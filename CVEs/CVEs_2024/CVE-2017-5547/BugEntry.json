{"buggy_code": ["/*\n * HID driver for Corsair devices\n *\n * Supported devices:\n *  - Vengeance K90 Keyboard\n *\n * Copyright (c) 2015 Clement Vuchener\n */\n\n/*\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 2 of the License, or (at your option)\n * any later version.\n */\n\n#include <linux/hid.h>\n#include <linux/module.h>\n#include <linux/usb.h>\n#include <linux/leds.h>\n\n#include \"hid-ids.h\"\n\n#define CORSAIR_USE_K90_MACRO\t(1<<0)\n#define CORSAIR_USE_K90_BACKLIGHT\t(1<<1)\n\nstruct k90_led {\n\tstruct led_classdev cdev;\n\tint brightness;\n\tstruct work_struct work;\n\tbool removed;\n};\n\nstruct k90_drvdata {\n\tstruct k90_led record_led;\n};\n\nstruct corsair_drvdata {\n\tunsigned long quirks;\n\tstruct k90_drvdata *k90;\n\tstruct k90_led *backlight;\n};\n\n#define K90_GKEY_COUNT\t18\n\nstatic int corsair_usage_to_gkey(unsigned int usage)\n{\n\t/* G1 (0xd0) to G16 (0xdf) */\n\tif (usage >= 0xd0 && usage <= 0xdf)\n\t\treturn usage - 0xd0 + 1;\n\t/* G17 (0xe8) to G18 (0xe9) */\n\tif (usage >= 0xe8 && usage <= 0xe9)\n\t\treturn usage - 0xe8 + 17;\n\treturn 0;\n}\n\nstatic unsigned short corsair_gkey_map[K90_GKEY_COUNT] = {\n\tBTN_TRIGGER_HAPPY1,\n\tBTN_TRIGGER_HAPPY2,\n\tBTN_TRIGGER_HAPPY3,\n\tBTN_TRIGGER_HAPPY4,\n\tBTN_TRIGGER_HAPPY5,\n\tBTN_TRIGGER_HAPPY6,\n\tBTN_TRIGGER_HAPPY7,\n\tBTN_TRIGGER_HAPPY8,\n\tBTN_TRIGGER_HAPPY9,\n\tBTN_TRIGGER_HAPPY10,\n\tBTN_TRIGGER_HAPPY11,\n\tBTN_TRIGGER_HAPPY12,\n\tBTN_TRIGGER_HAPPY13,\n\tBTN_TRIGGER_HAPPY14,\n\tBTN_TRIGGER_HAPPY15,\n\tBTN_TRIGGER_HAPPY16,\n\tBTN_TRIGGER_HAPPY17,\n\tBTN_TRIGGER_HAPPY18,\n};\n\nmodule_param_array_named(gkey_codes, corsair_gkey_map, ushort, NULL, S_IRUGO);\nMODULE_PARM_DESC(gkey_codes, \"Key codes for the G-keys\");\n\nstatic unsigned short corsair_record_keycodes[2] = {\n\tBTN_TRIGGER_HAPPY19,\n\tBTN_TRIGGER_HAPPY20\n};\n\nmodule_param_array_named(recordkey_codes, corsair_record_keycodes, ushort,\n\t\t\t NULL, S_IRUGO);\nMODULE_PARM_DESC(recordkey_codes, \"Key codes for the MR (start and stop record) button\");\n\nstatic unsigned short corsair_profile_keycodes[3] = {\n\tBTN_TRIGGER_HAPPY21,\n\tBTN_TRIGGER_HAPPY22,\n\tBTN_TRIGGER_HAPPY23\n};\n\nmodule_param_array_named(profilekey_codes, corsair_profile_keycodes, ushort,\n\t\t\t NULL, S_IRUGO);\nMODULE_PARM_DESC(profilekey_codes, \"Key codes for the profile buttons\");\n\n#define CORSAIR_USAGE_SPECIAL_MIN 0xf0\n#define CORSAIR_USAGE_SPECIAL_MAX 0xff\n\n#define CORSAIR_USAGE_MACRO_RECORD_START 0xf6\n#define CORSAIR_USAGE_MACRO_RECORD_STOP 0xf7\n\n#define CORSAIR_USAGE_PROFILE 0xf1\n#define CORSAIR_USAGE_M1 0xf1\n#define CORSAIR_USAGE_M2 0xf2\n#define CORSAIR_USAGE_M3 0xf3\n#define CORSAIR_USAGE_PROFILE_MAX 0xf3\n\n#define CORSAIR_USAGE_META_OFF 0xf4\n#define CORSAIR_USAGE_META_ON  0xf5\n\n#define CORSAIR_USAGE_LIGHT 0xfa\n#define CORSAIR_USAGE_LIGHT_OFF 0xfa\n#define CORSAIR_USAGE_LIGHT_DIM 0xfb\n#define CORSAIR_USAGE_LIGHT_MEDIUM 0xfc\n#define CORSAIR_USAGE_LIGHT_BRIGHT 0xfd\n#define CORSAIR_USAGE_LIGHT_MAX 0xfd\n\n/* USB control protocol */\n\n#define K90_REQUEST_BRIGHTNESS 49\n#define K90_REQUEST_MACRO_MODE 2\n#define K90_REQUEST_STATUS 4\n#define K90_REQUEST_GET_MODE 5\n#define K90_REQUEST_PROFILE 20\n\n#define K90_MACRO_MODE_SW 0x0030\n#define K90_MACRO_MODE_HW 0x0001\n\n#define K90_MACRO_LED_ON  0x0020\n#define K90_MACRO_LED_OFF 0x0040\n\n/*\n * LED class devices\n */\n\n#define K90_BACKLIGHT_LED_SUFFIX \"::backlight\"\n#define K90_RECORD_LED_SUFFIX \"::record\"\n\nstatic enum led_brightness k90_backlight_get(struct led_classdev *led_cdev)\n{\n\tint ret;\n\tstruct k90_led *led = container_of(led_cdev, struct k90_led, cdev);\n\tstruct device *dev = led->cdev.dev->parent;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tint brightness;\n\tchar data[8];\n\n\tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_STATUS,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, 0, 0, data, 8,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"Failed to get K90 initial state (error %d).\\n\",\n\t\t\t ret);\n\t\treturn -EIO;\n\t}\n\tbrightness = data[4];\n\tif (brightness < 0 || brightness > 3) {\n\t\tdev_warn(dev,\n\t\t\t \"Read invalid backlight brightness: %02hhx.\\n\",\n\t\t\t data[4]);\n\t\treturn -EIO;\n\t}\n\treturn brightness;\n}\n\nstatic enum led_brightness k90_record_led_get(struct led_classdev *led_cdev)\n{\n\tstruct k90_led *led = container_of(led_cdev, struct k90_led, cdev);\n\n\treturn led->brightness;\n}\n\nstatic void k90_brightness_set(struct led_classdev *led_cdev,\n\t\t\t       enum led_brightness brightness)\n{\n\tstruct k90_led *led = container_of(led_cdev, struct k90_led, cdev);\n\n\tled->brightness = brightness;\n\tschedule_work(&led->work);\n}\n\nstatic void k90_backlight_work(struct work_struct *work)\n{\n\tint ret;\n\tstruct k90_led *led = container_of(work, struct k90_led, work);\n\tstruct device *dev;\n\tstruct usb_interface *usbif;\n\tstruct usb_device *usbdev;\n\n\tif (led->removed)\n\t\treturn;\n\n\tdev = led->cdev.dev->parent;\n\tusbif = to_usb_interface(dev->parent);\n\tusbdev = interface_to_usbdev(usbif);\n\n\tret = usb_control_msg(usbdev, usb_sndctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_BRIGHTNESS,\n\t\t\t      USB_DIR_OUT | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, led->brightness, 0,\n\t\t\t      NULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (ret != 0)\n\t\tdev_warn(dev, \"Failed to set backlight brightness (error: %d).\\n\",\n\t\t\t ret);\n}\n\nstatic void k90_record_led_work(struct work_struct *work)\n{\n\tint ret;\n\tstruct k90_led *led = container_of(work, struct k90_led, work);\n\tstruct device *dev;\n\tstruct usb_interface *usbif;\n\tstruct usb_device *usbdev;\n\tint value;\n\n\tif (led->removed)\n\t\treturn;\n\n\tdev = led->cdev.dev->parent;\n\tusbif = to_usb_interface(dev->parent);\n\tusbdev = interface_to_usbdev(usbif);\n\n\tif (led->brightness > 0)\n\t\tvalue = K90_MACRO_LED_ON;\n\telse\n\t\tvalue = K90_MACRO_LED_OFF;\n\n\tret = usb_control_msg(usbdev, usb_sndctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_MACRO_MODE,\n\t\t\t      USB_DIR_OUT | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, value, 0, NULL, 0,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret != 0)\n\t\tdev_warn(dev, \"Failed to set record LED state (error: %d).\\n\",\n\t\t\t ret);\n}\n\n/*\n * Keyboard attributes\n */\n\nstatic ssize_t k90_show_macro_mode(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tint ret;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tconst char *macro_mode;\n\tchar data[8];\n\n\tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_GET_MODE,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, 0, 0, data, 2,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"Failed to get K90 initial mode (error %d).\\n\",\n\t\t\t ret);\n\t\treturn -EIO;\n\t}\n\n\tswitch (data[0]) {\n\tcase K90_MACRO_MODE_HW:\n\t\tmacro_mode = \"HW\";\n\t\tbreak;\n\n\tcase K90_MACRO_MODE_SW:\n\t\tmacro_mode = \"SW\";\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(dev, \"K90 in unknown mode: %02hhx.\\n\",\n\t\t\t data[0]);\n\t\treturn -EIO;\n\t}\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", macro_mode);\n}\n\nstatic ssize_t k90_store_macro_mode(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tint ret;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\t__u16 value;\n\n\tif (strncmp(buf, \"SW\", 2) == 0)\n\t\tvalue = K90_MACRO_MODE_SW;\n\telse if (strncmp(buf, \"HW\", 2) == 0)\n\t\tvalue = K90_MACRO_MODE_HW;\n\telse\n\t\treturn -EINVAL;\n\n\tret = usb_control_msg(usbdev, usb_sndctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_MACRO_MODE,\n\t\t\t      USB_DIR_OUT | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, value, 0, NULL, 0,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret != 0) {\n\t\tdev_warn(dev, \"Failed to set macro mode.\\n\");\n\t\treturn ret;\n\t}\n\n\treturn count;\n}\n\nstatic ssize_t k90_show_current_profile(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tint ret;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tint current_profile;\n\tchar data[8];\n\n\tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_STATUS,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, 0, 0, data, 8,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"Failed to get K90 initial state (error %d).\\n\",\n\t\t\t ret);\n\t\treturn -EIO;\n\t}\n\tcurrent_profile = data[7];\n\tif (current_profile < 1 || current_profile > 3) {\n\t\tdev_warn(dev, \"Read invalid current profile: %02hhx.\\n\",\n\t\t\t data[7]);\n\t\treturn -EIO;\n\t}\n\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", current_profile);\n}\n\nstatic ssize_t k90_store_current_profile(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t const char *buf, size_t count)\n{\n\tint ret;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tint profile;\n\n\tif (kstrtoint(buf, 10, &profile))\n\t\treturn -EINVAL;\n\tif (profile < 1 || profile > 3)\n\t\treturn -EINVAL;\n\n\tret = usb_control_msg(usbdev, usb_sndctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_PROFILE,\n\t\t\t      USB_DIR_OUT | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, profile, 0, NULL, 0,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret != 0) {\n\t\tdev_warn(dev, \"Failed to change current profile (error %d).\\n\",\n\t\t\t ret);\n\t\treturn ret;\n\t}\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(macro_mode, 0644, k90_show_macro_mode, k90_store_macro_mode);\nstatic DEVICE_ATTR(current_profile, 0644, k90_show_current_profile,\n\t\t   k90_store_current_profile);\n\nstatic struct attribute *k90_attrs[] = {\n\t&dev_attr_macro_mode.attr,\n\t&dev_attr_current_profile.attr,\n\tNULL\n};\n\nstatic const struct attribute_group k90_attr_group = {\n\t.attrs = k90_attrs,\n};\n\n/*\n * Driver functions\n */\n\nstatic int k90_init_backlight(struct hid_device *dev)\n{\n\tint ret;\n\tstruct corsair_drvdata *drvdata = hid_get_drvdata(dev);\n\tsize_t name_sz;\n\tchar *name;\n\n\tdrvdata->backlight = kzalloc(sizeof(struct k90_led), GFP_KERNEL);\n\tif (!drvdata->backlight) {\n\t\tret = -ENOMEM;\n\t\tgoto fail_backlight_alloc;\n\t}\n\n\tname_sz =\n\t    strlen(dev_name(&dev->dev)) + sizeof(K90_BACKLIGHT_LED_SUFFIX);\n\tname = kzalloc(name_sz, GFP_KERNEL);\n\tif (!name) {\n\t\tret = -ENOMEM;\n\t\tgoto fail_name_alloc;\n\t}\n\tsnprintf(name, name_sz, \"%s\" K90_BACKLIGHT_LED_SUFFIX,\n\t\t dev_name(&dev->dev));\n\tdrvdata->backlight->removed = false;\n\tdrvdata->backlight->cdev.name = name;\n\tdrvdata->backlight->cdev.max_brightness = 3;\n\tdrvdata->backlight->cdev.brightness_set = k90_brightness_set;\n\tdrvdata->backlight->cdev.brightness_get = k90_backlight_get;\n\tINIT_WORK(&drvdata->backlight->work, k90_backlight_work);\n\tret = led_classdev_register(&dev->dev, &drvdata->backlight->cdev);\n\tif (ret != 0)\n\t\tgoto fail_register_cdev;\n\n\treturn 0;\n\nfail_register_cdev:\n\tkfree(drvdata->backlight->cdev.name);\nfail_name_alloc:\n\tkfree(drvdata->backlight);\n\tdrvdata->backlight = NULL;\nfail_backlight_alloc:\n\treturn ret;\n}\n\nstatic int k90_init_macro_functions(struct hid_device *dev)\n{\n\tint ret;\n\tstruct corsair_drvdata *drvdata = hid_get_drvdata(dev);\n\tstruct k90_drvdata *k90;\n\tsize_t name_sz;\n\tchar *name;\n\n\tk90 = kzalloc(sizeof(struct k90_drvdata), GFP_KERNEL);\n\tif (!k90) {\n\t\tret = -ENOMEM;\n\t\tgoto fail_drvdata;\n\t}\n\tdrvdata->k90 = k90;\n\n\t/* Init LED device for record LED */\n\tname_sz = strlen(dev_name(&dev->dev)) + sizeof(K90_RECORD_LED_SUFFIX);\n\tname = kzalloc(name_sz, GFP_KERNEL);\n\tif (!name) {\n\t\tret = -ENOMEM;\n\t\tgoto fail_record_led_alloc;\n\t}\n\tsnprintf(name, name_sz, \"%s\" K90_RECORD_LED_SUFFIX,\n\t\t dev_name(&dev->dev));\n\tk90->record_led.removed = false;\n\tk90->record_led.cdev.name = name;\n\tk90->record_led.cdev.max_brightness = 1;\n\tk90->record_led.cdev.brightness_set = k90_brightness_set;\n\tk90->record_led.cdev.brightness_get = k90_record_led_get;\n\tINIT_WORK(&k90->record_led.work, k90_record_led_work);\n\tk90->record_led.brightness = 0;\n\tret = led_classdev_register(&dev->dev, &k90->record_led.cdev);\n\tif (ret != 0)\n\t\tgoto fail_record_led;\n\n\t/* Init attributes */\n\tret = sysfs_create_group(&dev->dev.kobj, &k90_attr_group);\n\tif (ret != 0)\n\t\tgoto fail_sysfs;\n\n\treturn 0;\n\nfail_sysfs:\n\tk90->record_led.removed = true;\n\tled_classdev_unregister(&k90->record_led.cdev);\n\tcancel_work_sync(&k90->record_led.work);\nfail_record_led:\n\tkfree(k90->record_led.cdev.name);\nfail_record_led_alloc:\n\tkfree(k90);\nfail_drvdata:\n\tdrvdata->k90 = NULL;\n\treturn ret;\n}\n\nstatic void k90_cleanup_backlight(struct hid_device *dev)\n{\n\tstruct corsair_drvdata *drvdata = hid_get_drvdata(dev);\n\n\tif (drvdata->backlight) {\n\t\tdrvdata->backlight->removed = true;\n\t\tled_classdev_unregister(&drvdata->backlight->cdev);\n\t\tcancel_work_sync(&drvdata->backlight->work);\n\t\tkfree(drvdata->backlight->cdev.name);\n\t\tkfree(drvdata->backlight);\n\t}\n}\n\nstatic void k90_cleanup_macro_functions(struct hid_device *dev)\n{\n\tstruct corsair_drvdata *drvdata = hid_get_drvdata(dev);\n\tstruct k90_drvdata *k90 = drvdata->k90;\n\n\tif (k90) {\n\t\tsysfs_remove_group(&dev->dev.kobj, &k90_attr_group);\n\n\t\tk90->record_led.removed = true;\n\t\tled_classdev_unregister(&k90->record_led.cdev);\n\t\tcancel_work_sync(&k90->record_led.work);\n\t\tkfree(k90->record_led.cdev.name);\n\n\t\tkfree(k90);\n\t}\n}\n\nstatic int corsair_probe(struct hid_device *dev, const struct hid_device_id *id)\n{\n\tint ret;\n\tunsigned long quirks = id->driver_data;\n\tstruct corsair_drvdata *drvdata;\n\tstruct usb_interface *usbif = to_usb_interface(dev->dev.parent);\n\n\tdrvdata = devm_kzalloc(&dev->dev, sizeof(struct corsair_drvdata),\n\t\t\t       GFP_KERNEL);\n\tif (drvdata == NULL)\n\t\treturn -ENOMEM;\n\tdrvdata->quirks = quirks;\n\thid_set_drvdata(dev, drvdata);\n\n\tret = hid_parse(dev);\n\tif (ret != 0) {\n\t\thid_err(dev, \"parse failed\\n\");\n\t\treturn ret;\n\t}\n\tret = hid_hw_start(dev, HID_CONNECT_DEFAULT);\n\tif (ret != 0) {\n\t\thid_err(dev, \"hw start failed\\n\");\n\t\treturn ret;\n\t}\n\n\tif (usbif->cur_altsetting->desc.bInterfaceNumber == 0) {\n\t\tif (quirks & CORSAIR_USE_K90_MACRO) {\n\t\t\tret = k90_init_macro_functions(dev);\n\t\t\tif (ret != 0)\n\t\t\t\thid_warn(dev, \"Failed to initialize K90 macro functions.\\n\");\n\t\t}\n\t\tif (quirks & CORSAIR_USE_K90_BACKLIGHT) {\n\t\t\tret = k90_init_backlight(dev);\n\t\t\tif (ret != 0)\n\t\t\t\thid_warn(dev, \"Failed to initialize K90 backlight.\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void corsair_remove(struct hid_device *dev)\n{\n\tk90_cleanup_macro_functions(dev);\n\tk90_cleanup_backlight(dev);\n\n\thid_hw_stop(dev);\n}\n\nstatic int corsair_event(struct hid_device *dev, struct hid_field *field,\n\t\t\t struct hid_usage *usage, __s32 value)\n{\n\tstruct corsair_drvdata *drvdata = hid_get_drvdata(dev);\n\n\tif (!drvdata->k90)\n\t\treturn 0;\n\n\tswitch (usage->hid & HID_USAGE) {\n\tcase CORSAIR_USAGE_MACRO_RECORD_START:\n\t\tdrvdata->k90->record_led.brightness = 1;\n\t\tbreak;\n\tcase CORSAIR_USAGE_MACRO_RECORD_STOP:\n\t\tdrvdata->k90->record_led.brightness = 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int corsair_input_mapping(struct hid_device *dev,\n\t\t\t\t struct hid_input *input,\n\t\t\t\t struct hid_field *field,\n\t\t\t\t struct hid_usage *usage, unsigned long **bit,\n\t\t\t\t int *max)\n{\n\tint gkey;\n\n\tif ((usage->hid & HID_USAGE_PAGE) != HID_UP_KEYBOARD)\n\t\treturn 0;\n\n\tgkey = corsair_usage_to_gkey(usage->hid & HID_USAGE);\n\tif (gkey != 0) {\n\t\thid_map_usage_clear(input, usage, bit, max, EV_KEY,\n\t\t\t\t    corsair_gkey_map[gkey - 1]);\n\t\treturn 1;\n\t}\n\tif ((usage->hid & HID_USAGE) >= CORSAIR_USAGE_SPECIAL_MIN &&\n\t    (usage->hid & HID_USAGE) <= CORSAIR_USAGE_SPECIAL_MAX) {\n\t\tswitch (usage->hid & HID_USAGE) {\n\t\tcase CORSAIR_USAGE_MACRO_RECORD_START:\n\t\t\thid_map_usage_clear(input, usage, bit, max, EV_KEY,\n\t\t\t\t\t    corsair_record_keycodes[0]);\n\t\t\treturn 1;\n\n\t\tcase CORSAIR_USAGE_MACRO_RECORD_STOP:\n\t\t\thid_map_usage_clear(input, usage, bit, max, EV_KEY,\n\t\t\t\t\t    corsair_record_keycodes[1]);\n\t\t\treturn 1;\n\n\t\tcase CORSAIR_USAGE_M1:\n\t\t\thid_map_usage_clear(input, usage, bit, max, EV_KEY,\n\t\t\t\t\t    corsair_profile_keycodes[0]);\n\t\t\treturn 1;\n\n\t\tcase CORSAIR_USAGE_M2:\n\t\t\thid_map_usage_clear(input, usage, bit, max, EV_KEY,\n\t\t\t\t\t    corsair_profile_keycodes[1]);\n\t\t\treturn 1;\n\n\t\tcase CORSAIR_USAGE_M3:\n\t\t\thid_map_usage_clear(input, usage, bit, max, EV_KEY,\n\t\t\t\t\t    corsair_profile_keycodes[2]);\n\t\t\treturn 1;\n\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct hid_device_id corsair_devices[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CORSAIR, USB_DEVICE_ID_CORSAIR_K90),\n\t\t.driver_data = CORSAIR_USE_K90_MACRO |\n\t\t\t       CORSAIR_USE_K90_BACKLIGHT },\n\t{}\n};\n\nMODULE_DEVICE_TABLE(hid, corsair_devices);\n\nstatic struct hid_driver corsair_driver = {\n\t.name = \"corsair\",\n\t.id_table = corsair_devices,\n\t.probe = corsair_probe,\n\t.event = corsair_event,\n\t.remove = corsair_remove,\n\t.input_mapping = corsair_input_mapping,\n};\n\nmodule_hid_driver(corsair_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Clement Vuchener\");\nMODULE_DESCRIPTION(\"HID driver for Corsair devices\");\n"], "fixing_code": ["/*\n * HID driver for Corsair devices\n *\n * Supported devices:\n *  - Vengeance K90 Keyboard\n *\n * Copyright (c) 2015 Clement Vuchener\n */\n\n/*\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 2 of the License, or (at your option)\n * any later version.\n */\n\n#include <linux/hid.h>\n#include <linux/module.h>\n#include <linux/usb.h>\n#include <linux/leds.h>\n\n#include \"hid-ids.h\"\n\n#define CORSAIR_USE_K90_MACRO\t(1<<0)\n#define CORSAIR_USE_K90_BACKLIGHT\t(1<<1)\n\nstruct k90_led {\n\tstruct led_classdev cdev;\n\tint brightness;\n\tstruct work_struct work;\n\tbool removed;\n};\n\nstruct k90_drvdata {\n\tstruct k90_led record_led;\n};\n\nstruct corsair_drvdata {\n\tunsigned long quirks;\n\tstruct k90_drvdata *k90;\n\tstruct k90_led *backlight;\n};\n\n#define K90_GKEY_COUNT\t18\n\nstatic int corsair_usage_to_gkey(unsigned int usage)\n{\n\t/* G1 (0xd0) to G16 (0xdf) */\n\tif (usage >= 0xd0 && usage <= 0xdf)\n\t\treturn usage - 0xd0 + 1;\n\t/* G17 (0xe8) to G18 (0xe9) */\n\tif (usage >= 0xe8 && usage <= 0xe9)\n\t\treturn usage - 0xe8 + 17;\n\treturn 0;\n}\n\nstatic unsigned short corsair_gkey_map[K90_GKEY_COUNT] = {\n\tBTN_TRIGGER_HAPPY1,\n\tBTN_TRIGGER_HAPPY2,\n\tBTN_TRIGGER_HAPPY3,\n\tBTN_TRIGGER_HAPPY4,\n\tBTN_TRIGGER_HAPPY5,\n\tBTN_TRIGGER_HAPPY6,\n\tBTN_TRIGGER_HAPPY7,\n\tBTN_TRIGGER_HAPPY8,\n\tBTN_TRIGGER_HAPPY9,\n\tBTN_TRIGGER_HAPPY10,\n\tBTN_TRIGGER_HAPPY11,\n\tBTN_TRIGGER_HAPPY12,\n\tBTN_TRIGGER_HAPPY13,\n\tBTN_TRIGGER_HAPPY14,\n\tBTN_TRIGGER_HAPPY15,\n\tBTN_TRIGGER_HAPPY16,\n\tBTN_TRIGGER_HAPPY17,\n\tBTN_TRIGGER_HAPPY18,\n};\n\nmodule_param_array_named(gkey_codes, corsair_gkey_map, ushort, NULL, S_IRUGO);\nMODULE_PARM_DESC(gkey_codes, \"Key codes for the G-keys\");\n\nstatic unsigned short corsair_record_keycodes[2] = {\n\tBTN_TRIGGER_HAPPY19,\n\tBTN_TRIGGER_HAPPY20\n};\n\nmodule_param_array_named(recordkey_codes, corsair_record_keycodes, ushort,\n\t\t\t NULL, S_IRUGO);\nMODULE_PARM_DESC(recordkey_codes, \"Key codes for the MR (start and stop record) button\");\n\nstatic unsigned short corsair_profile_keycodes[3] = {\n\tBTN_TRIGGER_HAPPY21,\n\tBTN_TRIGGER_HAPPY22,\n\tBTN_TRIGGER_HAPPY23\n};\n\nmodule_param_array_named(profilekey_codes, corsair_profile_keycodes, ushort,\n\t\t\t NULL, S_IRUGO);\nMODULE_PARM_DESC(profilekey_codes, \"Key codes for the profile buttons\");\n\n#define CORSAIR_USAGE_SPECIAL_MIN 0xf0\n#define CORSAIR_USAGE_SPECIAL_MAX 0xff\n\n#define CORSAIR_USAGE_MACRO_RECORD_START 0xf6\n#define CORSAIR_USAGE_MACRO_RECORD_STOP 0xf7\n\n#define CORSAIR_USAGE_PROFILE 0xf1\n#define CORSAIR_USAGE_M1 0xf1\n#define CORSAIR_USAGE_M2 0xf2\n#define CORSAIR_USAGE_M3 0xf3\n#define CORSAIR_USAGE_PROFILE_MAX 0xf3\n\n#define CORSAIR_USAGE_META_OFF 0xf4\n#define CORSAIR_USAGE_META_ON  0xf5\n\n#define CORSAIR_USAGE_LIGHT 0xfa\n#define CORSAIR_USAGE_LIGHT_OFF 0xfa\n#define CORSAIR_USAGE_LIGHT_DIM 0xfb\n#define CORSAIR_USAGE_LIGHT_MEDIUM 0xfc\n#define CORSAIR_USAGE_LIGHT_BRIGHT 0xfd\n#define CORSAIR_USAGE_LIGHT_MAX 0xfd\n\n/* USB control protocol */\n\n#define K90_REQUEST_BRIGHTNESS 49\n#define K90_REQUEST_MACRO_MODE 2\n#define K90_REQUEST_STATUS 4\n#define K90_REQUEST_GET_MODE 5\n#define K90_REQUEST_PROFILE 20\n\n#define K90_MACRO_MODE_SW 0x0030\n#define K90_MACRO_MODE_HW 0x0001\n\n#define K90_MACRO_LED_ON  0x0020\n#define K90_MACRO_LED_OFF 0x0040\n\n/*\n * LED class devices\n */\n\n#define K90_BACKLIGHT_LED_SUFFIX \"::backlight\"\n#define K90_RECORD_LED_SUFFIX \"::record\"\n\nstatic enum led_brightness k90_backlight_get(struct led_classdev *led_cdev)\n{\n\tint ret;\n\tstruct k90_led *led = container_of(led_cdev, struct k90_led, cdev);\n\tstruct device *dev = led->cdev.dev->parent;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tint brightness;\n\tchar *data;\n\n\tdata = kmalloc(8, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_STATUS,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, 0, 0, data, 8,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"Failed to get K90 initial state (error %d).\\n\",\n\t\t\t ret);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\tbrightness = data[4];\n\tif (brightness < 0 || brightness > 3) {\n\t\tdev_warn(dev,\n\t\t\t \"Read invalid backlight brightness: %02hhx.\\n\",\n\t\t\t data[4]);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\tret = brightness;\nout:\n\tkfree(data);\n\n\treturn ret;\n}\n\nstatic enum led_brightness k90_record_led_get(struct led_classdev *led_cdev)\n{\n\tstruct k90_led *led = container_of(led_cdev, struct k90_led, cdev);\n\n\treturn led->brightness;\n}\n\nstatic void k90_brightness_set(struct led_classdev *led_cdev,\n\t\t\t       enum led_brightness brightness)\n{\n\tstruct k90_led *led = container_of(led_cdev, struct k90_led, cdev);\n\n\tled->brightness = brightness;\n\tschedule_work(&led->work);\n}\n\nstatic void k90_backlight_work(struct work_struct *work)\n{\n\tint ret;\n\tstruct k90_led *led = container_of(work, struct k90_led, work);\n\tstruct device *dev;\n\tstruct usb_interface *usbif;\n\tstruct usb_device *usbdev;\n\n\tif (led->removed)\n\t\treturn;\n\n\tdev = led->cdev.dev->parent;\n\tusbif = to_usb_interface(dev->parent);\n\tusbdev = interface_to_usbdev(usbif);\n\n\tret = usb_control_msg(usbdev, usb_sndctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_BRIGHTNESS,\n\t\t\t      USB_DIR_OUT | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, led->brightness, 0,\n\t\t\t      NULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (ret != 0)\n\t\tdev_warn(dev, \"Failed to set backlight brightness (error: %d).\\n\",\n\t\t\t ret);\n}\n\nstatic void k90_record_led_work(struct work_struct *work)\n{\n\tint ret;\n\tstruct k90_led *led = container_of(work, struct k90_led, work);\n\tstruct device *dev;\n\tstruct usb_interface *usbif;\n\tstruct usb_device *usbdev;\n\tint value;\n\n\tif (led->removed)\n\t\treturn;\n\n\tdev = led->cdev.dev->parent;\n\tusbif = to_usb_interface(dev->parent);\n\tusbdev = interface_to_usbdev(usbif);\n\n\tif (led->brightness > 0)\n\t\tvalue = K90_MACRO_LED_ON;\n\telse\n\t\tvalue = K90_MACRO_LED_OFF;\n\n\tret = usb_control_msg(usbdev, usb_sndctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_MACRO_MODE,\n\t\t\t      USB_DIR_OUT | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, value, 0, NULL, 0,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret != 0)\n\t\tdev_warn(dev, \"Failed to set record LED state (error: %d).\\n\",\n\t\t\t ret);\n}\n\n/*\n * Keyboard attributes\n */\n\nstatic ssize_t k90_show_macro_mode(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tint ret;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tconst char *macro_mode;\n\tchar *data;\n\n\tdata = kmalloc(2, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_GET_MODE,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, 0, 0, data, 2,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"Failed to get K90 initial mode (error %d).\\n\",\n\t\t\t ret);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tswitch (data[0]) {\n\tcase K90_MACRO_MODE_HW:\n\t\tmacro_mode = \"HW\";\n\t\tbreak;\n\n\tcase K90_MACRO_MODE_SW:\n\t\tmacro_mode = \"SW\";\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(dev, \"K90 in unknown mode: %02hhx.\\n\",\n\t\t\t data[0]);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tret = snprintf(buf, PAGE_SIZE, \"%s\\n\", macro_mode);\nout:\n\tkfree(data);\n\n\treturn ret;\n}\n\nstatic ssize_t k90_store_macro_mode(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tint ret;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\t__u16 value;\n\n\tif (strncmp(buf, \"SW\", 2) == 0)\n\t\tvalue = K90_MACRO_MODE_SW;\n\telse if (strncmp(buf, \"HW\", 2) == 0)\n\t\tvalue = K90_MACRO_MODE_HW;\n\telse\n\t\treturn -EINVAL;\n\n\tret = usb_control_msg(usbdev, usb_sndctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_MACRO_MODE,\n\t\t\t      USB_DIR_OUT | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, value, 0, NULL, 0,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret != 0) {\n\t\tdev_warn(dev, \"Failed to set macro mode.\\n\");\n\t\treturn ret;\n\t}\n\n\treturn count;\n}\n\nstatic ssize_t k90_show_current_profile(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tint ret;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tint current_profile;\n\tchar *data;\n\n\tdata = kmalloc(8, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_STATUS,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, 0, 0, data, 8,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"Failed to get K90 initial state (error %d).\\n\",\n\t\t\t ret);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\tcurrent_profile = data[7];\n\tif (current_profile < 1 || current_profile > 3) {\n\t\tdev_warn(dev, \"Read invalid current profile: %02hhx.\\n\",\n\t\t\t data[7]);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tret = snprintf(buf, PAGE_SIZE, \"%d\\n\", current_profile);\nout:\n\tkfree(data);\n\n\treturn ret;\n}\n\nstatic ssize_t k90_store_current_profile(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t const char *buf, size_t count)\n{\n\tint ret;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tint profile;\n\n\tif (kstrtoint(buf, 10, &profile))\n\t\treturn -EINVAL;\n\tif (profile < 1 || profile > 3)\n\t\treturn -EINVAL;\n\n\tret = usb_control_msg(usbdev, usb_sndctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_PROFILE,\n\t\t\t      USB_DIR_OUT | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, profile, 0, NULL, 0,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret != 0) {\n\t\tdev_warn(dev, \"Failed to change current profile (error %d).\\n\",\n\t\t\t ret);\n\t\treturn ret;\n\t}\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(macro_mode, 0644, k90_show_macro_mode, k90_store_macro_mode);\nstatic DEVICE_ATTR(current_profile, 0644, k90_show_current_profile,\n\t\t   k90_store_current_profile);\n\nstatic struct attribute *k90_attrs[] = {\n\t&dev_attr_macro_mode.attr,\n\t&dev_attr_current_profile.attr,\n\tNULL\n};\n\nstatic const struct attribute_group k90_attr_group = {\n\t.attrs = k90_attrs,\n};\n\n/*\n * Driver functions\n */\n\nstatic int k90_init_backlight(struct hid_device *dev)\n{\n\tint ret;\n\tstruct corsair_drvdata *drvdata = hid_get_drvdata(dev);\n\tsize_t name_sz;\n\tchar *name;\n\n\tdrvdata->backlight = kzalloc(sizeof(struct k90_led), GFP_KERNEL);\n\tif (!drvdata->backlight) {\n\t\tret = -ENOMEM;\n\t\tgoto fail_backlight_alloc;\n\t}\n\n\tname_sz =\n\t    strlen(dev_name(&dev->dev)) + sizeof(K90_BACKLIGHT_LED_SUFFIX);\n\tname = kzalloc(name_sz, GFP_KERNEL);\n\tif (!name) {\n\t\tret = -ENOMEM;\n\t\tgoto fail_name_alloc;\n\t}\n\tsnprintf(name, name_sz, \"%s\" K90_BACKLIGHT_LED_SUFFIX,\n\t\t dev_name(&dev->dev));\n\tdrvdata->backlight->removed = false;\n\tdrvdata->backlight->cdev.name = name;\n\tdrvdata->backlight->cdev.max_brightness = 3;\n\tdrvdata->backlight->cdev.brightness_set = k90_brightness_set;\n\tdrvdata->backlight->cdev.brightness_get = k90_backlight_get;\n\tINIT_WORK(&drvdata->backlight->work, k90_backlight_work);\n\tret = led_classdev_register(&dev->dev, &drvdata->backlight->cdev);\n\tif (ret != 0)\n\t\tgoto fail_register_cdev;\n\n\treturn 0;\n\nfail_register_cdev:\n\tkfree(drvdata->backlight->cdev.name);\nfail_name_alloc:\n\tkfree(drvdata->backlight);\n\tdrvdata->backlight = NULL;\nfail_backlight_alloc:\n\treturn ret;\n}\n\nstatic int k90_init_macro_functions(struct hid_device *dev)\n{\n\tint ret;\n\tstruct corsair_drvdata *drvdata = hid_get_drvdata(dev);\n\tstruct k90_drvdata *k90;\n\tsize_t name_sz;\n\tchar *name;\n\n\tk90 = kzalloc(sizeof(struct k90_drvdata), GFP_KERNEL);\n\tif (!k90) {\n\t\tret = -ENOMEM;\n\t\tgoto fail_drvdata;\n\t}\n\tdrvdata->k90 = k90;\n\n\t/* Init LED device for record LED */\n\tname_sz = strlen(dev_name(&dev->dev)) + sizeof(K90_RECORD_LED_SUFFIX);\n\tname = kzalloc(name_sz, GFP_KERNEL);\n\tif (!name) {\n\t\tret = -ENOMEM;\n\t\tgoto fail_record_led_alloc;\n\t}\n\tsnprintf(name, name_sz, \"%s\" K90_RECORD_LED_SUFFIX,\n\t\t dev_name(&dev->dev));\n\tk90->record_led.removed = false;\n\tk90->record_led.cdev.name = name;\n\tk90->record_led.cdev.max_brightness = 1;\n\tk90->record_led.cdev.brightness_set = k90_brightness_set;\n\tk90->record_led.cdev.brightness_get = k90_record_led_get;\n\tINIT_WORK(&k90->record_led.work, k90_record_led_work);\n\tk90->record_led.brightness = 0;\n\tret = led_classdev_register(&dev->dev, &k90->record_led.cdev);\n\tif (ret != 0)\n\t\tgoto fail_record_led;\n\n\t/* Init attributes */\n\tret = sysfs_create_group(&dev->dev.kobj, &k90_attr_group);\n\tif (ret != 0)\n\t\tgoto fail_sysfs;\n\n\treturn 0;\n\nfail_sysfs:\n\tk90->record_led.removed = true;\n\tled_classdev_unregister(&k90->record_led.cdev);\n\tcancel_work_sync(&k90->record_led.work);\nfail_record_led:\n\tkfree(k90->record_led.cdev.name);\nfail_record_led_alloc:\n\tkfree(k90);\nfail_drvdata:\n\tdrvdata->k90 = NULL;\n\treturn ret;\n}\n\nstatic void k90_cleanup_backlight(struct hid_device *dev)\n{\n\tstruct corsair_drvdata *drvdata = hid_get_drvdata(dev);\n\n\tif (drvdata->backlight) {\n\t\tdrvdata->backlight->removed = true;\n\t\tled_classdev_unregister(&drvdata->backlight->cdev);\n\t\tcancel_work_sync(&drvdata->backlight->work);\n\t\tkfree(drvdata->backlight->cdev.name);\n\t\tkfree(drvdata->backlight);\n\t}\n}\n\nstatic void k90_cleanup_macro_functions(struct hid_device *dev)\n{\n\tstruct corsair_drvdata *drvdata = hid_get_drvdata(dev);\n\tstruct k90_drvdata *k90 = drvdata->k90;\n\n\tif (k90) {\n\t\tsysfs_remove_group(&dev->dev.kobj, &k90_attr_group);\n\n\t\tk90->record_led.removed = true;\n\t\tled_classdev_unregister(&k90->record_led.cdev);\n\t\tcancel_work_sync(&k90->record_led.work);\n\t\tkfree(k90->record_led.cdev.name);\n\n\t\tkfree(k90);\n\t}\n}\n\nstatic int corsair_probe(struct hid_device *dev, const struct hid_device_id *id)\n{\n\tint ret;\n\tunsigned long quirks = id->driver_data;\n\tstruct corsair_drvdata *drvdata;\n\tstruct usb_interface *usbif = to_usb_interface(dev->dev.parent);\n\n\tdrvdata = devm_kzalloc(&dev->dev, sizeof(struct corsair_drvdata),\n\t\t\t       GFP_KERNEL);\n\tif (drvdata == NULL)\n\t\treturn -ENOMEM;\n\tdrvdata->quirks = quirks;\n\thid_set_drvdata(dev, drvdata);\n\n\tret = hid_parse(dev);\n\tif (ret != 0) {\n\t\thid_err(dev, \"parse failed\\n\");\n\t\treturn ret;\n\t}\n\tret = hid_hw_start(dev, HID_CONNECT_DEFAULT);\n\tif (ret != 0) {\n\t\thid_err(dev, \"hw start failed\\n\");\n\t\treturn ret;\n\t}\n\n\tif (usbif->cur_altsetting->desc.bInterfaceNumber == 0) {\n\t\tif (quirks & CORSAIR_USE_K90_MACRO) {\n\t\t\tret = k90_init_macro_functions(dev);\n\t\t\tif (ret != 0)\n\t\t\t\thid_warn(dev, \"Failed to initialize K90 macro functions.\\n\");\n\t\t}\n\t\tif (quirks & CORSAIR_USE_K90_BACKLIGHT) {\n\t\t\tret = k90_init_backlight(dev);\n\t\t\tif (ret != 0)\n\t\t\t\thid_warn(dev, \"Failed to initialize K90 backlight.\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void corsair_remove(struct hid_device *dev)\n{\n\tk90_cleanup_macro_functions(dev);\n\tk90_cleanup_backlight(dev);\n\n\thid_hw_stop(dev);\n}\n\nstatic int corsair_event(struct hid_device *dev, struct hid_field *field,\n\t\t\t struct hid_usage *usage, __s32 value)\n{\n\tstruct corsair_drvdata *drvdata = hid_get_drvdata(dev);\n\n\tif (!drvdata->k90)\n\t\treturn 0;\n\n\tswitch (usage->hid & HID_USAGE) {\n\tcase CORSAIR_USAGE_MACRO_RECORD_START:\n\t\tdrvdata->k90->record_led.brightness = 1;\n\t\tbreak;\n\tcase CORSAIR_USAGE_MACRO_RECORD_STOP:\n\t\tdrvdata->k90->record_led.brightness = 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int corsair_input_mapping(struct hid_device *dev,\n\t\t\t\t struct hid_input *input,\n\t\t\t\t struct hid_field *field,\n\t\t\t\t struct hid_usage *usage, unsigned long **bit,\n\t\t\t\t int *max)\n{\n\tint gkey;\n\n\tif ((usage->hid & HID_USAGE_PAGE) != HID_UP_KEYBOARD)\n\t\treturn 0;\n\n\tgkey = corsair_usage_to_gkey(usage->hid & HID_USAGE);\n\tif (gkey != 0) {\n\t\thid_map_usage_clear(input, usage, bit, max, EV_KEY,\n\t\t\t\t    corsair_gkey_map[gkey - 1]);\n\t\treturn 1;\n\t}\n\tif ((usage->hid & HID_USAGE) >= CORSAIR_USAGE_SPECIAL_MIN &&\n\t    (usage->hid & HID_USAGE) <= CORSAIR_USAGE_SPECIAL_MAX) {\n\t\tswitch (usage->hid & HID_USAGE) {\n\t\tcase CORSAIR_USAGE_MACRO_RECORD_START:\n\t\t\thid_map_usage_clear(input, usage, bit, max, EV_KEY,\n\t\t\t\t\t    corsair_record_keycodes[0]);\n\t\t\treturn 1;\n\n\t\tcase CORSAIR_USAGE_MACRO_RECORD_STOP:\n\t\t\thid_map_usage_clear(input, usage, bit, max, EV_KEY,\n\t\t\t\t\t    corsair_record_keycodes[1]);\n\t\t\treturn 1;\n\n\t\tcase CORSAIR_USAGE_M1:\n\t\t\thid_map_usage_clear(input, usage, bit, max, EV_KEY,\n\t\t\t\t\t    corsair_profile_keycodes[0]);\n\t\t\treturn 1;\n\n\t\tcase CORSAIR_USAGE_M2:\n\t\t\thid_map_usage_clear(input, usage, bit, max, EV_KEY,\n\t\t\t\t\t    corsair_profile_keycodes[1]);\n\t\t\treturn 1;\n\n\t\tcase CORSAIR_USAGE_M3:\n\t\t\thid_map_usage_clear(input, usage, bit, max, EV_KEY,\n\t\t\t\t\t    corsair_profile_keycodes[2]);\n\t\t\treturn 1;\n\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct hid_device_id corsair_devices[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CORSAIR, USB_DEVICE_ID_CORSAIR_K90),\n\t\t.driver_data = CORSAIR_USE_K90_MACRO |\n\t\t\t       CORSAIR_USE_K90_BACKLIGHT },\n\t{}\n};\n\nMODULE_DEVICE_TABLE(hid, corsair_devices);\n\nstatic struct hid_driver corsair_driver = {\n\t.name = \"corsair\",\n\t.id_table = corsair_devices,\n\t.probe = corsair_probe,\n\t.event = corsair_event,\n\t.remove = corsair_remove,\n\t.input_mapping = corsair_input_mapping,\n};\n\nmodule_hid_driver(corsair_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Clement Vuchener\");\nMODULE_DESCRIPTION(\"HID driver for Corsair devices\");\n"], "filenames": ["drivers/hid/hid-corsair.c"], "buggy_code_start_loc": [151], "buggy_code_end_loc": [343], "fixing_code_start_loc": [151], "fixing_code_end_loc": [373], "type": "CWE-119", "message": "drivers/hid/hid-corsair.c in the Linux kernel 4.9.x before 4.9.6 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash or memory corruption) or possibly have unspecified other impact by leveraging use of more than one virtual page for a DMA scatterlist.", "other": {"cve": {"id": "CVE-2017-5547", "sourceIdentifier": "cve@mitre.org", "published": "2017-02-06T06:59:00.527", "lastModified": "2023-02-10T00:54:27.027", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "drivers/hid/hid-corsair.c in the Linux kernel 4.9.x before 4.9.6 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash or memory corruption) or possibly have unspecified other impact by leveraging use of more than one virtual page for a DMA scatterlist."}, {"lang": "es", "value": "drivers/hid/hid-corsair.c en el kernel de Linux 4.9.x antes 4.9.6 interact\u00faa incorrectamente con la opci\u00f3n CONFIG_VMAP_STACK, lo que permite a usuarios locales provocar una denegaci\u00f3n de servicio (ca\u00edda del sistema o corrupci\u00f3n de memoria) o posiblemente tener otro impacto no especificado aprovechando el uso de m\u00e1s de una p\u00e1gina virtual para una lista de dispersi\u00f3n de DMA."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.4", "versionEndExcluding": "4.4.45", "matchCriteriaId": "BAA44040-635E-42BC-834A-D2689F65038F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.5", "versionEndExcluding": "4.9.6", "matchCriteriaId": "6C4EC008-DEFD-4361-A4DA-8E99063FE606"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=6d104af38b570d37aa32a5803b04c354f8ed513d", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "http://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.9.6", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2017/01/21/3", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/95709", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1416096", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/torvalds/linux/commit/6d104af38b570d37aa32a5803b04c354f8ed513d", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/6d104af38b570d37aa32a5803b04c354f8ed513d"}}