{"buggy_code": ["/*\n * Copyright (C) 2004-2018 ZNC, see the NOTICE file for details.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <znc/WebModules.h>\n#include <znc/FileUtils.h>\n#include <znc/User.h>\n#include <znc/IRCNetwork.h>\n#include <znc/znc.h>\n#include <time.h>\n#include <algorithm>\n#include <sstream>\n\nusing std::pair;\nusing std::vector;\n\n/// @todo Do we want to make this a configure option?\n#define _SKINDIR_ _DATADIR_ \"/webskins\"\n\nconst unsigned int CWebSock::m_uiMaxSessions = 5;\n\n// We need this class to make sure the contained maps and their content is\n// destroyed in the order that we want.\nstruct CSessionManager {\n    // Sessions are valid for a day, (24h, ...)\n    CSessionManager() : m_mspSessions(24 * 60 * 60 * 1000), m_mIPSessions() {}\n    ~CSessionManager() {\n        // Make sure all sessions are destroyed before any of our maps\n        // are destroyed\n        m_mspSessions.Clear();\n    }\n\n    CWebSessionMap m_mspSessions;\n    std::multimap<CString, CWebSession*> m_mIPSessions;\n};\ntypedef std::multimap<CString, CWebSession*>::iterator mIPSessionsIterator;\n\nstatic CSessionManager Sessions;\n\nclass CWebAuth : public CAuthBase {\n  public:\n    CWebAuth(CWebSock* pWebSock, const CString& sUsername,\n             const CString& sPassword, bool bBasic);\n    ~CWebAuth() override {}\n\n    CWebAuth(const CWebAuth&) = delete;\n    CWebAuth& operator=(const CWebAuth&) = delete;\n\n    void SetWebSock(CWebSock* pWebSock) { m_pWebSock = pWebSock; }\n    void AcceptedLogin(CUser& User) override;\n    void RefusedLogin(const CString& sReason) override;\n    void Invalidate() override;\n\n  private:\n  protected:\n    CWebSock* m_pWebSock;\n    bool m_bBasic;\n};\n\nvoid CWebSock::FinishUserSessions(const CUser& User) {\n    Sessions.m_mspSessions.FinishUserSessions(User);\n}\n\nCWebSession::~CWebSession() {\n    // Find our entry in mIPSessions\n    pair<mIPSessionsIterator, mIPSessionsIterator> p =\n        Sessions.m_mIPSessions.equal_range(m_sIP);\n    mIPSessionsIterator it = p.first;\n    mIPSessionsIterator end = p.second;\n\n    while (it != end) {\n        if (it->second == this) {\n            Sessions.m_mIPSessions.erase(it++);\n        } else {\n            ++it;\n        }\n    }\n}\n\nCZNCTagHandler::CZNCTagHandler(CWebSock& WebSock)\n    : CTemplateTagHandler(), m_WebSock(WebSock) {}\n\nbool CZNCTagHandler::HandleTag(CTemplate& Tmpl, const CString& sName,\n                               const CString& sArgs, CString& sOutput) {\n    if (sName.Equals(\"URLPARAM\")) {\n        // sOutput = CZNC::Get()\n        sOutput = m_WebSock.GetParam(sArgs.Token(0), false);\n        return true;\n    }\n\n    return false;\n}\n\nCWebSession::CWebSession(const CString& sId, const CString& sIP)\n    : m_sId(sId),\n      m_sIP(sIP),\n      m_pUser(nullptr),\n      m_vsErrorMsgs(),\n      m_vsSuccessMsgs(),\n      m_tmLastActive() {\n    Sessions.m_mIPSessions.insert(make_pair(sIP, this));\n    UpdateLastActive();\n}\n\nvoid CWebSession::UpdateLastActive() { time(&m_tmLastActive); }\n\nbool CWebSession::IsAdmin() const { return IsLoggedIn() && m_pUser->IsAdmin(); }\n\nCWebAuth::CWebAuth(CWebSock* pWebSock, const CString& sUsername,\n                   const CString& sPassword, bool bBasic)\n    : CAuthBase(sUsername, sPassword, pWebSock),\n      m_pWebSock(pWebSock),\n      m_bBasic(bBasic) {}\n\nvoid CWebSession::ClearMessageLoops() {\n    m_vsErrorMsgs.clear();\n    m_vsSuccessMsgs.clear();\n}\n\nvoid CWebSession::FillMessageLoops(CTemplate& Tmpl) {\n    for (const CString& sMessage : m_vsErrorMsgs) {\n        CTemplate& Row = Tmpl.AddRow(\"ErrorLoop\");\n        Row[\"Message\"] = sMessage;\n    }\n\n    for (const CString& sMessage : m_vsSuccessMsgs) {\n        CTemplate& Row = Tmpl.AddRow(\"SuccessLoop\");\n        Row[\"Message\"] = sMessage;\n    }\n}\n\nsize_t CWebSession::AddError(const CString& sMessage) {\n    m_vsErrorMsgs.push_back(sMessage);\n    return m_vsErrorMsgs.size();\n}\n\nsize_t CWebSession::AddSuccess(const CString& sMessage) {\n    m_vsSuccessMsgs.push_back(sMessage);\n    return m_vsSuccessMsgs.size();\n}\n\nvoid CWebSessionMap::FinishUserSessions(const CUser& User) {\n    iterator it = m_mItems.begin();\n\n    while (it != m_mItems.end()) {\n        if (it->second.second->GetUser() == &User) {\n            m_mItems.erase(it++);\n        } else {\n            ++it;\n        }\n    }\n}\n\nvoid CWebAuth::AcceptedLogin(CUser& User) {\n    if (m_pWebSock) {\n        std::shared_ptr<CWebSession> spSession = m_pWebSock->GetSession();\n\n        spSession->SetUser(&User);\n\n        m_pWebSock->SetLoggedIn(true);\n        m_pWebSock->UnPauseRead();\n        if (m_bBasic) {\n            m_pWebSock->ReadLine(\"\");\n        } else {\n            m_pWebSock->Redirect(\"/?cookie_check=true\");\n        }\n\n        DEBUG(\"Successful login attempt ==> USER [\" + User.GetUserName() +\n              \"] ==> SESSION [\" + spSession->GetId() + \"]\");\n    }\n}\n\nvoid CWebAuth::RefusedLogin(const CString& sReason) {\n    if (m_pWebSock) {\n        std::shared_ptr<CWebSession> spSession = m_pWebSock->GetSession();\n\n        spSession->AddError(\"Invalid login!\");\n        spSession->SetUser(nullptr);\n\n        m_pWebSock->SetLoggedIn(false);\n        m_pWebSock->UnPauseRead();\n        if (m_bBasic) {\n            m_pWebSock->AddHeader(\"WWW-Authenticate\", \"Basic realm=\\\"ZNC\\\"\");\n            m_pWebSock->CHTTPSock::PrintErrorPage(\n                401, \"Unauthorized\",\n                \"HTTP Basic authentication attempted with invalid credentials\");\n            // Why CWebSock makes this function protected?..\n        } else {\n            m_pWebSock->Redirect(\"/?cookie_check=true\");\n        }\n\n        DEBUG(\"UNSUCCESSFUL login attempt ==> REASON [\" + sReason +\n              \"] ==> SESSION [\" + spSession->GetId() + \"]\");\n    }\n}\n\nvoid CWebAuth::Invalidate() {\n    CAuthBase::Invalidate();\n    m_pWebSock = nullptr;\n}\n\nCWebSock::CWebSock(const CString& sURIPrefix)\n    : CHTTPSock(nullptr, sURIPrefix),\n      m_bPathsSet(false),\n      m_Template(),\n      m_spAuth(),\n      m_sModName(\"\"),\n      m_sPath(\"\"),\n      m_sPage(\"\"),\n      m_spSession() {\n    m_Template.AddTagHandler(std::make_shared<CZNCTagHandler>(*this));\n}\n\nCWebSock::~CWebSock() {\n    if (m_spAuth) {\n        m_spAuth->Invalidate();\n    }\n\n    // we have to account for traffic here because CSocket does\n    // not have a valid CModule* pointer.\n    CUser* pUser = GetSession()->GetUser();\n    if (pUser) {\n        pUser->AddBytesWritten(GetBytesWritten());\n        pUser->AddBytesRead(GetBytesRead());\n    } else {\n        CZNC::Get().AddBytesWritten(GetBytesWritten());\n        CZNC::Get().AddBytesRead(GetBytesRead());\n    }\n\n    // bytes have been accounted for, so make sure they don't get again:\n    ResetBytesWritten();\n    ResetBytesRead();\n}\n\nvoid CWebSock::GetAvailSkins(VCString& vRet) const {\n    vRet.clear();\n\n    CString sRoot(GetSkinPath(\"_default_\"));\n\n    sRoot.TrimRight(\"/\");\n    sRoot.TrimRight(\"_default_\");\n    sRoot.TrimRight(\"/\");\n\n    if (!sRoot.empty()) {\n        sRoot += \"/\";\n    }\n\n    if (!sRoot.empty() && CFile::IsDir(sRoot)) {\n        CDir Dir(sRoot);\n\n        for (const CFile* pSubDir : Dir) {\n            if (pSubDir->IsDir() && pSubDir->GetShortName() == \"_default_\") {\n                vRet.push_back(pSubDir->GetShortName());\n                break;\n            }\n        }\n\n        for (const CFile* pSubDir : Dir) {\n            if (pSubDir->IsDir() && pSubDir->GetShortName() != \"_default_\" &&\n                pSubDir->GetShortName() != \".svn\") {\n                vRet.push_back(pSubDir->GetShortName());\n            }\n        }\n    }\n}\n\nVCString CWebSock::GetDirs(CModule* pModule, bool bIsTemplate) {\n    CString sHomeSkinsDir(CZNC::Get().GetZNCPath() + \"/webskins/\");\n    CString sSkinName(GetSkinName());\n    VCString vsResult;\n\n    // Module specific paths\n\n    if (pModule) {\n        const CString& sModName(pModule->GetModName());\n\n        // 1. ~/.znc/webskins/<user_skin_setting>/mods/<mod_name>/\n        //\n        if (!sSkinName.empty()) {\n            vsResult.push_back(GetSkinPath(sSkinName) + \"/mods/\" + sModName +\n                               \"/\");\n        }\n\n        // 2. ~/.znc/webskins/_default_/mods/<mod_name>/\n        //\n        vsResult.push_back(GetSkinPath(\"_default_\") + \"/mods/\" + sModName +\n                           \"/\");\n\n        // 3. ./modules/<mod_name>/tmpl/\n        //\n        vsResult.push_back(pModule->GetModDataDir() + \"/tmpl/\");\n\n        // 4. ~/.znc/webskins/<user_skin_setting>/mods/<mod_name>/\n        //\n        if (!sSkinName.empty()) {\n            vsResult.push_back(GetSkinPath(sSkinName) + \"/mods/\" + sModName +\n                               \"/\");\n        }\n\n        // 5. ~/.znc/webskins/_default_/mods/<mod_name>/\n        //\n        vsResult.push_back(GetSkinPath(\"_default_\") + \"/mods/\" + sModName +\n                           \"/\");\n    }\n\n    // 6. ~/.znc/webskins/<user_skin_setting>/\n    //\n    if (!sSkinName.empty()) {\n        vsResult.push_back(GetSkinPath(sSkinName) +\n                           CString(bIsTemplate ? \"/tmpl/\" : \"/\"));\n    }\n\n    // 7. ~/.znc/webskins/_default_/\n    //\n    vsResult.push_back(GetSkinPath(\"_default_\") +\n                       CString(bIsTemplate ? \"/tmpl/\" : \"/\"));\n\n    return vsResult;\n}\n\nCString CWebSock::FindTmpl(CModule* pModule, const CString& sName) {\n    VCString vsDirs = GetDirs(pModule, true);\n    CString sFile = pModule->GetModName() + \"_\" + sName;\n    for (const CString& sDir : vsDirs) {\n        if (CFile::Exists(CDir::ChangeDir(sDir, sFile))) {\n            m_Template.AppendPath(sDir);\n            return sFile;\n        }\n    }\n    return sName;\n}\n\nvoid CWebSock::SetPaths(CModule* pModule, bool bIsTemplate) {\n    m_Template.ClearPaths();\n\n    VCString vsDirs = GetDirs(pModule, bIsTemplate);\n    for (const CString& sDir : vsDirs) {\n        m_Template.AppendPath(sDir);\n    }\n\n    m_bPathsSet = true;\n}\n\nvoid CWebSock::SetVars() {\n    m_Template[\"SessionUser\"] = GetUser();\n    m_Template[\"SessionIP\"] = GetRemoteIP();\n    m_Template[\"Tag\"] = CZNC::GetTag(GetSession()->GetUser() != nullptr, true);\n    m_Template[\"Version\"] = CZNC::GetVersion();\n    m_Template[\"SkinName\"] = GetSkinName();\n    m_Template[\"_CSRF_Check\"] = GetCSRFCheck();\n    m_Template[\"URIPrefix\"] = GetURIPrefix();\n\n    if (GetSession()->IsAdmin()) {\n        m_Template[\"IsAdmin\"] = \"true\";\n    }\n\n    GetSession()->FillMessageLoops(m_Template);\n    GetSession()->ClearMessageLoops();\n\n    // Global Mods\n    CModules& vgMods = CZNC::Get().GetModules();\n    for (CModule* pgMod : vgMods) {\n        AddModLoop(\"GlobalModLoop\", *pgMod);\n    }\n\n    // User Mods\n    if (IsLoggedIn()) {\n        CModules& vMods = GetSession()->GetUser()->GetModules();\n\n        for (CModule* pMod : vMods) {\n            AddModLoop(\"UserModLoop\", *pMod);\n        }\n\n        vector<CIRCNetwork*> vNetworks = GetSession()->GetUser()->GetNetworks();\n        for (CIRCNetwork* pNetwork : vNetworks) {\n            CModules& vnMods = pNetwork->GetModules();\n\n            CTemplate& Row = m_Template.AddRow(\"NetworkModLoop\");\n            Row[\"NetworkName\"] = pNetwork->GetName();\n\n            for (CModule* pnMod : vnMods) {\n                AddModLoop(\"ModLoop\", *pnMod, &Row);\n            }\n        }\n    }\n\n    if (IsLoggedIn()) {\n        m_Template[\"LoggedIn\"] = \"true\";\n    }\n}\n\nbool CWebSock::AddModLoop(const CString& sLoopName, CModule& Module,\n                          CTemplate* pTemplate) {\n    if (!pTemplate) {\n        pTemplate = &m_Template;\n    }\n\n    CString sTitle(Module.GetWebMenuTitle());\n\n    if (!sTitle.empty() && (IsLoggedIn() || (!Module.WebRequiresLogin() &&\n                                             !Module.WebRequiresAdmin())) &&\n        (GetSession()->IsAdmin() || !Module.WebRequiresAdmin())) {\n        CTemplate& Row = pTemplate->AddRow(sLoopName);\n        bool bActiveModule = false;\n\n        Row[\"ModName\"] = Module.GetModName();\n        Row[\"ModPath\"] = Module.GetWebPath();\n        Row[\"Title\"] = sTitle;\n\n        if (m_sModName == Module.GetModName()) {\n            CString sModuleType = GetPath().Token(1, false, \"/\");\n            if (sModuleType == \"global\" &&\n                Module.GetType() == CModInfo::GlobalModule) {\n                bActiveModule = true;\n            } else if (sModuleType == \"user\" &&\n                       Module.GetType() == CModInfo::UserModule) {\n                bActiveModule = true;\n            } else if (sModuleType == \"network\" &&\n                       Module.GetType() == CModInfo::NetworkModule) {\n                CIRCNetwork* Network = Module.GetNetwork();\n                if (Network) {\n                    CString sNetworkName = GetPath().Token(2, false, \"/\");\n                    if (sNetworkName == Network->GetName()) {\n                        bActiveModule = true;\n                    }\n                } else {\n                    bActiveModule = true;\n                }\n            }\n        }\n\n        if (bActiveModule) {\n            Row[\"Active\"] = \"true\";\n        }\n\n        if (Module.GetUser()) {\n            Row[\"Username\"] = Module.GetUser()->GetUserName();\n        }\n\n        VWebSubPages& vSubPages = Module.GetSubPages();\n\n        for (TWebSubPage& SubPage : vSubPages) {\n            // bActive is whether or not the current url matches this subpage\n            // (params will be checked below)\n            bool bActive = (m_sModName == Module.GetModName() &&\n                            m_sPage == SubPage->GetName() && bActiveModule);\n\n            if (SubPage->RequiresAdmin() && !GetSession()->IsAdmin()) {\n                // Don't add admin-only subpages to requests from non-admin\n                // users\n                continue;\n            }\n\n            CTemplate& SubRow = Row.AddRow(\"SubPageLoop\");\n\n            SubRow[\"ModName\"] = Module.GetModName();\n            SubRow[\"ModPath\"] = Module.GetWebPath();\n            SubRow[\"PageName\"] = SubPage->GetName();\n            SubRow[\"Title\"] = SubPage->GetTitle().empty() ? SubPage->GetName()\n                                                          : SubPage->GetTitle();\n\n            CString& sParams = SubRow[\"Params\"];\n\n            const VPair& vParams = SubPage->GetParams();\n            for (const pair<CString, CString>& ssNV : vParams) {\n                if (!sParams.empty()) {\n                    sParams += \"&\";\n                }\n\n                if (!ssNV.first.empty()) {\n                    if (!ssNV.second.empty()) {\n                        sParams += ssNV.first.Escape_n(CString::EURL);\n                        sParams += \"=\";\n                        sParams += ssNV.second.Escape_n(CString::EURL);\n                    }\n\n                    if (bActive && GetParam(ssNV.first, false) != ssNV.second) {\n                        bActive = false;\n                    }\n                }\n            }\n\n            if (bActive) {\n                SubRow[\"Active\"] = \"true\";\n            }\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\nCWebSock::EPageReqResult CWebSock::PrintStaticFile(const CString& sPath,\n                                                   CString& sPageRet,\n                                                   CModule* pModule) {\n    SetPaths(pModule);\n    CString sFile = m_Template.ExpandFile(sPath.TrimLeft_n(\"/\"));\n    DEBUG(\"About to print [\" + sFile + \"]\");\n    // Either PrintFile() fails and sends an error page or it succeeds and\n    // sends a result. In both cases we don't have anything more to do.\n    PrintFile(sFile);\n    return PAGE_DONE;\n}\n\nCWebSock::EPageReqResult CWebSock::PrintTemplate(const CString& sPageName,\n                                                 CString& sPageRet,\n                                                 CModule* pModule) {\n    SetVars();\n\n    m_Template[\"PageName\"] = sPageName;\n\n    if (pModule) {\n        m_Template[\"ModName\"] = pModule->GetModName();\n\n        if (m_Template.find(\"Title\") == m_Template.end()) {\n            m_Template[\"Title\"] = pModule->GetWebMenuTitle();\n        }\n\n        std::vector<CTemplate*>* breadcrumbs =\n            m_Template.GetLoop(\"BreadCrumbs\");\n        if (breadcrumbs->size() == 1 &&\n            m_Template[\"Title\"] != pModule->GetModName()) {\n            // Module didn't add its own breadcrumbs, so add a generic one...\n            // But it'll be useless if it's the same as module name\n            CTemplate& bread = m_Template.AddRow(\"BreadCrumbs\");\n            bread[\"Text\"] = m_Template[\"Title\"];\n        }\n    }\n\n    if (!m_bPathsSet) {\n        SetPaths(pModule, true);\n    }\n\n    if (m_Template.GetFileName().empty() &&\n        !m_Template.SetFile(sPageName + \".tmpl\")) {\n        return PAGE_NOTFOUND;\n    }\n\n    if (m_Template.PrintString(sPageRet)) {\n        return PAGE_PRINT;\n    } else {\n        return PAGE_NOTFOUND;\n    }\n}\n\nCString CWebSock::GetSkinPath(const CString& sSkinName) {\n    CString sRet = CZNC::Get().GetZNCPath() + \"/webskins/\" + sSkinName;\n\n    if (!CFile::IsDir(sRet)) {\n        sRet = CZNC::Get().GetCurPath() + \"/webskins/\" + sSkinName;\n\n        if (!CFile::IsDir(sRet)) {\n            sRet = CString(_SKINDIR_) + \"/\" + sSkinName;\n        }\n    }\n\n    return sRet + \"/\";\n}\n\nbool CWebSock::ForceLogin() {\n    if (GetSession()->IsLoggedIn()) {\n        return true;\n    }\n\n    GetSession()->AddError(\"You must login to view that page\");\n    Redirect(\"/\");\n    return false;\n}\n\nCString CWebSock::GetRequestCookie(const CString& sKey) {\n    const CString sPrefixedKey = CString(GetLocalPort()) + \"-\" + sKey;\n    CString sRet;\n\n    if (!m_sModName.empty()) {\n        sRet = CHTTPSock::GetRequestCookie(\"Mod-\" + m_sModName + \"-\" +\n                                           sPrefixedKey);\n    }\n\n    if (sRet.empty()) {\n        return CHTTPSock::GetRequestCookie(sPrefixedKey);\n    }\n\n    return sRet;\n}\n\nbool CWebSock::SendCookie(const CString& sKey, const CString& sValue) {\n    const CString sPrefixedKey = CString(GetLocalPort()) + \"-\" + sKey;\n\n    if (!m_sModName.empty()) {\n        return CHTTPSock::SendCookie(\"Mod-\" + m_sModName + \"-\" + sPrefixedKey,\n                                     sValue);\n    }\n\n    return CHTTPSock::SendCookie(sPrefixedKey, sValue);\n}\n\nvoid CWebSock::OnPageRequest(const CString& sURI) {\n    CString sPageRet;\n    EPageReqResult eRet = OnPageRequestInternal(sURI, sPageRet);\n    switch (eRet) {\n        case PAGE_PRINT:\n            PrintPage(sPageRet);\n            break;\n        case PAGE_DEFERRED:\n            // Something else will later call Close()\n            break;\n        case PAGE_DONE:\n            // Redirect or something like that, it's done, just make sure\n            // the connection will be closed\n            Close(CLT_AFTERWRITE);\n            break;\n        case PAGE_NOTFOUND:\n        default:\n            PrintNotFound();\n            break;\n    }\n}\n\nCWebSock::EPageReqResult CWebSock::OnPageRequestInternal(const CString& sURI,\n                                                         CString& sPageRet) {\n    // Check that their session really belongs to their IP address. IP-based\n    // authentication is bad, but here it's just an extra layer that makes\n    // stealing cookies harder to pull off.\n    //\n    // When their IP is wrong, we give them an invalid cookie. This makes\n    // sure that they will get a new cookie on their next request.\n    if (CZNC::Get().GetProtectWebSessions() &&\n        GetSession()->GetIP() != GetRemoteIP()) {\n        DEBUG(\"Expected IP: \" << GetSession()->GetIP());\n        DEBUG(\"Remote IP:   \" << GetRemoteIP());\n        SendCookie(\"SessionId\", \"WRONG_IP_FOR_SESSION\");\n        PrintErrorPage(403, \"Access denied\",\n                       \"This session does not belong to your IP.\");\n        return PAGE_DONE;\n    }\n\n    // For pages *not provided* by modules, a CSRF check is performed which involves:\n    // Ensure that they really POSTed from one our forms by checking if they\n    // know the \"secret\" CSRF check value. Don't do this for login since\n    // CSRF against the login form makes no sense and the login form does a\n    // cookies-enabled check which would break otherwise.\n    // Don't do this, if user authenticated using http-basic auth, because:\n    // 1. they obviously know the password,\n    // 2. it's easier to automate some tasks e.g. user creation, without need to\n    //    care about cookies and CSRF\n    if (IsPost() && !m_bBasicAuth && !sURI.StartsWith(\"/mods/\") &&\n        !ValidateCSRFCheck(sURI)) {\n        DEBUG(\"Expected _CSRF_Check: \" << GetCSRFCheck());\n        DEBUG(\"Actual _CSRF_Check:   \" << GetParam(\"_CSRF_Check\"));\n        PrintErrorPage(\n            403, \"Access denied\",\n            \"POST requests need to send \"\n            \"a secret token to prevent cross-site request forgery attacks.\");\n        return PAGE_DONE;\n    }\n\n    SendCookie(\"SessionId\", GetSession()->GetId());\n\n    if (GetSession()->IsLoggedIn()) {\n        m_sUser = GetSession()->GetUser()->GetUserName();\n        m_bLoggedIn = true;\n    }\n    CLanguageScope user_language(\n        m_bLoggedIn ? GetSession()->GetUser()->GetLanguage() : \"\");\n\n    // Handle the static pages that don't require a login\n    if (sURI == \"/\") {\n        if (!m_bLoggedIn && GetParam(\"cookie_check\", false).ToBool() &&\n            GetRequestCookie(\"SessionId\").empty()) {\n            GetSession()->AddError(\n                \"Your browser does not have cookies enabled for this site!\");\n        }\n        return PrintTemplate(\"index\", sPageRet);\n    } else if (sURI == \"/favicon.ico\") {\n        return PrintStaticFile(\"/pub/favicon.ico\", sPageRet);\n    } else if (sURI == \"/robots.txt\") {\n        return PrintStaticFile(\"/pub/robots.txt\", sPageRet);\n    } else if (sURI == \"/logout\") {\n        GetSession()->SetUser(nullptr);\n        SetLoggedIn(false);\n        Redirect(\"/\");\n\n        // We already sent a reply\n        return PAGE_DONE;\n    } else if (sURI == \"/login\") {\n        if (GetParam(\"submitted\").ToBool()) {\n            m_sUser = GetParam(\"user\");\n            m_sPass = GetParam(\"pass\");\n            m_bLoggedIn = OnLogin(m_sUser, m_sPass, false);\n\n            // AcceptedLogin()/RefusedLogin() will call Redirect()\n            return PAGE_DEFERRED;\n        }\n\n        Redirect(\"/\");  // the login form is here\n        return PAGE_DONE;\n    } else if (sURI.StartsWith(\"/pub/\")) {\n        return PrintStaticFile(sURI, sPageRet);\n    } else if (sURI.StartsWith(\"/skinfiles/\")) {\n        CString sSkinName = sURI.substr(11);\n        CString::size_type uPathStart = sSkinName.find(\"/\");\n        if (uPathStart != CString::npos) {\n            CString sFilePath = sSkinName.substr(uPathStart + 1);\n            sSkinName.erase(uPathStart);\n\n            m_Template.ClearPaths();\n            m_Template.AppendPath(GetSkinPath(sSkinName) + \"pub\");\n\n            if (PrintFile(m_Template.ExpandFile(sFilePath))) {\n                return PAGE_DONE;\n            } else {\n                return PAGE_NOTFOUND;\n            }\n        }\n        return PAGE_NOTFOUND;\n    } else if (sURI.StartsWith(\"/mods/\") || sURI.StartsWith(\"/modfiles/\")) {\n        // Make sure modules are treated as directories\n        if (!sURI.EndsWith(\"/\") && !sURI.Contains(\".\") &&\n            !sURI.TrimLeft_n(\"/mods/\").TrimLeft_n(\"/\").Contains(\"/\")) {\n            Redirect(sURI + \"/\");\n            return PAGE_DONE;\n        }\n\n        // The URI looks like:\n        // /mods/[type]/([network]/)?[module][/page][?arg1=val1&arg2=val2...]\n\n        m_sPath = GetPath().TrimLeft_n(\"/\");\n\n        m_sPath.TrimPrefix(\"mods/\");\n        m_sPath.TrimPrefix(\"modfiles/\");\n\n        CString sType = m_sPath.Token(0, false, \"/\");\n        m_sPath = m_sPath.Token(1, true, \"/\");\n\n        CModInfo::EModuleType eModType;\n        if (sType.Equals(\"global\")) {\n            eModType = CModInfo::GlobalModule;\n        } else if (sType.Equals(\"user\")) {\n            eModType = CModInfo::UserModule;\n        } else if (sType.Equals(\"network\")) {\n            eModType = CModInfo::NetworkModule;\n        } else {\n            PrintErrorPage(403, \"Forbidden\",\n                           \"Unknown module type [\" + sType + \"]\");\n            return PAGE_DONE;\n        }\n\n        if ((eModType != CModInfo::GlobalModule) && !ForceLogin()) {\n            // Make sure we have a valid user\n            return PAGE_DONE;\n        }\n\n        CIRCNetwork* pNetwork = nullptr;\n        if (eModType == CModInfo::NetworkModule) {\n            CString sNetwork = m_sPath.Token(0, false, \"/\");\n            m_sPath = m_sPath.Token(1, true, \"/\");\n\n            pNetwork = GetSession()->GetUser()->FindNetwork(sNetwork);\n\n            if (!pNetwork) {\n                PrintErrorPage(404, \"Not Found\",\n                               \"Network [\" + sNetwork + \"] not found.\");\n                return PAGE_DONE;\n            }\n        }\n\n        m_sModName = m_sPath.Token(0, false, \"/\");\n        m_sPage = m_sPath.Token(1, true, \"/\");\n\n        if (m_sPage.empty()) {\n            m_sPage = \"index\";\n        }\n\n        DEBUG(\"Path [\" + m_sPath + \"], Module [\" + m_sModName + \"], Page [\" +\n              m_sPage + \"]\");\n\n        CModule* pModule = nullptr;\n\n        switch (eModType) {\n            case CModInfo::GlobalModule:\n                pModule = CZNC::Get().GetModules().FindModule(m_sModName);\n                break;\n            case CModInfo::UserModule:\n                pModule = GetSession()->GetUser()->GetModules().FindModule(\n                    m_sModName);\n                break;\n            case CModInfo::NetworkModule:\n                pModule = pNetwork->GetModules().FindModule(m_sModName);\n                break;\n        }\n\n        if (!pModule) return PAGE_NOTFOUND;\n\n        // Pass CSRF check to module.\n        // Note that the normal CSRF checks are not applied to /mods/ URLs.\n        if (IsPost() && !m_bBasicAuth &&\n            !pModule->ValidateWebRequestCSRFCheck(*this, m_sPage)) {\n            DEBUG(\"Expected _CSRF_Check: \" << GetCSRFCheck());\n            DEBUG(\"Actual _CSRF_Check:   \" << GetParam(\"_CSRF_Check\"));\n            PrintErrorPage(\n                403, \"Access denied\",\n                \"POST requests need to send \"\n                \"a secret token to prevent cross-site request forgery attacks.\");\n            return PAGE_DONE;\n        }\n\n        m_Template[\"ModPath\"] = pModule->GetWebPath();\n        m_Template[\"ModFilesPath\"] = pModule->GetWebFilesPath();\n\n        if (pModule->WebRequiresLogin() && !ForceLogin()) {\n            return PAGE_PRINT;\n        } else if (pModule->WebRequiresAdmin() && !GetSession()->IsAdmin()) {\n            PrintErrorPage(403, \"Forbidden\",\n                           \"You need to be an admin to access this module\");\n            return PAGE_DONE;\n        } else if (pModule->GetType() != CModInfo::GlobalModule &&\n                   pModule->GetUser() != GetSession()->GetUser()) {\n            PrintErrorPage(403, \"Forbidden\",\n                           \"You must login as \" +\n                               pModule->GetUser()->GetUserName() +\n                               \" in order to view this page\");\n            return PAGE_DONE;\n        } else if (pModule->OnWebPreRequest(*this, m_sPage)) {\n            return PAGE_DEFERRED;\n        }\n\n        VWebSubPages& vSubPages = pModule->GetSubPages();\n\n        for (TWebSubPage& SubPage : vSubPages) {\n            bool bActive = (m_sModName == pModule->GetModName() &&\n                            m_sPage == SubPage->GetName());\n\n            if (bActive && SubPage->RequiresAdmin() &&\n                !GetSession()->IsAdmin()) {\n                PrintErrorPage(403, \"Forbidden\",\n                               \"You need to be an admin to access this page\");\n                return PAGE_DONE;\n            }\n        }\n\n        if (pModule && pModule->GetType() != CModInfo::GlobalModule &&\n            (!IsLoggedIn() || pModule->GetUser() != GetSession()->GetUser())) {\n            AddModLoop(\"UserModLoop\", *pModule);\n        }\n\n        if (sURI.StartsWith(\"/modfiles/\")) {\n            m_Template.AppendPath(GetSkinPath(GetSkinName()) + \"/mods/\" +\n                                  m_sModName + \"/files/\");\n            m_Template.AppendPath(pModule->GetModDataDir() + \"/files/\");\n\n            if (PrintFile(m_Template.ExpandFile(m_sPage.TrimLeft_n(\"/\")))) {\n                return PAGE_PRINT;\n            } else {\n                return PAGE_NOTFOUND;\n            }\n        } else {\n            SetPaths(pModule, true);\n\n            CTemplate& breadModule = m_Template.AddRow(\"BreadCrumbs\");\n            breadModule[\"Text\"] = pModule->GetModName();\n            breadModule[\"URL\"] = pModule->GetWebPath();\n\n            /* if a module returns false from OnWebRequest, it does not\n               want the template to be printed, usually because it did a\n               redirect. */\n            if (pModule->OnWebRequest(*this, m_sPage, m_Template)) {\n                // If they already sent a reply, let's assume\n                // they did what they wanted to do.\n                if (SentHeader()) {\n                    return PAGE_DONE;\n                }\n                return PrintTemplate(m_sPage, sPageRet, pModule);\n            }\n\n            if (!SentHeader()) {\n                PrintErrorPage(\n                    404, \"Not Implemented\",\n                    \"The requested module does not acknowledge web requests\");\n            }\n            return PAGE_DONE;\n        }\n    } else {\n        CString sPage(sURI.Trim_n(\"/\"));\n        if (sPage.length() < 32) {\n            for (unsigned int a = 0; a < sPage.length(); a++) {\n                unsigned char c = sPage[a];\n\n                if ((c < '0' || c > '9') && (c < 'a' || c > 'z') &&\n                    (c < 'A' || c > 'Z') && c != '_') {\n                    return PAGE_NOTFOUND;\n                }\n            }\n\n            return PrintTemplate(sPage, sPageRet);\n        }\n    }\n\n    return PAGE_NOTFOUND;\n}\n\nvoid CWebSock::PrintErrorPage(const CString& sMessage) {\n    m_Template.SetFile(\"Error.tmpl\");\n\n    m_Template[\"Action\"] = \"error\";\n    m_Template[\"Title\"] = \"Error\";\n    m_Template[\"Error\"] = sMessage;\n}\n\nstatic inline bool compareLastActive(\n    const std::pair<const CString, CWebSession*>& first,\n    const std::pair<const CString, CWebSession*>& second) {\n    return first.second->GetLastActive() < second.second->GetLastActive();\n}\n\nstd::shared_ptr<CWebSession> CWebSock::GetSession() {\n    if (m_spSession) {\n        return m_spSession;\n    }\n\n    const CString sCookieSessionId = GetRequestCookie(\"SessionId\");\n    std::shared_ptr<CWebSession>* pSession =\n        Sessions.m_mspSessions.GetItem(sCookieSessionId);\n\n    if (pSession != nullptr) {\n        // Refresh the timeout\n        Sessions.m_mspSessions.AddItem((*pSession)->GetId(), *pSession);\n        (*pSession)->UpdateLastActive();\n        m_spSession = *pSession;\n        DEBUG(\"Found existing session from cookie: [\" + sCookieSessionId +\n              \"] IsLoggedIn(\" +\n              CString((*pSession)->IsLoggedIn()\n                          ? \"true, \" + ((*pSession)->GetUser()->GetUserName())\n                          : \"false\") +\n              \")\");\n        return *pSession;\n    }\n\n    if (Sessions.m_mIPSessions.count(GetRemoteIP()) > m_uiMaxSessions) {\n        pair<mIPSessionsIterator, mIPSessionsIterator> p =\n            Sessions.m_mIPSessions.equal_range(GetRemoteIP());\n        mIPSessionsIterator it =\n            std::min_element(p.first, p.second, compareLastActive);\n        DEBUG(\"Remote IP:   \" << GetRemoteIP() << \"; discarding session [\"\n                              << it->second->GetId() << \"]\");\n        Sessions.m_mspSessions.RemItem(it->second->GetId());\n    }\n\n    CString sSessionID;\n    do {\n        sSessionID = CString::RandomString(32);\n        sSessionID += \":\" + GetRemoteIP() + \":\" + CString(GetRemotePort());\n        sSessionID += \":\" + GetLocalIP() + \":\" + CString(GetLocalPort());\n        sSessionID += \":\" + CString(time(nullptr));\n        sSessionID = sSessionID.SHA256();\n\n        DEBUG(\"Auto generated session: [\" + sSessionID + \"]\");\n    } while (Sessions.m_mspSessions.HasItem(sSessionID));\n\n    std::shared_ptr<CWebSession> spSession(\n        new CWebSession(sSessionID, GetRemoteIP()));\n    Sessions.m_mspSessions.AddItem(spSession->GetId(), spSession);\n\n    m_spSession = spSession;\n\n    return spSession;\n}\n\nCString CWebSock::GetCSRFCheck() {\n    std::shared_ptr<CWebSession> pSession = GetSession();\n    return pSession->GetId().MD5();\n}\n\nbool CWebSock::ValidateCSRFCheck(const CString& sURI) {\n    return sURI == \"/login\" || GetParam(\"_CSRF_Check\") == GetCSRFCheck();\n}\n\nbool CWebSock::OnLogin(const CString& sUser, const CString& sPass,\n                       bool bBasic) {\n    DEBUG(\"=================== CWebSock::OnLogin(), basic auth? \"\n          << std::boolalpha << bBasic);\n    m_spAuth = std::make_shared<CWebAuth>(this, sUser, sPass, bBasic);\n\n    // Some authentication module could need some time, block this socket\n    // until then. CWebAuth will UnPauseRead().\n    PauseRead();\n    CZNC::Get().AuthUser(m_spAuth);\n\n    // If CWebAuth already set this, don't change it.\n    return IsLoggedIn();\n}\n\nCsock* CWebSock::GetSockObj(const CString& sHost, unsigned short uPort) {\n    // All listening is done by CListener, thus CWebSock should never have\n    // to listen, but since GetSockObj() is pure virtual...\n    DEBUG(\"CWebSock::GetSockObj() called - this should never happen!\");\n    return nullptr;\n}\n\nCString CWebSock::GetSkinName() {\n    std::shared_ptr<CWebSession> spSession = GetSession();\n\n    if (spSession->IsLoggedIn() &&\n        !spSession->GetUser()->GetSkinName().empty()) {\n        return spSession->GetUser()->GetSkinName();\n    }\n\n    return CZNC::Get().GetSkinName();\n}\n"], "fixing_code": ["/*\n * Copyright (C) 2004-2018 ZNC, see the NOTICE file for details.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <znc/WebModules.h>\n#include <znc/FileUtils.h>\n#include <znc/User.h>\n#include <znc/IRCNetwork.h>\n#include <znc/znc.h>\n#include <time.h>\n#include <algorithm>\n#include <sstream>\n\nusing std::pair;\nusing std::vector;\n\n/// @todo Do we want to make this a configure option?\n#define _SKINDIR_ _DATADIR_ \"/webskins\"\n\nconst unsigned int CWebSock::m_uiMaxSessions = 5;\n\n// We need this class to make sure the contained maps and their content is\n// destroyed in the order that we want.\nstruct CSessionManager {\n    // Sessions are valid for a day, (24h, ...)\n    CSessionManager() : m_mspSessions(24 * 60 * 60 * 1000), m_mIPSessions() {}\n    ~CSessionManager() {\n        // Make sure all sessions are destroyed before any of our maps\n        // are destroyed\n        m_mspSessions.Clear();\n    }\n\n    CWebSessionMap m_mspSessions;\n    std::multimap<CString, CWebSession*> m_mIPSessions;\n};\ntypedef std::multimap<CString, CWebSession*>::iterator mIPSessionsIterator;\n\nstatic CSessionManager Sessions;\n\nclass CWebAuth : public CAuthBase {\n  public:\n    CWebAuth(CWebSock* pWebSock, const CString& sUsername,\n             const CString& sPassword, bool bBasic);\n    ~CWebAuth() override {}\n\n    CWebAuth(const CWebAuth&) = delete;\n    CWebAuth& operator=(const CWebAuth&) = delete;\n\n    void SetWebSock(CWebSock* pWebSock) { m_pWebSock = pWebSock; }\n    void AcceptedLogin(CUser& User) override;\n    void RefusedLogin(const CString& sReason) override;\n    void Invalidate() override;\n\n  private:\n  protected:\n    CWebSock* m_pWebSock;\n    bool m_bBasic;\n};\n\nvoid CWebSock::FinishUserSessions(const CUser& User) {\n    Sessions.m_mspSessions.FinishUserSessions(User);\n}\n\nCWebSession::~CWebSession() {\n    // Find our entry in mIPSessions\n    pair<mIPSessionsIterator, mIPSessionsIterator> p =\n        Sessions.m_mIPSessions.equal_range(m_sIP);\n    mIPSessionsIterator it = p.first;\n    mIPSessionsIterator end = p.second;\n\n    while (it != end) {\n        if (it->second == this) {\n            Sessions.m_mIPSessions.erase(it++);\n        } else {\n            ++it;\n        }\n    }\n}\n\nCZNCTagHandler::CZNCTagHandler(CWebSock& WebSock)\n    : CTemplateTagHandler(), m_WebSock(WebSock) {}\n\nbool CZNCTagHandler::HandleTag(CTemplate& Tmpl, const CString& sName,\n                               const CString& sArgs, CString& sOutput) {\n    if (sName.Equals(\"URLPARAM\")) {\n        // sOutput = CZNC::Get()\n        sOutput = m_WebSock.GetParam(sArgs.Token(0), false);\n        return true;\n    }\n\n    return false;\n}\n\nCWebSession::CWebSession(const CString& sId, const CString& sIP)\n    : m_sId(sId),\n      m_sIP(sIP),\n      m_pUser(nullptr),\n      m_vsErrorMsgs(),\n      m_vsSuccessMsgs(),\n      m_tmLastActive() {\n    Sessions.m_mIPSessions.insert(make_pair(sIP, this));\n    UpdateLastActive();\n}\n\nvoid CWebSession::UpdateLastActive() { time(&m_tmLastActive); }\n\nbool CWebSession::IsAdmin() const { return IsLoggedIn() && m_pUser->IsAdmin(); }\n\nCWebAuth::CWebAuth(CWebSock* pWebSock, const CString& sUsername,\n                   const CString& sPassword, bool bBasic)\n    : CAuthBase(sUsername, sPassword, pWebSock),\n      m_pWebSock(pWebSock),\n      m_bBasic(bBasic) {}\n\nvoid CWebSession::ClearMessageLoops() {\n    m_vsErrorMsgs.clear();\n    m_vsSuccessMsgs.clear();\n}\n\nvoid CWebSession::FillMessageLoops(CTemplate& Tmpl) {\n    for (const CString& sMessage : m_vsErrorMsgs) {\n        CTemplate& Row = Tmpl.AddRow(\"ErrorLoop\");\n        Row[\"Message\"] = sMessage;\n    }\n\n    for (const CString& sMessage : m_vsSuccessMsgs) {\n        CTemplate& Row = Tmpl.AddRow(\"SuccessLoop\");\n        Row[\"Message\"] = sMessage;\n    }\n}\n\nsize_t CWebSession::AddError(const CString& sMessage) {\n    m_vsErrorMsgs.push_back(sMessage);\n    return m_vsErrorMsgs.size();\n}\n\nsize_t CWebSession::AddSuccess(const CString& sMessage) {\n    m_vsSuccessMsgs.push_back(sMessage);\n    return m_vsSuccessMsgs.size();\n}\n\nvoid CWebSessionMap::FinishUserSessions(const CUser& User) {\n    iterator it = m_mItems.begin();\n\n    while (it != m_mItems.end()) {\n        if (it->second.second->GetUser() == &User) {\n            m_mItems.erase(it++);\n        } else {\n            ++it;\n        }\n    }\n}\n\nvoid CWebAuth::AcceptedLogin(CUser& User) {\n    if (m_pWebSock) {\n        std::shared_ptr<CWebSession> spSession = m_pWebSock->GetSession();\n\n        spSession->SetUser(&User);\n\n        m_pWebSock->SetLoggedIn(true);\n        m_pWebSock->UnPauseRead();\n        if (m_bBasic) {\n            m_pWebSock->ReadLine(\"\");\n        } else {\n            m_pWebSock->Redirect(\"/?cookie_check=true\");\n        }\n\n        DEBUG(\"Successful login attempt ==> USER [\" + User.GetUserName() +\n              \"] ==> SESSION [\" + spSession->GetId() + \"]\");\n    }\n}\n\nvoid CWebAuth::RefusedLogin(const CString& sReason) {\n    if (m_pWebSock) {\n        std::shared_ptr<CWebSession> spSession = m_pWebSock->GetSession();\n\n        spSession->AddError(\"Invalid login!\");\n        spSession->SetUser(nullptr);\n\n        m_pWebSock->SetLoggedIn(false);\n        m_pWebSock->UnPauseRead();\n        if (m_bBasic) {\n            m_pWebSock->AddHeader(\"WWW-Authenticate\", \"Basic realm=\\\"ZNC\\\"\");\n            m_pWebSock->CHTTPSock::PrintErrorPage(\n                401, \"Unauthorized\",\n                \"HTTP Basic authentication attempted with invalid credentials\");\n            // Why CWebSock makes this function protected?..\n        } else {\n            m_pWebSock->Redirect(\"/?cookie_check=true\");\n        }\n\n        DEBUG(\"UNSUCCESSFUL login attempt ==> REASON [\" + sReason +\n              \"] ==> SESSION [\" + spSession->GetId() + \"]\");\n    }\n}\n\nvoid CWebAuth::Invalidate() {\n    CAuthBase::Invalidate();\n    m_pWebSock = nullptr;\n}\n\nCWebSock::CWebSock(const CString& sURIPrefix)\n    : CHTTPSock(nullptr, sURIPrefix),\n      m_bPathsSet(false),\n      m_Template(),\n      m_spAuth(),\n      m_sModName(\"\"),\n      m_sPath(\"\"),\n      m_sPage(\"\"),\n      m_spSession() {\n    m_Template.AddTagHandler(std::make_shared<CZNCTagHandler>(*this));\n}\n\nCWebSock::~CWebSock() {\n    if (m_spAuth) {\n        m_spAuth->Invalidate();\n    }\n\n    // we have to account for traffic here because CSocket does\n    // not have a valid CModule* pointer.\n    CUser* pUser = GetSession()->GetUser();\n    if (pUser) {\n        pUser->AddBytesWritten(GetBytesWritten());\n        pUser->AddBytesRead(GetBytesRead());\n    } else {\n        CZNC::Get().AddBytesWritten(GetBytesWritten());\n        CZNC::Get().AddBytesRead(GetBytesRead());\n    }\n\n    // bytes have been accounted for, so make sure they don't get again:\n    ResetBytesWritten();\n    ResetBytesRead();\n}\n\nvoid CWebSock::GetAvailSkins(VCString& vRet) const {\n    vRet.clear();\n\n    CString sRoot(GetSkinPath(\"_default_\"));\n\n    sRoot.TrimRight(\"/\");\n    sRoot.TrimRight(\"_default_\");\n    sRoot.TrimRight(\"/\");\n\n    if (!sRoot.empty()) {\n        sRoot += \"/\";\n    }\n\n    if (!sRoot.empty() && CFile::IsDir(sRoot)) {\n        CDir Dir(sRoot);\n\n        for (const CFile* pSubDir : Dir) {\n            if (pSubDir->IsDir() && pSubDir->GetShortName() == \"_default_\") {\n                vRet.push_back(pSubDir->GetShortName());\n                break;\n            }\n        }\n\n        for (const CFile* pSubDir : Dir) {\n            if (pSubDir->IsDir() && pSubDir->GetShortName() != \"_default_\" &&\n                pSubDir->GetShortName() != \".svn\") {\n                vRet.push_back(pSubDir->GetShortName());\n            }\n        }\n    }\n}\n\nVCString CWebSock::GetDirs(CModule* pModule, bool bIsTemplate) {\n    CString sHomeSkinsDir(CZNC::Get().GetZNCPath() + \"/webskins/\");\n    CString sSkinName(GetSkinName());\n    VCString vsResult;\n\n    // Module specific paths\n\n    if (pModule) {\n        const CString& sModName(pModule->GetModName());\n\n        // 1. ~/.znc/webskins/<user_skin_setting>/mods/<mod_name>/\n        //\n        if (!sSkinName.empty()) {\n            vsResult.push_back(GetSkinPath(sSkinName) + \"/mods/\" + sModName +\n                               \"/\");\n        }\n\n        // 2. ~/.znc/webskins/_default_/mods/<mod_name>/\n        //\n        vsResult.push_back(GetSkinPath(\"_default_\") + \"/mods/\" + sModName +\n                           \"/\");\n\n        // 3. ./modules/<mod_name>/tmpl/\n        //\n        vsResult.push_back(pModule->GetModDataDir() + \"/tmpl/\");\n\n        // 4. ~/.znc/webskins/<user_skin_setting>/mods/<mod_name>/\n        //\n        if (!sSkinName.empty()) {\n            vsResult.push_back(GetSkinPath(sSkinName) + \"/mods/\" + sModName +\n                               \"/\");\n        }\n\n        // 5. ~/.znc/webskins/_default_/mods/<mod_name>/\n        //\n        vsResult.push_back(GetSkinPath(\"_default_\") + \"/mods/\" + sModName +\n                           \"/\");\n    }\n\n    // 6. ~/.znc/webskins/<user_skin_setting>/\n    //\n    if (!sSkinName.empty()) {\n        vsResult.push_back(GetSkinPath(sSkinName) +\n                           CString(bIsTemplate ? \"/tmpl/\" : \"/\"));\n    }\n\n    // 7. ~/.znc/webskins/_default_/\n    //\n    vsResult.push_back(GetSkinPath(\"_default_\") +\n                       CString(bIsTemplate ? \"/tmpl/\" : \"/\"));\n\n    return vsResult;\n}\n\nCString CWebSock::FindTmpl(CModule* pModule, const CString& sName) {\n    VCString vsDirs = GetDirs(pModule, true);\n    CString sFile = pModule->GetModName() + \"_\" + sName;\n    for (const CString& sDir : vsDirs) {\n        if (CFile::Exists(CDir::ChangeDir(sDir, sFile))) {\n            m_Template.AppendPath(sDir);\n            return sFile;\n        }\n    }\n    return sName;\n}\n\nvoid CWebSock::SetPaths(CModule* pModule, bool bIsTemplate) {\n    m_Template.ClearPaths();\n\n    VCString vsDirs = GetDirs(pModule, bIsTemplate);\n    for (const CString& sDir : vsDirs) {\n        m_Template.AppendPath(sDir);\n    }\n\n    m_bPathsSet = true;\n}\n\nvoid CWebSock::SetVars() {\n    m_Template[\"SessionUser\"] = GetUser();\n    m_Template[\"SessionIP\"] = GetRemoteIP();\n    m_Template[\"Tag\"] = CZNC::GetTag(GetSession()->GetUser() != nullptr, true);\n    m_Template[\"Version\"] = CZNC::GetVersion();\n    m_Template[\"SkinName\"] = GetSkinName();\n    m_Template[\"_CSRF_Check\"] = GetCSRFCheck();\n    m_Template[\"URIPrefix\"] = GetURIPrefix();\n\n    if (GetSession()->IsAdmin()) {\n        m_Template[\"IsAdmin\"] = \"true\";\n    }\n\n    GetSession()->FillMessageLoops(m_Template);\n    GetSession()->ClearMessageLoops();\n\n    // Global Mods\n    CModules& vgMods = CZNC::Get().GetModules();\n    for (CModule* pgMod : vgMods) {\n        AddModLoop(\"GlobalModLoop\", *pgMod);\n    }\n\n    // User Mods\n    if (IsLoggedIn()) {\n        CModules& vMods = GetSession()->GetUser()->GetModules();\n\n        for (CModule* pMod : vMods) {\n            AddModLoop(\"UserModLoop\", *pMod);\n        }\n\n        vector<CIRCNetwork*> vNetworks = GetSession()->GetUser()->GetNetworks();\n        for (CIRCNetwork* pNetwork : vNetworks) {\n            CModules& vnMods = pNetwork->GetModules();\n\n            CTemplate& Row = m_Template.AddRow(\"NetworkModLoop\");\n            Row[\"NetworkName\"] = pNetwork->GetName();\n\n            for (CModule* pnMod : vnMods) {\n                AddModLoop(\"ModLoop\", *pnMod, &Row);\n            }\n        }\n    }\n\n    if (IsLoggedIn()) {\n        m_Template[\"LoggedIn\"] = \"true\";\n    }\n}\n\nbool CWebSock::AddModLoop(const CString& sLoopName, CModule& Module,\n                          CTemplate* pTemplate) {\n    if (!pTemplate) {\n        pTemplate = &m_Template;\n    }\n\n    CString sTitle(Module.GetWebMenuTitle());\n\n    if (!sTitle.empty() && (IsLoggedIn() || (!Module.WebRequiresLogin() &&\n                                             !Module.WebRequiresAdmin())) &&\n        (GetSession()->IsAdmin() || !Module.WebRequiresAdmin())) {\n        CTemplate& Row = pTemplate->AddRow(sLoopName);\n        bool bActiveModule = false;\n\n        Row[\"ModName\"] = Module.GetModName();\n        Row[\"ModPath\"] = Module.GetWebPath();\n        Row[\"Title\"] = sTitle;\n\n        if (m_sModName == Module.GetModName()) {\n            CString sModuleType = GetPath().Token(1, false, \"/\");\n            if (sModuleType == \"global\" &&\n                Module.GetType() == CModInfo::GlobalModule) {\n                bActiveModule = true;\n            } else if (sModuleType == \"user\" &&\n                       Module.GetType() == CModInfo::UserModule) {\n                bActiveModule = true;\n            } else if (sModuleType == \"network\" &&\n                       Module.GetType() == CModInfo::NetworkModule) {\n                CIRCNetwork* Network = Module.GetNetwork();\n                if (Network) {\n                    CString sNetworkName = GetPath().Token(2, false, \"/\");\n                    if (sNetworkName == Network->GetName()) {\n                        bActiveModule = true;\n                    }\n                } else {\n                    bActiveModule = true;\n                }\n            }\n        }\n\n        if (bActiveModule) {\n            Row[\"Active\"] = \"true\";\n        }\n\n        if (Module.GetUser()) {\n            Row[\"Username\"] = Module.GetUser()->GetUserName();\n        }\n\n        VWebSubPages& vSubPages = Module.GetSubPages();\n\n        for (TWebSubPage& SubPage : vSubPages) {\n            // bActive is whether or not the current url matches this subpage\n            // (params will be checked below)\n            bool bActive = (m_sModName == Module.GetModName() &&\n                            m_sPage == SubPage->GetName() && bActiveModule);\n\n            if (SubPage->RequiresAdmin() && !GetSession()->IsAdmin()) {\n                // Don't add admin-only subpages to requests from non-admin\n                // users\n                continue;\n            }\n\n            CTemplate& SubRow = Row.AddRow(\"SubPageLoop\");\n\n            SubRow[\"ModName\"] = Module.GetModName();\n            SubRow[\"ModPath\"] = Module.GetWebPath();\n            SubRow[\"PageName\"] = SubPage->GetName();\n            SubRow[\"Title\"] = SubPage->GetTitle().empty() ? SubPage->GetName()\n                                                          : SubPage->GetTitle();\n\n            CString& sParams = SubRow[\"Params\"];\n\n            const VPair& vParams = SubPage->GetParams();\n            for (const pair<CString, CString>& ssNV : vParams) {\n                if (!sParams.empty()) {\n                    sParams += \"&\";\n                }\n\n                if (!ssNV.first.empty()) {\n                    if (!ssNV.second.empty()) {\n                        sParams += ssNV.first.Escape_n(CString::EURL);\n                        sParams += \"=\";\n                        sParams += ssNV.second.Escape_n(CString::EURL);\n                    }\n\n                    if (bActive && GetParam(ssNV.first, false) != ssNV.second) {\n                        bActive = false;\n                    }\n                }\n            }\n\n            if (bActive) {\n                SubRow[\"Active\"] = \"true\";\n            }\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\nCWebSock::EPageReqResult CWebSock::PrintStaticFile(const CString& sPath,\n                                                   CString& sPageRet,\n                                                   CModule* pModule) {\n    SetPaths(pModule);\n    CString sFile = m_Template.ExpandFile(sPath.TrimLeft_n(\"/\"));\n    DEBUG(\"About to print [\" + sFile + \"]\");\n    // Either PrintFile() fails and sends an error page or it succeeds and\n    // sends a result. In both cases we don't have anything more to do.\n    PrintFile(sFile);\n    return PAGE_DONE;\n}\n\nCWebSock::EPageReqResult CWebSock::PrintTemplate(const CString& sPageName,\n                                                 CString& sPageRet,\n                                                 CModule* pModule) {\n    SetVars();\n\n    m_Template[\"PageName\"] = sPageName;\n\n    if (pModule) {\n        m_Template[\"ModName\"] = pModule->GetModName();\n\n        if (m_Template.find(\"Title\") == m_Template.end()) {\n            m_Template[\"Title\"] = pModule->GetWebMenuTitle();\n        }\n\n        std::vector<CTemplate*>* breadcrumbs =\n            m_Template.GetLoop(\"BreadCrumbs\");\n        if (breadcrumbs->size() == 1 &&\n            m_Template[\"Title\"] != pModule->GetModName()) {\n            // Module didn't add its own breadcrumbs, so add a generic one...\n            // But it'll be useless if it's the same as module name\n            CTemplate& bread = m_Template.AddRow(\"BreadCrumbs\");\n            bread[\"Text\"] = m_Template[\"Title\"];\n        }\n    }\n\n    if (!m_bPathsSet) {\n        SetPaths(pModule, true);\n    }\n\n    if (m_Template.GetFileName().empty() &&\n        !m_Template.SetFile(sPageName + \".tmpl\")) {\n        return PAGE_NOTFOUND;\n    }\n\n    if (m_Template.PrintString(sPageRet)) {\n        return PAGE_PRINT;\n    } else {\n        return PAGE_NOTFOUND;\n    }\n}\n\nCString CWebSock::GetSkinPath(const CString& sSkinName) {\n    const CString sSkin = sSkinName.Replace_n(\"/\", \"_\").Replace_n(\".\", \"_\");\n\n    CString sRet = CZNC::Get().GetZNCPath() + \"/webskins/\" + sSkin;\n\n    if (!CFile::IsDir(sRet)) {\n        sRet = CZNC::Get().GetCurPath() + \"/webskins/\" + sSkin;\n\n        if (!CFile::IsDir(sRet)) {\n            sRet = CString(_SKINDIR_) + \"/\" + sSkin;\n        }\n    }\n\n    return sRet + \"/\";\n}\n\nbool CWebSock::ForceLogin() {\n    if (GetSession()->IsLoggedIn()) {\n        return true;\n    }\n\n    GetSession()->AddError(\"You must login to view that page\");\n    Redirect(\"/\");\n    return false;\n}\n\nCString CWebSock::GetRequestCookie(const CString& sKey) {\n    const CString sPrefixedKey = CString(GetLocalPort()) + \"-\" + sKey;\n    CString sRet;\n\n    if (!m_sModName.empty()) {\n        sRet = CHTTPSock::GetRequestCookie(\"Mod-\" + m_sModName + \"-\" +\n                                           sPrefixedKey);\n    }\n\n    if (sRet.empty()) {\n        return CHTTPSock::GetRequestCookie(sPrefixedKey);\n    }\n\n    return sRet;\n}\n\nbool CWebSock::SendCookie(const CString& sKey, const CString& sValue) {\n    const CString sPrefixedKey = CString(GetLocalPort()) + \"-\" + sKey;\n\n    if (!m_sModName.empty()) {\n        return CHTTPSock::SendCookie(\"Mod-\" + m_sModName + \"-\" + sPrefixedKey,\n                                     sValue);\n    }\n\n    return CHTTPSock::SendCookie(sPrefixedKey, sValue);\n}\n\nvoid CWebSock::OnPageRequest(const CString& sURI) {\n    CString sPageRet;\n    EPageReqResult eRet = OnPageRequestInternal(sURI, sPageRet);\n    switch (eRet) {\n        case PAGE_PRINT:\n            PrintPage(sPageRet);\n            break;\n        case PAGE_DEFERRED:\n            // Something else will later call Close()\n            break;\n        case PAGE_DONE:\n            // Redirect or something like that, it's done, just make sure\n            // the connection will be closed\n            Close(CLT_AFTERWRITE);\n            break;\n        case PAGE_NOTFOUND:\n        default:\n            PrintNotFound();\n            break;\n    }\n}\n\nCWebSock::EPageReqResult CWebSock::OnPageRequestInternal(const CString& sURI,\n                                                         CString& sPageRet) {\n    // Check that their session really belongs to their IP address. IP-based\n    // authentication is bad, but here it's just an extra layer that makes\n    // stealing cookies harder to pull off.\n    //\n    // When their IP is wrong, we give them an invalid cookie. This makes\n    // sure that they will get a new cookie on their next request.\n    if (CZNC::Get().GetProtectWebSessions() &&\n        GetSession()->GetIP() != GetRemoteIP()) {\n        DEBUG(\"Expected IP: \" << GetSession()->GetIP());\n        DEBUG(\"Remote IP:   \" << GetRemoteIP());\n        SendCookie(\"SessionId\", \"WRONG_IP_FOR_SESSION\");\n        PrintErrorPage(403, \"Access denied\",\n                       \"This session does not belong to your IP.\");\n        return PAGE_DONE;\n    }\n\n    // For pages *not provided* by modules, a CSRF check is performed which involves:\n    // Ensure that they really POSTed from one our forms by checking if they\n    // know the \"secret\" CSRF check value. Don't do this for login since\n    // CSRF against the login form makes no sense and the login form does a\n    // cookies-enabled check which would break otherwise.\n    // Don't do this, if user authenticated using http-basic auth, because:\n    // 1. they obviously know the password,\n    // 2. it's easier to automate some tasks e.g. user creation, without need to\n    //    care about cookies and CSRF\n    if (IsPost() && !m_bBasicAuth && !sURI.StartsWith(\"/mods/\") &&\n        !ValidateCSRFCheck(sURI)) {\n        DEBUG(\"Expected _CSRF_Check: \" << GetCSRFCheck());\n        DEBUG(\"Actual _CSRF_Check:   \" << GetParam(\"_CSRF_Check\"));\n        PrintErrorPage(\n            403, \"Access denied\",\n            \"POST requests need to send \"\n            \"a secret token to prevent cross-site request forgery attacks.\");\n        return PAGE_DONE;\n    }\n\n    SendCookie(\"SessionId\", GetSession()->GetId());\n\n    if (GetSession()->IsLoggedIn()) {\n        m_sUser = GetSession()->GetUser()->GetUserName();\n        m_bLoggedIn = true;\n    }\n    CLanguageScope user_language(\n        m_bLoggedIn ? GetSession()->GetUser()->GetLanguage() : \"\");\n\n    // Handle the static pages that don't require a login\n    if (sURI == \"/\") {\n        if (!m_bLoggedIn && GetParam(\"cookie_check\", false).ToBool() &&\n            GetRequestCookie(\"SessionId\").empty()) {\n            GetSession()->AddError(\n                \"Your browser does not have cookies enabled for this site!\");\n        }\n        return PrintTemplate(\"index\", sPageRet);\n    } else if (sURI == \"/favicon.ico\") {\n        return PrintStaticFile(\"/pub/favicon.ico\", sPageRet);\n    } else if (sURI == \"/robots.txt\") {\n        return PrintStaticFile(\"/pub/robots.txt\", sPageRet);\n    } else if (sURI == \"/logout\") {\n        GetSession()->SetUser(nullptr);\n        SetLoggedIn(false);\n        Redirect(\"/\");\n\n        // We already sent a reply\n        return PAGE_DONE;\n    } else if (sURI == \"/login\") {\n        if (GetParam(\"submitted\").ToBool()) {\n            m_sUser = GetParam(\"user\");\n            m_sPass = GetParam(\"pass\");\n            m_bLoggedIn = OnLogin(m_sUser, m_sPass, false);\n\n            // AcceptedLogin()/RefusedLogin() will call Redirect()\n            return PAGE_DEFERRED;\n        }\n\n        Redirect(\"/\");  // the login form is here\n        return PAGE_DONE;\n    } else if (sURI.StartsWith(\"/pub/\")) {\n        return PrintStaticFile(sURI, sPageRet);\n    } else if (sURI.StartsWith(\"/skinfiles/\")) {\n        CString sSkinName = sURI.substr(11);\n        CString::size_type uPathStart = sSkinName.find(\"/\");\n        if (uPathStart != CString::npos) {\n            CString sFilePath = sSkinName.substr(uPathStart + 1);\n            sSkinName.erase(uPathStart);\n\n            m_Template.ClearPaths();\n            m_Template.AppendPath(GetSkinPath(sSkinName) + \"pub\");\n\n            if (PrintFile(m_Template.ExpandFile(sFilePath))) {\n                return PAGE_DONE;\n            } else {\n                return PAGE_NOTFOUND;\n            }\n        }\n        return PAGE_NOTFOUND;\n    } else if (sURI.StartsWith(\"/mods/\") || sURI.StartsWith(\"/modfiles/\")) {\n        // Make sure modules are treated as directories\n        if (!sURI.EndsWith(\"/\") && !sURI.Contains(\".\") &&\n            !sURI.TrimLeft_n(\"/mods/\").TrimLeft_n(\"/\").Contains(\"/\")) {\n            Redirect(sURI + \"/\");\n            return PAGE_DONE;\n        }\n\n        // The URI looks like:\n        // /mods/[type]/([network]/)?[module][/page][?arg1=val1&arg2=val2...]\n\n        m_sPath = GetPath().TrimLeft_n(\"/\");\n\n        m_sPath.TrimPrefix(\"mods/\");\n        m_sPath.TrimPrefix(\"modfiles/\");\n\n        CString sType = m_sPath.Token(0, false, \"/\");\n        m_sPath = m_sPath.Token(1, true, \"/\");\n\n        CModInfo::EModuleType eModType;\n        if (sType.Equals(\"global\")) {\n            eModType = CModInfo::GlobalModule;\n        } else if (sType.Equals(\"user\")) {\n            eModType = CModInfo::UserModule;\n        } else if (sType.Equals(\"network\")) {\n            eModType = CModInfo::NetworkModule;\n        } else {\n            PrintErrorPage(403, \"Forbidden\",\n                           \"Unknown module type [\" + sType + \"]\");\n            return PAGE_DONE;\n        }\n\n        if ((eModType != CModInfo::GlobalModule) && !ForceLogin()) {\n            // Make sure we have a valid user\n            return PAGE_DONE;\n        }\n\n        CIRCNetwork* pNetwork = nullptr;\n        if (eModType == CModInfo::NetworkModule) {\n            CString sNetwork = m_sPath.Token(0, false, \"/\");\n            m_sPath = m_sPath.Token(1, true, \"/\");\n\n            pNetwork = GetSession()->GetUser()->FindNetwork(sNetwork);\n\n            if (!pNetwork) {\n                PrintErrorPage(404, \"Not Found\",\n                               \"Network [\" + sNetwork + \"] not found.\");\n                return PAGE_DONE;\n            }\n        }\n\n        m_sModName = m_sPath.Token(0, false, \"/\");\n        m_sPage = m_sPath.Token(1, true, \"/\");\n\n        if (m_sPage.empty()) {\n            m_sPage = \"index\";\n        }\n\n        DEBUG(\"Path [\" + m_sPath + \"], Module [\" + m_sModName + \"], Page [\" +\n              m_sPage + \"]\");\n\n        CModule* pModule = nullptr;\n\n        switch (eModType) {\n            case CModInfo::GlobalModule:\n                pModule = CZNC::Get().GetModules().FindModule(m_sModName);\n                break;\n            case CModInfo::UserModule:\n                pModule = GetSession()->GetUser()->GetModules().FindModule(\n                    m_sModName);\n                break;\n            case CModInfo::NetworkModule:\n                pModule = pNetwork->GetModules().FindModule(m_sModName);\n                break;\n        }\n\n        if (!pModule) return PAGE_NOTFOUND;\n\n        // Pass CSRF check to module.\n        // Note that the normal CSRF checks are not applied to /mods/ URLs.\n        if (IsPost() && !m_bBasicAuth &&\n            !pModule->ValidateWebRequestCSRFCheck(*this, m_sPage)) {\n            DEBUG(\"Expected _CSRF_Check: \" << GetCSRFCheck());\n            DEBUG(\"Actual _CSRF_Check:   \" << GetParam(\"_CSRF_Check\"));\n            PrintErrorPage(\n                403, \"Access denied\",\n                \"POST requests need to send \"\n                \"a secret token to prevent cross-site request forgery attacks.\");\n            return PAGE_DONE;\n        }\n\n        m_Template[\"ModPath\"] = pModule->GetWebPath();\n        m_Template[\"ModFilesPath\"] = pModule->GetWebFilesPath();\n\n        if (pModule->WebRequiresLogin() && !ForceLogin()) {\n            return PAGE_PRINT;\n        } else if (pModule->WebRequiresAdmin() && !GetSession()->IsAdmin()) {\n            PrintErrorPage(403, \"Forbidden\",\n                           \"You need to be an admin to access this module\");\n            return PAGE_DONE;\n        } else if (pModule->GetType() != CModInfo::GlobalModule &&\n                   pModule->GetUser() != GetSession()->GetUser()) {\n            PrintErrorPage(403, \"Forbidden\",\n                           \"You must login as \" +\n                               pModule->GetUser()->GetUserName() +\n                               \" in order to view this page\");\n            return PAGE_DONE;\n        } else if (pModule->OnWebPreRequest(*this, m_sPage)) {\n            return PAGE_DEFERRED;\n        }\n\n        VWebSubPages& vSubPages = pModule->GetSubPages();\n\n        for (TWebSubPage& SubPage : vSubPages) {\n            bool bActive = (m_sModName == pModule->GetModName() &&\n                            m_sPage == SubPage->GetName());\n\n            if (bActive && SubPage->RequiresAdmin() &&\n                !GetSession()->IsAdmin()) {\n                PrintErrorPage(403, \"Forbidden\",\n                               \"You need to be an admin to access this page\");\n                return PAGE_DONE;\n            }\n        }\n\n        if (pModule && pModule->GetType() != CModInfo::GlobalModule &&\n            (!IsLoggedIn() || pModule->GetUser() != GetSession()->GetUser())) {\n            AddModLoop(\"UserModLoop\", *pModule);\n        }\n\n        if (sURI.StartsWith(\"/modfiles/\")) {\n            m_Template.AppendPath(GetSkinPath(GetSkinName()) + \"/mods/\" +\n                                  m_sModName + \"/files/\");\n            m_Template.AppendPath(pModule->GetModDataDir() + \"/files/\");\n\n            if (PrintFile(m_Template.ExpandFile(m_sPage.TrimLeft_n(\"/\")))) {\n                return PAGE_PRINT;\n            } else {\n                return PAGE_NOTFOUND;\n            }\n        } else {\n            SetPaths(pModule, true);\n\n            CTemplate& breadModule = m_Template.AddRow(\"BreadCrumbs\");\n            breadModule[\"Text\"] = pModule->GetModName();\n            breadModule[\"URL\"] = pModule->GetWebPath();\n\n            /* if a module returns false from OnWebRequest, it does not\n               want the template to be printed, usually because it did a\n               redirect. */\n            if (pModule->OnWebRequest(*this, m_sPage, m_Template)) {\n                // If they already sent a reply, let's assume\n                // they did what they wanted to do.\n                if (SentHeader()) {\n                    return PAGE_DONE;\n                }\n                return PrintTemplate(m_sPage, sPageRet, pModule);\n            }\n\n            if (!SentHeader()) {\n                PrintErrorPage(\n                    404, \"Not Implemented\",\n                    \"The requested module does not acknowledge web requests\");\n            }\n            return PAGE_DONE;\n        }\n    } else {\n        CString sPage(sURI.Trim_n(\"/\"));\n        if (sPage.length() < 32) {\n            for (unsigned int a = 0; a < sPage.length(); a++) {\n                unsigned char c = sPage[a];\n\n                if ((c < '0' || c > '9') && (c < 'a' || c > 'z') &&\n                    (c < 'A' || c > 'Z') && c != '_') {\n                    return PAGE_NOTFOUND;\n                }\n            }\n\n            return PrintTemplate(sPage, sPageRet);\n        }\n    }\n\n    return PAGE_NOTFOUND;\n}\n\nvoid CWebSock::PrintErrorPage(const CString& sMessage) {\n    m_Template.SetFile(\"Error.tmpl\");\n\n    m_Template[\"Action\"] = \"error\";\n    m_Template[\"Title\"] = \"Error\";\n    m_Template[\"Error\"] = sMessage;\n}\n\nstatic inline bool compareLastActive(\n    const std::pair<const CString, CWebSession*>& first,\n    const std::pair<const CString, CWebSession*>& second) {\n    return first.second->GetLastActive() < second.second->GetLastActive();\n}\n\nstd::shared_ptr<CWebSession> CWebSock::GetSession() {\n    if (m_spSession) {\n        return m_spSession;\n    }\n\n    const CString sCookieSessionId = GetRequestCookie(\"SessionId\");\n    std::shared_ptr<CWebSession>* pSession =\n        Sessions.m_mspSessions.GetItem(sCookieSessionId);\n\n    if (pSession != nullptr) {\n        // Refresh the timeout\n        Sessions.m_mspSessions.AddItem((*pSession)->GetId(), *pSession);\n        (*pSession)->UpdateLastActive();\n        m_spSession = *pSession;\n        DEBUG(\"Found existing session from cookie: [\" + sCookieSessionId +\n              \"] IsLoggedIn(\" +\n              CString((*pSession)->IsLoggedIn()\n                          ? \"true, \" + ((*pSession)->GetUser()->GetUserName())\n                          : \"false\") +\n              \")\");\n        return *pSession;\n    }\n\n    if (Sessions.m_mIPSessions.count(GetRemoteIP()) > m_uiMaxSessions) {\n        pair<mIPSessionsIterator, mIPSessionsIterator> p =\n            Sessions.m_mIPSessions.equal_range(GetRemoteIP());\n        mIPSessionsIterator it =\n            std::min_element(p.first, p.second, compareLastActive);\n        DEBUG(\"Remote IP:   \" << GetRemoteIP() << \"; discarding session [\"\n                              << it->second->GetId() << \"]\");\n        Sessions.m_mspSessions.RemItem(it->second->GetId());\n    }\n\n    CString sSessionID;\n    do {\n        sSessionID = CString::RandomString(32);\n        sSessionID += \":\" + GetRemoteIP() + \":\" + CString(GetRemotePort());\n        sSessionID += \":\" + GetLocalIP() + \":\" + CString(GetLocalPort());\n        sSessionID += \":\" + CString(time(nullptr));\n        sSessionID = sSessionID.SHA256();\n\n        DEBUG(\"Auto generated session: [\" + sSessionID + \"]\");\n    } while (Sessions.m_mspSessions.HasItem(sSessionID));\n\n    std::shared_ptr<CWebSession> spSession(\n        new CWebSession(sSessionID, GetRemoteIP()));\n    Sessions.m_mspSessions.AddItem(spSession->GetId(), spSession);\n\n    m_spSession = spSession;\n\n    return spSession;\n}\n\nCString CWebSock::GetCSRFCheck() {\n    std::shared_ptr<CWebSession> pSession = GetSession();\n    return pSession->GetId().MD5();\n}\n\nbool CWebSock::ValidateCSRFCheck(const CString& sURI) {\n    return sURI == \"/login\" || GetParam(\"_CSRF_Check\") == GetCSRFCheck();\n}\n\nbool CWebSock::OnLogin(const CString& sUser, const CString& sPass,\n                       bool bBasic) {\n    DEBUG(\"=================== CWebSock::OnLogin(), basic auth? \"\n          << std::boolalpha << bBasic);\n    m_spAuth = std::make_shared<CWebAuth>(this, sUser, sPass, bBasic);\n\n    // Some authentication module could need some time, block this socket\n    // until then. CWebAuth will UnPauseRead().\n    PauseRead();\n    CZNC::Get().AuthUser(m_spAuth);\n\n    // If CWebAuth already set this, don't change it.\n    return IsLoggedIn();\n}\n\nCsock* CWebSock::GetSockObj(const CString& sHost, unsigned short uPort) {\n    // All listening is done by CListener, thus CWebSock should never have\n    // to listen, but since GetSockObj() is pure virtual...\n    DEBUG(\"CWebSock::GetSockObj() called - this should never happen!\");\n    return nullptr;\n}\n\nCString CWebSock::GetSkinName() {\n    std::shared_ptr<CWebSession> spSession = GetSession();\n\n    if (spSession->IsLoggedIn() &&\n        !spSession->GetUser()->GetSkinName().empty()) {\n        return spSession->GetUser()->GetSkinName();\n    }\n\n    return CZNC::Get().GetSkinName();\n}\n"], "filenames": ["src/WebModules.cpp"], "buggy_code_start_loc": [560], "buggy_code_end_loc": [567], "fixing_code_start_loc": [560], "fixing_code_end_loc": [569], "type": "CWE-22", "message": "ZNC before 1.7.1-rc1 is prone to a path traversal flaw via ../ in a web skin name to access files outside of the intended skins directories.", "other": {"cve": {"id": "CVE-2018-14056", "sourceIdentifier": "cve@mitre.org", "published": "2018-07-15T01:29:03.633", "lastModified": "2019-03-08T17:04:48.770", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "ZNC before 1.7.1-rc1 is prone to a path traversal flaw via ../ in a web skin name to access files outside of the intended skins directories."}, {"lang": "es", "value": "ZNC en versiones anteriores a la 1.7.1-rc1 es propenso a un error de salto de directorio mediante ../ en un nombre de skin web para acceder a archivos fuera del directorio skins planeado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:znc:znc:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.7.0", "matchCriteriaId": "D5E5C246-94BF-4233-A1A5-7924D253C052"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://github.com/znc/znc/commit/a4a5aeeb17d32937d8c7d743dae9a4cc755ce773", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201807-03", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4252", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/znc/znc/commit/a4a5aeeb17d32937d8c7d743dae9a4cc755ce773"}}