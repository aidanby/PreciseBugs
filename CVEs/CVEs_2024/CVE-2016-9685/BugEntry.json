{"buggy_code": ["/*\n * Copyright (c) 2000-2005 Silicon Graphics, Inc.\n * Copyright (c) 2013 Red Hat, Inc.\n * All Rights Reserved.\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it would be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write the Free Software Foundation,\n * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n */\n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_dir2.h\"\n\nSTATIC int\nxfs_attr_shortform_compare(const void *a, const void *b)\n{\n\txfs_attr_sf_sort_t *sa, *sb;\n\n\tsa = (xfs_attr_sf_sort_t *)a;\n\tsb = (xfs_attr_sf_sort_t *)b;\n\tif (sa->hash < sb->hash) {\n\t\treturn -1;\n\t} else if (sa->hash > sb->hash) {\n\t\treturn 1;\n\t} else {\n\t\treturn sa->entno - sb->entno;\n\t}\n}\n\n#define XFS_ISRESET_CURSOR(cursor) \\\n\t(!((cursor)->initted) && !((cursor)->hashval) && \\\n\t !((cursor)->blkno) && !((cursor)->offset))\n/*\n * Copy out entries of shortform attribute lists for attr_list().\n * Shortform attribute lists are not stored in hashval sorted order.\n * If the output buffer is not large enough to hold them all, then we\n * we have to calculate each entries' hashvalue and sort them before\n * we can begin returning them to the user.\n */\nint\nxfs_attr_shortform_list(xfs_attr_list_context_t *context)\n{\n\tattrlist_cursor_kern_t *cursor;\n\txfs_attr_sf_sort_t *sbuf, *sbp;\n\txfs_attr_shortform_t *sf;\n\txfs_attr_sf_entry_t *sfe;\n\txfs_inode_t *dp;\n\tint sbsize, nsbuf, count, i;\n\tint error;\n\n\tASSERT(context != NULL);\n\tdp = context->dp;\n\tASSERT(dp != NULL);\n\tASSERT(dp->i_afp != NULL);\n\tsf = (xfs_attr_shortform_t *)dp->i_afp->if_u1.if_data;\n\tASSERT(sf != NULL);\n\tif (!sf->hdr.count)\n\t\treturn 0;\n\tcursor = context->cursor;\n\tASSERT(cursor != NULL);\n\n\ttrace_xfs_attr_list_sf(context);\n\n\t/*\n\t * If the buffer is large enough and the cursor is at the start,\n\t * do not bother with sorting since we will return everything in\n\t * one buffer and another call using the cursor won't need to be\n\t * made.\n\t * Note the generous fudge factor of 16 overhead bytes per entry.\n\t * If bufsize is zero then put_listent must be a search function\n\t * and can just scan through what we have.\n\t */\n\tif (context->bufsize == 0 ||\n\t    (XFS_ISRESET_CURSOR(cursor) &&\n             (dp->i_afp->if_bytes + sf->hdr.count * 16) < context->bufsize)) {\n\t\tfor (i = 0, sfe = &sf->list[0]; i < sf->hdr.count; i++) {\n\t\t\terror = context->put_listent(context,\n\t\t\t\t\t   sfe->flags,\n\t\t\t\t\t   sfe->nameval,\n\t\t\t\t\t   (int)sfe->namelen,\n\t\t\t\t\t   (int)sfe->valuelen,\n\t\t\t\t\t   &sfe->nameval[sfe->namelen]);\n\n\t\t\t/*\n\t\t\t * Either search callback finished early or\n\t\t\t * didn't fit it all in the buffer after all.\n\t\t\t */\n\t\t\tif (context->seen_enough)\n\t\t\t\tbreak;\n\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tsfe = XFS_ATTR_SF_NEXTENTRY(sfe);\n\t\t}\n\t\ttrace_xfs_attr_list_sf_all(context);\n\t\treturn 0;\n\t}\n\n\t/* do no more for a search callback */\n\tif (context->bufsize == 0)\n\t\treturn 0;\n\n\t/*\n\t * It didn't all fit, so we have to sort everything on hashval.\n\t */\n\tsbsize = sf->hdr.count * sizeof(*sbuf);\n\tsbp = sbuf = kmem_alloc(sbsize, KM_SLEEP | KM_NOFS);\n\n\t/*\n\t * Scan the attribute list for the rest of the entries, storing\n\t * the relevant info from only those that match into a buffer.\n\t */\n\tnsbuf = 0;\n\tfor (i = 0, sfe = &sf->list[0]; i < sf->hdr.count; i++) {\n\t\tif (unlikely(\n\t\t    ((char *)sfe < (char *)sf) ||\n\t\t    ((char *)sfe >= ((char *)sf + dp->i_afp->if_bytes)))) {\n\t\t\tXFS_CORRUPTION_ERROR(\"xfs_attr_shortform_list\",\n\t\t\t\t\t     XFS_ERRLEVEL_LOW,\n\t\t\t\t\t     context->dp->i_mount, sfe);\n\t\t\tkmem_free(sbuf);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\n\t\tsbp->entno = i;\n\t\tsbp->hash = xfs_da_hashname(sfe->nameval, sfe->namelen);\n\t\tsbp->name = sfe->nameval;\n\t\tsbp->namelen = sfe->namelen;\n\t\t/* These are bytes, and both on-disk, don't endian-flip */\n\t\tsbp->valuelen = sfe->valuelen;\n\t\tsbp->flags = sfe->flags;\n\t\tsfe = XFS_ATTR_SF_NEXTENTRY(sfe);\n\t\tsbp++;\n\t\tnsbuf++;\n\t}\n\n\t/*\n\t * Sort the entries on hash then entno.\n\t */\n\txfs_sort(sbuf, nsbuf, sizeof(*sbuf), xfs_attr_shortform_compare);\n\n\t/*\n\t * Re-find our place IN THE SORTED LIST.\n\t */\n\tcount = 0;\n\tcursor->initted = 1;\n\tcursor->blkno = 0;\n\tfor (sbp = sbuf, i = 0; i < nsbuf; i++, sbp++) {\n\t\tif (sbp->hash == cursor->hashval) {\n\t\t\tif (cursor->offset == count) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount++;\n\t\t} else if (sbp->hash > cursor->hashval) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == nsbuf) {\n\t\tkmem_free(sbuf);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Loop putting entries into the user buffer.\n\t */\n\tfor ( ; i < nsbuf; i++, sbp++) {\n\t\tif (cursor->hashval != sbp->hash) {\n\t\t\tcursor->hashval = sbp->hash;\n\t\t\tcursor->offset = 0;\n\t\t}\n\t\terror = context->put_listent(context,\n\t\t\t\t\tsbp->flags,\n\t\t\t\t\tsbp->name,\n\t\t\t\t\tsbp->namelen,\n\t\t\t\t\tsbp->valuelen,\n\t\t\t\t\t&sbp->name[sbp->namelen]);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif (context->seen_enough)\n\t\t\tbreak;\n\t\tcursor->offset++;\n\t}\n\n\tkmem_free(sbuf);\n\treturn 0;\n}\n\nSTATIC int\nxfs_attr_node_list(xfs_attr_list_context_t *context)\n{\n\tattrlist_cursor_kern_t *cursor;\n\txfs_attr_leafblock_t *leaf;\n\txfs_da_intnode_t *node;\n\tstruct xfs_attr3_icleaf_hdr leafhdr;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\tstruct xfs_da_node_entry *btree;\n\tint error, i;\n\tstruct xfs_buf *bp;\n\tstruct xfs_inode\t*dp = context->dp;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\n\ttrace_xfs_attr_node_list(context);\n\n\tcursor = context->cursor;\n\tcursor->initted = 1;\n\n\t/*\n\t * Do all sorts of validation on the passed-in cursor structure.\n\t * If anything is amiss, ignore the cursor and look up the hashval\n\t * starting from the btree root.\n\t */\n\tbp = NULL;\n\tif (cursor->blkno > 0) {\n\t\terror = xfs_da3_node_read(NULL, dp, cursor->blkno, -1,\n\t\t\t\t\t      &bp, XFS_ATTR_FORK);\n\t\tif ((error != 0) && (error != -EFSCORRUPTED))\n\t\t\treturn error;\n\t\tif (bp) {\n\t\t\tstruct xfs_attr_leaf_entry *entries;\n\n\t\t\tnode = bp->b_addr;\n\t\t\tswitch (be16_to_cpu(node->hdr.info.magic)) {\n\t\t\tcase XFS_DA_NODE_MAGIC:\n\t\t\tcase XFS_DA3_NODE_MAGIC:\n\t\t\t\ttrace_xfs_attr_list_wrong_blk(context);\n\t\t\t\txfs_trans_brelse(NULL, bp);\n\t\t\t\tbp = NULL;\n\t\t\t\tbreak;\n\t\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\t\tcase XFS_ATTR3_LEAF_MAGIC:\n\t\t\t\tleaf = bp->b_addr;\n\t\t\t\txfs_attr3_leaf_hdr_from_disk(mp->m_attr_geo,\n\t\t\t\t\t\t\t     &leafhdr, leaf);\n\t\t\t\tentries = xfs_attr3_leaf_entryp(leaf);\n\t\t\t\tif (cursor->hashval > be32_to_cpu(\n\t\t\t\t\t\tentries[leafhdr.count - 1].hashval)) {\n\t\t\t\t\ttrace_xfs_attr_list_wrong_blk(context);\n\t\t\t\t\txfs_trans_brelse(NULL, bp);\n\t\t\t\t\tbp = NULL;\n\t\t\t\t} else if (cursor->hashval <= be32_to_cpu(\n\t\t\t\t\t\tentries[0].hashval)) {\n\t\t\t\t\ttrace_xfs_attr_list_wrong_blk(context);\n\t\t\t\t\txfs_trans_brelse(NULL, bp);\n\t\t\t\t\tbp = NULL;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ttrace_xfs_attr_list_wrong_blk(context);\n\t\t\t\txfs_trans_brelse(NULL, bp);\n\t\t\t\tbp = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * We did not find what we expected given the cursor's contents,\n\t * so we start from the top and work down based on the hash value.\n\t * Note that start of node block is same as start of leaf block.\n\t */\n\tif (bp == NULL) {\n\t\tcursor->blkno = 0;\n\t\tfor (;;) {\n\t\t\t__uint16_t magic;\n\n\t\t\terror = xfs_da3_node_read(NULL, dp,\n\t\t\t\t\t\t      cursor->blkno, -1, &bp,\n\t\t\t\t\t\t      XFS_ATTR_FORK);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tnode = bp->b_addr;\n\t\t\tmagic = be16_to_cpu(node->hdr.info.magic);\n\t\t\tif (magic == XFS_ATTR_LEAF_MAGIC ||\n\t\t\t    magic == XFS_ATTR3_LEAF_MAGIC)\n\t\t\t\tbreak;\n\t\t\tif (magic != XFS_DA_NODE_MAGIC &&\n\t\t\t    magic != XFS_DA3_NODE_MAGIC) {\n\t\t\t\tXFS_CORRUPTION_ERROR(\"xfs_attr_node_list(3)\",\n\t\t\t\t\t\t     XFS_ERRLEVEL_LOW,\n\t\t\t\t\t\t     context->dp->i_mount,\n\t\t\t\t\t\t     node);\n\t\t\t\txfs_trans_brelse(NULL, bp);\n\t\t\t\treturn -EFSCORRUPTED;\n\t\t\t}\n\n\t\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\t\tbtree = dp->d_ops->node_tree_p(node);\n\t\t\tfor (i = 0; i < nodehdr.count; btree++, i++) {\n\t\t\t\tif (cursor->hashval\n\t\t\t\t\t\t<= be32_to_cpu(btree->hashval)) {\n\t\t\t\t\tcursor->blkno = be32_to_cpu(btree->before);\n\t\t\t\t\ttrace_xfs_attr_list_node_descend(context,\n\t\t\t\t\t\t\t\t\t btree);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == nodehdr.count) {\n\t\t\t\txfs_trans_brelse(NULL, bp);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\txfs_trans_brelse(NULL, bp);\n\t\t}\n\t}\n\tASSERT(bp != NULL);\n\n\t/*\n\t * Roll upward through the blocks, processing each leaf block in\n\t * order.  As long as there is space in the result buffer, keep\n\t * adding the information.\n\t */\n\tfor (;;) {\n\t\tleaf = bp->b_addr;\n\t\terror = xfs_attr3_leaf_list_int(bp, context);\n\t\tif (error) {\n\t\t\txfs_trans_brelse(NULL, bp);\n\t\t\treturn error;\n\t\t}\n\t\txfs_attr3_leaf_hdr_from_disk(mp->m_attr_geo, &leafhdr, leaf);\n\t\tif (context->seen_enough || leafhdr.forw == 0)\n\t\t\tbreak;\n\t\tcursor->blkno = leafhdr.forw;\n\t\txfs_trans_brelse(NULL, bp);\n\t\terror = xfs_attr3_leaf_read(NULL, dp, cursor->blkno, -1, &bp);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\txfs_trans_brelse(NULL, bp);\n\treturn 0;\n}\n\n/*\n * Copy out attribute list entries for attr_list(), for leaf attribute lists.\n */\nint\nxfs_attr3_leaf_list_int(\n\tstruct xfs_buf\t\t\t*bp,\n\tstruct xfs_attr_list_context\t*context)\n{\n\tstruct attrlist_cursor_kern\t*cursor;\n\tstruct xfs_attr_leafblock\t*leaf;\n\tstruct xfs_attr3_icleaf_hdr\tichdr;\n\tstruct xfs_attr_leaf_entry\t*entries;\n\tstruct xfs_attr_leaf_entry\t*entry;\n\tint\t\t\t\tretval;\n\tint\t\t\t\ti;\n\tstruct xfs_mount\t\t*mp = context->dp->i_mount;\n\n\ttrace_xfs_attr_list_leaf(context);\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(mp->m_attr_geo, &ichdr, leaf);\n\tentries = xfs_attr3_leaf_entryp(leaf);\n\n\tcursor = context->cursor;\n\tcursor->initted = 1;\n\n\t/*\n\t * Re-find our place in the leaf block if this is a new syscall.\n\t */\n\tif (context->resynch) {\n\t\tentry = &entries[0];\n\t\tfor (i = 0; i < ichdr.count; entry++, i++) {\n\t\t\tif (be32_to_cpu(entry->hashval) == cursor->hashval) {\n\t\t\t\tif (cursor->offset == context->dupcnt) {\n\t\t\t\t\tcontext->dupcnt = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontext->dupcnt++;\n\t\t\t} else if (be32_to_cpu(entry->hashval) >\n\t\t\t\t\tcursor->hashval) {\n\t\t\t\tcontext->dupcnt = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == ichdr.count) {\n\t\t\ttrace_xfs_attr_list_notfound(context);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tentry = &entries[0];\n\t\ti = 0;\n\t}\n\tcontext->resynch = 0;\n\n\t/*\n\t * We have found our place, start copying out the new attributes.\n\t */\n\tretval = 0;\n\tfor (; i < ichdr.count; entry++, i++) {\n\t\tif (be32_to_cpu(entry->hashval) != cursor->hashval) {\n\t\t\tcursor->hashval = be32_to_cpu(entry->hashval);\n\t\t\tcursor->offset = 0;\n\t\t}\n\n\t\tif (entry->flags & XFS_ATTR_INCOMPLETE)\n\t\t\tcontinue;\t\t/* skip incomplete entries */\n\n\t\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\t\txfs_attr_leaf_name_local_t *name_loc =\n\t\t\t\txfs_attr3_leaf_name_local(leaf, i);\n\n\t\t\tretval = context->put_listent(context,\n\t\t\t\t\t\tentry->flags,\n\t\t\t\t\t\tname_loc->nameval,\n\t\t\t\t\t\t(int)name_loc->namelen,\n\t\t\t\t\t\tbe16_to_cpu(name_loc->valuelen),\n\t\t\t\t\t\t&name_loc->nameval[name_loc->namelen]);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t} else {\n\t\t\txfs_attr_leaf_name_remote_t *name_rmt =\n\t\t\t\txfs_attr3_leaf_name_remote(leaf, i);\n\n\t\t\tint valuelen = be32_to_cpu(name_rmt->valuelen);\n\n\t\t\tif (context->put_value) {\n\t\t\t\txfs_da_args_t args;\n\n\t\t\t\tmemset((char *)&args, 0, sizeof(args));\n\t\t\t\targs.geo = context->dp->i_mount->m_attr_geo;\n\t\t\t\targs.dp = context->dp;\n\t\t\t\targs.whichfork = XFS_ATTR_FORK;\n\t\t\t\targs.valuelen = valuelen;\n\t\t\t\targs.rmtvaluelen = valuelen;\n\t\t\t\targs.value = kmem_alloc(valuelen, KM_SLEEP | KM_NOFS);\n\t\t\t\targs.rmtblkno = be32_to_cpu(name_rmt->valueblk);\n\t\t\t\targs.rmtblkcnt = xfs_attr3_rmt_blocks(\n\t\t\t\t\t\t\targs.dp->i_mount, valuelen);\n\t\t\t\tretval = xfs_attr_rmtval_get(&args);\n\t\t\t\tif (retval)\n\t\t\t\t\treturn retval;\n\t\t\t\tretval = context->put_listent(context,\n\t\t\t\t\t\tentry->flags,\n\t\t\t\t\t\tname_rmt->name,\n\t\t\t\t\t\t(int)name_rmt->namelen,\n\t\t\t\t\t\tvaluelen,\n\t\t\t\t\t\targs.value);\n\t\t\t\tkmem_free(args.value);\n\t\t\t} else {\n\t\t\t\tretval = context->put_listent(context,\n\t\t\t\t\t\tentry->flags,\n\t\t\t\t\t\tname_rmt->name,\n\t\t\t\t\t\t(int)name_rmt->namelen,\n\t\t\t\t\t\tvaluelen,\n\t\t\t\t\t\tNULL);\n\t\t\t}\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t}\n\t\tif (context->seen_enough)\n\t\t\tbreak;\n\t\tcursor->offset++;\n\t}\n\ttrace_xfs_attr_list_leaf_end(context);\n\treturn retval;\n}\n\n/*\n * Copy out attribute entries for attr_list(), for leaf attribute lists.\n */\nSTATIC int\nxfs_attr_leaf_list(xfs_attr_list_context_t *context)\n{\n\tint error;\n\tstruct xfs_buf *bp;\n\n\ttrace_xfs_attr_leaf_list(context);\n\n\tcontext->cursor->blkno = 0;\n\terror = xfs_attr3_leaf_read(NULL, context->dp, 0, -1, &bp);\n\tif (error)\n\t\treturn error;\n\n\terror = xfs_attr3_leaf_list_int(bp, context);\n\txfs_trans_brelse(NULL, bp);\n\treturn error;\n}\n\nint\nxfs_attr_list_int(\n\txfs_attr_list_context_t *context)\n{\n\tint error;\n\txfs_inode_t *dp = context->dp;\n\tuint\t\tlock_mode;\n\n\tXFS_STATS_INC(dp->i_mount, xs_attr_list);\n\n\tif (XFS_FORCED_SHUTDOWN(dp->i_mount))\n\t\treturn -EIO;\n\n\t/*\n\t * Decide on what work routines to call based on the inode size.\n\t */\n\tlock_mode = xfs_ilock_attr_map_shared(dp);\n\tif (!xfs_inode_hasattr(dp)) {\n\t\terror = 0;\n\t} else if (dp->i_d.di_aformat == XFS_DINODE_FMT_LOCAL) {\n\t\terror = xfs_attr_shortform_list(context);\n\t} else if (xfs_bmap_one_block(dp, XFS_ATTR_FORK)) {\n\t\terror = xfs_attr_leaf_list(context);\n\t} else {\n\t\terror = xfs_attr_node_list(context);\n\t}\n\txfs_iunlock(dp, lock_mode);\n\treturn error;\n}\n\n#define\tATTR_ENTBASESIZE\t\t/* minimum bytes used by an attr */ \\\n\t(((struct attrlist_ent *) 0)->a_name - (char *) 0)\n#define\tATTR_ENTSIZE(namelen)\t\t/* actual bytes used by an attr */ \\\n\t((ATTR_ENTBASESIZE + (namelen) + 1 + sizeof(u_int32_t)-1) \\\n\t & ~(sizeof(u_int32_t)-1))\n\n/*\n * Format an attribute and copy it out to the user's buffer.\n * Take care to check values and protect against them changing later,\n * we may be reading them directly out of a user buffer.\n */\nSTATIC int\nxfs_attr_put_listent(\n\txfs_attr_list_context_t *context,\n\tint\t\tflags,\n\tunsigned char\t*name,\n\tint\t\tnamelen,\n\tint\t\tvaluelen,\n\tunsigned char\t*value)\n{\n\tstruct attrlist *alist = (struct attrlist *)context->alist;\n\tattrlist_ent_t *aep;\n\tint arraytop;\n\n\tASSERT(!(context->flags & ATTR_KERNOVAL));\n\tASSERT(context->count >= 0);\n\tASSERT(context->count < (ATTR_MAX_VALUELEN/8));\n\tASSERT(context->firstu >= sizeof(*alist));\n\tASSERT(context->firstu <= context->bufsize);\n\n\t/*\n\t * Only list entries in the right namespace.\n\t */\n\tif (((context->flags & ATTR_SECURE) == 0) !=\n\t    ((flags & XFS_ATTR_SECURE) == 0))\n\t\treturn 0;\n\tif (((context->flags & ATTR_ROOT) == 0) !=\n\t    ((flags & XFS_ATTR_ROOT) == 0))\n\t\treturn 0;\n\n\tarraytop = sizeof(*alist) +\n\t\t\tcontext->count * sizeof(alist->al_offset[0]);\n\tcontext->firstu -= ATTR_ENTSIZE(namelen);\n\tif (context->firstu < arraytop) {\n\t\ttrace_xfs_attr_list_full(context);\n\t\talist->al_more = 1;\n\t\tcontext->seen_enough = 1;\n\t\treturn 1;\n\t}\n\n\taep = (attrlist_ent_t *)&context->alist[context->firstu];\n\taep->a_valuelen = valuelen;\n\tmemcpy(aep->a_name, name, namelen);\n\taep->a_name[namelen] = 0;\n\talist->al_offset[context->count++] = context->firstu;\n\talist->al_count = context->count;\n\ttrace_xfs_attr_list_add(context);\n\treturn 0;\n}\n\n/*\n * Generate a list of extended attribute names and optionally\n * also value lengths.  Positive return value follows the XFS\n * convention of being an error, zero or negative return code\n * is the length of the buffer returned (negated), indicating\n * success.\n */\nint\nxfs_attr_list(\n\txfs_inode_t\t*dp,\n\tchar\t\t*buffer,\n\tint\t\tbufsize,\n\tint\t\tflags,\n\tattrlist_cursor_kern_t *cursor)\n{\n\txfs_attr_list_context_t context;\n\tstruct attrlist *alist;\n\tint error;\n\n\t/*\n\t * Validate the cursor.\n\t */\n\tif (cursor->pad1 || cursor->pad2)\n\t\treturn -EINVAL;\n\tif ((cursor->initted == 0) &&\n\t    (cursor->hashval || cursor->blkno || cursor->offset))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Check for a properly aligned buffer.\n\t */\n\tif (((long)buffer) & (sizeof(int)-1))\n\t\treturn -EFAULT;\n\tif (flags & ATTR_KERNOVAL)\n\t\tbufsize = 0;\n\n\t/*\n\t * Initialize the output buffer.\n\t */\n\tmemset(&context, 0, sizeof(context));\n\tcontext.dp = dp;\n\tcontext.cursor = cursor;\n\tcontext.resynch = 1;\n\tcontext.flags = flags;\n\tcontext.alist = buffer;\n\tcontext.bufsize = (bufsize & ~(sizeof(int)-1));  /* align */\n\tcontext.firstu = context.bufsize;\n\tcontext.put_listent = xfs_attr_put_listent;\n\n\talist = (struct attrlist *)context.alist;\n\talist->al_count = 0;\n\talist->al_more = 0;\n\talist->al_offset[0] = context.bufsize;\n\n\terror = xfs_attr_list_int(&context);\n\tASSERT(error <= 0);\n\treturn error;\n}\n"], "fixing_code": ["/*\n * Copyright (c) 2000-2005 Silicon Graphics, Inc.\n * Copyright (c) 2013 Red Hat, Inc.\n * All Rights Reserved.\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it would be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write the Free Software Foundation,\n * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n */\n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_dir2.h\"\n\nSTATIC int\nxfs_attr_shortform_compare(const void *a, const void *b)\n{\n\txfs_attr_sf_sort_t *sa, *sb;\n\n\tsa = (xfs_attr_sf_sort_t *)a;\n\tsb = (xfs_attr_sf_sort_t *)b;\n\tif (sa->hash < sb->hash) {\n\t\treturn -1;\n\t} else if (sa->hash > sb->hash) {\n\t\treturn 1;\n\t} else {\n\t\treturn sa->entno - sb->entno;\n\t}\n}\n\n#define XFS_ISRESET_CURSOR(cursor) \\\n\t(!((cursor)->initted) && !((cursor)->hashval) && \\\n\t !((cursor)->blkno) && !((cursor)->offset))\n/*\n * Copy out entries of shortform attribute lists for attr_list().\n * Shortform attribute lists are not stored in hashval sorted order.\n * If the output buffer is not large enough to hold them all, then we\n * we have to calculate each entries' hashvalue and sort them before\n * we can begin returning them to the user.\n */\nint\nxfs_attr_shortform_list(xfs_attr_list_context_t *context)\n{\n\tattrlist_cursor_kern_t *cursor;\n\txfs_attr_sf_sort_t *sbuf, *sbp;\n\txfs_attr_shortform_t *sf;\n\txfs_attr_sf_entry_t *sfe;\n\txfs_inode_t *dp;\n\tint sbsize, nsbuf, count, i;\n\tint error;\n\n\tASSERT(context != NULL);\n\tdp = context->dp;\n\tASSERT(dp != NULL);\n\tASSERT(dp->i_afp != NULL);\n\tsf = (xfs_attr_shortform_t *)dp->i_afp->if_u1.if_data;\n\tASSERT(sf != NULL);\n\tif (!sf->hdr.count)\n\t\treturn 0;\n\tcursor = context->cursor;\n\tASSERT(cursor != NULL);\n\n\ttrace_xfs_attr_list_sf(context);\n\n\t/*\n\t * If the buffer is large enough and the cursor is at the start,\n\t * do not bother with sorting since we will return everything in\n\t * one buffer and another call using the cursor won't need to be\n\t * made.\n\t * Note the generous fudge factor of 16 overhead bytes per entry.\n\t * If bufsize is zero then put_listent must be a search function\n\t * and can just scan through what we have.\n\t */\n\tif (context->bufsize == 0 ||\n\t    (XFS_ISRESET_CURSOR(cursor) &&\n             (dp->i_afp->if_bytes + sf->hdr.count * 16) < context->bufsize)) {\n\t\tfor (i = 0, sfe = &sf->list[0]; i < sf->hdr.count; i++) {\n\t\t\terror = context->put_listent(context,\n\t\t\t\t\t   sfe->flags,\n\t\t\t\t\t   sfe->nameval,\n\t\t\t\t\t   (int)sfe->namelen,\n\t\t\t\t\t   (int)sfe->valuelen,\n\t\t\t\t\t   &sfe->nameval[sfe->namelen]);\n\n\t\t\t/*\n\t\t\t * Either search callback finished early or\n\t\t\t * didn't fit it all in the buffer after all.\n\t\t\t */\n\t\t\tif (context->seen_enough)\n\t\t\t\tbreak;\n\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tsfe = XFS_ATTR_SF_NEXTENTRY(sfe);\n\t\t}\n\t\ttrace_xfs_attr_list_sf_all(context);\n\t\treturn 0;\n\t}\n\n\t/* do no more for a search callback */\n\tif (context->bufsize == 0)\n\t\treturn 0;\n\n\t/*\n\t * It didn't all fit, so we have to sort everything on hashval.\n\t */\n\tsbsize = sf->hdr.count * sizeof(*sbuf);\n\tsbp = sbuf = kmem_alloc(sbsize, KM_SLEEP | KM_NOFS);\n\n\t/*\n\t * Scan the attribute list for the rest of the entries, storing\n\t * the relevant info from only those that match into a buffer.\n\t */\n\tnsbuf = 0;\n\tfor (i = 0, sfe = &sf->list[0]; i < sf->hdr.count; i++) {\n\t\tif (unlikely(\n\t\t    ((char *)sfe < (char *)sf) ||\n\t\t    ((char *)sfe >= ((char *)sf + dp->i_afp->if_bytes)))) {\n\t\t\tXFS_CORRUPTION_ERROR(\"xfs_attr_shortform_list\",\n\t\t\t\t\t     XFS_ERRLEVEL_LOW,\n\t\t\t\t\t     context->dp->i_mount, sfe);\n\t\t\tkmem_free(sbuf);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\n\t\tsbp->entno = i;\n\t\tsbp->hash = xfs_da_hashname(sfe->nameval, sfe->namelen);\n\t\tsbp->name = sfe->nameval;\n\t\tsbp->namelen = sfe->namelen;\n\t\t/* These are bytes, and both on-disk, don't endian-flip */\n\t\tsbp->valuelen = sfe->valuelen;\n\t\tsbp->flags = sfe->flags;\n\t\tsfe = XFS_ATTR_SF_NEXTENTRY(sfe);\n\t\tsbp++;\n\t\tnsbuf++;\n\t}\n\n\t/*\n\t * Sort the entries on hash then entno.\n\t */\n\txfs_sort(sbuf, nsbuf, sizeof(*sbuf), xfs_attr_shortform_compare);\n\n\t/*\n\t * Re-find our place IN THE SORTED LIST.\n\t */\n\tcount = 0;\n\tcursor->initted = 1;\n\tcursor->blkno = 0;\n\tfor (sbp = sbuf, i = 0; i < nsbuf; i++, sbp++) {\n\t\tif (sbp->hash == cursor->hashval) {\n\t\t\tif (cursor->offset == count) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount++;\n\t\t} else if (sbp->hash > cursor->hashval) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == nsbuf) {\n\t\tkmem_free(sbuf);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Loop putting entries into the user buffer.\n\t */\n\tfor ( ; i < nsbuf; i++, sbp++) {\n\t\tif (cursor->hashval != sbp->hash) {\n\t\t\tcursor->hashval = sbp->hash;\n\t\t\tcursor->offset = 0;\n\t\t}\n\t\terror = context->put_listent(context,\n\t\t\t\t\tsbp->flags,\n\t\t\t\t\tsbp->name,\n\t\t\t\t\tsbp->namelen,\n\t\t\t\t\tsbp->valuelen,\n\t\t\t\t\t&sbp->name[sbp->namelen]);\n\t\tif (error) {\n\t\t\tkmem_free(sbuf);\n\t\t\treturn error;\n\t\t}\n\t\tif (context->seen_enough)\n\t\t\tbreak;\n\t\tcursor->offset++;\n\t}\n\n\tkmem_free(sbuf);\n\treturn 0;\n}\n\nSTATIC int\nxfs_attr_node_list(xfs_attr_list_context_t *context)\n{\n\tattrlist_cursor_kern_t *cursor;\n\txfs_attr_leafblock_t *leaf;\n\txfs_da_intnode_t *node;\n\tstruct xfs_attr3_icleaf_hdr leafhdr;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\tstruct xfs_da_node_entry *btree;\n\tint error, i;\n\tstruct xfs_buf *bp;\n\tstruct xfs_inode\t*dp = context->dp;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\n\ttrace_xfs_attr_node_list(context);\n\n\tcursor = context->cursor;\n\tcursor->initted = 1;\n\n\t/*\n\t * Do all sorts of validation on the passed-in cursor structure.\n\t * If anything is amiss, ignore the cursor and look up the hashval\n\t * starting from the btree root.\n\t */\n\tbp = NULL;\n\tif (cursor->blkno > 0) {\n\t\terror = xfs_da3_node_read(NULL, dp, cursor->blkno, -1,\n\t\t\t\t\t      &bp, XFS_ATTR_FORK);\n\t\tif ((error != 0) && (error != -EFSCORRUPTED))\n\t\t\treturn error;\n\t\tif (bp) {\n\t\t\tstruct xfs_attr_leaf_entry *entries;\n\n\t\t\tnode = bp->b_addr;\n\t\t\tswitch (be16_to_cpu(node->hdr.info.magic)) {\n\t\t\tcase XFS_DA_NODE_MAGIC:\n\t\t\tcase XFS_DA3_NODE_MAGIC:\n\t\t\t\ttrace_xfs_attr_list_wrong_blk(context);\n\t\t\t\txfs_trans_brelse(NULL, bp);\n\t\t\t\tbp = NULL;\n\t\t\t\tbreak;\n\t\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\t\tcase XFS_ATTR3_LEAF_MAGIC:\n\t\t\t\tleaf = bp->b_addr;\n\t\t\t\txfs_attr3_leaf_hdr_from_disk(mp->m_attr_geo,\n\t\t\t\t\t\t\t     &leafhdr, leaf);\n\t\t\t\tentries = xfs_attr3_leaf_entryp(leaf);\n\t\t\t\tif (cursor->hashval > be32_to_cpu(\n\t\t\t\t\t\tentries[leafhdr.count - 1].hashval)) {\n\t\t\t\t\ttrace_xfs_attr_list_wrong_blk(context);\n\t\t\t\t\txfs_trans_brelse(NULL, bp);\n\t\t\t\t\tbp = NULL;\n\t\t\t\t} else if (cursor->hashval <= be32_to_cpu(\n\t\t\t\t\t\tentries[0].hashval)) {\n\t\t\t\t\ttrace_xfs_attr_list_wrong_blk(context);\n\t\t\t\t\txfs_trans_brelse(NULL, bp);\n\t\t\t\t\tbp = NULL;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ttrace_xfs_attr_list_wrong_blk(context);\n\t\t\t\txfs_trans_brelse(NULL, bp);\n\t\t\t\tbp = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * We did not find what we expected given the cursor's contents,\n\t * so we start from the top and work down based on the hash value.\n\t * Note that start of node block is same as start of leaf block.\n\t */\n\tif (bp == NULL) {\n\t\tcursor->blkno = 0;\n\t\tfor (;;) {\n\t\t\t__uint16_t magic;\n\n\t\t\terror = xfs_da3_node_read(NULL, dp,\n\t\t\t\t\t\t      cursor->blkno, -1, &bp,\n\t\t\t\t\t\t      XFS_ATTR_FORK);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tnode = bp->b_addr;\n\t\t\tmagic = be16_to_cpu(node->hdr.info.magic);\n\t\t\tif (magic == XFS_ATTR_LEAF_MAGIC ||\n\t\t\t    magic == XFS_ATTR3_LEAF_MAGIC)\n\t\t\t\tbreak;\n\t\t\tif (magic != XFS_DA_NODE_MAGIC &&\n\t\t\t    magic != XFS_DA3_NODE_MAGIC) {\n\t\t\t\tXFS_CORRUPTION_ERROR(\"xfs_attr_node_list(3)\",\n\t\t\t\t\t\t     XFS_ERRLEVEL_LOW,\n\t\t\t\t\t\t     context->dp->i_mount,\n\t\t\t\t\t\t     node);\n\t\t\t\txfs_trans_brelse(NULL, bp);\n\t\t\t\treturn -EFSCORRUPTED;\n\t\t\t}\n\n\t\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\t\tbtree = dp->d_ops->node_tree_p(node);\n\t\t\tfor (i = 0; i < nodehdr.count; btree++, i++) {\n\t\t\t\tif (cursor->hashval\n\t\t\t\t\t\t<= be32_to_cpu(btree->hashval)) {\n\t\t\t\t\tcursor->blkno = be32_to_cpu(btree->before);\n\t\t\t\t\ttrace_xfs_attr_list_node_descend(context,\n\t\t\t\t\t\t\t\t\t btree);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == nodehdr.count) {\n\t\t\t\txfs_trans_brelse(NULL, bp);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\txfs_trans_brelse(NULL, bp);\n\t\t}\n\t}\n\tASSERT(bp != NULL);\n\n\t/*\n\t * Roll upward through the blocks, processing each leaf block in\n\t * order.  As long as there is space in the result buffer, keep\n\t * adding the information.\n\t */\n\tfor (;;) {\n\t\tleaf = bp->b_addr;\n\t\terror = xfs_attr3_leaf_list_int(bp, context);\n\t\tif (error) {\n\t\t\txfs_trans_brelse(NULL, bp);\n\t\t\treturn error;\n\t\t}\n\t\txfs_attr3_leaf_hdr_from_disk(mp->m_attr_geo, &leafhdr, leaf);\n\t\tif (context->seen_enough || leafhdr.forw == 0)\n\t\t\tbreak;\n\t\tcursor->blkno = leafhdr.forw;\n\t\txfs_trans_brelse(NULL, bp);\n\t\terror = xfs_attr3_leaf_read(NULL, dp, cursor->blkno, -1, &bp);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\txfs_trans_brelse(NULL, bp);\n\treturn 0;\n}\n\n/*\n * Copy out attribute list entries for attr_list(), for leaf attribute lists.\n */\nint\nxfs_attr3_leaf_list_int(\n\tstruct xfs_buf\t\t\t*bp,\n\tstruct xfs_attr_list_context\t*context)\n{\n\tstruct attrlist_cursor_kern\t*cursor;\n\tstruct xfs_attr_leafblock\t*leaf;\n\tstruct xfs_attr3_icleaf_hdr\tichdr;\n\tstruct xfs_attr_leaf_entry\t*entries;\n\tstruct xfs_attr_leaf_entry\t*entry;\n\tint\t\t\t\tretval;\n\tint\t\t\t\ti;\n\tstruct xfs_mount\t\t*mp = context->dp->i_mount;\n\n\ttrace_xfs_attr_list_leaf(context);\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(mp->m_attr_geo, &ichdr, leaf);\n\tentries = xfs_attr3_leaf_entryp(leaf);\n\n\tcursor = context->cursor;\n\tcursor->initted = 1;\n\n\t/*\n\t * Re-find our place in the leaf block if this is a new syscall.\n\t */\n\tif (context->resynch) {\n\t\tentry = &entries[0];\n\t\tfor (i = 0; i < ichdr.count; entry++, i++) {\n\t\t\tif (be32_to_cpu(entry->hashval) == cursor->hashval) {\n\t\t\t\tif (cursor->offset == context->dupcnt) {\n\t\t\t\t\tcontext->dupcnt = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontext->dupcnt++;\n\t\t\t} else if (be32_to_cpu(entry->hashval) >\n\t\t\t\t\tcursor->hashval) {\n\t\t\t\tcontext->dupcnt = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == ichdr.count) {\n\t\t\ttrace_xfs_attr_list_notfound(context);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tentry = &entries[0];\n\t\ti = 0;\n\t}\n\tcontext->resynch = 0;\n\n\t/*\n\t * We have found our place, start copying out the new attributes.\n\t */\n\tretval = 0;\n\tfor (; i < ichdr.count; entry++, i++) {\n\t\tif (be32_to_cpu(entry->hashval) != cursor->hashval) {\n\t\t\tcursor->hashval = be32_to_cpu(entry->hashval);\n\t\t\tcursor->offset = 0;\n\t\t}\n\n\t\tif (entry->flags & XFS_ATTR_INCOMPLETE)\n\t\t\tcontinue;\t\t/* skip incomplete entries */\n\n\t\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\t\txfs_attr_leaf_name_local_t *name_loc =\n\t\t\t\txfs_attr3_leaf_name_local(leaf, i);\n\n\t\t\tretval = context->put_listent(context,\n\t\t\t\t\t\tentry->flags,\n\t\t\t\t\t\tname_loc->nameval,\n\t\t\t\t\t\t(int)name_loc->namelen,\n\t\t\t\t\t\tbe16_to_cpu(name_loc->valuelen),\n\t\t\t\t\t\t&name_loc->nameval[name_loc->namelen]);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t} else {\n\t\t\txfs_attr_leaf_name_remote_t *name_rmt =\n\t\t\t\txfs_attr3_leaf_name_remote(leaf, i);\n\n\t\t\tint valuelen = be32_to_cpu(name_rmt->valuelen);\n\n\t\t\tif (context->put_value) {\n\t\t\t\txfs_da_args_t args;\n\n\t\t\t\tmemset((char *)&args, 0, sizeof(args));\n\t\t\t\targs.geo = context->dp->i_mount->m_attr_geo;\n\t\t\t\targs.dp = context->dp;\n\t\t\t\targs.whichfork = XFS_ATTR_FORK;\n\t\t\t\targs.valuelen = valuelen;\n\t\t\t\targs.rmtvaluelen = valuelen;\n\t\t\t\targs.value = kmem_alloc(valuelen, KM_SLEEP | KM_NOFS);\n\t\t\t\targs.rmtblkno = be32_to_cpu(name_rmt->valueblk);\n\t\t\t\targs.rmtblkcnt = xfs_attr3_rmt_blocks(\n\t\t\t\t\t\t\targs.dp->i_mount, valuelen);\n\t\t\t\tretval = xfs_attr_rmtval_get(&args);\n\t\t\t\tif (!retval)\n\t\t\t\t\tretval = context->put_listent(context,\n\t\t\t\t\t\t\tentry->flags,\n\t\t\t\t\t\t\tname_rmt->name,\n\t\t\t\t\t\t\t(int)name_rmt->namelen,\n\t\t\t\t\t\t\tvaluelen,\n\t\t\t\t\t\t\targs.value);\n\t\t\t\tkmem_free(args.value);\n\t\t\t} else {\n\t\t\t\tretval = context->put_listent(context,\n\t\t\t\t\t\tentry->flags,\n\t\t\t\t\t\tname_rmt->name,\n\t\t\t\t\t\t(int)name_rmt->namelen,\n\t\t\t\t\t\tvaluelen,\n\t\t\t\t\t\tNULL);\n\t\t\t}\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t}\n\t\tif (context->seen_enough)\n\t\t\tbreak;\n\t\tcursor->offset++;\n\t}\n\ttrace_xfs_attr_list_leaf_end(context);\n\treturn retval;\n}\n\n/*\n * Copy out attribute entries for attr_list(), for leaf attribute lists.\n */\nSTATIC int\nxfs_attr_leaf_list(xfs_attr_list_context_t *context)\n{\n\tint error;\n\tstruct xfs_buf *bp;\n\n\ttrace_xfs_attr_leaf_list(context);\n\n\tcontext->cursor->blkno = 0;\n\terror = xfs_attr3_leaf_read(NULL, context->dp, 0, -1, &bp);\n\tif (error)\n\t\treturn error;\n\n\terror = xfs_attr3_leaf_list_int(bp, context);\n\txfs_trans_brelse(NULL, bp);\n\treturn error;\n}\n\nint\nxfs_attr_list_int(\n\txfs_attr_list_context_t *context)\n{\n\tint error;\n\txfs_inode_t *dp = context->dp;\n\tuint\t\tlock_mode;\n\n\tXFS_STATS_INC(dp->i_mount, xs_attr_list);\n\n\tif (XFS_FORCED_SHUTDOWN(dp->i_mount))\n\t\treturn -EIO;\n\n\t/*\n\t * Decide on what work routines to call based on the inode size.\n\t */\n\tlock_mode = xfs_ilock_attr_map_shared(dp);\n\tif (!xfs_inode_hasattr(dp)) {\n\t\terror = 0;\n\t} else if (dp->i_d.di_aformat == XFS_DINODE_FMT_LOCAL) {\n\t\terror = xfs_attr_shortform_list(context);\n\t} else if (xfs_bmap_one_block(dp, XFS_ATTR_FORK)) {\n\t\terror = xfs_attr_leaf_list(context);\n\t} else {\n\t\terror = xfs_attr_node_list(context);\n\t}\n\txfs_iunlock(dp, lock_mode);\n\treturn error;\n}\n\n#define\tATTR_ENTBASESIZE\t\t/* minimum bytes used by an attr */ \\\n\t(((struct attrlist_ent *) 0)->a_name - (char *) 0)\n#define\tATTR_ENTSIZE(namelen)\t\t/* actual bytes used by an attr */ \\\n\t((ATTR_ENTBASESIZE + (namelen) + 1 + sizeof(u_int32_t)-1) \\\n\t & ~(sizeof(u_int32_t)-1))\n\n/*\n * Format an attribute and copy it out to the user's buffer.\n * Take care to check values and protect against them changing later,\n * we may be reading them directly out of a user buffer.\n */\nSTATIC int\nxfs_attr_put_listent(\n\txfs_attr_list_context_t *context,\n\tint\t\tflags,\n\tunsigned char\t*name,\n\tint\t\tnamelen,\n\tint\t\tvaluelen,\n\tunsigned char\t*value)\n{\n\tstruct attrlist *alist = (struct attrlist *)context->alist;\n\tattrlist_ent_t *aep;\n\tint arraytop;\n\n\tASSERT(!(context->flags & ATTR_KERNOVAL));\n\tASSERT(context->count >= 0);\n\tASSERT(context->count < (ATTR_MAX_VALUELEN/8));\n\tASSERT(context->firstu >= sizeof(*alist));\n\tASSERT(context->firstu <= context->bufsize);\n\n\t/*\n\t * Only list entries in the right namespace.\n\t */\n\tif (((context->flags & ATTR_SECURE) == 0) !=\n\t    ((flags & XFS_ATTR_SECURE) == 0))\n\t\treturn 0;\n\tif (((context->flags & ATTR_ROOT) == 0) !=\n\t    ((flags & XFS_ATTR_ROOT) == 0))\n\t\treturn 0;\n\n\tarraytop = sizeof(*alist) +\n\t\t\tcontext->count * sizeof(alist->al_offset[0]);\n\tcontext->firstu -= ATTR_ENTSIZE(namelen);\n\tif (context->firstu < arraytop) {\n\t\ttrace_xfs_attr_list_full(context);\n\t\talist->al_more = 1;\n\t\tcontext->seen_enough = 1;\n\t\treturn 1;\n\t}\n\n\taep = (attrlist_ent_t *)&context->alist[context->firstu];\n\taep->a_valuelen = valuelen;\n\tmemcpy(aep->a_name, name, namelen);\n\taep->a_name[namelen] = 0;\n\talist->al_offset[context->count++] = context->firstu;\n\talist->al_count = context->count;\n\ttrace_xfs_attr_list_add(context);\n\treturn 0;\n}\n\n/*\n * Generate a list of extended attribute names and optionally\n * also value lengths.  Positive return value follows the XFS\n * convention of being an error, zero or negative return code\n * is the length of the buffer returned (negated), indicating\n * success.\n */\nint\nxfs_attr_list(\n\txfs_inode_t\t*dp,\n\tchar\t\t*buffer,\n\tint\t\tbufsize,\n\tint\t\tflags,\n\tattrlist_cursor_kern_t *cursor)\n{\n\txfs_attr_list_context_t context;\n\tstruct attrlist *alist;\n\tint error;\n\n\t/*\n\t * Validate the cursor.\n\t */\n\tif (cursor->pad1 || cursor->pad2)\n\t\treturn -EINVAL;\n\tif ((cursor->initted == 0) &&\n\t    (cursor->hashval || cursor->blkno || cursor->offset))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Check for a properly aligned buffer.\n\t */\n\tif (((long)buffer) & (sizeof(int)-1))\n\t\treturn -EFAULT;\n\tif (flags & ATTR_KERNOVAL)\n\t\tbufsize = 0;\n\n\t/*\n\t * Initialize the output buffer.\n\t */\n\tmemset(&context, 0, sizeof(context));\n\tcontext.dp = dp;\n\tcontext.cursor = cursor;\n\tcontext.resynch = 1;\n\tcontext.flags = flags;\n\tcontext.alist = buffer;\n\tcontext.bufsize = (bufsize & ~(sizeof(int)-1));  /* align */\n\tcontext.firstu = context.bufsize;\n\tcontext.put_listent = xfs_attr_put_listent;\n\n\talist = (struct attrlist *)context.alist;\n\talist->al_count = 0;\n\talist->al_more = 0;\n\talist->al_offset[0] = context.bufsize;\n\n\terror = xfs_attr_list_int(&context);\n\tASSERT(error <= 0);\n\treturn error;\n}\n"], "filenames": ["fs/xfs/xfs_attr_list.c"], "buggy_code_start_loc": [205], "buggy_code_end_loc": [465], "fixing_code_start_loc": [205], "fixing_code_end_loc": [466], "type": "CWE-400", "message": "Multiple memory leaks in error paths in fs/xfs/xfs_attr_list.c in the Linux kernel before 4.5.1 allow local users to cause a denial of service (memory consumption) via crafted XFS filesystem operations.", "other": {"cve": {"id": "CVE-2016-9685", "sourceIdentifier": "cve@mitre.org", "published": "2016-12-28T07:59:00.383", "lastModified": "2018-01-05T02:31:23.370", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Multiple memory leaks in error paths in fs/xfs/xfs_attr_list.c in the Linux kernel before 4.5.1 allow local users to cause a denial of service (memory consumption) via crafted XFS filesystem operations."}, {"lang": "es", "value": "M\u00faltiples fugas de memoria en rutas de error en fs/xfs/xfs_attr_list.c en el kernel de Linux en versiones anteriores a 4.5.1 permiten a usuarios locales provocar una denegaci\u00f3n de servicio (consumo de memoria) a trav\u00e9s de operaciones de archivo de sistema XFS manipuladas."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.5.0", "matchCriteriaId": "F61E0DB9-4FAB-4B47-91DA-A0FAF09E3747"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=2e83b79b2d6c78bf1b4aa227938a214dcbddc83f", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "http://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.5.1", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/11/30/1", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch"]}, {"url": "http://www.securityfocus.com/bid/94593", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2017:1842", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2017:2077", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2017:2669", "source": "cve@mitre.org"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1396941", "source": "cve@mitre.org", "tags": ["Issue Tracking"]}, {"url": "https://github.com/torvalds/linux/commit/2e83b79b2d6c78bf1b4aa227938a214dcbddc83f", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/2e83b79b2d6c78bf1b4aa227938a214dcbddc83f"}}