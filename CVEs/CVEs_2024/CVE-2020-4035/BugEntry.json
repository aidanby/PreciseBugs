{"buggy_code": ["import Foundation\n\nclass DatabaseDriver {\n    typealias SchemaVersion = Int\n    typealias Schema = (version: SchemaVersion, sql: Database.SQL)\n    typealias MigrationSet = (from: SchemaVersion, to: SchemaVersion, sql: Database.SQL)\n\n    struct SchemaNeededError: Error { }\n    struct MigrationNeededError: Error {\n        let databaseVersion: SchemaVersion\n    }\n\n    let database: Database\n\n    convenience init(dbName: String, schemaVersion: SchemaVersion) throws {\n        self.init(dbName: dbName)\n\n        switch isCompatible(withVersion: schemaVersion) {\n        case .compatible: break\n        case .needsSetup:\n            throw SchemaNeededError()\n        case .needsMigration(fromVersion: let dbVersion):\n            throw MigrationNeededError(databaseVersion: dbVersion)\n        }\n    }\n\n    convenience init(dbName: String, setUpWithSchema schema: Schema) {\n        self.init(dbName: dbName)\n\n        do {\n            try unsafeResetDatabase(schema: schema)\n        } catch {\n            fatalError(\"Error while setting up the database: \\(error)\")\n        }\n    }\n\n    convenience init(dbName: String, setUpWithMigrations migrations: MigrationSet) throws {\n        self.init(dbName: dbName)\n        try migrate(with: migrations)\n    }\n\n    private init(dbName: String) {\n        self.database = Database(path: getPath(dbName: dbName))\n    }\n\n    func find(table: Database.TableName, id: RecordId) throws -> Any? {\n        guard !isCached(table, id) else {\n            return id\n        }\n\n        let results = try database.queryRaw(\"select * from \\(table) where id == ? limit 1\", [id])\n\n        guard let record = results.next() else {\n            return nil\n        }\n\n        markAsCached(table, id)\n        return record.resultDictionary!\n    }\n\n    func cachedQuery(table: Database.TableName, query: Database.SQL) throws -> [Any] {\n        return try database.queryRaw(query).map { row in\n            let id = row.string(forColumn: \"id\")!\n\n            if isCached(table, id) {\n                return id\n            } else {\n                markAsCached(table, id)\n                return row.resultDictionary!\n            }\n        }\n    }\n\n    func count(_ query: Database.SQL) throws -> Int {\n        return try database.count(query)\n    }\n\n    enum Operation {\n        case execute(table: Database.TableName, query: Database.SQL, args: Database.QueryArgs)\n        case create(table: Database.TableName, id: RecordId, query: Database.SQL, args: Database.QueryArgs)\n        case destroyPermanently(table: Database.TableName, id: RecordId)\n        case markAsDeleted(table: Database.TableName, id: RecordId)\n        // case destroyDeletedRecords(table: Database.TableName, records: [RecordId])\n        // case setLocal(key: String, value: String)\n        // case removeLocal(key: String)\n    }\n\n    func batch(_ operations: [Operation]) throws {\n        var newIds: [(Database.TableName, RecordId)] = []\n        var removedIds: [(Database.TableName, RecordId)] = []\n\n        try database.inTransaction {\n            for operation in operations {\n                switch operation {\n                case .execute(table: _, query: let query, args: let args):\n                    try database.execute(query, args)\n\n                case .create(table: let table, id: let id, query: let query, args: let args):\n                    try database.execute(query, args)\n                    newIds.append((table, id))\n\n                case .markAsDeleted(table: let table, id: let id):\n                    try database.execute(\"update \\(table) set _status='deleted' where id == ?\", [id])\n                    removedIds.append((table, id))\n\n                case .destroyPermanently(table: let table, id: let id):\n                    // TODO: What's the behavior if nothing got deleted?\n                    try database.execute(\"delete from \\(table) where id == ?\", [id])\n                    removedIds.append((table, id))\n                }\n            }\n        }\n\n        for (table, id) in newIds {\n            markAsCached(table, id)\n        }\n\n        for (table, id) in removedIds {\n            removeFromCache(table, id)\n        }\n    }\n\n    func getDeletedRecords(table: Database.TableName) throws -> [RecordId] {\n        return try database.queryRaw(\"select id from \\(table) where _status='deleted'\").map { row in\n            row.string(forColumn: \"id\")!\n        }\n    }\n\n    func destroyDeletedRecords(table: Database.TableName, records: [RecordId]) throws {\n        // TODO: What's the behavior if record doesn't exist or isn't actually deleted?\n        let recordIds = records.map { id in \"'\\(id)'\" }.joined(separator: \",\")\n        try database.execute(\"delete from \\(table) where id in (\\(recordIds))\")\n    }\n\n// MARK: - LocalStorage\n\n    func getLocal(key: String) throws -> String? {\n        let results = try database.queryRaw(\"select value from local_storage where key = ?\", [key])\n\n        guard let record = results.next() else {\n            return nil\n        }\n\n        return record.string(forColumn: \"value\")!\n    }\n\n    func setLocal(key: String, value: String) throws {\n        return try database.execute(\"insert or replace into local_storage (key, value) values (?, ?)\", [key, value])\n    }\n\n    func removeLocal(key: String) throws {\n        return try database.execute(\"delete from local_storage where key == ?\", [key])\n    }\n\n// MARK: - Record caching\n\n    typealias RecordId = String\n\n    // Rewritten to use good ol' mutable Objective C for performance\n    // The swifty implementation in debug took >100s to execute on a 65K batch. This: 6ms. Yes. Really.\n    private var cachedRecords: NSMutableDictionary /* [TableName: Set<RecordId>] */ = NSMutableDictionary()\n\n    func isCached(_ table: Database.TableName, _ id: RecordId) -> Bool {\n        if let set = cachedRecords[table] as? NSSet {\n            return set.contains(id)\n        }\n        return false\n    }\n\n    private func markAsCached(_ table: Database.TableName, _ id: RecordId) {\n        var cachedSet: NSMutableSet\n        if let set = cachedRecords[table] as? NSMutableSet {\n            cachedSet = set\n        } else {\n            cachedSet = NSMutableSet()\n            cachedRecords[table] = cachedSet\n        }\n        cachedSet.add(id)\n    }\n\n    private func removeFromCache(_ table: Database.TableName, _ id: RecordId) {\n        if let set = cachedRecords[table] as? NSMutableSet {\n            set.remove(id)\n        }\n    }\n\n// MARK: - Other private details\n\n    private enum SchemaCompatibility {\n        case compatible\n        case needsSetup\n        case needsMigration(fromVersion: SchemaVersion)\n    }\n\n    private func isCompatible(withVersion schemaVersion: SchemaVersion) -> SchemaCompatibility {\n        let databaseVersion = database.userVersion\n\n        switch databaseVersion {\n        case schemaVersion: return .compatible\n        case 0: return .needsSetup\n        case (1..<schemaVersion): return .needsMigration(fromVersion: databaseVersion)\n        default:\n            consoleLog(\"Database has newer version (\\(databaseVersion)) than what the \" +\n                \"app supports (\\(schemaVersion)). Will reset database.\")\n            return .needsSetup\n        }\n    }\n\n    func unsafeResetDatabase(schema: Schema) throws {\n        try database.unsafeDestroyEverything()\n        cachedRecords = [:]\n\n        try setUpSchema(schema: schema)\n    }\n\n    private func setUpSchema(schema: Schema) throws {\n        try database.inTransaction {\n            try database.executeStatements(schema.sql + localStorageSchema)\n            database.userVersion = schema.version\n        }\n    }\n\n    private func migrate(with migrations: MigrationSet) throws {\n        precondition(\n            database.userVersion == migrations.from,\n            \"Incompatbile migration set applied. DB: \\(database.userVersion), migration: \\(migrations.from)\"\n        )\n\n        try database.inTransaction {\n            try database.executeStatements(migrations.sql)\n            database.userVersion = migrations.to\n        }\n    }\n\n    private let localStorageSchema = \"\"\"\n        create table local_storage (\n        key varchar(16) primary key not null,\n        value text not null\n        );\n\n        create index local_storage_key_index on local_storage (key);\n    \"\"\"\n}\n\nprivate func getPath(dbName: String) -> String {\n    // If starts with `file:` or contains `/`, it's a path!\n    if dbName.starts(with: \"file:\") || dbName.contains(\"/\") {\n        return dbName\n    } else {\n        // swiftlint:disable:next force_try\n        return try! FileManager.default\n            .url(for: .documentDirectory, in: .userDomainMask, appropriateFor: nil, create: false)\n            .appendingPathComponent(\"\\(dbName).db\")\n            .path\n    }\n}\n", "import expect from 'expect'\nimport naughtyStrings from 'big-list-of-naughty-strings'\n\nimport Model from '../../Model'\nimport Query from '../../Query'\nimport { sanitizedRaw } from '../../RawRecord'\nimport * as Q from '../../QueryDescription'\nimport { appSchema, tableSchema } from '../../Schema'\nimport { schemaMigrations, createTable, addColumns } from '../../Schema/migrations'\n\nimport { matchTests, naughtyMatchTests, joinTests } from '../../__tests__/databaseTests'\nimport DatabaseAdapterCompat from '../compat'\nimport {\n  testSchema,\n  taskQuery,\n  mockTaskRaw,\n  performMatchTest,\n  performJoinTest,\n  expectSortedEqual,\n  MockTask,\n  mockProjectRaw,\n  projectQuery,\n} from './helpers'\n\nclass BadModel extends Model {\n  static table = 'nonexistent'\n}\n\nexport default () => [\n  [\n    'validates adapter options',\n    async (_adapter, AdapterClass) => {\n      const schema = { ...testSchema, version: 10 }\n\n      const makeAdapter = options => new AdapterClass({ schema, ...options })\n      const adapterWithMigrations = migrations => makeAdapter({ migrations })\n\n      // expect(() => makeAdapter({})).toThrowError(/missing migrations/)\n\n      expect(() => makeAdapter({ migrationsExperimental: [] })).toThrow(\n        /`migrationsExperimental` option has been renamed to `migrations`/,\n      )\n\n      if (AdapterClass.name === 'LokiJSAdapter') {\n        expect(() => makeAdapter({ experimentalUseIncrementalIndexedDB: false })).toThrow(\n          /LokiJSAdapter `experimentalUseIncrementalIndexedDB` option has been renamed/,\n        )\n      }\n\n      expect(() => adapterWithMigrations({ migrations: [] })).toThrow(/use schemaMigrations()/)\n\n      // OK migrations passed\n      const adapterWithRealMigrations = migrations =>\n        adapterWithMigrations(schemaMigrations({ migrations }))\n\n      expect(() => adapterWithRealMigrations([{ toVersion: 10, steps: [] }])).not.toThrow()\n      expect(() =>\n        adapterWithRealMigrations([{ toVersion: 10, steps: [] }, { toVersion: 9, steps: [] }]),\n      ).not.toThrow()\n\n      // Empty migrations only allowed if version 1\n      expect(\n        () =>\n          new AdapterClass({\n            schema: { ...testSchema, version: 1 },\n            migrations: schemaMigrations({ migrations: [] }),\n          }),\n      ).not.toThrow()\n      expect(() => adapterWithRealMigrations([])).toThrow(/Missing migration/)\n\n      // Migrations can't be newer than schema\n      expect(() => adapterWithRealMigrations([{ toVersion: 11, steps: [] }])).toThrow(\n        /migrations can't be newer than schema/i,\n      )\n      // Migration to latest version must be present\n      expect(() =>\n        adapterWithRealMigrations([{ toVersion: 9, steps: [] }, { toVersion: 8, steps: [] }]),\n      ).toThrow(/Missing migration/)\n    },\n  ],\n  [\n    'can query and count on empty db',\n    async adapter => {\n      const query = taskQuery()\n      expect(await adapter.query(query)).toEqual([])\n      expect(await adapter.count(query)).toBe(0)\n    },\n  ],\n  [\n    'can create and find records (sanity test)',\n    async adapter => {\n      const record = mockTaskRaw({ id: 'abc', text1: 'bar', order: 1 })\n      await adapter.batch([['create', 'tasks', record]])\n      expect(await adapter.find('tasks', 'abc')).toBe('abc')\n    },\n  ],\n  [\n    'can find records by ID',\n    async _adapter => {\n      let adapter = _adapter\n\n      // add a record\n      const s1 = mockTaskRaw({ id: 's1', text1: 'bar', order: 1 })\n      await adapter.batch([['create', 'tasks', s1]])\n\n      // returns cached ID after create\n      expect(await adapter.find('tasks', 's1')).toBe('s1')\n\n      // add more, restart app\n      const s2 = mockTaskRaw({ id: 's2', bool1: true, order: 2 })\n      const s3 = mockTaskRaw({ id: 's3', text1: 'baz' })\n      await adapter.batch([['create', 'tasks', s2], ['create', 'tasks', s3]])\n      adapter = await adapter.testClone()\n\n      // returns raw if not cached\n      expect(await adapter.find('tasks', 's2')).toEqual(s2)\n      expect(await adapter.find('tasks', 's3')).toEqual(s3)\n\n      // caches records after first find\n      expect(await adapter.find('tasks', 's2')).toBe('s2')\n\n      // returns null if not found\n      expect(await adapter.find('tasks', 's4')).toBe(null)\n    },\n  ],\n  [\n    'can cache non-global IDs on find',\n    async _adapter => {\n      let adapter = _adapter\n\n      // add a record\n      const s1 = mockTaskRaw({ id: 'id1', text1: 'bar', order: 1 })\n      await adapter.batch([['create', 'tasks', s1]])\n\n      // returns null if not found in a different table\n      expect(await adapter.find('projects', 'id1')).toBe(null)\n\n      const p1 = mockProjectRaw({ id: 'id1', num1: 1, text1: 'foo' })\n      await adapter.batch([['create', 'projects', p1]])\n\n      // returns cached ID after create\n      expect(await adapter.find('projects', 'id1')).toBe('id1')\n\n      // add more project, restart app\n      const p2 = mockProjectRaw({ id: 'id2', num1: 1, text1: 'foo' })\n      await adapter.batch([['create', 'projects', p2]])\n      adapter = await adapter.testClone()\n\n      const s2 = mockTaskRaw({ id: 'id2', text1: 'baz', order: 2 })\n      await adapter.batch([['create', 'tasks', s2]])\n\n      // returns cached ID after create\n      expect(await adapter.find('tasks', 'id2')).toBe('id2')\n\n      // returns raw if not cached for a different table\n      expect(await adapter.find('projects', 'id2')).toEqual(p2)\n      // returns cached ID after previous find\n      expect(await adapter.find('projects', 'id2')).toBe('id2')\n    },\n  ],\n  [\n    'can cache non-global IDs on query',\n    async _adapter => {\n      let adapter = _adapter\n\n      // add a record\n      const s1 = mockTaskRaw({ id: 'id1', text1: 'bar', order: 1 })\n      await adapter.batch([['create', 'tasks', s1]])\n\n      // returns empty array\n      expectSortedEqual(await adapter.query(projectQuery()), [])\n\n      const p1 = mockProjectRaw({ id: 'id1', num1: 1, text1: 'foo' })\n      await adapter.batch([['create', 'projects', p1]])\n\n      // returns cached ID after create\n      expectSortedEqual(await adapter.query(projectQuery()), ['id1'])\n\n      // add more project, restart app\n      const p2 = mockProjectRaw({ id: 'id2', num1: 1, text1: 'foo' })\n      await adapter.batch([['create', 'projects', p2]])\n      adapter = await adapter.testClone()\n\n      const s2 = mockTaskRaw({ id: 'id2', text1: 'baz', order: 2 })\n      await adapter.batch([['create', 'tasks', s2]])\n\n      // returns cached IDs after create\n      expectSortedEqual(await adapter.query(taskQuery()), [s1, 'id2'])\n\n      // returns raw if not cached for a different table\n      expectSortedEqual(await adapter.query(projectQuery()), [p1, p2])\n      // returns cached IDs after previous query\n      expectSortedEqual(await adapter.query(taskQuery()), ['id1', 'id2'])\n    },\n  ],\n  [\n    'sanitizes records on find',\n    async _adapter => {\n      let adapter = _adapter\n      const tt1 = { id: 'tt1', task_id: 'abcdef' } // Unsanitized raw!\n\n      await adapter.batch([['create', 'tag_assignments', tt1]])\n      adapter = await adapter.testClone()\n\n      expect(await adapter.find('tag_assignments', 'tt1')).toEqual(\n        sanitizedRaw(tt1, testSchema.tables.tag_assignments),\n      )\n    },\n  ],\n  [\n    'can query and count records',\n    async adapter => {\n      const record1 = mockTaskRaw({ id: 't1', text1: 'bar', bool1: false, order: 1 })\n      const record2 = mockTaskRaw({ id: 't2', text1: 'baz', bool1: true, order: 2 })\n      const record3 = mockTaskRaw({ id: 't3', text1: 'abc', bool1: false, order: 3 })\n\n      await adapter.batch([\n        ['create', 'tasks', record1],\n        ['create', 'tasks', record2],\n        ['create', 'tasks', record3],\n      ])\n\n      // all records\n      expectSortedEqual(await adapter.query(taskQuery()), ['t1', 't2', 't3'])\n      expect(await adapter.count(taskQuery())).toBe(3)\n\n      // some records\n      expectSortedEqual(await adapter.query(taskQuery(Q.where('bool1', false))), ['t1', 't3'])\n      expectSortedEqual(await adapter.query(taskQuery(Q.where('order', 2))), ['t2'])\n      expectSortedEqual(await adapter.query(taskQuery(Q.where('order', 3))), ['t3'])\n\n      expect(await adapter.count(taskQuery(Q.where('bool1', false)))).toBe(2)\n\n      // no records\n      expectSortedEqual(await adapter.query(taskQuery(Q.where('text1', 'nope'))), [])\n      expect(await adapter.count(taskQuery(Q.where('text1', 'nope')))).toBe(0)\n      expect(await adapter.count(taskQuery(Q.where('order', 4)))).toBe(0)\n    },\n  ],\n  [\n    'can query records in raw query format',\n    async (adapter, AdapterClass) => {\n      if (AdapterClass.name === 'SQLiteAdapter') {\n        const record1 = mockTaskRaw({ id: 't1', text1: 'bar', bool1: false, order: 1 })\n        const record2 = mockTaskRaw({ id: 't2', text1: 'baz', bool1: true, order: 2 })\n        const record3 = mockTaskRaw({ id: 't3', text1: 'abc', bool1: false, order: 3 })\n\n        await adapter.batch([\n          ['create', 'tasks', record1],\n          ['create', 'tasks', record2],\n          ['create', 'tasks', record3],\n        ])\n\n        // all records\n        expectSortedEqual(await adapter.unsafeSqlQuery('tasks', `SELECT * FROM tasks`), [\n          't1',\n          't2',\n          't3',\n        ])\n\n        expectSortedEqual(\n          await adapter.unsafeSqlQuery('tasks', `SELECT * FROM tasks WHERE bool1 = 0`),\n          ['t1', 't3'],\n        )\n\n        expectSortedEqual(\n          await adapter.unsafeSqlQuery('tasks', `SELECT * FROM tasks WHERE id = 't2'`),\n          ['t2'],\n        )\n\n        expectSortedEqual(\n          await adapter.unsafeSqlQuery('tasks', `SELECT * FROM tasks WHERE \\`order\\` = 2`),\n          ['t2'],\n        )\n\n        expectSortedEqual(\n          await adapter.unsafeSqlQuery('tasks', `SELECT * FROM tasks WHERE text1 = 'nope'`),\n          [],\n        )\n      } else {\n        expect(adapter.unsafeSqlQuery).toBe(undefined)\n      }\n    },\n  ],\n  [\n    'compacts query results',\n    async _adapter => {\n      let adapter = _adapter\n      const queryAll = () => adapter.query(taskQuery())\n\n      // add records, restart app\n      const s1 = mockTaskRaw({ id: 's1', order: 1 })\n      const s2 = mockTaskRaw({ id: 's2', order: 2 })\n      await adapter.batch([['create', 'tasks', s1], ['create', 'tasks', s2]])\n      adapter = await adapter.testClone()\n\n      // first time we see it, get full object\n      expectSortedEqual(await queryAll(), [s1, s2])\n\n      // cached next time\n      expect(await queryAll()).toEqual(['s1', 's2'])\n\n      // updating doesn't change anything\n      await adapter.batch([['update', 'tasks', s2]])\n      expect(await queryAll()).toEqual(['s1', 's2'])\n\n      // records added via adapter get cached automatically\n      const s3 = mockTaskRaw({ id: 's3' })\n      await adapter.batch([['create', 'tasks', s3]])\n      expect(await queryAll()).toEqual(['s1', 's2', 's3'])\n\n      // remove and re-add and it appears again\n      await adapter.batch([['destroyPermanently', 'tasks', s3.id]])\n      expect(await queryAll()).toEqual(['s1', 's2'])\n\n      const s3New = mockTaskRaw({ id: 's3', bool1: true })\n      await adapter.batch([['create', 'tasks', s3New]])\n      expect(await queryAll()).toEqual(['s1', 's2', 's3'])\n\n      // restart app, doesn't have the records\n      adapter = await adapter.testClone()\n      expectSortedEqual(await queryAll(), [s1, s2, s3New])\n    },\n  ],\n  [\n    'sanitizes records on query',\n    async _adapter => {\n      let adapter = _adapter\n      // Unsanitized raw!\n      const t1 = { id: 't1', text1: 'foo', order: 1 }\n      const t2 = { id: 't2', text2: 'bar', order: 2 }\n\n      await adapter.batch([['create', 'tasks', t1], ['create', 'tasks', t2]])\n      adapter = await adapter.testClone()\n\n      expectSortedEqual(await adapter.query(taskQuery()), [\n        sanitizedRaw(t1, testSchema.tables.tasks),\n        sanitizedRaw(t2, testSchema.tables.tasks),\n      ])\n    },\n  ],\n  [\n    'returns a COPY of the data',\n    async _adapter => {\n      let adapter = _adapter\n      const raw = mockTaskRaw({ id: 't1', text1: 'bar' })\n      const originalRaw = { ...raw }\n      await adapter.batch([['create', 'tasks', raw]])\n\n      adapter = await adapter.testClone()\n      const fetchedRaw = await adapter.find('tasks', 't1')\n\n      // data is equal but not the same reference\n      expect(fetchedRaw).toEqual(originalRaw)\n      expect(fetchedRaw).toEqual(raw)\n      expect(fetchedRaw).not.toBe(raw)\n\n      // make sure same is true for query\n      adapter = await adapter.testClone()\n      const [queriedRaw] = await adapter.query(taskQuery())\n      expect(queriedRaw).toEqual(originalRaw)\n      expect(queriedRaw).not.toBe(raw)\n    },\n  ],\n  [\n    'can update records',\n    async _adapter => {\n      let adapter = _adapter\n      const raw = mockTaskRaw({ id: 't1', text1: 'bar' })\n      await adapter.batch([['create', 'tasks', raw]])\n      raw.bool1 = true\n      raw.order = 2\n      await adapter.batch([['update', 'tasks', raw]])\n\n      adapter = await adapter.testClone()\n      const fetchedUpdatedRaw = await adapter.find('tasks', 't1')\n\n      // check raws are equal (but a copy)\n      expect(fetchedUpdatedRaw.bool1).toBe(true)\n      expect(fetchedUpdatedRaw.order).toBe(2)\n      expect(fetchedUpdatedRaw).toEqual(raw)\n      expect(fetchedUpdatedRaw).not.toBe(raw)\n    },\n  ],\n  [\n    'can mark records as deleted',\n    async adapter => {\n      const m1 = mockTaskRaw({ id: 't1', text1: 'bar1' })\n      await adapter.batch([['create', 'tasks', m1]])\n      expect(await adapter.query(taskQuery())).toEqual(['t1'])\n\n      await adapter.batch([['markAsDeleted', 'tasks', m1.id]])\n      expect(await adapter.query(taskQuery())).toEqual([])\n\n      // Check that the record is removed from cache\n      // HACK: Set _status to reveal the record in query (if record was cached, there would only be ID)\n      m1._status = 'synced'\n      await adapter.batch([['update', 'tasks', m1]])\n      expectSortedEqual(await adapter.query(taskQuery()), [m1])\n    },\n  ],\n  [\n    'can get deleted record ids',\n    async adapter => {\n      const m1 = mockTaskRaw({ id: 't1', text1: 'bar1', order: 1 })\n      const m2 = mockTaskRaw({ id: 't2', text1: 'bar2', order: 2 })\n      await adapter.batch([\n        ['create', 'tasks', m1],\n        ['markAsDeleted', 'tasks', m1.id],\n        ['create', 'tasks', m2],\n        ['create', 'tasks', mockTaskRaw({ id: 't3', text1: 'bar3' })],\n        ['markAsDeleted', 'tasks', m2.id],\n      ])\n      expectSortedEqual(await adapter.getDeletedRecords('tasks'), ['t2', 't1'])\n    },\n  ],\n  [\n    'can destroy deleted records',\n    async adapter => {\n      const m1 = mockTaskRaw({ id: 't1', text1: 'bar1', order: 1 })\n      const m2 = mockTaskRaw({ id: 't2', text1: 'bar2', order: 2 })\n      const m3 = mockTaskRaw({ id: 't3', text1: 'bar3', order: 3 })\n      await adapter.batch([\n        ['create', 'tasks', m1],\n        ['create', 'tasks', m2],\n        ['create', 'tasks', m3],\n        ['create', 'tasks', mockTaskRaw({ id: 't4', text1: 'bar4' })],\n      ])\n      await adapter.batch([\n        ['markAsDeleted', 'tasks', m1.id],\n        ['markAsDeleted', 'tasks', m2.id],\n        ['markAsDeleted', 'tasks', m3.id],\n      ])\n\n      await adapter.destroyDeletedRecords('tasks', ['t1', 't2'])\n      expectSortedEqual(await adapter.getDeletedRecords('tasks'), ['t3'])\n      expectSortedEqual(await adapter.query(taskQuery()), ['t4'])\n      expect(await adapter.find('tasks', 't1')).toBeNull()\n      expect(await adapter.find('tasks', 't2')).toBeNull()\n    },\n  ],\n  [\n    'can run mixed batches',\n    async _adapter => {\n      let adapter = _adapter\n      const m1 = mockTaskRaw({ id: 't1', text1: 'bar' })\n      const m3 = mockTaskRaw({ id: 't3' })\n      const m4 = mockTaskRaw({ id: 't4' })\n\n      await adapter.batch([['create', 'tasks', m1]])\n\n      m1.bool1 = true\n      const m2 = mockTaskRaw({ id: 't2', text1: 'bar', bool2: true, order: 2 })\n\n      await adapter.batch([\n        ['create', 'tasks', m3],\n        ['create', 'tasks', m4],\n        ['destroyPermanently', 'tasks', m3.id],\n        ['update', 'tasks', m1],\n        ['create', 'tasks', m2],\n        ['markAsDeleted', 'tasks', m4.id],\n      ])\n\n      adapter = await adapter.testClone()\n      const fetched1 = await adapter.find('tasks', 't1')\n      expect(fetched1.bool1).toBe(true)\n      expect(fetched1).toEqual(m1)\n\n      const fetched2 = await adapter.find('tasks', 't2')\n      expect(fetched2.bool2).toBe(true)\n\n      expect(await adapter.find('tasks', 't3')).toBeNull()\n      expect(await adapter.query(taskQuery())).toEqual(['t1', 't2'])\n\n      expect(await adapter.getDeletedRecords('tasks')).toEqual(['t4'])\n    },\n  ],\n  [\n    'batches are transactional',\n    async (adapter, AdapterClass) => {\n      // sanity check\n      await adapter.batch([['create', 'tasks', mockTaskRaw({ id: 't1' })]])\n      expect(await adapter.query(taskQuery())).toEqual(['t1'])\n\n      await expect(\n        adapter.batch([\n          ['create', 'tasks', mockTaskRaw({ id: 't2' })],\n          ['create', 'does_not_exist', mockTaskRaw({ id: 't3' })],\n        ]),\n      ).rejects.toMatchObject({\n        // TODO: Get rid of the unknown error - fix on Android\n        message: expect.stringMatching(\n          AdapterClass.name === 'SQLiteAdapter'\n            ? /(no such table: does_not_exist|Exception in HostFunction: <unknown>)/\n            : /Cannot read property 'insert' of null/,\n        ),\n      })\n      if (AdapterClass.name !== 'LokiJSAdapter') {\n        // Regrettably, Loki is not transactional\n        expect(await adapter.query(taskQuery())).toEqual(['t1'])\n      }\n    },\n  ],\n  [\n    'can run sync-like flow',\n    async adapter => {\n      const queryAll = () => adapter.query(taskQuery())\n\n      const m1 = mockTaskRaw({ id: 't1', text1: 'bar1', order: 1 })\n      const m2 = mockTaskRaw({ id: 't2', text1: 'bar2', order: 2 })\n      const m3 = mockTaskRaw({ id: 't3', text1: 'bar3', order: 3 })\n\n      await adapter.batch([\n        ['create', 'tasks', m1],\n        ['create', 'tasks', m2],\n        ['create', 'tasks', m3],\n        ['create', 'tasks', mockTaskRaw({ id: 't4', text1: 'bar4' })],\n        ['markAsDeleted', 'tasks', m1.id],\n        ['markAsDeleted', 'tasks', m3.id],\n      ])\n\n      // pull server changes - server wants us to delete some records\n      await adapter.batch([\n        ['destroyPermanently', 'tasks', m1.id],\n        ['destroyPermanently', 'tasks', m2.id],\n      ])\n      expect(await queryAll()).toHaveLength(1)\n\n      // push local changes\n      const toDelete = await adapter.getDeletedRecords('tasks')\n      expect(toDelete).toEqual(['t3'])\n      await adapter.destroyDeletedRecords('tasks', toDelete)\n\n      expect(await adapter.getDeletedRecords('tasks')).toHaveLength(0)\n      expect(await queryAll()).toHaveLength(1)\n    },\n  ],\n  [\n    'can unsafely reset database',\n    async adapter => {\n      await adapter.batch([['create', 'tasks', mockTaskRaw({ id: 't1', text1: 'bar', order: 1 })]])\n      await adapter.unsafeResetDatabase()\n      await expect(await adapter.count(taskQuery())).toBe(0)\n\n      // check that reset database still works\n      await adapter.batch([['create', 'tasks', mockTaskRaw({ id: 't2', text1: 'baz', order: 2 })]])\n      expect(await adapter.count(taskQuery())).toBe(1)\n    },\n  ],\n  [\n    'queues actions correctly',\n    async adapter => {\n      function queryable(promise) {\n        let isSettled = false\n        const result = promise.then(\n          value => {\n            isSettled = true\n            return value\n          },\n          e => {\n            isSettled = true\n            throw e\n          },\n        )\n        result.isSettled = () => isSettled\n        return result\n      }\n\n      adapter.batch([['create', 'tasks', mockTaskRaw({ id: 't1', text1: 'foo', order: 1 })]])\n      const find1Promise = queryable(adapter.find('tasks', 't1'))\n      const find2Promise = queryable(adapter.find('tasks', 't2'))\n      adapter.batch([['create', 'tasks', mockTaskRaw({ id: 't2', text1: 'bar', order: 2 })]])\n      const queryPromise = queryable(adapter.query(taskQuery()))\n      const find2Promise2 = queryable(adapter.find('tasks', 't2'))\n\n      await find2Promise2\n\n      expect(find1Promise.isSettled()).toBe(true)\n      expect(find2Promise.isSettled()).toBe(true)\n      expect(queryPromise.isSettled()).toBe(true)\n      expect(find2Promise2.isSettled()).toBe(true)\n      expect(await find1Promise).toBe('t1')\n      expect(await find2Promise).toBe(null)\n      expect(await queryPromise).toEqual(['t1', 't2'])\n      expect(await find2Promise2).toBe('t2')\n\n      // unsafeResetDatabase is the only action in loki that's necessarily asynchronous even in sync mode\n      const batchPromise = queryable(\n        adapter.batch([['create', 'tasks', mockTaskRaw({ id: 't3', text1: 'bar', order: 2 })]]),\n      )\n      adapter.unsafeResetDatabase()\n      adapter.batch([['create', 'tasks', mockTaskRaw({ id: 't1', text1: 'bar', order: 2 })]])\n      const queryPromise2 = adapter.query(taskQuery())\n\n      expect(await queryPromise2).toEqual(['t1'])\n      expect(batchPromise.isSettled()).toBe(true)\n    },\n  ],\n  [\n    'fails on bad queries, creates, updates, deletes',\n    async adapter => {\n      const badQuery = new Query({ modelClass: BadModel }, []).serialize()\n      await expect(adapter.query(badQuery)).rejects.toBeInstanceOf(Error)\n      await expect(adapter.count(badQuery)).rejects.toBeInstanceOf(Error)\n\n      const record1 = new BadModel({ table: 'nonexisting' }, { id: 't1' })\n      await expect(adapter.batch([['create', record1]])).rejects.toBeInstanceOf(Error)\n\n      await expect(adapter.batch(['create', record1])).rejects.toBeInstanceOf(Error)\n\n      // TODO: Fix slight inconsistencies between loki & sqlite\n      // if (platform.isWeb) {\n      // await expect(\n      //   adapter.batch([['update', 'tasks', mockTaskRaw({ id: 'nonexists' })]]),\n      // ).rejects.toBeInstanceOf(Error)\n\n      // TODO: Mark as deleted?\n\n      // const record = 'tasks', mockTaskRaw({ id: '1' })\n      // await expect(adapter.batch([['destroyPermanently', record]])).rejects.toBeInstanceOf(Error)\n      // }\n    },\n  ],\n  [\n    'supports LocalStorage',\n    async adapter => {\n      // non-existent fields return undefined\n      expect(await adapter.getLocal('nonexisting')).toBeNull()\n\n      // set\n      await adapter.setLocal('test1', 'val1')\n      expect(await adapter.getLocal('test1')).toBe('val1')\n\n      // update\n      await adapter.setLocal('test1', 'val2')\n      expect(await adapter.getLocal('test1')).toBe('val2')\n\n      // delete\n      await adapter.removeLocal('test1')\n      expect(await adapter.getLocal('test1')).toBeNull()\n\n      // can be safely reassigned\n      await adapter.setLocal('test1', 'val3')\n      expect(await adapter.getLocal('test1')).toBe('val3')\n\n      // can use keywords as keys\n      // can be safely reassigned\n      await adapter.setLocal('order', '3')\n      expect(await adapter.getLocal('order')).toBe('3')\n\n      // deleting already undefined is safe\n      await adapter.removeLocal('nonexisting')\n    },\n  ],\n  [\n    'migrates database between versions',\n    async (_adapter, AdapterClass, extraAdapterOptions) => {\n      // launch app in one version\n      const taskColumnsV3 = [{ name: 'num1', type: 'number' }]\n      const projectColumnsV3 = [{ name: 'text1', type: 'string' }]\n      const testSchemaV3 = appSchema({\n        version: 3,\n        tables: [\n          tableSchema({ name: 'tasks', columns: taskColumnsV3 }),\n          tableSchema({ name: 'projects', columns: projectColumnsV3 }),\n        ],\n      })\n\n      let adapter = new DatabaseAdapterCompat(\n        new AdapterClass({\n          schema: testSchemaV3,\n          migrations: schemaMigrations({ migrations: [{ toVersion: 3, steps: [] }] }),\n          ...extraAdapterOptions,\n        }),\n      )\n      // TODO: Remove me. Temporary workaround for the race condition - wait until next macrotask to ensure that database has set up\n      await new Promise(resolve => setTimeout(resolve, 0))\n      // add data\n      await adapter.batch([\n        ['create', 'tasks', { id: 't1', num1: 10 }],\n        ['create', 'tasks', { id: 't2', num1: 20 }],\n      ])\n\n      // can't add to tables that don't exist yet\n      await expect(\n        adapter.batch([['create', 'tag_assignments', { id: 'tt1', text1: 'hello' }]]),\n      ).rejects.toBeInstanceOf(Error)\n\n      // migrate to new version\n      const taskColumnsV5 = [\n        { name: 'test_string', type: 'string' },\n        { name: 'test_string_optional', type: 'string', isOptional: true },\n        { name: 'test_number', type: 'number' },\n        { name: 'test_number_optional', type: 'number', isOptional: true },\n        { name: 'test_boolean', type: 'boolean' },\n        { name: 'test_boolean_optional', type: 'boolean', isOptional: true },\n      ]\n      const projectColumnsV5 = [{ name: 'text2', type: 'string', isIndexed: true }]\n      const tagAssignmentSchema = {\n        name: 'tag_assignments',\n        columns: [{ name: 'text1', type: 'string' }],\n      }\n\n      const testSchemaV5 = appSchema({\n        version: 5,\n        tables: [\n          tableSchema({\n            name: 'tasks',\n            columns: [...taskColumnsV3, ...taskColumnsV5],\n          }),\n          tableSchema({\n            name: 'projects',\n            columns: [...projectColumnsV3, ...projectColumnsV5],\n          }),\n          tableSchema(tagAssignmentSchema),\n        ],\n      })\n      const migrationsV5 = schemaMigrations({\n        migrations: [\n          {\n            toVersion: 5,\n            steps: [addColumns({ table: 'tasks', columns: taskColumnsV5 })],\n          },\n          {\n            toVersion: 4,\n            steps: [\n              createTable(tagAssignmentSchema),\n              addColumns({ table: 'projects', columns: projectColumnsV5 }),\n            ],\n          },\n          {\n            toVersion: 3,\n            steps: [\n              createTable({\n                name: 'will_not_be_created',\n                columns: [{ name: 'num1', type: 'number' }],\n              }),\n            ],\n          },\n        ],\n      })\n      adapter = await adapter.testClone({\n        schema: testSchemaV5,\n        migrations: migrationsV5,\n      })\n\n      // check that the data is still there\n      expect(await adapter.count(new Query({ modelClass: MockTask }, []))).toBe(2)\n\n      // check if new columns were populated with appropriate default values\n      const checkTaskColumn = (columnName, expectedValue) =>\n        new Query({ modelClass: MockTask }, [Q.where(columnName, expectedValue)]).serialize()\n\n      expect(await adapter.count(checkTaskColumn('test_string', ''))).toBe(2)\n      expect(await adapter.count(checkTaskColumn('test_string_optional', null))).toBe(2)\n      expect(await adapter.count(checkTaskColumn('test_number', 0))).toBe(2)\n      expect(await adapter.count(checkTaskColumn('test_number_optional', null))).toBe(2)\n      expect(await adapter.count(checkTaskColumn('test_boolean', false))).toBe(2)\n      expect(await adapter.count(checkTaskColumn('test_boolean_optional', null))).toBe(2)\n\n      // check I can use new table and columns\n      await adapter.batch([\n        ['create', 'tag_assignments', { id: 'tt2', text1: 'hello' }],\n        ['create', 'projects', { id: 'p1', text1: 'hey', text2: 'foo' }],\n        [\n          'create',\n          'tasks',\n          { id: 't3', test_string: 'hey', test_number: 2, test_boolean_optional: true },\n        ],\n      ])\n\n      // check that out-of-range migration was not executed\n      await expect(\n        adapter.batch([['create', 'will_not_be_created', { id: 'w1', text1: 'hello' }]]),\n      ).rejects.toBeInstanceOf(Error)\n\n      // make sure new fields actually work and that migrations won't be applied again\n      adapter = await adapter.testClone()\n\n      const p1 = await adapter.find('projects', 'p1')\n      expect(p1.text2).toBe('foo')\n\n      const t1 = await adapter.find('tasks', 't3')\n      expect(t1.test_string).toBe('hey')\n      expect(t1.test_number).toBe(2)\n      expect(t1.test_boolean).toBe(false)\n\n      const tt1 = await adapter.find('tag_assignments', 'tt2')\n      expect(tt1.text1).toBe('hello')\n    },\n  ],\n  [\n    `can perform empty migrations (regression test)`,\n    async (_adapter, AdapterClass, extraAdapterOptions) => {\n      let adapter = new DatabaseAdapterCompat(\n        new AdapterClass({\n          schema: { ...testSchema, version: 1 },\n          migrations: schemaMigrations({ migrations: [] }),\n          ...extraAdapterOptions,\n        }),\n      )\n      // TODO: Remove me. Temporary workaround for the race condition - wait until next macrotask to ensure that database has set up\n      await new Promise(resolve => setTimeout(resolve, 0))\n      await adapter.batch([['create', 'tasks', mockTaskRaw({ id: 't1', text1: 'foo' })]])\n      expect(await adapter.count(taskQuery())).toBe(1)\n\n      // Perform an empty migration (no steps, just version bump)\n      adapter = await adapter.testClone({\n        schema: { ...testSchema, version: 2 },\n        migrations: schemaMigrations({ migrations: [{ toVersion: 2, steps: [] }] }),\n      })\n\n      // check that migration worked, no data lost\n      expect(await adapter.count(taskQuery())).toBe(1)\n      expect((await adapter.find('tasks', 't1')).text1).toBe('foo')\n    },\n  ],\n  [\n    `resets database when it's newer than app schema`,\n    async (_adapter, AdapterClass, extraAdapterOptions) => {\n      // launch newer version of the app\n      let adapter = new DatabaseAdapterCompat(\n        new AdapterClass({\n          schema: { ...testSchema, version: 3 },\n          migrations: schemaMigrations({ migrations: [{ toVersion: 3, steps: [] }] }),\n          ...extraAdapterOptions,\n        }),\n      )\n      // TODO: Remove me. Temporary workaround for the race condition - wait until next macrotask to ensure that database has set up\n      await new Promise(resolve => setTimeout(resolve, 0))\n\n      await adapter.batch([['create', 'tasks', mockTaskRaw({})]])\n      expect(await adapter.count(taskQuery())).toBe(1)\n\n      // launch older version of the app\n      adapter = await adapter.testClone({\n        schema: { ...testSchema, version: 1 },\n        migrations: schemaMigrations({ migrations: [] }),\n      })\n\n      expect(await adapter.count(taskQuery())).toBe(0)\n      await adapter.batch([['create', 'tasks', mockTaskRaw({})]])\n      expect(await adapter.count(taskQuery())).toBe(1)\n    },\n  ],\n  [\n    'resets database when there are no available migrations',\n    async (_adapter, AdapterClass, extraAdapterOptions) => {\n      // launch older version of the app\n      let adapter = new DatabaseAdapterCompat(\n        new AdapterClass({\n          schema: { ...testSchema, version: 1 },\n          migrations: schemaMigrations({ migrations: [] }),\n          ...extraAdapterOptions,\n        }),\n      )\n      // TODO: Remove me. Temporary workaround for the race condition - wait until next macrotask to ensure that database has set up\n      await new Promise(resolve => setTimeout(resolve, 0))\n\n      await adapter.batch([['create', 'tasks', mockTaskRaw({})]])\n      expect(await adapter.count(taskQuery())).toBe(1)\n\n      // launch newer version of the app, without migrations available\n      adapter = await adapter.testClone({\n        schema: { ...testSchema, version: 3 },\n        migrations: schemaMigrations({ migrations: [{ toVersion: 3, steps: [] }] }),\n      })\n\n      expect(await adapter.count(taskQuery())).toBe(0)\n      await adapter.batch([['create', 'tasks', mockTaskRaw({})]])\n      expect(await adapter.count(taskQuery())).toBe(1)\n    },\n  ],\n  [\n    'errors when migration fails',\n    async (_adapter, AdapterClass, extraAdapterOptions) => {\n      // launch older version of the app\n      let adapter = new DatabaseAdapterCompat(\n        new AdapterClass({\n          schema: { ...testSchema, version: 1 },\n          migrations: schemaMigrations({ migrations: [] }),\n          ...extraAdapterOptions,\n        }),\n      )\n      // TODO: Remove me. Temporary workaround for the race condition - wait until next macrotask to ensure that database has set up\n      await new Promise(resolve => setTimeout(resolve, 0))\n\n      await adapter.batch([['create', 'tasks', mockTaskRaw({})]])\n      expect(await adapter.count(taskQuery())).toBe(1)\n      // launch newer version of the app with a migration that will fail\n      const adapterPromise = adapter.testClone({\n        schema: { ...testSchema, version: 2 },\n        migrations: schemaMigrations({\n          migrations: [\n            {\n              toVersion: 2,\n              steps: [\n                // with SQLite, trying to create a duplicate table will fail, but Loki will just ignore it\n                // so let's insert something that WILL fail\n                AdapterClass.name === 'LokiJSAdapter'\n                  ? { type: 'bad_type' }\n                  : createTable({ name: 'tasks', columns: [] }),\n              ],\n            },\n          ],\n        }),\n      })\n\n      // TODO: Make the SQLite, LokiJS adapter behavior consistent\n      if (AdapterClass.name === 'LokiJSAdapter') {\n        adapter = await adapterPromise\n        await expect(adapter.count(taskQuery())).rejects.toBeInstanceOf(Error)\n        await expect(adapter.batch([['create', 'tasks', mockTaskRaw({})]])).rejects.toBeInstanceOf(\n          Error,\n        )\n      } else {\n        await expect(adapterPromise).rejects.toBeInstanceOf(Error)\n      }\n    },\n  ],\n  ...matchTests.map(testCase => [\n    `[shared match test] ${testCase.name}`,\n    async adapter => {\n      await performMatchTest(adapter, testCase)\n    },\n  ]),\n  [\n    '[shared match test] can match strings from big-list-of-naughty-strings',\n    async (adapter, AdapterClass, extraAdapterOptions) => {\n      // eslint-disable-next-line no-restricted-syntax\n      for (const testCase of naughtyMatchTests) {\n        // console.log(testCase.name)\n\n        // KNOWN ISSUE: non-JSI adapter implementation gets confused by this (it's a BOM mark)\n        if (\n          AdapterClass.name === 'SQLiteAdapter' &&\n          !extraAdapterOptions.experimentalUseJSI &&\n          testCase.matching[0].text1 === '\ufeff'\n        ) {\n          // eslint-disable-next-line no-console\n          console.warn('skip check for a BOM naughty string - known failing test')\n        } else {\n          // eslint-disable-next-line no-await-in-loop\n          await performMatchTest(adapter, testCase)\n        }\n      }\n    },\n  ],\n  [\n    'can store and retrieve large numbers (regression test)',\n    async _adapter => {\n      // NOTE: matcher test didn't catch it because both insert and query has the same bug\n      let adapter = _adapter\n      const number = 1590485104033\n      await adapter.batch([['create', 'tasks', { id: 'm1', num1: number }]])\n      // launch app again\n      adapter = await adapter.testClone()\n      const record = await adapter.find('tasks', 'm1')\n      expect(record.num1).toBe(number)\n    },\n  ],\n  [\n    'can store and retrieve naughty strings exactly',\n    async (_adapter, AdapterClass, extraAdapterOptions) => {\n      let adapter = _adapter\n      const indexedNaughtyStrings = naughtyStrings.map((string, i) => [`id${i}`, string])\n      await adapter.batch(\n        indexedNaughtyStrings.map(([id, string]) => ['create', 'tasks', { id, text1: string }]),\n      )\n\n      // launch app again\n      adapter = await adapter.testClone()\n      const allRecords = await adapter.query(taskQuery())\n\n      indexedNaughtyStrings.forEach(([id, string]) => {\n        const record = allRecords.find(model => model.id === id)\n        // console.log(string, record)\n        // KNOWN ISSUE: non-JSI adapter implementation gets confused by this (it's a BOM mark)\n        if (\n          AdapterClass.name === 'SQLiteAdapter' &&\n          !extraAdapterOptions.experimentalUseJSI &&\n          string === '\ufeff'\n        ) {\n          expect(record.text1).not.toBe(string) // if this fails, it means the issue's been fixed\n        } else {\n          expect(!!record).toBe(true)\n          expect(record.text1).toBe(string)\n        }\n      })\n    },\n  ],\n  ...joinTests.map(testCase => [\n    `[shared join test] ${testCase.name}`,\n    async adapter => {\n      await performJoinTest(adapter, testCase)\n    },\n  ]),\n]\n"], "fixing_code": ["import Foundation\n\nclass DatabaseDriver {\n    typealias SchemaVersion = Int\n    typealias Schema = (version: SchemaVersion, sql: Database.SQL)\n    typealias MigrationSet = (from: SchemaVersion, to: SchemaVersion, sql: Database.SQL)\n\n    struct SchemaNeededError: Error { }\n    struct MigrationNeededError: Error {\n        let databaseVersion: SchemaVersion\n    }\n\n    let database: Database\n\n    convenience init(dbName: String, schemaVersion: SchemaVersion) throws {\n        self.init(dbName: dbName)\n\n        switch isCompatible(withVersion: schemaVersion) {\n        case .compatible: break\n        case .needsSetup:\n            throw SchemaNeededError()\n        case .needsMigration(fromVersion: let dbVersion):\n            throw MigrationNeededError(databaseVersion: dbVersion)\n        }\n    }\n\n    convenience init(dbName: String, setUpWithSchema schema: Schema) {\n        self.init(dbName: dbName)\n\n        do {\n            try unsafeResetDatabase(schema: schema)\n        } catch {\n            fatalError(\"Error while setting up the database: \\(error)\")\n        }\n    }\n\n    convenience init(dbName: String, setUpWithMigrations migrations: MigrationSet) throws {\n        self.init(dbName: dbName)\n        try migrate(with: migrations)\n    }\n\n    private init(dbName: String) {\n        self.database = Database(path: getPath(dbName: dbName))\n    }\n\n    func find(table: Database.TableName, id: RecordId) throws -> Any? {\n        guard !isCached(table, id) else {\n            return id\n        }\n\n        let results = try database.queryRaw(\"select * from \\(table) where id == ? limit 1\", [id])\n\n        guard let record = results.next() else {\n            return nil\n        }\n\n        markAsCached(table, id)\n        return record.resultDictionary!\n    }\n\n    func cachedQuery(table: Database.TableName, query: Database.SQL) throws -> [Any] {\n        return try database.queryRaw(query).map { row in\n            let id = row.string(forColumn: \"id\")!\n\n            if isCached(table, id) {\n                return id\n            } else {\n                markAsCached(table, id)\n                return row.resultDictionary!\n            }\n        }\n    }\n\n    func count(_ query: Database.SQL) throws -> Int {\n        return try database.count(query)\n    }\n\n    enum Operation {\n        case execute(table: Database.TableName, query: Database.SQL, args: Database.QueryArgs)\n        case create(table: Database.TableName, id: RecordId, query: Database.SQL, args: Database.QueryArgs)\n        case destroyPermanently(table: Database.TableName, id: RecordId)\n        case markAsDeleted(table: Database.TableName, id: RecordId)\n        // case destroyDeletedRecords(table: Database.TableName, records: [RecordId])\n        // case setLocal(key: String, value: String)\n        // case removeLocal(key: String)\n    }\n\n    func batch(_ operations: [Operation]) throws {\n        var newIds: [(Database.TableName, RecordId)] = []\n        var removedIds: [(Database.TableName, RecordId)] = []\n\n        try database.inTransaction {\n            for operation in operations {\n                switch operation {\n                case .execute(table: _, query: let query, args: let args):\n                    try database.execute(query, args)\n\n                case .create(table: let table, id: let id, query: let query, args: let args):\n                    try database.execute(query, args)\n                    newIds.append((table, id))\n\n                case .markAsDeleted(table: let table, id: let id):\n                    try database.execute(\"update \\(table) set _status='deleted' where id == ?\", [id])\n                    removedIds.append((table, id))\n\n                case .destroyPermanently(table: let table, id: let id):\n                    // TODO: What's the behavior if nothing got deleted?\n                    try database.execute(\"delete from \\(table) where id == ?\", [id])\n                    removedIds.append((table, id))\n                }\n            }\n        }\n\n        for (table, id) in newIds {\n            markAsCached(table, id)\n        }\n\n        for (table, id) in removedIds {\n            removeFromCache(table, id)\n        }\n    }\n\n    func getDeletedRecords(table: Database.TableName) throws -> [RecordId] {\n        return try database.queryRaw(\"select id from \\(table) where _status='deleted'\").map { row in\n            row.string(forColumn: \"id\")!\n        }\n    }\n\n    func destroyDeletedRecords(table: Database.TableName, records: [RecordId]) throws {\n        // TODO: What's the behavior if record doesn't exist or isn't actually deleted?\n        let recordPlaceholders = records.map { _ in \"?\" }.joined(separator: \",\")\n        try database.execute(\"delete from \\(table) where id in (\\(recordPlaceholders))\", records)\n    }\n\n// MARK: - LocalStorage\n\n    func getLocal(key: String) throws -> String? {\n        let results = try database.queryRaw(\"select value from local_storage where key = ?\", [key])\n\n        guard let record = results.next() else {\n            return nil\n        }\n\n        return record.string(forColumn: \"value\")!\n    }\n\n    func setLocal(key: String, value: String) throws {\n        return try database.execute(\"insert or replace into local_storage (key, value) values (?, ?)\", [key, value])\n    }\n\n    func removeLocal(key: String) throws {\n        return try database.execute(\"delete from local_storage where key == ?\", [key])\n    }\n\n// MARK: - Record caching\n\n    typealias RecordId = String\n\n    // Rewritten to use good ol' mutable Objective C for performance\n    // The swifty implementation in debug took >100s to execute on a 65K batch. This: 6ms. Yes. Really.\n    private var cachedRecords: NSMutableDictionary /* [TableName: Set<RecordId>] */ = NSMutableDictionary()\n\n    func isCached(_ table: Database.TableName, _ id: RecordId) -> Bool {\n        if let set = cachedRecords[table] as? NSSet {\n            return set.contains(id)\n        }\n        return false\n    }\n\n    private func markAsCached(_ table: Database.TableName, _ id: RecordId) {\n        var cachedSet: NSMutableSet\n        if let set = cachedRecords[table] as? NSMutableSet {\n            cachedSet = set\n        } else {\n            cachedSet = NSMutableSet()\n            cachedRecords[table] = cachedSet\n        }\n        cachedSet.add(id)\n    }\n\n    private func removeFromCache(_ table: Database.TableName, _ id: RecordId) {\n        if let set = cachedRecords[table] as? NSMutableSet {\n            set.remove(id)\n        }\n    }\n\n// MARK: - Other private details\n\n    private enum SchemaCompatibility {\n        case compatible\n        case needsSetup\n        case needsMigration(fromVersion: SchemaVersion)\n    }\n\n    private func isCompatible(withVersion schemaVersion: SchemaVersion) -> SchemaCompatibility {\n        let databaseVersion = database.userVersion\n\n        switch databaseVersion {\n        case schemaVersion: return .compatible\n        case 0: return .needsSetup\n        case (1..<schemaVersion): return .needsMigration(fromVersion: databaseVersion)\n        default:\n            consoleLog(\"Database has newer version (\\(databaseVersion)) than what the \" +\n                \"app supports (\\(schemaVersion)). Will reset database.\")\n            return .needsSetup\n        }\n    }\n\n    func unsafeResetDatabase(schema: Schema) throws {\n        try database.unsafeDestroyEverything()\n        cachedRecords = [:]\n\n        try setUpSchema(schema: schema)\n    }\n\n    private func setUpSchema(schema: Schema) throws {\n        try database.inTransaction {\n            try database.executeStatements(schema.sql + localStorageSchema)\n            database.userVersion = schema.version\n        }\n    }\n\n    private func migrate(with migrations: MigrationSet) throws {\n        precondition(\n            database.userVersion == migrations.from,\n            \"Incompatbile migration set applied. DB: \\(database.userVersion), migration: \\(migrations.from)\"\n        )\n\n        try database.inTransaction {\n            try database.executeStatements(migrations.sql)\n            database.userVersion = migrations.to\n        }\n    }\n\n    private let localStorageSchema = \"\"\"\n        create table local_storage (\n        key varchar(16) primary key not null,\n        value text not null\n        );\n\n        create index local_storage_key_index on local_storage (key);\n    \"\"\"\n}\n\nprivate func getPath(dbName: String) -> String {\n    // If starts with `file:` or contains `/`, it's a path!\n    if dbName.starts(with: \"file:\") || dbName.contains(\"/\") {\n        return dbName\n    } else {\n        // swiftlint:disable:next force_try\n        return try! FileManager.default\n            .url(for: .documentDirectory, in: .userDomainMask, appropriateFor: nil, create: false)\n            .appendingPathComponent(\"\\(dbName).db\")\n            .path\n    }\n}\n", "import expect from 'expect'\nimport naughtyStrings from 'big-list-of-naughty-strings'\n\nimport Model from '../../Model'\nimport Query from '../../Query'\nimport { sanitizedRaw } from '../../RawRecord'\nimport * as Q from '../../QueryDescription'\nimport { appSchema, tableSchema } from '../../Schema'\nimport { schemaMigrations, createTable, addColumns } from '../../Schema/migrations'\n\nimport { matchTests, naughtyMatchTests, joinTests } from '../../__tests__/databaseTests'\nimport DatabaseAdapterCompat from '../compat'\nimport {\n  testSchema,\n  taskQuery,\n  mockTaskRaw,\n  performMatchTest,\n  performJoinTest,\n  expectSortedEqual,\n  MockTask,\n  mockProjectRaw,\n  projectQuery,\n} from './helpers'\n\nclass BadModel extends Model {\n  static table = 'nonexistent'\n}\n\nexport default () => [\n  [\n    'validates adapter options',\n    async (_adapter, AdapterClass) => {\n      const schema = { ...testSchema, version: 10 }\n\n      const makeAdapter = options => new AdapterClass({ schema, ...options })\n      const adapterWithMigrations = migrations => makeAdapter({ migrations })\n\n      // expect(() => makeAdapter({})).toThrowError(/missing migrations/)\n\n      expect(() => makeAdapter({ migrationsExperimental: [] })).toThrow(\n        /`migrationsExperimental` option has been renamed to `migrations`/,\n      )\n\n      if (AdapterClass.name === 'LokiJSAdapter') {\n        expect(() => makeAdapter({ experimentalUseIncrementalIndexedDB: false })).toThrow(\n          /LokiJSAdapter `experimentalUseIncrementalIndexedDB` option has been renamed/,\n        )\n      }\n\n      expect(() => adapterWithMigrations({ migrations: [] })).toThrow(/use schemaMigrations()/)\n\n      // OK migrations passed\n      const adapterWithRealMigrations = migrations =>\n        adapterWithMigrations(schemaMigrations({ migrations }))\n\n      expect(() => adapterWithRealMigrations([{ toVersion: 10, steps: [] }])).not.toThrow()\n      expect(() =>\n        adapterWithRealMigrations([{ toVersion: 10, steps: [] }, { toVersion: 9, steps: [] }]),\n      ).not.toThrow()\n\n      // Empty migrations only allowed if version 1\n      expect(\n        () =>\n          new AdapterClass({\n            schema: { ...testSchema, version: 1 },\n            migrations: schemaMigrations({ migrations: [] }),\n          }),\n      ).not.toThrow()\n      expect(() => adapterWithRealMigrations([])).toThrow(/Missing migration/)\n\n      // Migrations can't be newer than schema\n      expect(() => adapterWithRealMigrations([{ toVersion: 11, steps: [] }])).toThrow(\n        /migrations can't be newer than schema/i,\n      )\n      // Migration to latest version must be present\n      expect(() =>\n        adapterWithRealMigrations([{ toVersion: 9, steps: [] }, { toVersion: 8, steps: [] }]),\n      ).toThrow(/Missing migration/)\n    },\n  ],\n  [\n    'can query and count on empty db',\n    async adapter => {\n      const query = taskQuery()\n      expect(await adapter.query(query)).toEqual([])\n      expect(await adapter.count(query)).toBe(0)\n    },\n  ],\n  [\n    'can create and find records (sanity test)',\n    async adapter => {\n      const record = mockTaskRaw({ id: 'abc', text1: 'bar', order: 1 })\n      await adapter.batch([['create', 'tasks', record]])\n      expect(await adapter.find('tasks', 'abc')).toBe('abc')\n    },\n  ],\n  [\n    'can find records by ID',\n    async _adapter => {\n      let adapter = _adapter\n\n      // add a record\n      const s1 = mockTaskRaw({ id: 's1', text1: 'bar', order: 1 })\n      await adapter.batch([['create', 'tasks', s1]])\n\n      // returns cached ID after create\n      expect(await adapter.find('tasks', 's1')).toBe('s1')\n\n      // add more, restart app\n      const s2 = mockTaskRaw({ id: 's2', bool1: true, order: 2 })\n      const s3 = mockTaskRaw({ id: 's3', text1: 'baz' })\n      await adapter.batch([['create', 'tasks', s2], ['create', 'tasks', s3]])\n      adapter = await adapter.testClone()\n\n      // returns raw if not cached\n      expect(await adapter.find('tasks', 's2')).toEqual(s2)\n      expect(await adapter.find('tasks', 's3')).toEqual(s3)\n\n      // caches records after first find\n      expect(await adapter.find('tasks', 's2')).toBe('s2')\n\n      // returns null if not found\n      expect(await adapter.find('tasks', 's4')).toBe(null)\n    },\n  ],\n  [\n    'can cache non-global IDs on find',\n    async _adapter => {\n      let adapter = _adapter\n\n      // add a record\n      const s1 = mockTaskRaw({ id: 'id1', text1: 'bar', order: 1 })\n      await adapter.batch([['create', 'tasks', s1]])\n\n      // returns null if not found in a different table\n      expect(await adapter.find('projects', 'id1')).toBe(null)\n\n      const p1 = mockProjectRaw({ id: 'id1', num1: 1, text1: 'foo' })\n      await adapter.batch([['create', 'projects', p1]])\n\n      // returns cached ID after create\n      expect(await adapter.find('projects', 'id1')).toBe('id1')\n\n      // add more project, restart app\n      const p2 = mockProjectRaw({ id: 'id2', num1: 1, text1: 'foo' })\n      await adapter.batch([['create', 'projects', p2]])\n      adapter = await adapter.testClone()\n\n      const s2 = mockTaskRaw({ id: 'id2', text1: 'baz', order: 2 })\n      await adapter.batch([['create', 'tasks', s2]])\n\n      // returns cached ID after create\n      expect(await adapter.find('tasks', 'id2')).toBe('id2')\n\n      // returns raw if not cached for a different table\n      expect(await adapter.find('projects', 'id2')).toEqual(p2)\n      // returns cached ID after previous find\n      expect(await adapter.find('projects', 'id2')).toBe('id2')\n    },\n  ],\n  [\n    'can cache non-global IDs on query',\n    async _adapter => {\n      let adapter = _adapter\n\n      // add a record\n      const s1 = mockTaskRaw({ id: 'id1', text1: 'bar', order: 1 })\n      await adapter.batch([['create', 'tasks', s1]])\n\n      // returns empty array\n      expectSortedEqual(await adapter.query(projectQuery()), [])\n\n      const p1 = mockProjectRaw({ id: 'id1', num1: 1, text1: 'foo' })\n      await adapter.batch([['create', 'projects', p1]])\n\n      // returns cached ID after create\n      expectSortedEqual(await adapter.query(projectQuery()), ['id1'])\n\n      // add more project, restart app\n      const p2 = mockProjectRaw({ id: 'id2', num1: 1, text1: 'foo' })\n      await adapter.batch([['create', 'projects', p2]])\n      adapter = await adapter.testClone()\n\n      const s2 = mockTaskRaw({ id: 'id2', text1: 'baz', order: 2 })\n      await adapter.batch([['create', 'tasks', s2]])\n\n      // returns cached IDs after create\n      expectSortedEqual(await adapter.query(taskQuery()), [s1, 'id2'])\n\n      // returns raw if not cached for a different table\n      expectSortedEqual(await adapter.query(projectQuery()), [p1, p2])\n      // returns cached IDs after previous query\n      expectSortedEqual(await adapter.query(taskQuery()), ['id1', 'id2'])\n    },\n  ],\n  [\n    'sanitizes records on find',\n    async _adapter => {\n      let adapter = _adapter\n      const tt1 = { id: 'tt1', task_id: 'abcdef' } // Unsanitized raw!\n\n      await adapter.batch([['create', 'tag_assignments', tt1]])\n      adapter = await adapter.testClone()\n\n      expect(await adapter.find('tag_assignments', 'tt1')).toEqual(\n        sanitizedRaw(tt1, testSchema.tables.tag_assignments),\n      )\n    },\n  ],\n  [\n    'can query and count records',\n    async adapter => {\n      const record1 = mockTaskRaw({ id: 't1', text1: 'bar', bool1: false, order: 1 })\n      const record2 = mockTaskRaw({ id: 't2', text1: 'baz', bool1: true, order: 2 })\n      const record3 = mockTaskRaw({ id: 't3', text1: 'abc', bool1: false, order: 3 })\n\n      await adapter.batch([\n        ['create', 'tasks', record1],\n        ['create', 'tasks', record2],\n        ['create', 'tasks', record3],\n      ])\n\n      // all records\n      expectSortedEqual(await adapter.query(taskQuery()), ['t1', 't2', 't3'])\n      expect(await adapter.count(taskQuery())).toBe(3)\n\n      // some records\n      expectSortedEqual(await adapter.query(taskQuery(Q.where('bool1', false))), ['t1', 't3'])\n      expectSortedEqual(await adapter.query(taskQuery(Q.where('order', 2))), ['t2'])\n      expectSortedEqual(await adapter.query(taskQuery(Q.where('order', 3))), ['t3'])\n\n      expect(await adapter.count(taskQuery(Q.where('bool1', false)))).toBe(2)\n\n      // no records\n      expectSortedEqual(await adapter.query(taskQuery(Q.where('text1', 'nope'))), [])\n      expect(await adapter.count(taskQuery(Q.where('text1', 'nope')))).toBe(0)\n      expect(await adapter.count(taskQuery(Q.where('order', 4)))).toBe(0)\n    },\n  ],\n  [\n    'can query records in raw query format',\n    async (adapter, AdapterClass) => {\n      if (AdapterClass.name === 'SQLiteAdapter') {\n        const record1 = mockTaskRaw({ id: 't1', text1: 'bar', bool1: false, order: 1 })\n        const record2 = mockTaskRaw({ id: 't2', text1: 'baz', bool1: true, order: 2 })\n        const record3 = mockTaskRaw({ id: 't3', text1: 'abc', bool1: false, order: 3 })\n\n        await adapter.batch([\n          ['create', 'tasks', record1],\n          ['create', 'tasks', record2],\n          ['create', 'tasks', record3],\n        ])\n\n        // all records\n        expectSortedEqual(await adapter.unsafeSqlQuery('tasks', `SELECT * FROM tasks`), [\n          't1',\n          't2',\n          't3',\n        ])\n\n        expectSortedEqual(\n          await adapter.unsafeSqlQuery('tasks', `SELECT * FROM tasks WHERE bool1 = 0`),\n          ['t1', 't3'],\n        )\n\n        expectSortedEqual(\n          await adapter.unsafeSqlQuery('tasks', `SELECT * FROM tasks WHERE id = 't2'`),\n          ['t2'],\n        )\n\n        expectSortedEqual(\n          await adapter.unsafeSqlQuery('tasks', `SELECT * FROM tasks WHERE \\`order\\` = 2`),\n          ['t2'],\n        )\n\n        expectSortedEqual(\n          await adapter.unsafeSqlQuery('tasks', `SELECT * FROM tasks WHERE text1 = 'nope'`),\n          [],\n        )\n      } else {\n        expect(adapter.unsafeSqlQuery).toBe(undefined)\n      }\n    },\n  ],\n  [\n    'compacts query results',\n    async _adapter => {\n      let adapter = _adapter\n      const queryAll = () => adapter.query(taskQuery())\n\n      // add records, restart app\n      const s1 = mockTaskRaw({ id: 's1', order: 1 })\n      const s2 = mockTaskRaw({ id: 's2', order: 2 })\n      await adapter.batch([['create', 'tasks', s1], ['create', 'tasks', s2]])\n      adapter = await adapter.testClone()\n\n      // first time we see it, get full object\n      expectSortedEqual(await queryAll(), [s1, s2])\n\n      // cached next time\n      expect(await queryAll()).toEqual(['s1', 's2'])\n\n      // updating doesn't change anything\n      await adapter.batch([['update', 'tasks', s2]])\n      expect(await queryAll()).toEqual(['s1', 's2'])\n\n      // records added via adapter get cached automatically\n      const s3 = mockTaskRaw({ id: 's3' })\n      await adapter.batch([['create', 'tasks', s3]])\n      expect(await queryAll()).toEqual(['s1', 's2', 's3'])\n\n      // remove and re-add and it appears again\n      await adapter.batch([['destroyPermanently', 'tasks', s3.id]])\n      expect(await queryAll()).toEqual(['s1', 's2'])\n\n      const s3New = mockTaskRaw({ id: 's3', bool1: true })\n      await adapter.batch([['create', 'tasks', s3New]])\n      expect(await queryAll()).toEqual(['s1', 's2', 's3'])\n\n      // restart app, doesn't have the records\n      adapter = await adapter.testClone()\n      expectSortedEqual(await queryAll(), [s1, s2, s3New])\n    },\n  ],\n  [\n    'sanitizes records on query',\n    async _adapter => {\n      let adapter = _adapter\n      // Unsanitized raw!\n      const t1 = { id: 't1', text1: 'foo', order: 1 }\n      const t2 = { id: 't2', text2: 'bar', order: 2 }\n\n      await adapter.batch([['create', 'tasks', t1], ['create', 'tasks', t2]])\n      adapter = await adapter.testClone()\n\n      expectSortedEqual(await adapter.query(taskQuery()), [\n        sanitizedRaw(t1, testSchema.tables.tasks),\n        sanitizedRaw(t2, testSchema.tables.tasks),\n      ])\n    },\n  ],\n  [\n    'returns a COPY of the data',\n    async _adapter => {\n      let adapter = _adapter\n      const raw = mockTaskRaw({ id: 't1', text1: 'bar' })\n      const originalRaw = { ...raw }\n      await adapter.batch([['create', 'tasks', raw]])\n\n      adapter = await adapter.testClone()\n      const fetchedRaw = await adapter.find('tasks', 't1')\n\n      // data is equal but not the same reference\n      expect(fetchedRaw).toEqual(originalRaw)\n      expect(fetchedRaw).toEqual(raw)\n      expect(fetchedRaw).not.toBe(raw)\n\n      // make sure same is true for query\n      adapter = await adapter.testClone()\n      const [queriedRaw] = await adapter.query(taskQuery())\n      expect(queriedRaw).toEqual(originalRaw)\n      expect(queriedRaw).not.toBe(raw)\n    },\n  ],\n  [\n    'can update records',\n    async _adapter => {\n      let adapter = _adapter\n      const raw = mockTaskRaw({ id: 't1', text1: 'bar' })\n      await adapter.batch([['create', 'tasks', raw]])\n      raw.bool1 = true\n      raw.order = 2\n      await adapter.batch([['update', 'tasks', raw]])\n\n      adapter = await adapter.testClone()\n      const fetchedUpdatedRaw = await adapter.find('tasks', 't1')\n\n      // check raws are equal (but a copy)\n      expect(fetchedUpdatedRaw.bool1).toBe(true)\n      expect(fetchedUpdatedRaw.order).toBe(2)\n      expect(fetchedUpdatedRaw).toEqual(raw)\n      expect(fetchedUpdatedRaw).not.toBe(raw)\n    },\n  ],\n  [\n    'can mark records as deleted',\n    async adapter => {\n      const m1 = mockTaskRaw({ id: 't1', text1: 'bar1' })\n      await adapter.batch([['create', 'tasks', m1]])\n      expect(await adapter.query(taskQuery())).toEqual(['t1'])\n\n      await adapter.batch([['markAsDeleted', 'tasks', m1.id]])\n      expect(await adapter.query(taskQuery())).toEqual([])\n\n      // Check that the record is removed from cache\n      // HACK: Set _status to reveal the record in query (if record was cached, there would only be ID)\n      m1._status = 'synced'\n      await adapter.batch([['update', 'tasks', m1]])\n      expectSortedEqual(await adapter.query(taskQuery()), [m1])\n    },\n  ],\n  [\n    'can get deleted record ids',\n    async adapter => {\n      const m1 = mockTaskRaw({ id: 't1', text1: 'bar1', order: 1 })\n      const m2 = mockTaskRaw({ id: 't2', text1: 'bar2', order: 2 })\n      await adapter.batch([\n        ['create', 'tasks', m1],\n        ['markAsDeleted', 'tasks', m1.id],\n        ['create', 'tasks', m2],\n        ['create', 'tasks', mockTaskRaw({ id: 't3', text1: 'bar3' })],\n        ['markAsDeleted', 'tasks', m2.id],\n      ])\n      expectSortedEqual(await adapter.getDeletedRecords('tasks'), ['t2', 't1'])\n    },\n  ],\n  [\n    'can destroy deleted records',\n    async adapter => {\n      const m1 = mockTaskRaw({ id: 't1', text1: 'bar1', order: 1 })\n      const m2 = mockTaskRaw({ id: 't2', text1: 'bar2', order: 2 })\n      const m3 = mockTaskRaw({ id: 't3', text1: 'bar3', order: 3 })\n      await adapter.batch([\n        ['create', 'tasks', m1],\n        ['create', 'tasks', m2],\n        ['create', 'tasks', m3],\n        ['create', 'tasks', mockTaskRaw({ id: 't4', text1: 'bar4' })],\n      ])\n      await adapter.batch([\n        ['markAsDeleted', 'tasks', m1.id],\n        ['markAsDeleted', 'tasks', m2.id],\n        ['markAsDeleted', 'tasks', m3.id],\n      ])\n\n      await adapter.destroyDeletedRecords('tasks', ['t1', 't2'])\n      expectSortedEqual(await adapter.getDeletedRecords('tasks'), ['t3'])\n      expectSortedEqual(await adapter.query(taskQuery()), ['t4'])\n      expect(await adapter.find('tasks', 't1')).toBeNull()\n      expect(await adapter.find('tasks', 't2')).toBeNull()\n    },\n  ],\n  [\n    'destroyDeletedRecords can handle unsafe strings',\n    async adapter => {\n      const m1 = mockTaskRaw({ id: 't1', text1: 'bar1', order: 1 })\n      const m2 = mockTaskRaw({ id: 't2', text1: 'bar2', order: 2 })\n      const m3 = mockTaskRaw({ id: 't3', text1: 'bar3', order: 3 })\n      await adapter.batch([\n        ['create', 'tasks', m1],\n        ['create', 'tasks', m2],\n        ['create', 'tasks', m3],\n      ])\n      await adapter.batch([\n        ['markAsDeleted', 'tasks', m1.id],\n        ['markAsDeleted', 'tasks', m2.id],\n        ['markAsDeleted', 'tasks', m3.id],\n      ])\n\n      await adapter.destroyDeletedRecords('tasks', ['\\') or 1=1 --'])\n      expectSortedEqual(await adapter.getDeletedRecords('tasks'), ['t1', 't2', 't3'])\n      expectSortedEqual(await adapter.query(taskQuery()), [])\n\n      await adapter.destroyDeletedRecords('tasks', ['\\'); insert into tasks (id) values (\\'t4\\') --'])\n      expectSortedEqual(await adapter.query(taskQuery()), [])\n    },\n  ],\n  [\n    'can run mixed batches',\n    async _adapter => {\n      let adapter = _adapter\n      const m1 = mockTaskRaw({ id: 't1', text1: 'bar' })\n      const m3 = mockTaskRaw({ id: 't3' })\n      const m4 = mockTaskRaw({ id: 't4' })\n\n      await adapter.batch([['create', 'tasks', m1]])\n\n      m1.bool1 = true\n      const m2 = mockTaskRaw({ id: 't2', text1: 'bar', bool2: true, order: 2 })\n\n      await adapter.batch([\n        ['create', 'tasks', m3],\n        ['create', 'tasks', m4],\n        ['destroyPermanently', 'tasks', m3.id],\n        ['update', 'tasks', m1],\n        ['create', 'tasks', m2],\n        ['markAsDeleted', 'tasks', m4.id],\n      ])\n\n      adapter = await adapter.testClone()\n      const fetched1 = await adapter.find('tasks', 't1')\n      expect(fetched1.bool1).toBe(true)\n      expect(fetched1).toEqual(m1)\n\n      const fetched2 = await adapter.find('tasks', 't2')\n      expect(fetched2.bool2).toBe(true)\n\n      expect(await adapter.find('tasks', 't3')).toBeNull()\n      expect(await adapter.query(taskQuery())).toEqual(['t1', 't2'])\n\n      expect(await adapter.getDeletedRecords('tasks')).toEqual(['t4'])\n    },\n  ],\n  [\n    'batches are transactional',\n    async (adapter, AdapterClass) => {\n      // sanity check\n      await adapter.batch([['create', 'tasks', mockTaskRaw({ id: 't1' })]])\n      expect(await adapter.query(taskQuery())).toEqual(['t1'])\n\n      await expect(\n        adapter.batch([\n          ['create', 'tasks', mockTaskRaw({ id: 't2' })],\n          ['create', 'does_not_exist', mockTaskRaw({ id: 't3' })],\n        ]),\n      ).rejects.toMatchObject({\n        // TODO: Get rid of the unknown error - fix on Android\n        message: expect.stringMatching(\n          AdapterClass.name === 'SQLiteAdapter'\n            ? /(no such table: does_not_exist|Exception in HostFunction: <unknown>)/\n            : /Cannot read property 'insert' of null/,\n        ),\n      })\n      if (AdapterClass.name !== 'LokiJSAdapter') {\n        // Regrettably, Loki is not transactional\n        expect(await adapter.query(taskQuery())).toEqual(['t1'])\n      }\n    },\n  ],\n  [\n    'can run sync-like flow',\n    async adapter => {\n      const queryAll = () => adapter.query(taskQuery())\n\n      const m1 = mockTaskRaw({ id: 't1', text1: 'bar1', order: 1 })\n      const m2 = mockTaskRaw({ id: 't2', text1: 'bar2', order: 2 })\n      const m3 = mockTaskRaw({ id: 't3', text1: 'bar3', order: 3 })\n\n      await adapter.batch([\n        ['create', 'tasks', m1],\n        ['create', 'tasks', m2],\n        ['create', 'tasks', m3],\n        ['create', 'tasks', mockTaskRaw({ id: 't4', text1: 'bar4' })],\n        ['markAsDeleted', 'tasks', m1.id],\n        ['markAsDeleted', 'tasks', m3.id],\n      ])\n\n      // pull server changes - server wants us to delete some records\n      await adapter.batch([\n        ['destroyPermanently', 'tasks', m1.id],\n        ['destroyPermanently', 'tasks', m2.id],\n      ])\n      expect(await queryAll()).toHaveLength(1)\n\n      // push local changes\n      const toDelete = await adapter.getDeletedRecords('tasks')\n      expect(toDelete).toEqual(['t3'])\n      await adapter.destroyDeletedRecords('tasks', toDelete)\n\n      expect(await adapter.getDeletedRecords('tasks')).toHaveLength(0)\n      expect(await queryAll()).toHaveLength(1)\n    },\n  ],\n  [\n    'can unsafely reset database',\n    async adapter => {\n      await adapter.batch([['create', 'tasks', mockTaskRaw({ id: 't1', text1: 'bar', order: 1 })]])\n      await adapter.unsafeResetDatabase()\n      await expect(await adapter.count(taskQuery())).toBe(0)\n\n      // check that reset database still works\n      await adapter.batch([['create', 'tasks', mockTaskRaw({ id: 't2', text1: 'baz', order: 2 })]])\n      expect(await adapter.count(taskQuery())).toBe(1)\n    },\n  ],\n  [\n    'queues actions correctly',\n    async adapter => {\n      function queryable(promise) {\n        let isSettled = false\n        const result = promise.then(\n          value => {\n            isSettled = true\n            return value\n          },\n          e => {\n            isSettled = true\n            throw e\n          },\n        )\n        result.isSettled = () => isSettled\n        return result\n      }\n\n      adapter.batch([['create', 'tasks', mockTaskRaw({ id: 't1', text1: 'foo', order: 1 })]])\n      const find1Promise = queryable(adapter.find('tasks', 't1'))\n      const find2Promise = queryable(adapter.find('tasks', 't2'))\n      adapter.batch([['create', 'tasks', mockTaskRaw({ id: 't2', text1: 'bar', order: 2 })]])\n      const queryPromise = queryable(adapter.query(taskQuery()))\n      const find2Promise2 = queryable(adapter.find('tasks', 't2'))\n\n      await find2Promise2\n\n      expect(find1Promise.isSettled()).toBe(true)\n      expect(find2Promise.isSettled()).toBe(true)\n      expect(queryPromise.isSettled()).toBe(true)\n      expect(find2Promise2.isSettled()).toBe(true)\n      expect(await find1Promise).toBe('t1')\n      expect(await find2Promise).toBe(null)\n      expect(await queryPromise).toEqual(['t1', 't2'])\n      expect(await find2Promise2).toBe('t2')\n\n      // unsafeResetDatabase is the only action in loki that's necessarily asynchronous even in sync mode\n      const batchPromise = queryable(\n        adapter.batch([['create', 'tasks', mockTaskRaw({ id: 't3', text1: 'bar', order: 2 })]]),\n      )\n      adapter.unsafeResetDatabase()\n      adapter.batch([['create', 'tasks', mockTaskRaw({ id: 't1', text1: 'bar', order: 2 })]])\n      const queryPromise2 = adapter.query(taskQuery())\n\n      expect(await queryPromise2).toEqual(['t1'])\n      expect(batchPromise.isSettled()).toBe(true)\n    },\n  ],\n  [\n    'fails on bad queries, creates, updates, deletes',\n    async adapter => {\n      const badQuery = new Query({ modelClass: BadModel }, []).serialize()\n      await expect(adapter.query(badQuery)).rejects.toBeInstanceOf(Error)\n      await expect(adapter.count(badQuery)).rejects.toBeInstanceOf(Error)\n\n      const record1 = new BadModel({ table: 'nonexisting' }, { id: 't1' })\n      await expect(adapter.batch([['create', record1]])).rejects.toBeInstanceOf(Error)\n\n      await expect(adapter.batch(['create', record1])).rejects.toBeInstanceOf(Error)\n\n      // TODO: Fix slight inconsistencies between loki & sqlite\n      // if (platform.isWeb) {\n      // await expect(\n      //   adapter.batch([['update', 'tasks', mockTaskRaw({ id: 'nonexists' })]]),\n      // ).rejects.toBeInstanceOf(Error)\n\n      // TODO: Mark as deleted?\n\n      // const record = 'tasks', mockTaskRaw({ id: '1' })\n      // await expect(adapter.batch([['destroyPermanently', record]])).rejects.toBeInstanceOf(Error)\n      // }\n    },\n  ],\n  [\n    'supports LocalStorage',\n    async adapter => {\n      // non-existent fields return undefined\n      expect(await adapter.getLocal('nonexisting')).toBeNull()\n\n      // set\n      await adapter.setLocal('test1', 'val1')\n      expect(await adapter.getLocal('test1')).toBe('val1')\n\n      // update\n      await adapter.setLocal('test1', 'val2')\n      expect(await adapter.getLocal('test1')).toBe('val2')\n\n      // delete\n      await adapter.removeLocal('test1')\n      expect(await adapter.getLocal('test1')).toBeNull()\n\n      // can be safely reassigned\n      await adapter.setLocal('test1', 'val3')\n      expect(await adapter.getLocal('test1')).toBe('val3')\n\n      // can use keywords as keys\n      // can be safely reassigned\n      await adapter.setLocal('order', '3')\n      expect(await adapter.getLocal('order')).toBe('3')\n\n      // deleting already undefined is safe\n      await adapter.removeLocal('nonexisting')\n    },\n  ],\n  [\n    'migrates database between versions',\n    async (_adapter, AdapterClass, extraAdapterOptions) => {\n      // launch app in one version\n      const taskColumnsV3 = [{ name: 'num1', type: 'number' }]\n      const projectColumnsV3 = [{ name: 'text1', type: 'string' }]\n      const testSchemaV3 = appSchema({\n        version: 3,\n        tables: [\n          tableSchema({ name: 'tasks', columns: taskColumnsV3 }),\n          tableSchema({ name: 'projects', columns: projectColumnsV3 }),\n        ],\n      })\n\n      let adapter = new DatabaseAdapterCompat(\n        new AdapterClass({\n          schema: testSchemaV3,\n          migrations: schemaMigrations({ migrations: [{ toVersion: 3, steps: [] }] }),\n          ...extraAdapterOptions,\n        }),\n      )\n      // TODO: Remove me. Temporary workaround for the race condition - wait until next macrotask to ensure that database has set up\n      await new Promise(resolve => setTimeout(resolve, 0))\n      // add data\n      await adapter.batch([\n        ['create', 'tasks', { id: 't1', num1: 10 }],\n        ['create', 'tasks', { id: 't2', num1: 20 }],\n      ])\n\n      // can't add to tables that don't exist yet\n      await expect(\n        adapter.batch([['create', 'tag_assignments', { id: 'tt1', text1: 'hello' }]]),\n      ).rejects.toBeInstanceOf(Error)\n\n      // migrate to new version\n      const taskColumnsV5 = [\n        { name: 'test_string', type: 'string' },\n        { name: 'test_string_optional', type: 'string', isOptional: true },\n        { name: 'test_number', type: 'number' },\n        { name: 'test_number_optional', type: 'number', isOptional: true },\n        { name: 'test_boolean', type: 'boolean' },\n        { name: 'test_boolean_optional', type: 'boolean', isOptional: true },\n      ]\n      const projectColumnsV5 = [{ name: 'text2', type: 'string', isIndexed: true }]\n      const tagAssignmentSchema = {\n        name: 'tag_assignments',\n        columns: [{ name: 'text1', type: 'string' }],\n      }\n\n      const testSchemaV5 = appSchema({\n        version: 5,\n        tables: [\n          tableSchema({\n            name: 'tasks',\n            columns: [...taskColumnsV3, ...taskColumnsV5],\n          }),\n          tableSchema({\n            name: 'projects',\n            columns: [...projectColumnsV3, ...projectColumnsV5],\n          }),\n          tableSchema(tagAssignmentSchema),\n        ],\n      })\n      const migrationsV5 = schemaMigrations({\n        migrations: [\n          {\n            toVersion: 5,\n            steps: [addColumns({ table: 'tasks', columns: taskColumnsV5 })],\n          },\n          {\n            toVersion: 4,\n            steps: [\n              createTable(tagAssignmentSchema),\n              addColumns({ table: 'projects', columns: projectColumnsV5 }),\n            ],\n          },\n          {\n            toVersion: 3,\n            steps: [\n              createTable({\n                name: 'will_not_be_created',\n                columns: [{ name: 'num1', type: 'number' }],\n              }),\n            ],\n          },\n        ],\n      })\n      adapter = await adapter.testClone({\n        schema: testSchemaV5,\n        migrations: migrationsV5,\n      })\n\n      // check that the data is still there\n      expect(await adapter.count(new Query({ modelClass: MockTask }, []))).toBe(2)\n\n      // check if new columns were populated with appropriate default values\n      const checkTaskColumn = (columnName, expectedValue) =>\n        new Query({ modelClass: MockTask }, [Q.where(columnName, expectedValue)]).serialize()\n\n      expect(await adapter.count(checkTaskColumn('test_string', ''))).toBe(2)\n      expect(await adapter.count(checkTaskColumn('test_string_optional', null))).toBe(2)\n      expect(await adapter.count(checkTaskColumn('test_number', 0))).toBe(2)\n      expect(await adapter.count(checkTaskColumn('test_number_optional', null))).toBe(2)\n      expect(await adapter.count(checkTaskColumn('test_boolean', false))).toBe(2)\n      expect(await adapter.count(checkTaskColumn('test_boolean_optional', null))).toBe(2)\n\n      // check I can use new table and columns\n      await adapter.batch([\n        ['create', 'tag_assignments', { id: 'tt2', text1: 'hello' }],\n        ['create', 'projects', { id: 'p1', text1: 'hey', text2: 'foo' }],\n        [\n          'create',\n          'tasks',\n          { id: 't3', test_string: 'hey', test_number: 2, test_boolean_optional: true },\n        ],\n      ])\n\n      // check that out-of-range migration was not executed\n      await expect(\n        adapter.batch([['create', 'will_not_be_created', { id: 'w1', text1: 'hello' }]]),\n      ).rejects.toBeInstanceOf(Error)\n\n      // make sure new fields actually work and that migrations won't be applied again\n      adapter = await adapter.testClone()\n\n      const p1 = await adapter.find('projects', 'p1')\n      expect(p1.text2).toBe('foo')\n\n      const t1 = await adapter.find('tasks', 't3')\n      expect(t1.test_string).toBe('hey')\n      expect(t1.test_number).toBe(2)\n      expect(t1.test_boolean).toBe(false)\n\n      const tt1 = await adapter.find('tag_assignments', 'tt2')\n      expect(tt1.text1).toBe('hello')\n    },\n  ],\n  [\n    `can perform empty migrations (regression test)`,\n    async (_adapter, AdapterClass, extraAdapterOptions) => {\n      let adapter = new DatabaseAdapterCompat(\n        new AdapterClass({\n          schema: { ...testSchema, version: 1 },\n          migrations: schemaMigrations({ migrations: [] }),\n          ...extraAdapterOptions,\n        }),\n      )\n      // TODO: Remove me. Temporary workaround for the race condition - wait until next macrotask to ensure that database has set up\n      await new Promise(resolve => setTimeout(resolve, 0))\n      await adapter.batch([['create', 'tasks', mockTaskRaw({ id: 't1', text1: 'foo' })]])\n      expect(await adapter.count(taskQuery())).toBe(1)\n\n      // Perform an empty migration (no steps, just version bump)\n      adapter = await adapter.testClone({\n        schema: { ...testSchema, version: 2 },\n        migrations: schemaMigrations({ migrations: [{ toVersion: 2, steps: [] }] }),\n      })\n\n      // check that migration worked, no data lost\n      expect(await adapter.count(taskQuery())).toBe(1)\n      expect((await adapter.find('tasks', 't1')).text1).toBe('foo')\n    },\n  ],\n  [\n    `resets database when it's newer than app schema`,\n    async (_adapter, AdapterClass, extraAdapterOptions) => {\n      // launch newer version of the app\n      let adapter = new DatabaseAdapterCompat(\n        new AdapterClass({\n          schema: { ...testSchema, version: 3 },\n          migrations: schemaMigrations({ migrations: [{ toVersion: 3, steps: [] }] }),\n          ...extraAdapterOptions,\n        }),\n      )\n      // TODO: Remove me. Temporary workaround for the race condition - wait until next macrotask to ensure that database has set up\n      await new Promise(resolve => setTimeout(resolve, 0))\n\n      await adapter.batch([['create', 'tasks', mockTaskRaw({})]])\n      expect(await adapter.count(taskQuery())).toBe(1)\n\n      // launch older version of the app\n      adapter = await adapter.testClone({\n        schema: { ...testSchema, version: 1 },\n        migrations: schemaMigrations({ migrations: [] }),\n      })\n\n      expect(await adapter.count(taskQuery())).toBe(0)\n      await adapter.batch([['create', 'tasks', mockTaskRaw({})]])\n      expect(await adapter.count(taskQuery())).toBe(1)\n    },\n  ],\n  [\n    'resets database when there are no available migrations',\n    async (_adapter, AdapterClass, extraAdapterOptions) => {\n      // launch older version of the app\n      let adapter = new DatabaseAdapterCompat(\n        new AdapterClass({\n          schema: { ...testSchema, version: 1 },\n          migrations: schemaMigrations({ migrations: [] }),\n          ...extraAdapterOptions,\n        }),\n      )\n      // TODO: Remove me. Temporary workaround for the race condition - wait until next macrotask to ensure that database has set up\n      await new Promise(resolve => setTimeout(resolve, 0))\n\n      await adapter.batch([['create', 'tasks', mockTaskRaw({})]])\n      expect(await adapter.count(taskQuery())).toBe(1)\n\n      // launch newer version of the app, without migrations available\n      adapter = await adapter.testClone({\n        schema: { ...testSchema, version: 3 },\n        migrations: schemaMigrations({ migrations: [{ toVersion: 3, steps: [] }] }),\n      })\n\n      expect(await adapter.count(taskQuery())).toBe(0)\n      await adapter.batch([['create', 'tasks', mockTaskRaw({})]])\n      expect(await adapter.count(taskQuery())).toBe(1)\n    },\n  ],\n  [\n    'errors when migration fails',\n    async (_adapter, AdapterClass, extraAdapterOptions) => {\n      // launch older version of the app\n      let adapter = new DatabaseAdapterCompat(\n        new AdapterClass({\n          schema: { ...testSchema, version: 1 },\n          migrations: schemaMigrations({ migrations: [] }),\n          ...extraAdapterOptions,\n        }),\n      )\n      // TODO: Remove me. Temporary workaround for the race condition - wait until next macrotask to ensure that database has set up\n      await new Promise(resolve => setTimeout(resolve, 0))\n\n      await adapter.batch([['create', 'tasks', mockTaskRaw({})]])\n      expect(await adapter.count(taskQuery())).toBe(1)\n      // launch newer version of the app with a migration that will fail\n      const adapterPromise = adapter.testClone({\n        schema: { ...testSchema, version: 2 },\n        migrations: schemaMigrations({\n          migrations: [\n            {\n              toVersion: 2,\n              steps: [\n                // with SQLite, trying to create a duplicate table will fail, but Loki will just ignore it\n                // so let's insert something that WILL fail\n                AdapterClass.name === 'LokiJSAdapter'\n                  ? { type: 'bad_type' }\n                  : createTable({ name: 'tasks', columns: [] }),\n              ],\n            },\n          ],\n        }),\n      })\n\n      // TODO: Make the SQLite, LokiJS adapter behavior consistent\n      if (AdapterClass.name === 'LokiJSAdapter') {\n        adapter = await adapterPromise\n        await expect(adapter.count(taskQuery())).rejects.toBeInstanceOf(Error)\n        await expect(adapter.batch([['create', 'tasks', mockTaskRaw({})]])).rejects.toBeInstanceOf(\n          Error,\n        )\n      } else {\n        await expect(adapterPromise).rejects.toBeInstanceOf(Error)\n      }\n    },\n  ],\n  ...matchTests.map(testCase => [\n    `[shared match test] ${testCase.name}`,\n    async adapter => {\n      await performMatchTest(adapter, testCase)\n    },\n  ]),\n  [\n    '[shared match test] can match strings from big-list-of-naughty-strings',\n    async (adapter, AdapterClass, extraAdapterOptions) => {\n      // eslint-disable-next-line no-restricted-syntax\n      for (const testCase of naughtyMatchTests) {\n        // console.log(testCase.name)\n\n        // KNOWN ISSUE: non-JSI adapter implementation gets confused by this (it's a BOM mark)\n        if (\n          AdapterClass.name === 'SQLiteAdapter' &&\n          !extraAdapterOptions.experimentalUseJSI &&\n          testCase.matching[0].text1 === '\ufeff'\n        ) {\n          // eslint-disable-next-line no-console\n          console.warn('skip check for a BOM naughty string - known failing test')\n        } else {\n          // eslint-disable-next-line no-await-in-loop\n          await performMatchTest(adapter, testCase)\n        }\n      }\n    },\n  ],\n  [\n    'can store and retrieve large numbers (regression test)',\n    async _adapter => {\n      // NOTE: matcher test didn't catch it because both insert and query has the same bug\n      let adapter = _adapter\n      const number = 1590485104033\n      await adapter.batch([['create', 'tasks', { id: 'm1', num1: number }]])\n      // launch app again\n      adapter = await adapter.testClone()\n      const record = await adapter.find('tasks', 'm1')\n      expect(record.num1).toBe(number)\n    },\n  ],\n  [\n    'can store and retrieve naughty strings exactly',\n    async (_adapter, AdapterClass, extraAdapterOptions) => {\n      let adapter = _adapter\n      const indexedNaughtyStrings = naughtyStrings.map((string, i) => [`id${i}`, string])\n      await adapter.batch(\n        indexedNaughtyStrings.map(([id, string]) => ['create', 'tasks', { id, text1: string }]),\n      )\n\n      // launch app again\n      adapter = await adapter.testClone()\n      const allRecords = await adapter.query(taskQuery())\n\n      indexedNaughtyStrings.forEach(([id, string]) => {\n        const record = allRecords.find(model => model.id === id)\n        // console.log(string, record)\n        // KNOWN ISSUE: non-JSI adapter implementation gets confused by this (it's a BOM mark)\n        if (\n          AdapterClass.name === 'SQLiteAdapter' &&\n          !extraAdapterOptions.experimentalUseJSI &&\n          string === '\ufeff'\n        ) {\n          expect(record.text1).not.toBe(string) // if this fails, it means the issue's been fixed\n        } else {\n          expect(!!record).toBe(true)\n          expect(record.text1).toBe(string)\n        }\n      })\n    },\n  ],\n  ...joinTests.map(testCase => [\n    `[shared join test] ${testCase.name}`,\n    async adapter => {\n      await performJoinTest(adapter, testCase)\n    },\n  ]),\n]\n"], "filenames": ["native/ios/WatermelonDB/DatabaseDriver.swift", "src/adapters/__tests__/commonTests.js"], "buggy_code_start_loc": [131, 439], "buggy_code_end_loc": [133, 439], "fixing_code_start_loc": [131, 440], "fixing_code_end_loc": [133, 465], "type": "CWE-89", "message": "In WatermelonDB (NPM package \"@nozbe/watermelondb\") before versions 0.15.1 and 0.16.2, a maliciously crafted record ID can exploit a SQL Injection vulnerability in iOS adapter implementation and cause the app to delete all or selected records from the database, generally causing the app to become unusable. This may happen in apps that don't validate IDs (valid IDs are `/^[a-zA-Z0-9_-.]+$/`) and use Watermelon Sync or low-level `database.adapter.destroyDeletedRecords` method. The integrity risk is low due to the fact that maliciously deleted records won't synchronize, so logout-login will restore all data, although some local changes may be lost if the malicious deletion causes the sync process to fail to proceed to push stage. No way to breach confidentiality with this vulnerability is known. Full exploitation of SQL Injection is mitigated, because it's not possible to nest an insert/update query inside a delete query in SQLite, and it's not possible to pass a semicolon-separated second query. There's also no known practicable way to breach confidentiality by selectively deleting records, because those records will not be synchronized. It's theoretically possible that selective record deletion could cause an app to behave insecurely if lack of a record is used to make security decisions by the app. This is patched in versions 0.15.1, 0.16.2, and 0.16.1-fix", "other": {"cve": {"id": "CVE-2020-4035", "sourceIdentifier": "security-advisories@github.com", "published": "2020-06-03T17:15:26.153", "lastModified": "2020-06-11T19:56:56.273", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In WatermelonDB (NPM package \"@nozbe/watermelondb\") before versions 0.15.1 and 0.16.2, a maliciously crafted record ID can exploit a SQL Injection vulnerability in iOS adapter implementation and cause the app to delete all or selected records from the database, generally causing the app to become unusable. This may happen in apps that don't validate IDs (valid IDs are `/^[a-zA-Z0-9_-.]+$/`) and use Watermelon Sync or low-level `database.adapter.destroyDeletedRecords` method. The integrity risk is low due to the fact that maliciously deleted records won't synchronize, so logout-login will restore all data, although some local changes may be lost if the malicious deletion causes the sync process to fail to proceed to push stage. No way to breach confidentiality with this vulnerability is known. Full exploitation of SQL Injection is mitigated, because it's not possible to nest an insert/update query inside a delete query in SQLite, and it's not possible to pass a semicolon-separated second query. There's also no known practicable way to breach confidentiality by selectively deleting records, because those records will not be synchronized. It's theoretically possible that selective record deletion could cause an app to behave insecurely if lack of a record is used to make security decisions by the app. This is patched in versions 0.15.1, 0.16.2, and 0.16.1-fix"}, {"lang": "es", "value": "En WatermelonDB (paquete NPM \"@nozbe/watermelondb\") versiones anteriores a 0.15.1 y 0.16.2, un ID de registro dise\u00f1ado con fines maliciosos puede explotar una vulnerabilidad de inyecci\u00f3n SQL en la implementaci\u00f3n del adaptador iOS y causar que la aplicaci\u00f3n elimine todo o registros seleccionados de la base de datos, por lo general, la aplicaci\u00f3n queda inutilizable. Esto puede suceder en aplicaciones que no comprueban los ID (los ID v\u00e1lidos son \"/^[a-zA-Z0-9_-.]+$/\") y usan Watermelon Sync o el m\u00e9todo \"database.adapter.destroyDeletedRecords\" de bajo nivel . El riesgo de integridad es bajo debido al hecho de que los registros eliminados maliciosamente no se sincronizar\u00e1n, por lo que el inicio de sesi\u00f3n cerrar\u00e1 todos los datos, aunque algunos cambios locales pueden perderse si la eliminaci\u00f3n maliciosa causa que el proceso de sincronizaci\u00f3n no avance a la etapa de inserci\u00f3n. No se conoce ninguna manera de violar la confidencialidad con esta vulnerabilidad. Una explotaci\u00f3n completa de la inyecci\u00f3n SQL se mitiga, porque no es posible anidar una consulta de inserci\u00f3n/actualizaci\u00f3n dentro de una consulta de eliminaci\u00f3n en SQLite, y no es posible pasar una segunda consulta separada por punto y coma. Tampoco se conoce una manera pr\u00e1ctica de violar la confidencialidad mediante la eliminaci\u00f3n selectiva de registros, porque esos registros no se sincronizar\u00e1n. Te\u00f3ricamente es posible que la eliminaci\u00f3n de registros selectiva pueda hacer que una aplicaci\u00f3n se comporte de forma no segura si la falta de un registro para tomar decisiones de seguridad es usada por la aplicaci\u00f3n. Esto est\u00e1 parcheado en las versiones 0.15.1, 0.16.2 y 0.16.1-fix"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:N/I:L/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 4.2}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:N/I:L/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 4.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 5.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nozbe:watermelondb:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.15.1", "matchCriteriaId": "246C2261-8971-4C09-90AC-15AD5A864A1F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nozbe:watermelondb:0.16.0:*:*:*:*:*:*:*", "matchCriteriaId": "E9E2E1B2-B5DA-4010-8635-B555309F84C1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nozbe:watermelondb:0.16.1:*:*:*:*:*:*:*", "matchCriteriaId": "2FF01DBC-C248-40CA-BD58-B75E94D99D3D"}]}]}], "references": [{"url": "https://github.com/Nozbe/WatermelonDB/commit/924c7ae2a8d7d6459656751e5b9b1bf91a218025", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Nozbe/WatermelonDB/security/advisories/GHSA-38f9-m297-6q9g", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Nozbe/WatermelonDB/commit/924c7ae2a8d7d6459656751e5b9b1bf91a218025"}}