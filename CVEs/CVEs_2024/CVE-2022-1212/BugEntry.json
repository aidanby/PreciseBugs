{"buggy_code": ["/*\n** vm.c - virtual machine for mruby\n**\n** See Copyright Notice in mruby.h\n*/\n\n#include <mruby.h>\n#include <mruby/array.h>\n#include <mruby/class.h>\n#include <mruby/hash.h>\n#include <mruby/irep.h>\n#include <mruby/numeric.h>\n#include <mruby/proc.h>\n#include <mruby/range.h>\n#include <mruby/string.h>\n#include <mruby/variable.h>\n#include <mruby/error.h>\n#include <mruby/opcode.h>\n#include \"value_array.h\"\n#include <mruby/throw.h>\n#include <mruby/dump.h>\n#include <mruby/internal.h>\n#include <mruby/presym.h>\n\n#ifdef MRB_NO_STDIO\n#if defined(__cplusplus)\nextern \"C\" {\n#endif\nvoid abort(void);\n#if defined(__cplusplus)\n}  /* extern \"C\" { */\n#endif\n#endif\n\n#define STACK_INIT_SIZE 128\n#define CALLINFO_INIT_SIZE 32\n\n/* Define amount of linear stack growth. */\n#ifndef MRB_STACK_GROWTH\n#define MRB_STACK_GROWTH 128\n#endif\n\n/* Maximum recursive depth. Should be set lower on memory constrained systems. */\n#ifndef MRB_CALL_LEVEL_MAX\n#define MRB_CALL_LEVEL_MAX 512\n#endif\n\n/* Maximum stack depth. Should be set lower on memory constrained systems.\nThe value below allows about 60000 recursive calls in the simplest case. */\n#ifndef MRB_STACK_MAX\n#define MRB_STACK_MAX (0x40000 - MRB_STACK_GROWTH)\n#endif\n\n#ifdef VM_DEBUG\n# define DEBUG(x) (x)\n#else\n# define DEBUG(x)\n#endif\n\n\n#ifndef MRB_GC_FIXED_ARENA\nstatic void\nmrb_gc_arena_shrink(mrb_state *mrb, int idx)\n{\n  mrb_gc *gc = &mrb->gc;\n  int capa = gc->arena_capa;\n\n  mrb->gc.arena_idx = idx;\n  if (idx < capa / 4) {\n    capa >>= 2;\n    if (capa < MRB_GC_ARENA_SIZE) {\n      capa = MRB_GC_ARENA_SIZE;\n    }\n    if (capa != gc->arena_capa) {\n      gc->arena = (struct RBasic**)mrb_realloc(mrb, gc->arena, sizeof(struct RBasic*)*capa);\n      gc->arena_capa = capa;\n    }\n  }\n}\n#else\n#define mrb_gc_arena_shrink(mrb,idx) mrb_gc_arena_restore(mrb,idx)\n#endif\n\n#define CALL_MAXARGS 15\n#define CALL_VARARGS (CALL_MAXARGS<<4 | CALL_MAXARGS)\n\nvoid mrb_method_missing(mrb_state *mrb, mrb_sym name, mrb_value self, mrb_value args);\n\nstatic inline void\nstack_clear(mrb_value *from, size_t count)\n{\n  while (count-- > 0) {\n    SET_NIL_VALUE(*from);\n    from++;\n  }\n}\n\nstatic inline void\nstack_copy(mrb_value *dst, const mrb_value *src, size_t size)\n{\n  memcpy(dst, src, sizeof(mrb_value)*size);\n}\n\nstatic void\nstack_init(mrb_state *mrb)\n{\n  struct mrb_context *c = mrb->c;\n\n  /* mrb_assert(mrb->stack == NULL); */\n  c->stbase = (mrb_value *)mrb_calloc(mrb, STACK_INIT_SIZE, sizeof(mrb_value));\n  c->stend = c->stbase + STACK_INIT_SIZE;\n\n  /* mrb_assert(ci == NULL); */\n  c->cibase = (mrb_callinfo *)mrb_calloc(mrb, CALLINFO_INIT_SIZE, sizeof(mrb_callinfo));\n  c->ciend = c->cibase + CALLINFO_INIT_SIZE;\n  c->ci = c->cibase;\n  c->ci->u.target_class = mrb->object_class;\n  c->ci->stack = c->stbase;\n}\n\nstatic inline void\nenvadjust(mrb_state *mrb, mrb_value *oldbase, mrb_value *newbase, size_t oldsize)\n{\n  mrb_callinfo *ci = mrb->c->cibase;\n\n  if (newbase == oldbase) return;\n  while (ci <= mrb->c->ci) {\n    struct REnv *e = mrb_vm_ci_env(ci);\n    mrb_value *st;\n\n    if (e && MRB_ENV_ONSTACK_P(e) &&\n        (st = e->stack) && oldbase <= st && st < oldbase+oldsize) {\n      ptrdiff_t off = e->stack - oldbase;\n\n      e->stack = newbase + off;\n    }\n\n    if (ci->proc && MRB_PROC_ENV_P(ci->proc) && e != MRB_PROC_ENV(ci->proc)) {\n      e = MRB_PROC_ENV(ci->proc);\n\n      if (e && MRB_ENV_ONSTACK_P(e) &&\n          (st = e->stack) && oldbase <= st && st < oldbase+oldsize) {\n        ptrdiff_t off = e->stack - oldbase;\n\n        e->stack = newbase + off;\n      }\n    }\n\n    ci->stack = newbase + (ci->stack - oldbase);\n    ci++;\n  }\n}\n\n/** def rec ; $deep =+ 1 ; if $deep > 1000 ; return 0 ; end ; rec ; end  */\n\nstatic void\nstack_extend_alloc(mrb_state *mrb, mrb_int room)\n{\n  mrb_value *oldbase = mrb->c->stbase;\n  mrb_value *newstack;\n  size_t oldsize = mrb->c->stend - mrb->c->stbase;\n  size_t size = oldsize;\n  size_t off = mrb->c->ci->stack ? mrb->c->stend - mrb->c->ci->stack : 0;\n\n  if (off > size) size = off;\n#ifdef MRB_STACK_EXTEND_DOUBLING\n  if ((size_t)room <= size)\n    size *= 2;\n  else\n    size += room;\n#else\n  /* Use linear stack growth.\n     It is slightly slower than doubling the stack space,\n     but it saves memory on small devices. */\n  if (room <= MRB_STACK_GROWTH)\n    size += MRB_STACK_GROWTH;\n  else\n    size += room;\n#endif\n\n  newstack = (mrb_value *)mrb_realloc_simple(mrb, mrb->c->stbase, sizeof(mrb_value) * size);\n  if (newstack == NULL) {\n    mrb_exc_raise(mrb, mrb_obj_value(mrb->stack_err));\n  }\n  stack_clear(&(newstack[oldsize]), size - oldsize);\n  envadjust(mrb, oldbase, newstack, oldsize);\n  mrb->c->stbase = newstack;\n  mrb->c->stend = mrb->c->stbase + size;\n\n  /* Raise an exception if the new stack size will be too large,\n     to prevent infinite recursion. However, do this only after resizing the stack, so mrb_raise has stack space to work with. */\n  if (size > MRB_STACK_MAX) {\n    mrb_exc_raise(mrb, mrb_obj_value(mrb->stack_err));\n  }\n}\n\nMRB_API void\nmrb_stack_extend(mrb_state *mrb, mrb_int room)\n{\n  if (!mrb->c->ci->stack || mrb->c->ci->stack + room >= mrb->c->stend) {\n    stack_extend_alloc(mrb, room);\n  }\n}\n\nstatic inline struct REnv*\nuvenv(mrb_state *mrb, mrb_int up)\n{\n  const struct RProc *proc = mrb->c->ci->proc;\n  struct REnv *e;\n\n  while (up--) {\n    proc = proc->upper;\n    if (!proc) return NULL;\n  }\n  e = MRB_PROC_ENV(proc);\n  if (e) return e;              /* proc has enclosed env */\n  else {\n    mrb_callinfo *ci = mrb->c->ci;\n    mrb_callinfo *cb = mrb->c->cibase;\n\n    while (cb <= ci) {\n      if (ci->proc == proc) {\n        return mrb_vm_ci_env(ci);\n      }\n      ci--;\n    }\n  }\n  return NULL;\n}\n\nstatic inline const struct RProc*\ntop_proc(mrb_state *mrb, const struct RProc *proc)\n{\n  while (proc->upper) {\n    if (MRB_PROC_SCOPE_P(proc) || MRB_PROC_STRICT_P(proc))\n      return proc;\n    proc = proc->upper;\n  }\n  return proc;\n}\n\n#define CINFO_NONE    0\n#define CINFO_SKIP    1\n#define CINFO_DIRECT  2\n#define CINFO_RESUMED 3\n\nstatic inline mrb_callinfo*\ncipush(mrb_state *mrb, mrb_int push_stacks, uint8_t cci,\n       struct RClass *target_class, const struct RProc *proc, mrb_sym mid, uint8_t argc)\n{\n  struct mrb_context *c = mrb->c;\n  mrb_callinfo *ci = c->ci;\n\n  if (ci + 1 == c->ciend) {\n    ptrdiff_t size = ci - c->cibase;\n\n    if (size > MRB_CALL_LEVEL_MAX) {\n      mrb_exc_raise(mrb, mrb_obj_value(mrb->stack_err));\n    }\n    c->cibase = (mrb_callinfo *)mrb_realloc(mrb, c->cibase, sizeof(mrb_callinfo)*size*2);\n    c->ci = c->cibase + size;\n    c->ciend = c->cibase + size * 2;\n  }\n  ci = ++c->ci;\n  ci->mid = mid;\n  mrb_vm_ci_proc_set(ci, proc);\n  ci->stack = ci[-1].stack + push_stacks;\n  ci->n = argc & 0xf;\n  ci->nk = (argc>>4) & 0xf;\n  ci->cci = cci;\n  ci->u.target_class = target_class;\n\n  return ci;\n}\n\nvoid\nmrb_env_unshare(mrb_state *mrb, struct REnv *e)\n{\n  if (e == NULL) return;\n  else {\n    size_t len = (size_t)MRB_ENV_LEN(e);\n    mrb_value *p;\n\n    if (!MRB_ENV_ONSTACK_P(e)) return;\n    if (e->cxt != mrb->c) return;\n    if (e == mrb_vm_ci_env(mrb->c->cibase)) return; /* for mirb */\n    p = (mrb_value *)mrb_malloc(mrb, sizeof(mrb_value)*len);\n    if (len > 0) {\n      stack_copy(p, e->stack, len);\n    }\n    e->stack = p;\n    MRB_ENV_CLOSE(e);\n    mrb_write_barrier(mrb, (struct RBasic *)e);\n  }\n}\n\nstatic inline mrb_callinfo*\ncipop(mrb_state *mrb)\n{\n  struct mrb_context *c = mrb->c;\n  struct REnv *env = mrb_vm_ci_env(c->ci);\n\n  c->ci--;\n  if (env) mrb_env_unshare(mrb, env);\n  return c->ci;\n}\n\nMRB_API mrb_value\nmrb_protect_error(mrb_state *mrb, mrb_protect_error_func *body, void *userdata, mrb_bool *error)\n{\n  struct mrb_jmpbuf *prev_jmp = mrb->jmp;\n  struct mrb_jmpbuf c_jmp;\n  mrb_value result = mrb_nil_value();\n  int ai = mrb_gc_arena_save(mrb);\n  const struct mrb_context *c = mrb->c;\n  ptrdiff_t ci_index = c->ci - c->cibase;\n\n  if (error) { *error = FALSE; }\n\n  MRB_TRY(&c_jmp) {\n    mrb->jmp = &c_jmp;\n    result = body(mrb, userdata);\n    mrb->jmp = prev_jmp;\n  }\n  MRB_CATCH(&c_jmp) {\n    mrb->jmp = prev_jmp;\n    result = mrb_obj_value(mrb->exc);\n    mrb->exc = NULL;\n    if (error) { *error = TRUE; }\n    if (mrb->c == c) {\n      while (c->ci - c->cibase > ci_index) {\n        cipop(mrb);\n      }\n    }\n    else {\n      // It was probably switched by mrb_fiber_resume().\n      // Simply destroy all successive CINFO_DIRECTs once the fiber has been switched.\n      c = mrb->c;\n      while (c->ci > c->cibase && c->ci->cci == CINFO_DIRECT) {\n        cipop(mrb);\n      }\n    }\n  }\n  MRB_END_EXC(&c_jmp);\n\n  mrb_gc_arena_restore(mrb, ai);\n  mrb_gc_protect(mrb, result);\n  return result;\n}\n\nvoid mrb_exc_set(mrb_state *mrb, mrb_value exc);\nstatic mrb_value mrb_run(mrb_state *mrb, const struct RProc* proc, mrb_value self);\n\n#ifndef MRB_FUNCALL_ARGC_MAX\n#define MRB_FUNCALL_ARGC_MAX 16\n#endif\n\nMRB_API mrb_value\nmrb_funcall(mrb_state *mrb, mrb_value self, const char *name, mrb_int argc, ...)\n{\n  mrb_value argv[MRB_FUNCALL_ARGC_MAX];\n  va_list ap;\n  mrb_int i;\n  mrb_sym mid = mrb_intern_cstr(mrb, name);\n\n  if (argc > MRB_FUNCALL_ARGC_MAX) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"Too long arguments. (limit=\" MRB_STRINGIZE(MRB_FUNCALL_ARGC_MAX) \")\");\n  }\n\n  va_start(ap, argc);\n  for (i = 0; i < argc; i++) {\n    argv[i] = va_arg(ap, mrb_value);\n  }\n  va_end(ap);\n  return mrb_funcall_argv(mrb, self, mid, argc, argv);\n}\n\nMRB_API mrb_value\nmrb_funcall_id(mrb_state *mrb, mrb_value self, mrb_sym mid, mrb_int argc, ...)\n{\n  mrb_value argv[MRB_FUNCALL_ARGC_MAX];\n  va_list ap;\n  mrb_int i;\n\n  if (argc > MRB_FUNCALL_ARGC_MAX) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"Too long arguments. (limit=\" MRB_STRINGIZE(MRB_FUNCALL_ARGC_MAX) \")\");\n  }\n\n  va_start(ap, argc);\n  for (i = 0; i < argc; i++) {\n    argv[i] = va_arg(ap, mrb_value);\n  }\n  va_end(ap);\n  return mrb_funcall_argv(mrb, self, mid, argc, argv);\n}\n\nstatic mrb_int\nmrb_ci_kidx(const mrb_callinfo *ci)\n{\n  return (ci->n == CALL_MAXARGS) ? 2 : ci->n + 1;\n}\n\nstatic mrb_int\nmrb_bidx(uint16_t c)\n{\n  uint8_t n = c & 0xf;\n  uint8_t k = (c>>4) & 0xf;\n  if (n == 15) n = 1;\n  if (k == 15) n += 1;\n  else n += k*2;\n  return n + 1;                 /* self + args + kargs */\n}\n\nmrb_int\nmrb_ci_bidx(mrb_callinfo *ci)\n{\n  return mrb_bidx(ci->n|(ci->nk<<4));\n}\n\nmrb_int\nmrb_ci_nregs(mrb_callinfo *ci)\n{\n  const struct RProc *p;\n\n  if (!ci) return 4;\n  mrb_int nregs = mrb_ci_bidx(ci) + 1; /* self + args + kargs + blk */\n  p = ci->proc;\n  if (p && !MRB_PROC_CFUNC_P(p) && p->body.irep && p->body.irep->nregs > nregs) {\n    return p->body.irep->nregs;\n  }\n  return nregs;\n}\n\nmrb_value mrb_obj_missing(mrb_state *mrb, mrb_value mod);\n\nstatic mrb_method_t\nprepare_missing(mrb_state *mrb, mrb_value recv, mrb_sym mid, struct RClass **clsp, uint32_t a, uint16_t *c, mrb_value blk, int super)\n{\n  mrb_sym missing = MRB_SYM(method_missing);\n  mrb_callinfo *ci = mrb->c->ci;\n  uint16_t b = *c;\n  mrb_int n = b & 0xf;\n  mrb_int nk = (b>>4) & 0xf;\n  mrb_value *argv = &ci->stack[a+1];\n  mrb_value args;\n  mrb_method_t m;\n\n  /* pack positional arguments */\n  if (n == 15) args = argv[0];\n  else args = mrb_ary_new_from_values(mrb, n, argv);\n\n  if (mrb_func_basic_p(mrb, recv, missing, mrb_obj_missing)) {\n  method_missing:\n    if (super) mrb_no_method_error(mrb, mid, args, \"no superclass method '%n'\", mid);\n    else mrb_method_missing(mrb, mid, recv, args);\n    /* not reached */\n  }\n  if (mid != missing) {\n    *clsp = mrb_class(mrb, recv);\n  }\n  m = mrb_method_search_vm(mrb, clsp, missing);\n  if (MRB_METHOD_UNDEF_P(m)) goto method_missing; /* just in case */\n  mrb_stack_extend(mrb, a+4);\n\n  argv = &ci->stack[a+1];       /* maybe reallocated */\n  argv[0] = args;\n  if (nk == 0) {\n    argv[1] = blk;\n  }\n  else {\n    mrb_assert(nk == 15);\n    argv[1] = argv[n];\n    argv[2] = blk;\n  }\n  *c = 15 | (uint16_t)(nk<<4);\n  mrb_ary_unshift(mrb, args, mrb_symbol_value(mid));\n  return m;\n}\n\nMRB_API mrb_value\nmrb_funcall_with_block(mrb_state *mrb, mrb_value self, mrb_sym mid, mrb_int argc, const mrb_value *argv, mrb_value blk)\n{\n  mrb_value val;\n  int ai = mrb_gc_arena_save(mrb);\n\n  if (!mrb->jmp) {\n    struct mrb_jmpbuf c_jmp;\n    ptrdiff_t nth_ci = mrb->c->ci - mrb->c->cibase;\n\n    MRB_TRY(&c_jmp) {\n      mrb->jmp = &c_jmp;\n      /* recursive call */\n      val = mrb_funcall_with_block(mrb, self, mid, argc, argv, blk);\n      mrb->jmp = 0;\n    }\n    MRB_CATCH(&c_jmp) { /* error */\n      while (nth_ci < (mrb->c->ci - mrb->c->cibase)) {\n        cipop(mrb);\n      }\n      mrb->jmp = 0;\n      val = mrb_obj_value(mrb->exc);\n    }\n    MRB_END_EXC(&c_jmp);\n    mrb->jmp = 0;\n  }\n  else {\n    mrb_method_t m;\n    struct RClass *c;\n    mrb_callinfo *ci = mrb->c->ci;\n    mrb_int n = mrb_ci_nregs(ci);\n    ptrdiff_t voff = -1;\n\n    if (!mrb->c->stbase) {\n      stack_init(mrb);\n    }\n    if (ci - mrb->c->cibase > MRB_CALL_LEVEL_MAX) {\n      mrb_exc_raise(mrb, mrb_obj_value(mrb->stack_err));\n    }\n    if (mrb->c->stbase <= argv && argv < mrb->c->stend) {\n      voff = argv - mrb->c->stbase;\n    }\n    if (argc < 0) {\n      mrb_raisef(mrb, E_ARGUMENT_ERROR, \"negative argc for funcall (%i)\", argc);\n    }\n    c = mrb_class(mrb, self);\n    m = mrb_method_search_vm(mrb, &c, mid);\n    mrb_stack_extend(mrb, n + argc + 3);\n    if (argc >= 15) {\n      ci->stack[n+1] = mrb_ary_new_from_values(mrb, argc, argv);\n      argc = 15;\n    }\n    if (MRB_METHOD_UNDEF_P(m)) {\n      uint16_t ac = (uint16_t)argc;\n      m = prepare_missing(mrb, self, mid, &c, n, &ac, mrb_nil_value(), 0);\n      argc = (mrb_int)ac;\n      mid = MRB_SYM(method_missing);\n    }\n    ci = cipush(mrb, n, 0, c, NULL, mid, argc);\n    if (MRB_METHOD_PROC_P(m)) {\n      struct RProc *p = MRB_METHOD_PROC(m);\n\n      mrb_vm_ci_proc_set(ci, p);\n      if (!MRB_PROC_CFUNC_P(p)) {\n        mrb_stack_extend(mrb, p->body.irep->nregs + argc);\n      }\n    }\n    if (voff >= 0) {\n      argv = mrb->c->stbase + voff;\n    }\n    ci->stack[0] = self;\n    if (argc < 15) {\n      if (argc > 0)\n        stack_copy(ci->stack+1, argv, argc);\n      ci->stack[argc+1] = blk;\n    }\n    else {\n      ci->stack[2] = blk;\n    }\n\n    if (MRB_METHOD_CFUNC_P(m)) {\n      ci->cci = CINFO_DIRECT;\n      val = MRB_METHOD_CFUNC(m)(mrb, self);\n      cipop(mrb);\n    }\n    else {\n      ci->cci = CINFO_SKIP;\n      val = mrb_run(mrb, MRB_METHOD_PROC(m), self);\n    }\n  }\n  mrb_gc_arena_restore(mrb, ai);\n  mrb_gc_protect(mrb, val);\n  return val;\n}\n\nMRB_API mrb_value\nmrb_funcall_argv(mrb_state *mrb, mrb_value self, mrb_sym mid, mrb_int argc, const mrb_value *argv)\n{\n  return mrb_funcall_with_block(mrb, self, mid, argc, argv, mrb_nil_value());\n}\n\nstatic void\ncheck_method_noarg(mrb_state *mrb, const mrb_callinfo *ci)\n{\n  int argc = ci->n == CALL_MAXARGS ? RARRAY_LEN(ci->stack[1]) : ci->n;\n  if (ci->nk > 0) {\n    mrb_value kdict = ci->stack[mrb_ci_kidx(ci)];\n    if (!(mrb_hash_p(kdict) && mrb_hash_empty_p(mrb, kdict))) {\n      argc++;\n    }\n  }\n  if (argc > 0) {\n    mrb_argnum_error(mrb, argc, 0, 0);\n  }\n}\n\nstatic mrb_value\nexec_irep(mrb_state *mrb, mrb_value self, struct RProc *p)\n{\n  mrb_callinfo *ci = mrb->c->ci;\n  int keep, nregs;\n\n  ci->stack[0] = self;\n  mrb_vm_ci_proc_set(ci, p);\n  if (MRB_PROC_CFUNC_P(p)) {\n    if (MRB_PROC_NOARG_P(p)) {\n      check_method_noarg(mrb, ci);\n    }\n    return MRB_PROC_CFUNC(p)(mrb, self);\n  }\n  nregs = p->body.irep->nregs;\n  keep = mrb_ci_bidx(ci)+1;\n  if (nregs < keep) {\n    mrb_stack_extend(mrb, keep);\n  }\n  else {\n    mrb_stack_extend(mrb, nregs);\n    stack_clear(ci->stack+keep, nregs-keep);\n  }\n\n  cipush(mrb, 0, 0, NULL, NULL, 0, 0);\n\n  return self;\n}\n\nmrb_value\nmrb_exec_irep(mrb_state *mrb, mrb_value self, struct RProc *p)\n{\n  mrb_callinfo *ci = mrb->c->ci;\n  if (ci->cci == CINFO_NONE) {\n    return exec_irep(mrb, self, p);\n  }\n  else {\n    mrb_value ret;\n    if (MRB_PROC_CFUNC_P(p)) {\n      if (MRB_PROC_NOARG_P(p)) {\n        check_method_noarg(mrb, ci);\n      }\n      cipush(mrb, 0, CINFO_DIRECT, mrb_vm_ci_target_class(ci), p, ci->mid, ci->n|(ci->nk<<4));\n      ret = MRB_PROC_CFUNC(p)(mrb, self);\n      cipop(mrb);\n    }\n    else {\n      int keep = mrb_ci_bidx(ci) + 1; /* receiver + block */\n      ret = mrb_top_run(mrb, p, self, keep);\n    }\n    if (mrb->exc && mrb->jmp) {\n      mrb_exc_raise(mrb, mrb_obj_value(mrb->exc));\n    }\n    return ret;\n  }\n}\n\n/* 15.3.1.3.4  */\n/* 15.3.1.3.44 */\n/*\n *  call-seq:\n *     obj.send(symbol [, args...])        -> obj\n *     obj.__send__(symbol [, args...])      -> obj\n *\n *  Invokes the method identified by _symbol_, passing it any\n *  arguments specified. You can use <code>__send__</code> if the name\n *  +send+ clashes with an existing method in _obj_.\n *\n *     class Klass\n *       def hello(*args)\n *         \"Hello \" + args.join(' ')\n *       end\n *     end\n *     k = Klass.new\n *     k.send :hello, \"gentle\", \"readers\"   #=> \"Hello gentle readers\"\n */\nmrb_value\nmrb_f_send(mrb_state *mrb, mrb_value self)\n{\n  mrb_sym name;\n  mrb_value block, *regs;\n  mrb_method_t m;\n  struct RClass *c;\n  mrb_callinfo *ci = mrb->c->ci;\n  int n = ci->n;\n\n  if (ci->cci > CINFO_NONE) {\n  funcall:;\n    const mrb_value *argv;\n    mrb_int argc;\n    mrb_get_args(mrb, \"n*&\", &name, &argv, &argc, &block);\n    return mrb_funcall_with_block(mrb, self, name, argc, argv, block);\n  }\n\n  regs = mrb->c->ci->stack+1;\n\n  if (n == 0) {\n  argnum_error:\n    mrb_argnum_error(mrb, 0, 1, -1);\n  }\n  else if (n == 15) {\n    if (RARRAY_LEN(regs[0]) == 0) goto argnum_error;\n    name = mrb_obj_to_sym(mrb, RARRAY_PTR(regs[0])[0]);\n  }\n  else {\n    name = mrb_obj_to_sym(mrb, regs[0]);\n  }\n\n  c = mrb_class(mrb, self);\n  m = mrb_method_search_vm(mrb, &c, name);\n  if (MRB_METHOD_UNDEF_P(m)) {            /* call method_mising */\n    goto funcall;\n  }\n\n  ci->mid = name;\n  ci->u.target_class = c;\n  /* remove first symbol from arguments */\n  if (n == 15) {     /* variable length arguments */\n    regs[0] = mrb_ary_subseq(mrb, regs[0], 1, RARRAY_LEN(regs[0]) - 1);\n  }\n  else { /* n > 0 */\n    for (int i=0; i<n; i++) {\n      regs[i] = regs[i+1];\n    }\n    regs[n] = regs[n+1];        /* copy kdict or block */\n    if (ci->nk > 0) {\n      regs[n+1] = regs[n+2];    /* copy block */\n    }\n    ci->n--;\n  }\n\n  if (MRB_METHOD_CFUNC_P(m)) {\n    if (MRB_METHOD_NOARG_P(m)) {\n      check_method_noarg(mrb, ci);\n    }\n\n    if (MRB_METHOD_PROC_P(m)) {\n      mrb_vm_ci_proc_set(ci, MRB_METHOD_PROC(m));\n    }\n    return MRB_METHOD_CFUNC(m)(mrb, self);\n  }\n  return exec_irep(mrb, self, MRB_METHOD_PROC(m));\n}\n\nstatic void\ncheck_block(mrb_state *mrb, mrb_value blk)\n{\n  if (mrb_nil_p(blk)) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"no block given\");\n  }\n  if (!mrb_proc_p(blk)) {\n    mrb_raise(mrb, E_TYPE_ERROR, \"not a block\");\n  }\n}\n\nstatic mrb_value\neval_under(mrb_state *mrb, mrb_value self, mrb_value blk, struct RClass *c)\n{\n  struct RProc *p;\n  mrb_callinfo *ci;\n  int nregs;\n\n  check_block(mrb, blk);\n  ci = mrb->c->ci;\n  if (ci->cci == CINFO_DIRECT) {\n    return mrb_yield_with_class(mrb, blk, 1, &self, self, c);\n  }\n  ci->u.target_class = c;\n  p = mrb_proc_ptr(blk);\n  mrb_vm_ci_proc_set(ci, p);\n  ci->n = 1;\n  ci->nk = 0;\n  ci->mid = ci[-1].mid;\n  if (MRB_PROC_CFUNC_P(p)) {\n    mrb_stack_extend(mrb, 4);\n    mrb->c->ci->stack[0] = self;\n    mrb->c->ci->stack[1] = self;\n    mrb->c->ci->stack[2] = mrb_nil_value();\n    return MRB_PROC_CFUNC(p)(mrb, self);\n  }\n  nregs = p->body.irep->nregs;\n  if (nregs < 4) nregs = 4;\n  mrb_stack_extend(mrb, nregs);\n  mrb->c->ci->stack[0] = self;\n  mrb->c->ci->stack[1] = self;\n  stack_clear(mrb->c->ci->stack+2, nregs-2);\n  ci = cipush(mrb, 0, 0, NULL, NULL, 0, 0);\n\n  return self;\n}\n\n/* 15.2.2.4.35 */\n/*\n *  call-seq:\n *     mod.class_eval {| | block }  -> obj\n *     mod.module_eval {| | block } -> obj\n *\n *  Evaluates block in the context of _mod_. This can\n *  be used to add methods to a class. <code>module_eval</code> returns\n *  the result of evaluating its argument.\n */\nmrb_value\nmrb_mod_module_eval(mrb_state *mrb, mrb_value mod)\n{\n  mrb_value a, b;\n\n  if (mrb_get_args(mrb, \"|S&\", &a, &b) == 1) {\n    mrb_raise(mrb, E_NOTIMP_ERROR, \"module_eval/class_eval with string not implemented\");\n  }\n  return eval_under(mrb, mod, b, mrb_class_ptr(mod));\n}\n\n/* 15.3.1.3.18 */\n/*\n *  call-seq:\n *     obj.instance_eval {| | block }                       -> obj\n *\n *  Evaluates the given block,within  the context of the receiver (_obj_).\n *  In order to set the context, the variable +self+ is set to _obj_ while\n *  the code is executing, giving the code access to _obj_'s\n *  instance variables. In the version of <code>instance_eval</code>\n *  that takes a +String+, the optional second and third\n *  parameters supply a filename and starting line number that are used\n *  when reporting compilation errors.\n *\n *     class KlassWithSecret\n *       def initialize\n *         @secret = 99\n *       end\n *     end\n *     k = KlassWithSecret.new\n *     k.instance_eval { @secret }   #=> 99\n */\nmrb_value\nmrb_obj_instance_eval(mrb_state *mrb, mrb_value self)\n{\n  mrb_value a, b;\n\n  if (mrb_get_args(mrb, \"|S&\", &a, &b) == 1) {\n    mrb_raise(mrb, E_NOTIMP_ERROR, \"instance_eval with string not implemented\");\n  }\n  return eval_under(mrb, self, b, mrb_singleton_class_ptr(mrb, self));\n}\n\nMRB_API mrb_value\nmrb_yield_with_class(mrb_state *mrb, mrb_value b, mrb_int argc, const mrb_value *argv, mrb_value self, struct RClass *c)\n{\n  struct RProc *p;\n  mrb_sym mid = mrb->c->ci->mid;\n  mrb_callinfo *ci;\n  mrb_value val;\n  mrb_int n;\n\n  check_block(mrb, b);\n  ci = mrb->c->ci;\n  n = mrb_ci_nregs(ci);\n  p = mrb_proc_ptr(b);\n  ci = cipush(mrb, n, CINFO_SKIP, c, p, mid, 0 /* dummy */);\n  ci->nk = 0;\n  if (argc >= CALL_MAXARGS) {\n    ci->n = 15;\n    n = 3;\n  }\n  else {\n    ci->n = argc;\n    n = argc + 2;\n  }\n  mrb_stack_extend(mrb, n);\n  mrb->c->ci->stack[0] = self;\n  if (ci->n == 15) {\n    mrb->c->ci->stack[1] = mrb_ary_new_from_values(mrb, argc, argv);\n    argc = 1;\n  }\n  else if (argc > 0) {\n    stack_copy(mrb->c->ci->stack+1, argv, argc);\n  }\n  mrb->c->ci->stack[argc+1] = mrb_nil_value(); /* clear blk */\n\n  if (MRB_PROC_CFUNC_P(p)) {\n    ci->cci = CINFO_DIRECT;\n    val = MRB_PROC_CFUNC(p)(mrb, self);\n    cipop(mrb);\n  }\n  else {\n    val = mrb_run(mrb, p, self);\n  }\n  return val;\n}\n\nMRB_API mrb_value\nmrb_yield_argv(mrb_state *mrb, mrb_value b, mrb_int argc, const mrb_value *argv)\n{\n  struct RProc *p = mrb_proc_ptr(b);\n\n  return mrb_yield_with_class(mrb, b, argc, argv, MRB_PROC_ENV(p)->stack[0], MRB_PROC_TARGET_CLASS(p));\n}\n\nMRB_API mrb_value\nmrb_yield(mrb_state *mrb, mrb_value b, mrb_value arg)\n{\n  struct RProc *p = mrb_proc_ptr(b);\n\n  return mrb_yield_with_class(mrb, b, 1, &arg, MRB_PROC_ENV(p)->stack[0], MRB_PROC_TARGET_CLASS(p));\n}\n\nmrb_value\nmrb_yield_cont(mrb_state *mrb, mrb_value b, mrb_value self, mrb_int argc, const mrb_value *argv)\n{\n  struct RProc *p;\n  mrb_callinfo *ci;\n\n  check_block(mrb, b);\n  p = mrb_proc_ptr(b);\n  ci = mrb->c->ci;\n\n  mrb_stack_extend(mrb, 4);\n  mrb->c->ci->stack[1] = mrb_ary_new_from_values(mrb, argc, argv);\n  mrb->c->ci->stack[2] = mrb_nil_value();\n  mrb->c->ci->stack[3] = mrb_nil_value();\n  ci->n = 15;\n  ci->nk = 0;\n  return exec_irep(mrb, self, p);\n}\n\nstatic struct RBreak*\nbreak_new(mrb_state *mrb, uint32_t tag, const struct RProc *p, mrb_value val)\n{\n  struct RBreak *brk;\n\n  brk = MRB_OBJ_ALLOC(mrb, MRB_TT_BREAK, NULL);\n  mrb_break_proc_set(brk, p);\n  mrb_break_value_set(brk, val);\n  mrb_break_tag_set(brk, tag);\n\n  return brk;\n}\n\n#define MRB_CATCH_FILTER_RESCUE (UINT32_C(1) << MRB_CATCH_RESCUE)\n#define MRB_CATCH_FILTER_ENSURE (UINT32_C(1) << MRB_CATCH_ENSURE)\n#define MRB_CATCH_FILTER_ALL    (MRB_CATCH_FILTER_RESCUE | MRB_CATCH_FILTER_ENSURE)\n\nstatic const struct mrb_irep_catch_handler *\ncatch_handler_find(mrb_state *mrb, mrb_callinfo *ci, const mrb_code *pc, uint32_t filter)\n{\n  const mrb_irep *irep;\n  ptrdiff_t xpc;\n  size_t cnt;\n  const struct mrb_irep_catch_handler *e;\n\n/* The comparison operators use `>` and `<=` because pc already points to the next instruction */\n#define catch_cover_p(pc, beg, end) ((pc) > (ptrdiff_t)(beg) && (pc) <= (ptrdiff_t)(end))\n\n  if (ci->proc == NULL || MRB_PROC_CFUNC_P(ci->proc)) return NULL;\n  irep = ci->proc->body.irep;\n  if (irep->clen < 1) return NULL;\n  xpc = pc - irep->iseq;\n  /* If it retry at the top level, pc will be 0, so check with -1 as the start position */\n  mrb_assert(catch_cover_p(xpc, -1, irep->ilen));\n  if (!catch_cover_p(xpc, -1, irep->ilen)) return NULL;\n\n  /* Currently uses a simple linear search to avoid processing complexity. */\n  cnt = irep->clen;\n  e = mrb_irep_catch_handler_table(irep) + cnt - 1;\n  for (; cnt > 0; cnt --, e --) {\n    if (((UINT32_C(1) << e->type) & filter) &&\n        catch_cover_p(xpc, mrb_irep_catch_handler_unpack(e->begin), mrb_irep_catch_handler_unpack(e->end))) {\n      return e;\n    }\n  }\n\n#undef catch_cover_p\n\n  return NULL;\n}\n\ntypedef enum {\n  LOCALJUMP_ERROR_RETURN = 0,\n  LOCALJUMP_ERROR_BREAK = 1,\n  LOCALJUMP_ERROR_YIELD = 2\n} localjump_error_kind;\n\nstatic void\nlocaljump_error(mrb_state *mrb, localjump_error_kind kind)\n{\n  char kind_str[3][7] = { \"return\", \"break\", \"yield\" };\n  char kind_str_len[] = { 6, 5, 5 };\n  static const char lead[] = \"unexpected \";\n  mrb_value msg;\n  mrb_value exc;\n\n  msg = mrb_str_new_capa(mrb, sizeof(lead) + 7);\n  mrb_str_cat(mrb, msg, lead, sizeof(lead) - 1);\n  mrb_str_cat(mrb, msg, kind_str[kind], kind_str_len[kind]);\n  exc = mrb_exc_new_str(mrb, E_LOCALJUMP_ERROR, msg);\n  mrb_exc_set(mrb, exc);\n}\n\nstatic void\nargnum_error(mrb_state *mrb, mrb_int num)\n{\n  mrb_value exc;\n  mrb_value str;\n  mrb_int argc = mrb->c->ci->n;\n\n  if (argc == 15) {\n    mrb_value args = mrb->c->ci->stack[1];\n    if (mrb_array_p(args)) {\n      argc = RARRAY_LEN(args);\n    }\n  }\n  if (argc == 0 && mrb->c->ci->nk != 0 && !mrb_hash_empty_p(mrb, mrb->c->ci->stack[1])) {\n    argc++;\n  }\n  str = mrb_format(mrb, \"wrong number of arguments (given %i, expected %i)\", argc, num);\n  exc = mrb_exc_new_str(mrb, E_ARGUMENT_ERROR, str);\n  mrb_exc_set(mrb, exc);\n}\n\nstatic mrb_bool\nbreak_tag_p(struct RBreak *brk, uint32_t tag)\n{\n  return (brk != NULL && brk->tt == MRB_TT_BREAK) ? TRUE : FALSE;\n}\n\nstatic void\nprepare_tagged_break(mrb_state *mrb, uint32_t tag, const struct RProc *proc, mrb_value val)\n{\n  if (break_tag_p((struct RBreak*)mrb->exc, tag)) {\n    mrb_break_tag_set((struct RBreak*)mrb->exc, tag);\n  }\n  else {\n    mrb->exc = (struct RObject*)break_new(mrb, tag, proc, val);\n  }\n}\n\n#define THROW_TAGGED_BREAK(mrb, tag, proc, val) \\\n  do { \\\n    prepare_tagged_break(mrb, tag, proc, val); \\\n    goto L_CATCH_TAGGED_BREAK; \\\n  } while (0)\n\n#define UNWIND_ENSURE(mrb, ci, pc, tag, proc, val) \\\n  do { \\\n    ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ENSURE); \\\n    if (ch) { \\\n      THROW_TAGGED_BREAK(mrb, tag, proc, val); \\\n    } \\\n  } while (0)\n\n/*\n *  CHECKPOINT_RESTORE(tag) {\n *    This part is executed when jumping by the same \"tag\" of RBreak (it is not executed the first time).\n *    Write the code required (initialization of variables, etc.) for the subsequent processing.\n *  }\n *  CHECKPOINT_MAIN(tag) {\n *    This part is always executed.\n *  }\n *  CHECKPOINT_END(tag);\n *\n *  ...\n *\n *  // Jump to CHECKPOINT_RESTORE with the same \"tag\".\n *  goto CHECKPOINT_LABEL_MAKE(tag);\n */\n\n#define CHECKPOINT_LABEL_MAKE(tag) L_CHECKPOINT_ ## tag\n\n#define CHECKPOINT_RESTORE(tag) \\\n  do { \\\n    if (FALSE) { \\\n      CHECKPOINT_LABEL_MAKE(tag): \\\n      do {\n\n#define CHECKPOINT_MAIN(tag) \\\n      } while (0); \\\n    } \\\n    do {\n\n#define CHECKPOINT_END(tag) \\\n    } while (0); \\\n  } while (0)\n\n#ifdef MRB_USE_DEBUG_HOOK\n#define CODE_FETCH_HOOK(mrb, irep, pc, regs) if ((mrb)->code_fetch_hook) (mrb)->code_fetch_hook((mrb), (irep), (pc), (regs));\n#else\n#define CODE_FETCH_HOOK(mrb, irep, pc, regs)\n#endif\n\n#ifdef MRB_BYTECODE_DECODE_OPTION\n#define BYTECODE_DECODER(x) ((mrb)->bytecode_decoder)?(mrb)->bytecode_decoder((mrb), (x)):(x)\n#else\n#define BYTECODE_DECODER(x) (x)\n#endif\n\n#ifndef MRB_NO_DIRECT_THREADING\n#if defined __GNUC__ || defined __clang__ || defined __INTEL_COMPILER\n#define DIRECT_THREADED\n#endif\n#endif /* ifndef MRB_NO_DIRECT_THREADING */\n\n#ifndef DIRECT_THREADED\n\n#define INIT_DISPATCH for (;;) { insn = BYTECODE_DECODER(*pc); CODE_FETCH_HOOK(mrb, irep, pc, regs); switch (insn) {\n#define CASE(insn,ops) case insn: pc++; FETCH_ ## ops (); mrb->c->ci->pc = pc; L_ ## insn ## _BODY:\n#define NEXT goto L_END_DISPATCH\n#define JUMP NEXT\n#define END_DISPATCH L_END_DISPATCH:;}}\n\n#else\n\n#define INIT_DISPATCH JUMP; return mrb_nil_value();\n#define CASE(insn,ops) L_ ## insn: pc++; FETCH_ ## ops (); mrb->c->ci->pc = pc; L_ ## insn ## _BODY:\n#define NEXT insn=BYTECODE_DECODER(*pc); CODE_FETCH_HOOK(mrb, irep, pc, regs); goto *optable[insn]\n#define JUMP NEXT\n\n#define END_DISPATCH\n\n#endif\n\nMRB_API mrb_value\nmrb_vm_run(mrb_state *mrb, const struct RProc *proc, mrb_value self, mrb_int stack_keep)\n{\n  const mrb_irep *irep = proc->body.irep;\n  mrb_value result;\n  struct mrb_context *c = mrb->c;\n  ptrdiff_t cioff = c->ci - c->cibase;\n  mrb_int nregs = irep->nregs;\n\n  if (!c->stbase) {\n    stack_init(mrb);\n  }\n  if (stack_keep > nregs)\n    nregs = stack_keep;\n  mrb_stack_extend(mrb, nregs);\n  stack_clear(c->ci->stack + stack_keep, nregs - stack_keep);\n  c->ci->stack[0] = self;\n  result = mrb_vm_exec(mrb, proc, irep->iseq);\n  if (mrb->c != c) {\n    if (mrb->c->fib) {\n      mrb_write_barrier(mrb, (struct RBasic*)mrb->c->fib);\n    }\n    mrb->c = c;\n  }\n  else if (c->ci - c->cibase > cioff) {\n    c->ci = c->cibase + cioff;\n  }\n  return result;\n}\n\nstatic struct RClass*\ncheck_target_class(mrb_state *mrb)\n{\n  struct RClass *target = mrb_vm_ci_target_class(mrb->c->ci);\n  if (!target) {\n    mrb_value exc = mrb_exc_new_lit(mrb, E_TYPE_ERROR, \"no target class or module\");\n    mrb_exc_set(mrb, exc);\n  }\n  return target;\n}\n\nstatic mrb_value\nhash_new_from_values(mrb_state *mrb, mrb_int argc, mrb_value *regs)\n{\n  mrb_value hash = mrb_hash_new_capa(mrb, argc);\n  while (argc--) {\n    mrb_hash_set(mrb, hash, regs[0], regs[1]);\n    regs += 2;\n  }\n  return hash;\n}\n\n#define ARGUMENT_NORMALIZE(arg_base, arg_info, insn) do { \\\n  int n = *(arg_info)&0xf; \\\n  int nk = (*(arg_info)>>4)&0xf; \\\n  mrb_int bidx = (arg_base) + mrb_bidx(*(arg_info)); \\\n  if (nk == CALL_MAXARGS) { \\\n    mrb_ensure_hash_type(mrb, regs[(arg_base)+(n==CALL_MAXARGS?1:n)+1]); \\\n  } \\\n  else if (nk > 0) {  /* pack keyword arguments */ \\\n    mrb_int kidx = (arg_base)+(n==CALL_MAXARGS?1:n)+1; \\\n    mrb_value kdict = hash_new_from_values(mrb, nk, regs+kidx); \\\n    regs[kidx] = kdict; \\\n    nk = CALL_MAXARGS; \\\n    *(arg_info) = n | (nk<<4); \\\n  } \\\n  \\\n  mrb_assert(bidx < irep->nregs+(arg_base)); \\\n  mrb_int new_bidx = (arg_base)+mrb_bidx(*(arg_info)); \\\n  if ((insn) == OP_SEND) { \\\n    /* clear block argument */ \\\n    SET_NIL_VALUE(regs[new_bidx]); \\\n    SET_NIL_VALUE(blk); \\\n  } \\\n  else { \\\n    blk = regs[bidx]; \\\n    if (!mrb_nil_p(blk) && !mrb_proc_p(blk)) { \\\n      blk = mrb_type_convert(mrb, blk, MRB_TT_PROC, MRB_SYM(to_proc)); \\\n      /* The stack might have been reallocated during mrb_type_convert(), see #3622 */ \\\n    } \\\n    regs[new_bidx] = blk; \\\n  } \\\n} while (0)\n\nMRB_API mrb_value\nmrb_vm_exec(mrb_state *mrb, const struct RProc *proc, const mrb_code *pc)\n{\n  /* mrb_assert(MRB_PROC_CFUNC_P(proc)) */\n  const mrb_irep *irep = proc->body.irep;\n  const mrb_pool_value *pool = irep->pool;\n  const mrb_sym *syms = irep->syms;\n  mrb_code insn;\n  int ai = mrb_gc_arena_save(mrb);\n  struct mrb_jmpbuf *prev_jmp = mrb->jmp;\n  struct mrb_jmpbuf c_jmp;\n  uint32_t a;\n  uint16_t b;\n  uint16_t c;\n  mrb_sym mid;\n  const struct mrb_irep_catch_handler *ch;\n\n#ifdef DIRECT_THREADED\n  static const void * const optable[] = {\n#define OPCODE(x,_) &&L_OP_ ## x,\n#include \"mruby/ops.h\"\n#undef OPCODE\n  };\n#endif\n\n  mrb_bool exc_catched = FALSE;\nRETRY_TRY_BLOCK:\n\n  MRB_TRY(&c_jmp) {\n\n  if (exc_catched) {\n    exc_catched = FALSE;\n    mrb_gc_arena_restore(mrb, ai);\n    if (mrb->exc && mrb->exc->tt == MRB_TT_BREAK)\n      goto L_BREAK;\n    goto L_RAISE;\n  }\n  mrb->jmp = &c_jmp;\n  mrb_vm_ci_proc_set(mrb->c->ci, proc);\n\n#define regs (mrb->c->ci->stack)\n  INIT_DISPATCH {\n    CASE(OP_NOP, Z) {\n      /* do nothing */\n      NEXT;\n    }\n\n    CASE(OP_MOVE, BB) {\n      regs[a] = regs[b];\n      NEXT;\n    }\n\n    CASE(OP_LOADL, BB) {\n      switch (pool[b].tt) {   /* number */\n      case IREP_TT_INT32:\n        regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i32);\n        break;\n      case IREP_TT_INT64:\n#if defined(MRB_INT64)\n        regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i64);\n        break;\n#else\n#if defined(MRB_64BIT)\n        if (INT32_MIN <= pool[b].u.i64 && pool[b].u.i64 <= INT32_MAX) {\n          regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i64);\n          break;\n        }\n#endif\n        goto L_INT_OVERFLOW;\n#endif\n      case IREP_TT_BIGINT:\n        goto L_INT_OVERFLOW;\n#ifndef MRB_NO_FLOAT\n      case IREP_TT_FLOAT:\n        regs[a] = mrb_float_value(mrb, pool[b].u.f);\n        break;\n#endif\n      default:\n        /* should not happen (tt:string) */\n        regs[a] = mrb_nil_value();\n        break;\n      }\n      NEXT;\n    }\n\n    CASE(OP_LOADI, BB) {\n      SET_FIXNUM_VALUE(regs[a], b);\n      NEXT;\n    }\n\n    CASE(OP_LOADINEG, BB) {\n      SET_FIXNUM_VALUE(regs[a], -b);\n      NEXT;\n    }\n\n    CASE(OP_LOADI__1,B) goto L_LOADI;\n    CASE(OP_LOADI_0,B) goto L_LOADI;\n    CASE(OP_LOADI_1,B) goto L_LOADI;\n    CASE(OP_LOADI_2,B) goto L_LOADI;\n    CASE(OP_LOADI_3,B) goto L_LOADI;\n    CASE(OP_LOADI_4,B) goto L_LOADI;\n    CASE(OP_LOADI_5,B) goto L_LOADI;\n    CASE(OP_LOADI_6,B) goto L_LOADI;\n    CASE(OP_LOADI_7, B) {\n    L_LOADI:\n      SET_FIXNUM_VALUE(regs[a], (mrb_int)insn - (mrb_int)OP_LOADI_0);\n      NEXT;\n    }\n\n    CASE(OP_LOADI16, BS) {\n      SET_FIXNUM_VALUE(regs[a], (mrb_int)(int16_t)b);\n      NEXT;\n    }\n\n    CASE(OP_LOADI32, BSS) {\n      SET_INT_VALUE(mrb, regs[a], (int32_t)(((uint32_t)b<<16)+c));\n      NEXT;\n    }\n\n    CASE(OP_LOADSYM, BB) {\n      SET_SYM_VALUE(regs[a], syms[b]);\n      NEXT;\n    }\n\n    CASE(OP_LOADNIL, B) {\n      SET_NIL_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_LOADSELF, B) {\n      regs[a] = regs[0];\n      NEXT;\n    }\n\n    CASE(OP_LOADT, B) {\n      SET_TRUE_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_LOADF, B) {\n      SET_FALSE_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETGV, BB) {\n      mrb_value val = mrb_gv_get(mrb, syms[b]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETGV, BB) {\n      mrb_gv_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETSV, BB) {\n      mrb_value val = mrb_vm_special_get(mrb, syms[b]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETSV, BB) {\n      mrb_vm_special_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETIV, BB) {\n      regs[a] = mrb_iv_get(mrb, regs[0], syms[b]);\n      NEXT;\n    }\n\n    CASE(OP_SETIV, BB) {\n      mrb_iv_set(mrb, regs[0], syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETCV, BB) {\n      mrb_value val;\n      val = mrb_vm_cv_get(mrb, syms[b]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETCV, BB) {\n      mrb_vm_cv_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETIDX, B) {\n      mrb_value va = regs[a], vb = regs[a+1];\n      switch (mrb_type(va)) {\n      case MRB_TT_ARRAY:\n        if (!mrb_integer_p(vb)) goto getidx_fallback;\n        regs[a] = mrb_ary_entry(va, mrb_integer(vb));\n        break;\n      case MRB_TT_HASH:\n        va = mrb_hash_get(mrb, va, vb);\n        regs[a] = va;\n        break;\n      case MRB_TT_STRING:\n        switch (mrb_type(vb)) {\n        case MRB_TT_INTEGER:\n        case MRB_TT_STRING:\n        case MRB_TT_RANGE:\n          va = mrb_str_aref(mrb, va, vb, mrb_undef_value());\n          regs[a] = va;\n          break;\n        default:\n          goto getidx_fallback;\n        }\n        break;\n      default:\n      getidx_fallback:\n        mid = MRB_OPSYM(aref);\n        goto L_SEND_SYM;\n      }\n      NEXT;\n    }\n\n    CASE(OP_SETIDX, B) {\n      c = 2;\n      mid = MRB_OPSYM(aset);\n      SET_NIL_VALUE(regs[a+3]);\n      goto L_SENDB_SYM;\n    }\n\n    CASE(OP_GETCONST, BB) {\n      mrb_value v = mrb_vm_const_get(mrb, syms[b]);\n      regs[a] = v;\n      NEXT;\n    }\n\n    CASE(OP_SETCONST, BB) {\n      mrb_vm_const_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETMCNST, BB) {\n      mrb_value v = mrb_const_get(mrb, regs[a], syms[b]);\n      regs[a] = v;\n      NEXT;\n    }\n\n    CASE(OP_SETMCNST, BB) {\n      mrb_const_set(mrb, regs[a+1], syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETUPVAR, BBB) {\n      mrb_value *regs_a = regs + a;\n      struct REnv *e = uvenv(mrb, c);\n\n      if (e && b < MRB_ENV_LEN(e)) {\n        *regs_a = e->stack[b];\n      }\n      else {\n        *regs_a = mrb_nil_value();\n      }\n      NEXT;\n    }\n\n    CASE(OP_SETUPVAR, BBB) {\n      struct REnv *e = uvenv(mrb, c);\n\n      if (e) {\n        mrb_value *regs_a = regs + a;\n\n        if (b < MRB_ENV_LEN(e)) {\n          e->stack[b] = *regs_a;\n          mrb_write_barrier(mrb, (struct RBasic*)e);\n        }\n      }\n      NEXT;\n    }\n\n    CASE(OP_JMP, S) {\n      pc += (int16_t)a;\n      JUMP;\n    }\n    CASE(OP_JMPIF, BS) {\n      if (mrb_test(regs[a])) {\n        pc += (int16_t)b;\n        JUMP;\n      }\n      NEXT;\n    }\n    CASE(OP_JMPNOT, BS) {\n      if (!mrb_test(regs[a])) {\n        pc += (int16_t)b;\n        JUMP;\n      }\n      NEXT;\n    }\n    CASE(OP_JMPNIL, BS) {\n      if (mrb_nil_p(regs[a])) {\n        pc += (int16_t)b;\n        JUMP;\n      }\n      NEXT;\n    }\n\n    CASE(OP_JMPUW, S) {\n      a = (uint32_t)((pc - irep->iseq) + (int16_t)a);\n      CHECKPOINT_RESTORE(RBREAK_TAG_JUMP) {\n        struct RBreak *brk = (struct RBreak*)mrb->exc;\n        mrb_value target = mrb_break_value_get(brk);\n        mrb_assert(mrb_integer_p(target));\n        a = (uint32_t)mrb_integer(target);\n        mrb_assert(a >= 0 && a < irep->ilen);\n      }\n      CHECKPOINT_MAIN(RBREAK_TAG_JUMP) {\n        ch = catch_handler_find(mrb, mrb->c->ci, pc, MRB_CATCH_FILTER_ENSURE);\n        if (ch) {\n          /* avoiding a jump from a catch handler into the same handler */\n          if (a < mrb_irep_catch_handler_unpack(ch->begin) || a >= mrb_irep_catch_handler_unpack(ch->end)) {\n            THROW_TAGGED_BREAK(mrb, RBREAK_TAG_JUMP, proc, mrb_fixnum_value(a));\n          }\n        }\n      }\n      CHECKPOINT_END(RBREAK_TAG_JUMP);\n\n      mrb->exc = NULL; /* clear break object */\n      pc = irep->iseq + a;\n      JUMP;\n    }\n\n    CASE(OP_EXCEPT, B) {\n      mrb_value exc;\n\n      if (mrb->exc == NULL) {\n        exc = mrb_nil_value();\n      }\n      else {\n        switch (mrb->exc->tt) {\n        case MRB_TT_BREAK:\n        case MRB_TT_EXCEPTION:\n          exc = mrb_obj_value(mrb->exc);\n          break;\n        default:\n          mrb_assert(!\"bad mrb_type\");\n          exc = mrb_nil_value();\n          break;\n        }\n        mrb->exc = NULL;\n      }\n      regs[a] = exc;\n      NEXT;\n    }\n    CASE(OP_RESCUE, BB) {\n      mrb_value exc = regs[a];  /* exc on stack */\n      mrb_value e = regs[b];\n      struct RClass *ec;\n\n      switch (mrb_type(e)) {\n      case MRB_TT_CLASS:\n      case MRB_TT_MODULE:\n        break;\n      default:\n        {\n          mrb_value exc;\n\n          exc = mrb_exc_new_lit(mrb, E_TYPE_ERROR,\n                                    \"class or module required for rescue clause\");\n          mrb_exc_set(mrb, exc);\n          goto L_RAISE;\n        }\n      }\n      ec = mrb_class_ptr(e);\n      regs[b] = mrb_bool_value(mrb_obj_is_kind_of(mrb, exc, ec));\n      NEXT;\n    }\n\n    CASE(OP_RAISEIF, B) {\n      mrb_value exc = regs[a];\n      if (mrb_break_p(exc)) {\n        mrb->exc = mrb_obj_ptr(exc);\n        goto L_BREAK;\n      }\n      mrb_exc_set(mrb, exc);\n      if (mrb->exc) {\n        goto L_RAISE;\n      }\n      NEXT;\n    }\n\n    CASE(OP_SSEND, BBB) {\n      regs[a] = regs[0];\n      insn = OP_SEND;\n    }\n    goto L_SENDB;\n\n    CASE(OP_SSENDB, BBB) {\n      regs[a] = regs[0];\n    }\n    goto L_SENDB;\n\n    CASE(OP_SEND, BBB)\n    goto L_SENDB;\n\n    L_SEND_SYM:\n    c = 1;\n    /* push nil after arguments */\n    SET_NIL_VALUE(regs[a+2]);\n    goto L_SENDB_SYM;\n\n    CASE(OP_SENDB, BBB)\n    L_SENDB:\n    mid = syms[b];\n    L_SENDB_SYM:\n    {\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_method_t m;\n      struct RClass *cls;\n      mrb_value recv, blk;\n\n      ARGUMENT_NORMALIZE(a, &c, insn);\n\n      recv = regs[a];\n      cls = mrb_class(mrb, recv);\n      m = mrb_method_search_vm(mrb, &cls, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        m = prepare_missing(mrb, recv, mid, &cls, a, &c, blk, 0);\n        mid = MRB_SYM(method_missing);\n      }\n\n      /* push callinfo */\n      ci = cipush(mrb, a, 0, cls, NULL, mid, c);\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        if (MRB_METHOD_PROC_P(m)) {\n          struct RProc *p = MRB_METHOD_PROC(m);\n\n          mrb_vm_ci_proc_set(ci, p);\n          recv = p->body.func(mrb, recv);\n        }\n        else {\n          if (MRB_METHOD_NOARG_P(m)) {\n            check_method_noarg(mrb, ci);\n          }\n          recv = MRB_METHOD_FUNC(m)(mrb, recv);\n        }\n        mrb_gc_arena_shrink(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        ci = mrb->c->ci;\n        if (mrb_proc_p(blk)) {\n          struct RProc *p = mrb_proc_ptr(blk);\n          if (p && !MRB_PROC_STRICT_P(p) && MRB_PROC_ENV(p) == mrb_vm_ci_env(&ci[-1])) {\n            p->flags |= MRB_PROC_ORPHAN;\n          }\n        }\n        if (!ci->u.target_class) { /* return from context modifying method (resume/yield) */\n          if (ci->cci == CINFO_RESUMED) {\n            mrb->jmp = prev_jmp;\n            return recv;\n          }\n          else {\n            mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n            proc = ci[-1].proc;\n            irep = proc->body.irep;\n            pool = irep->pool;\n            syms = irep->syms;\n          }\n        }\n        ci->stack[0] = recv;\n        /* pop stackpos */\n        ci = cipop(mrb);\n        pc = ci->pc;\n      }\n      else {\n        /* setup environment for calling method */\n        mrb_vm_ci_proc_set(ci, (proc = MRB_METHOD_PROC(m)));\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        mrb_stack_extend(mrb, (irep->nregs < 4) ? 4 : irep->nregs);\n        pc = irep->iseq;\n      }\n    }\n    JUMP;\n\n    CASE(OP_CALL, Z) {\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_value recv = ci->stack[0];\n      struct RProc *m = mrb_proc_ptr(recv);\n\n      /* replace callinfo */\n      ci->u.target_class = MRB_PROC_TARGET_CLASS(m);\n      mrb_vm_ci_proc_set(ci, m);\n      if (MRB_PROC_ENV_P(m)) {\n        ci->mid = MRB_PROC_ENV(m)->mid;\n      }\n\n      /* prepare stack */\n      if (MRB_PROC_CFUNC_P(m)) {\n        recv = MRB_PROC_CFUNC(m)(mrb, recv);\n        mrb_gc_arena_shrink(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        /* pop stackpos */\n        ci = cipop(mrb);\n        pc = ci->pc;\n        ci[1].stack[0] = recv;\n        irep = mrb->c->ci->proc->body.irep;\n      }\n      else {\n        /* setup environment for calling method */\n        proc = m;\n        irep = m->body.irep;\n        if (!irep) {\n          mrb->c->ci->stack[0] = mrb_nil_value();\n          a = 0;\n          c = OP_R_NORMAL;\n          goto L_OP_RETURN_BODY;\n        }\n        mrb_int nargs = mrb_ci_bidx(ci)+1;\n        if (nargs < irep->nregs) {\n          mrb_stack_extend(mrb, irep->nregs);\n          stack_clear(regs+nargs, irep->nregs-nargs);\n        }\n        if (MRB_PROC_ENV_P(m)) {\n          regs[0] = MRB_PROC_ENV(m)->stack[0];\n        }\n        pc = irep->iseq;\n      }\n      pool = irep->pool;\n      syms = irep->syms;\n      JUMP;\n    }\n\n    CASE(OP_SUPER, BB) {\n      mrb_method_t m;\n      struct RClass *cls;\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_value recv, blk;\n      const struct RProc *p = ci->proc;\n      mrb_sym mid = ci->mid;\n      struct RClass* target_class = MRB_PROC_TARGET_CLASS(p);\n\n      if (MRB_PROC_ENV_P(p) && p->e.env->mid && p->e.env->mid != mid) { /* alias support */\n        mid = p->e.env->mid;    /* restore old mid */\n      }\n\n      if (mid == 0 || !target_class) {\n        mrb_value exc = mrb_exc_new_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if (target_class->flags & MRB_FL_CLASS_IS_PREPENDED) {\n        target_class = mrb_vm_ci_target_class(ci);\n      }\n      else if (target_class->tt == MRB_TT_MODULE) {\n        target_class = mrb_vm_ci_target_class(ci);\n        if (!target_class || target_class->tt != MRB_TT_ICLASS) {\n          goto super_typeerror;\n        }\n      }\n      recv = regs[0];\n      if (!mrb_obj_is_kind_of(mrb, recv, target_class)) {\n      super_typeerror: ;\n        mrb_value exc = mrb_exc_new_lit(mrb, E_TYPE_ERROR,\n                                            \"self has wrong type to call super in this context\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n\n      ARGUMENT_NORMALIZE(a, &b, OP_SUPER);\n\n      cls = target_class->super;\n      m = mrb_method_search_vm(mrb, &cls, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        m = prepare_missing(mrb, recv, mid, &cls, a, &b, blk, 1);\n        mid = MRB_SYM(method_missing);\n      }\n\n      /* push callinfo */\n      ci = cipush(mrb, a, 0, cls, NULL, mid, b);\n\n      /* prepare stack */\n      ci->stack[0] = recv;\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        mrb_value v;\n\n        if (MRB_METHOD_PROC_P(m)) {\n          mrb_vm_ci_proc_set(ci, MRB_METHOD_PROC(m));\n        }\n        v = MRB_METHOD_CFUNC(m)(mrb, recv);\n        mrb_gc_arena_restore(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        ci = mrb->c->ci;\n        mrb_assert(!mrb_break_p(v));\n        if (!mrb_vm_ci_target_class(ci)) { /* return from context modifying method (resume/yield) */\n          if (ci->cci == CINFO_RESUMED) {\n            mrb->jmp = prev_jmp;\n            return v;\n          }\n          else {\n            mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n            proc = ci[-1].proc;\n            irep = proc->body.irep;\n            pool = irep->pool;\n            syms = irep->syms;\n          }\n        }\n        mrb->c->ci->stack[0] = v;\n        ci = cipop(mrb);\n        pc = ci->pc;\n      }\n      else {\n        /* setup environment for calling method */\n        mrb_vm_ci_proc_set(ci, (proc = MRB_METHOD_PROC(m)));\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        mrb_stack_extend(mrb, (irep->nregs < 4) ? 4 : irep->nregs);\n        pc = irep->iseq;\n      }\n      JUMP;\n    }\n\n    CASE(OP_ARGARY, BS) {\n      mrb_int m1 = (b>>11)&0x3f;\n      mrb_int r  = (b>>10)&0x1;\n      mrb_int m2 = (b>>5)&0x1f;\n      mrb_int kd = (b>>4)&0x1;\n      mrb_int lv = (b>>0)&0xf;\n      mrb_value *stack;\n\n      if (mrb->c->ci->mid == 0 || mrb_vm_ci_target_class(mrb->c->ci) == NULL) {\n        mrb_value exc;\n\n      L_NOSUPER:\n        exc = mrb_exc_new_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if (lv == 0) stack = regs + 1;\n      else {\n        struct REnv *e = uvenv(mrb, lv-1);\n        if (!e) goto L_NOSUPER;\n        if (MRB_ENV_LEN(e) <= m1+r+m2+1)\n          goto L_NOSUPER;\n        stack = e->stack + 1;\n      }\n      if (r == 0) {\n        regs[a] = mrb_ary_new_from_values(mrb, m1+m2, stack);\n      }\n      else {\n        mrb_value *pp = NULL;\n        struct RArray *rest;\n        mrb_int len = 0;\n\n        if (mrb_array_p(stack[m1])) {\n          struct RArray *ary = mrb_ary_ptr(stack[m1]);\n\n          pp = ARY_PTR(ary);\n          len = ARY_LEN(ary);\n        }\n        regs[a] = mrb_ary_new_capa(mrb, m1+len+m2);\n        rest = mrb_ary_ptr(regs[a]);\n        if (m1 > 0) {\n          stack_copy(ARY_PTR(rest), stack, m1);\n        }\n        if (len > 0) {\n          stack_copy(ARY_PTR(rest)+m1, pp, len);\n        }\n        if (m2 > 0) {\n          stack_copy(ARY_PTR(rest)+m1+len, stack+m1+1, m2);\n        }\n        ARY_SET_LEN(rest, m1+len+m2);\n      }\n      if (kd) {\n        regs[a+1] = stack[m1+r+m2];\n        regs[a+2] = stack[m1+r+m2+1];\n      }\n      else {\n        regs[a+1] = stack[m1+r+m2];\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ENTER, W) {\n      mrb_int m1 = MRB_ASPEC_REQ(a);\n      mrb_int o  = MRB_ASPEC_OPT(a);\n      mrb_int r  = MRB_ASPEC_REST(a);\n      mrb_int m2 = MRB_ASPEC_POST(a);\n      mrb_int kd = (MRB_ASPEC_KEY(a) > 0 || MRB_ASPEC_KDICT(a))? 1 : 0;\n      /* unused\n      int b  = MRB_ASPEC_BLOCK(a);\n      */\n      mrb_int const len = m1 + o + r + m2;\n\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_int argc = ci->n;\n      mrb_value *argv = regs+1;\n      mrb_value * const argv0 = argv;\n      mrb_int const kw_pos = len + kd;    /* where kwhash should be */\n      mrb_int const blk_pos = kw_pos + 1; /* where block should be */\n      mrb_value blk = regs[mrb_ci_bidx(ci)];\n      mrb_value kdict = mrb_nil_value();\n\n      /* keyword arguments */\n      if (ci->nk > 0) {\n        mrb_int kidx = mrb_ci_kidx(ci);\n        kdict = regs[kidx];\n        if (!mrb_hash_p(kdict) || mrb_hash_size(mrb, kdict) == 0) {\n          kdict = mrb_nil_value();\n          ci->nk = 0;\n        }\n      }\n      if (!kd && !mrb_nil_p(kdict)) {\n        if (argc < 14) {\n          ci->n++;\n          argc++;    /* include kdict in normal arguments */\n        }\n        else if (argc == 14) {\n          /* pack arguments and kdict */\n          regs[1] = mrb_ary_new_from_values(mrb, argc+1, &regs[1]);\n          argc = ci->n = 15;\n        }\n        else {/* argc == 15 */\n          /* push kdict to packed arguments */\n          mrb_ary_push(mrb, regs[1], regs[2]);\n        }\n        ci->nk = 0;\n      }\n      if (kd && MRB_ASPEC_KEY(a) > 0 && mrb_hash_p(kdict)) {\n        kdict = mrb_hash_dup(mrb, kdict);\n      }\n\n      /* arguments is passed with Array */\n      if (argc == 15) {\n        struct RArray *ary = mrb_ary_ptr(regs[1]);\n        argv = ARY_PTR(ary);\n        argc = (int)ARY_LEN(ary);\n        mrb_gc_protect(mrb, regs[1]);\n      }\n\n      /* strict argument check */\n      if (ci->proc && MRB_PROC_STRICT_P(ci->proc)) {\n        if (argc < m1 + m2 || (r == 0 && argc > len)) {\n          argnum_error(mrb, m1+m2);\n          goto L_RAISE;\n        }\n      }\n      /* extract first argument array to arguments */\n      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {\n        mrb_gc_protect(mrb, argv[0]);\n        argc = (int)RARRAY_LEN(argv[0]);\n        argv = RARRAY_PTR(argv[0]);\n      }\n\n      /* rest arguments */\n      mrb_value rest = mrb_nil_value();\n      if (argc < len) {\n        mrb_int mlen = m2;\n        if (argc < m1+m2) {\n          mlen = m1 < argc ? argc - m1 : 0;\n        }\n\n        /* copy mandatory and optional arguments */\n        if (argv0 != argv && argv) {\n          value_move(&regs[1], argv, argc-mlen); /* m1 + o */\n        }\n        if (argc < m1) {\n          stack_clear(&regs[argc+1], m1-argc);\n        }\n        /* copy post mandatory arguments */\n        if (mlen) {\n          value_move(&regs[len-m2+1], &argv[argc-mlen], mlen);\n        }\n        if (mlen < m2) {\n          stack_clear(&regs[len-m2+mlen+1], m2-mlen);\n        }\n        /* initialize rest arguments with empty Array */\n        if (r) {\n          rest = mrb_ary_new_capa(mrb, 0);\n          regs[m1+o+1] = rest;\n        }\n        /* skip initializer of passed arguments */\n        if (o > 0 && argc > m1+m2)\n          pc += (argc - m1 - m2)*3;\n      }\n      else {\n        mrb_int rnum = 0;\n        if (argv0 != argv) {\n          value_move(&regs[1], argv, m1+o);\n        }\n        if (r) {\n          rnum = argc-m1-o-m2;\n          rest = mrb_ary_new_from_values(mrb, rnum, argv+m1+o);\n          regs[m1+o+1] = rest;\n        }\n        if (m2 > 0 && argc-m2 > m1) {\n          value_move(&regs[m1+o+r+1], &argv[m1+o+rnum], m2);\n        }\n        pc += o*3;\n      }\n\n      /* need to be update blk first to protect blk from GC */\n      regs[blk_pos] = blk;              /* move block */\n      if (kd) {\n        if (mrb_nil_p(kdict))\n          kdict = mrb_hash_new_capa(mrb, 0);\n        regs[kw_pos] = kdict;           /* set kwhash */\n      }\n\n      /* format arguments for generated code */\n      mrb->c->ci->n = len;\n\n      /* clear local (but non-argument) variables */\n      if (irep->nlocals-blk_pos-1 > 0) {\n        stack_clear(&regs[blk_pos+1], irep->nlocals-blk_pos-1);\n      }\n      JUMP;\n    }\n\n    CASE(OP_KARG, BB) {\n      mrb_value k = mrb_symbol_value(syms[b]);\n      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n      mrb_value kdict, v;\n\n      if (kidx < 0 || !mrb_hash_p(kdict=regs[kidx]) || !mrb_hash_key_p(mrb, kdict, k)) {\n        mrb_value str = mrb_format(mrb, \"missing keyword: %v\", k);\n        mrb_exc_set(mrb, mrb_exc_new_str(mrb, E_ARGUMENT_ERROR, str));\n        goto L_RAISE;\n      }\n      v = mrb_hash_get(mrb, kdict, k);\n      regs[a] = v;\n      mrb_hash_delete_key(mrb, kdict, k);\n      NEXT;\n    }\n\n    CASE(OP_KEY_P, BB) {\n      mrb_value k = mrb_symbol_value(syms[b]);\n      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n      mrb_value kdict;\n      mrb_bool key_p = FALSE;\n\n      if (kidx >= 0 && mrb_hash_p(kdict=regs[kidx])) {\n        key_p = mrb_hash_key_p(mrb, kdict, k);\n      }\n      regs[a] = mrb_bool_value(key_p);\n      NEXT;\n    }\n\n    CASE(OP_KEYEND, Z) {\n      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n      mrb_value kdict;\n\n      if (kidx >= 0 && mrb_hash_p(kdict=regs[kidx]) && !mrb_hash_empty_p(mrb, kdict)) {\n        mrb_value keys = mrb_hash_keys(mrb, kdict);\n        mrb_value key1 = RARRAY_PTR(keys)[0];\n        mrb_value str = mrb_format(mrb, \"unknown keyword: %v\", key1);\n        mrb_exc_set(mrb, mrb_exc_new_str(mrb, E_ARGUMENT_ERROR, str));\n        goto L_RAISE;\n      }\n      NEXT;\n    }\n\n    CASE(OP_BREAK, B) {\n      c = OP_R_BREAK;\n      goto L_RETURN;\n    }\n    CASE(OP_RETURN_BLK, B) {\n      c = OP_R_RETURN;\n      goto L_RETURN;\n    }\n    CASE(OP_RETURN, B)\n    c = OP_R_NORMAL;\n    L_RETURN:\n    {\n      mrb_callinfo *ci;\n\n      ci = mrb->c->ci;\n      if (ci->mid) {\n        mrb_value blk = regs[mrb_ci_bidx(ci)];\n\n        if (mrb_proc_p(blk)) {\n          struct RProc *p = mrb_proc_ptr(blk);\n\n          if (!MRB_PROC_STRICT_P(p) &&\n              ci > mrb->c->cibase && MRB_PROC_ENV(p) == mrb_vm_ci_env(&ci[-1])) {\n            p->flags |= MRB_PROC_ORPHAN;\n          }\n        }\n      }\n\n      if (mrb->exc) {\n      L_RAISE:\n        ci = mrb->c->ci;\n        if (ci == mrb->c->cibase) {\n          ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL);\n          if (ch == NULL) goto L_FTOP;\n          goto L_CATCH;\n        }\n        while ((ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL)) == NULL) {\n          ci = cipop(mrb);\n          if (ci[1].cci == CINFO_SKIP && prev_jmp) {\n            mrb->jmp = prev_jmp;\n            MRB_THROW(prev_jmp);\n          }\n          pc = ci[0].pc;\n          if (ci == mrb->c->cibase) {\n            ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL);\n            if (ch == NULL) {\n            L_FTOP:             /* fiber top */\n              if (mrb->c == mrb->root_c) {\n                mrb->c->ci->stack = mrb->c->stbase;\n                goto L_STOP;\n              }\n              else {\n                struct mrb_context *c = mrb->c;\n\n                c->status = MRB_FIBER_TERMINATED;\n                mrb->c = c->prev;\n                c->prev = NULL;\n                goto L_RAISE;\n              }\n            }\n            break;\n          }\n        }\n      L_CATCH:\n        if (ch == NULL) goto L_STOP;\n        if (FALSE) {\n        L_CATCH_TAGGED_BREAK: /* from THROW_TAGGED_BREAK() or UNWIND_ENSURE() */\n          ci = mrb->c->ci;\n        }\n        proc = ci->proc;\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        mrb_stack_extend(mrb, irep->nregs);\n        pc = irep->iseq + mrb_irep_catch_handler_unpack(ch->target);\n      }\n      else {\n        mrb_int acc;\n        mrb_value v;\n\n        ci = mrb->c->ci;\n        v = regs[a];\n        mrb_gc_protect(mrb, v);\n        switch (c) {\n        case OP_R_RETURN:\n          /* Fall through to OP_R_NORMAL otherwise */\n          if (ci->cci == CINFO_NONE && MRB_PROC_ENV_P(proc) && !MRB_PROC_STRICT_P(proc)) {\n            const struct RProc *dst;\n            mrb_callinfo *cibase;\n            cibase = mrb->c->cibase;\n            dst = top_proc(mrb, proc);\n\n            if (MRB_PROC_ENV_P(dst)) {\n              struct REnv *e = MRB_PROC_ENV(dst);\n\n              if (!MRB_ENV_ONSTACK_P(e) || (e->cxt && e->cxt != mrb->c)) {\n                localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                goto L_RAISE;\n              }\n            }\n            /* check jump destination */\n            while (cibase <= ci && ci->proc != dst) {\n              if (ci->cci > CINFO_NONE) { /* jump cross C boundary */\n                localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                goto L_RAISE;\n              }\n              ci--;\n            }\n            if (ci <= cibase) { /* no jump destination */\n              localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n              goto L_RAISE;\n            }\n            ci = mrb->c->ci;\n            while (cibase <= ci && ci->proc != dst) {\n              CHECKPOINT_RESTORE(RBREAK_TAG_RETURN_BLOCK) {\n                cibase = mrb->c->cibase;\n                dst = top_proc(mrb, proc);\n              }\n              CHECKPOINT_MAIN(RBREAK_TAG_RETURN_BLOCK) {\n                UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN_BLOCK, proc, v);\n              }\n              CHECKPOINT_END(RBREAK_TAG_RETURN_BLOCK);\n              ci = cipop(mrb);\n              pc = ci->pc;\n            }\n            proc = ci->proc;\n            mrb->exc = NULL; /* clear break object */\n            break;\n          }\n          /* fallthrough */\n        case OP_R_NORMAL:\n        NORMAL_RETURN:\n          if (ci == mrb->c->cibase) {\n            struct mrb_context *c;\n            c = mrb->c;\n\n            if (!c->prev) { /* toplevel return */\n              regs[irep->nlocals] = v;\n              goto CHECKPOINT_LABEL_MAKE(RBREAK_TAG_STOP);\n            }\n            if (!c->vmexec && c->prev->ci == c->prev->cibase) {\n              mrb_value exc = mrb_exc_new_lit(mrb, E_FIBER_ERROR, \"double resume\");\n              mrb_exc_set(mrb, exc);\n              goto L_RAISE;\n            }\n            CHECKPOINT_RESTORE(RBREAK_TAG_RETURN_TOPLEVEL) {\n              c = mrb->c;\n            }\n            CHECKPOINT_MAIN(RBREAK_TAG_RETURN_TOPLEVEL) {\n              UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN_TOPLEVEL, proc, v);\n            }\n            CHECKPOINT_END(RBREAK_TAG_RETURN_TOPLEVEL);\n            /* automatic yield at the end */\n            c->status = MRB_FIBER_TERMINATED;\n            mrb->c = c->prev;\n            mrb->c->status = MRB_FIBER_RUNNING;\n            c->prev = NULL;\n            if (c->vmexec) {\n              mrb_gc_arena_restore(mrb, ai);\n              c->vmexec = FALSE;\n              mrb->jmp = prev_jmp;\n              return v;\n            }\n            ci = mrb->c->ci;\n          }\n          CHECKPOINT_RESTORE(RBREAK_TAG_RETURN) {\n            /* do nothing */\n          }\n          CHECKPOINT_MAIN(RBREAK_TAG_RETURN) {\n            UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN, proc, v);\n          }\n          CHECKPOINT_END(RBREAK_TAG_RETURN);\n          mrb->exc = NULL; /* clear break object */\n          break;\n        case OP_R_BREAK:\n          if (MRB_PROC_STRICT_P(proc)) goto NORMAL_RETURN;\n          if (MRB_PROC_ORPHAN_P(proc)) {\n            mrb_value exc;\n\n          L_BREAK_ERROR:\n            exc = mrb_exc_new_lit(mrb, E_LOCALJUMP_ERROR,\n                                      \"break from proc-closure\");\n            mrb_exc_set(mrb, exc);\n            goto L_RAISE;\n          }\n          if (!MRB_PROC_ENV_P(proc) || !MRB_ENV_ONSTACK_P(MRB_PROC_ENV(proc))) {\n            goto L_BREAK_ERROR;\n          }\n          else {\n            struct REnv *e = MRB_PROC_ENV(proc);\n\n            if (e->cxt != mrb->c) {\n              goto L_BREAK_ERROR;\n            }\n          }\n          CHECKPOINT_RESTORE(RBREAK_TAG_BREAK) {\n            /* do nothing */\n          }\n          CHECKPOINT_MAIN(RBREAK_TAG_BREAK) {\n            UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK, proc, v);\n          }\n          CHECKPOINT_END(RBREAK_TAG_BREAK);\n          /* break from fiber block */\n          if (ci == mrb->c->cibase && ci->pc) {\n            struct mrb_context *c = mrb->c;\n\n            mrb->c = c->prev;\n            c->prev = NULL;\n            ci = mrb->c->ci;\n          }\n          if (ci->cci > CINFO_NONE) {\n            ci = cipop(mrb);\n            mrb_gc_arena_restore(mrb, ai);\n            mrb->c->vmexec = FALSE;\n            mrb->exc = (struct RObject*)break_new(mrb, RBREAK_TAG_BREAK, proc, v);\n            mrb->jmp = prev_jmp;\n            MRB_THROW(prev_jmp);\n          }\n          if (FALSE) {\n            struct RBreak *brk;\n\n          L_BREAK:\n            brk = (struct RBreak*)mrb->exc;\n            proc = mrb_break_proc_get(brk);\n            v = mrb_break_value_get(brk);\n            ci = mrb->c->ci;\n\n            switch (mrb_break_tag_get(brk)) {\n#define DISPATCH_CHECKPOINTS(n, i) case n: goto CHECKPOINT_LABEL_MAKE(n);\n              RBREAK_TAG_FOREACH(DISPATCH_CHECKPOINTS)\n#undef DISPATCH_CHECKPOINTS\n              default:\n                mrb_assert(!\"wrong break tag\");\n            }\n          }\n          while (mrb->c->cibase < ci && ci[-1].proc != proc->upper) {\n            if (ci[-1].cci == CINFO_SKIP) {\n              goto L_BREAK_ERROR;\n            }\n            CHECKPOINT_RESTORE(RBREAK_TAG_BREAK_UPPER) {\n              /* do nothing */\n            }\n            CHECKPOINT_MAIN(RBREAK_TAG_BREAK_UPPER) {\n              UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK_UPPER, proc, v);\n            }\n            CHECKPOINT_END(RBREAK_TAG_BREAK_UPPER);\n            ci = cipop(mrb);\n            pc = ci->pc;\n          }\n          CHECKPOINT_RESTORE(RBREAK_TAG_BREAK_INTARGET) {\n            /* do nothing */\n          }\n          CHECKPOINT_MAIN(RBREAK_TAG_BREAK_INTARGET) {\n            UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK_INTARGET, proc, v);\n          }\n          CHECKPOINT_END(RBREAK_TAG_BREAK_INTARGET);\n          if (ci == mrb->c->cibase) {\n            goto L_BREAK_ERROR;\n          }\n          mrb->exc = NULL; /* clear break object */\n          break;\n        default:\n          /* cannot happen */\n          break;\n        }\n        mrb_assert(ci == mrb->c->ci);\n        mrb_assert(mrb->exc == NULL);\n\n        if (mrb->c->vmexec && !mrb_vm_ci_target_class(ci)) {\n          mrb_gc_arena_restore(mrb, ai);\n          mrb->c->vmexec = FALSE;\n          mrb->jmp = prev_jmp;\n          return v;\n        }\n        acc = ci->cci;\n        ci = cipop(mrb);\n        if (acc == CINFO_SKIP || acc == CINFO_DIRECT) {\n          mrb_gc_arena_restore(mrb, ai);\n          mrb->jmp = prev_jmp;\n          return v;\n        }\n        pc = ci->pc;\n        DEBUG(fprintf(stderr, \"from :%s\\n\", mrb_sym_name(mrb, ci->mid)));\n        proc = ci->proc;\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n\n        ci[1].stack[0] = v;\n        mrb_gc_arena_restore(mrb, ai);\n      }\n      JUMP;\n    }\n\n    CASE(OP_BLKPUSH, BS) {\n      int m1 = (b>>11)&0x3f;\n      int r  = (b>>10)&0x1;\n      int m2 = (b>>5)&0x1f;\n      int kd = (b>>4)&0x1;\n      int lv = (b>>0)&0xf;\n      mrb_value *stack;\n\n      if (lv == 0) stack = regs + 1;\n      else {\n        struct REnv *e = uvenv(mrb, lv-1);\n        if (!e || (!MRB_ENV_ONSTACK_P(e) && e->mid == 0) ||\n            MRB_ENV_LEN(e) <= m1+r+m2+1) {\n          localjump_error(mrb, LOCALJUMP_ERROR_YIELD);\n          goto L_RAISE;\n        }\n        stack = e->stack + 1;\n      }\n      if (mrb_nil_p(stack[m1+r+m2+kd])) {\n        localjump_error(mrb, LOCALJUMP_ERROR_YIELD);\n        goto L_RAISE;\n      }\n      regs[a] = stack[m1+r+m2+kd];\n      NEXT;\n    }\n\n  L_INT_OVERFLOW:\n    {\n      mrb_value exc = mrb_exc_new_lit(mrb, E_RANGE_ERROR, \"integer overflow\");\n      mrb_exc_set(mrb, exc);\n    }\n    goto L_RAISE;\n\n#define TYPES2(a,b) ((((uint16_t)(a))<<8)|(((uint16_t)(b))&0xff))\n#define OP_MATH(op_name)                                                    \\\n  /* need to check if op is overridden */                                   \\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {                  \\\n    OP_MATH_CASE_INTEGER(op_name);                                          \\\n    OP_MATH_CASE_FLOAT(op_name, integer, float);                            \\\n    OP_MATH_CASE_FLOAT(op_name, float,  integer);                           \\\n    OP_MATH_CASE_FLOAT(op_name, float,  float);                             \\\n    OP_MATH_CASE_STRING_##op_name();                                        \\\n    default:                                                                \\\n      mid = MRB_OPSYM(op_name);                                             \\\n      goto L_SEND_SYM;                                                      \\\n  }                                                                         \\\n  NEXT;\n#define OP_MATH_CASE_INTEGER(op_name)                                       \\\n  case TYPES2(MRB_TT_INTEGER, MRB_TT_INTEGER):                              \\\n    {                                                                       \\\n      mrb_int x = mrb_integer(regs[a]), y = mrb_integer(regs[a+1]), z;      \\\n      if (mrb_int_##op_name##_overflow(x, y, &z))                           \\\n        OP_MATH_OVERFLOW_INT();                                             \\\n      else                                                                  \\\n        SET_INT_VALUE(mrb,regs[a], z);                                      \\\n    }                                                                       \\\n    break\n#ifdef MRB_NO_FLOAT\n#define OP_MATH_CASE_FLOAT(op_name, t1, t2) (void)0\n#else\n#define OP_MATH_CASE_FLOAT(op_name, t1, t2)                                     \\\n  case TYPES2(OP_MATH_TT_##t1, OP_MATH_TT_##t2):                                \\\n    {                                                                           \\\n      mrb_float z = mrb_##t1(regs[a]) OP_MATH_OP_##op_name mrb_##t2(regs[a+1]); \\\n      SET_FLOAT_VALUE(mrb, regs[a], z);                                         \\\n    }                                                                           \\\n    break\n#endif\n#define OP_MATH_OVERFLOW_INT() goto L_INT_OVERFLOW\n#define OP_MATH_CASE_STRING_add()                                           \\\n  case TYPES2(MRB_TT_STRING, MRB_TT_STRING):                                \\\n    regs[a] = mrb_str_plus(mrb, regs[a], regs[a+1]);                        \\\n    mrb_gc_arena_restore(mrb, ai);                                          \\\n    break\n#define OP_MATH_CASE_STRING_sub() (void)0\n#define OP_MATH_CASE_STRING_mul() (void)0\n#define OP_MATH_OP_add +\n#define OP_MATH_OP_sub -\n#define OP_MATH_OP_mul *\n#define OP_MATH_TT_integer MRB_TT_INTEGER\n#define OP_MATH_TT_float   MRB_TT_FLOAT\n\n    CASE(OP_ADD, B) {\n      OP_MATH(add);\n    }\n\n    CASE(OP_SUB, B) {\n      OP_MATH(sub);\n    }\n\n    CASE(OP_MUL, B) {\n      OP_MATH(mul);\n    }\n\n    CASE(OP_DIV, B) {\n#ifndef MRB_NO_FLOAT\n      mrb_float x, y, f;\n#endif\n\n      /* need to check if op is overridden */\n      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\n      case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\n        {\n          mrb_int x = mrb_integer(regs[a]);\n          mrb_int y = mrb_integer(regs[a+1]);\n          mrb_int div = mrb_div_int(mrb, x, y);\n          SET_INT_VALUE(mrb, regs[a], div);\n        }\n        NEXT;\n#ifndef MRB_NO_FLOAT\n      case TYPES2(MRB_TT_INTEGER,MRB_TT_FLOAT):\n        x = (mrb_float)mrb_integer(regs[a]);\n        y = mrb_float(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_INTEGER):\n        x = mrb_float(regs[a]);\n        y = (mrb_float)mrb_integer(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\n        x = mrb_float(regs[a]);\n        y = mrb_float(regs[a+1]);\n        break;\n#endif\n      default:\n        mid = MRB_OPSYM(div);\n        goto L_SEND_SYM;\n      }\n\n#ifndef MRB_NO_FLOAT\n      f = mrb_div_float(x, y);\n      SET_FLOAT_VALUE(mrb, regs[a], f);\n#endif\n      NEXT;\n    }\n\n#define OP_MATHI(op_name)                                                   \\\n  /* need to check if op is overridden */                                   \\\n  switch (mrb_type(regs[a])) {                                              \\\n    OP_MATHI_CASE_INTEGER(op_name);                                         \\\n    OP_MATHI_CASE_FLOAT(op_name);                                           \\\n    default:                                                                \\\n      SET_INT_VALUE(mrb,regs[a+1], b);                                      \\\n      mid = MRB_OPSYM(op_name);                                             \\\n      goto L_SEND_SYM;                                                      \\\n  }                                                                         \\\n  NEXT;\n#define OP_MATHI_CASE_INTEGER(op_name)                                      \\\n  case MRB_TT_INTEGER:                                                      \\\n    {                                                                       \\\n      mrb_int x = mrb_integer(regs[a]), y = (mrb_int)b, z;                  \\\n      if (mrb_int_##op_name##_overflow(x, y, &z))                           \\\n        OP_MATH_OVERFLOW_INT();                                             \\\n      else                                                                  \\\n        SET_INT_VALUE(mrb,regs[a], z);                                      \\\n    }                                                                       \\\n    break\n#ifdef MRB_NO_FLOAT\n#define OP_MATHI_CASE_FLOAT(op_name) (void)0\n#else\n#define OP_MATHI_CASE_FLOAT(op_name)                                        \\\n  case MRB_TT_FLOAT:                                                        \\\n    {                                                                       \\\n      mrb_float z = mrb_float(regs[a]) OP_MATH_OP_##op_name b;              \\\n      SET_FLOAT_VALUE(mrb, regs[a], z);                                     \\\n    }                                                                       \\\n    break\n#endif\n\n    CASE(OP_ADDI, BB) {\n      OP_MATHI(add);\n    }\n\n    CASE(OP_SUBI, BB) {\n      OP_MATHI(sub);\n    }\n\n#define OP_CMP_BODY(op,v1,v2) (v1(regs[a]) op v2(regs[a+1]))\n\n#ifdef MRB_NO_FLOAT\n#define OP_CMP(op,sym) do {\\\n  int result;\\\n  /* need to check if - is overridden */\\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\\\n  case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\\\n    break;\\\n  default:\\\n    mid = MRB_OPSYM(sym);\\\n    goto L_SEND_SYM;\\\n  }\\\n  if (result) {\\\n    SET_TRUE_VALUE(regs[a]);\\\n  }\\\n  else {\\\n    SET_FALSE_VALUE(regs[a]);\\\n  }\\\n} while(0)\n#else\n#define OP_CMP(op, sym) do {\\\n  int result;\\\n  /* need to check if - is overridden */\\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\\\n  case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\\\n    break;\\\n  case TYPES2(MRB_TT_INTEGER,MRB_TT_FLOAT):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_float);\\\n    break;\\\n  case TYPES2(MRB_TT_FLOAT,MRB_TT_INTEGER):\\\n    result = OP_CMP_BODY(op,mrb_float,mrb_fixnum);\\\n    break;\\\n  case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\\\n    result = OP_CMP_BODY(op,mrb_float,mrb_float);\\\n    break;\\\n  default:\\\n    mid = MRB_OPSYM(sym);\\\n    goto L_SEND_SYM;\\\n  }\\\n  if (result) {\\\n    SET_TRUE_VALUE(regs[a]);\\\n  }\\\n  else {\\\n    SET_FALSE_VALUE(regs[a]);\\\n  }\\\n} while(0)\n#endif\n\n    CASE(OP_EQ, B) {\n      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {\n        SET_TRUE_VALUE(regs[a]);\n      }\n      else {\n        OP_CMP(==,eq);\n      }\n      NEXT;\n    }\n\n    CASE(OP_LT, B) {\n      OP_CMP(<,lt);\n      NEXT;\n    }\n\n    CASE(OP_LE, B) {\n      OP_CMP(<=,le);\n      NEXT;\n    }\n\n    CASE(OP_GT, B) {\n      OP_CMP(>,gt);\n      NEXT;\n    }\n\n    CASE(OP_GE, B) {\n      OP_CMP(>=,ge);\n      NEXT;\n    }\n\n    CASE(OP_ARRAY, BB) {\n      regs[a] = mrb_ary_new_from_values(mrb, b, &regs[a]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n    CASE(OP_ARRAY2, BBB) {\n      regs[a] = mrb_ary_new_from_values(mrb, c, &regs[b]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ARYCAT, B) {\n      mrb_value splat = mrb_ary_splat(mrb, regs[a+1]);\n      if (mrb_nil_p(regs[a])) {\n        regs[a] = splat;\n      }\n      else {\n        mrb_assert(mrb_array_p(regs[a]));\n        mrb_ary_concat(mrb, regs[a], splat);\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ARYPUSH, BB) {\n      mrb_assert(mrb_array_p(regs[a]));\n      for (mrb_int i=0; i<b; i++) {\n        mrb_ary_push(mrb, regs[a], regs[a+i+1]);\n      }\n      NEXT;\n    }\n\n    CASE(OP_ARYDUP, B) {\n      mrb_value ary = regs[a];\n      if (mrb_array_p(ary)) {\n        ary = mrb_ary_new_from_values(mrb, RARRAY_LEN(ary), RARRAY_PTR(ary));\n      }\n      else {\n        ary = mrb_ary_new_from_values(mrb, 1, &ary);\n      }\n      regs[a] = ary;\n      NEXT;\n    }\n\n    CASE(OP_AREF, BBB) {\n      mrb_value v = regs[b];\n\n      if (!mrb_array_p(v)) {\n        if (c == 0) {\n          regs[a] = v;\n        }\n        else {\n          SET_NIL_VALUE(regs[a]);\n        }\n      }\n      else {\n        v = mrb_ary_ref(mrb, v, c);\n        regs[a] = v;\n      }\n      NEXT;\n    }\n\n    CASE(OP_ASET, BBB) {\n      mrb_assert(mrb_array_p(regs[a]));\n      mrb_ary_set(mrb, regs[b], c, regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_APOST, BBB) {\n      mrb_value v = regs[a];\n      int pre  = b;\n      int post = c;\n      struct RArray *ary;\n      int len, idx;\n\n      if (!mrb_array_p(v)) {\n        v = mrb_ary_new_from_values(mrb, 1, &regs[a]);\n      }\n      ary = mrb_ary_ptr(v);\n      len = (int)ARY_LEN(ary);\n      if (len > pre + post) {\n        v = mrb_ary_new_from_values(mrb, len - pre - post, ARY_PTR(ary)+pre);\n        regs[a++] = v;\n        while (post--) {\n          regs[a++] = ARY_PTR(ary)[len-post-1];\n        }\n      }\n      else {\n        v = mrb_ary_new_capa(mrb, 0);\n        regs[a++] = v;\n        for (idx=0; idx+pre<len; idx++) {\n          regs[a+idx] = ARY_PTR(ary)[pre+idx];\n        }\n        while (idx < post) {\n          SET_NIL_VALUE(regs[a+idx]);\n          idx++;\n        }\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_INTERN, B) {\n      mrb_assert(mrb_string_p(regs[a]));\n      mrb_sym sym = mrb_intern_str(mrb, regs[a]);\n      regs[a] = mrb_symbol_value(sym);\n      NEXT;\n    }\n\n    CASE(OP_SYMBOL, BB) {\n      size_t len;\n      mrb_sym sym;\n\n      mrb_assert((pool[b].tt&IREP_TT_NFLAG)==0);\n      len = pool[b].tt >> 2;\n      if (pool[b].tt & IREP_TT_SFLAG) {\n        sym = mrb_intern_static(mrb, pool[b].u.str, len);\n      }\n      else {\n        sym  = mrb_intern(mrb, pool[b].u.str, len);\n      }\n      regs[a] = mrb_symbol_value(sym);\n      NEXT;\n    }\n\n    CASE(OP_STRING, BB) {\n      mrb_int len;\n\n      mrb_assert((pool[b].tt&IREP_TT_NFLAG)==0);\n      len = pool[b].tt >> 2;\n      if (pool[b].tt & IREP_TT_SFLAG) {\n        regs[a] = mrb_str_new_static(mrb, pool[b].u.str, len);\n      }\n      else {\n        regs[a] = mrb_str_new(mrb, pool[b].u.str, len);\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_STRCAT, B) {\n      mrb_assert(mrb_string_p(regs[a]));\n      mrb_str_concat(mrb, regs[a], regs[a+1]);\n      NEXT;\n    }\n\n    CASE(OP_HASH, BB) {\n      mrb_value hash = mrb_hash_new_capa(mrb, b);\n      int i;\n      int lim = a+b*2;\n\n      for (i=a; i<lim; i+=2) {\n        mrb_hash_set(mrb, hash, regs[i], regs[i+1]);\n      }\n      regs[a] = hash;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_HASHADD, BB) {\n      mrb_value hash;\n      int i;\n      int lim = a+b*2+1;\n\n      hash = regs[a];\n      mrb_ensure_hash_type(mrb, hash);\n      for (i=a+1; i<lim; i+=2) {\n        mrb_hash_set(mrb, hash, regs[i], regs[i+1]);\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n    CASE(OP_HASHCAT, B) {\n      mrb_value hash = regs[a];\n\n      mrb_assert(mrb_hash_p(hash));\n      mrb_hash_merge(mrb, hash, regs[a+1]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_LAMBDA, BB)\n    c = OP_L_LAMBDA;\n    L_MAKE_LAMBDA:\n    {\n      struct RProc *p;\n      const mrb_irep *nirep = irep->reps[b];\n\n      if (c & OP_L_CAPTURE) {\n        p = mrb_closure_new(mrb, nirep);\n      }\n      else {\n        p = mrb_proc_new(mrb, nirep);\n        p->flags |= MRB_PROC_SCOPE;\n      }\n      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;\n      regs[a] = mrb_obj_value(p);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n    CASE(OP_BLOCK, BB) {\n      c = OP_L_BLOCK;\n      goto L_MAKE_LAMBDA;\n    }\n    CASE(OP_METHOD, BB) {\n      c = OP_L_METHOD;\n      goto L_MAKE_LAMBDA;\n    }\n\n    CASE(OP_RANGE_INC, B) {\n      mrb_value v = mrb_range_new(mrb, regs[a], regs[a+1], FALSE);\n      regs[a] = v;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_RANGE_EXC, B) {\n      mrb_value v = mrb_range_new(mrb, regs[a], regs[a+1], TRUE);\n      regs[a] = v;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_OCLASS, B) {\n      regs[a] = mrb_obj_value(mrb->object_class);\n      NEXT;\n    }\n\n    CASE(OP_CLASS, BB) {\n      struct RClass *c = 0, *baseclass;\n      mrb_value base, super;\n      mrb_sym id = syms[b];\n\n      base = regs[a];\n      super = regs[a+1];\n      if (mrb_nil_p(base)) {\n        baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);\n        if (!baseclass) baseclass = mrb->object_class;\n        base = mrb_obj_value(baseclass);\n      }\n      c = mrb_vm_define_class(mrb, base, super, id);\n      regs[a] = mrb_obj_value(c);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_MODULE, BB) {\n      struct RClass *cls = 0, *baseclass;\n      mrb_value base;\n      mrb_sym id = syms[b];\n\n      base = regs[a];\n      if (mrb_nil_p(base)) {\n        baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);\n        if (!baseclass) baseclass = mrb->object_class;\n        base = mrb_obj_value(baseclass);\n      }\n      cls = mrb_vm_define_module(mrb, base, id);\n      regs[a] = mrb_obj_value(cls);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_EXEC, BB)\n    {\n      mrb_value recv = regs[a];\n      struct RProc *p;\n      const mrb_irep *nirep = irep->reps[b];\n\n      /* prepare closure */\n      p = mrb_proc_new(mrb, nirep);\n      p->c = NULL;\n      mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)proc);\n      MRB_PROC_SET_TARGET_CLASS(p, mrb_class_ptr(recv));\n      p->flags |= MRB_PROC_SCOPE;\n\n      /* prepare call stack */\n      cipush(mrb, a, 0, mrb_class_ptr(recv), p, 0, 0);\n\n      irep = p->body.irep;\n      pool = irep->pool;\n      syms = irep->syms;\n      mrb_stack_extend(mrb, irep->nregs);\n      stack_clear(regs+1, irep->nregs-1);\n      pc = irep->iseq;\n      JUMP;\n    }\n\n    CASE(OP_DEF, BB) {\n      struct RClass *target = mrb_class_ptr(regs[a]);\n      struct RProc *p = mrb_proc_ptr(regs[a+1]);\n      mrb_method_t m;\n      mrb_sym mid = syms[b];\n\n      MRB_METHOD_FROM_PROC(m, p);\n      mrb_define_method_raw(mrb, target, mid, m);\n      mrb_method_added(mrb, target, mid);\n      mrb_gc_arena_restore(mrb, ai);\n      regs[a] = mrb_symbol_value(mid);\n      NEXT;\n    }\n\n    CASE(OP_SCLASS, B) {\n      regs[a] = mrb_singleton_class(mrb, regs[a]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_TCLASS, B) {\n      struct RClass *target = check_target_class(mrb);\n      if (!target) goto L_RAISE;\n      regs[a] = mrb_obj_value(target);\n      NEXT;\n    }\n\n    CASE(OP_ALIAS, BB) {\n      struct RClass *target = check_target_class(mrb);\n\n      if (!target) goto L_RAISE;\n      mrb_alias_method(mrb, target, syms[a], syms[b]);\n      mrb_method_added(mrb, target, syms[a]);\n      NEXT;\n    }\n    CASE(OP_UNDEF, B) {\n      struct RClass *target = check_target_class(mrb);\n\n      if (!target) goto L_RAISE;\n      mrb_undef_method_id(mrb, target, syms[a]);\n      NEXT;\n    }\n\n    CASE(OP_DEBUG, Z) {\n      FETCH_BBB();\n#ifdef MRB_USE_DEBUG_HOOK\n      mrb->debug_op_hook(mrb, irep, pc, regs);\n#else\n#ifndef MRB_NO_STDIO\n      printf(\"OP_DEBUG %d %d %d\\n\", a, b, c);\n#else\n      abort();\n#endif\n#endif\n      NEXT;\n    }\n\n    CASE(OP_ERR, B) {\n      size_t len = pool[a].tt >> 2;\n      mrb_value exc;\n\n      mrb_assert((pool[a].tt&IREP_TT_NFLAG)==0);\n      exc = mrb_exc_new(mrb, E_LOCALJUMP_ERROR, pool[a].u.str, len);\n      mrb_exc_set(mrb, exc);\n      goto L_RAISE;\n    }\n\n    CASE(OP_EXT1, Z) {\n      insn = READ_B();\n      switch (insn) {\n#define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _1(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY;\n#include \"mruby/ops.h\"\n#undef OPCODE\n      }\n      pc--;\n      NEXT;\n    }\n    CASE(OP_EXT2, Z) {\n      insn = READ_B();\n      switch (insn) {\n#define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _2(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY;\n#include \"mruby/ops.h\"\n#undef OPCODE\n      }\n      pc--;\n      NEXT;\n    }\n    CASE(OP_EXT3, Z) {\n      uint8_t insn = READ_B();\n      switch (insn) {\n#define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _3(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY;\n#include \"mruby/ops.h\"\n#undef OPCODE\n      }\n      pc--;\n      NEXT;\n    }\n\n    CASE(OP_STOP, Z) {\n      /*        stop VM */\n      CHECKPOINT_RESTORE(RBREAK_TAG_STOP) {\n        /* do nothing */\n      }\n      CHECKPOINT_MAIN(RBREAK_TAG_STOP) {\n        UNWIND_ENSURE(mrb, mrb->c->ci, pc, RBREAK_TAG_STOP, proc, mrb_nil_value());\n      }\n      CHECKPOINT_END(RBREAK_TAG_STOP);\n    L_STOP:\n      mrb->jmp = prev_jmp;\n      if (mrb->exc) {\n        mrb_assert(mrb->exc->tt == MRB_TT_EXCEPTION);\n        return mrb_obj_value(mrb->exc);\n      }\n      return regs[irep->nlocals];\n    }\n  }\n  END_DISPATCH;\n#undef regs\n  }\n  MRB_CATCH(&c_jmp) {\n    mrb_callinfo *ci = mrb->c->ci;\n    while (ci > mrb->c->cibase && ci->cci == CINFO_DIRECT) {\n      ci = cipop(mrb);\n    }\n    exc_catched = TRUE;\n    pc = ci->pc;\n    goto RETRY_TRY_BLOCK;\n  }\n  MRB_END_EXC(&c_jmp);\n}\n\nstatic mrb_value\nmrb_run(mrb_state *mrb, const struct RProc *proc, mrb_value self)\n{\n  return mrb_vm_run(mrb, proc, self, mrb_ci_bidx(mrb->c->ci) + 1);\n}\n\nMRB_API mrb_value\nmrb_top_run(mrb_state *mrb, const struct RProc *proc, mrb_value self, mrb_int stack_keep)\n{\n  mrb_value v;\n\n  if (!mrb->c->cibase) {\n    return mrb_vm_run(mrb, proc, self, stack_keep);\n  }\n  if (mrb->c->ci == mrb->c->cibase) {\n    mrb_vm_ci_env_set(mrb->c->ci, NULL);\n    return mrb_vm_run(mrb, proc, self, stack_keep);\n  }\n  cipush(mrb, 0, CINFO_SKIP, mrb->object_class, NULL, 0, 0);\n  v = mrb_vm_run(mrb, proc, self, stack_keep);\n\n  return v;\n}\n\n#if defined(MRB_USE_CXX_EXCEPTION) && defined(__cplusplus)\n# if !defined(MRB_USE_CXX_ABI)\n} /* end of extern \"C\" */\n# endif\nmrb_int mrb_jmpbuf::jmpbuf_id = 0;\n# if !defined(MRB_USE_CXX_ABI)\nextern \"C\" {\n# endif\n#endif\n"], "fixing_code": ["/*\n** vm.c - virtual machine for mruby\n**\n** See Copyright Notice in mruby.h\n*/\n\n#include <mruby.h>\n#include <mruby/array.h>\n#include <mruby/class.h>\n#include <mruby/hash.h>\n#include <mruby/irep.h>\n#include <mruby/numeric.h>\n#include <mruby/proc.h>\n#include <mruby/range.h>\n#include <mruby/string.h>\n#include <mruby/variable.h>\n#include <mruby/error.h>\n#include <mruby/opcode.h>\n#include \"value_array.h\"\n#include <mruby/throw.h>\n#include <mruby/dump.h>\n#include <mruby/internal.h>\n#include <mruby/presym.h>\n\n#ifdef MRB_NO_STDIO\n#if defined(__cplusplus)\nextern \"C\" {\n#endif\nvoid abort(void);\n#if defined(__cplusplus)\n}  /* extern \"C\" { */\n#endif\n#endif\n\n#define STACK_INIT_SIZE 128\n#define CALLINFO_INIT_SIZE 32\n\n/* Define amount of linear stack growth. */\n#ifndef MRB_STACK_GROWTH\n#define MRB_STACK_GROWTH 128\n#endif\n\n/* Maximum recursive depth. Should be set lower on memory constrained systems. */\n#ifndef MRB_CALL_LEVEL_MAX\n#define MRB_CALL_LEVEL_MAX 512\n#endif\n\n/* Maximum stack depth. Should be set lower on memory constrained systems.\nThe value below allows about 60000 recursive calls in the simplest case. */\n#ifndef MRB_STACK_MAX\n#define MRB_STACK_MAX (0x40000 - MRB_STACK_GROWTH)\n#endif\n\n#ifdef VM_DEBUG\n# define DEBUG(x) (x)\n#else\n# define DEBUG(x)\n#endif\n\n\n#ifndef MRB_GC_FIXED_ARENA\nstatic void\nmrb_gc_arena_shrink(mrb_state *mrb, int idx)\n{\n  mrb_gc *gc = &mrb->gc;\n  int capa = gc->arena_capa;\n\n  mrb->gc.arena_idx = idx;\n  if (idx < capa / 4) {\n    capa >>= 2;\n    if (capa < MRB_GC_ARENA_SIZE) {\n      capa = MRB_GC_ARENA_SIZE;\n    }\n    if (capa != gc->arena_capa) {\n      gc->arena = (struct RBasic**)mrb_realloc(mrb, gc->arena, sizeof(struct RBasic*)*capa);\n      gc->arena_capa = capa;\n    }\n  }\n}\n#else\n#define mrb_gc_arena_shrink(mrb,idx) mrb_gc_arena_restore(mrb,idx)\n#endif\n\n#define CALL_MAXARGS 15\n#define CALL_VARARGS (CALL_MAXARGS<<4 | CALL_MAXARGS)\n\nvoid mrb_method_missing(mrb_state *mrb, mrb_sym name, mrb_value self, mrb_value args);\n\nstatic inline void\nstack_clear(mrb_value *from, size_t count)\n{\n  while (count-- > 0) {\n    SET_NIL_VALUE(*from);\n    from++;\n  }\n}\n\nstatic inline void\nstack_copy(mrb_value *dst, const mrb_value *src, size_t size)\n{\n  memcpy(dst, src, sizeof(mrb_value)*size);\n}\n\nstatic void\nstack_init(mrb_state *mrb)\n{\n  struct mrb_context *c = mrb->c;\n\n  /* mrb_assert(mrb->stack == NULL); */\n  c->stbase = (mrb_value *)mrb_calloc(mrb, STACK_INIT_SIZE, sizeof(mrb_value));\n  c->stend = c->stbase + STACK_INIT_SIZE;\n\n  /* mrb_assert(ci == NULL); */\n  c->cibase = (mrb_callinfo *)mrb_calloc(mrb, CALLINFO_INIT_SIZE, sizeof(mrb_callinfo));\n  c->ciend = c->cibase + CALLINFO_INIT_SIZE;\n  c->ci = c->cibase;\n  c->ci->u.target_class = mrb->object_class;\n  c->ci->stack = c->stbase;\n}\n\nstatic inline void\nenvadjust(mrb_state *mrb, mrb_value *oldbase, mrb_value *newbase, size_t oldsize)\n{\n  mrb_callinfo *ci = mrb->c->cibase;\n\n  if (newbase == oldbase) return;\n  while (ci <= mrb->c->ci) {\n    struct REnv *e = mrb_vm_ci_env(ci);\n    mrb_value *st;\n\n    if (e && MRB_ENV_ONSTACK_P(e) &&\n        (st = e->stack) && oldbase <= st && st < oldbase+oldsize) {\n      ptrdiff_t off = e->stack - oldbase;\n\n      e->stack = newbase + off;\n    }\n\n    if (ci->proc && MRB_PROC_ENV_P(ci->proc) && e != MRB_PROC_ENV(ci->proc)) {\n      e = MRB_PROC_ENV(ci->proc);\n\n      if (e && MRB_ENV_ONSTACK_P(e) &&\n          (st = e->stack) && oldbase <= st && st < oldbase+oldsize) {\n        ptrdiff_t off = e->stack - oldbase;\n\n        e->stack = newbase + off;\n      }\n    }\n\n    ci->stack = newbase + (ci->stack - oldbase);\n    ci++;\n  }\n}\n\n/** def rec ; $deep =+ 1 ; if $deep > 1000 ; return 0 ; end ; rec ; end  */\n\nstatic void\nstack_extend_alloc(mrb_state *mrb, mrb_int room)\n{\n  mrb_value *oldbase = mrb->c->stbase;\n  mrb_value *newstack;\n  size_t oldsize = mrb->c->stend - mrb->c->stbase;\n  size_t size = oldsize;\n  size_t off = mrb->c->ci->stack ? mrb->c->stend - mrb->c->ci->stack : 0;\n\n  if (off > size) size = off;\n#ifdef MRB_STACK_EXTEND_DOUBLING\n  if ((size_t)room <= size)\n    size *= 2;\n  else\n    size += room;\n#else\n  /* Use linear stack growth.\n     It is slightly slower than doubling the stack space,\n     but it saves memory on small devices. */\n  if (room <= MRB_STACK_GROWTH)\n    size += MRB_STACK_GROWTH;\n  else\n    size += room;\n#endif\n\n  newstack = (mrb_value *)mrb_realloc_simple(mrb, mrb->c->stbase, sizeof(mrb_value) * size);\n  if (newstack == NULL) {\n    mrb_exc_raise(mrb, mrb_obj_value(mrb->stack_err));\n  }\n  stack_clear(&(newstack[oldsize]), size - oldsize);\n  envadjust(mrb, oldbase, newstack, oldsize);\n  mrb->c->stbase = newstack;\n  mrb->c->stend = mrb->c->stbase + size;\n\n  /* Raise an exception if the new stack size will be too large,\n     to prevent infinite recursion. However, do this only after resizing the stack, so mrb_raise has stack space to work with. */\n  if (size > MRB_STACK_MAX) {\n    mrb_exc_raise(mrb, mrb_obj_value(mrb->stack_err));\n  }\n}\n\nMRB_API void\nmrb_stack_extend(mrb_state *mrb, mrb_int room)\n{\n  if (!mrb->c->ci->stack || mrb->c->ci->stack + room >= mrb->c->stend) {\n    stack_extend_alloc(mrb, room);\n  }\n}\n\nstatic inline struct REnv*\nuvenv(mrb_state *mrb, mrb_int up)\n{\n  const struct RProc *proc = mrb->c->ci->proc;\n  struct REnv *e;\n\n  while (up--) {\n    proc = proc->upper;\n    if (!proc) return NULL;\n  }\n  e = MRB_PROC_ENV(proc);\n  if (e) return e;              /* proc has enclosed env */\n  else {\n    mrb_callinfo *ci = mrb->c->ci;\n    mrb_callinfo *cb = mrb->c->cibase;\n\n    while (cb <= ci) {\n      if (ci->proc == proc) {\n        return mrb_vm_ci_env(ci);\n      }\n      ci--;\n    }\n  }\n  return NULL;\n}\n\nstatic inline const struct RProc*\ntop_proc(mrb_state *mrb, const struct RProc *proc)\n{\n  while (proc->upper) {\n    if (MRB_PROC_SCOPE_P(proc) || MRB_PROC_STRICT_P(proc))\n      return proc;\n    proc = proc->upper;\n  }\n  return proc;\n}\n\n#define CINFO_NONE    0\n#define CINFO_SKIP    1\n#define CINFO_DIRECT  2\n#define CINFO_RESUMED 3\n\nstatic inline mrb_callinfo*\ncipush(mrb_state *mrb, mrb_int push_stacks, uint8_t cci,\n       struct RClass *target_class, const struct RProc *proc, mrb_sym mid, uint8_t argc)\n{\n  struct mrb_context *c = mrb->c;\n  mrb_callinfo *ci = c->ci;\n\n  if (ci + 1 == c->ciend) {\n    ptrdiff_t size = ci - c->cibase;\n\n    if (size > MRB_CALL_LEVEL_MAX) {\n      mrb_exc_raise(mrb, mrb_obj_value(mrb->stack_err));\n    }\n    c->cibase = (mrb_callinfo *)mrb_realloc(mrb, c->cibase, sizeof(mrb_callinfo)*size*2);\n    c->ci = c->cibase + size;\n    c->ciend = c->cibase + size * 2;\n  }\n  ci = ++c->ci;\n  ci->mid = mid;\n  mrb_vm_ci_proc_set(ci, proc);\n  ci->stack = ci[-1].stack + push_stacks;\n  ci->n = argc & 0xf;\n  ci->nk = (argc>>4) & 0xf;\n  ci->cci = cci;\n  ci->u.target_class = target_class;\n\n  return ci;\n}\n\nvoid\nmrb_env_unshare(mrb_state *mrb, struct REnv *e)\n{\n  if (e == NULL) return;\n  else {\n    size_t len = (size_t)MRB_ENV_LEN(e);\n    mrb_value *p;\n\n    if (!MRB_ENV_ONSTACK_P(e)) return;\n    if (e->cxt != mrb->c) return;\n    if (e == mrb_vm_ci_env(mrb->c->cibase)) return; /* for mirb */\n    p = (mrb_value *)mrb_malloc(mrb, sizeof(mrb_value)*len);\n    if (len > 0) {\n      stack_copy(p, e->stack, len);\n    }\n    e->stack = p;\n    MRB_ENV_CLOSE(e);\n    mrb_write_barrier(mrb, (struct RBasic *)e);\n  }\n}\n\nstatic inline mrb_callinfo*\ncipop(mrb_state *mrb)\n{\n  struct mrb_context *c = mrb->c;\n  struct REnv *env = mrb_vm_ci_env(c->ci);\n\n  c->ci--;\n  if (env) mrb_env_unshare(mrb, env);\n  return c->ci;\n}\n\nMRB_API mrb_value\nmrb_protect_error(mrb_state *mrb, mrb_protect_error_func *body, void *userdata, mrb_bool *error)\n{\n  struct mrb_jmpbuf *prev_jmp = mrb->jmp;\n  struct mrb_jmpbuf c_jmp;\n  mrb_value result = mrb_nil_value();\n  int ai = mrb_gc_arena_save(mrb);\n  const struct mrb_context *c = mrb->c;\n  ptrdiff_t ci_index = c->ci - c->cibase;\n\n  if (error) { *error = FALSE; }\n\n  MRB_TRY(&c_jmp) {\n    mrb->jmp = &c_jmp;\n    result = body(mrb, userdata);\n    mrb->jmp = prev_jmp;\n  }\n  MRB_CATCH(&c_jmp) {\n    mrb->jmp = prev_jmp;\n    result = mrb_obj_value(mrb->exc);\n    mrb->exc = NULL;\n    if (error) { *error = TRUE; }\n    if (mrb->c == c) {\n      while (c->ci - c->cibase > ci_index) {\n        cipop(mrb);\n      }\n    }\n    else {\n      // It was probably switched by mrb_fiber_resume().\n      // Simply destroy all successive CINFO_DIRECTs once the fiber has been switched.\n      c = mrb->c;\n      while (c->ci > c->cibase && c->ci->cci == CINFO_DIRECT) {\n        cipop(mrb);\n      }\n    }\n  }\n  MRB_END_EXC(&c_jmp);\n\n  mrb_gc_arena_restore(mrb, ai);\n  mrb_gc_protect(mrb, result);\n  return result;\n}\n\nvoid mrb_exc_set(mrb_state *mrb, mrb_value exc);\nstatic mrb_value mrb_run(mrb_state *mrb, const struct RProc* proc, mrb_value self);\n\n#ifndef MRB_FUNCALL_ARGC_MAX\n#define MRB_FUNCALL_ARGC_MAX 16\n#endif\n\nMRB_API mrb_value\nmrb_funcall(mrb_state *mrb, mrb_value self, const char *name, mrb_int argc, ...)\n{\n  mrb_value argv[MRB_FUNCALL_ARGC_MAX];\n  va_list ap;\n  mrb_int i;\n  mrb_sym mid = mrb_intern_cstr(mrb, name);\n\n  if (argc > MRB_FUNCALL_ARGC_MAX) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"Too long arguments. (limit=\" MRB_STRINGIZE(MRB_FUNCALL_ARGC_MAX) \")\");\n  }\n\n  va_start(ap, argc);\n  for (i = 0; i < argc; i++) {\n    argv[i] = va_arg(ap, mrb_value);\n  }\n  va_end(ap);\n  return mrb_funcall_argv(mrb, self, mid, argc, argv);\n}\n\nMRB_API mrb_value\nmrb_funcall_id(mrb_state *mrb, mrb_value self, mrb_sym mid, mrb_int argc, ...)\n{\n  mrb_value argv[MRB_FUNCALL_ARGC_MAX];\n  va_list ap;\n  mrb_int i;\n\n  if (argc > MRB_FUNCALL_ARGC_MAX) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"Too long arguments. (limit=\" MRB_STRINGIZE(MRB_FUNCALL_ARGC_MAX) \")\");\n  }\n\n  va_start(ap, argc);\n  for (i = 0; i < argc; i++) {\n    argv[i] = va_arg(ap, mrb_value);\n  }\n  va_end(ap);\n  return mrb_funcall_argv(mrb, self, mid, argc, argv);\n}\n\nstatic mrb_int\nmrb_ci_kidx(const mrb_callinfo *ci)\n{\n  return (ci->n == CALL_MAXARGS) ? 2 : ci->n + 1;\n}\n\nstatic mrb_int\nmrb_bidx(uint16_t c)\n{\n  uint8_t n = c & 0xf;\n  uint8_t k = (c>>4) & 0xf;\n  if (n == 15) n = 1;\n  if (k == 15) n += 1;\n  else n += k*2;\n  return n + 1;                 /* self + args + kargs */\n}\n\nmrb_int\nmrb_ci_bidx(mrb_callinfo *ci)\n{\n  return mrb_bidx(ci->n|(ci->nk<<4));\n}\n\nmrb_int\nmrb_ci_nregs(mrb_callinfo *ci)\n{\n  const struct RProc *p;\n\n  if (!ci) return 4;\n  mrb_int nregs = mrb_ci_bidx(ci) + 1; /* self + args + kargs + blk */\n  p = ci->proc;\n  if (p && !MRB_PROC_CFUNC_P(p) && p->body.irep && p->body.irep->nregs > nregs) {\n    return p->body.irep->nregs;\n  }\n  return nregs;\n}\n\nmrb_value mrb_obj_missing(mrb_state *mrb, mrb_value mod);\n\nstatic mrb_method_t\nprepare_missing(mrb_state *mrb, mrb_value recv, mrb_sym mid, struct RClass **clsp, uint32_t a, uint16_t *c, mrb_value blk, int super)\n{\n  mrb_sym missing = MRB_SYM(method_missing);\n  mrb_callinfo *ci = mrb->c->ci;\n  uint16_t b = *c;\n  mrb_int n = b & 0xf;\n  mrb_int nk = (b>>4) & 0xf;\n  mrb_value *argv = &ci->stack[a+1];\n  mrb_value args;\n  mrb_method_t m;\n\n  /* pack positional arguments */\n  if (n == 15) args = argv[0];\n  else args = mrb_ary_new_from_values(mrb, n, argv);\n\n  if (mrb_func_basic_p(mrb, recv, missing, mrb_obj_missing)) {\n  method_missing:\n    if (super) mrb_no_method_error(mrb, mid, args, \"no superclass method '%n'\", mid);\n    else mrb_method_missing(mrb, mid, recv, args);\n    /* not reached */\n  }\n  if (mid != missing) {\n    *clsp = mrb_class(mrb, recv);\n  }\n  m = mrb_method_search_vm(mrb, clsp, missing);\n  if (MRB_METHOD_UNDEF_P(m)) goto method_missing; /* just in case */\n  mrb_stack_extend(mrb, a+4);\n\n  argv = &ci->stack[a+1];       /* maybe reallocated */\n  argv[0] = args;\n  if (nk == 0) {\n    argv[1] = blk;\n  }\n  else {\n    mrb_assert(nk == 15);\n    argv[1] = argv[n];\n    argv[2] = blk;\n  }\n  *c = 15 | (uint16_t)(nk<<4);\n  mrb_ary_unshift(mrb, args, mrb_symbol_value(mid));\n  return m;\n}\n\nMRB_API mrb_value\nmrb_funcall_with_block(mrb_state *mrb, mrb_value self, mrb_sym mid, mrb_int argc, const mrb_value *argv, mrb_value blk)\n{\n  mrb_value val;\n  int ai = mrb_gc_arena_save(mrb);\n\n  if (!mrb->jmp) {\n    struct mrb_jmpbuf c_jmp;\n    ptrdiff_t nth_ci = mrb->c->ci - mrb->c->cibase;\n\n    MRB_TRY(&c_jmp) {\n      mrb->jmp = &c_jmp;\n      /* recursive call */\n      val = mrb_funcall_with_block(mrb, self, mid, argc, argv, blk);\n      mrb->jmp = 0;\n    }\n    MRB_CATCH(&c_jmp) { /* error */\n      while (nth_ci < (mrb->c->ci - mrb->c->cibase)) {\n        cipop(mrb);\n      }\n      mrb->jmp = 0;\n      val = mrb_obj_value(mrb->exc);\n    }\n    MRB_END_EXC(&c_jmp);\n    mrb->jmp = 0;\n  }\n  else {\n    mrb_method_t m;\n    struct RClass *c;\n    mrb_callinfo *ci = mrb->c->ci;\n    mrb_int n = mrb_ci_nregs(ci);\n    ptrdiff_t voff = -1;\n\n    if (!mrb->c->stbase) {\n      stack_init(mrb);\n    }\n    if (ci - mrb->c->cibase > MRB_CALL_LEVEL_MAX) {\n      mrb_exc_raise(mrb, mrb_obj_value(mrb->stack_err));\n    }\n    if (mrb->c->stbase <= argv && argv < mrb->c->stend) {\n      voff = argv - mrb->c->stbase;\n    }\n    if (argc < 0) {\n      mrb_raisef(mrb, E_ARGUMENT_ERROR, \"negative argc for funcall (%i)\", argc);\n    }\n    c = mrb_class(mrb, self);\n    m = mrb_method_search_vm(mrb, &c, mid);\n    mrb_stack_extend(mrb, n + argc + 3);\n    if (argc >= 15) {\n      ci->stack[n+1] = mrb_ary_new_from_values(mrb, argc, argv);\n      argc = 15;\n    }\n    if (MRB_METHOD_UNDEF_P(m)) {\n      uint16_t ac = (uint16_t)argc;\n      m = prepare_missing(mrb, self, mid, &c, n, &ac, mrb_nil_value(), 0);\n      argc = (mrb_int)ac;\n      mid = MRB_SYM(method_missing);\n    }\n    ci = cipush(mrb, n, 0, c, NULL, mid, argc);\n    if (MRB_METHOD_PROC_P(m)) {\n      struct RProc *p = MRB_METHOD_PROC(m);\n\n      mrb_vm_ci_proc_set(ci, p);\n      if (!MRB_PROC_CFUNC_P(p)) {\n        mrb_stack_extend(mrb, p->body.irep->nregs + argc);\n      }\n    }\n    if (voff >= 0) {\n      argv = mrb->c->stbase + voff;\n    }\n    ci->stack[0] = self;\n    if (argc < 15) {\n      if (argc > 0)\n        stack_copy(ci->stack+1, argv, argc);\n      ci->stack[argc+1] = blk;\n    }\n    else {\n      ci->stack[2] = blk;\n    }\n\n    if (MRB_METHOD_CFUNC_P(m)) {\n      ci->cci = CINFO_DIRECT;\n      val = MRB_METHOD_CFUNC(m)(mrb, self);\n      cipop(mrb);\n    }\n    else {\n      ci->cci = CINFO_SKIP;\n      val = mrb_run(mrb, MRB_METHOD_PROC(m), self);\n    }\n  }\n  mrb_gc_arena_restore(mrb, ai);\n  mrb_gc_protect(mrb, val);\n  return val;\n}\n\nMRB_API mrb_value\nmrb_funcall_argv(mrb_state *mrb, mrb_value self, mrb_sym mid, mrb_int argc, const mrb_value *argv)\n{\n  return mrb_funcall_with_block(mrb, self, mid, argc, argv, mrb_nil_value());\n}\n\nstatic void\ncheck_method_noarg(mrb_state *mrb, const mrb_callinfo *ci)\n{\n  int argc = ci->n == CALL_MAXARGS ? RARRAY_LEN(ci->stack[1]) : ci->n;\n  if (ci->nk > 0) {\n    mrb_value kdict = ci->stack[mrb_ci_kidx(ci)];\n    if (!(mrb_hash_p(kdict) && mrb_hash_empty_p(mrb, kdict))) {\n      argc++;\n    }\n  }\n  if (argc > 0) {\n    mrb_argnum_error(mrb, argc, 0, 0);\n  }\n}\n\nstatic mrb_value\nexec_irep(mrb_state *mrb, mrb_value self, struct RProc *p)\n{\n  mrb_callinfo *ci = mrb->c->ci;\n  int keep, nregs;\n\n  ci->stack[0] = self;\n  mrb_vm_ci_proc_set(ci, p);\n  if (MRB_PROC_CFUNC_P(p)) {\n    if (MRB_PROC_NOARG_P(p)) {\n      check_method_noarg(mrb, ci);\n    }\n    return MRB_PROC_CFUNC(p)(mrb, self);\n  }\n  nregs = p->body.irep->nregs;\n  keep = mrb_ci_bidx(ci)+1;\n  if (nregs < keep) {\n    mrb_stack_extend(mrb, keep);\n  }\n  else {\n    mrb_stack_extend(mrb, nregs);\n    stack_clear(ci->stack+keep, nregs-keep);\n  }\n\n  cipush(mrb, 0, 0, NULL, NULL, 0, 0);\n\n  return self;\n}\n\nmrb_value\nmrb_exec_irep(mrb_state *mrb, mrb_value self, struct RProc *p)\n{\n  mrb_callinfo *ci = mrb->c->ci;\n  if (ci->cci == CINFO_NONE) {\n    return exec_irep(mrb, self, p);\n  }\n  else {\n    mrb_value ret;\n    if (MRB_PROC_CFUNC_P(p)) {\n      if (MRB_PROC_NOARG_P(p)) {\n        check_method_noarg(mrb, ci);\n      }\n      cipush(mrb, 0, CINFO_DIRECT, mrb_vm_ci_target_class(ci), p, ci->mid, ci->n|(ci->nk<<4));\n      ret = MRB_PROC_CFUNC(p)(mrb, self);\n      cipop(mrb);\n    }\n    else {\n      int keep = mrb_ci_bidx(ci) + 1; /* receiver + block */\n      ret = mrb_top_run(mrb, p, self, keep);\n    }\n    if (mrb->exc && mrb->jmp) {\n      mrb_exc_raise(mrb, mrb_obj_value(mrb->exc));\n    }\n    return ret;\n  }\n}\n\n/* 15.3.1.3.4  */\n/* 15.3.1.3.44 */\n/*\n *  call-seq:\n *     obj.send(symbol [, args...])        -> obj\n *     obj.__send__(symbol [, args...])      -> obj\n *\n *  Invokes the method identified by _symbol_, passing it any\n *  arguments specified. You can use <code>__send__</code> if the name\n *  +send+ clashes with an existing method in _obj_.\n *\n *     class Klass\n *       def hello(*args)\n *         \"Hello \" + args.join(' ')\n *       end\n *     end\n *     k = Klass.new\n *     k.send :hello, \"gentle\", \"readers\"   #=> \"Hello gentle readers\"\n */\nmrb_value\nmrb_f_send(mrb_state *mrb, mrb_value self)\n{\n  mrb_sym name;\n  mrb_value block, *regs;\n  mrb_method_t m;\n  struct RClass *c;\n  mrb_callinfo *ci = mrb->c->ci;\n  int n = ci->n;\n\n  if (ci->cci > CINFO_NONE) {\n  funcall:;\n    const mrb_value *argv;\n    mrb_int argc;\n    mrb_get_args(mrb, \"n*&\", &name, &argv, &argc, &block);\n    return mrb_funcall_with_block(mrb, self, name, argc, argv, block);\n  }\n\n  regs = mrb->c->ci->stack+1;\n\n  if (n == 0) {\n  argnum_error:\n    mrb_argnum_error(mrb, 0, 1, -1);\n  }\n  else if (n == 15) {\n    if (RARRAY_LEN(regs[0]) == 0) goto argnum_error;\n    name = mrb_obj_to_sym(mrb, RARRAY_PTR(regs[0])[0]);\n  }\n  else {\n    name = mrb_obj_to_sym(mrb, regs[0]);\n  }\n\n  c = mrb_class(mrb, self);\n  m = mrb_method_search_vm(mrb, &c, name);\n  if (MRB_METHOD_UNDEF_P(m)) {            /* call method_mising */\n    goto funcall;\n  }\n\n  ci->mid = name;\n  ci->u.target_class = c;\n  /* remove first symbol from arguments */\n  if (n == 15) {     /* variable length arguments */\n    regs[0] = mrb_ary_subseq(mrb, regs[0], 1, RARRAY_LEN(regs[0]) - 1);\n  }\n  else { /* n > 0 */\n    for (int i=0; i<n; i++) {\n      regs[i] = regs[i+1];\n    }\n    regs[n] = regs[n+1];        /* copy kdict or block */\n    if (ci->nk > 0) {\n      regs[n+1] = regs[n+2];    /* copy block */\n    }\n    ci->n--;\n  }\n\n  if (MRB_METHOD_CFUNC_P(m)) {\n    if (MRB_METHOD_NOARG_P(m)) {\n      check_method_noarg(mrb, ci);\n    }\n\n    if (MRB_METHOD_PROC_P(m)) {\n      mrb_vm_ci_proc_set(ci, MRB_METHOD_PROC(m));\n    }\n    return MRB_METHOD_CFUNC(m)(mrb, self);\n  }\n  return exec_irep(mrb, self, MRB_METHOD_PROC(m));\n}\n\nstatic void\ncheck_block(mrb_state *mrb, mrb_value blk)\n{\n  if (mrb_nil_p(blk)) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"no block given\");\n  }\n  if (!mrb_proc_p(blk)) {\n    mrb_raise(mrb, E_TYPE_ERROR, \"not a block\");\n  }\n}\n\nstatic mrb_value\neval_under(mrb_state *mrb, mrb_value self, mrb_value blk, struct RClass *c)\n{\n  struct RProc *p;\n  mrb_callinfo *ci;\n  int nregs;\n\n  check_block(mrb, blk);\n  ci = mrb->c->ci;\n  if (ci->cci == CINFO_DIRECT) {\n    return mrb_yield_with_class(mrb, blk, 1, &self, self, c);\n  }\n  ci->u.target_class = c;\n  p = mrb_proc_ptr(blk);\n  mrb_vm_ci_proc_set(ci, p);\n  ci->n = 1;\n  ci->nk = 0;\n  ci->mid = ci[-1].mid;\n  if (MRB_PROC_CFUNC_P(p)) {\n    mrb_stack_extend(mrb, 4);\n    mrb->c->ci->stack[0] = self;\n    mrb->c->ci->stack[1] = self;\n    mrb->c->ci->stack[2] = mrb_nil_value();\n    return MRB_PROC_CFUNC(p)(mrb, self);\n  }\n  nregs = p->body.irep->nregs;\n  if (nregs < 4) nregs = 4;\n  mrb_stack_extend(mrb, nregs);\n  mrb->c->ci->stack[0] = self;\n  mrb->c->ci->stack[1] = self;\n  stack_clear(mrb->c->ci->stack+2, nregs-2);\n  ci = cipush(mrb, 0, 0, NULL, NULL, 0, 0);\n\n  return self;\n}\n\n/* 15.2.2.4.35 */\n/*\n *  call-seq:\n *     mod.class_eval {| | block }  -> obj\n *     mod.module_eval {| | block } -> obj\n *\n *  Evaluates block in the context of _mod_. This can\n *  be used to add methods to a class. <code>module_eval</code> returns\n *  the result of evaluating its argument.\n */\nmrb_value\nmrb_mod_module_eval(mrb_state *mrb, mrb_value mod)\n{\n  mrb_value a, b;\n\n  if (mrb_get_args(mrb, \"|S&\", &a, &b) == 1) {\n    mrb_raise(mrb, E_NOTIMP_ERROR, \"module_eval/class_eval with string not implemented\");\n  }\n  return eval_under(mrb, mod, b, mrb_class_ptr(mod));\n}\n\n/* 15.3.1.3.18 */\n/*\n *  call-seq:\n *     obj.instance_eval {| | block }                       -> obj\n *\n *  Evaluates the given block,within  the context of the receiver (_obj_).\n *  In order to set the context, the variable +self+ is set to _obj_ while\n *  the code is executing, giving the code access to _obj_'s\n *  instance variables. In the version of <code>instance_eval</code>\n *  that takes a +String+, the optional second and third\n *  parameters supply a filename and starting line number that are used\n *  when reporting compilation errors.\n *\n *     class KlassWithSecret\n *       def initialize\n *         @secret = 99\n *       end\n *     end\n *     k = KlassWithSecret.new\n *     k.instance_eval { @secret }   #=> 99\n */\nmrb_value\nmrb_obj_instance_eval(mrb_state *mrb, mrb_value self)\n{\n  mrb_value a, b;\n\n  if (mrb_get_args(mrb, \"|S&\", &a, &b) == 1) {\n    mrb_raise(mrb, E_NOTIMP_ERROR, \"instance_eval with string not implemented\");\n  }\n  return eval_under(mrb, self, b, mrb_singleton_class_ptr(mrb, self));\n}\n\nMRB_API mrb_value\nmrb_yield_with_class(mrb_state *mrb, mrb_value b, mrb_int argc, const mrb_value *argv, mrb_value self, struct RClass *c)\n{\n  struct RProc *p;\n  mrb_sym mid = mrb->c->ci->mid;\n  mrb_callinfo *ci;\n  mrb_value val;\n  mrb_int n;\n\n  check_block(mrb, b);\n  ci = mrb->c->ci;\n  n = mrb_ci_nregs(ci);\n  p = mrb_proc_ptr(b);\n  ci = cipush(mrb, n, CINFO_SKIP, c, p, mid, 0 /* dummy */);\n  ci->nk = 0;\n  if (argc >= CALL_MAXARGS) {\n    ci->n = 15;\n    n = 3;\n  }\n  else {\n    ci->n = argc;\n    n = argc + 2;\n  }\n  mrb_stack_extend(mrb, n);\n  mrb->c->ci->stack[0] = self;\n  if (ci->n == 15) {\n    mrb->c->ci->stack[1] = mrb_ary_new_from_values(mrb, argc, argv);\n    argc = 1;\n  }\n  else if (argc > 0) {\n    stack_copy(mrb->c->ci->stack+1, argv, argc);\n  }\n  mrb->c->ci->stack[argc+1] = mrb_nil_value(); /* clear blk */\n\n  if (MRB_PROC_CFUNC_P(p)) {\n    ci->cci = CINFO_DIRECT;\n    val = MRB_PROC_CFUNC(p)(mrb, self);\n    cipop(mrb);\n  }\n  else {\n    val = mrb_run(mrb, p, self);\n  }\n  return val;\n}\n\nMRB_API mrb_value\nmrb_yield_argv(mrb_state *mrb, mrb_value b, mrb_int argc, const mrb_value *argv)\n{\n  struct RProc *p = mrb_proc_ptr(b);\n\n  return mrb_yield_with_class(mrb, b, argc, argv, MRB_PROC_ENV(p)->stack[0], MRB_PROC_TARGET_CLASS(p));\n}\n\nMRB_API mrb_value\nmrb_yield(mrb_state *mrb, mrb_value b, mrb_value arg)\n{\n  struct RProc *p = mrb_proc_ptr(b);\n\n  return mrb_yield_with_class(mrb, b, 1, &arg, MRB_PROC_ENV(p)->stack[0], MRB_PROC_TARGET_CLASS(p));\n}\n\nmrb_value\nmrb_yield_cont(mrb_state *mrb, mrb_value b, mrb_value self, mrb_int argc, const mrb_value *argv)\n{\n  struct RProc *p;\n  mrb_callinfo *ci;\n\n  check_block(mrb, b);\n  p = mrb_proc_ptr(b);\n  ci = mrb->c->ci;\n\n  mrb_stack_extend(mrb, 4);\n  mrb->c->ci->stack[1] = mrb_ary_new_from_values(mrb, argc, argv);\n  mrb->c->ci->stack[2] = mrb_nil_value();\n  mrb->c->ci->stack[3] = mrb_nil_value();\n  ci->n = 15;\n  ci->nk = 0;\n  return exec_irep(mrb, self, p);\n}\n\nstatic struct RBreak*\nbreak_new(mrb_state *mrb, uint32_t tag, const struct RProc *p, mrb_value val)\n{\n  struct RBreak *brk;\n\n  brk = MRB_OBJ_ALLOC(mrb, MRB_TT_BREAK, NULL);\n  mrb_break_proc_set(brk, p);\n  mrb_break_value_set(brk, val);\n  mrb_break_tag_set(brk, tag);\n\n  return brk;\n}\n\n#define MRB_CATCH_FILTER_RESCUE (UINT32_C(1) << MRB_CATCH_RESCUE)\n#define MRB_CATCH_FILTER_ENSURE (UINT32_C(1) << MRB_CATCH_ENSURE)\n#define MRB_CATCH_FILTER_ALL    (MRB_CATCH_FILTER_RESCUE | MRB_CATCH_FILTER_ENSURE)\n\nstatic const struct mrb_irep_catch_handler *\ncatch_handler_find(mrb_state *mrb, mrb_callinfo *ci, const mrb_code *pc, uint32_t filter)\n{\n  const mrb_irep *irep;\n  ptrdiff_t xpc;\n  size_t cnt;\n  const struct mrb_irep_catch_handler *e;\n\n/* The comparison operators use `>` and `<=` because pc already points to the next instruction */\n#define catch_cover_p(pc, beg, end) ((pc) > (ptrdiff_t)(beg) && (pc) <= (ptrdiff_t)(end))\n\n  if (ci->proc == NULL || MRB_PROC_CFUNC_P(ci->proc)) return NULL;\n  irep = ci->proc->body.irep;\n  if (irep->clen < 1) return NULL;\n  xpc = pc - irep->iseq;\n  /* If it retry at the top level, pc will be 0, so check with -1 as the start position */\n  mrb_assert(catch_cover_p(xpc, -1, irep->ilen));\n  if (!catch_cover_p(xpc, -1, irep->ilen)) return NULL;\n\n  /* Currently uses a simple linear search to avoid processing complexity. */\n  cnt = irep->clen;\n  e = mrb_irep_catch_handler_table(irep) + cnt - 1;\n  for (; cnt > 0; cnt --, e --) {\n    if (((UINT32_C(1) << e->type) & filter) &&\n        catch_cover_p(xpc, mrb_irep_catch_handler_unpack(e->begin), mrb_irep_catch_handler_unpack(e->end))) {\n      return e;\n    }\n  }\n\n#undef catch_cover_p\n\n  return NULL;\n}\n\ntypedef enum {\n  LOCALJUMP_ERROR_RETURN = 0,\n  LOCALJUMP_ERROR_BREAK = 1,\n  LOCALJUMP_ERROR_YIELD = 2\n} localjump_error_kind;\n\nstatic void\nlocaljump_error(mrb_state *mrb, localjump_error_kind kind)\n{\n  char kind_str[3][7] = { \"return\", \"break\", \"yield\" };\n  char kind_str_len[] = { 6, 5, 5 };\n  static const char lead[] = \"unexpected \";\n  mrb_value msg;\n  mrb_value exc;\n\n  msg = mrb_str_new_capa(mrb, sizeof(lead) + 7);\n  mrb_str_cat(mrb, msg, lead, sizeof(lead) - 1);\n  mrb_str_cat(mrb, msg, kind_str[kind], kind_str_len[kind]);\n  exc = mrb_exc_new_str(mrb, E_LOCALJUMP_ERROR, msg);\n  mrb_exc_set(mrb, exc);\n}\n\nstatic void\nargnum_error(mrb_state *mrb, mrb_int num)\n{\n  mrb_value exc;\n  mrb_value str;\n  mrb_int argc = mrb->c->ci->n;\n\n  if (argc == 15) {\n    mrb_value args = mrb->c->ci->stack[1];\n    if (mrb_array_p(args)) {\n      argc = RARRAY_LEN(args);\n    }\n  }\n  if (argc == 0 && mrb->c->ci->nk != 0 && !mrb_hash_empty_p(mrb, mrb->c->ci->stack[1])) {\n    argc++;\n  }\n  str = mrb_format(mrb, \"wrong number of arguments (given %i, expected %i)\", argc, num);\n  exc = mrb_exc_new_str(mrb, E_ARGUMENT_ERROR, str);\n  mrb_exc_set(mrb, exc);\n}\n\nstatic mrb_bool\nbreak_tag_p(struct RBreak *brk, uint32_t tag)\n{\n  return (brk != NULL && brk->tt == MRB_TT_BREAK) ? TRUE : FALSE;\n}\n\nstatic void\nprepare_tagged_break(mrb_state *mrb, uint32_t tag, const struct RProc *proc, mrb_value val)\n{\n  if (break_tag_p((struct RBreak*)mrb->exc, tag)) {\n    mrb_break_tag_set((struct RBreak*)mrb->exc, tag);\n  }\n  else {\n    mrb->exc = (struct RObject*)break_new(mrb, tag, proc, val);\n  }\n}\n\n#define THROW_TAGGED_BREAK(mrb, tag, proc, val) \\\n  do { \\\n    prepare_tagged_break(mrb, tag, proc, val); \\\n    goto L_CATCH_TAGGED_BREAK; \\\n  } while (0)\n\n#define UNWIND_ENSURE(mrb, ci, pc, tag, proc, val) \\\n  do { \\\n    ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ENSURE); \\\n    if (ch) { \\\n      THROW_TAGGED_BREAK(mrb, tag, proc, val); \\\n    } \\\n  } while (0)\n\n/*\n *  CHECKPOINT_RESTORE(tag) {\n *    This part is executed when jumping by the same \"tag\" of RBreak (it is not executed the first time).\n *    Write the code required (initialization of variables, etc.) for the subsequent processing.\n *  }\n *  CHECKPOINT_MAIN(tag) {\n *    This part is always executed.\n *  }\n *  CHECKPOINT_END(tag);\n *\n *  ...\n *\n *  // Jump to CHECKPOINT_RESTORE with the same \"tag\".\n *  goto CHECKPOINT_LABEL_MAKE(tag);\n */\n\n#define CHECKPOINT_LABEL_MAKE(tag) L_CHECKPOINT_ ## tag\n\n#define CHECKPOINT_RESTORE(tag) \\\n  do { \\\n    if (FALSE) { \\\n      CHECKPOINT_LABEL_MAKE(tag): \\\n      do {\n\n#define CHECKPOINT_MAIN(tag) \\\n      } while (0); \\\n    } \\\n    do {\n\n#define CHECKPOINT_END(tag) \\\n    } while (0); \\\n  } while (0)\n\n#ifdef MRB_USE_DEBUG_HOOK\n#define CODE_FETCH_HOOK(mrb, irep, pc, regs) if ((mrb)->code_fetch_hook) (mrb)->code_fetch_hook((mrb), (irep), (pc), (regs));\n#else\n#define CODE_FETCH_HOOK(mrb, irep, pc, regs)\n#endif\n\n#ifdef MRB_BYTECODE_DECODE_OPTION\n#define BYTECODE_DECODER(x) ((mrb)->bytecode_decoder)?(mrb)->bytecode_decoder((mrb), (x)):(x)\n#else\n#define BYTECODE_DECODER(x) (x)\n#endif\n\n#ifndef MRB_NO_DIRECT_THREADING\n#if defined __GNUC__ || defined __clang__ || defined __INTEL_COMPILER\n#define DIRECT_THREADED\n#endif\n#endif /* ifndef MRB_NO_DIRECT_THREADING */\n\n#ifndef DIRECT_THREADED\n\n#define INIT_DISPATCH for (;;) { insn = BYTECODE_DECODER(*pc); CODE_FETCH_HOOK(mrb, irep, pc, regs); switch (insn) {\n#define CASE(insn,ops) case insn: pc++; FETCH_ ## ops (); mrb->c->ci->pc = pc; L_ ## insn ## _BODY:\n#define NEXT goto L_END_DISPATCH\n#define JUMP NEXT\n#define END_DISPATCH L_END_DISPATCH:;}}\n\n#else\n\n#define INIT_DISPATCH JUMP; return mrb_nil_value();\n#define CASE(insn,ops) L_ ## insn: pc++; FETCH_ ## ops (); mrb->c->ci->pc = pc; L_ ## insn ## _BODY:\n#define NEXT insn=BYTECODE_DECODER(*pc); CODE_FETCH_HOOK(mrb, irep, pc, regs); goto *optable[insn]\n#define JUMP NEXT\n\n#define END_DISPATCH\n\n#endif\n\nMRB_API mrb_value\nmrb_vm_run(mrb_state *mrb, const struct RProc *proc, mrb_value self, mrb_int stack_keep)\n{\n  const mrb_irep *irep = proc->body.irep;\n  mrb_value result;\n  struct mrb_context *c = mrb->c;\n  ptrdiff_t cioff = c->ci - c->cibase;\n  mrb_int nregs = irep->nregs;\n\n  if (!c->stbase) {\n    stack_init(mrb);\n  }\n  if (stack_keep > nregs)\n    nregs = stack_keep;\n  mrb_stack_extend(mrb, nregs);\n  stack_clear(c->ci->stack + stack_keep, nregs - stack_keep);\n  c->ci->stack[0] = self;\n  result = mrb_vm_exec(mrb, proc, irep->iseq);\n  if (mrb->c != c) {\n    if (mrb->c->fib) {\n      mrb_write_barrier(mrb, (struct RBasic*)mrb->c->fib);\n    }\n    mrb->c = c;\n  }\n  else if (c->ci - c->cibase > cioff) {\n    c->ci = c->cibase + cioff;\n  }\n  return result;\n}\n\nstatic struct RClass*\ncheck_target_class(mrb_state *mrb)\n{\n  struct RClass *target = mrb_vm_ci_target_class(mrb->c->ci);\n  if (!target) {\n    mrb_value exc = mrb_exc_new_lit(mrb, E_TYPE_ERROR, \"no target class or module\");\n    mrb_exc_set(mrb, exc);\n  }\n  return target;\n}\n\nstatic mrb_value\nhash_new_from_values(mrb_state *mrb, mrb_int argc, mrb_value *regs)\n{\n  mrb_value hash = mrb_hash_new_capa(mrb, argc);\n  while (argc--) {\n    mrb_hash_set(mrb, hash, regs[0], regs[1]);\n    regs += 2;\n  }\n  return hash;\n}\n\n#define ARGUMENT_NORMALIZE(arg_base, arg_info, insn) do { \\\n  int n = *(arg_info)&0xf; \\\n  int nk = (*(arg_info)>>4)&0xf; \\\n  mrb_int bidx = (arg_base) + mrb_bidx(*(arg_info)); \\\n  if (nk == CALL_MAXARGS) { \\\n    mrb_ensure_hash_type(mrb, regs[(arg_base)+(n==CALL_MAXARGS?1:n)+1]); \\\n  } \\\n  else if (nk > 0) {  /* pack keyword arguments */ \\\n    mrb_int kidx = (arg_base)+(n==CALL_MAXARGS?1:n)+1; \\\n    mrb_value kdict = hash_new_from_values(mrb, nk, regs+kidx); \\\n    regs[kidx] = kdict; \\\n    nk = CALL_MAXARGS; \\\n    *(arg_info) = n | (nk<<4); \\\n  } \\\n  \\\n  mrb_assert(bidx < irep->nregs+(arg_base)); \\\n  mrb_int new_bidx = (arg_base)+mrb_bidx(*(arg_info)); \\\n  if ((insn) == OP_SEND) { \\\n    /* clear block argument */ \\\n    SET_NIL_VALUE(regs[new_bidx]); \\\n    SET_NIL_VALUE(blk); \\\n  } \\\n  else { \\\n    blk = regs[bidx]; \\\n    if (!mrb_nil_p(blk) && !mrb_proc_p(blk)) { \\\n      blk = mrb_type_convert(mrb, blk, MRB_TT_PROC, MRB_SYM(to_proc)); \\\n      /* The stack might have been reallocated during mrb_type_convert(), see #3622 */ \\\n    } \\\n    regs[new_bidx] = blk; \\\n  } \\\n} while (0)\n\nMRB_API mrb_value\nmrb_vm_exec(mrb_state *mrb, const struct RProc *proc, const mrb_code *pc)\n{\n  /* mrb_assert(MRB_PROC_CFUNC_P(proc)) */\n  const mrb_irep *irep = proc->body.irep;\n  const mrb_pool_value *pool = irep->pool;\n  const mrb_sym *syms = irep->syms;\n  mrb_code insn;\n  int ai = mrb_gc_arena_save(mrb);\n  struct mrb_jmpbuf *prev_jmp = mrb->jmp;\n  struct mrb_jmpbuf c_jmp;\n  uint32_t a;\n  uint16_t b;\n  uint16_t c;\n  mrb_sym mid;\n  const struct mrb_irep_catch_handler *ch;\n\n#ifdef DIRECT_THREADED\n  static const void * const optable[] = {\n#define OPCODE(x,_) &&L_OP_ ## x,\n#include \"mruby/ops.h\"\n#undef OPCODE\n  };\n#endif\n\n  mrb_bool exc_catched = FALSE;\nRETRY_TRY_BLOCK:\n\n  MRB_TRY(&c_jmp) {\n\n  if (exc_catched) {\n    exc_catched = FALSE;\n    mrb_gc_arena_restore(mrb, ai);\n    if (mrb->exc && mrb->exc->tt == MRB_TT_BREAK)\n      goto L_BREAK;\n    goto L_RAISE;\n  }\n  mrb->jmp = &c_jmp;\n  mrb_vm_ci_proc_set(mrb->c->ci, proc);\n\n#define regs (mrb->c->ci->stack)\n  INIT_DISPATCH {\n    CASE(OP_NOP, Z) {\n      /* do nothing */\n      NEXT;\n    }\n\n    CASE(OP_MOVE, BB) {\n      regs[a] = regs[b];\n      NEXT;\n    }\n\n    CASE(OP_LOADL, BB) {\n      switch (pool[b].tt) {   /* number */\n      case IREP_TT_INT32:\n        regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i32);\n        break;\n      case IREP_TT_INT64:\n#if defined(MRB_INT64)\n        regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i64);\n        break;\n#else\n#if defined(MRB_64BIT)\n        if (INT32_MIN <= pool[b].u.i64 && pool[b].u.i64 <= INT32_MAX) {\n          regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i64);\n          break;\n        }\n#endif\n        goto L_INT_OVERFLOW;\n#endif\n      case IREP_TT_BIGINT:\n        goto L_INT_OVERFLOW;\n#ifndef MRB_NO_FLOAT\n      case IREP_TT_FLOAT:\n        regs[a] = mrb_float_value(mrb, pool[b].u.f);\n        break;\n#endif\n      default:\n        /* should not happen (tt:string) */\n        regs[a] = mrb_nil_value();\n        break;\n      }\n      NEXT;\n    }\n\n    CASE(OP_LOADI, BB) {\n      SET_FIXNUM_VALUE(regs[a], b);\n      NEXT;\n    }\n\n    CASE(OP_LOADINEG, BB) {\n      SET_FIXNUM_VALUE(regs[a], -b);\n      NEXT;\n    }\n\n    CASE(OP_LOADI__1,B) goto L_LOADI;\n    CASE(OP_LOADI_0,B) goto L_LOADI;\n    CASE(OP_LOADI_1,B) goto L_LOADI;\n    CASE(OP_LOADI_2,B) goto L_LOADI;\n    CASE(OP_LOADI_3,B) goto L_LOADI;\n    CASE(OP_LOADI_4,B) goto L_LOADI;\n    CASE(OP_LOADI_5,B) goto L_LOADI;\n    CASE(OP_LOADI_6,B) goto L_LOADI;\n    CASE(OP_LOADI_7, B) {\n    L_LOADI:\n      SET_FIXNUM_VALUE(regs[a], (mrb_int)insn - (mrb_int)OP_LOADI_0);\n      NEXT;\n    }\n\n    CASE(OP_LOADI16, BS) {\n      SET_FIXNUM_VALUE(regs[a], (mrb_int)(int16_t)b);\n      NEXT;\n    }\n\n    CASE(OP_LOADI32, BSS) {\n      SET_INT_VALUE(mrb, regs[a], (int32_t)(((uint32_t)b<<16)+c));\n      NEXT;\n    }\n\n    CASE(OP_LOADSYM, BB) {\n      SET_SYM_VALUE(regs[a], syms[b]);\n      NEXT;\n    }\n\n    CASE(OP_LOADNIL, B) {\n      SET_NIL_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_LOADSELF, B) {\n      regs[a] = regs[0];\n      NEXT;\n    }\n\n    CASE(OP_LOADT, B) {\n      SET_TRUE_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_LOADF, B) {\n      SET_FALSE_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETGV, BB) {\n      mrb_value val = mrb_gv_get(mrb, syms[b]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETGV, BB) {\n      mrb_gv_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETSV, BB) {\n      mrb_value val = mrb_vm_special_get(mrb, syms[b]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETSV, BB) {\n      mrb_vm_special_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETIV, BB) {\n      regs[a] = mrb_iv_get(mrb, regs[0], syms[b]);\n      NEXT;\n    }\n\n    CASE(OP_SETIV, BB) {\n      mrb_iv_set(mrb, regs[0], syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETCV, BB) {\n      mrb_value val;\n      val = mrb_vm_cv_get(mrb, syms[b]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETCV, BB) {\n      mrb_vm_cv_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETIDX, B) {\n      mrb_value va = regs[a], vb = regs[a+1];\n      switch (mrb_type(va)) {\n      case MRB_TT_ARRAY:\n        if (!mrb_integer_p(vb)) goto getidx_fallback;\n        regs[a] = mrb_ary_entry(va, mrb_integer(vb));\n        break;\n      case MRB_TT_HASH:\n        va = mrb_hash_get(mrb, va, vb);\n        regs[a] = va;\n        break;\n      case MRB_TT_STRING:\n        switch (mrb_type(vb)) {\n        case MRB_TT_INTEGER:\n        case MRB_TT_STRING:\n        case MRB_TT_RANGE:\n          va = mrb_str_aref(mrb, va, vb, mrb_undef_value());\n          regs[a] = va;\n          break;\n        default:\n          goto getidx_fallback;\n        }\n        break;\n      default:\n      getidx_fallback:\n        mid = MRB_OPSYM(aref);\n        goto L_SEND_SYM;\n      }\n      NEXT;\n    }\n\n    CASE(OP_SETIDX, B) {\n      c = 2;\n      mid = MRB_OPSYM(aset);\n      SET_NIL_VALUE(regs[a+3]);\n      goto L_SENDB_SYM;\n    }\n\n    CASE(OP_GETCONST, BB) {\n      mrb_value v = mrb_vm_const_get(mrb, syms[b]);\n      regs[a] = v;\n      NEXT;\n    }\n\n    CASE(OP_SETCONST, BB) {\n      mrb_vm_const_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETMCNST, BB) {\n      mrb_value v = mrb_const_get(mrb, regs[a], syms[b]);\n      regs[a] = v;\n      NEXT;\n    }\n\n    CASE(OP_SETMCNST, BB) {\n      mrb_const_set(mrb, regs[a+1], syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETUPVAR, BBB) {\n      mrb_value *regs_a = regs + a;\n      struct REnv *e = uvenv(mrb, c);\n\n      if (e && b < MRB_ENV_LEN(e)) {\n        *regs_a = e->stack[b];\n      }\n      else {\n        *regs_a = mrb_nil_value();\n      }\n      NEXT;\n    }\n\n    CASE(OP_SETUPVAR, BBB) {\n      struct REnv *e = uvenv(mrb, c);\n\n      if (e) {\n        mrb_value *regs_a = regs + a;\n\n        if (b < MRB_ENV_LEN(e)) {\n          e->stack[b] = *regs_a;\n          mrb_write_barrier(mrb, (struct RBasic*)e);\n        }\n      }\n      NEXT;\n    }\n\n    CASE(OP_JMP, S) {\n      pc += (int16_t)a;\n      JUMP;\n    }\n    CASE(OP_JMPIF, BS) {\n      if (mrb_test(regs[a])) {\n        pc += (int16_t)b;\n        JUMP;\n      }\n      NEXT;\n    }\n    CASE(OP_JMPNOT, BS) {\n      if (!mrb_test(regs[a])) {\n        pc += (int16_t)b;\n        JUMP;\n      }\n      NEXT;\n    }\n    CASE(OP_JMPNIL, BS) {\n      if (mrb_nil_p(regs[a])) {\n        pc += (int16_t)b;\n        JUMP;\n      }\n      NEXT;\n    }\n\n    CASE(OP_JMPUW, S) {\n      a = (uint32_t)((pc - irep->iseq) + (int16_t)a);\n      CHECKPOINT_RESTORE(RBREAK_TAG_JUMP) {\n        struct RBreak *brk = (struct RBreak*)mrb->exc;\n        mrb_value target = mrb_break_value_get(brk);\n        mrb_assert(mrb_integer_p(target));\n        a = (uint32_t)mrb_integer(target);\n        mrb_assert(a >= 0 && a < irep->ilen);\n      }\n      CHECKPOINT_MAIN(RBREAK_TAG_JUMP) {\n        ch = catch_handler_find(mrb, mrb->c->ci, pc, MRB_CATCH_FILTER_ENSURE);\n        if (ch) {\n          /* avoiding a jump from a catch handler into the same handler */\n          if (a < mrb_irep_catch_handler_unpack(ch->begin) || a >= mrb_irep_catch_handler_unpack(ch->end)) {\n            THROW_TAGGED_BREAK(mrb, RBREAK_TAG_JUMP, proc, mrb_fixnum_value(a));\n          }\n        }\n      }\n      CHECKPOINT_END(RBREAK_TAG_JUMP);\n\n      mrb->exc = NULL; /* clear break object */\n      pc = irep->iseq + a;\n      JUMP;\n    }\n\n    CASE(OP_EXCEPT, B) {\n      mrb_value exc;\n\n      if (mrb->exc == NULL) {\n        exc = mrb_nil_value();\n      }\n      else {\n        switch (mrb->exc->tt) {\n        case MRB_TT_BREAK:\n        case MRB_TT_EXCEPTION:\n          exc = mrb_obj_value(mrb->exc);\n          break;\n        default:\n          mrb_assert(!\"bad mrb_type\");\n          exc = mrb_nil_value();\n          break;\n        }\n        mrb->exc = NULL;\n      }\n      regs[a] = exc;\n      NEXT;\n    }\n    CASE(OP_RESCUE, BB) {\n      mrb_value exc = regs[a];  /* exc on stack */\n      mrb_value e = regs[b];\n      struct RClass *ec;\n\n      switch (mrb_type(e)) {\n      case MRB_TT_CLASS:\n      case MRB_TT_MODULE:\n        break;\n      default:\n        {\n          mrb_value exc;\n\n          exc = mrb_exc_new_lit(mrb, E_TYPE_ERROR,\n                                    \"class or module required for rescue clause\");\n          mrb_exc_set(mrb, exc);\n          goto L_RAISE;\n        }\n      }\n      ec = mrb_class_ptr(e);\n      regs[b] = mrb_bool_value(mrb_obj_is_kind_of(mrb, exc, ec));\n      NEXT;\n    }\n\n    CASE(OP_RAISEIF, B) {\n      mrb_value exc = regs[a];\n      if (mrb_break_p(exc)) {\n        mrb->exc = mrb_obj_ptr(exc);\n        goto L_BREAK;\n      }\n      mrb_exc_set(mrb, exc);\n      if (mrb->exc) {\n        goto L_RAISE;\n      }\n      NEXT;\n    }\n\n    CASE(OP_SSEND, BBB) {\n      regs[a] = regs[0];\n      insn = OP_SEND;\n    }\n    goto L_SENDB;\n\n    CASE(OP_SSENDB, BBB) {\n      regs[a] = regs[0];\n    }\n    goto L_SENDB;\n\n    CASE(OP_SEND, BBB)\n    goto L_SENDB;\n\n    L_SEND_SYM:\n    c = 1;\n    /* push nil after arguments */\n    SET_NIL_VALUE(regs[a+2]);\n    goto L_SENDB_SYM;\n\n    CASE(OP_SENDB, BBB)\n    L_SENDB:\n    mid = syms[b];\n    L_SENDB_SYM:\n    {\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_method_t m;\n      struct RClass *cls;\n      mrb_value recv, blk;\n\n      ARGUMENT_NORMALIZE(a, &c, insn);\n\n      recv = regs[a];\n      cls = mrb_class(mrb, recv);\n      m = mrb_method_search_vm(mrb, &cls, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        m = prepare_missing(mrb, recv, mid, &cls, a, &c, blk, 0);\n        mid = MRB_SYM(method_missing);\n      }\n\n      /* push callinfo */\n      ci = cipush(mrb, a, 0, cls, NULL, mid, c);\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        if (MRB_METHOD_PROC_P(m)) {\n          struct RProc *p = MRB_METHOD_PROC(m);\n\n          mrb_vm_ci_proc_set(ci, p);\n          recv = p->body.func(mrb, recv);\n        }\n        else {\n          if (MRB_METHOD_NOARG_P(m)) {\n            check_method_noarg(mrb, ci);\n          }\n          recv = MRB_METHOD_FUNC(m)(mrb, recv);\n        }\n        mrb_gc_arena_shrink(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        ci = mrb->c->ci;\n        if (mrb_proc_p(blk)) {\n          struct RProc *p = mrb_proc_ptr(blk);\n          if (p && !MRB_PROC_STRICT_P(p) && MRB_PROC_ENV(p) == mrb_vm_ci_env(&ci[-1])) {\n            p->flags |= MRB_PROC_ORPHAN;\n          }\n        }\n        if (!ci->u.target_class) { /* return from context modifying method (resume/yield) */\n          if (ci->cci == CINFO_RESUMED) {\n            mrb->jmp = prev_jmp;\n            return recv;\n          }\n          else {\n            mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n            proc = ci[-1].proc;\n            irep = proc->body.irep;\n            pool = irep->pool;\n            syms = irep->syms;\n          }\n        }\n        ci->stack[0] = recv;\n        /* pop stackpos */\n        ci = cipop(mrb);\n        pc = ci->pc;\n      }\n      else {\n        /* setup environment for calling method */\n        mrb_vm_ci_proc_set(ci, (proc = MRB_METHOD_PROC(m)));\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        mrb_stack_extend(mrb, (irep->nregs < 4) ? 4 : irep->nregs);\n        pc = irep->iseq;\n      }\n    }\n    JUMP;\n\n    CASE(OP_CALL, Z) {\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_value recv = ci->stack[0];\n      struct RProc *m = mrb_proc_ptr(recv);\n\n      /* replace callinfo */\n      ci->u.target_class = MRB_PROC_TARGET_CLASS(m);\n      mrb_vm_ci_proc_set(ci, m);\n      if (MRB_PROC_ENV_P(m)) {\n        ci->mid = MRB_PROC_ENV(m)->mid;\n      }\n\n      /* prepare stack */\n      if (MRB_PROC_CFUNC_P(m)) {\n        recv = MRB_PROC_CFUNC(m)(mrb, recv);\n        mrb_gc_arena_shrink(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        /* pop stackpos */\n        ci = cipop(mrb);\n        pc = ci->pc;\n        ci[1].stack[0] = recv;\n        irep = mrb->c->ci->proc->body.irep;\n      }\n      else {\n        /* setup environment for calling method */\n        proc = m;\n        irep = m->body.irep;\n        if (!irep) {\n          mrb->c->ci->stack[0] = mrb_nil_value();\n          a = 0;\n          c = OP_R_NORMAL;\n          goto L_OP_RETURN_BODY;\n        }\n        mrb_int nargs = mrb_ci_bidx(ci)+1;\n        if (nargs < irep->nregs) {\n          mrb_stack_extend(mrb, irep->nregs);\n          stack_clear(regs+nargs, irep->nregs-nargs);\n        }\n        if (MRB_PROC_ENV_P(m)) {\n          regs[0] = MRB_PROC_ENV(m)->stack[0];\n        }\n        pc = irep->iseq;\n      }\n      pool = irep->pool;\n      syms = irep->syms;\n      JUMP;\n    }\n\n    CASE(OP_SUPER, BB) {\n      mrb_method_t m;\n      struct RClass *cls;\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_value recv, blk;\n      const struct RProc *p = ci->proc;\n      mrb_sym mid = ci->mid;\n      struct RClass* target_class = MRB_PROC_TARGET_CLASS(p);\n\n      if (MRB_PROC_ENV_P(p) && p->e.env->mid && p->e.env->mid != mid) { /* alias support */\n        mid = p->e.env->mid;    /* restore old mid */\n      }\n\n      if (mid == 0 || !target_class) {\n        mrb_value exc = mrb_exc_new_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if (target_class->flags & MRB_FL_CLASS_IS_PREPENDED) {\n        target_class = mrb_vm_ci_target_class(ci);\n      }\n      else if (target_class->tt == MRB_TT_MODULE) {\n        target_class = mrb_vm_ci_target_class(ci);\n        if (!target_class || target_class->tt != MRB_TT_ICLASS) {\n          goto super_typeerror;\n        }\n      }\n      recv = regs[0];\n      if (!mrb_obj_is_kind_of(mrb, recv, target_class)) {\n      super_typeerror: ;\n        mrb_value exc = mrb_exc_new_lit(mrb, E_TYPE_ERROR,\n                                            \"self has wrong type to call super in this context\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n\n      ARGUMENT_NORMALIZE(a, &b, OP_SUPER);\n\n      cls = target_class->super;\n      m = mrb_method_search_vm(mrb, &cls, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        m = prepare_missing(mrb, recv, mid, &cls, a, &b, blk, 1);\n        mid = MRB_SYM(method_missing);\n      }\n\n      /* push callinfo */\n      ci = cipush(mrb, a, 0, cls, NULL, mid, b);\n\n      /* prepare stack */\n      ci->stack[0] = recv;\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        mrb_value v;\n\n        if (MRB_METHOD_PROC_P(m)) {\n          mrb_vm_ci_proc_set(ci, MRB_METHOD_PROC(m));\n        }\n        v = MRB_METHOD_CFUNC(m)(mrb, recv);\n        mrb_gc_arena_restore(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        ci = mrb->c->ci;\n        mrb_assert(!mrb_break_p(v));\n        if (!mrb_vm_ci_target_class(ci)) { /* return from context modifying method (resume/yield) */\n          if (ci->cci == CINFO_RESUMED) {\n            mrb->jmp = prev_jmp;\n            return v;\n          }\n          else {\n            mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n            proc = ci[-1].proc;\n            irep = proc->body.irep;\n            pool = irep->pool;\n            syms = irep->syms;\n          }\n        }\n        mrb->c->ci->stack[0] = v;\n        ci = cipop(mrb);\n        pc = ci->pc;\n      }\n      else {\n        /* setup environment for calling method */\n        mrb_vm_ci_proc_set(ci, (proc = MRB_METHOD_PROC(m)));\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        mrb_stack_extend(mrb, (irep->nregs < 4) ? 4 : irep->nregs);\n        pc = irep->iseq;\n      }\n      JUMP;\n    }\n\n    CASE(OP_ARGARY, BS) {\n      mrb_int m1 = (b>>11)&0x3f;\n      mrb_int r  = (b>>10)&0x1;\n      mrb_int m2 = (b>>5)&0x1f;\n      mrb_int kd = (b>>4)&0x1;\n      mrb_int lv = (b>>0)&0xf;\n      mrb_value *stack;\n\n      if (mrb->c->ci->mid == 0 || mrb_vm_ci_target_class(mrb->c->ci) == NULL) {\n        mrb_value exc;\n\n      L_NOSUPER:\n        exc = mrb_exc_new_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if (lv == 0) stack = regs + 1;\n      else {\n        struct REnv *e = uvenv(mrb, lv-1);\n        if (!e) goto L_NOSUPER;\n        if (MRB_ENV_LEN(e) <= m1+r+m2+1)\n          goto L_NOSUPER;\n        stack = e->stack + 1;\n      }\n      if (r == 0) {\n        regs[a] = mrb_ary_new_from_values(mrb, m1+m2, stack);\n      }\n      else {\n        mrb_value *pp = NULL;\n        struct RArray *rest;\n        mrb_int len = 0;\n\n        if (mrb_array_p(stack[m1])) {\n          struct RArray *ary = mrb_ary_ptr(stack[m1]);\n\n          pp = ARY_PTR(ary);\n          len = ARY_LEN(ary);\n        }\n        regs[a] = mrb_ary_new_capa(mrb, m1+len+m2);\n        rest = mrb_ary_ptr(regs[a]);\n        if (m1 > 0) {\n          stack_copy(ARY_PTR(rest), stack, m1);\n        }\n        if (len > 0) {\n          stack_copy(ARY_PTR(rest)+m1, pp, len);\n        }\n        if (m2 > 0) {\n          stack_copy(ARY_PTR(rest)+m1+len, stack+m1+1, m2);\n        }\n        ARY_SET_LEN(rest, m1+len+m2);\n      }\n      if (kd) {\n        regs[a+1] = stack[m1+r+m2];\n        regs[a+2] = stack[m1+r+m2+1];\n      }\n      else {\n        regs[a+1] = stack[m1+r+m2];\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ENTER, W) {\n      mrb_int m1 = MRB_ASPEC_REQ(a);\n      mrb_int o  = MRB_ASPEC_OPT(a);\n      mrb_int r  = MRB_ASPEC_REST(a);\n      mrb_int m2 = MRB_ASPEC_POST(a);\n      mrb_int kd = (MRB_ASPEC_KEY(a) > 0 || MRB_ASPEC_KDICT(a))? 1 : 0;\n      /* unused\n      int b  = MRB_ASPEC_BLOCK(a);\n      */\n      mrb_int const len = m1 + o + r + m2;\n\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_int argc = ci->n;\n      mrb_value *argv = regs+1;\n      mrb_value * const argv0 = argv;\n      mrb_int const kw_pos = len + kd;    /* where kwhash should be */\n      mrb_int const blk_pos = kw_pos + 1; /* where block should be */\n      mrb_value blk = regs[mrb_ci_bidx(ci)];\n      mrb_value kdict = mrb_nil_value();\n\n      /* keyword arguments */\n      if (ci->nk > 0) {\n        mrb_int kidx = mrb_ci_kidx(ci);\n        kdict = regs[kidx];\n        if (!mrb_hash_p(kdict) || mrb_hash_size(mrb, kdict) == 0) {\n          kdict = mrb_nil_value();\n          ci->nk = 0;\n        }\n      }\n      if (!kd && !mrb_nil_p(kdict)) {\n        if (argc < 14) {\n          ci->n++;\n          argc++;    /* include kdict in normal arguments */\n        }\n        else if (argc == 14) {\n          /* pack arguments and kdict */\n          regs[1] = mrb_ary_new_from_values(mrb, argc+1, &regs[1]);\n          argc = ci->n = 15;\n        }\n        else {/* argc == 15 */\n          /* push kdict to packed arguments */\n          mrb_ary_push(mrb, regs[1], regs[2]);\n        }\n        ci->nk = 0;\n      }\n      if (kd && MRB_ASPEC_KEY(a) > 0 && mrb_hash_p(kdict)) {\n        kdict = mrb_hash_dup(mrb, kdict);\n      }\n\n      /* arguments is passed with Array */\n      if (argc == 15) {\n        struct RArray *ary = mrb_ary_ptr(regs[1]);\n        argv = ARY_PTR(ary);\n        argc = (int)ARY_LEN(ary);\n        mrb_gc_protect(mrb, regs[1]);\n      }\n\n      /* strict argument check */\n      if (ci->proc && MRB_PROC_STRICT_P(ci->proc)) {\n        if (argc < m1 + m2 || (r == 0 && argc > len)) {\n          argnum_error(mrb, m1+m2);\n          goto L_RAISE;\n        }\n      }\n      /* extract first argument array to arguments */\n      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {\n        mrb_gc_protect(mrb, argv[0]);\n        argc = (int)RARRAY_LEN(argv[0]);\n        argv = RARRAY_PTR(argv[0]);\n      }\n\n      /* rest arguments */\n      mrb_value rest = mrb_nil_value();\n      if (argc < len) {\n        mrb_int mlen = m2;\n        if (argc < m1+m2) {\n          mlen = m1 < argc ? argc - m1 : 0;\n        }\n\n        /* copy mandatory and optional arguments */\n        if (argv0 != argv && argv) {\n          value_move(&regs[1], argv, argc-mlen); /* m1 + o */\n        }\n        if (argc < m1) {\n          stack_clear(&regs[argc+1], m1-argc);\n        }\n        /* copy post mandatory arguments */\n        if (mlen) {\n          value_move(&regs[len-m2+1], &argv[argc-mlen], mlen);\n        }\n        if (mlen < m2) {\n          stack_clear(&regs[len-m2+mlen+1], m2-mlen);\n        }\n        /* initialize rest arguments with empty Array */\n        if (r) {\n          rest = mrb_ary_new_capa(mrb, 0);\n          regs[m1+o+1] = rest;\n        }\n        /* skip initializer of passed arguments */\n        if (o > 0 && argc > m1+m2)\n          pc += (argc - m1 - m2)*3;\n      }\n      else {\n        mrb_int rnum = 0;\n        if (argv0 != argv) {\n          value_move(&regs[1], argv, m1+o);\n        }\n        if (r) {\n          rnum = argc-m1-o-m2;\n          rest = mrb_ary_new_from_values(mrb, rnum, argv+m1+o);\n          regs[m1+o+1] = rest;\n        }\n        if (m2 > 0 && argc-m2 > m1) {\n          value_move(&regs[m1+o+r+1], &argv[m1+o+rnum], m2);\n        }\n        pc += o*3;\n      }\n\n      /* need to be update blk first to protect blk from GC */\n      regs[blk_pos] = blk;              /* move block */\n      if (kd) {\n        if (mrb_nil_p(kdict))\n          kdict = mrb_hash_new_capa(mrb, 0);\n        regs[kw_pos] = kdict;           /* set kwhash */\n      }\n\n      /* format arguments for generated code */\n      mrb->c->ci->n = len;\n\n      /* clear local (but non-argument) variables */\n      if (irep->nlocals-blk_pos-1 > 0) {\n        stack_clear(&regs[blk_pos+1], irep->nlocals-blk_pos-1);\n      }\n      JUMP;\n    }\n\n    CASE(OP_KARG, BB) {\n      mrb_value k = mrb_symbol_value(syms[b]);\n      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n      mrb_value kdict, v;\n\n      if (kidx < 0 || !mrb_hash_p(kdict=regs[kidx]) || !mrb_hash_key_p(mrb, kdict, k)) {\n        mrb_value str = mrb_format(mrb, \"missing keyword: %v\", k);\n        mrb_exc_set(mrb, mrb_exc_new_str(mrb, E_ARGUMENT_ERROR, str));\n        goto L_RAISE;\n      }\n      v = mrb_hash_get(mrb, kdict, k);\n      regs[a] = v;\n      mrb_hash_delete_key(mrb, kdict, k);\n      NEXT;\n    }\n\n    CASE(OP_KEY_P, BB) {\n      mrb_value k = mrb_symbol_value(syms[b]);\n      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n      mrb_value kdict;\n      mrb_bool key_p = FALSE;\n\n      if (kidx >= 0 && mrb_hash_p(kdict=regs[kidx])) {\n        key_p = mrb_hash_key_p(mrb, kdict, k);\n      }\n      regs[a] = mrb_bool_value(key_p);\n      NEXT;\n    }\n\n    CASE(OP_KEYEND, Z) {\n      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n      mrb_value kdict;\n\n      if (kidx >= 0 && mrb_hash_p(kdict=regs[kidx]) && !mrb_hash_empty_p(mrb, kdict)) {\n        mrb_value keys = mrb_hash_keys(mrb, kdict);\n        mrb_value key1 = RARRAY_PTR(keys)[0];\n        mrb_value str = mrb_format(mrb, \"unknown keyword: %v\", key1);\n        mrb_exc_set(mrb, mrb_exc_new_str(mrb, E_ARGUMENT_ERROR, str));\n        goto L_RAISE;\n      }\n      NEXT;\n    }\n\n    CASE(OP_BREAK, B) {\n      c = OP_R_BREAK;\n      goto L_RETURN;\n    }\n    CASE(OP_RETURN_BLK, B) {\n      c = OP_R_RETURN;\n      goto L_RETURN;\n    }\n    CASE(OP_RETURN, B)\n    c = OP_R_NORMAL;\n    L_RETURN:\n    {\n      mrb_callinfo *ci;\n\n      ci = mrb->c->ci;\n      if (ci->mid) {\n        mrb_value blk = regs[mrb_ci_bidx(ci)];\n\n        if (mrb_proc_p(blk)) {\n          struct RProc *p = mrb_proc_ptr(blk);\n\n          if (!MRB_PROC_STRICT_P(p) &&\n              ci > mrb->c->cibase && MRB_PROC_ENV(p) == mrb_vm_ci_env(&ci[-1])) {\n            p->flags |= MRB_PROC_ORPHAN;\n          }\n        }\n      }\n\n      if (mrb->exc) {\n      L_RAISE:\n        ci = mrb->c->ci;\n        if (ci == mrb->c->cibase) {\n          ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL);\n          if (ch == NULL) goto L_FTOP;\n          goto L_CATCH;\n        }\n        while ((ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL)) == NULL) {\n          ci = cipop(mrb);\n          if (ci[1].cci == CINFO_SKIP && prev_jmp) {\n            mrb->jmp = prev_jmp;\n            MRB_THROW(prev_jmp);\n          }\n          pc = ci[0].pc;\n          if (ci == mrb->c->cibase) {\n            ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL);\n            if (ch == NULL) {\n            L_FTOP:             /* fiber top */\n              if (mrb->c == mrb->root_c) {\n                mrb->c->ci->stack = mrb->c->stbase;\n                goto L_STOP;\n              }\n              else {\n                struct mrb_context *c = mrb->c;\n\n                c->status = MRB_FIBER_TERMINATED;\n                mrb->c = c->prev;\n                c->prev = NULL;\n                goto L_RAISE;\n              }\n            }\n            break;\n          }\n        }\n      L_CATCH:\n        if (ch == NULL) goto L_STOP;\n        if (FALSE) {\n        L_CATCH_TAGGED_BREAK: /* from THROW_TAGGED_BREAK() or UNWIND_ENSURE() */\n          ci = mrb->c->ci;\n        }\n        proc = ci->proc;\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        mrb_stack_extend(mrb, irep->nregs);\n        pc = irep->iseq + mrb_irep_catch_handler_unpack(ch->target);\n      }\n      else {\n        mrb_int acc;\n        mrb_value v;\n\n        ci = mrb->c->ci;\n        v = regs[a];\n        mrb_gc_protect(mrb, v);\n        switch (c) {\n        case OP_R_RETURN:\n          /* Fall through to OP_R_NORMAL otherwise */\n          if (ci->cci == CINFO_NONE && MRB_PROC_ENV_P(proc) && !MRB_PROC_STRICT_P(proc)) {\n            const struct RProc *dst;\n            mrb_callinfo *cibase;\n            cibase = mrb->c->cibase;\n            dst = top_proc(mrb, proc);\n\n            if (MRB_PROC_ENV_P(dst)) {\n              struct REnv *e = MRB_PROC_ENV(dst);\n\n              if (!MRB_ENV_ONSTACK_P(e) || (e->cxt && e->cxt != mrb->c)) {\n                localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                goto L_RAISE;\n              }\n            }\n            /* check jump destination */\n            while (cibase <= ci && ci->proc != dst) {\n              if (ci->cci > CINFO_NONE) { /* jump cross C boundary */\n                localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                goto L_RAISE;\n              }\n              ci--;\n            }\n            if (ci <= cibase) { /* no jump destination */\n              localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n              goto L_RAISE;\n            }\n            ci = mrb->c->ci;\n            while (cibase <= ci && ci->proc != dst) {\n              CHECKPOINT_RESTORE(RBREAK_TAG_RETURN_BLOCK) {\n                cibase = mrb->c->cibase;\n                dst = top_proc(mrb, proc);\n              }\n              CHECKPOINT_MAIN(RBREAK_TAG_RETURN_BLOCK) {\n                UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN_BLOCK, proc, v);\n              }\n              CHECKPOINT_END(RBREAK_TAG_RETURN_BLOCK);\n              ci = cipop(mrb);\n              pc = ci->pc;\n            }\n            proc = ci->proc;\n            mrb->exc = NULL; /* clear break object */\n            break;\n          }\n          /* fallthrough */\n        case OP_R_NORMAL:\n        NORMAL_RETURN:\n          if (ci == mrb->c->cibase) {\n            struct mrb_context *c;\n            c = mrb->c;\n\n            if (!c->prev) { /* toplevel return */\n              regs[irep->nlocals] = v;\n              goto CHECKPOINT_LABEL_MAKE(RBREAK_TAG_STOP);\n            }\n            if (!c->vmexec && c->prev->ci == c->prev->cibase) {\n              mrb_value exc = mrb_exc_new_lit(mrb, E_FIBER_ERROR, \"double resume\");\n              mrb_exc_set(mrb, exc);\n              goto L_RAISE;\n            }\n            CHECKPOINT_RESTORE(RBREAK_TAG_RETURN_TOPLEVEL) {\n              c = mrb->c;\n            }\n            CHECKPOINT_MAIN(RBREAK_TAG_RETURN_TOPLEVEL) {\n              UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN_TOPLEVEL, proc, v);\n            }\n            CHECKPOINT_END(RBREAK_TAG_RETURN_TOPLEVEL);\n            /* automatic yield at the end */\n            c->status = MRB_FIBER_TERMINATED;\n            mrb->c = c->prev;\n            mrb->c->status = MRB_FIBER_RUNNING;\n            c->prev = NULL;\n            if (c->vmexec) {\n              mrb_gc_arena_restore(mrb, ai);\n              c->vmexec = FALSE;\n              mrb->jmp = prev_jmp;\n              return v;\n            }\n            ci = mrb->c->ci;\n          }\n          CHECKPOINT_RESTORE(RBREAK_TAG_RETURN) {\n            /* do nothing */\n          }\n          CHECKPOINT_MAIN(RBREAK_TAG_RETURN) {\n            UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN, proc, v);\n          }\n          CHECKPOINT_END(RBREAK_TAG_RETURN);\n          mrb->exc = NULL; /* clear break object */\n          break;\n        case OP_R_BREAK:\n          if (MRB_PROC_STRICT_P(proc)) goto NORMAL_RETURN;\n          if (MRB_PROC_ORPHAN_P(proc)) {\n            mrb_value exc;\n\n          L_BREAK_ERROR:\n            exc = mrb_exc_new_lit(mrb, E_LOCALJUMP_ERROR,\n                                      \"break from proc-closure\");\n            mrb_exc_set(mrb, exc);\n            goto L_RAISE;\n          }\n          if (!MRB_PROC_ENV_P(proc) || !MRB_ENV_ONSTACK_P(MRB_PROC_ENV(proc))) {\n            goto L_BREAK_ERROR;\n          }\n          else {\n            struct REnv *e = MRB_PROC_ENV(proc);\n\n            if (e->cxt != mrb->c) {\n              goto L_BREAK_ERROR;\n            }\n          }\n          CHECKPOINT_RESTORE(RBREAK_TAG_BREAK) {\n            /* do nothing */\n          }\n          CHECKPOINT_MAIN(RBREAK_TAG_BREAK) {\n            UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK, proc, v);\n          }\n          CHECKPOINT_END(RBREAK_TAG_BREAK);\n          /* break from fiber block */\n          if (ci == mrb->c->cibase && ci->pc) {\n            struct mrb_context *c = mrb->c;\n\n            mrb->c = c->prev;\n            c->prev = NULL;\n            ci = mrb->c->ci;\n          }\n          if (ci->cci > CINFO_NONE) {\n            ci = cipop(mrb);\n            mrb->exc = (struct RObject*)break_new(mrb, RBREAK_TAG_BREAK, proc, v);\n            mrb_gc_arena_restore(mrb, ai);\n            mrb->c->vmexec = FALSE;\n            mrb->jmp = prev_jmp;\n            MRB_THROW(prev_jmp);\n          }\n          if (FALSE) {\n            struct RBreak *brk;\n\n          L_BREAK:\n            brk = (struct RBreak*)mrb->exc;\n            proc = mrb_break_proc_get(brk);\n            v = mrb_break_value_get(brk);\n            ci = mrb->c->ci;\n\n            switch (mrb_break_tag_get(brk)) {\n#define DISPATCH_CHECKPOINTS(n, i) case n: goto CHECKPOINT_LABEL_MAKE(n);\n              RBREAK_TAG_FOREACH(DISPATCH_CHECKPOINTS)\n#undef DISPATCH_CHECKPOINTS\n              default:\n                mrb_assert(!\"wrong break tag\");\n            }\n          }\n          while (mrb->c->cibase < ci && ci[-1].proc != proc->upper) {\n            if (ci[-1].cci == CINFO_SKIP) {\n              goto L_BREAK_ERROR;\n            }\n            CHECKPOINT_RESTORE(RBREAK_TAG_BREAK_UPPER) {\n              /* do nothing */\n            }\n            CHECKPOINT_MAIN(RBREAK_TAG_BREAK_UPPER) {\n              UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK_UPPER, proc, v);\n            }\n            CHECKPOINT_END(RBREAK_TAG_BREAK_UPPER);\n            ci = cipop(mrb);\n            pc = ci->pc;\n          }\n          CHECKPOINT_RESTORE(RBREAK_TAG_BREAK_INTARGET) {\n            /* do nothing */\n          }\n          CHECKPOINT_MAIN(RBREAK_TAG_BREAK_INTARGET) {\n            UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK_INTARGET, proc, v);\n          }\n          CHECKPOINT_END(RBREAK_TAG_BREAK_INTARGET);\n          if (ci == mrb->c->cibase) {\n            goto L_BREAK_ERROR;\n          }\n          mrb->exc = NULL; /* clear break object */\n          break;\n        default:\n          /* cannot happen */\n          break;\n        }\n        mrb_assert(ci == mrb->c->ci);\n        mrb_assert(mrb->exc == NULL);\n\n        if (mrb->c->vmexec && !mrb_vm_ci_target_class(ci)) {\n          mrb_gc_arena_restore(mrb, ai);\n          mrb->c->vmexec = FALSE;\n          mrb->jmp = prev_jmp;\n          return v;\n        }\n        acc = ci->cci;\n        ci = cipop(mrb);\n        if (acc == CINFO_SKIP || acc == CINFO_DIRECT) {\n          mrb_gc_arena_restore(mrb, ai);\n          mrb->jmp = prev_jmp;\n          return v;\n        }\n        pc = ci->pc;\n        DEBUG(fprintf(stderr, \"from :%s\\n\", mrb_sym_name(mrb, ci->mid)));\n        proc = ci->proc;\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n\n        ci[1].stack[0] = v;\n        mrb_gc_arena_restore(mrb, ai);\n      }\n      JUMP;\n    }\n\n    CASE(OP_BLKPUSH, BS) {\n      int m1 = (b>>11)&0x3f;\n      int r  = (b>>10)&0x1;\n      int m2 = (b>>5)&0x1f;\n      int kd = (b>>4)&0x1;\n      int lv = (b>>0)&0xf;\n      mrb_value *stack;\n\n      if (lv == 0) stack = regs + 1;\n      else {\n        struct REnv *e = uvenv(mrb, lv-1);\n        if (!e || (!MRB_ENV_ONSTACK_P(e) && e->mid == 0) ||\n            MRB_ENV_LEN(e) <= m1+r+m2+1) {\n          localjump_error(mrb, LOCALJUMP_ERROR_YIELD);\n          goto L_RAISE;\n        }\n        stack = e->stack + 1;\n      }\n      if (mrb_nil_p(stack[m1+r+m2+kd])) {\n        localjump_error(mrb, LOCALJUMP_ERROR_YIELD);\n        goto L_RAISE;\n      }\n      regs[a] = stack[m1+r+m2+kd];\n      NEXT;\n    }\n\n  L_INT_OVERFLOW:\n    {\n      mrb_value exc = mrb_exc_new_lit(mrb, E_RANGE_ERROR, \"integer overflow\");\n      mrb_exc_set(mrb, exc);\n    }\n    goto L_RAISE;\n\n#define TYPES2(a,b) ((((uint16_t)(a))<<8)|(((uint16_t)(b))&0xff))\n#define OP_MATH(op_name)                                                    \\\n  /* need to check if op is overridden */                                   \\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {                  \\\n    OP_MATH_CASE_INTEGER(op_name);                                          \\\n    OP_MATH_CASE_FLOAT(op_name, integer, float);                            \\\n    OP_MATH_CASE_FLOAT(op_name, float,  integer);                           \\\n    OP_MATH_CASE_FLOAT(op_name, float,  float);                             \\\n    OP_MATH_CASE_STRING_##op_name();                                        \\\n    default:                                                                \\\n      mid = MRB_OPSYM(op_name);                                             \\\n      goto L_SEND_SYM;                                                      \\\n  }                                                                         \\\n  NEXT;\n#define OP_MATH_CASE_INTEGER(op_name)                                       \\\n  case TYPES2(MRB_TT_INTEGER, MRB_TT_INTEGER):                              \\\n    {                                                                       \\\n      mrb_int x = mrb_integer(regs[a]), y = mrb_integer(regs[a+1]), z;      \\\n      if (mrb_int_##op_name##_overflow(x, y, &z))                           \\\n        OP_MATH_OVERFLOW_INT();                                             \\\n      else                                                                  \\\n        SET_INT_VALUE(mrb,regs[a], z);                                      \\\n    }                                                                       \\\n    break\n#ifdef MRB_NO_FLOAT\n#define OP_MATH_CASE_FLOAT(op_name, t1, t2) (void)0\n#else\n#define OP_MATH_CASE_FLOAT(op_name, t1, t2)                                     \\\n  case TYPES2(OP_MATH_TT_##t1, OP_MATH_TT_##t2):                                \\\n    {                                                                           \\\n      mrb_float z = mrb_##t1(regs[a]) OP_MATH_OP_##op_name mrb_##t2(regs[a+1]); \\\n      SET_FLOAT_VALUE(mrb, regs[a], z);                                         \\\n    }                                                                           \\\n    break\n#endif\n#define OP_MATH_OVERFLOW_INT() goto L_INT_OVERFLOW\n#define OP_MATH_CASE_STRING_add()                                           \\\n  case TYPES2(MRB_TT_STRING, MRB_TT_STRING):                                \\\n    regs[a] = mrb_str_plus(mrb, regs[a], regs[a+1]);                        \\\n    mrb_gc_arena_restore(mrb, ai);                                          \\\n    break\n#define OP_MATH_CASE_STRING_sub() (void)0\n#define OP_MATH_CASE_STRING_mul() (void)0\n#define OP_MATH_OP_add +\n#define OP_MATH_OP_sub -\n#define OP_MATH_OP_mul *\n#define OP_MATH_TT_integer MRB_TT_INTEGER\n#define OP_MATH_TT_float   MRB_TT_FLOAT\n\n    CASE(OP_ADD, B) {\n      OP_MATH(add);\n    }\n\n    CASE(OP_SUB, B) {\n      OP_MATH(sub);\n    }\n\n    CASE(OP_MUL, B) {\n      OP_MATH(mul);\n    }\n\n    CASE(OP_DIV, B) {\n#ifndef MRB_NO_FLOAT\n      mrb_float x, y, f;\n#endif\n\n      /* need to check if op is overridden */\n      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\n      case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\n        {\n          mrb_int x = mrb_integer(regs[a]);\n          mrb_int y = mrb_integer(regs[a+1]);\n          mrb_int div = mrb_div_int(mrb, x, y);\n          SET_INT_VALUE(mrb, regs[a], div);\n        }\n        NEXT;\n#ifndef MRB_NO_FLOAT\n      case TYPES2(MRB_TT_INTEGER,MRB_TT_FLOAT):\n        x = (mrb_float)mrb_integer(regs[a]);\n        y = mrb_float(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_INTEGER):\n        x = mrb_float(regs[a]);\n        y = (mrb_float)mrb_integer(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\n        x = mrb_float(regs[a]);\n        y = mrb_float(regs[a+1]);\n        break;\n#endif\n      default:\n        mid = MRB_OPSYM(div);\n        goto L_SEND_SYM;\n      }\n\n#ifndef MRB_NO_FLOAT\n      f = mrb_div_float(x, y);\n      SET_FLOAT_VALUE(mrb, regs[a], f);\n#endif\n      NEXT;\n    }\n\n#define OP_MATHI(op_name)                                                   \\\n  /* need to check if op is overridden */                                   \\\n  switch (mrb_type(regs[a])) {                                              \\\n    OP_MATHI_CASE_INTEGER(op_name);                                         \\\n    OP_MATHI_CASE_FLOAT(op_name);                                           \\\n    default:                                                                \\\n      SET_INT_VALUE(mrb,regs[a+1], b);                                      \\\n      mid = MRB_OPSYM(op_name);                                             \\\n      goto L_SEND_SYM;                                                      \\\n  }                                                                         \\\n  NEXT;\n#define OP_MATHI_CASE_INTEGER(op_name)                                      \\\n  case MRB_TT_INTEGER:                                                      \\\n    {                                                                       \\\n      mrb_int x = mrb_integer(regs[a]), y = (mrb_int)b, z;                  \\\n      if (mrb_int_##op_name##_overflow(x, y, &z))                           \\\n        OP_MATH_OVERFLOW_INT();                                             \\\n      else                                                                  \\\n        SET_INT_VALUE(mrb,regs[a], z);                                      \\\n    }                                                                       \\\n    break\n#ifdef MRB_NO_FLOAT\n#define OP_MATHI_CASE_FLOAT(op_name) (void)0\n#else\n#define OP_MATHI_CASE_FLOAT(op_name)                                        \\\n  case MRB_TT_FLOAT:                                                        \\\n    {                                                                       \\\n      mrb_float z = mrb_float(regs[a]) OP_MATH_OP_##op_name b;              \\\n      SET_FLOAT_VALUE(mrb, regs[a], z);                                     \\\n    }                                                                       \\\n    break\n#endif\n\n    CASE(OP_ADDI, BB) {\n      OP_MATHI(add);\n    }\n\n    CASE(OP_SUBI, BB) {\n      OP_MATHI(sub);\n    }\n\n#define OP_CMP_BODY(op,v1,v2) (v1(regs[a]) op v2(regs[a+1]))\n\n#ifdef MRB_NO_FLOAT\n#define OP_CMP(op,sym) do {\\\n  int result;\\\n  /* need to check if - is overridden */\\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\\\n  case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\\\n    break;\\\n  default:\\\n    mid = MRB_OPSYM(sym);\\\n    goto L_SEND_SYM;\\\n  }\\\n  if (result) {\\\n    SET_TRUE_VALUE(regs[a]);\\\n  }\\\n  else {\\\n    SET_FALSE_VALUE(regs[a]);\\\n  }\\\n} while(0)\n#else\n#define OP_CMP(op, sym) do {\\\n  int result;\\\n  /* need to check if - is overridden */\\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\\\n  case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\\\n    break;\\\n  case TYPES2(MRB_TT_INTEGER,MRB_TT_FLOAT):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_float);\\\n    break;\\\n  case TYPES2(MRB_TT_FLOAT,MRB_TT_INTEGER):\\\n    result = OP_CMP_BODY(op,mrb_float,mrb_fixnum);\\\n    break;\\\n  case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\\\n    result = OP_CMP_BODY(op,mrb_float,mrb_float);\\\n    break;\\\n  default:\\\n    mid = MRB_OPSYM(sym);\\\n    goto L_SEND_SYM;\\\n  }\\\n  if (result) {\\\n    SET_TRUE_VALUE(regs[a]);\\\n  }\\\n  else {\\\n    SET_FALSE_VALUE(regs[a]);\\\n  }\\\n} while(0)\n#endif\n\n    CASE(OP_EQ, B) {\n      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {\n        SET_TRUE_VALUE(regs[a]);\n      }\n      else {\n        OP_CMP(==,eq);\n      }\n      NEXT;\n    }\n\n    CASE(OP_LT, B) {\n      OP_CMP(<,lt);\n      NEXT;\n    }\n\n    CASE(OP_LE, B) {\n      OP_CMP(<=,le);\n      NEXT;\n    }\n\n    CASE(OP_GT, B) {\n      OP_CMP(>,gt);\n      NEXT;\n    }\n\n    CASE(OP_GE, B) {\n      OP_CMP(>=,ge);\n      NEXT;\n    }\n\n    CASE(OP_ARRAY, BB) {\n      regs[a] = mrb_ary_new_from_values(mrb, b, &regs[a]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n    CASE(OP_ARRAY2, BBB) {\n      regs[a] = mrb_ary_new_from_values(mrb, c, &regs[b]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ARYCAT, B) {\n      mrb_value splat = mrb_ary_splat(mrb, regs[a+1]);\n      if (mrb_nil_p(regs[a])) {\n        regs[a] = splat;\n      }\n      else {\n        mrb_assert(mrb_array_p(regs[a]));\n        mrb_ary_concat(mrb, regs[a], splat);\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ARYPUSH, BB) {\n      mrb_assert(mrb_array_p(regs[a]));\n      for (mrb_int i=0; i<b; i++) {\n        mrb_ary_push(mrb, regs[a], regs[a+i+1]);\n      }\n      NEXT;\n    }\n\n    CASE(OP_ARYDUP, B) {\n      mrb_value ary = regs[a];\n      if (mrb_array_p(ary)) {\n        ary = mrb_ary_new_from_values(mrb, RARRAY_LEN(ary), RARRAY_PTR(ary));\n      }\n      else {\n        ary = mrb_ary_new_from_values(mrb, 1, &ary);\n      }\n      regs[a] = ary;\n      NEXT;\n    }\n\n    CASE(OP_AREF, BBB) {\n      mrb_value v = regs[b];\n\n      if (!mrb_array_p(v)) {\n        if (c == 0) {\n          regs[a] = v;\n        }\n        else {\n          SET_NIL_VALUE(regs[a]);\n        }\n      }\n      else {\n        v = mrb_ary_ref(mrb, v, c);\n        regs[a] = v;\n      }\n      NEXT;\n    }\n\n    CASE(OP_ASET, BBB) {\n      mrb_assert(mrb_array_p(regs[a]));\n      mrb_ary_set(mrb, regs[b], c, regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_APOST, BBB) {\n      mrb_value v = regs[a];\n      int pre  = b;\n      int post = c;\n      struct RArray *ary;\n      int len, idx;\n\n      if (!mrb_array_p(v)) {\n        v = mrb_ary_new_from_values(mrb, 1, &regs[a]);\n      }\n      ary = mrb_ary_ptr(v);\n      len = (int)ARY_LEN(ary);\n      if (len > pre + post) {\n        v = mrb_ary_new_from_values(mrb, len - pre - post, ARY_PTR(ary)+pre);\n        regs[a++] = v;\n        while (post--) {\n          regs[a++] = ARY_PTR(ary)[len-post-1];\n        }\n      }\n      else {\n        v = mrb_ary_new_capa(mrb, 0);\n        regs[a++] = v;\n        for (idx=0; idx+pre<len; idx++) {\n          regs[a+idx] = ARY_PTR(ary)[pre+idx];\n        }\n        while (idx < post) {\n          SET_NIL_VALUE(regs[a+idx]);\n          idx++;\n        }\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_INTERN, B) {\n      mrb_assert(mrb_string_p(regs[a]));\n      mrb_sym sym = mrb_intern_str(mrb, regs[a]);\n      regs[a] = mrb_symbol_value(sym);\n      NEXT;\n    }\n\n    CASE(OP_SYMBOL, BB) {\n      size_t len;\n      mrb_sym sym;\n\n      mrb_assert((pool[b].tt&IREP_TT_NFLAG)==0);\n      len = pool[b].tt >> 2;\n      if (pool[b].tt & IREP_TT_SFLAG) {\n        sym = mrb_intern_static(mrb, pool[b].u.str, len);\n      }\n      else {\n        sym  = mrb_intern(mrb, pool[b].u.str, len);\n      }\n      regs[a] = mrb_symbol_value(sym);\n      NEXT;\n    }\n\n    CASE(OP_STRING, BB) {\n      mrb_int len;\n\n      mrb_assert((pool[b].tt&IREP_TT_NFLAG)==0);\n      len = pool[b].tt >> 2;\n      if (pool[b].tt & IREP_TT_SFLAG) {\n        regs[a] = mrb_str_new_static(mrb, pool[b].u.str, len);\n      }\n      else {\n        regs[a] = mrb_str_new(mrb, pool[b].u.str, len);\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_STRCAT, B) {\n      mrb_assert(mrb_string_p(regs[a]));\n      mrb_str_concat(mrb, regs[a], regs[a+1]);\n      NEXT;\n    }\n\n    CASE(OP_HASH, BB) {\n      mrb_value hash = mrb_hash_new_capa(mrb, b);\n      int i;\n      int lim = a+b*2;\n\n      for (i=a; i<lim; i+=2) {\n        mrb_hash_set(mrb, hash, regs[i], regs[i+1]);\n      }\n      regs[a] = hash;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_HASHADD, BB) {\n      mrb_value hash;\n      int i;\n      int lim = a+b*2+1;\n\n      hash = regs[a];\n      mrb_ensure_hash_type(mrb, hash);\n      for (i=a+1; i<lim; i+=2) {\n        mrb_hash_set(mrb, hash, regs[i], regs[i+1]);\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n    CASE(OP_HASHCAT, B) {\n      mrb_value hash = regs[a];\n\n      mrb_assert(mrb_hash_p(hash));\n      mrb_hash_merge(mrb, hash, regs[a+1]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_LAMBDA, BB)\n    c = OP_L_LAMBDA;\n    L_MAKE_LAMBDA:\n    {\n      struct RProc *p;\n      const mrb_irep *nirep = irep->reps[b];\n\n      if (c & OP_L_CAPTURE) {\n        p = mrb_closure_new(mrb, nirep);\n      }\n      else {\n        p = mrb_proc_new(mrb, nirep);\n        p->flags |= MRB_PROC_SCOPE;\n      }\n      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;\n      regs[a] = mrb_obj_value(p);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n    CASE(OP_BLOCK, BB) {\n      c = OP_L_BLOCK;\n      goto L_MAKE_LAMBDA;\n    }\n    CASE(OP_METHOD, BB) {\n      c = OP_L_METHOD;\n      goto L_MAKE_LAMBDA;\n    }\n\n    CASE(OP_RANGE_INC, B) {\n      mrb_value v = mrb_range_new(mrb, regs[a], regs[a+1], FALSE);\n      regs[a] = v;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_RANGE_EXC, B) {\n      mrb_value v = mrb_range_new(mrb, regs[a], regs[a+1], TRUE);\n      regs[a] = v;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_OCLASS, B) {\n      regs[a] = mrb_obj_value(mrb->object_class);\n      NEXT;\n    }\n\n    CASE(OP_CLASS, BB) {\n      struct RClass *c = 0, *baseclass;\n      mrb_value base, super;\n      mrb_sym id = syms[b];\n\n      base = regs[a];\n      super = regs[a+1];\n      if (mrb_nil_p(base)) {\n        baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);\n        if (!baseclass) baseclass = mrb->object_class;\n        base = mrb_obj_value(baseclass);\n      }\n      c = mrb_vm_define_class(mrb, base, super, id);\n      regs[a] = mrb_obj_value(c);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_MODULE, BB) {\n      struct RClass *cls = 0, *baseclass;\n      mrb_value base;\n      mrb_sym id = syms[b];\n\n      base = regs[a];\n      if (mrb_nil_p(base)) {\n        baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);\n        if (!baseclass) baseclass = mrb->object_class;\n        base = mrb_obj_value(baseclass);\n      }\n      cls = mrb_vm_define_module(mrb, base, id);\n      regs[a] = mrb_obj_value(cls);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_EXEC, BB)\n    {\n      mrb_value recv = regs[a];\n      struct RProc *p;\n      const mrb_irep *nirep = irep->reps[b];\n\n      /* prepare closure */\n      p = mrb_proc_new(mrb, nirep);\n      p->c = NULL;\n      mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)proc);\n      MRB_PROC_SET_TARGET_CLASS(p, mrb_class_ptr(recv));\n      p->flags |= MRB_PROC_SCOPE;\n\n      /* prepare call stack */\n      cipush(mrb, a, 0, mrb_class_ptr(recv), p, 0, 0);\n\n      irep = p->body.irep;\n      pool = irep->pool;\n      syms = irep->syms;\n      mrb_stack_extend(mrb, irep->nregs);\n      stack_clear(regs+1, irep->nregs-1);\n      pc = irep->iseq;\n      JUMP;\n    }\n\n    CASE(OP_DEF, BB) {\n      struct RClass *target = mrb_class_ptr(regs[a]);\n      struct RProc *p = mrb_proc_ptr(regs[a+1]);\n      mrb_method_t m;\n      mrb_sym mid = syms[b];\n\n      MRB_METHOD_FROM_PROC(m, p);\n      mrb_define_method_raw(mrb, target, mid, m);\n      mrb_method_added(mrb, target, mid);\n      mrb_gc_arena_restore(mrb, ai);\n      regs[a] = mrb_symbol_value(mid);\n      NEXT;\n    }\n\n    CASE(OP_SCLASS, B) {\n      regs[a] = mrb_singleton_class(mrb, regs[a]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_TCLASS, B) {\n      struct RClass *target = check_target_class(mrb);\n      if (!target) goto L_RAISE;\n      regs[a] = mrb_obj_value(target);\n      NEXT;\n    }\n\n    CASE(OP_ALIAS, BB) {\n      struct RClass *target = check_target_class(mrb);\n\n      if (!target) goto L_RAISE;\n      mrb_alias_method(mrb, target, syms[a], syms[b]);\n      mrb_method_added(mrb, target, syms[a]);\n      NEXT;\n    }\n    CASE(OP_UNDEF, B) {\n      struct RClass *target = check_target_class(mrb);\n\n      if (!target) goto L_RAISE;\n      mrb_undef_method_id(mrb, target, syms[a]);\n      NEXT;\n    }\n\n    CASE(OP_DEBUG, Z) {\n      FETCH_BBB();\n#ifdef MRB_USE_DEBUG_HOOK\n      mrb->debug_op_hook(mrb, irep, pc, regs);\n#else\n#ifndef MRB_NO_STDIO\n      printf(\"OP_DEBUG %d %d %d\\n\", a, b, c);\n#else\n      abort();\n#endif\n#endif\n      NEXT;\n    }\n\n    CASE(OP_ERR, B) {\n      size_t len = pool[a].tt >> 2;\n      mrb_value exc;\n\n      mrb_assert((pool[a].tt&IREP_TT_NFLAG)==0);\n      exc = mrb_exc_new(mrb, E_LOCALJUMP_ERROR, pool[a].u.str, len);\n      mrb_exc_set(mrb, exc);\n      goto L_RAISE;\n    }\n\n    CASE(OP_EXT1, Z) {\n      insn = READ_B();\n      switch (insn) {\n#define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _1(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY;\n#include \"mruby/ops.h\"\n#undef OPCODE\n      }\n      pc--;\n      NEXT;\n    }\n    CASE(OP_EXT2, Z) {\n      insn = READ_B();\n      switch (insn) {\n#define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _2(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY;\n#include \"mruby/ops.h\"\n#undef OPCODE\n      }\n      pc--;\n      NEXT;\n    }\n    CASE(OP_EXT3, Z) {\n      uint8_t insn = READ_B();\n      switch (insn) {\n#define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _3(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY;\n#include \"mruby/ops.h\"\n#undef OPCODE\n      }\n      pc--;\n      NEXT;\n    }\n\n    CASE(OP_STOP, Z) {\n      /*        stop VM */\n      CHECKPOINT_RESTORE(RBREAK_TAG_STOP) {\n        /* do nothing */\n      }\n      CHECKPOINT_MAIN(RBREAK_TAG_STOP) {\n        UNWIND_ENSURE(mrb, mrb->c->ci, pc, RBREAK_TAG_STOP, proc, mrb_nil_value());\n      }\n      CHECKPOINT_END(RBREAK_TAG_STOP);\n    L_STOP:\n      mrb->jmp = prev_jmp;\n      if (mrb->exc) {\n        mrb_assert(mrb->exc->tt == MRB_TT_EXCEPTION);\n        return mrb_obj_value(mrb->exc);\n      }\n      return regs[irep->nlocals];\n    }\n  }\n  END_DISPATCH;\n#undef regs\n  }\n  MRB_CATCH(&c_jmp) {\n    mrb_callinfo *ci = mrb->c->ci;\n    while (ci > mrb->c->cibase && ci->cci == CINFO_DIRECT) {\n      ci = cipop(mrb);\n    }\n    exc_catched = TRUE;\n    pc = ci->pc;\n    goto RETRY_TRY_BLOCK;\n  }\n  MRB_END_EXC(&c_jmp);\n}\n\nstatic mrb_value\nmrb_run(mrb_state *mrb, const struct RProc *proc, mrb_value self)\n{\n  return mrb_vm_run(mrb, proc, self, mrb_ci_bidx(mrb->c->ci) + 1);\n}\n\nMRB_API mrb_value\nmrb_top_run(mrb_state *mrb, const struct RProc *proc, mrb_value self, mrb_int stack_keep)\n{\n  mrb_value v;\n\n  if (!mrb->c->cibase) {\n    return mrb_vm_run(mrb, proc, self, stack_keep);\n  }\n  if (mrb->c->ci == mrb->c->cibase) {\n    mrb_vm_ci_env_set(mrb->c->ci, NULL);\n    return mrb_vm_run(mrb, proc, self, stack_keep);\n  }\n  cipush(mrb, 0, CINFO_SKIP, mrb->object_class, NULL, 0, 0);\n  v = mrb_vm_run(mrb, proc, self, stack_keep);\n\n  return v;\n}\n\n#if defined(MRB_USE_CXX_EXCEPTION) && defined(__cplusplus)\n# if !defined(MRB_USE_CXX_ABI)\n} /* end of extern \"C\" */\n# endif\nmrb_int mrb_jmpbuf::jmpbuf_id = 0;\n# if !defined(MRB_USE_CXX_ABI)\nextern \"C\" {\n# endif\n#endif\n"], "filenames": ["src/vm.c"], "buggy_code_start_loc": [2270], "buggy_code_end_loc": [2274], "fixing_code_start_loc": [2271], "fixing_code_end_loc": [2273], "type": "CWE-416", "message": "Use-After-Free in str_escape in mruby/mruby in GitHub repository mruby/mruby prior to 3.2. Possible arbitrary code execution if being exploited.", "other": {"cve": {"id": "CVE-2022-1212", "sourceIdentifier": "security@huntr.dev", "published": "2022-04-05T04:15:08.770", "lastModified": "2022-04-12T20:53:53.833", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Use-After-Free in str_escape in mruby/mruby in GitHub repository mruby/mruby prior to 3.2. Possible arbitrary code execution if being exploited."}, {"lang": "es", "value": "Un Oso de Memoria previamente Liberada en la funci\u00f3n str_escape en mruby/mruby en el repositorio GitHub mruby/mruby versiones anteriores a 3.2. Una posible ejecuci\u00f3n de c\u00f3digo arbitrario si es explotado"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:L/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 9.3, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 4.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mruby:mruby:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.0.0", "matchCriteriaId": "E65F5997-52F0-4937-AFA2-D56A5DACBD6C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mruby:mruby:3.1.0:rc:*:*:*:*:*:*", "matchCriteriaId": "2AD579DE-3A97-4AD5-B13C-C9D44331311F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mruby:mruby:3.1.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "E89212A2-5FED-4CEA-88A4-77611895FF17"}]}]}], "references": [{"url": "https://github.com/mruby/mruby/commit/3cf291f72224715942beaf8553e42ba8891ab3c6", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/9fcc06d0-08e4-49c8-afda-2cae40946abe", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/mruby/mruby/commit/3cf291f72224715942beaf8553e42ba8891ab3c6"}}