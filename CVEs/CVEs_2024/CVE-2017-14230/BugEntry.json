{"buggy_code": ["/* mboxlist.c -- Mailbox list manipulation routines\n *\n * Copyright (c) 1994-2008 Carnegie Mellon University.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * 3. The name \"Carnegie Mellon University\" must not be used to\n *    endorse or promote products derived from this software without\n *    prior written permission. For permission or any legal\n *    details, please contact\n *      Carnegie Mellon University\n *      Center for Technology Transfer and Enterprise Creation\n *      4615 Forbes Avenue\n *      Suite 302\n *      Pittsburgh, PA  15213\n *      (412) 268-7393, fax: (412) 268-7395\n *      innovation@andrew.cmu.edu\n *\n * 4. Redistributions of any form whatsoever must retain the following\n *    acknowledgment:\n *    \"This product includes software developed by Computing Services\n *     at Carnegie Mellon University (http://www.cmu.edu/computing/).\"\n *\n * CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO\n * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE\n * FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN\n * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <config.h>\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/uio.h>\n#include <fcntl.h>\n#include <syslog.h>\n\n#include <sys/ipc.h>\n#include <sys/msg.h>\n\n#include \"acl.h\"\n#include \"annotate.h\"\n#include \"glob.h\"\n#include \"assert.h\"\n#include \"global.h\"\n#include \"cyrusdb.h\"\n#include \"util.h\"\n#include \"mailbox.h\"\n#include \"mboxevent.h\"\n#include \"exitcodes.h\"\n#include \"xmalloc.h\"\n#include \"xstrlcpy.h\"\n#include \"partlist.h\"\n#include \"xstrlcat.h\"\n#include \"user.h\"\n\n/* generated headers are not necessarily in current directory */\n#include \"imap/imap_err.h\"\n\n#include \"mboxname.h\"\n#include \"mupdate-client.h\"\n\n#include \"mboxlist.h\"\n#include \"quota.h\"\n#include \"sync_log.h\"\n\n#define DB config_mboxlist_db\n#define SUBDB config_subscription_db\n\ncyrus_acl_canonproc_t mboxlist_ensureOwnerRights;\n\nstatic struct db *mbdb;\n\nstatic int mboxlist_dbopen = 0;\n\nstatic int mboxlist_opensubs(const char *userid, struct db **ret);\nstatic void mboxlist_closesubs(struct db *sub);\n\nstatic int mboxlist_rmquota(const mbentry_t *mbentry, void *rock);\nstatic int mboxlist_changequota(const mbentry_t *mbentry, void *rock);\n\nEXPORTED mbentry_t *mboxlist_entry_create(void)\n{\n    mbentry_t *ret = xzmalloc(sizeof(mbentry_t));\n    /* xxx - initialiser functions here? */\n    return ret;\n}\n\nEXPORTED mbentry_t *mboxlist_entry_copy(const mbentry_t *src)\n{\n    mbentry_t *copy = mboxlist_entry_create();\n    copy->name = xstrdupnull(src->name);\n    copy->ext_name = xstrdupnull(src->ext_name);\n\n    copy->mtime = src->mtime;\n    copy->uidvalidity = src->uidvalidity;\n    copy->mbtype = src->mbtype;\n    copy->foldermodseq = src->foldermodseq;\n\n    copy->partition = xstrdupnull(src->partition);\n    copy->server = xstrdupnull(src->server);\n    copy->acl = xstrdupnull(src->acl);\n    copy->uniqueid = xstrdupnull(src->uniqueid);\n\n    copy->legacy_specialuse = xstrdupnull(src->legacy_specialuse);\n\n    return copy;\n}\n\nEXPORTED void mboxlist_entry_free(mbentry_t **mbentryptr)\n{\n    mbentry_t *mbentry = *mbentryptr;\n\n    /* idempotent */\n    if (!mbentry) return;\n\n    free(mbentry->name);\n    free(mbentry->ext_name);\n\n    free(mbentry->partition);\n    free(mbentry->server);\n    free(mbentry->acl);\n    free(mbentry->uniqueid);\n\n    free(mbentry->legacy_specialuse);\n\n    free(mbentry);\n\n    *mbentryptr = NULL;\n}\n\nstatic void _write_acl(struct dlist *dl, const char *aclstr)\n{\n    const char *p, *q;\n    struct dlist *al = dlist_newkvlist(dl, \"A\");\n\n    p = aclstr;\n\n    while (p && *p) {\n        char *name,*val;\n\n        q = strchr(p, '\\t');\n        if (!q) break;\n\n        name = xstrndup(p, q-p);\n        q++;\n\n        p = strchr(q, '\\t');\n        if (p) {\n            val = xstrndup(q, p-q);\n            p++;\n        }\n        else\n            val = xstrdup(q);\n\n        dlist_setatom(al, name, val);\n\n        free(name);\n        free(val);\n    }\n}\n\nEXPORTED const char *mboxlist_mbtype_to_string(uint32_t mbtype)\n{\n    static struct buf buf = BUF_INITIALIZER;\n\n    buf_reset(&buf);\n\n    if (mbtype & MBTYPE_DELETED)\n        buf_putc(&buf, 'd');\n    if (mbtype & MBTYPE_MOVING)\n        buf_putc(&buf, 'm');\n    if (mbtype & MBTYPE_NETNEWS)\n        buf_putc(&buf, 'n');\n    if (mbtype & MBTYPE_REMOTE)\n        buf_putc(&buf, 'r');\n    if (mbtype & MBTYPE_RESERVE)\n        buf_putc(&buf, 'z');\n    if (mbtype & MBTYPE_CALENDAR)\n        buf_putc(&buf, 'c');\n    if (mbtype & MBTYPE_COLLECTION)\n        buf_putc(&buf, 'b');\n    if (mbtype & MBTYPE_ADDRESSBOOK)\n        buf_putc(&buf, 'a');\n\n    return buf_cstring(&buf);\n}\n\nstatic char *mboxlist_entry_cstring(const mbentry_t *mbentry)\n{\n    struct buf buf = BUF_INITIALIZER;\n    struct dlist *dl = dlist_newkvlist(NULL, mbentry->name);\n\n    if (mbentry->acl)\n        _write_acl(dl, mbentry->acl);\n\n    if (mbentry->uniqueid)\n        dlist_setatom(dl, \"I\", mbentry->uniqueid);\n\n    if (mbentry->partition)\n        dlist_setatom(dl, \"P\", mbentry->partition);\n\n    if (mbentry->server)\n        dlist_setatom(dl, \"S\", mbentry->server);\n\n    if (mbentry->mbtype)\n        dlist_setatom(dl, \"T\", mboxlist_mbtype_to_string(mbentry->mbtype));\n\n    if (mbentry->uidvalidity)\n        dlist_setnum32(dl, \"V\", mbentry->uidvalidity);\n\n    if (mbentry->foldermodseq)\n        dlist_setnum64(dl, \"F\", mbentry->foldermodseq);\n\n    dlist_setdate(dl, \"M\", time(NULL));\n\n    dlist_printbuf(dl, 0, &buf);\n\n    dlist_free(&dl);\n\n    return buf_release(&buf);\n}\n\nEXPORTED char *mbentry_metapath(const struct mboxlist_entry *mbentry, int metatype, int isnew)\n{\n    return mboxname_metapath(mbentry->partition,\n                             mbentry->name,\n                             mbentry->uniqueid,\n                             metatype,\n                             isnew);\n}\n\nEXPORTED char *mbentry_datapath(const struct mboxlist_entry *mbentry, uint32_t uid)\n{\n    return mboxname_datapath(mbentry->partition,\n                             mbentry->name,\n                             mbentry->uniqueid,\n                             uid);\n}\n\n/*\n * read a single record from the mailboxes.db and return a pointer to it\n */\nstatic int mboxlist_read(const char *name, const char **dataptr, size_t *datalenptr,\n                         struct txn **tid, int wrlock)\n{\n    int namelen = strlen(name);\n    int r;\n\n    if (!namelen)\n        return IMAP_MAILBOX_NONEXISTENT;\n\n    if (wrlock) {\n        r = cyrusdb_fetchlock(mbdb, name, namelen, dataptr, datalenptr, tid);\n    } else {\n        r = cyrusdb_fetch(mbdb, name, namelen, dataptr, datalenptr, tid);\n    }\n\n    switch (r) {\n    case CYRUSDB_OK:\n        /* no entry required, just checking if it exists */\n        return 0;\n        break;\n\n    case CYRUSDB_AGAIN:\n        return IMAP_AGAIN;\n        break;\n\n    case CYRUSDB_NOTFOUND:\n        return IMAP_MAILBOX_NONEXISTENT;\n        break;\n\n    default:\n        syslog(LOG_ERR, \"DBERROR: error fetching mboxlist %s: %s\",\n               name, cyrusdb_strerror(r));\n        return IMAP_IOERROR;\n        break;\n    }\n\n    /* never get here */\n}\n\nEXPORTED uint32_t mboxlist_string_to_mbtype(const char *string)\n{\n    uint32_t mbtype = 0;\n\n    if (!string) return 0; /* null just means default */\n\n    for (; *string; string++) {\n        switch (*string) {\n        case 'a':\n            mbtype |= MBTYPE_ADDRESSBOOK;\n            break;\n        case 'b':\n            mbtype |= MBTYPE_COLLECTION;\n            break;\n        case 'c':\n            mbtype |= MBTYPE_CALENDAR;\n            break;\n        case 'd':\n            mbtype |= MBTYPE_DELETED;\n            break;\n        case 'm':\n            mbtype |= MBTYPE_MOVING;\n            break;\n        case 'n':\n            mbtype |= MBTYPE_NETNEWS;\n            break;\n        case 'r':\n            mbtype |= MBTYPE_REMOTE;\n            break;\n        case 'z':\n            mbtype |= MBTYPE_RESERVE;\n            break;\n        }\n    }\n\n    return mbtype;\n}\n\nstruct parseentry_rock {\n    struct mboxlist_entry *mbentry;\n    struct buf *aclbuf;\n    int doingacl;\n};\n\nint parseentry_cb(int type, struct dlistsax_data *d)\n{\n    struct parseentry_rock *rock = (struct parseentry_rock *)d->rock;\n\n    switch(type) {\n    case DLISTSAX_KVLISTSTART:\n        if (!strcmp(buf_cstring(&d->kbuf), \"A\")) {\n            rock->doingacl = 1;\n        }\n        break;\n    case DLISTSAX_KVLISTEND:\n        rock->doingacl = 0;\n        break;\n    case DLISTSAX_STRING:\n        if (rock->doingacl) {\n            buf_append(rock->aclbuf, &d->kbuf);\n            buf_putc(rock->aclbuf, '\\t');\n            buf_append(rock->aclbuf, &d->buf);\n            buf_putc(rock->aclbuf, '\\t');\n        }\n        else {\n            const char *key = buf_cstring(&d->kbuf);\n            if (!strcmp(key, \"F\")) {\n                rock->mbentry->foldermodseq = atoll(buf_cstring(&d->buf));\n            }\n            else if (!strcmp(key, \"I\")) {\n                rock->mbentry->uniqueid = buf_newcstring(&d->buf);\n            }\n            else if (!strcmp(key, \"M\")) {\n                rock->mbentry->mtime = atoi(buf_cstring(&d->buf));\n            }\n            else if (!strcmp(key, \"P\")) {\n                rock->mbentry->partition = buf_newcstring(&d->buf);\n            }\n            else if (!strcmp(key, \"S\")) {\n                rock->mbentry->server = buf_newcstring(&d->buf);\n            }\n            else if (!strcmp(key, \"T\")) {\n                rock->mbentry->mbtype = mboxlist_string_to_mbtype(buf_cstring(&d->buf));\n            }\n            else if (!strcmp(key, \"V\")) {\n                rock->mbentry->uidvalidity = atol(buf_cstring(&d->buf));\n            }\n        }\n    }\n\n    return 0;\n}\n\n/*\n * parse a record read from the mailboxes.db into its parts.\n *\n * full dlist format is:\n *  A: _a_cl\n *  I: unique_i_d\n *  M: _m_time\n *  P: _p_artition\n *  S: _s_erver\n *  T: _t_ype\n *  V: uid_v_alidity\n */\nEXPORTED int mboxlist_parse_entry(mbentry_t **mbentryptr,\n                                  const char *name, size_t namelen,\n                                  const char *data, size_t datalen)\n{\n    static struct buf aclbuf;\n    int r = IMAP_MAILBOX_BADFORMAT;\n    char *freeme = NULL;\n    char **target;\n    char *p, *q;\n    mbentry_t *mbentry = mboxlist_entry_create();\n\n    if (!datalen)\n        goto done;\n\n    /* copy name */\n    if (namelen)\n        mbentry->name = xstrndup(name, namelen);\n    else\n        mbentry->name = xstrdup(name);\n\n    /* check for DLIST mboxlist */\n    if (*data == '%') {\n        struct parseentry_rock rock;\n        memset(&rock, 0, sizeof(struct parseentry_rock));\n        rock.mbentry = mbentry;\n        rock.aclbuf = &aclbuf;\n        aclbuf.len = 0;\n        r = dlist_parsesax(data, datalen, 0, parseentry_cb, &rock);\n        if (!r) mbentry->acl = buf_newcstring(&aclbuf);\n        goto done;\n    }\n\n    /* copy data */\n    freeme = p = xstrndup(data, datalen);\n\n    /* check for extended mboxlist entry */\n    if (*p == '(') {\n        int last = 0;\n        p++; /* past leading '(' */\n        while (!last) {\n            target = NULL;\n            q = p;\n            while (*q && *q != ' ' && *q != ')') q++;\n            if (*q != ' ') break;\n            *q++ = '\\0';\n            if (!strcmp(p, \"uniqueid\")) target = &mbentry->uniqueid;\n            if (!strcmp(p, \"specialuse\")) target = &mbentry->legacy_specialuse;\n            p = q;\n            while (*q && *q != ' ' && *q != ')') q++;\n            if (*q != ' ') last = 1;\n            if (*q) *q++ = '\\0';\n            if (target) *target = xstrdup(p);\n            p = q;\n        }\n        if (*p == ' ') p++; /* past trailing ' ' */\n    }\n\n    /* copy out interesting parts */\n    mbentry->mbtype = strtol(p, &p, 10);\n    if (*p == ' ') p++;\n\n    q = p;\n    while (*q && *q != ' ' && *q != '!') q++;\n    if (*q == '!') {\n        *q++ = '\\0';\n        mbentry->server = xstrdup(p);\n        p = q;\n        while (*q && *q != ' ') q++;\n    }\n    if (*q) *q++ = '\\0';\n    mbentry->partition = xstrdup(p);\n\n    mbentry->acl = xstrdup(q);\n\n    r = 0;\n\ndone:\n    if (!r && mbentryptr)\n        *mbentryptr = mbentry;\n    else mboxlist_entry_free(&mbentry);\n    free(freeme);\n    return r;\n}\n\n/* read a record and parse into parts */\nstatic int mboxlist_mylookup(const char *name,\n                             mbentry_t **mbentryptr,\n                             struct txn **tid, int wrlock)\n{\n    int r;\n    const char *data;\n    size_t datalen;\n\n    r = mboxlist_read(name, &data, &datalen, tid, wrlock);\n    if (r) return r;\n\n    return mboxlist_parse_entry(mbentryptr, name, 0, data, datalen);\n}\n\n/*\n * Lookup 'name' in the mailbox list, ignoring reserved records\n */\nEXPORTED int mboxlist_lookup(const char *name, mbentry_t **entryptr,\n                             struct txn **tid)\n{\n    mbentry_t *entry = NULL;\n    int r;\n\n    r = mboxlist_mylookup(name, &entry, tid, 0);\n\n    if (r) return r;\n\n    /* Ignore \"reserved\" entries, like they aren't there */\n    if (entry->mbtype & MBTYPE_RESERVE) {\n        mboxlist_entry_free(&entry);\n        return IMAP_MAILBOX_RESERVED;\n    }\n\n    /* Ignore \"deleted\" entries, like they aren't there */\n    if (entry->mbtype & MBTYPE_DELETED) {\n        mboxlist_entry_free(&entry);\n        return IMAP_MAILBOX_NONEXISTENT;\n    }\n\n    if (entryptr) *entryptr = entry;\n    else mboxlist_entry_free(&entry);\n\n    return 0;\n}\n\nEXPORTED int mboxlist_lookup_allow_all(const char *name,\n                                   mbentry_t **entryptr,\n                                   struct txn **tid)\n{\n    return mboxlist_mylookup(name, entryptr, tid, 0);\n}\n\nstruct _find_specialuse_data {\n    const char *use;\n    const char *userid;\n    char *mboxname;\n};\n\nstatic int _find_specialuse(const mbentry_t *mbentry, void *rock)\n{\n    struct _find_specialuse_data *d = (struct _find_specialuse_data *)rock;\n    struct buf attrib = BUF_INITIALIZER;\n\n    annotatemore_lookup(mbentry->name, \"/specialuse\", d->userid, &attrib);\n\n    if (attrib.len) {\n        strarray_t *uses = strarray_split(buf_cstring(&attrib), \" \", 0);\n        if (strarray_find_case(uses, d->use, 0) >= 0)\n            d->mboxname = xstrdup(mbentry->name);\n        strarray_free(uses);\n    }\n\n    buf_free(&attrib);\n\n    if (d->mboxname) return CYRUSDB_DONE;\n    return 0;\n}\n\n\nEXPORTED char *mboxlist_find_specialuse(const char *use, const char *userid)\n{\n    /* \\\\Inbox is magical */\n    if (!strcasecmp(use, \"\\\\Inbox\"))\n        return mboxname_user_mbox(userid, NULL);\n\n    struct _find_specialuse_data rock = { use, userid, NULL };\n    mboxlist_usermboxtree(userid, _find_specialuse, &rock, MBOXTREE_SKIP_ROOT);\n    return rock.mboxname;\n}\n\nstruct _find_uniqueid_data {\n    const char *uniqueid;\n    char *mboxname;\n};\n\nstatic int _find_uniqueid(const mbentry_t *mbentry, void *rock) {\n    struct _find_uniqueid_data *d = (struct _find_uniqueid_data *) rock;\n    int r = 0;\n    if (!strcmp(d->uniqueid, mbentry->uniqueid)) {\n        d->mboxname = xstrdup(mbentry->name);\n        r = CYRUSDB_DONE;\n    }\n    return r;\n}\n\nEXPORTED char *mboxlist_find_uniqueid(const char *uniqueid, const char *userid)\n{\n    struct _find_uniqueid_data rock = { uniqueid, NULL };\n    mboxlist_usermboxtree(userid, _find_uniqueid, &rock, MBOXTREE_PLUS_RACL);\n    return rock.mboxname;\n}\n\n/* given a mailbox name, find the staging directory.  XXX - this should\n * require more locking, and staging directories should be by pid */\nHIDDEN int mboxlist_findstage(const char *name, char *stagedir, size_t sd_len)\n{\n    const char *root;\n    mbentry_t *mbentry = NULL;\n    int r;\n\n    assert(stagedir != NULL);\n\n    /* Find mailbox */\n    r = mboxlist_lookup(name, &mbentry, NULL);\n    if (r) return r;\n\n    root = config_partitiondir(mbentry->partition);\n    mboxlist_entry_free(&mbentry);\n\n    if (!root) return IMAP_PARTITION_UNKNOWN;\n\n    snprintf(stagedir, sd_len, \"%s/stage./\", root);\n\n    return 0;\n}\n\nstatic void mboxlist_racl_key(int isuser, const char *keyuser, const char *mbname, struct buf *buf)\n{\n    buf_setcstr(buf, \"$RACL$\");\n    buf_putc(buf, isuser ? 'U' : 'S');\n    buf_putc(buf, '$');\n    if (keyuser) {\n        buf_appendcstr(buf, keyuser);\n        buf_putc(buf, '$');\n    }\n    if (mbname) {\n        buf_appendcstr(buf, mbname);\n    }\n}\n\nstatic int user_is_in(const strarray_t *aclbits, const char *user)\n{\n    int i;\n    if (!aclbits) return 0;\n    for (i = 0; i+1 < strarray_size(aclbits); i+=2) {\n        if (!strcmp(strarray_nth(aclbits, i), user)) return 1;\n    }\n    return 0;\n}\n\nstatic int mboxlist_update_racl(const char *name, const mbentry_t *oldmbentry, const mbentry_t *newmbentry, struct txn **txn)\n{\n    static strarray_t *admins = NULL;\n    struct buf buf = BUF_INITIALIZER;\n    char *userid = mboxname_to_userid(name);\n    strarray_t *oldusers = NULL;\n    strarray_t *newusers = NULL;\n    int i;\n    int r = 0;\n\n    if (!admins) admins = strarray_split(config_getstring(IMAPOPT_ADMINS), NULL, 0);\n\n    if (oldmbentry && oldmbentry->mbtype != MBTYPE_DELETED)\n        oldusers = strarray_split(oldmbentry->acl, \"\\t\", 0);\n\n    if (newmbentry && newmbentry->mbtype != MBTYPE_DELETED)\n        newusers = strarray_split(newmbentry->acl, \"\\t\", 0);\n\n    if (oldusers) {\n        for (i = 0; i+1 < strarray_size(oldusers); i+=2) {\n            const char *acluser = strarray_nth(oldusers, i);\n            const char *aclval = strarray_nth(oldusers, i+1);\n            if (!strchr(aclval, 'l')) continue; /* non-lookup ACLs can be skipped */\n            if (!strcmpsafe(userid, acluser)) continue;\n            if (strarray_find(admins, acluser, 0) >= 0) continue;\n            if (user_is_in(newusers, acluser)) continue;\n            mboxlist_racl_key(!!userid, acluser, name, &buf);\n            r = cyrusdb_delete(mbdb, buf.s, buf.len, txn, /*force*/1);\n            if (r) goto done;\n        }\n    }\n\n    if (newusers) {\n        for (i = 0; i+1 < strarray_size(newusers); i+=2) {\n            const char *acluser = strarray_nth(newusers, i);\n            const char *aclval = strarray_nth(newusers, i+1);\n            if (!strchr(aclval, 'l')) continue; /* non-lookup ACLs can be skipped */\n            if (!strcmpsafe(userid, acluser)) continue;\n            if (strarray_find(admins, acluser, 0) >= 0) continue;\n            if (user_is_in(oldusers, acluser)) continue;\n            mboxlist_racl_key(!!userid, acluser, name, &buf);\n            r = cyrusdb_store(mbdb, buf.s, buf.len, \"\", 0, txn);\n            if (r) goto done;\n        }\n    }\n\n done:\n    strarray_free(oldusers);\n    strarray_free(newusers);\n    free(userid);\n    buf_free(&buf);\n    return r;\n}\n\nstatic int mboxlist_update_entry(const char *name, const mbentry_t *mbentry, struct txn **txn)\n{\n    mbentry_t *old = NULL;\n    int r = 0;\n\n    mboxlist_mylookup(name, &old, txn, 0); // ignore errors, it will be NULL\n\n    if (!cyrusdb_fetch(mbdb, \"$RACL\", 5, NULL, NULL, txn)) {\n        r = mboxlist_update_racl(name, old, mbentry, txn);\n        /* XXX return value here is discarded? */\n    }\n\n    if (mbentry) {\n        char *mboxent = mboxlist_entry_cstring(mbentry);\n        r = cyrusdb_store(mbdb, name, strlen(name), mboxent, strlen(mboxent), txn);\n        free(mboxent);\n\n        if (!r && config_auditlog) {\n            /* XXX is there a difference between \"\" and NULL? */\n            if (old && strcmpsafe(old->acl, mbentry->acl)) {\n                syslog(LOG_NOTICE, \"auditlog: acl sessionid=<%s> \"\n                                   \"mailbox=<%s> uniqueid=<%s> \"\n                                   \"oldacl=<%s> acl=<%s>\",\n                       session_id(),\n                       name, mbentry->uniqueid,\n                       old->acl, mbentry->acl);\n            }\n        }\n    }\n    else {\n        r = cyrusdb_delete(mbdb, name, strlen(name), txn, /*force*/1);\n    }\n\n    mboxlist_entry_free(&old);\n    return r;\n}\n\nEXPORTED int mboxlist_delete(const char *name)\n{\n    return mboxlist_update_entry(name, NULL, NULL);\n}\n\nEXPORTED int mboxlist_update(mbentry_t *mbentry, int localonly)\n{\n    int r = 0, r2 = 0;\n    struct txn *tid = NULL;\n\n    r = mboxlist_update_entry(mbentry->name, mbentry, &tid);\n\n    if (!r)\n        mboxname_setmodseq(mbentry->name, mbentry->foldermodseq, mbentry->mbtype, /*dofolder*/1);\n\n    /* commit the change to mupdate */\n    if (!r && !localonly && config_mupdate_server) {\n        mupdate_handle *mupdate_h = NULL;\n\n        r = mupdate_connect(config_mupdate_server, NULL, &mupdate_h, NULL);\n        if (r) {\n            syslog(LOG_ERR,\n                   \"cannot connect to mupdate server for update of '%s'\",\n                   mbentry->name);\n        } else {\n            char *location = strconcat(config_servername, \"!\",\n                                       mbentry->partition, (char *)NULL);\n            r = mupdate_activate(mupdate_h, mbentry->name,\n                                 location, mbentry->acl);\n            free(location);\n            if (r) {\n                syslog(LOG_ERR,\n                       \"MUPDATE: can't update mailbox entry for '%s'\",\n                       mbentry->name);\n            }\n        }\n        mupdate_disconnect(&mupdate_h);\n    }\n\n    if (tid) {\n        if (r) {\n            r2 = cyrusdb_abort(mbdb, tid);\n        } else {\n            r2 = cyrusdb_commit(mbdb, tid);\n        }\n    }\n\n    if (r2) {\n        syslog(LOG_ERR, \"DBERROR: error %s txn in mboxlist_update: %s\",\n               r ? \"aborting\" : \"commiting\", cyrusdb_strerror(r2));\n    }\n\n    return r;\n}\n\nEXPORTED int mboxlist_findparent(const char *mboxname,\n                               mbentry_t **mbentryp)\n{\n    mbentry_t *mbentry = NULL;\n    mbname_t *mbname = mbname_from_intname(mboxname);\n    int r = IMAP_MAILBOX_NONEXISTENT;\n\n    while (strarray_size(mbname_boxes(mbname))) {\n        free(mbname_pop_boxes(mbname));\n        mboxlist_entry_free(&mbentry);\n        r = mboxlist_lookup(mbname_intname(mbname), &mbentry, NULL);\n        if (r != IMAP_MAILBOX_NONEXISTENT)\n            break;\n    }\n\n    if (r)\n        mboxlist_entry_free(&mbentry);\n    else\n        *mbentryp = mbentry;\n\n    mbname_free(&mbname);\n\n    return r;\n}\n\nstatic int mboxlist_create_partition(const char *mboxname,\n                                     const char *part,\n                                     char **out)\n{\n    mbentry_t *parent = NULL;\n\n    if (!part) {\n        int r = mboxlist_findparent(mboxname, &parent);\n        if (!r) part = parent->partition;\n    }\n\n    /* use defaultpartition if specified */\n    if (!part && config_defpartition)\n        part = config_defpartition;\n\n    /* look for most fitting partition */\n    if (!part)\n        part = partlist_local_select();\n\n    /* Configuration error */\n    if (!part || (strlen(part) > MAX_PARTITION_LEN))\n        goto err;\n\n    if (!config_partitiondir(part))\n        goto err;\n\n    *out = xstrdupnull(part);\n\n    mboxlist_entry_free(&parent);\n    return 0;\n\nerr:\n    mboxlist_entry_free(&parent);\n    return IMAP_PARTITION_UNKNOWN;\n}\n\n/*\n * Check if a mailbox can be created.  There is no other setup at this\n * stage, just the check!\n */\nstatic int mboxlist_create_namecheck(const char *mboxname,\n                                     const char *userid,\n                                     const struct auth_state *auth_state,\n                                     int isadmin, int force_subdirs)\n{\n    mbentry_t *mbentry = NULL;\n    int r = 0;\n\n    /* policy first */\n    r = mboxname_policycheck(mboxname);\n    if (r) goto done;\n\n    /* is this the user's INBOX namespace? */\n    if (!isadmin && mboxname_userownsmailbox(userid, mboxname)) {\n        /* User has admin rights over their own mailbox namespace */\n        if (config_implicitrights & ACL_ADMIN)\n            isadmin = 1;\n    }\n\n    /* Check to see if mailbox already exists */\n    r = mboxlist_lookup(mboxname, &mbentry, NULL);\n    if (r != IMAP_MAILBOX_NONEXISTENT) {\n        if (!r) {\n            r = IMAP_MAILBOX_EXISTS;\n\n            /* Lie about error if privacy demands */\n            if (!isadmin &&\n                !(cyrus_acl_myrights(auth_state, mbentry->acl) & ACL_LOOKUP)) {\n                r = IMAP_PERMISSION_DENIED;\n            }\n        }\n\n        goto done;\n    }\n    mboxlist_entry_free(&mbentry);\n\n    /* look for a parent mailbox */\n    r = mboxlist_findparent(mboxname, &mbentry);\n    if (r == 0) {\n        /* found a parent */\n        char root[MAX_MAILBOX_NAME+1];\n\n        /* check acl */\n        if (!isadmin &&\n            !(cyrus_acl_myrights(auth_state, mbentry->acl) & ACL_CREATE)) {\n            r = IMAP_PERMISSION_DENIED;\n            goto done;\n        }\n\n        /* check quota */\n        if (quota_findroot(root, sizeof(root), mboxname)) {\n            quota_t qdiffs[QUOTA_NUMRESOURCES] = QUOTA_DIFFS_DONTCARE_INITIALIZER;\n            qdiffs[QUOTA_NUMFOLDERS] = 1;\n            r = quota_check_useds(root, qdiffs);\n            if (r) goto done;\n        }\n    }\n    else if (r == IMAP_MAILBOX_NONEXISTENT) {\n        /* no parent mailbox */\n        if (!isadmin) {\n            r = IMAP_PERMISSION_DENIED;\n            goto done;\n        }\n\n        if (!force_subdirs) {\n            mbname_t *mbname = mbname_from_intname(mboxname);\n            if (!mbname_isdeleted(mbname) && mbname_userid(mbname) && strarray_size(mbname_boxes(mbname))) {\n                /* Disallow creating user.X.* when no user.X */\n                r = IMAP_PERMISSION_DENIED;\n                goto done;\n            }\n            mbname_free(&mbname);\n        }\n\n        /* otherwise no parent is OK */\n        r = 0;\n    }\n\ndone:\n    mboxlist_entry_free(&mbentry);\n\n    return r;\n}\n\nstatic int mboxlist_create_acl(const char *mboxname, char **out)\n{\n    mbentry_t *mbentry = NULL;\n    int r;\n    int mask;\n\n    char *defaultacl;\n    char *identifier;\n    char *rights;\n    char *p;\n\n    r = mboxlist_findparent(mboxname, &mbentry);\n    if (!r) {\n        *out = xstrdup(mbentry->acl);\n        mboxlist_entry_free(&mbentry);\n        return 0;\n    }\n\n    *out = xstrdup(\"\");\n    char *owner = mboxname_to_userid(mboxname);\n    if (owner) {\n        /* owner gets full permission on own mailbox by default */\n        cyrus_acl_set(out, owner, ACL_MODE_SET, ACL_ALL,\n                      (cyrus_acl_canonproc_t *)0, (void *)0);\n        free(owner);\n        return 0;\n    }\n\n    defaultacl = identifier = xstrdup(config_getstring(IMAPOPT_DEFAULTACL));\n    for (;;) {\n        while (*identifier && Uisspace(*identifier)) identifier++;\n        rights = identifier;\n        while (*rights && !Uisspace(*rights)) rights++;\n        if (!*rights) break;\n        *rights++ = '\\0';\n        while (*rights && Uisspace(*rights)) rights++;\n        if (!*rights) break;\n        p = rights;\n        while (*p && !Uisspace(*p)) p++;\n        if (*p) *p++ = '\\0';\n        cyrus_acl_strtomask(rights, &mask);\n        /* XXX and if strtomask fails? */\n        cyrus_acl_set(out, identifier, ACL_MODE_SET, mask,\n                      (cyrus_acl_canonproc_t *)0, (void *)0);\n        identifier = p;\n    }\n    free(defaultacl);\n\n    return 0;\n}\n\n/* and this API just plain sucks */\nEXPORTED int mboxlist_createmailboxcheck(const char *name, int mbtype __attribute__((unused)),\n                                const char *partition,\n                                int isadmin, const char *userid,\n                                const struct auth_state *auth_state,\n                                char **newacl, char **newpartition,\n                                int forceuser)\n{\n    char *part = NULL;\n    char *acl = NULL;\n    int r = 0;\n\n    r = mboxlist_create_namecheck(name, userid, auth_state,\n                                  isadmin, forceuser);\n    if (r) goto done;\n\n    if (newacl) {\n        r = mboxlist_create_acl(name, &acl);\n        if (r) goto done;\n    }\n\n    if (newpartition) {\n        r = mboxlist_create_partition(name, partition, &part);\n        if (r) goto done;\n    }\n\n done:\n    if (r || !newacl) free(acl);\n    else *newacl = acl;\n\n    if (r || !newpartition) free(part);\n    else *newpartition = part;\n\n    return r;\n}\n\n/*\n * Create a mailbox\n *\n * 1. verify ACL's to best of ability (CRASH: abort)\n * 2. verify parent ACL's if need to\n * 3. create the local mailbox locally (exclusive lock) and keep it locked\n * 4. open mupdate connection if necessary\n * 5. create mupdate entry (CRASH: mupdate inconsistant)\n *\n */\n\nstatic int mboxlist_createmailbox_full(const char *mboxname, int mbtype,\n                                const char *partition,\n                                int isadmin, const char *userid,\n                                const struct auth_state *auth_state,\n                                int options, unsigned uidvalidity,\n                                modseq_t highestmodseq,\n                                const char *copyacl, const char *uniqueid,\n                                int localonly, int forceuser, int dbonly,\n                                struct mailbox **mboxptr)\n{\n    int r;\n    char *newpartition = NULL;\n    char *acl = NULL;\n    struct mailbox *newmailbox = NULL;\n    int isremote = mbtype & MBTYPE_REMOTE;\n    mbentry_t *newmbentry = NULL;\n\n    r = mboxlist_create_namecheck(mboxname, userid, auth_state,\n                                  isadmin, forceuser);\n    if (r) goto done;\n\n    if (copyacl) {\n        acl = xstrdup(copyacl);\n    }\n    else {\n        r = mboxlist_create_acl(mboxname, &acl);\n        if (r) goto done;\n    }\n\n    r = mboxlist_create_partition(mboxname, partition, &newpartition);\n    if (r) goto done;\n\n    if (!dbonly && !isremote) {\n        /* Filesystem Operations */\n        r = mailbox_create(mboxname, mbtype, newpartition, acl, uniqueid,\n                           options, uidvalidity, highestmodseq, &newmailbox);\n        if (r) goto done; /* CREATE failed */\n        r = mailbox_add_conversations(newmailbox);\n        if (r) goto done;\n    }\n\n    /* all is well - activate the mailbox */\n    newmbentry = mboxlist_entry_create();\n    newmbentry->acl = xstrdupnull(acl);\n    newmbentry->mbtype = mbtype;\n    newmbentry->partition = xstrdupnull(newpartition);\n    if (newmailbox) {\n        newmbentry->uniqueid = xstrdupnull(newmailbox->uniqueid);\n        newmbentry->uidvalidity = newmailbox->i.uidvalidity;\n        newmbentry->foldermodseq = newmailbox->i.highestmodseq;\n    }\n    r = mboxlist_update_entry(mboxname, newmbentry, NULL);\n\n    if (r) {\n        syslog(LOG_ERR, \"DBERROR: failed to insert to mailboxes list %s: %s\",\n               mboxname, cyrusdb_strerror(r));\n        r = IMAP_IOERROR;\n    }\n\n    /* 9. set MUPDATE entry as commited (CRASH: commited) */\n    if (!r && config_mupdate_server && !localonly) {\n        mupdate_handle *mupdate_h = NULL;\n        char *loc = strconcat(config_servername, \"!\", newpartition, (char *)NULL);\n\n        r = mupdate_connect(config_mupdate_server, NULL, &mupdate_h, NULL);\n        if (!r) r = mupdate_reserve(mupdate_h, mboxname, loc);\n        if (!r) r = mupdate_activate(mupdate_h, mboxname, loc, acl);\n        if (r) {\n            syslog(LOG_ERR, \"MUPDATE: can't commit mailbox entry for '%s'\",\n                   mboxname);\n            mboxlist_update_entry(mboxname, NULL, 0);\n        }\n        if (mupdate_h) mupdate_disconnect(&mupdate_h);\n        free(loc);\n    }\n\ndone:\n    if (newmailbox) {\n        if (r) mailbox_delete(&newmailbox);\n        else if (mboxptr) *mboxptr = newmailbox;\n        else mailbox_close(&newmailbox);\n    }\n\n    free(acl);\n    free(newpartition);\n    mboxlist_entry_free(&newmbentry);\n\n    return r;\n}\n\nEXPORTED int mboxlist_createmailbox(const char *name, int mbtype,\n                           const char *partition,\n                           int isadmin, const char *userid,\n                           const struct auth_state *auth_state,\n                           int localonly, int forceuser, int dbonly,\n                           int notify, struct mailbox **mailboxptr)\n{\n    int options = config_getint(IMAPOPT_MAILBOX_DEFAULT_OPTIONS)\n                  | OPT_POP3_NEW_UIDL;\n    int r;\n    struct mailbox *mailbox = NULL;\n    uint32_t uidvalidity = 0;\n\n    /* check if a previous deleted mailbox existed */\n    mbentry_t *oldmbentry = NULL;\n    r = mboxlist_lookup_allow_all(name, &oldmbentry, NULL);\n    if (!r && oldmbentry->mbtype == MBTYPE_DELETED) {\n        /* then the UIDVALIDITY must be higher than before */\n        if (uidvalidity <= oldmbentry->uidvalidity)\n            uidvalidity = oldmbentry->uidvalidity+1;\n    }\n    mboxlist_entry_free(&oldmbentry);\n\n    r = mboxlist_createmailbox_full(name, mbtype, partition,\n                                    isadmin, userid, auth_state,\n                                    options, uidvalidity, 0, NULL, NULL, localonly,\n                                    forceuser, dbonly, &mailbox);\n\n    if (notify && !r) {\n        /* send a MailboxCreate event notification */\n        struct mboxevent *mboxevent = mboxevent_new(EVENT_MAILBOX_CREATE);\n        mboxevent_extract_mailbox(mboxevent, mailbox);\n        mboxevent_set_access(mboxevent, NULL, NULL, userid, mailbox->name, 1);\n\n        mboxevent_notify(&mboxevent);\n        mboxevent_free(&mboxevent);\n    }\n\n    if (mailboxptr && !r) *mailboxptr = mailbox;\n    else mailbox_close(&mailbox);\n\n    return r;\n}\n\nEXPORTED int mboxlist_createsync(const char *name, int mbtype,\n                        const char *partition,\n                        const char *userid, const struct auth_state *auth_state,\n                        int options, unsigned uidvalidity,\n                        modseq_t highestmodseq,\n                        const char *acl, const char *uniqueid,\n                        int local_only, struct mailbox **mboxptr)\n{\n    return mboxlist_createmailbox_full(name, mbtype, partition,\n                                       1, userid, auth_state,\n                                       options, uidvalidity,\n                                       highestmodseq, acl, uniqueid,\n                                       local_only, 1, 0, mboxptr);\n}\n\n/* insert an entry for the proxy */\nEXPORTED int mboxlist_insertremote(mbentry_t *mbentry,\n                          struct txn **txn)\n{\n    int r = 0;\n\n    if (mbentry->server) {\n        /* remote mailbox */\n        if (config_mupdate_config == IMAP_ENUM_MUPDATE_CONFIG_UNIFIED &&\n            !strcasecmp(mbentry->server, config_servername)) {\n            /* its on our server, make it a local mailbox */\n            mbentry->mbtype &= ~MBTYPE_REMOTE;\n            mbentry->server = NULL;\n        }\n        else {\n            /* make sure it's a remote mailbox */\n            mbentry->mbtype |= MBTYPE_REMOTE;\n        }\n    }\n\n    /* database put */\n    r = mboxlist_update_entry(mbentry->name, mbentry, txn);\n\n    switch (r) {\n    case CYRUSDB_OK:\n        break;\n    case CYRUSDB_AGAIN:\n        abort(); /* shouldn't happen ! */\n        break;\n    default:\n        syslog(LOG_ERR, \"DBERROR: error updating database %s: %s\",\n               mbentry->name, cyrusdb_strerror(r));\n        r = IMAP_IOERROR;\n        break;\n    }\n\n    return r;\n}\n\n/* Special function to delete a remote mailbox.\n * Only affects mboxlist.\n * Assumes admin powers. */\nEXPORTED int mboxlist_deleteremote(const char *name, struct txn **in_tid)\n{\n    int r;\n    struct txn **tid;\n    struct txn *lcl_tid = NULL;\n    mbentry_t *mbentry = NULL;\n\n    if(in_tid) {\n        tid = in_tid;\n    } else {\n        tid = &lcl_tid;\n    }\n\n retry:\n    r = mboxlist_mylookup(name, &mbentry, tid, 1);\n    switch (r) {\n    case 0:\n        break;\n\n    case IMAP_MAILBOX_NONEXISTENT:\n        r = 0;\n        break;\n\n    case IMAP_AGAIN:\n        goto retry;\n        break;\n\n    default:\n        goto done;\n    }\n\n    if (mbentry && (mbentry->mbtype & MBTYPE_REMOTE) && !mbentry->server) {\n        syslog(LOG_ERR,\n               \"mboxlist_deleteremote called on non-remote mailbox: %s\",\n               name);\n        goto done;\n    }\n\n    r = mboxlist_update_entry(name, NULL, tid);\n    if (r) {\n        syslog(LOG_ERR, \"DBERROR: error deleting %s: %s\",\n               name, cyrusdb_strerror(r));\n        r = IMAP_IOERROR;\n    }\n\n    /* commit db operations, but only if we weren't passed a transaction */\n    if (!in_tid) {\n        r = cyrusdb_commit(mbdb, *tid);\n        if (r) {\n            syslog(LOG_ERR, \"DBERROR: failed on commit: %s\",\n                   cyrusdb_strerror(r));\n            r = IMAP_IOERROR;\n        }\n        tid = NULL;\n    }\n\n done:\n    if (r && !in_tid && tid) {\n        /* Abort the transaction if it is still in progress */\n        cyrusdb_abort(mbdb, *tid);\n    }\n\n    return r;\n}\n\nstatic int addmbox_to_list(const mbentry_t *mbentry, void *rock)\n{\n    strarray_t *list = (strarray_t *)rock;\n    strarray_append(list, mbentry->name);\n    return 0;\n}\n\n/*\n * Delayed Delete a mailbox: translate delete into rename\n */\nEXPORTED int\nmboxlist_delayed_deletemailbox(const char *name, int isadmin,\n                               const char *userid,\n                               const struct auth_state *auth_state,\n                               struct mboxevent *mboxevent,\n                               int checkacl,\n                               int localonly,\n                               int force)\n{\n    mbentry_t *mbentry = NULL;\n    strarray_t existing = STRARRAY_INITIALIZER;\n    int i;\n    char newname[MAX_MAILBOX_BUFFER];\n    int r = 0;\n    long myrights;\n\n    if (!isadmin && force) return IMAP_PERMISSION_DENIED;\n\n    /* delete of a user.X folder */\n    mbname_t *mbname = mbname_from_intname(name);\n    if (mbname_userid(mbname) && !strarray_size(mbname_boxes(mbname))) {\n        /* Can't DELETE INBOX (your own inbox) */\n        if (!strcmpsafe(mbname_userid(mbname), userid)) {\n            r = IMAP_MAILBOX_NOTSUPPORTED;\n            goto done;\n        }\n        /* Only admins may delete user */\n        if (!isadmin) {\n            r = IMAP_PERMISSION_DENIED;\n            goto done;\n        }\n    }\n\n    if (!isadmin && mbname_userid(mbname)) {\n        struct buf attrib = BUF_INITIALIZER;\n        annotatemore_lookup(mbname_intname(mbname), \"/specialuse\", mbname_userid(mbname), &attrib);\n        if (attrib.len)\n            r = IMAP_MAILBOX_SPECIALUSE;\n        buf_free(&attrib);\n        if (r) goto done;\n    }\n\n    r = mboxlist_lookup(name, &mbentry, NULL);\n    if (r) goto done;\n\n    /* check if user has Delete right (we've already excluded non-admins\n     * from deleting a user mailbox) */\n    if (checkacl) {\n        myrights = cyrus_acl_myrights(auth_state, mbentry->acl);\n        if (!(myrights & ACL_DELETEMBOX)) {\n            /* User has admin rights over their own mailbox namespace */\n            if (mboxname_userownsmailbox(userid, name) &&\n                (config_implicitrights & ACL_ADMIN)) {\n                isadmin = 1;\n            }\n\n            /* Lie about error if privacy demands */\n            r = (isadmin || (myrights & ACL_LOOKUP)) ?\n                IMAP_PERMISSION_DENIED : IMAP_MAILBOX_NONEXISTENT;\n\n            goto done;\n        }\n    }\n\n    /* check if there are already too many! */\n    mboxname_todeleted(name, newname, 0);\n    r = mboxlist_mboxtree(newname, addmbox_to_list, &existing, MBOXTREE_SKIP_ROOT);\n    if (r) goto done;\n\n    /* keep the last 19, so the new one is the 20th */\n    for (i = 0; i < (int)existing.count - 19; i++) {\n        const char *subname = strarray_nth(&existing, i);\n        syslog(LOG_NOTICE, \"too many subfolders for %s, deleting %s (%d / %d)\",\n               newname, subname, i+1, (int)existing.count);\n        r = mboxlist_deletemailbox(subname, 1, userid, auth_state, NULL, 0, 1, 1);\n        if (r) goto done;\n    }\n\n    /* get the deleted name */\n    mboxname_todeleted(name, newname, 1);\n\n    /* Get mboxlist_renamemailbox to do the hard work. No ACL checks needed */\n    r = mboxlist_renamemailbox((char *)name, newname, mbentry->partition,\n                               0 /* uidvalidity */,\n                               1 /* isadmin */, userid,\n                               auth_state,\n                               mboxevent,\n                               localonly /* local_only */,\n                               force, 1);\n\ndone:\n    strarray_fini(&existing);\n    mboxlist_entry_free(&mbentry);\n    mbname_free(&mbname);\n\n    return r;\n}\n\n/*\n * Delete a mailbox.\n * Deleting the mailbox user.FOO may only be performed by an admin.\n *\n * 1. Begin transaction\n * 2. Verify ACL's\n * 3. remove from database\n * 4. remove from disk\n * 5. commit transaction\n * 6. Open mupdate connection if necessary\n * 7. delete from mupdate\n *\n */\nEXPORTED int mboxlist_deletemailbox(const char *name, int isadmin,\n                                    const char *userid,\n                                    const struct auth_state *auth_state,\n                                    struct mboxevent *mboxevent,\n                                    int checkacl,\n                                    int local_only, int force)\n{\n    mbentry_t *mbentry = NULL;\n    int r = 0;\n    long myrights;\n    struct mailbox *mailbox = NULL;\n    int isremote = 0;\n    mupdate_handle *mupdate_h = NULL;\n\n    if (!isadmin && force) return IMAP_PERMISSION_DENIED;\n\n    /* delete of a user.X folder */\n    mbname_t *mbname = mbname_from_intname(name);\n    if (mbname_userid(mbname) && !strarray_size(mbname_boxes(mbname))) {\n        /* Can't DELETE INBOX (your own inbox) */\n        if (!strcmpsafe(mbname_userid(mbname), userid)) {\n            r = IMAP_MAILBOX_NOTSUPPORTED;\n            goto done;\n        }\n        /* Only admins may delete user */\n        if (!isadmin) {\n            r = IMAP_PERMISSION_DENIED;\n            goto done;\n        }\n    }\n\n    if (!isadmin && mbname_userid(mbname)) {\n        struct buf attrib = BUF_INITIALIZER;\n        annotatemore_lookup(mbname_intname(mbname), \"/specialuse\", mbname_userid(mbname), &attrib);\n        if (attrib.len)\n            r = IMAP_MAILBOX_SPECIALUSE;\n        buf_free(&attrib);\n        if (r) goto done;\n    }\n\n    r = mboxlist_lookup_allow_all(name, &mbentry, NULL);\n    if (r) goto done;\n\n    isremote = mbentry->mbtype & MBTYPE_REMOTE;\n\n    /* check if user has Delete right (we've already excluded non-admins\n     * from deleting a user mailbox) */\n    if (checkacl) {\n        myrights = cyrus_acl_myrights(auth_state, mbentry->acl);\n        if(!(myrights & ACL_DELETEMBOX)) {\n            /* User has admin rights over their own mailbox namespace */\n            if (mboxname_userownsmailbox(userid, name) &&\n                (config_implicitrights & ACL_ADMIN)) {\n                isadmin = 1;\n            }\n\n            /* Lie about error if privacy demands */\n            r = (isadmin || (myrights & ACL_LOOKUP)) ?\n                IMAP_PERMISSION_DENIED : IMAP_MAILBOX_NONEXISTENT;\n            goto done;\n        }\n    }\n\n    /* Lock the mailbox if it isn't a remote mailbox */\n    if (!isremote) {\n        r = mailbox_open_iwl(name, &mailbox);\n    }\n    if (r && !force) goto done;\n\n    /* remove from mupdate */\n    if (!isremote && !local_only && config_mupdate_server) {\n        /* delete the mailbox in MUPDATE */\n        r = mupdate_connect(config_mupdate_server, NULL, &mupdate_h, NULL);\n        if (r) {\n            syslog(LOG_ERR,\n                   \"cannot connect to mupdate server for delete of '%s'\",\n                   name);\n            goto done;\n        }\n        r = mupdate_delete(mupdate_h, name);\n        if(r) {\n            syslog(LOG_ERR,\n                   \"MUPDATE: can't delete mailbox entry '%s'\", name);\n        }\n        if (mupdate_h) mupdate_disconnect(&mupdate_h);\n    }\n    if (r && !force) goto done;\n\n    if (!isremote && !mboxname_isdeletedmailbox(name, NULL)) {\n        /* store a DELETED marker */\n        mbentry_t *newmbentry = mboxlist_entry_create();\n        newmbentry->name = xstrdupnull(name);\n        newmbentry->mbtype = MBTYPE_DELETED;\n        if (mailbox) {\n            newmbentry->uniqueid = xstrdupnull(mailbox->uniqueid);\n            newmbentry->uidvalidity = mailbox->i.uidvalidity;\n            newmbentry->foldermodseq = mailbox_modseq_dirty(mailbox);\n        }\n        r = mboxlist_update(newmbentry, /*localonly*/1);\n        mboxlist_entry_free(&newmbentry);\n    }\n    else {\n        /* delete entry (including DELETED.* mailboxes, no need\n         * to keep that rubbish around) */\n        r = mboxlist_update_entry(name, NULL, 0);\n        if (r) {\n            syslog(LOG_ERR, \"DBERROR: error deleting %s: %s\",\n                   name, cyrusdb_strerror(r));\n            r = IMAP_IOERROR;\n            if (!force) goto done;\n        }\n        if (r && !force) goto done;\n    }\n\n    /* delete underlying mailbox */\n    if (!isremote && mailbox) {\n        /* only on a real delete do we delete from the remote end as well */\n        sync_log_unmailbox(mailbox->name);\n        mboxevent_extract_mailbox(mboxevent, mailbox);\n        mboxevent_set_access(mboxevent, NULL, NULL, userid, mailbox->name, 1);\n\n        r = mailbox_delete(&mailbox);\n        /* abort event notification */\n        if (r && mboxevent)\n            mboxevent_free(&mboxevent);\n    }\n\n done:\n    mailbox_close(&mailbox);\n    mboxlist_entry_free(&mbentry);\n    mbname_free(&mbname);\n\n    return r;\n}\n\nstatic int _rename_check_specialuse(const char *oldname, const char *newname)\n{\n    mbname_t *old = mbname_from_intname(oldname);\n    mbname_t *new = mbname_from_intname(newname);\n    struct buf attrib = BUF_INITIALIZER;\n    int r = 0;\n    if (mbname_userid(old))\n        annotatemore_lookup(oldname, \"/specialuse\", mbname_userid(old), &attrib);\n    /* we have specialuse? */\n    if (attrib.len) {\n        /* then target must be a single-depth mailbox too */\n        if (strarray_size(mbname_boxes(new)) != 1)\n            r = IMAP_MAILBOX_SPECIALUSE;\n        /* and have a userid as well */\n        if (!mbname_userid(new))\n            r = IMAP_MAILBOX_SPECIALUSE;\n        /* and not be deleted */\n        if (mbname_isdeleted(new))\n            r = IMAP_MAILBOX_SPECIALUSE;\n    }\n    mbname_free(&new);\n    mbname_free(&old);\n    buf_free(&attrib);\n    return r;\n}\n\n/*\n * Rename/move a single mailbox (recursive renames are handled at a\n * higher level).  This only supports local mailboxes.  Remote\n * mailboxes are handled up in imapd.c\n */\nEXPORTED int mboxlist_renamemailbox(const char *oldname, const char *newname,\n                           const char *partition, unsigned uidvalidity,\n                           int isadmin, const char *userid,\n                           const struct auth_state *auth_state,\n                           struct mboxevent *mboxevent,\n                           int local_only, int forceuser, int ignorequota)\n{\n    int r;\n    int mupdatecommiterror = 0;\n    long myrights;\n    int isusermbox = 0; /* Are we renaming someone's inbox */\n    int partitionmove = 0;\n    struct mailbox *oldmailbox = NULL;\n    struct mailbox *newmailbox = NULL;\n    struct txn *tid = NULL;\n    const char *root = NULL;\n    char *newpartition = NULL;\n    mupdate_handle *mupdate_h = NULL;\n    mbentry_t *newmbentry = NULL;\n\n    /* 1. open mailbox */\n    r = mailbox_open_iwl(oldname, &oldmailbox);\n    if (r) return r;\n\n    myrights = cyrus_acl_myrights(auth_state, oldmailbox->acl);\n\n    /* check the ACLs up-front */\n    if (!isadmin) {\n        if (!(myrights & ACL_DELETEMBOX)) {\n            r = (myrights & ACL_LOOKUP) ?\n                IMAP_PERMISSION_DENIED : IMAP_MAILBOX_NONEXISTENT;\n            goto done;\n        }\n    }\n\n    /* 2. verify valid move */\n    /* XXX - handle remote mailbox */\n\n    /* special case: same mailbox, must be a partition move */\n    if (!strcmp(oldname, newname)) {\n        const char *oldpath = mailbox_datapath(oldmailbox, 0);\n\n        /* Only admin can move mailboxes between partitions */\n        if (!isadmin) {\n            r = IMAP_PERMISSION_DENIED;\n            goto done;\n        }\n\n        /* No partition, we're definitely not moving anywhere */\n        if (!partition) {\n            r = IMAP_MAILBOX_EXISTS;\n            goto done;\n        }\n\n        /* let mupdate code below know it was a partition move */\n        partitionmove = 1;\n\n        /* this is OK because it uses a different static buffer */\n        root = config_partitiondir(partition);\n        if (!root) {\n            r = IMAP_PARTITION_UNKNOWN;\n            goto done;\n        }\n        if (!strncmp(root, oldpath, strlen(root)) &&\n            oldpath[strlen(root)] == '/') {\n            /* partitions are the same or share common prefix */\n            r = IMAP_MAILBOX_EXISTS;\n            goto done;\n        }\n\n        /* NOTE: this is a rename to the same mailbox name on a\n         * different partition.  This is a pretty filthy hack,\n         * which should be handled by having four totally different\n         * codepaths: INBOX -> INBOX.foo, user rename, regular rename\n         * and of course this one, partition move */\n        newpartition = xstrdup(partition);\n        r = mailbox_copy_files(oldmailbox, newpartition, newname, oldmailbox->uniqueid);\n        if (r) goto done;\n        newmbentry = mboxlist_entry_create();\n        newmbentry->mbtype = oldmailbox->mbtype;\n        newmbentry->partition = xstrdupnull(newpartition);\n        newmbentry->acl = xstrdupnull(oldmailbox->acl);\n        newmbentry->uidvalidity = oldmailbox->i.uidvalidity;\n        newmbentry->uniqueid = xstrdupnull(oldmailbox->uniqueid);\n        newmbentry->foldermodseq = oldmailbox->i.highestmodseq; /* bump regardless, it's rare */\n\n        r = mboxlist_update_entry(newname, newmbentry, &tid);\n        if (r) goto done;\n\n        /* skip ahead to the commit */\n        goto dbdone;\n    }\n\n    if (!isadmin) {\n        r = _rename_check_specialuse(oldname, newname);\n        if (r) goto done;\n    }\n\n    /* RENAME of some user's INBOX */\n    if (mboxname_isusermailbox(oldname, 1)) {\n        if (mboxname_isdeletedmailbox(newname, NULL)) {\n            /* delete user is OK */\n        }\n        else if (mboxname_isusermailbox(newname, 1)) {\n            /* user rename is depends on config */\n            if (!config_getswitch(IMAPOPT_ALLOWUSERMOVES)) {\n                r = IMAP_MAILBOX_NOTSUPPORTED;\n                goto done;\n            }\n        }\n        else if (mboxname_userownsmailbox(userid, oldname) &&\n                 mboxname_userownsmailbox(userid, newname)) {\n            /* Special case of renaming inbox */\n            isusermbox = 1;\n        }\n        else {\n            /* Everything else is bogus */\n            r = IMAP_MAILBOX_NOTSUPPORTED;\n            goto done;\n        }\n    }\n\n    r = mboxlist_create_namecheck(newname, userid, auth_state,\n                                  isadmin, forceuser);\n    if (r) goto done;\n\n    r = mboxlist_create_partition(newname, partition, &newpartition);\n    if (r) goto done;\n\n    if (!newpartition) newpartition = xstrdup(config_defpartition);\n\n    /* keep uidvalidity on rename unless specified */\n    if (!uidvalidity)\n        uidvalidity = oldmailbox->i.uidvalidity;\n\n    /* Rename the actual mailbox */\n    r = mailbox_rename_copy(oldmailbox, newname, newpartition, uidvalidity,\n                            isusermbox ? userid : NULL, ignorequota,\n                            &newmailbox);\n\n    if (r) goto done;\n\n    syslog(LOG_INFO, \"Rename: %s -> %s\", oldname, newname);\n\n    /* create new entry */\n    newmbentry = mboxlist_entry_create();\n    newmbentry->name = xstrdupnull(newmailbox->name);\n    newmbentry->mbtype = newmailbox->mbtype;\n    newmbentry->partition = xstrdupnull(newmailbox->part);\n    newmbentry->acl = xstrdupnull(newmailbox->acl);\n    newmbentry->uidvalidity = newmailbox->i.uidvalidity;\n    newmbentry->uniqueid = xstrdupnull(newmailbox->uniqueid);\n    newmbentry->foldermodseq = newmailbox->i.highestmodseq;\n\n    do {\n        r = 0;\n\n        /* delete the old entry */\n        if (!isusermbox) {\n            /* store a DELETED marker */\n            mbentry_t *oldmbentry = mboxlist_entry_create();\n            oldmbentry->name = xstrdupnull(oldmailbox->name);\n            oldmbentry->mbtype = MBTYPE_DELETED;\n            oldmbentry->uidvalidity = oldmailbox->i.uidvalidity;\n            oldmbentry->uniqueid = xstrdupnull(oldmailbox->uniqueid);\n            oldmbentry->foldermodseq = mailbox_modseq_dirty(oldmailbox);\n\n            r = mboxlist_update_entry(oldname, oldmbentry, &tid);\n\n            mboxlist_entry_free(&oldmbentry);\n        }\n\n        /* create a new entry */\n        if (!r) {\n            r = mboxlist_update_entry(newname, newmbentry, &tid);\n        }\n\n        switch (r) {\n        case 0: /* success */\n            break;\n        case CYRUSDB_AGAIN:\n            tid = NULL;\n            break;\n        default:\n            syslog(LOG_ERR, \"DBERROR: rename failed on store %s %s: %s\",\n                   oldname, newname, cyrusdb_strerror(r));\n            r = IMAP_IOERROR;\n            goto done;\n            break;\n        }\n    } while (r == CYRUSDB_AGAIN);\n\n dbdone:\n\n    /* 3. Commit transaction */\n    r = cyrusdb_commit(mbdb, tid);\n    tid = NULL;\n    if (r) {\n        syslog(LOG_ERR, \"DBERROR: rename failed on commit %s %s: %s\",\n               oldname, newname, cyrusdb_strerror(r));\n        r = IMAP_IOERROR;\n        goto done;\n    }\n\n    if (!local_only && config_mupdate_server) {\n        /* commit the mailbox in MUPDATE */\n        char *loc = strconcat(config_servername, \"!\", newpartition, (char *)NULL);\n\n        r = mupdate_connect(config_mupdate_server, NULL, &mupdate_h, NULL);\n        if (!partitionmove) {\n            if (!r && !isusermbox)\n                r = mupdate_delete(mupdate_h, oldname);\n            if (!r) r = mupdate_reserve(mupdate_h, newname, loc);\n        }\n        if (!r) r = mupdate_activate(mupdate_h, newname, loc, newmbentry->acl);\n        if (r) {\n            syslog(LOG_ERR,\n                   \"MUPDATE: can't commit mailbox entry for '%s'\",\n                   newname);\n            mupdatecommiterror = r;\n        }\n        if (mupdate_h) mupdate_disconnect(&mupdate_h);\n        free(loc);\n    }\n\n done: /* Commit or cleanup */\n    if (!r && newmailbox)\n        r = mailbox_commit(newmailbox);\n\n    if (r) {\n        /* rollback DB changes if it was an mupdate failure */\n        if (mupdatecommiterror) {\n            r = 0;\n\n            /* recreate an old entry */\n            if (!isusermbox)\n                r = mboxlist_update_entry(oldname, newmbentry, &tid);\n\n            /* delete the new entry */\n            if (!r)\n                r = mboxlist_update_entry(newname, NULL, &tid);\n\n            /* Commit transaction */\n            if (!r)\n                r = cyrusdb_commit(mbdb, tid);\n\n            tid = NULL;\n            if (r) {\n                /* XXX HOWTO repair this mess! */\n                syslog(LOG_ERR, \"DBERROR: failed DB rollback on mailboxrename %s %s: %s\",\n                       oldname, newname, cyrusdb_strerror(r));\n                syslog(LOG_ERR, \"DBERROR: mailboxdb on mupdate and backend ARE NOT CONSISTENT\");\n                syslog(LOG_ERR, \"DBERROR: mailboxdb on mupdate has entry for %s, mailboxdb on backend has entry for %s and files are on the old position\", oldname, newname);\n                r = IMAP_IOERROR;\n            } else {\n                r = mupdatecommiterror;\n            }\n        }\n\n        if (newmailbox) mailbox_delete(&newmailbox);\n        if (partitionmove && newpartition)\n            mailbox_delete_cleanup(NULL, newpartition, newname, oldmailbox->uniqueid);\n        mailbox_close(&oldmailbox);\n    } else {\n        if (newmailbox) {\n            /* prepare the event notification */\n            if (mboxevent) {\n\n                /* case of delayed delete */\n                if (mboxevent->type == EVENT_MAILBOX_DELETE)\n                    mboxevent_extract_mailbox(mboxevent, oldmailbox);\n                else {\n                    mboxevent_extract_mailbox(mboxevent, newmailbox);\n                    mboxevent_extract_old_mailbox(mboxevent, oldmailbox);\n                }\n\n                mboxevent_set_access(mboxevent, NULL, NULL, userid, newmailbox->name, 1);\n            }\n\n            /* log the rename before we close either mailbox, so that\n             * we never nuke the mailbox from the replica before realising\n             * that it has been renamed.  This can be moved later again when\n             * we sync mailboxes by uniqueid rather than name... */\n            sync_log_mailbox_double(oldname, newname);\n\n            mailbox_rename_cleanup(&oldmailbox, isusermbox);\n\n#ifdef WITH_DAV\n            mailbox_add_dav(newmailbox);\n#endif\n\n            mailbox_close(&newmailbox);\n\n            /* and log an append so that squatter indexes it */\n            sync_log_append(newname);\n        }\n        else if (partitionmove) {\n            char *oldpartition = xstrdup(oldmailbox->part);\n            char *olduniqueid = xstrdup(oldmailbox->uniqueid);\n            if (config_auditlog)\n                syslog(LOG_NOTICE, \"auditlog: partitionmove sessionid=<%s> \"\n                       \"mailbox=<%s> uniqueid=<%s> oldpart=<%s> newpart=<%s>\",\n                       session_id(),\n                       oldmailbox->name, oldmailbox->uniqueid,\n                       oldpartition, partition);\n            /* this will sync-log the name anyway */\n            mailbox_close(&oldmailbox);\n            mailbox_delete_cleanup(NULL, oldpartition, oldname, olduniqueid);\n            free(olduniqueid);\n            free(oldpartition);\n        }\n        else\n            abort(); /* impossible, in theory */\n    }\n\n    /* free memory */\n    free(newpartition);\n    mboxlist_entry_free(&newmbentry);\n\n    return r;\n}\n\n/*\n * Check if the admin rights are present in the 'rights'\n */\nstatic int mboxlist_have_admin_rights(const char *rights) {\n    int access, have_admin_access;\n\n    cyrus_acl_strtomask(rights, &access);\n    have_admin_access = access & ACL_ADMIN;\n\n    return have_admin_access;\n}\n\n/*\n * Change the ACL for mailbox 'name' so that 'identifier' has the\n * rights enumerated in the string 'rights'.  If 'rights' is the null\n * pointer, removes the ACL entry for 'identifier'.   'isadmin' is\n * nonzero if user is a mailbox admin.  'userid' is the user's login id.\n *\n * 1. Start transaction\n * 2. Check rights\n * 3. Set db entry\n * 4. Change backup copy (cyrus.header)\n * 5. Commit transaction\n * 6. Change mupdate entry\n *\n */\nEXPORTED int mboxlist_setacl(const struct namespace *namespace __attribute__((unused)),\n                    const char *name,\n                    const char *identifier, const char *rights,\n                    int isadmin, const char *userid,\n                    const struct auth_state *auth_state)\n{\n    mbentry_t *mbentry = NULL;\n    int r;\n    int myrights;\n    int mode = ACL_MODE_SET;\n    int isusermbox = 0;\n    int isidentifiermbox = 0;\n    int anyoneuseracl = 1;\n    int ensure_owner_rights = 0;\n    int mask;\n    const char *mailbox_owner = NULL;\n    struct mailbox *mailbox = NULL;\n    char *newacl = NULL;\n    struct txn *tid = NULL;\n\n    /* round trip identifier to potentially strip domain */\n    mbname_t *mbname = mbname_from_userid(identifier);\n    /* XXX - enforce cross domain restrictions */\n    identifier = mbname_userid(mbname);\n\n    /* checks if the mailbox belongs to the user who is trying to change the\n       access rights */\n    if (mboxname_userownsmailbox(userid, name))\n        isusermbox = 1;\n    anyoneuseracl = config_getswitch(IMAPOPT_ANYONEUSERACL);\n\n    /* checks if the identifier is the mailbox owner */\n    if (mboxname_userownsmailbox(identifier, name))\n        isidentifiermbox = 1;\n\n    /* who is the mailbox owner? */\n    if (isusermbox) {\n        mailbox_owner = userid;\n    }\n    else if (isidentifiermbox) {\n        mailbox_owner = identifier;\n    }\n\n    /* ensure the access rights if the folder owner is the current user or\n       the identifier */\n    ensure_owner_rights = isusermbox || isidentifiermbox;\n\n    /* 1. Start Transaction */\n    /* lookup the mailbox to make sure it exists and get its acl */\n    do {\n        r = mboxlist_mylookup(name, &mbentry, &tid, 1);\n    } while(r == IMAP_AGAIN);\n\n    /* Can't do this to an in-transit or reserved mailbox */\n    if (!r && mbentry->mbtype & (MBTYPE_MOVING | MBTYPE_RESERVE | MBTYPE_DELETED)) {\n        r = IMAP_MAILBOX_NOTSUPPORTED;\n    }\n\n    /* if it is not a remote mailbox, we need to unlock the mailbox list,\n     * lock the mailbox, and re-lock the mailboxes list */\n    /* we must do this to obey our locking rules */\n    if (!r && !(mbentry->mbtype & MBTYPE_REMOTE)) {\n        cyrusdb_abort(mbdb, tid);\n        tid = NULL;\n        mboxlist_entry_free(&mbentry);\n\n        /* open & lock mailbox header */\n        r = mailbox_open_iwl(name, &mailbox);\n\n        if (!r) {\n            do {\n                /* lookup the mailbox to make sure it exists and get its acl */\n                r = mboxlist_mylookup(name, &mbentry, &tid, 1);\n            } while (r == IMAP_AGAIN);\n        }\n\n        if(r) goto done;\n    }\n\n    /* 2. Check Rights */\n    if (!r && !isadmin) {\n        myrights = cyrus_acl_myrights(auth_state, mbentry->acl);\n        if (!(myrights & ACL_ADMIN)) {\n            r = (myrights & ACL_LOOKUP) ?\n                IMAP_PERMISSION_DENIED : IMAP_MAILBOX_NONEXISTENT;\n            goto done;\n        }\n    }\n\n    /* 2.1 Only admin user can set 'anyone' rights if config says so */\n    if (!r && !isadmin && !anyoneuseracl && !strncmp(identifier, \"anyone\", 6)) {\n      r = IMAP_PERMISSION_DENIED;\n      goto done;\n    }\n\n    /* 3. Set DB Entry */\n    if(!r) {\n        /* Make change to ACL */\n        newacl = xstrdup(mbentry->acl);\n        if (rights && *rights) {\n            /* rights are present and non-empty */\n            mode = ACL_MODE_SET;\n            if (*rights == '+') {\n                rights++;\n                mode = ACL_MODE_ADD;\n            }\n            else if (*rights == '-') {\n                rights++;\n                mode = ACL_MODE_REMOVE;\n            }\n            /* do not allow non-admin user to remove the admin rights from mailbox owner */\n            if (!isadmin && isidentifiermbox && mode != ACL_MODE_ADD) {\n                int has_admin_rights = mboxlist_have_admin_rights(rights);\n                if ((has_admin_rights && mode == ACL_MODE_REMOVE) ||\n                   (!has_admin_rights && mode != ACL_MODE_REMOVE)) {\n                    syslog(LOG_ERR, \"Denied removal of admin rights on \"\n                           \"folder \\\"%s\\\" (owner: %s) by user \\\"%s\\\"\", name,\n                           mailbox_owner, userid);\n                    r = IMAP_PERMISSION_DENIED;\n                    goto done;\n                }\n            }\n\n            r = cyrus_acl_strtomask(rights, &mask);\n\n            if (!r && cyrus_acl_set(&newacl, identifier, mode, mask,\n                                    ensure_owner_rights ? mboxlist_ensureOwnerRights : 0,\n                                    (void *)mailbox_owner)) {\n                r = IMAP_INVALID_IDENTIFIER;\n            }\n        } else {\n            /* do not allow to remove the admin rights from mailbox owner */\n            if (!isadmin && isidentifiermbox) {\n                syslog(LOG_ERR, \"Denied removal of admin rights on \"\n                       \"folder \\\"%s\\\" (owner: %s) by user \\\"%s\\\"\", name,\n                       mailbox_owner, userid);\n                r = IMAP_PERMISSION_DENIED;\n                goto done;\n            }\n\n            if (cyrus_acl_remove(&newacl, identifier,\n                                 ensure_owner_rights ? mboxlist_ensureOwnerRights : 0,\n                                 (void *)mailbox_owner)) {\n                r = IMAP_INVALID_IDENTIFIER;\n            }\n        }\n    }\n\n    if (!r) {\n        /* ok, change the database */\n        free(mbentry->acl);\n        mbentry->acl = xstrdupnull(newacl);\n\n        r = mboxlist_update_entry(name, mbentry, &tid);\n\n        if (r) {\n            syslog(LOG_ERR, \"DBERROR: error updating acl %s: %s\",\n                   name, cyrusdb_strerror(r));\n            r = IMAP_IOERROR;\n        }\n\n        /* send a AclChange event notification */\n        struct mboxevent *mboxevent = mboxevent_new(EVENT_ACL_CHANGE);\n        mboxevent_extract_mailbox(mboxevent, mailbox);\n        mboxevent_set_acl(mboxevent, identifier, rights);\n        mboxevent_set_access(mboxevent, NULL, NULL, userid, mailbox->name, 0);\n\n        mboxevent_notify(&mboxevent);\n        mboxevent_free(&mboxevent);\n\n    }\n\n    /* 4. Change backup copy (cyrus.header) */\n    /* we already have it locked from above */\n    if (!r && !(mbentry->mbtype & MBTYPE_REMOTE)) {\n        mailbox_set_acl(mailbox, newacl, 1);\n        /* want to commit immediately to ensure ordering */\n        r = mailbox_commit(mailbox);\n    }\n\n    /* 5. Commit transaction */\n    if (!r) {\n        if((r = cyrusdb_commit(mbdb, tid)) != 0) {\n            syslog(LOG_ERR, \"DBERROR: failed on commit: %s\",\n                   cyrusdb_strerror(r));\n            r = IMAP_IOERROR;\n        }\n        tid = NULL;\n    }\n\n    /* 6. Change mupdate entry  */\n    if (!r && config_mupdate_server) {\n        mupdate_handle *mupdate_h = NULL;\n        /* commit the update to MUPDATE */\n        char buf[MAX_PARTITION_LEN + HOSTNAME_SIZE + 2];\n\n        snprintf(buf, sizeof(buf), \"%s!%s\", config_servername, mbentry->partition);\n\n        r = mupdate_connect(config_mupdate_server, NULL, &mupdate_h, NULL);\n        if(r) {\n            syslog(LOG_ERR,\n                   \"cannot connect to mupdate server for setacl on '%s'\",\n                   name);\n        } else {\n            r = mupdate_activate(mupdate_h, name, buf, newacl);\n            if(r) {\n                syslog(LOG_ERR,\n                       \"MUPDATE: can't update mailbox entry for '%s'\",\n                       name);\n            }\n        }\n        mupdate_disconnect(&mupdate_h);\n    }\n\n  done:\n    if (r && tid) {\n        /* if we are mid-transaction, abort it! */\n        int r2 = cyrusdb_abort(mbdb, tid);\n        if (r2) {\n            syslog(LOG_ERR,\n                   \"DBERROR: error aborting txn in mboxlist_setacl: %s\",\n                   cyrusdb_strerror(r2));\n        }\n    }\n    mailbox_close(&mailbox);\n    free(newacl);\n    mboxlist_entry_free(&mbentry);\n    mbname_free(&mbname);\n\n    return r;\n}\n\n/*\n * Change the ACL for mailbox 'name'.  We already have it locked\n * and have written the backup copy to the header, so there's\n * nothing left but to write the mailboxes.db.\n *\n * 1. Start transaction\n * 2. Set db entry\n * 3. Commit transaction\n * 4. Change mupdate entry\n *\n */\nEXPORTED int\nmboxlist_sync_setacls(const char *name, const char *newacl)\n{\n    mbentry_t *mbentry = NULL;\n    int r;\n    struct txn *tid = NULL;\n\n    /* 1. Start Transaction */\n    /* lookup the mailbox to make sure it exists and get its acl */\n    do {\n        r = mboxlist_mylookup(name, &mbentry, &tid, 1);\n    } while(r == IMAP_AGAIN);\n\n    /* Can't do this to an in-transit or reserved mailbox */\n    if (!r && mbentry->mbtype & (MBTYPE_MOVING | MBTYPE_RESERVE | MBTYPE_DELETED)) {\n        r = IMAP_MAILBOX_NOTSUPPORTED;\n    }\n\n    /* 2. Set DB Entry */\n    if (!r) {\n        /* ok, change the database */\n        free(mbentry->acl);\n        mbentry->acl = xstrdupnull(newacl);\n\n        r = mboxlist_update_entry(name, mbentry, &tid);\n\n        if (r) {\n            syslog(LOG_ERR, \"DBERROR: error updating acl %s: %s\",\n                   name, cyrusdb_strerror(r));\n            r = IMAP_IOERROR;\n        }\n    }\n\n    /* 3. Commit transaction */\n    if (!r) {\n        r = cyrusdb_commit(mbdb, tid);\n        if (r) {\n            syslog(LOG_ERR, \"DBERROR: failed on commit %s: %s\",\n                   name, cyrusdb_strerror(r));\n            r = IMAP_IOERROR;\n        }\n        tid = NULL;\n    }\n\n    /* 4. Change mupdate entry  */\n    if (!r && config_mupdate_server) {\n        mupdate_handle *mupdate_h = NULL;\n        /* commit the update to MUPDATE */\n        char buf[MAX_PARTITION_LEN + HOSTNAME_SIZE + 2];\n        sprintf(buf, \"%s!%s\", config_servername, mbentry->partition);\n\n        r = mupdate_connect(config_mupdate_server, NULL, &mupdate_h, NULL);\n        if (r) {\n            syslog(LOG_ERR,\n                   \"cannot connect to mupdate server for syncacl on '%s'\",\n                   name);\n        } else {\n            r = mupdate_activate(mupdate_h, name, buf, newacl);\n            if(r) {\n                syslog(LOG_ERR,\n                       \"MUPDATE: can't update mailbox entry for '%s'\",\n                       name);\n            }\n        }\n        mupdate_disconnect(&mupdate_h);\n    }\n\n    if (r && tid) {\n        /* if we are mid-transaction, abort it! */\n        int r2 = cyrusdb_abort(mbdb, tid);\n        if (r2) {\n            syslog(LOG_ERR,\n                   \"DBERROR: error aborting txn in sync_setacls %s: %s\",\n                   name, cyrusdb_strerror(r2));\n        }\n    }\n\n    mboxlist_entry_free(&mbentry);\n\n    return r;\n}\n\nstruct find_rock {\n    ptrarray_t globs;\n    struct namespace *namespace;\n    const char *userid;\n    const char *domain;\n    int mb_category;\n    int checkmboxlist;\n    int issubs;\n    int singlepercent;\n    struct db *db;\n    int isadmin;\n    const struct auth_state *auth_state;\n    mbname_t *mbname;\n    mbentry_t *mbentry;\n    int matchlen;\n    findall_cb *proc;\n    void *procrock;\n};\n\n/* return non-zero if we like this one */\nstatic int find_p(void *rockp,\n                  const char *key, size_t keylen,\n                  const char *data, size_t datalen)\n{\n    struct find_rock *rock = (struct find_rock *) rockp;\n    char intname[MAX_MAILBOX_PATH+1];\n    int i;\n\n    /* skip any $RACL or future $ space keys */\n    if (key[0] == '$') return 0;\n\n    memcpy(intname, key, keylen);\n    intname[keylen] = 0;\n\n    assert(!rock->mbname);\n    rock->mbname = mbname_from_intname(intname);\n\n    if (!rock->isadmin && !config_getswitch(IMAPOPT_CROSSDOMAINS)) {\n        /* don't list mailboxes outside of the default domain */\n        if (strcmpsafe(rock->domain, mbname_domain(rock->mbname)))\n            goto nomatch;\n    }\n\n    if (rock->mb_category && mbname_category(rock->mbname, rock->namespace, rock->userid) != rock->mb_category)\n        goto nomatch;\n\n    /* NOTE: this will all be cleaned up to be much more efficient sooner or later, with\n     * a mbname_t being kept inside the mbentry, and the extname cached all the way to\n     * final use.  For now, we pay the cost of re-calculating for simplicity of the\n     * changes to mbname_t itself */\n    const char *extname = mbname_extname(rock->mbname, rock->namespace, rock->userid);\n    if (!extname) goto nomatch;\n\n    int matchlen = 0;\n    for (i = 0; i < rock->globs.count; i++) {\n        glob *g = ptrarray_nth(&rock->globs, i);\n        int thismatch = glob_test(g, extname);\n        if (thismatch > matchlen) matchlen = thismatch;\n    }\n\n    /* If its not a match, skip it -- partial matches are ok. */\n    if (!matchlen) goto nomatch;\n\n    rock->matchlen = matchlen;\n\n    /* subs DB has empty keys */\n    if (rock->issubs)\n        goto good;\n\n    /* ignore entirely deleted records */\n    if (mboxlist_parse_entry(&rock->mbentry, key, keylen, data, datalen))\n        goto nomatch;\n\n    /* nobody sees tombstones */\n    if (rock->mbentry->mbtype & MBTYPE_DELETED)\n        goto nomatch;\n\n    /* check acl */\n    if (!rock->isadmin) {\n        /* always suppress deleted for non-admin */\n        if (mbname_isdeleted(rock->mbname)) goto nomatch;\n\n        /* check the acls */\n        if (!(cyrus_acl_myrights(rock->auth_state, rock->mbentry->acl) & ACL_LOOKUP)) goto nomatch;\n    }\n\ngood:\n    return 1;\n\nnomatch:\n    mboxlist_entry_free(&rock->mbentry);\n    mbname_free(&rock->mbname);\n    return 0;\n}\n\nstatic int find_cb(void *rockp,\n                   /* XXX - confirm these are the same?  - nah */\n                   const char *key __attribute__((unused)),\n                   size_t keylen __attribute__((unused)),\n                   const char *data __attribute__((unused)),\n                   size_t datalen __attribute__((unused)))\n{\n    struct find_rock *rock = (struct find_rock *) rockp;\n    char *testname = NULL;\n    int r = 0;\n    int i;\n\n    if (rock->checkmboxlist && !rock->mbentry) {\n        r = mboxlist_lookup(mbname_intname(rock->mbname), &rock->mbentry, NULL);\n        if (r) {\n            if (r == IMAP_MAILBOX_NONEXISTENT) r = 0;\n            goto done;\n        }\n    }\n\n    const char *extname = mbname_extname(rock->mbname, rock->namespace, rock->userid);\n    testname = xstrndup(extname, rock->matchlen);\n\n    struct findall_data fdata = { testname, rock->mb_category, rock->mbentry, NULL };\n\n    if (rock->singlepercent) {\n        char sep = rock->namespace->hier_sep;\n        char *p = testname;\n        /* we need to try all the previous names in order */\n        while ((p = strchr(p, sep)) != NULL) {\n            *p = '\\0';\n\n            /* only if this expression could fully match */\n            int matchlen = 0;\n            for (i = 0; i < rock->globs.count; i++) {\n                glob *g = ptrarray_nth(&rock->globs, i);\n                int thismatch = glob_test(g, testname);\n                if (thismatch > matchlen) matchlen = thismatch;\n            }\n\n            if (matchlen == (int)strlen(testname)) {\n                r = (*rock->proc)(&fdata, rock->procrock);\n                if (r) goto done;\n            }\n\n            /* replace the separator for the next longest name */\n            *p++ = sep;\n        }\n    }\n\n    /* mbname confirms that it's an exact match */\n    if (rock->matchlen == (int)strlen(extname))\n        fdata.mbname = rock->mbname;\n\n    r = (*rock->proc)(&fdata, rock->procrock);\n\n done:\n    free(testname);\n    mboxlist_entry_free(&rock->mbentry);\n    mbname_free(&rock->mbname);\n    return r;\n}\n\nstruct allmb_rock {\n    struct mboxlist_entry *mbentry;\n    int flags;\n    mboxlist_cb *proc;\n    void *rock;\n};\n\nstatic int allmbox_cb(void *rock,\n                      const char *key,\n                      size_t keylen,\n                      const char *data,\n                      size_t datalen)\n{\n    struct allmb_rock *mbrock = (struct allmb_rock *)rock;\n\n    if (!mbrock->mbentry) {\n        int r = mboxlist_parse_entry(&mbrock->mbentry, key, keylen, data, datalen);\n        if (r) return r;\n    }\n\n    return mbrock->proc(mbrock->mbentry, mbrock->rock);\n}\n\nstatic int allmbox_p(void *rock,\n                     const char *key,\n                     size_t keylen,\n                     const char *data,\n                     size_t datalen)\n{\n    struct allmb_rock *mbrock = (struct allmb_rock *)rock;\n    int r;\n\n    /* skip any dollar keys */\n    if (keylen && key[0] == '$') return 0;\n\n    /* free previous record */\n    mboxlist_entry_free(&mbrock->mbentry);\n\n    r = mboxlist_parse_entry(&mbrock->mbentry, key, keylen, data, datalen);\n    if (r) return 0;\n\n    if (!(mbrock->flags & MBOXTREE_TOMBSTONES) && (mbrock->mbentry->mbtype & MBTYPE_DELETED))\n        return 0;\n\n    return 1; /* process this record */\n}\n\nEXPORTED int mboxlist_allmbox(const char *prefix, mboxlist_cb *proc, void *rock, int incdel)\n{\n    struct allmb_rock mbrock = { NULL, 0, proc, rock };\n    int r = 0;\n\n    if (incdel) mbrock.flags |= MBOXTREE_TOMBSTONES;\n    if (!prefix) prefix = \"\";\n\n    r = cyrusdb_foreach(mbdb, prefix, strlen(prefix),\n                        allmbox_p, allmbox_cb, &mbrock, 0);\n\n    mboxlist_entry_free(&mbrock.mbentry);\n\n    return r;\n}\n\nEXPORTED int mboxlist_mboxtree(const char *mboxname, mboxlist_cb *proc, void *rock, int flags)\n{\n    struct allmb_rock mbrock = { NULL, flags, proc, rock };\n    int r = 0;\n\n    if (!(flags & MBOXTREE_SKIP_ROOT)) {\n        r = cyrusdb_forone(mbdb, mboxname, strlen(mboxname), allmbox_p, allmbox_cb, &mbrock, 0);\n        if (r) goto done;\n    }\n\n    if (!(flags & MBOXTREE_SKIP_CHILDREN)) {\n        char *prefix = strconcat(mboxname, \".\", (char *)NULL);\n        r = cyrusdb_foreach(mbdb, prefix, strlen(prefix), allmbox_p, allmbox_cb, &mbrock, 0);\n        free(prefix);\n        if (r) goto done;\n    }\n\n    if ((flags & MBOXTREE_DELETED)) {\n        struct buf buf = BUF_INITIALIZER;\n        const char *p = strchr(mboxname, '!');\n        const char *dp = config_getstring(IMAPOPT_DELETEDPREFIX);\n        if (p) {\n            buf_printf(&buf, \"%.*s!%s.%s\", (int)(p-mboxname), mboxname, dp, p+1);\n        }\n        else {\n            buf_printf(&buf, \"%s.%s\", dp, mboxname);\n        }\n        const char *prefix = buf_cstring(&buf);\n        r = cyrusdb_foreach(mbdb, prefix, strlen(prefix), allmbox_p, allmbox_cb, &mbrock, 0);\n        buf_free(&buf);\n        if (r) goto done;\n    }\n\n done:\n    mboxlist_entry_free(&mbrock.mbentry);\n    return r;\n}\n\nstatic int racls_del_cb(void *rock,\n                  const char *key, size_t keylen,\n                  const char *data __attribute__((unused)),\n                  size_t datalen __attribute__((unused)))\n{\n    struct txn **txn = (struct txn **)rock;\n    return cyrusdb_delete(mbdb, key, keylen, txn, /*force*/0);\n}\n\nstatic int racls_add_cb(const mbentry_t *mbentry, void *rock)\n{\n    struct txn **txn = (struct txn **)rock;\n    return mboxlist_update_racl(mbentry->name, NULL, mbentry, txn);\n}\n\nEXPORTED int mboxlist_set_racls(int enabled)\n{\n    struct txn *tid = NULL;\n    int r = 0;\n    int now = !cyrusdb_fetch(mbdb, \"$RACL\", 5, NULL, NULL, &tid);\n\n    if (now && !enabled) {\n        syslog(LOG_NOTICE, \"removing reverse acl support\");\n        /* remove */\n        r = cyrusdb_foreach(mbdb, \"$RACL\", 5, NULL, racls_del_cb, &tid, &tid);\n    }\n    else if (enabled && !now) {\n        /* add */\n        struct allmb_rock mbrock = { NULL, 0, racls_add_cb, &tid };\n        /* we can't use mboxlist_allmbox because it doesn't do transactions */\n        syslog(LOG_NOTICE, \"adding reverse acl support\");\n        r = cyrusdb_foreach(mbdb, \"\", 0, allmbox_p, allmbox_cb, &mbrock, &tid);\n        if (r) {\n            syslog(LOG_ERR, \"ERROR: failed to add reverse acl support %s\", error_message(r));\n        }\n        mboxlist_entry_free(&mbrock.mbentry);\n        if (!r) r = cyrusdb_store(mbdb, \"$RACL\", 5, \"\", 0, &tid);\n    }\n\n    if (r)\n        cyrusdb_abort(mbdb, tid);\n    else\n        cyrusdb_commit(mbdb, tid);\n\n    return r;\n}\n\n\nstruct alluser_rock {\n    char *prev;\n    user_cb *proc;\n    void *rock;\n};\n\nstatic int alluser_cb(const mbentry_t *mbentry, void *rock)\n{\n    struct alluser_rock *urock = (struct alluser_rock *)rock;\n    char *userid = mboxname_to_userid(mbentry->name);\n    int r = 0;\n\n    if (userid) {\n        if (strcmpsafe(urock->prev, userid)) {\n            r = urock->proc(userid, urock->rock);\n            free(urock->prev);\n            urock->prev = xstrdup(userid);\n        }\n        free(userid);\n    }\n\n    return r;\n}\n\nEXPORTED int mboxlist_alluser(user_cb *proc, void *rock)\n{\n    struct alluser_rock urock;\n    int r = 0;\n    urock.prev = NULL;\n    urock.proc = proc;\n    urock.rock = rock;\n    r = mboxlist_allmbox(NULL, alluser_cb, &urock, /*flags*/0);\n    free(urock.prev);\n    return r;\n}\n\nstruct raclrock {\n    int prefixlen;\n    strarray_t *list;\n};\n\nstatic int racl_cb(void *rock,\n                   const char *key, size_t keylen,\n                   const char *data __attribute__((unused)),\n                   size_t datalen __attribute__((unused)))\n{\n    struct raclrock *raclrock = (struct raclrock *)rock;\n    strarray_appendm(raclrock->list, xstrndup(key + raclrock->prefixlen, keylen - raclrock->prefixlen));\n    return 0;\n}\n\nEXPORTED int mboxlist_usermboxtree(const char *userid, mboxlist_cb *proc,\n                                   void *rock, int flags)\n{\n    char *inbox = mboxname_user_mbox(userid, 0);\n    int r = mboxlist_mboxtree(inbox, proc, rock, flags);\n\n    if (flags & MBOXTREE_PLUS_RACL) {\n        struct allmb_rock mbrock = { NULL, flags, proc, rock };\n        /* we're using reverse ACLs */\n        struct buf buf = BUF_INITIALIZER;\n        strarray_t matches = STRARRAY_INITIALIZER;\n\n        /* user items */\n        mboxlist_racl_key(1, userid, NULL, &buf);\n        /* this is the prefix */\n        struct raclrock raclrock = { buf.len, &matches };\n        /* we only need to look inside the prefix still, but we keep the length\n         * in raclrock pointing to the start of the mboxname part of the key so\n         * we get correct names in matches */\n        r = cyrusdb_foreach(mbdb, buf.s, buf.len, NULL, racl_cb, &raclrock, NULL);\n        buf_reset(&buf);\n\n        /* shared items */\n        mboxlist_racl_key(0, userid, NULL, &buf);\n        raclrock.prefixlen = buf.len;\n        if (!r) r = cyrusdb_foreach(mbdb, buf.s, buf.len, NULL, racl_cb, &raclrock, NULL);\n\n        /* XXX - later we need to sort the array when we've added groups */\n        int i;\n        for (i = 0; !r && i < strarray_size(&matches); i++) {\n            const char *mboxname = strarray_nth(&matches, i);\n            r = cyrusdb_forone(mbdb, mboxname, strlen(mboxname), allmbox_p, allmbox_cb, &mbrock, 0);\n        }\n        buf_free(&buf);\n        strarray_fini(&matches);\n        mboxlist_entry_free(&mbrock.mbentry);\n    }\n\n    free(inbox);\n    return r;\n}\n\nstatic int mboxlist_find_category(struct find_rock *rock, const char *prefix, size_t len)\n{\n    int r = 0;\n    if (!rock->issubs && !rock->isadmin && !cyrusdb_fetch(rock->db, \"$RACL\", 5, NULL, NULL, NULL)) {\n        /* we're using reverse ACLs */\n        struct buf buf = BUF_INITIALIZER;\n        strarray_t matches = STRARRAY_INITIALIZER;\n        mboxlist_racl_key(rock->mb_category == MBNAME_OTHERUSER, rock->userid, NULL, &buf);\n        /* this is the prefix */\n        struct raclrock raclrock = { buf.len, &matches };\n        /* we only need to look inside the prefix still, but we keep the length\n         * in raclrock pointing to the start of the mboxname part of the key so\n         * we get correct names in matches */\n        if (len) buf_appendmap(&buf, prefix, len);\n        r = cyrusdb_foreach(rock->db, buf.s, buf.len, NULL, racl_cb, &raclrock, NULL);\n        /* XXX - later we need to sort the array when we've added groups */\n        int i;\n        for (i = 0; !r && i < strarray_size(&matches); i++) {\n            const char *key = strarray_nth(&matches, i);\n            r = cyrusdb_forone(rock->db, key, strlen(key), &find_p, &find_cb, rock, NULL);\n        }\n        strarray_fini(&matches);\n    }\n    else {\n        r = cyrusdb_foreach(rock->db, prefix, len, &find_p, &find_cb, rock, NULL);\n    }\n\n    if (r == CYRUSDB_DONE) r = 0;\n    return r;\n}\n\n/*\n * Find all mailboxes that match 'pattern'.\n * 'isadmin' is nonzero if user is a mailbox admin.  'userid'\n * is the user's login id.  For each matching mailbox, calls\n * 'proc' with the name of the mailbox.  If 'proc' ever returns\n * a nonzero value, mboxlist_findall immediately stops searching\n * and returns that value.  'rock' is passed along as an argument to proc in\n * case it wants some persistant storage or extra data.\n */\n/* Find all mailboxes that match 'pattern'. */\n\nstatic int mboxlist_do_find(struct find_rock *rock, const strarray_t *patterns)\n{\n    const char *userid = rock->userid;\n    int isadmin = rock->isadmin;\n\n    int crossdomains = config_getswitch(IMAPOPT_CROSSDOMAINS);\n    char inbox[MAX_MAILBOX_BUFFER];\n    size_t inboxlen = 0;\n    size_t prefixlen, len;\n    size_t domainlen = 0;\n    size_t userlen = userid ? strlen(userid) : 0;\n    char domainpat[MAX_MAILBOX_BUFFER]; /* do intra-domain fetches only */\n    char commonpat[MAX_MAILBOX_BUFFER];\n    int r = 0;\n    int i;\n    const char *p;\n\n    if (patterns->count < 1) return 0; /* nothing to do */\n\n    for (i = 0; i < patterns->count; i++) {\n        glob *g = glob_init(strarray_nth(patterns, i), rock->namespace->hier_sep);\n        ptrarray_append(&rock->globs, g);\n    }\n\n    if (config_virtdomains && userid && (p = strchr(userid, '@'))) {\n        userlen = p - userid;\n        domainlen = strlen(p); /* includes separator */\n        snprintf(domainpat, sizeof(domainpat), \"%s!\", p+1);\n    }\n    else\n        domainpat[0] = '\\0';\n\n    /* calculate the inbox (with trailing .INBOX. for later use) */\n    if (userid && (!(p = strchr(userid, rock->namespace->hier_sep)) ||\n        ((p - userid) > (int)userlen)) &&\n        strlen(userid)+7 < MAX_MAILBOX_BUFFER) {\n        char *t, *tmpuser = NULL;\n        const char *inboxuser;\n\n        if (domainlen)\n            snprintf(inbox, sizeof(inbox), \"%s!\", userid+userlen+1);\n        if (rock->namespace->hier_sep == '/' && (p = strchr(userid, '.'))) {\n            tmpuser = xmalloc(userlen);\n            memcpy(tmpuser, userid, userlen);\n            t = tmpuser + (p - userid);\n            while(t < (tmpuser + userlen)) {\n                if (*t == '.')\n                    *t = '^';\n                t++;\n            }\n            inboxuser = tmpuser;\n        } else\n            inboxuser = userid;\n        snprintf(inbox+domainlen, sizeof(inbox)-domainlen,\n                 \"user.%.*s.INBOX.\", (int)userlen, inboxuser);\n        free(tmpuser);\n        inboxlen = strlen(inbox) - 7;\n    }\n    else {\n        userid = 0;\n    }\n\n    /* Find the common search prefix of all patterns */\n    const char *firstpat = strarray_nth(patterns, 0);\n    for (prefixlen = 0; firstpat[prefixlen]; prefixlen++) {\n        if (prefixlen >= MAX_MAILBOX_NAME) {\n            r = IMAP_MAILBOX_BADNAME;\n            goto done;\n        }\n        char c = firstpat[prefixlen];\n        for (i = 1; i < patterns->count; i++) {\n            const char *pat = strarray_nth(patterns, i);\n            if (pat[prefixlen] != c) break;\n        }\n        if (i < patterns->count) break;\n        if (c == '*' || c == '%' || c == '?') break;\n        commonpat[prefixlen] = c;\n    }\n    commonpat[prefixlen] = '\\0';\n\n    if (patterns->count == 1) {\n        /* Skip pattern which matches shared namespace prefix */\n        if (!strcmp(firstpat+prefixlen, \"%\"))\n            rock->singlepercent = 2;\n        /* output prefix regardless */\n        if (!strcmp(firstpat+prefixlen, \"*%\"))\n            rock->singlepercent = 1;\n    }\n\n    /*\n     * Personal (INBOX) namespace (only if not admin)\n     */\n    if (userid && !isadmin) {\n        /* first the INBOX */\n        rock->mb_category = MBNAME_INBOX;\n        r = cyrusdb_forone(rock->db, inbox, inboxlen, &find_p, &find_cb, rock, NULL);\n        if (r == CYRUSDB_DONE) r = 0;\n        if (r) goto done;\n\n        if (rock->namespace->isalt) {\n            /* do exact INBOX subs before resetting the namebuffer */\n            rock->mb_category = MBNAME_INBOXSUB;\n            r = cyrusdb_foreach(rock->db, inbox, inboxlen+7, &find_p, &find_cb, rock, NULL);\n            if (r == CYRUSDB_DONE) r = 0;\n            if (r) goto done;\n\n            /* reset the the namebuffer */\n            r = (*rock->proc)(NULL, rock->procrock);\n            if (r) goto done;\n        }\n\n        /* iterate through all the mailboxes under the user's inbox */\n        rock->mb_category = MBNAME_OWNER;\n        r = cyrusdb_foreach(rock->db, inbox, inboxlen+1, &find_p, &find_cb, rock, NULL);\n        if (r == CYRUSDB_DONE) r = 0;\n        if (r) goto done;\n\n        /* \"Alt Prefix\" folders */\n        if (rock->namespace->isalt) {\n            /* reset the the namebuffer */\n            r = (*rock->proc)(NULL, rock->procrock);\n            if (r) goto done;\n\n            rock->mb_category = MBNAME_ALTINBOX;\n\n            /* special case user.foo.INBOX.  If we're singlepercent == 2, this could\n             return DONE, in which case we don't need to foreach the rest of the\n             altprefix space */\n            r = cyrusdb_forone(rock->db, inbox, inboxlen+6, &find_p, &find_cb, rock, NULL);\n            if (r == CYRUSDB_DONE) goto skipalt;\n            if (r) goto done;\n\n            /* special case any other altprefix stuff */\n            rock->mb_category = MBNAME_ALTPREFIX;\n            r = cyrusdb_foreach(rock->db, inbox, inboxlen+1, &find_p, &find_cb, rock, NULL);\n        skipalt: /* we got a done, so skip out of the foreach early */\n            if (r == CYRUSDB_DONE) r = 0;\n            if (r) goto done;\n        }\n    }\n\n    /*\n     * Other Users namespace\n     *\n     * If \"Other Users*\" can match pattern, search for those mailboxes next\n     */\n    if (isadmin || rock->namespace->accessible[NAMESPACE_USER]) {\n        len = strlen(rock->namespace->prefix[NAMESPACE_USER]);\n        if (len) len--; // trailing separator\n\n        if (!strncmp(rock->namespace->prefix[NAMESPACE_USER], commonpat, MIN(len, prefixlen))) {\n            if (prefixlen < len) {\n                /* we match all users */\n                strlcpy(domainpat+domainlen, \"user.\", sizeof(domainpat)-domainlen);\n            }\n            else {\n                /* just those in this prefix */\n                strlcpy(domainpat+domainlen, \"user.\", sizeof(domainpat)-domainlen);\n                strlcpy(domainpat+domainlen+5, commonpat+len+1, sizeof(domainpat)-domainlen-5);\n            }\n\n            rock->mb_category = MBNAME_OTHERUSER;\n\n            /* because of how domains work, with crossdomains or admin you can't prefix at all :( */\n            size_t thislen = (isadmin || crossdomains) ? 0 : strlen(domainpat);\n\n            /* reset the the namebuffer */\n            r = (*rock->proc)(NULL, rock->procrock);\n            if (r) goto done;\n\n            r = mboxlist_find_category(rock, domainpat, thislen);\n            if (r) goto done;\n        }\n    }\n\n    /*\n     * Shared namespace\n     *\n     * search for all remaining mailboxes.\n     * just bother looking at the ones that have the same pattern prefix.\n     */\n    if (isadmin || rock->namespace->accessible[NAMESPACE_SHARED]) {\n        len = strlen(rock->namespace->prefix[NAMESPACE_SHARED]);\n        if (len) len--; // trailing separator\n\n        if (!strncmp(rock->namespace->prefix[NAMESPACE_SHARED], commonpat, MIN(len, prefixlen))) {\n            rock->mb_category = MBNAME_SHARED;\n\n            /* reset the the namebuffer */\n            r = (*rock->proc)(NULL, rock->procrock);\n            if (r) goto done;\n\n            /* iterate through all the non-user folders on the server */\n            r = mboxlist_find_category(rock, domainpat, domainlen);\n            if (r) goto done;\n        }\n    }\n\n    /* finish with a reset call always */\n    r = (*rock->proc)(NULL, rock->procrock);\n\n done:\n    for (i = 0; i < rock->globs.count; i++) {\n        glob *g = ptrarray_nth(&rock->globs, i);\n        glob_free(&g);\n    }\n    ptrarray_fini(&rock->globs);\n\n    return r;\n}\n\nEXPORTED int mboxlist_findallmulti(struct namespace *namespace,\n                                   const strarray_t *patterns, int isadmin,\n                                   const char *userid, const struct auth_state *auth_state,\n                                   findall_cb *proc, void *rock)\n{\n    int r = 0;\n\n    if (!namespace) namespace = mboxname_get_adminnamespace();\n\n    struct find_rock cbrock;\n    memset(&cbrock, 0, sizeof(struct find_rock));\n\n    cbrock.auth_state = auth_state;\n    cbrock.db = mbdb;\n    cbrock.isadmin = isadmin;\n    cbrock.namespace = namespace;\n    cbrock.proc = proc;\n    cbrock.procrock = rock;\n    cbrock.userid = userid;\n    if (userid) {\n        const char *domp = strchr(userid, '@');\n        if (domp) cbrock.domain = domp + 1;\n    }\n\n    r = mboxlist_do_find(&cbrock, patterns);\n\n    return r;\n}\n\nEXPORTED int mboxlist_findall(struct namespace *namespace,\n                              const char *pattern, int isadmin,\n                              const char *userid, const struct auth_state *auth_state,\n                              findall_cb *proc, void *rock)\n{\n    strarray_t patterns = STRARRAY_INITIALIZER;\n    strarray_append(&patterns, pattern);\n\n    int r = mboxlist_findallmulti(namespace, &patterns, isadmin, userid, auth_state, proc, rock);\n\n    strarray_fini(&patterns);\n\n    return r;\n}\n\nEXPORTED int mboxlist_findone(struct namespace *namespace,\n                              const char *intname, int isadmin,\n                              const char *userid, const struct auth_state *auth_state,\n                              findall_cb *proc, void *rock)\n{\n    int r = 0;\n\n    if (!namespace) namespace = mboxname_get_adminnamespace();\n\n    struct find_rock cbrock;\n    memset(&cbrock, 0, sizeof(struct find_rock));\n\n    cbrock.auth_state = auth_state;\n    cbrock.db = mbdb;\n    cbrock.isadmin = isadmin;\n    cbrock.namespace = namespace;\n    cbrock.proc = proc;\n    cbrock.procrock = rock;\n    cbrock.userid = userid;\n    if (userid) {\n        const char *domp = strchr(userid, '@');\n        if (domp) cbrock.domain = domp + 1;\n    }\n\n    mbname_t *mbname = mbname_from_intname(intname);\n    glob *g = glob_init(mbname_extname(mbname, namespace, userid),\n                        namespace->hier_sep);\n    ptrarray_append(&cbrock.globs, g);\n    mbname_free(&mbname);\n\n    r = cyrusdb_forone(cbrock.db, intname, strlen(intname), &find_p, &find_cb, &cbrock, NULL);\n\n    glob_free(&g);\n    ptrarray_fini(&cbrock.globs);\n\n    return r;\n}\n\nstatic int exists_cb(const mbentry_t *mbentry __attribute__((unused)), void *rock)\n{\n    int *exists = (int *)rock;\n    *exists = 1;\n    return CYRUSDB_DONE; /* one is enough */\n}\n\n/*\n * Set all the resource quotas on, or create a quota root.\n */\nEXPORTED int mboxlist_setquotas(const char *root,\n                       quota_t newquotas[QUOTA_NUMRESOURCES], int force)\n{\n    struct quota q;\n    int r;\n    int res;\n    struct txn *tid = NULL;\n    struct mboxevent *mboxevents = NULL;\n    struct mboxevent *quotachange_event = NULL;\n    struct mboxevent *quotawithin_event = NULL;\n\n    if (!root[0] || root[0] == '.' || strchr(root, '/')\n        || strchr(root, '*') || strchr(root, '%') || strchr(root, '?')) {\n        return IMAP_MAILBOX_BADNAME;\n    }\n\n    quota_init(&q, root);\n    r = quota_read(&q, &tid, 1);\n\n    if (!r) {\n        int changed = 0;\n        int underquota;\n\n        /* has it changed? */\n        for (res = 0 ; res < QUOTA_NUMRESOURCES ; res++) {\n            if (q.limits[res] != newquotas[res]) {\n                underquota = 0;\n\n                /* Prepare a QuotaChange event notification *now*.\n                 *\n                 * This is to ensure the QuotaChange is emitted before the\n                 * subsequent QuotaWithin (if the latter becomes applicable).\n                 */\n                if (quotachange_event == NULL) {\n                    quotachange_event = mboxevent_enqueue(EVENT_QUOTA_CHANGE,\n                                                          &mboxevents);\n                }\n\n                /* prepare a QuotaWithin event notification if now under quota */\n                if (quota_is_overquota(&q, res, NULL) &&\n                    (!quota_is_overquota(&q, res, newquotas) || newquotas[res] == -1)) {\n                    if (quotawithin_event == NULL)\n                        quotawithin_event = mboxevent_enqueue(EVENT_QUOTA_WITHIN,\n                                                              &mboxevents);\n                    underquota++;\n                }\n\n                q.limits[res] = newquotas[res];\n                changed++;\n\n                mboxevent_extract_quota(quotachange_event, &q, res);\n                if (underquota)\n                    mboxevent_extract_quota(quotawithin_event, &q, res);\n            }\n        }\n        if (changed) {\n            r = quota_write(&q, &tid);\n\n            if (quotachange_event == NULL) {\n                quotachange_event = mboxevent_enqueue(EVENT_QUOTA_CHANGE, &mboxevents);\n            }\n\n            for (res = 0; res < QUOTA_NUMRESOURCES; res++) {\n                mboxevent_extract_quota(quotachange_event, &q, res);\n            }\n        }\n\n        if (!r)\n            quota_commit(&tid);\n\n        goto done;\n    }\n\n    if (r != IMAP_QUOTAROOT_NONEXISTENT)\n        goto done;\n\n    if (config_virtdomains && root[strlen(root)-1] == '!') {\n        /* domain quota */\n    }\n    else {\n        mbentry_t *mbentry = NULL;\n\n        /* look for a top-level mailbox in the proposed quotaroot */\n        r = mboxlist_lookup(root, &mbentry, NULL);\n        if (r) {\n            if (!force && r == IMAP_MAILBOX_NONEXISTENT) {\n                mboxlist_mboxtree(root, exists_cb, &force, MBOXTREE_SKIP_ROOT);\n            }\n            /* are we going to force the create anyway? */\n            if (force) {\n                r = 0;\n            }\n        }\n        else if (mbentry->mbtype & (MBTYPE_REMOTE | MBTYPE_MOVING)) {\n            /* Can't set quota on a remote mailbox */\n            r = IMAP_MAILBOX_NOTSUPPORTED;\n        }\n        mboxlist_entry_free(&mbentry);\n        if (r) goto done;\n    }\n\n    /* safe against quota -f and other root change races */\n    r = quota_changelock();\n    if (r) goto done;\n\n    /* initialise the quota */\n    memcpy(q.limits, newquotas, sizeof(q.limits));\n    r = quota_write(&q, &tid);\n    if (r) goto done;\n\n    /* prepare a QuotaChange event notification */\n    if (quotachange_event == NULL)\n        quotachange_event = mboxevent_enqueue(EVENT_QUOTA_CHANGE, &mboxevents);\n\n    for (res = 0; res < QUOTA_NUMRESOURCES; res++) {\n        mboxevent_extract_quota(quotachange_event, &q, res);\n    }\n\n    quota_commit(&tid);\n\n    /* recurse through mailboxes, setting the quota and finding\n     * out the usage */\n    mboxlist_mboxtree(root, mboxlist_changequota, (void *)root, 0);\n\n    quota_changelockrelease();\n\ndone:\n    quota_free(&q);\n    if (r && tid) quota_abort(&tid);\n    if (!r) {\n        sync_log_quota(root);\n\n        /* send QuotaChange and QuotaWithin event notifications */\n        mboxevent_notify(&mboxevents);\n    }\n    mboxevent_freequeue(&mboxevents);\n\n    return r;\n}\n\n/*\n *  Remove a quota root\n */\nEXPORTED int mboxlist_unsetquota(const char *root)\n{\n    struct quota q;\n    int r=0;\n\n    if (!root[0] || root[0] == '.' || strchr(root, '/')\n        || strchr(root, '*') || strchr(root, '%') || strchr(root, '?')) {\n        return IMAP_MAILBOX_BADNAME;\n    }\n\n    quota_init(&q, root);\n    r = quota_read(&q, NULL, 0);\n    /* already unset */\n    if (r == IMAP_QUOTAROOT_NONEXISTENT) {\n        r = 0;\n        goto done;\n    }\n    if (r) goto done;\n\n    r = quota_changelock();\n\n    /*\n     * Have to remove it from all affected mailboxes\n     */\n    mboxlist_mboxtree(root, mboxlist_rmquota, (void *)root, /*flags*/0);\n\n    r = quota_deleteroot(root);\n    quota_changelockrelease();\n\n    if (!r) sync_log_quota(root);\n\n done:\n    quota_free(&q);\n    return r;\n}\n\nEXPORTED modseq_t mboxlist_foldermodseq_dirty(struct mailbox *mailbox)\n{\n    mbentry_t *mbentry = NULL;\n    modseq_t ret = 0;\n\n    if (mboxlist_mylookup(mailbox->name, &mbentry, NULL, 0))\n        return 0;\n\n    ret = mbentry->foldermodseq = mailbox_modseq_dirty(mailbox);\n\n    mboxlist_update(mbentry, 0);\n\n    mboxlist_entry_free(&mbentry);\n\n    return ret;\n}\n\n/*\n * ACL access canonicalization routine which ensures that 'owner'\n * retains lookup, administer, and create rights over a mailbox.\n */\nEXPORTED int mboxlist_ensureOwnerRights(void *rock, const char *identifier,\n                               int myrights)\n{\n    char *owner = (char *)rock;\n    if (strcmp(identifier, owner) != 0) return myrights;\n    return myrights|config_implicitrights;\n}\n\n/*\n * Helper function to remove the quota root for 'name'\n */\nstatic int mboxlist_rmquota(const mbentry_t *mbentry, void *rock)\n{\n    int r = 0;\n    struct mailbox *mailbox = NULL;\n    const char *oldroot = (const char *) rock;\n\n    assert(oldroot != NULL);\n\n    r = mailbox_open_iwl(mbentry->name, &mailbox);\n    if (r) goto done;\n\n    if (mailbox->quotaroot) {\n        if (strcmp(mailbox->quotaroot, oldroot)) {\n            /* Part of a different quota root */\n            goto done;\n        }\n\n        r = mailbox_set_quotaroot(mailbox, NULL);\n    }\n\n done:\n    mailbox_close(&mailbox);\n\n    if (r) {\n        syslog(LOG_ERR, \"LOSTQUOTA: unable to remove quota root %s for %s: %s\",\n               oldroot, mbentry->name, error_message(r));\n    }\n\n    /* not a huge tragedy if we failed, so always return success */\n    return 0;\n}\n\n/*\n * Helper function to change the quota root for 'name' to that pointed\n * to by the static global struct pointer 'mboxlist_newquota'.\n */\nstatic int mboxlist_changequota(const mbentry_t *mbentry, void *rock)\n{\n    int r = 0;\n    struct mailbox *mailbox = NULL;\n    const char *root = (const char *) rock;\n    int res;\n    quota_t quota_usage[QUOTA_NUMRESOURCES];\n\n    assert(root);\n\n    r = mailbox_open_iwl(mbentry->name, &mailbox);\n    if (r) goto done;\n\n    mailbox_get_usage(mailbox, quota_usage);\n\n    if (mailbox->quotaroot) {\n        quota_t quota_diff[QUOTA_NUMRESOURCES];\n\n        if (strlen(mailbox->quotaroot) >= strlen(root)) {\n            /* Part of a child quota root - skip */\n            goto done;\n        }\n\n        /* remove usage from the old quotaroot */\n        for (res = 0; res < QUOTA_NUMRESOURCES ; res++) {\n            quota_diff[res] = -quota_usage[res];\n        }\n        r = quota_update_useds(mailbox->quotaroot, quota_diff,\n                               mailbox->name);\n    }\n\n    /* update (or set) the quotaroot */\n    r = mailbox_set_quotaroot(mailbox, root);\n    if (r) goto done;\n\n    /* update the new quota root */\n    r = quota_update_useds(root, quota_usage, mailbox->name);\n\n done:\n    mailbox_close(&mailbox);\n\n    if (r) {\n        syslog(LOG_ERR, \"LOSTQUOTA: unable to change quota root for %s to %s: %s\",\n               mbentry->name, root, error_message(r));\n    }\n\n    /* Note, we're a callback, and it's not a huge tragedy if we\n     * fail, so we don't ever return a failure */\n    return 0;\n}\n\n/* must be called after cyrus_init */\nEXPORTED void mboxlist_init(int myflags)\n{\n    if (myflags & MBOXLIST_SYNC) {\n        cyrusdb_sync(DB);\n    }\n}\n\nEXPORTED void mboxlist_open(const char *fname)\n{\n    int ret, flags;\n    char *tofree = NULL;\n\n    if (!fname)\n        fname = config_getstring(IMAPOPT_MBOXLIST_DB_PATH);\n\n    /* create db file name */\n    if (!fname) {\n        tofree = strconcat(config_dir, FNAME_MBOXLIST, (char *)NULL);\n        fname = tofree;\n    }\n\n    flags = CYRUSDB_CREATE;\n    if (config_getswitch(IMAPOPT_IMPROVED_MBOXLIST_SORT)) {\n        flags |= CYRUSDB_MBOXSORT;\n    }\n\n    ret = cyrusdb_open(DB, fname, flags, &mbdb);\n    if (ret != 0) {\n        syslog(LOG_ERR, \"DBERROR: opening %s: %s\", fname,\n               cyrusdb_strerror(ret));\n            /* Exiting TEMPFAIL because Sendmail thinks this\n               EC_OSFILE == permanent failure. */\n        fatal(\"can't read mailboxes file\", EC_TEMPFAIL);\n    }\n\n    free(tofree);\n\n    mboxlist_dbopen = 1;\n}\n\nEXPORTED void mboxlist_close(void)\n{\n    int r;\n\n    if (mboxlist_dbopen) {\n        r = cyrusdb_close(mbdb);\n        if (r) {\n            syslog(LOG_ERR, \"DBERROR: error closing mailboxes: %s\",\n                   cyrusdb_strerror(r));\n        }\n        mboxlist_dbopen = 0;\n    }\n}\n\nEXPORTED void mboxlist_done(void)\n{\n    /* DB->done() handled by cyrus_done() */\n}\n\n/*\n * Open the subscription list for 'userid'.\n *\n * On success, returns zero.\n * On failure, returns an error code.\n */\nstatic int\nmboxlist_opensubs(const char *userid,\n                  struct db **ret)\n{\n    int r = 0, flags;\n    char *subsfname;\n\n    /* Build subscription list filename */\n    subsfname = user_hash_subs(userid);\n\n    flags = CYRUSDB_CREATE;\n    if (config_getswitch(IMAPOPT_IMPROVED_MBOXLIST_SORT)) {\n        flags |= CYRUSDB_MBOXSORT;\n    }\n\n    r = cyrusdb_open(SUBDB, subsfname, flags, ret);\n    if (r != CYRUSDB_OK) {\n        r = IMAP_IOERROR;\n    }\n    free(subsfname);\n\n    return r;\n}\n\n/*\n * Close a subscription file\n */\nstatic void mboxlist_closesubs(struct db *sub)\n{\n    cyrusdb_close(sub);\n}\n\n/*\n * Find subscribed mailboxes that match 'pattern'.\n * 'isadmin' is nonzero if user is a mailbox admin.  'userid'\n * is the user's login id.  For each matching mailbox, calls\n * 'proc' with the name of the mailbox.\n */\nEXPORTED int mboxlist_findsubmulti(struct namespace *namespace,\n                                   const strarray_t *patterns, int isadmin,\n                                   const char *userid, const struct auth_state *auth_state,\n                                   findall_cb *proc, void *rock,\n                                   int force)\n{\n    int r = 0;\n\n    if (!namespace) namespace = mboxname_get_adminnamespace();\n\n    struct find_rock cbrock;\n    memset(&cbrock, 0, sizeof(struct find_rock));\n\n    /* open the subscription file that contains the mailboxes the\n       user is subscribed to */\n    struct db *subs = NULL;\n    r = mboxlist_opensubs(userid, &subs);\n    if (r) return r;\n\n    cbrock.auth_state = auth_state;\n    cbrock.checkmboxlist = !force;\n    cbrock.db = subs;\n    cbrock.isadmin = isadmin;\n    cbrock.issubs = 1;\n    cbrock.namespace = namespace;\n    cbrock.proc = proc;\n    cbrock.procrock = rock;\n    cbrock.userid = userid;\n    if (userid) {\n        const char *domp = strchr(userid, '@');\n        if (domp) cbrock.domain = domp + 1;\n    }\n\n    r = mboxlist_do_find(&cbrock, patterns);\n\n    mboxlist_closesubs(subs);\n\n    return r;\n}\n\nEXPORTED int mboxlist_findsub(struct namespace *namespace,\n                              const char *pattern, int isadmin,\n                              const char *userid, const struct auth_state *auth_state,\n                              findall_cb *proc, void *rock,\n                              int force)\n{\n    strarray_t patterns = STRARRAY_INITIALIZER;\n    strarray_append(&patterns, pattern);\n\n    int r = mboxlist_findsubmulti(namespace, &patterns, isadmin, userid, auth_state, proc, rock, force);\n\n    strarray_fini(&patterns);\n\n    return r;\n}\n\nstatic int subsadd_cb(void *rock, const char *key, size_t keylen,\n                      const char *val __attribute__((unused)),\n                      size_t vallen __attribute__((unused)))\n{\n    strarray_t *list = (strarray_t *)rock;\n    strarray_appendm(list, xstrndup(key, keylen));\n    return 0;\n}\n\nEXPORTED strarray_t *mboxlist_sublist(const char *userid)\n{\n    struct db *subs = NULL;\n    strarray_t *list = strarray_new();\n    int r;\n\n    /* open subs DB */\n    r = mboxlist_opensubs(userid, &subs);\n    if (r) goto done;\n\n    /* faster to do it all in a single slurp! */\n    r = cyrusdb_foreach(subs, \"\", 0, subsadd_cb, NULL, list, 0);\n\n    mboxlist_closesubs(subs);\n\ndone:\n    if (r) {\n        strarray_free(list);\n        return NULL;\n    }\n    return list;\n}\n\n\n\nstruct submb_rock {\n    struct mboxlist_entry *mbentry;\n    const char *userid;\n    int flags;\n    mboxlist_cb *proc;\n    void *rock;\n};\n\nstatic int usersubs_cb(void *rock, const char *key, size_t keylen,\n                      const char *data __attribute__((unused)),\n                      size_t datalen __attribute__((unused)))\n{\n    struct submb_rock *mbrock = (struct submb_rock *) rock;\n    char mboxname[MAX_MAILBOX_NAME+1];\n    int r;\n\n    /* free previous record */\n    mboxlist_entry_free(&mbrock->mbentry);\n\n    snprintf(mboxname, MAX_MAILBOX_NAME, \"%.*s\", (int) keylen, key);\n\n    if ((mbrock->flags & MBOXTREE_SKIP_PERSONAL) &&\n        mboxname_userownsmailbox(mbrock->userid, mboxname)) return 0;\n\n    r = mboxlist_lookup(mboxname, &mbrock->mbentry, NULL);\n    if (r) {\n        syslog(LOG_INFO, \"mboxlist_lookup(%s) failed: %s\",\n               mboxname, error_message(r));\n        return r;\n    }\n\n    return mbrock->proc(mbrock->mbentry, mbrock->rock);\n}\n\nEXPORTED int mboxlist_usersubs(const char *userid, mboxlist_cb *proc,\n                               void *rock, int flags)\n{\n    struct db *subs = NULL;\n    struct submb_rock mbrock = { NULL, userid, flags, proc, rock };\n    int r = 0;\n\n    /* open subs DB */\n    r = mboxlist_opensubs(userid, &subs);\n    if (r) return r;\n\n    /* faster to do it all in a single slurp! */\n    r = cyrusdb_foreach(subs, \"\", 0, NULL, usersubs_cb, &mbrock, 0);\n\n    mboxlist_entry_free(&mbrock.mbentry);\n\n    mboxlist_closesubs(subs);\n\n    return r;\n}\n\n\n\n\n/* returns CYRUSDB_NOTFOUND if the folder doesn't exist, and 0 if it does! */\nEXPORTED int mboxlist_checksub(const char *name, const char *userid)\n{\n    int r;\n    struct db *subs;\n    const char *val;\n    size_t vallen;\n\n    r = mboxlist_opensubs(userid, &subs);\n\n    if (!r) r = cyrusdb_fetch(subs, name, strlen(name), &val, &vallen, NULL);\n\n    mboxlist_closesubs(subs);\n    return r;\n}\n\n/*\n * Change 'user's subscription status for mailbox 'name'.\n * Subscribes if 'add' is nonzero, unsubscribes otherwise.\n * if 'force' is set, force the subscription through even if\n * we don't know about 'name'.\n */\nEXPORTED int mboxlist_changesub(const char *name, const char *userid,\n                                const struct auth_state *auth_state,\n                                int add, int force, int notify)\n{\n    mbentry_t *mbentry = NULL;\n    int r;\n    struct db *subs;\n    struct mboxevent *mboxevent;\n\n    if ((r = mboxlist_opensubs(userid, &subs)) != 0) {\n        return r;\n    }\n\n    if (add && !force) {\n        /* Ensure mailbox exists and can be seen by user */\n        if ((r = mboxlist_lookup(name, &mbentry, NULL))!=0) {\n            mboxlist_closesubs(subs);\n            return r;\n        }\n        if ((cyrus_acl_myrights(auth_state, mbentry->acl) & ACL_LOOKUP) == 0) {\n            mboxlist_closesubs(subs);\n            mboxlist_entry_free(&mbentry);\n            return IMAP_MAILBOX_NONEXISTENT;\n        }\n    }\n\n    if (add) {\n        r = cyrusdb_store(subs, name, strlen(name), \"\", 0, NULL);\n    } else {\n        r = cyrusdb_delete(subs, name, strlen(name), NULL, 0);\n        /* if it didn't exist, that's ok */\n        if (r == CYRUSDB_EXISTS) r = CYRUSDB_OK;\n    }\n\n    switch (r) {\n    case CYRUSDB_OK:\n        r = 0;\n        break;\n\n    default:\n        r = IMAP_IOERROR;\n        break;\n    }\n\n    sync_log_subscribe(userid, name);\n    mboxlist_closesubs(subs);\n    mboxlist_entry_free(&mbentry);\n\n    /* prepare a MailboxSubscribe or MailboxUnSubscribe event notification */\n    if (notify && r == 0) {\n        mboxevent = mboxevent_new(add ? EVENT_MAILBOX_SUBSCRIBE :\n                                        EVENT_MAILBOX_UNSUBSCRIBE);\n\n        mboxevent_set_access(mboxevent, NULL, NULL, userid, name, 1);\n        mboxevent_notify(&mboxevent);\n        mboxevent_free(&mboxevent);\n    }\n\n    return r;\n}\n\n/* Transaction Handlers */\nEXPORTED int mboxlist_commit(struct txn *tid)\n{\n    assert(tid);\n\n    return cyrusdb_commit(mbdb, tid);\n}\n\nint mboxlist_abort(struct txn *tid)\n{\n    assert(tid);\n\n    return cyrusdb_abort(mbdb, tid);\n}\n\nEXPORTED int mboxlist_delayed_delete_isenabled(void)\n{\n    enum enum_value config_delete_mode = config_getenum(IMAPOPT_DELETE_MODE);\n\n    return(config_delete_mode == IMAP_ENUM_DELETE_MODE_DELAYED);\n}\n"], "fixing_code": ["/* mboxlist.c -- Mailbox list manipulation routines\n *\n * Copyright (c) 1994-2008 Carnegie Mellon University.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * 3. The name \"Carnegie Mellon University\" must not be used to\n *    endorse or promote products derived from this software without\n *    prior written permission. For permission or any legal\n *    details, please contact\n *      Carnegie Mellon University\n *      Center for Technology Transfer and Enterprise Creation\n *      4615 Forbes Avenue\n *      Suite 302\n *      Pittsburgh, PA  15213\n *      (412) 268-7393, fax: (412) 268-7395\n *      innovation@andrew.cmu.edu\n *\n * 4. Redistributions of any form whatsoever must retain the following\n *    acknowledgment:\n *    \"This product includes software developed by Computing Services\n *     at Carnegie Mellon University (http://www.cmu.edu/computing/).\"\n *\n * CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO\n * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE\n * FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN\n * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <config.h>\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/uio.h>\n#include <fcntl.h>\n#include <syslog.h>\n\n#include <sys/ipc.h>\n#include <sys/msg.h>\n\n#include \"acl.h\"\n#include \"annotate.h\"\n#include \"glob.h\"\n#include \"assert.h\"\n#include \"global.h\"\n#include \"cyrusdb.h\"\n#include \"util.h\"\n#include \"mailbox.h\"\n#include \"mboxevent.h\"\n#include \"exitcodes.h\"\n#include \"xmalloc.h\"\n#include \"xstrlcpy.h\"\n#include \"partlist.h\"\n#include \"xstrlcat.h\"\n#include \"user.h\"\n\n/* generated headers are not necessarily in current directory */\n#include \"imap/imap_err.h\"\n\n#include \"mboxname.h\"\n#include \"mupdate-client.h\"\n\n#include \"mboxlist.h\"\n#include \"quota.h\"\n#include \"sync_log.h\"\n\n#define DB config_mboxlist_db\n#define SUBDB config_subscription_db\n\ncyrus_acl_canonproc_t mboxlist_ensureOwnerRights;\n\nstatic struct db *mbdb;\n\nstatic int mboxlist_dbopen = 0;\n\nstatic int mboxlist_opensubs(const char *userid, struct db **ret);\nstatic void mboxlist_closesubs(struct db *sub);\n\nstatic int mboxlist_rmquota(const mbentry_t *mbentry, void *rock);\nstatic int mboxlist_changequota(const mbentry_t *mbentry, void *rock);\n\nEXPORTED mbentry_t *mboxlist_entry_create(void)\n{\n    mbentry_t *ret = xzmalloc(sizeof(mbentry_t));\n    /* xxx - initialiser functions here? */\n    return ret;\n}\n\nEXPORTED mbentry_t *mboxlist_entry_copy(const mbentry_t *src)\n{\n    mbentry_t *copy = mboxlist_entry_create();\n    copy->name = xstrdupnull(src->name);\n    copy->ext_name = xstrdupnull(src->ext_name);\n\n    copy->mtime = src->mtime;\n    copy->uidvalidity = src->uidvalidity;\n    copy->mbtype = src->mbtype;\n    copy->foldermodseq = src->foldermodseq;\n\n    copy->partition = xstrdupnull(src->partition);\n    copy->server = xstrdupnull(src->server);\n    copy->acl = xstrdupnull(src->acl);\n    copy->uniqueid = xstrdupnull(src->uniqueid);\n\n    copy->legacy_specialuse = xstrdupnull(src->legacy_specialuse);\n\n    return copy;\n}\n\nEXPORTED void mboxlist_entry_free(mbentry_t **mbentryptr)\n{\n    mbentry_t *mbentry = *mbentryptr;\n\n    /* idempotent */\n    if (!mbentry) return;\n\n    free(mbentry->name);\n    free(mbentry->ext_name);\n\n    free(mbentry->partition);\n    free(mbentry->server);\n    free(mbentry->acl);\n    free(mbentry->uniqueid);\n\n    free(mbentry->legacy_specialuse);\n\n    free(mbentry);\n\n    *mbentryptr = NULL;\n}\n\nstatic void _write_acl(struct dlist *dl, const char *aclstr)\n{\n    const char *p, *q;\n    struct dlist *al = dlist_newkvlist(dl, \"A\");\n\n    p = aclstr;\n\n    while (p && *p) {\n        char *name,*val;\n\n        q = strchr(p, '\\t');\n        if (!q) break;\n\n        name = xstrndup(p, q-p);\n        q++;\n\n        p = strchr(q, '\\t');\n        if (p) {\n            val = xstrndup(q, p-q);\n            p++;\n        }\n        else\n            val = xstrdup(q);\n\n        dlist_setatom(al, name, val);\n\n        free(name);\n        free(val);\n    }\n}\n\nEXPORTED const char *mboxlist_mbtype_to_string(uint32_t mbtype)\n{\n    static struct buf buf = BUF_INITIALIZER;\n\n    buf_reset(&buf);\n\n    if (mbtype & MBTYPE_DELETED)\n        buf_putc(&buf, 'd');\n    if (mbtype & MBTYPE_MOVING)\n        buf_putc(&buf, 'm');\n    if (mbtype & MBTYPE_NETNEWS)\n        buf_putc(&buf, 'n');\n    if (mbtype & MBTYPE_REMOTE)\n        buf_putc(&buf, 'r');\n    if (mbtype & MBTYPE_RESERVE)\n        buf_putc(&buf, 'z');\n    if (mbtype & MBTYPE_CALENDAR)\n        buf_putc(&buf, 'c');\n    if (mbtype & MBTYPE_COLLECTION)\n        buf_putc(&buf, 'b');\n    if (mbtype & MBTYPE_ADDRESSBOOK)\n        buf_putc(&buf, 'a');\n\n    return buf_cstring(&buf);\n}\n\nstatic char *mboxlist_entry_cstring(const mbentry_t *mbentry)\n{\n    struct buf buf = BUF_INITIALIZER;\n    struct dlist *dl = dlist_newkvlist(NULL, mbentry->name);\n\n    if (mbentry->acl)\n        _write_acl(dl, mbentry->acl);\n\n    if (mbentry->uniqueid)\n        dlist_setatom(dl, \"I\", mbentry->uniqueid);\n\n    if (mbentry->partition)\n        dlist_setatom(dl, \"P\", mbentry->partition);\n\n    if (mbentry->server)\n        dlist_setatom(dl, \"S\", mbentry->server);\n\n    if (mbentry->mbtype)\n        dlist_setatom(dl, \"T\", mboxlist_mbtype_to_string(mbentry->mbtype));\n\n    if (mbentry->uidvalidity)\n        dlist_setnum32(dl, \"V\", mbentry->uidvalidity);\n\n    if (mbentry->foldermodseq)\n        dlist_setnum64(dl, \"F\", mbentry->foldermodseq);\n\n    dlist_setdate(dl, \"M\", time(NULL));\n\n    dlist_printbuf(dl, 0, &buf);\n\n    dlist_free(&dl);\n\n    return buf_release(&buf);\n}\n\nEXPORTED char *mbentry_metapath(const struct mboxlist_entry *mbentry, int metatype, int isnew)\n{\n    return mboxname_metapath(mbentry->partition,\n                             mbentry->name,\n                             mbentry->uniqueid,\n                             metatype,\n                             isnew);\n}\n\nEXPORTED char *mbentry_datapath(const struct mboxlist_entry *mbentry, uint32_t uid)\n{\n    return mboxname_datapath(mbentry->partition,\n                             mbentry->name,\n                             mbentry->uniqueid,\n                             uid);\n}\n\n/*\n * read a single record from the mailboxes.db and return a pointer to it\n */\nstatic int mboxlist_read(const char *name, const char **dataptr, size_t *datalenptr,\n                         struct txn **tid, int wrlock)\n{\n    int namelen = strlen(name);\n    int r;\n\n    if (!namelen)\n        return IMAP_MAILBOX_NONEXISTENT;\n\n    if (wrlock) {\n        r = cyrusdb_fetchlock(mbdb, name, namelen, dataptr, datalenptr, tid);\n    } else {\n        r = cyrusdb_fetch(mbdb, name, namelen, dataptr, datalenptr, tid);\n    }\n\n    switch (r) {\n    case CYRUSDB_OK:\n        /* no entry required, just checking if it exists */\n        return 0;\n        break;\n\n    case CYRUSDB_AGAIN:\n        return IMAP_AGAIN;\n        break;\n\n    case CYRUSDB_NOTFOUND:\n        return IMAP_MAILBOX_NONEXISTENT;\n        break;\n\n    default:\n        syslog(LOG_ERR, \"DBERROR: error fetching mboxlist %s: %s\",\n               name, cyrusdb_strerror(r));\n        return IMAP_IOERROR;\n        break;\n    }\n\n    /* never get here */\n}\n\nEXPORTED uint32_t mboxlist_string_to_mbtype(const char *string)\n{\n    uint32_t mbtype = 0;\n\n    if (!string) return 0; /* null just means default */\n\n    for (; *string; string++) {\n        switch (*string) {\n        case 'a':\n            mbtype |= MBTYPE_ADDRESSBOOK;\n            break;\n        case 'b':\n            mbtype |= MBTYPE_COLLECTION;\n            break;\n        case 'c':\n            mbtype |= MBTYPE_CALENDAR;\n            break;\n        case 'd':\n            mbtype |= MBTYPE_DELETED;\n            break;\n        case 'm':\n            mbtype |= MBTYPE_MOVING;\n            break;\n        case 'n':\n            mbtype |= MBTYPE_NETNEWS;\n            break;\n        case 'r':\n            mbtype |= MBTYPE_REMOTE;\n            break;\n        case 'z':\n            mbtype |= MBTYPE_RESERVE;\n            break;\n        }\n    }\n\n    return mbtype;\n}\n\nstruct parseentry_rock {\n    struct mboxlist_entry *mbentry;\n    struct buf *aclbuf;\n    int doingacl;\n};\n\nint parseentry_cb(int type, struct dlistsax_data *d)\n{\n    struct parseentry_rock *rock = (struct parseentry_rock *)d->rock;\n\n    switch(type) {\n    case DLISTSAX_KVLISTSTART:\n        if (!strcmp(buf_cstring(&d->kbuf), \"A\")) {\n            rock->doingacl = 1;\n        }\n        break;\n    case DLISTSAX_KVLISTEND:\n        rock->doingacl = 0;\n        break;\n    case DLISTSAX_STRING:\n        if (rock->doingacl) {\n            buf_append(rock->aclbuf, &d->kbuf);\n            buf_putc(rock->aclbuf, '\\t');\n            buf_append(rock->aclbuf, &d->buf);\n            buf_putc(rock->aclbuf, '\\t');\n        }\n        else {\n            const char *key = buf_cstring(&d->kbuf);\n            if (!strcmp(key, \"F\")) {\n                rock->mbentry->foldermodseq = atoll(buf_cstring(&d->buf));\n            }\n            else if (!strcmp(key, \"I\")) {\n                rock->mbentry->uniqueid = buf_newcstring(&d->buf);\n            }\n            else if (!strcmp(key, \"M\")) {\n                rock->mbentry->mtime = atoi(buf_cstring(&d->buf));\n            }\n            else if (!strcmp(key, \"P\")) {\n                rock->mbentry->partition = buf_newcstring(&d->buf);\n            }\n            else if (!strcmp(key, \"S\")) {\n                rock->mbentry->server = buf_newcstring(&d->buf);\n            }\n            else if (!strcmp(key, \"T\")) {\n                rock->mbentry->mbtype = mboxlist_string_to_mbtype(buf_cstring(&d->buf));\n            }\n            else if (!strcmp(key, \"V\")) {\n                rock->mbentry->uidvalidity = atol(buf_cstring(&d->buf));\n            }\n        }\n    }\n\n    return 0;\n}\n\n/*\n * parse a record read from the mailboxes.db into its parts.\n *\n * full dlist format is:\n *  A: _a_cl\n *  I: unique_i_d\n *  M: _m_time\n *  P: _p_artition\n *  S: _s_erver\n *  T: _t_ype\n *  V: uid_v_alidity\n */\nEXPORTED int mboxlist_parse_entry(mbentry_t **mbentryptr,\n                                  const char *name, size_t namelen,\n                                  const char *data, size_t datalen)\n{\n    static struct buf aclbuf;\n    int r = IMAP_MAILBOX_BADFORMAT;\n    char *freeme = NULL;\n    char **target;\n    char *p, *q;\n    mbentry_t *mbentry = mboxlist_entry_create();\n\n    if (!datalen)\n        goto done;\n\n    /* copy name */\n    if (namelen)\n        mbentry->name = xstrndup(name, namelen);\n    else\n        mbentry->name = xstrdup(name);\n\n    /* check for DLIST mboxlist */\n    if (*data == '%') {\n        struct parseentry_rock rock;\n        memset(&rock, 0, sizeof(struct parseentry_rock));\n        rock.mbentry = mbentry;\n        rock.aclbuf = &aclbuf;\n        aclbuf.len = 0;\n        r = dlist_parsesax(data, datalen, 0, parseentry_cb, &rock);\n        if (!r) mbentry->acl = buf_newcstring(&aclbuf);\n        goto done;\n    }\n\n    /* copy data */\n    freeme = p = xstrndup(data, datalen);\n\n    /* check for extended mboxlist entry */\n    if (*p == '(') {\n        int last = 0;\n        p++; /* past leading '(' */\n        while (!last) {\n            target = NULL;\n            q = p;\n            while (*q && *q != ' ' && *q != ')') q++;\n            if (*q != ' ') break;\n            *q++ = '\\0';\n            if (!strcmp(p, \"uniqueid\")) target = &mbentry->uniqueid;\n            if (!strcmp(p, \"specialuse\")) target = &mbentry->legacy_specialuse;\n            p = q;\n            while (*q && *q != ' ' && *q != ')') q++;\n            if (*q != ' ') last = 1;\n            if (*q) *q++ = '\\0';\n            if (target) *target = xstrdup(p);\n            p = q;\n        }\n        if (*p == ' ') p++; /* past trailing ' ' */\n    }\n\n    /* copy out interesting parts */\n    mbentry->mbtype = strtol(p, &p, 10);\n    if (*p == ' ') p++;\n\n    q = p;\n    while (*q && *q != ' ' && *q != '!') q++;\n    if (*q == '!') {\n        *q++ = '\\0';\n        mbentry->server = xstrdup(p);\n        p = q;\n        while (*q && *q != ' ') q++;\n    }\n    if (*q) *q++ = '\\0';\n    mbentry->partition = xstrdup(p);\n\n    mbentry->acl = xstrdup(q);\n\n    r = 0;\n\ndone:\n    if (!r && mbentryptr)\n        *mbentryptr = mbentry;\n    else mboxlist_entry_free(&mbentry);\n    free(freeme);\n    return r;\n}\n\n/* read a record and parse into parts */\nstatic int mboxlist_mylookup(const char *name,\n                             mbentry_t **mbentryptr,\n                             struct txn **tid, int wrlock)\n{\n    int r;\n    const char *data;\n    size_t datalen;\n\n    r = mboxlist_read(name, &data, &datalen, tid, wrlock);\n    if (r) return r;\n\n    return mboxlist_parse_entry(mbentryptr, name, 0, data, datalen);\n}\n\n/*\n * Lookup 'name' in the mailbox list, ignoring reserved records\n */\nEXPORTED int mboxlist_lookup(const char *name, mbentry_t **entryptr,\n                             struct txn **tid)\n{\n    mbentry_t *entry = NULL;\n    int r;\n\n    r = mboxlist_mylookup(name, &entry, tid, 0);\n\n    if (r) return r;\n\n    /* Ignore \"reserved\" entries, like they aren't there */\n    if (entry->mbtype & MBTYPE_RESERVE) {\n        mboxlist_entry_free(&entry);\n        return IMAP_MAILBOX_RESERVED;\n    }\n\n    /* Ignore \"deleted\" entries, like they aren't there */\n    if (entry->mbtype & MBTYPE_DELETED) {\n        mboxlist_entry_free(&entry);\n        return IMAP_MAILBOX_NONEXISTENT;\n    }\n\n    if (entryptr) *entryptr = entry;\n    else mboxlist_entry_free(&entry);\n\n    return 0;\n}\n\nEXPORTED int mboxlist_lookup_allow_all(const char *name,\n                                   mbentry_t **entryptr,\n                                   struct txn **tid)\n{\n    return mboxlist_mylookup(name, entryptr, tid, 0);\n}\n\nstruct _find_specialuse_data {\n    const char *use;\n    const char *userid;\n    char *mboxname;\n};\n\nstatic int _find_specialuse(const mbentry_t *mbentry, void *rock)\n{\n    struct _find_specialuse_data *d = (struct _find_specialuse_data *)rock;\n    struct buf attrib = BUF_INITIALIZER;\n\n    annotatemore_lookup(mbentry->name, \"/specialuse\", d->userid, &attrib);\n\n    if (attrib.len) {\n        strarray_t *uses = strarray_split(buf_cstring(&attrib), \" \", 0);\n        if (strarray_find_case(uses, d->use, 0) >= 0)\n            d->mboxname = xstrdup(mbentry->name);\n        strarray_free(uses);\n    }\n\n    buf_free(&attrib);\n\n    if (d->mboxname) return CYRUSDB_DONE;\n    return 0;\n}\n\n\nEXPORTED char *mboxlist_find_specialuse(const char *use, const char *userid)\n{\n    /* \\\\Inbox is magical */\n    if (!strcasecmp(use, \"\\\\Inbox\"))\n        return mboxname_user_mbox(userid, NULL);\n\n    struct _find_specialuse_data rock = { use, userid, NULL };\n    mboxlist_usermboxtree(userid, _find_specialuse, &rock, MBOXTREE_SKIP_ROOT);\n    return rock.mboxname;\n}\n\nstruct _find_uniqueid_data {\n    const char *uniqueid;\n    char *mboxname;\n};\n\nstatic int _find_uniqueid(const mbentry_t *mbentry, void *rock) {\n    struct _find_uniqueid_data *d = (struct _find_uniqueid_data *) rock;\n    int r = 0;\n    if (!strcmp(d->uniqueid, mbentry->uniqueid)) {\n        d->mboxname = xstrdup(mbentry->name);\n        r = CYRUSDB_DONE;\n    }\n    return r;\n}\n\nEXPORTED char *mboxlist_find_uniqueid(const char *uniqueid, const char *userid)\n{\n    struct _find_uniqueid_data rock = { uniqueid, NULL };\n    mboxlist_usermboxtree(userid, _find_uniqueid, &rock, MBOXTREE_PLUS_RACL);\n    return rock.mboxname;\n}\n\n/* given a mailbox name, find the staging directory.  XXX - this should\n * require more locking, and staging directories should be by pid */\nHIDDEN int mboxlist_findstage(const char *name, char *stagedir, size_t sd_len)\n{\n    const char *root;\n    mbentry_t *mbentry = NULL;\n    int r;\n\n    assert(stagedir != NULL);\n\n    /* Find mailbox */\n    r = mboxlist_lookup(name, &mbentry, NULL);\n    if (r) return r;\n\n    root = config_partitiondir(mbentry->partition);\n    mboxlist_entry_free(&mbentry);\n\n    if (!root) return IMAP_PARTITION_UNKNOWN;\n\n    snprintf(stagedir, sd_len, \"%s/stage./\", root);\n\n    return 0;\n}\n\nstatic void mboxlist_racl_key(int isuser, const char *keyuser, const char *mbname, struct buf *buf)\n{\n    buf_setcstr(buf, \"$RACL$\");\n    buf_putc(buf, isuser ? 'U' : 'S');\n    buf_putc(buf, '$');\n    if (keyuser) {\n        buf_appendcstr(buf, keyuser);\n        buf_putc(buf, '$');\n    }\n    if (mbname) {\n        buf_appendcstr(buf, mbname);\n    }\n}\n\nstatic int user_is_in(const strarray_t *aclbits, const char *user)\n{\n    int i;\n    if (!aclbits) return 0;\n    for (i = 0; i+1 < strarray_size(aclbits); i+=2) {\n        if (!strcmp(strarray_nth(aclbits, i), user)) return 1;\n    }\n    return 0;\n}\n\nstatic int mboxlist_update_racl(const char *name, const mbentry_t *oldmbentry, const mbentry_t *newmbentry, struct txn **txn)\n{\n    static strarray_t *admins = NULL;\n    struct buf buf = BUF_INITIALIZER;\n    char *userid = mboxname_to_userid(name);\n    strarray_t *oldusers = NULL;\n    strarray_t *newusers = NULL;\n    int i;\n    int r = 0;\n\n    if (!admins) admins = strarray_split(config_getstring(IMAPOPT_ADMINS), NULL, 0);\n\n    if (oldmbentry && oldmbentry->mbtype != MBTYPE_DELETED)\n        oldusers = strarray_split(oldmbentry->acl, \"\\t\", 0);\n\n    if (newmbentry && newmbentry->mbtype != MBTYPE_DELETED)\n        newusers = strarray_split(newmbentry->acl, \"\\t\", 0);\n\n    if (oldusers) {\n        for (i = 0; i+1 < strarray_size(oldusers); i+=2) {\n            const char *acluser = strarray_nth(oldusers, i);\n            const char *aclval = strarray_nth(oldusers, i+1);\n            if (!strchr(aclval, 'l')) continue; /* non-lookup ACLs can be skipped */\n            if (!strcmpsafe(userid, acluser)) continue;\n            if (strarray_find(admins, acluser, 0) >= 0) continue;\n            if (user_is_in(newusers, acluser)) continue;\n            mboxlist_racl_key(!!userid, acluser, name, &buf);\n            r = cyrusdb_delete(mbdb, buf.s, buf.len, txn, /*force*/1);\n            if (r) goto done;\n        }\n    }\n\n    if (newusers) {\n        for (i = 0; i+1 < strarray_size(newusers); i+=2) {\n            const char *acluser = strarray_nth(newusers, i);\n            const char *aclval = strarray_nth(newusers, i+1);\n            if (!strchr(aclval, 'l')) continue; /* non-lookup ACLs can be skipped */\n            if (!strcmpsafe(userid, acluser)) continue;\n            if (strarray_find(admins, acluser, 0) >= 0) continue;\n            if (user_is_in(oldusers, acluser)) continue;\n            mboxlist_racl_key(!!userid, acluser, name, &buf);\n            r = cyrusdb_store(mbdb, buf.s, buf.len, \"\", 0, txn);\n            if (r) goto done;\n        }\n    }\n\n done:\n    strarray_free(oldusers);\n    strarray_free(newusers);\n    free(userid);\n    buf_free(&buf);\n    return r;\n}\n\nstatic int mboxlist_update_entry(const char *name, const mbentry_t *mbentry, struct txn **txn)\n{\n    mbentry_t *old = NULL;\n    int r = 0;\n\n    mboxlist_mylookup(name, &old, txn, 0); // ignore errors, it will be NULL\n\n    if (!cyrusdb_fetch(mbdb, \"$RACL\", 5, NULL, NULL, txn)) {\n        r = mboxlist_update_racl(name, old, mbentry, txn);\n        /* XXX return value here is discarded? */\n    }\n\n    if (mbentry) {\n        char *mboxent = mboxlist_entry_cstring(mbentry);\n        r = cyrusdb_store(mbdb, name, strlen(name), mboxent, strlen(mboxent), txn);\n        free(mboxent);\n\n        if (!r && config_auditlog) {\n            /* XXX is there a difference between \"\" and NULL? */\n            if (old && strcmpsafe(old->acl, mbentry->acl)) {\n                syslog(LOG_NOTICE, \"auditlog: acl sessionid=<%s> \"\n                                   \"mailbox=<%s> uniqueid=<%s> \"\n                                   \"oldacl=<%s> acl=<%s>\",\n                       session_id(),\n                       name, mbentry->uniqueid,\n                       old->acl, mbentry->acl);\n            }\n        }\n    }\n    else {\n        r = cyrusdb_delete(mbdb, name, strlen(name), txn, /*force*/1);\n    }\n\n    mboxlist_entry_free(&old);\n    return r;\n}\n\nEXPORTED int mboxlist_delete(const char *name)\n{\n    return mboxlist_update_entry(name, NULL, NULL);\n}\n\nEXPORTED int mboxlist_update(mbentry_t *mbentry, int localonly)\n{\n    int r = 0, r2 = 0;\n    struct txn *tid = NULL;\n\n    r = mboxlist_update_entry(mbentry->name, mbentry, &tid);\n\n    if (!r)\n        mboxname_setmodseq(mbentry->name, mbentry->foldermodseq, mbentry->mbtype, /*dofolder*/1);\n\n    /* commit the change to mupdate */\n    if (!r && !localonly && config_mupdate_server) {\n        mupdate_handle *mupdate_h = NULL;\n\n        r = mupdate_connect(config_mupdate_server, NULL, &mupdate_h, NULL);\n        if (r) {\n            syslog(LOG_ERR,\n                   \"cannot connect to mupdate server for update of '%s'\",\n                   mbentry->name);\n        } else {\n            char *location = strconcat(config_servername, \"!\",\n                                       mbentry->partition, (char *)NULL);\n            r = mupdate_activate(mupdate_h, mbentry->name,\n                                 location, mbentry->acl);\n            free(location);\n            if (r) {\n                syslog(LOG_ERR,\n                       \"MUPDATE: can't update mailbox entry for '%s'\",\n                       mbentry->name);\n            }\n        }\n        mupdate_disconnect(&mupdate_h);\n    }\n\n    if (tid) {\n        if (r) {\n            r2 = cyrusdb_abort(mbdb, tid);\n        } else {\n            r2 = cyrusdb_commit(mbdb, tid);\n        }\n    }\n\n    if (r2) {\n        syslog(LOG_ERR, \"DBERROR: error %s txn in mboxlist_update: %s\",\n               r ? \"aborting\" : \"commiting\", cyrusdb_strerror(r2));\n    }\n\n    return r;\n}\n\nEXPORTED int mboxlist_findparent(const char *mboxname,\n                               mbentry_t **mbentryp)\n{\n    mbentry_t *mbentry = NULL;\n    mbname_t *mbname = mbname_from_intname(mboxname);\n    int r = IMAP_MAILBOX_NONEXISTENT;\n\n    while (strarray_size(mbname_boxes(mbname))) {\n        free(mbname_pop_boxes(mbname));\n        mboxlist_entry_free(&mbentry);\n        r = mboxlist_lookup(mbname_intname(mbname), &mbentry, NULL);\n        if (r != IMAP_MAILBOX_NONEXISTENT)\n            break;\n    }\n\n    if (r)\n        mboxlist_entry_free(&mbentry);\n    else\n        *mbentryp = mbentry;\n\n    mbname_free(&mbname);\n\n    return r;\n}\n\nstatic int mboxlist_create_partition(const char *mboxname,\n                                     const char *part,\n                                     char **out)\n{\n    mbentry_t *parent = NULL;\n\n    if (!part) {\n        int r = mboxlist_findparent(mboxname, &parent);\n        if (!r) part = parent->partition;\n    }\n\n    /* use defaultpartition if specified */\n    if (!part && config_defpartition)\n        part = config_defpartition;\n\n    /* look for most fitting partition */\n    if (!part)\n        part = partlist_local_select();\n\n    /* Configuration error */\n    if (!part || (strlen(part) > MAX_PARTITION_LEN))\n        goto err;\n\n    if (!config_partitiondir(part))\n        goto err;\n\n    *out = xstrdupnull(part);\n\n    mboxlist_entry_free(&parent);\n    return 0;\n\nerr:\n    mboxlist_entry_free(&parent);\n    return IMAP_PARTITION_UNKNOWN;\n}\n\n/*\n * Check if a mailbox can be created.  There is no other setup at this\n * stage, just the check!\n */\nstatic int mboxlist_create_namecheck(const char *mboxname,\n                                     const char *userid,\n                                     const struct auth_state *auth_state,\n                                     int isadmin, int force_subdirs)\n{\n    mbentry_t *mbentry = NULL;\n    int r = 0;\n\n    /* policy first */\n    r = mboxname_policycheck(mboxname);\n    if (r) goto done;\n\n    /* is this the user's INBOX namespace? */\n    if (!isadmin && mboxname_userownsmailbox(userid, mboxname)) {\n        /* User has admin rights over their own mailbox namespace */\n        if (config_implicitrights & ACL_ADMIN)\n            isadmin = 1;\n    }\n\n    /* Check to see if mailbox already exists */\n    r = mboxlist_lookup(mboxname, &mbentry, NULL);\n    if (r != IMAP_MAILBOX_NONEXISTENT) {\n        if (!r) {\n            r = IMAP_MAILBOX_EXISTS;\n\n            /* Lie about error if privacy demands */\n            if (!isadmin &&\n                !(cyrus_acl_myrights(auth_state, mbentry->acl) & ACL_LOOKUP)) {\n                r = IMAP_PERMISSION_DENIED;\n            }\n        }\n\n        goto done;\n    }\n    mboxlist_entry_free(&mbentry);\n\n    /* look for a parent mailbox */\n    r = mboxlist_findparent(mboxname, &mbentry);\n    if (r == 0) {\n        /* found a parent */\n        char root[MAX_MAILBOX_NAME+1];\n\n        /* check acl */\n        if (!isadmin &&\n            !(cyrus_acl_myrights(auth_state, mbentry->acl) & ACL_CREATE)) {\n            r = IMAP_PERMISSION_DENIED;\n            goto done;\n        }\n\n        /* check quota */\n        if (quota_findroot(root, sizeof(root), mboxname)) {\n            quota_t qdiffs[QUOTA_NUMRESOURCES] = QUOTA_DIFFS_DONTCARE_INITIALIZER;\n            qdiffs[QUOTA_NUMFOLDERS] = 1;\n            r = quota_check_useds(root, qdiffs);\n            if (r) goto done;\n        }\n    }\n    else if (r == IMAP_MAILBOX_NONEXISTENT) {\n        /* no parent mailbox */\n        if (!isadmin) {\n            r = IMAP_PERMISSION_DENIED;\n            goto done;\n        }\n\n        if (!force_subdirs) {\n            mbname_t *mbname = mbname_from_intname(mboxname);\n            if (!mbname_isdeleted(mbname) && mbname_userid(mbname) && strarray_size(mbname_boxes(mbname))) {\n                /* Disallow creating user.X.* when no user.X */\n                r = IMAP_PERMISSION_DENIED;\n                goto done;\n            }\n            mbname_free(&mbname);\n        }\n\n        /* otherwise no parent is OK */\n        r = 0;\n    }\n\ndone:\n    mboxlist_entry_free(&mbentry);\n\n    return r;\n}\n\nstatic int mboxlist_create_acl(const char *mboxname, char **out)\n{\n    mbentry_t *mbentry = NULL;\n    int r;\n    int mask;\n\n    char *defaultacl;\n    char *identifier;\n    char *rights;\n    char *p;\n\n    r = mboxlist_findparent(mboxname, &mbentry);\n    if (!r) {\n        *out = xstrdup(mbentry->acl);\n        mboxlist_entry_free(&mbentry);\n        return 0;\n    }\n\n    *out = xstrdup(\"\");\n    char *owner = mboxname_to_userid(mboxname);\n    if (owner) {\n        /* owner gets full permission on own mailbox by default */\n        cyrus_acl_set(out, owner, ACL_MODE_SET, ACL_ALL,\n                      (cyrus_acl_canonproc_t *)0, (void *)0);\n        free(owner);\n        return 0;\n    }\n\n    defaultacl = identifier = xstrdup(config_getstring(IMAPOPT_DEFAULTACL));\n    for (;;) {\n        while (*identifier && Uisspace(*identifier)) identifier++;\n        rights = identifier;\n        while (*rights && !Uisspace(*rights)) rights++;\n        if (!*rights) break;\n        *rights++ = '\\0';\n        while (*rights && Uisspace(*rights)) rights++;\n        if (!*rights) break;\n        p = rights;\n        while (*p && !Uisspace(*p)) p++;\n        if (*p) *p++ = '\\0';\n        cyrus_acl_strtomask(rights, &mask);\n        /* XXX and if strtomask fails? */\n        cyrus_acl_set(out, identifier, ACL_MODE_SET, mask,\n                      (cyrus_acl_canonproc_t *)0, (void *)0);\n        identifier = p;\n    }\n    free(defaultacl);\n\n    return 0;\n}\n\n/* and this API just plain sucks */\nEXPORTED int mboxlist_createmailboxcheck(const char *name, int mbtype __attribute__((unused)),\n                                const char *partition,\n                                int isadmin, const char *userid,\n                                const struct auth_state *auth_state,\n                                char **newacl, char **newpartition,\n                                int forceuser)\n{\n    char *part = NULL;\n    char *acl = NULL;\n    int r = 0;\n\n    r = mboxlist_create_namecheck(name, userid, auth_state,\n                                  isadmin, forceuser);\n    if (r) goto done;\n\n    if (newacl) {\n        r = mboxlist_create_acl(name, &acl);\n        if (r) goto done;\n    }\n\n    if (newpartition) {\n        r = mboxlist_create_partition(name, partition, &part);\n        if (r) goto done;\n    }\n\n done:\n    if (r || !newacl) free(acl);\n    else *newacl = acl;\n\n    if (r || !newpartition) free(part);\n    else *newpartition = part;\n\n    return r;\n}\n\n/*\n * Create a mailbox\n *\n * 1. verify ACL's to best of ability (CRASH: abort)\n * 2. verify parent ACL's if need to\n * 3. create the local mailbox locally (exclusive lock) and keep it locked\n * 4. open mupdate connection if necessary\n * 5. create mupdate entry (CRASH: mupdate inconsistant)\n *\n */\n\nstatic int mboxlist_createmailbox_full(const char *mboxname, int mbtype,\n                                const char *partition,\n                                int isadmin, const char *userid,\n                                const struct auth_state *auth_state,\n                                int options, unsigned uidvalidity,\n                                modseq_t highestmodseq,\n                                const char *copyacl, const char *uniqueid,\n                                int localonly, int forceuser, int dbonly,\n                                struct mailbox **mboxptr)\n{\n    int r;\n    char *newpartition = NULL;\n    char *acl = NULL;\n    struct mailbox *newmailbox = NULL;\n    int isremote = mbtype & MBTYPE_REMOTE;\n    mbentry_t *newmbentry = NULL;\n\n    r = mboxlist_create_namecheck(mboxname, userid, auth_state,\n                                  isadmin, forceuser);\n    if (r) goto done;\n\n    if (copyacl) {\n        acl = xstrdup(copyacl);\n    }\n    else {\n        r = mboxlist_create_acl(mboxname, &acl);\n        if (r) goto done;\n    }\n\n    r = mboxlist_create_partition(mboxname, partition, &newpartition);\n    if (r) goto done;\n\n    if (!dbonly && !isremote) {\n        /* Filesystem Operations */\n        r = mailbox_create(mboxname, mbtype, newpartition, acl, uniqueid,\n                           options, uidvalidity, highestmodseq, &newmailbox);\n        if (r) goto done; /* CREATE failed */\n        r = mailbox_add_conversations(newmailbox);\n        if (r) goto done;\n    }\n\n    /* all is well - activate the mailbox */\n    newmbentry = mboxlist_entry_create();\n    newmbentry->acl = xstrdupnull(acl);\n    newmbentry->mbtype = mbtype;\n    newmbentry->partition = xstrdupnull(newpartition);\n    if (newmailbox) {\n        newmbentry->uniqueid = xstrdupnull(newmailbox->uniqueid);\n        newmbentry->uidvalidity = newmailbox->i.uidvalidity;\n        newmbentry->foldermodseq = newmailbox->i.highestmodseq;\n    }\n    r = mboxlist_update_entry(mboxname, newmbentry, NULL);\n\n    if (r) {\n        syslog(LOG_ERR, \"DBERROR: failed to insert to mailboxes list %s: %s\",\n               mboxname, cyrusdb_strerror(r));\n        r = IMAP_IOERROR;\n    }\n\n    /* 9. set MUPDATE entry as commited (CRASH: commited) */\n    if (!r && config_mupdate_server && !localonly) {\n        mupdate_handle *mupdate_h = NULL;\n        char *loc = strconcat(config_servername, \"!\", newpartition, (char *)NULL);\n\n        r = mupdate_connect(config_mupdate_server, NULL, &mupdate_h, NULL);\n        if (!r) r = mupdate_reserve(mupdate_h, mboxname, loc);\n        if (!r) r = mupdate_activate(mupdate_h, mboxname, loc, acl);\n        if (r) {\n            syslog(LOG_ERR, \"MUPDATE: can't commit mailbox entry for '%s'\",\n                   mboxname);\n            mboxlist_update_entry(mboxname, NULL, 0);\n        }\n        if (mupdate_h) mupdate_disconnect(&mupdate_h);\n        free(loc);\n    }\n\ndone:\n    if (newmailbox) {\n        if (r) mailbox_delete(&newmailbox);\n        else if (mboxptr) *mboxptr = newmailbox;\n        else mailbox_close(&newmailbox);\n    }\n\n    free(acl);\n    free(newpartition);\n    mboxlist_entry_free(&newmbentry);\n\n    return r;\n}\n\nEXPORTED int mboxlist_createmailbox(const char *name, int mbtype,\n                           const char *partition,\n                           int isadmin, const char *userid,\n                           const struct auth_state *auth_state,\n                           int localonly, int forceuser, int dbonly,\n                           int notify, struct mailbox **mailboxptr)\n{\n    int options = config_getint(IMAPOPT_MAILBOX_DEFAULT_OPTIONS)\n                  | OPT_POP3_NEW_UIDL;\n    int r;\n    struct mailbox *mailbox = NULL;\n    uint32_t uidvalidity = 0;\n\n    /* check if a previous deleted mailbox existed */\n    mbentry_t *oldmbentry = NULL;\n    r = mboxlist_lookup_allow_all(name, &oldmbentry, NULL);\n    if (!r && oldmbentry->mbtype == MBTYPE_DELETED) {\n        /* then the UIDVALIDITY must be higher than before */\n        if (uidvalidity <= oldmbentry->uidvalidity)\n            uidvalidity = oldmbentry->uidvalidity+1;\n    }\n    mboxlist_entry_free(&oldmbentry);\n\n    r = mboxlist_createmailbox_full(name, mbtype, partition,\n                                    isadmin, userid, auth_state,\n                                    options, uidvalidity, 0, NULL, NULL, localonly,\n                                    forceuser, dbonly, &mailbox);\n\n    if (notify && !r) {\n        /* send a MailboxCreate event notification */\n        struct mboxevent *mboxevent = mboxevent_new(EVENT_MAILBOX_CREATE);\n        mboxevent_extract_mailbox(mboxevent, mailbox);\n        mboxevent_set_access(mboxevent, NULL, NULL, userid, mailbox->name, 1);\n\n        mboxevent_notify(&mboxevent);\n        mboxevent_free(&mboxevent);\n    }\n\n    if (mailboxptr && !r) *mailboxptr = mailbox;\n    else mailbox_close(&mailbox);\n\n    return r;\n}\n\nEXPORTED int mboxlist_createsync(const char *name, int mbtype,\n                        const char *partition,\n                        const char *userid, const struct auth_state *auth_state,\n                        int options, unsigned uidvalidity,\n                        modseq_t highestmodseq,\n                        const char *acl, const char *uniqueid,\n                        int local_only, struct mailbox **mboxptr)\n{\n    return mboxlist_createmailbox_full(name, mbtype, partition,\n                                       1, userid, auth_state,\n                                       options, uidvalidity,\n                                       highestmodseq, acl, uniqueid,\n                                       local_only, 1, 0, mboxptr);\n}\n\n/* insert an entry for the proxy */\nEXPORTED int mboxlist_insertremote(mbentry_t *mbentry,\n                          struct txn **txn)\n{\n    int r = 0;\n\n    if (mbentry->server) {\n        /* remote mailbox */\n        if (config_mupdate_config == IMAP_ENUM_MUPDATE_CONFIG_UNIFIED &&\n            !strcasecmp(mbentry->server, config_servername)) {\n            /* its on our server, make it a local mailbox */\n            mbentry->mbtype &= ~MBTYPE_REMOTE;\n            mbentry->server = NULL;\n        }\n        else {\n            /* make sure it's a remote mailbox */\n            mbentry->mbtype |= MBTYPE_REMOTE;\n        }\n    }\n\n    /* database put */\n    r = mboxlist_update_entry(mbentry->name, mbentry, txn);\n\n    switch (r) {\n    case CYRUSDB_OK:\n        break;\n    case CYRUSDB_AGAIN:\n        abort(); /* shouldn't happen ! */\n        break;\n    default:\n        syslog(LOG_ERR, \"DBERROR: error updating database %s: %s\",\n               mbentry->name, cyrusdb_strerror(r));\n        r = IMAP_IOERROR;\n        break;\n    }\n\n    return r;\n}\n\n/* Special function to delete a remote mailbox.\n * Only affects mboxlist.\n * Assumes admin powers. */\nEXPORTED int mboxlist_deleteremote(const char *name, struct txn **in_tid)\n{\n    int r;\n    struct txn **tid;\n    struct txn *lcl_tid = NULL;\n    mbentry_t *mbentry = NULL;\n\n    if(in_tid) {\n        tid = in_tid;\n    } else {\n        tid = &lcl_tid;\n    }\n\n retry:\n    r = mboxlist_mylookup(name, &mbentry, tid, 1);\n    switch (r) {\n    case 0:\n        break;\n\n    case IMAP_MAILBOX_NONEXISTENT:\n        r = 0;\n        break;\n\n    case IMAP_AGAIN:\n        goto retry;\n        break;\n\n    default:\n        goto done;\n    }\n\n    if (mbentry && (mbentry->mbtype & MBTYPE_REMOTE) && !mbentry->server) {\n        syslog(LOG_ERR,\n               \"mboxlist_deleteremote called on non-remote mailbox: %s\",\n               name);\n        goto done;\n    }\n\n    r = mboxlist_update_entry(name, NULL, tid);\n    if (r) {\n        syslog(LOG_ERR, \"DBERROR: error deleting %s: %s\",\n               name, cyrusdb_strerror(r));\n        r = IMAP_IOERROR;\n    }\n\n    /* commit db operations, but only if we weren't passed a transaction */\n    if (!in_tid) {\n        r = cyrusdb_commit(mbdb, *tid);\n        if (r) {\n            syslog(LOG_ERR, \"DBERROR: failed on commit: %s\",\n                   cyrusdb_strerror(r));\n            r = IMAP_IOERROR;\n        }\n        tid = NULL;\n    }\n\n done:\n    if (r && !in_tid && tid) {\n        /* Abort the transaction if it is still in progress */\n        cyrusdb_abort(mbdb, *tid);\n    }\n\n    return r;\n}\n\nstatic int addmbox_to_list(const mbentry_t *mbentry, void *rock)\n{\n    strarray_t *list = (strarray_t *)rock;\n    strarray_append(list, mbentry->name);\n    return 0;\n}\n\n/*\n * Delayed Delete a mailbox: translate delete into rename\n */\nEXPORTED int\nmboxlist_delayed_deletemailbox(const char *name, int isadmin,\n                               const char *userid,\n                               const struct auth_state *auth_state,\n                               struct mboxevent *mboxevent,\n                               int checkacl,\n                               int localonly,\n                               int force)\n{\n    mbentry_t *mbentry = NULL;\n    strarray_t existing = STRARRAY_INITIALIZER;\n    int i;\n    char newname[MAX_MAILBOX_BUFFER];\n    int r = 0;\n    long myrights;\n\n    if (!isadmin && force) return IMAP_PERMISSION_DENIED;\n\n    /* delete of a user.X folder */\n    mbname_t *mbname = mbname_from_intname(name);\n    if (mbname_userid(mbname) && !strarray_size(mbname_boxes(mbname))) {\n        /* Can't DELETE INBOX (your own inbox) */\n        if (!strcmpsafe(mbname_userid(mbname), userid)) {\n            r = IMAP_MAILBOX_NOTSUPPORTED;\n            goto done;\n        }\n        /* Only admins may delete user */\n        if (!isadmin) {\n            r = IMAP_PERMISSION_DENIED;\n            goto done;\n        }\n    }\n\n    if (!isadmin && mbname_userid(mbname)) {\n        struct buf attrib = BUF_INITIALIZER;\n        annotatemore_lookup(mbname_intname(mbname), \"/specialuse\", mbname_userid(mbname), &attrib);\n        if (attrib.len)\n            r = IMAP_MAILBOX_SPECIALUSE;\n        buf_free(&attrib);\n        if (r) goto done;\n    }\n\n    r = mboxlist_lookup(name, &mbentry, NULL);\n    if (r) goto done;\n\n    /* check if user has Delete right (we've already excluded non-admins\n     * from deleting a user mailbox) */\n    if (checkacl) {\n        myrights = cyrus_acl_myrights(auth_state, mbentry->acl);\n        if (!(myrights & ACL_DELETEMBOX)) {\n            /* User has admin rights over their own mailbox namespace */\n            if (mboxname_userownsmailbox(userid, name) &&\n                (config_implicitrights & ACL_ADMIN)) {\n                isadmin = 1;\n            }\n\n            /* Lie about error if privacy demands */\n            r = (isadmin || (myrights & ACL_LOOKUP)) ?\n                IMAP_PERMISSION_DENIED : IMAP_MAILBOX_NONEXISTENT;\n\n            goto done;\n        }\n    }\n\n    /* check if there are already too many! */\n    mboxname_todeleted(name, newname, 0);\n    r = mboxlist_mboxtree(newname, addmbox_to_list, &existing, MBOXTREE_SKIP_ROOT);\n    if (r) goto done;\n\n    /* keep the last 19, so the new one is the 20th */\n    for (i = 0; i < (int)existing.count - 19; i++) {\n        const char *subname = strarray_nth(&existing, i);\n        syslog(LOG_NOTICE, \"too many subfolders for %s, deleting %s (%d / %d)\",\n               newname, subname, i+1, (int)existing.count);\n        r = mboxlist_deletemailbox(subname, 1, userid, auth_state, NULL, 0, 1, 1);\n        if (r) goto done;\n    }\n\n    /* get the deleted name */\n    mboxname_todeleted(name, newname, 1);\n\n    /* Get mboxlist_renamemailbox to do the hard work. No ACL checks needed */\n    r = mboxlist_renamemailbox((char *)name, newname, mbentry->partition,\n                               0 /* uidvalidity */,\n                               1 /* isadmin */, userid,\n                               auth_state,\n                               mboxevent,\n                               localonly /* local_only */,\n                               force, 1);\n\ndone:\n    strarray_fini(&existing);\n    mboxlist_entry_free(&mbentry);\n    mbname_free(&mbname);\n\n    return r;\n}\n\n/*\n * Delete a mailbox.\n * Deleting the mailbox user.FOO may only be performed by an admin.\n *\n * 1. Begin transaction\n * 2. Verify ACL's\n * 3. remove from database\n * 4. remove from disk\n * 5. commit transaction\n * 6. Open mupdate connection if necessary\n * 7. delete from mupdate\n *\n */\nEXPORTED int mboxlist_deletemailbox(const char *name, int isadmin,\n                                    const char *userid,\n                                    const struct auth_state *auth_state,\n                                    struct mboxevent *mboxevent,\n                                    int checkacl,\n                                    int local_only, int force)\n{\n    mbentry_t *mbentry = NULL;\n    int r = 0;\n    long myrights;\n    struct mailbox *mailbox = NULL;\n    int isremote = 0;\n    mupdate_handle *mupdate_h = NULL;\n\n    if (!isadmin && force) return IMAP_PERMISSION_DENIED;\n\n    /* delete of a user.X folder */\n    mbname_t *mbname = mbname_from_intname(name);\n    if (mbname_userid(mbname) && !strarray_size(mbname_boxes(mbname))) {\n        /* Can't DELETE INBOX (your own inbox) */\n        if (!strcmpsafe(mbname_userid(mbname), userid)) {\n            r = IMAP_MAILBOX_NOTSUPPORTED;\n            goto done;\n        }\n        /* Only admins may delete user */\n        if (!isadmin) {\n            r = IMAP_PERMISSION_DENIED;\n            goto done;\n        }\n    }\n\n    if (!isadmin && mbname_userid(mbname)) {\n        struct buf attrib = BUF_INITIALIZER;\n        annotatemore_lookup(mbname_intname(mbname), \"/specialuse\", mbname_userid(mbname), &attrib);\n        if (attrib.len)\n            r = IMAP_MAILBOX_SPECIALUSE;\n        buf_free(&attrib);\n        if (r) goto done;\n    }\n\n    r = mboxlist_lookup_allow_all(name, &mbentry, NULL);\n    if (r) goto done;\n\n    isremote = mbentry->mbtype & MBTYPE_REMOTE;\n\n    /* check if user has Delete right (we've already excluded non-admins\n     * from deleting a user mailbox) */\n    if (checkacl) {\n        myrights = cyrus_acl_myrights(auth_state, mbentry->acl);\n        if(!(myrights & ACL_DELETEMBOX)) {\n            /* User has admin rights over their own mailbox namespace */\n            if (mboxname_userownsmailbox(userid, name) &&\n                (config_implicitrights & ACL_ADMIN)) {\n                isadmin = 1;\n            }\n\n            /* Lie about error if privacy demands */\n            r = (isadmin || (myrights & ACL_LOOKUP)) ?\n                IMAP_PERMISSION_DENIED : IMAP_MAILBOX_NONEXISTENT;\n            goto done;\n        }\n    }\n\n    /* Lock the mailbox if it isn't a remote mailbox */\n    if (!isremote) {\n        r = mailbox_open_iwl(name, &mailbox);\n    }\n    if (r && !force) goto done;\n\n    /* remove from mupdate */\n    if (!isremote && !local_only && config_mupdate_server) {\n        /* delete the mailbox in MUPDATE */\n        r = mupdate_connect(config_mupdate_server, NULL, &mupdate_h, NULL);\n        if (r) {\n            syslog(LOG_ERR,\n                   \"cannot connect to mupdate server for delete of '%s'\",\n                   name);\n            goto done;\n        }\n        r = mupdate_delete(mupdate_h, name);\n        if(r) {\n            syslog(LOG_ERR,\n                   \"MUPDATE: can't delete mailbox entry '%s'\", name);\n        }\n        if (mupdate_h) mupdate_disconnect(&mupdate_h);\n    }\n    if (r && !force) goto done;\n\n    if (!isremote && !mboxname_isdeletedmailbox(name, NULL)) {\n        /* store a DELETED marker */\n        mbentry_t *newmbentry = mboxlist_entry_create();\n        newmbentry->name = xstrdupnull(name);\n        newmbentry->mbtype = MBTYPE_DELETED;\n        if (mailbox) {\n            newmbentry->uniqueid = xstrdupnull(mailbox->uniqueid);\n            newmbentry->uidvalidity = mailbox->i.uidvalidity;\n            newmbentry->foldermodseq = mailbox_modseq_dirty(mailbox);\n        }\n        r = mboxlist_update(newmbentry, /*localonly*/1);\n        mboxlist_entry_free(&newmbentry);\n    }\n    else {\n        /* delete entry (including DELETED.* mailboxes, no need\n         * to keep that rubbish around) */\n        r = mboxlist_update_entry(name, NULL, 0);\n        if (r) {\n            syslog(LOG_ERR, \"DBERROR: error deleting %s: %s\",\n                   name, cyrusdb_strerror(r));\n            r = IMAP_IOERROR;\n            if (!force) goto done;\n        }\n        if (r && !force) goto done;\n    }\n\n    /* delete underlying mailbox */\n    if (!isremote && mailbox) {\n        /* only on a real delete do we delete from the remote end as well */\n        sync_log_unmailbox(mailbox->name);\n        mboxevent_extract_mailbox(mboxevent, mailbox);\n        mboxevent_set_access(mboxevent, NULL, NULL, userid, mailbox->name, 1);\n\n        r = mailbox_delete(&mailbox);\n        /* abort event notification */\n        if (r && mboxevent)\n            mboxevent_free(&mboxevent);\n    }\n\n done:\n    mailbox_close(&mailbox);\n    mboxlist_entry_free(&mbentry);\n    mbname_free(&mbname);\n\n    return r;\n}\n\nstatic int _rename_check_specialuse(const char *oldname, const char *newname)\n{\n    mbname_t *old = mbname_from_intname(oldname);\n    mbname_t *new = mbname_from_intname(newname);\n    struct buf attrib = BUF_INITIALIZER;\n    int r = 0;\n    if (mbname_userid(old))\n        annotatemore_lookup(oldname, \"/specialuse\", mbname_userid(old), &attrib);\n    /* we have specialuse? */\n    if (attrib.len) {\n        /* then target must be a single-depth mailbox too */\n        if (strarray_size(mbname_boxes(new)) != 1)\n            r = IMAP_MAILBOX_SPECIALUSE;\n        /* and have a userid as well */\n        if (!mbname_userid(new))\n            r = IMAP_MAILBOX_SPECIALUSE;\n        /* and not be deleted */\n        if (mbname_isdeleted(new))\n            r = IMAP_MAILBOX_SPECIALUSE;\n    }\n    mbname_free(&new);\n    mbname_free(&old);\n    buf_free(&attrib);\n    return r;\n}\n\n/*\n * Rename/move a single mailbox (recursive renames are handled at a\n * higher level).  This only supports local mailboxes.  Remote\n * mailboxes are handled up in imapd.c\n */\nEXPORTED int mboxlist_renamemailbox(const char *oldname, const char *newname,\n                           const char *partition, unsigned uidvalidity,\n                           int isadmin, const char *userid,\n                           const struct auth_state *auth_state,\n                           struct mboxevent *mboxevent,\n                           int local_only, int forceuser, int ignorequota)\n{\n    int r;\n    int mupdatecommiterror = 0;\n    long myrights;\n    int isusermbox = 0; /* Are we renaming someone's inbox */\n    int partitionmove = 0;\n    struct mailbox *oldmailbox = NULL;\n    struct mailbox *newmailbox = NULL;\n    struct txn *tid = NULL;\n    const char *root = NULL;\n    char *newpartition = NULL;\n    mupdate_handle *mupdate_h = NULL;\n    mbentry_t *newmbentry = NULL;\n\n    /* 1. open mailbox */\n    r = mailbox_open_iwl(oldname, &oldmailbox);\n    if (r) return r;\n\n    myrights = cyrus_acl_myrights(auth_state, oldmailbox->acl);\n\n    /* check the ACLs up-front */\n    if (!isadmin) {\n        if (!(myrights & ACL_DELETEMBOX)) {\n            r = (myrights & ACL_LOOKUP) ?\n                IMAP_PERMISSION_DENIED : IMAP_MAILBOX_NONEXISTENT;\n            goto done;\n        }\n    }\n\n    /* 2. verify valid move */\n    /* XXX - handle remote mailbox */\n\n    /* special case: same mailbox, must be a partition move */\n    if (!strcmp(oldname, newname)) {\n        const char *oldpath = mailbox_datapath(oldmailbox, 0);\n\n        /* Only admin can move mailboxes between partitions */\n        if (!isadmin) {\n            r = IMAP_PERMISSION_DENIED;\n            goto done;\n        }\n\n        /* No partition, we're definitely not moving anywhere */\n        if (!partition) {\n            r = IMAP_MAILBOX_EXISTS;\n            goto done;\n        }\n\n        /* let mupdate code below know it was a partition move */\n        partitionmove = 1;\n\n        /* this is OK because it uses a different static buffer */\n        root = config_partitiondir(partition);\n        if (!root) {\n            r = IMAP_PARTITION_UNKNOWN;\n            goto done;\n        }\n        if (!strncmp(root, oldpath, strlen(root)) &&\n            oldpath[strlen(root)] == '/') {\n            /* partitions are the same or share common prefix */\n            r = IMAP_MAILBOX_EXISTS;\n            goto done;\n        }\n\n        /* NOTE: this is a rename to the same mailbox name on a\n         * different partition.  This is a pretty filthy hack,\n         * which should be handled by having four totally different\n         * codepaths: INBOX -> INBOX.foo, user rename, regular rename\n         * and of course this one, partition move */\n        newpartition = xstrdup(partition);\n        r = mailbox_copy_files(oldmailbox, newpartition, newname, oldmailbox->uniqueid);\n        if (r) goto done;\n        newmbentry = mboxlist_entry_create();\n        newmbentry->mbtype = oldmailbox->mbtype;\n        newmbentry->partition = xstrdupnull(newpartition);\n        newmbentry->acl = xstrdupnull(oldmailbox->acl);\n        newmbentry->uidvalidity = oldmailbox->i.uidvalidity;\n        newmbentry->uniqueid = xstrdupnull(oldmailbox->uniqueid);\n        newmbentry->foldermodseq = oldmailbox->i.highestmodseq; /* bump regardless, it's rare */\n\n        r = mboxlist_update_entry(newname, newmbentry, &tid);\n        if (r) goto done;\n\n        /* skip ahead to the commit */\n        goto dbdone;\n    }\n\n    if (!isadmin) {\n        r = _rename_check_specialuse(oldname, newname);\n        if (r) goto done;\n    }\n\n    /* RENAME of some user's INBOX */\n    if (mboxname_isusermailbox(oldname, 1)) {\n        if (mboxname_isdeletedmailbox(newname, NULL)) {\n            /* delete user is OK */\n        }\n        else if (mboxname_isusermailbox(newname, 1)) {\n            /* user rename is depends on config */\n            if (!config_getswitch(IMAPOPT_ALLOWUSERMOVES)) {\n                r = IMAP_MAILBOX_NOTSUPPORTED;\n                goto done;\n            }\n        }\n        else if (mboxname_userownsmailbox(userid, oldname) &&\n                 mboxname_userownsmailbox(userid, newname)) {\n            /* Special case of renaming inbox */\n            isusermbox = 1;\n        }\n        else {\n            /* Everything else is bogus */\n            r = IMAP_MAILBOX_NOTSUPPORTED;\n            goto done;\n        }\n    }\n\n    r = mboxlist_create_namecheck(newname, userid, auth_state,\n                                  isadmin, forceuser);\n    if (r) goto done;\n\n    r = mboxlist_create_partition(newname, partition, &newpartition);\n    if (r) goto done;\n\n    if (!newpartition) newpartition = xstrdup(config_defpartition);\n\n    /* keep uidvalidity on rename unless specified */\n    if (!uidvalidity)\n        uidvalidity = oldmailbox->i.uidvalidity;\n\n    /* Rename the actual mailbox */\n    r = mailbox_rename_copy(oldmailbox, newname, newpartition, uidvalidity,\n                            isusermbox ? userid : NULL, ignorequota,\n                            &newmailbox);\n\n    if (r) goto done;\n\n    syslog(LOG_INFO, \"Rename: %s -> %s\", oldname, newname);\n\n    /* create new entry */\n    newmbentry = mboxlist_entry_create();\n    newmbentry->name = xstrdupnull(newmailbox->name);\n    newmbentry->mbtype = newmailbox->mbtype;\n    newmbentry->partition = xstrdupnull(newmailbox->part);\n    newmbentry->acl = xstrdupnull(newmailbox->acl);\n    newmbentry->uidvalidity = newmailbox->i.uidvalidity;\n    newmbentry->uniqueid = xstrdupnull(newmailbox->uniqueid);\n    newmbentry->foldermodseq = newmailbox->i.highestmodseq;\n\n    do {\n        r = 0;\n\n        /* delete the old entry */\n        if (!isusermbox) {\n            /* store a DELETED marker */\n            mbentry_t *oldmbentry = mboxlist_entry_create();\n            oldmbentry->name = xstrdupnull(oldmailbox->name);\n            oldmbentry->mbtype = MBTYPE_DELETED;\n            oldmbentry->uidvalidity = oldmailbox->i.uidvalidity;\n            oldmbentry->uniqueid = xstrdupnull(oldmailbox->uniqueid);\n            oldmbentry->foldermodseq = mailbox_modseq_dirty(oldmailbox);\n\n            r = mboxlist_update_entry(oldname, oldmbentry, &tid);\n\n            mboxlist_entry_free(&oldmbentry);\n        }\n\n        /* create a new entry */\n        if (!r) {\n            r = mboxlist_update_entry(newname, newmbentry, &tid);\n        }\n\n        switch (r) {\n        case 0: /* success */\n            break;\n        case CYRUSDB_AGAIN:\n            tid = NULL;\n            break;\n        default:\n            syslog(LOG_ERR, \"DBERROR: rename failed on store %s %s: %s\",\n                   oldname, newname, cyrusdb_strerror(r));\n            r = IMAP_IOERROR;\n            goto done;\n            break;\n        }\n    } while (r == CYRUSDB_AGAIN);\n\n dbdone:\n\n    /* 3. Commit transaction */\n    r = cyrusdb_commit(mbdb, tid);\n    tid = NULL;\n    if (r) {\n        syslog(LOG_ERR, \"DBERROR: rename failed on commit %s %s: %s\",\n               oldname, newname, cyrusdb_strerror(r));\n        r = IMAP_IOERROR;\n        goto done;\n    }\n\n    if (!local_only && config_mupdate_server) {\n        /* commit the mailbox in MUPDATE */\n        char *loc = strconcat(config_servername, \"!\", newpartition, (char *)NULL);\n\n        r = mupdate_connect(config_mupdate_server, NULL, &mupdate_h, NULL);\n        if (!partitionmove) {\n            if (!r && !isusermbox)\n                r = mupdate_delete(mupdate_h, oldname);\n            if (!r) r = mupdate_reserve(mupdate_h, newname, loc);\n        }\n        if (!r) r = mupdate_activate(mupdate_h, newname, loc, newmbentry->acl);\n        if (r) {\n            syslog(LOG_ERR,\n                   \"MUPDATE: can't commit mailbox entry for '%s'\",\n                   newname);\n            mupdatecommiterror = r;\n        }\n        if (mupdate_h) mupdate_disconnect(&mupdate_h);\n        free(loc);\n    }\n\n done: /* Commit or cleanup */\n    if (!r && newmailbox)\n        r = mailbox_commit(newmailbox);\n\n    if (r) {\n        /* rollback DB changes if it was an mupdate failure */\n        if (mupdatecommiterror) {\n            r = 0;\n\n            /* recreate an old entry */\n            if (!isusermbox)\n                r = mboxlist_update_entry(oldname, newmbentry, &tid);\n\n            /* delete the new entry */\n            if (!r)\n                r = mboxlist_update_entry(newname, NULL, &tid);\n\n            /* Commit transaction */\n            if (!r)\n                r = cyrusdb_commit(mbdb, tid);\n\n            tid = NULL;\n            if (r) {\n                /* XXX HOWTO repair this mess! */\n                syslog(LOG_ERR, \"DBERROR: failed DB rollback on mailboxrename %s %s: %s\",\n                       oldname, newname, cyrusdb_strerror(r));\n                syslog(LOG_ERR, \"DBERROR: mailboxdb on mupdate and backend ARE NOT CONSISTENT\");\n                syslog(LOG_ERR, \"DBERROR: mailboxdb on mupdate has entry for %s, mailboxdb on backend has entry for %s and files are on the old position\", oldname, newname);\n                r = IMAP_IOERROR;\n            } else {\n                r = mupdatecommiterror;\n            }\n        }\n\n        if (newmailbox) mailbox_delete(&newmailbox);\n        if (partitionmove && newpartition)\n            mailbox_delete_cleanup(NULL, newpartition, newname, oldmailbox->uniqueid);\n        mailbox_close(&oldmailbox);\n    } else {\n        if (newmailbox) {\n            /* prepare the event notification */\n            if (mboxevent) {\n\n                /* case of delayed delete */\n                if (mboxevent->type == EVENT_MAILBOX_DELETE)\n                    mboxevent_extract_mailbox(mboxevent, oldmailbox);\n                else {\n                    mboxevent_extract_mailbox(mboxevent, newmailbox);\n                    mboxevent_extract_old_mailbox(mboxevent, oldmailbox);\n                }\n\n                mboxevent_set_access(mboxevent, NULL, NULL, userid, newmailbox->name, 1);\n            }\n\n            /* log the rename before we close either mailbox, so that\n             * we never nuke the mailbox from the replica before realising\n             * that it has been renamed.  This can be moved later again when\n             * we sync mailboxes by uniqueid rather than name... */\n            sync_log_mailbox_double(oldname, newname);\n\n            mailbox_rename_cleanup(&oldmailbox, isusermbox);\n\n#ifdef WITH_DAV\n            mailbox_add_dav(newmailbox);\n#endif\n\n            mailbox_close(&newmailbox);\n\n            /* and log an append so that squatter indexes it */\n            sync_log_append(newname);\n        }\n        else if (partitionmove) {\n            char *oldpartition = xstrdup(oldmailbox->part);\n            char *olduniqueid = xstrdup(oldmailbox->uniqueid);\n            if (config_auditlog)\n                syslog(LOG_NOTICE, \"auditlog: partitionmove sessionid=<%s> \"\n                       \"mailbox=<%s> uniqueid=<%s> oldpart=<%s> newpart=<%s>\",\n                       session_id(),\n                       oldmailbox->name, oldmailbox->uniqueid,\n                       oldpartition, partition);\n            /* this will sync-log the name anyway */\n            mailbox_close(&oldmailbox);\n            mailbox_delete_cleanup(NULL, oldpartition, oldname, olduniqueid);\n            free(olduniqueid);\n            free(oldpartition);\n        }\n        else\n            abort(); /* impossible, in theory */\n    }\n\n    /* free memory */\n    free(newpartition);\n    mboxlist_entry_free(&newmbentry);\n\n    return r;\n}\n\n/*\n * Check if the admin rights are present in the 'rights'\n */\nstatic int mboxlist_have_admin_rights(const char *rights) {\n    int access, have_admin_access;\n\n    cyrus_acl_strtomask(rights, &access);\n    have_admin_access = access & ACL_ADMIN;\n\n    return have_admin_access;\n}\n\n/*\n * Change the ACL for mailbox 'name' so that 'identifier' has the\n * rights enumerated in the string 'rights'.  If 'rights' is the null\n * pointer, removes the ACL entry for 'identifier'.   'isadmin' is\n * nonzero if user is a mailbox admin.  'userid' is the user's login id.\n *\n * 1. Start transaction\n * 2. Check rights\n * 3. Set db entry\n * 4. Change backup copy (cyrus.header)\n * 5. Commit transaction\n * 6. Change mupdate entry\n *\n */\nEXPORTED int mboxlist_setacl(const struct namespace *namespace __attribute__((unused)),\n                    const char *name,\n                    const char *identifier, const char *rights,\n                    int isadmin, const char *userid,\n                    const struct auth_state *auth_state)\n{\n    mbentry_t *mbentry = NULL;\n    int r;\n    int myrights;\n    int mode = ACL_MODE_SET;\n    int isusermbox = 0;\n    int isidentifiermbox = 0;\n    int anyoneuseracl = 1;\n    int ensure_owner_rights = 0;\n    int mask;\n    const char *mailbox_owner = NULL;\n    struct mailbox *mailbox = NULL;\n    char *newacl = NULL;\n    struct txn *tid = NULL;\n\n    /* round trip identifier to potentially strip domain */\n    mbname_t *mbname = mbname_from_userid(identifier);\n    /* XXX - enforce cross domain restrictions */\n    identifier = mbname_userid(mbname);\n\n    /* checks if the mailbox belongs to the user who is trying to change the\n       access rights */\n    if (mboxname_userownsmailbox(userid, name))\n        isusermbox = 1;\n    anyoneuseracl = config_getswitch(IMAPOPT_ANYONEUSERACL);\n\n    /* checks if the identifier is the mailbox owner */\n    if (mboxname_userownsmailbox(identifier, name))\n        isidentifiermbox = 1;\n\n    /* who is the mailbox owner? */\n    if (isusermbox) {\n        mailbox_owner = userid;\n    }\n    else if (isidentifiermbox) {\n        mailbox_owner = identifier;\n    }\n\n    /* ensure the access rights if the folder owner is the current user or\n       the identifier */\n    ensure_owner_rights = isusermbox || isidentifiermbox;\n\n    /* 1. Start Transaction */\n    /* lookup the mailbox to make sure it exists and get its acl */\n    do {\n        r = mboxlist_mylookup(name, &mbentry, &tid, 1);\n    } while(r == IMAP_AGAIN);\n\n    /* Can't do this to an in-transit or reserved mailbox */\n    if (!r && mbentry->mbtype & (MBTYPE_MOVING | MBTYPE_RESERVE | MBTYPE_DELETED)) {\n        r = IMAP_MAILBOX_NOTSUPPORTED;\n    }\n\n    /* if it is not a remote mailbox, we need to unlock the mailbox list,\n     * lock the mailbox, and re-lock the mailboxes list */\n    /* we must do this to obey our locking rules */\n    if (!r && !(mbentry->mbtype & MBTYPE_REMOTE)) {\n        cyrusdb_abort(mbdb, tid);\n        tid = NULL;\n        mboxlist_entry_free(&mbentry);\n\n        /* open & lock mailbox header */\n        r = mailbox_open_iwl(name, &mailbox);\n\n        if (!r) {\n            do {\n                /* lookup the mailbox to make sure it exists and get its acl */\n                r = mboxlist_mylookup(name, &mbentry, &tid, 1);\n            } while (r == IMAP_AGAIN);\n        }\n\n        if(r) goto done;\n    }\n\n    /* 2. Check Rights */\n    if (!r && !isadmin) {\n        myrights = cyrus_acl_myrights(auth_state, mbentry->acl);\n        if (!(myrights & ACL_ADMIN)) {\n            r = (myrights & ACL_LOOKUP) ?\n                IMAP_PERMISSION_DENIED : IMAP_MAILBOX_NONEXISTENT;\n            goto done;\n        }\n    }\n\n    /* 2.1 Only admin user can set 'anyone' rights if config says so */\n    if (!r && !isadmin && !anyoneuseracl && !strncmp(identifier, \"anyone\", 6)) {\n      r = IMAP_PERMISSION_DENIED;\n      goto done;\n    }\n\n    /* 3. Set DB Entry */\n    if(!r) {\n        /* Make change to ACL */\n        newacl = xstrdup(mbentry->acl);\n        if (rights && *rights) {\n            /* rights are present and non-empty */\n            mode = ACL_MODE_SET;\n            if (*rights == '+') {\n                rights++;\n                mode = ACL_MODE_ADD;\n            }\n            else if (*rights == '-') {\n                rights++;\n                mode = ACL_MODE_REMOVE;\n            }\n            /* do not allow non-admin user to remove the admin rights from mailbox owner */\n            if (!isadmin && isidentifiermbox && mode != ACL_MODE_ADD) {\n                int has_admin_rights = mboxlist_have_admin_rights(rights);\n                if ((has_admin_rights && mode == ACL_MODE_REMOVE) ||\n                   (!has_admin_rights && mode != ACL_MODE_REMOVE)) {\n                    syslog(LOG_ERR, \"Denied removal of admin rights on \"\n                           \"folder \\\"%s\\\" (owner: %s) by user \\\"%s\\\"\", name,\n                           mailbox_owner, userid);\n                    r = IMAP_PERMISSION_DENIED;\n                    goto done;\n                }\n            }\n\n            r = cyrus_acl_strtomask(rights, &mask);\n\n            if (!r && cyrus_acl_set(&newacl, identifier, mode, mask,\n                                    ensure_owner_rights ? mboxlist_ensureOwnerRights : 0,\n                                    (void *)mailbox_owner)) {\n                r = IMAP_INVALID_IDENTIFIER;\n            }\n        } else {\n            /* do not allow to remove the admin rights from mailbox owner */\n            if (!isadmin && isidentifiermbox) {\n                syslog(LOG_ERR, \"Denied removal of admin rights on \"\n                       \"folder \\\"%s\\\" (owner: %s) by user \\\"%s\\\"\", name,\n                       mailbox_owner, userid);\n                r = IMAP_PERMISSION_DENIED;\n                goto done;\n            }\n\n            if (cyrus_acl_remove(&newacl, identifier,\n                                 ensure_owner_rights ? mboxlist_ensureOwnerRights : 0,\n                                 (void *)mailbox_owner)) {\n                r = IMAP_INVALID_IDENTIFIER;\n            }\n        }\n    }\n\n    if (!r) {\n        /* ok, change the database */\n        free(mbentry->acl);\n        mbentry->acl = xstrdupnull(newacl);\n\n        r = mboxlist_update_entry(name, mbentry, &tid);\n\n        if (r) {\n            syslog(LOG_ERR, \"DBERROR: error updating acl %s: %s\",\n                   name, cyrusdb_strerror(r));\n            r = IMAP_IOERROR;\n        }\n\n        /* send a AclChange event notification */\n        struct mboxevent *mboxevent = mboxevent_new(EVENT_ACL_CHANGE);\n        mboxevent_extract_mailbox(mboxevent, mailbox);\n        mboxevent_set_acl(mboxevent, identifier, rights);\n        mboxevent_set_access(mboxevent, NULL, NULL, userid, mailbox->name, 0);\n\n        mboxevent_notify(&mboxevent);\n        mboxevent_free(&mboxevent);\n\n    }\n\n    /* 4. Change backup copy (cyrus.header) */\n    /* we already have it locked from above */\n    if (!r && !(mbentry->mbtype & MBTYPE_REMOTE)) {\n        mailbox_set_acl(mailbox, newacl, 1);\n        /* want to commit immediately to ensure ordering */\n        r = mailbox_commit(mailbox);\n    }\n\n    /* 5. Commit transaction */\n    if (!r) {\n        if((r = cyrusdb_commit(mbdb, tid)) != 0) {\n            syslog(LOG_ERR, \"DBERROR: failed on commit: %s\",\n                   cyrusdb_strerror(r));\n            r = IMAP_IOERROR;\n        }\n        tid = NULL;\n    }\n\n    /* 6. Change mupdate entry  */\n    if (!r && config_mupdate_server) {\n        mupdate_handle *mupdate_h = NULL;\n        /* commit the update to MUPDATE */\n        char buf[MAX_PARTITION_LEN + HOSTNAME_SIZE + 2];\n\n        snprintf(buf, sizeof(buf), \"%s!%s\", config_servername, mbentry->partition);\n\n        r = mupdate_connect(config_mupdate_server, NULL, &mupdate_h, NULL);\n        if(r) {\n            syslog(LOG_ERR,\n                   \"cannot connect to mupdate server for setacl on '%s'\",\n                   name);\n        } else {\n            r = mupdate_activate(mupdate_h, name, buf, newacl);\n            if(r) {\n                syslog(LOG_ERR,\n                       \"MUPDATE: can't update mailbox entry for '%s'\",\n                       name);\n            }\n        }\n        mupdate_disconnect(&mupdate_h);\n    }\n\n  done:\n    if (r && tid) {\n        /* if we are mid-transaction, abort it! */\n        int r2 = cyrusdb_abort(mbdb, tid);\n        if (r2) {\n            syslog(LOG_ERR,\n                   \"DBERROR: error aborting txn in mboxlist_setacl: %s\",\n                   cyrusdb_strerror(r2));\n        }\n    }\n    mailbox_close(&mailbox);\n    free(newacl);\n    mboxlist_entry_free(&mbentry);\n    mbname_free(&mbname);\n\n    return r;\n}\n\n/*\n * Change the ACL for mailbox 'name'.  We already have it locked\n * and have written the backup copy to the header, so there's\n * nothing left but to write the mailboxes.db.\n *\n * 1. Start transaction\n * 2. Set db entry\n * 3. Commit transaction\n * 4. Change mupdate entry\n *\n */\nEXPORTED int\nmboxlist_sync_setacls(const char *name, const char *newacl)\n{\n    mbentry_t *mbentry = NULL;\n    int r;\n    struct txn *tid = NULL;\n\n    /* 1. Start Transaction */\n    /* lookup the mailbox to make sure it exists and get its acl */\n    do {\n        r = mboxlist_mylookup(name, &mbentry, &tid, 1);\n    } while(r == IMAP_AGAIN);\n\n    /* Can't do this to an in-transit or reserved mailbox */\n    if (!r && mbentry->mbtype & (MBTYPE_MOVING | MBTYPE_RESERVE | MBTYPE_DELETED)) {\n        r = IMAP_MAILBOX_NOTSUPPORTED;\n    }\n\n    /* 2. Set DB Entry */\n    if (!r) {\n        /* ok, change the database */\n        free(mbentry->acl);\n        mbentry->acl = xstrdupnull(newacl);\n\n        r = mboxlist_update_entry(name, mbentry, &tid);\n\n        if (r) {\n            syslog(LOG_ERR, \"DBERROR: error updating acl %s: %s\",\n                   name, cyrusdb_strerror(r));\n            r = IMAP_IOERROR;\n        }\n    }\n\n    /* 3. Commit transaction */\n    if (!r) {\n        r = cyrusdb_commit(mbdb, tid);\n        if (r) {\n            syslog(LOG_ERR, \"DBERROR: failed on commit %s: %s\",\n                   name, cyrusdb_strerror(r));\n            r = IMAP_IOERROR;\n        }\n        tid = NULL;\n    }\n\n    /* 4. Change mupdate entry  */\n    if (!r && config_mupdate_server) {\n        mupdate_handle *mupdate_h = NULL;\n        /* commit the update to MUPDATE */\n        char buf[MAX_PARTITION_LEN + HOSTNAME_SIZE + 2];\n        sprintf(buf, \"%s!%s\", config_servername, mbentry->partition);\n\n        r = mupdate_connect(config_mupdate_server, NULL, &mupdate_h, NULL);\n        if (r) {\n            syslog(LOG_ERR,\n                   \"cannot connect to mupdate server for syncacl on '%s'\",\n                   name);\n        } else {\n            r = mupdate_activate(mupdate_h, name, buf, newacl);\n            if(r) {\n                syslog(LOG_ERR,\n                       \"MUPDATE: can't update mailbox entry for '%s'\",\n                       name);\n            }\n        }\n        mupdate_disconnect(&mupdate_h);\n    }\n\n    if (r && tid) {\n        /* if we are mid-transaction, abort it! */\n        int r2 = cyrusdb_abort(mbdb, tid);\n        if (r2) {\n            syslog(LOG_ERR,\n                   \"DBERROR: error aborting txn in sync_setacls %s: %s\",\n                   name, cyrusdb_strerror(r2));\n        }\n    }\n\n    mboxlist_entry_free(&mbentry);\n\n    return r;\n}\n\nstruct find_rock {\n    ptrarray_t globs;\n    struct namespace *namespace;\n    const char *userid;\n    const char *domain;\n    int mb_category;\n    int checkmboxlist;\n    int issubs;\n    int singlepercent;\n    struct db *db;\n    int isadmin;\n    const struct auth_state *auth_state;\n    mbname_t *mbname;\n    mbentry_t *mbentry;\n    int matchlen;\n    findall_cb *proc;\n    void *procrock;\n};\n\n/* return non-zero if we like this one */\nstatic int find_p(void *rockp,\n                  const char *key, size_t keylen,\n                  const char *data, size_t datalen)\n{\n    struct find_rock *rock = (struct find_rock *) rockp;\n    char intname[MAX_MAILBOX_PATH+1];\n    int i;\n\n    /* skip any $RACL or future $ space keys */\n    if (key[0] == '$') return 0;\n\n    memcpy(intname, key, keylen);\n    intname[keylen] = 0;\n\n    assert(!rock->mbname);\n    rock->mbname = mbname_from_intname(intname);\n\n    if (!rock->isadmin && !config_getswitch(IMAPOPT_CROSSDOMAINS)) {\n        /* don't list mailboxes outside of the default domain */\n        if (strcmpsafe(rock->domain, mbname_domain(rock->mbname)))\n            goto nomatch;\n    }\n\n    if (rock->mb_category && mbname_category(rock->mbname, rock->namespace, rock->userid) != rock->mb_category)\n        goto nomatch;\n\n    /* NOTE: this will all be cleaned up to be much more efficient sooner or later, with\n     * a mbname_t being kept inside the mbentry, and the extname cached all the way to\n     * final use.  For now, we pay the cost of re-calculating for simplicity of the\n     * changes to mbname_t itself */\n    const char *extname = mbname_extname(rock->mbname, rock->namespace, rock->userid);\n    if (!extname) goto nomatch;\n\n    int matchlen = 0;\n    for (i = 0; i < rock->globs.count; i++) {\n        glob *g = ptrarray_nth(&rock->globs, i);\n        int thismatch = glob_test(g, extname);\n        if (thismatch > matchlen) matchlen = thismatch;\n    }\n\n    /* If its not a match, skip it -- partial matches are ok. */\n    if (!matchlen) goto nomatch;\n\n    rock->matchlen = matchlen;\n\n    /* subs DB has empty keys */\n    if (rock->issubs)\n        goto good;\n\n    /* ignore entirely deleted records */\n    if (mboxlist_parse_entry(&rock->mbentry, key, keylen, data, datalen))\n        goto nomatch;\n\n    /* nobody sees tombstones */\n    if (rock->mbentry->mbtype & MBTYPE_DELETED)\n        goto nomatch;\n\n    /* check acl */\n    if (!rock->isadmin) {\n        /* always suppress deleted for non-admin */\n        if (mbname_isdeleted(rock->mbname)) goto nomatch;\n\n        /* check the acls */\n        if (!(cyrus_acl_myrights(rock->auth_state, rock->mbentry->acl) & ACL_LOOKUP)) goto nomatch;\n    }\n\ngood:\n    return 1;\n\nnomatch:\n    mboxlist_entry_free(&rock->mbentry);\n    mbname_free(&rock->mbname);\n    return 0;\n}\n\nstatic int find_cb(void *rockp,\n                   /* XXX - confirm these are the same?  - nah */\n                   const char *key __attribute__((unused)),\n                   size_t keylen __attribute__((unused)),\n                   const char *data __attribute__((unused)),\n                   size_t datalen __attribute__((unused)))\n{\n    struct find_rock *rock = (struct find_rock *) rockp;\n    char *testname = NULL;\n    int r = 0;\n    int i;\n\n    if (rock->checkmboxlist && !rock->mbentry) {\n        r = mboxlist_lookup(mbname_intname(rock->mbname), &rock->mbentry, NULL);\n        if (r) {\n            if (r == IMAP_MAILBOX_NONEXISTENT) r = 0;\n            goto done;\n        }\n    }\n\n    const char *extname = mbname_extname(rock->mbname, rock->namespace, rock->userid);\n    testname = xstrndup(extname, rock->matchlen);\n\n    struct findall_data fdata = { testname, rock->mb_category, rock->mbentry, NULL };\n\n    if (rock->singlepercent) {\n        char sep = rock->namespace->hier_sep;\n        char *p = testname;\n        /* we need to try all the previous names in order */\n        while ((p = strchr(p, sep)) != NULL) {\n            *p = '\\0';\n\n            /* only if this expression could fully match */\n            int matchlen = 0;\n            for (i = 0; i < rock->globs.count; i++) {\n                glob *g = ptrarray_nth(&rock->globs, i);\n                int thismatch = glob_test(g, testname);\n                if (thismatch > matchlen) matchlen = thismatch;\n            }\n\n            if (matchlen == (int)strlen(testname)) {\n                r = (*rock->proc)(&fdata, rock->procrock);\n                if (r) goto done;\n            }\n\n            /* replace the separator for the next longest name */\n            *p++ = sep;\n        }\n    }\n\n    /* mbname confirms that it's an exact match */\n    if (rock->matchlen == (int)strlen(extname))\n        fdata.mbname = rock->mbname;\n\n    r = (*rock->proc)(&fdata, rock->procrock);\n\n done:\n    free(testname);\n    mboxlist_entry_free(&rock->mbentry);\n    mbname_free(&rock->mbname);\n    return r;\n}\n\nstruct allmb_rock {\n    struct mboxlist_entry *mbentry;\n    int flags;\n    mboxlist_cb *proc;\n    void *rock;\n};\n\nstatic int allmbox_cb(void *rock,\n                      const char *key,\n                      size_t keylen,\n                      const char *data,\n                      size_t datalen)\n{\n    struct allmb_rock *mbrock = (struct allmb_rock *)rock;\n\n    if (!mbrock->mbentry) {\n        int r = mboxlist_parse_entry(&mbrock->mbentry, key, keylen, data, datalen);\n        if (r) return r;\n    }\n\n    return mbrock->proc(mbrock->mbentry, mbrock->rock);\n}\n\nstatic int allmbox_p(void *rock,\n                     const char *key,\n                     size_t keylen,\n                     const char *data,\n                     size_t datalen)\n{\n    struct allmb_rock *mbrock = (struct allmb_rock *)rock;\n    int r;\n\n    /* skip any dollar keys */\n    if (keylen && key[0] == '$') return 0;\n\n    /* free previous record */\n    mboxlist_entry_free(&mbrock->mbentry);\n\n    r = mboxlist_parse_entry(&mbrock->mbentry, key, keylen, data, datalen);\n    if (r) return 0;\n\n    if (!(mbrock->flags & MBOXTREE_TOMBSTONES) && (mbrock->mbentry->mbtype & MBTYPE_DELETED))\n        return 0;\n\n    return 1; /* process this record */\n}\n\nEXPORTED int mboxlist_allmbox(const char *prefix, mboxlist_cb *proc, void *rock, int incdel)\n{\n    struct allmb_rock mbrock = { NULL, 0, proc, rock };\n    int r = 0;\n\n    if (incdel) mbrock.flags |= MBOXTREE_TOMBSTONES;\n    if (!prefix) prefix = \"\";\n\n    r = cyrusdb_foreach(mbdb, prefix, strlen(prefix),\n                        allmbox_p, allmbox_cb, &mbrock, 0);\n\n    mboxlist_entry_free(&mbrock.mbentry);\n\n    return r;\n}\n\nEXPORTED int mboxlist_mboxtree(const char *mboxname, mboxlist_cb *proc, void *rock, int flags)\n{\n    struct allmb_rock mbrock = { NULL, flags, proc, rock };\n    int r = 0;\n\n    if (!(flags & MBOXTREE_SKIP_ROOT)) {\n        r = cyrusdb_forone(mbdb, mboxname, strlen(mboxname), allmbox_p, allmbox_cb, &mbrock, 0);\n        if (r) goto done;\n    }\n\n    if (!(flags & MBOXTREE_SKIP_CHILDREN)) {\n        char *prefix = strconcat(mboxname, \".\", (char *)NULL);\n        r = cyrusdb_foreach(mbdb, prefix, strlen(prefix), allmbox_p, allmbox_cb, &mbrock, 0);\n        free(prefix);\n        if (r) goto done;\n    }\n\n    if ((flags & MBOXTREE_DELETED)) {\n        struct buf buf = BUF_INITIALIZER;\n        const char *p = strchr(mboxname, '!');\n        const char *dp = config_getstring(IMAPOPT_DELETEDPREFIX);\n        if (p) {\n            buf_printf(&buf, \"%.*s!%s.%s\", (int)(p-mboxname), mboxname, dp, p+1);\n        }\n        else {\n            buf_printf(&buf, \"%s.%s\", dp, mboxname);\n        }\n        const char *prefix = buf_cstring(&buf);\n        r = cyrusdb_foreach(mbdb, prefix, strlen(prefix), allmbox_p, allmbox_cb, &mbrock, 0);\n        buf_free(&buf);\n        if (r) goto done;\n    }\n\n done:\n    mboxlist_entry_free(&mbrock.mbentry);\n    return r;\n}\n\nstatic int racls_del_cb(void *rock,\n                  const char *key, size_t keylen,\n                  const char *data __attribute__((unused)),\n                  size_t datalen __attribute__((unused)))\n{\n    struct txn **txn = (struct txn **)rock;\n    return cyrusdb_delete(mbdb, key, keylen, txn, /*force*/0);\n}\n\nstatic int racls_add_cb(const mbentry_t *mbentry, void *rock)\n{\n    struct txn **txn = (struct txn **)rock;\n    return mboxlist_update_racl(mbentry->name, NULL, mbentry, txn);\n}\n\nEXPORTED int mboxlist_set_racls(int enabled)\n{\n    struct txn *tid = NULL;\n    int r = 0;\n    int now = !cyrusdb_fetch(mbdb, \"$RACL\", 5, NULL, NULL, &tid);\n\n    if (now && !enabled) {\n        syslog(LOG_NOTICE, \"removing reverse acl support\");\n        /* remove */\n        r = cyrusdb_foreach(mbdb, \"$RACL\", 5, NULL, racls_del_cb, &tid, &tid);\n    }\n    else if (enabled && !now) {\n        /* add */\n        struct allmb_rock mbrock = { NULL, 0, racls_add_cb, &tid };\n        /* we can't use mboxlist_allmbox because it doesn't do transactions */\n        syslog(LOG_NOTICE, \"adding reverse acl support\");\n        r = cyrusdb_foreach(mbdb, \"\", 0, allmbox_p, allmbox_cb, &mbrock, &tid);\n        if (r) {\n            syslog(LOG_ERR, \"ERROR: failed to add reverse acl support %s\", error_message(r));\n        }\n        mboxlist_entry_free(&mbrock.mbentry);\n        if (!r) r = cyrusdb_store(mbdb, \"$RACL\", 5, \"\", 0, &tid);\n    }\n\n    if (r)\n        cyrusdb_abort(mbdb, tid);\n    else\n        cyrusdb_commit(mbdb, tid);\n\n    return r;\n}\n\n\nstruct alluser_rock {\n    char *prev;\n    user_cb *proc;\n    void *rock;\n};\n\nstatic int alluser_cb(const mbentry_t *mbentry, void *rock)\n{\n    struct alluser_rock *urock = (struct alluser_rock *)rock;\n    char *userid = mboxname_to_userid(mbentry->name);\n    int r = 0;\n\n    if (userid) {\n        if (strcmpsafe(urock->prev, userid)) {\n            r = urock->proc(userid, urock->rock);\n            free(urock->prev);\n            urock->prev = xstrdup(userid);\n        }\n        free(userid);\n    }\n\n    return r;\n}\n\nEXPORTED int mboxlist_alluser(user_cb *proc, void *rock)\n{\n    struct alluser_rock urock;\n    int r = 0;\n    urock.prev = NULL;\n    urock.proc = proc;\n    urock.rock = rock;\n    r = mboxlist_allmbox(NULL, alluser_cb, &urock, /*flags*/0);\n    free(urock.prev);\n    return r;\n}\n\nstruct raclrock {\n    int prefixlen;\n    strarray_t *list;\n};\n\nstatic int racl_cb(void *rock,\n                   const char *key, size_t keylen,\n                   const char *data __attribute__((unused)),\n                   size_t datalen __attribute__((unused)))\n{\n    struct raclrock *raclrock = (struct raclrock *)rock;\n    strarray_appendm(raclrock->list, xstrndup(key + raclrock->prefixlen, keylen - raclrock->prefixlen));\n    return 0;\n}\n\nEXPORTED int mboxlist_usermboxtree(const char *userid, mboxlist_cb *proc,\n                                   void *rock, int flags)\n{\n    char *inbox = mboxname_user_mbox(userid, 0);\n    int r = mboxlist_mboxtree(inbox, proc, rock, flags);\n\n    if (flags & MBOXTREE_PLUS_RACL) {\n        struct allmb_rock mbrock = { NULL, flags, proc, rock };\n        /* we're using reverse ACLs */\n        struct buf buf = BUF_INITIALIZER;\n        strarray_t matches = STRARRAY_INITIALIZER;\n\n        /* user items */\n        mboxlist_racl_key(1, userid, NULL, &buf);\n        /* this is the prefix */\n        struct raclrock raclrock = { buf.len, &matches };\n        /* we only need to look inside the prefix still, but we keep the length\n         * in raclrock pointing to the start of the mboxname part of the key so\n         * we get correct names in matches */\n        r = cyrusdb_foreach(mbdb, buf.s, buf.len, NULL, racl_cb, &raclrock, NULL);\n        buf_reset(&buf);\n\n        /* shared items */\n        mboxlist_racl_key(0, userid, NULL, &buf);\n        raclrock.prefixlen = buf.len;\n        if (!r) r = cyrusdb_foreach(mbdb, buf.s, buf.len, NULL, racl_cb, &raclrock, NULL);\n\n        /* XXX - later we need to sort the array when we've added groups */\n        int i;\n        for (i = 0; !r && i < strarray_size(&matches); i++) {\n            const char *mboxname = strarray_nth(&matches, i);\n            r = cyrusdb_forone(mbdb, mboxname, strlen(mboxname), allmbox_p, allmbox_cb, &mbrock, 0);\n        }\n        buf_free(&buf);\n        strarray_fini(&matches);\n        mboxlist_entry_free(&mbrock.mbentry);\n    }\n\n    free(inbox);\n    return r;\n}\n\nstatic int mboxlist_find_category(struct find_rock *rock, const char *prefix, size_t len)\n{\n    int r = 0;\n    if (!rock->issubs && !rock->isadmin && !cyrusdb_fetch(rock->db, \"$RACL\", 5, NULL, NULL, NULL)) {\n        /* we're using reverse ACLs */\n        struct buf buf = BUF_INITIALIZER;\n        strarray_t matches = STRARRAY_INITIALIZER;\n        mboxlist_racl_key(rock->mb_category == MBNAME_OTHERUSER, rock->userid, NULL, &buf);\n        /* this is the prefix */\n        struct raclrock raclrock = { buf.len, &matches };\n        /* we only need to look inside the prefix still, but we keep the length\n         * in raclrock pointing to the start of the mboxname part of the key so\n         * we get correct names in matches */\n        if (len) buf_appendmap(&buf, prefix, len);\n        r = cyrusdb_foreach(rock->db, buf.s, buf.len, NULL, racl_cb, &raclrock, NULL);\n        /* XXX - later we need to sort the array when we've added groups */\n        int i;\n        for (i = 0; !r && i < strarray_size(&matches); i++) {\n            const char *key = strarray_nth(&matches, i);\n            r = cyrusdb_forone(rock->db, key, strlen(key), &find_p, &find_cb, rock, NULL);\n        }\n        strarray_fini(&matches);\n    }\n    else {\n        r = cyrusdb_foreach(rock->db, prefix, len, &find_p, &find_cb, rock, NULL);\n    }\n\n    if (r == CYRUSDB_DONE) r = 0;\n    return r;\n}\n\n/*\n * Find all mailboxes that match 'pattern'.\n * 'isadmin' is nonzero if user is a mailbox admin.  'userid'\n * is the user's login id.  For each matching mailbox, calls\n * 'proc' with the name of the mailbox.  If 'proc' ever returns\n * a nonzero value, mboxlist_findall immediately stops searching\n * and returns that value.  'rock' is passed along as an argument to proc in\n * case it wants some persistant storage or extra data.\n */\n/* Find all mailboxes that match 'pattern'. */\n\nstatic int mboxlist_do_find(struct find_rock *rock, const strarray_t *patterns)\n{\n    const char *userid = rock->userid;\n    int isadmin = rock->isadmin;\n\n    int crossdomains = config_getswitch(IMAPOPT_CROSSDOMAINS);\n    char inbox[MAX_MAILBOX_BUFFER];\n    size_t inboxlen = 0;\n    size_t prefixlen, len;\n    size_t domainlen = 0;\n    size_t userlen = userid ? strlen(userid) : 0;\n    char domainpat[MAX_MAILBOX_BUFFER]; /* do intra-domain fetches only */\n    char commonpat[MAX_MAILBOX_BUFFER];\n    int r = 0;\n    int i;\n    const char *p;\n\n    if (patterns->count < 1) return 0; /* nothing to do */\n\n    for (i = 0; i < patterns->count; i++) {\n        glob *g = glob_init(strarray_nth(patterns, i), rock->namespace->hier_sep);\n        ptrarray_append(&rock->globs, g);\n    }\n\n    if (config_virtdomains && userid && (p = strchr(userid, '@'))) {\n        userlen = p - userid;\n        domainlen = strlen(p); /* includes separator */\n        snprintf(domainpat, sizeof(domainpat), \"%s!\", p+1);\n    }\n    else\n        domainpat[0] = '\\0';\n\n    /* calculate the inbox (with trailing .INBOX. for later use) */\n    if (userid && (!(p = strchr(userid, rock->namespace->hier_sep)) ||\n        ((p - userid) > (int)userlen)) &&\n        strlen(userid)+7 < MAX_MAILBOX_BUFFER) {\n        char *t, *tmpuser = NULL;\n        const char *inboxuser;\n\n        if (domainlen)\n            snprintf(inbox, sizeof(inbox), \"%s!\", userid+userlen+1);\n        if (rock->namespace->hier_sep == '/' && (p = strchr(userid, '.'))) {\n            tmpuser = xmalloc(userlen);\n            memcpy(tmpuser, userid, userlen);\n            t = tmpuser + (p - userid);\n            while(t < (tmpuser + userlen)) {\n                if (*t == '.')\n                    *t = '^';\n                t++;\n            }\n            inboxuser = tmpuser;\n        } else\n            inboxuser = userid;\n        snprintf(inbox+domainlen, sizeof(inbox)-domainlen,\n                 \"user.%.*s.INBOX.\", (int)userlen, inboxuser);\n        free(tmpuser);\n        inboxlen = strlen(inbox) - 7;\n    }\n    else {\n        userid = 0;\n    }\n\n    /* Find the common search prefix of all patterns */\n    const char *firstpat = strarray_nth(patterns, 0);\n    for (prefixlen = 0; firstpat[prefixlen]; prefixlen++) {\n        if (prefixlen >= MAX_MAILBOX_NAME) {\n            r = IMAP_MAILBOX_BADNAME;\n            goto done;\n        }\n        char c = firstpat[prefixlen];\n        for (i = 1; i < patterns->count; i++) {\n            const char *pat = strarray_nth(patterns, i);\n            if (pat[prefixlen] != c) break;\n        }\n        if (i < patterns->count) break;\n        if (c == '*' || c == '%' || c == '?') break;\n        commonpat[prefixlen] = c;\n    }\n    commonpat[prefixlen] = '\\0';\n\n    if (patterns->count == 1) {\n        /* Skip pattern which matches shared namespace prefix */\n        if (!strcmp(firstpat+prefixlen, \"%\"))\n            rock->singlepercent = 2;\n        /* output prefix regardless */\n        if (!strcmp(firstpat+prefixlen, \"*%\"))\n            rock->singlepercent = 1;\n    }\n\n    /*\n     * Personal (INBOX) namespace (only if not admin)\n     */\n    if (userid && !isadmin) {\n        /* first the INBOX */\n        rock->mb_category = MBNAME_INBOX;\n        r = cyrusdb_forone(rock->db, inbox, inboxlen, &find_p, &find_cb, rock, NULL);\n        if (r == CYRUSDB_DONE) r = 0;\n        if (r) goto done;\n\n        if (rock->namespace->isalt) {\n            /* do exact INBOX subs before resetting the namebuffer */\n            rock->mb_category = MBNAME_INBOXSUB;\n            r = cyrusdb_foreach(rock->db, inbox, inboxlen+7, &find_p, &find_cb, rock, NULL);\n            if (r == CYRUSDB_DONE) r = 0;\n            if (r) goto done;\n\n            /* reset the the namebuffer */\n            r = (*rock->proc)(NULL, rock->procrock);\n            if (r) goto done;\n        }\n\n        /* iterate through all the mailboxes under the user's inbox */\n        rock->mb_category = MBNAME_OWNER;\n        r = cyrusdb_foreach(rock->db, inbox, inboxlen+1, &find_p, &find_cb, rock, NULL);\n        if (r == CYRUSDB_DONE) r = 0;\n        if (r) goto done;\n\n        /* \"Alt Prefix\" folders */\n        if (rock->namespace->isalt) {\n            /* reset the the namebuffer */\n            r = (*rock->proc)(NULL, rock->procrock);\n            if (r) goto done;\n\n            rock->mb_category = MBNAME_ALTINBOX;\n\n            /* special case user.foo.INBOX.  If we're singlepercent == 2, this could\n             return DONE, in which case we don't need to foreach the rest of the\n             altprefix space */\n            r = cyrusdb_forone(rock->db, inbox, inboxlen+6, &find_p, &find_cb, rock, NULL);\n            if (r == CYRUSDB_DONE) goto skipalt;\n            if (r) goto done;\n\n            /* special case any other altprefix stuff */\n            rock->mb_category = MBNAME_ALTPREFIX;\n            r = cyrusdb_foreach(rock->db, inbox, inboxlen+1, &find_p, &find_cb, rock, NULL);\n        skipalt: /* we got a done, so skip out of the foreach early */\n            if (r == CYRUSDB_DONE) r = 0;\n            if (r) goto done;\n        }\n    }\n\n    /*\n     * Other Users namespace\n     *\n     * If \"Other Users*\" can match pattern, search for those mailboxes next\n     */\n    if (isadmin || rock->namespace->accessible[NAMESPACE_USER]) {\n        len = strlen(rock->namespace->prefix[NAMESPACE_USER]);\n        if (len) len--; // trailing separator\n\n        if (!strncmp(rock->namespace->prefix[NAMESPACE_USER], commonpat, MIN(len, prefixlen))) {\n            if (prefixlen <= len) {\n                /* we match all users */\n                strlcpy(domainpat+domainlen, \"user.\", sizeof(domainpat)-domainlen);\n            }\n            else {\n                /* just those in this prefix */\n                strlcpy(domainpat+domainlen, \"user.\", sizeof(domainpat)-domainlen);\n                strlcpy(domainpat+domainlen+5, commonpat+len+1, sizeof(domainpat)-domainlen-5);\n            }\n\n            rock->mb_category = MBNAME_OTHERUSER;\n\n            /* because of how domains work, with crossdomains or admin you can't prefix at all :( */\n            size_t thislen = (isadmin || crossdomains) ? 0 : strlen(domainpat);\n\n            /* reset the the namebuffer */\n            r = (*rock->proc)(NULL, rock->procrock);\n            if (r) goto done;\n\n            r = mboxlist_find_category(rock, domainpat, thislen);\n            if (r) goto done;\n        }\n    }\n\n    /*\n     * Shared namespace\n     *\n     * search for all remaining mailboxes.\n     * just bother looking at the ones that have the same pattern prefix.\n     */\n    if (isadmin || rock->namespace->accessible[NAMESPACE_SHARED]) {\n        len = strlen(rock->namespace->prefix[NAMESPACE_SHARED]);\n        if (len) len--; // trailing separator\n\n        if (!strncmp(rock->namespace->prefix[NAMESPACE_SHARED], commonpat, MIN(len, prefixlen))) {\n            rock->mb_category = MBNAME_SHARED;\n\n            /* reset the the namebuffer */\n            r = (*rock->proc)(NULL, rock->procrock);\n            if (r) goto done;\n\n            /* iterate through all the non-user folders on the server */\n            r = mboxlist_find_category(rock, domainpat, domainlen);\n            if (r) goto done;\n        }\n    }\n\n    /* finish with a reset call always */\n    r = (*rock->proc)(NULL, rock->procrock);\n\n done:\n    for (i = 0; i < rock->globs.count; i++) {\n        glob *g = ptrarray_nth(&rock->globs, i);\n        glob_free(&g);\n    }\n    ptrarray_fini(&rock->globs);\n\n    return r;\n}\n\nEXPORTED int mboxlist_findallmulti(struct namespace *namespace,\n                                   const strarray_t *patterns, int isadmin,\n                                   const char *userid, const struct auth_state *auth_state,\n                                   findall_cb *proc, void *rock)\n{\n    int r = 0;\n\n    if (!namespace) namespace = mboxname_get_adminnamespace();\n\n    struct find_rock cbrock;\n    memset(&cbrock, 0, sizeof(struct find_rock));\n\n    cbrock.auth_state = auth_state;\n    cbrock.db = mbdb;\n    cbrock.isadmin = isadmin;\n    cbrock.namespace = namespace;\n    cbrock.proc = proc;\n    cbrock.procrock = rock;\n    cbrock.userid = userid;\n    if (userid) {\n        const char *domp = strchr(userid, '@');\n        if (domp) cbrock.domain = domp + 1;\n    }\n\n    r = mboxlist_do_find(&cbrock, patterns);\n\n    return r;\n}\n\nEXPORTED int mboxlist_findall(struct namespace *namespace,\n                              const char *pattern, int isadmin,\n                              const char *userid, const struct auth_state *auth_state,\n                              findall_cb *proc, void *rock)\n{\n    strarray_t patterns = STRARRAY_INITIALIZER;\n    strarray_append(&patterns, pattern);\n\n    int r = mboxlist_findallmulti(namespace, &patterns, isadmin, userid, auth_state, proc, rock);\n\n    strarray_fini(&patterns);\n\n    return r;\n}\n\nEXPORTED int mboxlist_findone(struct namespace *namespace,\n                              const char *intname, int isadmin,\n                              const char *userid, const struct auth_state *auth_state,\n                              findall_cb *proc, void *rock)\n{\n    int r = 0;\n\n    if (!namespace) namespace = mboxname_get_adminnamespace();\n\n    struct find_rock cbrock;\n    memset(&cbrock, 0, sizeof(struct find_rock));\n\n    cbrock.auth_state = auth_state;\n    cbrock.db = mbdb;\n    cbrock.isadmin = isadmin;\n    cbrock.namespace = namespace;\n    cbrock.proc = proc;\n    cbrock.procrock = rock;\n    cbrock.userid = userid;\n    if (userid) {\n        const char *domp = strchr(userid, '@');\n        if (domp) cbrock.domain = domp + 1;\n    }\n\n    mbname_t *mbname = mbname_from_intname(intname);\n    glob *g = glob_init(mbname_extname(mbname, namespace, userid),\n                        namespace->hier_sep);\n    ptrarray_append(&cbrock.globs, g);\n    mbname_free(&mbname);\n\n    r = cyrusdb_forone(cbrock.db, intname, strlen(intname), &find_p, &find_cb, &cbrock, NULL);\n\n    glob_free(&g);\n    ptrarray_fini(&cbrock.globs);\n\n    return r;\n}\n\nstatic int exists_cb(const mbentry_t *mbentry __attribute__((unused)), void *rock)\n{\n    int *exists = (int *)rock;\n    *exists = 1;\n    return CYRUSDB_DONE; /* one is enough */\n}\n\n/*\n * Set all the resource quotas on, or create a quota root.\n */\nEXPORTED int mboxlist_setquotas(const char *root,\n                       quota_t newquotas[QUOTA_NUMRESOURCES], int force)\n{\n    struct quota q;\n    int r;\n    int res;\n    struct txn *tid = NULL;\n    struct mboxevent *mboxevents = NULL;\n    struct mboxevent *quotachange_event = NULL;\n    struct mboxevent *quotawithin_event = NULL;\n\n    if (!root[0] || root[0] == '.' || strchr(root, '/')\n        || strchr(root, '*') || strchr(root, '%') || strchr(root, '?')) {\n        return IMAP_MAILBOX_BADNAME;\n    }\n\n    quota_init(&q, root);\n    r = quota_read(&q, &tid, 1);\n\n    if (!r) {\n        int changed = 0;\n        int underquota;\n\n        /* has it changed? */\n        for (res = 0 ; res < QUOTA_NUMRESOURCES ; res++) {\n            if (q.limits[res] != newquotas[res]) {\n                underquota = 0;\n\n                /* Prepare a QuotaChange event notification *now*.\n                 *\n                 * This is to ensure the QuotaChange is emitted before the\n                 * subsequent QuotaWithin (if the latter becomes applicable).\n                 */\n                if (quotachange_event == NULL) {\n                    quotachange_event = mboxevent_enqueue(EVENT_QUOTA_CHANGE,\n                                                          &mboxevents);\n                }\n\n                /* prepare a QuotaWithin event notification if now under quota */\n                if (quota_is_overquota(&q, res, NULL) &&\n                    (!quota_is_overquota(&q, res, newquotas) || newquotas[res] == -1)) {\n                    if (quotawithin_event == NULL)\n                        quotawithin_event = mboxevent_enqueue(EVENT_QUOTA_WITHIN,\n                                                              &mboxevents);\n                    underquota++;\n                }\n\n                q.limits[res] = newquotas[res];\n                changed++;\n\n                mboxevent_extract_quota(quotachange_event, &q, res);\n                if (underquota)\n                    mboxevent_extract_quota(quotawithin_event, &q, res);\n            }\n        }\n        if (changed) {\n            r = quota_write(&q, &tid);\n\n            if (quotachange_event == NULL) {\n                quotachange_event = mboxevent_enqueue(EVENT_QUOTA_CHANGE, &mboxevents);\n            }\n\n            for (res = 0; res < QUOTA_NUMRESOURCES; res++) {\n                mboxevent_extract_quota(quotachange_event, &q, res);\n            }\n        }\n\n        if (!r)\n            quota_commit(&tid);\n\n        goto done;\n    }\n\n    if (r != IMAP_QUOTAROOT_NONEXISTENT)\n        goto done;\n\n    if (config_virtdomains && root[strlen(root)-1] == '!') {\n        /* domain quota */\n    }\n    else {\n        mbentry_t *mbentry = NULL;\n\n        /* look for a top-level mailbox in the proposed quotaroot */\n        r = mboxlist_lookup(root, &mbentry, NULL);\n        if (r) {\n            if (!force && r == IMAP_MAILBOX_NONEXISTENT) {\n                mboxlist_mboxtree(root, exists_cb, &force, MBOXTREE_SKIP_ROOT);\n            }\n            /* are we going to force the create anyway? */\n            if (force) {\n                r = 0;\n            }\n        }\n        else if (mbentry->mbtype & (MBTYPE_REMOTE | MBTYPE_MOVING)) {\n            /* Can't set quota on a remote mailbox */\n            r = IMAP_MAILBOX_NOTSUPPORTED;\n        }\n        mboxlist_entry_free(&mbentry);\n        if (r) goto done;\n    }\n\n    /* safe against quota -f and other root change races */\n    r = quota_changelock();\n    if (r) goto done;\n\n    /* initialise the quota */\n    memcpy(q.limits, newquotas, sizeof(q.limits));\n    r = quota_write(&q, &tid);\n    if (r) goto done;\n\n    /* prepare a QuotaChange event notification */\n    if (quotachange_event == NULL)\n        quotachange_event = mboxevent_enqueue(EVENT_QUOTA_CHANGE, &mboxevents);\n\n    for (res = 0; res < QUOTA_NUMRESOURCES; res++) {\n        mboxevent_extract_quota(quotachange_event, &q, res);\n    }\n\n    quota_commit(&tid);\n\n    /* recurse through mailboxes, setting the quota and finding\n     * out the usage */\n    mboxlist_mboxtree(root, mboxlist_changequota, (void *)root, 0);\n\n    quota_changelockrelease();\n\ndone:\n    quota_free(&q);\n    if (r && tid) quota_abort(&tid);\n    if (!r) {\n        sync_log_quota(root);\n\n        /* send QuotaChange and QuotaWithin event notifications */\n        mboxevent_notify(&mboxevents);\n    }\n    mboxevent_freequeue(&mboxevents);\n\n    return r;\n}\n\n/*\n *  Remove a quota root\n */\nEXPORTED int mboxlist_unsetquota(const char *root)\n{\n    struct quota q;\n    int r=0;\n\n    if (!root[0] || root[0] == '.' || strchr(root, '/')\n        || strchr(root, '*') || strchr(root, '%') || strchr(root, '?')) {\n        return IMAP_MAILBOX_BADNAME;\n    }\n\n    quota_init(&q, root);\n    r = quota_read(&q, NULL, 0);\n    /* already unset */\n    if (r == IMAP_QUOTAROOT_NONEXISTENT) {\n        r = 0;\n        goto done;\n    }\n    if (r) goto done;\n\n    r = quota_changelock();\n\n    /*\n     * Have to remove it from all affected mailboxes\n     */\n    mboxlist_mboxtree(root, mboxlist_rmquota, (void *)root, /*flags*/0);\n\n    r = quota_deleteroot(root);\n    quota_changelockrelease();\n\n    if (!r) sync_log_quota(root);\n\n done:\n    quota_free(&q);\n    return r;\n}\n\nEXPORTED modseq_t mboxlist_foldermodseq_dirty(struct mailbox *mailbox)\n{\n    mbentry_t *mbentry = NULL;\n    modseq_t ret = 0;\n\n    if (mboxlist_mylookup(mailbox->name, &mbentry, NULL, 0))\n        return 0;\n\n    ret = mbentry->foldermodseq = mailbox_modseq_dirty(mailbox);\n\n    mboxlist_update(mbentry, 0);\n\n    mboxlist_entry_free(&mbentry);\n\n    return ret;\n}\n\n/*\n * ACL access canonicalization routine which ensures that 'owner'\n * retains lookup, administer, and create rights over a mailbox.\n */\nEXPORTED int mboxlist_ensureOwnerRights(void *rock, const char *identifier,\n                               int myrights)\n{\n    char *owner = (char *)rock;\n    if (strcmp(identifier, owner) != 0) return myrights;\n    return myrights|config_implicitrights;\n}\n\n/*\n * Helper function to remove the quota root for 'name'\n */\nstatic int mboxlist_rmquota(const mbentry_t *mbentry, void *rock)\n{\n    int r = 0;\n    struct mailbox *mailbox = NULL;\n    const char *oldroot = (const char *) rock;\n\n    assert(oldroot != NULL);\n\n    r = mailbox_open_iwl(mbentry->name, &mailbox);\n    if (r) goto done;\n\n    if (mailbox->quotaroot) {\n        if (strcmp(mailbox->quotaroot, oldroot)) {\n            /* Part of a different quota root */\n            goto done;\n        }\n\n        r = mailbox_set_quotaroot(mailbox, NULL);\n    }\n\n done:\n    mailbox_close(&mailbox);\n\n    if (r) {\n        syslog(LOG_ERR, \"LOSTQUOTA: unable to remove quota root %s for %s: %s\",\n               oldroot, mbentry->name, error_message(r));\n    }\n\n    /* not a huge tragedy if we failed, so always return success */\n    return 0;\n}\n\n/*\n * Helper function to change the quota root for 'name' to that pointed\n * to by the static global struct pointer 'mboxlist_newquota'.\n */\nstatic int mboxlist_changequota(const mbentry_t *mbentry, void *rock)\n{\n    int r = 0;\n    struct mailbox *mailbox = NULL;\n    const char *root = (const char *) rock;\n    int res;\n    quota_t quota_usage[QUOTA_NUMRESOURCES];\n\n    assert(root);\n\n    r = mailbox_open_iwl(mbentry->name, &mailbox);\n    if (r) goto done;\n\n    mailbox_get_usage(mailbox, quota_usage);\n\n    if (mailbox->quotaroot) {\n        quota_t quota_diff[QUOTA_NUMRESOURCES];\n\n        if (strlen(mailbox->quotaroot) >= strlen(root)) {\n            /* Part of a child quota root - skip */\n            goto done;\n        }\n\n        /* remove usage from the old quotaroot */\n        for (res = 0; res < QUOTA_NUMRESOURCES ; res++) {\n            quota_diff[res] = -quota_usage[res];\n        }\n        r = quota_update_useds(mailbox->quotaroot, quota_diff,\n                               mailbox->name);\n    }\n\n    /* update (or set) the quotaroot */\n    r = mailbox_set_quotaroot(mailbox, root);\n    if (r) goto done;\n\n    /* update the new quota root */\n    r = quota_update_useds(root, quota_usage, mailbox->name);\n\n done:\n    mailbox_close(&mailbox);\n\n    if (r) {\n        syslog(LOG_ERR, \"LOSTQUOTA: unable to change quota root for %s to %s: %s\",\n               mbentry->name, root, error_message(r));\n    }\n\n    /* Note, we're a callback, and it's not a huge tragedy if we\n     * fail, so we don't ever return a failure */\n    return 0;\n}\n\n/* must be called after cyrus_init */\nEXPORTED void mboxlist_init(int myflags)\n{\n    if (myflags & MBOXLIST_SYNC) {\n        cyrusdb_sync(DB);\n    }\n}\n\nEXPORTED void mboxlist_open(const char *fname)\n{\n    int ret, flags;\n    char *tofree = NULL;\n\n    if (!fname)\n        fname = config_getstring(IMAPOPT_MBOXLIST_DB_PATH);\n\n    /* create db file name */\n    if (!fname) {\n        tofree = strconcat(config_dir, FNAME_MBOXLIST, (char *)NULL);\n        fname = tofree;\n    }\n\n    flags = CYRUSDB_CREATE;\n    if (config_getswitch(IMAPOPT_IMPROVED_MBOXLIST_SORT)) {\n        flags |= CYRUSDB_MBOXSORT;\n    }\n\n    ret = cyrusdb_open(DB, fname, flags, &mbdb);\n    if (ret != 0) {\n        syslog(LOG_ERR, \"DBERROR: opening %s: %s\", fname,\n               cyrusdb_strerror(ret));\n            /* Exiting TEMPFAIL because Sendmail thinks this\n               EC_OSFILE == permanent failure. */\n        fatal(\"can't read mailboxes file\", EC_TEMPFAIL);\n    }\n\n    free(tofree);\n\n    mboxlist_dbopen = 1;\n}\n\nEXPORTED void mboxlist_close(void)\n{\n    int r;\n\n    if (mboxlist_dbopen) {\n        r = cyrusdb_close(mbdb);\n        if (r) {\n            syslog(LOG_ERR, \"DBERROR: error closing mailboxes: %s\",\n                   cyrusdb_strerror(r));\n        }\n        mboxlist_dbopen = 0;\n    }\n}\n\nEXPORTED void mboxlist_done(void)\n{\n    /* DB->done() handled by cyrus_done() */\n}\n\n/*\n * Open the subscription list for 'userid'.\n *\n * On success, returns zero.\n * On failure, returns an error code.\n */\nstatic int\nmboxlist_opensubs(const char *userid,\n                  struct db **ret)\n{\n    int r = 0, flags;\n    char *subsfname;\n\n    /* Build subscription list filename */\n    subsfname = user_hash_subs(userid);\n\n    flags = CYRUSDB_CREATE;\n    if (config_getswitch(IMAPOPT_IMPROVED_MBOXLIST_SORT)) {\n        flags |= CYRUSDB_MBOXSORT;\n    }\n\n    r = cyrusdb_open(SUBDB, subsfname, flags, ret);\n    if (r != CYRUSDB_OK) {\n        r = IMAP_IOERROR;\n    }\n    free(subsfname);\n\n    return r;\n}\n\n/*\n * Close a subscription file\n */\nstatic void mboxlist_closesubs(struct db *sub)\n{\n    cyrusdb_close(sub);\n}\n\n/*\n * Find subscribed mailboxes that match 'pattern'.\n * 'isadmin' is nonzero if user is a mailbox admin.  'userid'\n * is the user's login id.  For each matching mailbox, calls\n * 'proc' with the name of the mailbox.\n */\nEXPORTED int mboxlist_findsubmulti(struct namespace *namespace,\n                                   const strarray_t *patterns, int isadmin,\n                                   const char *userid, const struct auth_state *auth_state,\n                                   findall_cb *proc, void *rock,\n                                   int force)\n{\n    int r = 0;\n\n    if (!namespace) namespace = mboxname_get_adminnamespace();\n\n    struct find_rock cbrock;\n    memset(&cbrock, 0, sizeof(struct find_rock));\n\n    /* open the subscription file that contains the mailboxes the\n       user is subscribed to */\n    struct db *subs = NULL;\n    r = mboxlist_opensubs(userid, &subs);\n    if (r) return r;\n\n    cbrock.auth_state = auth_state;\n    cbrock.checkmboxlist = !force;\n    cbrock.db = subs;\n    cbrock.isadmin = isadmin;\n    cbrock.issubs = 1;\n    cbrock.namespace = namespace;\n    cbrock.proc = proc;\n    cbrock.procrock = rock;\n    cbrock.userid = userid;\n    if (userid) {\n        const char *domp = strchr(userid, '@');\n        if (domp) cbrock.domain = domp + 1;\n    }\n\n    r = mboxlist_do_find(&cbrock, patterns);\n\n    mboxlist_closesubs(subs);\n\n    return r;\n}\n\nEXPORTED int mboxlist_findsub(struct namespace *namespace,\n                              const char *pattern, int isadmin,\n                              const char *userid, const struct auth_state *auth_state,\n                              findall_cb *proc, void *rock,\n                              int force)\n{\n    strarray_t patterns = STRARRAY_INITIALIZER;\n    strarray_append(&patterns, pattern);\n\n    int r = mboxlist_findsubmulti(namespace, &patterns, isadmin, userid, auth_state, proc, rock, force);\n\n    strarray_fini(&patterns);\n\n    return r;\n}\n\nstatic int subsadd_cb(void *rock, const char *key, size_t keylen,\n                      const char *val __attribute__((unused)),\n                      size_t vallen __attribute__((unused)))\n{\n    strarray_t *list = (strarray_t *)rock;\n    strarray_appendm(list, xstrndup(key, keylen));\n    return 0;\n}\n\nEXPORTED strarray_t *mboxlist_sublist(const char *userid)\n{\n    struct db *subs = NULL;\n    strarray_t *list = strarray_new();\n    int r;\n\n    /* open subs DB */\n    r = mboxlist_opensubs(userid, &subs);\n    if (r) goto done;\n\n    /* faster to do it all in a single slurp! */\n    r = cyrusdb_foreach(subs, \"\", 0, subsadd_cb, NULL, list, 0);\n\n    mboxlist_closesubs(subs);\n\ndone:\n    if (r) {\n        strarray_free(list);\n        return NULL;\n    }\n    return list;\n}\n\n\n\nstruct submb_rock {\n    struct mboxlist_entry *mbentry;\n    const char *userid;\n    int flags;\n    mboxlist_cb *proc;\n    void *rock;\n};\n\nstatic int usersubs_cb(void *rock, const char *key, size_t keylen,\n                      const char *data __attribute__((unused)),\n                      size_t datalen __attribute__((unused)))\n{\n    struct submb_rock *mbrock = (struct submb_rock *) rock;\n    char mboxname[MAX_MAILBOX_NAME+1];\n    int r;\n\n    /* free previous record */\n    mboxlist_entry_free(&mbrock->mbentry);\n\n    snprintf(mboxname, MAX_MAILBOX_NAME, \"%.*s\", (int) keylen, key);\n\n    if ((mbrock->flags & MBOXTREE_SKIP_PERSONAL) &&\n        mboxname_userownsmailbox(mbrock->userid, mboxname)) return 0;\n\n    r = mboxlist_lookup(mboxname, &mbrock->mbentry, NULL);\n    if (r) {\n        syslog(LOG_INFO, \"mboxlist_lookup(%s) failed: %s\",\n               mboxname, error_message(r));\n        return r;\n    }\n\n    return mbrock->proc(mbrock->mbentry, mbrock->rock);\n}\n\nEXPORTED int mboxlist_usersubs(const char *userid, mboxlist_cb *proc,\n                               void *rock, int flags)\n{\n    struct db *subs = NULL;\n    struct submb_rock mbrock = { NULL, userid, flags, proc, rock };\n    int r = 0;\n\n    /* open subs DB */\n    r = mboxlist_opensubs(userid, &subs);\n    if (r) return r;\n\n    /* faster to do it all in a single slurp! */\n    r = cyrusdb_foreach(subs, \"\", 0, NULL, usersubs_cb, &mbrock, 0);\n\n    mboxlist_entry_free(&mbrock.mbentry);\n\n    mboxlist_closesubs(subs);\n\n    return r;\n}\n\n\n\n\n/* returns CYRUSDB_NOTFOUND if the folder doesn't exist, and 0 if it does! */\nEXPORTED int mboxlist_checksub(const char *name, const char *userid)\n{\n    int r;\n    struct db *subs;\n    const char *val;\n    size_t vallen;\n\n    r = mboxlist_opensubs(userid, &subs);\n\n    if (!r) r = cyrusdb_fetch(subs, name, strlen(name), &val, &vallen, NULL);\n\n    mboxlist_closesubs(subs);\n    return r;\n}\n\n/*\n * Change 'user's subscription status for mailbox 'name'.\n * Subscribes if 'add' is nonzero, unsubscribes otherwise.\n * if 'force' is set, force the subscription through even if\n * we don't know about 'name'.\n */\nEXPORTED int mboxlist_changesub(const char *name, const char *userid,\n                                const struct auth_state *auth_state,\n                                int add, int force, int notify)\n{\n    mbentry_t *mbentry = NULL;\n    int r;\n    struct db *subs;\n    struct mboxevent *mboxevent;\n\n    if ((r = mboxlist_opensubs(userid, &subs)) != 0) {\n        return r;\n    }\n\n    if (add && !force) {\n        /* Ensure mailbox exists and can be seen by user */\n        if ((r = mboxlist_lookup(name, &mbentry, NULL))!=0) {\n            mboxlist_closesubs(subs);\n            return r;\n        }\n        if ((cyrus_acl_myrights(auth_state, mbentry->acl) & ACL_LOOKUP) == 0) {\n            mboxlist_closesubs(subs);\n            mboxlist_entry_free(&mbentry);\n            return IMAP_MAILBOX_NONEXISTENT;\n        }\n    }\n\n    if (add) {\n        r = cyrusdb_store(subs, name, strlen(name), \"\", 0, NULL);\n    } else {\n        r = cyrusdb_delete(subs, name, strlen(name), NULL, 0);\n        /* if it didn't exist, that's ok */\n        if (r == CYRUSDB_EXISTS) r = CYRUSDB_OK;\n    }\n\n    switch (r) {\n    case CYRUSDB_OK:\n        r = 0;\n        break;\n\n    default:\n        r = IMAP_IOERROR;\n        break;\n    }\n\n    sync_log_subscribe(userid, name);\n    mboxlist_closesubs(subs);\n    mboxlist_entry_free(&mbentry);\n\n    /* prepare a MailboxSubscribe or MailboxUnSubscribe event notification */\n    if (notify && r == 0) {\n        mboxevent = mboxevent_new(add ? EVENT_MAILBOX_SUBSCRIBE :\n                                        EVENT_MAILBOX_UNSUBSCRIBE);\n\n        mboxevent_set_access(mboxevent, NULL, NULL, userid, name, 1);\n        mboxevent_notify(&mboxevent);\n        mboxevent_free(&mboxevent);\n    }\n\n    return r;\n}\n\n/* Transaction Handlers */\nEXPORTED int mboxlist_commit(struct txn *tid)\n{\n    assert(tid);\n\n    return cyrusdb_commit(mbdb, tid);\n}\n\nint mboxlist_abort(struct txn *tid)\n{\n    assert(tid);\n\n    return cyrusdb_abort(mbdb, tid);\n}\n\nEXPORTED int mboxlist_delayed_delete_isenabled(void)\n{\n    enum enum_value config_delete_mode = config_getenum(IMAPOPT_DELETE_MODE);\n\n    return(config_delete_mode == IMAP_ENUM_DELETE_MODE_DELAYED);\n}\n"], "filenames": ["imap/mboxlist.c"], "buggy_code_start_loc": [2854], "buggy_code_end_loc": [2855], "fixing_code_start_loc": [2854], "fixing_code_end_loc": [2855], "type": "CWE-20", "message": "In the mboxlist_do_find function in imap/mboxlist.c in Cyrus IMAP before 3.0.4, an off-by-one error in prefix calculation for the LIST command caused use of uninitialized memory, which might allow remote attackers to obtain sensitive information or cause a denial of service (daemon crash) via a 'LIST \"\" \"Other Users\"' command.", "other": {"cve": {"id": "CVE-2017-14230", "sourceIdentifier": "cve@mitre.org", "published": "2017-09-10T07:29:00.177", "lastModified": "2017-09-21T14:19:33.240", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In the mboxlist_do_find function in imap/mboxlist.c in Cyrus IMAP before 3.0.4, an off-by-one error in prefix calculation for the LIST command caused use of uninitialized memory, which might allow remote attackers to obtain sensitive information or cause a denial of service (daemon crash) via a 'LIST \"\" \"Other Users\"' command."}, {"lang": "es", "value": "En la funci\u00f3n mboxlist_do_find en imap/mboxlist.c en Cyrus IMAP en versiones anteriores a la 3.0.4, un error por un paso (off-by-one) en el c\u00e1lculo de prefijos para el comando LIST provocaba el uso de memoria sin inicializar, lo que podr\u00eda permitir que atacantes remotos obtengan informaci\u00f3n sensible o provoquen una denegaci\u00f3n de servicio (daemon crash) mediante un comando 'LIST \"\" \"Other Users\"'."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:cyrus:imap:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.0.3", "matchCriteriaId": "B093D058-650F-443F-AB82-F3E58BFD222B"}]}]}], "references": [{"url": "https://github.com/cyrusimap/cyrus-imapd/commit/6bd33275368edfa71ae117de895488584678ac79", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/cyrusimap/cyrus-imapd/issues/2132", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://lists.andrew.cmu.edu/pipermail/cyrus-announce/2017-September/000145.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.cyrusimap.org/imap/download/release-notes/3.0/x/3.0.4.html", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/cyrusimap/cyrus-imapd/commit/6bd33275368edfa71ae117de895488584678ac79"}}