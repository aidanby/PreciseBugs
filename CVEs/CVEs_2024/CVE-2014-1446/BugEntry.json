{"buggy_code": ["/*****************************************************************************/\n\n/*\n *    yam.c  -- YAM radio modem driver.\n *\n *      Copyright (C) 1998 Frederic Rible F1OAT (frible@teaser.fr)\n *      Adapted from baycom.c driver written by Thomas Sailer (sailer@ife.ee.ethz.ch)\n *\n *      This program is free software; you can redistribute it and/or modify\n *      it under the terms of the GNU General Public License as published by\n *      the Free Software Foundation; either version 2 of the License, or\n *      (at your option) any later version.\n *\n *      This program is distributed in the hope that it will be useful,\n *      but WITHOUT ANY WARRANTY; without even the implied warranty of\n *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *      GNU General Public License for more details.\n *\n *      You should have received a copy of the GNU General Public License\n *      along with this program; if not, write to the Free Software\n *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n *  Please note that the GPL allows you to use the driver, NOT the radio.\n *  In order to use the radio, you need a license from the communications\n *  authority of your country.\n *\n *\n *  History:\n *   0.0 F1OAT 06.06.98  Begin of work with baycom.c source code V 0.3\n *   0.1 F1OAT 07.06.98  Add timer polling routine for channel arbitration\n *   0.2 F6FBB 08.06.98  Added delay after FPGA programming\n *   0.3 F6FBB 29.07.98  Delayed PTT implementation for dupmode=2\n *   0.4 F6FBB 30.07.98  Added TxTail, Slottime and Persistence\n *   0.5 F6FBB 01.08.98  Shared IRQs, /proc/net and network statistics\n *   0.6 F6FBB 25.08.98  Added 1200Bds format\n *   0.7 F6FBB 12.09.98  Added to the kernel configuration\n *   0.8 F6FBB 14.10.98  Fixed slottime/persistence timing bug\n *       OK1ZIA 2.09.01  Fixed \"kfree_skb on hard IRQ\" \n *                       using dev_kfree_skb_any(). (important in 2.4 kernel)\n *   \n */\n\n/*****************************************************************************/\n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <linux/if.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/random.h>\n#include <asm/io.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/firmware.h>\n#include <linux/platform_device.h>\n\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <net/ax25.h>\n\n#include <linux/kernel.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <net/net_namespace.h>\n\n#include <asm/uaccess.h>\n#include <linux/init.h>\n\n#include <linux/yam.h>\n\n/* --------------------------------------------------------------------- */\n\nstatic const char yam_drvname[] = \"yam\";\nstatic const char yam_drvinfo[] __initconst = KERN_INFO \\\n\t\"YAM driver version 0.8 by F1OAT/F6FBB\\n\";\n\n/* --------------------------------------------------------------------- */\n\n#define FIRMWARE_9600\t\"yam/9600.bin\"\n#define FIRMWARE_1200\t\"yam/1200.bin\"\n\n#define YAM_9600\t1\n#define YAM_1200\t2\n\n#define NR_PORTS\t4\n#define YAM_MAGIC\t0xF10A7654\n\n/* Transmitter states */\n\n#define TX_OFF\t\t0\n#define TX_HEAD\t\t1\n#define TX_DATA\t\t2\n#define TX_CRC1\t\t3\n#define TX_CRC2\t\t4\n#define TX_TAIL\t\t5\n\n#define YAM_MAX_FRAME\t1024\n\n#define DEFAULT_BITRATE\t9600\t\t\t/* bps */\n#define DEFAULT_HOLDD\t10\t\t\t/* sec */\n#define DEFAULT_TXD\t300\t\t\t/* ms */\n#define DEFAULT_TXTAIL\t10\t\t\t/* ms */\n#define DEFAULT_SLOT\t100\t\t\t/* ms */\n#define DEFAULT_PERS\t64\t\t\t/* 0->255 */\n\nstruct yam_port {\n\tint magic;\n\tint bitrate;\n\tint baudrate;\n\tint iobase;\n\tint irq;\n\tint dupmode;\n\n\tstruct net_device *dev;\n\n\tint nb_rxint;\n\tint nb_mdint;\n\n\t/* Parameters section */\n\n\tint txd;\t\t\t\t/* tx delay */\n\tint holdd;\t\t\t\t/* duplex ptt delay */\n\tint txtail;\t\t\t\t/* txtail delay */\n\tint slot;\t\t\t\t/* slottime */\n\tint pers;\t\t\t\t/* persistence */\n\n\t/* Tx section */\n\n\tint tx_state;\n\tint tx_count;\n\tint slotcnt;\n\tunsigned char tx_buf[YAM_MAX_FRAME];\n\tint tx_len;\n\tint tx_crcl, tx_crch;\n\tstruct sk_buff_head send_queue;\t\t/* Packets awaiting transmission */\n\n\t/* Rx section */\n\n\tint dcd;\n\tunsigned char rx_buf[YAM_MAX_FRAME];\n\tint rx_len;\n\tint rx_crcl, rx_crch;\n};\n\nstruct yam_mcs {\n\tunsigned char bits[YAM_FPGA_SIZE];\n\tint bitrate;\n\tstruct yam_mcs *next;\n};\n\nstatic struct net_device *yam_devs[NR_PORTS];\n\nstatic struct yam_mcs *yam_data;\n\nstatic DEFINE_TIMER(yam_timer, NULL, 0, 0);\n\n/* --------------------------------------------------------------------- */\n\n#define RBR(iobase)\t(iobase+0)\n#define THR(iobase)\t(iobase+0)\n#define IER(iobase)\t(iobase+1)\n#define IIR(iobase)\t(iobase+2)\n#define FCR(iobase)\t(iobase+2)\n#define LCR(iobase)\t(iobase+3)\n#define MCR(iobase)\t(iobase+4)\n#define LSR(iobase)\t(iobase+5)\n#define MSR(iobase)\t(iobase+6)\n#define SCR(iobase)\t(iobase+7)\n#define DLL(iobase)\t(iobase+0)\n#define DLM(iobase)\t(iobase+1)\n\n#define YAM_EXTENT\t8\n\n/* Interrupt Identification Register Bit Masks */\n#define IIR_NOPEND\t1\n#define IIR_MSR\t\t0\n#define IIR_TX\t\t2\n#define IIR_RX\t\t4\n#define IIR_LSR\t\t6\n#define IIR_TIMEOUT\t12\t\t\t/* Fifo mode only */\n\n#define IIR_MASK\t0x0F\n\n/* Interrupt Enable Register Bit Masks */\n#define IER_RX\t\t1\t\t\t/* enable rx interrupt */\n#define IER_TX\t\t2\t\t\t/* enable tx interrupt */\n#define IER_LSR\t\t4\t\t\t/* enable line status interrupts */\n#define IER_MSR\t\t8\t\t\t/* enable modem status interrupts */\n\n/* Modem Control Register Bit Masks */\n#define MCR_DTR\t\t0x01\t\t\t/* DTR output */\n#define MCR_RTS\t\t0x02\t\t\t/* RTS output */\n#define MCR_OUT1\t0x04\t\t\t/* OUT1 output (not accessible in RS232) */\n#define MCR_OUT2\t0x08\t\t\t/* Master Interrupt enable (must be set on PCs) */\n#define MCR_LOOP\t0x10\t\t\t/* Loopback enable */\n\n/* Modem Status Register Bit Masks */\n#define MSR_DCTS\t0x01\t\t\t/* Delta CTS input */\n#define MSR_DDSR\t0x02\t\t\t/* Delta DSR */\n#define MSR_DRIN\t0x04\t\t\t/* Delta RI */\n#define MSR_DDCD\t0x08\t\t\t/* Delta DCD */\n#define MSR_CTS\t\t0x10\t\t\t/* CTS input */\n#define MSR_DSR\t\t0x20\t\t\t/* DSR input */\n#define MSR_RING\t0x40\t\t\t/* RI  input */\n#define MSR_DCD\t\t0x80\t\t\t/* DCD input */\n\n/* line status register bit mask */\n#define LSR_RXC\t\t0x01\n#define LSR_OE\t\t0x02\n#define LSR_PE\t\t0x04\n#define LSR_FE\t\t0x08\n#define LSR_BREAK\t0x10\n#define LSR_THRE\t0x20\n#define LSR_TSRE\t0x40\n\n/* Line Control Register Bit Masks */\n#define LCR_DLAB\t0x80\n#define LCR_BREAK\t0x40\n#define LCR_PZERO\t0x28\n#define LCR_PEVEN\t0x18\n#define LCR_PODD\t0x08\n#define LCR_STOP1\t0x00\n#define LCR_STOP2\t0x04\n#define LCR_BIT5\t0x00\n#define LCR_BIT6\t0x02\n#define LCR_BIT7\t0x01\n#define LCR_BIT8\t0x03\n\n/* YAM Modem <-> UART Port mapping */\n\n#define TX_RDY\t\tMSR_DCTS\t\t/* transmitter ready to send */\n#define RX_DCD\t\tMSR_DCD\t\t\t/* carrier detect */\n#define RX_FLAG\t\tMSR_RING\t\t/* hdlc flag received */\n#define FPGA_DONE\tMSR_DSR\t\t\t/* FPGA is configured */\n#define PTT_ON\t\t(MCR_RTS|MCR_OUT2)\t/* activate PTT */\n#define PTT_OFF\t\t(MCR_DTR|MCR_OUT2)\t/* release PTT */\n\n#define ENABLE_RXINT\tIER_RX\t\t\t/* enable uart rx interrupt during rx */\n#define ENABLE_TXINT\tIER_MSR\t\t\t/* enable uart ms interrupt during tx */\n#define ENABLE_RTXINT\t(IER_RX|IER_MSR)\t/* full duplex operations */\n\n\n/*************************************************************************\n* CRC Tables\n************************************************************************/\n\nstatic const unsigned char chktabl[256] =\n{0x00, 0x89, 0x12, 0x9b, 0x24, 0xad, 0x36, 0xbf, 0x48, 0xc1, 0x5a, 0xd3, 0x6c, 0xe5, 0x7e,\n 0xf7, 0x81, 0x08, 0x93, 0x1a, 0xa5, 0x2c, 0xb7, 0x3e, 0xc9, 0x40, 0xdb, 0x52, 0xed, 0x64,\n 0xff, 0x76, 0x02, 0x8b, 0x10, 0x99, 0x26, 0xaf, 0x34, 0xbd, 0x4a, 0xc3, 0x58, 0xd1, 0x6e,\n 0xe7, 0x7c, 0xf5, 0x83, 0x0a, 0x91, 0x18, 0xa7, 0x2e, 0xb5, 0x3c, 0xcb, 0x42, 0xd9, 0x50,\n 0xef, 0x66, 0xfd, 0x74, 0x04, 0x8d, 0x16, 0x9f, 0x20, 0xa9, 0x32, 0xbb, 0x4c, 0xc5, 0x5e,\n 0xd7, 0x68, 0xe1, 0x7a, 0xf3, 0x85, 0x0c, 0x97, 0x1e, 0xa1, 0x28, 0xb3, 0x3a, 0xcd, 0x44,\n 0xdf, 0x56, 0xe9, 0x60, 0xfb, 0x72, 0x06, 0x8f, 0x14, 0x9d, 0x22, 0xab, 0x30, 0xb9, 0x4e,\n 0xc7, 0x5c, 0xd5, 0x6a, 0xe3, 0x78, 0xf1, 0x87, 0x0e, 0x95, 0x1c, 0xa3, 0x2a, 0xb1, 0x38,\n 0xcf, 0x46, 0xdd, 0x54, 0xeb, 0x62, 0xf9, 0x70, 0x08, 0x81, 0x1a, 0x93, 0x2c, 0xa5, 0x3e,\n 0xb7, 0x40, 0xc9, 0x52, 0xdb, 0x64, 0xed, 0x76, 0xff, 0x89, 0x00, 0x9b, 0x12, 0xad, 0x24,\n 0xbf, 0x36, 0xc1, 0x48, 0xd3, 0x5a, 0xe5, 0x6c, 0xf7, 0x7e, 0x0a, 0x83, 0x18, 0x91, 0x2e,\n 0xa7, 0x3c, 0xb5, 0x42, 0xcb, 0x50, 0xd9, 0x66, 0xef, 0x74, 0xfd, 0x8b, 0x02, 0x99, 0x10,\n 0xaf, 0x26, 0xbd, 0x34, 0xc3, 0x4a, 0xd1, 0x58, 0xe7, 0x6e, 0xf5, 0x7c, 0x0c, 0x85, 0x1e,\n 0x97, 0x28, 0xa1, 0x3a, 0xb3, 0x44, 0xcd, 0x56, 0xdf, 0x60, 0xe9, 0x72, 0xfb, 0x8d, 0x04,\n 0x9f, 0x16, 0xa9, 0x20, 0xbb, 0x32, 0xc5, 0x4c, 0xd7, 0x5e, 0xe1, 0x68, 0xf3, 0x7a, 0x0e,\n 0x87, 0x1c, 0x95, 0x2a, 0xa3, 0x38, 0xb1, 0x46, 0xcf, 0x54, 0xdd, 0x62, 0xeb, 0x70, 0xf9,\n 0x8f, 0x06, 0x9d, 0x14, 0xab, 0x22, 0xb9, 0x30, 0xc7, 0x4e, 0xd5, 0x5c, 0xe3, 0x6a, 0xf1,\n 0x78};\nstatic const unsigned char chktabh[256] =\n{0x00, 0x11, 0x23, 0x32, 0x46, 0x57, 0x65, 0x74, 0x8c, 0x9d, 0xaf, 0xbe, 0xca, 0xdb, 0xe9,\n 0xf8, 0x10, 0x01, 0x33, 0x22, 0x56, 0x47, 0x75, 0x64, 0x9c, 0x8d, 0xbf, 0xae, 0xda, 0xcb,\n 0xf9, 0xe8, 0x21, 0x30, 0x02, 0x13, 0x67, 0x76, 0x44, 0x55, 0xad, 0xbc, 0x8e, 0x9f, 0xeb,\n 0xfa, 0xc8, 0xd9, 0x31, 0x20, 0x12, 0x03, 0x77, 0x66, 0x54, 0x45, 0xbd, 0xac, 0x9e, 0x8f,\n 0xfb, 0xea, 0xd8, 0xc9, 0x42, 0x53, 0x61, 0x70, 0x04, 0x15, 0x27, 0x36, 0xce, 0xdf, 0xed,\n 0xfc, 0x88, 0x99, 0xab, 0xba, 0x52, 0x43, 0x71, 0x60, 0x14, 0x05, 0x37, 0x26, 0xde, 0xcf,\n 0xfd, 0xec, 0x98, 0x89, 0xbb, 0xaa, 0x63, 0x72, 0x40, 0x51, 0x25, 0x34, 0x06, 0x17, 0xef,\n 0xfe, 0xcc, 0xdd, 0xa9, 0xb8, 0x8a, 0x9b, 0x73, 0x62, 0x50, 0x41, 0x35, 0x24, 0x16, 0x07,\n 0xff, 0xee, 0xdc, 0xcd, 0xb9, 0xa8, 0x9a, 0x8b, 0x84, 0x95, 0xa7, 0xb6, 0xc2, 0xd3, 0xe1,\n 0xf0, 0x08, 0x19, 0x2b, 0x3a, 0x4e, 0x5f, 0x6d, 0x7c, 0x94, 0x85, 0xb7, 0xa6, 0xd2, 0xc3,\n 0xf1, 0xe0, 0x18, 0x09, 0x3b, 0x2a, 0x5e, 0x4f, 0x7d, 0x6c, 0xa5, 0xb4, 0x86, 0x97, 0xe3,\n 0xf2, 0xc0, 0xd1, 0x29, 0x38, 0x0a, 0x1b, 0x6f, 0x7e, 0x4c, 0x5d, 0xb5, 0xa4, 0x96, 0x87,\n 0xf3, 0xe2, 0xd0, 0xc1, 0x39, 0x28, 0x1a, 0x0b, 0x7f, 0x6e, 0x5c, 0x4d, 0xc6, 0xd7, 0xe5,\n 0xf4, 0x80, 0x91, 0xa3, 0xb2, 0x4a, 0x5b, 0x69, 0x78, 0x0c, 0x1d, 0x2f, 0x3e, 0xd6, 0xc7,\n 0xf5, 0xe4, 0x90, 0x81, 0xb3, 0xa2, 0x5a, 0x4b, 0x79, 0x68, 0x1c, 0x0d, 0x3f, 0x2e, 0xe7,\n 0xf6, 0xc4, 0xd5, 0xa1, 0xb0, 0x82, 0x93, 0x6b, 0x7a, 0x48, 0x59, 0x2d, 0x3c, 0x0e, 0x1f,\n 0xf7, 0xe6, 0xd4, 0xc5, 0xb1, 0xa0, 0x92, 0x83, 0x7b, 0x6a, 0x58, 0x49, 0x3d, 0x2c, 0x1e,\n 0x0f};\n\n/*************************************************************************\n* FPGA functions\n************************************************************************/\n\nstatic void delay(int ms)\n{\n\tunsigned long timeout = jiffies + ((ms * HZ) / 1000);\n\twhile (time_before(jiffies, timeout))\n\t\tcpu_relax();\n}\n\n/*\n * reset FPGA\n */\n\nstatic void fpga_reset(int iobase)\n{\n\toutb(0, IER(iobase));\n\toutb(LCR_DLAB | LCR_BIT5, LCR(iobase));\n\toutb(1, DLL(iobase));\n\toutb(0, DLM(iobase));\n\n\toutb(LCR_BIT5, LCR(iobase));\n\tinb(LSR(iobase));\n\tinb(MSR(iobase));\n\t/* turn off FPGA supply voltage */\n\toutb(MCR_OUT1 | MCR_OUT2, MCR(iobase));\n\tdelay(100);\n\t/* turn on FPGA supply voltage again */\n\toutb(MCR_DTR | MCR_RTS | MCR_OUT1 | MCR_OUT2, MCR(iobase));\n\tdelay(100);\n}\n\n/*\n * send one byte to FPGA\n */\n\nstatic int fpga_write(int iobase, unsigned char wrd)\n{\n\tunsigned char bit;\n\tint k;\n\tunsigned long timeout = jiffies + HZ / 10;\n\n\tfor (k = 0; k < 8; k++) {\n\t\tbit = (wrd & 0x80) ? (MCR_RTS | MCR_DTR) : MCR_DTR;\n\t\toutb(bit | MCR_OUT1 | MCR_OUT2, MCR(iobase));\n\t\twrd <<= 1;\n\t\toutb(0xfc, THR(iobase));\n\t\twhile ((inb(LSR(iobase)) & LSR_TSRE) == 0)\n\t\t\tif (time_after(jiffies, timeout))\n\t\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n/*\n * predef should be 0 for loading user defined mcs\n * predef should be YAM_1200 for loading predef 1200 mcs\n * predef should be YAM_9600 for loading predef 9600 mcs\n */\nstatic unsigned char *add_mcs(unsigned char *bits, int bitrate,\n\t\t\t      unsigned int predef)\n{\n\tconst char *fw_name[2] = {FIRMWARE_9600, FIRMWARE_1200};\n\tconst struct firmware *fw;\n\tstruct platform_device *pdev;\n\tstruct yam_mcs *p;\n\tint err;\n\n\tswitch (predef) {\n\tcase 0:\n\t\tfw = NULL;\n\t\tbreak;\n\tcase YAM_1200:\n\tcase YAM_9600:\n\t\tpredef--;\n\t\tpdev = platform_device_register_simple(\"yam\", 0, NULL, 0);\n\t\tif (IS_ERR(pdev)) {\n\t\t\tprintk(KERN_ERR \"yam: Failed to register firmware\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\terr = request_firmware(&fw, fw_name[predef], &pdev->dev);\n\t\tplatform_device_unregister(pdev);\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR \"Failed to load firmware \\\"%s\\\"\\n\",\n\t\t\t       fw_name[predef]);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (fw->size != YAM_FPGA_SIZE) {\n\t\t\tprintk(KERN_ERR \"Bogus length %zu in firmware \\\"%s\\\"\\n\",\n\t\t\t       fw->size, fw_name[predef]);\n\t\t\trelease_firmware(fw);\n\t\t\treturn NULL;\n\t\t}\n\t\tbits = (unsigned char *)fw->data;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"yam: Invalid predef number %u\\n\", predef);\n\t\treturn NULL;\n\t}\n\n\t/* If it already exists, replace the bit data */\n\tp = yam_data;\n\twhile (p) {\n\t\tif (p->bitrate == bitrate) {\n\t\t\tmemcpy(p->bits, bits, YAM_FPGA_SIZE);\n\t\t\tgoto out;\n\t\t}\n\t\tp = p->next;\n\t}\n\n\t/* Allocate a new mcs */\n\tif ((p = kmalloc(sizeof(struct yam_mcs), GFP_KERNEL)) == NULL) {\n\t\trelease_firmware(fw);\n\t\treturn NULL;\n\t}\n\tmemcpy(p->bits, bits, YAM_FPGA_SIZE);\n\tp->bitrate = bitrate;\n\tp->next = yam_data;\n\tyam_data = p;\n out:\n\trelease_firmware(fw);\n\treturn p->bits;\n}\n\nstatic unsigned char *get_mcs(int bitrate)\n{\n\tstruct yam_mcs *p;\n\n\tp = yam_data;\n\twhile (p) {\n\t\tif (p->bitrate == bitrate)\n\t\t\treturn p->bits;\n\t\tp = p->next;\n\t}\n\n\t/* Load predefined mcs data */\n\tswitch (bitrate) {\n\tcase 1200:\n\t\t/* setting predef as YAM_1200 for loading predef 1200 mcs */\n\t\treturn add_mcs(NULL, bitrate, YAM_1200);\n\tdefault:\n\t\t/* setting predef as YAM_9600 for loading predef 9600 mcs */\n\t\treturn add_mcs(NULL, bitrate, YAM_9600);\n\t}\n}\n\n/*\n * download bitstream to FPGA\n * data is contained in bits[] array in yam1200.h resp. yam9600.h\n */\n\nstatic int fpga_download(int iobase, int bitrate)\n{\n\tint i, rc;\n\tunsigned char *pbits;\n\n\tpbits = get_mcs(bitrate);\n\tif (pbits == NULL)\n\t\treturn -1;\n\n\tfpga_reset(iobase);\n\tfor (i = 0; i < YAM_FPGA_SIZE; i++) {\n\t\tif (fpga_write(iobase, pbits[i])) {\n\t\t\tprintk(KERN_ERR \"yam: error in write cycle\\n\");\n\t\t\treturn -1;\t\t\t/* write... */\n\t\t}\n\t}\n\n\tfpga_write(iobase, 0xFF);\n\trc = inb(MSR(iobase));\t\t/* check DONE signal */\n\n\t/* Needed for some hardwares */\n\tdelay(50);\n\n\treturn (rc & MSR_DSR) ? 0 : -1;\n}\n\n\n/************************************************************************\n* Serial port init \n************************************************************************/\n\nstatic void yam_set_uart(struct net_device *dev)\n{\n\tstruct yam_port *yp = netdev_priv(dev);\n\tint divisor = 115200 / yp->baudrate;\n\n\toutb(0, IER(dev->base_addr));\n\toutb(LCR_DLAB | LCR_BIT8, LCR(dev->base_addr));\n\toutb(divisor, DLL(dev->base_addr));\n\toutb(0, DLM(dev->base_addr));\n\toutb(LCR_BIT8, LCR(dev->base_addr));\n\toutb(PTT_OFF, MCR(dev->base_addr));\n\toutb(0x00, FCR(dev->base_addr));\n\n\t/* Flush pending irq */\n\n\tinb(RBR(dev->base_addr));\n\tinb(MSR(dev->base_addr));\n\n\t/* Enable rx irq */\n\n\toutb(ENABLE_RTXINT, IER(dev->base_addr));\n}\n\n\n/* --------------------------------------------------------------------- */\n\nenum uart {\n\tc_uart_unknown, c_uart_8250,\n\tc_uart_16450, c_uart_16550, c_uart_16550A\n};\n\nstatic const char *uart_str[] =\n{\"unknown\", \"8250\", \"16450\", \"16550\", \"16550A\"};\n\nstatic enum uart yam_check_uart(unsigned int iobase)\n{\n\tunsigned char b1, b2, b3;\n\tenum uart u;\n\tenum uart uart_tab[] =\n\t{c_uart_16450, c_uart_unknown, c_uart_16550, c_uart_16550A};\n\n\tb1 = inb(MCR(iobase));\n\toutb(b1 | 0x10, MCR(iobase));\t/* loopback mode */\n\tb2 = inb(MSR(iobase));\n\toutb(0x1a, MCR(iobase));\n\tb3 = inb(MSR(iobase)) & 0xf0;\n\toutb(b1, MCR(iobase));\t\t/* restore old values */\n\toutb(b2, MSR(iobase));\n\tif (b3 != 0x90)\n\t\treturn c_uart_unknown;\n\tinb(RBR(iobase));\n\tinb(RBR(iobase));\n\toutb(0x01, FCR(iobase));\t/* enable FIFOs */\n\tu = uart_tab[(inb(IIR(iobase)) >> 6) & 3];\n\tif (u == c_uart_16450) {\n\t\toutb(0x5a, SCR(iobase));\n\t\tb1 = inb(SCR(iobase));\n\t\toutb(0xa5, SCR(iobase));\n\t\tb2 = inb(SCR(iobase));\n\t\tif ((b1 != 0x5a) || (b2 != 0xa5))\n\t\t\tu = c_uart_8250;\n\t}\n\treturn u;\n}\n\n/******************************************************************************\n* Rx Section\n******************************************************************************/\nstatic inline void yam_rx_flag(struct net_device *dev, struct yam_port *yp)\n{\n\tif (yp->dcd && yp->rx_len >= 3 && yp->rx_len < YAM_MAX_FRAME) {\n\t\tint pkt_len = yp->rx_len - 2 + 1;\t/* -CRC + kiss */\n\t\tstruct sk_buff *skb;\n\n\t\tif ((yp->rx_crch & yp->rx_crcl) != 0xFF) {\n\t\t\t/* Bad crc */\n\t\t} else {\n\t\t\tif (!(skb = dev_alloc_skb(pkt_len))) {\n\t\t\t\tprintk(KERN_WARNING \"%s: memory squeeze, dropping packet\\n\", dev->name);\n\t\t\t\t++dev->stats.rx_dropped;\n\t\t\t} else {\n\t\t\t\tunsigned char *cp;\n\t\t\t\tcp = skb_put(skb, pkt_len);\n\t\t\t\t*cp++ = 0;\t\t/* KISS kludge */\n\t\t\t\tmemcpy(cp, yp->rx_buf, pkt_len - 1);\n\t\t\t\tskb->protocol = ax25_type_trans(skb, dev);\n\t\t\t\tnetif_rx(skb);\n\t\t\t\t++dev->stats.rx_packets;\n\t\t\t}\n\t\t}\n\t}\n\typ->rx_len = 0;\n\typ->rx_crcl = 0x21;\n\typ->rx_crch = 0xf3;\n}\n\nstatic inline void yam_rx_byte(struct net_device *dev, struct yam_port *yp, unsigned char rxb)\n{\n\tif (yp->rx_len < YAM_MAX_FRAME) {\n\t\tunsigned char c = yp->rx_crcl;\n\t\typ->rx_crcl = (chktabl[c] ^ yp->rx_crch);\n\t\typ->rx_crch = (chktabh[c] ^ rxb);\n\t\typ->rx_buf[yp->rx_len++] = rxb;\n\t}\n}\n\n/********************************************************************************\n* TX Section\n********************************************************************************/\n\nstatic void ptt_on(struct net_device *dev)\n{\n\toutb(PTT_ON, MCR(dev->base_addr));\n}\n\nstatic void ptt_off(struct net_device *dev)\n{\n\toutb(PTT_OFF, MCR(dev->base_addr));\n}\n\nstatic netdev_tx_t yam_send_packet(struct sk_buff *skb,\n\t\t\t\t\t struct net_device *dev)\n{\n\tstruct yam_port *yp = netdev_priv(dev);\n\n\tskb_queue_tail(&yp->send_queue, skb);\n\tdev->trans_start = jiffies;\n\treturn NETDEV_TX_OK;\n}\n\nstatic void yam_start_tx(struct net_device *dev, struct yam_port *yp)\n{\n\tif ((yp->tx_state == TX_TAIL) || (yp->txd == 0))\n\t\typ->tx_count = 1;\n\telse\n\t\typ->tx_count = (yp->bitrate * yp->txd) / 8000;\n\typ->tx_state = TX_HEAD;\n\tptt_on(dev);\n}\n\nstatic void yam_arbitrate(struct net_device *dev)\n{\n\tstruct yam_port *yp = netdev_priv(dev);\n\n\tif (yp->magic != YAM_MAGIC || yp->tx_state != TX_OFF ||\n\t    skb_queue_empty(&yp->send_queue))\n\t\treturn;\n\t/* tx_state is TX_OFF and there is data to send */\n\n\tif (yp->dupmode) {\n\t\t/* Full duplex mode, don't wait */\n\t\tyam_start_tx(dev, yp);\n\t\treturn;\n\t}\n\tif (yp->dcd) {\n\t\t/* DCD on, wait slotime ... */\n\t\typ->slotcnt = yp->slot / 10;\n\t\treturn;\n\t}\n\t/* Is slottime passed ? */\n\tif ((--yp->slotcnt) > 0)\n\t\treturn;\n\n\typ->slotcnt = yp->slot / 10;\n\n\t/* is random > persist ? */\n\tif ((prandom_u32() % 256) > yp->pers)\n\t\treturn;\n\n\tyam_start_tx(dev, yp);\n}\n\nstatic void yam_dotimer(unsigned long dummy)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_PORTS; i++) {\n\t\tstruct net_device *dev = yam_devs[i];\n\t\tif (dev && netif_running(dev))\n\t\t\tyam_arbitrate(dev);\n\t}\n\tyam_timer.expires = jiffies + HZ / 100;\n\tadd_timer(&yam_timer);\n}\n\nstatic void yam_tx_byte(struct net_device *dev, struct yam_port *yp)\n{\n\tstruct sk_buff *skb;\n\tunsigned char b, temp;\n\n\tswitch (yp->tx_state) {\n\tcase TX_OFF:\n\t\tbreak;\n\tcase TX_HEAD:\n\t\tif (--yp->tx_count <= 0) {\n\t\t\tif (!(skb = skb_dequeue(&yp->send_queue))) {\n\t\t\t\tptt_off(dev);\n\t\t\t\typ->tx_state = TX_OFF;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\typ->tx_state = TX_DATA;\n\t\t\tif (skb->data[0] != 0) {\n/*                              do_kiss_params(s, skb->data, skb->len); */\n\t\t\t\tdev_kfree_skb_any(skb);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\typ->tx_len = skb->len - 1;\t/* strip KISS byte */\n\t\t\tif (yp->tx_len >= YAM_MAX_FRAME || yp->tx_len < 2) {\n        \t\t\tdev_kfree_skb_any(skb);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tskb_copy_from_linear_data_offset(skb, 1,\n\t\t\t\t\t\t\t yp->tx_buf,\n\t\t\t\t\t\t\t yp->tx_len);\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\typ->tx_count = 0;\n\t\t\typ->tx_crcl = 0x21;\n\t\t\typ->tx_crch = 0xf3;\n\t\t\typ->tx_state = TX_DATA;\n\t\t}\n\t\tbreak;\n\tcase TX_DATA:\n\t\tb = yp->tx_buf[yp->tx_count++];\n\t\toutb(b, THR(dev->base_addr));\n\t\ttemp = yp->tx_crcl;\n\t\typ->tx_crcl = chktabl[temp] ^ yp->tx_crch;\n\t\typ->tx_crch = chktabh[temp] ^ b;\n\t\tif (yp->tx_count >= yp->tx_len) {\n\t\t\typ->tx_state = TX_CRC1;\n\t\t}\n\t\tbreak;\n\tcase TX_CRC1:\n\t\typ->tx_crch = chktabl[yp->tx_crcl] ^ yp->tx_crch;\n\t\typ->tx_crcl = chktabh[yp->tx_crcl] ^ chktabl[yp->tx_crch] ^ 0xff;\n\t\toutb(yp->tx_crcl, THR(dev->base_addr));\n\t\typ->tx_state = TX_CRC2;\n\t\tbreak;\n\tcase TX_CRC2:\n\t\toutb(chktabh[yp->tx_crch] ^ 0xFF, THR(dev->base_addr));\n\t\tif (skb_queue_empty(&yp->send_queue)) {\n\t\t\typ->tx_count = (yp->bitrate * yp->txtail) / 8000;\n\t\t\tif (yp->dupmode == 2)\n\t\t\t\typ->tx_count += (yp->bitrate * yp->holdd) / 8;\n\t\t\tif (yp->tx_count == 0)\n\t\t\t\typ->tx_count = 1;\n\t\t\typ->tx_state = TX_TAIL;\n\t\t} else {\n\t\t\typ->tx_count = 1;\n\t\t\typ->tx_state = TX_HEAD;\n\t\t}\n\t\t++dev->stats.tx_packets;\n\t\tbreak;\n\tcase TX_TAIL:\n\t\tif (--yp->tx_count <= 0) {\n\t\t\typ->tx_state = TX_OFF;\n\t\t\tptt_off(dev);\n\t\t}\n\t\tbreak;\n\t}\n}\n\n/***********************************************************************************\n* ISR routine\n************************************************************************************/\n\nstatic irqreturn_t yam_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev;\n\tstruct yam_port *yp;\n\tunsigned char iir;\n\tint counter = 100;\n\tint i;\n\tint handled = 0;\n\n\tfor (i = 0; i < NR_PORTS; i++) {\n\t\tdev = yam_devs[i];\n\t\typ = netdev_priv(dev);\n\n\t\tif (!netif_running(dev))\n\t\t\tcontinue;\n\n\t\twhile ((iir = IIR_MASK & inb(IIR(dev->base_addr))) != IIR_NOPEND) {\n\t\t\tunsigned char msr = inb(MSR(dev->base_addr));\n\t\t\tunsigned char lsr = inb(LSR(dev->base_addr));\n\t\t\tunsigned char rxb;\n\n\t\t\thandled = 1;\n\n\t\t\tif (lsr & LSR_OE)\n\t\t\t\t++dev->stats.rx_fifo_errors;\n\n\t\t\typ->dcd = (msr & RX_DCD) ? 1 : 0;\n\n\t\t\tif (--counter <= 0) {\n\t\t\t\tprintk(KERN_ERR \"%s: too many irq iir=%d\\n\",\n\t\t\t\t\t\tdev->name, iir);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (msr & TX_RDY) {\n\t\t\t\t++yp->nb_mdint;\n\t\t\t\tyam_tx_byte(dev, yp);\n\t\t\t}\n\t\t\tif (lsr & LSR_RXC) {\n\t\t\t\t++yp->nb_rxint;\n\t\t\t\trxb = inb(RBR(dev->base_addr));\n\t\t\t\tif (msr & RX_FLAG)\n\t\t\t\t\tyam_rx_flag(dev, yp);\n\t\t\t\telse\n\t\t\t\t\tyam_rx_byte(dev, yp, rxb);\n\t\t\t}\n\t\t}\n\t}\nout:\n\treturn IRQ_RETVAL(handled);\n}\n\n#ifdef CONFIG_PROC_FS\n\nstatic void *yam_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\treturn (*pos < NR_PORTS) ? yam_devs[*pos] : NULL;\n}\n\nstatic void *yam_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\t++*pos;\n\treturn (*pos < NR_PORTS) ? yam_devs[*pos] : NULL;\n}\n\nstatic void yam_seq_stop(struct seq_file *seq, void *v)\n{\n}\n\nstatic int yam_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct net_device *dev = v;\n\tconst struct yam_port *yp = netdev_priv(dev);\n\n\tseq_printf(seq, \"Device %s\\n\", dev->name);\n\tseq_printf(seq, \"  Up       %d\\n\", netif_running(dev));\n\tseq_printf(seq, \"  Speed    %u\\n\", yp->bitrate);\n\tseq_printf(seq, \"  IoBase   0x%x\\n\", yp->iobase);\n\tseq_printf(seq, \"  BaudRate %u\\n\", yp->baudrate);\n\tseq_printf(seq, \"  IRQ      %u\\n\", yp->irq);\n\tseq_printf(seq, \"  TxState  %u\\n\", yp->tx_state);\n\tseq_printf(seq, \"  Duplex   %u\\n\", yp->dupmode);\n\tseq_printf(seq, \"  HoldDly  %u\\n\", yp->holdd);\n\tseq_printf(seq, \"  TxDelay  %u\\n\", yp->txd);\n\tseq_printf(seq, \"  TxTail   %u\\n\", yp->txtail);\n\tseq_printf(seq, \"  SlotTime %u\\n\", yp->slot);\n\tseq_printf(seq, \"  Persist  %u\\n\", yp->pers);\n\tseq_printf(seq, \"  TxFrames %lu\\n\", dev->stats.tx_packets);\n\tseq_printf(seq, \"  RxFrames %lu\\n\", dev->stats.rx_packets);\n\tseq_printf(seq, \"  TxInt    %u\\n\", yp->nb_mdint);\n\tseq_printf(seq, \"  RxInt    %u\\n\", yp->nb_rxint);\n\tseq_printf(seq, \"  RxOver   %lu\\n\", dev->stats.rx_fifo_errors);\n\tseq_printf(seq, \"\\n\");\n\treturn 0;\n}\n\nstatic const struct seq_operations yam_seqops = {\n\t.start = yam_seq_start,\n\t.next = yam_seq_next,\n\t.stop = yam_seq_stop,\n\t.show = yam_seq_show,\n};\n\nstatic int yam_info_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &yam_seqops);\n}\n\nstatic const struct file_operations yam_info_fops = {\n\t.owner = THIS_MODULE,\n\t.open = yam_info_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = seq_release,\n};\n\n#endif\n\n\n/* --------------------------------------------------------------------- */\n\nstatic int yam_open(struct net_device *dev)\n{\n\tstruct yam_port *yp = netdev_priv(dev);\n\tenum uart u;\n\tint i;\n\tint ret=0;\n\n\tprintk(KERN_INFO \"Trying %s at iobase 0x%lx irq %u\\n\", dev->name, dev->base_addr, dev->irq);\n\n\tif (!yp->bitrate)\n\t\treturn -ENXIO;\n\tif (!dev->base_addr || dev->base_addr > 0x1000 - YAM_EXTENT ||\n\t\tdev->irq < 2 || dev->irq > 15) {\n\t\treturn -ENXIO;\n\t}\n\tif (!request_region(dev->base_addr, YAM_EXTENT, dev->name))\n\t{\n\t\tprintk(KERN_ERR \"%s: cannot 0x%lx busy\\n\", dev->name, dev->base_addr);\n\t\treturn -EACCES;\n\t}\n\tif ((u = yam_check_uart(dev->base_addr)) == c_uart_unknown) {\n\t\tprintk(KERN_ERR \"%s: cannot find uart type\\n\", dev->name);\n\t\tret = -EIO;\n\t\tgoto out_release_base;\n\t}\n\tif (fpga_download(dev->base_addr, yp->bitrate)) {\n\t\tprintk(KERN_ERR \"%s: cannot init FPGA\\n\", dev->name);\n\t\tret = -EIO;\n\t\tgoto out_release_base;\n\t}\n\toutb(0, IER(dev->base_addr));\n\tif (request_irq(dev->irq, yam_interrupt, IRQF_SHARED, dev->name, dev)) {\n\t\tprintk(KERN_ERR \"%s: irq %d busy\\n\", dev->name, dev->irq);\n\t\tret = -EBUSY;\n\t\tgoto out_release_base;\n\t}\n\n\tyam_set_uart(dev);\n\n\tnetif_start_queue(dev);\n\t\n\typ->slotcnt = yp->slot / 10;\n\n\t/* Reset overruns for all ports - FPGA programming makes overruns */\n\tfor (i = 0; i < NR_PORTS; i++) {\n\t\tstruct net_device *yam_dev = yam_devs[i];\n\n\t\tinb(LSR(yam_dev->base_addr));\n\t\tyam_dev->stats.rx_fifo_errors = 0;\n\t}\n\n\tprintk(KERN_INFO \"%s at iobase 0x%lx irq %u uart %s\\n\", dev->name, dev->base_addr, dev->irq,\n\t\t   uart_str[u]);\n\treturn 0;\n\nout_release_base:\n\trelease_region(dev->base_addr, YAM_EXTENT);\n\treturn ret;\n}\n\n/* --------------------------------------------------------------------- */\n\nstatic int yam_close(struct net_device *dev)\n{\n\tstruct sk_buff *skb;\n\tstruct yam_port *yp = netdev_priv(dev);\n\n\tif (!dev)\n\t\treturn -EINVAL;\n\n\t/*\n\t * disable interrupts\n\t */\n\toutb(0, IER(dev->base_addr));\n\toutb(1, MCR(dev->base_addr));\n\t/* Remove IRQ handler if last */\n\tfree_irq(dev->irq,dev);\n\trelease_region(dev->base_addr, YAM_EXTENT);\n\tnetif_stop_queue(dev);\n\twhile ((skb = skb_dequeue(&yp->send_queue)))\n\t\tdev_kfree_skb(skb);\n\n\tprintk(KERN_INFO \"%s: close yam at iobase 0x%lx irq %u\\n\",\n\t\t   yam_drvname, dev->base_addr, dev->irq);\n\treturn 0;\n}\n\n/* --------------------------------------------------------------------- */\n\nstatic int yam_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\tstruct yam_port *yp = netdev_priv(dev);\n\tstruct yamdrv_ioctl_cfg yi;\n\tstruct yamdrv_ioctl_mcs *ym;\n\tint ioctl_cmd;\n\n\tif (copy_from_user(&ioctl_cmd, ifr->ifr_data, sizeof(int)))\n\t\t return -EFAULT;\n\n\tif (yp->magic != YAM_MAGIC)\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (cmd != SIOCDEVPRIVATE)\n\t\treturn -EINVAL;\n\n\tswitch (ioctl_cmd) {\n\n\tcase SIOCYAMRESERVED:\n\t\treturn -EINVAL;\t\t\t/* unused */\n\n\tcase SIOCYAMSMCS:\n\t\tif (netif_running(dev))\n\t\t\treturn -EINVAL;\t\t/* Cannot change this parameter when up */\n\t\tif ((ym = kmalloc(sizeof(struct yamdrv_ioctl_mcs), GFP_KERNEL)) == NULL)\n\t\t\treturn -ENOBUFS;\n\t\tif (copy_from_user(ym, ifr->ifr_data, sizeof(struct yamdrv_ioctl_mcs))) {\n\t\t\tkfree(ym);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tif (ym->bitrate > YAM_MAXBITRATE) {\n\t\t\tkfree(ym);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t/* setting predef as 0 for loading userdefined mcs data */\n\t\tadd_mcs(ym->bits, ym->bitrate, 0);\n\t\tkfree(ym);\n\t\tbreak;\n\n\tcase SIOCYAMSCFG:\n\t\tif (!capable(CAP_SYS_RAWIO))\n\t\t\treturn -EPERM;\n\t\tif (copy_from_user(&yi, ifr->ifr_data, sizeof(struct yamdrv_ioctl_cfg)))\n\t\t\t return -EFAULT;\n\n\t\tif ((yi.cfg.mask & YAM_IOBASE) && netif_running(dev))\n\t\t\treturn -EINVAL;\t\t/* Cannot change this parameter when up */\n\t\tif ((yi.cfg.mask & YAM_IRQ) && netif_running(dev))\n\t\t\treturn -EINVAL;\t\t/* Cannot change this parameter when up */\n\t\tif ((yi.cfg.mask & YAM_BITRATE) && netif_running(dev))\n\t\t\treturn -EINVAL;\t\t/* Cannot change this parameter when up */\n\t\tif ((yi.cfg.mask & YAM_BAUDRATE) && netif_running(dev))\n\t\t\treturn -EINVAL;\t\t/* Cannot change this parameter when up */\n\n\t\tif (yi.cfg.mask & YAM_IOBASE) {\n\t\t\typ->iobase = yi.cfg.iobase;\n\t\t\tdev->base_addr = yi.cfg.iobase;\n\t\t}\n\t\tif (yi.cfg.mask & YAM_IRQ) {\n\t\t\tif (yi.cfg.irq > 15)\n\t\t\t\treturn -EINVAL;\n\t\t\typ->irq = yi.cfg.irq;\n\t\t\tdev->irq = yi.cfg.irq;\n\t\t}\n\t\tif (yi.cfg.mask & YAM_BITRATE) {\n\t\t\tif (yi.cfg.bitrate > YAM_MAXBITRATE)\n\t\t\t\treturn -EINVAL;\n\t\t\typ->bitrate = yi.cfg.bitrate;\n\t\t}\n\t\tif (yi.cfg.mask & YAM_BAUDRATE) {\n\t\t\tif (yi.cfg.baudrate > YAM_MAXBAUDRATE)\n\t\t\t\treturn -EINVAL;\n\t\t\typ->baudrate = yi.cfg.baudrate;\n\t\t}\n\t\tif (yi.cfg.mask & YAM_MODE) {\n\t\t\tif (yi.cfg.mode > YAM_MAXMODE)\n\t\t\t\treturn -EINVAL;\n\t\t\typ->dupmode = yi.cfg.mode;\n\t\t}\n\t\tif (yi.cfg.mask & YAM_HOLDDLY) {\n\t\t\tif (yi.cfg.holddly > YAM_MAXHOLDDLY)\n\t\t\t\treturn -EINVAL;\n\t\t\typ->holdd = yi.cfg.holddly;\n\t\t}\n\t\tif (yi.cfg.mask & YAM_TXDELAY) {\n\t\t\tif (yi.cfg.txdelay > YAM_MAXTXDELAY)\n\t\t\t\treturn -EINVAL;\n\t\t\typ->txd = yi.cfg.txdelay;\n\t\t}\n\t\tif (yi.cfg.mask & YAM_TXTAIL) {\n\t\t\tif (yi.cfg.txtail > YAM_MAXTXTAIL)\n\t\t\t\treturn -EINVAL;\n\t\t\typ->txtail = yi.cfg.txtail;\n\t\t}\n\t\tif (yi.cfg.mask & YAM_PERSIST) {\n\t\t\tif (yi.cfg.persist > YAM_MAXPERSIST)\n\t\t\t\treturn -EINVAL;\n\t\t\typ->pers = yi.cfg.persist;\n\t\t}\n\t\tif (yi.cfg.mask & YAM_SLOTTIME) {\n\t\t\tif (yi.cfg.slottime > YAM_MAXSLOTTIME)\n\t\t\t\treturn -EINVAL;\n\t\t\typ->slot = yi.cfg.slottime;\n\t\t\typ->slotcnt = yp->slot / 10;\n\t\t}\n\t\tbreak;\n\n\tcase SIOCYAMGCFG:\n\t\tyi.cfg.mask = 0xffffffff;\n\t\tyi.cfg.iobase = yp->iobase;\n\t\tyi.cfg.irq = yp->irq;\n\t\tyi.cfg.bitrate = yp->bitrate;\n\t\tyi.cfg.baudrate = yp->baudrate;\n\t\tyi.cfg.mode = yp->dupmode;\n\t\tyi.cfg.txdelay = yp->txd;\n\t\tyi.cfg.holddly = yp->holdd;\n\t\tyi.cfg.txtail = yp->txtail;\n\t\tyi.cfg.persist = yp->pers;\n\t\tyi.cfg.slottime = yp->slot;\n\t\tif (copy_to_user(ifr->ifr_data, &yi, sizeof(struct yamdrv_ioctl_cfg)))\n\t\t\t return -EFAULT;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\n\t}\n\n\treturn 0;\n}\n\n/* --------------------------------------------------------------------- */\n\nstatic int yam_set_mac_address(struct net_device *dev, void *addr)\n{\n\tstruct sockaddr *sa = (struct sockaddr *) addr;\n\n\t/* addr is an AX.25 shifted ASCII mac address */\n\tmemcpy(dev->dev_addr, sa->sa_data, dev->addr_len);\n\treturn 0;\n}\n\n/* --------------------------------------------------------------------- */\n\nstatic const struct net_device_ops yam_netdev_ops = {\n\t.ndo_open\t     = yam_open,\n\t.ndo_stop\t     = yam_close,\n\t.ndo_start_xmit      = yam_send_packet,\n\t.ndo_do_ioctl \t     = yam_ioctl,\n\t.ndo_set_mac_address = yam_set_mac_address,\n};\n\nstatic void yam_setup(struct net_device *dev)\n{\n\tstruct yam_port *yp = netdev_priv(dev);\n\n\typ->magic = YAM_MAGIC;\n\typ->bitrate = DEFAULT_BITRATE;\n\typ->baudrate = DEFAULT_BITRATE * 2;\n\typ->iobase = 0;\n\typ->irq = 0;\n\typ->dupmode = 0;\n\typ->holdd = DEFAULT_HOLDD;\n\typ->txd = DEFAULT_TXD;\n\typ->txtail = DEFAULT_TXTAIL;\n\typ->slot = DEFAULT_SLOT;\n\typ->pers = DEFAULT_PERS;\n\typ->dev = dev;\n\n\tdev->base_addr = yp->iobase;\n\tdev->irq = yp->irq;\n\n\tskb_queue_head_init(&yp->send_queue);\n\n\tdev->netdev_ops = &yam_netdev_ops;\n\tdev->header_ops = &ax25_header_ops;\n\n\tdev->type = ARPHRD_AX25;\n\tdev->hard_header_len = AX25_MAX_HEADER_LEN;\n\tdev->mtu = AX25_MTU;\n\tdev->addr_len = AX25_ADDR_LEN;\n\tmemcpy(dev->broadcast, &ax25_bcast, AX25_ADDR_LEN);\n\tmemcpy(dev->dev_addr, &ax25_defaddr, AX25_ADDR_LEN);\n}\n\nstatic int __init yam_init_driver(void)\n{\n\tstruct net_device *dev;\n\tint i, err;\n\tchar name[IFNAMSIZ];\n\n\tprintk(yam_drvinfo);\n\n\tfor (i = 0; i < NR_PORTS; i++) {\n\t\tsprintf(name, \"yam%d\", i);\n\t\t\n\t\tdev = alloc_netdev(sizeof(struct yam_port), name,\n\t\t\t\t   yam_setup);\n\t\tif (!dev) {\n\t\t\tpr_err(\"yam: cannot allocate net device\\n\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\t\t\n\t\terr = register_netdev(dev);\n\t\tif (err) {\n\t\t\tprintk(KERN_WARNING \"yam: cannot register net device %s\\n\", dev->name);\n\t\t\tgoto error;\n\t\t}\n\t\tyam_devs[i] = dev;\n\n\t}\n\n\tyam_timer.function = yam_dotimer;\n\tyam_timer.expires = jiffies + HZ / 100;\n\tadd_timer(&yam_timer);\n\n\tproc_create(\"yam\", S_IRUGO, init_net.proc_net, &yam_info_fops);\n\treturn 0;\n error:\n\twhile (--i >= 0) {\n\t\tunregister_netdev(yam_devs[i]);\n\t\tfree_netdev(yam_devs[i]);\n\t}\n\treturn err;\n}\n\n/* --------------------------------------------------------------------- */\n\nstatic void __exit yam_cleanup_driver(void)\n{\n\tstruct yam_mcs *p;\n\tint i;\n\n\tdel_timer(&yam_timer);\n\tfor (i = 0; i < NR_PORTS; i++) {\n\t\tstruct net_device *dev = yam_devs[i];\n\t\tif (dev) {\n\t\t\tunregister_netdev(dev);\n\t\t\tfree_netdev(dev);\n\t\t}\n\t}\n\n\twhile (yam_data) {\n\t\tp = yam_data;\n\t\tyam_data = yam_data->next;\n\t\tkfree(p);\n\t}\n\n\tremove_proc_entry(\"yam\", init_net.proc_net);\n}\n\n/* --------------------------------------------------------------------- */\n\nMODULE_AUTHOR(\"Frederic Rible F1OAT frible@teaser.fr\");\nMODULE_DESCRIPTION(\"Yam amateur radio modem driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(FIRMWARE_1200);\nMODULE_FIRMWARE(FIRMWARE_9600);\n\nmodule_init(yam_init_driver);\nmodule_exit(yam_cleanup_driver);\n\n/* --------------------------------------------------------------------- */\n\n"], "fixing_code": ["/*****************************************************************************/\n\n/*\n *    yam.c  -- YAM radio modem driver.\n *\n *      Copyright (C) 1998 Frederic Rible F1OAT (frible@teaser.fr)\n *      Adapted from baycom.c driver written by Thomas Sailer (sailer@ife.ee.ethz.ch)\n *\n *      This program is free software; you can redistribute it and/or modify\n *      it under the terms of the GNU General Public License as published by\n *      the Free Software Foundation; either version 2 of the License, or\n *      (at your option) any later version.\n *\n *      This program is distributed in the hope that it will be useful,\n *      but WITHOUT ANY WARRANTY; without even the implied warranty of\n *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *      GNU General Public License for more details.\n *\n *      You should have received a copy of the GNU General Public License\n *      along with this program; if not, write to the Free Software\n *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n *  Please note that the GPL allows you to use the driver, NOT the radio.\n *  In order to use the radio, you need a license from the communications\n *  authority of your country.\n *\n *\n *  History:\n *   0.0 F1OAT 06.06.98  Begin of work with baycom.c source code V 0.3\n *   0.1 F1OAT 07.06.98  Add timer polling routine for channel arbitration\n *   0.2 F6FBB 08.06.98  Added delay after FPGA programming\n *   0.3 F6FBB 29.07.98  Delayed PTT implementation for dupmode=2\n *   0.4 F6FBB 30.07.98  Added TxTail, Slottime and Persistence\n *   0.5 F6FBB 01.08.98  Shared IRQs, /proc/net and network statistics\n *   0.6 F6FBB 25.08.98  Added 1200Bds format\n *   0.7 F6FBB 12.09.98  Added to the kernel configuration\n *   0.8 F6FBB 14.10.98  Fixed slottime/persistence timing bug\n *       OK1ZIA 2.09.01  Fixed \"kfree_skb on hard IRQ\" \n *                       using dev_kfree_skb_any(). (important in 2.4 kernel)\n *   \n */\n\n/*****************************************************************************/\n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <linux/if.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/random.h>\n#include <asm/io.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/firmware.h>\n#include <linux/platform_device.h>\n\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <net/ax25.h>\n\n#include <linux/kernel.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <net/net_namespace.h>\n\n#include <asm/uaccess.h>\n#include <linux/init.h>\n\n#include <linux/yam.h>\n\n/* --------------------------------------------------------------------- */\n\nstatic const char yam_drvname[] = \"yam\";\nstatic const char yam_drvinfo[] __initconst = KERN_INFO \\\n\t\"YAM driver version 0.8 by F1OAT/F6FBB\\n\";\n\n/* --------------------------------------------------------------------- */\n\n#define FIRMWARE_9600\t\"yam/9600.bin\"\n#define FIRMWARE_1200\t\"yam/1200.bin\"\n\n#define YAM_9600\t1\n#define YAM_1200\t2\n\n#define NR_PORTS\t4\n#define YAM_MAGIC\t0xF10A7654\n\n/* Transmitter states */\n\n#define TX_OFF\t\t0\n#define TX_HEAD\t\t1\n#define TX_DATA\t\t2\n#define TX_CRC1\t\t3\n#define TX_CRC2\t\t4\n#define TX_TAIL\t\t5\n\n#define YAM_MAX_FRAME\t1024\n\n#define DEFAULT_BITRATE\t9600\t\t\t/* bps */\n#define DEFAULT_HOLDD\t10\t\t\t/* sec */\n#define DEFAULT_TXD\t300\t\t\t/* ms */\n#define DEFAULT_TXTAIL\t10\t\t\t/* ms */\n#define DEFAULT_SLOT\t100\t\t\t/* ms */\n#define DEFAULT_PERS\t64\t\t\t/* 0->255 */\n\nstruct yam_port {\n\tint magic;\n\tint bitrate;\n\tint baudrate;\n\tint iobase;\n\tint irq;\n\tint dupmode;\n\n\tstruct net_device *dev;\n\n\tint nb_rxint;\n\tint nb_mdint;\n\n\t/* Parameters section */\n\n\tint txd;\t\t\t\t/* tx delay */\n\tint holdd;\t\t\t\t/* duplex ptt delay */\n\tint txtail;\t\t\t\t/* txtail delay */\n\tint slot;\t\t\t\t/* slottime */\n\tint pers;\t\t\t\t/* persistence */\n\n\t/* Tx section */\n\n\tint tx_state;\n\tint tx_count;\n\tint slotcnt;\n\tunsigned char tx_buf[YAM_MAX_FRAME];\n\tint tx_len;\n\tint tx_crcl, tx_crch;\n\tstruct sk_buff_head send_queue;\t\t/* Packets awaiting transmission */\n\n\t/* Rx section */\n\n\tint dcd;\n\tunsigned char rx_buf[YAM_MAX_FRAME];\n\tint rx_len;\n\tint rx_crcl, rx_crch;\n};\n\nstruct yam_mcs {\n\tunsigned char bits[YAM_FPGA_SIZE];\n\tint bitrate;\n\tstruct yam_mcs *next;\n};\n\nstatic struct net_device *yam_devs[NR_PORTS];\n\nstatic struct yam_mcs *yam_data;\n\nstatic DEFINE_TIMER(yam_timer, NULL, 0, 0);\n\n/* --------------------------------------------------------------------- */\n\n#define RBR(iobase)\t(iobase+0)\n#define THR(iobase)\t(iobase+0)\n#define IER(iobase)\t(iobase+1)\n#define IIR(iobase)\t(iobase+2)\n#define FCR(iobase)\t(iobase+2)\n#define LCR(iobase)\t(iobase+3)\n#define MCR(iobase)\t(iobase+4)\n#define LSR(iobase)\t(iobase+5)\n#define MSR(iobase)\t(iobase+6)\n#define SCR(iobase)\t(iobase+7)\n#define DLL(iobase)\t(iobase+0)\n#define DLM(iobase)\t(iobase+1)\n\n#define YAM_EXTENT\t8\n\n/* Interrupt Identification Register Bit Masks */\n#define IIR_NOPEND\t1\n#define IIR_MSR\t\t0\n#define IIR_TX\t\t2\n#define IIR_RX\t\t4\n#define IIR_LSR\t\t6\n#define IIR_TIMEOUT\t12\t\t\t/* Fifo mode only */\n\n#define IIR_MASK\t0x0F\n\n/* Interrupt Enable Register Bit Masks */\n#define IER_RX\t\t1\t\t\t/* enable rx interrupt */\n#define IER_TX\t\t2\t\t\t/* enable tx interrupt */\n#define IER_LSR\t\t4\t\t\t/* enable line status interrupts */\n#define IER_MSR\t\t8\t\t\t/* enable modem status interrupts */\n\n/* Modem Control Register Bit Masks */\n#define MCR_DTR\t\t0x01\t\t\t/* DTR output */\n#define MCR_RTS\t\t0x02\t\t\t/* RTS output */\n#define MCR_OUT1\t0x04\t\t\t/* OUT1 output (not accessible in RS232) */\n#define MCR_OUT2\t0x08\t\t\t/* Master Interrupt enable (must be set on PCs) */\n#define MCR_LOOP\t0x10\t\t\t/* Loopback enable */\n\n/* Modem Status Register Bit Masks */\n#define MSR_DCTS\t0x01\t\t\t/* Delta CTS input */\n#define MSR_DDSR\t0x02\t\t\t/* Delta DSR */\n#define MSR_DRIN\t0x04\t\t\t/* Delta RI */\n#define MSR_DDCD\t0x08\t\t\t/* Delta DCD */\n#define MSR_CTS\t\t0x10\t\t\t/* CTS input */\n#define MSR_DSR\t\t0x20\t\t\t/* DSR input */\n#define MSR_RING\t0x40\t\t\t/* RI  input */\n#define MSR_DCD\t\t0x80\t\t\t/* DCD input */\n\n/* line status register bit mask */\n#define LSR_RXC\t\t0x01\n#define LSR_OE\t\t0x02\n#define LSR_PE\t\t0x04\n#define LSR_FE\t\t0x08\n#define LSR_BREAK\t0x10\n#define LSR_THRE\t0x20\n#define LSR_TSRE\t0x40\n\n/* Line Control Register Bit Masks */\n#define LCR_DLAB\t0x80\n#define LCR_BREAK\t0x40\n#define LCR_PZERO\t0x28\n#define LCR_PEVEN\t0x18\n#define LCR_PODD\t0x08\n#define LCR_STOP1\t0x00\n#define LCR_STOP2\t0x04\n#define LCR_BIT5\t0x00\n#define LCR_BIT6\t0x02\n#define LCR_BIT7\t0x01\n#define LCR_BIT8\t0x03\n\n/* YAM Modem <-> UART Port mapping */\n\n#define TX_RDY\t\tMSR_DCTS\t\t/* transmitter ready to send */\n#define RX_DCD\t\tMSR_DCD\t\t\t/* carrier detect */\n#define RX_FLAG\t\tMSR_RING\t\t/* hdlc flag received */\n#define FPGA_DONE\tMSR_DSR\t\t\t/* FPGA is configured */\n#define PTT_ON\t\t(MCR_RTS|MCR_OUT2)\t/* activate PTT */\n#define PTT_OFF\t\t(MCR_DTR|MCR_OUT2)\t/* release PTT */\n\n#define ENABLE_RXINT\tIER_RX\t\t\t/* enable uart rx interrupt during rx */\n#define ENABLE_TXINT\tIER_MSR\t\t\t/* enable uart ms interrupt during tx */\n#define ENABLE_RTXINT\t(IER_RX|IER_MSR)\t/* full duplex operations */\n\n\n/*************************************************************************\n* CRC Tables\n************************************************************************/\n\nstatic const unsigned char chktabl[256] =\n{0x00, 0x89, 0x12, 0x9b, 0x24, 0xad, 0x36, 0xbf, 0x48, 0xc1, 0x5a, 0xd3, 0x6c, 0xe5, 0x7e,\n 0xf7, 0x81, 0x08, 0x93, 0x1a, 0xa5, 0x2c, 0xb7, 0x3e, 0xc9, 0x40, 0xdb, 0x52, 0xed, 0x64,\n 0xff, 0x76, 0x02, 0x8b, 0x10, 0x99, 0x26, 0xaf, 0x34, 0xbd, 0x4a, 0xc3, 0x58, 0xd1, 0x6e,\n 0xe7, 0x7c, 0xf5, 0x83, 0x0a, 0x91, 0x18, 0xa7, 0x2e, 0xb5, 0x3c, 0xcb, 0x42, 0xd9, 0x50,\n 0xef, 0x66, 0xfd, 0x74, 0x04, 0x8d, 0x16, 0x9f, 0x20, 0xa9, 0x32, 0xbb, 0x4c, 0xc5, 0x5e,\n 0xd7, 0x68, 0xe1, 0x7a, 0xf3, 0x85, 0x0c, 0x97, 0x1e, 0xa1, 0x28, 0xb3, 0x3a, 0xcd, 0x44,\n 0xdf, 0x56, 0xe9, 0x60, 0xfb, 0x72, 0x06, 0x8f, 0x14, 0x9d, 0x22, 0xab, 0x30, 0xb9, 0x4e,\n 0xc7, 0x5c, 0xd5, 0x6a, 0xe3, 0x78, 0xf1, 0x87, 0x0e, 0x95, 0x1c, 0xa3, 0x2a, 0xb1, 0x38,\n 0xcf, 0x46, 0xdd, 0x54, 0xeb, 0x62, 0xf9, 0x70, 0x08, 0x81, 0x1a, 0x93, 0x2c, 0xa5, 0x3e,\n 0xb7, 0x40, 0xc9, 0x52, 0xdb, 0x64, 0xed, 0x76, 0xff, 0x89, 0x00, 0x9b, 0x12, 0xad, 0x24,\n 0xbf, 0x36, 0xc1, 0x48, 0xd3, 0x5a, 0xe5, 0x6c, 0xf7, 0x7e, 0x0a, 0x83, 0x18, 0x91, 0x2e,\n 0xa7, 0x3c, 0xb5, 0x42, 0xcb, 0x50, 0xd9, 0x66, 0xef, 0x74, 0xfd, 0x8b, 0x02, 0x99, 0x10,\n 0xaf, 0x26, 0xbd, 0x34, 0xc3, 0x4a, 0xd1, 0x58, 0xe7, 0x6e, 0xf5, 0x7c, 0x0c, 0x85, 0x1e,\n 0x97, 0x28, 0xa1, 0x3a, 0xb3, 0x44, 0xcd, 0x56, 0xdf, 0x60, 0xe9, 0x72, 0xfb, 0x8d, 0x04,\n 0x9f, 0x16, 0xa9, 0x20, 0xbb, 0x32, 0xc5, 0x4c, 0xd7, 0x5e, 0xe1, 0x68, 0xf3, 0x7a, 0x0e,\n 0x87, 0x1c, 0x95, 0x2a, 0xa3, 0x38, 0xb1, 0x46, 0xcf, 0x54, 0xdd, 0x62, 0xeb, 0x70, 0xf9,\n 0x8f, 0x06, 0x9d, 0x14, 0xab, 0x22, 0xb9, 0x30, 0xc7, 0x4e, 0xd5, 0x5c, 0xe3, 0x6a, 0xf1,\n 0x78};\nstatic const unsigned char chktabh[256] =\n{0x00, 0x11, 0x23, 0x32, 0x46, 0x57, 0x65, 0x74, 0x8c, 0x9d, 0xaf, 0xbe, 0xca, 0xdb, 0xe9,\n 0xf8, 0x10, 0x01, 0x33, 0x22, 0x56, 0x47, 0x75, 0x64, 0x9c, 0x8d, 0xbf, 0xae, 0xda, 0xcb,\n 0xf9, 0xe8, 0x21, 0x30, 0x02, 0x13, 0x67, 0x76, 0x44, 0x55, 0xad, 0xbc, 0x8e, 0x9f, 0xeb,\n 0xfa, 0xc8, 0xd9, 0x31, 0x20, 0x12, 0x03, 0x77, 0x66, 0x54, 0x45, 0xbd, 0xac, 0x9e, 0x8f,\n 0xfb, 0xea, 0xd8, 0xc9, 0x42, 0x53, 0x61, 0x70, 0x04, 0x15, 0x27, 0x36, 0xce, 0xdf, 0xed,\n 0xfc, 0x88, 0x99, 0xab, 0xba, 0x52, 0x43, 0x71, 0x60, 0x14, 0x05, 0x37, 0x26, 0xde, 0xcf,\n 0xfd, 0xec, 0x98, 0x89, 0xbb, 0xaa, 0x63, 0x72, 0x40, 0x51, 0x25, 0x34, 0x06, 0x17, 0xef,\n 0xfe, 0xcc, 0xdd, 0xa9, 0xb8, 0x8a, 0x9b, 0x73, 0x62, 0x50, 0x41, 0x35, 0x24, 0x16, 0x07,\n 0xff, 0xee, 0xdc, 0xcd, 0xb9, 0xa8, 0x9a, 0x8b, 0x84, 0x95, 0xa7, 0xb6, 0xc2, 0xd3, 0xe1,\n 0xf0, 0x08, 0x19, 0x2b, 0x3a, 0x4e, 0x5f, 0x6d, 0x7c, 0x94, 0x85, 0xb7, 0xa6, 0xd2, 0xc3,\n 0xf1, 0xe0, 0x18, 0x09, 0x3b, 0x2a, 0x5e, 0x4f, 0x7d, 0x6c, 0xa5, 0xb4, 0x86, 0x97, 0xe3,\n 0xf2, 0xc0, 0xd1, 0x29, 0x38, 0x0a, 0x1b, 0x6f, 0x7e, 0x4c, 0x5d, 0xb5, 0xa4, 0x96, 0x87,\n 0xf3, 0xe2, 0xd0, 0xc1, 0x39, 0x28, 0x1a, 0x0b, 0x7f, 0x6e, 0x5c, 0x4d, 0xc6, 0xd7, 0xe5,\n 0xf4, 0x80, 0x91, 0xa3, 0xb2, 0x4a, 0x5b, 0x69, 0x78, 0x0c, 0x1d, 0x2f, 0x3e, 0xd6, 0xc7,\n 0xf5, 0xe4, 0x90, 0x81, 0xb3, 0xa2, 0x5a, 0x4b, 0x79, 0x68, 0x1c, 0x0d, 0x3f, 0x2e, 0xe7,\n 0xf6, 0xc4, 0xd5, 0xa1, 0xb0, 0x82, 0x93, 0x6b, 0x7a, 0x48, 0x59, 0x2d, 0x3c, 0x0e, 0x1f,\n 0xf7, 0xe6, 0xd4, 0xc5, 0xb1, 0xa0, 0x92, 0x83, 0x7b, 0x6a, 0x58, 0x49, 0x3d, 0x2c, 0x1e,\n 0x0f};\n\n/*************************************************************************\n* FPGA functions\n************************************************************************/\n\nstatic void delay(int ms)\n{\n\tunsigned long timeout = jiffies + ((ms * HZ) / 1000);\n\twhile (time_before(jiffies, timeout))\n\t\tcpu_relax();\n}\n\n/*\n * reset FPGA\n */\n\nstatic void fpga_reset(int iobase)\n{\n\toutb(0, IER(iobase));\n\toutb(LCR_DLAB | LCR_BIT5, LCR(iobase));\n\toutb(1, DLL(iobase));\n\toutb(0, DLM(iobase));\n\n\toutb(LCR_BIT5, LCR(iobase));\n\tinb(LSR(iobase));\n\tinb(MSR(iobase));\n\t/* turn off FPGA supply voltage */\n\toutb(MCR_OUT1 | MCR_OUT2, MCR(iobase));\n\tdelay(100);\n\t/* turn on FPGA supply voltage again */\n\toutb(MCR_DTR | MCR_RTS | MCR_OUT1 | MCR_OUT2, MCR(iobase));\n\tdelay(100);\n}\n\n/*\n * send one byte to FPGA\n */\n\nstatic int fpga_write(int iobase, unsigned char wrd)\n{\n\tunsigned char bit;\n\tint k;\n\tunsigned long timeout = jiffies + HZ / 10;\n\n\tfor (k = 0; k < 8; k++) {\n\t\tbit = (wrd & 0x80) ? (MCR_RTS | MCR_DTR) : MCR_DTR;\n\t\toutb(bit | MCR_OUT1 | MCR_OUT2, MCR(iobase));\n\t\twrd <<= 1;\n\t\toutb(0xfc, THR(iobase));\n\t\twhile ((inb(LSR(iobase)) & LSR_TSRE) == 0)\n\t\t\tif (time_after(jiffies, timeout))\n\t\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n/*\n * predef should be 0 for loading user defined mcs\n * predef should be YAM_1200 for loading predef 1200 mcs\n * predef should be YAM_9600 for loading predef 9600 mcs\n */\nstatic unsigned char *add_mcs(unsigned char *bits, int bitrate,\n\t\t\t      unsigned int predef)\n{\n\tconst char *fw_name[2] = {FIRMWARE_9600, FIRMWARE_1200};\n\tconst struct firmware *fw;\n\tstruct platform_device *pdev;\n\tstruct yam_mcs *p;\n\tint err;\n\n\tswitch (predef) {\n\tcase 0:\n\t\tfw = NULL;\n\t\tbreak;\n\tcase YAM_1200:\n\tcase YAM_9600:\n\t\tpredef--;\n\t\tpdev = platform_device_register_simple(\"yam\", 0, NULL, 0);\n\t\tif (IS_ERR(pdev)) {\n\t\t\tprintk(KERN_ERR \"yam: Failed to register firmware\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\terr = request_firmware(&fw, fw_name[predef], &pdev->dev);\n\t\tplatform_device_unregister(pdev);\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR \"Failed to load firmware \\\"%s\\\"\\n\",\n\t\t\t       fw_name[predef]);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (fw->size != YAM_FPGA_SIZE) {\n\t\t\tprintk(KERN_ERR \"Bogus length %zu in firmware \\\"%s\\\"\\n\",\n\t\t\t       fw->size, fw_name[predef]);\n\t\t\trelease_firmware(fw);\n\t\t\treturn NULL;\n\t\t}\n\t\tbits = (unsigned char *)fw->data;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"yam: Invalid predef number %u\\n\", predef);\n\t\treturn NULL;\n\t}\n\n\t/* If it already exists, replace the bit data */\n\tp = yam_data;\n\twhile (p) {\n\t\tif (p->bitrate == bitrate) {\n\t\t\tmemcpy(p->bits, bits, YAM_FPGA_SIZE);\n\t\t\tgoto out;\n\t\t}\n\t\tp = p->next;\n\t}\n\n\t/* Allocate a new mcs */\n\tif ((p = kmalloc(sizeof(struct yam_mcs), GFP_KERNEL)) == NULL) {\n\t\trelease_firmware(fw);\n\t\treturn NULL;\n\t}\n\tmemcpy(p->bits, bits, YAM_FPGA_SIZE);\n\tp->bitrate = bitrate;\n\tp->next = yam_data;\n\tyam_data = p;\n out:\n\trelease_firmware(fw);\n\treturn p->bits;\n}\n\nstatic unsigned char *get_mcs(int bitrate)\n{\n\tstruct yam_mcs *p;\n\n\tp = yam_data;\n\twhile (p) {\n\t\tif (p->bitrate == bitrate)\n\t\t\treturn p->bits;\n\t\tp = p->next;\n\t}\n\n\t/* Load predefined mcs data */\n\tswitch (bitrate) {\n\tcase 1200:\n\t\t/* setting predef as YAM_1200 for loading predef 1200 mcs */\n\t\treturn add_mcs(NULL, bitrate, YAM_1200);\n\tdefault:\n\t\t/* setting predef as YAM_9600 for loading predef 9600 mcs */\n\t\treturn add_mcs(NULL, bitrate, YAM_9600);\n\t}\n}\n\n/*\n * download bitstream to FPGA\n * data is contained in bits[] array in yam1200.h resp. yam9600.h\n */\n\nstatic int fpga_download(int iobase, int bitrate)\n{\n\tint i, rc;\n\tunsigned char *pbits;\n\n\tpbits = get_mcs(bitrate);\n\tif (pbits == NULL)\n\t\treturn -1;\n\n\tfpga_reset(iobase);\n\tfor (i = 0; i < YAM_FPGA_SIZE; i++) {\n\t\tif (fpga_write(iobase, pbits[i])) {\n\t\t\tprintk(KERN_ERR \"yam: error in write cycle\\n\");\n\t\t\treturn -1;\t\t\t/* write... */\n\t\t}\n\t}\n\n\tfpga_write(iobase, 0xFF);\n\trc = inb(MSR(iobase));\t\t/* check DONE signal */\n\n\t/* Needed for some hardwares */\n\tdelay(50);\n\n\treturn (rc & MSR_DSR) ? 0 : -1;\n}\n\n\n/************************************************************************\n* Serial port init \n************************************************************************/\n\nstatic void yam_set_uart(struct net_device *dev)\n{\n\tstruct yam_port *yp = netdev_priv(dev);\n\tint divisor = 115200 / yp->baudrate;\n\n\toutb(0, IER(dev->base_addr));\n\toutb(LCR_DLAB | LCR_BIT8, LCR(dev->base_addr));\n\toutb(divisor, DLL(dev->base_addr));\n\toutb(0, DLM(dev->base_addr));\n\toutb(LCR_BIT8, LCR(dev->base_addr));\n\toutb(PTT_OFF, MCR(dev->base_addr));\n\toutb(0x00, FCR(dev->base_addr));\n\n\t/* Flush pending irq */\n\n\tinb(RBR(dev->base_addr));\n\tinb(MSR(dev->base_addr));\n\n\t/* Enable rx irq */\n\n\toutb(ENABLE_RTXINT, IER(dev->base_addr));\n}\n\n\n/* --------------------------------------------------------------------- */\n\nenum uart {\n\tc_uart_unknown, c_uart_8250,\n\tc_uart_16450, c_uart_16550, c_uart_16550A\n};\n\nstatic const char *uart_str[] =\n{\"unknown\", \"8250\", \"16450\", \"16550\", \"16550A\"};\n\nstatic enum uart yam_check_uart(unsigned int iobase)\n{\n\tunsigned char b1, b2, b3;\n\tenum uart u;\n\tenum uart uart_tab[] =\n\t{c_uart_16450, c_uart_unknown, c_uart_16550, c_uart_16550A};\n\n\tb1 = inb(MCR(iobase));\n\toutb(b1 | 0x10, MCR(iobase));\t/* loopback mode */\n\tb2 = inb(MSR(iobase));\n\toutb(0x1a, MCR(iobase));\n\tb3 = inb(MSR(iobase)) & 0xf0;\n\toutb(b1, MCR(iobase));\t\t/* restore old values */\n\toutb(b2, MSR(iobase));\n\tif (b3 != 0x90)\n\t\treturn c_uart_unknown;\n\tinb(RBR(iobase));\n\tinb(RBR(iobase));\n\toutb(0x01, FCR(iobase));\t/* enable FIFOs */\n\tu = uart_tab[(inb(IIR(iobase)) >> 6) & 3];\n\tif (u == c_uart_16450) {\n\t\toutb(0x5a, SCR(iobase));\n\t\tb1 = inb(SCR(iobase));\n\t\toutb(0xa5, SCR(iobase));\n\t\tb2 = inb(SCR(iobase));\n\t\tif ((b1 != 0x5a) || (b2 != 0xa5))\n\t\t\tu = c_uart_8250;\n\t}\n\treturn u;\n}\n\n/******************************************************************************\n* Rx Section\n******************************************************************************/\nstatic inline void yam_rx_flag(struct net_device *dev, struct yam_port *yp)\n{\n\tif (yp->dcd && yp->rx_len >= 3 && yp->rx_len < YAM_MAX_FRAME) {\n\t\tint pkt_len = yp->rx_len - 2 + 1;\t/* -CRC + kiss */\n\t\tstruct sk_buff *skb;\n\n\t\tif ((yp->rx_crch & yp->rx_crcl) != 0xFF) {\n\t\t\t/* Bad crc */\n\t\t} else {\n\t\t\tif (!(skb = dev_alloc_skb(pkt_len))) {\n\t\t\t\tprintk(KERN_WARNING \"%s: memory squeeze, dropping packet\\n\", dev->name);\n\t\t\t\t++dev->stats.rx_dropped;\n\t\t\t} else {\n\t\t\t\tunsigned char *cp;\n\t\t\t\tcp = skb_put(skb, pkt_len);\n\t\t\t\t*cp++ = 0;\t\t/* KISS kludge */\n\t\t\t\tmemcpy(cp, yp->rx_buf, pkt_len - 1);\n\t\t\t\tskb->protocol = ax25_type_trans(skb, dev);\n\t\t\t\tnetif_rx(skb);\n\t\t\t\t++dev->stats.rx_packets;\n\t\t\t}\n\t\t}\n\t}\n\typ->rx_len = 0;\n\typ->rx_crcl = 0x21;\n\typ->rx_crch = 0xf3;\n}\n\nstatic inline void yam_rx_byte(struct net_device *dev, struct yam_port *yp, unsigned char rxb)\n{\n\tif (yp->rx_len < YAM_MAX_FRAME) {\n\t\tunsigned char c = yp->rx_crcl;\n\t\typ->rx_crcl = (chktabl[c] ^ yp->rx_crch);\n\t\typ->rx_crch = (chktabh[c] ^ rxb);\n\t\typ->rx_buf[yp->rx_len++] = rxb;\n\t}\n}\n\n/********************************************************************************\n* TX Section\n********************************************************************************/\n\nstatic void ptt_on(struct net_device *dev)\n{\n\toutb(PTT_ON, MCR(dev->base_addr));\n}\n\nstatic void ptt_off(struct net_device *dev)\n{\n\toutb(PTT_OFF, MCR(dev->base_addr));\n}\n\nstatic netdev_tx_t yam_send_packet(struct sk_buff *skb,\n\t\t\t\t\t struct net_device *dev)\n{\n\tstruct yam_port *yp = netdev_priv(dev);\n\n\tskb_queue_tail(&yp->send_queue, skb);\n\tdev->trans_start = jiffies;\n\treturn NETDEV_TX_OK;\n}\n\nstatic void yam_start_tx(struct net_device *dev, struct yam_port *yp)\n{\n\tif ((yp->tx_state == TX_TAIL) || (yp->txd == 0))\n\t\typ->tx_count = 1;\n\telse\n\t\typ->tx_count = (yp->bitrate * yp->txd) / 8000;\n\typ->tx_state = TX_HEAD;\n\tptt_on(dev);\n}\n\nstatic void yam_arbitrate(struct net_device *dev)\n{\n\tstruct yam_port *yp = netdev_priv(dev);\n\n\tif (yp->magic != YAM_MAGIC || yp->tx_state != TX_OFF ||\n\t    skb_queue_empty(&yp->send_queue))\n\t\treturn;\n\t/* tx_state is TX_OFF and there is data to send */\n\n\tif (yp->dupmode) {\n\t\t/* Full duplex mode, don't wait */\n\t\tyam_start_tx(dev, yp);\n\t\treturn;\n\t}\n\tif (yp->dcd) {\n\t\t/* DCD on, wait slotime ... */\n\t\typ->slotcnt = yp->slot / 10;\n\t\treturn;\n\t}\n\t/* Is slottime passed ? */\n\tif ((--yp->slotcnt) > 0)\n\t\treturn;\n\n\typ->slotcnt = yp->slot / 10;\n\n\t/* is random > persist ? */\n\tif ((prandom_u32() % 256) > yp->pers)\n\t\treturn;\n\n\tyam_start_tx(dev, yp);\n}\n\nstatic void yam_dotimer(unsigned long dummy)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_PORTS; i++) {\n\t\tstruct net_device *dev = yam_devs[i];\n\t\tif (dev && netif_running(dev))\n\t\t\tyam_arbitrate(dev);\n\t}\n\tyam_timer.expires = jiffies + HZ / 100;\n\tadd_timer(&yam_timer);\n}\n\nstatic void yam_tx_byte(struct net_device *dev, struct yam_port *yp)\n{\n\tstruct sk_buff *skb;\n\tunsigned char b, temp;\n\n\tswitch (yp->tx_state) {\n\tcase TX_OFF:\n\t\tbreak;\n\tcase TX_HEAD:\n\t\tif (--yp->tx_count <= 0) {\n\t\t\tif (!(skb = skb_dequeue(&yp->send_queue))) {\n\t\t\t\tptt_off(dev);\n\t\t\t\typ->tx_state = TX_OFF;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\typ->tx_state = TX_DATA;\n\t\t\tif (skb->data[0] != 0) {\n/*                              do_kiss_params(s, skb->data, skb->len); */\n\t\t\t\tdev_kfree_skb_any(skb);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\typ->tx_len = skb->len - 1;\t/* strip KISS byte */\n\t\t\tif (yp->tx_len >= YAM_MAX_FRAME || yp->tx_len < 2) {\n        \t\t\tdev_kfree_skb_any(skb);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tskb_copy_from_linear_data_offset(skb, 1,\n\t\t\t\t\t\t\t yp->tx_buf,\n\t\t\t\t\t\t\t yp->tx_len);\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\typ->tx_count = 0;\n\t\t\typ->tx_crcl = 0x21;\n\t\t\typ->tx_crch = 0xf3;\n\t\t\typ->tx_state = TX_DATA;\n\t\t}\n\t\tbreak;\n\tcase TX_DATA:\n\t\tb = yp->tx_buf[yp->tx_count++];\n\t\toutb(b, THR(dev->base_addr));\n\t\ttemp = yp->tx_crcl;\n\t\typ->tx_crcl = chktabl[temp] ^ yp->tx_crch;\n\t\typ->tx_crch = chktabh[temp] ^ b;\n\t\tif (yp->tx_count >= yp->tx_len) {\n\t\t\typ->tx_state = TX_CRC1;\n\t\t}\n\t\tbreak;\n\tcase TX_CRC1:\n\t\typ->tx_crch = chktabl[yp->tx_crcl] ^ yp->tx_crch;\n\t\typ->tx_crcl = chktabh[yp->tx_crcl] ^ chktabl[yp->tx_crch] ^ 0xff;\n\t\toutb(yp->tx_crcl, THR(dev->base_addr));\n\t\typ->tx_state = TX_CRC2;\n\t\tbreak;\n\tcase TX_CRC2:\n\t\toutb(chktabh[yp->tx_crch] ^ 0xFF, THR(dev->base_addr));\n\t\tif (skb_queue_empty(&yp->send_queue)) {\n\t\t\typ->tx_count = (yp->bitrate * yp->txtail) / 8000;\n\t\t\tif (yp->dupmode == 2)\n\t\t\t\typ->tx_count += (yp->bitrate * yp->holdd) / 8;\n\t\t\tif (yp->tx_count == 0)\n\t\t\t\typ->tx_count = 1;\n\t\t\typ->tx_state = TX_TAIL;\n\t\t} else {\n\t\t\typ->tx_count = 1;\n\t\t\typ->tx_state = TX_HEAD;\n\t\t}\n\t\t++dev->stats.tx_packets;\n\t\tbreak;\n\tcase TX_TAIL:\n\t\tif (--yp->tx_count <= 0) {\n\t\t\typ->tx_state = TX_OFF;\n\t\t\tptt_off(dev);\n\t\t}\n\t\tbreak;\n\t}\n}\n\n/***********************************************************************************\n* ISR routine\n************************************************************************************/\n\nstatic irqreturn_t yam_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev;\n\tstruct yam_port *yp;\n\tunsigned char iir;\n\tint counter = 100;\n\tint i;\n\tint handled = 0;\n\n\tfor (i = 0; i < NR_PORTS; i++) {\n\t\tdev = yam_devs[i];\n\t\typ = netdev_priv(dev);\n\n\t\tif (!netif_running(dev))\n\t\t\tcontinue;\n\n\t\twhile ((iir = IIR_MASK & inb(IIR(dev->base_addr))) != IIR_NOPEND) {\n\t\t\tunsigned char msr = inb(MSR(dev->base_addr));\n\t\t\tunsigned char lsr = inb(LSR(dev->base_addr));\n\t\t\tunsigned char rxb;\n\n\t\t\thandled = 1;\n\n\t\t\tif (lsr & LSR_OE)\n\t\t\t\t++dev->stats.rx_fifo_errors;\n\n\t\t\typ->dcd = (msr & RX_DCD) ? 1 : 0;\n\n\t\t\tif (--counter <= 0) {\n\t\t\t\tprintk(KERN_ERR \"%s: too many irq iir=%d\\n\",\n\t\t\t\t\t\tdev->name, iir);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (msr & TX_RDY) {\n\t\t\t\t++yp->nb_mdint;\n\t\t\t\tyam_tx_byte(dev, yp);\n\t\t\t}\n\t\t\tif (lsr & LSR_RXC) {\n\t\t\t\t++yp->nb_rxint;\n\t\t\t\trxb = inb(RBR(dev->base_addr));\n\t\t\t\tif (msr & RX_FLAG)\n\t\t\t\t\tyam_rx_flag(dev, yp);\n\t\t\t\telse\n\t\t\t\t\tyam_rx_byte(dev, yp, rxb);\n\t\t\t}\n\t\t}\n\t}\nout:\n\treturn IRQ_RETVAL(handled);\n}\n\n#ifdef CONFIG_PROC_FS\n\nstatic void *yam_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\treturn (*pos < NR_PORTS) ? yam_devs[*pos] : NULL;\n}\n\nstatic void *yam_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\t++*pos;\n\treturn (*pos < NR_PORTS) ? yam_devs[*pos] : NULL;\n}\n\nstatic void yam_seq_stop(struct seq_file *seq, void *v)\n{\n}\n\nstatic int yam_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct net_device *dev = v;\n\tconst struct yam_port *yp = netdev_priv(dev);\n\n\tseq_printf(seq, \"Device %s\\n\", dev->name);\n\tseq_printf(seq, \"  Up       %d\\n\", netif_running(dev));\n\tseq_printf(seq, \"  Speed    %u\\n\", yp->bitrate);\n\tseq_printf(seq, \"  IoBase   0x%x\\n\", yp->iobase);\n\tseq_printf(seq, \"  BaudRate %u\\n\", yp->baudrate);\n\tseq_printf(seq, \"  IRQ      %u\\n\", yp->irq);\n\tseq_printf(seq, \"  TxState  %u\\n\", yp->tx_state);\n\tseq_printf(seq, \"  Duplex   %u\\n\", yp->dupmode);\n\tseq_printf(seq, \"  HoldDly  %u\\n\", yp->holdd);\n\tseq_printf(seq, \"  TxDelay  %u\\n\", yp->txd);\n\tseq_printf(seq, \"  TxTail   %u\\n\", yp->txtail);\n\tseq_printf(seq, \"  SlotTime %u\\n\", yp->slot);\n\tseq_printf(seq, \"  Persist  %u\\n\", yp->pers);\n\tseq_printf(seq, \"  TxFrames %lu\\n\", dev->stats.tx_packets);\n\tseq_printf(seq, \"  RxFrames %lu\\n\", dev->stats.rx_packets);\n\tseq_printf(seq, \"  TxInt    %u\\n\", yp->nb_mdint);\n\tseq_printf(seq, \"  RxInt    %u\\n\", yp->nb_rxint);\n\tseq_printf(seq, \"  RxOver   %lu\\n\", dev->stats.rx_fifo_errors);\n\tseq_printf(seq, \"\\n\");\n\treturn 0;\n}\n\nstatic const struct seq_operations yam_seqops = {\n\t.start = yam_seq_start,\n\t.next = yam_seq_next,\n\t.stop = yam_seq_stop,\n\t.show = yam_seq_show,\n};\n\nstatic int yam_info_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &yam_seqops);\n}\n\nstatic const struct file_operations yam_info_fops = {\n\t.owner = THIS_MODULE,\n\t.open = yam_info_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = seq_release,\n};\n\n#endif\n\n\n/* --------------------------------------------------------------------- */\n\nstatic int yam_open(struct net_device *dev)\n{\n\tstruct yam_port *yp = netdev_priv(dev);\n\tenum uart u;\n\tint i;\n\tint ret=0;\n\n\tprintk(KERN_INFO \"Trying %s at iobase 0x%lx irq %u\\n\", dev->name, dev->base_addr, dev->irq);\n\n\tif (!yp->bitrate)\n\t\treturn -ENXIO;\n\tif (!dev->base_addr || dev->base_addr > 0x1000 - YAM_EXTENT ||\n\t\tdev->irq < 2 || dev->irq > 15) {\n\t\treturn -ENXIO;\n\t}\n\tif (!request_region(dev->base_addr, YAM_EXTENT, dev->name))\n\t{\n\t\tprintk(KERN_ERR \"%s: cannot 0x%lx busy\\n\", dev->name, dev->base_addr);\n\t\treturn -EACCES;\n\t}\n\tif ((u = yam_check_uart(dev->base_addr)) == c_uart_unknown) {\n\t\tprintk(KERN_ERR \"%s: cannot find uart type\\n\", dev->name);\n\t\tret = -EIO;\n\t\tgoto out_release_base;\n\t}\n\tif (fpga_download(dev->base_addr, yp->bitrate)) {\n\t\tprintk(KERN_ERR \"%s: cannot init FPGA\\n\", dev->name);\n\t\tret = -EIO;\n\t\tgoto out_release_base;\n\t}\n\toutb(0, IER(dev->base_addr));\n\tif (request_irq(dev->irq, yam_interrupt, IRQF_SHARED, dev->name, dev)) {\n\t\tprintk(KERN_ERR \"%s: irq %d busy\\n\", dev->name, dev->irq);\n\t\tret = -EBUSY;\n\t\tgoto out_release_base;\n\t}\n\n\tyam_set_uart(dev);\n\n\tnetif_start_queue(dev);\n\t\n\typ->slotcnt = yp->slot / 10;\n\n\t/* Reset overruns for all ports - FPGA programming makes overruns */\n\tfor (i = 0; i < NR_PORTS; i++) {\n\t\tstruct net_device *yam_dev = yam_devs[i];\n\n\t\tinb(LSR(yam_dev->base_addr));\n\t\tyam_dev->stats.rx_fifo_errors = 0;\n\t}\n\n\tprintk(KERN_INFO \"%s at iobase 0x%lx irq %u uart %s\\n\", dev->name, dev->base_addr, dev->irq,\n\t\t   uart_str[u]);\n\treturn 0;\n\nout_release_base:\n\trelease_region(dev->base_addr, YAM_EXTENT);\n\treturn ret;\n}\n\n/* --------------------------------------------------------------------- */\n\nstatic int yam_close(struct net_device *dev)\n{\n\tstruct sk_buff *skb;\n\tstruct yam_port *yp = netdev_priv(dev);\n\n\tif (!dev)\n\t\treturn -EINVAL;\n\n\t/*\n\t * disable interrupts\n\t */\n\toutb(0, IER(dev->base_addr));\n\toutb(1, MCR(dev->base_addr));\n\t/* Remove IRQ handler if last */\n\tfree_irq(dev->irq,dev);\n\trelease_region(dev->base_addr, YAM_EXTENT);\n\tnetif_stop_queue(dev);\n\twhile ((skb = skb_dequeue(&yp->send_queue)))\n\t\tdev_kfree_skb(skb);\n\n\tprintk(KERN_INFO \"%s: close yam at iobase 0x%lx irq %u\\n\",\n\t\t   yam_drvname, dev->base_addr, dev->irq);\n\treturn 0;\n}\n\n/* --------------------------------------------------------------------- */\n\nstatic int yam_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\tstruct yam_port *yp = netdev_priv(dev);\n\tstruct yamdrv_ioctl_cfg yi;\n\tstruct yamdrv_ioctl_mcs *ym;\n\tint ioctl_cmd;\n\n\tif (copy_from_user(&ioctl_cmd, ifr->ifr_data, sizeof(int)))\n\t\t return -EFAULT;\n\n\tif (yp->magic != YAM_MAGIC)\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (cmd != SIOCDEVPRIVATE)\n\t\treturn -EINVAL;\n\n\tswitch (ioctl_cmd) {\n\n\tcase SIOCYAMRESERVED:\n\t\treturn -EINVAL;\t\t\t/* unused */\n\n\tcase SIOCYAMSMCS:\n\t\tif (netif_running(dev))\n\t\t\treturn -EINVAL;\t\t/* Cannot change this parameter when up */\n\t\tif ((ym = kmalloc(sizeof(struct yamdrv_ioctl_mcs), GFP_KERNEL)) == NULL)\n\t\t\treturn -ENOBUFS;\n\t\tif (copy_from_user(ym, ifr->ifr_data, sizeof(struct yamdrv_ioctl_mcs))) {\n\t\t\tkfree(ym);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tif (ym->bitrate > YAM_MAXBITRATE) {\n\t\t\tkfree(ym);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t/* setting predef as 0 for loading userdefined mcs data */\n\t\tadd_mcs(ym->bits, ym->bitrate, 0);\n\t\tkfree(ym);\n\t\tbreak;\n\n\tcase SIOCYAMSCFG:\n\t\tif (!capable(CAP_SYS_RAWIO))\n\t\t\treturn -EPERM;\n\t\tif (copy_from_user(&yi, ifr->ifr_data, sizeof(struct yamdrv_ioctl_cfg)))\n\t\t\t return -EFAULT;\n\n\t\tif ((yi.cfg.mask & YAM_IOBASE) && netif_running(dev))\n\t\t\treturn -EINVAL;\t\t/* Cannot change this parameter when up */\n\t\tif ((yi.cfg.mask & YAM_IRQ) && netif_running(dev))\n\t\t\treturn -EINVAL;\t\t/* Cannot change this parameter when up */\n\t\tif ((yi.cfg.mask & YAM_BITRATE) && netif_running(dev))\n\t\t\treturn -EINVAL;\t\t/* Cannot change this parameter when up */\n\t\tif ((yi.cfg.mask & YAM_BAUDRATE) && netif_running(dev))\n\t\t\treturn -EINVAL;\t\t/* Cannot change this parameter when up */\n\n\t\tif (yi.cfg.mask & YAM_IOBASE) {\n\t\t\typ->iobase = yi.cfg.iobase;\n\t\t\tdev->base_addr = yi.cfg.iobase;\n\t\t}\n\t\tif (yi.cfg.mask & YAM_IRQ) {\n\t\t\tif (yi.cfg.irq > 15)\n\t\t\t\treturn -EINVAL;\n\t\t\typ->irq = yi.cfg.irq;\n\t\t\tdev->irq = yi.cfg.irq;\n\t\t}\n\t\tif (yi.cfg.mask & YAM_BITRATE) {\n\t\t\tif (yi.cfg.bitrate > YAM_MAXBITRATE)\n\t\t\t\treturn -EINVAL;\n\t\t\typ->bitrate = yi.cfg.bitrate;\n\t\t}\n\t\tif (yi.cfg.mask & YAM_BAUDRATE) {\n\t\t\tif (yi.cfg.baudrate > YAM_MAXBAUDRATE)\n\t\t\t\treturn -EINVAL;\n\t\t\typ->baudrate = yi.cfg.baudrate;\n\t\t}\n\t\tif (yi.cfg.mask & YAM_MODE) {\n\t\t\tif (yi.cfg.mode > YAM_MAXMODE)\n\t\t\t\treturn -EINVAL;\n\t\t\typ->dupmode = yi.cfg.mode;\n\t\t}\n\t\tif (yi.cfg.mask & YAM_HOLDDLY) {\n\t\t\tif (yi.cfg.holddly > YAM_MAXHOLDDLY)\n\t\t\t\treturn -EINVAL;\n\t\t\typ->holdd = yi.cfg.holddly;\n\t\t}\n\t\tif (yi.cfg.mask & YAM_TXDELAY) {\n\t\t\tif (yi.cfg.txdelay > YAM_MAXTXDELAY)\n\t\t\t\treturn -EINVAL;\n\t\t\typ->txd = yi.cfg.txdelay;\n\t\t}\n\t\tif (yi.cfg.mask & YAM_TXTAIL) {\n\t\t\tif (yi.cfg.txtail > YAM_MAXTXTAIL)\n\t\t\t\treturn -EINVAL;\n\t\t\typ->txtail = yi.cfg.txtail;\n\t\t}\n\t\tif (yi.cfg.mask & YAM_PERSIST) {\n\t\t\tif (yi.cfg.persist > YAM_MAXPERSIST)\n\t\t\t\treturn -EINVAL;\n\t\t\typ->pers = yi.cfg.persist;\n\t\t}\n\t\tif (yi.cfg.mask & YAM_SLOTTIME) {\n\t\t\tif (yi.cfg.slottime > YAM_MAXSLOTTIME)\n\t\t\t\treturn -EINVAL;\n\t\t\typ->slot = yi.cfg.slottime;\n\t\t\typ->slotcnt = yp->slot / 10;\n\t\t}\n\t\tbreak;\n\n\tcase SIOCYAMGCFG:\n\t\tmemset(&yi, 0, sizeof(yi));\n\t\tyi.cfg.mask = 0xffffffff;\n\t\tyi.cfg.iobase = yp->iobase;\n\t\tyi.cfg.irq = yp->irq;\n\t\tyi.cfg.bitrate = yp->bitrate;\n\t\tyi.cfg.baudrate = yp->baudrate;\n\t\tyi.cfg.mode = yp->dupmode;\n\t\tyi.cfg.txdelay = yp->txd;\n\t\tyi.cfg.holddly = yp->holdd;\n\t\tyi.cfg.txtail = yp->txtail;\n\t\tyi.cfg.persist = yp->pers;\n\t\tyi.cfg.slottime = yp->slot;\n\t\tif (copy_to_user(ifr->ifr_data, &yi, sizeof(struct yamdrv_ioctl_cfg)))\n\t\t\t return -EFAULT;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\n\t}\n\n\treturn 0;\n}\n\n/* --------------------------------------------------------------------- */\n\nstatic int yam_set_mac_address(struct net_device *dev, void *addr)\n{\n\tstruct sockaddr *sa = (struct sockaddr *) addr;\n\n\t/* addr is an AX.25 shifted ASCII mac address */\n\tmemcpy(dev->dev_addr, sa->sa_data, dev->addr_len);\n\treturn 0;\n}\n\n/* --------------------------------------------------------------------- */\n\nstatic const struct net_device_ops yam_netdev_ops = {\n\t.ndo_open\t     = yam_open,\n\t.ndo_stop\t     = yam_close,\n\t.ndo_start_xmit      = yam_send_packet,\n\t.ndo_do_ioctl \t     = yam_ioctl,\n\t.ndo_set_mac_address = yam_set_mac_address,\n};\n\nstatic void yam_setup(struct net_device *dev)\n{\n\tstruct yam_port *yp = netdev_priv(dev);\n\n\typ->magic = YAM_MAGIC;\n\typ->bitrate = DEFAULT_BITRATE;\n\typ->baudrate = DEFAULT_BITRATE * 2;\n\typ->iobase = 0;\n\typ->irq = 0;\n\typ->dupmode = 0;\n\typ->holdd = DEFAULT_HOLDD;\n\typ->txd = DEFAULT_TXD;\n\typ->txtail = DEFAULT_TXTAIL;\n\typ->slot = DEFAULT_SLOT;\n\typ->pers = DEFAULT_PERS;\n\typ->dev = dev;\n\n\tdev->base_addr = yp->iobase;\n\tdev->irq = yp->irq;\n\n\tskb_queue_head_init(&yp->send_queue);\n\n\tdev->netdev_ops = &yam_netdev_ops;\n\tdev->header_ops = &ax25_header_ops;\n\n\tdev->type = ARPHRD_AX25;\n\tdev->hard_header_len = AX25_MAX_HEADER_LEN;\n\tdev->mtu = AX25_MTU;\n\tdev->addr_len = AX25_ADDR_LEN;\n\tmemcpy(dev->broadcast, &ax25_bcast, AX25_ADDR_LEN);\n\tmemcpy(dev->dev_addr, &ax25_defaddr, AX25_ADDR_LEN);\n}\n\nstatic int __init yam_init_driver(void)\n{\n\tstruct net_device *dev;\n\tint i, err;\n\tchar name[IFNAMSIZ];\n\n\tprintk(yam_drvinfo);\n\n\tfor (i = 0; i < NR_PORTS; i++) {\n\t\tsprintf(name, \"yam%d\", i);\n\t\t\n\t\tdev = alloc_netdev(sizeof(struct yam_port), name,\n\t\t\t\t   yam_setup);\n\t\tif (!dev) {\n\t\t\tpr_err(\"yam: cannot allocate net device\\n\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\t\t\n\t\terr = register_netdev(dev);\n\t\tif (err) {\n\t\t\tprintk(KERN_WARNING \"yam: cannot register net device %s\\n\", dev->name);\n\t\t\tgoto error;\n\t\t}\n\t\tyam_devs[i] = dev;\n\n\t}\n\n\tyam_timer.function = yam_dotimer;\n\tyam_timer.expires = jiffies + HZ / 100;\n\tadd_timer(&yam_timer);\n\n\tproc_create(\"yam\", S_IRUGO, init_net.proc_net, &yam_info_fops);\n\treturn 0;\n error:\n\twhile (--i >= 0) {\n\t\tunregister_netdev(yam_devs[i]);\n\t\tfree_netdev(yam_devs[i]);\n\t}\n\treturn err;\n}\n\n/* --------------------------------------------------------------------- */\n\nstatic void __exit yam_cleanup_driver(void)\n{\n\tstruct yam_mcs *p;\n\tint i;\n\n\tdel_timer(&yam_timer);\n\tfor (i = 0; i < NR_PORTS; i++) {\n\t\tstruct net_device *dev = yam_devs[i];\n\t\tif (dev) {\n\t\t\tunregister_netdev(dev);\n\t\t\tfree_netdev(dev);\n\t\t}\n\t}\n\n\twhile (yam_data) {\n\t\tp = yam_data;\n\t\tyam_data = yam_data->next;\n\t\tkfree(p);\n\t}\n\n\tremove_proc_entry(\"yam\", init_net.proc_net);\n}\n\n/* --------------------------------------------------------------------- */\n\nMODULE_AUTHOR(\"Frederic Rible F1OAT frible@teaser.fr\");\nMODULE_DESCRIPTION(\"Yam amateur radio modem driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(FIRMWARE_1200);\nMODULE_FIRMWARE(FIRMWARE_9600);\n\nmodule_init(yam_init_driver);\nmodule_exit(yam_cleanup_driver);\n\n/* --------------------------------------------------------------------- */\n\n"], "filenames": ["drivers/net/hamradio/yam.c"], "buggy_code_start_loc": [1059], "buggy_code_end_loc": [1059], "fixing_code_start_loc": [1060], "fixing_code_end_loc": [1061], "type": "CWE-399", "message": "The yam_ioctl function in drivers/net/hamradio/yam.c in the Linux kernel before 3.12.8 does not initialize a certain structure member, which allows local users to obtain sensitive information from kernel memory by leveraging the CAP_NET_ADMIN capability for an SIOCYAMGCFG ioctl call.", "other": {"cve": {"id": "CVE-2014-1446", "sourceIdentifier": "cve@mitre.org", "published": "2014-01-18T22:55:03.397", "lastModified": "2017-08-29T01:34:25.170", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The yam_ioctl function in drivers/net/hamradio/yam.c in the Linux kernel before 3.12.8 does not initialize a certain structure member, which allows local users to obtain sensitive information from kernel memory by leveraging the CAP_NET_ADMIN capability for an SIOCYAMGCFG ioctl call."}, {"lang": "es", "value": "La funci\u00f3n yam_ioclt en drivers/net/hamradio/yam.c en el kernel Linux anteriores a 3.1.2.8 no inicializa cierto miembro de estructura, lo cual permite a usuarios locales obtener informaci\u00f3n snesible de la memoria del kernel aprovechando la funcionalidad CAP_NET_ADMIN para una llamada SIOCYAMGCFG ioctl."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 1.9}, "baseSeverity": "LOW", "exploitabilityScore": 3.4, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-399"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.12.7", "matchCriteriaId": "22BA3594-3370-4F0A-974A-0FC2FFB50BA5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.12:*:*:*:*:*:*:*", "matchCriteriaId": "B291154A-4B91-4A0E-AAAE-716A8BB7BF99"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.12.1:*:*:*:*:*:*:*", "matchCriteriaId": "D835FBA1-49DE-4184-BEC8-7ED2B3F7B0BB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.12.2:*:*:*:*:*:*:*", "matchCriteriaId": "080BD3C9-0606-4D9A-B7AE-3DF9F75B8FF6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.12.3:*:*:*:*:*:*:*", "matchCriteriaId": "CCDF0F11-3DB4-41F6-B6D3-383857884258"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.12.4:*:*:*:*:*:*:*", "matchCriteriaId": "2FB1772A-F4AA-4AB8-9FC9-10993A6A5B46"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.12.5:*:*:*:*:*:*:*", "matchCriteriaId": "4DB5B4D7-C79C-448E-B0D4-A6A9C440F49C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.12.6:*:*:*:*:*:*:*", "matchCriteriaId": "7C9A32A2-C1EC-4463-B21F-79E6592C5339"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=8e3fbf870481eb53b2d3a322d1fc395ad8b367ed", "source": "cve@mitre.org"}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2014-January/126858.html", "source": "cve@mitre.org"}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2014-January/126874.html", "source": "cve@mitre.org"}, {"url": "http://www.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.12.8", "source": "cve@mitre.org"}, {"url": "http://www.mandriva.com/security/advisories?name=MDVSA-2014:038", "source": "cve@mitre.org"}, {"url": "http://www.openwall.com/lists/oss-security/2014/01/15/3", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/bid/64954", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-2113-1", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-2117-1", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-2128-1", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-2129-1", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-2133-1", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-2134-1", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-2135-1", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-2136-1", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-2138-1", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-2139-1", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-2141-1", "source": "cve@mitre.org"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1053620", "source": "cve@mitre.org"}, {"url": "https://exchange.xforce.ibmcloud.com/vulnerabilities/90445", "source": "cve@mitre.org"}, {"url": "https://github.com/torvalds/linux/commit/8e3fbf870481eb53b2d3a322d1fc395ad8b367ed", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/8e3fbf870481eb53b2d3a322d1fc395ad8b367ed"}}