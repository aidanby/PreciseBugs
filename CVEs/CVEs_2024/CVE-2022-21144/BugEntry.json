{"buggy_code": ["{\n  \"name\": \"libxmljs\",\n  \"author\": \"Marco Rogers\",\n  \"contributors\": [\n    \"Jeff Smick\"\n  ],\n  \"binary\": {\n    \"module_name\": \"xmljs\",\n    \"module_path\": \"./build/Release/\",\n    \"host\": \"https://github.com\",\n    \"remote_path\": \"./libxmljs/libxmljs/releases/download/v{version}/\",\n    \"package_name\": \"{node_abi}-{platform}-{arch}.tar.gz\"\n  },\n  \"description\": \"libxml bindings for v8 javascript engine\",\n  \"version\": \"0.19.7\",\n  \"scripts\": {\n    \"install\": \"node-pre-gyp install --fallback-to-build --loglevel http\",\n    \"test\": \"node --expose_gc ./node_modules/.bin/nodeunit test\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"http://github.com/libxmljs/libxmljs.git\"\n  },\n  \"bugs\": {\n    \"url\": \"http://github.com/libxmljs/libxmljs/issues\"\n  },\n  \"main\": \"./index\",\n  \"license\": \"MIT\",\n  \"engines\": {\n    \"node\": \">=0.8.0\"\n  },\n  \"dependencies\": {\n    \"bindings\": \"~1.3.0\",\n    \"nan\": \"~2.14.0\",\n    \"node-pre-gyp\": \"~0.11.0\"\n  },\n  \"devDependencies\": {\n    \"nodeunit\": \"~0.11.2\",\n    \"semver\": \"~5.5.0\"\n  }\n}\n", "// Copyright 2009, Squish Tech, LLC.\n\n#include <node.h>\n#include <node_buffer.h>\n\n#include <cstring>\n\n//#include <libxml/tree.h>\n#include <libxml/HTMLtree.h>\n#include <libxml/HTMLparser.h>\n#include <libxml/xmlschemas.h>\n#include <libxml/relaxng.h>\n#include <libxml/xmlsave.h>\n\n#include \"xml_document.h\"\n#include \"xml_element.h\"\n#include \"xml_namespace.h\"\n#include \"xml_syntax_error.h\"\n\nnamespace libxmljs {\n\nNan::Persistent<v8::FunctionTemplate> XmlDocument::constructor_template;\n\nNAN_METHOD(XmlDocument::Encoding)\n{\n    Nan::HandleScope scope;\n    XmlDocument* document = Nan::ObjectWrap::Unwrap<XmlDocument>(info.Holder());\n    assert(document);\n\n    // if no args, get the encoding\n    if (info.Length() == 0 || info[0]->IsUndefined()) {\n        if (document->xml_obj->encoding)\n            return info.GetReturnValue().Set(Nan::New<v8::String>(\n                        (const char *)document->xml_obj->encoding,\n                        xmlStrlen((const xmlChar*)document->xml_obj->encoding)).ToLocalChecked());\n\n        return info.GetReturnValue().Set(Nan::Null());\n    }\n\n    // set the encoding otherwise\n    Nan::Utf8String encoding(Nan::To<v8::String>(info[0]).ToLocalChecked());\n    if(document->xml_obj->encoding != NULL) {\n        xmlFree((xmlChar*)document->xml_obj->encoding);\n    }\n\n    document->xml_obj->encoding = xmlStrdup((const xmlChar*)*encoding);\n    return info.GetReturnValue().Set(info.Holder());\n}\n\nNAN_METHOD(XmlDocument::Version)\n{\n    Nan::HandleScope scope;\n    XmlDocument *document = Nan::ObjectWrap::Unwrap<XmlDocument>(info.Holder());\n    assert(document);\n\n    if (document->xml_obj->version)\n        return info.GetReturnValue().Set(Nan::New<v8::String>((const char *)document->xml_obj->version,\n                    xmlStrlen((const xmlChar*)document->xml_obj->version)).ToLocalChecked());\n\n    return info.GetReturnValue().Set(Nan::Null());\n}\n\nNAN_METHOD(XmlDocument::Root)\n{\n    Nan::HandleScope scope;\n    XmlDocument* document = Nan::ObjectWrap::Unwrap<XmlDocument>(info.Holder());\n    assert(document);\n\n    xmlNode* root = xmlDocGetRootElement(document->xml_obj);\n\n    if (info.Length() == 0 || info[0]->IsUndefined())\n    {\n        if (!root) {\n            return info.GetReturnValue().Set(Nan::Null());\n        }\n        return info.GetReturnValue().Set(XmlElement::New(root));\n    }\n\n    if (root != NULL) {\n        return Nan::ThrowError(\"Holder document already has a root node\");\n    }\n\n    // set the element as the root element for the document\n    // allows for proper retrieval of root later\n    XmlElement* element = Nan::ObjectWrap::Unwrap<XmlElement>(Nan::To<v8::Object>(info[0]).ToLocalChecked());\n    assert(element);\n    xmlDocSetRootElement(document->xml_obj, element->xml_obj);\n    element->ref_wrapped_ancestor();\n    return info.GetReturnValue().Set(info[0]);\n}\n\nNAN_METHOD(XmlDocument::GetDtd)\n{\n    Nan::HandleScope scope;\n    XmlDocument* document = Nan::ObjectWrap::Unwrap<XmlDocument>(info.Holder());\n    assert(document);\n\n    xmlDtdPtr dtd = xmlGetIntSubset(document->xml_obj);\n\n    if (!dtd) {\n        return info.GetReturnValue().Set(Nan::Null());\n    }\n\n    const char* name = (const char *)dtd->name;\n    const char* extId = (const char *)dtd->ExternalID;\n    const char* sysId = (const char *)dtd->SystemID;\n\n    v8::Local<v8::Object> dtdObj = Nan::New<v8::Object>();\n    v8::Local<v8::Value> nameValue = (v8::Local<v8::Value>)Nan::Null();\n    v8::Local<v8::Value> extValue = (v8::Local<v8::Value>)Nan::Null();\n    v8::Local<v8::Value> sysValue = (v8::Local<v8::Value>)Nan::Null();\n\n    if (name != NULL) {\n        nameValue = (v8::Local<v8::Value>)Nan::New<v8::String>(name, strlen(name)).ToLocalChecked();\n    }\n\n    if (extId != NULL) {\n        extValue = (v8::Local<v8::Value>)Nan::New<v8::String>(extId, strlen(extId)).ToLocalChecked();\n    }\n\n    if (sysId != NULL) {\n        sysValue = (v8::Local<v8::Value>)Nan::New<v8::String>(sysId, strlen(sysId)).ToLocalChecked();\n    }\n\n\n    Nan::Set(dtdObj, Nan::New<v8::String>(\"name\").ToLocalChecked(), nameValue);\n\n    Nan::Set(dtdObj, Nan::New<v8::String>(\"externalId\").ToLocalChecked(), extValue);\n\n    Nan::Set(dtdObj, Nan::New<v8::String>(\"systemId\").ToLocalChecked(), sysValue);\n\n    return info.GetReturnValue().Set(dtdObj);\n\n}\n\nNAN_METHOD(XmlDocument::SetDtd)\n{\n    Nan::HandleScope scope;\n\n    XmlDocument* document = Nan::ObjectWrap::Unwrap<XmlDocument>(info.Holder());\n    assert(document);\n\n    Nan::Utf8String name(info[0]);\n\n    v8::Local<v8::Value> extIdOpt;\n    v8::Local<v8::Value> sysIdOpt;\n    if (info.Length() > 1 && info[1]->IsString()) {\n      extIdOpt = info[1];\n    }\n    if (info.Length() > 2 && info[2]->IsString()) {\n      sysIdOpt = info[2];\n    }\n\n    Nan::Utf8String extIdRaw(extIdOpt);\n    Nan::Utf8String sysIdRaw(sysIdOpt);\n\n    //must be set to null in order for xmlCreateIntSubset to ignore them\n    const char* extId = (extIdRaw.length()) ? *extIdRaw : NULL;\n    const char* sysId = (sysIdRaw.length()) ? *sysIdRaw : NULL;\n\n    //No good way of unsetting the doctype if it is previously set...this allows us to.\n    xmlDtdPtr dtd = xmlGetIntSubset(document->xml_obj);\n\n    xmlUnlinkNode((xmlNodePtr) dtd);\n    xmlFreeNode((xmlNodePtr) dtd);\n\n    xmlCreateIntSubset(document->xml_obj, (const xmlChar *) *name, (const xmlChar *) extId, (const xmlChar *) sysId);\n\n    return info.GetReturnValue().Set(info.Holder());\n}\n\nNAN_METHOD(XmlDocument::ToString)\n{\n    Nan::HandleScope scope;\n\n    XmlDocument* document = Nan::ObjectWrap::Unwrap<XmlDocument>(info.Holder());\n    assert(document);\n\n    int options = 0;\n\n    if (info.Length() > 0) {\n    if (info[0]->IsBoolean()) {\n        if (Nan::To<v8::Boolean>(info[0]).ToLocalChecked()->Value() == true) {\n            options |= XML_SAVE_FORMAT;\n        }\n    } else if (info[0]->IsObject()) {\n        v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();\n\n        // drop the xml declaration\n        if (Nan::Get(obj, Nan::New<v8::String>(\"declaration\").ToLocalChecked()).ToLocalChecked()->IsFalse()) {\n            options |= XML_SAVE_NO_DECL;\n        }\n\n        // format save output\n        if (Nan::Get(obj, Nan::New<v8::String>(\"format\").ToLocalChecked()).ToLocalChecked()->IsTrue()) {\n            options |= XML_SAVE_FORMAT;\n        }\n\n        // no empty tags (only works with XML) ex: <title></title> becomes <title/>\n        if (Nan::Get(obj, Nan::New<v8::String>(\"selfCloseEmpty\").ToLocalChecked()).ToLocalChecked()->IsFalse()) {\n            options |= XML_SAVE_NO_EMPTY;\n        }\n\n        // format with non-significant whitespace\n        if (Nan::Get(obj, Nan::New<v8::String>(\"whitespace\").ToLocalChecked()).ToLocalChecked()->IsTrue()) {\n            options |= XML_SAVE_WSNONSIG;\n        }\n\n        v8::Local<v8::Value> type = Nan::Get(obj, Nan::New<v8::String>(\"type\").ToLocalChecked()).ToLocalChecked();\n        if (Nan::Equals(type, Nan::New<v8::String>(\"XML\").ToLocalChecked()).ToChecked() ||\n            Nan::Equals(type, Nan::New<v8::String>(\"xml\").ToLocalChecked()).ToChecked()) {\n            options |= XML_SAVE_AS_XML;    // force XML serialization on HTML doc\n        } else if (Nan::Equals(type, Nan::New<v8::String>(\"HTML\").ToLocalChecked()).ToChecked() ||\n                 Nan::Equals(type, Nan::New<v8::String>(\"html\").ToLocalChecked()).ToChecked()) {\n            options |= XML_SAVE_AS_HTML;   // force HTML serialization on XML doc\n            // if the document is XML and we want formatted HTML output\n            // we must use the XHTML serializer because the default HTML\n            // serializer only formats node->type = HTML_NODE and not XML_NODEs\n            if ((options & XML_SAVE_FORMAT) && (options & XML_SAVE_XHTML) == false) {\n              options |= XML_SAVE_XHTML;\n            }\n        } else if (Nan::Equals(type, Nan::New<v8::String>(\"XHTML\").ToLocalChecked()).ToChecked() ||\n                 Nan::Equals(type, Nan::New<v8::String>(\"xhtml\").ToLocalChecked()).ToChecked()) {\n                options |= XML_SAVE_XHTML;    // force XHTML serialization\n            }\n        }\n    }\n\n    xmlBuffer* buf = xmlBufferCreate();\n    xmlSaveCtxt* savectx = xmlSaveToBuffer(buf, \"UTF-8\", options);\n    xmlSaveTree(savectx, (xmlNode*)document->xml_obj);\n    xmlSaveFlush(savectx);\n    xmlSaveClose(savectx);\n    v8::Local<v8::Value> ret = Nan::Null();\n    if (xmlBufferLength(buf) > 0)\n        ret = Nan::New<v8::String>((char*)xmlBufferContent(buf), xmlBufferLength(buf)).ToLocalChecked();\n    xmlBufferFree(buf);\n\n    return info.GetReturnValue().Set(ret);\n}\n\n// not called from node\n// private api\nv8::Local<v8::Object>\nXmlDocument::New(xmlDoc* doc)\n{\n    Nan::EscapableHandleScope scope;\n\n    if (doc->_private) {\n        return scope.Escape(static_cast<XmlDocument*>(doc->_private)->handle());\n    }\n\n    v8::Local<v8::Object> obj = Nan::NewInstance(Nan::GetFunction(Nan::New(constructor_template)).ToLocalChecked()).ToLocalChecked();\n\n    XmlDocument* document = Nan::ObjectWrap::Unwrap<XmlDocument>(obj);\n\n    // replace the document we created\n    document->xml_obj->_private = NULL;\n    xmlFreeDoc(document->xml_obj);\n    document->xml_obj = doc;\n\n    // store ourselves in the document\n    // this is how we can get instances or already existing v8 objects\n    doc->_private = document;\n\n    return scope.Escape(obj);\n}\n\nint getParserOption(v8::Local<v8::Object> props, const char *key, int value, bool defaultValue = true) {\n    Nan::HandleScope scope;\n    v8::Local<v8::Value> prop = Nan::Get(props, Nan::New<v8::String>(key).ToLocalChecked()).ToLocalChecked();\n    return !prop->IsUndefined() && Nan::To<v8::Boolean>(prop).ToLocalChecked()->Value() == defaultValue ? value : 0;\n}\n\nxmlParserOption getParserOptions(v8::Local<v8::Object> props) {\n    int ret = 0;\n\n    // http://xmlsoft.org/html/libxml-parser.html#xmlParserOption\n    // http://www.xmlsoft.org/html/libxml-HTMLparser.html#htmlParserOption\n\n    ret |= getParserOption(props, \"recover\", XML_PARSE_RECOVER);            // 1: recover on errors\n    /*ret |= getParserOption(props, \"recover\", HTML_PARSE_RECOVER);           // 1: Relaxed parsing*/\n\n    ret |= getParserOption(props, \"noent\", XML_PARSE_NOENT);                // 2: substitute entities\n\n    ret |= getParserOption(props, \"dtdload\", XML_PARSE_DTDLOAD);            // 4: load the external subset\n    ret |= getParserOption(props, \"doctype\", HTML_PARSE_NODEFDTD, false);   // 4: do not default a doctype if not found\n\n    ret |= getParserOption(props, \"dtdattr\", XML_PARSE_DTDATTR);            // 8: default DTD attributes\n    ret |= getParserOption(props, \"dtdvalid\", XML_PARSE_DTDVALID);          // 16: validate with the DTD\n\n    ret |= getParserOption(props, \"noerror\", XML_PARSE_NOERROR);            // 32: suppress error reports\n    ret |= getParserOption(props, \"errors\",  HTML_PARSE_NOERROR, false);    // 32: suppress error reports\n\n    ret |= getParserOption(props, \"nowarning\", XML_PARSE_NOWARNING);        // 64: suppress warning reports\n    ret |= getParserOption(props, \"warnings\", HTML_PARSE_NOWARNING, false); // 64: suppress warning reports\n\n    ret |= getParserOption(props, \"pedantic\", XML_PARSE_PEDANTIC);          // 128: pedantic error reporting\n    /*ret |= getParserOption(props, \"pedantic\", HTML_PARSE_PEDANTIC);         // 128: pedantic error reporting*/\n\n    ret |= getParserOption(props, \"noblanks\", XML_PARSE_NOBLANKS);          // 256: remove blank nodes\n    ret |= getParserOption(props, \"blanks\", HTML_PARSE_NOBLANKS, false);    // 256: remove blank nodes\n\n    ret |= getParserOption(props, \"sax1\", XML_PARSE_SAX1);                  // 512: use the SAX1 interface internally\n    ret |= getParserOption(props, \"xinclude\", XML_PARSE_XINCLUDE);          // 1024: Implement XInclude substitition\n\n    ret |= getParserOption(props, \"nonet\", XML_PARSE_NONET);                // 2048: Forbid network access\n    ret |= getParserOption(props, \"net\", HTML_PARSE_NONET, false);          // 2048: Forbid network access\n\n    ret |= getParserOption(props, \"nodict\", XML_PARSE_NODICT);              // 4096: Do not reuse the context dictionnary\n    ret |= getParserOption(props, \"dict\", XML_PARSE_NODICT, false);         // 4096: Do not reuse the context dictionnary\n\n    ret |= getParserOption(props, \"nsclean\", XML_PARSE_NSCLEAN);            // 8192: remove redundant namespaces declarations\n    ret |= getParserOption(props, \"implied\", HTML_PARSE_NOIMPLIED, false);  // 8192: Do not add implied html/body elements\n\n    ret |= getParserOption(props, \"nocdata\", XML_PARSE_NOCDATA);            // 16384: merge CDATA as text nodes\n    ret |= getParserOption(props, \"cdata\", XML_PARSE_NOCDATA, false);       // 16384: merge CDATA as text nodes\n\n    ret |= getParserOption(props, \"noxincnode\", XML_PARSE_NOXINCNODE);      // 32768: do not generate XINCLUDE START/END nodes\n    ret |= getParserOption(props, \"xincnode\", XML_PARSE_NOXINCNODE, false); // 32768: do not generate XINCLUDE START/END nodes\n\n    ret |= getParserOption(props, \"compact\", XML_PARSE_COMPACT);            // 65536: compact small text nodes; no modification of the tree allowed afterwards (will possibly crash if you try to modify the tree)\n    /*ret |= getParserOption(props, \"compact\", HTML_PARSE_COMPACT , false);   // 65536: compact small text nodes*/\n\n    ret |= getParserOption(props, \"old10\", XML_PARSE_OLD10);                // 131072: parse using XML-1.0 before update 5\n\n    ret |= getParserOption(props, \"nobasefix\", XML_PARSE_NOBASEFIX);        // 262144: do not fixup XINCLUDE xml:base uris\n    ret |= getParserOption(props, \"basefix\", XML_PARSE_NOBASEFIX, false);   // 262144: do not fixup XINCLUDE xml:base uris\n\n    ret |= getParserOption(props, \"huge\", XML_PARSE_HUGE);                  // 524288: relax any hardcoded limit from the parser\n    ret |= getParserOption(props, \"oldsax\", XML_PARSE_OLDSAX);              // 1048576: parse using SAX2 interface before 2.7.0\n\n    ret |= getParserOption(props, \"ignore_enc\", XML_PARSE_IGNORE_ENC);      // 2097152: ignore internal document encoding hint\n    /*ret |= getParserOption(props, \"ignore_enc\", HTML_PARSE_IGNORE_ENC);      // 2097152: ignore internal document encoding hint*/\n\n    ret |= getParserOption(props, \"big_lines\", XML_PARSE_BIG_LINES);        // 4194304: Store big lines numbers in text PSVI field\n\n    return (xmlParserOption)ret;\n}\n\nNAN_METHOD(XmlDocument::FromHtml)\n{\n    Nan::HandleScope scope;\n\n    v8::Local<v8::Object> options = Nan::To<v8::Object>(info[1]).ToLocalChecked();\n    v8::Local<v8::Value>  baseUrlOpt  = Nan::Get(options,\n        Nan::New<v8::String>(\"baseUrl\").ToLocalChecked()).ToLocalChecked();\n    v8::Local<v8::Value>  encodingOpt = Nan::Get(options,\n        Nan::New<v8::String>(\"encoding\").ToLocalChecked()).ToLocalChecked();\n    v8::Local<v8::Value> excludeImpliedElementsOpt = Nan::Get(options,\n        Nan::New<v8::String>(\"excludeImpliedElements\").ToLocalChecked()).ToLocalChecked();\n\n    // the base URL that will be used for this HTML parsed document\n    Nan::Utf8String baseUrl_(Nan::To<v8::String>(baseUrlOpt).ToLocalChecked());\n    const char * baseUrl = *baseUrl_;\n    if (!baseUrlOpt->IsString()) {\n        baseUrl = NULL;\n    }\n\n    // the encoding to be used for this document\n    // (leave NULL for libxml to autodetect)\n    Nan::Utf8String encoding_(Nan::To<v8::String>(encodingOpt).ToLocalChecked());\n    const char * encoding = *encoding_;\n\n    if (!encodingOpt->IsString()) {\n        encoding = NULL;\n    }\n\n    v8::Local<v8::Array> errors = Nan::New<v8::Array>();\n    xmlResetLastError();\n    xmlSetStructuredErrorFunc(reinterpret_cast<void*>(&errors), XmlSyntaxError::PushToArray);\n\n    int opts = (int)getParserOptions(options);\n    if (Nan::To<v8::Boolean>(excludeImpliedElementsOpt).ToLocalChecked()->Value())\n        opts |= HTML_PARSE_NOIMPLIED | HTML_PARSE_NODEFDTD;\n\n    htmlDocPtr doc;\n    if (!node::Buffer::HasInstance(info[0])) {\n        // Parse a string\n        Nan::Utf8String str(Nan::To<v8::String>(info[0]).ToLocalChecked());\n        doc = htmlReadMemory(*str, str.length(), baseUrl, encoding, opts);\n    }\n    else {\n        // Parse a buffer\n        v8::Local<v8::Object> buf = Nan::To<v8::Object>(info[0]).ToLocalChecked();\n        doc = htmlReadMemory(node::Buffer::Data(buf), node::Buffer::Length(buf),\n                            baseUrl, encoding, opts);\n    }\n\n    xmlSetStructuredErrorFunc(NULL, NULL);\n\n    if (!doc) {\n        xmlError* error = xmlGetLastError();\n        if (error) {\n            return Nan::ThrowError(XmlSyntaxError::BuildSyntaxError(error));\n        }\n        return Nan::ThrowError(\"Could not parse XML string\");\n    }\n\n    v8::Local<v8::Object> doc_handle = XmlDocument::New(doc);\n    Nan::Set(doc_handle, Nan::New<v8::String>(\"errors\").ToLocalChecked(), errors);\n\n    // create the xml document handle to return\n    return info.GetReturnValue().Set(doc_handle);\n}\n\n// FIXME: this method is almost identical to FromHtml above.\n// The two should be refactored to use a common function for most\n// of the work\nNAN_METHOD(XmlDocument::FromXml)\n{\n    Nan::HandleScope scope;\n\n    v8::Local<v8::Array> errors = Nan::New<v8::Array>();\n    xmlResetLastError();\n    xmlSetStructuredErrorFunc(reinterpret_cast<void *>(&errors),\n            XmlSyntaxError::PushToArray);\n\n    v8::Local<v8::Object> options = Nan::To<v8::Object>(info[1]).ToLocalChecked();\n    v8::Local<v8::Value>  baseUrlOpt  = Nan::Get(options,\n        Nan::New<v8::String>(\"baseUrl\").ToLocalChecked()).ToLocalChecked();\n    v8::Local<v8::Value>  encodingOpt = Nan::Get(options,\n        Nan::New<v8::String>(\"encoding\").ToLocalChecked()).ToLocalChecked();\n\n    // the base URL that will be used for this document\n    Nan::Utf8String baseUrl_(Nan::To<v8::String>(baseUrlOpt).ToLocalChecked());\n    const char * baseUrl = *baseUrl_;\n    if (!baseUrlOpt->IsString()) {\n        baseUrl = NULL;\n    }\n\n    // the encoding to be used for this document\n    // (leave NULL for libxml to autodetect)\n    Nan::Utf8String encoding_(Nan::To<v8::String>(encodingOpt).ToLocalChecked());\n    const char * encoding = *encoding_;\n    if (!encodingOpt->IsString()) {\n        encoding = NULL;\n    }\n\n    int opts = (int) getParserOptions(options);\n    xmlDocPtr doc;\n    if (!node::Buffer::HasInstance(info[0])) {\n      // Parse a string\n      Nan::Utf8String str(Nan::To<v8::String>(info[0]).ToLocalChecked());\n      doc = xmlReadMemory(*str, str.length(), baseUrl, \"UTF-8\", opts);\n    }\n    else {\n      // Parse a buffer\n      v8::Local<v8::Object> buf = Nan::To<v8::Object>(info[0]).ToLocalChecked();\n      doc = xmlReadMemory(node::Buffer::Data(buf), node::Buffer::Length(buf),\n                          baseUrl, encoding, opts);\n    }\n\n    xmlSetStructuredErrorFunc(NULL, NULL);\n\n    if (!doc) {\n        xmlError* error = xmlGetLastError();\n        if (error) {\n            return Nan::ThrowError(XmlSyntaxError::BuildSyntaxError(error));\n        }\n        return Nan::ThrowError(\"Could not parse XML string\");\n    }\n\n    v8::Local<v8::Object> doc_handle = XmlDocument::New(doc);\n    Nan::Set(doc_handle, Nan::New<v8::String>(\"errors\").ToLocalChecked(), errors);\n\n    xmlNode* root_node = xmlDocGetRootElement(doc);\n    if (root_node == NULL) {\n        return Nan::ThrowError(\"parsed document has no root element\");\n    }\n\n    // create the xml document handle to return\n    return info.GetReturnValue().Set(doc_handle);\n}\n\nNAN_METHOD(XmlDocument::Validate)\n{\n    Nan::HandleScope scope;\n\n    v8::Local<v8::Array> errors = Nan::New<v8::Array>();\n    xmlResetLastError();\n    xmlSetStructuredErrorFunc(reinterpret_cast<void *>(&errors),\n            XmlSyntaxError::PushToArray);\n\n    XmlDocument* document = Nan::ObjectWrap::Unwrap<XmlDocument>(info.Holder());\n    XmlDocument* documentSchema = Nan::ObjectWrap::Unwrap<XmlDocument>(Nan::To<v8::Object>(info[0]).ToLocalChecked());\n\n    xmlSchemaParserCtxtPtr parser_ctxt = xmlSchemaNewDocParserCtxt(documentSchema->xml_obj);\n    if (parser_ctxt == NULL) {\n        return Nan::ThrowError(\"Could not create context for schema parser\");\n    }\n    xmlSchemaPtr schema = xmlSchemaParse(parser_ctxt);\n    if (schema == NULL) {\n        return Nan::ThrowError(\"Invalid XSD schema\");\n    }\n    xmlSchemaValidCtxtPtr valid_ctxt = xmlSchemaNewValidCtxt(schema);\n    if (valid_ctxt == NULL) {\n        return Nan::ThrowError(\"Unable to create a validation context for the schema\");\n    }\n    bool valid = xmlSchemaValidateDoc(valid_ctxt, document->xml_obj) == 0;\n\n    xmlSetStructuredErrorFunc(NULL, NULL);\n    Nan::Set(info.Holder(), Nan::New<v8::String>(\"validationErrors\").ToLocalChecked(), errors);\n\n    xmlSchemaFreeValidCtxt(valid_ctxt);\n    xmlSchemaFree(schema);\n    xmlSchemaFreeParserCtxt(parser_ctxt);\n\n    return info.GetReturnValue().Set(Nan::New<v8::Boolean>(valid));\n}\n\nNAN_METHOD(XmlDocument::RngValidate)\n{\n    Nan::HandleScope scope;\n\n    v8::Local<v8::Array> errors = Nan::New<v8::Array>();\n    xmlResetLastError();\n    xmlSetStructuredErrorFunc(reinterpret_cast<void *>(&errors),\n            XmlSyntaxError::PushToArray);\n\n    XmlDocument* document = Nan::ObjectWrap::Unwrap<XmlDocument>(info.Holder());\n    XmlDocument* documentSchema = Nan::ObjectWrap::Unwrap<XmlDocument>(Nan::To<v8::Object>(info[0]).ToLocalChecked());\n\n    xmlRelaxNGParserCtxtPtr parser_ctxt = xmlRelaxNGNewDocParserCtxt(documentSchema->xml_obj);\n    if (parser_ctxt == NULL) {\n        return Nan::ThrowError(\"Could not create context for RELAX NG schema parser\");\n    }\n\n    xmlRelaxNGPtr schema = xmlRelaxNGParse(parser_ctxt);\n    if (schema == NULL) {\n        return Nan::ThrowError(\"Invalid RELAX NG schema\");\n    }\n\n    xmlRelaxNGValidCtxtPtr valid_ctxt = xmlRelaxNGNewValidCtxt(schema);\n    if (valid_ctxt == NULL) {\n        return Nan::ThrowError(\"Unable to create a validation context for the RELAX NG schema\");\n    }\n    bool valid = xmlRelaxNGValidateDoc(valid_ctxt, document->xml_obj) == 0;\n\n    xmlSetStructuredErrorFunc(NULL, NULL);\n    Nan::Set(info.Holder(), Nan::New<v8::String>(\"validationErrors\").ToLocalChecked(), errors);\n\n    xmlRelaxNGFreeValidCtxt(valid_ctxt);\n    xmlRelaxNGFree(schema);\n    xmlRelaxNGFreeParserCtxt(parser_ctxt);\n\n    return info.GetReturnValue().Set(Nan::New<v8::Boolean>(valid));\n}\n\n/// this is a blank object with prototype methods\n/// not exposed to the user and not called from js\nNAN_METHOD(XmlDocument::New)\n{\n    Nan::HandleScope scope;\n\n    Nan::Utf8String version(Nan::To<v8::String>(info[0]).ToLocalChecked());\n    xmlDoc* doc = xmlNewDoc((const xmlChar*)(*version));\n\n    XmlDocument* document = new XmlDocument(doc);\n    document->Wrap(info.Holder());\n\n    return info.GetReturnValue().Set(info.Holder());\n}\n\nXmlDocument::XmlDocument(xmlDoc* doc)\n    : xml_obj(doc)\n{\n    xml_obj->_private = this;\n}\n\nXmlDocument::~XmlDocument()\n{\n    xml_obj->_private = NULL;\n    xmlFreeDoc(xml_obj);\n}\n\nvoid\nXmlDocument::Initialize(v8::Local<v8::Object> target)\n{\n    Nan::HandleScope scope;\n\n    v8::Local<v8::FunctionTemplate> tmpl =\n      Nan::New<v8::FunctionTemplate>(New);\n    tmpl->SetClassName(Nan::New<v8::String>(\"Document\").ToLocalChecked());\n\n    constructor_template.Reset( tmpl);\n    tmpl->InstanceTemplate()->SetInternalFieldCount(1);\n\n    /// setup internal methods for bindings\n    Nan::SetPrototypeMethod(tmpl,\n            \"_root\",\n            XmlDocument::Root);\n\n    Nan::SetPrototypeMethod(tmpl,\n            \"_version\",\n            XmlDocument::Version);\n\n    Nan::SetPrototypeMethod(tmpl,\n            \"_encoding\",\n            XmlDocument::Encoding);\n\n    Nan::SetPrototypeMethod(tmpl,\n            \"_toString\",\n            XmlDocument::ToString);\n\n    Nan::SetPrototypeMethod(tmpl,\n            \"_validate\",\n            XmlDocument::Validate);\n    Nan::SetPrototypeMethod(tmpl,\n            \"_rngValidate\",\n            XmlDocument::RngValidate);\n    Nan::SetPrototypeMethod(tmpl,\n            \"_setDtd\",\n            XmlDocument::SetDtd);\n    Nan::SetPrototypeMethod(tmpl,\n            \"_getDtd\",\n            XmlDocument::GetDtd);\n\n\n    Nan::SetMethod(target, \"fromXml\", XmlDocument::FromXml);\n    Nan::SetMethod(target, \"fromHtml\", XmlDocument::FromHtml);\n\n    // used to create new document handles\n    Nan::Set(target, Nan::New<v8::String>(\"Document\").ToLocalChecked(), Nan::GetFunction(tmpl).ToLocalChecked());\n\n    XmlNode::Initialize(target);\n    XmlNamespace::Initialize(target);\n}\n}  // namespcae libxmljs\n", "var fs = require('fs');\nvar libxml = require('../index');\n\nfunction make_error(object) {\n    var err = new Error(object.message);\n    err.domain = object.domain;\n    err.code = object.code;\n    err.level = object.level;\n    err.line = object.line;\n    err.column = object.column;\n    return err;\n}\n\nmodule.exports.parse = function(assert) {\n    var filename = __dirname + '/fixtures/parser.html';\n\n    function attempt_parse(encoding) {\n        var str = fs.readFileSync(filename, encoding);\n\n        var doc = libxml.parseHtml(str);\n        assert.equal('html', doc.root().name());\n        assert.equal('Test HTML document', doc.get('head/title').text());\n        assert.equal('HTML content!', doc.get('body/span').text());\n    }\n\n    // Parse via a string\n    attempt_parse('utf-8');\n\n    // Parse via a Buffer\n    attempt_parse(null);\n\n    assert.done();\n};\n\n// Although libxml defaults to a utf-8 encoding, if not specifically specified\n// it will guess the encoding based on meta http-equiv tags available\n// This test shows that the \"guessed\" encoding can be overridden\nmodule.exports.parse_force_encoding = function(assert) {\n    var filename = __dirname + '/fixtures/parser.euc_jp.html';\n\n    function attempt_parse(encoding, opts) {\n        var str = fs.readFileSync(filename, encoding);\n\n        var doc = libxml.parseHtml(str, opts);\n        assert.equal('html', doc.root().name());\n\n        // make sure libxml rewrite the meta charset of this document\n\n        // calling toString on the document ensure that it is converted to the\n        // correct internal format and the new meta tag is replaced\n        doc.root().toString();\n        var fixedCharset = doc.find('/html/head/meta/@content')[0].value();\n        assert.ok( fixedCharset.indexOf(opts.encoding.toUpperCase() ) !== -1);\n\n        assert.equal('\u30c6\u30b9\u30c8', doc.get('head/title').text());\n        assert.equal('\u30c6\u30b9\u30c8', doc.get('body/div').text());\n    }\n\n    // Parse via a string\n    attempt_parse('utf-8', {encoding: 'utf-8'});\n\n    // Parse via a Buffer\n    attempt_parse(null, {encoding: 'utf-8'});\n\n    assert.done();\n};\n\nmodule.exports.parse_synonym = function(assert) {\n    assert.strictEqual(libxml.parseHtml, libxml.parseHtmlString);\n    assert.done();\n}\n\nmodule.exports.recoverable_parse = function(assert) {\n    var recoverableFile = __dirname +'/fixtures/warnings/amp.html';\n    var str = fs.readFileSync(recoverableFile, 'utf8');\n    var recoverableErrors = [\n      make_error({ domain: 5,\n        code: 23,\n        message: \"htmlParseEntityRef: expecting ';'\\n\",\n        level: 2,\n        line: 12,\n        column: 27 }),\n      make_error({ domain: 5,\n        code: 68,\n        message: \"htmlParseEntityRef: no name\\n\",\n        level: 2,\n        line: 12,\n        column: 38 }),\n      make_error({ domain: 5,\n        code: 23,\n        message: \"htmlParseEntityRef: expecting ';'\\n\",\n        level: 2,\n        line: 14,\n        column: 4 }),\n      make_error({ domain: 5,\n        code: 68,\n        message: \"htmlParseEntityRef: no name\\n\",\n        level: 2,\n        line: 15,\n        column: 4 })\n    ];\n\n    var doc = libxml.parseHtml(str);\n    assert.equal(4, doc.errors.length);\n    for(var i = 0; i < recoverableErrors.length; i++) {\n        assert.equal(recoverableErrors[i].domain, doc.errors[i].domain);\n        assert.equal(recoverableErrors[i].code, doc.errors[i].code);\n        assert.equal(recoverableErrors[i].message, doc.errors[i].message);\n        assert.equal(recoverableErrors[i].level, doc.errors[i].level);\n        assert.equal(recoverableErrors[i].line, doc.errors[i].line);\n    }\n    assert.done();\n};\n\nmodule.exports.parseOptions = function(assert) {\n    var doc = libxml.parseHtml(\"<a/>\", { doctype: false, implied: false }).toString();\n    assert.ok(doc.indexOf('DOCTYPE') === -1);\n    assert.ok(doc.indexOf('body') === -1);\n    assert.ok(doc.indexOf('<html>') === -1);\n\n    doc = libxml.parseHtml(\"<a/>\", { doctype: false, implied: true }).toString();\n    assert.ok(doc.indexOf('DOCTYPE') === -1);\n    assert.ok(doc.indexOf('body') > -1);\n    assert.ok(doc.indexOf('<html>') > -1);\n\n    doc = libxml.parseHtml(\"<a/>\", { implied: false }).toString();\n    assert.ok(doc.indexOf('DOCTYPE') > -1);\n    assert.ok(doc.indexOf('body') === -1);\n    assert.ok(doc.indexOf('<html>') === -1);\n    assert.done();\n}\n\nmodule.exports.toString = function(assert) {\n    var doc = new libxml.Document();\n    assert.ok(doc.toString({declaration: false}) === null);\n    assert.ok(doc.toString({declaration: false, type:'html'}).length === 1);\n\n    doc = libxml.parseHtml(\"<a></a>\");\n    assert.ok(doc.toString().indexOf('<?xml') === -1);\n    assert.ok(doc.toString({ type: 'xml' }).indexOf('<?xml') > -1);\n    assert.ok(doc.toString({ type: 'xhtml' }).indexOf('<?xml') > -1);\n    assert.ok(doc.toString({ type: 'xml', selfCloseEmpty:true }).indexOf('<a/>') > -1);\n    assert.done();\n}\n", "var fs = require('fs');\n\nvar libxml = require('../index');\n\nmodule.exports.parse = function(assert) {\n    var filename = __dirname + '/fixtures/parser.xml';\n    var str = fs.readFileSync(filename, 'utf8');\n\n    var doc = libxml.parseXml(str);\n    assert.equal('1.0', doc.version());\n    assert.equal('UTF-8', doc.encoding());\n    assert.equal('root', doc.root().name());\n    assert.equal('child', doc.get('child').name());\n    assert.equal('grandchild', doc.get('child').get('grandchild').name());\n    assert.equal('with love', doc.get('child/grandchild').text());\n    assert.equal('sibling', doc.get('sibling').name());\n    assert.equal(6, doc.get('sibling').line());\n    assert.equal(3, doc.get('child').attr('to').line());\n    assert.equal('with content!', doc.get('sibling').text());\n    assert.equal(str, doc.toString());\n    assert.done();\n};\n\nmodule.exports.parse_buffer = function(assert) {\n    var filename = __dirname + '/fixtures/parser-utf16.xml';\n    var buf = fs.readFileSync(filename);\n\n    var doc = libxml.parseXml(buf);\n    assert.equal('1.0', doc.version());\n    assert.equal('UTF-16', doc.encoding());\n    assert.equal('root', doc.root().name());\n    assert.done();\n};\n\nmodule.exports.parse_synonym = function(assert) {\n    assert.strictEqual(libxml.parseXml, libxml.parseXmlString);\n    assert.done();\n}\n\nmodule.exports.recoverable_parse = function(assert) {\n    var filename = __dirname + '/fixtures/warnings/ent9.xml';\n    var str = fs.readFileSync(filename, 'utf8');\n\n    var doc = libxml.parseXml(str);\n\n    assert.equal(1, doc.errors.length);\n    var err = doc.errors.shift();\n    assert.ok(err instanceof Error);\n    assert.equal(err.domain, 3);\n    assert.equal(err.column, 13);\n    assert.equal(err.line, 1);\n    assert.equal(err.code, 201);\n    assert.equal(err.str1, 'prefix');\n\n    assert.done();\n};\n\nmodule.exports.baseurl_xml = function(assert) {\n    if (/^win/.test(process.platform)) {\n        // libxml won't resolve the path on Windows\n        assert.done();\n        return;\n    }\n\n    var str = '<!DOCTYPE example SYSTEM \"baseurl.dtd\">\\n' +\n      '<example msg=\"&happy;\"/>\\n';\n\n    // First verify it fails when we don't give baseUrl\n    var doc = libxml.Document.fromXml(str, {\n      dtdvalid: true,\n      nonet: true,\n    });\n    assert.ok(doc.errors.length > 0);\n\n    // Now it should work\n    var doc = libxml.Document.fromXml(str, {\n      dtdvalid: true,\n      nonet: true,\n      baseUrl: __dirname + '/fixtures/example.xml',\n    });\n    assert.ok(!doc.errors || doc.errors.length == 0);\n\n    assert.done();\n};\n\n\n\n\nmodule.exports.fatal_error = function(assert) {\n    var filename = __dirname + '/fixtures/errors/comment.xml';\n    var str = fs.readFileSync(filename, 'utf8');\n    var err = null;\n\n    try {\n        libxml.parseXml(str);\n    } catch(e) { err = e; }\n\n    var errorControl = {\n        domain: 1,\n        code: 4,\n        message: \"Start tag expected, '<' not found\\n\",\n        level: 3,\n        file: null,\n        line: 5,\n        str1: null,\n        str2: null,\n        str3: null,\n        int1: null,\n        column: 10\n    };\n    assert.equal(errorControl.code, err.code);\n    assert.done();\n};\n\nmodule.exports.parse_options = function(assert) {\n    function test_parser_option(input, options, expected) {\n        var output = libxml.parseXml(input, options).toString();\n        output = output.replace(/^<\\?xml version=\"1.0\" encoding=\"UTF-8\"\\?>\\n/, '');\n        output = output.replace(/\\n$/, '');\n        assert.equal(output, expected);\n    }\n\n    test_parser_option(\"<x>&</x>\", { recover: true }, \"<x/>\") // without this option, this document would raise an exception during parsing\n    test_parser_option(\"<!DOCTYPE x [ <!ENTITY foo 'bar'> ]> <x>&foo;</x>\", { noent: true }, '<!DOCTYPE x [\\n<!ENTITY foo \"bar\">\\n]>\\n<x>bar</x>') // foo => bar\n    test_parser_option(\"<x> <a>123</a> </x>\", { }, \"<x> <a>123</a> </x>\") // no indentation even though the toString() default called for formatting\n    test_parser_option(\"<x> <a>123</a> </x>\", { noblanks: true }, \"<x>\\n  <a>123</a>\\n</x>\") // ah, now we have indentation!\n    test_parser_option(\"<x><![CDATA[hi]]></x>\", {  }, \"<x><![CDATA[hi]]></x>\") // normally CDATA stays as CDATA\n    test_parser_option(\"<x><![CDATA[hi]]></x>\", { nocdata: true }, \"<x>hi</x>\") // but here CDATA is removed!\n    assert.done();\n};\n"], "fixing_code": ["{\n  \"name\": \"libxmljs\",\n  \"author\": \"Marco Rogers\",\n  \"contributors\": [\n    \"Jeff Smick\"\n  ],\n  \"binary\": {\n    \"module_name\": \"xmljs\",\n    \"module_path\": \"./build/Release/\",\n    \"host\": \"https://github.com\",\n    \"remote_path\": \"./libxmljs/libxmljs/releases/download/v{version}/\",\n    \"package_name\": \"{node_abi}-{platform}-{arch}.tar.gz\"\n  },\n  \"description\": \"libxml bindings for v8 javascript engine\",\n  \"version\": \"0.19.8\",\n  \"scripts\": {\n    \"install\": \"node-pre-gyp install --fallback-to-build --loglevel http\",\n    \"test\": \"node --expose_gc ./node_modules/.bin/nodeunit test\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"http://github.com/libxmljs/libxmljs.git\"\n  },\n  \"bugs\": {\n    \"url\": \"http://github.com/libxmljs/libxmljs/issues\"\n  },\n  \"main\": \"./index\",\n  \"license\": \"MIT\",\n  \"engines\": {\n    \"node\": \">=0.8.0\"\n  },\n  \"dependencies\": {\n    \"bindings\": \"~1.3.0\",\n    \"nan\": \"~2.14.0\",\n    \"node-pre-gyp\": \"~0.11.0\"\n  },\n  \"devDependencies\": {\n    \"nodeunit\": \"~0.11.2\",\n    \"semver\": \"~5.5.0\"\n  }\n}", "// Copyright 2009, Squish Tech, LLC.\n\n#include <node.h>\n#include <node_buffer.h>\n\n#include <cstring>\n\n//#include <libxml/tree.h>\n#include <libxml/HTMLtree.h>\n#include <libxml/HTMLparser.h>\n#include <libxml/xmlschemas.h>\n#include <libxml/relaxng.h>\n#include <libxml/xmlsave.h>\n\n#include \"xml_document.h\"\n#include \"xml_element.h\"\n#include \"xml_namespace.h\"\n#include \"xml_syntax_error.h\"\n\nnamespace libxmljs {\n\nNan::Persistent<v8::FunctionTemplate> XmlDocument::constructor_template;\n\nNAN_METHOD(XmlDocument::Encoding)\n{\n    Nan::HandleScope scope;\n    XmlDocument* document = Nan::ObjectWrap::Unwrap<XmlDocument>(info.Holder());\n    assert(document);\n\n    // if no args, get the encoding\n    if (info.Length() == 0 || info[0]->IsUndefined()) {\n        if (document->xml_obj->encoding)\n            return info.GetReturnValue().Set(Nan::New<v8::String>(\n                        (const char *)document->xml_obj->encoding,\n                        xmlStrlen((const xmlChar*)document->xml_obj->encoding)).ToLocalChecked());\n\n        return info.GetReturnValue().Set(Nan::Null());\n    }\n\n    // set the encoding otherwise\n    Nan::Utf8String encoding(Nan::To<v8::String>(info[0]).ToLocalChecked());\n    if(document->xml_obj->encoding != NULL) {\n        xmlFree((xmlChar*)document->xml_obj->encoding);\n    }\n\n    document->xml_obj->encoding = xmlStrdup((const xmlChar*)*encoding);\n    return info.GetReturnValue().Set(info.Holder());\n}\n\nNAN_METHOD(XmlDocument::Version)\n{\n    Nan::HandleScope scope;\n    XmlDocument *document = Nan::ObjectWrap::Unwrap<XmlDocument>(info.Holder());\n    assert(document);\n\n    if (document->xml_obj->version)\n        return info.GetReturnValue().Set(Nan::New<v8::String>((const char *)document->xml_obj->version,\n                    xmlStrlen((const xmlChar*)document->xml_obj->version)).ToLocalChecked());\n\n    return info.GetReturnValue().Set(Nan::Null());\n}\n\nNAN_METHOD(XmlDocument::Root)\n{\n    Nan::HandleScope scope;\n    XmlDocument* document = Nan::ObjectWrap::Unwrap<XmlDocument>(info.Holder());\n    assert(document);\n\n    xmlNode* root = xmlDocGetRootElement(document->xml_obj);\n\n    if (info.Length() == 0 || info[0]->IsUndefined())\n    {\n        if (!root) {\n            return info.GetReturnValue().Set(Nan::Null());\n        }\n        return info.GetReturnValue().Set(XmlElement::New(root));\n    }\n\n    if (root != NULL) {\n        return Nan::ThrowError(\"Holder document already has a root node\");\n    }\n\n    // set the element as the root element for the document\n    // allows for proper retrieval of root later\n    XmlElement* element = Nan::ObjectWrap::Unwrap<XmlElement>(Nan::To<v8::Object>(info[0]).ToLocalChecked());\n    assert(element);\n    xmlDocSetRootElement(document->xml_obj, element->xml_obj);\n    element->ref_wrapped_ancestor();\n    return info.GetReturnValue().Set(info[0]);\n}\n\nNAN_METHOD(XmlDocument::GetDtd)\n{\n    Nan::HandleScope scope;\n    XmlDocument* document = Nan::ObjectWrap::Unwrap<XmlDocument>(info.Holder());\n    assert(document);\n\n    xmlDtdPtr dtd = xmlGetIntSubset(document->xml_obj);\n\n    if (!dtd) {\n        return info.GetReturnValue().Set(Nan::Null());\n    }\n\n    const char* name = (const char *)dtd->name;\n    const char* extId = (const char *)dtd->ExternalID;\n    const char* sysId = (const char *)dtd->SystemID;\n\n    v8::Local<v8::Object> dtdObj = Nan::New<v8::Object>();\n    v8::Local<v8::Value> nameValue = (v8::Local<v8::Value>)Nan::Null();\n    v8::Local<v8::Value> extValue = (v8::Local<v8::Value>)Nan::Null();\n    v8::Local<v8::Value> sysValue = (v8::Local<v8::Value>)Nan::Null();\n\n    if (name != NULL) {\n        nameValue = (v8::Local<v8::Value>)Nan::New<v8::String>(name, strlen(name)).ToLocalChecked();\n    }\n\n    if (extId != NULL) {\n        extValue = (v8::Local<v8::Value>)Nan::New<v8::String>(extId, strlen(extId)).ToLocalChecked();\n    }\n\n    if (sysId != NULL) {\n        sysValue = (v8::Local<v8::Value>)Nan::New<v8::String>(sysId, strlen(sysId)).ToLocalChecked();\n    }\n\n\n    Nan::Set(dtdObj, Nan::New<v8::String>(\"name\").ToLocalChecked(), nameValue);\n\n    Nan::Set(dtdObj, Nan::New<v8::String>(\"externalId\").ToLocalChecked(), extValue);\n\n    Nan::Set(dtdObj, Nan::New<v8::String>(\"systemId\").ToLocalChecked(), sysValue);\n\n    return info.GetReturnValue().Set(dtdObj);\n\n}\n\nNAN_METHOD(XmlDocument::SetDtd)\n{\n    Nan::HandleScope scope;\n\n    XmlDocument* document = Nan::ObjectWrap::Unwrap<XmlDocument>(info.Holder());\n    assert(document);\n\n    Nan::Utf8String name(info[0]);\n\n    v8::Local<v8::Value> extIdOpt;\n    v8::Local<v8::Value> sysIdOpt;\n    if (info.Length() > 1 && info[1]->IsString()) {\n      extIdOpt = info[1];\n    }\n    if (info.Length() > 2 && info[2]->IsString()) {\n      sysIdOpt = info[2];\n    }\n\n    Nan::Utf8String extIdRaw(extIdOpt);\n    Nan::Utf8String sysIdRaw(sysIdOpt);\n\n    //must be set to null in order for xmlCreateIntSubset to ignore them\n    const char* extId = (extIdRaw.length()) ? *extIdRaw : NULL;\n    const char* sysId = (sysIdRaw.length()) ? *sysIdRaw : NULL;\n\n    //No good way of unsetting the doctype if it is previously set...this allows us to.\n    xmlDtdPtr dtd = xmlGetIntSubset(document->xml_obj);\n\n    xmlUnlinkNode((xmlNodePtr) dtd);\n    xmlFreeNode((xmlNodePtr) dtd);\n\n    xmlCreateIntSubset(document->xml_obj, (const xmlChar *) *name, (const xmlChar *) extId, (const xmlChar *) sysId);\n\n    return info.GetReturnValue().Set(info.Holder());\n}\n\nNAN_METHOD(XmlDocument::ToString)\n{\n    Nan::HandleScope scope;\n\n    XmlDocument* document = Nan::ObjectWrap::Unwrap<XmlDocument>(info.Holder());\n    assert(document);\n\n    int options = 0;\n\n    if (info.Length() > 0) {\n    if (info[0]->IsBoolean()) {\n        if (Nan::To<v8::Boolean>(info[0]).ToLocalChecked()->Value() == true) {\n            options |= XML_SAVE_FORMAT;\n        }\n    } else if (info[0]->IsObject()) {\n        v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();\n\n        // drop the xml declaration\n        if (Nan::Get(obj, Nan::New<v8::String>(\"declaration\").ToLocalChecked()).ToLocalChecked()->IsFalse()) {\n            options |= XML_SAVE_NO_DECL;\n        }\n\n        // format save output\n        if (Nan::Get(obj, Nan::New<v8::String>(\"format\").ToLocalChecked()).ToLocalChecked()->IsTrue()) {\n            options |= XML_SAVE_FORMAT;\n        }\n\n        // no empty tags (only works with XML) ex: <title></title> becomes <title/>\n        if (Nan::Get(obj, Nan::New<v8::String>(\"selfCloseEmpty\").ToLocalChecked()).ToLocalChecked()->IsFalse()) {\n            options |= XML_SAVE_NO_EMPTY;\n        }\n\n        // format with non-significant whitespace\n        if (Nan::Get(obj, Nan::New<v8::String>(\"whitespace\").ToLocalChecked()).ToLocalChecked()->IsTrue()) {\n            options |= XML_SAVE_WSNONSIG;\n        }\n\n        v8::Local<v8::Value> type = Nan::Get(obj, Nan::New<v8::String>(\"type\").ToLocalChecked()).ToLocalChecked();\n        if (Nan::Equals(type, Nan::New<v8::String>(\"XML\").ToLocalChecked()).ToChecked() ||\n            Nan::Equals(type, Nan::New<v8::String>(\"xml\").ToLocalChecked()).ToChecked()) {\n            options |= XML_SAVE_AS_XML;    // force XML serialization on HTML doc\n        } else if (Nan::Equals(type, Nan::New<v8::String>(\"HTML\").ToLocalChecked()).ToChecked() ||\n                 Nan::Equals(type, Nan::New<v8::String>(\"html\").ToLocalChecked()).ToChecked()) {\n            options |= XML_SAVE_AS_HTML;   // force HTML serialization on XML doc\n            // if the document is XML and we want formatted HTML output\n            // we must use the XHTML serializer because the default HTML\n            // serializer only formats node->type = HTML_NODE and not XML_NODEs\n            if ((options & XML_SAVE_FORMAT) && (options & XML_SAVE_XHTML) == false) {\n              options |= XML_SAVE_XHTML;\n            }\n        } else if (Nan::Equals(type, Nan::New<v8::String>(\"XHTML\").ToLocalChecked()).ToChecked() ||\n                 Nan::Equals(type, Nan::New<v8::String>(\"xhtml\").ToLocalChecked()).ToChecked()) {\n                options |= XML_SAVE_XHTML;    // force XHTML serialization\n            }\n        }\n    }\n\n    xmlBuffer* buf = xmlBufferCreate();\n    xmlSaveCtxt* savectx = xmlSaveToBuffer(buf, \"UTF-8\", options);\n    xmlSaveTree(savectx, (xmlNode*)document->xml_obj);\n    xmlSaveFlush(savectx);\n    xmlSaveClose(savectx);\n    v8::Local<v8::Value> ret = Nan::Null();\n    if (xmlBufferLength(buf) > 0)\n        ret = Nan::New<v8::String>((char*)xmlBufferContent(buf), xmlBufferLength(buf)).ToLocalChecked();\n    xmlBufferFree(buf);\n\n    return info.GetReturnValue().Set(ret);\n}\n\n// not called from node\n// private api\nv8::Local<v8::Object>\nXmlDocument::New(xmlDoc* doc)\n{\n    Nan::EscapableHandleScope scope;\n\n    if (doc->_private) {\n        return scope.Escape(static_cast<XmlDocument*>(doc->_private)->handle());\n    }\n\n    v8::Local<v8::Object> obj = Nan::NewInstance(Nan::GetFunction(Nan::New(constructor_template)).ToLocalChecked()).ToLocalChecked();\n\n    XmlDocument* document = Nan::ObjectWrap::Unwrap<XmlDocument>(obj);\n\n    // replace the document we created\n    document->xml_obj->_private = NULL;\n    xmlFreeDoc(document->xml_obj);\n    document->xml_obj = doc;\n\n    // store ourselves in the document\n    // this is how we can get instances or already existing v8 objects\n    doc->_private = document;\n\n    return scope.Escape(obj);\n}\n\nint getParserOption(v8::Local<v8::Object> props, const char *key, int value, bool defaultValue = true) {\n    Nan::HandleScope scope;\n    v8::Local<v8::Value> prop = Nan::Get(props, Nan::New<v8::String>(key).ToLocalChecked()).ToLocalChecked();\n    return !prop->IsUndefined() && Nan::To<v8::Boolean>(prop).ToLocalChecked()->Value() == defaultValue ? value : 0;\n}\n\nxmlParserOption getParserOptions(v8::Local<v8::Object> props) {\n    int ret = 0;\n\n    // http://xmlsoft.org/html/libxml-parser.html#xmlParserOption\n    // http://www.xmlsoft.org/html/libxml-HTMLparser.html#htmlParserOption\n\n    ret |= getParserOption(props, \"recover\", XML_PARSE_RECOVER);            // 1: recover on errors\n    /*ret |= getParserOption(props, \"recover\", HTML_PARSE_RECOVER);           // 1: Relaxed parsing*/\n\n    ret |= getParserOption(props, \"noent\", XML_PARSE_NOENT);                // 2: substitute entities\n\n    ret |= getParserOption(props, \"dtdload\", XML_PARSE_DTDLOAD);            // 4: load the external subset\n    ret |= getParserOption(props, \"doctype\", HTML_PARSE_NODEFDTD, false);   // 4: do not default a doctype if not found\n\n    ret |= getParserOption(props, \"dtdattr\", XML_PARSE_DTDATTR);            // 8: default DTD attributes\n    ret |= getParserOption(props, \"dtdvalid\", XML_PARSE_DTDVALID);          // 16: validate with the DTD\n\n    ret |= getParserOption(props, \"noerror\", XML_PARSE_NOERROR);            // 32: suppress error reports\n    ret |= getParserOption(props, \"errors\",  HTML_PARSE_NOERROR, false);    // 32: suppress error reports\n\n    ret |= getParserOption(props, \"nowarning\", XML_PARSE_NOWARNING);        // 64: suppress warning reports\n    ret |= getParserOption(props, \"warnings\", HTML_PARSE_NOWARNING, false); // 64: suppress warning reports\n\n    ret |= getParserOption(props, \"pedantic\", XML_PARSE_PEDANTIC);          // 128: pedantic error reporting\n    /*ret |= getParserOption(props, \"pedantic\", HTML_PARSE_PEDANTIC);         // 128: pedantic error reporting*/\n\n    ret |= getParserOption(props, \"noblanks\", XML_PARSE_NOBLANKS);          // 256: remove blank nodes\n    ret |= getParserOption(props, \"blanks\", HTML_PARSE_NOBLANKS, false);    // 256: remove blank nodes\n\n    ret |= getParserOption(props, \"sax1\", XML_PARSE_SAX1);                  // 512: use the SAX1 interface internally\n    ret |= getParserOption(props, \"xinclude\", XML_PARSE_XINCLUDE);          // 1024: Implement XInclude substitition\n\n    ret |= getParserOption(props, \"nonet\", XML_PARSE_NONET);                // 2048: Forbid network access\n    ret |= getParserOption(props, \"net\", HTML_PARSE_NONET, false);          // 2048: Forbid network access\n\n    ret |= getParserOption(props, \"nodict\", XML_PARSE_NODICT);              // 4096: Do not reuse the context dictionnary\n    ret |= getParserOption(props, \"dict\", XML_PARSE_NODICT, false);         // 4096: Do not reuse the context dictionnary\n\n    ret |= getParserOption(props, \"nsclean\", XML_PARSE_NSCLEAN);            // 8192: remove redundant namespaces declarations\n    ret |= getParserOption(props, \"implied\", HTML_PARSE_NOIMPLIED, false);  // 8192: Do not add implied html/body elements\n\n    ret |= getParserOption(props, \"nocdata\", XML_PARSE_NOCDATA);            // 16384: merge CDATA as text nodes\n    ret |= getParserOption(props, \"cdata\", XML_PARSE_NOCDATA, false);       // 16384: merge CDATA as text nodes\n\n    ret |= getParserOption(props, \"noxincnode\", XML_PARSE_NOXINCNODE);      // 32768: do not generate XINCLUDE START/END nodes\n    ret |= getParserOption(props, \"xincnode\", XML_PARSE_NOXINCNODE, false); // 32768: do not generate XINCLUDE START/END nodes\n\n    ret |= getParserOption(props, \"compact\", XML_PARSE_COMPACT);            // 65536: compact small text nodes; no modification of the tree allowed afterwards (will possibly crash if you try to modify the tree)\n    /*ret |= getParserOption(props, \"compact\", HTML_PARSE_COMPACT , false);   // 65536: compact small text nodes*/\n\n    ret |= getParserOption(props, \"old10\", XML_PARSE_OLD10);                // 131072: parse using XML-1.0 before update 5\n\n    ret |= getParserOption(props, \"nobasefix\", XML_PARSE_NOBASEFIX);        // 262144: do not fixup XINCLUDE xml:base uris\n    ret |= getParserOption(props, \"basefix\", XML_PARSE_NOBASEFIX, false);   // 262144: do not fixup XINCLUDE xml:base uris\n\n    ret |= getParserOption(props, \"huge\", XML_PARSE_HUGE);                  // 524288: relax any hardcoded limit from the parser\n    ret |= getParserOption(props, \"oldsax\", XML_PARSE_OLDSAX);              // 1048576: parse using SAX2 interface before 2.7.0\n\n    ret |= getParserOption(props, \"ignore_enc\", XML_PARSE_IGNORE_ENC);      // 2097152: ignore internal document encoding hint\n    /*ret |= getParserOption(props, \"ignore_enc\", HTML_PARSE_IGNORE_ENC);      // 2097152: ignore internal document encoding hint*/\n\n    ret |= getParserOption(props, \"big_lines\", XML_PARSE_BIG_LINES);        // 4194304: Store big lines numbers in text PSVI field\n\n    return (xmlParserOption)ret;\n}\n\nNAN_METHOD(XmlDocument::FromHtml)\n{\n    Nan::HandleScope scope;\n\n    v8::Local<v8::Object> options = Nan::To<v8::Object>(info[1]).ToLocalChecked();\n    v8::Local<v8::Value>  baseUrlOpt  = Nan::Get(options,\n        Nan::New<v8::String>(\"baseUrl\").ToLocalChecked()).ToLocalChecked();\n    v8::Local<v8::Value>  encodingOpt = Nan::Get(options,\n        Nan::New<v8::String>(\"encoding\").ToLocalChecked()).ToLocalChecked();\n    v8::Local<v8::Value> excludeImpliedElementsOpt = Nan::Get(options,\n        Nan::New<v8::String>(\"excludeImpliedElements\").ToLocalChecked()).ToLocalChecked();\n\n    // the base URL that will be used for this HTML parsed document\n    Nan::Utf8String baseUrl_(Nan::To<v8::String>(baseUrlOpt).ToLocalChecked());\n    const char * baseUrl = *baseUrl_;\n    if (!baseUrlOpt->IsString()) {\n        baseUrl = NULL;\n    }\n\n    // the encoding to be used for this document\n    // (leave NULL for libxml to autodetect)\n    Nan::Utf8String encoding_(Nan::To<v8::String>(encodingOpt).ToLocalChecked());\n    const char * encoding = *encoding_;\n\n    if (!encodingOpt->IsString()) {\n        encoding = NULL;\n    }\n\n    v8::Local<v8::Array> errors = Nan::New<v8::Array>();\n    xmlResetLastError();\n    xmlSetStructuredErrorFunc(reinterpret_cast<void*>(&errors), XmlSyntaxError::PushToArray);\n\n    int opts = (int)getParserOptions(options);\n    if (Nan::To<v8::Boolean>(excludeImpliedElementsOpt).ToLocalChecked()->Value())\n        opts |= HTML_PARSE_NOIMPLIED | HTML_PARSE_NODEFDTD;\n\n    htmlDocPtr doc;\n    if (info[0]->IsString()) {\n        // Parse a string\n        Nan::Utf8String str(Nan::To<v8::String>(info[0]).ToLocalChecked());\n        doc = htmlReadMemory(*str, str.length(), baseUrl, encoding, opts);\n    }\n    else if (node::Buffer::HasInstance(info[0])) {\n        // Parse a buffer\n        v8::Local<v8::Object> buf = Nan::To<v8::Object>(info[0]).ToLocalChecked();\n        doc = htmlReadMemory(node::Buffer::Data(buf), node::Buffer::Length(buf),\n                            baseUrl, encoding, opts);\n    } else {\n        return Nan::ThrowError(\"XML must be a string or buffer\");\n    }\n\n    xmlSetStructuredErrorFunc(NULL, NULL);\n\n    if (!doc) {\n        xmlError* error = xmlGetLastError();\n        if (error) {\n            return Nan::ThrowError(XmlSyntaxError::BuildSyntaxError(error));\n        }\n        return Nan::ThrowError(\"Could not parse XML string\");\n    }\n\n    v8::Local<v8::Object> doc_handle = XmlDocument::New(doc);\n    Nan::Set(doc_handle, Nan::New<v8::String>(\"errors\").ToLocalChecked(), errors);\n\n    // create the xml document handle to return\n    return info.GetReturnValue().Set(doc_handle);\n}\n\n// FIXME: this method is almost identical to FromHtml above.\n// The two should be refactored to use a common function for most\n// of the work\nNAN_METHOD(XmlDocument::FromXml)\n{\n    Nan::HandleScope scope;\n\n    v8::Local<v8::Array> errors = Nan::New<v8::Array>();\n    xmlResetLastError();\n    xmlSetStructuredErrorFunc(reinterpret_cast<void *>(&errors),\n            XmlSyntaxError::PushToArray);\n\n    v8::Local<v8::Object> options = Nan::To<v8::Object>(info[1]).ToLocalChecked();\n    v8::Local<v8::Value>  baseUrlOpt  = Nan::Get(options,\n        Nan::New<v8::String>(\"baseUrl\").ToLocalChecked()).ToLocalChecked();\n    v8::Local<v8::Value>  encodingOpt = Nan::Get(options,\n        Nan::New<v8::String>(\"encoding\").ToLocalChecked()).ToLocalChecked();\n\n    // the base URL that will be used for this document\n    Nan::Utf8String baseUrl_(Nan::To<v8::String>(baseUrlOpt).ToLocalChecked());\n    const char * baseUrl = *baseUrl_;\n    if (!baseUrlOpt->IsString()) {\n        baseUrl = NULL;\n    }\n\n    // the encoding to be used for this document\n    // (leave NULL for libxml to autodetect)\n    Nan::Utf8String encoding_(Nan::To<v8::String>(encodingOpt).ToLocalChecked());\n    const char * encoding = *encoding_;\n    if (!encodingOpt->IsString()) {\n        encoding = NULL;\n    }\n\n    int opts = (int) getParserOptions(options);\n    xmlDocPtr doc;\n    if (info[0]->IsString()) {\n      // Parse a string\n      Nan::Utf8String str(Nan::To<v8::String>(info[0]).ToLocalChecked());\n      doc = xmlReadMemory(*str, str.length(), baseUrl, \"UTF-8\", opts);\n    }\n    else if (node::Buffer::HasInstance(info[0])) {\n      // Parse a buffer\n      v8::Local<v8::Object> buf = Nan::To<v8::Object>(info[0]).ToLocalChecked();\n      doc = xmlReadMemory(node::Buffer::Data(buf), node::Buffer::Length(buf),\n                          baseUrl, encoding, opts);\n    } else {\n        return Nan::ThrowError(\"XML must be a string or buffer\");\n    }\n\n    xmlSetStructuredErrorFunc(NULL, NULL);\n\n    if (!doc) {\n        xmlError* error = xmlGetLastError();\n        if (error) {\n            return Nan::ThrowError(XmlSyntaxError::BuildSyntaxError(error));\n        }\n        return Nan::ThrowError(\"Could not parse XML string\");\n    }\n\n    v8::Local<v8::Object> doc_handle = XmlDocument::New(doc);\n    Nan::Set(doc_handle, Nan::New<v8::String>(\"errors\").ToLocalChecked(), errors);\n\n    xmlNode* root_node = xmlDocGetRootElement(doc);\n    if (root_node == NULL) {\n        return Nan::ThrowError(\"parsed document has no root element\");\n    }\n\n    // create the xml document handle to return\n    return info.GetReturnValue().Set(doc_handle);\n}\n\nNAN_METHOD(XmlDocument::Validate)\n{\n    Nan::HandleScope scope;\n\n    v8::Local<v8::Array> errors = Nan::New<v8::Array>();\n    xmlResetLastError();\n    xmlSetStructuredErrorFunc(reinterpret_cast<void *>(&errors),\n            XmlSyntaxError::PushToArray);\n\n    XmlDocument* document = Nan::ObjectWrap::Unwrap<XmlDocument>(info.Holder());\n    XmlDocument* documentSchema = Nan::ObjectWrap::Unwrap<XmlDocument>(Nan::To<v8::Object>(info[0]).ToLocalChecked());\n\n    xmlSchemaParserCtxtPtr parser_ctxt = xmlSchemaNewDocParserCtxt(documentSchema->xml_obj);\n    if (parser_ctxt == NULL) {\n        return Nan::ThrowError(\"Could not create context for schema parser\");\n    }\n    xmlSchemaPtr schema = xmlSchemaParse(parser_ctxt);\n    if (schema == NULL) {\n        return Nan::ThrowError(\"Invalid XSD schema\");\n    }\n    xmlSchemaValidCtxtPtr valid_ctxt = xmlSchemaNewValidCtxt(schema);\n    if (valid_ctxt == NULL) {\n        return Nan::ThrowError(\"Unable to create a validation context for the schema\");\n    }\n    bool valid = xmlSchemaValidateDoc(valid_ctxt, document->xml_obj) == 0;\n\n    xmlSetStructuredErrorFunc(NULL, NULL);\n    Nan::Set(info.Holder(), Nan::New<v8::String>(\"validationErrors\").ToLocalChecked(), errors);\n\n    xmlSchemaFreeValidCtxt(valid_ctxt);\n    xmlSchemaFree(schema);\n    xmlSchemaFreeParserCtxt(parser_ctxt);\n\n    return info.GetReturnValue().Set(Nan::New<v8::Boolean>(valid));\n}\n\nNAN_METHOD(XmlDocument::RngValidate)\n{\n    Nan::HandleScope scope;\n\n    v8::Local<v8::Array> errors = Nan::New<v8::Array>();\n    xmlResetLastError();\n    xmlSetStructuredErrorFunc(reinterpret_cast<void *>(&errors),\n            XmlSyntaxError::PushToArray);\n\n    XmlDocument* document = Nan::ObjectWrap::Unwrap<XmlDocument>(info.Holder());\n    XmlDocument* documentSchema = Nan::ObjectWrap::Unwrap<XmlDocument>(Nan::To<v8::Object>(info[0]).ToLocalChecked());\n\n    xmlRelaxNGParserCtxtPtr parser_ctxt = xmlRelaxNGNewDocParserCtxt(documentSchema->xml_obj);\n    if (parser_ctxt == NULL) {\n        return Nan::ThrowError(\"Could not create context for RELAX NG schema parser\");\n    }\n\n    xmlRelaxNGPtr schema = xmlRelaxNGParse(parser_ctxt);\n    if (schema == NULL) {\n        return Nan::ThrowError(\"Invalid RELAX NG schema\");\n    }\n\n    xmlRelaxNGValidCtxtPtr valid_ctxt = xmlRelaxNGNewValidCtxt(schema);\n    if (valid_ctxt == NULL) {\n        return Nan::ThrowError(\"Unable to create a validation context for the RELAX NG schema\");\n    }\n    bool valid = xmlRelaxNGValidateDoc(valid_ctxt, document->xml_obj) == 0;\n\n    xmlSetStructuredErrorFunc(NULL, NULL);\n    Nan::Set(info.Holder(), Nan::New<v8::String>(\"validationErrors\").ToLocalChecked(), errors);\n\n    xmlRelaxNGFreeValidCtxt(valid_ctxt);\n    xmlRelaxNGFree(schema);\n    xmlRelaxNGFreeParserCtxt(parser_ctxt);\n\n    return info.GetReturnValue().Set(Nan::New<v8::Boolean>(valid));\n}\n\n/// this is a blank object with prototype methods\n/// not exposed to the user and not called from js\nNAN_METHOD(XmlDocument::New)\n{\n    Nan::HandleScope scope;\n\n    Nan::Utf8String version(Nan::To<v8::String>(info[0]).ToLocalChecked());\n    xmlDoc* doc = xmlNewDoc((const xmlChar*)(*version));\n\n    XmlDocument* document = new XmlDocument(doc);\n    document->Wrap(info.Holder());\n\n    return info.GetReturnValue().Set(info.Holder());\n}\n\nXmlDocument::XmlDocument(xmlDoc* doc)\n    : xml_obj(doc)\n{\n    xml_obj->_private = this;\n}\n\nXmlDocument::~XmlDocument()\n{\n    xml_obj->_private = NULL;\n    xmlFreeDoc(xml_obj);\n}\n\nvoid\nXmlDocument::Initialize(v8::Local<v8::Object> target)\n{\n    Nan::HandleScope scope;\n\n    v8::Local<v8::FunctionTemplate> tmpl =\n      Nan::New<v8::FunctionTemplate>(New);\n    tmpl->SetClassName(Nan::New<v8::String>(\"Document\").ToLocalChecked());\n\n    constructor_template.Reset( tmpl);\n    tmpl->InstanceTemplate()->SetInternalFieldCount(1);\n\n    /// setup internal methods for bindings\n    Nan::SetPrototypeMethod(tmpl,\n            \"_root\",\n            XmlDocument::Root);\n\n    Nan::SetPrototypeMethod(tmpl,\n            \"_version\",\n            XmlDocument::Version);\n\n    Nan::SetPrototypeMethod(tmpl,\n            \"_encoding\",\n            XmlDocument::Encoding);\n\n    Nan::SetPrototypeMethod(tmpl,\n            \"_toString\",\n            XmlDocument::ToString);\n\n    Nan::SetPrototypeMethod(tmpl,\n            \"_validate\",\n            XmlDocument::Validate);\n    Nan::SetPrototypeMethod(tmpl,\n            \"_rngValidate\",\n            XmlDocument::RngValidate);\n    Nan::SetPrototypeMethod(tmpl,\n            \"_setDtd\",\n            XmlDocument::SetDtd);\n    Nan::SetPrototypeMethod(tmpl,\n            \"_getDtd\",\n            XmlDocument::GetDtd);\n\n\n    Nan::SetMethod(target, \"fromXml\", XmlDocument::FromXml);\n    Nan::SetMethod(target, \"fromHtml\", XmlDocument::FromHtml);\n\n    // used to create new document handles\n    Nan::Set(target, Nan::New<v8::String>(\"Document\").ToLocalChecked(), Nan::GetFunction(tmpl).ToLocalChecked());\n\n    XmlNode::Initialize(target);\n    XmlNamespace::Initialize(target);\n}\n}  // namespcae libxmljs\n", "var fs = require('fs');\nvar libxml = require('../index');\n\nfunction make_error(object) {\n    var err = new Error(object.message);\n    err.domain = object.domain;\n    err.code = object.code;\n    err.level = object.level;\n    err.line = object.line;\n    err.column = object.column;\n    return err;\n}\n\nmodule.exports.parse = function(assert) {\n    var filename = __dirname + '/fixtures/parser.html';\n\n    function attempt_parse(encoding) {\n        var str = fs.readFileSync(filename, encoding);\n\n        var doc = libxml.parseHtml(str);\n        assert.equal('html', doc.root().name());\n        assert.equal('Test HTML document', doc.get('head/title').text());\n        assert.equal('HTML content!', doc.get('body/span').text());\n    }\n\n    // Parse via a string\n    attempt_parse('utf-8');\n\n    // Parse via a Buffer\n    attempt_parse(null);\n\n    assert.done();\n};\n\nmodule.exports.invalid_input = function(assert) {\n    try {\n        libxml.parseHtml({object: true});\n        assert.ok(false);\n    } catch(err) {\n        assert.ok(true)\n    }\n\n    assert.done();\n};\n\n// Although libxml defaults to a utf-8 encoding, if not specifically specified\n// it will guess the encoding based on meta http-equiv tags available\n// This test shows that the \"guessed\" encoding can be overridden\nmodule.exports.parse_force_encoding = function(assert) {\n    var filename = __dirname + '/fixtures/parser.euc_jp.html';\n\n    function attempt_parse(encoding, opts) {\n        var str = fs.readFileSync(filename, encoding);\n\n        var doc = libxml.parseHtml(str, opts);\n        assert.equal('html', doc.root().name());\n\n        // make sure libxml rewrite the meta charset of this document\n\n        // calling toString on the document ensure that it is converted to the\n        // correct internal format and the new meta tag is replaced\n        doc.root().toString();\n        var fixedCharset = doc.find('/html/head/meta/@content')[0].value();\n        assert.ok( fixedCharset.indexOf(opts.encoding.toUpperCase() ) !== -1);\n\n        assert.equal('\u30c6\u30b9\u30c8', doc.get('head/title').text());\n        assert.equal('\u30c6\u30b9\u30c8', doc.get('body/div').text());\n    }\n\n    // Parse via a string\n    attempt_parse('utf-8', {encoding: 'utf-8'});\n\n    // Parse via a Buffer\n    attempt_parse(null, {encoding: 'utf-8'});\n\n    assert.done();\n};\n\nmodule.exports.parse_synonym = function(assert) {\n    assert.strictEqual(libxml.parseHtml, libxml.parseHtmlString);\n    assert.done();\n}\n\nmodule.exports.recoverable_parse = function(assert) {\n    var recoverableFile = __dirname +'/fixtures/warnings/amp.html';\n    var str = fs.readFileSync(recoverableFile, 'utf8');\n    var recoverableErrors = [\n      make_error({ domain: 5,\n        code: 23,\n        message: \"htmlParseEntityRef: expecting ';'\\n\",\n        level: 2,\n        line: 12,\n        column: 27 }),\n      make_error({ domain: 5,\n        code: 68,\n        message: \"htmlParseEntityRef: no name\\n\",\n        level: 2,\n        line: 12,\n        column: 38 }),\n      make_error({ domain: 5,\n        code: 23,\n        message: \"htmlParseEntityRef: expecting ';'\\n\",\n        level: 2,\n        line: 14,\n        column: 4 }),\n      make_error({ domain: 5,\n        code: 68,\n        message: \"htmlParseEntityRef: no name\\n\",\n        level: 2,\n        line: 15,\n        column: 4 })\n    ];\n\n    var doc = libxml.parseHtml(str);\n    assert.equal(4, doc.errors.length);\n    for(var i = 0; i < recoverableErrors.length; i++) {\n        assert.equal(recoverableErrors[i].domain, doc.errors[i].domain);\n        assert.equal(recoverableErrors[i].code, doc.errors[i].code);\n        assert.equal(recoverableErrors[i].message, doc.errors[i].message);\n        assert.equal(recoverableErrors[i].level, doc.errors[i].level);\n        assert.equal(recoverableErrors[i].line, doc.errors[i].line);\n    }\n    assert.done();\n};\n\nmodule.exports.parseOptions = function(assert) {\n    var doc = libxml.parseHtml(\"<a/>\", { doctype: false, implied: false }).toString();\n    assert.ok(doc.indexOf('DOCTYPE') === -1);\n    assert.ok(doc.indexOf('body') === -1);\n    assert.ok(doc.indexOf('<html>') === -1);\n\n    doc = libxml.parseHtml(\"<a/>\", { doctype: false, implied: true }).toString();\n    assert.ok(doc.indexOf('DOCTYPE') === -1);\n    assert.ok(doc.indexOf('body') > -1);\n    assert.ok(doc.indexOf('<html>') > -1);\n\n    doc = libxml.parseHtml(\"<a/>\", { implied: false }).toString();\n    assert.ok(doc.indexOf('DOCTYPE') > -1);\n    assert.ok(doc.indexOf('body') === -1);\n    assert.ok(doc.indexOf('<html>') === -1);\n    assert.done();\n}\n\nmodule.exports.toString = function(assert) {\n    var doc = new libxml.Document();\n    assert.ok(doc.toString({declaration: false}) === null);\n    assert.ok(doc.toString({declaration: false, type:'html'}).length === 1);\n\n    doc = libxml.parseHtml(\"<a></a>\");\n    assert.ok(doc.toString().indexOf('<?xml') === -1);\n    assert.ok(doc.toString({ type: 'xml' }).indexOf('<?xml') > -1);\n    assert.ok(doc.toString({ type: 'xhtml' }).indexOf('<?xml') > -1);\n    assert.ok(doc.toString({ type: 'xml', selfCloseEmpty:true }).indexOf('<a/>') > -1);\n    assert.done();\n}\n", "var fs = require('fs');\n\nvar libxml = require('../index');\n\nmodule.exports.parse = function(assert) {\n    var filename = __dirname + '/fixtures/parser.xml';\n    var str = fs.readFileSync(filename, 'utf8');\n\n    var doc = libxml.parseXml(str);\n    assert.equal('1.0', doc.version());\n    assert.equal('UTF-8', doc.encoding());\n    assert.equal('root', doc.root().name());\n    assert.equal('child', doc.get('child').name());\n    assert.equal('grandchild', doc.get('child').get('grandchild').name());\n    assert.equal('with love', doc.get('child/grandchild').text());\n    assert.equal('sibling', doc.get('sibling').name());\n    assert.equal(6, doc.get('sibling').line());\n    assert.equal(3, doc.get('child').attr('to').line());\n    assert.equal('with content!', doc.get('sibling').text());\n    assert.equal(str, doc.toString());\n    assert.done();\n};\n\nmodule.exports.invalid_input = function(assert) {\n    try {\n        libxml.parseXml({object: true});\n        assert.ok(false);\n    } catch(err) {\n        assert.ok(true)\n    }\n\n    assert.done();\n};\n\nmodule.exports.parse_buffer = function(assert) {\n    var filename = __dirname + '/fixtures/parser-utf16.xml';\n    var buf = fs.readFileSync(filename);\n\n    var doc = libxml.parseXml(buf);\n    assert.equal('1.0', doc.version());\n    assert.equal('UTF-16', doc.encoding());\n    assert.equal('root', doc.root().name());\n    assert.done();\n};\n\nmodule.exports.parse_synonym = function(assert) {\n    assert.strictEqual(libxml.parseXml, libxml.parseXmlString);\n    assert.done();\n}\n\nmodule.exports.recoverable_parse = function(assert) {\n    var filename = __dirname + '/fixtures/warnings/ent9.xml';\n    var str = fs.readFileSync(filename, 'utf8');\n\n    var doc = libxml.parseXml(str);\n\n    assert.equal(1, doc.errors.length);\n    var err = doc.errors.shift();\n    assert.ok(err instanceof Error);\n    assert.equal(err.domain, 3);\n    assert.equal(err.column, 13);\n    assert.equal(err.line, 1);\n    assert.equal(err.code, 201);\n    assert.equal(err.str1, 'prefix');\n\n    assert.done();\n};\n\nmodule.exports.baseurl_xml = function(assert) {\n    if (/^win/.test(process.platform)) {\n        // libxml won't resolve the path on Windows\n        assert.done();\n        return;\n    }\n\n    var str = '<!DOCTYPE example SYSTEM \"baseurl.dtd\">\\n' +\n      '<example msg=\"&happy;\"/>\\n';\n\n    // First verify it fails when we don't give baseUrl\n    var doc = libxml.Document.fromXml(str, {\n      dtdvalid: true,\n      nonet: true,\n    });\n    assert.ok(doc.errors.length > 0);\n\n    // Now it should work\n    var doc = libxml.Document.fromXml(str, {\n      dtdvalid: true,\n      nonet: true,\n      baseUrl: __dirname + '/fixtures/example.xml',\n    });\n    assert.ok(!doc.errors || doc.errors.length == 0);\n\n    assert.done();\n};\n\n\n\n\nmodule.exports.fatal_error = function(assert) {\n    var filename = __dirname + '/fixtures/errors/comment.xml';\n    var str = fs.readFileSync(filename, 'utf8');\n    var err = null;\n\n    try {\n        libxml.parseXml(str);\n    } catch(e) { err = e; }\n\n    var errorControl = {\n        domain: 1,\n        code: 4,\n        message: \"Start tag expected, '<' not found\\n\",\n        level: 3,\n        file: null,\n        line: 5,\n        str1: null,\n        str2: null,\n        str3: null,\n        int1: null,\n        column: 10\n    };\n    assert.equal(errorControl.code, err.code);\n    assert.done();\n};\n\nmodule.exports.parse_options = function(assert) {\n    function test_parser_option(input, options, expected) {\n        var output = libxml.parseXml(input, options).toString();\n        output = output.replace(/^<\\?xml version=\"1.0\" encoding=\"UTF-8\"\\?>\\n/, '');\n        output = output.replace(/\\n$/, '');\n        assert.equal(output, expected);\n    }\n\n    test_parser_option(\"<x>&</x>\", { recover: true }, \"<x/>\") // without this option, this document would raise an exception during parsing\n    test_parser_option(\"<!DOCTYPE x [ <!ENTITY foo 'bar'> ]> <x>&foo;</x>\", { noent: true }, '<!DOCTYPE x [\\n<!ENTITY foo \"bar\">\\n]>\\n<x>bar</x>') // foo => bar\n    test_parser_option(\"<x> <a>123</a> </x>\", { }, \"<x> <a>123</a> </x>\") // no indentation even though the toString() default called for formatting\n    test_parser_option(\"<x> <a>123</a> </x>\", { noblanks: true }, \"<x>\\n  <a>123</a>\\n</x>\") // ah, now we have indentation!\n    test_parser_option(\"<x><![CDATA[hi]]></x>\", {  }, \"<x><![CDATA[hi]]></x>\") // normally CDATA stays as CDATA\n    test_parser_option(\"<x><![CDATA[hi]]></x>\", { nocdata: true }, \"<x>hi</x>\") // but here CDATA is removed!\n    assert.done();\n};\n"], "filenames": ["package.json", "src/xml_document.cc", "test/html_parser.js", "test/xml_parser.js"], "buggy_code_start_loc": [15, 378, 30, 20], "buggy_code_end_loc": [42, 451, 30, 20], "fixing_code_start_loc": [15, 378, 31, 21], "fixing_code_end_loc": [42, 456, 42, 32], "type": "CWE-400", "message": "This affects all versions of package libxmljs. When invoking the libxmljs.parseXml function with a non-buffer argument the V8 code will attempt invoking the .toString method of the argument. If the argument's toString value is not a Function object V8 will crash.", "other": {"cve": {"id": "CVE-2022-21144", "sourceIdentifier": "report@snyk.io", "published": "2022-05-01T16:15:07.957", "lastModified": "2022-07-18T17:41:02.783", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "This affects all versions of package libxmljs. When invoking the libxmljs.parseXml function with a non-buffer argument the V8 code will attempt invoking the .toString method of the argument. If the argument's toString value is not a Function object V8 will crash."}, {"lang": "es", "value": "Esto afecta a todas las versiones del paquete libxmljs. Cuando es invocada la funci\u00f3n libxmljs.parseXml con un argumento que no es un buffer, el c\u00f3digo V8 intentar\u00e1 invocar el m\u00e9todo .toString del argumento. Si el valor toString del argumento no es un objeto Function, V8 ser\u00e1 bloqueado"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libxmljs_project:libxmljs:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "0.19.8", "matchCriteriaId": "D1456B17-F84B-41D9-9142-B3A5966B2E13"}]}]}], "references": [{"url": "https://github.com/libxmljs/libxmljs/commit/2501807bde9b38cfaed06d1e140487516d91379d", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/libxmljs/libxmljs/pull/594", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JS-LIBXMLJS-2348756", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/libxmljs/libxmljs/commit/2501807bde9b38cfaed06d1e140487516d91379d"}}