{"buggy_code": ["const qs = require(\"querystring\");\nconst parse = require(\"url\").parse;\nconst base64id = require(\"base64id\");\nconst transports = require(\"./transports\");\nconst EventEmitter = require(\"events\").EventEmitter;\nconst Socket = require(\"./socket\");\nconst debug = require(\"debug\")(\"engine\");\nconst cookieMod = require(\"cookie\");\n\nconst DEFAULT_WS_ENGINE = require(\"ws\").Server;\n\nclass Server extends EventEmitter {\n  /**\n   * Server constructor.\n   *\n   * @param {Object} options\n   * @api public\n   */\n  constructor(opts = {}) {\n    super();\n\n    this.clients = {};\n    this.clientsCount = 0;\n\n    this.opts = Object.assign(\n      {\n        wsEngine: DEFAULT_WS_ENGINE,\n        pingTimeout: 20000,\n        pingInterval: 25000,\n        upgradeTimeout: 10000,\n        maxHttpBufferSize: 1e6,\n        transports: Object.keys(transports),\n        allowUpgrades: true,\n        httpCompression: {\n          threshold: 1024\n        },\n        cors: false,\n        allowEIO3: false\n      },\n      opts\n    );\n\n    if (opts.cookie) {\n      this.opts.cookie = Object.assign(\n        {\n          name: \"io\",\n          path: \"/\",\n          httpOnly: opts.cookie.path !== false,\n          sameSite: \"lax\"\n        },\n        opts.cookie\n      );\n    }\n\n    if (this.opts.cors) {\n      this.corsMiddleware = require(\"cors\")(this.opts.cors);\n    }\n\n    if (opts.perMessageDeflate) {\n      this.opts.perMessageDeflate = Object.assign(\n        {\n          threshold: 1024\n        },\n        opts.perMessageDeflate\n      );\n    }\n\n    this.init();\n  }\n\n  /**\n   * Initialize websocket server\n   *\n   * @api private\n   */\n  init() {\n    if (!~this.opts.transports.indexOf(\"websocket\")) return;\n\n    if (this.ws) this.ws.close();\n\n    this.ws = new this.opts.wsEngine({\n      noServer: true,\n      clientTracking: false,\n      perMessageDeflate: this.opts.perMessageDeflate,\n      maxPayload: this.opts.maxHttpBufferSize\n    });\n\n    if (typeof this.ws.on === \"function\") {\n      this.ws.on(\"headers\", (headersArray, req) => {\n        // note: 'ws' uses an array of headers, while Engine.IO uses an object (response.writeHead() accepts both formats)\n        // we could also try to parse the array and then sync the values, but that will be error-prone\n        const additionalHeaders = {};\n\n        const isInitialRequest = !req._query.sid;\n        if (isInitialRequest) {\n          this.emit(\"initial_headers\", additionalHeaders, req);\n        }\n\n        this.emit(\"headers\", additionalHeaders, req);\n\n        Object.keys(additionalHeaders).forEach(key => {\n          headersArray.push(`${key}: ${additionalHeaders[key]}`);\n        });\n      });\n    }\n  }\n\n  /**\n   * Returns a list of available transports for upgrade given a certain transport.\n   *\n   * @return {Array}\n   * @api public\n   */\n  upgrades(transport) {\n    if (!this.opts.allowUpgrades) return [];\n    return transports[transport].upgradesTo || [];\n  }\n\n  /**\n   * Verifies a request.\n   *\n   * @param {http.IncomingMessage}\n   * @return {Boolean} whether the request is valid\n   * @api private\n   */\n  verify(req, upgrade, fn) {\n    // transport check\n    const transport = req._query.transport;\n    if (!~this.opts.transports.indexOf(transport)) {\n      debug('unknown transport \"%s\"', transport);\n      return fn(Server.errors.UNKNOWN_TRANSPORT, { transport });\n    }\n\n    // 'Origin' header check\n    const isOriginInvalid = checkInvalidHeaderChar(req.headers.origin);\n    if (isOriginInvalid) {\n      const origin = req.headers.origin;\n      req.headers.origin = null;\n      debug(\"origin header invalid\");\n      return fn(Server.errors.BAD_REQUEST, {\n        name: \"INVALID_ORIGIN\",\n        origin\n      });\n    }\n\n    // sid check\n    const sid = req._query.sid;\n    if (sid) {\n      if (!this.clients.hasOwnProperty(sid)) {\n        debug('unknown sid \"%s\"', sid);\n        return fn(Server.errors.UNKNOWN_SID, {\n          sid\n        });\n      }\n      const previousTransport = this.clients[sid].transport.name;\n      if (!upgrade && previousTransport !== transport) {\n        debug(\"bad request: unexpected transport without upgrade\");\n        return fn(Server.errors.BAD_REQUEST, {\n          name: \"TRANSPORT_MISMATCH\",\n          transport,\n          previousTransport\n        });\n      }\n    } else {\n      // handshake is GET only\n      if (\"GET\" !== req.method) {\n        return fn(Server.errors.BAD_HANDSHAKE_METHOD, {\n          method: req.method\n        });\n      }\n\n      if (!this.opts.allowRequest) return fn();\n\n      return this.opts.allowRequest(req, (message, success) => {\n        if (!success) {\n          return fn(Server.errors.FORBIDDEN, {\n            message\n          });\n        }\n        fn();\n      });\n    }\n\n    fn();\n  }\n\n  /**\n   * Prepares a request by processing the query string.\n   *\n   * @api private\n   */\n  prepare(req) {\n    // try to leverage pre-existing `req._query` (e.g: from connect)\n    if (!req._query) {\n      req._query = ~req.url.indexOf(\"?\") ? qs.parse(parse(req.url).query) : {};\n    }\n  }\n\n  /**\n   * Closes all clients.\n   *\n   * @api public\n   */\n  close() {\n    debug(\"closing all open clients\");\n    for (let i in this.clients) {\n      if (this.clients.hasOwnProperty(i)) {\n        this.clients[i].close(true);\n      }\n    }\n    if (this.ws) {\n      debug(\"closing webSocketServer\");\n      this.ws.close();\n      // don't delete this.ws because it can be used again if the http server starts listening again\n    }\n    return this;\n  }\n\n  /**\n   * Handles an Engine.IO HTTP request.\n   *\n   * @param {http.IncomingMessage} request\n   * @param {http.ServerResponse|http.OutgoingMessage} response\n   * @api public\n   */\n  handleRequest(req, res) {\n    debug('handling \"%s\" http request \"%s\"', req.method, req.url);\n    this.prepare(req);\n    req.res = res;\n\n    const callback = (errorCode, errorContext) => {\n      if (errorCode !== undefined) {\n        this.emit(\"connection_error\", {\n          req,\n          code: errorCode,\n          message: Server.errorMessages[errorCode],\n          context: errorContext\n        });\n        abortRequest(res, errorCode, errorContext);\n        return;\n      }\n\n      if (req._query.sid) {\n        debug(\"setting new request for existing client\");\n        this.clients[req._query.sid].transport.onRequest(req);\n      } else {\n        const closeConnection = (errorCode, errorContext) =>\n          abortRequest(res, errorCode, errorContext);\n        this.handshake(req._query.transport, req, closeConnection);\n      }\n    };\n\n    if (this.corsMiddleware) {\n      this.corsMiddleware.call(null, req, res, () => {\n        this.verify(req, false, callback);\n      });\n    } else {\n      this.verify(req, false, callback);\n    }\n  }\n\n  /**\n   * generate a socket id.\n   * Overwrite this method to generate your custom socket id\n   *\n   * @param {Object} request object\n   * @api public\n   */\n  generateId(req) {\n    return base64id.generateId();\n  }\n\n  /**\n   * Handshakes a new client.\n   *\n   * @param {String} transport name\n   * @param {Object} request object\n   * @param {Function} closeConnection\n   *\n   * @api private\n   */\n  async handshake(transportName, req, closeConnection) {\n    const protocol = req._query.EIO === \"4\" ? 4 : 3; // 3rd revision by default\n    if (protocol === 3 && !this.opts.allowEIO3) {\n      debug(\"unsupported protocol version\");\n      this.emit(\"connection_error\", {\n        req,\n        code: Server.errors.UNSUPPORTED_PROTOCOL_VERSION,\n        message:\n          Server.errorMessages[Server.errors.UNSUPPORTED_PROTOCOL_VERSION],\n        context: {\n          protocol\n        }\n      });\n      closeConnection(Server.errors.UNSUPPORTED_PROTOCOL_VERSION);\n      return;\n    }\n\n    let id;\n    try {\n      id = await this.generateId(req);\n    } catch (e) {\n      debug(\"error while generating an id\");\n      this.emit(\"connection_error\", {\n        req,\n        code: Server.errors.BAD_REQUEST,\n        message: Server.errorMessages[Server.errors.BAD_REQUEST],\n        context: {\n          name: \"ID_GENERATION_ERROR\",\n          error: e\n        }\n      });\n      closeConnection(Server.errors.BAD_REQUEST);\n      return;\n    }\n\n    debug('handshaking client \"%s\"', id);\n\n    try {\n      var transport = new transports[transportName](req);\n      if (\"polling\" === transportName) {\n        transport.maxHttpBufferSize = this.opts.maxHttpBufferSize;\n        transport.httpCompression = this.opts.httpCompression;\n      } else if (\"websocket\" === transportName) {\n        transport.perMessageDeflate = this.opts.perMessageDeflate;\n      }\n\n      if (req._query && req._query.b64) {\n        transport.supportsBinary = false;\n      } else {\n        transport.supportsBinary = true;\n      }\n    } catch (e) {\n      debug('error handshaking to transport \"%s\"', transportName);\n      this.emit(\"connection_error\", {\n        req,\n        code: Server.errors.BAD_REQUEST,\n        message: Server.errorMessages[Server.errors.BAD_REQUEST],\n        context: {\n          name: \"TRANSPORT_HANDSHAKE_ERROR\",\n          error: e\n        }\n      });\n      closeConnection(Server.errors.BAD_REQUEST);\n      return;\n    }\n    const socket = new Socket(id, this, transport, req, protocol);\n\n    transport.on(\"headers\", (headers, req) => {\n      const isInitialRequest = !req._query.sid;\n\n      if (isInitialRequest) {\n        if (this.opts.cookie) {\n          headers[\"Set-Cookie\"] = [\n            cookieMod.serialize(this.opts.cookie.name, id, this.opts.cookie)\n          ];\n        }\n        this.emit(\"initial_headers\", headers, req);\n      }\n      this.emit(\"headers\", headers, req);\n    });\n\n    transport.onRequest(req);\n\n    this.clients[id] = socket;\n    this.clientsCount++;\n\n    socket.once(\"close\", () => {\n      delete this.clients[id];\n      this.clientsCount--;\n    });\n\n    this.emit(\"connection\", socket);\n  }\n\n  /**\n   * Handles an Engine.IO HTTP Upgrade.\n   *\n   * @api public\n   */\n  handleUpgrade(req, socket, upgradeHead) {\n    this.prepare(req);\n\n    this.verify(req, true, (errorCode, errorContext) => {\n      if (errorCode) {\n        this.emit(\"connection_error\", {\n          req,\n          code: errorCode,\n          message: Server.errorMessages[errorCode],\n          context: errorContext\n        });\n        abortUpgrade(socket, errorCode, errorContext);\n        return;\n      }\n\n      const head = Buffer.from(upgradeHead); // eslint-disable-line node/no-deprecated-api\n      upgradeHead = null;\n\n      // delegate to ws\n      this.ws.handleUpgrade(req, socket, head, websocket => {\n        this.onWebSocket(req, socket, websocket);\n      });\n    });\n  }\n\n  /**\n   * Called upon a ws.io connection.\n   *\n   * @param {ws.Socket} websocket\n   * @api private\n   */\n  onWebSocket(req, socket, websocket) {\n    websocket.on(\"error\", onUpgradeError);\n\n    if (\n      transports[req._query.transport] !== undefined &&\n      !transports[req._query.transport].prototype.handlesUpgrades\n    ) {\n      debug(\"transport doesnt handle upgraded requests\");\n      websocket.close();\n      return;\n    }\n\n    // get client id\n    const id = req._query.sid;\n\n    // keep a reference to the ws.Socket\n    req.websocket = websocket;\n\n    if (id) {\n      const client = this.clients[id];\n      if (!client) {\n        debug(\"upgrade attempt for closed client\");\n        websocket.close();\n      } else if (client.upgrading) {\n        debug(\"transport has already been trying to upgrade\");\n        websocket.close();\n      } else if (client.upgraded) {\n        debug(\"transport had already been upgraded\");\n        websocket.close();\n      } else {\n        debug(\"upgrading existing transport\");\n\n        // transport error handling takes over\n        websocket.removeListener(\"error\", onUpgradeError);\n\n        const transport = new transports[req._query.transport](req);\n        if (req._query && req._query.b64) {\n          transport.supportsBinary = false;\n        } else {\n          transport.supportsBinary = true;\n        }\n        transport.perMessageDeflate = this.perMessageDeflate;\n        client.maybeUpgrade(transport);\n      }\n    } else {\n      // transport error handling takes over\n      websocket.removeListener(\"error\", onUpgradeError);\n\n      const closeConnection = (errorCode, errorContext) =>\n        abortUpgrade(socket, errorCode, errorContext);\n      this.handshake(req._query.transport, req, closeConnection);\n    }\n\n    function onUpgradeError() {\n      debug(\"websocket error before upgrade\");\n      // websocket.close() not needed\n    }\n  }\n\n  /**\n   * Captures upgrade requests for a http.Server.\n   *\n   * @param {http.Server} server\n   * @param {Object} options\n   * @api public\n   */\n  attach(server, options = {}) {\n    let path = (options.path || \"/engine.io\").replace(/\\/$/, \"\");\n\n    const destroyUpgradeTimeout = options.destroyUpgradeTimeout || 1000;\n\n    // normalize path\n    path += \"/\";\n\n    function check(req) {\n      return path === req.url.substr(0, path.length);\n    }\n\n    // cache and clean up listeners\n    const listeners = server.listeners(\"request\").slice(0);\n    server.removeAllListeners(\"request\");\n    server.on(\"close\", this.close.bind(this));\n    server.on(\"listening\", this.init.bind(this));\n\n    // add request handler\n    server.on(\"request\", (req, res) => {\n      if (check(req)) {\n        debug('intercepting request for path \"%s\"', path);\n        this.handleRequest(req, res);\n      } else {\n        let i = 0;\n        const l = listeners.length;\n        for (; i < l; i++) {\n          listeners[i].call(server, req, res);\n        }\n      }\n    });\n\n    if (~this.opts.transports.indexOf(\"websocket\")) {\n      server.on(\"upgrade\", (req, socket, head) => {\n        if (check(req)) {\n          this.handleUpgrade(req, socket, head);\n        } else if (false !== options.destroyUpgrade) {\n          // default node behavior is to disconnect when no handlers\n          // but by adding a handler, we prevent that\n          // and if no eio thing handles the upgrade\n          // then the socket needs to die!\n          setTimeout(function() {\n            if (socket.writable && socket.bytesWritten <= 0) {\n              return socket.end();\n            }\n          }, destroyUpgradeTimeout);\n        }\n      });\n    }\n  }\n}\n\n/**\n * Protocol errors mappings.\n */\n\nServer.errors = {\n  UNKNOWN_TRANSPORT: 0,\n  UNKNOWN_SID: 1,\n  BAD_HANDSHAKE_METHOD: 2,\n  BAD_REQUEST: 3,\n  FORBIDDEN: 4,\n  UNSUPPORTED_PROTOCOL_VERSION: 5\n};\n\nServer.errorMessages = {\n  0: \"Transport unknown\",\n  1: \"Session ID unknown\",\n  2: \"Bad handshake method\",\n  3: \"Bad request\",\n  4: \"Forbidden\",\n  5: \"Unsupported protocol version\"\n};\n\n/**\n * Close the HTTP long-polling request\n *\n * @param res - the response object\n * @param errorCode - the error code\n * @param errorContext - additional error context\n *\n * @api private\n */\n\nfunction abortRequest(res, errorCode, errorContext) {\n  const statusCode = errorCode === Server.errors.FORBIDDEN ? 403 : 400;\n  const message =\n    errorContext && errorContext.message\n      ? errorContext.message\n      : Server.errorMessages[errorCode];\n\n  res.writeHead(statusCode, { \"Content-Type\": \"application/json\" });\n  res.end(\n    JSON.stringify({\n      code: errorCode,\n      message\n    })\n  );\n}\n\n/**\n * Close the WebSocket connection\n *\n * @param {net.Socket} socket\n * @param {string} errorCode - the error code\n * @param {object} errorContext - additional error context\n *\n * @api private\n */\n\nfunction abortUpgrade(socket, errorCode, errorContext = {}) {\n  socket.on(\"error\", () => {\n    debug(\"ignoring error from closed connection\");\n  });\n  if (socket.writable) {\n    const message = errorContext.message || Server.errorMessages[errorCode];\n    const length = Buffer.byteLength(message);\n    socket.write(\n      \"HTTP/1.1 400 Bad Request\\r\\n\" +\n        \"Connection: close\\r\\n\" +\n        \"Content-type: text/html\\r\\n\" +\n        \"Content-Length: \" +\n        length +\n        \"\\r\\n\" +\n        \"\\r\\n\" +\n        message\n    );\n  }\n  socket.destroy();\n}\n\nmodule.exports = Server;\n\n/* eslint-disable */\n\n/**\n * From https://github.com/nodejs/node/blob/v8.4.0/lib/_http_common.js#L303-L354\n *\n * True if val contains an invalid field-vchar\n *  field-value    = *( field-content / obs-fold )\n *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n *  field-vchar    = VCHAR / obs-text\n *\n * checkInvalidHeaderChar() is currently designed to be inlinable by v8,\n * so take care when making changes to the implementation so that the source\n * code size does not exceed v8's default max_inlined_source_size setting.\n **/\n// prettier-ignore\nconst validHdrChars = [\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, // 0 - 15\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 32 - 47\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 48 - 63\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 80 - 95\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, // 112 - 127\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 128 ...\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1  // ... 255\n]\n\nfunction checkInvalidHeaderChar(val) {\n  val += \"\";\n  if (val.length < 1) return false;\n  if (!validHdrChars[val.charCodeAt(0)]) {\n    debug('invalid header, index 0, char \"%s\"', val.charCodeAt(0));\n    return true;\n  }\n  if (val.length < 2) return false;\n  if (!validHdrChars[val.charCodeAt(1)]) {\n    debug('invalid header, index 1, char \"%s\"', val.charCodeAt(1));\n    return true;\n  }\n  if (val.length < 3) return false;\n  if (!validHdrChars[val.charCodeAt(2)]) {\n    debug('invalid header, index 2, char \"%s\"', val.charCodeAt(2));\n    return true;\n  }\n  if (val.length < 4) return false;\n  if (!validHdrChars[val.charCodeAt(3)]) {\n    debug('invalid header, index 3, char \"%s\"', val.charCodeAt(3));\n    return true;\n  }\n  for (let i = 4; i < val.length; ++i) {\n    if (!validHdrChars[val.charCodeAt(i)]) {\n      debug('invalid header, index \"%i\", char \"%s\"', i, val.charCodeAt(i));\n      return true;\n    }\n  }\n  return false;\n}\n", "/* eslint-disable standard/no-callback-literal */\n\nconst http = require(\"http\");\nconst https = require(\"https\");\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst exec = require(\"child_process\").exec;\nconst zlib = require(\"zlib\");\nconst eio = require(\"..\");\nconst { eioc, listen, createPartialDone } = require(\"./common\");\nconst expect = require(\"expect.js\");\nconst request = require(\"superagent\");\nconst cookieMod = require(\"cookie\");\n\n/**\n * Tests.\n */\n\ndescribe(\"server\", () => {\n  let engine, client;\n\n  afterEach(() => {\n    if (engine) {\n      engine.httpServer.close();\n    }\n    if (client) {\n      client.close();\n    }\n  });\n\n  describe(\"verification\", () => {\n    it(\"should disallow non-existent transports\", done => {\n      const partialDone = createPartialDone(done, 2);\n\n      engine = listen(port => {\n        engine.on(\"connection_error\", err => {\n          expect(err.req).to.be.an(http.IncomingMessage);\n          expect(err.code).to.be(0);\n          expect(err.message).to.be(\"Transport unknown\");\n          expect(err.context.transport).to.be(\"tobi\");\n          partialDone();\n        });\n\n        request\n          .get(\"http://localhost:%d/engine.io/default/\".s(port))\n          .query({ transport: \"tobi\" }) // no tobi transport - outrageous\n          .end((err, res) => {\n            expect(err).to.be.an(Error);\n            expect(res.status).to.be(400);\n            expect(res.body.code).to.be(0);\n            expect(res.body.message).to.be(\"Transport unknown\");\n            partialDone();\n          });\n      });\n    });\n\n    it(\"should disallow `constructor` as transports\", done => {\n      const partialDone = createPartialDone(done, 2);\n\n      // make sure we check for actual properties - not those present on every {}\n      engine = listen(port => {\n        engine.on(\"connection_error\", err => {\n          expect(err.req).to.be.an(http.IncomingMessage);\n          expect(err.code).to.be(0);\n          expect(err.message).to.be(\"Transport unknown\");\n          expect(err.context.transport).to.be(\"constructor\");\n          partialDone();\n        });\n\n        request\n          .get(\"http://localhost:%d/engine.io/default/\".s(port))\n          .set(\"Origin\", \"http://engine.io\")\n          .query({ transport: \"constructor\" })\n          .end((err, res) => {\n            expect(err).to.be.an(Error);\n            expect(res.status).to.be(400);\n            expect(res.body.code).to.be(0);\n            expect(res.body.message).to.be(\"Transport unknown\");\n            partialDone();\n          });\n      });\n    });\n\n    it(\"should disallow non-existent sids\", done => {\n      const partialDone = createPartialDone(done, 2);\n\n      engine = listen(port => {\n        engine.on(\"connection_error\", err => {\n          expect(err.req).to.be.an(http.IncomingMessage);\n          expect(err.code).to.be(1);\n          expect(err.message).to.be(\"Session ID unknown\");\n          expect(err.context.sid).to.be(\"test\");\n          partialDone();\n        });\n\n        request\n          .get(\"http://localhost:%d/engine.io/default/\".s(port))\n          .set(\"Origin\", \"http://engine.io\")\n          .query({ transport: \"polling\", sid: \"test\" })\n          .end((err, res) => {\n            expect(err).to.be.an(Error);\n            expect(res.status).to.be(400);\n            expect(res.body.code).to.be(1);\n            expect(res.body.message).to.be(\"Session ID unknown\");\n            partialDone();\n          });\n      });\n    });\n\n    it(\"should disallow requests that are rejected by `allowRequest`\", done => {\n      const partialDone = createPartialDone(done, 2);\n\n      engine = listen(\n        {\n          allowRequest: (req, fn) => {\n            fn(\"Thou shall not pass\", false);\n          }\n        },\n        port => {\n          engine.on(\"connection_error\", err => {\n            expect(err.req).to.be.an(http.IncomingMessage);\n            expect(err.code).to.be(4);\n            expect(err.message).to.be(\"Forbidden\");\n            expect(err.context.message).to.be(\"Thou shall not pass\");\n            partialDone();\n          });\n\n          request\n            .get(\"http://localhost:%d/engine.io/default/\".s(port))\n            .set(\"Origin\", \"http://engine.io\")\n            .query({ transport: \"polling\" })\n            .end((err, res) => {\n              expect(err).to.be.an(Error);\n              expect(res.status).to.be(403);\n              expect(res.body.code).to.be(4);\n              expect(res.body.message).to.be(\"Thou shall not pass\");\n              partialDone();\n            });\n        }\n      );\n    });\n\n    it(\"should disallow connection that are rejected by `allowRequest`\", done => {\n      listen(\n        {\n          allowRequest: (req, fn) => {\n            fn(null, false);\n          }\n        },\n        port => {\n          const client = eioc(\"ws://localhost:%d\".s(port), {\n            transports: [\"websocket\"]\n          });\n          client.on(\"error\", () => {\n            done();\n          });\n        }\n      );\n    });\n  });\n\n  describe(\"handshake\", () => {\n    it(\"should send the io cookie\", done => {\n      listen({ cookie: true }, port => {\n        request\n          .get(\"http://localhost:%d/engine.io/default/\".s(port))\n          .query({ transport: \"polling\", b64: 1 })\n          .end((err, res) => {\n            expect(err).to.be(null);\n            // hack-obtain sid\n            const sid = res.text.match(/\"sid\":\"([^\"]+)\"/)[1];\n            expect(res.headers[\"set-cookie\"][0]).to.be(\n              `io=${sid}; Path=/; HttpOnly; SameSite=Lax`\n            );\n            done();\n          });\n      });\n    });\n\n    it(\"should send the io cookie custom name\", done => {\n      listen({ cookie: { name: \"woot\" } }, port => {\n        request\n          .get(\"http://localhost:%d/engine.io/default/\".s(port))\n          .query({ transport: \"polling\", b64: 1 })\n          .end((err, res) => {\n            expect(err).to.be(null);\n            const sid = res.text.match(/\"sid\":\"([^\"]+)\"/)[1];\n            expect(res.headers[\"set-cookie\"][0]).to.be(\n              `woot=${sid}; Path=/; HttpOnly; SameSite=Lax`\n            );\n            done();\n          });\n      });\n    });\n\n    it(\"should send the cookie with custom path\", done => {\n      listen({ cookie: { path: \"/custom\" } }, port => {\n        request\n          .get(\"http://localhost:%d/engine.io/default/\".s(port))\n          .query({ transport: \"polling\", b64: 1 })\n          .end((err, res) => {\n            expect(err).to.be(null);\n            const sid = res.text.match(/\"sid\":\"([^\"]+)\"/)[1];\n            expect(res.headers[\"set-cookie\"][0]).to.be(\n              `io=${sid}; Path=/custom; HttpOnly; SameSite=Lax`\n            );\n            done();\n          });\n      });\n    });\n\n    it(\"should send the cookie with path=false\", done => {\n      listen({ cookie: { path: false } }, port => {\n        request\n          .get(\"http://localhost:%d/engine.io/default/\".s(port))\n          .query({ transport: \"polling\", b64: 1 })\n          .end((err, res) => {\n            expect(err).to.be(null);\n            const sid = res.text.match(/\"sid\":\"([^\"]+)\"/)[1];\n            expect(res.headers[\"set-cookie\"][0]).to.be(\n              `io=${sid}; SameSite=Lax`\n            );\n            done();\n          });\n      });\n    });\n\n    it(\"should send the io cookie with httpOnly=true\", done => {\n      listen({ cookie: { httpOnly: true } }, port => {\n        request\n          .get(\"http://localhost:%d/engine.io/default/\".s(port))\n          .query({ transport: \"polling\", b64: 1 })\n          .end((err, res) => {\n            expect(err).to.be(null);\n            const sid = res.text.match(/\"sid\":\"([^\"]+)\"/)[1];\n            expect(res.headers[\"set-cookie\"][0]).to.be(\n              `io=${sid}; Path=/; HttpOnly; SameSite=Lax`\n            );\n            done();\n          });\n      });\n    });\n\n    it(\"should send the io cookie with sameSite=strict\", done => {\n      listen({ cookie: { sameSite: \"strict\" } }, port => {\n        request\n          .get(\"http://localhost:%d/engine.io/default/\".s(port))\n          .query({ transport: \"polling\", b64: 1 })\n          .end((err, res) => {\n            expect(err).to.be(null);\n            const sid = res.text.match(/\"sid\":\"([^\"]+)\"/)[1];\n            expect(res.headers[\"set-cookie\"][0]).to.be(\n              `io=${sid}; Path=/; HttpOnly; SameSite=Strict`\n            );\n            done();\n          });\n      });\n    });\n\n    it(\"should send the io cookie with httpOnly=false\", done => {\n      listen({ cookie: { httpOnly: false } }, port => {\n        request\n          .get(\"http://localhost:%d/engine.io/default/\".s(port))\n          .query({ transport: \"polling\", b64: 1 })\n          .end((err, res) => {\n            expect(err).to.be(null);\n            const sid = res.text.match(/\"sid\":\"([^\"]+)\"/)[1];\n            expect(res.headers[\"set-cookie\"][0]).to.be(\n              `io=${sid}; Path=/; SameSite=Lax`\n            );\n            done();\n          });\n      });\n    });\n\n    it(\"should send the io cookie with httpOnly not boolean\", done => {\n      listen({ cookie: { httpOnly: \"no\" } }, port => {\n        request\n          .get(\"http://localhost:%d/engine.io/default/\".s(port))\n          .query({ transport: \"polling\", b64: 1 })\n          .end((err, res) => {\n            expect(err).to.be(null);\n            const sid = res.text.match(/\"sid\":\"([^\"]+)\"/)[1];\n            expect(res.headers[\"set-cookie\"][0]).to.be(\n              `io=${sid}; Path=/; HttpOnly; SameSite=Lax`\n            );\n            done();\n          });\n      });\n    });\n\n    it(\"should not send the io cookie\", done => {\n      listen({ cookie: false }, port => {\n        request\n          .get(\"http://localhost:%d/engine.io/default/\".s(port))\n          .query({ transport: \"polling\" })\n          .end((err, res) => {\n            expect(err).to.be(null);\n            expect(res.headers[\"set-cookie\"]).to.be(undefined);\n            done();\n          });\n      });\n    });\n\n    it(\"should register a new client\", done => {\n      const engine = listen({ allowUpgrades: false }, port => {\n        expect(Object.keys(engine.clients)).to.have.length(0);\n        expect(engine.clientsCount).to.be(0);\n\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n        socket.on(\"open\", () => {\n          expect(Object.keys(engine.clients)).to.have.length(1);\n          expect(engine.clientsCount).to.be(1);\n          done();\n        });\n      });\n    });\n\n    it(\"should register a new client with custom id\", done => {\n      const engine = listen({ allowUpgrades: false }, port => {\n        expect(Object.keys(engine.clients)).to.have.length(0);\n        expect(engine.clientsCount).to.be(0);\n\n        const customId = \"CustomId\" + Date.now();\n\n        engine.generateId = req => customId;\n\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n        socket.once(\"open\", () => {\n          expect(Object.keys(engine.clients)).to.have.length(1);\n          expect(engine.clientsCount).to.be(1);\n          expect(socket.id).to.be(customId);\n          expect(engine.clients[customId].id).to.be(customId);\n          done();\n        });\n      });\n    });\n\n    it(\"should register a new client with custom id (with a Promise)\", done => {\n      const engine = listen({ allowUpgrades: false }, port => {\n        const customId = \"CustomId\" + Date.now();\n\n        engine.generateId = () => Promise.resolve(customId);\n\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n        socket.once(\"open\", () => {\n          expect(socket.id).to.be(customId);\n          expect(engine.clients[customId].id).to.be(customId);\n          done();\n        });\n      });\n    });\n\n    it(\"should disallow connection that are rejected by `generateId`\", done => {\n      const partialDone = createPartialDone(done, 2);\n\n      engine = listen({ allowUpgrades: false }, port => {\n        engine.generateId = () => {\n          return Promise.reject(new Error(\"nope\"));\n        };\n\n        engine.on(\"connection_error\", err => {\n          expect(err.req).to.be.an(http.IncomingMessage);\n          expect(err.code).to.be(3);\n          expect(err.message).to.be(\"Bad request\");\n          expect(err.context.name).to.be(\"ID_GENERATION_ERROR\");\n          partialDone();\n        });\n\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n        socket.on(\"error\", () => {\n          partialDone();\n        });\n      });\n    });\n\n    it(\"should disallow connection that are rejected by `generateId` (websocket only)\", function(done) {\n      if (process.env.EIO_WS_ENGINE === \"eiows\") {\n        this.skip();\n      }\n      const partialDone = createPartialDone(done, 2);\n\n      engine = listen({ allowUpgrades: false }, port => {\n        engine.generateId = () => {\n          return Promise.reject(new Error(\"nope\"));\n        };\n\n        engine.on(\"connection_error\", err => {\n          expect(err.req).to.be.an(http.IncomingMessage);\n          expect(err.code).to.be(3);\n          expect(err.message).to.be(\"Bad request\");\n          expect(err.context.name).to.be(\"ID_GENERATION_ERROR\");\n          partialDone();\n        });\n\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n          transports: [\"websocket\"]\n        });\n        socket.on(\"error\", () => {\n          partialDone();\n        });\n      });\n    });\n\n    it(\"should exchange handshake data\", done => {\n      listen({ allowUpgrades: false }, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n        socket.on(\"handshake\", obj => {\n          expect(obj.sid).to.be.a(\"string\");\n          expect(obj.pingTimeout).to.be.a(\"number\");\n          expect(obj.upgrades).to.be.an(\"array\");\n          done();\n        });\n      });\n    });\n\n    it(\"should allow custom ping timeouts\", done => {\n      listen({ allowUpgrades: false, pingTimeout: 123 }, port => {\n        const socket = new eioc.Socket(\"http://localhost:%d\".s(port));\n        socket.on(\"handshake\", obj => {\n          expect(obj.pingTimeout).to.be(123);\n          done();\n        });\n      });\n    });\n\n    it(\"should trigger a connection event with a Socket\", done => {\n      const engine = listen({ allowUpgrades: false }, port => {\n        eioc(\"ws://localhost:%d\".s(port));\n        engine.on(\"connection\", socket => {\n          expect(socket).to.be.an(eio.Socket);\n          done();\n        });\n      });\n    });\n\n    it(\"should open with polling by default\", done => {\n      const engine = listen({ allowUpgrades: false }, port => {\n        eioc(\"ws://localhost:%d\".s(port));\n        engine.on(\"connection\", socket => {\n          expect(socket.transport.name).to.be(\"polling\");\n          done();\n        });\n      });\n    });\n\n    it(\"should be able to open with ws directly\", done => {\n      const engine = listen({ transports: [\"websocket\"] }, port => {\n        eioc(\"ws://localhost:%d\".s(port), { transports: [\"websocket\"] });\n        engine.on(\"connection\", socket => {\n          expect(socket.transport.name).to.be(\"websocket\");\n          done();\n        });\n      });\n    });\n\n    it(\"should not suggest any upgrades for websocket\", done => {\n      listen({ transports: [\"websocket\"] }, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n          transports: [\"websocket\"]\n        });\n        socket.on(\"handshake\", obj => {\n          expect(obj.upgrades).to.have.length(0);\n          done();\n        });\n      });\n    });\n\n    it(\"should not suggest upgrades when none are availble\", done => {\n      listen({ transports: [\"polling\"] }, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {});\n        socket.on(\"handshake\", obj => {\n          expect(obj.upgrades).to.have.length(0);\n          done();\n        });\n      });\n    });\n\n    it(\"should only suggest available upgrades\", done => {\n      listen({ transports: [\"polling\"] }, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {});\n        socket.on(\"handshake\", obj => {\n          expect(obj.upgrades).to.have.length(0);\n          done();\n        });\n      });\n    });\n\n    it(\"should suggest all upgrades when no transports are disabled\", done => {\n      listen({}, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {});\n        socket.on(\"handshake\", obj => {\n          expect(obj.upgrades).to.have.length(1);\n          expect(obj.upgrades).to.have.contain(\"websocket\");\n          done();\n        });\n      });\n    });\n\n    it(\"default to polling when proxy doesn't support websocket\", done => {\n      const partialDone = createPartialDone(done, 2);\n\n      engine = listen({ allowUpgrades: false }, port => {\n        engine.on(\"connection\", socket => {\n          socket.on(\"message\", msg => {\n            if (\"echo\" === msg) socket.send(msg);\n          });\n        });\n\n        engine.on(\"connection_error\", err => {\n          expect(err.req).to.be.an(http.IncomingMessage);\n          expect(err.code).to.be(3);\n          expect(err.message).to.be(\"Bad request\");\n          expect(err.context.name).to.be(\"TRANSPORT_MISMATCH\");\n          expect(err.context.transport).to.be(\"websocket\");\n          expect(err.context.previousTransport).to.be(\"polling\");\n          partialDone();\n        });\n\n        var socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n        socket.on(\"open\", () => {\n          request\n            .get(\"http://localhost:%d/engine.io/\".s(port))\n            .set({ connection: \"close\" })\n            .query({ transport: \"websocket\", sid: socket.id })\n            .end((err, res) => {\n              expect(err).to.be.an(Error);\n              expect(res.status).to.be(400);\n              expect(res.body.code).to.be(3);\n              socket.send(\"echo\");\n              socket.on(\"message\", msg => {\n                expect(msg).to.be(\"echo\");\n                partialDone();\n              });\n            });\n        });\n      });\n    });\n\n    it(\"should allow arbitrary data through query string\", done => {\n      const engine = listen({ allowUpgrades: false }, port => {\n        eioc(\"ws://localhost:%d\".s(port), { query: { a: \"b\" } });\n        engine.on(\"connection\", conn => {\n          expect(conn.request._query).to.have.keys(\"transport\", \"a\");\n          expect(conn.request._query.a).to.be(\"b\");\n          done();\n        });\n      });\n    });\n\n    it(\"should allow data through query string in uri\", done => {\n      const engine = listen({ allowUpgrades: false }, port => {\n        eioc(\"ws://localhost:%d?a=b&c=d\".s(port));\n        engine.on(\"connection\", conn => {\n          expect(conn.request._query.EIO).to.be.a(\"string\");\n          expect(conn.request._query.a).to.be(\"b\");\n          expect(conn.request._query.c).to.be(\"d\");\n          done();\n        });\n      });\n    });\n\n    it(\"should disallow bad requests (handshake error)\", done => {\n      const partialDone = createPartialDone(done, 2);\n\n      engine = listen(\n        {\n          cors: { credentials: true, origin: \"http://engine.io\" }\n        },\n        port => {\n          engine.on(\"connection_error\", err => {\n            expect(err.req).to.be.an(http.IncomingMessage);\n            expect(err.code).to.be(3);\n            expect(err.message).to.be(\"Bad request\");\n            expect(err.context.name).to.be(\"TRANSPORT_HANDSHAKE_ERROR\");\n            expect(err.context.error).to.be.an(Error);\n            expect(err.context.error.name).to.be(\"TypeError\");\n            partialDone();\n          });\n\n          request\n            .get(\"http://localhost:%d/engine.io/default/\".s(port))\n            .set(\"Origin\", \"http://engine.io\")\n            .query({ transport: \"websocket\" })\n            .end((err, res) => {\n              expect(err).to.be.an(Error);\n              expect(res.status).to.be(400);\n              expect(res.body.code).to.be(3);\n              expect(res.body.message).to.be(\"Bad request\");\n              expect(res.header[\"access-control-allow-credentials\"]).to.be(\n                \"true\"\n              );\n              expect(res.header[\"access-control-allow-origin\"]).to.be(\n                \"http://engine.io\"\n              );\n              partialDone();\n            });\n        }\n      );\n    });\n\n    it(\"should disallow invalid origin header\", done => {\n      const partialDone = createPartialDone(done, 2);\n\n      engine = listen(port => {\n        // we can't send an invalid header through request.get\n        // so add an invalid char here\n        engine.prepare = function(req) {\n          eio.Server.prototype.prepare.call(engine, req);\n          req.headers.origin += \"\\n\";\n        };\n\n        engine.on(\"connection_error\", err => {\n          expect(err.req).to.be.an(http.IncomingMessage);\n          expect(err.code).to.be(3);\n          expect(err.message).to.be(\"Bad request\");\n          expect(err.context.name).to.be(\"INVALID_ORIGIN\");\n          expect(err.context.origin).to.be(\"http://engine.io/\\n\");\n          partialDone();\n        });\n\n        request\n          .get(\"http://localhost:%d/engine.io/default/\".s(port))\n          .set(\"Origin\", \"http://engine.io/\")\n          .query({ transport: \"websocket\" })\n          .end((err, res) => {\n            expect(err).to.be.an(Error);\n            expect(res.status).to.be(400);\n            expect(res.body.code).to.be(3);\n            expect(res.body.message).to.be(\"Bad request\");\n            partialDone();\n          });\n      });\n    });\n\n    it(\"should disallow invalid handshake method\", done => {\n      const partialDone = createPartialDone(done, 2);\n\n      engine = listen(port => {\n        engine.on(\"connection_error\", err => {\n          expect(err.req).to.be.an(http.IncomingMessage);\n          expect(err.code).to.be(2);\n          expect(err.message).to.be(\"Bad handshake method\");\n          expect(err.context.method).to.be(\"OPTIONS\");\n          partialDone();\n        });\n\n        request\n          .options(\"http://localhost:%d/engine.io/default/\".s(port))\n          .query({ transport: \"polling\" })\n          .end((err, res) => {\n            expect(err).to.be.an(Error);\n            expect(res.status).to.be(400);\n            expect(res.body.code).to.be(2);\n            expect(res.body.message).to.be(\"Bad handshake method\");\n            partialDone();\n          });\n      });\n    });\n\n    it(\"should disallow unsupported protocol versions\", done => {\n      const partialDone = createPartialDone(done, 2);\n\n      const httpServer = http.createServer();\n      const engine = eio({ allowEIO3: false });\n      engine.attach(httpServer);\n      httpServer.listen(() => {\n        const port = httpServer.address().port;\n\n        engine.on(\"connection_error\", err => {\n          expect(err.req).to.be.an(http.IncomingMessage);\n          expect(err.code).to.be(5);\n          expect(err.message).to.be(\"Unsupported protocol version\");\n          expect(err.context.protocol).to.be(3);\n\n          httpServer.close();\n          partialDone();\n        });\n\n        request\n          .get(\"http://localhost:%d/engine.io/\".s(port))\n          .query({ transport: \"polling\", EIO: 3 })\n          .end((err, res) => {\n            expect(err).to.be.an(Error);\n            expect(res.status).to.be(400);\n            expect(res.body.code).to.be(5);\n            expect(res.body.message).to.be(\"Unsupported protocol version\");\n            partialDone();\n          });\n      });\n    });\n\n    it(\"should send a packet along with the handshake\", done => {\n      listen({ initialPacket: \"faster!\" }, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n        socket.on(\"open\", () => {\n          socket.on(\"message\", msg => {\n            expect(msg).to.be(\"faster!\");\n            done();\n          });\n        });\n      });\n    });\n  });\n\n  describe(\"close\", () => {\n    it(\"should be able to access non-empty writeBuffer at closing (server)\", done => {\n      const opts = { allowUpgrades: false };\n      const engine = listen(opts, port => {\n        eioc(\"http://localhost:%d\".s(port));\n        engine.on(\"connection\", conn => {\n          conn.on(\"close\", reason => {\n            expect(conn.writeBuffer.length).to.be(1);\n            setTimeout(() => {\n              expect(conn.writeBuffer.length).to.be(0); // writeBuffer has been cleared\n            }, 10);\n            done();\n          });\n          conn.writeBuffer.push({ type: \"message\", data: \"foo\" });\n          conn.onError(\"\");\n        });\n      });\n    });\n\n    it(\"should be able to access non-empty writeBuffer at closing (client)\", done => {\n      const opts = { allowUpgrades: false };\n      listen(opts, port => {\n        const socket = new eioc.Socket(\"http://localhost:%d\".s(port));\n        socket.on(\"open\", () => {\n          socket.on(\"close\", reason => {\n            expect(socket.writeBuffer.length).to.be(1);\n            setTimeout(() => {\n              expect(socket.writeBuffer.length).to.be(0);\n            }, 10);\n            done();\n          });\n          socket.writeBuffer.push({ type: \"message\", data: \"foo\" });\n          socket.onError(\"\");\n        });\n      });\n    });\n\n    it(\"should trigger on server if the client does not pong\", done => {\n      const opts = { allowUpgrades: false, pingInterval: 5, pingTimeout: 5 };\n      const engine = listen(opts, port => {\n        const socket = new eioc.Socket(\"http://localhost:%d\".s(port));\n        socket.sendPacket = () => {};\n        engine.on(\"connection\", conn => {\n          conn.on(\"close\", reason => {\n            expect(reason).to.be(\"ping timeout\");\n            done();\n          });\n        });\n      });\n    });\n\n    it(\"should trigger on server even when there is no outstanding polling request (GH-198)\", done => {\n      const opts = {\n        allowUpgrades: false,\n        pingInterval: 500,\n        pingTimeout: 500\n      };\n      const engine = listen(opts, port => {\n        const socket = new eioc.Socket(\"http://localhost:%d\".s(port));\n        engine.on(\"connection\", conn => {\n          conn.on(\"close\", reason => {\n            expect(reason).to.be(\"ping timeout\");\n            done();\n          });\n          // client abruptly disconnects, no polling request on this tick since we've just connected\n          socket.sendPacket = () => {};\n          socket.transport.removeListener(\"packet\");\n          socket.close();\n          // then server app tries to close the socket, since client disappeared\n          conn.close();\n        });\n      });\n    });\n\n    it(\"should trigger on client if server does not meet ping timeout\", done => {\n      const opts = { allowUpgrades: false, pingInterval: 50, pingTimeout: 30 };\n      listen(opts, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n        socket.on(\"open\", () => {\n          // override onPacket and Transport#onClose to simulate an inactive server after handshake\n          socket.transport.removeListener(\"packet\");\n          socket.transport.removeListener(\"close\");\n          socket.on(\"close\", (reason, err) => {\n            expect(reason).to.be(\"ping timeout\");\n            done();\n          });\n        });\n      });\n    });\n\n    it(\"should trigger on both ends upon ping timeout\", done => {\n      const opts = { allowUpgrades: false, pingTimeout: 50, pingInterval: 50 };\n      const engine = listen(opts, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n        let total = 2;\n\n        function onClose(reason, err) {\n          expect(reason).to.be(\"ping timeout\");\n          --total || done();\n        }\n\n        engine.on(\"connection\", conn => {\n          conn.on(\"close\", onClose);\n        });\n\n        socket.on(\"open\", () => {\n          // override onPacket and Transport#onClose to simulate an inactive server after handshake\n          socket.sendPacket = () => {};\n          socket.transport.removeListener(\"packet\");\n          socket.transport.removeListener(\"close\");\n          socket.on(\"close\", onClose);\n        });\n      });\n    });\n\n    it(\"should trigger when server closes a client\", done => {\n      const engine = listen({ allowUpgrades: false }, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n        let total = 2;\n\n        engine.on(\"connection\", conn => {\n          conn.on(\"close\", reason => {\n            expect(reason).to.be(\"forced close\");\n            --total || done();\n          });\n          setTimeout(() => {\n            conn.close();\n          }, 10);\n        });\n\n        socket.on(\"open\", () => {\n          socket.on(\"close\", reason => {\n            expect(reason).to.be(\"transport close\");\n            --total || done();\n          });\n        });\n      });\n    });\n\n    it(\"should trigger when server closes a client (ws)\", done => {\n      const opts = { allowUpgrades: false, transports: [\"websocket\"] };\n      const engine = listen(opts, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n          transports: [\"websocket\"]\n        });\n        let total = 2;\n\n        engine.on(\"connection\", conn => {\n          conn.on(\"close\", reason => {\n            expect(reason).to.be(\"forced close\");\n            --total || done();\n          });\n          setTimeout(() => {\n            conn.close();\n          }, 10);\n        });\n\n        socket.on(\"open\", () => {\n          socket.on(\"close\", reason => {\n            expect(reason).to.be(\"transport close\");\n            --total || done();\n          });\n        });\n      });\n    });\n\n    it(\"should allow client reconnect after restarting (ws)\", done => {\n      const opts = { transports: [\"websocket\"] };\n      const engine = listen(opts, port => {\n        engine.httpServer.close();\n        engine.httpServer.listen(port);\n\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n          transports: [\"websocket\"]\n        });\n\n        engine.once(\"connection\", conn => {\n          setTimeout(() => {\n            conn.close();\n          }, 10);\n        });\n\n        socket.once(\"close\", reason => {\n          expect(reason).to.be(\"transport close\");\n          done();\n        });\n      });\n    });\n\n    it(\"should trigger when client closes\", done => {\n      const engine = listen({ allowUpgrades: false }, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n        let total = 2;\n\n        engine.on(\"connection\", conn => {\n          conn.on(\"close\", reason => {\n            expect(reason).to.be(\"transport close\");\n            --total || done();\n          });\n        });\n\n        socket.on(\"open\", () => {\n          socket.on(\"close\", reason => {\n            expect(reason).to.be(\"forced close\");\n            --total || done();\n          });\n\n          setTimeout(() => {\n            socket.close();\n          }, 10);\n        });\n      });\n    });\n\n    it(\"should trigger when client closes (ws)\", done => {\n      const opts = { allowUpgrades: false, transports: [\"websocket\"] };\n      const engine = listen(opts, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n          transports: [\"websocket\"]\n        });\n        let total = 2;\n\n        engine.on(\"connection\", conn => {\n          conn.on(\"close\", reason => {\n            expect(reason).to.be(\"transport close\");\n            --total || done();\n          });\n        });\n\n        socket.on(\"open\", () => {\n          socket.on(\"close\", reason => {\n            expect(reason).to.be(\"forced close\");\n            --total || done();\n          });\n\n          setTimeout(() => {\n            socket.close();\n          }, 10);\n        });\n      });\n    });\n\n    it(\"should trigger when calling socket.close() in payload\", done => {\n      const engine = listen({ allowUpgrades: false }, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n\n        engine.on(\"connection\", conn => {\n          conn.send(null, () => {\n            socket.close();\n          });\n          conn.send(\"this should not be handled\");\n\n          conn.on(\"close\", reason => {\n            expect(reason).to.be(\"transport close\");\n            done();\n          });\n        });\n\n        socket.on(\"open\", () => {\n          socket.on(\"message\", msg => {\n            expect(msg).to.not.be(\"this should not be handled\");\n          });\n\n          socket.on(\"close\", reason => {\n            expect(reason).to.be(\"forced close\");\n          });\n        });\n      });\n    });\n\n    it(\"should abort upgrade if socket is closed (GH-35)\", done => {\n      listen({ allowUpgrades: true }, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n        socket.on(\"open\", () => {\n          socket.close();\n          // we wait until complete to see if we get an uncaught EPIPE\n          setTimeout(() => {\n            done();\n          }, 100);\n        });\n      });\n    });\n\n    it(\"should abort connection when upgrade fails\", done => {\n      listen({ allowUpgrades: true }, port => {\n        const req = http.request(\n          {\n            port,\n            path: \"/engine.io/\",\n            headers: {\n              connection: \"Upgrade\",\n              upgrade: \"websocket\"\n            }\n          },\n          res => {\n            expect(res.statusCode).to.eql(400);\n            res.resume();\n            res.on(\"end\", done);\n          }\n        );\n        req.end();\n      });\n    });\n\n    it(\n      \"should trigger if a poll request is ongoing and the underlying \" +\n        \"socket closes, as in a browser tab close\",\n      $done => {\n        const engine = listen({ allowUpgrades: false }, port => {\n          // hack to access the sockets created by node-xmlhttprequest\n          // see: https://github.com/driverdan/node-XMLHttpRequest/issues/44\n          const request = require(\"http\").request;\n          const sockets = [];\n          http.request = function(opts) {\n            const req = request.apply(null, arguments);\n            req.on(\"socket\", socket => {\n              sockets.push(socket);\n            });\n            return req;\n          };\n\n          function done() {\n            http.request = request;\n            $done();\n          }\n\n          var socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n          let serverSocket;\n\n          engine.on(\"connection\", s => {\n            serverSocket = s;\n          });\n\n          socket.transport.on(\"poll\", () => {\n            // we set a timer to wait for the request to actually reach\n            setTimeout(() => {\n              // at this time server's `connection` should have been fired\n              expect(serverSocket).to.be.an(\"object\");\n\n              // OPENED readyState is expected - we are actually polling\n              expect(socket.transport.pollXhr.xhr.readyState).to.be(1);\n\n              // 2 requests sent to the server over an unique port means\n              // we should have been assigned 2 sockets\n              expect(sockets.length).to.be(2);\n\n              // expect the socket to be open at this point\n              expect(serverSocket.readyState).to.be(\"open\");\n\n              // kill the underlying connection\n              sockets[1].end();\n              serverSocket.on(\"close\", (reason, err) => {\n                expect(reason).to.be(\"transport error\");\n                expect(err.message).to.be(\"poll connection closed prematurely\");\n                done();\n              });\n            }, 50);\n          });\n        });\n      }\n    );\n\n    it(\"should not trigger with connection: close header\", $done => {\n      const engine = listen({ allowUpgrades: false }, port => {\n        // intercept requests to add connection: close\n        const request = http.request;\n        http.request = function() {\n          const opts = arguments[0];\n          opts.headers = opts.headers || {};\n          opts.headers.Connection = \"close\";\n          return request.apply(this, arguments);\n        };\n\n        function done() {\n          http.request = request;\n          $done();\n        }\n\n        engine.on(\"connection\", socket => {\n          socket.on(\"message\", msg => {\n            expect(msg).to.equal(\"test\");\n            socket.send(\"woot\");\n          });\n        });\n\n        var socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n        socket.on(\"open\", () => {\n          socket.send(\"test\");\n        });\n        socket.on(\"message\", msg => {\n          expect(msg).to.be(\"woot\");\n          done();\n        });\n      });\n    });\n\n    it(\n      \"should not trigger early with connection `ping timeout`\" +\n        \"after post handshake timeout\",\n      done => {\n        // first timeout should trigger after `pingInterval + pingTimeout`,\n        // not just `pingTimeout`.\n        const opts = {\n          allowUpgrades: false,\n          pingInterval: 300,\n          pingTimeout: 100\n        };\n        listen(opts, port => {\n          const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n          let clientCloseReason = null;\n\n          socket.on(\"handshake\", () => {\n            socket.transport.removeListener(\"packet\");\n          });\n          socket.on(\"open\", () => {\n            socket.on(\"close\", reason => {\n              clientCloseReason = reason;\n            });\n          });\n\n          setTimeout(() => {\n            expect(clientCloseReason).to.be(null);\n            done();\n          }, 200);\n        });\n      }\n    );\n\n    it(\n      \"should not trigger early with connection `ping timeout` \" +\n        \"after post ping timeout\",\n      done => {\n        // ping timeout should trigger after `pingInterval + pingTimeout`,\n        // not just `pingTimeout`.\n        const opts = {\n          allowUpgrades: false,\n          pingInterval: 80,\n          pingTimeout: 50\n        };\n        const engine = listen(opts, port => {\n          const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n          let clientCloseReason = null;\n\n          engine.on(\"connection\", conn => {\n            conn.on(\"heartbeat\", () => {\n              conn.onPacket = () => {};\n            });\n          });\n\n          socket.on(\"open\", () => {\n            socket.on(\"close\", reason => {\n              clientCloseReason = reason;\n            });\n          });\n\n          setTimeout(() => {\n            expect(clientCloseReason).to.be(null);\n            done();\n          }, 100);\n        });\n      }\n    );\n\n    it(\n      \"should trigger early with connection `transport close` \" +\n        \"after missing pong\",\n      done => {\n        // ping timeout should trigger after `pingInterval + pingTimeout`,\n        // not just `pingTimeout`.\n        const opts = {\n          allowUpgrades: false,\n          pingInterval: 80,\n          pingTimeout: 50\n        };\n        const engine = listen(opts, port => {\n          const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n          let clientCloseReason = null;\n\n          socket.on(\"open\", () => {\n            socket.on(\"close\", reason => {\n              clientCloseReason = reason;\n            });\n          });\n\n          engine.on(\"connection\", conn => {\n            conn.on(\"heartbeat\", () => {\n              setTimeout(() => {\n                conn.close();\n              }, 20);\n              setTimeout(() => {\n                expect(clientCloseReason).to.be(\"transport close\");\n                done();\n              }, 100);\n            });\n          });\n        });\n      }\n    );\n\n    if (process.env.EIO_CLIENT === \"3\") {\n      it(\n        \"should trigger with connection `ping timeout` \" +\n          \"after `pingInterval + pingTimeout`\",\n        done => {\n          const opts = {\n            allowUpgrades: false,\n            pingInterval: 300,\n            pingTimeout: 100\n          };\n          const engine = listen(opts, port => {\n            const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n            let clientCloseReason = null;\n\n            socket.on(\"open\", () => {\n              socket.on(\"close\", reason => {\n                clientCloseReason = reason;\n              });\n            });\n\n            engine.on(\"connection\", conn => {\n              conn.once(\"heartbeat\", () => {\n                setTimeout(() => {\n                  socket.transport.removeListener(\"packet\");\n                  expect(clientCloseReason).to.be(null);\n                }, 150);\n                setTimeout(() => {\n                  expect(clientCloseReason).to.be(null);\n                }, 350);\n                setTimeout(() => {\n                  expect(clientCloseReason).to.be(\"ping timeout\");\n                  done();\n                }, 500);\n              });\n            });\n          });\n        }\n      );\n    } else {\n      it(\n        \"should trigger with connection `ping timeout` \" +\n          \"after `pingInterval + pingTimeout`\",\n        done => {\n          const opts = {\n            allowUpgrades: false,\n            pingInterval: 300,\n            pingTimeout: 100\n          };\n          const engine = listen(opts, port => {\n            const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n            let clientCloseReason = null;\n\n            socket.on(\"open\", () => {\n              socket.on(\"close\", reason => {\n                clientCloseReason = reason;\n              });\n            });\n\n            engine.on(\"connection\", conn => {\n              conn.once(\"heartbeat\", () => {\n                socket.transport.removeListener(\"packet\");\n                setTimeout(() => {\n                  expect(clientCloseReason).to.be(null);\n                }, 150);\n                setTimeout(() => {\n                  expect(clientCloseReason).to.be(null);\n                }, 350);\n                setTimeout(() => {\n                  expect(clientCloseReason).to.be(\"ping timeout\");\n                  done();\n                }, 500);\n              });\n            });\n          });\n        }\n      );\n    }\n\n    it(\n      \"should abort the polling data request if it is \" + \"in progress\",\n      done => {\n        const engine = listen({ transports: [\"polling\"] }, port => {\n          const socket = new eioc.Socket(\"http://localhost:%d\".s(port));\n\n          engine.on(\"connection\", conn => {\n            const onDataRequest = conn.transport.onDataRequest;\n            conn.transport.onDataRequest = (req, res) => {\n              engine.httpServer.close(done);\n              onDataRequest.call(conn.transport, req, res);\n              req.removeAllListeners();\n              conn.close();\n            };\n          });\n\n          socket.on(\"open\", () => {\n            socket.send(\"test\");\n          });\n        });\n      }\n    );\n\n    // tests https://github.com/LearnBoost/engine.io-client/issues/207\n    // websocket test, transport error\n    it(\"should trigger transport close before open for ws\", done => {\n      const opts = { transports: [\"websocket\"] };\n      listen(opts, port => {\n        const url = \"ws://%s:%d\".s(\"0.0.0.0\", port);\n        const socket = new eioc.Socket(url);\n        socket.on(\"open\", () => {\n          done(new Error(\"Test invalidation\"));\n        });\n        socket.on(\"close\", reason => {\n          expect(reason).to.be(\"transport error\");\n          done();\n        });\n      });\n    });\n\n    // tests https://github.com/LearnBoost/engine.io-client/issues/207\n    // polling test, transport error\n    it(\"should trigger transport close before open for xhr\", done => {\n      const opts = { transports: [\"polling\"] };\n      listen(opts, port => {\n        const socket = new eioc.Socket(\"http://invalidserver:%d\".s(port));\n        socket.on(\"open\", () => {\n          done(new Error(\"Test invalidation\"));\n        });\n        socket.on(\"close\", reason => {\n          expect(reason).to.be(\"transport error\");\n          done();\n        });\n      });\n    });\n\n    // tests https://github.com/LearnBoost/engine.io-client/issues/207\n    // websocket test, force close\n    it(\"should trigger force close before open for ws\", done => {\n      const opts = { transports: [\"websocket\"] };\n      listen(opts, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n        socket.on(\"open\", () => {\n          done(new Error(\"Test invalidation\"));\n        });\n        socket.on(\"close\", reason => {\n          expect(reason).to.be(\"forced close\");\n          done();\n        });\n        socket.close();\n      });\n    });\n\n    // tests https://github.com/LearnBoost/engine.io-client/issues/207\n    // polling test, force close\n    it(\"should trigger force close before open for xhr\", done => {\n      const opts = { transports: [\"polling\"] };\n      listen(opts, port => {\n        const socket = new eioc.Socket(\"http://localhost:%d\".s(port));\n        socket.on(\"open\", () => {\n          done(new Error(\"Test invalidation\"));\n        });\n        socket.on(\"close\", reason => {\n          expect(reason).to.be(\"forced close\");\n          done();\n        });\n        socket.close();\n      });\n    });\n\n    it(\"should close transport upon ping timeout (ws)\", done => {\n      const opts = {\n        allowUpgrades: false,\n        transports: [\"websocket\"],\n        pingInterval: 50,\n        pingTimeout: 30\n      };\n      const engine = listen(opts, port => {\n        engine.on(\"connection\", conn => {\n          conn.transport.on(\"close\", done);\n        });\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n          transports: [\"websocket\"]\n        });\n        // override to simulate an inactive client\n        socket.sendPacket = socket.onHeartbeat = () => {};\n      });\n    });\n\n    it(\"should close transport upon ping timeout (polling)\", done => {\n      const opts = {\n        allowUpgrades: false,\n        transports: [\"polling\"],\n        pingInterval: 50,\n        pingTimeout: 30\n      };\n      const engine = listen(opts, port => {\n        engine.on(\"connection\", conn => {\n          conn.transport.on(\"close\", done);\n        });\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n          transports: [\"polling\"]\n        });\n        // override to simulate an inactive client\n        socket.sendPacket = socket.onHeartbeat = () => {};\n      });\n    });\n\n    it(\"should close transport upon parse error (ws)\", done => {\n      const opts = { allowUpgrades: false, transports: [\"websocket\"] };\n      const engine = listen(opts, port => {\n        engine.on(\"connection\", conn => {\n          conn.transport.on(\"close\", done);\n        });\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n          transports: [\"websocket\"]\n        });\n        socket.on(\"open\", () => {\n          socket.transport.ws.send(\"invalid\");\n        });\n      });\n    });\n\n    it(\"should close transport upon parse error (polling)\", done => {\n      const opts = { allowUpgrades: false, transports: [\"polling\"] };\n      const engine = listen(opts, port => {\n        engine.on(\"connection\", conn => {\n          conn.transport.closeTimeout = 100;\n          conn.transport.on(\"close\", done);\n        });\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n          transports: [\"polling\"]\n        });\n        socket.on(\"open\", () => {\n          socket.transport.doWrite(\"invalid\", () => {});\n        });\n      });\n    });\n\n    it(\"should close upgrading transport upon socket close\", done => {\n      const engine = listen(port => {\n        engine.on(\"connection\", conn => {\n          conn.on(\"upgrading\", transport => {\n            transport.on(\"close\", done);\n            conn.close();\n          });\n        });\n        eioc(\"ws://localhost:%d\".s(port));\n      });\n    });\n\n    it(\"should close upgrading transport upon upgrade timeout\", done => {\n      const opts = { upgradeTimeout: 100 };\n      const engine = listen(opts, port => {\n        engine.on(\"connection\", conn => {\n          conn.on(\"upgrading\", transport => {\n            transport.on(\"close\", done);\n          });\n        });\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n        socket.on(\"upgrading\", transport => {\n          // override not to complete upgrading\n          transport.send = () => {};\n        });\n      });\n    });\n\n    it(\"should not timeout after an upgrade\", done => {\n      const opts = { pingInterval: 200, pingTimeout: 20 };\n      const engine = listen(opts, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n        socket.on(\"open\", () => {\n          setTimeout(() => {\n            socket.removeListener(\"close\");\n            engine.close();\n            socket.close();\n            done();\n          }, 500);\n        });\n        socket.on(\"close\", () => {\n          done(new Error(\"should not happen\"));\n        });\n      });\n    });\n\n    it(\"should not crash when messing with Object prototype\", done => {\n      Object.prototype.foo = \"bar\"; // eslint-disable-line no-extend-native\n      const engine = listen({ allowUpgrades: true }, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n        socket.on(\"open\", () => {\n          engine.close();\n          setTimeout(() => {\n            done();\n          }, 100);\n        });\n      });\n    });\n\n    describe(\"graceful close\", () => {\n      function fixture(filename) {\n        return (\n          process.execPath + \" \" + path.join(__dirname, \"fixtures\", filename)\n        );\n      }\n\n      it(\"should stop socket and timers\", done => {\n        exec(fixture(\"server-close.js\"), done);\n      });\n\n      it(\"should stop upgraded socket and timers\", done => {\n        exec(fixture(\"server-close-upgraded.js\"), done);\n      });\n\n      it(\"should stop upgrading socket and timers\", done => {\n        exec(fixture(\"server-close-upgrading.js\"), done);\n      });\n    });\n  });\n\n  describe(\"messages\", function() {\n    this.timeout(5000);\n\n    it(\"should arrive from server to client\", done => {\n      const engine = listen({ allowUpgrades: false }, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n        engine.on(\"connection\", conn => {\n          conn.send(\"a\");\n        });\n        socket.on(\"open\", () => {\n          socket.on(\"message\", msg => {\n            expect(msg).to.be(\"a\");\n            done();\n          });\n        });\n      });\n    });\n\n    it(\"should arrive from server to client (multiple)\", done => {\n      const engine = listen({ allowUpgrades: false }, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n        const expected = [\"a\", \"b\", \"c\"];\n        let i = 0;\n\n        engine.on(\"connection\", conn => {\n          conn.send(\"a\");\n          // we use set timeouts to ensure the messages are delivered as part\n          // of different.\n          setTimeout(() => {\n            conn.send(\"b\");\n\n            setTimeout(() => {\n              // here we make sure we buffer both the close packet and\n              // a regular packet\n              conn.send(\"c\");\n              conn.close();\n            }, 50);\n          }, 50);\n\n          conn.on(\"close\", () => {\n            // since close fires right after the buffer is drained\n            setTimeout(() => {\n              expect(i).to.be(3);\n              done();\n            }, 50);\n          });\n        });\n        socket.on(\"open\", () => {\n          socket.on(\"message\", msg => {\n            expect(msg).to.be(expected[i++]);\n          });\n        });\n      });\n    });\n\n    it(\"should not be receiving data when getting a message longer than maxHttpBufferSize when polling\", done => {\n      const opts = {\n        allowUpgrades: false,\n        transports: [\"polling\"],\n        maxHttpBufferSize: 5\n      };\n      const engine = listen(opts, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n        engine.on(\"connection\", conn => {\n          conn.on(\"message\", msg => {\n            done(\n              new Error(\"Test invalidation (message is longer than allowed)\")\n            );\n          });\n        });\n        socket.on(\"open\", () => {\n          socket.send(\"aasdasdakjhasdkjhasdkjhasdkjhasdkjhasdkjhasdkjha\");\n        });\n        socket.on(\"close\", () => {\n          done();\n        });\n      });\n    });\n\n    it(\"should not be receiving data when getting a message longer than maxHttpBufferSize (websocket)\", done => {\n      const opts = { maxHttpBufferSize: 5 };\n      const engine = listen(opts, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n          transports: [\"websocket\"]\n        });\n        engine.on(\"connection\", conn => {\n          conn.on(\"message\", msg => {\n            done(\n              new Error(\"Test invalidation (message is longer than allowed)\")\n            );\n          });\n        });\n        socket.on(\"open\", () => {\n          socket.send(\"aasdasdakjhasdkjhasdkjhasdkjhasdkjhasdkjhasdkjha\");\n        });\n        socket.on(\"close\", () => {\n          done();\n        });\n      });\n    });\n\n    it(\"should receive data when getting a message shorter than maxHttpBufferSize when polling\", done => {\n      const opts = {\n        allowUpgrades: false,\n        transports: [\"polling\"],\n        maxHttpBufferSize: 5\n      };\n      const engine = listen(opts, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n        engine.on(\"connection\", conn => {\n          conn.on(\"message\", msg => {\n            expect(msg).to.be(\"a\");\n            done();\n          });\n        });\n        socket.on(\"open\", () => {\n          socket.send(\"a\");\n        });\n      });\n    });\n\n    it(\"should arrive from server to client (ws)\", done => {\n      const opts = { allowUpgrades: false, transports: [\"websocket\"] };\n      const engine = listen(opts, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n          transports: [\"websocket\"]\n        });\n        engine.on(\"connection\", conn => {\n          conn.send(\"a\");\n        });\n        socket.on(\"open\", () => {\n          socket.on(\"message\", msg => {\n            expect(msg).to.be(\"a\");\n            done();\n          });\n        });\n      });\n    });\n\n    it(\"should arrive from server to client (multiple, ws)\", done => {\n      const opts = { allowUpgrades: false, transports: [\"websocket\"] };\n      const engine = listen(opts, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n          transports: [\"websocket\"]\n        });\n        const expected = [\"a\", \"b\", \"c\"];\n        let i = 0;\n\n        engine.on(\"connection\", conn => {\n          conn.send(\"a\");\n          setTimeout(() => {\n            conn.send(\"b\");\n            setTimeout(() => {\n              conn.send(\"c\");\n              conn.close();\n            }, 50);\n          }, 50);\n          conn.on(\"close\", () => {\n            setTimeout(() => {\n              expect(i).to.be(3);\n              done();\n            }, 50);\n          });\n        });\n\n        socket.on(\"open\", () => {\n          socket.on(\"message\", msg => {\n            expect(msg).to.be(expected[i++]);\n          });\n        });\n      });\n    });\n\n    it(\"should arrive from server to client (multiple, no delay, ws)\", done => {\n      const opts = { allowUpgrades: false, transports: [\"websocket\"] };\n      const engine = listen(opts, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n          transports: [\"websocket\"]\n        });\n        const expected = [\"a\", \"b\", \"c\"];\n        let i = 0;\n\n        engine.on(\"connection\", conn => {\n          conn.on(\"close\", () => {\n            setTimeout(() => {\n              expect(i).to.be(3);\n              done();\n            }, 50);\n          });\n          conn.send(\"a\");\n          conn.send(\"b\");\n          conn.send(\"c\");\n          setTimeout(() => {\n            conn.close();\n          }, 50);\n        });\n\n        socket.on(\"open\", () => {\n          socket.on(\"message\", msg => {\n            expect(msg).to.be(expected[i++]);\n          });\n        });\n      });\n    });\n\n    it(\"should arrive when binary data is sent as Int8Array (ws)\", done => {\n      const binaryData = new Int8Array(5);\n      for (let i = 0; i < binaryData.length; i++) {\n        binaryData[i] = i;\n      }\n\n      const opts = { allowUpgrades: false, transports: [\"websocket\"] };\n      const engine = listen(opts, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n          transports: [\"websocket\"]\n        });\n\n        engine.on(\"connection\", conn => {\n          conn.send(binaryData);\n        });\n\n        socket.on(\"open\", () => {\n          socket.on(\"message\", msg => {\n            for (let i = 0; i < binaryData.length; i++) {\n              const num = msg.readInt8(i);\n              expect(num).to.be(i);\n            }\n            done();\n          });\n        });\n      });\n    });\n\n    it(\"should arrive when binary data is sent as Int32Array (ws)\", done => {\n      const binaryData = new Int32Array(5);\n      for (let i = 0; i < binaryData.length; i++) {\n        binaryData[i] = (i + 100) * 9823;\n      }\n\n      const opts = { allowUpgrades: false, transports: [\"websocket\"] };\n      const engine = listen(opts, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n          transports: [\"websocket\"]\n        });\n\n        engine.on(\"connection\", conn => {\n          conn.send(binaryData);\n        });\n\n        socket.on(\"open\", () => {\n          socket.on(\"message\", msg => {\n            let i = 0,\n              ii = 0;\n            for (; ii < binaryData.length; i += 4, ii++) {\n              const num = msg.readInt32LE(i);\n              expect(num).to.be((ii + 100) * 9823);\n            }\n            done();\n          });\n        });\n      });\n    });\n\n    it(\"should arrive when binary data is sent as Int32Array, given as ArrayBuffer(ws)\", done => {\n      const binaryData = new Int32Array(5);\n      for (let i = 0; i < binaryData.length; i++) {\n        binaryData[i] = (i + 100) * 9823;\n      }\n\n      const opts = { allowUpgrades: false, transports: [\"websocket\"] };\n      const engine = listen(opts, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n          transports: [\"websocket\"]\n        });\n\n        engine.on(\"connection\", conn => {\n          conn.send(binaryData.buffer);\n        });\n\n        socket.on(\"open\", () => {\n          socket.on(\"message\", msg => {\n            let i = 0,\n              ii = 0;\n            for (; ii < binaryData.length; i += 4, ii++) {\n              const num = msg.readInt32LE(i);\n              expect(num).to.be((ii + 100) * 9823);\n            }\n            done();\n          });\n        });\n      });\n    });\n\n    it(\"should arrive when binary data is sent as Buffer (ws)\", done => {\n      const binaryData = Buffer.allocUnsafe(5);\n      for (let i = 0; i < binaryData.length; i++) {\n        binaryData.writeInt8(i, i);\n      }\n\n      const opts = { allowUpgrades: false, transports: [\"websocket\"] };\n      const engine = listen(opts, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n          transports: [\"websocket\"]\n        });\n\n        engine.on(\"connection\", conn => {\n          conn.send(binaryData);\n        });\n\n        socket.on(\"open\", () => {\n          socket.on(\"message\", msg => {\n            for (let i = 0; i < binaryData.length; i++) {\n              const num = msg.readInt8(i);\n              expect(num).to.be(i);\n            }\n            done();\n          });\n        });\n      });\n    });\n\n    it(\"should arrive when binary data sent as Buffer (polling)\", done => {\n      const binaryData = Buffer.allocUnsafe(5);\n      for (let i = 0; i < binaryData.length; i++) {\n        binaryData.writeInt8(i, i);\n      }\n\n      const opts = { allowUpgrades: false, transports: [\"polling\"] };\n      const engine = listen(opts, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n          transports: [\"polling\"]\n        });\n\n        engine.on(\"connection\", conn => {\n          conn.send(binaryData);\n        });\n\n        socket.on(\"open\", () => {\n          socket.on(\"message\", msg => {\n            for (let i = 0; i < binaryData.length; i++) {\n              const num = msg.readInt8(i);\n              expect(num).to.be(i);\n            }\n\n            done();\n          });\n        });\n      });\n    });\n\n    it(\"should arrive as ArrayBuffer if requested when binary data sent as Buffer (ws)\", done => {\n      const binaryData = Buffer.allocUnsafe(5);\n      for (let i = 0; i < binaryData.length; i++) {\n        binaryData.writeInt8(i, i);\n      }\n\n      const opts = { allowUpgrades: false, transports: [\"websocket\"] };\n      const engine = listen(opts, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n          transports: [\"websocket\"]\n        });\n        socket.binaryType = \"arraybuffer\";\n\n        engine.on(\"connection\", conn => {\n          conn.send(binaryData);\n        });\n\n        socket.on(\"open\", () => {\n          socket.on(\"message\", msg => {\n            expect(msg instanceof ArrayBuffer).to.be(true);\n            const intArray = new Int8Array(msg);\n            for (let i = 0; i < binaryData.length; i++) {\n              expect(intArray[i]).to.be(i);\n            }\n\n            done();\n          });\n        });\n      });\n    });\n\n    it(\"should arrive as ArrayBuffer if requested when binary data sent as Buffer (polling)\", done => {\n      const binaryData = Buffer.allocUnsafe(5);\n      for (let i = 0; i < binaryData.length; i++) {\n        binaryData.writeInt8(i, i);\n      }\n\n      const opts = { allowUpgrades: false, transports: [\"polling\"] };\n      const engine = listen(opts, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n          transports: [\"polling\"]\n        });\n        socket.binaryType = \"arraybuffer\";\n\n        engine.on(\"connection\", conn => {\n          conn.send(binaryData);\n        });\n\n        socket.on(\"open\", () => {\n          socket.on(\"message\", msg => {\n            expect(msg instanceof ArrayBuffer).to.be(true);\n            const intArray = new Int8Array(msg);\n            for (let i = 0; i < binaryData.length; i++) {\n              expect(intArray[i]).to.be(i);\n            }\n\n            done();\n          });\n        });\n      });\n    });\n\n    it(\"should trigger a flush/drain event\", done => {\n      const engine = listen({ allowUpgrades: false }, port => {\n        engine.on(\"connection\", socket => {\n          let totalEvents = 4;\n\n          engine.on(\"flush\", (sock, buf) => {\n            expect(sock).to.be(socket);\n            expect(buf).to.be.an(\"array\");\n            --totalEvents || done();\n          });\n          socket.on(\"flush\", buf => {\n            expect(buf).to.be.an(\"array\");\n            --totalEvents || done();\n          });\n\n          engine.on(\"drain\", sock => {\n            expect(sock).to.be(socket);\n            expect(socket.writeBuffer.length).to.be(0);\n            --totalEvents || done();\n          });\n          socket.on(\"drain\", () => {\n            expect(socket.writeBuffer.length).to.be(0);\n            --totalEvents || done();\n          });\n\n          socket.send(\"aaaa\");\n        });\n\n        eioc(\"ws://localhost:%d\".s(port));\n      });\n    });\n\n    it(\n      \"should interleave with pongs if many messages buffered \" +\n        \"after connection open\",\n      function(done) {\n        this.slow(4000);\n        this.timeout(8000);\n\n        const opts = {\n          transports: [\"websocket\"],\n          pingInterval: 200,\n          pingTimeout: 100\n        };\n\n        const engine = listen(opts, port => {\n          const messageCount = 100;\n          const messagePayload = new Array(256 * 256).join(\"a\");\n          let connection = null;\n          engine.on(\"connection\", conn => {\n            connection = conn;\n          });\n          const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n            transports: [\"websocket\"]\n          });\n          socket.on(\"open\", () => {\n            for (let i = 0; i < messageCount; i++) {\n              //            connection.send('message: ' + i);   // works\n              connection.send(messagePayload + \"|message: \" + i); // does not work\n            }\n            let receivedCount = 0;\n            socket.on(\"message\", msg => {\n              receivedCount += 1;\n              if (receivedCount === messageCount) {\n                done();\n              }\n            });\n          });\n        });\n      }\n    );\n\n    it(\"should support chinese\", done => {\n      const engine = listen({ allowUpgrades: false }, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n        const shi = \"\u77f3\u5ba4\u8a69\u58eb\u65bd\u6c0f\uff0c\u55dc\u7345\uff0c\u8a93\u98df\u5341\u7345\u3002\";\n        const shi2 = \"\u6c0f\u6642\u6642\u9069\u5e02\u8996\u7345\u3002\";\n        engine.on(\"connection\", conn => {\n          conn.send(\".\");\n          conn.send(shi);\n          conn.send(shi2);\n          conn.once(\"message\", msg0 => {\n            expect(msg0).to.be(\".\");\n            conn.once(\"message\", msg => {\n              expect(msg).to.be(shi);\n              conn.once(\"message\", msg2 => {\n                expect(msg2).to.be(shi2);\n                done();\n              });\n            });\n          });\n        });\n        socket.on(\"open\", () => {\n          socket.once(\"message\", msg0 => {\n            expect(msg0).to.be(\".\");\n            socket.once(\"message\", msg => {\n              expect(msg).to.be(shi);\n              socket.once(\"message\", msg2 => {\n                expect(msg2).to.be(shi2);\n                socket.send(\".\");\n                socket.send(shi);\n                socket.send(shi2);\n              });\n            });\n          });\n        });\n      });\n    });\n\n    it(\"should send and receive data with key and cert (polling)\", done => {\n      const srvOpts = {\n        key: fs.readFileSync(\"test/fixtures/server.key\"),\n        cert: fs.readFileSync(\"test/fixtures/server.crt\"),\n        ca: fs.readFileSync(\"test/fixtures/ca.crt\"),\n        requestCert: true,\n        rejectUnauthorized: true\n      };\n\n      const opts = {\n        key: fs.readFileSync(\"test/fixtures/client.key\"),\n        cert: fs.readFileSync(\"test/fixtures/client.crt\"),\n        ca: fs.readFileSync(\"test/fixtures/ca.crt\"),\n        transports: [\"polling\"]\n      };\n\n      const srv = https.createServer(srvOpts, (req, res) => {\n        res.writeHead(200);\n        res.end(\"hello world\\n\");\n      });\n\n      const engine = eio({\n        transports: [\"polling\"],\n        allowUpgrades: false,\n        allowEIO3: true\n      });\n      engine.attach(srv);\n      srv.listen(() => {\n        const port = srv.address().port;\n        const socket = new eioc.Socket(\"https://localhost:%d\".s(port), opts);\n\n        engine.on(\"connection\", conn => {\n          conn.on(\"message\", msg => {\n            expect(msg).to.be(\"hello\");\n            done();\n          });\n        });\n\n        socket.on(\"open\", () => {\n          socket.send(\"hello\");\n        });\n      });\n    });\n\n    it(\"should send and receive data with ca when not requiring auth (polling)\", done => {\n      const srvOpts = {\n        key: fs.readFileSync(\"test/fixtures/server.key\"),\n        cert: fs.readFileSync(\"test/fixtures/server.crt\"),\n        ca: fs.readFileSync(\"test/fixtures/ca.crt\"),\n        requestCert: true,\n        rejectUnauthorized: false\n      };\n\n      const opts = {\n        ca: fs.readFileSync(\"test/fixtures/ca.crt\"),\n        transports: [\"polling\"]\n      };\n\n      const srv = https.createServer(srvOpts, (req, res) => {\n        res.writeHead(200);\n        res.end(\"hello world\\n\");\n      });\n\n      const engine = eio({\n        transports: [\"polling\"],\n        allowUpgrades: false,\n        allowEIO3: true\n      });\n      engine.attach(srv);\n      srv.listen(() => {\n        const port = srv.address().port;\n        const socket = new eioc.Socket(\"https://localhost:%d\".s(port), opts);\n\n        engine.on(\"connection\", conn => {\n          conn.on(\"message\", msg => {\n            expect(msg).to.be(\"hello\");\n            done();\n          });\n        });\n\n        socket.on(\"open\", () => {\n          socket.send(\"hello\");\n        });\n      });\n    });\n\n    it(\"should send and receive data with key and cert (ws)\", done => {\n      const srvOpts = {\n        key: fs.readFileSync(\"test/fixtures/server.key\"),\n        cert: fs.readFileSync(\"test/fixtures/server.crt\"),\n        ca: fs.readFileSync(\"test/fixtures/ca.crt\"),\n        requestCert: true,\n        rejectUnauthorized: true\n      };\n\n      const opts = {\n        key: fs.readFileSync(\"test/fixtures/client.key\"),\n        cert: fs.readFileSync(\"test/fixtures/client.crt\"),\n        ca: fs.readFileSync(\"test/fixtures/ca.crt\"),\n        transports: [\"websocket\"]\n      };\n\n      const srv = https.createServer(srvOpts, (req, res) => {\n        res.writeHead(200);\n        res.end(\"hello world\\n\");\n      });\n\n      const engine = eio({\n        transports: [\"websocket\"],\n        allowUpgrades: false,\n        allowEIO3: true\n      });\n      engine.attach(srv);\n      srv.listen(() => {\n        const port = srv.address().port;\n        const socket = new eioc.Socket(\"https://localhost:%d\".s(port), opts);\n\n        engine.on(\"connection\", conn => {\n          conn.on(\"message\", msg => {\n            expect(msg).to.be(\"hello\");\n            done();\n          });\n        });\n\n        socket.on(\"open\", () => {\n          socket.send(\"hello\");\n        });\n      });\n    });\n\n    it(\"should send and receive data with pfx (polling)\", done => {\n      const srvOpts = {\n        key: fs.readFileSync(\"test/fixtures/server.key\"),\n        cert: fs.readFileSync(\"test/fixtures/server.crt\"),\n        ca: fs.readFileSync(\"test/fixtures/ca.crt\"),\n        requestCert: true,\n        rejectUnauthorized: true\n      };\n\n      const opts = {\n        pfx: fs.readFileSync(\"test/fixtures/client.pfx\"),\n        ca: fs.readFileSync(\"test/fixtures/ca.crt\"),\n        transports: [\"polling\"]\n      };\n\n      const srv = https.createServer(srvOpts, (req, res) => {\n        res.writeHead(200);\n        res.end(\"hello world\\n\");\n      });\n\n      const engine = eio({\n        transports: [\"polling\"],\n        allowUpgrades: false,\n        allowEIO3: true\n      });\n      engine.attach(srv);\n      srv.listen(() => {\n        const port = srv.address().port;\n        const socket = new eioc.Socket(\"https://localhost:%d\".s(port), opts);\n\n        engine.on(\"connection\", conn => {\n          conn.on(\"message\", msg => {\n            expect(msg).to.be(\"hello\");\n            done();\n          });\n        });\n\n        socket.on(\"open\", () => {\n          socket.send(\"hello\");\n        });\n      });\n    });\n\n    it(\"should send and receive data with pfx (ws)\", done => {\n      const srvOpts = {\n        key: fs.readFileSync(\"test/fixtures/server.key\"),\n        cert: fs.readFileSync(\"test/fixtures/server.crt\"),\n        ca: fs.readFileSync(\"test/fixtures/ca.crt\"),\n        requestCert: true,\n        rejectUnauthorized: true\n      };\n\n      const opts = {\n        pfx: fs.readFileSync(\"test/fixtures/client.pfx\"),\n        ca: fs.readFileSync(\"test/fixtures/ca.crt\"),\n        transports: [\"websocket\"]\n      };\n\n      const srv = https.createServer(srvOpts, (req, res) => {\n        res.writeHead(200);\n        res.end(\"hello world\\n\");\n      });\n\n      const engine = eio({\n        transports: [\"websocket\"],\n        allowUpgrades: false,\n        allowEIO3: true\n      });\n      engine.attach(srv);\n      srv.listen(() => {\n        const port = srv.address().port;\n        const socket = new eioc.Socket(\"https://localhost:%d\".s(port), opts);\n\n        engine.on(\"connection\", conn => {\n          conn.on(\"message\", msg => {\n            expect(msg).to.be(\"hello\");\n            done();\n          });\n        });\n\n        socket.on(\"open\", () => {\n          socket.send(\"hello\");\n        });\n      });\n    });\n  });\n\n  describe(\"send\", () => {\n    describe(\"writeBuffer\", () => {\n      it(\"should not empty until `drain` event (polling)\", done => {\n        listen({ allowUpgrades: false }, port => {\n          const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n            transports: [\"polling\"]\n          });\n          let totalEvents = 2;\n          socket.on(\"open\", () => {\n            socket.send(\"a\");\n            socket.send(\"b\");\n            // writeBuffer should be nonempty, with 'a' still in it\n            expect(socket.writeBuffer.length).to.eql(2);\n          });\n          socket.transport.on(\"drain\", () => {\n            expect(socket.writeBuffer.length).to.eql(--totalEvents);\n            totalEvents || done();\n          });\n        });\n      });\n\n      it(\"should not empty until `drain` event (websocket)\", done => {\n        listen({ allowUpgrades: false }, port => {\n          const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n            transports: [\"websocket\"]\n          });\n          let totalEvents = 2;\n          socket.on(\"open\", () => {\n            socket.send(\"a\");\n            socket.send(\"b\");\n            // writeBuffer should be nonempty, with 'a' still in it\n            expect(socket.writeBuffer.length).to.eql(2);\n          });\n          socket.transport.on(\"drain\", () => {\n            expect(socket.writeBuffer.length).to.eql(--totalEvents);\n            totalEvents || done();\n          });\n        });\n      });\n    });\n\n    describe(\"callback\", () => {\n      it(\"should execute in order when message sent (client) (polling)\", done => {\n        const engine = listen({ allowUpgrades: false }, port => {\n          const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n            transports: [\"polling\"]\n          });\n          let i = 0;\n          let j = 0;\n\n          engine.on(\"connection\", conn => {\n            conn.on(\"message\", msg => {\n              conn.send(msg);\n            });\n          });\n\n          socket.on(\"open\", () => {\n            socket.on(\"message\", msg => {\n              // send another packet until we've sent 3 total\n              if (++i < 3) {\n                expect(i).to.eql(j);\n                sendFn();\n              } else {\n                done();\n              }\n            });\n\n            function sendFn() {\n              socket.send(\n                j,\n                (value => {\n                  j++;\n                })(j)\n              );\n            }\n\n            sendFn();\n          });\n        });\n      });\n\n      it(\"should execute in order when message sent (client) (websocket)\", done => {\n        const engine = listen({ allowUpgrades: false }, port => {\n          const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n            transports: [\"websocket\"]\n          });\n          let i = 0;\n          let j = 0;\n\n          engine.on(\"connection\", conn => {\n            conn.on(\"message\", msg => {\n              conn.send(msg);\n            });\n          });\n\n          socket.on(\"open\", () => {\n            socket.on(\"message\", msg => {\n              // send another packet until we've sent 3 total\n              if (++i < 3) {\n                expect(i).to.eql(j);\n                sendFn();\n              } else {\n                done();\n              }\n            });\n\n            function sendFn() {\n              socket.send(\n                j,\n                (value => {\n                  j++;\n                })(j)\n              );\n            }\n\n            sendFn();\n          });\n        });\n      });\n\n      it(\"should execute in order with payloads (client) (polling)\", done => {\n        const engine = listen({ allowUpgrades: false }, port => {\n          const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n            transports: [\"polling\"]\n          });\n          let i = 0;\n          let lastCbFired = 0;\n\n          engine.on(\"connection\", conn => {\n            conn.on(\"message\", msg => {\n              conn.send(msg);\n            });\n          });\n\n          socket.on(\"open\", () => {\n            socket.on(\"message\", msg => {\n              expect(msg).to.eql(i + 1);\n              i++;\n            });\n\n            function cb(value) {\n              expect(value).to.eql(lastCbFired + 1);\n              lastCbFired = value;\n              if (value === 3) {\n                done();\n              }\n            }\n\n            // 2 and 3 will be in the same payload\n            socket.once(\"flush\", () => {\n              socket.send(2, () => {\n                cb(2);\n              });\n              socket.send(3, () => {\n                cb(3);\n              });\n            });\n\n            socket.send(1, () => {\n              cb(1);\n            });\n          });\n        });\n      });\n\n      it(\"should execute in order with payloads (client) (websocket)\", done => {\n        const engine = listen({ allowUpgrades: false }, port => {\n          const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n            transports: [\"websocket\"]\n          });\n          let i = 0;\n          let lastCbFired = 0;\n\n          engine.on(\"connection\", conn => {\n            conn.on(\"message\", msg => {\n              conn.send(msg);\n            });\n          });\n\n          socket.on(\"open\", () => {\n            socket.on(\"message\", msg => {\n              expect(msg).to.eql(i + 1);\n              i++;\n            });\n\n            function cb(value) {\n              expect(value).to.eql(lastCbFired + 1);\n              lastCbFired = value;\n              if (value === 3) {\n                done();\n              }\n            }\n\n            // 2 and 3 will be in the same payload\n            socket.once(\"flush\", () => {\n              socket.send(2, () => {\n                cb(2);\n              });\n              socket.send(3, () => {\n                cb(3);\n              });\n            });\n\n            socket.send(1, () => {\n              cb(1);\n            });\n          });\n        });\n      });\n\n      it(\"should execute when message sent (polling)\", done => {\n        const engine = listen({ allowUpgrades: false }, port => {\n          const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n            transports: [\"polling\"]\n          });\n          let i = 0;\n          let j = 0;\n\n          engine.on(\"connection\", conn => {\n            conn.send(\"a\", transport => {\n              i++;\n            });\n          });\n          socket.on(\"open\", () => {\n            socket.on(\"message\", msg => {\n              j++;\n            });\n          });\n\n          setTimeout(() => {\n            expect(i).to.be(j);\n            done();\n          }, 100);\n        });\n      });\n\n      it(\"should execute when message sent (websocket)\", done => {\n        const engine = listen({ allowUpgrades: false }, port => {\n          const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n            transports: [\"websocket\"]\n          });\n          let i = 0;\n          let j = 0;\n\n          engine.on(\"connection\", conn => {\n            conn.send(\"a\", transport => {\n              i++;\n            });\n          });\n\n          socket.on(\"open\", () => {\n            socket.on(\"message\", msg => {\n              j++;\n            });\n          });\n\n          setTimeout(() => {\n            expect(i).to.be(j);\n            done();\n          }, 100);\n        });\n      });\n\n      it(\"should execute once for each send\", done => {\n        const engine = listen(port => {\n          const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n          let a = 0;\n          let b = 0;\n          let c = 0;\n          let all = 0;\n\n          engine.on(\"connection\", conn => {\n            conn.send(\"a\");\n            conn.send(\"b\");\n            conn.send(\"c\");\n          });\n\n          socket.on(\"open\", () => {\n            socket.on(\"message\", msg => {\n              if (msg === \"a\") a++;\n              if (msg === \"b\") b++;\n              if (msg === \"c\") c++;\n\n              if (++all === 3) {\n                expect(a).to.be(1);\n                expect(b).to.be(1);\n                expect(c).to.be(1);\n                done();\n              }\n            });\n          });\n        });\n      });\n\n      it(\"should execute in multipart packet\", done => {\n        const engine = listen(port => {\n          const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n          let i = 0;\n          let j = 0;\n\n          engine.on(\"connection\", conn => {\n            conn.send(\"b\", transport => {\n              i++;\n            });\n\n            conn.send(\"a\", transport => {\n              i++;\n            });\n          });\n          socket.on(\"open\", () => {\n            socket.on(\"message\", msg => {\n              j++;\n            });\n          });\n\n          setTimeout(() => {\n            expect(i).to.be(j);\n            done();\n          }, 200);\n        });\n      });\n\n      it(\"should execute in multipart packet (polling)\", done => {\n        const engine = listen(port => {\n          const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n            transports: [\"polling\"]\n          });\n          let i = 0;\n          let j = 0;\n\n          engine.on(\"connection\", conn => {\n            conn.send(\"d\", transport => {\n              i++;\n            });\n\n            conn.send(\"c\", transport => {\n              i++;\n            });\n\n            conn.send(\"b\", transport => {\n              i++;\n            });\n\n            conn.send(\"a\", transport => {\n              i++;\n            });\n          });\n          socket.on(\"open\", () => {\n            socket.on(\"message\", msg => {\n              j++;\n            });\n          });\n\n          setTimeout(() => {\n            expect(i).to.be(j);\n            done();\n          }, 200);\n        });\n      });\n\n      it(\"should clean callback references when socket gets closed with pending callbacks\", done => {\n        const engine = listen({ allowUpgrades: false }, port => {\n          const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n            transports: [\"polling\"]\n          });\n\n          engine.on(\"connection\", conn => {\n            socket.transport.on(\"pollComplete\", () => {\n              conn.send(\"a\", transport => {\n                done(new Error(\"Test invalidation\"));\n              });\n\n              if (!conn.writeBuffer.length) {\n                done(new Error(\"Test invalidation\"));\n              }\n\n              // force to close the socket when we have one or more packet(s) in buffer\n              socket.close();\n            });\n\n            conn.on(\"close\", reason => {\n              expect(conn.packetsFn).to.be.empty();\n              expect(conn.sentCallbackFn).to.be.empty();\n              done();\n            });\n          });\n        });\n      });\n\n      it(\"should not execute when it is not actually sent (polling)\", done => {\n        const engine = listen({ allowUpgrades: false }, port => {\n          const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n            transports: [\"polling\"]\n          });\n\n          socket.transport.on(\"pollComplete\", msg => {\n            socket.close();\n          });\n\n          engine.on(\"connection\", conn => {\n            let err;\n            conn.send(\"a\");\n            conn.send(\"b\", transport => {\n              err = new Error(\"Test invalidation\");\n            });\n            conn.on(\"close\", reason => {\n              done(err);\n            });\n          });\n        });\n      });\n    });\n\n    describe(\"pre-encoded content\", () => {\n      it(\"should use the pre-encoded content\", done => {\n        engine = listen(port => {\n          client = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n            transports: [\"websocket\"]\n          });\n\n          engine.on(\"connection\", conn => {\n            conn.send(\"test\", {\n              wsPreEncoded: \"4test pre-encoded\"\n            });\n          });\n\n          client.on(\"message\", msg => {\n            expect(msg).to.be(\"test pre-encoded\");\n            done();\n          });\n        });\n      });\n    });\n  });\n\n  describe(\"packet\", () => {\n    it(\"should emit when socket receives packet\", done => {\n      const engine = listen({ allowUpgrades: false }, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n        engine.on(\"connection\", conn => {\n          conn.on(\"packet\", packet => {\n            expect(packet.type).to.be(\"message\");\n            expect(packet.data).to.be(\"a\");\n            done();\n          });\n        });\n        socket.on(\"open\", () => {\n          socket.send(\"a\");\n        });\n      });\n    });\n\n    it(\"should emit when receives pong\", done => {\n      const engine = listen({ allowUpgrades: false, pingInterval: 4 }, port => {\n        eioc(\"ws://localhost:%d\".s(port));\n        engine.on(\"connection\", conn => {\n          conn.on(\"packet\", packet => {\n            conn.close();\n            if (process.env.EIO_CLIENT === \"3\") {\n              expect(packet.type).to.be(\"ping\");\n            } else {\n              expect(packet.type).to.be(\"pong\");\n            }\n            done();\n          });\n        });\n      });\n    });\n  });\n\n  describe(\"packetCreate\", () => {\n    it(\"should emit before socket send message\", done => {\n      const engine = listen({ allowUpgrades: false }, port => {\n        eioc(\"ws://localhost:%d\".s(port));\n        engine.on(\"connection\", conn => {\n          conn.on(\"packetCreate\", packet => {\n            expect(packet.type).to.be(\"message\");\n            expect(packet.data).to.be(\"a\");\n            done();\n          });\n          conn.send(\"a\");\n        });\n      });\n    });\n\n    it(\"should emit before send pong\", done => {\n      const engine = listen({ allowUpgrades: false, pingInterval: 4 }, port => {\n        eioc(\"ws://localhost:%d\".s(port));\n        engine.on(\"connection\", conn => {\n          conn.on(\"packetCreate\", packet => {\n            conn.close();\n            if (process.env.EIO_CLIENT === \"3\") {\n              expect(packet.type).to.be(\"pong\");\n            } else {\n              expect(packet.type).to.be(\"ping\");\n            }\n            done();\n          });\n        });\n      });\n    });\n  });\n\n  describe(\"upgrade\", () => {\n    it(\"should upgrade\", done => {\n      const engine = listen(port => {\n        // it takes both to send 50 to verify\n        let ready = 2;\n        let closed = 2;\n\n        function finish() {\n          setTimeout(() => {\n            socket.close();\n          }, 10);\n        }\n\n        // server\n        engine.on(\"connection\", conn => {\n          let lastSent = 0;\n          let lastReceived = 0;\n          let upgraded = false;\n          const interval = setInterval(() => {\n            lastSent++;\n            conn.send(lastSent);\n            if (50 === lastSent) {\n              clearInterval(interval);\n              --ready || finish();\n            }\n          }, 2);\n\n          expect(conn.request._query.transport).to.be(\"polling\");\n\n          conn.on(\"message\", msg => {\n            expect(conn.request._query).to.be.an(\"object\");\n            lastReceived++;\n            expect(msg).to.eql(lastReceived);\n          });\n\n          conn.on(\"upgrade\", to => {\n            expect(conn.request._query.transport).to.be(\"polling\");\n            upgraded = true;\n            expect(to.name).to.be(\"websocket\");\n            expect(conn.transport.name).to.be(\"websocket\");\n          });\n\n          conn.on(\"close\", reason => {\n            expect(reason).to.be(\"transport close\");\n            expect(lastSent).to.be(50);\n            expect(lastReceived).to.be(50);\n            expect(upgraded).to.be(true);\n            --closed || done();\n          });\n        });\n\n        // client\n        var socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n        socket.on(\"open\", () => {\n          let lastSent = 0;\n          let lastReceived = 0;\n          let upgrades = 0;\n          const interval = setInterval(() => {\n            lastSent++;\n            socket.send(lastSent);\n            if (50 === lastSent) {\n              clearInterval(interval);\n              --ready || finish();\n            }\n          }, 2);\n          socket.on(\"upgrading\", to => {\n            // we want to make sure for the sake of this test that we have a buffer\n            expect(to.name).to.equal(\"websocket\");\n            upgrades++;\n\n            // force send a few packets to ensure we test buffer transfer\n            lastSent++;\n            socket.send(lastSent);\n            lastSent++;\n            socket.send(lastSent);\n\n            expect(socket.writeBuffer).to.not.be.empty();\n          });\n          socket.on(\"upgrade\", to => {\n            expect(to.name).to.equal(\"websocket\");\n            upgrades++;\n          });\n          socket.on(\"message\", msg => {\n            lastReceived++;\n            expect(lastReceived).to.eql(msg);\n          });\n          socket.on(\"close\", reason => {\n            expect(reason).to.be(\"forced close\");\n            expect(lastSent).to.be(50);\n            expect(upgrades).to.be(2);\n            --closed || done();\n          });\n        });\n      });\n\n      // attach another engine to make sure it doesn't break upgrades\n      eio.attach(engine.httpServer, { path: \"/foo\" });\n    });\n  });\n\n  describe(\"http compression\", () => {\n    function getSidFromResponse(res) {\n      const c = cookieMod.parse(res.headers[\"set-cookie\"][0]);\n      return c[Object.keys(c)[0]];\n    }\n\n    it(\"should compress by default\", done => {\n      const engine = listen({ cookie: true, transports: [\"polling\"] }, port => {\n        engine.on(\"connection\", conn => {\n          const buf = Buffer.allocUnsafe(1024);\n          for (let i = 0; i < buf.length; i++) buf[i] = i % 0xff;\n          conn.send(buf);\n        });\n\n        http.get(\n          {\n            port: port,\n            path: \"/engine.io/default/?transport=polling\"\n          },\n          res => {\n            const sid = getSidFromResponse(res);\n            http.get(\n              {\n                port: port,\n                path: \"/engine.io/default/?transport=polling&sid=\" + sid,\n                headers: { \"Accept-Encoding\": \"gzip, deflate\" }\n              },\n              res => {\n                expect(res.headers[\"content-encoding\"]).to.equal(\"gzip\");\n                res\n                  .pipe(zlib.createGunzip())\n                  .on(\"error\", done)\n                  .on(\"end\", done)\n                  .resume();\n              }\n            );\n          }\n        );\n      });\n    });\n\n    it(\"should compress using deflate\", done => {\n      const engine = listen({ cookie: true, transports: [\"polling\"] }, port => {\n        engine.on(\"connection\", conn => {\n          const buf = Buffer.allocUnsafe(1024);\n          for (let i = 0; i < buf.length; i++) buf[i] = i % 0xff;\n          conn.send(buf);\n        });\n\n        http.get(\n          {\n            port: port,\n            path: \"/engine.io/default/?transport=polling\"\n          },\n          res => {\n            const sid = getSidFromResponse(res);\n            http.get(\n              {\n                port: port,\n                path: \"/engine.io/default/?transport=polling&sid=\" + sid,\n                headers: { \"Accept-Encoding\": \"deflate\" }\n              },\n              res => {\n                expect(res.headers[\"content-encoding\"]).to.equal(\"deflate\");\n                res\n                  .pipe(zlib.createDeflate())\n                  .on(\"error\", done)\n                  .on(\"end\", done)\n                  .resume();\n              }\n            );\n          }\n        );\n      });\n    });\n\n    it(\"should set threshold\", done => {\n      const engine = listen(\n        {\n          cookie: true,\n          transports: [\"polling\"],\n          httpCompression: { threshold: 0 }\n        },\n        port => {\n          engine.on(\"connection\", conn => {\n            const buf = Buffer.allocUnsafe(10);\n            for (let i = 0; i < buf.length; i++) buf[i] = i % 0xff;\n            conn.send(buf);\n          });\n\n          http.get(\n            {\n              port: port,\n              path: \"/engine.io/default/?transport=polling\"\n            },\n            res => {\n              const sid = getSidFromResponse(res);\n              http.get(\n                {\n                  port: port,\n                  path: \"/engine.io/default/?transport=polling&sid=\" + sid,\n                  headers: { \"Accept-Encoding\": \"gzip, deflate\" }\n                },\n                res => {\n                  expect(res.headers[\"content-encoding\"]).to.equal(\"gzip\");\n                  done();\n                }\n              );\n            }\n          );\n        }\n      );\n    });\n\n    it(\"should disable compression\", done => {\n      const engine = listen(\n        { cookie: true, transports: [\"polling\"], httpCompression: false },\n        port => {\n          engine.on(\"connection\", conn => {\n            const buf = Buffer.allocUnsafe(1024);\n            for (let i = 0; i < buf.length; i++) buf[i] = i % 0xff;\n            conn.send(buf);\n          });\n\n          http.get(\n            {\n              port: port,\n              path: \"/engine.io/default/?transport=polling\"\n            },\n            res => {\n              const sid = getSidFromResponse(res);\n              http.get(\n                {\n                  port: port,\n                  path: \"/engine.io/default/?transport=polling&sid=\" + sid,\n                  headers: { \"Accept-Encoding\": \"gzip, deflate\" }\n                },\n                res => {\n                  expect(res.headers[\"content-encoding\"]).to.be(undefined);\n                  done();\n                }\n              );\n            }\n          );\n        }\n      );\n    });\n\n    it(\"should disable compression per message\", done => {\n      const engine = listen({ cookie: true, transports: [\"polling\"] }, port => {\n        engine.on(\"connection\", conn => {\n          const buf = Buffer.allocUnsafe(1024);\n          for (let i = 0; i < buf.length; i++) buf[i] = i % 0xff;\n          conn.send(buf, { compress: false });\n        });\n\n        http.get(\n          {\n            port: port,\n            path: \"/engine.io/default/?transport=polling\"\n          },\n          res => {\n            const sid = getSidFromResponse(res);\n            http.get(\n              {\n                port: port,\n                path: \"/engine.io/default/?transport=polling&sid=\" + sid,\n                headers: { \"Accept-Encoding\": \"gzip, deflate\" }\n              },\n              res => {\n                expect(res.headers[\"content-encoding\"]).to.be(undefined);\n                done();\n              }\n            );\n          }\n        );\n      });\n    });\n\n    it(\"should not compress when the byte size is below threshold\", done => {\n      const engine = listen({ cookie: true, transports: [\"polling\"] }, port => {\n        engine.on(\"connection\", conn => {\n          const buf = Buffer.allocUnsafe(100);\n          for (let i = 0; i < buf.length; i++) buf[i] = i % 0xff;\n          conn.send(buf);\n        });\n\n        http.get(\n          {\n            port: port,\n            path: \"/engine.io/default/?transport=polling\"\n          },\n          res => {\n            const sid = getSidFromResponse(res);\n            http.get(\n              {\n                port: port,\n                path: \"/engine.io/default/?transport=polling&sid=\" + sid,\n                headers: { \"Accept-Encoding\": \"gzip, deflate\" }\n              },\n              res => {\n                expect(res.headers[\"content-encoding\"]).to.be(undefined);\n                done();\n              }\n            );\n          }\n        );\n      });\n    });\n  });\n\n  describe(\"permessage-deflate\", () => {\n    it(\"should set threshold\", done => {\n      const engine = listen(\n        { transports: [\"websocket\"], perMessageDeflate: { threshold: 0 } },\n        port => {\n          engine.on(\"connection\", conn => {\n            const socket = conn.transport.socket;\n            const send = socket.send;\n            socket.send = (data, opts, callback) => {\n              socket.send = send;\n              socket.send(data, opts, callback);\n\n              expect(opts.compress).to.be(true);\n              conn.close();\n              done();\n            };\n\n            const buf = Buffer.allocUnsafe(100);\n            for (let i = 0; i < buf.length; i++) buf[i] = i % 0xff;\n            conn.send(buf, { compress: true });\n          });\n          eioc(\"http://localhost:%d\".s(port), { transports: [\"websocket\"] });\n        }\n      );\n    });\n\n    it(\"should not compress when the byte size is below threshold\", done => {\n      const engine = listen(\n        { transports: [\"websocket\"], perMessageDeflate: true },\n        port => {\n          engine.on(\"connection\", conn => {\n            const socket = conn.transport.socket;\n            const send = socket.send;\n            socket.send = (data, opts, callback) => {\n              socket.send = send;\n              socket.send(data, opts, callback);\n\n              expect(opts.compress).to.be(false);\n              conn.close();\n              done();\n            };\n\n            const buf = Buffer.allocUnsafe(100);\n            for (let i = 0; i < buf.length; i++) buf[i] = i % 0xff;\n            conn.send(buf, { compress: true });\n          });\n          eioc(\"http://localhost:%d\".s(port), { transports: [\"websocket\"] });\n        }\n      );\n    });\n  });\n\n  describe(\"extraHeaders\", function() {\n    this.timeout(5000);\n\n    const headers = {\n      \"x-custom-header-for-my-project\": \"my-secret-access-token\",\n      cookie:\n        \"user_session=NI2JlCKF90aE0sJZD9ZzujtdsUqNYSBYxzlTsvdSUe35ZzdtVRGqYFr0kdGxbfc5gUOkR9RGp20GVKza; path=/; expires=Tue, 07-Apr-2015 18:18:08 GMT; secure; HttpOnly\"\n    };\n\n    function testForTransport(transport, done) {\n      const engine = listen(port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n          extraHeaders: headers,\n          transports: [transport]\n        });\n        engine.on(\"connection\", conn => {\n          for (let h in headers) {\n            expect(conn.request.headers[h]).to.equal(headers[h]);\n          }\n          done();\n        });\n        socket.on(\"open\", () => {});\n      });\n    }\n\n    it(\"should arrive from client to server via WebSockets\", done => {\n      testForTransport(\"websocket\", done);\n    });\n\n    it(\"should arrive from client to server via XMLHttpRequest\", done => {\n      testForTransport(\"polling\", done);\n    });\n  });\n\n  describe(\"response headers\", () => {\n    function testForHeaders(headers, done) {\n      const engine = listen(port => {\n        engine.on(\"connection\", conn => {\n          conn.transport.once(\"headers\", headers => {\n            expect(headers[\"X-XSS-Protection\"]).to.be(\"0\");\n            conn.close();\n            done();\n          });\n          conn.send(\"hi\");\n        });\n        eioc(\"ws://localhost:%d\".s(port), {\n          extraHeaders: headers,\n          transports: [\"polling\"]\n        });\n      });\n    }\n\n    it(\"should contain X-XSS-Protection: 0 for IE8\", done => {\n      const headers = {\n        \"user-agent\":\n          \"Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; Tablet PC 2.0)\"\n      };\n      testForHeaders(headers, done);\n    });\n\n    it(\"should contain X-XSS-Protection: 0 for IE11\", done => {\n      const headers = {\n        \"user-agent\":\n          \"Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko\"\n      };\n      testForHeaders(headers, done);\n    });\n\n    it(\"should emit a 'initial_headers' event (polling)\", done => {\n      const partialDone = createPartialDone(done, 2);\n\n      engine = listen({ cookie: true }, port => {\n        engine.on(\"initial_headers\", (headers, req) => {\n          expect(req.method).to.be(\"GET\");\n          headers[\"test\"] = \"123\";\n          headers[\"set-cookie\"] = \"mycookie=456\";\n          partialDone();\n        });\n\n        request\n          .get(\"http://localhost:%d/engine.io/\".s(port))\n          .query({ transport: \"polling\" })\n          .end((err, res) => {\n            expect(err).to.be(null);\n            expect(res.status).to.be(200);\n            expect(res.headers[\"test\"]).to.be(\"123\");\n            expect(res.headers[\"set-cookie\"].length).to.be(2);\n            expect(res.headers[\"set-cookie\"][1]).to.be(\"mycookie=456\");\n\n            const sid = JSON.parse(res.text.substring(4)).sid;\n\n            request\n              .post(\"http://localhost:%d/engine.io/\".s(port))\n              .query({ transport: \"polling\", sid })\n              .send(\"1:6\")\n              .end((err, res) => {\n                expect(err).to.be(null);\n                expect(res.status).to.be(200);\n                expect(res.headers[\"test\"]).to.be(undefined);\n                expect(res.headers[\"set-cookie\"]).to.be(undefined);\n                partialDone();\n              });\n          });\n      });\n    });\n\n    it(\"should emit a 'headers' event (polling)\", done => {\n      const partialDone = createPartialDone(done, 3);\n\n      engine = listen({ cookie: true }, port => {\n        engine.on(\"headers\", headers => {\n          headers[\"test\"] = \"123\";\n          headers[\"set-cookie\"] = \"mycookie=456\";\n          partialDone();\n        });\n\n        request\n          .get(\"http://localhost:%d/engine.io/\".s(port))\n          .query({ transport: \"polling\" })\n          .end((err, res) => {\n            expect(err).to.be(null);\n            expect(res.status).to.be(200);\n            expect(res.headers[\"test\"]).to.be(\"123\");\n            expect(res.headers[\"set-cookie\"].length).to.be(2);\n            expect(res.headers[\"set-cookie\"][1]).to.be(\"mycookie=456\");\n\n            const sid = JSON.parse(res.text.substring(4)).sid;\n\n            request\n              .post(\"http://localhost:%d/engine.io/\".s(port))\n              .query({ transport: \"polling\", sid })\n              .send(\"1:6\")\n              .end((err, res) => {\n                expect(err).to.be(null);\n                expect(res.status).to.be(200);\n                expect(res.headers[\"set-cookie\"].length).to.be(1);\n                expect(res.headers[\"set-cookie\"][0]).to.be(\"mycookie=456\");\n                partialDone();\n              });\n          });\n      });\n    });\n\n    it(\"should emit a 'initial_headers' event (websocket)\", function(done) {\n      if (process.env.EIO_WS_ENGINE === \"eiows\") {\n        this.skip();\n      }\n      const partialDone = createPartialDone(done, 2);\n\n      engine = listen({ cookie: true }, port => {\n        engine.on(\"initial_headers\", (headers, req) => {\n          expect(req.method).to.be(\"GET\");\n          headers[\"test\"] = \"123\";\n          headers[\"set-cookie\"] = \"mycookie=456\";\n          partialDone();\n        });\n\n        client = eioc(\"ws://localhost:%d\".s(port), {\n          transports: [\"websocket\"]\n        });\n\n        client.transport.ws.on(\"upgrade\", res => {\n          expect(res.headers[\"test\"]).to.be(\"123\");\n          expect(res.headers[\"set-cookie\"].length).to.be(1);\n          expect(res.headers[\"set-cookie\"][0]).to.be(\"mycookie=456\");\n          partialDone();\n        });\n      });\n    });\n\n    it(\"should emit a single 'initial_headers' event per connection\", done => {\n      const partialDone = createPartialDone(done, 2);\n\n      engine = listen(port => {\n        engine.on(\"initial_headers\", () => {\n          partialDone();\n        });\n\n        client = eioc(\"ws://localhost:%d\".s(port));\n\n        client.on(\"upgrade\", () => {\n          partialDone();\n        });\n      });\n    });\n\n    it(\"should emit several 'headers' events per connection\", function(done) {\n      if (process.env.EIO_WS_ENGINE === \"eiows\") {\n        this.skip();\n      }\n      const partialDone = createPartialDone(done, 4);\n\n      engine = listen(port => {\n        engine.on(\"headers\", () => {\n          partialDone();\n        });\n\n        client = eioc(\"ws://localhost:%d\".s(port));\n\n        client.on(\"upgrade\", () => {\n          partialDone();\n        });\n      });\n    });\n  });\n\n  describe(\"cors\", () => {\n    it(\"should allow CORS from the current origin (preflight request)\", done => {\n      listen(\n        { cors: { origin: true, headers: [\"my-header\"], credentials: true } },\n        port => {\n          request\n            .options(\"http://localhost:%d/engine.io/default/\".s(port))\n            .set(\"Origin\", \"http://engine.io\")\n            .query({ transport: \"polling\" })\n            .end((err, res) => {\n              expect(err).to.be(null);\n              expect(res.status).to.be(204);\n              expect(res.body).to.be.empty();\n              expect(res.header[\"access-control-allow-origin\"]).to.be(\n                \"http://engine.io\"\n              );\n              expect(res.header[\"access-control-allow-methods\"]).to.be(\n                \"GET,HEAD,PUT,PATCH,POST,DELETE\"\n              );\n              expect(res.header[\"access-control-allow-headers\"]).to.be(\n                \"my-header\"\n              );\n              expect(res.header[\"access-control-allow-credentials\"]).to.be(\n                \"true\"\n              );\n              done();\n            });\n        }\n      );\n    });\n\n    it(\"should allow CORS from the current origin (actual request)\", done => {\n      listen(\n        { cors: { origin: true, headers: [\"my-header\"], credentials: true } },\n        port => {\n          request\n            .get(\"http://localhost:%d/engine.io/default/\".s(port))\n            .set(\"Origin\", \"http://engine.io\")\n            .query({ transport: \"polling\" })\n            .end((err, res) => {\n              expect(err).to.be(null);\n              expect(res.status).to.be(200);\n              expect(res.body).to.be.empty();\n              expect(res.header[\"access-control-allow-origin\"]).to.be(\n                \"http://engine.io\"\n              );\n              expect(res.header[\"access-control-allow-methods\"]).to.be(\n                undefined\n              );\n              expect(res.header[\"access-control-allow-headers\"]).to.be(\n                undefined\n              );\n              expect(res.header[\"access-control-allow-credentials\"]).to.be(\n                \"true\"\n              );\n              done();\n            });\n        }\n      );\n    });\n\n    it(\"should disallow CORS from a bad origin\", done => {\n      listen(\n        {\n          cors: {\n            origin: [\"http://good-domain.com\"]\n          }\n        },\n        port => {\n          request\n            .options(\"http://localhost:%d/engine.io/default/\".s(port))\n            .set(\"Origin\", \"http://bad-domain.com\")\n            .query({ transport: \"polling\" })\n            .end((err, res) => {\n              expect(err).to.be(null);\n              expect(res.status).to.be(204);\n              expect(res.body).to.be.empty();\n              expect(res.header[\"access-control-allow-origin\"]).to.be(\n                undefined\n              );\n              expect(res.header[\"access-control-allow-credentials\"]).to.be(\n                undefined\n              );\n              done();\n            });\n        }\n      );\n    });\n\n    it(\"should forward the configuration to the cors module\", done => {\n      listen(\n        {\n          cors: {\n            origin: \"http://good-domain.com\",\n            methods: [\"GET\", \"PUT\", \"POST\"],\n            allowedHeaders: [\"my-header\"],\n            exposedHeaders: [\"my-exposed-header\"],\n            credentials: true,\n            maxAge: 123,\n            optionsSuccessStatus: 200\n          }\n        },\n        port => {\n          request\n            .options(\"http://localhost:%d/engine.io/default/\".s(port))\n            .set(\"Origin\", \"http://good-domain.com\")\n            .query({ transport: \"polling\" })\n            .end((err, res) => {\n              expect(err).to.be(null);\n              expect(res.status).to.be(200);\n              expect(res.body).to.be.empty();\n              expect(res.header[\"access-control-allow-origin\"]).to.be(\n                \"http://good-domain.com\"\n              );\n              expect(res.header[\"access-control-allow-methods\"]).to.be(\n                \"GET,PUT,POST\"\n              );\n              expect(res.header[\"access-control-allow-headers\"]).to.be(\n                \"my-header\"\n              );\n              expect(res.header[\"access-control-expose-headers\"]).to.be(\n                \"my-exposed-header\"\n              );\n              expect(res.header[\"access-control-allow-credentials\"]).to.be(\n                \"true\"\n              );\n              expect(res.header[\"access-control-max-age\"]).to.be(\"123\");\n              done();\n            });\n        }\n      );\n    });\n  });\n\n  describe(\"wsEngine option\", () => {\n    it(\"should allow loading of other websocket server implementation like eiows\", done => {\n      const engine = listen(\n        { allowUpgrades: false, wsEngine: require(\"eiows\").Server },\n        port => {\n          expect(engine.ws instanceof require(\"eiows\").Server).to.be.ok();\n          const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n          engine.on(\"connection\", conn => {\n            conn.send(\"a\");\n          });\n          socket.on(\"open\", () => {\n            socket.on(\"message\", msg => {\n              expect(msg).to.be(\"a\");\n              done();\n            });\n          });\n        }\n      );\n    });\n  });\n\n  describe(\"remoteAddress\", () => {\n    it(\"should be defined (polling)\", done => {\n      const engine = listen({ transports: [\"polling\"] }, port => {\n        eioc(\"ws://localhost:%d\".s(port), { transports: [\"polling\"] });\n        engine.on(\"connection\", socket => {\n          expect(socket.remoteAddress).to.be(\"::ffff:127.0.0.1\");\n          done();\n        });\n      });\n    });\n\n    it(\"should be defined (ws)\", done => {\n      const engine = listen({ transports: [\"websocket\"] }, port => {\n        eioc(\"ws://localhost:%d\".s(port), { transports: [\"websocket\"] });\n        engine.on(\"connection\", socket => {\n          expect(socket.remoteAddress).to.be(\"::ffff:127.0.0.1\");\n          done();\n        });\n      });\n    });\n  });\n});\n"], "fixing_code": ["const qs = require(\"querystring\");\nconst parse = require(\"url\").parse;\nconst base64id = require(\"base64id\");\nconst transports = require(\"./transports\");\nconst EventEmitter = require(\"events\").EventEmitter;\nconst Socket = require(\"./socket\");\nconst debug = require(\"debug\")(\"engine\");\nconst cookieMod = require(\"cookie\");\n\nconst DEFAULT_WS_ENGINE = require(\"ws\").Server;\n\nclass Server extends EventEmitter {\n  /**\n   * Server constructor.\n   *\n   * @param {Object} options\n   * @api public\n   */\n  constructor(opts = {}) {\n    super();\n\n    this.clients = {};\n    this.clientsCount = 0;\n\n    this.opts = Object.assign(\n      {\n        wsEngine: DEFAULT_WS_ENGINE,\n        pingTimeout: 20000,\n        pingInterval: 25000,\n        upgradeTimeout: 10000,\n        maxHttpBufferSize: 1e6,\n        transports: Object.keys(transports),\n        allowUpgrades: true,\n        httpCompression: {\n          threshold: 1024\n        },\n        cors: false,\n        allowEIO3: false\n      },\n      opts\n    );\n\n    if (opts.cookie) {\n      this.opts.cookie = Object.assign(\n        {\n          name: \"io\",\n          path: \"/\",\n          httpOnly: opts.cookie.path !== false,\n          sameSite: \"lax\"\n        },\n        opts.cookie\n      );\n    }\n\n    if (this.opts.cors) {\n      this.corsMiddleware = require(\"cors\")(this.opts.cors);\n    }\n\n    if (opts.perMessageDeflate) {\n      this.opts.perMessageDeflate = Object.assign(\n        {\n          threshold: 1024\n        },\n        opts.perMessageDeflate\n      );\n    }\n\n    this.init();\n  }\n\n  /**\n   * Initialize websocket server\n   *\n   * @api private\n   */\n  init() {\n    if (!~this.opts.transports.indexOf(\"websocket\")) return;\n\n    if (this.ws) this.ws.close();\n\n    this.ws = new this.opts.wsEngine({\n      noServer: true,\n      clientTracking: false,\n      perMessageDeflate: this.opts.perMessageDeflate,\n      maxPayload: this.opts.maxHttpBufferSize\n    });\n\n    if (typeof this.ws.on === \"function\") {\n      this.ws.on(\"headers\", (headersArray, req) => {\n        // note: 'ws' uses an array of headers, while Engine.IO uses an object (response.writeHead() accepts both formats)\n        // we could also try to parse the array and then sync the values, but that will be error-prone\n        const additionalHeaders = {};\n\n        const isInitialRequest = !req._query.sid;\n        if (isInitialRequest) {\n          this.emit(\"initial_headers\", additionalHeaders, req);\n        }\n\n        this.emit(\"headers\", additionalHeaders, req);\n\n        Object.keys(additionalHeaders).forEach(key => {\n          headersArray.push(`${key}: ${additionalHeaders[key]}`);\n        });\n      });\n    }\n  }\n\n  /**\n   * Returns a list of available transports for upgrade given a certain transport.\n   *\n   * @return {Array}\n   * @api public\n   */\n  upgrades(transport) {\n    if (!this.opts.allowUpgrades) return [];\n    return transports[transport].upgradesTo || [];\n  }\n\n  /**\n   * Verifies a request.\n   *\n   * @param {http.IncomingMessage}\n   * @return {Boolean} whether the request is valid\n   * @api private\n   */\n  verify(req, upgrade, fn) {\n    // transport check\n    const transport = req._query.transport;\n    if (!~this.opts.transports.indexOf(transport)) {\n      debug('unknown transport \"%s\"', transport);\n      return fn(Server.errors.UNKNOWN_TRANSPORT, { transport });\n    }\n\n    // 'Origin' header check\n    const isOriginInvalid = checkInvalidHeaderChar(req.headers.origin);\n    if (isOriginInvalid) {\n      const origin = req.headers.origin;\n      req.headers.origin = null;\n      debug(\"origin header invalid\");\n      return fn(Server.errors.BAD_REQUEST, {\n        name: \"INVALID_ORIGIN\",\n        origin\n      });\n    }\n\n    // sid check\n    const sid = req._query.sid;\n    if (sid) {\n      if (!this.clients.hasOwnProperty(sid)) {\n        debug('unknown sid \"%s\"', sid);\n        return fn(Server.errors.UNKNOWN_SID, {\n          sid\n        });\n      }\n      const previousTransport = this.clients[sid].transport.name;\n      if (!upgrade && previousTransport !== transport) {\n        debug(\"bad request: unexpected transport without upgrade\");\n        return fn(Server.errors.BAD_REQUEST, {\n          name: \"TRANSPORT_MISMATCH\",\n          transport,\n          previousTransport\n        });\n      }\n    } else {\n      // handshake is GET only\n      if (\"GET\" !== req.method) {\n        return fn(Server.errors.BAD_HANDSHAKE_METHOD, {\n          method: req.method\n        });\n      }\n\n      if (!this.opts.allowRequest) return fn();\n\n      return this.opts.allowRequest(req, (message, success) => {\n        if (!success) {\n          return fn(Server.errors.FORBIDDEN, {\n            message\n          });\n        }\n        fn();\n      });\n    }\n\n    fn();\n  }\n\n  /**\n   * Prepares a request by processing the query string.\n   *\n   * @api private\n   */\n  prepare(req) {\n    // try to leverage pre-existing `req._query` (e.g: from connect)\n    if (!req._query) {\n      req._query = ~req.url.indexOf(\"?\") ? qs.parse(parse(req.url).query) : {};\n    }\n  }\n\n  /**\n   * Closes all clients.\n   *\n   * @api public\n   */\n  close() {\n    debug(\"closing all open clients\");\n    for (let i in this.clients) {\n      if (this.clients.hasOwnProperty(i)) {\n        this.clients[i].close(true);\n      }\n    }\n    if (this.ws) {\n      debug(\"closing webSocketServer\");\n      this.ws.close();\n      // don't delete this.ws because it can be used again if the http server starts listening again\n    }\n    return this;\n  }\n\n  /**\n   * Handles an Engine.IO HTTP request.\n   *\n   * @param {http.IncomingMessage} request\n   * @param {http.ServerResponse|http.OutgoingMessage} response\n   * @api public\n   */\n  handleRequest(req, res) {\n    debug('handling \"%s\" http request \"%s\"', req.method, req.url);\n    this.prepare(req);\n    req.res = res;\n\n    const callback = (errorCode, errorContext) => {\n      if (errorCode !== undefined) {\n        this.emit(\"connection_error\", {\n          req,\n          code: errorCode,\n          message: Server.errorMessages[errorCode],\n          context: errorContext\n        });\n        abortRequest(res, errorCode, errorContext);\n        return;\n      }\n\n      if (req._query.sid) {\n        debug(\"setting new request for existing client\");\n        this.clients[req._query.sid].transport.onRequest(req);\n      } else {\n        const closeConnection = (errorCode, errorContext) =>\n          abortRequest(res, errorCode, errorContext);\n        this.handshake(req._query.transport, req, closeConnection);\n      }\n    };\n\n    if (this.corsMiddleware) {\n      this.corsMiddleware.call(null, req, res, () => {\n        this.verify(req, false, callback);\n      });\n    } else {\n      this.verify(req, false, callback);\n    }\n  }\n\n  /**\n   * generate a socket id.\n   * Overwrite this method to generate your custom socket id\n   *\n   * @param {Object} request object\n   * @api public\n   */\n  generateId(req) {\n    return base64id.generateId();\n  }\n\n  /**\n   * Handshakes a new client.\n   *\n   * @param {String} transport name\n   * @param {Object} request object\n   * @param {Function} closeConnection\n   *\n   * @api private\n   */\n  async handshake(transportName, req, closeConnection) {\n    const protocol = req._query.EIO === \"4\" ? 4 : 3; // 3rd revision by default\n    if (protocol === 3 && !this.opts.allowEIO3) {\n      debug(\"unsupported protocol version\");\n      this.emit(\"connection_error\", {\n        req,\n        code: Server.errors.UNSUPPORTED_PROTOCOL_VERSION,\n        message:\n          Server.errorMessages[Server.errors.UNSUPPORTED_PROTOCOL_VERSION],\n        context: {\n          protocol\n        }\n      });\n      closeConnection(Server.errors.UNSUPPORTED_PROTOCOL_VERSION);\n      return;\n    }\n\n    let id;\n    try {\n      id = await this.generateId(req);\n    } catch (e) {\n      debug(\"error while generating an id\");\n      this.emit(\"connection_error\", {\n        req,\n        code: Server.errors.BAD_REQUEST,\n        message: Server.errorMessages[Server.errors.BAD_REQUEST],\n        context: {\n          name: \"ID_GENERATION_ERROR\",\n          error: e\n        }\n      });\n      closeConnection(Server.errors.BAD_REQUEST);\n      return;\n    }\n\n    debug('handshaking client \"%s\"', id);\n\n    try {\n      var transport = new transports[transportName](req);\n      if (\"polling\" === transportName) {\n        transport.maxHttpBufferSize = this.opts.maxHttpBufferSize;\n        transport.httpCompression = this.opts.httpCompression;\n      } else if (\"websocket\" === transportName) {\n        transport.perMessageDeflate = this.opts.perMessageDeflate;\n      }\n\n      if (req._query && req._query.b64) {\n        transport.supportsBinary = false;\n      } else {\n        transport.supportsBinary = true;\n      }\n    } catch (e) {\n      debug('error handshaking to transport \"%s\"', transportName);\n      this.emit(\"connection_error\", {\n        req,\n        code: Server.errors.BAD_REQUEST,\n        message: Server.errorMessages[Server.errors.BAD_REQUEST],\n        context: {\n          name: \"TRANSPORT_HANDSHAKE_ERROR\",\n          error: e\n        }\n      });\n      closeConnection(Server.errors.BAD_REQUEST);\n      return;\n    }\n    const socket = new Socket(id, this, transport, req, protocol);\n\n    transport.on(\"headers\", (headers, req) => {\n      const isInitialRequest = !req._query.sid;\n\n      if (isInitialRequest) {\n        if (this.opts.cookie) {\n          headers[\"Set-Cookie\"] = [\n            cookieMod.serialize(this.opts.cookie.name, id, this.opts.cookie)\n          ];\n        }\n        this.emit(\"initial_headers\", headers, req);\n      }\n      this.emit(\"headers\", headers, req);\n    });\n\n    transport.onRequest(req);\n\n    this.clients[id] = socket;\n    this.clientsCount++;\n\n    socket.once(\"close\", () => {\n      delete this.clients[id];\n      this.clientsCount--;\n    });\n\n    this.emit(\"connection\", socket);\n  }\n\n  /**\n   * Handles an Engine.IO HTTP Upgrade.\n   *\n   * @api public\n   */\n  handleUpgrade(req, socket, upgradeHead) {\n    this.prepare(req);\n\n    this.verify(req, true, (errorCode, errorContext) => {\n      if (errorCode) {\n        this.emit(\"connection_error\", {\n          req,\n          code: errorCode,\n          message: Server.errorMessages[errorCode],\n          context: errorContext\n        });\n        abortUpgrade(socket, errorCode, errorContext);\n        return;\n      }\n\n      const head = Buffer.from(upgradeHead); // eslint-disable-line node/no-deprecated-api\n      upgradeHead = null;\n\n      // delegate to ws\n      this.ws.handleUpgrade(req, socket, head, websocket => {\n        this.onWebSocket(req, socket, websocket);\n      });\n    });\n  }\n\n  /**\n   * Called upon a ws.io connection.\n   *\n   * @param {ws.Socket} websocket\n   * @api private\n   */\n  onWebSocket(req, socket, websocket) {\n    websocket.on(\"error\", onUpgradeError);\n\n    if (\n      transports[req._query.transport] !== undefined &&\n      !transports[req._query.transport].prototype.handlesUpgrades\n    ) {\n      debug(\"transport doesnt handle upgraded requests\");\n      websocket.close();\n      return;\n    }\n\n    // get client id\n    const id = req._query.sid;\n\n    // keep a reference to the ws.Socket\n    req.websocket = websocket;\n\n    if (id) {\n      const client = this.clients[id];\n      if (!client) {\n        debug(\"upgrade attempt for closed client\");\n        websocket.close();\n      } else if (client.upgrading) {\n        debug(\"transport has already been trying to upgrade\");\n        websocket.close();\n      } else if (client.upgraded) {\n        debug(\"transport had already been upgraded\");\n        websocket.close();\n      } else {\n        debug(\"upgrading existing transport\");\n\n        // transport error handling takes over\n        websocket.removeListener(\"error\", onUpgradeError);\n\n        const transport = new transports[req._query.transport](req);\n        if (req._query && req._query.b64) {\n          transport.supportsBinary = false;\n        } else {\n          transport.supportsBinary = true;\n        }\n        transport.perMessageDeflate = this.perMessageDeflate;\n        client.maybeUpgrade(transport);\n      }\n    } else {\n      const closeConnection = (errorCode, errorContext) =>\n        abortUpgrade(socket, errorCode, errorContext);\n      this.handshake(req._query.transport, req, closeConnection);\n    }\n\n    function onUpgradeError() {\n      debug(\"websocket error before upgrade\");\n      // websocket.close() not needed\n    }\n  }\n\n  /**\n   * Captures upgrade requests for a http.Server.\n   *\n   * @param {http.Server} server\n   * @param {Object} options\n   * @api public\n   */\n  attach(server, options = {}) {\n    let path = (options.path || \"/engine.io\").replace(/\\/$/, \"\");\n\n    const destroyUpgradeTimeout = options.destroyUpgradeTimeout || 1000;\n\n    // normalize path\n    path += \"/\";\n\n    function check(req) {\n      return path === req.url.substr(0, path.length);\n    }\n\n    // cache and clean up listeners\n    const listeners = server.listeners(\"request\").slice(0);\n    server.removeAllListeners(\"request\");\n    server.on(\"close\", this.close.bind(this));\n    server.on(\"listening\", this.init.bind(this));\n\n    // add request handler\n    server.on(\"request\", (req, res) => {\n      if (check(req)) {\n        debug('intercepting request for path \"%s\"', path);\n        this.handleRequest(req, res);\n      } else {\n        let i = 0;\n        const l = listeners.length;\n        for (; i < l; i++) {\n          listeners[i].call(server, req, res);\n        }\n      }\n    });\n\n    if (~this.opts.transports.indexOf(\"websocket\")) {\n      server.on(\"upgrade\", (req, socket, head) => {\n        if (check(req)) {\n          this.handleUpgrade(req, socket, head);\n        } else if (false !== options.destroyUpgrade) {\n          // default node behavior is to disconnect when no handlers\n          // but by adding a handler, we prevent that\n          // and if no eio thing handles the upgrade\n          // then the socket needs to die!\n          setTimeout(function() {\n            if (socket.writable && socket.bytesWritten <= 0) {\n              return socket.end();\n            }\n          }, destroyUpgradeTimeout);\n        }\n      });\n    }\n  }\n}\n\n/**\n * Protocol errors mappings.\n */\n\nServer.errors = {\n  UNKNOWN_TRANSPORT: 0,\n  UNKNOWN_SID: 1,\n  BAD_HANDSHAKE_METHOD: 2,\n  BAD_REQUEST: 3,\n  FORBIDDEN: 4,\n  UNSUPPORTED_PROTOCOL_VERSION: 5\n};\n\nServer.errorMessages = {\n  0: \"Transport unknown\",\n  1: \"Session ID unknown\",\n  2: \"Bad handshake method\",\n  3: \"Bad request\",\n  4: \"Forbidden\",\n  5: \"Unsupported protocol version\"\n};\n\n/**\n * Close the HTTP long-polling request\n *\n * @param res - the response object\n * @param errorCode - the error code\n * @param errorContext - additional error context\n *\n * @api private\n */\n\nfunction abortRequest(res, errorCode, errorContext) {\n  const statusCode = errorCode === Server.errors.FORBIDDEN ? 403 : 400;\n  const message =\n    errorContext && errorContext.message\n      ? errorContext.message\n      : Server.errorMessages[errorCode];\n\n  res.writeHead(statusCode, { \"Content-Type\": \"application/json\" });\n  res.end(\n    JSON.stringify({\n      code: errorCode,\n      message\n    })\n  );\n}\n\n/**\n * Close the WebSocket connection\n *\n * @param {net.Socket} socket\n * @param {string} errorCode - the error code\n * @param {object} errorContext - additional error context\n *\n * @api private\n */\n\nfunction abortUpgrade(socket, errorCode, errorContext = {}) {\n  socket.on(\"error\", () => {\n    debug(\"ignoring error from closed connection\");\n  });\n  if (socket.writable) {\n    const message = errorContext.message || Server.errorMessages[errorCode];\n    const length = Buffer.byteLength(message);\n    socket.write(\n      \"HTTP/1.1 400 Bad Request\\r\\n\" +\n        \"Connection: close\\r\\n\" +\n        \"Content-type: text/html\\r\\n\" +\n        \"Content-Length: \" +\n        length +\n        \"\\r\\n\" +\n        \"\\r\\n\" +\n        message\n    );\n  }\n  socket.destroy();\n}\n\nmodule.exports = Server;\n\n/* eslint-disable */\n\n/**\n * From https://github.com/nodejs/node/blob/v8.4.0/lib/_http_common.js#L303-L354\n *\n * True if val contains an invalid field-vchar\n *  field-value    = *( field-content / obs-fold )\n *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n *  field-vchar    = VCHAR / obs-text\n *\n * checkInvalidHeaderChar() is currently designed to be inlinable by v8,\n * so take care when making changes to the implementation so that the source\n * code size does not exceed v8's default max_inlined_source_size setting.\n **/\n// prettier-ignore\nconst validHdrChars = [\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, // 0 - 15\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 32 - 47\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 48 - 63\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 80 - 95\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, // 112 - 127\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 128 ...\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1  // ... 255\n]\n\nfunction checkInvalidHeaderChar(val) {\n  val += \"\";\n  if (val.length < 1) return false;\n  if (!validHdrChars[val.charCodeAt(0)]) {\n    debug('invalid header, index 0, char \"%s\"', val.charCodeAt(0));\n    return true;\n  }\n  if (val.length < 2) return false;\n  if (!validHdrChars[val.charCodeAt(1)]) {\n    debug('invalid header, index 1, char \"%s\"', val.charCodeAt(1));\n    return true;\n  }\n  if (val.length < 3) return false;\n  if (!validHdrChars[val.charCodeAt(2)]) {\n    debug('invalid header, index 2, char \"%s\"', val.charCodeAt(2));\n    return true;\n  }\n  if (val.length < 4) return false;\n  if (!validHdrChars[val.charCodeAt(3)]) {\n    debug('invalid header, index 3, char \"%s\"', val.charCodeAt(3));\n    return true;\n  }\n  for (let i = 4; i < val.length; ++i) {\n    if (!validHdrChars[val.charCodeAt(i)]) {\n      debug('invalid header, index \"%i\", char \"%s\"', i, val.charCodeAt(i));\n      return true;\n    }\n  }\n  return false;\n}\n", "/* eslint-disable standard/no-callback-literal */\n\nconst http = require(\"http\");\nconst https = require(\"https\");\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst exec = require(\"child_process\").exec;\nconst zlib = require(\"zlib\");\nconst eio = require(\"..\");\nconst { eioc, listen, createPartialDone } = require(\"./common\");\nconst expect = require(\"expect.js\");\nconst request = require(\"superagent\");\nconst cookieMod = require(\"cookie\");\n\n/**\n * Tests.\n */\n\ndescribe(\"server\", () => {\n  let engine, client;\n\n  afterEach(() => {\n    if (engine) {\n      engine.httpServer.close();\n    }\n    if (client) {\n      client.close();\n    }\n  });\n\n  describe(\"verification\", () => {\n    it(\"should disallow non-existent transports\", done => {\n      const partialDone = createPartialDone(done, 2);\n\n      engine = listen(port => {\n        engine.on(\"connection_error\", err => {\n          expect(err.req).to.be.an(http.IncomingMessage);\n          expect(err.code).to.be(0);\n          expect(err.message).to.be(\"Transport unknown\");\n          expect(err.context.transport).to.be(\"tobi\");\n          partialDone();\n        });\n\n        request\n          .get(\"http://localhost:%d/engine.io/default/\".s(port))\n          .query({ transport: \"tobi\" }) // no tobi transport - outrageous\n          .end((err, res) => {\n            expect(err).to.be.an(Error);\n            expect(res.status).to.be(400);\n            expect(res.body.code).to.be(0);\n            expect(res.body.message).to.be(\"Transport unknown\");\n            partialDone();\n          });\n      });\n    });\n\n    it(\"should disallow `constructor` as transports\", done => {\n      const partialDone = createPartialDone(done, 2);\n\n      // make sure we check for actual properties - not those present on every {}\n      engine = listen(port => {\n        engine.on(\"connection_error\", err => {\n          expect(err.req).to.be.an(http.IncomingMessage);\n          expect(err.code).to.be(0);\n          expect(err.message).to.be(\"Transport unknown\");\n          expect(err.context.transport).to.be(\"constructor\");\n          partialDone();\n        });\n\n        request\n          .get(\"http://localhost:%d/engine.io/default/\".s(port))\n          .set(\"Origin\", \"http://engine.io\")\n          .query({ transport: \"constructor\" })\n          .end((err, res) => {\n            expect(err).to.be.an(Error);\n            expect(res.status).to.be(400);\n            expect(res.body.code).to.be(0);\n            expect(res.body.message).to.be(\"Transport unknown\");\n            partialDone();\n          });\n      });\n    });\n\n    it(\"should disallow non-existent sids\", done => {\n      const partialDone = createPartialDone(done, 2);\n\n      engine = listen(port => {\n        engine.on(\"connection_error\", err => {\n          expect(err.req).to.be.an(http.IncomingMessage);\n          expect(err.code).to.be(1);\n          expect(err.message).to.be(\"Session ID unknown\");\n          expect(err.context.sid).to.be(\"test\");\n          partialDone();\n        });\n\n        request\n          .get(\"http://localhost:%d/engine.io/default/\".s(port))\n          .set(\"Origin\", \"http://engine.io\")\n          .query({ transport: \"polling\", sid: \"test\" })\n          .end((err, res) => {\n            expect(err).to.be.an(Error);\n            expect(res.status).to.be(400);\n            expect(res.body.code).to.be(1);\n            expect(res.body.message).to.be(\"Session ID unknown\");\n            partialDone();\n          });\n      });\n    });\n\n    it(\"should disallow requests that are rejected by `allowRequest`\", done => {\n      const partialDone = createPartialDone(done, 2);\n\n      engine = listen(\n        {\n          allowRequest: (req, fn) => {\n            fn(\"Thou shall not pass\", false);\n          }\n        },\n        port => {\n          engine.on(\"connection_error\", err => {\n            expect(err.req).to.be.an(http.IncomingMessage);\n            expect(err.code).to.be(4);\n            expect(err.message).to.be(\"Forbidden\");\n            expect(err.context.message).to.be(\"Thou shall not pass\");\n            partialDone();\n          });\n\n          request\n            .get(\"http://localhost:%d/engine.io/default/\".s(port))\n            .set(\"Origin\", \"http://engine.io\")\n            .query({ transport: \"polling\" })\n            .end((err, res) => {\n              expect(err).to.be.an(Error);\n              expect(res.status).to.be(403);\n              expect(res.body.code).to.be(4);\n              expect(res.body.message).to.be(\"Thou shall not pass\");\n              partialDone();\n            });\n        }\n      );\n    });\n\n    it(\"should disallow connection that are rejected by `allowRequest`\", done => {\n      listen(\n        {\n          allowRequest: (req, fn) => {\n            fn(null, false);\n          }\n        },\n        port => {\n          const client = eioc(\"ws://localhost:%d\".s(port), {\n            transports: [\"websocket\"]\n          });\n          client.on(\"error\", () => {\n            done();\n          });\n        }\n      );\n    });\n\n    it(\"should not throw when the client sends invalid data during the handshake (ws only)\", done => {\n      listen(port => {\n        // will throw \"RangeError: Invalid WebSocket frame: RSV2 and RSV3 must be clear\"\n        request\n          .get(`http://localhost:${port}/engine.io/`)\n          .set(\"connection\", \"upgrade\")\n          .set(\"upgrade\", \"websocket\")\n          .set(\"Sec-WebSocket-Version\", \"13\")\n          .set(\"Sec-WebSocket-Key\", \"DXR4dX615eRds8nRmlhqtw==\")\n          .query({ transport: \"websocket\", EIO: 4 })\n          .send(\"test\")\n          .end(() => {});\n\n        setTimeout(done, 50);\n      });\n    });\n\n    it(\"should not throw when the client sends invalid data during the handshake (upgrade)\", done => {\n      listen(port => {\n        request\n          .get(`http://localhost:${port}/engine.io/`)\n          .query({ transport: \"polling\", EIO: 4 })\n          .end((err, res) => {\n            const sid = JSON.parse(res.text.substring(1)).sid;\n\n            request\n              .get(`http://localhost:${port}/engine.io/`)\n              .set(\"connection\", \"upgrade\")\n              .set(\"upgrade\", \"websocket\")\n              .set(\"Sec-WebSocket-Version\", \"13\")\n              .set(\"Sec-WebSocket-Key\", \"DXR4dX615eRds8nRmlhqtw==\")\n              .query({ transport: \"websocket\", EIO: 4, sid })\n              .send(\"test\")\n              .end(() => {});\n\n            setTimeout(done, 50);\n          });\n      });\n    });\n  });\n\n  describe(\"handshake\", () => {\n    it(\"should send the io cookie\", done => {\n      listen({ cookie: true }, port => {\n        request\n          .get(\"http://localhost:%d/engine.io/default/\".s(port))\n          .query({ transport: \"polling\", b64: 1 })\n          .end((err, res) => {\n            expect(err).to.be(null);\n            // hack-obtain sid\n            const sid = res.text.match(/\"sid\":\"([^\"]+)\"/)[1];\n            expect(res.headers[\"set-cookie\"][0]).to.be(\n              `io=${sid}; Path=/; HttpOnly; SameSite=Lax`\n            );\n            done();\n          });\n      });\n    });\n\n    it(\"should send the io cookie custom name\", done => {\n      listen({ cookie: { name: \"woot\" } }, port => {\n        request\n          .get(\"http://localhost:%d/engine.io/default/\".s(port))\n          .query({ transport: \"polling\", b64: 1 })\n          .end((err, res) => {\n            expect(err).to.be(null);\n            const sid = res.text.match(/\"sid\":\"([^\"]+)\"/)[1];\n            expect(res.headers[\"set-cookie\"][0]).to.be(\n              `woot=${sid}; Path=/; HttpOnly; SameSite=Lax`\n            );\n            done();\n          });\n      });\n    });\n\n    it(\"should send the cookie with custom path\", done => {\n      listen({ cookie: { path: \"/custom\" } }, port => {\n        request\n          .get(\"http://localhost:%d/engine.io/default/\".s(port))\n          .query({ transport: \"polling\", b64: 1 })\n          .end((err, res) => {\n            expect(err).to.be(null);\n            const sid = res.text.match(/\"sid\":\"([^\"]+)\"/)[1];\n            expect(res.headers[\"set-cookie\"][0]).to.be(\n              `io=${sid}; Path=/custom; HttpOnly; SameSite=Lax`\n            );\n            done();\n          });\n      });\n    });\n\n    it(\"should send the cookie with path=false\", done => {\n      listen({ cookie: { path: false } }, port => {\n        request\n          .get(\"http://localhost:%d/engine.io/default/\".s(port))\n          .query({ transport: \"polling\", b64: 1 })\n          .end((err, res) => {\n            expect(err).to.be(null);\n            const sid = res.text.match(/\"sid\":\"([^\"]+)\"/)[1];\n            expect(res.headers[\"set-cookie\"][0]).to.be(\n              `io=${sid}; SameSite=Lax`\n            );\n            done();\n          });\n      });\n    });\n\n    it(\"should send the io cookie with httpOnly=true\", done => {\n      listen({ cookie: { httpOnly: true } }, port => {\n        request\n          .get(\"http://localhost:%d/engine.io/default/\".s(port))\n          .query({ transport: \"polling\", b64: 1 })\n          .end((err, res) => {\n            expect(err).to.be(null);\n            const sid = res.text.match(/\"sid\":\"([^\"]+)\"/)[1];\n            expect(res.headers[\"set-cookie\"][0]).to.be(\n              `io=${sid}; Path=/; HttpOnly; SameSite=Lax`\n            );\n            done();\n          });\n      });\n    });\n\n    it(\"should send the io cookie with sameSite=strict\", done => {\n      listen({ cookie: { sameSite: \"strict\" } }, port => {\n        request\n          .get(\"http://localhost:%d/engine.io/default/\".s(port))\n          .query({ transport: \"polling\", b64: 1 })\n          .end((err, res) => {\n            expect(err).to.be(null);\n            const sid = res.text.match(/\"sid\":\"([^\"]+)\"/)[1];\n            expect(res.headers[\"set-cookie\"][0]).to.be(\n              `io=${sid}; Path=/; HttpOnly; SameSite=Strict`\n            );\n            done();\n          });\n      });\n    });\n\n    it(\"should send the io cookie with httpOnly=false\", done => {\n      listen({ cookie: { httpOnly: false } }, port => {\n        request\n          .get(\"http://localhost:%d/engine.io/default/\".s(port))\n          .query({ transport: \"polling\", b64: 1 })\n          .end((err, res) => {\n            expect(err).to.be(null);\n            const sid = res.text.match(/\"sid\":\"([^\"]+)\"/)[1];\n            expect(res.headers[\"set-cookie\"][0]).to.be(\n              `io=${sid}; Path=/; SameSite=Lax`\n            );\n            done();\n          });\n      });\n    });\n\n    it(\"should send the io cookie with httpOnly not boolean\", done => {\n      listen({ cookie: { httpOnly: \"no\" } }, port => {\n        request\n          .get(\"http://localhost:%d/engine.io/default/\".s(port))\n          .query({ transport: \"polling\", b64: 1 })\n          .end((err, res) => {\n            expect(err).to.be(null);\n            const sid = res.text.match(/\"sid\":\"([^\"]+)\"/)[1];\n            expect(res.headers[\"set-cookie\"][0]).to.be(\n              `io=${sid}; Path=/; HttpOnly; SameSite=Lax`\n            );\n            done();\n          });\n      });\n    });\n\n    it(\"should not send the io cookie\", done => {\n      listen({ cookie: false }, port => {\n        request\n          .get(\"http://localhost:%d/engine.io/default/\".s(port))\n          .query({ transport: \"polling\" })\n          .end((err, res) => {\n            expect(err).to.be(null);\n            expect(res.headers[\"set-cookie\"]).to.be(undefined);\n            done();\n          });\n      });\n    });\n\n    it(\"should register a new client\", done => {\n      const engine = listen({ allowUpgrades: false }, port => {\n        expect(Object.keys(engine.clients)).to.have.length(0);\n        expect(engine.clientsCount).to.be(0);\n\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n        socket.on(\"open\", () => {\n          expect(Object.keys(engine.clients)).to.have.length(1);\n          expect(engine.clientsCount).to.be(1);\n          done();\n        });\n      });\n    });\n\n    it(\"should register a new client with custom id\", done => {\n      const engine = listen({ allowUpgrades: false }, port => {\n        expect(Object.keys(engine.clients)).to.have.length(0);\n        expect(engine.clientsCount).to.be(0);\n\n        const customId = \"CustomId\" + Date.now();\n\n        engine.generateId = req => customId;\n\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n        socket.once(\"open\", () => {\n          expect(Object.keys(engine.clients)).to.have.length(1);\n          expect(engine.clientsCount).to.be(1);\n          expect(socket.id).to.be(customId);\n          expect(engine.clients[customId].id).to.be(customId);\n          done();\n        });\n      });\n    });\n\n    it(\"should register a new client with custom id (with a Promise)\", done => {\n      const engine = listen({ allowUpgrades: false }, port => {\n        const customId = \"CustomId\" + Date.now();\n\n        engine.generateId = () => Promise.resolve(customId);\n\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n        socket.once(\"open\", () => {\n          expect(socket.id).to.be(customId);\n          expect(engine.clients[customId].id).to.be(customId);\n          done();\n        });\n      });\n    });\n\n    it(\"should disallow connection that are rejected by `generateId`\", done => {\n      const partialDone = createPartialDone(done, 2);\n\n      engine = listen({ allowUpgrades: false }, port => {\n        engine.generateId = () => {\n          return Promise.reject(new Error(\"nope\"));\n        };\n\n        engine.on(\"connection_error\", err => {\n          expect(err.req).to.be.an(http.IncomingMessage);\n          expect(err.code).to.be(3);\n          expect(err.message).to.be(\"Bad request\");\n          expect(err.context.name).to.be(\"ID_GENERATION_ERROR\");\n          partialDone();\n        });\n\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n        socket.on(\"error\", () => {\n          partialDone();\n        });\n      });\n    });\n\n    it(\"should disallow connection that are rejected by `generateId` (websocket only)\", function(done) {\n      if (process.env.EIO_WS_ENGINE === \"eiows\") {\n        this.skip();\n      }\n      const partialDone = createPartialDone(done, 2);\n\n      engine = listen({ allowUpgrades: false }, port => {\n        engine.generateId = () => {\n          return Promise.reject(new Error(\"nope\"));\n        };\n\n        engine.on(\"connection_error\", err => {\n          expect(err.req).to.be.an(http.IncomingMessage);\n          expect(err.code).to.be(3);\n          expect(err.message).to.be(\"Bad request\");\n          expect(err.context.name).to.be(\"ID_GENERATION_ERROR\");\n          partialDone();\n        });\n\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n          transports: [\"websocket\"]\n        });\n        socket.on(\"error\", () => {\n          partialDone();\n        });\n      });\n    });\n\n    it(\"should exchange handshake data\", done => {\n      listen({ allowUpgrades: false }, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n        socket.on(\"handshake\", obj => {\n          expect(obj.sid).to.be.a(\"string\");\n          expect(obj.pingTimeout).to.be.a(\"number\");\n          expect(obj.upgrades).to.be.an(\"array\");\n          done();\n        });\n      });\n    });\n\n    it(\"should allow custom ping timeouts\", done => {\n      listen({ allowUpgrades: false, pingTimeout: 123 }, port => {\n        const socket = new eioc.Socket(\"http://localhost:%d\".s(port));\n        socket.on(\"handshake\", obj => {\n          expect(obj.pingTimeout).to.be(123);\n          done();\n        });\n      });\n    });\n\n    it(\"should trigger a connection event with a Socket\", done => {\n      const engine = listen({ allowUpgrades: false }, port => {\n        eioc(\"ws://localhost:%d\".s(port));\n        engine.on(\"connection\", socket => {\n          expect(socket).to.be.an(eio.Socket);\n          done();\n        });\n      });\n    });\n\n    it(\"should open with polling by default\", done => {\n      const engine = listen({ allowUpgrades: false }, port => {\n        eioc(\"ws://localhost:%d\".s(port));\n        engine.on(\"connection\", socket => {\n          expect(socket.transport.name).to.be(\"polling\");\n          done();\n        });\n      });\n    });\n\n    it(\"should be able to open with ws directly\", done => {\n      const engine = listen({ transports: [\"websocket\"] }, port => {\n        eioc(\"ws://localhost:%d\".s(port), { transports: [\"websocket\"] });\n        engine.on(\"connection\", socket => {\n          expect(socket.transport.name).to.be(\"websocket\");\n          done();\n        });\n      });\n    });\n\n    it(\"should not suggest any upgrades for websocket\", done => {\n      listen({ transports: [\"websocket\"] }, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n          transports: [\"websocket\"]\n        });\n        socket.on(\"handshake\", obj => {\n          expect(obj.upgrades).to.have.length(0);\n          done();\n        });\n      });\n    });\n\n    it(\"should not suggest upgrades when none are availble\", done => {\n      listen({ transports: [\"polling\"] }, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {});\n        socket.on(\"handshake\", obj => {\n          expect(obj.upgrades).to.have.length(0);\n          done();\n        });\n      });\n    });\n\n    it(\"should only suggest available upgrades\", done => {\n      listen({ transports: [\"polling\"] }, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {});\n        socket.on(\"handshake\", obj => {\n          expect(obj.upgrades).to.have.length(0);\n          done();\n        });\n      });\n    });\n\n    it(\"should suggest all upgrades when no transports are disabled\", done => {\n      listen({}, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {});\n        socket.on(\"handshake\", obj => {\n          expect(obj.upgrades).to.have.length(1);\n          expect(obj.upgrades).to.have.contain(\"websocket\");\n          done();\n        });\n      });\n    });\n\n    it(\"default to polling when proxy doesn't support websocket\", done => {\n      const partialDone = createPartialDone(done, 2);\n\n      engine = listen({ allowUpgrades: false }, port => {\n        engine.on(\"connection\", socket => {\n          socket.on(\"message\", msg => {\n            if (\"echo\" === msg) socket.send(msg);\n          });\n        });\n\n        engine.on(\"connection_error\", err => {\n          expect(err.req).to.be.an(http.IncomingMessage);\n          expect(err.code).to.be(3);\n          expect(err.message).to.be(\"Bad request\");\n          expect(err.context.name).to.be(\"TRANSPORT_MISMATCH\");\n          expect(err.context.transport).to.be(\"websocket\");\n          expect(err.context.previousTransport).to.be(\"polling\");\n          partialDone();\n        });\n\n        var socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n        socket.on(\"open\", () => {\n          request\n            .get(\"http://localhost:%d/engine.io/\".s(port))\n            .set({ connection: \"close\" })\n            .query({ transport: \"websocket\", sid: socket.id })\n            .end((err, res) => {\n              expect(err).to.be.an(Error);\n              expect(res.status).to.be(400);\n              expect(res.body.code).to.be(3);\n              socket.send(\"echo\");\n              socket.on(\"message\", msg => {\n                expect(msg).to.be(\"echo\");\n                partialDone();\n              });\n            });\n        });\n      });\n    });\n\n    it(\"should allow arbitrary data through query string\", done => {\n      const engine = listen({ allowUpgrades: false }, port => {\n        eioc(\"ws://localhost:%d\".s(port), { query: { a: \"b\" } });\n        engine.on(\"connection\", conn => {\n          expect(conn.request._query).to.have.keys(\"transport\", \"a\");\n          expect(conn.request._query.a).to.be(\"b\");\n          done();\n        });\n      });\n    });\n\n    it(\"should allow data through query string in uri\", done => {\n      const engine = listen({ allowUpgrades: false }, port => {\n        eioc(\"ws://localhost:%d?a=b&c=d\".s(port));\n        engine.on(\"connection\", conn => {\n          expect(conn.request._query.EIO).to.be.a(\"string\");\n          expect(conn.request._query.a).to.be(\"b\");\n          expect(conn.request._query.c).to.be(\"d\");\n          done();\n        });\n      });\n    });\n\n    it(\"should disallow bad requests (handshake error)\", done => {\n      const partialDone = createPartialDone(done, 2);\n\n      engine = listen(\n        {\n          cors: { credentials: true, origin: \"http://engine.io\" }\n        },\n        port => {\n          engine.on(\"connection_error\", err => {\n            expect(err.req).to.be.an(http.IncomingMessage);\n            expect(err.code).to.be(3);\n            expect(err.message).to.be(\"Bad request\");\n            expect(err.context.name).to.be(\"TRANSPORT_HANDSHAKE_ERROR\");\n            expect(err.context.error).to.be.an(Error);\n            expect(err.context.error.name).to.be(\"TypeError\");\n            partialDone();\n          });\n\n          request\n            .get(\"http://localhost:%d/engine.io/default/\".s(port))\n            .set(\"Origin\", \"http://engine.io\")\n            .query({ transport: \"websocket\" })\n            .end((err, res) => {\n              expect(err).to.be.an(Error);\n              expect(res.status).to.be(400);\n              expect(res.body.code).to.be(3);\n              expect(res.body.message).to.be(\"Bad request\");\n              expect(res.header[\"access-control-allow-credentials\"]).to.be(\n                \"true\"\n              );\n              expect(res.header[\"access-control-allow-origin\"]).to.be(\n                \"http://engine.io\"\n              );\n              partialDone();\n            });\n        }\n      );\n    });\n\n    it(\"should disallow invalid origin header\", done => {\n      const partialDone = createPartialDone(done, 2);\n\n      engine = listen(port => {\n        // we can't send an invalid header through request.get\n        // so add an invalid char here\n        engine.prepare = function(req) {\n          eio.Server.prototype.prepare.call(engine, req);\n          req.headers.origin += \"\\n\";\n        };\n\n        engine.on(\"connection_error\", err => {\n          expect(err.req).to.be.an(http.IncomingMessage);\n          expect(err.code).to.be(3);\n          expect(err.message).to.be(\"Bad request\");\n          expect(err.context.name).to.be(\"INVALID_ORIGIN\");\n          expect(err.context.origin).to.be(\"http://engine.io/\\n\");\n          partialDone();\n        });\n\n        request\n          .get(\"http://localhost:%d/engine.io/default/\".s(port))\n          .set(\"Origin\", \"http://engine.io/\")\n          .query({ transport: \"websocket\" })\n          .end((err, res) => {\n            expect(err).to.be.an(Error);\n            expect(res.status).to.be(400);\n            expect(res.body.code).to.be(3);\n            expect(res.body.message).to.be(\"Bad request\");\n            partialDone();\n          });\n      });\n    });\n\n    it(\"should disallow invalid handshake method\", done => {\n      const partialDone = createPartialDone(done, 2);\n\n      engine = listen(port => {\n        engine.on(\"connection_error\", err => {\n          expect(err.req).to.be.an(http.IncomingMessage);\n          expect(err.code).to.be(2);\n          expect(err.message).to.be(\"Bad handshake method\");\n          expect(err.context.method).to.be(\"OPTIONS\");\n          partialDone();\n        });\n\n        request\n          .options(\"http://localhost:%d/engine.io/default/\".s(port))\n          .query({ transport: \"polling\" })\n          .end((err, res) => {\n            expect(err).to.be.an(Error);\n            expect(res.status).to.be(400);\n            expect(res.body.code).to.be(2);\n            expect(res.body.message).to.be(\"Bad handshake method\");\n            partialDone();\n          });\n      });\n    });\n\n    it(\"should disallow unsupported protocol versions\", done => {\n      const partialDone = createPartialDone(done, 2);\n\n      const httpServer = http.createServer();\n      const engine = eio({ allowEIO3: false });\n      engine.attach(httpServer);\n      httpServer.listen(() => {\n        const port = httpServer.address().port;\n\n        engine.on(\"connection_error\", err => {\n          expect(err.req).to.be.an(http.IncomingMessage);\n          expect(err.code).to.be(5);\n          expect(err.message).to.be(\"Unsupported protocol version\");\n          expect(err.context.protocol).to.be(3);\n\n          httpServer.close();\n          partialDone();\n        });\n\n        request\n          .get(\"http://localhost:%d/engine.io/\".s(port))\n          .query({ transport: \"polling\", EIO: 3 })\n          .end((err, res) => {\n            expect(err).to.be.an(Error);\n            expect(res.status).to.be(400);\n            expect(res.body.code).to.be(5);\n            expect(res.body.message).to.be(\"Unsupported protocol version\");\n            partialDone();\n          });\n      });\n    });\n\n    it(\"should send a packet along with the handshake\", done => {\n      listen({ initialPacket: \"faster!\" }, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n        socket.on(\"open\", () => {\n          socket.on(\"message\", msg => {\n            expect(msg).to.be(\"faster!\");\n            done();\n          });\n        });\n      });\n    });\n  });\n\n  describe(\"close\", () => {\n    it(\"should be able to access non-empty writeBuffer at closing (server)\", done => {\n      const opts = { allowUpgrades: false };\n      const engine = listen(opts, port => {\n        eioc(\"http://localhost:%d\".s(port));\n        engine.on(\"connection\", conn => {\n          conn.on(\"close\", reason => {\n            expect(conn.writeBuffer.length).to.be(1);\n            setTimeout(() => {\n              expect(conn.writeBuffer.length).to.be(0); // writeBuffer has been cleared\n            }, 10);\n            done();\n          });\n          conn.writeBuffer.push({ type: \"message\", data: \"foo\" });\n          conn.onError(\"\");\n        });\n      });\n    });\n\n    it(\"should be able to access non-empty writeBuffer at closing (client)\", done => {\n      const opts = { allowUpgrades: false };\n      listen(opts, port => {\n        const socket = new eioc.Socket(\"http://localhost:%d\".s(port));\n        socket.on(\"open\", () => {\n          socket.on(\"close\", reason => {\n            expect(socket.writeBuffer.length).to.be(1);\n            setTimeout(() => {\n              expect(socket.writeBuffer.length).to.be(0);\n            }, 10);\n            done();\n          });\n          socket.writeBuffer.push({ type: \"message\", data: \"foo\" });\n          socket.onError(\"\");\n        });\n      });\n    });\n\n    it(\"should trigger on server if the client does not pong\", done => {\n      const opts = { allowUpgrades: false, pingInterval: 5, pingTimeout: 5 };\n      const engine = listen(opts, port => {\n        const socket = new eioc.Socket(\"http://localhost:%d\".s(port));\n        socket.sendPacket = () => {};\n        engine.on(\"connection\", conn => {\n          conn.on(\"close\", reason => {\n            expect(reason).to.be(\"ping timeout\");\n            done();\n          });\n        });\n      });\n    });\n\n    it(\"should trigger on server even when there is no outstanding polling request (GH-198)\", done => {\n      const opts = {\n        allowUpgrades: false,\n        pingInterval: 500,\n        pingTimeout: 500\n      };\n      const engine = listen(opts, port => {\n        const socket = new eioc.Socket(\"http://localhost:%d\".s(port));\n        engine.on(\"connection\", conn => {\n          conn.on(\"close\", reason => {\n            expect(reason).to.be(\"ping timeout\");\n            done();\n          });\n          // client abruptly disconnects, no polling request on this tick since we've just connected\n          socket.sendPacket = () => {};\n          socket.transport.removeListener(\"packet\");\n          socket.close();\n          // then server app tries to close the socket, since client disappeared\n          conn.close();\n        });\n      });\n    });\n\n    it(\"should trigger on client if server does not meet ping timeout\", done => {\n      const opts = { allowUpgrades: false, pingInterval: 50, pingTimeout: 30 };\n      listen(opts, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n        socket.on(\"open\", () => {\n          // override onPacket and Transport#onClose to simulate an inactive server after handshake\n          socket.transport.removeListener(\"packet\");\n          socket.transport.removeListener(\"close\");\n          socket.on(\"close\", (reason, err) => {\n            expect(reason).to.be(\"ping timeout\");\n            done();\n          });\n        });\n      });\n    });\n\n    it(\"should trigger on both ends upon ping timeout\", done => {\n      const opts = { allowUpgrades: false, pingTimeout: 50, pingInterval: 50 };\n      const engine = listen(opts, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n        let total = 2;\n\n        function onClose(reason, err) {\n          expect(reason).to.be(\"ping timeout\");\n          --total || done();\n        }\n\n        engine.on(\"connection\", conn => {\n          conn.on(\"close\", onClose);\n        });\n\n        socket.on(\"open\", () => {\n          // override onPacket and Transport#onClose to simulate an inactive server after handshake\n          socket.sendPacket = () => {};\n          socket.transport.removeListener(\"packet\");\n          socket.transport.removeListener(\"close\");\n          socket.on(\"close\", onClose);\n        });\n      });\n    });\n\n    it(\"should trigger when server closes a client\", done => {\n      const engine = listen({ allowUpgrades: false }, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n        let total = 2;\n\n        engine.on(\"connection\", conn => {\n          conn.on(\"close\", reason => {\n            expect(reason).to.be(\"forced close\");\n            --total || done();\n          });\n          setTimeout(() => {\n            conn.close();\n          }, 10);\n        });\n\n        socket.on(\"open\", () => {\n          socket.on(\"close\", reason => {\n            expect(reason).to.be(\"transport close\");\n            --total || done();\n          });\n        });\n      });\n    });\n\n    it(\"should trigger when server closes a client (ws)\", done => {\n      const opts = { allowUpgrades: false, transports: [\"websocket\"] };\n      const engine = listen(opts, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n          transports: [\"websocket\"]\n        });\n        let total = 2;\n\n        engine.on(\"connection\", conn => {\n          conn.on(\"close\", reason => {\n            expect(reason).to.be(\"forced close\");\n            --total || done();\n          });\n          setTimeout(() => {\n            conn.close();\n          }, 10);\n        });\n\n        socket.on(\"open\", () => {\n          socket.on(\"close\", reason => {\n            expect(reason).to.be(\"transport close\");\n            --total || done();\n          });\n        });\n      });\n    });\n\n    it(\"should allow client reconnect after restarting (ws)\", done => {\n      const opts = { transports: [\"websocket\"] };\n      const engine = listen(opts, port => {\n        engine.httpServer.close();\n        engine.httpServer.listen(port);\n\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n          transports: [\"websocket\"]\n        });\n\n        engine.once(\"connection\", conn => {\n          setTimeout(() => {\n            conn.close();\n          }, 10);\n        });\n\n        socket.once(\"close\", reason => {\n          expect(reason).to.be(\"transport close\");\n          done();\n        });\n      });\n    });\n\n    it(\"should trigger when client closes\", done => {\n      const engine = listen({ allowUpgrades: false }, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n        let total = 2;\n\n        engine.on(\"connection\", conn => {\n          conn.on(\"close\", reason => {\n            expect(reason).to.be(\"transport close\");\n            --total || done();\n          });\n        });\n\n        socket.on(\"open\", () => {\n          socket.on(\"close\", reason => {\n            expect(reason).to.be(\"forced close\");\n            --total || done();\n          });\n\n          setTimeout(() => {\n            socket.close();\n          }, 10);\n        });\n      });\n    });\n\n    it(\"should trigger when client closes (ws)\", done => {\n      const opts = { allowUpgrades: false, transports: [\"websocket\"] };\n      const engine = listen(opts, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n          transports: [\"websocket\"]\n        });\n        let total = 2;\n\n        engine.on(\"connection\", conn => {\n          conn.on(\"close\", reason => {\n            expect(reason).to.be(\"transport close\");\n            --total || done();\n          });\n        });\n\n        socket.on(\"open\", () => {\n          socket.on(\"close\", reason => {\n            expect(reason).to.be(\"forced close\");\n            --total || done();\n          });\n\n          setTimeout(() => {\n            socket.close();\n          }, 10);\n        });\n      });\n    });\n\n    it(\"should trigger when calling socket.close() in payload\", done => {\n      const engine = listen({ allowUpgrades: false }, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n\n        engine.on(\"connection\", conn => {\n          conn.send(null, () => {\n            socket.close();\n          });\n          conn.send(\"this should not be handled\");\n\n          conn.on(\"close\", reason => {\n            expect(reason).to.be(\"transport close\");\n            done();\n          });\n        });\n\n        socket.on(\"open\", () => {\n          socket.on(\"message\", msg => {\n            expect(msg).to.not.be(\"this should not be handled\");\n          });\n\n          socket.on(\"close\", reason => {\n            expect(reason).to.be(\"forced close\");\n          });\n        });\n      });\n    });\n\n    it(\"should abort upgrade if socket is closed (GH-35)\", done => {\n      listen({ allowUpgrades: true }, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n        socket.on(\"open\", () => {\n          socket.close();\n          // we wait until complete to see if we get an uncaught EPIPE\n          setTimeout(() => {\n            done();\n          }, 100);\n        });\n      });\n    });\n\n    it(\"should abort connection when upgrade fails\", done => {\n      listen({ allowUpgrades: true }, port => {\n        const req = http.request(\n          {\n            port,\n            path: \"/engine.io/\",\n            headers: {\n              connection: \"Upgrade\",\n              upgrade: \"websocket\"\n            }\n          },\n          res => {\n            expect(res.statusCode).to.eql(400);\n            res.resume();\n            res.on(\"end\", done);\n          }\n        );\n        req.end();\n      });\n    });\n\n    it(\n      \"should trigger if a poll request is ongoing and the underlying \" +\n        \"socket closes, as in a browser tab close\",\n      $done => {\n        const engine = listen({ allowUpgrades: false }, port => {\n          // hack to access the sockets created by node-xmlhttprequest\n          // see: https://github.com/driverdan/node-XMLHttpRequest/issues/44\n          const request = require(\"http\").request;\n          const sockets = [];\n          http.request = function(opts) {\n            const req = request.apply(null, arguments);\n            req.on(\"socket\", socket => {\n              sockets.push(socket);\n            });\n            return req;\n          };\n\n          function done() {\n            http.request = request;\n            $done();\n          }\n\n          var socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n          let serverSocket;\n\n          engine.on(\"connection\", s => {\n            serverSocket = s;\n          });\n\n          socket.transport.on(\"poll\", () => {\n            // we set a timer to wait for the request to actually reach\n            setTimeout(() => {\n              // at this time server's `connection` should have been fired\n              expect(serverSocket).to.be.an(\"object\");\n\n              // OPENED readyState is expected - we are actually polling\n              expect(socket.transport.pollXhr.xhr.readyState).to.be(1);\n\n              // 2 requests sent to the server over an unique port means\n              // we should have been assigned 2 sockets\n              expect(sockets.length).to.be(2);\n\n              // expect the socket to be open at this point\n              expect(serverSocket.readyState).to.be(\"open\");\n\n              // kill the underlying connection\n              sockets[1].end();\n              serverSocket.on(\"close\", (reason, err) => {\n                expect(reason).to.be(\"transport error\");\n                expect(err.message).to.be(\"poll connection closed prematurely\");\n                done();\n              });\n            }, 50);\n          });\n        });\n      }\n    );\n\n    it(\"should not trigger with connection: close header\", $done => {\n      const engine = listen({ allowUpgrades: false }, port => {\n        // intercept requests to add connection: close\n        const request = http.request;\n        http.request = function() {\n          const opts = arguments[0];\n          opts.headers = opts.headers || {};\n          opts.headers.Connection = \"close\";\n          return request.apply(this, arguments);\n        };\n\n        function done() {\n          http.request = request;\n          $done();\n        }\n\n        engine.on(\"connection\", socket => {\n          socket.on(\"message\", msg => {\n            expect(msg).to.equal(\"test\");\n            socket.send(\"woot\");\n          });\n        });\n\n        var socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n        socket.on(\"open\", () => {\n          socket.send(\"test\");\n        });\n        socket.on(\"message\", msg => {\n          expect(msg).to.be(\"woot\");\n          done();\n        });\n      });\n    });\n\n    it(\n      \"should not trigger early with connection `ping timeout`\" +\n        \"after post handshake timeout\",\n      done => {\n        // first timeout should trigger after `pingInterval + pingTimeout`,\n        // not just `pingTimeout`.\n        const opts = {\n          allowUpgrades: false,\n          pingInterval: 300,\n          pingTimeout: 100\n        };\n        listen(opts, port => {\n          const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n          let clientCloseReason = null;\n\n          socket.on(\"handshake\", () => {\n            socket.transport.removeListener(\"packet\");\n          });\n          socket.on(\"open\", () => {\n            socket.on(\"close\", reason => {\n              clientCloseReason = reason;\n            });\n          });\n\n          setTimeout(() => {\n            expect(clientCloseReason).to.be(null);\n            done();\n          }, 200);\n        });\n      }\n    );\n\n    it(\n      \"should not trigger early with connection `ping timeout` \" +\n        \"after post ping timeout\",\n      done => {\n        // ping timeout should trigger after `pingInterval + pingTimeout`,\n        // not just `pingTimeout`.\n        const opts = {\n          allowUpgrades: false,\n          pingInterval: 80,\n          pingTimeout: 50\n        };\n        const engine = listen(opts, port => {\n          const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n          let clientCloseReason = null;\n\n          engine.on(\"connection\", conn => {\n            conn.on(\"heartbeat\", () => {\n              conn.onPacket = () => {};\n            });\n          });\n\n          socket.on(\"open\", () => {\n            socket.on(\"close\", reason => {\n              clientCloseReason = reason;\n            });\n          });\n\n          setTimeout(() => {\n            expect(clientCloseReason).to.be(null);\n            done();\n          }, 100);\n        });\n      }\n    );\n\n    it(\n      \"should trigger early with connection `transport close` \" +\n        \"after missing pong\",\n      done => {\n        // ping timeout should trigger after `pingInterval + pingTimeout`,\n        // not just `pingTimeout`.\n        const opts = {\n          allowUpgrades: false,\n          pingInterval: 80,\n          pingTimeout: 50\n        };\n        const engine = listen(opts, port => {\n          const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n          let clientCloseReason = null;\n\n          socket.on(\"open\", () => {\n            socket.on(\"close\", reason => {\n              clientCloseReason = reason;\n            });\n          });\n\n          engine.on(\"connection\", conn => {\n            conn.on(\"heartbeat\", () => {\n              setTimeout(() => {\n                conn.close();\n              }, 20);\n              setTimeout(() => {\n                expect(clientCloseReason).to.be(\"transport close\");\n                done();\n              }, 100);\n            });\n          });\n        });\n      }\n    );\n\n    if (process.env.EIO_CLIENT === \"3\") {\n      it(\n        \"should trigger with connection `ping timeout` \" +\n          \"after `pingInterval + pingTimeout`\",\n        done => {\n          const opts = {\n            allowUpgrades: false,\n            pingInterval: 300,\n            pingTimeout: 100\n          };\n          const engine = listen(opts, port => {\n            const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n            let clientCloseReason = null;\n\n            socket.on(\"open\", () => {\n              socket.on(\"close\", reason => {\n                clientCloseReason = reason;\n              });\n            });\n\n            engine.on(\"connection\", conn => {\n              conn.once(\"heartbeat\", () => {\n                setTimeout(() => {\n                  socket.transport.removeListener(\"packet\");\n                  expect(clientCloseReason).to.be(null);\n                }, 150);\n                setTimeout(() => {\n                  expect(clientCloseReason).to.be(null);\n                }, 350);\n                setTimeout(() => {\n                  expect(clientCloseReason).to.be(\"ping timeout\");\n                  done();\n                }, 500);\n              });\n            });\n          });\n        }\n      );\n    } else {\n      it(\n        \"should trigger with connection `ping timeout` \" +\n          \"after `pingInterval + pingTimeout`\",\n        done => {\n          const opts = {\n            allowUpgrades: false,\n            pingInterval: 300,\n            pingTimeout: 100\n          };\n          const engine = listen(opts, port => {\n            const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n            let clientCloseReason = null;\n\n            socket.on(\"open\", () => {\n              socket.on(\"close\", reason => {\n                clientCloseReason = reason;\n              });\n            });\n\n            engine.on(\"connection\", conn => {\n              conn.once(\"heartbeat\", () => {\n                socket.transport.removeListener(\"packet\");\n                setTimeout(() => {\n                  expect(clientCloseReason).to.be(null);\n                }, 150);\n                setTimeout(() => {\n                  expect(clientCloseReason).to.be(null);\n                }, 350);\n                setTimeout(() => {\n                  expect(clientCloseReason).to.be(\"ping timeout\");\n                  done();\n                }, 500);\n              });\n            });\n          });\n        }\n      );\n    }\n\n    it(\n      \"should abort the polling data request if it is \" + \"in progress\",\n      done => {\n        const engine = listen({ transports: [\"polling\"] }, port => {\n          const socket = new eioc.Socket(\"http://localhost:%d\".s(port));\n\n          engine.on(\"connection\", conn => {\n            const onDataRequest = conn.transport.onDataRequest;\n            conn.transport.onDataRequest = (req, res) => {\n              engine.httpServer.close(done);\n              onDataRequest.call(conn.transport, req, res);\n              req.removeAllListeners();\n              conn.close();\n            };\n          });\n\n          socket.on(\"open\", () => {\n            socket.send(\"test\");\n          });\n        });\n      }\n    );\n\n    // tests https://github.com/LearnBoost/engine.io-client/issues/207\n    // websocket test, transport error\n    it(\"should trigger transport close before open for ws\", done => {\n      const opts = { transports: [\"websocket\"] };\n      listen(opts, port => {\n        const url = \"ws://%s:%d\".s(\"0.0.0.0\", port);\n        const socket = new eioc.Socket(url);\n        socket.on(\"open\", () => {\n          done(new Error(\"Test invalidation\"));\n        });\n        socket.on(\"close\", reason => {\n          expect(reason).to.be(\"transport error\");\n          done();\n        });\n      });\n    });\n\n    // tests https://github.com/LearnBoost/engine.io-client/issues/207\n    // polling test, transport error\n    it(\"should trigger transport close before open for xhr\", done => {\n      const opts = { transports: [\"polling\"] };\n      listen(opts, port => {\n        const socket = new eioc.Socket(\"http://invalidserver:%d\".s(port));\n        socket.on(\"open\", () => {\n          done(new Error(\"Test invalidation\"));\n        });\n        socket.on(\"close\", reason => {\n          expect(reason).to.be(\"transport error\");\n          done();\n        });\n      });\n    });\n\n    // tests https://github.com/LearnBoost/engine.io-client/issues/207\n    // websocket test, force close\n    it(\"should trigger force close before open for ws\", done => {\n      const opts = { transports: [\"websocket\"] };\n      listen(opts, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n        socket.on(\"open\", () => {\n          done(new Error(\"Test invalidation\"));\n        });\n        socket.on(\"close\", reason => {\n          expect(reason).to.be(\"forced close\");\n          done();\n        });\n        socket.close();\n      });\n    });\n\n    // tests https://github.com/LearnBoost/engine.io-client/issues/207\n    // polling test, force close\n    it(\"should trigger force close before open for xhr\", done => {\n      const opts = { transports: [\"polling\"] };\n      listen(opts, port => {\n        const socket = new eioc.Socket(\"http://localhost:%d\".s(port));\n        socket.on(\"open\", () => {\n          done(new Error(\"Test invalidation\"));\n        });\n        socket.on(\"close\", reason => {\n          expect(reason).to.be(\"forced close\");\n          done();\n        });\n        socket.close();\n      });\n    });\n\n    it(\"should close transport upon ping timeout (ws)\", done => {\n      const opts = {\n        allowUpgrades: false,\n        transports: [\"websocket\"],\n        pingInterval: 50,\n        pingTimeout: 30\n      };\n      const engine = listen(opts, port => {\n        engine.on(\"connection\", conn => {\n          conn.transport.on(\"close\", done);\n        });\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n          transports: [\"websocket\"]\n        });\n        // override to simulate an inactive client\n        socket.sendPacket = socket.onHeartbeat = () => {};\n      });\n    });\n\n    it(\"should close transport upon ping timeout (polling)\", done => {\n      const opts = {\n        allowUpgrades: false,\n        transports: [\"polling\"],\n        pingInterval: 50,\n        pingTimeout: 30\n      };\n      const engine = listen(opts, port => {\n        engine.on(\"connection\", conn => {\n          conn.transport.on(\"close\", done);\n        });\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n          transports: [\"polling\"]\n        });\n        // override to simulate an inactive client\n        socket.sendPacket = socket.onHeartbeat = () => {};\n      });\n    });\n\n    it(\"should close transport upon parse error (ws)\", done => {\n      const opts = { allowUpgrades: false, transports: [\"websocket\"] };\n      const engine = listen(opts, port => {\n        engine.on(\"connection\", conn => {\n          conn.transport.on(\"close\", done);\n        });\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n          transports: [\"websocket\"]\n        });\n        socket.on(\"open\", () => {\n          socket.transport.ws.send(\"invalid\");\n        });\n      });\n    });\n\n    it(\"should close transport upon parse error (polling)\", done => {\n      const opts = { allowUpgrades: false, transports: [\"polling\"] };\n      const engine = listen(opts, port => {\n        engine.on(\"connection\", conn => {\n          conn.transport.closeTimeout = 100;\n          conn.transport.on(\"close\", done);\n        });\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n          transports: [\"polling\"]\n        });\n        socket.on(\"open\", () => {\n          socket.transport.doWrite(\"invalid\", () => {});\n        });\n      });\n    });\n\n    it(\"should close upgrading transport upon socket close\", done => {\n      const engine = listen(port => {\n        engine.on(\"connection\", conn => {\n          conn.on(\"upgrading\", transport => {\n            transport.on(\"close\", done);\n            conn.close();\n          });\n        });\n        eioc(\"ws://localhost:%d\".s(port));\n      });\n    });\n\n    it(\"should close upgrading transport upon upgrade timeout\", done => {\n      const opts = { upgradeTimeout: 100 };\n      const engine = listen(opts, port => {\n        engine.on(\"connection\", conn => {\n          conn.on(\"upgrading\", transport => {\n            transport.on(\"close\", done);\n          });\n        });\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n        socket.on(\"upgrading\", transport => {\n          // override not to complete upgrading\n          transport.send = () => {};\n        });\n      });\n    });\n\n    it(\"should not timeout after an upgrade\", done => {\n      const opts = { pingInterval: 200, pingTimeout: 20 };\n      const engine = listen(opts, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n        socket.on(\"open\", () => {\n          setTimeout(() => {\n            socket.removeListener(\"close\");\n            engine.close();\n            socket.close();\n            done();\n          }, 500);\n        });\n        socket.on(\"close\", () => {\n          done(new Error(\"should not happen\"));\n        });\n      });\n    });\n\n    it(\"should not crash when messing with Object prototype\", done => {\n      Object.prototype.foo = \"bar\"; // eslint-disable-line no-extend-native\n      const engine = listen({ allowUpgrades: true }, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n        socket.on(\"open\", () => {\n          engine.close();\n          setTimeout(() => {\n            done();\n          }, 100);\n        });\n      });\n    });\n\n    describe(\"graceful close\", () => {\n      function fixture(filename) {\n        return (\n          process.execPath + \" \" + path.join(__dirname, \"fixtures\", filename)\n        );\n      }\n\n      it(\"should stop socket and timers\", done => {\n        exec(fixture(\"server-close.js\"), done);\n      });\n\n      it(\"should stop upgraded socket and timers\", done => {\n        exec(fixture(\"server-close-upgraded.js\"), done);\n      });\n\n      it(\"should stop upgrading socket and timers\", done => {\n        exec(fixture(\"server-close-upgrading.js\"), done);\n      });\n    });\n  });\n\n  describe(\"messages\", function() {\n    this.timeout(5000);\n\n    it(\"should arrive from server to client\", done => {\n      const engine = listen({ allowUpgrades: false }, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n        engine.on(\"connection\", conn => {\n          conn.send(\"a\");\n        });\n        socket.on(\"open\", () => {\n          socket.on(\"message\", msg => {\n            expect(msg).to.be(\"a\");\n            done();\n          });\n        });\n      });\n    });\n\n    it(\"should arrive from server to client (multiple)\", done => {\n      const engine = listen({ allowUpgrades: false }, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n        const expected = [\"a\", \"b\", \"c\"];\n        let i = 0;\n\n        engine.on(\"connection\", conn => {\n          conn.send(\"a\");\n          // we use set timeouts to ensure the messages are delivered as part\n          // of different.\n          setTimeout(() => {\n            conn.send(\"b\");\n\n            setTimeout(() => {\n              // here we make sure we buffer both the close packet and\n              // a regular packet\n              conn.send(\"c\");\n              conn.close();\n            }, 50);\n          }, 50);\n\n          conn.on(\"close\", () => {\n            // since close fires right after the buffer is drained\n            setTimeout(() => {\n              expect(i).to.be(3);\n              done();\n            }, 50);\n          });\n        });\n        socket.on(\"open\", () => {\n          socket.on(\"message\", msg => {\n            expect(msg).to.be(expected[i++]);\n          });\n        });\n      });\n    });\n\n    it(\"should not be receiving data when getting a message longer than maxHttpBufferSize when polling\", done => {\n      const opts = {\n        allowUpgrades: false,\n        transports: [\"polling\"],\n        maxHttpBufferSize: 5\n      };\n      const engine = listen(opts, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n        engine.on(\"connection\", conn => {\n          conn.on(\"message\", msg => {\n            done(\n              new Error(\"Test invalidation (message is longer than allowed)\")\n            );\n          });\n        });\n        socket.on(\"open\", () => {\n          socket.send(\"aasdasdakjhasdkjhasdkjhasdkjhasdkjhasdkjhasdkjha\");\n        });\n        socket.on(\"close\", () => {\n          done();\n        });\n      });\n    });\n\n    it(\"should not be receiving data when getting a message longer than maxHttpBufferSize (websocket)\", done => {\n      const opts = { maxHttpBufferSize: 5 };\n      const engine = listen(opts, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n          transports: [\"websocket\"]\n        });\n        engine.on(\"connection\", conn => {\n          conn.on(\"message\", msg => {\n            done(\n              new Error(\"Test invalidation (message is longer than allowed)\")\n            );\n          });\n        });\n        socket.on(\"open\", () => {\n          socket.send(\"aasdasdakjhasdkjhasdkjhasdkjhasdkjhasdkjhasdkjha\");\n        });\n        socket.on(\"close\", () => {\n          done();\n        });\n      });\n    });\n\n    it(\"should receive data when getting a message shorter than maxHttpBufferSize when polling\", done => {\n      const opts = {\n        allowUpgrades: false,\n        transports: [\"polling\"],\n        maxHttpBufferSize: 5\n      };\n      const engine = listen(opts, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n        engine.on(\"connection\", conn => {\n          conn.on(\"message\", msg => {\n            expect(msg).to.be(\"a\");\n            done();\n          });\n        });\n        socket.on(\"open\", () => {\n          socket.send(\"a\");\n        });\n      });\n    });\n\n    it(\"should arrive from server to client (ws)\", done => {\n      const opts = { allowUpgrades: false, transports: [\"websocket\"] };\n      const engine = listen(opts, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n          transports: [\"websocket\"]\n        });\n        engine.on(\"connection\", conn => {\n          conn.send(\"a\");\n        });\n        socket.on(\"open\", () => {\n          socket.on(\"message\", msg => {\n            expect(msg).to.be(\"a\");\n            done();\n          });\n        });\n      });\n    });\n\n    it(\"should arrive from server to client (multiple, ws)\", done => {\n      const opts = { allowUpgrades: false, transports: [\"websocket\"] };\n      const engine = listen(opts, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n          transports: [\"websocket\"]\n        });\n        const expected = [\"a\", \"b\", \"c\"];\n        let i = 0;\n\n        engine.on(\"connection\", conn => {\n          conn.send(\"a\");\n          setTimeout(() => {\n            conn.send(\"b\");\n            setTimeout(() => {\n              conn.send(\"c\");\n              conn.close();\n            }, 50);\n          }, 50);\n          conn.on(\"close\", () => {\n            setTimeout(() => {\n              expect(i).to.be(3);\n              done();\n            }, 50);\n          });\n        });\n\n        socket.on(\"open\", () => {\n          socket.on(\"message\", msg => {\n            expect(msg).to.be(expected[i++]);\n          });\n        });\n      });\n    });\n\n    it(\"should arrive from server to client (multiple, no delay, ws)\", done => {\n      const opts = { allowUpgrades: false, transports: [\"websocket\"] };\n      const engine = listen(opts, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n          transports: [\"websocket\"]\n        });\n        const expected = [\"a\", \"b\", \"c\"];\n        let i = 0;\n\n        engine.on(\"connection\", conn => {\n          conn.on(\"close\", () => {\n            setTimeout(() => {\n              expect(i).to.be(3);\n              done();\n            }, 50);\n          });\n          conn.send(\"a\");\n          conn.send(\"b\");\n          conn.send(\"c\");\n          setTimeout(() => {\n            conn.close();\n          }, 50);\n        });\n\n        socket.on(\"open\", () => {\n          socket.on(\"message\", msg => {\n            expect(msg).to.be(expected[i++]);\n          });\n        });\n      });\n    });\n\n    it(\"should arrive when binary data is sent as Int8Array (ws)\", done => {\n      const binaryData = new Int8Array(5);\n      for (let i = 0; i < binaryData.length; i++) {\n        binaryData[i] = i;\n      }\n\n      const opts = { allowUpgrades: false, transports: [\"websocket\"] };\n      const engine = listen(opts, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n          transports: [\"websocket\"]\n        });\n\n        engine.on(\"connection\", conn => {\n          conn.send(binaryData);\n        });\n\n        socket.on(\"open\", () => {\n          socket.on(\"message\", msg => {\n            for (let i = 0; i < binaryData.length; i++) {\n              const num = msg.readInt8(i);\n              expect(num).to.be(i);\n            }\n            done();\n          });\n        });\n      });\n    });\n\n    it(\"should arrive when binary data is sent as Int32Array (ws)\", done => {\n      const binaryData = new Int32Array(5);\n      for (let i = 0; i < binaryData.length; i++) {\n        binaryData[i] = (i + 100) * 9823;\n      }\n\n      const opts = { allowUpgrades: false, transports: [\"websocket\"] };\n      const engine = listen(opts, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n          transports: [\"websocket\"]\n        });\n\n        engine.on(\"connection\", conn => {\n          conn.send(binaryData);\n        });\n\n        socket.on(\"open\", () => {\n          socket.on(\"message\", msg => {\n            let i = 0,\n              ii = 0;\n            for (; ii < binaryData.length; i += 4, ii++) {\n              const num = msg.readInt32LE(i);\n              expect(num).to.be((ii + 100) * 9823);\n            }\n            done();\n          });\n        });\n      });\n    });\n\n    it(\"should arrive when binary data is sent as Int32Array, given as ArrayBuffer(ws)\", done => {\n      const binaryData = new Int32Array(5);\n      for (let i = 0; i < binaryData.length; i++) {\n        binaryData[i] = (i + 100) * 9823;\n      }\n\n      const opts = { allowUpgrades: false, transports: [\"websocket\"] };\n      const engine = listen(opts, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n          transports: [\"websocket\"]\n        });\n\n        engine.on(\"connection\", conn => {\n          conn.send(binaryData.buffer);\n        });\n\n        socket.on(\"open\", () => {\n          socket.on(\"message\", msg => {\n            let i = 0,\n              ii = 0;\n            for (; ii < binaryData.length; i += 4, ii++) {\n              const num = msg.readInt32LE(i);\n              expect(num).to.be((ii + 100) * 9823);\n            }\n            done();\n          });\n        });\n      });\n    });\n\n    it(\"should arrive when binary data is sent as Buffer (ws)\", done => {\n      const binaryData = Buffer.allocUnsafe(5);\n      for (let i = 0; i < binaryData.length; i++) {\n        binaryData.writeInt8(i, i);\n      }\n\n      const opts = { allowUpgrades: false, transports: [\"websocket\"] };\n      const engine = listen(opts, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n          transports: [\"websocket\"]\n        });\n\n        engine.on(\"connection\", conn => {\n          conn.send(binaryData);\n        });\n\n        socket.on(\"open\", () => {\n          socket.on(\"message\", msg => {\n            for (let i = 0; i < binaryData.length; i++) {\n              const num = msg.readInt8(i);\n              expect(num).to.be(i);\n            }\n            done();\n          });\n        });\n      });\n    });\n\n    it(\"should arrive when binary data sent as Buffer (polling)\", done => {\n      const binaryData = Buffer.allocUnsafe(5);\n      for (let i = 0; i < binaryData.length; i++) {\n        binaryData.writeInt8(i, i);\n      }\n\n      const opts = { allowUpgrades: false, transports: [\"polling\"] };\n      const engine = listen(opts, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n          transports: [\"polling\"]\n        });\n\n        engine.on(\"connection\", conn => {\n          conn.send(binaryData);\n        });\n\n        socket.on(\"open\", () => {\n          socket.on(\"message\", msg => {\n            for (let i = 0; i < binaryData.length; i++) {\n              const num = msg.readInt8(i);\n              expect(num).to.be(i);\n            }\n\n            done();\n          });\n        });\n      });\n    });\n\n    it(\"should arrive as ArrayBuffer if requested when binary data sent as Buffer (ws)\", done => {\n      const binaryData = Buffer.allocUnsafe(5);\n      for (let i = 0; i < binaryData.length; i++) {\n        binaryData.writeInt8(i, i);\n      }\n\n      const opts = { allowUpgrades: false, transports: [\"websocket\"] };\n      const engine = listen(opts, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n          transports: [\"websocket\"]\n        });\n        socket.binaryType = \"arraybuffer\";\n\n        engine.on(\"connection\", conn => {\n          conn.send(binaryData);\n        });\n\n        socket.on(\"open\", () => {\n          socket.on(\"message\", msg => {\n            expect(msg instanceof ArrayBuffer).to.be(true);\n            const intArray = new Int8Array(msg);\n            for (let i = 0; i < binaryData.length; i++) {\n              expect(intArray[i]).to.be(i);\n            }\n\n            done();\n          });\n        });\n      });\n    });\n\n    it(\"should arrive as ArrayBuffer if requested when binary data sent as Buffer (polling)\", done => {\n      const binaryData = Buffer.allocUnsafe(5);\n      for (let i = 0; i < binaryData.length; i++) {\n        binaryData.writeInt8(i, i);\n      }\n\n      const opts = { allowUpgrades: false, transports: [\"polling\"] };\n      const engine = listen(opts, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n          transports: [\"polling\"]\n        });\n        socket.binaryType = \"arraybuffer\";\n\n        engine.on(\"connection\", conn => {\n          conn.send(binaryData);\n        });\n\n        socket.on(\"open\", () => {\n          socket.on(\"message\", msg => {\n            expect(msg instanceof ArrayBuffer).to.be(true);\n            const intArray = new Int8Array(msg);\n            for (let i = 0; i < binaryData.length; i++) {\n              expect(intArray[i]).to.be(i);\n            }\n\n            done();\n          });\n        });\n      });\n    });\n\n    it(\"should trigger a flush/drain event\", done => {\n      const engine = listen({ allowUpgrades: false }, port => {\n        engine.on(\"connection\", socket => {\n          let totalEvents = 4;\n\n          engine.on(\"flush\", (sock, buf) => {\n            expect(sock).to.be(socket);\n            expect(buf).to.be.an(\"array\");\n            --totalEvents || done();\n          });\n          socket.on(\"flush\", buf => {\n            expect(buf).to.be.an(\"array\");\n            --totalEvents || done();\n          });\n\n          engine.on(\"drain\", sock => {\n            expect(sock).to.be(socket);\n            expect(socket.writeBuffer.length).to.be(0);\n            --totalEvents || done();\n          });\n          socket.on(\"drain\", () => {\n            expect(socket.writeBuffer.length).to.be(0);\n            --totalEvents || done();\n          });\n\n          socket.send(\"aaaa\");\n        });\n\n        eioc(\"ws://localhost:%d\".s(port));\n      });\n    });\n\n    it(\n      \"should interleave with pongs if many messages buffered \" +\n        \"after connection open\",\n      function(done) {\n        this.slow(4000);\n        this.timeout(8000);\n\n        const opts = {\n          transports: [\"websocket\"],\n          pingInterval: 200,\n          pingTimeout: 100\n        };\n\n        const engine = listen(opts, port => {\n          const messageCount = 100;\n          const messagePayload = new Array(256 * 256).join(\"a\");\n          let connection = null;\n          engine.on(\"connection\", conn => {\n            connection = conn;\n          });\n          const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n            transports: [\"websocket\"]\n          });\n          socket.on(\"open\", () => {\n            for (let i = 0; i < messageCount; i++) {\n              //            connection.send('message: ' + i);   // works\n              connection.send(messagePayload + \"|message: \" + i); // does not work\n            }\n            let receivedCount = 0;\n            socket.on(\"message\", msg => {\n              receivedCount += 1;\n              if (receivedCount === messageCount) {\n                done();\n              }\n            });\n          });\n        });\n      }\n    );\n\n    it(\"should support chinese\", done => {\n      const engine = listen({ allowUpgrades: false }, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n        const shi = \"\u77f3\u5ba4\u8a69\u58eb\u65bd\u6c0f\uff0c\u55dc\u7345\uff0c\u8a93\u98df\u5341\u7345\u3002\";\n        const shi2 = \"\u6c0f\u6642\u6642\u9069\u5e02\u8996\u7345\u3002\";\n        engine.on(\"connection\", conn => {\n          conn.send(\".\");\n          conn.send(shi);\n          conn.send(shi2);\n          conn.once(\"message\", msg0 => {\n            expect(msg0).to.be(\".\");\n            conn.once(\"message\", msg => {\n              expect(msg).to.be(shi);\n              conn.once(\"message\", msg2 => {\n                expect(msg2).to.be(shi2);\n                done();\n              });\n            });\n          });\n        });\n        socket.on(\"open\", () => {\n          socket.once(\"message\", msg0 => {\n            expect(msg0).to.be(\".\");\n            socket.once(\"message\", msg => {\n              expect(msg).to.be(shi);\n              socket.once(\"message\", msg2 => {\n                expect(msg2).to.be(shi2);\n                socket.send(\".\");\n                socket.send(shi);\n                socket.send(shi2);\n              });\n            });\n          });\n        });\n      });\n    });\n\n    it(\"should send and receive data with key and cert (polling)\", done => {\n      const srvOpts = {\n        key: fs.readFileSync(\"test/fixtures/server.key\"),\n        cert: fs.readFileSync(\"test/fixtures/server.crt\"),\n        ca: fs.readFileSync(\"test/fixtures/ca.crt\"),\n        requestCert: true,\n        rejectUnauthorized: true\n      };\n\n      const opts = {\n        key: fs.readFileSync(\"test/fixtures/client.key\"),\n        cert: fs.readFileSync(\"test/fixtures/client.crt\"),\n        ca: fs.readFileSync(\"test/fixtures/ca.crt\"),\n        transports: [\"polling\"]\n      };\n\n      const srv = https.createServer(srvOpts, (req, res) => {\n        res.writeHead(200);\n        res.end(\"hello world\\n\");\n      });\n\n      const engine = eio({\n        transports: [\"polling\"],\n        allowUpgrades: false,\n        allowEIO3: true\n      });\n      engine.attach(srv);\n      srv.listen(() => {\n        const port = srv.address().port;\n        const socket = new eioc.Socket(\"https://localhost:%d\".s(port), opts);\n\n        engine.on(\"connection\", conn => {\n          conn.on(\"message\", msg => {\n            expect(msg).to.be(\"hello\");\n            done();\n          });\n        });\n\n        socket.on(\"open\", () => {\n          socket.send(\"hello\");\n        });\n      });\n    });\n\n    it(\"should send and receive data with ca when not requiring auth (polling)\", done => {\n      const srvOpts = {\n        key: fs.readFileSync(\"test/fixtures/server.key\"),\n        cert: fs.readFileSync(\"test/fixtures/server.crt\"),\n        ca: fs.readFileSync(\"test/fixtures/ca.crt\"),\n        requestCert: true,\n        rejectUnauthorized: false\n      };\n\n      const opts = {\n        ca: fs.readFileSync(\"test/fixtures/ca.crt\"),\n        transports: [\"polling\"]\n      };\n\n      const srv = https.createServer(srvOpts, (req, res) => {\n        res.writeHead(200);\n        res.end(\"hello world\\n\");\n      });\n\n      const engine = eio({\n        transports: [\"polling\"],\n        allowUpgrades: false,\n        allowEIO3: true\n      });\n      engine.attach(srv);\n      srv.listen(() => {\n        const port = srv.address().port;\n        const socket = new eioc.Socket(\"https://localhost:%d\".s(port), opts);\n\n        engine.on(\"connection\", conn => {\n          conn.on(\"message\", msg => {\n            expect(msg).to.be(\"hello\");\n            done();\n          });\n        });\n\n        socket.on(\"open\", () => {\n          socket.send(\"hello\");\n        });\n      });\n    });\n\n    it(\"should send and receive data with key and cert (ws)\", done => {\n      const srvOpts = {\n        key: fs.readFileSync(\"test/fixtures/server.key\"),\n        cert: fs.readFileSync(\"test/fixtures/server.crt\"),\n        ca: fs.readFileSync(\"test/fixtures/ca.crt\"),\n        requestCert: true,\n        rejectUnauthorized: true\n      };\n\n      const opts = {\n        key: fs.readFileSync(\"test/fixtures/client.key\"),\n        cert: fs.readFileSync(\"test/fixtures/client.crt\"),\n        ca: fs.readFileSync(\"test/fixtures/ca.crt\"),\n        transports: [\"websocket\"]\n      };\n\n      const srv = https.createServer(srvOpts, (req, res) => {\n        res.writeHead(200);\n        res.end(\"hello world\\n\");\n      });\n\n      const engine = eio({\n        transports: [\"websocket\"],\n        allowUpgrades: false,\n        allowEIO3: true\n      });\n      engine.attach(srv);\n      srv.listen(() => {\n        const port = srv.address().port;\n        const socket = new eioc.Socket(\"https://localhost:%d\".s(port), opts);\n\n        engine.on(\"connection\", conn => {\n          conn.on(\"message\", msg => {\n            expect(msg).to.be(\"hello\");\n            done();\n          });\n        });\n\n        socket.on(\"open\", () => {\n          socket.send(\"hello\");\n        });\n      });\n    });\n\n    it(\"should send and receive data with pfx (polling)\", done => {\n      const srvOpts = {\n        key: fs.readFileSync(\"test/fixtures/server.key\"),\n        cert: fs.readFileSync(\"test/fixtures/server.crt\"),\n        ca: fs.readFileSync(\"test/fixtures/ca.crt\"),\n        requestCert: true,\n        rejectUnauthorized: true\n      };\n\n      const opts = {\n        pfx: fs.readFileSync(\"test/fixtures/client.pfx\"),\n        ca: fs.readFileSync(\"test/fixtures/ca.crt\"),\n        transports: [\"polling\"]\n      };\n\n      const srv = https.createServer(srvOpts, (req, res) => {\n        res.writeHead(200);\n        res.end(\"hello world\\n\");\n      });\n\n      const engine = eio({\n        transports: [\"polling\"],\n        allowUpgrades: false,\n        allowEIO3: true\n      });\n      engine.attach(srv);\n      srv.listen(() => {\n        const port = srv.address().port;\n        const socket = new eioc.Socket(\"https://localhost:%d\".s(port), opts);\n\n        engine.on(\"connection\", conn => {\n          conn.on(\"message\", msg => {\n            expect(msg).to.be(\"hello\");\n            done();\n          });\n        });\n\n        socket.on(\"open\", () => {\n          socket.send(\"hello\");\n        });\n      });\n    });\n\n    it(\"should send and receive data with pfx (ws)\", done => {\n      const srvOpts = {\n        key: fs.readFileSync(\"test/fixtures/server.key\"),\n        cert: fs.readFileSync(\"test/fixtures/server.crt\"),\n        ca: fs.readFileSync(\"test/fixtures/ca.crt\"),\n        requestCert: true,\n        rejectUnauthorized: true\n      };\n\n      const opts = {\n        pfx: fs.readFileSync(\"test/fixtures/client.pfx\"),\n        ca: fs.readFileSync(\"test/fixtures/ca.crt\"),\n        transports: [\"websocket\"]\n      };\n\n      const srv = https.createServer(srvOpts, (req, res) => {\n        res.writeHead(200);\n        res.end(\"hello world\\n\");\n      });\n\n      const engine = eio({\n        transports: [\"websocket\"],\n        allowUpgrades: false,\n        allowEIO3: true\n      });\n      engine.attach(srv);\n      srv.listen(() => {\n        const port = srv.address().port;\n        const socket = new eioc.Socket(\"https://localhost:%d\".s(port), opts);\n\n        engine.on(\"connection\", conn => {\n          conn.on(\"message\", msg => {\n            expect(msg).to.be(\"hello\");\n            done();\n          });\n        });\n\n        socket.on(\"open\", () => {\n          socket.send(\"hello\");\n        });\n      });\n    });\n  });\n\n  describe(\"send\", () => {\n    describe(\"writeBuffer\", () => {\n      it(\"should not empty until `drain` event (polling)\", done => {\n        listen({ allowUpgrades: false }, port => {\n          const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n            transports: [\"polling\"]\n          });\n          let totalEvents = 2;\n          socket.on(\"open\", () => {\n            socket.send(\"a\");\n            socket.send(\"b\");\n            // writeBuffer should be nonempty, with 'a' still in it\n            expect(socket.writeBuffer.length).to.eql(2);\n          });\n          socket.transport.on(\"drain\", () => {\n            expect(socket.writeBuffer.length).to.eql(--totalEvents);\n            totalEvents || done();\n          });\n        });\n      });\n\n      it(\"should not empty until `drain` event (websocket)\", done => {\n        listen({ allowUpgrades: false }, port => {\n          const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n            transports: [\"websocket\"]\n          });\n          let totalEvents = 2;\n          socket.on(\"open\", () => {\n            socket.send(\"a\");\n            socket.send(\"b\");\n            // writeBuffer should be nonempty, with 'a' still in it\n            expect(socket.writeBuffer.length).to.eql(2);\n          });\n          socket.transport.on(\"drain\", () => {\n            expect(socket.writeBuffer.length).to.eql(--totalEvents);\n            totalEvents || done();\n          });\n        });\n      });\n    });\n\n    describe(\"callback\", () => {\n      it(\"should execute in order when message sent (client) (polling)\", done => {\n        const engine = listen({ allowUpgrades: false }, port => {\n          const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n            transports: [\"polling\"]\n          });\n          let i = 0;\n          let j = 0;\n\n          engine.on(\"connection\", conn => {\n            conn.on(\"message\", msg => {\n              conn.send(msg);\n            });\n          });\n\n          socket.on(\"open\", () => {\n            socket.on(\"message\", msg => {\n              // send another packet until we've sent 3 total\n              if (++i < 3) {\n                expect(i).to.eql(j);\n                sendFn();\n              } else {\n                done();\n              }\n            });\n\n            function sendFn() {\n              socket.send(\n                j,\n                (value => {\n                  j++;\n                })(j)\n              );\n            }\n\n            sendFn();\n          });\n        });\n      });\n\n      it(\"should execute in order when message sent (client) (websocket)\", done => {\n        const engine = listen({ allowUpgrades: false }, port => {\n          const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n            transports: [\"websocket\"]\n          });\n          let i = 0;\n          let j = 0;\n\n          engine.on(\"connection\", conn => {\n            conn.on(\"message\", msg => {\n              conn.send(msg);\n            });\n          });\n\n          socket.on(\"open\", () => {\n            socket.on(\"message\", msg => {\n              // send another packet until we've sent 3 total\n              if (++i < 3) {\n                expect(i).to.eql(j);\n                sendFn();\n              } else {\n                done();\n              }\n            });\n\n            function sendFn() {\n              socket.send(\n                j,\n                (value => {\n                  j++;\n                })(j)\n              );\n            }\n\n            sendFn();\n          });\n        });\n      });\n\n      it(\"should execute in order with payloads (client) (polling)\", done => {\n        const engine = listen({ allowUpgrades: false }, port => {\n          const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n            transports: [\"polling\"]\n          });\n          let i = 0;\n          let lastCbFired = 0;\n\n          engine.on(\"connection\", conn => {\n            conn.on(\"message\", msg => {\n              conn.send(msg);\n            });\n          });\n\n          socket.on(\"open\", () => {\n            socket.on(\"message\", msg => {\n              expect(msg).to.eql(i + 1);\n              i++;\n            });\n\n            function cb(value) {\n              expect(value).to.eql(lastCbFired + 1);\n              lastCbFired = value;\n              if (value === 3) {\n                done();\n              }\n            }\n\n            // 2 and 3 will be in the same payload\n            socket.once(\"flush\", () => {\n              socket.send(2, () => {\n                cb(2);\n              });\n              socket.send(3, () => {\n                cb(3);\n              });\n            });\n\n            socket.send(1, () => {\n              cb(1);\n            });\n          });\n        });\n      });\n\n      it(\"should execute in order with payloads (client) (websocket)\", done => {\n        const engine = listen({ allowUpgrades: false }, port => {\n          const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n            transports: [\"websocket\"]\n          });\n          let i = 0;\n          let lastCbFired = 0;\n\n          engine.on(\"connection\", conn => {\n            conn.on(\"message\", msg => {\n              conn.send(msg);\n            });\n          });\n\n          socket.on(\"open\", () => {\n            socket.on(\"message\", msg => {\n              expect(msg).to.eql(i + 1);\n              i++;\n            });\n\n            function cb(value) {\n              expect(value).to.eql(lastCbFired + 1);\n              lastCbFired = value;\n              if (value === 3) {\n                done();\n              }\n            }\n\n            // 2 and 3 will be in the same payload\n            socket.once(\"flush\", () => {\n              socket.send(2, () => {\n                cb(2);\n              });\n              socket.send(3, () => {\n                cb(3);\n              });\n            });\n\n            socket.send(1, () => {\n              cb(1);\n            });\n          });\n        });\n      });\n\n      it(\"should execute when message sent (polling)\", done => {\n        const engine = listen({ allowUpgrades: false }, port => {\n          const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n            transports: [\"polling\"]\n          });\n          let i = 0;\n          let j = 0;\n\n          engine.on(\"connection\", conn => {\n            conn.send(\"a\", transport => {\n              i++;\n            });\n          });\n          socket.on(\"open\", () => {\n            socket.on(\"message\", msg => {\n              j++;\n            });\n          });\n\n          setTimeout(() => {\n            expect(i).to.be(j);\n            done();\n          }, 100);\n        });\n      });\n\n      it(\"should execute when message sent (websocket)\", done => {\n        const engine = listen({ allowUpgrades: false }, port => {\n          const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n            transports: [\"websocket\"]\n          });\n          let i = 0;\n          let j = 0;\n\n          engine.on(\"connection\", conn => {\n            conn.send(\"a\", transport => {\n              i++;\n            });\n          });\n\n          socket.on(\"open\", () => {\n            socket.on(\"message\", msg => {\n              j++;\n            });\n          });\n\n          setTimeout(() => {\n            expect(i).to.be(j);\n            done();\n          }, 100);\n        });\n      });\n\n      it(\"should execute once for each send\", done => {\n        const engine = listen(port => {\n          const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n          let a = 0;\n          let b = 0;\n          let c = 0;\n          let all = 0;\n\n          engine.on(\"connection\", conn => {\n            conn.send(\"a\");\n            conn.send(\"b\");\n            conn.send(\"c\");\n          });\n\n          socket.on(\"open\", () => {\n            socket.on(\"message\", msg => {\n              if (msg === \"a\") a++;\n              if (msg === \"b\") b++;\n              if (msg === \"c\") c++;\n\n              if (++all === 3) {\n                expect(a).to.be(1);\n                expect(b).to.be(1);\n                expect(c).to.be(1);\n                done();\n              }\n            });\n          });\n        });\n      });\n\n      it(\"should execute in multipart packet\", done => {\n        const engine = listen(port => {\n          const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n          let i = 0;\n          let j = 0;\n\n          engine.on(\"connection\", conn => {\n            conn.send(\"b\", transport => {\n              i++;\n            });\n\n            conn.send(\"a\", transport => {\n              i++;\n            });\n          });\n          socket.on(\"open\", () => {\n            socket.on(\"message\", msg => {\n              j++;\n            });\n          });\n\n          setTimeout(() => {\n            expect(i).to.be(j);\n            done();\n          }, 200);\n        });\n      });\n\n      it(\"should execute in multipart packet (polling)\", done => {\n        const engine = listen(port => {\n          const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n            transports: [\"polling\"]\n          });\n          let i = 0;\n          let j = 0;\n\n          engine.on(\"connection\", conn => {\n            conn.send(\"d\", transport => {\n              i++;\n            });\n\n            conn.send(\"c\", transport => {\n              i++;\n            });\n\n            conn.send(\"b\", transport => {\n              i++;\n            });\n\n            conn.send(\"a\", transport => {\n              i++;\n            });\n          });\n          socket.on(\"open\", () => {\n            socket.on(\"message\", msg => {\n              j++;\n            });\n          });\n\n          setTimeout(() => {\n            expect(i).to.be(j);\n            done();\n          }, 200);\n        });\n      });\n\n      it(\"should clean callback references when socket gets closed with pending callbacks\", done => {\n        const engine = listen({ allowUpgrades: false }, port => {\n          const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n            transports: [\"polling\"]\n          });\n\n          engine.on(\"connection\", conn => {\n            socket.transport.on(\"pollComplete\", () => {\n              conn.send(\"a\", transport => {\n                done(new Error(\"Test invalidation\"));\n              });\n\n              if (!conn.writeBuffer.length) {\n                done(new Error(\"Test invalidation\"));\n              }\n\n              // force to close the socket when we have one or more packet(s) in buffer\n              socket.close();\n            });\n\n            conn.on(\"close\", reason => {\n              expect(conn.packetsFn).to.be.empty();\n              expect(conn.sentCallbackFn).to.be.empty();\n              done();\n            });\n          });\n        });\n      });\n\n      it(\"should not execute when it is not actually sent (polling)\", done => {\n        const engine = listen({ allowUpgrades: false }, port => {\n          const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n            transports: [\"polling\"]\n          });\n\n          socket.transport.on(\"pollComplete\", msg => {\n            socket.close();\n          });\n\n          engine.on(\"connection\", conn => {\n            let err;\n            conn.send(\"a\");\n            conn.send(\"b\", transport => {\n              err = new Error(\"Test invalidation\");\n            });\n            conn.on(\"close\", reason => {\n              done(err);\n            });\n          });\n        });\n      });\n    });\n\n    describe(\"pre-encoded content\", () => {\n      it(\"should use the pre-encoded content\", done => {\n        engine = listen(port => {\n          client = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n            transports: [\"websocket\"]\n          });\n\n          engine.on(\"connection\", conn => {\n            conn.send(\"test\", {\n              wsPreEncoded: \"4test pre-encoded\"\n            });\n          });\n\n          client.on(\"message\", msg => {\n            expect(msg).to.be(\"test pre-encoded\");\n            done();\n          });\n        });\n      });\n    });\n  });\n\n  describe(\"packet\", () => {\n    it(\"should emit when socket receives packet\", done => {\n      const engine = listen({ allowUpgrades: false }, port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n        engine.on(\"connection\", conn => {\n          conn.on(\"packet\", packet => {\n            expect(packet.type).to.be(\"message\");\n            expect(packet.data).to.be(\"a\");\n            done();\n          });\n        });\n        socket.on(\"open\", () => {\n          socket.send(\"a\");\n        });\n      });\n    });\n\n    it(\"should emit when receives pong\", done => {\n      const engine = listen({ allowUpgrades: false, pingInterval: 4 }, port => {\n        eioc(\"ws://localhost:%d\".s(port));\n        engine.on(\"connection\", conn => {\n          conn.on(\"packet\", packet => {\n            conn.close();\n            if (process.env.EIO_CLIENT === \"3\") {\n              expect(packet.type).to.be(\"ping\");\n            } else {\n              expect(packet.type).to.be(\"pong\");\n            }\n            done();\n          });\n        });\n      });\n    });\n  });\n\n  describe(\"packetCreate\", () => {\n    it(\"should emit before socket send message\", done => {\n      const engine = listen({ allowUpgrades: false }, port => {\n        eioc(\"ws://localhost:%d\".s(port));\n        engine.on(\"connection\", conn => {\n          conn.on(\"packetCreate\", packet => {\n            expect(packet.type).to.be(\"message\");\n            expect(packet.data).to.be(\"a\");\n            done();\n          });\n          conn.send(\"a\");\n        });\n      });\n    });\n\n    it(\"should emit before send pong\", done => {\n      const engine = listen({ allowUpgrades: false, pingInterval: 4 }, port => {\n        eioc(\"ws://localhost:%d\".s(port));\n        engine.on(\"connection\", conn => {\n          conn.on(\"packetCreate\", packet => {\n            conn.close();\n            if (process.env.EIO_CLIENT === \"3\") {\n              expect(packet.type).to.be(\"pong\");\n            } else {\n              expect(packet.type).to.be(\"ping\");\n            }\n            done();\n          });\n        });\n      });\n    });\n  });\n\n  describe(\"upgrade\", () => {\n    it(\"should upgrade\", done => {\n      const engine = listen(port => {\n        // it takes both to send 50 to verify\n        let ready = 2;\n        let closed = 2;\n\n        function finish() {\n          setTimeout(() => {\n            socket.close();\n          }, 10);\n        }\n\n        // server\n        engine.on(\"connection\", conn => {\n          let lastSent = 0;\n          let lastReceived = 0;\n          let upgraded = false;\n          const interval = setInterval(() => {\n            lastSent++;\n            conn.send(lastSent);\n            if (50 === lastSent) {\n              clearInterval(interval);\n              --ready || finish();\n            }\n          }, 2);\n\n          expect(conn.request._query.transport).to.be(\"polling\");\n\n          conn.on(\"message\", msg => {\n            expect(conn.request._query).to.be.an(\"object\");\n            lastReceived++;\n            expect(msg).to.eql(lastReceived);\n          });\n\n          conn.on(\"upgrade\", to => {\n            expect(conn.request._query.transport).to.be(\"polling\");\n            upgraded = true;\n            expect(to.name).to.be(\"websocket\");\n            expect(conn.transport.name).to.be(\"websocket\");\n          });\n\n          conn.on(\"close\", reason => {\n            expect(reason).to.be(\"transport close\");\n            expect(lastSent).to.be(50);\n            expect(lastReceived).to.be(50);\n            expect(upgraded).to.be(true);\n            --closed || done();\n          });\n        });\n\n        // client\n        var socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n        socket.on(\"open\", () => {\n          let lastSent = 0;\n          let lastReceived = 0;\n          let upgrades = 0;\n          const interval = setInterval(() => {\n            lastSent++;\n            socket.send(lastSent);\n            if (50 === lastSent) {\n              clearInterval(interval);\n              --ready || finish();\n            }\n          }, 2);\n          socket.on(\"upgrading\", to => {\n            // we want to make sure for the sake of this test that we have a buffer\n            expect(to.name).to.equal(\"websocket\");\n            upgrades++;\n\n            // force send a few packets to ensure we test buffer transfer\n            lastSent++;\n            socket.send(lastSent);\n            lastSent++;\n            socket.send(lastSent);\n\n            expect(socket.writeBuffer).to.not.be.empty();\n          });\n          socket.on(\"upgrade\", to => {\n            expect(to.name).to.equal(\"websocket\");\n            upgrades++;\n          });\n          socket.on(\"message\", msg => {\n            lastReceived++;\n            expect(lastReceived).to.eql(msg);\n          });\n          socket.on(\"close\", reason => {\n            expect(reason).to.be(\"forced close\");\n            expect(lastSent).to.be(50);\n            expect(upgrades).to.be(2);\n            --closed || done();\n          });\n        });\n      });\n\n      // attach another engine to make sure it doesn't break upgrades\n      eio.attach(engine.httpServer, { path: \"/foo\" });\n    });\n  });\n\n  describe(\"http compression\", () => {\n    function getSidFromResponse(res) {\n      const c = cookieMod.parse(res.headers[\"set-cookie\"][0]);\n      return c[Object.keys(c)[0]];\n    }\n\n    it(\"should compress by default\", done => {\n      const engine = listen({ cookie: true, transports: [\"polling\"] }, port => {\n        engine.on(\"connection\", conn => {\n          const buf = Buffer.allocUnsafe(1024);\n          for (let i = 0; i < buf.length; i++) buf[i] = i % 0xff;\n          conn.send(buf);\n        });\n\n        http.get(\n          {\n            port: port,\n            path: \"/engine.io/default/?transport=polling\"\n          },\n          res => {\n            const sid = getSidFromResponse(res);\n            http.get(\n              {\n                port: port,\n                path: \"/engine.io/default/?transport=polling&sid=\" + sid,\n                headers: { \"Accept-Encoding\": \"gzip, deflate\" }\n              },\n              res => {\n                expect(res.headers[\"content-encoding\"]).to.equal(\"gzip\");\n                res\n                  .pipe(zlib.createGunzip())\n                  .on(\"error\", done)\n                  .on(\"end\", done)\n                  .resume();\n              }\n            );\n          }\n        );\n      });\n    });\n\n    it(\"should compress using deflate\", done => {\n      const engine = listen({ cookie: true, transports: [\"polling\"] }, port => {\n        engine.on(\"connection\", conn => {\n          const buf = Buffer.allocUnsafe(1024);\n          for (let i = 0; i < buf.length; i++) buf[i] = i % 0xff;\n          conn.send(buf);\n        });\n\n        http.get(\n          {\n            port: port,\n            path: \"/engine.io/default/?transport=polling\"\n          },\n          res => {\n            const sid = getSidFromResponse(res);\n            http.get(\n              {\n                port: port,\n                path: \"/engine.io/default/?transport=polling&sid=\" + sid,\n                headers: { \"Accept-Encoding\": \"deflate\" }\n              },\n              res => {\n                expect(res.headers[\"content-encoding\"]).to.equal(\"deflate\");\n                res\n                  .pipe(zlib.createDeflate())\n                  .on(\"error\", done)\n                  .on(\"end\", done)\n                  .resume();\n              }\n            );\n          }\n        );\n      });\n    });\n\n    it(\"should set threshold\", done => {\n      const engine = listen(\n        {\n          cookie: true,\n          transports: [\"polling\"],\n          httpCompression: { threshold: 0 }\n        },\n        port => {\n          engine.on(\"connection\", conn => {\n            const buf = Buffer.allocUnsafe(10);\n            for (let i = 0; i < buf.length; i++) buf[i] = i % 0xff;\n            conn.send(buf);\n          });\n\n          http.get(\n            {\n              port: port,\n              path: \"/engine.io/default/?transport=polling\"\n            },\n            res => {\n              const sid = getSidFromResponse(res);\n              http.get(\n                {\n                  port: port,\n                  path: \"/engine.io/default/?transport=polling&sid=\" + sid,\n                  headers: { \"Accept-Encoding\": \"gzip, deflate\" }\n                },\n                res => {\n                  expect(res.headers[\"content-encoding\"]).to.equal(\"gzip\");\n                  done();\n                }\n              );\n            }\n          );\n        }\n      );\n    });\n\n    it(\"should disable compression\", done => {\n      const engine = listen(\n        { cookie: true, transports: [\"polling\"], httpCompression: false },\n        port => {\n          engine.on(\"connection\", conn => {\n            const buf = Buffer.allocUnsafe(1024);\n            for (let i = 0; i < buf.length; i++) buf[i] = i % 0xff;\n            conn.send(buf);\n          });\n\n          http.get(\n            {\n              port: port,\n              path: \"/engine.io/default/?transport=polling\"\n            },\n            res => {\n              const sid = getSidFromResponse(res);\n              http.get(\n                {\n                  port: port,\n                  path: \"/engine.io/default/?transport=polling&sid=\" + sid,\n                  headers: { \"Accept-Encoding\": \"gzip, deflate\" }\n                },\n                res => {\n                  expect(res.headers[\"content-encoding\"]).to.be(undefined);\n                  done();\n                }\n              );\n            }\n          );\n        }\n      );\n    });\n\n    it(\"should disable compression per message\", done => {\n      const engine = listen({ cookie: true, transports: [\"polling\"] }, port => {\n        engine.on(\"connection\", conn => {\n          const buf = Buffer.allocUnsafe(1024);\n          for (let i = 0; i < buf.length; i++) buf[i] = i % 0xff;\n          conn.send(buf, { compress: false });\n        });\n\n        http.get(\n          {\n            port: port,\n            path: \"/engine.io/default/?transport=polling\"\n          },\n          res => {\n            const sid = getSidFromResponse(res);\n            http.get(\n              {\n                port: port,\n                path: \"/engine.io/default/?transport=polling&sid=\" + sid,\n                headers: { \"Accept-Encoding\": \"gzip, deflate\" }\n              },\n              res => {\n                expect(res.headers[\"content-encoding\"]).to.be(undefined);\n                done();\n              }\n            );\n          }\n        );\n      });\n    });\n\n    it(\"should not compress when the byte size is below threshold\", done => {\n      const engine = listen({ cookie: true, transports: [\"polling\"] }, port => {\n        engine.on(\"connection\", conn => {\n          const buf = Buffer.allocUnsafe(100);\n          for (let i = 0; i < buf.length; i++) buf[i] = i % 0xff;\n          conn.send(buf);\n        });\n\n        http.get(\n          {\n            port: port,\n            path: \"/engine.io/default/?transport=polling\"\n          },\n          res => {\n            const sid = getSidFromResponse(res);\n            http.get(\n              {\n                port: port,\n                path: \"/engine.io/default/?transport=polling&sid=\" + sid,\n                headers: { \"Accept-Encoding\": \"gzip, deflate\" }\n              },\n              res => {\n                expect(res.headers[\"content-encoding\"]).to.be(undefined);\n                done();\n              }\n            );\n          }\n        );\n      });\n    });\n  });\n\n  describe(\"permessage-deflate\", () => {\n    it(\"should set threshold\", done => {\n      const engine = listen(\n        { transports: [\"websocket\"], perMessageDeflate: { threshold: 0 } },\n        port => {\n          engine.on(\"connection\", conn => {\n            const socket = conn.transport.socket;\n            const send = socket.send;\n            socket.send = (data, opts, callback) => {\n              socket.send = send;\n              socket.send(data, opts, callback);\n\n              expect(opts.compress).to.be(true);\n              conn.close();\n              done();\n            };\n\n            const buf = Buffer.allocUnsafe(100);\n            for (let i = 0; i < buf.length; i++) buf[i] = i % 0xff;\n            conn.send(buf, { compress: true });\n          });\n          eioc(\"http://localhost:%d\".s(port), { transports: [\"websocket\"] });\n        }\n      );\n    });\n\n    it(\"should not compress when the byte size is below threshold\", done => {\n      const engine = listen(\n        { transports: [\"websocket\"], perMessageDeflate: true },\n        port => {\n          engine.on(\"connection\", conn => {\n            const socket = conn.transport.socket;\n            const send = socket.send;\n            socket.send = (data, opts, callback) => {\n              socket.send = send;\n              socket.send(data, opts, callback);\n\n              expect(opts.compress).to.be(false);\n              conn.close();\n              done();\n            };\n\n            const buf = Buffer.allocUnsafe(100);\n            for (let i = 0; i < buf.length; i++) buf[i] = i % 0xff;\n            conn.send(buf, { compress: true });\n          });\n          eioc(\"http://localhost:%d\".s(port), { transports: [\"websocket\"] });\n        }\n      );\n    });\n  });\n\n  describe(\"extraHeaders\", function() {\n    this.timeout(5000);\n\n    const headers = {\n      \"x-custom-header-for-my-project\": \"my-secret-access-token\",\n      cookie:\n        \"user_session=NI2JlCKF90aE0sJZD9ZzujtdsUqNYSBYxzlTsvdSUe35ZzdtVRGqYFr0kdGxbfc5gUOkR9RGp20GVKza; path=/; expires=Tue, 07-Apr-2015 18:18:08 GMT; secure; HttpOnly\"\n    };\n\n    function testForTransport(transport, done) {\n      const engine = listen(port => {\n        const socket = new eioc.Socket(\"ws://localhost:%d\".s(port), {\n          extraHeaders: headers,\n          transports: [transport]\n        });\n        engine.on(\"connection\", conn => {\n          for (let h in headers) {\n            expect(conn.request.headers[h]).to.equal(headers[h]);\n          }\n          done();\n        });\n        socket.on(\"open\", () => {});\n      });\n    }\n\n    it(\"should arrive from client to server via WebSockets\", done => {\n      testForTransport(\"websocket\", done);\n    });\n\n    it(\"should arrive from client to server via XMLHttpRequest\", done => {\n      testForTransport(\"polling\", done);\n    });\n  });\n\n  describe(\"response headers\", () => {\n    function testForHeaders(headers, done) {\n      const engine = listen(port => {\n        engine.on(\"connection\", conn => {\n          conn.transport.once(\"headers\", headers => {\n            expect(headers[\"X-XSS-Protection\"]).to.be(\"0\");\n            conn.close();\n            done();\n          });\n          conn.send(\"hi\");\n        });\n        eioc(\"ws://localhost:%d\".s(port), {\n          extraHeaders: headers,\n          transports: [\"polling\"]\n        });\n      });\n    }\n\n    it(\"should contain X-XSS-Protection: 0 for IE8\", done => {\n      const headers = {\n        \"user-agent\":\n          \"Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; Tablet PC 2.0)\"\n      };\n      testForHeaders(headers, done);\n    });\n\n    it(\"should contain X-XSS-Protection: 0 for IE11\", done => {\n      const headers = {\n        \"user-agent\":\n          \"Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko\"\n      };\n      testForHeaders(headers, done);\n    });\n\n    it(\"should emit a 'initial_headers' event (polling)\", done => {\n      const partialDone = createPartialDone(done, 2);\n\n      engine = listen({ cookie: true }, port => {\n        engine.on(\"initial_headers\", (headers, req) => {\n          expect(req.method).to.be(\"GET\");\n          headers[\"test\"] = \"123\";\n          headers[\"set-cookie\"] = \"mycookie=456\";\n          partialDone();\n        });\n\n        request\n          .get(\"http://localhost:%d/engine.io/\".s(port))\n          .query({ transport: \"polling\" })\n          .end((err, res) => {\n            expect(err).to.be(null);\n            expect(res.status).to.be(200);\n            expect(res.headers[\"test\"]).to.be(\"123\");\n            expect(res.headers[\"set-cookie\"].length).to.be(2);\n            expect(res.headers[\"set-cookie\"][1]).to.be(\"mycookie=456\");\n\n            const sid = JSON.parse(res.text.substring(4)).sid;\n\n            request\n              .post(\"http://localhost:%d/engine.io/\".s(port))\n              .query({ transport: \"polling\", sid })\n              .send(\"1:6\")\n              .end((err, res) => {\n                expect(err).to.be(null);\n                expect(res.status).to.be(200);\n                expect(res.headers[\"test\"]).to.be(undefined);\n                expect(res.headers[\"set-cookie\"]).to.be(undefined);\n                partialDone();\n              });\n          });\n      });\n    });\n\n    it(\"should emit a 'headers' event (polling)\", done => {\n      const partialDone = createPartialDone(done, 3);\n\n      engine = listen({ cookie: true }, port => {\n        engine.on(\"headers\", headers => {\n          headers[\"test\"] = \"123\";\n          headers[\"set-cookie\"] = \"mycookie=456\";\n          partialDone();\n        });\n\n        request\n          .get(\"http://localhost:%d/engine.io/\".s(port))\n          .query({ transport: \"polling\" })\n          .end((err, res) => {\n            expect(err).to.be(null);\n            expect(res.status).to.be(200);\n            expect(res.headers[\"test\"]).to.be(\"123\");\n            expect(res.headers[\"set-cookie\"].length).to.be(2);\n            expect(res.headers[\"set-cookie\"][1]).to.be(\"mycookie=456\");\n\n            const sid = JSON.parse(res.text.substring(4)).sid;\n\n            request\n              .post(\"http://localhost:%d/engine.io/\".s(port))\n              .query({ transport: \"polling\", sid })\n              .send(\"1:6\")\n              .end((err, res) => {\n                expect(err).to.be(null);\n                expect(res.status).to.be(200);\n                expect(res.headers[\"set-cookie\"].length).to.be(1);\n                expect(res.headers[\"set-cookie\"][0]).to.be(\"mycookie=456\");\n                partialDone();\n              });\n          });\n      });\n    });\n\n    it(\"should emit a 'initial_headers' event (websocket)\", function(done) {\n      if (process.env.EIO_WS_ENGINE === \"eiows\") {\n        this.skip();\n      }\n      const partialDone = createPartialDone(done, 2);\n\n      engine = listen({ cookie: true }, port => {\n        engine.on(\"initial_headers\", (headers, req) => {\n          expect(req.method).to.be(\"GET\");\n          headers[\"test\"] = \"123\";\n          headers[\"set-cookie\"] = \"mycookie=456\";\n          partialDone();\n        });\n\n        client = eioc(\"ws://localhost:%d\".s(port), {\n          transports: [\"websocket\"]\n        });\n\n        client.transport.ws.on(\"upgrade\", res => {\n          expect(res.headers[\"test\"]).to.be(\"123\");\n          expect(res.headers[\"set-cookie\"].length).to.be(1);\n          expect(res.headers[\"set-cookie\"][0]).to.be(\"mycookie=456\");\n          partialDone();\n        });\n      });\n    });\n\n    it(\"should emit a single 'initial_headers' event per connection\", done => {\n      const partialDone = createPartialDone(done, 2);\n\n      engine = listen(port => {\n        engine.on(\"initial_headers\", () => {\n          partialDone();\n        });\n\n        client = eioc(\"ws://localhost:%d\".s(port));\n\n        client.on(\"upgrade\", () => {\n          partialDone();\n        });\n      });\n    });\n\n    it(\"should emit several 'headers' events per connection\", function(done) {\n      if (process.env.EIO_WS_ENGINE === \"eiows\") {\n        this.skip();\n      }\n      const partialDone = createPartialDone(done, 4);\n\n      engine = listen(port => {\n        engine.on(\"headers\", () => {\n          partialDone();\n        });\n\n        client = eioc(\"ws://localhost:%d\".s(port));\n\n        client.on(\"upgrade\", () => {\n          partialDone();\n        });\n      });\n    });\n  });\n\n  describe(\"cors\", () => {\n    it(\"should allow CORS from the current origin (preflight request)\", done => {\n      listen(\n        { cors: { origin: true, headers: [\"my-header\"], credentials: true } },\n        port => {\n          request\n            .options(\"http://localhost:%d/engine.io/default/\".s(port))\n            .set(\"Origin\", \"http://engine.io\")\n            .query({ transport: \"polling\" })\n            .end((err, res) => {\n              expect(err).to.be(null);\n              expect(res.status).to.be(204);\n              expect(res.body).to.be.empty();\n              expect(res.header[\"access-control-allow-origin\"]).to.be(\n                \"http://engine.io\"\n              );\n              expect(res.header[\"access-control-allow-methods\"]).to.be(\n                \"GET,HEAD,PUT,PATCH,POST,DELETE\"\n              );\n              expect(res.header[\"access-control-allow-headers\"]).to.be(\n                \"my-header\"\n              );\n              expect(res.header[\"access-control-allow-credentials\"]).to.be(\n                \"true\"\n              );\n              done();\n            });\n        }\n      );\n    });\n\n    it(\"should allow CORS from the current origin (actual request)\", done => {\n      listen(\n        { cors: { origin: true, headers: [\"my-header\"], credentials: true } },\n        port => {\n          request\n            .get(\"http://localhost:%d/engine.io/default/\".s(port))\n            .set(\"Origin\", \"http://engine.io\")\n            .query({ transport: \"polling\" })\n            .end((err, res) => {\n              expect(err).to.be(null);\n              expect(res.status).to.be(200);\n              expect(res.body).to.be.empty();\n              expect(res.header[\"access-control-allow-origin\"]).to.be(\n                \"http://engine.io\"\n              );\n              expect(res.header[\"access-control-allow-methods\"]).to.be(\n                undefined\n              );\n              expect(res.header[\"access-control-allow-headers\"]).to.be(\n                undefined\n              );\n              expect(res.header[\"access-control-allow-credentials\"]).to.be(\n                \"true\"\n              );\n              done();\n            });\n        }\n      );\n    });\n\n    it(\"should disallow CORS from a bad origin\", done => {\n      listen(\n        {\n          cors: {\n            origin: [\"http://good-domain.com\"]\n          }\n        },\n        port => {\n          request\n            .options(\"http://localhost:%d/engine.io/default/\".s(port))\n            .set(\"Origin\", \"http://bad-domain.com\")\n            .query({ transport: \"polling\" })\n            .end((err, res) => {\n              expect(err).to.be(null);\n              expect(res.status).to.be(204);\n              expect(res.body).to.be.empty();\n              expect(res.header[\"access-control-allow-origin\"]).to.be(\n                undefined\n              );\n              expect(res.header[\"access-control-allow-credentials\"]).to.be(\n                undefined\n              );\n              done();\n            });\n        }\n      );\n    });\n\n    it(\"should forward the configuration to the cors module\", done => {\n      listen(\n        {\n          cors: {\n            origin: \"http://good-domain.com\",\n            methods: [\"GET\", \"PUT\", \"POST\"],\n            allowedHeaders: [\"my-header\"],\n            exposedHeaders: [\"my-exposed-header\"],\n            credentials: true,\n            maxAge: 123,\n            optionsSuccessStatus: 200\n          }\n        },\n        port => {\n          request\n            .options(\"http://localhost:%d/engine.io/default/\".s(port))\n            .set(\"Origin\", \"http://good-domain.com\")\n            .query({ transport: \"polling\" })\n            .end((err, res) => {\n              expect(err).to.be(null);\n              expect(res.status).to.be(200);\n              expect(res.body).to.be.empty();\n              expect(res.header[\"access-control-allow-origin\"]).to.be(\n                \"http://good-domain.com\"\n              );\n              expect(res.header[\"access-control-allow-methods\"]).to.be(\n                \"GET,PUT,POST\"\n              );\n              expect(res.header[\"access-control-allow-headers\"]).to.be(\n                \"my-header\"\n              );\n              expect(res.header[\"access-control-expose-headers\"]).to.be(\n                \"my-exposed-header\"\n              );\n              expect(res.header[\"access-control-allow-credentials\"]).to.be(\n                \"true\"\n              );\n              expect(res.header[\"access-control-max-age\"]).to.be(\"123\");\n              done();\n            });\n        }\n      );\n    });\n  });\n\n  describe(\"wsEngine option\", () => {\n    it(\"should allow loading of other websocket server implementation like eiows\", done => {\n      const engine = listen(\n        { allowUpgrades: false, wsEngine: require(\"eiows\").Server },\n        port => {\n          expect(engine.ws instanceof require(\"eiows\").Server).to.be.ok();\n          const socket = new eioc.Socket(\"ws://localhost:%d\".s(port));\n          engine.on(\"connection\", conn => {\n            conn.send(\"a\");\n          });\n          socket.on(\"open\", () => {\n            socket.on(\"message\", msg => {\n              expect(msg).to.be(\"a\");\n              done();\n            });\n          });\n        }\n      );\n    });\n  });\n\n  describe(\"remoteAddress\", () => {\n    it(\"should be defined (polling)\", done => {\n      const engine = listen({ transports: [\"polling\"] }, port => {\n        eioc(\"ws://localhost:%d\".s(port), { transports: [\"polling\"] });\n        engine.on(\"connection\", socket => {\n          expect(socket.remoteAddress).to.be(\"::ffff:127.0.0.1\");\n          done();\n        });\n      });\n    });\n\n    it(\"should be defined (ws)\", done => {\n      const engine = listen({ transports: [\"websocket\"] }, port => {\n        eioc(\"ws://localhost:%d\".s(port), { transports: [\"websocket\"] });\n        engine.on(\"connection\", socket => {\n          expect(socket.remoteAddress).to.be(\"::ffff:127.0.0.1\");\n          done();\n        });\n      });\n    });\n  });\n});\n"], "filenames": ["lib/server.js", "test/server.js"], "buggy_code_start_loc": [457, 158], "buggy_code_end_loc": [460, 158], "fixing_code_start_loc": [456, 159], "fixing_code_end_loc": [456, 199], "type": "CWE-754", "message": "Engine.IO is the implementation of transport-based cross-browser/cross-device bi-directional communication layer for Socket.IO. A specially crafted HTTP request can trigger an uncaught exception on the Engine.IO server, thus killing the Node.js process. This impacts all the users of the `engine.io` package starting from version `4.0.0`, including those who uses depending packages like `socket.io`. Versions prior to `4.0.0` are not impacted. A fix has been released for each major branch, namely `4.1.2` for the `4.x.x` branch, `5.2.1` for the `5.x.x` branch, and `6.1.1` for the `6.x.x` branch. There is no known workaround except upgrading to a safe version.", "other": {"cve": {"id": "CVE-2022-21676", "sourceIdentifier": "security-advisories@github.com", "published": "2022-01-12T19:15:09.217", "lastModified": "2023-02-10T16:23:45.350", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Engine.IO is the implementation of transport-based cross-browser/cross-device bi-directional communication layer for Socket.IO. A specially crafted HTTP request can trigger an uncaught exception on the Engine.IO server, thus killing the Node.js process. This impacts all the users of the `engine.io` package starting from version `4.0.0`, including those who uses depending packages like `socket.io`. Versions prior to `4.0.0` are not impacted. A fix has been released for each major branch, namely `4.1.2` for the `4.x.x` branch, `5.2.1` for the `5.x.x` branch, and `6.1.1` for the `6.x.x` branch. There is no known workaround except upgrading to a safe version."}, {"lang": "es", "value": "Engine.IO es la implementaci\u00f3n de la capa de comunicaci\u00f3n bidireccional entre navegadores y dispositivos para Socket.IO. Una petici\u00f3n HTTP especialmente dise\u00f1ada puede desencadenar una excepci\u00f3n no capturada en el servidor de Engine.IO, matando as\u00ed el proceso de Node.js. Esto afecta a todos los usuarios del paquete \"engine.io\" a partir de la versi\u00f3n \"4.0.0\", incluyendo aquellos que usan paquetes dependientes como \"socket.io\". Las versiones anteriores a \"4.0.0\" no est\u00e1n afectadas. Ha sido publicado una correcci\u00f3n para cada rama principal, a saber, \"4.1.2\" para la rama \"4.x.x\", \"5.2.1\" para la rama \"5.x.x\", y \"6.1.1\" para la rama \"6.x.x\". No se presenta ninguna medida de mitigaci\u00f3n conocida, excepto la actualizaci\u00f3n a una versi\u00f3n segura"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-754"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-754"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:socket:engine.io:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "4.0.0", "versionEndExcluding": "4.1.2", "matchCriteriaId": "94FFE6AA-08E1-42B0-9960-37358EA89887"}, {"vulnerable": true, "criteria": "cpe:2.3:a:socket:engine.io:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "5.0.0", "versionEndExcluding": "5.2.1", "matchCriteriaId": "81ACF961-FC3A-492B-B668-B5CEBCB47033"}, {"vulnerable": true, "criteria": "cpe:2.3:a:socket:engine.io:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "6.0.0", "versionEndExcluding": "6.1.1", "matchCriteriaId": "A6A747F1-20E1-4B28-A077-8720EB785243"}]}]}], "references": [{"url": "https://github.com/socketio/engine.io/commit/66f889fc1d966bf5bfa0de1939069153643874ab", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/socketio/engine.io/commit/a70800d7e96da32f6e6622804ef659ebc58659db", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/socketio/engine.io/commit/c0e194d44933bd83bf9a4b126fca68ba7bf5098c", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/socketio/engine.io/releases/tag/4.1.2", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/socketio/engine.io/releases/tag/5.2.1", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/socketio/engine.io/releases/tag/6.1.1", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/socketio/engine.io/security/advisories/GHSA-273r-mgr4-v34f", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20220209-0002/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/socketio/engine.io/commit/66f889fc1d966bf5bfa0de1939069153643874ab"}}