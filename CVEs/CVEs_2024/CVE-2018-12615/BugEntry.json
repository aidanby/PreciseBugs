{"buggy_code": ["/*\n *  Phusion Passenger - https://www.phusionpassenger.com/\n *  Copyright (c) 2018 Phusion Holding B.V.\n *\n *  \"Passenger\", \"Phusion Passenger\" and \"Union Station\" are registered\n *  trademarks of Phusion Holding B.V.\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"Software\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/param.h>\n#include <cstdio>\n#include <cstdlib>\n#include <cerrno>\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <grp.h>\n\n#include <string>\n#include <boost/scoped_array.hpp>\n\n#include <Constants.h>\n#include <ProcessManagement/Utils.h>\n#include <Utils/OptionParsing.h>\n#include <Utils/StrIntUtils.h>\n\nnamespace Passenger {\nnamespace ExecHelper {\n\nusing namespace std;\n\n\nstruct Options {\n\tstring user;\n\tint programArgStart;\n\n\tOptions()\n\t\t: programArgStart(2)\n\t\t{ }\n};\n\nstatic void\nusage() {\n\t// ....|---------------Keep output within standard terminal width (80 chars)------------|\n\tprintf(\"Usage: \" AGENT_EXE \" exec-helper [OPTIONS...] <PROGRAM> [ARGS...]\\n\");\n\tprintf(\"Executes the given program under a specific environment.\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"Options:\\n\");\n\tprintf(\"  --user <USER>   Execute as the given user. The GID will be set to the\\n\");\n\tprintf(\"                  user's primary group. Supplementary groups will also\\n\");\n\tprintf(\"                  be set.\\n\");\n\tprintf(\"  --help          Show this help message.\\n\");\n}\n\nstatic bool\nparseOption(int argc, const char *argv[], int &i, Options &options) {\n\tOptionParser p(usage);\n\n\tif (p.isValueFlag(argc, i, argv[i], '\\0', \"--user\")) {\n\t\toptions.user = argv[i + 1];\n\t\ti += 2;\n\t} else {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic bool\nparseOptions(int argc, const char *argv[], Options &options) {\n\tOptionParser p(usage);\n\tint i = 2;\n\n\twhile (i < argc) {\n\t\tif (parseOption(argc, argv, i, options)) {\n\t\t\tcontinue;\n\t\t} else if (p.isFlag(argv[i], 'h', \"--help\")) {\n\t\t\tusage();\n\t\t\texit(0);\n\t\t} else if (*argv[i] == '-') {\n\t\t\tfprintf(stderr, \"ERROR: unrecognized argument %s. Please type \"\n\t\t\t\t\"'%s exec-helper --help' for usage.\\n\", argv[i], argv[0]);\n\t\t\texit(1);\n\t\t} else {\n\t\t\toptions.programArgStart = i;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic string\ndescribeCommand(int argc, const char *argv[], const Options &options) {\n\tstring result = \"'\";\n\tresult.append(argv[options.programArgStart]);\n\tresult.append(\"'\");\n\n\tif (argc > options.programArgStart + 1) {\n\t\tresult.append(\" (with params '\");\n\n\t\tint i = options.programArgStart + 1;\n\t\twhile (i < argc) {\n\t\t\tif (i != options.programArgStart + 1) {\n\t\t\t\tresult.append(\" \");\n\t\t\t}\n\t\t\tresult.append(argv[i]);\n\t\t\ti++;\n\t\t}\n\n\t\tresult.append(\"')\");\n\t}\n\n\treturn result;\n}\n\nstatic void\nreportGetpwuidError(const string &user, int e) {\n\tif (e == 0) {\n\t\tfprintf(stderr,\n\t\t\t\"ERROR: Cannot lookup up system user database entry for user '%s':\"\n\t\t\t\" user does not exist\\n\", user.c_str());\n\t} else {\n\t\tfprintf(stderr,\n\t\t\t\"ERROR: Cannot lookup up system user database entry for user '%s':\"\n\t\t\t\" %s (errno=%d)\\n\",\n\t\t\tuser.c_str(), strerror(e), e);\n\t}\n}\n\nstatic void\nlookupUserGroup(const string &user, uid_t *uid, struct passwd **userInfo, gid_t *gid) {\n\terrno = 0;\n\t*userInfo = getpwnam(user.c_str());\n\tif (*userInfo == NULL) {\n\t\tif (looksLikePositiveNumber(user)) {\n\t\t\tint e = errno;\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Warning: error looking up system user database\"\n\t\t\t\t\" entry for user '%s': %s (errno=%d)\\n\",\n\t\t\t\tuser.c_str(), strerror(e), e);\n\t\t\t*uid = (uid_t) atoi(user.c_str());\n\t\t\t*userInfo = getpwuid(*uid);\n\t\t\tif (*userInfo == NULL) {\n\t\t\t\treportGetpwuidError(user, errno);\n\t\t\t\texit(1);\n\t\t\t} else {\n\t\t\t\t*gid = (*userInfo)->pw_gid;\n\t\t\t}\n\t\t} else {\n\t\t\treportGetpwuidError(user, errno);\n\t\t\texit(1);\n\t\t}\n\t} else {\n\t\t*uid = (*userInfo)->pw_uid;\n\t\t*gid = (*userInfo)->pw_gid;\n\t}\n}\n\nstatic void\nswitchGroup(uid_t uid, const struct passwd *userInfo, gid_t gid) {\n\tif (userInfo != NULL) {\n\t\tbool setgroupsCalled = false;\n\n\t\t#if defined(__linux__) || defined(__APPLE__) || defined(__FreeBSD__)\n\t\t\t#ifdef __APPLE__\n\t\t\t\tint groups[1024];\n\t\t\t\tint ngroups = sizeof(groups) / sizeof(int);\n\t\t\t#else\n\t\t\t\tgid_t groups[1024];\n\t\t\t\tint ngroups = sizeof(groups) / sizeof(gid_t);\n\t\t\t#endif\n\t\t\tboost::scoped_array<gid_t> gidset;\n\n\t\t\tint ret = getgrouplist(userInfo->pw_name, gid,\n\t\t\t\tgroups, &ngroups);\n\t\t\tif (ret == -1) {\n\t\t\t\tint e = errno;\n\t\t\t\tfprintf(stderr, \"ERROR: getgrouplist(%s, %d) failed: %s (errno=%d)\\n\",\n\t\t\t\t\tuserInfo->pw_name, (int) gid, strerror(e), e);\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tif (ngroups <= NGROUPS_MAX) {\n\t\t\t\tsetgroupsCalled = true;\n\t\t\t\tgidset.reset(new gid_t[ngroups]);\n\t\t\t\tif (setgroups(ngroups, gidset.get()) == -1) {\n\t\t\t\t\tint e = errno;\n\t\t\t\t\tfprintf(stderr, \"ERROR: setgroups(%d, ...) failed: %s (errno=%d)\\n\",\n\t\t\t\t\t\tngroups, strerror(e), e);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t#endif\n\n\t\tif (!setgroupsCalled && initgroups(userInfo->pw_name, gid) == -1) {\n\t\t\tint e = errno;\n\t\t\tfprintf(stderr, \"ERROR: initgroups(%s, %d) failed: %s (errno=%d)\\n\",\n\t\t\t\tuserInfo->pw_name, (int) gid, strerror(e), e);\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif (setgid(gid) == -1) {\n\t\tint e = errno;\n\t\tfprintf(stderr, \"ERROR: setgid(%d) failed: %s (errno=%d)\\n\",\n\t\t\t(int) gid, strerror(e), e);\n\t\texit(1);\n\t}\n}\n\nstatic void\nswitchUser(uid_t uid, const struct passwd *userInfo) {\n\tif (setuid(uid) == -1) {\n\t\tint e = errno;\n\t\tfprintf(stderr, \"setuid(%d) failed: %s (errno=%d)\\n\",\n\t\t\t(int) uid, strerror(e), e);\n\t\texit(1);\n\t}\n\tif (userInfo != NULL) {\n\t\tsetenv(\"USER\", userInfo->pw_name, 1);\n\t\tsetenv(\"LOGNAME\", userInfo->pw_name, 1);\n\t\tsetenv(\"SHELL\", userInfo->pw_shell, 1);\n\t\tsetenv(\"HOME\", userInfo->pw_dir, 1);\n\t} else {\n\t\tunsetenv(\"USER\");\n\t\tunsetenv(\"LOGNAME\");\n\t\tunsetenv(\"SHELL\");\n\t\tunsetenv(\"HOME\");\n\t}\n}\n\nint\nexecHelperMain(int argc, char *argv[]) {\n\tif (argc < 3) {\n\t\tusage();\n\t\texit(1);\n\t}\n\n\tOptions options;\n\tif (!parseOptions(argc, (const char **) argv, options)) {\n\t\tfprintf(stderr, \"Error parsing arguments.\\n\");\n\t\tusage();\n\t\texit(1);\n\t}\n\n\tresetSignalHandlersAndMask();\n\tdisableMallocDebugging();\n\n\tif (!options.user.empty()) {\n\t\tstruct passwd *userInfo;\n\t\tuid_t uid;\n\t\tgid_t gid;\n\n\t\tlookupUserGroup(options.user, &uid, &userInfo, &gid);\n\t\tswitchGroup(uid, userInfo, gid);\n\t\tswitchUser(uid, userInfo);\n\t}\n\n\texecvp(argv[options.programArgStart],\n\t\t(char * const *) &argv[options.programArgStart]);\n\tint e = errno;\n\tfprintf(stderr, \"ERROR: unable to execute %s: %s (errno=%d)\\n\",\n\t\tdescribeCommand(argc, (const char **) argv, options).c_str(),\n\t\tstrerror(e),\n\t\te);\n\treturn 1;\n}\n\n\n} // namespace ExecHelper\n} // namespace Passenger\n\n\nint\nexecHelperMain(int argc, char *argv[]) {\n\treturn Passenger::ExecHelper::execHelperMain(argc, argv);\n}\n"], "fixing_code": ["/*\n *  Phusion Passenger - https://www.phusionpassenger.com/\n *  Copyright (c) 2018 Phusion Holding B.V.\n *\n *  \"Passenger\", \"Phusion Passenger\" and \"Union Station\" are registered\n *  trademarks of Phusion Holding B.V.\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"Software\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/param.h>\n#include <cstdio>\n#include <cstdlib>\n#include <cerrno>\n#include <limits.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <grp.h>\n\n#include <string>\n#include <boost/scoped_array.hpp>\n\n#include <Constants.h>\n#include <ProcessManagement/Utils.h>\n#include <Utils/OptionParsing.h>\n#include <Utils/StrIntUtils.h>\n\nnamespace Passenger {\nnamespace ExecHelper {\n\nusing namespace std;\n\n\nstruct Options {\n\tstring user;\n\tint programArgStart;\n\n\tOptions()\n\t\t: programArgStart(2)\n\t\t{ }\n};\n\nstatic void\nusage() {\n\t// ....|---------------Keep output within standard terminal width (80 chars)------------|\n\tprintf(\"Usage: \" AGENT_EXE \" exec-helper [OPTIONS...] <PROGRAM> [ARGS...]\\n\");\n\tprintf(\"Executes the given program under a specific environment.\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"Options:\\n\");\n\tprintf(\"  --user <USER>   Execute as the given user. The GID will be set to the\\n\");\n\tprintf(\"                  user's primary group. Supplementary groups will also\\n\");\n\tprintf(\"                  be set.\\n\");\n\tprintf(\"  --help          Show this help message.\\n\");\n}\n\nstatic bool\nparseOption(int argc, const char *argv[], int &i, Options &options) {\n\tOptionParser p(usage);\n\n\tif (p.isValueFlag(argc, i, argv[i], '\\0', \"--user\")) {\n\t\toptions.user = argv[i + 1];\n\t\ti += 2;\n\t} else {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic bool\nparseOptions(int argc, const char *argv[], Options &options) {\n\tOptionParser p(usage);\n\tint i = 2;\n\n\twhile (i < argc) {\n\t\tif (parseOption(argc, argv, i, options)) {\n\t\t\tcontinue;\n\t\t} else if (p.isFlag(argv[i], 'h', \"--help\")) {\n\t\t\tusage();\n\t\t\texit(0);\n\t\t} else if (*argv[i] == '-') {\n\t\t\tfprintf(stderr, \"ERROR: unrecognized argument %s. Please type \"\n\t\t\t\t\"'%s exec-helper --help' for usage.\\n\", argv[i], argv[0]);\n\t\t\texit(1);\n\t\t} else {\n\t\t\toptions.programArgStart = i;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic string\ndescribeCommand(int argc, const char *argv[], const Options &options) {\n\tstring result = \"'\";\n\tresult.append(argv[options.programArgStart]);\n\tresult.append(\"'\");\n\n\tif (argc > options.programArgStart + 1) {\n\t\tresult.append(\" (with params '\");\n\n\t\tint i = options.programArgStart + 1;\n\t\twhile (i < argc) {\n\t\t\tif (i != options.programArgStart + 1) {\n\t\t\t\tresult.append(\" \");\n\t\t\t}\n\t\t\tresult.append(argv[i]);\n\t\t\ti++;\n\t\t}\n\n\t\tresult.append(\"')\");\n\t}\n\n\treturn result;\n}\n\nstatic void\nreportGetpwuidError(const string &user, int e) {\n\tif (e == 0) {\n\t\tfprintf(stderr,\n\t\t\t\"ERROR: Cannot lookup up system user database entry for user '%s':\"\n\t\t\t\" user does not exist\\n\", user.c_str());\n\t} else {\n\t\tfprintf(stderr,\n\t\t\t\"ERROR: Cannot lookup up system user database entry for user '%s':\"\n\t\t\t\" %s (errno=%d)\\n\",\n\t\t\tuser.c_str(), strerror(e), e);\n\t}\n}\n\nstatic void\nlookupUserGroup(const string &user, uid_t *uid, struct passwd **userInfo, gid_t *gid) {\n\terrno = 0;\n\t*userInfo = getpwnam(user.c_str());\n\tif (*userInfo == NULL) {\n\t\tif (looksLikePositiveNumber(user)) {\n\t\t\tint e = errno;\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Warning: error looking up system user database\"\n\t\t\t\t\" entry for user '%s': %s (errno=%d)\\n\",\n\t\t\t\tuser.c_str(), strerror(e), e);\n\t\t\t*uid = (uid_t) atoi(user.c_str());\n\t\t\t*userInfo = getpwuid(*uid);\n\t\t\tif (*userInfo == NULL) {\n\t\t\t\treportGetpwuidError(user, errno);\n\t\t\t\texit(1);\n\t\t\t} else {\n\t\t\t\t*gid = (*userInfo)->pw_gid;\n\t\t\t}\n\t\t} else {\n\t\t\treportGetpwuidError(user, errno);\n\t\t\texit(1);\n\t\t}\n\t} else {\n\t\t*uid = (*userInfo)->pw_uid;\n\t\t*gid = (*userInfo)->pw_gid;\n\t}\n}\n\nstatic void\nswitchGroup(uid_t uid, const struct passwd *userInfo, gid_t gid) {\n\tif (userInfo != NULL) {\n\t\tbool setgroupsCalled = false;\n\n\t\t#if defined(__linux__) || defined(__APPLE__) || defined(__FreeBSD__)\n\t\t\t#ifdef __APPLE__\n\t\t\t\tint groups[1024];\n\t\t\t\tint ngroups = sizeof(groups) / sizeof(int);\n\t\t\t#else\n\t\t\t\tgid_t groups[1024];\n\t\t\t\tint ngroups = sizeof(groups) / sizeof(gid_t);\n\t\t\t#endif\n\t\t\tboost::scoped_array<gid_t> gidset;\n\n\t\t\tint ret = getgrouplist(userInfo->pw_name, gid,\n\t\t\t\tgroups, &ngroups);\n\t\t\tif (ret == -1) {\n\t\t\t\tint e = errno;\n\t\t\t\tfprintf(stderr, \"ERROR: getgrouplist(%s, %d) failed: %s (errno=%d)\\n\",\n\t\t\t\t\tuserInfo->pw_name, (int) gid, strerror(e), e);\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tif (ngroups <= NGROUPS_MAX) {\n\t\t\t\tsetgroupsCalled = true;\n\t\t\t\tgidset.reset(new gid_t[ngroups]);\n\t\t\t\tfor (int i = 0; i < ngroups; i++) {\n\t\t\t\t\tgidset[i] = groups[i];\n\t\t\t\t}\n\t\t\t\tif (setgroups(ngroups, gidset.get()) == -1) {\n\t\t\t\t\tint e = errno;\n\t\t\t\t\tfprintf(stderr, \"ERROR: setgroups(%d, ...) failed: %s (errno=%d)\\n\",\n\t\t\t\t\t\tngroups, strerror(e), e);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t#endif\n\n\t\tif (!setgroupsCalled && initgroups(userInfo->pw_name, gid) == -1) {\n\t\t\tint e = errno;\n\t\t\tfprintf(stderr, \"ERROR: initgroups(%s, %d) failed: %s (errno=%d)\\n\",\n\t\t\t\tuserInfo->pw_name, (int) gid, strerror(e), e);\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif (setgid(gid) == -1) {\n\t\tint e = errno;\n\t\tfprintf(stderr, \"ERROR: setgid(%d) failed: %s (errno=%d)\\n\",\n\t\t\t(int) gid, strerror(e), e);\n\t\texit(1);\n\t}\n}\n\nstatic void\nswitchUser(uid_t uid, const struct passwd *userInfo) {\n\tif (setuid(uid) == -1) {\n\t\tint e = errno;\n\t\tfprintf(stderr, \"setuid(%d) failed: %s (errno=%d)\\n\",\n\t\t\t(int) uid, strerror(e), e);\n\t\texit(1);\n\t}\n\tif (userInfo != NULL) {\n\t\tsetenv(\"USER\", userInfo->pw_name, 1);\n\t\tsetenv(\"LOGNAME\", userInfo->pw_name, 1);\n\t\tsetenv(\"SHELL\", userInfo->pw_shell, 1);\n\t\tsetenv(\"HOME\", userInfo->pw_dir, 1);\n\t} else {\n\t\tunsetenv(\"USER\");\n\t\tunsetenv(\"LOGNAME\");\n\t\tunsetenv(\"SHELL\");\n\t\tunsetenv(\"HOME\");\n\t}\n}\n\nint\nexecHelperMain(int argc, char *argv[]) {\n\tif (argc < 3) {\n\t\tusage();\n\t\texit(1);\n\t}\n\n\tOptions options;\n\tif (!parseOptions(argc, (const char **) argv, options)) {\n\t\tfprintf(stderr, \"Error parsing arguments.\\n\");\n\t\tusage();\n\t\texit(1);\n\t}\n\n\tresetSignalHandlersAndMask();\n\tdisableMallocDebugging();\n\n\tif (!options.user.empty()) {\n\t\tstruct passwd *userInfo;\n\t\tuid_t uid;\n\t\tgid_t gid;\n\n\t\tlookupUserGroup(options.user, &uid, &userInfo, &gid);\n\t\tswitchGroup(uid, userInfo, gid);\n\t\tswitchUser(uid, userInfo);\n\t}\n\n\texecvp(argv[options.programArgStart],\n\t\t(char * const *) &argv[options.programArgStart]);\n\tint e = errno;\n\tfprintf(stderr, \"ERROR: unable to execute %s: %s (errno=%d)\\n\",\n\t\tdescribeCommand(argc, (const char **) argv, options).c_str(),\n\t\tstrerror(e),\n\t\te);\n\treturn 1;\n}\n\n\n} // namespace ExecHelper\n} // namespace Passenger\n\n\nint\nexecHelperMain(int argc, char *argv[]) {\n\treturn Passenger::ExecHelper::execHelperMain(argc, argv);\n}\n"], "filenames": ["src/agent/ExecHelper/ExecHelperMain.cpp"], "buggy_code_start_loc": [203], "buggy_code_end_loc": [203], "fixing_code_start_loc": [204], "fixing_code_end_loc": [207], "type": "CWE-732", "message": "An issue was discovered in switchGroup() in agent/ExecHelper/ExecHelperMain.cpp in Phusion Passenger before 5.3.2. The set of groups (gidset) is not set correctly, leaving it up to randomness (i.e., uninitialized memory) which supplementary groups are actually being set while lowering privileges.", "other": {"cve": {"id": "CVE-2018-12615", "sourceIdentifier": "cve@mitre.org", "published": "2018-06-21T15:29:00.367", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in switchGroup() in agent/ExecHelper/ExecHelperMain.cpp in Phusion Passenger before 5.3.2. The set of groups (gidset) is not set correctly, leaving it up to randomness (i.e., uninitialized memory) which supplementary groups are actually being set while lowering privileges."}, {"lang": "es", "value": "Se ha descubierto un problema en switchGroup() en agent/ExecHelper/ExecHelperMain.cpp en Phusion Passenger en versiones anteriores a la 5.3.2. El conjunto de grupos (gidset) no est\u00e1 configurado correctamente, lo que hace que sea aleatorio (p. ej. la memoria no inicializada) decidir qu\u00e9 grupos suplementarios se est\u00e1n estableciendo mientras se bajan los privilegios."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-732"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:phusion:passenger:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.3.2", "matchCriteriaId": "9EF34C59-909A-4C72-B19B-2C68C566856F"}]}]}], "references": [{"url": "https://github.com/phusion/passenger/commit/4e97fdb86d0a0141ec9a052c6e691fcd07bb45c8", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/phusion/passenger/commit/4e97fdb86d0a0141ec9a052c6e691fcd07bb45c8"}}