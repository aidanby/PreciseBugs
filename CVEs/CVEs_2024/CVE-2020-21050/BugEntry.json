{"buggy_code": ["/*\n * This file is derived from \"stb_image.h\" that is in public domain.\n * https://github.com/nothings/stb\n *\n * Hayaki Saito <saitoha@me.com> modified this and re-licensed\n * it under the MIT license.\n *\n * Copyright (c) 2014-2018 Hayaki Saito\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n#include \"config.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include \"frame.h\"\n#include \"fromgif.h\"\n\n/*\n * gif_context_t struct and start_xxx functions\n *\n * gif_context_t structure is our basic context used by all images, so it\n * contains all the IO context, plus some basic image information\n */\ntypedef struct\n{\n   unsigned int img_x, img_y;\n   int img_n, img_out_n;\n\n   int buflen;\n   unsigned char buffer_start[128];\n\n   unsigned char *img_buffer, *img_buffer_end;\n   unsigned char *img_buffer_original;\n} gif_context_t;\n\ntypedef struct\n{\n   signed short prefix;\n   unsigned char first;\n   unsigned char suffix;\n} gif_lzw;\n\ntypedef struct\n{\n   int w, h;\n   unsigned char *out;  /* output buffer (always 4 components) */\n   int flags, bgindex, ratio, transparent, eflags;\n   unsigned char pal[256][3];\n   unsigned char lpal[256][3];\n   gif_lzw codes[4096];\n   unsigned char *color_table;\n   int parse, step;\n   int lflags;\n   int start_x, start_y;\n   int max_x, max_y;\n   int cur_x, cur_y;\n   int line_size;\n   int loop_count;\n   int delay;\n   int is_multiframe;\n   int is_terminated;\n} gif_t;\n\n\n/* initialize a memory-decode context */\nstatic unsigned char\ngif_get8(gif_context_t *s)\n{\n    if (s->img_buffer < s->img_buffer_end) {\n        return *s->img_buffer++;\n    }\n    return 0;\n}\n\n\nstatic int\ngif_get16le(gif_context_t *s)\n{\n    int z = gif_get8(s);\n    return z + (gif_get8(s) << 8);\n}\n\n\nstatic void\ngif_parse_colortable(\n    gif_context_t /* in */ *s,\n    unsigned char       /* in */ pal[256][3],\n    int           /* in */ num_entries)\n{\n    int i;\n\n    for (i = 0; i < num_entries; ++i) {\n        pal[i][2] = gif_get8(s);\n        pal[i][1] = gif_get8(s);\n        pal[i][0] = gif_get8(s);\n    }\n}\n\n\nstatic SIXELSTATUS\ngif_load_header(\n    gif_context_t /* in */ *s,\n    gif_t         /* in */ *g)\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n    unsigned char version;\n    if (gif_get8(s) != 'G') {\n        goto end;\n    }\n    if (gif_get8(s) != 'I') {\n        goto end;\n    }\n    if (gif_get8(s) != 'F') {\n        goto end;\n    }\n    if (gif_get8(s) != '8') {\n        goto end;\n    }\n\n    version = gif_get8(s);\n\n    if (version != '7' && version != '9') {\n        goto end;\n    }\n    if (gif_get8(s) != 'a') {\n        goto end;\n    }\n\n    g->w = gif_get16le(s);\n    g->h = gif_get16le(s);\n    g->flags = gif_get8(s);\n    g->bgindex = gif_get8(s);\n    g->ratio = gif_get8(s);\n    g->transparent = (-1);\n    g->loop_count = (-1);\n\n    if (g->flags & 0x80) {\n        gif_parse_colortable(s, g->pal, 2 << (g->flags & 7));\n    }\n\n    status = SIXEL_OK;\n\nend:\n    return status;\n}\n\n\nstatic SIXELSTATUS\ngif_init_frame(\n    sixel_frame_t /* in */ *frame,\n    gif_t         /* in */ *pg,\n    unsigned char /* in */ *bgcolor,\n    int           /* in */ reqcolors,\n    int           /* in */ fuse_palette)\n{\n    SIXELSTATUS status = SIXEL_OK;\n    int i;\n    int ncolors;\n\n    frame->delay = pg->delay;\n    ncolors = 2 << (pg->flags & 7);\n    if (frame->palette == NULL) {\n        frame->palette = (unsigned char *)sixel_allocator_malloc(frame->allocator, (size_t)(ncolors * 3));\n    } else if (frame->ncolors < ncolors) {\n        sixel_allocator_free(frame->allocator, frame->palette);\n        frame->palette = (unsigned char *)sixel_allocator_malloc(frame->allocator, (size_t)(ncolors * 3));\n    }\n    if (frame->palette == NULL) {\n        sixel_helper_set_additional_message(\n            \"gif_init_frame: sixel_allocator_malloc() failed.\");\n        status = SIXEL_BAD_ALLOCATION;\n        goto end;\n    }\n    frame->ncolors = ncolors;\n    if (frame->ncolors <= reqcolors && fuse_palette) {\n        frame->pixelformat = SIXEL_PIXELFORMAT_PAL8;\n        sixel_allocator_free(frame->allocator, frame->pixels);\n        frame->pixels = (unsigned char *)sixel_allocator_malloc(frame->allocator,\n                                                                (size_t)(frame->width * frame->height));\n        if (frame->pixels == NULL) {\n            sixel_helper_set_additional_message(\n                \"sixel_allocator_malloc() failed in gif_init_frame().\");\n            status = SIXEL_BAD_ALLOCATION;\n            goto end;\n        }\n        memcpy(frame->pixels, pg->out, (size_t)(frame->width * frame->height));\n\n        for (i = 0; i < frame->ncolors; ++i) {\n            frame->palette[i * 3 + 0] = pg->color_table[i * 3 + 2];\n            frame->palette[i * 3 + 1] = pg->color_table[i * 3 + 1];\n            frame->palette[i * 3 + 2] = pg->color_table[i * 3 + 0];\n        }\n        if (pg->lflags & 0x80) {\n            if (pg->eflags & 0x01) {\n                if (bgcolor) {\n                    frame->palette[pg->transparent * 3 + 0] = bgcolor[0];\n                    frame->palette[pg->transparent * 3 + 1] = bgcolor[1];\n                    frame->palette[pg->transparent * 3 + 2] = bgcolor[2];\n                } else {\n                    frame->transparent = pg->transparent;\n                }\n            }\n        } else if (pg->flags & 0x80) {\n            if (pg->eflags & 0x01) {\n                if (bgcolor) {\n                    frame->palette[pg->transparent * 3 + 0] = bgcolor[0];\n                    frame->palette[pg->transparent * 3 + 1] = bgcolor[1];\n                    frame->palette[pg->transparent * 3 + 2] = bgcolor[2];\n                } else {\n                    frame->transparent = pg->transparent;\n                }\n            }\n        }\n    } else {\n        frame->pixelformat = SIXEL_PIXELFORMAT_RGB888;\n        frame->pixels = (unsigned char *)sixel_allocator_malloc(frame->allocator,\n                                                                (size_t)(pg->w * pg->h * 3));\n        if (frame->pixels == NULL) {\n            sixel_helper_set_additional_message(\n                \"sixel_allocator_malloc() failed in gif_init_frame().\");\n            status = SIXEL_BAD_ALLOCATION;\n            goto end;\n        }\n        for (i = 0; i < pg->w * pg->h; ++i) {\n            frame->pixels[i * 3 + 0] = pg->color_table[pg->out[i] * 3 + 2];\n            frame->pixels[i * 3 + 1] = pg->color_table[pg->out[i] * 3 + 1];\n            frame->pixels[i * 3 + 2] = pg->color_table[pg->out[i] * 3 + 0];\n        }\n    }\n    frame->multiframe = (pg->loop_count != (-1));\n\n    status = SIXEL_OK;\n\nend:\n    return status;\n}\n\n\nstatic void\ngif_out_code(\n    gif_t           /* in */ *g,\n    unsigned short  /* in */ code\n)\n{\n    /* recurse to decode the prefixes, since the linked-list is backwards,\n       and working backwards through an interleaved image would be nasty */\n    if (g->codes[code].prefix >= 0) {\n        gif_out_code(g, (unsigned short)g->codes[code].prefix);\n    }\n\n    if (g->cur_y >= g->max_y) {\n        return;\n    }\n\n    g->out[g->cur_x + g->cur_y] = g->codes[code].suffix;\n    g->cur_x++;\n\n    if (g->cur_x >= g->max_x) {\n        g->cur_x = g->start_x;\n        g->cur_y += g->step;\n\n        while (g->cur_y >= g->max_y && g->parse > 0) {\n            g->step = (1 << g->parse) * g->line_size;\n            g->cur_y = g->start_y + (g->step >> 1);\n            --g->parse;\n        }\n    }\n}\n\n\nstatic SIXELSTATUS\ngif_process_raster(\n    gif_context_t /* in */ *s,\n    gif_t         /* in */ *g\n)\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n    unsigned char lzw_cs;\n    signed int len, code;\n    unsigned int first;\n    signed int codesize, codemask, avail, oldcode, bits, valid_bits, clear;\n    gif_lzw *p;\n\n    lzw_cs = gif_get8(s);\n    clear = 1 << lzw_cs;\n    first = 1;\n    codesize = lzw_cs + 1;\n    codemask = (1 << codesize) - 1;\n    bits = 0;\n    valid_bits = 0;\n    for (code = 0; code < clear; code++) {\n        g->codes[code].prefix = -1;\n        g->codes[code].first = (unsigned char) code;\n        g->codes[code].suffix = (unsigned char) code;\n    }\n\n    /* support no starting clear code */\n    avail = clear + 2;\n    oldcode = (-1);\n\n    len = 0;\n    for(;;) {\n        if (valid_bits < codesize) {\n            if (len == 0) {\n                len = gif_get8(s); /* start new block */\n                if (len == 0) {\n                    return SIXEL_OK;\n                }\n            }\n            --len;\n            bits |= (signed int) gif_get8(s) << valid_bits;\n            valid_bits += 8;\n        } else {\n            code = bits & codemask;\n            bits >>= codesize;\n            valid_bits -= codesize;\n            /* @OPTIMIZE: is there some way we can accelerate the non-clear path? */\n            if (code == clear) {  /* clear code */\n                codesize = lzw_cs + 1;\n                codemask = (1 << codesize) - 1;\n                avail = clear + 2;\n                oldcode = -1;\n                first = 0;\n            } else if (code == clear + 1) { /* end of stream code */\n                s->img_buffer += len;\n                while ((len = gif_get8(s)) > 0) {\n                    s->img_buffer += len;\n                }\n                return SIXEL_OK;\n            } else if (code <= avail) {\n                if (first) {\n                    sixel_helper_set_additional_message(\n                        \"corrupt GIF (reason: no clear code).\");\n                    status = SIXEL_RUNTIME_ERROR;\n                    goto end;\n                }\n                if (oldcode >= 0) {\n                    if (avail < 4096) {\n                        p = &g->codes[avail++];\n                        p->prefix = (signed short) oldcode;\n                        p->first = g->codes[oldcode].first;\n                        p->suffix = (code == avail) ? p->first : g->codes[code].first;\n                    }\n                } else if (code == avail) {\n                    sixel_helper_set_additional_message(\n                        \"corrupt GIF (reason: illegal code in raster).\");\n                    status = SIXEL_RUNTIME_ERROR;\n                    goto end;\n                }\n\n                gif_out_code(g, (unsigned short) code);\n\n                if ((avail & codemask) == 0 && avail <= 0x0FFF) {\n                    codesize++;\n                    codemask = (1 << codesize) - 1;\n                }\n\n                oldcode = code;\n            } else {\n                sixel_helper_set_additional_message(\n                    \"corrupt GIF (reason: illegal code in raster).\");\n                status = SIXEL_RUNTIME_ERROR;\n                goto end;\n            }\n        }\n    }\n\n    status = SIXEL_OK;\n\nend:\n    return status;\n}\n\n\n/* this function is ported from stb_image.h */\nstatic SIXELSTATUS\ngif_load_next(\n    gif_context_t /* in */ *s,\n    gif_t         /* in */ *g,\n    unsigned char /* in */ *bgcolor\n)\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n    unsigned char buffer[256];\n    int x;\n    int y;\n    int w;\n    int h;\n    int len;\n\n    for (;;) {\n        switch (gif_get8(s)) {\n        case 0x2C: /* Image Descriptor */\n            x = gif_get16le(s);\n            y = gif_get16le(s);\n            w = gif_get16le(s);\n            h = gif_get16le(s);\n            if (((x + w) > (g->w)) || ((y + h) > (g->h))) {\n                sixel_helper_set_additional_message(\n                    \"corrupt GIF (reason: bad Image Descriptor).\");\n                status = SIXEL_RUNTIME_ERROR;\n                goto end;\n            }\n\n            g->line_size = g->w;\n            g->start_x = x;\n            g->start_y = y * g->line_size;\n            g->max_x   = g->start_x + w;\n            g->max_y   = g->start_y + h * g->line_size;\n            g->cur_x   = g->start_x;\n            g->cur_y   = g->start_y;\n\n            g->lflags = gif_get8(s);\n\n            if (g->lflags & 0x40) {\n                g->step = 8 * g->line_size; /* first interlaced spacing */\n                g->parse = 3;\n            } else {\n                g->step = g->line_size;\n                g->parse = 0;\n            }\n\n            if (g->lflags & 0x80) {\n                gif_parse_colortable(s,\n                                     g->lpal,\n                                     2 << (g->lflags & 7));\n                g->color_table = (unsigned char *) g->lpal;\n            } else if (g->flags & 0x80) {\n                if (g->transparent >= 0 && (g->eflags & 0x01)) {\n                   if (bgcolor) {\n                       g->pal[g->transparent][0] = bgcolor[2];\n                       g->pal[g->transparent][1] = bgcolor[1];\n                       g->pal[g->transparent][2] = bgcolor[0];\n                   }\n                }\n                g->color_table = (unsigned char *)g->pal;\n            } else {\n                sixel_helper_set_additional_message(\n                    \"corrupt GIF (reason: missing color table).\");\n                status = SIXEL_RUNTIME_ERROR;\n                goto end;\n            }\n\n            status = gif_process_raster(s, g);\n            if (SIXEL_FAILED(status)) {\n                goto end;\n            }\n            goto end;\n\n        case 0x21: /* Comment Extension. */\n            switch (gif_get8(s)) {\n            case 0x01: /* Plain Text Extension */\n                break;\n            case 0x21: /* Comment Extension */\n                break;\n            case 0xF9: /* Graphic Control Extension */\n                len = gif_get8(s); /* block size */\n                if (len == 4) {\n                    g->eflags = gif_get8(s);\n                    g->delay = gif_get16le(s); /* delay */\n                    g->transparent = gif_get8(s);\n                } else {\n                    s->img_buffer += len;\n                    break;\n                }\n                break;\n            case 0xFF: /* Application Extension */\n                len = gif_get8(s); /* block size */\n                if (s->img_buffer + len > s->img_buffer_end) {\n                    status = SIXEL_RUNTIME_ERROR;\n                    goto end;\n                }\n                memcpy(buffer, s->img_buffer, (size_t)len);\n                s->img_buffer += len;\n                buffer[len] = 0;\n                if (len == 11 && strcmp((char *)buffer, \"NETSCAPE2.0\") == 0) {\n                    if (gif_get8(s) == 0x03) {\n                        /* loop count */\n                        switch (gif_get8(s)) {\n                        case 0x00:\n                            g->loop_count = 1;\n                            break;\n                        case 0x01:\n                            g->loop_count = gif_get16le(s);\n                            break;\n                        default:\n                            g->loop_count = 1;\n                            break;\n                        }\n                    }\n                }\n                break;\n            default:\n                break;\n            }\n            while ((len = gif_get8(s)) != 0) {\n                s->img_buffer += len;\n            }\n            break;\n\n        case 0x3B: /* gif stream termination code */\n            g->is_terminated = 1;\n            status = SIXEL_OK;\n            goto end;\n\n        default:\n            sixel_helper_set_additional_message(\n                \"corrupt GIF (reason: unknown code).\");\n            status = SIXEL_RUNTIME_ERROR;\n            goto end;\n        }\n    }\n\n    status = SIXEL_OK;\n\nend:\n    return status;\n}\n\ntypedef union _fn_pointer {\n    sixel_load_image_function fn;\n    void *                    p;\n} fn_pointer;\n\nSIXELSTATUS\nload_gif(\n    unsigned char       /* in */ *buffer,\n    int                 /* in */ size,\n    unsigned char       /* in */ *bgcolor,\n    int                 /* in */ reqcolors,\n    int                 /* in */ fuse_palette,\n    int                 /* in */ fstatic,\n    int                 /* in */ loop_control,\n    void                /* in */ *fn_load,     /* callback */\n    void                /* in */ *context,     /* private data for callback */\n    sixel_allocator_t   /* in */ *allocator)   /* allocator object */\n{\n    gif_context_t s;\n    gif_t g;\n    SIXELSTATUS status = SIXEL_FALSE;\n    sixel_frame_t *frame;\n    fn_pointer fnp;\n\n    fnp.p = fn_load;\n    g.out = NULL;\n\n    status = sixel_frame_new(&frame, allocator);\n    if (SIXEL_FAILED(status)) {\n        goto end;\n    }\n    s.img_buffer = s.img_buffer_original = (unsigned char *)buffer;\n    s.img_buffer_end = (unsigned char *)buffer + size;\n    memset(&g, 0, sizeof(g));\n    status = gif_load_header(&s, &g);\n    if (status != SIXEL_OK) {\n        goto end;\n    }\n    g.out = (unsigned char *)sixel_allocator_malloc(allocator, (size_t)(g.w * g.h));\n    if (g.out == NULL) {\n        sixel_helper_set_additional_message(\n            \"load_gif: sixel_allocator_malloc() failed.\");\n        status = SIXEL_BAD_ALLOCATION;\n        goto end;\n    }\n\n    frame->loop_count = 0;\n\n    for (;;) { /* per loop */\n\n        frame->frame_no = 0;\n\n        s.img_buffer = s.img_buffer_original;\n        status = gif_load_header(&s, &g);\n        if (status != SIXEL_OK) {\n            goto end;\n        }\n\n        g.is_terminated = 0;\n\n        for (;;) { /* per frame */\n            status = gif_load_next(&s, &g, bgcolor);\n            if (status != SIXEL_OK) {\n                goto end;\n            }\n            if (g.is_terminated) {\n                break;\n            }\n\n            frame->width = g.w;\n            frame->height = g.h;\n            status = gif_init_frame(frame, &g, bgcolor, reqcolors, fuse_palette);\n            if (status != SIXEL_OK) {\n                goto end;\n            }\n\n            status = fnp.fn(frame, context);\n            if (status != SIXEL_OK) {\n                goto end;\n            }\n\n            if (fstatic) {\n                goto end;\n            }\n            ++frame->frame_no;\n        }\n\n        ++frame->loop_count;\n\n        if (g.loop_count < 0) {\n            break;\n        }\n        if (loop_control == SIXEL_LOOP_DISABLE || frame->frame_no == 1) {\n            break;\n        }\n        if (loop_control == SIXEL_LOOP_AUTO) {\n            if (frame->loop_count == g.loop_count) {\n                break;\n            }\n        }\n    }\n\nend:\n    sixel_allocator_free(frame->allocator, g.out);\n    sixel_frame_unref(frame);\n\n    return status;\n}\n\n\n#if HAVE_TESTS\nstatic int\ntest1(void)\n{\n    int nret = EXIT_FAILURE;\n\n    nret = EXIT_SUCCESS;\n\n    return nret;\n}\n\n\nSIXELAPI int\nsixel_fromgif_tests_main(void)\n{\n    int nret = EXIT_FAILURE;\n    size_t i;\n    typedef int (* testcase)(void);\n\n    static testcase const testcases[] = {\n        test1,\n    };\n\n    for (i = 0; i < sizeof(testcases) / sizeof(testcase); ++i) {\n        nret = testcases[i]();\n        if (nret != EXIT_SUCCESS) {\n            goto error;\n        }\n    }\n\n    nret = EXIT_SUCCESS;\n\nerror:\n    return nret;\n}\n#endif  /* HAVE_TESTS */\n\n/* emacs Local Variables:      */\n/* emacs mode: c               */\n/* emacs tab-width: 4          */\n/* emacs indent-tabs-mode: nil */\n/* emacs c-basic-offset: 4     */\n/* emacs End:                  */\n/* vim: set expandtab ts=4 sts=4 sw=4 : */\n/* EOF */\n"], "fixing_code": ["/*\n * This file is derived from \"stb_image.h\" that is in public domain.\n * https://github.com/nothings/stb\n *\n * Hayaki Saito <saitoha@me.com> modified this and re-licensed\n * it under the MIT license.\n *\n * Copyright (c) 2014-2018 Hayaki Saito\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n#include \"config.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include \"frame.h\"\n#include \"fromgif.h\"\n\n/*\n * gif_context_t struct and start_xxx functions\n *\n * gif_context_t structure is our basic context used by all images, so it\n * contains all the IO context, plus some basic image information\n */\ntypedef struct\n{\n   unsigned int img_x, img_y;\n   int img_n, img_out_n;\n\n   int buflen;\n   unsigned char buffer_start[128];\n\n   unsigned char *img_buffer, *img_buffer_end;\n   unsigned char *img_buffer_original;\n} gif_context_t;\n\ntypedef struct\n{\n   signed short prefix;\n   unsigned char first;\n   unsigned char suffix;\n} gif_lzw;\n\nenum {\n   gif_lzw_max_code_size = 12\n};\n\ntypedef struct\n{\n   int w, h;\n   unsigned char *out;  /* output buffer (always 4 components) */\n   int flags, bgindex, ratio, transparent, eflags;\n   unsigned char pal[256][3];\n   unsigned char lpal[256][3];\n   gif_lzw codes[1 << gif_lzw_max_code_size];\n   unsigned char *color_table;\n   int parse, step;\n   int lflags;\n   int start_x, start_y;\n   int max_x, max_y;\n   int cur_x, cur_y;\n   int line_size;\n   int loop_count;\n   int delay;\n   int is_multiframe;\n   int is_terminated;\n} gif_t;\n\n\n/* initialize a memory-decode context */\nstatic unsigned char\ngif_get8(gif_context_t *s)\n{\n    if (s->img_buffer < s->img_buffer_end) {\n        return *s->img_buffer++;\n    }\n    return 0;\n}\n\n\nstatic int\ngif_get16le(gif_context_t *s)\n{\n    int z = gif_get8(s);\n    return z + (gif_get8(s) << 8);\n}\n\n\nstatic void\ngif_parse_colortable(\n    gif_context_t /* in */ *s,\n    unsigned char       /* in */ pal[256][3],\n    int           /* in */ num_entries)\n{\n    int i;\n\n    for (i = 0; i < num_entries; ++i) {\n        pal[i][2] = gif_get8(s);\n        pal[i][1] = gif_get8(s);\n        pal[i][0] = gif_get8(s);\n    }\n}\n\n\nstatic SIXELSTATUS\ngif_load_header(\n    gif_context_t /* in */ *s,\n    gif_t         /* in */ *g)\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n    unsigned char version;\n    if (gif_get8(s) != 'G') {\n        goto end;\n    }\n    if (gif_get8(s) != 'I') {\n        goto end;\n    }\n    if (gif_get8(s) != 'F') {\n        goto end;\n    }\n    if (gif_get8(s) != '8') {\n        goto end;\n    }\n\n    version = gif_get8(s);\n\n    if (version != '7' && version != '9') {\n        goto end;\n    }\n    if (gif_get8(s) != 'a') {\n        goto end;\n    }\n\n    g->w = gif_get16le(s);\n    g->h = gif_get16le(s);\n    g->flags = gif_get8(s);\n    g->bgindex = gif_get8(s);\n    g->ratio = gif_get8(s);\n    g->transparent = (-1);\n    g->loop_count = (-1);\n\n    if (g->flags & 0x80) {\n        gif_parse_colortable(s, g->pal, 2 << (g->flags & 7));\n    }\n\n    status = SIXEL_OK;\n\nend:\n    return status;\n}\n\n\nstatic SIXELSTATUS\ngif_init_frame(\n    sixel_frame_t /* in */ *frame,\n    gif_t         /* in */ *pg,\n    unsigned char /* in */ *bgcolor,\n    int           /* in */ reqcolors,\n    int           /* in */ fuse_palette)\n{\n    SIXELSTATUS status = SIXEL_OK;\n    int i;\n    int ncolors;\n\n    frame->delay = pg->delay;\n    ncolors = 2 << (pg->flags & 7);\n    if (frame->palette == NULL) {\n        frame->palette = (unsigned char *)sixel_allocator_malloc(frame->allocator, (size_t)(ncolors * 3));\n    } else if (frame->ncolors < ncolors) {\n        sixel_allocator_free(frame->allocator, frame->palette);\n        frame->palette = (unsigned char *)sixel_allocator_malloc(frame->allocator, (size_t)(ncolors * 3));\n    }\n    if (frame->palette == NULL) {\n        sixel_helper_set_additional_message(\n            \"gif_init_frame: sixel_allocator_malloc() failed.\");\n        status = SIXEL_BAD_ALLOCATION;\n        goto end;\n    }\n    frame->ncolors = ncolors;\n    if (frame->ncolors <= reqcolors && fuse_palette) {\n        frame->pixelformat = SIXEL_PIXELFORMAT_PAL8;\n        sixel_allocator_free(frame->allocator, frame->pixels);\n        frame->pixels = (unsigned char *)sixel_allocator_malloc(frame->allocator,\n                                                                (size_t)(frame->width * frame->height));\n        if (frame->pixels == NULL) {\n            sixel_helper_set_additional_message(\n                \"sixel_allocator_malloc() failed in gif_init_frame().\");\n            status = SIXEL_BAD_ALLOCATION;\n            goto end;\n        }\n        memcpy(frame->pixels, pg->out, (size_t)(frame->width * frame->height));\n\n        for (i = 0; i < frame->ncolors; ++i) {\n            frame->palette[i * 3 + 0] = pg->color_table[i * 3 + 2];\n            frame->palette[i * 3 + 1] = pg->color_table[i * 3 + 1];\n            frame->palette[i * 3 + 2] = pg->color_table[i * 3 + 0];\n        }\n        if (pg->lflags & 0x80) {\n            if (pg->eflags & 0x01) {\n                if (bgcolor) {\n                    frame->palette[pg->transparent * 3 + 0] = bgcolor[0];\n                    frame->palette[pg->transparent * 3 + 1] = bgcolor[1];\n                    frame->palette[pg->transparent * 3 + 2] = bgcolor[2];\n                } else {\n                    frame->transparent = pg->transparent;\n                }\n            }\n        } else if (pg->flags & 0x80) {\n            if (pg->eflags & 0x01) {\n                if (bgcolor) {\n                    frame->palette[pg->transparent * 3 + 0] = bgcolor[0];\n                    frame->palette[pg->transparent * 3 + 1] = bgcolor[1];\n                    frame->palette[pg->transparent * 3 + 2] = bgcolor[2];\n                } else {\n                    frame->transparent = pg->transparent;\n                }\n            }\n        }\n    } else {\n        frame->pixelformat = SIXEL_PIXELFORMAT_RGB888;\n        frame->pixels = (unsigned char *)sixel_allocator_malloc(frame->allocator,\n                                                                (size_t)(pg->w * pg->h * 3));\n        if (frame->pixels == NULL) {\n            sixel_helper_set_additional_message(\n                \"sixel_allocator_malloc() failed in gif_init_frame().\");\n            status = SIXEL_BAD_ALLOCATION;\n            goto end;\n        }\n        for (i = 0; i < pg->w * pg->h; ++i) {\n            frame->pixels[i * 3 + 0] = pg->color_table[pg->out[i] * 3 + 2];\n            frame->pixels[i * 3 + 1] = pg->color_table[pg->out[i] * 3 + 1];\n            frame->pixels[i * 3 + 2] = pg->color_table[pg->out[i] * 3 + 0];\n        }\n    }\n    frame->multiframe = (pg->loop_count != (-1));\n\n    status = SIXEL_OK;\n\nend:\n    return status;\n}\n\n\nstatic void\ngif_out_code(\n    gif_t           /* in */ *g,\n    unsigned short  /* in */ code\n)\n{\n    /* recurse to decode the prefixes, since the linked-list is backwards,\n       and working backwards through an interleaved image would be nasty */\n    if (g->codes[code].prefix >= 0) {\n        gif_out_code(g, (unsigned short)g->codes[code].prefix);\n    }\n\n    if (g->cur_y >= g->max_y) {\n        return;\n    }\n\n    g->out[g->cur_x + g->cur_y] = g->codes[code].suffix;\n    g->cur_x++;\n\n    if (g->cur_x >= g->max_x) {\n        g->cur_x = g->start_x;\n        g->cur_y += g->step;\n\n        while (g->cur_y >= g->max_y && g->parse > 0) {\n            g->step = (1 << g->parse) * g->line_size;\n            g->cur_y = g->start_y + (g->step >> 1);\n            --g->parse;\n        }\n    }\n}\n\n\nstatic SIXELSTATUS\ngif_process_raster(\n    gif_context_t /* in */ *s,\n    gif_t         /* in */ *g\n)\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n    unsigned char lzw_cs;\n    signed int len, code;\n    unsigned int first;\n    signed int codesize, codemask, avail, oldcode, bits, valid_bits, clear;\n    gif_lzw *p;\n\n    /* LZW Minimum Code Size */\n    lzw_cs = gif_get8(s);\n    if (lzw_cs > gif_lzw_max_code_size) {\n        sixel_helper_set_additional_message(\n            \"Unsupported GIF (LZW code size)\");\n        status = SIXEL_RUNTIME_ERROR;\n        goto end;\n    }\n\n    clear = 1 << lzw_cs;\n    first = 1;\n    codesize = lzw_cs + 1;\n    codemask = (1 << codesize) - 1;\n    bits = 0;\n    valid_bits = 0;\n    for (code = 0; code < clear; code++) {\n        g->codes[code].prefix = -1;\n        g->codes[code].first = (unsigned char) code;\n        g->codes[code].suffix = (unsigned char) code;\n    }\n\n    /* support no starting clear code */\n    avail = clear + 2;\n    oldcode = (-1);\n\n    len = 0;\n    for(;;) {\n        if (valid_bits < codesize) {\n            if (len == 0) {\n                len = gif_get8(s); /* start new block */\n                if (len == 0) {\n                    return SIXEL_OK;\n                }\n            }\n            --len;\n            bits |= (signed int) gif_get8(s) << valid_bits;\n            valid_bits += 8;\n        } else {\n            code = bits & codemask;\n            bits >>= codesize;\n            valid_bits -= codesize;\n            /* @OPTIMIZE: is there some way we can accelerate the non-clear path? */\n            if (code == clear) {  /* clear code */\n                codesize = lzw_cs + 1;\n                codemask = (1 << codesize) - 1;\n                avail = clear + 2;\n                oldcode = -1;\n                first = 0;\n            } else if (code == clear + 1) { /* end of stream code */\n                s->img_buffer += len;\n                while ((len = gif_get8(s)) > 0) {\n                    s->img_buffer += len;\n                }\n                return SIXEL_OK;\n            } else if (code <= avail) {\n                if (first) {\n                    sixel_helper_set_additional_message(\n                        \"corrupt GIF (reason: no clear code).\");\n                    status = SIXEL_RUNTIME_ERROR;\n                    goto end;\n                }\n                if (oldcode >= 0) {\n                    if (avail < (1 << gif_lzw_max_code_size)) {\n                        p = &g->codes[avail++];\n                        p->prefix = (signed short) oldcode;\n                        p->first = g->codes[oldcode].first;\n                        p->suffix = (code == avail) ? p->first : g->codes[code].first;\n                    }\n                } else if (code == avail) {\n                    sixel_helper_set_additional_message(\n                        \"corrupt GIF (reason: illegal code in raster).\");\n                    status = SIXEL_RUNTIME_ERROR;\n                    goto end;\n                }\n\n                gif_out_code(g, (unsigned short) code);\n\n                if ((avail & codemask) == 0 && avail <= 0x0FFF) {\n                    codesize++;\n                    codemask = (1 << codesize) - 1;\n                }\n\n                oldcode = code;\n            } else {\n                sixel_helper_set_additional_message(\n                    \"corrupt GIF (reason: illegal code in raster).\");\n                status = SIXEL_RUNTIME_ERROR;\n                goto end;\n            }\n        }\n    }\n\n    status = SIXEL_OK;\n\nend:\n    return status;\n}\n\n\n/* this function is ported from stb_image.h */\nstatic SIXELSTATUS\ngif_load_next(\n    gif_context_t /* in */ *s,\n    gif_t         /* in */ *g,\n    unsigned char /* in */ *bgcolor\n)\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n    unsigned char buffer[256];\n    int x;\n    int y;\n    int w;\n    int h;\n    int len;\n\n    for (;;) {\n        switch (gif_get8(s)) {\n        case 0x2C: /* Image Descriptor */\n            x = gif_get16le(s);\n            y = gif_get16le(s);\n            w = gif_get16le(s);\n            h = gif_get16le(s);\n            if (((x + w) > (g->w)) || ((y + h) > (g->h))) {\n                sixel_helper_set_additional_message(\n                    \"corrupt GIF (reason: bad Image Descriptor).\");\n                status = SIXEL_RUNTIME_ERROR;\n                goto end;\n            }\n\n            g->line_size = g->w;\n            g->start_x = x;\n            g->start_y = y * g->line_size;\n            g->max_x   = g->start_x + w;\n            g->max_y   = g->start_y + h * g->line_size;\n            g->cur_x   = g->start_x;\n            g->cur_y   = g->start_y;\n\n            g->lflags = gif_get8(s);\n\n            if (g->lflags & 0x40) {\n                g->step = 8 * g->line_size; /* first interlaced spacing */\n                g->parse = 3;\n            } else {\n                g->step = g->line_size;\n                g->parse = 0;\n            }\n\n            if (g->lflags & 0x80) {\n                gif_parse_colortable(s,\n                                     g->lpal,\n                                     2 << (g->lflags & 7));\n                g->color_table = (unsigned char *) g->lpal;\n            } else if (g->flags & 0x80) {\n                if (g->transparent >= 0 && (g->eflags & 0x01)) {\n                   if (bgcolor) {\n                       g->pal[g->transparent][0] = bgcolor[2];\n                       g->pal[g->transparent][1] = bgcolor[1];\n                       g->pal[g->transparent][2] = bgcolor[0];\n                   }\n                }\n                g->color_table = (unsigned char *)g->pal;\n            } else {\n                sixel_helper_set_additional_message(\n                    \"corrupt GIF (reason: missing color table).\");\n                status = SIXEL_RUNTIME_ERROR;\n                goto end;\n            }\n\n            status = gif_process_raster(s, g);\n            if (SIXEL_FAILED(status)) {\n                goto end;\n            }\n            goto end;\n\n        case 0x21: /* Comment Extension. */\n            switch (gif_get8(s)) {\n            case 0x01: /* Plain Text Extension */\n                break;\n            case 0x21: /* Comment Extension */\n                break;\n            case 0xF9: /* Graphic Control Extension */\n                len = gif_get8(s); /* block size */\n                if (len == 4) {\n                    g->eflags = gif_get8(s);\n                    g->delay = gif_get16le(s); /* delay */\n                    g->transparent = gif_get8(s);\n                } else {\n                    s->img_buffer += len;\n                    break;\n                }\n                break;\n            case 0xFF: /* Application Extension */\n                len = gif_get8(s); /* block size */\n                if (s->img_buffer + len > s->img_buffer_end) {\n                    status = SIXEL_RUNTIME_ERROR;\n                    goto end;\n                }\n                memcpy(buffer, s->img_buffer, (size_t)len);\n                s->img_buffer += len;\n                buffer[len] = 0;\n                if (len == 11 && strcmp((char *)buffer, \"NETSCAPE2.0\") == 0) {\n                    if (gif_get8(s) == 0x03) {\n                        /* loop count */\n                        switch (gif_get8(s)) {\n                        case 0x00:\n                            g->loop_count = 1;\n                            break;\n                        case 0x01:\n                            g->loop_count = gif_get16le(s);\n                            break;\n                        default:\n                            g->loop_count = 1;\n                            break;\n                        }\n                    }\n                }\n                break;\n            default:\n                break;\n            }\n            while ((len = gif_get8(s)) != 0) {\n                s->img_buffer += len;\n            }\n            break;\n\n        case 0x3B: /* gif stream termination code */\n            g->is_terminated = 1;\n            status = SIXEL_OK;\n            goto end;\n\n        default:\n            sixel_helper_set_additional_message(\n                \"corrupt GIF (reason: unknown code).\");\n            status = SIXEL_RUNTIME_ERROR;\n            goto end;\n        }\n    }\n\n    status = SIXEL_OK;\n\nend:\n    return status;\n}\n\ntypedef union _fn_pointer {\n    sixel_load_image_function fn;\n    void *                    p;\n} fn_pointer;\n\nSIXELSTATUS\nload_gif(\n    unsigned char       /* in */ *buffer,\n    int                 /* in */ size,\n    unsigned char       /* in */ *bgcolor,\n    int                 /* in */ reqcolors,\n    int                 /* in */ fuse_palette,\n    int                 /* in */ fstatic,\n    int                 /* in */ loop_control,\n    void                /* in */ *fn_load,     /* callback */\n    void                /* in */ *context,     /* private data for callback */\n    sixel_allocator_t   /* in */ *allocator)   /* allocator object */\n{\n    gif_context_t s;\n    gif_t g;\n    SIXELSTATUS status = SIXEL_FALSE;\n    sixel_frame_t *frame;\n    fn_pointer fnp;\n\n    fnp.p = fn_load;\n    g.out = NULL;\n\n    status = sixel_frame_new(&frame, allocator);\n    if (SIXEL_FAILED(status)) {\n        goto end;\n    }\n    s.img_buffer = s.img_buffer_original = (unsigned char *)buffer;\n    s.img_buffer_end = (unsigned char *)buffer + size;\n    memset(&g, 0, sizeof(g));\n    status = gif_load_header(&s, &g);\n    if (status != SIXEL_OK) {\n        goto end;\n    }\n    g.out = (unsigned char *)sixel_allocator_malloc(allocator, (size_t)(g.w * g.h));\n    if (g.out == NULL) {\n        sixel_helper_set_additional_message(\n            \"load_gif: sixel_allocator_malloc() failed.\");\n        status = SIXEL_BAD_ALLOCATION;\n        goto end;\n    }\n\n    frame->loop_count = 0;\n\n    for (;;) { /* per loop */\n\n        frame->frame_no = 0;\n\n        s.img_buffer = s.img_buffer_original;\n        status = gif_load_header(&s, &g);\n        if (status != SIXEL_OK) {\n            goto end;\n        }\n\n        g.is_terminated = 0;\n\n        for (;;) { /* per frame */\n            status = gif_load_next(&s, &g, bgcolor);\n            if (status != SIXEL_OK) {\n                goto end;\n            }\n            if (g.is_terminated) {\n                break;\n            }\n\n            frame->width = g.w;\n            frame->height = g.h;\n            status = gif_init_frame(frame, &g, bgcolor, reqcolors, fuse_palette);\n            if (status != SIXEL_OK) {\n                goto end;\n            }\n\n            status = fnp.fn(frame, context);\n            if (status != SIXEL_OK) {\n                goto end;\n            }\n\n            if (fstatic) {\n                goto end;\n            }\n            ++frame->frame_no;\n        }\n\n        ++frame->loop_count;\n\n        if (g.loop_count < 0) {\n            break;\n        }\n        if (loop_control == SIXEL_LOOP_DISABLE || frame->frame_no == 1) {\n            break;\n        }\n        if (loop_control == SIXEL_LOOP_AUTO) {\n            if (frame->loop_count == g.loop_count) {\n                break;\n            }\n        }\n    }\n\nend:\n    sixel_allocator_free(frame->allocator, g.out);\n    sixel_frame_unref(frame);\n\n    return status;\n}\n\n\n#if HAVE_TESTS\nstatic int\ntest1(void)\n{\n    int nret = EXIT_FAILURE;\n\n    nret = EXIT_SUCCESS;\n\n    return nret;\n}\n\n\nSIXELAPI int\nsixel_fromgif_tests_main(void)\n{\n    int nret = EXIT_FAILURE;\n    size_t i;\n    typedef int (* testcase)(void);\n\n    static testcase const testcases[] = {\n        test1,\n    };\n\n    for (i = 0; i < sizeof(testcases) / sizeof(testcase); ++i) {\n        nret = testcases[i]();\n        if (nret != EXIT_SUCCESS) {\n            goto error;\n        }\n    }\n\n    nret = EXIT_SUCCESS;\n\nerror:\n    return nret;\n}\n#endif  /* HAVE_TESTS */\n\n/* emacs Local Variables:      */\n/* emacs mode: c               */\n/* emacs tab-width: 4          */\n/* emacs indent-tabs-mode: nil */\n/* emacs c-basic-offset: 4     */\n/* emacs End:                  */\n/* vim: set expandtab ts=4 sts=4 sw=4 : */\n/* EOF */\n"], "filenames": ["src/fromgif.c"], "buggy_code_start_loc": [60], "buggy_code_end_loc": [357], "fixing_code_start_loc": [61], "fixing_code_end_loc": [369], "type": "CWE-787", "message": "Libsixel prior to v1.8.3 contains a stack buffer overflow in the function gif_process_raster at fromgif.c.", "other": {"cve": {"id": "CVE-2020-21050", "sourceIdentifier": "cve@mitre.org", "published": "2021-09-14T16:15:08.987", "lastModified": "2022-09-20T20:56:48.307", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Libsixel prior to v1.8.3 contains a stack buffer overflow in the function gif_process_raster at fromgif.c."}, {"lang": "es", "value": "Libsixel versiones anteriores a v1.8.3, contiene un desbordamiento del buffer de pila en la funci\u00f3n gif_process_raster en el archivo fromgif.c"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libsixel_project:libsixel:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.8.3", "matchCriteriaId": "3A5CB650-56E4-4DF9-9310-080C174E1528"}]}]}], "references": [{"url": "https://bitbucket.org/netbsd/pkgsrc/commits/a27113e21179cbfbfae0c35f6a9edd6aa498faae", "source": "cve@mitre.org", "tags": ["Broken Link"]}, {"url": "https://cwe.mitre.org/data/definitions/121.html", "source": "cve@mitre.org", "tags": ["Technical Description"]}, {"url": "https://github.com/saitoha/libsixel/blob/master/ChangeLog", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/saitoha/libsixel/commit/7808a06b88c11dbc502318cdd51fa374f8cd47ee", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/saitoha/libsixel/issues/75", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/saitoha/libsixel/releases/tag/v1.8.5", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/saitoha/libsixel/commit/7808a06b88c11dbc502318cdd51fa374f8cd47ee"}}