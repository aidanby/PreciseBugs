{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2012\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / BIFS codec sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n\n\n#include <gpac/internal/bifs_dev.h>\n#include <gpac/scene_manager.h>\n#include \"quant.h\"\n#include \"script.h\"\n\n#ifndef GPAC_DISABLE_BIFS\n\nvoid SFCommandBufferChanged(GF_BifsDecoder * codec, GF_Node *node)\n{\n\tvoid Conditional_BufferReplaced(GF_BifsDecoder * codec, GF_Node *node);\n\n\tswitch (gf_node_get_tag(node)) {\n\tcase TAG_MPEG4_Conditional:\n\t\tConditional_BufferReplaced(codec, node);\n\t\tbreak;\n\t}\n}\n\n\n//startTimes, stopTimes and co are coded as relative to their AU timestamp when received\n//on the wire. If from scripts or within proto the offset doesn't apply\nvoid BD_OffsetSFTime(GF_BifsDecoder * codec, Double *time)\n{\n\tif ((!codec->is_com_dec && codec->pCurrentProto) || codec->dec_memory_mode) return;\n\t*time += codec->cts_offset;\n}\n\nvoid BD_CheckSFTimeOffset(GF_BifsDecoder *codec, GF_Node *node, GF_FieldInfo *inf)\n{\n\tif (gf_node_get_tag(node) != TAG_ProtoNode) {\n\t\tif (!stricmp(inf->name, \"startTime\") || !stricmp(inf->name, \"stopTime\"))\n\t\t\tBD_OffsetSFTime(codec,  (Double *)inf->far_ptr);\n\t} else if (gf_sg_proto_field_is_sftime_offset(node, inf)) {\n\t\tBD_OffsetSFTime(codec,  (Double *)inf->far_ptr);\n\t}\n}\n\n\nFixed BD_ReadSFFloat(GF_BifsDecoder * codec, GF_BitStream *bs)\n{\n\tif (codec->ActiveQP && codec->ActiveQP->useEfficientCoding)\n\t\treturn gf_bifs_dec_mantissa_float(codec, bs);\n\n\treturn FLT2FIX(gf_bs_read_float(bs));\n}\n\n\nGF_Err gf_bifs_dec_sf_field(GF_BifsDecoder * codec, GF_BitStream *bs, GF_Node *node, GF_FieldInfo *field, Bool is_mem_com)\n{\n\tGF_Err e;\n\tGF_Node *new_node;\n\tu32 size, length, w, h, i;\n\tchar *buffer;\n\n\t//blindly call unquantize. return is OK, error or GF_EOS\n\tif (codec->ActiveQP && node) {\n\t\te = gf_bifs_dec_unquant_field(codec, bs, node, field);\n\t\tif (e != GF_EOS) return e;\n\t}\n\t//not quantized, use normal scheme\n\tswitch (field->fieldType) {\n\tcase GF_SG_VRML_SFBOOL:\n\t\t* ((SFBool *) field->far_ptr) = (SFBool) gf_bs_read_int(bs, 1);\n\t\tbreak;\n\tcase GF_SG_VRML_SFCOLOR:\n\t\t((SFColor *)field->far_ptr)->red = BD_ReadSFFloat(codec, bs);\n\t\t((SFColor *)field->far_ptr)->green = BD_ReadSFFloat(codec, bs);\n\t\t((SFColor *)field->far_ptr)->blue = BD_ReadSFFloat(codec, bs);\n\t\tbreak;\n\tcase GF_SG_VRML_SFFLOAT:\n\t\t*((SFFloat *)field->far_ptr) = BD_ReadSFFloat(codec, bs);\n\t\tbreak;\n\tcase GF_SG_VRML_SFINT32:\n\t\t*((SFInt32 *)field->far_ptr) = (s32) gf_bs_read_int(bs, 32);\n\t\tbreak;\n\tcase GF_SG_VRML_SFTIME:\n\t\t*((SFTime *)field->far_ptr) = gf_bs_read_double(bs);\n\t\tif (node) BD_CheckSFTimeOffset(codec, node, field);\n\t\tbreak;\n\tcase GF_SG_VRML_SFVEC2F:\n\t\t((SFVec2f *)field->far_ptr)->x = BD_ReadSFFloat(codec, bs);\n\t\t((SFVec2f *)field->far_ptr)->y = BD_ReadSFFloat(codec, bs);\n\t\tbreak;\n\tcase GF_SG_VRML_SFVEC3F:\n\t\t((SFVec3f *)field->far_ptr)->x = BD_ReadSFFloat(codec, bs);\n\t\t((SFVec3f *)field->far_ptr)->y = BD_ReadSFFloat(codec, bs);\n\t\t((SFVec3f *)field->far_ptr)->z = BD_ReadSFFloat(codec, bs);\n\t\tbreak;\n\tcase GF_SG_VRML_SFROTATION:\n\t\t((SFRotation *)field->far_ptr)->x = BD_ReadSFFloat(codec, bs);\n\t\t((SFRotation *)field->far_ptr)->y = BD_ReadSFFloat(codec, bs);\n\t\t((SFRotation *)field->far_ptr)->z = BD_ReadSFFloat(codec, bs);\n\t\t((SFRotation *)field->far_ptr)->q = BD_ReadSFFloat(codec, bs);\n\t\tbreak;\n\tcase GF_SG_VRML_SFSTRING:\n\t\tsize = gf_bs_read_int(bs, 5);\n\t\tlength = gf_bs_read_int(bs, size);\n\t\tif (gf_bs_available(bs) < length) return GF_NON_COMPLIANT_BITSTREAM;\n\n\t\tif (node && (node->sgprivate->tag==TAG_MPEG4_CacheTexture) && (field->fieldIndex<=2)) {\n\t\t\tM_CacheTexture *ct = (M_CacheTexture *) node;\n\t\t\tct->data_len = length;\n\t\t\tif (ct->data) gf_free(ct->data);\n\t\t\tct->data = (u8*)gf_malloc(sizeof(char)*length);\n\t\t\tgf_bs_read_data(bs, (char*)ct->data, length);\n\t\t} else if (node && (node->sgprivate->tag==TAG_MPEG4_BitWrapper) ) {\n\t\t\tM_BitWrapper *bw = (M_BitWrapper*) node;\n\t\t\tif (bw->buffer.buffer) gf_free(bw->buffer.buffer);\n\t\t\tbw->buffer_len = length;\n\t\t\tbw->buffer.buffer = (char*)gf_malloc(sizeof(char)*length);\n\t\t\tgf_bs_read_data(bs, (char*)bw->buffer.buffer, length);\n\t\t} else {\n\t\t\tif ( ((SFString *)field->far_ptr)->buffer ) gf_free( ((SFString *)field->far_ptr)->buffer);\n\t\t\t((SFString *)field->far_ptr)->buffer = (char *)gf_malloc(sizeof(char)*(length+1));\n\t\t\tmemset(((SFString *)field->far_ptr)->buffer , 0, length+1);\n\t\t\tfor (i=0; i<length; i++) {\n\t\t\t\t((SFString *)field->far_ptr)->buffer[i] = gf_bs_read_int(bs, 8);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase GF_SG_VRML_SFURL:\n\t{\n\t\tSFURL *url = (SFURL *) field->far_ptr;\n\t\tsize = gf_bs_read_int(bs, 1);\n\t\tif (size) {\n\t\t\tif (url->url) gf_free(url->url );\n\t\t\turl->url = NULL;\n\t\t\tlength = gf_bs_read_int(bs, 10);\n\t\t\turl->OD_ID = length;\n\t\t} else {\n\t\t\tif ( url->OD_ID ) url->OD_ID = (u32) -1;\n\t\t\tsize = gf_bs_read_int(bs, 5);\n\t\t\tlength = gf_bs_read_int(bs, size);\n\t\t\tif (gf_bs_available(bs) < length) return GF_NON_COMPLIANT_BITSTREAM;\n\t\t\tbuffer = NULL;\n\t\t\tif (length) {\n\t\t\t\tbuffer = (char *)gf_malloc(sizeof(char)*(length+1));\n\t\t\t\tmemset(buffer, 0, length+1);\n\t\t\t\tfor (i=0; i<length; i++) buffer[i] = gf_bs_read_int(bs, 8);\n\t\t\t}\n\t\t\tif (url->url) gf_free( url->url);\n\t\t\t/*if URL is empty set it to NULL*/\n\t\t\tif (buffer && strlen(buffer)) {\n\t\t\t\turl->url = buffer;\n\t\t\t} else {\n\t\t\t\tgf_free(buffer);\n\t\t\t\turl->url = NULL;\n\t\t\t}\n\t\t}\n\t}\n\tbreak;\n\tcase GF_SG_VRML_SFIMAGE:\n\t\tif (((SFImage *)field->far_ptr)->pixels) {\n\t\t\tgf_free(((SFImage *)field->far_ptr)->pixels);\n\t\t\t((SFImage *)field->far_ptr)->pixels = NULL;\n\t\t}\n\t\tw = gf_bs_read_int(bs, 12);\n\t\th = gf_bs_read_int(bs, 12);\n\t\tlength = gf_bs_read_int(bs, 2);\n\n\t\tif (length > 3) length = 3;\n\t\tlength += 1;\n\t\tsize = w * h * length;\n\t\tif (gf_bs_available(bs) < size) return GF_NON_COMPLIANT_BITSTREAM;\n\t\t((SFImage *)field->far_ptr)->width = w;\n\t\t((SFImage *)field->far_ptr)->height = h;\n\t\t((SFImage *)field->far_ptr)->numComponents = length;\n\t\t((SFImage *)field->far_ptr)->pixels = (unsigned char *)gf_malloc(sizeof(char)*size);\n\t\t//WARNING: Buffers are NOT ALIGNED IN THE BITSTREAM\n\t\tfor (i=0; i<size; i++) {\n\t\t\t((SFImage *)field->far_ptr)->pixels[i] = gf_bs_read_int(bs, 8);\n\t\t}\n\t\tbreak;\n\tcase GF_SG_VRML_SFCOMMANDBUFFER:\n\t{\n\t\tSFCommandBuffer *sfcb = (SFCommandBuffer *)field->far_ptr;\n\t\tif (!node) return GF_BAD_PARAM;\n\t\tif (sfcb->buffer) {\n\t\t\tgf_free(sfcb->buffer);\n\t\t\tsfcb->buffer = NULL;\n\t\t}\n\t\twhile (gf_list_count(sfcb->commandList)) {\n\t\t\tGF_Command *com = (GF_Command*)gf_list_get(sfcb->commandList, 0);\n\t\t\tgf_list_rem(sfcb->commandList, 0);\n\t\t\tgf_sg_command_del(com);\n\t\t}\n\n\t\tsize = gf_bs_read_int(bs, 5);\n\t\tlength = gf_bs_read_int(bs, size);\n\t\tif (gf_bs_available(bs) < length) return GF_NON_COMPLIANT_BITSTREAM;\n\n\t\tsfcb->bufferSize = length;\n\t\tif (length) {\n\t\t\tsfcb->buffer = (unsigned char *)gf_malloc(sizeof(char)*(length));\n\t\t\t//WARNING Buffers are NOT ALIGNED IN THE BITSTREAM\n\t\t\tfor (i=0; i<length; i++) {\n\t\t\t\tsfcb->buffer[i] = gf_bs_read_int(bs, 8);\n\t\t\t}\n\t\t}\n\t\t//notify the node - this is needed in case an enhencement layer replaces the buffer, in which case\n\t\t//the # ID Bits may change\n\t\tSFCommandBufferChanged(codec, node);\n\n\t\t/*\n\t\t 1 - memory mode, register command buffer for later parsing\n\t\t 2 - InputSensor only works on decompressed commands\n\t\t*/\n\t\tif (codec->dec_memory_mode || (node->sgprivate->tag==TAG_MPEG4_InputSensor)) {\n\t\t\tCommandBufferItem *cbi = (CommandBufferItem *)gf_malloc(sizeof(CommandBufferItem));\n\t\t\tcbi->node = node;\n\t\t\tgf_node_register(cbi->node, NULL);\n\t\t\tcbi->cb = sfcb;\n\t\t\tgf_list_add(codec->command_buffers, cbi);\n\t\t}\n\t}\n\tbreak;\n\tcase GF_SG_VRML_SFNODE:\n\t\t//if not memory dec mode, unregister previous node\n\t\t//otherwise the field points to the memory command internal field\n\t\tif (!is_mem_com) {\n\t\t\tGF_Node *old_node = *((GF_Node **) field->far_ptr);\n\t\t\tif (old_node != NULL) {\n\t\t\t\tu32 i, count = gf_list_count(codec->command_buffers);\n\t\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\t\tCommandBufferItem *cbi = (CommandBufferItem*) gf_list_get(codec->command_buffers, i);\n\t\t\t\t\tif (cbi->node == old_node) {\n\t\t\t\t\t\tgf_list_rem(codec->command_buffers, i);\n\t\t\t\t\t\ti--;\n\t\t\t\t\t\tcount--;\n\t\t\t\t\t\tgf_node_unregister(cbi->node, NULL);\n\t\t\t\t\t\tgf_free(cbi);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_node_unregister(old_node, node);\n\t\t\t\t *((GF_Node **) field->far_ptr) = NULL;\n\t\t\t}\n\t\t}\n\t\t//for nodes the field ptr is a ptr to the field, which is a node ptr ;)\n\t\tnew_node = gf_bifs_dec_node(codec, bs, field->NDTtype);\n\t\tif (new_node) {\n\t\t\te = gf_node_register(new_node, is_mem_com ? NULL : node);\n\t\t\tif (e) return e;\n\t\t}\n\t\t//it may happen that new_node is NULL (this is valid for a proto declaration)\n\t\t*((GF_Node **) field->far_ptr) = new_node;\n\t\tbreak;\n\tcase GF_SG_VRML_SFSCRIPT:\n#ifdef GPAC_HAS_QJS\n\t\tcodec->LastError = node ? SFScript_Parse(codec, (SFScript*)field->far_ptr, bs, node) : GF_NON_COMPLIANT_BITSTREAM;\n#else\n\t\treturn GF_NOT_SUPPORTED;\n#endif\n\t\tbreak;\n\tcase GF_SG_VRML_SFATTRREF:\n\t{\n\t\tSFAttrRef *ar = (SFAttrRef *)field->far_ptr;\n\t\tu32 nodeID = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits);\n\t\tar->node = gf_sg_find_node(codec->current_graph, nodeID);\n\t\tif (!ar->node) {\n\n\t\t} else {\n\t\t\tu32 nbBitsDEF = gf_get_bit_size(gf_node_get_num_fields_in_mode(ar->node, GF_SG_FIELD_CODING_DEF) - 1);\n\t\t\tu32 field_ref = gf_bs_read_int(bs, nbBitsDEF);\n\t\t\tcodec->LastError = gf_bifs_get_field_index(ar->node, field_ref, GF_SG_FIELD_CODING_DEF, &ar->fieldIndex);\n\t\t}\n\t}\n\tbreak;\n\tdefault:\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\treturn codec->LastError;\n}\n\nGF_Err BD_DecMFFieldList(GF_BifsDecoder * codec, GF_BitStream *bs, GF_Node *node, GF_FieldInfo *field, Bool is_mem_com)\n{\n\tGF_Node *new_node;\n\tGF_Err e;\n\tu8 endFlag, qp_local, qp_on, initial_qp;\n\tGF_ChildNodeItem *last = NULL;\n\tu32 nbF;\n\n\tGF_FieldInfo sffield;\n\n\tmemset(&sffield, 0, sizeof(GF_FieldInfo));\n\tsffield.fieldIndex = field->fieldIndex;\n\tsffield.fieldType = gf_sg_vrml_get_sf_type(field->fieldType);\n\tsffield.NDTtype = field->NDTtype;\n\tsffield.name = field->name;\n\n\tnbF = 0;\n\tqp_on = qp_local = 0;\n\tinitial_qp = codec->ActiveQP ? 1 : 0;\n\n\tendFlag = gf_bs_read_int(bs, 1);\n\twhile (!endFlag  && (codec->LastError>=0)) {\n\t\tif (field->fieldType != GF_SG_VRML_MFNODE) {\n\t\t\te = gf_sg_vrml_mf_append(field->far_ptr, field->fieldType, & sffield.far_ptr);\n\t\t\tif (e) return e;\n\t\t\te = gf_bifs_dec_sf_field(codec, bs, node, &sffield, GF_FALSE);\n\t\t\tif (e) return e;\n\t\t} else {\n\t\t\tnew_node = gf_bifs_dec_node(codec, bs, field->NDTtype);\n\t\t\t//append\n\t\t\tif (new_node) {\n\t\t\t\te = gf_node_register(new_node, is_mem_com ? NULL : node);\n\t\t\t\tif (e) return e;\n\n\t\t\t\t//regular coding\n\t\t\t\tif (node) {\n\t\t\t\t\t//special case for QP, register as the current QP\n\t\t\t\t\tif (gf_node_get_tag(new_node) == TAG_MPEG4_QuantizationParameter) {\n\t\t\t\t\t\tqp_local = ((M_QuantizationParameter *)new_node)->isLocal;\n\t\t\t\t\t\t//we have a QP in the same scope, remove previous\n\t\t\t\t\t\tif (qp_on) gf_bifs_dec_qp_remove(codec, GF_FALSE);\n\t\t\t\t\t\te = gf_bifs_dec_qp_set(codec, new_node);\n\t\t\t\t\t\tif (e) return e;\n\t\t\t\t\t\tqp_on = 1;\n\t\t\t\t\t\tif (qp_local) qp_local = 2;\n\t\t\t\t\t\tif (codec->force_keep_qp) {\n\t\t\t\t\t\t\te = gf_node_list_add_child_last(field->far_ptr, new_node, &last);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgf_node_register(new_node, NULL);\n\t\t\t\t\t\t\tgf_node_unregister(new_node, node);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else\n\t\t\t\t\t\t//this is generic MFNode container\n\t\t\t\t\t\te = gf_node_list_add_child_last(field->far_ptr, new_node, &last);\n\n\t\t\t\t}\n\t\t\t\t//proto coding: directly add the child\n\t\t\t\telse if (codec->pCurrentProto) {\n\t\t\t\t\t//TO DO: what happens if this is a QP node on the interface ?\n\t\t\t\t\te = gf_node_list_add_child_last( (GF_ChildNodeItem **)field->far_ptr, new_node, &last);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn codec->LastError;\n\t\t\t}\n\t\t}\n\t\tif (e) return e;\n\n\t\tendFlag = gf_bs_read_int(bs, 1);\n\n\t\t//according to the spec, the QP applies to the current node itself,\n\t\t//not just children. If IsLocal is TRUE remove the node\n\t\tif (qp_on && qp_local) {\n\t\t\tif (qp_local == 2) {\n\t\t\t\tqp_local = 1;\n\t\t\t} else {\n\t\t\t\t//ask to get rid of QP and reactivate if we had a QP when entering\n\t\t\t\tgf_bifs_dec_qp_remove(codec, initial_qp);\n\t\t\t\tqp_local = 0;\n\t\t\t\tqp_on = 0;\n\t\t\t}\n\t\t}\n\t\tnbF += 1;\n\t}\n\t/*finally delete the QP if any (local or not) as we get out of this node\n\tand reactivate previous one*/\n\tif (qp_on) gf_bifs_dec_qp_remove(codec, initial_qp);\n\t/*this is for QP 14*/\n\tgf_bifs_dec_qp14_set_length(codec, nbF);\n\treturn GF_OK;\n}\n\nGF_Err BD_DecMFFieldVec(GF_BifsDecoder * codec, GF_BitStream *bs, GF_Node *node, GF_FieldInfo *field, Bool is_mem_com)\n{\n\tGF_Err e;\n\tu32 NbBits, nbFields;\n\tu32 i;\n\tGF_ChildNodeItem *last;\n\tu8 qp_local, qp_on, initial_qp;\n\tGF_FieldInfo sffield;\n\n\tmemset(&sffield, 0, sizeof(GF_FieldInfo));\n\tsffield.fieldIndex = field->fieldIndex;\n\tsffield.fieldType = gf_sg_vrml_get_sf_type(field->fieldType);\n\tsffield.NDTtype = field->NDTtype;\n\tsffield.name = field->name;\n\n\tinitial_qp = qp_local = qp_on = 0;\n\n\t//vector description - alloc the MF size before\n\tNbBits = gf_bs_read_int(bs, 5);\n\tnbFields = gf_bs_read_int(bs, NbBits);\n\n\tif (codec->ActiveQP) {\n\t\tinitial_qp = 1;\n\t\t/*this is for QP 14*/\n\t\tgf_bifs_dec_qp14_set_length(codec, nbFields);\n\t}\n\n\tif (field->fieldType != GF_SG_VRML_MFNODE) {\n\t\te = gf_sg_vrml_mf_alloc(field->far_ptr, field->fieldType, nbFields);\n\t\tif (e) return e;\n\n\t\tfor (i=0; i<nbFields; i++) {\n\t\t\te = gf_sg_vrml_mf_get_item(field->far_ptr, field->fieldType, & sffield.far_ptr, i);\n\t\t\tif (e) return e;\n\t\t\te = gf_bifs_dec_sf_field(codec, bs, node, &sffield, GF_FALSE);\n\t\t\tif (e) return e;\n\t\t}\n\t} else {\n\t\tlast = NULL;\n\t\tfor (i=0; i<nbFields; i++) {\n\t\t\tGF_Node *new_node = gf_bifs_dec_node(codec, bs, field->NDTtype);\n\t\t\tif (new_node) {\n\t\t\t\te = gf_node_register(new_node, is_mem_com ? NULL : node);\n\t\t\t\tif (e) return e;\n\n\t\t\t\tif (node) {\n\t\t\t\t\t/*special case for QP, register as the current QP*/\n\t\t\t\t\tif (gf_node_get_tag(new_node) == TAG_MPEG4_QuantizationParameter) {\n\t\t\t\t\t\tqp_local = ((M_QuantizationParameter *)new_node)->isLocal;\n\t\t\t\t\t\t/*we have a QP in the same scope, remove previous\n\t\t\t\t\t\tNB: we assume this is the right behavior, the spec doesn't say\n\t\t\t\t\t\twhether QP is cumulative or not*/\n\t\t\t\t\t\tif (qp_on) gf_bifs_dec_qp_remove(codec, GF_FALSE);\n\n\t\t\t\t\t\te = gf_bifs_dec_qp_set(codec, new_node);\n\t\t\t\t\t\tif (e) return e;\n\t\t\t\t\t\tqp_on = 1;\n\t\t\t\t\t\tif (qp_local) qp_local = 2;\n\t\t\t\t\t\tif (codec->force_keep_qp) {\n\t\t\t\t\t\t\te = gf_node_list_add_child_last(field->far_ptr, new_node, &last);\n\t\t\t\t\t\t\tif (e) return e;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgf_node_register(new_node, NULL);\n\t\t\t\t\t\t\tgf_node_unregister(new_node, node);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\te = gf_node_list_add_child_last(field->far_ptr, new_node, &last);\n\t\t\t\t\t\tif (e) return e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*proto coding*/\n\t\t\t\telse if (codec->pCurrentProto) {\n\t\t\t\t\t/*TO DO: what happens if this is a QP node on the interface ?*/\n\t\t\t\t\te = gf_node_list_add_child_last( (GF_ChildNodeItem **)field->far_ptr, new_node, &last);\n\t\t\t\t\tif (e) return e;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn codec->LastError ? codec->LastError : GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t}\n\t\t}\n\t\t/*according to the spec, the QP applies to the current node itself, not just children.\n\t\tIf IsLocal is TRUE remove the node*/\n\t\tif (qp_on && qp_local) {\n\t\t\tif (qp_local == 2) {\n//\t\t\t\tqp_local = 1;\n\t\t\t} else {\n\t\t\t\t//ask to get rid of QP and reactivate if we had a QP when entering the node\n\t\t\t\tgf_bifs_dec_qp_remove(codec, initial_qp);\n//\t\t\t\tqp_local = 0;\n\t\t\t}\n\t\t}\n\t}\n\t/*finally delete the QP if any (local or not) as we get out of this node*/\n\tif (qp_on) gf_bifs_dec_qp_remove(codec, GF_TRUE);\n\treturn GF_OK;\n}\n\n\nvoid gf_bifs_check_field_change(GF_Node *node, GF_FieldInfo *field)\n{\n\tif (field->fieldType==GF_SG_VRML_MFNODE) node->sgprivate->flags |= GF_SG_CHILD_DIRTY;\n\t/*signal node modif*/\n\tgf_node_changed(node, field);\n\t/*Notify eventOut in all cases to handle protos*/\n\tgf_node_event_out(node, field->fieldIndex);\n\t/*and propagate eventIn if any*/\n\tif (field->on_event_in) {\n\t\tfield->on_event_in(node, NULL);\n\t} else if ((gf_node_get_tag(node) == TAG_MPEG4_Script) && (field->eventType==GF_SG_EVENT_IN)) {\n\t\tgf_sg_script_event_in(node, field);\n\t}\n\n}\n\nGF_Err gf_bifs_dec_field(GF_BifsDecoder * codec, GF_BitStream *bs, GF_Node *node, GF_FieldInfo *field, Bool is_mem_com)\n{\n\tGF_Err e;\n\tu8 flag;\n\n//\tif (codec->LastError) return codec->LastError;\n\n\tassert(node);\n//\tif (field->fieldType == GF_SG_VRML_UNKNOWN) return GF_NON_COMPLIANT_BITSTREAM;\n\n\tif (gf_sg_vrml_is_sf_field(field->fieldType)) {\n\t\te = gf_bifs_dec_sf_field(codec, bs, node, field, is_mem_com);\n\t\tif (e) return e;\n\t} else {\n\t\t/*clean up the eventIn field if not done*/\n\t\tif (field->eventType == GF_SG_EVENT_IN) {\n\t\t\tif (field->fieldType == GF_SG_VRML_MFNODE) {\n\t\t\t\tgf_node_unregister_children(node, * (GF_ChildNodeItem **)field->far_ptr);\n\t\t\t\t* (GF_ChildNodeItem **)field->far_ptr = NULL;\n\t\t\t} else {\n\t\t\t\t//remove all items of the MFField\n\t\t\t\te = gf_sg_vrml_mf_reset(field->far_ptr, field->fieldType);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t}\n\n\t\t/*predictiveMFField*/\n\t\tif (codec->info->config.UsePredictiveMFField) {\n\t\t\tflag = gf_bs_read_int(bs, 1);\n\t\t\tif (flag) {\n#ifdef GPAC_ENABLE_BIFS_PMF\n\t\t\t\treturn gf_bifs_dec_pred_mf_field(codec, bs, node, field);\n#else\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[BIFS] Stream uses Predictive Field Coding, disabled in this build!\\n\"));\n\t\t\t\treturn GF_NOT_SUPPORTED;\n#endif\n\t\t\t}\n\t\t}\n\n\t\t/*reserved*/\n\t\tflag = gf_bs_read_int(bs, 1);\n\t\tif (!flag) {\n\t\t\t/*destroy the field content...*/\n\t\t\tif (field->fieldType != GF_SG_VRML_MFNODE) {\n\t\t\t\te = gf_sg_vrml_mf_reset(field->far_ptr, field->fieldType);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t\t/*List description - alloc is dynamic*/\n\t\t\tflag = gf_bs_read_int(bs, 1);\n\t\t\tif (flag) {\n\t\t\t\te = BD_DecMFFieldList(codec, bs, node, field, is_mem_com);\n\t\t\t} else {\n\t\t\t\te = BD_DecMFFieldVec(codec, bs, node, field, is_mem_com);\n\t\t\t}\n\t\t\tif (e) return codec->LastError = e;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err BD_SetProtoISed(GF_BifsDecoder * codec, u32 protofield, GF_Node *n, u32 nodefield)\n{\n\t/*take care of conditional execution in proto*/\n\tif (codec->current_graph->pOwningProto) {\n\t\treturn gf_sg_proto_instance_set_ised((GF_Node *) codec->current_graph->pOwningProto, protofield, n, nodefield);\n\t}\n\t/*regular ISed fields*/\n\telse {\n\t\treturn gf_sg_proto_field_set_ised(codec->pCurrentProto, protofield, n, nodefield);\n\t}\n}\n\nGF_Err gf_bifs_dec_node_list(GF_BifsDecoder * codec, GF_BitStream *bs, GF_Node *node, Bool is_proto)\n{\n\tu8 flag;\n\tGF_Err e;\n\tu32 numBitsALL, numBitsDEF, field_all, field_ref, numProtoBits;\n\tGF_FieldInfo field;\n\n\tnumProtoBits = numBitsALL = 0;\n\tif (codec->pCurrentProto) {\n\t\tnumProtoBits = gf_get_bit_size(gf_sg_proto_get_field_count(codec->pCurrentProto) - 1);\n\t\tnumBitsALL = gf_get_bit_size(gf_node_get_num_fields_in_mode(node, GF_SG_FIELD_CODING_ALL)-1);\n\t}\n\tnumBitsDEF = gf_get_bit_size(gf_node_get_num_fields_in_mode(node, GF_SG_FIELD_CODING_DEF)-1);\n\n\tflag = gf_bs_read_int(bs, 1);\n\twhile (!flag && (codec->LastError>=0)) {\n\t\tif (codec->pCurrentProto) {\n\t\t\t//IS'ed flag\n\t\t\tflag = gf_bs_read_int(bs, 1);\n\t\t\tif (flag) {\n\t\t\t\t//get field index in ALL mode for node\n\t\t\t\tfield_ref = gf_bs_read_int(bs, numBitsALL);\n\t\t\t\t//get field index in ALL mode for proto\n\t\t\t\tfield_all = gf_bs_read_int(bs, numProtoBits);\n\t\t\t\te = gf_node_get_field(node, field_ref, &field);\n\t\t\t\tif (e) return e;\n\t\t\t\te = BD_SetProtoISed(codec, field_all, node, field_ref);\n\t\t\t\tif (e) return e;\n\t\t\t\tflag = gf_bs_read_int(bs, 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t//fields are coded in DEF mode\n\t\tfield_ref = gf_bs_read_int(bs, numBitsDEF);\n\t\te = gf_bifs_get_field_index(node, field_ref, GF_SG_FIELD_CODING_DEF, &field_all);\n\t\tif (e) return e;\n\t\te = gf_node_get_field(node, field_all, &field);\n\t\tif (e) return e;\n\t\te = gf_bifs_dec_field(codec, bs, node, &field, GF_FALSE);\n\t\tif (e) return e;\n\t\tflag = gf_bs_read_int(bs, 1);\n\n\t\tif (is_proto) gf_sg_proto_mark_field_loaded(node, &field);\n\t}\n\treturn codec->LastError;\n}\n\nGF_Err gf_bifs_dec_node_mask(GF_BifsDecoder * codec, GF_BitStream *bs, GF_Node *node, Bool is_proto)\n{\n\tu32 i, numFields, numProtoFields, index, flag, nbBits;\n\tGF_Err e;\n\tGF_FieldInfo field;\n\n\t//proto coding\n\tif (codec->pCurrentProto) {\n\t\tnumFields = gf_node_get_num_fields_in_mode(node, GF_SG_FIELD_CODING_ALL);\n\t\tnumProtoFields = gf_sg_proto_get_field_count(codec->pCurrentProto);\n\t\tnbBits = gf_get_bit_size(numProtoFields-1);\n\n\t\tfor (i=0; i<numFields; i++) {\n\t\t\tflag = gf_bs_read_int(bs, 1);\n\t\t\tif (!flag) continue;\n\t\t\tflag = gf_bs_read_int(bs, 1);\n\t\t\t//IS'ed field, create route for binding to Proto declaration\n\t\t\tif (flag) {\n\t\t\t\t//reference index of our IS'ed proto field\n\t\t\t\tflag = gf_bs_read_int(bs, nbBits);\n\t\t\t\te = gf_node_get_field(node, i, &field);\n\t\t\t\tif (e) return e;\n\t\t\t\te = BD_SetProtoISed(codec, flag, node, i);\n\t\t\t}\n\t\t\t//regular field, parse it (nb: no contextual coding for protos in maskNode,\n\t\t\t//all node fields are coded\n\t\t\telse {\n\t\t\t\te = gf_node_get_field(node, i, &field);\n\t\t\t\tif (e) return e;\n\t\t\t\te = gf_bifs_dec_field(codec, bs, node, &field, GF_FALSE);\n\t\t\t}\n\t\t\tif (e) return e;\n\t\t}\n\t}\n\t//regular coding\n\telse {\n\t\tnumFields = gf_node_get_num_fields_in_mode(node, GF_SG_FIELD_CODING_DEF);\n\t\tfor (i=0; i<numFields; i++) {\n\t\t\tflag = gf_bs_read_int(bs, 1);\n\t\t\tif (!flag) continue;\n\t\t\tgf_bifs_get_field_index(node, i, GF_SG_FIELD_CODING_DEF, &index);\n\t\t\te = gf_node_get_field(node, index, &field);\n\t\t\tif (e) return e;\n\t\t\te = gf_bifs_dec_field(codec, bs, node, &field, GF_FALSE);\n\t\t\tif (e) return e;\n\n\t\t\tif (is_proto) gf_sg_proto_mark_field_loaded(node, &field);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\nstatic void UpdateTimeNode(GF_BifsDecoder * codec, GF_Node *node)\n{\n\tswitch (gf_node_get_tag(node)) {\n\tcase TAG_MPEG4_AnimationStream:\n\t\tBD_OffsetSFTime(codec, & ((M_AnimationStream*)node)->startTime);\n\t\tBD_OffsetSFTime(codec, & ((M_AnimationStream*)node)->stopTime);\n\t\tbreak;\n\tcase TAG_MPEG4_AudioBuffer:\n\t\tBD_OffsetSFTime(codec, & ((M_AudioBuffer*)node)->startTime);\n\t\tBD_OffsetSFTime(codec, & ((M_AudioBuffer*)node)->stopTime);\n\t\tbreak;\n\tcase TAG_MPEG4_AudioClip:\n\t\tBD_OffsetSFTime(codec, & ((M_AudioClip*)node)->startTime);\n\t\tBD_OffsetSFTime(codec, & ((M_AudioClip*)node)->stopTime);\n\t\tbreak;\n\tcase TAG_MPEG4_AudioSource:\n\t\tBD_OffsetSFTime(codec, & ((M_AudioSource*)node)->startTime);\n\t\tBD_OffsetSFTime(codec, & ((M_AudioSource*)node)->stopTime);\n\t\tbreak;\n\tcase TAG_MPEG4_MovieTexture:\n\t\tBD_OffsetSFTime(codec, & ((M_MovieTexture*)node)->startTime);\n\t\tBD_OffsetSFTime(codec, & ((M_MovieTexture*)node)->stopTime);\n\t\tbreak;\n\tcase TAG_MPEG4_TimeSensor:\n\t\tBD_OffsetSFTime(codec, & ((M_TimeSensor*)node)->startTime);\n\t\tBD_OffsetSFTime(codec, & ((M_TimeSensor*)node)->stopTime);\n\t\tbreak;\n\tcase TAG_ProtoNode:\n\t{\n\t\tu32 i, nbFields;\n\t\tGF_FieldInfo inf;\n\t\tnbFields = gf_node_get_num_fields_in_mode(node, GF_SG_FIELD_CODING_ALL);\n\t\tfor (i=0; i<nbFields; i++) {\n\t\t\tgf_node_get_field(node, i, &inf);\n\t\t\tif (inf.fieldType != GF_SG_VRML_SFTIME) continue;\n\t\t\tBD_CheckSFTimeOffset(codec, node, &inf);\n\t\t}\n\t}\n\tbreak;\n\t}\n}\n\nGF_Node *gf_bifs_dec_node(GF_BifsDecoder * codec, GF_BitStream *bs, u32 NDT_Tag)\n{\n\tu32 nodeID, NDTBits, node_type, node_tag, ProtoID, BVersion;\n\tBool skip_init, reset_qp14;\n\tGF_Node *new_node;\n\tGF_Err e;\n\tGF_Proto *proto;\n\tvoid SetupConditional(GF_BifsDecoder *codec, GF_Node *node);\n\n\t//to store the UseName\n\tchar name[1000];\n\n#if 0\n\t/*should only happen with inputSensor, in which case this is BAAAAD*/\n\tif (!codec->info) {\n\t\tcodec->LastError = GF_BAD_PARAM;\n\t\treturn NULL;\n\t}\n#endif\n\n\n\tBVersion = GF_BIFS_V1;\n\n\t/*this is a USE statement*/\n\tif (gf_bs_read_int(bs, 1)) {\n\t\tnodeID = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits);\n\t\t/*NULL node is encoded as USE with ID = all bits to 1*/\n\t\tif (nodeID == (u32) (1<<codec->info->config.NodeIDBits))\n\t\t\treturn NULL;\n\t\t//find node\n\t\tnew_node = gf_sg_find_node(codec->current_graph, nodeID);\n\n\t\t//check node is allowed for the given NDT\n\t\tif (new_node && !gf_node_in_table(new_node, NDT_Tag)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[BIFS] Node %s not allowed as field/child of NDT type %d\\n\", gf_node_get_class_name(new_node), NDT_Tag));\n\t\t\tcodec->LastError = GF_SG_UNKNOWN_NODE;\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (!new_node) {\n\t\t\tcodec->LastError = GF_SG_UNKNOWN_NODE;\n\t\t} else {\n\t\t\t/*restore QP14 length*/\n\t\t\tswitch (gf_node_get_tag(new_node)) {\n\t\t\tcase TAG_MPEG4_Coordinate:\n\t\t\t{\n\t\t\t\tu32 nbCoord = ((M_Coordinate *)new_node)->point.count;\n\t\t\t\tgf_bifs_dec_qp14_enter(codec, GF_TRUE);\n\t\t\t\tgf_bifs_dec_qp14_set_length(codec, nbCoord);\n\t\t\t\tgf_bifs_dec_qp14_enter(codec, GF_FALSE);\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase TAG_MPEG4_Coordinate2D:\n\t\t\t{\n\t\t\t\tu32 nbCoord = ((M_Coordinate2D *)new_node)->point.count;\n\t\t\t\tgf_bifs_dec_qp14_enter(codec, GF_TRUE);\n\t\t\t\tgf_bifs_dec_qp14_set_length(codec, nbCoord);\n\t\t\t\tgf_bifs_dec_qp14_enter(codec, GF_FALSE);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn new_node;\n\t}\n\n\t//this is a new node\n\tnodeID = 0;\n\tname[0] = 0;\n\tnode_tag = 0;\n\tproto = NULL;\n\n\t//browse all node groups\n\twhile (1) {\n\t\tNDTBits = gf_bifs_get_ndt_bits(NDT_Tag, BVersion);\n\t\t/*this happens in replacescene where no top-level node is present (externProto)*/\n\t\tif ((BVersion==1) && (NDTBits > 8 * gf_bs_available(bs)) ) {\n\t\t\tcodec->LastError = GF_OK;\n\t\t\treturn NULL;\n\t\t}\n\n\t\tnode_type = gf_bs_read_int(bs, NDTBits);\n\t\tif (node_type) break;\n\n\t\t//increment BIFS version\n\t\tBVersion += 1;\n\t\t//not supported\n\t\tif (BVersion > GF_BIFS_NUM_VERSION) {\n\t\t\tcodec->LastError = GF_BIFS_UNKNOWN_VERSION;\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tif (BVersion==2 && node_type==1) {\n\t\tProtoID = gf_bs_read_int(bs, codec->info->config.ProtoIDBits);\n\t\t/*look in current graph for the proto - this may be a proto graph*/\n\t\tproto = gf_sg_find_proto(codec->current_graph, ProtoID, NULL);\n\t\t/*this was in proto so look in main scene*/\n\t\tif (!proto && codec->current_graph != codec->scenegraph)\n\t\t\tproto = gf_sg_find_proto(codec->scenegraph, ProtoID, NULL);\n\n\t\tif (!proto) {\n\t\t\tcodec->LastError = GF_SG_UNKNOWN_NODE;\n\t\t\treturn NULL;\n\t\t}\n\t} else {\n\t\tnode_tag = gf_bifs_ndt_get_node_type(NDT_Tag, node_type, BVersion);\n\t}\n\n\t/*special handling of 3D mesh*/\n\tif ((node_tag == TAG_MPEG4_IndexedFaceSet) && codec->info->config.Use3DMeshCoding) {\n\t\tif (gf_bs_read_int(bs, 1)) {\n\t\t\t/*nodeID = 1 + */gf_bs_read_int(bs, codec->info->config.NodeIDBits);\n\t\t\tif (codec->UseName) gf_bifs_dec_name(bs, name, 1000);\n\t\t}\n\t\t/*parse the 3DMesh node*/\n\t\treturn NULL;\n\t}\n\t/*unknown node*/\n\tif (!node_tag && !proto) {\n\t\tcodec->LastError = GF_SG_UNKNOWN_NODE;\n\t\treturn NULL;\n\t}\n\n\n\t/*DEF'd flag*/\n\tif (gf_bs_read_int(bs, 1)) {\n\t\tif (!codec->info->config.NodeIDBits) {\n\t\t\tcodec->LastError = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\treturn NULL;\n\t\t}\n\t\tnodeID = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits);\n\t\tif (codec->UseName) gf_bifs_dec_name(bs, name, 1000);\n\t}\n\n\tnew_node = NULL;\n\tskip_init = GF_FALSE;\n\n\t/*don't check node IDs duplicate since VRML may use them...*/\n#if 0\n\t/*if a node with same DEF is already in the scene, use it\n\twe don't do that in memory mode because commands may force replacement\n\tof a node with a new node with same ID, and we want to be able to dump it (otherwise we would\n\tdump a USE)*/\n\tif (nodeID && !codec->dec_memory_mode) {\n\t\tnew_node = gf_sg_find_node(codec->current_graph, nodeID);\n\t\tif (new_node) {\n\t\t\tif (proto) {\n\t\t\t\tif ((gf_node_get_tag(new_node) != TAG_ProtoNode) || (gf_node_get_proto(new_node) != proto)) {\n\t\t\t\t\tcodec->LastError = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tskip_init = 1;\n\t\t\t} else {\n\t\t\t\tif (gf_node_get_tag(new_node) != node_tag) {\n\t\t\t\t\tcodec->LastError = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tskip_init = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (!new_node)\n#endif\n\n\t{\n\t\tif (proto) {\n\t\t\t/*create proto interface*/\n\t\t\tnew_node = gf_sg_proto_create_instance(codec->current_graph, proto);\n            //don't init protos unless externProto (in which case we want init for hardcoded protos)\n            if (! proto->ExternProto.count) skip_init = GF_TRUE;\n\t\t} else {\n\t\t\tnew_node = gf_node_new(codec->current_graph, node_tag);\n\t\t}\n\t}\n\tif (!new_node) {\n\t\tcodec->LastError = GF_NOT_SUPPORTED;\n\t\treturn NULL;\n\t}\n\n\t/*update default time fields except in proto parsing*/\n\tif (!codec->pCurrentProto) UpdateTimeNode(codec, new_node);\n\t/*nodes are only init outside protos, nodes internal to protos are never intialized */\n\telse skip_init = GF_TRUE;\n\n\t/*if coords were not stored for QP14 before coding this node, reset QP14 it when leaving*/\n\treset_qp14 = !codec->coord_stored;\n\n\t/*QP 14 is a special quant mode for IndexFace/Line(2D)Set to quantize the\n\tcoordonate(2D) child, based on the first field parsed\n\twe must check the type of the node and notfy the QP*/\n\tswitch (node_tag) {\n\tcase TAG_MPEG4_Coordinate:\n\tcase TAG_MPEG4_Coordinate2D:\n\t\tgf_bifs_dec_qp14_enter(codec, GF_TRUE);\n\t}\n\n\tif (gf_bs_read_int(bs, 1)) {\n\t\te = gf_bifs_dec_node_mask(codec, bs, new_node, proto ? GF_TRUE : GF_FALSE);\n\t} else {\n\t\te = gf_bifs_dec_node_list(codec, bs, new_node, proto ? GF_TRUE : GF_FALSE);\n\t}\n\tif (codec->coord_stored && reset_qp14)\n\t\tgf_bifs_dec_qp14_reset(codec);\n\n\tif (e) {\n\t\tcodec->LastError = e;\n\t\t/*register*/\n\t\tgf_node_register(new_node, NULL);\n\t\t/*unregister (deletes)*/\n\t\tgf_node_unregister(new_node, NULL);\n\t\treturn NULL;\n\t}\n\n\t/*VRML: \"The transformation hierarchy shall be a directed acyclic graph; results are undefined if a node\n\tin the transformation hierarchy is its own ancestor\"\n\tthat's good, because the scene graph can't handle cyclic graphs (destroy will never be called).\n\tWe therefore only register the node once parsed*/\n\tif (nodeID) {\n\t\tif (strlen(name)) {\n\t\t\tgf_node_set_id(new_node, nodeID, name);\n\t\t} else {\n\t\t\tgf_node_set_id(new_node, nodeID, NULL);\n\t\t}\n\t}\n\n\tif (!skip_init)\n\t\tgf_node_init(new_node);\n\n\tswitch (node_tag) {\n\tcase TAG_MPEG4_Coordinate:\n\tcase TAG_MPEG4_Coordinate2D:\n\t\tgf_bifs_dec_qp14_enter(codec, GF_FALSE);\n\t\tbreak;\n\tcase TAG_MPEG4_Script:\n\t\t/*load script if in main graph (useless to load in proto declaration)*/\n\t\tif (codec->scenegraph == codec->current_graph) {\n\t\t\tgf_sg_script_load(new_node);\n\t\t}\n\t\tbreak;\n\t/*conditionals must be init*/\n\tcase TAG_MPEG4_Conditional:\n\t\tSetupConditional(codec, new_node);\n\t\tbreak;\n\t}\n\n\t/*proto is initialized upon the first traversal to have the same behavior as wth BT/XMT loading*/\n#if 0\n\t/*if new node is a proto and we're in the top scene, load proto code*/\n\tif (proto && (codec->scenegraph == codec->current_graph)) {\n\t\tcodec->LastError = gf_sg_proto_load_code(new_node);\n\t}\n#endif\n\n\treturn new_node;\n}\n\n#endif /*GPAC_DISABLE_BIFS*/\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2012\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / BIFS codec sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n\n\n#include <gpac/internal/bifs_dev.h>\n#include <gpac/scene_manager.h>\n#include \"quant.h\"\n#include \"script.h\"\n\n#ifndef GPAC_DISABLE_BIFS\n\nvoid SFCommandBufferChanged(GF_BifsDecoder * codec, GF_Node *node)\n{\n\tvoid Conditional_BufferReplaced(GF_BifsDecoder * codec, GF_Node *node);\n\n\tswitch (gf_node_get_tag(node)) {\n\tcase TAG_MPEG4_Conditional:\n\t\tConditional_BufferReplaced(codec, node);\n\t\tbreak;\n\t}\n}\n\n\n//startTimes, stopTimes and co are coded as relative to their AU timestamp when received\n//on the wire. If from scripts or within proto the offset doesn't apply\nvoid BD_OffsetSFTime(GF_BifsDecoder * codec, Double *time)\n{\n\tif ((!codec->is_com_dec && codec->pCurrentProto) || codec->dec_memory_mode) return;\n\t*time += codec->cts_offset;\n}\n\nvoid BD_CheckSFTimeOffset(GF_BifsDecoder *codec, GF_Node *node, GF_FieldInfo *inf)\n{\n\tif (gf_node_get_tag(node) != TAG_ProtoNode) {\n\t\tif (!stricmp(inf->name, \"startTime\") || !stricmp(inf->name, \"stopTime\"))\n\t\t\tBD_OffsetSFTime(codec,  (Double *)inf->far_ptr);\n\t} else if (gf_sg_proto_field_is_sftime_offset(node, inf)) {\n\t\tBD_OffsetSFTime(codec,  (Double *)inf->far_ptr);\n\t}\n}\n\n\nFixed BD_ReadSFFloat(GF_BifsDecoder * codec, GF_BitStream *bs)\n{\n\tif (codec->ActiveQP && codec->ActiveQP->useEfficientCoding)\n\t\treturn gf_bifs_dec_mantissa_float(codec, bs);\n\n\treturn FLT2FIX(gf_bs_read_float(bs));\n}\n\n\nGF_Err gf_bifs_dec_sf_field(GF_BifsDecoder * codec, GF_BitStream *bs, GF_Node *node, GF_FieldInfo *field, Bool is_mem_com)\n{\n\tGF_Err e;\n\tGF_Node *new_node;\n\tu32 size, length, w, h, i;\n\tchar *buffer;\n\n\t//blindly call unquantize. return is OK, error or GF_EOS\n\tif (codec->ActiveQP && node) {\n\t\te = gf_bifs_dec_unquant_field(codec, bs, node, field);\n\t\tif (e != GF_EOS) return e;\n\t}\n\t//not quantized, use normal scheme\n\tswitch (field->fieldType) {\n\tcase GF_SG_VRML_SFBOOL:\n\t\t* ((SFBool *) field->far_ptr) = (SFBool) gf_bs_read_int(bs, 1);\n\t\tbreak;\n\tcase GF_SG_VRML_SFCOLOR:\n\t\t((SFColor *)field->far_ptr)->red = BD_ReadSFFloat(codec, bs);\n\t\t((SFColor *)field->far_ptr)->green = BD_ReadSFFloat(codec, bs);\n\t\t((SFColor *)field->far_ptr)->blue = BD_ReadSFFloat(codec, bs);\n\t\tbreak;\n\tcase GF_SG_VRML_SFFLOAT:\n\t\t*((SFFloat *)field->far_ptr) = BD_ReadSFFloat(codec, bs);\n\t\tbreak;\n\tcase GF_SG_VRML_SFINT32:\n\t\t*((SFInt32 *)field->far_ptr) = (s32) gf_bs_read_int(bs, 32);\n\t\tbreak;\n\tcase GF_SG_VRML_SFTIME:\n\t\t*((SFTime *)field->far_ptr) = gf_bs_read_double(bs);\n\t\tif (node) BD_CheckSFTimeOffset(codec, node, field);\n\t\tbreak;\n\tcase GF_SG_VRML_SFVEC2F:\n\t\t((SFVec2f *)field->far_ptr)->x = BD_ReadSFFloat(codec, bs);\n\t\t((SFVec2f *)field->far_ptr)->y = BD_ReadSFFloat(codec, bs);\n\t\tbreak;\n\tcase GF_SG_VRML_SFVEC3F:\n\t\t((SFVec3f *)field->far_ptr)->x = BD_ReadSFFloat(codec, bs);\n\t\t((SFVec3f *)field->far_ptr)->y = BD_ReadSFFloat(codec, bs);\n\t\t((SFVec3f *)field->far_ptr)->z = BD_ReadSFFloat(codec, bs);\n\t\tbreak;\n\tcase GF_SG_VRML_SFROTATION:\n\t\t((SFRotation *)field->far_ptr)->x = BD_ReadSFFloat(codec, bs);\n\t\t((SFRotation *)field->far_ptr)->y = BD_ReadSFFloat(codec, bs);\n\t\t((SFRotation *)field->far_ptr)->z = BD_ReadSFFloat(codec, bs);\n\t\t((SFRotation *)field->far_ptr)->q = BD_ReadSFFloat(codec, bs);\n\t\tbreak;\n\tcase GF_SG_VRML_SFSTRING:\n\t\tsize = gf_bs_read_int(bs, 5);\n\t\tlength = gf_bs_read_int(bs, size);\n\t\tif (gf_bs_available(bs) < length) return GF_NON_COMPLIANT_BITSTREAM;\n\n\t\tif (node && (node->sgprivate->tag==TAG_MPEG4_CacheTexture) && (field->fieldIndex<=2)) {\n\t\t\tM_CacheTexture *ct = (M_CacheTexture *) node;\n\t\t\tct->data_len = length;\n\t\t\tif (ct->data) gf_free(ct->data);\n\t\t\tct->data = (u8*)gf_malloc(sizeof(char)*length);\n\t\t\tgf_bs_read_data(bs, (char*)ct->data, length);\n\t\t} else if (node && (node->sgprivate->tag==TAG_MPEG4_BitWrapper) ) {\n\t\t\tM_BitWrapper *bw = (M_BitWrapper*) node;\n\t\t\tif (bw->buffer.buffer) gf_free(bw->buffer.buffer);\n\t\t\tbw->buffer_len = length;\n\t\t\tbw->buffer.buffer = (char*)gf_malloc(sizeof(char)*length);\n\t\t\tgf_bs_read_data(bs, (char*)bw->buffer.buffer, length);\n\t\t} else {\n\t\t\tif ( ((SFString *)field->far_ptr)->buffer ) gf_free( ((SFString *)field->far_ptr)->buffer);\n\t\t\t((SFString *)field->far_ptr)->buffer = (char *)gf_malloc(sizeof(char)*(length+1));\n\t\t\tmemset(((SFString *)field->far_ptr)->buffer , 0, length+1);\n\t\t\tfor (i=0; i<length; i++) {\n\t\t\t\t((SFString *)field->far_ptr)->buffer[i] = gf_bs_read_int(bs, 8);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase GF_SG_VRML_SFURL:\n\t{\n\t\tSFURL *url = (SFURL *) field->far_ptr;\n\t\tsize = gf_bs_read_int(bs, 1);\n\t\tif (size) {\n\t\t\tif (url->url) gf_free(url->url );\n\t\t\turl->url = NULL;\n\t\t\tlength = gf_bs_read_int(bs, 10);\n\t\t\turl->OD_ID = length;\n\t\t} else {\n\t\t\tif ( url->OD_ID ) url->OD_ID = (u32) -1;\n\t\t\tsize = gf_bs_read_int(bs, 5);\n\t\t\tlength = gf_bs_read_int(bs, size);\n\t\t\tif (gf_bs_available(bs) < length) return GF_NON_COMPLIANT_BITSTREAM;\n\t\t\tbuffer = NULL;\n\t\t\tif (length) {\n\t\t\t\tbuffer = (char *)gf_malloc(sizeof(char)*(length+1));\n\t\t\t\tmemset(buffer, 0, length+1);\n\t\t\t\tfor (i=0; i<length; i++) buffer[i] = gf_bs_read_int(bs, 8);\n\t\t\t}\n\t\t\tif (url->url) gf_free( url->url);\n\t\t\t/*if URL is empty set it to NULL*/\n\t\t\tif (buffer && strlen(buffer)) {\n\t\t\t\turl->url = buffer;\n\t\t\t} else {\n\t\t\t\tgf_free(buffer);\n\t\t\t\turl->url = NULL;\n\t\t\t}\n\t\t}\n\t}\n\tbreak;\n\tcase GF_SG_VRML_SFIMAGE:\n\t\tif (((SFImage *)field->far_ptr)->pixels) {\n\t\t\tgf_free(((SFImage *)field->far_ptr)->pixels);\n\t\t\t((SFImage *)field->far_ptr)->pixels = NULL;\n\t\t}\n\t\tw = gf_bs_read_int(bs, 12);\n\t\th = gf_bs_read_int(bs, 12);\n\t\tlength = gf_bs_read_int(bs, 2);\n\n\t\tif (length > 3) length = 3;\n\t\tlength += 1;\n\t\tsize = w * h * length;\n\t\tif (gf_bs_available(bs) < size) return GF_NON_COMPLIANT_BITSTREAM;\n\t\t((SFImage *)field->far_ptr)->width = w;\n\t\t((SFImage *)field->far_ptr)->height = h;\n\t\t((SFImage *)field->far_ptr)->numComponents = length;\n\t\t((SFImage *)field->far_ptr)->pixels = (unsigned char *)gf_malloc(sizeof(char)*size);\n\t\t//WARNING: Buffers are NOT ALIGNED IN THE BITSTREAM\n\t\tfor (i=0; i<size; i++) {\n\t\t\t((SFImage *)field->far_ptr)->pixels[i] = gf_bs_read_int(bs, 8);\n\t\t}\n\t\tbreak;\n\tcase GF_SG_VRML_SFCOMMANDBUFFER:\n\t{\n\t\tSFCommandBuffer *sfcb = (SFCommandBuffer *)field->far_ptr;\n\t\tif (!node) return GF_BAD_PARAM;\n\t\tif (sfcb->buffer) {\n\t\t\tgf_free(sfcb->buffer);\n\t\t\tsfcb->buffer = NULL;\n\t\t\tsfcb->bufferSize = 0;\n\t\t}\n\t\twhile (gf_list_count(sfcb->commandList)) {\n\t\t\tGF_Command *com = (GF_Command*)gf_list_get(sfcb->commandList, 0);\n\t\t\tgf_list_rem(sfcb->commandList, 0);\n\t\t\tgf_sg_command_del(com);\n\t\t}\n\n\t\tsize = gf_bs_read_int(bs, 5);\n\t\tlength = gf_bs_read_int(bs, size);\n\t\tif (gf_bs_available(bs) < length) return GF_NON_COMPLIANT_BITSTREAM;\n\n\t\tsfcb->bufferSize = length;\n\t\tif (length) {\n\t\t\tsfcb->buffer = (unsigned char *)gf_malloc(sizeof(char)*(length));\n\t\t\t//WARNING Buffers are NOT ALIGNED IN THE BITSTREAM\n\t\t\tfor (i=0; i<length; i++) {\n\t\t\t\tsfcb->buffer[i] = gf_bs_read_int(bs, 8);\n\t\t\t}\n\t\t}\n\t\t//notify the node - this is needed in case an enhencement layer replaces the buffer, in which case\n\t\t//the # ID Bits may change\n\t\tSFCommandBufferChanged(codec, node);\n\n\t\t/*\n\t\t 1 - memory mode, register command buffer for later parsing\n\t\t 2 - InputSensor only works on decompressed commands\n\t\t*/\n\t\tif (codec->dec_memory_mode || (node->sgprivate->tag==TAG_MPEG4_InputSensor)) {\n\t\t\tCommandBufferItem *cbi = (CommandBufferItem *)gf_malloc(sizeof(CommandBufferItem));\n\t\t\tcbi->node = node;\n\t\t\tgf_node_register(cbi->node, NULL);\n\t\t\tcbi->cb = sfcb;\n\t\t\tgf_list_add(codec->command_buffers, cbi);\n\t\t}\n\t}\n\tbreak;\n\tcase GF_SG_VRML_SFNODE:\n\t\t//if not memory dec mode, unregister previous node\n\t\t//otherwise the field points to the memory command internal field\n\t\tif (!is_mem_com) {\n\t\t\tGF_Node *old_node = *((GF_Node **) field->far_ptr);\n\t\t\tif (old_node != NULL) {\n\t\t\t\tu32 i, count = gf_list_count(codec->command_buffers);\n\t\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\t\tCommandBufferItem *cbi = (CommandBufferItem*) gf_list_get(codec->command_buffers, i);\n\t\t\t\t\tif (cbi->node == old_node) {\n\t\t\t\t\t\tgf_list_rem(codec->command_buffers, i);\n\t\t\t\t\t\ti--;\n\t\t\t\t\t\tcount--;\n\t\t\t\t\t\tgf_node_unregister(cbi->node, NULL);\n\t\t\t\t\t\tgf_free(cbi);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_node_unregister(old_node, node);\n\t\t\t\t *((GF_Node **) field->far_ptr) = NULL;\n\t\t\t}\n\t\t}\n\t\t//for nodes the field ptr is a ptr to the field, which is a node ptr ;)\n\t\tnew_node = gf_bifs_dec_node(codec, bs, field->NDTtype);\n\t\tif (new_node) {\n\t\t\te = gf_node_register(new_node, is_mem_com ? NULL : node);\n\t\t\tif (e) return e;\n\t\t}\n\t\t//it may happen that new_node is NULL (this is valid for a proto declaration)\n\t\t*((GF_Node **) field->far_ptr) = new_node;\n\t\tbreak;\n\tcase GF_SG_VRML_SFSCRIPT:\n#ifdef GPAC_HAS_QJS\n\t\tcodec->LastError = node ? SFScript_Parse(codec, (SFScript*)field->far_ptr, bs, node) : GF_NON_COMPLIANT_BITSTREAM;\n#else\n\t\treturn GF_NOT_SUPPORTED;\n#endif\n\t\tbreak;\n\tcase GF_SG_VRML_SFATTRREF:\n\t{\n\t\tSFAttrRef *ar = (SFAttrRef *)field->far_ptr;\n\t\tu32 nodeID = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits);\n\t\tar->node = gf_sg_find_node(codec->current_graph, nodeID);\n\t\tif (!ar->node) {\n\n\t\t} else {\n\t\t\tu32 nbBitsDEF = gf_get_bit_size(gf_node_get_num_fields_in_mode(ar->node, GF_SG_FIELD_CODING_DEF) - 1);\n\t\t\tu32 field_ref = gf_bs_read_int(bs, nbBitsDEF);\n\t\t\tcodec->LastError = gf_bifs_get_field_index(ar->node, field_ref, GF_SG_FIELD_CODING_DEF, &ar->fieldIndex);\n\t\t}\n\t}\n\tbreak;\n\tdefault:\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\treturn codec->LastError;\n}\n\nGF_Err BD_DecMFFieldList(GF_BifsDecoder * codec, GF_BitStream *bs, GF_Node *node, GF_FieldInfo *field, Bool is_mem_com)\n{\n\tGF_Node *new_node;\n\tGF_Err e;\n\tu8 endFlag, qp_local, qp_on, initial_qp;\n\tGF_ChildNodeItem *last = NULL;\n\tu32 nbF;\n\n\tGF_FieldInfo sffield;\n\n\tmemset(&sffield, 0, sizeof(GF_FieldInfo));\n\tsffield.fieldIndex = field->fieldIndex;\n\tsffield.fieldType = gf_sg_vrml_get_sf_type(field->fieldType);\n\tsffield.NDTtype = field->NDTtype;\n\tsffield.name = field->name;\n\n\tnbF = 0;\n\tqp_on = qp_local = 0;\n\tinitial_qp = codec->ActiveQP ? 1 : 0;\n\n\tendFlag = gf_bs_read_int(bs, 1);\n\twhile (!endFlag  && (codec->LastError>=0)) {\n\t\tif (field->fieldType != GF_SG_VRML_MFNODE) {\n\t\t\te = gf_sg_vrml_mf_append(field->far_ptr, field->fieldType, & sffield.far_ptr);\n\t\t\tif (e) return e;\n\t\t\te = gf_bifs_dec_sf_field(codec, bs, node, &sffield, GF_FALSE);\n\t\t\tif (e) return e;\n\t\t} else {\n\t\t\tnew_node = gf_bifs_dec_node(codec, bs, field->NDTtype);\n\t\t\t//append\n\t\t\tif (new_node) {\n\t\t\t\te = gf_node_register(new_node, is_mem_com ? NULL : node);\n\t\t\t\tif (e) return e;\n\n\t\t\t\t//regular coding\n\t\t\t\tif (node) {\n\t\t\t\t\t//special case for QP, register as the current QP\n\t\t\t\t\tif (gf_node_get_tag(new_node) == TAG_MPEG4_QuantizationParameter) {\n\t\t\t\t\t\tqp_local = ((M_QuantizationParameter *)new_node)->isLocal;\n\t\t\t\t\t\t//we have a QP in the same scope, remove previous\n\t\t\t\t\t\tif (qp_on) gf_bifs_dec_qp_remove(codec, GF_FALSE);\n\t\t\t\t\t\te = gf_bifs_dec_qp_set(codec, new_node);\n\t\t\t\t\t\tif (e) return e;\n\t\t\t\t\t\tqp_on = 1;\n\t\t\t\t\t\tif (qp_local) qp_local = 2;\n\t\t\t\t\t\tif (codec->force_keep_qp) {\n\t\t\t\t\t\t\te = gf_node_list_add_child_last(field->far_ptr, new_node, &last);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgf_node_register(new_node, NULL);\n\t\t\t\t\t\t\tgf_node_unregister(new_node, node);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else\n\t\t\t\t\t\t//this is generic MFNode container\n\t\t\t\t\t\te = gf_node_list_add_child_last(field->far_ptr, new_node, &last);\n\n\t\t\t\t}\n\t\t\t\t//proto coding: directly add the child\n\t\t\t\telse if (codec->pCurrentProto) {\n\t\t\t\t\t//TO DO: what happens if this is a QP node on the interface ?\n\t\t\t\t\te = gf_node_list_add_child_last( (GF_ChildNodeItem **)field->far_ptr, new_node, &last);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn codec->LastError;\n\t\t\t}\n\t\t}\n\t\tif (e) return e;\n\n\t\tendFlag = gf_bs_read_int(bs, 1);\n\n\t\t//according to the spec, the QP applies to the current node itself,\n\t\t//not just children. If IsLocal is TRUE remove the node\n\t\tif (qp_on && qp_local) {\n\t\t\tif (qp_local == 2) {\n\t\t\t\tqp_local = 1;\n\t\t\t} else {\n\t\t\t\t//ask to get rid of QP and reactivate if we had a QP when entering\n\t\t\t\tgf_bifs_dec_qp_remove(codec, initial_qp);\n\t\t\t\tqp_local = 0;\n\t\t\t\tqp_on = 0;\n\t\t\t}\n\t\t}\n\t\tnbF += 1;\n\t}\n\t/*finally delete the QP if any (local or not) as we get out of this node\n\tand reactivate previous one*/\n\tif (qp_on) gf_bifs_dec_qp_remove(codec, initial_qp);\n\t/*this is for QP 14*/\n\tgf_bifs_dec_qp14_set_length(codec, nbF);\n\treturn GF_OK;\n}\n\nGF_Err BD_DecMFFieldVec(GF_BifsDecoder * codec, GF_BitStream *bs, GF_Node *node, GF_FieldInfo *field, Bool is_mem_com)\n{\n\tGF_Err e;\n\tu32 NbBits, nbFields;\n\tu32 i;\n\tGF_ChildNodeItem *last;\n\tu8 qp_local, qp_on, initial_qp;\n\tGF_FieldInfo sffield;\n\n\tmemset(&sffield, 0, sizeof(GF_FieldInfo));\n\tsffield.fieldIndex = field->fieldIndex;\n\tsffield.fieldType = gf_sg_vrml_get_sf_type(field->fieldType);\n\tsffield.NDTtype = field->NDTtype;\n\tsffield.name = field->name;\n\n\tinitial_qp = qp_local = qp_on = 0;\n\n\t//vector description - alloc the MF size before\n\tNbBits = gf_bs_read_int(bs, 5);\n\tnbFields = gf_bs_read_int(bs, NbBits);\n\n\tif (codec->ActiveQP) {\n\t\tinitial_qp = 1;\n\t\t/*this is for QP 14*/\n\t\tgf_bifs_dec_qp14_set_length(codec, nbFields);\n\t}\n\n\tif (field->fieldType != GF_SG_VRML_MFNODE) {\n\t\te = gf_sg_vrml_mf_alloc(field->far_ptr, field->fieldType, nbFields);\n\t\tif (e) return e;\n\n\t\tfor (i=0; i<nbFields; i++) {\n\t\t\te = gf_sg_vrml_mf_get_item(field->far_ptr, field->fieldType, & sffield.far_ptr, i);\n\t\t\tif (e) return e;\n\t\t\te = gf_bifs_dec_sf_field(codec, bs, node, &sffield, GF_FALSE);\n\t\t\tif (e) return e;\n\t\t}\n\t} else {\n\t\tlast = NULL;\n\t\tfor (i=0; i<nbFields; i++) {\n\t\t\tGF_Node *new_node = gf_bifs_dec_node(codec, bs, field->NDTtype);\n\t\t\tif (new_node) {\n\t\t\t\te = gf_node_register(new_node, is_mem_com ? NULL : node);\n\t\t\t\tif (e) return e;\n\n\t\t\t\tif (node) {\n\t\t\t\t\t/*special case for QP, register as the current QP*/\n\t\t\t\t\tif (gf_node_get_tag(new_node) == TAG_MPEG4_QuantizationParameter) {\n\t\t\t\t\t\tqp_local = ((M_QuantizationParameter *)new_node)->isLocal;\n\t\t\t\t\t\t/*we have a QP in the same scope, remove previous\n\t\t\t\t\t\tNB: we assume this is the right behavior, the spec doesn't say\n\t\t\t\t\t\twhether QP is cumulative or not*/\n\t\t\t\t\t\tif (qp_on) gf_bifs_dec_qp_remove(codec, GF_FALSE);\n\n\t\t\t\t\t\te = gf_bifs_dec_qp_set(codec, new_node);\n\t\t\t\t\t\tif (e) return e;\n\t\t\t\t\t\tqp_on = 1;\n\t\t\t\t\t\tif (qp_local) qp_local = 2;\n\t\t\t\t\t\tif (codec->force_keep_qp) {\n\t\t\t\t\t\t\te = gf_node_list_add_child_last(field->far_ptr, new_node, &last);\n\t\t\t\t\t\t\tif (e) return e;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgf_node_register(new_node, NULL);\n\t\t\t\t\t\t\tgf_node_unregister(new_node, node);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\te = gf_node_list_add_child_last(field->far_ptr, new_node, &last);\n\t\t\t\t\t\tif (e) return e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*proto coding*/\n\t\t\t\telse if (codec->pCurrentProto) {\n\t\t\t\t\t/*TO DO: what happens if this is a QP node on the interface ?*/\n\t\t\t\t\te = gf_node_list_add_child_last( (GF_ChildNodeItem **)field->far_ptr, new_node, &last);\n\t\t\t\t\tif (e) return e;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn codec->LastError ? codec->LastError : GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t}\n\t\t}\n\t\t/*according to the spec, the QP applies to the current node itself, not just children.\n\t\tIf IsLocal is TRUE remove the node*/\n\t\tif (qp_on && qp_local) {\n\t\t\tif (qp_local == 2) {\n//\t\t\t\tqp_local = 1;\n\t\t\t} else {\n\t\t\t\t//ask to get rid of QP and reactivate if we had a QP when entering the node\n\t\t\t\tgf_bifs_dec_qp_remove(codec, initial_qp);\n//\t\t\t\tqp_local = 0;\n\t\t\t}\n\t\t}\n\t}\n\t/*finally delete the QP if any (local or not) as we get out of this node*/\n\tif (qp_on) gf_bifs_dec_qp_remove(codec, GF_TRUE);\n\treturn GF_OK;\n}\n\n\nvoid gf_bifs_check_field_change(GF_Node *node, GF_FieldInfo *field)\n{\n\tif (field->fieldType==GF_SG_VRML_MFNODE) node->sgprivate->flags |= GF_SG_CHILD_DIRTY;\n\t/*signal node modif*/\n\tgf_node_changed(node, field);\n\t/*Notify eventOut in all cases to handle protos*/\n\tgf_node_event_out(node, field->fieldIndex);\n\t/*and propagate eventIn if any*/\n\tif (field->on_event_in) {\n\t\tfield->on_event_in(node, NULL);\n\t} else if ((gf_node_get_tag(node) == TAG_MPEG4_Script) && (field->eventType==GF_SG_EVENT_IN)) {\n\t\tgf_sg_script_event_in(node, field);\n\t}\n\n}\n\nGF_Err gf_bifs_dec_field(GF_BifsDecoder * codec, GF_BitStream *bs, GF_Node *node, GF_FieldInfo *field, Bool is_mem_com)\n{\n\tGF_Err e;\n\tu8 flag;\n\n//\tif (codec->LastError) return codec->LastError;\n\n\tassert(node);\n//\tif (field->fieldType == GF_SG_VRML_UNKNOWN) return GF_NON_COMPLIANT_BITSTREAM;\n\n\tif (gf_sg_vrml_is_sf_field(field->fieldType)) {\n\t\te = gf_bifs_dec_sf_field(codec, bs, node, field, is_mem_com);\n\t\tif (e) return e;\n\t} else {\n\t\t/*clean up the eventIn field if not done*/\n\t\tif (field->eventType == GF_SG_EVENT_IN) {\n\t\t\tif (field->fieldType == GF_SG_VRML_MFNODE) {\n\t\t\t\tgf_node_unregister_children(node, * (GF_ChildNodeItem **)field->far_ptr);\n\t\t\t\t* (GF_ChildNodeItem **)field->far_ptr = NULL;\n\t\t\t} else {\n\t\t\t\t//remove all items of the MFField\n\t\t\t\te = gf_sg_vrml_mf_reset(field->far_ptr, field->fieldType);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t}\n\n\t\t/*predictiveMFField*/\n\t\tif (codec->info->config.UsePredictiveMFField) {\n\t\t\tflag = gf_bs_read_int(bs, 1);\n\t\t\tif (flag) {\n#ifdef GPAC_ENABLE_BIFS_PMF\n\t\t\t\treturn gf_bifs_dec_pred_mf_field(codec, bs, node, field);\n#else\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[BIFS] Stream uses Predictive Field Coding, disabled in this build!\\n\"));\n\t\t\t\treturn GF_NOT_SUPPORTED;\n#endif\n\t\t\t}\n\t\t}\n\n\t\t/*reserved*/\n\t\tflag = gf_bs_read_int(bs, 1);\n\t\tif (!flag) {\n\t\t\t/*destroy the field content...*/\n\t\t\tif (field->fieldType != GF_SG_VRML_MFNODE) {\n\t\t\t\te = gf_sg_vrml_mf_reset(field->far_ptr, field->fieldType);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t\t/*List description - alloc is dynamic*/\n\t\t\tflag = gf_bs_read_int(bs, 1);\n\t\t\tif (flag) {\n\t\t\t\te = BD_DecMFFieldList(codec, bs, node, field, is_mem_com);\n\t\t\t} else {\n\t\t\t\te = BD_DecMFFieldVec(codec, bs, node, field, is_mem_com);\n\t\t\t}\n\t\t\tif (e) return codec->LastError = e;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err BD_SetProtoISed(GF_BifsDecoder * codec, u32 protofield, GF_Node *n, u32 nodefield)\n{\n\t/*take care of conditional execution in proto*/\n\tif (codec->current_graph->pOwningProto) {\n\t\treturn gf_sg_proto_instance_set_ised((GF_Node *) codec->current_graph->pOwningProto, protofield, n, nodefield);\n\t}\n\t/*regular ISed fields*/\n\telse {\n\t\treturn gf_sg_proto_field_set_ised(codec->pCurrentProto, protofield, n, nodefield);\n\t}\n}\n\nGF_Err gf_bifs_dec_node_list(GF_BifsDecoder * codec, GF_BitStream *bs, GF_Node *node, Bool is_proto)\n{\n\tu8 flag;\n\tGF_Err e;\n\tu32 numBitsALL, numBitsDEF, field_all, field_ref, numProtoBits;\n\tGF_FieldInfo field;\n\n\tnumProtoBits = numBitsALL = 0;\n\tif (codec->pCurrentProto) {\n\t\tnumProtoBits = gf_get_bit_size(gf_sg_proto_get_field_count(codec->pCurrentProto) - 1);\n\t\tnumBitsALL = gf_get_bit_size(gf_node_get_num_fields_in_mode(node, GF_SG_FIELD_CODING_ALL)-1);\n\t}\n\tnumBitsDEF = gf_get_bit_size(gf_node_get_num_fields_in_mode(node, GF_SG_FIELD_CODING_DEF)-1);\n\n\tflag = gf_bs_read_int(bs, 1);\n\twhile (!flag && (codec->LastError>=0)) {\n\t\tif (codec->pCurrentProto) {\n\t\t\t//IS'ed flag\n\t\t\tflag = gf_bs_read_int(bs, 1);\n\t\t\tif (flag) {\n\t\t\t\t//get field index in ALL mode for node\n\t\t\t\tfield_ref = gf_bs_read_int(bs, numBitsALL);\n\t\t\t\t//get field index in ALL mode for proto\n\t\t\t\tfield_all = gf_bs_read_int(bs, numProtoBits);\n\t\t\t\te = gf_node_get_field(node, field_ref, &field);\n\t\t\t\tif (e) return e;\n\t\t\t\te = BD_SetProtoISed(codec, field_all, node, field_ref);\n\t\t\t\tif (e) return e;\n\t\t\t\tflag = gf_bs_read_int(bs, 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t//fields are coded in DEF mode\n\t\tfield_ref = gf_bs_read_int(bs, numBitsDEF);\n\t\te = gf_bifs_get_field_index(node, field_ref, GF_SG_FIELD_CODING_DEF, &field_all);\n\t\tif (e) return e;\n\t\te = gf_node_get_field(node, field_all, &field);\n\t\tif (e) return e;\n\t\te = gf_bifs_dec_field(codec, bs, node, &field, GF_FALSE);\n\t\tif (e) return e;\n\t\tflag = gf_bs_read_int(bs, 1);\n\n\t\tif (is_proto) gf_sg_proto_mark_field_loaded(node, &field);\n\t}\n\treturn codec->LastError;\n}\n\nGF_Err gf_bifs_dec_node_mask(GF_BifsDecoder * codec, GF_BitStream *bs, GF_Node *node, Bool is_proto)\n{\n\tu32 i, numFields, numProtoFields, index, flag, nbBits;\n\tGF_Err e;\n\tGF_FieldInfo field;\n\n\t//proto coding\n\tif (codec->pCurrentProto) {\n\t\tnumFields = gf_node_get_num_fields_in_mode(node, GF_SG_FIELD_CODING_ALL);\n\t\tnumProtoFields = gf_sg_proto_get_field_count(codec->pCurrentProto);\n\t\tnbBits = gf_get_bit_size(numProtoFields-1);\n\n\t\tfor (i=0; i<numFields; i++) {\n\t\t\tflag = gf_bs_read_int(bs, 1);\n\t\t\tif (!flag) continue;\n\t\t\tflag = gf_bs_read_int(bs, 1);\n\t\t\t//IS'ed field, create route for binding to Proto declaration\n\t\t\tif (flag) {\n\t\t\t\t//reference index of our IS'ed proto field\n\t\t\t\tflag = gf_bs_read_int(bs, nbBits);\n\t\t\t\te = gf_node_get_field(node, i, &field);\n\t\t\t\tif (e) return e;\n\t\t\t\te = BD_SetProtoISed(codec, flag, node, i);\n\t\t\t}\n\t\t\t//regular field, parse it (nb: no contextual coding for protos in maskNode,\n\t\t\t//all node fields are coded\n\t\t\telse {\n\t\t\t\te = gf_node_get_field(node, i, &field);\n\t\t\t\tif (e) return e;\n\t\t\t\te = gf_bifs_dec_field(codec, bs, node, &field, GF_FALSE);\n\t\t\t}\n\t\t\tif (e) return e;\n\t\t}\n\t}\n\t//regular coding\n\telse {\n\t\tnumFields = gf_node_get_num_fields_in_mode(node, GF_SG_FIELD_CODING_DEF);\n\t\tfor (i=0; i<numFields; i++) {\n\t\t\tflag = gf_bs_read_int(bs, 1);\n\t\t\tif (!flag) continue;\n\t\t\tgf_bifs_get_field_index(node, i, GF_SG_FIELD_CODING_DEF, &index);\n\t\t\te = gf_node_get_field(node, index, &field);\n\t\t\tif (e) return e;\n\t\t\te = gf_bifs_dec_field(codec, bs, node, &field, GF_FALSE);\n\t\t\tif (e) return e;\n\n\t\t\tif (is_proto) gf_sg_proto_mark_field_loaded(node, &field);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\nstatic void UpdateTimeNode(GF_BifsDecoder * codec, GF_Node *node)\n{\n\tswitch (gf_node_get_tag(node)) {\n\tcase TAG_MPEG4_AnimationStream:\n\t\tBD_OffsetSFTime(codec, & ((M_AnimationStream*)node)->startTime);\n\t\tBD_OffsetSFTime(codec, & ((M_AnimationStream*)node)->stopTime);\n\t\tbreak;\n\tcase TAG_MPEG4_AudioBuffer:\n\t\tBD_OffsetSFTime(codec, & ((M_AudioBuffer*)node)->startTime);\n\t\tBD_OffsetSFTime(codec, & ((M_AudioBuffer*)node)->stopTime);\n\t\tbreak;\n\tcase TAG_MPEG4_AudioClip:\n\t\tBD_OffsetSFTime(codec, & ((M_AudioClip*)node)->startTime);\n\t\tBD_OffsetSFTime(codec, & ((M_AudioClip*)node)->stopTime);\n\t\tbreak;\n\tcase TAG_MPEG4_AudioSource:\n\t\tBD_OffsetSFTime(codec, & ((M_AudioSource*)node)->startTime);\n\t\tBD_OffsetSFTime(codec, & ((M_AudioSource*)node)->stopTime);\n\t\tbreak;\n\tcase TAG_MPEG4_MovieTexture:\n\t\tBD_OffsetSFTime(codec, & ((M_MovieTexture*)node)->startTime);\n\t\tBD_OffsetSFTime(codec, & ((M_MovieTexture*)node)->stopTime);\n\t\tbreak;\n\tcase TAG_MPEG4_TimeSensor:\n\t\tBD_OffsetSFTime(codec, & ((M_TimeSensor*)node)->startTime);\n\t\tBD_OffsetSFTime(codec, & ((M_TimeSensor*)node)->stopTime);\n\t\tbreak;\n\tcase TAG_ProtoNode:\n\t{\n\t\tu32 i, nbFields;\n\t\tGF_FieldInfo inf;\n\t\tnbFields = gf_node_get_num_fields_in_mode(node, GF_SG_FIELD_CODING_ALL);\n\t\tfor (i=0; i<nbFields; i++) {\n\t\t\tgf_node_get_field(node, i, &inf);\n\t\t\tif (inf.fieldType != GF_SG_VRML_SFTIME) continue;\n\t\t\tBD_CheckSFTimeOffset(codec, node, &inf);\n\t\t}\n\t}\n\tbreak;\n\t}\n}\n\nGF_Node *gf_bifs_dec_node(GF_BifsDecoder * codec, GF_BitStream *bs, u32 NDT_Tag)\n{\n\tu32 nodeID, NDTBits, node_type, node_tag, ProtoID, BVersion;\n\tBool skip_init, reset_qp14;\n\tGF_Node *new_node;\n\tGF_Err e;\n\tGF_Proto *proto;\n\tvoid SetupConditional(GF_BifsDecoder *codec, GF_Node *node);\n\n\t//to store the UseName\n\tchar name[1000];\n\n#if 0\n\t/*should only happen with inputSensor, in which case this is BAAAAD*/\n\tif (!codec->info) {\n\t\tcodec->LastError = GF_BAD_PARAM;\n\t\treturn NULL;\n\t}\n#endif\n\n\n\tBVersion = GF_BIFS_V1;\n\n\t/*this is a USE statement*/\n\tif (gf_bs_read_int(bs, 1)) {\n\t\tnodeID = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits);\n\t\t/*NULL node is encoded as USE with ID = all bits to 1*/\n\t\tif (nodeID == (u32) (1<<codec->info->config.NodeIDBits))\n\t\t\treturn NULL;\n\t\t//find node\n\t\tnew_node = gf_sg_find_node(codec->current_graph, nodeID);\n\n\t\t//check node is allowed for the given NDT\n\t\tif (new_node && !gf_node_in_table(new_node, NDT_Tag)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[BIFS] Node %s not allowed as field/child of NDT type %d\\n\", gf_node_get_class_name(new_node), NDT_Tag));\n\t\t\tcodec->LastError = GF_SG_UNKNOWN_NODE;\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (!new_node) {\n\t\t\tcodec->LastError = GF_SG_UNKNOWN_NODE;\n\t\t} else {\n\t\t\t/*restore QP14 length*/\n\t\t\tswitch (gf_node_get_tag(new_node)) {\n\t\t\tcase TAG_MPEG4_Coordinate:\n\t\t\t{\n\t\t\t\tu32 nbCoord = ((M_Coordinate *)new_node)->point.count;\n\t\t\t\tgf_bifs_dec_qp14_enter(codec, GF_TRUE);\n\t\t\t\tgf_bifs_dec_qp14_set_length(codec, nbCoord);\n\t\t\t\tgf_bifs_dec_qp14_enter(codec, GF_FALSE);\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase TAG_MPEG4_Coordinate2D:\n\t\t\t{\n\t\t\t\tu32 nbCoord = ((M_Coordinate2D *)new_node)->point.count;\n\t\t\t\tgf_bifs_dec_qp14_enter(codec, GF_TRUE);\n\t\t\t\tgf_bifs_dec_qp14_set_length(codec, nbCoord);\n\t\t\t\tgf_bifs_dec_qp14_enter(codec, GF_FALSE);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn new_node;\n\t}\n\n\t//this is a new node\n\tnodeID = 0;\n\tname[0] = 0;\n\tnode_tag = 0;\n\tproto = NULL;\n\n\t//browse all node groups\n\twhile (1) {\n\t\tNDTBits = gf_bifs_get_ndt_bits(NDT_Tag, BVersion);\n\t\t/*this happens in replacescene where no top-level node is present (externProto)*/\n\t\tif ((BVersion==1) && (NDTBits > 8 * gf_bs_available(bs)) ) {\n\t\t\tcodec->LastError = GF_OK;\n\t\t\treturn NULL;\n\t\t}\n\n\t\tnode_type = gf_bs_read_int(bs, NDTBits);\n\t\tif (node_type) break;\n\n\t\t//increment BIFS version\n\t\tBVersion += 1;\n\t\t//not supported\n\t\tif (BVersion > GF_BIFS_NUM_VERSION) {\n\t\t\tcodec->LastError = GF_BIFS_UNKNOWN_VERSION;\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tif (BVersion==2 && node_type==1) {\n\t\tProtoID = gf_bs_read_int(bs, codec->info->config.ProtoIDBits);\n\t\t/*look in current graph for the proto - this may be a proto graph*/\n\t\tproto = gf_sg_find_proto(codec->current_graph, ProtoID, NULL);\n\t\t/*this was in proto so look in main scene*/\n\t\tif (!proto && codec->current_graph != codec->scenegraph)\n\t\t\tproto = gf_sg_find_proto(codec->scenegraph, ProtoID, NULL);\n\n\t\tif (!proto) {\n\t\t\tcodec->LastError = GF_SG_UNKNOWN_NODE;\n\t\t\treturn NULL;\n\t\t}\n\t} else {\n\t\tnode_tag = gf_bifs_ndt_get_node_type(NDT_Tag, node_type, BVersion);\n\t}\n\n\t/*special handling of 3D mesh*/\n\tif ((node_tag == TAG_MPEG4_IndexedFaceSet) && codec->info->config.Use3DMeshCoding) {\n\t\tif (gf_bs_read_int(bs, 1)) {\n\t\t\t/*nodeID = 1 + */gf_bs_read_int(bs, codec->info->config.NodeIDBits);\n\t\t\tif (codec->UseName) gf_bifs_dec_name(bs, name, 1000);\n\t\t}\n\t\t/*parse the 3DMesh node*/\n\t\treturn NULL;\n\t}\n\t/*unknown node*/\n\tif (!node_tag && !proto) {\n\t\tcodec->LastError = GF_SG_UNKNOWN_NODE;\n\t\treturn NULL;\n\t}\n\n\n\t/*DEF'd flag*/\n\tif (gf_bs_read_int(bs, 1)) {\n\t\tif (!codec->info->config.NodeIDBits) {\n\t\t\tcodec->LastError = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\treturn NULL;\n\t\t}\n\t\tnodeID = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits);\n\t\tif (codec->UseName) gf_bifs_dec_name(bs, name, 1000);\n\t}\n\n\tnew_node = NULL;\n\tskip_init = GF_FALSE;\n\n\t/*don't check node IDs duplicate since VRML may use them...*/\n#if 0\n\t/*if a node with same DEF is already in the scene, use it\n\twe don't do that in memory mode because commands may force replacement\n\tof a node with a new node with same ID, and we want to be able to dump it (otherwise we would\n\tdump a USE)*/\n\tif (nodeID && !codec->dec_memory_mode) {\n\t\tnew_node = gf_sg_find_node(codec->current_graph, nodeID);\n\t\tif (new_node) {\n\t\t\tif (proto) {\n\t\t\t\tif ((gf_node_get_tag(new_node) != TAG_ProtoNode) || (gf_node_get_proto(new_node) != proto)) {\n\t\t\t\t\tcodec->LastError = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tskip_init = 1;\n\t\t\t} else {\n\t\t\t\tif (gf_node_get_tag(new_node) != node_tag) {\n\t\t\t\t\tcodec->LastError = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tskip_init = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (!new_node)\n#endif\n\n\t{\n\t\tif (proto) {\n\t\t\t/*create proto interface*/\n\t\t\tnew_node = gf_sg_proto_create_instance(codec->current_graph, proto);\n            //don't init protos unless externProto (in which case we want init for hardcoded protos)\n            if (! proto->ExternProto.count) skip_init = GF_TRUE;\n\t\t} else {\n\t\t\tnew_node = gf_node_new(codec->current_graph, node_tag);\n\t\t}\n\t}\n\tif (!new_node) {\n\t\tcodec->LastError = GF_NOT_SUPPORTED;\n\t\treturn NULL;\n\t}\n\n\t/*update default time fields except in proto parsing*/\n\tif (!codec->pCurrentProto) UpdateTimeNode(codec, new_node);\n\t/*nodes are only init outside protos, nodes internal to protos are never intialized */\n\telse skip_init = GF_TRUE;\n\n\t/*if coords were not stored for QP14 before coding this node, reset QP14 it when leaving*/\n\treset_qp14 = !codec->coord_stored;\n\n\t/*QP 14 is a special quant mode for IndexFace/Line(2D)Set to quantize the\n\tcoordonate(2D) child, based on the first field parsed\n\twe must check the type of the node and notfy the QP*/\n\tswitch (node_tag) {\n\tcase TAG_MPEG4_Coordinate:\n\tcase TAG_MPEG4_Coordinate2D:\n\t\tgf_bifs_dec_qp14_enter(codec, GF_TRUE);\n\t}\n\n\tif (gf_bs_read_int(bs, 1)) {\n\t\te = gf_bifs_dec_node_mask(codec, bs, new_node, proto ? GF_TRUE : GF_FALSE);\n\t} else {\n\t\te = gf_bifs_dec_node_list(codec, bs, new_node, proto ? GF_TRUE : GF_FALSE);\n\t}\n\tif (codec->coord_stored && reset_qp14)\n\t\tgf_bifs_dec_qp14_reset(codec);\n\n\tif (e) {\n\t\tcodec->LastError = e;\n\t\t/*register*/\n\t\tgf_node_register(new_node, NULL);\n\t\t/*unregister (deletes)*/\n\t\tgf_node_unregister(new_node, NULL);\n\t\treturn NULL;\n\t}\n\n\t/*VRML: \"The transformation hierarchy shall be a directed acyclic graph; results are undefined if a node\n\tin the transformation hierarchy is its own ancestor\"\n\tthat's good, because the scene graph can't handle cyclic graphs (destroy will never be called).\n\tWe therefore only register the node once parsed*/\n\tif (nodeID) {\n\t\tif (strlen(name)) {\n\t\t\tgf_node_set_id(new_node, nodeID, name);\n\t\t} else {\n\t\t\tgf_node_set_id(new_node, nodeID, NULL);\n\t\t}\n\t}\n\n\tif (!skip_init)\n\t\tgf_node_init(new_node);\n\n\tswitch (node_tag) {\n\tcase TAG_MPEG4_Coordinate:\n\tcase TAG_MPEG4_Coordinate2D:\n\t\tgf_bifs_dec_qp14_enter(codec, GF_FALSE);\n\t\tbreak;\n\tcase TAG_MPEG4_Script:\n\t\t/*load script if in main graph (useless to load in proto declaration)*/\n\t\tif (codec->scenegraph == codec->current_graph) {\n\t\t\tgf_sg_script_load(new_node);\n\t\t}\n\t\tbreak;\n\t/*conditionals must be init*/\n\tcase TAG_MPEG4_Conditional:\n\t\tSetupConditional(codec, new_node);\n\t\tbreak;\n\t}\n\n\t/*proto is initialized upon the first traversal to have the same behavior as wth BT/XMT loading*/\n#if 0\n\t/*if new node is a proto and we're in the top scene, load proto code*/\n\tif (proto && (codec->scenegraph == codec->current_graph)) {\n\t\tcodec->LastError = gf_sg_proto_load_code(new_node);\n\t}\n#endif\n\n\treturn new_node;\n}\n\n#endif /*GPAC_DISABLE_BIFS*/\n"], "filenames": ["src/bifs/field_decode.c"], "buggy_code_start_loc": [207], "buggy_code_end_loc": [207], "fixing_code_start_loc": [208], "fixing_code_end_loc": [209], "type": "CWE-476", "message": "Null Pointer Dereference Caused Segmentation Fault in GitHub repository gpac/gpac prior to 2.1.0-DEV.", "other": {"cve": {"id": "CVE-2022-1172", "sourceIdentifier": "security@huntr.dev", "published": "2022-03-30T10:15:07.890", "lastModified": "2022-04-05T21:16:39.837", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Null Pointer Dereference Caused Segmentation Fault in GitHub repository gpac/gpac prior to 2.1.0-DEV."}, {"lang": "es", "value": "Una Desreferencia de Puntero Null caus\u00f3 un fallo de segmentaci\u00f3n en el repositorio de GitHub gpac/gpac versiones anteriores a 2.1.0-DEV"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.0, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.3, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:R/S:U/C:N/I:L/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 5.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.3, "impactScore": 4.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.0.0", "matchCriteriaId": "6FDA7EFB-AFD8-40D1-B517-04A825BC302A"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/55a183e6b8602369c04ea3836e05436a79fbc7f8", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/a26cb79c-9257-4fbf-98c5-a5a331efa264", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/55a183e6b8602369c04ea3836e05436a79fbc7f8"}}