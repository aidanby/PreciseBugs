{"buggy_code": ["/*****************************************************************\n|\n|    AP4 - MetaData \n|\n|    Copyright 2002-2008 Axiomatic Systems, LLC\n|\n|\n|    This file is part of Bento4/AP4 (MP4 Atom Processing Library).\n|\n|    Unless you have obtained Bento4 under a difference license,\n|    this version of Bento4 is Bento4|GPL.\n|    Bento4|GPL is free software; you can redistribute it and/or modify\n|    it under the terms of the GNU General Public License as published by\n|    the Free Software Foundation; either version 2, or (at your option)\n|    any later version.\n|\n|    Bento4|GPL is distributed in the hope that it will be useful,\n|    but WITHOUT ANY WARRANTY; without even the implied warranty of\n|    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n|    GNU General Public License for more details.\n|\n|    You should have received a copy of the GNU General Public License\n|    along with Bento4|GPL; see the file COPYING.  If not, write to the\n|    Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n|    02111-1307, USA.\n|\n****************************************************************/\n\n/*----------------------------------------------------------------------\n|   includes\n+---------------------------------------------------------------------*/\n#include \"Ap4File.h\"\n#include \"Ap4Movie.h\"\n#include \"Ap4MetaData.h\"\n#include \"Ap4ContainerAtom.h\"\n#include \"Ap4MoovAtom.h\"\n#include \"Ap4HdlrAtom.h\"\n#include \"Ap4DataBuffer.h\"\n#include \"Ap4Utils.h\"\n#include \"Ap4String.h\"\n\n/*----------------------------------------------------------------------\n|   dynamic cast support\n+---------------------------------------------------------------------*/\nAP4_DEFINE_DYNAMIC_CAST_ANCHOR(AP4_3GppLocalizedStringAtom)\nAP4_DEFINE_DYNAMIC_CAST_ANCHOR(AP4_DcfdAtom)\nAP4_DEFINE_DYNAMIC_CAST_ANCHOR(AP4_DcfStringAtom)\nAP4_DEFINE_DYNAMIC_CAST_ANCHOR(AP4_DataAtom)\nAP4_DEFINE_DYNAMIC_CAST_ANCHOR(AP4_MetaDataStringAtom)\n\n/*----------------------------------------------------------------------\n|   metadata keys\n+---------------------------------------------------------------------*/\nstatic const AP4_MetaData::KeyInfo AP4_MetaData_KeyInfos [] = {\n    {\"Name\",                \"Name\",                 AP4_ATOM_TYPE_cNAM, AP4_MetaData::Value::TYPE_STRING_UTF_8},\n    {\"Artist\",              \"Artist\",               AP4_ATOM_TYPE_cART, AP4_MetaData::Value::TYPE_STRING_UTF_8},\n    {\"AlbumArtist\",         \"Album Artist\",         AP4_ATOM_TYPE_aART, AP4_MetaData::Value::TYPE_STRING_UTF_8},\n    {\"Composer\",            \"Composer\",             AP4_ATOM_TYPE_cCOM, AP4_MetaData::Value::TYPE_STRING_UTF_8},\n    {\"Writer\",              \"Writer\",               AP4_ATOM_TYPE_cWRT, AP4_MetaData::Value::TYPE_STRING_UTF_8},\n    {\"Album\",               \"Album\",                AP4_ATOM_TYPE_cALB, AP4_MetaData::Value::TYPE_STRING_UTF_8},\n    {\"GenreCode\",           \"Genre\",                AP4_ATOM_TYPE_GNRE, AP4_MetaData::Value::TYPE_BINARY},\n    {\"GenreName\",           \"Genre\",                AP4_ATOM_TYPE_cGEN, AP4_MetaData::Value::TYPE_STRING_UTF_8},\n    {\"Grouping\",            \"Grouping\",             AP4_ATOM_TYPE_cGRP, AP4_MetaData::Value::TYPE_STRING_UTF_8},\n    {\"Date\",                \"Date\",                 AP4_ATOM_TYPE_cDAY, AP4_MetaData::Value::TYPE_STRING_UTF_8},\n    {\"Tool\",                \"Encoding Tool\",        AP4_ATOM_TYPE_cTOO, AP4_MetaData::Value::TYPE_STRING_UTF_8},\n    {\"Comment\",             \"Comment\",              AP4_ATOM_TYPE_cCMT, AP4_MetaData::Value::TYPE_STRING_UTF_8},\n    {\"Lyrics\",              \"Lyrics\",               AP4_ATOM_TYPE_cLYR, AP4_MetaData::Value::TYPE_STRING_UTF_8},\n    {\"Copyright\",           \"Copyright\",            AP4_ATOM_TYPE_CPRT, AP4_MetaData::Value::TYPE_STRING_UTF_8},\n    {\"Track\",               \"Track Number\",         AP4_ATOM_TYPE_TRKN, AP4_MetaData::Value::TYPE_BINARY},\n    {\"Disc\",                \"Disc Number\",          AP4_ATOM_TYPE_DISK, AP4_MetaData::Value::TYPE_BINARY},\n    {\"Cover\",               \"Cover Art\",            AP4_ATOM_TYPE_COVR, AP4_MetaData::Value::TYPE_BINARY},\n    {\"Description\",         \"Description\",          AP4_ATOM_TYPE_DESC, AP4_MetaData::Value::TYPE_STRING_UTF_8},\n    {\"Rating\",              \"Rating\",               AP4_ATOM_TYPE_RTNG, AP4_MetaData::Value::TYPE_INT_08_BE},\n    {\"Tempo\",               \"Tempo\",                AP4_ATOM_TYPE_TMPO, AP4_MetaData::Value::TYPE_INT_16_BE},\n    {\"Compilation\",         \"Compilation\",          AP4_ATOM_TYPE_CPIL, AP4_MetaData::Value::TYPE_INT_08_BE},\n    {\"IsGapless\",           \"Is Gapless\",           AP4_ATOM_TYPE_PGAP, AP4_MetaData::Value::TYPE_INT_08_BE},\n    {\"Title\",               \"Title\",                AP4_ATOM_TYPE_TITL, AP4_MetaData::Value::TYPE_STRING_UTF_8},\n    {\"Description\",         \"Description\",          AP4_ATOM_TYPE_DSCP, AP4_MetaData::Value::TYPE_STRING_UTF_8},\n    {\"StoreFrontID\",        \"Store Front ID\",       AP4_ATOM_TYPE_sfID, AP4_MetaData::Value::TYPE_INT_32_BE},\n    {\"FileKind\",            \"File Kind\",            AP4_ATOM_TYPE_STIK, AP4_MetaData::Value::TYPE_INT_08_BE},\n    {\"ShowName\",            \"Show Name\",            AP4_ATOM_TYPE_TVSH, AP4_MetaData::Value::TYPE_STRING_UTF_8},\n    {\"ShowSeason\",          \"Show Season Number\",   AP4_ATOM_TYPE_TVSN, AP4_MetaData::Value::TYPE_INT_32_BE},\n    {\"ShowEpisodeNumber\",   \"Show Episode Number\",  AP4_ATOM_TYPE_TVES, AP4_MetaData::Value::TYPE_INT_32_BE},\n    {\"ShowEpisodeName\",     \"Show Episode Name\",    AP4_ATOM_TYPE_TVEN, AP4_MetaData::Value::TYPE_STRING_UTF_8},\n    {\"TVNetworkName\",       \"TV Network Name\",      AP4_ATOM_TYPE_TVNN, AP4_MetaData::Value::TYPE_STRING_UTF_8},\n    {\"IsPodcast\",           \"Is a Podcast\",         AP4_ATOM_TYPE_PCST, AP4_MetaData::Value::TYPE_INT_08_BE},\n    {\"PodcastUrl\",          \"Podcast URL\",          AP4_ATOM_TYPE_PURL, AP4_MetaData::Value::TYPE_BINARY},\n    {\"PodcastGuid\",         \"Podcast GUID\",         AP4_ATOM_TYPE_EGID, AP4_MetaData::Value::TYPE_BINARY},\n    {\"PodcastCategory\",     \"Podcast Category\",     AP4_ATOM_TYPE_CATG, AP4_MetaData::Value::TYPE_STRING_UTF_8},\n    {\"Keywords\",            \"Keywords\",             AP4_ATOM_TYPE_KEYW, AP4_MetaData::Value::TYPE_STRING_UTF_8},\n    {\"PurchaseDate\",        \"Purchase Date\",        AP4_ATOM_TYPE_PURD, AP4_MetaData::Value::TYPE_STRING_UTF_8},\n    {\"IconUri\",             \"Icon URI\",             AP4_ATOM_TYPE_ICNU, AP4_MetaData::Value::TYPE_STRING_UTF_8},\n    {\"InfoUrl\",             \"Info URL\",             AP4_ATOM_TYPE_INFU, AP4_MetaData::Value::TYPE_STRING_UTF_8},\n    {\"CoverUri\",            \"Cover Art URI\",        AP4_ATOM_TYPE_CVRU, AP4_MetaData::Value::TYPE_STRING_UTF_8},\n    {\"LyricsUri\",           \"Lyrics URI\",           AP4_ATOM_TYPE_LRCU, AP4_MetaData::Value::TYPE_STRING_UTF_8},\n    {\"Duration\",            \"Duration\",             AP4_ATOM_TYPE_DCFD, AP4_MetaData::Value::TYPE_INT_32_BE},\n    {\"Performer\",           \"Performer\",            AP4_ATOM_TYPE_PERF, AP4_MetaData::Value::TYPE_STRING_UTF_8},\n    {\"Author\",              \"Author\",               AP4_ATOM_TYPE_AUTH, AP4_MetaData::Value::TYPE_STRING_UTF_8},\n};\nAP4_Array<AP4_MetaData::KeyInfo> AP4_MetaData::KeyInfos(\n    AP4_MetaData_KeyInfos, \n    sizeof(AP4_MetaData_KeyInfos)/sizeof(KeyInfo));\nAP4_Result\nAP4_MetaData::Initialized() { return AP4_MetaData::KeyInfos.ItemCount() != 0; }\nAP4_Result\nAP4_MetaData::Initialize() {\n    unsigned int item_count = sizeof(AP4_MetaData_KeyInfos)/sizeof(KeyInfo);\n    KeyInfos.SetItemCount(item_count);\n    for (unsigned int i=0; i<item_count; i++) {\n        KeyInfos[i] = AP4_MetaData_KeyInfos[i];\n    }\n    return AP4_SUCCESS;\n}\nAP4_Result\nAP4_MetaData::UnInitialize() {\n    return AP4_MetaData::KeyInfos.Clear();\n}\n\n/*----------------------------------------------------------------------\n|   genre IDs\n+---------------------------------------------------------------------*/\nstatic const char* const Ap4Id3Genres[] = \n{\n    \"Blues\",\n    \"Classic Rock\",\n    \"Country\",\n    \"Dance\",\n    \"Disco\",\n    \"Funk\",\n    \"Grunge\",\n    \"Hip-Hop\",\n    \"Jazz\",\n    \"Metal\",\n    \"New Age\",\n    \"Oldies\",\n    \"Other\",\n    \"Pop\",\n    \"R&B\",\n    \"Rap\",\n    \"Reggae\",\n    \"Rock\",\n    \"Techno\",\n    \"Industrial\",\n    \"Alternative\",\n    \"Ska\",\n    \"Death Metal\",\n    \"Pranks\",\n    \"Soundtrack\",\n    \"Euro-Techno\",\n    \"Ambient\",\n    \"Trip-Hop\",\n    \"Vocal\",\n    \"Jazz+Funk\",\n    \"Fusion\",\n    \"Trance\",\n    \"Classical\",\n    \"Instrumental\",\n    \"Acid\",\n    \"House\",\n    \"Game\",\n    \"Sound Clip\",\n    \"Gospel\",\n    \"Noise\",\n    \"AlternRock\",\n    \"Bass\",\n    \"Soul\",\n    \"Punk\",\n    \"Space\",\n    \"Meditative\",\n    \"Instrumental Pop\",\n    \"Instrumental Rock\",\n    \"Ethnic\",\n    \"Gothic\",\n    \"Darkwave\",\n    \"Techno-Industrial\",\n    \"Electronic\",\n    \"Pop-Folk\",\n    \"Eurodance\",\n    \"Dream\",\n    \"Southern Rock\",\n    \"Comedy\",\n    \"Cult\",\n    \"Gangsta\",\n    \"Top 40\",\n    \"Christian Rap\",\n    \"Pop/Funk\",\n    \"Jungle\",\n    \"Native American\",\n    \"Cabaret\",\n    \"New Wave\",\n    \"Psychadelic\",\n    \"Rave\",\n    \"Showtunes\",\n    \"Trailer\",\n    \"Lo-Fi\",\n    \"Tribal\",\n    \"Acid Punk\",\n    \"Acid Jazz\",\n    \"Polka\",\n    \"Retro\",\n    \"Musical\",\n    \"Rock & Roll\",\n    \"Hard Rock\",\n    \"Folk\",\n    \"Folk-Rock\",\n    \"National Folk\",\n    \"Swing\",\n    \"Fast Fusion\",\n    \"Bebob\",\n    \"Latin\",\n    \"Revival\",\n    \"Celtic\",\n    \"Bluegrass\",\n    \"Avantgarde\",\n    \"Gothic Rock\",\n    \"Progressive Rock\",\n    \"Psychedelic Rock\",\n    \"Symphonic Rock\",\n    \"Slow Rock\",\n    \"Big Band\",\n    \"Chorus\",\n    \"Easy Listening\",\n    \"Acoustic\",\n    \"Humour\",\n    \"Speech\",\n    \"Chanson\",\n    \"Opera\",\n    \"Chamber Music\",\n    \"Sonata\",\n    \"Symphony\",\n    \"Booty Bass\",\n    \"Primus\",\n    \"Porn Groove\",\n    \"Satire\",\n    \"Slow Jam\",\n    \"Club\",\n    \"Tango\",\n    \"Samba\",\n    \"Folklore\",\n    \"Ballad\",\n    \"Power Ballad\",\n    \"Rhythmic Soul\",\n    \"Freestyle\",\n    \"Duet\",\n    \"Punk Rock\",\n    \"Drum Solo\",\n    \"Acapella\",\n    \"Euro-House\",\n    \"Dance Hall\"\n};\n\nstatic const char*\nAp4StikNames[] = {\n    \"Movie\",            // 0\n    \"Normal\",           // 1\n    \"Audiobook\",        // 2\n    \"?\",                // 3\n    \"?\",                // 4\n    \"Whacked Bookmark\", // 5\n    \"Music Video\",      // 6\n    \"?\",                // 7\n    \"?\",                // 8\n    \"Short Film\",       // 9 \n    \"TV Show\",          // 10\n    \"Booklet\",          // 11\n    \"?\",                // 12\n    \"?\",                // 13\n    \"Ring Tone\"         // 14\n};\n\n\n/* sfID Store Front country\n    Australia   => 143460,\n    Austria     => 143445,\n    Belgium     => 143446,\n    Canada      => 143455,\n    Denmark     => 143458,\n    Finland     => 143447,\n    France      => 143442,\n    Germany     => 143443,\n    Greece      => 143448,\n    Ireland     => 143449,\n    Italy       => 143450,\n    Japan       => 143462,\n    Luxembourg  => 143451,\n    Netherlands => 143452,\n    Norway      => 143457,\n    Portugal    => 143453,\n    Spain       => 143454,\n    Sweden      => 143456,\n    Switzerland => 143459,\n    UK          => 143444,\n    USA         => 143441,\n*/\n\n/*----------------------------------------------------------------------\n|   constants\n+---------------------------------------------------------------------*/\nconst AP4_Size AP4_DATA_ATOM_MAX_SIZE = 0x40000000;\n\n/*----------------------------------------------------------------------\n|   3GPP localized string atoms\n+---------------------------------------------------------------------*/\nconst AP4_Atom::Type AP4_MetaDataAtomTypeHandler::_3gppLocalizedStringTypes[] = {\n    AP4_ATOM_TYPE_TITL,\n    AP4_ATOM_TYPE_DSCP,\n    AP4_ATOM_TYPE_CPRT,\n    AP4_ATOM_TYPE_PERF,\n    AP4_ATOM_TYPE_AUTH,\n    AP4_ATOM_TYPE_GNRE\n};\nconst AP4_MetaDataAtomTypeHandler::TypeList AP4_MetaDataAtomTypeHandler::_3gppLocalizedStringTypeList = {\n    _3gppLocalizedStringTypes,\n    sizeof(_3gppLocalizedStringTypes)/sizeof(_3gppLocalizedStringTypes[0])\n};\n\n/*----------------------------------------------------------------------\n|   other 3GPP atoms\n+---------------------------------------------------------------------*/\nconst AP4_Atom::Type AP4_MetaDataAtomTypeHandler::_3gppOtherTypes[] = {\n    AP4_ATOM_TYPE_RTNG,\n    AP4_ATOM_TYPE_CLSF,\n    AP4_ATOM_TYPE_KYWD,\n    AP4_ATOM_TYPE_LOCI,\n    AP4_ATOM_TYPE_ALBM,\n    AP4_ATOM_TYPE_YRRC,\n};\nconst AP4_MetaDataAtomTypeHandler::TypeList AP4_MetaDataAtomTypeHandler::_3gppOtherTypeList = {\n    _3gppOtherTypes,\n    sizeof(_3gppOtherTypes)/sizeof(_3gppOtherTypes[0])\n};\n\n/*----------------------------------------------------------------------\n|   DCF string atoms\n+---------------------------------------------------------------------*/\nconst AP4_Atom::Type AP4_MetaDataAtomTypeHandler::DcfStringTypes[] = {\n    AP4_ATOM_TYPE_ICNU,\n    AP4_ATOM_TYPE_INFU,\n    AP4_ATOM_TYPE_CVRU,\n    AP4_ATOM_TYPE_LRCU\n};\nconst AP4_MetaDataAtomTypeHandler::TypeList AP4_MetaDataAtomTypeHandler::DcfStringTypeList = {\n    DcfStringTypes,\n    sizeof(DcfStringTypes)/sizeof(DcfStringTypes[0])\n};\n\n/*----------------------------------------------------------------------\n|   atom type lists\n+---------------------------------------------------------------------*/\nconst AP4_Atom::Type AP4_MetaDataAtomTypeHandler::IlstTypes[] = \n{\n    AP4_ATOM_TYPE_dddd,\n    AP4_ATOM_TYPE_cNAM,\n    AP4_ATOM_TYPE_cART,\n    AP4_ATOM_TYPE_cCOM,\n    AP4_ATOM_TYPE_cWRT,\n    AP4_ATOM_TYPE_cALB,\n    AP4_ATOM_TYPE_cGEN,\n    AP4_ATOM_TYPE_cGRP,\n    AP4_ATOM_TYPE_cDAY,\n    AP4_ATOM_TYPE_cTOO,\n    AP4_ATOM_TYPE_cCMT,\n    AP4_ATOM_TYPE_CPRT,\n    AP4_ATOM_TYPE_TRKN,\n    AP4_ATOM_TYPE_DISK,\n    AP4_ATOM_TYPE_COVR,\n    AP4_ATOM_TYPE_DESC,\n    AP4_ATOM_TYPE_GNRE,\n    AP4_ATOM_TYPE_CPIL,\n    AP4_ATOM_TYPE_TMPO,\n    AP4_ATOM_TYPE_RTNG,\n    AP4_ATOM_TYPE_apID,\n    AP4_ATOM_TYPE_cnID,\n    AP4_ATOM_TYPE_cmID,\n    AP4_ATOM_TYPE_atID,\n    AP4_ATOM_TYPE_plID,\n    AP4_ATOM_TYPE_geID,\n    AP4_ATOM_TYPE_sfID,\n    AP4_ATOM_TYPE_akID,\n    AP4_ATOM_TYPE_aART,\n    AP4_ATOM_TYPE_TVNN,\n    AP4_ATOM_TYPE_TVSH,\n    AP4_ATOM_TYPE_TVEN,\n    AP4_ATOM_TYPE_TVSN,\n    AP4_ATOM_TYPE_TVES,\n    AP4_ATOM_TYPE_STIK,\n    AP4_ATOM_TYPE_PGAP,\n    AP4_ATOM_TYPE_PCST,\n    AP4_ATOM_TYPE_PURD,\n    AP4_ATOM_TYPE_PURL,\n    AP4_ATOM_TYPE_EGID,\n    AP4_ATOM_TYPE_SONM,\n    AP4_ATOM_TYPE_SOAL,\n    AP4_ATOM_TYPE_SOAR,\n    AP4_ATOM_TYPE_SOAA,\n    AP4_ATOM_TYPE_SOCO,\n    AP4_ATOM_TYPE_SOSN\n};\nconst AP4_MetaDataAtomTypeHandler::TypeList AP4_MetaDataAtomTypeHandler::IlstTypeList = {\n    IlstTypes,\n    sizeof(IlstTypes)/sizeof(IlstTypes[0])\n};\n\n/*----------------------------------------------------------------------\n|   AP4_MetaDataAtomTypeHandler::CreateAtom\n+---------------------------------------------------------------------*/\nAP4_Result \nAP4_MetaDataAtomTypeHandler::CreateAtom(AP4_Atom::Type  type,\n                                        AP4_UI32        size,\n                                        AP4_ByteStream& stream,\n                                        AP4_Atom::Type  context,\n                                        AP4_Atom*&      atom)\n{\n    atom = NULL;\n\n    if (context == AP4_ATOM_TYPE_ILST) {\n        if (IsTypeInList(type, IlstTypeList)) {\n            m_AtomFactory->PushContext(type);\n            atom = AP4_ContainerAtom::Create(type, size, false, false, stream, *m_AtomFactory);\n            m_AtomFactory->PopContext();\n        }\n    } else if (type == AP4_ATOM_TYPE_DATA) {\n        if (IsTypeInList(context, IlstTypeList)) {\n            atom = new AP4_DataAtom(size, stream);\n        }\n    } else if (context == AP4_ATOM_TYPE_dddd) {\n        if (type == AP4_ATOM_TYPE_MEAN || type == AP4_ATOM_TYPE_NAME) {\n            atom = new AP4_MetaDataStringAtom(type, size, stream);\n        }\n    } else if (context == AP4_ATOM_TYPE_UDTA) {\n        if (IsTypeInList(type, _3gppLocalizedStringTypeList)) {\n            atom = AP4_3GppLocalizedStringAtom::Create(type, size, stream);\n        } else if (IsTypeInList(type, DcfStringTypeList)) {\n            atom = AP4_DcfStringAtom::Create(type, size, stream);\n        } else if (type == AP4_ATOM_TYPE_DCFD) {\n            atom = AP4_DcfdAtom::Create(size, stream);\n        }\n    }\n\n    return atom?AP4_SUCCESS:AP4_FAILURE;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_MetaDataAtomTypeHandler::IsTypeInList\n+---------------------------------------------------------------------*/\nbool\nAP4_MetaDataAtomTypeHandler::IsTypeInList(AP4_Atom::Type type, const AP4_MetaDataAtomTypeHandler::TypeList& list)\n{\n    for (unsigned int i=0; i<list.m_Size; i++) {\n        if (type == list.m_Types[i]) return true;\n    }\n    return false;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_MetaData::AP4_MetaData\n+---------------------------------------------------------------------*/\nAP4_MetaData::AP4_MetaData(AP4_File* file)\n{\n    // get the file's movie\n    AP4_Movie* movie = file->GetMovie();\n\n    // handle the movie's metadata if there is a movie in the file\n    if (movie) {\n        AP4_MoovAtom* moov = movie->GetMoovAtom();\n        if (moov == NULL) return;\n        ParseMoov(moov);\n        AP4_Atom* udta = moov->GetChild(AP4_ATOM_TYPE_UDTA);\n        if (udta) {\n            AP4_ContainerAtom* udta_container = AP4_DYNAMIC_CAST(AP4_ContainerAtom, udta);\n            if (udta_container) {\n                ParseUdta(udta_container, \"3gpp\");\n            }\n        }\n    } else {\n        // if we don't have a movie, try to show metadata from a udta atom\n        AP4_List<AP4_Atom>& top_level_atoms = file->GetTopLevelAtoms();\n        \n        AP4_List<AP4_Atom>::Item* atom_item = top_level_atoms.FirstItem();\n        while (atom_item) {\n            AP4_ContainerAtom* container = AP4_DYNAMIC_CAST(AP4_ContainerAtom, atom_item->GetData());\n            if (container) {\n                // look for a udta in a DCF layout\n                AP4_Atom* udta = container->FindChild(\"odhe/udta\");\n                if (udta) {\n                    AP4_ContainerAtom* udta_container = AP4_DYNAMIC_CAST(AP4_ContainerAtom, udta);\n                    if (udta_container) {\n                        ParseUdta(udta_container, \"dcf\");\n                    }\n                }\n            }\n            atom_item = atom_item->GetNext();\n        }\n    } \n}\n\n/*----------------------------------------------------------------------\n|   AP4_MetaData::ParseMoov\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_MetaData::ParseMoov(AP4_MoovAtom* moov)\n{\n    // look for a 'meta' atom with 'hdlr' type 'mdir'\n    AP4_HdlrAtom* hdlr = AP4_DYNAMIC_CAST(AP4_HdlrAtom, moov->FindChild(\"udta/meta/hdlr\"));\n    if (hdlr == NULL || hdlr->GetHandlerType() != AP4_HANDLER_TYPE_MDIR) return AP4_ERROR_NO_SUCH_ITEM;\n\n    // get the list of entries\n    AP4_ContainerAtom* ilst = AP4_DYNAMIC_CAST(AP4_ContainerAtom, moov->FindChild(\"udta/meta/ilst\"));\n    if (ilst == NULL) return AP4_ERROR_NO_SUCH_ITEM;\n    \n    AP4_List<AP4_Atom>::Item* ilst_item = ilst->GetChildren().FirstItem();\n    while (ilst_item) {\n        AP4_ContainerAtom* entry_atom = AP4_DYNAMIC_CAST(AP4_ContainerAtom, ilst_item->GetData()); \n        if (entry_atom) {\n            AddIlstEntries(entry_atom, \"meta\");\n        }\n        ilst_item = ilst_item->GetNext();\n    }\n    \n    return AP4_SUCCESS;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_MetaData::ParseUdta\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_MetaData::ParseUdta(AP4_ContainerAtom* udta, const char* namespc)\n{\n    // check that the atom is indeed a 'udta' atom\n    if (udta->GetType() != AP4_ATOM_TYPE_UDTA) {\n        return AP4_ERROR_INVALID_PARAMETERS;\n    }\n    \n    AP4_List<AP4_Atom>::Item* udta_item = udta->GetChildren().FirstItem();\n    for (; udta_item; udta_item = udta_item->GetNext()) {\n        AP4_3GppLocalizedStringAtom* _3gpp_atom = AP4_DYNAMIC_CAST(AP4_3GppLocalizedStringAtom, udta_item->GetData()); \n        if (_3gpp_atom) {\n            Add3GppEntry(_3gpp_atom, namespc);\n            continue;\n        } \n        \n        AP4_DcfStringAtom* dcfs_atom = AP4_DYNAMIC_CAST(AP4_DcfStringAtom, udta_item->GetData());\n        if (dcfs_atom) {\n            AddDcfStringEntry(dcfs_atom, namespc);\n            continue;\n        } \n\n        AP4_DcfdAtom* dcfd_atom = AP4_DYNAMIC_CAST(AP4_DcfdAtom, udta_item->GetData());\n        if (dcfd_atom) {\n            AddDcfdEntry(dcfd_atom, namespc);\n        }\n    }\n    \n    return AP4_SUCCESS;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_MetaData::~AP4_MetaData\n+---------------------------------------------------------------------*/\nAP4_MetaData::~AP4_MetaData()\n{\n    m_Entries.DeleteReferences();\n}\n\n/*----------------------------------------------------------------------\n|   AP4_MetaData::ResolveKeyName\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_MetaData::ResolveKeyName(AP4_Atom::Type atom_type, AP4_String& value)\n{\n    const char* key_name = NULL;\n    char        four_cc[5];\n\n    // look for a match in the key infos\n    for (unsigned int i=0; \n         i<sizeof(AP4_MetaData_KeyInfos)/sizeof(AP4_MetaData_KeyInfos[0]); \n         i++) {\n        if (AP4_MetaData_KeyInfos[i].four_cc == atom_type) {\n            key_name = AP4_MetaData_KeyInfos[i].name;\n            break;\n        }\n    }\n    if (key_name == NULL) {\n        // this key was not found in the key infos, create a name for it\n        AP4_FormatFourChars(four_cc, (AP4_UI32)atom_type);\n        key_name = four_cc;\n    }\n    value = key_name;\n    \n    return AP4_SUCCESS;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_MetaData::AddIlstEntries\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_MetaData::AddIlstEntries(AP4_ContainerAtom* atom, const char* namespc)\n{\n    AP4_MetaData::Value* value = NULL;\n\n    if (atom->GetType() == AP4_ATOM_TYPE_dddd) {\n        // look for the namespace\n        AP4_MetaDataStringAtom* mean = static_cast<AP4_MetaDataStringAtom*>(atom->GetChild(AP4_ATOM_TYPE_MEAN));\n        if (mean == NULL) return AP4_ERROR_INVALID_FORMAT;\n\n        // look for the name\n        AP4_MetaDataStringAtom* name = static_cast<AP4_MetaDataStringAtom*>(atom->GetChild(AP4_ATOM_TYPE_NAME));\n        if (name == NULL) return AP4_ERROR_INVALID_FORMAT;\n\n        // get the value\n        AP4_DataAtom* data_atom = static_cast<AP4_DataAtom*>(atom->GetChild(AP4_ATOM_TYPE_DATA));\n        if (data_atom == NULL) return AP4_ERROR_INVALID_FORMAT;\n        value = new AP4_AtomMetaDataValue(data_atom, atom->GetType());\n        \n        return m_Entries.Add(new Entry(name->GetValue().GetChars(),\n                                       mean->GetValue().GetChars(),\n                                       value));\n    } else {\n        const char* key_name = NULL;\n        char        four_cc[5];\n\n        // convert the atom type to a name\n        AP4_FormatFourChars(four_cc, (AP4_UI32)atom->GetType());\n        key_name = four_cc;\n\n        // add one entry for each data atom\n        AP4_List<AP4_Atom>::Item* data_item = atom->GetChildren().FirstItem();\n        while (data_item) {\n            AP4_Atom* item_atom = data_item->GetData();\n            if (item_atom->GetType() == AP4_ATOM_TYPE_DATA) {\n                AP4_DataAtom* data_atom = static_cast<AP4_DataAtom*>(item_atom);\n                value = new AP4_AtomMetaDataValue(data_atom, atom->GetType());\n                m_Entries.Add(new Entry(key_name, namespc, value));\n            }\n            data_item = data_item->GetNext();\n        }\n\n        return AP4_SUCCESS;\n    }\n}\n\n/*----------------------------------------------------------------------\n|   AP4_MetaData::Add3GppEntry\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_MetaData::Add3GppEntry(AP4_3GppLocalizedStringAtom* atom, const char* namespc)\n{\n    AP4_String key_name;\n    ResolveKeyName(atom->GetType(), key_name);\n    \n    const char* language = NULL;\n    if (atom->GetLanguage()[0]) {\n        language = atom->GetLanguage();\n    }\n    AP4_MetaData::Value* value = new AP4_StringMetaDataValue(atom->GetValue().GetChars(),\n                                                             language);\n    m_Entries.Add(new Entry(key_name.GetChars(), namespc, value));\n    \n    return AP4_SUCCESS;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_MetaData::AddDcfStringEntry\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_MetaData::AddDcfStringEntry(AP4_DcfStringAtom* atom, const char* namespc)\n{\n    AP4_String key_name;\n    ResolveKeyName(atom->GetType(), key_name);\n    \n    AP4_MetaData::Value* value = new AP4_StringMetaDataValue(atom->GetValue().GetChars());\n    m_Entries.Add(new Entry(key_name.GetChars(), namespc, value));\n    \n    return AP4_SUCCESS;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_MetaData::AddDcfdEntry\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_MetaData::AddDcfdEntry(AP4_DcfdAtom* atom, const char* namespc)\n{\n    AP4_String key_name;\n    ResolveKeyName(atom->GetType(), key_name);\n    \n    AP4_MetaData::Value* value = new AP4_IntegerMetaDataValue(AP4_MetaData::Value::TYPE_INT_32_BE, \n                                                              atom->GetDuration());\n    m_Entries.Add(new Entry(key_name.GetChars(), namespc, value));\n    \n    return AP4_SUCCESS;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_MetaData::Value::MapDataTypeToCategory\n+---------------------------------------------------------------------*/\nAP4_MetaData::Value::TypeCategory \nAP4_MetaData::Value::MapTypeToCategory(Type type)\n{\n    switch (type) {\n        case AP4_MetaData::Value::TYPE_INT_08_BE:\n        case AP4_MetaData::Value::TYPE_INT_16_BE:\n        case AP4_MetaData::Value::TYPE_INT_32_BE:\n            return AP4_MetaData::Value::TYPE_CATEGORY_INTEGER;\n\n        case AP4_MetaData::Value::TYPE_STRING_UTF_8:\n        case AP4_MetaData::Value::TYPE_STRING_UTF_16:\n        case AP4_MetaData::Value::TYPE_STRING_PASCAL:\n            return AP4_MetaData::Value::TYPE_CATEGORY_STRING;\n\n        case AP4_MetaData::Value::TYPE_FLOAT_32_BE:\n        case AP4_MetaData::Value::TYPE_FLOAT_64_BE:\n            return AP4_MetaData::Value::TYPE_CATEGORY_FLOAT;\n            \n        default:\n            return AP4_MetaData::Value::TYPE_CATEGORY_BINARY;\n    }\n}\n\n/*----------------------------------------------------------------------\n|   AP4_MetaData::Value::GetTypeCategory\n+---------------------------------------------------------------------*/\nAP4_MetaData::Value::TypeCategory \nAP4_MetaData::Value::GetTypeCategory() const\n{\n    return MapTypeToCategory(m_Type);\n}\n\n/*----------------------------------------------------------------------\n|   AP4_MetaData::Entry::ToAtom\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_MetaData::Entry::ToAtom(AP4_Atom*& atom) const\n{\n    atom = NULL;\n    \n    if (m_Value == NULL) {\n        return AP4_ERROR_INVALID_PARAMETERS;\n    }\n    \n    if (m_Key.GetNamespace() == \"meta\") {\n        // convert the name into an atom type\n        if (m_Key.GetName().GetLength() != 4) {\n            // the name is not in the right format\n            return AP4_ERROR_INVALID_PARAMETERS;\n        }\n        AP4_Atom::Type atom_type = AP4_Atom::TypeFromString(m_Key.GetName().GetChars()); \n                                   \n        // create a container atom for the data\n        AP4_ContainerAtom* container = new AP4_ContainerAtom(atom_type);\n\n        // add the data atom\n        AP4_DataAtom* data = new AP4_DataAtom(*m_Value);\n        container->AddChild(data);\n        \n        atom = container;\n        return AP4_SUCCESS;\n    } else if (m_Key.GetNamespace() == \"dcf\") {\n        // convert the name into an atom type\n        if (m_Key.GetName().GetLength() != 4) {\n            // the name is not in the right format\n            return AP4_ERROR_INVALID_PARAMETERS;\n        }\n        AP4_Atom::Type atom_type = AP4_Atom::TypeFromString(m_Key.GetName().GetChars()); \n\n        if (AP4_MetaDataAtomTypeHandler::IsTypeInList(atom_type, \n            AP4_MetaDataAtomTypeHandler::DcfStringTypeList)) {\n            AP4_String atom_value = m_Value->ToString();\n            atom = new AP4_DcfStringAtom(atom_type, atom_value.GetChars());\n            return AP4_SUCCESS;\n        } else if (AP4_MetaDataAtomTypeHandler::IsTypeInList(atom_type, \n                   AP4_MetaDataAtomTypeHandler::_3gppLocalizedStringTypeList)) {\n            AP4_String atom_value = m_Value->ToString();\n            const char* language = \"eng\"; // default\n            if (m_Value->GetLanguage().GetLength() != 0) {\n                language = m_Value->GetLanguage().GetChars();\n            }\n            atom = new AP4_3GppLocalizedStringAtom(atom_type, language, atom_value.GetChars());\n            return AP4_SUCCESS;\n        } else if (atom_type == AP4_ATOM_TYPE_DCFD) {\n            atom = new AP4_DcfdAtom((AP4_UI32)m_Value->ToInteger());\n            return AP4_SUCCESS;\n        }\n        \n         // not supported\n         return AP4_ERROR_NOT_SUPPORTED; \n    } else {\n        // create a '----' atom\n        AP4_ContainerAtom* container = new AP4_ContainerAtom(AP4_ATOM_TYPE_dddd);\n        \n        // add a 'mean' string\n        container->AddChild(new AP4_MetaDataStringAtom(AP4_ATOM_TYPE_MEAN, m_Key.GetNamespace().GetChars()));\n        \n        // add a 'name' string\n        container->AddChild(new AP4_MetaDataStringAtom(AP4_ATOM_TYPE_NAME, m_Key.GetName().GetChars()));\n\n        // add the data atom\n        AP4_DataAtom* data = new AP4_DataAtom(*m_Value);\n        container->AddChild(data);\n        \n        atom = container;\n        return AP4_SUCCESS;\n    }\n        \n    // unreachable - return AP4_ERROR_NOT_SUPPORTED;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_MetaData::Entry::FindInIlst\n+---------------------------------------------------------------------*/\nAP4_ContainerAtom*\nAP4_MetaData::Entry::FindInIlst(AP4_ContainerAtom* ilst) const\n{\n    if (m_Key.GetNamespace() == \"meta\") {\n        AP4_Atom::Type atom_type = AP4_Atom::TypeFromString(m_Key.GetName().GetChars());\n        return AP4_DYNAMIC_CAST(AP4_ContainerAtom, ilst->GetChild(atom_type));\n    } else {\n        AP4_List<AP4_Atom>::Item* ilst_item = ilst->GetChildren().FirstItem();\n        while (ilst_item) {\n            AP4_ContainerAtom* entry_atom = AP4_DYNAMIC_CAST(AP4_ContainerAtom, ilst_item->GetData()); \n            if (entry_atom) {\n                AP4_MetaDataStringAtom* mean = static_cast<AP4_MetaDataStringAtom*>(entry_atom->GetChild(AP4_ATOM_TYPE_MEAN));\n                AP4_MetaDataStringAtom* name = static_cast<AP4_MetaDataStringAtom*>(entry_atom->GetChild(AP4_ATOM_TYPE_NAME));\n                if (mean && name &&\n                    mean->GetValue() == m_Key.GetNamespace() &&\n                    name->GetValue() == m_Key.GetName()) {\n                    return entry_atom;\n                }\n            }\n            ilst_item = ilst_item->GetNext();\n        }\n    }\n    \n    // not found\n    return NULL;\n}\n    \n/*----------------------------------------------------------------------\n|   AP4_MetaData::Entry::AddToFileIlst\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_MetaData::Entry::AddToFileIlst(AP4_File& file, AP4_Ordinal index)\n{\n    // check that we have a correct entry\n    if (m_Value == NULL) return AP4_ERROR_INVALID_STATE;\n\n    // convert the entry into an atom\n    AP4_Atom* atom;\n    AP4_Result result = ToAtom(atom);\n    if (AP4_FAILED(result)) return result;\n    AP4_ContainerAtom* entry_atom = AP4_DYNAMIC_CAST(AP4_ContainerAtom, atom);\n    if (entry_atom == NULL) {\n        return AP4_ERROR_INVALID_FORMAT;\n    }\n\n    // look for the 'moov'\n    AP4_Movie* movie = file.GetMovie();\n    if (movie == NULL) return AP4_ERROR_INVALID_FORMAT;\n    AP4_MoovAtom* moov = movie->GetMoovAtom();\n    if (moov == NULL) return AP4_ERROR_INVALID_FORMAT;\n    \n    // look for 'udta', and create if it does not exist \n    AP4_ContainerAtom* udta = AP4_DYNAMIC_CAST(AP4_ContainerAtom, moov->FindChild(\"udta\", true));\n    if (udta == NULL) return AP4_ERROR_INTERNAL;\n    \n    // look for 'meta', and create if it does not exist ('meta' is a FULL atom)\n    AP4_ContainerAtom* meta = AP4_DYNAMIC_CAST(AP4_ContainerAtom, udta->FindChild(\"meta\", true, true));\n    if (meta == NULL) return AP4_ERROR_INTERNAL;\n\n    // look for a 'hdlr' atom type 'mdir'\n    AP4_HdlrAtom* hdlr = AP4_DYNAMIC_CAST(AP4_HdlrAtom, meta->FindChild(\"hdlr\"));\n    if (hdlr == NULL) {\n        hdlr = new AP4_HdlrAtom(AP4_HANDLER_TYPE_MDIR, \"\");\n        meta->AddChild(hdlr);\n    } else {\n        if (hdlr->GetHandlerType() != AP4_HANDLER_TYPE_MDIR) {\n            return AP4_ERROR_INVALID_FORMAT;\n        }\n    }\n\n    // get/create the list of entries\n    AP4_ContainerAtom* ilst = AP4_DYNAMIC_CAST(AP4_ContainerAtom, meta->FindChild(\"ilst\", true));\n    if (ilst == NULL) return AP4_ERROR_INTERNAL;\n    \n    // look if there is already a container for this entry\n    AP4_ContainerAtom* existing = FindInIlst(ilst);\n    if (existing == NULL) {\n        // just add the one we have\n        ilst->AddChild(entry_atom);\n    } else {\n        // add the entry's data to the existing entry\n        AP4_DataAtom* data_atom = AP4_DYNAMIC_CAST(AP4_DataAtom, entry_atom->GetChild(AP4_ATOM_TYPE_DATA));\n        if (data_atom == NULL) return AP4_ERROR_INTERNAL;\n        entry_atom->RemoveChild(data_atom);\n        existing->AddChild(data_atom, index);\n        delete entry_atom;\n    }\n    \n    return AP4_SUCCESS;    \n}\n\n/*----------------------------------------------------------------------\n|   AP4_MetaData::Entry::AddToFileDcf\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_MetaData::Entry::AddToFileDcf(AP4_File& file, AP4_Ordinal index)\n{\n    // check that we have a correct entry\n    if (m_Value == NULL) return AP4_ERROR_INVALID_STATE;\n    \n    // look for 'odrm/odhe'\n    AP4_ContainerAtom* odhe = AP4_DYNAMIC_CAST(AP4_ContainerAtom, file.FindChild(\"odrm/odhe\"));\n    if (odhe == NULL) return AP4_ERROR_NO_SUCH_ITEM;\n\n    // get/create the list of entries\n    AP4_ContainerAtom* udta = AP4_DYNAMIC_CAST(AP4_ContainerAtom, odhe->FindChild(\"udta\", true));\n    if (udta == NULL) return AP4_ERROR_INTERNAL;\n    \n    // convert the entry into an atom\n    AP4_Atom* data_atom;\n    AP4_Result result = ToAtom(data_atom);\n    if (AP4_FAILED(result)) return result;\n\n    // add the entry's data to the container\n    return udta->AddChild(data_atom, index);\n}\n\n/*----------------------------------------------------------------------\n|   AP4_MetaData::Entry::AddToFile\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_MetaData::Entry::AddToFile(AP4_File& file, AP4_Ordinal index)\n{\n    // check that we have a correct entry\n    if (m_Value == NULL) return AP4_ERROR_INVALID_STATE;\n \n    // check the namespace of the key to know where to add the atom\n    if (m_Key.GetNamespace() == \"meta\") {\n        return AddToFileIlst(file, index);\n    } else if (m_Key.GetNamespace() == \"dcf\") {\n        return AddToFileDcf(file, index);\n    } else {\n        // custom namespace\n        return AddToFileIlst(file, index);\n    }\n}\n\n/*----------------------------------------------------------------------\n|   AP4_MetaData::Entry::RemoveFromFileIlst\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_MetaData::Entry::RemoveFromFileIlst(AP4_File& file, AP4_Ordinal index)\n{\n    // look for the 'moov'\n    AP4_Movie* movie = file.GetMovie();\n    if (movie == NULL) return AP4_ERROR_INVALID_FORMAT;\n    AP4_MoovAtom* moov = movie->GetMoovAtom();\n    if (moov == NULL) return AP4_ERROR_INVALID_FORMAT;\n    \n    // look for 'udta/meta/ilst'\n    AP4_ContainerAtom* ilst = AP4_DYNAMIC_CAST(AP4_ContainerAtom, moov->FindChild(\"udta/meta/ilst\"));\n    if (ilst == NULL) return AP4_ERROR_NO_SUCH_ITEM;\n    \n    // look if there is already a container for this entry\n    AP4_ContainerAtom* existing = FindInIlst(ilst);\n    if (existing == NULL) return AP4_ERROR_NO_SUCH_ITEM;\n            \n    // remove the data atom in the entry\n    AP4_Result result = existing->DeleteChild(AP4_ATOM_TYPE_DATA, index);\n    if (AP4_FAILED(result)) return result;\n\n    // cleanup\n    if (existing->GetType() == AP4_ATOM_TYPE_dddd) {\n        // custom entry: if there are no more 'data' children, remove the entry\n        if (existing->GetChild(AP4_ATOM_TYPE_DATA) == NULL) {\n            ilst->RemoveChild(existing);\n            delete existing;\n        }\n    } else {\n        // normal entry: if the entry is empty, remove it\n        if (existing->GetChildren().ItemCount() == 0) {\n            ilst->RemoveChild(existing);\n            delete existing;\n        }\n    }\n    \n    return AP4_SUCCESS;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_MetaData::Entry::RemoveFromFileDcf\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_MetaData::Entry::RemoveFromFileDcf(AP4_File& file, AP4_Ordinal index)\n{\n    // look for 'odrm/odhe/udta'\n    AP4_ContainerAtom* udta = AP4_DYNAMIC_CAST(AP4_ContainerAtom, file.FindChild(\"odrm/odhe/udta\"));\n    if (udta == NULL) return AP4_ERROR_NO_SUCH_ITEM;\n                \n    // remove the data atom in the entry\n    AP4_UI32 type = AP4_BytesToUInt32BE((const unsigned char*)m_Key.GetName().GetChars());\n    AP4_Result result = udta->DeleteChild(type, index);\n    if (AP4_FAILED(result)) return result;\n    \n    return AP4_SUCCESS;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_MetaData::Entry::RemoveFromFile\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_MetaData::Entry::RemoveFromFile(AP4_File& file, AP4_Ordinal index)\n{\n    // check the namespace of the key to know where to add the atom\n    if (m_Key.GetNamespace() == \"meta\") {\n        return RemoveFromFileIlst(file, index);\n    } else if (m_Key.GetNamespace() == \"dcf\") {\n        return RemoveFromFileDcf(file, index);\n    } else {\n        // custom namespace\n        return RemoveFromFileIlst(file, index);\n    }\n}\n\n/*----------------------------------------------------------------------\n|   AP4_StringMetaDataValue::ToString\n+---------------------------------------------------------------------*/\nAP4_String\nAP4_StringMetaDataValue::ToString() const\n{\n    return m_Value;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_StringMetaDataValue::ToBytes\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_StringMetaDataValue::ToBytes(AP4_DataBuffer& /* bytes */) const\n{\n    return AP4_ERROR_NOT_SUPPORTED;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_StringMetaDataValue::ToInteger\n+---------------------------------------------------------------------*/\nlong\nAP4_StringMetaDataValue::ToInteger() const\n{\n    return 0;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_IntegerMetaDataValue::ToString\n+---------------------------------------------------------------------*/\nAP4_String\nAP4_IntegerMetaDataValue::ToString() const\n{\n    char value[16];\n    AP4_FormatString(value, sizeof(value), \"%ld\", m_Value);\n    return AP4_String(value);\n}\n\n/*----------------------------------------------------------------------\n|   AP4_IntegerMetaDataValue::ToBytes\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_IntegerMetaDataValue::ToBytes(AP4_DataBuffer& /* bytes */) const\n{\n    return AP4_ERROR_NOT_SUPPORTED;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_IntegerMetaDataValue::ToInteger\n+---------------------------------------------------------------------*/\nlong\nAP4_IntegerMetaDataValue::ToInteger() const\n{\n    return m_Value;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_BinaryMetaDataValue::ToString\n+---------------------------------------------------------------------*/\nAP4_String\nAP4_BinaryMetaDataValue::ToString() const\n{\n    return AP4_String(); // not supported\n}\n\n/*----------------------------------------------------------------------\n|   AP4_BinaryMetaDataValue::ToBytes\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_BinaryMetaDataValue::ToBytes(AP4_DataBuffer& bytes) const\n{\n    bytes.SetDataSize(m_Value.GetDataSize());\n    AP4_CopyMemory(bytes.UseData(), m_Value.GetData(), m_Value.GetDataSize());\n    return AP4_SUCCESS;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_BinaryMetaDataValue::ToInteger\n+---------------------------------------------------------------------*/\nlong\nAP4_BinaryMetaDataValue::ToInteger() const\n{\n    return 0; // NOT SUPPORTED\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AtomMetaDataValue::AP4_AtomMetaDataValue\n+---------------------------------------------------------------------*/\nAP4_AtomMetaDataValue::AP4_AtomMetaDataValue(AP4_DataAtom*  atom,\n                                             AP4_UI32       parent_type) :\n    Value(atom->GetValueType()),\n    m_DataAtom(atom)\n{\n    switch (parent_type) {\n        case AP4_ATOM_TYPE_GNRE:\n            m_Meaning = MEANING_ID3_GENRE;\n            break;\n\n        case AP4_ATOM_TYPE_CPIL:\n            m_Meaning = MEANING_BOOLEAN;\n            break;\n\n        case AP4_ATOM_TYPE_PGAP:\n        case AP4_ATOM_TYPE_PCST:\n            m_Meaning = MEANING_BOOLEAN;\n            break;\n\n        case AP4_ATOM_TYPE_STIK:\n            m_Meaning = MEANING_FILE_KIND;\n            break;\n\n        case AP4_ATOM_TYPE_PURL:\n        case AP4_ATOM_TYPE_EGID:\n            m_Meaning = MEANING_BINARY_ENCODED_CHARS;\n            break;\n            \n        default:\n            break;\n    }\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AtomMetaDataValue::ToString\n+---------------------------------------------------------------------*/\nAP4_String \nAP4_AtomMetaDataValue::ToString() const\n{\n    char string[256] = \"\";\n\n    AP4_MetaData::Value::Type value_type = m_DataAtom->GetValueType();\n    switch (AP4_MetaData::Value::MapTypeToCategory(value_type)) {\n        case AP4_MetaData::Value::TYPE_CATEGORY_INTEGER: \n            {\n                long value;\n                if (AP4_SUCCEEDED(m_DataAtom->LoadInteger(value))) {\n                    if (m_Meaning == MEANING_BOOLEAN) {\n                        if (value) {\n                            return \"True\";\n                        } else {\n                            return \"False\";\n                        }\n                    } else if (m_Meaning == MEANING_FILE_KIND) {\n                        if (value >= 0 && ((unsigned int)value) <= sizeof(Ap4StikNames)/sizeof(Ap4StikNames[0])) {\n                            AP4_FormatString(string, sizeof(string), \"(%ld) %s\", value, Ap4StikNames[value]);\n                        } else {\n                            return \"Unknown\";\n                        }\n                    } else {\n                        AP4_FormatString(string, sizeof(string), \"%ld\", value);\n                    }\n                }\n                return AP4_String((const char*)string);\n                break;\n            }\n\n        case AP4_MetaData::Value::TYPE_CATEGORY_STRING:\n            {\n                AP4_String* category_string;\n                if (AP4_SUCCEEDED(m_DataAtom->LoadString(category_string))) {\n                    AP4_String result(*category_string);\n                    delete category_string;\n                    return result;\n                }\n                break;\n            }\n\n        case AP4_MetaData::Value::TYPE_CATEGORY_BINARY:\n            {\n                AP4_DataBuffer data;\n                if (AP4_SUCCEEDED(m_DataAtom->LoadBytes(data))) {\n                    if (m_Meaning == MEANING_ID3_GENRE && data.GetDataSize() == 2) {\n                        unsigned int genre = (data.GetData()[0])*256+data.GetData()[1];\n                        if (genre >= 1 && genre <= sizeof(Ap4Id3Genres)/sizeof(Ap4Id3Genres[0])) {\n                            AP4_FormatString(string, sizeof(string), \"(%d) %s\", genre, Ap4Id3Genres[genre-1]);\n                            return AP4_String((const char*)string);\n                        } else {\n                            return \"Unknown\";\n                        }\n                    } else if (m_Meaning == MEANING_BINARY_ENCODED_CHARS) {\n                        AP4_String result;\n                        result.Assign((const char*)data.GetData(), data.GetDataSize());\n                        return result;\n                    } else {\n                        unsigned int dump_length = data.GetDataSize();\n                        bool truncate = false;\n                        if (dump_length > 16) {\n                            dump_length = 16;\n                            truncate = true;\n                        }\n                        char* out = string;\n                        for (unsigned int i=0; i<dump_length; i++) {\n                            AP4_FormatString(out, sizeof(string)-(out-string), \"%02x \", data.GetData()[i]);\n                            out += 3;\n                        }\n                        if (truncate) {\n                            *out++='.'; *out++='.'; *out++='.'; *out++=' ';\n                        }\n                        AP4_FormatString(out, sizeof(string)-(out-string), \"[%d bytes]\", (int)data.GetDataSize());\n                    }\n                }\n                return AP4_String(string);\n            }\n        default:\n            return AP4_String();\n    }\n\n    return AP4_String();\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AtomMetaDataValue::ToBytes\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_AtomMetaDataValue::ToBytes(AP4_DataBuffer& bytes) const\n{\n    return m_DataAtom->LoadBytes(bytes);\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AtomMetaDataValue::ToInteger\n+---------------------------------------------------------------------*/\nlong       \nAP4_AtomMetaDataValue::ToInteger() const\n{\n    long value;\n    if (AP4_SUCCEEDED(m_DataAtom->LoadInteger(value))) {\n        return value;\n    } else {\n        return 0;\n    }\n}\n\n/*----------------------------------------------------------------------\n|   AP4_DataAtom::AP4_DataAtom\n+---------------------------------------------------------------------*/\nAP4_DataAtom::AP4_DataAtom(const AP4_MetaData::Value& value) :\n    AP4_Atom(AP4_ATOM_TYPE_DATA, AP4_ATOM_HEADER_SIZE),\n    m_DataType(DATA_TYPE_BINARY)\n{\n    AP4_MemoryByteStream* memory = new AP4_MemoryByteStream();\n    AP4_Size payload_size = 8;\n    m_Source = memory;\n    \n    switch (value.GetType()) {\n        case AP4_MetaData::Value::TYPE_STRING_UTF_8: {\n            m_DataType = DATA_TYPE_STRING_UTF_8;\n            AP4_String string_value = value.ToString();\n            if (string_value.GetLength()) {\n                memory->Write(string_value.GetChars(), string_value.GetLength());\n            }\n            payload_size += string_value.GetLength();\n            break;\n        }\n         \n        case AP4_MetaData::Value::TYPE_INT_08_BE: {\n            m_DataType = DATA_TYPE_SIGNED_INT_BE;\n            AP4_UI08 int_value = (AP4_UI08)value.ToInteger();\n            memory->Write(&int_value, 1);\n            payload_size += 1;\n            break;\n        }\n            \n        case AP4_MetaData::Value::TYPE_INT_16_BE: {\n            m_DataType = DATA_TYPE_SIGNED_INT_BE;\n            AP4_UI16 int_value = (AP4_UI16)value.ToInteger();\n            memory->Write(&int_value, 2);\n            payload_size += 2;\n            break;\n        }\n\n        case AP4_MetaData::Value::TYPE_INT_32_BE: {\n            m_DataType = DATA_TYPE_SIGNED_INT_BE;\n            AP4_UI32 int_value = (AP4_UI32)value.ToInteger();\n            memory->Write(&int_value, 4);\n            payload_size += 4;\n            break;\n        }\n\n        case AP4_MetaData::Value::TYPE_JPEG:\n            m_DataType = DATA_TYPE_JPEG;\n            // FALLTHROUGH\n        case AP4_MetaData::Value::TYPE_GIF: \n            if (m_DataType == DATA_TYPE_BINARY) m_DataType = DATA_TYPE_GIF;\n            // FALLTHROUGH\n        case AP4_MetaData::Value::TYPE_BINARY: {\n            AP4_DataBuffer buffer;\n            value.ToBytes(buffer);\n            if (buffer.GetDataSize()) {\n                memory->Write(buffer.GetData(), buffer.GetDataSize());\n            }\n            payload_size += buffer.GetDataSize();\n            break;\n        }\n\n        default:\n            break;\n    }\n    \n    const AP4_String& language = value.GetLanguage();\n    if (language == \"en\") {\n        m_DataLang = LANGUAGE_ENGLISH;\n    } else {\n        // default\n        m_DataLang = LANGUAGE_ENGLISH;\n    }\n    \n    m_Size32 += payload_size;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_DataAtom::AP4_DataAtom\n+---------------------------------------------------------------------*/\nAP4_DataAtom::AP4_DataAtom(AP4_UI32 size, AP4_ByteStream& stream) :\n    AP4_Atom(AP4_ATOM_TYPE_DATA, size)\n{\n    if (size < AP4_ATOM_HEADER_SIZE+8) return;\n\n    AP4_UI32 i;\n    stream.ReadUI32(i); m_DataType = (DataType)i;\n    stream.ReadUI32(i); m_DataLang = (DataLang)i;\n\n    // the stream for the data is a substream of this source\n    AP4_Position data_offset;\n    stream.Tell(data_offset);\n    AP4_Size data_size = size-AP4_ATOM_HEADER_SIZE-8;\n    m_Source = new AP4_SubStream(stream, data_offset, data_size);\n}\n\n/*----------------------------------------------------------------------\n|   AP4_DataAtom::~AP4_DataAtom\n+---------------------------------------------------------------------*/\nAP4_DataAtom::~AP4_DataAtom()\n{\n    delete(m_Source);\n}\n\n/*----------------------------------------------------------------------\n|   AP4_DataAtom::GetValueType\n+---------------------------------------------------------------------*/\nAP4_MetaData::Value::Type\nAP4_DataAtom::GetValueType()\n{\n    switch (m_DataType) {\n        case DATA_TYPE_BINARY:\n            return AP4_MetaData::Value::TYPE_BINARY;\n\n        case DATA_TYPE_SIGNED_INT_BE:\n            switch (m_Size32-16) {\n                case 1: return AP4_MetaData::Value::TYPE_INT_08_BE;\n                case 2: return AP4_MetaData::Value::TYPE_INT_16_BE;\n                case 4: return AP4_MetaData::Value::TYPE_INT_32_BE;\n                default: return AP4_MetaData::Value::TYPE_BINARY;\n            }\n            break;\n            \n        case DATA_TYPE_STRING_UTF_8:\n            return AP4_MetaData::Value::TYPE_STRING_UTF_8;\n            \n        case DATA_TYPE_STRING_UTF_16:\n            return AP4_MetaData::Value::TYPE_STRING_UTF_16;\n            \n        case DATA_TYPE_STRING_PASCAL:\n            return AP4_MetaData::Value::TYPE_STRING_PASCAL;\n\n        case DATA_TYPE_GIF:\n            return AP4_MetaData::Value::TYPE_GIF;\n\n        case DATA_TYPE_JPEG:\n            return AP4_MetaData::Value::TYPE_JPEG;\n\n        default:\n            return AP4_MetaData::Value::TYPE_BINARY;\n    }\n    \n    // unreachable - return AP4_MetaData::Value::TYPE_BINARY;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_DataAtom::WriteFields\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_DataAtom::WriteFields(AP4_ByteStream& stream)\n{\n    stream.WriteUI32(m_DataType);\n    stream.WriteUI32(m_DataLang);\n    if (m_Source) {\n        AP4_LargeSize size = 0;\n        m_Source->GetSize(size);\n        m_Source->Seek(0);\n        m_Source->CopyTo(stream, size);\n    }\n\n    return AP4_SUCCESS;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_DataAtom::InspectFields\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_DataAtom::InspectFields(AP4_AtomInspector& inspector)\n{\n    inspector.AddField(\"type\", m_DataType);\n    inspector.AddField(\"lang\", m_DataLang);\n    if (m_DataType == DATA_TYPE_STRING_UTF_8) {\n        AP4_String* str;\n        if (AP4_SUCCEEDED(LoadString(str))) {\n            inspector.AddField(\"value\", str->GetChars());\n            delete str;\n        }\n    } else if (m_DataType == DATA_TYPE_SIGNED_INT_BE) {\n        long value;\n        if (AP4_SUCCEEDED(LoadInteger(value))) {\n            inspector.AddField(\"value\", value);\n        }\n    }\n\n    return AP4_SUCCESS;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_DataAtom::LoadString\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_DataAtom::LoadString(AP4_String*& string)\n{\n    if (m_Source == NULL) {\n        string = new AP4_String();\n        return AP4_SUCCESS;\n    } else {\n        // create a string with enough capactiy for the data\n        AP4_LargeSize size = 0;\n        m_Source->GetSize(size);\n        if (size > AP4_DATA_ATOM_MAX_SIZE) return AP4_ERROR_OUT_OF_RANGE;\n        string = new AP4_String((AP4_Size)size);\n\n        // read from the start of the stream\n        m_Source->Seek(0);\n        AP4_Result result = m_Source->Read(string->UseChars(), (AP4_Size)size);\n        if (AP4_FAILED(result)) {\n            delete string;\n            string = NULL;\n        }\n\n        return result;\n    }\n}\n\n/*----------------------------------------------------------------------\n|   AP4_DataAtom::LoadBytes\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_DataAtom::LoadBytes(AP4_DataBuffer& bytes)\n{\n    if (m_Source == NULL) {\n        bytes.SetDataSize(0);\n        return AP4_SUCCESS;\n    }\n    AP4_LargeSize size = 0;\n    m_Source->GetSize(size);\n    if (size > AP4_DATA_ATOM_MAX_SIZE) return AP4_ERROR_OUT_OF_RANGE;\n    bytes.SetDataSize((AP4_Size)size);\n    m_Source->Seek(0);\n    AP4_Result result = m_Source->Read(bytes.UseData(), (AP4_Size)size);\n    if (AP4_FAILED(result)) {\n        bytes.SetDataSize(0);\n    }\n    return result;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_DataAtom::LoadInteger\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_DataAtom::LoadInteger(long& value) \n{\n    AP4_Result result = AP4_FAILURE;\n    value = 0;\n    if (m_Source == NULL) return AP4_SUCCESS;\n    AP4_LargeSize size = 0;\n    m_Source->GetSize(size);\n    if (size > 4) {\n        return AP4_ERROR_OUT_OF_RANGE;\n    }\n    unsigned char bytes[4];\n    m_Source->Seek(0);\n    m_Source->Read(bytes, (AP4_Size)size);\n    result = AP4_SUCCESS;\n    switch (size) {\n        case 1: value = bytes[0]; break;\n        case 2: value = AP4_BytesToInt16BE(bytes); break;\n        case 4: value = AP4_BytesToInt32BE(bytes); break;\n        default: value = 0; result = AP4_ERROR_INVALID_FORMAT; break;\n    }\n    return result;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_MetaDataStringAtom::AP4_MetaDataStringAtom\n+---------------------------------------------------------------------*/\nAP4_MetaDataStringAtom::AP4_MetaDataStringAtom(Type type, const char* value) :\n    AP4_Atom(type, AP4_ATOM_HEADER_SIZE),\n    m_Reserved(0),\n    m_Value(value)\n{\n    m_Size32 += 4+m_Value.GetLength();\n}\n\n/*----------------------------------------------------------------------\n|   AP4_MetaDataStringAtom::AP4_MetaDataStringAtom\n+---------------------------------------------------------------------*/\nAP4_MetaDataStringAtom::AP4_MetaDataStringAtom(Type type, AP4_UI32 size, AP4_ByteStream& stream) :\n    AP4_Atom(type, size),\n    m_Reserved(0),\n    m_Value((AP4_Size)(size-AP4_ATOM_HEADER_SIZE-4))\n{\n    stream.ReadUI32(m_Reserved);\n    stream.Read(m_Value.UseChars(), m_Value.GetLength());\n}\n\n/*----------------------------------------------------------------------\n|   AP4_MetaDataStringAtom::WriteFields\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_MetaDataStringAtom::WriteFields(AP4_ByteStream& stream)\n{\n    stream.WriteUI32(m_Reserved);\n    return stream.Write(m_Value.GetChars(), m_Value.GetLength());\n}\n\n/*----------------------------------------------------------------------\n|   AP4_MetaDataStringAtom::InspectFields\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_MetaDataStringAtom::InspectFields(AP4_AtomInspector& inspector)\n{\n    inspector.AddField(\"value\", m_Value.GetChars());\n    return AP4_SUCCESS;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_3GppLocalizedStringAtom::Create\n+---------------------------------------------------------------------*/\nAP4_3GppLocalizedStringAtom*\nAP4_3GppLocalizedStringAtom::Create(Type type, AP4_UI32 size, AP4_ByteStream& stream) \n{\n    AP4_UI08 version;\n    AP4_UI32 flags;\n    if (AP4_FAILED(AP4_Atom::ReadFullHeader(stream, version, flags))) return NULL;\n    if (version != 0) return NULL;\n    return new AP4_3GppLocalizedStringAtom(type, size, version, flags, stream);\n}\n\n/*----------------------------------------------------------------------\n|   AP4_3GppLocalizedStringAtom::AP4_3GppLocalizedStringAtom\n+---------------------------------------------------------------------*/\nAP4_3GppLocalizedStringAtom::AP4_3GppLocalizedStringAtom(Type        type, \n                                                         const char* language, \n                                                         const char* value) :\n    AP4_Atom(type, AP4_FULL_ATOM_HEADER_SIZE+2, 0, 0),\n    m_Value(value)\n{\n    m_Language[0] = language[0];\n    m_Language[1] = language[1];\n    m_Language[2] = language[2];\n    m_Language[3] = language[3];\n    \n    m_Size32 += m_Value.GetLength()+1;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_3GppLocalizedStringAtom::AP4_3GppLocalizedStringAtom\n+---------------------------------------------------------------------*/\nAP4_3GppLocalizedStringAtom::AP4_3GppLocalizedStringAtom(Type            type, \n                                                         AP4_UI32        size, \n                                                         AP4_UI08        version,\n                                                         AP4_UI32        flags,\n                                                         AP4_ByteStream& stream) :\n    AP4_Atom(type, size, version, flags)\n{\n    // read the language code\n    AP4_UI16 packed_language;\n    stream.ReadUI16(packed_language);\n    m_Language[0] = 0x60+((packed_language>>10)&0x1F);\n    m_Language[1] = 0x60+((packed_language>> 5)&0x1F);\n    m_Language[2] = 0x60+((packed_language    )&0x1F);\n    m_Language[3] = '\\0';\n    \n    // read the value (should be a NULL-terminated string, but we'll\n    // allow for strings that are not terminated)\n    if (size > AP4_FULL_ATOM_HEADER_SIZE+2) {\n        AP4_UI32 value_size = size-(AP4_FULL_ATOM_HEADER_SIZE+2);\n        char* value = new char[value_size];\n        stream.Read(value, value_size);\n        m_Value.Assign(value, value_size);\n        delete[] value;\n    }\n}\n\n/*----------------------------------------------------------------------\n|   AP4_3GppLocalizedStringAtom::WriteFields\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_3GppLocalizedStringAtom::WriteFields(AP4_ByteStream& stream)\n{\n    AP4_UI16 packed_language = ((m_Language[0]-0x60)<<10) |\n                               ((m_Language[1]-0x60)<< 5) |\n                               ((m_Language[2]-0x60));\n    stream.WriteUI16(packed_language);\n    AP4_Size payload_size = (AP4_UI32)GetSize()-GetHeaderSize();\n    if (payload_size < 2) return AP4_ERROR_INVALID_FORMAT;\n    AP4_Size value_size = m_Value.GetLength()+1;\n    if (value_size > payload_size-2) {\n        value_size = payload_size-2;\n    }\n    stream.Write(m_Value.GetChars(), value_size);\n    for (unsigned int i=value_size; i<payload_size-2; i++) {\n        stream.WriteUI08(0);\n    }\n    return AP4_SUCCESS;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_3GppLocalizedStringAtom::InspectFields\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_3GppLocalizedStringAtom::InspectFields(AP4_AtomInspector& inspector)\n{\n    inspector.AddField(\"language\", GetLanguage());\n    inspector.AddField(\"value\", m_Value.GetChars());\n    return AP4_SUCCESS;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_DcfStringAtom::Create\n+---------------------------------------------------------------------*/\nAP4_DcfStringAtom*\nAP4_DcfStringAtom::Create(Type type, AP4_UI32 size, AP4_ByteStream& stream) \n{\n    AP4_UI08 version;\n    AP4_UI32 flags;\n    if (AP4_FAILED(AP4_Atom::ReadFullHeader(stream, version, flags))) return NULL;\n    if (version != 0) return NULL;\n    return new AP4_DcfStringAtom(type, size, version, flags, stream);\n}\n\n/*----------------------------------------------------------------------\n|   AP4_DcfStringAtom::AP4_DcfStringAtom\n+---------------------------------------------------------------------*/\nAP4_DcfStringAtom::AP4_DcfStringAtom(Type type, const char* value) :\n    AP4_Atom(type, AP4_FULL_ATOM_HEADER_SIZE, 0, 0),\n    m_Value(value)\n{\n    m_Size32 += m_Value.GetLength();\n}\n\n/*----------------------------------------------------------------------\n|   AP4_DcfStringAtom::AP4_DcfStringAtom\n+---------------------------------------------------------------------*/\nAP4_DcfStringAtom::AP4_DcfStringAtom(Type            type, \n                                     AP4_UI32        size, \n                                     AP4_UI08        version,\n                                     AP4_UI32        flags,\n                                     AP4_ByteStream& stream) :\n    AP4_Atom(type, size, version, flags)\n{\n    if (size > AP4_FULL_ATOM_HEADER_SIZE) {\n        AP4_UI32 value_size = size-(AP4_FULL_ATOM_HEADER_SIZE);\n        char* value = new char[value_size];\n        stream.Read(value, value_size);\n        m_Value.Assign(value, value_size);\n        delete[] value;\n    }\n}\n\n/*----------------------------------------------------------------------\n|   AP4_DcfStringAtom::WriteFields\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_DcfStringAtom::WriteFields(AP4_ByteStream& stream)\n{\n    if (m_Value.GetLength()) stream.Write(m_Value.GetChars(), m_Value.GetLength());\n    return AP4_SUCCESS;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_DcfStringAtom::InspectFields\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_DcfStringAtom::InspectFields(AP4_AtomInspector& inspector)\n{\n    inspector.AddField(\"value\", m_Value.GetChars());\n    return AP4_SUCCESS;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_DcfdAtom::Create\n+---------------------------------------------------------------------*/\nAP4_DcfdAtom*\nAP4_DcfdAtom::Create(AP4_UI32 size, AP4_ByteStream& stream) \n{\n    AP4_UI08 version;\n    AP4_UI32 flags;\n    if (AP4_FAILED(AP4_Atom::ReadFullHeader(stream, version, flags))) return NULL;\n    if (version != 0) return NULL;\n    if (size != AP4_FULL_ATOM_HEADER_SIZE+4) return NULL;\n    return new AP4_DcfdAtom(version, flags, stream);\n}\n\n/*----------------------------------------------------------------------\n|   AP4_DcfdAtom::AP4_DcfdAtom\n+---------------------------------------------------------------------*/\nAP4_DcfdAtom::AP4_DcfdAtom(AP4_UI08        version,\n                           AP4_UI32        flags,\n                           AP4_ByteStream& stream) :\n    AP4_Atom(AP4_ATOM_TYPE_DCFD, AP4_FULL_ATOM_HEADER_SIZE+4, version, flags),\n    m_Duration(0)\n{\n    stream.ReadUI32(m_Duration);\n}\n\n/*----------------------------------------------------------------------\n|   AP4_DcfdAtom::AP4_DcfdAtom\n+---------------------------------------------------------------------*/\nAP4_DcfdAtom::AP4_DcfdAtom(AP4_UI32 duration) :\n    AP4_Atom(AP4_ATOM_TYPE_DCFD, AP4_FULL_ATOM_HEADER_SIZE+4, 0, 0),\n    m_Duration(duration)\n{\n}\n\n/*----------------------------------------------------------------------\n|   AP4_DcfdAtom::WriteFields\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_DcfdAtom::WriteFields(AP4_ByteStream& stream)\n{\n    stream.WriteUI32(m_Duration);\n    return AP4_SUCCESS;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_DcfdAtom::InspectFields\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_DcfdAtom::InspectFields(AP4_AtomInspector& inspector)\n{\n    inspector.AddField(\"duration\", m_Duration);\n    return AP4_SUCCESS;\n}\n"], "fixing_code": ["/*****************************************************************\n|\n|    AP4 - MetaData \n|\n|    Copyright 2002-2008 Axiomatic Systems, LLC\n|\n|\n|    This file is part of Bento4/AP4 (MP4 Atom Processing Library).\n|\n|    Unless you have obtained Bento4 under a difference license,\n|    this version of Bento4 is Bento4|GPL.\n|    Bento4|GPL is free software; you can redistribute it and/or modify\n|    it under the terms of the GNU General Public License as published by\n|    the Free Software Foundation; either version 2, or (at your option)\n|    any later version.\n|\n|    Bento4|GPL is distributed in the hope that it will be useful,\n|    but WITHOUT ANY WARRANTY; without even the implied warranty of\n|    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n|    GNU General Public License for more details.\n|\n|    You should have received a copy of the GNU General Public License\n|    along with Bento4|GPL; see the file COPYING.  If not, write to the\n|    Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n|    02111-1307, USA.\n|\n****************************************************************/\n\n/*----------------------------------------------------------------------\n|   includes\n+---------------------------------------------------------------------*/\n#include \"Ap4File.h\"\n#include \"Ap4Movie.h\"\n#include \"Ap4MetaData.h\"\n#include \"Ap4ContainerAtom.h\"\n#include \"Ap4MoovAtom.h\"\n#include \"Ap4HdlrAtom.h\"\n#include \"Ap4DataBuffer.h\"\n#include \"Ap4Utils.h\"\n#include \"Ap4String.h\"\n\n/*----------------------------------------------------------------------\n|   dynamic cast support\n+---------------------------------------------------------------------*/\nAP4_DEFINE_DYNAMIC_CAST_ANCHOR(AP4_3GppLocalizedStringAtom)\nAP4_DEFINE_DYNAMIC_CAST_ANCHOR(AP4_DcfdAtom)\nAP4_DEFINE_DYNAMIC_CAST_ANCHOR(AP4_DcfStringAtom)\nAP4_DEFINE_DYNAMIC_CAST_ANCHOR(AP4_DataAtom)\nAP4_DEFINE_DYNAMIC_CAST_ANCHOR(AP4_MetaDataStringAtom)\n\n/*----------------------------------------------------------------------\n|   metadata keys\n+---------------------------------------------------------------------*/\nstatic const AP4_MetaData::KeyInfo AP4_MetaData_KeyInfos [] = {\n    {\"Name\",                \"Name\",                 AP4_ATOM_TYPE_cNAM, AP4_MetaData::Value::TYPE_STRING_UTF_8},\n    {\"Artist\",              \"Artist\",               AP4_ATOM_TYPE_cART, AP4_MetaData::Value::TYPE_STRING_UTF_8},\n    {\"AlbumArtist\",         \"Album Artist\",         AP4_ATOM_TYPE_aART, AP4_MetaData::Value::TYPE_STRING_UTF_8},\n    {\"Composer\",            \"Composer\",             AP4_ATOM_TYPE_cCOM, AP4_MetaData::Value::TYPE_STRING_UTF_8},\n    {\"Writer\",              \"Writer\",               AP4_ATOM_TYPE_cWRT, AP4_MetaData::Value::TYPE_STRING_UTF_8},\n    {\"Album\",               \"Album\",                AP4_ATOM_TYPE_cALB, AP4_MetaData::Value::TYPE_STRING_UTF_8},\n    {\"GenreCode\",           \"Genre\",                AP4_ATOM_TYPE_GNRE, AP4_MetaData::Value::TYPE_BINARY},\n    {\"GenreName\",           \"Genre\",                AP4_ATOM_TYPE_cGEN, AP4_MetaData::Value::TYPE_STRING_UTF_8},\n    {\"Grouping\",            \"Grouping\",             AP4_ATOM_TYPE_cGRP, AP4_MetaData::Value::TYPE_STRING_UTF_8},\n    {\"Date\",                \"Date\",                 AP4_ATOM_TYPE_cDAY, AP4_MetaData::Value::TYPE_STRING_UTF_8},\n    {\"Tool\",                \"Encoding Tool\",        AP4_ATOM_TYPE_cTOO, AP4_MetaData::Value::TYPE_STRING_UTF_8},\n    {\"Comment\",             \"Comment\",              AP4_ATOM_TYPE_cCMT, AP4_MetaData::Value::TYPE_STRING_UTF_8},\n    {\"Lyrics\",              \"Lyrics\",               AP4_ATOM_TYPE_cLYR, AP4_MetaData::Value::TYPE_STRING_UTF_8},\n    {\"Copyright\",           \"Copyright\",            AP4_ATOM_TYPE_CPRT, AP4_MetaData::Value::TYPE_STRING_UTF_8},\n    {\"Track\",               \"Track Number\",         AP4_ATOM_TYPE_TRKN, AP4_MetaData::Value::TYPE_BINARY},\n    {\"Disc\",                \"Disc Number\",          AP4_ATOM_TYPE_DISK, AP4_MetaData::Value::TYPE_BINARY},\n    {\"Cover\",               \"Cover Art\",            AP4_ATOM_TYPE_COVR, AP4_MetaData::Value::TYPE_BINARY},\n    {\"Description\",         \"Description\",          AP4_ATOM_TYPE_DESC, AP4_MetaData::Value::TYPE_STRING_UTF_8},\n    {\"Rating\",              \"Rating\",               AP4_ATOM_TYPE_RTNG, AP4_MetaData::Value::TYPE_INT_08_BE},\n    {\"Tempo\",               \"Tempo\",                AP4_ATOM_TYPE_TMPO, AP4_MetaData::Value::TYPE_INT_16_BE},\n    {\"Compilation\",         \"Compilation\",          AP4_ATOM_TYPE_CPIL, AP4_MetaData::Value::TYPE_INT_08_BE},\n    {\"IsGapless\",           \"Is Gapless\",           AP4_ATOM_TYPE_PGAP, AP4_MetaData::Value::TYPE_INT_08_BE},\n    {\"Title\",               \"Title\",                AP4_ATOM_TYPE_TITL, AP4_MetaData::Value::TYPE_STRING_UTF_8},\n    {\"Description\",         \"Description\",          AP4_ATOM_TYPE_DSCP, AP4_MetaData::Value::TYPE_STRING_UTF_8},\n    {\"StoreFrontID\",        \"Store Front ID\",       AP4_ATOM_TYPE_sfID, AP4_MetaData::Value::TYPE_INT_32_BE},\n    {\"FileKind\",            \"File Kind\",            AP4_ATOM_TYPE_STIK, AP4_MetaData::Value::TYPE_INT_08_BE},\n    {\"ShowName\",            \"Show Name\",            AP4_ATOM_TYPE_TVSH, AP4_MetaData::Value::TYPE_STRING_UTF_8},\n    {\"ShowSeason\",          \"Show Season Number\",   AP4_ATOM_TYPE_TVSN, AP4_MetaData::Value::TYPE_INT_32_BE},\n    {\"ShowEpisodeNumber\",   \"Show Episode Number\",  AP4_ATOM_TYPE_TVES, AP4_MetaData::Value::TYPE_INT_32_BE},\n    {\"ShowEpisodeName\",     \"Show Episode Name\",    AP4_ATOM_TYPE_TVEN, AP4_MetaData::Value::TYPE_STRING_UTF_8},\n    {\"TVNetworkName\",       \"TV Network Name\",      AP4_ATOM_TYPE_TVNN, AP4_MetaData::Value::TYPE_STRING_UTF_8},\n    {\"IsPodcast\",           \"Is a Podcast\",         AP4_ATOM_TYPE_PCST, AP4_MetaData::Value::TYPE_INT_08_BE},\n    {\"PodcastUrl\",          \"Podcast URL\",          AP4_ATOM_TYPE_PURL, AP4_MetaData::Value::TYPE_BINARY},\n    {\"PodcastGuid\",         \"Podcast GUID\",         AP4_ATOM_TYPE_EGID, AP4_MetaData::Value::TYPE_BINARY},\n    {\"PodcastCategory\",     \"Podcast Category\",     AP4_ATOM_TYPE_CATG, AP4_MetaData::Value::TYPE_STRING_UTF_8},\n    {\"Keywords\",            \"Keywords\",             AP4_ATOM_TYPE_KEYW, AP4_MetaData::Value::TYPE_STRING_UTF_8},\n    {\"PurchaseDate\",        \"Purchase Date\",        AP4_ATOM_TYPE_PURD, AP4_MetaData::Value::TYPE_STRING_UTF_8},\n    {\"IconUri\",             \"Icon URI\",             AP4_ATOM_TYPE_ICNU, AP4_MetaData::Value::TYPE_STRING_UTF_8},\n    {\"InfoUrl\",             \"Info URL\",             AP4_ATOM_TYPE_INFU, AP4_MetaData::Value::TYPE_STRING_UTF_8},\n    {\"CoverUri\",            \"Cover Art URI\",        AP4_ATOM_TYPE_CVRU, AP4_MetaData::Value::TYPE_STRING_UTF_8},\n    {\"LyricsUri\",           \"Lyrics URI\",           AP4_ATOM_TYPE_LRCU, AP4_MetaData::Value::TYPE_STRING_UTF_8},\n    {\"Duration\",            \"Duration\",             AP4_ATOM_TYPE_DCFD, AP4_MetaData::Value::TYPE_INT_32_BE},\n    {\"Performer\",           \"Performer\",            AP4_ATOM_TYPE_PERF, AP4_MetaData::Value::TYPE_STRING_UTF_8},\n    {\"Author\",              \"Author\",               AP4_ATOM_TYPE_AUTH, AP4_MetaData::Value::TYPE_STRING_UTF_8},\n};\nAP4_Array<AP4_MetaData::KeyInfo> AP4_MetaData::KeyInfos(\n    AP4_MetaData_KeyInfos, \n    sizeof(AP4_MetaData_KeyInfos)/sizeof(KeyInfo));\nAP4_Result\nAP4_MetaData::Initialized() { return AP4_MetaData::KeyInfos.ItemCount() != 0; }\nAP4_Result\nAP4_MetaData::Initialize() {\n    unsigned int item_count = sizeof(AP4_MetaData_KeyInfos)/sizeof(KeyInfo);\n    KeyInfos.SetItemCount(item_count);\n    for (unsigned int i=0; i<item_count; i++) {\n        KeyInfos[i] = AP4_MetaData_KeyInfos[i];\n    }\n    return AP4_SUCCESS;\n}\nAP4_Result\nAP4_MetaData::UnInitialize() {\n    return AP4_MetaData::KeyInfos.Clear();\n}\n\n/*----------------------------------------------------------------------\n|   genre IDs\n+---------------------------------------------------------------------*/\nstatic const char* const Ap4Id3Genres[] = \n{\n    \"Blues\",\n    \"Classic Rock\",\n    \"Country\",\n    \"Dance\",\n    \"Disco\",\n    \"Funk\",\n    \"Grunge\",\n    \"Hip-Hop\",\n    \"Jazz\",\n    \"Metal\",\n    \"New Age\",\n    \"Oldies\",\n    \"Other\",\n    \"Pop\",\n    \"R&B\",\n    \"Rap\",\n    \"Reggae\",\n    \"Rock\",\n    \"Techno\",\n    \"Industrial\",\n    \"Alternative\",\n    \"Ska\",\n    \"Death Metal\",\n    \"Pranks\",\n    \"Soundtrack\",\n    \"Euro-Techno\",\n    \"Ambient\",\n    \"Trip-Hop\",\n    \"Vocal\",\n    \"Jazz+Funk\",\n    \"Fusion\",\n    \"Trance\",\n    \"Classical\",\n    \"Instrumental\",\n    \"Acid\",\n    \"House\",\n    \"Game\",\n    \"Sound Clip\",\n    \"Gospel\",\n    \"Noise\",\n    \"AlternRock\",\n    \"Bass\",\n    \"Soul\",\n    \"Punk\",\n    \"Space\",\n    \"Meditative\",\n    \"Instrumental Pop\",\n    \"Instrumental Rock\",\n    \"Ethnic\",\n    \"Gothic\",\n    \"Darkwave\",\n    \"Techno-Industrial\",\n    \"Electronic\",\n    \"Pop-Folk\",\n    \"Eurodance\",\n    \"Dream\",\n    \"Southern Rock\",\n    \"Comedy\",\n    \"Cult\",\n    \"Gangsta\",\n    \"Top 40\",\n    \"Christian Rap\",\n    \"Pop/Funk\",\n    \"Jungle\",\n    \"Native American\",\n    \"Cabaret\",\n    \"New Wave\",\n    \"Psychadelic\",\n    \"Rave\",\n    \"Showtunes\",\n    \"Trailer\",\n    \"Lo-Fi\",\n    \"Tribal\",\n    \"Acid Punk\",\n    \"Acid Jazz\",\n    \"Polka\",\n    \"Retro\",\n    \"Musical\",\n    \"Rock & Roll\",\n    \"Hard Rock\",\n    \"Folk\",\n    \"Folk-Rock\",\n    \"National Folk\",\n    \"Swing\",\n    \"Fast Fusion\",\n    \"Bebob\",\n    \"Latin\",\n    \"Revival\",\n    \"Celtic\",\n    \"Bluegrass\",\n    \"Avantgarde\",\n    \"Gothic Rock\",\n    \"Progressive Rock\",\n    \"Psychedelic Rock\",\n    \"Symphonic Rock\",\n    \"Slow Rock\",\n    \"Big Band\",\n    \"Chorus\",\n    \"Easy Listening\",\n    \"Acoustic\",\n    \"Humour\",\n    \"Speech\",\n    \"Chanson\",\n    \"Opera\",\n    \"Chamber Music\",\n    \"Sonata\",\n    \"Symphony\",\n    \"Booty Bass\",\n    \"Primus\",\n    \"Porn Groove\",\n    \"Satire\",\n    \"Slow Jam\",\n    \"Club\",\n    \"Tango\",\n    \"Samba\",\n    \"Folklore\",\n    \"Ballad\",\n    \"Power Ballad\",\n    \"Rhythmic Soul\",\n    \"Freestyle\",\n    \"Duet\",\n    \"Punk Rock\",\n    \"Drum Solo\",\n    \"Acapella\",\n    \"Euro-House\",\n    \"Dance Hall\"\n};\n\nstatic const char*\nAp4StikNames[] = {\n    \"Movie\",            // 0\n    \"Normal\",           // 1\n    \"Audiobook\",        // 2\n    \"?\",                // 3\n    \"?\",                // 4\n    \"Whacked Bookmark\", // 5\n    \"Music Video\",      // 6\n    \"?\",                // 7\n    \"?\",                // 8\n    \"Short Film\",       // 9 \n    \"TV Show\",          // 10\n    \"Booklet\",          // 11\n    \"?\",                // 12\n    \"?\",                // 13\n    \"Ring Tone\"         // 14\n};\n\n\n/* sfID Store Front country\n    Australia   => 143460,\n    Austria     => 143445,\n    Belgium     => 143446,\n    Canada      => 143455,\n    Denmark     => 143458,\n    Finland     => 143447,\n    France      => 143442,\n    Germany     => 143443,\n    Greece      => 143448,\n    Ireland     => 143449,\n    Italy       => 143450,\n    Japan       => 143462,\n    Luxembourg  => 143451,\n    Netherlands => 143452,\n    Norway      => 143457,\n    Portugal    => 143453,\n    Spain       => 143454,\n    Sweden      => 143456,\n    Switzerland => 143459,\n    UK          => 143444,\n    USA         => 143441,\n*/\n\n/*----------------------------------------------------------------------\n|   constants\n+---------------------------------------------------------------------*/\nconst AP4_Size AP4_DATA_ATOM_MAX_SIZE = 0x40000000;\n\n/*----------------------------------------------------------------------\n|   3GPP localized string atoms\n+---------------------------------------------------------------------*/\nconst AP4_Atom::Type AP4_MetaDataAtomTypeHandler::_3gppLocalizedStringTypes[] = {\n    AP4_ATOM_TYPE_TITL,\n    AP4_ATOM_TYPE_DSCP,\n    AP4_ATOM_TYPE_CPRT,\n    AP4_ATOM_TYPE_PERF,\n    AP4_ATOM_TYPE_AUTH,\n    AP4_ATOM_TYPE_GNRE\n};\nconst AP4_MetaDataAtomTypeHandler::TypeList AP4_MetaDataAtomTypeHandler::_3gppLocalizedStringTypeList = {\n    _3gppLocalizedStringTypes,\n    sizeof(_3gppLocalizedStringTypes)/sizeof(_3gppLocalizedStringTypes[0])\n};\n\n/*----------------------------------------------------------------------\n|   other 3GPP atoms\n+---------------------------------------------------------------------*/\nconst AP4_Atom::Type AP4_MetaDataAtomTypeHandler::_3gppOtherTypes[] = {\n    AP4_ATOM_TYPE_RTNG,\n    AP4_ATOM_TYPE_CLSF,\n    AP4_ATOM_TYPE_KYWD,\n    AP4_ATOM_TYPE_LOCI,\n    AP4_ATOM_TYPE_ALBM,\n    AP4_ATOM_TYPE_YRRC,\n};\nconst AP4_MetaDataAtomTypeHandler::TypeList AP4_MetaDataAtomTypeHandler::_3gppOtherTypeList = {\n    _3gppOtherTypes,\n    sizeof(_3gppOtherTypes)/sizeof(_3gppOtherTypes[0])\n};\n\n/*----------------------------------------------------------------------\n|   DCF string atoms\n+---------------------------------------------------------------------*/\nconst AP4_Atom::Type AP4_MetaDataAtomTypeHandler::DcfStringTypes[] = {\n    AP4_ATOM_TYPE_ICNU,\n    AP4_ATOM_TYPE_INFU,\n    AP4_ATOM_TYPE_CVRU,\n    AP4_ATOM_TYPE_LRCU\n};\nconst AP4_MetaDataAtomTypeHandler::TypeList AP4_MetaDataAtomTypeHandler::DcfStringTypeList = {\n    DcfStringTypes,\n    sizeof(DcfStringTypes)/sizeof(DcfStringTypes[0])\n};\n\n/*----------------------------------------------------------------------\n|   atom type lists\n+---------------------------------------------------------------------*/\nconst AP4_Atom::Type AP4_MetaDataAtomTypeHandler::IlstTypes[] = \n{\n    AP4_ATOM_TYPE_dddd,\n    AP4_ATOM_TYPE_cNAM,\n    AP4_ATOM_TYPE_cART,\n    AP4_ATOM_TYPE_cCOM,\n    AP4_ATOM_TYPE_cWRT,\n    AP4_ATOM_TYPE_cALB,\n    AP4_ATOM_TYPE_cGEN,\n    AP4_ATOM_TYPE_cGRP,\n    AP4_ATOM_TYPE_cDAY,\n    AP4_ATOM_TYPE_cTOO,\n    AP4_ATOM_TYPE_cCMT,\n    AP4_ATOM_TYPE_CPRT,\n    AP4_ATOM_TYPE_TRKN,\n    AP4_ATOM_TYPE_DISK,\n    AP4_ATOM_TYPE_COVR,\n    AP4_ATOM_TYPE_DESC,\n    AP4_ATOM_TYPE_GNRE,\n    AP4_ATOM_TYPE_CPIL,\n    AP4_ATOM_TYPE_TMPO,\n    AP4_ATOM_TYPE_RTNG,\n    AP4_ATOM_TYPE_apID,\n    AP4_ATOM_TYPE_cnID,\n    AP4_ATOM_TYPE_cmID,\n    AP4_ATOM_TYPE_atID,\n    AP4_ATOM_TYPE_plID,\n    AP4_ATOM_TYPE_geID,\n    AP4_ATOM_TYPE_sfID,\n    AP4_ATOM_TYPE_akID,\n    AP4_ATOM_TYPE_aART,\n    AP4_ATOM_TYPE_TVNN,\n    AP4_ATOM_TYPE_TVSH,\n    AP4_ATOM_TYPE_TVEN,\n    AP4_ATOM_TYPE_TVSN,\n    AP4_ATOM_TYPE_TVES,\n    AP4_ATOM_TYPE_STIK,\n    AP4_ATOM_TYPE_PGAP,\n    AP4_ATOM_TYPE_PCST,\n    AP4_ATOM_TYPE_PURD,\n    AP4_ATOM_TYPE_PURL,\n    AP4_ATOM_TYPE_EGID,\n    AP4_ATOM_TYPE_SONM,\n    AP4_ATOM_TYPE_SOAL,\n    AP4_ATOM_TYPE_SOAR,\n    AP4_ATOM_TYPE_SOAA,\n    AP4_ATOM_TYPE_SOCO,\n    AP4_ATOM_TYPE_SOSN\n};\nconst AP4_MetaDataAtomTypeHandler::TypeList AP4_MetaDataAtomTypeHandler::IlstTypeList = {\n    IlstTypes,\n    sizeof(IlstTypes)/sizeof(IlstTypes[0])\n};\n\n/*----------------------------------------------------------------------\n|   AP4_MetaDataAtomTypeHandler::CreateAtom\n+---------------------------------------------------------------------*/\nAP4_Result \nAP4_MetaDataAtomTypeHandler::CreateAtom(AP4_Atom::Type  type,\n                                        AP4_UI32        size,\n                                        AP4_ByteStream& stream,\n                                        AP4_Atom::Type  context,\n                                        AP4_Atom*&      atom)\n{\n    atom = NULL;\n\n    if (context == AP4_ATOM_TYPE_ILST) {\n        if (IsTypeInList(type, IlstTypeList)) {\n            m_AtomFactory->PushContext(type);\n            atom = AP4_ContainerAtom::Create(type, size, false, false, stream, *m_AtomFactory);\n            m_AtomFactory->PopContext();\n        }\n    } else if (type == AP4_ATOM_TYPE_DATA) {\n        if (IsTypeInList(context, IlstTypeList)) {\n            atom = new AP4_DataAtom(size, stream);\n        }\n    } else if (context == AP4_ATOM_TYPE_dddd) {\n        if (type == AP4_ATOM_TYPE_MEAN || type == AP4_ATOM_TYPE_NAME) {\n            atom = new AP4_MetaDataStringAtom(type, size, stream);\n        }\n    } else if (context == AP4_ATOM_TYPE_UDTA) {\n        if (IsTypeInList(type, _3gppLocalizedStringTypeList)) {\n            atom = AP4_3GppLocalizedStringAtom::Create(type, size, stream);\n        } else if (IsTypeInList(type, DcfStringTypeList)) {\n            atom = AP4_DcfStringAtom::Create(type, size, stream);\n        } else if (type == AP4_ATOM_TYPE_DCFD) {\n            atom = AP4_DcfdAtom::Create(size, stream);\n        }\n    }\n\n    return atom?AP4_SUCCESS:AP4_FAILURE;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_MetaDataAtomTypeHandler::IsTypeInList\n+---------------------------------------------------------------------*/\nbool\nAP4_MetaDataAtomTypeHandler::IsTypeInList(AP4_Atom::Type type, const AP4_MetaDataAtomTypeHandler::TypeList& list)\n{\n    for (unsigned int i=0; i<list.m_Size; i++) {\n        if (type == list.m_Types[i]) return true;\n    }\n    return false;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_MetaData::AP4_MetaData\n+---------------------------------------------------------------------*/\nAP4_MetaData::AP4_MetaData(AP4_File* file)\n{\n    // get the file's movie\n    AP4_Movie* movie = file->GetMovie();\n\n    // handle the movie's metadata if there is a movie in the file\n    if (movie) {\n        AP4_MoovAtom* moov = movie->GetMoovAtom();\n        if (moov == NULL) return;\n        ParseMoov(moov);\n        AP4_Atom* udta = moov->GetChild(AP4_ATOM_TYPE_UDTA);\n        if (udta) {\n            AP4_ContainerAtom* udta_container = AP4_DYNAMIC_CAST(AP4_ContainerAtom, udta);\n            if (udta_container) {\n                ParseUdta(udta_container, \"3gpp\");\n            }\n        }\n    } else {\n        // if we don't have a movie, try to show metadata from a udta atom\n        AP4_List<AP4_Atom>& top_level_atoms = file->GetTopLevelAtoms();\n        \n        AP4_List<AP4_Atom>::Item* atom_item = top_level_atoms.FirstItem();\n        while (atom_item) {\n            AP4_ContainerAtom* container = AP4_DYNAMIC_CAST(AP4_ContainerAtom, atom_item->GetData());\n            if (container) {\n                // look for a udta in a DCF layout\n                AP4_Atom* udta = container->FindChild(\"odhe/udta\");\n                if (udta) {\n                    AP4_ContainerAtom* udta_container = AP4_DYNAMIC_CAST(AP4_ContainerAtom, udta);\n                    if (udta_container) {\n                        ParseUdta(udta_container, \"dcf\");\n                    }\n                }\n            }\n            atom_item = atom_item->GetNext();\n        }\n    } \n}\n\n/*----------------------------------------------------------------------\n|   AP4_MetaData::ParseMoov\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_MetaData::ParseMoov(AP4_MoovAtom* moov)\n{\n    // look for a 'meta' atom with 'hdlr' type 'mdir'\n    AP4_HdlrAtom* hdlr = AP4_DYNAMIC_CAST(AP4_HdlrAtom, moov->FindChild(\"udta/meta/hdlr\"));\n    if (hdlr == NULL || hdlr->GetHandlerType() != AP4_HANDLER_TYPE_MDIR) return AP4_ERROR_NO_SUCH_ITEM;\n\n    // get the list of entries\n    AP4_ContainerAtom* ilst = AP4_DYNAMIC_CAST(AP4_ContainerAtom, moov->FindChild(\"udta/meta/ilst\"));\n    if (ilst == NULL) return AP4_ERROR_NO_SUCH_ITEM;\n    \n    AP4_List<AP4_Atom>::Item* ilst_item = ilst->GetChildren().FirstItem();\n    while (ilst_item) {\n        AP4_ContainerAtom* entry_atom = AP4_DYNAMIC_CAST(AP4_ContainerAtom, ilst_item->GetData()); \n        if (entry_atom) {\n            AddIlstEntries(entry_atom, \"meta\");\n        }\n        ilst_item = ilst_item->GetNext();\n    }\n    \n    return AP4_SUCCESS;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_MetaData::ParseUdta\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_MetaData::ParseUdta(AP4_ContainerAtom* udta, const char* namespc)\n{\n    // check that the atom is indeed a 'udta' atom\n    if (udta->GetType() != AP4_ATOM_TYPE_UDTA) {\n        return AP4_ERROR_INVALID_PARAMETERS;\n    }\n    \n    AP4_List<AP4_Atom>::Item* udta_item = udta->GetChildren().FirstItem();\n    for (; udta_item; udta_item = udta_item->GetNext()) {\n        AP4_3GppLocalizedStringAtom* _3gpp_atom = AP4_DYNAMIC_CAST(AP4_3GppLocalizedStringAtom, udta_item->GetData()); \n        if (_3gpp_atom) {\n            Add3GppEntry(_3gpp_atom, namespc);\n            continue;\n        } \n        \n        AP4_DcfStringAtom* dcfs_atom = AP4_DYNAMIC_CAST(AP4_DcfStringAtom, udta_item->GetData());\n        if (dcfs_atom) {\n            AddDcfStringEntry(dcfs_atom, namespc);\n            continue;\n        } \n\n        AP4_DcfdAtom* dcfd_atom = AP4_DYNAMIC_CAST(AP4_DcfdAtom, udta_item->GetData());\n        if (dcfd_atom) {\n            AddDcfdEntry(dcfd_atom, namespc);\n        }\n    }\n    \n    return AP4_SUCCESS;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_MetaData::~AP4_MetaData\n+---------------------------------------------------------------------*/\nAP4_MetaData::~AP4_MetaData()\n{\n    m_Entries.DeleteReferences();\n}\n\n/*----------------------------------------------------------------------\n|   AP4_MetaData::ResolveKeyName\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_MetaData::ResolveKeyName(AP4_Atom::Type atom_type, AP4_String& value)\n{\n    const char* key_name = NULL;\n    char        four_cc[5];\n\n    // look for a match in the key infos\n    for (unsigned int i=0; \n         i<sizeof(AP4_MetaData_KeyInfos)/sizeof(AP4_MetaData_KeyInfos[0]); \n         i++) {\n        if (AP4_MetaData_KeyInfos[i].four_cc == atom_type) {\n            key_name = AP4_MetaData_KeyInfos[i].name;\n            break;\n        }\n    }\n    if (key_name == NULL) {\n        // this key was not found in the key infos, create a name for it\n        AP4_FormatFourChars(four_cc, (AP4_UI32)atom_type);\n        key_name = four_cc;\n    }\n    value = key_name;\n    \n    return AP4_SUCCESS;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_MetaData::AddIlstEntries\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_MetaData::AddIlstEntries(AP4_ContainerAtom* atom, const char* namespc)\n{\n    AP4_MetaData::Value* value = NULL;\n\n    if (atom->GetType() == AP4_ATOM_TYPE_dddd) {\n        // look for the namespace\n        AP4_MetaDataStringAtom* mean = static_cast<AP4_MetaDataStringAtom*>(atom->GetChild(AP4_ATOM_TYPE_MEAN));\n        if (mean == NULL) return AP4_ERROR_INVALID_FORMAT;\n\n        // look for the name\n        AP4_MetaDataStringAtom* name = static_cast<AP4_MetaDataStringAtom*>(atom->GetChild(AP4_ATOM_TYPE_NAME));\n        if (name == NULL) return AP4_ERROR_INVALID_FORMAT;\n\n        // get the value\n        AP4_DataAtom* data_atom = static_cast<AP4_DataAtom*>(atom->GetChild(AP4_ATOM_TYPE_DATA));\n        if (data_atom == NULL) return AP4_ERROR_INVALID_FORMAT;\n        value = new AP4_AtomMetaDataValue(data_atom, atom->GetType());\n        \n        return m_Entries.Add(new Entry(name->GetValue().GetChars(),\n                                       mean->GetValue().GetChars(),\n                                       value));\n    } else {\n        const char* key_name = NULL;\n        char        four_cc[5];\n\n        // convert the atom type to a name\n        AP4_FormatFourChars(four_cc, (AP4_UI32)atom->GetType());\n        key_name = four_cc;\n\n        // add one entry for each data atom\n        AP4_List<AP4_Atom>::Item* data_item = atom->GetChildren().FirstItem();\n        while (data_item) {\n            AP4_Atom* item_atom = data_item->GetData();\n            if (item_atom->GetType() == AP4_ATOM_TYPE_DATA) {\n                AP4_DataAtom* data_atom = static_cast<AP4_DataAtom*>(item_atom);\n                value = new AP4_AtomMetaDataValue(data_atom, atom->GetType());\n                m_Entries.Add(new Entry(key_name, namespc, value));\n            }\n            data_item = data_item->GetNext();\n        }\n\n        return AP4_SUCCESS;\n    }\n}\n\n/*----------------------------------------------------------------------\n|   AP4_MetaData::Add3GppEntry\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_MetaData::Add3GppEntry(AP4_3GppLocalizedStringAtom* atom, const char* namespc)\n{\n    AP4_String key_name;\n    ResolveKeyName(atom->GetType(), key_name);\n    \n    const char* language = NULL;\n    if (atom->GetLanguage()[0]) {\n        language = atom->GetLanguage();\n    }\n    AP4_MetaData::Value* value = new AP4_StringMetaDataValue(atom->GetValue().GetChars(),\n                                                             language);\n    m_Entries.Add(new Entry(key_name.GetChars(), namespc, value));\n    \n    return AP4_SUCCESS;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_MetaData::AddDcfStringEntry\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_MetaData::AddDcfStringEntry(AP4_DcfStringAtom* atom, const char* namespc)\n{\n    AP4_String key_name;\n    ResolveKeyName(atom->GetType(), key_name);\n    \n    AP4_MetaData::Value* value = new AP4_StringMetaDataValue(atom->GetValue().GetChars());\n    m_Entries.Add(new Entry(key_name.GetChars(), namespc, value));\n    \n    return AP4_SUCCESS;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_MetaData::AddDcfdEntry\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_MetaData::AddDcfdEntry(AP4_DcfdAtom* atom, const char* namespc)\n{\n    AP4_String key_name;\n    ResolveKeyName(atom->GetType(), key_name);\n    \n    AP4_MetaData::Value* value = new AP4_IntegerMetaDataValue(AP4_MetaData::Value::TYPE_INT_32_BE, \n                                                              atom->GetDuration());\n    m_Entries.Add(new Entry(key_name.GetChars(), namespc, value));\n    \n    return AP4_SUCCESS;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_MetaData::Value::MapDataTypeToCategory\n+---------------------------------------------------------------------*/\nAP4_MetaData::Value::TypeCategory \nAP4_MetaData::Value::MapTypeToCategory(Type type)\n{\n    switch (type) {\n        case AP4_MetaData::Value::TYPE_INT_08_BE:\n        case AP4_MetaData::Value::TYPE_INT_16_BE:\n        case AP4_MetaData::Value::TYPE_INT_32_BE:\n            return AP4_MetaData::Value::TYPE_CATEGORY_INTEGER;\n\n        case AP4_MetaData::Value::TYPE_STRING_UTF_8:\n        case AP4_MetaData::Value::TYPE_STRING_UTF_16:\n        case AP4_MetaData::Value::TYPE_STRING_PASCAL:\n            return AP4_MetaData::Value::TYPE_CATEGORY_STRING;\n\n        case AP4_MetaData::Value::TYPE_FLOAT_32_BE:\n        case AP4_MetaData::Value::TYPE_FLOAT_64_BE:\n            return AP4_MetaData::Value::TYPE_CATEGORY_FLOAT;\n            \n        default:\n            return AP4_MetaData::Value::TYPE_CATEGORY_BINARY;\n    }\n}\n\n/*----------------------------------------------------------------------\n|   AP4_MetaData::Value::GetTypeCategory\n+---------------------------------------------------------------------*/\nAP4_MetaData::Value::TypeCategory \nAP4_MetaData::Value::GetTypeCategory() const\n{\n    return MapTypeToCategory(m_Type);\n}\n\n/*----------------------------------------------------------------------\n|   AP4_MetaData::Entry::ToAtom\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_MetaData::Entry::ToAtom(AP4_Atom*& atom) const\n{\n    atom = NULL;\n    \n    if (m_Value == NULL) {\n        return AP4_ERROR_INVALID_PARAMETERS;\n    }\n    \n    if (m_Key.GetNamespace() == \"meta\") {\n        // convert the name into an atom type\n        if (m_Key.GetName().GetLength() != 4) {\n            // the name is not in the right format\n            return AP4_ERROR_INVALID_PARAMETERS;\n        }\n        AP4_Atom::Type atom_type = AP4_Atom::TypeFromString(m_Key.GetName().GetChars()); \n                                   \n        // create a container atom for the data\n        AP4_ContainerAtom* container = new AP4_ContainerAtom(atom_type);\n\n        // add the data atom\n        AP4_DataAtom* data = new AP4_DataAtom(*m_Value);\n        container->AddChild(data);\n        \n        atom = container;\n        return AP4_SUCCESS;\n    } else if (m_Key.GetNamespace() == \"dcf\") {\n        // convert the name into an atom type\n        if (m_Key.GetName().GetLength() != 4) {\n            // the name is not in the right format\n            return AP4_ERROR_INVALID_PARAMETERS;\n        }\n        AP4_Atom::Type atom_type = AP4_Atom::TypeFromString(m_Key.GetName().GetChars()); \n\n        if (AP4_MetaDataAtomTypeHandler::IsTypeInList(atom_type, \n            AP4_MetaDataAtomTypeHandler::DcfStringTypeList)) {\n            AP4_String atom_value = m_Value->ToString();\n            atom = new AP4_DcfStringAtom(atom_type, atom_value.GetChars());\n            return AP4_SUCCESS;\n        } else if (AP4_MetaDataAtomTypeHandler::IsTypeInList(atom_type, \n                   AP4_MetaDataAtomTypeHandler::_3gppLocalizedStringTypeList)) {\n            AP4_String atom_value = m_Value->ToString();\n            const char* language = \"eng\"; // default\n            if (m_Value->GetLanguage().GetLength() != 0) {\n                language = m_Value->GetLanguage().GetChars();\n            }\n            atom = new AP4_3GppLocalizedStringAtom(atom_type, language, atom_value.GetChars());\n            return AP4_SUCCESS;\n        } else if (atom_type == AP4_ATOM_TYPE_DCFD) {\n            atom = new AP4_DcfdAtom((AP4_UI32)m_Value->ToInteger());\n            return AP4_SUCCESS;\n        }\n        \n         // not supported\n         return AP4_ERROR_NOT_SUPPORTED; \n    } else {\n        // create a '----' atom\n        AP4_ContainerAtom* container = new AP4_ContainerAtom(AP4_ATOM_TYPE_dddd);\n        \n        // add a 'mean' string\n        container->AddChild(new AP4_MetaDataStringAtom(AP4_ATOM_TYPE_MEAN, m_Key.GetNamespace().GetChars()));\n        \n        // add a 'name' string\n        container->AddChild(new AP4_MetaDataStringAtom(AP4_ATOM_TYPE_NAME, m_Key.GetName().GetChars()));\n\n        // add the data atom\n        AP4_DataAtom* data = new AP4_DataAtom(*m_Value);\n        container->AddChild(data);\n        \n        atom = container;\n        return AP4_SUCCESS;\n    }\n        \n    // unreachable - return AP4_ERROR_NOT_SUPPORTED;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_MetaData::Entry::FindInIlst\n+---------------------------------------------------------------------*/\nAP4_ContainerAtom*\nAP4_MetaData::Entry::FindInIlst(AP4_ContainerAtom* ilst) const\n{\n    if (m_Key.GetNamespace() == \"meta\") {\n        AP4_Atom::Type atom_type = AP4_Atom::TypeFromString(m_Key.GetName().GetChars());\n        return AP4_DYNAMIC_CAST(AP4_ContainerAtom, ilst->GetChild(atom_type));\n    } else {\n        AP4_List<AP4_Atom>::Item* ilst_item = ilst->GetChildren().FirstItem();\n        while (ilst_item) {\n            AP4_ContainerAtom* entry_atom = AP4_DYNAMIC_CAST(AP4_ContainerAtom, ilst_item->GetData()); \n            if (entry_atom) {\n                AP4_MetaDataStringAtom* mean = static_cast<AP4_MetaDataStringAtom*>(entry_atom->GetChild(AP4_ATOM_TYPE_MEAN));\n                AP4_MetaDataStringAtom* name = static_cast<AP4_MetaDataStringAtom*>(entry_atom->GetChild(AP4_ATOM_TYPE_NAME));\n                if (mean && name &&\n                    mean->GetValue() == m_Key.GetNamespace() &&\n                    name->GetValue() == m_Key.GetName()) {\n                    return entry_atom;\n                }\n            }\n            ilst_item = ilst_item->GetNext();\n        }\n    }\n    \n    // not found\n    return NULL;\n}\n    \n/*----------------------------------------------------------------------\n|   AP4_MetaData::Entry::AddToFileIlst\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_MetaData::Entry::AddToFileIlst(AP4_File& file, AP4_Ordinal index)\n{\n    // check that we have a correct entry\n    if (m_Value == NULL) return AP4_ERROR_INVALID_STATE;\n\n    // convert the entry into an atom\n    AP4_Atom* atom;\n    AP4_Result result = ToAtom(atom);\n    if (AP4_FAILED(result)) return result;\n    AP4_ContainerAtom* entry_atom = AP4_DYNAMIC_CAST(AP4_ContainerAtom, atom);\n    if (entry_atom == NULL) {\n        return AP4_ERROR_INVALID_FORMAT;\n    }\n\n    // look for the 'moov'\n    AP4_Movie* movie = file.GetMovie();\n    if (movie == NULL) return AP4_ERROR_INVALID_FORMAT;\n    AP4_MoovAtom* moov = movie->GetMoovAtom();\n    if (moov == NULL) return AP4_ERROR_INVALID_FORMAT;\n    \n    // look for 'udta', and create if it does not exist \n    AP4_ContainerAtom* udta = AP4_DYNAMIC_CAST(AP4_ContainerAtom, moov->FindChild(\"udta\", true));\n    if (udta == NULL) return AP4_ERROR_INTERNAL;\n    \n    // look for 'meta', and create if it does not exist ('meta' is a FULL atom)\n    AP4_ContainerAtom* meta = AP4_DYNAMIC_CAST(AP4_ContainerAtom, udta->FindChild(\"meta\", true, true));\n    if (meta == NULL) return AP4_ERROR_INTERNAL;\n\n    // look for a 'hdlr' atom type 'mdir'\n    AP4_HdlrAtom* hdlr = AP4_DYNAMIC_CAST(AP4_HdlrAtom, meta->FindChild(\"hdlr\"));\n    if (hdlr == NULL) {\n        hdlr = new AP4_HdlrAtom(AP4_HANDLER_TYPE_MDIR, \"\");\n        meta->AddChild(hdlr);\n    } else {\n        if (hdlr->GetHandlerType() != AP4_HANDLER_TYPE_MDIR) {\n            return AP4_ERROR_INVALID_FORMAT;\n        }\n    }\n\n    // get/create the list of entries\n    AP4_ContainerAtom* ilst = AP4_DYNAMIC_CAST(AP4_ContainerAtom, meta->FindChild(\"ilst\", true));\n    if (ilst == NULL) return AP4_ERROR_INTERNAL;\n    \n    // look if there is already a container for this entry\n    AP4_ContainerAtom* existing = FindInIlst(ilst);\n    if (existing == NULL) {\n        // just add the one we have\n        ilst->AddChild(entry_atom);\n    } else {\n        // add the entry's data to the existing entry\n        AP4_DataAtom* data_atom = AP4_DYNAMIC_CAST(AP4_DataAtom, entry_atom->GetChild(AP4_ATOM_TYPE_DATA));\n        if (data_atom == NULL) return AP4_ERROR_INTERNAL;\n        entry_atom->RemoveChild(data_atom);\n        existing->AddChild(data_atom, index);\n        delete entry_atom;\n    }\n    \n    return AP4_SUCCESS;    \n}\n\n/*----------------------------------------------------------------------\n|   AP4_MetaData::Entry::AddToFileDcf\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_MetaData::Entry::AddToFileDcf(AP4_File& file, AP4_Ordinal index)\n{\n    // check that we have a correct entry\n    if (m_Value == NULL) return AP4_ERROR_INVALID_STATE;\n    \n    // look for 'odrm/odhe'\n    AP4_ContainerAtom* odhe = AP4_DYNAMIC_CAST(AP4_ContainerAtom, file.FindChild(\"odrm/odhe\"));\n    if (odhe == NULL) return AP4_ERROR_NO_SUCH_ITEM;\n\n    // get/create the list of entries\n    AP4_ContainerAtom* udta = AP4_DYNAMIC_CAST(AP4_ContainerAtom, odhe->FindChild(\"udta\", true));\n    if (udta == NULL) return AP4_ERROR_INTERNAL;\n    \n    // convert the entry into an atom\n    AP4_Atom* data_atom;\n    AP4_Result result = ToAtom(data_atom);\n    if (AP4_FAILED(result)) return result;\n\n    // add the entry's data to the container\n    return udta->AddChild(data_atom, index);\n}\n\n/*----------------------------------------------------------------------\n|   AP4_MetaData::Entry::AddToFile\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_MetaData::Entry::AddToFile(AP4_File& file, AP4_Ordinal index)\n{\n    // check that we have a correct entry\n    if (m_Value == NULL) return AP4_ERROR_INVALID_STATE;\n \n    // check the namespace of the key to know where to add the atom\n    if (m_Key.GetNamespace() == \"meta\") {\n        return AddToFileIlst(file, index);\n    } else if (m_Key.GetNamespace() == \"dcf\") {\n        return AddToFileDcf(file, index);\n    } else {\n        // custom namespace\n        return AddToFileIlst(file, index);\n    }\n}\n\n/*----------------------------------------------------------------------\n|   AP4_MetaData::Entry::RemoveFromFileIlst\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_MetaData::Entry::RemoveFromFileIlst(AP4_File& file, AP4_Ordinal index)\n{\n    // look for the 'moov'\n    AP4_Movie* movie = file.GetMovie();\n    if (movie == NULL) return AP4_ERROR_INVALID_FORMAT;\n    AP4_MoovAtom* moov = movie->GetMoovAtom();\n    if (moov == NULL) return AP4_ERROR_INVALID_FORMAT;\n    \n    // look for 'udta/meta/ilst'\n    AP4_ContainerAtom* ilst = AP4_DYNAMIC_CAST(AP4_ContainerAtom, moov->FindChild(\"udta/meta/ilst\"));\n    if (ilst == NULL) return AP4_ERROR_NO_SUCH_ITEM;\n    \n    // look if there is already a container for this entry\n    AP4_ContainerAtom* existing = FindInIlst(ilst);\n    if (existing == NULL) return AP4_ERROR_NO_SUCH_ITEM;\n            \n    // remove the data atom in the entry\n    AP4_Result result = existing->DeleteChild(AP4_ATOM_TYPE_DATA, index);\n    if (AP4_FAILED(result)) return result;\n\n    // cleanup\n    if (existing->GetType() == AP4_ATOM_TYPE_dddd) {\n        // custom entry: if there are no more 'data' children, remove the entry\n        if (existing->GetChild(AP4_ATOM_TYPE_DATA) == NULL) {\n            ilst->RemoveChild(existing);\n            delete existing;\n        }\n    } else {\n        // normal entry: if the entry is empty, remove it\n        if (existing->GetChildren().ItemCount() == 0) {\n            ilst->RemoveChild(existing);\n            delete existing;\n        }\n    }\n    \n    return AP4_SUCCESS;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_MetaData::Entry::RemoveFromFileDcf\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_MetaData::Entry::RemoveFromFileDcf(AP4_File& file, AP4_Ordinal index)\n{\n    // look for 'odrm/odhe/udta'\n    AP4_ContainerAtom* udta = AP4_DYNAMIC_CAST(AP4_ContainerAtom, file.FindChild(\"odrm/odhe/udta\"));\n    if (udta == NULL) return AP4_ERROR_NO_SUCH_ITEM;\n                \n    // remove the data atom in the entry\n    AP4_UI32 type = AP4_BytesToUInt32BE((const unsigned char*)m_Key.GetName().GetChars());\n    AP4_Result result = udta->DeleteChild(type, index);\n    if (AP4_FAILED(result)) return result;\n    \n    return AP4_SUCCESS;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_MetaData::Entry::RemoveFromFile\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_MetaData::Entry::RemoveFromFile(AP4_File& file, AP4_Ordinal index)\n{\n    // check the namespace of the key to know where to add the atom\n    if (m_Key.GetNamespace() == \"meta\") {\n        return RemoveFromFileIlst(file, index);\n    } else if (m_Key.GetNamespace() == \"dcf\") {\n        return RemoveFromFileDcf(file, index);\n    } else {\n        // custom namespace\n        return RemoveFromFileIlst(file, index);\n    }\n}\n\n/*----------------------------------------------------------------------\n|   AP4_StringMetaDataValue::ToString\n+---------------------------------------------------------------------*/\nAP4_String\nAP4_StringMetaDataValue::ToString() const\n{\n    return m_Value;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_StringMetaDataValue::ToBytes\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_StringMetaDataValue::ToBytes(AP4_DataBuffer& /* bytes */) const\n{\n    return AP4_ERROR_NOT_SUPPORTED;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_StringMetaDataValue::ToInteger\n+---------------------------------------------------------------------*/\nlong\nAP4_StringMetaDataValue::ToInteger() const\n{\n    return 0;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_IntegerMetaDataValue::ToString\n+---------------------------------------------------------------------*/\nAP4_String\nAP4_IntegerMetaDataValue::ToString() const\n{\n    char value[16];\n    AP4_FormatString(value, sizeof(value), \"%ld\", m_Value);\n    return AP4_String(value);\n}\n\n/*----------------------------------------------------------------------\n|   AP4_IntegerMetaDataValue::ToBytes\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_IntegerMetaDataValue::ToBytes(AP4_DataBuffer& /* bytes */) const\n{\n    return AP4_ERROR_NOT_SUPPORTED;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_IntegerMetaDataValue::ToInteger\n+---------------------------------------------------------------------*/\nlong\nAP4_IntegerMetaDataValue::ToInteger() const\n{\n    return m_Value;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_BinaryMetaDataValue::ToString\n+---------------------------------------------------------------------*/\nAP4_String\nAP4_BinaryMetaDataValue::ToString() const\n{\n    return AP4_String(); // not supported\n}\n\n/*----------------------------------------------------------------------\n|   AP4_BinaryMetaDataValue::ToBytes\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_BinaryMetaDataValue::ToBytes(AP4_DataBuffer& bytes) const\n{\n    bytes.SetDataSize(m_Value.GetDataSize());\n    AP4_CopyMemory(bytes.UseData(), m_Value.GetData(), m_Value.GetDataSize());\n    return AP4_SUCCESS;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_BinaryMetaDataValue::ToInteger\n+---------------------------------------------------------------------*/\nlong\nAP4_BinaryMetaDataValue::ToInteger() const\n{\n    return 0; // NOT SUPPORTED\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AtomMetaDataValue::AP4_AtomMetaDataValue\n+---------------------------------------------------------------------*/\nAP4_AtomMetaDataValue::AP4_AtomMetaDataValue(AP4_DataAtom*  atom,\n                                             AP4_UI32       parent_type) :\n    Value(atom->GetValueType()),\n    m_DataAtom(atom)\n{\n    switch (parent_type) {\n        case AP4_ATOM_TYPE_GNRE:\n            m_Meaning = MEANING_ID3_GENRE;\n            break;\n\n        case AP4_ATOM_TYPE_CPIL:\n            m_Meaning = MEANING_BOOLEAN;\n            break;\n\n        case AP4_ATOM_TYPE_PGAP:\n        case AP4_ATOM_TYPE_PCST:\n            m_Meaning = MEANING_BOOLEAN;\n            break;\n\n        case AP4_ATOM_TYPE_STIK:\n            m_Meaning = MEANING_FILE_KIND;\n            break;\n\n        case AP4_ATOM_TYPE_PURL:\n        case AP4_ATOM_TYPE_EGID:\n            m_Meaning = MEANING_BINARY_ENCODED_CHARS;\n            break;\n            \n        default:\n            break;\n    }\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AtomMetaDataValue::ToString\n+---------------------------------------------------------------------*/\nAP4_String \nAP4_AtomMetaDataValue::ToString() const\n{\n    char string[256] = \"\";\n\n    AP4_MetaData::Value::Type value_type = m_DataAtom->GetValueType();\n    switch (AP4_MetaData::Value::MapTypeToCategory(value_type)) {\n        case AP4_MetaData::Value::TYPE_CATEGORY_INTEGER: \n            {\n                long value;\n                if (AP4_SUCCEEDED(m_DataAtom->LoadInteger(value))) {\n                    if (m_Meaning == MEANING_BOOLEAN) {\n                        if (value) {\n                            return \"True\";\n                        } else {\n                            return \"False\";\n                        }\n                    } else if (m_Meaning == MEANING_FILE_KIND) {\n                        if (value >= 0 && ((unsigned int)value) <= sizeof(Ap4StikNames)/sizeof(Ap4StikNames[0])) {\n                            AP4_FormatString(string, sizeof(string), \"(%ld) %s\", value, Ap4StikNames[value]);\n                        } else {\n                            return \"Unknown\";\n                        }\n                    } else {\n                        AP4_FormatString(string, sizeof(string), \"%ld\", value);\n                    }\n                }\n                return AP4_String((const char*)string);\n                break;\n            }\n\n        case AP4_MetaData::Value::TYPE_CATEGORY_STRING:\n            {\n                AP4_String* category_string;\n                if (AP4_SUCCEEDED(m_DataAtom->LoadString(category_string))) {\n                    AP4_String result(*category_string);\n                    delete category_string;\n                    return result;\n                }\n                break;\n            }\n\n        case AP4_MetaData::Value::TYPE_CATEGORY_BINARY:\n            {\n                AP4_DataBuffer data;\n                if (AP4_SUCCEEDED(m_DataAtom->LoadBytes(data))) {\n                    if (m_Meaning == MEANING_ID3_GENRE && data.GetDataSize() == 2) {\n                        unsigned int genre = (data.GetData()[0])*256+data.GetData()[1];\n                        if (genre >= 1 && genre <= sizeof(Ap4Id3Genres)/sizeof(Ap4Id3Genres[0])) {\n                            AP4_FormatString(string, sizeof(string), \"(%d) %s\", genre, Ap4Id3Genres[genre-1]);\n                            return AP4_String((const char*)string);\n                        } else {\n                            return \"Unknown\";\n                        }\n                    } else if (m_Meaning == MEANING_BINARY_ENCODED_CHARS) {\n                        AP4_String result;\n                        result.Assign((const char*)data.GetData(), data.GetDataSize());\n                        return result;\n                    } else {\n                        unsigned int dump_length = data.GetDataSize();\n                        bool truncate = false;\n                        if (dump_length > 16) {\n                            dump_length = 16;\n                            truncate = true;\n                        }\n                        char* out = string;\n                        for (unsigned int i=0; i<dump_length; i++) {\n                            AP4_FormatString(out, sizeof(string)-(out-string), \"%02x \", data.GetData()[i]);\n                            out += 3;\n                        }\n                        if (truncate) {\n                            *out++='.'; *out++='.'; *out++='.'; *out++=' ';\n                        }\n                        AP4_FormatString(out, sizeof(string)-(out-string), \"[%d bytes]\", (int)data.GetDataSize());\n                    }\n                }\n                return AP4_String(string);\n            }\n        default:\n            return AP4_String();\n    }\n\n    return AP4_String();\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AtomMetaDataValue::ToBytes\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_AtomMetaDataValue::ToBytes(AP4_DataBuffer& bytes) const\n{\n    return m_DataAtom->LoadBytes(bytes);\n}\n\n/*----------------------------------------------------------------------\n|   AP4_AtomMetaDataValue::ToInteger\n+---------------------------------------------------------------------*/\nlong       \nAP4_AtomMetaDataValue::ToInteger() const\n{\n    long value;\n    if (AP4_SUCCEEDED(m_DataAtom->LoadInteger(value))) {\n        return value;\n    } else {\n        return 0;\n    }\n}\n\n/*----------------------------------------------------------------------\n|   AP4_DataAtom::AP4_DataAtom\n+---------------------------------------------------------------------*/\nAP4_DataAtom::AP4_DataAtom(const AP4_MetaData::Value& value) :\n    AP4_Atom(AP4_ATOM_TYPE_DATA, AP4_ATOM_HEADER_SIZE),\n    m_DataType(DATA_TYPE_BINARY),\n    m_Source(NULL)\n{\n    AP4_MemoryByteStream* memory = new AP4_MemoryByteStream();\n    AP4_Size payload_size = 8;\n    m_Source = memory;\n    \n    switch (value.GetType()) {\n        case AP4_MetaData::Value::TYPE_STRING_UTF_8: {\n            m_DataType = DATA_TYPE_STRING_UTF_8;\n            AP4_String string_value = value.ToString();\n            if (string_value.GetLength()) {\n                memory->Write(string_value.GetChars(), string_value.GetLength());\n            }\n            payload_size += string_value.GetLength();\n            break;\n        }\n         \n        case AP4_MetaData::Value::TYPE_INT_08_BE: {\n            m_DataType = DATA_TYPE_SIGNED_INT_BE;\n            AP4_UI08 int_value = (AP4_UI08)value.ToInteger();\n            memory->Write(&int_value, 1);\n            payload_size += 1;\n            break;\n        }\n            \n        case AP4_MetaData::Value::TYPE_INT_16_BE: {\n            m_DataType = DATA_TYPE_SIGNED_INT_BE;\n            AP4_UI16 int_value = (AP4_UI16)value.ToInteger();\n            memory->Write(&int_value, 2);\n            payload_size += 2;\n            break;\n        }\n\n        case AP4_MetaData::Value::TYPE_INT_32_BE: {\n            m_DataType = DATA_TYPE_SIGNED_INT_BE;\n            AP4_UI32 int_value = (AP4_UI32)value.ToInteger();\n            memory->Write(&int_value, 4);\n            payload_size += 4;\n            break;\n        }\n\n        case AP4_MetaData::Value::TYPE_JPEG:\n            m_DataType = DATA_TYPE_JPEG;\n            // FALLTHROUGH\n        case AP4_MetaData::Value::TYPE_GIF: \n            if (m_DataType == DATA_TYPE_BINARY) m_DataType = DATA_TYPE_GIF;\n            // FALLTHROUGH\n        case AP4_MetaData::Value::TYPE_BINARY: {\n            AP4_DataBuffer buffer;\n            value.ToBytes(buffer);\n            if (buffer.GetDataSize()) {\n                memory->Write(buffer.GetData(), buffer.GetDataSize());\n            }\n            payload_size += buffer.GetDataSize();\n            break;\n        }\n\n        default:\n            break;\n    }\n    \n    const AP4_String& language = value.GetLanguage();\n    if (language == \"en\") {\n        m_DataLang = LANGUAGE_ENGLISH;\n    } else {\n        // default\n        m_DataLang = LANGUAGE_ENGLISH;\n    }\n    \n    m_Size32 += payload_size;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_DataAtom::AP4_DataAtom\n+---------------------------------------------------------------------*/\nAP4_DataAtom::AP4_DataAtom(AP4_UI32 size, AP4_ByteStream& stream) :\n    AP4_Atom(AP4_ATOM_TYPE_DATA, size),\n    m_Source(NULL)\n{\n    if (size < AP4_ATOM_HEADER_SIZE+8) return;\n\n    AP4_UI32 i;\n    stream.ReadUI32(i); m_DataType = (DataType)i;\n    stream.ReadUI32(i); m_DataLang = (DataLang)i;\n\n    // the stream for the data is a substream of this source\n    AP4_Position data_offset;\n    stream.Tell(data_offset);\n    AP4_Size data_size = size-AP4_ATOM_HEADER_SIZE-8;\n    m_Source = new AP4_SubStream(stream, data_offset, data_size);\n}\n\n/*----------------------------------------------------------------------\n|   AP4_DataAtom::~AP4_DataAtom\n+---------------------------------------------------------------------*/\nAP4_DataAtom::~AP4_DataAtom()\n{\n    delete(m_Source);\n}\n\n/*----------------------------------------------------------------------\n|   AP4_DataAtom::GetValueType\n+---------------------------------------------------------------------*/\nAP4_MetaData::Value::Type\nAP4_DataAtom::GetValueType()\n{\n    switch (m_DataType) {\n        case DATA_TYPE_BINARY:\n            return AP4_MetaData::Value::TYPE_BINARY;\n\n        case DATA_TYPE_SIGNED_INT_BE:\n            switch (m_Size32-16) {\n                case 1: return AP4_MetaData::Value::TYPE_INT_08_BE;\n                case 2: return AP4_MetaData::Value::TYPE_INT_16_BE;\n                case 4: return AP4_MetaData::Value::TYPE_INT_32_BE;\n                default: return AP4_MetaData::Value::TYPE_BINARY;\n            }\n            break;\n            \n        case DATA_TYPE_STRING_UTF_8:\n            return AP4_MetaData::Value::TYPE_STRING_UTF_8;\n            \n        case DATA_TYPE_STRING_UTF_16:\n            return AP4_MetaData::Value::TYPE_STRING_UTF_16;\n            \n        case DATA_TYPE_STRING_PASCAL:\n            return AP4_MetaData::Value::TYPE_STRING_PASCAL;\n\n        case DATA_TYPE_GIF:\n            return AP4_MetaData::Value::TYPE_GIF;\n\n        case DATA_TYPE_JPEG:\n            return AP4_MetaData::Value::TYPE_JPEG;\n\n        default:\n            return AP4_MetaData::Value::TYPE_BINARY;\n    }\n    \n    // unreachable - return AP4_MetaData::Value::TYPE_BINARY;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_DataAtom::WriteFields\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_DataAtom::WriteFields(AP4_ByteStream& stream)\n{\n    stream.WriteUI32(m_DataType);\n    stream.WriteUI32(m_DataLang);\n    if (m_Source) {\n        AP4_LargeSize size = 0;\n        m_Source->GetSize(size);\n        m_Source->Seek(0);\n        m_Source->CopyTo(stream, size);\n    }\n\n    return AP4_SUCCESS;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_DataAtom::InspectFields\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_DataAtom::InspectFields(AP4_AtomInspector& inspector)\n{\n    inspector.AddField(\"type\", m_DataType);\n    inspector.AddField(\"lang\", m_DataLang);\n    if (m_DataType == DATA_TYPE_STRING_UTF_8) {\n        AP4_String* str;\n        if (AP4_SUCCEEDED(LoadString(str))) {\n            inspector.AddField(\"value\", str->GetChars());\n            delete str;\n        }\n    } else if (m_DataType == DATA_TYPE_SIGNED_INT_BE) {\n        long value;\n        if (AP4_SUCCEEDED(LoadInteger(value))) {\n            inspector.AddField(\"value\", value);\n        }\n    }\n\n    return AP4_SUCCESS;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_DataAtom::LoadString\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_DataAtom::LoadString(AP4_String*& string)\n{\n    if (m_Source == NULL) {\n        string = new AP4_String();\n        return AP4_SUCCESS;\n    } else {\n        // create a string with enough capactiy for the data\n        AP4_LargeSize size = 0;\n        m_Source->GetSize(size);\n        if (size > AP4_DATA_ATOM_MAX_SIZE) return AP4_ERROR_OUT_OF_RANGE;\n        string = new AP4_String((AP4_Size)size);\n\n        // read from the start of the stream\n        m_Source->Seek(0);\n        AP4_Result result = m_Source->Read(string->UseChars(), (AP4_Size)size);\n        if (AP4_FAILED(result)) {\n            delete string;\n            string = NULL;\n        }\n\n        return result;\n    }\n}\n\n/*----------------------------------------------------------------------\n|   AP4_DataAtom::LoadBytes\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_DataAtom::LoadBytes(AP4_DataBuffer& bytes)\n{\n    if (m_Source == NULL) {\n        bytes.SetDataSize(0);\n        return AP4_SUCCESS;\n    }\n    AP4_LargeSize size = 0;\n    m_Source->GetSize(size);\n    if (size > AP4_DATA_ATOM_MAX_SIZE) return AP4_ERROR_OUT_OF_RANGE;\n    bytes.SetDataSize((AP4_Size)size);\n    m_Source->Seek(0);\n    AP4_Result result = m_Source->Read(bytes.UseData(), (AP4_Size)size);\n    if (AP4_FAILED(result)) {\n        bytes.SetDataSize(0);\n    }\n    return result;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_DataAtom::LoadInteger\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_DataAtom::LoadInteger(long& value) \n{\n    AP4_Result result = AP4_FAILURE;\n    value = 0;\n    if (m_Source == NULL) return AP4_SUCCESS;\n    AP4_LargeSize size = 0;\n    m_Source->GetSize(size);\n    if (size > 4) {\n        return AP4_ERROR_OUT_OF_RANGE;\n    }\n    unsigned char bytes[4];\n    m_Source->Seek(0);\n    m_Source->Read(bytes, (AP4_Size)size);\n    result = AP4_SUCCESS;\n    switch (size) {\n        case 1: value = bytes[0]; break;\n        case 2: value = AP4_BytesToInt16BE(bytes); break;\n        case 4: value = AP4_BytesToInt32BE(bytes); break;\n        default: value = 0; result = AP4_ERROR_INVALID_FORMAT; break;\n    }\n    return result;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_MetaDataStringAtom::AP4_MetaDataStringAtom\n+---------------------------------------------------------------------*/\nAP4_MetaDataStringAtom::AP4_MetaDataStringAtom(Type type, const char* value) :\n    AP4_Atom(type, AP4_ATOM_HEADER_SIZE),\n    m_Reserved(0),\n    m_Value(value)\n{\n    m_Size32 += 4+m_Value.GetLength();\n}\n\n/*----------------------------------------------------------------------\n|   AP4_MetaDataStringAtom::AP4_MetaDataStringAtom\n+---------------------------------------------------------------------*/\nAP4_MetaDataStringAtom::AP4_MetaDataStringAtom(Type type, AP4_UI32 size, AP4_ByteStream& stream) :\n    AP4_Atom(type, size),\n    m_Reserved(0),\n    m_Value((AP4_Size)(size-AP4_ATOM_HEADER_SIZE-4))\n{\n    stream.ReadUI32(m_Reserved);\n    stream.Read(m_Value.UseChars(), m_Value.GetLength());\n}\n\n/*----------------------------------------------------------------------\n|   AP4_MetaDataStringAtom::WriteFields\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_MetaDataStringAtom::WriteFields(AP4_ByteStream& stream)\n{\n    stream.WriteUI32(m_Reserved);\n    return stream.Write(m_Value.GetChars(), m_Value.GetLength());\n}\n\n/*----------------------------------------------------------------------\n|   AP4_MetaDataStringAtom::InspectFields\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_MetaDataStringAtom::InspectFields(AP4_AtomInspector& inspector)\n{\n    inspector.AddField(\"value\", m_Value.GetChars());\n    return AP4_SUCCESS;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_3GppLocalizedStringAtom::Create\n+---------------------------------------------------------------------*/\nAP4_3GppLocalizedStringAtom*\nAP4_3GppLocalizedStringAtom::Create(Type type, AP4_UI32 size, AP4_ByteStream& stream) \n{\n    AP4_UI08 version;\n    AP4_UI32 flags;\n    if (AP4_FAILED(AP4_Atom::ReadFullHeader(stream, version, flags))) return NULL;\n    if (version != 0) return NULL;\n    return new AP4_3GppLocalizedStringAtom(type, size, version, flags, stream);\n}\n\n/*----------------------------------------------------------------------\n|   AP4_3GppLocalizedStringAtom::AP4_3GppLocalizedStringAtom\n+---------------------------------------------------------------------*/\nAP4_3GppLocalizedStringAtom::AP4_3GppLocalizedStringAtom(Type        type, \n                                                         const char* language, \n                                                         const char* value) :\n    AP4_Atom(type, AP4_FULL_ATOM_HEADER_SIZE+2, 0, 0),\n    m_Value(value)\n{\n    m_Language[0] = language[0];\n    m_Language[1] = language[1];\n    m_Language[2] = language[2];\n    m_Language[3] = language[3];\n    \n    m_Size32 += m_Value.GetLength()+1;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_3GppLocalizedStringAtom::AP4_3GppLocalizedStringAtom\n+---------------------------------------------------------------------*/\nAP4_3GppLocalizedStringAtom::AP4_3GppLocalizedStringAtom(Type            type, \n                                                         AP4_UI32        size, \n                                                         AP4_UI08        version,\n                                                         AP4_UI32        flags,\n                                                         AP4_ByteStream& stream) :\n    AP4_Atom(type, size, version, flags)\n{\n    // read the language code\n    AP4_UI16 packed_language;\n    stream.ReadUI16(packed_language);\n    m_Language[0] = 0x60+((packed_language>>10)&0x1F);\n    m_Language[1] = 0x60+((packed_language>> 5)&0x1F);\n    m_Language[2] = 0x60+((packed_language    )&0x1F);\n    m_Language[3] = '\\0';\n    \n    // read the value (should be a NULL-terminated string, but we'll\n    // allow for strings that are not terminated)\n    if (size > AP4_FULL_ATOM_HEADER_SIZE+2) {\n        AP4_UI32 value_size = size-(AP4_FULL_ATOM_HEADER_SIZE+2);\n        char* value = new char[value_size];\n        stream.Read(value, value_size);\n        m_Value.Assign(value, value_size);\n        delete[] value;\n    }\n}\n\n/*----------------------------------------------------------------------\n|   AP4_3GppLocalizedStringAtom::WriteFields\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_3GppLocalizedStringAtom::WriteFields(AP4_ByteStream& stream)\n{\n    AP4_UI16 packed_language = ((m_Language[0]-0x60)<<10) |\n                               ((m_Language[1]-0x60)<< 5) |\n                               ((m_Language[2]-0x60));\n    stream.WriteUI16(packed_language);\n    AP4_Size payload_size = (AP4_UI32)GetSize()-GetHeaderSize();\n    if (payload_size < 2) return AP4_ERROR_INVALID_FORMAT;\n    AP4_Size value_size = m_Value.GetLength()+1;\n    if (value_size > payload_size-2) {\n        value_size = payload_size-2;\n    }\n    stream.Write(m_Value.GetChars(), value_size);\n    for (unsigned int i=value_size; i<payload_size-2; i++) {\n        stream.WriteUI08(0);\n    }\n    return AP4_SUCCESS;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_3GppLocalizedStringAtom::InspectFields\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_3GppLocalizedStringAtom::InspectFields(AP4_AtomInspector& inspector)\n{\n    inspector.AddField(\"language\", GetLanguage());\n    inspector.AddField(\"value\", m_Value.GetChars());\n    return AP4_SUCCESS;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_DcfStringAtom::Create\n+---------------------------------------------------------------------*/\nAP4_DcfStringAtom*\nAP4_DcfStringAtom::Create(Type type, AP4_UI32 size, AP4_ByteStream& stream) \n{\n    AP4_UI08 version;\n    AP4_UI32 flags;\n    if (AP4_FAILED(AP4_Atom::ReadFullHeader(stream, version, flags))) return NULL;\n    if (version != 0) return NULL;\n    return new AP4_DcfStringAtom(type, size, version, flags, stream);\n}\n\n/*----------------------------------------------------------------------\n|   AP4_DcfStringAtom::AP4_DcfStringAtom\n+---------------------------------------------------------------------*/\nAP4_DcfStringAtom::AP4_DcfStringAtom(Type type, const char* value) :\n    AP4_Atom(type, AP4_FULL_ATOM_HEADER_SIZE, 0, 0),\n    m_Value(value)\n{\n    m_Size32 += m_Value.GetLength();\n}\n\n/*----------------------------------------------------------------------\n|   AP4_DcfStringAtom::AP4_DcfStringAtom\n+---------------------------------------------------------------------*/\nAP4_DcfStringAtom::AP4_DcfStringAtom(Type            type, \n                                     AP4_UI32        size, \n                                     AP4_UI08        version,\n                                     AP4_UI32        flags,\n                                     AP4_ByteStream& stream) :\n    AP4_Atom(type, size, version, flags)\n{\n    if (size > AP4_FULL_ATOM_HEADER_SIZE) {\n        AP4_UI32 value_size = size-(AP4_FULL_ATOM_HEADER_SIZE);\n        char* value = new char[value_size];\n        stream.Read(value, value_size);\n        m_Value.Assign(value, value_size);\n        delete[] value;\n    }\n}\n\n/*----------------------------------------------------------------------\n|   AP4_DcfStringAtom::WriteFields\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_DcfStringAtom::WriteFields(AP4_ByteStream& stream)\n{\n    if (m_Value.GetLength()) stream.Write(m_Value.GetChars(), m_Value.GetLength());\n    return AP4_SUCCESS;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_DcfStringAtom::InspectFields\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_DcfStringAtom::InspectFields(AP4_AtomInspector& inspector)\n{\n    inspector.AddField(\"value\", m_Value.GetChars());\n    return AP4_SUCCESS;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_DcfdAtom::Create\n+---------------------------------------------------------------------*/\nAP4_DcfdAtom*\nAP4_DcfdAtom::Create(AP4_UI32 size, AP4_ByteStream& stream) \n{\n    AP4_UI08 version;\n    AP4_UI32 flags;\n    if (AP4_FAILED(AP4_Atom::ReadFullHeader(stream, version, flags))) return NULL;\n    if (version != 0) return NULL;\n    if (size != AP4_FULL_ATOM_HEADER_SIZE+4) return NULL;\n    return new AP4_DcfdAtom(version, flags, stream);\n}\n\n/*----------------------------------------------------------------------\n|   AP4_DcfdAtom::AP4_DcfdAtom\n+---------------------------------------------------------------------*/\nAP4_DcfdAtom::AP4_DcfdAtom(AP4_UI08        version,\n                           AP4_UI32        flags,\n                           AP4_ByteStream& stream) :\n    AP4_Atom(AP4_ATOM_TYPE_DCFD, AP4_FULL_ATOM_HEADER_SIZE+4, version, flags),\n    m_Duration(0)\n{\n    stream.ReadUI32(m_Duration);\n}\n\n/*----------------------------------------------------------------------\n|   AP4_DcfdAtom::AP4_DcfdAtom\n+---------------------------------------------------------------------*/\nAP4_DcfdAtom::AP4_DcfdAtom(AP4_UI32 duration) :\n    AP4_Atom(AP4_ATOM_TYPE_DCFD, AP4_FULL_ATOM_HEADER_SIZE+4, 0, 0),\n    m_Duration(duration)\n{\n}\n\n/*----------------------------------------------------------------------\n|   AP4_DcfdAtom::WriteFields\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_DcfdAtom::WriteFields(AP4_ByteStream& stream)\n{\n    stream.WriteUI32(m_Duration);\n    return AP4_SUCCESS;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_DcfdAtom::InspectFields\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4_DcfdAtom::InspectFields(AP4_AtomInspector& inspector)\n{\n    inspector.AddField(\"duration\", m_Duration);\n    return AP4_SUCCESS;\n}\n"], "filenames": ["Source/C++/MetaData/Ap4MetaData.cpp"], "buggy_code_start_loc": [1261], "buggy_code_end_loc": [1338], "fixing_code_start_loc": [1261], "fixing_code_end_loc": [1340], "type": "CWE-476", "message": "A NULL pointer dereference was discovered in the AP4_DataAtom class in MetaData/Ap4MetaData.cpp in Bento4 version 1.5.0-617. The vulnerability causes a segmentation fault and application crash, which leads to remote denial of service.", "other": {"cve": {"id": "CVE-2017-14641", "sourceIdentifier": "cve@mitre.org", "published": "2017-09-21T17:29:00.260", "lastModified": "2017-09-28T16:16:24.483", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A NULL pointer dereference was discovered in the AP4_DataAtom class in MetaData/Ap4MetaData.cpp in Bento4 version 1.5.0-617. The vulnerability causes a segmentation fault and application crash, which leads to remote denial of service."}, {"lang": "es", "value": "Existe una desreferencia de puntero NULL en la clase AP4_DataAtom en MetaData/Ap4MetaData.cpp en Bento4 1.5.0-617. Esta vulnerabilidad causa un error de segmentaci\u00f3n y el cierre inesperado de la aplicaci\u00f3n, lo que da lugar a una denegaci\u00f3n de servicio remota."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:bento4:bento4:1.5.0-617:*:*:*:*:*:*:*", "matchCriteriaId": "E91AC306-5354-4B0C-B481-CBA451648D90"}]}]}], "references": [{"url": "https://blogs.gentoo.org/ago/2017/09/14/bento4-null-pointer-dereference-in-ap4_dataatomap4_dataatom-ap4metadata-cpp/", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/axiomatic-systems/Bento4/commit/41cad602709436628f07b4c4f64e9ff7a611f687", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/axiomatic-systems/Bento4/issues/184", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/axiomatic-systems/Bento4/commit/41cad602709436628f07b4c4f64e9ff7a611f687"}}