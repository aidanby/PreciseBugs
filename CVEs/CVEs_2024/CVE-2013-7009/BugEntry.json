{"buggy_code": ["/*\n * Quicktime Video (RPZA) Video Decoder\n * Copyright (C) 2003 the ffmpeg project\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * QT RPZA Video Decoder by Roberto Togni\n * For more information about the RPZA format, visit:\n *   http://www.pcisys.net/~melanson/codecs/\n *\n * The RPZA decoder outputs RGB555 colorspace data.\n *\n * Note that this decoder reads big endian RGB555 pixel values from the\n * bytestream, arranges them in the host's endian order, and outputs\n * them to the final rendered map in the same host endian order. This is\n * intended behavior as the libavcodec documentation states that RGB555\n * pixels shall be stored in native CPU endianness.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"libavutil/internal.h\"\n#include \"libavutil/intreadwrite.h\"\n#include \"avcodec.h\"\n#include \"internal.h\"\n\ntypedef struct RpzaContext {\n\n    AVCodecContext *avctx;\n    AVFrame frame;\n\n    const unsigned char *buf;\n    int size;\n\n} RpzaContext;\n\n#define ADVANCE_BLOCK() \\\n{ \\\n    pixel_ptr += 4; \\\n    if (pixel_ptr >= width) \\\n    { \\\n        pixel_ptr = 0; \\\n        row_ptr += stride * 4; \\\n    } \\\n    total_blocks--; \\\n    if (total_blocks < 0) \\\n    { \\\n        av_log(s->avctx, AV_LOG_ERROR, \"warning: block counter just went negative (this should not happen)\\n\"); \\\n        return; \\\n    } \\\n}\n\nstatic void rpza_decode_stream(RpzaContext *s)\n{\n    int width = s->avctx->width;\n    int stride = s->frame.linesize[0] / 2;\n    int row_inc = stride - 4;\n    int stream_ptr = 0;\n    int chunk_size;\n    unsigned char opcode;\n    int n_blocks;\n    unsigned short colorA = 0, colorB;\n    unsigned short color4[4];\n    unsigned char index, idx;\n    unsigned short ta, tb;\n    unsigned short *pixels = (unsigned short *)s->frame.data[0];\n\n    int row_ptr = 0;\n    int pixel_ptr = 0;\n    int block_ptr;\n    int pixel_x, pixel_y;\n    int total_blocks;\n\n    /* First byte is always 0xe1. Warn if it's different */\n    if (s->buf[stream_ptr] != 0xe1)\n        av_log(s->avctx, AV_LOG_ERROR, \"First chunk byte is 0x%02x instead of 0xe1\\n\",\n            s->buf[stream_ptr]);\n\n    /* Get chunk size, ingnoring first byte */\n    chunk_size = AV_RB32(&s->buf[stream_ptr]) & 0x00FFFFFF;\n    stream_ptr += 4;\n\n    /* If length mismatch use size from MOV file and try to decode anyway */\n    if (chunk_size != s->size)\n        av_log(s->avctx, AV_LOG_ERROR, \"MOV chunk size != encoded chunk size; using MOV chunk size\\n\");\n\n    chunk_size = s->size;\n\n    /* Number of 4x4 blocks in frame. */\n    total_blocks = ((s->avctx->width + 3) / 4) * ((s->avctx->height + 3) / 4);\n\n    /* Process chunk data */\n    while (stream_ptr < chunk_size) {\n        opcode = s->buf[stream_ptr++]; /* Get opcode */\n\n        n_blocks = (opcode & 0x1f) + 1; /* Extract block counter from opcode */\n\n        /* If opcode MSbit is 0, we need more data to decide what to do */\n        if ((opcode & 0x80) == 0) {\n            colorA = (opcode << 8) | (s->buf[stream_ptr++]);\n            opcode = 0;\n            if ((s->buf[stream_ptr] & 0x80) != 0) {\n                /* Must behave as opcode 110xxxxx, using colorA computed\n                 * above. Use fake opcode 0x20 to enter switch block at\n                 * the right place */\n                opcode = 0x20;\n                n_blocks = 1;\n            }\n        }\n\n        switch (opcode & 0xe0) {\n\n        /* Skip blocks */\n        case 0x80:\n            while (n_blocks--) {\n              ADVANCE_BLOCK();\n            }\n            break;\n\n        /* Fill blocks with one color */\n        case 0xa0:\n            colorA = AV_RB16 (&s->buf[stream_ptr]);\n            stream_ptr += 2;\n            while (n_blocks--) {\n                block_ptr = row_ptr + pixel_ptr;\n                for (pixel_y = 0; pixel_y < 4; pixel_y++) {\n                    for (pixel_x = 0; pixel_x < 4; pixel_x++){\n                        pixels[block_ptr] = colorA;\n                        block_ptr++;\n                    }\n                    block_ptr += row_inc;\n                }\n                ADVANCE_BLOCK();\n            }\n            break;\n\n        /* Fill blocks with 4 colors */\n        case 0xc0:\n            colorA = AV_RB16 (&s->buf[stream_ptr]);\n            stream_ptr += 2;\n        case 0x20:\n            colorB = AV_RB16 (&s->buf[stream_ptr]);\n            stream_ptr += 2;\n\n            /* sort out the colors */\n            color4[0] = colorB;\n            color4[1] = 0;\n            color4[2] = 0;\n            color4[3] = colorA;\n\n            /* red components */\n            ta = (colorA >> 10) & 0x1F;\n            tb = (colorB >> 10) & 0x1F;\n            color4[1] |= ((11 * ta + 21 * tb) >> 5) << 10;\n            color4[2] |= ((21 * ta + 11 * tb) >> 5) << 10;\n\n            /* green components */\n            ta = (colorA >> 5) & 0x1F;\n            tb = (colorB >> 5) & 0x1F;\n            color4[1] |= ((11 * ta + 21 * tb) >> 5) << 5;\n            color4[2] |= ((21 * ta + 11 * tb) >> 5) << 5;\n\n            /* blue components */\n            ta = colorA & 0x1F;\n            tb = colorB & 0x1F;\n            color4[1] |= ((11 * ta + 21 * tb) >> 5);\n            color4[2] |= ((21 * ta + 11 * tb) >> 5);\n\n            if (s->size - stream_ptr < n_blocks * 4)\n                return;\n            while (n_blocks--) {\n                block_ptr = row_ptr + pixel_ptr;\n                for (pixel_y = 0; pixel_y < 4; pixel_y++) {\n                    index = s->buf[stream_ptr++];\n                    for (pixel_x = 0; pixel_x < 4; pixel_x++){\n                        idx = (index >> (2 * (3 - pixel_x))) & 0x03;\n                        pixels[block_ptr] = color4[idx];\n                        block_ptr++;\n                    }\n                    block_ptr += row_inc;\n                }\n                ADVANCE_BLOCK();\n            }\n            break;\n\n        /* Fill block with 16 colors */\n        case 0x00:\n            if (s->size - stream_ptr < 16)\n                return;\n            block_ptr = row_ptr + pixel_ptr;\n            for (pixel_y = 0; pixel_y < 4; pixel_y++) {\n                for (pixel_x = 0; pixel_x < 4; pixel_x++){\n                    /* We already have color of upper left pixel */\n                    if ((pixel_y != 0) || (pixel_x !=0)) {\n                        colorA = AV_RB16 (&s->buf[stream_ptr]);\n                        stream_ptr += 2;\n                    }\n                    pixels[block_ptr] = colorA;\n                    block_ptr++;\n                }\n                block_ptr += row_inc;\n            }\n            ADVANCE_BLOCK();\n            break;\n\n        /* Unknown opcode */\n        default:\n            av_log(s->avctx, AV_LOG_ERROR, \"Unknown opcode %d in rpza chunk.\"\n                 \" Skip remaining %d bytes of chunk data.\\n\", opcode,\n                 chunk_size - stream_ptr);\n            return;\n        } /* Opcode switch */\n    }\n}\n\nstatic av_cold int rpza_decode_init(AVCodecContext *avctx)\n{\n    RpzaContext *s = avctx->priv_data;\n\n    s->avctx = avctx;\n    avctx->pix_fmt = AV_PIX_FMT_RGB555;\n\n    avcodec_get_frame_defaults(&s->frame);\n\n    return 0;\n}\n\nstatic int rpza_decode_frame(AVCodecContext *avctx,\n                             void *data, int *got_frame,\n                             AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    RpzaContext *s = avctx->priv_data;\n    int ret;\n\n    s->buf = buf;\n    s->size = buf_size;\n\n    if ((ret = ff_reget_buffer(avctx, &s->frame)) < 0)\n        return ret;\n\n    rpza_decode_stream(s);\n\n    if ((ret = av_frame_ref(data, &s->frame)) < 0)\n        return ret;\n\n    *got_frame      = 1;\n\n    /* always report that the buffer was completely consumed */\n    return buf_size;\n}\n\nstatic av_cold int rpza_decode_end(AVCodecContext *avctx)\n{\n    RpzaContext *s = avctx->priv_data;\n\n    av_frame_unref(&s->frame);\n\n    return 0;\n}\n\nAVCodec ff_rpza_decoder = {\n    .name           = \"rpza\",\n    .type           = AVMEDIA_TYPE_VIDEO,\n    .id             = AV_CODEC_ID_RPZA,\n    .priv_data_size = sizeof(RpzaContext),\n    .init           = rpza_decode_init,\n    .close          = rpza_decode_end,\n    .decode         = rpza_decode_frame,\n    .capabilities   = CODEC_CAP_DR1,\n    .long_name      = NULL_IF_CONFIG_SMALL(\"QuickTime video (RPZA)\"),\n};\n"], "fixing_code": ["/*\n * Quicktime Video (RPZA) Video Decoder\n * Copyright (C) 2003 the ffmpeg project\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * QT RPZA Video Decoder by Roberto Togni\n * For more information about the RPZA format, visit:\n *   http://www.pcisys.net/~melanson/codecs/\n *\n * The RPZA decoder outputs RGB555 colorspace data.\n *\n * Note that this decoder reads big endian RGB555 pixel values from the\n * bytestream, arranges them in the host's endian order, and outputs\n * them to the final rendered map in the same host endian order. This is\n * intended behavior as the libavcodec documentation states that RGB555\n * pixels shall be stored in native CPU endianness.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"libavutil/internal.h\"\n#include \"libavutil/intreadwrite.h\"\n#include \"avcodec.h\"\n#include \"internal.h\"\n\ntypedef struct RpzaContext {\n\n    AVCodecContext *avctx;\n    AVFrame frame;\n\n    const unsigned char *buf;\n    int size;\n\n} RpzaContext;\n\n#define ADVANCE_BLOCK() \\\n{ \\\n    pixel_ptr += 4; \\\n    if (pixel_ptr >= width) \\\n    { \\\n        pixel_ptr = 0; \\\n        row_ptr += stride * 4; \\\n    } \\\n    total_blocks--; \\\n    if (total_blocks < 0) \\\n    { \\\n        av_log(s->avctx, AV_LOG_ERROR, \"warning: block counter just went negative (this should not happen)\\n\"); \\\n        return; \\\n    } \\\n}\n\nstatic void rpza_decode_stream(RpzaContext *s)\n{\n    int width = s->avctx->width;\n    int stride = s->frame.linesize[0] / 2;\n    int row_inc = stride - 4;\n    int stream_ptr = 0;\n    int chunk_size;\n    unsigned char opcode;\n    int n_blocks;\n    unsigned short colorA = 0, colorB;\n    unsigned short color4[4];\n    unsigned char index, idx;\n    unsigned short ta, tb;\n    unsigned short *pixels = (unsigned short *)s->frame.data[0];\n\n    int row_ptr = 0;\n    int pixel_ptr = -4;\n    int block_ptr;\n    int pixel_x, pixel_y;\n    int total_blocks;\n\n    /* First byte is always 0xe1. Warn if it's different */\n    if (s->buf[stream_ptr] != 0xe1)\n        av_log(s->avctx, AV_LOG_ERROR, \"First chunk byte is 0x%02x instead of 0xe1\\n\",\n            s->buf[stream_ptr]);\n\n    /* Get chunk size, ingnoring first byte */\n    chunk_size = AV_RB32(&s->buf[stream_ptr]) & 0x00FFFFFF;\n    stream_ptr += 4;\n\n    /* If length mismatch use size from MOV file and try to decode anyway */\n    if (chunk_size != s->size)\n        av_log(s->avctx, AV_LOG_ERROR, \"MOV chunk size != encoded chunk size; using MOV chunk size\\n\");\n\n    chunk_size = s->size;\n\n    /* Number of 4x4 blocks in frame. */\n    total_blocks = ((s->avctx->width + 3) / 4) * ((s->avctx->height + 3) / 4);\n\n    /* Process chunk data */\n    while (stream_ptr < chunk_size) {\n        opcode = s->buf[stream_ptr++]; /* Get opcode */\n\n        n_blocks = (opcode & 0x1f) + 1; /* Extract block counter from opcode */\n\n        /* If opcode MSbit is 0, we need more data to decide what to do */\n        if ((opcode & 0x80) == 0) {\n            colorA = (opcode << 8) | (s->buf[stream_ptr++]);\n            opcode = 0;\n            if ((s->buf[stream_ptr] & 0x80) != 0) {\n                /* Must behave as opcode 110xxxxx, using colorA computed\n                 * above. Use fake opcode 0x20 to enter switch block at\n                 * the right place */\n                opcode = 0x20;\n                n_blocks = 1;\n            }\n        }\n\n        switch (opcode & 0xe0) {\n\n        /* Skip blocks */\n        case 0x80:\n            while (n_blocks--) {\n              ADVANCE_BLOCK();\n            }\n            break;\n\n        /* Fill blocks with one color */\n        case 0xa0:\n            colorA = AV_RB16 (&s->buf[stream_ptr]);\n            stream_ptr += 2;\n            while (n_blocks--) {\n                ADVANCE_BLOCK()\n                block_ptr = row_ptr + pixel_ptr;\n                for (pixel_y = 0; pixel_y < 4; pixel_y++) {\n                    for (pixel_x = 0; pixel_x < 4; pixel_x++){\n                        pixels[block_ptr] = colorA;\n                        block_ptr++;\n                    }\n                    block_ptr += row_inc;\n                }\n            }\n            break;\n\n        /* Fill blocks with 4 colors */\n        case 0xc0:\n            colorA = AV_RB16 (&s->buf[stream_ptr]);\n            stream_ptr += 2;\n        case 0x20:\n            colorB = AV_RB16 (&s->buf[stream_ptr]);\n            stream_ptr += 2;\n\n            /* sort out the colors */\n            color4[0] = colorB;\n            color4[1] = 0;\n            color4[2] = 0;\n            color4[3] = colorA;\n\n            /* red components */\n            ta = (colorA >> 10) & 0x1F;\n            tb = (colorB >> 10) & 0x1F;\n            color4[1] |= ((11 * ta + 21 * tb) >> 5) << 10;\n            color4[2] |= ((21 * ta + 11 * tb) >> 5) << 10;\n\n            /* green components */\n            ta = (colorA >> 5) & 0x1F;\n            tb = (colorB >> 5) & 0x1F;\n            color4[1] |= ((11 * ta + 21 * tb) >> 5) << 5;\n            color4[2] |= ((21 * ta + 11 * tb) >> 5) << 5;\n\n            /* blue components */\n            ta = colorA & 0x1F;\n            tb = colorB & 0x1F;\n            color4[1] |= ((11 * ta + 21 * tb) >> 5);\n            color4[2] |= ((21 * ta + 11 * tb) >> 5);\n\n            if (s->size - stream_ptr < n_blocks * 4)\n                return;\n            while (n_blocks--) {\n                ADVANCE_BLOCK();\n                block_ptr = row_ptr + pixel_ptr;\n                for (pixel_y = 0; pixel_y < 4; pixel_y++) {\n                    index = s->buf[stream_ptr++];\n                    for (pixel_x = 0; pixel_x < 4; pixel_x++){\n                        idx = (index >> (2 * (3 - pixel_x))) & 0x03;\n                        pixels[block_ptr] = color4[idx];\n                        block_ptr++;\n                    }\n                    block_ptr += row_inc;\n                }\n            }\n            break;\n\n        /* Fill block with 16 colors */\n        case 0x00:\n            if (s->size - stream_ptr < 16)\n                return;\n            ADVANCE_BLOCK();\n            block_ptr = row_ptr + pixel_ptr;\n            for (pixel_y = 0; pixel_y < 4; pixel_y++) {\n                for (pixel_x = 0; pixel_x < 4; pixel_x++){\n                    /* We already have color of upper left pixel */\n                    if ((pixel_y != 0) || (pixel_x !=0)) {\n                        colorA = AV_RB16 (&s->buf[stream_ptr]);\n                        stream_ptr += 2;\n                    }\n                    pixels[block_ptr] = colorA;\n                    block_ptr++;\n                }\n                block_ptr += row_inc;\n            }\n            break;\n\n        /* Unknown opcode */\n        default:\n            av_log(s->avctx, AV_LOG_ERROR, \"Unknown opcode %d in rpza chunk.\"\n                 \" Skip remaining %d bytes of chunk data.\\n\", opcode,\n                 chunk_size - stream_ptr);\n            return;\n        } /* Opcode switch */\n    }\n}\n\nstatic av_cold int rpza_decode_init(AVCodecContext *avctx)\n{\n    RpzaContext *s = avctx->priv_data;\n\n    s->avctx = avctx;\n    avctx->pix_fmt = AV_PIX_FMT_RGB555;\n\n    avcodec_get_frame_defaults(&s->frame);\n\n    return 0;\n}\n\nstatic int rpza_decode_frame(AVCodecContext *avctx,\n                             void *data, int *got_frame,\n                             AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    RpzaContext *s = avctx->priv_data;\n    int ret;\n\n    s->buf = buf;\n    s->size = buf_size;\n\n    if ((ret = ff_reget_buffer(avctx, &s->frame)) < 0)\n        return ret;\n\n    rpza_decode_stream(s);\n\n    if ((ret = av_frame_ref(data, &s->frame)) < 0)\n        return ret;\n\n    *got_frame      = 1;\n\n    /* always report that the buffer was completely consumed */\n    return buf_size;\n}\n\nstatic av_cold int rpza_decode_end(AVCodecContext *avctx)\n{\n    RpzaContext *s = avctx->priv_data;\n\n    av_frame_unref(&s->frame);\n\n    return 0;\n}\n\nAVCodec ff_rpza_decoder = {\n    .name           = \"rpza\",\n    .type           = AVMEDIA_TYPE_VIDEO,\n    .id             = AV_CODEC_ID_RPZA,\n    .priv_data_size = sizeof(RpzaContext),\n    .init           = rpza_decode_init,\n    .close          = rpza_decode_end,\n    .decode         = rpza_decode_frame,\n    .capabilities   = CODEC_CAP_DR1,\n    .long_name      = NULL_IF_CONFIG_SMALL(\"QuickTime video (RPZA)\"),\n};\n"], "filenames": ["libavcodec/rpza.c"], "buggy_code_start_loc": [88], "buggy_code_end_loc": [223], "fixing_code_start_loc": [88], "fixing_code_end_loc": [222], "type": "CWE-119", "message": "The rpza_decode_stream function in libavcodec/rpza.c in FFmpeg before 2.1 does not properly maintain a pointer to pixel data, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted Apple RPZA data.", "other": {"cve": {"id": "CVE-2013-7009", "sourceIdentifier": "cve@mitre.org", "published": "2013-12-09T16:36:47.847", "lastModified": "2016-12-03T03:00:34.690", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The rpza_decode_stream function in libavcodec/rpza.c in FFmpeg before 2.1 does not properly maintain a pointer to pixel data, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted Apple RPZA data."}, {"lang": "es", "value": "La funci\u00f3n rpza_decode_stream en libavcodec/rpza.c en FFmpeg anteriores a 2.1 no mantiene correctamente un puntero a p\u00edxeles, lo cual permite a atacantes remotos causar denegaci\u00f3n de servicio (acceso a array fuera de l\u00edmites) o posiblemente tener otro impacto no especificado a trav\u00e9s de datos Apple RPZA."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.0.1", "matchCriteriaId": "C41A1983-BA74-4806-A227-EBBF7989112C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.3:*:*:*:*:*:*:*", "matchCriteriaId": "B2649A80-4739-4BBB-AB0B-99AD435BE7CF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.3.1:*:*:*:*:*:*:*", "matchCriteriaId": "D4A2E77D-B826-4B49-ADC8-7F704E149A5A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.3.2:*:*:*:*:*:*:*", "matchCriteriaId": "18157837-4550-45E3-A12E-AE06E047E253"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.3.3:*:*:*:*:*:*:*", "matchCriteriaId": "E9F42611-C3E2-416B-9AE7-A5AE83E4DEF7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.3.4:*:*:*:*:*:*:*", "matchCriteriaId": "3A20789F-26E3-4871-B24E-25E922BADDF0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "67C6C243-3ACC-49C3-80CA-D7CA8FEFF0D8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.2:*:*:*:*:*:*:*", "matchCriteriaId": "6AE6D368-0BA6-4499-B7E1-EE16C03012E9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.3:*:*:*:*:*:*:*", "matchCriteriaId": "26C0F6EF-0452-4AFE-AF3E-B88F963A0938"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.4:*:*:*:*:*:*:*", "matchCriteriaId": "5B4DD372-4D3B-445C-8C38-E083A3C0D4A7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.5:*:*:*:*:*:*:*", "matchCriteriaId": "733C03D7-2780-4D69-A98D-BCFB91D1119A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.6:*:*:*:*:*:*:*", "matchCriteriaId": "0AEE1977-E9E0-4BFF-B33B-B083E49E51F1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.7:*:*:*:*:*:*:*", "matchCriteriaId": "E6979C17-0BC6-47D1-9B73-254D84306A96"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.8:*:*:*:*:*:*:*", "matchCriteriaId": "204C7C05-3441-4DB0-8702-D99C8FCB381E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.4.9:pre1:*:*:*:*:*:*", "matchCriteriaId": "2E1A7011-B992-4E35-B306-45772DACB23C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5:*:*:*:*:*:*:*", "matchCriteriaId": "8D486C17-FC4A-4AEE-A430-1B1FBCC2C27C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.1:*:*:*:*:*:*:*", "matchCriteriaId": "632BC7C2-FE59-47B0-885C-0EB8C74DF041"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.2:*:*:*:*:*:*:*", "matchCriteriaId": "5D1AE0BF-A6FD-4EBA-BF61-07AC81EA560D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.3:*:*:*:*:*:*:*", "matchCriteriaId": "5B8FA106-FE65-4BB0-92A7-E8A5AF978A9B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.4:*:*:*:*:*:*:*", "matchCriteriaId": "514669DA-8D02-44CE-BE18-8783F69AE394"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.4.5:*:*:*:*:*:*:*", "matchCriteriaId": "8041E6ED-472A-40DF-AA90-F3509D90D47A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.4.6:*:*:*:*:*:*:*", "matchCriteriaId": "D2C64382-9259-4D61-B352-7F123527289C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.5.5:*:*:*:*:*:*:*", "matchCriteriaId": "32A152D9-947E-4198-9C2D-2A582F09AB75"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.6:*:*:*:*:*:*:*", "matchCriteriaId": "37FBB817-A186-4517-9DA7-B3638576AAE7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.6.1:*:*:*:*:*:*:*", "matchCriteriaId": "157ABA40-6101-4E9C-A24C-84F8E23D374D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.6.2:*:*:*:*:*:*:*", "matchCriteriaId": "C7EA46DD-2CC4-426F-8709-821B7572C94A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.6.3:*:*:*:*:*:*:*", "matchCriteriaId": "3DE12C59-4409-4F7A-9759-7B26FA9DAC34"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7:*:*:*:*:*:*:*", "matchCriteriaId": "30FE6578-F031-4F5B-B955-8F912CFCA1B0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.1:*:*:*:*:*:*:*", "matchCriteriaId": "07669E0E-8C4B-430E-802F-F64EEA2B5A0B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.2:*:*:*:*:*:*:*", "matchCriteriaId": "F3EB7F17-F25D-4E48-8A43-F799619CE71F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.3:*:*:*:*:*:*:*", "matchCriteriaId": "60705A3B-7136-45D1-8068-E2DC9E01EB04"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.4:*:*:*:*:*:*:*", "matchCriteriaId": "C722B143-2648-4EB2-A090-7B788F41F300"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.5:*:*:*:*:*:*:*", "matchCriteriaId": "B31AFDBC-A782-4C18-8EAA-6D927397BEA3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.6:*:*:*:*:*:*:*", "matchCriteriaId": "73E9E8F4-A942-4F34-BCE2-82A180F1DD1F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.7:*:*:*:*:*:*:*", "matchCriteriaId": "AAA31D75-C3FB-4D89-8B2D-21372AAEB78B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.8:*:*:*:*:*:*:*", "matchCriteriaId": "B20E5358-826C-47A2-B39F-ED4E9213BA95"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.9:*:*:*:*:*:*:*", "matchCriteriaId": "26321888-E140-4F09-AAA0-7392AA7F6307"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.11:*:*:*:*:*:*:*", "matchCriteriaId": "7E46B9F3-A9C0-4B8A-A119-40CA4CBBD0EE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.7.12:*:*:*:*:*:*:*", "matchCriteriaId": "44800572-71C5-4AA1-9CB6-30AA902B0353"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "87090477-1D36-48B3-88AE-5CD5EE8F89D7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.1:*:*:*:*:*:*:*", "matchCriteriaId": "2096FF8B-9B57-4C59-84DB-9CC0DEAB47AC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.2:*:*:*:*:*:*:*", "matchCriteriaId": "34C99254-776C-4AAD-BDA2-3F544256AA67"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.5:*:*:*:*:*:*:*", "matchCriteriaId": "CE9D7B73-9CDA-4BAE-8DD9-8E1E34C20648"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.5.3:*:*:*:*:*:*:*", "matchCriteriaId": "4FDBF2C0-8E33-4575-8A19-4F1CABA3023F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.5.4:*:*:*:*:*:*:*", "matchCriteriaId": "72040664-077A-48FB-9E6B-B69EA8D26CB4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.6:*:*:*:*:*:*:*", "matchCriteriaId": "F428A2E4-A54F-4296-A00F-1A4E160253D7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.7:*:*:*:*:*:*:*", "matchCriteriaId": "5239E4FA-0359-49F1-93D4-24AB013FAC20"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.8:*:*:*:*:*:*:*", "matchCriteriaId": "F0C8230D-4E89-45F9-B0F7-E317119E0FA0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.10:*:*:*:*:*:*:*", "matchCriteriaId": "585CE7D2-1CE8-44AB-AE67-07D7D3721F68"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.8.11:*:*:*:*:*:*:*", "matchCriteriaId": "EE81C339-A794-4303-B829-BE743DF0B132"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.9:*:*:*:*:*:*:*", "matchCriteriaId": "5CE0A27B-66D7-4D1B-8E6A-F4722C070BD3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.9.1:*:*:*:*:*:*:*", "matchCriteriaId": "864DC4A2-A378-4389-B62E-9E785879A744"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.10:*:*:*:*:*:*:*", "matchCriteriaId": "16304267-C808-4B6B-9903-2DEAB40AD899"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.10.3:*:*:*:*:*:*:*", "matchCriteriaId": "CEEBBA83-1BFC-45A8-B34A-AB3A9B8A9414"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.10.4:*:*:*:*:*:*:*", "matchCriteriaId": "F559B34E-23EE-4E09-A044-E7F54C55B05E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:0.11:*:*:*:*:*:*:*", "matchCriteriaId": "62BA2708-BE77-42B7-B51A-C1B58632462C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.0:*:*:*:*:*:*:*", "matchCriteriaId": "23E57BB1-DF1E-4173-BE52-72E2B3E6BA23"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "A3E30DB1-0CFC-4EAA-BF07-CE7551ABDCB5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.1.2:*:*:*:*:*:*:*", "matchCriteriaId": "DBA7D745-DC16-43B9-8A2D-4D6944A6BFD0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.1.3:*:*:*:*:*:*:*", "matchCriteriaId": "87A511A5-2040-433A-9B32-B89332214FA6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.1.4:*:*:*:*:*:*:*", "matchCriteriaId": "0C01DD9C-98C9-4896-8D66-A8336582298B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.2:*:*:*:*:*:*:*", "matchCriteriaId": "BBE7723A-3D6B-4390-B82E-6A5A6992141A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:1.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "1ED8FF93-5AA7-443C-BBDB-845736BB337B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:2.0:*:*:*:*:*:*:*", "matchCriteriaId": "A1337F5B-E9D9-4335-9E05-50018E59E530"}]}]}], "references": [{"url": "http://ffmpeg.org/security.html", "source": "cve@mitre.org"}, {"url": "http://openwall.com/lists/oss-security/2013/11/26/7", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "http://openwall.com/lists/oss-security/2013/12/08/3", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/3819db745da2ac7fb3faacb116788c32f4753f34", "source": "cve@mitre.org", "tags": ["Exploit", "Patch"]}, {"url": "https://security.gentoo.org/glsa/201603-06", "source": "cve@mitre.org"}, {"url": "https://trac.ffmpeg.org/ticket/2850", "source": "cve@mitre.org", "tags": ["Exploit"]}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/3819db745da2ac7fb3faacb116788c32f4753f34"}}