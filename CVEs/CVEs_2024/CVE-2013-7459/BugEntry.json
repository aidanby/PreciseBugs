{"buggy_code": ["# -*- coding: utf-8 -*-\n#\n#  SelfTest/Hash/common.py: Common code for Crypto.SelfTest.Hash\n#\n# Written in 2008 by Dwayne C. Litzenberger <dlitz@dlitz.net>\n#\n# ===================================================================\n# The contents of this file are dedicated to the public domain.  To\n# the extent that dedication to the public domain is not available,\n# everyone is granted a worldwide, perpetual, royalty-free,\n# non-exclusive license to exercise all rights associated with the\n# contents of this file for any purpose whatsoever.\n# No rights are reserved.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n# SOFTWARE.\n# ===================================================================\n\n\"\"\"Self-testing for PyCrypto hash modules\"\"\"\n\nfrom __future__ import nested_scopes\n\n__revision__ = \"$Id$\"\n\nimport sys\nif sys.version_info[0] == 2 and sys.version_info[1] == 1:\n    from Crypto.Util.py21compat import *\n\nimport unittest\nfrom binascii import a2b_hex, b2a_hex, hexlify\n\nfrom Crypto.Util.py3compat import *\nfrom Crypto.Util.strxor import strxor_c\n\n# For compatibility with Python 2.1 and Python 2.2\nif sys.hexversion < 0x02030000:\n    # Python 2.1 doesn't have a dict() function\n    # Python 2.2 dict() function raises TypeError if you do dict(MD5='blah')\n    def dict(**kwargs):\n        return kwargs.copy()\nelse:\n    dict = dict\n\nclass _NoDefault: pass        # sentinel object\ndef _extract(d, k, default=_NoDefault):\n    \"\"\"Get an item from a dictionary, and remove it from the dictionary.\"\"\"\n    try:\n        retval = d[k]\n    except KeyError:\n        if default is _NoDefault:\n            raise\n        return default\n    del d[k]\n    return retval\n\n# Generic cipher test case\nclass CipherSelfTest(unittest.TestCase):\n\n    def __init__(self, module, params):\n        unittest.TestCase.__init__(self)\n        self.module = module\n\n        # Extract the parameters\n        params = params.copy()\n        self.description = _extract(params, 'description')\n        self.key = b(_extract(params, 'key'))\n        self.plaintext = b(_extract(params, 'plaintext'))\n        self.ciphertext = b(_extract(params, 'ciphertext'))\n        self.module_name = _extract(params, 'module_name', None)\n        self.assoc_data = _extract(params, 'assoc_data', None)\n        self.mac = _extract(params, 'mac', None)\n        if self.assoc_data:\n            self.mac = b(self.mac)\n\n        mode = _extract(params, 'mode', None)\n        self.mode_name = str(mode)\n        if mode is not None:\n            # Block cipher\n            self.mode = getattr(self.module, \"MODE_\" + mode)\n\n            self.iv = _extract(params, 'iv', None)\n            if self.iv is None:\n                self.iv = _extract(params, 'nonce', None)\n            if self.iv is not None:\n                self.iv = b(self.iv)\n\n            # Only relevant for OPENPGP mode\n            self.encrypted_iv = _extract(params, 'encrypted_iv', None)\n            if self.encrypted_iv is not None:\n                self.encrypted_iv = b(self.encrypted_iv)\n        else:\n            # Stream cipher\n            self.mode = None\n            self.iv = None\n\n        self.extra_params = params\n\n    def shortDescription(self):\n        return self.description\n\n    def _new(self, do_decryption=0):\n        params = self.extra_params.copy()\n\n        # Handle CTR mode parameters.  By default, we use Counter.new(self.module.block_size)\n        if hasattr(self.module, \"MODE_CTR\") and self.mode == self.module.MODE_CTR:\n            from Crypto.Util import Counter\n            ctr_class = _extract(params, 'ctr_class', Counter.new)\n            ctr_params = _extract(params, 'ctr_params', {}).copy()\n            if ctr_params.has_key('prefix'): ctr_params['prefix'] = a2b_hex(b(ctr_params['prefix']))\n            if ctr_params.has_key('suffix'): ctr_params['suffix'] = a2b_hex(b(ctr_params['suffix']))\n            if not ctr_params.has_key('nbits'):\n                ctr_params['nbits'] = 8*(self.module.block_size - len(ctr_params.get('prefix', '')) - len(ctr_params.get('suffix', '')))\n            params['counter'] = ctr_class(**ctr_params)\n\n        if self.mode is None:\n            # Stream cipher\n            return self.module.new(a2b_hex(self.key), **params)\n        elif self.iv is None:\n            # Block cipher without iv\n            return self.module.new(a2b_hex(self.key), self.mode, **params)\n        else:\n            # Block cipher with iv\n            if do_decryption and self.mode == self.module.MODE_OPENPGP:\n                # In PGP mode, the IV to feed for decryption is the *encrypted* one\n                return self.module.new(a2b_hex(self.key), self.mode, a2b_hex(self.encrypted_iv), **params)\n            else:\n                return self.module.new(a2b_hex(self.key), self.mode, a2b_hex(self.iv), **params)\n\n    def isMode(self, name):\n        if not hasattr(self.module, \"MODE_\"+name):\n            return False\n        return self.mode == getattr(self.module, \"MODE_\"+name)\n\n    def runTest(self):\n        plaintext = a2b_hex(self.plaintext)\n        ciphertext = a2b_hex(self.ciphertext)\n        assoc_data = []\n        if self.assoc_data:\n            assoc_data = [ a2b_hex(b(x)) for x in self.assoc_data]\n\n        ct = None\n        pt = None\n\n        #\n        # Repeat the same encryption or decryption twice and verify\n        # that the result is always the same\n        #\n        for i in xrange(2):\n            cipher = self._new()\n            decipher = self._new(1)\n\n            # Only AEAD modes\n            for comp in assoc_data:\n                cipher.update(comp)\n                decipher.update(comp)\n\n            ctX = b2a_hex(cipher.encrypt(plaintext))\n            if self.isMode(\"SIV\"):\n                ptX = b2a_hex(decipher.decrypt_and_verify(ciphertext, a2b_hex(self.mac)))\n            else:\n                ptX = b2a_hex(decipher.decrypt(ciphertext))\n\n            if ct:\n                self.assertEqual(ct, ctX)\n                self.assertEqual(pt, ptX)\n            ct, pt = ctX, ptX\n\n        if self.isMode(\"OPENPGP\"):\n            # In PGP mode, data returned by the first encrypt()\n            # is prefixed with the encrypted IV.\n            # Here we check it and then remove it from the ciphertexts.\n            eilen = len(self.encrypted_iv)\n            self.assertEqual(self.encrypted_iv, ct[:eilen])\n            ct = ct[eilen:]\n\n        self.assertEqual(self.ciphertext, ct)  # encrypt\n        self.assertEqual(self.plaintext, pt)   # decrypt\n\n        if self.mac:\n            mac = b2a_hex(cipher.digest())\n            self.assertEqual(self.mac, mac)\n            decipher.verify(a2b_hex(self.mac))\n\nclass CipherStreamingSelfTest(CipherSelfTest):\n\n    def shortDescription(self):\n        desc = self.module_name\n        if self.mode is not None:\n            desc += \" in %s mode\" % (self.mode_name,)\n        return \"%s should behave like a stream cipher\" % (desc,)\n\n    def runTest(self):\n        plaintext = a2b_hex(self.plaintext)\n        ciphertext = a2b_hex(self.ciphertext)\n\n        # The cipher should work like a stream cipher\n\n        # Test counter mode encryption, 3 bytes at a time\n        ct3 = []\n        cipher = self._new()\n        for i in range(0, len(plaintext), 3):\n            ct3.append(cipher.encrypt(plaintext[i:i+3]))\n        ct3 = b2a_hex(b(\"\").join(ct3))\n        self.assertEqual(self.ciphertext, ct3)  # encryption (3 bytes at a time)\n\n        # Test counter mode decryption, 3 bytes at a time\n        pt3 = []\n        cipher = self._new()\n        for i in range(0, len(ciphertext), 3):\n            pt3.append(cipher.encrypt(ciphertext[i:i+3]))\n        # PY3K: This is meant to be text, do not change to bytes (data)\n        pt3 = b2a_hex(b(\"\").join(pt3))\n        self.assertEqual(self.plaintext, pt3)  # decryption (3 bytes at a time)\n\nclass CTRSegfaultTest(unittest.TestCase):\n\n    def __init__(self, module, params):\n        unittest.TestCase.__init__(self)\n        self.module = module\n        self.key = b(params['key'])\n        self.module_name = params.get('module_name', None)\n\n    def shortDescription(self):\n        return \"\"\"Regression test: %s.new(key, %s.MODE_CTR) should raise TypeError, not segfault\"\"\" % (self.module_name, self.module_name)\n\n    def runTest(self):\n        self.assertRaises(TypeError, self.module.new, a2b_hex(self.key), self.module.MODE_CTR)\n\nclass CTRWraparoundTest(unittest.TestCase):\n\n    def __init__(self, module, params):\n        unittest.TestCase.__init__(self)\n        self.module = module\n        self.key = b(params['key'])\n        self.module_name = params.get('module_name', None)\n\n    def shortDescription(self):\n        return \"\"\"Regression test: %s with MODE_CTR raising OverflowError on wraparound\"\"\" % (self.module_name,)\n\n    def runTest(self):\n        from Crypto.Util import Counter\n\n        def pythonCounter():\n            state = [0]\n            def ctr():\n                # First block succeeds; Second and subsequent blocks raise OverflowError\n                if state[0] == 0:\n                    state[0] = 1\n                    return b(\"\\xff\") * self.module.block_size\n                else:\n                    raise OverflowError\n            return ctr\n\n        for little_endian in (0, 1): # (False, True) Test both endiannesses\n            block = b(\"\\x00\") * self.module.block_size\n\n            # Test PyObject_CallObject code path: if the counter raises OverflowError\n            cipher = self.module.new(a2b_hex(self.key), self.module.MODE_CTR, counter=pythonCounter())\n            cipher.encrypt(block)\n            self.assertRaises(OverflowError, cipher.encrypt, block)\n            self.assertRaises(OverflowError, cipher.encrypt, block)\n\n            # Test PyObject_CallObject code path: counter object should raise OverflowError\n            ctr = Counter.new(8*self.module.block_size, initial_value=2L**(8*self.module.block_size)-1, little_endian=little_endian)\n            ctr()\n            self.assertRaises(OverflowError, ctr)\n            self.assertRaises(OverflowError, ctr)\n\n            # Test the CTR-mode shortcut\n            ctr = Counter.new(8*self.module.block_size, initial_value=2L**(8*self.module.block_size)-1, little_endian=little_endian)\n            cipher = self.module.new(a2b_hex(self.key), self.module.MODE_CTR, counter=ctr)\n            cipher.encrypt(block)\n            self.assertRaises(OverflowError, cipher.encrypt, block)\n            self.assertRaises(OverflowError, cipher.encrypt, block)\n\nclass CFBSegmentSizeTest(unittest.TestCase):\n\n    def __init__(self, module, params):\n        unittest.TestCase.__init__(self)\n        self.module = module\n        self.key = b(params['key'])\n        self.description = params['description']\n\n    def shortDescription(self):\n        return self.description\n\n    def runTest(self):\n        \"\"\"Regression test: m.new(key, m.MODE_CFB, segment_size=N) should require segment_size to be a multiple of 8 bits\"\"\"\n        for i in range(1, 8):\n            self.assertRaises(ValueError, self.module.new, a2b_hex(self.key), self.module.MODE_CFB, segment_size=i)\n        self.module.new(a2b_hex(self.key), self.module.MODE_CFB, \"\\0\"*self.module.block_size, segment_size=8) # should succeed\n\nclass CCMMACLengthTest(unittest.TestCase):\n    \"\"\"CCM specific tests about MAC\"\"\"\n\n    def __init__(self, module):\n        unittest.TestCase.__init__(self)\n        self.module = module\n        self.key = b('\\xFF')*16\n        self.iv = b('\\x00')*10\n\n    def shortDescription(self):\n        return self.description\n\n    def runTest(self):\n        \"\"\"Verify that MAC can only be 4,6,8,..,16 bytes long.\"\"\"\n        for i in range(3,16,2):\n            self.description = \"CCM MAC length check (%d bytes)\" % i\n            self.assertRaises(ValueError, self.module.new, self.key,\n                    self.module.MODE_CCM, self.iv, msg_len=10, mac_len=i)\n\n        \"\"\"Verify that default MAC length is 16.\"\"\"\n        self.description = \"CCM default MAC length check\"\n        cipher = self.module.new(self.key, self.module.MODE_CCM,\n                self.iv, msg_len=4)\n        cipher.encrypt(b('z')*4)\n        self.assertEqual(len(cipher.digest()), 16)\n\nclass CCMSplitEncryptionTest(unittest.TestCase):\n    \"\"\"CCM specific tests to validate how encrypt()\n    decrypt() can be called multiple times on the\n    same object.\"\"\"\n\n    def __init__(self, module):\n        unittest.TestCase.__init__(self)\n        self.module = module\n        self.key = b('\\xFF')*16\n        self.iv = b('\\x00')*10\n        self.description = \"CCM Split Encryption Test\"\n\n    def shortDescription(self):\n        return self.description\n\n    def runTest(self):\n        \"\"\"Verify that CCM update()/encrypt() can be called multiple times,\n        provided that lengths are declared beforehand\"\"\"\n\n        data = b(\"AUTH DATA\")\n        pt1  = b(\"PLAINTEXT1\")       # Short\n        pt2  = b(\"PLAINTEXT2\")       # Long\n        pt_ref = pt1+pt2\n\n        # REFERENCE: Run with 1 update() and 1 encrypt()\n        cipher = self.module.new(self.key, self.module.MODE_CCM,\n            self.iv)\n        cipher.update(data)\n        ct_ref = cipher.encrypt(pt_ref)\n        mac_ref = cipher.digest()\n\n        # Verify that calling CCM encrypt()/decrypt() twice is not\n        # possible without the 'msg_len' parameter and regardless\n        # of the 'assoc_len' parameter\n        for ad_len in None, len(data):\n            cipher = self.module.new(self.key, self.module.MODE_CCM,\n                self.iv, assoc_len=ad_len)\n            cipher.update(data)\n            cipher.encrypt(pt1)\n            self.assertRaises(TypeError, cipher.encrypt, pt2)\n\n            cipher = self.module.new(self.key, self.module.MODE_CCM,\n                self.iv, assoc_len=ad_len)\n            cipher.update(data)\n            cipher.decrypt(ct_ref[:len(pt1)])\n            self.assertRaises(TypeError, cipher.decrypt, ct_ref[len(pt1):])\n\n        # Run with 2 encrypt()/decrypt(). Results must be the same\n        # regardless of the 'assoc_len' parameter\n        for ad_len in None, len(data):\n            cipher = self.module.new(self.key, self.module.MODE_CCM,\n                self.iv, assoc_len=ad_len, msg_len=len(pt_ref))\n            cipher.update(data)\n            ct = cipher.encrypt(pt1)\n            ct += cipher.encrypt(pt2)\n            mac = cipher.digest()\n            self.assertEqual(ct_ref, ct)\n            self.assertEqual(mac_ref, mac)\n\n            cipher = self.module.new(self.key, self.module.MODE_CCM,\n                self.iv, msg_len=len(pt1+pt2))\n            cipher.update(data)\n            pt = cipher.decrypt(ct[:len(pt1)])\n            pt += cipher.decrypt(ct[len(pt1):])\n            mac = cipher.verify(mac_ref)\n            self.assertEqual(pt_ref, pt)\n\nclass AEADTests(unittest.TestCase):\n    \"\"\"Tests generic to all AEAD modes\"\"\"\n\n    def __init__(self, module, mode_name, key_size):\n        unittest.TestCase.__init__(self)\n        self.module = module\n        self.mode_name = mode_name\n        self.mode = getattr(module, mode_name)\n        if not self.isMode(\"SIV\"):\n            self.key = b('\\xFF')*key_size\n        else:\n            self.key = b('\\xFF')*key_size*2\n        self.iv = b('\\x00')*10\n        self.description = \"AEAD Test\"\n\n    def isMode(self, name):\n        if not hasattr(self.module, \"MODE_\"+name):\n            return False\n        return self.mode == getattr(self.module, \"MODE_\"+name)\n\n    def right_mac_test(self):\n        \"\"\"Positive tests for MAC\"\"\"\n\n        self.description = \"Test for right MAC in %s of %s\" % \\\n            (self.mode_name, self.module.__name__)\n\n        ad_ref = b(\"Reference AD\")\n        pt_ref = b(\"Reference plaintext\")\n\n        # Encrypt and create the reference MAC\n        cipher = self.module.new(self.key, self.mode, self.iv)\n        cipher.update(ad_ref)\n        ct_ref = cipher.encrypt(pt_ref)\n        mac_ref = cipher.digest()\n\n        # Decrypt and verify that MAC is accepted\n        decipher = self.module.new(self.key, self.mode, self.iv)\n        decipher.update(ad_ref)\n        pt = decipher.decrypt_and_verify(ct_ref, mac_ref)\n        self.assertEqual(pt, pt_ref)\n\n        # Verify that hexverify work\n        decipher.hexverify(hexlify(mac_ref))\n\n    def wrong_mac_test(self):\n        \"\"\"Negative tests for MAC\"\"\"\n\n        self.description = \"Test for wrong MAC in %s of %s\" % \\\n            (self.mode_name, self.module.__name__)\n\n        ad_ref = b(\"Reference AD\")\n        pt_ref = b(\"Reference plaintext\")\n\n        # Encrypt and create the reference MAC\n        cipher = self.module.new(self.key, self.mode, self.iv)\n        cipher.update(ad_ref)\n        ct_ref = cipher.encrypt(pt_ref)\n        mac_ref = cipher.digest()\n\n        # Modify the MAC and verify it is NOT ACCEPTED\n        wrong_mac = strxor_c(mac_ref, 255)\n        decipher = self.module.new(self.key, self.mode, self.iv)\n        decipher.update(ad_ref)\n        self.assertRaises(ValueError, decipher.decrypt_and_verify,\n                          ct_ref, wrong_mac)\n\n    def zero_data(self):\n        \"\"\"Verify transition from INITIALIZED to FINISHED\"\"\"\n\n        self.description = \"Test for zero data in %s of %s\" % \\\n            (self.mode_name, self.module.__name__)\n        cipher = self.module.new(self.key, self.mode, self.iv)\n        cipher.digest()\n\n    def multiple_updates(self):\n        \"\"\"Verify that update() can be called multiple times\"\"\"\n\n        self.description = \"Test for multiple updates in %s of %s\" % \\\n            (self.mode_name, self.module.__name__)\n\n        # In all modes other than SIV, the associated data is a single\n        # component that can be arbitrarilly split and submitted to update().\n        #\n        # In SIV, associated data is instead organized in a vector or multiple\n        # components. Each component is passed to update() as a whole.\n        # This test is therefore not meaningful to SIV.\n        if self.isMode(\"SIV\"):\n            return\n\n        ad = b(\"\").join([bchr(x) for x in xrange(0,128)])\n\n        mac1, mac2, mac3 = (None,)*3\n        for chunk_length in 1,10,40,80,128:\n            chunks = [ad[i:i+chunk_length] for i in range(0, len(ad), chunk_length)]\n\n            # No encryption/decryption\n            cipher = self.module.new(self.key, self.mode, self.iv)\n            for c in chunks:\n                cipher.update(c)\n            if mac1:\n                cipher.verify(mac1)\n            else:\n                mac1 = cipher.digest()\n\n            # Encryption\n            cipher = self.module.new(self.key, self.mode, self.iv)\n            for c in chunks:\n                cipher.update(c)\n            ct = cipher.encrypt(b(\"PT\"))\n            mac2 = cipher.digest()\n\n            # Decryption\n            cipher = self.module.new(self.key, self.mode, self.iv)\n            for c in chunks:\n                cipher.update(c)\n            cipher.decrypt(ct)\n            cipher.verify(mac2)\n\n    def no_mix_encrypt_decrypt(self):\n        \"\"\"Verify that encrypt and decrypt cannot be mixed up\"\"\"\n\n        self.description = \"Test for mix of encrypt and decrypt in %s of %s\" % \\\n            (self.mode_name, self.module.__name__)\n\n        # Calling decrypt after encrypt raises an exception\n        cipher = self.module.new(self.key, self.mode, self.iv)\n        cipher.encrypt(b(\"PT\")*40)\n        self.assertRaises(TypeError, cipher.decrypt, b(\"XYZ\")*40)\n\n        # Calling encrypt() after decrypt() raises an exception\n        # (excluded for SIV, since decrypt() is not valid)\n        if not self.isMode(\"SIV\"):\n            cipher = self.module.new(self.key, self.mode, self.iv)\n            cipher.decrypt(b(\"CT\")*40)\n            self.assertRaises(TypeError, cipher.encrypt, b(\"XYZ\")*40)\n\n        # Calling verify after encrypt raises an exception\n        cipher = self.module.new(self.key, self.mode, self.iv)\n        cipher.encrypt(b(\"PT\")*40)\n        self.assertRaises(TypeError, cipher.verify, b(\"XYZ\"))\n        self.assertRaises(TypeError, cipher.hexverify, \"12\")\n\n        # Calling digest() after decrypt() raises an exception\n        # (excluded for SIV, since decrypt() is not valid)\n        if not self.isMode(\"SIV\"):\n            cipher = self.module.new(self.key, self.mode, self.iv)\n            cipher.decrypt(b(\"CT\")*40)\n            self.assertRaises(TypeError, cipher.digest)\n            self.assertRaises(TypeError, cipher.hexdigest)\n\n    def no_late_update(self):\n        \"\"\"Verify that update cannot be called after encrypt or decrypt\"\"\"\n\n        self.description = \"Test for late update in %s of %s\" % \\\n            (self.mode_name, self.module.__name__)\n\n        # Calling update after encrypt raises an exception\n        cipher = self.module.new(self.key, self.mode, self.iv)\n        cipher.update(b(\"XX\"))\n        cipher.encrypt(b(\"PT\")*40)\n        self.assertRaises(TypeError, cipher.update, b(\"XYZ\"))\n\n        # Calling update() after decrypt() raises an exception\n        # (excluded for SIV, since decrypt() is not valid)\n        if not self.isMode(\"SIV\"):\n            cipher = self.module.new(self.key, self.mode, self.iv)\n            cipher.update(b(\"XX\"))\n            cipher.decrypt(b(\"CT\")*40)\n            self.assertRaises(TypeError, cipher.update, b(\"XYZ\"))\n\n    def loopback(self):\n        \"\"\"Verify composition of encrypt_and_digest() and decrypt_and_verify()\n        is the identity function.\"\"\"\n\n        self.description  = \"Lookback test decrypt_and_verify(encrypt_and_digest)\"\\\n                            \"for %s in %s\" % (self.mode_name,\n                            self.module.__name__)\n\n        enc_cipher = self.module.new(self.key, self.mode, self.iv)\n        dec_cipher = self.module.new(self.key, self.mode, self.iv)\n\n        enc_cipher.update(b(\"XXX\"))\n        dec_cipher.update(b(\"XXX\"))\n\n        plaintext = b(\"Reference\") * 10\n        ct, mac = enc_cipher.encrypt_and_digest(plaintext)\n        pt = dec_cipher.decrypt_and_verify(ct, mac)\n\n        self.assertEqual(plaintext, pt)\n\n    def runTest(self):\n        self.right_mac_test()\n        self.wrong_mac_test()\n        self.zero_data()\n        self.multiple_updates()\n        self.no_mix_encrypt_decrypt()\n        self.no_late_update()\n        self.loopback()\n\n    def shortDescription(self):\n        return self.description\n\nclass RoundtripTest(unittest.TestCase):\n    def __init__(self, module, params):\n        from Crypto import Random\n        unittest.TestCase.__init__(self)\n        self.module = module\n        self.iv = Random.get_random_bytes(module.block_size)\n        self.key = b(params['key'])\n        self.plaintext = 100 * b(params['plaintext'])\n        self.module_name = params.get('module_name', None)\n\n    def shortDescription(self):\n        return \"\"\"%s .decrypt() output of .encrypt() should not be garbled\"\"\" % (self.module_name,)\n\n    def runTest(self):\n        for mode in (self.module.MODE_ECB, self.module.MODE_CBC, self.module.MODE_CFB, self.module.MODE_OFB, self.module.MODE_OPENPGP):\n            encryption_cipher = self.module.new(a2b_hex(self.key), mode, self.iv)\n            ciphertext = encryption_cipher.encrypt(self.plaintext)\n\n            if mode != self.module.MODE_OPENPGP:\n                decryption_cipher = self.module.new(a2b_hex(self.key), mode, self.iv)\n            else:\n                eiv = ciphertext[:self.module.block_size+2]\n                ciphertext = ciphertext[self.module.block_size+2:]\n                decryption_cipher = self.module.new(a2b_hex(self.key), mode, eiv)\n            decrypted_plaintext = decryption_cipher.decrypt(ciphertext)\n            self.assertEqual(self.plaintext, decrypted_plaintext)\n\nclass PGPTest(unittest.TestCase):\n    def __init__(self, module, params):\n        unittest.TestCase.__init__(self)\n        self.module = module\n        self.key = b(params['key'])\n\n    def shortDescription(self):\n        return \"MODE_PGP was implemented incorrectly and insecurely. It's completely banished now.\"\n\n    def runTest(self):\n        self.assertRaises(ValueError, self.module.new, a2b_hex(self.key),\n                self.module.MODE_PGP)\n\nclass IVLengthTest(unittest.TestCase):\n    def __init__(self, module, params):\n        unittest.TestCase.__init__(self)\n        self.module = module\n        self.key = b(params['key'])\n\n    def shortDescription(self):\n        return \"Check that all modes except MODE_ECB and MODE_CTR require an IV of the proper length\"\n\n    def runTest(self):\n        self.assertRaises(ValueError, self.module.new, a2b_hex(self.key),\n                self.module.MODE_CBC, \"\")\n        self.assertRaises(ValueError, self.module.new, a2b_hex(self.key),\n                self.module.MODE_CFB, \"\")\n        self.assertRaises(ValueError, self.module.new, a2b_hex(self.key),\n                self.module.MODE_OFB, \"\")\n        self.assertRaises(ValueError, self.module.new, a2b_hex(self.key),\n                self.module.MODE_OPENPGP, \"\")\n        if hasattr(self.module, \"MODE_CCM\"):\n            for ivlen in (0,6,14):\n                self.assertRaises(ValueError, self.module.new, a2b_hex(self.key),\n                    self.module.MODE_CCM, bchr(0)*ivlen, msg_len=10)\n        self.module.new(a2b_hex(self.key), self.module.MODE_ECB, \"\")\n        self.module.new(a2b_hex(self.key), self.module.MODE_CTR, \"\", counter=self._dummy_counter)\n\n    def _dummy_counter(self):\n        return \"\\0\" * self.module.block_size\n\ndef make_block_tests(module, module_name, test_data, additional_params=dict()):\n    tests = []\n    extra_tests_added = 0\n    for i in range(len(test_data)):\n        row = test_data[i]\n\n        # Build the \"params\" dictionary\n        params = {'mode': 'ECB'}\n        if len(row) == 3:\n            (params['plaintext'], params['ciphertext'], params['key']) = row\n        elif len(row) == 4:\n            (params['plaintext'], params['ciphertext'], params['key'], params['description']) = row\n        elif len(row) == 5:\n            (params['plaintext'], params['ciphertext'], params['key'], params['description'], extra_params) = row\n            params.update(extra_params)\n        else:\n            raise AssertionError(\"Unsupported tuple size %d\" % (len(row),))\n\n        # Build the display-name for the test\n        p2 = params.copy()\n        p_key = _extract(p2, 'key')\n        p_plaintext = _extract(p2, 'plaintext')\n        p_ciphertext = _extract(p2, 'ciphertext')\n        p_description = _extract(p2, 'description', None)\n        p_mode = p2.get('mode', 'ECB')\n        if p_mode == 'ECB':\n            _extract(p2, 'mode', 'ECB')\n\n        if p_description is not None:\n            description = p_description\n        elif p_mode == 'ECB' and not p2:\n            description = \"p=%s, k=%s\" % (p_plaintext, p_key)\n        else:\n            description = \"p=%s, k=%s, %r\" % (p_plaintext, p_key, p2)\n        name = \"%s #%d: %s\" % (module_name, i+1, description)\n        params['description'] = name\n        params['module_name'] = module_name\n        params.update(additional_params)\n\n        # Add extra test(s) to the test suite before the current test\n        if not extra_tests_added:\n            tests += [\n                CTRSegfaultTest(module, params),\n                CTRWraparoundTest(module, params),\n                CFBSegmentSizeTest(module, params),\n                RoundtripTest(module, params),\n                PGPTest(module, params),\n                IVLengthTest(module, params),\n            ]\n            extra_tests_added = 1\n\n        # Extract associated data and MAC for AEAD modes\n        if p_mode in ('CCM', 'EAX', 'SIV', 'GCM'):\n            assoc_data, params['plaintext'] = params['plaintext'].split('|')\n            assoc_data2, params['ciphertext'], params['mac'] = params['ciphertext'].split('|')\n            params['assoc_data'] = assoc_data.split(\"-\")\n            params['mac_len'] = len(params['mac'])>>1\n\n        # Add the current test to the test suite\n        tests.append(CipherSelfTest(module, params))\n\n        # When using CTR mode, test that the interface behaves like a stream cipher\n        if p_mode in ('OFB', 'CTR'):\n            tests.append(CipherStreamingSelfTest(module, params))\n\n        # When using CTR mode, test the non-shortcut code path.\n        if p_mode == 'CTR' and not params.has_key('ctr_class'):\n            params2 = params.copy()\n            params2['description'] += \" (shortcut disabled)\"\n            ctr_params2 = params.get('ctr_params', {}).copy()\n            params2['ctr_params'] = ctr_params2\n            if not params2['ctr_params'].has_key('disable_shortcut'):\n                params2['ctr_params']['disable_shortcut'] = 1\n            tests.append(CipherSelfTest(module, params2))\n\n    # Add tests that don't use test vectors\n    if hasattr(module, \"MODE_CCM\"):\n        tests += [\n            CCMMACLengthTest(module),\n            CCMSplitEncryptionTest(module),\n        ]\n    for aead_mode in (\"MODE_CCM\",\"MODE_EAX\", \"MODE_SIV\", \"MODE_GCM\"):\n        if hasattr(module, aead_mode):\n            key_sizes = []\n            try:\n                key_sizes += module.key_size\n            except TypeError:\n                key_sizes = [ module.key_size ]\n            for ks in key_sizes:\n                tests += [\n                    AEADTests(module, aead_mode, ks),\n                ]\n\n    return tests\n\ndef make_stream_tests(module, module_name, test_data):\n    tests = []\n    for i in range(len(test_data)):\n        row = test_data[i]\n\n        # Build the \"params\" dictionary\n        params = {}\n        if len(row) == 3:\n            (params['plaintext'], params['ciphertext'], params['key']) = row\n        elif len(row) == 4:\n            (params['plaintext'], params['ciphertext'], params['key'], params['description']) = row\n        elif len(row) == 5:\n            (params['plaintext'], params['ciphertext'], params['key'], params['description'], extra_params) = row\n            params.update(extra_params)\n        else:\n            raise AssertionError(\"Unsupported tuple size %d\" % (len(row),))\n\n        # Build the display-name for the test\n        p2 = params.copy()\n        p_key = _extract(p2, 'key')\n        p_plaintext = _extract(p2, 'plaintext')\n        p_ciphertext = _extract(p2, 'ciphertext')\n        p_description = _extract(p2, 'description', None)\n\n        if p_description is not None:\n            description = p_description\n        elif not p2:\n            description = \"p=%s, k=%s\" % (p_plaintext, p_key)\n        else:\n            description = \"p=%s, k=%s, %r\" % (p_plaintext, p_key, p2)\n        name = \"%s #%d: %s\" % (module_name, i+1, description)\n        params['description'] = name\n        params['module_name'] = module_name\n\n        # Add the test to the test suite\n        tests.append(CipherSelfTest(module, params))\n        tests.append(CipherStreamingSelfTest(module, params))\n    return tests\n\n# vim:set ts=4 sw=4 sts=4 expandtab:\n", "\n/* -*- C -*- */\n/*\n *  block_template.c : Generic framework for block encryption algorithms\n *\n * Written by Andrew Kuchling and others\n *\n * ===================================================================\n * The contents of this file are dedicated to the public domain.  To\n * the extent that dedication to the public domain is not available,\n * everyone is granted a worldwide, perpetual, royalty-free,\n * non-exclusive license to exercise all rights associated with the\n * contents of this file for any purpose whatsoever.\n * No rights are reserved.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n * ===================================================================\n */\n\n#include \"pycrypto_common.h\"\n#include \"modsupport.h\"\n#include <string.h>\n#include \"_counter.h\"\n\n/* Cipher operation modes */\n\n#define MODE_ECB 1\n#define MODE_CBC 2\n#define MODE_CFB 3\n#define MODE_PGP 4\n#define MODE_OFB 5\n#define MODE_CTR 6\n\n#define _STR(x) #x\n#define _XSTR(x) _STR(x)\n#define _PASTE(x,y) x##y\n#define _PASTE2(x,y) _PASTE(x,y)\n#ifdef IS_PY3K\n#define _MODULE_NAME _PASTE2(PyInit_,MODULE_NAME)\n#else\n#define _MODULE_NAME _PASTE2(init,MODULE_NAME)\n#endif\n#define _MODULE_STRING _XSTR(MODULE_NAME)\n\n/* Object references for the counter_shortcut */\nstatic PyObject *_counter_module = NULL;\nstatic PyTypeObject *PCT_CounterBEType = NULL;\nstatic PyTypeObject *PCT_CounterLEType = NULL;\n\ntypedef struct \n{\n\tPyObject_HEAD \n\tint mode, count, segment_size;\n\tunsigned char IV[BLOCK_SIZE], oldCipher[BLOCK_SIZE];\n\tPyObject *counter;\n\tint counter_shortcut;\n\tblock_state st;\n} ALGobject;\n\n/* Please see PEP3123 for a discussion of PyObject_HEAD and changes made in 3.x to make it conform to Standard C.\n * These changes also dictate using Py_TYPE to check type, and PyVarObject_HEAD_INIT(NULL, 0) to initialize\n */\nstaticforward PyTypeObject ALGtype;\n\nstatic ALGobject *\nnewALGobject(void)\n{\n\tALGobject * new;\n\tnew = PyObject_New(ALGobject, &ALGtype);\n\tnew->mode = MODE_ECB;\n\tnew->counter = NULL;\n\tnew->counter_shortcut = 0;\n\treturn new;\n}\n\nstatic void\nALGdealloc(PyObject *ptr)\n{\t\t\n\tALGobject *self = (ALGobject *)ptr;\n\n\t/* Overwrite the contents of the object */\n\tPy_XDECREF(self->counter);\n\tself->counter = NULL;\n\tmemset(self->IV, 0, BLOCK_SIZE);\n\tmemset(self->oldCipher, 0, BLOCK_SIZE);\n\tmemset((char*)&(self->st), 0, sizeof(block_state));\n\tself->mode = self->count = self->segment_size = 0;\n\tPyObject_Del(ptr);\n}\n\n\n\nstatic char ALGnew__doc__[] = \n\"new(key, [mode], [IV]): Return a new \" _MODULE_STRING \" encryption object.\";\n\nstatic char *kwlist[] = {\"key\", \"mode\", \"IV\", \"counter\", \"segment_size\",\n#ifdef PCT_ARC2_MODULE\n                         \"effective_keylen\",\n#endif\n\t\t\t NULL};\n\nstatic ALGobject *\nALGnew(PyObject *self, PyObject *args, PyObject *kwdict)\n{\n\tunsigned char *key, *IV;\n\tALGobject * new=NULL;\n\tint keylen, IVlen=0, mode=MODE_ECB, segment_size=0;\n\tPyObject *counter = NULL;\n\tint counter_shortcut = 0;\n#ifdef PCT_ARC2_MODULE\n        int effective_keylen = 1024;    /* this is a weird default, but it's compatible with old versions of PyCrypto */\n#endif\n\t/* Set default values */\n\tif (!PyArg_ParseTupleAndKeywords(args, kwdict, \"s#|is#Oi\"\n#ifdef PCT_ARC2_MODULE\n\t\t\t\t\t \"i\"\n#endif\n\t\t\t\t\t , kwlist,\n\t\t\t\t\t &key, &keylen, &mode, &IV, &IVlen,\n\t\t\t\t\t &counter, &segment_size\n#ifdef PCT_ARC2_MODULE\n\t\t\t\t\t , &effective_keylen\n#endif\n\t\t)) \n\t{\n\t\treturn NULL;\n\t}\n\n\tif (mode<MODE_ECB || mode>MODE_CTR) \n\t{\n\t\tPyErr_Format(PyExc_ValueError, \n\t\t\t     \"Unknown cipher feedback mode %i\",\n\t\t\t     mode);\n\t\treturn NULL;\n\t}\n\tif (mode == MODE_PGP) {\n\t\tPyErr_Format(PyExc_ValueError, \n\t\t\t     \"MODE_PGP is not supported anymore\");\n\t\treturn NULL;\n\t}\n\tif (KEY_SIZE!=0 && keylen!=KEY_SIZE)\n\t{\n\t\tPyErr_Format(PyExc_ValueError,\n\t\t\t     \"Key must be %i bytes long, not %i\",\n\t\t\t     KEY_SIZE, keylen);\n\t\treturn NULL;\n\t}\n\tif (KEY_SIZE==0 && keylen==0)\n\t{\n\t\tPyErr_SetString(PyExc_ValueError,\n\t\t\t\t\"Key cannot be the null string\");\n\t\treturn NULL;\n\t}\n\tif (IVlen != BLOCK_SIZE && mode != MODE_ECB && mode != MODE_CTR)\n\t{\n\t\tPyErr_Format(PyExc_ValueError,\n\t\t\t     \"IV must be %i bytes long\", BLOCK_SIZE);\n\t\treturn NULL;\n\t}\n\n\t/* Mode-specific checks */\n\tif (mode == MODE_CFB) {\n\t\tif (segment_size == 0) segment_size = 8;\n\t\tif (segment_size < 1 || segment_size > BLOCK_SIZE*8 || ((segment_size & 7) != 0)) {\n\t\t\tPyErr_Format(PyExc_ValueError, \n\t\t\t\t     \"segment_size must be multiple of 8 (bits) \"\n\t\t\t\t     \"between 1 and %i\", BLOCK_SIZE*8);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tif (mode == MODE_CTR) {\n\t\tif (counter == NULL) {\n\t\t\tPyErr_SetString(PyExc_TypeError,\n\t\t\t\t\t\"'counter' keyword parameter is required with CTR mode\");\n\t\t\treturn NULL;\n\t\t} else if (Py_TYPE(counter) == PCT_CounterBEType || Py_TYPE(counter) == PCT_CounterLEType) {\n\t\t\tcounter_shortcut = 1;\n\t\t} else if (!PyCallable_Check(counter)) {\n\t\t\tPyErr_SetString(PyExc_ValueError, \n\t\t\t\t\t\"'counter' parameter must be a callable object\");\n\t\t\treturn NULL;\n\t\t}\n\t} else {\n\t\tif (counter != NULL) {\n\t\t\tPyErr_SetString(PyExc_ValueError, \n\t\t\t\t\t\"'counter' parameter only useful with CTR mode\");\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t/* Cipher-specific checks */\n#ifdef PCT_ARC2_MODULE\n        if (effective_keylen<0 || effective_keylen>1024) {\n\t\tPyErr_Format(PyExc_ValueError,\n\t\t\t     \"RC2: effective_keylen must be between 0 and 1024, not %i\",\n\t\t\t     effective_keylen);\n\t\treturn NULL;\n        }\n#endif\n\n\t/* Copy parameters into object */\n\tnew = newALGobject();\n\tnew->segment_size = segment_size;\n\tnew->counter = counter;\n\tPy_XINCREF(counter);\n\tnew->counter_shortcut = counter_shortcut;\n#ifdef PCT_ARC2_MODULE\n        new->st.effective_keylen = effective_keylen;\n#endif\n\n\tblock_init(&(new->st), key, keylen);\n\tif (PyErr_Occurred())\n\t{\n\t\tPy_DECREF(new);\n\t\treturn NULL;\n\t}\n\tmemset(new->IV, 0, BLOCK_SIZE);\n\tmemset(new->oldCipher, 0, BLOCK_SIZE);\n\tmemcpy(new->IV, IV, IVlen);\n\tnew->mode = mode;\n\tnew->count=BLOCK_SIZE;   /* stores how many bytes in new->oldCipher have been used */\n\treturn new;\n}\n\nstatic char ALG_Encrypt__doc__[] =\n\"Encrypt the provided string of binary data.\";\n\nstatic PyObject *\nALG_Encrypt(ALGobject *self, PyObject *args)\n{\n\tunsigned char *buffer, *str;\n\tunsigned char temp[BLOCK_SIZE];\n\tint i, j, len;\n\tPyObject *result;\n  \n\tif (!PyArg_Parse(args, \"s#\", &str, &len))\n\t\treturn NULL;\n\tif (len==0)\t\t\t/* Handle empty string */\n\t{\n\t\treturn PyBytes_FromStringAndSize(NULL, 0);\n\t}\n\tif ( (len % BLOCK_SIZE) !=0 && \n\t     (self->mode!=MODE_CFB) &&\n\t     (self->mode!=MODE_OFB) &&\n\t     (self->mode!=MODE_CTR))\n\t{\n\t\tPyErr_Format(PyExc_ValueError, \n\t\t\t     \"Input strings must be \"\n\t\t\t     \"a multiple of %i in length\",\n\t\t\t     BLOCK_SIZE);\n\t\treturn NULL;\n\t}\n\tif (self->mode == MODE_CFB && \n\t    (len % (self->segment_size/8) !=0)) {\n\t\tPyErr_Format(PyExc_ValueError, \n\t\t\t     \"Input strings must be a multiple of \"\n\t\t\t     \"the segment size %i in length\",\n\t\t\t     self->segment_size/8);\n\t\treturn NULL;\n\t}\n\n\tbuffer=malloc(len);\n\tif (buffer==NULL) \n\t{\n\t\tPyErr_SetString(PyExc_MemoryError, \n\t\t\t\t\"No memory available in \"\n\t\t\t\t_MODULE_STRING \" encrypt\");\n\t\treturn NULL;\n\t}\n\tPy_BEGIN_ALLOW_THREADS;\n\tswitch(self->mode)\n\t{\n\tcase(MODE_ECB):      \n\t\tfor(i=0; i<len; i+=BLOCK_SIZE) \n\t\t{\n\t\t\tblock_encrypt(&(self->st), str+i, buffer+i);\n\t\t}\n\t\tbreak;\n\n\tcase(MODE_CBC):      \n\t\tfor(i=0; i<len; i+=BLOCK_SIZE) \n\t\t{\n\t\t\tfor(j=0; j<BLOCK_SIZE; j++)\n\t\t\t{\n\t\t\t\ttemp[j]=str[i+j]^self->IV[j];\n\t\t\t}\n\t\t\tblock_encrypt(&(self->st), temp, buffer+i);\n\t\t\tmemcpy(self->IV, buffer+i, BLOCK_SIZE);\n\t\t}\n\t\tbreak;\n\n\tcase(MODE_CFB):      \n\t\tfor(i=0; i<len; i+=self->segment_size/8) \n\t\t{\n\t\t\tblock_encrypt(&(self->st), self->IV, temp);\n\t\t\tfor (j=0; j<self->segment_size/8; j++) {\n\t\t\t\tbuffer[i+j] = str[i+j] ^ temp[j];\n\t\t\t}\n\t\t\tif (self->segment_size == BLOCK_SIZE * 8) {\n\t\t\t\t/* s == b: segment size is identical to \n\t\t\t\t   the algorithm block size */\n\t\t\t\tmemcpy(self->IV, buffer + i, BLOCK_SIZE);\n\t\t\t}\n\t\t\telse if ((self->segment_size % 8) == 0) {\n\t\t\t\tint sz = self->segment_size/8;\n\t\t\t\tmemmove(self->IV, self->IV + sz, \n\t\t\t\t\tBLOCK_SIZE-sz);\n\t\t\t\tmemcpy(self->IV + BLOCK_SIZE - sz, buffer + i,\n\t\t\t\t       sz);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* segment_size is not a multiple of 8; \n\t\t\t\t   currently this can't happen */\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase(MODE_OFB):\n\t\t/* OFB mode is a stream cipher whose keystream is generated by encrypting the previous ciphered output.\n\t\t * - self->IV stores the current keystream block\n\t\t * - self->count indicates the current offset within the current keystream block\n\t\t * - str stores the input string\n\t\t * - buffer stores the output string\n\t\t * - len indicates the length of the input and output strings\n\t\t * - i indicates the current offset within the input and output strings\n\t\t * (len-i) is the number of bytes remaining to encrypt\n\t\t * (BLOCK_SIZE-self->count) is the number of bytes remaining in the current keystream block\n\t\t */\n\t\ti = 0;\n\t\twhile(i < len)\n\t\t{\n\t\t\t/* If we don't need more than what remains of the current keystream block, then just XOR it in */\n\t\t\tif (len-i <= BLOCK_SIZE-self->count) { /* remaining_bytes_to_encrypt <= remaining_bytes_in_IV */\n\t\t\t\t/* XOR until the input is used up */\n\t\t\t\tfor(j=0; j<(len-i); j++) {\n\t\t\t\t\tassert(i+j < len);\n\t\t\t\t\tassert(self->count+j < BLOCK_SIZE);\n\t\t\t\t\tbuffer[i+j] = self->IV[self->count+j] ^ str[i+j];\n\t\t\t\t}\n\t\t\t\tself->count += len-i;\n\t\t\t\ti = len;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Use up the current keystream block */\n\t\t\tfor(j=0; j<BLOCK_SIZE-self->count; j++) {\n\t\t\t\tassert(i+j < len);\n\t\t\t\tassert(self->count+j < BLOCK_SIZE);\n\t\t\t\tbuffer[i+j] = self->IV[self->count+j] ^ str[i+j];\n\t\t\t}\n\t\t\ti += BLOCK_SIZE-self->count;\n\t\t\tself->count = BLOCK_SIZE;\n\n\t\t\t/* Generate a new keystream block */\n\t\t\tblock_encrypt(&(self->st), self->IV, temp);\n\t\t\tmemcpy(self->IV, temp, BLOCK_SIZE);\n\n\t\t\t/* Move the pointer to the start of the keystream */\n\t\t\tself->count = 0;\n\t\t}\n\t\tbreak;\n\n\tcase(MODE_CTR):\n\t\t/* CTR mode is a stream cipher whose keystream is generated by encrypting unique counter values.\n\t\t * - self->counter points to the Counter callable, which is\n\t\t *   responsible for generating keystream blocks\n\t\t * - self->count indicates the current offset within the current keystream block\n\t\t * - self->IV stores the current keystream block\n\t\t * - str stores the input string\n\t\t * - buffer stores the output string\n\t\t * - len indicates the length if the input and output strings\n\t\t * - i indicates the current offset within the input and output strings\n\t\t * - (len-i) is the number of bytes remaining to encrypt\n\t\t * - (BLOCK_SIZE-self->count) is the number of bytes remaining in the current keystream block\n\t\t */\n\t\ti = 0;\n\t\twhile (i < len) {\n\t\t\t/* If we don't need more than what remains of the current keystream block, then just XOR it in */\n\t\t\tif (len-i <= BLOCK_SIZE-self->count) { /* remaining_bytes_to_encrypt <= remaining_bytes_in_IV */\n\t\t\t\t/* XOR until the input is used up */\n\t\t\t\tfor(j=0; j<(len-i); j++) {\n\t\t\t\t\tassert(i+j < len);\n\t\t\t\t\tassert(self->count+j < BLOCK_SIZE);\n\t\t\t\t\tbuffer[i+j] = (self->IV[self->count+j] ^= str[i+j]);\n\t\t\t\t}\n\t\t\t\tself->count += len-i;\n\t\t\t\ti = len;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Use up the current keystream block */\n\t\t\tfor(j=0; j<BLOCK_SIZE-self->count; j++) {\n\t\t\t\tassert(i+j < len);\n\t\t\t\tassert(self->count+j < BLOCK_SIZE);\n\t\t\t\tbuffer[i+j] = (self->IV[self->count+j] ^= str[i+j]);\n\t\t\t}\n\t\t\ti += BLOCK_SIZE-self->count;\n\t\t\tself->count = BLOCK_SIZE;\n\n\t\t\t/* Generate a new keystream block */\n\t\t\tif (self->counter_shortcut) {\n\t\t\t\t/* CTR mode shortcut: If we're using Util.Counter,\n\t\t\t\t * bypass the normal Python function call mechanism\n\t\t\t\t * and manipulate the counter directly. */\n\n\t\t\t\tPCT_CounterObject *ctr = (PCT_CounterObject *)(self->counter);\n\t\t\t\tif (ctr->carry && !ctr->allow_wraparound) {\n\t\t\t\t\tPy_BLOCK_THREADS;\n\t\t\t\t\tPyErr_SetString(PyExc_OverflowError,\n\t\t\t\t\t\t\t\"counter wrapped without allow_wraparound\");\n\t\t\t\t\tfree(buffer);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tif (ctr->buf_size != BLOCK_SIZE) {\n\t\t\t\t\tPy_BLOCK_THREADS;\n\t\t\t\t\tPyErr_Format(PyExc_TypeError,\n\t\t\t\t\t\t     \"CTR counter function returned \"\n\t\t\t\t\t\t     \"string of length %zi, not %i\",\n\t\t\t\t\t\t     ctr->buf_size, BLOCK_SIZE);\n\t\t\t\t\tfree(buffer);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tblock_encrypt(&(self->st),\n\t\t\t\t\t      (unsigned char *)ctr->val,\n\t\t\t\t\t      self->IV);\n\t\t\t\tctr->inc_func(ctr);\n\t\t\t} else {\n\t\t\t\tPyObject *ctr;\n\t\t\t\tPy_BLOCK_THREADS;\n\t\t\t\tctr = PyObject_CallObject(self->counter, NULL);\n\t\t\t\tif (ctr == NULL) {\n\t\t\t\t\tfree(buffer);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tif (!PyBytes_Check(ctr))\n\t\t\t\t{\n\t\t\t\t\tPyErr_SetString(PyExc_TypeError,\n\t\t\t\t\t\t\t\"CTR counter function didn't return a bytestring\");\n\t\t\t\t\tPy_DECREF(ctr);\n\t\t\t\t\tfree(buffer);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tif (PyBytes_Size(ctr) != BLOCK_SIZE) {\n\t\t\t\t\tPyErr_Format(PyExc_TypeError,\n\t\t\t\t\t\t     \"CTR counter function returned \"\n\t\t\t\t\t\t     \"bytestring not of length %i\",\n\t\t\t\t\t\t     BLOCK_SIZE);\n\t\t\t\t\tPy_DECREF(ctr);\n\t\t\t\t\tfree(buffer);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tPy_UNBLOCK_THREADS;\n\t\t\t\tblock_encrypt(&(self->st), (unsigned char *)PyBytes_AsString(ctr),\n\t\t\t\t\t      self->IV);\n\t\t\t\tPy_BLOCK_THREADS;\n\t\t\t\tPy_DECREF(ctr);\n\t\t\t\tPy_UNBLOCK_THREADS;\n\t\t\t}\n\n\t\t\t/* Move the pointer to the start of the keystream block */\n\t\t\tself->count = 0;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tPy_BLOCK_THREADS;\n\t\tPyErr_Format(PyExc_SystemError, \n\t\t\t     \"Unknown ciphertext feedback mode %i; \"\n\t\t\t     \"this shouldn't happen\",\n\t\t\t     self->mode);\n\t\tfree(buffer);\n\t\treturn NULL;\n\t}\n\tPy_END_ALLOW_THREADS;\n\tresult=PyBytes_FromStringAndSize((char *) buffer, len);\n\tfree(buffer);\n\treturn(result);\n}\n\nstatic char ALG_Decrypt__doc__[] =\n\"decrypt(string): Decrypt the provided string of binary data.\";\n\n\n\n\nstatic PyObject *\nALG_Decrypt(ALGobject *self, PyObject *args)\n{\n\tunsigned char *buffer, *str;\n\tunsigned char temp[BLOCK_SIZE];\n\tint i, j, len;\n\tPyObject *result;\n\n\t/* CTR and OFB mode decryption is identical to encryption */\n\tif (self->mode == MODE_CTR || self->mode == MODE_OFB)\n\t\treturn ALG_Encrypt(self, args);\n\n\tif (!PyArg_Parse(args, \"s#\", &str, &len))\n\t\treturn NULL;\n\tif (len==0)\t\t\t/* Handle empty string */\n\t{\n\t\treturn PyBytes_FromStringAndSize(NULL, 0);\n\t}\n\tif ( (len % BLOCK_SIZE) !=0 && (self->mode!=MODE_CFB))\n\t{\n\t\tPyErr_Format(PyExc_ValueError, \n\t\t\t     \"Input strings must be \"\n\t\t\t     \"a multiple of %i in length\",\n\t\t\t     BLOCK_SIZE);\n\t\treturn NULL;\n\t}\n\tif (self->mode == MODE_CFB && \n\t    (len % (self->segment_size/8) !=0)) {\n\t\tPyErr_Format(PyExc_ValueError, \n\t\t\t     \"Input strings must be a multiple of \"\n\t\t\t     \"the segment size %i in length\",\n\t\t\t     self->segment_size/8);\n\t\treturn NULL;\n\t}\n\tbuffer=malloc(len);\n\tif (buffer==NULL) \n\t{\n\t\tPyErr_SetString(PyExc_MemoryError, \n\t\t\t\t\"No memory available in \" _MODULE_STRING\n\t\t\t\t\" decrypt\");\n\t\treturn NULL;\n\t}\n\tPy_BEGIN_ALLOW_THREADS;\n\tswitch(self->mode)\n\t{\n\tcase(MODE_ECB):      \n\t\tfor(i=0; i<len; i+=BLOCK_SIZE) \n\t\t{\n\t\t\tblock_decrypt(&(self->st), str+i, buffer+i);\n\t\t}\n\t\tbreak;\n\n\tcase(MODE_CBC):      \n\t\tfor(i=0; i<len; i+=BLOCK_SIZE) \n\t\t{\n\t\t\tmemcpy(self->oldCipher, self->IV, BLOCK_SIZE);\n\t\t\tblock_decrypt(&(self->st), str+i, temp);\n\t\t\tfor(j=0; j<BLOCK_SIZE; j++) \n\t\t\t{\n\t\t\t\tbuffer[i+j]=temp[j]^self->IV[j];\n\t\t\t\tself->IV[j]=str[i+j];\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase(MODE_CFB):      \n\t\tfor(i=0; i<len; i+=self->segment_size/8) \n\t\t{\n\t\t\tblock_encrypt(&(self->st), self->IV, temp);\n\t\t\tfor (j=0; j<self->segment_size/8; j++) {\n\t\t\t\tbuffer[i+j] = str[i+j]^temp[j];\n\t\t\t}\n\t\t\tif (self->segment_size == BLOCK_SIZE * 8) {\n\t\t\t\t/* s == b: segment size is identical to \n\t\t\t\t   the algorithm block size */\n\t\t\t\tmemcpy(self->IV, str + i, BLOCK_SIZE);\n\t\t\t}\n\t\t\telse if ((self->segment_size % 8) == 0) {\n\t\t\t\tint sz = self->segment_size/8;\n\t\t\t\tmemmove(self->IV, self->IV + sz, \n\t\t\t\t\tBLOCK_SIZE-sz);\n\t\t\t\tmemcpy(self->IV + BLOCK_SIZE - sz, str + i, \n\t\t\t\t       sz);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* segment_size is not a multiple of 8; \n\t\t\t\t   currently this can't happen */\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tPy_BLOCK_THREADS;\n\t\tPyErr_Format(PyExc_SystemError, \n\t\t\t     \"Unknown ciphertext feedback mode %i; \"\n\t\t\t     \"this shouldn't happen\",\n\t\t\t     self->mode);\n\t\tfree(buffer);\n\t\treturn NULL;\n\t}\n\tPy_END_ALLOW_THREADS;\n\tresult=PyBytes_FromStringAndSize((char *) buffer, len);\n\tfree(buffer);\n\treturn(result);\n}\n\n/* ALG object methods */\nstatic PyMethodDef ALGmethods[] =\n{\n {\"encrypt\", (PyCFunction) ALG_Encrypt, METH_O, ALG_Encrypt__doc__},\n {\"decrypt\", (PyCFunction) ALG_Decrypt, METH_O, ALG_Decrypt__doc__},\n {NULL, NULL}\t\t\t/* sentinel */\n};\n\nstatic int\nALGsetattr(PyObject *ptr, char *name, PyObject *v)\n{\n  ALGobject *self=(ALGobject *)ptr;\n  if (strcmp(name, \"IV\") != 0) \n    {\n      PyErr_Format(PyExc_AttributeError,\n\t\t   \"non-existent block cipher object attribute '%s'\",\n\t\t   name);\n      return -1;\n    }\n  if (v==NULL)\n    {\n      PyErr_SetString(PyExc_AttributeError,\n\t\t      \"Can't delete IV attribute of block cipher object\");\n      return -1;\n    }\n  if (!PyBytes_Check(v))\n    {\n      PyErr_SetString(PyExc_TypeError,\n\t\t\t  \"IV attribute of block cipher object must be bytestring\");\n      return -1;\n    }\n  if (PyBytes_Size(v)!=BLOCK_SIZE) \n    {\n      PyErr_Format(PyExc_ValueError, \n\t\t   _MODULE_STRING \" IV must be %i bytes long\",\n\t\t   BLOCK_SIZE);\n      return -1;\n    }\n  memcpy(self->IV, PyBytes_AsString(v), BLOCK_SIZE);\n  return 0;\n}\n\nstatic PyObject *\nALGgetattro(PyObject *s, PyObject *attr)\n{\n  ALGobject *self = (ALGobject*)s;\n\n  if (!PyString_Check(attr))\n\tgoto generic;\n\n  if (PyString_CompareWithASCIIString(attr, \"IV\") == 0)\n    {\n      return(PyBytes_FromStringAndSize((char *) self->IV, BLOCK_SIZE));\n    }\n  if (PyString_CompareWithASCIIString(attr, \"mode\") == 0)\n     {\n       return(PyInt_FromLong((long)(self->mode)));\n     }\n  if (PyString_CompareWithASCIIString(attr, \"block_size\") == 0)\n     {\n       return PyInt_FromLong(BLOCK_SIZE);\n     }\n  if (PyString_CompareWithASCIIString(attr, \"key_size\") == 0)\n     {\n       return PyInt_FromLong(KEY_SIZE);\n     }\n  generic:\n#if PYTHON_API_VERSION >= 1011          /* Python 2.2 and later */\n\treturn PyObject_GenericGetAttr(s, attr);\n#else\n\tif (PyString_Check(attr) < 0) {\n\t\tPyErr_SetObject(PyExc_AttributeError, attr);\n\t\treturn NULL;\n\t}\n\treturn Py_FindMethod(ALGmethods, (PyObject *)self, PyString_AsString(attr));\n#endif\n}\n\n/* List of functions defined in the module */\n\nstatic struct PyMethodDef modulemethods[] =\n{\n {\"new\", (PyCFunction) ALGnew, METH_VARARGS|METH_KEYWORDS, ALGnew__doc__},\n {NULL, NULL}\t\t\t/* sentinel */\n};\n\nstatic PyTypeObject ALGtype =\n{\n\tPyVarObject_HEAD_INIT(NULL, 0)  /* deferred type init for compilation on Windows, type will be filled in at runtime */\n\t_MODULE_STRING,\t\t/*tp_name*/\n\tsizeof(ALGobject),\t/*tp_size*/\n\t0,\t\t\t\t/*tp_itemsize*/\n\t/* methods */\n\t(destructor) ALGdealloc,\t/*tp_dealloc*/\n\t0,\t\t\t\t/*tp_print*/\n\t0,\t\t\t\t/*tp_getattr*/\n\tALGsetattr,    /*tp_setattr*/\n\t0,\t\t\t/*tp_compare*/\n\t(reprfunc) 0,\t\t\t\t/*tp_repr*/\n\t0,\t\t\t\t/*tp_as_number*/\n\t0,\t\t\t\t/*tp_as_sequence */\n\t0,\t\t\t\t/*tp_as_mapping */\n\t0,\t\t\t\t/*tp_hash*/\n\t0,\t\t\t\t/*tp_call*/\n\t0,\t\t\t\t/*tp_str*/\n\tALGgetattro,\t/*tp_getattro*/\n\t0,\t\t\t\t/*tp_setattro*/\n\t0,\t\t\t\t/*tp_as_buffer*/\n\tPy_TPFLAGS_DEFAULT,\t\t/*tp_flags*/\n\t0,\t\t\t\t/*tp_doc*/\n\t0,\t\t\t\t/*tp_traverse*/\n\t0,\t\t\t\t/*tp_clear*/\n\t0,\t\t\t\t/*tp_richcompare*/\n\t0,\t\t\t\t/*tp_weaklistoffset*/\n#if PYTHON_API_VERSION >= 1011          /* Python 2.2 and later */\n\t0,\t\t\t\t/*tp_iter*/\n\t0,\t\t\t\t/*tp_iternext*/\n\tALGmethods,\t\t/*tp_methods*/\n#endif\n};\n\n#ifdef IS_PY3K\nstatic struct PyModuleDef moduledef = {\n\tPyModuleDef_HEAD_INIT,\n\t\"Crypto.Cipher.\" _MODULE_STRING,\n\tNULL,\n\t-1,\n\tmodulemethods,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL\n};\n#endif\n\n/* Initialization function for the module */\nPyMODINIT_FUNC\n_MODULE_NAME (void)\n{\n\tPyObject *m = NULL;\n\tPyObject *abiver = NULL;\n\tPyObject *__all__ = NULL;\n\n\tif (PyType_Ready(&ALGtype) < 0)\n\t\tgoto errout;\n\n\t/* Create the module and add the functions */\n#ifdef IS_PY3K\n\tm = PyModule_Create(&moduledef);\n#else\n\tm = Py_InitModule(\"Crypto.Cipher.\" _MODULE_STRING, modulemethods);\n#endif\n\tif (m == NULL)\n\t\tgoto errout;\n\n\t/* Add the type object to the module (using the name of the module itself),\n\t * so that its methods docstrings are discoverable by introspection tools. */\n\tPyObject_SetAttrString(m, _MODULE_STRING, (PyObject *)&ALGtype);\n\n\t/* Add some symbolic constants to the module */\n\tPyModule_AddIntConstant(m, \"MODE_ECB\", MODE_ECB);\n\tPyModule_AddIntConstant(m, \"MODE_CBC\", MODE_CBC);\n\tPyModule_AddIntConstant(m, \"MODE_CFB\", MODE_CFB);\n\tPyModule_AddIntConstant(m, \"MODE_PGP\", MODE_PGP); /** Vestigial **/\n\tPyModule_AddIntConstant(m, \"MODE_OFB\", MODE_OFB);\n\tPyModule_AddIntConstant(m, \"MODE_CTR\", MODE_CTR);\n\tPyModule_AddIntConstant(m, \"block_size\", BLOCK_SIZE);\n\tPyModule_AddIntConstant(m, \"key_size\", KEY_SIZE);\n\n\t/* Import CounterBE and CounterLE from the _counter module */\n\tPy_CLEAR(_counter_module);\n\t_counter_module = PyImport_ImportModule(\"Crypto.Util._counter\");\n\tif (_counter_module == NULL)\n\t\tgoto errout;\n\tPCT_CounterBEType = (PyTypeObject *)PyObject_GetAttrString(_counter_module, \"CounterBE\");\n\tPCT_CounterLEType = (PyTypeObject *)PyObject_GetAttrString(_counter_module, \"CounterLE\");\n\n\t/* Simple ABI version check in case the user doesn't re-compile all of\n\t * the modules during an upgrade. */\n\tabiver = PyObject_GetAttrString(_counter_module, \"_PCT_CTR_ABI_VERSION\");\n\tif (PCT_CounterBEType == NULL || PyType_Check((PyObject *)PCT_CounterBEType) < 0 ||\n\t\t PCT_CounterLEType == NULL || PyType_Check((PyObject *)PCT_CounterLEType) < 0 ||\n\t\t abiver == NULL || PyInt_CheckExact(abiver) < 0 || PyInt_AS_LONG(abiver) != PCT_CTR_ABI_VERSION)\n\t{\n\t\tPyErr_SetString(PyExc_ImportError, \"Crypto.Util._counter ABI mismatch.  Was PyCrypto incorrectly compiled?\");\n\t\tgoto errout;\n\t}\n\n\t/* Create __all__ (to help generate documentation) */\n\t__all__ = PyList_New(10);\n\tif (__all__ == NULL)\n\t\tgoto errout;\n\tPyList_SetItem(__all__, 0, PyString_FromString(_MODULE_STRING));\t/* This is the ALGType object */\n\tPyList_SetItem(__all__, 1, PyString_FromString(\"new\"));\n\tPyList_SetItem(__all__, 2, PyString_FromString(\"MODE_ECB\"));\n\tPyList_SetItem(__all__, 3, PyString_FromString(\"MODE_CBC\"));\n\tPyList_SetItem(__all__, 4, PyString_FromString(\"MODE_CFB\"));\n\tPyList_SetItem(__all__, 5, PyString_FromString(\"MODE_PGP\"));\n\tPyList_SetItem(__all__, 6, PyString_FromString(\"MODE_OFB\"));\n\tPyList_SetItem(__all__, 7, PyString_FromString(\"MODE_CTR\"));\n\tPyList_SetItem(__all__, 8, PyString_FromString(\"block_size\"));\n\tPyList_SetItem(__all__, 9, PyString_FromString(\"key_size\"));\n\tPyObject_SetAttrString(m, \"__all__\", __all__);\n\nout:\n\t/* Final error check */\n\tif (m == NULL && !PyErr_Occurred()) {\n\t\tPyErr_SetString(PyExc_ImportError, \"can't initialize module\");\n\t\tgoto errout;\n\t}\n\n\t/* Free local objects here */\n\tPy_CLEAR(abiver);\n\tPy_CLEAR(__all__);\n\n\t/* Return */\n#ifdef IS_PY3K\n\treturn m;\n#else\n\treturn;\n#endif\n\nerrout:\n\t/* Free the module and other global objects here */\n\tPy_CLEAR(m);\n\tPy_CLEAR(_counter_module);\n\tPy_CLEAR(PCT_CounterBEType);\n\tPy_CLEAR(PCT_CounterLEType);\n\tgoto out;\n}\n/* vim:set ts=4 sw=4 sts=0 noexpandtab: */\n"], "fixing_code": ["# -*- coding: utf-8 -*-\n#\n#  SelfTest/Hash/common.py: Common code for Crypto.SelfTest.Hash\n#\n# Written in 2008 by Dwayne C. Litzenberger <dlitz@dlitz.net>\n#\n# ===================================================================\n# The contents of this file are dedicated to the public domain.  To\n# the extent that dedication to the public domain is not available,\n# everyone is granted a worldwide, perpetual, royalty-free,\n# non-exclusive license to exercise all rights associated with the\n# contents of this file for any purpose whatsoever.\n# No rights are reserved.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n# SOFTWARE.\n# ===================================================================\n\n\"\"\"Self-testing for PyCrypto hash modules\"\"\"\n\nfrom __future__ import nested_scopes\n\n__revision__ = \"$Id$\"\n\nimport sys\nif sys.version_info[0] == 2 and sys.version_info[1] == 1:\n    from Crypto.Util.py21compat import *\n\nimport unittest\nfrom binascii import a2b_hex, b2a_hex, hexlify\n\nfrom Crypto.Util.py3compat import *\nfrom Crypto.Util.strxor import strxor_c\n\n# For compatibility with Python 2.1 and Python 2.2\nif sys.hexversion < 0x02030000:\n    # Python 2.1 doesn't have a dict() function\n    # Python 2.2 dict() function raises TypeError if you do dict(MD5='blah')\n    def dict(**kwargs):\n        return kwargs.copy()\nelse:\n    dict = dict\n\nclass _NoDefault: pass        # sentinel object\ndef _extract(d, k, default=_NoDefault):\n    \"\"\"Get an item from a dictionary, and remove it from the dictionary.\"\"\"\n    try:\n        retval = d[k]\n    except KeyError:\n        if default is _NoDefault:\n            raise\n        return default\n    del d[k]\n    return retval\n\n# Generic cipher test case\nclass CipherSelfTest(unittest.TestCase):\n\n    def __init__(self, module, params):\n        unittest.TestCase.__init__(self)\n        self.module = module\n\n        # Extract the parameters\n        params = params.copy()\n        self.description = _extract(params, 'description')\n        self.key = b(_extract(params, 'key'))\n        self.plaintext = b(_extract(params, 'plaintext'))\n        self.ciphertext = b(_extract(params, 'ciphertext'))\n        self.module_name = _extract(params, 'module_name', None)\n        self.assoc_data = _extract(params, 'assoc_data', None)\n        self.mac = _extract(params, 'mac', None)\n        if self.assoc_data:\n            self.mac = b(self.mac)\n\n        mode = _extract(params, 'mode', None)\n        self.mode_name = str(mode)\n        if mode is not None:\n            # Block cipher\n            self.mode = getattr(self.module, \"MODE_\" + mode)\n\n            self.iv = _extract(params, 'iv', None)\n            if self.iv is None:\n                self.iv = _extract(params, 'nonce', None)\n            if self.iv is not None:\n                self.iv = b(self.iv)\n\n            # Only relevant for OPENPGP mode\n            self.encrypted_iv = _extract(params, 'encrypted_iv', None)\n            if self.encrypted_iv is not None:\n                self.encrypted_iv = b(self.encrypted_iv)\n        else:\n            # Stream cipher\n            self.mode = None\n            self.iv = None\n\n        self.extra_params = params\n\n    def shortDescription(self):\n        return self.description\n\n    def _new(self, do_decryption=0):\n        params = self.extra_params.copy()\n\n        # Handle CTR mode parameters.  By default, we use Counter.new(self.module.block_size)\n        if hasattr(self.module, \"MODE_CTR\") and self.mode == self.module.MODE_CTR:\n            from Crypto.Util import Counter\n            ctr_class = _extract(params, 'ctr_class', Counter.new)\n            ctr_params = _extract(params, 'ctr_params', {}).copy()\n            if ctr_params.has_key('prefix'): ctr_params['prefix'] = a2b_hex(b(ctr_params['prefix']))\n            if ctr_params.has_key('suffix'): ctr_params['suffix'] = a2b_hex(b(ctr_params['suffix']))\n            if not ctr_params.has_key('nbits'):\n                ctr_params['nbits'] = 8*(self.module.block_size - len(ctr_params.get('prefix', '')) - len(ctr_params.get('suffix', '')))\n            params['counter'] = ctr_class(**ctr_params)\n\n        if self.mode is None:\n            # Stream cipher\n            return self.module.new(a2b_hex(self.key), **params)\n        elif self.iv is None:\n            # Block cipher without iv\n            return self.module.new(a2b_hex(self.key), self.mode, **params)\n        else:\n            # Block cipher with iv\n            if do_decryption and self.mode == self.module.MODE_OPENPGP:\n                # In PGP mode, the IV to feed for decryption is the *encrypted* one\n                return self.module.new(a2b_hex(self.key), self.mode, a2b_hex(self.encrypted_iv), **params)\n            else:\n                return self.module.new(a2b_hex(self.key), self.mode, a2b_hex(self.iv), **params)\n\n    def isMode(self, name):\n        if not hasattr(self.module, \"MODE_\"+name):\n            return False\n        return self.mode == getattr(self.module, \"MODE_\"+name)\n\n    def runTest(self):\n        plaintext = a2b_hex(self.plaintext)\n        ciphertext = a2b_hex(self.ciphertext)\n        assoc_data = []\n        if self.assoc_data:\n            assoc_data = [ a2b_hex(b(x)) for x in self.assoc_data]\n\n        ct = None\n        pt = None\n\n        #\n        # Repeat the same encryption or decryption twice and verify\n        # that the result is always the same\n        #\n        for i in xrange(2):\n            cipher = self._new()\n            decipher = self._new(1)\n\n            # Only AEAD modes\n            for comp in assoc_data:\n                cipher.update(comp)\n                decipher.update(comp)\n\n            ctX = b2a_hex(cipher.encrypt(plaintext))\n            if self.isMode(\"SIV\"):\n                ptX = b2a_hex(decipher.decrypt_and_verify(ciphertext, a2b_hex(self.mac)))\n            else:\n                ptX = b2a_hex(decipher.decrypt(ciphertext))\n\n            if ct:\n                self.assertEqual(ct, ctX)\n                self.assertEqual(pt, ptX)\n            ct, pt = ctX, ptX\n\n        if self.isMode(\"OPENPGP\"):\n            # In PGP mode, data returned by the first encrypt()\n            # is prefixed with the encrypted IV.\n            # Here we check it and then remove it from the ciphertexts.\n            eilen = len(self.encrypted_iv)\n            self.assertEqual(self.encrypted_iv, ct[:eilen])\n            ct = ct[eilen:]\n\n        self.assertEqual(self.ciphertext, ct)  # encrypt\n        self.assertEqual(self.plaintext, pt)   # decrypt\n\n        if self.mac:\n            mac = b2a_hex(cipher.digest())\n            self.assertEqual(self.mac, mac)\n            decipher.verify(a2b_hex(self.mac))\n\nclass CipherStreamingSelfTest(CipherSelfTest):\n\n    def shortDescription(self):\n        desc = self.module_name\n        if self.mode is not None:\n            desc += \" in %s mode\" % (self.mode_name,)\n        return \"%s should behave like a stream cipher\" % (desc,)\n\n    def runTest(self):\n        plaintext = a2b_hex(self.plaintext)\n        ciphertext = a2b_hex(self.ciphertext)\n\n        # The cipher should work like a stream cipher\n\n        # Test counter mode encryption, 3 bytes at a time\n        ct3 = []\n        cipher = self._new()\n        for i in range(0, len(plaintext), 3):\n            ct3.append(cipher.encrypt(plaintext[i:i+3]))\n        ct3 = b2a_hex(b(\"\").join(ct3))\n        self.assertEqual(self.ciphertext, ct3)  # encryption (3 bytes at a time)\n\n        # Test counter mode decryption, 3 bytes at a time\n        pt3 = []\n        cipher = self._new()\n        for i in range(0, len(ciphertext), 3):\n            pt3.append(cipher.encrypt(ciphertext[i:i+3]))\n        # PY3K: This is meant to be text, do not change to bytes (data)\n        pt3 = b2a_hex(b(\"\").join(pt3))\n        self.assertEqual(self.plaintext, pt3)  # decryption (3 bytes at a time)\n\nclass CTRSegfaultTest(unittest.TestCase):\n\n    def __init__(self, module, params):\n        unittest.TestCase.__init__(self)\n        self.module = module\n        self.key = b(params['key'])\n        self.module_name = params.get('module_name', None)\n\n    def shortDescription(self):\n        return \"\"\"Regression test: %s.new(key, %s.MODE_CTR) should raise TypeError, not segfault\"\"\" % (self.module_name, self.module_name)\n\n    def runTest(self):\n        self.assertRaises(TypeError, self.module.new, a2b_hex(self.key), self.module.MODE_CTR)\n\nclass CTRWraparoundTest(unittest.TestCase):\n\n    def __init__(self, module, params):\n        unittest.TestCase.__init__(self)\n        self.module = module\n        self.key = b(params['key'])\n        self.module_name = params.get('module_name', None)\n\n    def shortDescription(self):\n        return \"\"\"Regression test: %s with MODE_CTR raising OverflowError on wraparound\"\"\" % (self.module_name,)\n\n    def runTest(self):\n        from Crypto.Util import Counter\n\n        def pythonCounter():\n            state = [0]\n            def ctr():\n                # First block succeeds; Second and subsequent blocks raise OverflowError\n                if state[0] == 0:\n                    state[0] = 1\n                    return b(\"\\xff\") * self.module.block_size\n                else:\n                    raise OverflowError\n            return ctr\n\n        for little_endian in (0, 1): # (False, True) Test both endiannesses\n            block = b(\"\\x00\") * self.module.block_size\n\n            # Test PyObject_CallObject code path: if the counter raises OverflowError\n            cipher = self.module.new(a2b_hex(self.key), self.module.MODE_CTR, counter=pythonCounter())\n            cipher.encrypt(block)\n            self.assertRaises(OverflowError, cipher.encrypt, block)\n            self.assertRaises(OverflowError, cipher.encrypt, block)\n\n            # Test PyObject_CallObject code path: counter object should raise OverflowError\n            ctr = Counter.new(8*self.module.block_size, initial_value=2L**(8*self.module.block_size)-1, little_endian=little_endian)\n            ctr()\n            self.assertRaises(OverflowError, ctr)\n            self.assertRaises(OverflowError, ctr)\n\n            # Test the CTR-mode shortcut\n            ctr = Counter.new(8*self.module.block_size, initial_value=2L**(8*self.module.block_size)-1, little_endian=little_endian)\n            cipher = self.module.new(a2b_hex(self.key), self.module.MODE_CTR, counter=ctr)\n            cipher.encrypt(block)\n            self.assertRaises(OverflowError, cipher.encrypt, block)\n            self.assertRaises(OverflowError, cipher.encrypt, block)\n\nclass CFBSegmentSizeTest(unittest.TestCase):\n\n    def __init__(self, module, params):\n        unittest.TestCase.__init__(self)\n        self.module = module\n        self.key = b(params['key'])\n        self.description = params['description']\n\n    def shortDescription(self):\n        return self.description\n\n    def runTest(self):\n        \"\"\"Regression test: m.new(key, m.MODE_CFB, segment_size=N) should require segment_size to be a multiple of 8 bits\"\"\"\n        for i in range(1, 8):\n            self.assertRaises(ValueError, self.module.new, a2b_hex(self.key), self.module.MODE_CFB, segment_size=i)\n        self.module.new(a2b_hex(self.key), self.module.MODE_CFB, \"\\0\"*self.module.block_size, segment_size=8) # should succeed\n\nclass CCMMACLengthTest(unittest.TestCase):\n    \"\"\"CCM specific tests about MAC\"\"\"\n\n    def __init__(self, module):\n        unittest.TestCase.__init__(self)\n        self.module = module\n        self.key = b('\\xFF')*16\n        self.iv = b('\\x00')*10\n\n    def shortDescription(self):\n        return self.description\n\n    def runTest(self):\n        \"\"\"Verify that MAC can only be 4,6,8,..,16 bytes long.\"\"\"\n        for i in range(3,16,2):\n            self.description = \"CCM MAC length check (%d bytes)\" % i\n            self.assertRaises(ValueError, self.module.new, self.key,\n                    self.module.MODE_CCM, self.iv, msg_len=10, mac_len=i)\n\n        \"\"\"Verify that default MAC length is 16.\"\"\"\n        self.description = \"CCM default MAC length check\"\n        cipher = self.module.new(self.key, self.module.MODE_CCM,\n                self.iv, msg_len=4)\n        cipher.encrypt(b('z')*4)\n        self.assertEqual(len(cipher.digest()), 16)\n\nclass CCMSplitEncryptionTest(unittest.TestCase):\n    \"\"\"CCM specific tests to validate how encrypt()\n    decrypt() can be called multiple times on the\n    same object.\"\"\"\n\n    def __init__(self, module):\n        unittest.TestCase.__init__(self)\n        self.module = module\n        self.key = b('\\xFF')*16\n        self.iv = b('\\x00')*10\n        self.description = \"CCM Split Encryption Test\"\n\n    def shortDescription(self):\n        return self.description\n\n    def runTest(self):\n        \"\"\"Verify that CCM update()/encrypt() can be called multiple times,\n        provided that lengths are declared beforehand\"\"\"\n\n        data = b(\"AUTH DATA\")\n        pt1  = b(\"PLAINTEXT1\")       # Short\n        pt2  = b(\"PLAINTEXT2\")       # Long\n        pt_ref = pt1+pt2\n\n        # REFERENCE: Run with 1 update() and 1 encrypt()\n        cipher = self.module.new(self.key, self.module.MODE_CCM,\n            self.iv)\n        cipher.update(data)\n        ct_ref = cipher.encrypt(pt_ref)\n        mac_ref = cipher.digest()\n\n        # Verify that calling CCM encrypt()/decrypt() twice is not\n        # possible without the 'msg_len' parameter and regardless\n        # of the 'assoc_len' parameter\n        for ad_len in None, len(data):\n            cipher = self.module.new(self.key, self.module.MODE_CCM,\n                self.iv, assoc_len=ad_len)\n            cipher.update(data)\n            cipher.encrypt(pt1)\n            self.assertRaises(TypeError, cipher.encrypt, pt2)\n\n            cipher = self.module.new(self.key, self.module.MODE_CCM,\n                self.iv, assoc_len=ad_len)\n            cipher.update(data)\n            cipher.decrypt(ct_ref[:len(pt1)])\n            self.assertRaises(TypeError, cipher.decrypt, ct_ref[len(pt1):])\n\n        # Run with 2 encrypt()/decrypt(). Results must be the same\n        # regardless of the 'assoc_len' parameter\n        for ad_len in None, len(data):\n            cipher = self.module.new(self.key, self.module.MODE_CCM,\n                self.iv, assoc_len=ad_len, msg_len=len(pt_ref))\n            cipher.update(data)\n            ct = cipher.encrypt(pt1)\n            ct += cipher.encrypt(pt2)\n            mac = cipher.digest()\n            self.assertEqual(ct_ref, ct)\n            self.assertEqual(mac_ref, mac)\n\n            cipher = self.module.new(self.key, self.module.MODE_CCM,\n                self.iv, msg_len=len(pt1+pt2))\n            cipher.update(data)\n            pt = cipher.decrypt(ct[:len(pt1)])\n            pt += cipher.decrypt(ct[len(pt1):])\n            mac = cipher.verify(mac_ref)\n            self.assertEqual(pt_ref, pt)\n\nclass AEADTests(unittest.TestCase):\n    \"\"\"Tests generic to all AEAD modes\"\"\"\n\n    def __init__(self, module, mode_name, key_size):\n        unittest.TestCase.__init__(self)\n        self.module = module\n        self.mode_name = mode_name\n        self.mode = getattr(module, mode_name)\n        if not self.isMode(\"SIV\"):\n            self.key = b('\\xFF')*key_size\n        else:\n            self.key = b('\\xFF')*key_size*2\n        self.iv = b('\\x00')*10\n        self.description = \"AEAD Test\"\n\n    def isMode(self, name):\n        if not hasattr(self.module, \"MODE_\"+name):\n            return False\n        return self.mode == getattr(self.module, \"MODE_\"+name)\n\n    def right_mac_test(self):\n        \"\"\"Positive tests for MAC\"\"\"\n\n        self.description = \"Test for right MAC in %s of %s\" % \\\n            (self.mode_name, self.module.__name__)\n\n        ad_ref = b(\"Reference AD\")\n        pt_ref = b(\"Reference plaintext\")\n\n        # Encrypt and create the reference MAC\n        cipher = self.module.new(self.key, self.mode, self.iv)\n        cipher.update(ad_ref)\n        ct_ref = cipher.encrypt(pt_ref)\n        mac_ref = cipher.digest()\n\n        # Decrypt and verify that MAC is accepted\n        decipher = self.module.new(self.key, self.mode, self.iv)\n        decipher.update(ad_ref)\n        pt = decipher.decrypt_and_verify(ct_ref, mac_ref)\n        self.assertEqual(pt, pt_ref)\n\n        # Verify that hexverify work\n        decipher.hexverify(hexlify(mac_ref))\n\n    def wrong_mac_test(self):\n        \"\"\"Negative tests for MAC\"\"\"\n\n        self.description = \"Test for wrong MAC in %s of %s\" % \\\n            (self.mode_name, self.module.__name__)\n\n        ad_ref = b(\"Reference AD\")\n        pt_ref = b(\"Reference plaintext\")\n\n        # Encrypt and create the reference MAC\n        cipher = self.module.new(self.key, self.mode, self.iv)\n        cipher.update(ad_ref)\n        ct_ref = cipher.encrypt(pt_ref)\n        mac_ref = cipher.digest()\n\n        # Modify the MAC and verify it is NOT ACCEPTED\n        wrong_mac = strxor_c(mac_ref, 255)\n        decipher = self.module.new(self.key, self.mode, self.iv)\n        decipher.update(ad_ref)\n        self.assertRaises(ValueError, decipher.decrypt_and_verify,\n                          ct_ref, wrong_mac)\n\n    def zero_data(self):\n        \"\"\"Verify transition from INITIALIZED to FINISHED\"\"\"\n\n        self.description = \"Test for zero data in %s of %s\" % \\\n            (self.mode_name, self.module.__name__)\n        cipher = self.module.new(self.key, self.mode, self.iv)\n        cipher.digest()\n\n    def multiple_updates(self):\n        \"\"\"Verify that update() can be called multiple times\"\"\"\n\n        self.description = \"Test for multiple updates in %s of %s\" % \\\n            (self.mode_name, self.module.__name__)\n\n        # In all modes other than SIV, the associated data is a single\n        # component that can be arbitrarilly split and submitted to update().\n        #\n        # In SIV, associated data is instead organized in a vector or multiple\n        # components. Each component is passed to update() as a whole.\n        # This test is therefore not meaningful to SIV.\n        if self.isMode(\"SIV\"):\n            return\n\n        ad = b(\"\").join([bchr(x) for x in xrange(0,128)])\n\n        mac1, mac2, mac3 = (None,)*3\n        for chunk_length in 1,10,40,80,128:\n            chunks = [ad[i:i+chunk_length] for i in range(0, len(ad), chunk_length)]\n\n            # No encryption/decryption\n            cipher = self.module.new(self.key, self.mode, self.iv)\n            for c in chunks:\n                cipher.update(c)\n            if mac1:\n                cipher.verify(mac1)\n            else:\n                mac1 = cipher.digest()\n\n            # Encryption\n            cipher = self.module.new(self.key, self.mode, self.iv)\n            for c in chunks:\n                cipher.update(c)\n            ct = cipher.encrypt(b(\"PT\"))\n            mac2 = cipher.digest()\n\n            # Decryption\n            cipher = self.module.new(self.key, self.mode, self.iv)\n            for c in chunks:\n                cipher.update(c)\n            cipher.decrypt(ct)\n            cipher.verify(mac2)\n\n    def no_mix_encrypt_decrypt(self):\n        \"\"\"Verify that encrypt and decrypt cannot be mixed up\"\"\"\n\n        self.description = \"Test for mix of encrypt and decrypt in %s of %s\" % \\\n            (self.mode_name, self.module.__name__)\n\n        # Calling decrypt after encrypt raises an exception\n        cipher = self.module.new(self.key, self.mode, self.iv)\n        cipher.encrypt(b(\"PT\")*40)\n        self.assertRaises(TypeError, cipher.decrypt, b(\"XYZ\")*40)\n\n        # Calling encrypt() after decrypt() raises an exception\n        # (excluded for SIV, since decrypt() is not valid)\n        if not self.isMode(\"SIV\"):\n            cipher = self.module.new(self.key, self.mode, self.iv)\n            cipher.decrypt(b(\"CT\")*40)\n            self.assertRaises(TypeError, cipher.encrypt, b(\"XYZ\")*40)\n\n        # Calling verify after encrypt raises an exception\n        cipher = self.module.new(self.key, self.mode, self.iv)\n        cipher.encrypt(b(\"PT\")*40)\n        self.assertRaises(TypeError, cipher.verify, b(\"XYZ\"))\n        self.assertRaises(TypeError, cipher.hexverify, \"12\")\n\n        # Calling digest() after decrypt() raises an exception\n        # (excluded for SIV, since decrypt() is not valid)\n        if not self.isMode(\"SIV\"):\n            cipher = self.module.new(self.key, self.mode, self.iv)\n            cipher.decrypt(b(\"CT\")*40)\n            self.assertRaises(TypeError, cipher.digest)\n            self.assertRaises(TypeError, cipher.hexdigest)\n\n    def no_late_update(self):\n        \"\"\"Verify that update cannot be called after encrypt or decrypt\"\"\"\n\n        self.description = \"Test for late update in %s of %s\" % \\\n            (self.mode_name, self.module.__name__)\n\n        # Calling update after encrypt raises an exception\n        cipher = self.module.new(self.key, self.mode, self.iv)\n        cipher.update(b(\"XX\"))\n        cipher.encrypt(b(\"PT\")*40)\n        self.assertRaises(TypeError, cipher.update, b(\"XYZ\"))\n\n        # Calling update() after decrypt() raises an exception\n        # (excluded for SIV, since decrypt() is not valid)\n        if not self.isMode(\"SIV\"):\n            cipher = self.module.new(self.key, self.mode, self.iv)\n            cipher.update(b(\"XX\"))\n            cipher.decrypt(b(\"CT\")*40)\n            self.assertRaises(TypeError, cipher.update, b(\"XYZ\"))\n\n    def loopback(self):\n        \"\"\"Verify composition of encrypt_and_digest() and decrypt_and_verify()\n        is the identity function.\"\"\"\n\n        self.description  = \"Lookback test decrypt_and_verify(encrypt_and_digest)\"\\\n                            \"for %s in %s\" % (self.mode_name,\n                            self.module.__name__)\n\n        enc_cipher = self.module.new(self.key, self.mode, self.iv)\n        dec_cipher = self.module.new(self.key, self.mode, self.iv)\n\n        enc_cipher.update(b(\"XXX\"))\n        dec_cipher.update(b(\"XXX\"))\n\n        plaintext = b(\"Reference\") * 10\n        ct, mac = enc_cipher.encrypt_and_digest(plaintext)\n        pt = dec_cipher.decrypt_and_verify(ct, mac)\n\n        self.assertEqual(plaintext, pt)\n\n    def runTest(self):\n        self.right_mac_test()\n        self.wrong_mac_test()\n        self.zero_data()\n        self.multiple_updates()\n        self.no_mix_encrypt_decrypt()\n        self.no_late_update()\n        self.loopback()\n\n    def shortDescription(self):\n        return self.description\n\nclass RoundtripTest(unittest.TestCase):\n    def __init__(self, module, params):\n        from Crypto import Random\n        unittest.TestCase.__init__(self)\n        self.module = module\n        self.iv = Random.get_random_bytes(module.block_size)\n        self.key = b(params['key'])\n        self.plaintext = 100 * b(params['plaintext'])\n        self.module_name = params.get('module_name', None)\n\n    def shortDescription(self):\n        return \"\"\"%s .decrypt() output of .encrypt() should not be garbled\"\"\" % (self.module_name,)\n\n    def runTest(self):\n\n        ## ECB mode\n        mode = self.module.MODE_ECB\n        encryption_cipher = self.module.new(a2b_hex(self.key), mode)\n        ciphertext = encryption_cipher.encrypt(self.plaintext)\n        decryption_cipher = self.module.new(a2b_hex(self.key), mode)\n        decrypted_plaintext = decryption_cipher.decrypt(ciphertext)\n        self.assertEqual(self.plaintext, decrypted_plaintext)\n\n        ## OPENPGP mode\n        mode = self.module.MODE_OPENPGP\n        encryption_cipher = self.module.new(a2b_hex(self.key), mode, self.iv)\n        eiv_ciphertext = encryption_cipher.encrypt(self.plaintext)\n        eiv = eiv_ciphertext[:self.module.block_size+2]\n        ciphertext = eiv_ciphertext[self.module.block_size+2:]\n        decryption_cipher = self.module.new(a2b_hex(self.key), mode, eiv)\n        decrypted_plaintext = decryption_cipher.decrypt(ciphertext)\n        self.assertEqual(self.plaintext, decrypted_plaintext)\n\n        ## All other non-AEAD modes (but CTR)\n        for mode in (self.module.MODE_CBC, self.module.MODE_CFB, self.module.MODE_OFB):\n            encryption_cipher = self.module.new(a2b_hex(self.key), mode, self.iv)\n            ciphertext = encryption_cipher.encrypt(self.plaintext)\n            decryption_cipher = self.module.new(a2b_hex(self.key), mode, self.iv)\n            decrypted_plaintext = decryption_cipher.decrypt(ciphertext)\n            self.assertEqual(self.plaintext, decrypted_plaintext)\n\n\nclass PGPTest(unittest.TestCase):\n    def __init__(self, module, params):\n        unittest.TestCase.__init__(self)\n        self.module = module\n        self.key = b(params['key'])\n\n    def shortDescription(self):\n        return \"MODE_PGP was implemented incorrectly and insecurely. It's completely banished now.\"\n\n    def runTest(self):\n        self.assertRaises(ValueError, self.module.new, a2b_hex(self.key),\n                self.module.MODE_PGP)\n\nclass IVLengthTest(unittest.TestCase):\n    def __init__(self, module, params):\n        unittest.TestCase.__init__(self)\n        self.module = module\n        self.key = b(params['key'])\n\n    def shortDescription(self):\n        return \"Check that all modes except MODE_ECB and MODE_CTR require an IV of the proper length\"\n\n    def runTest(self):\n        self.assertRaises(ValueError, self.module.new, a2b_hex(self.key),\n                self.module.MODE_CBC, \"\")\n        self.assertRaises(ValueError, self.module.new, a2b_hex(self.key),\n                self.module.MODE_CFB, \"\")\n        self.assertRaises(ValueError, self.module.new, a2b_hex(self.key),\n                self.module.MODE_OFB, \"\")\n        self.assertRaises(ValueError, self.module.new, a2b_hex(self.key),\n                self.module.MODE_OPENPGP, \"\")\n        if hasattr(self.module, \"MODE_CCM\"):\n            for ivlen in (0,6,14):\n                self.assertRaises(ValueError, self.module.new, a2b_hex(self.key),\n                    self.module.MODE_CCM, bchr(0)*ivlen, msg_len=10)\n        self.module.new(a2b_hex(self.key), self.module.MODE_ECB, \"\")\n        self.module.new(a2b_hex(self.key), self.module.MODE_CTR, \"\", counter=self._dummy_counter)\n\n    def _dummy_counter(self):\n        return \"\\0\" * self.module.block_size\n\ndef make_block_tests(module, module_name, test_data, additional_params=dict()):\n    tests = []\n    extra_tests_added = 0\n    for i in range(len(test_data)):\n        row = test_data[i]\n\n        # Build the \"params\" dictionary\n        params = {'mode': 'ECB'}\n        if len(row) == 3:\n            (params['plaintext'], params['ciphertext'], params['key']) = row\n        elif len(row) == 4:\n            (params['plaintext'], params['ciphertext'], params['key'], params['description']) = row\n        elif len(row) == 5:\n            (params['plaintext'], params['ciphertext'], params['key'], params['description'], extra_params) = row\n            params.update(extra_params)\n        else:\n            raise AssertionError(\"Unsupported tuple size %d\" % (len(row),))\n\n        # Build the display-name for the test\n        p2 = params.copy()\n        p_key = _extract(p2, 'key')\n        p_plaintext = _extract(p2, 'plaintext')\n        p_ciphertext = _extract(p2, 'ciphertext')\n        p_description = _extract(p2, 'description', None)\n        p_mode = p2.get('mode', 'ECB')\n        if p_mode == 'ECB':\n            _extract(p2, 'mode', 'ECB')\n\n        if p_description is not None:\n            description = p_description\n        elif p_mode == 'ECB' and not p2:\n            description = \"p=%s, k=%s\" % (p_plaintext, p_key)\n        else:\n            description = \"p=%s, k=%s, %r\" % (p_plaintext, p_key, p2)\n        name = \"%s #%d: %s\" % (module_name, i+1, description)\n        params['description'] = name\n        params['module_name'] = module_name\n        params.update(additional_params)\n\n        # Add extra test(s) to the test suite before the current test\n        if not extra_tests_added:\n            tests += [\n                CTRSegfaultTest(module, params),\n                CTRWraparoundTest(module, params),\n                CFBSegmentSizeTest(module, params),\n                RoundtripTest(module, params),\n                PGPTest(module, params),\n                IVLengthTest(module, params),\n            ]\n            extra_tests_added = 1\n\n        # Extract associated data and MAC for AEAD modes\n        if p_mode in ('CCM', 'EAX', 'SIV', 'GCM'):\n            assoc_data, params['plaintext'] = params['plaintext'].split('|')\n            assoc_data2, params['ciphertext'], params['mac'] = params['ciphertext'].split('|')\n            params['assoc_data'] = assoc_data.split(\"-\")\n            params['mac_len'] = len(params['mac'])>>1\n\n        # Add the current test to the test suite\n        tests.append(CipherSelfTest(module, params))\n\n        # When using CTR mode, test that the interface behaves like a stream cipher\n        if p_mode in ('OFB', 'CTR'):\n            tests.append(CipherStreamingSelfTest(module, params))\n\n        # When using CTR mode, test the non-shortcut code path.\n        if p_mode == 'CTR' and not params.has_key('ctr_class'):\n            params2 = params.copy()\n            params2['description'] += \" (shortcut disabled)\"\n            ctr_params2 = params.get('ctr_params', {}).copy()\n            params2['ctr_params'] = ctr_params2\n            if not params2['ctr_params'].has_key('disable_shortcut'):\n                params2['ctr_params']['disable_shortcut'] = 1\n            tests.append(CipherSelfTest(module, params2))\n\n    # Add tests that don't use test vectors\n    if hasattr(module, \"MODE_CCM\"):\n        tests += [\n            CCMMACLengthTest(module),\n            CCMSplitEncryptionTest(module),\n        ]\n    for aead_mode in (\"MODE_CCM\",\"MODE_EAX\", \"MODE_SIV\", \"MODE_GCM\"):\n        if hasattr(module, aead_mode):\n            key_sizes = []\n            try:\n                key_sizes += module.key_size\n            except TypeError:\n                key_sizes = [ module.key_size ]\n            for ks in key_sizes:\n                tests += [\n                    AEADTests(module, aead_mode, ks),\n                ]\n\n    return tests\n\ndef make_stream_tests(module, module_name, test_data):\n    tests = []\n    for i in range(len(test_data)):\n        row = test_data[i]\n\n        # Build the \"params\" dictionary\n        params = {}\n        if len(row) == 3:\n            (params['plaintext'], params['ciphertext'], params['key']) = row\n        elif len(row) == 4:\n            (params['plaintext'], params['ciphertext'], params['key'], params['description']) = row\n        elif len(row) == 5:\n            (params['plaintext'], params['ciphertext'], params['key'], params['description'], extra_params) = row\n            params.update(extra_params)\n        else:\n            raise AssertionError(\"Unsupported tuple size %d\" % (len(row),))\n\n        # Build the display-name for the test\n        p2 = params.copy()\n        p_key = _extract(p2, 'key')\n        p_plaintext = _extract(p2, 'plaintext')\n        p_ciphertext = _extract(p2, 'ciphertext')\n        p_description = _extract(p2, 'description', None)\n\n        if p_description is not None:\n            description = p_description\n        elif not p2:\n            description = \"p=%s, k=%s\" % (p_plaintext, p_key)\n        else:\n            description = \"p=%s, k=%s, %r\" % (p_plaintext, p_key, p2)\n        name = \"%s #%d: %s\" % (module_name, i+1, description)\n        params['description'] = name\n        params['module_name'] = module_name\n\n        # Add the test to the test suite\n        tests.append(CipherSelfTest(module, params))\n        tests.append(CipherStreamingSelfTest(module, params))\n    return tests\n\n# vim:set ts=4 sw=4 sts=4 expandtab:\n", "\n/* -*- C -*- */\n/*\n *  block_template.c : Generic framework for block encryption algorithms\n *\n * Written by Andrew Kuchling and others\n *\n * ===================================================================\n * The contents of this file are dedicated to the public domain.  To\n * the extent that dedication to the public domain is not available,\n * everyone is granted a worldwide, perpetual, royalty-free,\n * non-exclusive license to exercise all rights associated with the\n * contents of this file for any purpose whatsoever.\n * No rights are reserved.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n * ===================================================================\n */\n\n#include \"pycrypto_common.h\"\n#include \"modsupport.h\"\n#include <string.h>\n#include \"_counter.h\"\n\n/* Cipher operation modes */\n\n#define MODE_ECB 1\n#define MODE_CBC 2\n#define MODE_CFB 3\n#define MODE_PGP 4\n#define MODE_OFB 5\n#define MODE_CTR 6\n\n#define _STR(x) #x\n#define _XSTR(x) _STR(x)\n#define _PASTE(x,y) x##y\n#define _PASTE2(x,y) _PASTE(x,y)\n#ifdef IS_PY3K\n#define _MODULE_NAME _PASTE2(PyInit_,MODULE_NAME)\n#else\n#define _MODULE_NAME _PASTE2(init,MODULE_NAME)\n#endif\n#define _MODULE_STRING _XSTR(MODULE_NAME)\n\n/* Object references for the counter_shortcut */\nstatic PyObject *_counter_module = NULL;\nstatic PyTypeObject *PCT_CounterBEType = NULL;\nstatic PyTypeObject *PCT_CounterLEType = NULL;\n\ntypedef struct \n{\n\tPyObject_HEAD \n\tint mode, count, segment_size;\n\tunsigned char IV[BLOCK_SIZE], oldCipher[BLOCK_SIZE];\n\tPyObject *counter;\n\tint counter_shortcut;\n\tblock_state st;\n} ALGobject;\n\n/* Please see PEP3123 for a discussion of PyObject_HEAD and changes made in 3.x to make it conform to Standard C.\n * These changes also dictate using Py_TYPE to check type, and PyVarObject_HEAD_INIT(NULL, 0) to initialize\n */\nstaticforward PyTypeObject ALGtype;\n\nstatic ALGobject *\nnewALGobject(void)\n{\n\tALGobject * new;\n\tnew = PyObject_New(ALGobject, &ALGtype);\n\tnew->mode = MODE_ECB;\n\tnew->counter = NULL;\n\tnew->counter_shortcut = 0;\n\treturn new;\n}\n\nstatic void\nALGdealloc(PyObject *ptr)\n{\t\t\n\tALGobject *self = (ALGobject *)ptr;\n\n\t/* Overwrite the contents of the object */\n\tPy_XDECREF(self->counter);\n\tself->counter = NULL;\n\tmemset(self->IV, 0, BLOCK_SIZE);\n\tmemset(self->oldCipher, 0, BLOCK_SIZE);\n\tmemset((char*)&(self->st), 0, sizeof(block_state));\n\tself->mode = self->count = self->segment_size = 0;\n\tPyObject_Del(ptr);\n}\n\n\n\nstatic char ALGnew__doc__[] = \n\"new(key, [mode], [IV]): Return a new \" _MODULE_STRING \" encryption object.\";\n\nstatic char *kwlist[] = {\"key\", \"mode\", \"IV\", \"counter\", \"segment_size\",\n#ifdef PCT_ARC2_MODULE\n                         \"effective_keylen\",\n#endif\n\t\t\t NULL};\n\nstatic ALGobject *\nALGnew(PyObject *self, PyObject *args, PyObject *kwdict)\n{\n\tunsigned char *key, *IV;\n\tALGobject * new=NULL;\n\tint keylen, IVlen=0, mode=MODE_ECB, segment_size=0;\n\tPyObject *counter = NULL;\n\tint counter_shortcut = 0;\n#ifdef PCT_ARC2_MODULE\n        int effective_keylen = 1024;    /* this is a weird default, but it's compatible with old versions of PyCrypto */\n#endif\n\t/* Set default values */\n\tif (!PyArg_ParseTupleAndKeywords(args, kwdict, \"s#|is#Oi\"\n#ifdef PCT_ARC2_MODULE\n\t\t\t\t\t \"i\"\n#endif\n\t\t\t\t\t , kwlist,\n\t\t\t\t\t &key, &keylen, &mode, &IV, &IVlen,\n\t\t\t\t\t &counter, &segment_size\n#ifdef PCT_ARC2_MODULE\n\t\t\t\t\t , &effective_keylen\n#endif\n\t\t)) \n\t{\n\t\treturn NULL;\n\t}\n\n\tif (mode<MODE_ECB || mode>MODE_CTR) \n\t{\n\t\tPyErr_Format(PyExc_ValueError, \n\t\t\t     \"Unknown cipher feedback mode %i\",\n\t\t\t     mode);\n\t\treturn NULL;\n\t}\n\tif (mode == MODE_PGP) {\n\t\tPyErr_Format(PyExc_ValueError, \n\t\t\t     \"MODE_PGP is not supported anymore\");\n\t\treturn NULL;\n\t}\n\tif (KEY_SIZE!=0 && keylen!=KEY_SIZE)\n\t{\n\t\tPyErr_Format(PyExc_ValueError,\n\t\t\t     \"Key must be %i bytes long, not %i\",\n\t\t\t     KEY_SIZE, keylen);\n\t\treturn NULL;\n\t}\n\tif (KEY_SIZE==0 && keylen==0)\n\t{\n\t\tPyErr_SetString(PyExc_ValueError,\n\t\t\t\t\"Key cannot be the null string\");\n\t\treturn NULL;\n\t}\n\tif (IVlen != 0 && mode == MODE_ECB)\n\t{\n\t\tPyErr_Format(PyExc_ValueError, \"ECB mode does not use IV\");\n\t\treturn NULL;\n\t}\n\tif (IVlen != 0 && mode == MODE_CTR)\n\t{\n\t\tPyErr_Format(PyExc_ValueError,\n\t\t\t\"CTR mode needs counter parameter, not IV\");\n\t\treturn NULL;\n\t}\n\tif (IVlen != BLOCK_SIZE && mode != MODE_ECB && mode != MODE_CTR)\n\t{\n\t\tPyErr_Format(PyExc_ValueError,\n\t\t\t     \"IV must be %i bytes long\", BLOCK_SIZE);\n\t\treturn NULL;\n\t}\n\n\t/* Mode-specific checks */\n\tif (mode == MODE_CFB) {\n\t\tif (segment_size == 0) segment_size = 8;\n\t\tif (segment_size < 1 || segment_size > BLOCK_SIZE*8 || ((segment_size & 7) != 0)) {\n\t\t\tPyErr_Format(PyExc_ValueError, \n\t\t\t\t     \"segment_size must be multiple of 8 (bits) \"\n\t\t\t\t     \"between 1 and %i\", BLOCK_SIZE*8);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tif (mode == MODE_CTR) {\n\t\tif (counter == NULL) {\n\t\t\tPyErr_SetString(PyExc_TypeError,\n\t\t\t\t\t\"'counter' keyword parameter is required with CTR mode\");\n\t\t\treturn NULL;\n\t\t} else if (Py_TYPE(counter) == PCT_CounterBEType || Py_TYPE(counter) == PCT_CounterLEType) {\n\t\t\tcounter_shortcut = 1;\n\t\t} else if (!PyCallable_Check(counter)) {\n\t\t\tPyErr_SetString(PyExc_ValueError, \n\t\t\t\t\t\"'counter' parameter must be a callable object\");\n\t\t\treturn NULL;\n\t\t}\n\t} else {\n\t\tif (counter != NULL) {\n\t\t\tPyErr_SetString(PyExc_ValueError, \n\t\t\t\t\t\"'counter' parameter only useful with CTR mode\");\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t/* Cipher-specific checks */\n#ifdef PCT_ARC2_MODULE\n        if (effective_keylen<0 || effective_keylen>1024) {\n\t\tPyErr_Format(PyExc_ValueError,\n\t\t\t     \"RC2: effective_keylen must be between 0 and 1024, not %i\",\n\t\t\t     effective_keylen);\n\t\treturn NULL;\n        }\n#endif\n\n\t/* Copy parameters into object */\n\tnew = newALGobject();\n\tnew->segment_size = segment_size;\n\tnew->counter = counter;\n\tPy_XINCREF(counter);\n\tnew->counter_shortcut = counter_shortcut;\n#ifdef PCT_ARC2_MODULE\n        new->st.effective_keylen = effective_keylen;\n#endif\n\n\tblock_init(&(new->st), key, keylen);\n\tif (PyErr_Occurred())\n\t{\n\t\tPy_DECREF(new);\n\t\treturn NULL;\n\t}\n\tmemset(new->IV, 0, BLOCK_SIZE);\n\tmemset(new->oldCipher, 0, BLOCK_SIZE);\n\tmemcpy(new->IV, IV, IVlen);\n\tnew->mode = mode;\n\tnew->count=BLOCK_SIZE;   /* stores how many bytes in new->oldCipher have been used */\n\treturn new;\n}\n\nstatic char ALG_Encrypt__doc__[] =\n\"Encrypt the provided string of binary data.\";\n\nstatic PyObject *\nALG_Encrypt(ALGobject *self, PyObject *args)\n{\n\tunsigned char *buffer, *str;\n\tunsigned char temp[BLOCK_SIZE];\n\tint i, j, len;\n\tPyObject *result;\n  \n\tif (!PyArg_Parse(args, \"s#\", &str, &len))\n\t\treturn NULL;\n\tif (len==0)\t\t\t/* Handle empty string */\n\t{\n\t\treturn PyBytes_FromStringAndSize(NULL, 0);\n\t}\n\tif ( (len % BLOCK_SIZE) !=0 && \n\t     (self->mode!=MODE_CFB) &&\n\t     (self->mode!=MODE_OFB) &&\n\t     (self->mode!=MODE_CTR))\n\t{\n\t\tPyErr_Format(PyExc_ValueError, \n\t\t\t     \"Input strings must be \"\n\t\t\t     \"a multiple of %i in length\",\n\t\t\t     BLOCK_SIZE);\n\t\treturn NULL;\n\t}\n\tif (self->mode == MODE_CFB && \n\t    (len % (self->segment_size/8) !=0)) {\n\t\tPyErr_Format(PyExc_ValueError, \n\t\t\t     \"Input strings must be a multiple of \"\n\t\t\t     \"the segment size %i in length\",\n\t\t\t     self->segment_size/8);\n\t\treturn NULL;\n\t}\n\n\tbuffer=malloc(len);\n\tif (buffer==NULL) \n\t{\n\t\tPyErr_SetString(PyExc_MemoryError, \n\t\t\t\t\"No memory available in \"\n\t\t\t\t_MODULE_STRING \" encrypt\");\n\t\treturn NULL;\n\t}\n\tPy_BEGIN_ALLOW_THREADS;\n\tswitch(self->mode)\n\t{\n\tcase(MODE_ECB):      \n\t\tfor(i=0; i<len; i+=BLOCK_SIZE) \n\t\t{\n\t\t\tblock_encrypt(&(self->st), str+i, buffer+i);\n\t\t}\n\t\tbreak;\n\n\tcase(MODE_CBC):      \n\t\tfor(i=0; i<len; i+=BLOCK_SIZE) \n\t\t{\n\t\t\tfor(j=0; j<BLOCK_SIZE; j++)\n\t\t\t{\n\t\t\t\ttemp[j]=str[i+j]^self->IV[j];\n\t\t\t}\n\t\t\tblock_encrypt(&(self->st), temp, buffer+i);\n\t\t\tmemcpy(self->IV, buffer+i, BLOCK_SIZE);\n\t\t}\n\t\tbreak;\n\n\tcase(MODE_CFB):      \n\t\tfor(i=0; i<len; i+=self->segment_size/8) \n\t\t{\n\t\t\tblock_encrypt(&(self->st), self->IV, temp);\n\t\t\tfor (j=0; j<self->segment_size/8; j++) {\n\t\t\t\tbuffer[i+j] = str[i+j] ^ temp[j];\n\t\t\t}\n\t\t\tif (self->segment_size == BLOCK_SIZE * 8) {\n\t\t\t\t/* s == b: segment size is identical to \n\t\t\t\t   the algorithm block size */\n\t\t\t\tmemcpy(self->IV, buffer + i, BLOCK_SIZE);\n\t\t\t}\n\t\t\telse if ((self->segment_size % 8) == 0) {\n\t\t\t\tint sz = self->segment_size/8;\n\t\t\t\tmemmove(self->IV, self->IV + sz, \n\t\t\t\t\tBLOCK_SIZE-sz);\n\t\t\t\tmemcpy(self->IV + BLOCK_SIZE - sz, buffer + i,\n\t\t\t\t       sz);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* segment_size is not a multiple of 8; \n\t\t\t\t   currently this can't happen */\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase(MODE_OFB):\n\t\t/* OFB mode is a stream cipher whose keystream is generated by encrypting the previous ciphered output.\n\t\t * - self->IV stores the current keystream block\n\t\t * - self->count indicates the current offset within the current keystream block\n\t\t * - str stores the input string\n\t\t * - buffer stores the output string\n\t\t * - len indicates the length of the input and output strings\n\t\t * - i indicates the current offset within the input and output strings\n\t\t * (len-i) is the number of bytes remaining to encrypt\n\t\t * (BLOCK_SIZE-self->count) is the number of bytes remaining in the current keystream block\n\t\t */\n\t\ti = 0;\n\t\twhile(i < len)\n\t\t{\n\t\t\t/* If we don't need more than what remains of the current keystream block, then just XOR it in */\n\t\t\tif (len-i <= BLOCK_SIZE-self->count) { /* remaining_bytes_to_encrypt <= remaining_bytes_in_IV */\n\t\t\t\t/* XOR until the input is used up */\n\t\t\t\tfor(j=0; j<(len-i); j++) {\n\t\t\t\t\tassert(i+j < len);\n\t\t\t\t\tassert(self->count+j < BLOCK_SIZE);\n\t\t\t\t\tbuffer[i+j] = self->IV[self->count+j] ^ str[i+j];\n\t\t\t\t}\n\t\t\t\tself->count += len-i;\n\t\t\t\ti = len;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Use up the current keystream block */\n\t\t\tfor(j=0; j<BLOCK_SIZE-self->count; j++) {\n\t\t\t\tassert(i+j < len);\n\t\t\t\tassert(self->count+j < BLOCK_SIZE);\n\t\t\t\tbuffer[i+j] = self->IV[self->count+j] ^ str[i+j];\n\t\t\t}\n\t\t\ti += BLOCK_SIZE-self->count;\n\t\t\tself->count = BLOCK_SIZE;\n\n\t\t\t/* Generate a new keystream block */\n\t\t\tblock_encrypt(&(self->st), self->IV, temp);\n\t\t\tmemcpy(self->IV, temp, BLOCK_SIZE);\n\n\t\t\t/* Move the pointer to the start of the keystream */\n\t\t\tself->count = 0;\n\t\t}\n\t\tbreak;\n\n\tcase(MODE_CTR):\n\t\t/* CTR mode is a stream cipher whose keystream is generated by encrypting unique counter values.\n\t\t * - self->counter points to the Counter callable, which is\n\t\t *   responsible for generating keystream blocks\n\t\t * - self->count indicates the current offset within the current keystream block\n\t\t * - self->IV stores the current keystream block\n\t\t * - str stores the input string\n\t\t * - buffer stores the output string\n\t\t * - len indicates the length if the input and output strings\n\t\t * - i indicates the current offset within the input and output strings\n\t\t * - (len-i) is the number of bytes remaining to encrypt\n\t\t * - (BLOCK_SIZE-self->count) is the number of bytes remaining in the current keystream block\n\t\t */\n\t\ti = 0;\n\t\twhile (i < len) {\n\t\t\t/* If we don't need more than what remains of the current keystream block, then just XOR it in */\n\t\t\tif (len-i <= BLOCK_SIZE-self->count) { /* remaining_bytes_to_encrypt <= remaining_bytes_in_IV */\n\t\t\t\t/* XOR until the input is used up */\n\t\t\t\tfor(j=0; j<(len-i); j++) {\n\t\t\t\t\tassert(i+j < len);\n\t\t\t\t\tassert(self->count+j < BLOCK_SIZE);\n\t\t\t\t\tbuffer[i+j] = (self->IV[self->count+j] ^= str[i+j]);\n\t\t\t\t}\n\t\t\t\tself->count += len-i;\n\t\t\t\ti = len;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Use up the current keystream block */\n\t\t\tfor(j=0; j<BLOCK_SIZE-self->count; j++) {\n\t\t\t\tassert(i+j < len);\n\t\t\t\tassert(self->count+j < BLOCK_SIZE);\n\t\t\t\tbuffer[i+j] = (self->IV[self->count+j] ^= str[i+j]);\n\t\t\t}\n\t\t\ti += BLOCK_SIZE-self->count;\n\t\t\tself->count = BLOCK_SIZE;\n\n\t\t\t/* Generate a new keystream block */\n\t\t\tif (self->counter_shortcut) {\n\t\t\t\t/* CTR mode shortcut: If we're using Util.Counter,\n\t\t\t\t * bypass the normal Python function call mechanism\n\t\t\t\t * and manipulate the counter directly. */\n\n\t\t\t\tPCT_CounterObject *ctr = (PCT_CounterObject *)(self->counter);\n\t\t\t\tif (ctr->carry && !ctr->allow_wraparound) {\n\t\t\t\t\tPy_BLOCK_THREADS;\n\t\t\t\t\tPyErr_SetString(PyExc_OverflowError,\n\t\t\t\t\t\t\t\"counter wrapped without allow_wraparound\");\n\t\t\t\t\tfree(buffer);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tif (ctr->buf_size != BLOCK_SIZE) {\n\t\t\t\t\tPy_BLOCK_THREADS;\n\t\t\t\t\tPyErr_Format(PyExc_TypeError,\n\t\t\t\t\t\t     \"CTR counter function returned \"\n\t\t\t\t\t\t     \"string of length %zi, not %i\",\n\t\t\t\t\t\t     ctr->buf_size, BLOCK_SIZE);\n\t\t\t\t\tfree(buffer);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tblock_encrypt(&(self->st),\n\t\t\t\t\t      (unsigned char *)ctr->val,\n\t\t\t\t\t      self->IV);\n\t\t\t\tctr->inc_func(ctr);\n\t\t\t} else {\n\t\t\t\tPyObject *ctr;\n\t\t\t\tPy_BLOCK_THREADS;\n\t\t\t\tctr = PyObject_CallObject(self->counter, NULL);\n\t\t\t\tif (ctr == NULL) {\n\t\t\t\t\tfree(buffer);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tif (!PyBytes_Check(ctr))\n\t\t\t\t{\n\t\t\t\t\tPyErr_SetString(PyExc_TypeError,\n\t\t\t\t\t\t\t\"CTR counter function didn't return a bytestring\");\n\t\t\t\t\tPy_DECREF(ctr);\n\t\t\t\t\tfree(buffer);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tif (PyBytes_Size(ctr) != BLOCK_SIZE) {\n\t\t\t\t\tPyErr_Format(PyExc_TypeError,\n\t\t\t\t\t\t     \"CTR counter function returned \"\n\t\t\t\t\t\t     \"bytestring not of length %i\",\n\t\t\t\t\t\t     BLOCK_SIZE);\n\t\t\t\t\tPy_DECREF(ctr);\n\t\t\t\t\tfree(buffer);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tPy_UNBLOCK_THREADS;\n\t\t\t\tblock_encrypt(&(self->st), (unsigned char *)PyBytes_AsString(ctr),\n\t\t\t\t\t      self->IV);\n\t\t\t\tPy_BLOCK_THREADS;\n\t\t\t\tPy_DECREF(ctr);\n\t\t\t\tPy_UNBLOCK_THREADS;\n\t\t\t}\n\n\t\t\t/* Move the pointer to the start of the keystream block */\n\t\t\tself->count = 0;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tPy_BLOCK_THREADS;\n\t\tPyErr_Format(PyExc_SystemError, \n\t\t\t     \"Unknown ciphertext feedback mode %i; \"\n\t\t\t     \"this shouldn't happen\",\n\t\t\t     self->mode);\n\t\tfree(buffer);\n\t\treturn NULL;\n\t}\n\tPy_END_ALLOW_THREADS;\n\tresult=PyBytes_FromStringAndSize((char *) buffer, len);\n\tfree(buffer);\n\treturn(result);\n}\n\nstatic char ALG_Decrypt__doc__[] =\n\"decrypt(string): Decrypt the provided string of binary data.\";\n\n\n\n\nstatic PyObject *\nALG_Decrypt(ALGobject *self, PyObject *args)\n{\n\tunsigned char *buffer, *str;\n\tunsigned char temp[BLOCK_SIZE];\n\tint i, j, len;\n\tPyObject *result;\n\n\t/* CTR and OFB mode decryption is identical to encryption */\n\tif (self->mode == MODE_CTR || self->mode == MODE_OFB)\n\t\treturn ALG_Encrypt(self, args);\n\n\tif (!PyArg_Parse(args, \"s#\", &str, &len))\n\t\treturn NULL;\n\tif (len==0)\t\t\t/* Handle empty string */\n\t{\n\t\treturn PyBytes_FromStringAndSize(NULL, 0);\n\t}\n\tif ( (len % BLOCK_SIZE) !=0 && (self->mode!=MODE_CFB))\n\t{\n\t\tPyErr_Format(PyExc_ValueError, \n\t\t\t     \"Input strings must be \"\n\t\t\t     \"a multiple of %i in length\",\n\t\t\t     BLOCK_SIZE);\n\t\treturn NULL;\n\t}\n\tif (self->mode == MODE_CFB && \n\t    (len % (self->segment_size/8) !=0)) {\n\t\tPyErr_Format(PyExc_ValueError, \n\t\t\t     \"Input strings must be a multiple of \"\n\t\t\t     \"the segment size %i in length\",\n\t\t\t     self->segment_size/8);\n\t\treturn NULL;\n\t}\n\tbuffer=malloc(len);\n\tif (buffer==NULL) \n\t{\n\t\tPyErr_SetString(PyExc_MemoryError, \n\t\t\t\t\"No memory available in \" _MODULE_STRING\n\t\t\t\t\" decrypt\");\n\t\treturn NULL;\n\t}\n\tPy_BEGIN_ALLOW_THREADS;\n\tswitch(self->mode)\n\t{\n\tcase(MODE_ECB):      \n\t\tfor(i=0; i<len; i+=BLOCK_SIZE) \n\t\t{\n\t\t\tblock_decrypt(&(self->st), str+i, buffer+i);\n\t\t}\n\t\tbreak;\n\n\tcase(MODE_CBC):      \n\t\tfor(i=0; i<len; i+=BLOCK_SIZE) \n\t\t{\n\t\t\tmemcpy(self->oldCipher, self->IV, BLOCK_SIZE);\n\t\t\tblock_decrypt(&(self->st), str+i, temp);\n\t\t\tfor(j=0; j<BLOCK_SIZE; j++) \n\t\t\t{\n\t\t\t\tbuffer[i+j]=temp[j]^self->IV[j];\n\t\t\t\tself->IV[j]=str[i+j];\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase(MODE_CFB):      \n\t\tfor(i=0; i<len; i+=self->segment_size/8) \n\t\t{\n\t\t\tblock_encrypt(&(self->st), self->IV, temp);\n\t\t\tfor (j=0; j<self->segment_size/8; j++) {\n\t\t\t\tbuffer[i+j] = str[i+j]^temp[j];\n\t\t\t}\n\t\t\tif (self->segment_size == BLOCK_SIZE * 8) {\n\t\t\t\t/* s == b: segment size is identical to \n\t\t\t\t   the algorithm block size */\n\t\t\t\tmemcpy(self->IV, str + i, BLOCK_SIZE);\n\t\t\t}\n\t\t\telse if ((self->segment_size % 8) == 0) {\n\t\t\t\tint sz = self->segment_size/8;\n\t\t\t\tmemmove(self->IV, self->IV + sz, \n\t\t\t\t\tBLOCK_SIZE-sz);\n\t\t\t\tmemcpy(self->IV + BLOCK_SIZE - sz, str + i, \n\t\t\t\t       sz);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* segment_size is not a multiple of 8; \n\t\t\t\t   currently this can't happen */\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tPy_BLOCK_THREADS;\n\t\tPyErr_Format(PyExc_SystemError, \n\t\t\t     \"Unknown ciphertext feedback mode %i; \"\n\t\t\t     \"this shouldn't happen\",\n\t\t\t     self->mode);\n\t\tfree(buffer);\n\t\treturn NULL;\n\t}\n\tPy_END_ALLOW_THREADS;\n\tresult=PyBytes_FromStringAndSize((char *) buffer, len);\n\tfree(buffer);\n\treturn(result);\n}\n\n/* ALG object methods */\nstatic PyMethodDef ALGmethods[] =\n{\n {\"encrypt\", (PyCFunction) ALG_Encrypt, METH_O, ALG_Encrypt__doc__},\n {\"decrypt\", (PyCFunction) ALG_Decrypt, METH_O, ALG_Decrypt__doc__},\n {NULL, NULL}\t\t\t/* sentinel */\n};\n\nstatic int\nALGsetattr(PyObject *ptr, char *name, PyObject *v)\n{\n  ALGobject *self=(ALGobject *)ptr;\n  if (strcmp(name, \"IV\") != 0) \n    {\n      PyErr_Format(PyExc_AttributeError,\n\t\t   \"non-existent block cipher object attribute '%s'\",\n\t\t   name);\n      return -1;\n    }\n  if (v==NULL)\n    {\n      PyErr_SetString(PyExc_AttributeError,\n\t\t      \"Can't delete IV attribute of block cipher object\");\n      return -1;\n    }\n  if (!PyBytes_Check(v))\n    {\n      PyErr_SetString(PyExc_TypeError,\n\t\t\t  \"IV attribute of block cipher object must be bytestring\");\n      return -1;\n    }\n  if (PyBytes_Size(v)!=BLOCK_SIZE) \n    {\n      PyErr_Format(PyExc_ValueError, \n\t\t   _MODULE_STRING \" IV must be %i bytes long\",\n\t\t   BLOCK_SIZE);\n      return -1;\n    }\n  memcpy(self->IV, PyBytes_AsString(v), BLOCK_SIZE);\n  return 0;\n}\n\nstatic PyObject *\nALGgetattro(PyObject *s, PyObject *attr)\n{\n  ALGobject *self = (ALGobject*)s;\n\n  if (!PyString_Check(attr))\n\tgoto generic;\n\n  if (PyString_CompareWithASCIIString(attr, \"IV\") == 0)\n    {\n      return(PyBytes_FromStringAndSize((char *) self->IV, BLOCK_SIZE));\n    }\n  if (PyString_CompareWithASCIIString(attr, \"mode\") == 0)\n     {\n       return(PyInt_FromLong((long)(self->mode)));\n     }\n  if (PyString_CompareWithASCIIString(attr, \"block_size\") == 0)\n     {\n       return PyInt_FromLong(BLOCK_SIZE);\n     }\n  if (PyString_CompareWithASCIIString(attr, \"key_size\") == 0)\n     {\n       return PyInt_FromLong(KEY_SIZE);\n     }\n  generic:\n#if PYTHON_API_VERSION >= 1011          /* Python 2.2 and later */\n\treturn PyObject_GenericGetAttr(s, attr);\n#else\n\tif (PyString_Check(attr) < 0) {\n\t\tPyErr_SetObject(PyExc_AttributeError, attr);\n\t\treturn NULL;\n\t}\n\treturn Py_FindMethod(ALGmethods, (PyObject *)self, PyString_AsString(attr));\n#endif\n}\n\n/* List of functions defined in the module */\n\nstatic struct PyMethodDef modulemethods[] =\n{\n {\"new\", (PyCFunction) ALGnew, METH_VARARGS|METH_KEYWORDS, ALGnew__doc__},\n {NULL, NULL}\t\t\t/* sentinel */\n};\n\nstatic PyTypeObject ALGtype =\n{\n\tPyVarObject_HEAD_INIT(NULL, 0)  /* deferred type init for compilation on Windows, type will be filled in at runtime */\n\t_MODULE_STRING,\t\t/*tp_name*/\n\tsizeof(ALGobject),\t/*tp_size*/\n\t0,\t\t\t\t/*tp_itemsize*/\n\t/* methods */\n\t(destructor) ALGdealloc,\t/*tp_dealloc*/\n\t0,\t\t\t\t/*tp_print*/\n\t0,\t\t\t\t/*tp_getattr*/\n\tALGsetattr,    /*tp_setattr*/\n\t0,\t\t\t/*tp_compare*/\n\t(reprfunc) 0,\t\t\t\t/*tp_repr*/\n\t0,\t\t\t\t/*tp_as_number*/\n\t0,\t\t\t\t/*tp_as_sequence */\n\t0,\t\t\t\t/*tp_as_mapping */\n\t0,\t\t\t\t/*tp_hash*/\n\t0,\t\t\t\t/*tp_call*/\n\t0,\t\t\t\t/*tp_str*/\n\tALGgetattro,\t/*tp_getattro*/\n\t0,\t\t\t\t/*tp_setattro*/\n\t0,\t\t\t\t/*tp_as_buffer*/\n\tPy_TPFLAGS_DEFAULT,\t\t/*tp_flags*/\n\t0,\t\t\t\t/*tp_doc*/\n\t0,\t\t\t\t/*tp_traverse*/\n\t0,\t\t\t\t/*tp_clear*/\n\t0,\t\t\t\t/*tp_richcompare*/\n\t0,\t\t\t\t/*tp_weaklistoffset*/\n#if PYTHON_API_VERSION >= 1011          /* Python 2.2 and later */\n\t0,\t\t\t\t/*tp_iter*/\n\t0,\t\t\t\t/*tp_iternext*/\n\tALGmethods,\t\t/*tp_methods*/\n#endif\n};\n\n#ifdef IS_PY3K\nstatic struct PyModuleDef moduledef = {\n\tPyModuleDef_HEAD_INIT,\n\t\"Crypto.Cipher.\" _MODULE_STRING,\n\tNULL,\n\t-1,\n\tmodulemethods,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL\n};\n#endif\n\n/* Initialization function for the module */\nPyMODINIT_FUNC\n_MODULE_NAME (void)\n{\n\tPyObject *m = NULL;\n\tPyObject *abiver = NULL;\n\tPyObject *__all__ = NULL;\n\n\tif (PyType_Ready(&ALGtype) < 0)\n\t\tgoto errout;\n\n\t/* Create the module and add the functions */\n#ifdef IS_PY3K\n\tm = PyModule_Create(&moduledef);\n#else\n\tm = Py_InitModule(\"Crypto.Cipher.\" _MODULE_STRING, modulemethods);\n#endif\n\tif (m == NULL)\n\t\tgoto errout;\n\n\t/* Add the type object to the module (using the name of the module itself),\n\t * so that its methods docstrings are discoverable by introspection tools. */\n\tPyObject_SetAttrString(m, _MODULE_STRING, (PyObject *)&ALGtype);\n\n\t/* Add some symbolic constants to the module */\n\tPyModule_AddIntConstant(m, \"MODE_ECB\", MODE_ECB);\n\tPyModule_AddIntConstant(m, \"MODE_CBC\", MODE_CBC);\n\tPyModule_AddIntConstant(m, \"MODE_CFB\", MODE_CFB);\n\tPyModule_AddIntConstant(m, \"MODE_PGP\", MODE_PGP); /** Vestigial **/\n\tPyModule_AddIntConstant(m, \"MODE_OFB\", MODE_OFB);\n\tPyModule_AddIntConstant(m, \"MODE_CTR\", MODE_CTR);\n\tPyModule_AddIntConstant(m, \"block_size\", BLOCK_SIZE);\n\tPyModule_AddIntConstant(m, \"key_size\", KEY_SIZE);\n\n\t/* Import CounterBE and CounterLE from the _counter module */\n\tPy_CLEAR(_counter_module);\n\t_counter_module = PyImport_ImportModule(\"Crypto.Util._counter\");\n\tif (_counter_module == NULL)\n\t\tgoto errout;\n\tPCT_CounterBEType = (PyTypeObject *)PyObject_GetAttrString(_counter_module, \"CounterBE\");\n\tPCT_CounterLEType = (PyTypeObject *)PyObject_GetAttrString(_counter_module, \"CounterLE\");\n\n\t/* Simple ABI version check in case the user doesn't re-compile all of\n\t * the modules during an upgrade. */\n\tabiver = PyObject_GetAttrString(_counter_module, \"_PCT_CTR_ABI_VERSION\");\n\tif (PCT_CounterBEType == NULL || PyType_Check((PyObject *)PCT_CounterBEType) < 0 ||\n\t\t PCT_CounterLEType == NULL || PyType_Check((PyObject *)PCT_CounterLEType) < 0 ||\n\t\t abiver == NULL || PyInt_CheckExact(abiver) < 0 || PyInt_AS_LONG(abiver) != PCT_CTR_ABI_VERSION)\n\t{\n\t\tPyErr_SetString(PyExc_ImportError, \"Crypto.Util._counter ABI mismatch.  Was PyCrypto incorrectly compiled?\");\n\t\tgoto errout;\n\t}\n\n\t/* Create __all__ (to help generate documentation) */\n\t__all__ = PyList_New(10);\n\tif (__all__ == NULL)\n\t\tgoto errout;\n\tPyList_SetItem(__all__, 0, PyString_FromString(_MODULE_STRING));\t/* This is the ALGType object */\n\tPyList_SetItem(__all__, 1, PyString_FromString(\"new\"));\n\tPyList_SetItem(__all__, 2, PyString_FromString(\"MODE_ECB\"));\n\tPyList_SetItem(__all__, 3, PyString_FromString(\"MODE_CBC\"));\n\tPyList_SetItem(__all__, 4, PyString_FromString(\"MODE_CFB\"));\n\tPyList_SetItem(__all__, 5, PyString_FromString(\"MODE_PGP\"));\n\tPyList_SetItem(__all__, 6, PyString_FromString(\"MODE_OFB\"));\n\tPyList_SetItem(__all__, 7, PyString_FromString(\"MODE_CTR\"));\n\tPyList_SetItem(__all__, 8, PyString_FromString(\"block_size\"));\n\tPyList_SetItem(__all__, 9, PyString_FromString(\"key_size\"));\n\tPyObject_SetAttrString(m, \"__all__\", __all__);\n\nout:\n\t/* Final error check */\n\tif (m == NULL && !PyErr_Occurred()) {\n\t\tPyErr_SetString(PyExc_ImportError, \"can't initialize module\");\n\t\tgoto errout;\n\t}\n\n\t/* Free local objects here */\n\tPy_CLEAR(abiver);\n\tPy_CLEAR(__all__);\n\n\t/* Return */\n#ifdef IS_PY3K\n\treturn m;\n#else\n\treturn;\n#endif\n\nerrout:\n\t/* Free the module and other global objects here */\n\tPy_CLEAR(m);\n\tPy_CLEAR(_counter_module);\n\tPy_CLEAR(PCT_CounterBEType);\n\tPy_CLEAR(PCT_CounterLEType);\n\tgoto out;\n}\n/* vim:set ts=4 sw=4 sts=0 noexpandtab: */\n"], "filenames": ["lib/Crypto/SelfTest/Cipher/common.py", "src/block_template.c"], "buggy_code_start_loc": [608, 158], "buggy_code_end_loc": [619, 158], "fixing_code_start_loc": [608, 159], "fixing_code_end_loc": [635, 170], "type": "CWE-119", "message": "Heap-based buffer overflow in the ALGnew function in block_templace.c in Python Cryptography Toolkit (aka pycrypto) allows remote attackers to execute arbitrary code as demonstrated by a crafted iv parameter to cryptmsg.py.", "other": {"cve": {"id": "CVE-2013-7459", "sourceIdentifier": "cve@mitre.org", "published": "2017-02-15T15:59:00.153", "lastModified": "2017-07-01T01:29:05.047", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Heap-based buffer overflow in the ALGnew function in block_templace.c in Python Cryptography Toolkit (aka pycrypto) allows remote attackers to execute arbitrary code as demonstrated by a crafted iv parameter to cryptmsg.py."}, {"lang": "es", "value": "Desbordamiento de b\u00fafer basado en memoria din\u00e1mica en la funci\u00f3n ALGnew en block_templace.c en Python Cryptography Toolkit (tambi\u00e9n conocido como pycrypto) permite a atacantes remotos ejecutar c\u00f3digo arbitrario como se demuestra por un par\u00e1metro iv manipulado para cryptmsg.py."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:dlitz:pycrypto:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.6.1", "matchCriteriaId": "9A04076A-FFA3-48C6-A43D-171C93A38B5A"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:24:*:*:*:*:*:*:*", "matchCriteriaId": "C729D5D1-ED95-443A-9F53-5D7C2FD9B80C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:25:*:*:*:*:*:*:*", "matchCriteriaId": "772E9557-A371-4664-AE2D-4135AAEB89AA"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2016/12/27/8", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/95122", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1409754", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/dlitz/pycrypto/commit/8dbe0dc3eea5c689d4f76b37b93fe216cf1f00d4", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/dlitz/pycrypto/issues/176", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/C6BWNADPLKDBBQBUT3P75W7HAJCE7M3B/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/RJ37R2YLX56YZABFNAOWV4VTHTGYREAE/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://pony7.fr/ctf:public:32c3:cryptmsg", "source": "cve@mitre.org", "tags": ["Exploit", "Technical Description", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201702-14", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/dlitz/pycrypto/commit/8dbe0dc3eea5c689d4f76b37b93fe216cf1f00d4"}}