{"buggy_code": ["package gateway\n\nimport (\n\t\"context\"\n\t\"crypto/aes\"\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/golang/protobuf/ptypes\"\n\t\"github.com/jmoiron/sqlx\"\n\t\"github.com/pkg/errors\"\n\tlog \"github.com/sirupsen/logrus\"\n\n\t\"github.com/brocaar/chirpstack-api/go/v3/common\"\n\t\"github.com/brocaar/chirpstack-api/go/v3/gw\"\n\t\"github.com/brocaar/chirpstack-network-server/internal/helpers\"\n\t\"github.com/brocaar/chirpstack-network-server/internal/logging\"\n\t\"github.com/brocaar/chirpstack-network-server/internal/storage\"\n\t\"github.com/brocaar/lorawan\"\n)\n\n// UpdateMetaDataInRxInfoSet updates the gateway meta-data in the\n// given rx-info set. It will:\n//   - add the gateway location\n//   - set the FPGA id if available\n//   - decrypt the fine-timestamp (if available and AES key is set)\nfunc UpdateMetaDataInRxInfoSet(ctx context.Context, db sqlx.Queryer, rxInfo []*gw.UplinkRXInfo) error {\n\tfor i := range rxInfo {\n\t\tid := helpers.GetGatewayID(rxInfo[i])\n\t\tg, err := storage.GetAndCacheGateway(ctx, db, id)\n\t\tif err != nil {\n\t\t\tlog.WithFields(log.Fields{\n\t\t\t\t\"ctx_id\":     ctx.Value(logging.ContextIDKey),\n\t\t\t\t\"gateway_id\": id,\n\t\t\t}).WithError(err).Error(\"get gateway error\")\n\t\t\tcontinue\n\t\t}\n\n\t\t// set gateway location\n\t\trxInfo[i].Location = &common.Location{\n\t\t\tLatitude:  g.Location.Latitude,\n\t\t\tLongitude: g.Location.Longitude,\n\t\t\tAltitude:  g.Altitude,\n\t\t}\n\n\t\tvar board storage.GatewayBoard\n\t\tif int(rxInfo[i].Board) < len(g.Boards) {\n\t\t\tboard = g.Boards[int(rxInfo[i].Board)]\n\t\t}\n\n\t\t// set FPGA ID\n\t\t// this is useful when the AES decryption key is not set as it\n\t\t// indicates which key to use for decryption\n\t\tif rxInfo[i].FineTimestampType == gw.FineTimestampType_ENCRYPTED && board.FPGAID != nil {\n\t\t\ttsInfo := rxInfo[i].GetEncryptedFineTimestamp()\n\t\t\tif tsInfo == nil {\n\t\t\t\tlog.WithFields(log.Fields{\n\t\t\t\t\t\"ctx_id\":     ctx.Value(logging.ContextIDKey),\n\t\t\t\t\t\"gateway_id\": id,\n\t\t\t\t}).Error(\"encrypted_fine_timestamp must not be nil\")\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif len(tsInfo.FpgaId) == 0 {\n\t\t\t\ttsInfo.FpgaId = board.FPGAID[:]\n\t\t\t}\n\t\t}\n\n\t\t// decrypt fine-timestamp when the AES key is known\n\t\tif rxInfo[i].FineTimestampType == gw.FineTimestampType_ENCRYPTED && board.FineTimestampKey != nil {\n\t\t\ttsInfo := rxInfo[i].GetEncryptedFineTimestamp()\n\t\t\tif tsInfo == nil {\n\t\t\t\tlog.WithFields(log.Fields{\n\t\t\t\t\t\"ctx_id\":     ctx.Value(logging.ContextIDKey),\n\t\t\t\t\t\"gateway_id\": id,\n\t\t\t\t}).Error(\"encrypted_fine_timestamp must not be nil\")\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif rxInfo[i].Time == nil {\n\t\t\t\tlog.WithFields(log.Fields{\n\t\t\t\t\t\"ctx_id\":     ctx.Value(logging.ContextIDKey),\n\t\t\t\t\t\"gateway_id\": id,\n\t\t\t\t}).Error(\"time must not be nil\")\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\trxTime, err := ptypes.Timestamp(rxInfo[i].Time)\n\t\t\tif err != nil {\n\t\t\t\tlog.WithFields(log.Fields{\n\t\t\t\t\t\"ctx_id\":     ctx.Value(logging.ContextIDKey),\n\t\t\t\t\t\"gateway_id\": id,\n\t\t\t\t}).WithError(err).Error(\"get timestamp error\")\n\t\t\t}\n\n\t\t\tplainTS, err := decryptFineTimestamp(*board.FineTimestampKey, rxTime, *tsInfo)\n\t\t\tif err != nil {\n\t\t\t\tlog.WithFields(log.Fields{\n\t\t\t\t\t\"ctx_id\":     ctx.Value(logging.ContextIDKey),\n\t\t\t\t\t\"gateway_id\": id,\n\t\t\t\t}).WithError(err).Error(\"decrypt fine-timestamp error\")\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\trxInfo[i].FineTimestampType = gw.FineTimestampType_PLAIN\n\t\t\trxInfo[i].FineTimestamp = &gw.UplinkRXInfo_PlainFineTimestamp{\n\t\t\t\tPlainFineTimestamp: &plainTS,\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc decryptFineTimestamp(key lorawan.AES128Key, rxTime time.Time, ts gw.EncryptedFineTimestamp) (gw.PlainFineTimestamp, error) {\n\tvar plainTS gw.PlainFineTimestamp\n\n\tblock, err := aes.NewCipher(key[:])\n\tif err != nil {\n\t\treturn plainTS, errors.Wrap(err, \"new cipher error\")\n\t}\n\n\tif len(ts.EncryptedNs) != block.BlockSize() {\n\t\treturn plainTS, fmt.Errorf(\"invalid block-size (%d) or ciphertext length (%d)\", block.BlockSize(), len(ts.EncryptedNs))\n\t}\n\n\tct := make([]byte, block.BlockSize())\n\tblock.Decrypt(ct, ts.EncryptedNs)\n\n\tnanoSec := binary.BigEndian.Uint64(ct[len(ct)-8:])\n\tnanoSec = nanoSec / 32\n\n\tif time.Duration(nanoSec) >= time.Second {\n\t\treturn plainTS, errors.New(\"expected fine-timestamp nanosecond remainder must be < 1 second, did you set the correct decryption key?\")\n\t}\n\n\trxTime = rxTime.Add(time.Duration(nanoSec) * time.Nanosecond)\n\n\tplainTS.Time, err = ptypes.TimestampProto(rxTime)\n\tif err != nil {\n\t\treturn plainTS, errors.Wrap(err, \"timestamp proto error\")\n\t}\n\n\treturn plainTS, nil\n}\n", "package stats\n\nimport (\n\t\"context\"\n\t\"time\"\n\n\t\"github.com/pkg/errors\"\n\tlog \"github.com/sirupsen/logrus\"\n\n\t\"github.com/brocaar/chirpstack-api/go/v3/as\"\n\t\"github.com/brocaar/chirpstack-api/go/v3/common\"\n\t\"github.com/brocaar/chirpstack-api/go/v3/gw\"\n\t\"github.com/brocaar/chirpstack-network-server/internal/backend/gateway\"\n\t\"github.com/brocaar/chirpstack-network-server/internal/band\"\n\t\"github.com/brocaar/chirpstack-network-server/internal/helpers\"\n\t\"github.com/brocaar/chirpstack-network-server/internal/logging\"\n\t\"github.com/brocaar/chirpstack-network-server/internal/storage\"\n\tloraband \"github.com/brocaar/lorawan/band\"\n)\n\ntype statsContext struct {\n\tctx          context.Context\n\tgateway      storage.Gateway\n\tgatewayStats gw.GatewayStats\n}\n\nvar tasks = []func(*statsContext) error{\n\tgetGateway,\n\tupdateGatewayState,\n\thandleGatewayConfigurationUpdate,\n\tforwardGatewayStats,\n}\n\n// Handle handles the gateway stats\nfunc Handle(ctx context.Context, stats gw.GatewayStats) error {\n\tsctx := statsContext{\n\t\tctx:          ctx,\n\t\tgatewayStats: stats,\n\t}\n\n\tfor _, t := range tasks {\n\t\tif err := t(&sctx); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc getGateway(ctx *statsContext) error {\n\tgatewayID := helpers.GetGatewayID(&ctx.gatewayStats)\n\tgw, err := storage.GetAndCacheGateway(ctx.ctx, storage.DB(), gatewayID)\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"get gateway error\")\n\t}\n\n\tctx.gateway = gw\n\treturn nil\n}\n\nfunc updateGatewayState(ctx *statsContext) error {\n\tnow := time.Now()\n\tif ctx.gateway.FirstSeenAt == nil {\n\t\tctx.gateway.FirstSeenAt = &now\n\t}\n\tctx.gateway.LastSeenAt = &now\n\n\tif ctx.gatewayStats.Location != nil {\n\t\tctx.gateway.Location.Latitude = ctx.gatewayStats.Location.Latitude\n\t\tctx.gateway.Location.Longitude = ctx.gatewayStats.Location.Longitude\n\t\tctx.gateway.Altitude = ctx.gatewayStats.Location.Altitude\n\t}\n\n\tif err := storage.UpdateGateway(ctx.ctx, storage.DB(), &ctx.gateway); err != nil {\n\t\treturn errors.Wrap(err, \"update gateway error\")\n\t}\n\n\tif err := storage.FlushGatewayCache(ctx.ctx, ctx.gateway.GatewayID); err != nil {\n\t\treturn errors.Wrap(err, \"flush gateway cache error\")\n\t}\n\n\treturn nil\n}\n\nfunc handleGatewayConfigurationUpdate(ctx *statsContext) error {\n\tif ctx.gateway.GatewayProfileID == nil {\n\t\tlog.WithFields(log.Fields{\n\t\t\t\"gateway_id\": ctx.gateway.GatewayID,\n\t\t\t\"ctx_id\":     ctx.ctx.Value(logging.ContextIDKey),\n\t\t}).Debug(\"gateway-profile is not set, skipping configuration update\")\n\t\treturn nil\n\t}\n\n\tgwProfile, err := storage.GetGatewayProfile(ctx.ctx, storage.DB(), *ctx.gateway.GatewayProfileID)\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"get gateway-profile error\")\n\t}\n\n\tif gwProfile.GetVersion() == ctx.gatewayStats.ConfigVersion || gwProfile.GetVersion() == ctx.gatewayStats.GetMetaData()[\"config_version\"] {\n\t\tlog.WithFields(log.Fields{\n\t\t\t\"gateway_id\": ctx.gateway.GatewayID,\n\t\t\t\"version\":    ctx.gatewayStats.ConfigVersion,\n\t\t\t\"ctx_id\":     ctx.ctx.Value(logging.ContextIDKey),\n\t\t}).Debug(\"gateway configuration is up-to-date\")\n\t\treturn nil\n\t}\n\n\tconfigPacket := gw.GatewayConfiguration{\n\t\tGatewayId: ctx.gateway.GatewayID[:],\n\t\tVersion:   gwProfile.GetVersion(),\n\t}\n\n\tfor _, i := range gwProfile.Channels {\n\t\tc, err := band.Band().GetUplinkChannel(int(i))\n\t\tif err != nil {\n\t\t\treturn errors.Wrap(err, \"get channel error\")\n\t\t}\n\n\t\tgwC := gw.ChannelConfiguration{\n\t\t\tFrequency:  uint32(c.Frequency),\n\t\t\tModulation: common.Modulation_LORA,\n\t\t}\n\n\t\tmodConfig := gw.LoRaModulationConfig{}\n\n\t\tfor drI := c.MaxDR; drI >= c.MinDR; drI-- {\n\t\t\tdr, err := band.Band().GetDataRate(drI)\n\t\t\tif err != nil {\n\t\t\t\treturn errors.Wrap(err, \"get data-rate error\")\n\t\t\t}\n\n\t\t\tmodConfig.SpreadingFactors = append(modConfig.SpreadingFactors, uint32(dr.SpreadFactor))\n\t\t\tmodConfig.Bandwidth = uint32(dr.Bandwidth)\n\t\t}\n\n\t\tgwC.ModulationConfig = &gw.ChannelConfiguration_LoraModulationConfig{\n\t\t\tLoraModulationConfig: &modConfig,\n\t\t}\n\n\t\tconfigPacket.Channels = append(configPacket.Channels, &gwC)\n\t}\n\n\tfor _, c := range gwProfile.ExtraChannels {\n\t\tgwC := gw.ChannelConfiguration{\n\t\t\tFrequency: uint32(c.Frequency),\n\t\t}\n\n\t\tswitch loraband.Modulation(c.Modulation) {\n\t\tcase loraband.LoRaModulation:\n\t\t\tgwC.Modulation = common.Modulation_LORA\n\t\t\tmodConfig := gw.LoRaModulationConfig{\n\t\t\t\tBandwidth: uint32(c.Bandwidth),\n\t\t\t}\n\n\t\t\tfor _, sf := range c.SpreadingFactors {\n\t\t\t\tmodConfig.SpreadingFactors = append(modConfig.SpreadingFactors, uint32(sf))\n\t\t\t}\n\n\t\t\tgwC.ModulationConfig = &gw.ChannelConfiguration_LoraModulationConfig{\n\t\t\t\tLoraModulationConfig: &modConfig,\n\t\t\t}\n\t\tcase loraband.FSKModulation:\n\t\t\tgwC.Modulation = common.Modulation_FSK\n\t\t\tmodConfig := gw.FSKModulationConfig{\n\t\t\t\tBandwidth: uint32(c.Bandwidth),\n\t\t\t\tBitrate:   uint32(c.Bitrate),\n\t\t\t}\n\n\t\t\tgwC.ModulationConfig = &gw.ChannelConfiguration_FskModulationConfig{\n\t\t\t\tFskModulationConfig: &modConfig,\n\t\t\t}\n\t\t}\n\n\t\tconfigPacket.Channels = append(configPacket.Channels, &gwC)\n\t}\n\n\tif err := gateway.Backend().SendGatewayConfigPacket(configPacket); err != nil {\n\t\treturn errors.Wrap(err, \"send gateway-configuration packet error\")\n\t}\n\n\treturn nil\n}\n\nfunc forwardGatewayStats(ctx *statsContext) error {\n\trp, err := storage.GetRoutingProfile(ctx.ctx, storage.DB(), ctx.gateway.RoutingProfileID)\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"get routing-profile error\")\n\t}\n\n\tasClient, err := rp.GetApplicationServerClient()\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"get application-server client error\")\n\t}\n\n\t_, err = asClient.HandleGatewayStats(ctx.ctx, &as.HandleGatewayStatsRequest{\n\t\tGatewayId:           ctx.gatewayStats.GatewayId,\n\t\tStatsId:             ctx.gatewayStats.StatsId,\n\t\tTime:                ctx.gatewayStats.Time,\n\t\tLocation:            ctx.gatewayStats.Location,\n\t\tRxPacketsReceived:   ctx.gatewayStats.RxPacketsReceived,\n\t\tRxPacketsReceivedOk: ctx.gatewayStats.RxPacketsReceivedOk,\n\t\tTxPacketsReceived:   ctx.gatewayStats.TxPacketsReceived,\n\t\tTxPacketsEmitted:    ctx.gatewayStats.TxPacketsEmitted,\n\t\tMetadata:            ctx.gatewayStats.MetaData,\n\t})\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"handle gateway stats error\")\n\t}\n\n\treturn nil\n}\n", "package uplink\n\nimport (\n\t\"context\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/gofrs/uuid\"\n\t\"github.com/pkg/errors\"\n\tlog \"github.com/sirupsen/logrus\"\n\n\t\"github.com/brocaar/chirpstack-api/go/v3/gw\"\n\t\"github.com/brocaar/chirpstack-api/go/v3/nc\"\n\t\"github.com/brocaar/chirpstack-api/go/v3/ns\"\n\t\"github.com/brocaar/chirpstack-network-server/internal/backend/controller\"\n\tgwbackend \"github.com/brocaar/chirpstack-network-server/internal/backend/gateway\"\n\t\"github.com/brocaar/chirpstack-network-server/internal/config\"\n\t\"github.com/brocaar/chirpstack-network-server/internal/downlink/ack\"\n\t\"github.com/brocaar/chirpstack-network-server/internal/framelog\"\n\t\"github.com/brocaar/chirpstack-network-server/internal/gateway\"\n\t\"github.com/brocaar/chirpstack-network-server/internal/helpers\"\n\t\"github.com/brocaar/chirpstack-network-server/internal/logging\"\n\t\"github.com/brocaar/chirpstack-network-server/internal/models\"\n\t\"github.com/brocaar/chirpstack-network-server/internal/storage\"\n\t\"github.com/brocaar/chirpstack-network-server/internal/uplink/data\"\n\t\"github.com/brocaar/chirpstack-network-server/internal/uplink/join\"\n\t\"github.com/brocaar/chirpstack-network-server/internal/uplink/proprietary\"\n\t\"github.com/brocaar/chirpstack-network-server/internal/uplink/rejoin\"\n\t\"github.com/brocaar/lorawan\"\n)\n\nvar (\n\tdeduplicationDelay time.Duration\n)\n\n// Setup configures the package.\nfunc Setup(conf config.Config) error {\n\tif err := data.Setup(conf); err != nil {\n\t\treturn errors.Wrap(err, \"configure uplink/data error\")\n\t}\n\n\tif err := join.Setup(conf); err != nil {\n\t\treturn errors.Wrap(err, \"configure uplink/join error\")\n\t}\n\n\tif err := rejoin.Setup(conf); err != nil {\n\t\treturn errors.Wrap(err, \"configure uplink/rejoin error\")\n\t}\n\n\tdeduplicationDelay = conf.NetworkServer.DeduplicationDelay\n\n\treturn nil\n}\n\n// Server represents a server listening for uplink packets.\ntype Server struct {\n\twg sync.WaitGroup\n}\n\n// NewServer creates a new server.\nfunc NewServer() *Server {\n\treturn &Server{}\n}\n\n// Start starts the server.\nfunc (s *Server) Start() error {\n\tgo func() {\n\t\ts.wg.Add(1)\n\t\tdefer s.wg.Done()\n\t\tHandleUplinkFrames(&s.wg)\n\t}()\n\n\tgo func() {\n\t\ts.wg.Add(1)\n\t\tdefer s.wg.Done()\n\t\tHandleDownlinkTXAcks(&s.wg)\n\t}()\n\treturn nil\n}\n\n// Stop closes the gateway backend and waits for the server to complete the\n// pending packets.\nfunc (s *Server) Stop() error {\n\tif err := gwbackend.Backend().Close(); err != nil {\n\t\treturn fmt.Errorf(\"close gateway backend error: %s\", err)\n\t}\n\tlog.Info(\"uplink: waiting for pending actions to complete\")\n\ts.wg.Wait()\n\treturn nil\n}\n\n// HandleUplinkFrames consumes received packets by the gateway and handles them\n// in a separate go-routine. Errors are logged.\nfunc HandleUplinkFrames(wg *sync.WaitGroup) {\n\tfor uplinkFrame := range gwbackend.Backend().RXPacketChan() {\n\t\tgo func(uplinkFrame gw.UplinkFrame) {\n\t\t\twg.Add(1)\n\t\t\tdefer wg.Done()\n\n\t\t\t// The ctxID will be available as context value \"ctx_id\" so that\n\t\t\t// this can be used when writing logs. This makes it easier to\n\t\t\t// group multiple log-lines to the same context.\n\t\t\tctxID, err := uuid.NewV4()\n\t\t\tif err != nil {\n\t\t\t\tlog.WithError(err).Error(\"uplink: get new uuid error\")\n\t\t\t}\n\n\t\t\tctx := context.Background()\n\t\t\tctx = context.WithValue(ctx, logging.ContextIDKey, ctxID)\n\n\t\t\tif err := HandleUplinkFrame(ctx, uplinkFrame); err != nil {\n\t\t\t\tlog.WithFields(log.Fields{\n\t\t\t\t\t\"ctx_id\": ctxID,\n\t\t\t\t}).WithError(err).Error(\"uplink: processing uplink frame error\")\n\t\t\t}\n\t\t}(uplinkFrame)\n\t}\n}\n\n// HandleUplinkFrame handles a single uplink frame.\nfunc HandleUplinkFrame(ctx context.Context, uplinkFrame gw.UplinkFrame) error {\n\treturn collectUplinkFrames(ctx, uplinkFrame)\n}\n\n// HandleDownlinkTXAcks consumes received downlink tx acknowledgements from\n// the gateway.\nfunc HandleDownlinkTXAcks(wg *sync.WaitGroup) {\n\tfor downlinkTXAck := range gwbackend.Backend().DownlinkTXAckChan() {\n\t\tgo func(downlinkTXAck gw.DownlinkTXAck) {\n\t\t\twg.Add(1)\n\t\t\tdefer wg.Done()\n\n\t\t\t// The ctxID will be available as context value \"ctx_id\" so that\n\t\t\t// this can be used when writing logs. This makes it easier to\n\t\t\t// group multiple log-lines to the same context.\n\t\t\tvar ctxID uuid.UUID\n\t\t\tif downlinkTXAck.DownlinkId != nil {\n\t\t\t\tcopy(ctxID[:], downlinkTXAck.DownlinkId)\n\t\t\t}\n\n\t\t\tctx := context.Background()\n\t\t\tctx = context.WithValue(ctx, logging.ContextIDKey, ctxID)\n\n\t\t\tif err := ack.HandleDownlinkTXAck(ctx, downlinkTXAck); err != nil {\n\t\t\t\tlog.WithFields(log.Fields{\n\t\t\t\t\t\"gateway_id\": hex.EncodeToString(downlinkTXAck.GatewayId),\n\t\t\t\t\t\"token\":      downlinkTXAck.Token,\n\t\t\t\t\t\"ctx_id\":     ctxID,\n\t\t\t\t}).WithError(err).Error(\"uplink: handle downlink tx ack error\")\n\t\t\t}\n\n\t\t}(downlinkTXAck)\n\t}\n}\n\nfunc collectUplinkFrames(ctx context.Context, uplinkFrame gw.UplinkFrame) error {\n\treturn collectAndCallOnce(uplinkFrame, func(rxPacket models.RXPacket) error {\n\t\terr := handleCollectedUplink(ctx, uplinkFrame, rxPacket)\n\t\tif err != nil {\n\t\t\tcause := errors.Cause(err)\n\t\t\tif cause == storage.ErrDoesNotExist || cause == storage.ErrFrameCounterReset || cause == storage.ErrInvalidMIC || cause == storage.ErrFrameCounterRetransmission {\n\t\t\t\tif _, err := controller.Client().HandleRejectedUplinkFrameSet(ctx, &nc.HandleRejectedUplinkFrameSetRequest{\n\t\t\t\t\tFrameSet: &gw.UplinkFrameSet{\n\t\t\t\t\t\tPhyPayload: uplinkFrame.PhyPayload,\n\t\t\t\t\t\tTxInfo:     rxPacket.TXInfo,\n\t\t\t\t\t\tRxInfo:     rxPacket.RXInfoSet,\n\t\t\t\t\t},\n\t\t\t\t}); err != nil {\n\t\t\t\t\tlog.WithError(err).Error(\"uplink: call controller HandleRejectedUplinkFrameSet RPC error\")\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn err\n\t})\n}\n\nfunc handleCollectedUplink(ctx context.Context, uplinkFrame gw.UplinkFrame, rxPacket models.RXPacket) error {\n\tvar uplinkIDs []uuid.UUID\n\tfor _, p := range rxPacket.RXInfoSet {\n\t\tuplinkIDs = append(uplinkIDs, helpers.GetUplinkID(p))\n\t}\n\n\tlog.WithFields(log.Fields{\n\t\t\"uplink_ids\": uplinkIDs,\n\t\t\"mtype\":      rxPacket.PHYPayload.MHDR.MType,\n\t\t\"ctx_id\":     ctx.Value(logging.ContextIDKey),\n\t}).Info(\"uplink: frame(s) collected\")\n\n\t// update the gateway meta-data\n\tif err := gateway.UpdateMetaDataInRxInfoSet(ctx, storage.DB(), rxPacket.RXInfoSet); err != nil {\n\t\tlog.WithError(err).Error(\"uplink: update gateway meta-data in rx-info set error\")\n\t}\n\n\t// log the frame for each receiving gateway.\n\tif err := framelog.LogUplinkFrameForGateways(ctx, ns.UplinkFrameLog{\n\t\tPhyPayload: uplinkFrame.PhyPayload,\n\t\tTxInfo:     rxPacket.TXInfo,\n\t\tRxInfo:     rxPacket.RXInfoSet,\n\t}); err != nil {\n\t\tlog.WithFields(log.Fields{\n\t\t\t\"ctx_id\": ctx.Value(logging.ContextIDKey),\n\t\t}).WithError(err).Error(\"uplink: log uplink frames for gateways error\")\n\t}\n\n\t// handle the frame based on message-type\n\tswitch rxPacket.PHYPayload.MHDR.MType {\n\tcase lorawan.JoinRequest:\n\t\treturn join.Handle(ctx, rxPacket)\n\tcase lorawan.RejoinRequest:\n\t\treturn rejoin.Handle(ctx, rxPacket)\n\tcase lorawan.UnconfirmedDataUp, lorawan.ConfirmedDataUp:\n\t\treturn data.Handle(ctx, rxPacket)\n\tcase lorawan.Proprietary:\n\t\treturn proprietary.Handle(ctx, rxPacket)\n\tdefault:\n\t\treturn nil\n\t}\n}\n"], "fixing_code": ["package gateway\n\nimport (\n\t\"context\"\n\t\"crypto/aes\"\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/golang/protobuf/ptypes\"\n\t\"github.com/jmoiron/sqlx\"\n\t\"github.com/pkg/errors\"\n\tlog \"github.com/sirupsen/logrus\"\n\n\t\"github.com/brocaar/chirpstack-api/go/v3/common\"\n\t\"github.com/brocaar/chirpstack-api/go/v3/gw\"\n\t\"github.com/brocaar/chirpstack-network-server/internal/helpers\"\n\t\"github.com/brocaar/chirpstack-network-server/internal/logging\"\n\t\"github.com/brocaar/chirpstack-network-server/internal/storage\"\n\t\"github.com/brocaar/lorawan\"\n)\n\n// UpdateMetaDataInRxInfoSet updates the gateway meta-data in the\n// given rx-info set. It will:\n//   - add the gateway location\n//   - set the FPGA id if available\n//   - decrypt the fine-timestamp (if available and AES key is set)\nfunc UpdateMetaDataInRxInfoSet(ctx context.Context, db sqlx.Queryer, rxInfoSet []*gw.UplinkRXInfo) []*gw.UplinkRXInfo {\n\tvar out []*gw.UplinkRXInfo\n\n\tfor i := range rxInfoSet {\n\t\trxInfo := rxInfoSet[i]\n\n\t\tid := helpers.GetGatewayID(rxInfo)\n\t\tg, err := storage.GetAndCacheGateway(ctx, db, id)\n\t\tif err != nil {\n\t\t\tif errors.Cause(err) == storage.ErrDoesNotExist {\n\t\t\t\tlog.WithFields(log.Fields{\n\t\t\t\t\t\"ctx_id\":     ctx.Value(logging.ContextIDKey),\n\t\t\t\t\t\"gateway_id\": id,\n\t\t\t\t}).Warning(\"uplink received by unknown gateway\")\n\t\t\t} else {\n\t\t\t\tlog.WithFields(log.Fields{\n\t\t\t\t\t\"ctx_id\":     ctx.Value(logging.ContextIDKey),\n\t\t\t\t\t\"gateway_id\": id,\n\t\t\t\t}).WithError(err).Error(\"get gateway error\")\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\t// set gateway location\n\t\trxInfo.Location = &common.Location{\n\t\t\tLatitude:  g.Location.Latitude,\n\t\t\tLongitude: g.Location.Longitude,\n\t\t\tAltitude:  g.Altitude,\n\t\t}\n\n\t\tvar board storage.GatewayBoard\n\t\tif int(rxInfo.Board) < len(g.Boards) {\n\t\t\tboard = g.Boards[int(rxInfo.Board)]\n\t\t}\n\n\t\t// set FPGA ID\n\t\t// this is useful when the AES decryption key is not set as it\n\t\t// indicates which key to use for decryption\n\t\tif tsInfo := rxInfo.GetEncryptedFineTimestamp(); tsInfo != nil && board.FPGAID != nil {\n\t\t\tif len(tsInfo.FpgaId) == 0 {\n\t\t\t\ttsInfo.FpgaId = board.FPGAID[:]\n\t\t\t}\n\t\t}\n\n\t\t// decrypt fine-timestamp when the AES key is known\n\t\tif tsInfo := rxInfo.GetEncryptedFineTimestamp(); tsInfo != nil && board.FineTimestampKey != nil {\n\t\t\trxTime, err := ptypes.Timestamp(rxInfo.GetTime())\n\t\t\tif err != nil {\n\t\t\t\tlog.WithFields(log.Fields{\n\t\t\t\t\t\"ctx_id\":     ctx.Value(logging.ContextIDKey),\n\t\t\t\t\t\"gateway_id\": id,\n\t\t\t\t}).WithError(err).Error(\"get timestamp error\")\n\t\t\t}\n\n\t\t\tplainTS, err := decryptFineTimestamp(*board.FineTimestampKey, rxTime, *tsInfo)\n\t\t\tif err != nil {\n\t\t\t\tlog.WithFields(log.Fields{\n\t\t\t\t\t\"ctx_id\":     ctx.Value(logging.ContextIDKey),\n\t\t\t\t\t\"gateway_id\": id,\n\t\t\t\t}).WithError(err).Error(\"decrypt fine-timestamp error\")\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\trxInfo.FineTimestampType = gw.FineTimestampType_PLAIN\n\t\t\trxInfo.FineTimestamp = &gw.UplinkRXInfo_PlainFineTimestamp{\n\t\t\t\tPlainFineTimestamp: &plainTS,\n\t\t\t}\n\t\t}\n\n\t\tout = append(out, rxInfo)\n\t}\n\n\treturn out\n}\n\nfunc decryptFineTimestamp(key lorawan.AES128Key, rxTime time.Time, ts gw.EncryptedFineTimestamp) (gw.PlainFineTimestamp, error) {\n\tvar plainTS gw.PlainFineTimestamp\n\n\tblock, err := aes.NewCipher(key[:])\n\tif err != nil {\n\t\treturn plainTS, errors.Wrap(err, \"new cipher error\")\n\t}\n\n\tif len(ts.EncryptedNs) != block.BlockSize() {\n\t\treturn plainTS, fmt.Errorf(\"invalid block-size (%d) or ciphertext length (%d)\", block.BlockSize(), len(ts.EncryptedNs))\n\t}\n\n\tct := make([]byte, block.BlockSize())\n\tblock.Decrypt(ct, ts.EncryptedNs)\n\n\tnanoSec := binary.BigEndian.Uint64(ct[len(ct)-8:])\n\tnanoSec = nanoSec / 32\n\n\tif time.Duration(nanoSec) >= time.Second {\n\t\treturn plainTS, errors.New(\"expected fine-timestamp nanosecond remainder must be < 1 second, did you set the correct decryption key?\")\n\t}\n\n\trxTime = rxTime.Add(time.Duration(nanoSec) * time.Nanosecond)\n\n\tplainTS.Time, err = ptypes.TimestampProto(rxTime)\n\tif err != nil {\n\t\treturn plainTS, errors.Wrap(err, \"timestamp proto error\")\n\t}\n\n\treturn plainTS, nil\n}\n", "package stats\n\nimport (\n\t\"context\"\n\t\"time\"\n\n\t\"github.com/pkg/errors\"\n\tlog \"github.com/sirupsen/logrus\"\n\n\t\"github.com/brocaar/chirpstack-api/go/v3/as\"\n\t\"github.com/brocaar/chirpstack-api/go/v3/common\"\n\t\"github.com/brocaar/chirpstack-api/go/v3/gw\"\n\t\"github.com/brocaar/chirpstack-network-server/internal/backend/gateway\"\n\t\"github.com/brocaar/chirpstack-network-server/internal/band\"\n\t\"github.com/brocaar/chirpstack-network-server/internal/helpers\"\n\t\"github.com/brocaar/chirpstack-network-server/internal/logging\"\n\t\"github.com/brocaar/chirpstack-network-server/internal/storage\"\n\tloraband \"github.com/brocaar/lorawan/band\"\n)\n\nvar ErrAbort = errors.New(\"abort\")\n\ntype statsContext struct {\n\tctx          context.Context\n\tgateway      storage.Gateway\n\tgatewayStats gw.GatewayStats\n}\n\nvar tasks = []func(*statsContext) error{\n\tgetGateway,\n\tupdateGatewayState,\n\thandleGatewayConfigurationUpdate,\n\tforwardGatewayStats,\n}\n\n// Handle handles the gateway stats\nfunc Handle(ctx context.Context, stats gw.GatewayStats) error {\n\tsctx := statsContext{\n\t\tctx:          ctx,\n\t\tgatewayStats: stats,\n\t}\n\n\tfor _, t := range tasks {\n\t\tif err := t(&sctx); err != nil {\n\t\t\tif err == ErrAbort {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc getGateway(ctx *statsContext) error {\n\tgatewayID := helpers.GetGatewayID(&ctx.gatewayStats)\n\tgw, err := storage.GetAndCacheGateway(ctx.ctx, storage.DB(), gatewayID)\n\tif err != nil {\n\t\tif errors.Cause(err) == storage.ErrDoesNotExist {\n\t\t\tlog.WithFields(log.Fields{\n\t\t\t\t\"ctx_id\":     ctx.ctx.Value(logging.ContextIDKey),\n\t\t\t\t\"gateway_id\": gatewayID,\n\t\t\t}).Warning(\"gateway/stats: stats received by unknown gateway\")\n\t\t\treturn ErrAbort\n\t\t} else {\n\t\t\treturn errors.Wrap(err, \"get gateway error\")\n\t\t}\n\t}\n\n\tctx.gateway = gw\n\treturn nil\n}\n\nfunc updateGatewayState(ctx *statsContext) error {\n\tnow := time.Now()\n\tif ctx.gateway.FirstSeenAt == nil {\n\t\tctx.gateway.FirstSeenAt = &now\n\t}\n\tctx.gateway.LastSeenAt = &now\n\n\tif ctx.gatewayStats.Location != nil {\n\t\tctx.gateway.Location.Latitude = ctx.gatewayStats.Location.Latitude\n\t\tctx.gateway.Location.Longitude = ctx.gatewayStats.Location.Longitude\n\t\tctx.gateway.Altitude = ctx.gatewayStats.Location.Altitude\n\t}\n\n\tif err := storage.UpdateGateway(ctx.ctx, storage.DB(), &ctx.gateway); err != nil {\n\t\treturn errors.Wrap(err, \"update gateway error\")\n\t}\n\n\tif err := storage.FlushGatewayCache(ctx.ctx, ctx.gateway.GatewayID); err != nil {\n\t\treturn errors.Wrap(err, \"flush gateway cache error\")\n\t}\n\n\treturn nil\n}\n\nfunc handleGatewayConfigurationUpdate(ctx *statsContext) error {\n\tif ctx.gateway.GatewayProfileID == nil {\n\t\tlog.WithFields(log.Fields{\n\t\t\t\"gateway_id\": ctx.gateway.GatewayID,\n\t\t\t\"ctx_id\":     ctx.ctx.Value(logging.ContextIDKey),\n\t\t}).Debug(\"gateway-profile is not set, skipping configuration update\")\n\t\treturn nil\n\t}\n\n\tgwProfile, err := storage.GetGatewayProfile(ctx.ctx, storage.DB(), *ctx.gateway.GatewayProfileID)\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"get gateway-profile error\")\n\t}\n\n\tif gwProfile.GetVersion() == ctx.gatewayStats.ConfigVersion || gwProfile.GetVersion() == ctx.gatewayStats.GetMetaData()[\"config_version\"] {\n\t\tlog.WithFields(log.Fields{\n\t\t\t\"gateway_id\": ctx.gateway.GatewayID,\n\t\t\t\"version\":    ctx.gatewayStats.ConfigVersion,\n\t\t\t\"ctx_id\":     ctx.ctx.Value(logging.ContextIDKey),\n\t\t}).Debug(\"gateway configuration is up-to-date\")\n\t\treturn nil\n\t}\n\n\tconfigPacket := gw.GatewayConfiguration{\n\t\tGatewayId: ctx.gateway.GatewayID[:],\n\t\tVersion:   gwProfile.GetVersion(),\n\t}\n\n\tfor _, i := range gwProfile.Channels {\n\t\tc, err := band.Band().GetUplinkChannel(int(i))\n\t\tif err != nil {\n\t\t\treturn errors.Wrap(err, \"get channel error\")\n\t\t}\n\n\t\tgwC := gw.ChannelConfiguration{\n\t\t\tFrequency:  uint32(c.Frequency),\n\t\t\tModulation: common.Modulation_LORA,\n\t\t}\n\n\t\tmodConfig := gw.LoRaModulationConfig{}\n\n\t\tfor drI := c.MaxDR; drI >= c.MinDR; drI-- {\n\t\t\tdr, err := band.Band().GetDataRate(drI)\n\t\t\tif err != nil {\n\t\t\t\treturn errors.Wrap(err, \"get data-rate error\")\n\t\t\t}\n\n\t\t\tmodConfig.SpreadingFactors = append(modConfig.SpreadingFactors, uint32(dr.SpreadFactor))\n\t\t\tmodConfig.Bandwidth = uint32(dr.Bandwidth)\n\t\t}\n\n\t\tgwC.ModulationConfig = &gw.ChannelConfiguration_LoraModulationConfig{\n\t\t\tLoraModulationConfig: &modConfig,\n\t\t}\n\n\t\tconfigPacket.Channels = append(configPacket.Channels, &gwC)\n\t}\n\n\tfor _, c := range gwProfile.ExtraChannels {\n\t\tgwC := gw.ChannelConfiguration{\n\t\t\tFrequency: uint32(c.Frequency),\n\t\t}\n\n\t\tswitch loraband.Modulation(c.Modulation) {\n\t\tcase loraband.LoRaModulation:\n\t\t\tgwC.Modulation = common.Modulation_LORA\n\t\t\tmodConfig := gw.LoRaModulationConfig{\n\t\t\t\tBandwidth: uint32(c.Bandwidth),\n\t\t\t}\n\n\t\t\tfor _, sf := range c.SpreadingFactors {\n\t\t\t\tmodConfig.SpreadingFactors = append(modConfig.SpreadingFactors, uint32(sf))\n\t\t\t}\n\n\t\t\tgwC.ModulationConfig = &gw.ChannelConfiguration_LoraModulationConfig{\n\t\t\t\tLoraModulationConfig: &modConfig,\n\t\t\t}\n\t\tcase loraband.FSKModulation:\n\t\t\tgwC.Modulation = common.Modulation_FSK\n\t\t\tmodConfig := gw.FSKModulationConfig{\n\t\t\t\tBandwidth: uint32(c.Bandwidth),\n\t\t\t\tBitrate:   uint32(c.Bitrate),\n\t\t\t}\n\n\t\t\tgwC.ModulationConfig = &gw.ChannelConfiguration_FskModulationConfig{\n\t\t\t\tFskModulationConfig: &modConfig,\n\t\t\t}\n\t\t}\n\n\t\tconfigPacket.Channels = append(configPacket.Channels, &gwC)\n\t}\n\n\tif err := gateway.Backend().SendGatewayConfigPacket(configPacket); err != nil {\n\t\treturn errors.Wrap(err, \"send gateway-configuration packet error\")\n\t}\n\n\treturn nil\n}\n\nfunc forwardGatewayStats(ctx *statsContext) error {\n\trp, err := storage.GetRoutingProfile(ctx.ctx, storage.DB(), ctx.gateway.RoutingProfileID)\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"get routing-profile error\")\n\t}\n\n\tasClient, err := rp.GetApplicationServerClient()\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"get application-server client error\")\n\t}\n\n\t_, err = asClient.HandleGatewayStats(ctx.ctx, &as.HandleGatewayStatsRequest{\n\t\tGatewayId:           ctx.gatewayStats.GatewayId,\n\t\tStatsId:             ctx.gatewayStats.StatsId,\n\t\tTime:                ctx.gatewayStats.Time,\n\t\tLocation:            ctx.gatewayStats.Location,\n\t\tRxPacketsReceived:   ctx.gatewayStats.RxPacketsReceived,\n\t\tRxPacketsReceivedOk: ctx.gatewayStats.RxPacketsReceivedOk,\n\t\tTxPacketsReceived:   ctx.gatewayStats.TxPacketsReceived,\n\t\tTxPacketsEmitted:    ctx.gatewayStats.TxPacketsEmitted,\n\t\tMetadata:            ctx.gatewayStats.MetaData,\n\t})\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"handle gateway stats error\")\n\t}\n\n\treturn nil\n}\n", "package uplink\n\nimport (\n\t\"context\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/gofrs/uuid\"\n\t\"github.com/pkg/errors\"\n\tlog \"github.com/sirupsen/logrus\"\n\n\t\"github.com/brocaar/chirpstack-api/go/v3/gw\"\n\t\"github.com/brocaar/chirpstack-api/go/v3/nc\"\n\t\"github.com/brocaar/chirpstack-api/go/v3/ns\"\n\t\"github.com/brocaar/chirpstack-network-server/internal/backend/controller\"\n\tgwbackend \"github.com/brocaar/chirpstack-network-server/internal/backend/gateway\"\n\t\"github.com/brocaar/chirpstack-network-server/internal/config\"\n\t\"github.com/brocaar/chirpstack-network-server/internal/downlink/ack\"\n\t\"github.com/brocaar/chirpstack-network-server/internal/framelog\"\n\t\"github.com/brocaar/chirpstack-network-server/internal/gateway\"\n\t\"github.com/brocaar/chirpstack-network-server/internal/helpers\"\n\t\"github.com/brocaar/chirpstack-network-server/internal/logging\"\n\t\"github.com/brocaar/chirpstack-network-server/internal/models\"\n\t\"github.com/brocaar/chirpstack-network-server/internal/storage\"\n\t\"github.com/brocaar/chirpstack-network-server/internal/uplink/data\"\n\t\"github.com/brocaar/chirpstack-network-server/internal/uplink/join\"\n\t\"github.com/brocaar/chirpstack-network-server/internal/uplink/proprietary\"\n\t\"github.com/brocaar/chirpstack-network-server/internal/uplink/rejoin\"\n\t\"github.com/brocaar/lorawan\"\n)\n\nvar (\n\tdeduplicationDelay time.Duration\n)\n\n// Setup configures the package.\nfunc Setup(conf config.Config) error {\n\tif err := data.Setup(conf); err != nil {\n\t\treturn errors.Wrap(err, \"configure uplink/data error\")\n\t}\n\n\tif err := join.Setup(conf); err != nil {\n\t\treturn errors.Wrap(err, \"configure uplink/join error\")\n\t}\n\n\tif err := rejoin.Setup(conf); err != nil {\n\t\treturn errors.Wrap(err, \"configure uplink/rejoin error\")\n\t}\n\n\tdeduplicationDelay = conf.NetworkServer.DeduplicationDelay\n\n\treturn nil\n}\n\n// Server represents a server listening for uplink packets.\ntype Server struct {\n\twg sync.WaitGroup\n}\n\n// NewServer creates a new server.\nfunc NewServer() *Server {\n\treturn &Server{}\n}\n\n// Start starts the server.\nfunc (s *Server) Start() error {\n\tgo func() {\n\t\ts.wg.Add(1)\n\t\tdefer s.wg.Done()\n\t\tHandleUplinkFrames(&s.wg)\n\t}()\n\n\tgo func() {\n\t\ts.wg.Add(1)\n\t\tdefer s.wg.Done()\n\t\tHandleDownlinkTXAcks(&s.wg)\n\t}()\n\treturn nil\n}\n\n// Stop closes the gateway backend and waits for the server to complete the\n// pending packets.\nfunc (s *Server) Stop() error {\n\tif err := gwbackend.Backend().Close(); err != nil {\n\t\treturn fmt.Errorf(\"close gateway backend error: %s\", err)\n\t}\n\tlog.Info(\"uplink: waiting for pending actions to complete\")\n\ts.wg.Wait()\n\treturn nil\n}\n\n// HandleUplinkFrames consumes received packets by the gateway and handles them\n// in a separate go-routine. Errors are logged.\nfunc HandleUplinkFrames(wg *sync.WaitGroup) {\n\tfor uplinkFrame := range gwbackend.Backend().RXPacketChan() {\n\t\tgo func(uplinkFrame gw.UplinkFrame) {\n\t\t\twg.Add(1)\n\t\t\tdefer wg.Done()\n\n\t\t\t// The ctxID will be available as context value \"ctx_id\" so that\n\t\t\t// this can be used when writing logs. This makes it easier to\n\t\t\t// group multiple log-lines to the same context.\n\t\t\tctxID, err := uuid.NewV4()\n\t\t\tif err != nil {\n\t\t\t\tlog.WithError(err).Error(\"uplink: get new uuid error\")\n\t\t\t}\n\n\t\t\tctx := context.Background()\n\t\t\tctx = context.WithValue(ctx, logging.ContextIDKey, ctxID)\n\n\t\t\tif err := HandleUplinkFrame(ctx, uplinkFrame); err != nil {\n\t\t\t\tlog.WithFields(log.Fields{\n\t\t\t\t\t\"ctx_id\": ctxID,\n\t\t\t\t}).WithError(err).Error(\"uplink: processing uplink frame error\")\n\t\t\t}\n\t\t}(uplinkFrame)\n\t}\n}\n\n// HandleUplinkFrame handles a single uplink frame.\nfunc HandleUplinkFrame(ctx context.Context, uplinkFrame gw.UplinkFrame) error {\n\treturn collectUplinkFrames(ctx, uplinkFrame)\n}\n\n// HandleDownlinkTXAcks consumes received downlink tx acknowledgements from\n// the gateway.\nfunc HandleDownlinkTXAcks(wg *sync.WaitGroup) {\n\tfor downlinkTXAck := range gwbackend.Backend().DownlinkTXAckChan() {\n\t\tgo func(downlinkTXAck gw.DownlinkTXAck) {\n\t\t\twg.Add(1)\n\t\t\tdefer wg.Done()\n\n\t\t\t// The ctxID will be available as context value \"ctx_id\" so that\n\t\t\t// this can be used when writing logs. This makes it easier to\n\t\t\t// group multiple log-lines to the same context.\n\t\t\tvar ctxID uuid.UUID\n\t\t\tif downlinkTXAck.DownlinkId != nil {\n\t\t\t\tcopy(ctxID[:], downlinkTXAck.DownlinkId)\n\t\t\t}\n\n\t\t\tctx := context.Background()\n\t\t\tctx = context.WithValue(ctx, logging.ContextIDKey, ctxID)\n\n\t\t\tif err := ack.HandleDownlinkTXAck(ctx, downlinkTXAck); err != nil {\n\t\t\t\tlog.WithFields(log.Fields{\n\t\t\t\t\t\"gateway_id\": hex.EncodeToString(downlinkTXAck.GatewayId),\n\t\t\t\t\t\"token\":      downlinkTXAck.Token,\n\t\t\t\t\t\"ctx_id\":     ctxID,\n\t\t\t\t}).WithError(err).Error(\"uplink: handle downlink tx ack error\")\n\t\t\t}\n\n\t\t}(downlinkTXAck)\n\t}\n}\n\nfunc collectUplinkFrames(ctx context.Context, uplinkFrame gw.UplinkFrame) error {\n\treturn collectAndCallOnce(uplinkFrame, func(rxPacket models.RXPacket) error {\n\t\terr := handleCollectedUplink(ctx, uplinkFrame, rxPacket)\n\t\tif err != nil {\n\t\t\tcause := errors.Cause(err)\n\t\t\tif cause == storage.ErrDoesNotExist || cause == storage.ErrFrameCounterReset || cause == storage.ErrInvalidMIC || cause == storage.ErrFrameCounterRetransmission {\n\t\t\t\tif _, err := controller.Client().HandleRejectedUplinkFrameSet(ctx, &nc.HandleRejectedUplinkFrameSetRequest{\n\t\t\t\t\tFrameSet: &gw.UplinkFrameSet{\n\t\t\t\t\t\tPhyPayload: uplinkFrame.PhyPayload,\n\t\t\t\t\t\tTxInfo:     rxPacket.TXInfo,\n\t\t\t\t\t\tRxInfo:     rxPacket.RXInfoSet,\n\t\t\t\t\t},\n\t\t\t\t}); err != nil {\n\t\t\t\t\tlog.WithError(err).Error(\"uplink: call controller HandleRejectedUplinkFrameSet RPC error\")\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn err\n\t})\n}\n\nfunc handleCollectedUplink(ctx context.Context, uplinkFrame gw.UplinkFrame, rxPacket models.RXPacket) error {\n\t// update the gateway meta-data\n\trxPacket.RXInfoSet = gateway.UpdateMetaDataInRxInfoSet(ctx, storage.DB(), rxPacket.RXInfoSet)\n\n\t// Return if the RXInfoSet is empty.\n\tif len(rxPacket.RXInfoSet) == 0 {\n\t\treturn nil\n\t}\n\n\tvar uplinkIDs []uuid.UUID\n\tfor _, p := range rxPacket.RXInfoSet {\n\t\tuplinkIDs = append(uplinkIDs, helpers.GetUplinkID(p))\n\t}\n\n\tlog.WithFields(log.Fields{\n\t\t\"uplink_ids\": uplinkIDs,\n\t\t\"mtype\":      rxPacket.PHYPayload.MHDR.MType,\n\t\t\"ctx_id\":     ctx.Value(logging.ContextIDKey),\n\t}).Info(\"uplink: frame(s) collected\")\n\n\t// log the frame for each receiving gateway.\n\tif err := framelog.LogUplinkFrameForGateways(ctx, ns.UplinkFrameLog{\n\t\tPhyPayload: uplinkFrame.PhyPayload,\n\t\tTxInfo:     rxPacket.TXInfo,\n\t\tRxInfo:     rxPacket.RXInfoSet,\n\t}); err != nil {\n\t\tlog.WithFields(log.Fields{\n\t\t\t\"ctx_id\": ctx.Value(logging.ContextIDKey),\n\t\t}).WithError(err).Error(\"uplink: log uplink frames for gateways error\")\n\t}\n\n\t// handle the frame based on message-type\n\tswitch rxPacket.PHYPayload.MHDR.MType {\n\tcase lorawan.JoinRequest:\n\t\treturn join.Handle(ctx, rxPacket)\n\tcase lorawan.RejoinRequest:\n\t\treturn rejoin.Handle(ctx, rxPacket)\n\tcase lorawan.UnconfirmedDataUp, lorawan.ConfirmedDataUp:\n\t\treturn data.Handle(ctx, rxPacket)\n\tcase lorawan.Proprietary:\n\t\treturn proprietary.Handle(ctx, rxPacket)\n\tdefault:\n\t\treturn nil\n\t}\n}\n"], "filenames": ["internal/gateway/rx_info.go", "internal/gateway/stats/stats.go", "internal/uplink/uplink.go"], "buggy_code_start_loc": [28, 20, 180], "buggy_code_end_loc": [114, 55, 196], "fixing_code_start_loc": [28, 21, 181], "fixing_code_end_loc": [101, 68, 198], "type": "CWE-20", "message": "** DISPUTED ** An inaccurate frame deduplication process in ChirpStack Network Server 3.9.0 allows a malicious gateway to perform uplink Denial of Service via malformed frequency attributes in CollectAndCallOnceCollect in internal/uplink/collect.go. NOTE: the vendor's position is that there are no \"guarantees that allowing untrusted LoRa gateways to the network should still result in a secure network.\"", "other": {"cve": {"id": "CVE-2020-28349", "sourceIdentifier": "cve@mitre.org", "published": "2020-11-09T01:15:13.710", "lastModified": "2020-11-19T15:46:44.357", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "** DISPUTED ** An inaccurate frame deduplication process in ChirpStack Network Server 3.9.0 allows a malicious gateway to perform uplink Denial of Service via malformed frequency attributes in CollectAndCallOnceCollect in internal/uplink/collect.go. NOTE: the vendor's position is that there are no \"guarantees that allowing untrusted LoRa gateways to the network should still result in a secure network.\""}, {"lang": "es", "value": "** EN DISPUTA ** Un proceso de deduplicaci\u00f3n de tramas inexacto en ChirpStack Network Server versi\u00f3n 3.9.0, permite a un gateway malicioso llevar a cabo una Denegaci\u00f3n de Servicio de uplink por medio de atributos de frecuencia malformados en la funci\u00f3n CollectAndCallOnceCollect en el archivo internal/uplink/collect.go.&#xa0;NOTA: la posici\u00f3n del proveedor es que no existen \"garant\u00edas de que permitir puertas de enlace LoRa que no son de confianza a la red resultar\u00eda en una red segura.\""}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:chirpstack:network_server:3.9.0:*:*:*:*:*:*:*", "matchCriteriaId": "E8C89488-CFAD-4DC7-A3EB-4B68DA34717A"}]}]}], "references": [{"url": "https://github.com/brocaar/chirpstack-network-server/commit/874fc1a9b01045ebe8a340f0bb01ed19e8256e60", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/brocaar/chirpstack-network-server/commit/f996bb0c6c85281b5658f59ff09db1b4a73db453", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.cyberark.com/resources/threat-research-blog/lorawan-mqtt-what-to-know-when-securing-your-iot-network", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/brocaar/chirpstack-network-server/commit/874fc1a9b01045ebe8a340f0bb01ed19e8256e60"}}