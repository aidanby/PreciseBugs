{"buggy_code": ["/* mpi-pow.c  -  MPI functions\n *\tCopyright (C) 1994, 1996, 1998, 2000 Free Software Foundation, Inc.\n *\n * This file is part of GnuPG.\n *\n * GnuPG is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * GnuPG is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA\n *\n * Note: This code is heavily based on the GNU MP Library.\n *\t Actually it's the same code with only minor changes in the\n *\t way the data is stored; this is to support the abstraction\n *\t of an optional secure memory allocation which may be used\n *\t to avoid revealing of sensitive data due to paging etc.\n *\t The GNU MP Library itself is published under the LGPL;\n *\t however I decided to publish this code under the plain GPL.\n */\n\n#include <linux/string.h>\n#include \"mpi-internal.h\"\n#include \"longlong.h\"\n\n/****************\n * RES = BASE ^ EXP mod MOD\n */\nint mpi_powm(MPI res, MPI base, MPI exp, MPI mod)\n{\n\tmpi_ptr_t mp_marker = NULL, bp_marker = NULL, ep_marker = NULL;\n\tmpi_ptr_t xp_marker = NULL;\n\tmpi_ptr_t tspace = NULL;\n\tmpi_ptr_t rp, ep, mp, bp;\n\tmpi_size_t esize, msize, bsize, rsize;\n\tint esign, msign, bsign, rsign;\n\tmpi_size_t size;\n\tint mod_shift_cnt;\n\tint negative_result;\n\tint assign_rp = 0;\n\tmpi_size_t tsize = 0;\t/* to avoid compiler warning */\n\t/* fixme: we should check that the warning is void */\n\tint rc = -ENOMEM;\n\n\tesize = exp->nlimbs;\n\tmsize = mod->nlimbs;\n\tsize = 2 * msize;\n\tesign = exp->sign;\n\tmsign = mod->sign;\n\n\trp = res->d;\n\tep = exp->d;\n\n\tif (!msize)\n\t\treturn -EINVAL;\n\n\tif (!esize) {\n\t\t/* Exponent is zero, result is 1 mod MOD, i.e., 1 or 0\n\t\t * depending on if MOD equals 1.  */\n\t\trp[0] = 1;\n\t\tres->nlimbs = (msize == 1 && mod->d[0] == 1) ? 0 : 1;\n\t\tres->sign = 0;\n\t\tgoto leave;\n\t}\n\n\t/* Normalize MOD (i.e. make its most significant bit set) as required by\n\t * mpn_divrem.  This will make the intermediate values in the calculation\n\t * slightly larger, but the correct result is obtained after a final\n\t * reduction using the original MOD value.  */\n\tmp = mp_marker = mpi_alloc_limb_space(msize);\n\tif (!mp)\n\t\tgoto enomem;\n\tmod_shift_cnt = count_leading_zeros(mod->d[msize - 1]);\n\tif (mod_shift_cnt)\n\t\tmpihelp_lshift(mp, mod->d, msize, mod_shift_cnt);\n\telse\n\t\tMPN_COPY(mp, mod->d, msize);\n\n\tbsize = base->nlimbs;\n\tbsign = base->sign;\n\tif (bsize > msize) {\t/* The base is larger than the module. Reduce it. */\n\t\t/* Allocate (BSIZE + 1) with space for remainder and quotient.\n\t\t * (The quotient is (bsize - msize + 1) limbs.)  */\n\t\tbp = bp_marker = mpi_alloc_limb_space(bsize + 1);\n\t\tif (!bp)\n\t\t\tgoto enomem;\n\t\tMPN_COPY(bp, base->d, bsize);\n\t\t/* We don't care about the quotient, store it above the remainder,\n\t\t * at BP + MSIZE.  */\n\t\tmpihelp_divrem(bp + msize, 0, bp, bsize, mp, msize);\n\t\tbsize = msize;\n\t\t/* Canonicalize the base, since we are going to multiply with it\n\t\t * quite a few times.  */\n\t\tMPN_NORMALIZE(bp, bsize);\n\t} else\n\t\tbp = base->d;\n\n\tif (!bsize) {\n\t\tres->nlimbs = 0;\n\t\tres->sign = 0;\n\t\tgoto leave;\n\t}\n\n\tif (res->alloced < size) {\n\t\t/* We have to allocate more space for RES.  If any of the input\n\t\t * parameters are identical to RES, defer deallocation of the old\n\t\t * space.  */\n\t\tif (rp == ep || rp == mp || rp == bp) {\n\t\t\trp = mpi_alloc_limb_space(size);\n\t\t\tif (!rp)\n\t\t\t\tgoto enomem;\n\t\t\tassign_rp = 1;\n\t\t} else {\n\t\t\tif (mpi_resize(res, size) < 0)\n\t\t\t\tgoto enomem;\n\t\t\trp = res->d;\n\t\t}\n\t} else {\t\t/* Make BASE, EXP and MOD not overlap with RES.  */\n\t\tif (rp == bp) {\n\t\t\t/* RES and BASE are identical.  Allocate temp. space for BASE.  */\n\t\t\tBUG_ON(bp_marker);\n\t\t\tbp = bp_marker = mpi_alloc_limb_space(bsize);\n\t\t\tif (!bp)\n\t\t\t\tgoto enomem;\n\t\t\tMPN_COPY(bp, rp, bsize);\n\t\t}\n\t\tif (rp == ep) {\n\t\t\t/* RES and EXP are identical.  Allocate temp. space for EXP.  */\n\t\t\tep = ep_marker = mpi_alloc_limb_space(esize);\n\t\t\tif (!ep)\n\t\t\t\tgoto enomem;\n\t\t\tMPN_COPY(ep, rp, esize);\n\t\t}\n\t\tif (rp == mp) {\n\t\t\t/* RES and MOD are identical.  Allocate temporary space for MOD. */\n\t\t\tBUG_ON(mp_marker);\n\t\t\tmp = mp_marker = mpi_alloc_limb_space(msize);\n\t\t\tif (!mp)\n\t\t\t\tgoto enomem;\n\t\t\tMPN_COPY(mp, rp, msize);\n\t\t}\n\t}\n\n\tMPN_COPY(rp, bp, bsize);\n\trsize = bsize;\n\trsign = bsign;\n\n\t{\n\t\tmpi_size_t i;\n\t\tmpi_ptr_t xp;\n\t\tint c;\n\t\tmpi_limb_t e;\n\t\tmpi_limb_t carry_limb;\n\t\tstruct karatsuba_ctx karactx;\n\n\t\txp = xp_marker = mpi_alloc_limb_space(2 * (msize + 1));\n\t\tif (!xp)\n\t\t\tgoto enomem;\n\n\t\tmemset(&karactx, 0, sizeof karactx);\n\t\tnegative_result = (ep[0] & 1) && base->sign;\n\n\t\ti = esize - 1;\n\t\te = ep[i];\n\t\tc = count_leading_zeros(e);\n\t\te = (e << c) << 1;\t/* shift the exp bits to the left, lose msb */\n\t\tc = BITS_PER_MPI_LIMB - 1 - c;\n\n\t\t/* Main loop.\n\t\t *\n\t\t * Make the result be pointed to alternately by XP and RP.  This\n\t\t * helps us avoid block copying, which would otherwise be necessary\n\t\t * with the overlap restrictions of mpihelp_divmod. With 50% probability\n\t\t * the result after this loop will be in the area originally pointed\n\t\t * by RP (==RES->d), and with 50% probability in the area originally\n\t\t * pointed to by XP.\n\t\t */\n\n\t\tfor (;;) {\n\t\t\twhile (c) {\n\t\t\t\tmpi_ptr_t tp;\n\t\t\t\tmpi_size_t xsize;\n\n\t\t\t\t/*if (mpihelp_mul_n(xp, rp, rp, rsize) < 0) goto enomem */\n\t\t\t\tif (rsize < KARATSUBA_THRESHOLD)\n\t\t\t\t\tmpih_sqr_n_basecase(xp, rp, rsize);\n\t\t\t\telse {\n\t\t\t\t\tif (!tspace) {\n\t\t\t\t\t\ttsize = 2 * rsize;\n\t\t\t\t\t\ttspace =\n\t\t\t\t\t\t    mpi_alloc_limb_space(tsize);\n\t\t\t\t\t\tif (!tspace)\n\t\t\t\t\t\t\tgoto enomem;\n\t\t\t\t\t} else if (tsize < (2 * rsize)) {\n\t\t\t\t\t\tmpi_free_limb_space(tspace);\n\t\t\t\t\t\ttsize = 2 * rsize;\n\t\t\t\t\t\ttspace =\n\t\t\t\t\t\t    mpi_alloc_limb_space(tsize);\n\t\t\t\t\t\tif (!tspace)\n\t\t\t\t\t\t\tgoto enomem;\n\t\t\t\t\t}\n\t\t\t\t\tmpih_sqr_n(xp, rp, rsize, tspace);\n\t\t\t\t}\n\n\t\t\t\txsize = 2 * rsize;\n\t\t\t\tif (xsize > msize) {\n\t\t\t\t\tmpihelp_divrem(xp + msize, 0, xp, xsize,\n\t\t\t\t\t\t       mp, msize);\n\t\t\t\t\txsize = msize;\n\t\t\t\t}\n\n\t\t\t\ttp = rp;\n\t\t\t\trp = xp;\n\t\t\t\txp = tp;\n\t\t\t\trsize = xsize;\n\n\t\t\t\tif ((mpi_limb_signed_t) e < 0) {\n\t\t\t\t\t/*mpihelp_mul( xp, rp, rsize, bp, bsize ); */\n\t\t\t\t\tif (bsize < KARATSUBA_THRESHOLD) {\n\t\t\t\t\t\tmpi_limb_t tmp;\n\t\t\t\t\t\tif (mpihelp_mul\n\t\t\t\t\t\t    (xp, rp, rsize, bp, bsize,\n\t\t\t\t\t\t     &tmp) < 0)\n\t\t\t\t\t\t\tgoto enomem;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (mpihelp_mul_karatsuba_case\n\t\t\t\t\t\t    (xp, rp, rsize, bp, bsize,\n\t\t\t\t\t\t     &karactx) < 0)\n\t\t\t\t\t\t\tgoto enomem;\n\t\t\t\t\t}\n\n\t\t\t\t\txsize = rsize + bsize;\n\t\t\t\t\tif (xsize > msize) {\n\t\t\t\t\t\tmpihelp_divrem(xp + msize, 0,\n\t\t\t\t\t\t\t       xp, xsize, mp,\n\t\t\t\t\t\t\t       msize);\n\t\t\t\t\t\txsize = msize;\n\t\t\t\t\t}\n\n\t\t\t\t\ttp = rp;\n\t\t\t\t\trp = xp;\n\t\t\t\t\txp = tp;\n\t\t\t\t\trsize = xsize;\n\t\t\t\t}\n\t\t\t\te <<= 1;\n\t\t\t\tc--;\n\t\t\t}\n\n\t\t\ti--;\n\t\t\tif (i < 0)\n\t\t\t\tbreak;\n\t\t\te = ep[i];\n\t\t\tc = BITS_PER_MPI_LIMB;\n\t\t}\n\n\t\t/* We shifted MOD, the modulo reduction argument, left MOD_SHIFT_CNT\n\t\t * steps.  Adjust the result by reducing it with the original MOD.\n\t\t *\n\t\t * Also make sure the result is put in RES->d (where it already\n\t\t * might be, see above).\n\t\t */\n\t\tif (mod_shift_cnt) {\n\t\t\tcarry_limb =\n\t\t\t    mpihelp_lshift(res->d, rp, rsize, mod_shift_cnt);\n\t\t\trp = res->d;\n\t\t\tif (carry_limb) {\n\t\t\t\trp[rsize] = carry_limb;\n\t\t\t\trsize++;\n\t\t\t}\n\t\t} else {\n\t\t\tMPN_COPY(res->d, rp, rsize);\n\t\t\trp = res->d;\n\t\t}\n\n\t\tif (rsize >= msize) {\n\t\t\tmpihelp_divrem(rp + msize, 0, rp, rsize, mp, msize);\n\t\t\trsize = msize;\n\t\t}\n\n\t\t/* Remove any leading zero words from the result.  */\n\t\tif (mod_shift_cnt)\n\t\t\tmpihelp_rshift(rp, rp, rsize, mod_shift_cnt);\n\t\tMPN_NORMALIZE(rp, rsize);\n\n\t\tmpihelp_release_karatsuba_ctx(&karactx);\n\t}\n\n\tif (negative_result && rsize) {\n\t\tif (mod_shift_cnt)\n\t\t\tmpihelp_rshift(mp, mp, msize, mod_shift_cnt);\n\t\tmpihelp_sub(rp, mp, msize, rp, rsize);\n\t\trsize = msize;\n\t\trsign = msign;\n\t\tMPN_NORMALIZE(rp, rsize);\n\t}\n\tres->nlimbs = rsize;\n\tres->sign = rsign;\n\nleave:\n\trc = 0;\nenomem:\n\tif (assign_rp)\n\t\tmpi_assign_limb_space(res, rp, size);\n\tif (mp_marker)\n\t\tmpi_free_limb_space(mp_marker);\n\tif (bp_marker)\n\t\tmpi_free_limb_space(bp_marker);\n\tif (ep_marker)\n\t\tmpi_free_limb_space(ep_marker);\n\tif (xp_marker)\n\t\tmpi_free_limb_space(xp_marker);\n\tif (tspace)\n\t\tmpi_free_limb_space(tspace);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(mpi_powm);\n"], "fixing_code": ["/* mpi-pow.c  -  MPI functions\n *\tCopyright (C) 1994, 1996, 1998, 2000 Free Software Foundation, Inc.\n *\n * This file is part of GnuPG.\n *\n * GnuPG is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * GnuPG is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA\n *\n * Note: This code is heavily based on the GNU MP Library.\n *\t Actually it's the same code with only minor changes in the\n *\t way the data is stored; this is to support the abstraction\n *\t of an optional secure memory allocation which may be used\n *\t to avoid revealing of sensitive data due to paging etc.\n *\t The GNU MP Library itself is published under the LGPL;\n *\t however I decided to publish this code under the plain GPL.\n */\n\n#include <linux/string.h>\n#include \"mpi-internal.h\"\n#include \"longlong.h\"\n\n/****************\n * RES = BASE ^ EXP mod MOD\n */\nint mpi_powm(MPI res, MPI base, MPI exp, MPI mod)\n{\n\tmpi_ptr_t mp_marker = NULL, bp_marker = NULL, ep_marker = NULL;\n\tmpi_ptr_t xp_marker = NULL;\n\tmpi_ptr_t tspace = NULL;\n\tmpi_ptr_t rp, ep, mp, bp;\n\tmpi_size_t esize, msize, bsize, rsize;\n\tint esign, msign, bsign, rsign;\n\tmpi_size_t size;\n\tint mod_shift_cnt;\n\tint negative_result;\n\tint assign_rp = 0;\n\tmpi_size_t tsize = 0;\t/* to avoid compiler warning */\n\t/* fixme: we should check that the warning is void */\n\tint rc = -ENOMEM;\n\n\tesize = exp->nlimbs;\n\tmsize = mod->nlimbs;\n\tsize = 2 * msize;\n\tesign = exp->sign;\n\tmsign = mod->sign;\n\n\trp = res->d;\n\tep = exp->d;\n\n\tif (!msize)\n\t\treturn -EINVAL;\n\n\tif (!esize) {\n\t\t/* Exponent is zero, result is 1 mod MOD, i.e., 1 or 0\n\t\t * depending on if MOD equals 1.  */\n\t\tres->nlimbs = (msize == 1 && mod->d[0] == 1) ? 0 : 1;\n\t\tif (res->nlimbs) {\n\t\t\tif (mpi_resize(res, 1) < 0)\n\t\t\t\tgoto enomem;\n\t\t\trp = res->d;\n\t\t\trp[0] = 1;\n\t\t}\n\t\tres->sign = 0;\n\t\tgoto leave;\n\t}\n\n\t/* Normalize MOD (i.e. make its most significant bit set) as required by\n\t * mpn_divrem.  This will make the intermediate values in the calculation\n\t * slightly larger, but the correct result is obtained after a final\n\t * reduction using the original MOD value.  */\n\tmp = mp_marker = mpi_alloc_limb_space(msize);\n\tif (!mp)\n\t\tgoto enomem;\n\tmod_shift_cnt = count_leading_zeros(mod->d[msize - 1]);\n\tif (mod_shift_cnt)\n\t\tmpihelp_lshift(mp, mod->d, msize, mod_shift_cnt);\n\telse\n\t\tMPN_COPY(mp, mod->d, msize);\n\n\tbsize = base->nlimbs;\n\tbsign = base->sign;\n\tif (bsize > msize) {\t/* The base is larger than the module. Reduce it. */\n\t\t/* Allocate (BSIZE + 1) with space for remainder and quotient.\n\t\t * (The quotient is (bsize - msize + 1) limbs.)  */\n\t\tbp = bp_marker = mpi_alloc_limb_space(bsize + 1);\n\t\tif (!bp)\n\t\t\tgoto enomem;\n\t\tMPN_COPY(bp, base->d, bsize);\n\t\t/* We don't care about the quotient, store it above the remainder,\n\t\t * at BP + MSIZE.  */\n\t\tmpihelp_divrem(bp + msize, 0, bp, bsize, mp, msize);\n\t\tbsize = msize;\n\t\t/* Canonicalize the base, since we are going to multiply with it\n\t\t * quite a few times.  */\n\t\tMPN_NORMALIZE(bp, bsize);\n\t} else\n\t\tbp = base->d;\n\n\tif (!bsize) {\n\t\tres->nlimbs = 0;\n\t\tres->sign = 0;\n\t\tgoto leave;\n\t}\n\n\tif (res->alloced < size) {\n\t\t/* We have to allocate more space for RES.  If any of the input\n\t\t * parameters are identical to RES, defer deallocation of the old\n\t\t * space.  */\n\t\tif (rp == ep || rp == mp || rp == bp) {\n\t\t\trp = mpi_alloc_limb_space(size);\n\t\t\tif (!rp)\n\t\t\t\tgoto enomem;\n\t\t\tassign_rp = 1;\n\t\t} else {\n\t\t\tif (mpi_resize(res, size) < 0)\n\t\t\t\tgoto enomem;\n\t\t\trp = res->d;\n\t\t}\n\t} else {\t\t/* Make BASE, EXP and MOD not overlap with RES.  */\n\t\tif (rp == bp) {\n\t\t\t/* RES and BASE are identical.  Allocate temp. space for BASE.  */\n\t\t\tBUG_ON(bp_marker);\n\t\t\tbp = bp_marker = mpi_alloc_limb_space(bsize);\n\t\t\tif (!bp)\n\t\t\t\tgoto enomem;\n\t\t\tMPN_COPY(bp, rp, bsize);\n\t\t}\n\t\tif (rp == ep) {\n\t\t\t/* RES and EXP are identical.  Allocate temp. space for EXP.  */\n\t\t\tep = ep_marker = mpi_alloc_limb_space(esize);\n\t\t\tif (!ep)\n\t\t\t\tgoto enomem;\n\t\t\tMPN_COPY(ep, rp, esize);\n\t\t}\n\t\tif (rp == mp) {\n\t\t\t/* RES and MOD are identical.  Allocate temporary space for MOD. */\n\t\t\tBUG_ON(mp_marker);\n\t\t\tmp = mp_marker = mpi_alloc_limb_space(msize);\n\t\t\tif (!mp)\n\t\t\t\tgoto enomem;\n\t\t\tMPN_COPY(mp, rp, msize);\n\t\t}\n\t}\n\n\tMPN_COPY(rp, bp, bsize);\n\trsize = bsize;\n\trsign = bsign;\n\n\t{\n\t\tmpi_size_t i;\n\t\tmpi_ptr_t xp;\n\t\tint c;\n\t\tmpi_limb_t e;\n\t\tmpi_limb_t carry_limb;\n\t\tstruct karatsuba_ctx karactx;\n\n\t\txp = xp_marker = mpi_alloc_limb_space(2 * (msize + 1));\n\t\tif (!xp)\n\t\t\tgoto enomem;\n\n\t\tmemset(&karactx, 0, sizeof karactx);\n\t\tnegative_result = (ep[0] & 1) && base->sign;\n\n\t\ti = esize - 1;\n\t\te = ep[i];\n\t\tc = count_leading_zeros(e);\n\t\te = (e << c) << 1;\t/* shift the exp bits to the left, lose msb */\n\t\tc = BITS_PER_MPI_LIMB - 1 - c;\n\n\t\t/* Main loop.\n\t\t *\n\t\t * Make the result be pointed to alternately by XP and RP.  This\n\t\t * helps us avoid block copying, which would otherwise be necessary\n\t\t * with the overlap restrictions of mpihelp_divmod. With 50% probability\n\t\t * the result after this loop will be in the area originally pointed\n\t\t * by RP (==RES->d), and with 50% probability in the area originally\n\t\t * pointed to by XP.\n\t\t */\n\n\t\tfor (;;) {\n\t\t\twhile (c) {\n\t\t\t\tmpi_ptr_t tp;\n\t\t\t\tmpi_size_t xsize;\n\n\t\t\t\t/*if (mpihelp_mul_n(xp, rp, rp, rsize) < 0) goto enomem */\n\t\t\t\tif (rsize < KARATSUBA_THRESHOLD)\n\t\t\t\t\tmpih_sqr_n_basecase(xp, rp, rsize);\n\t\t\t\telse {\n\t\t\t\t\tif (!tspace) {\n\t\t\t\t\t\ttsize = 2 * rsize;\n\t\t\t\t\t\ttspace =\n\t\t\t\t\t\t    mpi_alloc_limb_space(tsize);\n\t\t\t\t\t\tif (!tspace)\n\t\t\t\t\t\t\tgoto enomem;\n\t\t\t\t\t} else if (tsize < (2 * rsize)) {\n\t\t\t\t\t\tmpi_free_limb_space(tspace);\n\t\t\t\t\t\ttsize = 2 * rsize;\n\t\t\t\t\t\ttspace =\n\t\t\t\t\t\t    mpi_alloc_limb_space(tsize);\n\t\t\t\t\t\tif (!tspace)\n\t\t\t\t\t\t\tgoto enomem;\n\t\t\t\t\t}\n\t\t\t\t\tmpih_sqr_n(xp, rp, rsize, tspace);\n\t\t\t\t}\n\n\t\t\t\txsize = 2 * rsize;\n\t\t\t\tif (xsize > msize) {\n\t\t\t\t\tmpihelp_divrem(xp + msize, 0, xp, xsize,\n\t\t\t\t\t\t       mp, msize);\n\t\t\t\t\txsize = msize;\n\t\t\t\t}\n\n\t\t\t\ttp = rp;\n\t\t\t\trp = xp;\n\t\t\t\txp = tp;\n\t\t\t\trsize = xsize;\n\n\t\t\t\tif ((mpi_limb_signed_t) e < 0) {\n\t\t\t\t\t/*mpihelp_mul( xp, rp, rsize, bp, bsize ); */\n\t\t\t\t\tif (bsize < KARATSUBA_THRESHOLD) {\n\t\t\t\t\t\tmpi_limb_t tmp;\n\t\t\t\t\t\tif (mpihelp_mul\n\t\t\t\t\t\t    (xp, rp, rsize, bp, bsize,\n\t\t\t\t\t\t     &tmp) < 0)\n\t\t\t\t\t\t\tgoto enomem;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (mpihelp_mul_karatsuba_case\n\t\t\t\t\t\t    (xp, rp, rsize, bp, bsize,\n\t\t\t\t\t\t     &karactx) < 0)\n\t\t\t\t\t\t\tgoto enomem;\n\t\t\t\t\t}\n\n\t\t\t\t\txsize = rsize + bsize;\n\t\t\t\t\tif (xsize > msize) {\n\t\t\t\t\t\tmpihelp_divrem(xp + msize, 0,\n\t\t\t\t\t\t\t       xp, xsize, mp,\n\t\t\t\t\t\t\t       msize);\n\t\t\t\t\t\txsize = msize;\n\t\t\t\t\t}\n\n\t\t\t\t\ttp = rp;\n\t\t\t\t\trp = xp;\n\t\t\t\t\txp = tp;\n\t\t\t\t\trsize = xsize;\n\t\t\t\t}\n\t\t\t\te <<= 1;\n\t\t\t\tc--;\n\t\t\t}\n\n\t\t\ti--;\n\t\t\tif (i < 0)\n\t\t\t\tbreak;\n\t\t\te = ep[i];\n\t\t\tc = BITS_PER_MPI_LIMB;\n\t\t}\n\n\t\t/* We shifted MOD, the modulo reduction argument, left MOD_SHIFT_CNT\n\t\t * steps.  Adjust the result by reducing it with the original MOD.\n\t\t *\n\t\t * Also make sure the result is put in RES->d (where it already\n\t\t * might be, see above).\n\t\t */\n\t\tif (mod_shift_cnt) {\n\t\t\tcarry_limb =\n\t\t\t    mpihelp_lshift(res->d, rp, rsize, mod_shift_cnt);\n\t\t\trp = res->d;\n\t\t\tif (carry_limb) {\n\t\t\t\trp[rsize] = carry_limb;\n\t\t\t\trsize++;\n\t\t\t}\n\t\t} else {\n\t\t\tMPN_COPY(res->d, rp, rsize);\n\t\t\trp = res->d;\n\t\t}\n\n\t\tif (rsize >= msize) {\n\t\t\tmpihelp_divrem(rp + msize, 0, rp, rsize, mp, msize);\n\t\t\trsize = msize;\n\t\t}\n\n\t\t/* Remove any leading zero words from the result.  */\n\t\tif (mod_shift_cnt)\n\t\t\tmpihelp_rshift(rp, rp, rsize, mod_shift_cnt);\n\t\tMPN_NORMALIZE(rp, rsize);\n\n\t\tmpihelp_release_karatsuba_ctx(&karactx);\n\t}\n\n\tif (negative_result && rsize) {\n\t\tif (mod_shift_cnt)\n\t\t\tmpihelp_rshift(mp, mp, msize, mod_shift_cnt);\n\t\tmpihelp_sub(rp, mp, msize, rp, rsize);\n\t\trsize = msize;\n\t\trsign = msign;\n\t\tMPN_NORMALIZE(rp, rsize);\n\t}\n\tres->nlimbs = rsize;\n\tres->sign = rsign;\n\nleave:\n\trc = 0;\nenomem:\n\tif (assign_rp)\n\t\tmpi_assign_limb_space(res, rp, size);\n\tif (mp_marker)\n\t\tmpi_free_limb_space(mp_marker);\n\tif (bp_marker)\n\t\tmpi_free_limb_space(bp_marker);\n\tif (ep_marker)\n\t\tmpi_free_limb_space(ep_marker);\n\tif (xp_marker)\n\t\tmpi_free_limb_space(xp_marker);\n\tif (tspace)\n\t\tmpi_free_limb_space(tspace);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(mpi_powm);\n"], "filenames": ["lib/mpi/mpi-pow.c"], "buggy_code_start_loc": [67], "buggy_code_end_loc": [68], "fixing_code_start_loc": [66], "fixing_code_end_loc": [74], "type": "CWE-20", "message": "The mpi_powm function in lib/mpi/mpi-pow.c in the Linux kernel through 4.8.11 does not ensure that memory is allocated for limb data, which allows local users to cause a denial of service (stack memory corruption and panic) via an add_key system call for an RSA key with a zero exponent.", "other": {"cve": {"id": "CVE-2016-8650", "sourceIdentifier": "secalert@redhat.com", "published": "2016-11-28T03:59:09.843", "lastModified": "2023-02-12T23:26:33.667", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The mpi_powm function in lib/mpi/mpi-pow.c in the Linux kernel through 4.8.11 does not ensure that memory is allocated for limb data, which allows local users to cause a denial of service (stack memory corruption and panic) via an add_key system call for an RSA key with a zero exponent."}, {"lang": "es", "value": "La funci\u00f3n mpi_powm en lib/mpi/mpi-pow.c en el kernel Linux hasta la versi\u00f3n 4.8.11 no se asegura que la memoria est\u00e9 alojada para datos limb, lo que permite a usuarios locales provocar una denegaci\u00f3n de servicio (corrupci\u00f3n de memoria de pila y p\u00e1nico) a trav\u00e9s de una llamada de sistema add_key para una llave RSA con un componente cero."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}, {"lang": "en", "value": "CWE-399"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.8.11", "matchCriteriaId": "00B2C5A0-53C6-4A5A-A79A-9A213FA01EE5"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=f5527fffff3f002b0a6b376163613b82f69de073", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Vendor Advisory"]}, {"url": "http://seclists.org/fulldisclosure/2016/Nov/76", "source": "secalert@redhat.com", "tags": ["Mailing List"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/11/24/8", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/94532", "source": "secalert@redhat.com"}, {"url": "http://www.securitytracker.com/id/1037968", "source": "secalert@redhat.com"}, {"url": "https://access.redhat.com/errata/RHSA-2017:0931", "source": "secalert@redhat.com"}, {"url": "https://access.redhat.com/errata/RHSA-2017:0932", "source": "secalert@redhat.com"}, {"url": "https://access.redhat.com/errata/RHSA-2017:0933", "source": "secalert@redhat.com"}, {"url": "https://access.redhat.com/errata/RHSA-2018:1854", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1395187", "source": "secalert@redhat.com", "tags": ["Issue Tracking"]}, {"url": "https://github.com/torvalds/linux/commit/f5527fffff3f002b0a6b376163613b82f69de073", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://source.android.com/security/bulletin/2017-03-01.html", "source": "secalert@redhat.com"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/f5527fffff3f002b0a6b376163613b82f69de073"}}