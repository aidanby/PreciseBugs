{"buggy_code": ["/*-\n * SPDX-License-Identifier: BSD-3-Clause\n *\n * Copyright (c) 2001-2008, by Cisco Systems, Inc. All rights reserved.\n * Copyright (c) 2008-2012, by Randall Stewart. All rights reserved.\n * Copyright (c) 2008-2012, by Michael Tuexen. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * a) Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *\n * b) Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the distribution.\n *\n * c) Neither the name of Cisco Systems, Inc. nor the names of its\n *    contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifdef __FreeBSD__\n#include <sys/cdefs.h>\n__FBSDID(\"$FreeBSD: head/sys/netinet/sctp_auth.c 352438 2019-09-17 09:46:42Z tuexen $\");\n#endif\n\n#include <netinet/sctp_os.h>\n#include <netinet/sctp.h>\n#include <netinet/sctp_header.h>\n#include <netinet/sctp_pcb.h>\n#include <netinet/sctp_var.h>\n#include <netinet/sctp_sysctl.h>\n#include <netinet/sctputil.h>\n#include <netinet/sctp_indata.h>\n#include <netinet/sctp_output.h>\n#include <netinet/sctp_auth.h>\n\n#ifdef SCTP_DEBUG\n#define SCTP_AUTH_DEBUG\t\t(SCTP_BASE_SYSCTL(sctp_debug_on) & SCTP_DEBUG_AUTH1)\n#define SCTP_AUTH_DEBUG2\t(SCTP_BASE_SYSCTL(sctp_debug_on) & SCTP_DEBUG_AUTH2)\n#endif /* SCTP_DEBUG */\n\n\nvoid\nsctp_clear_chunklist(sctp_auth_chklist_t *chklist)\n{\n\tmemset(chklist, 0, sizeof(*chklist));\n\t/* chklist->num_chunks = 0; */\n}\n\nsctp_auth_chklist_t *\nsctp_alloc_chunklist(void)\n{\n\tsctp_auth_chklist_t *chklist;\n\n\tSCTP_MALLOC(chklist, sctp_auth_chklist_t *, sizeof(*chklist),\n\t\t    SCTP_M_AUTH_CL);\n\tif (chklist == NULL) {\n\t\tSCTPDBG(SCTP_DEBUG_AUTH1, \"sctp_alloc_chunklist: failed to get memory!\\n\");\n\t} else {\n\t\tsctp_clear_chunklist(chklist);\n\t}\n\treturn (chklist);\n}\n\nvoid\nsctp_free_chunklist(sctp_auth_chklist_t *list)\n{\n\tif (list != NULL)\n\t\tSCTP_FREE(list, SCTP_M_AUTH_CL);\n}\n\nsctp_auth_chklist_t *\nsctp_copy_chunklist(sctp_auth_chklist_t *list)\n{\n\tsctp_auth_chklist_t *new_list;\n\n\tif (list == NULL)\n\t\treturn (NULL);\n\n\t/* get a new list */\n\tnew_list = sctp_alloc_chunklist();\n\tif (new_list == NULL)\n\t\treturn (NULL);\n\t/* copy it */\n\tmemcpy(new_list, list, sizeof(*new_list));\n\n\treturn (new_list);\n}\n\n\n/*\n * add a chunk to the required chunks list\n */\nint\nsctp_auth_add_chunk(uint8_t chunk, sctp_auth_chklist_t *list)\n{\n\tif (list == NULL)\n\t\treturn (-1);\n\n\t/* is chunk restricted? */\n\tif ((chunk == SCTP_INITIATION) ||\n\t    (chunk == SCTP_INITIATION_ACK) ||\n\t    (chunk == SCTP_SHUTDOWN_COMPLETE) ||\n\t    (chunk == SCTP_AUTHENTICATION)) {\n\t\treturn (-1);\n\t}\n\tif (list->chunks[chunk] == 0) {\n\t\tlist->chunks[chunk] = 1;\n\t\tlist->num_chunks++;\n\t\tSCTPDBG(SCTP_DEBUG_AUTH1,\n\t\t\t\"SCTP: added chunk %u (0x%02x) to Auth list\\n\",\n\t\t\tchunk, chunk);\n\t}\n\treturn (0);\n}\n\n/*\n * delete a chunk from the required chunks list\n */\nint\nsctp_auth_delete_chunk(uint8_t chunk, sctp_auth_chklist_t *list)\n{\n\tif (list == NULL)\n\t\treturn (-1);\n\n\tif (list->chunks[chunk] == 1) {\n\t\tlist->chunks[chunk] = 0;\n\t\tlist->num_chunks--;\n\t\tSCTPDBG(SCTP_DEBUG_AUTH1,\n\t\t\t\"SCTP: deleted chunk %u (0x%02x) from Auth list\\n\",\n\t\t\tchunk, chunk);\n\t}\n\treturn (0);\n}\n\nsize_t\nsctp_auth_get_chklist_size(const sctp_auth_chklist_t *list)\n{\n\tif (list == NULL)\n\t\treturn (0);\n\telse\n\t\treturn (list->num_chunks);\n}\n\n/*\n * return the current number and list of required chunks caller must\n * guarantee ptr has space for up to 256 bytes\n */\nint\nsctp_serialize_auth_chunks(const sctp_auth_chklist_t *list, uint8_t *ptr)\n{\n\tint i, count = 0;\n\n\tif (list == NULL)\n\t\treturn (0);\n\n\tfor (i = 0; i < 256; i++) {\n\t\tif (list->chunks[i] != 0) {\n\t\t\t*ptr++ = i;\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn (count);\n}\n\nint\nsctp_pack_auth_chunks(const sctp_auth_chklist_t *list, uint8_t *ptr)\n{\n\tint i, size = 0;\n\n\tif (list == NULL)\n\t\treturn (0);\n\n\tif (list->num_chunks <= 32) {\n\t\t/* just list them, one byte each */\n\t\tfor (i = 0; i < 256; i++) {\n\t\t\tif (list->chunks[i] != 0) {\n\t\t\t\t*ptr++ = i;\n\t\t\t\tsize++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tint index, offset;\n\n\t\t/* pack into a 32 byte bitfield */\n\t\tfor (i = 0; i < 256; i++) {\n\t\t\tif (list->chunks[i] != 0) {\n\t\t\t\tindex = i / 8;\n\t\t\t\toffset = i % 8;\n\t\t\t\tptr[index] |= (1 << offset);\n\t\t\t}\n\t\t}\n\t\tsize = 32;\n\t}\n\treturn (size);\n}\n\nint\nsctp_unpack_auth_chunks(const uint8_t *ptr, uint8_t num_chunks,\n    sctp_auth_chklist_t *list)\n{\n\tint i;\n\tint size;\n\n\tif (list == NULL)\n\t\treturn (0);\n\n\tif (num_chunks <= 32) {\n\t\t/* just pull them, one byte each */\n\t\tfor (i = 0; i < num_chunks; i++) {\n\t\t\t(void)sctp_auth_add_chunk(*ptr++, list);\n\t\t}\n\t\tsize = num_chunks;\n\t} else {\n\t\tint index, offset;\n\n\t\t/* unpack from a 32 byte bitfield */\n\t\tfor (index = 0; index < 32; index++) {\n\t\t\tfor (offset = 0; offset < 8; offset++) {\n\t\t\t\tif (ptr[index] & (1 << offset)) {\n\t\t\t\t\t(void)sctp_auth_add_chunk((index * 8) + offset, list);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsize = 32;\n\t}\n\treturn (size);\n}\n\n\n/*\n * allocate structure space for a key of length keylen\n */\nsctp_key_t *\nsctp_alloc_key(uint32_t keylen)\n{\n\tsctp_key_t *new_key;\n\n\tSCTP_MALLOC(new_key, sctp_key_t *, sizeof(*new_key) + keylen,\n\t\t    SCTP_M_AUTH_KY);\n\tif (new_key == NULL) {\n\t\t/* out of memory */\n\t\treturn (NULL);\n\t}\n\tnew_key->keylen = keylen;\n\treturn (new_key);\n}\n\nvoid\nsctp_free_key(sctp_key_t *key)\n{\n\tif (key != NULL)\n\t\tSCTP_FREE(key,SCTP_M_AUTH_KY);\n}\n\nvoid\nsctp_print_key(sctp_key_t *key, const char *str)\n{\n\tuint32_t i;\n\n\tif (key == NULL) {\n\t\tSCTP_PRINTF(\"%s: [Null key]\\n\", str);\n\t\treturn;\n\t}\n\tSCTP_PRINTF(\"%s: len %u, \", str, key->keylen);\n\tif (key->keylen) {\n\t\tfor (i = 0; i < key->keylen; i++)\n\t\t\tSCTP_PRINTF(\"%02x\", key->key[i]);\n\t\tSCTP_PRINTF(\"\\n\");\n\t} else {\n\t\tSCTP_PRINTF(\"[Null key]\\n\");\n\t}\n}\n\nvoid\nsctp_show_key(sctp_key_t *key, const char *str)\n{\n\tuint32_t i;\n\n\tif (key == NULL) {\n\t\tSCTP_PRINTF(\"%s: [Null key]\\n\", str);\n\t\treturn;\n\t}\n\tSCTP_PRINTF(\"%s: len %u, \", str, key->keylen);\n\tif (key->keylen) {\n\t\tfor (i = 0; i < key->keylen; i++)\n\t\t\tSCTP_PRINTF(\"%02x\", key->key[i]);\n\t\tSCTP_PRINTF(\"\\n\");\n\t} else {\n\t\tSCTP_PRINTF(\"[Null key]\\n\");\n\t}\n}\n\nstatic uint32_t\nsctp_get_keylen(sctp_key_t *key)\n{\n\tif (key != NULL)\n\t\treturn (key->keylen);\n\telse\n\t\treturn (0);\n}\n\n/*\n * generate a new random key of length 'keylen'\n */\nsctp_key_t *\nsctp_generate_random_key(uint32_t keylen)\n{\n\tsctp_key_t *new_key;\n\n\tnew_key = sctp_alloc_key(keylen);\n\tif (new_key == NULL) {\n\t\t/* out of memory */\n\t\treturn (NULL);\n\t}\n\tSCTP_READ_RANDOM(new_key->key, keylen);\n\tnew_key->keylen = keylen;\n\treturn (new_key);\n}\n\nsctp_key_t *\nsctp_set_key(uint8_t *key, uint32_t keylen)\n{\n\tsctp_key_t *new_key;\n\n\tnew_key = sctp_alloc_key(keylen);\n\tif (new_key == NULL) {\n\t\t/* out of memory */\n\t\treturn (NULL);\n\t}\n\tmemcpy(new_key->key, key, keylen);\n\treturn (new_key);\n}\n\n/*-\n * given two keys of variable size, compute which key is \"larger/smaller\"\n * returns:  1 if key1 > key2\n *          -1 if key1 < key2\n *           0 if key1 = key2\n */\nstatic int\nsctp_compare_key(sctp_key_t *key1, sctp_key_t *key2)\n{\n\tuint32_t maxlen;\n\tuint32_t i;\n\tuint32_t key1len, key2len;\n\tuint8_t *key_1, *key_2;\n\tuint8_t val1, val2;\n\n\t/* sanity/length check */\n\tkey1len = sctp_get_keylen(key1);\n\tkey2len = sctp_get_keylen(key2);\n\tif ((key1len == 0) && (key2len == 0))\n\t\treturn (0);\n\telse if (key1len == 0)\n\t\treturn (-1);\n\telse if (key2len == 0)\n\t\treturn (1);\n\n\tif (key1len < key2len) {\n\t\tmaxlen = key2len;\n\t} else {\n\t\tmaxlen = key1len;\n\t}\n\tkey_1 = key1->key;\n\tkey_2 = key2->key;\n\t/* check for numeric equality */\n\tfor (i = 0; i < maxlen; i++) {\n\t\t/* left-pad with zeros */\n\t\tval1 = (i < (maxlen - key1len)) ? 0 : *(key_1++);\n\t\tval2 = (i < (maxlen - key2len)) ? 0 : *(key_2++);\n\t\tif (val1 > val2) {\n\t\t\treturn (1);\n\t\t} else if (val1 < val2) {\n\t\t\treturn (-1);\n\t\t}\n\t}\n\t/* keys are equal value, so check lengths */\n\tif (key1len == key2len)\n\t\treturn (0);\n\telse if (key1len < key2len)\n\t\treturn (-1);\n\telse\n\t\treturn (1);\n}\n\n/*\n * generate the concatenated keying material based on the two keys and the\n * shared key (if available). draft-ietf-tsvwg-auth specifies the specific\n * order for concatenation\n */\nsctp_key_t *\nsctp_compute_hashkey(sctp_key_t *key1, sctp_key_t *key2, sctp_key_t *shared)\n{\n\tuint32_t keylen;\n\tsctp_key_t *new_key;\n\tuint8_t *key_ptr;\n\n\tkeylen = sctp_get_keylen(key1) + sctp_get_keylen(key2) +\n\t    sctp_get_keylen(shared);\n\n\tif (keylen > 0) {\n\t\t/* get space for the new key */\n\t\tnew_key = sctp_alloc_key(keylen);\n\t\tif (new_key == NULL) {\n\t\t\t/* out of memory */\n\t\t\treturn (NULL);\n\t\t}\n\t\tnew_key->keylen = keylen;\n\t\tkey_ptr = new_key->key;\n\t} else {\n\t\t/* all keys empty/null?! */\n\t\treturn (NULL);\n\t}\n\n\t/* concatenate the keys */\n\tif (sctp_compare_key(key1, key2) <= 0) {\n\t\t/* key is shared + key1 + key2 */\n\t\tif (sctp_get_keylen(shared)) {\n\t\t\tmemcpy(key_ptr, shared->key, shared->keylen);\n\t\t\tkey_ptr += shared->keylen;\n\t\t}\n\t\tif (sctp_get_keylen(key1)) {\n\t\t\tmemcpy(key_ptr, key1->key, key1->keylen);\n\t\t\tkey_ptr += key1->keylen;\n\t\t}\n\t\tif (sctp_get_keylen(key2)) {\n\t\t\tmemcpy(key_ptr, key2->key, key2->keylen);\n\t\t}\n\t} else {\n\t\t/* key is shared + key2 + key1 */\n\t\tif (sctp_get_keylen(shared)) {\n\t\t\tmemcpy(key_ptr, shared->key, shared->keylen);\n\t\t\tkey_ptr += shared->keylen;\n\t\t}\n\t\tif (sctp_get_keylen(key2)) {\n\t\t\tmemcpy(key_ptr, key2->key, key2->keylen);\n\t\t\tkey_ptr += key2->keylen;\n\t\t}\n\t\tif (sctp_get_keylen(key1)) {\n\t\t\tmemcpy(key_ptr, key1->key, key1->keylen);\n\t\t}\n\t}\n\treturn (new_key);\n}\n\n\nsctp_sharedkey_t *\nsctp_alloc_sharedkey(void)\n{\n\tsctp_sharedkey_t *new_key;\n\n\tSCTP_MALLOC(new_key, sctp_sharedkey_t *, sizeof(*new_key),\n\t\t    SCTP_M_AUTH_KY);\n\tif (new_key == NULL) {\n\t\t/* out of memory */\n\t\treturn (NULL);\n\t}\n\tnew_key->keyid = 0;\n\tnew_key->key = NULL;\n\tnew_key->refcount = 1;\n\tnew_key->deactivated = 0;\n\treturn (new_key);\n}\n\nvoid\nsctp_free_sharedkey(sctp_sharedkey_t *skey)\n{\n\tif (skey == NULL)\n\t\treturn;\n\n\tif (SCTP_DECREMENT_AND_CHECK_REFCOUNT(&skey->refcount)) {\n\t\tif (skey->key != NULL)\n\t\t\tsctp_free_key(skey->key);\n\t\tSCTP_FREE(skey, SCTP_M_AUTH_KY);\n\t}\n}\n\nsctp_sharedkey_t *\nsctp_find_sharedkey(struct sctp_keyhead *shared_keys, uint16_t key_id)\n{\n\tsctp_sharedkey_t *skey;\n\n\tLIST_FOREACH(skey, shared_keys, next) {\n\t\tif (skey->keyid == key_id)\n\t\t\treturn (skey);\n\t}\n\treturn (NULL);\n}\n\nint\nsctp_insert_sharedkey(struct sctp_keyhead *shared_keys,\n\t\t      sctp_sharedkey_t *new_skey)\n{\n\tsctp_sharedkey_t *skey;\n\n\tif ((shared_keys == NULL) || (new_skey == NULL))\n\t\treturn (EINVAL);\n\n\t/* insert into an empty list? */\n\tif (LIST_EMPTY(shared_keys)) {\n\t\tLIST_INSERT_HEAD(shared_keys, new_skey, next);\n\t\treturn (0);\n\t}\n\t/* insert into the existing list, ordered by key id */\n\tLIST_FOREACH(skey, shared_keys, next) {\n\t\tif (new_skey->keyid < skey->keyid) {\n\t\t\t/* insert it before here */\n\t\t\tLIST_INSERT_BEFORE(skey, new_skey, next);\n\t\t\treturn (0);\n\t\t} else if (new_skey->keyid == skey->keyid) {\n\t\t\t/* replace the existing key */\n\t\t\t/* verify this key *can* be replaced */\n\t\t\tif ((skey->deactivated) || (skey->refcount > 1)) {\n\t\t\t\tSCTPDBG(SCTP_DEBUG_AUTH1,\n\t\t\t\t\t\"can't replace shared key id %u\\n\",\n\t\t\t\t\tnew_skey->keyid);\n\t\t\t\treturn (EBUSY);\n\t\t\t}\n\t\t\tSCTPDBG(SCTP_DEBUG_AUTH1,\n\t\t\t\t\"replacing shared key id %u\\n\",\n\t\t\t\tnew_skey->keyid);\n\t\t\tLIST_INSERT_BEFORE(skey, new_skey, next);\n\t\t\tLIST_REMOVE(skey, next);\n\t\t\tsctp_free_sharedkey(skey);\n\t\t\treturn (0);\n\t\t}\n\t\tif (LIST_NEXT(skey, next) == NULL) {\n\t\t\t/* belongs at the end of the list */\n\t\t\tLIST_INSERT_AFTER(skey, new_skey, next);\n\t\t\treturn (0);\n\t\t}\n\t}\n\t/* shouldn't reach here */\n\treturn (EINVAL);\n}\n\nvoid\nsctp_auth_key_acquire(struct sctp_tcb *stcb, uint16_t key_id)\n{\n\tsctp_sharedkey_t *skey;\n\n\t/* find the shared key */\n\tskey = sctp_find_sharedkey(&stcb->asoc.shared_keys, key_id);\n\n\t/* bump the ref count */\n\tif (skey) {\n\t\tatomic_add_int(&skey->refcount, 1);\n\t\tSCTPDBG(SCTP_DEBUG_AUTH2,\n\t\t\t\"%s: stcb %p key %u refcount acquire to %d\\n\",\n\t\t\t__func__, (void *)stcb, key_id, skey->refcount);\n\t}\n}\n\nvoid\nsctp_auth_key_release(struct sctp_tcb *stcb, uint16_t key_id, int so_locked\n#if !defined(__APPLE__) && !defined(SCTP_SO_LOCK_TESTING)\n\tSCTP_UNUSED\n#endif\n)\n{\n\tsctp_sharedkey_t *skey;\n\n\t/* find the shared key */\n\tskey = sctp_find_sharedkey(&stcb->asoc.shared_keys, key_id);\n\n\t/* decrement the ref count */\n\tif (skey) {\n\t\tSCTPDBG(SCTP_DEBUG_AUTH2,\n\t\t\t\"%s: stcb %p key %u refcount release to %d\\n\",\n\t\t\t__func__, (void *)stcb, key_id, skey->refcount);\n\n\t\t/* see if a notification should be generated */\n\t\tif ((skey->refcount <= 2) && (skey->deactivated)) {\n\t\t\t/* notify ULP that key is no longer used */\n\t\t\tsctp_ulp_notify(SCTP_NOTIFY_AUTH_FREE_KEY, stcb,\n\t\t\t\t\tkey_id, 0, so_locked);\n\t\t\tSCTPDBG(SCTP_DEBUG_AUTH2,\n\t\t\t\t\"%s: stcb %p key %u no longer used, %d\\n\",\n\t\t\t\t__func__, (void *)stcb, key_id, skey->refcount);\n\t\t}\n\t\tsctp_free_sharedkey(skey);\n\t}\n}\n\nstatic sctp_sharedkey_t *\nsctp_copy_sharedkey(const sctp_sharedkey_t *skey)\n{\n\tsctp_sharedkey_t *new_skey;\n\n\tif (skey == NULL)\n\t\treturn (NULL);\n\tnew_skey = sctp_alloc_sharedkey();\n\tif (new_skey == NULL)\n\t\treturn (NULL);\n\tif (skey->key != NULL)\n\t\tnew_skey->key = sctp_set_key(skey->key->key, skey->key->keylen);\n\telse\n\t\tnew_skey->key = NULL;\n\tnew_skey->keyid = skey->keyid;\n\treturn (new_skey);\n}\n\nint\nsctp_copy_skeylist(const struct sctp_keyhead *src, struct sctp_keyhead *dest)\n{\n\tsctp_sharedkey_t *skey, *new_skey;\n\tint count = 0;\n\n\tif ((src == NULL) || (dest == NULL))\n\t\treturn (0);\n\tLIST_FOREACH(skey, src, next) {\n\t\tnew_skey = sctp_copy_sharedkey(skey);\n\t\tif (new_skey != NULL) {\n\t\t\tif (sctp_insert_sharedkey(dest, new_skey)) {\n\t\t\t\tsctp_free_sharedkey(new_skey);\n\t\t\t} else {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn (count);\n}\n\n\nsctp_hmaclist_t *\nsctp_alloc_hmaclist(uint16_t num_hmacs)\n{\n\tsctp_hmaclist_t *new_list;\n\tint alloc_size;\n\n\talloc_size = sizeof(*new_list) + num_hmacs * sizeof(new_list->hmac[0]);\n\tSCTP_MALLOC(new_list, sctp_hmaclist_t *, alloc_size,\n\t\t    SCTP_M_AUTH_HL);\n\tif (new_list == NULL) {\n\t\t/* out of memory */\n\t\treturn (NULL);\n\t}\n\tnew_list->max_algo = num_hmacs;\n\tnew_list->num_algo = 0;\n\treturn (new_list);\n}\n\nvoid\nsctp_free_hmaclist(sctp_hmaclist_t *list)\n{\n\tif (list != NULL) {\n\t\tSCTP_FREE(list,SCTP_M_AUTH_HL);\n\t\tlist = NULL;\n\t}\n}\n\nint\nsctp_auth_add_hmacid(sctp_hmaclist_t *list, uint16_t hmac_id)\n{\n\tint i;\n\tif (list == NULL)\n\t\treturn (-1);\n\tif (list->num_algo == list->max_algo) {\n\t\tSCTPDBG(SCTP_DEBUG_AUTH1,\n\t\t\t\"SCTP: HMAC id list full, ignoring add %u\\n\", hmac_id);\n\t\treturn (-1);\n\t}\n#if defined(SCTP_SUPPORT_HMAC_SHA256)\n\tif ((hmac_id != SCTP_AUTH_HMAC_ID_SHA1) &&\n\t    (hmac_id != SCTP_AUTH_HMAC_ID_SHA256)) {\n#else\n\tif (hmac_id != SCTP_AUTH_HMAC_ID_SHA1) {\n#endif\n\t\treturn (-1);\n\t}\n\t/* Now is it already in the list */\n\tfor (i = 0; i < list->num_algo; i++) {\n\t\tif (list->hmac[i] == hmac_id) {\n\t\t\t/* already in list */\n\t\t\treturn (-1);\n\t\t}\n\t}\n\tSCTPDBG(SCTP_DEBUG_AUTH1, \"SCTP: add HMAC id %u to list\\n\", hmac_id);\n\tlist->hmac[list->num_algo++] = hmac_id;\n\treturn (0);\n}\n\nsctp_hmaclist_t *\nsctp_copy_hmaclist(sctp_hmaclist_t *list)\n{\n\tsctp_hmaclist_t *new_list;\n\tint i;\n\n\tif (list == NULL)\n\t\treturn (NULL);\n\t/* get a new list */\n\tnew_list = sctp_alloc_hmaclist(list->max_algo);\n\tif (new_list == NULL)\n\t\treturn (NULL);\n\t/* copy it */\n\tnew_list->max_algo = list->max_algo;\n\tnew_list->num_algo = list->num_algo;\n\tfor (i = 0; i < list->num_algo; i++)\n\t\tnew_list->hmac[i] = list->hmac[i];\n\treturn (new_list);\n}\n\nsctp_hmaclist_t *\nsctp_default_supported_hmaclist(void)\n{\n\tsctp_hmaclist_t *new_list;\n\n#if defined(SCTP_SUPPORT_HMAC_SHA256)\n\tnew_list = sctp_alloc_hmaclist(2);\n#else\n\tnew_list = sctp_alloc_hmaclist(1);\n#endif\n\tif (new_list == NULL)\n\t\treturn (NULL);\n#if defined(SCTP_SUPPORT_HMAC_SHA256)\n\t/* We prefer SHA256, so list it first */\n\t(void)sctp_auth_add_hmacid(new_list, SCTP_AUTH_HMAC_ID_SHA256);\n#endif\n\t(void)sctp_auth_add_hmacid(new_list, SCTP_AUTH_HMAC_ID_SHA1);\n\treturn (new_list);\n}\n\n/*-\n * HMAC algos are listed in priority/preference order\n * find the best HMAC id to use for the peer based on local support\n */\nuint16_t\nsctp_negotiate_hmacid(sctp_hmaclist_t *peer, sctp_hmaclist_t *local)\n{\n\tint i, j;\n\n\tif ((local == NULL) || (peer == NULL))\n\t\treturn (SCTP_AUTH_HMAC_ID_RSVD);\n\n\tfor (i = 0; i < peer->num_algo; i++) {\n\t\tfor (j = 0; j < local->num_algo; j++) {\n\t\t\tif (peer->hmac[i] == local->hmac[j]) {\n\t\t\t\t/* found the \"best\" one */\n\t\t\t\tSCTPDBG(SCTP_DEBUG_AUTH1,\n\t\t\t\t\t\"SCTP: negotiated peer HMAC id %u\\n\",\n\t\t\t\t\tpeer->hmac[i]);\n\t\t\t\treturn (peer->hmac[i]);\n\t\t\t}\n\t\t}\n\t}\n\t/* didn't find one! */\n\treturn (SCTP_AUTH_HMAC_ID_RSVD);\n}\n\n/*-\n * serialize the HMAC algo list and return space used\n * caller must guarantee ptr has appropriate space\n */\nint\nsctp_serialize_hmaclist(sctp_hmaclist_t *list, uint8_t *ptr)\n{\n\tint i;\n\tuint16_t hmac_id;\n\n\tif (list == NULL)\n\t\treturn (0);\n\n\tfor (i = 0; i < list->num_algo; i++) {\n\t\thmac_id = htons(list->hmac[i]);\n\t\tmemcpy(ptr, &hmac_id, sizeof(hmac_id));\n\t\tptr += sizeof(hmac_id);\n\t}\n\treturn (list->num_algo * sizeof(hmac_id));\n}\n\nint\nsctp_verify_hmac_param (struct sctp_auth_hmac_algo *hmacs, uint32_t num_hmacs)\n{\n\tuint32_t i;\n\n\tfor (i = 0; i < num_hmacs; i++) {\n\t\tif (ntohs(hmacs->hmac_ids[i]) == SCTP_AUTH_HMAC_ID_SHA1) {\n\t\t\treturn (0);\n\t\t}\n\t}\n\treturn (-1);\n}\n\nsctp_authinfo_t *\nsctp_alloc_authinfo(void)\n{\n\tsctp_authinfo_t *new_authinfo;\n\n\tSCTP_MALLOC(new_authinfo, sctp_authinfo_t *, sizeof(*new_authinfo),\n\t\t    SCTP_M_AUTH_IF);\n\n\tif (new_authinfo == NULL) {\n\t\t/* out of memory */\n\t\treturn (NULL);\n\t}\n\tmemset(new_authinfo, 0, sizeof(*new_authinfo));\n\treturn (new_authinfo);\n}\n\nvoid\nsctp_free_authinfo(sctp_authinfo_t *authinfo)\n{\n\tif (authinfo == NULL)\n\t\treturn;\n\n\tif (authinfo->random != NULL)\n\t\tsctp_free_key(authinfo->random);\n\tif (authinfo->peer_random != NULL)\n\t\tsctp_free_key(authinfo->peer_random);\n\tif (authinfo->assoc_key != NULL)\n\t\tsctp_free_key(authinfo->assoc_key);\n\tif (authinfo->recv_key != NULL)\n\t\tsctp_free_key(authinfo->recv_key);\n\n\t/* We are NOT dynamically allocating authinfo's right now... */\n\t/* SCTP_FREE(authinfo, SCTP_M_AUTH_??); */\n}\n\n\nuint32_t\nsctp_get_auth_chunk_len(uint16_t hmac_algo)\n{\n\tint size;\n\n\tsize = sizeof(struct sctp_auth_chunk) + sctp_get_hmac_digest_len(hmac_algo);\n\treturn (SCTP_SIZE32(size));\n}\n\nuint32_t\nsctp_get_hmac_digest_len(uint16_t hmac_algo)\n{\n\tswitch (hmac_algo) {\n\tcase SCTP_AUTH_HMAC_ID_SHA1:\n\t\treturn (SCTP_AUTH_DIGEST_LEN_SHA1);\n#if defined(SCTP_SUPPORT_HMAC_SHA256)\n\tcase SCTP_AUTH_HMAC_ID_SHA256:\n\t\treturn (SCTP_AUTH_DIGEST_LEN_SHA256);\n#endif\n\tdefault:\n\t\t/* unknown HMAC algorithm: can't do anything */\n\t\treturn (0);\n\t} /* end switch */\n}\n\nstatic inline int\nsctp_get_hmac_block_len(uint16_t hmac_algo)\n{\n\tswitch (hmac_algo) {\n\tcase SCTP_AUTH_HMAC_ID_SHA1:\n\t\treturn (64);\n#if defined(SCTP_SUPPORT_HMAC_SHA256)\n\tcase SCTP_AUTH_HMAC_ID_SHA256:\n\t\treturn (64);\n#endif\n\tcase SCTP_AUTH_HMAC_ID_RSVD:\n\tdefault:\n\t\t/* unknown HMAC algorithm: can't do anything */\n\t\treturn (0);\n\t} /* end switch */\n}\n\n#if defined(__Userspace__)\n/* __Userspace__ SHA1_Init is defined in libcrypto.a (libssl-dev on Ubuntu) */\n#endif\nstatic void\nsctp_hmac_init(uint16_t hmac_algo, sctp_hash_context_t *ctx)\n{\n\tswitch (hmac_algo) {\n\tcase SCTP_AUTH_HMAC_ID_SHA1:\n\t\tSCTP_SHA1_INIT(&ctx->sha1);\n\t\tbreak;\n#if defined(SCTP_SUPPORT_HMAC_SHA256)\n\tcase SCTP_AUTH_HMAC_ID_SHA256:\n\t\tSCTP_SHA256_INIT(&ctx->sha256);\n\t\tbreak;\n#endif\n\tcase SCTP_AUTH_HMAC_ID_RSVD:\n\tdefault:\n\t\t/* unknown HMAC algorithm: can't do anything */\n\t\treturn;\n\t} /* end switch */\n}\n\nstatic void\nsctp_hmac_update(uint16_t hmac_algo, sctp_hash_context_t *ctx,\n    uint8_t *text, uint32_t textlen)\n{\n\tswitch (hmac_algo) {\n\tcase SCTP_AUTH_HMAC_ID_SHA1:\n\t\tSCTP_SHA1_UPDATE(&ctx->sha1, text, textlen);\n\t\tbreak;\n#if defined(SCTP_SUPPORT_HMAC_SHA256)\n\tcase SCTP_AUTH_HMAC_ID_SHA256:\n\t\tSCTP_SHA256_UPDATE(&ctx->sha256, text, textlen);\n\t\tbreak;\n#endif\n\tcase SCTP_AUTH_HMAC_ID_RSVD:\n\tdefault:\n\t\t/* unknown HMAC algorithm: can't do anything */\n\t\treturn;\n\t} /* end switch */\n}\n\nstatic void\nsctp_hmac_final(uint16_t hmac_algo, sctp_hash_context_t *ctx,\n    uint8_t *digest)\n{\n\tswitch (hmac_algo) {\n\tcase SCTP_AUTH_HMAC_ID_SHA1:\n\t\tSCTP_SHA1_FINAL(digest, &ctx->sha1);\n\t\tbreak;\n#if defined(SCTP_SUPPORT_HMAC_SHA256)\n\tcase SCTP_AUTH_HMAC_ID_SHA256:\n\t\tSCTP_SHA256_FINAL(digest, &ctx->sha256);\n\t\tbreak;\n#endif\n\tcase SCTP_AUTH_HMAC_ID_RSVD:\n\tdefault:\n\t\t/* unknown HMAC algorithm: can't do anything */\n\t\treturn;\n\t} /* end switch */\n}\n\n/*-\n * Keyed-Hashing for Message Authentication: FIPS 198 (RFC 2104)\n *\n * Compute the HMAC digest using the desired hash key, text, and HMAC\n * algorithm.  Resulting digest is placed in 'digest' and digest length\n * is returned, if the HMAC was performed.\n *\n * WARNING: it is up to the caller to supply sufficient space to hold the\n * resultant digest.\n */\nuint32_t\nsctp_hmac(uint16_t hmac_algo, uint8_t *key, uint32_t keylen,\n    uint8_t *text, uint32_t textlen, uint8_t *digest)\n{\n\tuint32_t digestlen;\n\tuint32_t blocklen;\n\tsctp_hash_context_t ctx;\n\tuint8_t ipad[128], opad[128];\t/* keyed hash inner/outer pads */\n\tuint8_t temp[SCTP_AUTH_DIGEST_LEN_MAX];\n\tuint32_t i;\n\n\t/* sanity check the material and length */\n\tif ((key == NULL) || (keylen == 0) || (text == NULL) ||\n\t    (textlen == 0) || (digest == NULL)) {\n\t\t/* can't do HMAC with empty key or text or digest store */\n\t\treturn (0);\n\t}\n\t/* validate the hmac algo and get the digest length */\n\tdigestlen = sctp_get_hmac_digest_len(hmac_algo);\n\tif (digestlen == 0)\n\t\treturn (0);\n\n\t/* hash the key if it is longer than the hash block size */\n\tblocklen = sctp_get_hmac_block_len(hmac_algo);\n\tif (keylen > blocklen) {\n\t\tsctp_hmac_init(hmac_algo, &ctx);\n\t\tsctp_hmac_update(hmac_algo, &ctx, key, keylen);\n\t\tsctp_hmac_final(hmac_algo, &ctx, temp);\n\t\t/* set the hashed key as the key */\n\t\tkeylen = digestlen;\n\t\tkey = temp;\n\t}\n\t/* initialize the inner/outer pads with the key and \"append\" zeroes */\n\tmemset(ipad, 0, blocklen);\n\tmemset(opad, 0, blocklen);\n\tmemcpy(ipad, key, keylen);\n\tmemcpy(opad, key, keylen);\n\n\t/* XOR the key with ipad and opad values */\n\tfor (i = 0; i < blocklen; i++) {\n\t\tipad[i] ^= 0x36;\n\t\topad[i] ^= 0x5c;\n\t}\n\n\t/* perform inner hash */\n\tsctp_hmac_init(hmac_algo, &ctx);\n\tsctp_hmac_update(hmac_algo, &ctx, ipad, blocklen);\n\tsctp_hmac_update(hmac_algo, &ctx, text, textlen);\n\tsctp_hmac_final(hmac_algo, &ctx, temp);\n\n\t/* perform outer hash */\n\tsctp_hmac_init(hmac_algo, &ctx);\n\tsctp_hmac_update(hmac_algo, &ctx, opad, blocklen);\n\tsctp_hmac_update(hmac_algo, &ctx, temp, digestlen);\n\tsctp_hmac_final(hmac_algo, &ctx, digest);\n\n\treturn (digestlen);\n}\n\n/* mbuf version */\nuint32_t\nsctp_hmac_m(uint16_t hmac_algo, uint8_t *key, uint32_t keylen,\n    struct mbuf *m, uint32_t m_offset, uint8_t *digest, uint32_t trailer)\n{\n\tuint32_t digestlen;\n\tuint32_t blocklen;\n\tsctp_hash_context_t ctx;\n\tuint8_t ipad[128], opad[128];\t/* keyed hash inner/outer pads */\n\tuint8_t temp[SCTP_AUTH_DIGEST_LEN_MAX];\n\tuint32_t i;\n\tstruct mbuf *m_tmp;\n\n\t/* sanity check the material and length */\n\tif ((key == NULL) || (keylen == 0) || (m == NULL) || (digest == NULL)) {\n\t\t/* can't do HMAC with empty key or text or digest store */\n\t\treturn (0);\n\t}\n\t/* validate the hmac algo and get the digest length */\n\tdigestlen = sctp_get_hmac_digest_len(hmac_algo);\n\tif (digestlen == 0)\n\t\treturn (0);\n\n\t/* hash the key if it is longer than the hash block size */\n\tblocklen = sctp_get_hmac_block_len(hmac_algo);\n\tif (keylen > blocklen) {\n\t\tsctp_hmac_init(hmac_algo, &ctx);\n\t\tsctp_hmac_update(hmac_algo, &ctx, key, keylen);\n\t\tsctp_hmac_final(hmac_algo, &ctx, temp);\n\t\t/* set the hashed key as the key */\n\t\tkeylen = digestlen;\n\t\tkey = temp;\n\t}\n\t/* initialize the inner/outer pads with the key and \"append\" zeroes */\n\tmemset(ipad, 0, blocklen);\n\tmemset(opad, 0, blocklen);\n\tmemcpy(ipad, key, keylen);\n\tmemcpy(opad, key, keylen);\n\n\t/* XOR the key with ipad and opad values */\n\tfor (i = 0; i < blocklen; i++) {\n\t\tipad[i] ^= 0x36;\n\t\topad[i] ^= 0x5c;\n\t}\n\n\t/* perform inner hash */\n\tsctp_hmac_init(hmac_algo, &ctx);\n\tsctp_hmac_update(hmac_algo, &ctx, ipad, blocklen);\n\t/* find the correct starting mbuf and offset (get start of text) */\n\tm_tmp = m;\n\twhile ((m_tmp != NULL) && (m_offset >= (uint32_t) SCTP_BUF_LEN(m_tmp))) {\n\t\tm_offset -= SCTP_BUF_LEN(m_tmp);\n\t\tm_tmp = SCTP_BUF_NEXT(m_tmp);\n\t}\n\t/* now use the rest of the mbuf chain for the text */\n\twhile (m_tmp != NULL) {\n\t\tif ((SCTP_BUF_NEXT(m_tmp) == NULL) && trailer) {\n\t\t\tsctp_hmac_update(hmac_algo, &ctx, mtod(m_tmp, uint8_t *) + m_offset,\n\t\t\t\t\t SCTP_BUF_LEN(m_tmp) - (trailer+m_offset));\n\t\t} else {\n\t\t\tsctp_hmac_update(hmac_algo, &ctx, mtod(m_tmp, uint8_t *) + m_offset,\n\t\t\t\t\t SCTP_BUF_LEN(m_tmp) - m_offset);\n\t\t}\n\n\t\t/* clear the offset since it's only for the first mbuf */\n\t\tm_offset = 0;\n\t\tm_tmp = SCTP_BUF_NEXT(m_tmp);\n\t}\n\tsctp_hmac_final(hmac_algo, &ctx, temp);\n\n\t/* perform outer hash */\n\tsctp_hmac_init(hmac_algo, &ctx);\n\tsctp_hmac_update(hmac_algo, &ctx, opad, blocklen);\n\tsctp_hmac_update(hmac_algo, &ctx, temp, digestlen);\n\tsctp_hmac_final(hmac_algo, &ctx, digest);\n\n\treturn (digestlen);\n}\n\n/*\n * computes the requested HMAC using a key struct (which may be modified if\n * the keylen exceeds the HMAC block len).\n */\nuint32_t\nsctp_compute_hmac(uint16_t hmac_algo, sctp_key_t *key, uint8_t *text,\n    uint32_t textlen, uint8_t *digest)\n{\n\tuint32_t digestlen;\n\tuint32_t blocklen;\n\tsctp_hash_context_t ctx;\n\tuint8_t temp[SCTP_AUTH_DIGEST_LEN_MAX];\n\n\t/* sanity check */\n\tif ((key == NULL) || (text == NULL) || (textlen == 0) ||\n\t    (digest == NULL)) {\n\t\t/* can't do HMAC with empty key or text or digest store */\n\t\treturn (0);\n\t}\n\t/* validate the hmac algo and get the digest length */\n\tdigestlen = sctp_get_hmac_digest_len(hmac_algo);\n\tif (digestlen == 0)\n\t\treturn (0);\n\n\t/* hash the key if it is longer than the hash block size */\n\tblocklen = sctp_get_hmac_block_len(hmac_algo);\n\tif (key->keylen > blocklen) {\n\t\tsctp_hmac_init(hmac_algo, &ctx);\n\t\tsctp_hmac_update(hmac_algo, &ctx, key->key, key->keylen);\n\t\tsctp_hmac_final(hmac_algo, &ctx, temp);\n\t\t/* save the hashed key as the new key */\n\t\tkey->keylen = digestlen;\n\t\tmemcpy(key->key, temp, key->keylen);\n\t}\n\treturn (sctp_hmac(hmac_algo, key->key, key->keylen, text, textlen,\n\t    digest));\n}\n\n/* mbuf version */\nuint32_t\nsctp_compute_hmac_m(uint16_t hmac_algo, sctp_key_t *key, struct mbuf *m,\n    uint32_t m_offset, uint8_t *digest)\n{\n\tuint32_t digestlen;\n\tuint32_t blocklen;\n\tsctp_hash_context_t ctx;\n\tuint8_t temp[SCTP_AUTH_DIGEST_LEN_MAX];\n\n\t/* sanity check */\n\tif ((key == NULL) || (m == NULL) || (digest == NULL)) {\n\t\t/* can't do HMAC with empty key or text or digest store */\n\t\treturn (0);\n\t}\n\t/* validate the hmac algo and get the digest length */\n\tdigestlen = sctp_get_hmac_digest_len(hmac_algo);\n\tif (digestlen == 0)\n\t\treturn (0);\n\n\t/* hash the key if it is longer than the hash block size */\n\tblocklen = sctp_get_hmac_block_len(hmac_algo);\n\tif (key->keylen > blocklen) {\n\t\tsctp_hmac_init(hmac_algo, &ctx);\n\t\tsctp_hmac_update(hmac_algo, &ctx, key->key, key->keylen);\n\t\tsctp_hmac_final(hmac_algo, &ctx, temp);\n\t\t/* save the hashed key as the new key */\n\t\tkey->keylen = digestlen;\n\t\tmemcpy(key->key, temp, key->keylen);\n\t}\n\treturn (sctp_hmac_m(hmac_algo, key->key, key->keylen, m, m_offset, digest, 0));\n}\n\nint\nsctp_auth_is_supported_hmac(sctp_hmaclist_t *list, uint16_t id)\n{\n\tint i;\n\n\tif ((list == NULL) || (id == SCTP_AUTH_HMAC_ID_RSVD))\n\t\treturn (0);\n\n\tfor (i = 0; i < list->num_algo; i++)\n\t\tif (list->hmac[i] == id)\n\t\t\treturn (1);\n\n\t/* not in the list */\n\treturn (0);\n}\n\n\n/*-\n * clear any cached key(s) if they match the given key id on an association.\n * the cached key(s) will be recomputed and re-cached at next use.\n * ASSUMES TCB_LOCK is already held\n */\nvoid\nsctp_clear_cachedkeys(struct sctp_tcb *stcb, uint16_t keyid)\n{\n\tif (stcb == NULL)\n\t\treturn;\n\n\tif (keyid == stcb->asoc.authinfo.assoc_keyid) {\n\t\tsctp_free_key(stcb->asoc.authinfo.assoc_key);\n\t\tstcb->asoc.authinfo.assoc_key = NULL;\n\t}\n\tif (keyid == stcb->asoc.authinfo.recv_keyid) {\n\t\tsctp_free_key(stcb->asoc.authinfo.recv_key);\n\t\tstcb->asoc.authinfo.recv_key = NULL;\n\t}\n}\n\n/*-\n * clear any cached key(s) if they match the given key id for all assocs on\n * an endpoint.\n * ASSUMES INP_WLOCK is already held\n */\nvoid\nsctp_clear_cachedkeys_ep(struct sctp_inpcb *inp, uint16_t keyid)\n{\n\tstruct sctp_tcb *stcb;\n\n\tif (inp == NULL)\n\t\treturn;\n\n\t/* clear the cached keys on all assocs on this instance */\n\tLIST_FOREACH(stcb, &inp->sctp_asoc_list, sctp_tcblist) {\n\t\tSCTP_TCB_LOCK(stcb);\n\t\tsctp_clear_cachedkeys(stcb, keyid);\n\t\tSCTP_TCB_UNLOCK(stcb);\n\t}\n}\n\n/*-\n * delete a shared key from an association\n * ASSUMES TCB_LOCK is already held\n */\nint\nsctp_delete_sharedkey(struct sctp_tcb *stcb, uint16_t keyid)\n{\n\tsctp_sharedkey_t *skey;\n\n\tif (stcb == NULL)\n\t\treturn (-1);\n\n\t/* is the keyid the assoc active sending key */\n\tif (keyid == stcb->asoc.authinfo.active_keyid)\n\t\treturn (-1);\n\n\t/* does the key exist? */\n\tskey = sctp_find_sharedkey(&stcb->asoc.shared_keys, keyid);\n\tif (skey == NULL)\n\t\treturn (-1);\n\n\t/* are there other refcount holders on the key? */\n\tif (skey->refcount > 1)\n\t\treturn (-1);\n\n\t/* remove it */\n\tLIST_REMOVE(skey, next);\n\tsctp_free_sharedkey(skey);\t/* frees skey->key as well */\n\n\t/* clear any cached keys */\n\tsctp_clear_cachedkeys(stcb, keyid);\n\treturn (0);\n}\n\n/*-\n * deletes a shared key from the endpoint\n * ASSUMES INP_WLOCK is already held\n */\nint\nsctp_delete_sharedkey_ep(struct sctp_inpcb *inp, uint16_t keyid)\n{\n\tsctp_sharedkey_t *skey;\n\n\tif (inp == NULL)\n\t\treturn (-1);\n\n\t/* is the keyid the active sending key on the endpoint */\n\tif (keyid == inp->sctp_ep.default_keyid)\n\t\treturn (-1);\n\n\t/* does the key exist? */\n\tskey = sctp_find_sharedkey(&inp->sctp_ep.shared_keys, keyid);\n\tif (skey == NULL)\n\t\treturn (-1);\n\n\t/* endpoint keys are not refcounted */\n\n\t/* remove it */\n\tLIST_REMOVE(skey, next);\n\tsctp_free_sharedkey(skey);\t/* frees skey->key as well */\n\n\t/* clear any cached keys */\n\tsctp_clear_cachedkeys_ep(inp, keyid);\n\treturn (0);\n}\n\n/*-\n * set the active key on an association\n * ASSUMES TCB_LOCK is already held\n */\nint\nsctp_auth_setactivekey(struct sctp_tcb *stcb, uint16_t keyid)\n{\n\tsctp_sharedkey_t *skey = NULL;\n\n\t/* find the key on the assoc */\n\tskey = sctp_find_sharedkey(&stcb->asoc.shared_keys, keyid);\n\tif (skey == NULL) {\n\t\t/* that key doesn't exist */\n\t\treturn (-1);\n\t}\n\tif ((skey->deactivated) && (skey->refcount > 1)) {\n\t\t/* can't reactivate a deactivated key with other refcounts */\n\t\treturn (-1);\n\t}\n\n\t/* set the (new) active key */\n\tstcb->asoc.authinfo.active_keyid = keyid;\n\t/* reset the deactivated flag */\n\tskey->deactivated = 0;\n\n\treturn (0);\n}\n\n/*-\n * set the active key on an endpoint\n * ASSUMES INP_WLOCK is already held\n */\nint\nsctp_auth_setactivekey_ep(struct sctp_inpcb *inp, uint16_t keyid)\n{\n\tsctp_sharedkey_t *skey;\n\n\t/* find the key */\n\tskey = sctp_find_sharedkey(&inp->sctp_ep.shared_keys, keyid);\n\tif (skey == NULL) {\n\t\t/* that key doesn't exist */\n\t\treturn (-1);\n\t}\n\tinp->sctp_ep.default_keyid = keyid;\n\treturn (0);\n}\n\n/*-\n * deactivates a shared key from the association\n * ASSUMES INP_WLOCK is already held\n */\nint\nsctp_deact_sharedkey(struct sctp_tcb *stcb, uint16_t keyid)\n{\n\tsctp_sharedkey_t *skey;\n\n\tif (stcb == NULL)\n\t\treturn (-1);\n\n\t/* is the keyid the assoc active sending key */\n\tif (keyid == stcb->asoc.authinfo.active_keyid)\n\t\treturn (-1);\n\n\t/* does the key exist? */\n\tskey = sctp_find_sharedkey(&stcb->asoc.shared_keys, keyid);\n\tif (skey == NULL)\n\t\treturn (-1);\n\n\t/* are there other refcount holders on the key? */\n\tif (skey->refcount == 1) {\n\t\t/* no other users, send a notification for this key */\n\t\tsctp_ulp_notify(SCTP_NOTIFY_AUTH_FREE_KEY, stcb, keyid, 0,\n\t\t\t\tSCTP_SO_LOCKED);\n\t}\n\n\t/* mark the key as deactivated */\n\tskey->deactivated = 1;\n\n\treturn (0);\n}\n\n/*-\n * deactivates a shared key from the endpoint\n * ASSUMES INP_WLOCK is already held\n */\nint\nsctp_deact_sharedkey_ep(struct sctp_inpcb *inp, uint16_t keyid)\n{\n\tsctp_sharedkey_t *skey;\n\n\tif (inp == NULL)\n\t\treturn (-1);\n\n\t/* is the keyid the active sending key on the endpoint */\n\tif (keyid == inp->sctp_ep.default_keyid)\n\t\treturn (-1);\n\n\t/* does the key exist? */\n\tskey = sctp_find_sharedkey(&inp->sctp_ep.shared_keys, keyid);\n\tif (skey == NULL)\n\t\treturn (-1);\n\n\t/* endpoint keys are not refcounted */\n\n\t/* remove it */\n\tLIST_REMOVE(skey, next);\n\tsctp_free_sharedkey(skey);\t/* frees skey->key as well */\n\n\treturn (0);\n}\n\n/*\n * get local authentication parameters from cookie (from INIT-ACK)\n */\nvoid\nsctp_auth_get_cookie_params(struct sctp_tcb *stcb, struct mbuf *m,\n    uint32_t offset, uint32_t length)\n{\n\tstruct sctp_paramhdr *phdr, tmp_param;\n\tuint16_t plen, ptype;\n\tuint8_t random_store[SCTP_PARAM_BUFFER_SIZE];\n\tstruct sctp_auth_random *p_random = NULL;\n\tuint16_t random_len = 0;\n\tuint8_t hmacs_store[SCTP_PARAM_BUFFER_SIZE];\n\tstruct sctp_auth_hmac_algo *hmacs = NULL;\n\tuint16_t hmacs_len = 0;\n\tuint8_t chunks_store[SCTP_PARAM_BUFFER_SIZE];\n\tstruct sctp_auth_chunk_list *chunks = NULL;\n\tuint16_t num_chunks = 0;\n\tsctp_key_t *new_key;\n\tuint32_t keylen;\n\n\t/* convert to upper bound */\n\tlength += offset;\n\n\tphdr = (struct sctp_paramhdr *)sctp_m_getptr(m, offset,\n\t    sizeof(struct sctp_paramhdr), (uint8_t *)&tmp_param);\n\twhile (phdr != NULL) {\n\t\tptype = ntohs(phdr->param_type);\n\t\tplen = ntohs(phdr->param_length);\n\n\t\tif ((plen == 0) || (offset + plen > length))\n\t\t\tbreak;\n\n\t\tif (ptype == SCTP_RANDOM) {\n\t\t\tif (plen > sizeof(random_store))\n\t\t\t\tbreak;\n\t\t\tphdr = sctp_get_next_param(m, offset,\n\t\t\t    (struct sctp_paramhdr *)random_store, plen);\n\t\t\tif (phdr == NULL)\n\t\t\t\treturn;\n\t\t\t/* save the random and length for the key */\n\t\t\tp_random = (struct sctp_auth_random *)phdr;\n\t\t\trandom_len = plen - sizeof(*p_random);\n\t\t} else if (ptype == SCTP_HMAC_LIST) {\n\t\t\tuint16_t num_hmacs;\n\t\t\tuint16_t i;\n\n\t\t\tif (plen > sizeof(hmacs_store))\n\t\t\t\tbreak;\n\t\t\tphdr = sctp_get_next_param(m, offset,\n\t\t\t    (struct sctp_paramhdr *)hmacs_store, plen);\n\t\t\tif (phdr == NULL)\n\t\t\t\treturn;\n\t\t\t/* save the hmacs list and num for the key */\n\t\t\thmacs = (struct sctp_auth_hmac_algo *)phdr;\n\t\t\thmacs_len = plen - sizeof(*hmacs);\n\t\t\tnum_hmacs = hmacs_len / sizeof(hmacs->hmac_ids[0]);\n\t\t\tif (stcb->asoc.local_hmacs != NULL)\n\t\t\t\tsctp_free_hmaclist(stcb->asoc.local_hmacs);\n\t\t\tstcb->asoc.local_hmacs = sctp_alloc_hmaclist(num_hmacs);\n\t\t\tif (stcb->asoc.local_hmacs != NULL) {\n\t\t\t\tfor (i = 0; i < num_hmacs; i++) {\n\t\t\t\t\t(void)sctp_auth_add_hmacid(stcb->asoc.local_hmacs,\n\t\t\t\t\t    ntohs(hmacs->hmac_ids[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (ptype == SCTP_CHUNK_LIST) {\n\t\t\tint i;\n\n\t\t\tif (plen > sizeof(chunks_store))\n\t\t\t\tbreak;\n\t\t\tphdr = sctp_get_next_param(m, offset,\n\t\t\t    (struct sctp_paramhdr *)chunks_store, plen);\n\t\t\tif (phdr == NULL)\n\t\t\t\treturn;\n\t\t\tchunks = (struct sctp_auth_chunk_list *)phdr;\n\t\t\tnum_chunks = plen - sizeof(*chunks);\n\t\t\t/* save chunks list and num for the key */\n\t\t\tif (stcb->asoc.local_auth_chunks != NULL)\n\t\t\t\tsctp_clear_chunklist(stcb->asoc.local_auth_chunks);\n\t\t\telse\n\t\t\t\tstcb->asoc.local_auth_chunks = sctp_alloc_chunklist();\n\t\t\tfor (i = 0; i < num_chunks; i++) {\n\t\t\t\t(void)sctp_auth_add_chunk(chunks->chunk_types[i],\n\t\t\t\t    stcb->asoc.local_auth_chunks);\n\t\t\t}\n\t\t}\n\t\t/* get next parameter */\n\t\toffset += SCTP_SIZE32(plen);\n\t\tif (offset + sizeof(struct sctp_paramhdr) > length)\n\t\t\tbreak;\n\t\tphdr = (struct sctp_paramhdr *)sctp_m_getptr(m, offset, sizeof(struct sctp_paramhdr),\n\t\t    (uint8_t *)&tmp_param);\n\t}\n\t/* concatenate the full random key */\n\tkeylen = sizeof(*p_random) + random_len + sizeof(*hmacs) + hmacs_len;\n\tif (chunks != NULL) {\n\t\tkeylen += sizeof(*chunks) + num_chunks;\n\t}\n\tnew_key = sctp_alloc_key(keylen);\n\tif (new_key != NULL) {\n\t\t/* copy in the RANDOM */\n\t\tif (p_random != NULL) {\n\t\t\tkeylen = sizeof(*p_random) + random_len;\n\t\t\tmemcpy(new_key->key, p_random, keylen);\n\t\t} else {\n\t\t\tkeylen = 0;\n\t\t}\n\t\t/* append in the AUTH chunks */\n\t\tif (chunks != NULL) {\n\t\t\tmemcpy(new_key->key + keylen, chunks,\n\t\t\t       sizeof(*chunks) + num_chunks);\n\t\t\tkeylen += sizeof(*chunks) + num_chunks;\n\t\t}\n\t\t/* append in the HMACs */\n\t\tif (hmacs != NULL) {\n\t\t\tmemcpy(new_key->key + keylen, hmacs,\n\t\t\t       sizeof(*hmacs) + hmacs_len);\n\t\t}\n\t}\n\tif (stcb->asoc.authinfo.random != NULL)\n\t\tsctp_free_key(stcb->asoc.authinfo.random);\n\tstcb->asoc.authinfo.random = new_key;\n\tstcb->asoc.authinfo.random_len = random_len;\n\tsctp_clear_cachedkeys(stcb, stcb->asoc.authinfo.assoc_keyid);\n\tsctp_clear_cachedkeys(stcb, stcb->asoc.authinfo.recv_keyid);\n\n\t/* negotiate what HMAC to use for the peer */\n\tstcb->asoc.peer_hmac_id = sctp_negotiate_hmacid(stcb->asoc.peer_hmacs,\n\t    stcb->asoc.local_hmacs);\n\n\t/* copy defaults from the endpoint */\n\t/* FIX ME: put in cookie? */\n\tstcb->asoc.authinfo.active_keyid = stcb->sctp_ep->sctp_ep.default_keyid;\n\t/* copy out the shared key list (by reference) from the endpoint */\n\t(void)sctp_copy_skeylist(&stcb->sctp_ep->sctp_ep.shared_keys,\n\t\t\t\t &stcb->asoc.shared_keys);\n}\n\n/*\n * compute and fill in the HMAC digest for a packet\n */\nvoid\nsctp_fill_hmac_digest_m(struct mbuf *m, uint32_t auth_offset,\n    struct sctp_auth_chunk *auth, struct sctp_tcb *stcb, uint16_t keyid)\n{\n\tuint32_t digestlen;\n\tsctp_sharedkey_t *skey;\n\tsctp_key_t *key;\n\n\tif ((stcb == NULL) || (auth == NULL))\n\t\treturn;\n\n\t/* zero the digest + chunk padding */\n\tdigestlen = sctp_get_hmac_digest_len(stcb->asoc.peer_hmac_id);\n\tmemset(auth->hmac, 0, SCTP_SIZE32(digestlen));\n\n\t/* is the desired key cached? */\n\tif ((keyid != stcb->asoc.authinfo.assoc_keyid) ||\n\t    (stcb->asoc.authinfo.assoc_key == NULL)) {\n\t\tif (stcb->asoc.authinfo.assoc_key != NULL) {\n\t\t\t/* free the old cached key */\n\t\t\tsctp_free_key(stcb->asoc.authinfo.assoc_key);\n\t\t}\n\t\tskey = sctp_find_sharedkey(&stcb->asoc.shared_keys, keyid);\n\t\t/* the only way skey is NULL is if null key id 0 is used */\n\t\tif (skey != NULL)\n\t\t\tkey = skey->key;\n\t\telse\n\t\t\tkey = NULL;\n\t\t/* compute a new assoc key and cache it */\n\t\tstcb->asoc.authinfo.assoc_key =\n\t\t    sctp_compute_hashkey(stcb->asoc.authinfo.random,\n\t\t\t\t\t stcb->asoc.authinfo.peer_random, key);\n\t\tstcb->asoc.authinfo.assoc_keyid = keyid;\n\t\tSCTPDBG(SCTP_DEBUG_AUTH1, \"caching key id %u\\n\",\n\t\t\tstcb->asoc.authinfo.assoc_keyid);\n#ifdef SCTP_DEBUG\n\t\tif (SCTP_AUTH_DEBUG)\n\t\t\tsctp_print_key(stcb->asoc.authinfo.assoc_key,\n\t\t\t\t       \"Assoc Key\");\n#endif\n\t}\n\n\t/* set in the active key id */\n\tauth->shared_key_id = htons(keyid);\n\n\t/* compute and fill in the digest */\n\t(void)sctp_compute_hmac_m(stcb->asoc.peer_hmac_id, stcb->asoc.authinfo.assoc_key,\n\t\t\t\t  m, auth_offset, auth->hmac);\n}\n\n\nstatic void\nsctp_zero_m(struct mbuf *m, uint32_t m_offset, uint32_t size)\n{\n\tstruct mbuf *m_tmp;\n\tuint8_t *data;\n\n\t/* sanity check */\n\tif (m == NULL)\n\t\treturn;\n\n\t/* find the correct starting mbuf and offset (get start position) */\n\tm_tmp = m;\n\twhile ((m_tmp != NULL) && (m_offset >= (uint32_t) SCTP_BUF_LEN(m_tmp))) {\n\t\tm_offset -= SCTP_BUF_LEN(m_tmp);\n\t\tm_tmp = SCTP_BUF_NEXT(m_tmp);\n\t}\n\t/* now use the rest of the mbuf chain */\n\twhile ((m_tmp != NULL) && (size > 0)) {\n\t\tdata = mtod(m_tmp, uint8_t *) + m_offset;\n\t\tif (size > (uint32_t)(SCTP_BUF_LEN(m_tmp) - m_offset)) {\n\t\t\tmemset(data, 0, SCTP_BUF_LEN(m_tmp) - m_offset);\n\t\t\tsize -= SCTP_BUF_LEN(m_tmp) - m_offset;\n\t\t} else {\n\t\t\tmemset(data, 0, size);\n\t\t\tsize = 0;\n\t\t}\n\t\t/* clear the offset since it's only for the first mbuf */\n\t\tm_offset = 0;\n\t\tm_tmp = SCTP_BUF_NEXT(m_tmp);\n\t}\n}\n\n/*-\n * process the incoming Authentication chunk\n * return codes:\n *   -1 on any authentication error\n *    0 on authentication verification\n */\nint\nsctp_handle_auth(struct sctp_tcb *stcb, struct sctp_auth_chunk *auth,\n    struct mbuf *m, uint32_t offset)\n{\n\tuint16_t chunklen;\n\tuint16_t shared_key_id;\n\tuint16_t hmac_id;\n\tsctp_sharedkey_t *skey;\n\tuint32_t digestlen;\n\tuint8_t digest[SCTP_AUTH_DIGEST_LEN_MAX];\n\tuint8_t computed_digest[SCTP_AUTH_DIGEST_LEN_MAX];\n\n\t/* auth is checked for NULL by caller */\n\tchunklen = ntohs(auth->ch.chunk_length);\n\tif (chunklen < sizeof(*auth)) {\n\t\tSCTP_STAT_INCR(sctps_recvauthfailed);\n\t\treturn (-1);\n\t}\n\tSCTP_STAT_INCR(sctps_recvauth);\n\n\t/* get the auth params */\n\tshared_key_id = ntohs(auth->shared_key_id);\n\thmac_id = ntohs(auth->hmac_id);\n\tSCTPDBG(SCTP_DEBUG_AUTH1,\n\t\t\"SCTP AUTH Chunk: shared key %u, HMAC id %u\\n\",\n\t\tshared_key_id, hmac_id);\n\n\t/* is the indicated HMAC supported? */\n\tif (!sctp_auth_is_supported_hmac(stcb->asoc.local_hmacs, hmac_id)) {\n\t\tstruct mbuf *op_err;\n\t\tstruct sctp_error_auth_invalid_hmac *cause;\n\n\t\tSCTP_STAT_INCR(sctps_recvivalhmacid);\n\t\tSCTPDBG(SCTP_DEBUG_AUTH1,\n\t\t\t\"SCTP Auth: unsupported HMAC id %u\\n\",\n\t\t\thmac_id);\n\t\t/*\n\t\t * report this in an Error Chunk: Unsupported HMAC\n\t\t * Identifier\n\t\t */\n\t\top_err = sctp_get_mbuf_for_msg(sizeof(struct sctp_error_auth_invalid_hmac),\n\t\t                               0, M_NOWAIT, 1, MT_HEADER);\n\t\tif (op_err != NULL) {\n\t\t\t/* pre-reserve some space */\n\t\t\tSCTP_BUF_RESV_UF(op_err, sizeof(struct sctp_chunkhdr));\n\t\t\t/* fill in the error */\n\t\t\tcause = mtod(op_err, struct sctp_error_auth_invalid_hmac *);\n\t\t\tcause->cause.code = htons(SCTP_CAUSE_UNSUPPORTED_HMACID);\n\t\t\tcause->cause.length = htons(sizeof(struct sctp_error_auth_invalid_hmac));\n\t\t\tcause->hmac_id = ntohs(hmac_id);\n\t\t\tSCTP_BUF_LEN(op_err) = sizeof(struct sctp_error_auth_invalid_hmac);\n\t\t\t/* queue it */\n\t\t\tsctp_queue_op_err(stcb, op_err);\n\t\t}\n\t\treturn (-1);\n\t}\n\t/* get the indicated shared key, if available */\n\tif ((stcb->asoc.authinfo.recv_key == NULL) ||\n\t    (stcb->asoc.authinfo.recv_keyid != shared_key_id)) {\n\t\t/* find the shared key on the assoc first */\n\t\tskey = sctp_find_sharedkey(&stcb->asoc.shared_keys,\n\t\t\t\t\t   shared_key_id);\n\t\t/* if the shared key isn't found, discard the chunk */\n\t\tif (skey == NULL) {\n\t\t\tSCTP_STAT_INCR(sctps_recvivalkeyid);\n\t\t\tSCTPDBG(SCTP_DEBUG_AUTH1,\n\t\t\t\t\"SCTP Auth: unknown key id %u\\n\",\n\t\t\t\tshared_key_id);\n\t\t\treturn (-1);\n\t\t}\n\t\t/* generate a notification if this is a new key id */\n\t\tif (stcb->asoc.authinfo.recv_keyid != shared_key_id)\n\t\t\t/*\n\t\t\t * sctp_ulp_notify(SCTP_NOTIFY_AUTH_NEW_KEY, stcb,\n\t\t\t * shared_key_id, (void\n\t\t\t * *)stcb->asoc.authinfo.recv_keyid);\n\t\t\t */\n\t\t\tsctp_notify_authentication(stcb, SCTP_AUTH_NEW_KEY,\n\t\t\t    shared_key_id, stcb->asoc.authinfo.recv_keyid,\n\t\t\t    SCTP_SO_NOT_LOCKED);\n\t\t/* compute a new recv assoc key and cache it */\n\t\tif (stcb->asoc.authinfo.recv_key != NULL)\n\t\t\tsctp_free_key(stcb->asoc.authinfo.recv_key);\n\t\tstcb->asoc.authinfo.recv_key =\n\t\t    sctp_compute_hashkey(stcb->asoc.authinfo.random,\n\t\t    stcb->asoc.authinfo.peer_random, skey->key);\n\t\tstcb->asoc.authinfo.recv_keyid = shared_key_id;\n#ifdef SCTP_DEBUG\n\t\tif (SCTP_AUTH_DEBUG)\n\t\t\tsctp_print_key(stcb->asoc.authinfo.recv_key, \"Recv Key\");\n#endif\n\t}\n\t/* validate the digest length */\n\tdigestlen = sctp_get_hmac_digest_len(hmac_id);\n\tif (chunklen < (sizeof(*auth) + digestlen)) {\n\t\t/* invalid digest length */\n\t\tSCTP_STAT_INCR(sctps_recvauthfailed);\n\t\tSCTPDBG(SCTP_DEBUG_AUTH1,\n\t\t\t\"SCTP Auth: chunk too short for HMAC\\n\");\n\t\treturn (-1);\n\t}\n\t/* save a copy of the digest, zero the pseudo header, and validate */\n\tmemcpy(digest, auth->hmac, digestlen);\n\tsctp_zero_m(m, offset + sizeof(*auth), SCTP_SIZE32(digestlen));\n\t(void)sctp_compute_hmac_m(hmac_id, stcb->asoc.authinfo.recv_key,\n\t    m, offset, computed_digest);\n\n#if defined(__Userspace__)\n#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n\treturn (0);\n#endif\n#endif\n\t/* compare the computed digest with the one in the AUTH chunk */\n\tif (timingsafe_bcmp(digest, computed_digest, digestlen) != 0) {\n\t\tSCTP_STAT_INCR(sctps_recvauthfailed);\n\t\tSCTPDBG(SCTP_DEBUG_AUTH1,\n\t\t\t\"SCTP Auth: HMAC digest check failed\\n\");\n\t\treturn (-1);\n\t}\n\treturn (0);\n}\n\n/*\n * Generate NOTIFICATION\n */\nvoid\nsctp_notify_authentication(struct sctp_tcb *stcb, uint32_t indication,\n\t\t\t   uint16_t keyid, uint16_t alt_keyid, int so_locked\n#if !defined(__APPLE__) && !defined(SCTP_SO_LOCK_TESTING)\n\tSCTP_UNUSED\n#endif\n)\n{\n\tstruct mbuf *m_notify;\n\tstruct sctp_authkey_event *auth;\n\tstruct sctp_queued_to_read *control;\n\n\tif ((stcb == NULL) ||\n\t   (stcb->sctp_ep->sctp_flags & SCTP_PCB_FLAGS_SOCKET_GONE) ||\n\t   (stcb->sctp_ep->sctp_flags & SCTP_PCB_FLAGS_SOCKET_ALLGONE) ||\n\t   (stcb->asoc.state & SCTP_STATE_CLOSED_SOCKET)\n\t\t) {\n\t\t/* If the socket is gone we are out of here */\n\t\treturn;\n\t}\n\n\tif (sctp_stcb_is_feature_off(stcb->sctp_ep, stcb, SCTP_PCB_FLAGS_AUTHEVNT))\n\t\t/* event not enabled */\n\t\treturn;\n\n\tm_notify = sctp_get_mbuf_for_msg(sizeof(struct sctp_authkey_event),\n\t\t\t\t\t  0, M_NOWAIT, 1, MT_HEADER);\n\tif (m_notify == NULL)\n\t\t/* no space left */\n\t\treturn;\n\n\tSCTP_BUF_LEN(m_notify) = 0;\n\tauth = mtod(m_notify, struct sctp_authkey_event *);\n\tmemset(auth, 0, sizeof(struct sctp_authkey_event));\n\tauth->auth_type = SCTP_AUTHENTICATION_EVENT;\n\tauth->auth_flags = 0;\n\tauth->auth_length = sizeof(*auth);\n\tauth->auth_keynumber = keyid;\n\tauth->auth_altkeynumber = alt_keyid;\n\tauth->auth_indication = indication;\n\tauth->auth_assoc_id = sctp_get_associd(stcb);\n\n\tSCTP_BUF_LEN(m_notify) = sizeof(*auth);\n\tSCTP_BUF_NEXT(m_notify) = NULL;\n\n\t/* append to socket */\n\tcontrol = sctp_build_readq_entry(stcb, stcb->asoc.primary_destination,\n\t    0, 0, stcb->asoc.context, 0, 0, 0, m_notify);\n\tif (control == NULL) {\n\t\t/* no memory */\n\t\tsctp_m_freem(m_notify);\n\t\treturn;\n\t}\n\tcontrol->length = SCTP_BUF_LEN(m_notify);\n\tcontrol->spec_flags = M_NOTIFICATION;\n\t/* not that we need this */\n\tcontrol->tail_mbuf = m_notify;\n\tsctp_add_to_readq(stcb->sctp_ep, stcb, control,\n\t    &stcb->sctp_socket->so_rcv, 1, SCTP_READ_LOCK_NOT_HELD, so_locked);\n}\n\n\n/*-\n * validates the AUTHentication related parameters in an INIT/INIT-ACK\n * Note: currently only used for INIT as INIT-ACK is handled inline\n * with sctp_load_addresses_from_init()\n */\nint\nsctp_validate_init_auth_params(struct mbuf *m, int offset, int limit)\n{\n\tstruct sctp_paramhdr *phdr, param_buf;\n\tuint16_t ptype, plen;\n\tint peer_supports_asconf = 0;\n\tint peer_supports_auth = 0;\n\tint got_random = 0, got_hmacs = 0, got_chklist = 0;\n\tuint8_t saw_asconf = 0;\n\tuint8_t saw_asconf_ack = 0;\n\n\t/* go through each of the params. */\n\tphdr = sctp_get_next_param(m, offset, &param_buf, sizeof(param_buf));\n\twhile (phdr) {\n\t\tptype = ntohs(phdr->param_type);\n\t\tplen = ntohs(phdr->param_length);\n\n\t\tif (offset + plen > limit) {\n\t\t\tbreak;\n\t\t}\n\t\tif (plen < sizeof(struct sctp_paramhdr)) {\n\t\t\tbreak;\n\t\t}\n\t\tif (ptype == SCTP_SUPPORTED_CHUNK_EXT) {\n\t\t\t/* A supported extension chunk */\n\t\t\tstruct sctp_supported_chunk_types_param *pr_supported;\n\t\t\tuint8_t local_store[SCTP_SMALL_CHUNK_STORE];\n\t\t\tint num_ent, i;\n\n\t\t\tif (plen > sizeof(local_store)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tphdr = sctp_get_next_param(m, offset,\n\t\t\t                           (struct sctp_paramhdr *)&local_store,\n\t\t\t                           plen);\n\t\t\tif (phdr == NULL) {\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\tpr_supported = (struct sctp_supported_chunk_types_param *)phdr;\n\t\t\tnum_ent = plen - sizeof(struct sctp_paramhdr);\n\t\t\tfor (i = 0; i < num_ent; i++) {\n\t\t\t\tswitch (pr_supported->chunk_types[i]) {\n\t\t\t\tcase SCTP_ASCONF:\n\t\t\t\tcase SCTP_ASCONF_ACK:\n\t\t\t\t\tpeer_supports_asconf = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t/* one we don't care about */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (ptype == SCTP_RANDOM) {\n\t\t\t/* enforce the random length */\n\t\t\tif (plen != (sizeof(struct sctp_auth_random) +\n\t\t\t\t     SCTP_AUTH_RANDOM_SIZE_REQUIRED)) {\n\t\t\t\tSCTPDBG(SCTP_DEBUG_AUTH1,\n\t\t\t\t\t\"SCTP: invalid RANDOM len\\n\");\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\tgot_random = 1;\n\t\t} else if (ptype == SCTP_HMAC_LIST) {\n\t\t\tstruct sctp_auth_hmac_algo *hmacs;\n\t\t\tuint8_t store[SCTP_PARAM_BUFFER_SIZE];\n\t\t\tint num_hmacs;\n\n\t\t\tif (plen > sizeof(store)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tphdr = sctp_get_next_param(m, offset,\n\t\t\t                           (struct sctp_paramhdr *)store,\n\t\t\t                           plen);\n\t\t\tif (phdr == NULL) {\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\thmacs = (struct sctp_auth_hmac_algo *)phdr;\n\t\t\tnum_hmacs = (plen - sizeof(*hmacs)) / sizeof(hmacs->hmac_ids[0]);\n\t\t\t/* validate the hmac list */\n\t\t\tif (sctp_verify_hmac_param(hmacs, num_hmacs)) {\n\t\t\t\tSCTPDBG(SCTP_DEBUG_AUTH1,\n\t\t\t\t\t\"SCTP: invalid HMAC param\\n\");\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\tgot_hmacs = 1;\n\t\t} else if (ptype == SCTP_CHUNK_LIST) {\n\t\t\tstruct sctp_auth_chunk_list *chunks;\n\t\t\tuint8_t chunks_store[SCTP_SMALL_CHUNK_STORE];\n\t\t\tint i, num_chunks;\n\n\t\t\tif (plen > sizeof(chunks_store)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tphdr = sctp_get_next_param(m, offset,\n\t\t\t\t\t\t   (struct sctp_paramhdr *)chunks_store,\n\t\t\t\t\t\t   plen);\n\t\t\tif (phdr == NULL) {\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\t/*-\n\t\t\t * Flip through the list and mark that the\n\t\t\t * peer supports asconf/asconf_ack.\n\t\t\t */\n\t\t\tchunks = (struct sctp_auth_chunk_list *)phdr;\n\t\t\tnum_chunks = plen - sizeof(*chunks);\n\t\t\tfor (i = 0; i < num_chunks; i++) {\n\t\t\t\t/* record asconf/asconf-ack if listed */\n\t\t\t\tif (chunks->chunk_types[i] == SCTP_ASCONF)\n\t\t\t\t\tsaw_asconf = 1;\n\t\t\t\tif (chunks->chunk_types[i] == SCTP_ASCONF_ACK)\n\t\t\t\t\tsaw_asconf_ack = 1;\n\n\t\t\t}\n\t\t\tif (num_chunks)\n\t\t\t\tgot_chklist = 1;\n\t\t}\n\n\t\toffset += SCTP_SIZE32(plen);\n\t\tif (offset >= limit) {\n\t\t\tbreak;\n\t\t}\n\t\tphdr = sctp_get_next_param(m, offset, &param_buf,\n\t\t    sizeof(param_buf));\n\t}\n\t/* validate authentication required parameters */\n\tif (got_random && got_hmacs) {\n\t\tpeer_supports_auth = 1;\n\t} else {\n\t\tpeer_supports_auth = 0;\n\t}\n\tif (!peer_supports_auth && got_chklist) {\n\t\tSCTPDBG(SCTP_DEBUG_AUTH1,\n\t\t\t\"SCTP: peer sent chunk list w/o AUTH\\n\");\n\t\treturn (-1);\n\t}\n\tif (peer_supports_asconf && !peer_supports_auth) {\n\t\tSCTPDBG(SCTP_DEBUG_AUTH1,\n\t\t\t\"SCTP: peer supports ASCONF but not AUTH\\n\");\n\t\treturn (-1);\n\t} else if ((peer_supports_asconf) && (peer_supports_auth) &&\n\t\t   ((saw_asconf == 0) || (saw_asconf_ack == 0))) {\n\t\treturn (-2);\n\t}\n\treturn (0);\n}\n\nvoid\nsctp_initialize_auth_params(struct sctp_inpcb *inp, struct sctp_tcb *stcb)\n{\n\tuint16_t chunks_len = 0;\n\tuint16_t hmacs_len = 0;\n\tuint16_t random_len = SCTP_AUTH_RANDOM_SIZE_DEFAULT;\n\tsctp_key_t *new_key;\n\tuint16_t keylen;\n\n\t/* initialize hmac list from endpoint */\n\tstcb->asoc.local_hmacs = sctp_copy_hmaclist(inp->sctp_ep.local_hmacs);\n\tif (stcb->asoc.local_hmacs != NULL) {\n\t\thmacs_len = stcb->asoc.local_hmacs->num_algo *\n\t\t    sizeof(stcb->asoc.local_hmacs->hmac[0]);\n\t}\n\t/* initialize auth chunks list from endpoint */\n\tstcb->asoc.local_auth_chunks =\n\t    sctp_copy_chunklist(inp->sctp_ep.local_auth_chunks);\n\tif (stcb->asoc.local_auth_chunks != NULL) {\n\t\tint i;\n\t\tfor (i = 0; i < 256; i++) {\n\t\t\tif (stcb->asoc.local_auth_chunks->chunks[i])\n\t\t\t\tchunks_len++;\n\t\t}\n\t}\n\t/* copy defaults from the endpoint */\n\tstcb->asoc.authinfo.active_keyid = inp->sctp_ep.default_keyid;\n\n\t/* copy out the shared key list (by reference) from the endpoint */\n\t(void)sctp_copy_skeylist(&inp->sctp_ep.shared_keys,\n\t\t\t\t &stcb->asoc.shared_keys);\n\n\t/* now set the concatenated key (random + chunks + hmacs) */\n\t/* key includes parameter headers */\n\tkeylen = (3 * sizeof(struct sctp_paramhdr)) + random_len + chunks_len +\n\t    hmacs_len;\n\tnew_key = sctp_alloc_key(keylen);\n\tif (new_key != NULL) {\n\t\tstruct sctp_paramhdr *ph;\n\t\tint plen;\n\t\t/* generate and copy in the RANDOM */\n\t\tph = (struct sctp_paramhdr *)new_key->key;\n\t\tph->param_type = htons(SCTP_RANDOM);\n\t\tplen = sizeof(*ph) + random_len;\n\t\tph->param_length = htons(plen);\n\t\tSCTP_READ_RANDOM(new_key->key + sizeof(*ph), random_len);\n\t\tkeylen = plen;\n\n\t\t/* append in the AUTH chunks */\n\t\t/* NOTE: currently we always have chunks to list */\n\t\tph = (struct sctp_paramhdr *)(new_key->key + keylen);\n\t\tph->param_type = htons(SCTP_CHUNK_LIST);\n\t\tplen = sizeof(*ph) + chunks_len;\n\t\tph->param_length = htons(plen);\n\t\tkeylen += sizeof(*ph);\n\t\tif (stcb->asoc.local_auth_chunks) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < 256; i++) {\n\t\t\t\tif (stcb->asoc.local_auth_chunks->chunks[i])\n\t\t\t\t\tnew_key->key[keylen++] = i;\n\t\t\t}\n\t\t}\n\n\t\t/* append in the HMACs */\n\t\tph = (struct sctp_paramhdr *)(new_key->key + keylen);\n\t\tph->param_type = htons(SCTP_HMAC_LIST);\n\t\tplen = sizeof(*ph) + hmacs_len;\n\t\tph->param_length = htons(plen);\n\t\tkeylen += sizeof(*ph);\n\t\t(void)sctp_serialize_hmaclist(stcb->asoc.local_hmacs,\n\t\t\t\t\tnew_key->key + keylen);\n\t}\n\tif (stcb->asoc.authinfo.random != NULL)\n\t    sctp_free_key(stcb->asoc.authinfo.random);\n\tstcb->asoc.authinfo.random = new_key;\n\tstcb->asoc.authinfo.random_len = random_len;\n}\n\n\n#ifdef SCTP_HMAC_TEST\n/*\n * HMAC and key concatenation tests\n */\nstatic void\nsctp_print_digest(uint8_t *digest, uint32_t digestlen, const char *str)\n{\n\tuint32_t i;\n\n\tSCTP_PRINTF(\"\\n%s: 0x\", str);\n\tif (digest == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < digestlen; i++)\n\t\tSCTP_PRINTF(\"%02x\", digest[i]);\n}\n\nstatic int\nsctp_test_hmac(const char *str, uint16_t hmac_id, uint8_t *key,\n    uint32_t keylen, uint8_t *text, uint32_t textlen,\n    uint8_t *digest, uint32_t digestlen)\n{\n\tuint8_t computed_digest[SCTP_AUTH_DIGEST_LEN_MAX];\n\n\tSCTP_PRINTF(\"\\n%s:\", str);\n\tsctp_hmac(hmac_id, key, keylen, text, textlen, computed_digest);\n\tsctp_print_digest(digest, digestlen, \"Expected digest\");\n\tsctp_print_digest(computed_digest, digestlen, \"Computed digest\");\n\tif (memcmp(digest, computed_digest, digestlen) != 0) {\n\t\tSCTP_PRINTF(\"\\nFAILED\");\n\t\treturn (-1);\n\t} else {\n\t\tSCTP_PRINTF(\"\\nPASSED\");\n\t\treturn (0);\n\t}\n}\n\n\n/*\n * RFC 2202: HMAC-SHA1 test cases\n */\nvoid\nsctp_test_hmac_sha1(void)\n{\n\tuint8_t *digest;\n\tuint8_t key[128];\n\tuint32_t keylen;\n\tuint8_t text[128];\n\tuint32_t textlen;\n\tuint32_t digestlen = 20;\n\tint failed = 0;\n\n\t/*-\n\t * test_case =     1\n\t * key =           0x0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b\n\t * key_len =       20\n\t * data =          \"Hi There\"\n\t * data_len =      8\n\t * digest =        0xb617318655057264e28bc0b6fb378c8ef146be00\n\t */\n\tkeylen = 20;\n\tmemset(key, 0x0b, keylen);\n\ttextlen = 8;\n\tstrcpy(text, \"Hi There\");\n\tdigest = \"\\xb6\\x17\\x31\\x86\\x55\\x05\\x72\\x64\\xe2\\x8b\\xc0\\xb6\\xfb\\x37\\x8c\\x8e\\xf1\\x46\\xbe\\x00\";\n\tif (sctp_test_hmac(\"SHA1 test case 1\", SCTP_AUTH_HMAC_ID_SHA1, key, keylen,\n\t    text, textlen, digest, digestlen) < 0)\n\t\tfailed++;\n\n\t/*-\n\t * test_case =     2\n\t * key =           \"Jefe\"\n\t * key_len =       4\n\t * data =          \"what do ya want for nothing?\"\n\t * data_len =      28\n\t * digest =        0xeffcdf6ae5eb2fa2d27416d5f184df9c259a7c79\n\t */\n\tkeylen = 4;\n\tstrcpy(key, \"Jefe\");\n\ttextlen = 28;\n\tstrcpy(text, \"what do ya want for nothing?\");\n\tdigest = \"\\xef\\xfc\\xdf\\x6a\\xe5\\xeb\\x2f\\xa2\\xd2\\x74\\x16\\xd5\\xf1\\x84\\xdf\\x9c\\x25\\x9a\\x7c\\x79\";\n\tif (sctp_test_hmac(\"SHA1 test case 2\", SCTP_AUTH_HMAC_ID_SHA1, key, keylen,\n\t    text, textlen, digest, digestlen) < 0)\n\t\tfailed++;\n\n\t/*-\n\t * test_case =     3\n\t * key =           0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\t * key_len =       20\n\t * data =          0xdd repeated 50 times\n\t * data_len =      50\n\t * digest =        0x125d7342b9ac11cd91a39af48aa17b4f63f175d3\n\t */\n\tkeylen = 20;\n\tmemset(key, 0xaa, keylen);\n\ttextlen = 50;\n\tmemset(text, 0xdd, textlen);\n\tdigest = \"\\x12\\x5d\\x73\\x42\\xb9\\xac\\x11\\xcd\\x91\\xa3\\x9a\\xf4\\x8a\\xa1\\x7b\\x4f\\x63\\xf1\\x75\\xd3\";\n\tif (sctp_test_hmac(\"SHA1 test case 3\", SCTP_AUTH_HMAC_ID_SHA1, key, keylen,\n\t    text, textlen, digest, digestlen) < 0)\n\t\tfailed++;\n\n\t/*-\n\t * test_case =     4\n\t * key =           0x0102030405060708090a0b0c0d0e0f10111213141516171819\n\t * key_len =       25\n\t * data =          0xcd repeated 50 times\n\t * data_len =      50\n\t * digest =        0x4c9007f4026250c6bc8414f9bf50c86c2d7235da\n\t */\n\tkeylen = 25;\n\tmemcpy(key, \"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\", keylen);\n\ttextlen = 50;\n\tmemset(text, 0xcd, textlen);\n\tdigest = \"\\x4c\\x90\\x07\\xf4\\x02\\x62\\x50\\xc6\\xbc\\x84\\x14\\xf9\\xbf\\x50\\xc8\\x6c\\x2d\\x72\\x35\\xda\";\n\tif (sctp_test_hmac(\"SHA1 test case 4\", SCTP_AUTH_HMAC_ID_SHA1, key, keylen,\n\t    text, textlen, digest, digestlen) < 0)\n\t\tfailed++;\n\n\t/*-\n\t * test_case =     5\n\t * key =           0x0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c\n\t * key_len =       20\n\t * data =          \"Test With Truncation\"\n\t * data_len =      20\n\t * digest =        0x4c1a03424b55e07fe7f27be1d58bb9324a9a5a04\n\t * digest-96 =     0x4c1a03424b55e07fe7f27be1\n\t */\n\tkeylen = 20;\n\tmemset(key, 0x0c, keylen);\n\ttextlen = 20;\n\tstrcpy(text, \"Test With Truncation\");\n\tdigest = \"\\x4c\\x1a\\x03\\x42\\x4b\\x55\\xe0\\x7f\\xe7\\xf2\\x7b\\xe1\\xd5\\x8b\\xb9\\x32\\x4a\\x9a\\x5a\\x04\";\n\tif (sctp_test_hmac(\"SHA1 test case 5\", SCTP_AUTH_HMAC_ID_SHA1, key, keylen,\n\t    text, textlen, digest, digestlen) < 0)\n\t\tfailed++;\n\n\t/*-\n\t * test_case =     6\n\t * key =           0xaa repeated 80 times\n\t * key_len =       80\n\t * data =          \"Test Using Larger Than Block-Size Key - Hash Key First\"\n\t * data_len =      54\n\t * digest =        0xaa4ae5e15272d00e95705637ce8a3b55ed402112\n\t */\n\tkeylen = 80;\n\tmemset(key, 0xaa, keylen);\n\ttextlen = 54;\n\tstrcpy(text, \"Test Using Larger Than Block-Size Key - Hash Key First\");\n\tdigest = \"\\xaa\\x4a\\xe5\\xe1\\x52\\x72\\xd0\\x0e\\x95\\x70\\x56\\x37\\xce\\x8a\\x3b\\x55\\xed\\x40\\x21\\x12\";\n\tif (sctp_test_hmac(\"SHA1 test case 6\", SCTP_AUTH_HMAC_ID_SHA1, key, keylen,\n\t    text, textlen, digest, digestlen) < 0)\n\t\tfailed++;\n\n\t/*-\n\t * test_case =     7\n\t * key =           0xaa repeated 80 times\n\t * key_len =       80\n\t * data =          \"Test Using Larger Than Block-Size Key and Larger Than One Block-Size Data\"\n\t * data_len =      73\n\t * digest =        0xe8e99d0f45237d786d6bbaa7965c7808bbff1a91\n\t */\n\tkeylen = 80;\n\tmemset(key, 0xaa, keylen);\n\ttextlen = 73;\n\tstrcpy(text, \"Test Using Larger Than Block-Size Key and Larger Than One Block-Size Data\");\n\tdigest = \"\\xe8\\xe9\\x9d\\x0f\\x45\\x23\\x7d\\x78\\x6d\\x6b\\xba\\xa7\\x96\\x5c\\x78\\x08\\xbb\\xff\\x1a\\x91\";\n\tif (sctp_test_hmac(\"SHA1 test case 7\", SCTP_AUTH_HMAC_ID_SHA1, key, keylen,\n\t    text, textlen, digest, digestlen) < 0)\n\t\tfailed++;\n\n\t/* done with all tests */\n\tif (failed)\n\t\tSCTP_PRINTF(\"\\nSHA1 test results: %d cases failed\", failed);\n\telse\n\t\tSCTP_PRINTF(\"\\nSHA1 test results: all test cases passed\");\n}\n\n/*\n * test assoc key concatenation\n */\nstatic int\nsctp_test_key_concatenation(sctp_key_t *key1, sctp_key_t *key2,\n    sctp_key_t *expected_key)\n{\n\tsctp_key_t *key;\n\tint ret_val;\n\n\tsctp_show_key(key1, \"\\nkey1\");\n\tsctp_show_key(key2, \"\\nkey2\");\n\tkey = sctp_compute_hashkey(key1, key2, NULL);\n\tsctp_show_key(expected_key, \"\\nExpected\");\n\tsctp_show_key(key, \"\\nComputed\");\n\tif (memcmp(key, expected_key, expected_key->keylen) != 0) {\n\t\tSCTP_PRINTF(\"\\nFAILED\");\n\t\tret_val = -1;\n\t} else {\n\t\tSCTP_PRINTF(\"\\nPASSED\");\n\t\tret_val = 0;\n\t}\n\tsctp_free_key(key1);\n\tsctp_free_key(key2);\n\tsctp_free_key(expected_key);\n\tsctp_free_key(key);\n\treturn (ret_val);\n}\n\n\nvoid\nsctp_test_authkey(void)\n{\n\tsctp_key_t *key1, *key2, *expected_key;\n\tint failed = 0;\n\n\t/* test case 1 */\n\tkey1 = sctp_set_key(\"\\x01\\x01\\x01\\x01\", 4);\n\tkey2 = sctp_set_key(\"\\x01\\x02\\x03\\x04\", 4);\n\texpected_key = sctp_set_key(\"\\x01\\x01\\x01\\x01\\x01\\x02\\x03\\x04\", 8);\n\tif (sctp_test_key_concatenation(key1, key2, expected_key) < 0)\n\t\tfailed++;\n\n\t/* test case 2 */\n\tkey1 = sctp_set_key(\"\\x00\\x00\\x00\\x01\", 4);\n\tkey2 = sctp_set_key(\"\\x02\", 1);\n\texpected_key = sctp_set_key(\"\\x00\\x00\\x00\\x01\\x02\", 5);\n\tif (sctp_test_key_concatenation(key1, key2, expected_key) < 0)\n\t\tfailed++;\n\n\t/* test case 3 */\n\tkey1 = sctp_set_key(\"\\x01\", 1);\n\tkey2 = sctp_set_key(\"\\x00\\x00\\x00\\x02\", 4);\n\texpected_key = sctp_set_key(\"\\x01\\x00\\x00\\x00\\x02\", 5);\n\tif (sctp_test_key_concatenation(key1, key2, expected_key) < 0)\n\t\tfailed++;\n\n\t/* test case 4 */\n\tkey1 = sctp_set_key(\"\\x00\\x00\\x00\\x01\", 4);\n\tkey2 = sctp_set_key(\"\\x01\", 1);\n\texpected_key = sctp_set_key(\"\\x01\\x00\\x00\\x00\\x01\", 5);\n\tif (sctp_test_key_concatenation(key1, key2, expected_key) < 0)\n\t\tfailed++;\n\n\t/* test case 5 */\n\tkey1 = sctp_set_key(\"\\x01\", 1);\n\tkey2 = sctp_set_key(\"\\x00\\x00\\x00\\x01\", 4);\n\texpected_key = sctp_set_key(\"\\x01\\x00\\x00\\x00\\x01\", 5);\n\tif (sctp_test_key_concatenation(key1, key2, expected_key) < 0)\n\t\tfailed++;\n\n\t/* test case 6 */\n\tkey1 = sctp_set_key(\"\\x00\\x00\\x00\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\", 11);\n\tkey2 = sctp_set_key(\"\\x00\\x00\\x00\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x08\", 11);\n\texpected_key = sctp_set_key(\"\\x00\\x00\\x00\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x00\\x00\\x00\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x08\", 22);\n\tif (sctp_test_key_concatenation(key1, key2, expected_key) < 0)\n\t\tfailed++;\n\n\t/* test case 7 */\n\tkey1 = sctp_set_key(\"\\x00\\x00\\x00\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x08\", 11);\n\tkey2 = sctp_set_key(\"\\x00\\x00\\x00\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\", 11);\n\texpected_key = sctp_set_key(\"\\x00\\x00\\x00\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x00\\x00\\x00\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x08\", 22);\n\tif (sctp_test_key_concatenation(key1, key2, expected_key) < 0)\n\t\tfailed++;\n\n\t/* done with all tests */\n\tif (failed)\n\t\tSCTP_PRINTF(\"\\nKey concatenation test results: %d cases failed\", failed);\n\telse\n\t\tSCTP_PRINTF(\"\\nKey concatenation test results: all test cases passed\");\n}\n\n\n#if defined(STANDALONE_HMAC_TEST)\nint\nmain(void)\n{\n\tsctp_test_hmac_sha1();\n\tsctp_test_authkey();\n}\n\n#endif /* STANDALONE_HMAC_TEST */\n\n#endif /* SCTP_HMAC_TEST */\n", "/*-\n * SPDX-License-Identifier: BSD-3-Clause\n *\n * Copyright (c) 2001-2008, by Cisco Systems, Inc. All rights reserved.\n * Copyright (c) 2008-2012, by Randall Stewart. All rights reserved.\n * Copyright (c) 2008-2012, by Michael Tuexen. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * a) Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *\n * b) Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the distribution.\n *\n * c) Neither the name of Cisco Systems, Inc. nor the names of its\n *    contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifdef __FreeBSD__\n#include <sys/cdefs.h>\n__FBSDID(\"$FreeBSD: head/sys/netinet/sctp_pcb.c 353477 2019-10-13 16:14:04Z markj $\");\n#endif\n\n#include <netinet/sctp_os.h>\n#ifdef __FreeBSD__\n#include <sys/proc.h>\n#endif\n#include <netinet/sctp_var.h>\n#include <netinet/sctp_sysctl.h>\n#include <netinet/sctp_pcb.h>\n#include <netinet/sctputil.h>\n#include <netinet/sctp.h>\n#include <netinet/sctp_header.h>\n#include <netinet/sctp_asconf.h>\n#include <netinet/sctp_output.h>\n#include <netinet/sctp_timer.h>\n#include <netinet/sctp_bsd_addr.h>\n#if defined(INET) || defined(INET6)\n#if !defined(__Userspace_os_Windows)\n#include <netinet/udp.h>\n#endif\n#endif\n#ifdef INET6\n#if defined(__Userspace__)\n#include \"user_ip6_var.h\"\n#else\n#include <netinet6/ip6_var.h>\n#endif\n#endif\n#if defined(__FreeBSD__)\n#include <sys/sched.h>\n#include <sys/smp.h>\n#include <sys/unistd.h>\n#endif\n#if defined(__Userspace__)\n#include <user_socketvar.h>\n#include <user_atomic.h>\n#if !defined(__Userspace_os_Windows)\n#include <netdb.h>\n#endif\n#endif\n\n#if defined(__APPLE__)\n#define APPLE_FILE_NO 4\n#endif\n\n#if defined(__FreeBSD__) && __FreeBSD_version >= 801000\nVNET_DEFINE(struct sctp_base_info, system_base_info);\n#else\nstruct sctp_base_info system_base_info;\n#endif\n\n/* FIX: we don't handle multiple link local scopes */\n/* \"scopeless\" replacement IN6_ARE_ADDR_EQUAL */\n#ifdef INET6\nint\nSCTP6_ARE_ADDR_EQUAL(struct sockaddr_in6 *a, struct sockaddr_in6 *b)\n{\n#ifdef SCTP_EMBEDDED_V6_SCOPE\n#if defined(__APPLE__)\n\tstruct in6_addr tmp_a, tmp_b;\n\n\ttmp_a = a->sin6_addr;\n#if defined(APPLE_LEOPARD) || defined(APPLE_SNOWLEOPARD)\n\tif (in6_embedscope(&tmp_a, a, NULL, NULL) != 0) {\n#else\n\tif (in6_embedscope(&tmp_a, a, NULL, NULL, NULL) != 0) {\n#endif\n\t\treturn (0);\n\t}\n\ttmp_b = b->sin6_addr;\n#if defined(APPLE_LEOPARD) || defined(APPLE_SNOWLEOPARD)\n\tif (in6_embedscope(&tmp_b, b, NULL, NULL) != 0) {\n#else\n\tif (in6_embedscope(&tmp_b, b, NULL, NULL, NULL) != 0) {\n#endif\n\t\treturn (0);\n\t}\n\treturn (IN6_ARE_ADDR_EQUAL(&tmp_a, &tmp_b));\n#elif defined(SCTP_KAME)\n\tstruct sockaddr_in6 tmp_a, tmp_b;\n\n\tmemcpy(&tmp_a, a, sizeof(struct sockaddr_in6));\n\tif (sa6_embedscope(&tmp_a, MODULE_GLOBAL(ip6_use_defzone)) != 0) {\n\t\treturn (0);\n\t}\n\tmemcpy(&tmp_b, b, sizeof(struct sockaddr_in6));\n\tif (sa6_embedscope(&tmp_b, MODULE_GLOBAL(ip6_use_defzone)) != 0) {\n\t\treturn (0);\n\t}\n\treturn (IN6_ARE_ADDR_EQUAL(&tmp_a.sin6_addr, &tmp_b.sin6_addr));\n#else\n\tstruct in6_addr tmp_a, tmp_b;\n\n\ttmp_a = a->sin6_addr;\n\tif (in6_embedscope(&tmp_a, a) != 0) {\n\t\treturn (0);\n\t}\n\ttmp_b = b->sin6_addr;\n\tif (in6_embedscope(&tmp_b, b) != 0) {\n\t\treturn (0);\n\t}\n\treturn (IN6_ARE_ADDR_EQUAL(&tmp_a, &tmp_b));\n#endif\n#else\n\treturn (IN6_ARE_ADDR_EQUAL(&(a->sin6_addr), &(b->sin6_addr)));\n#endif /* SCTP_EMBEDDED_V6_SCOPE */\n}\n#endif\n\nvoid\nsctp_fill_pcbinfo(struct sctp_pcbinfo *spcb)\n{\n\t/*\n\t * We really don't need to lock this, but I will just because it\n\t * does not hurt.\n\t */\n\tSCTP_INP_INFO_RLOCK();\n\tspcb->ep_count = SCTP_BASE_INFO(ipi_count_ep);\n\tspcb->asoc_count = SCTP_BASE_INFO(ipi_count_asoc);\n\tspcb->laddr_count = SCTP_BASE_INFO(ipi_count_laddr);\n\tspcb->raddr_count = SCTP_BASE_INFO(ipi_count_raddr);\n\tspcb->chk_count = SCTP_BASE_INFO(ipi_count_chunk);\n\tspcb->readq_count = SCTP_BASE_INFO(ipi_count_readq);\n\tspcb->stream_oque = SCTP_BASE_INFO(ipi_count_strmoq);\n\tspcb->free_chunks = SCTP_BASE_INFO(ipi_free_chunks);\n\tSCTP_INP_INFO_RUNLOCK();\n}\n\n/*-\n * Addresses are added to VRF's (Virtual Router's). For BSD we\n * have only the default VRF 0. We maintain a hash list of\n * VRF's. Each VRF has its own list of sctp_ifn's. Each of\n * these has a list of addresses. When we add a new address\n * to a VRF we lookup the ifn/ifn_index, if the ifn does\n * not exist we create it and add it to the list of IFN's\n * within the VRF. Once we have the sctp_ifn, we add the\n * address to the list. So we look something like:\n *\n * hash-vrf-table\n *   vrf-> ifn-> ifn -> ifn\n *   vrf    |\n *    ...   +--ifa-> ifa -> ifa\n *   vrf\n *\n * We keep these separate lists since the SCTP subsystem will\n * point to these from its source address selection nets structure.\n * When an address is deleted it does not happen right away on\n * the SCTP side, it gets scheduled. What we do when a\n * delete happens is immediately remove the address from\n * the master list and decrement the refcount. As our\n * addip iterator works through and frees the src address\n * selection pointing to the sctp_ifa, eventually the refcount\n * will reach 0 and we will delete it. Note that it is assumed\n * that any locking on system level ifn/ifa is done at the\n * caller of these functions and these routines will only\n * lock the SCTP structures as they add or delete things.\n *\n * Other notes on VRF concepts.\n *  - An endpoint can be in multiple VRF's\n *  - An association lives within a VRF and only one VRF.\n *  - Any incoming packet we can deduce the VRF for by\n *    looking at the mbuf/pak inbound (for BSD its VRF=0 :D)\n *  - Any downward send call or connect call must supply the\n *    VRF via ancillary data or via some sort of set default\n *    VRF socket option call (again for BSD no brainer since\n *    the VRF is always 0).\n *  - An endpoint may add multiple VRF's to it.\n *  - Listening sockets can accept associations in any\n *    of the VRF's they are in but the assoc will end up\n *    in only one VRF (gotten from the packet or connect/send).\n *\n */\n\nstruct sctp_vrf *\nsctp_allocate_vrf(int vrf_id)\n{\n\tstruct sctp_vrf *vrf = NULL;\n\tstruct sctp_vrflist *bucket;\n\n\t/* First allocate the VRF structure */\n\tvrf = sctp_find_vrf(vrf_id);\n\tif (vrf) {\n\t\t/* Already allocated */\n\t\treturn (vrf);\n\t}\n\tSCTP_MALLOC(vrf, struct sctp_vrf *, sizeof(struct sctp_vrf),\n\t\t    SCTP_M_VRF);\n\tif (vrf == NULL) {\n\t\t/* No memory */\n#ifdef INVARIANTS\n\t\tpanic(\"No memory for VRF:%d\", vrf_id);\n#endif\n\t\treturn (NULL);\n\t}\n\t/* setup the VRF */\n\tmemset(vrf, 0, sizeof(struct sctp_vrf));\n\tvrf->vrf_id = vrf_id;\n\tLIST_INIT(&vrf->ifnlist);\n\tvrf->total_ifa_count = 0;\n\tvrf->refcount = 0;\n\t/* now also setup table ids */\n\tSCTP_INIT_VRF_TABLEID(vrf);\n\t/* Init the HASH of addresses */\n\tvrf->vrf_addr_hash = SCTP_HASH_INIT(SCTP_VRF_ADDR_HASH_SIZE,\n\t\t\t\t\t    &vrf->vrf_addr_hashmark);\n\tif (vrf->vrf_addr_hash == NULL) {\n\t\t/* No memory */\n#ifdef INVARIANTS\n\t\tpanic(\"No memory for VRF:%d\", vrf_id);\n#endif\n\t\tSCTP_FREE(vrf, SCTP_M_VRF);\n\t\treturn (NULL);\n\t}\n\n\t/* Add it to the hash table */\n\tbucket = &SCTP_BASE_INFO(sctp_vrfhash)[(vrf_id & SCTP_BASE_INFO(hashvrfmark))];\n\tLIST_INSERT_HEAD(bucket, vrf, next_vrf);\n\tatomic_add_int(&SCTP_BASE_INFO(ipi_count_vrfs), 1);\n\treturn (vrf);\n}\n\n\nstruct sctp_ifn *\nsctp_find_ifn(void *ifn, uint32_t ifn_index)\n{\n\tstruct sctp_ifn *sctp_ifnp;\n\tstruct sctp_ifnlist *hash_ifn_head;\n\n\t/* We assume the lock is held for the addresses\n\t * if that's wrong problems could occur :-)\n\t */\n\thash_ifn_head = &SCTP_BASE_INFO(vrf_ifn_hash)[(ifn_index & SCTP_BASE_INFO(vrf_ifn_hashmark))];\n\tLIST_FOREACH(sctp_ifnp, hash_ifn_head, next_bucket) {\n\t\tif (sctp_ifnp->ifn_index == ifn_index) {\n\t\t\treturn (sctp_ifnp);\n\t\t}\n\t\tif (sctp_ifnp->ifn_p && ifn && (sctp_ifnp->ifn_p == ifn)) {\n\t\t\treturn (sctp_ifnp);\n\t\t}\n\t}\n\treturn (NULL);\n}\n\n\nstruct sctp_vrf *\nsctp_find_vrf(uint32_t vrf_id)\n{\n\tstruct sctp_vrflist *bucket;\n\tstruct sctp_vrf *liste;\n\n\tbucket = &SCTP_BASE_INFO(sctp_vrfhash)[(vrf_id & SCTP_BASE_INFO(hashvrfmark))];\n\tLIST_FOREACH(liste, bucket, next_vrf) {\n\t\tif (vrf_id == liste->vrf_id) {\n\t\t\treturn (liste);\n\t\t}\n\t}\n\treturn (NULL);\n}\n\n\nvoid\nsctp_free_vrf(struct sctp_vrf *vrf)\n{\n\tif (SCTP_DECREMENT_AND_CHECK_REFCOUNT(&vrf->refcount)) {\n                if (vrf->vrf_addr_hash) {\n                    SCTP_HASH_FREE(vrf->vrf_addr_hash, vrf->vrf_addr_hashmark);\n                    vrf->vrf_addr_hash = NULL;\n                }\n\t\t/* We zero'd the count */\n\t\tLIST_REMOVE(vrf, next_vrf);\n\t\tSCTP_FREE(vrf, SCTP_M_VRF);\n\t\tatomic_subtract_int(&SCTP_BASE_INFO(ipi_count_vrfs), 1);\n\t}\n}\n\n\nvoid\nsctp_free_ifn(struct sctp_ifn *sctp_ifnp)\n{\n\tif (SCTP_DECREMENT_AND_CHECK_REFCOUNT(&sctp_ifnp->refcount)) {\n\t\t/* We zero'd the count */\n\t\tif (sctp_ifnp->vrf) {\n\t\t\tsctp_free_vrf(sctp_ifnp->vrf);\n\t\t}\n\t\tSCTP_FREE(sctp_ifnp, SCTP_M_IFN);\n\t\tatomic_subtract_int(&SCTP_BASE_INFO(ipi_count_ifns), 1);\n\t}\n}\n\n\nvoid\nsctp_update_ifn_mtu(uint32_t ifn_index, uint32_t mtu)\n{\n\tstruct sctp_ifn *sctp_ifnp;\n\n\tsctp_ifnp = sctp_find_ifn((void *)NULL, ifn_index);\n\tif (sctp_ifnp != NULL) {\n\t\tsctp_ifnp->ifn_mtu = mtu;\n\t}\n}\n\n\nvoid\nsctp_free_ifa(struct sctp_ifa *sctp_ifap)\n{\n\tif (SCTP_DECREMENT_AND_CHECK_REFCOUNT(&sctp_ifap->refcount)) {\n\t\t/* We zero'd the count */\n\t\tif (sctp_ifap->ifn_p) {\n\t\t\tsctp_free_ifn(sctp_ifap->ifn_p);\n\t\t}\n\t\tSCTP_FREE(sctp_ifap, SCTP_M_IFA);\n\t\tatomic_subtract_int(&SCTP_BASE_INFO(ipi_count_ifas), 1);\n\t}\n}\n\n\nstatic void\nsctp_delete_ifn(struct sctp_ifn *sctp_ifnp, int hold_addr_lock)\n{\n\tstruct sctp_ifn *found;\n\n\tfound = sctp_find_ifn(sctp_ifnp->ifn_p, sctp_ifnp->ifn_index);\n\tif (found == NULL) {\n\t\t/* Not in the list.. sorry */\n\t\treturn;\n\t}\n\tif (hold_addr_lock == 0)\n\t\tSCTP_IPI_ADDR_WLOCK();\n\tLIST_REMOVE(sctp_ifnp, next_bucket);\n\tLIST_REMOVE(sctp_ifnp, next_ifn);\n\tSCTP_DEREGISTER_INTERFACE(sctp_ifnp->ifn_index,\n\t\t\t\t  sctp_ifnp->registered_af);\n\tif (hold_addr_lock == 0)\n\t\tSCTP_IPI_ADDR_WUNLOCK();\n\t/* Take away the reference, and possibly free it */\n\tsctp_free_ifn(sctp_ifnp);\n}\n\n\nvoid\nsctp_mark_ifa_addr_down(uint32_t vrf_id, struct sockaddr *addr,\n\t\t\tconst char *if_name, uint32_t ifn_index)\n{\n\tstruct sctp_vrf *vrf;\n\tstruct sctp_ifa *sctp_ifap;\n\n\tSCTP_IPI_ADDR_RLOCK();\n\tvrf = sctp_find_vrf(vrf_id);\n\tif (vrf == NULL) {\n\t\tSCTPDBG(SCTP_DEBUG_PCB4, \"Can't find vrf_id 0x%x\\n\", vrf_id);\n\t\tgoto out;\n\n\t}\n\tsctp_ifap = sctp_find_ifa_by_addr(addr, vrf->vrf_id, SCTP_ADDR_LOCKED);\n\tif (sctp_ifap == NULL) {\n\t\tSCTPDBG(SCTP_DEBUG_PCB4, \"Can't find sctp_ifap for address\\n\");\n\t\tgoto out;\n\t}\n\tif (sctp_ifap->ifn_p == NULL) {\n\t\tSCTPDBG(SCTP_DEBUG_PCB4, \"IFA has no IFN - can't mark unusable\\n\");\n\t\tgoto out;\n\t}\n\tif (if_name) {\n\t\tif (strncmp(if_name, sctp_ifap->ifn_p->ifn_name, SCTP_IFNAMSIZ) != 0) {\n\t\t\tSCTPDBG(SCTP_DEBUG_PCB4, \"IFN %s of IFA not the same as %s\\n\",\n\t\t\t\tsctp_ifap->ifn_p->ifn_name, if_name);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tif (sctp_ifap->ifn_p->ifn_index != ifn_index) {\n\t\t\tSCTPDBG(SCTP_DEBUG_PCB4, \"IFA owned by ifn_index:%d down command for ifn_index:%d - ignored\\n\",\n\t\t\t\tsctp_ifap->ifn_p->ifn_index, ifn_index);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tsctp_ifap->localifa_flags &= (~SCTP_ADDR_VALID);\n\tsctp_ifap->localifa_flags |= SCTP_ADDR_IFA_UNUSEABLE;\n out:\n\tSCTP_IPI_ADDR_RUNLOCK();\n}\n\n\nvoid\nsctp_mark_ifa_addr_up(uint32_t vrf_id, struct sockaddr *addr,\n\t\t      const char *if_name, uint32_t ifn_index)\n{\n\tstruct sctp_vrf *vrf;\n\tstruct sctp_ifa *sctp_ifap;\n\n\tSCTP_IPI_ADDR_RLOCK();\n\tvrf = sctp_find_vrf(vrf_id);\n\tif (vrf == NULL) {\n\t\tSCTPDBG(SCTP_DEBUG_PCB4, \"Can't find vrf_id 0x%x\\n\", vrf_id);\n\t\tgoto out;\n\n\t}\n\tsctp_ifap = sctp_find_ifa_by_addr(addr, vrf->vrf_id, SCTP_ADDR_LOCKED);\n\tif (sctp_ifap == NULL) {\n\t\tSCTPDBG(SCTP_DEBUG_PCB4, \"Can't find sctp_ifap for address\\n\");\n\t\tgoto out;\n\t}\n\tif (sctp_ifap->ifn_p == NULL) {\n\t\tSCTPDBG(SCTP_DEBUG_PCB4, \"IFA has no IFN - can't mark unusable\\n\");\n\t\tgoto out;\n\t}\n\tif (if_name) {\n\t\tif (strncmp(if_name, sctp_ifap->ifn_p->ifn_name, SCTP_IFNAMSIZ) != 0) {\n\t\t\tSCTPDBG(SCTP_DEBUG_PCB4, \"IFN %s of IFA not the same as %s\\n\",\n\t\t\t\tsctp_ifap->ifn_p->ifn_name, if_name);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tif (sctp_ifap->ifn_p->ifn_index != ifn_index) {\n\t\t\tSCTPDBG(SCTP_DEBUG_PCB4, \"IFA owned by ifn_index:%d down command for ifn_index:%d - ignored\\n\",\n\t\t\t\tsctp_ifap->ifn_p->ifn_index, ifn_index);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tsctp_ifap->localifa_flags &= (~SCTP_ADDR_IFA_UNUSEABLE);\n\tsctp_ifap->localifa_flags |= SCTP_ADDR_VALID;\n out:\n\tSCTP_IPI_ADDR_RUNLOCK();\n}\n\n\n/*-\n * Add an ifa to an ifn.\n * Register the interface as necessary.\n * NOTE: ADDR write lock MUST be held.\n */\nstatic void\nsctp_add_ifa_to_ifn(struct sctp_ifn *sctp_ifnp, struct sctp_ifa *sctp_ifap)\n{\n\tint ifa_af;\n\n\tLIST_INSERT_HEAD(&sctp_ifnp->ifalist, sctp_ifap, next_ifa);\n\tsctp_ifap->ifn_p = sctp_ifnp;\n\tatomic_add_int(&sctp_ifap->ifn_p->refcount, 1);\n\t/* update address counts */\n\tsctp_ifnp->ifa_count++;\n\tifa_af = sctp_ifap->address.sa.sa_family;\n\tswitch (ifa_af) {\n#ifdef INET\n\tcase AF_INET:\n\t\tsctp_ifnp->num_v4++;\n\t\tbreak;\n#endif\n#ifdef INET6\n\tcase AF_INET6:\n\t\tsctp_ifnp->num_v6++;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sctp_ifnp->ifa_count == 1) {\n\t\t/* register the new interface */\n\t\tSCTP_REGISTER_INTERFACE(sctp_ifnp->ifn_index, ifa_af);\n\t\tsctp_ifnp->registered_af = ifa_af;\n\t}\n}\n\n\n/*-\n * Remove an ifa from its ifn.\n * If no more addresses exist, remove the ifn too. Otherwise, re-register\n * the interface based on the remaining address families left.\n * NOTE: ADDR write lock MUST be held.\n */\nstatic void\nsctp_remove_ifa_from_ifn(struct sctp_ifa *sctp_ifap)\n{\n\tLIST_REMOVE(sctp_ifap, next_ifa);\n\tif (sctp_ifap->ifn_p) {\n\t\t/* update address counts */\n\t\tsctp_ifap->ifn_p->ifa_count--;\n\t\tswitch (sctp_ifap->address.sa.sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tsctp_ifap->ifn_p->num_v4--;\n\t\t\tbreak;\n#endif\n#ifdef INET6\n\t\tcase AF_INET6:\n\t\t\tsctp_ifap->ifn_p->num_v6--;\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (LIST_EMPTY(&sctp_ifap->ifn_p->ifalist)) {\n\t\t\t/* remove the ifn, possibly freeing it */\n\t\t\tsctp_delete_ifn(sctp_ifap->ifn_p, SCTP_ADDR_LOCKED);\n\t\t} else {\n\t\t\t/* re-register address family type, if needed */\n\t\t\tif ((sctp_ifap->ifn_p->num_v6 == 0) &&\n\t\t\t    (sctp_ifap->ifn_p->registered_af == AF_INET6)) {\n\t\t\t\tSCTP_DEREGISTER_INTERFACE(sctp_ifap->ifn_p->ifn_index, AF_INET6);\n\t\t\t\tSCTP_REGISTER_INTERFACE(sctp_ifap->ifn_p->ifn_index, AF_INET);\n\t\t\t\tsctp_ifap->ifn_p->registered_af = AF_INET;\n\t\t\t} else if ((sctp_ifap->ifn_p->num_v4 == 0) &&\n\t\t\t\t   (sctp_ifap->ifn_p->registered_af == AF_INET)) {\n\t\t\t\tSCTP_DEREGISTER_INTERFACE(sctp_ifap->ifn_p->ifn_index, AF_INET);\n\t\t\t\tSCTP_REGISTER_INTERFACE(sctp_ifap->ifn_p->ifn_index, AF_INET6);\n\t\t\t\tsctp_ifap->ifn_p->registered_af = AF_INET6;\n\t\t\t}\n\t\t\t/* free the ifn refcount */\n\t\t\tsctp_free_ifn(sctp_ifap->ifn_p);\n\t\t}\n\t\tsctp_ifap->ifn_p = NULL;\n\t}\n}\n\n\nstruct sctp_ifa *\nsctp_add_addr_to_vrf(uint32_t vrf_id, void *ifn, uint32_t ifn_index,\n\t\t     uint32_t ifn_type, const char *if_name, void *ifa,\n\t\t     struct sockaddr *addr, uint32_t ifa_flags,\n\t\t     int dynamic_add)\n{\n\tstruct sctp_vrf *vrf;\n\tstruct sctp_ifn *sctp_ifnp = NULL;\n\tstruct sctp_ifa *sctp_ifap = NULL;\n\tstruct sctp_ifalist *hash_addr_head;\n\tstruct sctp_ifnlist *hash_ifn_head;\n\tuint32_t hash_of_addr;\n\tint new_ifn_af = 0;\n\n#ifdef SCTP_DEBUG\n\tSCTPDBG(SCTP_DEBUG_PCB4, \"vrf_id 0x%x: adding address: \", vrf_id);\n\tSCTPDBG_ADDR(SCTP_DEBUG_PCB4, addr);\n#endif\n\tSCTP_IPI_ADDR_WLOCK();\n\tsctp_ifnp = sctp_find_ifn(ifn, ifn_index);\n\tif (sctp_ifnp) {\n\t\tvrf = sctp_ifnp->vrf;\n\t} else {\n\t\tvrf = sctp_find_vrf(vrf_id);\n\t\tif (vrf == NULL) {\n\t\t\tvrf = sctp_allocate_vrf(vrf_id);\n\t\t\tif (vrf == NULL) {\n\t\t\t\tSCTP_IPI_ADDR_WUNLOCK();\n\t\t\t\treturn (NULL);\n\t\t\t}\n\t\t}\n\t}\n\tif (sctp_ifnp == NULL) {\n\t\t/* build one and add it, can't hold lock\n\t\t * until after malloc done though.\n\t\t */\n\t\tSCTP_IPI_ADDR_WUNLOCK();\n\t\tSCTP_MALLOC(sctp_ifnp, struct sctp_ifn *,\n\t\t\t    sizeof(struct sctp_ifn), SCTP_M_IFN);\n\t\tif (sctp_ifnp == NULL) {\n#ifdef INVARIANTS\n\t\t\tpanic(\"No memory for IFN\");\n#endif\n\t\t\treturn (NULL);\n\t\t}\n\t\tmemset(sctp_ifnp, 0, sizeof(struct sctp_ifn));\n\t\tsctp_ifnp->ifn_index = ifn_index;\n\t\tsctp_ifnp->ifn_p = ifn;\n\t\tsctp_ifnp->ifn_type = ifn_type;\n\t\tsctp_ifnp->refcount = 0;\n\t\tsctp_ifnp->vrf = vrf;\n\t\tatomic_add_int(&vrf->refcount, 1);\n\t\tsctp_ifnp->ifn_mtu = SCTP_GATHER_MTU_FROM_IFN_INFO(ifn, ifn_index, addr->sa_family);\n\t\tif (if_name != NULL) {\n\t\t\tsnprintf(sctp_ifnp->ifn_name, SCTP_IFNAMSIZ, \"%s\", if_name);\n\t\t} else {\n\t\t\tsnprintf(sctp_ifnp->ifn_name, SCTP_IFNAMSIZ, \"%s\", \"unknown\");\n\t\t}\n\t\thash_ifn_head = &SCTP_BASE_INFO(vrf_ifn_hash)[(ifn_index & SCTP_BASE_INFO(vrf_ifn_hashmark))];\n\t\tLIST_INIT(&sctp_ifnp->ifalist);\n\t\tSCTP_IPI_ADDR_WLOCK();\n\t\tLIST_INSERT_HEAD(hash_ifn_head, sctp_ifnp, next_bucket);\n\t\tLIST_INSERT_HEAD(&vrf->ifnlist, sctp_ifnp, next_ifn);\n\t\tatomic_add_int(&SCTP_BASE_INFO(ipi_count_ifns), 1);\n\t\tnew_ifn_af = 1;\n\t}\n\tsctp_ifap = sctp_find_ifa_by_addr(addr, vrf->vrf_id, SCTP_ADDR_LOCKED);\n\tif (sctp_ifap) {\n\t\t/* Hmm, it already exists? */\n\t\tif ((sctp_ifap->ifn_p) &&\n\t\t    (sctp_ifap->ifn_p->ifn_index == ifn_index)) {\n\t\t\tSCTPDBG(SCTP_DEBUG_PCB4, \"Using existing ifn %s (0x%x) for ifa %p\\n\",\n\t\t\t\tsctp_ifap->ifn_p->ifn_name, ifn_index,\n\t\t\t\t(void *)sctp_ifap);\n\t\t\tif (new_ifn_af) {\n\t\t\t\t/* Remove the created one that we don't want */\n\t\t\t\tsctp_delete_ifn(sctp_ifnp, SCTP_ADDR_LOCKED);\n\t\t\t}\n\t\t\tif (sctp_ifap->localifa_flags & SCTP_BEING_DELETED) {\n\t\t\t\t/* easy to solve, just switch back to active */\n\t\t\t\tSCTPDBG(SCTP_DEBUG_PCB4, \"Clearing deleted ifa flag\\n\");\n\t\t\t\tsctp_ifap->localifa_flags = SCTP_ADDR_VALID;\n\t\t\t\tsctp_ifap->ifn_p = sctp_ifnp;\n\t\t\t\tatomic_add_int(&sctp_ifap->ifn_p->refcount, 1);\n\t\t\t}\n\t\texit_stage_left:\n\t\t\tSCTP_IPI_ADDR_WUNLOCK();\n\t\t\treturn (sctp_ifap);\n\t\t} else {\n\t\t\tif (sctp_ifap->ifn_p) {\n\t\t\t\t/*\n\t\t\t\t * The last IFN gets the address, remove the\n\t\t\t\t * old one\n\t\t\t\t */\n\t\t\t\tSCTPDBG(SCTP_DEBUG_PCB4, \"Moving ifa %p from %s (0x%x) to %s (0x%x)\\n\",\n\t\t\t\t\t(void *)sctp_ifap, sctp_ifap->ifn_p->ifn_name,\n\t\t\t\t\tsctp_ifap->ifn_p->ifn_index, if_name,\n\t\t\t\t\tifn_index);\n\t\t\t\t/* remove the address from the old ifn */\n\t\t\t\tsctp_remove_ifa_from_ifn(sctp_ifap);\n\t\t\t\t/* move the address over to the new ifn */\n\t\t\t\tsctp_add_ifa_to_ifn(sctp_ifnp, sctp_ifap);\n\t\t\t\tgoto exit_stage_left;\n\t\t\t} else {\n\t\t\t\t/* repair ifnp which was NULL ? */\n\t\t\t\tsctp_ifap->localifa_flags = SCTP_ADDR_VALID;\n\t\t\t\tSCTPDBG(SCTP_DEBUG_PCB4, \"Repairing ifn %p for ifa %p\\n\",\n\t\t\t\t\t(void *)sctp_ifnp, (void *)sctp_ifap);\n\t\t\t\tsctp_add_ifa_to_ifn(sctp_ifnp, sctp_ifap);\n\t\t\t}\n\t\t\tgoto exit_stage_left;\n\t\t}\n\t}\n\tSCTP_IPI_ADDR_WUNLOCK();\n\tSCTP_MALLOC(sctp_ifap, struct sctp_ifa *, sizeof(struct sctp_ifa), SCTP_M_IFA);\n\tif (sctp_ifap == NULL) {\n#ifdef INVARIANTS\n\t\tpanic(\"No memory for IFA\");\n#endif\n\t\treturn (NULL);\n\t}\n\tmemset(sctp_ifap, 0, sizeof(struct sctp_ifa));\n\tsctp_ifap->ifn_p = sctp_ifnp;\n\tatomic_add_int(&sctp_ifnp->refcount, 1);\n\tsctp_ifap->vrf_id = vrf_id;\n\tsctp_ifap->ifa = ifa;\n#ifdef HAVE_SA_LEN\n\tmemcpy(&sctp_ifap->address, addr, addr->sa_len);\n#else\n\tswitch (addr->sa_family) {\n#ifdef INET\n\tcase AF_INET:\n\t\tmemcpy(&sctp_ifap->address, addr, sizeof(struct sockaddr_in));\n\t\tbreak;\n#endif\n#ifdef INET6\n\tcase AF_INET6:\n\t\tmemcpy(&sctp_ifap->address, addr, sizeof(struct sockaddr_in6));\n\t\tbreak;\n#endif\n#if defined(__Userspace__)\n\tcase AF_CONN:\n\t\tmemcpy(&sctp_ifap->address, addr, sizeof(struct sockaddr_conn));\n\t\tbreak;\n#endif\n\tdefault:\n\t\t/* TSNH */\n\t\tbreak;\n\t}\n#endif\n\tsctp_ifap->localifa_flags = SCTP_ADDR_VALID | SCTP_ADDR_DEFER_USE;\n\tsctp_ifap->flags = ifa_flags;\n\t/* Set scope */\n\tswitch (sctp_ifap->address.sa.sa_family) {\n#ifdef INET\n\tcase AF_INET:\n\t{\n\t\tstruct sockaddr_in *sin;\n\n\t\tsin = &sctp_ifap->address.sin;\n\t\tif (SCTP_IFN_IS_IFT_LOOP(sctp_ifap->ifn_p) ||\n\t\t    (IN4_ISLOOPBACK_ADDRESS(&sin->sin_addr))) {\n\t\t\tsctp_ifap->src_is_loop = 1;\n\t\t}\n\t\tif ((IN4_ISPRIVATE_ADDRESS(&sin->sin_addr))) {\n\t\t\tsctp_ifap->src_is_priv = 1;\n\t\t}\n\t\tsctp_ifnp->num_v4++;\n\t\tif (new_ifn_af)\n\t\t    new_ifn_af = AF_INET;\n\t\tbreak;\n\t}\n#endif\n#ifdef INET6\n\tcase AF_INET6:\n\t{\n\t\t/* ok to use deprecated addresses? */\n\t\tstruct sockaddr_in6 *sin6;\n\n\t\tsin6 = &sctp_ifap->address.sin6;\n\t\tif (SCTP_IFN_IS_IFT_LOOP(sctp_ifap->ifn_p) ||\n\t\t    (IN6_IS_ADDR_LOOPBACK(&sin6->sin6_addr))) {\n\t\t\tsctp_ifap->src_is_loop = 1;\n\t\t}\n\t\tif (IN6_IS_ADDR_LINKLOCAL(&sin6->sin6_addr)) {\n\t\t\tsctp_ifap->src_is_priv = 1;\n\t\t}\n\t\tsctp_ifnp->num_v6++;\n\t\tif (new_ifn_af)\n\t\t\tnew_ifn_af = AF_INET6;\n\t\tbreak;\n\t}\n#endif\n#if defined(__Userspace__)\n\tcase AF_CONN:\n\t\tif (new_ifn_af)\n\t\t\tnew_ifn_af = AF_CONN;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tnew_ifn_af = 0;\n\t\tbreak;\n\t}\n\thash_of_addr = sctp_get_ifa_hash_val(&sctp_ifap->address.sa);\n\n\tif ((sctp_ifap->src_is_priv == 0) &&\n\t    (sctp_ifap->src_is_loop == 0)) {\n\t\tsctp_ifap->src_is_glob = 1;\n\t}\n\tSCTP_IPI_ADDR_WLOCK();\n\thash_addr_head = &vrf->vrf_addr_hash[(hash_of_addr & vrf->vrf_addr_hashmark)];\n\tLIST_INSERT_HEAD(hash_addr_head, sctp_ifap, next_bucket);\n\tsctp_ifap->refcount = 1;\n\tLIST_INSERT_HEAD(&sctp_ifnp->ifalist, sctp_ifap, next_ifa);\n\tsctp_ifnp->ifa_count++;\n\tvrf->total_ifa_count++;\n\tatomic_add_int(&SCTP_BASE_INFO(ipi_count_ifas), 1);\n\tif (new_ifn_af) {\n\t\tSCTP_REGISTER_INTERFACE(ifn_index, new_ifn_af);\n\t\tsctp_ifnp->registered_af = new_ifn_af;\n\t}\n\tSCTP_IPI_ADDR_WUNLOCK();\n\tif (dynamic_add) {\n\t\t/* Bump up the refcount so that when the timer\n\t\t * completes it will drop back down.\n\t\t */\n\t\tstruct sctp_laddr *wi;\n\n\t\tatomic_add_int(&sctp_ifap->refcount, 1);\n\t\twi = SCTP_ZONE_GET(SCTP_BASE_INFO(ipi_zone_laddr), struct sctp_laddr);\n\t\tif (wi == NULL) {\n\t\t\t/*\n\t\t\t * Gak, what can we do? We have lost an address\n\t\t\t * change can you say HOSED?\n\t\t\t */\n\t\t\tSCTPDBG(SCTP_DEBUG_PCB4, \"Lost an address change?\\n\");\n\t\t\t/* Opps, must decrement the count */\n\t\t\tsctp_del_addr_from_vrf(vrf_id, addr, ifn_index,\n\t\t\t\t\t       if_name);\n\t\t\treturn (NULL);\n\t\t}\n\t\tSCTP_INCR_LADDR_COUNT();\n\t\tmemset(wi, 0, sizeof(*wi));\n\t\t(void)SCTP_GETTIME_TIMEVAL(&wi->start_time);\n\t\twi->ifa = sctp_ifap;\n\t\twi->action = SCTP_ADD_IP_ADDRESS;\n\n\t\tSCTP_WQ_ADDR_LOCK();\n\t\tLIST_INSERT_HEAD(&SCTP_BASE_INFO(addr_wq), wi, sctp_nxt_addr);\n\t\tsctp_timer_start(SCTP_TIMER_TYPE_ADDR_WQ,\n\t\t\t\t (struct sctp_inpcb *)NULL,\n\t\t\t\t (struct sctp_tcb *)NULL,\n\t\t\t\t (struct sctp_nets *)NULL);\n\t\tSCTP_WQ_ADDR_UNLOCK();\n\t} else {\n\t\t/* it's ready for use */\n\t\tsctp_ifap->localifa_flags &= ~SCTP_ADDR_DEFER_USE;\n\t}\n\treturn (sctp_ifap);\n}\n\nvoid\nsctp_del_addr_from_vrf(uint32_t vrf_id, struct sockaddr *addr,\n\t\t       uint32_t ifn_index, const char *if_name)\n{\n\tstruct sctp_vrf *vrf;\n\tstruct sctp_ifa *sctp_ifap = NULL;\n\n\tSCTP_IPI_ADDR_WLOCK();\n\tvrf = sctp_find_vrf(vrf_id);\n\tif (vrf == NULL) {\n\t\tSCTPDBG(SCTP_DEBUG_PCB4, \"Can't find vrf_id 0x%x\\n\", vrf_id);\n\t\tgoto out_now;\n\t}\n\n#ifdef SCTP_DEBUG\n\tSCTPDBG(SCTP_DEBUG_PCB4, \"vrf_id 0x%x: deleting address:\", vrf_id);\n\tSCTPDBG_ADDR(SCTP_DEBUG_PCB4, addr);\n#endif\n\tsctp_ifap = sctp_find_ifa_by_addr(addr, vrf->vrf_id, SCTP_ADDR_LOCKED);\n\tif (sctp_ifap) {\n\t\t/* Validate the delete */\n\t\tif (sctp_ifap->ifn_p) {\n\t\t\tint valid = 0;\n\t\t\t/*-\n\t\t\t * The name has priority over the ifn_index\n\t\t\t * if its given. We do this especially for\n\t\t\t * panda who might recycle indexes fast.\n\t\t\t */\n\t\t\tif (if_name) {\n\t\t\t\tif (strncmp(if_name, sctp_ifap->ifn_p->ifn_name, SCTP_IFNAMSIZ) == 0) {\n\t\t\t\t\t/* They match its a correct delete */\n\t\t\t\t\tvalid = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!valid) {\n\t\t\t\t/* last ditch check ifn_index */\n\t\t\t\tif (ifn_index == sctp_ifap->ifn_p->ifn_index) {\n\t\t\t\t\tvalid = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!valid) {\n\t\t\t\tSCTPDBG(SCTP_DEBUG_PCB4, \"ifn:%d ifname:%s does not match addresses\\n\",\n\t\t\t\t\tifn_index, ((if_name == NULL) ? \"NULL\" : if_name));\n\t\t\t\tSCTPDBG(SCTP_DEBUG_PCB4, \"ifn:%d ifname:%s - ignoring delete\\n\",\n\t\t\t\t\tsctp_ifap->ifn_p->ifn_index, sctp_ifap->ifn_p->ifn_name);\n\t\t\t\tSCTP_IPI_ADDR_WUNLOCK();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tSCTPDBG(SCTP_DEBUG_PCB4, \"Deleting ifa %p\\n\", (void *)sctp_ifap);\n\t\tsctp_ifap->localifa_flags &= SCTP_ADDR_VALID;\n                /*\n\t\t * We don't set the flag. This means that the structure will\n\t\t * hang around in EP's that have bound specific to it until\n\t\t * they close. This gives us TCP like behavior if someone\n\t\t * removes an address (or for that matter adds it right back).\n\t\t */\n\t\t/* sctp_ifap->localifa_flags |= SCTP_BEING_DELETED; */\n\t\tvrf->total_ifa_count--;\n\t\tLIST_REMOVE(sctp_ifap, next_bucket);\n\t\tsctp_remove_ifa_from_ifn(sctp_ifap);\n\t}\n#ifdef SCTP_DEBUG\n\telse {\n\t\tSCTPDBG(SCTP_DEBUG_PCB4, \"Del Addr-ifn:%d Could not find address:\",\n\t\t\tifn_index);\n\t\tSCTPDBG_ADDR(SCTP_DEBUG_PCB1, addr);\n\t}\n#endif\n\n out_now:\n\tSCTP_IPI_ADDR_WUNLOCK();\n\tif (sctp_ifap) {\n\t\tstruct sctp_laddr *wi;\n\n\t\twi = SCTP_ZONE_GET(SCTP_BASE_INFO(ipi_zone_laddr), struct sctp_laddr);\n\t\tif (wi == NULL) {\n\t\t\t/*\n\t\t\t * Gak, what can we do? We have lost an address\n\t\t\t * change can you say HOSED?\n\t\t\t */\n\t\t\tSCTPDBG(SCTP_DEBUG_PCB4, \"Lost an address change?\\n\");\n\n\t\t\t/* Oops, must decrement the count */\n\t\t\tsctp_free_ifa(sctp_ifap);\n\t\t\treturn;\n\t\t}\n\t\tSCTP_INCR_LADDR_COUNT();\n\t\tmemset(wi, 0, sizeof(*wi));\n\t\t(void)SCTP_GETTIME_TIMEVAL(&wi->start_time);\n\t\twi->ifa = sctp_ifap;\n\t\twi->action = SCTP_DEL_IP_ADDRESS;\n\t\tSCTP_WQ_ADDR_LOCK();\n\t\t/*\n\t\t * Should this really be a tailq? As it is we will process the\n\t\t * newest first :-0\n\t\t */\n\t\tLIST_INSERT_HEAD(&SCTP_BASE_INFO(addr_wq), wi, sctp_nxt_addr);\n\t\tsctp_timer_start(SCTP_TIMER_TYPE_ADDR_WQ,\n\t\t\t\t (struct sctp_inpcb *)NULL,\n\t\t\t\t (struct sctp_tcb *)NULL,\n\t\t\t\t (struct sctp_nets *)NULL);\n\t\tSCTP_WQ_ADDR_UNLOCK();\n\t}\n\treturn;\n}\n\n\nstatic int\nsctp_does_stcb_own_this_addr(struct sctp_tcb *stcb, struct sockaddr *to)\n{\n\tint loopback_scope;\n#if defined(INET)\n\tint ipv4_local_scope, ipv4_addr_legal;\n#endif\n#if defined(INET6)\n\tint local_scope, site_scope, ipv6_addr_legal;\n#endif\n#if defined(__Userspace__)\n\tint conn_addr_legal;\n#endif\n\tstruct sctp_vrf *vrf;\n\tstruct sctp_ifn *sctp_ifn;\n\tstruct sctp_ifa *sctp_ifa;\n\n\tloopback_scope = stcb->asoc.scope.loopback_scope;\n#if defined(INET)\n\tipv4_local_scope = stcb->asoc.scope.ipv4_local_scope;\n\tipv4_addr_legal = stcb->asoc.scope.ipv4_addr_legal;\n#endif\n#if defined(INET6)\n\tlocal_scope = stcb->asoc.scope.local_scope;\n\tsite_scope = stcb->asoc.scope.site_scope;\n\tipv6_addr_legal = stcb->asoc.scope.ipv6_addr_legal;\n#endif\n#if defined(__Userspace__)\n\tconn_addr_legal = stcb->asoc.scope.conn_addr_legal;\n#endif\n\n\tSCTP_IPI_ADDR_RLOCK();\n\tvrf = sctp_find_vrf(stcb->asoc.vrf_id);\n\tif (vrf == NULL) {\n\t\t/* no vrf, no addresses */\n\t\tSCTP_IPI_ADDR_RUNLOCK();\n\t\treturn (0);\n\t}\n\n\tif (stcb->sctp_ep->sctp_flags & SCTP_PCB_FLAGS_BOUNDALL) {\n\t\tLIST_FOREACH(sctp_ifn, &vrf->ifnlist, next_ifn) {\n\t\t\tif ((loopback_scope == 0) &&\n\t\t\t    SCTP_IFN_IS_IFT_LOOP(sctp_ifn)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tLIST_FOREACH(sctp_ifa, &sctp_ifn->ifalist, next_ifa) {\n\t\t\t\tif (sctp_is_addr_restricted(stcb, sctp_ifa) &&\n\t\t\t\t    (!sctp_is_addr_pending(stcb, sctp_ifa))) {\n\t\t\t\t\t/* We allow pending addresses, where we\n\t\t\t\t\t * have sent an asconf-add to be considered\n\t\t\t\t\t * valid.\n\t\t\t\t\t */\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (sctp_ifa->address.sa.sa_family != to->sa_family) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tswitch (sctp_ifa->address.sa.sa_family) {\n#ifdef INET\n\t\t\t\tcase AF_INET:\n\t\t\t\t\tif (ipv4_addr_legal) {\n\t\t\t\t\t\tstruct sockaddr_in *sin, *rsin;\n\n\t\t\t\t\t\tsin = &sctp_ifa->address.sin;\n\t\t\t\t\t\trsin = (struct sockaddr_in *)to;\n\t\t\t\t\t\tif ((ipv4_local_scope == 0) &&\n\t\t\t\t\t\t    IN4_ISPRIVATE_ADDRESS(&sin->sin_addr)) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n#if defined(__FreeBSD__)\n\t\t\t\t\t\tif (prison_check_ip4(stcb->sctp_ep->ip_inp.inp.inp_cred,\n\t\t\t\t\t\t                     &sin->sin_addr) != 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t\tif (sin->sin_addr.s_addr == rsin->sin_addr.s_addr) {\n\t\t\t\t\t\t\tSCTP_IPI_ADDR_RUNLOCK();\n\t\t\t\t\t\t\treturn (1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n#endif\n#ifdef INET6\n\t\t\t\tcase AF_INET6:\n\t\t\t\t\tif (ipv6_addr_legal) {\n\t\t\t\t\t\tstruct sockaddr_in6 *sin6, *rsin6;\n#if defined(SCTP_EMBEDDED_V6_SCOPE) && !defined(SCTP_KAME)\n\t\t\t\t\t\tstruct sockaddr_in6 lsa6;\n#endif\n\t\t\t\t\t\tsin6 = &sctp_ifa->address.sin6;\n\t\t\t\t\t\trsin6 = (struct sockaddr_in6 *)to;\n#if defined(__FreeBSD__)\n\t\t\t\t\t\tif (prison_check_ip6(stcb->sctp_ep->ip_inp.inp.inp_cred,\n\t\t\t\t\t\t                     &sin6->sin6_addr) != 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t\tif (IN6_IS_ADDR_LINKLOCAL(&sin6->sin6_addr)) {\n\t\t\t\t\t\t\tif (local_scope == 0)\n\t\t\t\t\t\t\t\tcontinue;\n#if defined(SCTP_EMBEDDED_V6_SCOPE)\n\t\t\t\t\t\t\tif (sin6->sin6_scope_id == 0) {\n#ifdef SCTP_KAME\n\t\t\t\t\t\t\t\tif (sa6_recoverscope(sin6) != 0)\n\t\t\t\t\t\t\t\t\tcontinue;\n#else\n\t\t\t\t\t\t\t\tlsa6 = *sin6;\n\t\t\t\t\t\t\t\tif (in6_recoverscope(&lsa6,\n\t\t\t\t\t\t\t\t                     &lsa6.sin6_addr,\n\t\t\t\t\t\t\t\t                     NULL))\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tsin6 = &lsa6;\n#endif /* SCTP_KAME */\n\t\t\t\t\t\t\t}\n#endif /* SCTP_EMBEDDED_V6_SCOPE */\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ((site_scope == 0) &&\n\t\t\t\t\t\t    (IN6_IS_ADDR_SITELOCAL(&sin6->sin6_addr))) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (SCTP6_ARE_ADDR_EQUAL(sin6, rsin6)) {\n\t\t\t\t\t\t\tSCTP_IPI_ADDR_RUNLOCK();\n\t\t\t\t\t\t\treturn (1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n#endif\n#if defined(__Userspace__)\n\t\t\t\tcase AF_CONN:\n\t\t\t\t\tif (conn_addr_legal) {\n\t\t\t\t\t\tstruct sockaddr_conn *sconn, *rsconn;\n\n\t\t\t\t\t\tsconn = &sctp_ifa->address.sconn;\n\t\t\t\t\t\trsconn = (struct sockaddr_conn *)to;\n\t\t\t\t\t\tif (sconn->sconn_addr == rsconn->sconn_addr) {\n\t\t\t\t\t\t\tSCTP_IPI_ADDR_RUNLOCK();\n\t\t\t\t\t\t\treturn (1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n#endif\n\t\t\t\tdefault:\n\t\t\t\t\t/* TSNH */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tstruct sctp_laddr *laddr;\n\n\t\tLIST_FOREACH(laddr, &stcb->sctp_ep->sctp_addr_list, sctp_nxt_addr) {\n\t\t\tif (laddr->ifa->localifa_flags & SCTP_BEING_DELETED) {\n\t\t\t\tSCTPDBG(SCTP_DEBUG_PCB1, \"ifa being deleted\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (sctp_is_addr_restricted(stcb, laddr->ifa) &&\n\t\t\t    (!sctp_is_addr_pending(stcb, laddr->ifa))) {\n\t\t\t\t/* We allow pending addresses, where we\n\t\t\t\t * have sent an asconf-add to be considered\n\t\t\t\t * valid.\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (laddr->ifa->address.sa.sa_family != to->sa_family) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tswitch (to->sa_family) {\n#ifdef INET\n\t\t\tcase AF_INET:\n\t\t\t{\n\t\t\t\tstruct sockaddr_in *sin, *rsin;\n\n\t\t\t\tsin = &laddr->ifa->address.sin;\n\t\t\t\trsin = (struct sockaddr_in *)to;\n\t\t\t\tif (sin->sin_addr.s_addr == rsin->sin_addr.s_addr) {\n\t\t\t\t\tSCTP_IPI_ADDR_RUNLOCK();\n\t\t\t\t\treturn (1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n#ifdef INET6\n\t\t\tcase AF_INET6:\n\t\t\t{\n\t\t\t\tstruct sockaddr_in6 *sin6, *rsin6;\n\n\t\t\t\tsin6 = &laddr->ifa->address.sin6;\n\t\t\t\trsin6 = (struct sockaddr_in6 *)to;\n\t\t\t\tif (SCTP6_ARE_ADDR_EQUAL(sin6, rsin6)) {\n\t\t\t\t\tSCTP_IPI_ADDR_RUNLOCK();\n\t\t\t\t\treturn (1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n#endif\n#if defined(__Userspace__)\n\t\t\tcase AF_CONN:\n\t\t\t{\n\t\t\t\tstruct sockaddr_conn *sconn, *rsconn;\n\n\t\t\t\tsconn = &laddr->ifa->address.sconn;\n\t\t\t\trsconn = (struct sockaddr_conn *)to;\n\t\t\t\tif (sconn->sconn_addr == rsconn->sconn_addr) {\n\t\t\t\t\tSCTP_IPI_ADDR_RUNLOCK();\n\t\t\t\t\treturn (1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n\t\t\tdefault:\n\t\t\t\t/* TSNH */\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\t}\n\tSCTP_IPI_ADDR_RUNLOCK();\n\treturn (0);\n}\n\n\nstatic struct sctp_tcb *\nsctp_tcb_special_locate(struct sctp_inpcb **inp_p, struct sockaddr *from,\n    struct sockaddr *to, struct sctp_nets **netp, uint32_t vrf_id)\n{\n\t/**** ASSUMES THE CALLER holds the INP_INFO_RLOCK */\n\t/*\n\t * If we support the TCP model, then we must now dig through to see\n\t * if we can find our endpoint in the list of tcp ep's.\n\t */\n\tuint16_t lport, rport;\n\tstruct sctppcbhead *ephead;\n\tstruct sctp_inpcb *inp;\n\tstruct sctp_laddr *laddr;\n\tstruct sctp_tcb *stcb;\n\tstruct sctp_nets *net;\n#ifdef SCTP_MVRF\n\tint fnd, i;\n#endif\n\n\tif ((to == NULL) || (from == NULL)) {\n\t\treturn (NULL);\n\t}\n\n\tswitch (to->sa_family) {\n#ifdef INET\n\tcase AF_INET:\n\t\tif (from->sa_family == AF_INET) {\n\t\t\tlport = ((struct sockaddr_in *)to)->sin_port;\n\t\t\trport = ((struct sockaddr_in *)from)->sin_port;\n\t\t} else {\n\t\t\treturn (NULL);\n\t\t}\n\t\tbreak;\n#endif\n#ifdef INET6\n\tcase AF_INET6:\n\t\tif (from->sa_family == AF_INET6) {\n\t\t\tlport = ((struct sockaddr_in6 *)to)->sin6_port;\n\t\t\trport = ((struct sockaddr_in6 *)from)->sin6_port;\n\t\t} else {\n\t\t\treturn (NULL);\n\t\t}\n\t\tbreak;\n#endif\n#if defined(__Userspace__)\n\tcase AF_CONN:\n\t\tif (from->sa_family == AF_CONN) {\n\t\t\tlport = ((struct sockaddr_conn *)to)->sconn_port;\n\t\t\trport = ((struct sockaddr_conn *)from)->sconn_port;\n\t\t} else {\n\t\t\treturn (NULL);\n\t\t}\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn (NULL);\n\t}\n\tephead = &SCTP_BASE_INFO(sctp_tcpephash)[SCTP_PCBHASH_ALLADDR((lport | rport), SCTP_BASE_INFO(hashtcpmark))];\n\t/*\n\t * Ok now for each of the guys in this bucket we must look and see:\n\t * - Does the remote port match. - Does there single association's\n\t * addresses match this address (to). If so we update p_ep to point\n\t * to this ep and return the tcb from it.\n\t */\n\tLIST_FOREACH(inp, ephead, sctp_hash) {\n\t\tSCTP_INP_RLOCK(inp);\n\t\tif (inp->sctp_flags & SCTP_PCB_FLAGS_SOCKET_ALLGONE) {\n\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\tcontinue;\n\t\t}\n\t\tif (lport != inp->sctp_lport) {\n\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\tcontinue;\n\t\t}\n#if defined(__FreeBSD__)\n\t\tswitch (to->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t{\n\t\t\tstruct sockaddr_in *sin;\n\n\t\t\tsin = (struct sockaddr_in *)to;\n\t\t\tif (prison_check_ip4(inp->ip_inp.inp.inp_cred,\n\t\t\t                     &sin->sin_addr) != 0) {\n\t\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n#endif\n#ifdef INET6\n\t\tcase AF_INET6:\n\t\t{\n\t\t\tstruct sockaddr_in6 *sin6;\n\n\t\t\tsin6 = (struct sockaddr_in6 *)to;\n\t\t\tif (prison_check_ip6(inp->ip_inp.inp.inp_cred,\n\t\t\t                     &sin6->sin6_addr) != 0) {\n\t\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\tcontinue;\n\t\t}\n#endif\n#ifdef SCTP_MVRF\n\t\tfnd = 0;\n\t\tfor (i = 0; i < inp->num_vrfs; i++) {\n\t\t\tif (inp->m_vrf_ids[i] == vrf_id) {\n\t\t\t\tfnd = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (fnd == 0) {\n\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\tcontinue;\n\t\t}\n#else\n\t\tif (inp->def_vrf_id != vrf_id) {\n\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\tcontinue;\n\t\t}\n#endif\n\t\t/* check to see if the ep has one of the addresses */\n\t\tif ((inp->sctp_flags & SCTP_PCB_FLAGS_BOUNDALL) == 0) {\n\t\t\t/* We are NOT bound all, so look further */\n\t\t\tint match = 0;\n\n\t\t\tLIST_FOREACH(laddr, &inp->sctp_addr_list, sctp_nxt_addr) {\n\n\t\t\t\tif (laddr->ifa == NULL) {\n\t\t\t\t\tSCTPDBG(SCTP_DEBUG_PCB1, \"%s: NULL ifa\\n\", __func__);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (laddr->ifa->localifa_flags & SCTP_BEING_DELETED) {\n\t\t\t\t\tSCTPDBG(SCTP_DEBUG_PCB1, \"ifa being deleted\\n\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (laddr->ifa->address.sa.sa_family ==\n\t\t\t\t    to->sa_family) {\n\t\t\t\t\t/* see if it matches */\n#ifdef INET\n\t\t\t\t\tif (from->sa_family == AF_INET) {\n\t\t\t\t\t\tstruct sockaddr_in *intf_addr, *sin;\n\n\t\t\t\t\t\tintf_addr = &laddr->ifa->address.sin;\n\t\t\t\t\t\tsin = (struct sockaddr_in *)to;\n\t\t\t\t\t\tif (sin->sin_addr.s_addr ==\n\t\t\t\t\t\t    intf_addr->sin_addr.s_addr) {\n\t\t\t\t\t\t\tmatch = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n#ifdef INET6\n\t\t\t\t\tif (from->sa_family == AF_INET6) {\n\t\t\t\t\t\tstruct sockaddr_in6 *intf_addr6;\n\t\t\t\t\t\tstruct sockaddr_in6 *sin6;\n\n\t\t\t\t\t\tsin6 = (struct sockaddr_in6 *)\n\t\t\t\t\t\t    to;\n\t\t\t\t\t\tintf_addr6 = &laddr->ifa->address.sin6;\n\n\t\t\t\t\t\tif (SCTP6_ARE_ADDR_EQUAL(sin6,\n\t\t\t\t\t\t    intf_addr6)) {\n\t\t\t\t\t\t\tmatch = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n#if defined(__Userspace__)\n\t\t\t\t\tif (from->sa_family == AF_CONN) {\n\t\t\t\t\t\tstruct sockaddr_conn *intf_addr, *sconn;\n\n\t\t\t\t\t\tintf_addr = &laddr->ifa->address.sconn;\n\t\t\t\t\t\tsconn = (struct sockaddr_conn *)to;\n\t\t\t\t\t\tif (sconn->sconn_addr ==\n\t\t\t\t\t\t    intf_addr->sconn_addr) {\n\t\t\t\t\t\t\tmatch = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (match == 0) {\n\t\t\t\t/* This endpoint does not have this address */\n\t\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Ok if we hit here the ep has the address, does it hold\n\t\t * the tcb?\n\t\t */\n\t\t/* XXX: Why don't we TAILQ_FOREACH through sctp_asoc_list? */\n\t\tstcb = LIST_FIRST(&inp->sctp_asoc_list);\n\t\tif (stcb == NULL) {\n\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\tcontinue;\n\t\t}\n\t\tSCTP_TCB_LOCK(stcb);\n\t\tif (!sctp_does_stcb_own_this_addr(stcb, to)) {\n\t\t\tSCTP_TCB_UNLOCK(stcb);\n\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\tcontinue;\n\t\t}\n\t\tif (stcb->rport != rport) {\n\t\t\t/* remote port does not match. */\n\t\t\tSCTP_TCB_UNLOCK(stcb);\n\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\tcontinue;\n\t\t}\n\t\tif (stcb->asoc.state & SCTP_STATE_ABOUT_TO_BE_FREED) {\n\t\t\tSCTP_TCB_UNLOCK(stcb);\n\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!sctp_does_stcb_own_this_addr(stcb, to)) {\n\t\t\tSCTP_TCB_UNLOCK(stcb);\n\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Does this TCB have a matching address? */\n\t\tTAILQ_FOREACH(net, &stcb->asoc.nets, sctp_next) {\n\n\t\t\tif (net->ro._l_addr.sa.sa_family != from->sa_family) {\n\t\t\t\t/* not the same family, can't be a match */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tswitch (from->sa_family) {\n#ifdef INET\n\t\t\tcase AF_INET:\n\t\t\t{\n\t\t\t\tstruct sockaddr_in *sin, *rsin;\n\n\t\t\t\tsin = (struct sockaddr_in *)&net->ro._l_addr;\n\t\t\t\trsin = (struct sockaddr_in *)from;\n\t\t\t\tif (sin->sin_addr.s_addr ==\n\t\t\t\t    rsin->sin_addr.s_addr) {\n\t\t\t\t\t/* found it */\n\t\t\t\t\tif (netp != NULL) {\n\t\t\t\t\t\t*netp = net;\n\t\t\t\t\t}\n\t\t\t\t\t/* Update the endpoint pointer */\n\t\t\t\t\t*inp_p = inp;\n\t\t\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\t\t\treturn (stcb);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n#ifdef INET6\n\t\t\tcase AF_INET6:\n\t\t\t{\n\t\t\t\tstruct sockaddr_in6 *sin6, *rsin6;\n\n\t\t\t\tsin6 = (struct sockaddr_in6 *)&net->ro._l_addr;\n\t\t\t\trsin6 = (struct sockaddr_in6 *)from;\n\t\t\t\tif (SCTP6_ARE_ADDR_EQUAL(sin6,\n\t\t\t\t    rsin6)) {\n\t\t\t\t\t/* found it */\n\t\t\t\t\tif (netp != NULL) {\n\t\t\t\t\t\t*netp = net;\n\t\t\t\t\t}\n\t\t\t\t\t/* Update the endpoint pointer */\n\t\t\t\t\t*inp_p = inp;\n\t\t\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\t\t\treturn (stcb);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n#if defined(__Userspace__)\n\t\t\tcase AF_CONN:\n\t\t\t{\n\t\t\t\tstruct sockaddr_conn *sconn, *rsconn;\n\n\t\t\t\tsconn = (struct sockaddr_conn *)&net->ro._l_addr;\n\t\t\t\trsconn = (struct sockaddr_conn *)from;\n\t\t\t\tif (sconn->sconn_addr == rsconn->sconn_addr) {\n\t\t\t\t\t/* found it */\n\t\t\t\t\tif (netp != NULL) {\n\t\t\t\t\t\t*netp = net;\n\t\t\t\t\t}\n\t\t\t\t\t/* Update the endpoint pointer */\n\t\t\t\t\t*inp_p = inp;\n\t\t\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\t\t\treturn (stcb);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n\t\t\tdefault:\n\t\t\t\t/* TSNH */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tSCTP_TCB_UNLOCK(stcb);\n\t\tSCTP_INP_RUNLOCK(inp);\n\t}\n\treturn (NULL);\n}\n\n\n/*\n * rules for use\n *\n * 1) If I return a NULL you must decrement any INP ref cnt. 2) If I find an\n * stcb, both will be locked (locked_tcb and stcb) but decrement will be done\n * (if locked == NULL). 3) Decrement happens on return ONLY if locked ==\n * NULL.\n */\n\nstruct sctp_tcb *\nsctp_findassociation_ep_addr(struct sctp_inpcb **inp_p, struct sockaddr *remote,\n    struct sctp_nets **netp, struct sockaddr *local, struct sctp_tcb *locked_tcb)\n{\n\tstruct sctpasochead *head;\n\tstruct sctp_inpcb *inp;\n\tstruct sctp_tcb *stcb = NULL;\n\tstruct sctp_nets *net;\n\tuint16_t rport;\n\n\tinp = *inp_p;\n\tswitch (remote->sa_family) {\n#ifdef INET\n\tcase AF_INET:\n\t\trport = (((struct sockaddr_in *)remote)->sin_port);\n\t\tbreak;\n#endif\n#ifdef INET6\n\tcase AF_INET6:\n\t\trport = (((struct sockaddr_in6 *)remote)->sin6_port);\n\t\tbreak;\n#endif\n#if defined(__Userspace__)\n\tcase AF_CONN:\n\t\trport = (((struct sockaddr_conn *)remote)->sconn_port);\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn (NULL);\n\t}\n\tif (locked_tcb) {\n\t\t/*\n\t\t * UN-lock so we can do proper locking here this occurs when\n\t\t * called from load_addresses_from_init.\n\t\t */\n\t\tatomic_add_int(&locked_tcb->asoc.refcnt, 1);\n\t\tSCTP_TCB_UNLOCK(locked_tcb);\n\t}\n\tSCTP_INP_INFO_RLOCK();\n\tif ((inp->sctp_flags & SCTP_PCB_FLAGS_TCPTYPE) ||\n\t    (inp->sctp_flags & SCTP_PCB_FLAGS_IN_TCPPOOL)) {\n\t\t/*-\n\t\t * Now either this guy is our listener or it's the\n\t\t * connector. If it is the one that issued the connect, then\n\t\t * it's only chance is to be the first TCB in the list. If\n\t\t * it is the acceptor, then do the special_lookup to hash\n\t\t * and find the real inp.\n\t\t */\n\t\tif ((inp->sctp_socket) && SCTP_IS_LISTENING(inp)) {\n\t\t\t/* to is peer addr, from is my addr */\n#ifndef SCTP_MVRF\n\t\t\tstcb = sctp_tcb_special_locate(inp_p, remote, local,\n\t\t\t    netp, inp->def_vrf_id);\n\t\t\tif ((stcb != NULL) && (locked_tcb == NULL)) {\n\t\t\t\t/* we have a locked tcb, lower refcount */\n\t\t\t\tSCTP_INP_DECR_REF(inp);\n\t\t\t}\n\t\t\tif ((locked_tcb != NULL) && (locked_tcb != stcb)) {\n\t\t\t\tSCTP_INP_RLOCK(locked_tcb->sctp_ep);\n\t\t\t\tSCTP_TCB_LOCK(locked_tcb);\n\t\t\t\tatomic_subtract_int(&locked_tcb->asoc.refcnt, 1);\n\t\t\t\tSCTP_INP_RUNLOCK(locked_tcb->sctp_ep);\n\t\t\t}\n#else\n\t\t\t/*-\n\t\t\t * MVRF is tricky, we must look in every VRF\n\t\t\t * the endpoint has.\n\t\t\t */\n\t\t\tint i;\n\n\t\t\tfor (i = 0; i < inp->num_vrfs; i++) {\n\t\t\t\tstcb = sctp_tcb_special_locate(inp_p, remote, local,\n\t\t\t\t                               netp, inp->m_vrf_ids[i]);\n\t\t\t\tif ((stcb != NULL) && (locked_tcb == NULL)) {\n\t\t\t\t\t/* we have a locked tcb, lower refcount */\n\t\t\t\t\tSCTP_INP_DECR_REF(inp);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif ((locked_tcb != NULL) && (locked_tcb != stcb)) {\n\t\t\t\t\tSCTP_INP_RLOCK(locked_tcb->sctp_ep);\n\t\t\t\t\tSCTP_TCB_LOCK(locked_tcb);\n\t\t\t\t\tatomic_subtract_int(&locked_tcb->asoc.refcnt, 1);\n\t\t\t\t\tSCTP_INP_RUNLOCK(locked_tcb->sctp_ep);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\tSCTP_INP_INFO_RUNLOCK();\n\t\t\treturn (stcb);\n\t\t} else {\n\t\t\tSCTP_INP_WLOCK(inp);\n\t\t\tif (inp->sctp_flags & SCTP_PCB_FLAGS_SOCKET_ALLGONE) {\n\t\t\t\tgoto null_return;\n\t\t\t}\n\t\t\tstcb = LIST_FIRST(&inp->sctp_asoc_list);\n\t\t\tif (stcb == NULL) {\n\t\t\t\tgoto null_return;\n\t\t\t}\n\t\t\tSCTP_TCB_LOCK(stcb);\n\n\t\t\tif (stcb->rport != rport) {\n\t\t\t\t/* remote port does not match. */\n\t\t\t\tSCTP_TCB_UNLOCK(stcb);\n\t\t\t\tgoto null_return;\n\t\t\t}\n\t\t\tif (stcb->asoc.state & SCTP_STATE_ABOUT_TO_BE_FREED) {\n\t\t\t\tSCTP_TCB_UNLOCK(stcb);\n\t\t\t\tgoto null_return;\n\t\t\t}\n\t\t\tif (local && !sctp_does_stcb_own_this_addr(stcb, local)) {\n\t\t\t\tSCTP_TCB_UNLOCK(stcb);\n\t\t\t\tgoto null_return;\n\t\t\t}\n\t\t\t/* now look at the list of remote addresses */\n\t\t\tTAILQ_FOREACH(net, &stcb->asoc.nets, sctp_next) {\n#ifdef INVARIANTS\n\t\t\t\tif (net == (TAILQ_NEXT(net, sctp_next))) {\n\t\t\t\t\tpanic(\"Corrupt net list\");\n\t\t\t\t}\n#endif\n\t\t\t\tif (net->ro._l_addr.sa.sa_family !=\n\t\t\t\t    remote->sa_family) {\n\t\t\t\t\t/* not the same family */\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tswitch (remote->sa_family) {\n#ifdef INET\n\t\t\t\tcase AF_INET:\n\t\t\t\t{\n\t\t\t\t\tstruct sockaddr_in *sin, *rsin;\n\n\t\t\t\t\tsin = (struct sockaddr_in *)\n\t\t\t\t\t    &net->ro._l_addr;\n\t\t\t\t\trsin = (struct sockaddr_in *)remote;\n\t\t\t\t\tif (sin->sin_addr.s_addr ==\n\t\t\t\t\t    rsin->sin_addr.s_addr) {\n\t\t\t\t\t\t/* found it */\n\t\t\t\t\t\tif (netp != NULL) {\n\t\t\t\t\t\t\t*netp = net;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (locked_tcb == NULL) {\n\t\t\t\t\t\t\tSCTP_INP_DECR_REF(inp);\n\t\t\t\t\t\t} else if (locked_tcb != stcb) {\n\t\t\t\t\t\t\tSCTP_TCB_LOCK(locked_tcb);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (locked_tcb) {\n\t\t\t\t\t\t\tatomic_subtract_int(&locked_tcb->asoc.refcnt, 1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tSCTP_INP_WUNLOCK(inp);\n\t\t\t\t\t\tSCTP_INP_INFO_RUNLOCK();\n\t\t\t\t\t\treturn (stcb);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n#endif\n#ifdef INET6\n\t\t\t\tcase AF_INET6:\n\t\t\t\t{\n\t\t\t\t\tstruct sockaddr_in6 *sin6, *rsin6;\n\n\t\t\t\t\tsin6 = (struct sockaddr_in6 *)&net->ro._l_addr;\n\t\t\t\t\trsin6 = (struct sockaddr_in6 *)remote;\n\t\t\t\t\tif (SCTP6_ARE_ADDR_EQUAL(sin6,\n\t\t\t\t\t    rsin6)) {\n\t\t\t\t\t\t/* found it */\n\t\t\t\t\t\tif (netp != NULL) {\n\t\t\t\t\t\t\t*netp = net;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (locked_tcb == NULL) {\n\t\t\t\t\t\t\tSCTP_INP_DECR_REF(inp);\n\t\t\t\t\t\t} else if (locked_tcb != stcb) {\n\t\t\t\t\t\t\tSCTP_TCB_LOCK(locked_tcb);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (locked_tcb) {\n\t\t\t\t\t\t\tatomic_subtract_int(&locked_tcb->asoc.refcnt, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tSCTP_INP_WUNLOCK(inp);\n\t\t\t\t\t\tSCTP_INP_INFO_RUNLOCK();\n\t\t\t\t\t\treturn (stcb);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n#endif\n#if defined(__Userspace__)\n\t\t\t\tcase AF_CONN:\n\t\t\t\t{\n\t\t\t\t\tstruct sockaddr_conn *sconn, *rsconn;\n\n\t\t\t\t\tsconn = (struct sockaddr_conn *)&net->ro._l_addr;\n\t\t\t\t\trsconn = (struct sockaddr_conn *)remote;\n\t\t\t\t\tif (sconn->sconn_addr == rsconn->sconn_addr) {\n\t\t\t\t\t\t/* found it */\n\t\t\t\t\t\tif (netp != NULL) {\n\t\t\t\t\t\t\t*netp = net;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (locked_tcb == NULL) {\n\t\t\t\t\t\t\tSCTP_INP_DECR_REF(inp);\n\t\t\t\t\t\t} else if (locked_tcb != stcb) {\n\t\t\t\t\t\t\tSCTP_TCB_LOCK(locked_tcb);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (locked_tcb) {\n\t\t\t\t\t\t\tatomic_subtract_int(&locked_tcb->asoc.refcnt, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tSCTP_INP_WUNLOCK(inp);\n\t\t\t\t\t\tSCTP_INP_INFO_RUNLOCK();\n\t\t\t\t\t\treturn (stcb);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n#endif\n\t\t\t\tdefault:\n\t\t\t\t\t/* TSNH */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSCTP_TCB_UNLOCK(stcb);\n\t\t}\n\t} else {\n\t\tSCTP_INP_WLOCK(inp);\n\t\tif (inp->sctp_flags & SCTP_PCB_FLAGS_SOCKET_ALLGONE) {\n\t\t\tgoto null_return;\n\t\t}\n\t\thead = &inp->sctp_tcbhash[SCTP_PCBHASH_ALLADDR(rport,\n\t\t                                               inp->sctp_hashmark)];\n\t\tLIST_FOREACH(stcb, head, sctp_tcbhash) {\n\t\t\tif (stcb->rport != rport) {\n\t\t\t\t/* remote port does not match */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tSCTP_TCB_LOCK(stcb);\n\t\t\tif (stcb->asoc.state & SCTP_STATE_ABOUT_TO_BE_FREED) {\n\t\t\t\tSCTP_TCB_UNLOCK(stcb);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (local && !sctp_does_stcb_own_this_addr(stcb, local)) {\n\t\t\t\tSCTP_TCB_UNLOCK(stcb);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* now look at the list of remote addresses */\n\t\t\tTAILQ_FOREACH(net, &stcb->asoc.nets, sctp_next) {\n#ifdef INVARIANTS\n\t\t\t\tif (net == (TAILQ_NEXT(net, sctp_next))) {\n\t\t\t\t\tpanic(\"Corrupt net list\");\n\t\t\t\t}\n#endif\n\t\t\t\tif (net->ro._l_addr.sa.sa_family !=\n\t\t\t\t    remote->sa_family) {\n\t\t\t\t\t/* not the same family */\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tswitch (remote->sa_family) {\n#ifdef INET\n\t\t\t\tcase AF_INET:\n\t\t\t\t{\n\t\t\t\t\tstruct sockaddr_in *sin, *rsin;\n\n\t\t\t\t\tsin = (struct sockaddr_in *)\n\t\t\t\t\t    &net->ro._l_addr;\n\t\t\t\t\trsin = (struct sockaddr_in *)remote;\n\t\t\t\t\tif (sin->sin_addr.s_addr ==\n\t\t\t\t\t    rsin->sin_addr.s_addr) {\n\t\t\t\t\t\t/* found it */\n\t\t\t\t\t\tif (netp != NULL) {\n\t\t\t\t\t\t\t*netp = net;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (locked_tcb == NULL) {\n\t\t\t\t\t\t\tSCTP_INP_DECR_REF(inp);\n\t\t\t\t\t\t} else if (locked_tcb != stcb) {\n\t\t\t\t\t\t\tSCTP_TCB_LOCK(locked_tcb);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (locked_tcb) {\n\t\t\t\t\t\t\tatomic_subtract_int(&locked_tcb->asoc.refcnt, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tSCTP_INP_WUNLOCK(inp);\n\t\t\t\t\t\tSCTP_INP_INFO_RUNLOCK();\n\t\t\t\t\t\treturn (stcb);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n#endif\n#ifdef INET6\n\t\t\t\tcase AF_INET6:\n\t\t\t\t{\n\t\t\t\t\tstruct sockaddr_in6 *sin6, *rsin6;\n\n\t\t\t\t\tsin6 = (struct sockaddr_in6 *)\n\t\t\t\t\t    &net->ro._l_addr;\n\t\t\t\t\trsin6 = (struct sockaddr_in6 *)remote;\n\t\t\t\t\tif (SCTP6_ARE_ADDR_EQUAL(sin6,\n\t\t\t\t\t    rsin6)) {\n\t\t\t\t\t\t/* found it */\n\t\t\t\t\t\tif (netp != NULL) {\n\t\t\t\t\t\t\t*netp = net;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (locked_tcb == NULL) {\n\t\t\t\t\t\t\tSCTP_INP_DECR_REF(inp);\n\t\t\t\t\t\t} else if (locked_tcb != stcb) {\n\t\t\t\t\t\t\tSCTP_TCB_LOCK(locked_tcb);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (locked_tcb) {\n\t\t\t\t\t\t\tatomic_subtract_int(&locked_tcb->asoc.refcnt, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tSCTP_INP_WUNLOCK(inp);\n\t\t\t\t\t\tSCTP_INP_INFO_RUNLOCK();\n\t\t\t\t\t\treturn (stcb);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n#endif\n#if defined(__Userspace__)\n\t\t\t\tcase AF_CONN:\n\t\t\t\t{\n\t\t\t\t\tstruct sockaddr_conn *sconn, *rsconn;\n\n\t\t\t\t\tsconn = (struct sockaddr_conn *)&net->ro._l_addr;\n\t\t\t\t\trsconn = (struct sockaddr_conn *)remote;\n\t\t\t\t\tif (sconn->sconn_addr == rsconn->sconn_addr) {\n\t\t\t\t\t\t/* found it */\n\t\t\t\t\t\tif (netp != NULL) {\n\t\t\t\t\t\t\t*netp = net;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (locked_tcb == NULL) {\n\t\t\t\t\t\t\tSCTP_INP_DECR_REF(inp);\n\t\t\t\t\t\t} else if (locked_tcb != stcb) {\n\t\t\t\t\t\t\tSCTP_TCB_LOCK(locked_tcb);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (locked_tcb) {\n\t\t\t\t\t\t\tatomic_subtract_int(&locked_tcb->asoc.refcnt, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tSCTP_INP_WUNLOCK(inp);\n\t\t\t\t\t\tSCTP_INP_INFO_RUNLOCK();\n\t\t\t\t\t\treturn (stcb);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n#endif\n\t\t\t\tdefault:\n\t\t\t\t\t/* TSNH */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSCTP_TCB_UNLOCK(stcb);\n\t\t}\n\t}\nnull_return:\n\t/* clean up for returning null */\n\tif (locked_tcb) {\n\t\tSCTP_TCB_LOCK(locked_tcb);\n\t\tatomic_subtract_int(&locked_tcb->asoc.refcnt, 1);\n\t}\n\tSCTP_INP_WUNLOCK(inp);\n\tSCTP_INP_INFO_RUNLOCK();\n\t/* not found */\n\treturn (NULL);\n}\n\n\n/*\n * Find an association for a specific endpoint using the association id given\n * out in the COMM_UP notification\n */\nstruct sctp_tcb *\nsctp_findasoc_ep_asocid_locked(struct sctp_inpcb *inp, sctp_assoc_t asoc_id, int want_lock)\n{\n\t/*\n\t * Use my the assoc_id to find a endpoint\n\t */\n\tstruct sctpasochead *head;\n\tstruct sctp_tcb *stcb;\n\tuint32_t id;\n\n\tif (inp == NULL) {\n\t\tSCTP_PRINTF(\"TSNH ep_associd\\n\");\n\t\treturn (NULL);\n\t}\n\tif (inp->sctp_flags & SCTP_PCB_FLAGS_SOCKET_ALLGONE) {\n\t\tSCTP_PRINTF(\"TSNH ep_associd0\\n\");\n\t\treturn (NULL);\n\t}\n\tid = (uint32_t)asoc_id;\n\thead = &inp->sctp_asocidhash[SCTP_PCBHASH_ASOC(id, inp->hashasocidmark)];\n\tif (head == NULL) {\n\t\t/* invalid id TSNH */\n\t\tSCTP_PRINTF(\"TSNH ep_associd1\\n\");\n\t\treturn (NULL);\n\t}\n\tLIST_FOREACH(stcb, head, sctp_tcbasocidhash) {\n\t\tif (stcb->asoc.assoc_id == id) {\n\t\t\tif (inp != stcb->sctp_ep) {\n\t\t\t\t/*\n\t\t\t\t * some other guy has the same id active (id\n\t\t\t\t * collision ??).\n\t\t\t\t */\n\t\t\t\tSCTP_PRINTF(\"TSNH ep_associd2\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (stcb->asoc.state & SCTP_STATE_ABOUT_TO_BE_FREED) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (want_lock) {\n\t\t\t\tSCTP_TCB_LOCK(stcb);\n\t\t\t}\n\t\t\treturn (stcb);\n\t\t}\n\t}\n\treturn (NULL);\n}\n\n\nstruct sctp_tcb *\nsctp_findassociation_ep_asocid(struct sctp_inpcb *inp, sctp_assoc_t asoc_id, int want_lock)\n{\n\tstruct sctp_tcb *stcb;\n\n\tSCTP_INP_RLOCK(inp);\n\tstcb = sctp_findasoc_ep_asocid_locked(inp, asoc_id, want_lock);\n\tSCTP_INP_RUNLOCK(inp);\n\treturn (stcb);\n}\n\n\n/*\n * Endpoint probe expects that the INP_INFO is locked.\n */\nstatic struct sctp_inpcb *\nsctp_endpoint_probe(struct sockaddr *nam, struct sctppcbhead *head,\n\t\t    uint16_t lport, uint32_t vrf_id)\n{\n\tstruct sctp_inpcb *inp;\n\tstruct sctp_laddr *laddr;\n#ifdef INET\n\tstruct sockaddr_in *sin;\n#endif\n#ifdef INET6\n\tstruct sockaddr_in6 *sin6;\n\tstruct sockaddr_in6 *intf_addr6;\n#endif\n#if defined(__Userspace__)\n\tstruct sockaddr_conn *sconn;\n#endif\n#ifdef SCTP_MVRF\n\tint i;\n#endif\n\tint  fnd;\n\n#ifdef INET\n\tsin = NULL;\n#endif\n#ifdef INET6\n\tsin6 = NULL;\n#endif\n#if defined(__Userspace__)\n\tsconn = NULL;\n#endif\n\tswitch (nam->sa_family) {\n#ifdef INET\n\tcase AF_INET:\n\t\tsin = (struct sockaddr_in *)nam;\n\t\tbreak;\n#endif\n#ifdef INET6\n\tcase AF_INET6:\n\t\tsin6 = (struct sockaddr_in6 *)nam;\n\t\tbreak;\n#endif\n#if defined(__Userspace__)\n\tcase AF_CONN:\n\t\tsconn = (struct sockaddr_conn *)nam;\n\t\tbreak;\n#endif\n\tdefault:\n\t\t/* unsupported family */\n\t\treturn (NULL);\n\t}\n\n\tif (head == NULL)\n\t\treturn (NULL);\n\n\tLIST_FOREACH(inp, head, sctp_hash) {\n\t\tSCTP_INP_RLOCK(inp);\n\t\tif (inp->sctp_flags & SCTP_PCB_FLAGS_SOCKET_ALLGONE) {\n\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((inp->sctp_flags & SCTP_PCB_FLAGS_BOUNDALL) &&\n\t\t    (inp->sctp_lport == lport)) {\n\t\t\t/* got it */\n\t\t\tswitch (nam->sa_family) {\n#ifdef INET\n\t\t\tcase AF_INET:\n\t\t\t\tif ((inp->sctp_flags & SCTP_PCB_FLAGS_BOUND_V6) &&\n\t\t\t\t    SCTP_IPV6_V6ONLY(inp)) {\n\t\t\t\t\t/* IPv4 on a IPv6 socket with ONLY IPv6 set */\n\t\t\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n#if defined(__FreeBSD__)\n\t\t\t\tif (prison_check_ip4(inp->ip_inp.inp.inp_cred,\n\t\t\t\t                     &sin->sin_addr) != 0) {\n\t\t\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n#endif\n\t\t\t\tbreak;\n#endif\n#ifdef INET6\n\t\t\tcase AF_INET6:\n\t\t\t\t/* A V6 address and the endpoint is NOT bound V6 */\n\t\t\t\tif ((inp->sctp_flags & SCTP_PCB_FLAGS_BOUND_V6) == 0) {\n\t\t\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n#if defined(__FreeBSD__)\n\t\t\t\tif (prison_check_ip6(inp->ip_inp.inp.inp_cred,\n\t\t\t\t                     &sin6->sin6_addr) != 0) {\n\t\t\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n#endif\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* does a VRF id match? */\n\t\t\tfnd = 0;\n#ifdef SCTP_MVRF\n\t\t\tfor (i = 0; i < inp->num_vrfs; i++) {\n\t\t\t\tif (inp->m_vrf_ids[i] == vrf_id) {\n\t\t\t\t\tfnd = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n#else\n\t\t\tif (inp->def_vrf_id == vrf_id)\n\t\t\t\tfnd = 1;\n#endif\n\n\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\tif (!fnd)\n\t\t\t\tcontinue;\n\t\t\treturn (inp);\n\t\t}\n\t\tSCTP_INP_RUNLOCK(inp);\n\t}\n\tswitch (nam->sa_family) {\n#ifdef INET\n\tcase AF_INET:\n\t\tif (sin->sin_addr.s_addr == INADDR_ANY) {\n\t\t\t/* Can't hunt for one that has no address specified */\n\t\t\treturn (NULL);\n\t\t}\n\t\tbreak;\n#endif\n#ifdef INET6\n\tcase AF_INET6:\n\t\tif (IN6_IS_ADDR_UNSPECIFIED(&sin6->sin6_addr)) {\n\t\t\t/* Can't hunt for one that has no address specified */\n\t\t\treturn (NULL);\n\t\t}\n\t\tbreak;\n#endif\n#if defined(__Userspace__)\n\tcase AF_CONN:\n\t\tif (sconn->sconn_addr == NULL) {\n\t\t\treturn (NULL);\n\t\t}\n\t\tbreak;\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\t/*\n\t * ok, not bound to all so see if we can find a EP bound to this\n\t * address.\n\t */\n\tLIST_FOREACH(inp, head, sctp_hash) {\n\t\tSCTP_INP_RLOCK(inp);\n\t\tif (inp->sctp_flags & SCTP_PCB_FLAGS_SOCKET_ALLGONE) {\n\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((inp->sctp_flags & SCTP_PCB_FLAGS_BOUNDALL)) {\n\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Ok this could be a likely candidate, look at all of its\n\t\t * addresses\n\t\t */\n\t\tif (inp->sctp_lport != lport) {\n\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\tcontinue;\n\t\t}\n\t\t/* does a VRF id match? */\n\t\tfnd = 0;\n#ifdef SCTP_MVRF\n\t\tfor (i = 0; i < inp->num_vrfs; i++) {\n\t\t\tif (inp->m_vrf_ids[i] == vrf_id) {\n\t\t\t\tfnd = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n#else\n\t\tif (inp->def_vrf_id == vrf_id)\n\t\t\tfnd = 1;\n\n#endif\n\t\tif (!fnd) {\n\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\tcontinue;\n\t\t}\n\t\tLIST_FOREACH(laddr, &inp->sctp_addr_list, sctp_nxt_addr) {\n\t\t\tif (laddr->ifa == NULL) {\n\t\t\t\tSCTPDBG(SCTP_DEBUG_PCB1, \"%s: NULL ifa\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tSCTPDBG(SCTP_DEBUG_PCB1, \"Ok laddr->ifa:%p is possible, \",\n\t\t\t\t(void *)laddr->ifa);\n\t\t\tif (laddr->ifa->localifa_flags & SCTP_BEING_DELETED) {\n\t\t\t\tSCTPDBG(SCTP_DEBUG_PCB1, \"Huh IFA being deleted\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (laddr->ifa->address.sa.sa_family == nam->sa_family) {\n\t\t\t\t/* possible, see if it matches */\n\t\t\t\tswitch (nam->sa_family) {\n#ifdef INET\n\t\t\t\tcase AF_INET:\n#if defined(__APPLE__)\n\t\t\t\t\tif (sin == NULL) {\n\t\t\t\t\t\t/* TSNH */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tif (sin->sin_addr.s_addr ==\n\t\t\t\t\t    laddr->ifa->address.sin.sin_addr.s_addr) {\n\t\t\t\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\t\t\t\treturn (inp);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n#endif\n#ifdef INET6\n\t\t\t\tcase AF_INET6:\n\t\t\t\t\tintf_addr6 = &laddr->ifa->address.sin6;\n\t\t\t\t\tif (SCTP6_ARE_ADDR_EQUAL(sin6,\n\t\t\t\t\t    intf_addr6)) {\n\t\t\t\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\t\t\t\treturn (inp);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n#endif\n#if defined(__Userspace__)\n\t\t\t\tcase AF_CONN:\n\t\t\t\t\tif (sconn->sconn_addr == laddr->ifa->address.sconn.sconn_addr) {\n\t\t\t\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\t\t\t\treturn (inp);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n#endif\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSCTP_INP_RUNLOCK(inp);\n\t}\n\treturn (NULL);\n}\n\n\nstatic struct sctp_inpcb *\nsctp_isport_inuse(struct sctp_inpcb *inp, uint16_t lport, uint32_t vrf_id)\n{\n\tstruct sctppcbhead *head;\n\tstruct sctp_inpcb *t_inp;\n#ifdef SCTP_MVRF\n\tint i;\n#endif\n\tint fnd;\n\n\thead = &SCTP_BASE_INFO(sctp_ephash)[SCTP_PCBHASH_ALLADDR(lport,\n\t    SCTP_BASE_INFO(hashmark))];\n\tLIST_FOREACH(t_inp, head, sctp_hash) {\n\t\tif (t_inp->sctp_lport != lport) {\n\t\t\tcontinue;\n\t\t}\n\t\t/* is it in the VRF in question */\n\t\tfnd = 0;\n#ifdef SCTP_MVRF\n\t\tfor (i = 0; i < inp->num_vrfs; i++) {\n\t\t\tif (t_inp->m_vrf_ids[i] == vrf_id) {\n\t\t\t\tfnd = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n#else\n\t\tif (t_inp->def_vrf_id == vrf_id)\n\t\t\tfnd = 1;\n#endif\n\t\tif (!fnd)\n\t\t\tcontinue;\n\n\t\t/* This one is in use. */\n\t\t/* check the v6/v4 binding issue */\n\t\tif ((t_inp->sctp_flags & SCTP_PCB_FLAGS_BOUND_V6) &&\n\t\t    SCTP_IPV6_V6ONLY(t_inp)) {\n\t\t\tif (inp->sctp_flags & SCTP_PCB_FLAGS_BOUND_V6) {\n\t\t\t\t/* collision in V6 space */\n\t\t\t\treturn (t_inp);\n\t\t\t} else {\n\t\t\t\t/* inp is BOUND_V4 no conflict */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else if (t_inp->sctp_flags & SCTP_PCB_FLAGS_BOUND_V6) {\n\t\t\t/* t_inp is bound v4 and v6, conflict always */\n\t\t\treturn (t_inp);\n\t\t} else {\n\t\t\t/* t_inp is bound only V4 */\n\t\t\tif ((inp->sctp_flags & SCTP_PCB_FLAGS_BOUND_V6) &&\n\t\t\t    SCTP_IPV6_V6ONLY(inp)) {\n\t\t\t\t/* no conflict */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* else fall through to conflict */\n\t\t}\n\t\treturn (t_inp);\n\t}\n\treturn (NULL);\n}\n\n\nint\nsctp_swap_inpcb_for_listen(struct sctp_inpcb *inp)\n{\n\t/* For 1-2-1 with port reuse */\n\tstruct sctppcbhead *head;\n\tstruct sctp_inpcb *tinp, *ninp;\n\n\tif (sctp_is_feature_off(inp, SCTP_PCB_FLAGS_PORTREUSE)) {\n\t\t/* only works with port reuse on */\n\t\treturn (-1);\n\t}\n\tif ((inp->sctp_flags & SCTP_PCB_FLAGS_IN_TCPPOOL) == 0) {\n\t\treturn (0);\n\t}\n\tSCTP_INP_RUNLOCK(inp);\n\tSCTP_INP_INFO_WLOCK();\n\thead = &SCTP_BASE_INFO(sctp_ephash)[SCTP_PCBHASH_ALLADDR(inp->sctp_lport,\n\t                                    SCTP_BASE_INFO(hashmark))];\n\t/* Kick out all non-listeners to the TCP hash */\n\tLIST_FOREACH_SAFE(tinp, head, sctp_hash, ninp) {\n\t\tif (tinp->sctp_lport != inp->sctp_lport) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (tinp->sctp_flags & SCTP_PCB_FLAGS_SOCKET_ALLGONE) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (tinp->sctp_flags & SCTP_PCB_FLAGS_SOCKET_GONE) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (SCTP_IS_LISTENING(tinp)) {\n\t\t\tcontinue;\n\t\t}\n\t\tSCTP_INP_WLOCK(tinp);\n\t\tLIST_REMOVE(tinp, sctp_hash);\n\t\thead = &SCTP_BASE_INFO(sctp_tcpephash)[SCTP_PCBHASH_ALLADDR(tinp->sctp_lport, SCTP_BASE_INFO(hashtcpmark))];\n\t\ttinp->sctp_flags |= SCTP_PCB_FLAGS_IN_TCPPOOL;\n\t\tLIST_INSERT_HEAD(head, tinp, sctp_hash);\n\t\tSCTP_INP_WUNLOCK(tinp);\n\t}\n\tSCTP_INP_WLOCK(inp);\n\t/* Pull from where he was */\n\tLIST_REMOVE(inp, sctp_hash);\n\tinp->sctp_flags &= ~SCTP_PCB_FLAGS_IN_TCPPOOL;\n\thead = &SCTP_BASE_INFO(sctp_ephash)[SCTP_PCBHASH_ALLADDR(inp->sctp_lport, SCTP_BASE_INFO(hashmark))];\n\tLIST_INSERT_HEAD(head, inp, sctp_hash);\n\tSCTP_INP_WUNLOCK(inp);\n\tSCTP_INP_RLOCK(inp);\n\tSCTP_INP_INFO_WUNLOCK();\n\treturn (0);\n}\n\n\nstruct sctp_inpcb *\nsctp_pcb_findep(struct sockaddr *nam, int find_tcp_pool, int have_lock,\n\t\tuint32_t vrf_id)\n{\n\t/*\n\t * First we check the hash table to see if someone has this port\n\t * bound with just the port.\n\t */\n\tstruct sctp_inpcb *inp;\n\tstruct sctppcbhead *head;\n\tint lport;\n\tunsigned int i;\n#ifdef INET\n\tstruct sockaddr_in *sin;\n#endif\n#ifdef INET6\n\tstruct sockaddr_in6 *sin6;\n#endif\n#if defined(__Userspace__)\n\tstruct sockaddr_conn *sconn;\n#endif\n\n\tswitch (nam->sa_family) {\n#ifdef INET\n\tcase AF_INET:\n\t\tsin = (struct sockaddr_in *)nam;\n\t\tlport = sin->sin_port;\n\t\tbreak;\n#endif\n#ifdef INET6\n\tcase AF_INET6:\n\t\tsin6 = (struct sockaddr_in6 *)nam;\n\t\tlport = sin6->sin6_port;\n\t\tbreak;\n#endif\n#if defined(__Userspace__)\n\tcase AF_CONN:\n\t\tsconn = (struct sockaddr_conn *)nam;\n\t\tlport = sconn->sconn_port;\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn (NULL);\n\t}\n\t/*\n\t * I could cheat here and just cast to one of the types but we will\n\t * do it right. It also provides the check against an Unsupported\n\t * type too.\n\t */\n\t/* Find the head of the ALLADDR chain */\n\tif (have_lock == 0) {\n\t\tSCTP_INP_INFO_RLOCK();\n\t}\n\thead = &SCTP_BASE_INFO(sctp_ephash)[SCTP_PCBHASH_ALLADDR(lport,\n\t    SCTP_BASE_INFO(hashmark))];\n\tinp = sctp_endpoint_probe(nam, head, lport, vrf_id);\n\n\t/*\n\t * If the TCP model exists it could be that the main listening\n\t * endpoint is gone but there still exists a connected socket for this\n\t * guy. If so we can return the first one that we find. This may NOT\n\t * be the correct one so the caller should be wary on the returned INP.\n\t * Currently the only caller that sets find_tcp_pool is in bindx where\n\t * we are verifying that a user CAN bind the address. He either\n\t * has bound it already, or someone else has, or its open to bind,\n\t * so this is good enough.\n\t */\n\tif (inp == NULL && find_tcp_pool) {\n\t\tfor (i = 0; i < SCTP_BASE_INFO(hashtcpmark) + 1; i++) {\n\t\t\thead = &SCTP_BASE_INFO(sctp_tcpephash)[i];\n\t\t\tinp = sctp_endpoint_probe(nam, head, lport, vrf_id);\n\t\t\tif (inp) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (inp) {\n\t\tSCTP_INP_INCR_REF(inp);\n\t}\n\tif (have_lock == 0) {\n\t\tSCTP_INP_INFO_RUNLOCK();\n\t}\n\treturn (inp);\n}\n\n\n/*\n * Find an association for an endpoint with the pointer to whom you want to\n * send to and the endpoint pointer. The address can be IPv4 or IPv6. We may\n * need to change the *to to some other struct like a mbuf...\n */\nstruct sctp_tcb *\nsctp_findassociation_addr_sa(struct sockaddr *from, struct sockaddr *to,\n    struct sctp_inpcb **inp_p, struct sctp_nets **netp, int find_tcp_pool,\n    uint32_t vrf_id)\n{\n\tstruct sctp_inpcb *inp = NULL;\n\tstruct sctp_tcb *stcb;\n\n\tSCTP_INP_INFO_RLOCK();\n\tif (find_tcp_pool) {\n\t\tif (inp_p != NULL) {\n\t\t\tstcb = sctp_tcb_special_locate(inp_p, from, to, netp,\n\t\t\t                               vrf_id);\n\t\t} else {\n\t\t\tstcb = sctp_tcb_special_locate(&inp, from, to, netp,\n\t\t\t                               vrf_id);\n\t\t}\n\t\tif (stcb != NULL) {\n\t\t\tSCTP_INP_INFO_RUNLOCK();\n\t\t\treturn (stcb);\n\t\t}\n\t}\n\tinp = sctp_pcb_findep(to, 0, 1, vrf_id);\n\tif (inp_p != NULL) {\n\t\t*inp_p = inp;\n\t}\n\tSCTP_INP_INFO_RUNLOCK();\n\tif (inp == NULL) {\n\t\treturn (NULL);\n\t}\n\t/*\n\t * ok, we have an endpoint, now lets find the assoc for it (if any)\n\t * we now place the source address or from in the to of the find\n\t * endpoint call. Since in reality this chain is used from the\n\t * inbound packet side.\n\t */\n\tif (inp_p != NULL) {\n\t\tstcb = sctp_findassociation_ep_addr(inp_p, from, netp, to,\n\t\t                                    NULL);\n\t} else {\n\t\tstcb = sctp_findassociation_ep_addr(&inp, from, netp, to,\n\t\t                                    NULL);\n\t}\n\treturn (stcb);\n}\n\n\n/*\n * This routine will grub through the mbuf that is a INIT or INIT-ACK and\n * find all addresses that the sender has specified in any address list. Each\n * address will be used to lookup the TCB and see if one exits.\n */\nstatic struct sctp_tcb *\nsctp_findassociation_special_addr(struct mbuf *m, int offset,\n    struct sctphdr *sh, struct sctp_inpcb **inp_p, struct sctp_nets **netp,\n    struct sockaddr *dst)\n{\n\tstruct sctp_paramhdr *phdr, param_buf;\n#if defined(INET) || defined(INET6)\n\tstruct sctp_tcb *stcb;\n\tuint16_t ptype;\n#endif\n\tuint16_t plen;\n#ifdef INET\n\tstruct sockaddr_in sin4;\n#endif\n#ifdef INET6\n\tstruct sockaddr_in6 sin6;\n#endif\n\n#ifdef INET\n\tmemset(&sin4, 0, sizeof(sin4));\n#ifdef HAVE_SIN_LEN\n\tsin4.sin_len = sizeof(sin4);\n#endif\n\tsin4.sin_family = AF_INET;\n\tsin4.sin_port = sh->src_port;\n#endif\n#ifdef INET6\n\tmemset(&sin6, 0, sizeof(sin6));\n#ifdef HAVE_SIN6_LEN\n\tsin6.sin6_len = sizeof(sin6);\n#endif\n\tsin6.sin6_family = AF_INET6;\n\tsin6.sin6_port = sh->src_port;\n#endif\n\n\toffset += sizeof(struct sctp_init_chunk);\n\n\tphdr = sctp_get_next_param(m, offset, &param_buf, sizeof(param_buf));\n\twhile (phdr != NULL) {\n\t\t/* now we must see if we want the parameter */\n#if defined(INET) || defined(INET6)\n\t\tptype = ntohs(phdr->param_type);\n#endif\n\t\tplen = ntohs(phdr->param_length);\n\t\tif (plen == 0) {\n\t\t\tbreak;\n\t\t}\n#ifdef INET\n\t\tif (ptype == SCTP_IPV4_ADDRESS &&\n\t\t    plen == sizeof(struct sctp_ipv4addr_param)) {\n\t\t\t/* Get the rest of the address */\n\t\t\tstruct sctp_ipv4addr_param ip4_param, *p4;\n\n\t\t\tphdr = sctp_get_next_param(m, offset,\n\t\t\t    (struct sctp_paramhdr *)&ip4_param, sizeof(ip4_param));\n\t\t\tif (phdr == NULL) {\n\t\t\t\treturn (NULL);\n\t\t\t}\n\t\t\tp4 = (struct sctp_ipv4addr_param *)phdr;\n\t\t\tmemcpy(&sin4.sin_addr, &p4->addr, sizeof(p4->addr));\n\t\t\t/* look it up */\n\t\t\tstcb = sctp_findassociation_ep_addr(inp_p,\n\t\t\t    (struct sockaddr *)&sin4, netp, dst, NULL);\n\t\t\tif (stcb != NULL) {\n\t\t\t\treturn (stcb);\n\t\t\t}\n\t\t}\n#endif\n#ifdef INET6\n\t\tif (ptype == SCTP_IPV6_ADDRESS &&\n\t\t    plen == sizeof(struct sctp_ipv6addr_param)) {\n\t\t\t/* Get the rest of the address */\n\t\t\tstruct sctp_ipv6addr_param ip6_param, *p6;\n\n\t\t\tphdr = sctp_get_next_param(m, offset,\n\t\t\t    (struct sctp_paramhdr *)&ip6_param, sizeof(ip6_param));\n\t\t\tif (phdr == NULL) {\n\t\t\t\treturn (NULL);\n\t\t\t}\n\t\t\tp6 = (struct sctp_ipv6addr_param *)phdr;\n\t\t\tmemcpy(&sin6.sin6_addr, &p6->addr, sizeof(p6->addr));\n\t\t\t/* look it up */\n\t\t\tstcb = sctp_findassociation_ep_addr(inp_p,\n\t\t\t    (struct sockaddr *)&sin6, netp, dst, NULL);\n\t\t\tif (stcb != NULL) {\n\t\t\t\treturn (stcb);\n\t\t\t}\n\t\t}\n#endif\n\t\toffset += SCTP_SIZE32(plen);\n\t\tphdr = sctp_get_next_param(m, offset, &param_buf,\n\t\t\t\t\t   sizeof(param_buf));\n\t}\n\treturn (NULL);\n}\n\nstatic struct sctp_tcb *\nsctp_findassoc_by_vtag(struct sockaddr *from, struct sockaddr *to, uint32_t vtag,\n\t\t       struct sctp_inpcb **inp_p, struct sctp_nets **netp, uint16_t rport,\n\t\t       uint16_t lport, int skip_src_check, uint32_t vrf_id, uint32_t remote_tag)\n{\n\t/*\n\t * Use my vtag to hash. If we find it we then verify the source addr\n\t * is in the assoc. If all goes well we save a bit on rec of a\n\t * packet.\n\t */\n\tstruct sctpasochead *head;\n\tstruct sctp_nets *net;\n\tstruct sctp_tcb *stcb;\n#ifdef SCTP_MVRF\n\tunsigned int i;\n#endif\n\n\tSCTP_INP_INFO_RLOCK();\n\thead = &SCTP_BASE_INFO(sctp_asochash)[SCTP_PCBHASH_ASOC(vtag,\n\t                                                        SCTP_BASE_INFO(hashasocmark))];\n\tLIST_FOREACH(stcb, head, sctp_asocs) {\n\t\tSCTP_INP_RLOCK(stcb->sctp_ep);\n\t\tif (stcb->sctp_ep->sctp_flags & SCTP_PCB_FLAGS_SOCKET_ALLGONE) {\n\t\t\tSCTP_INP_RUNLOCK(stcb->sctp_ep);\n\t\t\tcontinue;\n\t\t}\n#ifdef SCTP_MVRF\n\t\tfor (i = 0; i < stcb->sctp_ep->num_vrfs; i++) {\n\t\t\tif (stcb->sctp_ep->m_vrf_ids[i] == vrf_id) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == stcb->sctp_ep->num_vrfs) {\n\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\tcontinue;\n\t\t}\n#else\n\t\tif (stcb->sctp_ep->def_vrf_id != vrf_id) {\n\t\t\tSCTP_INP_RUNLOCK(stcb->sctp_ep);\n\t\t\tcontinue;\n\t\t}\n#endif\n\t\tSCTP_TCB_LOCK(stcb);\n\t\tSCTP_INP_RUNLOCK(stcb->sctp_ep);\n\t\tif (stcb->asoc.my_vtag == vtag) {\n\t\t\t/* candidate */\n\t\t\tif (stcb->rport != rport) {\n\t\t\t\tSCTP_TCB_UNLOCK(stcb);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (stcb->sctp_ep->sctp_lport != lport) {\n\t\t\t\tSCTP_TCB_UNLOCK(stcb);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (stcb->asoc.state & SCTP_STATE_ABOUT_TO_BE_FREED) {\n\t\t\t\tSCTP_TCB_UNLOCK(stcb);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* RRS:Need toaddr check here */\n\t\t\tif (sctp_does_stcb_own_this_addr(stcb, to) == 0) {\n\t\t\t        /* Endpoint does not own this address */\n\t\t\t\tSCTP_TCB_UNLOCK(stcb);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (remote_tag) {\n\t\t\t\t/* If we have both vtags that's all we match on */\n\t\t\t\tif (stcb->asoc.peer_vtag == remote_tag) {\n\t\t\t\t\t/* If both tags match we consider it conclusive\n\t\t\t\t\t * and check NO source/destination addresses\n\t\t\t\t\t */\n\t\t\t\t\tgoto conclusive;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (skip_src_check) {\n\t\t\tconclusive:\n\t\t\t        if (from) {\n\t\t\t\t\t*netp = sctp_findnet(stcb, from);\n\t\t\t\t} else {\n\t\t\t\t\t*netp = NULL;\t/* unknown */\n\t\t\t\t}\n\t\t\t\tif (inp_p)\n\t\t\t\t\t*inp_p = stcb->sctp_ep;\n\t\t\t\tSCTP_INP_INFO_RUNLOCK();\n\t\t\t\treturn (stcb);\n\t\t\t}\n\t\t\tnet = sctp_findnet(stcb, from);\n\t\t\tif (net) {\n\t\t\t\t/* yep its him. */\n\t\t\t\t*netp = net;\n\t\t\t\tSCTP_STAT_INCR(sctps_vtagexpress);\n\t\t\t\t*inp_p = stcb->sctp_ep;\n\t\t\t\tSCTP_INP_INFO_RUNLOCK();\n\t\t\t\treturn (stcb);\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * not him, this should only happen in rare\n\t\t\t\t * cases so I peg it.\n\t\t\t\t */\n\t\t\t\tSCTP_STAT_INCR(sctps_vtagbogus);\n\t\t\t}\n\t\t}\n\t\tSCTP_TCB_UNLOCK(stcb);\n\t}\n\tSCTP_INP_INFO_RUNLOCK();\n\treturn (NULL);\n}\n\n\n/*\n * Find an association with the pointer to the inbound IP packet. This can be\n * a IPv4 or IPv6 packet.\n */\nstruct sctp_tcb *\nsctp_findassociation_addr(struct mbuf *m, int offset,\n    struct sockaddr *src, struct sockaddr *dst,\n    struct sctphdr *sh, struct sctp_chunkhdr *ch,\n    struct sctp_inpcb **inp_p, struct sctp_nets **netp, uint32_t vrf_id)\n{\n\tstruct sctp_tcb *stcb;\n\tstruct sctp_inpcb *inp;\n\n\tif (sh->v_tag) {\n\t\t/* we only go down this path if vtag is non-zero */\n\t\tstcb = sctp_findassoc_by_vtag(src, dst, ntohl(sh->v_tag),\n\t\t                              inp_p, netp, sh->src_port, sh->dest_port, 0, vrf_id, 0);\n\t\tif (stcb) {\n\t\t\treturn (stcb);\n\t\t}\n\t}\n\n\tif (inp_p) {\n\t\tstcb = sctp_findassociation_addr_sa(src, dst, inp_p, netp,\n\t\t                                    1, vrf_id);\n\t\tinp = *inp_p;\n\t} else {\n\t\tstcb = sctp_findassociation_addr_sa(src, dst, &inp, netp,\n\t\t                                    1, vrf_id);\n\t}\n\tSCTPDBG(SCTP_DEBUG_PCB1, \"stcb:%p inp:%p\\n\", (void *)stcb, (void *)inp);\n\tif (stcb == NULL && inp) {\n\t\t/* Found a EP but not this address */\n\t\tif ((ch->chunk_type == SCTP_INITIATION) ||\n\t\t    (ch->chunk_type == SCTP_INITIATION_ACK)) {\n\t\t\t/*-\n\t\t\t * special hook, we do NOT return linp or an\n\t\t\t * association that is linked to an existing\n\t\t\t * association that is under the TCP pool (i.e. no\n\t\t\t * listener exists). The endpoint finding routine\n\t\t\t * will always find a listener before examining the\n\t\t\t * TCP pool.\n\t\t\t */\n\t\t\tif (inp->sctp_flags & SCTP_PCB_FLAGS_IN_TCPPOOL) {\n\t\t\t\tif (inp_p) {\n\t\t\t\t\t*inp_p = NULL;\n\t\t\t\t}\n\t\t\t\treturn (NULL);\n\t\t\t}\n\t\t\tstcb = sctp_findassociation_special_addr(m,\n\t\t\t    offset, sh, &inp, netp, dst);\n\t\t\tif (inp_p != NULL) {\n\t\t\t\t*inp_p = inp;\n\t\t\t}\n\t\t}\n\t}\n\tSCTPDBG(SCTP_DEBUG_PCB1, \"stcb is %p\\n\", (void *)stcb);\n\treturn (stcb);\n}\n\n/*\n * lookup an association by an ASCONF lookup address.\n * if the lookup address is 0.0.0.0 or ::0, use the vtag to do the lookup\n */\nstruct sctp_tcb *\nsctp_findassociation_ep_asconf(struct mbuf *m, int offset,\n\t\t\t       struct sockaddr *dst, struct sctphdr *sh,\n                               struct sctp_inpcb **inp_p, struct sctp_nets **netp, uint32_t vrf_id)\n{\n\tstruct sctp_tcb *stcb;\n\tunion sctp_sockstore remote_store;\n\tstruct sctp_paramhdr param_buf, *phdr;\n\tint ptype;\n\tint zero_address = 0;\n#ifdef INET\n\tstruct sockaddr_in *sin;\n#endif\n#ifdef INET6\n\tstruct sockaddr_in6 *sin6;\n#endif\n\n\tmemset(&remote_store, 0, sizeof(remote_store));\n\tphdr = sctp_get_next_param(m, offset + sizeof(struct sctp_asconf_chunk),\n\t\t\t\t   &param_buf, sizeof(struct sctp_paramhdr));\n\tif (phdr == NULL) {\n\t\tSCTPDBG(SCTP_DEBUG_INPUT3, \"%s: failed to get asconf lookup addr\\n\",\n\t\t\t__func__);\n\t\treturn NULL;\n\t}\n\tptype = (int)((uint32_t) ntohs(phdr->param_type));\n\t/* get the correlation address */\n\tswitch (ptype) {\n#ifdef INET6\n\tcase SCTP_IPV6_ADDRESS:\n\t{\n\t\t/* ipv6 address param */\n\t\tstruct sctp_ipv6addr_param *p6, p6_buf;\n\n\t\tif (ntohs(phdr->param_length) != sizeof(struct sctp_ipv6addr_param)) {\n\t\t\treturn NULL;\n\t\t}\n\t\tp6 = (struct sctp_ipv6addr_param *)sctp_get_next_param(m,\n\t\t\t\t\t\t\t\t       offset + sizeof(struct sctp_asconf_chunk),\n\t\t\t\t\t\t\t\t       &p6_buf.ph, sizeof(p6_buf));\n\t\tif (p6 == NULL) {\n\t\t\tSCTPDBG(SCTP_DEBUG_INPUT3, \"%s: failed to get asconf v6 lookup addr\\n\",\n\t\t\t\t__func__);\n\t\t\treturn (NULL);\n\t\t}\n\t\tsin6 = &remote_store.sin6;\n\t\tsin6->sin6_family = AF_INET6;\n#ifdef HAVE_SIN6_LEN\n\t\tsin6->sin6_len = sizeof(*sin6);\n#endif\n\t\tsin6->sin6_port = sh->src_port;\n\t\tmemcpy(&sin6->sin6_addr, &p6->addr, sizeof(struct in6_addr));\n\t\tif (IN6_IS_ADDR_UNSPECIFIED(&sin6->sin6_addr))\n\t\t\tzero_address = 1;\n\t\tbreak;\n\t}\n#endif\n#ifdef INET\n\tcase SCTP_IPV4_ADDRESS:\n\t{\n\t\t/* ipv4 address param */\n\t\tstruct sctp_ipv4addr_param *p4, p4_buf;\n\n\t\tif (ntohs(phdr->param_length) != sizeof(struct sctp_ipv4addr_param)) {\n\t\t\treturn NULL;\n\t\t}\n\t\tp4 = (struct sctp_ipv4addr_param *)sctp_get_next_param(m,\n\t\t\t\t\t\t\t\t       offset + sizeof(struct sctp_asconf_chunk),\n\t\t\t\t\t\t\t\t       &p4_buf.ph, sizeof(p4_buf));\n\t\tif (p4 == NULL) {\n\t\t\tSCTPDBG(SCTP_DEBUG_INPUT3, \"%s: failed to get asconf v4 lookup addr\\n\",\n\t\t\t\t__func__);\n\t\t\treturn (NULL);\n\t\t}\n\t\tsin = &remote_store.sin;\n\t\tsin->sin_family = AF_INET;\n#ifdef HAVE_SIN_LEN\n\t\tsin->sin_len = sizeof(*sin);\n#endif\n\t\tsin->sin_port = sh->src_port;\n\t\tmemcpy(&sin->sin_addr, &p4->addr, sizeof(struct in_addr));\n\t\tif (sin->sin_addr.s_addr == INADDR_ANY)\n\t\t\tzero_address = 1;\n\t\tbreak;\n\t}\n#endif\n\tdefault:\n\t\t/* invalid address param type */\n\t\treturn NULL;\n\t}\n\n\tif (zero_address) {\n\t        stcb = sctp_findassoc_by_vtag(NULL, dst, ntohl(sh->v_tag), inp_p,\n\t\t\t\t\t      netp, sh->src_port, sh->dest_port, 1, vrf_id, 0);\n\t\tif (stcb != NULL) {\n\t\t\tSCTP_INP_DECR_REF(*inp_p);\n\t\t}\n\t} else {\n\t\tstcb = sctp_findassociation_ep_addr(inp_p,\n\t\t    &remote_store.sa, netp,\n\t\t    dst, NULL);\n\t}\n\treturn (stcb);\n}\n\n\n/*\n * allocate a sctp_inpcb and setup a temporary binding to a port/all\n * addresses. This way if we don't get a bind we by default pick a ephemeral\n * port with all addresses bound.\n */\nint\nsctp_inpcb_alloc(struct socket *so, uint32_t vrf_id)\n{\n\t/*\n\t * we get called when a new endpoint starts up. We need to allocate\n\t * the sctp_inpcb structure from the zone and init it. Mark it as\n\t * unbound and find a port that we can use as an ephemeral with\n\t * INADDR_ANY. If the user binds later no problem we can then add in\n\t * the specific addresses. And setup the default parameters for the\n\t * EP.\n\t */\n\tint i, error;\n\tstruct sctp_inpcb *inp;\n\tstruct sctp_pcb *m;\n\tstruct timeval time;\n\tsctp_sharedkey_t *null_key;\n\n\terror = 0;\n\n\tSCTP_INP_INFO_WLOCK();\n\tinp = SCTP_ZONE_GET(SCTP_BASE_INFO(ipi_zone_ep), struct sctp_inpcb);\n\tif (inp == NULL) {\n\t\tSCTP_PRINTF(\"Out of SCTP-INPCB structures - no resources\\n\");\n\t\tSCTP_INP_INFO_WUNLOCK();\n\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, ENOBUFS);\n\t\treturn (ENOBUFS);\n\t}\n\t/* zap it */\n\tmemset(inp, 0, sizeof(*inp));\n\n\t/* bump generations */\n#if defined(__APPLE__)\n\tinp->ip_inp.inp.inp_state = INPCB_STATE_INUSE;\n#endif\n\t/* setup socket pointers */\n\tinp->sctp_socket = so;\n\tinp->ip_inp.inp.inp_socket = so;\n#if defined(__FreeBSD__)\n\tinp->ip_inp.inp.inp_cred = crhold(so->so_cred);\n#endif\n#ifdef INET6\n#if !defined(__Userspace__) && !defined(__Windows__)\n\tif (INP_SOCKAF(so) == AF_INET6) {\n\t\tif (MODULE_GLOBAL(ip6_auto_flowlabel)) {\n\t\t\tinp->ip_inp.inp.inp_flags |= IN6P_AUTOFLOWLABEL;\n\t\t}\n\t\tif (MODULE_GLOBAL(ip6_v6only)) {\n\t\t\tinp->ip_inp.inp.inp_flags |= IN6P_IPV6_V6ONLY;\n\t\t}\n\t}\n#endif\n#endif\n\tinp->sctp_associd_counter = 1;\n\tinp->partial_delivery_point = SCTP_SB_LIMIT_RCV(so) >> SCTP_PARTIAL_DELIVERY_SHIFT;\n\tinp->sctp_frag_point = SCTP_DEFAULT_MAXSEGMENT;\n\tinp->max_cwnd = 0;\n\tinp->sctp_cmt_on_off = SCTP_BASE_SYSCTL(sctp_cmt_on_off);\n\tinp->ecn_supported = (uint8_t)SCTP_BASE_SYSCTL(sctp_ecn_enable);\n\tinp->prsctp_supported = (uint8_t)SCTP_BASE_SYSCTL(sctp_pr_enable);\n\tinp->auth_supported = (uint8_t)SCTP_BASE_SYSCTL(sctp_auth_enable);\n\tinp->asconf_supported = (uint8_t)SCTP_BASE_SYSCTL(sctp_asconf_enable);\n\tinp->reconfig_supported = (uint8_t)SCTP_BASE_SYSCTL(sctp_reconfig_enable);\n\tinp->nrsack_supported = (uint8_t)SCTP_BASE_SYSCTL(sctp_nrsack_enable);\n\tinp->pktdrop_supported = (uint8_t)SCTP_BASE_SYSCTL(sctp_pktdrop_enable);\n\tinp->idata_supported = 0;\n\n#if defined(__FreeBSD__)\n\tinp->fibnum = so->so_fibnum;\n#else\n\tinp->fibnum = 0;\n#endif\n#if defined(__Userspace__)\n\tinp->ulp_info = NULL;\n\tinp->recv_callback = NULL;\n\tinp->send_callback = NULL;\n\tinp->send_sb_threshold = 0;\n#endif\n\t/* init the small hash table we use to track asocid <-> tcb */\n\tinp->sctp_asocidhash = SCTP_HASH_INIT(SCTP_STACK_VTAG_HASH_SIZE, &inp->hashasocidmark);\n\tif (inp->sctp_asocidhash == NULL) {\n#if defined(__FreeBSD__)\n\t\tcrfree(inp->ip_inp.inp.inp_cred);\n#endif\n\t\tSCTP_ZONE_FREE(SCTP_BASE_INFO(ipi_zone_ep), inp);\n\t\tSCTP_INP_INFO_WUNLOCK();\n\t\treturn (ENOBUFS);\n\t}\n\tSCTP_INCR_EP_COUNT();\n\tinp->ip_inp.inp.inp_ip_ttl = MODULE_GLOBAL(ip_defttl);\n\tSCTP_INP_INFO_WUNLOCK();\n\n\tso->so_pcb = (caddr_t)inp;\n\n#if defined(__FreeBSD__) && __FreeBSD_version < 803000\n\tif ((SCTP_SO_TYPE(so) == SOCK_DGRAM) ||\n\t    (SCTP_SO_TYPE(so) == SOCK_SEQPACKET)) {\n#else\n\tif (SCTP_SO_TYPE(so) == SOCK_SEQPACKET) {\n#endif\n\t\t/* UDP style socket */\n\t\tinp->sctp_flags = (SCTP_PCB_FLAGS_UDPTYPE |\n\t\t    SCTP_PCB_FLAGS_UNBOUND);\n\t\t/* Be sure it is NON-BLOCKING IO for UDP */\n\t\t/* SCTP_SET_SO_NBIO(so); */\n\t} else if (SCTP_SO_TYPE(so) == SOCK_STREAM) {\n\t\t/* TCP style socket */\n\t\tinp->sctp_flags = (SCTP_PCB_FLAGS_TCPTYPE |\n\t\t    SCTP_PCB_FLAGS_UNBOUND);\n\t\t/* Be sure we have blocking IO by default */\n\t\tSOCK_LOCK(so);\n\t\tSCTP_CLEAR_SO_NBIO(so);\n\t\tSOCK_UNLOCK(so);\n#if defined(__Panda__)\n\t} else if (SCTP_SO_TYPE(so) == SOCK_FASTSEQPACKET) {\n\t\tinp->sctp_flags = (SCTP_PCB_FLAGS_UDPTYPE |\n\t\t    SCTP_PCB_FLAGS_UNBOUND);\n\t} else if (SCTP_SO_TYPE(so) == SOCK_FASTSTREAM) {\n\t\tinp->sctp_flags = (SCTP_PCB_FLAGS_TCPTYPE |\n\t\t    SCTP_PCB_FLAGS_UNBOUND);\n#endif\n\t} else {\n\t\t/*\n\t\t * unsupported socket type (RAW, etc)- in case we missed it\n\t\t * in protosw\n\t\t */\n\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, EOPNOTSUPP);\n\t\tso->so_pcb = NULL;\n#if defined(__FreeBSD__)\n\t\tcrfree(inp->ip_inp.inp.inp_cred);\n#endif\n\t\tSCTP_ZONE_FREE(SCTP_BASE_INFO(ipi_zone_ep), inp);\n\t\treturn (EOPNOTSUPP);\n\t}\n\tif (SCTP_BASE_SYSCTL(sctp_default_frag_interleave) == SCTP_FRAG_LEVEL_1) {\n\t\tsctp_feature_on(inp, SCTP_PCB_FLAGS_FRAG_INTERLEAVE);\n\t\tsctp_feature_off(inp, SCTP_PCB_FLAGS_INTERLEAVE_STRMS);\n\t} else if (SCTP_BASE_SYSCTL(sctp_default_frag_interleave) == SCTP_FRAG_LEVEL_2) {\n\t\tsctp_feature_on(inp, SCTP_PCB_FLAGS_FRAG_INTERLEAVE);\n\t\tsctp_feature_on(inp, SCTP_PCB_FLAGS_INTERLEAVE_STRMS);\n\t} else if (SCTP_BASE_SYSCTL(sctp_default_frag_interleave) == SCTP_FRAG_LEVEL_0) {\n\t\tsctp_feature_off(inp, SCTP_PCB_FLAGS_FRAG_INTERLEAVE);\n\t\tsctp_feature_off(inp, SCTP_PCB_FLAGS_INTERLEAVE_STRMS);\n\t}\n\tinp->sctp_tcbhash = SCTP_HASH_INIT(SCTP_BASE_SYSCTL(sctp_pcbtblsize),\n\t\t\t\t\t   &inp->sctp_hashmark);\n\tif (inp->sctp_tcbhash == NULL) {\n\t\tSCTP_PRINTF(\"Out of SCTP-INPCB->hashinit - no resources\\n\");\n\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, ENOBUFS);\n\t\tso->so_pcb = NULL;\n#if defined(__FreeBSD__)\n\t\tcrfree(inp->ip_inp.inp.inp_cred);\n#endif\n\t\tSCTP_ZONE_FREE(SCTP_BASE_INFO(ipi_zone_ep), inp);\n\t\treturn (ENOBUFS);\n\t}\n#ifdef SCTP_MVRF\n\tinp->vrf_size = SCTP_DEFAULT_VRF_SIZE;\n\tSCTP_MALLOC(inp->m_vrf_ids, uint32_t *,\n\t\t    (sizeof(uint32_t) * inp->vrf_size), SCTP_M_MVRF);\n\tif (inp->m_vrf_ids == NULL) {\n\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, ENOBUFS);\n\t\tso->so_pcb = NULL;\n\t\tSCTP_HASH_FREE(inp->sctp_tcbhash, inp->sctp_hashmark);\n#if defined(__FreeBSD__)\n\t\tcrfree(inp->ip_inp.inp.inp_cred);\n#endif\n\t\tSCTP_ZONE_FREE(SCTP_BASE_INFO(ipi_zone_ep), inp);\n\t\treturn (ENOBUFS);\n\t}\n\tinp->m_vrf_ids[0] = vrf_id;\n\tinp->num_vrfs = 1;\n#endif\n\tinp->def_vrf_id = vrf_id;\n\n#if defined(__APPLE__)\n#if defined(APPLE_LEOPARD) || defined(APPLE_SNOWLEOPARD)\n\tinp->ip_inp.inp.inpcb_mtx = lck_mtx_alloc_init(SCTP_BASE_INFO(sctbinfo).mtx_grp, SCTP_BASE_INFO(sctbinfo).mtx_attr);\n\tif (inp->ip_inp.inp.inpcb_mtx == NULL) {\n\t\tSCTP_PRINTF(\"in_pcballoc: can't alloc mutex! so=%p\\n\", (void *)so);\n#ifdef SCTP_MVRF\n\t\tSCTP_FREE(inp->m_vrf_ids, SCTP_M_MVRF);\n#endif\n\t\tSCTP_HASH_FREE(inp->sctp_tcbhash, inp->sctp_hashmark);\n\t\tso->so_pcb = NULL;\n\t\tSCTP_ZONE_FREE(SCTP_BASE_INFO(ipi_zone_ep), inp);\n\t\tSCTP_UNLOCK_EXC(SCTP_BASE_INFO(sctbinfo).ipi_lock);\n\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, ENOMEM);\n\t\treturn (ENOMEM);\n\t}\n#elif defined(APPLE_LION) || defined(APPLE_MOUNTAINLION)\n\tlck_mtx_init(&inp->ip_inp.inp.inpcb_mtx, SCTP_BASE_INFO(sctbinfo).mtx_grp, SCTP_BASE_INFO(sctbinfo).mtx_attr);\n#else\n\tlck_mtx_init(&inp->ip_inp.inp.inpcb_mtx, SCTP_BASE_INFO(sctbinfo).ipi_lock_grp, SCTP_BASE_INFO(sctbinfo).ipi_lock_attr);\n#endif\n#endif\n\tSCTP_INP_INFO_WLOCK();\n\tSCTP_INP_LOCK_INIT(inp);\n#if defined(__FreeBSD__)\n\tINP_LOCK_INIT(&inp->ip_inp.inp, \"inp\", \"sctpinp\");\n#endif\n\tSCTP_INP_READ_INIT(inp);\n\tSCTP_ASOC_CREATE_LOCK_INIT(inp);\n\t/* lock the new ep */\n\tSCTP_INP_WLOCK(inp);\n\n\t/* add it to the info area */\n\tLIST_INSERT_HEAD(&SCTP_BASE_INFO(listhead), inp, sctp_list);\n#if defined(__APPLE__)\n\tinp->ip_inp.inp.inp_pcbinfo = &SCTP_BASE_INFO(sctbinfo);\n#if defined(APPLE_LEOPARD) || defined(APPLE_SNOWLEOPARD) || defined(APPLE_LION) || defined(APPLE_MOUNTAINLION)\n\tLIST_INSERT_HEAD(SCTP_BASE_INFO(sctbinfo).listhead, &inp->ip_inp.inp, inp_list);\n#else\n\tLIST_INSERT_HEAD(SCTP_BASE_INFO(sctbinfo).ipi_listhead, &inp->ip_inp.inp, inp_list);\n#endif\n#endif\n\tSCTP_INP_INFO_WUNLOCK();\n\n\tTAILQ_INIT(&inp->read_queue);\n\tLIST_INIT(&inp->sctp_addr_list);\n\n\tLIST_INIT(&inp->sctp_asoc_list);\n\n#ifdef SCTP_TRACK_FREED_ASOCS\n\t/* TEMP CODE */\n\tLIST_INIT(&inp->sctp_asoc_free_list);\n#endif\n\t/* Init the timer structure for signature change */\n\tSCTP_OS_TIMER_INIT(&inp->sctp_ep.signature_change.timer);\n\tinp->sctp_ep.signature_change.type = SCTP_TIMER_TYPE_NEWCOOKIE;\n\n\t/* now init the actual endpoint default data */\n\tm = &inp->sctp_ep;\n\n\t/* setup the base timeout information */\n\tm->sctp_timeoutticks[SCTP_TIMER_SEND] = SEC_TO_TICKS(SCTP_SEND_SEC);\t/* needed ? */\n\tm->sctp_timeoutticks[SCTP_TIMER_INIT] = SEC_TO_TICKS(SCTP_INIT_SEC);\t/* needed ? */\n\tm->sctp_timeoutticks[SCTP_TIMER_RECV] = MSEC_TO_TICKS(SCTP_BASE_SYSCTL(sctp_delayed_sack_time_default));\n\tm->sctp_timeoutticks[SCTP_TIMER_HEARTBEAT] = MSEC_TO_TICKS(SCTP_BASE_SYSCTL(sctp_heartbeat_interval_default));\n\tm->sctp_timeoutticks[SCTP_TIMER_PMTU] = SEC_TO_TICKS(SCTP_BASE_SYSCTL(sctp_pmtu_raise_time_default));\n\tm->sctp_timeoutticks[SCTP_TIMER_MAXSHUTDOWN] = SEC_TO_TICKS(SCTP_BASE_SYSCTL(sctp_shutdown_guard_time_default));\n\tm->sctp_timeoutticks[SCTP_TIMER_SIGNATURE] = SEC_TO_TICKS(SCTP_BASE_SYSCTL(sctp_secret_lifetime_default));\n\t/* all max/min max are in ms */\n\tm->sctp_maxrto = SCTP_BASE_SYSCTL(sctp_rto_max_default);\n\tm->sctp_minrto = SCTP_BASE_SYSCTL(sctp_rto_min_default);\n\tm->initial_rto = SCTP_BASE_SYSCTL(sctp_rto_initial_default);\n\tm->initial_init_rto_max = SCTP_BASE_SYSCTL(sctp_init_rto_max_default);\n\tm->sctp_sack_freq = SCTP_BASE_SYSCTL(sctp_sack_freq_default);\n\tm->max_init_times = SCTP_BASE_SYSCTL(sctp_init_rtx_max_default);\n\tm->max_send_times = SCTP_BASE_SYSCTL(sctp_assoc_rtx_max_default);\n\tm->def_net_failure = SCTP_BASE_SYSCTL(sctp_path_rtx_max_default);\n\tm->def_net_pf_threshold = SCTP_BASE_SYSCTL(sctp_path_pf_threshold);\n\tm->sctp_sws_sender = SCTP_SWS_SENDER_DEF;\n\tm->sctp_sws_receiver = SCTP_SWS_RECEIVER_DEF;\n\tm->max_burst = SCTP_BASE_SYSCTL(sctp_max_burst_default);\n\tm->fr_max_burst = SCTP_BASE_SYSCTL(sctp_fr_max_burst_default);\n\n\tm->sctp_default_cc_module = SCTP_BASE_SYSCTL(sctp_default_cc_module);\n\tm->sctp_default_ss_module = SCTP_BASE_SYSCTL(sctp_default_ss_module);\n\tm->max_open_streams_intome = SCTP_BASE_SYSCTL(sctp_nr_incoming_streams_default);\n\t/* number of streams to pre-open on a association */\n\tm->pre_open_stream_count = SCTP_BASE_SYSCTL(sctp_nr_outgoing_streams_default);\n\n\tm->default_mtu = 0;\n\t/* Add adaptation cookie */\n\tm->adaptation_layer_indicator = 0;\n\tm->adaptation_layer_indicator_provided = 0;\n\n\t/* seed random number generator */\n\tm->random_counter = 1;\n\tm->store_at = SCTP_SIGNATURE_SIZE;\n\tSCTP_READ_RANDOM(m->random_numbers, sizeof(m->random_numbers));\n\tsctp_fill_random_store(m);\n\n\t/* Minimum cookie size */\n\tm->size_of_a_cookie = (sizeof(struct sctp_init_msg) * 2) +\n\t    sizeof(struct sctp_state_cookie);\n\tm->size_of_a_cookie += SCTP_SIGNATURE_SIZE;\n\n\t/* Setup the initial secret */\n\t(void)SCTP_GETTIME_TIMEVAL(&time);\n\tm->time_of_secret_change = time.tv_sec;\n\n\tfor (i = 0; i < SCTP_NUMBER_OF_SECRETS; i++) {\n\t\tm->secret_key[0][i] = sctp_select_initial_TSN(m);\n\t}\n\tsctp_timer_start(SCTP_TIMER_TYPE_NEWCOOKIE, inp, NULL, NULL);\n\n\t/* How long is a cookie good for ? */\n\tm->def_cookie_life = MSEC_TO_TICKS(SCTP_BASE_SYSCTL(sctp_valid_cookie_life_default));\n\t/*\n\t * Initialize authentication parameters\n\t */\n\tm->local_hmacs = sctp_default_supported_hmaclist();\n\tm->local_auth_chunks = sctp_alloc_chunklist();\n\tif (inp->asconf_supported) {\n\t\tsctp_auth_add_chunk(SCTP_ASCONF, m->local_auth_chunks);\n\t\tsctp_auth_add_chunk(SCTP_ASCONF_ACK, m->local_auth_chunks);\n\t}\n\tm->default_dscp = 0;\n#ifdef INET6\n\tm->default_flowlabel = 0;\n#endif\n\tm->port = 0; /* encapsulation disabled by default */\n\tLIST_INIT(&m->shared_keys);\n\t/* add default NULL key as key id 0 */\n\tnull_key = sctp_alloc_sharedkey();\n\tsctp_insert_sharedkey(&m->shared_keys, null_key);\n\tSCTP_INP_WUNLOCK(inp);\n#ifdef SCTP_LOG_CLOSING\n\tsctp_log_closing(inp, NULL, 12);\n#endif\n\treturn (error);\n}\n\n\nvoid\nsctp_move_pcb_and_assoc(struct sctp_inpcb *old_inp, struct sctp_inpcb *new_inp,\n    struct sctp_tcb *stcb)\n{\n\tstruct sctp_nets *net;\n\tuint16_t lport, rport;\n\tstruct sctppcbhead *head;\n\tstruct sctp_laddr *laddr, *oladdr;\n\n\tatomic_add_int(&stcb->asoc.refcnt, 1);\n\tSCTP_TCB_UNLOCK(stcb);\n\tSCTP_INP_INFO_WLOCK();\n\tSCTP_INP_WLOCK(old_inp);\n\tSCTP_INP_WLOCK(new_inp);\n\tSCTP_TCB_LOCK(stcb);\n\tatomic_subtract_int(&stcb->asoc.refcnt, 1);\n\n\tnew_inp->sctp_ep.time_of_secret_change =\n\t    old_inp->sctp_ep.time_of_secret_change;\n\tmemcpy(new_inp->sctp_ep.secret_key, old_inp->sctp_ep.secret_key,\n\t    sizeof(old_inp->sctp_ep.secret_key));\n\tnew_inp->sctp_ep.current_secret_number =\n\t    old_inp->sctp_ep.current_secret_number;\n\tnew_inp->sctp_ep.last_secret_number =\n\t    old_inp->sctp_ep.last_secret_number;\n\tnew_inp->sctp_ep.size_of_a_cookie = old_inp->sctp_ep.size_of_a_cookie;\n\n\t/* make it so new data pours into the new socket */\n\tstcb->sctp_socket = new_inp->sctp_socket;\n\tstcb->sctp_ep = new_inp;\n\n\t/* Copy the port across */\n\tlport = new_inp->sctp_lport = old_inp->sctp_lport;\n\trport = stcb->rport;\n\t/* Pull the tcb from the old association */\n\tLIST_REMOVE(stcb, sctp_tcbhash);\n\tLIST_REMOVE(stcb, sctp_tcblist);\n\tif (stcb->asoc.in_asocid_hash) {\n\t\tLIST_REMOVE(stcb, sctp_tcbasocidhash);\n\t}\n\t/* Now insert the new_inp into the TCP connected hash */\n\thead = &SCTP_BASE_INFO(sctp_tcpephash)[SCTP_PCBHASH_ALLADDR((lport | rport), SCTP_BASE_INFO(hashtcpmark))];\n\n\tLIST_INSERT_HEAD(head, new_inp, sctp_hash);\n\t/* Its safe to access */\n\tnew_inp->sctp_flags &= ~SCTP_PCB_FLAGS_UNBOUND;\n\n\t/* Now move the tcb into the endpoint list */\n\tLIST_INSERT_HEAD(&new_inp->sctp_asoc_list, stcb, sctp_tcblist);\n\t/*\n\t * Question, do we even need to worry about the ep-hash since we\n\t * only have one connection? Probably not :> so lets get rid of it\n\t * and not suck up any kernel memory in that.\n\t */\n\tif (stcb->asoc.in_asocid_hash) {\n\t\tstruct sctpasochead *lhd;\n\t\tlhd = &new_inp->sctp_asocidhash[SCTP_PCBHASH_ASOC(stcb->asoc.assoc_id,\n\t\t\tnew_inp->hashasocidmark)];\n\t\tLIST_INSERT_HEAD(lhd, stcb, sctp_tcbasocidhash);\n\t}\n\t/* Ok. Let's restart timer. */\n\tTAILQ_FOREACH(net, &stcb->asoc.nets, sctp_next) {\n\t\tsctp_timer_start(SCTP_TIMER_TYPE_PATHMTURAISE, new_inp,\n\t\t    stcb, net);\n\t}\n\n\tSCTP_INP_INFO_WUNLOCK();\n\tif (new_inp->sctp_tcbhash != NULL) {\n\t\tSCTP_HASH_FREE(new_inp->sctp_tcbhash, new_inp->sctp_hashmark);\n\t\tnew_inp->sctp_tcbhash = NULL;\n\t}\n\tif ((new_inp->sctp_flags & SCTP_PCB_FLAGS_BOUNDALL) == 0) {\n\t\t/* Subset bound, so copy in the laddr list from the old_inp */\n\t\tLIST_FOREACH(oladdr, &old_inp->sctp_addr_list, sctp_nxt_addr) {\n\t\t\tladdr = SCTP_ZONE_GET(SCTP_BASE_INFO(ipi_zone_laddr), struct sctp_laddr);\n\t\t\tif (laddr == NULL) {\n\t\t\t\t/*\n\t\t\t\t * Gak, what can we do? This assoc is really\n\t\t\t\t * HOSED. We probably should send an abort\n\t\t\t\t * here.\n\t\t\t\t */\n\t\t\t\tSCTPDBG(SCTP_DEBUG_PCB1, \"Association hosed in TCP model, out of laddr memory\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tSCTP_INCR_LADDR_COUNT();\n\t\t\tmemset(laddr, 0, sizeof(*laddr));\n\t\t\t(void)SCTP_GETTIME_TIMEVAL(&laddr->start_time);\n\t\t\tladdr->ifa = oladdr->ifa;\n\t\t\tatomic_add_int(&laddr->ifa->refcount, 1);\n\t\t\tLIST_INSERT_HEAD(&new_inp->sctp_addr_list, laddr,\n\t\t\t    sctp_nxt_addr);\n\t\t\tnew_inp->laddr_count++;\n\t\t\tif (oladdr == stcb->asoc.last_used_address) {\n\t\t\t\tstcb->asoc.last_used_address = laddr;\n\t\t\t}\n\t\t}\n\t}\n\t/* Now any running timers need to be adjusted\n\t * since we really don't care if they are running\n\t * or not just blast in the new_inp into all of\n\t * them.\n\t */\n\n\tstcb->asoc.dack_timer.ep = (void *)new_inp;\n\tstcb->asoc.asconf_timer.ep = (void *)new_inp;\n\tstcb->asoc.strreset_timer.ep = (void *)new_inp;\n\tstcb->asoc.shut_guard_timer.ep = (void *)new_inp;\n\tstcb->asoc.autoclose_timer.ep = (void *)new_inp;\n\tstcb->asoc.delayed_event_timer.ep = (void *)new_inp;\n\tstcb->asoc.delete_prim_timer.ep = (void *)new_inp;\n\t/* now what about the nets? */\n\tTAILQ_FOREACH(net, &stcb->asoc.nets, sctp_next) {\n\t\tnet->pmtu_timer.ep = (void *)new_inp;\n\t\tnet->hb_timer.ep = (void *)new_inp;\n\t\tnet->rxt_timer.ep = (void *)new_inp;\n\t}\n\tSCTP_INP_WUNLOCK(new_inp);\n\tSCTP_INP_WUNLOCK(old_inp);\n}\n\n/*\n * insert an laddr entry with the given ifa for the desired list\n */\nstatic int\nsctp_insert_laddr(struct sctpladdr *list, struct sctp_ifa *ifa, uint32_t act)\n{\n\tstruct sctp_laddr *laddr;\n\n\tladdr = SCTP_ZONE_GET(SCTP_BASE_INFO(ipi_zone_laddr), struct sctp_laddr);\n\tif (laddr == NULL) {\n\t\t/* out of memory? */\n\t\tSCTP_LTRACE_ERR_RET(NULL, NULL, NULL, SCTP_FROM_SCTP_PCB, EINVAL);\n\t\treturn (EINVAL);\n\t}\n\tSCTP_INCR_LADDR_COUNT();\n\tmemset(laddr, 0, sizeof(*laddr));\n\t(void)SCTP_GETTIME_TIMEVAL(&laddr->start_time);\n\tladdr->ifa = ifa;\n\tladdr->action = act;\n\tatomic_add_int(&ifa->refcount, 1);\n\t/* insert it */\n\tLIST_INSERT_HEAD(list, laddr, sctp_nxt_addr);\n\n\treturn (0);\n}\n\n/*\n * Remove an laddr entry from the local address list (on an assoc)\n */\nstatic void\nsctp_remove_laddr(struct sctp_laddr *laddr)\n{\n\n\t/* remove from the list */\n\tLIST_REMOVE(laddr, sctp_nxt_addr);\n\tsctp_free_ifa(laddr->ifa);\n\tSCTP_ZONE_FREE(SCTP_BASE_INFO(ipi_zone_laddr), laddr);\n\tSCTP_DECR_LADDR_COUNT();\n}\n\n#if !(defined(__FreeBSD__) || defined(__APPLE__) || defined(__Userspace__))\n/*\n * Don't know why, but without this there is an unknown reference when\n * compiling NetBSD... hmm\n */\nextern void in6_sin6_2_sin(struct sockaddr_in *, struct sockaddr_in6 *sin6);\n#endif\n\n\n/* sctp_ifap is used to bypass normal local address validation checks */\nint\n#if defined(__FreeBSD__) && __FreeBSD_version >= 500000\nsctp_inpcb_bind(struct socket *so, struct sockaddr *addr,\n                struct sctp_ifa *sctp_ifap, struct thread *p)\n#elif defined(__Windows__)\nsctp_inpcb_bind(struct socket *so, struct sockaddr *addr,\n                struct sctp_ifa *sctp_ifap, PKTHREAD p)\n#else\nsctp_inpcb_bind(struct socket *so, struct sockaddr *addr,\n                struct sctp_ifa *sctp_ifap, struct proc *p)\n#endif\n{\n\t/* bind a ep to a socket address */\n\tstruct sctppcbhead *head;\n\tstruct sctp_inpcb *inp, *inp_tmp;\n#if defined(__FreeBSD__) || defined(__APPLE__)\n\tstruct inpcb *ip_inp;\n#endif\n\tint port_reuse_active = 0;\n\tint bindall;\n#ifdef SCTP_MVRF\n\tint i;\n#endif\n\tuint16_t lport;\n\tint error;\n\tuint32_t vrf_id;\n\n\tlport = 0;\n\tbindall = 1;\n\tinp = (struct sctp_inpcb *)so->so_pcb;\n#if defined(__FreeBSD__) || defined(__APPLE__)\n\tip_inp = (struct inpcb *)so->so_pcb;\n#endif\n#ifdef SCTP_DEBUG\n\tif (addr) {\n\t\tSCTPDBG(SCTP_DEBUG_PCB1, \"Bind called port: %d\\n\",\n\t\t\tntohs(((struct sockaddr_in *)addr)->sin_port));\n\t\tSCTPDBG(SCTP_DEBUG_PCB1, \"Addr: \");\n\t\tSCTPDBG_ADDR(SCTP_DEBUG_PCB1, addr);\n\t}\n#endif\n\tif ((inp->sctp_flags & SCTP_PCB_FLAGS_UNBOUND) == 0) {\n\t\t/* already did a bind, subsequent binds NOT allowed ! */\n\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, EINVAL);\n\t\treturn (EINVAL);\n\t}\n#if defined(__FreeBSD__) && __FreeBSD_version >= 500000\n#ifdef INVARIANTS\n\tif (p == NULL)\n\t\tpanic(\"null proc/thread\");\n#endif\n#endif\n\tif (addr != NULL) {\n\t\tswitch (addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t{\n\t\t\tstruct sockaddr_in *sin;\n\n\t\t\t/* IPV6_V6ONLY socket? */\n\t\t\tif (SCTP_IPV6_V6ONLY(inp)) {\n\t\t\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, EINVAL);\n\t\t\t\treturn (EINVAL);\n\t\t\t}\n#ifdef HAVE_SA_LEN\n\t\t\tif (addr->sa_len != sizeof(*sin)) {\n\t\t\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, EINVAL);\n\t\t\t\treturn (EINVAL);\n\t\t\t}\n#endif\n\n\t\t\tsin = (struct sockaddr_in *)addr;\n\t\t\tlport = sin->sin_port;\n#if defined(__FreeBSD__) && __FreeBSD_version >= 800000\n\t\t\t/*\n\t\t\t * For LOOPBACK the prison_local_ip4() call will transmute the ip address\n\t\t\t * to the proper value.\n\t\t\t */\n\t\t\tif (p && (error = prison_local_ip4(p->td_ucred, &sin->sin_addr)) != 0) {\n\t\t\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, error);\n\t\t\t\treturn (error);\n\t\t\t}\n#endif\n\t\t\tif (sin->sin_addr.s_addr != INADDR_ANY) {\n\t\t\t\tbindall = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n#endif\n#ifdef INET6\n\t\tcase AF_INET6:\n\t\t{\n\t\t\t/* Only for pure IPv6 Address. (No IPv4 Mapped!) */\n\t\t\tstruct sockaddr_in6 *sin6;\n\n\t\t\tsin6 = (struct sockaddr_in6 *)addr;\n\n#ifdef HAVE_SA_LEN\n\t\t\tif (addr->sa_len != sizeof(*sin6)) {\n\t\t\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, EINVAL);\n\t\t\t\treturn (EINVAL);\n\t\t\t}\n#endif\n\t\t\tlport = sin6->sin6_port;\n#if defined(__FreeBSD__) && __FreeBSD_version >= 800000\n\t\t\t/*\n\t\t\t * For LOOPBACK the prison_local_ip6() call will transmute the ipv6 address\n\t\t\t * to the proper value.\n\t\t\t */\n\t\t\tif (p && (error = prison_local_ip6(p->td_ucred, &sin6->sin6_addr,\n\t\t\t    (SCTP_IPV6_V6ONLY(inp) != 0))) != 0) {\n\t\t\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, error);\n\t\t\t\treturn (error);\n\t\t\t}\n#endif\n\t\t\tif (!IN6_IS_ADDR_UNSPECIFIED(&sin6->sin6_addr)) {\n\t\t\t\tbindall = 0;\n#ifdef SCTP_EMBEDDED_V6_SCOPE\n\t\t\t\t/* KAME hack: embed scopeid */\n#if defined(SCTP_KAME)\n\t\t\t\tif (sa6_embedscope(sin6, MODULE_GLOBAL(ip6_use_defzone)) != 0) {\n\t\t\t\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, EINVAL);\n\t\t\t\t\treturn (EINVAL);\n\t\t\t\t}\n#elif defined(__APPLE__)\n#if defined(APPLE_LEOPARD) || defined(APPLE_SNOWLEOPARD)\n\t\t\t\tif (in6_embedscope(&sin6->sin6_addr, sin6, ip_inp, NULL) != 0) {\n#else\n\t\t\t\tif (in6_embedscope(&sin6->sin6_addr, sin6, ip_inp, NULL, NULL) != 0) {\n#endif\n\t\t\t\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, EINVAL);\n\t\t\t\t\treturn (EINVAL);\n\t\t\t\t}\n#elif defined(__FreeBSD__)\n\t\t\t\terror = scope6_check_id(sin6, MODULE_GLOBAL(ip6_use_defzone));\n\t\t\t\tif (error != 0) {\n\t\t\t\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, error);\n\t\t\t\t\treturn (error);\n\t\t\t\t}\n#else\n\t\t\t\tif (in6_embedscope(&sin6->sin6_addr, sin6) != 0) {\n\t\t\t\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, EINVAL);\n\t\t\t\t\treturn (EINVAL);\n\t\t\t\t}\n#endif\n#endif /* SCTP_EMBEDDED_V6_SCOPE */\n\t\t\t}\n#ifndef SCOPEDROUTING\n\t\t\t/* this must be cleared for ifa_ifwithaddr() */\n\t\t\tsin6->sin6_scope_id = 0;\n#endif /* SCOPEDROUTING */\n\t\t\tbreak;\n\t\t}\n#endif\n#if defined(__Userspace__)\n\t\tcase AF_CONN:\n\t\t{\n\t\t\tstruct sockaddr_conn *sconn;\n\n#ifdef HAVE_SA_LEN\n\t\t\tif (addr->sa_len != sizeof(struct sockaddr_conn)) {\n\t\t\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, EINVAL);\n\t\t\t\treturn (EINVAL);\n\t\t\t}\n#endif\n\t\t\tsconn = (struct sockaddr_conn *)addr;\n\t\t\tlport = sconn->sconn_port;\n\t\t\tif (sconn->sconn_addr != NULL) {\n\t\t\t\tbindall = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, EAFNOSUPPORT);\n\t\t\treturn (EAFNOSUPPORT);\n\t\t}\n\t}\n\tSCTP_INP_INFO_WLOCK();\n\tSCTP_INP_WLOCK(inp);\n\t/* Setup a vrf_id to be the default for the non-bind-all case. */\n\tvrf_id = inp->def_vrf_id;\n\n\t/* increase our count due to the unlock we do */\n\tSCTP_INP_INCR_REF(inp);\n\tif (lport) {\n\t\t/*\n\t\t * Did the caller specify a port? if so we must see if an ep\n\t\t * already has this one bound.\n\t\t */\n\t\t/* got to be root to get at low ports */\n#if !defined(__Windows__)\n\t\tif (ntohs(lport) < IPPORT_RESERVED) {\n\t\t\tif ((p != NULL) && ((error =\n#ifdef __FreeBSD__\n#if __FreeBSD_version > 602000\n\t\t\t\t  priv_check(p, PRIV_NETINET_RESERVEDPORT)\n#elif __FreeBSD_version >= 500000\n\t\t\t\t  suser_cred(p->td_ucred, 0)\n#else\n\t\t\t\t  suser(p)\n#endif\n#elif defined(__APPLE__)\n\t\t\t\t  suser(p->p_ucred, &p->p_acflag)\n#elif defined(__Userspace__) /* must be true to use raw socket */\n\t\t\t\t  1\n#else\n\t\t\t\t  suser(p, 0)\n#endif\n\t\t\t\t    ) != 0)) {\n\t\t\t\tSCTP_INP_DECR_REF(inp);\n\t\t\t\tSCTP_INP_WUNLOCK(inp);\n\t\t\t\tSCTP_INP_INFO_WUNLOCK();\n\t\t\t\treturn (error);\n\t\t\t}\n#if defined(__Panda__)\n\t\t\tif (!SCTP_IS_PRIVILEDGED(so)) {\n\t\t\t\tSCTP_INP_DECR_REF(inp);\n\t\t\t\tSCTP_INP_WUNLOCK(inp);\n\t\t\t\tSCTP_INP_INFO_WUNLOCK();\n\t\t\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, EACCES);\n\t\t\t\treturn (EACCES);\n\t\t\t}\n#endif\n\t\t}\n#endif /* __Windows__ */\n\t\tSCTP_INP_WUNLOCK(inp);\n\t\tif (bindall) {\n#ifdef SCTP_MVRF\n\t\t\tfor (i = 0; i < inp->num_vrfs; i++) {\n\t\t\t\tvrf_id = inp->m_vrf_ids[i];\n#else\n\t\t\t\tvrf_id = inp->def_vrf_id;\n#endif\n\t\t\t\tinp_tmp = sctp_pcb_findep(addr, 0, 1, vrf_id);\n\t\t\t\tif (inp_tmp != NULL) {\n\t\t\t\t\t/*\n\t\t\t\t\t * lock guy returned and lower count\n\t\t\t\t\t * note that we are not bound so\n\t\t\t\t\t * inp_tmp should NEVER be inp. And\n\t\t\t\t\t * it is this inp (inp_tmp) that gets\n\t\t\t\t\t * the reference bump, so we must\n\t\t\t\t\t * lower it.\n\t\t\t\t\t */\n\t\t\t\t\tSCTP_INP_DECR_REF(inp_tmp);\n\t\t\t\t\t/* unlock info */\n\t\t\t\t\tif ((sctp_is_feature_on(inp, SCTP_PCB_FLAGS_PORTREUSE)) &&\n\t\t\t\t\t    (sctp_is_feature_on(inp_tmp, SCTP_PCB_FLAGS_PORTREUSE))) {\n\t\t\t\t\t\t/* Ok, must be one-2-one and allowing port re-use */\n\t\t\t\t\t\tport_reuse_active = 1;\n\t\t\t\t\t\tgoto continue_anyway;\n\t\t\t\t\t}\n\t\t\t\t\tSCTP_INP_DECR_REF(inp);\n\t\t\t\t\tSCTP_INP_INFO_WUNLOCK();\n\t\t\t\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, EADDRINUSE);\n\t\t\t\t\treturn (EADDRINUSE);\n\t\t\t\t}\n#ifdef SCTP_MVRF\n\t\t\t}\n#endif\n\t\t} else {\n\t\t\tinp_tmp = sctp_pcb_findep(addr, 0, 1, vrf_id);\n\t\t\tif (inp_tmp != NULL) {\n\t\t\t\t/*\n\t\t\t\t * lock guy returned and lower count note\n\t\t\t\t * that we are not bound so inp_tmp should\n\t\t\t\t * NEVER be inp. And it is this inp (inp_tmp)\n\t\t\t\t * that gets the reference bump, so we must\n\t\t\t\t * lower it.\n\t\t\t\t */\n\t\t\t\tSCTP_INP_DECR_REF(inp_tmp);\n\t\t\t\t/* unlock info */\n\t\t\t\tif ((sctp_is_feature_on(inp, SCTP_PCB_FLAGS_PORTREUSE)) &&\n\t\t\t\t    (sctp_is_feature_on(inp_tmp, SCTP_PCB_FLAGS_PORTREUSE))) {\n\t\t\t\t\t/* Ok, must be one-2-one and allowing port re-use */\n\t\t\t\t\tport_reuse_active = 1;\n\t\t\t\t\tgoto continue_anyway;\n\t\t\t\t}\n\t\t\t\tSCTP_INP_DECR_REF(inp);\n\t\t\t\tSCTP_INP_INFO_WUNLOCK();\n\t\t\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, EADDRINUSE);\n\t\t\t\treturn (EADDRINUSE);\n\t\t\t}\n\t\t}\n\tcontinue_anyway:\n\t\tSCTP_INP_WLOCK(inp);\n\t\tif (bindall) {\n\t\t\t/* verify that no lport is not used by a singleton */\n\t\t\tif ((port_reuse_active == 0) &&\n\t\t\t    (inp_tmp = sctp_isport_inuse(inp, lport, vrf_id))) {\n\t\t\t\t/* Sorry someone already has this one bound */\n\t\t\t\tif ((sctp_is_feature_on(inp, SCTP_PCB_FLAGS_PORTREUSE)) &&\n\t\t\t\t    (sctp_is_feature_on(inp_tmp, SCTP_PCB_FLAGS_PORTREUSE))) {\n\t\t\t\t\tport_reuse_active = 1;\n\t\t\t\t} else {\n\t\t\t\t\tSCTP_INP_DECR_REF(inp);\n\t\t\t\t\tSCTP_INP_WUNLOCK(inp);\n\t\t\t\t\tSCTP_INP_INFO_WUNLOCK();\n\t\t\t\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, EADDRINUSE);\n\t\t\t\t\treturn (EADDRINUSE);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tuint16_t first, last, candidate;\n\t\tuint16_t count;\n\t\tint done;\n\n#if defined(__Windows__)\n\t\tfirst = 1;\n\t\tlast = 0xffff;\n#else\n#if defined(__Userspace__)\n\t\t/* TODO ensure uid is 0, etc... */\n#elif defined(__FreeBSD__) || defined(__APPLE__)\n\t\tif (ip_inp->inp_flags & INP_HIGHPORT) {\n\t\t\tfirst = MODULE_GLOBAL(ipport_hifirstauto);\n\t\t\tlast = MODULE_GLOBAL(ipport_hilastauto);\n\t\t} else if (ip_inp->inp_flags & INP_LOWPORT) {\n\t\t\tif (p && (error =\n#ifdef __FreeBSD__\n#if __FreeBSD_version > 602000\n\t\t\t\t  priv_check(p, PRIV_NETINET_RESERVEDPORT)\n#elif __FreeBSD_version >= 500000\n\t\t\t\t  suser_cred(p->td_ucred, 0)\n#else\n\t\t\t\t  suser(p)\n#endif\n#elif defined(__APPLE__)\n\t\t\t\t  suser(p->p_ucred, &p->p_acflag)\n#else\n\t\t\t\t  suser(p, 0)\n#endif\n\t\t\t\t    )) {\n\t\t\t\tSCTP_INP_DECR_REF(inp);\n\t\t\t\tSCTP_INP_WUNLOCK(inp);\n\t\t\t\tSCTP_INP_INFO_WUNLOCK();\n\t\t\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, error);\n\t\t\t\treturn (error);\n\t\t\t}\n\t\t\tfirst = MODULE_GLOBAL(ipport_lowfirstauto);\n\t\t\tlast = MODULE_GLOBAL(ipport_lowlastauto);\n\t\t} else {\n#endif\n\t\t\tfirst = MODULE_GLOBAL(ipport_firstauto);\n\t\t\tlast = MODULE_GLOBAL(ipport_lastauto);\n#if defined(__FreeBSD__) || defined(__APPLE__)\n\t\t}\n#endif\n#endif /* __Windows__ */\n\t\tif (first > last) {\n\t\t\tuint16_t temp;\n\n\t\t\ttemp = first;\n\t\t\tfirst = last;\n\t\t\tlast = temp;\n\t\t}\n\t\tcount = last - first + 1; /* number of candidates */\n\t\tcandidate = first + sctp_select_initial_TSN(&inp->sctp_ep) % (count);\n\n\t\tdone = 0;\n\t\twhile (!done) {\n#ifdef SCTP_MVRF\n\t\t\tfor (i = 0; i < inp->num_vrfs; i++) {\n\t\t\t\tif (sctp_isport_inuse(inp, htons(candidate), inp->m_vrf_ids[i]) != NULL) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == inp->num_vrfs) {\n\t\t\t\tdone = 1;\n\t\t\t}\n#else\n\t\t\tif (sctp_isport_inuse(inp, htons(candidate), inp->def_vrf_id) == NULL) {\n\t\t\t\tdone = 1;\n\t\t\t}\n#endif\n\t\t\tif (!done) {\n\t\t\t\tif (--count == 0) {\n\t\t\t\t\tSCTP_INP_DECR_REF(inp);\n\t\t\t\t\tSCTP_INP_WUNLOCK(inp);\n\t\t\t\t\tSCTP_INP_INFO_WUNLOCK();\n\t\t\t\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, EADDRINUSE);\n\t\t\t\t\treturn (EADDRINUSE);\n\t\t\t\t}\n\t\t\t\tif (candidate == last)\n\t\t\t\t\tcandidate = first;\n\t\t\t\telse\n\t\t\t\t\tcandidate = candidate + 1;\n\t\t\t}\n\t\t}\n\t\tlport = htons(candidate);\n\t}\n\tSCTP_INP_DECR_REF(inp);\n\tif (inp->sctp_flags & (SCTP_PCB_FLAGS_SOCKET_GONE |\n\t\t\t       SCTP_PCB_FLAGS_SOCKET_ALLGONE)) {\n\t\t/*\n\t\t * this really should not happen. The guy did a non-blocking\n\t\t * bind and then did a close at the same time.\n\t\t */\n\t\tSCTP_INP_WUNLOCK(inp);\n\t\tSCTP_INP_INFO_WUNLOCK();\n\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, EINVAL);\n\t\treturn (EINVAL);\n\t}\n\t/* ok we look clear to give out this port, so lets setup the binding */\n\tif (bindall) {\n\t\t/* binding to all addresses, so just set in the proper flags */\n\t\tinp->sctp_flags |= SCTP_PCB_FLAGS_BOUNDALL;\n\t\t/* set the automatic addr changes from kernel flag */\n\t\tif (SCTP_BASE_SYSCTL(sctp_auto_asconf) == 0) {\n\t\t\tsctp_feature_off(inp, SCTP_PCB_FLAGS_DO_ASCONF);\n\t\t\tsctp_feature_off(inp, SCTP_PCB_FLAGS_AUTO_ASCONF);\n\t\t} else {\n\t\t\tsctp_feature_on(inp, SCTP_PCB_FLAGS_DO_ASCONF);\n\t\t\tsctp_feature_on(inp, SCTP_PCB_FLAGS_AUTO_ASCONF);\n\t\t}\n\t\tif (SCTP_BASE_SYSCTL(sctp_multiple_asconfs) == 0) {\n\t\t\tsctp_feature_off(inp, SCTP_PCB_FLAGS_MULTIPLE_ASCONFS);\n\t\t} else {\n\t\t\tsctp_feature_on(inp, SCTP_PCB_FLAGS_MULTIPLE_ASCONFS);\n\t\t}\n\t\t/* set the automatic mobility_base from kernel\n\t\t   flag (by micchie)\n\t\t*/\n\t\tif (SCTP_BASE_SYSCTL(sctp_mobility_base) == 0) {\n\t\t\tsctp_mobility_feature_off(inp, SCTP_MOBILITY_BASE);\n\t\t\tsctp_mobility_feature_off(inp, SCTP_MOBILITY_PRIM_DELETED);\n\t\t} else {\n\t\t\tsctp_mobility_feature_on(inp, SCTP_MOBILITY_BASE);\n\t\t\tsctp_mobility_feature_off(inp, SCTP_MOBILITY_PRIM_DELETED);\n\t\t}\n\t\t/* set the automatic mobility_fasthandoff from kernel\n\t\t   flag (by micchie)\n\t\t*/\n\t\tif (SCTP_BASE_SYSCTL(sctp_mobility_fasthandoff) == 0) {\n\t\t\tsctp_mobility_feature_off(inp, SCTP_MOBILITY_FASTHANDOFF);\n\t\t\tsctp_mobility_feature_off(inp, SCTP_MOBILITY_PRIM_DELETED);\n\t\t} else {\n\t\t\tsctp_mobility_feature_on(inp, SCTP_MOBILITY_FASTHANDOFF);\n\t\t\tsctp_mobility_feature_off(inp, SCTP_MOBILITY_PRIM_DELETED);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * bind specific, make sure flags is off and add a new\n\t\t * address structure to the sctp_addr_list inside the ep\n\t\t * structure.\n\t\t *\n\t\t * We will need to allocate one and insert it at the head. The\n\t\t * socketopt call can just insert new addresses in there as\n\t\t * well. It will also have to do the embed scope kame hack\n\t\t * too (before adding).\n\t\t */\n\t\tstruct sctp_ifa *ifa;\n\t\tunion sctp_sockstore store;\n\n\t\tmemset(&store, 0, sizeof(store));\n\t\tswitch (addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tmemcpy(&store.sin, addr, sizeof(struct sockaddr_in));\n\t\t\tstore.sin.sin_port = 0;\n\t\t\tbreak;\n#endif\n#ifdef INET6\n\t\tcase AF_INET6:\n\t\t\tmemcpy(&store.sin6, addr, sizeof(struct sockaddr_in6));\n\t\t\tstore.sin6.sin6_port = 0;\n\t\t\tbreak;\n#endif\n#if defined(__Userspace__)\n\t\tcase AF_CONN:\n\t\t\tmemcpy(&store.sconn, addr, sizeof(struct sockaddr_conn));\n\t\t\tstore.sconn.sconn_port = 0;\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * first find the interface with the bound address need to\n\t\t * zero out the port to find the address! yuck! can't do\n\t\t * this earlier since need port for sctp_pcb_findep()\n\t\t */\n\t\tif (sctp_ifap != NULL) {\n\t\t\tifa = sctp_ifap;\n\t\t} else {\n\t\t\t/* Note for BSD we hit here always other\n\t\t\t * O/S's will pass things in via the\n\t\t\t * sctp_ifap argument (Panda).\n\t\t\t */\n\t\t\tifa = sctp_find_ifa_by_addr(&store.sa,\n\t\t\t\t\t\t    vrf_id, SCTP_ADDR_NOT_LOCKED);\n\t\t}\n\t\tif (ifa == NULL) {\n\t\t\t/* Can't find an interface with that address */\n\t\t\tSCTP_INP_WUNLOCK(inp);\n\t\t\tSCTP_INP_INFO_WUNLOCK();\n\t\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, EADDRNOTAVAIL);\n\t\t\treturn (EADDRNOTAVAIL);\n\t\t}\n#ifdef INET6\n\t\tif (addr->sa_family == AF_INET6) {\n\t\t\t/* GAK, more FIXME IFA lock? */\n\t\t\tif (ifa->localifa_flags & SCTP_ADDR_IFA_UNUSEABLE) {\n\t\t\t\t/* Can't bind a non-existent addr. */\n\t\t\t\tSCTP_INP_WUNLOCK(inp);\n\t\t\t\tSCTP_INP_INFO_WUNLOCK();\n\t\t\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, EINVAL);\n\t\t\t\treturn (EINVAL);\n\t\t\t}\n\t\t}\n#endif\n\t\t/* we're not bound all */\n\t\tinp->sctp_flags &= ~SCTP_PCB_FLAGS_BOUNDALL;\n\t\t/* allow bindx() to send ASCONF's for binding changes */\n\t\tsctp_feature_on(inp, SCTP_PCB_FLAGS_DO_ASCONF);\n\t\t/* clear automatic addr changes from kernel flag */\n\t\tsctp_feature_off(inp, SCTP_PCB_FLAGS_AUTO_ASCONF);\n\n\t\t/* add this address to the endpoint list */\n\t\terror = sctp_insert_laddr(&inp->sctp_addr_list, ifa, 0);\n\t\tif (error != 0) {\n\t\t\tSCTP_INP_WUNLOCK(inp);\n\t\t\tSCTP_INP_INFO_WUNLOCK();\n\t\t\treturn (error);\n\t\t}\n\t\tinp->laddr_count++;\n\t}\n\t/* find the bucket */\n\tif (port_reuse_active) {\n\t\t/* Put it into tcp 1-2-1 hash */\n\t\thead = &SCTP_BASE_INFO(sctp_tcpephash)[SCTP_PCBHASH_ALLADDR(lport, SCTP_BASE_INFO(hashtcpmark))];\n\t\tinp->sctp_flags |= SCTP_PCB_FLAGS_IN_TCPPOOL;\n\t} else {\n\t\thead = &SCTP_BASE_INFO(sctp_ephash)[SCTP_PCBHASH_ALLADDR(lport, SCTP_BASE_INFO(hashmark))];\n\t}\n\t/* put it in the bucket */\n\tLIST_INSERT_HEAD(head, inp, sctp_hash);\n\tSCTPDBG(SCTP_DEBUG_PCB1, \"Main hash to bind at head:%p, bound port:%d - in tcp_pool=%d\\n\",\n\t\t(void *)head, ntohs(lport), port_reuse_active);\n\t/* set in the port */\n\tinp->sctp_lport = lport;\n\n\t/* turn off just the unbound flag */\n\tinp->sctp_flags &= ~SCTP_PCB_FLAGS_UNBOUND;\n\tSCTP_INP_WUNLOCK(inp);\n\tSCTP_INP_INFO_WUNLOCK();\n\treturn (0);\n}\n\n\nstatic void\nsctp_iterator_inp_being_freed(struct sctp_inpcb *inp)\n{\n\tstruct sctp_iterator *it, *nit;\n\n\t/*\n\t * We enter with the only the ITERATOR_LOCK in place and a write\n\t * lock on the inp_info stuff.\n\t */\n\tit = sctp_it_ctl.cur_it;\n#if defined(__FreeBSD__) && __FreeBSD_version >= 801000\n\tif (it && (it->vn != curvnet)) {\n\t\t/* Its not looking at our VNET */\n\t\treturn;\n\t}\n#endif\n\tif (it && (it->inp == inp)) {\n\t\t/*\n\t\t * This is tricky and we hold the iterator lock,\n\t\t * but when it returns and gets the lock (when we\n\t\t * release it) the iterator will try to operate on\n\t\t * inp. We need to stop that from happening. But\n\t\t * of course the iterator has a reference on the\n\t\t * stcb and inp. We can mark it and it will stop.\n\t\t *\n\t\t * If its a single iterator situation, we\n\t\t * set the end iterator flag. Otherwise\n\t\t * we set the iterator to go to the next inp.\n\t\t *\n\t\t */\n\t\tif (it->iterator_flags & SCTP_ITERATOR_DO_SINGLE_INP) {\n\t\t\tsctp_it_ctl.iterator_flags |= SCTP_ITERATOR_STOP_CUR_IT;\n\t\t} else {\n\t\t\tsctp_it_ctl.iterator_flags |= SCTP_ITERATOR_STOP_CUR_INP;\n\t\t}\n\t}\n\t/* Now go through and remove any single reference to\n\t * our inp that may be still pending on the list\n\t */\n\tSCTP_IPI_ITERATOR_WQ_LOCK();\n\tTAILQ_FOREACH_SAFE(it, &sctp_it_ctl.iteratorhead, sctp_nxt_itr, nit) {\n#if defined(__FreeBSD__) && __FreeBSD_version >= 801000\n\t\tif (it->vn != curvnet) {\n\t\t\tcontinue;\n\t\t}\n#endif\n\t\tif (it->inp == inp) {\n\t\t\t/* This one points to me is it inp specific? */\n\t\t\tif (it->iterator_flags & SCTP_ITERATOR_DO_SINGLE_INP) {\n\t\t\t\t/* Remove and free this one */\n\t\t\t\tTAILQ_REMOVE(&sctp_it_ctl.iteratorhead,\n\t\t\t\t    it, sctp_nxt_itr);\n\t\t\t\tif (it->function_atend != NULL) {\n\t\t\t\t\t(*it->function_atend) (it->pointer, it->val);\n\t\t\t\t}\n\t\t\t\tSCTP_FREE(it, SCTP_M_ITER);\n\t\t\t} else {\n\t\t\t\tit->inp = LIST_NEXT(it->inp, sctp_list);\n\t\t\t\tif (it->inp) {\n\t\t\t\t\tSCTP_INP_INCR_REF(it->inp);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* When its put in the refcnt is incremented so decr it */\n\t\t\tSCTP_INP_DECR_REF(inp);\n\t\t}\n\t}\n\tSCTP_IPI_ITERATOR_WQ_UNLOCK();\n}\n\n/* release sctp_inpcb unbind the port */\nvoid\nsctp_inpcb_free(struct sctp_inpcb *inp, int immediate, int from)\n{\n\t/*\n\t * Here we free a endpoint. We must find it (if it is in the Hash\n\t * table) and remove it from there. Then we must also find it in the\n\t * overall list and remove it from there. After all removals are\n\t * complete then any timer has to be stopped. Then start the actual\n\t * freeing. a) Any local lists. b) Any associations. c) The hash of\n\t * all associations. d) finally the ep itself.\n\t */\n\tstruct sctp_tcb *asoc, *nasoc;\n\tstruct sctp_laddr *laddr, *nladdr;\n\tstruct inpcb *ip_pcb;\n\tstruct socket *so;\n\tint being_refed = 0;\n\tstruct sctp_queued_to_read *sq, *nsq;\n#if !defined(__Panda__) && !defined(__Userspace__)\n#if !defined(__FreeBSD__) || __FreeBSD_version < 500000\n\tsctp_rtentry_t *rt;\n#endif\n#endif\n\tint cnt;\n\tsctp_sharedkey_t *shared_key, *nshared_key;\n\n\n#if defined(__APPLE__)\n\tsctp_lock_assert(SCTP_INP_SO(inp));\n#endif\n#ifdef SCTP_LOG_CLOSING\n\tsctp_log_closing(inp, NULL, 0);\n#endif\n\tSCTP_ITERATOR_LOCK();\n\t/* mark any iterators on the list or being processed */\n\tsctp_iterator_inp_being_freed(inp);\n\tSCTP_ITERATOR_UNLOCK();\n\tso = inp->sctp_socket;\n\tif (inp->sctp_flags & SCTP_PCB_FLAGS_SOCKET_ALLGONE) {\n\t\t/* been here before.. eeks.. get out of here */\n\t\tSCTP_PRINTF(\"This conflict in free SHOULD not be happening! from %d, imm %d\\n\", from, immediate);\n#ifdef SCTP_LOG_CLOSING\n\t\tsctp_log_closing(inp, NULL, 1);\n#endif\n\t\treturn;\n\t}\n\tSCTP_ASOC_CREATE_LOCK(inp);\n\tSCTP_INP_INFO_WLOCK();\n\n\tSCTP_INP_WLOCK(inp);\n\tif (from == SCTP_CALLED_AFTER_CMPSET_OFCLOSE) {\n\t\tinp->sctp_flags &= ~SCTP_PCB_FLAGS_CLOSE_IP;\n\t\t/* socket is gone, so no more wakeups allowed */\n\t\tinp->sctp_flags |= SCTP_PCB_FLAGS_DONT_WAKE;\n\t\tinp->sctp_flags &= ~SCTP_PCB_FLAGS_WAKEINPUT;\n\t\tinp->sctp_flags &= ~SCTP_PCB_FLAGS_WAKEOUTPUT;\n\n\t}\n\t/* First time through we have the socket lock, after that no more. */\n\tsctp_timer_stop(SCTP_TIMER_TYPE_NEWCOOKIE, inp, NULL, NULL,\n\t\t\tSCTP_FROM_SCTP_PCB + SCTP_LOC_1);\n\n\tif (inp->control) {\n\t\tsctp_m_freem(inp->control);\n\t\tinp->control = NULL;\n\t}\n\tif (inp->pkt) {\n\t\tsctp_m_freem(inp->pkt);\n\t\tinp->pkt = NULL;\n\t}\n\tip_pcb = &inp->ip_inp.inp;\t/* we could just cast the main pointer\n\t\t\t\t\t * here but I will be nice :> (i.e.\n\t\t\t\t\t * ip_pcb = ep;) */\n\tif (immediate == SCTP_FREE_SHOULD_USE_GRACEFUL_CLOSE) {\n\t\tint cnt_in_sd;\n\n\t\tcnt_in_sd = 0;\n\t\tLIST_FOREACH_SAFE(asoc, &inp->sctp_asoc_list, sctp_tcblist, nasoc) {\n\t\t\tSCTP_TCB_LOCK(asoc);\n\t\t\tif (asoc->asoc.state & SCTP_STATE_ABOUT_TO_BE_FREED) {\n\t\t\t\t/* Skip guys being freed */\n\t\t\t\tcnt_in_sd++;\n\t\t\t\tif (asoc->asoc.state & SCTP_STATE_IN_ACCEPT_QUEUE) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Special case - we did not start a kill\n\t\t\t\t\t * timer on the asoc due to it was not\n\t\t\t\t\t * closed. So go ahead and start it now.\n\t\t\t\t\t */\n\t\t\t\t\tSCTP_CLEAR_SUBSTATE(asoc, SCTP_STATE_IN_ACCEPT_QUEUE);\n\t\t\t\t\tsctp_timer_start(SCTP_TIMER_TYPE_ASOCKILL, inp, asoc, NULL);\n\t\t\t\t}\n\t\t\t\tSCTP_TCB_UNLOCK(asoc);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (((SCTP_GET_STATE(asoc) == SCTP_STATE_COOKIE_WAIT) ||\n\t\t\t     (SCTP_GET_STATE(asoc) == SCTP_STATE_COOKIE_ECHOED)) &&\n\t\t\t    (asoc->asoc.total_output_queue_size == 0)) {\n\t\t\t\t/* If we have data in queue, we don't want to just\n\t\t\t\t * free since the app may have done, send()/close\n\t\t\t\t * or connect/send/close. And it wants the data\n\t\t\t\t * to get across first.\n\t\t\t\t */\n\t\t\t\t/* Just abandon things in the front states */\n\t\t\t\tif (sctp_free_assoc(inp, asoc, SCTP_PCBFREE_NOFORCE,\n\t\t\t\t\t\t   SCTP_FROM_SCTP_PCB + SCTP_LOC_2) == 0) {\n\t\t\t\t\tcnt_in_sd++;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* Disconnect the socket please */\n\t\t\tasoc->sctp_socket = NULL;\n\t\t\tSCTP_ADD_SUBSTATE(asoc, SCTP_STATE_CLOSED_SOCKET);\n\t\t\tif ((asoc->asoc.size_on_reasm_queue > 0) ||\n\t\t\t    (asoc->asoc.control_pdapi) ||\n\t\t\t    (asoc->asoc.size_on_all_streams > 0) ||\n\t\t\t    (so && (so->so_rcv.sb_cc > 0))) {\n\t\t\t\t/* Left with Data unread */\n\t\t\t\tstruct mbuf *op_err;\n\n\t\t\t\top_err = sctp_generate_cause(SCTP_CAUSE_USER_INITIATED_ABT, \"\");\n\t\t\t\tasoc->sctp_ep->last_abort_code = SCTP_FROM_SCTP_PCB + SCTP_LOC_3;\n\t\t\t\tsctp_send_abort_tcb(asoc, op_err, SCTP_SO_LOCKED);\n\t\t\t\tSCTP_STAT_INCR_COUNTER32(sctps_aborted);\n\t\t\t\tif ((SCTP_GET_STATE(asoc) == SCTP_STATE_OPEN) ||\n\t\t\t\t    (SCTP_GET_STATE(asoc) == SCTP_STATE_SHUTDOWN_RECEIVED)) {\n\t\t\t\t\tSCTP_STAT_DECR_GAUGE32(sctps_currestab);\n\t\t\t\t}\n\t\t\t\tif (sctp_free_assoc(inp, asoc,\n\t\t\t\t\t\t    SCTP_PCBFREE_NOFORCE, SCTP_FROM_SCTP_PCB + SCTP_LOC_4) == 0) {\n\t\t\t\t\tcnt_in_sd++;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t} else if (TAILQ_EMPTY(&asoc->asoc.send_queue) &&\n\t\t\t           TAILQ_EMPTY(&asoc->asoc.sent_queue) &&\n\t\t\t           (asoc->asoc.stream_queue_cnt == 0)) {\n\t\t\t\tif ((*asoc->asoc.ss_functions.sctp_ss_is_user_msgs_incomplete)(asoc, &asoc->asoc)) {\n\t\t\t\t\tgoto abort_anyway;\n\t\t\t\t}\n\t\t\t\tif ((SCTP_GET_STATE(asoc) != SCTP_STATE_SHUTDOWN_SENT) &&\n\t\t\t\t    (SCTP_GET_STATE(asoc) != SCTP_STATE_SHUTDOWN_ACK_SENT)) {\n\t\t\t\t\tstruct sctp_nets *netp;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * there is nothing queued to send,\n\t\t\t\t\t * so I send shutdown\n\t\t\t\t\t */\n\t\t\t\t\tif ((SCTP_GET_STATE(asoc) == SCTP_STATE_OPEN) ||\n\t\t\t\t\t    (SCTP_GET_STATE(asoc) == SCTP_STATE_SHUTDOWN_RECEIVED)) {\n\t\t\t\t\t\tSCTP_STAT_DECR_GAUGE32(sctps_currestab);\n\t\t\t\t\t}\n\t\t\t\t\tSCTP_SET_STATE(asoc, SCTP_STATE_SHUTDOWN_SENT);\n\t\t\t\t\tsctp_stop_timers_for_shutdown(asoc);\n\t\t\t\t\tif (asoc->asoc.alternate) {\n\t\t\t\t\t\tnetp = asoc->asoc.alternate;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnetp = asoc->asoc.primary_destination;\n\t\t\t\t\t}\n\t\t\t\t\tsctp_send_shutdown(asoc, netp);\n\t\t\t\t\tsctp_timer_start(SCTP_TIMER_TYPE_SHUTDOWN, asoc->sctp_ep, asoc,\n\t\t\t\t\t    netp);\n\t\t\t\t\tsctp_timer_start(SCTP_TIMER_TYPE_SHUTDOWNGUARD, asoc->sctp_ep, asoc,\n\t\t\t\t\t    asoc->asoc.primary_destination);\n\t\t\t\t\tsctp_chunk_output(inp, asoc, SCTP_OUTPUT_FROM_SHUT_TMR, SCTP_SO_LOCKED);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* mark into shutdown pending */\n\t\t\t\tSCTP_ADD_SUBSTATE(asoc, SCTP_STATE_SHUTDOWN_PENDING);\n\t\t\t\tsctp_timer_start(SCTP_TIMER_TYPE_SHUTDOWNGUARD, asoc->sctp_ep, asoc,\n\t\t\t\t\t\t asoc->asoc.primary_destination);\n\t\t\t\tif ((*asoc->asoc.ss_functions.sctp_ss_is_user_msgs_incomplete)(asoc, &asoc->asoc)) {\n\t\t\t\t\tSCTP_ADD_SUBSTATE(asoc, SCTP_STATE_PARTIAL_MSG_LEFT);\n\t\t\t\t}\n\t\t\t\tif (TAILQ_EMPTY(&asoc->asoc.send_queue) &&\n\t\t\t\t    TAILQ_EMPTY(&asoc->asoc.sent_queue) &&\n\t\t\t\t    (asoc->asoc.state & SCTP_STATE_PARTIAL_MSG_LEFT)) {\n\t\t\t\t\tstruct mbuf *op_err;\n\t\t\t\tabort_anyway:\n\t\t\t\t\top_err = sctp_generate_cause(SCTP_CAUSE_USER_INITIATED_ABT, \"\");\n\t\t\t\t\tasoc->sctp_ep->last_abort_code = SCTP_FROM_SCTP_PCB + SCTP_LOC_5;\n\t\t\t\t\tsctp_send_abort_tcb(asoc, op_err, SCTP_SO_LOCKED);\n\t\t\t\t\tSCTP_STAT_INCR_COUNTER32(sctps_aborted);\n\t\t\t\t\tif ((SCTP_GET_STATE(asoc) == SCTP_STATE_OPEN) ||\n\t\t\t\t\t    (SCTP_GET_STATE(asoc) == SCTP_STATE_SHUTDOWN_RECEIVED)) {\n\t\t\t\t\t\tSCTP_STAT_DECR_GAUGE32(sctps_currestab);\n\t\t\t\t\t}\n\t\t\t\t\tif (sctp_free_assoc(inp, asoc,\n\t\t\t\t\t\t\t    SCTP_PCBFREE_NOFORCE,\n\t\t\t\t\t\t\t    SCTP_FROM_SCTP_PCB + SCTP_LOC_6) == 0) {\n\t\t\t\t\t\tcnt_in_sd++;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tsctp_chunk_output(inp, asoc, SCTP_OUTPUT_FROM_CLOSING, SCTP_SO_LOCKED);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcnt_in_sd++;\n\t\t\tSCTP_TCB_UNLOCK(asoc);\n\t\t}\n\t\t/* now is there some left in our SHUTDOWN state? */\n\t\tif (cnt_in_sd) {\n#ifdef SCTP_LOG_CLOSING\n\t\t\tsctp_log_closing(inp, NULL, 2);\n#endif\n\t\t\tinp->sctp_socket = NULL;\n\t\t\tSCTP_INP_WUNLOCK(inp);\n\t\t\tSCTP_ASOC_CREATE_UNLOCK(inp);\n\t\t\tSCTP_INP_INFO_WUNLOCK();\n\t\t\treturn;\n\t\t}\n\t}\n\tinp->sctp_socket = NULL;\n\tif ((inp->sctp_flags & SCTP_PCB_FLAGS_UNBOUND) !=\n\t    SCTP_PCB_FLAGS_UNBOUND) {\n\t\t/*\n\t\t * ok, this guy has been bound. It's port is\n\t\t * somewhere in the SCTP_BASE_INFO(hash table). Remove\n\t\t * it!\n\t\t */\n\t\tLIST_REMOVE(inp, sctp_hash);\n\t\tinp->sctp_flags |= SCTP_PCB_FLAGS_UNBOUND;\n\t}\n\n\t/* If there is a timer running to kill us,\n\t * forget it, since it may have a contest\n\t * on the INP lock.. which would cause us\n\t * to die ...\n\t */\n\tcnt = 0;\n\tLIST_FOREACH_SAFE(asoc, &inp->sctp_asoc_list, sctp_tcblist, nasoc) {\n\t\tSCTP_TCB_LOCK(asoc);\n\t\tif (asoc->asoc.state & SCTP_STATE_ABOUT_TO_BE_FREED) {\n\t\t\tif (asoc->asoc.state & SCTP_STATE_IN_ACCEPT_QUEUE) {\n\t\t\t\tSCTP_CLEAR_SUBSTATE(asoc, SCTP_STATE_IN_ACCEPT_QUEUE);\n\t\t\t\tsctp_timer_start(SCTP_TIMER_TYPE_ASOCKILL, inp, asoc, NULL);\n\t\t\t}\n\t\t        cnt++;\n\t\t\tSCTP_TCB_UNLOCK(asoc);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Free associations that are NOT killing us */\n\t\tif ((SCTP_GET_STATE(asoc) != SCTP_STATE_COOKIE_WAIT) &&\n\t\t    ((asoc->asoc.state & SCTP_STATE_ABOUT_TO_BE_FREED) == 0)) {\n\t\t\tstruct mbuf *op_err;\n\n\t\t\top_err = sctp_generate_cause(SCTP_CAUSE_USER_INITIATED_ABT, \"\");\n\t\t\tasoc->sctp_ep->last_abort_code = SCTP_FROM_SCTP_PCB + SCTP_LOC_7;\n\t\t\tsctp_send_abort_tcb(asoc, op_err, SCTP_SO_LOCKED);\n\t\t\tSCTP_STAT_INCR_COUNTER32(sctps_aborted);\n\t\t} else if (asoc->asoc.state & SCTP_STATE_ABOUT_TO_BE_FREED) {\n\t\t\tcnt++;\n\t\t\tSCTP_TCB_UNLOCK(asoc);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((SCTP_GET_STATE(asoc) == SCTP_STATE_OPEN) ||\n\t\t    (SCTP_GET_STATE(asoc) == SCTP_STATE_SHUTDOWN_RECEIVED)) {\n\t\t\tSCTP_STAT_DECR_GAUGE32(sctps_currestab);\n\t\t}\n\t\tif (sctp_free_assoc(inp, asoc, SCTP_PCBFREE_FORCE,\n\t\t                    SCTP_FROM_SCTP_PCB + SCTP_LOC_8) == 0) {\n\t\t\tcnt++;\n\t\t}\n\t}\n\tif (cnt) {\n\t\t/* Ok we have someone out there that will kill us */\n\t\t(void)SCTP_OS_TIMER_STOP(&inp->sctp_ep.signature_change.timer);\n#ifdef SCTP_LOG_CLOSING\n\t\tsctp_log_closing(inp, NULL, 3);\n#endif\n\t\tSCTP_INP_WUNLOCK(inp);\n\t\tSCTP_ASOC_CREATE_UNLOCK(inp);\n\t\tSCTP_INP_INFO_WUNLOCK();\n\t\treturn;\n\t}\n\tif (SCTP_INP_LOCK_CONTENDED(inp))\n\t\tbeing_refed++;\n\tif (SCTP_INP_READ_CONTENDED(inp))\n\t\tbeing_refed++;\n\tif (SCTP_ASOC_CREATE_LOCK_CONTENDED(inp))\n\t\tbeing_refed++;\n\n\tif ((inp->refcount) ||\n\t    (being_refed) ||\n\t    (inp->sctp_flags & SCTP_PCB_FLAGS_CLOSE_IP)) {\n\t\t(void)SCTP_OS_TIMER_STOP(&inp->sctp_ep.signature_change.timer);\n#ifdef SCTP_LOG_CLOSING\n\t\tsctp_log_closing(inp, NULL, 4);\n#endif\n\t\tsctp_timer_start(SCTP_TIMER_TYPE_INPKILL, inp, NULL, NULL);\n\t\tSCTP_INP_WUNLOCK(inp);\n\t\tSCTP_ASOC_CREATE_UNLOCK(inp);\n\t\tSCTP_INP_INFO_WUNLOCK();\n\t\treturn;\n\t}\n\tinp->sctp_ep.signature_change.type = 0;\n\tinp->sctp_flags |= SCTP_PCB_FLAGS_SOCKET_ALLGONE;\n\t/* Remove it from the list .. last thing we need a\n\t * lock for.\n\t */\n\tLIST_REMOVE(inp, sctp_list);\n\tSCTP_INP_WUNLOCK(inp);\n\tSCTP_ASOC_CREATE_UNLOCK(inp);\n\tSCTP_INP_INFO_WUNLOCK();\n\t/* Now we release all locks. Since this INP\n\t * cannot be found anymore except possibly by the\n\t * kill timer that might be running. We call\n\t * the drain function here. It should hit the case\n\t * were it sees the ACTIVE flag cleared and exit\n\t * out freeing us to proceed and destroy everything.\n\t */\n\tif (from != SCTP_CALLED_FROM_INPKILL_TIMER) {\n\t\t(void)SCTP_OS_TIMER_STOP_DRAIN(&inp->sctp_ep.signature_change.timer);\n\t} else {\n\t\t/* Probably un-needed */\n\t\t(void)SCTP_OS_TIMER_STOP(&inp->sctp_ep.signature_change.timer);\n\t}\n\n#ifdef SCTP_LOG_CLOSING\n\tsctp_log_closing(inp, NULL, 5);\n#endif\n\n#if !(defined(__Panda__) || defined(__Windows__) || defined(__Userspace__))\n#if !defined(__FreeBSD__) || __FreeBSD_version < 500000\n\trt = ip_pcb->inp_route.ro_rt;\n#endif\n#endif\n\n\tif ((inp->sctp_asocidhash) != NULL) {\n\t\tSCTP_HASH_FREE(inp->sctp_asocidhash, inp->hashasocidmark);\n\t\tinp->sctp_asocidhash = NULL;\n\t}\n\t/*sa_ignore FREED_MEMORY*/\n\tTAILQ_FOREACH_SAFE(sq, &inp->read_queue, next, nsq) {\n\t\t/* Its only abandoned if it had data left */\n\t\tif (sq->length)\n\t\t\tSCTP_STAT_INCR(sctps_left_abandon);\n\n\t\tTAILQ_REMOVE(&inp->read_queue, sq, next);\n\t\tsctp_free_remote_addr(sq->whoFrom);\n\t\tif (so)\n\t\t\tso->so_rcv.sb_cc -= sq->length;\n\t\tif (sq->data) {\n\t\t\tsctp_m_freem(sq->data);\n\t\t\tsq->data = NULL;\n\t\t}\n\t\t/*\n\t\t * no need to free the net count, since at this point all\n\t\t * assoc's are gone.\n\t\t */\n\t\tsctp_free_a_readq(NULL, sq);\n\t}\n\t/* Now the sctp_pcb things */\n\t/*\n\t * free each asoc if it is not already closed/free. we can't use the\n\t * macro here since le_next will get freed as part of the\n\t * sctp_free_assoc() call.\n\t */\n#ifndef __Panda__\n\tif (ip_pcb->inp_options) {\n\t\t(void)sctp_m_free(ip_pcb->inp_options);\n\t\tip_pcb->inp_options = 0;\n\t}\n#endif\n\n#if !(defined(__Panda__) || defined(__Windows__) || defined(__Userspace__))\n#if !defined(__FreeBSD__) || __FreeBSD_version < 500000\n\tif (rt) {\n\t\tRTFREE(rt);\n\t\tip_pcb->inp_route.ro_rt = 0;\n\t}\n#endif\n#if defined(__FreeBSD__) && __FreeBSD_version < 803000\n#ifdef INET\n\tif (ip_pcb->inp_moptions) {\n\t\tinp_freemoptions(ip_pcb->inp_moptions);\n\t\tip_pcb->inp_moptions = 0;\n\t}\n#endif\n#endif\n#endif\n\n#ifdef INET6\n#if !(defined(__Panda__) || defined(__Windows__) || defined(__Userspace__))\n#if defined(__FreeBSD__) || defined(__APPLE__)\n\tif (ip_pcb->inp_vflag & INP_IPV6) {\n#else\n\tif (inp->inp_vflag & INP_IPV6) {\n#endif\n\t\tip6_freepcbopts(ip_pcb->in6p_outputopts);\n\t}\n#endif\n#endif\t\t\t\t/* INET6 */\n#if !(defined(__FreeBSD__) || defined(__APPLE__) || defined(__Windows__) || defined(__Userspace__))\n\tinp->inp_vflag = 0;\n#else\n\tip_pcb->inp_vflag = 0;\n#endif\n\t/* free up authentication fields */\n\tif (inp->sctp_ep.local_auth_chunks != NULL)\n\t\tsctp_free_chunklist(inp->sctp_ep.local_auth_chunks);\n\tif (inp->sctp_ep.local_hmacs != NULL)\n\t\tsctp_free_hmaclist(inp->sctp_ep.local_hmacs);\n\n\tLIST_FOREACH_SAFE(shared_key, &inp->sctp_ep.shared_keys, next, nshared_key) {\n\t\tLIST_REMOVE(shared_key, next);\n\t\tsctp_free_sharedkey(shared_key);\n\t\t/*sa_ignore FREED_MEMORY*/\n\t}\n\n#if defined(__APPLE__)\n\tinp->ip_inp.inp.inp_state = INPCB_STATE_DEAD;\n\tif (in_pcb_checkstate(&inp->ip_inp.inp, WNT_STOPUSING, 1) != WNT_STOPUSING) {\n#ifdef INVARIANTS\n\t\tpanic(\"sctp_inpcb_free inp = %p couldn't set to STOPUSING\\n\", (void *)inp);\n#else\n\t\tSCTP_PRINTF(\"sctp_inpcb_free inp = %p couldn't set to STOPUSING\\n\", (void *)inp);\n#endif\n\t}\n\tinp->ip_inp.inp.inp_socket->so_flags |= SOF_PCBCLEARING;\n#endif\n\t/*\n\t * if we have an address list the following will free the list of\n\t * ifaddr's that are set into this ep. Again macro limitations here,\n\t * since the LIST_FOREACH could be a bad idea.\n\t */\n\tLIST_FOREACH_SAFE(laddr, &inp->sctp_addr_list, sctp_nxt_addr, nladdr) {\n\t\tsctp_remove_laddr(laddr);\n\t}\n\n#ifdef SCTP_TRACK_FREED_ASOCS\n\t/* TEMP CODE */\n\tLIST_FOREACH_SAFE(asoc, &inp->sctp_asoc_free_list, sctp_tcblist, nasoc) {\n\t\tLIST_REMOVE(asoc, sctp_tcblist);\n\t\tSCTP_ZONE_FREE(SCTP_BASE_INFO(ipi_zone_asoc), asoc);\n\t\tSCTP_DECR_ASOC_COUNT();\n\t}\n\t/* *** END TEMP CODE ****/\n#endif\n#ifdef SCTP_MVRF\n\tSCTP_FREE(inp->m_vrf_ids, SCTP_M_MVRF);\n#endif\n\t/* Now lets see about freeing the EP hash table. */\n\tif (inp->sctp_tcbhash != NULL) {\n\t\tSCTP_HASH_FREE(inp->sctp_tcbhash, inp->sctp_hashmark);\n\t\tinp->sctp_tcbhash = NULL;\n\t}\n\t/* Now we must put the ep memory back into the zone pool */\n#if defined(__FreeBSD__)\n\tcrfree(inp->ip_inp.inp.inp_cred);\n\tINP_LOCK_DESTROY(&inp->ip_inp.inp);\n#endif\n\tSCTP_INP_LOCK_DESTROY(inp);\n\tSCTP_INP_READ_DESTROY(inp);\n\tSCTP_ASOC_CREATE_LOCK_DESTROY(inp);\n#if !defined(__APPLE__)\n\tSCTP_ZONE_FREE(SCTP_BASE_INFO(ipi_zone_ep), inp);\n\tSCTP_DECR_EP_COUNT();\n#else\n\t/* For Tiger, we will do this later... */\n#endif\n}\n\n\nstruct sctp_nets *\nsctp_findnet(struct sctp_tcb *stcb, struct sockaddr *addr)\n{\n\tstruct sctp_nets *net;\n\t/* locate the address */\n\tTAILQ_FOREACH(net, &stcb->asoc.nets, sctp_next) {\n\t\tif (sctp_cmpaddr(addr, (struct sockaddr *)&net->ro._l_addr))\n\t\t\treturn (net);\n\t}\n\treturn (NULL);\n}\n\n\nint\nsctp_is_address_on_local_host(struct sockaddr *addr, uint32_t vrf_id)\n{\n#ifdef __Panda__\n\treturn (0);\n#else\n\tstruct sctp_ifa *sctp_ifa;\n\tsctp_ifa = sctp_find_ifa_by_addr(addr, vrf_id, SCTP_ADDR_NOT_LOCKED);\n\tif (sctp_ifa) {\n\t\treturn (1);\n\t} else {\n\t\treturn (0);\n\t}\n#endif\n}\n\n/*\n * add's a remote endpoint address, done with the INIT/INIT-ACK as well as\n * when a ASCONF arrives that adds it. It will also initialize all the cwnd\n * stats of stuff.\n */\nint\nsctp_add_remote_addr(struct sctp_tcb *stcb, struct sockaddr *newaddr,\n    struct sctp_nets **netp, uint16_t port, int set_scope, int from)\n{\n\t/*\n\t * The following is redundant to the same lines in the\n\t * sctp_aloc_assoc() but is needed since others call the add\n\t * address function\n\t */\n\tstruct sctp_nets *net, *netfirst;\n\tint addr_inscope;\n\n\tSCTPDBG(SCTP_DEBUG_PCB1, \"Adding an address (from:%d) to the peer: \",\n\t\tfrom);\n\tSCTPDBG_ADDR(SCTP_DEBUG_PCB1, newaddr);\n\n\tnetfirst = sctp_findnet(stcb, newaddr);\n\tif (netfirst) {\n\t\t/*\n\t\t * Lie and return ok, we don't want to make the association\n\t\t * go away for this behavior. It will happen in the TCP\n\t\t * model in a connected socket. It does not reach the hash\n\t\t * table until after the association is built so it can't be\n\t\t * found. Mark as reachable, since the initial creation will\n\t\t * have been cleared and the NOT_IN_ASSOC flag will have\n\t\t * been added... and we don't want to end up removing it\n\t\t * back out.\n\t\t */\n\t\tif (netfirst->dest_state & SCTP_ADDR_UNCONFIRMED) {\n\t\t\tnetfirst->dest_state = (SCTP_ADDR_REACHABLE |\n\t\t\t    SCTP_ADDR_UNCONFIRMED);\n\t\t} else {\n\t\t\tnetfirst->dest_state = SCTP_ADDR_REACHABLE;\n\t\t}\n\n\t\treturn (0);\n\t}\n\taddr_inscope = 1;\n\tswitch (newaddr->sa_family) {\n#ifdef INET\n\tcase AF_INET:\n\t{\n\t\tstruct sockaddr_in *sin;\n\n\t\tsin = (struct sockaddr_in *)newaddr;\n\t\tif (sin->sin_addr.s_addr == 0) {\n\t\t\t/* Invalid address */\n\t\t\treturn (-1);\n\t\t}\n\t\t/* zero out the zero area */\n\t\tmemset(&sin->sin_zero, 0, sizeof(sin->sin_zero));\n\n\t\t/* assure len is set */\n#ifdef HAVE_SIN_LEN\n\t\tsin->sin_len = sizeof(struct sockaddr_in);\n#endif\n\t\tif (set_scope) {\n\t\t\tif (IN4_ISPRIVATE_ADDRESS(&sin->sin_addr)) {\n\t\t\t\tstcb->asoc.scope.ipv4_local_scope = 1;\n\t\t\t}\n\t\t} else {\n\t\t\t/* Validate the address is in scope */\n\t\t\tif ((IN4_ISPRIVATE_ADDRESS(&sin->sin_addr)) &&\n\t\t\t    (stcb->asoc.scope.ipv4_local_scope == 0)) {\n\t\t\t\taddr_inscope = 0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n#endif\n#ifdef INET6\n\tcase AF_INET6:\n\t{\n\t\tstruct sockaddr_in6 *sin6;\n\n\t\tsin6 = (struct sockaddr_in6 *)newaddr;\n\t\tif (IN6_IS_ADDR_UNSPECIFIED(&sin6->sin6_addr)) {\n\t\t\t/* Invalid address */\n\t\t\treturn (-1);\n\t\t}\n\t\t/* assure len is set */\n#ifdef HAVE_SIN6_LEN\n\t\tsin6->sin6_len = sizeof(struct sockaddr_in6);\n#endif\n\t\tif (set_scope) {\n\t\t\tif (sctp_is_address_on_local_host(newaddr, stcb->asoc.vrf_id)) {\n\t\t\t\tstcb->asoc.scope.loopback_scope = 1;\n\t\t\t\tstcb->asoc.scope.local_scope = 0;\n\t\t\t\tstcb->asoc.scope.ipv4_local_scope = 1;\n\t\t\t\tstcb->asoc.scope.site_scope = 1;\n\t\t\t} else if (IN6_IS_ADDR_LINKLOCAL(&sin6->sin6_addr)) {\n\t\t\t\t/*\n\t\t\t\t * If the new destination is a LINK_LOCAL we\n\t\t\t\t * must have common site scope. Don't set\n\t\t\t\t * the local scope since we may not share\n\t\t\t\t * all links, only loopback can do this.\n\t\t\t\t * Links on the local network would also be\n\t\t\t\t * on our private network for v4 too.\n\t\t\t\t */\n\t\t\t\tstcb->asoc.scope.ipv4_local_scope = 1;\n\t\t\t\tstcb->asoc.scope.site_scope = 1;\n\t\t\t} else if (IN6_IS_ADDR_SITELOCAL(&sin6->sin6_addr)) {\n\t\t\t\t/*\n\t\t\t\t * If the new destination is SITE_LOCAL then\n\t\t\t\t * we must have site scope in common.\n\t\t\t\t */\n\t\t\t\tstcb->asoc.scope.site_scope = 1;\n\t\t\t}\n\t\t} else {\n\t\t\t/* Validate the address is in scope */\n\t\t\tif (IN6_IS_ADDR_LOOPBACK(&sin6->sin6_addr) &&\n\t\t\t    (stcb->asoc.scope.loopback_scope == 0)) {\n\t\t\t\taddr_inscope = 0;\n\t\t\t} else if (IN6_IS_ADDR_LINKLOCAL(&sin6->sin6_addr) &&\n\t\t\t    (stcb->asoc.scope.local_scope == 0)) {\n\t\t\t\taddr_inscope = 0;\n\t\t\t} else if (IN6_IS_ADDR_SITELOCAL(&sin6->sin6_addr) &&\n\t\t\t    (stcb->asoc.scope.site_scope == 0)) {\n\t\t\t\taddr_inscope = 0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n#endif\n#if defined(__Userspace__)\n\tcase AF_CONN:\n\t{\n\t\tstruct sockaddr_conn *sconn;\n\n\t\tsconn = (struct sockaddr_conn *)newaddr;\n\t\tif (sconn->sconn_addr == NULL) {\n\t\t\t/* Invalid address */\n\t\t\treturn (-1);\n\t\t}\n#ifdef HAVE_SCONN_LEN\n\t\tsconn->sconn_len = sizeof(struct sockaddr_conn);\n#endif\n\t\tbreak;\n\t}\n#endif\n\tdefault:\n\t\t/* not supported family type */\n\t\treturn (-1);\n\t}\n\tnet = SCTP_ZONE_GET(SCTP_BASE_INFO(ipi_zone_net), struct sctp_nets);\n\tif (net == NULL) {\n\t\treturn (-1);\n\t}\n\tSCTP_INCR_RADDR_COUNT();\n\tmemset(net, 0, sizeof(struct sctp_nets));\n\t(void)SCTP_GETTIME_TIMEVAL(&net->start_time);\n#ifdef HAVE_SA_LEN\n\tmemcpy(&net->ro._l_addr, newaddr, newaddr->sa_len);\n#endif\n\tswitch (newaddr->sa_family) {\n#ifdef INET\n\tcase AF_INET:\n#ifndef HAVE_SA_LEN\n\t\tmemcpy(&net->ro._l_addr, newaddr, sizeof(struct sockaddr_in));\n#endif\n\t\t((struct sockaddr_in *)&net->ro._l_addr)->sin_port = stcb->rport;\n\t\tbreak;\n#endif\n#ifdef INET6\n\tcase AF_INET6:\n#ifndef HAVE_SA_LEN\n\t\tmemcpy(&net->ro._l_addr, newaddr, sizeof(struct sockaddr_in6));\n#endif\n\t\t((struct sockaddr_in6 *)&net->ro._l_addr)->sin6_port = stcb->rport;\n\t\tbreak;\n#endif\n#if defined(__Userspace__)\n\tcase AF_CONN:\n#ifndef HAVE_SA_LEN\n\t\tmemcpy(&net->ro._l_addr, newaddr, sizeof(struct sockaddr_conn));\n#endif\n\t\t((struct sockaddr_conn *)&net->ro._l_addr)->sconn_port = stcb->rport;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\tnet->addr_is_local = sctp_is_address_on_local_host(newaddr, stcb->asoc.vrf_id);\n\tif (net->addr_is_local && ((set_scope || (from == SCTP_ADDR_IS_CONFIRMED)))) {\n\t\tstcb->asoc.scope.loopback_scope = 1;\n\t\tstcb->asoc.scope.ipv4_local_scope = 1;\n\t\tstcb->asoc.scope.local_scope = 0;\n\t\tstcb->asoc.scope.site_scope = 1;\n\t\taddr_inscope = 1;\n\t}\n\tnet->failure_threshold = stcb->asoc.def_net_failure;\n\tnet->pf_threshold = stcb->asoc.def_net_pf_threshold;\n\tif (addr_inscope == 0) {\n\t\tnet->dest_state = (SCTP_ADDR_REACHABLE |\n\t\t    SCTP_ADDR_OUT_OF_SCOPE);\n\t} else {\n\t\tif (from == SCTP_ADDR_IS_CONFIRMED)\n\t\t\t/* SCTP_ADDR_IS_CONFIRMED is passed by connect_x */\n\t\t\tnet->dest_state = SCTP_ADDR_REACHABLE;\n\t\telse\n\t\t\tnet->dest_state = SCTP_ADDR_REACHABLE |\n\t\t\t    SCTP_ADDR_UNCONFIRMED;\n\t}\n\t/* We set this to 0, the timer code knows that\n\t * this means its an initial value\n\t */\n\tnet->rto_needed = 1;\n\tnet->RTO = 0;\n\tnet->RTO_measured = 0;\n\tstcb->asoc.numnets++;\n\tnet->ref_count = 1;\n\tnet->cwr_window_tsn = net->last_cwr_tsn = stcb->asoc.sending_seq - 1;\n\tnet->port = port;\n\tnet->dscp = stcb->asoc.default_dscp;\n#ifdef INET6\n\tnet->flowlabel = stcb->asoc.default_flowlabel;\n#endif\n\tif (sctp_stcb_is_feature_on(stcb->sctp_ep, stcb, SCTP_PCB_FLAGS_DONOT_HEARTBEAT)) {\n\t\tnet->dest_state |= SCTP_ADDR_NOHB;\n\t} else {\n\t\tnet->dest_state &= ~SCTP_ADDR_NOHB;\n\t}\n\tif (sctp_stcb_is_feature_on(stcb->sctp_ep, stcb, SCTP_PCB_FLAGS_DO_NOT_PMTUD)) {\n\t\tnet->dest_state |= SCTP_ADDR_NO_PMTUD;\n\t} else {\n\t\tnet->dest_state &= ~SCTP_ADDR_NO_PMTUD;\n\t}\n\tnet->heart_beat_delay = stcb->asoc.heart_beat_delay;\n\t/* Init the timer structure */\n\tSCTP_OS_TIMER_INIT(&net->rxt_timer.timer);\n\tSCTP_OS_TIMER_INIT(&net->pmtu_timer.timer);\n\tSCTP_OS_TIMER_INIT(&net->hb_timer.timer);\n\n\t/* Now generate a route for this guy */\n#ifdef INET6\n#ifdef SCTP_EMBEDDED_V6_SCOPE\n\t/* KAME hack: embed scopeid */\n\tif (newaddr->sa_family == AF_INET6) {\n\t\tstruct sockaddr_in6 *sin6;\n\n\t\tsin6 = (struct sockaddr_in6 *)&net->ro._l_addr;\n#if defined(__APPLE__)\n#if defined(APPLE_LEOPARD) || defined(APPLE_SNOWLEOPARD)\n\t\t(void)in6_embedscope(&sin6->sin6_addr, sin6, &stcb->sctp_ep->ip_inp.inp, NULL);\n#else\n\t\t(void)in6_embedscope(&sin6->sin6_addr, sin6, &stcb->sctp_ep->ip_inp.inp, NULL, NULL);\n#endif\n#elif defined(SCTP_KAME)\n\t\t(void)sa6_embedscope(sin6, MODULE_GLOBAL(ip6_use_defzone));\n#else\n\t\t(void)in6_embedscope(&sin6->sin6_addr, sin6);\n#endif\n#ifndef SCOPEDROUTING\n\t\tsin6->sin6_scope_id = 0;\n#endif\n\t}\n#endif /* SCTP_EMBEDDED_V6_SCOPE */\n#endif\n\tSCTP_RTALLOC((sctp_route_t *)&net->ro,\n\t             stcb->asoc.vrf_id,\n\t             stcb->sctp_ep->fibnum);\n\n\tnet->src_addr_selected = 0;\n#if !defined(__Userspace__)\n\tif (SCTP_ROUTE_HAS_VALID_IFN(&net->ro)) {\n\t\t/* Get source address */\n\t\tnet->ro._s_addr = sctp_source_address_selection(stcb->sctp_ep,\n\t\t                                                stcb,\n\t\t                                                (sctp_route_t *)&net->ro,\n\t\t                                                net,\n\t\t                                                0,\n\t\t                                                stcb->asoc.vrf_id);\n\t\tif (stcb->asoc.default_mtu > 0) {\n\t\t\tnet->mtu = stcb->asoc.default_mtu;\n\t\t\tswitch (net->ro._l_addr.sa.sa_family) {\n#ifdef INET\n\t\t\tcase AF_INET:\n\t\t\t\tnet->mtu += SCTP_MIN_V4_OVERHEAD;\n\t\t\t\tbreak;\n#endif\n#ifdef INET6\n\t\t\tcase AF_INET6:\n\t\t\t\tnet->mtu += SCTP_MIN_OVERHEAD;\n\t\t\t\tbreak;\n#endif\n#if defined(__Userspace__)\n\t\t\tcase AF_CONN:\n\t\t\t\tnet->mtu += sizeof(struct sctphdr);\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n#if defined(INET) || defined(INET6)\n\t\t\tif (net->port) {\n\t\t\t\tnet->mtu += (uint32_t)sizeof(struct udphdr);\n\t\t\t}\n#endif\n\t\t} else if (net->ro._s_addr != NULL) {\n\t\t\tuint32_t imtu, rmtu, hcmtu;\n\n\t\t\tnet->src_addr_selected = 1;\n\t\t\t/* Now get the interface MTU */\n\t\t\tif (net->ro._s_addr->ifn_p != NULL) {\n\t\t\t\timtu = SCTP_GATHER_MTU_FROM_INTFC(net->ro._s_addr->ifn_p);\n\t\t\t} else {\n\t\t\t\timtu = 0;\n\t\t\t}\n\t\t\trmtu = SCTP_GATHER_MTU_FROM_ROUTE(net->ro._s_addr, &net->ro._l_addr.sa, net->ro.ro_rt);\n#if defined(__FreeBSD__)\n\t\t\thcmtu = sctp_hc_get_mtu(&net->ro._l_addr, stcb->sctp_ep->fibnum);\n#else\n\t\t\thcmtu = 0;\n#endif\n\t\t\tnet->mtu = sctp_min_mtu(hcmtu, rmtu, imtu);\n\t\t\tif (rmtu == 0) {\n\t\t\t\t/* Start things off to match mtu of interface please. */\n\t\t\t\tSCTP_SET_MTU_OF_ROUTE(&net->ro._l_addr.sa,\n\t\t\t\t                      net->ro.ro_rt, net->mtu);\n\t\t\t}\n\t\t}\n\t}\n#endif\n\tif (net->mtu == 0) {\n\t\tif (stcb->asoc.default_mtu > 0) {\n\t\t\tnet->mtu = stcb->asoc.default_mtu;\n\t\t\tswitch (net->ro._l_addr.sa.sa_family) {\n#ifdef INET\n\t\t\tcase AF_INET:\n\t\t\t\tnet->mtu += SCTP_MIN_V4_OVERHEAD;\n\t\t\t\tbreak;\n#endif\n#ifdef INET6\n\t\t\tcase AF_INET6:\n\t\t\t\tnet->mtu += SCTP_MIN_OVERHEAD;\n\t\t\t\tbreak;\n#endif\n#if defined(__Userspace__)\n\t\t\tcase AF_CONN:\n\t\t\t\tnet->mtu += sizeof(struct sctphdr);\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n#if defined(INET) || defined(INET6)\n\t\t\tif (net->port) {\n\t\t\t\tnet->mtu += (uint32_t)sizeof(struct udphdr);\n\t\t\t}\n#endif\n\t\t} else {\n\t\t\tswitch (newaddr->sa_family) {\n#ifdef INET\n\t\t\tcase AF_INET:\n\t\t\t\tnet->mtu = SCTP_DEFAULT_MTU;\n\t\t\t\tbreak;\n#endif\n#ifdef INET6\n\t\t\tcase AF_INET6:\n\t\t\t\tnet->mtu = 1280;\n\t\t\t\tbreak;\n#endif\n#if defined(__Userspace__)\n\t\t\tcase AF_CONN:\n\t\t\t\tnet->mtu = 1280;\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n#if defined(INET) || defined(INET6)\n\tif (net->port) {\n\t\tnet->mtu -= (uint32_t)sizeof(struct udphdr);\n\t}\n#endif\n\tif (from == SCTP_ALLOC_ASOC) {\n\t\tstcb->asoc.smallest_mtu = net->mtu;\n\t}\n\tif (stcb->asoc.smallest_mtu > net->mtu) {\n\t\tsctp_pathmtu_adjustment(stcb, net->mtu);\n\t}\n#ifdef INET6\n#ifdef SCTP_EMBEDDED_V6_SCOPE\n\tif (newaddr->sa_family == AF_INET6) {\n\t\tstruct sockaddr_in6 *sin6;\n\n\t\tsin6 = (struct sockaddr_in6 *)&net->ro._l_addr;\n#ifdef SCTP_KAME\n\t\t(void)sa6_recoverscope(sin6);\n#else\n\t\t(void)in6_recoverscope(sin6, &sin6->sin6_addr, NULL);\n#endif /* SCTP_KAME */\n\t}\n#endif /* SCTP_EMBEDDED_V6_SCOPE */\n#endif\n\n\t/* JRS - Use the congestion control given in the CC module */\n\tif (stcb->asoc.cc_functions.sctp_set_initial_cc_param != NULL)\n\t\t(*stcb->asoc.cc_functions.sctp_set_initial_cc_param)(stcb, net);\n\n\t/*\n\t * CMT: CUC algo - set find_pseudo_cumack to TRUE (1) at beginning\n\t * of assoc (2005/06/27, iyengar@cis.udel.edu)\n\t */\n\tnet->find_pseudo_cumack = 1;\n\tnet->find_rtx_pseudo_cumack = 1;\n#if defined(__FreeBSD__)\n\t/* Choose an initial flowid. */\n\tnet->flowid = stcb->asoc.my_vtag ^\n\t              ntohs(stcb->rport) ^\n\t              ntohs(stcb->sctp_ep->sctp_lport);\n\tnet->flowtype = M_HASHTYPE_OPAQUE_HASH;\n#endif\n\tif (netp) {\n\t\t*netp = net;\n\t}\n\tnetfirst = TAILQ_FIRST(&stcb->asoc.nets);\n\tif (net->ro.ro_rt == NULL) {\n\t\t/* Since we have no route put it at the back */\n\t\tTAILQ_INSERT_TAIL(&stcb->asoc.nets, net, sctp_next);\n\t} else if (netfirst == NULL) {\n\t\t/* We are the first one in the pool. */\n\t\tTAILQ_INSERT_HEAD(&stcb->asoc.nets, net, sctp_next);\n\t} else if (netfirst->ro.ro_rt == NULL) {\n\t\t/*\n\t\t * First one has NO route. Place this one ahead of the first\n\t\t * one.\n\t\t */\n\t\tTAILQ_INSERT_HEAD(&stcb->asoc.nets, net, sctp_next);\n#ifndef __Panda__\n\t} else if (net->ro.ro_rt->rt_ifp != netfirst->ro.ro_rt->rt_ifp) {\n\t\t/*\n\t\t * This one has a different interface than the one at the\n\t\t * top of the list. Place it ahead.\n\t\t */\n\t\tTAILQ_INSERT_HEAD(&stcb->asoc.nets, net, sctp_next);\n#endif\n\t} else {\n\t\t/*\n\t\t * Ok we have the same interface as the first one. Move\n\t\t * forward until we find either a) one with a NULL route...\n\t\t * insert ahead of that b) one with a different ifp.. insert\n\t\t * after that. c) end of the list.. insert at the tail.\n\t\t */\n\t\tstruct sctp_nets *netlook;\n\n\t\tdo {\n\t\t\tnetlook = TAILQ_NEXT(netfirst, sctp_next);\n\t\t\tif (netlook == NULL) {\n\t\t\t\t/* End of the list */\n\t\t\t\tTAILQ_INSERT_TAIL(&stcb->asoc.nets, net, sctp_next);\n\t\t\t\tbreak;\n\t\t\t} else if (netlook->ro.ro_rt == NULL) {\n\t\t\t\t/* next one has NO route */\n\t\t\t\tTAILQ_INSERT_BEFORE(netfirst, net, sctp_next);\n\t\t\t\tbreak;\n\t\t\t}\n#ifndef __Panda__\n\t\t\telse if (netlook->ro.ro_rt->rt_ifp != net->ro.ro_rt->rt_ifp)\n#else\n\t\t\telse\n#endif\n\t\t\t{\n\t\t\t\tTAILQ_INSERT_AFTER(&stcb->asoc.nets, netlook,\n\t\t\t\t\t\t   net, sctp_next);\n\t\t\t\tbreak;\n\t\t\t}\n#ifndef __Panda__\n\t\t\t/* Shift forward */\n\t\t\tnetfirst = netlook;\n#endif\n\t\t} while (netlook != NULL);\n\t}\n\n\t/* got to have a primary set */\n\tif (stcb->asoc.primary_destination == 0) {\n\t\tstcb->asoc.primary_destination = net;\n\t} else if ((stcb->asoc.primary_destination->ro.ro_rt == NULL) &&\n\t\t    (net->ro.ro_rt) &&\n\t    ((net->dest_state & SCTP_ADDR_UNCONFIRMED) == 0)) {\n\t\t/* No route to current primary adopt new primary */\n\t\tstcb->asoc.primary_destination = net;\n\t}\n\t/* Validate primary is first */\n\tnet = TAILQ_FIRST(&stcb->asoc.nets);\n\tif ((net != stcb->asoc.primary_destination) &&\n\t    (stcb->asoc.primary_destination)) {\n\t\t/* first one on the list is NOT the primary\n\t\t * sctp_cmpaddr() is much more efficient if\n\t\t * the primary is the first on the list, make it\n\t\t * so.\n\t\t */\n\t\tTAILQ_REMOVE(&stcb->asoc.nets,\n\t\t\t     stcb->asoc.primary_destination, sctp_next);\n\t\tTAILQ_INSERT_HEAD(&stcb->asoc.nets,\n\t\t\t\t  stcb->asoc.primary_destination, sctp_next);\n\t}\n\treturn (0);\n}\n\n\nstatic uint32_t\nsctp_aloc_a_assoc_id(struct sctp_inpcb *inp, struct sctp_tcb *stcb)\n{\n\tuint32_t id;\n\tstruct sctpasochead *head;\n\tstruct sctp_tcb *lstcb;\n\n try_again:\n\tif (inp->sctp_flags & SCTP_PCB_FLAGS_SOCKET_ALLGONE) {\n\t\t/* TSNH */\n\t\treturn (0);\n\t}\n\t/*\n\t * We don't allow assoc id to be one of SCTP_FUTURE_ASSOC,\n\t * SCTP_CURRENT_ASSOC and SCTP_ALL_ASSOC.\n\t */\n\tif (inp->sctp_associd_counter <= SCTP_ALL_ASSOC) {\n\t\tinp->sctp_associd_counter = SCTP_ALL_ASSOC + 1;\n\t}\n\tid = inp->sctp_associd_counter;\n\tinp->sctp_associd_counter++;\n\tlstcb = sctp_findasoc_ep_asocid_locked(inp, (sctp_assoc_t)id, 0);\n\tif (lstcb) {\n\t\tgoto try_again;\n\t}\n\thead = &inp->sctp_asocidhash[SCTP_PCBHASH_ASOC(id, inp->hashasocidmark)];\n\tLIST_INSERT_HEAD(head, stcb, sctp_tcbasocidhash);\n\tstcb->asoc.in_asocid_hash = 1;\n\treturn (id);\n}\n\n/*\n * allocate an association and add it to the endpoint. The caller must be\n * careful to add all additional addresses once they are know right away or\n * else the assoc will be may experience a blackout scenario.\n */\nstruct sctp_tcb *\nsctp_aloc_assoc(struct sctp_inpcb *inp, struct sockaddr *firstaddr,\n                int *error, uint32_t override_tag, uint32_t vrf_id,\n                uint16_t o_streams, uint16_t port,\n#if defined(__FreeBSD__) && __FreeBSD_version >= 500000\n                struct thread *p,\n#elif defined(__Windows__)\n                PKTHREAD p,\n#else\n#if defined(__Userspace__)\n                /*  __Userspace__ NULL proc is going to be passed here. See sctp_lower_sosend */\n#endif\n                struct proc *p,\n#endif\n                int initialize_auth_params)\n{\n\t/* note the p argument is only valid in unbound sockets */\n\n\tstruct sctp_tcb *stcb;\n\tstruct sctp_association *asoc;\n\tstruct sctpasochead *head;\n\tuint16_t rport;\n\tint err;\n\n\t/*\n\t * Assumption made here: Caller has done a\n\t * sctp_findassociation_ep_addr(ep, addr's); to make sure the\n\t * address does not exist already.\n\t */\n\tif (SCTP_BASE_INFO(ipi_count_asoc) >= SCTP_MAX_NUM_OF_ASOC) {\n\t\t/* Hit max assoc, sorry no more */\n\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, ENOBUFS);\n\t\t*error = ENOBUFS;\n\t\treturn (NULL);\n\t}\n\tif (firstaddr == NULL) {\n\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, EINVAL);\n\t\t*error = EINVAL;\n\t\treturn (NULL);\n\t}\n\tSCTP_INP_RLOCK(inp);\n\tif ((inp->sctp_flags & SCTP_PCB_FLAGS_IN_TCPPOOL) &&\n\t    ((sctp_is_feature_off(inp, SCTP_PCB_FLAGS_PORTREUSE)) ||\n\t     (inp->sctp_flags & SCTP_PCB_FLAGS_CONNECTED))) {\n\t\t/*\n\t\t * If its in the TCP pool, its NOT allowed to create an\n\t\t * association. The parent listener needs to call\n\t\t * sctp_aloc_assoc.. or the one-2-many socket. If a peeled\n\t\t * off, or connected one does this.. its an error.\n\t\t */\n\t\tSCTP_INP_RUNLOCK(inp);\n\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, EINVAL);\n\t\t*error = EINVAL;\n\t\treturn (NULL);\n\t}\n\tif ((inp->sctp_flags & SCTP_PCB_FLAGS_IN_TCPPOOL) ||\n\t    (inp->sctp_flags & SCTP_PCB_FLAGS_TCPTYPE)) {\n\t\tif ((inp->sctp_flags & SCTP_PCB_FLAGS_WAS_CONNECTED) ||\n\t\t    (inp->sctp_flags & SCTP_PCB_FLAGS_WAS_ABORTED)) {\n\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, EINVAL);\n\t\t\t*error = EINVAL;\n\t\t\treturn (NULL);\n\t\t}\n\t}\n\tSCTPDBG(SCTP_DEBUG_PCB3, \"Allocate an association for peer:\");\n#ifdef SCTP_DEBUG\n\tif (firstaddr) {\n\t\tSCTPDBG_ADDR(SCTP_DEBUG_PCB3, firstaddr);\n\t\tswitch (firstaddr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tSCTPDBG(SCTP_DEBUG_PCB3, \"Port:%d\\n\",\n\t\t\t        ntohs(((struct sockaddr_in *)firstaddr)->sin_port));\n\t\t\tbreak;\n#endif\n#ifdef INET6\n\t\tcase AF_INET6:\n\t\t\tSCTPDBG(SCTP_DEBUG_PCB3, \"Port:%d\\n\",\n\t\t\t        ntohs(((struct sockaddr_in6 *)firstaddr)->sin6_port));\n\t\t\tbreak;\n#endif\n#if defined(__Userspace__)\n\t\tcase AF_CONN:\n\t\t\tSCTPDBG(SCTP_DEBUG_PCB3, \"Port:%d\\n\",\n\t\t\t        ntohs(((struct sockaddr_conn *)firstaddr)->sconn_port));\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tSCTPDBG(SCTP_DEBUG_PCB3,\"None\\n\");\n\t}\n#endif\t\t\t\t/* SCTP_DEBUG */\n\tswitch (firstaddr->sa_family) {\n#ifdef INET\n\tcase AF_INET:\n\t{\n\t\tstruct sockaddr_in *sin;\n\n\t\tsin = (struct sockaddr_in *)firstaddr;\n\t\tif ((ntohs(sin->sin_port) == 0) ||\n\t\t    (sin->sin_addr.s_addr == INADDR_ANY) ||\n\t\t    (sin->sin_addr.s_addr == INADDR_BROADCAST) ||\n\t\t    IN_MULTICAST(ntohl(sin->sin_addr.s_addr))) {\n\t\t\t/* Invalid address */\n\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, EINVAL);\n\t\t\t*error = EINVAL;\n\t\t\treturn (NULL);\n\t\t}\n\t\trport = sin->sin_port;\n\t\tbreak;\n\t}\n#endif\n#ifdef INET6\n\tcase AF_INET6:\n\t{\n\t\tstruct sockaddr_in6 *sin6;\n\n\t\tsin6 = (struct sockaddr_in6 *)firstaddr;\n\t\tif ((ntohs(sin6->sin6_port) == 0) ||\n\t\t    IN6_IS_ADDR_UNSPECIFIED(&sin6->sin6_addr) ||\n\t\t    IN6_IS_ADDR_MULTICAST(&sin6->sin6_addr)) {\n\t\t\t/* Invalid address */\n\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, EINVAL);\n\t\t\t*error = EINVAL;\n\t\t\treturn (NULL);\n\t\t}\n\t\trport = sin6->sin6_port;\n\t\tbreak;\n\t}\n#endif\n#if defined(__Userspace__)\n\tcase AF_CONN:\n\t{\n\t\tstruct sockaddr_conn *sconn;\n\n\t\tsconn = (struct sockaddr_conn *)firstaddr;\n\t\tif ((ntohs(sconn->sconn_port) == 0) ||\n\t\t    (sconn->sconn_addr == NULL)) {\n\t\t\t/* Invalid address */\n\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, EINVAL);\n\t\t\t*error = EINVAL;\n\t\t\treturn (NULL);\n\t\t}\n\t\trport = sconn->sconn_port;\n\t\tbreak;\n\t}\n#endif\n\tdefault:\n\t\t/* not supported family type */\n\t\tSCTP_INP_RUNLOCK(inp);\n\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, EINVAL);\n\t\t*error = EINVAL;\n\t\treturn (NULL);\n\t}\n\tSCTP_INP_RUNLOCK(inp);\n\tif (inp->sctp_flags & SCTP_PCB_FLAGS_UNBOUND) {\n\t\t/*\n\t\t * If you have not performed a bind, then we need to do the\n\t\t * ephemeral bind for you.\n\t\t */\n\t\tif ((err = sctp_inpcb_bind(inp->sctp_socket,\n\t\t    (struct sockaddr *)NULL,\n\t\t    (struct sctp_ifa *)NULL,\n#ifndef __Panda__\n\t\t\t\t\t   p\n#else\n\t\t\t\t\t   (struct proc *)NULL\n#endif\n\t\t    ))) {\n\t\t\t/* bind error, probably perm */\n\t\t\t*error = err;\n\t\t\treturn (NULL);\n\t\t}\n\t}\n\tstcb = SCTP_ZONE_GET(SCTP_BASE_INFO(ipi_zone_asoc), struct sctp_tcb);\n\tif (stcb == NULL) {\n\t\t/* out of memory? */\n\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, ENOMEM);\n\t\t*error = ENOMEM;\n\t\treturn (NULL);\n\t}\n\tSCTP_INCR_ASOC_COUNT();\n\n\tmemset(stcb, 0, sizeof(*stcb));\n\tasoc = &stcb->asoc;\n\n\tSCTP_TCB_LOCK_INIT(stcb);\n\tSCTP_TCB_SEND_LOCK_INIT(stcb);\n\tstcb->rport = rport;\n\t/* setup back pointer's */\n\tstcb->sctp_ep = inp;\n\tstcb->sctp_socket = inp->sctp_socket;\n\tif ((err = sctp_init_asoc(inp, stcb, override_tag, vrf_id, o_streams))) {\n\t\t/* failed */\n\t\tSCTP_TCB_LOCK_DESTROY(stcb);\n\t\tSCTP_TCB_SEND_LOCK_DESTROY(stcb);\n\t\tSCTP_ZONE_FREE(SCTP_BASE_INFO(ipi_zone_asoc), stcb);\n\t\tSCTP_DECR_ASOC_COUNT();\n\t\t*error = err;\n\t\treturn (NULL);\n\t}\n\t/* and the port */\n\tSCTP_INP_INFO_WLOCK();\n\tSCTP_INP_WLOCK(inp);\n\tif (inp->sctp_flags & (SCTP_PCB_FLAGS_SOCKET_GONE | SCTP_PCB_FLAGS_SOCKET_ALLGONE)) {\n\t\t/* inpcb freed while alloc going on */\n\t\tSCTP_TCB_LOCK_DESTROY(stcb);\n\t\tSCTP_TCB_SEND_LOCK_DESTROY(stcb);\n\t\tSCTP_ZONE_FREE(SCTP_BASE_INFO(ipi_zone_asoc), stcb);\n\t\tSCTP_INP_WUNLOCK(inp);\n\t\tSCTP_INP_INFO_WUNLOCK();\n\t\tSCTP_DECR_ASOC_COUNT();\n\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, EINVAL);\n\t\t*error = EINVAL;\n\t\treturn (NULL);\n\t}\n\tSCTP_TCB_LOCK(stcb);\n\n\tasoc->assoc_id = sctp_aloc_a_assoc_id(inp, stcb);\n\t/* now that my_vtag is set, add it to the hash */\n\thead = &SCTP_BASE_INFO(sctp_asochash)[SCTP_PCBHASH_ASOC(stcb->asoc.my_vtag, SCTP_BASE_INFO(hashasocmark))];\n\t/* put it in the bucket in the vtag hash of assoc's for the system */\n\tLIST_INSERT_HEAD(head, stcb, sctp_asocs);\n\tSCTP_INP_INFO_WUNLOCK();\n\n\tif ((err = sctp_add_remote_addr(stcb, firstaddr, NULL, port, SCTP_DO_SETSCOPE, SCTP_ALLOC_ASOC))) {\n\t\t/* failure.. memory error? */\n\t\tif (asoc->strmout) {\n\t\t\tSCTP_FREE(asoc->strmout, SCTP_M_STRMO);\n\t\t\tasoc->strmout = NULL;\n\t\t}\n\t\tif (asoc->mapping_array) {\n\t\t\tSCTP_FREE(asoc->mapping_array, SCTP_M_MAP);\n\t\t\tasoc->mapping_array = NULL;\n\t\t}\n\t\tif (asoc->nr_mapping_array) {\n\t\t\tSCTP_FREE(asoc->nr_mapping_array, SCTP_M_MAP);\n\t\t\tasoc->nr_mapping_array = NULL;\n\t\t}\n\t\tSCTP_DECR_ASOC_COUNT();\n\t\tSCTP_TCB_UNLOCK(stcb);\n\t\tSCTP_TCB_LOCK_DESTROY(stcb);\n\t\tSCTP_TCB_SEND_LOCK_DESTROY(stcb);\n\t\tLIST_REMOVE(stcb, sctp_tcbasocidhash);\n\t\tSCTP_ZONE_FREE(SCTP_BASE_INFO(ipi_zone_asoc), stcb);\n\t\tSCTP_INP_WUNLOCK(inp);\n\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, ENOBUFS);\n\t\t*error = ENOBUFS;\n\t\treturn (NULL);\n\t}\n\t/* Init all the timers */\n\tSCTP_OS_TIMER_INIT(&asoc->dack_timer.timer);\n\tSCTP_OS_TIMER_INIT(&asoc->strreset_timer.timer);\n\tSCTP_OS_TIMER_INIT(&asoc->asconf_timer.timer);\n\tSCTP_OS_TIMER_INIT(&asoc->shut_guard_timer.timer);\n\tSCTP_OS_TIMER_INIT(&asoc->autoclose_timer.timer);\n\tSCTP_OS_TIMER_INIT(&asoc->delayed_event_timer.timer);\n\tSCTP_OS_TIMER_INIT(&asoc->delete_prim_timer.timer);\n\n\tLIST_INSERT_HEAD(&inp->sctp_asoc_list, stcb, sctp_tcblist);\n\t/* now file the port under the hash as well */\n\tif (inp->sctp_tcbhash != NULL) {\n\t\thead = &inp->sctp_tcbhash[SCTP_PCBHASH_ALLADDR(stcb->rport,\n\t\t    inp->sctp_hashmark)];\n\t\tLIST_INSERT_HEAD(head, stcb, sctp_tcbhash);\n\t}\n\tif (initialize_auth_params == SCTP_INITIALIZE_AUTH_PARAMS) {\n\t\tsctp_initialize_auth_params(inp, stcb);\n\t}\n\tSCTP_INP_WUNLOCK(inp);\n\tSCTPDBG(SCTP_DEBUG_PCB1, \"Association %p now allocated\\n\", (void *)stcb);\n\treturn (stcb);\n}\n\n\nvoid\nsctp_remove_net(struct sctp_tcb *stcb, struct sctp_nets *net)\n{\n\tstruct sctp_association *asoc;\n\n\tasoc = &stcb->asoc;\n\tasoc->numnets--;\n\tTAILQ_REMOVE(&asoc->nets, net, sctp_next);\n\tif (net == asoc->primary_destination) {\n\t\t/* Reset primary */\n\t\tstruct sctp_nets *lnet;\n\n\t\tlnet = TAILQ_FIRST(&asoc->nets);\n\t\t/* Mobility adaptation\n\t\t   Ideally, if deleted destination is the primary, it becomes\n\t\t   a fast retransmission trigger by the subsequent SET PRIMARY.\n\t\t   (by micchie)\n\t\t */\n\t\tif (sctp_is_mobility_feature_on(stcb->sctp_ep,\n\t\t                                SCTP_MOBILITY_BASE) ||\n\t\t    sctp_is_mobility_feature_on(stcb->sctp_ep,\n\t\t                                SCTP_MOBILITY_FASTHANDOFF)) {\n\t\t\tSCTPDBG(SCTP_DEBUG_ASCONF1, \"remove_net: primary dst is deleting\\n\");\n\t\t\tif (asoc->deleted_primary != NULL) {\n\t\t\t\tSCTPDBG(SCTP_DEBUG_ASCONF1, \"remove_net: deleted primary may be already stored\\n\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tasoc->deleted_primary = net;\n\t\t\tatomic_add_int(&net->ref_count, 1);\n\t\t\tmemset(&net->lastsa, 0, sizeof(net->lastsa));\n\t\t\tmemset(&net->lastsv, 0, sizeof(net->lastsv));\n\t\t\tsctp_mobility_feature_on(stcb->sctp_ep,\n\t\t\t\t\t\t SCTP_MOBILITY_PRIM_DELETED);\n\t\t\tsctp_timer_start(SCTP_TIMER_TYPE_PRIM_DELETED,\n\t\t\t\t\t stcb->sctp_ep, stcb, NULL);\n\t\t}\nout:\n\t\t/* Try to find a confirmed primary */\n\t\tasoc->primary_destination = sctp_find_alternate_net(stcb, lnet, 0);\n\t}\n\tif (net == asoc->last_data_chunk_from) {\n\t\t/* Reset primary */\n\t\tasoc->last_data_chunk_from = TAILQ_FIRST(&asoc->nets);\n\t}\n\tif (net == asoc->last_control_chunk_from) {\n\t\t/* Clear net */\n\t\tasoc->last_control_chunk_from = NULL;\n\t}\n\tif (net == stcb->asoc.alternate) {\n\t\tsctp_free_remote_addr(stcb->asoc.alternate);\n\t\tstcb->asoc.alternate = NULL;\n\t}\n\tsctp_free_remote_addr(net);\n}\n\n/*\n * remove a remote endpoint address from an association, it will fail if the\n * address does not exist.\n */\nint\nsctp_del_remote_addr(struct sctp_tcb *stcb, struct sockaddr *remaddr)\n{\n\t/*\n\t * Here we need to remove a remote address. This is quite simple, we\n\t * first find it in the list of address for the association\n\t * (tasoc->asoc.nets) and then if it is there, we do a LIST_REMOVE\n\t * on that item. Note we do not allow it to be removed if there are\n\t * no other addresses.\n\t */\n\tstruct sctp_association *asoc;\n\tstruct sctp_nets *net, *nnet;\n\n\tasoc = &stcb->asoc;\n\n\t/* locate the address */\n\tTAILQ_FOREACH_SAFE(net, &asoc->nets, sctp_next, nnet) {\n\t\tif (net->ro._l_addr.sa.sa_family != remaddr->sa_family) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (sctp_cmpaddr((struct sockaddr *)&net->ro._l_addr,\n\t\t    remaddr)) {\n\t\t\t/* we found the guy */\n\t\t\tif (asoc->numnets < 2) {\n\t\t\t\t/* Must have at LEAST two remote addresses */\n\t\t\t\treturn (-1);\n\t\t\t} else {\n\t\t\t\tsctp_remove_net(stcb, net);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t}\n\t}\n\t/* not found. */\n\treturn (-2);\n}\n\nvoid\nsctp_delete_from_timewait(uint32_t tag, uint16_t lport, uint16_t rport)\n{\n\tstruct sctpvtaghead *chain;\n\tstruct sctp_tagblock *twait_block;\n\tint found = 0;\n\tint i;\n\n\tchain = &SCTP_BASE_INFO(vtag_timewait)[(tag % SCTP_STACK_VTAG_HASH_SIZE)];\n\tLIST_FOREACH(twait_block, chain, sctp_nxt_tagblock) {\n\t\tfor (i = 0; i < SCTP_NUMBER_IN_VTAG_BLOCK; i++) {\n\t\t  if ((twait_block->vtag_block[i].v_tag == tag) &&\n\t\t      (twait_block->vtag_block[i].lport == lport) &&\n\t\t      (twait_block->vtag_block[i].rport == rport)) {\n\t\t\t\ttwait_block->vtag_block[i].tv_sec_at_expire = 0;\n\t\t\t\ttwait_block->vtag_block[i].v_tag = 0;\n\t\t\t\ttwait_block->vtag_block[i].lport = 0;\n\t\t\t\ttwait_block->vtag_block[i].rport = 0;\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (found)\n\t\t\tbreak;\n\t}\n}\n\nint\nsctp_is_in_timewait(uint32_t tag, uint16_t lport, uint16_t rport)\n{\n\tstruct sctpvtaghead *chain;\n\tstruct sctp_tagblock *twait_block;\n\tint found = 0;\n\tint i;\n\n\tSCTP_INP_INFO_WLOCK();\n\tchain = &SCTP_BASE_INFO(vtag_timewait)[(tag % SCTP_STACK_VTAG_HASH_SIZE)];\n\tLIST_FOREACH(twait_block, chain, sctp_nxt_tagblock) {\n\t\tfor (i = 0; i < SCTP_NUMBER_IN_VTAG_BLOCK; i++) {\n\t\t\tif ((twait_block->vtag_block[i].v_tag == tag)  &&\n\t\t\t    (twait_block->vtag_block[i].lport == lport)  &&\n\t\t\t    (twait_block->vtag_block[i].rport == rport)) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (found)\n\t\t\tbreak;\n\t}\n\tSCTP_INP_INFO_WUNLOCK();\n\treturn (found);\n}\n\n\nvoid\nsctp_add_vtag_to_timewait(uint32_t tag, uint32_t time, uint16_t lport, uint16_t rport)\n{\n\tstruct sctpvtaghead *chain;\n\tstruct sctp_tagblock *twait_block;\n\tstruct timeval now;\n\tint set, i;\n\n\tif (time == 0) {\n\t\t/* Its disabled */\n\t\treturn;\n\t}\n\t(void)SCTP_GETTIME_TIMEVAL(&now);\n\tchain = &SCTP_BASE_INFO(vtag_timewait)[(tag % SCTP_STACK_VTAG_HASH_SIZE)];\n\tset = 0;\n\tLIST_FOREACH(twait_block, chain, sctp_nxt_tagblock) {\n\t\t/* Block(s) present, lets find space, and expire on the fly */\n\t\tfor (i = 0; i < SCTP_NUMBER_IN_VTAG_BLOCK; i++) {\n\t\t\tif ((twait_block->vtag_block[i].v_tag == 0) &&\n\t\t\t    !set) {\n\t\t\t\ttwait_block->vtag_block[i].tv_sec_at_expire =\n\t\t\t\t\tnow.tv_sec + time;\n\t\t\t\ttwait_block->vtag_block[i].v_tag = tag;\n\t\t\t\ttwait_block->vtag_block[i].lport = lport;\n\t\t\t\ttwait_block->vtag_block[i].rport = rport;\n\t\t\t\tset = 1;\n\t\t\t} else if ((twait_block->vtag_block[i].v_tag) &&\n\t\t\t\t    ((long)twait_block->vtag_block[i].tv_sec_at_expire < now.tv_sec)) {\n\t\t\t\t/* Audit expires this guy */\n\t\t\t\ttwait_block->vtag_block[i].tv_sec_at_expire = 0;\n\t\t\t\ttwait_block->vtag_block[i].v_tag = 0;\n\t\t\t\ttwait_block->vtag_block[i].lport = 0;\n\t\t\t\ttwait_block->vtag_block[i].rport = 0;\n\t\t\t\tif (set == 0) {\n\t\t\t\t\t/* Reuse it for my new tag */\n\t\t\t\t\ttwait_block->vtag_block[i].tv_sec_at_expire = now.tv_sec + time;\n\t\t\t\t\ttwait_block->vtag_block[i].v_tag = tag;\n\t\t\t\t\ttwait_block->vtag_block[i].lport = lport;\n\t\t\t\t\ttwait_block->vtag_block[i].rport = rport;\n\t\t\t\t\tset = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (set) {\n\t\t\t/*\n\t\t\t * We only do up to the block where we can\n\t\t\t * place our tag for audits\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t}\n\t/* Need to add a new block to chain */\n\tif (!set) {\n\t\tSCTP_MALLOC(twait_block, struct sctp_tagblock *,\n\t\t    sizeof(struct sctp_tagblock), SCTP_M_TIMW);\n\t\tif (twait_block == NULL) {\n#ifdef INVARIANTS\n\t\t\tpanic(\"Can not alloc tagblock\");\n#endif\n\t\t\treturn;\n\t\t}\n\t\tmemset(twait_block, 0, sizeof(struct sctp_tagblock));\n\t\tLIST_INSERT_HEAD(chain, twait_block, sctp_nxt_tagblock);\n\t\ttwait_block->vtag_block[0].tv_sec_at_expire = now.tv_sec + time;\n\t\ttwait_block->vtag_block[0].v_tag = tag;\n\t\ttwait_block->vtag_block[0].lport = lport;\n\t\ttwait_block->vtag_block[0].rport = rport;\n\t}\n}\n\nvoid\nsctp_clean_up_stream(struct sctp_tcb *stcb, struct sctp_readhead *rh)\n{\n\tstruct sctp_tmit_chunk *chk, *nchk;\n\tstruct sctp_queued_to_read *control, *ncontrol;\n\n\tTAILQ_FOREACH_SAFE(control, rh, next_instrm, ncontrol) {\n\t\tTAILQ_REMOVE(rh, control, next_instrm);\n\t\tcontrol->on_strm_q = 0;\n\t\tif (control->on_read_q == 0) {\n\t\t\tsctp_free_remote_addr(control->whoFrom);\n\t\t\tif (control->data) {\n\t\t\t\tsctp_m_freem(control->data);\n\t\t\t\tcontrol->data = NULL;\n\t\t\t}\n\t\t}\n\t\t/* Reassembly free? */\n\t\tTAILQ_FOREACH_SAFE(chk, &control->reasm, sctp_next, nchk) {\n\t\t\tTAILQ_REMOVE(&control->reasm, chk, sctp_next);\n\t\t\tif (chk->data) {\n\t\t\t\tsctp_m_freem(chk->data);\n\t\t\t\tchk->data = NULL;\n\t\t\t}\n\t\t\tif (chk->holds_key_ref)\n\t\t\t\tsctp_auth_key_release(stcb, chk->auth_keyid, SCTP_SO_LOCKED);\n\t\t\tsctp_free_remote_addr(chk->whoTo);\n\t\t\tSCTP_ZONE_FREE(SCTP_BASE_INFO(ipi_zone_chunk), chk);\n\t\t\tSCTP_DECR_CHK_COUNT();\n\t\t\t/*sa_ignore FREED_MEMORY*/\n\t\t}\n\t\t/*\n\t\t * We don't free the address here\n\t\t * since all the net's were freed\n\t\t * above.\n\t\t */\n\t\tif (control->on_read_q == 0) {\n\t\t\tsctp_free_a_readq(stcb, control);\n\t\t}\n\t}\n}\n\n#ifdef __Panda__\nvoid panda_wakeup_socket(struct socket *so);\n#endif\n\n/*-\n * Free the association after un-hashing the remote port. This\n * function ALWAYS returns holding NO LOCK on the stcb. It DOES\n * expect that the input to this function IS a locked TCB.\n * It will return 0, if it did NOT destroy the association (instead\n * it unlocks it. It will return NON-zero if it either destroyed the\n * association OR the association is already destroyed.\n */\nint\nsctp_free_assoc(struct sctp_inpcb *inp, struct sctp_tcb *stcb, int from_inpcbfree, int from_location)\n{\n\tint i;\n\tstruct sctp_association *asoc;\n\tstruct sctp_nets *net, *nnet;\n\tstruct sctp_laddr *laddr, *naddr;\n\tstruct sctp_tmit_chunk *chk, *nchk;\n\tstruct sctp_asconf_addr *aparam, *naparam;\n\tstruct sctp_asconf_ack *aack, *naack;\n\tstruct sctp_stream_reset_list *strrst, *nstrrst;\n\tstruct sctp_queued_to_read *sq, *nsq;\n\tstruct sctp_stream_queue_pending *sp, *nsp;\n\tsctp_sharedkey_t *shared_key, *nshared_key;\n\tstruct socket *so;\n\n\t/* first, lets purge the entry from the hash table. */\n#if defined(__APPLE__)\n\tsctp_lock_assert(SCTP_INP_SO(inp));\n#endif\n\n#ifdef SCTP_LOG_CLOSING\n\tsctp_log_closing(inp, stcb, 6);\n#endif\n\tif (stcb->asoc.state == 0) {\n#ifdef SCTP_LOG_CLOSING\n\t\tsctp_log_closing(inp, NULL, 7);\n#endif\n\t\t/* there is no asoc, really TSNH :-0 */\n\t\treturn (1);\n\t}\n\tif (stcb->asoc.alternate) {\n\t\tsctp_free_remote_addr(stcb->asoc.alternate);\n\t\tstcb->asoc.alternate = NULL;\n\t}\n#if !defined(__APPLE__) /* TEMP: moved to below */\n        /* TEMP CODE */\n\tif (stcb->freed_from_where == 0) {\n\t\t/* Only record the first place free happened from */\n\t\tstcb->freed_from_where = from_location;\n\t}\n        /* TEMP CODE */\n#endif\n\n\tasoc = &stcb->asoc;\n\tif ((inp->sctp_flags & SCTP_PCB_FLAGS_SOCKET_ALLGONE) ||\n\t    (inp->sctp_flags & SCTP_PCB_FLAGS_SOCKET_GONE))\n\t\t/* nothing around */\n\t\tso = NULL;\n\telse\n\t\tso = inp->sctp_socket;\n\n\t/*\n\t * We used timer based freeing if a reader or writer is in the way.\n\t * So we first check if we are actually being called from a timer,\n\t * if so we abort early if a reader or writer is still in the way.\n\t */\n\tif ((stcb->asoc.state & SCTP_STATE_ABOUT_TO_BE_FREED) &&\n\t    (from_inpcbfree == SCTP_NORMAL_PROC)) {\n\t\t/*\n\t\t * is it the timer driving us? if so are the reader/writers\n\t\t * gone?\n\t\t */\n\t\tif (stcb->asoc.refcnt) {\n\t\t\t/* nope, reader or writer in the way */\n\t\t\tsctp_timer_start(SCTP_TIMER_TYPE_ASOCKILL, inp, stcb, NULL);\n\t\t\t/* no asoc destroyed */\n\t\t\tSCTP_TCB_UNLOCK(stcb);\n#ifdef SCTP_LOG_CLOSING\n\t\t\tsctp_log_closing(inp, stcb, 8);\n#endif\n\t\t\treturn (0);\n\t\t}\n\t}\n\t/* now clean up any other timers */\n\t(void)SCTP_OS_TIMER_STOP(&asoc->dack_timer.timer);\n\tasoc->dack_timer.self = NULL;\n\t(void)SCTP_OS_TIMER_STOP(&asoc->strreset_timer.timer);\n\t/*-\n\t * For stream reset we don't blast this unless\n\t * it is a str-reset timer, it might be the\n\t * free-asoc timer which we DON'T want to\n\t * disturb.\n\t */\n\tif (asoc->strreset_timer.type == SCTP_TIMER_TYPE_STRRESET)\n\t\tasoc->strreset_timer.self = NULL;\n\t(void)SCTP_OS_TIMER_STOP(&asoc->asconf_timer.timer);\n\tasoc->asconf_timer.self = NULL;\n\t(void)SCTP_OS_TIMER_STOP(&asoc->autoclose_timer.timer);\n\tasoc->autoclose_timer.self = NULL;\n\t(void)SCTP_OS_TIMER_STOP(&asoc->shut_guard_timer.timer);\n\tasoc->shut_guard_timer.self = NULL;\n\t(void)SCTP_OS_TIMER_STOP(&asoc->delayed_event_timer.timer);\n\tasoc->delayed_event_timer.self = NULL;\n\t/* Mobility adaptation */\n\t(void)SCTP_OS_TIMER_STOP(&asoc->delete_prim_timer.timer);\n\tasoc->delete_prim_timer.self = NULL;\n\tTAILQ_FOREACH(net, &asoc->nets, sctp_next) {\n\t\t(void)SCTP_OS_TIMER_STOP(&net->rxt_timer.timer);\n\t\tnet->rxt_timer.self = NULL;\n\t\t(void)SCTP_OS_TIMER_STOP(&net->pmtu_timer.timer);\n\t\tnet->pmtu_timer.self = NULL;\n\t\t(void)SCTP_OS_TIMER_STOP(&net->hb_timer.timer);\n\t\tnet->hb_timer.self = NULL;\n\t}\n\t/* Now the read queue needs to be cleaned up (only once) */\n\tif ((stcb->asoc.state & SCTP_STATE_ABOUT_TO_BE_FREED) == 0) {\n\t\tSCTP_ADD_SUBSTATE(stcb, SCTP_STATE_ABOUT_TO_BE_FREED);\n\t\tSCTP_INP_READ_LOCK(inp);\n\t\tTAILQ_FOREACH(sq, &inp->read_queue, next) {\n\t\t\tif (sq->stcb == stcb) {\n\t\t\t\tsq->do_not_ref_stcb = 1;\n\t\t\t\tsq->sinfo_cumtsn = stcb->asoc.cumulative_tsn;\n\t\t\t\t/* If there is no end, there never\n\t\t\t\t * will be now.\n\t\t\t\t */\n\t\t\t\tif (sq->end_added == 0) {\n\t\t\t\t\t/* Held for PD-API clear that. */\n\t\t\t\t\tsq->pdapi_aborted = 1;\n\t\t\t\t\tsq->held_length = 0;\n\t\t\t\t\tif (sctp_stcb_is_feature_on(inp, stcb, SCTP_PCB_FLAGS_PDAPIEVNT) && (so != NULL)) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Need to add a PD-API aborted indication.\n\t\t\t\t\t\t * Setting the control_pdapi assures that it will\n\t\t\t\t\t\t * be added right after this msg.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tuint32_t strseq;\n\t\t\t\t\t\tstcb->asoc.control_pdapi = sq;\n\t\t\t\t\t\tstrseq = (sq->sinfo_stream << 16) | (sq->mid & 0x0000ffff);\n\t\t\t\t\t\tsctp_ulp_notify(SCTP_NOTIFY_PARTIAL_DELVIERY_INDICATION,\n\t\t\t\t\t\t                stcb,\n\t\t\t\t\t\t                SCTP_PARTIAL_DELIVERY_ABORTED,\n\t\t\t\t\t\t                (void *)&strseq,\n\t\t\t\t\t\t                SCTP_SO_LOCKED);\n\t\t\t\t\t\tstcb->asoc.control_pdapi = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* Add an end to wake them */\n\t\t\t\tsq->end_added = 1;\n\t\t\t}\n\t\t}\n\t\tSCTP_INP_READ_UNLOCK(inp);\n\t\tif (stcb->block_entry) {\n\t\t\tSCTP_LTRACE_ERR_RET(inp, stcb, NULL, SCTP_FROM_SCTP_PCB, ECONNRESET);\n\t\t\tstcb->block_entry->error = ECONNRESET;\n\t\t\tstcb->block_entry = NULL;\n\t\t}\n\t}\n\tif ((stcb->asoc.refcnt) || (stcb->asoc.state & SCTP_STATE_IN_ACCEPT_QUEUE)) {\n\t\t/* Someone holds a reference OR the socket is unaccepted yet.\n\t\t*/\n\t\tif ((stcb->asoc.refcnt)  ||\n\t\t    (inp->sctp_flags & SCTP_PCB_FLAGS_SOCKET_ALLGONE) ||\n\t\t    (inp->sctp_flags & SCTP_PCB_FLAGS_SOCKET_GONE)) {\n\t\t\tSCTP_CLEAR_SUBSTATE(stcb, SCTP_STATE_IN_ACCEPT_QUEUE);\n\t\t\tsctp_timer_start(SCTP_TIMER_TYPE_ASOCKILL, inp, stcb, NULL);\n\t\t}\n\t\tSCTP_TCB_UNLOCK(stcb);\n\t\tif ((inp->sctp_flags & SCTP_PCB_FLAGS_SOCKET_ALLGONE) ||\n\t\t    (inp->sctp_flags & SCTP_PCB_FLAGS_SOCKET_GONE))\n\t\t\t/* nothing around */\n\t\t\tso = NULL;\n\t\tif (so) {\n\t\t\t/* Wake any reader/writers */\n\t\t\tsctp_sorwakeup(inp, so);\n\t\t\tsctp_sowwakeup(inp, so);\n\t\t}\n\n#ifdef SCTP_LOG_CLOSING\n\t\tsctp_log_closing(inp, stcb, 9);\n#endif\n\t\t/* no asoc destroyed */\n\t\treturn (0);\n\t}\n#ifdef SCTP_LOG_CLOSING\n\tsctp_log_closing(inp, stcb, 10);\n#endif\n\t/* When I reach here, no others want\n\t * to kill the assoc yet.. and I own\n\t * the lock. Now its possible an abort\n\t * comes in when I do the lock exchange\n\t * below to grab all the locks to do\n\t * the final take out. to prevent this\n\t * we increment the count, which will\n\t * start a timer and blow out above thus\n\t * assuring us that we hold exclusive\n\t * killing of the asoc. Note that\n\t * after getting back the TCB lock\n\t * we will go ahead and increment the\n\t * counter back up and stop any timer\n\t * a passing stranger may have started :-S\n\t */\n\tif (from_inpcbfree == SCTP_NORMAL_PROC) {\n\t\tatomic_add_int(&stcb->asoc.refcnt, 1);\n\n\t\tSCTP_TCB_UNLOCK(stcb);\n\t\tSCTP_INP_INFO_WLOCK();\n\t\tSCTP_INP_WLOCK(inp);\n\t\tSCTP_TCB_LOCK(stcb);\n\t}\n\t/* Double check the GONE flag */\n\tif ((inp->sctp_flags & SCTP_PCB_FLAGS_SOCKET_ALLGONE) ||\n\t    (inp->sctp_flags & SCTP_PCB_FLAGS_SOCKET_GONE))\n\t\t/* nothing around */\n\t\tso = NULL;\n\n\tif ((inp->sctp_flags & SCTP_PCB_FLAGS_TCPTYPE) ||\n\t    (inp->sctp_flags & SCTP_PCB_FLAGS_IN_TCPPOOL)) {\n\t\t/*\n\t\t * For TCP type we need special handling when we are\n\t\t * connected. We also include the peel'ed off ones to.\n\t\t */\n\t\tif (inp->sctp_flags & SCTP_PCB_FLAGS_CONNECTED) {\n\t\t\tinp->sctp_flags &= ~SCTP_PCB_FLAGS_CONNECTED;\n\t\t\tinp->sctp_flags |= SCTP_PCB_FLAGS_WAS_CONNECTED;\n\t\t\tif (so) {\n\t\t\t\tSOCKBUF_LOCK(&so->so_rcv);\n\t\t\t\tso->so_state &= ~(SS_ISCONNECTING |\n\t\t\t\t    SS_ISDISCONNECTING |\n\t\t\t\t    SS_ISCONFIRMING |\n\t\t\t\t    SS_ISCONNECTED);\n\t\t\t\tso->so_state |= SS_ISDISCONNECTED;\n#if defined(__APPLE__)\n\t\t\t\tsocantrcvmore(so);\n#else\n\t\t\t\tsocantrcvmore_locked(so);\n#endif\n\t\t\t\tsocantsendmore(so);\n\t\t\t\tsctp_sowwakeup(inp, so);\n\t\t\t\tsctp_sorwakeup(inp, so);\n\t\t\t\tSCTP_SOWAKEUP(so);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Make it invalid too, that way if its\n\t * about to run it will abort and return.\n\t */\n\t/* re-increment the lock */\n\tif (from_inpcbfree == SCTP_NORMAL_PROC) {\n\t\tatomic_add_int(&stcb->asoc.refcnt, -1);\n\t}\n\tif (stcb->asoc.refcnt) {\n\t\tSCTP_CLEAR_SUBSTATE(stcb, SCTP_STATE_IN_ACCEPT_QUEUE);\n\t\tsctp_timer_start(SCTP_TIMER_TYPE_ASOCKILL, inp, stcb, NULL);\n\t\tif (from_inpcbfree == SCTP_NORMAL_PROC) {\n\t\t\tSCTP_INP_INFO_WUNLOCK();\n\t\t\tSCTP_INP_WUNLOCK(inp);\n\t\t}\n\t\tSCTP_TCB_UNLOCK(stcb);\n\t\treturn (0);\n\t}\n\tasoc->state = 0;\n\tif (inp->sctp_tcbhash) {\n\t\tLIST_REMOVE(stcb, sctp_tcbhash);\n\t}\n\tif (stcb->asoc.in_asocid_hash) {\n\t\tLIST_REMOVE(stcb, sctp_tcbasocidhash);\n\t}\n\t/* Now lets remove it from the list of ALL associations in the EP */\n\tLIST_REMOVE(stcb, sctp_tcblist);\n\tif (from_inpcbfree == SCTP_NORMAL_PROC) {\n\t\tSCTP_INP_INCR_REF(inp);\n\t\tSCTP_INP_WUNLOCK(inp);\n\t}\n\t/* pull from vtag hash */\n\tLIST_REMOVE(stcb, sctp_asocs);\n\tsctp_add_vtag_to_timewait(asoc->my_vtag, SCTP_BASE_SYSCTL(sctp_vtag_time_wait),\n\t\t\t\t  inp->sctp_lport, stcb->rport);\n\n\t/* Now restop the timers to be sure\n\t * this is paranoia at is finest!\n\t */\n\t(void)SCTP_OS_TIMER_STOP(&asoc->strreset_timer.timer);\n\t(void)SCTP_OS_TIMER_STOP(&asoc->dack_timer.timer);\n\t(void)SCTP_OS_TIMER_STOP(&asoc->strreset_timer.timer);\n\t(void)SCTP_OS_TIMER_STOP(&asoc->asconf_timer.timer);\n\t(void)SCTP_OS_TIMER_STOP(&asoc->shut_guard_timer.timer);\n\t(void)SCTP_OS_TIMER_STOP(&asoc->autoclose_timer.timer);\n\t(void)SCTP_OS_TIMER_STOP(&asoc->delayed_event_timer.timer);\n\tTAILQ_FOREACH(net, &asoc->nets, sctp_next) {\n\t\t(void)SCTP_OS_TIMER_STOP(&net->rxt_timer.timer);\n\t\t(void)SCTP_OS_TIMER_STOP(&net->pmtu_timer.timer);\n\t\t(void)SCTP_OS_TIMER_STOP(&net->hb_timer.timer);\n\t}\n\n\tasoc->strreset_timer.type = SCTP_TIMER_TYPE_NONE;\n\t/*\n\t * The chunk lists and such SHOULD be empty but we check them just\n\t * in case.\n\t */\n\t/* anything on the wheel needs to be removed */\n\tSCTP_TCB_SEND_LOCK(stcb);\n\tfor (i = 0; i < asoc->streamoutcnt; i++) {\n\t\tstruct sctp_stream_out *outs;\n\n\t\touts = &asoc->strmout[i];\n\t\t/* now clean up any chunks here */\n\t\tTAILQ_FOREACH_SAFE(sp, &outs->outqueue, next, nsp) {\n\t\t\tatomic_subtract_int(&asoc->stream_queue_cnt, 1);\n\t\t\tTAILQ_REMOVE(&outs->outqueue, sp, next);\n\t\t\tstcb->asoc.ss_functions.sctp_ss_remove_from_stream(stcb, asoc, outs, sp, 1);\n\t\t\tsctp_free_spbufspace(stcb, asoc, sp);\n\t\t\tif (sp->data) {\n\t\t\t\tif (so) {\n\t\t\t\t\t/* Still an open socket - report */\n\t\t\t\t\tsctp_ulp_notify(SCTP_NOTIFY_SPECIAL_SP_FAIL, stcb,\n\t\t\t\t\t                0, (void *)sp, SCTP_SO_LOCKED);\n\t\t\t\t}\n\t\t\t\tif (sp->data) {\n\t\t\t\t\tsctp_m_freem(sp->data);\n\t\t\t\t\tsp->data = NULL;\n\t\t\t\t\tsp->tail_mbuf = NULL;\n\t\t\t\t\tsp->length = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sp->net) {\n\t\t\t\tsctp_free_remote_addr(sp->net);\n\t\t\t\tsp->net = NULL;\n\t\t\t}\n\t\t\tsctp_free_a_strmoq(stcb, sp, SCTP_SO_LOCKED);\n\t\t}\n\t}\n\tSCTP_TCB_SEND_UNLOCK(stcb);\n\t/*sa_ignore FREED_MEMORY*/\n\tTAILQ_FOREACH_SAFE(strrst, &asoc->resetHead, next_resp, nstrrst) {\n\t\tTAILQ_REMOVE(&asoc->resetHead, strrst, next_resp);\n\t\tSCTP_FREE(strrst, SCTP_M_STRESET);\n\t}\n\tTAILQ_FOREACH_SAFE(sq, &asoc->pending_reply_queue, next, nsq) {\n\t\tTAILQ_REMOVE(&asoc->pending_reply_queue, sq, next);\n\t\tif (sq->data) {\n\t\t\tsctp_m_freem(sq->data);\n\t\t\tsq->data = NULL;\n\t\t}\n\t\tsctp_free_remote_addr(sq->whoFrom);\n\t\tsq->whoFrom = NULL;\n\t\tsq->stcb = NULL;\n\t\t/* Free the ctl entry */\n\t\tsctp_free_a_readq(stcb, sq);\n\t\t/*sa_ignore FREED_MEMORY*/\n\t}\n\tTAILQ_FOREACH_SAFE(chk, &asoc->free_chunks, sctp_next, nchk) {\n\t\tTAILQ_REMOVE(&asoc->free_chunks, chk, sctp_next);\n\t\tif (chk->data) {\n\t\t\tsctp_m_freem(chk->data);\n\t\t\tchk->data = NULL;\n\t\t}\n\t\tif (chk->holds_key_ref)\n\t\t\tsctp_auth_key_release(stcb, chk->auth_keyid, SCTP_SO_LOCKED);\n\t\tSCTP_ZONE_FREE(SCTP_BASE_INFO(ipi_zone_chunk), chk);\n\t\tSCTP_DECR_CHK_COUNT();\n\t\tatomic_subtract_int(&SCTP_BASE_INFO(ipi_free_chunks), 1);\n\t\tasoc->free_chunk_cnt--;\n\t\t/*sa_ignore FREED_MEMORY*/\n\t}\n\t/* pending send queue SHOULD be empty */\n\tTAILQ_FOREACH_SAFE(chk, &asoc->send_queue, sctp_next, nchk) {\n\t\tif (asoc->strmout[chk->rec.data.sid].chunks_on_queues > 0) {\n\t\t\tasoc->strmout[chk->rec.data.sid].chunks_on_queues--;\n#ifdef INVARIANTS\n\t\t} else {\n\t\t\tpanic(\"No chunks on the queues for sid %u.\", chk->rec.data.sid);\n#endif\n\t\t}\n\t\tTAILQ_REMOVE(&asoc->send_queue, chk, sctp_next);\n\t\tif (chk->data) {\n\t\t\tif (so) {\n\t\t\t\t/* Still a socket? */\n\t\t\t\tsctp_ulp_notify(SCTP_NOTIFY_UNSENT_DG_FAIL, stcb,\n\t\t\t\t                0, chk, SCTP_SO_LOCKED);\n\t\t\t}\n\t\t\tif (chk->data) {\n\t\t\t\tsctp_m_freem(chk->data);\n\t\t\t\tchk->data = NULL;\n\t\t\t}\n\t\t}\n\t\tif (chk->holds_key_ref)\n\t\t\tsctp_auth_key_release(stcb, chk->auth_keyid, SCTP_SO_LOCKED);\n\t\tif (chk->whoTo) {\n\t\t\tsctp_free_remote_addr(chk->whoTo);\n\t\t\tchk->whoTo = NULL;\n\t\t}\n\t\tSCTP_ZONE_FREE(SCTP_BASE_INFO(ipi_zone_chunk), chk);\n\t\tSCTP_DECR_CHK_COUNT();\n\t\t/*sa_ignore FREED_MEMORY*/\n\t}\n\t/* sent queue SHOULD be empty */\n\tTAILQ_FOREACH_SAFE(chk, &asoc->sent_queue, sctp_next, nchk) {\n\t\tif (chk->sent != SCTP_DATAGRAM_NR_ACKED) {\n\t\t\tif (asoc->strmout[chk->rec.data.sid].chunks_on_queues > 0) {\n\t\t\t\tasoc->strmout[chk->rec.data.sid].chunks_on_queues--;\n#ifdef INVARIANTS\n\t\t\t} else {\n\t\t\t\tpanic(\"No chunks on the queues for sid %u.\", chk->rec.data.sid);\n#endif\n\t\t\t}\n\t\t}\n\t\tTAILQ_REMOVE(&asoc->sent_queue, chk, sctp_next);\n\t\tif (chk->data) {\n\t\t\tif (so) {\n\t\t\t\t/* Still a socket? */\n\t\t\t\tsctp_ulp_notify(SCTP_NOTIFY_SENT_DG_FAIL, stcb,\n\t\t\t\t                0, chk, SCTP_SO_LOCKED);\n\t\t\t}\n\t\t\tif (chk->data) {\n\t\t\t\tsctp_m_freem(chk->data);\n\t\t\t\tchk->data = NULL;\n\t\t\t}\n\t\t}\n\t\tif (chk->holds_key_ref)\n\t\t\tsctp_auth_key_release(stcb, chk->auth_keyid, SCTP_SO_LOCKED);\n\t\tsctp_free_remote_addr(chk->whoTo);\n\t\tSCTP_ZONE_FREE(SCTP_BASE_INFO(ipi_zone_chunk), chk);\n\t\tSCTP_DECR_CHK_COUNT();\n\t\t/*sa_ignore FREED_MEMORY*/\n\t}\n#ifdef INVARIANTS\n\tfor (i = 0; i < stcb->asoc.streamoutcnt; i++) {\n\t\tif (stcb->asoc.strmout[i].chunks_on_queues > 0) {\n\t\t\tpanic(\"%u chunks left for stream %u.\", stcb->asoc.strmout[i].chunks_on_queues, i);\n\t\t}\n\t}\n#endif\n\t/* control queue MAY not be empty */\n\tTAILQ_FOREACH_SAFE(chk, &asoc->control_send_queue, sctp_next, nchk) {\n\t\tTAILQ_REMOVE(&asoc->control_send_queue, chk, sctp_next);\n\t\tif (chk->data) {\n\t\t\tsctp_m_freem(chk->data);\n\t\t\tchk->data = NULL;\n\t\t}\n\t\tif (chk->holds_key_ref)\n\t\t\tsctp_auth_key_release(stcb, chk->auth_keyid, SCTP_SO_LOCKED);\n\t\tsctp_free_remote_addr(chk->whoTo);\n\t\tSCTP_ZONE_FREE(SCTP_BASE_INFO(ipi_zone_chunk), chk);\n\t\tSCTP_DECR_CHK_COUNT();\n\t\t/*sa_ignore FREED_MEMORY*/\n\t}\n\t/* ASCONF queue MAY not be empty */\n\tTAILQ_FOREACH_SAFE(chk, &asoc->asconf_send_queue, sctp_next, nchk) {\n\t\tTAILQ_REMOVE(&asoc->asconf_send_queue, chk, sctp_next);\n\t\tif (chk->data) {\n\t\t\tsctp_m_freem(chk->data);\n\t\t\tchk->data = NULL;\n\t\t}\n\t\tif (chk->holds_key_ref)\n\t\t\tsctp_auth_key_release(stcb, chk->auth_keyid, SCTP_SO_LOCKED);\n\t\tsctp_free_remote_addr(chk->whoTo);\n\t\tSCTP_ZONE_FREE(SCTP_BASE_INFO(ipi_zone_chunk), chk);\n\t\tSCTP_DECR_CHK_COUNT();\n\t\t/*sa_ignore FREED_MEMORY*/\n\t}\n\tif (asoc->mapping_array) {\n\t\tSCTP_FREE(asoc->mapping_array, SCTP_M_MAP);\n\t\tasoc->mapping_array = NULL;\n\t}\n\tif (asoc->nr_mapping_array) {\n\t\tSCTP_FREE(asoc->nr_mapping_array, SCTP_M_MAP);\n\t\tasoc->nr_mapping_array = NULL;\n\t}\n\t/* the stream outs */\n\tif (asoc->strmout) {\n\t\tSCTP_FREE(asoc->strmout, SCTP_M_STRMO);\n\t\tasoc->strmout = NULL;\n\t}\n\tasoc->strm_realoutsize = asoc->streamoutcnt = 0;\n\tif (asoc->strmin) {\n\t\tfor (i = 0; i < asoc->streamincnt; i++) {\n\t\t\tsctp_clean_up_stream(stcb, &asoc->strmin[i].inqueue);\n\t\t\tsctp_clean_up_stream(stcb, &asoc->strmin[i].uno_inqueue);\n\t\t}\n\t\tSCTP_FREE(asoc->strmin, SCTP_M_STRMI);\n\t\tasoc->strmin = NULL;\n\t}\n\tasoc->streamincnt = 0;\n\tTAILQ_FOREACH_SAFE(net, &asoc->nets, sctp_next, nnet) {\n#ifdef INVARIANTS\n\t\tif (SCTP_BASE_INFO(ipi_count_raddr) == 0) {\n\t\t\tpanic(\"no net's left alloc'ed, or list points to itself\");\n\t\t}\n#endif\n\t\tTAILQ_REMOVE(&asoc->nets, net, sctp_next);\n\t\tsctp_free_remote_addr(net);\n\t}\n\tLIST_FOREACH_SAFE(laddr, &asoc->sctp_restricted_addrs, sctp_nxt_addr, naddr) {\n\t\t/*sa_ignore FREED_MEMORY*/\n\t\tsctp_remove_laddr(laddr);\n\t}\n\n\t/* pending asconf (address) parameters */\n\tTAILQ_FOREACH_SAFE(aparam, &asoc->asconf_queue, next, naparam) {\n\t\t/*sa_ignore FREED_MEMORY*/\n\t\tTAILQ_REMOVE(&asoc->asconf_queue, aparam, next);\n\t\tSCTP_FREE(aparam,SCTP_M_ASC_ADDR);\n\t}\n\tTAILQ_FOREACH_SAFE(aack, &asoc->asconf_ack_sent, next, naack) {\n\t\t/*sa_ignore FREED_MEMORY*/\n\t\tTAILQ_REMOVE(&asoc->asconf_ack_sent, aack, next);\n\t\tif (aack->data != NULL) {\n\t\t\tsctp_m_freem(aack->data);\n\t\t}\n\t\tSCTP_ZONE_FREE(SCTP_BASE_INFO(ipi_zone_asconf_ack), aack);\n\t}\n\t/* clean up auth stuff */\n\tif (asoc->local_hmacs)\n\t\tsctp_free_hmaclist(asoc->local_hmacs);\n\tif (asoc->peer_hmacs)\n\t\tsctp_free_hmaclist(asoc->peer_hmacs);\n\n\tif (asoc->local_auth_chunks)\n\t\tsctp_free_chunklist(asoc->local_auth_chunks);\n\tif (asoc->peer_auth_chunks)\n\t\tsctp_free_chunklist(asoc->peer_auth_chunks);\n\n\tsctp_free_authinfo(&asoc->authinfo);\n\n\tLIST_FOREACH_SAFE(shared_key, &asoc->shared_keys, next, nshared_key) {\n\t\tLIST_REMOVE(shared_key, next);\n\t\tsctp_free_sharedkey(shared_key);\n\t\t/*sa_ignore FREED_MEMORY*/\n\t}\n\n\t/* Insert new items here :> */\n\n\t/* Get rid of LOCK */\n\tSCTP_TCB_UNLOCK(stcb);\n\tSCTP_TCB_LOCK_DESTROY(stcb);\n\tSCTP_TCB_SEND_LOCK_DESTROY(stcb);\n\tif (from_inpcbfree == SCTP_NORMAL_PROC) {\n\t\tSCTP_INP_INFO_WUNLOCK();\n\t\tSCTP_INP_RLOCK(inp);\n\t}\n#if defined(__APPLE__) /* TEMP CODE */\n\tstcb->freed_from_where = from_location;\n#endif\n#ifdef SCTP_TRACK_FREED_ASOCS\n\tif (inp->sctp_flags & SCTP_PCB_FLAGS_SOCKET_GONE) {\n\t\t/* now clean up the tasoc itself */\n\t\tSCTP_ZONE_FREE(SCTP_BASE_INFO(ipi_zone_asoc), stcb);\n\t\tSCTP_DECR_ASOC_COUNT();\n\t} else {\n\t\tLIST_INSERT_HEAD(&inp->sctp_asoc_free_list, stcb, sctp_tcblist);\n\t}\n#else\n\tSCTP_ZONE_FREE(SCTP_BASE_INFO(ipi_zone_asoc), stcb);\n\tSCTP_DECR_ASOC_COUNT();\n#endif\n\tif (from_inpcbfree == SCTP_NORMAL_PROC) {\n\t\tif (inp->sctp_flags & SCTP_PCB_FLAGS_SOCKET_GONE) {\n\t\t\t/* If its NOT the inp_free calling us AND\n\t\t\t * sctp_close as been called, we\n\t\t\t * call back...\n\t\t\t */\n\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\t/* This will start the kill timer (if we are\n\t\t\t * the last one) since we hold an increment yet. But\n\t\t\t * this is the only safe way to do this\n\t\t\t * since otherwise if the socket closes\n\t\t\t * at the same time we are here we might\n\t\t\t * collide in the cleanup.\n\t\t\t */\n\t\t\tsctp_inpcb_free(inp,\n\t\t\t\t\tSCTP_FREE_SHOULD_USE_GRACEFUL_CLOSE,\n\t\t\t\t\tSCTP_CALLED_DIRECTLY_NOCMPSET);\n\t\t\tSCTP_INP_DECR_REF(inp);\n\t\t\tgoto out_of;\n\t\t} else {\n\t\t\t/* The socket is still open. */\n\t\t\tSCTP_INP_DECR_REF(inp);\n\t\t}\n\t}\n\tif (from_inpcbfree == SCTP_NORMAL_PROC) {\n\t\tSCTP_INP_RUNLOCK(inp);\n\t}\n out_of:\n\t/* destroyed the asoc */\n#ifdef SCTP_LOG_CLOSING\n\tsctp_log_closing(inp, NULL, 11);\n#endif\n\treturn (1);\n}\n\n\n\n/*\n * determine if a destination is \"reachable\" based upon the addresses bound\n * to the current endpoint (e.g. only v4 or v6 currently bound)\n */\n/*\n * FIX: if we allow assoc-level bindx(), then this needs to be fixed to use\n * assoc level v4/v6 flags, as the assoc *may* not have the same address\n * types bound as its endpoint\n */\nint\nsctp_destination_is_reachable(struct sctp_tcb *stcb, struct sockaddr *destaddr)\n{\n\tstruct sctp_inpcb *inp;\n\tint answer;\n\n\t/*\n\t * No locks here, the TCB, in all cases is already locked and an\n\t * assoc is up. There is either a INP lock by the caller applied (in\n\t * asconf case when deleting an address) or NOT in the HB case,\n\t * however if HB then the INP increment is up and the INP will not\n\t * be removed (on top of the fact that we have a TCB lock). So we\n\t * only want to read the sctp_flags, which is either bound-all or\n\t * not.. no protection needed since once an assoc is up you can't be\n\t * changing your binding.\n\t */\n\tinp = stcb->sctp_ep;\n\tif (inp->sctp_flags & SCTP_PCB_FLAGS_BOUNDALL) {\n\t\t/* if bound all, destination is not restricted */\n\t\t/*\n\t\t * RRS: Question during lock work: Is this correct? If you\n\t\t * are bound-all you still might need to obey the V4--V6\n\t\t * flags??? IMO this bound-all stuff needs to be removed!\n\t\t */\n\t\treturn (1);\n\t}\n\t/* NOTE: all \"scope\" checks are done when local addresses are added */\n\tswitch (destaddr->sa_family) {\n#ifdef INET6\n\tcase AF_INET6:\n#if !(defined(__FreeBSD__) || defined(__APPLE__) || defined(__Windows__) || defined(__Userspace__))\n\t\tanswer = inp->inp_vflag & INP_IPV6;\n#else\n\t\tanswer = inp->ip_inp.inp.inp_vflag & INP_IPV6;\n#endif\n\t\tbreak;\n#endif\n#ifdef INET\n\tcase AF_INET:\n#if !(defined(__FreeBSD__) || defined(__APPLE__) || defined(__Windows__) || defined(__Userspace__))\n\t\tanswer = inp->inp_vflag & INP_IPV4;\n#else\n\t\tanswer = inp->ip_inp.inp.inp_vflag & INP_IPV4;\n#endif\n\t\tbreak;\n#endif\n#if defined(__Userspace__)\n\tcase AF_CONN:\n\t\tanswer = inp->ip_inp.inp.inp_vflag & INP_CONN;\n\t\tbreak;\n#endif\n\tdefault:\n\t\t/* invalid family, so it's unreachable */\n\t\tanswer = 0;\n\t\tbreak;\n\t}\n\treturn (answer);\n}\n\n/*\n * update the inp_vflags on an endpoint\n */\nstatic void\nsctp_update_ep_vflag(struct sctp_inpcb *inp)\n{\n\tstruct sctp_laddr *laddr;\n\n\t/* first clear the flag */\n#if !(defined(__FreeBSD__) || defined(__APPLE__) || defined(__Windows__) || defined(__Userspace__))\n\tinp->inp_vflag = 0;\n#else\n\tinp->ip_inp.inp.inp_vflag = 0;\n#endif\n\t/* set the flag based on addresses on the ep list */\n\tLIST_FOREACH(laddr, &inp->sctp_addr_list, sctp_nxt_addr) {\n\t\tif (laddr->ifa == NULL) {\n\t\t\tSCTPDBG(SCTP_DEBUG_PCB1, \"%s: NULL ifa\\n\",\n\t\t\t\t__func__);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (laddr->ifa->localifa_flags & SCTP_BEING_DELETED) {\n\t\t\tcontinue;\n\t\t}\n\t\tswitch (laddr->ifa->address.sa.sa_family) {\n#ifdef INET6\n\t\tcase AF_INET6:\n#if !(defined(__FreeBSD__) || defined(__APPLE__) || defined(__Windows__) || defined(__Userspace__))\n\t\t\tinp->inp_vflag |= INP_IPV6;\n#else\n\t\t\tinp->ip_inp.inp.inp_vflag |= INP_IPV6;\n#endif\n\t\t\tbreak;\n#endif\n#ifdef INET\n\t\tcase AF_INET:\n#if !(defined(__FreeBSD__) || defined(__APPLE__) || defined(__Windows__) || defined(__Userspace__))\n\t\t\tinp->inp_vflag |= INP_IPV4;\n#else\n\t\t\tinp->ip_inp.inp.inp_vflag |= INP_IPV4;\n#endif\n\t\t\tbreak;\n#endif\n#if defined(__Userspace__)\n\t\tcase AF_CONN:\n\t\t\tinp->ip_inp.inp.inp_vflag |= INP_CONN;\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/*\n * Add the address to the endpoint local address list There is nothing to be\n * done if we are bound to all addresses\n */\nvoid\nsctp_add_local_addr_ep(struct sctp_inpcb *inp, struct sctp_ifa *ifa, uint32_t action)\n{\n\tstruct sctp_laddr *laddr;\n\tstruct sctp_tcb *stcb;\n\tint fnd, error = 0;\n\n\tfnd = 0;\n\n\tif (inp->sctp_flags & SCTP_PCB_FLAGS_BOUNDALL) {\n\t\t/* You are already bound to all. You have it already */\n\t\treturn;\n\t}\n#ifdef INET6\n\tif (ifa->address.sa.sa_family == AF_INET6) {\n\t\tif (ifa->localifa_flags & SCTP_ADDR_IFA_UNUSEABLE) {\n\t\t\t/* Can't bind a non-useable addr. */\n\t\t\treturn;\n\t\t}\n\t}\n#endif\n\t/* first, is it already present? */\n\tLIST_FOREACH(laddr, &inp->sctp_addr_list, sctp_nxt_addr) {\n\t\tif (laddr->ifa == ifa) {\n\t\t\tfnd = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (fnd == 0) {\n\t\t/* Not in the ep list */\n\t\terror = sctp_insert_laddr(&inp->sctp_addr_list, ifa, action);\n\t\tif (error != 0)\n\t\t\treturn;\n\t\tinp->laddr_count++;\n\t\t/* update inp_vflag flags */\n\t\tswitch (ifa->address.sa.sa_family) {\n#ifdef INET6\n\t\tcase AF_INET6:\n#if !(defined(__FreeBSD__) || defined(__APPLE__) || defined(__Windows__) || defined(__Userspace__))\n\t\t\tinp->inp_vflag |= INP_IPV6;\n#else\n\t\t\tinp->ip_inp.inp.inp_vflag |= INP_IPV6;\n#endif\n\t\t\tbreak;\n#endif\n#ifdef INET\n\t\tcase AF_INET:\n#if !(defined(__FreeBSD__) || defined(__APPLE__) || defined(__Windows__) || defined(__Userspace__))\n\t\t\tinp->inp_vflag |= INP_IPV4;\n#else\n\t\t\tinp->ip_inp.inp.inp_vflag |= INP_IPV4;\n#endif\n\t\t\tbreak;\n#endif\n#if defined(__Userspace__)\n\t\tcase AF_CONN:\n\t\t\tinp->ip_inp.inp.inp_vflag |= INP_CONN;\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tLIST_FOREACH(stcb, &inp->sctp_asoc_list, sctp_tcblist) {\n\t\t\tsctp_add_local_addr_restricted(stcb, ifa);\n\t\t}\n\t}\n\treturn;\n}\n\n\n/*\n * select a new (hopefully reachable) destination net (should only be used\n * when we deleted an ep addr that is the only usable source address to reach\n * the destination net)\n */\nstatic void\nsctp_select_primary_destination(struct sctp_tcb *stcb)\n{\n\tstruct sctp_nets *net;\n\n\tTAILQ_FOREACH(net, &stcb->asoc.nets, sctp_next) {\n\t\t/* for now, we'll just pick the first reachable one we find */\n\t\tif (net->dest_state & SCTP_ADDR_UNCONFIRMED)\n\t\t\tcontinue;\n\t\tif (sctp_destination_is_reachable(stcb,\n\t\t    (struct sockaddr *)&net->ro._l_addr)) {\n\t\t\t/* found a reachable destination */\n\t\t\tstcb->asoc.primary_destination = net;\n\t\t}\n\t}\n\t/* I can't there from here! ...we're gonna die shortly... */\n}\n\n\n/*\n * Delete the address from the endpoint local address list. There is nothing\n * to be done if we are bound to all addresses\n */\nvoid\nsctp_del_local_addr_ep(struct sctp_inpcb *inp, struct sctp_ifa *ifa)\n{\n\tstruct sctp_laddr *laddr;\n\tint fnd;\n\n\tfnd = 0;\n\tif (inp->sctp_flags & SCTP_PCB_FLAGS_BOUNDALL) {\n\t\t/* You are already bound to all. You have it already */\n\t\treturn;\n\t}\n\tLIST_FOREACH(laddr, &inp->sctp_addr_list, sctp_nxt_addr) {\n\t\tif (laddr->ifa == ifa) {\n\t\t\tfnd = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fnd && (inp->laddr_count < 2)) {\n\t\t/* can't delete unless there are at LEAST 2 addresses */\n\t\treturn;\n\t}\n\tif (fnd) {\n\t\t/*\n\t\t * clean up any use of this address go through our\n\t\t * associations and clear any last_used_address that match\n\t\t * this one for each assoc, see if a new primary_destination\n\t\t * is needed\n\t\t */\n\t\tstruct sctp_tcb *stcb;\n\n\t\t/* clean up \"next_addr_touse\" */\n\t\tif (inp->next_addr_touse == laddr)\n\t\t\t/* delete this address */\n\t\t\tinp->next_addr_touse = NULL;\n\n\t\t/* clean up \"last_used_address\" */\n\t\tLIST_FOREACH(stcb, &inp->sctp_asoc_list, sctp_tcblist) {\n\t\t\tstruct sctp_nets *net;\n\n\t\t\tSCTP_TCB_LOCK(stcb);\n\t\t\tif (stcb->asoc.last_used_address == laddr)\n\t\t\t\t/* delete this address */\n\t\t\t\tstcb->asoc.last_used_address = NULL;\n\t\t\t/* Now spin through all the nets and purge any ref to laddr */\n\t\t\tTAILQ_FOREACH(net, &stcb->asoc.nets, sctp_next) {\n\t\t\t\tif (net->ro._s_addr == laddr->ifa) {\n\t\t\t\t\t/* Yep, purge src address selected */\n\t\t\t\t\tsctp_rtentry_t *rt;\n\n\t\t\t\t\t/* delete this address if cached */\n\t\t\t\t\trt = net->ro.ro_rt;\n\t\t\t\t\tif (rt != NULL) {\n\t\t\t\t\t\tRTFREE(rt);\n\t\t\t\t\t\tnet->ro.ro_rt = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tsctp_free_ifa(net->ro._s_addr);\n\t\t\t\t\tnet->ro._s_addr = NULL;\n\t\t\t\t\tnet->src_addr_selected = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSCTP_TCB_UNLOCK(stcb);\n\t\t}\t\t/* for each tcb */\n\t\t/* remove it from the ep list */\n\t\tsctp_remove_laddr(laddr);\n\t\tinp->laddr_count--;\n\t\t/* update inp_vflag flags */\n\t\tsctp_update_ep_vflag(inp);\n\t}\n\treturn;\n}\n\n/*\n * Add the address to the TCB local address restricted list.\n * This is a \"pending\" address list (eg. addresses waiting for an\n * ASCONF-ACK response) and cannot be used as a valid source address.\n */\nvoid\nsctp_add_local_addr_restricted(struct sctp_tcb *stcb, struct sctp_ifa *ifa)\n{\n\tstruct sctp_laddr *laddr;\n\tstruct sctpladdr *list;\n\n\t/*\n\t * Assumes TCB is locked.. and possibly the INP. May need to\n\t * confirm/fix that if we need it and is not the case.\n\t */\n\tlist = &stcb->asoc.sctp_restricted_addrs;\n\n#ifdef INET6\n\tif (ifa->address.sa.sa_family == AF_INET6) {\n\t\tif (ifa->localifa_flags & SCTP_ADDR_IFA_UNUSEABLE) {\n\t\t\t/* Can't bind a non-existent addr. */\n\t\t\treturn;\n\t\t}\n\t}\n#endif\n\t/* does the address already exist? */\n\tLIST_FOREACH(laddr, list, sctp_nxt_addr) {\n\t\tif (laddr->ifa == ifa) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* add to the list */\n\t(void)sctp_insert_laddr(list, ifa, 0);\n\treturn;\n}\n\n/*\n * Remove a local address from the TCB local address restricted list\n */\nvoid\nsctp_del_local_addr_restricted(struct sctp_tcb *stcb, struct sctp_ifa *ifa)\n{\n\tstruct sctp_inpcb *inp;\n\tstruct sctp_laddr *laddr;\n\n\t/*\n\t * This is called by asconf work. It is assumed that a) The TCB is\n\t * locked and b) The INP is locked. This is true in as much as I can\n\t * trace through the entry asconf code where I did these locks.\n\t * Again, the ASCONF code is a bit different in that it does lock\n\t * the INP during its work often times. This must be since we don't\n\t * want other proc's looking up things while what they are looking\n\t * up is changing :-D\n\t */\n\n\tinp = stcb->sctp_ep;\n\t/* if subset bound and don't allow ASCONF's, can't delete last */\n\tif (((inp->sctp_flags & SCTP_PCB_FLAGS_BOUNDALL) == 0) &&\n\t    sctp_is_feature_off(inp, SCTP_PCB_FLAGS_DO_ASCONF)) {\n\t\tif (stcb->sctp_ep->laddr_count < 2) {\n\t\t\t/* can't delete last address */\n\t\t\treturn;\n\t\t}\n\t}\n\tLIST_FOREACH(laddr, &stcb->asoc.sctp_restricted_addrs, sctp_nxt_addr) {\n\t\t/* remove the address if it exists */\n\t\tif (laddr->ifa == NULL)\n\t\t\tcontinue;\n\t\tif (laddr->ifa == ifa) {\n\t\t\tsctp_remove_laddr(laddr);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* address not found! */\n\treturn;\n}\n\n#if defined(__FreeBSD__)\n/*\n * Temporarily remove for __APPLE__ until we use the Tiger equivalents\n */\n/* sysctl */\nstatic int sctp_max_number_of_assoc = SCTP_MAX_NUM_OF_ASOC;\nstatic int sctp_scale_up_for_address = SCTP_SCALE_FOR_ADDR;\n#endif\t\t\t\t/* FreeBSD || APPLE */\n\n\n\n#if defined(__FreeBSD__) && defined(SCTP_MCORE_INPUT) && defined(SMP)\nstruct sctp_mcore_ctrl *sctp_mcore_workers = NULL;\nint *sctp_cpuarry = NULL;\nvoid\nsctp_queue_to_mcore(struct mbuf *m, int off, int cpu_to_use)\n{\n\t/* Queue a packet to a processor for the specified core */\n\tstruct sctp_mcore_queue *qent;\n\tstruct sctp_mcore_ctrl *wkq;\n\tint need_wake = 0;\n\tif (sctp_mcore_workers == NULL) {\n\t\t/* Something went way bad during setup */\n\t\tsctp_input_with_port(m, off, 0);\n\t\treturn;\n\t}\n\tSCTP_MALLOC(qent, struct sctp_mcore_queue *,\n\t\t    (sizeof(struct sctp_mcore_queue)),\n\t\t    SCTP_M_MCORE);\n\tif (qent == NULL) {\n\t\t/* This is trouble  */\n\t\tsctp_input_with_port(m, off, 0);\n\t\treturn;\n\t}\n#if defined(__FreeBSD__) && __FreeBSD_version >= 801000\n\tqent->vn = curvnet;\n#endif\n\tqent->m = m;\n\tqent->off = off;\n\tqent->v6 = 0;\n\twkq = &sctp_mcore_workers[cpu_to_use];\n\tSCTP_MCORE_QLOCK(wkq);\n\n\tTAILQ_INSERT_TAIL(&wkq->que, qent, next);\n\tif (wkq->running == 0) {\n\t\tneed_wake = 1;\n\t}\n\tSCTP_MCORE_QUNLOCK(wkq);\n\tif (need_wake) {\n\t\twakeup(&wkq->running);\n\t}\n}\n\nstatic void\nsctp_mcore_thread(void *arg)\n{\n\n\tstruct sctp_mcore_ctrl *wkq;\n\tstruct sctp_mcore_queue *qent;\n\n\twkq = (struct sctp_mcore_ctrl *)arg;\n\tstruct mbuf *m;\n\tint off, v6;\n\n\t/* Wait for first tickle */\n\tSCTP_MCORE_LOCK(wkq);\n\twkq->running = 0;\n\tmsleep(&wkq->running,\n\t       &wkq->core_mtx,\n\t       0, \"wait for pkt\", 0);\n\tSCTP_MCORE_UNLOCK(wkq);\n\n\t/* Bind to our cpu */\n\tthread_lock(curthread);\n\tsched_bind(curthread, wkq->cpuid);\n\tthread_unlock(curthread);\n\n\t/* Now lets start working */\n\tSCTP_MCORE_LOCK(wkq);\n\t/* Now grab lock and go */\n\tfor (;;) {\n\t\tSCTP_MCORE_QLOCK(wkq);\n\tskip_sleep:\n\t\twkq->running = 1;\n\t\tqent = TAILQ_FIRST(&wkq->que);\n\t\tif (qent) {\n\t\t\tTAILQ_REMOVE(&wkq->que, qent, next);\n\t\t\tSCTP_MCORE_QUNLOCK(wkq);\n#if defined(__FreeBSD__) && __FreeBSD_version >= 801000\n\t\t\tCURVNET_SET(qent->vn);\n#endif\n\t\t\tm = qent->m;\n\t\t\toff = qent->off;\n\t\t\tv6 = qent->v6;\n\t\t\tSCTP_FREE(qent, SCTP_M_MCORE);\n\t\t\tif (v6 == 0) {\n\t\t\t\tsctp_input_with_port(m, off, 0);\n\t\t\t} else {\n\t\t\t\tSCTP_PRINTF(\"V6 not yet supported\\n\");\n\t\t\t\tsctp_m_freem(m);\n\t\t\t}\n#if defined(__FreeBSD__) && __FreeBSD_version >= 801000\n\t\t\tCURVNET_RESTORE();\n#endif\n\t\t\tSCTP_MCORE_QLOCK(wkq);\n\t\t}\n\t\twkq->running = 0;\n\t\tif (!TAILQ_EMPTY(&wkq->que)) {\n\t\t\tgoto skip_sleep;\n\t\t}\n\t\tSCTP_MCORE_QUNLOCK(wkq);\n\t\tmsleep(&wkq->running,\n\t\t       &wkq->core_mtx,\n\t\t       0, \"wait for pkt\", 0);\n\t}\n}\n\nstatic void\nsctp_startup_mcore_threads(void)\n{\n\tint i, cpu;\n\n\tif (mp_ncpus == 1)\n\t\treturn;\n\n\tif (sctp_mcore_workers != NULL) {\n\t\t/* Already been here in some previous\n\t\t * vnet?\n\t\t */\n\t\treturn;\n\t}\n\tSCTP_MALLOC(sctp_mcore_workers, struct sctp_mcore_ctrl *,\n\t\t    ((mp_maxid+1) * sizeof(struct sctp_mcore_ctrl)),\n\t\t    SCTP_M_MCORE);\n\tif (sctp_mcore_workers == NULL) {\n\t\t/* TSNH I hope */\n\t\treturn;\n\t}\n\tmemset(sctp_mcore_workers, 0 , ((mp_maxid+1) *\n\t\t\t\t\tsizeof(struct sctp_mcore_ctrl)));\n\t/* Init the structures */\n\tfor (i = 0; i<=mp_maxid; i++) {\n\t\tTAILQ_INIT(&sctp_mcore_workers[i].que);\n\t\tSCTP_MCORE_LOCK_INIT(&sctp_mcore_workers[i]);\n\t\tSCTP_MCORE_QLOCK_INIT(&sctp_mcore_workers[i]);\n\t\tsctp_mcore_workers[i].cpuid = i;\n\t}\n\tif (sctp_cpuarry == NULL) {\n\t\tSCTP_MALLOC(sctp_cpuarry, int *,\n\t\t\t    (mp_ncpus * sizeof(int)),\n\t\t\t    SCTP_M_MCORE);\n\t\ti = 0;\n\t\tCPU_FOREACH(cpu) {\n\t\t\tsctp_cpuarry[i] = cpu;\n\t\t\ti++;\n\t\t}\n\t}\n\n\t/* Now start them all */\n\tCPU_FOREACH(cpu) {\n#if __FreeBSD_version <= 701000\n\t\t(void)kthread_create(sctp_mcore_thread,\n\t\t\t\t     (void *)&sctp_mcore_workers[cpu],\n\t\t\t\t     &sctp_mcore_workers[cpu].thread_proc,\n\t\t\t\t     RFPROC,\n\t\t\t\t     SCTP_KTHREAD_PAGES,\n\t\t\t\t     SCTP_MCORE_NAME);\n\n#else\n\t\t(void)kproc_create(sctp_mcore_thread,\n\t\t\t\t   (void *)&sctp_mcore_workers[cpu],\n\t\t\t\t   &sctp_mcore_workers[cpu].thread_proc,\n\t\t\t\t   RFPROC,\n\t\t\t\t   SCTP_KTHREAD_PAGES,\n\t\t\t\t   SCTP_MCORE_NAME);\n#endif\n\n\t}\n}\n#endif\n#if defined(__FreeBSD__) && __FreeBSD_cc_version >= 1400000\nstatic struct mbuf *\nsctp_netisr_hdlr(struct mbuf *m, uintptr_t source)\n{\n\tstruct ip *ip;\n\tstruct sctphdr *sh;\n\tint offset;\n\tuint32_t flowid, tag;\n\n\t/*\n\t * No flow id built by lower layers fix it so we\n\t * create one.\n\t */\n\tip = mtod(m, struct ip *);\n\toffset = (ip->ip_hl << 2) + sizeof(struct sctphdr);\n\tif (SCTP_BUF_LEN(m) < offset) {\n\t\tif ((m = m_pullup(m, offset)) == NULL) {\n\t\t\tSCTP_STAT_INCR(sctps_hdrops);\n\t\t\treturn (NULL);\n\t\t}\n\t\tip = mtod(m, struct ip *);\n\t}\n\tsh = (struct sctphdr *)((caddr_t)ip + (ip->ip_hl << 2));\n\ttag = htonl(sh->v_tag);\n\tflowid = tag ^ ntohs(sh->dest_port) ^ ntohs(sh->src_port);\n\tm->m_pkthdr.flowid = flowid;\n/* FIX ME */\n\tm->m_flags |= M_FLOWID;\n\treturn (m);\n}\n#endif\n\nvoid\n#if defined(__Userspace__)\nsctp_pcb_init(int start_threads)\n#else\nsctp_pcb_init(void)\n#endif\n{\n\t/*\n\t * SCTP initialization for the PCB structures should be called by\n\t * the sctp_init() function.\n\t */\n\tint i;\n\tstruct timeval tv;\n\n\tif (SCTP_BASE_VAR(sctp_pcb_initialized) != 0) {\n\t\t/* error I was called twice */\n\t\treturn;\n\t}\n\tSCTP_BASE_VAR(sctp_pcb_initialized) = 1;\n\n#if defined(SCTP_PROCESS_LEVEL_LOCKS)\n#if !defined(__Userspace_os_Windows)\n\tpthread_mutexattr_init(&SCTP_BASE_VAR(mtx_attr));\n#ifdef INVARIANTS\n\tpthread_mutexattr_settype(&SCTP_BASE_VAR(mtx_attr), PTHREAD_MUTEX_ERRORCHECK);\n#endif\n#endif\n#endif\n#if defined(SCTP_LOCAL_TRACE_BUF)\n#if defined(__Windows__)\n\tif (SCTP_BASE_SYSCTL(sctp_log) != NULL) {\n\t\tmemset(SCTP_BASE_SYSCTL(sctp_log), 0, sizeof(struct sctp_log));\n\t}\n#else\n\tmemset(&SCTP_BASE_SYSCTL(sctp_log), 0, sizeof(struct sctp_log));\n#endif\n#endif\n#if defined(__FreeBSD__) && defined(SMP) && defined(SCTP_USE_PERCPU_STAT)\n\tSCTP_MALLOC(SCTP_BASE_STATS, struct sctpstat *,\n\t\t    ((mp_maxid+1) * sizeof(struct sctpstat)),\n\t\t    SCTP_M_MCORE);\n#endif\n\t(void)SCTP_GETTIME_TIMEVAL(&tv);\n#if defined(__FreeBSD__) && defined(SMP) && defined(SCTP_USE_PERCPU_STAT)\n\tmemset(SCTP_BASE_STATS, 0, sizeof(struct sctpstat) * (mp_maxid+1));\n\tSCTP_BASE_STATS[PCPU_GET(cpuid)].sctps_discontinuitytime.tv_sec = (uint32_t)tv.tv_sec;\n\tSCTP_BASE_STATS[PCPU_GET(cpuid)].sctps_discontinuitytime.tv_usec = (uint32_t)tv.tv_usec;\n#else\n\tmemset(&SCTP_BASE_STATS, 0, sizeof(struct sctpstat));\n\tSCTP_BASE_STAT(sctps_discontinuitytime).tv_sec = (uint32_t)tv.tv_sec;\n\tSCTP_BASE_STAT(sctps_discontinuitytime).tv_usec = (uint32_t)tv.tv_usec;\n#endif\n\t/* init the empty list of (All) Endpoints */\n\tLIST_INIT(&SCTP_BASE_INFO(listhead));\n#if defined(__APPLE__)\n\tLIST_INIT(&SCTP_BASE_INFO(inplisthead));\n#if defined(APPLE_LEOPARD) || defined(APPLE_SNOWLEOPARD) || defined(APPLE_LION) || defined(APPLE_MOUNTAINLION)\n\tSCTP_BASE_INFO(sctbinfo).listhead = &SCTP_BASE_INFO(inplisthead);\n\tSCTP_BASE_INFO(sctbinfo).mtx_grp_attr = lck_grp_attr_alloc_init();\n\tlck_grp_attr_setdefault(SCTP_BASE_INFO(sctbinfo).mtx_grp_attr);\n\tSCTP_BASE_INFO(sctbinfo).mtx_grp = lck_grp_alloc_init(\"sctppcb\", SCTP_BASE_INFO(sctbinfo).mtx_grp_attr);\n\tSCTP_BASE_INFO(sctbinfo).mtx_attr = lck_attr_alloc_init();\n\tlck_attr_setdefault(SCTP_BASE_INFO(sctbinfo).mtx_attr);\n#else\n\tSCTP_BASE_INFO(sctbinfo).ipi_listhead = &SCTP_BASE_INFO(inplisthead);\n\tSCTP_BASE_INFO(sctbinfo).ipi_lock_grp_attr = lck_grp_attr_alloc_init();\n\tlck_grp_attr_setdefault(SCTP_BASE_INFO(sctbinfo).ipi_lock_grp_attr);\n\tSCTP_BASE_INFO(sctbinfo).ipi_lock_grp = lck_grp_alloc_init(\"sctppcb\", SCTP_BASE_INFO(sctbinfo).ipi_lock_grp_attr);\n\tSCTP_BASE_INFO(sctbinfo).ipi_lock_attr = lck_attr_alloc_init();\n\tlck_attr_setdefault(SCTP_BASE_INFO(sctbinfo).ipi_lock_attr);\n#endif\n#if !defined(APPLE_LEOPARD) && !defined(APPLE_SNOWLEOPARD) && !defined(APPLE_LION) && !defined(APPLE_MOUNTAINLION)\n\tSCTP_BASE_INFO(sctbinfo).ipi_gc = sctp_gc;\n\tin_pcbinfo_attach(&SCTP_BASE_INFO(sctbinfo));\n#endif\n#endif\n\n\n\t/* init the hash table of endpoints */\n#if defined(__FreeBSD__)\n#if defined(__FreeBSD_cc_version) && __FreeBSD_cc_version >= 440000\n\tTUNABLE_INT_FETCH(\"net.inet.sctp.tcbhashsize\", &SCTP_BASE_SYSCTL(sctp_hashtblsize));\n\tTUNABLE_INT_FETCH(\"net.inet.sctp.pcbhashsize\", &SCTP_BASE_SYSCTL(sctp_pcbtblsize));\n\tTUNABLE_INT_FETCH(\"net.inet.sctp.chunkscale\", &SCTP_BASE_SYSCTL(sctp_chunkscale));\n#else\n\tTUNABLE_INT_FETCH(\"net.inet.sctp.tcbhashsize\", SCTP_TCBHASHSIZE,\n\t\t\t  SCTP_BASE_SYSCTL(sctp_hashtblsize));\n\tTUNABLE_INT_FETCH(\"net.inet.sctp.pcbhashsize\", SCTP_PCBHASHSIZE,\n\t\t\t  SCTP_BASE_SYSCTL(sctp_pcbtblsize));\n\tTUNABLE_INT_FETCH(\"net.inet.sctp.chunkscale\", SCTP_CHUNKQUEUE_SCALE,\n\t\t\t  SCTP_BASE_SYSCTL(sctp_chunkscale));\n#endif\n#endif\n\tSCTP_BASE_INFO(sctp_asochash) = SCTP_HASH_INIT((SCTP_BASE_SYSCTL(sctp_hashtblsize) * 31),\n\t\t\t\t\t\t       &SCTP_BASE_INFO(hashasocmark));\n\tSCTP_BASE_INFO(sctp_ephash) = SCTP_HASH_INIT(SCTP_BASE_SYSCTL(sctp_hashtblsize),\n\t\t\t\t\t\t     &SCTP_BASE_INFO(hashmark));\n\tSCTP_BASE_INFO(sctp_tcpephash) = SCTP_HASH_INIT(SCTP_BASE_SYSCTL(sctp_hashtblsize),\n\t\t\t\t\t\t\t&SCTP_BASE_INFO(hashtcpmark));\n\tSCTP_BASE_INFO(hashtblsize) = SCTP_BASE_SYSCTL(sctp_hashtblsize);\n\n\n\tSCTP_BASE_INFO(sctp_vrfhash) = SCTP_HASH_INIT(SCTP_SIZE_OF_VRF_HASH,\n\t\t\t\t\t\t      &SCTP_BASE_INFO(hashvrfmark));\n\n\tSCTP_BASE_INFO(vrf_ifn_hash) = SCTP_HASH_INIT(SCTP_VRF_IFN_HASH_SIZE,\n\t\t\t\t\t\t      &SCTP_BASE_INFO(vrf_ifn_hashmark));\n\t/* init the zones */\n\t/*\n\t * FIX ME: Should check for NULL returns, but if it does fail we are\n\t * doomed to panic anyways... add later maybe.\n\t */\n\tSCTP_ZONE_INIT(SCTP_BASE_INFO(ipi_zone_ep), \"sctp_ep\",\n\t\t       sizeof(struct sctp_inpcb), maxsockets);\n\n\tSCTP_ZONE_INIT(SCTP_BASE_INFO(ipi_zone_asoc), \"sctp_asoc\",\n\t\t       sizeof(struct sctp_tcb), sctp_max_number_of_assoc);\n\n\tSCTP_ZONE_INIT(SCTP_BASE_INFO(ipi_zone_laddr), \"sctp_laddr\",\n\t\t       sizeof(struct sctp_laddr),\n\t\t       (sctp_max_number_of_assoc * sctp_scale_up_for_address));\n\n\tSCTP_ZONE_INIT(SCTP_BASE_INFO(ipi_zone_net), \"sctp_raddr\",\n\t\t       sizeof(struct sctp_nets),\n\t\t       (sctp_max_number_of_assoc * sctp_scale_up_for_address));\n\n\tSCTP_ZONE_INIT(SCTP_BASE_INFO(ipi_zone_chunk), \"sctp_chunk\",\n\t\t       sizeof(struct sctp_tmit_chunk),\n\t\t       (sctp_max_number_of_assoc * SCTP_BASE_SYSCTL(sctp_chunkscale)));\n\n\tSCTP_ZONE_INIT(SCTP_BASE_INFO(ipi_zone_readq), \"sctp_readq\",\n\t\t       sizeof(struct sctp_queued_to_read),\n\t\t       (sctp_max_number_of_assoc * SCTP_BASE_SYSCTL(sctp_chunkscale)));\n\n\tSCTP_ZONE_INIT(SCTP_BASE_INFO(ipi_zone_strmoq), \"sctp_stream_msg_out\",\n\t\t       sizeof(struct sctp_stream_queue_pending),\n\t\t       (sctp_max_number_of_assoc * SCTP_BASE_SYSCTL(sctp_chunkscale)));\n\n\tSCTP_ZONE_INIT(SCTP_BASE_INFO(ipi_zone_asconf), \"sctp_asconf\",\n\t\t       sizeof(struct sctp_asconf),\n\t\t       (sctp_max_number_of_assoc * SCTP_BASE_SYSCTL(sctp_chunkscale)));\n\n\tSCTP_ZONE_INIT(SCTP_BASE_INFO(ipi_zone_asconf_ack), \"sctp_asconf_ack\",\n\t\t       sizeof(struct sctp_asconf_ack),\n\t\t       (sctp_max_number_of_assoc * SCTP_BASE_SYSCTL(sctp_chunkscale)));\n\n\n\t/* Master Lock INIT for info structure */\n\tSCTP_INP_INFO_LOCK_INIT();\n\tSCTP_STATLOG_INIT_LOCK();\n\n\tSCTP_IPI_COUNT_INIT();\n\tSCTP_IPI_ADDR_INIT();\n#ifdef SCTP_PACKET_LOGGING\n\tSCTP_IP_PKTLOG_INIT();\n#endif\n\tLIST_INIT(&SCTP_BASE_INFO(addr_wq));\n\n\tSCTP_WQ_ADDR_INIT();\n\t/* not sure if we need all the counts */\n\tSCTP_BASE_INFO(ipi_count_ep) = 0;\n\t/* assoc/tcb zone info */\n\tSCTP_BASE_INFO(ipi_count_asoc) = 0;\n\t/* local addrlist zone info */\n\tSCTP_BASE_INFO(ipi_count_laddr) = 0;\n\t/* remote addrlist zone info */\n\tSCTP_BASE_INFO(ipi_count_raddr) = 0;\n\t/* chunk info */\n\tSCTP_BASE_INFO(ipi_count_chunk) = 0;\n\n\t/* socket queue zone info */\n\tSCTP_BASE_INFO(ipi_count_readq) = 0;\n\n\t/* stream out queue cont */\n\tSCTP_BASE_INFO(ipi_count_strmoq) = 0;\n\n\tSCTP_BASE_INFO(ipi_free_strmoq) = 0;\n\tSCTP_BASE_INFO(ipi_free_chunks) = 0;\n\n\tSCTP_OS_TIMER_INIT(&SCTP_BASE_INFO(addr_wq_timer.timer));\n\n\t/* Init the TIMEWAIT list */\n\tfor (i = 0; i < SCTP_STACK_VTAG_HASH_SIZE; i++) {\n\t\tLIST_INIT(&SCTP_BASE_INFO(vtag_timewait)[i]);\n\t}\n#if defined(SCTP_PROCESS_LEVEL_LOCKS)\n#if defined(__Userspace_os_Windows)\n\tInitializeConditionVariable(&sctp_it_ctl.iterator_wakeup);\n#else\n\t(void)pthread_cond_init(&sctp_it_ctl.iterator_wakeup, NULL);\n#endif\n#endif\n\tsctp_startup_iterator();\n\n#if defined(__FreeBSD__) && defined(SCTP_MCORE_INPUT) && defined(SMP)\n\tsctp_startup_mcore_threads();\n#endif\n\n#ifndef __Panda__\n\t/*\n\t * INIT the default VRF which for BSD is the only one, other O/S's\n\t * may have more. But initially they must start with one and then\n\t * add the VRF's as addresses are added.\n\t */\n\tsctp_init_vrf_list(SCTP_DEFAULT_VRF);\n#endif\n#if defined(__FreeBSD__) && __FreeBSD_cc_version >= 1400000\n\tif (ip_register_flow_handler(sctp_netisr_hdlr, IPPROTO_SCTP)) {\n\t\tSCTP_PRINTF(\"***SCTP- Error can't register netisr handler***\\n\");\n\t}\n#endif\n#if defined(_SCTP_NEEDS_CALLOUT_) || defined(_USER_SCTP_NEEDS_CALLOUT_)\n\t/* allocate the lock for the callout/timer queue */\n\tSCTP_TIMERQ_LOCK_INIT();\n\tSCTP_TIMERWAIT_LOCK_INIT();\n\tTAILQ_INIT(&SCTP_BASE_INFO(callqueue));\n#endif\n#if defined(__Userspace__)\n\tmbuf_initialize(NULL);\n\tatomic_init();\n#if defined(INET) || defined(INET6)\n\tif (start_threads)\n\t\trecv_thread_init();\n#endif\n#endif\n}\n\n/*\n * Assumes that the SCTP_BASE_INFO() lock is NOT held.\n */\nvoid\nsctp_pcb_finish(void)\n{\n\tstruct sctp_vrflist *vrf_bucket;\n\tstruct sctp_vrf *vrf, *nvrf;\n\tstruct sctp_ifn *ifn, *nifn;\n\tstruct sctp_ifa *ifa, *nifa;\n\tstruct sctpvtaghead *chain;\n\tstruct sctp_tagblock *twait_block, *prev_twait_block;\n\tstruct sctp_laddr *wi, *nwi;\n\tint i;\n\tstruct sctp_iterator *it, *nit;\n\n\tif (SCTP_BASE_VAR(sctp_pcb_initialized) == 0) {\n\t\tSCTP_PRINTF(\"%s: race condition on teardown.\\n\", __func__);\n\t\treturn;\n\t}\n\tSCTP_BASE_VAR(sctp_pcb_initialized) = 0;\n#if !defined(__FreeBSD__)\n\t/* Notify the iterator to exit. */\n\tSCTP_IPI_ITERATOR_WQ_LOCK();\n\tsctp_it_ctl.iterator_flags |= SCTP_ITERATOR_MUST_EXIT;\n\tsctp_wakeup_iterator();\n\tSCTP_IPI_ITERATOR_WQ_UNLOCK();\n#endif\n#if defined(__APPLE__)\n#if !defined(APPLE_LEOPARD) && !defined(APPLE_SNOWLEOPARD) && !defined(APPLE_LION) && !defined(APPLE_MOUNTAINLION)\n\tin_pcbinfo_detach(&SCTP_BASE_INFO(sctbinfo));\n#endif\n\tSCTP_IPI_ITERATOR_WQ_LOCK();\n\tdo {\n\t\tmsleep(&sctp_it_ctl.iterator_flags,\n\t\t       sctp_it_ctl.ipi_iterator_wq_mtx,\n\t\t       0, \"waiting_for_work\", 0);\n\t} while ((sctp_it_ctl.iterator_flags & SCTP_ITERATOR_EXITED) == 0);\n\tthread_deallocate(sctp_it_ctl.thread_proc);\n\tSCTP_IPI_ITERATOR_WQ_UNLOCK();\n#endif\n#if defined(__Windows__)\n\tif (sctp_it_ctl.iterator_thread_obj != NULL) {\n\t\tNTSTATUS status = STATUS_SUCCESS;\n\n\t\tKeSetEvent(&sctp_it_ctl.iterator_wakeup[1], IO_NO_INCREMENT, FALSE);\n\t\tstatus = KeWaitForSingleObject(sctp_it_ctl.iterator_thread_obj,\n\t\t\t\t\t       Executive,\n\t\t\t\t\t       KernelMode,\n\t\t\t\t\t       FALSE,\n\t\t\t\t\t       NULL);\n\t\tObDereferenceObject(sctp_it_ctl.iterator_thread_obj);\n\t}\n#endif\n#if defined(__Userspace__)\n\tif (sctp_it_ctl.thread_proc) {\n#if defined(__Userspace_os_Windows)\n\t\tWaitForSingleObject(sctp_it_ctl.thread_proc, INFINITE);\n\t\tCloseHandle(sctp_it_ctl.thread_proc);\n\t\tsctp_it_ctl.thread_proc = NULL;\n#else\n\t\tpthread_join(sctp_it_ctl.thread_proc, NULL);\n\t\tsctp_it_ctl.thread_proc = 0;\n#endif\n\t}\n#endif\n#if defined(SCTP_PROCESS_LEVEL_LOCKS)\n#if defined(__Userspace_os_Windows)\n\tDeleteConditionVariable(&sctp_it_ctl.iterator_wakeup);\n#else\n\tpthread_cond_destroy(&sctp_it_ctl.iterator_wakeup);\n\tpthread_mutexattr_destroy(&SCTP_BASE_VAR(mtx_attr));\n#endif\n#endif\n\t/* In FreeBSD the iterator thread never exits\n\t * but we do clean up.\n\t * The only way FreeBSD reaches here is if we have VRF's\n\t * but we still add the ifdef to make it compile on old versions.\n\t */\n#if defined(__FreeBSD__)\nretry:\n#endif\n\tSCTP_IPI_ITERATOR_WQ_LOCK();\n#if defined(__FreeBSD__)\n\t/*\n\t * sctp_iterator_worker() might be working on an it entry without\n\t * holding the lock.  We won't find it on the list either and\n\t * continue and free/destroy it.  While holding the lock, spin, to\n\t * avoid the race condition as sctp_iterator_worker() will have to\n\t * wait to re-aquire the lock.\n\t */\n\tif (sctp_it_ctl.iterator_running != 0 || sctp_it_ctl.cur_it != NULL) {\n\t\tSCTP_IPI_ITERATOR_WQ_UNLOCK();\n\t\tSCTP_PRINTF(\"%s: Iterator running while we held the lock. Retry. \"\n\t\t            \"cur_it=%p\\n\", __func__, sctp_it_ctl.cur_it);\n\t\tDELAY(10);\n\t\tgoto retry;\n\t}\n#endif\n\tTAILQ_FOREACH_SAFE(it, &sctp_it_ctl.iteratorhead, sctp_nxt_itr, nit) {\n#if defined(__FreeBSD__) && __FreeBSD_version >= 801000\n\t\tif (it->vn != curvnet) {\n\t\t\tcontinue;\n\t\t}\n#endif\n\t\tTAILQ_REMOVE(&sctp_it_ctl.iteratorhead, it, sctp_nxt_itr);\n\t\tif (it->function_atend != NULL) {\n\t\t\t(*it->function_atend) (it->pointer, it->val);\n\t\t}\n\t\tSCTP_FREE(it,SCTP_M_ITER);\n\t}\n\tSCTP_IPI_ITERATOR_WQ_UNLOCK();\n#if defined(__FreeBSD__) && __FreeBSD_version >= 801000\n\tSCTP_ITERATOR_LOCK();\n\tif ((sctp_it_ctl.cur_it) &&\n\t    (sctp_it_ctl.cur_it->vn == curvnet)) {\n\t\tsctp_it_ctl.iterator_flags |= SCTP_ITERATOR_STOP_CUR_IT;\n\t}\n\tSCTP_ITERATOR_UNLOCK();\n#endif\n#if !defined(__FreeBSD__)\n\tSCTP_IPI_ITERATOR_WQ_DESTROY();\n\tSCTP_ITERATOR_LOCK_DESTROY();\n#endif\n\tSCTP_OS_TIMER_STOP_DRAIN(&SCTP_BASE_INFO(addr_wq_timer.timer));\n\tSCTP_WQ_ADDR_LOCK();\n\tLIST_FOREACH_SAFE(wi, &SCTP_BASE_INFO(addr_wq), sctp_nxt_addr, nwi) {\n\t\tLIST_REMOVE(wi, sctp_nxt_addr);\n\t\tSCTP_DECR_LADDR_COUNT();\n\t\tif (wi->action == SCTP_DEL_IP_ADDRESS) {\n\t\t\tSCTP_FREE(wi->ifa, SCTP_M_IFA);\n\t\t}\n\t\tSCTP_ZONE_FREE(SCTP_BASE_INFO(ipi_zone_laddr), wi);\n\t}\n\tSCTP_WQ_ADDR_UNLOCK();\n\n\t/*\n\t * free the vrf/ifn/ifa lists and hashes (be sure address monitor\n\t * is destroyed first).\n\t */\n\tvrf_bucket = &SCTP_BASE_INFO(sctp_vrfhash)[(SCTP_DEFAULT_VRFID & SCTP_BASE_INFO(hashvrfmark))];\n\tLIST_FOREACH_SAFE(vrf, vrf_bucket, next_vrf, nvrf) {\n\t\tLIST_FOREACH_SAFE(ifn, &vrf->ifnlist, next_ifn, nifn) {\n\t\t\tLIST_FOREACH_SAFE(ifa, &ifn->ifalist, next_ifa, nifa) {\n\t\t\t\t/* free the ifa */\n\t\t\t\tLIST_REMOVE(ifa, next_bucket);\n\t\t\t\tLIST_REMOVE(ifa, next_ifa);\n\t\t\t\tSCTP_FREE(ifa, SCTP_M_IFA);\n\t\t\t}\n\t\t\t/* free the ifn */\n\t\t\tLIST_REMOVE(ifn, next_bucket);\n\t\t\tLIST_REMOVE(ifn, next_ifn);\n\t\t\tSCTP_FREE(ifn, SCTP_M_IFN);\n\t\t}\n\t\tSCTP_HASH_FREE(vrf->vrf_addr_hash, vrf->vrf_addr_hashmark);\n\t\t/* free the vrf */\n\t\tLIST_REMOVE(vrf, next_vrf);\n\t\tSCTP_FREE(vrf, SCTP_M_VRF);\n\t}\n\t/* free the vrf hashes */\n\tSCTP_HASH_FREE(SCTP_BASE_INFO(sctp_vrfhash), SCTP_BASE_INFO(hashvrfmark));\n\tSCTP_HASH_FREE(SCTP_BASE_INFO(vrf_ifn_hash), SCTP_BASE_INFO(vrf_ifn_hashmark));\n\n\t/* free the TIMEWAIT list elements malloc'd in the function\n\t * sctp_add_vtag_to_timewait()...\n\t */\n\tfor (i = 0; i < SCTP_STACK_VTAG_HASH_SIZE; i++) {\n\t\tchain = &SCTP_BASE_INFO(vtag_timewait)[i];\n\t\tif (!LIST_EMPTY(chain)) {\n\t\t\tprev_twait_block = NULL;\n\t\t\tLIST_FOREACH(twait_block, chain, sctp_nxt_tagblock) {\n\t\t\t\tif (prev_twait_block) {\n\t\t\t\t\tSCTP_FREE(prev_twait_block, SCTP_M_TIMW);\n\t\t\t\t}\n\t\t\t\tprev_twait_block = twait_block;\n\t\t\t}\n\t\t\tSCTP_FREE(prev_twait_block, SCTP_M_TIMW);\n\t\t}\n\t}\n\n\t/* free the locks and mutexes */\n#if defined(__APPLE__)\n\tSCTP_TIMERQ_LOCK_DESTROY();\n\tSCTP_TIMERWAIT_LOCK_DESTROY();\n#endif\n#ifdef SCTP_PACKET_LOGGING\n\tSCTP_IP_PKTLOG_DESTROY();\n#endif\n\tSCTP_IPI_ADDR_DESTROY();\n#if defined(__APPLE__)\n\tSCTP_IPI_COUNT_DESTROY();\n#endif\n\tSCTP_STATLOG_DESTROY();\n\tSCTP_INP_INFO_LOCK_DESTROY();\n\n\tSCTP_WQ_ADDR_DESTROY();\n\n#if defined(__APPLE__)\n#if defined(APPLE_LEOPARD) || defined(APPLE_SNOWLEOPARD) || defined(APPLE_LION) || defined(APPLE_MOUNTAINLION)\n\tlck_grp_attr_free(SCTP_BASE_INFO(sctbinfo).mtx_grp_attr);\n\tlck_grp_free(SCTP_BASE_INFO(sctbinfo).mtx_grp);\n\tlck_attr_free(SCTP_BASE_INFO(sctbinfo).mtx_attr);\n#else\n\tlck_grp_attr_free(SCTP_BASE_INFO(sctbinfo).ipi_lock_grp_attr);\n\tlck_grp_free(SCTP_BASE_INFO(sctbinfo).ipi_lock_grp);\n\tlck_attr_free(SCTP_BASE_INFO(sctbinfo).ipi_lock_attr);\n#endif\n#endif\n#if defined(__Userspace__)\n\tSCTP_TIMERQ_LOCK_DESTROY();\n\tSCTP_TIMERWAIT_LOCK_DESTROY();\n\tSCTP_ZONE_DESTROY(zone_mbuf);\n\tSCTP_ZONE_DESTROY(zone_clust);\n\tSCTP_ZONE_DESTROY(zone_ext_refcnt);\n#endif\n\t/* Get rid of other stuff too. */\n\tif (SCTP_BASE_INFO(sctp_asochash) != NULL)\n\t\tSCTP_HASH_FREE(SCTP_BASE_INFO(sctp_asochash), SCTP_BASE_INFO(hashasocmark));\n\tif (SCTP_BASE_INFO(sctp_ephash) != NULL)\n\t\tSCTP_HASH_FREE(SCTP_BASE_INFO(sctp_ephash), SCTP_BASE_INFO(hashmark));\n\tif (SCTP_BASE_INFO(sctp_tcpephash) != NULL)\n\t\tSCTP_HASH_FREE(SCTP_BASE_INFO(sctp_tcpephash), SCTP_BASE_INFO(hashtcpmark));\n\n#if defined(__Windows__) || defined(__FreeBSD__) || defined(__Userspace__)\n\tSCTP_ZONE_DESTROY(SCTP_BASE_INFO(ipi_zone_ep));\n\tSCTP_ZONE_DESTROY(SCTP_BASE_INFO(ipi_zone_asoc));\n\tSCTP_ZONE_DESTROY(SCTP_BASE_INFO(ipi_zone_laddr));\n\tSCTP_ZONE_DESTROY(SCTP_BASE_INFO(ipi_zone_net));\n\tSCTP_ZONE_DESTROY(SCTP_BASE_INFO(ipi_zone_chunk));\n\tSCTP_ZONE_DESTROY(SCTP_BASE_INFO(ipi_zone_readq));\n\tSCTP_ZONE_DESTROY(SCTP_BASE_INFO(ipi_zone_strmoq));\n\tSCTP_ZONE_DESTROY(SCTP_BASE_INFO(ipi_zone_asconf));\n\tSCTP_ZONE_DESTROY(SCTP_BASE_INFO(ipi_zone_asconf_ack));\n#endif\n#if defined(__FreeBSD__) && defined(SMP) && defined(SCTP_USE_PERCPU_STAT)\n\tSCTP_FREE(SCTP_BASE_STATS, SCTP_M_MCORE);\n#endif\n}\n\n\nint\nsctp_load_addresses_from_init(struct sctp_tcb *stcb, struct mbuf *m,\n                              int offset, int limit,\n                              struct sockaddr *src, struct sockaddr *dst,\n                              struct sockaddr *altsa, uint16_t port)\n{\n\t/*\n\t * grub through the INIT pulling addresses and loading them to the\n\t * nets structure in the asoc. The from address in the mbuf should\n\t * also be loaded (if it is not already). This routine can be called\n\t * with either INIT or INIT-ACK's as long as the m points to the IP\n\t * packet and the offset points to the beginning of the parameters.\n\t */\n\tstruct sctp_inpcb *inp;\n\tstruct sctp_nets *net, *nnet, *net_tmp;\n\tstruct sctp_paramhdr *phdr, param_buf;\n\tstruct sctp_tcb *stcb_tmp;\n\tuint16_t ptype, plen;\n\tstruct sockaddr *sa;\n\tuint8_t random_store[SCTP_PARAM_BUFFER_SIZE];\n\tstruct sctp_auth_random *p_random = NULL;\n\tuint16_t random_len = 0;\n\tuint8_t hmacs_store[SCTP_PARAM_BUFFER_SIZE];\n\tstruct sctp_auth_hmac_algo *hmacs = NULL;\n\tuint16_t hmacs_len = 0;\n\tuint8_t saw_asconf = 0;\n\tuint8_t saw_asconf_ack = 0;\n\tuint8_t chunks_store[SCTP_PARAM_BUFFER_SIZE];\n\tstruct sctp_auth_chunk_list *chunks = NULL;\n\tuint16_t num_chunks = 0;\n\tsctp_key_t *new_key;\n\tuint32_t keylen;\n\tint got_random = 0, got_hmacs = 0, got_chklist = 0;\n\tuint8_t peer_supports_ecn;\n\tuint8_t peer_supports_prsctp;\n\tuint8_t peer_supports_auth;\n\tuint8_t peer_supports_asconf;\n\tuint8_t peer_supports_asconf_ack;\n\tuint8_t peer_supports_reconfig;\n\tuint8_t peer_supports_nrsack;\n\tuint8_t peer_supports_pktdrop;\n\tuint8_t peer_supports_idata;\n#ifdef INET\n\tstruct sockaddr_in sin;\n#endif\n#ifdef INET6\n\tstruct sockaddr_in6 sin6;\n#endif\n\n\t/* First get the destination address setup too. */\n#ifdef INET\n\tmemset(&sin, 0, sizeof(sin));\n\tsin.sin_family = AF_INET;\n#ifdef HAVE_SIN_LEN\n\tsin.sin_len = sizeof(sin);\n#endif\n\tsin.sin_port = stcb->rport;\n#endif\n#ifdef INET6\n\tmemset(&sin6, 0, sizeof(sin6));\n\tsin6.sin6_family = AF_INET6;\n#ifdef HAVE_SIN6_LEN\n\tsin6.sin6_len = sizeof(struct sockaddr_in6);\n#endif\n\tsin6.sin6_port = stcb->rport;\n#endif\n\tif (altsa) {\n\t\tsa = altsa;\n\t} else {\n\t\tsa = src;\n\t}\n\tpeer_supports_idata = 0;\n\tpeer_supports_ecn = 0;\n\tpeer_supports_prsctp = 0;\n\tpeer_supports_auth = 0;\n\tpeer_supports_asconf = 0;\n\tpeer_supports_reconfig = 0;\n\tpeer_supports_nrsack = 0;\n\tpeer_supports_pktdrop = 0;\n\tTAILQ_FOREACH(net, &stcb->asoc.nets, sctp_next) {\n\t\t/* mark all addresses that we have currently on the list */\n\t\tnet->dest_state |= SCTP_ADDR_NOT_IN_ASSOC;\n\t}\n\t/* does the source address already exist? if so skip it */\n\tinp = stcb->sctp_ep;\n\tatomic_add_int(&stcb->asoc.refcnt, 1);\n\tstcb_tmp = sctp_findassociation_ep_addr(&inp, sa, &net_tmp, dst, stcb);\n\tatomic_add_int(&stcb->asoc.refcnt, -1);\n\n\tif ((stcb_tmp == NULL && inp == stcb->sctp_ep) || inp == NULL) {\n\t\t/* we must add the source address */\n\t\t/* no scope set here since we have a tcb already. */\n\t\tswitch (sa->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tif (stcb->asoc.scope.ipv4_addr_legal) {\n\t\t\t\tif (sctp_add_remote_addr(stcb, sa, NULL, port, SCTP_DONOT_SETSCOPE, SCTP_LOAD_ADDR_2)) {\n\t\t\t\t\treturn (-1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n#endif\n#ifdef INET6\n\t\tcase AF_INET6:\n\t\t\tif (stcb->asoc.scope.ipv6_addr_legal) {\n\t\t\t\tif (sctp_add_remote_addr(stcb, sa, NULL, port, SCTP_DONOT_SETSCOPE, SCTP_LOAD_ADDR_3)) {\n\t\t\t\t\treturn (-2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n#endif\n#if defined(__Userspace__)\n\t\tcase AF_CONN:\n\t\t\tif (stcb->asoc.scope.conn_addr_legal) {\n\t\t\t\tif (sctp_add_remote_addr(stcb, sa, NULL, port, SCTP_DONOT_SETSCOPE, SCTP_LOAD_ADDR_3)) {\n\t\t\t\t\treturn (-2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tif (net_tmp != NULL && stcb_tmp == stcb) {\n\t\t\tnet_tmp->dest_state &= ~SCTP_ADDR_NOT_IN_ASSOC;\n\t\t} else if (stcb_tmp != stcb) {\n\t\t\t/* It belongs to another association? */\n\t\t\tif (stcb_tmp)\n\t\t\t\tSCTP_TCB_UNLOCK(stcb_tmp);\n\t\t\treturn (-3);\n\t\t}\n\t}\n\tif (stcb->asoc.state == 0) {\n\t\t/* the assoc was freed? */\n\t\treturn (-4);\n\t}\n\t/* now we must go through each of the params. */\n\tphdr = sctp_get_next_param(m, offset, &param_buf, sizeof(param_buf));\n\twhile (phdr) {\n\t\tptype = ntohs(phdr->param_type);\n\t\tplen = ntohs(phdr->param_length);\n\t\t/*\n\t\t * SCTP_PRINTF(\"ptype => %0x, plen => %d\\n\", (uint32_t)ptype,\n\t\t * (int)plen);\n\t\t */\n\t\tif (offset + plen > limit) {\n\t\t\tbreak;\n\t\t}\n\t\tif (plen == 0) {\n\t\t\tbreak;\n\t\t}\n#ifdef INET\n\t\tif (ptype == SCTP_IPV4_ADDRESS) {\n\t\t\tif (stcb->asoc.scope.ipv4_addr_legal) {\n\t\t\t\tstruct sctp_ipv4addr_param *p4, p4_buf;\n\n\t\t\t\t/* ok get the v4 address and check/add */\n\t\t\t\tphdr = sctp_get_next_param(m, offset,\n\t\t\t\t\t\t\t   (struct sctp_paramhdr *)&p4_buf,\n\t\t\t\t\t\t\t   sizeof(p4_buf));\n\t\t\t\tif (plen != sizeof(struct sctp_ipv4addr_param) ||\n\t\t\t\t    phdr == NULL) {\n\t\t\t\t\treturn (-5);\n\t\t\t\t}\n\t\t\t\tp4 = (struct sctp_ipv4addr_param *)phdr;\n\t\t\t\tsin.sin_addr.s_addr = p4->addr;\n\t\t\t\tif (IN_MULTICAST(ntohl(sin.sin_addr.s_addr))) {\n\t\t\t\t\t/* Skip multi-cast addresses */\n\t\t\t\t\tgoto next_param;\n\t\t\t\t}\n\t\t\t\tif ((sin.sin_addr.s_addr == INADDR_BROADCAST) ||\n\t\t\t\t    (sin.sin_addr.s_addr == INADDR_ANY)) {\n\t\t\t\t\tgoto next_param;\n\t\t\t\t}\n\t\t\t\tsa = (struct sockaddr *)&sin;\n\t\t\t\tinp = stcb->sctp_ep;\n\t\t\t\tatomic_add_int(&stcb->asoc.refcnt, 1);\n\t\t\t\tstcb_tmp = sctp_findassociation_ep_addr(&inp, sa, &net,\n\t\t\t\t\t\t\t\t\tdst, stcb);\n\t\t\t\tatomic_add_int(&stcb->asoc.refcnt, -1);\n\n\t\t\t\tif ((stcb_tmp == NULL && inp == stcb->sctp_ep) ||\n\t\t\t\t    inp == NULL) {\n\t\t\t\t\t/* we must add the source address */\n\t\t\t\t\t/*\n\t\t\t\t\t * no scope set since we have a tcb\n\t\t\t\t\t * already\n\t\t\t\t\t */\n\n\t\t\t\t\t/*\n\t\t\t\t\t * we must validate the state again\n\t\t\t\t\t * here\n\t\t\t\t\t */\n\t\t\t\tadd_it_now:\n\t\t\t\t\tif (stcb->asoc.state == 0) {\n\t\t\t\t\t\t/* the assoc was freed? */\n\t\t\t\t\t\treturn (-7);\n\t\t\t\t\t}\n\t\t\t\t\tif (sctp_add_remote_addr(stcb, sa, NULL, port, SCTP_DONOT_SETSCOPE, SCTP_LOAD_ADDR_4)) {\n\t\t\t\t\t\treturn (-8);\n\t\t\t\t\t}\n\t\t\t\t} else if (stcb_tmp == stcb) {\n\t\t\t\t\tif (stcb->asoc.state == 0) {\n\t\t\t\t\t\t/* the assoc was freed? */\n\t\t\t\t\t\treturn (-10);\n\t\t\t\t\t}\n\t\t\t\t\tif (net != NULL) {\n\t\t\t\t\t\t/* clear flag */\n\t\t\t\t\t\tnet->dest_state &=\n\t\t\t\t\t\t\t~SCTP_ADDR_NOT_IN_ASSOC;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t * strange, address is in another\n\t\t\t\t\t * assoc? straighten out locks.\n\t\t\t\t\t */\n\t\t\t\t\tif (stcb_tmp) {\n\t\t\t\t\t\tif (SCTP_GET_STATE(stcb_tmp) == SCTP_STATE_COOKIE_WAIT) {\n\t\t\t\t\t\t\tstruct mbuf *op_err;\n\t\t\t\t\t\t\tchar msg[SCTP_DIAG_INFO_LEN];\n\n\t\t\t\t\t\t\t/* in setup state we abort this guy */\n\t\t\t\t\t\t\tsnprintf(msg, sizeof(msg),\n\t\t\t\t\t\t\t         \"%s:%d at %s\", __FILE__, __LINE__, __func__);\n\t\t\t\t\t\t\top_err = sctp_generate_cause(SCTP_BASE_SYSCTL(sctp_diag_info_code),\n\t\t\t\t\t\t\t         msg);\n\t\t\t\t\t\t\tsctp_abort_an_association(stcb_tmp->sctp_ep,\n\t\t\t\t\t\t\t\t\t\t  stcb_tmp, op_err,\n\t\t\t\t\t\t\t                          SCTP_SO_NOT_LOCKED);\n\t\t\t\t\t\t\tgoto add_it_now;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tSCTP_TCB_UNLOCK(stcb_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (stcb->asoc.state == 0) {\n\t\t\t\t\t\t/* the assoc was freed? */\n\t\t\t\t\t\treturn (-12);\n\t\t\t\t\t}\n\t\t\t\t\treturn (-13);\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n#endif\n#ifdef INET6\n\t\tif (ptype == SCTP_IPV6_ADDRESS) {\n\t\t\tif (stcb->asoc.scope.ipv6_addr_legal) {\n\t\t\t\t/* ok get the v6 address and check/add */\n\t\t\t\tstruct sctp_ipv6addr_param *p6, p6_buf;\n\n\t\t\t\tphdr = sctp_get_next_param(m, offset,\n\t\t\t\t\t\t\t   (struct sctp_paramhdr *)&p6_buf,\n\t\t\t\t\t\t\t   sizeof(p6_buf));\n\t\t\t\tif (plen != sizeof(struct sctp_ipv6addr_param) ||\n\t\t\t\t    phdr == NULL) {\n\t\t\t\t\treturn (-14);\n\t\t\t\t}\n\t\t\t\tp6 = (struct sctp_ipv6addr_param *)phdr;\n\t\t\t\tmemcpy((caddr_t)&sin6.sin6_addr, p6->addr,\n\t\t\t\t       sizeof(p6->addr));\n\t\t\t\tif (IN6_IS_ADDR_MULTICAST(&sin6.sin6_addr)) {\n\t\t\t\t\t/* Skip multi-cast addresses */\n\t\t\t\t\tgoto next_param;\n\t\t\t\t}\n\t\t\t\tif (IN6_IS_ADDR_LINKLOCAL(&sin6.sin6_addr)) {\n\t\t\t\t\t/* Link local make no sense without scope */\n\t\t\t\t\tgoto next_param;\n\t\t\t\t}\n\t\t\t\tsa = (struct sockaddr *)&sin6;\n\t\t\t\tinp = stcb->sctp_ep;\n\t\t\t\tatomic_add_int(&stcb->asoc.refcnt, 1);\n\t\t\t\tstcb_tmp = sctp_findassociation_ep_addr(&inp, sa, &net,\n\t\t\t\t\t\t\t\t\tdst, stcb);\n\t\t\t\tatomic_add_int(&stcb->asoc.refcnt, -1);\n\t\t\t\tif (stcb_tmp == NULL &&\n\t\t\t\t    (inp == stcb->sctp_ep || inp == NULL)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * we must validate the state again\n\t\t\t\t\t * here\n\t\t\t\t\t */\n\t\t\t\tadd_it_now6:\n\t\t\t\t\tif (stcb->asoc.state == 0) {\n\t\t\t\t\t\t/* the assoc was freed? */\n\t\t\t\t\t\treturn (-16);\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * we must add the address, no scope\n\t\t\t\t\t * set\n\t\t\t\t\t */\n\t\t\t\t\tif (sctp_add_remote_addr(stcb, sa, NULL, port, SCTP_DONOT_SETSCOPE, SCTP_LOAD_ADDR_5)) {\n\t\t\t\t\t\treturn (-17);\n\t\t\t\t\t}\n\t\t\t\t} else if (stcb_tmp == stcb) {\n\t\t\t\t\t/*\n\t\t\t\t\t * we must validate the state again\n\t\t\t\t\t * here\n\t\t\t\t\t */\n\t\t\t\t\tif (stcb->asoc.state == 0) {\n\t\t\t\t\t\t/* the assoc was freed? */\n\t\t\t\t\t\treturn (-19);\n\t\t\t\t\t}\n\t\t\t\t\tif (net != NULL) {\n\t\t\t\t\t\t/* clear flag */\n\t\t\t\t\t\tnet->dest_state &=\n\t\t\t\t\t\t\t~SCTP_ADDR_NOT_IN_ASSOC;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t * strange, address is in another\n\t\t\t\t\t * assoc? straighten out locks.\n\t\t\t\t\t */\n\t\t\t\t\tif (stcb_tmp) {\n\t\t\t\t\t\tif (SCTP_GET_STATE(stcb_tmp) == SCTP_STATE_COOKIE_WAIT) {\n\t\t\t\t\t\t\tstruct mbuf *op_err;\n\t\t\t\t\t\t\tchar msg[SCTP_DIAG_INFO_LEN];\n\n\t\t\t\t\t\t\t/* in setup state we abort this guy */\n\t\t\t\t\t\t\tsnprintf(msg, sizeof(msg),\n\t\t\t\t\t\t\t         \"%s:%d at %s\", __FILE__, __LINE__, __func__);\n\t\t\t\t\t\t\top_err = sctp_generate_cause(SCTP_BASE_SYSCTL(sctp_diag_info_code),\n\t\t\t\t\t\t\t         msg);\n\t\t\t\t\t\t\tsctp_abort_an_association(stcb_tmp->sctp_ep,\n\t\t\t\t\t\t\t\t\t\t  stcb_tmp, op_err,\n\t\t\t\t\t\t\t                          SCTP_SO_NOT_LOCKED);\n\t\t\t\t\t\t\tgoto add_it_now6;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tSCTP_TCB_UNLOCK(stcb_tmp);\n\t\t\t\t\t}\n\t\t\t\t\tif (stcb->asoc.state == 0) {\n\t\t\t\t\t\t/* the assoc was freed? */\n\t\t\t\t\t\treturn (-21);\n\t\t\t\t\t}\n\t\t\t\t\treturn (-22);\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n#endif\n\t\tif (ptype == SCTP_ECN_CAPABLE) {\n\t\t\tpeer_supports_ecn = 1;\n\t\t} else if (ptype == SCTP_ULP_ADAPTATION) {\n\t\t\tif (stcb->asoc.state != SCTP_STATE_OPEN) {\n\t\t\t\tstruct sctp_adaptation_layer_indication ai, *aip;\n\n\t\t\t\tphdr = sctp_get_next_param(m, offset,\n\t\t\t\t\t\t\t   (struct sctp_paramhdr *)&ai, sizeof(ai));\n\t\t\t\taip = (struct sctp_adaptation_layer_indication *)phdr;\n\t\t\t\tif (aip) {\n\t\t\t\t\tstcb->asoc.peers_adaptation = ntohl(aip->indication);\n\t\t\t\t\tstcb->asoc.adaptation_needed = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (ptype == SCTP_SET_PRIM_ADDR) {\n\t\t\tstruct sctp_asconf_addr_param lstore, *fee;\n\t\t\tint lptype;\n\t\t\tstruct sockaddr *lsa = NULL;\n#ifdef INET\n\t\t\tstruct sctp_asconf_addrv4_param *fii;\n#endif\n\n\t\t\tif (stcb->asoc.asconf_supported == 0) {\n\t\t\t\treturn (-100);\n\t\t\t}\n\t\t\tif (plen > sizeof(lstore)) {\n\t\t\t\treturn (-23);\n\t\t\t}\n\t\t\tphdr = sctp_get_next_param(m, offset,\n\t\t\t\t\t\t   (struct sctp_paramhdr *)&lstore,\n\t\t\t\t\t\t   plen);\n\t\t\tif (phdr == NULL) {\n\t\t\t\treturn (-24);\n\t\t\t}\n\t\t\tfee = (struct sctp_asconf_addr_param *)phdr;\n\t\t\tlptype = ntohs(fee->addrp.ph.param_type);\n\t\t\tswitch (lptype) {\n#ifdef INET\n\t\t\tcase SCTP_IPV4_ADDRESS:\n\t\t\t\tif (plen !=\n\t\t\t\t    sizeof(struct sctp_asconf_addrv4_param)) {\n\t\t\t\t\tSCTP_PRINTF(\"Sizeof setprim in init/init ack not %d but %d - ignored\\n\",\n\t\t\t\t\t\t    (int)sizeof(struct sctp_asconf_addrv4_param),\n\t\t\t\t\t\t    plen);\n\t\t\t\t} else {\n\t\t\t\t\tfii = (struct sctp_asconf_addrv4_param *)fee;\n\t\t\t\t\tsin.sin_addr.s_addr = fii->addrp.addr;\n\t\t\t\t\tlsa = (struct sockaddr *)&sin;\n\t\t\t\t}\n\t\t\t\tbreak;\n#endif\n#ifdef INET6\n\t\t\tcase SCTP_IPV6_ADDRESS:\n\t\t\t\tif (plen !=\n\t\t\t\t    sizeof(struct sctp_asconf_addr_param)) {\n\t\t\t\t\tSCTP_PRINTF(\"Sizeof setprim (v6) in init/init ack not %d but %d - ignored\\n\",\n\t\t\t\t\t\t    (int)sizeof(struct sctp_asconf_addr_param),\n\t\t\t\t\t\t    plen);\n\t\t\t\t} else {\n\t\t\t\t\tmemcpy(sin6.sin6_addr.s6_addr,\n\t\t\t\t\t       fee->addrp.addr,\n\t\t\t\t\t       sizeof(fee->addrp.addr));\n\t\t\t\t\tlsa = (struct sockaddr *)&sin6;\n\t\t\t\t}\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (lsa) {\n\t\t\t\t(void)sctp_set_primary_addr(stcb, sa, NULL);\n\t\t\t}\n\t\t} else if (ptype == SCTP_HAS_NAT_SUPPORT) {\n\t\t\tstcb->asoc.peer_supports_nat = 1;\n\t\t} else if (ptype == SCTP_PRSCTP_SUPPORTED) {\n\t\t\t/* Peer supports pr-sctp */\n\t\t\tpeer_supports_prsctp = 1;\n\t\t} else if (ptype == SCTP_SUPPORTED_CHUNK_EXT) {\n\t\t\t/* A supported extension chunk */\n\t\t\tstruct sctp_supported_chunk_types_param *pr_supported;\n\t\t\tuint8_t local_store[SCTP_PARAM_BUFFER_SIZE];\n\t\t\tint num_ent, i;\n\n\t\t\tif (plen > sizeof(local_store)) {\n\t\t\t\treturn (-35);\n\t\t\t}\n\t\t\tphdr = sctp_get_next_param(m, offset,\n\t\t\t\t\t\t   (struct sctp_paramhdr *)&local_store, plen);\n\t\t\tif (phdr == NULL) {\n\t\t\t\treturn (-25);\n\t\t\t}\n\t\t\tpr_supported = (struct sctp_supported_chunk_types_param *)phdr;\n\t\t\tnum_ent = plen - sizeof(struct sctp_paramhdr);\n\t\t\tfor (i = 0; i < num_ent; i++) {\n\t\t\t\tswitch (pr_supported->chunk_types[i]) {\n\t\t\t\tcase SCTP_ASCONF:\n\t\t\t\t\tpeer_supports_asconf = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SCTP_ASCONF_ACK:\n\t\t\t\t\tpeer_supports_asconf_ack = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SCTP_FORWARD_CUM_TSN:\n\t\t\t\t\tpeer_supports_prsctp = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SCTP_PACKET_DROPPED:\n\t\t\t\t\tpeer_supports_pktdrop = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SCTP_NR_SELECTIVE_ACK:\n\t\t\t\t\tpeer_supports_nrsack = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SCTP_STREAM_RESET:\n\t\t\t\t\tpeer_supports_reconfig = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SCTP_AUTHENTICATION:\n\t\t\t\t\tpeer_supports_auth = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SCTP_IDATA:\n\t\t\t\t\tpeer_supports_idata = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t/* one I have not learned yet */\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (ptype == SCTP_RANDOM) {\n\t\t\tif (plen > sizeof(random_store))\n\t\t\t\tbreak;\n\t\t\tif (got_random) {\n\t\t\t\t/* already processed a RANDOM */\n\t\t\t\tgoto next_param;\n\t\t\t}\n\t\t\tphdr = sctp_get_next_param(m, offset,\n\t\t\t\t\t\t   (struct sctp_paramhdr *)random_store,\n\t\t\t\t\t\t   plen);\n\t\t\tif (phdr == NULL)\n\t\t\t\treturn (-26);\n\t\t\tp_random = (struct sctp_auth_random *)phdr;\n\t\t\trandom_len = plen - sizeof(*p_random);\n\t\t\t/* enforce the random length */\n\t\t\tif (random_len != SCTP_AUTH_RANDOM_SIZE_REQUIRED) {\n\t\t\t\tSCTPDBG(SCTP_DEBUG_AUTH1, \"SCTP: invalid RANDOM len\\n\");\n\t\t\t\treturn (-27);\n\t\t\t}\n\t\t\tgot_random = 1;\n\t\t} else if (ptype == SCTP_HMAC_LIST) {\n\t\t\tuint16_t num_hmacs;\n\t\t\tuint16_t i;\n\n\t\t\tif (plen > sizeof(hmacs_store))\n\t\t\t\tbreak;\n\t\t\tif (got_hmacs) {\n\t\t\t\t/* already processed a HMAC list */\n\t\t\t\tgoto next_param;\n\t\t\t}\n\t\t\tphdr = sctp_get_next_param(m, offset,\n\t\t\t\t\t\t   (struct sctp_paramhdr *)hmacs_store,\n\t\t\t\t\t\t   plen);\n\t\t\tif (phdr == NULL)\n\t\t\t\treturn (-28);\n\t\t\thmacs = (struct sctp_auth_hmac_algo *)phdr;\n\t\t\thmacs_len = plen - sizeof(*hmacs);\n\t\t\tnum_hmacs = hmacs_len / sizeof(hmacs->hmac_ids[0]);\n\t\t\t/* validate the hmac list */\n\t\t\tif (sctp_verify_hmac_param(hmacs, num_hmacs)) {\n\t\t\t\treturn (-29);\n\t\t\t}\n\t\t\tif (stcb->asoc.peer_hmacs != NULL)\n\t\t\t\tsctp_free_hmaclist(stcb->asoc.peer_hmacs);\n\t\t\tstcb->asoc.peer_hmacs = sctp_alloc_hmaclist(num_hmacs);\n\t\t\tif (stcb->asoc.peer_hmacs != NULL) {\n\t\t\t\tfor (i = 0; i < num_hmacs; i++) {\n\t\t\t\t\t(void)sctp_auth_add_hmacid(stcb->asoc.peer_hmacs,\n\t\t\t\t\t\t\t\t   ntohs(hmacs->hmac_ids[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tgot_hmacs = 1;\n\t\t} else if (ptype == SCTP_CHUNK_LIST) {\n\t\t\tint i;\n\n\t\t\tif (plen > sizeof(chunks_store))\n\t\t\t\tbreak;\n\t\t\tif (got_chklist) {\n\t\t\t\t/* already processed a Chunks list */\n\t\t\t\tgoto next_param;\n\t\t\t}\n\t\t\tphdr = sctp_get_next_param(m, offset,\n\t\t\t\t\t\t   (struct sctp_paramhdr *)chunks_store,\n\t\t\t\t\t\t   plen);\n\t\t\tif (phdr == NULL)\n\t\t\t\treturn (-30);\n\t\t\tchunks = (struct sctp_auth_chunk_list *)phdr;\n\t\t\tnum_chunks = plen - sizeof(*chunks);\n\t\t\tif (stcb->asoc.peer_auth_chunks != NULL)\n\t\t\t\tsctp_clear_chunklist(stcb->asoc.peer_auth_chunks);\n\t\t\telse\n\t\t\t\tstcb->asoc.peer_auth_chunks = sctp_alloc_chunklist();\n\t\t\tfor (i = 0; i < num_chunks; i++) {\n\t\t\t\t(void)sctp_auth_add_chunk(chunks->chunk_types[i],\n\t\t\t\t\t\t\t  stcb->asoc.peer_auth_chunks);\n\t\t\t\t/* record asconf/asconf-ack if listed */\n\t\t\t\tif (chunks->chunk_types[i] == SCTP_ASCONF)\n\t\t\t\t\tsaw_asconf = 1;\n\t\t\t\tif (chunks->chunk_types[i] == SCTP_ASCONF_ACK)\n\t\t\t\t\tsaw_asconf_ack = 1;\n\n\t\t\t}\n\t\t\tgot_chklist = 1;\n\t\t} else if ((ptype == SCTP_HEARTBEAT_INFO) ||\n\t\t\t   (ptype == SCTP_STATE_COOKIE) ||\n\t\t\t   (ptype == SCTP_UNRECOG_PARAM) ||\n\t\t\t   (ptype == SCTP_COOKIE_PRESERVE) ||\n\t\t\t   (ptype == SCTP_SUPPORTED_ADDRTYPE) ||\n\t\t\t   (ptype == SCTP_ADD_IP_ADDRESS) ||\n\t\t\t   (ptype == SCTP_DEL_IP_ADDRESS) ||\n\t\t\t   (ptype == SCTP_ERROR_CAUSE_IND) ||\n\t\t\t   (ptype == SCTP_SUCCESS_REPORT)) {\n\t\t\t/* don't care */ ;\n\t\t} else {\n\t\t\tif ((ptype & 0x8000) == 0x0000) {\n\t\t\t\t/*\n\t\t\t\t * must stop processing the rest of the\n\t\t\t\t * param's. Any report bits were handled\n\t\t\t\t * with the call to\n\t\t\t\t * sctp_arethere_unrecognized_parameters()\n\t\t\t\t * when the INIT or INIT-ACK was first seen.\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\tnext_param:\n\t\toffset += SCTP_SIZE32(plen);\n\t\tif (offset >= limit) {\n\t\t\tbreak;\n\t\t}\n\t\tphdr = sctp_get_next_param(m, offset, &param_buf,\n\t\t\t\t\t   sizeof(param_buf));\n\t}\n\t/* Now check to see if we need to purge any addresses */\n\tTAILQ_FOREACH_SAFE(net, &stcb->asoc.nets, sctp_next, nnet) {\n\t\tif ((net->dest_state & SCTP_ADDR_NOT_IN_ASSOC) ==\n\t\t    SCTP_ADDR_NOT_IN_ASSOC) {\n\t\t\t/* This address has been removed from the asoc */\n\t\t\t/* remove and free it */\n\t\t\tstcb->asoc.numnets--;\n\t\t\tTAILQ_REMOVE(&stcb->asoc.nets, net, sctp_next);\n\t\t\tsctp_free_remote_addr(net);\n\t\t\tif (net == stcb->asoc.primary_destination) {\n\t\t\t\tstcb->asoc.primary_destination = NULL;\n\t\t\t\tsctp_select_primary_destination(stcb);\n\t\t\t}\n\t\t}\n\t}\n\tif ((stcb->asoc.ecn_supported == 1) &&\n\t    (peer_supports_ecn == 0)) {\n\t\tstcb->asoc.ecn_supported = 0;\n\t}\n\tif ((stcb->asoc.prsctp_supported == 1) &&\n\t    (peer_supports_prsctp == 0)) {\n\t\tstcb->asoc.prsctp_supported = 0;\n\t}\n\tif ((stcb->asoc.auth_supported == 1) &&\n\t    ((peer_supports_auth == 0) ||\n\t     (got_random == 0) || (got_hmacs == 0))) {\n\t\tstcb->asoc.auth_supported = 0;\n\t}\n\tif ((stcb->asoc.asconf_supported == 1) &&\n\t    ((peer_supports_asconf == 0) || (peer_supports_asconf_ack == 0) ||\n\t     (stcb->asoc.auth_supported == 0) ||\n\t     (saw_asconf == 0) || (saw_asconf_ack == 0))) {\n\t\tstcb->asoc.asconf_supported = 0;\n\t}\n\tif ((stcb->asoc.reconfig_supported == 1) &&\n\t    (peer_supports_reconfig == 0)) {\n\t\tstcb->asoc.reconfig_supported = 0;\n\t}\n\tif ((stcb->asoc.idata_supported == 1) &&\n\t    (peer_supports_idata == 0)) {\n\t\tstcb->asoc.idata_supported = 0;\n\t}\n\tif ((stcb->asoc.nrsack_supported == 1) &&\n\t    (peer_supports_nrsack == 0)) {\n\t\tstcb->asoc.nrsack_supported = 0;\n\t}\n\tif ((stcb->asoc.pktdrop_supported == 1) &&\n\t    (peer_supports_pktdrop == 0)){\n\t\tstcb->asoc.pktdrop_supported = 0;\n\t}\n\t/* validate authentication required parameters */\n\tif ((peer_supports_auth == 0) && (got_chklist == 1)) {\n\t\t/* peer does not support auth but sent a chunks list? */\n\t\treturn (-31);\n\t}\n\tif ((peer_supports_asconf == 1) && (peer_supports_auth == 0)) {\n\t\t/* peer supports asconf but not auth? */\n\t\treturn (-32);\n\t} else if ((peer_supports_asconf == 1) &&\n\t           (peer_supports_auth == 1) &&\n\t\t   ((saw_asconf == 0) || (saw_asconf_ack == 0))) {\n\t\treturn (-33);\n\t}\n\t/* concatenate the full random key */\n\tkeylen = sizeof(*p_random) + random_len + sizeof(*hmacs) + hmacs_len;\n\tif (chunks != NULL) {\n\t\tkeylen += sizeof(*chunks) + num_chunks;\n\t}\n\tnew_key = sctp_alloc_key(keylen);\n\tif (new_key != NULL) {\n\t\t/* copy in the RANDOM */\n\t\tif (p_random != NULL) {\n\t\t\tkeylen = sizeof(*p_random) + random_len;\n\t\t\tmemcpy(new_key->key, p_random, keylen);\n\t\t} else {\n\t\t\tkeylen = 0;\n\t\t}\n\t\t/* append in the AUTH chunks */\n\t\tif (chunks != NULL) {\n\t\t\tmemcpy(new_key->key + keylen, chunks,\n\t\t\t       sizeof(*chunks) + num_chunks);\n\t\t\tkeylen += sizeof(*chunks) + num_chunks;\n\t\t}\n\t\t/* append in the HMACs */\n\t\tif (hmacs != NULL) {\n\t\t\tmemcpy(new_key->key + keylen, hmacs,\n\t\t\t       sizeof(*hmacs) + hmacs_len);\n\t\t}\n\t} else {\n\t\t/* failed to get memory for the key */\n\t\treturn (-34);\n\t}\n\tif (stcb->asoc.authinfo.peer_random != NULL)\n\t\tsctp_free_key(stcb->asoc.authinfo.peer_random);\n\tstcb->asoc.authinfo.peer_random = new_key;\n\tsctp_clear_cachedkeys(stcb, stcb->asoc.authinfo.assoc_keyid);\n\tsctp_clear_cachedkeys(stcb, stcb->asoc.authinfo.recv_keyid);\n\n\treturn (0);\n}\n\nint\nsctp_set_primary_addr(struct sctp_tcb *stcb, struct sockaddr *sa,\n\t\t      struct sctp_nets *net)\n{\n\t/* make sure the requested primary address exists in the assoc */\n\tif (net == NULL && sa)\n\t\tnet = sctp_findnet(stcb, sa);\n\n\tif (net == NULL) {\n\t\t/* didn't find the requested primary address! */\n\t\treturn (-1);\n\t} else {\n\t\t/* set the primary address */\n\t\tif (net->dest_state & SCTP_ADDR_UNCONFIRMED) {\n\t\t\t/* Must be confirmed, so queue to set */\n\t\t\tnet->dest_state |= SCTP_ADDR_REQ_PRIMARY;\n\t\t\treturn (0);\n\t\t}\n\t\tstcb->asoc.primary_destination = net;\n\t\tif (!(net->dest_state & SCTP_ADDR_PF) && (stcb->asoc.alternate)) {\n\t\t\tsctp_free_remote_addr(stcb->asoc.alternate);\n\t\t\tstcb->asoc.alternate = NULL;\n\t\t}\n\t\tnet = TAILQ_FIRST(&stcb->asoc.nets);\n\t\tif (net != stcb->asoc.primary_destination) {\n\t\t\t/* first one on the list is NOT the primary\n\t\t\t * sctp_cmpaddr() is much more efficient if\n\t\t\t * the primary is the first on the list, make it\n\t\t\t * so.\n\t\t\t */\n\t\t\tTAILQ_REMOVE(&stcb->asoc.nets, stcb->asoc.primary_destination, sctp_next);\n\t\t\tTAILQ_INSERT_HEAD(&stcb->asoc.nets, stcb->asoc.primary_destination, sctp_next);\n\t\t}\n\t\treturn (0);\n\t}\n}\n\nint\nsctp_is_vtag_good(uint32_t tag, uint16_t lport, uint16_t rport, struct timeval *now)\n{\n\t/*\n\t * This function serves two purposes. It will see if a TAG can be\n\t * re-used and return 1 for yes it is ok and 0 for don't use that\n\t * tag. A secondary function it will do is purge out old tags that\n\t * can be removed.\n\t */\n\tstruct sctpvtaghead *chain;\n\tstruct sctp_tagblock *twait_block;\n\tstruct sctpasochead *head;\n\tstruct sctp_tcb *stcb;\n\tint i;\n\n\tSCTP_INP_INFO_RLOCK();\n\thead = &SCTP_BASE_INFO(sctp_asochash)[SCTP_PCBHASH_ASOC(tag,\n\t\t\t\t\t\t\t\tSCTP_BASE_INFO(hashasocmark))];\n\tLIST_FOREACH(stcb, head, sctp_asocs) {\n\t\t/* We choose not to lock anything here. TCB's can't be\n\t\t * removed since we have the read lock, so they can't\n\t\t * be freed on us, same thing for the INP. I may\n\t\t * be wrong with this assumption, but we will go\n\t\t * with it for now :-)\n\t\t */\n\t\tif (stcb->sctp_ep->sctp_flags & SCTP_PCB_FLAGS_SOCKET_ALLGONE) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (stcb->asoc.my_vtag == tag) {\n\t\t\t/* candidate */\n\t\t\tif (stcb->rport != rport) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (stcb->sctp_ep->sctp_lport != lport) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* Its a used tag set */\n\t\t\tSCTP_INP_INFO_RUNLOCK();\n\t\t\treturn (0);\n\t\t}\n\t}\n\tchain = &SCTP_BASE_INFO(vtag_timewait)[(tag % SCTP_STACK_VTAG_HASH_SIZE)];\n\t/* Now what about timed wait ? */\n\tLIST_FOREACH(twait_block, chain, sctp_nxt_tagblock) {\n\t\t/*\n\t\t * Block(s) are present, lets see if we have this tag in the\n\t\t * list\n\t\t */\n\t\tfor (i = 0; i < SCTP_NUMBER_IN_VTAG_BLOCK; i++) {\n\t\t\tif (twait_block->vtag_block[i].v_tag == 0) {\n\t\t\t\t/* not used */\n\t\t\t\tcontinue;\n\t\t\t} else if ((long)twait_block->vtag_block[i].tv_sec_at_expire  <\n\t\t\t\t   now->tv_sec) {\n\t\t\t\t/* Audit expires this guy */\n\t\t\t\ttwait_block->vtag_block[i].tv_sec_at_expire = 0;\n\t\t\t\ttwait_block->vtag_block[i].v_tag = 0;\n\t\t\t\ttwait_block->vtag_block[i].lport = 0;\n\t\t\t\ttwait_block->vtag_block[i].rport = 0;\n\t\t\t} else if ((twait_block->vtag_block[i].v_tag == tag) &&\n\t\t\t\t   (twait_block->vtag_block[i].lport == lport) &&\n\t\t\t\t   (twait_block->vtag_block[i].rport == rport)) {\n\t\t\t\t/* Bad tag, sorry :< */\n\t\t\t\tSCTP_INP_INFO_RUNLOCK();\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t}\n\t}\n\tSCTP_INP_INFO_RUNLOCK();\n\treturn (1);\n}\n\nstatic void\nsctp_drain_mbufs(struct sctp_tcb *stcb)\n{\n\t/*\n\t * We must hunt this association for MBUF's past the cumack (i.e.\n\t * out of order data that we can renege on).\n\t */\n\tstruct sctp_association *asoc;\n\tstruct sctp_tmit_chunk *chk, *nchk;\n\tuint32_t cumulative_tsn_p1;\n\tstruct sctp_queued_to_read *control, *ncontrol;\n\tint cnt, strmat;\n\tuint32_t gap, i;\n\tint fnd = 0;\n\n\t/* We look for anything larger than the cum-ack + 1 */\n\n\tasoc = &stcb->asoc;\n\tif (asoc->cumulative_tsn == asoc->highest_tsn_inside_map) {\n\t\t/* none we can reneg on. */\n\t\treturn;\n\t}\n\tSCTP_STAT_INCR(sctps_protocol_drains_done);\n\tcumulative_tsn_p1 = asoc->cumulative_tsn + 1;\n\tcnt = 0;\n\t/* Ok that was fun, now we will drain all the inbound streams? */\n\tfor (strmat = 0; strmat < asoc->streamincnt; strmat++) {\n\t\tTAILQ_FOREACH_SAFE(control, &asoc->strmin[strmat].inqueue, next_instrm, ncontrol) {\n#ifdef INVARIANTS\n\t\t\tif (control->on_strm_q != SCTP_ON_ORDERED ) {\n\t\t\t\tpanic(\"Huh control: %p on_q: %d -- not ordered?\",\n\t\t\t\t      control, control->on_strm_q);\n\t\t\t}\n#endif\n\t\t\tif (SCTP_TSN_GT(control->sinfo_tsn, cumulative_tsn_p1)) {\n\t\t\t\t/* Yep it is above cum-ack */\n\t\t\t\tcnt++;\n\t\t\t\tSCTP_CALC_TSN_TO_GAP(gap, control->sinfo_tsn, asoc->mapping_array_base_tsn);\n\t\t\t\tKASSERT(control->length > 0, (\"control has zero length\"));\n\t\t\t\tif (asoc->size_on_all_streams >= control->length) {\n\t\t\t\t\tasoc->size_on_all_streams -= control->length;\n\t\t\t\t} else {\n#ifdef INVARIANTS\n\t\t\t\t\tpanic(\"size_on_all_streams = %u smaller than control length %u\", asoc->size_on_all_streams, control->length);\n#else\n\t\t\t\t\tasoc->size_on_all_streams = 0;\n#endif\n\t\t\t\t}\n\t\t\t\tsctp_ucount_decr(asoc->cnt_on_all_streams);\n\t\t\t\tSCTP_UNSET_TSN_PRESENT(asoc->mapping_array, gap);\n\t\t\t\tif (control->on_read_q) {\n\t\t\t\t\tTAILQ_REMOVE(&stcb->sctp_ep->read_queue, control, next);\n\t\t\t\t\tcontrol->on_read_q = 0;\n\t\t\t\t}\n\t\t\t\tTAILQ_REMOVE(&asoc->strmin[strmat].inqueue, control, next_instrm);\n\t\t\t\tcontrol->on_strm_q = 0;\n\t\t\t\tif (control->data) {\n\t\t\t\t\tsctp_m_freem(control->data);\n\t\t\t\t\tcontrol->data = NULL;\n\t\t\t\t}\n\t\t\t\tsctp_free_remote_addr(control->whoFrom);\n\t\t\t\t/* Now its reasm? */\n\t\t\t\tTAILQ_FOREACH_SAFE(chk, &control->reasm, sctp_next, nchk) {\n\t\t\t\t\tcnt++;\n\t\t\t\t\tSCTP_CALC_TSN_TO_GAP(gap, chk->rec.data.tsn, asoc->mapping_array_base_tsn);\n\t\t\t\t\tKASSERT(chk->send_size > 0, (\"chunk has zero length\"));\n\t\t\t\t\tif (asoc->size_on_reasm_queue >= chk->send_size) {\n\t\t\t\t\t\tasoc->size_on_reasm_queue -= chk->send_size;\n\t\t\t\t\t} else {\n#ifdef INVARIANTS\n\t\t\t\t\t\tpanic(\"size_on_reasm_queue = %u smaller than chunk length %u\", asoc->size_on_reasm_queue, chk->send_size);\n#else\n\t\t\t\t\t\tasoc->size_on_reasm_queue = 0;\n#endif\n\t\t\t\t\t}\n\t\t\t\t\tsctp_ucount_decr(asoc->cnt_on_reasm_queue);\n\t\t\t\t\tSCTP_UNSET_TSN_PRESENT(asoc->mapping_array, gap);\n\t\t\t\t\tTAILQ_REMOVE(&control->reasm, chk, sctp_next);\n\t\t\t\t\tif (chk->data) {\n\t\t\t\t\t\tsctp_m_freem(chk->data);\n\t\t\t\t\t\tchk->data = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tsctp_free_a_chunk(stcb, chk, SCTP_SO_NOT_LOCKED);\n\t\t\t\t}\n\t\t\t\tsctp_free_a_readq(stcb, control);\n\t\t\t}\n\t\t}\n\t\tTAILQ_FOREACH_SAFE(control, &asoc->strmin[strmat].uno_inqueue, next_instrm, ncontrol) {\n#ifdef INVARIANTS\n\t\t\tif (control->on_strm_q != SCTP_ON_UNORDERED ) {\n\t\t\t\tpanic(\"Huh control: %p on_q: %d -- not unordered?\",\n\t\t\t\t      control, control->on_strm_q);\n\t\t\t}\n#endif\n\t\t\tif (SCTP_TSN_GT(control->sinfo_tsn, cumulative_tsn_p1)) {\n\t\t\t\t/* Yep it is above cum-ack */\n\t\t\t\tcnt++;\n\t\t\t\tSCTP_CALC_TSN_TO_GAP(gap, control->sinfo_tsn, asoc->mapping_array_base_tsn);\n\t\t\t\tKASSERT(control->length > 0, (\"control has zero length\"));\n\t\t\t\tif (asoc->size_on_all_streams >= control->length) {\n\t\t\t\t\tasoc->size_on_all_streams -= control->length;\n\t\t\t\t} else {\n#ifdef INVARIANTS\n\t\t\t\t\tpanic(\"size_on_all_streams = %u smaller than control length %u\", asoc->size_on_all_streams, control->length);\n#else\n\t\t\t\t\tasoc->size_on_all_streams = 0;\n#endif\n\t\t\t\t}\n\t\t\t\tsctp_ucount_decr(asoc->cnt_on_all_streams);\n\t\t\t\tSCTP_UNSET_TSN_PRESENT(asoc->mapping_array, gap);\n\t\t\t\tif (control->on_read_q) {\n\t\t\t\t\tTAILQ_REMOVE(&stcb->sctp_ep->read_queue, control, next);\n\t\t\t\t\tcontrol->on_read_q = 0;\n\t\t\t\t}\n\t\t\t\tTAILQ_REMOVE(&asoc->strmin[strmat].uno_inqueue, control, next_instrm);\n\t\t\t\tcontrol->on_strm_q = 0;\n\t\t\t\tif (control->data) {\n\t\t\t\t\tsctp_m_freem(control->data);\n\t\t\t\t\tcontrol->data = NULL;\n\t\t\t\t}\n\t\t\t\tsctp_free_remote_addr(control->whoFrom);\n\t\t\t\t/* Now its reasm? */\n\t\t\t\tTAILQ_FOREACH_SAFE(chk, &control->reasm, sctp_next, nchk) {\n\t\t\t\t\tcnt++;\n\t\t\t\t\tSCTP_CALC_TSN_TO_GAP(gap, chk->rec.data.tsn, asoc->mapping_array_base_tsn);\n\t\t\t\t\tKASSERT(chk->send_size > 0, (\"chunk has zero length\"));\n\t\t\t\t\tif (asoc->size_on_reasm_queue >= chk->send_size) {\n\t\t\t\t\t\tasoc->size_on_reasm_queue -= chk->send_size;\n\t\t\t\t\t} else {\n#ifdef INVARIANTS\n\t\t\t\t\t\tpanic(\"size_on_reasm_queue = %u smaller than chunk length %u\", asoc->size_on_reasm_queue, chk->send_size);\n#else\n\t\t\t\t\t\tasoc->size_on_reasm_queue = 0;\n#endif\n\t\t\t\t\t}\n\t\t\t\t\tsctp_ucount_decr(asoc->cnt_on_reasm_queue);\n\t\t\t\t\tSCTP_UNSET_TSN_PRESENT(asoc->mapping_array, gap);\n\t\t\t\t\tTAILQ_REMOVE(&control->reasm, chk, sctp_next);\n\t\t\t\t\tif (chk->data) {\n\t\t\t\t\t\tsctp_m_freem(chk->data);\n\t\t\t\t\t\tchk->data = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tsctp_free_a_chunk(stcb, chk, SCTP_SO_NOT_LOCKED);\n\t\t\t\t}\n\t\t\t\tsctp_free_a_readq(stcb, control);\n\t\t\t}\n\t\t}\n\t}\n\tif (cnt) {\n\t\t/* We must back down to see what the new highest is */\n\t\tfor (i = asoc->highest_tsn_inside_map; SCTP_TSN_GE(i, asoc->mapping_array_base_tsn); i--) {\n\t\t\tSCTP_CALC_TSN_TO_GAP(gap, i, asoc->mapping_array_base_tsn);\n\t\t\tif (SCTP_IS_TSN_PRESENT(asoc->mapping_array, gap)) {\n\t\t\t\tasoc->highest_tsn_inside_map = i;\n\t\t\t\tfnd = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!fnd) {\n\t\t\tasoc->highest_tsn_inside_map = asoc->mapping_array_base_tsn - 1;\n\t\t}\n\n\t\t/*\n\t\t * Question, should we go through the delivery queue? The only\n\t\t * reason things are on here is the app not reading OR a p-d-api up.\n\t\t * An attacker COULD send enough in to initiate the PD-API and then\n\t\t * send a bunch of stuff to other streams... these would wind up on\n\t\t * the delivery queue.. and then we would not get to them. But in\n\t\t * order to do this I then have to back-track and un-deliver\n\t\t * sequence numbers in streams.. el-yucko. I think for now we will\n\t\t * NOT look at the delivery queue and leave it to be something to\n\t\t * consider later. An alternative would be to abort the P-D-API with\n\t\t * a notification and then deliver the data.... Or another method\n\t\t * might be to keep track of how many times the situation occurs and\n\t\t * if we see a possible attack underway just abort the association.\n\t\t */\n#ifdef SCTP_DEBUG\n\t\tSCTPDBG(SCTP_DEBUG_PCB1, \"Freed %d chunks from reneg harvest\\n\", cnt);\n#endif\n\t\t/*\n\t\t * Now do we need to find a new\n\t\t * asoc->highest_tsn_inside_map?\n\t\t */\n\t\tasoc->last_revoke_count = cnt;\n\t\t(void)SCTP_OS_TIMER_STOP(&stcb->asoc.dack_timer.timer);\n\t\t/*sa_ignore NO_NULL_CHK*/\n\t\tsctp_send_sack(stcb, SCTP_SO_NOT_LOCKED);\n\t\tsctp_chunk_output(stcb->sctp_ep, stcb, SCTP_OUTPUT_FROM_DRAIN, SCTP_SO_NOT_LOCKED);\n\t}\n\t/*\n\t * Another issue, in un-setting the TSN's in the mapping array we\n\t * DID NOT adjust the highest_tsn marker.  This will cause one of two\n\t * things to occur. It may cause us to do extra work in checking for\n\t * our mapping array movement. More importantly it may cause us to\n\t * SACK every datagram. This may not be a bad thing though since we\n\t * will recover once we get our cum-ack above and all this stuff we\n\t * dumped recovered.\n\t */\n}\n\nvoid\nsctp_drain()\n{\n\t/*\n\t * We must walk the PCB lists for ALL associations here. The system\n\t * is LOW on MBUF's and needs help. This is where reneging will\n\t * occur. We really hope this does NOT happen!\n\t */\n#if defined(__FreeBSD__) && __FreeBSD_version >= 801000\n\tVNET_ITERATOR_DECL(vnet_iter);\n#else\n\tstruct sctp_inpcb *inp;\n\tstruct sctp_tcb *stcb;\n\n\tSCTP_STAT_INCR(sctps_protocol_drain_calls);\n\tif (SCTP_BASE_SYSCTL(sctp_do_drain) == 0) {\n\t\treturn;\n\t}\n#endif\n#if defined(__FreeBSD__) && __FreeBSD_version >= 801000\n\tVNET_LIST_RLOCK_NOSLEEP();\n\tVNET_FOREACH(vnet_iter) {\n\t\tCURVNET_SET(vnet_iter);\n\t\tstruct sctp_inpcb *inp;\n\t\tstruct sctp_tcb *stcb;\n#endif\n\n#if defined(__FreeBSD__) && __FreeBSD_version >= 801000\n\t\tSCTP_STAT_INCR(sctps_protocol_drain_calls);\n\t\tif (SCTP_BASE_SYSCTL(sctp_do_drain) == 0) {\n#ifdef VIMAGE\n\t\t\tcontinue;\n#else\n\t\t\treturn;\n#endif\n\t\t}\n#endif\n\t\tSCTP_INP_INFO_RLOCK();\n\t\tLIST_FOREACH(inp, &SCTP_BASE_INFO(listhead), sctp_list) {\n\t\t\t/* For each endpoint */\n\t\t\tSCTP_INP_RLOCK(inp);\n\t\t\tLIST_FOREACH(stcb, &inp->sctp_asoc_list, sctp_tcblist) {\n\t\t\t\t/* For each association */\n\t\t\t\tSCTP_TCB_LOCK(stcb);\n\t\t\t\tsctp_drain_mbufs(stcb);\n\t\t\t\tSCTP_TCB_UNLOCK(stcb);\n\t\t\t}\n\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t}\n\t\tSCTP_INP_INFO_RUNLOCK();\n#if defined(__FreeBSD__) && __FreeBSD_version >= 801000\n\t\tCURVNET_RESTORE();\n\t}\n\tVNET_LIST_RUNLOCK_NOSLEEP();\n#endif\n}\n\n/*\n * start a new iterator\n * iterates through all endpoints and associations based on the pcb_state\n * flags and asoc_state.  \"af\" (mandatory) is executed for all matching\n * assocs and \"ef\" (optional) is executed when the iterator completes.\n * \"inpf\" (optional) is executed for each new endpoint as it is being\n * iterated through. inpe (optional) is called when the inp completes\n * its way through all the stcbs.\n */\nint\nsctp_initiate_iterator(inp_func inpf,\n\t\t       asoc_func af,\n\t\t       inp_func inpe,\n\t\t       uint32_t pcb_state,\n\t\t       uint32_t pcb_features,\n\t\t       uint32_t asoc_state,\n\t\t       void *argp,\n\t\t       uint32_t argi,\n\t\t       end_func ef,\n\t\t       struct sctp_inpcb *s_inp,\n\t\t       uint8_t chunk_output_off)\n{\n\tstruct sctp_iterator *it = NULL;\n\n\tif (af == NULL) {\n\t\treturn (-1);\n\t}\n\tif (SCTP_BASE_VAR(sctp_pcb_initialized) == 0) {\n\t\tSCTP_PRINTF(\"%s: abort on initialize being %d\\n\", __func__,\n\t\t            SCTP_BASE_VAR(sctp_pcb_initialized));\n\t\treturn (-1);\n\t}\n\tSCTP_MALLOC(it, struct sctp_iterator *, sizeof(struct sctp_iterator),\n\t\t    SCTP_M_ITER);\n\tif (it == NULL) {\n\t\tSCTP_LTRACE_ERR_RET(NULL, NULL, NULL, SCTP_FROM_SCTP_PCB, ENOMEM);\n\t\treturn (ENOMEM);\n\t}\n\tmemset(it, 0, sizeof(*it));\n\tit->function_assoc = af;\n\tit->function_inp = inpf;\n\tif (inpf)\n\t\tit->done_current_ep = 0;\n\telse\n\t\tit->done_current_ep = 1;\n\tit->function_atend = ef;\n\tit->pointer = argp;\n\tit->val = argi;\n\tit->pcb_flags = pcb_state;\n\tit->pcb_features = pcb_features;\n\tit->asoc_state = asoc_state;\n\tit->function_inp_end = inpe;\n\tit->no_chunk_output = chunk_output_off;\n#if defined(__FreeBSD__) && __FreeBSD_version >= 801000\n\tit->vn = curvnet;\n#endif\n\tif (s_inp) {\n\t\t/* Assume lock is held here */\n\t\tit->inp = s_inp;\n\t\tSCTP_INP_INCR_REF(it->inp);\n\t\tit->iterator_flags = SCTP_ITERATOR_DO_SINGLE_INP;\n\t} else {\n\t\tSCTP_INP_INFO_RLOCK();\n\t\tit->inp = LIST_FIRST(&SCTP_BASE_INFO(listhead));\n\t\tif (it->inp) {\n\t\t\tSCTP_INP_INCR_REF(it->inp);\n\t\t}\n\t\tSCTP_INP_INFO_RUNLOCK();\n\t\tit->iterator_flags = SCTP_ITERATOR_DO_ALL_INP;\n\n\t}\n\tSCTP_IPI_ITERATOR_WQ_LOCK();\n\tif (SCTP_BASE_VAR(sctp_pcb_initialized) == 0) {\n\t\tSCTP_IPI_ITERATOR_WQ_UNLOCK();\n\t\tSCTP_PRINTF(\"%s: rollback on initialize being %d it=%p\\n\", __func__,\n\t\t            SCTP_BASE_VAR(sctp_pcb_initialized), it);\n\t\tSCTP_FREE(it, SCTP_M_ITER);\n\t\treturn (-1);\n\t}\n\tTAILQ_INSERT_TAIL(&sctp_it_ctl.iteratorhead, it, sctp_nxt_itr);\n\tif (sctp_it_ctl.iterator_running == 0) {\n\t\tsctp_wakeup_iterator();\n\t}\n\tSCTP_IPI_ITERATOR_WQ_UNLOCK();\n\t/* sa_ignore MEMLEAK {memory is put on the tailq for the iterator} */\n\treturn (0);\n}\n"], "fixing_code": ["/*-\n * SPDX-License-Identifier: BSD-3-Clause\n *\n * Copyright (c) 2001-2008, by Cisco Systems, Inc. All rights reserved.\n * Copyright (c) 2008-2012, by Randall Stewart. All rights reserved.\n * Copyright (c) 2008-2012, by Michael Tuexen. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * a) Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *\n * b) Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the distribution.\n *\n * c) Neither the name of Cisco Systems, Inc. nor the names of its\n *    contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifdef __FreeBSD__\n#include <sys/cdefs.h>\n__FBSDID(\"$FreeBSD: head/sys/netinet/sctp_auth.c 355931 2019-12-20 15:25:08Z tuexen $\");\n#endif\n\n#include <netinet/sctp_os.h>\n#include <netinet/sctp.h>\n#include <netinet/sctp_header.h>\n#include <netinet/sctp_pcb.h>\n#include <netinet/sctp_var.h>\n#include <netinet/sctp_sysctl.h>\n#include <netinet/sctputil.h>\n#include <netinet/sctp_indata.h>\n#include <netinet/sctp_output.h>\n#include <netinet/sctp_auth.h>\n\n#ifdef SCTP_DEBUG\n#define SCTP_AUTH_DEBUG\t\t(SCTP_BASE_SYSCTL(sctp_debug_on) & SCTP_DEBUG_AUTH1)\n#define SCTP_AUTH_DEBUG2\t(SCTP_BASE_SYSCTL(sctp_debug_on) & SCTP_DEBUG_AUTH2)\n#endif /* SCTP_DEBUG */\n\n\nvoid\nsctp_clear_chunklist(sctp_auth_chklist_t *chklist)\n{\n\tmemset(chklist, 0, sizeof(*chklist));\n\t/* chklist->num_chunks = 0; */\n}\n\nsctp_auth_chklist_t *\nsctp_alloc_chunklist(void)\n{\n\tsctp_auth_chklist_t *chklist;\n\n\tSCTP_MALLOC(chklist, sctp_auth_chklist_t *, sizeof(*chklist),\n\t\t    SCTP_M_AUTH_CL);\n\tif (chklist == NULL) {\n\t\tSCTPDBG(SCTP_DEBUG_AUTH1, \"sctp_alloc_chunklist: failed to get memory!\\n\");\n\t} else {\n\t\tsctp_clear_chunklist(chklist);\n\t}\n\treturn (chklist);\n}\n\nvoid\nsctp_free_chunklist(sctp_auth_chklist_t *list)\n{\n\tif (list != NULL)\n\t\tSCTP_FREE(list, SCTP_M_AUTH_CL);\n}\n\nsctp_auth_chklist_t *\nsctp_copy_chunklist(sctp_auth_chklist_t *list)\n{\n\tsctp_auth_chklist_t *new_list;\n\n\tif (list == NULL)\n\t\treturn (NULL);\n\n\t/* get a new list */\n\tnew_list = sctp_alloc_chunklist();\n\tif (new_list == NULL)\n\t\treturn (NULL);\n\t/* copy it */\n\tmemcpy(new_list, list, sizeof(*new_list));\n\n\treturn (new_list);\n}\n\n\n/*\n * add a chunk to the required chunks list\n */\nint\nsctp_auth_add_chunk(uint8_t chunk, sctp_auth_chklist_t *list)\n{\n\tif (list == NULL)\n\t\treturn (-1);\n\n\t/* is chunk restricted? */\n\tif ((chunk == SCTP_INITIATION) ||\n\t    (chunk == SCTP_INITIATION_ACK) ||\n\t    (chunk == SCTP_SHUTDOWN_COMPLETE) ||\n\t    (chunk == SCTP_AUTHENTICATION)) {\n\t\treturn (-1);\n\t}\n\tif (list->chunks[chunk] == 0) {\n\t\tlist->chunks[chunk] = 1;\n\t\tlist->num_chunks++;\n\t\tSCTPDBG(SCTP_DEBUG_AUTH1,\n\t\t\t\"SCTP: added chunk %u (0x%02x) to Auth list\\n\",\n\t\t\tchunk, chunk);\n\t}\n\treturn (0);\n}\n\n/*\n * delete a chunk from the required chunks list\n */\nint\nsctp_auth_delete_chunk(uint8_t chunk, sctp_auth_chklist_t *list)\n{\n\tif (list == NULL)\n\t\treturn (-1);\n\n\tif (list->chunks[chunk] == 1) {\n\t\tlist->chunks[chunk] = 0;\n\t\tlist->num_chunks--;\n\t\tSCTPDBG(SCTP_DEBUG_AUTH1,\n\t\t\t\"SCTP: deleted chunk %u (0x%02x) from Auth list\\n\",\n\t\t\tchunk, chunk);\n\t}\n\treturn (0);\n}\n\nsize_t\nsctp_auth_get_chklist_size(const sctp_auth_chklist_t *list)\n{\n\tif (list == NULL)\n\t\treturn (0);\n\telse\n\t\treturn (list->num_chunks);\n}\n\n/*\n * return the current number and list of required chunks caller must\n * guarantee ptr has space for up to 256 bytes\n */\nint\nsctp_serialize_auth_chunks(const sctp_auth_chklist_t *list, uint8_t *ptr)\n{\n\tint i, count = 0;\n\n\tif (list == NULL)\n\t\treturn (0);\n\n\tfor (i = 0; i < 256; i++) {\n\t\tif (list->chunks[i] != 0) {\n\t\t\t*ptr++ = i;\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn (count);\n}\n\nint\nsctp_pack_auth_chunks(const sctp_auth_chklist_t *list, uint8_t *ptr)\n{\n\tint i, size = 0;\n\n\tif (list == NULL)\n\t\treturn (0);\n\n\tif (list->num_chunks <= 32) {\n\t\t/* just list them, one byte each */\n\t\tfor (i = 0; i < 256; i++) {\n\t\t\tif (list->chunks[i] != 0) {\n\t\t\t\t*ptr++ = i;\n\t\t\t\tsize++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tint index, offset;\n\n\t\t/* pack into a 32 byte bitfield */\n\t\tfor (i = 0; i < 256; i++) {\n\t\t\tif (list->chunks[i] != 0) {\n\t\t\t\tindex = i / 8;\n\t\t\t\toffset = i % 8;\n\t\t\t\tptr[index] |= (1 << offset);\n\t\t\t}\n\t\t}\n\t\tsize = 32;\n\t}\n\treturn (size);\n}\n\nint\nsctp_unpack_auth_chunks(const uint8_t *ptr, uint8_t num_chunks,\n    sctp_auth_chklist_t *list)\n{\n\tint i;\n\tint size;\n\n\tif (list == NULL)\n\t\treturn (0);\n\n\tif (num_chunks <= 32) {\n\t\t/* just pull them, one byte each */\n\t\tfor (i = 0; i < num_chunks; i++) {\n\t\t\t(void)sctp_auth_add_chunk(*ptr++, list);\n\t\t}\n\t\tsize = num_chunks;\n\t} else {\n\t\tint index, offset;\n\n\t\t/* unpack from a 32 byte bitfield */\n\t\tfor (index = 0; index < 32; index++) {\n\t\t\tfor (offset = 0; offset < 8; offset++) {\n\t\t\t\tif (ptr[index] & (1 << offset)) {\n\t\t\t\t\t(void)sctp_auth_add_chunk((index * 8) + offset, list);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsize = 32;\n\t}\n\treturn (size);\n}\n\n\n/*\n * allocate structure space for a key of length keylen\n */\nsctp_key_t *\nsctp_alloc_key(uint32_t keylen)\n{\n\tsctp_key_t *new_key;\n\n\tSCTP_MALLOC(new_key, sctp_key_t *, sizeof(*new_key) + keylen,\n\t\t    SCTP_M_AUTH_KY);\n\tif (new_key == NULL) {\n\t\t/* out of memory */\n\t\treturn (NULL);\n\t}\n\tnew_key->keylen = keylen;\n\treturn (new_key);\n}\n\nvoid\nsctp_free_key(sctp_key_t *key)\n{\n\tif (key != NULL)\n\t\tSCTP_FREE(key,SCTP_M_AUTH_KY);\n}\n\nvoid\nsctp_print_key(sctp_key_t *key, const char *str)\n{\n\tuint32_t i;\n\n\tif (key == NULL) {\n\t\tSCTP_PRINTF(\"%s: [Null key]\\n\", str);\n\t\treturn;\n\t}\n\tSCTP_PRINTF(\"%s: len %u, \", str, key->keylen);\n\tif (key->keylen) {\n\t\tfor (i = 0; i < key->keylen; i++)\n\t\t\tSCTP_PRINTF(\"%02x\", key->key[i]);\n\t\tSCTP_PRINTF(\"\\n\");\n\t} else {\n\t\tSCTP_PRINTF(\"[Null key]\\n\");\n\t}\n}\n\nvoid\nsctp_show_key(sctp_key_t *key, const char *str)\n{\n\tuint32_t i;\n\n\tif (key == NULL) {\n\t\tSCTP_PRINTF(\"%s: [Null key]\\n\", str);\n\t\treturn;\n\t}\n\tSCTP_PRINTF(\"%s: len %u, \", str, key->keylen);\n\tif (key->keylen) {\n\t\tfor (i = 0; i < key->keylen; i++)\n\t\t\tSCTP_PRINTF(\"%02x\", key->key[i]);\n\t\tSCTP_PRINTF(\"\\n\");\n\t} else {\n\t\tSCTP_PRINTF(\"[Null key]\\n\");\n\t}\n}\n\nstatic uint32_t\nsctp_get_keylen(sctp_key_t *key)\n{\n\tif (key != NULL)\n\t\treturn (key->keylen);\n\telse\n\t\treturn (0);\n}\n\n/*\n * generate a new random key of length 'keylen'\n */\nsctp_key_t *\nsctp_generate_random_key(uint32_t keylen)\n{\n\tsctp_key_t *new_key;\n\n\tnew_key = sctp_alloc_key(keylen);\n\tif (new_key == NULL) {\n\t\t/* out of memory */\n\t\treturn (NULL);\n\t}\n\tSCTP_READ_RANDOM(new_key->key, keylen);\n\tnew_key->keylen = keylen;\n\treturn (new_key);\n}\n\nsctp_key_t *\nsctp_set_key(uint8_t *key, uint32_t keylen)\n{\n\tsctp_key_t *new_key;\n\n\tnew_key = sctp_alloc_key(keylen);\n\tif (new_key == NULL) {\n\t\t/* out of memory */\n\t\treturn (NULL);\n\t}\n\tmemcpy(new_key->key, key, keylen);\n\treturn (new_key);\n}\n\n/*-\n * given two keys of variable size, compute which key is \"larger/smaller\"\n * returns:  1 if key1 > key2\n *          -1 if key1 < key2\n *           0 if key1 = key2\n */\nstatic int\nsctp_compare_key(sctp_key_t *key1, sctp_key_t *key2)\n{\n\tuint32_t maxlen;\n\tuint32_t i;\n\tuint32_t key1len, key2len;\n\tuint8_t *key_1, *key_2;\n\tuint8_t val1, val2;\n\n\t/* sanity/length check */\n\tkey1len = sctp_get_keylen(key1);\n\tkey2len = sctp_get_keylen(key2);\n\tif ((key1len == 0) && (key2len == 0))\n\t\treturn (0);\n\telse if (key1len == 0)\n\t\treturn (-1);\n\telse if (key2len == 0)\n\t\treturn (1);\n\n\tif (key1len < key2len) {\n\t\tmaxlen = key2len;\n\t} else {\n\t\tmaxlen = key1len;\n\t}\n\tkey_1 = key1->key;\n\tkey_2 = key2->key;\n\t/* check for numeric equality */\n\tfor (i = 0; i < maxlen; i++) {\n\t\t/* left-pad with zeros */\n\t\tval1 = (i < (maxlen - key1len)) ? 0 : *(key_1++);\n\t\tval2 = (i < (maxlen - key2len)) ? 0 : *(key_2++);\n\t\tif (val1 > val2) {\n\t\t\treturn (1);\n\t\t} else if (val1 < val2) {\n\t\t\treturn (-1);\n\t\t}\n\t}\n\t/* keys are equal value, so check lengths */\n\tif (key1len == key2len)\n\t\treturn (0);\n\telse if (key1len < key2len)\n\t\treturn (-1);\n\telse\n\t\treturn (1);\n}\n\n/*\n * generate the concatenated keying material based on the two keys and the\n * shared key (if available). draft-ietf-tsvwg-auth specifies the specific\n * order for concatenation\n */\nsctp_key_t *\nsctp_compute_hashkey(sctp_key_t *key1, sctp_key_t *key2, sctp_key_t *shared)\n{\n\tuint32_t keylen;\n\tsctp_key_t *new_key;\n\tuint8_t *key_ptr;\n\n\tkeylen = sctp_get_keylen(key1) + sctp_get_keylen(key2) +\n\t    sctp_get_keylen(shared);\n\n\tif (keylen > 0) {\n\t\t/* get space for the new key */\n\t\tnew_key = sctp_alloc_key(keylen);\n\t\tif (new_key == NULL) {\n\t\t\t/* out of memory */\n\t\t\treturn (NULL);\n\t\t}\n\t\tnew_key->keylen = keylen;\n\t\tkey_ptr = new_key->key;\n\t} else {\n\t\t/* all keys empty/null?! */\n\t\treturn (NULL);\n\t}\n\n\t/* concatenate the keys */\n\tif (sctp_compare_key(key1, key2) <= 0) {\n\t\t/* key is shared + key1 + key2 */\n\t\tif (sctp_get_keylen(shared)) {\n\t\t\tmemcpy(key_ptr, shared->key, shared->keylen);\n\t\t\tkey_ptr += shared->keylen;\n\t\t}\n\t\tif (sctp_get_keylen(key1)) {\n\t\t\tmemcpy(key_ptr, key1->key, key1->keylen);\n\t\t\tkey_ptr += key1->keylen;\n\t\t}\n\t\tif (sctp_get_keylen(key2)) {\n\t\t\tmemcpy(key_ptr, key2->key, key2->keylen);\n\t\t}\n\t} else {\n\t\t/* key is shared + key2 + key1 */\n\t\tif (sctp_get_keylen(shared)) {\n\t\t\tmemcpy(key_ptr, shared->key, shared->keylen);\n\t\t\tkey_ptr += shared->keylen;\n\t\t}\n\t\tif (sctp_get_keylen(key2)) {\n\t\t\tmemcpy(key_ptr, key2->key, key2->keylen);\n\t\t\tkey_ptr += key2->keylen;\n\t\t}\n\t\tif (sctp_get_keylen(key1)) {\n\t\t\tmemcpy(key_ptr, key1->key, key1->keylen);\n\t\t}\n\t}\n\treturn (new_key);\n}\n\n\nsctp_sharedkey_t *\nsctp_alloc_sharedkey(void)\n{\n\tsctp_sharedkey_t *new_key;\n\n\tSCTP_MALLOC(new_key, sctp_sharedkey_t *, sizeof(*new_key),\n\t\t    SCTP_M_AUTH_KY);\n\tif (new_key == NULL) {\n\t\t/* out of memory */\n\t\treturn (NULL);\n\t}\n\tnew_key->keyid = 0;\n\tnew_key->key = NULL;\n\tnew_key->refcount = 1;\n\tnew_key->deactivated = 0;\n\treturn (new_key);\n}\n\nvoid\nsctp_free_sharedkey(sctp_sharedkey_t *skey)\n{\n\tif (skey == NULL)\n\t\treturn;\n\n\tif (SCTP_DECREMENT_AND_CHECK_REFCOUNT(&skey->refcount)) {\n\t\tif (skey->key != NULL)\n\t\t\tsctp_free_key(skey->key);\n\t\tSCTP_FREE(skey, SCTP_M_AUTH_KY);\n\t}\n}\n\nsctp_sharedkey_t *\nsctp_find_sharedkey(struct sctp_keyhead *shared_keys, uint16_t key_id)\n{\n\tsctp_sharedkey_t *skey;\n\n\tLIST_FOREACH(skey, shared_keys, next) {\n\t\tif (skey->keyid == key_id)\n\t\t\treturn (skey);\n\t}\n\treturn (NULL);\n}\n\nint\nsctp_insert_sharedkey(struct sctp_keyhead *shared_keys,\n\t\t      sctp_sharedkey_t *new_skey)\n{\n\tsctp_sharedkey_t *skey;\n\n\tif ((shared_keys == NULL) || (new_skey == NULL))\n\t\treturn (EINVAL);\n\n\t/* insert into an empty list? */\n\tif (LIST_EMPTY(shared_keys)) {\n\t\tLIST_INSERT_HEAD(shared_keys, new_skey, next);\n\t\treturn (0);\n\t}\n\t/* insert into the existing list, ordered by key id */\n\tLIST_FOREACH(skey, shared_keys, next) {\n\t\tif (new_skey->keyid < skey->keyid) {\n\t\t\t/* insert it before here */\n\t\t\tLIST_INSERT_BEFORE(skey, new_skey, next);\n\t\t\treturn (0);\n\t\t} else if (new_skey->keyid == skey->keyid) {\n\t\t\t/* replace the existing key */\n\t\t\t/* verify this key *can* be replaced */\n\t\t\tif ((skey->deactivated) || (skey->refcount > 1)) {\n\t\t\t\tSCTPDBG(SCTP_DEBUG_AUTH1,\n\t\t\t\t\t\"can't replace shared key id %u\\n\",\n\t\t\t\t\tnew_skey->keyid);\n\t\t\t\treturn (EBUSY);\n\t\t\t}\n\t\t\tSCTPDBG(SCTP_DEBUG_AUTH1,\n\t\t\t\t\"replacing shared key id %u\\n\",\n\t\t\t\tnew_skey->keyid);\n\t\t\tLIST_INSERT_BEFORE(skey, new_skey, next);\n\t\t\tLIST_REMOVE(skey, next);\n\t\t\tsctp_free_sharedkey(skey);\n\t\t\treturn (0);\n\t\t}\n\t\tif (LIST_NEXT(skey, next) == NULL) {\n\t\t\t/* belongs at the end of the list */\n\t\t\tLIST_INSERT_AFTER(skey, new_skey, next);\n\t\t\treturn (0);\n\t\t}\n\t}\n\t/* shouldn't reach here */\n\treturn (EINVAL);\n}\n\nvoid\nsctp_auth_key_acquire(struct sctp_tcb *stcb, uint16_t key_id)\n{\n\tsctp_sharedkey_t *skey;\n\n\t/* find the shared key */\n\tskey = sctp_find_sharedkey(&stcb->asoc.shared_keys, key_id);\n\n\t/* bump the ref count */\n\tif (skey) {\n\t\tatomic_add_int(&skey->refcount, 1);\n\t\tSCTPDBG(SCTP_DEBUG_AUTH2,\n\t\t\t\"%s: stcb %p key %u refcount acquire to %d\\n\",\n\t\t\t__func__, (void *)stcb, key_id, skey->refcount);\n\t}\n}\n\nvoid\nsctp_auth_key_release(struct sctp_tcb *stcb, uint16_t key_id, int so_locked\n#if !defined(__APPLE__) && !defined(SCTP_SO_LOCK_TESTING)\n\tSCTP_UNUSED\n#endif\n)\n{\n\tsctp_sharedkey_t *skey;\n\n\t/* find the shared key */\n\tskey = sctp_find_sharedkey(&stcb->asoc.shared_keys, key_id);\n\n\t/* decrement the ref count */\n\tif (skey) {\n\t\tSCTPDBG(SCTP_DEBUG_AUTH2,\n\t\t\t\"%s: stcb %p key %u refcount release to %d\\n\",\n\t\t\t__func__, (void *)stcb, key_id, skey->refcount);\n\n\t\t/* see if a notification should be generated */\n\t\tif ((skey->refcount <= 2) && (skey->deactivated)) {\n\t\t\t/* notify ULP that key is no longer used */\n\t\t\tsctp_ulp_notify(SCTP_NOTIFY_AUTH_FREE_KEY, stcb,\n\t\t\t\t\tkey_id, 0, so_locked);\n\t\t\tSCTPDBG(SCTP_DEBUG_AUTH2,\n\t\t\t\t\"%s: stcb %p key %u no longer used, %d\\n\",\n\t\t\t\t__func__, (void *)stcb, key_id, skey->refcount);\n\t\t}\n\t\tsctp_free_sharedkey(skey);\n\t}\n}\n\nstatic sctp_sharedkey_t *\nsctp_copy_sharedkey(const sctp_sharedkey_t *skey)\n{\n\tsctp_sharedkey_t *new_skey;\n\n\tif (skey == NULL)\n\t\treturn (NULL);\n\tnew_skey = sctp_alloc_sharedkey();\n\tif (new_skey == NULL)\n\t\treturn (NULL);\n\tif (skey->key != NULL)\n\t\tnew_skey->key = sctp_set_key(skey->key->key, skey->key->keylen);\n\telse\n\t\tnew_skey->key = NULL;\n\tnew_skey->keyid = skey->keyid;\n\treturn (new_skey);\n}\n\nint\nsctp_copy_skeylist(const struct sctp_keyhead *src, struct sctp_keyhead *dest)\n{\n\tsctp_sharedkey_t *skey, *new_skey;\n\tint count = 0;\n\n\tif ((src == NULL) || (dest == NULL))\n\t\treturn (0);\n\tLIST_FOREACH(skey, src, next) {\n\t\tnew_skey = sctp_copy_sharedkey(skey);\n\t\tif (new_skey != NULL) {\n\t\t\tif (sctp_insert_sharedkey(dest, new_skey)) {\n\t\t\t\tsctp_free_sharedkey(new_skey);\n\t\t\t} else {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn (count);\n}\n\n\nsctp_hmaclist_t *\nsctp_alloc_hmaclist(uint16_t num_hmacs)\n{\n\tsctp_hmaclist_t *new_list;\n\tint alloc_size;\n\n\talloc_size = sizeof(*new_list) + num_hmacs * sizeof(new_list->hmac[0]);\n\tSCTP_MALLOC(new_list, sctp_hmaclist_t *, alloc_size,\n\t\t    SCTP_M_AUTH_HL);\n\tif (new_list == NULL) {\n\t\t/* out of memory */\n\t\treturn (NULL);\n\t}\n\tnew_list->max_algo = num_hmacs;\n\tnew_list->num_algo = 0;\n\treturn (new_list);\n}\n\nvoid\nsctp_free_hmaclist(sctp_hmaclist_t *list)\n{\n\tif (list != NULL) {\n\t\tSCTP_FREE(list,SCTP_M_AUTH_HL);\n\t\tlist = NULL;\n\t}\n}\n\nint\nsctp_auth_add_hmacid(sctp_hmaclist_t *list, uint16_t hmac_id)\n{\n\tint i;\n\tif (list == NULL)\n\t\treturn (-1);\n\tif (list->num_algo == list->max_algo) {\n\t\tSCTPDBG(SCTP_DEBUG_AUTH1,\n\t\t\t\"SCTP: HMAC id list full, ignoring add %u\\n\", hmac_id);\n\t\treturn (-1);\n\t}\n#if defined(SCTP_SUPPORT_HMAC_SHA256)\n\tif ((hmac_id != SCTP_AUTH_HMAC_ID_SHA1) &&\n\t    (hmac_id != SCTP_AUTH_HMAC_ID_SHA256)) {\n#else\n\tif (hmac_id != SCTP_AUTH_HMAC_ID_SHA1) {\n#endif\n\t\treturn (-1);\n\t}\n\t/* Now is it already in the list */\n\tfor (i = 0; i < list->num_algo; i++) {\n\t\tif (list->hmac[i] == hmac_id) {\n\t\t\t/* already in list */\n\t\t\treturn (-1);\n\t\t}\n\t}\n\tSCTPDBG(SCTP_DEBUG_AUTH1, \"SCTP: add HMAC id %u to list\\n\", hmac_id);\n\tlist->hmac[list->num_algo++] = hmac_id;\n\treturn (0);\n}\n\nsctp_hmaclist_t *\nsctp_copy_hmaclist(sctp_hmaclist_t *list)\n{\n\tsctp_hmaclist_t *new_list;\n\tint i;\n\n\tif (list == NULL)\n\t\treturn (NULL);\n\t/* get a new list */\n\tnew_list = sctp_alloc_hmaclist(list->max_algo);\n\tif (new_list == NULL)\n\t\treturn (NULL);\n\t/* copy it */\n\tnew_list->max_algo = list->max_algo;\n\tnew_list->num_algo = list->num_algo;\n\tfor (i = 0; i < list->num_algo; i++)\n\t\tnew_list->hmac[i] = list->hmac[i];\n\treturn (new_list);\n}\n\nsctp_hmaclist_t *\nsctp_default_supported_hmaclist(void)\n{\n\tsctp_hmaclist_t *new_list;\n\n#if defined(SCTP_SUPPORT_HMAC_SHA256)\n\tnew_list = sctp_alloc_hmaclist(2);\n#else\n\tnew_list = sctp_alloc_hmaclist(1);\n#endif\n\tif (new_list == NULL)\n\t\treturn (NULL);\n#if defined(SCTP_SUPPORT_HMAC_SHA256)\n\t/* We prefer SHA256, so list it first */\n\t(void)sctp_auth_add_hmacid(new_list, SCTP_AUTH_HMAC_ID_SHA256);\n#endif\n\t(void)sctp_auth_add_hmacid(new_list, SCTP_AUTH_HMAC_ID_SHA1);\n\treturn (new_list);\n}\n\n/*-\n * HMAC algos are listed in priority/preference order\n * find the best HMAC id to use for the peer based on local support\n */\nuint16_t\nsctp_negotiate_hmacid(sctp_hmaclist_t *peer, sctp_hmaclist_t *local)\n{\n\tint i, j;\n\n\tif ((local == NULL) || (peer == NULL))\n\t\treturn (SCTP_AUTH_HMAC_ID_RSVD);\n\n\tfor (i = 0; i < peer->num_algo; i++) {\n\t\tfor (j = 0; j < local->num_algo; j++) {\n\t\t\tif (peer->hmac[i] == local->hmac[j]) {\n\t\t\t\t/* found the \"best\" one */\n\t\t\t\tSCTPDBG(SCTP_DEBUG_AUTH1,\n\t\t\t\t\t\"SCTP: negotiated peer HMAC id %u\\n\",\n\t\t\t\t\tpeer->hmac[i]);\n\t\t\t\treturn (peer->hmac[i]);\n\t\t\t}\n\t\t}\n\t}\n\t/* didn't find one! */\n\treturn (SCTP_AUTH_HMAC_ID_RSVD);\n}\n\n/*-\n * serialize the HMAC algo list and return space used\n * caller must guarantee ptr has appropriate space\n */\nint\nsctp_serialize_hmaclist(sctp_hmaclist_t *list, uint8_t *ptr)\n{\n\tint i;\n\tuint16_t hmac_id;\n\n\tif (list == NULL)\n\t\treturn (0);\n\n\tfor (i = 0; i < list->num_algo; i++) {\n\t\thmac_id = htons(list->hmac[i]);\n\t\tmemcpy(ptr, &hmac_id, sizeof(hmac_id));\n\t\tptr += sizeof(hmac_id);\n\t}\n\treturn (list->num_algo * sizeof(hmac_id));\n}\n\nint\nsctp_verify_hmac_param (struct sctp_auth_hmac_algo *hmacs, uint32_t num_hmacs)\n{\n\tuint32_t i;\n\n\tfor (i = 0; i < num_hmacs; i++) {\n\t\tif (ntohs(hmacs->hmac_ids[i]) == SCTP_AUTH_HMAC_ID_SHA1) {\n\t\t\treturn (0);\n\t\t}\n\t}\n\treturn (-1);\n}\n\nsctp_authinfo_t *\nsctp_alloc_authinfo(void)\n{\n\tsctp_authinfo_t *new_authinfo;\n\n\tSCTP_MALLOC(new_authinfo, sctp_authinfo_t *, sizeof(*new_authinfo),\n\t\t    SCTP_M_AUTH_IF);\n\n\tif (new_authinfo == NULL) {\n\t\t/* out of memory */\n\t\treturn (NULL);\n\t}\n\tmemset(new_authinfo, 0, sizeof(*new_authinfo));\n\treturn (new_authinfo);\n}\n\nvoid\nsctp_free_authinfo(sctp_authinfo_t *authinfo)\n{\n\tif (authinfo == NULL)\n\t\treturn;\n\n\tif (authinfo->random != NULL)\n\t\tsctp_free_key(authinfo->random);\n\tif (authinfo->peer_random != NULL)\n\t\tsctp_free_key(authinfo->peer_random);\n\tif (authinfo->assoc_key != NULL)\n\t\tsctp_free_key(authinfo->assoc_key);\n\tif (authinfo->recv_key != NULL)\n\t\tsctp_free_key(authinfo->recv_key);\n\n\t/* We are NOT dynamically allocating authinfo's right now... */\n\t/* SCTP_FREE(authinfo, SCTP_M_AUTH_??); */\n}\n\n\nuint32_t\nsctp_get_auth_chunk_len(uint16_t hmac_algo)\n{\n\tint size;\n\n\tsize = sizeof(struct sctp_auth_chunk) + sctp_get_hmac_digest_len(hmac_algo);\n\treturn (SCTP_SIZE32(size));\n}\n\nuint32_t\nsctp_get_hmac_digest_len(uint16_t hmac_algo)\n{\n\tswitch (hmac_algo) {\n\tcase SCTP_AUTH_HMAC_ID_SHA1:\n\t\treturn (SCTP_AUTH_DIGEST_LEN_SHA1);\n#if defined(SCTP_SUPPORT_HMAC_SHA256)\n\tcase SCTP_AUTH_HMAC_ID_SHA256:\n\t\treturn (SCTP_AUTH_DIGEST_LEN_SHA256);\n#endif\n\tdefault:\n\t\t/* unknown HMAC algorithm: can't do anything */\n\t\treturn (0);\n\t} /* end switch */\n}\n\nstatic inline int\nsctp_get_hmac_block_len(uint16_t hmac_algo)\n{\n\tswitch (hmac_algo) {\n\tcase SCTP_AUTH_HMAC_ID_SHA1:\n\t\treturn (64);\n#if defined(SCTP_SUPPORT_HMAC_SHA256)\n\tcase SCTP_AUTH_HMAC_ID_SHA256:\n\t\treturn (64);\n#endif\n\tcase SCTP_AUTH_HMAC_ID_RSVD:\n\tdefault:\n\t\t/* unknown HMAC algorithm: can't do anything */\n\t\treturn (0);\n\t} /* end switch */\n}\n\n#if defined(__Userspace__)\n/* __Userspace__ SHA1_Init is defined in libcrypto.a (libssl-dev on Ubuntu) */\n#endif\nstatic void\nsctp_hmac_init(uint16_t hmac_algo, sctp_hash_context_t *ctx)\n{\n\tswitch (hmac_algo) {\n\tcase SCTP_AUTH_HMAC_ID_SHA1:\n\t\tSCTP_SHA1_INIT(&ctx->sha1);\n\t\tbreak;\n#if defined(SCTP_SUPPORT_HMAC_SHA256)\n\tcase SCTP_AUTH_HMAC_ID_SHA256:\n\t\tSCTP_SHA256_INIT(&ctx->sha256);\n\t\tbreak;\n#endif\n\tcase SCTP_AUTH_HMAC_ID_RSVD:\n\tdefault:\n\t\t/* unknown HMAC algorithm: can't do anything */\n\t\treturn;\n\t} /* end switch */\n}\n\nstatic void\nsctp_hmac_update(uint16_t hmac_algo, sctp_hash_context_t *ctx,\n    uint8_t *text, uint32_t textlen)\n{\n\tswitch (hmac_algo) {\n\tcase SCTP_AUTH_HMAC_ID_SHA1:\n\t\tSCTP_SHA1_UPDATE(&ctx->sha1, text, textlen);\n\t\tbreak;\n#if defined(SCTP_SUPPORT_HMAC_SHA256)\n\tcase SCTP_AUTH_HMAC_ID_SHA256:\n\t\tSCTP_SHA256_UPDATE(&ctx->sha256, text, textlen);\n\t\tbreak;\n#endif\n\tcase SCTP_AUTH_HMAC_ID_RSVD:\n\tdefault:\n\t\t/* unknown HMAC algorithm: can't do anything */\n\t\treturn;\n\t} /* end switch */\n}\n\nstatic void\nsctp_hmac_final(uint16_t hmac_algo, sctp_hash_context_t *ctx,\n    uint8_t *digest)\n{\n\tswitch (hmac_algo) {\n\tcase SCTP_AUTH_HMAC_ID_SHA1:\n\t\tSCTP_SHA1_FINAL(digest, &ctx->sha1);\n\t\tbreak;\n#if defined(SCTP_SUPPORT_HMAC_SHA256)\n\tcase SCTP_AUTH_HMAC_ID_SHA256:\n\t\tSCTP_SHA256_FINAL(digest, &ctx->sha256);\n\t\tbreak;\n#endif\n\tcase SCTP_AUTH_HMAC_ID_RSVD:\n\tdefault:\n\t\t/* unknown HMAC algorithm: can't do anything */\n\t\treturn;\n\t} /* end switch */\n}\n\n/*-\n * Keyed-Hashing for Message Authentication: FIPS 198 (RFC 2104)\n *\n * Compute the HMAC digest using the desired hash key, text, and HMAC\n * algorithm.  Resulting digest is placed in 'digest' and digest length\n * is returned, if the HMAC was performed.\n *\n * WARNING: it is up to the caller to supply sufficient space to hold the\n * resultant digest.\n */\nuint32_t\nsctp_hmac(uint16_t hmac_algo, uint8_t *key, uint32_t keylen,\n    uint8_t *text, uint32_t textlen, uint8_t *digest)\n{\n\tuint32_t digestlen;\n\tuint32_t blocklen;\n\tsctp_hash_context_t ctx;\n\tuint8_t ipad[128], opad[128];\t/* keyed hash inner/outer pads */\n\tuint8_t temp[SCTP_AUTH_DIGEST_LEN_MAX];\n\tuint32_t i;\n\n\t/* sanity check the material and length */\n\tif ((key == NULL) || (keylen == 0) || (text == NULL) ||\n\t    (textlen == 0) || (digest == NULL)) {\n\t\t/* can't do HMAC with empty key or text or digest store */\n\t\treturn (0);\n\t}\n\t/* validate the hmac algo and get the digest length */\n\tdigestlen = sctp_get_hmac_digest_len(hmac_algo);\n\tif (digestlen == 0)\n\t\treturn (0);\n\n\t/* hash the key if it is longer than the hash block size */\n\tblocklen = sctp_get_hmac_block_len(hmac_algo);\n\tif (keylen > blocklen) {\n\t\tsctp_hmac_init(hmac_algo, &ctx);\n\t\tsctp_hmac_update(hmac_algo, &ctx, key, keylen);\n\t\tsctp_hmac_final(hmac_algo, &ctx, temp);\n\t\t/* set the hashed key as the key */\n\t\tkeylen = digestlen;\n\t\tkey = temp;\n\t}\n\t/* initialize the inner/outer pads with the key and \"append\" zeroes */\n\tmemset(ipad, 0, blocklen);\n\tmemset(opad, 0, blocklen);\n\tmemcpy(ipad, key, keylen);\n\tmemcpy(opad, key, keylen);\n\n\t/* XOR the key with ipad and opad values */\n\tfor (i = 0; i < blocklen; i++) {\n\t\tipad[i] ^= 0x36;\n\t\topad[i] ^= 0x5c;\n\t}\n\n\t/* perform inner hash */\n\tsctp_hmac_init(hmac_algo, &ctx);\n\tsctp_hmac_update(hmac_algo, &ctx, ipad, blocklen);\n\tsctp_hmac_update(hmac_algo, &ctx, text, textlen);\n\tsctp_hmac_final(hmac_algo, &ctx, temp);\n\n\t/* perform outer hash */\n\tsctp_hmac_init(hmac_algo, &ctx);\n\tsctp_hmac_update(hmac_algo, &ctx, opad, blocklen);\n\tsctp_hmac_update(hmac_algo, &ctx, temp, digestlen);\n\tsctp_hmac_final(hmac_algo, &ctx, digest);\n\n\treturn (digestlen);\n}\n\n/* mbuf version */\nuint32_t\nsctp_hmac_m(uint16_t hmac_algo, uint8_t *key, uint32_t keylen,\n    struct mbuf *m, uint32_t m_offset, uint8_t *digest, uint32_t trailer)\n{\n\tuint32_t digestlen;\n\tuint32_t blocklen;\n\tsctp_hash_context_t ctx;\n\tuint8_t ipad[128], opad[128];\t/* keyed hash inner/outer pads */\n\tuint8_t temp[SCTP_AUTH_DIGEST_LEN_MAX];\n\tuint32_t i;\n\tstruct mbuf *m_tmp;\n\n\t/* sanity check the material and length */\n\tif ((key == NULL) || (keylen == 0) || (m == NULL) || (digest == NULL)) {\n\t\t/* can't do HMAC with empty key or text or digest store */\n\t\treturn (0);\n\t}\n\t/* validate the hmac algo and get the digest length */\n\tdigestlen = sctp_get_hmac_digest_len(hmac_algo);\n\tif (digestlen == 0)\n\t\treturn (0);\n\n\t/* hash the key if it is longer than the hash block size */\n\tblocklen = sctp_get_hmac_block_len(hmac_algo);\n\tif (keylen > blocklen) {\n\t\tsctp_hmac_init(hmac_algo, &ctx);\n\t\tsctp_hmac_update(hmac_algo, &ctx, key, keylen);\n\t\tsctp_hmac_final(hmac_algo, &ctx, temp);\n\t\t/* set the hashed key as the key */\n\t\tkeylen = digestlen;\n\t\tkey = temp;\n\t}\n\t/* initialize the inner/outer pads with the key and \"append\" zeroes */\n\tmemset(ipad, 0, blocklen);\n\tmemset(opad, 0, blocklen);\n\tmemcpy(ipad, key, keylen);\n\tmemcpy(opad, key, keylen);\n\n\t/* XOR the key with ipad and opad values */\n\tfor (i = 0; i < blocklen; i++) {\n\t\tipad[i] ^= 0x36;\n\t\topad[i] ^= 0x5c;\n\t}\n\n\t/* perform inner hash */\n\tsctp_hmac_init(hmac_algo, &ctx);\n\tsctp_hmac_update(hmac_algo, &ctx, ipad, blocklen);\n\t/* find the correct starting mbuf and offset (get start of text) */\n\tm_tmp = m;\n\twhile ((m_tmp != NULL) && (m_offset >= (uint32_t) SCTP_BUF_LEN(m_tmp))) {\n\t\tm_offset -= SCTP_BUF_LEN(m_tmp);\n\t\tm_tmp = SCTP_BUF_NEXT(m_tmp);\n\t}\n\t/* now use the rest of the mbuf chain for the text */\n\twhile (m_tmp != NULL) {\n\t\tif ((SCTP_BUF_NEXT(m_tmp) == NULL) && trailer) {\n\t\t\tsctp_hmac_update(hmac_algo, &ctx, mtod(m_tmp, uint8_t *) + m_offset,\n\t\t\t\t\t SCTP_BUF_LEN(m_tmp) - (trailer+m_offset));\n\t\t} else {\n\t\t\tsctp_hmac_update(hmac_algo, &ctx, mtod(m_tmp, uint8_t *) + m_offset,\n\t\t\t\t\t SCTP_BUF_LEN(m_tmp) - m_offset);\n\t\t}\n\n\t\t/* clear the offset since it's only for the first mbuf */\n\t\tm_offset = 0;\n\t\tm_tmp = SCTP_BUF_NEXT(m_tmp);\n\t}\n\tsctp_hmac_final(hmac_algo, &ctx, temp);\n\n\t/* perform outer hash */\n\tsctp_hmac_init(hmac_algo, &ctx);\n\tsctp_hmac_update(hmac_algo, &ctx, opad, blocklen);\n\tsctp_hmac_update(hmac_algo, &ctx, temp, digestlen);\n\tsctp_hmac_final(hmac_algo, &ctx, digest);\n\n\treturn (digestlen);\n}\n\n/*\n * computes the requested HMAC using a key struct (which may be modified if\n * the keylen exceeds the HMAC block len).\n */\nuint32_t\nsctp_compute_hmac(uint16_t hmac_algo, sctp_key_t *key, uint8_t *text,\n    uint32_t textlen, uint8_t *digest)\n{\n\tuint32_t digestlen;\n\tuint32_t blocklen;\n\tsctp_hash_context_t ctx;\n\tuint8_t temp[SCTP_AUTH_DIGEST_LEN_MAX];\n\n\t/* sanity check */\n\tif ((key == NULL) || (text == NULL) || (textlen == 0) ||\n\t    (digest == NULL)) {\n\t\t/* can't do HMAC with empty key or text or digest store */\n\t\treturn (0);\n\t}\n\t/* validate the hmac algo and get the digest length */\n\tdigestlen = sctp_get_hmac_digest_len(hmac_algo);\n\tif (digestlen == 0)\n\t\treturn (0);\n\n\t/* hash the key if it is longer than the hash block size */\n\tblocklen = sctp_get_hmac_block_len(hmac_algo);\n\tif (key->keylen > blocklen) {\n\t\tsctp_hmac_init(hmac_algo, &ctx);\n\t\tsctp_hmac_update(hmac_algo, &ctx, key->key, key->keylen);\n\t\tsctp_hmac_final(hmac_algo, &ctx, temp);\n\t\t/* save the hashed key as the new key */\n\t\tkey->keylen = digestlen;\n\t\tmemcpy(key->key, temp, key->keylen);\n\t}\n\treturn (sctp_hmac(hmac_algo, key->key, key->keylen, text, textlen,\n\t    digest));\n}\n\n/* mbuf version */\nuint32_t\nsctp_compute_hmac_m(uint16_t hmac_algo, sctp_key_t *key, struct mbuf *m,\n    uint32_t m_offset, uint8_t *digest)\n{\n\tuint32_t digestlen;\n\tuint32_t blocklen;\n\tsctp_hash_context_t ctx;\n\tuint8_t temp[SCTP_AUTH_DIGEST_LEN_MAX];\n\n\t/* sanity check */\n\tif ((key == NULL) || (m == NULL) || (digest == NULL)) {\n\t\t/* can't do HMAC with empty key or text or digest store */\n\t\treturn (0);\n\t}\n\t/* validate the hmac algo and get the digest length */\n\tdigestlen = sctp_get_hmac_digest_len(hmac_algo);\n\tif (digestlen == 0)\n\t\treturn (0);\n\n\t/* hash the key if it is longer than the hash block size */\n\tblocklen = sctp_get_hmac_block_len(hmac_algo);\n\tif (key->keylen > blocklen) {\n\t\tsctp_hmac_init(hmac_algo, &ctx);\n\t\tsctp_hmac_update(hmac_algo, &ctx, key->key, key->keylen);\n\t\tsctp_hmac_final(hmac_algo, &ctx, temp);\n\t\t/* save the hashed key as the new key */\n\t\tkey->keylen = digestlen;\n\t\tmemcpy(key->key, temp, key->keylen);\n\t}\n\treturn (sctp_hmac_m(hmac_algo, key->key, key->keylen, m, m_offset, digest, 0));\n}\n\nint\nsctp_auth_is_supported_hmac(sctp_hmaclist_t *list, uint16_t id)\n{\n\tint i;\n\n\tif ((list == NULL) || (id == SCTP_AUTH_HMAC_ID_RSVD))\n\t\treturn (0);\n\n\tfor (i = 0; i < list->num_algo; i++)\n\t\tif (list->hmac[i] == id)\n\t\t\treturn (1);\n\n\t/* not in the list */\n\treturn (0);\n}\n\n\n/*-\n * clear any cached key(s) if they match the given key id on an association.\n * the cached key(s) will be recomputed and re-cached at next use.\n * ASSUMES TCB_LOCK is already held\n */\nvoid\nsctp_clear_cachedkeys(struct sctp_tcb *stcb, uint16_t keyid)\n{\n\tif (stcb == NULL)\n\t\treturn;\n\n\tif (keyid == stcb->asoc.authinfo.assoc_keyid) {\n\t\tsctp_free_key(stcb->asoc.authinfo.assoc_key);\n\t\tstcb->asoc.authinfo.assoc_key = NULL;\n\t}\n\tif (keyid == stcb->asoc.authinfo.recv_keyid) {\n\t\tsctp_free_key(stcb->asoc.authinfo.recv_key);\n\t\tstcb->asoc.authinfo.recv_key = NULL;\n\t}\n}\n\n/*-\n * clear any cached key(s) if they match the given key id for all assocs on\n * an endpoint.\n * ASSUMES INP_WLOCK is already held\n */\nvoid\nsctp_clear_cachedkeys_ep(struct sctp_inpcb *inp, uint16_t keyid)\n{\n\tstruct sctp_tcb *stcb;\n\n\tif (inp == NULL)\n\t\treturn;\n\n\t/* clear the cached keys on all assocs on this instance */\n\tLIST_FOREACH(stcb, &inp->sctp_asoc_list, sctp_tcblist) {\n\t\tSCTP_TCB_LOCK(stcb);\n\t\tsctp_clear_cachedkeys(stcb, keyid);\n\t\tSCTP_TCB_UNLOCK(stcb);\n\t}\n}\n\n/*-\n * delete a shared key from an association\n * ASSUMES TCB_LOCK is already held\n */\nint\nsctp_delete_sharedkey(struct sctp_tcb *stcb, uint16_t keyid)\n{\n\tsctp_sharedkey_t *skey;\n\n\tif (stcb == NULL)\n\t\treturn (-1);\n\n\t/* is the keyid the assoc active sending key */\n\tif (keyid == stcb->asoc.authinfo.active_keyid)\n\t\treturn (-1);\n\n\t/* does the key exist? */\n\tskey = sctp_find_sharedkey(&stcb->asoc.shared_keys, keyid);\n\tif (skey == NULL)\n\t\treturn (-1);\n\n\t/* are there other refcount holders on the key? */\n\tif (skey->refcount > 1)\n\t\treturn (-1);\n\n\t/* remove it */\n\tLIST_REMOVE(skey, next);\n\tsctp_free_sharedkey(skey);\t/* frees skey->key as well */\n\n\t/* clear any cached keys */\n\tsctp_clear_cachedkeys(stcb, keyid);\n\treturn (0);\n}\n\n/*-\n * deletes a shared key from the endpoint\n * ASSUMES INP_WLOCK is already held\n */\nint\nsctp_delete_sharedkey_ep(struct sctp_inpcb *inp, uint16_t keyid)\n{\n\tsctp_sharedkey_t *skey;\n\n\tif (inp == NULL)\n\t\treturn (-1);\n\n\t/* is the keyid the active sending key on the endpoint */\n\tif (keyid == inp->sctp_ep.default_keyid)\n\t\treturn (-1);\n\n\t/* does the key exist? */\n\tskey = sctp_find_sharedkey(&inp->sctp_ep.shared_keys, keyid);\n\tif (skey == NULL)\n\t\treturn (-1);\n\n\t/* endpoint keys are not refcounted */\n\n\t/* remove it */\n\tLIST_REMOVE(skey, next);\n\tsctp_free_sharedkey(skey);\t/* frees skey->key as well */\n\n\t/* clear any cached keys */\n\tsctp_clear_cachedkeys_ep(inp, keyid);\n\treturn (0);\n}\n\n/*-\n * set the active key on an association\n * ASSUMES TCB_LOCK is already held\n */\nint\nsctp_auth_setactivekey(struct sctp_tcb *stcb, uint16_t keyid)\n{\n\tsctp_sharedkey_t *skey = NULL;\n\n\t/* find the key on the assoc */\n\tskey = sctp_find_sharedkey(&stcb->asoc.shared_keys, keyid);\n\tif (skey == NULL) {\n\t\t/* that key doesn't exist */\n\t\treturn (-1);\n\t}\n\tif ((skey->deactivated) && (skey->refcount > 1)) {\n\t\t/* can't reactivate a deactivated key with other refcounts */\n\t\treturn (-1);\n\t}\n\n\t/* set the (new) active key */\n\tstcb->asoc.authinfo.active_keyid = keyid;\n\t/* reset the deactivated flag */\n\tskey->deactivated = 0;\n\n\treturn (0);\n}\n\n/*-\n * set the active key on an endpoint\n * ASSUMES INP_WLOCK is already held\n */\nint\nsctp_auth_setactivekey_ep(struct sctp_inpcb *inp, uint16_t keyid)\n{\n\tsctp_sharedkey_t *skey;\n\n\t/* find the key */\n\tskey = sctp_find_sharedkey(&inp->sctp_ep.shared_keys, keyid);\n\tif (skey == NULL) {\n\t\t/* that key doesn't exist */\n\t\treturn (-1);\n\t}\n\tinp->sctp_ep.default_keyid = keyid;\n\treturn (0);\n}\n\n/*-\n * deactivates a shared key from the association\n * ASSUMES INP_WLOCK is already held\n */\nint\nsctp_deact_sharedkey(struct sctp_tcb *stcb, uint16_t keyid)\n{\n\tsctp_sharedkey_t *skey;\n\n\tif (stcb == NULL)\n\t\treturn (-1);\n\n\t/* is the keyid the assoc active sending key */\n\tif (keyid == stcb->asoc.authinfo.active_keyid)\n\t\treturn (-1);\n\n\t/* does the key exist? */\n\tskey = sctp_find_sharedkey(&stcb->asoc.shared_keys, keyid);\n\tif (skey == NULL)\n\t\treturn (-1);\n\n\t/* are there other refcount holders on the key? */\n\tif (skey->refcount == 1) {\n\t\t/* no other users, send a notification for this key */\n\t\tsctp_ulp_notify(SCTP_NOTIFY_AUTH_FREE_KEY, stcb, keyid, 0,\n\t\t\t\tSCTP_SO_LOCKED);\n\t}\n\n\t/* mark the key as deactivated */\n\tskey->deactivated = 1;\n\n\treturn (0);\n}\n\n/*-\n * deactivates a shared key from the endpoint\n * ASSUMES INP_WLOCK is already held\n */\nint\nsctp_deact_sharedkey_ep(struct sctp_inpcb *inp, uint16_t keyid)\n{\n\tsctp_sharedkey_t *skey;\n\n\tif (inp == NULL)\n\t\treturn (-1);\n\n\t/* is the keyid the active sending key on the endpoint */\n\tif (keyid == inp->sctp_ep.default_keyid)\n\t\treturn (-1);\n\n\t/* does the key exist? */\n\tskey = sctp_find_sharedkey(&inp->sctp_ep.shared_keys, keyid);\n\tif (skey == NULL)\n\t\treturn (-1);\n\n\t/* endpoint keys are not refcounted */\n\n\t/* remove it */\n\tLIST_REMOVE(skey, next);\n\tsctp_free_sharedkey(skey);\t/* frees skey->key as well */\n\n\treturn (0);\n}\n\n/*\n * get local authentication parameters from cookie (from INIT-ACK)\n */\nvoid\nsctp_auth_get_cookie_params(struct sctp_tcb *stcb, struct mbuf *m,\n    uint32_t offset, uint32_t length)\n{\n\tstruct sctp_paramhdr *phdr, tmp_param;\n\tuint16_t plen, ptype;\n\tuint8_t random_store[SCTP_PARAM_BUFFER_SIZE];\n\tstruct sctp_auth_random *p_random = NULL;\n\tuint16_t random_len = 0;\n\tuint8_t hmacs_store[SCTP_PARAM_BUFFER_SIZE];\n\tstruct sctp_auth_hmac_algo *hmacs = NULL;\n\tuint16_t hmacs_len = 0;\n\tuint8_t chunks_store[SCTP_PARAM_BUFFER_SIZE];\n\tstruct sctp_auth_chunk_list *chunks = NULL;\n\tuint16_t num_chunks = 0;\n\tsctp_key_t *new_key;\n\tuint32_t keylen;\n\n\t/* convert to upper bound */\n\tlength += offset;\n\n\tphdr = (struct sctp_paramhdr *)sctp_m_getptr(m, offset,\n\t    sizeof(struct sctp_paramhdr), (uint8_t *)&tmp_param);\n\twhile (phdr != NULL) {\n\t\tptype = ntohs(phdr->param_type);\n\t\tplen = ntohs(phdr->param_length);\n\n\t\tif ((plen < sizeof(struct sctp_paramhdr)) ||\n\t\t    (offset + plen > length))\n\t\t\tbreak;\n\n\t\tif (ptype == SCTP_RANDOM) {\n\t\t\tif (plen > sizeof(random_store))\n\t\t\t\tbreak;\n\t\t\tphdr = sctp_get_next_param(m, offset,\n\t\t\t    (struct sctp_paramhdr *)random_store, plen);\n\t\t\tif (phdr == NULL)\n\t\t\t\treturn;\n\t\t\t/* save the random and length for the key */\n\t\t\tp_random = (struct sctp_auth_random *)phdr;\n\t\t\trandom_len = plen - sizeof(*p_random);\n\t\t} else if (ptype == SCTP_HMAC_LIST) {\n\t\t\tuint16_t num_hmacs;\n\t\t\tuint16_t i;\n\n\t\t\tif (plen > sizeof(hmacs_store))\n\t\t\t\tbreak;\n\t\t\tphdr = sctp_get_next_param(m, offset,\n\t\t\t    (struct sctp_paramhdr *)hmacs_store, plen);\n\t\t\tif (phdr == NULL)\n\t\t\t\treturn;\n\t\t\t/* save the hmacs list and num for the key */\n\t\t\thmacs = (struct sctp_auth_hmac_algo *)phdr;\n\t\t\thmacs_len = plen - sizeof(*hmacs);\n\t\t\tnum_hmacs = hmacs_len / sizeof(hmacs->hmac_ids[0]);\n\t\t\tif (stcb->asoc.local_hmacs != NULL)\n\t\t\t\tsctp_free_hmaclist(stcb->asoc.local_hmacs);\n\t\t\tstcb->asoc.local_hmacs = sctp_alloc_hmaclist(num_hmacs);\n\t\t\tif (stcb->asoc.local_hmacs != NULL) {\n\t\t\t\tfor (i = 0; i < num_hmacs; i++) {\n\t\t\t\t\t(void)sctp_auth_add_hmacid(stcb->asoc.local_hmacs,\n\t\t\t\t\t    ntohs(hmacs->hmac_ids[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (ptype == SCTP_CHUNK_LIST) {\n\t\t\tint i;\n\n\t\t\tif (plen > sizeof(chunks_store))\n\t\t\t\tbreak;\n\t\t\tphdr = sctp_get_next_param(m, offset,\n\t\t\t    (struct sctp_paramhdr *)chunks_store, plen);\n\t\t\tif (phdr == NULL)\n\t\t\t\treturn;\n\t\t\tchunks = (struct sctp_auth_chunk_list *)phdr;\n\t\t\tnum_chunks = plen - sizeof(*chunks);\n\t\t\t/* save chunks list and num for the key */\n\t\t\tif (stcb->asoc.local_auth_chunks != NULL)\n\t\t\t\tsctp_clear_chunklist(stcb->asoc.local_auth_chunks);\n\t\t\telse\n\t\t\t\tstcb->asoc.local_auth_chunks = sctp_alloc_chunklist();\n\t\t\tfor (i = 0; i < num_chunks; i++) {\n\t\t\t\t(void)sctp_auth_add_chunk(chunks->chunk_types[i],\n\t\t\t\t    stcb->asoc.local_auth_chunks);\n\t\t\t}\n\t\t}\n\t\t/* get next parameter */\n\t\toffset += SCTP_SIZE32(plen);\n\t\tif (offset + sizeof(struct sctp_paramhdr) > length)\n\t\t\tbreak;\n\t\tphdr = (struct sctp_paramhdr *)sctp_m_getptr(m, offset, sizeof(struct sctp_paramhdr),\n\t\t    (uint8_t *)&tmp_param);\n\t}\n\t/* concatenate the full random key */\n\tkeylen = sizeof(*p_random) + random_len + sizeof(*hmacs) + hmacs_len;\n\tif (chunks != NULL) {\n\t\tkeylen += sizeof(*chunks) + num_chunks;\n\t}\n\tnew_key = sctp_alloc_key(keylen);\n\tif (new_key != NULL) {\n\t\t/* copy in the RANDOM */\n\t\tif (p_random != NULL) {\n\t\t\tkeylen = sizeof(*p_random) + random_len;\n\t\t\tmemcpy(new_key->key, p_random, keylen);\n\t\t} else {\n\t\t\tkeylen = 0;\n\t\t}\n\t\t/* append in the AUTH chunks */\n\t\tif (chunks != NULL) {\n\t\t\tmemcpy(new_key->key + keylen, chunks,\n\t\t\t       sizeof(*chunks) + num_chunks);\n\t\t\tkeylen += sizeof(*chunks) + num_chunks;\n\t\t}\n\t\t/* append in the HMACs */\n\t\tif (hmacs != NULL) {\n\t\t\tmemcpy(new_key->key + keylen, hmacs,\n\t\t\t       sizeof(*hmacs) + hmacs_len);\n\t\t}\n\t}\n\tif (stcb->asoc.authinfo.random != NULL)\n\t\tsctp_free_key(stcb->asoc.authinfo.random);\n\tstcb->asoc.authinfo.random = new_key;\n\tstcb->asoc.authinfo.random_len = random_len;\n\tsctp_clear_cachedkeys(stcb, stcb->asoc.authinfo.assoc_keyid);\n\tsctp_clear_cachedkeys(stcb, stcb->asoc.authinfo.recv_keyid);\n\n\t/* negotiate what HMAC to use for the peer */\n\tstcb->asoc.peer_hmac_id = sctp_negotiate_hmacid(stcb->asoc.peer_hmacs,\n\t    stcb->asoc.local_hmacs);\n\n\t/* copy defaults from the endpoint */\n\t/* FIX ME: put in cookie? */\n\tstcb->asoc.authinfo.active_keyid = stcb->sctp_ep->sctp_ep.default_keyid;\n\t/* copy out the shared key list (by reference) from the endpoint */\n\t(void)sctp_copy_skeylist(&stcb->sctp_ep->sctp_ep.shared_keys,\n\t\t\t\t &stcb->asoc.shared_keys);\n}\n\n/*\n * compute and fill in the HMAC digest for a packet\n */\nvoid\nsctp_fill_hmac_digest_m(struct mbuf *m, uint32_t auth_offset,\n    struct sctp_auth_chunk *auth, struct sctp_tcb *stcb, uint16_t keyid)\n{\n\tuint32_t digestlen;\n\tsctp_sharedkey_t *skey;\n\tsctp_key_t *key;\n\n\tif ((stcb == NULL) || (auth == NULL))\n\t\treturn;\n\n\t/* zero the digest + chunk padding */\n\tdigestlen = sctp_get_hmac_digest_len(stcb->asoc.peer_hmac_id);\n\tmemset(auth->hmac, 0, SCTP_SIZE32(digestlen));\n\n\t/* is the desired key cached? */\n\tif ((keyid != stcb->asoc.authinfo.assoc_keyid) ||\n\t    (stcb->asoc.authinfo.assoc_key == NULL)) {\n\t\tif (stcb->asoc.authinfo.assoc_key != NULL) {\n\t\t\t/* free the old cached key */\n\t\t\tsctp_free_key(stcb->asoc.authinfo.assoc_key);\n\t\t}\n\t\tskey = sctp_find_sharedkey(&stcb->asoc.shared_keys, keyid);\n\t\t/* the only way skey is NULL is if null key id 0 is used */\n\t\tif (skey != NULL)\n\t\t\tkey = skey->key;\n\t\telse\n\t\t\tkey = NULL;\n\t\t/* compute a new assoc key and cache it */\n\t\tstcb->asoc.authinfo.assoc_key =\n\t\t    sctp_compute_hashkey(stcb->asoc.authinfo.random,\n\t\t\t\t\t stcb->asoc.authinfo.peer_random, key);\n\t\tstcb->asoc.authinfo.assoc_keyid = keyid;\n\t\tSCTPDBG(SCTP_DEBUG_AUTH1, \"caching key id %u\\n\",\n\t\t\tstcb->asoc.authinfo.assoc_keyid);\n#ifdef SCTP_DEBUG\n\t\tif (SCTP_AUTH_DEBUG)\n\t\t\tsctp_print_key(stcb->asoc.authinfo.assoc_key,\n\t\t\t\t       \"Assoc Key\");\n#endif\n\t}\n\n\t/* set in the active key id */\n\tauth->shared_key_id = htons(keyid);\n\n\t/* compute and fill in the digest */\n\t(void)sctp_compute_hmac_m(stcb->asoc.peer_hmac_id, stcb->asoc.authinfo.assoc_key,\n\t\t\t\t  m, auth_offset, auth->hmac);\n}\n\n\nstatic void\nsctp_zero_m(struct mbuf *m, uint32_t m_offset, uint32_t size)\n{\n\tstruct mbuf *m_tmp;\n\tuint8_t *data;\n\n\t/* sanity check */\n\tif (m == NULL)\n\t\treturn;\n\n\t/* find the correct starting mbuf and offset (get start position) */\n\tm_tmp = m;\n\twhile ((m_tmp != NULL) && (m_offset >= (uint32_t) SCTP_BUF_LEN(m_tmp))) {\n\t\tm_offset -= SCTP_BUF_LEN(m_tmp);\n\t\tm_tmp = SCTP_BUF_NEXT(m_tmp);\n\t}\n\t/* now use the rest of the mbuf chain */\n\twhile ((m_tmp != NULL) && (size > 0)) {\n\t\tdata = mtod(m_tmp, uint8_t *) + m_offset;\n\t\tif (size > (uint32_t)(SCTP_BUF_LEN(m_tmp) - m_offset)) {\n\t\t\tmemset(data, 0, SCTP_BUF_LEN(m_tmp) - m_offset);\n\t\t\tsize -= SCTP_BUF_LEN(m_tmp) - m_offset;\n\t\t} else {\n\t\t\tmemset(data, 0, size);\n\t\t\tsize = 0;\n\t\t}\n\t\t/* clear the offset since it's only for the first mbuf */\n\t\tm_offset = 0;\n\t\tm_tmp = SCTP_BUF_NEXT(m_tmp);\n\t}\n}\n\n/*-\n * process the incoming Authentication chunk\n * return codes:\n *   -1 on any authentication error\n *    0 on authentication verification\n */\nint\nsctp_handle_auth(struct sctp_tcb *stcb, struct sctp_auth_chunk *auth,\n    struct mbuf *m, uint32_t offset)\n{\n\tuint16_t chunklen;\n\tuint16_t shared_key_id;\n\tuint16_t hmac_id;\n\tsctp_sharedkey_t *skey;\n\tuint32_t digestlen;\n\tuint8_t digest[SCTP_AUTH_DIGEST_LEN_MAX];\n\tuint8_t computed_digest[SCTP_AUTH_DIGEST_LEN_MAX];\n\n\t/* auth is checked for NULL by caller */\n\tchunklen = ntohs(auth->ch.chunk_length);\n\tif (chunklen < sizeof(*auth)) {\n\t\tSCTP_STAT_INCR(sctps_recvauthfailed);\n\t\treturn (-1);\n\t}\n\tSCTP_STAT_INCR(sctps_recvauth);\n\n\t/* get the auth params */\n\tshared_key_id = ntohs(auth->shared_key_id);\n\thmac_id = ntohs(auth->hmac_id);\n\tSCTPDBG(SCTP_DEBUG_AUTH1,\n\t\t\"SCTP AUTH Chunk: shared key %u, HMAC id %u\\n\",\n\t\tshared_key_id, hmac_id);\n\n\t/* is the indicated HMAC supported? */\n\tif (!sctp_auth_is_supported_hmac(stcb->asoc.local_hmacs, hmac_id)) {\n\t\tstruct mbuf *op_err;\n\t\tstruct sctp_error_auth_invalid_hmac *cause;\n\n\t\tSCTP_STAT_INCR(sctps_recvivalhmacid);\n\t\tSCTPDBG(SCTP_DEBUG_AUTH1,\n\t\t\t\"SCTP Auth: unsupported HMAC id %u\\n\",\n\t\t\thmac_id);\n\t\t/*\n\t\t * report this in an Error Chunk: Unsupported HMAC\n\t\t * Identifier\n\t\t */\n\t\top_err = sctp_get_mbuf_for_msg(sizeof(struct sctp_error_auth_invalid_hmac),\n\t\t                               0, M_NOWAIT, 1, MT_HEADER);\n\t\tif (op_err != NULL) {\n\t\t\t/* pre-reserve some space */\n\t\t\tSCTP_BUF_RESV_UF(op_err, sizeof(struct sctp_chunkhdr));\n\t\t\t/* fill in the error */\n\t\t\tcause = mtod(op_err, struct sctp_error_auth_invalid_hmac *);\n\t\t\tcause->cause.code = htons(SCTP_CAUSE_UNSUPPORTED_HMACID);\n\t\t\tcause->cause.length = htons(sizeof(struct sctp_error_auth_invalid_hmac));\n\t\t\tcause->hmac_id = ntohs(hmac_id);\n\t\t\tSCTP_BUF_LEN(op_err) = sizeof(struct sctp_error_auth_invalid_hmac);\n\t\t\t/* queue it */\n\t\t\tsctp_queue_op_err(stcb, op_err);\n\t\t}\n\t\treturn (-1);\n\t}\n\t/* get the indicated shared key, if available */\n\tif ((stcb->asoc.authinfo.recv_key == NULL) ||\n\t    (stcb->asoc.authinfo.recv_keyid != shared_key_id)) {\n\t\t/* find the shared key on the assoc first */\n\t\tskey = sctp_find_sharedkey(&stcb->asoc.shared_keys,\n\t\t\t\t\t   shared_key_id);\n\t\t/* if the shared key isn't found, discard the chunk */\n\t\tif (skey == NULL) {\n\t\t\tSCTP_STAT_INCR(sctps_recvivalkeyid);\n\t\t\tSCTPDBG(SCTP_DEBUG_AUTH1,\n\t\t\t\t\"SCTP Auth: unknown key id %u\\n\",\n\t\t\t\tshared_key_id);\n\t\t\treturn (-1);\n\t\t}\n\t\t/* generate a notification if this is a new key id */\n\t\tif (stcb->asoc.authinfo.recv_keyid != shared_key_id)\n\t\t\t/*\n\t\t\t * sctp_ulp_notify(SCTP_NOTIFY_AUTH_NEW_KEY, stcb,\n\t\t\t * shared_key_id, (void\n\t\t\t * *)stcb->asoc.authinfo.recv_keyid);\n\t\t\t */\n\t\t\tsctp_notify_authentication(stcb, SCTP_AUTH_NEW_KEY,\n\t\t\t    shared_key_id, stcb->asoc.authinfo.recv_keyid,\n\t\t\t    SCTP_SO_NOT_LOCKED);\n\t\t/* compute a new recv assoc key and cache it */\n\t\tif (stcb->asoc.authinfo.recv_key != NULL)\n\t\t\tsctp_free_key(stcb->asoc.authinfo.recv_key);\n\t\tstcb->asoc.authinfo.recv_key =\n\t\t    sctp_compute_hashkey(stcb->asoc.authinfo.random,\n\t\t    stcb->asoc.authinfo.peer_random, skey->key);\n\t\tstcb->asoc.authinfo.recv_keyid = shared_key_id;\n#ifdef SCTP_DEBUG\n\t\tif (SCTP_AUTH_DEBUG)\n\t\t\tsctp_print_key(stcb->asoc.authinfo.recv_key, \"Recv Key\");\n#endif\n\t}\n\t/* validate the digest length */\n\tdigestlen = sctp_get_hmac_digest_len(hmac_id);\n\tif (chunklen < (sizeof(*auth) + digestlen)) {\n\t\t/* invalid digest length */\n\t\tSCTP_STAT_INCR(sctps_recvauthfailed);\n\t\tSCTPDBG(SCTP_DEBUG_AUTH1,\n\t\t\t\"SCTP Auth: chunk too short for HMAC\\n\");\n\t\treturn (-1);\n\t}\n\t/* save a copy of the digest, zero the pseudo header, and validate */\n\tmemcpy(digest, auth->hmac, digestlen);\n\tsctp_zero_m(m, offset + sizeof(*auth), SCTP_SIZE32(digestlen));\n\t(void)sctp_compute_hmac_m(hmac_id, stcb->asoc.authinfo.recv_key,\n\t    m, offset, computed_digest);\n\n#if defined(__Userspace__)\n#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n\treturn (0);\n#endif\n#endif\n\t/* compare the computed digest with the one in the AUTH chunk */\n\tif (timingsafe_bcmp(digest, computed_digest, digestlen) != 0) {\n\t\tSCTP_STAT_INCR(sctps_recvauthfailed);\n\t\tSCTPDBG(SCTP_DEBUG_AUTH1,\n\t\t\t\"SCTP Auth: HMAC digest check failed\\n\");\n\t\treturn (-1);\n\t}\n\treturn (0);\n}\n\n/*\n * Generate NOTIFICATION\n */\nvoid\nsctp_notify_authentication(struct sctp_tcb *stcb, uint32_t indication,\n\t\t\t   uint16_t keyid, uint16_t alt_keyid, int so_locked\n#if !defined(__APPLE__) && !defined(SCTP_SO_LOCK_TESTING)\n\tSCTP_UNUSED\n#endif\n)\n{\n\tstruct mbuf *m_notify;\n\tstruct sctp_authkey_event *auth;\n\tstruct sctp_queued_to_read *control;\n\n\tif ((stcb == NULL) ||\n\t   (stcb->sctp_ep->sctp_flags & SCTP_PCB_FLAGS_SOCKET_GONE) ||\n\t   (stcb->sctp_ep->sctp_flags & SCTP_PCB_FLAGS_SOCKET_ALLGONE) ||\n\t   (stcb->asoc.state & SCTP_STATE_CLOSED_SOCKET)\n\t\t) {\n\t\t/* If the socket is gone we are out of here */\n\t\treturn;\n\t}\n\n\tif (sctp_stcb_is_feature_off(stcb->sctp_ep, stcb, SCTP_PCB_FLAGS_AUTHEVNT))\n\t\t/* event not enabled */\n\t\treturn;\n\n\tm_notify = sctp_get_mbuf_for_msg(sizeof(struct sctp_authkey_event),\n\t\t\t\t\t  0, M_NOWAIT, 1, MT_HEADER);\n\tif (m_notify == NULL)\n\t\t/* no space left */\n\t\treturn;\n\n\tSCTP_BUF_LEN(m_notify) = 0;\n\tauth = mtod(m_notify, struct sctp_authkey_event *);\n\tmemset(auth, 0, sizeof(struct sctp_authkey_event));\n\tauth->auth_type = SCTP_AUTHENTICATION_EVENT;\n\tauth->auth_flags = 0;\n\tauth->auth_length = sizeof(*auth);\n\tauth->auth_keynumber = keyid;\n\tauth->auth_altkeynumber = alt_keyid;\n\tauth->auth_indication = indication;\n\tauth->auth_assoc_id = sctp_get_associd(stcb);\n\n\tSCTP_BUF_LEN(m_notify) = sizeof(*auth);\n\tSCTP_BUF_NEXT(m_notify) = NULL;\n\n\t/* append to socket */\n\tcontrol = sctp_build_readq_entry(stcb, stcb->asoc.primary_destination,\n\t    0, 0, stcb->asoc.context, 0, 0, 0, m_notify);\n\tif (control == NULL) {\n\t\t/* no memory */\n\t\tsctp_m_freem(m_notify);\n\t\treturn;\n\t}\n\tcontrol->length = SCTP_BUF_LEN(m_notify);\n\tcontrol->spec_flags = M_NOTIFICATION;\n\t/* not that we need this */\n\tcontrol->tail_mbuf = m_notify;\n\tsctp_add_to_readq(stcb->sctp_ep, stcb, control,\n\t    &stcb->sctp_socket->so_rcv, 1, SCTP_READ_LOCK_NOT_HELD, so_locked);\n}\n\n\n/*-\n * validates the AUTHentication related parameters in an INIT/INIT-ACK\n * Note: currently only used for INIT as INIT-ACK is handled inline\n * with sctp_load_addresses_from_init()\n */\nint\nsctp_validate_init_auth_params(struct mbuf *m, int offset, int limit)\n{\n\tstruct sctp_paramhdr *phdr, param_buf;\n\tuint16_t ptype, plen;\n\tint peer_supports_asconf = 0;\n\tint peer_supports_auth = 0;\n\tint got_random = 0, got_hmacs = 0, got_chklist = 0;\n\tuint8_t saw_asconf = 0;\n\tuint8_t saw_asconf_ack = 0;\n\n\t/* go through each of the params. */\n\tphdr = sctp_get_next_param(m, offset, &param_buf, sizeof(param_buf));\n\twhile (phdr) {\n\t\tptype = ntohs(phdr->param_type);\n\t\tplen = ntohs(phdr->param_length);\n\n\t\tif (offset + plen > limit) {\n\t\t\tbreak;\n\t\t}\n\t\tif (plen < sizeof(struct sctp_paramhdr)) {\n\t\t\tbreak;\n\t\t}\n\t\tif (ptype == SCTP_SUPPORTED_CHUNK_EXT) {\n\t\t\t/* A supported extension chunk */\n\t\t\tstruct sctp_supported_chunk_types_param *pr_supported;\n\t\t\tuint8_t local_store[SCTP_SMALL_CHUNK_STORE];\n\t\t\tint num_ent, i;\n\n\t\t\tif (plen > sizeof(local_store)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tphdr = sctp_get_next_param(m, offset,\n\t\t\t                           (struct sctp_paramhdr *)&local_store,\n\t\t\t                           plen);\n\t\t\tif (phdr == NULL) {\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\tpr_supported = (struct sctp_supported_chunk_types_param *)phdr;\n\t\t\tnum_ent = plen - sizeof(struct sctp_paramhdr);\n\t\t\tfor (i = 0; i < num_ent; i++) {\n\t\t\t\tswitch (pr_supported->chunk_types[i]) {\n\t\t\t\tcase SCTP_ASCONF:\n\t\t\t\tcase SCTP_ASCONF_ACK:\n\t\t\t\t\tpeer_supports_asconf = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t/* one we don't care about */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (ptype == SCTP_RANDOM) {\n\t\t\t/* enforce the random length */\n\t\t\tif (plen != (sizeof(struct sctp_auth_random) +\n\t\t\t\t     SCTP_AUTH_RANDOM_SIZE_REQUIRED)) {\n\t\t\t\tSCTPDBG(SCTP_DEBUG_AUTH1,\n\t\t\t\t\t\"SCTP: invalid RANDOM len\\n\");\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\tgot_random = 1;\n\t\t} else if (ptype == SCTP_HMAC_LIST) {\n\t\t\tstruct sctp_auth_hmac_algo *hmacs;\n\t\t\tuint8_t store[SCTP_PARAM_BUFFER_SIZE];\n\t\t\tint num_hmacs;\n\n\t\t\tif (plen > sizeof(store)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tphdr = sctp_get_next_param(m, offset,\n\t\t\t                           (struct sctp_paramhdr *)store,\n\t\t\t                           plen);\n\t\t\tif (phdr == NULL) {\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\thmacs = (struct sctp_auth_hmac_algo *)phdr;\n\t\t\tnum_hmacs = (plen - sizeof(*hmacs)) / sizeof(hmacs->hmac_ids[0]);\n\t\t\t/* validate the hmac list */\n\t\t\tif (sctp_verify_hmac_param(hmacs, num_hmacs)) {\n\t\t\t\tSCTPDBG(SCTP_DEBUG_AUTH1,\n\t\t\t\t\t\"SCTP: invalid HMAC param\\n\");\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\tgot_hmacs = 1;\n\t\t} else if (ptype == SCTP_CHUNK_LIST) {\n\t\t\tstruct sctp_auth_chunk_list *chunks;\n\t\t\tuint8_t chunks_store[SCTP_SMALL_CHUNK_STORE];\n\t\t\tint i, num_chunks;\n\n\t\t\tif (plen > sizeof(chunks_store)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tphdr = sctp_get_next_param(m, offset,\n\t\t\t\t\t\t   (struct sctp_paramhdr *)chunks_store,\n\t\t\t\t\t\t   plen);\n\t\t\tif (phdr == NULL) {\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\t/*-\n\t\t\t * Flip through the list and mark that the\n\t\t\t * peer supports asconf/asconf_ack.\n\t\t\t */\n\t\t\tchunks = (struct sctp_auth_chunk_list *)phdr;\n\t\t\tnum_chunks = plen - sizeof(*chunks);\n\t\t\tfor (i = 0; i < num_chunks; i++) {\n\t\t\t\t/* record asconf/asconf-ack if listed */\n\t\t\t\tif (chunks->chunk_types[i] == SCTP_ASCONF)\n\t\t\t\t\tsaw_asconf = 1;\n\t\t\t\tif (chunks->chunk_types[i] == SCTP_ASCONF_ACK)\n\t\t\t\t\tsaw_asconf_ack = 1;\n\n\t\t\t}\n\t\t\tif (num_chunks)\n\t\t\t\tgot_chklist = 1;\n\t\t}\n\n\t\toffset += SCTP_SIZE32(plen);\n\t\tif (offset >= limit) {\n\t\t\tbreak;\n\t\t}\n\t\tphdr = sctp_get_next_param(m, offset, &param_buf,\n\t\t    sizeof(param_buf));\n\t}\n\t/* validate authentication required parameters */\n\tif (got_random && got_hmacs) {\n\t\tpeer_supports_auth = 1;\n\t} else {\n\t\tpeer_supports_auth = 0;\n\t}\n\tif (!peer_supports_auth && got_chklist) {\n\t\tSCTPDBG(SCTP_DEBUG_AUTH1,\n\t\t\t\"SCTP: peer sent chunk list w/o AUTH\\n\");\n\t\treturn (-1);\n\t}\n\tif (peer_supports_asconf && !peer_supports_auth) {\n\t\tSCTPDBG(SCTP_DEBUG_AUTH1,\n\t\t\t\"SCTP: peer supports ASCONF but not AUTH\\n\");\n\t\treturn (-1);\n\t} else if ((peer_supports_asconf) && (peer_supports_auth) &&\n\t\t   ((saw_asconf == 0) || (saw_asconf_ack == 0))) {\n\t\treturn (-2);\n\t}\n\treturn (0);\n}\n\nvoid\nsctp_initialize_auth_params(struct sctp_inpcb *inp, struct sctp_tcb *stcb)\n{\n\tuint16_t chunks_len = 0;\n\tuint16_t hmacs_len = 0;\n\tuint16_t random_len = SCTP_AUTH_RANDOM_SIZE_DEFAULT;\n\tsctp_key_t *new_key;\n\tuint16_t keylen;\n\n\t/* initialize hmac list from endpoint */\n\tstcb->asoc.local_hmacs = sctp_copy_hmaclist(inp->sctp_ep.local_hmacs);\n\tif (stcb->asoc.local_hmacs != NULL) {\n\t\thmacs_len = stcb->asoc.local_hmacs->num_algo *\n\t\t    sizeof(stcb->asoc.local_hmacs->hmac[0]);\n\t}\n\t/* initialize auth chunks list from endpoint */\n\tstcb->asoc.local_auth_chunks =\n\t    sctp_copy_chunklist(inp->sctp_ep.local_auth_chunks);\n\tif (stcb->asoc.local_auth_chunks != NULL) {\n\t\tint i;\n\t\tfor (i = 0; i < 256; i++) {\n\t\t\tif (stcb->asoc.local_auth_chunks->chunks[i])\n\t\t\t\tchunks_len++;\n\t\t}\n\t}\n\t/* copy defaults from the endpoint */\n\tstcb->asoc.authinfo.active_keyid = inp->sctp_ep.default_keyid;\n\n\t/* copy out the shared key list (by reference) from the endpoint */\n\t(void)sctp_copy_skeylist(&inp->sctp_ep.shared_keys,\n\t\t\t\t &stcb->asoc.shared_keys);\n\n\t/* now set the concatenated key (random + chunks + hmacs) */\n\t/* key includes parameter headers */\n\tkeylen = (3 * sizeof(struct sctp_paramhdr)) + random_len + chunks_len +\n\t    hmacs_len;\n\tnew_key = sctp_alloc_key(keylen);\n\tif (new_key != NULL) {\n\t\tstruct sctp_paramhdr *ph;\n\t\tint plen;\n\t\t/* generate and copy in the RANDOM */\n\t\tph = (struct sctp_paramhdr *)new_key->key;\n\t\tph->param_type = htons(SCTP_RANDOM);\n\t\tplen = sizeof(*ph) + random_len;\n\t\tph->param_length = htons(plen);\n\t\tSCTP_READ_RANDOM(new_key->key + sizeof(*ph), random_len);\n\t\tkeylen = plen;\n\n\t\t/* append in the AUTH chunks */\n\t\t/* NOTE: currently we always have chunks to list */\n\t\tph = (struct sctp_paramhdr *)(new_key->key + keylen);\n\t\tph->param_type = htons(SCTP_CHUNK_LIST);\n\t\tplen = sizeof(*ph) + chunks_len;\n\t\tph->param_length = htons(plen);\n\t\tkeylen += sizeof(*ph);\n\t\tif (stcb->asoc.local_auth_chunks) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < 256; i++) {\n\t\t\t\tif (stcb->asoc.local_auth_chunks->chunks[i])\n\t\t\t\t\tnew_key->key[keylen++] = i;\n\t\t\t}\n\t\t}\n\n\t\t/* append in the HMACs */\n\t\tph = (struct sctp_paramhdr *)(new_key->key + keylen);\n\t\tph->param_type = htons(SCTP_HMAC_LIST);\n\t\tplen = sizeof(*ph) + hmacs_len;\n\t\tph->param_length = htons(plen);\n\t\tkeylen += sizeof(*ph);\n\t\t(void)sctp_serialize_hmaclist(stcb->asoc.local_hmacs,\n\t\t\t\t\tnew_key->key + keylen);\n\t}\n\tif (stcb->asoc.authinfo.random != NULL)\n\t    sctp_free_key(stcb->asoc.authinfo.random);\n\tstcb->asoc.authinfo.random = new_key;\n\tstcb->asoc.authinfo.random_len = random_len;\n}\n\n\n#ifdef SCTP_HMAC_TEST\n/*\n * HMAC and key concatenation tests\n */\nstatic void\nsctp_print_digest(uint8_t *digest, uint32_t digestlen, const char *str)\n{\n\tuint32_t i;\n\n\tSCTP_PRINTF(\"\\n%s: 0x\", str);\n\tif (digest == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < digestlen; i++)\n\t\tSCTP_PRINTF(\"%02x\", digest[i]);\n}\n\nstatic int\nsctp_test_hmac(const char *str, uint16_t hmac_id, uint8_t *key,\n    uint32_t keylen, uint8_t *text, uint32_t textlen,\n    uint8_t *digest, uint32_t digestlen)\n{\n\tuint8_t computed_digest[SCTP_AUTH_DIGEST_LEN_MAX];\n\n\tSCTP_PRINTF(\"\\n%s:\", str);\n\tsctp_hmac(hmac_id, key, keylen, text, textlen, computed_digest);\n\tsctp_print_digest(digest, digestlen, \"Expected digest\");\n\tsctp_print_digest(computed_digest, digestlen, \"Computed digest\");\n\tif (memcmp(digest, computed_digest, digestlen) != 0) {\n\t\tSCTP_PRINTF(\"\\nFAILED\");\n\t\treturn (-1);\n\t} else {\n\t\tSCTP_PRINTF(\"\\nPASSED\");\n\t\treturn (0);\n\t}\n}\n\n\n/*\n * RFC 2202: HMAC-SHA1 test cases\n */\nvoid\nsctp_test_hmac_sha1(void)\n{\n\tuint8_t *digest;\n\tuint8_t key[128];\n\tuint32_t keylen;\n\tuint8_t text[128];\n\tuint32_t textlen;\n\tuint32_t digestlen = 20;\n\tint failed = 0;\n\n\t/*-\n\t * test_case =     1\n\t * key =           0x0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b\n\t * key_len =       20\n\t * data =          \"Hi There\"\n\t * data_len =      8\n\t * digest =        0xb617318655057264e28bc0b6fb378c8ef146be00\n\t */\n\tkeylen = 20;\n\tmemset(key, 0x0b, keylen);\n\ttextlen = 8;\n\tstrcpy(text, \"Hi There\");\n\tdigest = \"\\xb6\\x17\\x31\\x86\\x55\\x05\\x72\\x64\\xe2\\x8b\\xc0\\xb6\\xfb\\x37\\x8c\\x8e\\xf1\\x46\\xbe\\x00\";\n\tif (sctp_test_hmac(\"SHA1 test case 1\", SCTP_AUTH_HMAC_ID_SHA1, key, keylen,\n\t    text, textlen, digest, digestlen) < 0)\n\t\tfailed++;\n\n\t/*-\n\t * test_case =     2\n\t * key =           \"Jefe\"\n\t * key_len =       4\n\t * data =          \"what do ya want for nothing?\"\n\t * data_len =      28\n\t * digest =        0xeffcdf6ae5eb2fa2d27416d5f184df9c259a7c79\n\t */\n\tkeylen = 4;\n\tstrcpy(key, \"Jefe\");\n\ttextlen = 28;\n\tstrcpy(text, \"what do ya want for nothing?\");\n\tdigest = \"\\xef\\xfc\\xdf\\x6a\\xe5\\xeb\\x2f\\xa2\\xd2\\x74\\x16\\xd5\\xf1\\x84\\xdf\\x9c\\x25\\x9a\\x7c\\x79\";\n\tif (sctp_test_hmac(\"SHA1 test case 2\", SCTP_AUTH_HMAC_ID_SHA1, key, keylen,\n\t    text, textlen, digest, digestlen) < 0)\n\t\tfailed++;\n\n\t/*-\n\t * test_case =     3\n\t * key =           0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\t * key_len =       20\n\t * data =          0xdd repeated 50 times\n\t * data_len =      50\n\t * digest =        0x125d7342b9ac11cd91a39af48aa17b4f63f175d3\n\t */\n\tkeylen = 20;\n\tmemset(key, 0xaa, keylen);\n\ttextlen = 50;\n\tmemset(text, 0xdd, textlen);\n\tdigest = \"\\x12\\x5d\\x73\\x42\\xb9\\xac\\x11\\xcd\\x91\\xa3\\x9a\\xf4\\x8a\\xa1\\x7b\\x4f\\x63\\xf1\\x75\\xd3\";\n\tif (sctp_test_hmac(\"SHA1 test case 3\", SCTP_AUTH_HMAC_ID_SHA1, key, keylen,\n\t    text, textlen, digest, digestlen) < 0)\n\t\tfailed++;\n\n\t/*-\n\t * test_case =     4\n\t * key =           0x0102030405060708090a0b0c0d0e0f10111213141516171819\n\t * key_len =       25\n\t * data =          0xcd repeated 50 times\n\t * data_len =      50\n\t * digest =        0x4c9007f4026250c6bc8414f9bf50c86c2d7235da\n\t */\n\tkeylen = 25;\n\tmemcpy(key, \"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\", keylen);\n\ttextlen = 50;\n\tmemset(text, 0xcd, textlen);\n\tdigest = \"\\x4c\\x90\\x07\\xf4\\x02\\x62\\x50\\xc6\\xbc\\x84\\x14\\xf9\\xbf\\x50\\xc8\\x6c\\x2d\\x72\\x35\\xda\";\n\tif (sctp_test_hmac(\"SHA1 test case 4\", SCTP_AUTH_HMAC_ID_SHA1, key, keylen,\n\t    text, textlen, digest, digestlen) < 0)\n\t\tfailed++;\n\n\t/*-\n\t * test_case =     5\n\t * key =           0x0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c\n\t * key_len =       20\n\t * data =          \"Test With Truncation\"\n\t * data_len =      20\n\t * digest =        0x4c1a03424b55e07fe7f27be1d58bb9324a9a5a04\n\t * digest-96 =     0x4c1a03424b55e07fe7f27be1\n\t */\n\tkeylen = 20;\n\tmemset(key, 0x0c, keylen);\n\ttextlen = 20;\n\tstrcpy(text, \"Test With Truncation\");\n\tdigest = \"\\x4c\\x1a\\x03\\x42\\x4b\\x55\\xe0\\x7f\\xe7\\xf2\\x7b\\xe1\\xd5\\x8b\\xb9\\x32\\x4a\\x9a\\x5a\\x04\";\n\tif (sctp_test_hmac(\"SHA1 test case 5\", SCTP_AUTH_HMAC_ID_SHA1, key, keylen,\n\t    text, textlen, digest, digestlen) < 0)\n\t\tfailed++;\n\n\t/*-\n\t * test_case =     6\n\t * key =           0xaa repeated 80 times\n\t * key_len =       80\n\t * data =          \"Test Using Larger Than Block-Size Key - Hash Key First\"\n\t * data_len =      54\n\t * digest =        0xaa4ae5e15272d00e95705637ce8a3b55ed402112\n\t */\n\tkeylen = 80;\n\tmemset(key, 0xaa, keylen);\n\ttextlen = 54;\n\tstrcpy(text, \"Test Using Larger Than Block-Size Key - Hash Key First\");\n\tdigest = \"\\xaa\\x4a\\xe5\\xe1\\x52\\x72\\xd0\\x0e\\x95\\x70\\x56\\x37\\xce\\x8a\\x3b\\x55\\xed\\x40\\x21\\x12\";\n\tif (sctp_test_hmac(\"SHA1 test case 6\", SCTP_AUTH_HMAC_ID_SHA1, key, keylen,\n\t    text, textlen, digest, digestlen) < 0)\n\t\tfailed++;\n\n\t/*-\n\t * test_case =     7\n\t * key =           0xaa repeated 80 times\n\t * key_len =       80\n\t * data =          \"Test Using Larger Than Block-Size Key and Larger Than One Block-Size Data\"\n\t * data_len =      73\n\t * digest =        0xe8e99d0f45237d786d6bbaa7965c7808bbff1a91\n\t */\n\tkeylen = 80;\n\tmemset(key, 0xaa, keylen);\n\ttextlen = 73;\n\tstrcpy(text, \"Test Using Larger Than Block-Size Key and Larger Than One Block-Size Data\");\n\tdigest = \"\\xe8\\xe9\\x9d\\x0f\\x45\\x23\\x7d\\x78\\x6d\\x6b\\xba\\xa7\\x96\\x5c\\x78\\x08\\xbb\\xff\\x1a\\x91\";\n\tif (sctp_test_hmac(\"SHA1 test case 7\", SCTP_AUTH_HMAC_ID_SHA1, key, keylen,\n\t    text, textlen, digest, digestlen) < 0)\n\t\tfailed++;\n\n\t/* done with all tests */\n\tif (failed)\n\t\tSCTP_PRINTF(\"\\nSHA1 test results: %d cases failed\", failed);\n\telse\n\t\tSCTP_PRINTF(\"\\nSHA1 test results: all test cases passed\");\n}\n\n/*\n * test assoc key concatenation\n */\nstatic int\nsctp_test_key_concatenation(sctp_key_t *key1, sctp_key_t *key2,\n    sctp_key_t *expected_key)\n{\n\tsctp_key_t *key;\n\tint ret_val;\n\n\tsctp_show_key(key1, \"\\nkey1\");\n\tsctp_show_key(key2, \"\\nkey2\");\n\tkey = sctp_compute_hashkey(key1, key2, NULL);\n\tsctp_show_key(expected_key, \"\\nExpected\");\n\tsctp_show_key(key, \"\\nComputed\");\n\tif (memcmp(key, expected_key, expected_key->keylen) != 0) {\n\t\tSCTP_PRINTF(\"\\nFAILED\");\n\t\tret_val = -1;\n\t} else {\n\t\tSCTP_PRINTF(\"\\nPASSED\");\n\t\tret_val = 0;\n\t}\n\tsctp_free_key(key1);\n\tsctp_free_key(key2);\n\tsctp_free_key(expected_key);\n\tsctp_free_key(key);\n\treturn (ret_val);\n}\n\n\nvoid\nsctp_test_authkey(void)\n{\n\tsctp_key_t *key1, *key2, *expected_key;\n\tint failed = 0;\n\n\t/* test case 1 */\n\tkey1 = sctp_set_key(\"\\x01\\x01\\x01\\x01\", 4);\n\tkey2 = sctp_set_key(\"\\x01\\x02\\x03\\x04\", 4);\n\texpected_key = sctp_set_key(\"\\x01\\x01\\x01\\x01\\x01\\x02\\x03\\x04\", 8);\n\tif (sctp_test_key_concatenation(key1, key2, expected_key) < 0)\n\t\tfailed++;\n\n\t/* test case 2 */\n\tkey1 = sctp_set_key(\"\\x00\\x00\\x00\\x01\", 4);\n\tkey2 = sctp_set_key(\"\\x02\", 1);\n\texpected_key = sctp_set_key(\"\\x00\\x00\\x00\\x01\\x02\", 5);\n\tif (sctp_test_key_concatenation(key1, key2, expected_key) < 0)\n\t\tfailed++;\n\n\t/* test case 3 */\n\tkey1 = sctp_set_key(\"\\x01\", 1);\n\tkey2 = sctp_set_key(\"\\x00\\x00\\x00\\x02\", 4);\n\texpected_key = sctp_set_key(\"\\x01\\x00\\x00\\x00\\x02\", 5);\n\tif (sctp_test_key_concatenation(key1, key2, expected_key) < 0)\n\t\tfailed++;\n\n\t/* test case 4 */\n\tkey1 = sctp_set_key(\"\\x00\\x00\\x00\\x01\", 4);\n\tkey2 = sctp_set_key(\"\\x01\", 1);\n\texpected_key = sctp_set_key(\"\\x01\\x00\\x00\\x00\\x01\", 5);\n\tif (sctp_test_key_concatenation(key1, key2, expected_key) < 0)\n\t\tfailed++;\n\n\t/* test case 5 */\n\tkey1 = sctp_set_key(\"\\x01\", 1);\n\tkey2 = sctp_set_key(\"\\x00\\x00\\x00\\x01\", 4);\n\texpected_key = sctp_set_key(\"\\x01\\x00\\x00\\x00\\x01\", 5);\n\tif (sctp_test_key_concatenation(key1, key2, expected_key) < 0)\n\t\tfailed++;\n\n\t/* test case 6 */\n\tkey1 = sctp_set_key(\"\\x00\\x00\\x00\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\", 11);\n\tkey2 = sctp_set_key(\"\\x00\\x00\\x00\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x08\", 11);\n\texpected_key = sctp_set_key(\"\\x00\\x00\\x00\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x00\\x00\\x00\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x08\", 22);\n\tif (sctp_test_key_concatenation(key1, key2, expected_key) < 0)\n\t\tfailed++;\n\n\t/* test case 7 */\n\tkey1 = sctp_set_key(\"\\x00\\x00\\x00\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x08\", 11);\n\tkey2 = sctp_set_key(\"\\x00\\x00\\x00\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\", 11);\n\texpected_key = sctp_set_key(\"\\x00\\x00\\x00\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x00\\x00\\x00\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x08\", 22);\n\tif (sctp_test_key_concatenation(key1, key2, expected_key) < 0)\n\t\tfailed++;\n\n\t/* done with all tests */\n\tif (failed)\n\t\tSCTP_PRINTF(\"\\nKey concatenation test results: %d cases failed\", failed);\n\telse\n\t\tSCTP_PRINTF(\"\\nKey concatenation test results: all test cases passed\");\n}\n\n\n#if defined(STANDALONE_HMAC_TEST)\nint\nmain(void)\n{\n\tsctp_test_hmac_sha1();\n\tsctp_test_authkey();\n}\n\n#endif /* STANDALONE_HMAC_TEST */\n\n#endif /* SCTP_HMAC_TEST */\n", "/*-\n * SPDX-License-Identifier: BSD-3-Clause\n *\n * Copyright (c) 2001-2008, by Cisco Systems, Inc. All rights reserved.\n * Copyright (c) 2008-2012, by Randall Stewart. All rights reserved.\n * Copyright (c) 2008-2012, by Michael Tuexen. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * a) Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *\n * b) Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the distribution.\n *\n * c) Neither the name of Cisco Systems, Inc. nor the names of its\n *    contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifdef __FreeBSD__\n#include <sys/cdefs.h>\n__FBSDID(\"$FreeBSD: head/sys/netinet/sctp_pcb.c 355931 2019-12-20 15:25:08Z tuexen $\");\n#endif\n\n#include <netinet/sctp_os.h>\n#ifdef __FreeBSD__\n#include <sys/proc.h>\n#endif\n#include <netinet/sctp_var.h>\n#include <netinet/sctp_sysctl.h>\n#include <netinet/sctp_pcb.h>\n#include <netinet/sctputil.h>\n#include <netinet/sctp.h>\n#include <netinet/sctp_header.h>\n#include <netinet/sctp_asconf.h>\n#include <netinet/sctp_output.h>\n#include <netinet/sctp_timer.h>\n#include <netinet/sctp_bsd_addr.h>\n#if defined(INET) || defined(INET6)\n#if !defined(__Userspace_os_Windows)\n#include <netinet/udp.h>\n#endif\n#endif\n#ifdef INET6\n#if defined(__Userspace__)\n#include \"user_ip6_var.h\"\n#else\n#include <netinet6/ip6_var.h>\n#endif\n#endif\n#if defined(__FreeBSD__)\n#include <sys/sched.h>\n#include <sys/smp.h>\n#include <sys/unistd.h>\n#endif\n#if defined(__Userspace__)\n#include <user_socketvar.h>\n#include <user_atomic.h>\n#if !defined(__Userspace_os_Windows)\n#include <netdb.h>\n#endif\n#endif\n\n#if defined(__APPLE__)\n#define APPLE_FILE_NO 4\n#endif\n\n#if defined(__FreeBSD__) && __FreeBSD_version >= 801000\nVNET_DEFINE(struct sctp_base_info, system_base_info);\n#else\nstruct sctp_base_info system_base_info;\n#endif\n\n/* FIX: we don't handle multiple link local scopes */\n/* \"scopeless\" replacement IN6_ARE_ADDR_EQUAL */\n#ifdef INET6\nint\nSCTP6_ARE_ADDR_EQUAL(struct sockaddr_in6 *a, struct sockaddr_in6 *b)\n{\n#ifdef SCTP_EMBEDDED_V6_SCOPE\n#if defined(__APPLE__)\n\tstruct in6_addr tmp_a, tmp_b;\n\n\ttmp_a = a->sin6_addr;\n#if defined(APPLE_LEOPARD) || defined(APPLE_SNOWLEOPARD)\n\tif (in6_embedscope(&tmp_a, a, NULL, NULL) != 0) {\n#else\n\tif (in6_embedscope(&tmp_a, a, NULL, NULL, NULL) != 0) {\n#endif\n\t\treturn (0);\n\t}\n\ttmp_b = b->sin6_addr;\n#if defined(APPLE_LEOPARD) || defined(APPLE_SNOWLEOPARD)\n\tif (in6_embedscope(&tmp_b, b, NULL, NULL) != 0) {\n#else\n\tif (in6_embedscope(&tmp_b, b, NULL, NULL, NULL) != 0) {\n#endif\n\t\treturn (0);\n\t}\n\treturn (IN6_ARE_ADDR_EQUAL(&tmp_a, &tmp_b));\n#elif defined(SCTP_KAME)\n\tstruct sockaddr_in6 tmp_a, tmp_b;\n\n\tmemcpy(&tmp_a, a, sizeof(struct sockaddr_in6));\n\tif (sa6_embedscope(&tmp_a, MODULE_GLOBAL(ip6_use_defzone)) != 0) {\n\t\treturn (0);\n\t}\n\tmemcpy(&tmp_b, b, sizeof(struct sockaddr_in6));\n\tif (sa6_embedscope(&tmp_b, MODULE_GLOBAL(ip6_use_defzone)) != 0) {\n\t\treturn (0);\n\t}\n\treturn (IN6_ARE_ADDR_EQUAL(&tmp_a.sin6_addr, &tmp_b.sin6_addr));\n#else\n\tstruct in6_addr tmp_a, tmp_b;\n\n\ttmp_a = a->sin6_addr;\n\tif (in6_embedscope(&tmp_a, a) != 0) {\n\t\treturn (0);\n\t}\n\ttmp_b = b->sin6_addr;\n\tif (in6_embedscope(&tmp_b, b) != 0) {\n\t\treturn (0);\n\t}\n\treturn (IN6_ARE_ADDR_EQUAL(&tmp_a, &tmp_b));\n#endif\n#else\n\treturn (IN6_ARE_ADDR_EQUAL(&(a->sin6_addr), &(b->sin6_addr)));\n#endif /* SCTP_EMBEDDED_V6_SCOPE */\n}\n#endif\n\nvoid\nsctp_fill_pcbinfo(struct sctp_pcbinfo *spcb)\n{\n\t/*\n\t * We really don't need to lock this, but I will just because it\n\t * does not hurt.\n\t */\n\tSCTP_INP_INFO_RLOCK();\n\tspcb->ep_count = SCTP_BASE_INFO(ipi_count_ep);\n\tspcb->asoc_count = SCTP_BASE_INFO(ipi_count_asoc);\n\tspcb->laddr_count = SCTP_BASE_INFO(ipi_count_laddr);\n\tspcb->raddr_count = SCTP_BASE_INFO(ipi_count_raddr);\n\tspcb->chk_count = SCTP_BASE_INFO(ipi_count_chunk);\n\tspcb->readq_count = SCTP_BASE_INFO(ipi_count_readq);\n\tspcb->stream_oque = SCTP_BASE_INFO(ipi_count_strmoq);\n\tspcb->free_chunks = SCTP_BASE_INFO(ipi_free_chunks);\n\tSCTP_INP_INFO_RUNLOCK();\n}\n\n/*-\n * Addresses are added to VRF's (Virtual Router's). For BSD we\n * have only the default VRF 0. We maintain a hash list of\n * VRF's. Each VRF has its own list of sctp_ifn's. Each of\n * these has a list of addresses. When we add a new address\n * to a VRF we lookup the ifn/ifn_index, if the ifn does\n * not exist we create it and add it to the list of IFN's\n * within the VRF. Once we have the sctp_ifn, we add the\n * address to the list. So we look something like:\n *\n * hash-vrf-table\n *   vrf-> ifn-> ifn -> ifn\n *   vrf    |\n *    ...   +--ifa-> ifa -> ifa\n *   vrf\n *\n * We keep these separate lists since the SCTP subsystem will\n * point to these from its source address selection nets structure.\n * When an address is deleted it does not happen right away on\n * the SCTP side, it gets scheduled. What we do when a\n * delete happens is immediately remove the address from\n * the master list and decrement the refcount. As our\n * addip iterator works through and frees the src address\n * selection pointing to the sctp_ifa, eventually the refcount\n * will reach 0 and we will delete it. Note that it is assumed\n * that any locking on system level ifn/ifa is done at the\n * caller of these functions and these routines will only\n * lock the SCTP structures as they add or delete things.\n *\n * Other notes on VRF concepts.\n *  - An endpoint can be in multiple VRF's\n *  - An association lives within a VRF and only one VRF.\n *  - Any incoming packet we can deduce the VRF for by\n *    looking at the mbuf/pak inbound (for BSD its VRF=0 :D)\n *  - Any downward send call or connect call must supply the\n *    VRF via ancillary data or via some sort of set default\n *    VRF socket option call (again for BSD no brainer since\n *    the VRF is always 0).\n *  - An endpoint may add multiple VRF's to it.\n *  - Listening sockets can accept associations in any\n *    of the VRF's they are in but the assoc will end up\n *    in only one VRF (gotten from the packet or connect/send).\n *\n */\n\nstruct sctp_vrf *\nsctp_allocate_vrf(int vrf_id)\n{\n\tstruct sctp_vrf *vrf = NULL;\n\tstruct sctp_vrflist *bucket;\n\n\t/* First allocate the VRF structure */\n\tvrf = sctp_find_vrf(vrf_id);\n\tif (vrf) {\n\t\t/* Already allocated */\n\t\treturn (vrf);\n\t}\n\tSCTP_MALLOC(vrf, struct sctp_vrf *, sizeof(struct sctp_vrf),\n\t\t    SCTP_M_VRF);\n\tif (vrf == NULL) {\n\t\t/* No memory */\n#ifdef INVARIANTS\n\t\tpanic(\"No memory for VRF:%d\", vrf_id);\n#endif\n\t\treturn (NULL);\n\t}\n\t/* setup the VRF */\n\tmemset(vrf, 0, sizeof(struct sctp_vrf));\n\tvrf->vrf_id = vrf_id;\n\tLIST_INIT(&vrf->ifnlist);\n\tvrf->total_ifa_count = 0;\n\tvrf->refcount = 0;\n\t/* now also setup table ids */\n\tSCTP_INIT_VRF_TABLEID(vrf);\n\t/* Init the HASH of addresses */\n\tvrf->vrf_addr_hash = SCTP_HASH_INIT(SCTP_VRF_ADDR_HASH_SIZE,\n\t\t\t\t\t    &vrf->vrf_addr_hashmark);\n\tif (vrf->vrf_addr_hash == NULL) {\n\t\t/* No memory */\n#ifdef INVARIANTS\n\t\tpanic(\"No memory for VRF:%d\", vrf_id);\n#endif\n\t\tSCTP_FREE(vrf, SCTP_M_VRF);\n\t\treturn (NULL);\n\t}\n\n\t/* Add it to the hash table */\n\tbucket = &SCTP_BASE_INFO(sctp_vrfhash)[(vrf_id & SCTP_BASE_INFO(hashvrfmark))];\n\tLIST_INSERT_HEAD(bucket, vrf, next_vrf);\n\tatomic_add_int(&SCTP_BASE_INFO(ipi_count_vrfs), 1);\n\treturn (vrf);\n}\n\n\nstruct sctp_ifn *\nsctp_find_ifn(void *ifn, uint32_t ifn_index)\n{\n\tstruct sctp_ifn *sctp_ifnp;\n\tstruct sctp_ifnlist *hash_ifn_head;\n\n\t/* We assume the lock is held for the addresses\n\t * if that's wrong problems could occur :-)\n\t */\n\thash_ifn_head = &SCTP_BASE_INFO(vrf_ifn_hash)[(ifn_index & SCTP_BASE_INFO(vrf_ifn_hashmark))];\n\tLIST_FOREACH(sctp_ifnp, hash_ifn_head, next_bucket) {\n\t\tif (sctp_ifnp->ifn_index == ifn_index) {\n\t\t\treturn (sctp_ifnp);\n\t\t}\n\t\tif (sctp_ifnp->ifn_p && ifn && (sctp_ifnp->ifn_p == ifn)) {\n\t\t\treturn (sctp_ifnp);\n\t\t}\n\t}\n\treturn (NULL);\n}\n\n\nstruct sctp_vrf *\nsctp_find_vrf(uint32_t vrf_id)\n{\n\tstruct sctp_vrflist *bucket;\n\tstruct sctp_vrf *liste;\n\n\tbucket = &SCTP_BASE_INFO(sctp_vrfhash)[(vrf_id & SCTP_BASE_INFO(hashvrfmark))];\n\tLIST_FOREACH(liste, bucket, next_vrf) {\n\t\tif (vrf_id == liste->vrf_id) {\n\t\t\treturn (liste);\n\t\t}\n\t}\n\treturn (NULL);\n}\n\n\nvoid\nsctp_free_vrf(struct sctp_vrf *vrf)\n{\n\tif (SCTP_DECREMENT_AND_CHECK_REFCOUNT(&vrf->refcount)) {\n                if (vrf->vrf_addr_hash) {\n                    SCTP_HASH_FREE(vrf->vrf_addr_hash, vrf->vrf_addr_hashmark);\n                    vrf->vrf_addr_hash = NULL;\n                }\n\t\t/* We zero'd the count */\n\t\tLIST_REMOVE(vrf, next_vrf);\n\t\tSCTP_FREE(vrf, SCTP_M_VRF);\n\t\tatomic_subtract_int(&SCTP_BASE_INFO(ipi_count_vrfs), 1);\n\t}\n}\n\n\nvoid\nsctp_free_ifn(struct sctp_ifn *sctp_ifnp)\n{\n\tif (SCTP_DECREMENT_AND_CHECK_REFCOUNT(&sctp_ifnp->refcount)) {\n\t\t/* We zero'd the count */\n\t\tif (sctp_ifnp->vrf) {\n\t\t\tsctp_free_vrf(sctp_ifnp->vrf);\n\t\t}\n\t\tSCTP_FREE(sctp_ifnp, SCTP_M_IFN);\n\t\tatomic_subtract_int(&SCTP_BASE_INFO(ipi_count_ifns), 1);\n\t}\n}\n\n\nvoid\nsctp_update_ifn_mtu(uint32_t ifn_index, uint32_t mtu)\n{\n\tstruct sctp_ifn *sctp_ifnp;\n\n\tsctp_ifnp = sctp_find_ifn((void *)NULL, ifn_index);\n\tif (sctp_ifnp != NULL) {\n\t\tsctp_ifnp->ifn_mtu = mtu;\n\t}\n}\n\n\nvoid\nsctp_free_ifa(struct sctp_ifa *sctp_ifap)\n{\n\tif (SCTP_DECREMENT_AND_CHECK_REFCOUNT(&sctp_ifap->refcount)) {\n\t\t/* We zero'd the count */\n\t\tif (sctp_ifap->ifn_p) {\n\t\t\tsctp_free_ifn(sctp_ifap->ifn_p);\n\t\t}\n\t\tSCTP_FREE(sctp_ifap, SCTP_M_IFA);\n\t\tatomic_subtract_int(&SCTP_BASE_INFO(ipi_count_ifas), 1);\n\t}\n}\n\n\nstatic void\nsctp_delete_ifn(struct sctp_ifn *sctp_ifnp, int hold_addr_lock)\n{\n\tstruct sctp_ifn *found;\n\n\tfound = sctp_find_ifn(sctp_ifnp->ifn_p, sctp_ifnp->ifn_index);\n\tif (found == NULL) {\n\t\t/* Not in the list.. sorry */\n\t\treturn;\n\t}\n\tif (hold_addr_lock == 0)\n\t\tSCTP_IPI_ADDR_WLOCK();\n\tLIST_REMOVE(sctp_ifnp, next_bucket);\n\tLIST_REMOVE(sctp_ifnp, next_ifn);\n\tSCTP_DEREGISTER_INTERFACE(sctp_ifnp->ifn_index,\n\t\t\t\t  sctp_ifnp->registered_af);\n\tif (hold_addr_lock == 0)\n\t\tSCTP_IPI_ADDR_WUNLOCK();\n\t/* Take away the reference, and possibly free it */\n\tsctp_free_ifn(sctp_ifnp);\n}\n\n\nvoid\nsctp_mark_ifa_addr_down(uint32_t vrf_id, struct sockaddr *addr,\n\t\t\tconst char *if_name, uint32_t ifn_index)\n{\n\tstruct sctp_vrf *vrf;\n\tstruct sctp_ifa *sctp_ifap;\n\n\tSCTP_IPI_ADDR_RLOCK();\n\tvrf = sctp_find_vrf(vrf_id);\n\tif (vrf == NULL) {\n\t\tSCTPDBG(SCTP_DEBUG_PCB4, \"Can't find vrf_id 0x%x\\n\", vrf_id);\n\t\tgoto out;\n\n\t}\n\tsctp_ifap = sctp_find_ifa_by_addr(addr, vrf->vrf_id, SCTP_ADDR_LOCKED);\n\tif (sctp_ifap == NULL) {\n\t\tSCTPDBG(SCTP_DEBUG_PCB4, \"Can't find sctp_ifap for address\\n\");\n\t\tgoto out;\n\t}\n\tif (sctp_ifap->ifn_p == NULL) {\n\t\tSCTPDBG(SCTP_DEBUG_PCB4, \"IFA has no IFN - can't mark unusable\\n\");\n\t\tgoto out;\n\t}\n\tif (if_name) {\n\t\tif (strncmp(if_name, sctp_ifap->ifn_p->ifn_name, SCTP_IFNAMSIZ) != 0) {\n\t\t\tSCTPDBG(SCTP_DEBUG_PCB4, \"IFN %s of IFA not the same as %s\\n\",\n\t\t\t\tsctp_ifap->ifn_p->ifn_name, if_name);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tif (sctp_ifap->ifn_p->ifn_index != ifn_index) {\n\t\t\tSCTPDBG(SCTP_DEBUG_PCB4, \"IFA owned by ifn_index:%d down command for ifn_index:%d - ignored\\n\",\n\t\t\t\tsctp_ifap->ifn_p->ifn_index, ifn_index);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tsctp_ifap->localifa_flags &= (~SCTP_ADDR_VALID);\n\tsctp_ifap->localifa_flags |= SCTP_ADDR_IFA_UNUSEABLE;\n out:\n\tSCTP_IPI_ADDR_RUNLOCK();\n}\n\n\nvoid\nsctp_mark_ifa_addr_up(uint32_t vrf_id, struct sockaddr *addr,\n\t\t      const char *if_name, uint32_t ifn_index)\n{\n\tstruct sctp_vrf *vrf;\n\tstruct sctp_ifa *sctp_ifap;\n\n\tSCTP_IPI_ADDR_RLOCK();\n\tvrf = sctp_find_vrf(vrf_id);\n\tif (vrf == NULL) {\n\t\tSCTPDBG(SCTP_DEBUG_PCB4, \"Can't find vrf_id 0x%x\\n\", vrf_id);\n\t\tgoto out;\n\n\t}\n\tsctp_ifap = sctp_find_ifa_by_addr(addr, vrf->vrf_id, SCTP_ADDR_LOCKED);\n\tif (sctp_ifap == NULL) {\n\t\tSCTPDBG(SCTP_DEBUG_PCB4, \"Can't find sctp_ifap for address\\n\");\n\t\tgoto out;\n\t}\n\tif (sctp_ifap->ifn_p == NULL) {\n\t\tSCTPDBG(SCTP_DEBUG_PCB4, \"IFA has no IFN - can't mark unusable\\n\");\n\t\tgoto out;\n\t}\n\tif (if_name) {\n\t\tif (strncmp(if_name, sctp_ifap->ifn_p->ifn_name, SCTP_IFNAMSIZ) != 0) {\n\t\t\tSCTPDBG(SCTP_DEBUG_PCB4, \"IFN %s of IFA not the same as %s\\n\",\n\t\t\t\tsctp_ifap->ifn_p->ifn_name, if_name);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tif (sctp_ifap->ifn_p->ifn_index != ifn_index) {\n\t\t\tSCTPDBG(SCTP_DEBUG_PCB4, \"IFA owned by ifn_index:%d down command for ifn_index:%d - ignored\\n\",\n\t\t\t\tsctp_ifap->ifn_p->ifn_index, ifn_index);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tsctp_ifap->localifa_flags &= (~SCTP_ADDR_IFA_UNUSEABLE);\n\tsctp_ifap->localifa_flags |= SCTP_ADDR_VALID;\n out:\n\tSCTP_IPI_ADDR_RUNLOCK();\n}\n\n\n/*-\n * Add an ifa to an ifn.\n * Register the interface as necessary.\n * NOTE: ADDR write lock MUST be held.\n */\nstatic void\nsctp_add_ifa_to_ifn(struct sctp_ifn *sctp_ifnp, struct sctp_ifa *sctp_ifap)\n{\n\tint ifa_af;\n\n\tLIST_INSERT_HEAD(&sctp_ifnp->ifalist, sctp_ifap, next_ifa);\n\tsctp_ifap->ifn_p = sctp_ifnp;\n\tatomic_add_int(&sctp_ifap->ifn_p->refcount, 1);\n\t/* update address counts */\n\tsctp_ifnp->ifa_count++;\n\tifa_af = sctp_ifap->address.sa.sa_family;\n\tswitch (ifa_af) {\n#ifdef INET\n\tcase AF_INET:\n\t\tsctp_ifnp->num_v4++;\n\t\tbreak;\n#endif\n#ifdef INET6\n\tcase AF_INET6:\n\t\tsctp_ifnp->num_v6++;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sctp_ifnp->ifa_count == 1) {\n\t\t/* register the new interface */\n\t\tSCTP_REGISTER_INTERFACE(sctp_ifnp->ifn_index, ifa_af);\n\t\tsctp_ifnp->registered_af = ifa_af;\n\t}\n}\n\n\n/*-\n * Remove an ifa from its ifn.\n * If no more addresses exist, remove the ifn too. Otherwise, re-register\n * the interface based on the remaining address families left.\n * NOTE: ADDR write lock MUST be held.\n */\nstatic void\nsctp_remove_ifa_from_ifn(struct sctp_ifa *sctp_ifap)\n{\n\tLIST_REMOVE(sctp_ifap, next_ifa);\n\tif (sctp_ifap->ifn_p) {\n\t\t/* update address counts */\n\t\tsctp_ifap->ifn_p->ifa_count--;\n\t\tswitch (sctp_ifap->address.sa.sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tsctp_ifap->ifn_p->num_v4--;\n\t\t\tbreak;\n#endif\n#ifdef INET6\n\t\tcase AF_INET6:\n\t\t\tsctp_ifap->ifn_p->num_v6--;\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (LIST_EMPTY(&sctp_ifap->ifn_p->ifalist)) {\n\t\t\t/* remove the ifn, possibly freeing it */\n\t\t\tsctp_delete_ifn(sctp_ifap->ifn_p, SCTP_ADDR_LOCKED);\n\t\t} else {\n\t\t\t/* re-register address family type, if needed */\n\t\t\tif ((sctp_ifap->ifn_p->num_v6 == 0) &&\n\t\t\t    (sctp_ifap->ifn_p->registered_af == AF_INET6)) {\n\t\t\t\tSCTP_DEREGISTER_INTERFACE(sctp_ifap->ifn_p->ifn_index, AF_INET6);\n\t\t\t\tSCTP_REGISTER_INTERFACE(sctp_ifap->ifn_p->ifn_index, AF_INET);\n\t\t\t\tsctp_ifap->ifn_p->registered_af = AF_INET;\n\t\t\t} else if ((sctp_ifap->ifn_p->num_v4 == 0) &&\n\t\t\t\t   (sctp_ifap->ifn_p->registered_af == AF_INET)) {\n\t\t\t\tSCTP_DEREGISTER_INTERFACE(sctp_ifap->ifn_p->ifn_index, AF_INET);\n\t\t\t\tSCTP_REGISTER_INTERFACE(sctp_ifap->ifn_p->ifn_index, AF_INET6);\n\t\t\t\tsctp_ifap->ifn_p->registered_af = AF_INET6;\n\t\t\t}\n\t\t\t/* free the ifn refcount */\n\t\t\tsctp_free_ifn(sctp_ifap->ifn_p);\n\t\t}\n\t\tsctp_ifap->ifn_p = NULL;\n\t}\n}\n\n\nstruct sctp_ifa *\nsctp_add_addr_to_vrf(uint32_t vrf_id, void *ifn, uint32_t ifn_index,\n\t\t     uint32_t ifn_type, const char *if_name, void *ifa,\n\t\t     struct sockaddr *addr, uint32_t ifa_flags,\n\t\t     int dynamic_add)\n{\n\tstruct sctp_vrf *vrf;\n\tstruct sctp_ifn *sctp_ifnp = NULL;\n\tstruct sctp_ifa *sctp_ifap = NULL;\n\tstruct sctp_ifalist *hash_addr_head;\n\tstruct sctp_ifnlist *hash_ifn_head;\n\tuint32_t hash_of_addr;\n\tint new_ifn_af = 0;\n\n#ifdef SCTP_DEBUG\n\tSCTPDBG(SCTP_DEBUG_PCB4, \"vrf_id 0x%x: adding address: \", vrf_id);\n\tSCTPDBG_ADDR(SCTP_DEBUG_PCB4, addr);\n#endif\n\tSCTP_IPI_ADDR_WLOCK();\n\tsctp_ifnp = sctp_find_ifn(ifn, ifn_index);\n\tif (sctp_ifnp) {\n\t\tvrf = sctp_ifnp->vrf;\n\t} else {\n\t\tvrf = sctp_find_vrf(vrf_id);\n\t\tif (vrf == NULL) {\n\t\t\tvrf = sctp_allocate_vrf(vrf_id);\n\t\t\tif (vrf == NULL) {\n\t\t\t\tSCTP_IPI_ADDR_WUNLOCK();\n\t\t\t\treturn (NULL);\n\t\t\t}\n\t\t}\n\t}\n\tif (sctp_ifnp == NULL) {\n\t\t/* build one and add it, can't hold lock\n\t\t * until after malloc done though.\n\t\t */\n\t\tSCTP_IPI_ADDR_WUNLOCK();\n\t\tSCTP_MALLOC(sctp_ifnp, struct sctp_ifn *,\n\t\t\t    sizeof(struct sctp_ifn), SCTP_M_IFN);\n\t\tif (sctp_ifnp == NULL) {\n#ifdef INVARIANTS\n\t\t\tpanic(\"No memory for IFN\");\n#endif\n\t\t\treturn (NULL);\n\t\t}\n\t\tmemset(sctp_ifnp, 0, sizeof(struct sctp_ifn));\n\t\tsctp_ifnp->ifn_index = ifn_index;\n\t\tsctp_ifnp->ifn_p = ifn;\n\t\tsctp_ifnp->ifn_type = ifn_type;\n\t\tsctp_ifnp->refcount = 0;\n\t\tsctp_ifnp->vrf = vrf;\n\t\tatomic_add_int(&vrf->refcount, 1);\n\t\tsctp_ifnp->ifn_mtu = SCTP_GATHER_MTU_FROM_IFN_INFO(ifn, ifn_index, addr->sa_family);\n\t\tif (if_name != NULL) {\n\t\t\tsnprintf(sctp_ifnp->ifn_name, SCTP_IFNAMSIZ, \"%s\", if_name);\n\t\t} else {\n\t\t\tsnprintf(sctp_ifnp->ifn_name, SCTP_IFNAMSIZ, \"%s\", \"unknown\");\n\t\t}\n\t\thash_ifn_head = &SCTP_BASE_INFO(vrf_ifn_hash)[(ifn_index & SCTP_BASE_INFO(vrf_ifn_hashmark))];\n\t\tLIST_INIT(&sctp_ifnp->ifalist);\n\t\tSCTP_IPI_ADDR_WLOCK();\n\t\tLIST_INSERT_HEAD(hash_ifn_head, sctp_ifnp, next_bucket);\n\t\tLIST_INSERT_HEAD(&vrf->ifnlist, sctp_ifnp, next_ifn);\n\t\tatomic_add_int(&SCTP_BASE_INFO(ipi_count_ifns), 1);\n\t\tnew_ifn_af = 1;\n\t}\n\tsctp_ifap = sctp_find_ifa_by_addr(addr, vrf->vrf_id, SCTP_ADDR_LOCKED);\n\tif (sctp_ifap) {\n\t\t/* Hmm, it already exists? */\n\t\tif ((sctp_ifap->ifn_p) &&\n\t\t    (sctp_ifap->ifn_p->ifn_index == ifn_index)) {\n\t\t\tSCTPDBG(SCTP_DEBUG_PCB4, \"Using existing ifn %s (0x%x) for ifa %p\\n\",\n\t\t\t\tsctp_ifap->ifn_p->ifn_name, ifn_index,\n\t\t\t\t(void *)sctp_ifap);\n\t\t\tif (new_ifn_af) {\n\t\t\t\t/* Remove the created one that we don't want */\n\t\t\t\tsctp_delete_ifn(sctp_ifnp, SCTP_ADDR_LOCKED);\n\t\t\t}\n\t\t\tif (sctp_ifap->localifa_flags & SCTP_BEING_DELETED) {\n\t\t\t\t/* easy to solve, just switch back to active */\n\t\t\t\tSCTPDBG(SCTP_DEBUG_PCB4, \"Clearing deleted ifa flag\\n\");\n\t\t\t\tsctp_ifap->localifa_flags = SCTP_ADDR_VALID;\n\t\t\t\tsctp_ifap->ifn_p = sctp_ifnp;\n\t\t\t\tatomic_add_int(&sctp_ifap->ifn_p->refcount, 1);\n\t\t\t}\n\t\texit_stage_left:\n\t\t\tSCTP_IPI_ADDR_WUNLOCK();\n\t\t\treturn (sctp_ifap);\n\t\t} else {\n\t\t\tif (sctp_ifap->ifn_p) {\n\t\t\t\t/*\n\t\t\t\t * The last IFN gets the address, remove the\n\t\t\t\t * old one\n\t\t\t\t */\n\t\t\t\tSCTPDBG(SCTP_DEBUG_PCB4, \"Moving ifa %p from %s (0x%x) to %s (0x%x)\\n\",\n\t\t\t\t\t(void *)sctp_ifap, sctp_ifap->ifn_p->ifn_name,\n\t\t\t\t\tsctp_ifap->ifn_p->ifn_index, if_name,\n\t\t\t\t\tifn_index);\n\t\t\t\t/* remove the address from the old ifn */\n\t\t\t\tsctp_remove_ifa_from_ifn(sctp_ifap);\n\t\t\t\t/* move the address over to the new ifn */\n\t\t\t\tsctp_add_ifa_to_ifn(sctp_ifnp, sctp_ifap);\n\t\t\t\tgoto exit_stage_left;\n\t\t\t} else {\n\t\t\t\t/* repair ifnp which was NULL ? */\n\t\t\t\tsctp_ifap->localifa_flags = SCTP_ADDR_VALID;\n\t\t\t\tSCTPDBG(SCTP_DEBUG_PCB4, \"Repairing ifn %p for ifa %p\\n\",\n\t\t\t\t\t(void *)sctp_ifnp, (void *)sctp_ifap);\n\t\t\t\tsctp_add_ifa_to_ifn(sctp_ifnp, sctp_ifap);\n\t\t\t}\n\t\t\tgoto exit_stage_left;\n\t\t}\n\t}\n\tSCTP_IPI_ADDR_WUNLOCK();\n\tSCTP_MALLOC(sctp_ifap, struct sctp_ifa *, sizeof(struct sctp_ifa), SCTP_M_IFA);\n\tif (sctp_ifap == NULL) {\n#ifdef INVARIANTS\n\t\tpanic(\"No memory for IFA\");\n#endif\n\t\treturn (NULL);\n\t}\n\tmemset(sctp_ifap, 0, sizeof(struct sctp_ifa));\n\tsctp_ifap->ifn_p = sctp_ifnp;\n\tatomic_add_int(&sctp_ifnp->refcount, 1);\n\tsctp_ifap->vrf_id = vrf_id;\n\tsctp_ifap->ifa = ifa;\n#ifdef HAVE_SA_LEN\n\tmemcpy(&sctp_ifap->address, addr, addr->sa_len);\n#else\n\tswitch (addr->sa_family) {\n#ifdef INET\n\tcase AF_INET:\n\t\tmemcpy(&sctp_ifap->address, addr, sizeof(struct sockaddr_in));\n\t\tbreak;\n#endif\n#ifdef INET6\n\tcase AF_INET6:\n\t\tmemcpy(&sctp_ifap->address, addr, sizeof(struct sockaddr_in6));\n\t\tbreak;\n#endif\n#if defined(__Userspace__)\n\tcase AF_CONN:\n\t\tmemcpy(&sctp_ifap->address, addr, sizeof(struct sockaddr_conn));\n\t\tbreak;\n#endif\n\tdefault:\n\t\t/* TSNH */\n\t\tbreak;\n\t}\n#endif\n\tsctp_ifap->localifa_flags = SCTP_ADDR_VALID | SCTP_ADDR_DEFER_USE;\n\tsctp_ifap->flags = ifa_flags;\n\t/* Set scope */\n\tswitch (sctp_ifap->address.sa.sa_family) {\n#ifdef INET\n\tcase AF_INET:\n\t{\n\t\tstruct sockaddr_in *sin;\n\n\t\tsin = &sctp_ifap->address.sin;\n\t\tif (SCTP_IFN_IS_IFT_LOOP(sctp_ifap->ifn_p) ||\n\t\t    (IN4_ISLOOPBACK_ADDRESS(&sin->sin_addr))) {\n\t\t\tsctp_ifap->src_is_loop = 1;\n\t\t}\n\t\tif ((IN4_ISPRIVATE_ADDRESS(&sin->sin_addr))) {\n\t\t\tsctp_ifap->src_is_priv = 1;\n\t\t}\n\t\tsctp_ifnp->num_v4++;\n\t\tif (new_ifn_af)\n\t\t    new_ifn_af = AF_INET;\n\t\tbreak;\n\t}\n#endif\n#ifdef INET6\n\tcase AF_INET6:\n\t{\n\t\t/* ok to use deprecated addresses? */\n\t\tstruct sockaddr_in6 *sin6;\n\n\t\tsin6 = &sctp_ifap->address.sin6;\n\t\tif (SCTP_IFN_IS_IFT_LOOP(sctp_ifap->ifn_p) ||\n\t\t    (IN6_IS_ADDR_LOOPBACK(&sin6->sin6_addr))) {\n\t\t\tsctp_ifap->src_is_loop = 1;\n\t\t}\n\t\tif (IN6_IS_ADDR_LINKLOCAL(&sin6->sin6_addr)) {\n\t\t\tsctp_ifap->src_is_priv = 1;\n\t\t}\n\t\tsctp_ifnp->num_v6++;\n\t\tif (new_ifn_af)\n\t\t\tnew_ifn_af = AF_INET6;\n\t\tbreak;\n\t}\n#endif\n#if defined(__Userspace__)\n\tcase AF_CONN:\n\t\tif (new_ifn_af)\n\t\t\tnew_ifn_af = AF_CONN;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tnew_ifn_af = 0;\n\t\tbreak;\n\t}\n\thash_of_addr = sctp_get_ifa_hash_val(&sctp_ifap->address.sa);\n\n\tif ((sctp_ifap->src_is_priv == 0) &&\n\t    (sctp_ifap->src_is_loop == 0)) {\n\t\tsctp_ifap->src_is_glob = 1;\n\t}\n\tSCTP_IPI_ADDR_WLOCK();\n\thash_addr_head = &vrf->vrf_addr_hash[(hash_of_addr & vrf->vrf_addr_hashmark)];\n\tLIST_INSERT_HEAD(hash_addr_head, sctp_ifap, next_bucket);\n\tsctp_ifap->refcount = 1;\n\tLIST_INSERT_HEAD(&sctp_ifnp->ifalist, sctp_ifap, next_ifa);\n\tsctp_ifnp->ifa_count++;\n\tvrf->total_ifa_count++;\n\tatomic_add_int(&SCTP_BASE_INFO(ipi_count_ifas), 1);\n\tif (new_ifn_af) {\n\t\tSCTP_REGISTER_INTERFACE(ifn_index, new_ifn_af);\n\t\tsctp_ifnp->registered_af = new_ifn_af;\n\t}\n\tSCTP_IPI_ADDR_WUNLOCK();\n\tif (dynamic_add) {\n\t\t/* Bump up the refcount so that when the timer\n\t\t * completes it will drop back down.\n\t\t */\n\t\tstruct sctp_laddr *wi;\n\n\t\tatomic_add_int(&sctp_ifap->refcount, 1);\n\t\twi = SCTP_ZONE_GET(SCTP_BASE_INFO(ipi_zone_laddr), struct sctp_laddr);\n\t\tif (wi == NULL) {\n\t\t\t/*\n\t\t\t * Gak, what can we do? We have lost an address\n\t\t\t * change can you say HOSED?\n\t\t\t */\n\t\t\tSCTPDBG(SCTP_DEBUG_PCB4, \"Lost an address change?\\n\");\n\t\t\t/* Opps, must decrement the count */\n\t\t\tsctp_del_addr_from_vrf(vrf_id, addr, ifn_index,\n\t\t\t\t\t       if_name);\n\t\t\treturn (NULL);\n\t\t}\n\t\tSCTP_INCR_LADDR_COUNT();\n\t\tmemset(wi, 0, sizeof(*wi));\n\t\t(void)SCTP_GETTIME_TIMEVAL(&wi->start_time);\n\t\twi->ifa = sctp_ifap;\n\t\twi->action = SCTP_ADD_IP_ADDRESS;\n\n\t\tSCTP_WQ_ADDR_LOCK();\n\t\tLIST_INSERT_HEAD(&SCTP_BASE_INFO(addr_wq), wi, sctp_nxt_addr);\n\t\tsctp_timer_start(SCTP_TIMER_TYPE_ADDR_WQ,\n\t\t\t\t (struct sctp_inpcb *)NULL,\n\t\t\t\t (struct sctp_tcb *)NULL,\n\t\t\t\t (struct sctp_nets *)NULL);\n\t\tSCTP_WQ_ADDR_UNLOCK();\n\t} else {\n\t\t/* it's ready for use */\n\t\tsctp_ifap->localifa_flags &= ~SCTP_ADDR_DEFER_USE;\n\t}\n\treturn (sctp_ifap);\n}\n\nvoid\nsctp_del_addr_from_vrf(uint32_t vrf_id, struct sockaddr *addr,\n\t\t       uint32_t ifn_index, const char *if_name)\n{\n\tstruct sctp_vrf *vrf;\n\tstruct sctp_ifa *sctp_ifap = NULL;\n\n\tSCTP_IPI_ADDR_WLOCK();\n\tvrf = sctp_find_vrf(vrf_id);\n\tif (vrf == NULL) {\n\t\tSCTPDBG(SCTP_DEBUG_PCB4, \"Can't find vrf_id 0x%x\\n\", vrf_id);\n\t\tgoto out_now;\n\t}\n\n#ifdef SCTP_DEBUG\n\tSCTPDBG(SCTP_DEBUG_PCB4, \"vrf_id 0x%x: deleting address:\", vrf_id);\n\tSCTPDBG_ADDR(SCTP_DEBUG_PCB4, addr);\n#endif\n\tsctp_ifap = sctp_find_ifa_by_addr(addr, vrf->vrf_id, SCTP_ADDR_LOCKED);\n\tif (sctp_ifap) {\n\t\t/* Validate the delete */\n\t\tif (sctp_ifap->ifn_p) {\n\t\t\tint valid = 0;\n\t\t\t/*-\n\t\t\t * The name has priority over the ifn_index\n\t\t\t * if its given. We do this especially for\n\t\t\t * panda who might recycle indexes fast.\n\t\t\t */\n\t\t\tif (if_name) {\n\t\t\t\tif (strncmp(if_name, sctp_ifap->ifn_p->ifn_name, SCTP_IFNAMSIZ) == 0) {\n\t\t\t\t\t/* They match its a correct delete */\n\t\t\t\t\tvalid = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!valid) {\n\t\t\t\t/* last ditch check ifn_index */\n\t\t\t\tif (ifn_index == sctp_ifap->ifn_p->ifn_index) {\n\t\t\t\t\tvalid = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!valid) {\n\t\t\t\tSCTPDBG(SCTP_DEBUG_PCB4, \"ifn:%d ifname:%s does not match addresses\\n\",\n\t\t\t\t\tifn_index, ((if_name == NULL) ? \"NULL\" : if_name));\n\t\t\t\tSCTPDBG(SCTP_DEBUG_PCB4, \"ifn:%d ifname:%s - ignoring delete\\n\",\n\t\t\t\t\tsctp_ifap->ifn_p->ifn_index, sctp_ifap->ifn_p->ifn_name);\n\t\t\t\tSCTP_IPI_ADDR_WUNLOCK();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tSCTPDBG(SCTP_DEBUG_PCB4, \"Deleting ifa %p\\n\", (void *)sctp_ifap);\n\t\tsctp_ifap->localifa_flags &= SCTP_ADDR_VALID;\n                /*\n\t\t * We don't set the flag. This means that the structure will\n\t\t * hang around in EP's that have bound specific to it until\n\t\t * they close. This gives us TCP like behavior if someone\n\t\t * removes an address (or for that matter adds it right back).\n\t\t */\n\t\t/* sctp_ifap->localifa_flags |= SCTP_BEING_DELETED; */\n\t\tvrf->total_ifa_count--;\n\t\tLIST_REMOVE(sctp_ifap, next_bucket);\n\t\tsctp_remove_ifa_from_ifn(sctp_ifap);\n\t}\n#ifdef SCTP_DEBUG\n\telse {\n\t\tSCTPDBG(SCTP_DEBUG_PCB4, \"Del Addr-ifn:%d Could not find address:\",\n\t\t\tifn_index);\n\t\tSCTPDBG_ADDR(SCTP_DEBUG_PCB1, addr);\n\t}\n#endif\n\n out_now:\n\tSCTP_IPI_ADDR_WUNLOCK();\n\tif (sctp_ifap) {\n\t\tstruct sctp_laddr *wi;\n\n\t\twi = SCTP_ZONE_GET(SCTP_BASE_INFO(ipi_zone_laddr), struct sctp_laddr);\n\t\tif (wi == NULL) {\n\t\t\t/*\n\t\t\t * Gak, what can we do? We have lost an address\n\t\t\t * change can you say HOSED?\n\t\t\t */\n\t\t\tSCTPDBG(SCTP_DEBUG_PCB4, \"Lost an address change?\\n\");\n\n\t\t\t/* Oops, must decrement the count */\n\t\t\tsctp_free_ifa(sctp_ifap);\n\t\t\treturn;\n\t\t}\n\t\tSCTP_INCR_LADDR_COUNT();\n\t\tmemset(wi, 0, sizeof(*wi));\n\t\t(void)SCTP_GETTIME_TIMEVAL(&wi->start_time);\n\t\twi->ifa = sctp_ifap;\n\t\twi->action = SCTP_DEL_IP_ADDRESS;\n\t\tSCTP_WQ_ADDR_LOCK();\n\t\t/*\n\t\t * Should this really be a tailq? As it is we will process the\n\t\t * newest first :-0\n\t\t */\n\t\tLIST_INSERT_HEAD(&SCTP_BASE_INFO(addr_wq), wi, sctp_nxt_addr);\n\t\tsctp_timer_start(SCTP_TIMER_TYPE_ADDR_WQ,\n\t\t\t\t (struct sctp_inpcb *)NULL,\n\t\t\t\t (struct sctp_tcb *)NULL,\n\t\t\t\t (struct sctp_nets *)NULL);\n\t\tSCTP_WQ_ADDR_UNLOCK();\n\t}\n\treturn;\n}\n\n\nstatic int\nsctp_does_stcb_own_this_addr(struct sctp_tcb *stcb, struct sockaddr *to)\n{\n\tint loopback_scope;\n#if defined(INET)\n\tint ipv4_local_scope, ipv4_addr_legal;\n#endif\n#if defined(INET6)\n\tint local_scope, site_scope, ipv6_addr_legal;\n#endif\n#if defined(__Userspace__)\n\tint conn_addr_legal;\n#endif\n\tstruct sctp_vrf *vrf;\n\tstruct sctp_ifn *sctp_ifn;\n\tstruct sctp_ifa *sctp_ifa;\n\n\tloopback_scope = stcb->asoc.scope.loopback_scope;\n#if defined(INET)\n\tipv4_local_scope = stcb->asoc.scope.ipv4_local_scope;\n\tipv4_addr_legal = stcb->asoc.scope.ipv4_addr_legal;\n#endif\n#if defined(INET6)\n\tlocal_scope = stcb->asoc.scope.local_scope;\n\tsite_scope = stcb->asoc.scope.site_scope;\n\tipv6_addr_legal = stcb->asoc.scope.ipv6_addr_legal;\n#endif\n#if defined(__Userspace__)\n\tconn_addr_legal = stcb->asoc.scope.conn_addr_legal;\n#endif\n\n\tSCTP_IPI_ADDR_RLOCK();\n\tvrf = sctp_find_vrf(stcb->asoc.vrf_id);\n\tif (vrf == NULL) {\n\t\t/* no vrf, no addresses */\n\t\tSCTP_IPI_ADDR_RUNLOCK();\n\t\treturn (0);\n\t}\n\n\tif (stcb->sctp_ep->sctp_flags & SCTP_PCB_FLAGS_BOUNDALL) {\n\t\tLIST_FOREACH(sctp_ifn, &vrf->ifnlist, next_ifn) {\n\t\t\tif ((loopback_scope == 0) &&\n\t\t\t    SCTP_IFN_IS_IFT_LOOP(sctp_ifn)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tLIST_FOREACH(sctp_ifa, &sctp_ifn->ifalist, next_ifa) {\n\t\t\t\tif (sctp_is_addr_restricted(stcb, sctp_ifa) &&\n\t\t\t\t    (!sctp_is_addr_pending(stcb, sctp_ifa))) {\n\t\t\t\t\t/* We allow pending addresses, where we\n\t\t\t\t\t * have sent an asconf-add to be considered\n\t\t\t\t\t * valid.\n\t\t\t\t\t */\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (sctp_ifa->address.sa.sa_family != to->sa_family) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tswitch (sctp_ifa->address.sa.sa_family) {\n#ifdef INET\n\t\t\t\tcase AF_INET:\n\t\t\t\t\tif (ipv4_addr_legal) {\n\t\t\t\t\t\tstruct sockaddr_in *sin, *rsin;\n\n\t\t\t\t\t\tsin = &sctp_ifa->address.sin;\n\t\t\t\t\t\trsin = (struct sockaddr_in *)to;\n\t\t\t\t\t\tif ((ipv4_local_scope == 0) &&\n\t\t\t\t\t\t    IN4_ISPRIVATE_ADDRESS(&sin->sin_addr)) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n#if defined(__FreeBSD__)\n\t\t\t\t\t\tif (prison_check_ip4(stcb->sctp_ep->ip_inp.inp.inp_cred,\n\t\t\t\t\t\t                     &sin->sin_addr) != 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t\tif (sin->sin_addr.s_addr == rsin->sin_addr.s_addr) {\n\t\t\t\t\t\t\tSCTP_IPI_ADDR_RUNLOCK();\n\t\t\t\t\t\t\treturn (1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n#endif\n#ifdef INET6\n\t\t\t\tcase AF_INET6:\n\t\t\t\t\tif (ipv6_addr_legal) {\n\t\t\t\t\t\tstruct sockaddr_in6 *sin6, *rsin6;\n#if defined(SCTP_EMBEDDED_V6_SCOPE) && !defined(SCTP_KAME)\n\t\t\t\t\t\tstruct sockaddr_in6 lsa6;\n#endif\n\t\t\t\t\t\tsin6 = &sctp_ifa->address.sin6;\n\t\t\t\t\t\trsin6 = (struct sockaddr_in6 *)to;\n#if defined(__FreeBSD__)\n\t\t\t\t\t\tif (prison_check_ip6(stcb->sctp_ep->ip_inp.inp.inp_cred,\n\t\t\t\t\t\t                     &sin6->sin6_addr) != 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t\tif (IN6_IS_ADDR_LINKLOCAL(&sin6->sin6_addr)) {\n\t\t\t\t\t\t\tif (local_scope == 0)\n\t\t\t\t\t\t\t\tcontinue;\n#if defined(SCTP_EMBEDDED_V6_SCOPE)\n\t\t\t\t\t\t\tif (sin6->sin6_scope_id == 0) {\n#ifdef SCTP_KAME\n\t\t\t\t\t\t\t\tif (sa6_recoverscope(sin6) != 0)\n\t\t\t\t\t\t\t\t\tcontinue;\n#else\n\t\t\t\t\t\t\t\tlsa6 = *sin6;\n\t\t\t\t\t\t\t\tif (in6_recoverscope(&lsa6,\n\t\t\t\t\t\t\t\t                     &lsa6.sin6_addr,\n\t\t\t\t\t\t\t\t                     NULL))\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tsin6 = &lsa6;\n#endif /* SCTP_KAME */\n\t\t\t\t\t\t\t}\n#endif /* SCTP_EMBEDDED_V6_SCOPE */\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ((site_scope == 0) &&\n\t\t\t\t\t\t    (IN6_IS_ADDR_SITELOCAL(&sin6->sin6_addr))) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (SCTP6_ARE_ADDR_EQUAL(sin6, rsin6)) {\n\t\t\t\t\t\t\tSCTP_IPI_ADDR_RUNLOCK();\n\t\t\t\t\t\t\treturn (1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n#endif\n#if defined(__Userspace__)\n\t\t\t\tcase AF_CONN:\n\t\t\t\t\tif (conn_addr_legal) {\n\t\t\t\t\t\tstruct sockaddr_conn *sconn, *rsconn;\n\n\t\t\t\t\t\tsconn = &sctp_ifa->address.sconn;\n\t\t\t\t\t\trsconn = (struct sockaddr_conn *)to;\n\t\t\t\t\t\tif (sconn->sconn_addr == rsconn->sconn_addr) {\n\t\t\t\t\t\t\tSCTP_IPI_ADDR_RUNLOCK();\n\t\t\t\t\t\t\treturn (1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n#endif\n\t\t\t\tdefault:\n\t\t\t\t\t/* TSNH */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tstruct sctp_laddr *laddr;\n\n\t\tLIST_FOREACH(laddr, &stcb->sctp_ep->sctp_addr_list, sctp_nxt_addr) {\n\t\t\tif (laddr->ifa->localifa_flags & SCTP_BEING_DELETED) {\n\t\t\t\tSCTPDBG(SCTP_DEBUG_PCB1, \"ifa being deleted\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (sctp_is_addr_restricted(stcb, laddr->ifa) &&\n\t\t\t    (!sctp_is_addr_pending(stcb, laddr->ifa))) {\n\t\t\t\t/* We allow pending addresses, where we\n\t\t\t\t * have sent an asconf-add to be considered\n\t\t\t\t * valid.\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (laddr->ifa->address.sa.sa_family != to->sa_family) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tswitch (to->sa_family) {\n#ifdef INET\n\t\t\tcase AF_INET:\n\t\t\t{\n\t\t\t\tstruct sockaddr_in *sin, *rsin;\n\n\t\t\t\tsin = &laddr->ifa->address.sin;\n\t\t\t\trsin = (struct sockaddr_in *)to;\n\t\t\t\tif (sin->sin_addr.s_addr == rsin->sin_addr.s_addr) {\n\t\t\t\t\tSCTP_IPI_ADDR_RUNLOCK();\n\t\t\t\t\treturn (1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n#ifdef INET6\n\t\t\tcase AF_INET6:\n\t\t\t{\n\t\t\t\tstruct sockaddr_in6 *sin6, *rsin6;\n\n\t\t\t\tsin6 = &laddr->ifa->address.sin6;\n\t\t\t\trsin6 = (struct sockaddr_in6 *)to;\n\t\t\t\tif (SCTP6_ARE_ADDR_EQUAL(sin6, rsin6)) {\n\t\t\t\t\tSCTP_IPI_ADDR_RUNLOCK();\n\t\t\t\t\treturn (1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n#endif\n#if defined(__Userspace__)\n\t\t\tcase AF_CONN:\n\t\t\t{\n\t\t\t\tstruct sockaddr_conn *sconn, *rsconn;\n\n\t\t\t\tsconn = &laddr->ifa->address.sconn;\n\t\t\t\trsconn = (struct sockaddr_conn *)to;\n\t\t\t\tif (sconn->sconn_addr == rsconn->sconn_addr) {\n\t\t\t\t\tSCTP_IPI_ADDR_RUNLOCK();\n\t\t\t\t\treturn (1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n\t\t\tdefault:\n\t\t\t\t/* TSNH */\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\t}\n\tSCTP_IPI_ADDR_RUNLOCK();\n\treturn (0);\n}\n\n\nstatic struct sctp_tcb *\nsctp_tcb_special_locate(struct sctp_inpcb **inp_p, struct sockaddr *from,\n    struct sockaddr *to, struct sctp_nets **netp, uint32_t vrf_id)\n{\n\t/**** ASSUMES THE CALLER holds the INP_INFO_RLOCK */\n\t/*\n\t * If we support the TCP model, then we must now dig through to see\n\t * if we can find our endpoint in the list of tcp ep's.\n\t */\n\tuint16_t lport, rport;\n\tstruct sctppcbhead *ephead;\n\tstruct sctp_inpcb *inp;\n\tstruct sctp_laddr *laddr;\n\tstruct sctp_tcb *stcb;\n\tstruct sctp_nets *net;\n#ifdef SCTP_MVRF\n\tint fnd, i;\n#endif\n\n\tif ((to == NULL) || (from == NULL)) {\n\t\treturn (NULL);\n\t}\n\n\tswitch (to->sa_family) {\n#ifdef INET\n\tcase AF_INET:\n\t\tif (from->sa_family == AF_INET) {\n\t\t\tlport = ((struct sockaddr_in *)to)->sin_port;\n\t\t\trport = ((struct sockaddr_in *)from)->sin_port;\n\t\t} else {\n\t\t\treturn (NULL);\n\t\t}\n\t\tbreak;\n#endif\n#ifdef INET6\n\tcase AF_INET6:\n\t\tif (from->sa_family == AF_INET6) {\n\t\t\tlport = ((struct sockaddr_in6 *)to)->sin6_port;\n\t\t\trport = ((struct sockaddr_in6 *)from)->sin6_port;\n\t\t} else {\n\t\t\treturn (NULL);\n\t\t}\n\t\tbreak;\n#endif\n#if defined(__Userspace__)\n\tcase AF_CONN:\n\t\tif (from->sa_family == AF_CONN) {\n\t\t\tlport = ((struct sockaddr_conn *)to)->sconn_port;\n\t\t\trport = ((struct sockaddr_conn *)from)->sconn_port;\n\t\t} else {\n\t\t\treturn (NULL);\n\t\t}\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn (NULL);\n\t}\n\tephead = &SCTP_BASE_INFO(sctp_tcpephash)[SCTP_PCBHASH_ALLADDR((lport | rport), SCTP_BASE_INFO(hashtcpmark))];\n\t/*\n\t * Ok now for each of the guys in this bucket we must look and see:\n\t * - Does the remote port match. - Does there single association's\n\t * addresses match this address (to). If so we update p_ep to point\n\t * to this ep and return the tcb from it.\n\t */\n\tLIST_FOREACH(inp, ephead, sctp_hash) {\n\t\tSCTP_INP_RLOCK(inp);\n\t\tif (inp->sctp_flags & SCTP_PCB_FLAGS_SOCKET_ALLGONE) {\n\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\tcontinue;\n\t\t}\n\t\tif (lport != inp->sctp_lport) {\n\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\tcontinue;\n\t\t}\n#if defined(__FreeBSD__)\n\t\tswitch (to->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t{\n\t\t\tstruct sockaddr_in *sin;\n\n\t\t\tsin = (struct sockaddr_in *)to;\n\t\t\tif (prison_check_ip4(inp->ip_inp.inp.inp_cred,\n\t\t\t                     &sin->sin_addr) != 0) {\n\t\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n#endif\n#ifdef INET6\n\t\tcase AF_INET6:\n\t\t{\n\t\t\tstruct sockaddr_in6 *sin6;\n\n\t\t\tsin6 = (struct sockaddr_in6 *)to;\n\t\t\tif (prison_check_ip6(inp->ip_inp.inp.inp_cred,\n\t\t\t                     &sin6->sin6_addr) != 0) {\n\t\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\tcontinue;\n\t\t}\n#endif\n#ifdef SCTP_MVRF\n\t\tfnd = 0;\n\t\tfor (i = 0; i < inp->num_vrfs; i++) {\n\t\t\tif (inp->m_vrf_ids[i] == vrf_id) {\n\t\t\t\tfnd = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (fnd == 0) {\n\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\tcontinue;\n\t\t}\n#else\n\t\tif (inp->def_vrf_id != vrf_id) {\n\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\tcontinue;\n\t\t}\n#endif\n\t\t/* check to see if the ep has one of the addresses */\n\t\tif ((inp->sctp_flags & SCTP_PCB_FLAGS_BOUNDALL) == 0) {\n\t\t\t/* We are NOT bound all, so look further */\n\t\t\tint match = 0;\n\n\t\t\tLIST_FOREACH(laddr, &inp->sctp_addr_list, sctp_nxt_addr) {\n\n\t\t\t\tif (laddr->ifa == NULL) {\n\t\t\t\t\tSCTPDBG(SCTP_DEBUG_PCB1, \"%s: NULL ifa\\n\", __func__);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (laddr->ifa->localifa_flags & SCTP_BEING_DELETED) {\n\t\t\t\t\tSCTPDBG(SCTP_DEBUG_PCB1, \"ifa being deleted\\n\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (laddr->ifa->address.sa.sa_family ==\n\t\t\t\t    to->sa_family) {\n\t\t\t\t\t/* see if it matches */\n#ifdef INET\n\t\t\t\t\tif (from->sa_family == AF_INET) {\n\t\t\t\t\t\tstruct sockaddr_in *intf_addr, *sin;\n\n\t\t\t\t\t\tintf_addr = &laddr->ifa->address.sin;\n\t\t\t\t\t\tsin = (struct sockaddr_in *)to;\n\t\t\t\t\t\tif (sin->sin_addr.s_addr ==\n\t\t\t\t\t\t    intf_addr->sin_addr.s_addr) {\n\t\t\t\t\t\t\tmatch = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n#ifdef INET6\n\t\t\t\t\tif (from->sa_family == AF_INET6) {\n\t\t\t\t\t\tstruct sockaddr_in6 *intf_addr6;\n\t\t\t\t\t\tstruct sockaddr_in6 *sin6;\n\n\t\t\t\t\t\tsin6 = (struct sockaddr_in6 *)\n\t\t\t\t\t\t    to;\n\t\t\t\t\t\tintf_addr6 = &laddr->ifa->address.sin6;\n\n\t\t\t\t\t\tif (SCTP6_ARE_ADDR_EQUAL(sin6,\n\t\t\t\t\t\t    intf_addr6)) {\n\t\t\t\t\t\t\tmatch = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n#if defined(__Userspace__)\n\t\t\t\t\tif (from->sa_family == AF_CONN) {\n\t\t\t\t\t\tstruct sockaddr_conn *intf_addr, *sconn;\n\n\t\t\t\t\t\tintf_addr = &laddr->ifa->address.sconn;\n\t\t\t\t\t\tsconn = (struct sockaddr_conn *)to;\n\t\t\t\t\t\tif (sconn->sconn_addr ==\n\t\t\t\t\t\t    intf_addr->sconn_addr) {\n\t\t\t\t\t\t\tmatch = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (match == 0) {\n\t\t\t\t/* This endpoint does not have this address */\n\t\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Ok if we hit here the ep has the address, does it hold\n\t\t * the tcb?\n\t\t */\n\t\t/* XXX: Why don't we TAILQ_FOREACH through sctp_asoc_list? */\n\t\tstcb = LIST_FIRST(&inp->sctp_asoc_list);\n\t\tif (stcb == NULL) {\n\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\tcontinue;\n\t\t}\n\t\tSCTP_TCB_LOCK(stcb);\n\t\tif (!sctp_does_stcb_own_this_addr(stcb, to)) {\n\t\t\tSCTP_TCB_UNLOCK(stcb);\n\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\tcontinue;\n\t\t}\n\t\tif (stcb->rport != rport) {\n\t\t\t/* remote port does not match. */\n\t\t\tSCTP_TCB_UNLOCK(stcb);\n\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\tcontinue;\n\t\t}\n\t\tif (stcb->asoc.state & SCTP_STATE_ABOUT_TO_BE_FREED) {\n\t\t\tSCTP_TCB_UNLOCK(stcb);\n\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!sctp_does_stcb_own_this_addr(stcb, to)) {\n\t\t\tSCTP_TCB_UNLOCK(stcb);\n\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Does this TCB have a matching address? */\n\t\tTAILQ_FOREACH(net, &stcb->asoc.nets, sctp_next) {\n\n\t\t\tif (net->ro._l_addr.sa.sa_family != from->sa_family) {\n\t\t\t\t/* not the same family, can't be a match */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tswitch (from->sa_family) {\n#ifdef INET\n\t\t\tcase AF_INET:\n\t\t\t{\n\t\t\t\tstruct sockaddr_in *sin, *rsin;\n\n\t\t\t\tsin = (struct sockaddr_in *)&net->ro._l_addr;\n\t\t\t\trsin = (struct sockaddr_in *)from;\n\t\t\t\tif (sin->sin_addr.s_addr ==\n\t\t\t\t    rsin->sin_addr.s_addr) {\n\t\t\t\t\t/* found it */\n\t\t\t\t\tif (netp != NULL) {\n\t\t\t\t\t\t*netp = net;\n\t\t\t\t\t}\n\t\t\t\t\t/* Update the endpoint pointer */\n\t\t\t\t\t*inp_p = inp;\n\t\t\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\t\t\treturn (stcb);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n#ifdef INET6\n\t\t\tcase AF_INET6:\n\t\t\t{\n\t\t\t\tstruct sockaddr_in6 *sin6, *rsin6;\n\n\t\t\t\tsin6 = (struct sockaddr_in6 *)&net->ro._l_addr;\n\t\t\t\trsin6 = (struct sockaddr_in6 *)from;\n\t\t\t\tif (SCTP6_ARE_ADDR_EQUAL(sin6,\n\t\t\t\t    rsin6)) {\n\t\t\t\t\t/* found it */\n\t\t\t\t\tif (netp != NULL) {\n\t\t\t\t\t\t*netp = net;\n\t\t\t\t\t}\n\t\t\t\t\t/* Update the endpoint pointer */\n\t\t\t\t\t*inp_p = inp;\n\t\t\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\t\t\treturn (stcb);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n#if defined(__Userspace__)\n\t\t\tcase AF_CONN:\n\t\t\t{\n\t\t\t\tstruct sockaddr_conn *sconn, *rsconn;\n\n\t\t\t\tsconn = (struct sockaddr_conn *)&net->ro._l_addr;\n\t\t\t\trsconn = (struct sockaddr_conn *)from;\n\t\t\t\tif (sconn->sconn_addr == rsconn->sconn_addr) {\n\t\t\t\t\t/* found it */\n\t\t\t\t\tif (netp != NULL) {\n\t\t\t\t\t\t*netp = net;\n\t\t\t\t\t}\n\t\t\t\t\t/* Update the endpoint pointer */\n\t\t\t\t\t*inp_p = inp;\n\t\t\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\t\t\treturn (stcb);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n\t\t\tdefault:\n\t\t\t\t/* TSNH */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tSCTP_TCB_UNLOCK(stcb);\n\t\tSCTP_INP_RUNLOCK(inp);\n\t}\n\treturn (NULL);\n}\n\n\n/*\n * rules for use\n *\n * 1) If I return a NULL you must decrement any INP ref cnt. 2) If I find an\n * stcb, both will be locked (locked_tcb and stcb) but decrement will be done\n * (if locked == NULL). 3) Decrement happens on return ONLY if locked ==\n * NULL.\n */\n\nstruct sctp_tcb *\nsctp_findassociation_ep_addr(struct sctp_inpcb **inp_p, struct sockaddr *remote,\n    struct sctp_nets **netp, struct sockaddr *local, struct sctp_tcb *locked_tcb)\n{\n\tstruct sctpasochead *head;\n\tstruct sctp_inpcb *inp;\n\tstruct sctp_tcb *stcb = NULL;\n\tstruct sctp_nets *net;\n\tuint16_t rport;\n\n\tinp = *inp_p;\n\tswitch (remote->sa_family) {\n#ifdef INET\n\tcase AF_INET:\n\t\trport = (((struct sockaddr_in *)remote)->sin_port);\n\t\tbreak;\n#endif\n#ifdef INET6\n\tcase AF_INET6:\n\t\trport = (((struct sockaddr_in6 *)remote)->sin6_port);\n\t\tbreak;\n#endif\n#if defined(__Userspace__)\n\tcase AF_CONN:\n\t\trport = (((struct sockaddr_conn *)remote)->sconn_port);\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn (NULL);\n\t}\n\tif (locked_tcb) {\n\t\t/*\n\t\t * UN-lock so we can do proper locking here this occurs when\n\t\t * called from load_addresses_from_init.\n\t\t */\n\t\tatomic_add_int(&locked_tcb->asoc.refcnt, 1);\n\t\tSCTP_TCB_UNLOCK(locked_tcb);\n\t}\n\tSCTP_INP_INFO_RLOCK();\n\tif ((inp->sctp_flags & SCTP_PCB_FLAGS_TCPTYPE) ||\n\t    (inp->sctp_flags & SCTP_PCB_FLAGS_IN_TCPPOOL)) {\n\t\t/*-\n\t\t * Now either this guy is our listener or it's the\n\t\t * connector. If it is the one that issued the connect, then\n\t\t * it's only chance is to be the first TCB in the list. If\n\t\t * it is the acceptor, then do the special_lookup to hash\n\t\t * and find the real inp.\n\t\t */\n\t\tif ((inp->sctp_socket) && SCTP_IS_LISTENING(inp)) {\n\t\t\t/* to is peer addr, from is my addr */\n#ifndef SCTP_MVRF\n\t\t\tstcb = sctp_tcb_special_locate(inp_p, remote, local,\n\t\t\t    netp, inp->def_vrf_id);\n\t\t\tif ((stcb != NULL) && (locked_tcb == NULL)) {\n\t\t\t\t/* we have a locked tcb, lower refcount */\n\t\t\t\tSCTP_INP_DECR_REF(inp);\n\t\t\t}\n\t\t\tif ((locked_tcb != NULL) && (locked_tcb != stcb)) {\n\t\t\t\tSCTP_INP_RLOCK(locked_tcb->sctp_ep);\n\t\t\t\tSCTP_TCB_LOCK(locked_tcb);\n\t\t\t\tatomic_subtract_int(&locked_tcb->asoc.refcnt, 1);\n\t\t\t\tSCTP_INP_RUNLOCK(locked_tcb->sctp_ep);\n\t\t\t}\n#else\n\t\t\t/*-\n\t\t\t * MVRF is tricky, we must look in every VRF\n\t\t\t * the endpoint has.\n\t\t\t */\n\t\t\tint i;\n\n\t\t\tfor (i = 0; i < inp->num_vrfs; i++) {\n\t\t\t\tstcb = sctp_tcb_special_locate(inp_p, remote, local,\n\t\t\t\t                               netp, inp->m_vrf_ids[i]);\n\t\t\t\tif ((stcb != NULL) && (locked_tcb == NULL)) {\n\t\t\t\t\t/* we have a locked tcb, lower refcount */\n\t\t\t\t\tSCTP_INP_DECR_REF(inp);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif ((locked_tcb != NULL) && (locked_tcb != stcb)) {\n\t\t\t\t\tSCTP_INP_RLOCK(locked_tcb->sctp_ep);\n\t\t\t\t\tSCTP_TCB_LOCK(locked_tcb);\n\t\t\t\t\tatomic_subtract_int(&locked_tcb->asoc.refcnt, 1);\n\t\t\t\t\tSCTP_INP_RUNLOCK(locked_tcb->sctp_ep);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\tSCTP_INP_INFO_RUNLOCK();\n\t\t\treturn (stcb);\n\t\t} else {\n\t\t\tSCTP_INP_WLOCK(inp);\n\t\t\tif (inp->sctp_flags & SCTP_PCB_FLAGS_SOCKET_ALLGONE) {\n\t\t\t\tgoto null_return;\n\t\t\t}\n\t\t\tstcb = LIST_FIRST(&inp->sctp_asoc_list);\n\t\t\tif (stcb == NULL) {\n\t\t\t\tgoto null_return;\n\t\t\t}\n\t\t\tSCTP_TCB_LOCK(stcb);\n\n\t\t\tif (stcb->rport != rport) {\n\t\t\t\t/* remote port does not match. */\n\t\t\t\tSCTP_TCB_UNLOCK(stcb);\n\t\t\t\tgoto null_return;\n\t\t\t}\n\t\t\tif (stcb->asoc.state & SCTP_STATE_ABOUT_TO_BE_FREED) {\n\t\t\t\tSCTP_TCB_UNLOCK(stcb);\n\t\t\t\tgoto null_return;\n\t\t\t}\n\t\t\tif (local && !sctp_does_stcb_own_this_addr(stcb, local)) {\n\t\t\t\tSCTP_TCB_UNLOCK(stcb);\n\t\t\t\tgoto null_return;\n\t\t\t}\n\t\t\t/* now look at the list of remote addresses */\n\t\t\tTAILQ_FOREACH(net, &stcb->asoc.nets, sctp_next) {\n#ifdef INVARIANTS\n\t\t\t\tif (net == (TAILQ_NEXT(net, sctp_next))) {\n\t\t\t\t\tpanic(\"Corrupt net list\");\n\t\t\t\t}\n#endif\n\t\t\t\tif (net->ro._l_addr.sa.sa_family !=\n\t\t\t\t    remote->sa_family) {\n\t\t\t\t\t/* not the same family */\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tswitch (remote->sa_family) {\n#ifdef INET\n\t\t\t\tcase AF_INET:\n\t\t\t\t{\n\t\t\t\t\tstruct sockaddr_in *sin, *rsin;\n\n\t\t\t\t\tsin = (struct sockaddr_in *)\n\t\t\t\t\t    &net->ro._l_addr;\n\t\t\t\t\trsin = (struct sockaddr_in *)remote;\n\t\t\t\t\tif (sin->sin_addr.s_addr ==\n\t\t\t\t\t    rsin->sin_addr.s_addr) {\n\t\t\t\t\t\t/* found it */\n\t\t\t\t\t\tif (netp != NULL) {\n\t\t\t\t\t\t\t*netp = net;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (locked_tcb == NULL) {\n\t\t\t\t\t\t\tSCTP_INP_DECR_REF(inp);\n\t\t\t\t\t\t} else if (locked_tcb != stcb) {\n\t\t\t\t\t\t\tSCTP_TCB_LOCK(locked_tcb);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (locked_tcb) {\n\t\t\t\t\t\t\tatomic_subtract_int(&locked_tcb->asoc.refcnt, 1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tSCTP_INP_WUNLOCK(inp);\n\t\t\t\t\t\tSCTP_INP_INFO_RUNLOCK();\n\t\t\t\t\t\treturn (stcb);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n#endif\n#ifdef INET6\n\t\t\t\tcase AF_INET6:\n\t\t\t\t{\n\t\t\t\t\tstruct sockaddr_in6 *sin6, *rsin6;\n\n\t\t\t\t\tsin6 = (struct sockaddr_in6 *)&net->ro._l_addr;\n\t\t\t\t\trsin6 = (struct sockaddr_in6 *)remote;\n\t\t\t\t\tif (SCTP6_ARE_ADDR_EQUAL(sin6,\n\t\t\t\t\t    rsin6)) {\n\t\t\t\t\t\t/* found it */\n\t\t\t\t\t\tif (netp != NULL) {\n\t\t\t\t\t\t\t*netp = net;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (locked_tcb == NULL) {\n\t\t\t\t\t\t\tSCTP_INP_DECR_REF(inp);\n\t\t\t\t\t\t} else if (locked_tcb != stcb) {\n\t\t\t\t\t\t\tSCTP_TCB_LOCK(locked_tcb);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (locked_tcb) {\n\t\t\t\t\t\t\tatomic_subtract_int(&locked_tcb->asoc.refcnt, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tSCTP_INP_WUNLOCK(inp);\n\t\t\t\t\t\tSCTP_INP_INFO_RUNLOCK();\n\t\t\t\t\t\treturn (stcb);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n#endif\n#if defined(__Userspace__)\n\t\t\t\tcase AF_CONN:\n\t\t\t\t{\n\t\t\t\t\tstruct sockaddr_conn *sconn, *rsconn;\n\n\t\t\t\t\tsconn = (struct sockaddr_conn *)&net->ro._l_addr;\n\t\t\t\t\trsconn = (struct sockaddr_conn *)remote;\n\t\t\t\t\tif (sconn->sconn_addr == rsconn->sconn_addr) {\n\t\t\t\t\t\t/* found it */\n\t\t\t\t\t\tif (netp != NULL) {\n\t\t\t\t\t\t\t*netp = net;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (locked_tcb == NULL) {\n\t\t\t\t\t\t\tSCTP_INP_DECR_REF(inp);\n\t\t\t\t\t\t} else if (locked_tcb != stcb) {\n\t\t\t\t\t\t\tSCTP_TCB_LOCK(locked_tcb);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (locked_tcb) {\n\t\t\t\t\t\t\tatomic_subtract_int(&locked_tcb->asoc.refcnt, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tSCTP_INP_WUNLOCK(inp);\n\t\t\t\t\t\tSCTP_INP_INFO_RUNLOCK();\n\t\t\t\t\t\treturn (stcb);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n#endif\n\t\t\t\tdefault:\n\t\t\t\t\t/* TSNH */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSCTP_TCB_UNLOCK(stcb);\n\t\t}\n\t} else {\n\t\tSCTP_INP_WLOCK(inp);\n\t\tif (inp->sctp_flags & SCTP_PCB_FLAGS_SOCKET_ALLGONE) {\n\t\t\tgoto null_return;\n\t\t}\n\t\thead = &inp->sctp_tcbhash[SCTP_PCBHASH_ALLADDR(rport,\n\t\t                                               inp->sctp_hashmark)];\n\t\tLIST_FOREACH(stcb, head, sctp_tcbhash) {\n\t\t\tif (stcb->rport != rport) {\n\t\t\t\t/* remote port does not match */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tSCTP_TCB_LOCK(stcb);\n\t\t\tif (stcb->asoc.state & SCTP_STATE_ABOUT_TO_BE_FREED) {\n\t\t\t\tSCTP_TCB_UNLOCK(stcb);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (local && !sctp_does_stcb_own_this_addr(stcb, local)) {\n\t\t\t\tSCTP_TCB_UNLOCK(stcb);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* now look at the list of remote addresses */\n\t\t\tTAILQ_FOREACH(net, &stcb->asoc.nets, sctp_next) {\n#ifdef INVARIANTS\n\t\t\t\tif (net == (TAILQ_NEXT(net, sctp_next))) {\n\t\t\t\t\tpanic(\"Corrupt net list\");\n\t\t\t\t}\n#endif\n\t\t\t\tif (net->ro._l_addr.sa.sa_family !=\n\t\t\t\t    remote->sa_family) {\n\t\t\t\t\t/* not the same family */\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tswitch (remote->sa_family) {\n#ifdef INET\n\t\t\t\tcase AF_INET:\n\t\t\t\t{\n\t\t\t\t\tstruct sockaddr_in *sin, *rsin;\n\n\t\t\t\t\tsin = (struct sockaddr_in *)\n\t\t\t\t\t    &net->ro._l_addr;\n\t\t\t\t\trsin = (struct sockaddr_in *)remote;\n\t\t\t\t\tif (sin->sin_addr.s_addr ==\n\t\t\t\t\t    rsin->sin_addr.s_addr) {\n\t\t\t\t\t\t/* found it */\n\t\t\t\t\t\tif (netp != NULL) {\n\t\t\t\t\t\t\t*netp = net;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (locked_tcb == NULL) {\n\t\t\t\t\t\t\tSCTP_INP_DECR_REF(inp);\n\t\t\t\t\t\t} else if (locked_tcb != stcb) {\n\t\t\t\t\t\t\tSCTP_TCB_LOCK(locked_tcb);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (locked_tcb) {\n\t\t\t\t\t\t\tatomic_subtract_int(&locked_tcb->asoc.refcnt, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tSCTP_INP_WUNLOCK(inp);\n\t\t\t\t\t\tSCTP_INP_INFO_RUNLOCK();\n\t\t\t\t\t\treturn (stcb);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n#endif\n#ifdef INET6\n\t\t\t\tcase AF_INET6:\n\t\t\t\t{\n\t\t\t\t\tstruct sockaddr_in6 *sin6, *rsin6;\n\n\t\t\t\t\tsin6 = (struct sockaddr_in6 *)\n\t\t\t\t\t    &net->ro._l_addr;\n\t\t\t\t\trsin6 = (struct sockaddr_in6 *)remote;\n\t\t\t\t\tif (SCTP6_ARE_ADDR_EQUAL(sin6,\n\t\t\t\t\t    rsin6)) {\n\t\t\t\t\t\t/* found it */\n\t\t\t\t\t\tif (netp != NULL) {\n\t\t\t\t\t\t\t*netp = net;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (locked_tcb == NULL) {\n\t\t\t\t\t\t\tSCTP_INP_DECR_REF(inp);\n\t\t\t\t\t\t} else if (locked_tcb != stcb) {\n\t\t\t\t\t\t\tSCTP_TCB_LOCK(locked_tcb);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (locked_tcb) {\n\t\t\t\t\t\t\tatomic_subtract_int(&locked_tcb->asoc.refcnt, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tSCTP_INP_WUNLOCK(inp);\n\t\t\t\t\t\tSCTP_INP_INFO_RUNLOCK();\n\t\t\t\t\t\treturn (stcb);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n#endif\n#if defined(__Userspace__)\n\t\t\t\tcase AF_CONN:\n\t\t\t\t{\n\t\t\t\t\tstruct sockaddr_conn *sconn, *rsconn;\n\n\t\t\t\t\tsconn = (struct sockaddr_conn *)&net->ro._l_addr;\n\t\t\t\t\trsconn = (struct sockaddr_conn *)remote;\n\t\t\t\t\tif (sconn->sconn_addr == rsconn->sconn_addr) {\n\t\t\t\t\t\t/* found it */\n\t\t\t\t\t\tif (netp != NULL) {\n\t\t\t\t\t\t\t*netp = net;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (locked_tcb == NULL) {\n\t\t\t\t\t\t\tSCTP_INP_DECR_REF(inp);\n\t\t\t\t\t\t} else if (locked_tcb != stcb) {\n\t\t\t\t\t\t\tSCTP_TCB_LOCK(locked_tcb);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (locked_tcb) {\n\t\t\t\t\t\t\tatomic_subtract_int(&locked_tcb->asoc.refcnt, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tSCTP_INP_WUNLOCK(inp);\n\t\t\t\t\t\tSCTP_INP_INFO_RUNLOCK();\n\t\t\t\t\t\treturn (stcb);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n#endif\n\t\t\t\tdefault:\n\t\t\t\t\t/* TSNH */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSCTP_TCB_UNLOCK(stcb);\n\t\t}\n\t}\nnull_return:\n\t/* clean up for returning null */\n\tif (locked_tcb) {\n\t\tSCTP_TCB_LOCK(locked_tcb);\n\t\tatomic_subtract_int(&locked_tcb->asoc.refcnt, 1);\n\t}\n\tSCTP_INP_WUNLOCK(inp);\n\tSCTP_INP_INFO_RUNLOCK();\n\t/* not found */\n\treturn (NULL);\n}\n\n\n/*\n * Find an association for a specific endpoint using the association id given\n * out in the COMM_UP notification\n */\nstruct sctp_tcb *\nsctp_findasoc_ep_asocid_locked(struct sctp_inpcb *inp, sctp_assoc_t asoc_id, int want_lock)\n{\n\t/*\n\t * Use my the assoc_id to find a endpoint\n\t */\n\tstruct sctpasochead *head;\n\tstruct sctp_tcb *stcb;\n\tuint32_t id;\n\n\tif (inp == NULL) {\n\t\tSCTP_PRINTF(\"TSNH ep_associd\\n\");\n\t\treturn (NULL);\n\t}\n\tif (inp->sctp_flags & SCTP_PCB_FLAGS_SOCKET_ALLGONE) {\n\t\tSCTP_PRINTF(\"TSNH ep_associd0\\n\");\n\t\treturn (NULL);\n\t}\n\tid = (uint32_t)asoc_id;\n\thead = &inp->sctp_asocidhash[SCTP_PCBHASH_ASOC(id, inp->hashasocidmark)];\n\tif (head == NULL) {\n\t\t/* invalid id TSNH */\n\t\tSCTP_PRINTF(\"TSNH ep_associd1\\n\");\n\t\treturn (NULL);\n\t}\n\tLIST_FOREACH(stcb, head, sctp_tcbasocidhash) {\n\t\tif (stcb->asoc.assoc_id == id) {\n\t\t\tif (inp != stcb->sctp_ep) {\n\t\t\t\t/*\n\t\t\t\t * some other guy has the same id active (id\n\t\t\t\t * collision ??).\n\t\t\t\t */\n\t\t\t\tSCTP_PRINTF(\"TSNH ep_associd2\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (stcb->asoc.state & SCTP_STATE_ABOUT_TO_BE_FREED) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (want_lock) {\n\t\t\t\tSCTP_TCB_LOCK(stcb);\n\t\t\t}\n\t\t\treturn (stcb);\n\t\t}\n\t}\n\treturn (NULL);\n}\n\n\nstruct sctp_tcb *\nsctp_findassociation_ep_asocid(struct sctp_inpcb *inp, sctp_assoc_t asoc_id, int want_lock)\n{\n\tstruct sctp_tcb *stcb;\n\n\tSCTP_INP_RLOCK(inp);\n\tstcb = sctp_findasoc_ep_asocid_locked(inp, asoc_id, want_lock);\n\tSCTP_INP_RUNLOCK(inp);\n\treturn (stcb);\n}\n\n\n/*\n * Endpoint probe expects that the INP_INFO is locked.\n */\nstatic struct sctp_inpcb *\nsctp_endpoint_probe(struct sockaddr *nam, struct sctppcbhead *head,\n\t\t    uint16_t lport, uint32_t vrf_id)\n{\n\tstruct sctp_inpcb *inp;\n\tstruct sctp_laddr *laddr;\n#ifdef INET\n\tstruct sockaddr_in *sin;\n#endif\n#ifdef INET6\n\tstruct sockaddr_in6 *sin6;\n\tstruct sockaddr_in6 *intf_addr6;\n#endif\n#if defined(__Userspace__)\n\tstruct sockaddr_conn *sconn;\n#endif\n#ifdef SCTP_MVRF\n\tint i;\n#endif\n\tint  fnd;\n\n#ifdef INET\n\tsin = NULL;\n#endif\n#ifdef INET6\n\tsin6 = NULL;\n#endif\n#if defined(__Userspace__)\n\tsconn = NULL;\n#endif\n\tswitch (nam->sa_family) {\n#ifdef INET\n\tcase AF_INET:\n\t\tsin = (struct sockaddr_in *)nam;\n\t\tbreak;\n#endif\n#ifdef INET6\n\tcase AF_INET6:\n\t\tsin6 = (struct sockaddr_in6 *)nam;\n\t\tbreak;\n#endif\n#if defined(__Userspace__)\n\tcase AF_CONN:\n\t\tsconn = (struct sockaddr_conn *)nam;\n\t\tbreak;\n#endif\n\tdefault:\n\t\t/* unsupported family */\n\t\treturn (NULL);\n\t}\n\n\tif (head == NULL)\n\t\treturn (NULL);\n\n\tLIST_FOREACH(inp, head, sctp_hash) {\n\t\tSCTP_INP_RLOCK(inp);\n\t\tif (inp->sctp_flags & SCTP_PCB_FLAGS_SOCKET_ALLGONE) {\n\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((inp->sctp_flags & SCTP_PCB_FLAGS_BOUNDALL) &&\n\t\t    (inp->sctp_lport == lport)) {\n\t\t\t/* got it */\n\t\t\tswitch (nam->sa_family) {\n#ifdef INET\n\t\t\tcase AF_INET:\n\t\t\t\tif ((inp->sctp_flags & SCTP_PCB_FLAGS_BOUND_V6) &&\n\t\t\t\t    SCTP_IPV6_V6ONLY(inp)) {\n\t\t\t\t\t/* IPv4 on a IPv6 socket with ONLY IPv6 set */\n\t\t\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n#if defined(__FreeBSD__)\n\t\t\t\tif (prison_check_ip4(inp->ip_inp.inp.inp_cred,\n\t\t\t\t                     &sin->sin_addr) != 0) {\n\t\t\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n#endif\n\t\t\t\tbreak;\n#endif\n#ifdef INET6\n\t\t\tcase AF_INET6:\n\t\t\t\t/* A V6 address and the endpoint is NOT bound V6 */\n\t\t\t\tif ((inp->sctp_flags & SCTP_PCB_FLAGS_BOUND_V6) == 0) {\n\t\t\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n#if defined(__FreeBSD__)\n\t\t\t\tif (prison_check_ip6(inp->ip_inp.inp.inp_cred,\n\t\t\t\t                     &sin6->sin6_addr) != 0) {\n\t\t\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n#endif\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* does a VRF id match? */\n\t\t\tfnd = 0;\n#ifdef SCTP_MVRF\n\t\t\tfor (i = 0; i < inp->num_vrfs; i++) {\n\t\t\t\tif (inp->m_vrf_ids[i] == vrf_id) {\n\t\t\t\t\tfnd = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n#else\n\t\t\tif (inp->def_vrf_id == vrf_id)\n\t\t\t\tfnd = 1;\n#endif\n\n\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\tif (!fnd)\n\t\t\t\tcontinue;\n\t\t\treturn (inp);\n\t\t}\n\t\tSCTP_INP_RUNLOCK(inp);\n\t}\n\tswitch (nam->sa_family) {\n#ifdef INET\n\tcase AF_INET:\n\t\tif (sin->sin_addr.s_addr == INADDR_ANY) {\n\t\t\t/* Can't hunt for one that has no address specified */\n\t\t\treturn (NULL);\n\t\t}\n\t\tbreak;\n#endif\n#ifdef INET6\n\tcase AF_INET6:\n\t\tif (IN6_IS_ADDR_UNSPECIFIED(&sin6->sin6_addr)) {\n\t\t\t/* Can't hunt for one that has no address specified */\n\t\t\treturn (NULL);\n\t\t}\n\t\tbreak;\n#endif\n#if defined(__Userspace__)\n\tcase AF_CONN:\n\t\tif (sconn->sconn_addr == NULL) {\n\t\t\treturn (NULL);\n\t\t}\n\t\tbreak;\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\t/*\n\t * ok, not bound to all so see if we can find a EP bound to this\n\t * address.\n\t */\n\tLIST_FOREACH(inp, head, sctp_hash) {\n\t\tSCTP_INP_RLOCK(inp);\n\t\tif (inp->sctp_flags & SCTP_PCB_FLAGS_SOCKET_ALLGONE) {\n\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((inp->sctp_flags & SCTP_PCB_FLAGS_BOUNDALL)) {\n\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Ok this could be a likely candidate, look at all of its\n\t\t * addresses\n\t\t */\n\t\tif (inp->sctp_lport != lport) {\n\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\tcontinue;\n\t\t}\n\t\t/* does a VRF id match? */\n\t\tfnd = 0;\n#ifdef SCTP_MVRF\n\t\tfor (i = 0; i < inp->num_vrfs; i++) {\n\t\t\tif (inp->m_vrf_ids[i] == vrf_id) {\n\t\t\t\tfnd = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n#else\n\t\tif (inp->def_vrf_id == vrf_id)\n\t\t\tfnd = 1;\n\n#endif\n\t\tif (!fnd) {\n\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\tcontinue;\n\t\t}\n\t\tLIST_FOREACH(laddr, &inp->sctp_addr_list, sctp_nxt_addr) {\n\t\t\tif (laddr->ifa == NULL) {\n\t\t\t\tSCTPDBG(SCTP_DEBUG_PCB1, \"%s: NULL ifa\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tSCTPDBG(SCTP_DEBUG_PCB1, \"Ok laddr->ifa:%p is possible, \",\n\t\t\t\t(void *)laddr->ifa);\n\t\t\tif (laddr->ifa->localifa_flags & SCTP_BEING_DELETED) {\n\t\t\t\tSCTPDBG(SCTP_DEBUG_PCB1, \"Huh IFA being deleted\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (laddr->ifa->address.sa.sa_family == nam->sa_family) {\n\t\t\t\t/* possible, see if it matches */\n\t\t\t\tswitch (nam->sa_family) {\n#ifdef INET\n\t\t\t\tcase AF_INET:\n#if defined(__APPLE__)\n\t\t\t\t\tif (sin == NULL) {\n\t\t\t\t\t\t/* TSNH */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tif (sin->sin_addr.s_addr ==\n\t\t\t\t\t    laddr->ifa->address.sin.sin_addr.s_addr) {\n\t\t\t\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\t\t\t\treturn (inp);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n#endif\n#ifdef INET6\n\t\t\t\tcase AF_INET6:\n\t\t\t\t\tintf_addr6 = &laddr->ifa->address.sin6;\n\t\t\t\t\tif (SCTP6_ARE_ADDR_EQUAL(sin6,\n\t\t\t\t\t    intf_addr6)) {\n\t\t\t\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\t\t\t\treturn (inp);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n#endif\n#if defined(__Userspace__)\n\t\t\t\tcase AF_CONN:\n\t\t\t\t\tif (sconn->sconn_addr == laddr->ifa->address.sconn.sconn_addr) {\n\t\t\t\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\t\t\t\treturn (inp);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n#endif\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSCTP_INP_RUNLOCK(inp);\n\t}\n\treturn (NULL);\n}\n\n\nstatic struct sctp_inpcb *\nsctp_isport_inuse(struct sctp_inpcb *inp, uint16_t lport, uint32_t vrf_id)\n{\n\tstruct sctppcbhead *head;\n\tstruct sctp_inpcb *t_inp;\n#ifdef SCTP_MVRF\n\tint i;\n#endif\n\tint fnd;\n\n\thead = &SCTP_BASE_INFO(sctp_ephash)[SCTP_PCBHASH_ALLADDR(lport,\n\t    SCTP_BASE_INFO(hashmark))];\n\tLIST_FOREACH(t_inp, head, sctp_hash) {\n\t\tif (t_inp->sctp_lport != lport) {\n\t\t\tcontinue;\n\t\t}\n\t\t/* is it in the VRF in question */\n\t\tfnd = 0;\n#ifdef SCTP_MVRF\n\t\tfor (i = 0; i < inp->num_vrfs; i++) {\n\t\t\tif (t_inp->m_vrf_ids[i] == vrf_id) {\n\t\t\t\tfnd = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n#else\n\t\tif (t_inp->def_vrf_id == vrf_id)\n\t\t\tfnd = 1;\n#endif\n\t\tif (!fnd)\n\t\t\tcontinue;\n\n\t\t/* This one is in use. */\n\t\t/* check the v6/v4 binding issue */\n\t\tif ((t_inp->sctp_flags & SCTP_PCB_FLAGS_BOUND_V6) &&\n\t\t    SCTP_IPV6_V6ONLY(t_inp)) {\n\t\t\tif (inp->sctp_flags & SCTP_PCB_FLAGS_BOUND_V6) {\n\t\t\t\t/* collision in V6 space */\n\t\t\t\treturn (t_inp);\n\t\t\t} else {\n\t\t\t\t/* inp is BOUND_V4 no conflict */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else if (t_inp->sctp_flags & SCTP_PCB_FLAGS_BOUND_V6) {\n\t\t\t/* t_inp is bound v4 and v6, conflict always */\n\t\t\treturn (t_inp);\n\t\t} else {\n\t\t\t/* t_inp is bound only V4 */\n\t\t\tif ((inp->sctp_flags & SCTP_PCB_FLAGS_BOUND_V6) &&\n\t\t\t    SCTP_IPV6_V6ONLY(inp)) {\n\t\t\t\t/* no conflict */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* else fall through to conflict */\n\t\t}\n\t\treturn (t_inp);\n\t}\n\treturn (NULL);\n}\n\n\nint\nsctp_swap_inpcb_for_listen(struct sctp_inpcb *inp)\n{\n\t/* For 1-2-1 with port reuse */\n\tstruct sctppcbhead *head;\n\tstruct sctp_inpcb *tinp, *ninp;\n\n\tif (sctp_is_feature_off(inp, SCTP_PCB_FLAGS_PORTREUSE)) {\n\t\t/* only works with port reuse on */\n\t\treturn (-1);\n\t}\n\tif ((inp->sctp_flags & SCTP_PCB_FLAGS_IN_TCPPOOL) == 0) {\n\t\treturn (0);\n\t}\n\tSCTP_INP_RUNLOCK(inp);\n\tSCTP_INP_INFO_WLOCK();\n\thead = &SCTP_BASE_INFO(sctp_ephash)[SCTP_PCBHASH_ALLADDR(inp->sctp_lport,\n\t                                    SCTP_BASE_INFO(hashmark))];\n\t/* Kick out all non-listeners to the TCP hash */\n\tLIST_FOREACH_SAFE(tinp, head, sctp_hash, ninp) {\n\t\tif (tinp->sctp_lport != inp->sctp_lport) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (tinp->sctp_flags & SCTP_PCB_FLAGS_SOCKET_ALLGONE) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (tinp->sctp_flags & SCTP_PCB_FLAGS_SOCKET_GONE) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (SCTP_IS_LISTENING(tinp)) {\n\t\t\tcontinue;\n\t\t}\n\t\tSCTP_INP_WLOCK(tinp);\n\t\tLIST_REMOVE(tinp, sctp_hash);\n\t\thead = &SCTP_BASE_INFO(sctp_tcpephash)[SCTP_PCBHASH_ALLADDR(tinp->sctp_lport, SCTP_BASE_INFO(hashtcpmark))];\n\t\ttinp->sctp_flags |= SCTP_PCB_FLAGS_IN_TCPPOOL;\n\t\tLIST_INSERT_HEAD(head, tinp, sctp_hash);\n\t\tSCTP_INP_WUNLOCK(tinp);\n\t}\n\tSCTP_INP_WLOCK(inp);\n\t/* Pull from where he was */\n\tLIST_REMOVE(inp, sctp_hash);\n\tinp->sctp_flags &= ~SCTP_PCB_FLAGS_IN_TCPPOOL;\n\thead = &SCTP_BASE_INFO(sctp_ephash)[SCTP_PCBHASH_ALLADDR(inp->sctp_lport, SCTP_BASE_INFO(hashmark))];\n\tLIST_INSERT_HEAD(head, inp, sctp_hash);\n\tSCTP_INP_WUNLOCK(inp);\n\tSCTP_INP_RLOCK(inp);\n\tSCTP_INP_INFO_WUNLOCK();\n\treturn (0);\n}\n\n\nstruct sctp_inpcb *\nsctp_pcb_findep(struct sockaddr *nam, int find_tcp_pool, int have_lock,\n\t\tuint32_t vrf_id)\n{\n\t/*\n\t * First we check the hash table to see if someone has this port\n\t * bound with just the port.\n\t */\n\tstruct sctp_inpcb *inp;\n\tstruct sctppcbhead *head;\n\tint lport;\n\tunsigned int i;\n#ifdef INET\n\tstruct sockaddr_in *sin;\n#endif\n#ifdef INET6\n\tstruct sockaddr_in6 *sin6;\n#endif\n#if defined(__Userspace__)\n\tstruct sockaddr_conn *sconn;\n#endif\n\n\tswitch (nam->sa_family) {\n#ifdef INET\n\tcase AF_INET:\n\t\tsin = (struct sockaddr_in *)nam;\n\t\tlport = sin->sin_port;\n\t\tbreak;\n#endif\n#ifdef INET6\n\tcase AF_INET6:\n\t\tsin6 = (struct sockaddr_in6 *)nam;\n\t\tlport = sin6->sin6_port;\n\t\tbreak;\n#endif\n#if defined(__Userspace__)\n\tcase AF_CONN:\n\t\tsconn = (struct sockaddr_conn *)nam;\n\t\tlport = sconn->sconn_port;\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn (NULL);\n\t}\n\t/*\n\t * I could cheat here and just cast to one of the types but we will\n\t * do it right. It also provides the check against an Unsupported\n\t * type too.\n\t */\n\t/* Find the head of the ALLADDR chain */\n\tif (have_lock == 0) {\n\t\tSCTP_INP_INFO_RLOCK();\n\t}\n\thead = &SCTP_BASE_INFO(sctp_ephash)[SCTP_PCBHASH_ALLADDR(lport,\n\t    SCTP_BASE_INFO(hashmark))];\n\tinp = sctp_endpoint_probe(nam, head, lport, vrf_id);\n\n\t/*\n\t * If the TCP model exists it could be that the main listening\n\t * endpoint is gone but there still exists a connected socket for this\n\t * guy. If so we can return the first one that we find. This may NOT\n\t * be the correct one so the caller should be wary on the returned INP.\n\t * Currently the only caller that sets find_tcp_pool is in bindx where\n\t * we are verifying that a user CAN bind the address. He either\n\t * has bound it already, or someone else has, or its open to bind,\n\t * so this is good enough.\n\t */\n\tif (inp == NULL && find_tcp_pool) {\n\t\tfor (i = 0; i < SCTP_BASE_INFO(hashtcpmark) + 1; i++) {\n\t\t\thead = &SCTP_BASE_INFO(sctp_tcpephash)[i];\n\t\t\tinp = sctp_endpoint_probe(nam, head, lport, vrf_id);\n\t\t\tif (inp) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (inp) {\n\t\tSCTP_INP_INCR_REF(inp);\n\t}\n\tif (have_lock == 0) {\n\t\tSCTP_INP_INFO_RUNLOCK();\n\t}\n\treturn (inp);\n}\n\n\n/*\n * Find an association for an endpoint with the pointer to whom you want to\n * send to and the endpoint pointer. The address can be IPv4 or IPv6. We may\n * need to change the *to to some other struct like a mbuf...\n */\nstruct sctp_tcb *\nsctp_findassociation_addr_sa(struct sockaddr *from, struct sockaddr *to,\n    struct sctp_inpcb **inp_p, struct sctp_nets **netp, int find_tcp_pool,\n    uint32_t vrf_id)\n{\n\tstruct sctp_inpcb *inp = NULL;\n\tstruct sctp_tcb *stcb;\n\n\tSCTP_INP_INFO_RLOCK();\n\tif (find_tcp_pool) {\n\t\tif (inp_p != NULL) {\n\t\t\tstcb = sctp_tcb_special_locate(inp_p, from, to, netp,\n\t\t\t                               vrf_id);\n\t\t} else {\n\t\t\tstcb = sctp_tcb_special_locate(&inp, from, to, netp,\n\t\t\t                               vrf_id);\n\t\t}\n\t\tif (stcb != NULL) {\n\t\t\tSCTP_INP_INFO_RUNLOCK();\n\t\t\treturn (stcb);\n\t\t}\n\t}\n\tinp = sctp_pcb_findep(to, 0, 1, vrf_id);\n\tif (inp_p != NULL) {\n\t\t*inp_p = inp;\n\t}\n\tSCTP_INP_INFO_RUNLOCK();\n\tif (inp == NULL) {\n\t\treturn (NULL);\n\t}\n\t/*\n\t * ok, we have an endpoint, now lets find the assoc for it (if any)\n\t * we now place the source address or from in the to of the find\n\t * endpoint call. Since in reality this chain is used from the\n\t * inbound packet side.\n\t */\n\tif (inp_p != NULL) {\n\t\tstcb = sctp_findassociation_ep_addr(inp_p, from, netp, to,\n\t\t                                    NULL);\n\t} else {\n\t\tstcb = sctp_findassociation_ep_addr(&inp, from, netp, to,\n\t\t                                    NULL);\n\t}\n\treturn (stcb);\n}\n\n\n/*\n * This routine will grub through the mbuf that is a INIT or INIT-ACK and\n * find all addresses that the sender has specified in any address list. Each\n * address will be used to lookup the TCB and see if one exits.\n */\nstatic struct sctp_tcb *\nsctp_findassociation_special_addr(struct mbuf *m, int offset,\n    struct sctphdr *sh, struct sctp_inpcb **inp_p, struct sctp_nets **netp,\n    struct sockaddr *dst)\n{\n\tstruct sctp_paramhdr *phdr, param_buf;\n#if defined(INET) || defined(INET6)\n\tstruct sctp_tcb *stcb;\n\tuint16_t ptype;\n#endif\n\tuint16_t plen;\n#ifdef INET\n\tstruct sockaddr_in sin4;\n#endif\n#ifdef INET6\n\tstruct sockaddr_in6 sin6;\n#endif\n\n#ifdef INET\n\tmemset(&sin4, 0, sizeof(sin4));\n#ifdef HAVE_SIN_LEN\n\tsin4.sin_len = sizeof(sin4);\n#endif\n\tsin4.sin_family = AF_INET;\n\tsin4.sin_port = sh->src_port;\n#endif\n#ifdef INET6\n\tmemset(&sin6, 0, sizeof(sin6));\n#ifdef HAVE_SIN6_LEN\n\tsin6.sin6_len = sizeof(sin6);\n#endif\n\tsin6.sin6_family = AF_INET6;\n\tsin6.sin6_port = sh->src_port;\n#endif\n\n\toffset += sizeof(struct sctp_init_chunk);\n\n\tphdr = sctp_get_next_param(m, offset, &param_buf, sizeof(param_buf));\n\twhile (phdr != NULL) {\n\t\t/* now we must see if we want the parameter */\n#if defined(INET) || defined(INET6)\n\t\tptype = ntohs(phdr->param_type);\n#endif\n\t\tplen = ntohs(phdr->param_length);\n\t\tif (plen == 0) {\n\t\t\tbreak;\n\t\t}\n#ifdef INET\n\t\tif (ptype == SCTP_IPV4_ADDRESS &&\n\t\t    plen == sizeof(struct sctp_ipv4addr_param)) {\n\t\t\t/* Get the rest of the address */\n\t\t\tstruct sctp_ipv4addr_param ip4_param, *p4;\n\n\t\t\tphdr = sctp_get_next_param(m, offset,\n\t\t\t    (struct sctp_paramhdr *)&ip4_param, sizeof(ip4_param));\n\t\t\tif (phdr == NULL) {\n\t\t\t\treturn (NULL);\n\t\t\t}\n\t\t\tp4 = (struct sctp_ipv4addr_param *)phdr;\n\t\t\tmemcpy(&sin4.sin_addr, &p4->addr, sizeof(p4->addr));\n\t\t\t/* look it up */\n\t\t\tstcb = sctp_findassociation_ep_addr(inp_p,\n\t\t\t    (struct sockaddr *)&sin4, netp, dst, NULL);\n\t\t\tif (stcb != NULL) {\n\t\t\t\treturn (stcb);\n\t\t\t}\n\t\t}\n#endif\n#ifdef INET6\n\t\tif (ptype == SCTP_IPV6_ADDRESS &&\n\t\t    plen == sizeof(struct sctp_ipv6addr_param)) {\n\t\t\t/* Get the rest of the address */\n\t\t\tstruct sctp_ipv6addr_param ip6_param, *p6;\n\n\t\t\tphdr = sctp_get_next_param(m, offset,\n\t\t\t    (struct sctp_paramhdr *)&ip6_param, sizeof(ip6_param));\n\t\t\tif (phdr == NULL) {\n\t\t\t\treturn (NULL);\n\t\t\t}\n\t\t\tp6 = (struct sctp_ipv6addr_param *)phdr;\n\t\t\tmemcpy(&sin6.sin6_addr, &p6->addr, sizeof(p6->addr));\n\t\t\t/* look it up */\n\t\t\tstcb = sctp_findassociation_ep_addr(inp_p,\n\t\t\t    (struct sockaddr *)&sin6, netp, dst, NULL);\n\t\t\tif (stcb != NULL) {\n\t\t\t\treturn (stcb);\n\t\t\t}\n\t\t}\n#endif\n\t\toffset += SCTP_SIZE32(plen);\n\t\tphdr = sctp_get_next_param(m, offset, &param_buf,\n\t\t\t\t\t   sizeof(param_buf));\n\t}\n\treturn (NULL);\n}\n\nstatic struct sctp_tcb *\nsctp_findassoc_by_vtag(struct sockaddr *from, struct sockaddr *to, uint32_t vtag,\n\t\t       struct sctp_inpcb **inp_p, struct sctp_nets **netp, uint16_t rport,\n\t\t       uint16_t lport, int skip_src_check, uint32_t vrf_id, uint32_t remote_tag)\n{\n\t/*\n\t * Use my vtag to hash. If we find it we then verify the source addr\n\t * is in the assoc. If all goes well we save a bit on rec of a\n\t * packet.\n\t */\n\tstruct sctpasochead *head;\n\tstruct sctp_nets *net;\n\tstruct sctp_tcb *stcb;\n#ifdef SCTP_MVRF\n\tunsigned int i;\n#endif\n\n\tSCTP_INP_INFO_RLOCK();\n\thead = &SCTP_BASE_INFO(sctp_asochash)[SCTP_PCBHASH_ASOC(vtag,\n\t                                                        SCTP_BASE_INFO(hashasocmark))];\n\tLIST_FOREACH(stcb, head, sctp_asocs) {\n\t\tSCTP_INP_RLOCK(stcb->sctp_ep);\n\t\tif (stcb->sctp_ep->sctp_flags & SCTP_PCB_FLAGS_SOCKET_ALLGONE) {\n\t\t\tSCTP_INP_RUNLOCK(stcb->sctp_ep);\n\t\t\tcontinue;\n\t\t}\n#ifdef SCTP_MVRF\n\t\tfor (i = 0; i < stcb->sctp_ep->num_vrfs; i++) {\n\t\t\tif (stcb->sctp_ep->m_vrf_ids[i] == vrf_id) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == stcb->sctp_ep->num_vrfs) {\n\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\tcontinue;\n\t\t}\n#else\n\t\tif (stcb->sctp_ep->def_vrf_id != vrf_id) {\n\t\t\tSCTP_INP_RUNLOCK(stcb->sctp_ep);\n\t\t\tcontinue;\n\t\t}\n#endif\n\t\tSCTP_TCB_LOCK(stcb);\n\t\tSCTP_INP_RUNLOCK(stcb->sctp_ep);\n\t\tif (stcb->asoc.my_vtag == vtag) {\n\t\t\t/* candidate */\n\t\t\tif (stcb->rport != rport) {\n\t\t\t\tSCTP_TCB_UNLOCK(stcb);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (stcb->sctp_ep->sctp_lport != lport) {\n\t\t\t\tSCTP_TCB_UNLOCK(stcb);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (stcb->asoc.state & SCTP_STATE_ABOUT_TO_BE_FREED) {\n\t\t\t\tSCTP_TCB_UNLOCK(stcb);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* RRS:Need toaddr check here */\n\t\t\tif (sctp_does_stcb_own_this_addr(stcb, to) == 0) {\n\t\t\t        /* Endpoint does not own this address */\n\t\t\t\tSCTP_TCB_UNLOCK(stcb);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (remote_tag) {\n\t\t\t\t/* If we have both vtags that's all we match on */\n\t\t\t\tif (stcb->asoc.peer_vtag == remote_tag) {\n\t\t\t\t\t/* If both tags match we consider it conclusive\n\t\t\t\t\t * and check NO source/destination addresses\n\t\t\t\t\t */\n\t\t\t\t\tgoto conclusive;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (skip_src_check) {\n\t\t\tconclusive:\n\t\t\t        if (from) {\n\t\t\t\t\t*netp = sctp_findnet(stcb, from);\n\t\t\t\t} else {\n\t\t\t\t\t*netp = NULL;\t/* unknown */\n\t\t\t\t}\n\t\t\t\tif (inp_p)\n\t\t\t\t\t*inp_p = stcb->sctp_ep;\n\t\t\t\tSCTP_INP_INFO_RUNLOCK();\n\t\t\t\treturn (stcb);\n\t\t\t}\n\t\t\tnet = sctp_findnet(stcb, from);\n\t\t\tif (net) {\n\t\t\t\t/* yep its him. */\n\t\t\t\t*netp = net;\n\t\t\t\tSCTP_STAT_INCR(sctps_vtagexpress);\n\t\t\t\t*inp_p = stcb->sctp_ep;\n\t\t\t\tSCTP_INP_INFO_RUNLOCK();\n\t\t\t\treturn (stcb);\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * not him, this should only happen in rare\n\t\t\t\t * cases so I peg it.\n\t\t\t\t */\n\t\t\t\tSCTP_STAT_INCR(sctps_vtagbogus);\n\t\t\t}\n\t\t}\n\t\tSCTP_TCB_UNLOCK(stcb);\n\t}\n\tSCTP_INP_INFO_RUNLOCK();\n\treturn (NULL);\n}\n\n\n/*\n * Find an association with the pointer to the inbound IP packet. This can be\n * a IPv4 or IPv6 packet.\n */\nstruct sctp_tcb *\nsctp_findassociation_addr(struct mbuf *m, int offset,\n    struct sockaddr *src, struct sockaddr *dst,\n    struct sctphdr *sh, struct sctp_chunkhdr *ch,\n    struct sctp_inpcb **inp_p, struct sctp_nets **netp, uint32_t vrf_id)\n{\n\tstruct sctp_tcb *stcb;\n\tstruct sctp_inpcb *inp;\n\n\tif (sh->v_tag) {\n\t\t/* we only go down this path if vtag is non-zero */\n\t\tstcb = sctp_findassoc_by_vtag(src, dst, ntohl(sh->v_tag),\n\t\t                              inp_p, netp, sh->src_port, sh->dest_port, 0, vrf_id, 0);\n\t\tif (stcb) {\n\t\t\treturn (stcb);\n\t\t}\n\t}\n\n\tif (inp_p) {\n\t\tstcb = sctp_findassociation_addr_sa(src, dst, inp_p, netp,\n\t\t                                    1, vrf_id);\n\t\tinp = *inp_p;\n\t} else {\n\t\tstcb = sctp_findassociation_addr_sa(src, dst, &inp, netp,\n\t\t                                    1, vrf_id);\n\t}\n\tSCTPDBG(SCTP_DEBUG_PCB1, \"stcb:%p inp:%p\\n\", (void *)stcb, (void *)inp);\n\tif (stcb == NULL && inp) {\n\t\t/* Found a EP but not this address */\n\t\tif ((ch->chunk_type == SCTP_INITIATION) ||\n\t\t    (ch->chunk_type == SCTP_INITIATION_ACK)) {\n\t\t\t/*-\n\t\t\t * special hook, we do NOT return linp or an\n\t\t\t * association that is linked to an existing\n\t\t\t * association that is under the TCP pool (i.e. no\n\t\t\t * listener exists). The endpoint finding routine\n\t\t\t * will always find a listener before examining the\n\t\t\t * TCP pool.\n\t\t\t */\n\t\t\tif (inp->sctp_flags & SCTP_PCB_FLAGS_IN_TCPPOOL) {\n\t\t\t\tif (inp_p) {\n\t\t\t\t\t*inp_p = NULL;\n\t\t\t\t}\n\t\t\t\treturn (NULL);\n\t\t\t}\n\t\t\tstcb = sctp_findassociation_special_addr(m,\n\t\t\t    offset, sh, &inp, netp, dst);\n\t\t\tif (inp_p != NULL) {\n\t\t\t\t*inp_p = inp;\n\t\t\t}\n\t\t}\n\t}\n\tSCTPDBG(SCTP_DEBUG_PCB1, \"stcb is %p\\n\", (void *)stcb);\n\treturn (stcb);\n}\n\n/*\n * lookup an association by an ASCONF lookup address.\n * if the lookup address is 0.0.0.0 or ::0, use the vtag to do the lookup\n */\nstruct sctp_tcb *\nsctp_findassociation_ep_asconf(struct mbuf *m, int offset,\n\t\t\t       struct sockaddr *dst, struct sctphdr *sh,\n                               struct sctp_inpcb **inp_p, struct sctp_nets **netp, uint32_t vrf_id)\n{\n\tstruct sctp_tcb *stcb;\n\tunion sctp_sockstore remote_store;\n\tstruct sctp_paramhdr param_buf, *phdr;\n\tint ptype;\n\tint zero_address = 0;\n#ifdef INET\n\tstruct sockaddr_in *sin;\n#endif\n#ifdef INET6\n\tstruct sockaddr_in6 *sin6;\n#endif\n\n\tmemset(&remote_store, 0, sizeof(remote_store));\n\tphdr = sctp_get_next_param(m, offset + sizeof(struct sctp_asconf_chunk),\n\t\t\t\t   &param_buf, sizeof(struct sctp_paramhdr));\n\tif (phdr == NULL) {\n\t\tSCTPDBG(SCTP_DEBUG_INPUT3, \"%s: failed to get asconf lookup addr\\n\",\n\t\t\t__func__);\n\t\treturn NULL;\n\t}\n\tptype = (int)((uint32_t) ntohs(phdr->param_type));\n\t/* get the correlation address */\n\tswitch (ptype) {\n#ifdef INET6\n\tcase SCTP_IPV6_ADDRESS:\n\t{\n\t\t/* ipv6 address param */\n\t\tstruct sctp_ipv6addr_param *p6, p6_buf;\n\n\t\tif (ntohs(phdr->param_length) != sizeof(struct sctp_ipv6addr_param)) {\n\t\t\treturn NULL;\n\t\t}\n\t\tp6 = (struct sctp_ipv6addr_param *)sctp_get_next_param(m,\n\t\t\t\t\t\t\t\t       offset + sizeof(struct sctp_asconf_chunk),\n\t\t\t\t\t\t\t\t       &p6_buf.ph, sizeof(p6_buf));\n\t\tif (p6 == NULL) {\n\t\t\tSCTPDBG(SCTP_DEBUG_INPUT3, \"%s: failed to get asconf v6 lookup addr\\n\",\n\t\t\t\t__func__);\n\t\t\treturn (NULL);\n\t\t}\n\t\tsin6 = &remote_store.sin6;\n\t\tsin6->sin6_family = AF_INET6;\n#ifdef HAVE_SIN6_LEN\n\t\tsin6->sin6_len = sizeof(*sin6);\n#endif\n\t\tsin6->sin6_port = sh->src_port;\n\t\tmemcpy(&sin6->sin6_addr, &p6->addr, sizeof(struct in6_addr));\n\t\tif (IN6_IS_ADDR_UNSPECIFIED(&sin6->sin6_addr))\n\t\t\tzero_address = 1;\n\t\tbreak;\n\t}\n#endif\n#ifdef INET\n\tcase SCTP_IPV4_ADDRESS:\n\t{\n\t\t/* ipv4 address param */\n\t\tstruct sctp_ipv4addr_param *p4, p4_buf;\n\n\t\tif (ntohs(phdr->param_length) != sizeof(struct sctp_ipv4addr_param)) {\n\t\t\treturn NULL;\n\t\t}\n\t\tp4 = (struct sctp_ipv4addr_param *)sctp_get_next_param(m,\n\t\t\t\t\t\t\t\t       offset + sizeof(struct sctp_asconf_chunk),\n\t\t\t\t\t\t\t\t       &p4_buf.ph, sizeof(p4_buf));\n\t\tif (p4 == NULL) {\n\t\t\tSCTPDBG(SCTP_DEBUG_INPUT3, \"%s: failed to get asconf v4 lookup addr\\n\",\n\t\t\t\t__func__);\n\t\t\treturn (NULL);\n\t\t}\n\t\tsin = &remote_store.sin;\n\t\tsin->sin_family = AF_INET;\n#ifdef HAVE_SIN_LEN\n\t\tsin->sin_len = sizeof(*sin);\n#endif\n\t\tsin->sin_port = sh->src_port;\n\t\tmemcpy(&sin->sin_addr, &p4->addr, sizeof(struct in_addr));\n\t\tif (sin->sin_addr.s_addr == INADDR_ANY)\n\t\t\tzero_address = 1;\n\t\tbreak;\n\t}\n#endif\n\tdefault:\n\t\t/* invalid address param type */\n\t\treturn NULL;\n\t}\n\n\tif (zero_address) {\n\t        stcb = sctp_findassoc_by_vtag(NULL, dst, ntohl(sh->v_tag), inp_p,\n\t\t\t\t\t      netp, sh->src_port, sh->dest_port, 1, vrf_id, 0);\n\t\tif (stcb != NULL) {\n\t\t\tSCTP_INP_DECR_REF(*inp_p);\n\t\t}\n\t} else {\n\t\tstcb = sctp_findassociation_ep_addr(inp_p,\n\t\t    &remote_store.sa, netp,\n\t\t    dst, NULL);\n\t}\n\treturn (stcb);\n}\n\n\n/*\n * allocate a sctp_inpcb and setup a temporary binding to a port/all\n * addresses. This way if we don't get a bind we by default pick a ephemeral\n * port with all addresses bound.\n */\nint\nsctp_inpcb_alloc(struct socket *so, uint32_t vrf_id)\n{\n\t/*\n\t * we get called when a new endpoint starts up. We need to allocate\n\t * the sctp_inpcb structure from the zone and init it. Mark it as\n\t * unbound and find a port that we can use as an ephemeral with\n\t * INADDR_ANY. If the user binds later no problem we can then add in\n\t * the specific addresses. And setup the default parameters for the\n\t * EP.\n\t */\n\tint i, error;\n\tstruct sctp_inpcb *inp;\n\tstruct sctp_pcb *m;\n\tstruct timeval time;\n\tsctp_sharedkey_t *null_key;\n\n\terror = 0;\n\n\tSCTP_INP_INFO_WLOCK();\n\tinp = SCTP_ZONE_GET(SCTP_BASE_INFO(ipi_zone_ep), struct sctp_inpcb);\n\tif (inp == NULL) {\n\t\tSCTP_PRINTF(\"Out of SCTP-INPCB structures - no resources\\n\");\n\t\tSCTP_INP_INFO_WUNLOCK();\n\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, ENOBUFS);\n\t\treturn (ENOBUFS);\n\t}\n\t/* zap it */\n\tmemset(inp, 0, sizeof(*inp));\n\n\t/* bump generations */\n#if defined(__APPLE__)\n\tinp->ip_inp.inp.inp_state = INPCB_STATE_INUSE;\n#endif\n\t/* setup socket pointers */\n\tinp->sctp_socket = so;\n\tinp->ip_inp.inp.inp_socket = so;\n#if defined(__FreeBSD__)\n\tinp->ip_inp.inp.inp_cred = crhold(so->so_cred);\n#endif\n#ifdef INET6\n#if !defined(__Userspace__) && !defined(__Windows__)\n\tif (INP_SOCKAF(so) == AF_INET6) {\n\t\tif (MODULE_GLOBAL(ip6_auto_flowlabel)) {\n\t\t\tinp->ip_inp.inp.inp_flags |= IN6P_AUTOFLOWLABEL;\n\t\t}\n\t\tif (MODULE_GLOBAL(ip6_v6only)) {\n\t\t\tinp->ip_inp.inp.inp_flags |= IN6P_IPV6_V6ONLY;\n\t\t}\n\t}\n#endif\n#endif\n\tinp->sctp_associd_counter = 1;\n\tinp->partial_delivery_point = SCTP_SB_LIMIT_RCV(so) >> SCTP_PARTIAL_DELIVERY_SHIFT;\n\tinp->sctp_frag_point = SCTP_DEFAULT_MAXSEGMENT;\n\tinp->max_cwnd = 0;\n\tinp->sctp_cmt_on_off = SCTP_BASE_SYSCTL(sctp_cmt_on_off);\n\tinp->ecn_supported = (uint8_t)SCTP_BASE_SYSCTL(sctp_ecn_enable);\n\tinp->prsctp_supported = (uint8_t)SCTP_BASE_SYSCTL(sctp_pr_enable);\n\tinp->auth_supported = (uint8_t)SCTP_BASE_SYSCTL(sctp_auth_enable);\n\tinp->asconf_supported = (uint8_t)SCTP_BASE_SYSCTL(sctp_asconf_enable);\n\tinp->reconfig_supported = (uint8_t)SCTP_BASE_SYSCTL(sctp_reconfig_enable);\n\tinp->nrsack_supported = (uint8_t)SCTP_BASE_SYSCTL(sctp_nrsack_enable);\n\tinp->pktdrop_supported = (uint8_t)SCTP_BASE_SYSCTL(sctp_pktdrop_enable);\n\tinp->idata_supported = 0;\n\n#if defined(__FreeBSD__)\n\tinp->fibnum = so->so_fibnum;\n#else\n\tinp->fibnum = 0;\n#endif\n#if defined(__Userspace__)\n\tinp->ulp_info = NULL;\n\tinp->recv_callback = NULL;\n\tinp->send_callback = NULL;\n\tinp->send_sb_threshold = 0;\n#endif\n\t/* init the small hash table we use to track asocid <-> tcb */\n\tinp->sctp_asocidhash = SCTP_HASH_INIT(SCTP_STACK_VTAG_HASH_SIZE, &inp->hashasocidmark);\n\tif (inp->sctp_asocidhash == NULL) {\n#if defined(__FreeBSD__)\n\t\tcrfree(inp->ip_inp.inp.inp_cred);\n#endif\n\t\tSCTP_ZONE_FREE(SCTP_BASE_INFO(ipi_zone_ep), inp);\n\t\tSCTP_INP_INFO_WUNLOCK();\n\t\treturn (ENOBUFS);\n\t}\n\tSCTP_INCR_EP_COUNT();\n\tinp->ip_inp.inp.inp_ip_ttl = MODULE_GLOBAL(ip_defttl);\n\tSCTP_INP_INFO_WUNLOCK();\n\n\tso->so_pcb = (caddr_t)inp;\n\n#if defined(__FreeBSD__) && __FreeBSD_version < 803000\n\tif ((SCTP_SO_TYPE(so) == SOCK_DGRAM) ||\n\t    (SCTP_SO_TYPE(so) == SOCK_SEQPACKET)) {\n#else\n\tif (SCTP_SO_TYPE(so) == SOCK_SEQPACKET) {\n#endif\n\t\t/* UDP style socket */\n\t\tinp->sctp_flags = (SCTP_PCB_FLAGS_UDPTYPE |\n\t\t    SCTP_PCB_FLAGS_UNBOUND);\n\t\t/* Be sure it is NON-BLOCKING IO for UDP */\n\t\t/* SCTP_SET_SO_NBIO(so); */\n\t} else if (SCTP_SO_TYPE(so) == SOCK_STREAM) {\n\t\t/* TCP style socket */\n\t\tinp->sctp_flags = (SCTP_PCB_FLAGS_TCPTYPE |\n\t\t    SCTP_PCB_FLAGS_UNBOUND);\n\t\t/* Be sure we have blocking IO by default */\n\t\tSOCK_LOCK(so);\n\t\tSCTP_CLEAR_SO_NBIO(so);\n\t\tSOCK_UNLOCK(so);\n#if defined(__Panda__)\n\t} else if (SCTP_SO_TYPE(so) == SOCK_FASTSEQPACKET) {\n\t\tinp->sctp_flags = (SCTP_PCB_FLAGS_UDPTYPE |\n\t\t    SCTP_PCB_FLAGS_UNBOUND);\n\t} else if (SCTP_SO_TYPE(so) == SOCK_FASTSTREAM) {\n\t\tinp->sctp_flags = (SCTP_PCB_FLAGS_TCPTYPE |\n\t\t    SCTP_PCB_FLAGS_UNBOUND);\n#endif\n\t} else {\n\t\t/*\n\t\t * unsupported socket type (RAW, etc)- in case we missed it\n\t\t * in protosw\n\t\t */\n\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, EOPNOTSUPP);\n\t\tso->so_pcb = NULL;\n#if defined(__FreeBSD__)\n\t\tcrfree(inp->ip_inp.inp.inp_cred);\n#endif\n\t\tSCTP_ZONE_FREE(SCTP_BASE_INFO(ipi_zone_ep), inp);\n\t\treturn (EOPNOTSUPP);\n\t}\n\tif (SCTP_BASE_SYSCTL(sctp_default_frag_interleave) == SCTP_FRAG_LEVEL_1) {\n\t\tsctp_feature_on(inp, SCTP_PCB_FLAGS_FRAG_INTERLEAVE);\n\t\tsctp_feature_off(inp, SCTP_PCB_FLAGS_INTERLEAVE_STRMS);\n\t} else if (SCTP_BASE_SYSCTL(sctp_default_frag_interleave) == SCTP_FRAG_LEVEL_2) {\n\t\tsctp_feature_on(inp, SCTP_PCB_FLAGS_FRAG_INTERLEAVE);\n\t\tsctp_feature_on(inp, SCTP_PCB_FLAGS_INTERLEAVE_STRMS);\n\t} else if (SCTP_BASE_SYSCTL(sctp_default_frag_interleave) == SCTP_FRAG_LEVEL_0) {\n\t\tsctp_feature_off(inp, SCTP_PCB_FLAGS_FRAG_INTERLEAVE);\n\t\tsctp_feature_off(inp, SCTP_PCB_FLAGS_INTERLEAVE_STRMS);\n\t}\n\tinp->sctp_tcbhash = SCTP_HASH_INIT(SCTP_BASE_SYSCTL(sctp_pcbtblsize),\n\t\t\t\t\t   &inp->sctp_hashmark);\n\tif (inp->sctp_tcbhash == NULL) {\n\t\tSCTP_PRINTF(\"Out of SCTP-INPCB->hashinit - no resources\\n\");\n\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, ENOBUFS);\n\t\tso->so_pcb = NULL;\n#if defined(__FreeBSD__)\n\t\tcrfree(inp->ip_inp.inp.inp_cred);\n#endif\n\t\tSCTP_ZONE_FREE(SCTP_BASE_INFO(ipi_zone_ep), inp);\n\t\treturn (ENOBUFS);\n\t}\n#ifdef SCTP_MVRF\n\tinp->vrf_size = SCTP_DEFAULT_VRF_SIZE;\n\tSCTP_MALLOC(inp->m_vrf_ids, uint32_t *,\n\t\t    (sizeof(uint32_t) * inp->vrf_size), SCTP_M_MVRF);\n\tif (inp->m_vrf_ids == NULL) {\n\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, ENOBUFS);\n\t\tso->so_pcb = NULL;\n\t\tSCTP_HASH_FREE(inp->sctp_tcbhash, inp->sctp_hashmark);\n#if defined(__FreeBSD__)\n\t\tcrfree(inp->ip_inp.inp.inp_cred);\n#endif\n\t\tSCTP_ZONE_FREE(SCTP_BASE_INFO(ipi_zone_ep), inp);\n\t\treturn (ENOBUFS);\n\t}\n\tinp->m_vrf_ids[0] = vrf_id;\n\tinp->num_vrfs = 1;\n#endif\n\tinp->def_vrf_id = vrf_id;\n\n#if defined(__APPLE__)\n#if defined(APPLE_LEOPARD) || defined(APPLE_SNOWLEOPARD)\n\tinp->ip_inp.inp.inpcb_mtx = lck_mtx_alloc_init(SCTP_BASE_INFO(sctbinfo).mtx_grp, SCTP_BASE_INFO(sctbinfo).mtx_attr);\n\tif (inp->ip_inp.inp.inpcb_mtx == NULL) {\n\t\tSCTP_PRINTF(\"in_pcballoc: can't alloc mutex! so=%p\\n\", (void *)so);\n#ifdef SCTP_MVRF\n\t\tSCTP_FREE(inp->m_vrf_ids, SCTP_M_MVRF);\n#endif\n\t\tSCTP_HASH_FREE(inp->sctp_tcbhash, inp->sctp_hashmark);\n\t\tso->so_pcb = NULL;\n\t\tSCTP_ZONE_FREE(SCTP_BASE_INFO(ipi_zone_ep), inp);\n\t\tSCTP_UNLOCK_EXC(SCTP_BASE_INFO(sctbinfo).ipi_lock);\n\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, ENOMEM);\n\t\treturn (ENOMEM);\n\t}\n#elif defined(APPLE_LION) || defined(APPLE_MOUNTAINLION)\n\tlck_mtx_init(&inp->ip_inp.inp.inpcb_mtx, SCTP_BASE_INFO(sctbinfo).mtx_grp, SCTP_BASE_INFO(sctbinfo).mtx_attr);\n#else\n\tlck_mtx_init(&inp->ip_inp.inp.inpcb_mtx, SCTP_BASE_INFO(sctbinfo).ipi_lock_grp, SCTP_BASE_INFO(sctbinfo).ipi_lock_attr);\n#endif\n#endif\n\tSCTP_INP_INFO_WLOCK();\n\tSCTP_INP_LOCK_INIT(inp);\n#if defined(__FreeBSD__)\n\tINP_LOCK_INIT(&inp->ip_inp.inp, \"inp\", \"sctpinp\");\n#endif\n\tSCTP_INP_READ_INIT(inp);\n\tSCTP_ASOC_CREATE_LOCK_INIT(inp);\n\t/* lock the new ep */\n\tSCTP_INP_WLOCK(inp);\n\n\t/* add it to the info area */\n\tLIST_INSERT_HEAD(&SCTP_BASE_INFO(listhead), inp, sctp_list);\n#if defined(__APPLE__)\n\tinp->ip_inp.inp.inp_pcbinfo = &SCTP_BASE_INFO(sctbinfo);\n#if defined(APPLE_LEOPARD) || defined(APPLE_SNOWLEOPARD) || defined(APPLE_LION) || defined(APPLE_MOUNTAINLION)\n\tLIST_INSERT_HEAD(SCTP_BASE_INFO(sctbinfo).listhead, &inp->ip_inp.inp, inp_list);\n#else\n\tLIST_INSERT_HEAD(SCTP_BASE_INFO(sctbinfo).ipi_listhead, &inp->ip_inp.inp, inp_list);\n#endif\n#endif\n\tSCTP_INP_INFO_WUNLOCK();\n\n\tTAILQ_INIT(&inp->read_queue);\n\tLIST_INIT(&inp->sctp_addr_list);\n\n\tLIST_INIT(&inp->sctp_asoc_list);\n\n#ifdef SCTP_TRACK_FREED_ASOCS\n\t/* TEMP CODE */\n\tLIST_INIT(&inp->sctp_asoc_free_list);\n#endif\n\t/* Init the timer structure for signature change */\n\tSCTP_OS_TIMER_INIT(&inp->sctp_ep.signature_change.timer);\n\tinp->sctp_ep.signature_change.type = SCTP_TIMER_TYPE_NEWCOOKIE;\n\n\t/* now init the actual endpoint default data */\n\tm = &inp->sctp_ep;\n\n\t/* setup the base timeout information */\n\tm->sctp_timeoutticks[SCTP_TIMER_SEND] = SEC_TO_TICKS(SCTP_SEND_SEC);\t/* needed ? */\n\tm->sctp_timeoutticks[SCTP_TIMER_INIT] = SEC_TO_TICKS(SCTP_INIT_SEC);\t/* needed ? */\n\tm->sctp_timeoutticks[SCTP_TIMER_RECV] = MSEC_TO_TICKS(SCTP_BASE_SYSCTL(sctp_delayed_sack_time_default));\n\tm->sctp_timeoutticks[SCTP_TIMER_HEARTBEAT] = MSEC_TO_TICKS(SCTP_BASE_SYSCTL(sctp_heartbeat_interval_default));\n\tm->sctp_timeoutticks[SCTP_TIMER_PMTU] = SEC_TO_TICKS(SCTP_BASE_SYSCTL(sctp_pmtu_raise_time_default));\n\tm->sctp_timeoutticks[SCTP_TIMER_MAXSHUTDOWN] = SEC_TO_TICKS(SCTP_BASE_SYSCTL(sctp_shutdown_guard_time_default));\n\tm->sctp_timeoutticks[SCTP_TIMER_SIGNATURE] = SEC_TO_TICKS(SCTP_BASE_SYSCTL(sctp_secret_lifetime_default));\n\t/* all max/min max are in ms */\n\tm->sctp_maxrto = SCTP_BASE_SYSCTL(sctp_rto_max_default);\n\tm->sctp_minrto = SCTP_BASE_SYSCTL(sctp_rto_min_default);\n\tm->initial_rto = SCTP_BASE_SYSCTL(sctp_rto_initial_default);\n\tm->initial_init_rto_max = SCTP_BASE_SYSCTL(sctp_init_rto_max_default);\n\tm->sctp_sack_freq = SCTP_BASE_SYSCTL(sctp_sack_freq_default);\n\tm->max_init_times = SCTP_BASE_SYSCTL(sctp_init_rtx_max_default);\n\tm->max_send_times = SCTP_BASE_SYSCTL(sctp_assoc_rtx_max_default);\n\tm->def_net_failure = SCTP_BASE_SYSCTL(sctp_path_rtx_max_default);\n\tm->def_net_pf_threshold = SCTP_BASE_SYSCTL(sctp_path_pf_threshold);\n\tm->sctp_sws_sender = SCTP_SWS_SENDER_DEF;\n\tm->sctp_sws_receiver = SCTP_SWS_RECEIVER_DEF;\n\tm->max_burst = SCTP_BASE_SYSCTL(sctp_max_burst_default);\n\tm->fr_max_burst = SCTP_BASE_SYSCTL(sctp_fr_max_burst_default);\n\n\tm->sctp_default_cc_module = SCTP_BASE_SYSCTL(sctp_default_cc_module);\n\tm->sctp_default_ss_module = SCTP_BASE_SYSCTL(sctp_default_ss_module);\n\tm->max_open_streams_intome = SCTP_BASE_SYSCTL(sctp_nr_incoming_streams_default);\n\t/* number of streams to pre-open on a association */\n\tm->pre_open_stream_count = SCTP_BASE_SYSCTL(sctp_nr_outgoing_streams_default);\n\n\tm->default_mtu = 0;\n\t/* Add adaptation cookie */\n\tm->adaptation_layer_indicator = 0;\n\tm->adaptation_layer_indicator_provided = 0;\n\n\t/* seed random number generator */\n\tm->random_counter = 1;\n\tm->store_at = SCTP_SIGNATURE_SIZE;\n\tSCTP_READ_RANDOM(m->random_numbers, sizeof(m->random_numbers));\n\tsctp_fill_random_store(m);\n\n\t/* Minimum cookie size */\n\tm->size_of_a_cookie = (sizeof(struct sctp_init_msg) * 2) +\n\t    sizeof(struct sctp_state_cookie);\n\tm->size_of_a_cookie += SCTP_SIGNATURE_SIZE;\n\n\t/* Setup the initial secret */\n\t(void)SCTP_GETTIME_TIMEVAL(&time);\n\tm->time_of_secret_change = time.tv_sec;\n\n\tfor (i = 0; i < SCTP_NUMBER_OF_SECRETS; i++) {\n\t\tm->secret_key[0][i] = sctp_select_initial_TSN(m);\n\t}\n\tsctp_timer_start(SCTP_TIMER_TYPE_NEWCOOKIE, inp, NULL, NULL);\n\n\t/* How long is a cookie good for ? */\n\tm->def_cookie_life = MSEC_TO_TICKS(SCTP_BASE_SYSCTL(sctp_valid_cookie_life_default));\n\t/*\n\t * Initialize authentication parameters\n\t */\n\tm->local_hmacs = sctp_default_supported_hmaclist();\n\tm->local_auth_chunks = sctp_alloc_chunklist();\n\tif (inp->asconf_supported) {\n\t\tsctp_auth_add_chunk(SCTP_ASCONF, m->local_auth_chunks);\n\t\tsctp_auth_add_chunk(SCTP_ASCONF_ACK, m->local_auth_chunks);\n\t}\n\tm->default_dscp = 0;\n#ifdef INET6\n\tm->default_flowlabel = 0;\n#endif\n\tm->port = 0; /* encapsulation disabled by default */\n\tLIST_INIT(&m->shared_keys);\n\t/* add default NULL key as key id 0 */\n\tnull_key = sctp_alloc_sharedkey();\n\tsctp_insert_sharedkey(&m->shared_keys, null_key);\n\tSCTP_INP_WUNLOCK(inp);\n#ifdef SCTP_LOG_CLOSING\n\tsctp_log_closing(inp, NULL, 12);\n#endif\n\treturn (error);\n}\n\n\nvoid\nsctp_move_pcb_and_assoc(struct sctp_inpcb *old_inp, struct sctp_inpcb *new_inp,\n    struct sctp_tcb *stcb)\n{\n\tstruct sctp_nets *net;\n\tuint16_t lport, rport;\n\tstruct sctppcbhead *head;\n\tstruct sctp_laddr *laddr, *oladdr;\n\n\tatomic_add_int(&stcb->asoc.refcnt, 1);\n\tSCTP_TCB_UNLOCK(stcb);\n\tSCTP_INP_INFO_WLOCK();\n\tSCTP_INP_WLOCK(old_inp);\n\tSCTP_INP_WLOCK(new_inp);\n\tSCTP_TCB_LOCK(stcb);\n\tatomic_subtract_int(&stcb->asoc.refcnt, 1);\n\n\tnew_inp->sctp_ep.time_of_secret_change =\n\t    old_inp->sctp_ep.time_of_secret_change;\n\tmemcpy(new_inp->sctp_ep.secret_key, old_inp->sctp_ep.secret_key,\n\t    sizeof(old_inp->sctp_ep.secret_key));\n\tnew_inp->sctp_ep.current_secret_number =\n\t    old_inp->sctp_ep.current_secret_number;\n\tnew_inp->sctp_ep.last_secret_number =\n\t    old_inp->sctp_ep.last_secret_number;\n\tnew_inp->sctp_ep.size_of_a_cookie = old_inp->sctp_ep.size_of_a_cookie;\n\n\t/* make it so new data pours into the new socket */\n\tstcb->sctp_socket = new_inp->sctp_socket;\n\tstcb->sctp_ep = new_inp;\n\n\t/* Copy the port across */\n\tlport = new_inp->sctp_lport = old_inp->sctp_lport;\n\trport = stcb->rport;\n\t/* Pull the tcb from the old association */\n\tLIST_REMOVE(stcb, sctp_tcbhash);\n\tLIST_REMOVE(stcb, sctp_tcblist);\n\tif (stcb->asoc.in_asocid_hash) {\n\t\tLIST_REMOVE(stcb, sctp_tcbasocidhash);\n\t}\n\t/* Now insert the new_inp into the TCP connected hash */\n\thead = &SCTP_BASE_INFO(sctp_tcpephash)[SCTP_PCBHASH_ALLADDR((lport | rport), SCTP_BASE_INFO(hashtcpmark))];\n\n\tLIST_INSERT_HEAD(head, new_inp, sctp_hash);\n\t/* Its safe to access */\n\tnew_inp->sctp_flags &= ~SCTP_PCB_FLAGS_UNBOUND;\n\n\t/* Now move the tcb into the endpoint list */\n\tLIST_INSERT_HEAD(&new_inp->sctp_asoc_list, stcb, sctp_tcblist);\n\t/*\n\t * Question, do we even need to worry about the ep-hash since we\n\t * only have one connection? Probably not :> so lets get rid of it\n\t * and not suck up any kernel memory in that.\n\t */\n\tif (stcb->asoc.in_asocid_hash) {\n\t\tstruct sctpasochead *lhd;\n\t\tlhd = &new_inp->sctp_asocidhash[SCTP_PCBHASH_ASOC(stcb->asoc.assoc_id,\n\t\t\tnew_inp->hashasocidmark)];\n\t\tLIST_INSERT_HEAD(lhd, stcb, sctp_tcbasocidhash);\n\t}\n\t/* Ok. Let's restart timer. */\n\tTAILQ_FOREACH(net, &stcb->asoc.nets, sctp_next) {\n\t\tsctp_timer_start(SCTP_TIMER_TYPE_PATHMTURAISE, new_inp,\n\t\t    stcb, net);\n\t}\n\n\tSCTP_INP_INFO_WUNLOCK();\n\tif (new_inp->sctp_tcbhash != NULL) {\n\t\tSCTP_HASH_FREE(new_inp->sctp_tcbhash, new_inp->sctp_hashmark);\n\t\tnew_inp->sctp_tcbhash = NULL;\n\t}\n\tif ((new_inp->sctp_flags & SCTP_PCB_FLAGS_BOUNDALL) == 0) {\n\t\t/* Subset bound, so copy in the laddr list from the old_inp */\n\t\tLIST_FOREACH(oladdr, &old_inp->sctp_addr_list, sctp_nxt_addr) {\n\t\t\tladdr = SCTP_ZONE_GET(SCTP_BASE_INFO(ipi_zone_laddr), struct sctp_laddr);\n\t\t\tif (laddr == NULL) {\n\t\t\t\t/*\n\t\t\t\t * Gak, what can we do? This assoc is really\n\t\t\t\t * HOSED. We probably should send an abort\n\t\t\t\t * here.\n\t\t\t\t */\n\t\t\t\tSCTPDBG(SCTP_DEBUG_PCB1, \"Association hosed in TCP model, out of laddr memory\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tSCTP_INCR_LADDR_COUNT();\n\t\t\tmemset(laddr, 0, sizeof(*laddr));\n\t\t\t(void)SCTP_GETTIME_TIMEVAL(&laddr->start_time);\n\t\t\tladdr->ifa = oladdr->ifa;\n\t\t\tatomic_add_int(&laddr->ifa->refcount, 1);\n\t\t\tLIST_INSERT_HEAD(&new_inp->sctp_addr_list, laddr,\n\t\t\t    sctp_nxt_addr);\n\t\t\tnew_inp->laddr_count++;\n\t\t\tif (oladdr == stcb->asoc.last_used_address) {\n\t\t\t\tstcb->asoc.last_used_address = laddr;\n\t\t\t}\n\t\t}\n\t}\n\t/* Now any running timers need to be adjusted\n\t * since we really don't care if they are running\n\t * or not just blast in the new_inp into all of\n\t * them.\n\t */\n\n\tstcb->asoc.dack_timer.ep = (void *)new_inp;\n\tstcb->asoc.asconf_timer.ep = (void *)new_inp;\n\tstcb->asoc.strreset_timer.ep = (void *)new_inp;\n\tstcb->asoc.shut_guard_timer.ep = (void *)new_inp;\n\tstcb->asoc.autoclose_timer.ep = (void *)new_inp;\n\tstcb->asoc.delayed_event_timer.ep = (void *)new_inp;\n\tstcb->asoc.delete_prim_timer.ep = (void *)new_inp;\n\t/* now what about the nets? */\n\tTAILQ_FOREACH(net, &stcb->asoc.nets, sctp_next) {\n\t\tnet->pmtu_timer.ep = (void *)new_inp;\n\t\tnet->hb_timer.ep = (void *)new_inp;\n\t\tnet->rxt_timer.ep = (void *)new_inp;\n\t}\n\tSCTP_INP_WUNLOCK(new_inp);\n\tSCTP_INP_WUNLOCK(old_inp);\n}\n\n/*\n * insert an laddr entry with the given ifa for the desired list\n */\nstatic int\nsctp_insert_laddr(struct sctpladdr *list, struct sctp_ifa *ifa, uint32_t act)\n{\n\tstruct sctp_laddr *laddr;\n\n\tladdr = SCTP_ZONE_GET(SCTP_BASE_INFO(ipi_zone_laddr), struct sctp_laddr);\n\tif (laddr == NULL) {\n\t\t/* out of memory? */\n\t\tSCTP_LTRACE_ERR_RET(NULL, NULL, NULL, SCTP_FROM_SCTP_PCB, EINVAL);\n\t\treturn (EINVAL);\n\t}\n\tSCTP_INCR_LADDR_COUNT();\n\tmemset(laddr, 0, sizeof(*laddr));\n\t(void)SCTP_GETTIME_TIMEVAL(&laddr->start_time);\n\tladdr->ifa = ifa;\n\tladdr->action = act;\n\tatomic_add_int(&ifa->refcount, 1);\n\t/* insert it */\n\tLIST_INSERT_HEAD(list, laddr, sctp_nxt_addr);\n\n\treturn (0);\n}\n\n/*\n * Remove an laddr entry from the local address list (on an assoc)\n */\nstatic void\nsctp_remove_laddr(struct sctp_laddr *laddr)\n{\n\n\t/* remove from the list */\n\tLIST_REMOVE(laddr, sctp_nxt_addr);\n\tsctp_free_ifa(laddr->ifa);\n\tSCTP_ZONE_FREE(SCTP_BASE_INFO(ipi_zone_laddr), laddr);\n\tSCTP_DECR_LADDR_COUNT();\n}\n\n#if !(defined(__FreeBSD__) || defined(__APPLE__) || defined(__Userspace__))\n/*\n * Don't know why, but without this there is an unknown reference when\n * compiling NetBSD... hmm\n */\nextern void in6_sin6_2_sin(struct sockaddr_in *, struct sockaddr_in6 *sin6);\n#endif\n\n\n/* sctp_ifap is used to bypass normal local address validation checks */\nint\n#if defined(__FreeBSD__) && __FreeBSD_version >= 500000\nsctp_inpcb_bind(struct socket *so, struct sockaddr *addr,\n                struct sctp_ifa *sctp_ifap, struct thread *p)\n#elif defined(__Windows__)\nsctp_inpcb_bind(struct socket *so, struct sockaddr *addr,\n                struct sctp_ifa *sctp_ifap, PKTHREAD p)\n#else\nsctp_inpcb_bind(struct socket *so, struct sockaddr *addr,\n                struct sctp_ifa *sctp_ifap, struct proc *p)\n#endif\n{\n\t/* bind a ep to a socket address */\n\tstruct sctppcbhead *head;\n\tstruct sctp_inpcb *inp, *inp_tmp;\n#if defined(__FreeBSD__) || defined(__APPLE__)\n\tstruct inpcb *ip_inp;\n#endif\n\tint port_reuse_active = 0;\n\tint bindall;\n#ifdef SCTP_MVRF\n\tint i;\n#endif\n\tuint16_t lport;\n\tint error;\n\tuint32_t vrf_id;\n\n\tlport = 0;\n\tbindall = 1;\n\tinp = (struct sctp_inpcb *)so->so_pcb;\n#if defined(__FreeBSD__) || defined(__APPLE__)\n\tip_inp = (struct inpcb *)so->so_pcb;\n#endif\n#ifdef SCTP_DEBUG\n\tif (addr) {\n\t\tSCTPDBG(SCTP_DEBUG_PCB1, \"Bind called port: %d\\n\",\n\t\t\tntohs(((struct sockaddr_in *)addr)->sin_port));\n\t\tSCTPDBG(SCTP_DEBUG_PCB1, \"Addr: \");\n\t\tSCTPDBG_ADDR(SCTP_DEBUG_PCB1, addr);\n\t}\n#endif\n\tif ((inp->sctp_flags & SCTP_PCB_FLAGS_UNBOUND) == 0) {\n\t\t/* already did a bind, subsequent binds NOT allowed ! */\n\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, EINVAL);\n\t\treturn (EINVAL);\n\t}\n#if defined(__FreeBSD__) && __FreeBSD_version >= 500000\n#ifdef INVARIANTS\n\tif (p == NULL)\n\t\tpanic(\"null proc/thread\");\n#endif\n#endif\n\tif (addr != NULL) {\n\t\tswitch (addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t{\n\t\t\tstruct sockaddr_in *sin;\n\n\t\t\t/* IPV6_V6ONLY socket? */\n\t\t\tif (SCTP_IPV6_V6ONLY(inp)) {\n\t\t\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, EINVAL);\n\t\t\t\treturn (EINVAL);\n\t\t\t}\n#ifdef HAVE_SA_LEN\n\t\t\tif (addr->sa_len != sizeof(*sin)) {\n\t\t\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, EINVAL);\n\t\t\t\treturn (EINVAL);\n\t\t\t}\n#endif\n\n\t\t\tsin = (struct sockaddr_in *)addr;\n\t\t\tlport = sin->sin_port;\n#if defined(__FreeBSD__) && __FreeBSD_version >= 800000\n\t\t\t/*\n\t\t\t * For LOOPBACK the prison_local_ip4() call will transmute the ip address\n\t\t\t * to the proper value.\n\t\t\t */\n\t\t\tif (p && (error = prison_local_ip4(p->td_ucred, &sin->sin_addr)) != 0) {\n\t\t\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, error);\n\t\t\t\treturn (error);\n\t\t\t}\n#endif\n\t\t\tif (sin->sin_addr.s_addr != INADDR_ANY) {\n\t\t\t\tbindall = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n#endif\n#ifdef INET6\n\t\tcase AF_INET6:\n\t\t{\n\t\t\t/* Only for pure IPv6 Address. (No IPv4 Mapped!) */\n\t\t\tstruct sockaddr_in6 *sin6;\n\n\t\t\tsin6 = (struct sockaddr_in6 *)addr;\n\n#ifdef HAVE_SA_LEN\n\t\t\tif (addr->sa_len != sizeof(*sin6)) {\n\t\t\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, EINVAL);\n\t\t\t\treturn (EINVAL);\n\t\t\t}\n#endif\n\t\t\tlport = sin6->sin6_port;\n#if defined(__FreeBSD__) && __FreeBSD_version >= 800000\n\t\t\t/*\n\t\t\t * For LOOPBACK the prison_local_ip6() call will transmute the ipv6 address\n\t\t\t * to the proper value.\n\t\t\t */\n\t\t\tif (p && (error = prison_local_ip6(p->td_ucred, &sin6->sin6_addr,\n\t\t\t    (SCTP_IPV6_V6ONLY(inp) != 0))) != 0) {\n\t\t\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, error);\n\t\t\t\treturn (error);\n\t\t\t}\n#endif\n\t\t\tif (!IN6_IS_ADDR_UNSPECIFIED(&sin6->sin6_addr)) {\n\t\t\t\tbindall = 0;\n#ifdef SCTP_EMBEDDED_V6_SCOPE\n\t\t\t\t/* KAME hack: embed scopeid */\n#if defined(SCTP_KAME)\n\t\t\t\tif (sa6_embedscope(sin6, MODULE_GLOBAL(ip6_use_defzone)) != 0) {\n\t\t\t\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, EINVAL);\n\t\t\t\t\treturn (EINVAL);\n\t\t\t\t}\n#elif defined(__APPLE__)\n#if defined(APPLE_LEOPARD) || defined(APPLE_SNOWLEOPARD)\n\t\t\t\tif (in6_embedscope(&sin6->sin6_addr, sin6, ip_inp, NULL) != 0) {\n#else\n\t\t\t\tif (in6_embedscope(&sin6->sin6_addr, sin6, ip_inp, NULL, NULL) != 0) {\n#endif\n\t\t\t\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, EINVAL);\n\t\t\t\t\treturn (EINVAL);\n\t\t\t\t}\n#elif defined(__FreeBSD__)\n\t\t\t\terror = scope6_check_id(sin6, MODULE_GLOBAL(ip6_use_defzone));\n\t\t\t\tif (error != 0) {\n\t\t\t\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, error);\n\t\t\t\t\treturn (error);\n\t\t\t\t}\n#else\n\t\t\t\tif (in6_embedscope(&sin6->sin6_addr, sin6) != 0) {\n\t\t\t\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, EINVAL);\n\t\t\t\t\treturn (EINVAL);\n\t\t\t\t}\n#endif\n#endif /* SCTP_EMBEDDED_V6_SCOPE */\n\t\t\t}\n#ifndef SCOPEDROUTING\n\t\t\t/* this must be cleared for ifa_ifwithaddr() */\n\t\t\tsin6->sin6_scope_id = 0;\n#endif /* SCOPEDROUTING */\n\t\t\tbreak;\n\t\t}\n#endif\n#if defined(__Userspace__)\n\t\tcase AF_CONN:\n\t\t{\n\t\t\tstruct sockaddr_conn *sconn;\n\n#ifdef HAVE_SA_LEN\n\t\t\tif (addr->sa_len != sizeof(struct sockaddr_conn)) {\n\t\t\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, EINVAL);\n\t\t\t\treturn (EINVAL);\n\t\t\t}\n#endif\n\t\t\tsconn = (struct sockaddr_conn *)addr;\n\t\t\tlport = sconn->sconn_port;\n\t\t\tif (sconn->sconn_addr != NULL) {\n\t\t\t\tbindall = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, EAFNOSUPPORT);\n\t\t\treturn (EAFNOSUPPORT);\n\t\t}\n\t}\n\tSCTP_INP_INFO_WLOCK();\n\tSCTP_INP_WLOCK(inp);\n\t/* Setup a vrf_id to be the default for the non-bind-all case. */\n\tvrf_id = inp->def_vrf_id;\n\n\t/* increase our count due to the unlock we do */\n\tSCTP_INP_INCR_REF(inp);\n\tif (lport) {\n\t\t/*\n\t\t * Did the caller specify a port? if so we must see if an ep\n\t\t * already has this one bound.\n\t\t */\n\t\t/* got to be root to get at low ports */\n#if !defined(__Windows__)\n\t\tif (ntohs(lport) < IPPORT_RESERVED) {\n\t\t\tif ((p != NULL) && ((error =\n#ifdef __FreeBSD__\n#if __FreeBSD_version > 602000\n\t\t\t\t  priv_check(p, PRIV_NETINET_RESERVEDPORT)\n#elif __FreeBSD_version >= 500000\n\t\t\t\t  suser_cred(p->td_ucred, 0)\n#else\n\t\t\t\t  suser(p)\n#endif\n#elif defined(__APPLE__)\n\t\t\t\t  suser(p->p_ucred, &p->p_acflag)\n#elif defined(__Userspace__) /* must be true to use raw socket */\n\t\t\t\t  1\n#else\n\t\t\t\t  suser(p, 0)\n#endif\n\t\t\t\t    ) != 0)) {\n\t\t\t\tSCTP_INP_DECR_REF(inp);\n\t\t\t\tSCTP_INP_WUNLOCK(inp);\n\t\t\t\tSCTP_INP_INFO_WUNLOCK();\n\t\t\t\treturn (error);\n\t\t\t}\n#if defined(__Panda__)\n\t\t\tif (!SCTP_IS_PRIVILEDGED(so)) {\n\t\t\t\tSCTP_INP_DECR_REF(inp);\n\t\t\t\tSCTP_INP_WUNLOCK(inp);\n\t\t\t\tSCTP_INP_INFO_WUNLOCK();\n\t\t\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, EACCES);\n\t\t\t\treturn (EACCES);\n\t\t\t}\n#endif\n\t\t}\n#endif /* __Windows__ */\n\t\tSCTP_INP_WUNLOCK(inp);\n\t\tif (bindall) {\n#ifdef SCTP_MVRF\n\t\t\tfor (i = 0; i < inp->num_vrfs; i++) {\n\t\t\t\tvrf_id = inp->m_vrf_ids[i];\n#else\n\t\t\t\tvrf_id = inp->def_vrf_id;\n#endif\n\t\t\t\tinp_tmp = sctp_pcb_findep(addr, 0, 1, vrf_id);\n\t\t\t\tif (inp_tmp != NULL) {\n\t\t\t\t\t/*\n\t\t\t\t\t * lock guy returned and lower count\n\t\t\t\t\t * note that we are not bound so\n\t\t\t\t\t * inp_tmp should NEVER be inp. And\n\t\t\t\t\t * it is this inp (inp_tmp) that gets\n\t\t\t\t\t * the reference bump, so we must\n\t\t\t\t\t * lower it.\n\t\t\t\t\t */\n\t\t\t\t\tSCTP_INP_DECR_REF(inp_tmp);\n\t\t\t\t\t/* unlock info */\n\t\t\t\t\tif ((sctp_is_feature_on(inp, SCTP_PCB_FLAGS_PORTREUSE)) &&\n\t\t\t\t\t    (sctp_is_feature_on(inp_tmp, SCTP_PCB_FLAGS_PORTREUSE))) {\n\t\t\t\t\t\t/* Ok, must be one-2-one and allowing port re-use */\n\t\t\t\t\t\tport_reuse_active = 1;\n\t\t\t\t\t\tgoto continue_anyway;\n\t\t\t\t\t}\n\t\t\t\t\tSCTP_INP_DECR_REF(inp);\n\t\t\t\t\tSCTP_INP_INFO_WUNLOCK();\n\t\t\t\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, EADDRINUSE);\n\t\t\t\t\treturn (EADDRINUSE);\n\t\t\t\t}\n#ifdef SCTP_MVRF\n\t\t\t}\n#endif\n\t\t} else {\n\t\t\tinp_tmp = sctp_pcb_findep(addr, 0, 1, vrf_id);\n\t\t\tif (inp_tmp != NULL) {\n\t\t\t\t/*\n\t\t\t\t * lock guy returned and lower count note\n\t\t\t\t * that we are not bound so inp_tmp should\n\t\t\t\t * NEVER be inp. And it is this inp (inp_tmp)\n\t\t\t\t * that gets the reference bump, so we must\n\t\t\t\t * lower it.\n\t\t\t\t */\n\t\t\t\tSCTP_INP_DECR_REF(inp_tmp);\n\t\t\t\t/* unlock info */\n\t\t\t\tif ((sctp_is_feature_on(inp, SCTP_PCB_FLAGS_PORTREUSE)) &&\n\t\t\t\t    (sctp_is_feature_on(inp_tmp, SCTP_PCB_FLAGS_PORTREUSE))) {\n\t\t\t\t\t/* Ok, must be one-2-one and allowing port re-use */\n\t\t\t\t\tport_reuse_active = 1;\n\t\t\t\t\tgoto continue_anyway;\n\t\t\t\t}\n\t\t\t\tSCTP_INP_DECR_REF(inp);\n\t\t\t\tSCTP_INP_INFO_WUNLOCK();\n\t\t\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, EADDRINUSE);\n\t\t\t\treturn (EADDRINUSE);\n\t\t\t}\n\t\t}\n\tcontinue_anyway:\n\t\tSCTP_INP_WLOCK(inp);\n\t\tif (bindall) {\n\t\t\t/* verify that no lport is not used by a singleton */\n\t\t\tif ((port_reuse_active == 0) &&\n\t\t\t    (inp_tmp = sctp_isport_inuse(inp, lport, vrf_id))) {\n\t\t\t\t/* Sorry someone already has this one bound */\n\t\t\t\tif ((sctp_is_feature_on(inp, SCTP_PCB_FLAGS_PORTREUSE)) &&\n\t\t\t\t    (sctp_is_feature_on(inp_tmp, SCTP_PCB_FLAGS_PORTREUSE))) {\n\t\t\t\t\tport_reuse_active = 1;\n\t\t\t\t} else {\n\t\t\t\t\tSCTP_INP_DECR_REF(inp);\n\t\t\t\t\tSCTP_INP_WUNLOCK(inp);\n\t\t\t\t\tSCTP_INP_INFO_WUNLOCK();\n\t\t\t\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, EADDRINUSE);\n\t\t\t\t\treturn (EADDRINUSE);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tuint16_t first, last, candidate;\n\t\tuint16_t count;\n\t\tint done;\n\n#if defined(__Windows__)\n\t\tfirst = 1;\n\t\tlast = 0xffff;\n#else\n#if defined(__Userspace__)\n\t\t/* TODO ensure uid is 0, etc... */\n#elif defined(__FreeBSD__) || defined(__APPLE__)\n\t\tif (ip_inp->inp_flags & INP_HIGHPORT) {\n\t\t\tfirst = MODULE_GLOBAL(ipport_hifirstauto);\n\t\t\tlast = MODULE_GLOBAL(ipport_hilastauto);\n\t\t} else if (ip_inp->inp_flags & INP_LOWPORT) {\n\t\t\tif (p && (error =\n#ifdef __FreeBSD__\n#if __FreeBSD_version > 602000\n\t\t\t\t  priv_check(p, PRIV_NETINET_RESERVEDPORT)\n#elif __FreeBSD_version >= 500000\n\t\t\t\t  suser_cred(p->td_ucred, 0)\n#else\n\t\t\t\t  suser(p)\n#endif\n#elif defined(__APPLE__)\n\t\t\t\t  suser(p->p_ucred, &p->p_acflag)\n#else\n\t\t\t\t  suser(p, 0)\n#endif\n\t\t\t\t    )) {\n\t\t\t\tSCTP_INP_DECR_REF(inp);\n\t\t\t\tSCTP_INP_WUNLOCK(inp);\n\t\t\t\tSCTP_INP_INFO_WUNLOCK();\n\t\t\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, error);\n\t\t\t\treturn (error);\n\t\t\t}\n\t\t\tfirst = MODULE_GLOBAL(ipport_lowfirstauto);\n\t\t\tlast = MODULE_GLOBAL(ipport_lowlastauto);\n\t\t} else {\n#endif\n\t\t\tfirst = MODULE_GLOBAL(ipport_firstauto);\n\t\t\tlast = MODULE_GLOBAL(ipport_lastauto);\n#if defined(__FreeBSD__) || defined(__APPLE__)\n\t\t}\n#endif\n#endif /* __Windows__ */\n\t\tif (first > last) {\n\t\t\tuint16_t temp;\n\n\t\t\ttemp = first;\n\t\t\tfirst = last;\n\t\t\tlast = temp;\n\t\t}\n\t\tcount = last - first + 1; /* number of candidates */\n\t\tcandidate = first + sctp_select_initial_TSN(&inp->sctp_ep) % (count);\n\n\t\tdone = 0;\n\t\twhile (!done) {\n#ifdef SCTP_MVRF\n\t\t\tfor (i = 0; i < inp->num_vrfs; i++) {\n\t\t\t\tif (sctp_isport_inuse(inp, htons(candidate), inp->m_vrf_ids[i]) != NULL) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == inp->num_vrfs) {\n\t\t\t\tdone = 1;\n\t\t\t}\n#else\n\t\t\tif (sctp_isport_inuse(inp, htons(candidate), inp->def_vrf_id) == NULL) {\n\t\t\t\tdone = 1;\n\t\t\t}\n#endif\n\t\t\tif (!done) {\n\t\t\t\tif (--count == 0) {\n\t\t\t\t\tSCTP_INP_DECR_REF(inp);\n\t\t\t\t\tSCTP_INP_WUNLOCK(inp);\n\t\t\t\t\tSCTP_INP_INFO_WUNLOCK();\n\t\t\t\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, EADDRINUSE);\n\t\t\t\t\treturn (EADDRINUSE);\n\t\t\t\t}\n\t\t\t\tif (candidate == last)\n\t\t\t\t\tcandidate = first;\n\t\t\t\telse\n\t\t\t\t\tcandidate = candidate + 1;\n\t\t\t}\n\t\t}\n\t\tlport = htons(candidate);\n\t}\n\tSCTP_INP_DECR_REF(inp);\n\tif (inp->sctp_flags & (SCTP_PCB_FLAGS_SOCKET_GONE |\n\t\t\t       SCTP_PCB_FLAGS_SOCKET_ALLGONE)) {\n\t\t/*\n\t\t * this really should not happen. The guy did a non-blocking\n\t\t * bind and then did a close at the same time.\n\t\t */\n\t\tSCTP_INP_WUNLOCK(inp);\n\t\tSCTP_INP_INFO_WUNLOCK();\n\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, EINVAL);\n\t\treturn (EINVAL);\n\t}\n\t/* ok we look clear to give out this port, so lets setup the binding */\n\tif (bindall) {\n\t\t/* binding to all addresses, so just set in the proper flags */\n\t\tinp->sctp_flags |= SCTP_PCB_FLAGS_BOUNDALL;\n\t\t/* set the automatic addr changes from kernel flag */\n\t\tif (SCTP_BASE_SYSCTL(sctp_auto_asconf) == 0) {\n\t\t\tsctp_feature_off(inp, SCTP_PCB_FLAGS_DO_ASCONF);\n\t\t\tsctp_feature_off(inp, SCTP_PCB_FLAGS_AUTO_ASCONF);\n\t\t} else {\n\t\t\tsctp_feature_on(inp, SCTP_PCB_FLAGS_DO_ASCONF);\n\t\t\tsctp_feature_on(inp, SCTP_PCB_FLAGS_AUTO_ASCONF);\n\t\t}\n\t\tif (SCTP_BASE_SYSCTL(sctp_multiple_asconfs) == 0) {\n\t\t\tsctp_feature_off(inp, SCTP_PCB_FLAGS_MULTIPLE_ASCONFS);\n\t\t} else {\n\t\t\tsctp_feature_on(inp, SCTP_PCB_FLAGS_MULTIPLE_ASCONFS);\n\t\t}\n\t\t/* set the automatic mobility_base from kernel\n\t\t   flag (by micchie)\n\t\t*/\n\t\tif (SCTP_BASE_SYSCTL(sctp_mobility_base) == 0) {\n\t\t\tsctp_mobility_feature_off(inp, SCTP_MOBILITY_BASE);\n\t\t\tsctp_mobility_feature_off(inp, SCTP_MOBILITY_PRIM_DELETED);\n\t\t} else {\n\t\t\tsctp_mobility_feature_on(inp, SCTP_MOBILITY_BASE);\n\t\t\tsctp_mobility_feature_off(inp, SCTP_MOBILITY_PRIM_DELETED);\n\t\t}\n\t\t/* set the automatic mobility_fasthandoff from kernel\n\t\t   flag (by micchie)\n\t\t*/\n\t\tif (SCTP_BASE_SYSCTL(sctp_mobility_fasthandoff) == 0) {\n\t\t\tsctp_mobility_feature_off(inp, SCTP_MOBILITY_FASTHANDOFF);\n\t\t\tsctp_mobility_feature_off(inp, SCTP_MOBILITY_PRIM_DELETED);\n\t\t} else {\n\t\t\tsctp_mobility_feature_on(inp, SCTP_MOBILITY_FASTHANDOFF);\n\t\t\tsctp_mobility_feature_off(inp, SCTP_MOBILITY_PRIM_DELETED);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * bind specific, make sure flags is off and add a new\n\t\t * address structure to the sctp_addr_list inside the ep\n\t\t * structure.\n\t\t *\n\t\t * We will need to allocate one and insert it at the head. The\n\t\t * socketopt call can just insert new addresses in there as\n\t\t * well. It will also have to do the embed scope kame hack\n\t\t * too (before adding).\n\t\t */\n\t\tstruct sctp_ifa *ifa;\n\t\tunion sctp_sockstore store;\n\n\t\tmemset(&store, 0, sizeof(store));\n\t\tswitch (addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tmemcpy(&store.sin, addr, sizeof(struct sockaddr_in));\n\t\t\tstore.sin.sin_port = 0;\n\t\t\tbreak;\n#endif\n#ifdef INET6\n\t\tcase AF_INET6:\n\t\t\tmemcpy(&store.sin6, addr, sizeof(struct sockaddr_in6));\n\t\t\tstore.sin6.sin6_port = 0;\n\t\t\tbreak;\n#endif\n#if defined(__Userspace__)\n\t\tcase AF_CONN:\n\t\t\tmemcpy(&store.sconn, addr, sizeof(struct sockaddr_conn));\n\t\t\tstore.sconn.sconn_port = 0;\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * first find the interface with the bound address need to\n\t\t * zero out the port to find the address! yuck! can't do\n\t\t * this earlier since need port for sctp_pcb_findep()\n\t\t */\n\t\tif (sctp_ifap != NULL) {\n\t\t\tifa = sctp_ifap;\n\t\t} else {\n\t\t\t/* Note for BSD we hit here always other\n\t\t\t * O/S's will pass things in via the\n\t\t\t * sctp_ifap argument (Panda).\n\t\t\t */\n\t\t\tifa = sctp_find_ifa_by_addr(&store.sa,\n\t\t\t\t\t\t    vrf_id, SCTP_ADDR_NOT_LOCKED);\n\t\t}\n\t\tif (ifa == NULL) {\n\t\t\t/* Can't find an interface with that address */\n\t\t\tSCTP_INP_WUNLOCK(inp);\n\t\t\tSCTP_INP_INFO_WUNLOCK();\n\t\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, EADDRNOTAVAIL);\n\t\t\treturn (EADDRNOTAVAIL);\n\t\t}\n#ifdef INET6\n\t\tif (addr->sa_family == AF_INET6) {\n\t\t\t/* GAK, more FIXME IFA lock? */\n\t\t\tif (ifa->localifa_flags & SCTP_ADDR_IFA_UNUSEABLE) {\n\t\t\t\t/* Can't bind a non-existent addr. */\n\t\t\t\tSCTP_INP_WUNLOCK(inp);\n\t\t\t\tSCTP_INP_INFO_WUNLOCK();\n\t\t\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, EINVAL);\n\t\t\t\treturn (EINVAL);\n\t\t\t}\n\t\t}\n#endif\n\t\t/* we're not bound all */\n\t\tinp->sctp_flags &= ~SCTP_PCB_FLAGS_BOUNDALL;\n\t\t/* allow bindx() to send ASCONF's for binding changes */\n\t\tsctp_feature_on(inp, SCTP_PCB_FLAGS_DO_ASCONF);\n\t\t/* clear automatic addr changes from kernel flag */\n\t\tsctp_feature_off(inp, SCTP_PCB_FLAGS_AUTO_ASCONF);\n\n\t\t/* add this address to the endpoint list */\n\t\terror = sctp_insert_laddr(&inp->sctp_addr_list, ifa, 0);\n\t\tif (error != 0) {\n\t\t\tSCTP_INP_WUNLOCK(inp);\n\t\t\tSCTP_INP_INFO_WUNLOCK();\n\t\t\treturn (error);\n\t\t}\n\t\tinp->laddr_count++;\n\t}\n\t/* find the bucket */\n\tif (port_reuse_active) {\n\t\t/* Put it into tcp 1-2-1 hash */\n\t\thead = &SCTP_BASE_INFO(sctp_tcpephash)[SCTP_PCBHASH_ALLADDR(lport, SCTP_BASE_INFO(hashtcpmark))];\n\t\tinp->sctp_flags |= SCTP_PCB_FLAGS_IN_TCPPOOL;\n\t} else {\n\t\thead = &SCTP_BASE_INFO(sctp_ephash)[SCTP_PCBHASH_ALLADDR(lport, SCTP_BASE_INFO(hashmark))];\n\t}\n\t/* put it in the bucket */\n\tLIST_INSERT_HEAD(head, inp, sctp_hash);\n\tSCTPDBG(SCTP_DEBUG_PCB1, \"Main hash to bind at head:%p, bound port:%d - in tcp_pool=%d\\n\",\n\t\t(void *)head, ntohs(lport), port_reuse_active);\n\t/* set in the port */\n\tinp->sctp_lport = lport;\n\n\t/* turn off just the unbound flag */\n\tinp->sctp_flags &= ~SCTP_PCB_FLAGS_UNBOUND;\n\tSCTP_INP_WUNLOCK(inp);\n\tSCTP_INP_INFO_WUNLOCK();\n\treturn (0);\n}\n\n\nstatic void\nsctp_iterator_inp_being_freed(struct sctp_inpcb *inp)\n{\n\tstruct sctp_iterator *it, *nit;\n\n\t/*\n\t * We enter with the only the ITERATOR_LOCK in place and a write\n\t * lock on the inp_info stuff.\n\t */\n\tit = sctp_it_ctl.cur_it;\n#if defined(__FreeBSD__) && __FreeBSD_version >= 801000\n\tif (it && (it->vn != curvnet)) {\n\t\t/* Its not looking at our VNET */\n\t\treturn;\n\t}\n#endif\n\tif (it && (it->inp == inp)) {\n\t\t/*\n\t\t * This is tricky and we hold the iterator lock,\n\t\t * but when it returns and gets the lock (when we\n\t\t * release it) the iterator will try to operate on\n\t\t * inp. We need to stop that from happening. But\n\t\t * of course the iterator has a reference on the\n\t\t * stcb and inp. We can mark it and it will stop.\n\t\t *\n\t\t * If its a single iterator situation, we\n\t\t * set the end iterator flag. Otherwise\n\t\t * we set the iterator to go to the next inp.\n\t\t *\n\t\t */\n\t\tif (it->iterator_flags & SCTP_ITERATOR_DO_SINGLE_INP) {\n\t\t\tsctp_it_ctl.iterator_flags |= SCTP_ITERATOR_STOP_CUR_IT;\n\t\t} else {\n\t\t\tsctp_it_ctl.iterator_flags |= SCTP_ITERATOR_STOP_CUR_INP;\n\t\t}\n\t}\n\t/* Now go through and remove any single reference to\n\t * our inp that may be still pending on the list\n\t */\n\tSCTP_IPI_ITERATOR_WQ_LOCK();\n\tTAILQ_FOREACH_SAFE(it, &sctp_it_ctl.iteratorhead, sctp_nxt_itr, nit) {\n#if defined(__FreeBSD__) && __FreeBSD_version >= 801000\n\t\tif (it->vn != curvnet) {\n\t\t\tcontinue;\n\t\t}\n#endif\n\t\tif (it->inp == inp) {\n\t\t\t/* This one points to me is it inp specific? */\n\t\t\tif (it->iterator_flags & SCTP_ITERATOR_DO_SINGLE_INP) {\n\t\t\t\t/* Remove and free this one */\n\t\t\t\tTAILQ_REMOVE(&sctp_it_ctl.iteratorhead,\n\t\t\t\t    it, sctp_nxt_itr);\n\t\t\t\tif (it->function_atend != NULL) {\n\t\t\t\t\t(*it->function_atend) (it->pointer, it->val);\n\t\t\t\t}\n\t\t\t\tSCTP_FREE(it, SCTP_M_ITER);\n\t\t\t} else {\n\t\t\t\tit->inp = LIST_NEXT(it->inp, sctp_list);\n\t\t\t\tif (it->inp) {\n\t\t\t\t\tSCTP_INP_INCR_REF(it->inp);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* When its put in the refcnt is incremented so decr it */\n\t\t\tSCTP_INP_DECR_REF(inp);\n\t\t}\n\t}\n\tSCTP_IPI_ITERATOR_WQ_UNLOCK();\n}\n\n/* release sctp_inpcb unbind the port */\nvoid\nsctp_inpcb_free(struct sctp_inpcb *inp, int immediate, int from)\n{\n\t/*\n\t * Here we free a endpoint. We must find it (if it is in the Hash\n\t * table) and remove it from there. Then we must also find it in the\n\t * overall list and remove it from there. After all removals are\n\t * complete then any timer has to be stopped. Then start the actual\n\t * freeing. a) Any local lists. b) Any associations. c) The hash of\n\t * all associations. d) finally the ep itself.\n\t */\n\tstruct sctp_tcb *asoc, *nasoc;\n\tstruct sctp_laddr *laddr, *nladdr;\n\tstruct inpcb *ip_pcb;\n\tstruct socket *so;\n\tint being_refed = 0;\n\tstruct sctp_queued_to_read *sq, *nsq;\n#if !defined(__Panda__) && !defined(__Userspace__)\n#if !defined(__FreeBSD__) || __FreeBSD_version < 500000\n\tsctp_rtentry_t *rt;\n#endif\n#endif\n\tint cnt;\n\tsctp_sharedkey_t *shared_key, *nshared_key;\n\n\n#if defined(__APPLE__)\n\tsctp_lock_assert(SCTP_INP_SO(inp));\n#endif\n#ifdef SCTP_LOG_CLOSING\n\tsctp_log_closing(inp, NULL, 0);\n#endif\n\tSCTP_ITERATOR_LOCK();\n\t/* mark any iterators on the list or being processed */\n\tsctp_iterator_inp_being_freed(inp);\n\tSCTP_ITERATOR_UNLOCK();\n\tso = inp->sctp_socket;\n\tif (inp->sctp_flags & SCTP_PCB_FLAGS_SOCKET_ALLGONE) {\n\t\t/* been here before.. eeks.. get out of here */\n\t\tSCTP_PRINTF(\"This conflict in free SHOULD not be happening! from %d, imm %d\\n\", from, immediate);\n#ifdef SCTP_LOG_CLOSING\n\t\tsctp_log_closing(inp, NULL, 1);\n#endif\n\t\treturn;\n\t}\n\tSCTP_ASOC_CREATE_LOCK(inp);\n\tSCTP_INP_INFO_WLOCK();\n\n\tSCTP_INP_WLOCK(inp);\n\tif (from == SCTP_CALLED_AFTER_CMPSET_OFCLOSE) {\n\t\tinp->sctp_flags &= ~SCTP_PCB_FLAGS_CLOSE_IP;\n\t\t/* socket is gone, so no more wakeups allowed */\n\t\tinp->sctp_flags |= SCTP_PCB_FLAGS_DONT_WAKE;\n\t\tinp->sctp_flags &= ~SCTP_PCB_FLAGS_WAKEINPUT;\n\t\tinp->sctp_flags &= ~SCTP_PCB_FLAGS_WAKEOUTPUT;\n\n\t}\n\t/* First time through we have the socket lock, after that no more. */\n\tsctp_timer_stop(SCTP_TIMER_TYPE_NEWCOOKIE, inp, NULL, NULL,\n\t\t\tSCTP_FROM_SCTP_PCB + SCTP_LOC_1);\n\n\tif (inp->control) {\n\t\tsctp_m_freem(inp->control);\n\t\tinp->control = NULL;\n\t}\n\tif (inp->pkt) {\n\t\tsctp_m_freem(inp->pkt);\n\t\tinp->pkt = NULL;\n\t}\n\tip_pcb = &inp->ip_inp.inp;\t/* we could just cast the main pointer\n\t\t\t\t\t * here but I will be nice :> (i.e.\n\t\t\t\t\t * ip_pcb = ep;) */\n\tif (immediate == SCTP_FREE_SHOULD_USE_GRACEFUL_CLOSE) {\n\t\tint cnt_in_sd;\n\n\t\tcnt_in_sd = 0;\n\t\tLIST_FOREACH_SAFE(asoc, &inp->sctp_asoc_list, sctp_tcblist, nasoc) {\n\t\t\tSCTP_TCB_LOCK(asoc);\n\t\t\tif (asoc->asoc.state & SCTP_STATE_ABOUT_TO_BE_FREED) {\n\t\t\t\t/* Skip guys being freed */\n\t\t\t\tcnt_in_sd++;\n\t\t\t\tif (asoc->asoc.state & SCTP_STATE_IN_ACCEPT_QUEUE) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Special case - we did not start a kill\n\t\t\t\t\t * timer on the asoc due to it was not\n\t\t\t\t\t * closed. So go ahead and start it now.\n\t\t\t\t\t */\n\t\t\t\t\tSCTP_CLEAR_SUBSTATE(asoc, SCTP_STATE_IN_ACCEPT_QUEUE);\n\t\t\t\t\tsctp_timer_start(SCTP_TIMER_TYPE_ASOCKILL, inp, asoc, NULL);\n\t\t\t\t}\n\t\t\t\tSCTP_TCB_UNLOCK(asoc);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (((SCTP_GET_STATE(asoc) == SCTP_STATE_COOKIE_WAIT) ||\n\t\t\t     (SCTP_GET_STATE(asoc) == SCTP_STATE_COOKIE_ECHOED)) &&\n\t\t\t    (asoc->asoc.total_output_queue_size == 0)) {\n\t\t\t\t/* If we have data in queue, we don't want to just\n\t\t\t\t * free since the app may have done, send()/close\n\t\t\t\t * or connect/send/close. And it wants the data\n\t\t\t\t * to get across first.\n\t\t\t\t */\n\t\t\t\t/* Just abandon things in the front states */\n\t\t\t\tif (sctp_free_assoc(inp, asoc, SCTP_PCBFREE_NOFORCE,\n\t\t\t\t\t\t   SCTP_FROM_SCTP_PCB + SCTP_LOC_2) == 0) {\n\t\t\t\t\tcnt_in_sd++;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* Disconnect the socket please */\n\t\t\tasoc->sctp_socket = NULL;\n\t\t\tSCTP_ADD_SUBSTATE(asoc, SCTP_STATE_CLOSED_SOCKET);\n\t\t\tif ((asoc->asoc.size_on_reasm_queue > 0) ||\n\t\t\t    (asoc->asoc.control_pdapi) ||\n\t\t\t    (asoc->asoc.size_on_all_streams > 0) ||\n\t\t\t    (so && (so->so_rcv.sb_cc > 0))) {\n\t\t\t\t/* Left with Data unread */\n\t\t\t\tstruct mbuf *op_err;\n\n\t\t\t\top_err = sctp_generate_cause(SCTP_CAUSE_USER_INITIATED_ABT, \"\");\n\t\t\t\tasoc->sctp_ep->last_abort_code = SCTP_FROM_SCTP_PCB + SCTP_LOC_3;\n\t\t\t\tsctp_send_abort_tcb(asoc, op_err, SCTP_SO_LOCKED);\n\t\t\t\tSCTP_STAT_INCR_COUNTER32(sctps_aborted);\n\t\t\t\tif ((SCTP_GET_STATE(asoc) == SCTP_STATE_OPEN) ||\n\t\t\t\t    (SCTP_GET_STATE(asoc) == SCTP_STATE_SHUTDOWN_RECEIVED)) {\n\t\t\t\t\tSCTP_STAT_DECR_GAUGE32(sctps_currestab);\n\t\t\t\t}\n\t\t\t\tif (sctp_free_assoc(inp, asoc,\n\t\t\t\t\t\t    SCTP_PCBFREE_NOFORCE, SCTP_FROM_SCTP_PCB + SCTP_LOC_4) == 0) {\n\t\t\t\t\tcnt_in_sd++;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t} else if (TAILQ_EMPTY(&asoc->asoc.send_queue) &&\n\t\t\t           TAILQ_EMPTY(&asoc->asoc.sent_queue) &&\n\t\t\t           (asoc->asoc.stream_queue_cnt == 0)) {\n\t\t\t\tif ((*asoc->asoc.ss_functions.sctp_ss_is_user_msgs_incomplete)(asoc, &asoc->asoc)) {\n\t\t\t\t\tgoto abort_anyway;\n\t\t\t\t}\n\t\t\t\tif ((SCTP_GET_STATE(asoc) != SCTP_STATE_SHUTDOWN_SENT) &&\n\t\t\t\t    (SCTP_GET_STATE(asoc) != SCTP_STATE_SHUTDOWN_ACK_SENT)) {\n\t\t\t\t\tstruct sctp_nets *netp;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * there is nothing queued to send,\n\t\t\t\t\t * so I send shutdown\n\t\t\t\t\t */\n\t\t\t\t\tif ((SCTP_GET_STATE(asoc) == SCTP_STATE_OPEN) ||\n\t\t\t\t\t    (SCTP_GET_STATE(asoc) == SCTP_STATE_SHUTDOWN_RECEIVED)) {\n\t\t\t\t\t\tSCTP_STAT_DECR_GAUGE32(sctps_currestab);\n\t\t\t\t\t}\n\t\t\t\t\tSCTP_SET_STATE(asoc, SCTP_STATE_SHUTDOWN_SENT);\n\t\t\t\t\tsctp_stop_timers_for_shutdown(asoc);\n\t\t\t\t\tif (asoc->asoc.alternate) {\n\t\t\t\t\t\tnetp = asoc->asoc.alternate;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnetp = asoc->asoc.primary_destination;\n\t\t\t\t\t}\n\t\t\t\t\tsctp_send_shutdown(asoc, netp);\n\t\t\t\t\tsctp_timer_start(SCTP_TIMER_TYPE_SHUTDOWN, asoc->sctp_ep, asoc,\n\t\t\t\t\t    netp);\n\t\t\t\t\tsctp_timer_start(SCTP_TIMER_TYPE_SHUTDOWNGUARD, asoc->sctp_ep, asoc,\n\t\t\t\t\t    asoc->asoc.primary_destination);\n\t\t\t\t\tsctp_chunk_output(inp, asoc, SCTP_OUTPUT_FROM_SHUT_TMR, SCTP_SO_LOCKED);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* mark into shutdown pending */\n\t\t\t\tSCTP_ADD_SUBSTATE(asoc, SCTP_STATE_SHUTDOWN_PENDING);\n\t\t\t\tsctp_timer_start(SCTP_TIMER_TYPE_SHUTDOWNGUARD, asoc->sctp_ep, asoc,\n\t\t\t\t\t\t asoc->asoc.primary_destination);\n\t\t\t\tif ((*asoc->asoc.ss_functions.sctp_ss_is_user_msgs_incomplete)(asoc, &asoc->asoc)) {\n\t\t\t\t\tSCTP_ADD_SUBSTATE(asoc, SCTP_STATE_PARTIAL_MSG_LEFT);\n\t\t\t\t}\n\t\t\t\tif (TAILQ_EMPTY(&asoc->asoc.send_queue) &&\n\t\t\t\t    TAILQ_EMPTY(&asoc->asoc.sent_queue) &&\n\t\t\t\t    (asoc->asoc.state & SCTP_STATE_PARTIAL_MSG_LEFT)) {\n\t\t\t\t\tstruct mbuf *op_err;\n\t\t\t\tabort_anyway:\n\t\t\t\t\top_err = sctp_generate_cause(SCTP_CAUSE_USER_INITIATED_ABT, \"\");\n\t\t\t\t\tasoc->sctp_ep->last_abort_code = SCTP_FROM_SCTP_PCB + SCTP_LOC_5;\n\t\t\t\t\tsctp_send_abort_tcb(asoc, op_err, SCTP_SO_LOCKED);\n\t\t\t\t\tSCTP_STAT_INCR_COUNTER32(sctps_aborted);\n\t\t\t\t\tif ((SCTP_GET_STATE(asoc) == SCTP_STATE_OPEN) ||\n\t\t\t\t\t    (SCTP_GET_STATE(asoc) == SCTP_STATE_SHUTDOWN_RECEIVED)) {\n\t\t\t\t\t\tSCTP_STAT_DECR_GAUGE32(sctps_currestab);\n\t\t\t\t\t}\n\t\t\t\t\tif (sctp_free_assoc(inp, asoc,\n\t\t\t\t\t\t\t    SCTP_PCBFREE_NOFORCE,\n\t\t\t\t\t\t\t    SCTP_FROM_SCTP_PCB + SCTP_LOC_6) == 0) {\n\t\t\t\t\t\tcnt_in_sd++;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tsctp_chunk_output(inp, asoc, SCTP_OUTPUT_FROM_CLOSING, SCTP_SO_LOCKED);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcnt_in_sd++;\n\t\t\tSCTP_TCB_UNLOCK(asoc);\n\t\t}\n\t\t/* now is there some left in our SHUTDOWN state? */\n\t\tif (cnt_in_sd) {\n#ifdef SCTP_LOG_CLOSING\n\t\t\tsctp_log_closing(inp, NULL, 2);\n#endif\n\t\t\tinp->sctp_socket = NULL;\n\t\t\tSCTP_INP_WUNLOCK(inp);\n\t\t\tSCTP_ASOC_CREATE_UNLOCK(inp);\n\t\t\tSCTP_INP_INFO_WUNLOCK();\n\t\t\treturn;\n\t\t}\n\t}\n\tinp->sctp_socket = NULL;\n\tif ((inp->sctp_flags & SCTP_PCB_FLAGS_UNBOUND) !=\n\t    SCTP_PCB_FLAGS_UNBOUND) {\n\t\t/*\n\t\t * ok, this guy has been bound. It's port is\n\t\t * somewhere in the SCTP_BASE_INFO(hash table). Remove\n\t\t * it!\n\t\t */\n\t\tLIST_REMOVE(inp, sctp_hash);\n\t\tinp->sctp_flags |= SCTP_PCB_FLAGS_UNBOUND;\n\t}\n\n\t/* If there is a timer running to kill us,\n\t * forget it, since it may have a contest\n\t * on the INP lock.. which would cause us\n\t * to die ...\n\t */\n\tcnt = 0;\n\tLIST_FOREACH_SAFE(asoc, &inp->sctp_asoc_list, sctp_tcblist, nasoc) {\n\t\tSCTP_TCB_LOCK(asoc);\n\t\tif (asoc->asoc.state & SCTP_STATE_ABOUT_TO_BE_FREED) {\n\t\t\tif (asoc->asoc.state & SCTP_STATE_IN_ACCEPT_QUEUE) {\n\t\t\t\tSCTP_CLEAR_SUBSTATE(asoc, SCTP_STATE_IN_ACCEPT_QUEUE);\n\t\t\t\tsctp_timer_start(SCTP_TIMER_TYPE_ASOCKILL, inp, asoc, NULL);\n\t\t\t}\n\t\t        cnt++;\n\t\t\tSCTP_TCB_UNLOCK(asoc);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Free associations that are NOT killing us */\n\t\tif ((SCTP_GET_STATE(asoc) != SCTP_STATE_COOKIE_WAIT) &&\n\t\t    ((asoc->asoc.state & SCTP_STATE_ABOUT_TO_BE_FREED) == 0)) {\n\t\t\tstruct mbuf *op_err;\n\n\t\t\top_err = sctp_generate_cause(SCTP_CAUSE_USER_INITIATED_ABT, \"\");\n\t\t\tasoc->sctp_ep->last_abort_code = SCTP_FROM_SCTP_PCB + SCTP_LOC_7;\n\t\t\tsctp_send_abort_tcb(asoc, op_err, SCTP_SO_LOCKED);\n\t\t\tSCTP_STAT_INCR_COUNTER32(sctps_aborted);\n\t\t} else if (asoc->asoc.state & SCTP_STATE_ABOUT_TO_BE_FREED) {\n\t\t\tcnt++;\n\t\t\tSCTP_TCB_UNLOCK(asoc);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((SCTP_GET_STATE(asoc) == SCTP_STATE_OPEN) ||\n\t\t    (SCTP_GET_STATE(asoc) == SCTP_STATE_SHUTDOWN_RECEIVED)) {\n\t\t\tSCTP_STAT_DECR_GAUGE32(sctps_currestab);\n\t\t}\n\t\tif (sctp_free_assoc(inp, asoc, SCTP_PCBFREE_FORCE,\n\t\t                    SCTP_FROM_SCTP_PCB + SCTP_LOC_8) == 0) {\n\t\t\tcnt++;\n\t\t}\n\t}\n\tif (cnt) {\n\t\t/* Ok we have someone out there that will kill us */\n\t\t(void)SCTP_OS_TIMER_STOP(&inp->sctp_ep.signature_change.timer);\n#ifdef SCTP_LOG_CLOSING\n\t\tsctp_log_closing(inp, NULL, 3);\n#endif\n\t\tSCTP_INP_WUNLOCK(inp);\n\t\tSCTP_ASOC_CREATE_UNLOCK(inp);\n\t\tSCTP_INP_INFO_WUNLOCK();\n\t\treturn;\n\t}\n\tif (SCTP_INP_LOCK_CONTENDED(inp))\n\t\tbeing_refed++;\n\tif (SCTP_INP_READ_CONTENDED(inp))\n\t\tbeing_refed++;\n\tif (SCTP_ASOC_CREATE_LOCK_CONTENDED(inp))\n\t\tbeing_refed++;\n\n\tif ((inp->refcount) ||\n\t    (being_refed) ||\n\t    (inp->sctp_flags & SCTP_PCB_FLAGS_CLOSE_IP)) {\n\t\t(void)SCTP_OS_TIMER_STOP(&inp->sctp_ep.signature_change.timer);\n#ifdef SCTP_LOG_CLOSING\n\t\tsctp_log_closing(inp, NULL, 4);\n#endif\n\t\tsctp_timer_start(SCTP_TIMER_TYPE_INPKILL, inp, NULL, NULL);\n\t\tSCTP_INP_WUNLOCK(inp);\n\t\tSCTP_ASOC_CREATE_UNLOCK(inp);\n\t\tSCTP_INP_INFO_WUNLOCK();\n\t\treturn;\n\t}\n\tinp->sctp_ep.signature_change.type = 0;\n\tinp->sctp_flags |= SCTP_PCB_FLAGS_SOCKET_ALLGONE;\n\t/* Remove it from the list .. last thing we need a\n\t * lock for.\n\t */\n\tLIST_REMOVE(inp, sctp_list);\n\tSCTP_INP_WUNLOCK(inp);\n\tSCTP_ASOC_CREATE_UNLOCK(inp);\n\tSCTP_INP_INFO_WUNLOCK();\n\t/* Now we release all locks. Since this INP\n\t * cannot be found anymore except possibly by the\n\t * kill timer that might be running. We call\n\t * the drain function here. It should hit the case\n\t * were it sees the ACTIVE flag cleared and exit\n\t * out freeing us to proceed and destroy everything.\n\t */\n\tif (from != SCTP_CALLED_FROM_INPKILL_TIMER) {\n\t\t(void)SCTP_OS_TIMER_STOP_DRAIN(&inp->sctp_ep.signature_change.timer);\n\t} else {\n\t\t/* Probably un-needed */\n\t\t(void)SCTP_OS_TIMER_STOP(&inp->sctp_ep.signature_change.timer);\n\t}\n\n#ifdef SCTP_LOG_CLOSING\n\tsctp_log_closing(inp, NULL, 5);\n#endif\n\n#if !(defined(__Panda__) || defined(__Windows__) || defined(__Userspace__))\n#if !defined(__FreeBSD__) || __FreeBSD_version < 500000\n\trt = ip_pcb->inp_route.ro_rt;\n#endif\n#endif\n\n\tif ((inp->sctp_asocidhash) != NULL) {\n\t\tSCTP_HASH_FREE(inp->sctp_asocidhash, inp->hashasocidmark);\n\t\tinp->sctp_asocidhash = NULL;\n\t}\n\t/*sa_ignore FREED_MEMORY*/\n\tTAILQ_FOREACH_SAFE(sq, &inp->read_queue, next, nsq) {\n\t\t/* Its only abandoned if it had data left */\n\t\tif (sq->length)\n\t\t\tSCTP_STAT_INCR(sctps_left_abandon);\n\n\t\tTAILQ_REMOVE(&inp->read_queue, sq, next);\n\t\tsctp_free_remote_addr(sq->whoFrom);\n\t\tif (so)\n\t\t\tso->so_rcv.sb_cc -= sq->length;\n\t\tif (sq->data) {\n\t\t\tsctp_m_freem(sq->data);\n\t\t\tsq->data = NULL;\n\t\t}\n\t\t/*\n\t\t * no need to free the net count, since at this point all\n\t\t * assoc's are gone.\n\t\t */\n\t\tsctp_free_a_readq(NULL, sq);\n\t}\n\t/* Now the sctp_pcb things */\n\t/*\n\t * free each asoc if it is not already closed/free. we can't use the\n\t * macro here since le_next will get freed as part of the\n\t * sctp_free_assoc() call.\n\t */\n#ifndef __Panda__\n\tif (ip_pcb->inp_options) {\n\t\t(void)sctp_m_free(ip_pcb->inp_options);\n\t\tip_pcb->inp_options = 0;\n\t}\n#endif\n\n#if !(defined(__Panda__) || defined(__Windows__) || defined(__Userspace__))\n#if !defined(__FreeBSD__) || __FreeBSD_version < 500000\n\tif (rt) {\n\t\tRTFREE(rt);\n\t\tip_pcb->inp_route.ro_rt = 0;\n\t}\n#endif\n#if defined(__FreeBSD__) && __FreeBSD_version < 803000\n#ifdef INET\n\tif (ip_pcb->inp_moptions) {\n\t\tinp_freemoptions(ip_pcb->inp_moptions);\n\t\tip_pcb->inp_moptions = 0;\n\t}\n#endif\n#endif\n#endif\n\n#ifdef INET6\n#if !(defined(__Panda__) || defined(__Windows__) || defined(__Userspace__))\n#if defined(__FreeBSD__) || defined(__APPLE__)\n\tif (ip_pcb->inp_vflag & INP_IPV6) {\n#else\n\tif (inp->inp_vflag & INP_IPV6) {\n#endif\n\t\tip6_freepcbopts(ip_pcb->in6p_outputopts);\n\t}\n#endif\n#endif\t\t\t\t/* INET6 */\n#if !(defined(__FreeBSD__) || defined(__APPLE__) || defined(__Windows__) || defined(__Userspace__))\n\tinp->inp_vflag = 0;\n#else\n\tip_pcb->inp_vflag = 0;\n#endif\n\t/* free up authentication fields */\n\tif (inp->sctp_ep.local_auth_chunks != NULL)\n\t\tsctp_free_chunklist(inp->sctp_ep.local_auth_chunks);\n\tif (inp->sctp_ep.local_hmacs != NULL)\n\t\tsctp_free_hmaclist(inp->sctp_ep.local_hmacs);\n\n\tLIST_FOREACH_SAFE(shared_key, &inp->sctp_ep.shared_keys, next, nshared_key) {\n\t\tLIST_REMOVE(shared_key, next);\n\t\tsctp_free_sharedkey(shared_key);\n\t\t/*sa_ignore FREED_MEMORY*/\n\t}\n\n#if defined(__APPLE__)\n\tinp->ip_inp.inp.inp_state = INPCB_STATE_DEAD;\n\tif (in_pcb_checkstate(&inp->ip_inp.inp, WNT_STOPUSING, 1) != WNT_STOPUSING) {\n#ifdef INVARIANTS\n\t\tpanic(\"sctp_inpcb_free inp = %p couldn't set to STOPUSING\\n\", (void *)inp);\n#else\n\t\tSCTP_PRINTF(\"sctp_inpcb_free inp = %p couldn't set to STOPUSING\\n\", (void *)inp);\n#endif\n\t}\n\tinp->ip_inp.inp.inp_socket->so_flags |= SOF_PCBCLEARING;\n#endif\n\t/*\n\t * if we have an address list the following will free the list of\n\t * ifaddr's that are set into this ep. Again macro limitations here,\n\t * since the LIST_FOREACH could be a bad idea.\n\t */\n\tLIST_FOREACH_SAFE(laddr, &inp->sctp_addr_list, sctp_nxt_addr, nladdr) {\n\t\tsctp_remove_laddr(laddr);\n\t}\n\n#ifdef SCTP_TRACK_FREED_ASOCS\n\t/* TEMP CODE */\n\tLIST_FOREACH_SAFE(asoc, &inp->sctp_asoc_free_list, sctp_tcblist, nasoc) {\n\t\tLIST_REMOVE(asoc, sctp_tcblist);\n\t\tSCTP_ZONE_FREE(SCTP_BASE_INFO(ipi_zone_asoc), asoc);\n\t\tSCTP_DECR_ASOC_COUNT();\n\t}\n\t/* *** END TEMP CODE ****/\n#endif\n#ifdef SCTP_MVRF\n\tSCTP_FREE(inp->m_vrf_ids, SCTP_M_MVRF);\n#endif\n\t/* Now lets see about freeing the EP hash table. */\n\tif (inp->sctp_tcbhash != NULL) {\n\t\tSCTP_HASH_FREE(inp->sctp_tcbhash, inp->sctp_hashmark);\n\t\tinp->sctp_tcbhash = NULL;\n\t}\n\t/* Now we must put the ep memory back into the zone pool */\n#if defined(__FreeBSD__)\n\tcrfree(inp->ip_inp.inp.inp_cred);\n\tINP_LOCK_DESTROY(&inp->ip_inp.inp);\n#endif\n\tSCTP_INP_LOCK_DESTROY(inp);\n\tSCTP_INP_READ_DESTROY(inp);\n\tSCTP_ASOC_CREATE_LOCK_DESTROY(inp);\n#if !defined(__APPLE__)\n\tSCTP_ZONE_FREE(SCTP_BASE_INFO(ipi_zone_ep), inp);\n\tSCTP_DECR_EP_COUNT();\n#else\n\t/* For Tiger, we will do this later... */\n#endif\n}\n\n\nstruct sctp_nets *\nsctp_findnet(struct sctp_tcb *stcb, struct sockaddr *addr)\n{\n\tstruct sctp_nets *net;\n\t/* locate the address */\n\tTAILQ_FOREACH(net, &stcb->asoc.nets, sctp_next) {\n\t\tif (sctp_cmpaddr(addr, (struct sockaddr *)&net->ro._l_addr))\n\t\t\treturn (net);\n\t}\n\treturn (NULL);\n}\n\n\nint\nsctp_is_address_on_local_host(struct sockaddr *addr, uint32_t vrf_id)\n{\n#ifdef __Panda__\n\treturn (0);\n#else\n\tstruct sctp_ifa *sctp_ifa;\n\tsctp_ifa = sctp_find_ifa_by_addr(addr, vrf_id, SCTP_ADDR_NOT_LOCKED);\n\tif (sctp_ifa) {\n\t\treturn (1);\n\t} else {\n\t\treturn (0);\n\t}\n#endif\n}\n\n/*\n * add's a remote endpoint address, done with the INIT/INIT-ACK as well as\n * when a ASCONF arrives that adds it. It will also initialize all the cwnd\n * stats of stuff.\n */\nint\nsctp_add_remote_addr(struct sctp_tcb *stcb, struct sockaddr *newaddr,\n    struct sctp_nets **netp, uint16_t port, int set_scope, int from)\n{\n\t/*\n\t * The following is redundant to the same lines in the\n\t * sctp_aloc_assoc() but is needed since others call the add\n\t * address function\n\t */\n\tstruct sctp_nets *net, *netfirst;\n\tint addr_inscope;\n\n\tSCTPDBG(SCTP_DEBUG_PCB1, \"Adding an address (from:%d) to the peer: \",\n\t\tfrom);\n\tSCTPDBG_ADDR(SCTP_DEBUG_PCB1, newaddr);\n\n\tnetfirst = sctp_findnet(stcb, newaddr);\n\tif (netfirst) {\n\t\t/*\n\t\t * Lie and return ok, we don't want to make the association\n\t\t * go away for this behavior. It will happen in the TCP\n\t\t * model in a connected socket. It does not reach the hash\n\t\t * table until after the association is built so it can't be\n\t\t * found. Mark as reachable, since the initial creation will\n\t\t * have been cleared and the NOT_IN_ASSOC flag will have\n\t\t * been added... and we don't want to end up removing it\n\t\t * back out.\n\t\t */\n\t\tif (netfirst->dest_state & SCTP_ADDR_UNCONFIRMED) {\n\t\t\tnetfirst->dest_state = (SCTP_ADDR_REACHABLE |\n\t\t\t    SCTP_ADDR_UNCONFIRMED);\n\t\t} else {\n\t\t\tnetfirst->dest_state = SCTP_ADDR_REACHABLE;\n\t\t}\n\n\t\treturn (0);\n\t}\n\taddr_inscope = 1;\n\tswitch (newaddr->sa_family) {\n#ifdef INET\n\tcase AF_INET:\n\t{\n\t\tstruct sockaddr_in *sin;\n\n\t\tsin = (struct sockaddr_in *)newaddr;\n\t\tif (sin->sin_addr.s_addr == 0) {\n\t\t\t/* Invalid address */\n\t\t\treturn (-1);\n\t\t}\n\t\t/* zero out the zero area */\n\t\tmemset(&sin->sin_zero, 0, sizeof(sin->sin_zero));\n\n\t\t/* assure len is set */\n#ifdef HAVE_SIN_LEN\n\t\tsin->sin_len = sizeof(struct sockaddr_in);\n#endif\n\t\tif (set_scope) {\n\t\t\tif (IN4_ISPRIVATE_ADDRESS(&sin->sin_addr)) {\n\t\t\t\tstcb->asoc.scope.ipv4_local_scope = 1;\n\t\t\t}\n\t\t} else {\n\t\t\t/* Validate the address is in scope */\n\t\t\tif ((IN4_ISPRIVATE_ADDRESS(&sin->sin_addr)) &&\n\t\t\t    (stcb->asoc.scope.ipv4_local_scope == 0)) {\n\t\t\t\taddr_inscope = 0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n#endif\n#ifdef INET6\n\tcase AF_INET6:\n\t{\n\t\tstruct sockaddr_in6 *sin6;\n\n\t\tsin6 = (struct sockaddr_in6 *)newaddr;\n\t\tif (IN6_IS_ADDR_UNSPECIFIED(&sin6->sin6_addr)) {\n\t\t\t/* Invalid address */\n\t\t\treturn (-1);\n\t\t}\n\t\t/* assure len is set */\n#ifdef HAVE_SIN6_LEN\n\t\tsin6->sin6_len = sizeof(struct sockaddr_in6);\n#endif\n\t\tif (set_scope) {\n\t\t\tif (sctp_is_address_on_local_host(newaddr, stcb->asoc.vrf_id)) {\n\t\t\t\tstcb->asoc.scope.loopback_scope = 1;\n\t\t\t\tstcb->asoc.scope.local_scope = 0;\n\t\t\t\tstcb->asoc.scope.ipv4_local_scope = 1;\n\t\t\t\tstcb->asoc.scope.site_scope = 1;\n\t\t\t} else if (IN6_IS_ADDR_LINKLOCAL(&sin6->sin6_addr)) {\n\t\t\t\t/*\n\t\t\t\t * If the new destination is a LINK_LOCAL we\n\t\t\t\t * must have common site scope. Don't set\n\t\t\t\t * the local scope since we may not share\n\t\t\t\t * all links, only loopback can do this.\n\t\t\t\t * Links on the local network would also be\n\t\t\t\t * on our private network for v4 too.\n\t\t\t\t */\n\t\t\t\tstcb->asoc.scope.ipv4_local_scope = 1;\n\t\t\t\tstcb->asoc.scope.site_scope = 1;\n\t\t\t} else if (IN6_IS_ADDR_SITELOCAL(&sin6->sin6_addr)) {\n\t\t\t\t/*\n\t\t\t\t * If the new destination is SITE_LOCAL then\n\t\t\t\t * we must have site scope in common.\n\t\t\t\t */\n\t\t\t\tstcb->asoc.scope.site_scope = 1;\n\t\t\t}\n\t\t} else {\n\t\t\t/* Validate the address is in scope */\n\t\t\tif (IN6_IS_ADDR_LOOPBACK(&sin6->sin6_addr) &&\n\t\t\t    (stcb->asoc.scope.loopback_scope == 0)) {\n\t\t\t\taddr_inscope = 0;\n\t\t\t} else if (IN6_IS_ADDR_LINKLOCAL(&sin6->sin6_addr) &&\n\t\t\t    (stcb->asoc.scope.local_scope == 0)) {\n\t\t\t\taddr_inscope = 0;\n\t\t\t} else if (IN6_IS_ADDR_SITELOCAL(&sin6->sin6_addr) &&\n\t\t\t    (stcb->asoc.scope.site_scope == 0)) {\n\t\t\t\taddr_inscope = 0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n#endif\n#if defined(__Userspace__)\n\tcase AF_CONN:\n\t{\n\t\tstruct sockaddr_conn *sconn;\n\n\t\tsconn = (struct sockaddr_conn *)newaddr;\n\t\tif (sconn->sconn_addr == NULL) {\n\t\t\t/* Invalid address */\n\t\t\treturn (-1);\n\t\t}\n#ifdef HAVE_SCONN_LEN\n\t\tsconn->sconn_len = sizeof(struct sockaddr_conn);\n#endif\n\t\tbreak;\n\t}\n#endif\n\tdefault:\n\t\t/* not supported family type */\n\t\treturn (-1);\n\t}\n\tnet = SCTP_ZONE_GET(SCTP_BASE_INFO(ipi_zone_net), struct sctp_nets);\n\tif (net == NULL) {\n\t\treturn (-1);\n\t}\n\tSCTP_INCR_RADDR_COUNT();\n\tmemset(net, 0, sizeof(struct sctp_nets));\n\t(void)SCTP_GETTIME_TIMEVAL(&net->start_time);\n#ifdef HAVE_SA_LEN\n\tmemcpy(&net->ro._l_addr, newaddr, newaddr->sa_len);\n#endif\n\tswitch (newaddr->sa_family) {\n#ifdef INET\n\tcase AF_INET:\n#ifndef HAVE_SA_LEN\n\t\tmemcpy(&net->ro._l_addr, newaddr, sizeof(struct sockaddr_in));\n#endif\n\t\t((struct sockaddr_in *)&net->ro._l_addr)->sin_port = stcb->rport;\n\t\tbreak;\n#endif\n#ifdef INET6\n\tcase AF_INET6:\n#ifndef HAVE_SA_LEN\n\t\tmemcpy(&net->ro._l_addr, newaddr, sizeof(struct sockaddr_in6));\n#endif\n\t\t((struct sockaddr_in6 *)&net->ro._l_addr)->sin6_port = stcb->rport;\n\t\tbreak;\n#endif\n#if defined(__Userspace__)\n\tcase AF_CONN:\n#ifndef HAVE_SA_LEN\n\t\tmemcpy(&net->ro._l_addr, newaddr, sizeof(struct sockaddr_conn));\n#endif\n\t\t((struct sockaddr_conn *)&net->ro._l_addr)->sconn_port = stcb->rport;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\tnet->addr_is_local = sctp_is_address_on_local_host(newaddr, stcb->asoc.vrf_id);\n\tif (net->addr_is_local && ((set_scope || (from == SCTP_ADDR_IS_CONFIRMED)))) {\n\t\tstcb->asoc.scope.loopback_scope = 1;\n\t\tstcb->asoc.scope.ipv4_local_scope = 1;\n\t\tstcb->asoc.scope.local_scope = 0;\n\t\tstcb->asoc.scope.site_scope = 1;\n\t\taddr_inscope = 1;\n\t}\n\tnet->failure_threshold = stcb->asoc.def_net_failure;\n\tnet->pf_threshold = stcb->asoc.def_net_pf_threshold;\n\tif (addr_inscope == 0) {\n\t\tnet->dest_state = (SCTP_ADDR_REACHABLE |\n\t\t    SCTP_ADDR_OUT_OF_SCOPE);\n\t} else {\n\t\tif (from == SCTP_ADDR_IS_CONFIRMED)\n\t\t\t/* SCTP_ADDR_IS_CONFIRMED is passed by connect_x */\n\t\t\tnet->dest_state = SCTP_ADDR_REACHABLE;\n\t\telse\n\t\t\tnet->dest_state = SCTP_ADDR_REACHABLE |\n\t\t\t    SCTP_ADDR_UNCONFIRMED;\n\t}\n\t/* We set this to 0, the timer code knows that\n\t * this means its an initial value\n\t */\n\tnet->rto_needed = 1;\n\tnet->RTO = 0;\n\tnet->RTO_measured = 0;\n\tstcb->asoc.numnets++;\n\tnet->ref_count = 1;\n\tnet->cwr_window_tsn = net->last_cwr_tsn = stcb->asoc.sending_seq - 1;\n\tnet->port = port;\n\tnet->dscp = stcb->asoc.default_dscp;\n#ifdef INET6\n\tnet->flowlabel = stcb->asoc.default_flowlabel;\n#endif\n\tif (sctp_stcb_is_feature_on(stcb->sctp_ep, stcb, SCTP_PCB_FLAGS_DONOT_HEARTBEAT)) {\n\t\tnet->dest_state |= SCTP_ADDR_NOHB;\n\t} else {\n\t\tnet->dest_state &= ~SCTP_ADDR_NOHB;\n\t}\n\tif (sctp_stcb_is_feature_on(stcb->sctp_ep, stcb, SCTP_PCB_FLAGS_DO_NOT_PMTUD)) {\n\t\tnet->dest_state |= SCTP_ADDR_NO_PMTUD;\n\t} else {\n\t\tnet->dest_state &= ~SCTP_ADDR_NO_PMTUD;\n\t}\n\tnet->heart_beat_delay = stcb->asoc.heart_beat_delay;\n\t/* Init the timer structure */\n\tSCTP_OS_TIMER_INIT(&net->rxt_timer.timer);\n\tSCTP_OS_TIMER_INIT(&net->pmtu_timer.timer);\n\tSCTP_OS_TIMER_INIT(&net->hb_timer.timer);\n\n\t/* Now generate a route for this guy */\n#ifdef INET6\n#ifdef SCTP_EMBEDDED_V6_SCOPE\n\t/* KAME hack: embed scopeid */\n\tif (newaddr->sa_family == AF_INET6) {\n\t\tstruct sockaddr_in6 *sin6;\n\n\t\tsin6 = (struct sockaddr_in6 *)&net->ro._l_addr;\n#if defined(__APPLE__)\n#if defined(APPLE_LEOPARD) || defined(APPLE_SNOWLEOPARD)\n\t\t(void)in6_embedscope(&sin6->sin6_addr, sin6, &stcb->sctp_ep->ip_inp.inp, NULL);\n#else\n\t\t(void)in6_embedscope(&sin6->sin6_addr, sin6, &stcb->sctp_ep->ip_inp.inp, NULL, NULL);\n#endif\n#elif defined(SCTP_KAME)\n\t\t(void)sa6_embedscope(sin6, MODULE_GLOBAL(ip6_use_defzone));\n#else\n\t\t(void)in6_embedscope(&sin6->sin6_addr, sin6);\n#endif\n#ifndef SCOPEDROUTING\n\t\tsin6->sin6_scope_id = 0;\n#endif\n\t}\n#endif /* SCTP_EMBEDDED_V6_SCOPE */\n#endif\n\tSCTP_RTALLOC((sctp_route_t *)&net->ro,\n\t             stcb->asoc.vrf_id,\n\t             stcb->sctp_ep->fibnum);\n\n\tnet->src_addr_selected = 0;\n#if !defined(__Userspace__)\n\tif (SCTP_ROUTE_HAS_VALID_IFN(&net->ro)) {\n\t\t/* Get source address */\n\t\tnet->ro._s_addr = sctp_source_address_selection(stcb->sctp_ep,\n\t\t                                                stcb,\n\t\t                                                (sctp_route_t *)&net->ro,\n\t\t                                                net,\n\t\t                                                0,\n\t\t                                                stcb->asoc.vrf_id);\n\t\tif (stcb->asoc.default_mtu > 0) {\n\t\t\tnet->mtu = stcb->asoc.default_mtu;\n\t\t\tswitch (net->ro._l_addr.sa.sa_family) {\n#ifdef INET\n\t\t\tcase AF_INET:\n\t\t\t\tnet->mtu += SCTP_MIN_V4_OVERHEAD;\n\t\t\t\tbreak;\n#endif\n#ifdef INET6\n\t\t\tcase AF_INET6:\n\t\t\t\tnet->mtu += SCTP_MIN_OVERHEAD;\n\t\t\t\tbreak;\n#endif\n#if defined(__Userspace__)\n\t\t\tcase AF_CONN:\n\t\t\t\tnet->mtu += sizeof(struct sctphdr);\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n#if defined(INET) || defined(INET6)\n\t\t\tif (net->port) {\n\t\t\t\tnet->mtu += (uint32_t)sizeof(struct udphdr);\n\t\t\t}\n#endif\n\t\t} else if (net->ro._s_addr != NULL) {\n\t\t\tuint32_t imtu, rmtu, hcmtu;\n\n\t\t\tnet->src_addr_selected = 1;\n\t\t\t/* Now get the interface MTU */\n\t\t\tif (net->ro._s_addr->ifn_p != NULL) {\n\t\t\t\timtu = SCTP_GATHER_MTU_FROM_INTFC(net->ro._s_addr->ifn_p);\n\t\t\t} else {\n\t\t\t\timtu = 0;\n\t\t\t}\n\t\t\trmtu = SCTP_GATHER_MTU_FROM_ROUTE(net->ro._s_addr, &net->ro._l_addr.sa, net->ro.ro_rt);\n#if defined(__FreeBSD__)\n\t\t\thcmtu = sctp_hc_get_mtu(&net->ro._l_addr, stcb->sctp_ep->fibnum);\n#else\n\t\t\thcmtu = 0;\n#endif\n\t\t\tnet->mtu = sctp_min_mtu(hcmtu, rmtu, imtu);\n\t\t\tif (rmtu == 0) {\n\t\t\t\t/* Start things off to match mtu of interface please. */\n\t\t\t\tSCTP_SET_MTU_OF_ROUTE(&net->ro._l_addr.sa,\n\t\t\t\t                      net->ro.ro_rt, net->mtu);\n\t\t\t}\n\t\t}\n\t}\n#endif\n\tif (net->mtu == 0) {\n\t\tif (stcb->asoc.default_mtu > 0) {\n\t\t\tnet->mtu = stcb->asoc.default_mtu;\n\t\t\tswitch (net->ro._l_addr.sa.sa_family) {\n#ifdef INET\n\t\t\tcase AF_INET:\n\t\t\t\tnet->mtu += SCTP_MIN_V4_OVERHEAD;\n\t\t\t\tbreak;\n#endif\n#ifdef INET6\n\t\t\tcase AF_INET6:\n\t\t\t\tnet->mtu += SCTP_MIN_OVERHEAD;\n\t\t\t\tbreak;\n#endif\n#if defined(__Userspace__)\n\t\t\tcase AF_CONN:\n\t\t\t\tnet->mtu += sizeof(struct sctphdr);\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n#if defined(INET) || defined(INET6)\n\t\t\tif (net->port) {\n\t\t\t\tnet->mtu += (uint32_t)sizeof(struct udphdr);\n\t\t\t}\n#endif\n\t\t} else {\n\t\t\tswitch (newaddr->sa_family) {\n#ifdef INET\n\t\t\tcase AF_INET:\n\t\t\t\tnet->mtu = SCTP_DEFAULT_MTU;\n\t\t\t\tbreak;\n#endif\n#ifdef INET6\n\t\t\tcase AF_INET6:\n\t\t\t\tnet->mtu = 1280;\n\t\t\t\tbreak;\n#endif\n#if defined(__Userspace__)\n\t\t\tcase AF_CONN:\n\t\t\t\tnet->mtu = 1280;\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n#if defined(INET) || defined(INET6)\n\tif (net->port) {\n\t\tnet->mtu -= (uint32_t)sizeof(struct udphdr);\n\t}\n#endif\n\tif (from == SCTP_ALLOC_ASOC) {\n\t\tstcb->asoc.smallest_mtu = net->mtu;\n\t}\n\tif (stcb->asoc.smallest_mtu > net->mtu) {\n\t\tsctp_pathmtu_adjustment(stcb, net->mtu);\n\t}\n#ifdef INET6\n#ifdef SCTP_EMBEDDED_V6_SCOPE\n\tif (newaddr->sa_family == AF_INET6) {\n\t\tstruct sockaddr_in6 *sin6;\n\n\t\tsin6 = (struct sockaddr_in6 *)&net->ro._l_addr;\n#ifdef SCTP_KAME\n\t\t(void)sa6_recoverscope(sin6);\n#else\n\t\t(void)in6_recoverscope(sin6, &sin6->sin6_addr, NULL);\n#endif /* SCTP_KAME */\n\t}\n#endif /* SCTP_EMBEDDED_V6_SCOPE */\n#endif\n\n\t/* JRS - Use the congestion control given in the CC module */\n\tif (stcb->asoc.cc_functions.sctp_set_initial_cc_param != NULL)\n\t\t(*stcb->asoc.cc_functions.sctp_set_initial_cc_param)(stcb, net);\n\n\t/*\n\t * CMT: CUC algo - set find_pseudo_cumack to TRUE (1) at beginning\n\t * of assoc (2005/06/27, iyengar@cis.udel.edu)\n\t */\n\tnet->find_pseudo_cumack = 1;\n\tnet->find_rtx_pseudo_cumack = 1;\n#if defined(__FreeBSD__)\n\t/* Choose an initial flowid. */\n\tnet->flowid = stcb->asoc.my_vtag ^\n\t              ntohs(stcb->rport) ^\n\t              ntohs(stcb->sctp_ep->sctp_lport);\n\tnet->flowtype = M_HASHTYPE_OPAQUE_HASH;\n#endif\n\tif (netp) {\n\t\t*netp = net;\n\t}\n\tnetfirst = TAILQ_FIRST(&stcb->asoc.nets);\n\tif (net->ro.ro_rt == NULL) {\n\t\t/* Since we have no route put it at the back */\n\t\tTAILQ_INSERT_TAIL(&stcb->asoc.nets, net, sctp_next);\n\t} else if (netfirst == NULL) {\n\t\t/* We are the first one in the pool. */\n\t\tTAILQ_INSERT_HEAD(&stcb->asoc.nets, net, sctp_next);\n\t} else if (netfirst->ro.ro_rt == NULL) {\n\t\t/*\n\t\t * First one has NO route. Place this one ahead of the first\n\t\t * one.\n\t\t */\n\t\tTAILQ_INSERT_HEAD(&stcb->asoc.nets, net, sctp_next);\n#ifndef __Panda__\n\t} else if (net->ro.ro_rt->rt_ifp != netfirst->ro.ro_rt->rt_ifp) {\n\t\t/*\n\t\t * This one has a different interface than the one at the\n\t\t * top of the list. Place it ahead.\n\t\t */\n\t\tTAILQ_INSERT_HEAD(&stcb->asoc.nets, net, sctp_next);\n#endif\n\t} else {\n\t\t/*\n\t\t * Ok we have the same interface as the first one. Move\n\t\t * forward until we find either a) one with a NULL route...\n\t\t * insert ahead of that b) one with a different ifp.. insert\n\t\t * after that. c) end of the list.. insert at the tail.\n\t\t */\n\t\tstruct sctp_nets *netlook;\n\n\t\tdo {\n\t\t\tnetlook = TAILQ_NEXT(netfirst, sctp_next);\n\t\t\tif (netlook == NULL) {\n\t\t\t\t/* End of the list */\n\t\t\t\tTAILQ_INSERT_TAIL(&stcb->asoc.nets, net, sctp_next);\n\t\t\t\tbreak;\n\t\t\t} else if (netlook->ro.ro_rt == NULL) {\n\t\t\t\t/* next one has NO route */\n\t\t\t\tTAILQ_INSERT_BEFORE(netfirst, net, sctp_next);\n\t\t\t\tbreak;\n\t\t\t}\n#ifndef __Panda__\n\t\t\telse if (netlook->ro.ro_rt->rt_ifp != net->ro.ro_rt->rt_ifp)\n#else\n\t\t\telse\n#endif\n\t\t\t{\n\t\t\t\tTAILQ_INSERT_AFTER(&stcb->asoc.nets, netlook,\n\t\t\t\t\t\t   net, sctp_next);\n\t\t\t\tbreak;\n\t\t\t}\n#ifndef __Panda__\n\t\t\t/* Shift forward */\n\t\t\tnetfirst = netlook;\n#endif\n\t\t} while (netlook != NULL);\n\t}\n\n\t/* got to have a primary set */\n\tif (stcb->asoc.primary_destination == 0) {\n\t\tstcb->asoc.primary_destination = net;\n\t} else if ((stcb->asoc.primary_destination->ro.ro_rt == NULL) &&\n\t\t    (net->ro.ro_rt) &&\n\t    ((net->dest_state & SCTP_ADDR_UNCONFIRMED) == 0)) {\n\t\t/* No route to current primary adopt new primary */\n\t\tstcb->asoc.primary_destination = net;\n\t}\n\t/* Validate primary is first */\n\tnet = TAILQ_FIRST(&stcb->asoc.nets);\n\tif ((net != stcb->asoc.primary_destination) &&\n\t    (stcb->asoc.primary_destination)) {\n\t\t/* first one on the list is NOT the primary\n\t\t * sctp_cmpaddr() is much more efficient if\n\t\t * the primary is the first on the list, make it\n\t\t * so.\n\t\t */\n\t\tTAILQ_REMOVE(&stcb->asoc.nets,\n\t\t\t     stcb->asoc.primary_destination, sctp_next);\n\t\tTAILQ_INSERT_HEAD(&stcb->asoc.nets,\n\t\t\t\t  stcb->asoc.primary_destination, sctp_next);\n\t}\n\treturn (0);\n}\n\n\nstatic uint32_t\nsctp_aloc_a_assoc_id(struct sctp_inpcb *inp, struct sctp_tcb *stcb)\n{\n\tuint32_t id;\n\tstruct sctpasochead *head;\n\tstruct sctp_tcb *lstcb;\n\n try_again:\n\tif (inp->sctp_flags & SCTP_PCB_FLAGS_SOCKET_ALLGONE) {\n\t\t/* TSNH */\n\t\treturn (0);\n\t}\n\t/*\n\t * We don't allow assoc id to be one of SCTP_FUTURE_ASSOC,\n\t * SCTP_CURRENT_ASSOC and SCTP_ALL_ASSOC.\n\t */\n\tif (inp->sctp_associd_counter <= SCTP_ALL_ASSOC) {\n\t\tinp->sctp_associd_counter = SCTP_ALL_ASSOC + 1;\n\t}\n\tid = inp->sctp_associd_counter;\n\tinp->sctp_associd_counter++;\n\tlstcb = sctp_findasoc_ep_asocid_locked(inp, (sctp_assoc_t)id, 0);\n\tif (lstcb) {\n\t\tgoto try_again;\n\t}\n\thead = &inp->sctp_asocidhash[SCTP_PCBHASH_ASOC(id, inp->hashasocidmark)];\n\tLIST_INSERT_HEAD(head, stcb, sctp_tcbasocidhash);\n\tstcb->asoc.in_asocid_hash = 1;\n\treturn (id);\n}\n\n/*\n * allocate an association and add it to the endpoint. The caller must be\n * careful to add all additional addresses once they are know right away or\n * else the assoc will be may experience a blackout scenario.\n */\nstruct sctp_tcb *\nsctp_aloc_assoc(struct sctp_inpcb *inp, struct sockaddr *firstaddr,\n                int *error, uint32_t override_tag, uint32_t vrf_id,\n                uint16_t o_streams, uint16_t port,\n#if defined(__FreeBSD__) && __FreeBSD_version >= 500000\n                struct thread *p,\n#elif defined(__Windows__)\n                PKTHREAD p,\n#else\n#if defined(__Userspace__)\n                /*  __Userspace__ NULL proc is going to be passed here. See sctp_lower_sosend */\n#endif\n                struct proc *p,\n#endif\n                int initialize_auth_params)\n{\n\t/* note the p argument is only valid in unbound sockets */\n\n\tstruct sctp_tcb *stcb;\n\tstruct sctp_association *asoc;\n\tstruct sctpasochead *head;\n\tuint16_t rport;\n\tint err;\n\n\t/*\n\t * Assumption made here: Caller has done a\n\t * sctp_findassociation_ep_addr(ep, addr's); to make sure the\n\t * address does not exist already.\n\t */\n\tif (SCTP_BASE_INFO(ipi_count_asoc) >= SCTP_MAX_NUM_OF_ASOC) {\n\t\t/* Hit max assoc, sorry no more */\n\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, ENOBUFS);\n\t\t*error = ENOBUFS;\n\t\treturn (NULL);\n\t}\n\tif (firstaddr == NULL) {\n\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, EINVAL);\n\t\t*error = EINVAL;\n\t\treturn (NULL);\n\t}\n\tSCTP_INP_RLOCK(inp);\n\tif ((inp->sctp_flags & SCTP_PCB_FLAGS_IN_TCPPOOL) &&\n\t    ((sctp_is_feature_off(inp, SCTP_PCB_FLAGS_PORTREUSE)) ||\n\t     (inp->sctp_flags & SCTP_PCB_FLAGS_CONNECTED))) {\n\t\t/*\n\t\t * If its in the TCP pool, its NOT allowed to create an\n\t\t * association. The parent listener needs to call\n\t\t * sctp_aloc_assoc.. or the one-2-many socket. If a peeled\n\t\t * off, or connected one does this.. its an error.\n\t\t */\n\t\tSCTP_INP_RUNLOCK(inp);\n\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, EINVAL);\n\t\t*error = EINVAL;\n\t\treturn (NULL);\n\t}\n\tif ((inp->sctp_flags & SCTP_PCB_FLAGS_IN_TCPPOOL) ||\n\t    (inp->sctp_flags & SCTP_PCB_FLAGS_TCPTYPE)) {\n\t\tif ((inp->sctp_flags & SCTP_PCB_FLAGS_WAS_CONNECTED) ||\n\t\t    (inp->sctp_flags & SCTP_PCB_FLAGS_WAS_ABORTED)) {\n\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, EINVAL);\n\t\t\t*error = EINVAL;\n\t\t\treturn (NULL);\n\t\t}\n\t}\n\tSCTPDBG(SCTP_DEBUG_PCB3, \"Allocate an association for peer:\");\n#ifdef SCTP_DEBUG\n\tif (firstaddr) {\n\t\tSCTPDBG_ADDR(SCTP_DEBUG_PCB3, firstaddr);\n\t\tswitch (firstaddr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tSCTPDBG(SCTP_DEBUG_PCB3, \"Port:%d\\n\",\n\t\t\t        ntohs(((struct sockaddr_in *)firstaddr)->sin_port));\n\t\t\tbreak;\n#endif\n#ifdef INET6\n\t\tcase AF_INET6:\n\t\t\tSCTPDBG(SCTP_DEBUG_PCB3, \"Port:%d\\n\",\n\t\t\t        ntohs(((struct sockaddr_in6 *)firstaddr)->sin6_port));\n\t\t\tbreak;\n#endif\n#if defined(__Userspace__)\n\t\tcase AF_CONN:\n\t\t\tSCTPDBG(SCTP_DEBUG_PCB3, \"Port:%d\\n\",\n\t\t\t        ntohs(((struct sockaddr_conn *)firstaddr)->sconn_port));\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tSCTPDBG(SCTP_DEBUG_PCB3,\"None\\n\");\n\t}\n#endif\t\t\t\t/* SCTP_DEBUG */\n\tswitch (firstaddr->sa_family) {\n#ifdef INET\n\tcase AF_INET:\n\t{\n\t\tstruct sockaddr_in *sin;\n\n\t\tsin = (struct sockaddr_in *)firstaddr;\n\t\tif ((ntohs(sin->sin_port) == 0) ||\n\t\t    (sin->sin_addr.s_addr == INADDR_ANY) ||\n\t\t    (sin->sin_addr.s_addr == INADDR_BROADCAST) ||\n\t\t    IN_MULTICAST(ntohl(sin->sin_addr.s_addr))) {\n\t\t\t/* Invalid address */\n\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, EINVAL);\n\t\t\t*error = EINVAL;\n\t\t\treturn (NULL);\n\t\t}\n\t\trport = sin->sin_port;\n\t\tbreak;\n\t}\n#endif\n#ifdef INET6\n\tcase AF_INET6:\n\t{\n\t\tstruct sockaddr_in6 *sin6;\n\n\t\tsin6 = (struct sockaddr_in6 *)firstaddr;\n\t\tif ((ntohs(sin6->sin6_port) == 0) ||\n\t\t    IN6_IS_ADDR_UNSPECIFIED(&sin6->sin6_addr) ||\n\t\t    IN6_IS_ADDR_MULTICAST(&sin6->sin6_addr)) {\n\t\t\t/* Invalid address */\n\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, EINVAL);\n\t\t\t*error = EINVAL;\n\t\t\treturn (NULL);\n\t\t}\n\t\trport = sin6->sin6_port;\n\t\tbreak;\n\t}\n#endif\n#if defined(__Userspace__)\n\tcase AF_CONN:\n\t{\n\t\tstruct sockaddr_conn *sconn;\n\n\t\tsconn = (struct sockaddr_conn *)firstaddr;\n\t\tif ((ntohs(sconn->sconn_port) == 0) ||\n\t\t    (sconn->sconn_addr == NULL)) {\n\t\t\t/* Invalid address */\n\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, EINVAL);\n\t\t\t*error = EINVAL;\n\t\t\treturn (NULL);\n\t\t}\n\t\trport = sconn->sconn_port;\n\t\tbreak;\n\t}\n#endif\n\tdefault:\n\t\t/* not supported family type */\n\t\tSCTP_INP_RUNLOCK(inp);\n\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, EINVAL);\n\t\t*error = EINVAL;\n\t\treturn (NULL);\n\t}\n\tSCTP_INP_RUNLOCK(inp);\n\tif (inp->sctp_flags & SCTP_PCB_FLAGS_UNBOUND) {\n\t\t/*\n\t\t * If you have not performed a bind, then we need to do the\n\t\t * ephemeral bind for you.\n\t\t */\n\t\tif ((err = sctp_inpcb_bind(inp->sctp_socket,\n\t\t    (struct sockaddr *)NULL,\n\t\t    (struct sctp_ifa *)NULL,\n#ifndef __Panda__\n\t\t\t\t\t   p\n#else\n\t\t\t\t\t   (struct proc *)NULL\n#endif\n\t\t    ))) {\n\t\t\t/* bind error, probably perm */\n\t\t\t*error = err;\n\t\t\treturn (NULL);\n\t\t}\n\t}\n\tstcb = SCTP_ZONE_GET(SCTP_BASE_INFO(ipi_zone_asoc), struct sctp_tcb);\n\tif (stcb == NULL) {\n\t\t/* out of memory? */\n\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, ENOMEM);\n\t\t*error = ENOMEM;\n\t\treturn (NULL);\n\t}\n\tSCTP_INCR_ASOC_COUNT();\n\n\tmemset(stcb, 0, sizeof(*stcb));\n\tasoc = &stcb->asoc;\n\n\tSCTP_TCB_LOCK_INIT(stcb);\n\tSCTP_TCB_SEND_LOCK_INIT(stcb);\n\tstcb->rport = rport;\n\t/* setup back pointer's */\n\tstcb->sctp_ep = inp;\n\tstcb->sctp_socket = inp->sctp_socket;\n\tif ((err = sctp_init_asoc(inp, stcb, override_tag, vrf_id, o_streams))) {\n\t\t/* failed */\n\t\tSCTP_TCB_LOCK_DESTROY(stcb);\n\t\tSCTP_TCB_SEND_LOCK_DESTROY(stcb);\n\t\tSCTP_ZONE_FREE(SCTP_BASE_INFO(ipi_zone_asoc), stcb);\n\t\tSCTP_DECR_ASOC_COUNT();\n\t\t*error = err;\n\t\treturn (NULL);\n\t}\n\t/* and the port */\n\tSCTP_INP_INFO_WLOCK();\n\tSCTP_INP_WLOCK(inp);\n\tif (inp->sctp_flags & (SCTP_PCB_FLAGS_SOCKET_GONE | SCTP_PCB_FLAGS_SOCKET_ALLGONE)) {\n\t\t/* inpcb freed while alloc going on */\n\t\tSCTP_TCB_LOCK_DESTROY(stcb);\n\t\tSCTP_TCB_SEND_LOCK_DESTROY(stcb);\n\t\tSCTP_ZONE_FREE(SCTP_BASE_INFO(ipi_zone_asoc), stcb);\n\t\tSCTP_INP_WUNLOCK(inp);\n\t\tSCTP_INP_INFO_WUNLOCK();\n\t\tSCTP_DECR_ASOC_COUNT();\n\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, EINVAL);\n\t\t*error = EINVAL;\n\t\treturn (NULL);\n\t}\n\tSCTP_TCB_LOCK(stcb);\n\n\tasoc->assoc_id = sctp_aloc_a_assoc_id(inp, stcb);\n\t/* now that my_vtag is set, add it to the hash */\n\thead = &SCTP_BASE_INFO(sctp_asochash)[SCTP_PCBHASH_ASOC(stcb->asoc.my_vtag, SCTP_BASE_INFO(hashasocmark))];\n\t/* put it in the bucket in the vtag hash of assoc's for the system */\n\tLIST_INSERT_HEAD(head, stcb, sctp_asocs);\n\tSCTP_INP_INFO_WUNLOCK();\n\n\tif ((err = sctp_add_remote_addr(stcb, firstaddr, NULL, port, SCTP_DO_SETSCOPE, SCTP_ALLOC_ASOC))) {\n\t\t/* failure.. memory error? */\n\t\tif (asoc->strmout) {\n\t\t\tSCTP_FREE(asoc->strmout, SCTP_M_STRMO);\n\t\t\tasoc->strmout = NULL;\n\t\t}\n\t\tif (asoc->mapping_array) {\n\t\t\tSCTP_FREE(asoc->mapping_array, SCTP_M_MAP);\n\t\t\tasoc->mapping_array = NULL;\n\t\t}\n\t\tif (asoc->nr_mapping_array) {\n\t\t\tSCTP_FREE(asoc->nr_mapping_array, SCTP_M_MAP);\n\t\t\tasoc->nr_mapping_array = NULL;\n\t\t}\n\t\tSCTP_DECR_ASOC_COUNT();\n\t\tSCTP_TCB_UNLOCK(stcb);\n\t\tSCTP_TCB_LOCK_DESTROY(stcb);\n\t\tSCTP_TCB_SEND_LOCK_DESTROY(stcb);\n\t\tLIST_REMOVE(stcb, sctp_tcbasocidhash);\n\t\tSCTP_ZONE_FREE(SCTP_BASE_INFO(ipi_zone_asoc), stcb);\n\t\tSCTP_INP_WUNLOCK(inp);\n\t\tSCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, ENOBUFS);\n\t\t*error = ENOBUFS;\n\t\treturn (NULL);\n\t}\n\t/* Init all the timers */\n\tSCTP_OS_TIMER_INIT(&asoc->dack_timer.timer);\n\tSCTP_OS_TIMER_INIT(&asoc->strreset_timer.timer);\n\tSCTP_OS_TIMER_INIT(&asoc->asconf_timer.timer);\n\tSCTP_OS_TIMER_INIT(&asoc->shut_guard_timer.timer);\n\tSCTP_OS_TIMER_INIT(&asoc->autoclose_timer.timer);\n\tSCTP_OS_TIMER_INIT(&asoc->delayed_event_timer.timer);\n\tSCTP_OS_TIMER_INIT(&asoc->delete_prim_timer.timer);\n\n\tLIST_INSERT_HEAD(&inp->sctp_asoc_list, stcb, sctp_tcblist);\n\t/* now file the port under the hash as well */\n\tif (inp->sctp_tcbhash != NULL) {\n\t\thead = &inp->sctp_tcbhash[SCTP_PCBHASH_ALLADDR(stcb->rport,\n\t\t    inp->sctp_hashmark)];\n\t\tLIST_INSERT_HEAD(head, stcb, sctp_tcbhash);\n\t}\n\tif (initialize_auth_params == SCTP_INITIALIZE_AUTH_PARAMS) {\n\t\tsctp_initialize_auth_params(inp, stcb);\n\t}\n\tSCTP_INP_WUNLOCK(inp);\n\tSCTPDBG(SCTP_DEBUG_PCB1, \"Association %p now allocated\\n\", (void *)stcb);\n\treturn (stcb);\n}\n\n\nvoid\nsctp_remove_net(struct sctp_tcb *stcb, struct sctp_nets *net)\n{\n\tstruct sctp_association *asoc;\n\n\tasoc = &stcb->asoc;\n\tasoc->numnets--;\n\tTAILQ_REMOVE(&asoc->nets, net, sctp_next);\n\tif (net == asoc->primary_destination) {\n\t\t/* Reset primary */\n\t\tstruct sctp_nets *lnet;\n\n\t\tlnet = TAILQ_FIRST(&asoc->nets);\n\t\t/* Mobility adaptation\n\t\t   Ideally, if deleted destination is the primary, it becomes\n\t\t   a fast retransmission trigger by the subsequent SET PRIMARY.\n\t\t   (by micchie)\n\t\t */\n\t\tif (sctp_is_mobility_feature_on(stcb->sctp_ep,\n\t\t                                SCTP_MOBILITY_BASE) ||\n\t\t    sctp_is_mobility_feature_on(stcb->sctp_ep,\n\t\t                                SCTP_MOBILITY_FASTHANDOFF)) {\n\t\t\tSCTPDBG(SCTP_DEBUG_ASCONF1, \"remove_net: primary dst is deleting\\n\");\n\t\t\tif (asoc->deleted_primary != NULL) {\n\t\t\t\tSCTPDBG(SCTP_DEBUG_ASCONF1, \"remove_net: deleted primary may be already stored\\n\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tasoc->deleted_primary = net;\n\t\t\tatomic_add_int(&net->ref_count, 1);\n\t\t\tmemset(&net->lastsa, 0, sizeof(net->lastsa));\n\t\t\tmemset(&net->lastsv, 0, sizeof(net->lastsv));\n\t\t\tsctp_mobility_feature_on(stcb->sctp_ep,\n\t\t\t\t\t\t SCTP_MOBILITY_PRIM_DELETED);\n\t\t\tsctp_timer_start(SCTP_TIMER_TYPE_PRIM_DELETED,\n\t\t\t\t\t stcb->sctp_ep, stcb, NULL);\n\t\t}\nout:\n\t\t/* Try to find a confirmed primary */\n\t\tasoc->primary_destination = sctp_find_alternate_net(stcb, lnet, 0);\n\t}\n\tif (net == asoc->last_data_chunk_from) {\n\t\t/* Reset primary */\n\t\tasoc->last_data_chunk_from = TAILQ_FIRST(&asoc->nets);\n\t}\n\tif (net == asoc->last_control_chunk_from) {\n\t\t/* Clear net */\n\t\tasoc->last_control_chunk_from = NULL;\n\t}\n\tif (net == stcb->asoc.alternate) {\n\t\tsctp_free_remote_addr(stcb->asoc.alternate);\n\t\tstcb->asoc.alternate = NULL;\n\t}\n\tsctp_free_remote_addr(net);\n}\n\n/*\n * remove a remote endpoint address from an association, it will fail if the\n * address does not exist.\n */\nint\nsctp_del_remote_addr(struct sctp_tcb *stcb, struct sockaddr *remaddr)\n{\n\t/*\n\t * Here we need to remove a remote address. This is quite simple, we\n\t * first find it in the list of address for the association\n\t * (tasoc->asoc.nets) and then if it is there, we do a LIST_REMOVE\n\t * on that item. Note we do not allow it to be removed if there are\n\t * no other addresses.\n\t */\n\tstruct sctp_association *asoc;\n\tstruct sctp_nets *net, *nnet;\n\n\tasoc = &stcb->asoc;\n\n\t/* locate the address */\n\tTAILQ_FOREACH_SAFE(net, &asoc->nets, sctp_next, nnet) {\n\t\tif (net->ro._l_addr.sa.sa_family != remaddr->sa_family) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (sctp_cmpaddr((struct sockaddr *)&net->ro._l_addr,\n\t\t    remaddr)) {\n\t\t\t/* we found the guy */\n\t\t\tif (asoc->numnets < 2) {\n\t\t\t\t/* Must have at LEAST two remote addresses */\n\t\t\t\treturn (-1);\n\t\t\t} else {\n\t\t\t\tsctp_remove_net(stcb, net);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t}\n\t}\n\t/* not found. */\n\treturn (-2);\n}\n\nvoid\nsctp_delete_from_timewait(uint32_t tag, uint16_t lport, uint16_t rport)\n{\n\tstruct sctpvtaghead *chain;\n\tstruct sctp_tagblock *twait_block;\n\tint found = 0;\n\tint i;\n\n\tchain = &SCTP_BASE_INFO(vtag_timewait)[(tag % SCTP_STACK_VTAG_HASH_SIZE)];\n\tLIST_FOREACH(twait_block, chain, sctp_nxt_tagblock) {\n\t\tfor (i = 0; i < SCTP_NUMBER_IN_VTAG_BLOCK; i++) {\n\t\t  if ((twait_block->vtag_block[i].v_tag == tag) &&\n\t\t      (twait_block->vtag_block[i].lport == lport) &&\n\t\t      (twait_block->vtag_block[i].rport == rport)) {\n\t\t\t\ttwait_block->vtag_block[i].tv_sec_at_expire = 0;\n\t\t\t\ttwait_block->vtag_block[i].v_tag = 0;\n\t\t\t\ttwait_block->vtag_block[i].lport = 0;\n\t\t\t\ttwait_block->vtag_block[i].rport = 0;\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (found)\n\t\t\tbreak;\n\t}\n}\n\nint\nsctp_is_in_timewait(uint32_t tag, uint16_t lport, uint16_t rport)\n{\n\tstruct sctpvtaghead *chain;\n\tstruct sctp_tagblock *twait_block;\n\tint found = 0;\n\tint i;\n\n\tSCTP_INP_INFO_WLOCK();\n\tchain = &SCTP_BASE_INFO(vtag_timewait)[(tag % SCTP_STACK_VTAG_HASH_SIZE)];\n\tLIST_FOREACH(twait_block, chain, sctp_nxt_tagblock) {\n\t\tfor (i = 0; i < SCTP_NUMBER_IN_VTAG_BLOCK; i++) {\n\t\t\tif ((twait_block->vtag_block[i].v_tag == tag)  &&\n\t\t\t    (twait_block->vtag_block[i].lport == lport)  &&\n\t\t\t    (twait_block->vtag_block[i].rport == rport)) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (found)\n\t\t\tbreak;\n\t}\n\tSCTP_INP_INFO_WUNLOCK();\n\treturn (found);\n}\n\n\nvoid\nsctp_add_vtag_to_timewait(uint32_t tag, uint32_t time, uint16_t lport, uint16_t rport)\n{\n\tstruct sctpvtaghead *chain;\n\tstruct sctp_tagblock *twait_block;\n\tstruct timeval now;\n\tint set, i;\n\n\tif (time == 0) {\n\t\t/* Its disabled */\n\t\treturn;\n\t}\n\t(void)SCTP_GETTIME_TIMEVAL(&now);\n\tchain = &SCTP_BASE_INFO(vtag_timewait)[(tag % SCTP_STACK_VTAG_HASH_SIZE)];\n\tset = 0;\n\tLIST_FOREACH(twait_block, chain, sctp_nxt_tagblock) {\n\t\t/* Block(s) present, lets find space, and expire on the fly */\n\t\tfor (i = 0; i < SCTP_NUMBER_IN_VTAG_BLOCK; i++) {\n\t\t\tif ((twait_block->vtag_block[i].v_tag == 0) &&\n\t\t\t    !set) {\n\t\t\t\ttwait_block->vtag_block[i].tv_sec_at_expire =\n\t\t\t\t\tnow.tv_sec + time;\n\t\t\t\ttwait_block->vtag_block[i].v_tag = tag;\n\t\t\t\ttwait_block->vtag_block[i].lport = lport;\n\t\t\t\ttwait_block->vtag_block[i].rport = rport;\n\t\t\t\tset = 1;\n\t\t\t} else if ((twait_block->vtag_block[i].v_tag) &&\n\t\t\t\t    ((long)twait_block->vtag_block[i].tv_sec_at_expire < now.tv_sec)) {\n\t\t\t\t/* Audit expires this guy */\n\t\t\t\ttwait_block->vtag_block[i].tv_sec_at_expire = 0;\n\t\t\t\ttwait_block->vtag_block[i].v_tag = 0;\n\t\t\t\ttwait_block->vtag_block[i].lport = 0;\n\t\t\t\ttwait_block->vtag_block[i].rport = 0;\n\t\t\t\tif (set == 0) {\n\t\t\t\t\t/* Reuse it for my new tag */\n\t\t\t\t\ttwait_block->vtag_block[i].tv_sec_at_expire = now.tv_sec + time;\n\t\t\t\t\ttwait_block->vtag_block[i].v_tag = tag;\n\t\t\t\t\ttwait_block->vtag_block[i].lport = lport;\n\t\t\t\t\ttwait_block->vtag_block[i].rport = rport;\n\t\t\t\t\tset = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (set) {\n\t\t\t/*\n\t\t\t * We only do up to the block where we can\n\t\t\t * place our tag for audits\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t}\n\t/* Need to add a new block to chain */\n\tif (!set) {\n\t\tSCTP_MALLOC(twait_block, struct sctp_tagblock *,\n\t\t    sizeof(struct sctp_tagblock), SCTP_M_TIMW);\n\t\tif (twait_block == NULL) {\n#ifdef INVARIANTS\n\t\t\tpanic(\"Can not alloc tagblock\");\n#endif\n\t\t\treturn;\n\t\t}\n\t\tmemset(twait_block, 0, sizeof(struct sctp_tagblock));\n\t\tLIST_INSERT_HEAD(chain, twait_block, sctp_nxt_tagblock);\n\t\ttwait_block->vtag_block[0].tv_sec_at_expire = now.tv_sec + time;\n\t\ttwait_block->vtag_block[0].v_tag = tag;\n\t\ttwait_block->vtag_block[0].lport = lport;\n\t\ttwait_block->vtag_block[0].rport = rport;\n\t}\n}\n\nvoid\nsctp_clean_up_stream(struct sctp_tcb *stcb, struct sctp_readhead *rh)\n{\n\tstruct sctp_tmit_chunk *chk, *nchk;\n\tstruct sctp_queued_to_read *control, *ncontrol;\n\n\tTAILQ_FOREACH_SAFE(control, rh, next_instrm, ncontrol) {\n\t\tTAILQ_REMOVE(rh, control, next_instrm);\n\t\tcontrol->on_strm_q = 0;\n\t\tif (control->on_read_q == 0) {\n\t\t\tsctp_free_remote_addr(control->whoFrom);\n\t\t\tif (control->data) {\n\t\t\t\tsctp_m_freem(control->data);\n\t\t\t\tcontrol->data = NULL;\n\t\t\t}\n\t\t}\n\t\t/* Reassembly free? */\n\t\tTAILQ_FOREACH_SAFE(chk, &control->reasm, sctp_next, nchk) {\n\t\t\tTAILQ_REMOVE(&control->reasm, chk, sctp_next);\n\t\t\tif (chk->data) {\n\t\t\t\tsctp_m_freem(chk->data);\n\t\t\t\tchk->data = NULL;\n\t\t\t}\n\t\t\tif (chk->holds_key_ref)\n\t\t\t\tsctp_auth_key_release(stcb, chk->auth_keyid, SCTP_SO_LOCKED);\n\t\t\tsctp_free_remote_addr(chk->whoTo);\n\t\t\tSCTP_ZONE_FREE(SCTP_BASE_INFO(ipi_zone_chunk), chk);\n\t\t\tSCTP_DECR_CHK_COUNT();\n\t\t\t/*sa_ignore FREED_MEMORY*/\n\t\t}\n\t\t/*\n\t\t * We don't free the address here\n\t\t * since all the net's were freed\n\t\t * above.\n\t\t */\n\t\tif (control->on_read_q == 0) {\n\t\t\tsctp_free_a_readq(stcb, control);\n\t\t}\n\t}\n}\n\n#ifdef __Panda__\nvoid panda_wakeup_socket(struct socket *so);\n#endif\n\n/*-\n * Free the association after un-hashing the remote port. This\n * function ALWAYS returns holding NO LOCK on the stcb. It DOES\n * expect that the input to this function IS a locked TCB.\n * It will return 0, if it did NOT destroy the association (instead\n * it unlocks it. It will return NON-zero if it either destroyed the\n * association OR the association is already destroyed.\n */\nint\nsctp_free_assoc(struct sctp_inpcb *inp, struct sctp_tcb *stcb, int from_inpcbfree, int from_location)\n{\n\tint i;\n\tstruct sctp_association *asoc;\n\tstruct sctp_nets *net, *nnet;\n\tstruct sctp_laddr *laddr, *naddr;\n\tstruct sctp_tmit_chunk *chk, *nchk;\n\tstruct sctp_asconf_addr *aparam, *naparam;\n\tstruct sctp_asconf_ack *aack, *naack;\n\tstruct sctp_stream_reset_list *strrst, *nstrrst;\n\tstruct sctp_queued_to_read *sq, *nsq;\n\tstruct sctp_stream_queue_pending *sp, *nsp;\n\tsctp_sharedkey_t *shared_key, *nshared_key;\n\tstruct socket *so;\n\n\t/* first, lets purge the entry from the hash table. */\n#if defined(__APPLE__)\n\tsctp_lock_assert(SCTP_INP_SO(inp));\n#endif\n\n#ifdef SCTP_LOG_CLOSING\n\tsctp_log_closing(inp, stcb, 6);\n#endif\n\tif (stcb->asoc.state == 0) {\n#ifdef SCTP_LOG_CLOSING\n\t\tsctp_log_closing(inp, NULL, 7);\n#endif\n\t\t/* there is no asoc, really TSNH :-0 */\n\t\treturn (1);\n\t}\n\tif (stcb->asoc.alternate) {\n\t\tsctp_free_remote_addr(stcb->asoc.alternate);\n\t\tstcb->asoc.alternate = NULL;\n\t}\n#if !defined(__APPLE__) /* TEMP: moved to below */\n        /* TEMP CODE */\n\tif (stcb->freed_from_where == 0) {\n\t\t/* Only record the first place free happened from */\n\t\tstcb->freed_from_where = from_location;\n\t}\n        /* TEMP CODE */\n#endif\n\n\tasoc = &stcb->asoc;\n\tif ((inp->sctp_flags & SCTP_PCB_FLAGS_SOCKET_ALLGONE) ||\n\t    (inp->sctp_flags & SCTP_PCB_FLAGS_SOCKET_GONE))\n\t\t/* nothing around */\n\t\tso = NULL;\n\telse\n\t\tso = inp->sctp_socket;\n\n\t/*\n\t * We used timer based freeing if a reader or writer is in the way.\n\t * So we first check if we are actually being called from a timer,\n\t * if so we abort early if a reader or writer is still in the way.\n\t */\n\tif ((stcb->asoc.state & SCTP_STATE_ABOUT_TO_BE_FREED) &&\n\t    (from_inpcbfree == SCTP_NORMAL_PROC)) {\n\t\t/*\n\t\t * is it the timer driving us? if so are the reader/writers\n\t\t * gone?\n\t\t */\n\t\tif (stcb->asoc.refcnt) {\n\t\t\t/* nope, reader or writer in the way */\n\t\t\tsctp_timer_start(SCTP_TIMER_TYPE_ASOCKILL, inp, stcb, NULL);\n\t\t\t/* no asoc destroyed */\n\t\t\tSCTP_TCB_UNLOCK(stcb);\n#ifdef SCTP_LOG_CLOSING\n\t\t\tsctp_log_closing(inp, stcb, 8);\n#endif\n\t\t\treturn (0);\n\t\t}\n\t}\n\t/* now clean up any other timers */\n\t(void)SCTP_OS_TIMER_STOP(&asoc->dack_timer.timer);\n\tasoc->dack_timer.self = NULL;\n\t(void)SCTP_OS_TIMER_STOP(&asoc->strreset_timer.timer);\n\t/*-\n\t * For stream reset we don't blast this unless\n\t * it is a str-reset timer, it might be the\n\t * free-asoc timer which we DON'T want to\n\t * disturb.\n\t */\n\tif (asoc->strreset_timer.type == SCTP_TIMER_TYPE_STRRESET)\n\t\tasoc->strreset_timer.self = NULL;\n\t(void)SCTP_OS_TIMER_STOP(&asoc->asconf_timer.timer);\n\tasoc->asconf_timer.self = NULL;\n\t(void)SCTP_OS_TIMER_STOP(&asoc->autoclose_timer.timer);\n\tasoc->autoclose_timer.self = NULL;\n\t(void)SCTP_OS_TIMER_STOP(&asoc->shut_guard_timer.timer);\n\tasoc->shut_guard_timer.self = NULL;\n\t(void)SCTP_OS_TIMER_STOP(&asoc->delayed_event_timer.timer);\n\tasoc->delayed_event_timer.self = NULL;\n\t/* Mobility adaptation */\n\t(void)SCTP_OS_TIMER_STOP(&asoc->delete_prim_timer.timer);\n\tasoc->delete_prim_timer.self = NULL;\n\tTAILQ_FOREACH(net, &asoc->nets, sctp_next) {\n\t\t(void)SCTP_OS_TIMER_STOP(&net->rxt_timer.timer);\n\t\tnet->rxt_timer.self = NULL;\n\t\t(void)SCTP_OS_TIMER_STOP(&net->pmtu_timer.timer);\n\t\tnet->pmtu_timer.self = NULL;\n\t\t(void)SCTP_OS_TIMER_STOP(&net->hb_timer.timer);\n\t\tnet->hb_timer.self = NULL;\n\t}\n\t/* Now the read queue needs to be cleaned up (only once) */\n\tif ((stcb->asoc.state & SCTP_STATE_ABOUT_TO_BE_FREED) == 0) {\n\t\tSCTP_ADD_SUBSTATE(stcb, SCTP_STATE_ABOUT_TO_BE_FREED);\n\t\tSCTP_INP_READ_LOCK(inp);\n\t\tTAILQ_FOREACH(sq, &inp->read_queue, next) {\n\t\t\tif (sq->stcb == stcb) {\n\t\t\t\tsq->do_not_ref_stcb = 1;\n\t\t\t\tsq->sinfo_cumtsn = stcb->asoc.cumulative_tsn;\n\t\t\t\t/* If there is no end, there never\n\t\t\t\t * will be now.\n\t\t\t\t */\n\t\t\t\tif (sq->end_added == 0) {\n\t\t\t\t\t/* Held for PD-API clear that. */\n\t\t\t\t\tsq->pdapi_aborted = 1;\n\t\t\t\t\tsq->held_length = 0;\n\t\t\t\t\tif (sctp_stcb_is_feature_on(inp, stcb, SCTP_PCB_FLAGS_PDAPIEVNT) && (so != NULL)) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Need to add a PD-API aborted indication.\n\t\t\t\t\t\t * Setting the control_pdapi assures that it will\n\t\t\t\t\t\t * be added right after this msg.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tuint32_t strseq;\n\t\t\t\t\t\tstcb->asoc.control_pdapi = sq;\n\t\t\t\t\t\tstrseq = (sq->sinfo_stream << 16) | (sq->mid & 0x0000ffff);\n\t\t\t\t\t\tsctp_ulp_notify(SCTP_NOTIFY_PARTIAL_DELVIERY_INDICATION,\n\t\t\t\t\t\t                stcb,\n\t\t\t\t\t\t                SCTP_PARTIAL_DELIVERY_ABORTED,\n\t\t\t\t\t\t                (void *)&strseq,\n\t\t\t\t\t\t                SCTP_SO_LOCKED);\n\t\t\t\t\t\tstcb->asoc.control_pdapi = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* Add an end to wake them */\n\t\t\t\tsq->end_added = 1;\n\t\t\t}\n\t\t}\n\t\tSCTP_INP_READ_UNLOCK(inp);\n\t\tif (stcb->block_entry) {\n\t\t\tSCTP_LTRACE_ERR_RET(inp, stcb, NULL, SCTP_FROM_SCTP_PCB, ECONNRESET);\n\t\t\tstcb->block_entry->error = ECONNRESET;\n\t\t\tstcb->block_entry = NULL;\n\t\t}\n\t}\n\tif ((stcb->asoc.refcnt) || (stcb->asoc.state & SCTP_STATE_IN_ACCEPT_QUEUE)) {\n\t\t/* Someone holds a reference OR the socket is unaccepted yet.\n\t\t*/\n\t\tif ((stcb->asoc.refcnt)  ||\n\t\t    (inp->sctp_flags & SCTP_PCB_FLAGS_SOCKET_ALLGONE) ||\n\t\t    (inp->sctp_flags & SCTP_PCB_FLAGS_SOCKET_GONE)) {\n\t\t\tSCTP_CLEAR_SUBSTATE(stcb, SCTP_STATE_IN_ACCEPT_QUEUE);\n\t\t\tsctp_timer_start(SCTP_TIMER_TYPE_ASOCKILL, inp, stcb, NULL);\n\t\t}\n\t\tSCTP_TCB_UNLOCK(stcb);\n\t\tif ((inp->sctp_flags & SCTP_PCB_FLAGS_SOCKET_ALLGONE) ||\n\t\t    (inp->sctp_flags & SCTP_PCB_FLAGS_SOCKET_GONE))\n\t\t\t/* nothing around */\n\t\t\tso = NULL;\n\t\tif (so) {\n\t\t\t/* Wake any reader/writers */\n\t\t\tsctp_sorwakeup(inp, so);\n\t\t\tsctp_sowwakeup(inp, so);\n\t\t}\n\n#ifdef SCTP_LOG_CLOSING\n\t\tsctp_log_closing(inp, stcb, 9);\n#endif\n\t\t/* no asoc destroyed */\n\t\treturn (0);\n\t}\n#ifdef SCTP_LOG_CLOSING\n\tsctp_log_closing(inp, stcb, 10);\n#endif\n\t/* When I reach here, no others want\n\t * to kill the assoc yet.. and I own\n\t * the lock. Now its possible an abort\n\t * comes in when I do the lock exchange\n\t * below to grab all the locks to do\n\t * the final take out. to prevent this\n\t * we increment the count, which will\n\t * start a timer and blow out above thus\n\t * assuring us that we hold exclusive\n\t * killing of the asoc. Note that\n\t * after getting back the TCB lock\n\t * we will go ahead and increment the\n\t * counter back up and stop any timer\n\t * a passing stranger may have started :-S\n\t */\n\tif (from_inpcbfree == SCTP_NORMAL_PROC) {\n\t\tatomic_add_int(&stcb->asoc.refcnt, 1);\n\n\t\tSCTP_TCB_UNLOCK(stcb);\n\t\tSCTP_INP_INFO_WLOCK();\n\t\tSCTP_INP_WLOCK(inp);\n\t\tSCTP_TCB_LOCK(stcb);\n\t}\n\t/* Double check the GONE flag */\n\tif ((inp->sctp_flags & SCTP_PCB_FLAGS_SOCKET_ALLGONE) ||\n\t    (inp->sctp_flags & SCTP_PCB_FLAGS_SOCKET_GONE))\n\t\t/* nothing around */\n\t\tso = NULL;\n\n\tif ((inp->sctp_flags & SCTP_PCB_FLAGS_TCPTYPE) ||\n\t    (inp->sctp_flags & SCTP_PCB_FLAGS_IN_TCPPOOL)) {\n\t\t/*\n\t\t * For TCP type we need special handling when we are\n\t\t * connected. We also include the peel'ed off ones to.\n\t\t */\n\t\tif (inp->sctp_flags & SCTP_PCB_FLAGS_CONNECTED) {\n\t\t\tinp->sctp_flags &= ~SCTP_PCB_FLAGS_CONNECTED;\n\t\t\tinp->sctp_flags |= SCTP_PCB_FLAGS_WAS_CONNECTED;\n\t\t\tif (so) {\n\t\t\t\tSOCKBUF_LOCK(&so->so_rcv);\n\t\t\t\tso->so_state &= ~(SS_ISCONNECTING |\n\t\t\t\t    SS_ISDISCONNECTING |\n\t\t\t\t    SS_ISCONFIRMING |\n\t\t\t\t    SS_ISCONNECTED);\n\t\t\t\tso->so_state |= SS_ISDISCONNECTED;\n#if defined(__APPLE__)\n\t\t\t\tsocantrcvmore(so);\n#else\n\t\t\t\tsocantrcvmore_locked(so);\n#endif\n\t\t\t\tsocantsendmore(so);\n\t\t\t\tsctp_sowwakeup(inp, so);\n\t\t\t\tsctp_sorwakeup(inp, so);\n\t\t\t\tSCTP_SOWAKEUP(so);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Make it invalid too, that way if its\n\t * about to run it will abort and return.\n\t */\n\t/* re-increment the lock */\n\tif (from_inpcbfree == SCTP_NORMAL_PROC) {\n\t\tatomic_add_int(&stcb->asoc.refcnt, -1);\n\t}\n\tif (stcb->asoc.refcnt) {\n\t\tSCTP_CLEAR_SUBSTATE(stcb, SCTP_STATE_IN_ACCEPT_QUEUE);\n\t\tsctp_timer_start(SCTP_TIMER_TYPE_ASOCKILL, inp, stcb, NULL);\n\t\tif (from_inpcbfree == SCTP_NORMAL_PROC) {\n\t\t\tSCTP_INP_INFO_WUNLOCK();\n\t\t\tSCTP_INP_WUNLOCK(inp);\n\t\t}\n\t\tSCTP_TCB_UNLOCK(stcb);\n\t\treturn (0);\n\t}\n\tasoc->state = 0;\n\tif (inp->sctp_tcbhash) {\n\t\tLIST_REMOVE(stcb, sctp_tcbhash);\n\t}\n\tif (stcb->asoc.in_asocid_hash) {\n\t\tLIST_REMOVE(stcb, sctp_tcbasocidhash);\n\t}\n\t/* Now lets remove it from the list of ALL associations in the EP */\n\tLIST_REMOVE(stcb, sctp_tcblist);\n\tif (from_inpcbfree == SCTP_NORMAL_PROC) {\n\t\tSCTP_INP_INCR_REF(inp);\n\t\tSCTP_INP_WUNLOCK(inp);\n\t}\n\t/* pull from vtag hash */\n\tLIST_REMOVE(stcb, sctp_asocs);\n\tsctp_add_vtag_to_timewait(asoc->my_vtag, SCTP_BASE_SYSCTL(sctp_vtag_time_wait),\n\t\t\t\t  inp->sctp_lport, stcb->rport);\n\n\t/* Now restop the timers to be sure\n\t * this is paranoia at is finest!\n\t */\n\t(void)SCTP_OS_TIMER_STOP(&asoc->strreset_timer.timer);\n\t(void)SCTP_OS_TIMER_STOP(&asoc->dack_timer.timer);\n\t(void)SCTP_OS_TIMER_STOP(&asoc->strreset_timer.timer);\n\t(void)SCTP_OS_TIMER_STOP(&asoc->asconf_timer.timer);\n\t(void)SCTP_OS_TIMER_STOP(&asoc->shut_guard_timer.timer);\n\t(void)SCTP_OS_TIMER_STOP(&asoc->autoclose_timer.timer);\n\t(void)SCTP_OS_TIMER_STOP(&asoc->delayed_event_timer.timer);\n\tTAILQ_FOREACH(net, &asoc->nets, sctp_next) {\n\t\t(void)SCTP_OS_TIMER_STOP(&net->rxt_timer.timer);\n\t\t(void)SCTP_OS_TIMER_STOP(&net->pmtu_timer.timer);\n\t\t(void)SCTP_OS_TIMER_STOP(&net->hb_timer.timer);\n\t}\n\n\tasoc->strreset_timer.type = SCTP_TIMER_TYPE_NONE;\n\t/*\n\t * The chunk lists and such SHOULD be empty but we check them just\n\t * in case.\n\t */\n\t/* anything on the wheel needs to be removed */\n\tSCTP_TCB_SEND_LOCK(stcb);\n\tfor (i = 0; i < asoc->streamoutcnt; i++) {\n\t\tstruct sctp_stream_out *outs;\n\n\t\touts = &asoc->strmout[i];\n\t\t/* now clean up any chunks here */\n\t\tTAILQ_FOREACH_SAFE(sp, &outs->outqueue, next, nsp) {\n\t\t\tatomic_subtract_int(&asoc->stream_queue_cnt, 1);\n\t\t\tTAILQ_REMOVE(&outs->outqueue, sp, next);\n\t\t\tstcb->asoc.ss_functions.sctp_ss_remove_from_stream(stcb, asoc, outs, sp, 1);\n\t\t\tsctp_free_spbufspace(stcb, asoc, sp);\n\t\t\tif (sp->data) {\n\t\t\t\tif (so) {\n\t\t\t\t\t/* Still an open socket - report */\n\t\t\t\t\tsctp_ulp_notify(SCTP_NOTIFY_SPECIAL_SP_FAIL, stcb,\n\t\t\t\t\t                0, (void *)sp, SCTP_SO_LOCKED);\n\t\t\t\t}\n\t\t\t\tif (sp->data) {\n\t\t\t\t\tsctp_m_freem(sp->data);\n\t\t\t\t\tsp->data = NULL;\n\t\t\t\t\tsp->tail_mbuf = NULL;\n\t\t\t\t\tsp->length = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sp->net) {\n\t\t\t\tsctp_free_remote_addr(sp->net);\n\t\t\t\tsp->net = NULL;\n\t\t\t}\n\t\t\tsctp_free_a_strmoq(stcb, sp, SCTP_SO_LOCKED);\n\t\t}\n\t}\n\tSCTP_TCB_SEND_UNLOCK(stcb);\n\t/*sa_ignore FREED_MEMORY*/\n\tTAILQ_FOREACH_SAFE(strrst, &asoc->resetHead, next_resp, nstrrst) {\n\t\tTAILQ_REMOVE(&asoc->resetHead, strrst, next_resp);\n\t\tSCTP_FREE(strrst, SCTP_M_STRESET);\n\t}\n\tTAILQ_FOREACH_SAFE(sq, &asoc->pending_reply_queue, next, nsq) {\n\t\tTAILQ_REMOVE(&asoc->pending_reply_queue, sq, next);\n\t\tif (sq->data) {\n\t\t\tsctp_m_freem(sq->data);\n\t\t\tsq->data = NULL;\n\t\t}\n\t\tsctp_free_remote_addr(sq->whoFrom);\n\t\tsq->whoFrom = NULL;\n\t\tsq->stcb = NULL;\n\t\t/* Free the ctl entry */\n\t\tsctp_free_a_readq(stcb, sq);\n\t\t/*sa_ignore FREED_MEMORY*/\n\t}\n\tTAILQ_FOREACH_SAFE(chk, &asoc->free_chunks, sctp_next, nchk) {\n\t\tTAILQ_REMOVE(&asoc->free_chunks, chk, sctp_next);\n\t\tif (chk->data) {\n\t\t\tsctp_m_freem(chk->data);\n\t\t\tchk->data = NULL;\n\t\t}\n\t\tif (chk->holds_key_ref)\n\t\t\tsctp_auth_key_release(stcb, chk->auth_keyid, SCTP_SO_LOCKED);\n\t\tSCTP_ZONE_FREE(SCTP_BASE_INFO(ipi_zone_chunk), chk);\n\t\tSCTP_DECR_CHK_COUNT();\n\t\tatomic_subtract_int(&SCTP_BASE_INFO(ipi_free_chunks), 1);\n\t\tasoc->free_chunk_cnt--;\n\t\t/*sa_ignore FREED_MEMORY*/\n\t}\n\t/* pending send queue SHOULD be empty */\n\tTAILQ_FOREACH_SAFE(chk, &asoc->send_queue, sctp_next, nchk) {\n\t\tif (asoc->strmout[chk->rec.data.sid].chunks_on_queues > 0) {\n\t\t\tasoc->strmout[chk->rec.data.sid].chunks_on_queues--;\n#ifdef INVARIANTS\n\t\t} else {\n\t\t\tpanic(\"No chunks on the queues for sid %u.\", chk->rec.data.sid);\n#endif\n\t\t}\n\t\tTAILQ_REMOVE(&asoc->send_queue, chk, sctp_next);\n\t\tif (chk->data) {\n\t\t\tif (so) {\n\t\t\t\t/* Still a socket? */\n\t\t\t\tsctp_ulp_notify(SCTP_NOTIFY_UNSENT_DG_FAIL, stcb,\n\t\t\t\t                0, chk, SCTP_SO_LOCKED);\n\t\t\t}\n\t\t\tif (chk->data) {\n\t\t\t\tsctp_m_freem(chk->data);\n\t\t\t\tchk->data = NULL;\n\t\t\t}\n\t\t}\n\t\tif (chk->holds_key_ref)\n\t\t\tsctp_auth_key_release(stcb, chk->auth_keyid, SCTP_SO_LOCKED);\n\t\tif (chk->whoTo) {\n\t\t\tsctp_free_remote_addr(chk->whoTo);\n\t\t\tchk->whoTo = NULL;\n\t\t}\n\t\tSCTP_ZONE_FREE(SCTP_BASE_INFO(ipi_zone_chunk), chk);\n\t\tSCTP_DECR_CHK_COUNT();\n\t\t/*sa_ignore FREED_MEMORY*/\n\t}\n\t/* sent queue SHOULD be empty */\n\tTAILQ_FOREACH_SAFE(chk, &asoc->sent_queue, sctp_next, nchk) {\n\t\tif (chk->sent != SCTP_DATAGRAM_NR_ACKED) {\n\t\t\tif (asoc->strmout[chk->rec.data.sid].chunks_on_queues > 0) {\n\t\t\t\tasoc->strmout[chk->rec.data.sid].chunks_on_queues--;\n#ifdef INVARIANTS\n\t\t\t} else {\n\t\t\t\tpanic(\"No chunks on the queues for sid %u.\", chk->rec.data.sid);\n#endif\n\t\t\t}\n\t\t}\n\t\tTAILQ_REMOVE(&asoc->sent_queue, chk, sctp_next);\n\t\tif (chk->data) {\n\t\t\tif (so) {\n\t\t\t\t/* Still a socket? */\n\t\t\t\tsctp_ulp_notify(SCTP_NOTIFY_SENT_DG_FAIL, stcb,\n\t\t\t\t                0, chk, SCTP_SO_LOCKED);\n\t\t\t}\n\t\t\tif (chk->data) {\n\t\t\t\tsctp_m_freem(chk->data);\n\t\t\t\tchk->data = NULL;\n\t\t\t}\n\t\t}\n\t\tif (chk->holds_key_ref)\n\t\t\tsctp_auth_key_release(stcb, chk->auth_keyid, SCTP_SO_LOCKED);\n\t\tsctp_free_remote_addr(chk->whoTo);\n\t\tSCTP_ZONE_FREE(SCTP_BASE_INFO(ipi_zone_chunk), chk);\n\t\tSCTP_DECR_CHK_COUNT();\n\t\t/*sa_ignore FREED_MEMORY*/\n\t}\n#ifdef INVARIANTS\n\tfor (i = 0; i < stcb->asoc.streamoutcnt; i++) {\n\t\tif (stcb->asoc.strmout[i].chunks_on_queues > 0) {\n\t\t\tpanic(\"%u chunks left for stream %u.\", stcb->asoc.strmout[i].chunks_on_queues, i);\n\t\t}\n\t}\n#endif\n\t/* control queue MAY not be empty */\n\tTAILQ_FOREACH_SAFE(chk, &asoc->control_send_queue, sctp_next, nchk) {\n\t\tTAILQ_REMOVE(&asoc->control_send_queue, chk, sctp_next);\n\t\tif (chk->data) {\n\t\t\tsctp_m_freem(chk->data);\n\t\t\tchk->data = NULL;\n\t\t}\n\t\tif (chk->holds_key_ref)\n\t\t\tsctp_auth_key_release(stcb, chk->auth_keyid, SCTP_SO_LOCKED);\n\t\tsctp_free_remote_addr(chk->whoTo);\n\t\tSCTP_ZONE_FREE(SCTP_BASE_INFO(ipi_zone_chunk), chk);\n\t\tSCTP_DECR_CHK_COUNT();\n\t\t/*sa_ignore FREED_MEMORY*/\n\t}\n\t/* ASCONF queue MAY not be empty */\n\tTAILQ_FOREACH_SAFE(chk, &asoc->asconf_send_queue, sctp_next, nchk) {\n\t\tTAILQ_REMOVE(&asoc->asconf_send_queue, chk, sctp_next);\n\t\tif (chk->data) {\n\t\t\tsctp_m_freem(chk->data);\n\t\t\tchk->data = NULL;\n\t\t}\n\t\tif (chk->holds_key_ref)\n\t\t\tsctp_auth_key_release(stcb, chk->auth_keyid, SCTP_SO_LOCKED);\n\t\tsctp_free_remote_addr(chk->whoTo);\n\t\tSCTP_ZONE_FREE(SCTP_BASE_INFO(ipi_zone_chunk), chk);\n\t\tSCTP_DECR_CHK_COUNT();\n\t\t/*sa_ignore FREED_MEMORY*/\n\t}\n\tif (asoc->mapping_array) {\n\t\tSCTP_FREE(asoc->mapping_array, SCTP_M_MAP);\n\t\tasoc->mapping_array = NULL;\n\t}\n\tif (asoc->nr_mapping_array) {\n\t\tSCTP_FREE(asoc->nr_mapping_array, SCTP_M_MAP);\n\t\tasoc->nr_mapping_array = NULL;\n\t}\n\t/* the stream outs */\n\tif (asoc->strmout) {\n\t\tSCTP_FREE(asoc->strmout, SCTP_M_STRMO);\n\t\tasoc->strmout = NULL;\n\t}\n\tasoc->strm_realoutsize = asoc->streamoutcnt = 0;\n\tif (asoc->strmin) {\n\t\tfor (i = 0; i < asoc->streamincnt; i++) {\n\t\t\tsctp_clean_up_stream(stcb, &asoc->strmin[i].inqueue);\n\t\t\tsctp_clean_up_stream(stcb, &asoc->strmin[i].uno_inqueue);\n\t\t}\n\t\tSCTP_FREE(asoc->strmin, SCTP_M_STRMI);\n\t\tasoc->strmin = NULL;\n\t}\n\tasoc->streamincnt = 0;\n\tTAILQ_FOREACH_SAFE(net, &asoc->nets, sctp_next, nnet) {\n#ifdef INVARIANTS\n\t\tif (SCTP_BASE_INFO(ipi_count_raddr) == 0) {\n\t\t\tpanic(\"no net's left alloc'ed, or list points to itself\");\n\t\t}\n#endif\n\t\tTAILQ_REMOVE(&asoc->nets, net, sctp_next);\n\t\tsctp_free_remote_addr(net);\n\t}\n\tLIST_FOREACH_SAFE(laddr, &asoc->sctp_restricted_addrs, sctp_nxt_addr, naddr) {\n\t\t/*sa_ignore FREED_MEMORY*/\n\t\tsctp_remove_laddr(laddr);\n\t}\n\n\t/* pending asconf (address) parameters */\n\tTAILQ_FOREACH_SAFE(aparam, &asoc->asconf_queue, next, naparam) {\n\t\t/*sa_ignore FREED_MEMORY*/\n\t\tTAILQ_REMOVE(&asoc->asconf_queue, aparam, next);\n\t\tSCTP_FREE(aparam,SCTP_M_ASC_ADDR);\n\t}\n\tTAILQ_FOREACH_SAFE(aack, &asoc->asconf_ack_sent, next, naack) {\n\t\t/*sa_ignore FREED_MEMORY*/\n\t\tTAILQ_REMOVE(&asoc->asconf_ack_sent, aack, next);\n\t\tif (aack->data != NULL) {\n\t\t\tsctp_m_freem(aack->data);\n\t\t}\n\t\tSCTP_ZONE_FREE(SCTP_BASE_INFO(ipi_zone_asconf_ack), aack);\n\t}\n\t/* clean up auth stuff */\n\tif (asoc->local_hmacs)\n\t\tsctp_free_hmaclist(asoc->local_hmacs);\n\tif (asoc->peer_hmacs)\n\t\tsctp_free_hmaclist(asoc->peer_hmacs);\n\n\tif (asoc->local_auth_chunks)\n\t\tsctp_free_chunklist(asoc->local_auth_chunks);\n\tif (asoc->peer_auth_chunks)\n\t\tsctp_free_chunklist(asoc->peer_auth_chunks);\n\n\tsctp_free_authinfo(&asoc->authinfo);\n\n\tLIST_FOREACH_SAFE(shared_key, &asoc->shared_keys, next, nshared_key) {\n\t\tLIST_REMOVE(shared_key, next);\n\t\tsctp_free_sharedkey(shared_key);\n\t\t/*sa_ignore FREED_MEMORY*/\n\t}\n\n\t/* Insert new items here :> */\n\n\t/* Get rid of LOCK */\n\tSCTP_TCB_UNLOCK(stcb);\n\tSCTP_TCB_LOCK_DESTROY(stcb);\n\tSCTP_TCB_SEND_LOCK_DESTROY(stcb);\n\tif (from_inpcbfree == SCTP_NORMAL_PROC) {\n\t\tSCTP_INP_INFO_WUNLOCK();\n\t\tSCTP_INP_RLOCK(inp);\n\t}\n#if defined(__APPLE__) /* TEMP CODE */\n\tstcb->freed_from_where = from_location;\n#endif\n#ifdef SCTP_TRACK_FREED_ASOCS\n\tif (inp->sctp_flags & SCTP_PCB_FLAGS_SOCKET_GONE) {\n\t\t/* now clean up the tasoc itself */\n\t\tSCTP_ZONE_FREE(SCTP_BASE_INFO(ipi_zone_asoc), stcb);\n\t\tSCTP_DECR_ASOC_COUNT();\n\t} else {\n\t\tLIST_INSERT_HEAD(&inp->sctp_asoc_free_list, stcb, sctp_tcblist);\n\t}\n#else\n\tSCTP_ZONE_FREE(SCTP_BASE_INFO(ipi_zone_asoc), stcb);\n\tSCTP_DECR_ASOC_COUNT();\n#endif\n\tif (from_inpcbfree == SCTP_NORMAL_PROC) {\n\t\tif (inp->sctp_flags & SCTP_PCB_FLAGS_SOCKET_GONE) {\n\t\t\t/* If its NOT the inp_free calling us AND\n\t\t\t * sctp_close as been called, we\n\t\t\t * call back...\n\t\t\t */\n\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t\t/* This will start the kill timer (if we are\n\t\t\t * the last one) since we hold an increment yet. But\n\t\t\t * this is the only safe way to do this\n\t\t\t * since otherwise if the socket closes\n\t\t\t * at the same time we are here we might\n\t\t\t * collide in the cleanup.\n\t\t\t */\n\t\t\tsctp_inpcb_free(inp,\n\t\t\t\t\tSCTP_FREE_SHOULD_USE_GRACEFUL_CLOSE,\n\t\t\t\t\tSCTP_CALLED_DIRECTLY_NOCMPSET);\n\t\t\tSCTP_INP_DECR_REF(inp);\n\t\t\tgoto out_of;\n\t\t} else {\n\t\t\t/* The socket is still open. */\n\t\t\tSCTP_INP_DECR_REF(inp);\n\t\t}\n\t}\n\tif (from_inpcbfree == SCTP_NORMAL_PROC) {\n\t\tSCTP_INP_RUNLOCK(inp);\n\t}\n out_of:\n\t/* destroyed the asoc */\n#ifdef SCTP_LOG_CLOSING\n\tsctp_log_closing(inp, NULL, 11);\n#endif\n\treturn (1);\n}\n\n\n\n/*\n * determine if a destination is \"reachable\" based upon the addresses bound\n * to the current endpoint (e.g. only v4 or v6 currently bound)\n */\n/*\n * FIX: if we allow assoc-level bindx(), then this needs to be fixed to use\n * assoc level v4/v6 flags, as the assoc *may* not have the same address\n * types bound as its endpoint\n */\nint\nsctp_destination_is_reachable(struct sctp_tcb *stcb, struct sockaddr *destaddr)\n{\n\tstruct sctp_inpcb *inp;\n\tint answer;\n\n\t/*\n\t * No locks here, the TCB, in all cases is already locked and an\n\t * assoc is up. There is either a INP lock by the caller applied (in\n\t * asconf case when deleting an address) or NOT in the HB case,\n\t * however if HB then the INP increment is up and the INP will not\n\t * be removed (on top of the fact that we have a TCB lock). So we\n\t * only want to read the sctp_flags, which is either bound-all or\n\t * not.. no protection needed since once an assoc is up you can't be\n\t * changing your binding.\n\t */\n\tinp = stcb->sctp_ep;\n\tif (inp->sctp_flags & SCTP_PCB_FLAGS_BOUNDALL) {\n\t\t/* if bound all, destination is not restricted */\n\t\t/*\n\t\t * RRS: Question during lock work: Is this correct? If you\n\t\t * are bound-all you still might need to obey the V4--V6\n\t\t * flags??? IMO this bound-all stuff needs to be removed!\n\t\t */\n\t\treturn (1);\n\t}\n\t/* NOTE: all \"scope\" checks are done when local addresses are added */\n\tswitch (destaddr->sa_family) {\n#ifdef INET6\n\tcase AF_INET6:\n#if !(defined(__FreeBSD__) || defined(__APPLE__) || defined(__Windows__) || defined(__Userspace__))\n\t\tanswer = inp->inp_vflag & INP_IPV6;\n#else\n\t\tanswer = inp->ip_inp.inp.inp_vflag & INP_IPV6;\n#endif\n\t\tbreak;\n#endif\n#ifdef INET\n\tcase AF_INET:\n#if !(defined(__FreeBSD__) || defined(__APPLE__) || defined(__Windows__) || defined(__Userspace__))\n\t\tanswer = inp->inp_vflag & INP_IPV4;\n#else\n\t\tanswer = inp->ip_inp.inp.inp_vflag & INP_IPV4;\n#endif\n\t\tbreak;\n#endif\n#if defined(__Userspace__)\n\tcase AF_CONN:\n\t\tanswer = inp->ip_inp.inp.inp_vflag & INP_CONN;\n\t\tbreak;\n#endif\n\tdefault:\n\t\t/* invalid family, so it's unreachable */\n\t\tanswer = 0;\n\t\tbreak;\n\t}\n\treturn (answer);\n}\n\n/*\n * update the inp_vflags on an endpoint\n */\nstatic void\nsctp_update_ep_vflag(struct sctp_inpcb *inp)\n{\n\tstruct sctp_laddr *laddr;\n\n\t/* first clear the flag */\n#if !(defined(__FreeBSD__) || defined(__APPLE__) || defined(__Windows__) || defined(__Userspace__))\n\tinp->inp_vflag = 0;\n#else\n\tinp->ip_inp.inp.inp_vflag = 0;\n#endif\n\t/* set the flag based on addresses on the ep list */\n\tLIST_FOREACH(laddr, &inp->sctp_addr_list, sctp_nxt_addr) {\n\t\tif (laddr->ifa == NULL) {\n\t\t\tSCTPDBG(SCTP_DEBUG_PCB1, \"%s: NULL ifa\\n\",\n\t\t\t\t__func__);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (laddr->ifa->localifa_flags & SCTP_BEING_DELETED) {\n\t\t\tcontinue;\n\t\t}\n\t\tswitch (laddr->ifa->address.sa.sa_family) {\n#ifdef INET6\n\t\tcase AF_INET6:\n#if !(defined(__FreeBSD__) || defined(__APPLE__) || defined(__Windows__) || defined(__Userspace__))\n\t\t\tinp->inp_vflag |= INP_IPV6;\n#else\n\t\t\tinp->ip_inp.inp.inp_vflag |= INP_IPV6;\n#endif\n\t\t\tbreak;\n#endif\n#ifdef INET\n\t\tcase AF_INET:\n#if !(defined(__FreeBSD__) || defined(__APPLE__) || defined(__Windows__) || defined(__Userspace__))\n\t\t\tinp->inp_vflag |= INP_IPV4;\n#else\n\t\t\tinp->ip_inp.inp.inp_vflag |= INP_IPV4;\n#endif\n\t\t\tbreak;\n#endif\n#if defined(__Userspace__)\n\t\tcase AF_CONN:\n\t\t\tinp->ip_inp.inp.inp_vflag |= INP_CONN;\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/*\n * Add the address to the endpoint local address list There is nothing to be\n * done if we are bound to all addresses\n */\nvoid\nsctp_add_local_addr_ep(struct sctp_inpcb *inp, struct sctp_ifa *ifa, uint32_t action)\n{\n\tstruct sctp_laddr *laddr;\n\tstruct sctp_tcb *stcb;\n\tint fnd, error = 0;\n\n\tfnd = 0;\n\n\tif (inp->sctp_flags & SCTP_PCB_FLAGS_BOUNDALL) {\n\t\t/* You are already bound to all. You have it already */\n\t\treturn;\n\t}\n#ifdef INET6\n\tif (ifa->address.sa.sa_family == AF_INET6) {\n\t\tif (ifa->localifa_flags & SCTP_ADDR_IFA_UNUSEABLE) {\n\t\t\t/* Can't bind a non-useable addr. */\n\t\t\treturn;\n\t\t}\n\t}\n#endif\n\t/* first, is it already present? */\n\tLIST_FOREACH(laddr, &inp->sctp_addr_list, sctp_nxt_addr) {\n\t\tif (laddr->ifa == ifa) {\n\t\t\tfnd = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (fnd == 0) {\n\t\t/* Not in the ep list */\n\t\terror = sctp_insert_laddr(&inp->sctp_addr_list, ifa, action);\n\t\tif (error != 0)\n\t\t\treturn;\n\t\tinp->laddr_count++;\n\t\t/* update inp_vflag flags */\n\t\tswitch (ifa->address.sa.sa_family) {\n#ifdef INET6\n\t\tcase AF_INET6:\n#if !(defined(__FreeBSD__) || defined(__APPLE__) || defined(__Windows__) || defined(__Userspace__))\n\t\t\tinp->inp_vflag |= INP_IPV6;\n#else\n\t\t\tinp->ip_inp.inp.inp_vflag |= INP_IPV6;\n#endif\n\t\t\tbreak;\n#endif\n#ifdef INET\n\t\tcase AF_INET:\n#if !(defined(__FreeBSD__) || defined(__APPLE__) || defined(__Windows__) || defined(__Userspace__))\n\t\t\tinp->inp_vflag |= INP_IPV4;\n#else\n\t\t\tinp->ip_inp.inp.inp_vflag |= INP_IPV4;\n#endif\n\t\t\tbreak;\n#endif\n#if defined(__Userspace__)\n\t\tcase AF_CONN:\n\t\t\tinp->ip_inp.inp.inp_vflag |= INP_CONN;\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tLIST_FOREACH(stcb, &inp->sctp_asoc_list, sctp_tcblist) {\n\t\t\tsctp_add_local_addr_restricted(stcb, ifa);\n\t\t}\n\t}\n\treturn;\n}\n\n\n/*\n * select a new (hopefully reachable) destination net (should only be used\n * when we deleted an ep addr that is the only usable source address to reach\n * the destination net)\n */\nstatic void\nsctp_select_primary_destination(struct sctp_tcb *stcb)\n{\n\tstruct sctp_nets *net;\n\n\tTAILQ_FOREACH(net, &stcb->asoc.nets, sctp_next) {\n\t\t/* for now, we'll just pick the first reachable one we find */\n\t\tif (net->dest_state & SCTP_ADDR_UNCONFIRMED)\n\t\t\tcontinue;\n\t\tif (sctp_destination_is_reachable(stcb,\n\t\t    (struct sockaddr *)&net->ro._l_addr)) {\n\t\t\t/* found a reachable destination */\n\t\t\tstcb->asoc.primary_destination = net;\n\t\t}\n\t}\n\t/* I can't there from here! ...we're gonna die shortly... */\n}\n\n\n/*\n * Delete the address from the endpoint local address list. There is nothing\n * to be done if we are bound to all addresses\n */\nvoid\nsctp_del_local_addr_ep(struct sctp_inpcb *inp, struct sctp_ifa *ifa)\n{\n\tstruct sctp_laddr *laddr;\n\tint fnd;\n\n\tfnd = 0;\n\tif (inp->sctp_flags & SCTP_PCB_FLAGS_BOUNDALL) {\n\t\t/* You are already bound to all. You have it already */\n\t\treturn;\n\t}\n\tLIST_FOREACH(laddr, &inp->sctp_addr_list, sctp_nxt_addr) {\n\t\tif (laddr->ifa == ifa) {\n\t\t\tfnd = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fnd && (inp->laddr_count < 2)) {\n\t\t/* can't delete unless there are at LEAST 2 addresses */\n\t\treturn;\n\t}\n\tif (fnd) {\n\t\t/*\n\t\t * clean up any use of this address go through our\n\t\t * associations and clear any last_used_address that match\n\t\t * this one for each assoc, see if a new primary_destination\n\t\t * is needed\n\t\t */\n\t\tstruct sctp_tcb *stcb;\n\n\t\t/* clean up \"next_addr_touse\" */\n\t\tif (inp->next_addr_touse == laddr)\n\t\t\t/* delete this address */\n\t\t\tinp->next_addr_touse = NULL;\n\n\t\t/* clean up \"last_used_address\" */\n\t\tLIST_FOREACH(stcb, &inp->sctp_asoc_list, sctp_tcblist) {\n\t\t\tstruct sctp_nets *net;\n\n\t\t\tSCTP_TCB_LOCK(stcb);\n\t\t\tif (stcb->asoc.last_used_address == laddr)\n\t\t\t\t/* delete this address */\n\t\t\t\tstcb->asoc.last_used_address = NULL;\n\t\t\t/* Now spin through all the nets and purge any ref to laddr */\n\t\t\tTAILQ_FOREACH(net, &stcb->asoc.nets, sctp_next) {\n\t\t\t\tif (net->ro._s_addr == laddr->ifa) {\n\t\t\t\t\t/* Yep, purge src address selected */\n\t\t\t\t\tsctp_rtentry_t *rt;\n\n\t\t\t\t\t/* delete this address if cached */\n\t\t\t\t\trt = net->ro.ro_rt;\n\t\t\t\t\tif (rt != NULL) {\n\t\t\t\t\t\tRTFREE(rt);\n\t\t\t\t\t\tnet->ro.ro_rt = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tsctp_free_ifa(net->ro._s_addr);\n\t\t\t\t\tnet->ro._s_addr = NULL;\n\t\t\t\t\tnet->src_addr_selected = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSCTP_TCB_UNLOCK(stcb);\n\t\t}\t\t/* for each tcb */\n\t\t/* remove it from the ep list */\n\t\tsctp_remove_laddr(laddr);\n\t\tinp->laddr_count--;\n\t\t/* update inp_vflag flags */\n\t\tsctp_update_ep_vflag(inp);\n\t}\n\treturn;\n}\n\n/*\n * Add the address to the TCB local address restricted list.\n * This is a \"pending\" address list (eg. addresses waiting for an\n * ASCONF-ACK response) and cannot be used as a valid source address.\n */\nvoid\nsctp_add_local_addr_restricted(struct sctp_tcb *stcb, struct sctp_ifa *ifa)\n{\n\tstruct sctp_laddr *laddr;\n\tstruct sctpladdr *list;\n\n\t/*\n\t * Assumes TCB is locked.. and possibly the INP. May need to\n\t * confirm/fix that if we need it and is not the case.\n\t */\n\tlist = &stcb->asoc.sctp_restricted_addrs;\n\n#ifdef INET6\n\tif (ifa->address.sa.sa_family == AF_INET6) {\n\t\tif (ifa->localifa_flags & SCTP_ADDR_IFA_UNUSEABLE) {\n\t\t\t/* Can't bind a non-existent addr. */\n\t\t\treturn;\n\t\t}\n\t}\n#endif\n\t/* does the address already exist? */\n\tLIST_FOREACH(laddr, list, sctp_nxt_addr) {\n\t\tif (laddr->ifa == ifa) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* add to the list */\n\t(void)sctp_insert_laddr(list, ifa, 0);\n\treturn;\n}\n\n/*\n * Remove a local address from the TCB local address restricted list\n */\nvoid\nsctp_del_local_addr_restricted(struct sctp_tcb *stcb, struct sctp_ifa *ifa)\n{\n\tstruct sctp_inpcb *inp;\n\tstruct sctp_laddr *laddr;\n\n\t/*\n\t * This is called by asconf work. It is assumed that a) The TCB is\n\t * locked and b) The INP is locked. This is true in as much as I can\n\t * trace through the entry asconf code where I did these locks.\n\t * Again, the ASCONF code is a bit different in that it does lock\n\t * the INP during its work often times. This must be since we don't\n\t * want other proc's looking up things while what they are looking\n\t * up is changing :-D\n\t */\n\n\tinp = stcb->sctp_ep;\n\t/* if subset bound and don't allow ASCONF's, can't delete last */\n\tif (((inp->sctp_flags & SCTP_PCB_FLAGS_BOUNDALL) == 0) &&\n\t    sctp_is_feature_off(inp, SCTP_PCB_FLAGS_DO_ASCONF)) {\n\t\tif (stcb->sctp_ep->laddr_count < 2) {\n\t\t\t/* can't delete last address */\n\t\t\treturn;\n\t\t}\n\t}\n\tLIST_FOREACH(laddr, &stcb->asoc.sctp_restricted_addrs, sctp_nxt_addr) {\n\t\t/* remove the address if it exists */\n\t\tif (laddr->ifa == NULL)\n\t\t\tcontinue;\n\t\tif (laddr->ifa == ifa) {\n\t\t\tsctp_remove_laddr(laddr);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* address not found! */\n\treturn;\n}\n\n#if defined(__FreeBSD__)\n/*\n * Temporarily remove for __APPLE__ until we use the Tiger equivalents\n */\n/* sysctl */\nstatic int sctp_max_number_of_assoc = SCTP_MAX_NUM_OF_ASOC;\nstatic int sctp_scale_up_for_address = SCTP_SCALE_FOR_ADDR;\n#endif\t\t\t\t/* FreeBSD || APPLE */\n\n\n\n#if defined(__FreeBSD__) && defined(SCTP_MCORE_INPUT) && defined(SMP)\nstruct sctp_mcore_ctrl *sctp_mcore_workers = NULL;\nint *sctp_cpuarry = NULL;\nvoid\nsctp_queue_to_mcore(struct mbuf *m, int off, int cpu_to_use)\n{\n\t/* Queue a packet to a processor for the specified core */\n\tstruct sctp_mcore_queue *qent;\n\tstruct sctp_mcore_ctrl *wkq;\n\tint need_wake = 0;\n\tif (sctp_mcore_workers == NULL) {\n\t\t/* Something went way bad during setup */\n\t\tsctp_input_with_port(m, off, 0);\n\t\treturn;\n\t}\n\tSCTP_MALLOC(qent, struct sctp_mcore_queue *,\n\t\t    (sizeof(struct sctp_mcore_queue)),\n\t\t    SCTP_M_MCORE);\n\tif (qent == NULL) {\n\t\t/* This is trouble  */\n\t\tsctp_input_with_port(m, off, 0);\n\t\treturn;\n\t}\n#if defined(__FreeBSD__) && __FreeBSD_version >= 801000\n\tqent->vn = curvnet;\n#endif\n\tqent->m = m;\n\tqent->off = off;\n\tqent->v6 = 0;\n\twkq = &sctp_mcore_workers[cpu_to_use];\n\tSCTP_MCORE_QLOCK(wkq);\n\n\tTAILQ_INSERT_TAIL(&wkq->que, qent, next);\n\tif (wkq->running == 0) {\n\t\tneed_wake = 1;\n\t}\n\tSCTP_MCORE_QUNLOCK(wkq);\n\tif (need_wake) {\n\t\twakeup(&wkq->running);\n\t}\n}\n\nstatic void\nsctp_mcore_thread(void *arg)\n{\n\n\tstruct sctp_mcore_ctrl *wkq;\n\tstruct sctp_mcore_queue *qent;\n\n\twkq = (struct sctp_mcore_ctrl *)arg;\n\tstruct mbuf *m;\n\tint off, v6;\n\n\t/* Wait for first tickle */\n\tSCTP_MCORE_LOCK(wkq);\n\twkq->running = 0;\n\tmsleep(&wkq->running,\n\t       &wkq->core_mtx,\n\t       0, \"wait for pkt\", 0);\n\tSCTP_MCORE_UNLOCK(wkq);\n\n\t/* Bind to our cpu */\n\tthread_lock(curthread);\n\tsched_bind(curthread, wkq->cpuid);\n\tthread_unlock(curthread);\n\n\t/* Now lets start working */\n\tSCTP_MCORE_LOCK(wkq);\n\t/* Now grab lock and go */\n\tfor (;;) {\n\t\tSCTP_MCORE_QLOCK(wkq);\n\tskip_sleep:\n\t\twkq->running = 1;\n\t\tqent = TAILQ_FIRST(&wkq->que);\n\t\tif (qent) {\n\t\t\tTAILQ_REMOVE(&wkq->que, qent, next);\n\t\t\tSCTP_MCORE_QUNLOCK(wkq);\n#if defined(__FreeBSD__) && __FreeBSD_version >= 801000\n\t\t\tCURVNET_SET(qent->vn);\n#endif\n\t\t\tm = qent->m;\n\t\t\toff = qent->off;\n\t\t\tv6 = qent->v6;\n\t\t\tSCTP_FREE(qent, SCTP_M_MCORE);\n\t\t\tif (v6 == 0) {\n\t\t\t\tsctp_input_with_port(m, off, 0);\n\t\t\t} else {\n\t\t\t\tSCTP_PRINTF(\"V6 not yet supported\\n\");\n\t\t\t\tsctp_m_freem(m);\n\t\t\t}\n#if defined(__FreeBSD__) && __FreeBSD_version >= 801000\n\t\t\tCURVNET_RESTORE();\n#endif\n\t\t\tSCTP_MCORE_QLOCK(wkq);\n\t\t}\n\t\twkq->running = 0;\n\t\tif (!TAILQ_EMPTY(&wkq->que)) {\n\t\t\tgoto skip_sleep;\n\t\t}\n\t\tSCTP_MCORE_QUNLOCK(wkq);\n\t\tmsleep(&wkq->running,\n\t\t       &wkq->core_mtx,\n\t\t       0, \"wait for pkt\", 0);\n\t}\n}\n\nstatic void\nsctp_startup_mcore_threads(void)\n{\n\tint i, cpu;\n\n\tif (mp_ncpus == 1)\n\t\treturn;\n\n\tif (sctp_mcore_workers != NULL) {\n\t\t/* Already been here in some previous\n\t\t * vnet?\n\t\t */\n\t\treturn;\n\t}\n\tSCTP_MALLOC(sctp_mcore_workers, struct sctp_mcore_ctrl *,\n\t\t    ((mp_maxid+1) * sizeof(struct sctp_mcore_ctrl)),\n\t\t    SCTP_M_MCORE);\n\tif (sctp_mcore_workers == NULL) {\n\t\t/* TSNH I hope */\n\t\treturn;\n\t}\n\tmemset(sctp_mcore_workers, 0 , ((mp_maxid+1) *\n\t\t\t\t\tsizeof(struct sctp_mcore_ctrl)));\n\t/* Init the structures */\n\tfor (i = 0; i<=mp_maxid; i++) {\n\t\tTAILQ_INIT(&sctp_mcore_workers[i].que);\n\t\tSCTP_MCORE_LOCK_INIT(&sctp_mcore_workers[i]);\n\t\tSCTP_MCORE_QLOCK_INIT(&sctp_mcore_workers[i]);\n\t\tsctp_mcore_workers[i].cpuid = i;\n\t}\n\tif (sctp_cpuarry == NULL) {\n\t\tSCTP_MALLOC(sctp_cpuarry, int *,\n\t\t\t    (mp_ncpus * sizeof(int)),\n\t\t\t    SCTP_M_MCORE);\n\t\ti = 0;\n\t\tCPU_FOREACH(cpu) {\n\t\t\tsctp_cpuarry[i] = cpu;\n\t\t\ti++;\n\t\t}\n\t}\n\n\t/* Now start them all */\n\tCPU_FOREACH(cpu) {\n#if __FreeBSD_version <= 701000\n\t\t(void)kthread_create(sctp_mcore_thread,\n\t\t\t\t     (void *)&sctp_mcore_workers[cpu],\n\t\t\t\t     &sctp_mcore_workers[cpu].thread_proc,\n\t\t\t\t     RFPROC,\n\t\t\t\t     SCTP_KTHREAD_PAGES,\n\t\t\t\t     SCTP_MCORE_NAME);\n\n#else\n\t\t(void)kproc_create(sctp_mcore_thread,\n\t\t\t\t   (void *)&sctp_mcore_workers[cpu],\n\t\t\t\t   &sctp_mcore_workers[cpu].thread_proc,\n\t\t\t\t   RFPROC,\n\t\t\t\t   SCTP_KTHREAD_PAGES,\n\t\t\t\t   SCTP_MCORE_NAME);\n#endif\n\n\t}\n}\n#endif\n#if defined(__FreeBSD__) && __FreeBSD_cc_version >= 1400000\nstatic struct mbuf *\nsctp_netisr_hdlr(struct mbuf *m, uintptr_t source)\n{\n\tstruct ip *ip;\n\tstruct sctphdr *sh;\n\tint offset;\n\tuint32_t flowid, tag;\n\n\t/*\n\t * No flow id built by lower layers fix it so we\n\t * create one.\n\t */\n\tip = mtod(m, struct ip *);\n\toffset = (ip->ip_hl << 2) + sizeof(struct sctphdr);\n\tif (SCTP_BUF_LEN(m) < offset) {\n\t\tif ((m = m_pullup(m, offset)) == NULL) {\n\t\t\tSCTP_STAT_INCR(sctps_hdrops);\n\t\t\treturn (NULL);\n\t\t}\n\t\tip = mtod(m, struct ip *);\n\t}\n\tsh = (struct sctphdr *)((caddr_t)ip + (ip->ip_hl << 2));\n\ttag = htonl(sh->v_tag);\n\tflowid = tag ^ ntohs(sh->dest_port) ^ ntohs(sh->src_port);\n\tm->m_pkthdr.flowid = flowid;\n/* FIX ME */\n\tm->m_flags |= M_FLOWID;\n\treturn (m);\n}\n#endif\n\nvoid\n#if defined(__Userspace__)\nsctp_pcb_init(int start_threads)\n#else\nsctp_pcb_init(void)\n#endif\n{\n\t/*\n\t * SCTP initialization for the PCB structures should be called by\n\t * the sctp_init() function.\n\t */\n\tint i;\n\tstruct timeval tv;\n\n\tif (SCTP_BASE_VAR(sctp_pcb_initialized) != 0) {\n\t\t/* error I was called twice */\n\t\treturn;\n\t}\n\tSCTP_BASE_VAR(sctp_pcb_initialized) = 1;\n\n#if defined(SCTP_PROCESS_LEVEL_LOCKS)\n#if !defined(__Userspace_os_Windows)\n\tpthread_mutexattr_init(&SCTP_BASE_VAR(mtx_attr));\n#ifdef INVARIANTS\n\tpthread_mutexattr_settype(&SCTP_BASE_VAR(mtx_attr), PTHREAD_MUTEX_ERRORCHECK);\n#endif\n#endif\n#endif\n#if defined(SCTP_LOCAL_TRACE_BUF)\n#if defined(__Windows__)\n\tif (SCTP_BASE_SYSCTL(sctp_log) != NULL) {\n\t\tmemset(SCTP_BASE_SYSCTL(sctp_log), 0, sizeof(struct sctp_log));\n\t}\n#else\n\tmemset(&SCTP_BASE_SYSCTL(sctp_log), 0, sizeof(struct sctp_log));\n#endif\n#endif\n#if defined(__FreeBSD__) && defined(SMP) && defined(SCTP_USE_PERCPU_STAT)\n\tSCTP_MALLOC(SCTP_BASE_STATS, struct sctpstat *,\n\t\t    ((mp_maxid+1) * sizeof(struct sctpstat)),\n\t\t    SCTP_M_MCORE);\n#endif\n\t(void)SCTP_GETTIME_TIMEVAL(&tv);\n#if defined(__FreeBSD__) && defined(SMP) && defined(SCTP_USE_PERCPU_STAT)\n\tmemset(SCTP_BASE_STATS, 0, sizeof(struct sctpstat) * (mp_maxid+1));\n\tSCTP_BASE_STATS[PCPU_GET(cpuid)].sctps_discontinuitytime.tv_sec = (uint32_t)tv.tv_sec;\n\tSCTP_BASE_STATS[PCPU_GET(cpuid)].sctps_discontinuitytime.tv_usec = (uint32_t)tv.tv_usec;\n#else\n\tmemset(&SCTP_BASE_STATS, 0, sizeof(struct sctpstat));\n\tSCTP_BASE_STAT(sctps_discontinuitytime).tv_sec = (uint32_t)tv.tv_sec;\n\tSCTP_BASE_STAT(sctps_discontinuitytime).tv_usec = (uint32_t)tv.tv_usec;\n#endif\n\t/* init the empty list of (All) Endpoints */\n\tLIST_INIT(&SCTP_BASE_INFO(listhead));\n#if defined(__APPLE__)\n\tLIST_INIT(&SCTP_BASE_INFO(inplisthead));\n#if defined(APPLE_LEOPARD) || defined(APPLE_SNOWLEOPARD) || defined(APPLE_LION) || defined(APPLE_MOUNTAINLION)\n\tSCTP_BASE_INFO(sctbinfo).listhead = &SCTP_BASE_INFO(inplisthead);\n\tSCTP_BASE_INFO(sctbinfo).mtx_grp_attr = lck_grp_attr_alloc_init();\n\tlck_grp_attr_setdefault(SCTP_BASE_INFO(sctbinfo).mtx_grp_attr);\n\tSCTP_BASE_INFO(sctbinfo).mtx_grp = lck_grp_alloc_init(\"sctppcb\", SCTP_BASE_INFO(sctbinfo).mtx_grp_attr);\n\tSCTP_BASE_INFO(sctbinfo).mtx_attr = lck_attr_alloc_init();\n\tlck_attr_setdefault(SCTP_BASE_INFO(sctbinfo).mtx_attr);\n#else\n\tSCTP_BASE_INFO(sctbinfo).ipi_listhead = &SCTP_BASE_INFO(inplisthead);\n\tSCTP_BASE_INFO(sctbinfo).ipi_lock_grp_attr = lck_grp_attr_alloc_init();\n\tlck_grp_attr_setdefault(SCTP_BASE_INFO(sctbinfo).ipi_lock_grp_attr);\n\tSCTP_BASE_INFO(sctbinfo).ipi_lock_grp = lck_grp_alloc_init(\"sctppcb\", SCTP_BASE_INFO(sctbinfo).ipi_lock_grp_attr);\n\tSCTP_BASE_INFO(sctbinfo).ipi_lock_attr = lck_attr_alloc_init();\n\tlck_attr_setdefault(SCTP_BASE_INFO(sctbinfo).ipi_lock_attr);\n#endif\n#if !defined(APPLE_LEOPARD) && !defined(APPLE_SNOWLEOPARD) && !defined(APPLE_LION) && !defined(APPLE_MOUNTAINLION)\n\tSCTP_BASE_INFO(sctbinfo).ipi_gc = sctp_gc;\n\tin_pcbinfo_attach(&SCTP_BASE_INFO(sctbinfo));\n#endif\n#endif\n\n\n\t/* init the hash table of endpoints */\n#if defined(__FreeBSD__)\n#if defined(__FreeBSD_cc_version) && __FreeBSD_cc_version >= 440000\n\tTUNABLE_INT_FETCH(\"net.inet.sctp.tcbhashsize\", &SCTP_BASE_SYSCTL(sctp_hashtblsize));\n\tTUNABLE_INT_FETCH(\"net.inet.sctp.pcbhashsize\", &SCTP_BASE_SYSCTL(sctp_pcbtblsize));\n\tTUNABLE_INT_FETCH(\"net.inet.sctp.chunkscale\", &SCTP_BASE_SYSCTL(sctp_chunkscale));\n#else\n\tTUNABLE_INT_FETCH(\"net.inet.sctp.tcbhashsize\", SCTP_TCBHASHSIZE,\n\t\t\t  SCTP_BASE_SYSCTL(sctp_hashtblsize));\n\tTUNABLE_INT_FETCH(\"net.inet.sctp.pcbhashsize\", SCTP_PCBHASHSIZE,\n\t\t\t  SCTP_BASE_SYSCTL(sctp_pcbtblsize));\n\tTUNABLE_INT_FETCH(\"net.inet.sctp.chunkscale\", SCTP_CHUNKQUEUE_SCALE,\n\t\t\t  SCTP_BASE_SYSCTL(sctp_chunkscale));\n#endif\n#endif\n\tSCTP_BASE_INFO(sctp_asochash) = SCTP_HASH_INIT((SCTP_BASE_SYSCTL(sctp_hashtblsize) * 31),\n\t\t\t\t\t\t       &SCTP_BASE_INFO(hashasocmark));\n\tSCTP_BASE_INFO(sctp_ephash) = SCTP_HASH_INIT(SCTP_BASE_SYSCTL(sctp_hashtblsize),\n\t\t\t\t\t\t     &SCTP_BASE_INFO(hashmark));\n\tSCTP_BASE_INFO(sctp_tcpephash) = SCTP_HASH_INIT(SCTP_BASE_SYSCTL(sctp_hashtblsize),\n\t\t\t\t\t\t\t&SCTP_BASE_INFO(hashtcpmark));\n\tSCTP_BASE_INFO(hashtblsize) = SCTP_BASE_SYSCTL(sctp_hashtblsize);\n\n\n\tSCTP_BASE_INFO(sctp_vrfhash) = SCTP_HASH_INIT(SCTP_SIZE_OF_VRF_HASH,\n\t\t\t\t\t\t      &SCTP_BASE_INFO(hashvrfmark));\n\n\tSCTP_BASE_INFO(vrf_ifn_hash) = SCTP_HASH_INIT(SCTP_VRF_IFN_HASH_SIZE,\n\t\t\t\t\t\t      &SCTP_BASE_INFO(vrf_ifn_hashmark));\n\t/* init the zones */\n\t/*\n\t * FIX ME: Should check for NULL returns, but if it does fail we are\n\t * doomed to panic anyways... add later maybe.\n\t */\n\tSCTP_ZONE_INIT(SCTP_BASE_INFO(ipi_zone_ep), \"sctp_ep\",\n\t\t       sizeof(struct sctp_inpcb), maxsockets);\n\n\tSCTP_ZONE_INIT(SCTP_BASE_INFO(ipi_zone_asoc), \"sctp_asoc\",\n\t\t       sizeof(struct sctp_tcb), sctp_max_number_of_assoc);\n\n\tSCTP_ZONE_INIT(SCTP_BASE_INFO(ipi_zone_laddr), \"sctp_laddr\",\n\t\t       sizeof(struct sctp_laddr),\n\t\t       (sctp_max_number_of_assoc * sctp_scale_up_for_address));\n\n\tSCTP_ZONE_INIT(SCTP_BASE_INFO(ipi_zone_net), \"sctp_raddr\",\n\t\t       sizeof(struct sctp_nets),\n\t\t       (sctp_max_number_of_assoc * sctp_scale_up_for_address));\n\n\tSCTP_ZONE_INIT(SCTP_BASE_INFO(ipi_zone_chunk), \"sctp_chunk\",\n\t\t       sizeof(struct sctp_tmit_chunk),\n\t\t       (sctp_max_number_of_assoc * SCTP_BASE_SYSCTL(sctp_chunkscale)));\n\n\tSCTP_ZONE_INIT(SCTP_BASE_INFO(ipi_zone_readq), \"sctp_readq\",\n\t\t       sizeof(struct sctp_queued_to_read),\n\t\t       (sctp_max_number_of_assoc * SCTP_BASE_SYSCTL(sctp_chunkscale)));\n\n\tSCTP_ZONE_INIT(SCTP_BASE_INFO(ipi_zone_strmoq), \"sctp_stream_msg_out\",\n\t\t       sizeof(struct sctp_stream_queue_pending),\n\t\t       (sctp_max_number_of_assoc * SCTP_BASE_SYSCTL(sctp_chunkscale)));\n\n\tSCTP_ZONE_INIT(SCTP_BASE_INFO(ipi_zone_asconf), \"sctp_asconf\",\n\t\t       sizeof(struct sctp_asconf),\n\t\t       (sctp_max_number_of_assoc * SCTP_BASE_SYSCTL(sctp_chunkscale)));\n\n\tSCTP_ZONE_INIT(SCTP_BASE_INFO(ipi_zone_asconf_ack), \"sctp_asconf_ack\",\n\t\t       sizeof(struct sctp_asconf_ack),\n\t\t       (sctp_max_number_of_assoc * SCTP_BASE_SYSCTL(sctp_chunkscale)));\n\n\n\t/* Master Lock INIT for info structure */\n\tSCTP_INP_INFO_LOCK_INIT();\n\tSCTP_STATLOG_INIT_LOCK();\n\n\tSCTP_IPI_COUNT_INIT();\n\tSCTP_IPI_ADDR_INIT();\n#ifdef SCTP_PACKET_LOGGING\n\tSCTP_IP_PKTLOG_INIT();\n#endif\n\tLIST_INIT(&SCTP_BASE_INFO(addr_wq));\n\n\tSCTP_WQ_ADDR_INIT();\n\t/* not sure if we need all the counts */\n\tSCTP_BASE_INFO(ipi_count_ep) = 0;\n\t/* assoc/tcb zone info */\n\tSCTP_BASE_INFO(ipi_count_asoc) = 0;\n\t/* local addrlist zone info */\n\tSCTP_BASE_INFO(ipi_count_laddr) = 0;\n\t/* remote addrlist zone info */\n\tSCTP_BASE_INFO(ipi_count_raddr) = 0;\n\t/* chunk info */\n\tSCTP_BASE_INFO(ipi_count_chunk) = 0;\n\n\t/* socket queue zone info */\n\tSCTP_BASE_INFO(ipi_count_readq) = 0;\n\n\t/* stream out queue cont */\n\tSCTP_BASE_INFO(ipi_count_strmoq) = 0;\n\n\tSCTP_BASE_INFO(ipi_free_strmoq) = 0;\n\tSCTP_BASE_INFO(ipi_free_chunks) = 0;\n\n\tSCTP_OS_TIMER_INIT(&SCTP_BASE_INFO(addr_wq_timer.timer));\n\n\t/* Init the TIMEWAIT list */\n\tfor (i = 0; i < SCTP_STACK_VTAG_HASH_SIZE; i++) {\n\t\tLIST_INIT(&SCTP_BASE_INFO(vtag_timewait)[i]);\n\t}\n#if defined(SCTP_PROCESS_LEVEL_LOCKS)\n#if defined(__Userspace_os_Windows)\n\tInitializeConditionVariable(&sctp_it_ctl.iterator_wakeup);\n#else\n\t(void)pthread_cond_init(&sctp_it_ctl.iterator_wakeup, NULL);\n#endif\n#endif\n\tsctp_startup_iterator();\n\n#if defined(__FreeBSD__) && defined(SCTP_MCORE_INPUT) && defined(SMP)\n\tsctp_startup_mcore_threads();\n#endif\n\n#ifndef __Panda__\n\t/*\n\t * INIT the default VRF which for BSD is the only one, other O/S's\n\t * may have more. But initially they must start with one and then\n\t * add the VRF's as addresses are added.\n\t */\n\tsctp_init_vrf_list(SCTP_DEFAULT_VRF);\n#endif\n#if defined(__FreeBSD__) && __FreeBSD_cc_version >= 1400000\n\tif (ip_register_flow_handler(sctp_netisr_hdlr, IPPROTO_SCTP)) {\n\t\tSCTP_PRINTF(\"***SCTP- Error can't register netisr handler***\\n\");\n\t}\n#endif\n#if defined(_SCTP_NEEDS_CALLOUT_) || defined(_USER_SCTP_NEEDS_CALLOUT_)\n\t/* allocate the lock for the callout/timer queue */\n\tSCTP_TIMERQ_LOCK_INIT();\n\tSCTP_TIMERWAIT_LOCK_INIT();\n\tTAILQ_INIT(&SCTP_BASE_INFO(callqueue));\n#endif\n#if defined(__Userspace__)\n\tmbuf_initialize(NULL);\n\tatomic_init();\n#if defined(INET) || defined(INET6)\n\tif (start_threads)\n\t\trecv_thread_init();\n#endif\n#endif\n}\n\n/*\n * Assumes that the SCTP_BASE_INFO() lock is NOT held.\n */\nvoid\nsctp_pcb_finish(void)\n{\n\tstruct sctp_vrflist *vrf_bucket;\n\tstruct sctp_vrf *vrf, *nvrf;\n\tstruct sctp_ifn *ifn, *nifn;\n\tstruct sctp_ifa *ifa, *nifa;\n\tstruct sctpvtaghead *chain;\n\tstruct sctp_tagblock *twait_block, *prev_twait_block;\n\tstruct sctp_laddr *wi, *nwi;\n\tint i;\n\tstruct sctp_iterator *it, *nit;\n\n\tif (SCTP_BASE_VAR(sctp_pcb_initialized) == 0) {\n\t\tSCTP_PRINTF(\"%s: race condition on teardown.\\n\", __func__);\n\t\treturn;\n\t}\n\tSCTP_BASE_VAR(sctp_pcb_initialized) = 0;\n#if !defined(__FreeBSD__)\n\t/* Notify the iterator to exit. */\n\tSCTP_IPI_ITERATOR_WQ_LOCK();\n\tsctp_it_ctl.iterator_flags |= SCTP_ITERATOR_MUST_EXIT;\n\tsctp_wakeup_iterator();\n\tSCTP_IPI_ITERATOR_WQ_UNLOCK();\n#endif\n#if defined(__APPLE__)\n#if !defined(APPLE_LEOPARD) && !defined(APPLE_SNOWLEOPARD) && !defined(APPLE_LION) && !defined(APPLE_MOUNTAINLION)\n\tin_pcbinfo_detach(&SCTP_BASE_INFO(sctbinfo));\n#endif\n\tSCTP_IPI_ITERATOR_WQ_LOCK();\n\tdo {\n\t\tmsleep(&sctp_it_ctl.iterator_flags,\n\t\t       sctp_it_ctl.ipi_iterator_wq_mtx,\n\t\t       0, \"waiting_for_work\", 0);\n\t} while ((sctp_it_ctl.iterator_flags & SCTP_ITERATOR_EXITED) == 0);\n\tthread_deallocate(sctp_it_ctl.thread_proc);\n\tSCTP_IPI_ITERATOR_WQ_UNLOCK();\n#endif\n#if defined(__Windows__)\n\tif (sctp_it_ctl.iterator_thread_obj != NULL) {\n\t\tNTSTATUS status = STATUS_SUCCESS;\n\n\t\tKeSetEvent(&sctp_it_ctl.iterator_wakeup[1], IO_NO_INCREMENT, FALSE);\n\t\tstatus = KeWaitForSingleObject(sctp_it_ctl.iterator_thread_obj,\n\t\t\t\t\t       Executive,\n\t\t\t\t\t       KernelMode,\n\t\t\t\t\t       FALSE,\n\t\t\t\t\t       NULL);\n\t\tObDereferenceObject(sctp_it_ctl.iterator_thread_obj);\n\t}\n#endif\n#if defined(__Userspace__)\n\tif (sctp_it_ctl.thread_proc) {\n#if defined(__Userspace_os_Windows)\n\t\tWaitForSingleObject(sctp_it_ctl.thread_proc, INFINITE);\n\t\tCloseHandle(sctp_it_ctl.thread_proc);\n\t\tsctp_it_ctl.thread_proc = NULL;\n#else\n\t\tpthread_join(sctp_it_ctl.thread_proc, NULL);\n\t\tsctp_it_ctl.thread_proc = 0;\n#endif\n\t}\n#endif\n#if defined(SCTP_PROCESS_LEVEL_LOCKS)\n#if defined(__Userspace_os_Windows)\n\tDeleteConditionVariable(&sctp_it_ctl.iterator_wakeup);\n#else\n\tpthread_cond_destroy(&sctp_it_ctl.iterator_wakeup);\n\tpthread_mutexattr_destroy(&SCTP_BASE_VAR(mtx_attr));\n#endif\n#endif\n\t/* In FreeBSD the iterator thread never exits\n\t * but we do clean up.\n\t * The only way FreeBSD reaches here is if we have VRF's\n\t * but we still add the ifdef to make it compile on old versions.\n\t */\n#if defined(__FreeBSD__)\nretry:\n#endif\n\tSCTP_IPI_ITERATOR_WQ_LOCK();\n#if defined(__FreeBSD__)\n\t/*\n\t * sctp_iterator_worker() might be working on an it entry without\n\t * holding the lock.  We won't find it on the list either and\n\t * continue and free/destroy it.  While holding the lock, spin, to\n\t * avoid the race condition as sctp_iterator_worker() will have to\n\t * wait to re-aquire the lock.\n\t */\n\tif (sctp_it_ctl.iterator_running != 0 || sctp_it_ctl.cur_it != NULL) {\n\t\tSCTP_IPI_ITERATOR_WQ_UNLOCK();\n\t\tSCTP_PRINTF(\"%s: Iterator running while we held the lock. Retry. \"\n\t\t            \"cur_it=%p\\n\", __func__, sctp_it_ctl.cur_it);\n\t\tDELAY(10);\n\t\tgoto retry;\n\t}\n#endif\n\tTAILQ_FOREACH_SAFE(it, &sctp_it_ctl.iteratorhead, sctp_nxt_itr, nit) {\n#if defined(__FreeBSD__) && __FreeBSD_version >= 801000\n\t\tif (it->vn != curvnet) {\n\t\t\tcontinue;\n\t\t}\n#endif\n\t\tTAILQ_REMOVE(&sctp_it_ctl.iteratorhead, it, sctp_nxt_itr);\n\t\tif (it->function_atend != NULL) {\n\t\t\t(*it->function_atend) (it->pointer, it->val);\n\t\t}\n\t\tSCTP_FREE(it,SCTP_M_ITER);\n\t}\n\tSCTP_IPI_ITERATOR_WQ_UNLOCK();\n#if defined(__FreeBSD__) && __FreeBSD_version >= 801000\n\tSCTP_ITERATOR_LOCK();\n\tif ((sctp_it_ctl.cur_it) &&\n\t    (sctp_it_ctl.cur_it->vn == curvnet)) {\n\t\tsctp_it_ctl.iterator_flags |= SCTP_ITERATOR_STOP_CUR_IT;\n\t}\n\tSCTP_ITERATOR_UNLOCK();\n#endif\n#if !defined(__FreeBSD__)\n\tSCTP_IPI_ITERATOR_WQ_DESTROY();\n\tSCTP_ITERATOR_LOCK_DESTROY();\n#endif\n\tSCTP_OS_TIMER_STOP_DRAIN(&SCTP_BASE_INFO(addr_wq_timer.timer));\n\tSCTP_WQ_ADDR_LOCK();\n\tLIST_FOREACH_SAFE(wi, &SCTP_BASE_INFO(addr_wq), sctp_nxt_addr, nwi) {\n\t\tLIST_REMOVE(wi, sctp_nxt_addr);\n\t\tSCTP_DECR_LADDR_COUNT();\n\t\tif (wi->action == SCTP_DEL_IP_ADDRESS) {\n\t\t\tSCTP_FREE(wi->ifa, SCTP_M_IFA);\n\t\t}\n\t\tSCTP_ZONE_FREE(SCTP_BASE_INFO(ipi_zone_laddr), wi);\n\t}\n\tSCTP_WQ_ADDR_UNLOCK();\n\n\t/*\n\t * free the vrf/ifn/ifa lists and hashes (be sure address monitor\n\t * is destroyed first).\n\t */\n\tvrf_bucket = &SCTP_BASE_INFO(sctp_vrfhash)[(SCTP_DEFAULT_VRFID & SCTP_BASE_INFO(hashvrfmark))];\n\tLIST_FOREACH_SAFE(vrf, vrf_bucket, next_vrf, nvrf) {\n\t\tLIST_FOREACH_SAFE(ifn, &vrf->ifnlist, next_ifn, nifn) {\n\t\t\tLIST_FOREACH_SAFE(ifa, &ifn->ifalist, next_ifa, nifa) {\n\t\t\t\t/* free the ifa */\n\t\t\t\tLIST_REMOVE(ifa, next_bucket);\n\t\t\t\tLIST_REMOVE(ifa, next_ifa);\n\t\t\t\tSCTP_FREE(ifa, SCTP_M_IFA);\n\t\t\t}\n\t\t\t/* free the ifn */\n\t\t\tLIST_REMOVE(ifn, next_bucket);\n\t\t\tLIST_REMOVE(ifn, next_ifn);\n\t\t\tSCTP_FREE(ifn, SCTP_M_IFN);\n\t\t}\n\t\tSCTP_HASH_FREE(vrf->vrf_addr_hash, vrf->vrf_addr_hashmark);\n\t\t/* free the vrf */\n\t\tLIST_REMOVE(vrf, next_vrf);\n\t\tSCTP_FREE(vrf, SCTP_M_VRF);\n\t}\n\t/* free the vrf hashes */\n\tSCTP_HASH_FREE(SCTP_BASE_INFO(sctp_vrfhash), SCTP_BASE_INFO(hashvrfmark));\n\tSCTP_HASH_FREE(SCTP_BASE_INFO(vrf_ifn_hash), SCTP_BASE_INFO(vrf_ifn_hashmark));\n\n\t/* free the TIMEWAIT list elements malloc'd in the function\n\t * sctp_add_vtag_to_timewait()...\n\t */\n\tfor (i = 0; i < SCTP_STACK_VTAG_HASH_SIZE; i++) {\n\t\tchain = &SCTP_BASE_INFO(vtag_timewait)[i];\n\t\tif (!LIST_EMPTY(chain)) {\n\t\t\tprev_twait_block = NULL;\n\t\t\tLIST_FOREACH(twait_block, chain, sctp_nxt_tagblock) {\n\t\t\t\tif (prev_twait_block) {\n\t\t\t\t\tSCTP_FREE(prev_twait_block, SCTP_M_TIMW);\n\t\t\t\t}\n\t\t\t\tprev_twait_block = twait_block;\n\t\t\t}\n\t\t\tSCTP_FREE(prev_twait_block, SCTP_M_TIMW);\n\t\t}\n\t}\n\n\t/* free the locks and mutexes */\n#if defined(__APPLE__)\n\tSCTP_TIMERQ_LOCK_DESTROY();\n\tSCTP_TIMERWAIT_LOCK_DESTROY();\n#endif\n#ifdef SCTP_PACKET_LOGGING\n\tSCTP_IP_PKTLOG_DESTROY();\n#endif\n\tSCTP_IPI_ADDR_DESTROY();\n#if defined(__APPLE__)\n\tSCTP_IPI_COUNT_DESTROY();\n#endif\n\tSCTP_STATLOG_DESTROY();\n\tSCTP_INP_INFO_LOCK_DESTROY();\n\n\tSCTP_WQ_ADDR_DESTROY();\n\n#if defined(__APPLE__)\n#if defined(APPLE_LEOPARD) || defined(APPLE_SNOWLEOPARD) || defined(APPLE_LION) || defined(APPLE_MOUNTAINLION)\n\tlck_grp_attr_free(SCTP_BASE_INFO(sctbinfo).mtx_grp_attr);\n\tlck_grp_free(SCTP_BASE_INFO(sctbinfo).mtx_grp);\n\tlck_attr_free(SCTP_BASE_INFO(sctbinfo).mtx_attr);\n#else\n\tlck_grp_attr_free(SCTP_BASE_INFO(sctbinfo).ipi_lock_grp_attr);\n\tlck_grp_free(SCTP_BASE_INFO(sctbinfo).ipi_lock_grp);\n\tlck_attr_free(SCTP_BASE_INFO(sctbinfo).ipi_lock_attr);\n#endif\n#endif\n#if defined(__Userspace__)\n\tSCTP_TIMERQ_LOCK_DESTROY();\n\tSCTP_TIMERWAIT_LOCK_DESTROY();\n\tSCTP_ZONE_DESTROY(zone_mbuf);\n\tSCTP_ZONE_DESTROY(zone_clust);\n\tSCTP_ZONE_DESTROY(zone_ext_refcnt);\n#endif\n\t/* Get rid of other stuff too. */\n\tif (SCTP_BASE_INFO(sctp_asochash) != NULL)\n\t\tSCTP_HASH_FREE(SCTP_BASE_INFO(sctp_asochash), SCTP_BASE_INFO(hashasocmark));\n\tif (SCTP_BASE_INFO(sctp_ephash) != NULL)\n\t\tSCTP_HASH_FREE(SCTP_BASE_INFO(sctp_ephash), SCTP_BASE_INFO(hashmark));\n\tif (SCTP_BASE_INFO(sctp_tcpephash) != NULL)\n\t\tSCTP_HASH_FREE(SCTP_BASE_INFO(sctp_tcpephash), SCTP_BASE_INFO(hashtcpmark));\n\n#if defined(__Windows__) || defined(__FreeBSD__) || defined(__Userspace__)\n\tSCTP_ZONE_DESTROY(SCTP_BASE_INFO(ipi_zone_ep));\n\tSCTP_ZONE_DESTROY(SCTP_BASE_INFO(ipi_zone_asoc));\n\tSCTP_ZONE_DESTROY(SCTP_BASE_INFO(ipi_zone_laddr));\n\tSCTP_ZONE_DESTROY(SCTP_BASE_INFO(ipi_zone_net));\n\tSCTP_ZONE_DESTROY(SCTP_BASE_INFO(ipi_zone_chunk));\n\tSCTP_ZONE_DESTROY(SCTP_BASE_INFO(ipi_zone_readq));\n\tSCTP_ZONE_DESTROY(SCTP_BASE_INFO(ipi_zone_strmoq));\n\tSCTP_ZONE_DESTROY(SCTP_BASE_INFO(ipi_zone_asconf));\n\tSCTP_ZONE_DESTROY(SCTP_BASE_INFO(ipi_zone_asconf_ack));\n#endif\n#if defined(__FreeBSD__) && defined(SMP) && defined(SCTP_USE_PERCPU_STAT)\n\tSCTP_FREE(SCTP_BASE_STATS, SCTP_M_MCORE);\n#endif\n}\n\n\nint\nsctp_load_addresses_from_init(struct sctp_tcb *stcb, struct mbuf *m,\n                              int offset, int limit,\n                              struct sockaddr *src, struct sockaddr *dst,\n                              struct sockaddr *altsa, uint16_t port)\n{\n\t/*\n\t * grub through the INIT pulling addresses and loading them to the\n\t * nets structure in the asoc. The from address in the mbuf should\n\t * also be loaded (if it is not already). This routine can be called\n\t * with either INIT or INIT-ACK's as long as the m points to the IP\n\t * packet and the offset points to the beginning of the parameters.\n\t */\n\tstruct sctp_inpcb *inp;\n\tstruct sctp_nets *net, *nnet, *net_tmp;\n\tstruct sctp_paramhdr *phdr, param_buf;\n\tstruct sctp_tcb *stcb_tmp;\n\tuint16_t ptype, plen;\n\tstruct sockaddr *sa;\n\tuint8_t random_store[SCTP_PARAM_BUFFER_SIZE];\n\tstruct sctp_auth_random *p_random = NULL;\n\tuint16_t random_len = 0;\n\tuint8_t hmacs_store[SCTP_PARAM_BUFFER_SIZE];\n\tstruct sctp_auth_hmac_algo *hmacs = NULL;\n\tuint16_t hmacs_len = 0;\n\tuint8_t saw_asconf = 0;\n\tuint8_t saw_asconf_ack = 0;\n\tuint8_t chunks_store[SCTP_PARAM_BUFFER_SIZE];\n\tstruct sctp_auth_chunk_list *chunks = NULL;\n\tuint16_t num_chunks = 0;\n\tsctp_key_t *new_key;\n\tuint32_t keylen;\n\tint got_random = 0, got_hmacs = 0, got_chklist = 0;\n\tuint8_t peer_supports_ecn;\n\tuint8_t peer_supports_prsctp;\n\tuint8_t peer_supports_auth;\n\tuint8_t peer_supports_asconf;\n\tuint8_t peer_supports_asconf_ack;\n\tuint8_t peer_supports_reconfig;\n\tuint8_t peer_supports_nrsack;\n\tuint8_t peer_supports_pktdrop;\n\tuint8_t peer_supports_idata;\n#ifdef INET\n\tstruct sockaddr_in sin;\n#endif\n#ifdef INET6\n\tstruct sockaddr_in6 sin6;\n#endif\n\n\t/* First get the destination address setup too. */\n#ifdef INET\n\tmemset(&sin, 0, sizeof(sin));\n\tsin.sin_family = AF_INET;\n#ifdef HAVE_SIN_LEN\n\tsin.sin_len = sizeof(sin);\n#endif\n\tsin.sin_port = stcb->rport;\n#endif\n#ifdef INET6\n\tmemset(&sin6, 0, sizeof(sin6));\n\tsin6.sin6_family = AF_INET6;\n#ifdef HAVE_SIN6_LEN\n\tsin6.sin6_len = sizeof(struct sockaddr_in6);\n#endif\n\tsin6.sin6_port = stcb->rport;\n#endif\n\tif (altsa) {\n\t\tsa = altsa;\n\t} else {\n\t\tsa = src;\n\t}\n\tpeer_supports_idata = 0;\n\tpeer_supports_ecn = 0;\n\tpeer_supports_prsctp = 0;\n\tpeer_supports_auth = 0;\n\tpeer_supports_asconf = 0;\n\tpeer_supports_reconfig = 0;\n\tpeer_supports_nrsack = 0;\n\tpeer_supports_pktdrop = 0;\n\tTAILQ_FOREACH(net, &stcb->asoc.nets, sctp_next) {\n\t\t/* mark all addresses that we have currently on the list */\n\t\tnet->dest_state |= SCTP_ADDR_NOT_IN_ASSOC;\n\t}\n\t/* does the source address already exist? if so skip it */\n\tinp = stcb->sctp_ep;\n\tatomic_add_int(&stcb->asoc.refcnt, 1);\n\tstcb_tmp = sctp_findassociation_ep_addr(&inp, sa, &net_tmp, dst, stcb);\n\tatomic_add_int(&stcb->asoc.refcnt, -1);\n\n\tif ((stcb_tmp == NULL && inp == stcb->sctp_ep) || inp == NULL) {\n\t\t/* we must add the source address */\n\t\t/* no scope set here since we have a tcb already. */\n\t\tswitch (sa->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tif (stcb->asoc.scope.ipv4_addr_legal) {\n\t\t\t\tif (sctp_add_remote_addr(stcb, sa, NULL, port, SCTP_DONOT_SETSCOPE, SCTP_LOAD_ADDR_2)) {\n\t\t\t\t\treturn (-1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n#endif\n#ifdef INET6\n\t\tcase AF_INET6:\n\t\t\tif (stcb->asoc.scope.ipv6_addr_legal) {\n\t\t\t\tif (sctp_add_remote_addr(stcb, sa, NULL, port, SCTP_DONOT_SETSCOPE, SCTP_LOAD_ADDR_3)) {\n\t\t\t\t\treturn (-2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n#endif\n#if defined(__Userspace__)\n\t\tcase AF_CONN:\n\t\t\tif (stcb->asoc.scope.conn_addr_legal) {\n\t\t\t\tif (sctp_add_remote_addr(stcb, sa, NULL, port, SCTP_DONOT_SETSCOPE, SCTP_LOAD_ADDR_3)) {\n\t\t\t\t\treturn (-2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tif (net_tmp != NULL && stcb_tmp == stcb) {\n\t\t\tnet_tmp->dest_state &= ~SCTP_ADDR_NOT_IN_ASSOC;\n\t\t} else if (stcb_tmp != stcb) {\n\t\t\t/* It belongs to another association? */\n\t\t\tif (stcb_tmp)\n\t\t\t\tSCTP_TCB_UNLOCK(stcb_tmp);\n\t\t\treturn (-3);\n\t\t}\n\t}\n\tif (stcb->asoc.state == 0) {\n\t\t/* the assoc was freed? */\n\t\treturn (-4);\n\t}\n\t/* now we must go through each of the params. */\n\tphdr = sctp_get_next_param(m, offset, &param_buf, sizeof(param_buf));\n\twhile (phdr) {\n\t\tptype = ntohs(phdr->param_type);\n\t\tplen = ntohs(phdr->param_length);\n\t\t/*\n\t\t * SCTP_PRINTF(\"ptype => %0x, plen => %d\\n\", (uint32_t)ptype,\n\t\t * (int)plen);\n\t\t */\n\t\tif (offset + plen > limit) {\n\t\t\tbreak;\n\t\t}\n\t\tif (plen < sizeof(struct sctp_paramhdr)) {\n\t\t\tbreak;\n\t\t}\n#ifdef INET\n\t\tif (ptype == SCTP_IPV4_ADDRESS) {\n\t\t\tif (stcb->asoc.scope.ipv4_addr_legal) {\n\t\t\t\tstruct sctp_ipv4addr_param *p4, p4_buf;\n\n\t\t\t\t/* ok get the v4 address and check/add */\n\t\t\t\tphdr = sctp_get_next_param(m, offset,\n\t\t\t\t\t\t\t   (struct sctp_paramhdr *)&p4_buf,\n\t\t\t\t\t\t\t   sizeof(p4_buf));\n\t\t\t\tif (plen != sizeof(struct sctp_ipv4addr_param) ||\n\t\t\t\t    phdr == NULL) {\n\t\t\t\t\treturn (-5);\n\t\t\t\t}\n\t\t\t\tp4 = (struct sctp_ipv4addr_param *)phdr;\n\t\t\t\tsin.sin_addr.s_addr = p4->addr;\n\t\t\t\tif (IN_MULTICAST(ntohl(sin.sin_addr.s_addr))) {\n\t\t\t\t\t/* Skip multi-cast addresses */\n\t\t\t\t\tgoto next_param;\n\t\t\t\t}\n\t\t\t\tif ((sin.sin_addr.s_addr == INADDR_BROADCAST) ||\n\t\t\t\t    (sin.sin_addr.s_addr == INADDR_ANY)) {\n\t\t\t\t\tgoto next_param;\n\t\t\t\t}\n\t\t\t\tsa = (struct sockaddr *)&sin;\n\t\t\t\tinp = stcb->sctp_ep;\n\t\t\t\tatomic_add_int(&stcb->asoc.refcnt, 1);\n\t\t\t\tstcb_tmp = sctp_findassociation_ep_addr(&inp, sa, &net,\n\t\t\t\t\t\t\t\t\tdst, stcb);\n\t\t\t\tatomic_add_int(&stcb->asoc.refcnt, -1);\n\n\t\t\t\tif ((stcb_tmp == NULL && inp == stcb->sctp_ep) ||\n\t\t\t\t    inp == NULL) {\n\t\t\t\t\t/* we must add the source address */\n\t\t\t\t\t/*\n\t\t\t\t\t * no scope set since we have a tcb\n\t\t\t\t\t * already\n\t\t\t\t\t */\n\n\t\t\t\t\t/*\n\t\t\t\t\t * we must validate the state again\n\t\t\t\t\t * here\n\t\t\t\t\t */\n\t\t\t\tadd_it_now:\n\t\t\t\t\tif (stcb->asoc.state == 0) {\n\t\t\t\t\t\t/* the assoc was freed? */\n\t\t\t\t\t\treturn (-7);\n\t\t\t\t\t}\n\t\t\t\t\tif (sctp_add_remote_addr(stcb, sa, NULL, port, SCTP_DONOT_SETSCOPE, SCTP_LOAD_ADDR_4)) {\n\t\t\t\t\t\treturn (-8);\n\t\t\t\t\t}\n\t\t\t\t} else if (stcb_tmp == stcb) {\n\t\t\t\t\tif (stcb->asoc.state == 0) {\n\t\t\t\t\t\t/* the assoc was freed? */\n\t\t\t\t\t\treturn (-10);\n\t\t\t\t\t}\n\t\t\t\t\tif (net != NULL) {\n\t\t\t\t\t\t/* clear flag */\n\t\t\t\t\t\tnet->dest_state &=\n\t\t\t\t\t\t\t~SCTP_ADDR_NOT_IN_ASSOC;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t * strange, address is in another\n\t\t\t\t\t * assoc? straighten out locks.\n\t\t\t\t\t */\n\t\t\t\t\tif (stcb_tmp) {\n\t\t\t\t\t\tif (SCTP_GET_STATE(stcb_tmp) == SCTP_STATE_COOKIE_WAIT) {\n\t\t\t\t\t\t\tstruct mbuf *op_err;\n\t\t\t\t\t\t\tchar msg[SCTP_DIAG_INFO_LEN];\n\n\t\t\t\t\t\t\t/* in setup state we abort this guy */\n\t\t\t\t\t\t\tsnprintf(msg, sizeof(msg),\n\t\t\t\t\t\t\t         \"%s:%d at %s\", __FILE__, __LINE__, __func__);\n\t\t\t\t\t\t\top_err = sctp_generate_cause(SCTP_BASE_SYSCTL(sctp_diag_info_code),\n\t\t\t\t\t\t\t         msg);\n\t\t\t\t\t\t\tsctp_abort_an_association(stcb_tmp->sctp_ep,\n\t\t\t\t\t\t\t\t\t\t  stcb_tmp, op_err,\n\t\t\t\t\t\t\t                          SCTP_SO_NOT_LOCKED);\n\t\t\t\t\t\t\tgoto add_it_now;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tSCTP_TCB_UNLOCK(stcb_tmp);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (stcb->asoc.state == 0) {\n\t\t\t\t\t\t/* the assoc was freed? */\n\t\t\t\t\t\treturn (-12);\n\t\t\t\t\t}\n\t\t\t\t\treturn (-13);\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n#endif\n#ifdef INET6\n\t\tif (ptype == SCTP_IPV6_ADDRESS) {\n\t\t\tif (stcb->asoc.scope.ipv6_addr_legal) {\n\t\t\t\t/* ok get the v6 address and check/add */\n\t\t\t\tstruct sctp_ipv6addr_param *p6, p6_buf;\n\n\t\t\t\tphdr = sctp_get_next_param(m, offset,\n\t\t\t\t\t\t\t   (struct sctp_paramhdr *)&p6_buf,\n\t\t\t\t\t\t\t   sizeof(p6_buf));\n\t\t\t\tif (plen != sizeof(struct sctp_ipv6addr_param) ||\n\t\t\t\t    phdr == NULL) {\n\t\t\t\t\treturn (-14);\n\t\t\t\t}\n\t\t\t\tp6 = (struct sctp_ipv6addr_param *)phdr;\n\t\t\t\tmemcpy((caddr_t)&sin6.sin6_addr, p6->addr,\n\t\t\t\t       sizeof(p6->addr));\n\t\t\t\tif (IN6_IS_ADDR_MULTICAST(&sin6.sin6_addr)) {\n\t\t\t\t\t/* Skip multi-cast addresses */\n\t\t\t\t\tgoto next_param;\n\t\t\t\t}\n\t\t\t\tif (IN6_IS_ADDR_LINKLOCAL(&sin6.sin6_addr)) {\n\t\t\t\t\t/* Link local make no sense without scope */\n\t\t\t\t\tgoto next_param;\n\t\t\t\t}\n\t\t\t\tsa = (struct sockaddr *)&sin6;\n\t\t\t\tinp = stcb->sctp_ep;\n\t\t\t\tatomic_add_int(&stcb->asoc.refcnt, 1);\n\t\t\t\tstcb_tmp = sctp_findassociation_ep_addr(&inp, sa, &net,\n\t\t\t\t\t\t\t\t\tdst, stcb);\n\t\t\t\tatomic_add_int(&stcb->asoc.refcnt, -1);\n\t\t\t\tif (stcb_tmp == NULL &&\n\t\t\t\t    (inp == stcb->sctp_ep || inp == NULL)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * we must validate the state again\n\t\t\t\t\t * here\n\t\t\t\t\t */\n\t\t\t\tadd_it_now6:\n\t\t\t\t\tif (stcb->asoc.state == 0) {\n\t\t\t\t\t\t/* the assoc was freed? */\n\t\t\t\t\t\treturn (-16);\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * we must add the address, no scope\n\t\t\t\t\t * set\n\t\t\t\t\t */\n\t\t\t\t\tif (sctp_add_remote_addr(stcb, sa, NULL, port, SCTP_DONOT_SETSCOPE, SCTP_LOAD_ADDR_5)) {\n\t\t\t\t\t\treturn (-17);\n\t\t\t\t\t}\n\t\t\t\t} else if (stcb_tmp == stcb) {\n\t\t\t\t\t/*\n\t\t\t\t\t * we must validate the state again\n\t\t\t\t\t * here\n\t\t\t\t\t */\n\t\t\t\t\tif (stcb->asoc.state == 0) {\n\t\t\t\t\t\t/* the assoc was freed? */\n\t\t\t\t\t\treturn (-19);\n\t\t\t\t\t}\n\t\t\t\t\tif (net != NULL) {\n\t\t\t\t\t\t/* clear flag */\n\t\t\t\t\t\tnet->dest_state &=\n\t\t\t\t\t\t\t~SCTP_ADDR_NOT_IN_ASSOC;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t * strange, address is in another\n\t\t\t\t\t * assoc? straighten out locks.\n\t\t\t\t\t */\n\t\t\t\t\tif (stcb_tmp) {\n\t\t\t\t\t\tif (SCTP_GET_STATE(stcb_tmp) == SCTP_STATE_COOKIE_WAIT) {\n\t\t\t\t\t\t\tstruct mbuf *op_err;\n\t\t\t\t\t\t\tchar msg[SCTP_DIAG_INFO_LEN];\n\n\t\t\t\t\t\t\t/* in setup state we abort this guy */\n\t\t\t\t\t\t\tsnprintf(msg, sizeof(msg),\n\t\t\t\t\t\t\t         \"%s:%d at %s\", __FILE__, __LINE__, __func__);\n\t\t\t\t\t\t\top_err = sctp_generate_cause(SCTP_BASE_SYSCTL(sctp_diag_info_code),\n\t\t\t\t\t\t\t         msg);\n\t\t\t\t\t\t\tsctp_abort_an_association(stcb_tmp->sctp_ep,\n\t\t\t\t\t\t\t\t\t\t  stcb_tmp, op_err,\n\t\t\t\t\t\t\t                          SCTP_SO_NOT_LOCKED);\n\t\t\t\t\t\t\tgoto add_it_now6;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tSCTP_TCB_UNLOCK(stcb_tmp);\n\t\t\t\t\t}\n\t\t\t\t\tif (stcb->asoc.state == 0) {\n\t\t\t\t\t\t/* the assoc was freed? */\n\t\t\t\t\t\treturn (-21);\n\t\t\t\t\t}\n\t\t\t\t\treturn (-22);\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n#endif\n\t\tif (ptype == SCTP_ECN_CAPABLE) {\n\t\t\tpeer_supports_ecn = 1;\n\t\t} else if (ptype == SCTP_ULP_ADAPTATION) {\n\t\t\tif (stcb->asoc.state != SCTP_STATE_OPEN) {\n\t\t\t\tstruct sctp_adaptation_layer_indication ai, *aip;\n\n\t\t\t\tphdr = sctp_get_next_param(m, offset,\n\t\t\t\t\t\t\t   (struct sctp_paramhdr *)&ai, sizeof(ai));\n\t\t\t\taip = (struct sctp_adaptation_layer_indication *)phdr;\n\t\t\t\tif (aip) {\n\t\t\t\t\tstcb->asoc.peers_adaptation = ntohl(aip->indication);\n\t\t\t\t\tstcb->asoc.adaptation_needed = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (ptype == SCTP_SET_PRIM_ADDR) {\n\t\t\tstruct sctp_asconf_addr_param lstore, *fee;\n\t\t\tint lptype;\n\t\t\tstruct sockaddr *lsa = NULL;\n#ifdef INET\n\t\t\tstruct sctp_asconf_addrv4_param *fii;\n#endif\n\n\t\t\tif (stcb->asoc.asconf_supported == 0) {\n\t\t\t\treturn (-100);\n\t\t\t}\n\t\t\tif (plen > sizeof(lstore)) {\n\t\t\t\treturn (-23);\n\t\t\t}\n\t\t\tif (plen < sizeof(struct sctp_asconf_addrv4_param)) {\n\t\t\t\treturn (-101);\n\t\t\t}\n\t\t\tphdr = sctp_get_next_param(m, offset,\n\t\t\t\t\t\t   (struct sctp_paramhdr *)&lstore,\n\t\t\t\t\t\t   plen);\n\t\t\tif (phdr == NULL) {\n\t\t\t\treturn (-24);\n\t\t\t}\n\t\t\tfee = (struct sctp_asconf_addr_param *)phdr;\n\t\t\tlptype = ntohs(fee->addrp.ph.param_type);\n\t\t\tswitch (lptype) {\n#ifdef INET\n\t\t\tcase SCTP_IPV4_ADDRESS:\n\t\t\t\tif (plen !=\n\t\t\t\t    sizeof(struct sctp_asconf_addrv4_param)) {\n\t\t\t\t\tSCTP_PRINTF(\"Sizeof setprim in init/init ack not %d but %d - ignored\\n\",\n\t\t\t\t\t\t    (int)sizeof(struct sctp_asconf_addrv4_param),\n\t\t\t\t\t\t    plen);\n\t\t\t\t} else {\n\t\t\t\t\tfii = (struct sctp_asconf_addrv4_param *)fee;\n\t\t\t\t\tsin.sin_addr.s_addr = fii->addrp.addr;\n\t\t\t\t\tlsa = (struct sockaddr *)&sin;\n\t\t\t\t}\n\t\t\t\tbreak;\n#endif\n#ifdef INET6\n\t\t\tcase SCTP_IPV6_ADDRESS:\n\t\t\t\tif (plen !=\n\t\t\t\t    sizeof(struct sctp_asconf_addr_param)) {\n\t\t\t\t\tSCTP_PRINTF(\"Sizeof setprim (v6) in init/init ack not %d but %d - ignored\\n\",\n\t\t\t\t\t\t    (int)sizeof(struct sctp_asconf_addr_param),\n\t\t\t\t\t\t    plen);\n\t\t\t\t} else {\n\t\t\t\t\tmemcpy(sin6.sin6_addr.s6_addr,\n\t\t\t\t\t       fee->addrp.addr,\n\t\t\t\t\t       sizeof(fee->addrp.addr));\n\t\t\t\t\tlsa = (struct sockaddr *)&sin6;\n\t\t\t\t}\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (lsa) {\n\t\t\t\t(void)sctp_set_primary_addr(stcb, sa, NULL);\n\t\t\t}\n\t\t} else if (ptype == SCTP_HAS_NAT_SUPPORT) {\n\t\t\tstcb->asoc.peer_supports_nat = 1;\n\t\t} else if (ptype == SCTP_PRSCTP_SUPPORTED) {\n\t\t\t/* Peer supports pr-sctp */\n\t\t\tpeer_supports_prsctp = 1;\n\t\t} else if (ptype == SCTP_SUPPORTED_CHUNK_EXT) {\n\t\t\t/* A supported extension chunk */\n\t\t\tstruct sctp_supported_chunk_types_param *pr_supported;\n\t\t\tuint8_t local_store[SCTP_PARAM_BUFFER_SIZE];\n\t\t\tint num_ent, i;\n\n\t\t\tif (plen > sizeof(local_store)) {\n\t\t\t\treturn (-35);\n\t\t\t}\n\t\t\tphdr = sctp_get_next_param(m, offset,\n\t\t\t\t\t\t   (struct sctp_paramhdr *)&local_store, plen);\n\t\t\tif (phdr == NULL) {\n\t\t\t\treturn (-25);\n\t\t\t}\n\t\t\tpr_supported = (struct sctp_supported_chunk_types_param *)phdr;\n\t\t\tnum_ent = plen - sizeof(struct sctp_paramhdr);\n\t\t\tfor (i = 0; i < num_ent; i++) {\n\t\t\t\tswitch (pr_supported->chunk_types[i]) {\n\t\t\t\tcase SCTP_ASCONF:\n\t\t\t\t\tpeer_supports_asconf = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SCTP_ASCONF_ACK:\n\t\t\t\t\tpeer_supports_asconf_ack = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SCTP_FORWARD_CUM_TSN:\n\t\t\t\t\tpeer_supports_prsctp = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SCTP_PACKET_DROPPED:\n\t\t\t\t\tpeer_supports_pktdrop = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SCTP_NR_SELECTIVE_ACK:\n\t\t\t\t\tpeer_supports_nrsack = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SCTP_STREAM_RESET:\n\t\t\t\t\tpeer_supports_reconfig = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SCTP_AUTHENTICATION:\n\t\t\t\t\tpeer_supports_auth = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SCTP_IDATA:\n\t\t\t\t\tpeer_supports_idata = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t/* one I have not learned yet */\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (ptype == SCTP_RANDOM) {\n\t\t\tif (plen > sizeof(random_store))\n\t\t\t\tbreak;\n\t\t\tif (got_random) {\n\t\t\t\t/* already processed a RANDOM */\n\t\t\t\tgoto next_param;\n\t\t\t}\n\t\t\tphdr = sctp_get_next_param(m, offset,\n\t\t\t\t\t\t   (struct sctp_paramhdr *)random_store,\n\t\t\t\t\t\t   plen);\n\t\t\tif (phdr == NULL)\n\t\t\t\treturn (-26);\n\t\t\tp_random = (struct sctp_auth_random *)phdr;\n\t\t\trandom_len = plen - sizeof(*p_random);\n\t\t\t/* enforce the random length */\n\t\t\tif (random_len != SCTP_AUTH_RANDOM_SIZE_REQUIRED) {\n\t\t\t\tSCTPDBG(SCTP_DEBUG_AUTH1, \"SCTP: invalid RANDOM len\\n\");\n\t\t\t\treturn (-27);\n\t\t\t}\n\t\t\tgot_random = 1;\n\t\t} else if (ptype == SCTP_HMAC_LIST) {\n\t\t\tuint16_t num_hmacs;\n\t\t\tuint16_t i;\n\n\t\t\tif (plen > sizeof(hmacs_store))\n\t\t\t\tbreak;\n\t\t\tif (got_hmacs) {\n\t\t\t\t/* already processed a HMAC list */\n\t\t\t\tgoto next_param;\n\t\t\t}\n\t\t\tphdr = sctp_get_next_param(m, offset,\n\t\t\t\t\t\t   (struct sctp_paramhdr *)hmacs_store,\n\t\t\t\t\t\t   plen);\n\t\t\tif (phdr == NULL)\n\t\t\t\treturn (-28);\n\t\t\thmacs = (struct sctp_auth_hmac_algo *)phdr;\n\t\t\thmacs_len = plen - sizeof(*hmacs);\n\t\t\tnum_hmacs = hmacs_len / sizeof(hmacs->hmac_ids[0]);\n\t\t\t/* validate the hmac list */\n\t\t\tif (sctp_verify_hmac_param(hmacs, num_hmacs)) {\n\t\t\t\treturn (-29);\n\t\t\t}\n\t\t\tif (stcb->asoc.peer_hmacs != NULL)\n\t\t\t\tsctp_free_hmaclist(stcb->asoc.peer_hmacs);\n\t\t\tstcb->asoc.peer_hmacs = sctp_alloc_hmaclist(num_hmacs);\n\t\t\tif (stcb->asoc.peer_hmacs != NULL) {\n\t\t\t\tfor (i = 0; i < num_hmacs; i++) {\n\t\t\t\t\t(void)sctp_auth_add_hmacid(stcb->asoc.peer_hmacs,\n\t\t\t\t\t\t\t\t   ntohs(hmacs->hmac_ids[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tgot_hmacs = 1;\n\t\t} else if (ptype == SCTP_CHUNK_LIST) {\n\t\t\tint i;\n\n\t\t\tif (plen > sizeof(chunks_store))\n\t\t\t\tbreak;\n\t\t\tif (got_chklist) {\n\t\t\t\t/* already processed a Chunks list */\n\t\t\t\tgoto next_param;\n\t\t\t}\n\t\t\tphdr = sctp_get_next_param(m, offset,\n\t\t\t\t\t\t   (struct sctp_paramhdr *)chunks_store,\n\t\t\t\t\t\t   plen);\n\t\t\tif (phdr == NULL)\n\t\t\t\treturn (-30);\n\t\t\tchunks = (struct sctp_auth_chunk_list *)phdr;\n\t\t\tnum_chunks = plen - sizeof(*chunks);\n\t\t\tif (stcb->asoc.peer_auth_chunks != NULL)\n\t\t\t\tsctp_clear_chunklist(stcb->asoc.peer_auth_chunks);\n\t\t\telse\n\t\t\t\tstcb->asoc.peer_auth_chunks = sctp_alloc_chunklist();\n\t\t\tfor (i = 0; i < num_chunks; i++) {\n\t\t\t\t(void)sctp_auth_add_chunk(chunks->chunk_types[i],\n\t\t\t\t\t\t\t  stcb->asoc.peer_auth_chunks);\n\t\t\t\t/* record asconf/asconf-ack if listed */\n\t\t\t\tif (chunks->chunk_types[i] == SCTP_ASCONF)\n\t\t\t\t\tsaw_asconf = 1;\n\t\t\t\tif (chunks->chunk_types[i] == SCTP_ASCONF_ACK)\n\t\t\t\t\tsaw_asconf_ack = 1;\n\n\t\t\t}\n\t\t\tgot_chklist = 1;\n\t\t} else if ((ptype == SCTP_HEARTBEAT_INFO) ||\n\t\t\t   (ptype == SCTP_STATE_COOKIE) ||\n\t\t\t   (ptype == SCTP_UNRECOG_PARAM) ||\n\t\t\t   (ptype == SCTP_COOKIE_PRESERVE) ||\n\t\t\t   (ptype == SCTP_SUPPORTED_ADDRTYPE) ||\n\t\t\t   (ptype == SCTP_ADD_IP_ADDRESS) ||\n\t\t\t   (ptype == SCTP_DEL_IP_ADDRESS) ||\n\t\t\t   (ptype == SCTP_ERROR_CAUSE_IND) ||\n\t\t\t   (ptype == SCTP_SUCCESS_REPORT)) {\n\t\t\t/* don't care */ ;\n\t\t} else {\n\t\t\tif ((ptype & 0x8000) == 0x0000) {\n\t\t\t\t/*\n\t\t\t\t * must stop processing the rest of the\n\t\t\t\t * param's. Any report bits were handled\n\t\t\t\t * with the call to\n\t\t\t\t * sctp_arethere_unrecognized_parameters()\n\t\t\t\t * when the INIT or INIT-ACK was first seen.\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\tnext_param:\n\t\toffset += SCTP_SIZE32(plen);\n\t\tif (offset >= limit) {\n\t\t\tbreak;\n\t\t}\n\t\tphdr = sctp_get_next_param(m, offset, &param_buf,\n\t\t\t\t\t   sizeof(param_buf));\n\t}\n\t/* Now check to see if we need to purge any addresses */\n\tTAILQ_FOREACH_SAFE(net, &stcb->asoc.nets, sctp_next, nnet) {\n\t\tif ((net->dest_state & SCTP_ADDR_NOT_IN_ASSOC) ==\n\t\t    SCTP_ADDR_NOT_IN_ASSOC) {\n\t\t\t/* This address has been removed from the asoc */\n\t\t\t/* remove and free it */\n\t\t\tstcb->asoc.numnets--;\n\t\t\tTAILQ_REMOVE(&stcb->asoc.nets, net, sctp_next);\n\t\t\tsctp_free_remote_addr(net);\n\t\t\tif (net == stcb->asoc.primary_destination) {\n\t\t\t\tstcb->asoc.primary_destination = NULL;\n\t\t\t\tsctp_select_primary_destination(stcb);\n\t\t\t}\n\t\t}\n\t}\n\tif ((stcb->asoc.ecn_supported == 1) &&\n\t    (peer_supports_ecn == 0)) {\n\t\tstcb->asoc.ecn_supported = 0;\n\t}\n\tif ((stcb->asoc.prsctp_supported == 1) &&\n\t    (peer_supports_prsctp == 0)) {\n\t\tstcb->asoc.prsctp_supported = 0;\n\t}\n\tif ((stcb->asoc.auth_supported == 1) &&\n\t    ((peer_supports_auth == 0) ||\n\t     (got_random == 0) || (got_hmacs == 0))) {\n\t\tstcb->asoc.auth_supported = 0;\n\t}\n\tif ((stcb->asoc.asconf_supported == 1) &&\n\t    ((peer_supports_asconf == 0) || (peer_supports_asconf_ack == 0) ||\n\t     (stcb->asoc.auth_supported == 0) ||\n\t     (saw_asconf == 0) || (saw_asconf_ack == 0))) {\n\t\tstcb->asoc.asconf_supported = 0;\n\t}\n\tif ((stcb->asoc.reconfig_supported == 1) &&\n\t    (peer_supports_reconfig == 0)) {\n\t\tstcb->asoc.reconfig_supported = 0;\n\t}\n\tif ((stcb->asoc.idata_supported == 1) &&\n\t    (peer_supports_idata == 0)) {\n\t\tstcb->asoc.idata_supported = 0;\n\t}\n\tif ((stcb->asoc.nrsack_supported == 1) &&\n\t    (peer_supports_nrsack == 0)) {\n\t\tstcb->asoc.nrsack_supported = 0;\n\t}\n\tif ((stcb->asoc.pktdrop_supported == 1) &&\n\t    (peer_supports_pktdrop == 0)){\n\t\tstcb->asoc.pktdrop_supported = 0;\n\t}\n\t/* validate authentication required parameters */\n\tif ((peer_supports_auth == 0) && (got_chklist == 1)) {\n\t\t/* peer does not support auth but sent a chunks list? */\n\t\treturn (-31);\n\t}\n\tif ((peer_supports_asconf == 1) && (peer_supports_auth == 0)) {\n\t\t/* peer supports asconf but not auth? */\n\t\treturn (-32);\n\t} else if ((peer_supports_asconf == 1) &&\n\t           (peer_supports_auth == 1) &&\n\t\t   ((saw_asconf == 0) || (saw_asconf_ack == 0))) {\n\t\treturn (-33);\n\t}\n\t/* concatenate the full random key */\n\tkeylen = sizeof(*p_random) + random_len + sizeof(*hmacs) + hmacs_len;\n\tif (chunks != NULL) {\n\t\tkeylen += sizeof(*chunks) + num_chunks;\n\t}\n\tnew_key = sctp_alloc_key(keylen);\n\tif (new_key != NULL) {\n\t\t/* copy in the RANDOM */\n\t\tif (p_random != NULL) {\n\t\t\tkeylen = sizeof(*p_random) + random_len;\n\t\t\tmemcpy(new_key->key, p_random, keylen);\n\t\t} else {\n\t\t\tkeylen = 0;\n\t\t}\n\t\t/* append in the AUTH chunks */\n\t\tif (chunks != NULL) {\n\t\t\tmemcpy(new_key->key + keylen, chunks,\n\t\t\t       sizeof(*chunks) + num_chunks);\n\t\t\tkeylen += sizeof(*chunks) + num_chunks;\n\t\t}\n\t\t/* append in the HMACs */\n\t\tif (hmacs != NULL) {\n\t\t\tmemcpy(new_key->key + keylen, hmacs,\n\t\t\t       sizeof(*hmacs) + hmacs_len);\n\t\t}\n\t} else {\n\t\t/* failed to get memory for the key */\n\t\treturn (-34);\n\t}\n\tif (stcb->asoc.authinfo.peer_random != NULL)\n\t\tsctp_free_key(stcb->asoc.authinfo.peer_random);\n\tstcb->asoc.authinfo.peer_random = new_key;\n\tsctp_clear_cachedkeys(stcb, stcb->asoc.authinfo.assoc_keyid);\n\tsctp_clear_cachedkeys(stcb, stcb->asoc.authinfo.recv_keyid);\n\n\treturn (0);\n}\n\nint\nsctp_set_primary_addr(struct sctp_tcb *stcb, struct sockaddr *sa,\n\t\t      struct sctp_nets *net)\n{\n\t/* make sure the requested primary address exists in the assoc */\n\tif (net == NULL && sa)\n\t\tnet = sctp_findnet(stcb, sa);\n\n\tif (net == NULL) {\n\t\t/* didn't find the requested primary address! */\n\t\treturn (-1);\n\t} else {\n\t\t/* set the primary address */\n\t\tif (net->dest_state & SCTP_ADDR_UNCONFIRMED) {\n\t\t\t/* Must be confirmed, so queue to set */\n\t\t\tnet->dest_state |= SCTP_ADDR_REQ_PRIMARY;\n\t\t\treturn (0);\n\t\t}\n\t\tstcb->asoc.primary_destination = net;\n\t\tif (!(net->dest_state & SCTP_ADDR_PF) && (stcb->asoc.alternate)) {\n\t\t\tsctp_free_remote_addr(stcb->asoc.alternate);\n\t\t\tstcb->asoc.alternate = NULL;\n\t\t}\n\t\tnet = TAILQ_FIRST(&stcb->asoc.nets);\n\t\tif (net != stcb->asoc.primary_destination) {\n\t\t\t/* first one on the list is NOT the primary\n\t\t\t * sctp_cmpaddr() is much more efficient if\n\t\t\t * the primary is the first on the list, make it\n\t\t\t * so.\n\t\t\t */\n\t\t\tTAILQ_REMOVE(&stcb->asoc.nets, stcb->asoc.primary_destination, sctp_next);\n\t\t\tTAILQ_INSERT_HEAD(&stcb->asoc.nets, stcb->asoc.primary_destination, sctp_next);\n\t\t}\n\t\treturn (0);\n\t}\n}\n\nint\nsctp_is_vtag_good(uint32_t tag, uint16_t lport, uint16_t rport, struct timeval *now)\n{\n\t/*\n\t * This function serves two purposes. It will see if a TAG can be\n\t * re-used and return 1 for yes it is ok and 0 for don't use that\n\t * tag. A secondary function it will do is purge out old tags that\n\t * can be removed.\n\t */\n\tstruct sctpvtaghead *chain;\n\tstruct sctp_tagblock *twait_block;\n\tstruct sctpasochead *head;\n\tstruct sctp_tcb *stcb;\n\tint i;\n\n\tSCTP_INP_INFO_RLOCK();\n\thead = &SCTP_BASE_INFO(sctp_asochash)[SCTP_PCBHASH_ASOC(tag,\n\t\t\t\t\t\t\t\tSCTP_BASE_INFO(hashasocmark))];\n\tLIST_FOREACH(stcb, head, sctp_asocs) {\n\t\t/* We choose not to lock anything here. TCB's can't be\n\t\t * removed since we have the read lock, so they can't\n\t\t * be freed on us, same thing for the INP. I may\n\t\t * be wrong with this assumption, but we will go\n\t\t * with it for now :-)\n\t\t */\n\t\tif (stcb->sctp_ep->sctp_flags & SCTP_PCB_FLAGS_SOCKET_ALLGONE) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (stcb->asoc.my_vtag == tag) {\n\t\t\t/* candidate */\n\t\t\tif (stcb->rport != rport) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (stcb->sctp_ep->sctp_lport != lport) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* Its a used tag set */\n\t\t\tSCTP_INP_INFO_RUNLOCK();\n\t\t\treturn (0);\n\t\t}\n\t}\n\tchain = &SCTP_BASE_INFO(vtag_timewait)[(tag % SCTP_STACK_VTAG_HASH_SIZE)];\n\t/* Now what about timed wait ? */\n\tLIST_FOREACH(twait_block, chain, sctp_nxt_tagblock) {\n\t\t/*\n\t\t * Block(s) are present, lets see if we have this tag in the\n\t\t * list\n\t\t */\n\t\tfor (i = 0; i < SCTP_NUMBER_IN_VTAG_BLOCK; i++) {\n\t\t\tif (twait_block->vtag_block[i].v_tag == 0) {\n\t\t\t\t/* not used */\n\t\t\t\tcontinue;\n\t\t\t} else if ((long)twait_block->vtag_block[i].tv_sec_at_expire  <\n\t\t\t\t   now->tv_sec) {\n\t\t\t\t/* Audit expires this guy */\n\t\t\t\ttwait_block->vtag_block[i].tv_sec_at_expire = 0;\n\t\t\t\ttwait_block->vtag_block[i].v_tag = 0;\n\t\t\t\ttwait_block->vtag_block[i].lport = 0;\n\t\t\t\ttwait_block->vtag_block[i].rport = 0;\n\t\t\t} else if ((twait_block->vtag_block[i].v_tag == tag) &&\n\t\t\t\t   (twait_block->vtag_block[i].lport == lport) &&\n\t\t\t\t   (twait_block->vtag_block[i].rport == rport)) {\n\t\t\t\t/* Bad tag, sorry :< */\n\t\t\t\tSCTP_INP_INFO_RUNLOCK();\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t}\n\t}\n\tSCTP_INP_INFO_RUNLOCK();\n\treturn (1);\n}\n\nstatic void\nsctp_drain_mbufs(struct sctp_tcb *stcb)\n{\n\t/*\n\t * We must hunt this association for MBUF's past the cumack (i.e.\n\t * out of order data that we can renege on).\n\t */\n\tstruct sctp_association *asoc;\n\tstruct sctp_tmit_chunk *chk, *nchk;\n\tuint32_t cumulative_tsn_p1;\n\tstruct sctp_queued_to_read *control, *ncontrol;\n\tint cnt, strmat;\n\tuint32_t gap, i;\n\tint fnd = 0;\n\n\t/* We look for anything larger than the cum-ack + 1 */\n\n\tasoc = &stcb->asoc;\n\tif (asoc->cumulative_tsn == asoc->highest_tsn_inside_map) {\n\t\t/* none we can reneg on. */\n\t\treturn;\n\t}\n\tSCTP_STAT_INCR(sctps_protocol_drains_done);\n\tcumulative_tsn_p1 = asoc->cumulative_tsn + 1;\n\tcnt = 0;\n\t/* Ok that was fun, now we will drain all the inbound streams? */\n\tfor (strmat = 0; strmat < asoc->streamincnt; strmat++) {\n\t\tTAILQ_FOREACH_SAFE(control, &asoc->strmin[strmat].inqueue, next_instrm, ncontrol) {\n#ifdef INVARIANTS\n\t\t\tif (control->on_strm_q != SCTP_ON_ORDERED ) {\n\t\t\t\tpanic(\"Huh control: %p on_q: %d -- not ordered?\",\n\t\t\t\t      control, control->on_strm_q);\n\t\t\t}\n#endif\n\t\t\tif (SCTP_TSN_GT(control->sinfo_tsn, cumulative_tsn_p1)) {\n\t\t\t\t/* Yep it is above cum-ack */\n\t\t\t\tcnt++;\n\t\t\t\tSCTP_CALC_TSN_TO_GAP(gap, control->sinfo_tsn, asoc->mapping_array_base_tsn);\n\t\t\t\tKASSERT(control->length > 0, (\"control has zero length\"));\n\t\t\t\tif (asoc->size_on_all_streams >= control->length) {\n\t\t\t\t\tasoc->size_on_all_streams -= control->length;\n\t\t\t\t} else {\n#ifdef INVARIANTS\n\t\t\t\t\tpanic(\"size_on_all_streams = %u smaller than control length %u\", asoc->size_on_all_streams, control->length);\n#else\n\t\t\t\t\tasoc->size_on_all_streams = 0;\n#endif\n\t\t\t\t}\n\t\t\t\tsctp_ucount_decr(asoc->cnt_on_all_streams);\n\t\t\t\tSCTP_UNSET_TSN_PRESENT(asoc->mapping_array, gap);\n\t\t\t\tif (control->on_read_q) {\n\t\t\t\t\tTAILQ_REMOVE(&stcb->sctp_ep->read_queue, control, next);\n\t\t\t\t\tcontrol->on_read_q = 0;\n\t\t\t\t}\n\t\t\t\tTAILQ_REMOVE(&asoc->strmin[strmat].inqueue, control, next_instrm);\n\t\t\t\tcontrol->on_strm_q = 0;\n\t\t\t\tif (control->data) {\n\t\t\t\t\tsctp_m_freem(control->data);\n\t\t\t\t\tcontrol->data = NULL;\n\t\t\t\t}\n\t\t\t\tsctp_free_remote_addr(control->whoFrom);\n\t\t\t\t/* Now its reasm? */\n\t\t\t\tTAILQ_FOREACH_SAFE(chk, &control->reasm, sctp_next, nchk) {\n\t\t\t\t\tcnt++;\n\t\t\t\t\tSCTP_CALC_TSN_TO_GAP(gap, chk->rec.data.tsn, asoc->mapping_array_base_tsn);\n\t\t\t\t\tKASSERT(chk->send_size > 0, (\"chunk has zero length\"));\n\t\t\t\t\tif (asoc->size_on_reasm_queue >= chk->send_size) {\n\t\t\t\t\t\tasoc->size_on_reasm_queue -= chk->send_size;\n\t\t\t\t\t} else {\n#ifdef INVARIANTS\n\t\t\t\t\t\tpanic(\"size_on_reasm_queue = %u smaller than chunk length %u\", asoc->size_on_reasm_queue, chk->send_size);\n#else\n\t\t\t\t\t\tasoc->size_on_reasm_queue = 0;\n#endif\n\t\t\t\t\t}\n\t\t\t\t\tsctp_ucount_decr(asoc->cnt_on_reasm_queue);\n\t\t\t\t\tSCTP_UNSET_TSN_PRESENT(asoc->mapping_array, gap);\n\t\t\t\t\tTAILQ_REMOVE(&control->reasm, chk, sctp_next);\n\t\t\t\t\tif (chk->data) {\n\t\t\t\t\t\tsctp_m_freem(chk->data);\n\t\t\t\t\t\tchk->data = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tsctp_free_a_chunk(stcb, chk, SCTP_SO_NOT_LOCKED);\n\t\t\t\t}\n\t\t\t\tsctp_free_a_readq(stcb, control);\n\t\t\t}\n\t\t}\n\t\tTAILQ_FOREACH_SAFE(control, &asoc->strmin[strmat].uno_inqueue, next_instrm, ncontrol) {\n#ifdef INVARIANTS\n\t\t\tif (control->on_strm_q != SCTP_ON_UNORDERED ) {\n\t\t\t\tpanic(\"Huh control: %p on_q: %d -- not unordered?\",\n\t\t\t\t      control, control->on_strm_q);\n\t\t\t}\n#endif\n\t\t\tif (SCTP_TSN_GT(control->sinfo_tsn, cumulative_tsn_p1)) {\n\t\t\t\t/* Yep it is above cum-ack */\n\t\t\t\tcnt++;\n\t\t\t\tSCTP_CALC_TSN_TO_GAP(gap, control->sinfo_tsn, asoc->mapping_array_base_tsn);\n\t\t\t\tKASSERT(control->length > 0, (\"control has zero length\"));\n\t\t\t\tif (asoc->size_on_all_streams >= control->length) {\n\t\t\t\t\tasoc->size_on_all_streams -= control->length;\n\t\t\t\t} else {\n#ifdef INVARIANTS\n\t\t\t\t\tpanic(\"size_on_all_streams = %u smaller than control length %u\", asoc->size_on_all_streams, control->length);\n#else\n\t\t\t\t\tasoc->size_on_all_streams = 0;\n#endif\n\t\t\t\t}\n\t\t\t\tsctp_ucount_decr(asoc->cnt_on_all_streams);\n\t\t\t\tSCTP_UNSET_TSN_PRESENT(asoc->mapping_array, gap);\n\t\t\t\tif (control->on_read_q) {\n\t\t\t\t\tTAILQ_REMOVE(&stcb->sctp_ep->read_queue, control, next);\n\t\t\t\t\tcontrol->on_read_q = 0;\n\t\t\t\t}\n\t\t\t\tTAILQ_REMOVE(&asoc->strmin[strmat].uno_inqueue, control, next_instrm);\n\t\t\t\tcontrol->on_strm_q = 0;\n\t\t\t\tif (control->data) {\n\t\t\t\t\tsctp_m_freem(control->data);\n\t\t\t\t\tcontrol->data = NULL;\n\t\t\t\t}\n\t\t\t\tsctp_free_remote_addr(control->whoFrom);\n\t\t\t\t/* Now its reasm? */\n\t\t\t\tTAILQ_FOREACH_SAFE(chk, &control->reasm, sctp_next, nchk) {\n\t\t\t\t\tcnt++;\n\t\t\t\t\tSCTP_CALC_TSN_TO_GAP(gap, chk->rec.data.tsn, asoc->mapping_array_base_tsn);\n\t\t\t\t\tKASSERT(chk->send_size > 0, (\"chunk has zero length\"));\n\t\t\t\t\tif (asoc->size_on_reasm_queue >= chk->send_size) {\n\t\t\t\t\t\tasoc->size_on_reasm_queue -= chk->send_size;\n\t\t\t\t\t} else {\n#ifdef INVARIANTS\n\t\t\t\t\t\tpanic(\"size_on_reasm_queue = %u smaller than chunk length %u\", asoc->size_on_reasm_queue, chk->send_size);\n#else\n\t\t\t\t\t\tasoc->size_on_reasm_queue = 0;\n#endif\n\t\t\t\t\t}\n\t\t\t\t\tsctp_ucount_decr(asoc->cnt_on_reasm_queue);\n\t\t\t\t\tSCTP_UNSET_TSN_PRESENT(asoc->mapping_array, gap);\n\t\t\t\t\tTAILQ_REMOVE(&control->reasm, chk, sctp_next);\n\t\t\t\t\tif (chk->data) {\n\t\t\t\t\t\tsctp_m_freem(chk->data);\n\t\t\t\t\t\tchk->data = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tsctp_free_a_chunk(stcb, chk, SCTP_SO_NOT_LOCKED);\n\t\t\t\t}\n\t\t\t\tsctp_free_a_readq(stcb, control);\n\t\t\t}\n\t\t}\n\t}\n\tif (cnt) {\n\t\t/* We must back down to see what the new highest is */\n\t\tfor (i = asoc->highest_tsn_inside_map; SCTP_TSN_GE(i, asoc->mapping_array_base_tsn); i--) {\n\t\t\tSCTP_CALC_TSN_TO_GAP(gap, i, asoc->mapping_array_base_tsn);\n\t\t\tif (SCTP_IS_TSN_PRESENT(asoc->mapping_array, gap)) {\n\t\t\t\tasoc->highest_tsn_inside_map = i;\n\t\t\t\tfnd = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!fnd) {\n\t\t\tasoc->highest_tsn_inside_map = asoc->mapping_array_base_tsn - 1;\n\t\t}\n\n\t\t/*\n\t\t * Question, should we go through the delivery queue? The only\n\t\t * reason things are on here is the app not reading OR a p-d-api up.\n\t\t * An attacker COULD send enough in to initiate the PD-API and then\n\t\t * send a bunch of stuff to other streams... these would wind up on\n\t\t * the delivery queue.. and then we would not get to them. But in\n\t\t * order to do this I then have to back-track and un-deliver\n\t\t * sequence numbers in streams.. el-yucko. I think for now we will\n\t\t * NOT look at the delivery queue and leave it to be something to\n\t\t * consider later. An alternative would be to abort the P-D-API with\n\t\t * a notification and then deliver the data.... Or another method\n\t\t * might be to keep track of how many times the situation occurs and\n\t\t * if we see a possible attack underway just abort the association.\n\t\t */\n#ifdef SCTP_DEBUG\n\t\tSCTPDBG(SCTP_DEBUG_PCB1, \"Freed %d chunks from reneg harvest\\n\", cnt);\n#endif\n\t\t/*\n\t\t * Now do we need to find a new\n\t\t * asoc->highest_tsn_inside_map?\n\t\t */\n\t\tasoc->last_revoke_count = cnt;\n\t\t(void)SCTP_OS_TIMER_STOP(&stcb->asoc.dack_timer.timer);\n\t\t/*sa_ignore NO_NULL_CHK*/\n\t\tsctp_send_sack(stcb, SCTP_SO_NOT_LOCKED);\n\t\tsctp_chunk_output(stcb->sctp_ep, stcb, SCTP_OUTPUT_FROM_DRAIN, SCTP_SO_NOT_LOCKED);\n\t}\n\t/*\n\t * Another issue, in un-setting the TSN's in the mapping array we\n\t * DID NOT adjust the highest_tsn marker.  This will cause one of two\n\t * things to occur. It may cause us to do extra work in checking for\n\t * our mapping array movement. More importantly it may cause us to\n\t * SACK every datagram. This may not be a bad thing though since we\n\t * will recover once we get our cum-ack above and all this stuff we\n\t * dumped recovered.\n\t */\n}\n\nvoid\nsctp_drain()\n{\n\t/*\n\t * We must walk the PCB lists for ALL associations here. The system\n\t * is LOW on MBUF's and needs help. This is where reneging will\n\t * occur. We really hope this does NOT happen!\n\t */\n#if defined(__FreeBSD__) && __FreeBSD_version >= 801000\n\tVNET_ITERATOR_DECL(vnet_iter);\n#else\n\tstruct sctp_inpcb *inp;\n\tstruct sctp_tcb *stcb;\n\n\tSCTP_STAT_INCR(sctps_protocol_drain_calls);\n\tif (SCTP_BASE_SYSCTL(sctp_do_drain) == 0) {\n\t\treturn;\n\t}\n#endif\n#if defined(__FreeBSD__) && __FreeBSD_version >= 801000\n\tVNET_LIST_RLOCK_NOSLEEP();\n\tVNET_FOREACH(vnet_iter) {\n\t\tCURVNET_SET(vnet_iter);\n\t\tstruct sctp_inpcb *inp;\n\t\tstruct sctp_tcb *stcb;\n#endif\n\n#if defined(__FreeBSD__) && __FreeBSD_version >= 801000\n\t\tSCTP_STAT_INCR(sctps_protocol_drain_calls);\n\t\tif (SCTP_BASE_SYSCTL(sctp_do_drain) == 0) {\n#ifdef VIMAGE\n\t\t\tcontinue;\n#else\n\t\t\treturn;\n#endif\n\t\t}\n#endif\n\t\tSCTP_INP_INFO_RLOCK();\n\t\tLIST_FOREACH(inp, &SCTP_BASE_INFO(listhead), sctp_list) {\n\t\t\t/* For each endpoint */\n\t\t\tSCTP_INP_RLOCK(inp);\n\t\t\tLIST_FOREACH(stcb, &inp->sctp_asoc_list, sctp_tcblist) {\n\t\t\t\t/* For each association */\n\t\t\t\tSCTP_TCB_LOCK(stcb);\n\t\t\t\tsctp_drain_mbufs(stcb);\n\t\t\t\tSCTP_TCB_UNLOCK(stcb);\n\t\t\t}\n\t\t\tSCTP_INP_RUNLOCK(inp);\n\t\t}\n\t\tSCTP_INP_INFO_RUNLOCK();\n#if defined(__FreeBSD__) && __FreeBSD_version >= 801000\n\t\tCURVNET_RESTORE();\n\t}\n\tVNET_LIST_RUNLOCK_NOSLEEP();\n#endif\n}\n\n/*\n * start a new iterator\n * iterates through all endpoints and associations based on the pcb_state\n * flags and asoc_state.  \"af\" (mandatory) is executed for all matching\n * assocs and \"ef\" (optional) is executed when the iterator completes.\n * \"inpf\" (optional) is executed for each new endpoint as it is being\n * iterated through. inpe (optional) is called when the inp completes\n * its way through all the stcbs.\n */\nint\nsctp_initiate_iterator(inp_func inpf,\n\t\t       asoc_func af,\n\t\t       inp_func inpe,\n\t\t       uint32_t pcb_state,\n\t\t       uint32_t pcb_features,\n\t\t       uint32_t asoc_state,\n\t\t       void *argp,\n\t\t       uint32_t argi,\n\t\t       end_func ef,\n\t\t       struct sctp_inpcb *s_inp,\n\t\t       uint8_t chunk_output_off)\n{\n\tstruct sctp_iterator *it = NULL;\n\n\tif (af == NULL) {\n\t\treturn (-1);\n\t}\n\tif (SCTP_BASE_VAR(sctp_pcb_initialized) == 0) {\n\t\tSCTP_PRINTF(\"%s: abort on initialize being %d\\n\", __func__,\n\t\t            SCTP_BASE_VAR(sctp_pcb_initialized));\n\t\treturn (-1);\n\t}\n\tSCTP_MALLOC(it, struct sctp_iterator *, sizeof(struct sctp_iterator),\n\t\t    SCTP_M_ITER);\n\tif (it == NULL) {\n\t\tSCTP_LTRACE_ERR_RET(NULL, NULL, NULL, SCTP_FROM_SCTP_PCB, ENOMEM);\n\t\treturn (ENOMEM);\n\t}\n\tmemset(it, 0, sizeof(*it));\n\tit->function_assoc = af;\n\tit->function_inp = inpf;\n\tif (inpf)\n\t\tit->done_current_ep = 0;\n\telse\n\t\tit->done_current_ep = 1;\n\tit->function_atend = ef;\n\tit->pointer = argp;\n\tit->val = argi;\n\tit->pcb_flags = pcb_state;\n\tit->pcb_features = pcb_features;\n\tit->asoc_state = asoc_state;\n\tit->function_inp_end = inpe;\n\tit->no_chunk_output = chunk_output_off;\n#if defined(__FreeBSD__) && __FreeBSD_version >= 801000\n\tit->vn = curvnet;\n#endif\n\tif (s_inp) {\n\t\t/* Assume lock is held here */\n\t\tit->inp = s_inp;\n\t\tSCTP_INP_INCR_REF(it->inp);\n\t\tit->iterator_flags = SCTP_ITERATOR_DO_SINGLE_INP;\n\t} else {\n\t\tSCTP_INP_INFO_RLOCK();\n\t\tit->inp = LIST_FIRST(&SCTP_BASE_INFO(listhead));\n\t\tif (it->inp) {\n\t\t\tSCTP_INP_INCR_REF(it->inp);\n\t\t}\n\t\tSCTP_INP_INFO_RUNLOCK();\n\t\tit->iterator_flags = SCTP_ITERATOR_DO_ALL_INP;\n\n\t}\n\tSCTP_IPI_ITERATOR_WQ_LOCK();\n\tif (SCTP_BASE_VAR(sctp_pcb_initialized) == 0) {\n\t\tSCTP_IPI_ITERATOR_WQ_UNLOCK();\n\t\tSCTP_PRINTF(\"%s: rollback on initialize being %d it=%p\\n\", __func__,\n\t\t            SCTP_BASE_VAR(sctp_pcb_initialized), it);\n\t\tSCTP_FREE(it, SCTP_M_ITER);\n\t\treturn (-1);\n\t}\n\tTAILQ_INSERT_TAIL(&sctp_it_ctl.iteratorhead, it, sctp_nxt_itr);\n\tif (sctp_it_ctl.iterator_running == 0) {\n\t\tsctp_wakeup_iterator();\n\t}\n\tSCTP_IPI_ITERATOR_WQ_UNLOCK();\n\t/* sa_ignore MEMLEAK {memory is put on the tailq for the iterator} */\n\treturn (0);\n}\n"], "filenames": ["usrsctplib/netinet/sctp_auth.c", "usrsctplib/netinet/sctp_pcb.c"], "buggy_code_start_loc": [37, 37], "buggy_code_end_loc": [1425, 7465], "fixing_code_start_loc": [37, 37], "fixing_code_end_loc": [1426, 7469], "type": "CWE-125", "message": "usrsctp before 2019-12-20 has out-of-bounds reads in sctp_load_addresses_from_init.", "other": {"cve": {"id": "CVE-2019-20503", "sourceIdentifier": "cve@mitre.org", "published": "2020-03-06T20:15:12.470", "lastModified": "2020-06-11T15:15:11.287", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "usrsctp before 2019-12-20 has out-of-bounds reads in sctp_load_addresses_from_init."}, {"lang": "es", "value": "usrsctp versiones anteriores al 20-12-2019, presenta lecturas fuera de l\u00edmites en la funci\u00f3n sctp_load_addresses_from_init."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:usrsctp_project:usrsctp:*:*:*:*:*:*:*:*", "versionEndExcluding": "2019-12-20", "matchCriteriaId": "1DE09463-9EA6-49EF-BCBF-568BE6E965B8"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-03/msg00022.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2020-03/msg00028.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2020-03/msg00030.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2020-03/msg00037.html", "source": "cve@mitre.org"}, {"url": "http://seclists.org/fulldisclosure/2020/May/49", "source": "cve@mitre.org"}, {"url": "http://seclists.org/fulldisclosure/2020/May/52", "source": "cve@mitre.org"}, {"url": "http://seclists.org/fulldisclosure/2020/May/55", "source": "cve@mitre.org"}, {"url": "http://seclists.org/fulldisclosure/2020/May/59", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2020:0815", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2020:0816", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2020:0819", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2020:0820", "source": "cve@mitre.org"}, {"url": "https://bugs.chromium.org/p/project-zero/issues/detail?id=1992", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Vendor Advisory"]}, {"url": "https://chromereleases.googleblog.com/2020/03/stable-channel-update-for-desktop_18.html", "source": "cve@mitre.org"}, {"url": "https://crbug.com/1059349", "source": "cve@mitre.org"}, {"url": "https://github.com/sctplab/usrsctp/commit/790a7a2555aefb392a5a69923f1e9d17b4968467", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/03/msg00013.html", "source": "cve@mitre.org"}, {"url": "https://lists.debian.org/debian-lts-announce/2020/03/msg00023.html", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/2DDNOAGIX5D77TTHT6YPMVJ5WTXTCQEI/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/6IOHSO6BUKC6I66J5PZOMAGFVJ66ZS57/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/JWANFIR3PYAL5RJQ4AO3ZS2DYMSF2ZGZ/", "source": "cve@mitre.org"}, {"url": "https://security.gentoo.org/glsa/202003-02", "source": "cve@mitre.org"}, {"url": "https://security.gentoo.org/glsa/202003-10", "source": "cve@mitre.org"}, {"url": "https://support.apple.com/HT211168", "source": "cve@mitre.org"}, {"url": "https://support.apple.com/HT211171", "source": "cve@mitre.org"}, {"url": "https://support.apple.com/HT211175", "source": "cve@mitre.org"}, {"url": "https://support.apple.com/HT211177", "source": "cve@mitre.org"}, {"url": "https://support.apple.com/kb/HT211168", "source": "cve@mitre.org"}, {"url": "https://support.apple.com/kb/HT211171", "source": "cve@mitre.org"}, {"url": "https://support.apple.com/kb/HT211175", "source": "cve@mitre.org"}, {"url": "https://support.apple.com/kb/HT211177", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4299-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4328-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4335-1/", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2020/dsa-4639", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2020/dsa-4642", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2020/dsa-4645", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/sctplab/usrsctp/commit/790a7a2555aefb392a5a69923f1e9d17b4968467"}}