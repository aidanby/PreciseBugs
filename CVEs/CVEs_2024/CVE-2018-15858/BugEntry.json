{"buggy_code": ["/************************************************************\n * Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.\n *\n * Permission to use, copy, modify, and distribute this\n * software and its documentation for any purpose and without\n * fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright\n * notice and this permission notice appear in supporting\n * documentation, and that the name of Silicon Graphics not be\n * used in advertising or publicity pertaining to distribution\n * of the software without specific prior written permission.\n * Silicon Graphics makes no representation about the suitability\n * of this software for any purpose. It is provided \"as is\"\n * without any express or implied warranty.\n *\n * SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS\n * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON\n * GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL\n * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,\n * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH\n * THE USE OR PERFORMANCE OF THIS SOFTWARE.\n *\n ********************************************************/\n\n#include \"xkbcomp-priv.h\"\n#include \"text.h\"\n#include \"expr.h\"\n#include \"include.h\"\n\ntypedef struct {\n    enum merge_mode merge;\n\n    xkb_atom_t alias;\n    xkb_atom_t real;\n} AliasInfo;\n\ntypedef struct {\n    enum merge_mode merge;\n\n    xkb_atom_t name;\n} LedNameInfo;\n\ntypedef struct {\n    char *name;\n    int errorCount;\n\n    xkb_keycode_t min_key_code;\n    xkb_keycode_t max_key_code;\n    darray(xkb_atom_t) key_names;\n    LedNameInfo led_names[XKB_MAX_LEDS];\n    unsigned int num_led_names;\n    darray(AliasInfo) aliases;\n\n    struct xkb_context *ctx;\n} KeyNamesInfo;\n\n/***====================================================================***/\n\nstatic void\nInitAliasInfo(AliasInfo *info, enum merge_mode merge,\n              xkb_atom_t alias, xkb_atom_t real)\n{\n    memset(info, 0, sizeof(*info));\n    info->merge = merge;\n    info->alias = alias;\n    info->real = real;\n}\n\nstatic LedNameInfo *\nFindLedByName(KeyNamesInfo *info, xkb_atom_t name,\n              xkb_led_index_t *idx_out)\n{\n    for (xkb_led_index_t idx = 0; idx < info->num_led_names; idx++) {\n        LedNameInfo *ledi = &info->led_names[idx];\n        if (ledi->name == name) {\n            *idx_out = idx;\n            return ledi;\n        }\n    }\n\n    return NULL;\n}\n\nstatic bool\nAddLedName(KeyNamesInfo *info, enum merge_mode merge, bool same_file,\n           LedNameInfo *new, xkb_led_index_t new_idx)\n{\n    xkb_led_index_t old_idx;\n    LedNameInfo *old;\n    const int verbosity = xkb_context_get_log_verbosity(info->ctx);\n    const bool report = (same_file && verbosity > 0) || verbosity > 9;\n    const bool replace = (merge == MERGE_REPLACE || merge == MERGE_OVERRIDE);\n\n    /* LED with the same name already exists. */\n    old = FindLedByName(info, new->name, &old_idx);\n    if (old) {\n        if (old_idx == new_idx) {\n            log_warn(info->ctx,\n                     \"Multiple indicators named \\\"%s\\\"; \"\n                     \"Identical definitions ignored\\n\",\n                     xkb_atom_text(info->ctx, new->name));\n            return true;\n        }\n\n        if (report) {\n            xkb_led_index_t use = (replace ? new_idx + 1 : old_idx + 1);\n            xkb_led_index_t ignore = (replace ? old_idx + 1 : new_idx + 1);\n            log_warn(info->ctx,\n                     \"Multiple indicators named %s; Using %d, ignoring %d\\n\",\n                     xkb_atom_text(info->ctx, new->name), use, ignore);\n        }\n\n        if (replace)\n            *old = *new;\n\n        return true;\n    }\n\n    if (new_idx >= info->num_led_names)\n        info->num_led_names = new_idx + 1;\n\n    /* LED with the same index already exists. */\n    old = &info->led_names[new_idx];\n    if (old->name != XKB_ATOM_NONE) {\n        if (report) {\n            const xkb_atom_t use = (replace ? new->name : old->name);\n            const xkb_atom_t ignore = (replace ? old->name : new->name);\n            log_warn(info->ctx, \"Multiple names for indicator %d; \"\n                     \"Using %s, ignoring %s\\n\", new_idx + 1,\n                     xkb_atom_text(info->ctx, use),\n                     xkb_atom_text(info->ctx, ignore));\n        }\n\n        if (replace)\n            *old = *new;\n\n        return true;\n    }\n\n    *old = *new;\n    return true;\n}\n\nstatic void\nClearKeyNamesInfo(KeyNamesInfo *info)\n{\n    free(info->name);\n    darray_free(info->key_names);\n    darray_free(info->aliases);\n}\n\nstatic void\nInitKeyNamesInfo(KeyNamesInfo *info, struct xkb_context *ctx)\n{\n    memset(info, 0, sizeof(*info));\n    info->ctx = ctx;\n    info->min_key_code = XKB_KEYCODE_INVALID;\n#if XKB_KEYCODE_INVALID < XKB_KEYCODE_MAX\n#error \"Hey, you can't be changing stuff like that.\"\n#endif\n}\n\nstatic xkb_keycode_t\nFindKeyByName(KeyNamesInfo *info, xkb_atom_t name)\n{\n    xkb_keycode_t i;\n\n    for (i = info->min_key_code; i <= info->max_key_code; i++)\n        if (darray_item(info->key_names, i) == name)\n            return i;\n\n    return XKB_KEYCODE_INVALID;\n}\n\nstatic bool\nAddKeyName(KeyNamesInfo *info, xkb_keycode_t kc, xkb_atom_t name,\n           enum merge_mode merge, bool same_file, bool report)\n{\n    xkb_atom_t old_name;\n    xkb_keycode_t old_kc;\n    const int verbosity = xkb_context_get_log_verbosity(info->ctx);\n\n    report = report && ((same_file && verbosity > 0) || verbosity > 7);\n\n    if (kc >= darray_size(info->key_names))\n        darray_resize0(info->key_names, kc + 1);\n\n    info->min_key_code = MIN(info->min_key_code, kc);\n    info->max_key_code = MAX(info->max_key_code, kc);\n\n    /* There's already a key with this keycode. */\n    old_name = darray_item(info->key_names, kc);\n    if (old_name != XKB_ATOM_NONE) {\n        const char *lname = KeyNameText(info->ctx, old_name);\n        const char *kname = KeyNameText(info->ctx, name);\n\n        if (old_name == name) {\n            if (report)\n                log_warn(info->ctx,\n                         \"Multiple identical key name definitions; \"\n                         \"Later occurrences of \\\"%s = %d\\\" ignored\\n\",\n                         lname, kc);\n            return true;\n        }\n        else if (merge == MERGE_AUGMENT) {\n            if (report)\n                log_warn(info->ctx,\n                         \"Multiple names for keycode %d; \"\n                         \"Using %s, ignoring %s\\n\", kc, lname, kname);\n            return true;\n        }\n        else {\n            if (report)\n                log_warn(info->ctx,\n                         \"Multiple names for keycode %d; \"\n                         \"Using %s, ignoring %s\\n\", kc, kname, lname);\n            darray_item(info->key_names, kc) = XKB_ATOM_NONE;\n        }\n    }\n\n    /* There's already a key with this name. */\n    old_kc = FindKeyByName(info, name);\n    if (old_kc != XKB_KEYCODE_INVALID && old_kc != kc) {\n        const char *kname = KeyNameText(info->ctx, name);\n\n        if (merge == MERGE_OVERRIDE) {\n            darray_item(info->key_names, old_kc) = XKB_ATOM_NONE;\n            if (report)\n                log_warn(info->ctx,\n                         \"Key name %s assigned to multiple keys; \"\n                         \"Using %d, ignoring %d\\n\", kname, kc, old_kc);\n        }\n        else {\n            if (report)\n                log_vrb(info->ctx, 3,\n                        \"Key name %s assigned to multiple keys; \"\n                        \"Using %d, ignoring %d\\n\", kname, old_kc, kc);\n            return true;\n        }\n    }\n\n    darray_item(info->key_names, kc) = name;\n    return true;\n}\n\n/***====================================================================***/\n\nstatic bool\nHandleAliasDef(KeyNamesInfo *info, KeyAliasDef *def, enum merge_mode merge);\n\nstatic void\nMergeIncludedKeycodes(KeyNamesInfo *into, KeyNamesInfo *from,\n                      enum merge_mode merge)\n{\n    if (from->errorCount > 0) {\n        into->errorCount += from->errorCount;\n        return;\n    }\n\n    if (into->name == NULL) {\n        into->name = from->name;\n        from->name = NULL;\n    }\n\n    /* Merge key names. */\n    if (darray_empty(into->key_names)) {\n        into->key_names = from->key_names;\n        darray_init(from->key_names);\n        into->min_key_code = from->min_key_code;\n        into->max_key_code = from->max_key_code;\n    }\n    else {\n        if (darray_size(into->key_names) < darray_size(from->key_names))\n            darray_resize0(into->key_names, darray_size(from->key_names));\n\n        for (unsigned i = from->min_key_code; i <= from->max_key_code; i++) {\n            xkb_atom_t name = darray_item(from->key_names, i);\n            if (name == XKB_ATOM_NONE)\n                continue;\n\n            if (!AddKeyName(into, i, name, merge, true, false))\n                into->errorCount++;\n        }\n    }\n\n    /* Merge key aliases. */\n    if (darray_empty(into->aliases)) {\n        into->aliases = from->aliases;\n        darray_init(from->aliases);\n    }\n    else {\n        AliasInfo *alias;\n\n        darray_foreach(alias, from->aliases) {\n            KeyAliasDef def;\n\n            def.merge = (merge == MERGE_DEFAULT ? alias->merge : merge);\n            def.alias = alias->alias;\n            def.real = alias->real;\n\n            if (!HandleAliasDef(into, &def, def.merge))\n                into->errorCount++;\n        }\n    }\n\n    /* Merge LED names. */\n    if (into->num_led_names == 0) {\n        memcpy(into->led_names, from->led_names,\n               sizeof(*from->led_names) * from->num_led_names);\n        into->num_led_names = from->num_led_names;\n        from->num_led_names = 0;\n    }\n    else {\n        for (xkb_led_index_t idx = 0; idx < from->num_led_names; idx++) {\n            LedNameInfo *ledi = &from->led_names[idx];\n\n            if (ledi->name == XKB_ATOM_NONE)\n                continue;\n\n            ledi->merge = (merge == MERGE_DEFAULT ? ledi->merge : merge);\n            if (!AddLedName(into, ledi->merge, false, ledi, idx))\n                into->errorCount++;\n        }\n    }\n}\n\nstatic void\nHandleKeycodesFile(KeyNamesInfo *info, XkbFile *file, enum merge_mode merge);\n\nstatic bool\nHandleIncludeKeycodes(KeyNamesInfo *info, IncludeStmt *include)\n{\n    KeyNamesInfo included;\n\n    InitKeyNamesInfo(&included, info->ctx);\n    included.name = include->stmt;\n    include->stmt = NULL;\n\n    for (IncludeStmt *stmt = include; stmt; stmt = stmt->next_incl) {\n        KeyNamesInfo next_incl;\n        XkbFile *file;\n\n        file = ProcessIncludeFile(info->ctx, stmt, FILE_TYPE_KEYCODES);\n        if (!file) {\n            info->errorCount += 10;\n            ClearKeyNamesInfo(&included);\n            return false;\n        }\n\n        InitKeyNamesInfo(&next_incl, info->ctx);\n\n        HandleKeycodesFile(&next_incl, file, MERGE_OVERRIDE);\n\n        MergeIncludedKeycodes(&included, &next_incl, stmt->merge);\n\n        ClearKeyNamesInfo(&next_incl);\n        FreeXkbFile(file);\n    }\n\n    MergeIncludedKeycodes(info, &included, include->merge);\n    ClearKeyNamesInfo(&included);\n\n    return (info->errorCount == 0);\n}\n\nstatic bool\nHandleKeycodeDef(KeyNamesInfo *info, KeycodeDef *stmt, enum merge_mode merge)\n{\n    if (stmt->merge != MERGE_DEFAULT) {\n        if (stmt->merge == MERGE_REPLACE)\n            merge = MERGE_OVERRIDE;\n        else\n            merge = stmt->merge;\n    }\n\n    if (stmt->value < 0 || stmt->value > XKB_KEYCODE_MAX) {\n        log_err(info->ctx,\n                \"Illegal keycode %lld: must be between 0..%u; \"\n                \"Key ignored\\n\", (long long) stmt->value, XKB_KEYCODE_MAX);\n        return false;\n    }\n\n    return AddKeyName(info, stmt->value, stmt->name, merge, false, true);\n}\n\nstatic bool\nHandleAliasDef(KeyNamesInfo *info, KeyAliasDef *def, enum merge_mode merge)\n{\n    AliasInfo *old, new;\n\n    darray_foreach(old, info->aliases) {\n        if (old->alias == def->alias) {\n            if (def->real == old->real) {\n                log_vrb(info->ctx, 1,\n                        \"Alias of %s for %s declared more than once; \"\n                        \"First definition ignored\\n\",\n                        KeyNameText(info->ctx, def->alias),\n                        KeyNameText(info->ctx, def->real));\n            }\n            else {\n                xkb_atom_t use, ignore;\n\n                use = (merge == MERGE_AUGMENT ? old->real : def->real);\n                ignore = (merge == MERGE_AUGMENT ? def->real : old->real);\n\n                log_warn(info->ctx,\n                         \"Multiple definitions for alias %s; \"\n                         \"Using %s, ignoring %s\\n\",\n                         KeyNameText(info->ctx, old->alias),\n                         KeyNameText(info->ctx, use),\n                         KeyNameText(info->ctx, ignore));\n\n                old->real = use;\n            }\n\n            old->merge = merge;\n            return true;\n        }\n    }\n\n    InitAliasInfo(&new, merge, def->alias, def->real);\n    darray_append(info->aliases, new);\n    return true;\n}\n\nstatic bool\nHandleKeyNameVar(KeyNamesInfo *info, VarDef *stmt)\n{\n    const char *elem, *field;\n    ExprDef *arrayNdx;\n\n    if (!ExprResolveLhs(info->ctx, stmt->name, &elem, &field, &arrayNdx))\n        return false;\n\n    if (elem) {\n        log_err(info->ctx, \"Unknown element %s encountered; \"\n                \"Default for field %s ignored\\n\", elem, field);\n        return false;\n    }\n\n    if (!istreq(field, \"minimum\") && !istreq(field, \"maximum\")) {\n        log_err(info->ctx, \"Unknown field encountered; \"\n                \"Assignment to field %s ignored\\n\", field);\n        return false;\n    }\n\n    /* We ignore explicit min/max statements, we always use computed. */\n    return true;\n}\n\nstatic bool\nHandleLedNameDef(KeyNamesInfo *info, LedNameDef *def,\n                 enum merge_mode merge)\n{\n    LedNameInfo ledi;\n    xkb_atom_t name;\n\n    if (def->ndx < 1 || def->ndx > XKB_MAX_LEDS) {\n        info->errorCount++;\n        log_err(info->ctx,\n                \"Illegal indicator index (%d) specified; must be between 1 .. %d; \"\n                \"Ignored\\n\", def->ndx, XKB_MAX_LEDS);\n        return false;\n    }\n\n    if (!ExprResolveString(info->ctx, def->name, &name)) {\n        char buf[20];\n        snprintf(buf, sizeof(buf), \"%u\", def->ndx);\n        info->errorCount++;\n        return ReportBadType(info->ctx, \"indicator\", \"name\", buf, \"string\");\n    }\n\n    ledi.merge = merge;\n    ledi.name = name;\n    return AddLedName(info, merge, true, &ledi, def->ndx - 1);\n}\n\nstatic void\nHandleKeycodesFile(KeyNamesInfo *info, XkbFile *file, enum merge_mode merge)\n{\n    bool ok;\n\n    free(info->name);\n    info->name = strdup_safe(file->name);\n\n    for (ParseCommon *stmt = file->defs; stmt; stmt = stmt->next) {\n        switch (stmt->type) {\n        case STMT_INCLUDE:\n            ok = HandleIncludeKeycodes(info, (IncludeStmt *) stmt);\n            break;\n        case STMT_KEYCODE:\n            ok = HandleKeycodeDef(info, (KeycodeDef *) stmt, merge);\n            break;\n        case STMT_ALIAS:\n            ok = HandleAliasDef(info, (KeyAliasDef *) stmt, merge);\n            break;\n        case STMT_VAR:\n            ok = HandleKeyNameVar(info, (VarDef *) stmt);\n            break;\n        case STMT_LED_NAME:\n            ok = HandleLedNameDef(info, (LedNameDef *) stmt, merge);\n            break;\n        default:\n            log_err(info->ctx,\n                    \"Keycode files may define key and indicator names only; \"\n                    \"Ignoring %s\\n\", stmt_type_to_string(stmt->type));\n            ok = false;\n            break;\n        }\n\n        if (!ok)\n            info->errorCount++;\n\n        if (info->errorCount > 10) {\n            log_err(info->ctx, \"Abandoning keycodes file \\\"%s\\\"\\n\",\n                    file->name);\n            break;\n        }\n    }\n}\n\n/***====================================================================***/\n\nstatic bool\nCopyKeyNamesToKeymap(struct xkb_keymap *keymap, KeyNamesInfo *info)\n{\n    struct xkb_key *keys;\n    xkb_keycode_t min_key_code, max_key_code, kc;\n\n    min_key_code = info->min_key_code;\n    max_key_code = info->max_key_code;\n    /* If the keymap has no keys, let's just use the safest pair we know. */\n    if (min_key_code == XKB_KEYCODE_INVALID) {\n        min_key_code = 8;\n        max_key_code = 255;\n    }\n\n    keys = calloc(max_key_code + 1, sizeof(*keys));\n    if (!keys)\n        return false;\n\n    for (kc = min_key_code; kc <= max_key_code; kc++)\n        keys[kc].keycode = kc;\n\n    for (kc = info->min_key_code; kc <= info->max_key_code; kc++)\n        keys[kc].name = darray_item(info->key_names, kc);\n\n    keymap->min_key_code = min_key_code;\n    keymap->max_key_code = max_key_code;\n    keymap->keys = keys;\n    return true;\n}\n\nstatic bool\nCopyKeyAliasesToKeymap(struct xkb_keymap *keymap, KeyNamesInfo *info)\n{\n    AliasInfo *alias;\n    unsigned i, num_key_aliases;\n    struct xkb_key_alias *key_aliases;\n\n    /*\n     * Do some sanity checking on the aliases. We can't do it before\n     * because keys and their aliases may be added out-of-order.\n     */\n    num_key_aliases = 0;\n    darray_foreach(alias, info->aliases) {\n        /* Check that ->real is a key. */\n        if (!XkbKeyByName(keymap, alias->real, false)) {\n            log_vrb(info->ctx, 5,\n                    \"Attempt to alias %s to non-existent key %s; Ignored\\n\",\n                    KeyNameText(info->ctx, alias->alias),\n                    KeyNameText(info->ctx, alias->real));\n            alias->real = XKB_ATOM_NONE;\n            continue;\n        }\n\n        /* Check that ->alias is not a key. */\n        if (XkbKeyByName(keymap, alias->alias, false)) {\n            log_vrb(info->ctx, 5,\n                    \"Attempt to create alias with the name of a real key; \"\n                    \"Alias \\\"%s = %s\\\" ignored\\n\",\n                    KeyNameText(info->ctx, alias->alias),\n                    KeyNameText(info->ctx, alias->real));\n            alias->real = XKB_ATOM_NONE;\n            continue;\n        }\n\n        num_key_aliases++;\n    }\n\n    /* Copy key aliases. */\n    key_aliases = NULL;\n    if (num_key_aliases > 0) {\n        key_aliases = calloc(num_key_aliases, sizeof(*key_aliases));\n        if (!key_aliases)\n            return false;\n    }\n\n    i = 0;\n    darray_foreach(alias, info->aliases) {\n        if (alias->real != XKB_ATOM_NONE) {\n            key_aliases[i].alias = alias->alias;\n            key_aliases[i].real = alias->real;\n            i++;\n        }\n    }\n\n    keymap->num_key_aliases = num_key_aliases;\n    keymap->key_aliases = key_aliases;\n    return true;\n}\n\nstatic bool\nCopyLedNamesToKeymap(struct xkb_keymap *keymap, KeyNamesInfo *info)\n{\n    keymap->num_leds = info->num_led_names;\n    for (xkb_led_index_t idx = 0; idx < info->num_led_names; idx++) {\n        LedNameInfo *ledi = &info->led_names[idx];\n\n        if (ledi->name == XKB_ATOM_NONE)\n            continue;\n\n        keymap->leds[idx].name = ledi->name;\n    }\n\n    return true;\n}\n\nstatic bool\nCopyKeyNamesInfoToKeymap(struct xkb_keymap *keymap, KeyNamesInfo *info)\n{\n    /* This function trashes keymap on error, but that's OK. */\n    if (!CopyKeyNamesToKeymap(keymap, info) ||\n        !CopyKeyAliasesToKeymap(keymap, info) ||\n        !CopyLedNamesToKeymap(keymap, info))\n        return false;\n\n    keymap->keycodes_section_name = strdup_safe(info->name);\n    XkbEscapeMapName(keymap->keycodes_section_name);\n    return true;\n}\n\n/***====================================================================***/\n\nbool\nCompileKeycodes(XkbFile *file, struct xkb_keymap *keymap,\n                enum merge_mode merge)\n{\n    KeyNamesInfo info;\n\n    InitKeyNamesInfo(&info, keymap->ctx);\n\n    HandleKeycodesFile(&info, file, merge);\n    if (info.errorCount != 0)\n        goto err_info;\n\n    if (!CopyKeyNamesInfoToKeymap(keymap, &info))\n        goto err_info;\n\n    ClearKeyNamesInfo(&info);\n    return true;\n\nerr_info:\n    ClearKeyNamesInfo(&info);\n    return false;\n}\n"], "fixing_code": ["/************************************************************\n * Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.\n *\n * Permission to use, copy, modify, and distribute this\n * software and its documentation for any purpose and without\n * fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright\n * notice and this permission notice appear in supporting\n * documentation, and that the name of Silicon Graphics not be\n * used in advertising or publicity pertaining to distribution\n * of the software without specific prior written permission.\n * Silicon Graphics makes no representation about the suitability\n * of this software for any purpose. It is provided \"as is\"\n * without any express or implied warranty.\n *\n * SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS\n * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON\n * GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL\n * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,\n * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH\n * THE USE OR PERFORMANCE OF THIS SOFTWARE.\n *\n ********************************************************/\n\n#include \"xkbcomp-priv.h\"\n#include \"text.h\"\n#include \"expr.h\"\n#include \"include.h\"\n\ntypedef struct {\n    enum merge_mode merge;\n\n    xkb_atom_t alias;\n    xkb_atom_t real;\n} AliasInfo;\n\ntypedef struct {\n    enum merge_mode merge;\n\n    xkb_atom_t name;\n} LedNameInfo;\n\ntypedef struct {\n    char *name;\n    int errorCount;\n\n    xkb_keycode_t min_key_code;\n    xkb_keycode_t max_key_code;\n    darray(xkb_atom_t) key_names;\n    LedNameInfo led_names[XKB_MAX_LEDS];\n    unsigned int num_led_names;\n    darray(AliasInfo) aliases;\n\n    struct xkb_context *ctx;\n} KeyNamesInfo;\n\n/***====================================================================***/\n\nstatic void\nInitAliasInfo(AliasInfo *info, enum merge_mode merge,\n              xkb_atom_t alias, xkb_atom_t real)\n{\n    memset(info, 0, sizeof(*info));\n    info->merge = merge;\n    info->alias = alias;\n    info->real = real;\n}\n\nstatic LedNameInfo *\nFindLedByName(KeyNamesInfo *info, xkb_atom_t name,\n              xkb_led_index_t *idx_out)\n{\n    for (xkb_led_index_t idx = 0; idx < info->num_led_names; idx++) {\n        LedNameInfo *ledi = &info->led_names[idx];\n        if (ledi->name == name) {\n            *idx_out = idx;\n            return ledi;\n        }\n    }\n\n    return NULL;\n}\n\nstatic bool\nAddLedName(KeyNamesInfo *info, enum merge_mode merge, bool same_file,\n           LedNameInfo *new, xkb_led_index_t new_idx)\n{\n    xkb_led_index_t old_idx;\n    LedNameInfo *old;\n    const int verbosity = xkb_context_get_log_verbosity(info->ctx);\n    const bool report = (same_file && verbosity > 0) || verbosity > 9;\n    const bool replace = (merge == MERGE_REPLACE || merge == MERGE_OVERRIDE);\n\n    /* LED with the same name already exists. */\n    old = FindLedByName(info, new->name, &old_idx);\n    if (old) {\n        if (old_idx == new_idx) {\n            log_warn(info->ctx,\n                     \"Multiple indicators named \\\"%s\\\"; \"\n                     \"Identical definitions ignored\\n\",\n                     xkb_atom_text(info->ctx, new->name));\n            return true;\n        }\n\n        if (report) {\n            xkb_led_index_t use = (replace ? new_idx + 1 : old_idx + 1);\n            xkb_led_index_t ignore = (replace ? old_idx + 1 : new_idx + 1);\n            log_warn(info->ctx,\n                     \"Multiple indicators named %s; Using %d, ignoring %d\\n\",\n                     xkb_atom_text(info->ctx, new->name), use, ignore);\n        }\n\n        if (replace)\n            *old = *new;\n\n        return true;\n    }\n\n    if (new_idx >= info->num_led_names)\n        info->num_led_names = new_idx + 1;\n\n    /* LED with the same index already exists. */\n    old = &info->led_names[new_idx];\n    if (old->name != XKB_ATOM_NONE) {\n        if (report) {\n            const xkb_atom_t use = (replace ? new->name : old->name);\n            const xkb_atom_t ignore = (replace ? old->name : new->name);\n            log_warn(info->ctx, \"Multiple names for indicator %d; \"\n                     \"Using %s, ignoring %s\\n\", new_idx + 1,\n                     xkb_atom_text(info->ctx, use),\n                     xkb_atom_text(info->ctx, ignore));\n        }\n\n        if (replace)\n            *old = *new;\n\n        return true;\n    }\n\n    *old = *new;\n    return true;\n}\n\nstatic void\nClearKeyNamesInfo(KeyNamesInfo *info)\n{\n    free(info->name);\n    darray_free(info->key_names);\n    darray_free(info->aliases);\n}\n\nstatic void\nInitKeyNamesInfo(KeyNamesInfo *info, struct xkb_context *ctx)\n{\n    memset(info, 0, sizeof(*info));\n    info->ctx = ctx;\n    info->min_key_code = XKB_KEYCODE_INVALID;\n#if XKB_KEYCODE_INVALID < XKB_KEYCODE_MAX\n#error \"Hey, you can't be changing stuff like that.\"\n#endif\n}\n\nstatic xkb_keycode_t\nFindKeyByName(KeyNamesInfo *info, xkb_atom_t name)\n{\n    xkb_keycode_t i;\n\n    for (i = info->min_key_code; i <= info->max_key_code; i++)\n        if (darray_item(info->key_names, i) == name)\n            return i;\n\n    return XKB_KEYCODE_INVALID;\n}\n\nstatic bool\nAddKeyName(KeyNamesInfo *info, xkb_keycode_t kc, xkb_atom_t name,\n           enum merge_mode merge, bool same_file, bool report)\n{\n    xkb_atom_t old_name;\n    xkb_keycode_t old_kc;\n    const int verbosity = xkb_context_get_log_verbosity(info->ctx);\n\n    report = report && ((same_file && verbosity > 0) || verbosity > 7);\n\n    if (kc >= darray_size(info->key_names))\n        darray_resize0(info->key_names, kc + 1);\n\n    info->min_key_code = MIN(info->min_key_code, kc);\n    info->max_key_code = MAX(info->max_key_code, kc);\n\n    /* There's already a key with this keycode. */\n    old_name = darray_item(info->key_names, kc);\n    if (old_name != XKB_ATOM_NONE) {\n        const char *lname = KeyNameText(info->ctx, old_name);\n        const char *kname = KeyNameText(info->ctx, name);\n\n        if (old_name == name) {\n            if (report)\n                log_warn(info->ctx,\n                         \"Multiple identical key name definitions; \"\n                         \"Later occurrences of \\\"%s = %d\\\" ignored\\n\",\n                         lname, kc);\n            return true;\n        }\n        else if (merge == MERGE_AUGMENT) {\n            if (report)\n                log_warn(info->ctx,\n                         \"Multiple names for keycode %d; \"\n                         \"Using %s, ignoring %s\\n\", kc, lname, kname);\n            return true;\n        }\n        else {\n            if (report)\n                log_warn(info->ctx,\n                         \"Multiple names for keycode %d; \"\n                         \"Using %s, ignoring %s\\n\", kc, kname, lname);\n            darray_item(info->key_names, kc) = XKB_ATOM_NONE;\n        }\n    }\n\n    /* There's already a key with this name. */\n    old_kc = FindKeyByName(info, name);\n    if (old_kc != XKB_KEYCODE_INVALID && old_kc != kc) {\n        const char *kname = KeyNameText(info->ctx, name);\n\n        if (merge == MERGE_OVERRIDE) {\n            darray_item(info->key_names, old_kc) = XKB_ATOM_NONE;\n            if (report)\n                log_warn(info->ctx,\n                         \"Key name %s assigned to multiple keys; \"\n                         \"Using %d, ignoring %d\\n\", kname, kc, old_kc);\n        }\n        else {\n            if (report)\n                log_vrb(info->ctx, 3,\n                        \"Key name %s assigned to multiple keys; \"\n                        \"Using %d, ignoring %d\\n\", kname, old_kc, kc);\n            return true;\n        }\n    }\n\n    darray_item(info->key_names, kc) = name;\n    return true;\n}\n\n/***====================================================================***/\n\nstatic bool\nHandleAliasDef(KeyNamesInfo *info, KeyAliasDef *def, enum merge_mode merge);\n\nstatic void\nMergeIncludedKeycodes(KeyNamesInfo *into, KeyNamesInfo *from,\n                      enum merge_mode merge)\n{\n    if (from->errorCount > 0) {\n        into->errorCount += from->errorCount;\n        return;\n    }\n\n    if (into->name == NULL) {\n        into->name = from->name;\n        from->name = NULL;\n    }\n\n    /* Merge key names. */\n    if (darray_empty(into->key_names)) {\n        into->key_names = from->key_names;\n        darray_init(from->key_names);\n        into->min_key_code = from->min_key_code;\n        into->max_key_code = from->max_key_code;\n    }\n    else {\n        if (darray_size(into->key_names) < darray_size(from->key_names))\n            darray_resize0(into->key_names, darray_size(from->key_names));\n\n        for (unsigned i = from->min_key_code; i <= from->max_key_code; i++) {\n            xkb_atom_t name = darray_item(from->key_names, i);\n            if (name == XKB_ATOM_NONE)\n                continue;\n\n            if (!AddKeyName(into, i, name, merge, true, false))\n                into->errorCount++;\n        }\n    }\n\n    /* Merge key aliases. */\n    if (darray_empty(into->aliases)) {\n        into->aliases = from->aliases;\n        darray_init(from->aliases);\n    }\n    else {\n        AliasInfo *alias;\n\n        darray_foreach(alias, from->aliases) {\n            KeyAliasDef def;\n\n            def.merge = (merge == MERGE_DEFAULT ? alias->merge : merge);\n            def.alias = alias->alias;\n            def.real = alias->real;\n\n            if (!HandleAliasDef(into, &def, def.merge))\n                into->errorCount++;\n        }\n    }\n\n    /* Merge LED names. */\n    if (into->num_led_names == 0) {\n        memcpy(into->led_names, from->led_names,\n               sizeof(*from->led_names) * from->num_led_names);\n        into->num_led_names = from->num_led_names;\n        from->num_led_names = 0;\n    }\n    else {\n        for (xkb_led_index_t idx = 0; idx < from->num_led_names; idx++) {\n            LedNameInfo *ledi = &from->led_names[idx];\n\n            if (ledi->name == XKB_ATOM_NONE)\n                continue;\n\n            ledi->merge = (merge == MERGE_DEFAULT ? ledi->merge : merge);\n            if (!AddLedName(into, ledi->merge, false, ledi, idx))\n                into->errorCount++;\n        }\n    }\n}\n\nstatic void\nHandleKeycodesFile(KeyNamesInfo *info, XkbFile *file, enum merge_mode merge);\n\nstatic bool\nHandleIncludeKeycodes(KeyNamesInfo *info, IncludeStmt *include)\n{\n    KeyNamesInfo included;\n\n    InitKeyNamesInfo(&included, info->ctx);\n    included.name = include->stmt;\n    include->stmt = NULL;\n\n    for (IncludeStmt *stmt = include; stmt; stmt = stmt->next_incl) {\n        KeyNamesInfo next_incl;\n        XkbFile *file;\n\n        file = ProcessIncludeFile(info->ctx, stmt, FILE_TYPE_KEYCODES);\n        if (!file) {\n            info->errorCount += 10;\n            ClearKeyNamesInfo(&included);\n            return false;\n        }\n\n        InitKeyNamesInfo(&next_incl, info->ctx);\n\n        HandleKeycodesFile(&next_incl, file, MERGE_OVERRIDE);\n\n        MergeIncludedKeycodes(&included, &next_incl, stmt->merge);\n\n        ClearKeyNamesInfo(&next_incl);\n        FreeXkbFile(file);\n    }\n\n    MergeIncludedKeycodes(info, &included, include->merge);\n    ClearKeyNamesInfo(&included);\n\n    return (info->errorCount == 0);\n}\n\nstatic bool\nHandleKeycodeDef(KeyNamesInfo *info, KeycodeDef *stmt, enum merge_mode merge)\n{\n    if (stmt->merge != MERGE_DEFAULT) {\n        if (stmt->merge == MERGE_REPLACE)\n            merge = MERGE_OVERRIDE;\n        else\n            merge = stmt->merge;\n    }\n\n    if (stmt->value < 0 || stmt->value > XKB_KEYCODE_MAX) {\n        log_err(info->ctx,\n                \"Illegal keycode %lld: must be between 0..%u; \"\n                \"Key ignored\\n\", (long long) stmt->value, XKB_KEYCODE_MAX);\n        return false;\n    }\n\n    return AddKeyName(info, stmt->value, stmt->name, merge, false, true);\n}\n\nstatic bool\nHandleAliasDef(KeyNamesInfo *info, KeyAliasDef *def, enum merge_mode merge)\n{\n    AliasInfo *old, new;\n\n    darray_foreach(old, info->aliases) {\n        if (old->alias == def->alias) {\n            if (def->real == old->real) {\n                log_vrb(info->ctx, 1,\n                        \"Alias of %s for %s declared more than once; \"\n                        \"First definition ignored\\n\",\n                        KeyNameText(info->ctx, def->alias),\n                        KeyNameText(info->ctx, def->real));\n            }\n            else {\n                xkb_atom_t use, ignore;\n\n                use = (merge == MERGE_AUGMENT ? old->real : def->real);\n                ignore = (merge == MERGE_AUGMENT ? def->real : old->real);\n\n                log_warn(info->ctx,\n                         \"Multiple definitions for alias %s; \"\n                         \"Using %s, ignoring %s\\n\",\n                         KeyNameText(info->ctx, old->alias),\n                         KeyNameText(info->ctx, use),\n                         KeyNameText(info->ctx, ignore));\n\n                old->real = use;\n            }\n\n            old->merge = merge;\n            return true;\n        }\n    }\n\n    InitAliasInfo(&new, merge, def->alias, def->real);\n    darray_append(info->aliases, new);\n    return true;\n}\n\nstatic bool\nHandleKeyNameVar(KeyNamesInfo *info, VarDef *stmt)\n{\n    const char *elem, *field;\n    ExprDef *arrayNdx;\n\n    if (!ExprResolveLhs(info->ctx, stmt->name, &elem, &field, &arrayNdx))\n        return false;\n\n    if (elem) {\n        log_err(info->ctx, \"Unknown element %s encountered; \"\n                \"Default for field %s ignored\\n\", elem, field);\n        return false;\n    }\n\n    if (!istreq(field, \"minimum\") && !istreq(field, \"maximum\")) {\n        log_err(info->ctx, \"Unknown field encountered; \"\n                \"Assignment to field %s ignored\\n\", field);\n        return false;\n    }\n\n    /* We ignore explicit min/max statements, we always use computed. */\n    return true;\n}\n\nstatic bool\nHandleLedNameDef(KeyNamesInfo *info, LedNameDef *def,\n                 enum merge_mode merge)\n{\n    LedNameInfo ledi;\n    xkb_atom_t name;\n\n    if (def->ndx < 1 || def->ndx > XKB_MAX_LEDS) {\n        info->errorCount++;\n        log_err(info->ctx,\n                \"Illegal indicator index (%d) specified; must be between 1 .. %d; \"\n                \"Ignored\\n\", def->ndx, XKB_MAX_LEDS);\n        return false;\n    }\n\n    if (!ExprResolveString(info->ctx, def->name, &name)) {\n        char buf[20];\n        snprintf(buf, sizeof(buf), \"%u\", def->ndx);\n        info->errorCount++;\n        return ReportBadType(info->ctx, \"indicator\", \"name\", buf, \"string\");\n    }\n\n    ledi.merge = merge;\n    ledi.name = name;\n    return AddLedName(info, merge, true, &ledi, def->ndx - 1);\n}\n\nstatic void\nHandleKeycodesFile(KeyNamesInfo *info, XkbFile *file, enum merge_mode merge)\n{\n    bool ok;\n\n    free(info->name);\n    info->name = strdup_safe(file->name);\n\n    for (ParseCommon *stmt = file->defs; stmt; stmt = stmt->next) {\n        switch (stmt->type) {\n        case STMT_INCLUDE:\n            ok = HandleIncludeKeycodes(info, (IncludeStmt *) stmt);\n            break;\n        case STMT_KEYCODE:\n            ok = HandleKeycodeDef(info, (KeycodeDef *) stmt, merge);\n            break;\n        case STMT_ALIAS:\n            ok = HandleAliasDef(info, (KeyAliasDef *) stmt, merge);\n            break;\n        case STMT_VAR:\n            ok = HandleKeyNameVar(info, (VarDef *) stmt);\n            break;\n        case STMT_LED_NAME:\n            ok = HandleLedNameDef(info, (LedNameDef *) stmt, merge);\n            break;\n        default:\n            log_err(info->ctx,\n                    \"Keycode files may define key and indicator names only; \"\n                    \"Ignoring %s\\n\", stmt_type_to_string(stmt->type));\n            ok = false;\n            break;\n        }\n\n        if (!ok)\n            info->errorCount++;\n\n        if (info->errorCount > 10) {\n            log_err(info->ctx, \"Abandoning keycodes file \\\"%s\\\"\\n\",\n                    file->name);\n            break;\n        }\n    }\n}\n\n/***====================================================================***/\n\nstatic bool\nCopyKeyNamesToKeymap(struct xkb_keymap *keymap, KeyNamesInfo *info)\n{\n    struct xkb_key *keys;\n    xkb_keycode_t min_key_code, max_key_code, kc;\n\n    min_key_code = info->min_key_code;\n    max_key_code = info->max_key_code;\n    /* If the keymap has no keys, let's just use the safest pair we know. */\n    if (min_key_code == XKB_KEYCODE_INVALID) {\n        min_key_code = 8;\n        max_key_code = 255;\n    }\n\n    keys = calloc(max_key_code + 1, sizeof(*keys));\n    if (!keys)\n        return false;\n\n    for (kc = min_key_code; kc <= max_key_code; kc++)\n        keys[kc].keycode = kc;\n\n    for (kc = info->min_key_code; kc <= info->max_key_code; kc++)\n        keys[kc].name = darray_item(info->key_names, kc);\n\n    keymap->min_key_code = min_key_code;\n    keymap->max_key_code = max_key_code;\n    keymap->keys = keys;\n    return true;\n}\n\nstatic bool\nCopyKeyAliasesToKeymap(struct xkb_keymap *keymap, KeyNamesInfo *info)\n{\n    AliasInfo *alias;\n    unsigned i, num_key_aliases;\n    struct xkb_key_alias *key_aliases;\n\n    /*\n     * Do some sanity checking on the aliases. We can't do it before\n     * because keys and their aliases may be added out-of-order.\n     */\n    num_key_aliases = 0;\n    darray_foreach(alias, info->aliases) {\n        /* Check that ->real is a key. */\n        if (!XkbKeyByName(keymap, alias->real, false)) {\n            log_vrb(info->ctx, 5,\n                    \"Attempt to alias %s to non-existent key %s; Ignored\\n\",\n                    KeyNameText(info->ctx, alias->alias),\n                    KeyNameText(info->ctx, alias->real));\n            alias->real = XKB_ATOM_NONE;\n            continue;\n        }\n\n        /* Check that ->alias is not a key. */\n        if (XkbKeyByName(keymap, alias->alias, false)) {\n            log_vrb(info->ctx, 5,\n                    \"Attempt to create alias with the name of a real key; \"\n                    \"Alias \\\"%s = %s\\\" ignored\\n\",\n                    KeyNameText(info->ctx, alias->alias),\n                    KeyNameText(info->ctx, alias->real));\n            alias->real = XKB_ATOM_NONE;\n            continue;\n        }\n\n        num_key_aliases++;\n    }\n\n    /* Copy key aliases. */\n    key_aliases = NULL;\n    if (num_key_aliases > 0) {\n        key_aliases = calloc(num_key_aliases, sizeof(*key_aliases));\n        if (!key_aliases)\n            return false;\n\n        i = 0;\n        darray_foreach(alias, info->aliases) {\n            if (alias->real != XKB_ATOM_NONE) {\n                key_aliases[i].alias = alias->alias;\n                key_aliases[i].real = alias->real;\n                i++;\n            }\n        }\n    }\n\n    keymap->num_key_aliases = num_key_aliases;\n    keymap->key_aliases = key_aliases;\n    return true;\n}\n\nstatic bool\nCopyLedNamesToKeymap(struct xkb_keymap *keymap, KeyNamesInfo *info)\n{\n    keymap->num_leds = info->num_led_names;\n    for (xkb_led_index_t idx = 0; idx < info->num_led_names; idx++) {\n        LedNameInfo *ledi = &info->led_names[idx];\n\n        if (ledi->name == XKB_ATOM_NONE)\n            continue;\n\n        keymap->leds[idx].name = ledi->name;\n    }\n\n    return true;\n}\n\nstatic bool\nCopyKeyNamesInfoToKeymap(struct xkb_keymap *keymap, KeyNamesInfo *info)\n{\n    /* This function trashes keymap on error, but that's OK. */\n    if (!CopyKeyNamesToKeymap(keymap, info) ||\n        !CopyKeyAliasesToKeymap(keymap, info) ||\n        !CopyLedNamesToKeymap(keymap, info))\n        return false;\n\n    keymap->keycodes_section_name = strdup_safe(info->name);\n    XkbEscapeMapName(keymap->keycodes_section_name);\n    return true;\n}\n\n/***====================================================================***/\n\nbool\nCompileKeycodes(XkbFile *file, struct xkb_keymap *keymap,\n                enum merge_mode merge)\n{\n    KeyNamesInfo info;\n\n    InitKeyNamesInfo(&info, keymap->ctx);\n\n    HandleKeycodesFile(&info, file, merge);\n    if (info.errorCount != 0)\n        goto err_info;\n\n    if (!CopyKeyNamesInfoToKeymap(keymap, &info))\n        goto err_info;\n\n    ClearKeyNamesInfo(&info);\n    return true;\n\nerr_info:\n    ClearKeyNamesInfo(&info);\n    return false;\n}\n"], "filenames": ["src/xkbcomp/keycodes.c"], "buggy_code_start_loc": [599], "buggy_code_end_loc": [607], "fixing_code_start_loc": [599], "fixing_code_end_loc": [607], "type": "CWE-476", "message": "Unchecked NULL pointer usage when handling invalid aliases in CopyKeyAliasesToKeymap in xkbcomp/keycodes.c in xkbcommon before 0.8.1 could be used by local attackers to crash (NULL pointer dereference) the xkbcommon parser by supplying a crafted keymap file.", "other": {"cve": {"id": "CVE-2018-15858", "sourceIdentifier": "cve@mitre.org", "published": "2018-08-25T21:29:02.063", "lastModified": "2019-03-19T17:34:19.187", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Unchecked NULL pointer usage when handling invalid aliases in CopyKeyAliasesToKeymap in xkbcomp/keycodes.c in xkbcommon before 0.8.1 could be used by local attackers to crash (NULL pointer dereference) the xkbcommon parser by supplying a crafted keymap file."}, {"lang": "es", "value": "El uso de un puntero NULL no verificado al gestionar alias inv\u00e1lidos en CopyKeyAliasesToKeymap en xkbcomp/keycodes.c en xkbcommon, en versiones anteriores a la 0.8.1, podr\u00eda ser aprovechado por atacantes locales para provocar el cierre inesperado (desreferencia de puntero NULL) del analizador xkbcommon proporcionando un archivo keymap manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:xkbcommon:libxkbcommon:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.8.1", "matchCriteriaId": "33CC7ED5-C297-470D-B26A-25D0EB694460"}, {"vulnerable": true, "criteria": "cpe:2.3:a:xkbcommon:xkbcommon:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.8.1", "matchCriteriaId": "C7D955F4-3540-42A7-8551-EA1A266DDEA6"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}]}]}], "references": [{"url": "https://github.com/xkbcommon/libxkbcommon/commit/badb428e63387140720f22486b3acbd3d738859f", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.freedesktop.org/archives/wayland-devel/2018-August/039232.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201810-05", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3786-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3786-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/xkbcommon/libxkbcommon/commit/badb428e63387140720f22486b3acbd3d738859f"}}