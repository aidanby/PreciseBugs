{"buggy_code": ["import psycopg2\nfrom psycopg2.extensions import ISOLATION_LEVEL_AUTOCOMMIT\n\n\ndef _create_pg_connection(config):\n    if 'server' in config:\n        username = '@'.join([config['username'], config['server']])\n    else:\n        username = config['username']\n    return psycopg2.connect(\n        database=config['database'],\n        user=username,\n        host=config['host'],\n        port=config['port'],\n        password=config['password'],\n    )\n\n\ndef check_db_or_user_exists(db_name, db_user, config):\n    with _create_pg_connection(config) as con:\n        with con.cursor() as cur:\n            cur.execute(\"SELECT 1 FROM pg_database WHERE datname='{}';\".format(db_name))\n            db_exists = cur.fetchone() is not None\n            cur.execute(\"SELECT 1 FROM pg_roles WHERE rolname='{}';\".format(db_user))\n            user = cur.fetchone()\n            user_exists = user is not None\n            return db_exists or user_exists\n\n\ndef create_postgres_db(connection_dict, config):\n    if check_db_or_user_exists(connection_dict[\"db_name\"], connection_dict[\"db_username\"], config):\n        raise ValueError(\"db or user already exists\")\n    with _create_pg_connection(config) as con:\n        con.set_isolation_level(ISOLATION_LEVEL_AUTOCOMMIT)\n        with con.cursor() as cur:\n            create_role = \"CREATE USER {db_username} WITH PASSWORD '{db_pwd}';\".format(**connection_dict)\n            drop_role = \"DROP ROLE {db_username};\".format(**connection_dict)\n            grant_role = 'GRANT {db_username} TO \"{postgraas_user}\";'.format(\n                db_username=connection_dict['db_username'], postgraas_user=get_normalized_username(config['username'])\n            )\n            create_database = \"CREATE DATABASE {db_name} OWNER {db_username};\".format(**connection_dict)\n            try:\n                cur.execute(create_role)\n                cur.execute(grant_role)\n            except psycopg2.ProgrammingError as e:\n                raise ValueError(e.args[0])\n            # cleanup role in case database creation fails\n            # saidly 'CREATE DATABASE' cannot run inside a transaction block\n            try:\n                cur.execute(create_database)\n            except psycopg2.ProgrammingError as e:\n                cur.execute(drop_role)\n                raise ValueError(e.args[0])\n\n\ndef get_normalized_username(username):\n    return username.split('@')[0]\n\n\ndef delete_database(db_name, config):\n    with _create_pg_connection(config) as con:\n        con.set_isolation_level(ISOLATION_LEVEL_AUTOCOMMIT)\n        with con.cursor() as cur:\n            try:\n                cur.execute('''DROP DATABASE \"{}\";'''.format(db_name))\n            except psycopg2.ProgrammingError as e:\n                raise ValueError(e.args[0])\n\n\ndef delete_user(username, config):\n    with _create_pg_connection(config) as con:\n        con.set_isolation_level(ISOLATION_LEVEL_AUTOCOMMIT)\n        with con.cursor() as cur:\n            try:\n                cur.execute('''DROP USER \"{}\";'''.format(get_normalized_username(username)))\n            except psycopg2.ProgrammingError as e:\n                raise ValueError(e.args[0])\n", "import os\nimport uuid\nimport json\ntry:\n    from StringIO import StringIO\nexcept ImportError:\n    from io import StringIO\nimport pytest\n\nimport postgraas_server.configuration as configuration\nfrom postgraas_server.create_app import create_app\nimport postgraas_server.backends.postgres_cluster.postgres_cluster_driver as pgcd\n\n\nCLUSTER_CONFIG = {\n    \"metadb\":\n    {\n        \"db_name\": \"postgraas\",\n        \"db_username\": \"postgraas\",\n        \"db_pwd\": \"postgraas12\",\n        \"host\": \"localhost\",\n        \"port\": \"54321\"\n    },\n    \"backend\":\n    {\n        \"type\": \"pg_cluster\",\n        \"host\": os.environ.get('PGHOST', 'localhost'),\n        \"port\": os.environ.get('PGPORT', '5432'),\n        \"database\": os.environ.get('PGDATABASE', 'postgres'),\n        \"username\": os.environ.get('PGUSER', 'postgres'),\n        \"password\": os.environ.get('PGPASSWORD', 'postgres')\n    }\n}\n\nCONFIGS = {\n    'pg_cluster': CLUSTER_CONFIG,\n}\n\n\ndef remove_digits(s):\n    return ''.join(c for c in s if not c.isdigit())\n\n\ndef delete_test_database_and_user(db_name, username, config):\n    try:\n        pgcd.delete_database(db_name, config)\n    except ValueError as e:\n        pass\n        # print(ValueError(e.args[0]))\n    try:\n        pgcd.delete_user(username, config)\n    except ValueError as e:\n        pass\n        # print(ValueError(e.args[0]))\n\n\n@pytest.fixture(params=['pg_cluster'])\ndef parametrized_setup(request, tmpdir):\n    from postgraas_server.management_resources import db\n    config = CONFIGS[request.param]\n    this_app = create_app(config)\n    this_app.config['SQLALCHEMY_DATABASE_URI'] = \"sqlite://\"\n    this_app.use_reloader = False\n    this_app.config['TESTING'] = True\n    ctx = this_app.app_context()\n    ctx.push()\n    db.create_all()\n    username, db_name = str(uuid.uuid4()).replace('-', '_'), str(uuid.uuid4()).replace('-', '_')\n    request.cls.app_client = this_app.test_client()\n    request.cls.db_name = remove_digits(db_name)\n    request.cls.username = remove_digits(username)\n    request.cls.backend = request.param\n    yield\n    if request.param == 'pg_cluster':\n#        try:\n            delete_test_database_and_user(db_name, username, config['backend'])\n#        except Exception:\n#            pass\n    db.drop_all()\n    ctx.pop()\n\n\nclass PostgraasApiTestBase:\n    def get_postgraas_by_name(self, name, client):\n        headers = {'Content-Type': 'application/json'}\n        list = client.get('/api/v2/postgraas_instances', headers=headers)\n        for instance in json.loads(list.data):\n            if instance[\"postgraas_instance_name\"] == name:\n                return instance[\"id\"]\n\n    def delete_instance_by_name(self, db_credentials, client):\n        id = self.get_postgraas_by_name(db_credentials[\"postgraas_instance_name\"], client)\n        db_pwd = db_credentials[\"db_pwd\"]\n        headers = {'Content-Type': 'application/json'}\n        client.delete(\n            '/api/v2/postgraas_instances/' + str(id),\n            data=json.dumps({\n                'db_pwd': db_pwd\n            }),\n            headers=headers\n        )\n\n\n@pytest.mark.usefixtures('parametrized_setup')\nclass TestPostgraasApi(PostgraasApiTestBase):\n\n    def test_delete_db_and_user(self):\n        backend_config = CONFIGS[self.backend]['backend']\n        db_credentials = {\n            \"postgraas_instance_name\": \"tests_postgraas_test_postgres_cluster_delete\",\n            \"db_name\": 'test_delete_db_and_users',\n            \"db_username\": 'test_delete_db_and_user',\n            \"db_pwd\": 'test_db_pwd',\n            \"host\": backend_config['host'],\n            \"port\": backend_config['port']\n        }\n        delete_test_database_and_user(db_credentials['db_name'], db_credentials['db_username'], backend_config)\n        exists = pgcd.check_db_or_user_exists(db_credentials['db_name'], db_credentials['db_username'], backend_config)\n        assert exists is False\n        pgcd.create_postgres_db(db_credentials, backend_config)\n        exists = pgcd.check_db_or_user_exists(db_credentials['db_name'], db_credentials['db_username'], backend_config)\n        assert exists is True\n        response = self.app_client.post('/api/v2/postgraas_instances',\n                                        data=json.dumps(db_credentials),\n                                        headers={'Content-Type': 'application/json'})\n        print(backend_config)\n        print(response.get_data(as_text=True))\n        assert (\"database or user already exists\" in json.loads(response.get_data(as_text=True))['description']) is True\n        delete_test_database_and_user(db_credentials['db_name'], db_credentials['db_username'], backend_config)\n        response = self.app_client.post('/api/v2/postgraas_instances',\n                                        data=json.dumps(db_credentials),\n                                        headers={'Content-Type': 'application/json'})\n        print(response.get_data(as_text=True))\n        assert (\"test_delete_db_and_users\" in json.loads(response.get_data(as_text=True))['db_name']) is True\n\n\n    def test_create_postgres_instance_exists(self):\n        backend_config = CONFIGS[self.backend]['backend']\n        db_credentials = {\n            \"postgraas_instance_name\": \"tests_postgraas_test_create_postgres_instance_api\",\n            \"db_name\": 'test_create_postgres_instance_exists',\n            \"db_username\": 'test_create_postgres_instance_exists_username',\n            \"db_pwd\": 'test_db_pwd',\n            \"host\": backend_config['host'],\n            \"port\": backend_config['port']\n        }\n        delete_test_database_and_user(db_credentials['db_name'], db_credentials['db_username'], backend_config)\n        exists = pgcd.check_db_or_user_exists(db_credentials['db_name'], db_credentials['db_username'], backend_config)\n        assert exists is False\n        print(db_credentials)\n        pgcd.create_postgres_db(db_credentials, backend_config)\n        exists = pgcd.check_db_or_user_exists(db_credentials['db_name'], db_credentials['db_username'], backend_config)\n        assert exists is True\n        response = self.app_client.post('/api/v2/postgraas_instances',\n                                        data=json.dumps(db_credentials),\n                                        headers={'Content-Type': 'application/json'})\n        delete_test_database_and_user(db_credentials['db_name'], db_credentials['db_username'], backend_config)\n        assert (\"database or user already exists\" in json.loads(response.get_data(as_text=True))['description']) is True\n\n    def test_create_postgres_instance_username_exists(self):\n        backend_config = CONFIGS[self.backend]['backend']\n        db_credentials = {\n            \"postgraas_instance_name\": \"tests_postgraas_test_create_postgres_instance_api\",\n            \"db_name\": 'test_create_postgres_instance_exists',\n            \"db_username\": 'test_create_postgres_instance_exists_username',\n            \"db_pwd\": 'test_db_pwd',\n            \"host\": backend_config['host'],\n            \"port\": backend_config['port']\n        }\n        db_credentials_same_user = {\n            \"postgraas_instance_name\": \"tests_postgraas_test_create_postgres_instance_api\",\n            \"db_name\": 'test_create_postgres_instance_exists_new_db_name',\n            \"db_username\": 'test_create_postgres_instance_exists_username',\n            \"db_pwd\": 'test_db_pwd',\n            \"host\": backend_config['host'],\n            \"port\": backend_config['port']\n        }\n        delete_test_database_and_user(db_credentials['db_name'], db_credentials['db_username'], backend_config)\n        exists = pgcd.check_db_or_user_exists(db_credentials['db_name'], db_credentials['db_username'], backend_config)\n        assert exists is False\n        print(db_credentials)\n        pgcd.create_postgres_db(db_credentials, backend_config)\n        exists = pgcd.check_db_or_user_exists(db_credentials['db_name'], db_credentials['db_username'], backend_config)\n        assert exists is True\n        with pytest.raises(ValueError):\n            pgcd.create_postgres_db(db_credentials_same_user, backend_config)\n\n        response = self.app_client.post('/api/v2/postgraas_instances',\n                                        data=json.dumps(db_credentials_same_user),\n                                        headers={'Content-Type': 'application/json'})\n        delete_test_database_and_user(db_credentials['db_name'], db_credentials['db_username'], backend_config)\n        delete_test_database_and_user(db_credentials_same_user['db_name'], db_credentials_same_user['db_username'],\n                                      backend_config)\n        assert (\"database or user already exists\" in json.loads(response.get_data(as_text=True))['description']) is True\n\n    def test_create_postgres_instance_bad_username(self):\n        backend_config = CONFIGS[self.backend]['backend']\n        db_credentials = {\n            \"postgraas_instance_name\": \"tests_postgraas_test_create_postgres_instance_api\",\n            \"db_name\": 'test_create_postgres_instance_exists',\n            \"db_username\": 'test-invalid-username',\n            \"db_pwd\": 'test_db_pwd',\n            \"host\": backend_config['host'],\n            \"port\": backend_config['port']\n        }\n        response = self.app_client.post('/api/v2/postgraas_instances',\n                                        data=json.dumps(db_credentials),\n                                        headers={'Content-Type': 'application/json'})\n        print(response.get_data(as_text=True))\n        delete_test_database_and_user(db_credentials['db_name'], db_credentials['db_username'], backend_config)\n        assert ('syntax error at or near \"-\"' in json.loads(response.get_data(as_text=True))['msg']) is True\n", "import uuid\nimport json\nimport os\nimport pytest\n\nimport postgraas_server.backends.docker.postgres_instance_driver as pid\nimport postgraas_server.backends.postgres_cluster.postgres_cluster_driver as pgcd\nimport postgraas_server.configuration as configuration\nfrom postgraas_server.backends.exceptions import PostgraasApiException\nfrom postgraas_server.create_app import create_app\nfrom postgraas_server.management_resources import DBInstance\n\nDOCKER_CONFIG = {\n    \"metadb\":\n    {\n        \"db_name\": \"postgraas\",\n        \"db_username\": \"postgraas\",\n        \"db_pwd\": \"postgraas12\",\n        \"host\": \"localhost\",\n        \"port\": \"54321\"\n    },\n    \"backend\":\n    {\n        \"type\": \"docker\"\n    }\n}\n\nCLUSTER_CONFIG = {\n    \"metadb\":\n    {\n        \"db_name\": \"postgraas\",\n        \"db_username\": \"postgraas\",\n        \"db_pwd\": \"postgraas12\",\n        \"host\": \"localhost\",\n        \"port\": \"54321\"\n    },\n    \"backend\":\n    {\n        \"type\": \"pg_cluster\",\n        \"host\": os.environ.get('PGHOST', 'localhost'),\n        \"port\": os.environ.get('PGPORT', '5432'),\n        \"database\": os.environ.get('PGDATABASE', 'postgres'),\n        \"username\": os.environ.get('PGUSER', 'postgres'),\n        \"password\": os.environ.get('PGPASSWORD', 'postgres')\n    }\n}\n\n\nCONFIGS = {\n    'docker': DOCKER_CONFIG,\n    'pg_cluster': CLUSTER_CONFIG,\n}\n\n\ndef remove_digits(s):\n    return ''.join(c for c in s if not c.isdigit())\n\n\ndef delete_all_test_postgraas_container():\n    c = pid._docker_client()\n    for container in c.containers.list():\n        if container.name.startswith(\"tests_postgraas_\"):\n            container.remove(force=True)\n\n\ndef delete_all_test_database_and_user(config):\n    con = pgcd._create_pg_connection(config)\n    cur = con.cursor()\n    cur.execute(\n        '''SELECT d.datname, u.usename\n           FROM pg_database d\n           JOIN pg_user u ON (d.datdba = u.usesysid);''')\n    for db in cur:\n        if db[0].startswith(\"tests_postgraas_\"):\n            delete_test_database_and_user(db[0], db[1], config)\n    cur.execute(\n        '''SELECT u.usename\n           FROM pg_user u;''')\n    for db in cur:\n        if db[0].startswith(\"tests_postgraas_\"):\n            pgcd.delete_user(db[0], config)\n\n\ndef delete_test_database_and_user(db_name, username, config):\n    pgcd.delete_database(db_name, config)\n    pgcd.delete_user(username, config)\n\n\n@pytest.fixture(params=['docker', 'pg_cluster'])\ndef parametrized_setup(request, tmpdir):\n    from postgraas_server.management_resources import db\n    cfg = tmpdir.join('config')\n    with open(cfg.strpath, \"w\") as fp:\n        json.dump(CONFIGS[request.param], fp)\n\n    config = configuration.get_config(cfg.strpath)\n    this_app = create_app(config)\n    this_app.config['SQLALCHEMY_DATABASE_URI'] = \"sqlite://\"\n    this_app.use_reloader = False\n    this_app.config['TESTING'] = True\n    ctx = this_app.app_context()\n    ctx.push()\n    db.create_all()\n    username, db_name = str(uuid.uuid4()).replace('-', '_'), str(uuid.uuid4()).replace('-', '_')\n    request.cls.this_app = this_app\n    request.cls.app_client = this_app.test_client()\n    request.cls.db_name = remove_digits(db_name)\n    request.cls.username = remove_digits(username)\n    request.cls.backend = request.param\n    try:\n        yield\n    except Exception:\n        pass\n    if request.param == 'docker':\n        delete_all_test_postgraas_container()\n    elif request.param == 'pg_cluster':\n        delete_all_test_database_and_user(config['backend'])\n    db.drop_all()\n    ctx.pop()\n\n\n@pytest.mark.usefixtures('parametrized_setup')\nclass TestPostgraasApi():\n    def test_create_and_delete_postgres_instance(self):\n        db_credentials = {\n            \"db_name\": 'tests_postgraas_instance_name',\n            \"db_username\": 'tests_postgraas_db_username',\n            \"db_pwd\": 'test_db_pwd',\n            \"host\": pid.get_hostname(),\n            \"port\": pid.get_open_port()\n        }\n        db_entry = DBInstance(\n            postgraas_instance_name=db_credentials['db_name'],\n            db_name=db_credentials['db_name'],\n            username=db_credentials['db_username'],\n            password=\"\",\n            hostname=db_credentials['host'],\n            port=db_credentials['port']\n        )\n        db_entry.container_id = self.this_app.postgraas_backend.create(db_entry, db_credentials)\n        self.this_app.postgraas_backend.delete(db_entry)\n        assert True\n\n    def test_create_postgraas_twice(self):\n        db_credentials = {\n            \"db_name\": 'tests_postgraas_instance_name',\n            \"db_username\": 'tests_postgraas_db_username',\n            \"db_pwd\": 'test_db_pwd',\n            \"host\": pid.get_hostname(),\n            \"port\": pid.get_open_port()\n        }\n        db_entry = DBInstance(\n            postgraas_instance_name=db_credentials['db_name'],\n            db_name=db_credentials['db_name'],\n            username=db_credentials['db_username'],\n            password=\"\",\n            hostname=db_credentials['host'],\n            port=db_credentials['port']\n        )\n        db_entry.container_id = self.this_app.postgraas_backend.create(db_entry, db_credentials)\n        with pytest.raises(PostgraasApiException) as excinfo:\n            db_entry.container_id = self.this_app.postgraas_backend.create(db_entry, db_credentials)\n        if self.backend == \"pg_cluster\":\n            assert excinfo.value.message == 'db or user already exists'\n        elif self.backend == \"docker\":\n            assert excinfo.value.message == 'Container exists already'\n        self.this_app.postgraas_backend.delete(db_entry)\n        assert True\n\n    def test_create_postgraas_bad_username(self):\n        db_credentials = {\n            \"db_name\": 'tests_postgraas_instance_name',\n            \"db_username\": 'tests_postgraas_db-bad username',\n            \"db_pwd\": 'test_db_pwd',\n            \"host\": pid.get_hostname(),\n            \"port\": pid.get_open_port()\n        }\n        db_entry = DBInstance(\n            postgraas_instance_name=db_credentials['db_name'],\n            db_name=db_credentials['db_name'],\n            username=db_credentials['db_username'],\n            password=\"\",\n            hostname=db_credentials['host'],\n            port=db_credentials['port']\n        )\n        if self.backend == \"pg_cluster\":\n            with pytest.raises(PostgraasApiException) as excinfo:\n                db_entry.container_id = self.this_app.postgraas_backend.create(db_entry, db_credentials)\n                self.this_app.postgraas_backend.delete(db_entry)\n            assert 'syntax error at or near \"-\"' in excinfo.value.message\n\n    def test_delete_nonexisting_db(self):\n        db_credentials = {\n            \"db_name\": 'tests_postgraas_instance_name',\n            \"db_username\": 'tests_postgraas_db-bad username',\n            \"db_pwd\": 'test_db_pwd',\n            \"host\": pid.get_hostname(),\n            \"port\": pid.get_open_port()\n        }\n        db_entry = DBInstance(\n            postgraas_instance_name=db_credentials['db_name'],\n            db_name=db_credentials['db_name'],\n            username=db_credentials['db_username'],\n            password=\"\",\n            hostname=db_credentials['host'],\n            port=db_credentials['port'],\n            container_id=\"4n8nz48az49prdmdmprmr4doesnotexit\"\n\n        )\n        with pytest.raises(PostgraasApiException) as excinfo:\n            db_entry.container_id = self.this_app.postgraas_backend.delete(db_entry)\n        assert 'does not exist' in excinfo.value.message\n"], "fixing_code": ["import psycopg2\nfrom psycopg2.extensions import ISOLATION_LEVEL_AUTOCOMMIT\nfrom psycopg2.sql import SQL, Identifier\n\n\ndef _create_pg_connection(config):\n    if 'server' in config:\n        username = '@'.join([config['username'], config['server']])\n    else:\n        username = config['username']\n    return psycopg2.connect(\n        database=config['database'],\n        user=username,\n        host=config['host'],\n        port=config['port'],\n        password=config['password'],\n    )\n\n\ndef check_db_or_user_exists(db_name, db_user, config):\n    with _create_pg_connection(config) as con:\n        with con.cursor() as cur:\n            cur.execute(\"SELECT 1 FROM pg_database WHERE datname=%s;\", (db_name, ))\n            db_exists = cur.fetchone() is not None\n            cur.execute(\"SELECT 1 FROM pg_roles WHERE rolname=%s;\", (db_user, ))\n            user = cur.fetchone()\n            user_exists = user is not None\n            return db_exists or user_exists\n\n\ndef create_postgres_db(connection_dict, config):\n    if check_db_or_user_exists(connection_dict[\"db_name\"], connection_dict[\"db_username\"], config):\n        raise ValueError(\"db or user already exists\")\n    with _create_pg_connection(config) as con:\n        con.set_isolation_level(ISOLATION_LEVEL_AUTOCOMMIT)\n        with con.cursor() as cur:\n            try:\n                cur.execute(SQL(\"CREATE USER {} WITH PASSWORD %s;\").format(\n                    Identifier(connection_dict['db_username']),\n                ), (\n                    connection_dict['db_pwd'],\n                ))\n                cur.execute(SQL(\"GRANT {} TO {};\").format(\n                    Identifier(connection_dict['db_username']),\n                    Identifier(get_normalized_username(config['username'])),\n                ))\n            except psycopg2.ProgrammingError as e:\n                raise ValueError(e.args[0])\n            # cleanup role in case database creation fails\n            # sadly 'CREATE DATABASE' cannot run inside a transaction block\n            try:\n                cur.execute(SQL(\"CREATE DATABASE {} OWNER {};\").format(\n                    Identifier(connection_dict['db_name']),\n                    Identifier(connection_dict['db_username']),\n                ))\n            except psycopg2.ProgrammingError as e:\n                cur.execute(SQL(\"DROP ROLE {};\").format(\n                    Identifier(connection_dict['db_username']),\n                ))\n                raise ValueError(e.args[0])\n\n\ndef get_normalized_username(username):\n    return username.split('@')[0]\n\n\ndef delete_database(db_name, config):\n    with _create_pg_connection(config) as con:\n        con.set_isolation_level(ISOLATION_LEVEL_AUTOCOMMIT)\n        with con.cursor() as cur:\n            try:\n                cur.execute('''DROP DATABASE \"{}\";'''.format(db_name))\n            except psycopg2.ProgrammingError as e:\n                raise ValueError(e.args[0])\n\n\ndef delete_user(username, config):\n    with _create_pg_connection(config) as con:\n        con.set_isolation_level(ISOLATION_LEVEL_AUTOCOMMIT)\n        with con.cursor() as cur:\n            try:\n                cur.execute('''DROP USER \"{}\";'''.format(get_normalized_username(username)))\n            except psycopg2.ProgrammingError as e:\n                raise ValueError(e.args[0])\n", "import os\nimport uuid\nimport json\ntry:\n    from StringIO import StringIO\nexcept ImportError:\n    from io import StringIO\nimport pytest\n\nimport postgraas_server.configuration as configuration\nfrom postgraas_server.create_app import create_app\nimport postgraas_server.backends.postgres_cluster.postgres_cluster_driver as pgcd\n\n\nCLUSTER_CONFIG = {\n    \"metadb\":\n    {\n        \"db_name\": \"postgraas\",\n        \"db_username\": \"postgraas\",\n        \"db_pwd\": \"postgraas12\",\n        \"host\": \"localhost\",\n        \"port\": \"54321\"\n    },\n    \"backend\":\n    {\n        \"type\": \"pg_cluster\",\n        \"host\": os.environ.get('PGHOST', 'localhost'),\n        \"port\": os.environ.get('PGPORT', '5432'),\n        \"database\": os.environ.get('PGDATABASE', 'postgres'),\n        \"username\": os.environ.get('PGUSER', 'postgres'),\n        \"password\": os.environ.get('PGPASSWORD', 'postgres')\n    }\n}\n\nCONFIGS = {\n    'pg_cluster': CLUSTER_CONFIG,\n}\n\n\ndef remove_digits(s):\n    return ''.join(c for c in s if not c.isdigit())\n\n\ndef delete_test_database_and_user(db_name, username, config):\n    try:\n        pgcd.delete_database(db_name, config)\n    except ValueError as e:\n        pass\n        # print(ValueError(e.args[0]))\n    try:\n        pgcd.delete_user(username, config)\n    except ValueError as e:\n        pass\n        # print(ValueError(e.args[0]))\n\n\n@pytest.fixture(params=['pg_cluster'])\ndef parametrized_setup(request, tmpdir):\n    from postgraas_server.management_resources import db\n    config = CONFIGS[request.param]\n    this_app = create_app(config)\n    this_app.config['SQLALCHEMY_DATABASE_URI'] = \"sqlite://\"\n    this_app.use_reloader = False\n    this_app.config['TESTING'] = True\n    ctx = this_app.app_context()\n    ctx.push()\n    db.create_all()\n    username, db_name = str(uuid.uuid4()).replace('-', '_'), str(uuid.uuid4()).replace('-', '_')\n    request.cls.app_client = this_app.test_client()\n    request.cls.db_name = remove_digits(db_name)\n    request.cls.username = remove_digits(username)\n    request.cls.backend = request.param\n    yield\n    if request.param == 'pg_cluster':\n#        try:\n            delete_test_database_and_user(db_name, username, config['backend'])\n#        except Exception:\n#            pass\n    db.drop_all()\n    ctx.pop()\n\n\nclass PostgraasApiTestBase:\n    def get_postgraas_by_name(self, name, client):\n        headers = {'Content-Type': 'application/json'}\n        list = client.get('/api/v2/postgraas_instances', headers=headers)\n        for instance in json.loads(list.data):\n            if instance[\"postgraas_instance_name\"] == name:\n                return instance[\"id\"]\n\n    def delete_instance_by_name(self, db_credentials, client):\n        id = self.get_postgraas_by_name(db_credentials[\"postgraas_instance_name\"], client)\n        db_pwd = db_credentials[\"db_pwd\"]\n        headers = {'Content-Type': 'application/json'}\n        client.delete(\n            '/api/v2/postgraas_instances/' + str(id),\n            data=json.dumps({\n                'db_pwd': db_pwd\n            }),\n            headers=headers\n        )\n\n\n@pytest.mark.usefixtures('parametrized_setup')\nclass TestPostgraasApi(PostgraasApiTestBase):\n\n    def test_delete_db_and_user(self):\n        backend_config = CONFIGS[self.backend]['backend']\n        db_credentials = {\n            \"postgraas_instance_name\": \"tests_postgraas_test_postgres_cluster_delete\",\n            \"db_name\": 'test_delete_db_and_users',\n            \"db_username\": 'test_delete_db_and_user',\n            \"db_pwd\": 'test_db_pwd',\n            \"host\": backend_config['host'],\n            \"port\": backend_config['port']\n        }\n        delete_test_database_and_user(db_credentials['db_name'], db_credentials['db_username'], backend_config)\n        exists = pgcd.check_db_or_user_exists(db_credentials['db_name'], db_credentials['db_username'], backend_config)\n        assert exists is False\n        pgcd.create_postgres_db(db_credentials, backend_config)\n        exists = pgcd.check_db_or_user_exists(db_credentials['db_name'], db_credentials['db_username'], backend_config)\n        assert exists is True\n        response = self.app_client.post('/api/v2/postgraas_instances',\n                                        data=json.dumps(db_credentials),\n                                        headers={'Content-Type': 'application/json'})\n        print(backend_config)\n        print(response.get_data(as_text=True))\n        assert (\"database or user already exists\" in json.loads(response.get_data(as_text=True))['description']) is True\n        delete_test_database_and_user(db_credentials['db_name'], db_credentials['db_username'], backend_config)\n        response = self.app_client.post('/api/v2/postgraas_instances',\n                                        data=json.dumps(db_credentials),\n                                        headers={'Content-Type': 'application/json'})\n        print(response.get_data(as_text=True))\n        assert (\"test_delete_db_and_users\" in json.loads(response.get_data(as_text=True))['db_name']) is True\n\n\n    def test_create_postgres_instance_exists(self):\n        backend_config = CONFIGS[self.backend]['backend']\n        db_credentials = {\n            \"postgraas_instance_name\": \"tests_postgraas_test_create_postgres_instance_api\",\n            \"db_name\": 'test_create_postgres_instance_exists',\n            \"db_username\": 'test_create_postgres_instance_exists_username',\n            \"db_pwd\": 'test_db_pwd',\n            \"host\": backend_config['host'],\n            \"port\": backend_config['port']\n        }\n        delete_test_database_and_user(db_credentials['db_name'], db_credentials['db_username'], backend_config)\n        exists = pgcd.check_db_or_user_exists(db_credentials['db_name'], db_credentials['db_username'], backend_config)\n        assert exists is False\n        print(db_credentials)\n        pgcd.create_postgres_db(db_credentials, backend_config)\n        exists = pgcd.check_db_or_user_exists(db_credentials['db_name'], db_credentials['db_username'], backend_config)\n        assert exists is True\n        response = self.app_client.post('/api/v2/postgraas_instances',\n                                        data=json.dumps(db_credentials),\n                                        headers={'Content-Type': 'application/json'})\n        delete_test_database_and_user(db_credentials['db_name'], db_credentials['db_username'], backend_config)\n        assert (\"database or user already exists\" in json.loads(response.get_data(as_text=True))['description']) is True\n\n    def test_create_postgres_instance_username_exists(self):\n        backend_config = CONFIGS[self.backend]['backend']\n        db_credentials = {\n            \"postgraas_instance_name\": \"tests_postgraas_test_create_postgres_instance_api\",\n            \"db_name\": 'test_create_postgres_instance_exists',\n            \"db_username\": 'test_create_postgres_instance_exists_username',\n            \"db_pwd\": 'test_db_pwd',\n            \"host\": backend_config['host'],\n            \"port\": backend_config['port']\n        }\n        db_credentials_same_user = {\n            \"postgraas_instance_name\": \"tests_postgraas_test_create_postgres_instance_api\",\n            \"db_name\": 'test_create_postgres_instance_exists_new_db_name',\n            \"db_username\": 'test_create_postgres_instance_exists_username',\n            \"db_pwd\": 'test_db_pwd',\n            \"host\": backend_config['host'],\n            \"port\": backend_config['port']\n        }\n        delete_test_database_and_user(db_credentials['db_name'], db_credentials['db_username'], backend_config)\n        exists = pgcd.check_db_or_user_exists(db_credentials['db_name'], db_credentials['db_username'], backend_config)\n        assert exists is False\n        print(db_credentials)\n        pgcd.create_postgres_db(db_credentials, backend_config)\n        exists = pgcd.check_db_or_user_exists(db_credentials['db_name'], db_credentials['db_username'], backend_config)\n        assert exists is True\n        with pytest.raises(ValueError):\n            pgcd.create_postgres_db(db_credentials_same_user, backend_config)\n\n        response = self.app_client.post('/api/v2/postgraas_instances',\n                                        data=json.dumps(db_credentials_same_user),\n                                        headers={'Content-Type': 'application/json'})\n        delete_test_database_and_user(db_credentials['db_name'], db_credentials['db_username'], backend_config)\n        delete_test_database_and_user(db_credentials_same_user['db_name'], db_credentials_same_user['db_username'],\n                                      backend_config)\n        assert (\"database or user already exists\" in json.loads(response.get_data(as_text=True))['description']) is True\n\n    @pytest.mark.xfail(reason='Username now valid due to hardening against SQL injections.')\n    def test_create_postgres_instance_bad_username(self):\n        backend_config = CONFIGS[self.backend]['backend']\n        db_credentials = {\n            \"postgraas_instance_name\": \"tests_postgraas_test_create_postgres_instance_api\",\n            \"db_name\": 'test_create_postgres_instance_exists',\n            \"db_username\": 'test-invalid-username',\n            \"db_pwd\": 'test_db_pwd',\n            \"host\": backend_config['host'],\n            \"port\": backend_config['port']\n        }\n        response = self.app_client.post('/api/v2/postgraas_instances',\n                                        data=json.dumps(db_credentials),\n                                        headers={'Content-Type': 'application/json'})\n        print(response.get_data(as_text=True))\n        delete_test_database_and_user(db_credentials['db_name'], db_credentials['db_username'], backend_config)\n        assert ('syntax error at or near \"-\"' in json.loads(response.get_data(as_text=True))['msg']) is True\n", "import uuid\nimport json\nimport os\nimport pytest\n\nimport postgraas_server.backends.docker.postgres_instance_driver as pid\nimport postgraas_server.backends.postgres_cluster.postgres_cluster_driver as pgcd\nimport postgraas_server.configuration as configuration\nfrom postgraas_server.backends.exceptions import PostgraasApiException\nfrom postgraas_server.create_app import create_app\nfrom postgraas_server.management_resources import DBInstance\n\nDOCKER_CONFIG = {\n    \"metadb\":\n    {\n        \"db_name\": \"postgraas\",\n        \"db_username\": \"postgraas\",\n        \"db_pwd\": \"postgraas12\",\n        \"host\": \"localhost\",\n        \"port\": \"54321\"\n    },\n    \"backend\":\n    {\n        \"type\": \"docker\"\n    }\n}\n\nCLUSTER_CONFIG = {\n    \"metadb\":\n    {\n        \"db_name\": \"postgraas\",\n        \"db_username\": \"postgraas\",\n        \"db_pwd\": \"postgraas12\",\n        \"host\": \"localhost\",\n        \"port\": \"54321\"\n    },\n    \"backend\":\n    {\n        \"type\": \"pg_cluster\",\n        \"host\": os.environ.get('PGHOST', 'localhost'),\n        \"port\": os.environ.get('PGPORT', '5432'),\n        \"database\": os.environ.get('PGDATABASE', 'postgres'),\n        \"username\": os.environ.get('PGUSER', 'postgres'),\n        \"password\": os.environ.get('PGPASSWORD', 'postgres')\n    }\n}\n\n\nCONFIGS = {\n    'docker': DOCKER_CONFIG,\n    'pg_cluster': CLUSTER_CONFIG,\n}\n\n\ndef remove_digits(s):\n    return ''.join(c for c in s if not c.isdigit())\n\n\ndef delete_all_test_postgraas_container():\n    c = pid._docker_client()\n    for container in c.containers.list():\n        if container.name.startswith(\"tests_postgraas_\"):\n            container.remove(force=True)\n\n\ndef delete_all_test_database_and_user(config):\n    con = pgcd._create_pg_connection(config)\n    cur = con.cursor()\n    cur.execute(\n        '''SELECT d.datname, u.usename\n           FROM pg_database d\n           JOIN pg_user u ON (d.datdba = u.usesysid);''')\n    for db in cur:\n        if db[0].startswith(\"tests_postgraas_\"):\n            delete_test_database_and_user(db[0], db[1], config)\n    cur.execute(\n        '''SELECT u.usename\n           FROM pg_user u;''')\n    for db in cur:\n        if db[0].startswith(\"tests_postgraas_\"):\n            pgcd.delete_user(db[0], config)\n\n\ndef delete_test_database_and_user(db_name, username, config):\n    pgcd.delete_database(db_name, config)\n    pgcd.delete_user(username, config)\n\n\n@pytest.fixture(params=['docker', 'pg_cluster'])\ndef parametrized_setup(request, tmpdir):\n    from postgraas_server.management_resources import db\n    cfg = tmpdir.join('config')\n    with open(cfg.strpath, \"w\") as fp:\n        json.dump(CONFIGS[request.param], fp)\n\n    config = configuration.get_config(cfg.strpath)\n    this_app = create_app(config)\n    this_app.config['SQLALCHEMY_DATABASE_URI'] = \"sqlite://\"\n    this_app.use_reloader = False\n    this_app.config['TESTING'] = True\n    ctx = this_app.app_context()\n    ctx.push()\n    db.create_all()\n    username, db_name = str(uuid.uuid4()).replace('-', '_'), str(uuid.uuid4()).replace('-', '_')\n    request.cls.this_app = this_app\n    request.cls.app_client = this_app.test_client()\n    request.cls.db_name = remove_digits(db_name)\n    request.cls.username = remove_digits(username)\n    request.cls.backend = request.param\n    try:\n        yield\n    except Exception:\n        pass\n    if request.param == 'docker':\n        delete_all_test_postgraas_container()\n    elif request.param == 'pg_cluster':\n        delete_all_test_database_and_user(config['backend'])\n    db.drop_all()\n    ctx.pop()\n\n\n@pytest.mark.usefixtures('parametrized_setup')\nclass TestPostgraasApi():\n    def test_create_and_delete_postgres_instance(self):\n        db_credentials = {\n            \"db_name\": 'tests_postgraas_instance_name',\n            \"db_username\": 'tests_postgraas_db_username',\n            \"db_pwd\": 'test_db_pwd',\n            \"host\": pid.get_hostname(),\n            \"port\": pid.get_open_port()\n        }\n        db_entry = DBInstance(\n            postgraas_instance_name=db_credentials['db_name'],\n            db_name=db_credentials['db_name'],\n            username=db_credentials['db_username'],\n            password=\"\",\n            hostname=db_credentials['host'],\n            port=db_credentials['port']\n        )\n        db_entry.container_id = self.this_app.postgraas_backend.create(db_entry, db_credentials)\n        self.this_app.postgraas_backend.delete(db_entry)\n        assert True\n\n    def test_create_postgraas_twice(self):\n        db_credentials = {\n            \"db_name\": 'tests_postgraas_instance_name',\n            \"db_username\": 'tests_postgraas_db_username',\n            \"db_pwd\": 'test_db_pwd',\n            \"host\": pid.get_hostname(),\n            \"port\": pid.get_open_port()\n        }\n        db_entry = DBInstance(\n            postgraas_instance_name=db_credentials['db_name'],\n            db_name=db_credentials['db_name'],\n            username=db_credentials['db_username'],\n            password=\"\",\n            hostname=db_credentials['host'],\n            port=db_credentials['port']\n        )\n        db_entry.container_id = self.this_app.postgraas_backend.create(db_entry, db_credentials)\n        with pytest.raises(PostgraasApiException) as excinfo:\n            db_entry.container_id = self.this_app.postgraas_backend.create(db_entry, db_credentials)\n        if self.backend == \"pg_cluster\":\n            assert excinfo.value.message == 'db or user already exists'\n        elif self.backend == \"docker\":\n            assert excinfo.value.message == 'Container exists already'\n        self.this_app.postgraas_backend.delete(db_entry)\n        assert True\n\n    @pytest.mark.xfail(reason='Username now valid due to hardening against SQL injections.')\n    def test_create_postgraas_bad_username(self):\n        db_credentials = {\n            \"db_name\": 'tests_postgraas_instance_name',\n            \"db_username\": 'tests_postgraas_db-bad username',\n            \"db_pwd\": 'test_db_pwd',\n            \"host\": pid.get_hostname(),\n            \"port\": pid.get_open_port()\n        }\n        db_entry = DBInstance(\n            postgraas_instance_name=db_credentials['db_name'],\n            db_name=db_credentials['db_name'],\n            username=db_credentials['db_username'],\n            password=\"\",\n            hostname=db_credentials['host'],\n            port=db_credentials['port']\n        )\n        if self.backend == \"pg_cluster\":\n            with pytest.raises(PostgraasApiException) as excinfo:\n                db_entry.container_id = self.this_app.postgraas_backend.create(db_entry, db_credentials)\n                self.this_app.postgraas_backend.delete(db_entry)\n            assert 'syntax error at or near \"-\"' in excinfo.value.message\n\n    def test_delete_nonexisting_db(self):\n        db_credentials = {\n            \"db_name\": 'tests_postgraas_instance_name',\n            \"db_username\": 'tests_postgraas_db-bad username',\n            \"db_pwd\": 'test_db_pwd',\n            \"host\": pid.get_hostname(),\n            \"port\": pid.get_open_port()\n        }\n        db_entry = DBInstance(\n            postgraas_instance_name=db_credentials['db_name'],\n            db_name=db_credentials['db_name'],\n            username=db_credentials['db_username'],\n            password=\"\",\n            hostname=db_credentials['host'],\n            port=db_credentials['port'],\n            container_id=\"4n8nz48az49prdmdmprmr4doesnotexit\"\n\n        )\n        with pytest.raises(PostgraasApiException) as excinfo:\n            db_entry.container_id = self.this_app.postgraas_backend.delete(db_entry)\n        assert 'does not exist' in excinfo.value.message\n"], "filenames": ["postgraas_server/backends/postgres_cluster/postgres_cluster_driver.py", "tests/test_integration/backends/postgres_cluster/test_postgres_cluster_driver.py", "tests/test_integration/test_backend_behaviour.py"], "buggy_code_start_loc": [2, 195, 169], "buggy_code_end_loc": [53, 195, 169], "fixing_code_start_loc": [3, 196, 170], "fixing_code_end_loc": [60, 197, 171], "type": "CWE-89", "message": "A vulnerability, which was classified as critical, was found in Blue Yonder postgraas_server up to 2.0.0b2. Affected is the function _create_pg_connection/create_postgres_db of the file postgraas_server/backends/postgres_cluster/postgres_cluster_driver.py of the component PostgreSQL Backend Handler. The manipulation leads to sql injection. Upgrading to version 2.0.0 is able to address this issue. The patch is identified as 7cd8d016edc74a78af0d81c948bfafbcc93c937c. It is recommended to upgrade the affected component. VDB-234246 is the identifier assigned to this vulnerability.", "other": {"cve": {"id": "CVE-2018-25088", "sourceIdentifier": "cna@vuldb.com", "published": "2023-07-18T13:15:11.187", "lastModified": "2024-02-29T01:23:14.860", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A vulnerability, which was classified as critical, was found in Blue Yonder postgraas_server up to 2.0.0b2. Affected is the function _create_pg_connection/create_postgres_db of the file postgraas_server/backends/postgres_cluster/postgres_cluster_driver.py of the component PostgreSQL Backend Handler. The manipulation leads to sql injection. Upgrading to version 2.0.0 is able to address this issue. The patch is identified as 7cd8d016edc74a78af0d81c948bfafbcc93c937c. It is recommended to upgrade the affected component. VDB-234246 is the identifier assigned to this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:A/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 3.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:A/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "ADJACENT_NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 5.2}, "baseSeverity": "MEDIUM", "exploitabilityScore": 5.1, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:blueyonder:postgraas_server:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.0.0", "matchCriteriaId": "8CF8797F-0420-464C-9A2E-014C8737C5DB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:blueyonder:postgraas_server:2.0.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "0F5318C9-6E8D-4A72-938D-0BA76F2FB923"}, {"vulnerable": true, "criteria": "cpe:2.3:a:blueyonder:postgraas_server:2.0.0:beta2:*:*:*:*:*:*", "matchCriteriaId": "C7662683-079A-43A9-9B17-3E3E6359B429"}]}]}], "references": [{"url": "https://github.com/blue-yonder/postgraas_server/commit/7cd8d016edc74a78af0d81c948bfafbcc93c937c", "source": "cna@vuldb.com", "tags": ["Patch"]}, {"url": "https://github.com/blue-yonder/postgraas_server/releases/tag/v2.0.0", "source": "cna@vuldb.com", "tags": ["Release Notes"]}, {"url": "https://vuldb.com/?ctiid.234246", "source": "cna@vuldb.com", "tags": ["Permissions Required"]}, {"url": "https://vuldb.com/?id.234246", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/blue-yonder/postgraas_server/commit/7cd8d016edc74a78af0d81c948bfafbcc93c937c"}}