{"buggy_code": ["/* $OpenBSD: doas.c,v 1.52 2016/04/28 04:48:56 tedu Exp $ */\n/*\n * Copyright (c) 2015 Ted Unangst <tedu@openbsd.org>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n\n#include <limits.h>\n#if __OpenBSD__\n#\tinclude <login_cap.h>\n#\tinclude <readpassphrase.h>\n#endif\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <err.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <grp.h>\n#include <syslog.h>\n#include <errno.h>\n\n#include \"includes.h\"\n\n#include \"doas.h\"\n\nstatic void __dead\nusage(void)\n{\n\tfprintf(stderr, \"usage: doas [-Lns] \"\n#ifdef __OpenBSD__\n\t    \"[-a style] \"\n#endif\n\t    \"[-C config] [-u user] command [args]\\n\");\n\texit(1);\n}\n\nstatic int\nparseuid(const char *s, uid_t *uid)\n{\n\tstruct passwd *pw;\n\tconst char *errstr;\n\n\tif ((pw = getpwnam(s)) != NULL) {\n\t\t*uid = pw->pw_uid;\n\t\treturn 0;\n\t}\n\t*uid = strtonum(s, 0, UID_MAX, &errstr);\n\tif (errstr)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic int\nuidcheck(const char *s, uid_t desired)\n{\n\tuid_t uid;\n\n\tif (parseuid(s, &uid) != 0)\n\t\treturn -1;\n\tif (uid != desired)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic int\nparsegid(const char *s, gid_t *gid)\n{\n\tstruct group *gr;\n\tconst char *errstr;\n\n\tif ((gr = getgrnam(s)) != NULL) {\n\t\t*gid = gr->gr_gid;\n\t\treturn 0;\n\t}\n\t*gid = strtonum(s, 0, GID_MAX, &errstr);\n\tif (errstr)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic int\nmatch(uid_t uid, gid_t *groups, int ngroups, uid_t target, const char *cmd,\n    const char **cmdargs, struct rule *r)\n{\n\tint i;\n\n\tif (r->ident[0] == ':') {\n\t\tgid_t rgid;\n\t\tif (parsegid(r->ident + 1, &rgid) == -1)\n\t\t\treturn 0;\n\t\tfor (i = 0; i < ngroups; i++) {\n\t\t\tif (rgid == groups[i])\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i == ngroups)\n\t\t\treturn 0;\n\t} else {\n\t\tif (uidcheck(r->ident, uid) != 0)\n\t\t\treturn 0;\n\t}\n\tif (r->target && uidcheck(r->target, target) != 0)\n\t\treturn 0;\n\tif (r->cmd) {\n\t\tif (strcmp(r->cmd, cmd))\n\t\t\treturn 0;\n\t\tif (r->cmdargs) {\n\t\t\t/* if arguments were given, they should match explicitly */\n\t\t\tfor (i = 0; r->cmdargs[i]; i++) {\n\t\t\t\tif (!cmdargs[i])\n\t\t\t\t\treturn 0;\n\t\t\t\tif (strcmp(r->cmdargs[i], cmdargs[i]))\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (cmdargs[i])\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic int\npermit(uid_t uid, gid_t *groups, int ngroups, const struct rule **lastr,\n    uid_t target, const char *cmd, const char **cmdargs)\n{\n\tint i;\n\n\t*lastr = NULL;\n\tfor (i = 0; i < nrules; i++) {\n\t\tif (match(uid, groups, ngroups, target, cmd,\n\t\t    cmdargs, rules[i]))\n\t\t\t*lastr = rules[i];\n\t}\n\tif (!*lastr)\n\t\treturn 0;\n\treturn (*lastr)->action == PERMIT;\n}\n\nstatic void\nparseconfig(const char *filename, int checkperms)\n{\n\textern FILE *yyfp;\n\textern int yyparse(void);\n\tstruct stat sb;\n\n\tyyfp = fopen(filename, \"r\");\n\tif (!yyfp)\n\t\terr(1, checkperms ? \"doas is not enabled, %s\" :\n\t\t    \"could not open config file %s\", filename);\n\n\tif (checkperms) {\n\t\tif (fstat(fileno(yyfp), &sb) != 0)\n\t\t\terr(1, \"fstat(\\\"%s\\\")\", filename);\n\t\tif ((sb.st_mode & (S_IWGRP|S_IWOTH)) != 0)\n\t\t\terrx(1, \"%s is writable by group or other\", filename);\n\t\tif (sb.st_uid != 0)\n\t\t\terrx(1, \"%s is not owned by root\", filename);\n\t}\n\n\tyyparse();\n\tfclose(yyfp);\n\tif (parse_errors)\n\t\texit(1);\n}\n\nstatic void __dead\ncheckconfig(const char *confpath, int argc, char **argv,\n    uid_t uid, gid_t *groups, int ngroups, uid_t target)\n{\n\tconst struct rule *rule;\n\n\tif (setresuid(uid, uid, uid) != 0)\n\t\terr(1, \"setresuid\");\n\n\tparseconfig(confpath, 0);\n\tif (!argc)\n\t\texit(0);\n\n\tif (permit(uid, groups, ngroups, &rule, target, argv[0],\n\t    (const char **)argv + 1)) {\n\t\tprintf(\"permit%s\\n\", (rule->options & NOPASS) ? \" nopass\" : \"\");\n\t\texit(0);\n\t} else {\n\t\tprintf(\"deny\\n\");\n\t\texit(1);\n\t}\n}\n\n#ifdef USE_BSD_AUTH\nstatic void\nauthuser(char *myname, char *login_style, int persist)\n{\n\tchar *challenge = NULL, *response, rbuf[1024], cbuf[128];\n\tauth_session_t *as;\n\tint fd = -1;\n\n\tif (persist)\n\t\tfd = open(\"/dev/tty\", O_RDWR);\n\tif (fd != -1) {\n\t\tif (ioctl(fd, TIOCCHKVERAUTH) == 0)\n\t\t\tgoto good;\n\t}\n\n\tif (!(as = auth_userchallenge(myname, login_style, \"auth-doas\",\n\t    &challenge)))\n\t\terrx(1, \"Authorization failed\");\n\tif (!challenge) {\n\t\tchar host[HOST_NAME_MAX + 1];\n\t\tif (gethostname(host, sizeof(host)))\n\t\t\tsnprintf(host, sizeof(host), \"?\");\n\t\tsnprintf(cbuf, sizeof(cbuf),\n\t\t    \"\\rdoas (%.32s@%.32s) password: \", myname, host);\n\t\tchallenge = cbuf;\n\t}\n\tresponse = readpassphrase(challenge, rbuf, sizeof(rbuf),\n\t    RPP_REQUIRE_TTY);\n\tif (response == NULL && errno == ENOTTY) {\n\t\tsyslog(LOG_AUTHPRIV | LOG_NOTICE,\n\t\t    \"tty required for %s\", myname);\n\t\terrx(1, \"a tty is required\");\n\t}\n\tif (!auth_userresponse(as, response, 0)) {\n\t\texplicit_bzero(rbuf, sizeof(rbuf));\n\t\tsyslog(LOG_AUTHPRIV | LOG_NOTICE,\n\t\t    \"failed auth for %s\", myname);\n\t\terrx(1, \"Authorization failed\");\n\t}\n\texplicit_bzero(rbuf, sizeof(rbuf));\ngood:\n\tif (fd != -1) {\n\t\tint secs = 5 * 60;\n\t\tioctl(fd, TIOCSETVERAUTH, &secs);\n\t\tclose(fd);\n\t}\n}\n#endif\n\nint\nmain(int argc, char **argv)\n{\n\tconst char *safepath = \"/bin:/sbin:/usr/bin:/usr/sbin:\"\n\t    \"/usr/local/bin:/usr/local/sbin\";\n\tconst char *confpath = NULL;\n\tchar *shargv[] = { NULL, NULL };\n\tchar *sh;\n\tconst char *cmd;\n\tchar cmdline[LINE_MAX];\n#ifdef __OpenBSD__\n\tchar mypwbuf[_PW_BUF_LEN], targpwbuf[_PW_BUF_LEN];\n#else\n\tchar *mypwbuf = NULL, *targpwbuf = NULL;\n#endif\n\tstruct passwd mypwstore, targpwstore;\n\tstruct passwd *mypw, *targpw;\n\tconst struct rule *rule;\n\tuid_t uid;\n\tuid_t target = 0;\n\tgid_t groups[NGROUPS_MAX + 1];\n\tint ngroups;\n\tint i, ch, rv;\n\tint sflag = 0;\n\tint nflag = 0;\n\tchar cwdpath[PATH_MAX];\n\tconst char *cwd;\n\tchar **envp;\n#ifdef USE_BSD_AUTH\n\tchar *login_style = NULL;\n#endif\n\n\tsetprogname(\"doas\");\n\n\tclosefrom(STDERR_FILENO + 1);\n\n\tuid = getuid();\n\n#ifdef USE_BSD_AUTH\n# define OPTSTRING \"a:C:Lnsu:\"\n#else\n# define OPTSTRING \"+C:Lnsu:\"\n#endif\n\n\twhile ((ch = getopt(argc, argv, OPTSTRING)) != -1) {\n\t\tswitch (ch) {\n#ifdef USE_BSD_AUTH\n\t\tcase 'a':\n\t\t\tlogin_style = optarg;\n\t\t\tbreak;\n#endif\n\t\tcase 'C':\n\t\t\tconfpath = optarg;\n\t\t\tbreak;\n\t\tcase 'L':\n#if defined(USE_BSD_AUTH)\n\t\t\ti = open(\"/dev/tty\", O_RDWR);\n\t\t\tif (i != -1)\n\t\t\t\tioctl(i, TIOCCLRVERAUTH);\n\t\t\texit(i == -1);\n#elif defined(USE_TIMESTAMP)\n\t\t\texit(timestamp_clear() == -1);\n#else\n\t\t\texit(0);\n#endif\n\t\tcase 'u':\n\t\t\tif (parseuid(optarg, &target) != 0)\n\t\t\t\terrx(1, \"unknown user\");\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tnflag = 1;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tsflag = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t\tbreak;\n\t\t}\n\t}\n\targv += optind;\n\targc -= optind;\n\n\tif (confpath) {\n\t\tif (sflag)\n\t\t\tusage();\n\t} else if ((!sflag && !argc) || (sflag && argc))\n\t\tusage();\n\n#ifdef __OpenBSD__\n\trv = getpwuid_r(uid, &mypwstore, mypwbuf, sizeof(mypwbuf), &mypw);\n\tif (rv != 0)\n\t\terr(1, \"getpwuid_r failed\");\n#else\n\tfor (size_t sz = 1024; sz <= 16*1024; sz *= 2) {\n\t\tmypwbuf = reallocarray(mypwbuf, sz, sizeof (char));\n\t\tif (mypwbuf == NULL)\n\t\t\terrx(1, \"can't allocate mypwbuf\");\n\t\trv = getpwuid_r(uid, &mypwstore, mypwbuf, sz, &mypw);\n\t\tif (rv != ERANGE)\n\t\t\tbreak;\n\t}\n\tif (rv != 0)\n\t\terr(1, \"getpwuid_r failed\");\n#endif\n\tif (mypw == NULL)\n\t\terrx(1, \"no passwd entry for self\");\n\tngroups = getgroups(NGROUPS_MAX, groups);\n\tif (ngroups == -1)\n\t\terr(1, \"can't get groups\");\n\tgroups[ngroups++] = getgid();\n\n\tif (sflag) {\n\t\tsh = getenv(\"SHELL\");\n\t\tif (sh == NULL || *sh == '\\0') {\n\t\t\tshargv[0] = mypw->pw_shell;\n\t\t} else\n\t\t\tshargv[0] = sh;\n\t\targv = shargv;\n\t\targc = 1;\n\t}\n\n\tif (confpath) {\n\t\tcheckconfig(confpath, argc, argv, uid, groups, ngroups,\n\t\t    target);\n\t\texit(1);\t/* fail safe */\n\t}\n\n\tif (geteuid())\n\t\terrx(1, \"not installed setuid\");\n\n\tparseconfig(\"/etc/doas.conf\", 1);\n\n\t/* cmdline is used only for logging, no need to abort on truncate */\n\t(void)strlcpy(cmdline, argv[0], sizeof(cmdline));\n\tfor (i = 1; i < argc; i++) {\n\t\tif (strlcat(cmdline, \" \", sizeof(cmdline)) >= sizeof(cmdline))\n\t\t\tbreak;\n\t\tif (strlcat(cmdline, argv[i], sizeof(cmdline)) >= sizeof(cmdline))\n\t\t\tbreak;\n\t}\n\n\tcmd = argv[0];\n\tif (!permit(uid, groups, ngroups, &rule, target, cmd,\n\t    (const char **)argv + 1)) {\n\t\tsyslog(LOG_AUTHPRIV | LOG_NOTICE,\n\t\t    \"failed command for %s: %s\", mypw->pw_name, cmdline);\n\t\terrc(1, EPERM, NULL);\n\t}\n\n#if defined(__OpenBSD__) || defined(USE_SHADOW)\n\tif (!(rule->options & NOPASS)) {\n\t\tif (nflag)\n\t\t\terrx(1, \"Authorization required\");\n\n# ifdef __OpenBSD__\n\t\tauthuser(mypw->pw_name, login_style, rule->options & PERSIST);\n# else\n\t\tshadowauth(mypw->pw_name, rule->options & PERSIST);\n# endif\n\t}\n\n# ifdef __OpenBSD__\n\tif (pledge(\"stdio rpath getpw exec id\", NULL) == -1)\n\t\terr(1, \"pledge\");\n# endif\n\n#elif !defined(USE_PAM)\n\t(void) nflag;\n\tif (!(rule->options & NOPASS)) {\n\t\terrx(1, \"Authorization required\");\n\t}\n#endif /* !(__OpenBSD__ || USE_SHADOW) && !USE_PAM */\n\n#ifdef __OpenBSD__\n\trv = getpwuid_r(target, &targpwstore, targpwbuf, sizeof(targpwbuf), &targpw);\n\tif (rv != 0)\n\t\terrx(1, \"no passwd entry for target\");\n#else\n\tfor (size_t sz = 1024; sz <= 16*1024; sz *= 2) {\n\t\ttargpwbuf = reallocarray(targpwbuf, sz, sizeof (char));\n\t\tif (targpwbuf == NULL)\n\t\t\terrx(1, \"can't allocate targpwbuf\");\n\t\trv = getpwuid_r(target, &targpwstore, targpwbuf, sz, &targpw);\n\t\tif (rv != ERANGE)\n\t\t\tbreak;\n\t}\n\tif (rv != 0)\n\t\terr(1, \"getpwuid_r failed\");\n#endif\n\tif (targpw == NULL)\n\t\terr(1, \"getpwuid_r failed\");\n\n#if defined(USE_PAM)\n\tpamauth(targpw->pw_name, mypw->pw_name, !nflag, rule->options & NOPASS,\n\t    rule->options & PERSIST);\n#endif\n\n#ifdef HAVE_SETUSERCONTEXT\n\tif (setusercontext(NULL, targpw, target, LOGIN_SETGROUP |\n\t    LOGIN_SETPRIORITY | LOGIN_SETRESOURCES | LOGIN_SETUMASK |\n\t    LOGIN_SETUSER) != 0)\n\t\terrx(1, \"failed to set user context for target\");\n#else\n\tif (setresgid(targpw->pw_gid, targpw->pw_gid, targpw->pw_gid) != 0)\n\t\terr(1, \"setresgid\");\n\tif (initgroups(targpw->pw_name, targpw->pw_gid) != 0)\n\t\terr(1, \"initgroups\");\n\tif (setresuid(target, target, target) != 0)\n\t\terr(1, \"setresuid\");\n#endif\n\n#ifdef __OpenBSD__\n\tif (pledge(\"stdio rpath exec\", NULL) == -1)\n\t\terr(1, \"pledge\");\n#endif\n\n\tif (getcwd(cwdpath, sizeof(cwdpath)) == NULL)\n\t\tcwd = \"(failed)\";\n\telse\n\t\tcwd = cwdpath;\n\n#ifdef __OpenBSD__\n\tif (pledge(\"stdio exec\", NULL) == -1)\n\t\terr(1, \"pledge\");\n#endif\n\n\tsyslog(LOG_AUTHPRIV | LOG_INFO, \"%s ran command %s as %s from %s\",\n\t    mypw->pw_name, cmdline, targpw->pw_name, cwd);\n\n\tenvp = prepenv(rule);\n\n\tif (rule->cmd) {\n\t\tif (setenv(\"PATH\", safepath, 1) == -1)\n\t\t\terr(1, \"failed to set PATH '%s'\", safepath);\n\t}\n\texecvpe(cmd, argv, envp);\n\tif (errno == ENOENT)\n\t\terrx(1, \"%s: command not found\", cmd);\n\terr(1, \"%s\", cmd);\n}\n", ".\\\" $OpenBSD: doas.conf.5,v 1.13 2015/07/27 21:44:11 tedu Exp $\n.\\\"\n.\\\"Copyright (c) 2015 Ted Unangst <tedu@openbsd.org>\n.\\\"\n.\\\"Permission to use, copy, modify, and distribute this software for any\n.\\\"purpose with or without fee is hereby granted, provided that the above\n.\\\"copyright notice and this permission notice appear in all copies.\n.\\\"\n.\\\"THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n.\\\"WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n.\\\"MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n.\\\"ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n.\\\"WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n.\\\"ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n.\\\"OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n.Dd $Mdocdate: July 27 2015 $\n.Dt DOAS.CONF 5\n.Os\n.Sh NAME\n.Nm doas.conf\n.Nd doas configuration file\n.Sh DESCRIPTION\nThe\n.Xr doas 1\nutility executes commands as other users according to the rules\nin the\n.Nm\nconfiguration file.\n.Pp\nThe rules have the following format:\n.Bd -ragged -offset indent\n.Ic permit Ns | Ns Ic deny\n.Op Ar options\n.Ar identity\n.Op Ic as Ar target\n.Op Ic cmd Ar command Op Ic args No ...\n.Ed\n.Pp\nRules consist of the following parts:\n.Bl -tag -width 11n\n.It Ic permit Ns | Ns Ic deny\nThe action to be taken if this rule matches.\n.It Ar options\nOptions are:\n.Bl -tag -width keepenv\n.It Ic nopass\nThe user is not required to enter a password.\n.It Ic persist\nAfter the user successfully authenticates, do not ask for a password\nagain for some time.\n.It Ic keepenv\nThe user's environment is maintained.\nThe default is to reset the environment, except for the variables\n.Ev DISPLAY ,\n.Ev HOME ,\n.Ev LOGNAME ,\n.Ev MAIL ,\n.Ev PATH ,\n.Ev TERM ,\n.Ev USER\nand\n.Ev USERNAME .\n.It Ic setenv { Oo Ar variable ... Oc Oo Ar variable=value ... Oc Ic }\nIn addition to the variables mentioned above, keep the space-separated\nspecified variables.\nVariables may also be removed with a leading\n.Sq -\nor set using the latter syntax.\nIf the first character of\n.Ar value\nis a\n.Ql $\nthen the value to be set is taken from the existing environment\nvariable of the indicated name.\n.El\n.It Ar identity\nThe username to match.\nGroups may be specified by prepending a colon\n.Pq Sq \\&: .\nNumeric IDs are also accepted.\n.It Ic as Ar target\nThe target user the running user is allowed to run the command as.\nThe default is all users.\n.It Ic cmd Ar command\nThe command the user is allowed or denied to run.\nThe default is all commands.\nBe advised that it is best to specify absolute paths.\nIf a relative path is specified, only a restricted\n.Ev PATH\nwill be searched.\n.It Ic args Op Ar argument ...\nArguments to command.\nThe command arguments provided by the user need to match those specified.\nThe keyword\n.Ic args\nalone means that command must be run without any arguments.\n.El\n.Pp\nThe last matching rule determines the action taken.\nIf no rule matches, the action is denied.\n.Pp\nComments can be put anywhere in the file using a hash mark\n.Pq Sq # ,\nand extend to the end of the current line.\n.Pp\nThe following quoting rules apply:\n.Bl -dash\n.It\nThe text between a pair of double quotes\n.Pq Sq \\&\"\nis taken as is.\n.It\nThe backslash character\n.Pq Sq \\e\nescapes the next character, including new line characters, outside comments;\nas a result, comments may not be extended over multiple lines.\n.It\nIf quotes or backslashes are used in a word,\nit isn't considered a keyword.\n.El\n.Sh FILES\n.Bl -tag -width \"/etc/doas.conf\"\n.It Pa /etc/doas.conf\ndoas configuration file.\n.El\n.Sh EXAMPLES\nThe following example permits user aja to install packages\nfrom a preferred mirror;\ngroup wheel to execute commands as any user while keeping the environment\nvariables\n.Ev PS1\nand\n.Ev SSH_AUTH_SOCK\nand\nunsetting\n.Ev ENV ;\npermits tedu to run procmap as root without a password;\nand additionally permits root to run unrestricted commands as itself.\n.Bd -literal -offset indent\npermit persist setenv { PKG_CACHE PKG_PATH } aja cmd pkg_add\npermit setenv { -ENV PS1=$DOAS_PS1 SSH_AUTH_SOCK } :wheel\npermit nopass tedu as root cmd /usr/sbin/procmap\n.Ed\n.Sh SEE ALSO\n.Xr doas 1\n.Sh HISTORY\nThe\n.Nm\nconfiguration file first appeared in\n.Ox 5.8 .\n.Sh AUTHORS\n.An Ted Unangst Aq Mt tedu@openbsd.org\n", "/* $OpenBSD$ */\n/*\n * Copyright (c) 2015 Ted Unangst <tedu@openbsd.org>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\nstruct rule {\n\tint action;\n\tint options;\n\tconst char *ident;\n\tconst char *target;\n\tconst char *cmd;\n\tconst char **cmdargs;\n\tconst char **envlist;\n};\n\nextern struct rule **rules;\nextern int nrules;\nextern int parse_errors;\n\nchar **prepenv(const struct rule *);\n\n#define PERMIT\t1\n#define DENY\t2\n\n#define NOPASS\t\t0x1\n#define KEEPENV\t\t0x2\n#define PERSIST\t\t0x4\n", "/* $OpenBSD$ */\n/*\n * Copyright (c) 2016 Ted Unangst <tedu@openbsd.org>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include \"sys-tree.h\"\n\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <err.h>\n#include <unistd.h>\n#include <errno.h>\n\n#include \"doas.h\"\n#include \"includes.h\"\n\nstruct envnode {\n\tRB_ENTRY(envnode) node;\n\tconst char *key;\n\tconst char *value;\n};\n\nstruct env {\n\tRB_HEAD(envtree, envnode) root;\n\tu_int count;\n};\n\nstatic int\nenvcmp(struct envnode *a, struct envnode *b)\n{\n\treturn strcmp(a->key, b->key);\n}\nRB_GENERATE_STATIC(envtree, envnode, node, envcmp)\n\nstatic struct envnode *\ncreatenode(const char *key, const char *value)\n{\n\tstruct envnode *node;\n\n\tnode = malloc(sizeof(*node));\n\tif (!node)\n\t\terr(1, NULL);\n\tnode->key = strdup(key);\n\tnode->value = strdup(value);\n\tif (!node->key || !node->value)\n\t\terr(1, NULL);\n\treturn node;\n}\n\nstatic void\nfreenode(struct envnode *node)\n{\n\tfree((char *)node->key);\n\tfree((char *)node->value);\n\tfree(node);\n}\n\nstatic struct env *\ncreateenv(const struct rule *rule)\n{\n\tstruct env *env;\n\tu_int i;\n\n\tenv = malloc(sizeof(*env));\n\tif (!env)\n\t\terr(1, NULL);\n\tRB_INIT(&env->root);\n\tenv->count = 0;\n\n\tif (rule->options & KEEPENV) {\n\t\textern char **environ;\n\n\t\tfor (i = 0; environ[i] != NULL; i++) {\n\t\t\tstruct envnode *node;\n\t\t\tconst char *e, *eq;\n\t\t\tsize_t len;\n\t\t\tchar keybuf[1024];\n\n\t\t\te = environ[i];\n\n\t\t\t/* ignore invalid or overlong names */\n\t\t\tif ((eq = strchr(e, '=')) == NULL || eq == e)\n\t\t\t\tcontinue;\n\t\t\tlen = eq - e;\n\t\t\tif (len > sizeof(keybuf) - 1)\n\t\t\t\tcontinue;\n\t\t\tmemcpy(keybuf, e, len);\n\t\t\tkeybuf[len] = '\\0';\n\n\t\t\tnode = createnode(keybuf, eq + 1);\n\t\t\tif (RB_INSERT(envtree, &env->root, node)) {\n\t\t\t\t/* ignore any later duplicates */\n\t\t\t\tfreenode(node);\n\t\t\t} else {\n\t\t\t\tenv->count++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn env;\n}\n\nstatic char **\nflattenenv(struct env *env)\n{\n\tchar **envp;\n\tstruct envnode *node;\n\tu_int i;\n\n\tenvp = reallocarray(NULL, env->count + 1, sizeof(char *));\n\tif (!envp)\n\t\terr(1, NULL);\n\ti = 0;\n\tRB_FOREACH(node, envtree, &env->root) {\n\t\tif (asprintf(&envp[i], \"%s=%s\", node->key, node->value) == -1)\n\t\t\terr(1, NULL);\n\t\ti++;\n\t}\n\tenvp[i] = NULL;\n\treturn envp;\n}\n\nstatic void\nfillenv(struct env *env, const char **envlist)\n{\n\tstruct envnode *node, key;\n\tconst char *e, *eq;\n\tconst char *val;\n\tchar name[1024];\n\tu_int i;\n\tsize_t len;\n\n\tfor (i = 0; envlist[i]; i++) {\n\t\te = envlist[i];\n\n\t\t/* parse out env name */\n\t\tif ((eq = strchr(e, '=')) == NULL)\n\t\t\tlen = strlen(e);\n\t\telse\n\t\t\tlen = eq - e;\n\t\tif (len > sizeof(name) - 1)\n\t\t\tcontinue;\n\t\tmemcpy(name, e, len);\n\t\tname[len] = '\\0';\n\n\t\t/* delete previous copies */\n\t\tkey.key = name;\n\t\tif (*name == '-')\n\t\t\tkey.key = name + 1;\n\t\tif ((node = RB_FIND(envtree, &env->root, &key))) {\n\t\t\tRB_REMOVE(envtree, &env->root, node);\n\t\t\tfreenode(node);\n\t\t\tenv->count--;\n\t\t}\n\t\tif (*name == '-')\n\t\t\tcontinue;\n\n\t\t/* assign value or inherit from environ */\n\t\tif (eq) {\n\t\t\tval = eq + 1;\n\t\t\tif (*val == '$')\n\t\t\t\tval = getenv(val + 1);\n\t\t} else {\n\t\t\tval = getenv(name);\n\t\t}\n\t\t/* at last, we have something to insert */\n\t\tif (val) {\n\t\t\tnode = createnode(name, val);\n\t\t\tRB_INSERT(envtree, &env->root, node);\n\t\t\tenv->count++;\n\t\t}\n\t}\n}\n\nchar **\nprepenv(const struct rule *rule)\n{\n\tstatic const char *safeset[] = {\n\t\t\"DISPLAY\", \"HOME\", \"LOGNAME\", \"MAIL\",\n\t\t\"PATH\", \"TERM\", \"USER\", \"USERNAME\",\n\t\tNULL\n\t};\n\tstruct env *env;\n\n\tenv = createenv(rule);\n\n\t/* if we started with blank, fill some defaults then apply rules */\n\tif (!(rule->options & KEEPENV))\n\t\tfillenv(env, safeset);\n\tif (rule->envlist)\n\t\tfillenv(env, rule->envlist);\n\n\treturn flattenenv(env);\n}\n"], "fixing_code": ["/* $OpenBSD: doas.c,v 1.52 2016/04/28 04:48:56 tedu Exp $ */\n/*\n * Copyright (c) 2015 Ted Unangst <tedu@openbsd.org>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n\n#include <limits.h>\n#if __OpenBSD__\n#\tinclude <login_cap.h>\n#\tinclude <readpassphrase.h>\n#endif\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <err.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <grp.h>\n#include <syslog.h>\n#include <errno.h>\n\n#include \"includes.h\"\n\n#include \"doas.h\"\n\nstatic void __dead\nusage(void)\n{\n\tfprintf(stderr, \"usage: doas [-Lns] \"\n#ifdef __OpenBSD__\n\t    \"[-a style] \"\n#endif\n\t    \"[-C config] [-u user] command [args]\\n\");\n\texit(1);\n}\n\nstatic int\nparseuid(const char *s, uid_t *uid)\n{\n\tstruct passwd *pw;\n\tconst char *errstr;\n\n\tif ((pw = getpwnam(s)) != NULL) {\n\t\t*uid = pw->pw_uid;\n\t\treturn 0;\n\t}\n\t*uid = strtonum(s, 0, UID_MAX, &errstr);\n\tif (errstr)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic int\nuidcheck(const char *s, uid_t desired)\n{\n\tuid_t uid;\n\n\tif (parseuid(s, &uid) != 0)\n\t\treturn -1;\n\tif (uid != desired)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic int\nparsegid(const char *s, gid_t *gid)\n{\n\tstruct group *gr;\n\tconst char *errstr;\n\n\tif ((gr = getgrnam(s)) != NULL) {\n\t\t*gid = gr->gr_gid;\n\t\treturn 0;\n\t}\n\t*gid = strtonum(s, 0, GID_MAX, &errstr);\n\tif (errstr)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic int\nmatch(uid_t uid, gid_t *groups, int ngroups, uid_t target, const char *cmd,\n    const char **cmdargs, struct rule *r)\n{\n\tint i;\n\n\tif (r->ident[0] == ':') {\n\t\tgid_t rgid;\n\t\tif (parsegid(r->ident + 1, &rgid) == -1)\n\t\t\treturn 0;\n\t\tfor (i = 0; i < ngroups; i++) {\n\t\t\tif (rgid == groups[i])\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i == ngroups)\n\t\t\treturn 0;\n\t} else {\n\t\tif (uidcheck(r->ident, uid) != 0)\n\t\t\treturn 0;\n\t}\n\tif (r->target && uidcheck(r->target, target) != 0)\n\t\treturn 0;\n\tif (r->cmd) {\n\t\tif (strcmp(r->cmd, cmd))\n\t\t\treturn 0;\n\t\tif (r->cmdargs) {\n\t\t\t/* if arguments were given, they should match explicitly */\n\t\t\tfor (i = 0; r->cmdargs[i]; i++) {\n\t\t\t\tif (!cmdargs[i])\n\t\t\t\t\treturn 0;\n\t\t\t\tif (strcmp(r->cmdargs[i], cmdargs[i]))\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (cmdargs[i])\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic int\npermit(uid_t uid, gid_t *groups, int ngroups, const struct rule **lastr,\n    uid_t target, const char *cmd, const char **cmdargs)\n{\n\tint i;\n\n\t*lastr = NULL;\n\tfor (i = 0; i < nrules; i++) {\n\t\tif (match(uid, groups, ngroups, target, cmd,\n\t\t    cmdargs, rules[i]))\n\t\t\t*lastr = rules[i];\n\t}\n\tif (!*lastr)\n\t\treturn 0;\n\treturn (*lastr)->action == PERMIT;\n}\n\nstatic void\nparseconfig(const char *filename, int checkperms)\n{\n\textern FILE *yyfp;\n\textern int yyparse(void);\n\tstruct stat sb;\n\n\tyyfp = fopen(filename, \"r\");\n\tif (!yyfp)\n\t\terr(1, checkperms ? \"doas is not enabled, %s\" :\n\t\t    \"could not open config file %s\", filename);\n\n\tif (checkperms) {\n\t\tif (fstat(fileno(yyfp), &sb) != 0)\n\t\t\terr(1, \"fstat(\\\"%s\\\")\", filename);\n\t\tif ((sb.st_mode & (S_IWGRP|S_IWOTH)) != 0)\n\t\t\terrx(1, \"%s is writable by group or other\", filename);\n\t\tif (sb.st_uid != 0)\n\t\t\terrx(1, \"%s is not owned by root\", filename);\n\t}\n\n\tyyparse();\n\tfclose(yyfp);\n\tif (parse_errors)\n\t\texit(1);\n}\n\nstatic void __dead\ncheckconfig(const char *confpath, int argc, char **argv,\n    uid_t uid, gid_t *groups, int ngroups, uid_t target)\n{\n\tconst struct rule *rule;\n\n\tif (setresuid(uid, uid, uid) != 0)\n\t\terr(1, \"setresuid\");\n\n\tparseconfig(confpath, 0);\n\tif (!argc)\n\t\texit(0);\n\n\tif (permit(uid, groups, ngroups, &rule, target, argv[0],\n\t    (const char **)argv + 1)) {\n\t\tprintf(\"permit%s\\n\", (rule->options & NOPASS) ? \" nopass\" : \"\");\n\t\texit(0);\n\t} else {\n\t\tprintf(\"deny\\n\");\n\t\texit(1);\n\t}\n}\n\n#ifdef USE_BSD_AUTH\nstatic void\nauthuser(char *myname, char *login_style, int persist)\n{\n\tchar *challenge = NULL, *response, rbuf[1024], cbuf[128];\n\tauth_session_t *as;\n\tint fd = -1;\n\n\tif (persist)\n\t\tfd = open(\"/dev/tty\", O_RDWR);\n\tif (fd != -1) {\n\t\tif (ioctl(fd, TIOCCHKVERAUTH) == 0)\n\t\t\tgoto good;\n\t}\n\n\tif (!(as = auth_userchallenge(myname, login_style, \"auth-doas\",\n\t    &challenge)))\n\t\terrx(1, \"Authorization failed\");\n\tif (!challenge) {\n\t\tchar host[HOST_NAME_MAX + 1];\n\t\tif (gethostname(host, sizeof(host)))\n\t\t\tsnprintf(host, sizeof(host), \"?\");\n\t\tsnprintf(cbuf, sizeof(cbuf),\n\t\t    \"\\rdoas (%.32s@%.32s) password: \", myname, host);\n\t\tchallenge = cbuf;\n\t}\n\tresponse = readpassphrase(challenge, rbuf, sizeof(rbuf),\n\t    RPP_REQUIRE_TTY);\n\tif (response == NULL && errno == ENOTTY) {\n\t\tsyslog(LOG_AUTHPRIV | LOG_NOTICE,\n\t\t    \"tty required for %s\", myname);\n\t\terrx(1, \"a tty is required\");\n\t}\n\tif (!auth_userresponse(as, response, 0)) {\n\t\texplicit_bzero(rbuf, sizeof(rbuf));\n\t\tsyslog(LOG_AUTHPRIV | LOG_NOTICE,\n\t\t    \"failed auth for %s\", myname);\n\t\terrx(1, \"Authorization failed\");\n\t}\n\texplicit_bzero(rbuf, sizeof(rbuf));\ngood:\n\tif (fd != -1) {\n\t\tint secs = 5 * 60;\n\t\tioctl(fd, TIOCSETVERAUTH, &secs);\n\t\tclose(fd);\n\t}\n}\n#endif\n\nint\nmain(int argc, char **argv)\n{\n\tconst char *safepath = \"/bin:/sbin:/usr/bin:/usr/sbin:\"\n\t    \"/usr/local/bin:/usr/local/sbin\";\n\tconst char *confpath = NULL;\n\tchar *shargv[] = { NULL, NULL };\n\tchar *sh;\n\tconst char *cmd;\n\tchar cmdline[LINE_MAX];\n#ifdef __OpenBSD__\n\tchar mypwbuf[_PW_BUF_LEN], targpwbuf[_PW_BUF_LEN];\n#else\n\tchar *mypwbuf = NULL, *targpwbuf = NULL;\n#endif\n\tstruct passwd mypwstore, targpwstore;\n\tstruct passwd *mypw, *targpw;\n\tconst struct rule *rule;\n\tuid_t uid;\n\tuid_t target = 0;\n\tgid_t groups[NGROUPS_MAX + 1];\n\tint ngroups;\n\tint i, ch, rv;\n\tint sflag = 0;\n\tint nflag = 0;\n\tchar cwdpath[PATH_MAX];\n\tconst char *cwd;\n\tchar **envp;\n#ifdef USE_BSD_AUTH\n\tchar *login_style = NULL;\n#endif\n\n\tsetprogname(\"doas\");\n\n\tclosefrom(STDERR_FILENO + 1);\n\n\tuid = getuid();\n\n#ifdef USE_BSD_AUTH\n# define OPTSTRING \"a:C:Lnsu:\"\n#else\n# define OPTSTRING \"+C:Lnsu:\"\n#endif\n\n\twhile ((ch = getopt(argc, argv, OPTSTRING)) != -1) {\n\t\tswitch (ch) {\n#ifdef USE_BSD_AUTH\n\t\tcase 'a':\n\t\t\tlogin_style = optarg;\n\t\t\tbreak;\n#endif\n\t\tcase 'C':\n\t\t\tconfpath = optarg;\n\t\t\tbreak;\n\t\tcase 'L':\n#if defined(USE_BSD_AUTH)\n\t\t\ti = open(\"/dev/tty\", O_RDWR);\n\t\t\tif (i != -1)\n\t\t\t\tioctl(i, TIOCCLRVERAUTH);\n\t\t\texit(i == -1);\n#elif defined(USE_TIMESTAMP)\n\t\t\texit(timestamp_clear() == -1);\n#else\n\t\t\texit(0);\n#endif\n\t\tcase 'u':\n\t\t\tif (parseuid(optarg, &target) != 0)\n\t\t\t\terrx(1, \"unknown user\");\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tnflag = 1;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tsflag = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t\tbreak;\n\t\t}\n\t}\n\targv += optind;\n\targc -= optind;\n\n\tif (confpath) {\n\t\tif (sflag)\n\t\t\tusage();\n\t} else if ((!sflag && !argc) || (sflag && argc))\n\t\tusage();\n\n#ifdef __OpenBSD__\n\trv = getpwuid_r(uid, &mypwstore, mypwbuf, sizeof(mypwbuf), &mypw);\n\tif (rv != 0)\n\t\terr(1, \"getpwuid_r failed\");\n#else\n\tfor (size_t sz = 1024; sz <= 16*1024; sz *= 2) {\n\t\tmypwbuf = reallocarray(mypwbuf, sz, sizeof (char));\n\t\tif (mypwbuf == NULL)\n\t\t\terrx(1, \"can't allocate mypwbuf\");\n\t\trv = getpwuid_r(uid, &mypwstore, mypwbuf, sz, &mypw);\n\t\tif (rv != ERANGE)\n\t\t\tbreak;\n\t}\n\tif (rv != 0)\n\t\terr(1, \"getpwuid_r failed\");\n#endif\n\tif (mypw == NULL)\n\t\terrx(1, \"no passwd entry for self\");\n\tngroups = getgroups(NGROUPS_MAX, groups);\n\tif (ngroups == -1)\n\t\terr(1, \"can't get groups\");\n\tgroups[ngroups++] = getgid();\n\n\tif (sflag) {\n\t\tsh = getenv(\"SHELL\");\n\t\tif (sh == NULL || *sh == '\\0') {\n\t\t\tshargv[0] = mypw->pw_shell;\n\t\t} else\n\t\t\tshargv[0] = sh;\n\t\targv = shargv;\n\t\targc = 1;\n\t}\n\n\tif (confpath) {\n\t\tcheckconfig(confpath, argc, argv, uid, groups, ngroups,\n\t\t    target);\n\t\texit(1);\t/* fail safe */\n\t}\n\n\tif (geteuid())\n\t\terrx(1, \"not installed setuid\");\n\n\tparseconfig(\"/etc/doas.conf\", 1);\n\n\t/* cmdline is used only for logging, no need to abort on truncate */\n\t(void)strlcpy(cmdline, argv[0], sizeof(cmdline));\n\tfor (i = 1; i < argc; i++) {\n\t\tif (strlcat(cmdline, \" \", sizeof(cmdline)) >= sizeof(cmdline))\n\t\t\tbreak;\n\t\tif (strlcat(cmdline, argv[i], sizeof(cmdline)) >= sizeof(cmdline))\n\t\t\tbreak;\n\t}\n\n\tcmd = argv[0];\n\tif (!permit(uid, groups, ngroups, &rule, target, cmd,\n\t    (const char **)argv + 1)) {\n\t\tsyslog(LOG_AUTHPRIV | LOG_NOTICE,\n\t\t    \"failed command for %s: %s\", mypw->pw_name, cmdline);\n\t\terrc(1, EPERM, NULL);\n\t}\n\n#if defined(__OpenBSD__) || defined(USE_SHADOW)\n\tif (!(rule->options & NOPASS)) {\n\t\tif (nflag)\n\t\t\terrx(1, \"Authorization required\");\n\n# ifdef __OpenBSD__\n\t\tauthuser(mypw->pw_name, login_style, rule->options & PERSIST);\n# else\n\t\tshadowauth(mypw->pw_name, rule->options & PERSIST);\n# endif\n\t}\n\n# ifdef __OpenBSD__\n\tif (pledge(\"stdio rpath getpw exec id\", NULL) == -1)\n\t\terr(1, \"pledge\");\n# endif\n\n#elif !defined(USE_PAM)\n\t(void) nflag;\n\tif (!(rule->options & NOPASS)) {\n\t\terrx(1, \"Authorization required\");\n\t}\n#endif /* !(__OpenBSD__ || USE_SHADOW) && !USE_PAM */\n\n#ifdef __OpenBSD__\n\trv = getpwuid_r(target, &targpwstore, targpwbuf, sizeof(targpwbuf), &targpw);\n\tif (rv != 0)\n\t\terrx(1, \"no passwd entry for target\");\n#else\n\tfor (size_t sz = 1024; sz <= 16*1024; sz *= 2) {\n\t\ttargpwbuf = reallocarray(targpwbuf, sz, sizeof (char));\n\t\tif (targpwbuf == NULL)\n\t\t\terrx(1, \"can't allocate targpwbuf\");\n\t\trv = getpwuid_r(target, &targpwstore, targpwbuf, sz, &targpw);\n\t\tif (rv != ERANGE)\n\t\t\tbreak;\n\t}\n\tif (rv != 0)\n\t\terr(1, \"getpwuid_r failed\");\n#endif\n\tif (targpw == NULL)\n\t\terr(1, \"getpwuid_r failed\");\n\n#if defined(USE_PAM)\n\tpamauth(targpw->pw_name, mypw->pw_name, !nflag, rule->options & NOPASS,\n\t    rule->options & PERSIST);\n#endif\n\n#ifdef HAVE_SETUSERCONTEXT\n\tif (setusercontext(NULL, targpw, target, LOGIN_SETGROUP |\n\t    LOGIN_SETPATH |\n\t    LOGIN_SETPRIORITY | LOGIN_SETRESOURCES | LOGIN_SETUMASK |\n\t    LOGIN_SETUSER) != 0)\n\t\terrx(1, \"failed to set user context for target\");\n#else\n\tif (setresgid(targpw->pw_gid, targpw->pw_gid, targpw->pw_gid) != 0)\n\t\terr(1, \"setresgid\");\n\tif (initgroups(targpw->pw_name, targpw->pw_gid) != 0)\n\t\terr(1, \"initgroups\");\n\tif (setresuid(target, target, target) != 0)\n\t\terr(1, \"setresuid\");\n#endif\n\n#ifdef __OpenBSD__\n\tif (pledge(\"stdio rpath exec\", NULL) == -1)\n\t\terr(1, \"pledge\");\n#endif\n\n\tif (getcwd(cwdpath, sizeof(cwdpath)) == NULL)\n\t\tcwd = \"(failed)\";\n\telse\n\t\tcwd = cwdpath;\n\n#ifdef __OpenBSD__\n\tif (pledge(\"stdio exec\", NULL) == -1)\n\t\terr(1, \"pledge\");\n#endif\n\n\tsyslog(LOG_AUTHPRIV | LOG_INFO, \"%s ran command %s as %s from %s\",\n\t    mypw->pw_name, cmdline, targpw->pw_name, cwd);\n\n\tenvp = prepenv(rule, mypw, targpw);\n\n\tif (rule->cmd) {\n\t\t/* do this again after setusercontext reset it */\n\t\tif (setenv(\"PATH\", safepath, 1) == -1)\n\t\t\terr(1, \"failed to set PATH '%s'\", safepath);\n\t}\n\texecvpe(cmd, argv, envp);\n\tif (errno == ENOENT)\n\t\terrx(1, \"%s: command not found\", cmd);\n\terr(1, \"%s\", cmd);\n}\n", ".\\\" $OpenBSD: doas.conf.5,v 1.13 2015/07/27 21:44:11 tedu Exp $\n.\\\"\n.\\\"Copyright (c) 2015 Ted Unangst <tedu@openbsd.org>\n.\\\"\n.\\\"Permission to use, copy, modify, and distribute this software for any\n.\\\"purpose with or without fee is hereby granted, provided that the above\n.\\\"copyright notice and this permission notice appear in all copies.\n.\\\"\n.\\\"THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n.\\\"WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n.\\\"MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n.\\\"ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n.\\\"WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n.\\\"ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n.\\\"OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n.Dd $Mdocdate: July 27 2015 $\n.Dt DOAS.CONF 5\n.Os\n.Sh NAME\n.Nm doas.conf\n.Nd doas configuration file\n.Sh DESCRIPTION\nThe\n.Xr doas 1\nutility executes commands as other users according to the rules\nin the\n.Nm\nconfiguration file.\n.Pp\nThe rules have the following format:\n.Bd -ragged -offset indent\n.Ic permit Ns | Ns Ic deny\n.Op Ar options\n.Ar identity\n.Op Ic as Ar target\n.Op Ic cmd Ar command Op Ic args No ...\n.Ed\n.Pp\nRules consist of the following parts:\n.Bl -tag -width 11n\n.It Ic permit Ns | Ns Ic deny\nThe action to be taken if this rule matches.\n.It Ar options\nOptions are:\n.Bl -tag -width keepenv\n.It Ic nopass\nThe user is not required to enter a password.\n.It Ic persist\nAfter the user successfully authenticates, do not ask for a password\nagain for some time.\n.It Ic keepenv\nThe user's environment is maintained.\nThe default is to reset the environment, except for the variables\n.Ev DISPLAY\nand\n.Ev TERM .\n.It Ic setenv { Oo Ar variable ... Oc Oo Ar variable=value ... Oc Ic }\nIn addition to the variables mentioned above, keep the space-separated\nspecified variables.\nVariables may also be removed with a leading\n.Sq -\nor set using the latter syntax.\nIf the first character of\n.Ar value\nis a\n.Ql $\nthen the value to be set is taken from the existing environment\nvariable of the indicated name.\n.El\n.It Ar identity\nThe username to match.\nGroups may be specified by prepending a colon\n.Pq Sq \\&: .\nNumeric IDs are also accepted.\n.It Ic as Ar target\nThe target user the running user is allowed to run the command as.\nThe default is all users.\n.It Ic cmd Ar command\nThe command the user is allowed or denied to run.\nThe default is all commands.\nBe advised that it is best to specify absolute paths.\nIf a relative path is specified, only a restricted\n.Ev PATH\nwill be searched.\n.It Ic args Op Ar argument ...\nArguments to command.\nThe command arguments provided by the user need to match those specified.\nThe keyword\n.Ic args\nalone means that command must be run without any arguments.\n.El\n.Pp\nThe last matching rule determines the action taken.\nIf no rule matches, the action is denied.\n.Pp\nComments can be put anywhere in the file using a hash mark\n.Pq Sq # ,\nand extend to the end of the current line.\n.Pp\nThe following quoting rules apply:\n.Bl -dash\n.It\nThe text between a pair of double quotes\n.Pq Sq \\&\"\nis taken as is.\n.It\nThe backslash character\n.Pq Sq \\e\nescapes the next character, including new line characters, outside comments;\nas a result, comments may not be extended over multiple lines.\n.It\nIf quotes or backslashes are used in a word,\nit isn't considered a keyword.\n.El\n.Sh FILES\n.Bl -tag -width \"/etc/doas.conf\"\n.It Pa /etc/doas.conf\ndoas configuration file.\n.El\n.Sh EXAMPLES\nThe following example permits user aja to install packages\nfrom a preferred mirror;\ngroup wheel to execute commands as any user while keeping the environment\nvariables\n.Ev PS1\nand\n.Ev SSH_AUTH_SOCK\nand\nunsetting\n.Ev ENV ;\npermits tedu to run procmap as root without a password;\nand additionally permits root to run unrestricted commands as itself.\n.Bd -literal -offset indent\npermit persist setenv { PKG_CACHE PKG_PATH } aja cmd pkg_add\npermit setenv { -ENV PS1=$DOAS_PS1 SSH_AUTH_SOCK } :wheel\npermit nopass tedu as root cmd /usr/sbin/procmap\n.Ed\n.Sh SEE ALSO\n.Xr doas 1\n.Sh HISTORY\nThe\n.Nm\nconfiguration file first appeared in\n.Ox 5.8 .\n.Sh AUTHORS\n.An Ted Unangst Aq Mt tedu@openbsd.org\n", "/* $OpenBSD$ */\n/*\n * Copyright (c) 2015 Ted Unangst <tedu@openbsd.org>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\nstruct rule {\n\tint action;\n\tint options;\n\tconst char *ident;\n\tconst char *target;\n\tconst char *cmd;\n\tconst char **cmdargs;\n\tconst char **envlist;\n};\n\nextern struct rule **rules;\nextern int nrules;\nextern int parse_errors;\n\nstruct passwd;\n\nchar **prepenv(const struct rule *, const struct passwd *,\n    const struct passwd *);\n\n#define PERMIT\t1\n#define DENY\t2\n\n#define NOPASS\t\t0x1\n#define KEEPENV\t\t0x2\n#define PERSIST\t\t0x4\n", "/* $OpenBSD$ */\n/*\n * Copyright (c) 2016 Ted Unangst <tedu@openbsd.org>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include \"sys-tree.h\"\n\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <err.h>\n#include <unistd.h>\n#include <errno.h>\n#include <pwd.h>\n\n#include \"doas.h\"\n#include \"includes.h\"\n\nstruct envnode {\n\tRB_ENTRY(envnode) node;\n\tconst char *key;\n\tconst char *value;\n};\n\nstruct env {\n\tRB_HEAD(envtree, envnode) root;\n\tu_int count;\n};\n\nstatic void fillenv(struct env *env, const char **envlist);\n\nstatic int\nenvcmp(struct envnode *a, struct envnode *b)\n{\n\treturn strcmp(a->key, b->key);\n}\nRB_GENERATE_STATIC(envtree, envnode, node, envcmp)\n\nstatic struct envnode *\ncreatenode(const char *key, const char *value)\n{\n\tstruct envnode *node;\n\n\tnode = malloc(sizeof(*node));\n\tif (!node)\n\t\terr(1, NULL);\n\tnode->key = strdup(key);\n\tnode->value = strdup(value);\n\tif (!node->key || !node->value)\n\t\terr(1, NULL);\n\treturn node;\n}\n\nstatic void\nfreenode(struct envnode *node)\n{\n\tfree((char *)node->key);\n\tfree((char *)node->value);\n\tfree(node);\n}\n\nstatic void\naddnode(struct env *env, const char *key, const char *value)\n{\n\tstruct envnode *node;\n\n\tnode = createnode(key, value);\n\tRB_INSERT(envtree, &env->root, node);\n\tenv->count++;\n}\n\nstatic struct env *\ncreateenv(const struct rule *rule, const struct passwd *mypw,\n    const struct passwd *targpw)\n{\n\tstruct env *env;\n\tu_int i;\n\n\tenv = malloc(sizeof(*env));\n\tif (!env)\n\t\terr(1, NULL);\n\tRB_INIT(&env->root);\n\tenv->count = 0;\n\n\taddnode(env, \"DOAS_USER\", mypw->pw_name);\n\n\tif (rule->options & KEEPENV) {\n\t\textern char **environ;\n\n\t\tfor (i = 0; environ[i] != NULL; i++) {\n\t\t\tstruct envnode *node;\n\t\t\tconst char *e, *eq;\n\t\t\tsize_t len;\n\t\t\tchar keybuf[1024];\n\n\t\t\te = environ[i];\n\n\t\t\t/* ignore invalid or overlong names */\n\t\t\tif ((eq = strchr(e, '=')) == NULL || eq == e)\n\t\t\t\tcontinue;\n\t\t\tlen = eq - e;\n\t\t\tif (len > sizeof(keybuf) - 1)\n\t\t\t\tcontinue;\n\t\t\tmemcpy(keybuf, e, len);\n\t\t\tkeybuf[len] = '\\0';\n\n\t\t\tnode = createnode(keybuf, eq + 1);\n\t\t\tif (RB_INSERT(envtree, &env->root, node)) {\n\t\t\t\t/* ignore any later duplicates */\n\t\t\t\tfreenode(node);\n\t\t\t} else {\n\t\t\t\tenv->count++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tstatic const char *copyset[] = {\n\t\t\t\"DISPLAY\", \"TERM\",\n\t\t\tNULL\n\t\t};\n\n\t\taddnode(env, \"HOME\", targpw->pw_dir);\n\t\taddnode(env, \"LOGNAME\", targpw->pw_name);\n\t\taddnode(env, \"PATH\", getenv(\"PATH\"));\n\t\taddnode(env, \"SHELL\", targpw->pw_shell);\n\t\taddnode(env, \"USER\", targpw->pw_name);\n\n\t\tfillenv(env, copyset);\n\t}\n\n\treturn env;\n}\n\nstatic char **\nflattenenv(struct env *env)\n{\n\tchar **envp;\n\tstruct envnode *node;\n\tu_int i;\n\n\tenvp = reallocarray(NULL, env->count + 1, sizeof(char *));\n\tif (!envp)\n\t\terr(1, NULL);\n\ti = 0;\n\tRB_FOREACH(node, envtree, &env->root) {\n\t\tif (asprintf(&envp[i], \"%s=%s\", node->key, node->value) == -1)\n\t\t\terr(1, NULL);\n\t\ti++;\n\t}\n\tenvp[i] = NULL;\n\treturn envp;\n}\n\nstatic void\nfillenv(struct env *env, const char **envlist)\n{\n\tstruct envnode *node, key;\n\tconst char *e, *eq;\n\tconst char *val;\n\tchar name[1024];\n\tu_int i;\n\tsize_t len;\n\n\tfor (i = 0; envlist[i]; i++) {\n\t\te = envlist[i];\n\n\t\t/* parse out env name */\n\t\tif ((eq = strchr(e, '=')) == NULL)\n\t\t\tlen = strlen(e);\n\t\telse\n\t\t\tlen = eq - e;\n\t\tif (len > sizeof(name) - 1)\n\t\t\tcontinue;\n\t\tmemcpy(name, e, len);\n\t\tname[len] = '\\0';\n\n\t\t/* delete previous copies */\n\t\tkey.key = name;\n\t\tif (*name == '-')\n\t\t\tkey.key = name + 1;\n\t\tif ((node = RB_FIND(envtree, &env->root, &key))) {\n\t\t\tRB_REMOVE(envtree, &env->root, node);\n\t\t\tfreenode(node);\n\t\t\tenv->count--;\n\t\t}\n\t\tif (*name == '-')\n\t\t\tcontinue;\n\n\t\t/* assign value or inherit from environ */\n\t\tif (eq) {\n\t\t\tval = eq + 1;\n\t\t\tif (*val == '$')\n\t\t\t\tval = getenv(val + 1);\n\t\t} else {\n\t\t\tval = getenv(name);\n\t\t}\n\t\t/* at last, we have something to insert */\n\t\tif (val) {\n\t\t\tnode = createnode(name, val);\n\t\t\tRB_INSERT(envtree, &env->root, node);\n\t\t\tenv->count++;\n\t\t}\n\t}\n}\n\nchar **\nprepenv(const struct rule *rule, const struct passwd *mypw,\n    const struct passwd *targpw)\n{\n\tstruct env *env;\n\n\tenv = createenv(rule, mypw, targpw);\n\tif (rule->envlist)\n\t\tfillenv(env, rule->envlist);\n\n\treturn flattenenv(env);\n}\n"], "filenames": ["doas.c", "doas.conf.5", "doas.h", "env.c"], "buggy_code_start_loc": [451, 54, 32, 26], "buggy_code_end_loc": [484, 63, 33, 204], "fixing_code_start_loc": [452, 54, 32, 27], "fixing_code_end_loc": [487, 57, 36, 225], "type": "CWE-459", "message": "In OpenDoas from 6.6 to 6.8 the users PATH variable was incorrectly inherited by authenticated executions if the authenticating rule allowed the user to execute any command. Rules that only allowed to authenticated user to execute specific commands were not affected by this issue.", "other": {"cve": {"id": "CVE-2019-25016", "sourceIdentifier": "cve@mitre.org", "published": "2021-01-28T20:15:12.663", "lastModified": "2022-04-26T16:14:29.577", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In OpenDoas from 6.6 to 6.8 the users PATH variable was incorrectly inherited by authenticated executions if the authenticating rule allowed the user to execute any command. Rules that only allowed to authenticated user to execute specific commands were not affected by this issue."}, {"lang": "es", "value": "En OpenDoas desde la versi\u00f3n 6.6 a la versi\u00f3n 6.8 la variable PATH del usuario era heredada incorrectamente por las ejecuciones autenticadas si la regla de autenticaci\u00f3n permit\u00eda al usuario ejecutar cualquier comando. Las reglas que s\u00f3lo permit\u00edan al usuario autenticado ejecutar comandos espec\u00edficos no se ve\u00edan afectadas por este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-459"}, {"lang": "en", "value": "CWE-909"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:opendoas_project:opendoas:*:*:*:*:*:*:*:*", "versionStartIncluding": "6.6", "versionEndIncluding": "6.8", "matchCriteriaId": "DE983C62-E301-449A-B3A0-BBE5A5DA4C70"}]}]}], "references": [{"url": "https://github.com/Duncaen/OpenDoas/commit/01c658f8c45cb92a343be5f32aa6da70b2032168", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Duncaen/OpenDoas/commit/d5acd52e2a15c36a8e06f9103d35622933aa422d", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Duncaen/OpenDoas/issues/45", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/Duncaen/OpenDoas/releases/tag/v6.8.1", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202107-11", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Duncaen/OpenDoas/commit/01c658f8c45cb92a343be5f32aa6da70b2032168"}}