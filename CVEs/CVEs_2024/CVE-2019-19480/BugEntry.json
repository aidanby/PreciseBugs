{"buggy_code": ["/*\n * pkcs15-prkey.c: PKCS #15 private key functions\n *\n * Copyright (C) 2001, 2002  Juha Yrj\u00f6l\u00e4 <juha.yrjola@iki.fi>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#if HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <assert.h>\n\n#ifdef ENABLE_OPENSSL\n#include <openssl/opensslv.h>\n#include <openssl/bn.h>\n#include <openssl/x509.h>\n#include <openssl/x509v3.h>\n#include <openssl/err.h>\n#include <openssl/bn.h>\n#include <openssl/rsa.h>\n#include <openssl/dsa.h>\n#if OPENSSL_VERSION_NUMBER >= 0x10000000L\n\t#ifndef OPENSSL_NO_EC\n\t#include <openssl/ec.h>\n\t#endif\n#endif\n#endif\n\n#include \"internal.h\"\n#include \"asn1.h\"\n#include \"pkcs15.h\"\n#include \"common/compat_strlcpy.h\"\n#include \"aux-data.h\"\n\n/*\n * in src/libopensc/types.h SC_MAX_SUPPORTED_ALGORITHMS  defined as 8\n */\n#define C_ASN1_SUPPORTED_ALGORITHMS_SIZE (SC_MAX_SUPPORTED_ALGORITHMS + 1)\nstatic const struct sc_asn1_entry c_asn1_supported_algorithms[C_ASN1_SUPPORTED_ALGORITHMS_SIZE] = {\n\t{ \"algorithmReference\", SC_ASN1_INTEGER, SC_ASN1_TAG_INTEGER, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"algorithmReference\", SC_ASN1_INTEGER, SC_ASN1_TAG_INTEGER, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"algorithmReference\", SC_ASN1_INTEGER, SC_ASN1_TAG_INTEGER, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"algorithmReference\", SC_ASN1_INTEGER, SC_ASN1_TAG_INTEGER, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"algorithmReference\", SC_ASN1_INTEGER, SC_ASN1_TAG_INTEGER, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"algorithmReference\", SC_ASN1_INTEGER, SC_ASN1_TAG_INTEGER, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"algorithmReference\", SC_ASN1_INTEGER, SC_ASN1_TAG_INTEGER, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"algorithmReference\", SC_ASN1_INTEGER, SC_ASN1_TAG_INTEGER, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ NULL, 0, 0, 0, NULL, NULL }\n};\n\n#define C_ASN1_COM_KEY_ATTR_SIZE 7\nstatic const struct sc_asn1_entry c_asn1_com_key_attr[C_ASN1_COM_KEY_ATTR_SIZE] = {\n\t{ \"iD\",\t\t SC_ASN1_PKCS15_ID, SC_ASN1_TAG_OCTET_STRING, 0, NULL, NULL },\n\t{ \"usage\",\t SC_ASN1_BIT_FIELD, SC_ASN1_TAG_BIT_STRING, 0, NULL, NULL },\n\t{ \"native\",\t SC_ASN1_BOOLEAN, SC_ASN1_TAG_BOOLEAN, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"accessFlags\", SC_ASN1_BIT_FIELD, SC_ASN1_TAG_BIT_STRING, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"keyReference\",SC_ASN1_INTEGER, SC_ASN1_TAG_INTEGER, SC_ASN1_OPTIONAL, NULL, NULL },\n/* Absent in PKCS#15-v1.1 but present in ISO 7816-15(2004-01-15)*/\n\t{ \"algReference\", SC_ASN1_STRUCT, SC_ASN1_CONS | SC_ASN1_CTX | 1, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ NULL, 0, 0, 0, NULL, NULL }\n};\n\n#define C_ASN1_COM_PRKEY_ATTR_SIZE 2\nstatic const struct sc_asn1_entry c_asn1_com_prkey_attr[C_ASN1_COM_PRKEY_ATTR_SIZE] = {\n\t{ \"subjectName\", SC_ASN1_OCTET_STRING, SC_ASN1_TAG_SEQUENCE | SC_ASN1_CONS,\n\t\tSC_ASN1_EMPTY_ALLOWED | SC_ASN1_ALLOC | SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ NULL, 0, 0, 0, NULL, NULL }\n};\n\n#define C_ASN1_RSAKEY_ATTR_SIZE 4\nstatic const struct sc_asn1_entry c_asn1_rsakey_attr[] = {\n\t{ \"value\",         SC_ASN1_PATH, SC_ASN1_TAG_SEQUENCE | SC_ASN1_CONS, SC_ASN1_EMPTY_ALLOWED, NULL, NULL },\n\t{ \"modulusLength\", SC_ASN1_INTEGER, SC_ASN1_TAG_INTEGER, 0, NULL, NULL },\n\t{ \"keyInfo\",\t   SC_ASN1_INTEGER, SC_ASN1_TAG_INTEGER, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ NULL, 0, 0, 0, NULL, NULL }\n};\n\n#define C_ASN1_PRK_RSA_ATTR_SIZE 2\nstatic const struct sc_asn1_entry c_asn1_prk_rsa_attr[C_ASN1_PRK_RSA_ATTR_SIZE] = {\n\t{ \"privateRSAKeyAttributes\", SC_ASN1_STRUCT, SC_ASN1_TAG_SEQUENCE | SC_ASN1_CONS, 0, NULL, NULL },\n\t{ NULL, 0, 0, 0, NULL, NULL }\n};\n\n#define C_ASN1_GOSTR3410KEY_ATTR_SIZE 5\nstatic const struct sc_asn1_entry c_asn1_gostr3410key_attr[C_ASN1_GOSTR3410KEY_ATTR_SIZE] = {\n\t{ \"value\",         SC_ASN1_PATH, SC_ASN1_TAG_SEQUENCE | SC_ASN1_CONS, 0, NULL, NULL },\n\t{ \"params_r3410\",  SC_ASN1_INTEGER, SC_ASN1_TAG_INTEGER, 0, NULL, NULL },\n\t{ \"params_r3411\",  SC_ASN1_INTEGER, SC_ASN1_TAG_INTEGER, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"params_28147\",  SC_ASN1_INTEGER, SC_ASN1_TAG_INTEGER, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ NULL, 0, 0, 0, NULL, NULL }\n};\n\n#define C_ASN1_PRK_GOSTR3410_ATTR_SIZE 2\nstatic const struct sc_asn1_entry c_asn1_prk_gostr3410_attr[C_ASN1_PRK_GOSTR3410_ATTR_SIZE] = {\n\t{ \"privateGOSTR3410KeyAttributes\", SC_ASN1_STRUCT, SC_ASN1_TAG_SEQUENCE | SC_ASN1_CONS, 0, NULL, NULL },\n\t{ NULL, 0, 0, 0, NULL, NULL }\n};\n\n#define C_ASN1_DSAKEY_I_P_ATTR_SIZE 2\nstatic const struct sc_asn1_entry c_asn1_dsakey_i_p_attr[C_ASN1_DSAKEY_I_P_ATTR_SIZE] = {\n\t{ \"path\",\tSC_ASN1_PATH, SC_ASN1_TAG_SEQUENCE | SC_ASN1_CONS, 0, NULL, NULL },\n\t{ NULL, 0, 0, 0, NULL, NULL }\n};\n\n#define C_ASN1_DSAKEY_VALUE_ATTR_SIZE 3\nstatic const struct sc_asn1_entry c_asn1_dsakey_value_attr[C_ASN1_DSAKEY_VALUE_ATTR_SIZE] = {\n\t{ \"path\",\tSC_ASN1_PATH, SC_ASN1_TAG_SEQUENCE | SC_ASN1_CONS, 0, NULL, NULL },\n\t{ \"pathProtected\",SC_ASN1_STRUCT, SC_ASN1_CTX | 1 | SC_ASN1_CONS, 0, NULL, NULL},\n\t{ NULL, 0, 0, 0, NULL, NULL }\n};\n\n#define C_ASN1_DSAKEY_ATTR_SIZE 2\nstatic const struct sc_asn1_entry c_asn1_dsakey_attr[C_ASN1_DSAKEY_ATTR_SIZE] = {\n\t{ \"value\",\tSC_ASN1_CHOICE, 0, 0, NULL, NULL },\n\t{ NULL, 0, 0, 0, NULL, NULL }\n};\n\n#define C_ASN1_PRK_DSA_ATTR_SIZE 2\nstatic const struct sc_asn1_entry c_asn1_prk_dsa_attr[C_ASN1_PRK_DSA_ATTR_SIZE] = {\n\t{ \"privateDSAKeyAttributes\", SC_ASN1_STRUCT, SC_ASN1_TAG_SEQUENCE | SC_ASN1_CONS, 0, NULL, NULL },\n\t{ NULL, 0, 0, 0, NULL, NULL }\n};\n\n/*\n * The element fieldSize is a proprietary extension to ISO 7816-15, providing to the middleware\n * the size of the underlying ECC field. This value is required for determine a proper size for\n * buffer allocations. The field follows the definition for modulusLength in RSA keys\n */\n#define C_ASN1_ECCKEY_ATTR 4\nstatic const struct sc_asn1_entry c_asn1_ecckey_attr[C_ASN1_ECCKEY_ATTR] = {\n\t{ \"value\",\t   SC_ASN1_PATH, SC_ASN1_TAG_SEQUENCE | SC_ASN1_CONS, SC_ASN1_EMPTY_ALLOWED, NULL, NULL },\n\t{ \"fieldSize\",\t   SC_ASN1_INTEGER, SC_ASN1_TAG_INTEGER, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"keyInfo\",\t   SC_ASN1_INTEGER, SC_ASN1_TAG_INTEGER, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ NULL, 0, 0, 0, NULL, NULL }\n};\n\n#define C_ASN1_PRK_ECC_ATTR 2\nstatic const struct sc_asn1_entry c_asn1_prk_ecc_attr[C_ASN1_PRK_ECC_ATTR] = {\n\t{ \"privateECCKeyAttributes\", SC_ASN1_STRUCT, SC_ASN1_TAG_SEQUENCE | SC_ASN1_CONS, 0, NULL, NULL },\n\t{ NULL, 0, 0, 0, NULL, NULL }\n};\n\n#define C_ASN1_PRKEY_SIZE 5\nstatic const struct sc_asn1_entry c_asn1_prkey[C_ASN1_PRKEY_SIZE] = {\n\t{ \"privateRSAKey\", SC_ASN1_PKCS15_OBJECT, SC_ASN1_TAG_SEQUENCE | SC_ASN1_CONS, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"privateECCKey\", SC_ASN1_PKCS15_OBJECT,  0 | SC_ASN1_CTX | SC_ASN1_CONS, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"privateDSAKey\", SC_ASN1_PKCS15_OBJECT,  2 | SC_ASN1_CTX | SC_ASN1_CONS, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"privateGOSTR3410Key\", SC_ASN1_PKCS15_OBJECT, 4 | SC_ASN1_CTX | SC_ASN1_CONS, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ NULL, 0, 0, 0, NULL, NULL }\n};\n\n\nint sc_pkcs15_decode_prkdf_entry(struct sc_pkcs15_card *p15card,\n\t\t\t\t struct sc_pkcs15_object *obj,\n\t\t\t\t const u8 ** buf, size_t *buflen)\n{\n\tsc_context_t *ctx = p15card->card->ctx;\n\tstruct sc_pkcs15_prkey_info info;\n\tint r, i, gostr3410_params[3];\n\tstruct sc_pkcs15_keyinfo_gostparams *keyinfo_gostparams;\n\tsize_t usage_len = sizeof(info.usage);\n\tsize_t af_len = sizeof(info.access_flags);\n\tstruct sc_asn1_entry asn1_com_key_attr[C_ASN1_COM_KEY_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_com_prkey_attr[C_ASN1_COM_PRKEY_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_rsakey_attr[C_ASN1_RSAKEY_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_prk_rsa_attr[C_ASN1_PRK_RSA_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_dsakey_attr[C_ASN1_DSAKEY_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_prk_dsa_attr[C_ASN1_PRK_DSA_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_dsakey_i_p_attr[C_ASN1_DSAKEY_I_P_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_dsakey_value_attr[C_ASN1_DSAKEY_VALUE_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_gostr3410key_attr[C_ASN1_GOSTR3410KEY_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_prk_gostr3410_attr[C_ASN1_PRK_GOSTR3410_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_ecckey_attr[C_ASN1_ECCKEY_ATTR];\n\tstruct sc_asn1_entry asn1_prk_ecc_attr[C_ASN1_PRK_ECC_ATTR];\n\tstruct sc_asn1_entry asn1_prkey[C_ASN1_PRKEY_SIZE];\n\tstruct sc_asn1_entry asn1_supported_algorithms[C_ASN1_SUPPORTED_ALGORITHMS_SIZE];\n\tstruct sc_asn1_pkcs15_object rsa_prkey_obj = {obj, asn1_com_key_attr, asn1_com_prkey_attr, asn1_prk_rsa_attr};\n\tstruct sc_asn1_pkcs15_object dsa_prkey_obj = {obj, asn1_com_key_attr, asn1_com_prkey_attr, asn1_prk_dsa_attr};\n\tstruct sc_asn1_pkcs15_object gostr3410_prkey_obj = {obj, asn1_com_key_attr, asn1_com_prkey_attr, asn1_prk_gostr3410_attr};\n\tstruct sc_asn1_pkcs15_object ecc_prkey_obj = { obj, asn1_com_key_attr, asn1_com_prkey_attr, asn1_prk_ecc_attr };\n\n\tsc_copy_asn1_entry(c_asn1_prkey, asn1_prkey);\n\tsc_copy_asn1_entry(c_asn1_supported_algorithms, asn1_supported_algorithms);\n\n\tsc_copy_asn1_entry(c_asn1_prk_rsa_attr, asn1_prk_rsa_attr);\n\tsc_copy_asn1_entry(c_asn1_rsakey_attr, asn1_rsakey_attr);\n\tsc_copy_asn1_entry(c_asn1_prk_dsa_attr, asn1_prk_dsa_attr);\n\tsc_copy_asn1_entry(c_asn1_dsakey_attr, asn1_dsakey_attr);\n\tsc_copy_asn1_entry(c_asn1_dsakey_value_attr, asn1_dsakey_value_attr);\n\tsc_copy_asn1_entry(c_asn1_dsakey_i_p_attr, asn1_dsakey_i_p_attr);\n\tsc_copy_asn1_entry(c_asn1_prk_gostr3410_attr, asn1_prk_gostr3410_attr);\n\tsc_copy_asn1_entry(c_asn1_gostr3410key_attr, asn1_gostr3410key_attr);\n\tsc_copy_asn1_entry(c_asn1_prk_ecc_attr, asn1_prk_ecc_attr);\n\tsc_copy_asn1_entry(c_asn1_ecckey_attr, asn1_ecckey_attr);\n\n\tsc_copy_asn1_entry(c_asn1_com_prkey_attr, asn1_com_prkey_attr);\n\tsc_copy_asn1_entry(c_asn1_com_key_attr, asn1_com_key_attr);\n\n\tsc_format_asn1_entry(asn1_prkey + 0, &rsa_prkey_obj, NULL, 0);\n\tsc_format_asn1_entry(asn1_prkey + 1, &ecc_prkey_obj, NULL, 0);\n\tsc_format_asn1_entry(asn1_prkey + 2, &dsa_prkey_obj, NULL, 0);\n\tsc_format_asn1_entry(asn1_prkey + 3, &gostr3410_prkey_obj, NULL, 0);\n\n\tsc_format_asn1_entry(asn1_prk_rsa_attr + 0, asn1_rsakey_attr, NULL, 0);\n\tsc_format_asn1_entry(asn1_prk_dsa_attr + 0, asn1_dsakey_attr, NULL, 0);\n\tsc_format_asn1_entry(asn1_prk_gostr3410_attr + 0, asn1_gostr3410key_attr, NULL, 0);\n\tsc_format_asn1_entry(asn1_prk_ecc_attr + 0, asn1_ecckey_attr, NULL, 0);\n\n\tsc_format_asn1_entry(asn1_rsakey_attr + 0, &info.path, NULL, 0);\n\tsc_format_asn1_entry(asn1_rsakey_attr + 1, &info.modulus_length, NULL, 0);\n\n\tsc_format_asn1_entry(asn1_dsakey_attr + 0, asn1_dsakey_value_attr, NULL, 0);\n\tsc_format_asn1_entry(asn1_dsakey_value_attr + 0, &info.path, NULL, 0);\n\tsc_format_asn1_entry(asn1_dsakey_value_attr + 1, asn1_dsakey_i_p_attr, NULL, 0);\n\tsc_format_asn1_entry(asn1_dsakey_i_p_attr + 0, &info.path, NULL, 0);\n\n\tsc_format_asn1_entry(asn1_gostr3410key_attr + 0, &info.path, NULL, 0);\n\tsc_format_asn1_entry(asn1_gostr3410key_attr + 1, &gostr3410_params[0], NULL, 0);\n\tsc_format_asn1_entry(asn1_gostr3410key_attr + 2, &gostr3410_params[1], NULL, 0);\n\tsc_format_asn1_entry(asn1_gostr3410key_attr + 3, &gostr3410_params[2], NULL, 0);\n\n\tsc_format_asn1_entry(asn1_ecckey_attr + 0, &info.path, NULL, 0);\n\tsc_format_asn1_entry(asn1_ecckey_attr + 1, &info.field_length, NULL, 0);\n\n\tsc_format_asn1_entry(asn1_com_key_attr + 0, &info.id, NULL, 0);\n\tsc_format_asn1_entry(asn1_com_key_attr + 1, &info.usage, &usage_len, 0);\n\tsc_format_asn1_entry(asn1_com_key_attr + 2, &info.native, NULL, 0);\n\tsc_format_asn1_entry(asn1_com_key_attr + 3, &info.access_flags, &af_len, 0);\n\tsc_format_asn1_entry(asn1_com_key_attr + 4, &info.key_reference, NULL, 0);\n\n\tfor (i=0; i<SC_MAX_SUPPORTED_ALGORITHMS && (asn1_supported_algorithms + i)->name; i++)\n\t\tsc_format_asn1_entry(asn1_supported_algorithms + i, &info.algo_refs[i], NULL, 0);\n\tsc_format_asn1_entry(asn1_com_key_attr + 5, asn1_supported_algorithms, NULL, 0);\n\n\tsc_format_asn1_entry(asn1_com_prkey_attr + 0, &info.subject.value, &info.subject.len, 0);\n\n\t/* Fill in defaults */\n\tmemset(&info, 0, sizeof(info));\n\tinfo.key_reference = -1;\n\tinfo.native = 1;\n\tmemset(gostr3410_params, 0, sizeof(gostr3410_params));\n\n\tr = sc_asn1_decode_choice(ctx, asn1_prkey, *buf, *buflen, buf, buflen);\n\tif (r < 0) {\n\t\t/* This might have allocated something. If so, clear it now */\n\t\tif (asn1_com_prkey_attr->flags & SC_ASN1_PRESENT &&\n\t\t\tasn1_com_prkey_attr[0].flags & SC_ASN1_PRESENT) {\n\t\t\tfree(asn1_com_prkey_attr[0].parm);\n\t\t}\n\t}\n\tif (r == SC_ERROR_ASN1_END_OF_CONTENTS)\n\t\treturn r;\n\tLOG_TEST_RET(ctx, r, \"PrKey DF ASN.1 decoding failed\");\n\tif (asn1_prkey[0].flags & SC_ASN1_PRESENT) {\n\t\tobj->type = SC_PKCS15_TYPE_PRKEY_RSA;\n\t}\n\telse if (asn1_prkey[1].flags & SC_ASN1_PRESENT) {\n\t\tobj->type = SC_PKCS15_TYPE_PRKEY_EC;\n\t}\n\telse if (asn1_prkey[2].flags & SC_ASN1_PRESENT) {\n\t\tobj->type = SC_PKCS15_TYPE_PRKEY_DSA;\n\t\t/* If the value was indirect-protected, mark the path */\n\t\tif (asn1_dsakey_i_p_attr[0].flags & SC_ASN1_PRESENT)\n\t\t\tinfo.path.type = SC_PATH_TYPE_PATH_PROT;\n\t}\n\telse if (asn1_prkey[3].flags & SC_ASN1_PRESENT) {\n\t\tobj->type = SC_PKCS15_TYPE_PRKEY_GOSTR3410;\n\t\tassert(info.modulus_length == 0);\n\t\tinfo.modulus_length = SC_PKCS15_GOSTR3410_KEYSIZE;\n\t\tassert(info.params.len == 0);\n\t\tinfo.params.len = sizeof(struct sc_pkcs15_keyinfo_gostparams);\n\t\tinfo.params.data = malloc(info.params.len);\n\t\tif (info.params.data == NULL)\n\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_OUT_OF_MEMORY);\n\t\tassert(sizeof(*keyinfo_gostparams) == info.params.len);\n\t\tkeyinfo_gostparams = info.params.data;\n\t\tkeyinfo_gostparams->gostr3410 = gostr3410_params[0];\n\t\tkeyinfo_gostparams->gostr3411 = gostr3410_params[1];\n\t\tkeyinfo_gostparams->gost28147 = gostr3410_params[2];\n\t}\n\telse {\n\t\tsc_log(ctx, \"Neither RSA or DSA or GOSTR3410 or ECC key in PrKDF entry.\");\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_ASN1_OBJECT);\n\t}\n\n\tif (!p15card->app || !p15card->app->ddo.aid.len)   {\n\t\tr = sc_pkcs15_make_absolute_path(&p15card->file_app->path, &info.path);\n\t\tif (r < 0) {\n\t\t\tsc_pkcs15_free_key_params(&info.params);\n\t\t\treturn r;\n\t\t}\n\t}\n\telse   {\n\t\tinfo.path.aid = p15card->app->ddo.aid;\n\t}\n\tsc_log(ctx, \"PrivKey path '%s'\", sc_print_path(&info.path));\n\n\t/* OpenSC 0.11.4 and older encoded \"keyReference\" as a negative value.\n\t * Fixed in 0.11.5 we need to add a hack, so old cards continue to work. */\n\tif (info.key_reference < -1)\n\t\tinfo.key_reference += 256;\n\n\t/* Check the auth_id - if not present, try and find it in access rules */\n\tif ((obj->flags & SC_PKCS15_CO_FLAG_PRIVATE) && (obj->auth_id.len == 0)) {\n\t\tsc_log(ctx, \"Private key %s has no auth ID - checking AccessControlRules\",\n\t\t\t\tsc_pkcs15_print_id(&info.id));\n\n\t\t/* Search in the access_rules for an appropriate auth ID */\n\t\tfor (i = 0; i < SC_PKCS15_MAX_ACCESS_RULES; i++) {\n\t\t\t/* If access_mode is one of the private key usage modes */\n\t\t\tif (obj->access_rules[i].access_mode &\n\t\t\t\t\t(SC_PKCS15_ACCESS_RULE_MODE_EXECUTE |\n\t\t\t\t\t SC_PKCS15_ACCESS_RULE_MODE_PSO_CDS |\n\t\t\t\t\t SC_PKCS15_ACCESS_RULE_MODE_PSO_DECRYPT |\n\t\t\t\t\t SC_PKCS15_ACCESS_RULE_MODE_INT_AUTH)) {\n\t\t\t\tif (obj->access_rules[i].auth_id.len != 0) {\n\t\t\t\t\t/* Found an auth ID to use for private key access */\n\t\t\t\t\tobj->auth_id = obj->access_rules[i].auth_id;\n\t\t\t\t\tsc_log(ctx, \"Auth ID found - %s\",\n\t\t\t\t\t\t sc_pkcs15_print_id(&obj->auth_id));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* No auth ID found */\n\t\tif (i == SC_PKCS15_MAX_ACCESS_RULES)\n\t\t\tsc_log(ctx, \"Warning: No auth ID found\");\n\t}\n\n\tobj->data = malloc(sizeof(info));\n\tif (obj->data == NULL) {\n\t\tsc_pkcs15_free_key_params(&info.params);\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_OUT_OF_MEMORY);\n\t}\n\tmemcpy(obj->data, &info, sizeof(info));\n\n\tsc_log(ctx, \"Key Subject %s\", sc_dump_hex(info.subject.value, info.subject.len));\n\tsc_log(ctx, \"Key path %s\", sc_print_path(&info.path));\n\treturn 0;\n}\n\nint sc_pkcs15_encode_prkdf_entry(sc_context_t *ctx, const struct sc_pkcs15_object *obj,\n\t\t\t\t u8 **buf, size_t *buflen)\n{\n\tstruct sc_asn1_entry asn1_com_key_attr[C_ASN1_COM_KEY_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_com_prkey_attr[C_ASN1_COM_PRKEY_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_rsakey_attr[C_ASN1_RSAKEY_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_prk_rsa_attr[C_ASN1_PRK_RSA_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_dsakey_attr[C_ASN1_DSAKEY_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_prk_dsa_attr[C_ASN1_PRK_DSA_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_dsakey_value_attr[C_ASN1_DSAKEY_VALUE_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_dsakey_i_p_attr[C_ASN1_DSAKEY_I_P_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_gostr3410key_attr[C_ASN1_GOSTR3410KEY_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_prk_gostr3410_attr[C_ASN1_PRK_GOSTR3410_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_ecckey_attr[C_ASN1_ECCKEY_ATTR];\n\tstruct sc_asn1_entry asn1_prk_ecc_attr[C_ASN1_PRK_ECC_ATTR];\n\tstruct sc_asn1_entry asn1_prkey[C_ASN1_PRKEY_SIZE];\n\tstruct sc_asn1_entry asn1_supported_algorithms[C_ASN1_SUPPORTED_ALGORITHMS_SIZE];\n\tstruct sc_asn1_pkcs15_object rsa_prkey_obj = {\n\t\t(struct sc_pkcs15_object *) obj, asn1_com_key_attr,\n\t\tasn1_com_prkey_attr, asn1_prk_rsa_attr\n\t};\n\tstruct sc_asn1_pkcs15_object dsa_prkey_obj = {\n\t\t(struct sc_pkcs15_object *) obj, asn1_com_key_attr,\n\t\tasn1_com_prkey_attr, asn1_prk_dsa_attr\n\t};\n\tstruct sc_asn1_pkcs15_object gostr3410_prkey_obj = {\n\t\t(struct sc_pkcs15_object *) obj,\n\t\tasn1_com_key_attr, asn1_com_prkey_attr,\n\t\tasn1_prk_gostr3410_attr\n\t};\n\tstruct sc_asn1_pkcs15_object ecc_prkey_obj = {\n\t\t(struct sc_pkcs15_object *) obj,\n\t\tasn1_com_key_attr, asn1_com_prkey_attr,\n\t\tasn1_prk_ecc_attr\n\t};\n\tstruct sc_pkcs15_prkey_info *prkey = (struct sc_pkcs15_prkey_info *) obj->data;\n\tstruct sc_pkcs15_keyinfo_gostparams *keyinfo_gostparams;\n\tint r, i;\n\tsize_t af_len, usage_len;\n\n\tsc_copy_asn1_entry(c_asn1_prkey, asn1_prkey);\n\tsc_copy_asn1_entry(c_asn1_supported_algorithms, asn1_supported_algorithms);\n\n\tsc_copy_asn1_entry(c_asn1_prk_rsa_attr, asn1_prk_rsa_attr);\n\tsc_copy_asn1_entry(c_asn1_rsakey_attr, asn1_rsakey_attr);\n\tsc_copy_asn1_entry(c_asn1_prk_dsa_attr, asn1_prk_dsa_attr);\n\tsc_copy_asn1_entry(c_asn1_dsakey_attr, asn1_dsakey_attr);\n\tsc_copy_asn1_entry(c_asn1_dsakey_value_attr, asn1_dsakey_value_attr);\n\tsc_copy_asn1_entry(c_asn1_dsakey_i_p_attr, asn1_dsakey_i_p_attr);\n\tsc_copy_asn1_entry(c_asn1_prk_gostr3410_attr, asn1_prk_gostr3410_attr);\n\tsc_copy_asn1_entry(c_asn1_gostr3410key_attr, asn1_gostr3410key_attr);\n\tsc_copy_asn1_entry(c_asn1_prk_ecc_attr, asn1_prk_ecc_attr);\n\tsc_copy_asn1_entry(c_asn1_ecckey_attr, asn1_ecckey_attr);\n\n\tsc_copy_asn1_entry(c_asn1_com_prkey_attr, asn1_com_prkey_attr);\n\tsc_copy_asn1_entry(c_asn1_com_key_attr, asn1_com_key_attr);\n\n\tswitch (obj->type) {\n\tcase SC_PKCS15_TYPE_PRKEY_RSA:\n\t\tsc_format_asn1_entry(asn1_prkey + 0, &rsa_prkey_obj, NULL, 1);\n\t\tsc_format_asn1_entry(asn1_prk_rsa_attr + 0, asn1_rsakey_attr, NULL, 1);\n\t\tsc_format_asn1_entry(asn1_rsakey_attr + 0, &prkey->path, NULL, 1);\n\t\tsc_format_asn1_entry(asn1_rsakey_attr + 1, &prkey->modulus_length, NULL, 1);\n\t\tbreak;\n\tcase SC_PKCS15_TYPE_PRKEY_EC:\n\t\tsc_format_asn1_entry(asn1_prkey + 1, &ecc_prkey_obj, NULL, 1);\n\t\tsc_format_asn1_entry(asn1_prk_ecc_attr + 0, asn1_ecckey_attr, NULL, 1);\n\t\tsc_format_asn1_entry(asn1_ecckey_attr + 0, &prkey->path, NULL, 1);\n\t\tsc_format_asn1_entry(asn1_ecckey_attr + 1, &prkey->field_length, NULL, 1);\n\t\tbreak;\n\tcase SC_PKCS15_TYPE_PRKEY_DSA:\n\t\tsc_format_asn1_entry(asn1_prkey + 2, &dsa_prkey_obj, NULL, 1);\n\t\tsc_format_asn1_entry(asn1_prk_dsa_attr + 0, asn1_dsakey_value_attr, NULL, 1);\n\t\tif (prkey->path.type != SC_PATH_TYPE_PATH_PROT) {\n\t\t\t/* indirect: just add the path */\n\t\t\tsc_format_asn1_entry(asn1_dsakey_value_attr + 0, &prkey->path, NULL, 1);\n\t\t}\n\t\telse {\n\t\t\t/* indirect-protected */\n\t\t\tsc_format_asn1_entry(asn1_dsakey_value_attr + 1, asn1_dsakey_i_p_attr, NULL, 1);\n\t\t\tsc_format_asn1_entry(asn1_dsakey_i_p_attr + 0, &prkey->path, NULL, 1);\n\t\t}\n\t\tbreak;\n\tcase SC_PKCS15_TYPE_PRKEY_GOSTR3410:\n\t\tsc_format_asn1_entry(asn1_prkey + 3, &gostr3410_prkey_obj, NULL, 1);\n\t\tsc_format_asn1_entry(asn1_prk_gostr3410_attr + 0, asn1_gostr3410key_attr, NULL, 1);\n\t\tsc_format_asn1_entry(asn1_gostr3410key_attr + 0, &prkey->path, NULL, 1);\n\t\tif (prkey->params.len == sizeof(*keyinfo_gostparams))   {\n\t\t\tkeyinfo_gostparams = prkey->params.data;\n\t\t\tsc_format_asn1_entry(asn1_gostr3410key_attr + 1, &keyinfo_gostparams->gostr3410, NULL, 1);\n\t\t\tsc_format_asn1_entry(asn1_gostr3410key_attr + 2, &keyinfo_gostparams->gostr3411, NULL, 1);\n\t\t\tsc_format_asn1_entry(asn1_gostr3410key_attr + 3, &keyinfo_gostparams->gost28147, NULL, 1);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tsc_log(ctx, \"Invalid private key type: %X\", obj->type);\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_INTERNAL);\n\t\tbreak;\n\t}\n\tsc_format_asn1_entry(asn1_com_key_attr + 0, &prkey->id, NULL, 1);\n\tusage_len = sizeof(prkey->usage);\n\tsc_format_asn1_entry(asn1_com_key_attr + 1, &prkey->usage, &usage_len, 1);\n\tif (prkey->native == 0)\n\t\tsc_format_asn1_entry(asn1_com_key_attr + 2, &prkey->native, NULL, 1);\n\tif (prkey->access_flags) {\n\t\taf_len = sizeof(prkey->access_flags);\n\t\tsc_format_asn1_entry(asn1_com_key_attr + 3, &prkey->access_flags, &af_len, 1);\n\t}\n\tif (prkey->key_reference >= 0)\n\t\tsc_format_asn1_entry(asn1_com_key_attr + 4, &prkey->key_reference, NULL, 1);\n\n\tfor (i=0; i<SC_MAX_SUPPORTED_ALGORITHMS && prkey->algo_refs[i]; i++)   {\n\t\tsc_log(ctx, \"Encode algorithm(%i) %i\", i, prkey->algo_refs[i]);\n\t\tsc_format_asn1_entry(asn1_supported_algorithms + i, &prkey->algo_refs[i], NULL, 1);\n\t}\n\tsc_format_asn1_entry(asn1_com_key_attr + 5, asn1_supported_algorithms, NULL, prkey->algo_refs[0] != 0);\n\n\tif (prkey->subject.value && prkey->subject.len)\n\t\tsc_format_asn1_entry(asn1_com_prkey_attr + 0, prkey->subject.value, &prkey->subject.len, 1);\n\telse\n\t\tmemset(asn1_com_prkey_attr, 0, sizeof(asn1_com_prkey_attr));\n\n\tr = sc_asn1_encode(ctx, asn1_prkey, buf, buflen);\n\n\tsc_log(ctx, \"Key path %s\", sc_print_path(&prkey->path));\n\treturn r;\n}\n\nint\nsc_pkcs15_prkey_attrs_from_cert(struct sc_pkcs15_card *p15card, struct sc_pkcs15_object *cert_object,\n\t\tstruct sc_pkcs15_object **out_key_object)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n#ifdef ENABLE_OPENSSL\n\tstruct sc_pkcs15_object *key_object = NULL;\n\tstruct sc_pkcs15_prkey_info *key_info = NULL;\n\tX509 *x = NULL;\n\tBIO *mem = NULL;\n\tunsigned char *buff = NULL, *ptr = NULL;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tif (out_key_object)\n\t\t*out_key_object = NULL;\n\n\trv = sc_pkcs15_find_prkey_by_id(p15card, &((struct sc_pkcs15_cert_info *)cert_object->data)->id, &key_object);\n\tif (rv == SC_ERROR_OBJECT_NOT_FOUND)\n\t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\tLOG_TEST_RET(ctx, rv, \"Find private key error\");\n\n\tkey_info = (struct sc_pkcs15_prkey_info *) key_object->data;\n\n\tERR_load_ERR_strings();\n\tERR_load_crypto_strings();\n\n\tsc_log(ctx, \"CertValue(%\"SC_FORMAT_LEN_SIZE_T\"u) %p\",\n\t       cert_object->content.len, cert_object->content.value);\n\tmem = BIO_new_mem_buf(cert_object->content.value, cert_object->content.len);\n\tif (!mem)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INTERNAL, \"MEM buffer allocation error\");\n\n\tx = d2i_X509_bio(mem, NULL);\n\tif (!x)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INTERNAL, \"x509 parse error\");\n\n\tbuff = OPENSSL_malloc(i2d_X509(x,NULL) + EVP_MAX_MD_SIZE);\n\tif (!buff)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_OUT_OF_MEMORY, \"OpenSSL allocation error\");\n\n\tptr = buff;\n\trv = i2d_X509_NAME(X509_get_subject_name(x), &ptr);\n\tif (rv <= 0)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INTERNAL, \"Get subject name error\");\n\n\tkey_info->subject.value = malloc(rv);\n\tif (!key_info->subject.value)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_OUT_OF_MEMORY, \"Subject allocation error\");\n\n\tmemcpy(key_info->subject.value, buff, rv);\n\tkey_info->subject.len = rv;\n\n\tstrlcpy(key_object->label, cert_object->label, sizeof(key_object->label));\n\n\trv = 0;\n\n\tif (x)\n\t\tX509_free(x);\n\tif (mem)\n\t\tBIO_free(mem);\n\tif (buff)\n\t\tOPENSSL_free(buff);\n\n\tERR_clear_error();\n\tERR_free_strings();\n\n\tif (out_key_object)\n\t\t*out_key_object = key_object;\n\n\tsc_log(ctx, \"Subject %s\", sc_dump_hex(key_info->subject.value, key_info->subject.len));\n\tLOG_FUNC_RETURN(ctx, rv);\n#else\n\tLOG_FUNC_RETURN(ctx, SC_ERROR_NOT_SUPPORTED);\n#endif\n}\n\n\nvoid\nsc_pkcs15_free_prkey(struct sc_pkcs15_prkey *key)\n{\n\tif (!key)\n\t\treturn;\n\tswitch (key->algorithm) {\n\tcase SC_ALGORITHM_RSA:\n\t\tfree(key->u.rsa.modulus.data);\n\t\tfree(key->u.rsa.exponent.data);\n\t\tfree(key->u.rsa.d.data);\n\t\tfree(key->u.rsa.p.data);\n\t\tfree(key->u.rsa.q.data);\n\t\tfree(key->u.rsa.iqmp.data);\n\t\tfree(key->u.rsa.dmp1.data);\n\t\tfree(key->u.rsa.dmq1.data);\n\t\tbreak;\n\tcase SC_ALGORITHM_DSA:\n\t\tfree(key->u.dsa.pub.data);\n\t\tfree(key->u.dsa.p.data);\n\t\tfree(key->u.dsa.q.data);\n\t\tfree(key->u.dsa.g.data);\n\t\tfree(key->u.dsa.priv.data);\n\t\tbreak;\n\tcase SC_ALGORITHM_GOSTR3410:\n\t\tassert(key->u.gostr3410.d.data);\n\t\tfree(key->u.gostr3410.d.data);\n\t\tbreak;\n\tcase SC_ALGORITHM_EC:\n\t\tif (key->u.ec.params.der.value)\n\t\t\tfree(key->u.ec.params.der.value);\n\t\tif (key->u.ec.params.named_curve)\n\t\t\tfree(key->u.ec.params.named_curve);\n\t\tif (key->u.ec.privateD.data)\n\t\t\tfree(key->u.ec.privateD.data);\n\t\tif (key->u.ec.ecpointQ.value)\n\t\t\tfree(key->u.ec.ecpointQ.value);\n\t\tbreak;\n\t}\n}\n\n\nvoid sc_pkcs15_free_prkey_info(sc_pkcs15_prkey_info_t *key)\n{\n\tif (key->subject.value)\n\t\tfree(key->subject.value);\n\n\tsc_pkcs15_free_key_params(&key->params);\n\n\tsc_aux_data_free(&key->aux_data);\n\n\tfree(key);\n}\n\nint\nsc_pkcs15_convert_bignum(sc_pkcs15_bignum_t *dst, const void *src)\n{\n#ifdef ENABLE_OPENSSL\n\tconst BIGNUM *bn = (const BIGNUM *)src;\n\n\tif (bn == 0)\n\t\treturn 0;\n\tdst->len = BN_num_bytes(bn);\n\tdst->data = malloc(dst->len);\n\tif (!dst->data)\n\t\treturn 0;\n\tBN_bn2bin(bn, dst->data);\n\treturn 1;\n#else\n\treturn 0;\n#endif\n}\n\nint\nsc_pkcs15_convert_prkey(struct sc_pkcs15_prkey *pkcs15_key, void *evp_key)\n{\n#ifdef ENABLE_OPENSSL\n\tEVP_PKEY *pk = (EVP_PKEY *)evp_key;\n\tint pk_type;\n\t pk_type = EVP_PKEY_base_id(pk);\n\n\tswitch (pk_type) {\n\tcase EVP_PKEY_RSA: {\n\t\tstruct sc_pkcs15_prkey_rsa *dst = &pkcs15_key->u.rsa;\n\t\tRSA *src = EVP_PKEY_get1_RSA(pk);\n\t\tconst BIGNUM *src_n, *src_e, *src_d, *src_p, *src_q, *src_iqmp, *src_dmp1, *src_dmq1;\n\n\t\tRSA_get0_key(src, &src_n, &src_e, &src_d);\n\t\tRSA_get0_factors(src, &src_p, &src_q);\n\t\tRSA_get0_crt_params(src, &src_dmp1, &src_dmq1, &src_iqmp);\n\n\t\tpkcs15_key->algorithm = SC_ALGORITHM_RSA;\n\t\tif (!sc_pkcs15_convert_bignum(&dst->modulus, src_n)\n\t\t || !sc_pkcs15_convert_bignum(&dst->exponent, src_e)\n\t\t || !sc_pkcs15_convert_bignum(&dst->d, src_d)\n\t\t || !sc_pkcs15_convert_bignum(&dst->p, src_p)\n\t\t || !sc_pkcs15_convert_bignum(&dst->q, src_q))\n\t\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t\tif (src_iqmp && src_dmp1 && src_dmq1) {\n\t\t\tsc_pkcs15_convert_bignum(&dst->iqmp, src_iqmp);\n\t\t\tsc_pkcs15_convert_bignum(&dst->dmp1, src_dmp1);\n\t\t\tsc_pkcs15_convert_bignum(&dst->dmq1, src_dmq1);\n\t\t}\n\t\tRSA_free(src);\n\t\tbreak;\n\t\t}\n\tcase EVP_PKEY_DSA: {\n\t\tstruct sc_pkcs15_prkey_dsa *dst = &pkcs15_key->u.dsa;\n\t\tDSA *src = EVP_PKEY_get1_DSA(pk);\n\t\tconst BIGNUM *src_pub_key, *src_p, *src_q, *src_g, *src_priv_key;\n\n\t\tDSA_get0_key(src, &src_pub_key, &src_priv_key);\n\t\tDSA_get0_pqg(src, &src_p, &src_q, &src_g);\n\n\t\tpkcs15_key->algorithm = SC_ALGORITHM_DSA;\n\t\tsc_pkcs15_convert_bignum(&dst->pub, src_pub_key);\n\t\tsc_pkcs15_convert_bignum(&dst->p, src_p);\n\t\tsc_pkcs15_convert_bignum(&dst->q, src_q);\n\t\tsc_pkcs15_convert_bignum(&dst->g, src_g);\n\t\tsc_pkcs15_convert_bignum(&dst->priv, src_priv_key);\n\t\tDSA_free(src);\n\t\tbreak;\n\t\t}\n#if OPENSSL_VERSION_NUMBER >= 0x10000000L && !defined(OPENSSL_NO_EC)\n\tcase NID_id_GostR3410_2001: {\n\t\tstruct sc_pkcs15_prkey_gostr3410 *dst = &pkcs15_key->u.gostr3410;\n\t\tEC_KEY *src = EVP_PKEY_get0(pk);\n\n\t\tassert(src);\n\t\tpkcs15_key->algorithm = SC_ALGORITHM_GOSTR3410;\n\t\tassert(EC_KEY_get0_private_key(src));\n\t\tsc_pkcs15_convert_bignum(&dst->d, EC_KEY_get0_private_key(src));\n\t\tbreak;\n\t\t}\n\tcase EVP_PKEY_EC: {\n\t\tstruct sc_pkcs15_prkey_ec *dst = &pkcs15_key->u.ec;\n\t\tEC_KEY *src = NULL;\n\t\tconst EC_GROUP *grp = NULL;\n\t\tunsigned char buf[255];\n\t\tsize_t buflen = 255;\n\t\tint nid;\n\n\t\tsrc = EVP_PKEY_get0(pk);\n\t\tassert(src);\n\t\tassert(EC_KEY_get0_private_key(src));\n\t\tassert(EC_KEY_get0_public_key(src));\n\n\t\tpkcs15_key->algorithm = SC_ALGORITHM_EC;\n\n\t\tif (!sc_pkcs15_convert_bignum(&dst->privateD, EC_KEY_get0_private_key(src)))\n\t\t\treturn SC_ERROR_INCOMPATIBLE_KEY;\n\n\t\tgrp = EC_KEY_get0_group(src);\n\t\tif(grp == 0)\n\t\t\treturn SC_ERROR_INCOMPATIBLE_KEY;\n\n\t\t/* get curve name */\n\t\tnid = EC_GROUP_get_curve_name(grp);\n\t\tif(nid != 0) {\n\t\t\tconst char *sn = OBJ_nid2sn(nid);\n\t\t\tif (sn)\n\t\t\t\tdst->params.named_curve = strdup(sn);\n\t\t}\n\n\t\t/* Decode EC_POINT from a octet string */\n\t\tbuflen = EC_POINT_point2oct(grp, (const EC_POINT *) EC_KEY_get0_public_key(src),\n\t\t\t\tPOINT_CONVERSION_UNCOMPRESSED, buf, buflen, NULL);\n\t\tif (!buflen)\n\t\t\treturn SC_ERROR_INCOMPATIBLE_KEY;\n\n\t\t/* copy the public key */\n\t\tdst->ecpointQ.value = malloc(buflen);\n\t\tif (!dst->ecpointQ.value)\n\t\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t\tmemcpy(dst->ecpointQ.value, buf, buflen);\n\t\tdst->ecpointQ.len = buflen;\n\n\t\t/*\n\t\t * In OpenSC the field_length is in bits. Not all curves are a mutiple of 8.\n\t\t * EC_POINT_point2oct handles this and returns octstrings that can handle\n\t\t * these curves. Get real field_length from OpenSSL. \n\t\t */\n\t\tdst->params.field_length = EC_GROUP_get_degree(grp);\n\n\t\t/* Octetstring may need leading zeros if BN is to short */\n\t\tif (dst->privateD.len < (dst->params.field_length + 7) / 8)   {\n\t\t\tsize_t d = (dst->params.field_length + 7) / 8 - dst->privateD.len;\n\n\t\t\tdst->privateD.data = realloc(dst->privateD.data, dst->privateD.len + d);\n\t\t\tif (!dst->privateD.data)\n\t\t\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\n\t\t\tmemmove(dst->privateD.data + d, dst->privateD.data, dst->privateD.len);\n\t\t\tmemset(dst->privateD.data, 0, d);\n\n\t\t\tdst->privateD.len += d;\n\t\t}\n\n\t\tbreak;\n\t}\n#endif /* OPENSSL_VERSION_NUMBER >= 0x10000000L && !defined(OPENSSL_NO_EC) */\n\tdefault:\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t}\n\n\treturn SC_SUCCESS;\n#else\n\treturn SC_ERROR_NOT_IMPLEMENTED;\n#endif\n}\n"], "fixing_code": ["/*\n * pkcs15-prkey.c: PKCS #15 private key functions\n *\n * Copyright (C) 2001, 2002  Juha Yrj\u00f6l\u00e4 <juha.yrjola@iki.fi>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#if HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <assert.h>\n\n#ifdef ENABLE_OPENSSL\n#include <openssl/opensslv.h>\n#include <openssl/bn.h>\n#include <openssl/x509.h>\n#include <openssl/x509v3.h>\n#include <openssl/err.h>\n#include <openssl/bn.h>\n#include <openssl/rsa.h>\n#include <openssl/dsa.h>\n#if OPENSSL_VERSION_NUMBER >= 0x10000000L\n\t#ifndef OPENSSL_NO_EC\n\t#include <openssl/ec.h>\n\t#endif\n#endif\n#endif\n\n#include \"internal.h\"\n#include \"asn1.h\"\n#include \"pkcs15.h\"\n#include \"common/compat_strlcpy.h\"\n#include \"aux-data.h\"\n\n/*\n * in src/libopensc/types.h SC_MAX_SUPPORTED_ALGORITHMS  defined as 8\n */\n#define C_ASN1_SUPPORTED_ALGORITHMS_SIZE (SC_MAX_SUPPORTED_ALGORITHMS + 1)\nstatic const struct sc_asn1_entry c_asn1_supported_algorithms[C_ASN1_SUPPORTED_ALGORITHMS_SIZE] = {\n\t{ \"algorithmReference\", SC_ASN1_INTEGER, SC_ASN1_TAG_INTEGER, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"algorithmReference\", SC_ASN1_INTEGER, SC_ASN1_TAG_INTEGER, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"algorithmReference\", SC_ASN1_INTEGER, SC_ASN1_TAG_INTEGER, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"algorithmReference\", SC_ASN1_INTEGER, SC_ASN1_TAG_INTEGER, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"algorithmReference\", SC_ASN1_INTEGER, SC_ASN1_TAG_INTEGER, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"algorithmReference\", SC_ASN1_INTEGER, SC_ASN1_TAG_INTEGER, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"algorithmReference\", SC_ASN1_INTEGER, SC_ASN1_TAG_INTEGER, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"algorithmReference\", SC_ASN1_INTEGER, SC_ASN1_TAG_INTEGER, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ NULL, 0, 0, 0, NULL, NULL }\n};\n\n#define C_ASN1_COM_KEY_ATTR_SIZE 7\nstatic const struct sc_asn1_entry c_asn1_com_key_attr[C_ASN1_COM_KEY_ATTR_SIZE] = {\n\t{ \"iD\",\t\t SC_ASN1_PKCS15_ID, SC_ASN1_TAG_OCTET_STRING, 0, NULL, NULL },\n\t{ \"usage\",\t SC_ASN1_BIT_FIELD, SC_ASN1_TAG_BIT_STRING, 0, NULL, NULL },\n\t{ \"native\",\t SC_ASN1_BOOLEAN, SC_ASN1_TAG_BOOLEAN, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"accessFlags\", SC_ASN1_BIT_FIELD, SC_ASN1_TAG_BIT_STRING, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"keyReference\",SC_ASN1_INTEGER, SC_ASN1_TAG_INTEGER, SC_ASN1_OPTIONAL, NULL, NULL },\n/* Absent in PKCS#15-v1.1 but present in ISO 7816-15(2004-01-15)*/\n\t{ \"algReference\", SC_ASN1_STRUCT, SC_ASN1_CONS | SC_ASN1_CTX | 1, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ NULL, 0, 0, 0, NULL, NULL }\n};\n\n#define C_ASN1_COM_PRKEY_ATTR_SIZE 2\nstatic const struct sc_asn1_entry c_asn1_com_prkey_attr[C_ASN1_COM_PRKEY_ATTR_SIZE] = {\n\t{ \"subjectName\", SC_ASN1_OCTET_STRING, SC_ASN1_TAG_SEQUENCE | SC_ASN1_CONS,\n\t\tSC_ASN1_EMPTY_ALLOWED | SC_ASN1_ALLOC | SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ NULL, 0, 0, 0, NULL, NULL }\n};\n\n#define C_ASN1_RSAKEY_ATTR_SIZE 4\nstatic const struct sc_asn1_entry c_asn1_rsakey_attr[] = {\n\t{ \"value\",         SC_ASN1_PATH, SC_ASN1_TAG_SEQUENCE | SC_ASN1_CONS, SC_ASN1_EMPTY_ALLOWED, NULL, NULL },\n\t{ \"modulusLength\", SC_ASN1_INTEGER, SC_ASN1_TAG_INTEGER, 0, NULL, NULL },\n\t{ \"keyInfo\",\t   SC_ASN1_INTEGER, SC_ASN1_TAG_INTEGER, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ NULL, 0, 0, 0, NULL, NULL }\n};\n\n#define C_ASN1_PRK_RSA_ATTR_SIZE 2\nstatic const struct sc_asn1_entry c_asn1_prk_rsa_attr[C_ASN1_PRK_RSA_ATTR_SIZE] = {\n\t{ \"privateRSAKeyAttributes\", SC_ASN1_STRUCT, SC_ASN1_TAG_SEQUENCE | SC_ASN1_CONS, 0, NULL, NULL },\n\t{ NULL, 0, 0, 0, NULL, NULL }\n};\n\n#define C_ASN1_GOSTR3410KEY_ATTR_SIZE 5\nstatic const struct sc_asn1_entry c_asn1_gostr3410key_attr[C_ASN1_GOSTR3410KEY_ATTR_SIZE] = {\n\t{ \"value\",         SC_ASN1_PATH, SC_ASN1_TAG_SEQUENCE | SC_ASN1_CONS, 0, NULL, NULL },\n\t{ \"params_r3410\",  SC_ASN1_INTEGER, SC_ASN1_TAG_INTEGER, 0, NULL, NULL },\n\t{ \"params_r3411\",  SC_ASN1_INTEGER, SC_ASN1_TAG_INTEGER, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"params_28147\",  SC_ASN1_INTEGER, SC_ASN1_TAG_INTEGER, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ NULL, 0, 0, 0, NULL, NULL }\n};\n\n#define C_ASN1_PRK_GOSTR3410_ATTR_SIZE 2\nstatic const struct sc_asn1_entry c_asn1_prk_gostr3410_attr[C_ASN1_PRK_GOSTR3410_ATTR_SIZE] = {\n\t{ \"privateGOSTR3410KeyAttributes\", SC_ASN1_STRUCT, SC_ASN1_TAG_SEQUENCE | SC_ASN1_CONS, 0, NULL, NULL },\n\t{ NULL, 0, 0, 0, NULL, NULL }\n};\n\n#define C_ASN1_DSAKEY_I_P_ATTR_SIZE 2\nstatic const struct sc_asn1_entry c_asn1_dsakey_i_p_attr[C_ASN1_DSAKEY_I_P_ATTR_SIZE] = {\n\t{ \"path\",\tSC_ASN1_PATH, SC_ASN1_TAG_SEQUENCE | SC_ASN1_CONS, 0, NULL, NULL },\n\t{ NULL, 0, 0, 0, NULL, NULL }\n};\n\n#define C_ASN1_DSAKEY_VALUE_ATTR_SIZE 3\nstatic const struct sc_asn1_entry c_asn1_dsakey_value_attr[C_ASN1_DSAKEY_VALUE_ATTR_SIZE] = {\n\t{ \"path\",\tSC_ASN1_PATH, SC_ASN1_TAG_SEQUENCE | SC_ASN1_CONS, 0, NULL, NULL },\n\t{ \"pathProtected\",SC_ASN1_STRUCT, SC_ASN1_CTX | 1 | SC_ASN1_CONS, 0, NULL, NULL},\n\t{ NULL, 0, 0, 0, NULL, NULL }\n};\n\n#define C_ASN1_DSAKEY_ATTR_SIZE 2\nstatic const struct sc_asn1_entry c_asn1_dsakey_attr[C_ASN1_DSAKEY_ATTR_SIZE] = {\n\t{ \"value\",\tSC_ASN1_CHOICE, 0, 0, NULL, NULL },\n\t{ NULL, 0, 0, 0, NULL, NULL }\n};\n\n#define C_ASN1_PRK_DSA_ATTR_SIZE 2\nstatic const struct sc_asn1_entry c_asn1_prk_dsa_attr[C_ASN1_PRK_DSA_ATTR_SIZE] = {\n\t{ \"privateDSAKeyAttributes\", SC_ASN1_STRUCT, SC_ASN1_TAG_SEQUENCE | SC_ASN1_CONS, 0, NULL, NULL },\n\t{ NULL, 0, 0, 0, NULL, NULL }\n};\n\n/*\n * The element fieldSize is a proprietary extension to ISO 7816-15, providing to the middleware\n * the size of the underlying ECC field. This value is required for determine a proper size for\n * buffer allocations. The field follows the definition for modulusLength in RSA keys\n */\n#define C_ASN1_ECCKEY_ATTR 4\nstatic const struct sc_asn1_entry c_asn1_ecckey_attr[C_ASN1_ECCKEY_ATTR] = {\n\t{ \"value\",\t   SC_ASN1_PATH, SC_ASN1_TAG_SEQUENCE | SC_ASN1_CONS, SC_ASN1_EMPTY_ALLOWED, NULL, NULL },\n\t{ \"fieldSize\",\t   SC_ASN1_INTEGER, SC_ASN1_TAG_INTEGER, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"keyInfo\",\t   SC_ASN1_INTEGER, SC_ASN1_TAG_INTEGER, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ NULL, 0, 0, 0, NULL, NULL }\n};\n\n#define C_ASN1_PRK_ECC_ATTR 2\nstatic const struct sc_asn1_entry c_asn1_prk_ecc_attr[C_ASN1_PRK_ECC_ATTR] = {\n\t{ \"privateECCKeyAttributes\", SC_ASN1_STRUCT, SC_ASN1_TAG_SEQUENCE | SC_ASN1_CONS, 0, NULL, NULL },\n\t{ NULL, 0, 0, 0, NULL, NULL }\n};\n\n#define C_ASN1_PRKEY_SIZE 5\nstatic const struct sc_asn1_entry c_asn1_prkey[C_ASN1_PRKEY_SIZE] = {\n\t{ \"privateRSAKey\", SC_ASN1_PKCS15_OBJECT, SC_ASN1_TAG_SEQUENCE | SC_ASN1_CONS, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"privateECCKey\", SC_ASN1_PKCS15_OBJECT,  0 | SC_ASN1_CTX | SC_ASN1_CONS, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"privateDSAKey\", SC_ASN1_PKCS15_OBJECT,  2 | SC_ASN1_CTX | SC_ASN1_CONS, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ \"privateGOSTR3410Key\", SC_ASN1_PKCS15_OBJECT, 4 | SC_ASN1_CTX | SC_ASN1_CONS, SC_ASN1_OPTIONAL, NULL, NULL },\n\t{ NULL, 0, 0, 0, NULL, NULL }\n};\n\n\nint sc_pkcs15_decode_prkdf_entry(struct sc_pkcs15_card *p15card,\n\t\t\t\t struct sc_pkcs15_object *obj,\n\t\t\t\t const u8 ** buf, size_t *buflen)\n{\n\tsc_context_t *ctx = p15card->card->ctx;\n\tstruct sc_pkcs15_prkey_info info;\n\tint r, i, gostr3410_params[3];\n\tstruct sc_pkcs15_keyinfo_gostparams *keyinfo_gostparams;\n\tsize_t usage_len = sizeof(info.usage);\n\tsize_t af_len = sizeof(info.access_flags);\n\tstruct sc_asn1_entry asn1_com_key_attr[C_ASN1_COM_KEY_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_com_prkey_attr[C_ASN1_COM_PRKEY_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_rsakey_attr[C_ASN1_RSAKEY_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_prk_rsa_attr[C_ASN1_PRK_RSA_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_dsakey_attr[C_ASN1_DSAKEY_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_prk_dsa_attr[C_ASN1_PRK_DSA_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_dsakey_i_p_attr[C_ASN1_DSAKEY_I_P_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_dsakey_value_attr[C_ASN1_DSAKEY_VALUE_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_gostr3410key_attr[C_ASN1_GOSTR3410KEY_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_prk_gostr3410_attr[C_ASN1_PRK_GOSTR3410_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_ecckey_attr[C_ASN1_ECCKEY_ATTR];\n\tstruct sc_asn1_entry asn1_prk_ecc_attr[C_ASN1_PRK_ECC_ATTR];\n\tstruct sc_asn1_entry asn1_prkey[C_ASN1_PRKEY_SIZE];\n\tstruct sc_asn1_entry asn1_supported_algorithms[C_ASN1_SUPPORTED_ALGORITHMS_SIZE];\n\tstruct sc_asn1_pkcs15_object rsa_prkey_obj = {obj, asn1_com_key_attr, asn1_com_prkey_attr, asn1_prk_rsa_attr};\n\tstruct sc_asn1_pkcs15_object dsa_prkey_obj = {obj, asn1_com_key_attr, asn1_com_prkey_attr, asn1_prk_dsa_attr};\n\tstruct sc_asn1_pkcs15_object gostr3410_prkey_obj = {obj, asn1_com_key_attr, asn1_com_prkey_attr, asn1_prk_gostr3410_attr};\n\tstruct sc_asn1_pkcs15_object ecc_prkey_obj = { obj, asn1_com_key_attr, asn1_com_prkey_attr, asn1_prk_ecc_attr };\n\n\tsc_copy_asn1_entry(c_asn1_prkey, asn1_prkey);\n\tsc_copy_asn1_entry(c_asn1_supported_algorithms, asn1_supported_algorithms);\n\n\tsc_copy_asn1_entry(c_asn1_prk_rsa_attr, asn1_prk_rsa_attr);\n\tsc_copy_asn1_entry(c_asn1_rsakey_attr, asn1_rsakey_attr);\n\tsc_copy_asn1_entry(c_asn1_prk_dsa_attr, asn1_prk_dsa_attr);\n\tsc_copy_asn1_entry(c_asn1_dsakey_attr, asn1_dsakey_attr);\n\tsc_copy_asn1_entry(c_asn1_dsakey_value_attr, asn1_dsakey_value_attr);\n\tsc_copy_asn1_entry(c_asn1_dsakey_i_p_attr, asn1_dsakey_i_p_attr);\n\tsc_copy_asn1_entry(c_asn1_prk_gostr3410_attr, asn1_prk_gostr3410_attr);\n\tsc_copy_asn1_entry(c_asn1_gostr3410key_attr, asn1_gostr3410key_attr);\n\tsc_copy_asn1_entry(c_asn1_prk_ecc_attr, asn1_prk_ecc_attr);\n\tsc_copy_asn1_entry(c_asn1_ecckey_attr, asn1_ecckey_attr);\n\n\tsc_copy_asn1_entry(c_asn1_com_prkey_attr, asn1_com_prkey_attr);\n\tsc_copy_asn1_entry(c_asn1_com_key_attr, asn1_com_key_attr);\n\n\tsc_format_asn1_entry(asn1_prkey + 0, &rsa_prkey_obj, NULL, 0);\n\tsc_format_asn1_entry(asn1_prkey + 1, &ecc_prkey_obj, NULL, 0);\n\tsc_format_asn1_entry(asn1_prkey + 2, &dsa_prkey_obj, NULL, 0);\n\tsc_format_asn1_entry(asn1_prkey + 3, &gostr3410_prkey_obj, NULL, 0);\n\n\tsc_format_asn1_entry(asn1_prk_rsa_attr + 0, asn1_rsakey_attr, NULL, 0);\n\tsc_format_asn1_entry(asn1_prk_dsa_attr + 0, asn1_dsakey_attr, NULL, 0);\n\tsc_format_asn1_entry(asn1_prk_gostr3410_attr + 0, asn1_gostr3410key_attr, NULL, 0);\n\tsc_format_asn1_entry(asn1_prk_ecc_attr + 0, asn1_ecckey_attr, NULL, 0);\n\n\tsc_format_asn1_entry(asn1_rsakey_attr + 0, &info.path, NULL, 0);\n\tsc_format_asn1_entry(asn1_rsakey_attr + 1, &info.modulus_length, NULL, 0);\n\n\tsc_format_asn1_entry(asn1_dsakey_attr + 0, asn1_dsakey_value_attr, NULL, 0);\n\tsc_format_asn1_entry(asn1_dsakey_value_attr + 0, &info.path, NULL, 0);\n\tsc_format_asn1_entry(asn1_dsakey_value_attr + 1, asn1_dsakey_i_p_attr, NULL, 0);\n\tsc_format_asn1_entry(asn1_dsakey_i_p_attr + 0, &info.path, NULL, 0);\n\n\tsc_format_asn1_entry(asn1_gostr3410key_attr + 0, &info.path, NULL, 0);\n\tsc_format_asn1_entry(asn1_gostr3410key_attr + 1, &gostr3410_params[0], NULL, 0);\n\tsc_format_asn1_entry(asn1_gostr3410key_attr + 2, &gostr3410_params[1], NULL, 0);\n\tsc_format_asn1_entry(asn1_gostr3410key_attr + 3, &gostr3410_params[2], NULL, 0);\n\n\tsc_format_asn1_entry(asn1_ecckey_attr + 0, &info.path, NULL, 0);\n\tsc_format_asn1_entry(asn1_ecckey_attr + 1, &info.field_length, NULL, 0);\n\n\tsc_format_asn1_entry(asn1_com_key_attr + 0, &info.id, NULL, 0);\n\tsc_format_asn1_entry(asn1_com_key_attr + 1, &info.usage, &usage_len, 0);\n\tsc_format_asn1_entry(asn1_com_key_attr + 2, &info.native, NULL, 0);\n\tsc_format_asn1_entry(asn1_com_key_attr + 3, &info.access_flags, &af_len, 0);\n\tsc_format_asn1_entry(asn1_com_key_attr + 4, &info.key_reference, NULL, 0);\n\n\tfor (i=0; i<SC_MAX_SUPPORTED_ALGORITHMS && (asn1_supported_algorithms + i)->name; i++)\n\t\tsc_format_asn1_entry(asn1_supported_algorithms + i, &info.algo_refs[i], NULL, 0);\n\tsc_format_asn1_entry(asn1_com_key_attr + 5, asn1_supported_algorithms, NULL, 0);\n\n\tsc_format_asn1_entry(asn1_com_prkey_attr + 0, &info.subject.value, &info.subject.len, 0);\n\n\t/* Fill in defaults */\n\tmemset(&info, 0, sizeof(info));\n\tinfo.key_reference = -1;\n\tinfo.native = 1;\n\tmemset(gostr3410_params, 0, sizeof(gostr3410_params));\n\n\tr = sc_asn1_decode_choice(ctx, asn1_prkey, *buf, *buflen, buf, buflen);\n\tif (r < 0) {\n\t\t/* This might have allocated something. If so, clear it now */\n\t\tfree(info.subject.value);\n\t}\n\tif (r == SC_ERROR_ASN1_END_OF_CONTENTS)\n\t\treturn r;\n\tLOG_TEST_RET(ctx, r, \"PrKey DF ASN.1 decoding failed\");\n\tif (asn1_prkey[0].flags & SC_ASN1_PRESENT) {\n\t\tobj->type = SC_PKCS15_TYPE_PRKEY_RSA;\n\t}\n\telse if (asn1_prkey[1].flags & SC_ASN1_PRESENT) {\n\t\tobj->type = SC_PKCS15_TYPE_PRKEY_EC;\n\t}\n\telse if (asn1_prkey[2].flags & SC_ASN1_PRESENT) {\n\t\tobj->type = SC_PKCS15_TYPE_PRKEY_DSA;\n\t\t/* If the value was indirect-protected, mark the path */\n\t\tif (asn1_dsakey_i_p_attr[0].flags & SC_ASN1_PRESENT)\n\t\t\tinfo.path.type = SC_PATH_TYPE_PATH_PROT;\n\t}\n\telse if (asn1_prkey[3].flags & SC_ASN1_PRESENT) {\n\t\tobj->type = SC_PKCS15_TYPE_PRKEY_GOSTR3410;\n\t\tassert(info.modulus_length == 0);\n\t\tinfo.modulus_length = SC_PKCS15_GOSTR3410_KEYSIZE;\n\t\tassert(info.params.len == 0);\n\t\tinfo.params.len = sizeof(struct sc_pkcs15_keyinfo_gostparams);\n\t\tinfo.params.data = malloc(info.params.len);\n\t\tif (info.params.data == NULL)\n\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_OUT_OF_MEMORY);\n\t\tassert(sizeof(*keyinfo_gostparams) == info.params.len);\n\t\tkeyinfo_gostparams = info.params.data;\n\t\tkeyinfo_gostparams->gostr3410 = gostr3410_params[0];\n\t\tkeyinfo_gostparams->gostr3411 = gostr3410_params[1];\n\t\tkeyinfo_gostparams->gost28147 = gostr3410_params[2];\n\t}\n\telse {\n\t\tsc_log(ctx, \"Neither RSA or DSA or GOSTR3410 or ECC key in PrKDF entry.\");\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_ASN1_OBJECT);\n\t}\n\n\tif (!p15card->app || !p15card->app->ddo.aid.len)   {\n\t\tr = sc_pkcs15_make_absolute_path(&p15card->file_app->path, &info.path);\n\t\tif (r < 0) {\n\t\t\tsc_pkcs15_free_key_params(&info.params);\n\t\t\treturn r;\n\t\t}\n\t}\n\telse   {\n\t\tinfo.path.aid = p15card->app->ddo.aid;\n\t}\n\tsc_log(ctx, \"PrivKey path '%s'\", sc_print_path(&info.path));\n\n\t/* OpenSC 0.11.4 and older encoded \"keyReference\" as a negative value.\n\t * Fixed in 0.11.5 we need to add a hack, so old cards continue to work. */\n\tif (info.key_reference < -1)\n\t\tinfo.key_reference += 256;\n\n\t/* Check the auth_id - if not present, try and find it in access rules */\n\tif ((obj->flags & SC_PKCS15_CO_FLAG_PRIVATE) && (obj->auth_id.len == 0)) {\n\t\tsc_log(ctx, \"Private key %s has no auth ID - checking AccessControlRules\",\n\t\t\t\tsc_pkcs15_print_id(&info.id));\n\n\t\t/* Search in the access_rules for an appropriate auth ID */\n\t\tfor (i = 0; i < SC_PKCS15_MAX_ACCESS_RULES; i++) {\n\t\t\t/* If access_mode is one of the private key usage modes */\n\t\t\tif (obj->access_rules[i].access_mode &\n\t\t\t\t\t(SC_PKCS15_ACCESS_RULE_MODE_EXECUTE |\n\t\t\t\t\t SC_PKCS15_ACCESS_RULE_MODE_PSO_CDS |\n\t\t\t\t\t SC_PKCS15_ACCESS_RULE_MODE_PSO_DECRYPT |\n\t\t\t\t\t SC_PKCS15_ACCESS_RULE_MODE_INT_AUTH)) {\n\t\t\t\tif (obj->access_rules[i].auth_id.len != 0) {\n\t\t\t\t\t/* Found an auth ID to use for private key access */\n\t\t\t\t\tobj->auth_id = obj->access_rules[i].auth_id;\n\t\t\t\t\tsc_log(ctx, \"Auth ID found - %s\",\n\t\t\t\t\t\t sc_pkcs15_print_id(&obj->auth_id));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* No auth ID found */\n\t\tif (i == SC_PKCS15_MAX_ACCESS_RULES)\n\t\t\tsc_log(ctx, \"Warning: No auth ID found\");\n\t}\n\n\tobj->data = malloc(sizeof(info));\n\tif (obj->data == NULL) {\n\t\tsc_pkcs15_free_key_params(&info.params);\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_OUT_OF_MEMORY);\n\t}\n\tmemcpy(obj->data, &info, sizeof(info));\n\n\tsc_log(ctx, \"Key Subject %s\", sc_dump_hex(info.subject.value, info.subject.len));\n\tsc_log(ctx, \"Key path %s\", sc_print_path(&info.path));\n\treturn 0;\n}\n\nint sc_pkcs15_encode_prkdf_entry(sc_context_t *ctx, const struct sc_pkcs15_object *obj,\n\t\t\t\t u8 **buf, size_t *buflen)\n{\n\tstruct sc_asn1_entry asn1_com_key_attr[C_ASN1_COM_KEY_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_com_prkey_attr[C_ASN1_COM_PRKEY_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_rsakey_attr[C_ASN1_RSAKEY_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_prk_rsa_attr[C_ASN1_PRK_RSA_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_dsakey_attr[C_ASN1_DSAKEY_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_prk_dsa_attr[C_ASN1_PRK_DSA_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_dsakey_value_attr[C_ASN1_DSAKEY_VALUE_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_dsakey_i_p_attr[C_ASN1_DSAKEY_I_P_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_gostr3410key_attr[C_ASN1_GOSTR3410KEY_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_prk_gostr3410_attr[C_ASN1_PRK_GOSTR3410_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_ecckey_attr[C_ASN1_ECCKEY_ATTR];\n\tstruct sc_asn1_entry asn1_prk_ecc_attr[C_ASN1_PRK_ECC_ATTR];\n\tstruct sc_asn1_entry asn1_prkey[C_ASN1_PRKEY_SIZE];\n\tstruct sc_asn1_entry asn1_supported_algorithms[C_ASN1_SUPPORTED_ALGORITHMS_SIZE];\n\tstruct sc_asn1_pkcs15_object rsa_prkey_obj = {\n\t\t(struct sc_pkcs15_object *) obj, asn1_com_key_attr,\n\t\tasn1_com_prkey_attr, asn1_prk_rsa_attr\n\t};\n\tstruct sc_asn1_pkcs15_object dsa_prkey_obj = {\n\t\t(struct sc_pkcs15_object *) obj, asn1_com_key_attr,\n\t\tasn1_com_prkey_attr, asn1_prk_dsa_attr\n\t};\n\tstruct sc_asn1_pkcs15_object gostr3410_prkey_obj = {\n\t\t(struct sc_pkcs15_object *) obj,\n\t\tasn1_com_key_attr, asn1_com_prkey_attr,\n\t\tasn1_prk_gostr3410_attr\n\t};\n\tstruct sc_asn1_pkcs15_object ecc_prkey_obj = {\n\t\t(struct sc_pkcs15_object *) obj,\n\t\tasn1_com_key_attr, asn1_com_prkey_attr,\n\t\tasn1_prk_ecc_attr\n\t};\n\tstruct sc_pkcs15_prkey_info *prkey = (struct sc_pkcs15_prkey_info *) obj->data;\n\tstruct sc_pkcs15_keyinfo_gostparams *keyinfo_gostparams;\n\tint r, i;\n\tsize_t af_len, usage_len;\n\n\tsc_copy_asn1_entry(c_asn1_prkey, asn1_prkey);\n\tsc_copy_asn1_entry(c_asn1_supported_algorithms, asn1_supported_algorithms);\n\n\tsc_copy_asn1_entry(c_asn1_prk_rsa_attr, asn1_prk_rsa_attr);\n\tsc_copy_asn1_entry(c_asn1_rsakey_attr, asn1_rsakey_attr);\n\tsc_copy_asn1_entry(c_asn1_prk_dsa_attr, asn1_prk_dsa_attr);\n\tsc_copy_asn1_entry(c_asn1_dsakey_attr, asn1_dsakey_attr);\n\tsc_copy_asn1_entry(c_asn1_dsakey_value_attr, asn1_dsakey_value_attr);\n\tsc_copy_asn1_entry(c_asn1_dsakey_i_p_attr, asn1_dsakey_i_p_attr);\n\tsc_copy_asn1_entry(c_asn1_prk_gostr3410_attr, asn1_prk_gostr3410_attr);\n\tsc_copy_asn1_entry(c_asn1_gostr3410key_attr, asn1_gostr3410key_attr);\n\tsc_copy_asn1_entry(c_asn1_prk_ecc_attr, asn1_prk_ecc_attr);\n\tsc_copy_asn1_entry(c_asn1_ecckey_attr, asn1_ecckey_attr);\n\n\tsc_copy_asn1_entry(c_asn1_com_prkey_attr, asn1_com_prkey_attr);\n\tsc_copy_asn1_entry(c_asn1_com_key_attr, asn1_com_key_attr);\n\n\tswitch (obj->type) {\n\tcase SC_PKCS15_TYPE_PRKEY_RSA:\n\t\tsc_format_asn1_entry(asn1_prkey + 0, &rsa_prkey_obj, NULL, 1);\n\t\tsc_format_asn1_entry(asn1_prk_rsa_attr + 0, asn1_rsakey_attr, NULL, 1);\n\t\tsc_format_asn1_entry(asn1_rsakey_attr + 0, &prkey->path, NULL, 1);\n\t\tsc_format_asn1_entry(asn1_rsakey_attr + 1, &prkey->modulus_length, NULL, 1);\n\t\tbreak;\n\tcase SC_PKCS15_TYPE_PRKEY_EC:\n\t\tsc_format_asn1_entry(asn1_prkey + 1, &ecc_prkey_obj, NULL, 1);\n\t\tsc_format_asn1_entry(asn1_prk_ecc_attr + 0, asn1_ecckey_attr, NULL, 1);\n\t\tsc_format_asn1_entry(asn1_ecckey_attr + 0, &prkey->path, NULL, 1);\n\t\tsc_format_asn1_entry(asn1_ecckey_attr + 1, &prkey->field_length, NULL, 1);\n\t\tbreak;\n\tcase SC_PKCS15_TYPE_PRKEY_DSA:\n\t\tsc_format_asn1_entry(asn1_prkey + 2, &dsa_prkey_obj, NULL, 1);\n\t\tsc_format_asn1_entry(asn1_prk_dsa_attr + 0, asn1_dsakey_value_attr, NULL, 1);\n\t\tif (prkey->path.type != SC_PATH_TYPE_PATH_PROT) {\n\t\t\t/* indirect: just add the path */\n\t\t\tsc_format_asn1_entry(asn1_dsakey_value_attr + 0, &prkey->path, NULL, 1);\n\t\t}\n\t\telse {\n\t\t\t/* indirect-protected */\n\t\t\tsc_format_asn1_entry(asn1_dsakey_value_attr + 1, asn1_dsakey_i_p_attr, NULL, 1);\n\t\t\tsc_format_asn1_entry(asn1_dsakey_i_p_attr + 0, &prkey->path, NULL, 1);\n\t\t}\n\t\tbreak;\n\tcase SC_PKCS15_TYPE_PRKEY_GOSTR3410:\n\t\tsc_format_asn1_entry(asn1_prkey + 3, &gostr3410_prkey_obj, NULL, 1);\n\t\tsc_format_asn1_entry(asn1_prk_gostr3410_attr + 0, asn1_gostr3410key_attr, NULL, 1);\n\t\tsc_format_asn1_entry(asn1_gostr3410key_attr + 0, &prkey->path, NULL, 1);\n\t\tif (prkey->params.len == sizeof(*keyinfo_gostparams))   {\n\t\t\tkeyinfo_gostparams = prkey->params.data;\n\t\t\tsc_format_asn1_entry(asn1_gostr3410key_attr + 1, &keyinfo_gostparams->gostr3410, NULL, 1);\n\t\t\tsc_format_asn1_entry(asn1_gostr3410key_attr + 2, &keyinfo_gostparams->gostr3411, NULL, 1);\n\t\t\tsc_format_asn1_entry(asn1_gostr3410key_attr + 3, &keyinfo_gostparams->gost28147, NULL, 1);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tsc_log(ctx, \"Invalid private key type: %X\", obj->type);\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_INTERNAL);\n\t\tbreak;\n\t}\n\tsc_format_asn1_entry(asn1_com_key_attr + 0, &prkey->id, NULL, 1);\n\tusage_len = sizeof(prkey->usage);\n\tsc_format_asn1_entry(asn1_com_key_attr + 1, &prkey->usage, &usage_len, 1);\n\tif (prkey->native == 0)\n\t\tsc_format_asn1_entry(asn1_com_key_attr + 2, &prkey->native, NULL, 1);\n\tif (prkey->access_flags) {\n\t\taf_len = sizeof(prkey->access_flags);\n\t\tsc_format_asn1_entry(asn1_com_key_attr + 3, &prkey->access_flags, &af_len, 1);\n\t}\n\tif (prkey->key_reference >= 0)\n\t\tsc_format_asn1_entry(asn1_com_key_attr + 4, &prkey->key_reference, NULL, 1);\n\n\tfor (i=0; i<SC_MAX_SUPPORTED_ALGORITHMS && prkey->algo_refs[i]; i++)   {\n\t\tsc_log(ctx, \"Encode algorithm(%i) %i\", i, prkey->algo_refs[i]);\n\t\tsc_format_asn1_entry(asn1_supported_algorithms + i, &prkey->algo_refs[i], NULL, 1);\n\t}\n\tsc_format_asn1_entry(asn1_com_key_attr + 5, asn1_supported_algorithms, NULL, prkey->algo_refs[0] != 0);\n\n\tif (prkey->subject.value && prkey->subject.len)\n\t\tsc_format_asn1_entry(asn1_com_prkey_attr + 0, prkey->subject.value, &prkey->subject.len, 1);\n\telse\n\t\tmemset(asn1_com_prkey_attr, 0, sizeof(asn1_com_prkey_attr));\n\n\tr = sc_asn1_encode(ctx, asn1_prkey, buf, buflen);\n\n\tsc_log(ctx, \"Key path %s\", sc_print_path(&prkey->path));\n\treturn r;\n}\n\nint\nsc_pkcs15_prkey_attrs_from_cert(struct sc_pkcs15_card *p15card, struct sc_pkcs15_object *cert_object,\n\t\tstruct sc_pkcs15_object **out_key_object)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n#ifdef ENABLE_OPENSSL\n\tstruct sc_pkcs15_object *key_object = NULL;\n\tstruct sc_pkcs15_prkey_info *key_info = NULL;\n\tX509 *x = NULL;\n\tBIO *mem = NULL;\n\tunsigned char *buff = NULL, *ptr = NULL;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tif (out_key_object)\n\t\t*out_key_object = NULL;\n\n\trv = sc_pkcs15_find_prkey_by_id(p15card, &((struct sc_pkcs15_cert_info *)cert_object->data)->id, &key_object);\n\tif (rv == SC_ERROR_OBJECT_NOT_FOUND)\n\t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\tLOG_TEST_RET(ctx, rv, \"Find private key error\");\n\n\tkey_info = (struct sc_pkcs15_prkey_info *) key_object->data;\n\n\tERR_load_ERR_strings();\n\tERR_load_crypto_strings();\n\n\tsc_log(ctx, \"CertValue(%\"SC_FORMAT_LEN_SIZE_T\"u) %p\",\n\t       cert_object->content.len, cert_object->content.value);\n\tmem = BIO_new_mem_buf(cert_object->content.value, cert_object->content.len);\n\tif (!mem)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INTERNAL, \"MEM buffer allocation error\");\n\n\tx = d2i_X509_bio(mem, NULL);\n\tif (!x)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INTERNAL, \"x509 parse error\");\n\n\tbuff = OPENSSL_malloc(i2d_X509(x,NULL) + EVP_MAX_MD_SIZE);\n\tif (!buff)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_OUT_OF_MEMORY, \"OpenSSL allocation error\");\n\n\tptr = buff;\n\trv = i2d_X509_NAME(X509_get_subject_name(x), &ptr);\n\tif (rv <= 0)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INTERNAL, \"Get subject name error\");\n\n\tkey_info->subject.value = malloc(rv);\n\tif (!key_info->subject.value)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_OUT_OF_MEMORY, \"Subject allocation error\");\n\n\tmemcpy(key_info->subject.value, buff, rv);\n\tkey_info->subject.len = rv;\n\n\tstrlcpy(key_object->label, cert_object->label, sizeof(key_object->label));\n\n\trv = 0;\n\n\tif (x)\n\t\tX509_free(x);\n\tif (mem)\n\t\tBIO_free(mem);\n\tif (buff)\n\t\tOPENSSL_free(buff);\n\n\tERR_clear_error();\n\tERR_free_strings();\n\n\tif (out_key_object)\n\t\t*out_key_object = key_object;\n\n\tsc_log(ctx, \"Subject %s\", sc_dump_hex(key_info->subject.value, key_info->subject.len));\n\tLOG_FUNC_RETURN(ctx, rv);\n#else\n\tLOG_FUNC_RETURN(ctx, SC_ERROR_NOT_SUPPORTED);\n#endif\n}\n\n\nvoid\nsc_pkcs15_free_prkey(struct sc_pkcs15_prkey *key)\n{\n\tif (!key)\n\t\treturn;\n\tswitch (key->algorithm) {\n\tcase SC_ALGORITHM_RSA:\n\t\tfree(key->u.rsa.modulus.data);\n\t\tfree(key->u.rsa.exponent.data);\n\t\tfree(key->u.rsa.d.data);\n\t\tfree(key->u.rsa.p.data);\n\t\tfree(key->u.rsa.q.data);\n\t\tfree(key->u.rsa.iqmp.data);\n\t\tfree(key->u.rsa.dmp1.data);\n\t\tfree(key->u.rsa.dmq1.data);\n\t\tbreak;\n\tcase SC_ALGORITHM_DSA:\n\t\tfree(key->u.dsa.pub.data);\n\t\tfree(key->u.dsa.p.data);\n\t\tfree(key->u.dsa.q.data);\n\t\tfree(key->u.dsa.g.data);\n\t\tfree(key->u.dsa.priv.data);\n\t\tbreak;\n\tcase SC_ALGORITHM_GOSTR3410:\n\t\tassert(key->u.gostr3410.d.data);\n\t\tfree(key->u.gostr3410.d.data);\n\t\tbreak;\n\tcase SC_ALGORITHM_EC:\n\t\tif (key->u.ec.params.der.value)\n\t\t\tfree(key->u.ec.params.der.value);\n\t\tif (key->u.ec.params.named_curve)\n\t\t\tfree(key->u.ec.params.named_curve);\n\t\tif (key->u.ec.privateD.data)\n\t\t\tfree(key->u.ec.privateD.data);\n\t\tif (key->u.ec.ecpointQ.value)\n\t\t\tfree(key->u.ec.ecpointQ.value);\n\t\tbreak;\n\t}\n}\n\n\nvoid sc_pkcs15_free_prkey_info(sc_pkcs15_prkey_info_t *key)\n{\n\tif (key->subject.value)\n\t\tfree(key->subject.value);\n\n\tsc_pkcs15_free_key_params(&key->params);\n\n\tsc_aux_data_free(&key->aux_data);\n\n\tfree(key);\n}\n\nint\nsc_pkcs15_convert_bignum(sc_pkcs15_bignum_t *dst, const void *src)\n{\n#ifdef ENABLE_OPENSSL\n\tconst BIGNUM *bn = (const BIGNUM *)src;\n\n\tif (bn == 0)\n\t\treturn 0;\n\tdst->len = BN_num_bytes(bn);\n\tdst->data = malloc(dst->len);\n\tif (!dst->data)\n\t\treturn 0;\n\tBN_bn2bin(bn, dst->data);\n\treturn 1;\n#else\n\treturn 0;\n#endif\n}\n\nint\nsc_pkcs15_convert_prkey(struct sc_pkcs15_prkey *pkcs15_key, void *evp_key)\n{\n#ifdef ENABLE_OPENSSL\n\tEVP_PKEY *pk = (EVP_PKEY *)evp_key;\n\tint pk_type;\n\t pk_type = EVP_PKEY_base_id(pk);\n\n\tswitch (pk_type) {\n\tcase EVP_PKEY_RSA: {\n\t\tstruct sc_pkcs15_prkey_rsa *dst = &pkcs15_key->u.rsa;\n\t\tRSA *src = EVP_PKEY_get1_RSA(pk);\n\t\tconst BIGNUM *src_n, *src_e, *src_d, *src_p, *src_q, *src_iqmp, *src_dmp1, *src_dmq1;\n\n\t\tRSA_get0_key(src, &src_n, &src_e, &src_d);\n\t\tRSA_get0_factors(src, &src_p, &src_q);\n\t\tRSA_get0_crt_params(src, &src_dmp1, &src_dmq1, &src_iqmp);\n\n\t\tpkcs15_key->algorithm = SC_ALGORITHM_RSA;\n\t\tif (!sc_pkcs15_convert_bignum(&dst->modulus, src_n)\n\t\t || !sc_pkcs15_convert_bignum(&dst->exponent, src_e)\n\t\t || !sc_pkcs15_convert_bignum(&dst->d, src_d)\n\t\t || !sc_pkcs15_convert_bignum(&dst->p, src_p)\n\t\t || !sc_pkcs15_convert_bignum(&dst->q, src_q))\n\t\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t\tif (src_iqmp && src_dmp1 && src_dmq1) {\n\t\t\tsc_pkcs15_convert_bignum(&dst->iqmp, src_iqmp);\n\t\t\tsc_pkcs15_convert_bignum(&dst->dmp1, src_dmp1);\n\t\t\tsc_pkcs15_convert_bignum(&dst->dmq1, src_dmq1);\n\t\t}\n\t\tRSA_free(src);\n\t\tbreak;\n\t\t}\n\tcase EVP_PKEY_DSA: {\n\t\tstruct sc_pkcs15_prkey_dsa *dst = &pkcs15_key->u.dsa;\n\t\tDSA *src = EVP_PKEY_get1_DSA(pk);\n\t\tconst BIGNUM *src_pub_key, *src_p, *src_q, *src_g, *src_priv_key;\n\n\t\tDSA_get0_key(src, &src_pub_key, &src_priv_key);\n\t\tDSA_get0_pqg(src, &src_p, &src_q, &src_g);\n\n\t\tpkcs15_key->algorithm = SC_ALGORITHM_DSA;\n\t\tsc_pkcs15_convert_bignum(&dst->pub, src_pub_key);\n\t\tsc_pkcs15_convert_bignum(&dst->p, src_p);\n\t\tsc_pkcs15_convert_bignum(&dst->q, src_q);\n\t\tsc_pkcs15_convert_bignum(&dst->g, src_g);\n\t\tsc_pkcs15_convert_bignum(&dst->priv, src_priv_key);\n\t\tDSA_free(src);\n\t\tbreak;\n\t\t}\n#if OPENSSL_VERSION_NUMBER >= 0x10000000L && !defined(OPENSSL_NO_EC)\n\tcase NID_id_GostR3410_2001: {\n\t\tstruct sc_pkcs15_prkey_gostr3410 *dst = &pkcs15_key->u.gostr3410;\n\t\tEC_KEY *src = EVP_PKEY_get0(pk);\n\n\t\tassert(src);\n\t\tpkcs15_key->algorithm = SC_ALGORITHM_GOSTR3410;\n\t\tassert(EC_KEY_get0_private_key(src));\n\t\tsc_pkcs15_convert_bignum(&dst->d, EC_KEY_get0_private_key(src));\n\t\tbreak;\n\t\t}\n\tcase EVP_PKEY_EC: {\n\t\tstruct sc_pkcs15_prkey_ec *dst = &pkcs15_key->u.ec;\n\t\tEC_KEY *src = NULL;\n\t\tconst EC_GROUP *grp = NULL;\n\t\tunsigned char buf[255];\n\t\tsize_t buflen = 255;\n\t\tint nid;\n\n\t\tsrc = EVP_PKEY_get0(pk);\n\t\tassert(src);\n\t\tassert(EC_KEY_get0_private_key(src));\n\t\tassert(EC_KEY_get0_public_key(src));\n\n\t\tpkcs15_key->algorithm = SC_ALGORITHM_EC;\n\n\t\tif (!sc_pkcs15_convert_bignum(&dst->privateD, EC_KEY_get0_private_key(src)))\n\t\t\treturn SC_ERROR_INCOMPATIBLE_KEY;\n\n\t\tgrp = EC_KEY_get0_group(src);\n\t\tif(grp == 0)\n\t\t\treturn SC_ERROR_INCOMPATIBLE_KEY;\n\n\t\t/* get curve name */\n\t\tnid = EC_GROUP_get_curve_name(grp);\n\t\tif(nid != 0) {\n\t\t\tconst char *sn = OBJ_nid2sn(nid);\n\t\t\tif (sn)\n\t\t\t\tdst->params.named_curve = strdup(sn);\n\t\t}\n\n\t\t/* Decode EC_POINT from a octet string */\n\t\tbuflen = EC_POINT_point2oct(grp, (const EC_POINT *) EC_KEY_get0_public_key(src),\n\t\t\t\tPOINT_CONVERSION_UNCOMPRESSED, buf, buflen, NULL);\n\t\tif (!buflen)\n\t\t\treturn SC_ERROR_INCOMPATIBLE_KEY;\n\n\t\t/* copy the public key */\n\t\tdst->ecpointQ.value = malloc(buflen);\n\t\tif (!dst->ecpointQ.value)\n\t\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t\tmemcpy(dst->ecpointQ.value, buf, buflen);\n\t\tdst->ecpointQ.len = buflen;\n\n\t\t/*\n\t\t * In OpenSC the field_length is in bits. Not all curves are a mutiple of 8.\n\t\t * EC_POINT_point2oct handles this and returns octstrings that can handle\n\t\t * these curves. Get real field_length from OpenSSL. \n\t\t */\n\t\tdst->params.field_length = EC_GROUP_get_degree(grp);\n\n\t\t/* Octetstring may need leading zeros if BN is to short */\n\t\tif (dst->privateD.len < (dst->params.field_length + 7) / 8)   {\n\t\t\tsize_t d = (dst->params.field_length + 7) / 8 - dst->privateD.len;\n\n\t\t\tdst->privateD.data = realloc(dst->privateD.data, dst->privateD.len + d);\n\t\t\tif (!dst->privateD.data)\n\t\t\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\n\t\t\tmemmove(dst->privateD.data + d, dst->privateD.data, dst->privateD.len);\n\t\t\tmemset(dst->privateD.data, 0, d);\n\n\t\t\tdst->privateD.len += d;\n\t\t}\n\n\t\tbreak;\n\t}\n#endif /* OPENSSL_VERSION_NUMBER >= 0x10000000L && !defined(OPENSSL_NO_EC) */\n\tdefault:\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t}\n\n\treturn SC_SUCCESS;\n#else\n\treturn SC_ERROR_NOT_IMPLEMENTED;\n#endif\n}\n"], "filenames": ["src/libopensc/pkcs15-prkey.c"], "buggy_code_start_loc": [263], "buggy_code_end_loc": [267], "fixing_code_start_loc": [263], "fixing_code_end_loc": [264], "type": "CWE-672", "message": "An issue was discovered in OpenSC through 0.19.0 and 0.20.x through 0.20.0-rc3. libopensc/pkcs15-prkey.c has an incorrect free operation in sc_pkcs15_decode_prkdf_entry.", "other": {"cve": {"id": "CVE-2019-19480", "sourceIdentifier": "cve@mitre.org", "published": "2019-12-01T23:15:10.730", "lastModified": "2020-01-24T19:15:13.323", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An issue was discovered in OpenSC through 0.19.0 and 0.20.x through 0.20.0-rc3. libopensc/pkcs15-prkey.c has an incorrect free operation in sc_pkcs15_decode_prkdf_entry."}, {"lang": "es", "value": "Se detect\u00f3 un problema en OpenSC versiones hasta 0.19.0 y versiones 0.20.x hasta 0.20.0-rc3. El archivo libopensc/pkcs15-prkey.c presenta una operaci\u00f3n liberada incorrecta en la funci\u00f3n sc_pkcs15_decode_prkdf_entry."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:P/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "PHYSICAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 4.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-672"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:opensc_project:opensc:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.19.0", "matchCriteriaId": "1BBAA136-529C-41AB-8A74-D4BABD9B00ED"}, {"vulnerable": true, "criteria": "cpe:2.3:a:opensc_project:opensc:0.20.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "B40AD56D-CA2A-41D0-A0B5-C5ACF6F21858"}, {"vulnerable": true, "criteria": "cpe:2.3:a:opensc_project:opensc:0.20.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "9C6258EA-E2DE-4AB0-BCF8-E4F550E80A4E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:opensc_project:opensc:0.20.0:rc3:*:*:*:*:*:*", "matchCriteriaId": "69C9C1EF-1A86-44CD-A147-5DEA86441FC2"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:o:linux:linux_kernel:-:*:*:*:*:*:*:*", "matchCriteriaId": "703AF700-7A70-47E2-BC3A-7FD03B3CA9C1"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2019/12/29/1", "source": "cve@mitre.org", "tags": ["Mailing List"]}, {"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=18478", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/OpenSC/OpenSC/commit/6ce6152284c47ba9b1d4fe8ff9d2e6a3f5ee02c7", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/NDSQLMZZYBHO5X3BK7D6E7E6NZIMZDI5/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/OpenSC/OpenSC/commit/6ce6152284c47ba9b1d4fe8ff9d2e6a3f5ee02c7"}}