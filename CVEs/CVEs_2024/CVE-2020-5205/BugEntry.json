{"buggy_code": ["# Changelog\n\n## v1.0.16 (TBA)\n\n### Enhancements\n\n* [`PowPersistentSession.Plug.Cookie`] Now supports `:persistent_session_cookie_opts` to customize any options that will be passed on to `Plug.Conn.put_resp_cookie/4`\n* [`PowResetPassword.Phoenix.ResetPasswordController`] Now uses `PowResetPassword.Phoenix.Messages.maybe_email_has_been_sent/1` with a generic response that tells the user the email has been sent only if an account was found\n* [`PowResetPassword.Phoenix.ResetPasswordController`] When a user doesn't exist will now return success message if `PowEmailConfirmation` extension is enabled\n* [`PowResetPassword.Phoenix.Messages`] Added `PowResetPassword.Phoenix.Messages.maybe_email_has_been_sent/1` and let `PowResetPassword.Phoenix.Messages.email_has_been_sent/1` fall back to it\n* [`PowEmailConfirmation.Phoenix.ControllerCallbacks`] When a user tries to sign up and the email has already been taken the default e-mail confirmation required message will be shown\n\n### Bug fixes\n\n* [`Pow.Ecto.Schema.Changeset`] Fixed bug where `Pow.Ecto.Schema.Changeset.user_id_field_changeset/3` update with `nil` value caused an exception to be raised\n* [`PowPersistentSession.Plug.Cookie`] Now expires the cookie 10 seconds after the last request when authenticating to prevent multiple simultaneous requests deletes the cookie immediately\n\n### Documentation\n\n* Added mailer rate limitation section to [production checklist guide](guides/production_checklist.md)\n* [`Pow.Plug.Session`] Added section on session expiration to the docs\n* Updated instructions in [umbrella project guide](guides/umbrella_project.md) to Elixir 1.9\n* [`Pow.Store.Backend.Base`] Updated usage example with Cachex\n* Added [security practices page](guides/security_practices.md)\n\n## v1.0.15 (2019-11-20)\n\n### Enhancements\n\n* [`Pow.Extension.Base`] Extensions are now expected to have a base module with compile-time information whether certain modules are available to prevent unnecessary `Code.ensure_compiled?/1` calls:\n  * Added `Pow.Extension.Base` module\n  * Added `PowEmailConfirmation` module\n  * Added `PowInvitation` module\n  * Added `PowPersistentSession` module\n  * Added `PowResetPassword` module\n* [`PowPersistentSession.Plug.Cookie`] Added support for custom metadata:\n  * `PowPersistentSession.Plug.Cookie.create/3` now stores a metadata keyword list that can be populated\n  * `PowPersistentSession.Plug.Cookie.create/3` will now, instead of adding `:session_fingerprint` to the metadata, populate the `:session_metadata` keyword list with `:fingerprint`\n  * `PowPersistentSession.Plug.Cookie.authenticate/2` will now populate session metadata with what exists in `:session_metadata` key for the persistent session metadata\n  * `PowPersistentSession.Plug.Cookie.create/3` now ensures to delete the previous persistent session first, if one is found in cookies\n* [`Pow.Extension.Config`] Added `Pow.Extension.Config.extension_modules/2`\n\n### Bug fixes\n\n* [`Router.Phoenix.Router`] Fixed bug where resource routes were not filtered correctly according to the path bindings\n\n### Deprecations\n\n* [`Pow.Extension.Config`] Deprecated `Pow.Extension.Config.discover_modules/2`\n\n## v1.0.14 (2019-10-29)\n\n### Changes\n\n* Changed minmum password length to 8 (OWASP/NIST recommendations)\n* `Pow.Phoenix.Router` now only filters routes that has equal number of bindings\n* `Pow.Phoenix.Routes.user_not_authenticated_path/1` now only puts the `:request_path` param if the request is using \"GET\" method\n* The stores has been refactored so the command conforms with ETS store. This means that put commands now accept `{key, value}` record element(s), and keys may be list for easier lookup.\n  * `Pow.Store.Backend.Base` behaviour now requires to;\n    * Accept `Pow.Store.Backend.Base.record/0` values for `put/2`\n    * Accept `Pow.Store.Backend.Base.key/0` for `delete/2` and `get/2`\n    * Implement `all/2`\n    * Remove `keys/1`\n    * Remove `put/3`\n  * `Pow.Store.Backend.EtsCache` now uses `:ordered_set` instead of `:set` for efficiency\n  * `Pow.Store.Backend.MnesiaCache` now uses `:ordered_set` instead of `:set` for efficiency\n  * `Pow.Store.Backend.MnesiaCache` will delete all binary key records when initialized\n  * `Pow.Store.Base` behaviour now requires to;\n    * Accept erlang term value for keys in all methods\n    * Implement `put/3` instead of `put/4`\n    * Implement `delete/2` instead of `put/3`\n    * Implement `get/2` instead of `put/3`\n    * Remove `keys/2`\n  * `Pow.Store.Base.all/3` added\n  * `Pow.Store.Base.put/3` added\n  * `Pow.Store.Base` will use binary key rather than key list if `all/2` doesn't exist in the backend cache\n  * Added `Pow.Store.CredentialsCache.users/2`\n  * Added `Pow.Store.CredentialsCache.sessions/2`\n  * `Pow.Store.CredentialsCache` now adds a session key rather than appending to a list for the user key to prevent race condition\n* `Pow.Plug.Session.create/3` now stores a keyword list with metadata for the session rather than just a timestamp\n* `Pow.Plug.Session.fetch/2` and `Pow.Plug.Session.create/3` now assigns `:pow_session_metadata` in `conn.private` with the session metadata\n* `Pow.Plug.Session.create/3` will use the metadata found in `conn.private[:pow_session_metadata]` if it exists and otherwise add a randomly unique id for `:fingerprint`\n* `PowPersistentSession.Plug.Cookie.create/3` will use the value of `conn.private[:pow_session_metadata][:fingerprint]` if it exists as `:session_fingerprint` in the persistent session metadata\n* `PowPersistentSession.Plug.Cookie.authenticate/2` will assign `:fingerprint` to `conn.private[:pow_session_metadata]` if it exists in the persistent session metadata\n* `Pow.Store.CredentialsCache.put/3` will invalidate any other sessions with the same `:fingerprint` if any is set in session metadata\n* `PowResetPassword.Phoenix.ResetPasswordController.create/2` when a user doesn't exist will now only return success message if the registration routes has been disabled, otherwise the form with an error message will be returned\n* Added `PowResetPassword.Phoenix.Messages.user_not_found/1`\n\n### Bug fixes\n\n* Fixed bug where `Pow.Store.CredentialsCache` wasn't used due to how `Pow.Store.Base` macro worked\n* Fixed bug where `PowEmailConfirmation.Phoenix.ControllerCallbacks` couldn't deliver email\n\n### Deprecations\n\n* Deprecated `Pow.Store.Backend.EtsCache.keys/1`\n* Deprecated `Pow.Store.Backend.EtsCache.put/3`\n* Deprecated `Pow.Store.Backend.MnesiaCache.keys/1`\n* Deprecated `Pow.Store.Backend.MnesiaCache.put/3`\n* Deprecated `Pow.Store.Base.keys/2`\n* Deprecated `Pow.Store.Base.put/4`\n* Deprecated `Pow.Store.CredentialsCache.user_session_keys/3`\n* Deprecated `Pow.Store.CredentialsCache.sessions/3`\n\n## v1.0.13 (2019-08-25)\n\n* Updated `PowEmailConfirmation.Ecto.Schema.changeset/3` so;\n  * when `:email` is identical to `:unconfirmed_email` it won't generate new `:email_confirmation_token`\n  * when `:email` is identical to the persisted `:email` value both `:email_confirmation_token` and `:unconfirmed_email` will be set to `nil`\n  * when there is no `:email` value in the params nothing happens\n* Updated `PowEmailConfirmation.Ecto.Schema.confirm_email_changeset/1` so now `:email_confirmation_token` is set to `nil`\n* Updated `Pow.Ecto.Schema.Changeset.user_id_field_changeset/3` so the e-mail validator now accepts unicode e-mails\n* Added `PowEmailConfirmation.Ecto.Context.current_email_unconfirmed?/2` and `PowEmailConfirmation.Plug.pending_email_change?/1`\n* Added `:email_validator` configuration option to `Pow.Ecto.Schema.Changeset`\n* Added `Pow.Ecto.Schema.Changeset.validate_email/1`\n* Fixed bug in `PowEmailConfirmation.Phoenix.ControllerCallbacks.send_confirmation_email/2` where the confirmation e-mail wasn't send to the updated e-mail address\n\n## v1.0.12 (2019-08-16)\n\n* Added API integration guide\n* Added `:reset_password_token_store` configuration setting\n* To prevent timing attacks, `Pow.Ecto.Context.authenticate/2` now verifies password on a blank user struct when no user can be found for the provided user id, but will always return nil. The blank user struct has a nil `:password_hash` value. The struct will be passed along with a blank password to the `verify_password/2` method in the user schema module.\n* To prevent timing attacks, when `Pow.Ecto.Schema.Changeset.verify_password/3` receives a struct with a nil `:password_hash` value, it'll hash a blank password, but always return false.\n* To prevent timing attacks, the UUID is always generated in `PowResetPassword.Plug.create_reset_token/2` whether the user exists or not.\n* `PowPersistentSession.Plug.Base` now accepts `:persistent_session_ttl` which will pass the TTL to the cache backend and used for the max age of the sesion cookie in `PowPersistentSession.Plug.Cookie`\n* Deprecated `:persistent_session_cookie_max_age` configuration setting\n* `Pow.Store.Backend.MnesiaCache` can now auto join clusters\n* `Pow.Store.Backend.MnesiaCache.Unsplit` module added for self-healing after network split\n* Removed `:nodes` config option for `Pow.Store.Backend.MnesiaCache`\n\n## v1.0.11 (2019-06-13)\n\n* Fixed bug in router filters with Phoenix 1.4.7\n\n## v1.0.10 (2019-06-09)\n\n* Prevent browser cache of `Pow.Phoenix.SessionController.new/2`, `Pow.Phoenix.RegistrationController.new/2` and `PowInvitation.Phoenix.InvitationController.edit/2` by setting \"Cache-Control\" header unless it already has been customized\n* All links in docs generated with `mix docs` and on [hexdocs.pm](http://hexdocs.pm/pow/) now works\n* Generated docs now uses lower case file name except for `README`, `CONTRIBUTING` and `CHANGELOG`\n* Removed duplicate call for `Pow.Plug.Session.delete/2` in `Pow.Plug.Sesssion.create/3`\n\n## v1.0.9 (2019-06-04)\n\n### Changes\n\n* `Pow.Phoenix.Router` will now only add specific routes if there is no matching route already defined\n* Added `Pow.Plug.get_plug/1` and instead of `:mod`, `:plug` is used in config\n* `Pow.Ecto.Context.authenticate/2` now returns nil if user id or password is nil\n\n### Bug fixes\n\n* Fixed bug with exception raised in `Pow.Ecto.Schema.normalize_user_id_field_value/1` when calling `Pow.Ecto.Context.get_by/2` with a non binary user id\n* Fixed bug with exception raised in `Pow.Ecto.Schema.normalize_user_id_field_value/1` when calling `Pow.Ecto.Context.authenticate/2` with a non binary user id\n\n### Deprecations\n\n* Deprecated `Pow.Plug.get_mod/1`\n* Removed call to `Pow.Ecto.Context.repo/1`\n\n## v1.0.8 (2019-05-24)\n\n### Changes\n\n* Added support for layout in mails with `Pow.Phoenix.Mailer.Mail` by setting `conn.private[:pow_mailer_layout]` same way as the Phoenix layout with `conn.private[:phoenix_layout]`\n* Added `:prefix` repo opts support to use in multitenant apps\n* Removed `@changeset.data.__struct__.pow_user_id_field()` in template in favor of using `Pow.Ecto.Schema.user_id_field/1`\n\n### Bug fixes\n\n* Fixed bug in `Pow.Ecto.Schema.Changeset.current_password_changeset/3` where an exception would be thrown if the virtual `:current_password` field of the user struct was set and either the `:current_password` change was blank or identical\n\n### Deprecations\n\n* Deprecated `Mix.Pow.Ecto.Migration.create_migration_files/3` and moved it to `Mix.Pow.Ecto.Migration.create_migration_file/3`\n* Deprecated `Pow.Ecto.Context.repo/1` and moved it to `Pow.Config.repo!/1`\n* Deprecated `Pow.Ecto.Context.user_schema_mod/1` and moved it to `Pow.Config.user!/1`\n\n## v1.0.7 (2019-05-01)\n\n* Fixed bug with Phoenix 1.4.4 scoped routes\n\n## v1.0.6 (2019-04-19)\n\n* Fixed bug where custom layout setting raised exception in `Pow.Phoenix.ViewHelpers.layout/1`\n* Prevent users from changing their email to one already taken when the PowEmailConfirmation extension has been enabled\n\n## v1.0.5 (2019-04-09)\n\n* Added `extension_messages/1` to extension controllers and callbacks\n* Improved feedback for when no templates are generated for an extension with `mix pow.extension.phoenix.gen.templates` and `mix pow.extension.phoenix.mailer.gen.templates` tasks\n* Error flash is no longer overridden in `Pow.Phoenix.PlugErrorHandler` if the error message is nil\n* Fixed bug in the migration generator where `references/2` wasn't called with options\n* Support any `:plug` version below `2.0.0`\n* Deprecated `Pow.Extension.Ecto.Context.Base`\n\n## v1.0.4 (2019-03-13)\n\n* Added `PowInvitation` to the `mix pow.extension.phoenix.gen.templates` and `mix pow.extension.phoenix.mailer.gen.templates` tasks\n* Fixed issue in umbrella projects where extensions wasn't found in environment configuration\n* Fixed so `:namespace` environment config can be used as web app module name\n* Shell instructions will only be printed if the configuration is missing\n* Now requires that `:ecto` or `:phoenix` are included in the dependency list for the app to run respective mix tasks\n* Deprecated `Mix.Pow.context_app/0`\n* Deprecated `Mix.Pow.ensure_dep!/3`\n* Deprecated `Mix.Pow.context_base/1`\n\n## v1.0.3 (2019-03-09)\n\n### Changes\n\n* Added `PowInvitation` extension\n* Added support in `Pow.Ecto.Schema` for Ecto associations fields\n* Added support for adding custom methods with `Pow.Extension.Ecto.Schema` through `__using__/1` macro in extension ecto schema module\n* Help information raised with invalid schema arguments for `pow.install`, `pow.ecto.install`, `pow.ecto.gen.migration`, and `pow.ecto.gen.schema` mix tasks\n* `PowEmailConfirmation` now redirects unconfirmed users to `after_registration_path/1` or `after_sign_in_path/1` rather than `pow_session_path(conn, :new)`\n\n### Bug fixes\n\n* Correct shell instructions for `mix pow.install` task with custom schema\n* Fixed bug in `Pow.Extension.Phoenix.Router.Base` and `Pow.Extension.Phoenix.Messages` where the full extension name wasn't used to namespace methods\n\n### Deprecations\n\n* Deprecated `Pow.Extension.Config.underscore_extension/1`\n* Deprecated `PowResetPassword.Ecto.Context.password_changeset/2`\n* Deprecated `Pow.Ecto.Schema.filter_new_fields/2`\n* Deprecated `:messages_backend_fallback` setting for extension controllers\n* Removed deprecated macro `router_helpers/1` in `Pow.Phoenix.Controller`\n\n## v1.0.2 (2019-02-28)\n\n* Added flash error message about e-mail confirmation for when user changes e-mail with PowEmailConfirmation enabled\n* Added `new_password_changeset/3` and `confirm_password_changeset/3` to `Pow.Ecto.Schema.Changeset`\n* Redis cache store backend guide\n* Correct shell instructions for `mix pow.phoenix.gen.templates` task\n* Only load environment config in `Pow.Config.get/3` when no key is set in the provided config\n* Fixed issue in `Pow.Store.Backend.MnesiaCache.keys/1` and `Pow.Store.Backend.EtsCache.keys/1` so they now return keys without namespace\n* `Pow.Store.Backend.MnesiaCache.put/3` now raises an error if TTL is not provided\n\n### Breaking changes\n\n* `PowResetPassword.Plug.reset_password_token/1` has been removed\n\n## v1.0.1 (2019-01-27)\n\n* `pow.extension.ecto.gen.migrations` mix task will output warning when a migration file won't be generated for any particular extension\n* Leading and trailing whitespace is removed from the user id field value (in addition to forced lower case)\n* An exception is raised when `pow_routes/0` or `pow_extension_routes/0` are used inside router scopes with aliases\n* Mail view templates assigns now has `[user: user, conn: conn]` along with the template specific assigns\n* Mail view subject methods now gets the same assigns passed as mail view template assigns instead of only `[conn: conn]`\n* Added `pow_registration_routes/0`, `pow_session_routes/0` and `pow_scope/1` macros to the router module\n* Added guide on how to disable registration\n\n## v1.0.0 (2018-11-18)\n\n* Phoenix 1.4 support\n* Ecto 3.0 support\n", "defmodule Pow.Plug.Session do\n  @moduledoc \"\"\"\n  This plug will handle user authorization using session.\n\n  The plug will store user and session metadata in the cache store backend. The\n  session metadata has at least an `:inserted_at` and a `:fingerprint` key. The\n  `:inserted_at` value is used to determine if the session has to be renewed,\n  and is set each time a session is created. The `:fingerprint` will be a random\n  unique id and will stay the same if a session is renewed.\n\n  When a session is renewed the old session is deleted and a new created.\n\n  You can add additional metadata to sessions by setting or updated the\n  assigned private `:pow_session_metadata` key in the conn. The value has to be\n  a keyword list.\n\n  ## Example\n\n      plug Plug.Session,\n        store: :cookie,\n        key: \"_my_app_demo_key\",\n        signing_salt: \"secret\"\n\n      plug Pow.Plug.Session,\n        repo: MyApp.Repo,\n        user: MyApp.User,\n        current_user_assigns_key: :current_user,\n        session_key: \"auth\",\n        session_store: {Pow.Store.CredentialsCache,\n                        ttl: :timer.minutes(30),\n                        namespace: \"credentials\"},\n        session_ttl_renewal: :timer.minutes(15),\n        cache_store_backend: Pow.Store.Backend.EtsCache,\n        users_context: Pow.Ecto.Users\n\n  ## Configuration options\n\n    * `:session_key` - session key name, defaults to \"auth\". If `:otp_app` is\n      used it'll automatically prepend the key with the `:otp_app` value.\n\n    * `:session_store` - the credentials cache store. This value defaults to\n      `{Pow.Store.CredentialsCache, backend: Pow.Store.Backend.EtsCache}`. The\n      `Pow.Store.Backend.EtsCache` backend store can be changed with the\n      `:cache_store_backend` option.\n\n    * `:cache_store_backend` - the backend cache store. This value defaults to\n      `Pow.Store.Backend.EtsCache`.\n\n    * `:session_ttl_renewal` - the ttl in milliseconds to trigger renewal of\n      sessions. Defaults to 15 minutes in miliseconds.\n\n  ## Custom metadata\n\n  The assigned private `:pow_session_metadata` key in the conn can be populated\n  with custom metadata. This data will be stored in the session metadata when\n  the session is created, and fetched in subsequent requests.\n\n  Here's an example of how one could add sign in timestamp, IP, and user agent\n  information to the session metadata:\n\n      def append_to_session_metadata(conn) do\n        client_ip  = to_string(:inet_parse.ntoa(conn.remote_ip))\n        user_agent = get_req_header(conn, \"user-agent\")\n\n        metadata =\n          conn.private\n          |> Map.get(:pow_session_metadata, [])\n          |> Keyword.put_new(:first_seen_at, DateTime.utc_now())\n          |> Keyword.put(:ip, client_ip)\n          |> Keyword.put(:user_agent, user_agent)\n\n        Plug.Conn.put_private(conn, :pow_session_metadata, metadata)\n      end\n\n  The `:first_seen_at` will only be set if it doesn't already exist in the\n  session metadata, while `:ip` and `:user_agent` will be updated each time the\n  session is created.\n\n  The method should be called after `Pow.Plug.Session.call/2` has been called\n  to ensure that the metadata, if any, has been fetched.\n\n  ## Session expiration\n\n  `Pow.Store.CredentialsCache` will, by default, invalidate any session token\n  30 minutes after it has been generated. To keep sessions alive the\n  `:session_ttl_renewal` option is used to determine when a session token\n  becomes stale and a new session ID has to be generated for the user (deleting\n  the previous one in the process).\n\n  If `:session_ttl_renewal` is set to zero, a new session token will be\n  generated on every request.\n\n  To change the amount of time a session can be alive, both the TTL for\n  `Pow.Store.CredentialsCache` and `:session_ttl_renewal` option should be\n  changed:\n\n      plug Pow.Plug.Session, otp_app: :my_app,\n        session_ttl_renewal: :timer.minutes(1),\n        session_store: {Pow.Store.CredentialsCache, ttl: :timer.minutes(15)}\n\n  In the above, a new session token will be generated when a request occurs\n  more than a minute after the current session token was generated. The\n  session is invalidated if there is no request for the next 14 minutes.\n\n  There are no absolute session timeout; sessions can be kept alive\n  indefinitely.\n  \"\"\"\n  use Pow.Plug.Base\n\n  alias Plug.Conn\n  alias Pow.{Config, Plug, Store.Backend.EtsCache, Store.CredentialsCache, UUID}\n\n  @session_key \"auth\"\n  @session_ttl_renewal :timer.minutes(15)\n\n  @doc \"\"\"\n  Fetches session from credentials cache.\n\n  This will fetch a session from the credentials cache with the session id\n  fetched through `Plug.Conn.get_session/2` session. If the credentials are\n  stale (timestamp is older than the `:session_ttl_renewal` value), the session\n  will be regenerated with `create/3`.\n\n  The metadata of the session will be assigned as a private\n  `:pow_session_metadata` key in the conn so it may be used in `create/3`.\n\n  See `do_fetch/2` for more.\n  \"\"\"\n  @impl true\n  @spec fetch(Conn.t(), Config.t()) :: {Conn.t(), map() | nil}\n  def fetch(conn, config) do\n    {store, store_config} = store(config)\n    conn                  = Conn.fetch_session(conn)\n    key                   = Conn.get_session(conn, session_key(config))\n\n    {key, store.get(store_config, key)}\n    |> convert_old_session_value()\n    |> handle_fetched_session_value(conn, config)\n  end\n\n  @doc \"\"\"\n  Create new session with a randomly generated unique session id.\n\n  This will store the unique session id with user credentials in the\n  credentials cache. The session id will be stored in the connection with\n  `Plug.Conn.put_session/3`. Any existing sessions will be deleted first with\n  `delete/2`.\n\n  The unique session id will be prepended by the `:otp_app` configuration\n  value, if present.\n\n  If an assigned private `:pow_session_metadata` key exists in the conn, it'll\n  be passed on as the metadata for the session. However the `:inserted_at` value\n  will always be overridden. If no `:fingerprint` exists in the metadata a\n  random UUID value will be generated as its value.\n\n  See `do_create/3` for more.\n  \"\"\"\n  @impl true\n  @spec create(Conn.t(), map(), Config.t()) :: {Conn.t(), map()}\n  def create(conn, user, config) do\n    conn                  = Conn.fetch_session(conn)\n    {store, store_config} = store(config)\n    metadata              = Map.get(conn.private, :pow_session_metadata, [])\n    {user, metadata}      = session_value(user, metadata)\n    key                   = session_id(config)\n    session_key           = session_key(config)\n\n    store.put(store_config, key, {user, metadata})\n\n    conn =\n      conn\n      |> delete(config)\n      |> Conn.put_private(:pow_session_metadata, metadata)\n      |> Conn.put_session(session_key, key)\n\n    {conn, user}\n  end\n\n  defp session_value(user, metadata) do\n    metadata =\n      metadata\n      |> Keyword.put_new(:fingerprint, UUID.generate())\n      |> Keyword.put(:inserted_at, timestamp())\n\n    {user, metadata}\n  end\n\n  @doc \"\"\"\n  Delete an existing session in the credentials cache.\n\n  This will delete a session in the credentials cache with the session id\n  fetched through `Plug.Conn.get_session/2`. The session in the connection is\n  deleted too with `Plug.Conn.delete_session/2`.\n\n  See `do_delete/2` for more.\n  \"\"\"\n  @impl true\n  @spec delete(Conn.t(), Config.t()) :: Conn.t()\n  def delete(conn, config) do\n    conn                  = Conn.fetch_session(conn)\n    key                   = Conn.get_session(conn, session_key(config))\n    {store, store_config} = store(config)\n    session_key           = session_key(config)\n\n    store.delete(store_config, key)\n\n    Conn.delete_session(conn, session_key)\n  end\n\n  # TODO: Remove by 1.1.0\n  defp convert_old_session_value({key, {user, timestamp}}) when is_number(timestamp), do: {key, {user, inserted_at: timestamp}}\n  defp convert_old_session_value(any), do: any\n\n  defp handle_fetched_session_value({_key, :not_found}, conn, _config), do: {conn, nil}\n  defp handle_fetched_session_value({_key, {user, metadata}}, conn, config) when is_list(metadata) do\n    conn\n    |> Conn.put_private(:pow_session_metadata, metadata)\n    |> renew_stale_session(user, metadata, config)\n  end\n\n  defp renew_stale_session(conn, user, metadata, config) do\n    metadata\n    |> Keyword.get(:inserted_at)\n    |> session_stale?(config)\n    |> case do\n      true  -> create(conn, user, config)\n      false -> {conn, user}\n    end\n  end\n\n  defp session_stale?(inserted_at, config) do\n    ttl = Config.get(config, :session_ttl_renewal, @session_ttl_renewal)\n    session_stale?(inserted_at, config, ttl)\n  end\n  defp session_stale?(_inserted_at, _config, nil), do: false\n  defp session_stale?(inserted_at, _config, ttl) do\n    inserted_at + ttl < timestamp()\n  end\n\n  defp session_id(config) do\n    uuid = UUID.generate()\n\n    Plug.prepend_with_namespace(config, uuid)\n  end\n\n  defp session_key(config) do\n    Config.get(config, :session_key, default_session_key(config))\n  end\n\n  defp default_session_key(config) do\n    Plug.prepend_with_namespace(config, @session_key)\n  end\n\n  defp store(config) do\n    case Config.get(config, :session_store, default_store(config)) do\n      {store, store_config} -> {store, store_config}\n      store                 -> {store, []}\n    end\n  end\n\n  defp default_store(config) do\n    backend = Config.get(config, :cache_store_backend, EtsCache)\n\n    {CredentialsCache, [backend: backend]}\n  end\n\n  defp timestamp, do: :os.system_time(:millisecond)\nend\n", "defmodule Pow.Plug.SessionTest do\n  use ExUnit.Case\n  doctest Pow.Plug.Session\n\n  alias Plug.Conn\n  alias Pow.{Plug, Plug.Session, Store.Backend.EtsCache, Store.CredentialsCache}\n  alias Pow.Test.{ConnHelpers, Ecto.Users.User, EtsCacheMock}\n\n  @default_opts [\n    current_user_assigns_key: :current_user,\n    session_key: \"auth\",\n    cache_store_backend: EtsCacheMock\n  ]\n  @store_config [backend: EtsCacheMock]\n  @user %User{id: 1}\n\n  setup do\n    EtsCacheMock.init()\n\n    conn =\n      :get\n      |> ConnHelpers.conn(\"/\")\n      |> ConnHelpers.init_session()\n\n    {:ok, %{conn: conn}}\n  end\n\n  test \"call/2 sets plug in :pow_config\", %{conn: conn} do\n    opts = Session.init(@default_opts)\n    conn = Session.call(conn, opts)\n    expected_config = [mod: Session, plug: Session] ++ @default_opts\n\n    assert is_nil(conn.assigns[:current_user])\n    assert conn.private[:pow_config] == expected_config\n  end\n\n  test \"call/2 with assigned current_user\", %{conn: conn} do\n    opts = Session.init(@default_opts)\n    conn =\n      conn\n      |> Plug.assign_current_user(\"assigned\", @default_opts)\n      |> Session.call(opts)\n\n    assert conn.assigns[:current_user] == \"assigned\"\n  end\n\n  test \"call/2 with stored current_user\", %{conn: conn} do\n    CredentialsCache.put(@store_config, \"token\", {@user, inserted_at: :os.system_time(:millisecond), fingerprint: \"fingerprint\"})\n\n    opts = Session.init(@default_opts)\n    conn =\n      conn\n      |> Conn.fetch_session()\n      |> Conn.put_session(@default_opts[:session_key], \"token\")\n      |> Session.call(opts)\n\n    assert conn.assigns[:current_user] == @user\n    assert conn.private[:pow_session_metadata][:fingerprint] == \"fingerprint\"\n  end\n\n  test \"call/2 with stored session and custom metadata\", %{conn: conn} do\n    inserted_at = :os.system_time(:millisecond)\n    CredentialsCache.put(@store_config, \"token\", {@user, inserted_at: inserted_at, a: 1})\n\n    opts = Session.init(@default_opts)\n    conn =\n      conn\n      |> Conn.put_private(:pow_session_metadata, b: 2)\n      |> Conn.fetch_session()\n      |> Conn.put_session(@default_opts[:session_key], \"token\")\n      |> Session.call(opts)\n\n    assert conn.assigns[:current_user] == @user\n    assert conn.private[:pow_session_metadata][:inserted_at] == inserted_at\n    assert conn.private[:pow_session_metadata][:a] == 1\n  end\n\n  test \"call/2 with non existing cached key\", %{conn: conn} do\n    CredentialsCache.put(@store_config, \"token\", {@user, inserted_at: :os.system_time(:millisecond)})\n\n    opts = Session.init(@default_opts)\n    conn =\n      conn\n      |> Conn.fetch_session()\n      |> Conn.put_session(@default_opts[:session_key], \"invalid\")\n      |> Session.call(opts)\n\n    assert is_nil(conn.assigns[:current_user])\n  end\n\n  test \"call/2 creates new session when :session_renewal_ttl reached\", %{conn: conn} do\n    ttl             = 100\n    config          = Keyword.put(@default_opts, :session_ttl_renewal, ttl)\n    timestamp       = :os.system_time(:millisecond)\n    stale_timestamp = timestamp - ttl - 1\n    init_conn       =\n      conn\n      |> Conn.fetch_session()\n      |> Conn.put_session(config[:session_key], \"token\")\n\n    CredentialsCache.put(@store_config, \"token\", {@user, inserted_at: timestamp, fingerprint: \"fingerprint\"})\n\n    opts = Session.init(config)\n    conn = Session.call(init_conn, opts)\n    session_id = get_session_id(conn)\n\n    assert conn.assigns[:current_user] == @user\n\n    CredentialsCache.put(@store_config, \"token\", {@user, inserted_at: stale_timestamp, fingerprint: \"fingerprint\"})\n    CredentialsCache.put(@store_config, \"newer_token\", {@user, inserted_at: timestamp, fingerprint: \"new_fingerprint\"})\n\n    conn = Session.call(init_conn, opts)\n\n    assert conn.assigns[:current_user] == @user\n    assert new_session_id = get_session_id(conn)\n    assert new_session_id != session_id\n    assert {_user, metadata} = CredentialsCache.get(@store_config, new_session_id)\n    assert metadata[:inserted_at] != stale_timestamp\n    assert metadata[:fingerprint] == \"fingerprint\"\n    assert conn.private[:pow_session_metadata][:fingerprint] == \"fingerprint\"\n  end\n\n  test \"call/2 with prepended `:otp_app` session key\", %{conn: conn} do\n    CredentialsCache.put(@store_config, \"token\", {@user, inserted_at: :os.system_time(:millisecond)})\n\n    opts =\n      @default_opts\n      |> Keyword.delete(:session_key)\n      |> Keyword.put(:otp_app, :test_app)\n      |> Session.init()\n    conn =\n      conn\n      |> Conn.fetch_session()\n      |> Conn.put_session(\"test_app_auth\", \"token\")\n      |> Session.call(opts)\n\n    assert conn.assigns[:current_user] == @user\n  end\n\n  # TODO: Remove by 1.1.0\n  test \"backwards compatible\", %{conn: conn} do\n    ttl             = 100\n    config          = Keyword.put(@default_opts, :session_ttl_renewal, ttl)\n    stale_timestamp = :os.system_time(:millisecond) - ttl - 1\n\n    @store_config\n    |> Keyword.put(:namespace, \"credentials\")\n    |> EtsCacheMock.put({\"token\", {@user, stale_timestamp}})\n\n    opts = Session.init(config)\n    conn =\n      conn\n      |> Conn.fetch_session()\n      |> Conn.put_session(config[:session_key], \"token\")\n      |> Session.call(opts)\n\n    assert new_session_id = get_session_id(conn)\n    assert new_session_id != \"token\"\n\n    assert conn.assigns[:current_user] == @user\n  end\n\n  describe \"create/2\" do\n    test \"creates new session id\", %{conn: conn} do\n      opts = Session.init(@default_opts)\n      conn =\n        conn\n        |> Session.call(opts)\n        |> Session.do_create(@user, opts)\n\n      session_id = get_session_id(conn)\n\n      assert {@user, metadata} = CredentialsCache.get(@store_config, session_id)\n      assert is_binary(session_id)\n      assert Plug.current_user(conn) == @user\n      assert metadata[:inserted_at]\n      assert metadata[:fingerprint]\n\n      conn = Session.do_create(conn, @user, opts)\n      new_session_id = get_session_id(conn)\n\n      assert {@user, new_metadata} = CredentialsCache.get(@store_config, new_session_id)\n      assert is_binary(session_id)\n      assert new_session_id != session_id\n      assert CredentialsCache.get(@store_config, session_id) == :not_found\n      assert Plug.current_user(conn) == @user\n      assert metadata[:fingerprint] == new_metadata[:fingerprint]\n    end\n\n    test \"creates with custom metadata\", %{conn: conn} do\n      inserted_at = :os.system_time(:millisecond) - 10\n      opts = Session.init(@default_opts)\n      conn =\n        conn\n        |> Conn.put_private(:pow_session_metadata, inserted_at: inserted_at, a: 1)\n        |> Session.call(opts)\n        |> Session.do_create(@user, opts)\n\n      assert conn.assigns[:current_user] == @user\n      assert conn.private[:pow_session_metadata][:inserted_at] != inserted_at\n      assert conn.private[:pow_session_metadata][:fingerprint]\n      assert conn.private[:pow_session_metadata][:a] == 1\n    end\n\n    test \"creates new session id with `:otp_app` prepended\", %{conn: conn} do\n      opts =\n        @default_opts\n        |> Keyword.delete(:session_key)\n        |> Keyword.put(:otp_app, :test_app)\n        |> Session.init()\n      conn =\n        conn\n        |> Session.call(opts)\n        |> Session.do_create(@user, opts)\n\n      refute get_session_id(conn)\n\n      session_id = conn.private[:plug_session][\"test_app_auth\"]\n      assert String.starts_with?(session_id, \"test_app_\")\n    end\n  end\n\n  test \"delete/1 removes session id\", %{conn: conn} do\n    opts = Session.init(@default_opts)\n    conn =\n      conn\n      |> Session.call(opts)\n      |> Session.do_create(@user, opts)\n\n    session_id = get_session_id(conn)\n\n    assert {@user, _metadata} = CredentialsCache.get(@store_config, session_id)\n    assert is_binary(session_id)\n    assert Plug.current_user(conn) == @user\n\n    conn = Session.do_delete(conn, opts)\n\n    refute new_session_id = get_session_id(conn)\n    assert is_nil(new_session_id)\n    assert CredentialsCache.get(@store_config, session_id) == :not_found\n    assert is_nil(Plug.current_user(conn))\n  end\n\n  describe \"with EtsCache backend\" do\n    setup do\n      start_supervised!({EtsCache, []})\n\n      :ok\n    end\n\n    test \"call/2\", %{conn: conn} do\n      sesion_key = \"auth\"\n      config     = [session_key: sesion_key]\n      token      = \"credentials_cache_test\"\n      timestamp  = :os.system_time(:millisecond)\n      CredentialsCache.put(config, token, {@user, inserted_at: timestamp})\n\n      :timer.sleep(100)\n\n      opts = Session.init(session_key: \"auth\")\n      conn =\n        conn\n        |> Conn.fetch_session()\n        |> Conn.put_session(\"auth\", token)\n        |> Session.call(opts)\n\n      assert conn.assigns[:current_user] == @user\n    end\n  end\n\n  def get_session_id(conn) do\n    conn.private[:plug_session][@default_opts[:session_key]]\n  end\nend\n"], "fixing_code": ["# Changelog\n\n## v1.0.16 (TBA)\n\n**Note:** This release contains an important security fix.\n\n### Enhancements\n\n* [`PowPersistentSession.Plug.Cookie`] Now supports `:persistent_session_cookie_opts` to customize any options that will be passed on to `Plug.Conn.put_resp_cookie/4`\n* [`PowResetPassword.Phoenix.ResetPasswordController`] Now uses `PowResetPassword.Phoenix.Messages.maybe_email_has_been_sent/1` with a generic response that tells the user the email has been sent only if an account was found\n* [`PowResetPassword.Phoenix.ResetPasswordController`] When a user doesn't exist will now return success message if `PowEmailConfirmation` extension is enabled\n* [`PowResetPassword.Phoenix.Messages`] Added `PowResetPassword.Phoenix.Messages.maybe_email_has_been_sent/1` and let `PowResetPassword.Phoenix.Messages.email_has_been_sent/1` fall back to it\n* [`PowEmailConfirmation.Phoenix.ControllerCallbacks`] When a user tries to sign up and the email has already been taken the default e-mail confirmation required message will be shown\n* [`Pow.Plug.Session`] Now renews the Plug session each time the Pow session is created or rolled\n\n### Bug fixes\n\n* [`Pow.Ecto.Schema.Changeset`] Fixed bug where `Pow.Ecto.Schema.Changeset.user_id_field_changeset/3` update with `nil` value caused an exception to be raised\n* [`PowPersistentSession.Plug.Cookie`] Now expires the cookie 10 seconds after the last request when authenticating to prevent multiple simultaneous requests deletes the cookie immediately\n\n### Documentation\n\n* Added mailer rate limitation section to [production checklist guide](guides/production_checklist.md)\n* [`Pow.Plug.Session`] Added section on session expiration to the docs\n* Updated instructions in [umbrella project guide](guides/umbrella_project.md) to Elixir 1.9\n* [`Pow.Store.Backend.Base`] Updated usage example with Cachex\n* Added [security practices page](guides/security_practices.md)\n\n## v1.0.15 (2019-11-20)\n\n### Enhancements\n\n* [`Pow.Extension.Base`] Extensions are now expected to have a base module with compile-time information whether certain modules are available to prevent unnecessary `Code.ensure_compiled?/1` calls:\n  * Added `Pow.Extension.Base` module\n  * Added `PowEmailConfirmation` module\n  * Added `PowInvitation` module\n  * Added `PowPersistentSession` module\n  * Added `PowResetPassword` module\n* [`PowPersistentSession.Plug.Cookie`] Added support for custom metadata:\n  * `PowPersistentSession.Plug.Cookie.create/3` now stores a metadata keyword list that can be populated\n  * `PowPersistentSession.Plug.Cookie.create/3` will now, instead of adding `:session_fingerprint` to the metadata, populate the `:session_metadata` keyword list with `:fingerprint`\n  * `PowPersistentSession.Plug.Cookie.authenticate/2` will now populate session metadata with what exists in `:session_metadata` key for the persistent session metadata\n  * `PowPersistentSession.Plug.Cookie.create/3` now ensures to delete the previous persistent session first, if one is found in cookies\n* [`Pow.Extension.Config`] Added `Pow.Extension.Config.extension_modules/2`\n\n### Bug fixes\n\n* [`Router.Phoenix.Router`] Fixed bug where resource routes were not filtered correctly according to the path bindings\n\n### Deprecations\n\n* [`Pow.Extension.Config`] Deprecated `Pow.Extension.Config.discover_modules/2`\n\n## v1.0.14 (2019-10-29)\n\n### Changes\n\n* Changed minmum password length to 8 (OWASP/NIST recommendations)\n* `Pow.Phoenix.Router` now only filters routes that has equal number of bindings\n* `Pow.Phoenix.Routes.user_not_authenticated_path/1` now only puts the `:request_path` param if the request is using \"GET\" method\n* The stores has been refactored so the command conforms with ETS store. This means that put commands now accept `{key, value}` record element(s), and keys may be list for easier lookup.\n  * `Pow.Store.Backend.Base` behaviour now requires to;\n    * Accept `Pow.Store.Backend.Base.record/0` values for `put/2`\n    * Accept `Pow.Store.Backend.Base.key/0` for `delete/2` and `get/2`\n    * Implement `all/2`\n    * Remove `keys/1`\n    * Remove `put/3`\n  * `Pow.Store.Backend.EtsCache` now uses `:ordered_set` instead of `:set` for efficiency\n  * `Pow.Store.Backend.MnesiaCache` now uses `:ordered_set` instead of `:set` for efficiency\n  * `Pow.Store.Backend.MnesiaCache` will delete all binary key records when initialized\n  * `Pow.Store.Base` behaviour now requires to;\n    * Accept erlang term value for keys in all methods\n    * Implement `put/3` instead of `put/4`\n    * Implement `delete/2` instead of `put/3`\n    * Implement `get/2` instead of `put/3`\n    * Remove `keys/2`\n  * `Pow.Store.Base.all/3` added\n  * `Pow.Store.Base.put/3` added\n  * `Pow.Store.Base` will use binary key rather than key list if `all/2` doesn't exist in the backend cache\n  * Added `Pow.Store.CredentialsCache.users/2`\n  * Added `Pow.Store.CredentialsCache.sessions/2`\n  * `Pow.Store.CredentialsCache` now adds a session key rather than appending to a list for the user key to prevent race condition\n* `Pow.Plug.Session.create/3` now stores a keyword list with metadata for the session rather than just a timestamp\n* `Pow.Plug.Session.fetch/2` and `Pow.Plug.Session.create/3` now assigns `:pow_session_metadata` in `conn.private` with the session metadata\n* `Pow.Plug.Session.create/3` will use the metadata found in `conn.private[:pow_session_metadata]` if it exists and otherwise add a randomly unique id for `:fingerprint`\n* `PowPersistentSession.Plug.Cookie.create/3` will use the value of `conn.private[:pow_session_metadata][:fingerprint]` if it exists as `:session_fingerprint` in the persistent session metadata\n* `PowPersistentSession.Plug.Cookie.authenticate/2` will assign `:fingerprint` to `conn.private[:pow_session_metadata]` if it exists in the persistent session metadata\n* `Pow.Store.CredentialsCache.put/3` will invalidate any other sessions with the same `:fingerprint` if any is set in session metadata\n* `PowResetPassword.Phoenix.ResetPasswordController.create/2` when a user doesn't exist will now only return success message if the registration routes has been disabled, otherwise the form with an error message will be returned\n* Added `PowResetPassword.Phoenix.Messages.user_not_found/1`\n\n### Bug fixes\n\n* Fixed bug where `Pow.Store.CredentialsCache` wasn't used due to how `Pow.Store.Base` macro worked\n* Fixed bug where `PowEmailConfirmation.Phoenix.ControllerCallbacks` couldn't deliver email\n\n### Deprecations\n\n* Deprecated `Pow.Store.Backend.EtsCache.keys/1`\n* Deprecated `Pow.Store.Backend.EtsCache.put/3`\n* Deprecated `Pow.Store.Backend.MnesiaCache.keys/1`\n* Deprecated `Pow.Store.Backend.MnesiaCache.put/3`\n* Deprecated `Pow.Store.Base.keys/2`\n* Deprecated `Pow.Store.Base.put/4`\n* Deprecated `Pow.Store.CredentialsCache.user_session_keys/3`\n* Deprecated `Pow.Store.CredentialsCache.sessions/3`\n\n## v1.0.13 (2019-08-25)\n\n* Updated `PowEmailConfirmation.Ecto.Schema.changeset/3` so;\n  * when `:email` is identical to `:unconfirmed_email` it won't generate new `:email_confirmation_token`\n  * when `:email` is identical to the persisted `:email` value both `:email_confirmation_token` and `:unconfirmed_email` will be set to `nil`\n  * when there is no `:email` value in the params nothing happens\n* Updated `PowEmailConfirmation.Ecto.Schema.confirm_email_changeset/1` so now `:email_confirmation_token` is set to `nil`\n* Updated `Pow.Ecto.Schema.Changeset.user_id_field_changeset/3` so the e-mail validator now accepts unicode e-mails\n* Added `PowEmailConfirmation.Ecto.Context.current_email_unconfirmed?/2` and `PowEmailConfirmation.Plug.pending_email_change?/1`\n* Added `:email_validator` configuration option to `Pow.Ecto.Schema.Changeset`\n* Added `Pow.Ecto.Schema.Changeset.validate_email/1`\n* Fixed bug in `PowEmailConfirmation.Phoenix.ControllerCallbacks.send_confirmation_email/2` where the confirmation e-mail wasn't send to the updated e-mail address\n\n## v1.0.12 (2019-08-16)\n\n* Added API integration guide\n* Added `:reset_password_token_store` configuration setting\n* To prevent timing attacks, `Pow.Ecto.Context.authenticate/2` now verifies password on a blank user struct when no user can be found for the provided user id, but will always return nil. The blank user struct has a nil `:password_hash` value. The struct will be passed along with a blank password to the `verify_password/2` method in the user schema module.\n* To prevent timing attacks, when `Pow.Ecto.Schema.Changeset.verify_password/3` receives a struct with a nil `:password_hash` value, it'll hash a blank password, but always return false.\n* To prevent timing attacks, the UUID is always generated in `PowResetPassword.Plug.create_reset_token/2` whether the user exists or not.\n* `PowPersistentSession.Plug.Base` now accepts `:persistent_session_ttl` which will pass the TTL to the cache backend and used for the max age of the sesion cookie in `PowPersistentSession.Plug.Cookie`\n* Deprecated `:persistent_session_cookie_max_age` configuration setting\n* `Pow.Store.Backend.MnesiaCache` can now auto join clusters\n* `Pow.Store.Backend.MnesiaCache.Unsplit` module added for self-healing after network split\n* Removed `:nodes` config option for `Pow.Store.Backend.MnesiaCache`\n\n## v1.0.11 (2019-06-13)\n\n* Fixed bug in router filters with Phoenix 1.4.7\n\n## v1.0.10 (2019-06-09)\n\n* Prevent browser cache of `Pow.Phoenix.SessionController.new/2`, `Pow.Phoenix.RegistrationController.new/2` and `PowInvitation.Phoenix.InvitationController.edit/2` by setting \"Cache-Control\" header unless it already has been customized\n* All links in docs generated with `mix docs` and on [hexdocs.pm](http://hexdocs.pm/pow/) now works\n* Generated docs now uses lower case file name except for `README`, `CONTRIBUTING` and `CHANGELOG`\n* Removed duplicate call for `Pow.Plug.Session.delete/2` in `Pow.Plug.Sesssion.create/3`\n\n## v1.0.9 (2019-06-04)\n\n### Changes\n\n* `Pow.Phoenix.Router` will now only add specific routes if there is no matching route already defined\n* Added `Pow.Plug.get_plug/1` and instead of `:mod`, `:plug` is used in config\n* `Pow.Ecto.Context.authenticate/2` now returns nil if user id or password is nil\n\n### Bug fixes\n\n* Fixed bug with exception raised in `Pow.Ecto.Schema.normalize_user_id_field_value/1` when calling `Pow.Ecto.Context.get_by/2` with a non binary user id\n* Fixed bug with exception raised in `Pow.Ecto.Schema.normalize_user_id_field_value/1` when calling `Pow.Ecto.Context.authenticate/2` with a non binary user id\n\n### Deprecations\n\n* Deprecated `Pow.Plug.get_mod/1`\n* Removed call to `Pow.Ecto.Context.repo/1`\n\n## v1.0.8 (2019-05-24)\n\n### Changes\n\n* Added support for layout in mails with `Pow.Phoenix.Mailer.Mail` by setting `conn.private[:pow_mailer_layout]` same way as the Phoenix layout with `conn.private[:phoenix_layout]`\n* Added `:prefix` repo opts support to use in multitenant apps\n* Removed `@changeset.data.__struct__.pow_user_id_field()` in template in favor of using `Pow.Ecto.Schema.user_id_field/1`\n\n### Bug fixes\n\n* Fixed bug in `Pow.Ecto.Schema.Changeset.current_password_changeset/3` where an exception would be thrown if the virtual `:current_password` field of the user struct was set and either the `:current_password` change was blank or identical\n\n### Deprecations\n\n* Deprecated `Mix.Pow.Ecto.Migration.create_migration_files/3` and moved it to `Mix.Pow.Ecto.Migration.create_migration_file/3`\n* Deprecated `Pow.Ecto.Context.repo/1` and moved it to `Pow.Config.repo!/1`\n* Deprecated `Pow.Ecto.Context.user_schema_mod/1` and moved it to `Pow.Config.user!/1`\n\n## v1.0.7 (2019-05-01)\n\n* Fixed bug with Phoenix 1.4.4 scoped routes\n\n## v1.0.6 (2019-04-19)\n\n* Fixed bug where custom layout setting raised exception in `Pow.Phoenix.ViewHelpers.layout/1`\n* Prevent users from changing their email to one already taken when the PowEmailConfirmation extension has been enabled\n\n## v1.0.5 (2019-04-09)\n\n* Added `extension_messages/1` to extension controllers and callbacks\n* Improved feedback for when no templates are generated for an extension with `mix pow.extension.phoenix.gen.templates` and `mix pow.extension.phoenix.mailer.gen.templates` tasks\n* Error flash is no longer overridden in `Pow.Phoenix.PlugErrorHandler` if the error message is nil\n* Fixed bug in the migration generator where `references/2` wasn't called with options\n* Support any `:plug` version below `2.0.0`\n* Deprecated `Pow.Extension.Ecto.Context.Base`\n\n## v1.0.4 (2019-03-13)\n\n* Added `PowInvitation` to the `mix pow.extension.phoenix.gen.templates` and `mix pow.extension.phoenix.mailer.gen.templates` tasks\n* Fixed issue in umbrella projects where extensions wasn't found in environment configuration\n* Fixed so `:namespace` environment config can be used as web app module name\n* Shell instructions will only be printed if the configuration is missing\n* Now requires that `:ecto` or `:phoenix` are included in the dependency list for the app to run respective mix tasks\n* Deprecated `Mix.Pow.context_app/0`\n* Deprecated `Mix.Pow.ensure_dep!/3`\n* Deprecated `Mix.Pow.context_base/1`\n\n## v1.0.3 (2019-03-09)\n\n### Changes\n\n* Added `PowInvitation` extension\n* Added support in `Pow.Ecto.Schema` for Ecto associations fields\n* Added support for adding custom methods with `Pow.Extension.Ecto.Schema` through `__using__/1` macro in extension ecto schema module\n* Help information raised with invalid schema arguments for `pow.install`, `pow.ecto.install`, `pow.ecto.gen.migration`, and `pow.ecto.gen.schema` mix tasks\n* `PowEmailConfirmation` now redirects unconfirmed users to `after_registration_path/1` or `after_sign_in_path/1` rather than `pow_session_path(conn, :new)`\n\n### Bug fixes\n\n* Correct shell instructions for `mix pow.install` task with custom schema\n* Fixed bug in `Pow.Extension.Phoenix.Router.Base` and `Pow.Extension.Phoenix.Messages` where the full extension name wasn't used to namespace methods\n\n### Deprecations\n\n* Deprecated `Pow.Extension.Config.underscore_extension/1`\n* Deprecated `PowResetPassword.Ecto.Context.password_changeset/2`\n* Deprecated `Pow.Ecto.Schema.filter_new_fields/2`\n* Deprecated `:messages_backend_fallback` setting for extension controllers\n* Removed deprecated macro `router_helpers/1` in `Pow.Phoenix.Controller`\n\n## v1.0.2 (2019-02-28)\n\n* Added flash error message about e-mail confirmation for when user changes e-mail with PowEmailConfirmation enabled\n* Added `new_password_changeset/3` and `confirm_password_changeset/3` to `Pow.Ecto.Schema.Changeset`\n* Redis cache store backend guide\n* Correct shell instructions for `mix pow.phoenix.gen.templates` task\n* Only load environment config in `Pow.Config.get/3` when no key is set in the provided config\n* Fixed issue in `Pow.Store.Backend.MnesiaCache.keys/1` and `Pow.Store.Backend.EtsCache.keys/1` so they now return keys without namespace\n* `Pow.Store.Backend.MnesiaCache.put/3` now raises an error if TTL is not provided\n\n### Breaking changes\n\n* `PowResetPassword.Plug.reset_password_token/1` has been removed\n\n## v1.0.1 (2019-01-27)\n\n* `pow.extension.ecto.gen.migrations` mix task will output warning when a migration file won't be generated for any particular extension\n* Leading and trailing whitespace is removed from the user id field value (in addition to forced lower case)\n* An exception is raised when `pow_routes/0` or `pow_extension_routes/0` are used inside router scopes with aliases\n* Mail view templates assigns now has `[user: user, conn: conn]` along with the template specific assigns\n* Mail view subject methods now gets the same assigns passed as mail view template assigns instead of only `[conn: conn]`\n* Added `pow_registration_routes/0`, `pow_session_routes/0` and `pow_scope/1` macros to the router module\n* Added guide on how to disable registration\n\n## v1.0.0 (2018-11-18)\n\n* Phoenix 1.4 support\n* Ecto 3.0 support\n", "defmodule Pow.Plug.Session do\n  @moduledoc \"\"\"\n  This plug will handle user authorization using session.\n\n  The plug will store user and session metadata in the cache store backend. The\n  session metadata has at least an `:inserted_at` and a `:fingerprint` key. The\n  `:inserted_at` value is used to determine if the session has to be renewed,\n  and is set each time a session is created. The `:fingerprint` will be a random\n  unique id and will stay the same if a session is renewed.\n\n  When a session is renewed the old session is deleted and a new created.\n\n  You can add additional metadata to sessions by setting or updated the\n  assigned private `:pow_session_metadata` key in the conn. The value has to be\n  a keyword list.\n\n  ## Example\n\n      plug Plug.Session,\n        store: :cookie,\n        key: \"_my_app_demo_key\",\n        signing_salt: \"secret\"\n\n      plug Pow.Plug.Session,\n        repo: MyApp.Repo,\n        user: MyApp.User,\n        current_user_assigns_key: :current_user,\n        session_key: \"auth\",\n        session_store: {Pow.Store.CredentialsCache,\n                        ttl: :timer.minutes(30),\n                        namespace: \"credentials\"},\n        session_ttl_renewal: :timer.minutes(15),\n        cache_store_backend: Pow.Store.Backend.EtsCache,\n        users_context: Pow.Ecto.Users\n\n  ## Configuration options\n\n    * `:session_key` - session key name, defaults to \"auth\". If `:otp_app` is\n      used it'll automatically prepend the key with the `:otp_app` value.\n\n    * `:session_store` - the credentials cache store. This value defaults to\n      `{Pow.Store.CredentialsCache, backend: Pow.Store.Backend.EtsCache}`. The\n      `Pow.Store.Backend.EtsCache` backend store can be changed with the\n      `:cache_store_backend` option.\n\n    * `:cache_store_backend` - the backend cache store. This value defaults to\n      `Pow.Store.Backend.EtsCache`.\n\n    * `:session_ttl_renewal` - the ttl in milliseconds to trigger renewal of\n      sessions. Defaults to 15 minutes in miliseconds.\n\n  ## Custom metadata\n\n  The assigned private `:pow_session_metadata` key in the conn can be populated\n  with custom metadata. This data will be stored in the session metadata when\n  the session is created, and fetched in subsequent requests.\n\n  Here's an example of how one could add sign in timestamp, IP, and user agent\n  information to the session metadata:\n\n      def append_to_session_metadata(conn) do\n        client_ip  = to_string(:inet_parse.ntoa(conn.remote_ip))\n        user_agent = get_req_header(conn, \"user-agent\")\n\n        metadata =\n          conn.private\n          |> Map.get(:pow_session_metadata, [])\n          |> Keyword.put_new(:first_seen_at, DateTime.utc_now())\n          |> Keyword.put(:ip, client_ip)\n          |> Keyword.put(:user_agent, user_agent)\n\n        Plug.Conn.put_private(conn, :pow_session_metadata, metadata)\n      end\n\n  The `:first_seen_at` will only be set if it doesn't already exist in the\n  session metadata, while `:ip` and `:user_agent` will be updated each time the\n  session is created.\n\n  The method should be called after `Pow.Plug.Session.call/2` has been called\n  to ensure that the metadata, if any, has been fetched.\n\n  ## Session expiration\n\n  `Pow.Store.CredentialsCache` will, by default, invalidate any session token\n  30 minutes after it has been generated. To keep sessions alive the\n  `:session_ttl_renewal` option is used to determine when a session token\n  becomes stale and a new session ID has to be generated for the user (deleting\n  the previous one in the process).\n\n  If `:session_ttl_renewal` is set to zero, a new session token will be\n  generated on every request.\n\n  To change the amount of time a session can be alive, both the TTL for\n  `Pow.Store.CredentialsCache` and `:session_ttl_renewal` option should be\n  changed:\n\n      plug Pow.Plug.Session, otp_app: :my_app,\n        session_ttl_renewal: :timer.minutes(1),\n        session_store: {Pow.Store.CredentialsCache, ttl: :timer.minutes(15)}\n\n  In the above, a new session token will be generated when a request occurs\n  more than a minute after the current session token was generated. The\n  session is invalidated if there is no request for the next 14 minutes.\n\n  There are no absolute session timeout; sessions can be kept alive\n  indefinitely.\n  \"\"\"\n  use Pow.Plug.Base\n\n  alias Plug.Conn\n  alias Pow.{Config, Plug, Store.Backend.EtsCache, Store.CredentialsCache, UUID}\n\n  @session_key \"auth\"\n  @session_ttl_renewal :timer.minutes(15)\n\n  @doc \"\"\"\n  Fetches session from credentials cache.\n\n  This will fetch a session from the credentials cache with the session id\n  fetched through `Plug.Conn.get_session/2` session. If the credentials are\n  stale (timestamp is older than the `:session_ttl_renewal` value), the session\n  will be regenerated with `create/3`.\n\n  The metadata of the session will be assigned as a private\n  `:pow_session_metadata` key in the conn so it may be used in `create/3`.\n\n  See `do_fetch/2` for more.\n  \"\"\"\n  @impl true\n  @spec fetch(Conn.t(), Config.t()) :: {Conn.t(), map() | nil}\n  def fetch(conn, config) do\n    {store, store_config} = store(config)\n    conn                  = Conn.fetch_session(conn)\n    key                   = Conn.get_session(conn, session_key(config))\n\n    {key, store.get(store_config, key)}\n    |> convert_old_session_value()\n    |> handle_fetched_session_value(conn, config)\n  end\n\n  @doc \"\"\"\n  Create new session with a randomly generated unique session id.\n\n  This will store the unique session id with user credentials in the\n  credentials cache. The session id will be stored in the connection with\n  `Plug.Conn.put_session/3`. Any existing sessions will be deleted first with\n  `delete/2`.\n\n  The unique session id will be prepended by the `:otp_app` configuration\n  value, if present.\n\n  If an assigned private `:pow_session_metadata` key exists in the conn, it'll\n  be passed on as the metadata for the session. However the `:inserted_at` value\n  will always be overridden. If no `:fingerprint` exists in the metadata a\n  random UUID value will be generated as its value.\n\n  See `do_create/3` for more.\n  \"\"\"\n  @impl true\n  @spec create(Conn.t(), map(), Config.t()) :: {Conn.t(), map()}\n  def create(conn, user, config) do\n    conn                  = Conn.fetch_session(conn)\n    {store, store_config} = store(config)\n    metadata              = Map.get(conn.private, :pow_session_metadata, [])\n    {user, metadata}      = session_value(user, metadata)\n    key                   = session_id(config)\n    session_key           = session_key(config)\n\n    store.put(store_config, key, {user, metadata})\n\n    conn =\n      conn\n      |> delete(config)\n      |> Conn.put_private(:pow_session_metadata, metadata)\n      |> Conn.put_session(session_key, key)\n      |> Conn.configure_session(renew: true)\n\n    {conn, user}\n  end\n\n  defp session_value(user, metadata) do\n    metadata =\n      metadata\n      |> Keyword.put_new(:fingerprint, UUID.generate())\n      |> Keyword.put(:inserted_at, timestamp())\n\n    {user, metadata}\n  end\n\n  @doc \"\"\"\n  Delete an existing session in the credentials cache.\n\n  This will delete a session in the credentials cache with the session id\n  fetched through `Plug.Conn.get_session/2`. The session in the connection is\n  deleted too with `Plug.Conn.delete_session/2`.\n\n  See `do_delete/2` for more.\n  \"\"\"\n  @impl true\n  @spec delete(Conn.t(), Config.t()) :: Conn.t()\n  def delete(conn, config) do\n    conn                  = Conn.fetch_session(conn)\n    key                   = Conn.get_session(conn, session_key(config))\n    {store, store_config} = store(config)\n    session_key           = session_key(config)\n\n    store.delete(store_config, key)\n\n    Conn.delete_session(conn, session_key)\n  end\n\n  # TODO: Remove by 1.1.0\n  defp convert_old_session_value({key, {user, timestamp}}) when is_number(timestamp), do: {key, {user, inserted_at: timestamp}}\n  defp convert_old_session_value(any), do: any\n\n  defp handle_fetched_session_value({_key, :not_found}, conn, _config), do: {conn, nil}\n  defp handle_fetched_session_value({_key, {user, metadata}}, conn, config) when is_list(metadata) do\n    conn\n    |> Conn.put_private(:pow_session_metadata, metadata)\n    |> renew_stale_session(user, metadata, config)\n  end\n\n  defp renew_stale_session(conn, user, metadata, config) do\n    metadata\n    |> Keyword.get(:inserted_at)\n    |> session_stale?(config)\n    |> case do\n      true  -> create(conn, user, config)\n      false -> {conn, user}\n    end\n  end\n\n  defp session_stale?(inserted_at, config) do\n    ttl = Config.get(config, :session_ttl_renewal, @session_ttl_renewal)\n    session_stale?(inserted_at, config, ttl)\n  end\n  defp session_stale?(_inserted_at, _config, nil), do: false\n  defp session_stale?(inserted_at, _config, ttl) do\n    inserted_at + ttl < timestamp()\n  end\n\n  defp session_id(config) do\n    uuid = UUID.generate()\n\n    Plug.prepend_with_namespace(config, uuid)\n  end\n\n  defp session_key(config) do\n    Config.get(config, :session_key, default_session_key(config))\n  end\n\n  defp default_session_key(config) do\n    Plug.prepend_with_namespace(config, @session_key)\n  end\n\n  defp store(config) do\n    case Config.get(config, :session_store, default_store(config)) do\n      {store, store_config} -> {store, store_config}\n      store                 -> {store, []}\n    end\n  end\n\n  defp default_store(config) do\n    backend = Config.get(config, :cache_store_backend, EtsCache)\n\n    {CredentialsCache, [backend: backend]}\n  end\n\n  defp timestamp, do: :os.system_time(:millisecond)\nend\n", "defmodule Pow.Plug.SessionTest do\n  use ExUnit.Case\n  doctest Pow.Plug.Session\n\n  alias Plug.{Conn, Test}\n  alias Pow.{Plug, Plug.Session, Store.Backend.EtsCache, Store.CredentialsCache}\n  alias Pow.Test.{ConnHelpers, Ecto.Users.User, EtsCacheMock}\n\n  @default_opts [\n    current_user_assigns_key: :current_user,\n    session_key: \"auth\",\n    cache_store_backend: EtsCacheMock\n  ]\n  @store_config [backend: EtsCacheMock]\n  @user %User{id: 1}\n\n  setup do\n    EtsCacheMock.init()\n\n    conn =\n      :get\n      |> ConnHelpers.conn(\"/\")\n      |> ConnHelpers.init_session()\n\n    {:ok, %{conn: conn}}\n  end\n\n  test \"call/2 sets plug in :pow_config\", %{conn: conn} do\n    opts = Session.init(@default_opts)\n    conn = Session.call(conn, opts)\n    expected_config = [mod: Session, plug: Session] ++ @default_opts\n\n    assert is_nil(conn.assigns[:current_user])\n    assert conn.private[:pow_config] == expected_config\n  end\n\n  test \"call/2 with assigned current_user\", %{conn: conn} do\n    opts = Session.init(@default_opts)\n    conn =\n      conn\n      |> Plug.assign_current_user(\"assigned\", @default_opts)\n      |> Session.call(opts)\n\n    assert conn.assigns[:current_user] == \"assigned\"\n  end\n\n  test \"call/2 with stored current_user\", %{conn: conn} do\n    CredentialsCache.put(@store_config, \"token\", {@user, inserted_at: :os.system_time(:millisecond), fingerprint: \"fingerprint\"})\n\n    opts = Session.init(@default_opts)\n    conn =\n      conn\n      |> Conn.fetch_session()\n      |> Conn.put_session(@default_opts[:session_key], \"token\")\n      |> Session.call(opts)\n\n    assert conn.assigns[:current_user] == @user\n    assert conn.private[:pow_session_metadata][:fingerprint] == \"fingerprint\"\n  end\n\n  test \"call/2 with stored session and custom metadata\", %{conn: conn} do\n    inserted_at = :os.system_time(:millisecond)\n    CredentialsCache.put(@store_config, \"token\", {@user, inserted_at: inserted_at, a: 1})\n\n    opts = Session.init(@default_opts)\n    conn =\n      conn\n      |> Conn.put_private(:pow_session_metadata, b: 2)\n      |> Conn.fetch_session()\n      |> Conn.put_session(@default_opts[:session_key], \"token\")\n      |> Session.call(opts)\n\n    assert conn.assigns[:current_user] == @user\n    assert conn.private[:pow_session_metadata][:inserted_at] == inserted_at\n    assert conn.private[:pow_session_metadata][:a] == 1\n  end\n\n  test \"call/2 with non existing cached key\", %{conn: conn} do\n    CredentialsCache.put(@store_config, \"token\", {@user, inserted_at: :os.system_time(:millisecond)})\n\n    opts = Session.init(@default_opts)\n    conn =\n      conn\n      |> Conn.fetch_session()\n      |> Conn.put_session(@default_opts[:session_key], \"invalid\")\n      |> Session.call(opts)\n\n    assert is_nil(conn.assigns[:current_user])\n  end\n\n  test \"call/2 creates new session when :session_renewal_ttl reached\", %{conn: conn} do\n    ttl             = 100\n    config          = Keyword.put(@default_opts, :session_ttl_renewal, ttl)\n    timestamp       = :os.system_time(:millisecond)\n    stale_timestamp = timestamp - ttl - 1\n    init_conn       =\n      conn\n      |> Conn.fetch_session()\n      |> Conn.put_session(config[:session_key], \"token\")\n\n    CredentialsCache.put(@store_config, \"token\", {@user, inserted_at: timestamp, fingerprint: \"fingerprint\"})\n\n    opts = Session.init(config)\n    conn = Session.call(init_conn, opts)\n    session_id = get_session_id(conn)\n\n    assert conn.assigns[:current_user] == @user\n\n    CredentialsCache.put(@store_config, \"token\", {@user, inserted_at: stale_timestamp, fingerprint: \"fingerprint\"})\n    CredentialsCache.put(@store_config, \"newer_token\", {@user, inserted_at: timestamp, fingerprint: \"new_fingerprint\"})\n\n    conn = Session.call(init_conn, opts)\n\n    assert conn.assigns[:current_user] == @user\n    assert new_session_id = get_session_id(conn)\n    assert new_session_id != session_id\n    assert {_user, metadata} = CredentialsCache.get(@store_config, new_session_id)\n    assert metadata[:inserted_at] != stale_timestamp\n    assert metadata[:fingerprint] == \"fingerprint\"\n    assert conn.private[:pow_session_metadata][:fingerprint] == \"fingerprint\"\n  end\n\n  test \"call/2 with prepended `:otp_app` session key\", %{conn: conn} do\n    CredentialsCache.put(@store_config, \"token\", {@user, inserted_at: :os.system_time(:millisecond)})\n\n    opts =\n      @default_opts\n      |> Keyword.delete(:session_key)\n      |> Keyword.put(:otp_app, :test_app)\n      |> Session.init()\n    conn =\n      conn\n      |> Conn.fetch_session()\n      |> Conn.put_session(\"test_app_auth\", \"token\")\n      |> Session.call(opts)\n\n    assert conn.assigns[:current_user] == @user\n  end\n\n  # TODO: Remove by 1.1.0\n  test \"backwards compatible\", %{conn: conn} do\n    ttl             = 100\n    config          = Keyword.put(@default_opts, :session_ttl_renewal, ttl)\n    stale_timestamp = :os.system_time(:millisecond) - ttl - 1\n\n    @store_config\n    |> Keyword.put(:namespace, \"credentials\")\n    |> EtsCacheMock.put({\"token\", {@user, stale_timestamp}})\n\n    opts = Session.init(config)\n    conn =\n      conn\n      |> Conn.fetch_session()\n      |> Conn.put_session(config[:session_key], \"token\")\n      |> Session.call(opts)\n\n    assert new_session_id = get_session_id(conn)\n    assert new_session_id != \"token\"\n\n    assert conn.assigns[:current_user] == @user\n  end\n\n  describe \"create/2\" do\n    test \"creates new session id\", %{conn: conn} do\n      opts = Session.init(@default_opts)\n      conn =\n        conn\n        |> Session.call(opts)\n        |> Session.do_create(@user, opts)\n\n      session_id = get_session_id(conn)\n\n      assert {@user, metadata} = CredentialsCache.get(@store_config, session_id)\n      assert is_binary(session_id)\n      assert Plug.current_user(conn) == @user\n      assert metadata[:inserted_at]\n      assert metadata[:fingerprint]\n\n      conn = Session.do_create(conn, @user, opts)\n      new_session_id = get_session_id(conn)\n\n      assert {@user, new_metadata} = CredentialsCache.get(@store_config, new_session_id)\n      assert is_binary(session_id)\n      assert new_session_id != session_id\n      assert CredentialsCache.get(@store_config, session_id) == :not_found\n      assert Plug.current_user(conn) == @user\n      assert metadata[:fingerprint] == new_metadata[:fingerprint]\n    end\n\n    test \"renews plug session\", %{conn: new_conn} do\n      opts = Session.init(@default_opts)\n      conn =\n        new_conn\n        |> Session.call(opts)\n        |> Session.do_create(@user, opts)\n        |> Conn.send_resp(200, \"\")\n\n      assert %{\"foobar\" => %{value: plug_session_id}} = conn.resp_cookies\n\n      conn =\n        new_conn\n        |> Test.recycle_cookies(conn)\n        |> Session.call(opts)\n        |> Session.do_create(@user, opts)\n        |> Conn.send_resp(200, \"\")\n\n      assert %{\"foobar\" => %{value: new_plug_session_id}} = conn.resp_cookies\n\n      refute plug_session_id == new_plug_session_id\n    end\n\n    test \"creates with custom metadata\", %{conn: conn} do\n      inserted_at = :os.system_time(:millisecond) - 10\n      opts = Session.init(@default_opts)\n      conn =\n        conn\n        |> Conn.put_private(:pow_session_metadata, inserted_at: inserted_at, a: 1)\n        |> Session.call(opts)\n        |> Session.do_create(@user, opts)\n\n      assert conn.assigns[:current_user] == @user\n      assert conn.private[:pow_session_metadata][:inserted_at] != inserted_at\n      assert conn.private[:pow_session_metadata][:fingerprint]\n      assert conn.private[:pow_session_metadata][:a] == 1\n    end\n\n    test \"creates new session id with `:otp_app` prepended\", %{conn: conn} do\n      opts =\n        @default_opts\n        |> Keyword.delete(:session_key)\n        |> Keyword.put(:otp_app, :test_app)\n        |> Session.init()\n      conn =\n        conn\n        |> Session.call(opts)\n        |> Session.do_create(@user, opts)\n\n      refute get_session_id(conn)\n\n      session_id = conn.private[:plug_session][\"test_app_auth\"]\n      assert String.starts_with?(session_id, \"test_app_\")\n    end\n  end\n\n  test \"delete/1 removes session id\", %{conn: conn} do\n    opts = Session.init(@default_opts)\n    conn =\n      conn\n      |> Session.call(opts)\n      |> Session.do_create(@user, opts)\n\n    session_id = get_session_id(conn)\n\n    assert {@user, _metadata} = CredentialsCache.get(@store_config, session_id)\n    assert is_binary(session_id)\n    assert Plug.current_user(conn) == @user\n\n    conn = Session.do_delete(conn, opts)\n\n    refute new_session_id = get_session_id(conn)\n    assert is_nil(new_session_id)\n    assert CredentialsCache.get(@store_config, session_id) == :not_found\n    assert is_nil(Plug.current_user(conn))\n  end\n\n  describe \"with EtsCache backend\" do\n    setup do\n      start_supervised!({EtsCache, []})\n\n      :ok\n    end\n\n    test \"call/2\", %{conn: conn} do\n      sesion_key = \"auth\"\n      config     = [session_key: sesion_key]\n      token      = \"credentials_cache_test\"\n      timestamp  = :os.system_time(:millisecond)\n      CredentialsCache.put(config, token, {@user, inserted_at: timestamp})\n\n      :timer.sleep(100)\n\n      opts = Session.init(session_key: \"auth\")\n      conn =\n        conn\n        |> Conn.fetch_session()\n        |> Conn.put_session(\"auth\", token)\n        |> Session.call(opts)\n\n      assert conn.assigns[:current_user] == @user\n    end\n  end\n\n  def get_session_id(conn) do\n    conn.private[:plug_session][@default_opts[:session_key]]\n  end\nend\n"], "filenames": ["CHANGELOG.md", "lib/pow/plug/session.ex", "test/pow/plug/session_test.exs"], "buggy_code_start_loc": [3, 175, 5], "buggy_code_end_loc": [11, 175, 189], "fixing_code_start_loc": [4, 176, 5], "fixing_code_end_loc": [15, 177, 212], "type": "CWE-384", "message": "In Pow (Hex package) before 1.0.16, the use of Plug.Session in Pow.Plug.Session is susceptible to session fixation attacks if a persistent session store is used for Plug.Session, such as Redis or a database. Cookie store, which is used in most Phoenix apps, doesn't have this vulnerability.", "other": {"cve": {"id": "CVE-2020-5205", "sourceIdentifier": "security-advisories@github.com", "published": "2020-01-09T02:15:13.340", "lastModified": "2020-01-17T14:45:00.757", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Pow (Hex package) before 1.0.16, the use of Plug.Session in Pow.Plug.Session is susceptible to session fixation attacks if a persistent session store is used for Plug.Session, such as Redis or a database. Cookie store, which is used in most Phoenix apps, doesn't have this vulnerability."}, {"lang": "es", "value": "En Pow (paquete Hex) versiones anteriores a 1.0.16, el uso de Plug.Session en Pow.Plug.Session es susceptible a ataques de fijaci\u00f3n de sesi\u00f3n si un almac\u00e9n de sesi\u00f3n persistente es utilizado para Plug.Session, tal y como Redis o una base de datos. La tienda de cookies, que es usada en la mayor\u00eda de las aplicaciones de Phoenix, no posee esta vulnerabilidad."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.5}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:C/C:H/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.3, "impactScore": 4.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-384"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-384"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:powauth:pow:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.0.16", "matchCriteriaId": "9CF220C0-67AC-42E8-AF68-58AD6E44BD2B"}]}]}], "references": [{"url": "https://github.com/danschultzer/pow/blob/master/CHANGELOG.md#v1016-2020-01-07", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/danschultzer/pow/commit/578ffd3d8bb8e8a26077b644222186b108da474f", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/danschultzer/pow/security/advisories/GHSA-v2wf-c3j6-wpvw", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/danschultzer/pow/commit/578ffd3d8bb8e8a26077b644222186b108da474f"}}