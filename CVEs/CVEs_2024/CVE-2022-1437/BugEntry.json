{"buggy_code": ["/* radare - LGPL - Copyright 2020 - mrmacete */\n\n#include <r_types.h>\n#include <r_util.h>\n#include <r_hash.h>\n#include \"coresymbolication.h\"\n\n#define R_CS_EL_OFF_SEGS 0x58\n#define R_CS_EL_SIZE_SEG 0x20\n#define R_CS_EL_SIZE_SECT_64 0x18\n#define R_CS_EL_SIZE_SECT_32 0x10\n#define R_CS_EL_SIZE_SYM 0x18\n#define R_CS_EL_SIZE_LSYM 0x24\n#define R_CS_EL_SIZE_LINFO 0x14\n\nstatic RCoreSymCacheElementHdr *r_coresym_cache_element_header_new(RBuffer *buf, size_t off, int bits) {\n\tRCoreSymCacheElementHdr *hdr = R_NEW0 (RCoreSymCacheElementHdr);\n\tif (hdr && r_buf_fread_at (buf, off, (ut8 *)hdr, \"13i16c5i\", 1) == sizeof (RCoreSymCacheElementHdr)) {\n\t\treturn hdr;\n\t}\n\tfree (hdr);\n\treturn NULL;\n}\n\nstatic void r_coresym_cache_element_segment_fini(RCoreSymCacheElementSegment *seg) {\n\tif (seg) {\n\t\tfree (seg->name);\n\t}\n}\n\nstatic void r_coresym_cache_element_section_fini(RCoreSymCacheElementSection *sec) {\n\tif (sec) {\n\t\tfree (sec->name);\n\t}\n}\n\nstatic void r_coresym_cache_element_flc_fini(RCoreSymCacheElementFLC *flc) {\n\tif (flc) {\n\t\tfree (flc->file);\n\t}\n}\n\nstatic void r_coresym_cache_element_symbol_fini(RCoreSymCacheElementSymbol *sym) {\n\tif (sym) {\n\t\tfree (sym->name);\n\t\tfree (sym->mangled_name);\n\t}\n}\n\nstatic void r_coresym_cache_element_lined_symbol_fini(RCoreSymCacheElementLinedSymbol *sym) {\n\tif (sym) {\n\t\tr_coresym_cache_element_symbol_fini (&sym->sym);\n\t\tr_coresym_cache_element_flc_fini (&sym->flc);\n\t}\n}\n\nstatic void r_coresym_cache_element_line_info_fini(RCoreSymCacheElementLineInfo *line) {\n\tif (line) {\n\t\tr_coresym_cache_element_flc_fini (&line->flc);\n\t}\n}\n\nvoid r_coresym_cache_element_free(RCoreSymCacheElement *element) {\n\tif (!element) {\n\t\treturn;\n\t}\n\tsize_t i;\n\tif (element->segments) {\n\t\tfor (i = 0; i < element->hdr->n_segments; i++) {\n\t\t\tr_coresym_cache_element_segment_fini (&element->segments[i]);\n\t\t}\n\t}\n\tif (element->sections) {\n\t\tfor (i = 0; i < element->hdr->n_sections; i++) {\n\t\t\tr_coresym_cache_element_section_fini (&element->sections[i]);\n\t\t}\n\t}\n\tif (element->symbols) {\n\t\tfor (i = 0; i < element->hdr->n_symbols; i++) {\n\t\t\tr_coresym_cache_element_symbol_fini (&element->symbols[i]);\n\t\t}\n\t}\n\tif (element->lined_symbols) {\n\t\tfor (i = 0; i < element->hdr->n_lined_symbols; i++) {\n\t\t\tr_coresym_cache_element_lined_symbol_fini (&element->lined_symbols[i]);\n\t\t}\n\t}\n\tif (element->line_info) {\n\t\tfor (i = 0; i < element->hdr->n_line_info; i++) {\n\t\t\tr_coresym_cache_element_line_info_fini (&element->line_info[i]);\n\t\t}\n\t}\n\tfree (element->segments);\n\tfree (element->sections);\n\tfree (element->symbols);\n\tfree (element->lined_symbols);\n\tfree (element->line_info);\n\tfree (element->hdr);\n\tfree (element->file_name);\n\tfree (element->binary_version);\n\tfree (element);\n}\n\nut64 r_coresym_cache_element_pa2va(RCoreSymCacheElement *element, ut64 pa) {\n\tsize_t i;\n\tfor (i = 0; i < element->hdr->n_segments; i++) {\n\t\tRCoreSymCacheElementSegment *seg = &element->segments[i];\n\t\tif (seg->size == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (seg->paddr < pa && pa < seg->paddr + seg->size) {\n\t\t\treturn pa - seg->paddr + seg->vaddr;\n\t\t}\n\t}\n\treturn pa;\n}\n\nstatic void meta_add_fileline(RBinFile *bf, ut64 vaddr, ut32 size, RCoreSymCacheElementFLC *flc) {\n\tSdb *s = bf->sdb_addrinfo;\n\tif (!s) {\n\t\treturn;\n\t}\n\tchar aoffset[64];\n\tut64 cursor = vaddr;\n\tut64 end = cursor + R_MAX (size, 1);\n\tchar *fileline = r_str_newf (\"%s:%d\", flc->file, flc->line);\n\twhile (cursor < end) {\n\t\tchar *aoffsetptr = sdb_itoa (cursor, aoffset, 16);\n\t\tif (!aoffsetptr) {\n\t\t\tbreak;\n\t\t}\n\t\tsdb_set (s, aoffsetptr, fileline, 0);\n\t\tsdb_set (s, fileline, aoffsetptr, 0);\n\t\tcursor += 2;\n\t}\n\tfree (fileline);\n}\n\nstatic char *str_dup_safe(const ut8 *b, const ut8 *str, const ut8 *end) {\n\tif (str >= b && str < end) {\n\t\tint len = r_str_nlen ((const char *)str, end - str);\n\t\tif (len) {\n\t\t\treturn r_str_ndup ((const char *)str, len);\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic char *str_dup_safe_fixed(const ut8 *b, const ut8 *str, ut64 len, const ut8 *end) {\n\tif (str >= b && str + len < end) {\n\t\tchar *result = calloc (1, len + 1);\n\t\tif (result) {\n\t\t\tr_str_ncpy (result, (const char *)str, len);\n\t\t\treturn result;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nRCoreSymCacheElement *r_coresym_cache_element_new(RBinFile *bf, RBuffer *buf, ut64 off, int bits, char * file_name) {\n\tRCoreSymCacheElement *result = NULL;\n\tut8 *b = NULL;\n\tRCoreSymCacheElementHdr *hdr = r_coresym_cache_element_header_new (buf, off, bits);\n\tif (!hdr) {\n\t\treturn NULL;\n\t}\n\tif (hdr->version != 1) {\n\t\teprintf (\"Unsupported CoreSymbolication cache version (%d)\\n\", hdr->version);\n\t\tgoto beach;\n\t}\n\tif (hdr->size == 0 || hdr->size > r_buf_size (buf) - off) {\n\t\teprintf (\"Corrupted CoreSymbolication header: size out of bounds (0x%x)\\n\", hdr->size);\n\t\tgoto beach;\n\t}\n\tresult = R_NEW0 (RCoreSymCacheElement);\n\tif (!result) {\n\t\tgoto beach;\n\t}\n\tresult->hdr = hdr;\n\tb = malloc (hdr->size);\n\tif (!b) {\n\t\tgoto beach;\n\t}\n\tif (r_buf_read_at (buf, off, b, hdr->size) != hdr->size) {\n\t\tgoto beach;\n\t}\n\tut8 *end = b + hdr->size;\n\tif (file_name) {\n\t\tresult->file_name = file_name;\n\t} else if (hdr->file_name_off) {\n\t\tresult->file_name = str_dup_safe (b, b + (size_t)hdr->file_name_off, end);\n\t}\n\tif (hdr->version_off) {\n\t\tresult->binary_version = str_dup_safe (b, b + (size_t)hdr->version_off, end);\n\t}\n\tconst size_t word_size = bits / 8;\n\tconst ut64 start_of_sections = (ut64)hdr->n_segments * R_CS_EL_SIZE_SEG + R_CS_EL_OFF_SEGS;\n\tconst ut64 sect_size = (bits == 32) ? R_CS_EL_SIZE_SECT_32 : R_CS_EL_SIZE_SECT_64;\n\tconst ut64 start_of_symbols = start_of_sections + (ut64)hdr->n_sections * sect_size;\n\tconst ut64 start_of_lined_symbols = start_of_symbols + (ut64)hdr->n_symbols * R_CS_EL_SIZE_SYM;\n\tconst ut64 start_of_line_info = start_of_lined_symbols + (ut64)hdr->n_lined_symbols * R_CS_EL_SIZE_LSYM;\n\tconst ut64 start_of_unknown_pairs = start_of_line_info + (ut64)hdr->n_line_info * R_CS_EL_SIZE_LINFO;\n\tconst ut64 start_of_strings = start_of_unknown_pairs + (ut64)hdr->n_symbols * 8;\n\n\tut64 page_zero_size = 0;\n\tsize_t page_zero_idx = 0;\n\tif (UT32_MUL_OVFCHK (hdr->n_segments, sizeof (RCoreSymCacheElementSegment))) {\n\t\tgoto beach;\n\t} else if (UT32_MUL_OVFCHK (hdr->n_sections, sizeof (RCoreSymCacheElementSection))) {\n\t\tgoto beach;\n\t} else if (UT32_MUL_OVFCHK (hdr->n_symbols, sizeof (RCoreSymCacheElementSymbol))) {\n\t\tgoto beach;\n\t} else if (UT32_MUL_OVFCHK (hdr->n_lined_symbols, sizeof (RCoreSymCacheElementLinedSymbol))) {\n\t\tgoto beach;\n\t} else if (UT32_MUL_OVFCHK (hdr->n_line_info, sizeof (RCoreSymCacheElementLineInfo))) {\n\t\tgoto beach;\n\t}\n\tif (hdr->n_segments > 0) {\n\t\tresult->segments = R_NEWS0 (RCoreSymCacheElementSegment, hdr->n_segments);\n\t\tif (!result->segments) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t i;\n\t\tut8 *cursor = b + R_CS_EL_OFF_SEGS;\n\t\tfor (i = 0; i < hdr->n_segments && cursor + sizeof (RCoreSymCacheElementSegment) < end; i++) {\n\t\t\tRCoreSymCacheElementSegment *seg = &result->segments[i];\n\t\t\tseg->paddr = seg->vaddr = r_read_le64 (cursor);\n\t\t\tcursor += 8;\n\t\t\tif (cursor >= end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tseg->size = seg->vsize = r_read_le64 (cursor);\n\t\t\tcursor += 8;\n\t\t\tif (cursor >= end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tseg->name = str_dup_safe_fixed (b, cursor, 16, end);\n\t\t\tcursor += 16;\n\t\t\tif (!seg->name) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!strcmp (seg->name, \"__PAGEZERO\")) {\n\t\t\t\tpage_zero_size = seg->size;\n\t\t\t\tpage_zero_idx = i;\n\t\t\t\tseg->paddr = seg->vaddr = 0;\n\t\t\t\tseg->size = 0;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < hdr->n_segments && page_zero_size > 0; i++) {\n\t\t\tif (i == page_zero_idx) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRCoreSymCacheElementSegment *seg = &result->segments[i];\n\t\t\tif (seg->vaddr < page_zero_size) {\n\t\t\t\tseg->vaddr += page_zero_size;\n\t\t\t}\n\t\t}\n\t}\n\tbool relative_to_strings = false;\n\tut8* string_origin;\n\tif (hdr->n_sections > 0) {\n\t\tresult->sections = R_NEWS0 (RCoreSymCacheElementSection, hdr->n_sections);\n\t\tif (!result->sections) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t i;\n\t\tut8 *cursor = b + start_of_sections;\n\t\tfor (i = 0; i < hdr->n_sections && cursor < end; i++) {\n\t\t\tut8 *sect_start = cursor;\n\t\t\tRCoreSymCacheElementSection *sect = &result->sections[i];\n\t\t\tsect->vaddr = sect->paddr = r_read_ble (cursor, false, bits);\n\t\t\tif (sect->vaddr < page_zero_size) {\n\t\t\t\tsect->vaddr += page_zero_size;\n\t\t\t}\n\t\t\tcursor += word_size;\n\t\t\tif (cursor + word_size >= end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsect->size = r_read_ble (cursor, false, bits);\n\t\t\tcursor += word_size;\n\t\t\tif (cursor + word_size >= end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut64 sect_name_off = r_read_ble (cursor, false, bits);\n\t\t\tif (!i && !sect_name_off) {\n\t\t\t\trelative_to_strings = true;\n\t\t\t}\n\t\t\tcursor += word_size;\n\t\t\tif (bits == 32) {\n\t\t\t\tcursor += word_size;\n\t\t\t}\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : sect_start;\n\t\t\tif (sect_name_off < (ut64)(size_t)(end - string_origin)) {\n\t\t\t\tsect->name = str_dup_safe (b, string_origin + sect_name_off, end);\n\t\t\t} else {\n\t\t\t\tsect->name = strdup (\"\");\n\t\t\t}\n\t\t}\n\t}\n\tif (hdr->n_symbols) {\n\t\tresult->symbols = R_NEWS0 (RCoreSymCacheElementSymbol, hdr->n_symbols);\n\t\tif (!result->symbols) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t i;\n\t\tut8 *cursor = b + start_of_symbols;\n\t\tfor (i = 0; i < hdr->n_symbols && cursor + R_CS_EL_SIZE_SYM <= end; i++) {\n\t\t\tRCoreSymCacheElementSymbol *sym = &result->symbols[i];\n\t\t\tsym->paddr = r_read_le32 (cursor);\n\t\t\tsym->size = r_read_le32 (cursor + 0x4);\n\t\t\tsym->unk1 = r_read_le32 (cursor + 0x8);\n\t\t\tsize_t name_off = r_read_le32 (cursor + 0xc);\n\t\t\tsize_t mangled_name_off = r_read_le32 (cursor + 0x10);\n\t\t\tsym->unk2 = (st32)r_read_le32 (cursor + 0x14);\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tsym->name = str_dup_safe (b, string_origin + name_off, end);\n\t\t\tif (!sym->name) {\n\t\t\t\tcursor += R_CS_EL_SIZE_SYM;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tsym->mangled_name = str_dup_safe (b, string_origin + mangled_name_off, end);\n\t\t\tif (!sym->mangled_name) {\n\t\t\t\tcursor += R_CS_EL_SIZE_SYM;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcursor += R_CS_EL_SIZE_SYM;\n\t\t}\n\t}\n\tif (hdr->n_lined_symbols) {\n\t\tresult->lined_symbols = R_NEWS0 (RCoreSymCacheElementLinedSymbol, hdr->n_lined_symbols);\n\t\tif (!result->lined_symbols) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t i;\n\t\tut8 *cursor = b + start_of_lined_symbols;\n\t\tfor (i = 0; i < hdr->n_lined_symbols && cursor + R_CS_EL_SIZE_LSYM <= end; i++) {\n\t\t\tRCoreSymCacheElementLinedSymbol *lsym = &result->lined_symbols[i];\n\t\t\tlsym->sym.paddr = r_read_le32 (cursor);\n\t\t\tlsym->sym.size = r_read_le32 (cursor + 0x4);\n\t\t\tlsym->sym.unk1 = r_read_le32 (cursor + 0x8);\n\t\t\tsize_t name_off = r_read_le32 (cursor + 0xc);\n\t\t\tsize_t mangled_name_off = r_read_le32 (cursor + 0x10);\n\t\t\tlsym->sym.unk2 = (st32)r_read_le32 (cursor + 0x14);\n\t\t\tsize_t file_name_off = r_read_le32 (cursor + 0x18);\n\t\t\tlsym->flc.line = r_read_le32 (cursor + 0x1c);\n\t\t\tlsym->flc.col = r_read_le32 (cursor + 0x20);\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tlsym->sym.name = str_dup_safe (b, string_origin + name_off, end);\n\t\t\tif (!lsym->sym.name) {\n\t\t\t\tcursor += R_CS_EL_SIZE_LSYM;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tlsym->sym.mangled_name = str_dup_safe (b, string_origin + mangled_name_off, end);\n\t\t\tif (!lsym->sym.mangled_name) {\n\t\t\t\tcursor += R_CS_EL_SIZE_LSYM;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tlsym->flc.file = str_dup_safe (b, string_origin + file_name_off, end);\n\t\t\tif (!lsym->flc.file) {\n\t\t\t\tcursor += R_CS_EL_SIZE_LSYM;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcursor += R_CS_EL_SIZE_LSYM;\n\t\t\tmeta_add_fileline (bf, r_coresym_cache_element_pa2va (result, lsym->sym.paddr), lsym->sym.size, &lsym->flc);\n\t\t}\n\t}\n\tif (hdr->n_line_info) {\n\t\tresult->line_info = R_NEWS0 (RCoreSymCacheElementLineInfo, hdr->n_line_info);\n\t\tif (!result->line_info) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t i;\n\t\tut8 *cursor = b + start_of_line_info;\n\t\tfor (i = 0; i < hdr->n_line_info && cursor + R_CS_EL_SIZE_LINFO <= end; i++) {\n\t\t\tRCoreSymCacheElementLineInfo *info = &result->line_info[i];\n\t\t\tinfo->paddr = r_read_le32 (cursor);\n\t\t\tinfo->size = r_read_le32 (cursor + 4);\n\t\t\tsize_t file_name_off = r_read_le32 (cursor + 8);\n\t\t\tinfo->flc.line = r_read_le32 (cursor + 0xc);\n\t\t\tinfo->flc.col = r_read_le32 (cursor + 0x10);\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tinfo->flc.file = str_dup_safe (b, string_origin + file_name_off, end);\n\t\t\tif (!info->flc.file) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcursor += R_CS_EL_SIZE_LINFO;\n\t\t\tmeta_add_fileline (bf, r_coresym_cache_element_pa2va (result, info->paddr), info->size, &info->flc);\n\t\t}\n\t}\n\n\t/*\n\t * TODO:\n\t * Figure out the meaning of the 2 arrays of hdr->n_symbols\n\t * 32-bit integers located at the end of line info.\n\t * Those are the last info before the strings at the end.\n\t */\n\nbeach:\n\tfree (b);\n\treturn result;\n}\n\n", "/* radare - LGPL - Copyright 2018-2022 - pancake */\n\n#include <r_types.h>\n#include <r_util.h>\n#include <r_lib.h>\n#include <r_bin.h>\n#include <ht_uu.h>\n#include \"../i/private.h\"\n#include \"mach0/coresymbolication.h\"\n\n// enable debugging messages\n#define D if (0)\n#define R_UUID_LENGTH 33\n\ntypedef struct symbols_header_t {\n\tut32 magic;\n\tut32 version;\n\tut8 uuid[16];\n\tut32 unk0;\n\tut32 unk1;\n\tut32 slotsize;\n\tut32 addr;\n\tbool valid;\n\tint size;\n} SymbolsHeader;\n\ntypedef struct symbols_metadata_t { // 0x40\n\tut32 cputype;\n\tut32 subtype;\n\tut32 n_segments;\n\tut32 namelen;\n\tut32 name;\n\tbool valid;\n\tut32 size;\n\t//RList *segments;\n\tut32 addr;\n\tint bits;\n\tconst char *arch;\n\tconst char *cpu;\n} SymbolsMetadata;\n\n// header starts at offset 0 and ends at offset 0x40\nstatic SymbolsHeader parseHeader(RBuffer *buf) {\n\tut8 b[64];\n\tSymbolsHeader sh = {0};\n\t(void)r_buf_read_at (buf, 0, b, sizeof (b));\n\tsh.magic = r_read_le32 (b);\n\tsh.version = r_read_le32 (b + 4);\n\tsh.valid = sh.magic == 0xff01ff02;\n\tint i;\n\tfor (i = 0; i < 16; i++) {\n\t\tsh.uuid[i] = b[24 + i];\n\t}\n\tsh.unk0 = r_read_le16 (b + 0x28);\n\tsh.unk1 = r_read_le16 (b + 0x2c); // is slotsize + 1 :?\n\tsh.slotsize = r_read_le16 (b + 0x2e);\n\tsh.size = 0x40;\n\treturn sh;\n}\n\nstatic const char *typeString(ut32 n, int *bits) {\n\t*bits = 32;\n\tif (n == 12) { // CPU_SUBTYPE_ARM_V7) {\n\t\treturn \"arm\";\n\t}\n\tif (n == 0x0100000c) { // arm64\n\t\t*bits = 64;\n\t\treturn \"arm\";\n\t}\n\tif (n == 0x0200000c) { // arm64-32\n\t\t//  TODO: must change bits\n\t\t*bits = 64;\n\t\treturn \"arm\";\n\t}\n\treturn \"x86\";\n}\n\nstatic const char *subtypeString(int n) {\n\tif (n == 9) { // CPU_SUBTYPE_ARM_V7) {\n\t\treturn \"armv7\";\n\t}\n\treturn \"?\";\n}\n\n// metadata section starts at offset 0x40 and ends around 0xb0 depending on filenamelength\nstatic SymbolsMetadata parseMetadata(RBuffer *buf, int off) {\n\tSymbolsMetadata sm = {0};\n\tut8 b[0x100] = {0};\n\t(void)r_buf_read_at (buf, off, b, sizeof (b));\n\tsm.addr = off;\n\tsm.cputype = r_read_le32 (b);\n\tsm.arch = typeString (sm.cputype, &sm.bits);\n\t//  eprintf (\"0x%08x  cputype  0x%x -> %s\\n\", 0x40, sm.cputype, typeString (sm.cputype));\n\t// bits = (strstr (typeString (sm.cputype, &sm.bits), \"64\"))? 64: 32;\n\tsm.subtype = r_read_le32 (b + 4);\n\tsm.cpu = subtypeString (sm.subtype);\n\t//  eprintf (\"0x%08x  subtype  0x%x -> %s\\n\", 0x44, sm.subtype, subtypeString (sm.subtype));\n\tsm.n_segments = r_read_le32 (b + 8);\n\t// int count = r_read_le32 (b + 0x48);\n\tsm.namelen = r_read_le32 (b + 0xc);\n\t// eprintf (\"0x%08x  count    %d\\n\", 0x48, count);\n\t// eprintf (\"0x%08x  strlen   %d\\n\", 0x4c, sm.namelen);\n\t// eprintf (\"0x%08x  filename %s\\n\", 0x50, b + 16);\n\tint delta = 16;\n\t//sm.segments = parseSegments (buf, off + sm.namelen + delta, sm.n_segments);\n\tsm.size = (sm.n_segments * 32) + sm.namelen + delta;\n\n\t// hack to detect format\n\tut32 nm, nm2, nm3;\n\tr_buf_read_at (buf, off + sm.size, (ut8 *)&nm, sizeof (nm));\n\tr_buf_read_at (buf, off + sm.size + 4, (ut8 *)&nm2, sizeof (nm2));\n\tr_buf_read_at (buf, off + sm.size + 8, (ut8 *)&nm3, sizeof (nm3));\n\t// eprintf (\"0x%x next %x %x %x\\n\", off + sm.size, nm, nm2, nm3);\n\tif (r_read_le32 (&nm3) != 0xa1b22b1a) {\n\t\tsm.size -= 8;\n\t\t//\t\tis64 = true;\n\t}\n\treturn sm;\n}\n\nstatic RBinSection *bin_section_from_section(RCoreSymCacheElementSection *sect) {\n\tif (!sect->name) {\n\t\treturn NULL;\n\t}\n\tRBinSection *s = R_NEW0 (RBinSection);\n\tif (!s) {\n\t\treturn NULL;\n\t}\n\ts->name = r_str_ndup (sect->name, 256);\n\ts->size = sect->size;\n\ts->vsize = s->size;\n\ts->paddr = sect->paddr;\n\ts->vaddr = sect->vaddr;\n\ts->add = true;\n\ts->perm = strstr (s->name, \"TEXT\") ? 5 : 4;\n\ts->is_segment = false;\n\treturn s;\n}\n\nstatic RBinSection *bin_section_from_segment(RCoreSymCacheElementSegment *seg) {\n\tif (!seg->name) {\n\t\treturn NULL;\n\t}\n\tRBinSection *s = R_NEW0 (RBinSection);\n\tif (!s) {\n\t\treturn NULL;\n\t}\n\ts->name = r_str_ndup (seg->name, 16);\n\ts->size = seg->size;\n\ts->vsize = seg->vsize;\n\ts->paddr = seg->paddr;\n\ts->vaddr = seg->vaddr;\n\ts->add = true;\n\ts->perm = strstr (s->name, \"TEXT\") ? 5 : 4;\n\ts->is_segment = true;\n\treturn s;\n}\n\nstatic RBinSymbol *bin_symbol_from_symbol(RCoreSymCacheElement *element, RCoreSymCacheElementSymbol *s) {\n\tif (!s->name && !s->mangled_name) {\n\t\treturn NULL;\n\t}\n\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\tif (sym) {\n\t\tif (s->name && s->mangled_name) {\n\t\t\tsym->dname = strdup (s->name);\n\t\t\tsym->name = strdup (s->mangled_name);\n\t\t} else if (s->name) {\n\t\t\tsym->name = strdup (s->name);\n\t\t} else if (s->mangled_name) {\n\t\t\tsym->name = s->mangled_name;\n\t\t}\n\t\tsym->paddr = s->paddr;\n\t\tsym->vaddr = r_coresym_cache_element_pa2va (element, s->paddr);\n\t\tsym->size = s->size;\n\t\tsym->type = R_BIN_TYPE_FUNC_STR;\n\t\tsym->bind = \"NONE\";\n\t}\n\treturn sym;\n}\n\nstatic RCoreSymCacheElement *parseDragons(RBinFile *bf, RBuffer *buf, int off, int bits, R_OWN char *file_name) {\n\tD eprintf (\"Dragons at 0x%x\\n\", off);\n\tst64 size = r_buf_size (buf);\n\tif (off >= size) {\n\t\treturn NULL;\n\t}\n\tsize -= off;\n\tif (!size) {\n\t\treturn NULL;\n\t}\n\tif (size < 32) {\n\t\treturn NULL;\n\t}\n\tut8 *b = malloc (size);\n\tif (!b) {\n\t\treturn NULL;\n\t}\n\tint available = r_buf_read_at (buf, off, b, size);\n\tif (available != size) {\n\t\teprintf (\"Warning: r_buf_read_at failed\\n\");\n\t\treturn NULL;\n\t}\n#if 0\n\t// after the list of sections, there's a bunch of unknown\n\t// data, brobably dwords, and then the same section list again\n\t// this function aims to parse it.\n\t0x00000138 |1a2b b2a1 0300 0000 1a2b b2a1 e055 0000| .+.......+...U..\n                         n_segments ----.          .--- how many sections ?\n\t0x00000148 |0100 0000 ca55 0000 0400 0000 1800 0000| .....U..........\n\t             .---- how many symbols? 0xc7\n\t0x00000158 |c700 0000 0000 0000 0000 0000 0104 0000| ................\n\t0x00000168 |250b e803 0000 0100 0000 0000 bd55 0000| %............U..\n\t0x00000178 |91bb e903 e35a b42c 93a4 340a 8746 9489| .....Z.,..4..F..\n\t0x00000188 |0cea 4c40 0c00 0000 0900 0000 0000 0000| ..L@............\n\t0x00000198 |0000 0000 0000 0000 0000 0000 0000 0000| ................\n\t0x000001a8 |0080 0000 0000 0000 5f5f 5445 5854 0000| ........__TEXT..\n\t0x000001b8 |0000 0000 0000 0000 0080 0000 0000 0000| ................\n\t0x000001c8 |0040 0000 0000 0000 5f5f 4441 5441 0000| .@......__DATA..\n\t0x000001d8 |0000 0000 0000 0000 00c0 0000 0000 0000| ................\n\t0x000001e8 |0000 0100 0000 0000 5f5f 4c4c 564d 0000| ........__LLVM..\n\t0x000001f8 |0000 0000 0000 0000 00c0 0100 0000 0000| ................\n\t0x00000208 |00c0 0000 0000 0000 5f5f 4c49 4e4b 4544| ........__LINKED\n\t0x00000218 |4954 0000 0000 0000 0000 0000 d069 0000| IT...........i..\n#endif\n\t// eprintf (\"Dragon's magic:\\n\");\n\tint magicCombo = 0;\n\tif (!memcmp (\"\\x1a\\x2b\\xb2\\xa1\", b, 4)) { // 0x130  ?\n\t\tmagicCombo++;\n\t}\n\tif (!memcmp (\"\\x1a\\x2b\\xb2\\xa1\", b + 8, 4)) {\n\t\tmagicCombo++;\n\t}\n\tif (magicCombo != 2) {\n\t\t// hack for C22F7494\n\t\tavailable = r_buf_read_at (buf, off - 8, b, size);\n\t\tif (available != size) {\n\t\t\teprintf (\"Warning: r_buf_read_at failed\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!memcmp (\"\\x1a\\x2b\\xb2\\xa1\", b, 4)) { // 0x130  ?\n\t\t\toff -= 8;\n\t\t} else {\n\t\t\teprintf (\"0x%08x  parsing error: invalid magic retry\\n\", off);\n\t\t}\n\t}\n\tD eprintf (\"0x%08x  magic  OK\\n\", off);\n\tD {\n\t\tconst int e0ss = r_read_le32 (b + 12);\n\t\teprintf (\"0x%08x  eoss   0x%x\\n\", off + 12, e0ss);\n\t}\n\tfree (b);\n\treturn r_coresym_cache_element_new (bf, buf, off + 16, bits, file_name);\n}\n\nstatic bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {\n#if 0\n\tSYMBOLS HEADER\n\n 0\tMAGIC\t02ff01ff\n 4\tVERSION 1 (little endian)\n 8      ffffffff\n16      002b0000 01000000 { 0x2b00, 0x0000 }\n24\tUUID    16 bytes\n40\t2621 d85b 2100 2000 0000 0000 0000 0000\n56\tffff ffff ffff ff7f 0c00 0000 0900 0000\n72\t0400 0000 6800 0000 2f76 6172 2f66 6f6c .... 4, 104 /// 104 length string\n184\n0x000000b8  5f5f 5445 5854 0000 0000 0000 0000 0000 0000 0000 0000 0000 0080 0000 0000 0000  __TEXT..........................\n0x000000d8  5f5f 4441 5441 0000 0000 0000 0000 0000 0080 0000 0000 0000 0040 0000 0000 0000  __DATA...................@......\n0x000000f8  5f5f 4c4c 564d 0000 0000 0000 0000 0000 00c0 0000 0000 0000 0000 0100 0000 0000  __LLVM..........................\n0x00000118  5f5f 4c49 4e4b 4544 4954 0000 0000 0000 00c0 0100 0000 0000 00c0 0000 0000 0000  __LINKEDIT......................\n\n#endif\n\t// 0 - magic check, version ...\n\tSymbolsHeader sh = parseHeader (buf);\n\tif (!sh.valid) {\n\t\teprintf (\"Invalid headers\\n\");\n\t\treturn false;\n\t}\n\tSymbolsMetadata sm = parseMetadata (buf, 0x40);\n\tchar * file_name = NULL;\n\tif (sm.namelen) {\n\t\tfile_name = calloc (sm.namelen + 1, 1);\n\t\tif (!file_name) {\n\t\t\treturn false;\n\t\t}\n\t\tif (r_buf_read_at (buf, 0x50, (ut8*)file_name, sm.namelen) != sm.namelen) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tRCoreSymCacheElement *element = parseDragons (bf, buf, sm.addr + sm.size, sm.bits, file_name);\n\tif (element) {\n\t\t*bin_obj = element;\n\t\treturn true;\n\t}\n\tfree (file_name);\n\treturn false;\n}\n\nstatic RList *sections(RBinFile *bf) {\n\tRList *res = r_list_newf ((RListFree)r_bin_section_free);\n\tr_return_val_if_fail (res && bf->o && bf->o->bin_obj, res);\n\tRCoreSymCacheElement *element = bf->o->bin_obj;\n\tsize_t i;\n\tif (element->segments) {\n\t\tfor (i = 0; i < element->hdr->n_segments; i++) {\n\t\t\tRCoreSymCacheElementSegment *seg = &element->segments[i];\n\t\t\tRBinSection *s = bin_section_from_segment (seg);\n\t\t\tif (s) {\n\t\t\t\tr_list_append (res, s);\n\t\t\t}\n\t\t}\n\t}\n\tif (element->sections) {\n\t\tfor (i = 0; i < element->hdr->n_sections; i++) {\n\t\t\tRCoreSymCacheElementSection *sect = &element->sections[i];\n\t\t\tRBinSection *s = bin_section_from_section (sect);\n\t\t\tif (s) {\n\t\t\t\tr_list_append (res, s);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nstatic ut64 baddr(RBinFile *bf) {\n\treturn 0LL;\n}\n\nstatic RBinInfo *info(RBinFile *bf) {\n\tSymbolsMetadata sm = parseMetadata (bf->buf, 0x40);\n\tRBinInfo *ret = R_NEW0 (RBinInfo);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->file = strdup (bf->file);\n\tret->bclass = strdup (\"symbols\");\n\tret->os = strdup (\"unknown\");\n\tret->arch = sm.arch ? strdup (sm.arch) : NULL;\n\tret->bits = sm.bits;\n\tret->type = strdup (\"Symbols file\");\n\tret->subsystem = strdup (\"llvm\");\n\tret->has_va = true;\n\n\treturn ret;\n}\n\nstatic bool check_buffer(RBinFile *bf, RBuffer *b) {\n\tut8 buf[4];\n\tr_buf_read_at (b, 0, buf, sizeof (buf));\n\treturn !memcmp (buf, \"\\x02\\xff\\x01\\xff\", 4);\n}\n\nstatic RList *symbols(RBinFile *bf) {\n\tRList *res = r_list_newf ((RListFree)r_bin_symbol_free);\n\tr_return_val_if_fail (res && bf->o && bf->o->bin_obj, res);\n\tRCoreSymCacheElement *element = bf->o->bin_obj;\n\tsize_t i;\n\tHtUU *hash = ht_uu_new0 ();\n\tif (!hash) {\n\t\treturn res;\n\t}\n\tbool found = false;\n\tfor (i = 0; i < element->hdr->n_lined_symbols; i++) {\n\t\tRCoreSymCacheElementSymbol *sym = (RCoreSymCacheElementSymbol *)&element->lined_symbols[i];\n\t\tif (!sym) {\n\t\t\tbreak;\n\t\t}\n\t\tht_uu_find (hash, sym->paddr, &found);\n\t\tif (found) {\n\t\t\tcontinue;\n\t\t}\n\t\tRBinSymbol *s = bin_symbol_from_symbol (element, sym);\n\t\tif (s) {\n\t\t\tr_list_append (res, s);\n\t\t\tht_uu_insert (hash, sym->paddr, 1);\n\t\t}\n\t}\n\tif (element->symbols) {\n\t\tfor (i = 0; i < element->hdr->n_symbols; i++) {\n\t\t\tRCoreSymCacheElementSymbol *sym = &element->symbols[i];\n\t\t\tht_uu_find (hash, sym->paddr, &found);\n\t\t\tif (found) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRBinSymbol *s = bin_symbol_from_symbol (element, sym);\n\t\t\tif (s) {\n\t\t\t\tr_list_append (res, s);\n\t\t\t}\n\t\t}\n\t}\n\tht_uu_free (hash);\n\treturn res;\n}\n\nstatic ut64 size(RBinFile *bf) {\n\treturn UT64_MAX;\n}\n\nstatic void destroy(RBinFile *bf) {\n\tr_coresym_cache_element_free (bf->o->bin_obj);\n}\n\nstatic void header(RBinFile *bf) {\n\tr_return_if_fail (bf && bf->o);\n\n\tRCoreSymCacheElement *element = bf->o->bin_obj;\n\tif (!element) {\n\t\treturn;\n\t}\n\n\tRBin *bin = bf->rbin;\n\tPrintfCallback p = bin->cb_printf;\n\tPJ *pj = pj_new ();\n\tif (!pj) {\n\t\treturn;\n\t}\n\n\tpj_o (pj);\n\tpj_kn (pj, \"cs_version\", element->hdr->version);\n\tpj_kn (pj, \"size\", element->hdr->size);\n\tif (element->file_name) {\n\t\tpj_ks (pj, \"name\", element->file_name);\n\t}\n\tif (element->binary_version) {\n\t\tpj_ks (pj, \"version\", element->binary_version);\n\t}\n\tchar uuidstr[R_UUID_LENGTH];\n\tr_hex_bin2str (element->hdr->uuid, 16, uuidstr);\n\tpj_ks (pj, \"uuid\", uuidstr);\n\tpj_kn (pj, \"segments\", element->hdr->n_segments);\n\tpj_kn (pj, \"sections\", element->hdr->n_sections);\n\tpj_kn (pj, \"symbols\", element->hdr->n_symbols);\n\tpj_kn (pj, \"lined_symbols\", element->hdr->n_lined_symbols);\n\tpj_kn (pj, \"line_info\", element->hdr->n_line_info);\n\tpj_end (pj);\n\n\tp (\"%s\\n\", pj_string (pj));\n\tpj_free (pj);\n}\n\nRBinPlugin r_bin_plugin_symbols = {\n\t.name = \"symbols\",\n\t.desc = \"Apple Symbols file\",\n\t.license = \"MIT\",\n\t.load_buffer = &load_buffer,\n\t.check_buffer = &check_buffer,\n\t.symbols = &symbols,\n\t.sections = &sections,\n\t.size = &size,\n\t.baddr = &baddr,\n\t.info = &info,\n\t.header = &header,\n\t.destroy = &destroy,\n};\n\n#ifndef R2_PLUGIN_INCORE\nR_API RLibStruct radare_plugin = {\n\t.type = R_LIB_TYPE_BIN,\n\t.data = &r_bin_plugin_symbols,\n\t.version = R2_VERSION\n};\n#endif\n"], "fixing_code": ["/* radare - LGPL - Copyright 2020 - mrmacete */\n\n#include <r_types.h>\n#include <r_util.h>\n#include <r_hash.h>\n#include \"coresymbolication.h\"\n\n#define R_CS_EL_OFF_SEGS 0x58\n#define R_CS_EL_SIZE_SEG 0x20\n#define R_CS_EL_SIZE_SECT_64 0x18\n#define R_CS_EL_SIZE_SECT_32 0x10\n#define R_CS_EL_SIZE_SYM 0x18\n#define R_CS_EL_SIZE_LSYM 0x24\n#define R_CS_EL_SIZE_LINFO 0x14\n\nstatic RCoreSymCacheElementHdr *r_coresym_cache_element_header_new(RBuffer *buf, size_t off, int bits) {\n\tRCoreSymCacheElementHdr *hdr = R_NEW0 (RCoreSymCacheElementHdr);\n\tif (hdr && r_buf_fread_at (buf, off, (ut8 *)hdr, \"13i16c5i\", 1) == sizeof (RCoreSymCacheElementHdr)) {\n\t\treturn hdr;\n\t}\n\tfree (hdr);\n\treturn NULL;\n}\n\nstatic void r_coresym_cache_element_segment_fini(RCoreSymCacheElementSegment *seg) {\n\tif (seg) {\n\t\tfree (seg->name);\n\t}\n}\n\nstatic void r_coresym_cache_element_section_fini(RCoreSymCacheElementSection *sec) {\n\tif (sec) {\n\t\tfree (sec->name);\n\t}\n}\n\nstatic void r_coresym_cache_element_flc_fini(RCoreSymCacheElementFLC *flc) {\n\tif (flc) {\n\t\tfree (flc->file);\n\t}\n}\n\nstatic void r_coresym_cache_element_symbol_fini(RCoreSymCacheElementSymbol *sym) {\n\tif (sym) {\n\t\tfree (sym->name);\n\t\tfree (sym->mangled_name);\n\t}\n}\n\nstatic void r_coresym_cache_element_lined_symbol_fini(RCoreSymCacheElementLinedSymbol *sym) {\n\tif (sym) {\n\t\tr_coresym_cache_element_symbol_fini (&sym->sym);\n\t\tr_coresym_cache_element_flc_fini (&sym->flc);\n\t}\n}\n\nstatic void r_coresym_cache_element_line_info_fini(RCoreSymCacheElementLineInfo *line) {\n\tif (line) {\n\t\tr_coresym_cache_element_flc_fini (&line->flc);\n\t}\n}\n\nvoid r_coresym_cache_element_free(RCoreSymCacheElement *element) {\n\tif (!element) {\n\t\treturn;\n\t}\n\tsize_t i;\n\tif (element->segments) {\n\t\tfor (i = 0; i < element->hdr->n_segments; i++) {\n\t\t\tr_coresym_cache_element_segment_fini (&element->segments[i]);\n\t\t}\n\t}\n\tif (element->sections) {\n\t\tfor (i = 0; i < element->hdr->n_sections; i++) {\n\t\t\tr_coresym_cache_element_section_fini (&element->sections[i]);\n\t\t}\n\t}\n\tif (element->symbols) {\n\t\tfor (i = 0; i < element->hdr->n_symbols; i++) {\n\t\t\tr_coresym_cache_element_symbol_fini (&element->symbols[i]);\n\t\t}\n\t}\n\tif (element->lined_symbols) {\n\t\tfor (i = 0; i < element->hdr->n_lined_symbols; i++) {\n\t\t\tr_coresym_cache_element_lined_symbol_fini (&element->lined_symbols[i]);\n\t\t}\n\t}\n\tif (element->line_info) {\n\t\tfor (i = 0; i < element->hdr->n_line_info; i++) {\n\t\t\tr_coresym_cache_element_line_info_fini (&element->line_info[i]);\n\t\t}\n\t}\n\tfree (element->segments);\n\tfree (element->sections);\n\tfree (element->symbols);\n\tfree (element->lined_symbols);\n\tfree (element->line_info);\n\tfree (element->hdr);\n\tfree (element->file_name);\n\tfree (element->binary_version);\n\tfree (element);\n}\n\nut64 r_coresym_cache_element_pa2va(RCoreSymCacheElement *element, ut64 pa) {\n\tsize_t i;\n\tfor (i = 0; i < element->hdr->n_segments; i++) {\n\t\tRCoreSymCacheElementSegment *seg = &element->segments[i];\n\t\tif (seg->size == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (seg->paddr < pa && pa < seg->paddr + seg->size) {\n\t\t\treturn pa - seg->paddr + seg->vaddr;\n\t\t}\n\t}\n\treturn pa;\n}\n\nstatic void meta_add_fileline(RBinFile *bf, ut64 vaddr, ut32 size, RCoreSymCacheElementFLC *flc) {\n\tSdb *s = bf->sdb_addrinfo;\n\tif (!s) {\n\t\treturn;\n\t}\n\tchar aoffset[64];\n\tut64 cursor = vaddr;\n\tut64 end = cursor + R_MAX (size, 1);\n\tchar *fileline = r_str_newf (\"%s:%d\", flc->file, flc->line);\n\twhile (cursor < end) {\n\t\tchar *aoffsetptr = sdb_itoa (cursor, aoffset, 16);\n\t\tif (!aoffsetptr) {\n\t\t\tbreak;\n\t\t}\n\t\tsdb_set (s, aoffsetptr, fileline, 0);\n\t\tsdb_set (s, fileline, aoffsetptr, 0);\n\t\tcursor += 2;\n\t}\n\tfree (fileline);\n}\n\nstatic char *str_dup_safe(const ut8 *b, const ut8 *str, const ut8 *end) {\n\tif (str >= b && str < end) {\n\t\tint len = r_str_nlen ((const char *)str, end - str);\n\t\tif (len) {\n\t\t\treturn r_str_ndup ((const char *)str, len);\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic char *str_dup_safe_fixed(const ut8 *b, const ut8 *str, ut64 len, const ut8 *end) {\n\tif (str >= b && str + len < end) {\n\t\tchar *result = calloc (1, len + 1);\n\t\tif (result) {\n\t\t\tr_str_ncpy (result, (const char *)str, len);\n\t\t\treturn result;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nRCoreSymCacheElement *r_coresym_cache_element_new(RBinFile *bf, RBuffer *buf, ut64 off, int bits, char * file_name) {\n\tRCoreSymCacheElement *result = NULL;\n\tut8 *b = NULL;\n\tRCoreSymCacheElementHdr *hdr = r_coresym_cache_element_header_new (buf, off, bits);\n\tif (!hdr) {\n\t\treturn NULL;\n\t}\n\tif (hdr->version != 1) {\n\t\teprintf (\"Unsupported CoreSymbolication cache version (%d)\\n\", hdr->version);\n\t\tgoto beach;\n\t}\n\tif (hdr->size == 0 || hdr->size > r_buf_size (buf) - off) {\n\t\teprintf (\"Corrupted CoreSymbolication header: size out of bounds (0x%x)\\n\", hdr->size);\n\t\tgoto beach;\n\t}\n\tresult = R_NEW0 (RCoreSymCacheElement);\n\tif (!result) {\n\t\tgoto beach;\n\t}\n\tresult->hdr = hdr;\n\tb = malloc (hdr->size);\n\tif (!b) {\n\t\tgoto beach;\n\t}\n\tif (r_buf_read_at (buf, off, b, hdr->size) != hdr->size) {\n\t\tgoto beach;\n\t}\n\tut8 *end = b + hdr->size;\n\tif (file_name) {\n\t\tresult->file_name = file_name;\n\t} else if (hdr->file_name_off) {\n\t\tresult->file_name = str_dup_safe (b, b + (size_t)hdr->file_name_off, end);\n\t}\n\tif (hdr->version_off) {\n\t\tresult->binary_version = str_dup_safe (b, b + (size_t)hdr->version_off, end);\n\t}\n\tconst size_t word_size = bits / 8;\n\tconst ut64 start_of_sections = (ut64)hdr->n_segments * R_CS_EL_SIZE_SEG + R_CS_EL_OFF_SEGS;\n\tconst ut64 sect_size = (bits == 32) ? R_CS_EL_SIZE_SECT_32 : R_CS_EL_SIZE_SECT_64;\n\tconst ut64 start_of_symbols = start_of_sections + (ut64)hdr->n_sections * sect_size;\n\tconst ut64 start_of_lined_symbols = start_of_symbols + (ut64)hdr->n_symbols * R_CS_EL_SIZE_SYM;\n\tconst ut64 start_of_line_info = start_of_lined_symbols + (ut64)hdr->n_lined_symbols * R_CS_EL_SIZE_LSYM;\n\tconst ut64 start_of_unknown_pairs = start_of_line_info + (ut64)hdr->n_line_info * R_CS_EL_SIZE_LINFO;\n\tconst ut64 start_of_strings = start_of_unknown_pairs + (ut64)hdr->n_symbols * 8;\n\n\tut64 page_zero_size = 0;\n\tsize_t page_zero_idx = 0;\n\tif (UT32_MUL_OVFCHK (hdr->n_segments, sizeof (RCoreSymCacheElementSegment))) {\n\t\tgoto beach;\n\t} else if (UT32_MUL_OVFCHK (hdr->n_sections, sizeof (RCoreSymCacheElementSection))) {\n\t\tgoto beach;\n\t} else if (UT32_MUL_OVFCHK (hdr->n_symbols, sizeof (RCoreSymCacheElementSymbol))) {\n\t\tgoto beach;\n\t} else if (UT32_MUL_OVFCHK (hdr->n_lined_symbols, sizeof (RCoreSymCacheElementLinedSymbol))) {\n\t\tgoto beach;\n\t} else if (UT32_MUL_OVFCHK (hdr->n_line_info, sizeof (RCoreSymCacheElementLineInfo))) {\n\t\tgoto beach;\n\t}\n\tif (hdr->n_segments > 0) {\n\t\tresult->segments = R_NEWS0 (RCoreSymCacheElementSegment, hdr->n_segments);\n\t\tif (!result->segments) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t i;\n\t\tut8 *cursor = b + R_CS_EL_OFF_SEGS;\n\t\tfor (i = 0; i < hdr->n_segments && cursor + sizeof (RCoreSymCacheElementSegment) < end; i++) {\n\t\t\tRCoreSymCacheElementSegment *seg = &result->segments[i];\n\t\t\tseg->paddr = seg->vaddr = r_read_le64 (cursor);\n\t\t\tcursor += 8;\n\t\t\tif (cursor >= end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tseg->size = seg->vsize = r_read_le64 (cursor);\n\t\t\tcursor += 8;\n\t\t\tif (cursor >= end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tseg->name = str_dup_safe_fixed (b, cursor, 16, end);\n\t\t\tcursor += 16;\n\t\t\tif (!seg->name) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!strcmp (seg->name, \"__PAGEZERO\")) {\n\t\t\t\tpage_zero_size = seg->size;\n\t\t\t\tpage_zero_idx = i;\n\t\t\t\tseg->paddr = seg->vaddr = 0;\n\t\t\t\tseg->size = 0;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < hdr->n_segments && page_zero_size > 0; i++) {\n\t\t\tif (i == page_zero_idx) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRCoreSymCacheElementSegment *seg = &result->segments[i];\n\t\t\tif (seg->vaddr < page_zero_size) {\n\t\t\t\tseg->vaddr += page_zero_size;\n\t\t\t}\n\t\t}\n\t}\n\tbool relative_to_strings = false;\n\tut8* string_origin;\n\tif (hdr->n_sections > 0) {\n\t\tresult->sections = R_NEWS0 (RCoreSymCacheElementSection, hdr->n_sections);\n\t\tif (!result->sections) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t i;\n\t\tut8 *cursor = b + start_of_sections;\n\t\tfor (i = 0; i < hdr->n_sections && cursor < end; i++) {\n\t\t\tut8 *sect_start = cursor;\n\t\t\tRCoreSymCacheElementSection *sect = &result->sections[i];\n\t\t\tif (cursor + (word_size * 4) > end) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tsect->vaddr = sect->paddr = r_read_ble (cursor, false, bits);\n\t\t\tif (sect->vaddr < page_zero_size) {\n\t\t\t\tsect->vaddr += page_zero_size;\n\t\t\t}\n\t\t\tcursor += word_size;\n\t\t\tif (cursor + word_size >= end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsect->size = r_read_ble (cursor, false, bits);\n\t\t\tcursor += word_size;\n\t\t\tif (cursor + word_size >= end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut64 sect_name_off = r_read_ble (cursor, false, bits);\n\t\t\tif (!i && !sect_name_off) {\n\t\t\t\trelative_to_strings = true;\n\t\t\t}\n\t\t\tcursor += word_size;\n\t\t\tif (bits == 32) {\n\t\t\t\tcursor += word_size;\n\t\t\t}\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : sect_start;\n\t\t\tif (sect_name_off < (ut64)(size_t)(end - string_origin)) {\n\t\t\t\tsect->name = str_dup_safe (b, string_origin + sect_name_off, end);\n\t\t\t} else {\n\t\t\t\tsect->name = strdup (\"\");\n\t\t\t}\n\t\t}\n\t}\n\tif (hdr->n_symbols) {\n\t\tresult->symbols = R_NEWS0 (RCoreSymCacheElementSymbol, hdr->n_symbols);\n\t\tif (!result->symbols) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t i;\n\t\tut8 *cursor = b + start_of_symbols;\n\t\tfor (i = 0; i < hdr->n_symbols && cursor + R_CS_EL_SIZE_SYM <= end; i++) {\n\t\t\tRCoreSymCacheElementSymbol *sym = &result->symbols[i];\n\t\t\tsym->paddr = r_read_le32 (cursor);\n\t\t\tsym->size = r_read_le32 (cursor + 0x4);\n\t\t\tsym->unk1 = r_read_le32 (cursor + 0x8);\n\t\t\tsize_t name_off = r_read_le32 (cursor + 0xc);\n\t\t\tsize_t mangled_name_off = r_read_le32 (cursor + 0x10);\n\t\t\tsym->unk2 = (st32)r_read_le32 (cursor + 0x14);\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tsym->name = str_dup_safe (b, string_origin + name_off, end);\n\t\t\tif (!sym->name) {\n\t\t\t\tcursor += R_CS_EL_SIZE_SYM;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tsym->mangled_name = str_dup_safe (b, string_origin + mangled_name_off, end);\n\t\t\tif (!sym->mangled_name) {\n\t\t\t\tcursor += R_CS_EL_SIZE_SYM;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcursor += R_CS_EL_SIZE_SYM;\n\t\t}\n\t}\n\tif (hdr->n_lined_symbols) {\n\t\tresult->lined_symbols = R_NEWS0 (RCoreSymCacheElementLinedSymbol, hdr->n_lined_symbols);\n\t\tif (!result->lined_symbols) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t i;\n\t\tut8 *cursor = b + start_of_lined_symbols;\n\t\tfor (i = 0; i < hdr->n_lined_symbols && cursor + R_CS_EL_SIZE_LSYM <= end; i++) {\n\t\t\tRCoreSymCacheElementLinedSymbol *lsym = &result->lined_symbols[i];\n\t\t\tlsym->sym.paddr = r_read_le32 (cursor);\n\t\t\tlsym->sym.size = r_read_le32 (cursor + 0x4);\n\t\t\tlsym->sym.unk1 = r_read_le32 (cursor + 0x8);\n\t\t\tsize_t name_off = r_read_le32 (cursor + 0xc);\n\t\t\tsize_t mangled_name_off = r_read_le32 (cursor + 0x10);\n\t\t\tlsym->sym.unk2 = (st32)r_read_le32 (cursor + 0x14);\n\t\t\tsize_t file_name_off = r_read_le32 (cursor + 0x18);\n\t\t\tlsym->flc.line = r_read_le32 (cursor + 0x1c);\n\t\t\tlsym->flc.col = r_read_le32 (cursor + 0x20);\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tlsym->sym.name = str_dup_safe (b, string_origin + name_off, end);\n\t\t\tif (!lsym->sym.name) {\n\t\t\t\tcursor += R_CS_EL_SIZE_LSYM;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tlsym->sym.mangled_name = str_dup_safe (b, string_origin + mangled_name_off, end);\n\t\t\tif (!lsym->sym.mangled_name) {\n\t\t\t\tcursor += R_CS_EL_SIZE_LSYM;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tif (!string_origin) {\n\t\t\t\tcursor += R_CS_EL_SIZE_LSYM;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlsym->flc.file = str_dup_safe (b, string_origin + file_name_off, end);\n\t\t\tif (!lsym->flc.file) {\n\t\t\t\tcursor += R_CS_EL_SIZE_LSYM;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcursor += R_CS_EL_SIZE_LSYM;\n\t\t\tmeta_add_fileline (bf, r_coresym_cache_element_pa2va (result, lsym->sym.paddr), lsym->sym.size, &lsym->flc);\n\t\t}\n\t}\n\tif (hdr->n_line_info) {\n\t\tresult->line_info = R_NEWS0 (RCoreSymCacheElementLineInfo, hdr->n_line_info);\n\t\tif (!result->line_info) {\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t i;\n\t\tut8 *cursor = b + start_of_line_info;\n\t\tfor (i = 0; i < hdr->n_line_info && cursor + R_CS_EL_SIZE_LINFO <= end; i++) {\n\t\t\tRCoreSymCacheElementLineInfo *info = &result->line_info[i];\n\t\t\tinfo->paddr = r_read_le32 (cursor);\n\t\t\tinfo->size = r_read_le32 (cursor + 4);\n\t\t\tsize_t file_name_off = r_read_le32 (cursor + 8);\n\t\t\tinfo->flc.line = r_read_le32 (cursor + 0xc);\n\t\t\tinfo->flc.col = r_read_le32 (cursor + 0x10);\n\t\t\tstring_origin = relative_to_strings? b + start_of_strings : cursor;\n\t\t\tinfo->flc.file = str_dup_safe (b, string_origin + file_name_off, end);\n\t\t\tif (!info->flc.file) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcursor += R_CS_EL_SIZE_LINFO;\n\t\t\tmeta_add_fileline (bf, r_coresym_cache_element_pa2va (result, info->paddr), info->size, &info->flc);\n\t\t}\n\t}\n\n\t/*\n\t * TODO:\n\t * Figure out the meaning of the 2 arrays of hdr->n_symbols\n\t * 32-bit integers located at the end of line info.\n\t * Those are the last info before the strings at the end.\n\t */\n\nbeach:\n\tfree (b);\n\treturn result;\n}\n\n", "/* radare - LGPL - Copyright 2018-2022 - pancake */\n\n#include <r_types.h>\n#include <r_util.h>\n#include <r_lib.h>\n#include <r_bin.h>\n#include <ht_uu.h>\n#include \"../i/private.h\"\n#include \"mach0/coresymbolication.h\"\n\n// enable debugging messages\n#define D if (0)\n#define R_UUID_LENGTH 33\n\ntypedef struct symbols_header_t {\n\tut32 magic;\n\tut32 version;\n\tut8 uuid[16];\n\tut32 unk0;\n\tut32 unk1;\n\tut32 slotsize;\n\tut32 addr;\n\tbool valid;\n\tint size;\n} SymbolsHeader;\n\ntypedef struct symbols_metadata_t { // 0x40\n\tut32 cputype;\n\tut32 subtype;\n\tut32 n_segments;\n\tut32 namelen;\n\tut32 name;\n\tbool valid;\n\tut32 size;\n\t//RList *segments;\n\tut32 addr;\n\tint bits;\n\tconst char *arch;\n\tconst char *cpu;\n} SymbolsMetadata;\n\n// header starts at offset 0 and ends at offset 0x40\nstatic SymbolsHeader parseHeader(RBuffer *buf) {\n\tut8 b[64];\n\tSymbolsHeader sh = {0};\n\t(void)r_buf_read_at (buf, 0, b, sizeof (b));\n\tsh.magic = r_read_le32 (b);\n\tsh.version = r_read_le32 (b + 4);\n\tsh.valid = sh.magic == 0xff01ff02;\n\tint i;\n\tfor (i = 0; i < 16; i++) {\n\t\tsh.uuid[i] = b[24 + i];\n\t}\n\tsh.unk0 = r_read_le16 (b + 0x28);\n\tsh.unk1 = r_read_le16 (b + 0x2c); // is slotsize + 1 :?\n\tsh.slotsize = r_read_le16 (b + 0x2e);\n\tsh.size = 0x40;\n\treturn sh;\n}\n\nstatic const char *typeString(ut32 n, int *bits) {\n\t*bits = 32;\n\tif (n == 12) { // CPU_SUBTYPE_ARM_V7) {\n\t\treturn \"arm\";\n\t}\n\tif (n == 0x0100000c) { // arm64\n\t\t*bits = 64;\n\t\treturn \"arm\";\n\t}\n\tif (n == 0x0200000c) { // arm64-32\n\t\t//  TODO: must change bits\n\t\t*bits = 64;\n\t\treturn \"arm\";\n\t}\n\treturn \"x86\";\n}\n\nstatic const char *subtypeString(int n) {\n\tif (n == 9) { // CPU_SUBTYPE_ARM_V7) {\n\t\treturn \"armv7\";\n\t}\n\treturn \"?\";\n}\n\n// metadata section starts at offset 0x40 and ends around 0xb0 depending on filenamelength\nstatic SymbolsMetadata parseMetadata(RBuffer *buf, int off) {\n\tSymbolsMetadata sm = {0};\n\tut8 b[0x100] = {0};\n\t(void)r_buf_read_at (buf, off, b, sizeof (b));\n\tsm.addr = off;\n\tsm.cputype = r_read_le32 (b);\n\tsm.arch = typeString (sm.cputype, &sm.bits);\n\t//  eprintf (\"0x%08x  cputype  0x%x -> %s\\n\", 0x40, sm.cputype, typeString (sm.cputype));\n\t// bits = (strstr (typeString (sm.cputype, &sm.bits), \"64\"))? 64: 32;\n\tsm.subtype = r_read_le32 (b + 4);\n\tsm.cpu = subtypeString (sm.subtype);\n\t//  eprintf (\"0x%08x  subtype  0x%x -> %s\\n\", 0x44, sm.subtype, subtypeString (sm.subtype));\n\tsm.n_segments = r_read_le32 (b + 8);\n\t// int count = r_read_le32 (b + 0x48);\n\tsm.namelen = r_read_le32 (b + 0xc);\n\t// eprintf (\"0x%08x  count    %d\\n\", 0x48, count);\n\t// eprintf (\"0x%08x  strlen   %d\\n\", 0x4c, sm.namelen);\n\t// eprintf (\"0x%08x  filename %s\\n\", 0x50, b + 16);\n\tint delta = 16;\n\t//sm.segments = parseSegments (buf, off + sm.namelen + delta, sm.n_segments);\n\tsm.size = (sm.n_segments * 32) + sm.namelen + delta;\n\n\t// hack to detect format\n\tut32 nm, nm2, nm3;\n\tr_buf_read_at (buf, off + sm.size, (ut8 *)&nm, sizeof (nm));\n\tr_buf_read_at (buf, off + sm.size + 4, (ut8 *)&nm2, sizeof (nm2));\n\tr_buf_read_at (buf, off + sm.size + 8, (ut8 *)&nm3, sizeof (nm3));\n\t// eprintf (\"0x%x next %x %x %x\\n\", off + sm.size, nm, nm2, nm3);\n\tif (r_read_le32 (&nm3) != 0xa1b22b1a) {\n\t\tsm.size -= 8;\n\t\t//\t\tis64 = true;\n\t}\n\treturn sm;\n}\n\nstatic RBinSection *bin_section_from_section(RCoreSymCacheElementSection *sect) {\n\tif (!sect->name) {\n\t\treturn NULL;\n\t}\n\tRBinSection *s = R_NEW0 (RBinSection);\n\tif (!s) {\n\t\treturn NULL;\n\t}\n\ts->name = r_str_ndup (sect->name, 256);\n\ts->size = sect->size;\n\ts->vsize = s->size;\n\ts->paddr = sect->paddr;\n\ts->vaddr = sect->vaddr;\n\ts->add = true;\n\ts->perm = strstr (s->name, \"TEXT\") ? 5 : 4;\n\ts->is_segment = false;\n\treturn s;\n}\n\nstatic RBinSection *bin_section_from_segment(RCoreSymCacheElementSegment *seg) {\n\tif (!seg->name) {\n\t\treturn NULL;\n\t}\n\tRBinSection *s = R_NEW0 (RBinSection);\n\tif (!s) {\n\t\treturn NULL;\n\t}\n\ts->name = r_str_ndup (seg->name, 16);\n\ts->size = seg->size;\n\ts->vsize = seg->vsize;\n\ts->paddr = seg->paddr;\n\ts->vaddr = seg->vaddr;\n\ts->add = true;\n\ts->perm = strstr (s->name, \"TEXT\") ? 5 : 4;\n\ts->is_segment = true;\n\treturn s;\n}\n\nstatic RBinSymbol *bin_symbol_from_symbol(RCoreSymCacheElement *element, RCoreSymCacheElementSymbol *s) {\n\tif (!s->name && !s->mangled_name) {\n\t\treturn NULL;\n\t}\n\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\tif (sym) {\n\t\tif (s->name && s->mangled_name) {\n\t\t\tsym->dname = strdup (s->name);\n\t\t\tsym->name = strdup (s->mangled_name);\n\t\t} else if (s->name) {\n\t\t\tsym->name = strdup (s->name);\n\t\t} else if (s->mangled_name) {\n\t\t\tsym->name = s->mangled_name;\n\t\t}\n\t\tsym->paddr = s->paddr;\n\t\tsym->vaddr = r_coresym_cache_element_pa2va (element, s->paddr);\n\t\tsym->size = s->size;\n\t\tsym->type = R_BIN_TYPE_FUNC_STR;\n\t\tsym->bind = \"NONE\";\n\t}\n\treturn sym;\n}\n\nstatic RCoreSymCacheElement *parseDragons(RBinFile *bf, RBuffer *buf, int off, int bits, R_OWN char *file_name) {\n\tD eprintf (\"Dragons at 0x%x\\n\", off);\n\tst64 size = r_buf_size (buf);\n\tif (off >= size) {\n\t\treturn NULL;\n\t}\n\tsize -= off;\n\tif (!size) {\n\t\treturn NULL;\n\t}\n\tif (size < 32) {\n\t\treturn NULL;\n\t}\n\tut8 *b = malloc (size);\n\tif (!b) {\n\t\treturn NULL;\n\t}\n\tint available = r_buf_read_at (buf, off, b, size);\n\tif (available != size) {\n\t\teprintf (\"Warning: r_buf_read_at failed\\n\");\n\t\treturn NULL;\n\t}\n#if 0\n\t// after the list of sections, there's a bunch of unknown\n\t// data, brobably dwords, and then the same section list again\n\t// this function aims to parse it.\n\t0x00000138 |1a2b b2a1 0300 0000 1a2b b2a1 e055 0000| .+.......+...U..\n                         n_segments ----.          .--- how many sections ?\n\t0x00000148 |0100 0000 ca55 0000 0400 0000 1800 0000| .....U..........\n\t             .---- how many symbols? 0xc7\n\t0x00000158 |c700 0000 0000 0000 0000 0000 0104 0000| ................\n\t0x00000168 |250b e803 0000 0100 0000 0000 bd55 0000| %............U..\n\t0x00000178 |91bb e903 e35a b42c 93a4 340a 8746 9489| .....Z.,..4..F..\n\t0x00000188 |0cea 4c40 0c00 0000 0900 0000 0000 0000| ..L@............\n\t0x00000198 |0000 0000 0000 0000 0000 0000 0000 0000| ................\n\t0x000001a8 |0080 0000 0000 0000 5f5f 5445 5854 0000| ........__TEXT..\n\t0x000001b8 |0000 0000 0000 0000 0080 0000 0000 0000| ................\n\t0x000001c8 |0040 0000 0000 0000 5f5f 4441 5441 0000| .@......__DATA..\n\t0x000001d8 |0000 0000 0000 0000 00c0 0000 0000 0000| ................\n\t0x000001e8 |0000 0100 0000 0000 5f5f 4c4c 564d 0000| ........__LLVM..\n\t0x000001f8 |0000 0000 0000 0000 00c0 0100 0000 0000| ................\n\t0x00000208 |00c0 0000 0000 0000 5f5f 4c49 4e4b 4544| ........__LINKED\n\t0x00000218 |4954 0000 0000 0000 0000 0000 d069 0000| IT...........i..\n#endif\n\t// eprintf (\"Dragon's magic:\\n\");\n\tint magicCombo = 0;\n\tif (!memcmp (\"\\x1a\\x2b\\xb2\\xa1\", b, 4)) { // 0x130  ?\n\t\tmagicCombo++;\n\t}\n\tif (!memcmp (\"\\x1a\\x2b\\xb2\\xa1\", b + 8, 4)) {\n\t\tmagicCombo++;\n\t}\n\tif (magicCombo != 2) {\n\t\t// hack for C22F7494\n\t\tavailable = r_buf_read_at (buf, off - 8, b, size);\n\t\tif (available != size) {\n\t\t\teprintf (\"Warning: r_buf_read_at failed\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!memcmp (\"\\x1a\\x2b\\xb2\\xa1\", b, 4)) { // 0x130  ?\n\t\t\toff -= 8;\n\t\t} else {\n\t\t\teprintf (\"0x%08x  parsing error: invalid magic retry\\n\", off);\n\t\t}\n\t}\n\tD eprintf (\"0x%08x  magic  OK\\n\", off);\n\tD {\n\t\tconst int e0ss = r_read_le32 (b + 12);\n\t\teprintf (\"0x%08x  eoss   0x%x\\n\", off + 12, e0ss);\n\t}\n\tfree (b);\n\treturn r_coresym_cache_element_new (bf, buf, off + 16, bits, file_name);\n}\n\nstatic bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {\n#if 0\n\tSYMBOLS HEADER\n\n 0\tMAGIC\t02ff01ff\n 4\tVERSION 1 (little endian)\n 8      ffffffff\n16      002b0000 01000000 { 0x2b00, 0x0000 }\n24\tUUID    16 bytes\n40\t2621 d85b 2100 2000 0000 0000 0000 0000\n56\tffff ffff ffff ff7f 0c00 0000 0900 0000\n72\t0400 0000 6800 0000 2f76 6172 2f66 6f6c .... 4, 104 /// 104 length string\n184\n0x000000b8  5f5f 5445 5854 0000 0000 0000 0000 0000 0000 0000 0000 0000 0080 0000 0000 0000  __TEXT..........................\n0x000000d8  5f5f 4441 5441 0000 0000 0000 0000 0000 0080 0000 0000 0000 0040 0000 0000 0000  __DATA...................@......\n0x000000f8  5f5f 4c4c 564d 0000 0000 0000 0000 0000 00c0 0000 0000 0000 0000 0100 0000 0000  __LLVM..........................\n0x00000118  5f5f 4c49 4e4b 4544 4954 0000 0000 0000 00c0 0100 0000 0000 00c0 0000 0000 0000  __LINKEDIT......................\n\n#endif\n\t// 0 - magic check, version ...\n\tSymbolsHeader sh = parseHeader (buf);\n\tif (!sh.valid) {\n\t\teprintf (\"Invalid headers\\n\");\n\t\treturn false;\n\t}\n\tSymbolsMetadata sm = parseMetadata (buf, 0x40);\n\tchar * file_name = NULL;\n\tif (sm.namelen) {\n\t\tfile_name = calloc (sm.namelen + 1, 1);\n\t\tif (!file_name) {\n\t\t\treturn false;\n\t\t}\n\t\tif (r_buf_read_at (buf, 0x50, (ut8*)file_name, sm.namelen) != sm.namelen) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tRCoreSymCacheElement *element = parseDragons (bf, buf, sm.addr + sm.size, sm.bits, file_name);\n\tif (element) {\n\t\t*bin_obj = element;\n\t\treturn true;\n\t}\n\tfree (file_name);\n\treturn false;\n}\n\nstatic RList *sections(RBinFile *bf) {\n\tRList *res = r_list_newf ((RListFree)r_bin_section_free);\n\tr_return_val_if_fail (res && bf->o && bf->o->bin_obj, res);\n\tRCoreSymCacheElement *element = bf->o->bin_obj;\n\tsize_t i;\n\tif (element->segments) {\n\t\tfor (i = 0; i < element->hdr->n_segments; i++) {\n\t\t\tRCoreSymCacheElementSegment *seg = &element->segments[i];\n\t\t\tRBinSection *s = bin_section_from_segment (seg);\n\t\t\tif (s) {\n\t\t\t\tr_list_append (res, s);\n\t\t\t}\n\t\t}\n\t}\n\tif (element->sections) {\n\t\tfor (i = 0; i < element->hdr->n_sections; i++) {\n\t\t\tRCoreSymCacheElementSection *sect = &element->sections[i];\n\t\t\tRBinSection *s = bin_section_from_section (sect);\n\t\t\tif (s) {\n\t\t\t\tr_list_append (res, s);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nstatic ut64 baddr(RBinFile *bf) {\n\treturn 0LL;\n}\n\nstatic RBinInfo *info(RBinFile *bf) {\n\tSymbolsMetadata sm = parseMetadata (bf->buf, 0x40);\n\tRBinInfo *ret = R_NEW0 (RBinInfo);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->file = strdup (bf->file);\n\tret->bclass = strdup (\"symbols\");\n\tret->os = strdup (\"unknown\");\n\tret->arch = sm.arch ? strdup (sm.arch) : NULL;\n\tret->bits = sm.bits;\n\tret->type = strdup (\"Symbols file\");\n\tret->subsystem = strdup (\"llvm\");\n\tret->has_va = true;\n\n\treturn ret;\n}\n\nstatic bool check_buffer(RBinFile *bf, RBuffer *b) {\n\tut8 buf[4];\n\tr_buf_read_at (b, 0, buf, sizeof (buf));\n\treturn !memcmp (buf, \"\\x02\\xff\\x01\\xff\", 4);\n}\n\nstatic RList *symbols(RBinFile *bf) {\n\tr_return_val_if_fail (bf && bf->o && bf->o->bin_obj, NULL);\n\tRCoreSymCacheElement *element = bf->o->bin_obj;\n\tsize_t i;\n\tHtUU *hash = ht_uu_new0 ();\n\tif (!hash) {\n\t\treturn NULL;\n\t}\n\tRList *res = r_list_newf ((RListFree)r_bin_symbol_free);\n\tbool found = false;\n\tif (element->lined_symbols) {\n\t\tfor (i = 0; i < element->hdr->n_lined_symbols; i++) {\n\t\t\tRCoreSymCacheElementSymbol *sym = (RCoreSymCacheElementSymbol *)&element->lined_symbols[i];\n\t\t\tif (!sym) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tht_uu_find (hash, sym->paddr, &found);\n\t\t\tif (found) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRBinSymbol *s = bin_symbol_from_symbol (element, sym);\n\t\t\tif (s) {\n\t\t\t\tr_list_append (res, s);\n\t\t\t\tht_uu_insert (hash, sym->paddr, 1);\n\t\t\t}\n\t\t}\n\t}\n\tif (element->symbols) {\n\t\tfor (i = 0; i < element->hdr->n_symbols; i++) {\n\t\t\tRCoreSymCacheElementSymbol *sym = &element->symbols[i];\n\t\t\tht_uu_find (hash, sym->paddr, &found);\n\t\t\tif (found) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRBinSymbol *s = bin_symbol_from_symbol (element, sym);\n\t\t\tif (s) {\n\t\t\t\tr_list_append (res, s);\n\t\t\t}\n\t\t}\n\t}\n\tht_uu_free (hash);\n\treturn res;\n}\n\nstatic ut64 size(RBinFile *bf) {\n\treturn UT64_MAX;\n}\n\nstatic void destroy(RBinFile *bf) {\n\tr_coresym_cache_element_free (bf->o->bin_obj);\n}\n\nstatic void header(RBinFile *bf) {\n\tr_return_if_fail (bf && bf->o);\n\n\tRCoreSymCacheElement *element = bf->o->bin_obj;\n\tif (!element) {\n\t\treturn;\n\t}\n\n\tRBin *bin = bf->rbin;\n\tPrintfCallback p = bin->cb_printf;\n\tPJ *pj = pj_new ();\n\tif (!pj) {\n\t\treturn;\n\t}\n\n\tpj_o (pj);\n\tpj_kn (pj, \"cs_version\", element->hdr->version);\n\tpj_kn (pj, \"size\", element->hdr->size);\n\tif (element->file_name) {\n\t\tpj_ks (pj, \"name\", element->file_name);\n\t}\n\tif (element->binary_version) {\n\t\tpj_ks (pj, \"version\", element->binary_version);\n\t}\n\tchar uuidstr[R_UUID_LENGTH];\n\tr_hex_bin2str (element->hdr->uuid, 16, uuidstr);\n\tpj_ks (pj, \"uuid\", uuidstr);\n\tpj_kn (pj, \"segments\", element->hdr->n_segments);\n\tpj_kn (pj, \"sections\", element->hdr->n_sections);\n\tpj_kn (pj, \"symbols\", element->hdr->n_symbols);\n\tpj_kn (pj, \"lined_symbols\", element->hdr->n_lined_symbols);\n\tpj_kn (pj, \"line_info\", element->hdr->n_line_info);\n\tpj_end (pj);\n\n\tp (\"%s\\n\", pj_string (pj));\n\tpj_free (pj);\n}\n\nRBinPlugin r_bin_plugin_symbols = {\n\t.name = \"symbols\",\n\t.desc = \"Apple Symbols file\",\n\t.license = \"MIT\",\n\t.load_buffer = &load_buffer,\n\t.check_buffer = &check_buffer,\n\t.symbols = &symbols,\n\t.sections = &sections,\n\t.size = &size,\n\t.baddr = &baddr,\n\t.info = &info,\n\t.header = &header,\n\t.destroy = &destroy,\n};\n\n#ifndef R2_PLUGIN_INCORE\nR_API RLibStruct radare_plugin = {\n\t.type = R_LIB_TYPE_BIN,\n\t.data = &r_bin_plugin_symbols,\n\t.version = R2_VERSION\n};\n#endif\n"], "filenames": ["libr/bin/format/mach0/coresymbolication.c", "libr/bin/p/bin_symbols.c"], "buggy_code_start_loc": [271, 356], "buggy_code_end_loc": [361, 378], "fixing_code_start_loc": [272, 356], "fixing_code_end_loc": [369, 380], "type": "CWE-787", "message": "Heap-based Buffer Overflow in GitHub repository radareorg/radare2 prior to 5.7.0. The bug causes the program reads data past the end of the intented buffer. Typically, this can allow attackers to read sensitive information from other memory locations or cause a crash.", "other": {"cve": {"id": "CVE-2022-1437", "sourceIdentifier": "security@huntr.dev", "published": "2022-04-22T15:15:07.840", "lastModified": "2022-05-03T20:22:30.833", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Heap-based Buffer Overflow in GitHub repository radareorg/radare2 prior to 5.7.0. The bug causes the program reads data past the end of the intented buffer. Typically, this can allow attackers to read sensitive information from other memory locations or cause a crash."}, {"lang": "es", "value": "Un desbordamiento de b\u00fafer en la regi\u00f3n Heap de la memoria en el repositorio GitHub radareorg/radare2 versiones anteriores a 5.7.0. El fallo causa que el programa lea datos m\u00e1s all\u00e1 del final del b\u00fafer previsto. Normalmente, esto puede permitir a atacantes leer informaci\u00f3n confidencial de otras ubicaciones de memoria o causar un bloqueo"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.2}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-122"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.7.0", "matchCriteriaId": "A79BEA4D-5D5F-4593-B2CA-0CA4C22C1C0A"}]}]}], "references": [{"url": "https://github.com/radareorg/radare2/commit/669a404b6d98d5db409a5ebadae4e94b34ef5136", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/af6c3e9e-b7df-4d80-b48f-77fdd17b4038", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/radareorg/radare2/commit/669a404b6d98d5db409a5ebadae4e94b34ef5136"}}