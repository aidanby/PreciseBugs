{"buggy_code": ["function ItemListHelper(\n    listType,\n    supportedSorting,\n    supportedFilters,\n    defaultSorting,\n    defaultFilters,\n    exclusiveFilters,\n    defaultPageSize,\n    persistPageSize\n) {\n    var self = this;\n\n    self.listType = listType;\n    self.supportedSorting = supportedSorting;\n    self.supportedFilters = supportedFilters;\n    self.defaultSorting = defaultSorting;\n    self.defaultFilters = defaultFilters;\n    self.exclusiveFilters = exclusiveFilters;\n    self.defaultPageSize = defaultPageSize;\n    self.persistPageSize = !!persistPageSize;\n\n    self.searchFunction = undefined;\n\n    self.allItems = [];\n    self.allSize = ko.observable(0);\n\n    self.items = ko.observableArray([]);\n    self.pageSize = ko.observable(self.defaultPageSize);\n    self.currentPage = ko.observable(0);\n    self.currentSorting = ko.observable(self.defaultSorting);\n    self.currentFilters = ko.observableArray(self.defaultFilters);\n    self.selectedItem = ko.observable(undefined);\n    self.filterSearch = ko.observable(true);\n\n    self.storageIds = {\n        currentSorting: self.listType + \".\" + \"currentSorting\",\n        currentFilters: self.listType + \".\" + \"currentFilters\",\n        pageSize: self.listType + \".\" + \"pageSize\"\n    };\n\n    //~~ item handling\n\n    self.refresh = function () {\n        self._updateItems();\n    };\n\n    self.updateItems = function (items) {\n        if (items === undefined) items = [];\n        self.allItems = items;\n        self.allSize(items.length);\n        self._updateItems();\n    };\n\n    self.selectItem = function (matcher) {\n        var itemList = self.items();\n        for (var i = 0; i < itemList.length; i++) {\n            if (matcher(itemList[i])) {\n                self.selectedItem(itemList[i]);\n                return true;\n            }\n        }\n        return false;\n    };\n\n    self.selectNone = function () {\n        self.selectedItem(undefined);\n    };\n\n    self.isSelected = function (data) {\n        return self.selectedItem() === data;\n    };\n\n    self.isSelectedByMatcher = function (matcher) {\n        return matcher(self.selectedItem());\n    };\n\n    self.removeItem = function (matcher) {\n        var index = self.getIndex(matcher, true);\n        if (index > -1) {\n            self.allItems.splice(index, 1);\n            self._updateItems();\n        }\n    };\n\n    self.updateItem = function (matcher, item) {\n        var index = self.allItems.findIndex(matcher);\n        if (index > -1) {\n            self.allItems[index] = item;\n            self._updateItems();\n        }\n    };\n\n    self.addItem = function (item) {\n        self.allItems.push(item);\n        self._updateItems();\n    };\n\n    //~~ pagination\n\n    self.paginatedItems = ko.dependentObservable(function () {\n        if (self.items() === undefined) {\n            return [];\n        } else if (self.pageSize() === 0) {\n            return self.items();\n        } else {\n            var from = Math.max(self.currentPage() * self.pageSize(), 0);\n            var to = Math.min(from + self.pageSize(), self.items().length);\n            return self.items().slice(from, to);\n        }\n    });\n    self.lastPage = ko.dependentObservable(function () {\n        return self.pageSize() === 0\n            ? 1\n            : Math.ceil(self.items().length / self.pageSize()) - 1;\n    });\n    self.pages = ko.dependentObservable(function () {\n        var pages = [];\n        var i;\n\n        if (self.pageSize() === 0) {\n            pages.push({number: 0, text: 1});\n        } else if (self.lastPage() < 7) {\n            for (i = 0; i < self.lastPage() + 1; i++) {\n                pages.push({number: i, text: i + 1});\n            }\n        } else {\n            pages.push({number: 0, text: 1});\n            if (self.currentPage() < 5) {\n                for (i = 1; i < 5; i++) {\n                    pages.push({number: i, text: i + 1});\n                }\n                pages.push({number: -1, text: \"\u2026\"});\n            } else if (self.currentPage() > self.lastPage() - 5) {\n                pages.push({number: -1, text: \"\u2026\"});\n                for (i = self.lastPage() - 4; i < self.lastPage(); i++) {\n                    pages.push({number: i, text: i + 1});\n                }\n            } else {\n                pages.push({number: -1, text: \"\u2026\"});\n                for (i = self.currentPage() - 1; i <= self.currentPage() + 1; i++) {\n                    pages.push({number: i, text: i + 1});\n                }\n                pages.push({number: -1, text: \"\u2026\"});\n            }\n            pages.push({number: self.lastPage(), text: self.lastPage() + 1});\n        }\n        return pages;\n    });\n\n    self.switchToItem = function (matcher) {\n        var pos = -1;\n        var itemList = self.items();\n        for (var i = 0; i < itemList.length; i++) {\n            if (matcher(itemList[i])) {\n                pos = i;\n                break;\n            }\n        }\n\n        if (pos > -1) {\n            var page = Math.floor(pos / self.pageSize());\n            self.changePage(page);\n        }\n    };\n\n    self.changePage = function (newPage) {\n        if (newPage < 0 || newPage > self.lastPage()) return;\n        self.currentPage(newPage);\n    };\n    self.prevPage = function () {\n        if (self.currentPage() > 0) {\n            self.currentPage(self.currentPage() - 1);\n        }\n    };\n    self.nextPage = function () {\n        if (self.currentPage() < self.lastPage()) {\n            self.currentPage(self.currentPage() + 1);\n        }\n    };\n\n    self.getIndex = function (matcher, all) {\n        var itemList;\n        if (all !== undefined && all === true) {\n            itemList = self.allItems;\n        } else {\n            itemList = self.items();\n        }\n\n        for (var i = 0; i < itemList.length; i++) {\n            if (matcher(itemList[i])) {\n                return i;\n            }\n        }\n        return -1;\n    };\n\n    self.getItem = function (matcher, all) {\n        var index = self.getIndex(matcher, all);\n        if (all !== undefined && all === true) {\n            return index > -1 ? self.allItems[index] : undefined;\n        } else {\n            return index > -1 ? self.items()[index] : undefined;\n        }\n    };\n\n    self.resetPage = function () {\n        if (self.currentPage() > self.lastPage()) {\n            self.currentPage(self.lastPage());\n        }\n    };\n\n    //~~ searching\n\n    self.changeSearchFunction = function (searchFunction) {\n        self.searchFunction = searchFunction;\n        self.changePage(0);\n        self._updateItems();\n    };\n\n    self.resetSearch = function () {\n        self.changeSearchFunction(undefined);\n    };\n\n    //~~ sorting\n\n    self.changeSorting = function (sorting) {\n        if (!_.contains(_.keys(self.supportedSorting), sorting)) return;\n\n        self.currentSorting(sorting);\n        self._saveCurrentSortingToLocalStorage();\n\n        self.changePage(0);\n        self._updateItems();\n    };\n\n    //~~ filtering\n\n    self.setFilterSearch = function (enabled) {\n        if (self.filterSearch() === enabled) return;\n\n        self.filterSearch(enabled);\n        self.changePage(0);\n        self._updateItems();\n    };\n\n    self.toggleFilterSearch = function () {\n        self.setFilterSearch(!self.filterSearch());\n    };\n\n    self.toggleFilter = function (filter) {\n        if (!_.contains(_.keys(self.supportedFilters), filter)) return;\n\n        if (_.contains(self.currentFilters(), filter)) {\n            self.removeFilter(filter);\n        } else {\n            self.addFilter(filter);\n        }\n    };\n\n    self.addFilter = function (filter) {\n        if (!_.contains(_.keys(self.supportedFilters), filter)) return;\n\n        for (var i = 0; i < self.exclusiveFilters.length; i++) {\n            if (_.contains(self.exclusiveFilters[i], filter)) {\n                for (var j = 0; j < self.exclusiveFilters[i].length; j++) {\n                    if (self.exclusiveFilters[i][j] === filter) continue;\n                    self.removeFilter(self.exclusiveFilters[i][j]);\n                }\n            }\n        }\n\n        var filters = self.currentFilters();\n        filters.push(filter);\n        self.currentFilters(filters);\n        self._saveCurrentFiltersToLocalStorage();\n\n        self.changePage(0);\n        self._updateItems();\n    };\n\n    self.removeFilter = function (filter) {\n        if (!_.contains(_.keys(self.supportedFilters), filter)) return;\n\n        var filters = self.currentFilters();\n        filters = _.without(filters, filter);\n        self.currentFilters(filters);\n        self._saveCurrentFiltersToLocalStorage();\n\n        self.changePage(0);\n        self._updateItems();\n    };\n\n    //~~ update for sorted and filtered view\n\n    self._updateItems = function () {\n        // determine comparator\n        var comparator = undefined;\n        var currentSorting = self.currentSorting();\n        if (\n            typeof currentSorting !== \"undefined\" &&\n            typeof self.supportedSorting[currentSorting] !== \"undefined\"\n        ) {\n            comparator = self.supportedSorting[currentSorting];\n        }\n\n        // work on all items\n        var result = self.allItems;\n\n        var hasSearch = typeof self.searchFunction !== \"undefined\" && self.searchFunction;\n\n        // filter if we're not searching or have search filtering enabled\n        if (!hasSearch || self.filterSearch()) {\n            var filters = self.currentFilters();\n            _.each(filters, function (filter) {\n                if (\n                    typeof filter !== \"undefined\" &&\n                    typeof supportedFilters[filter] !== \"undefined\"\n                )\n                    result = _.filter(result, supportedFilters[filter]);\n            });\n        }\n\n        // search if necessary\n        if (hasSearch) {\n            result = _.filter(result, self.searchFunction);\n        }\n\n        // sort if necessary\n        if (typeof comparator !== \"undefined\") result.sort(comparator);\n\n        // set result list\n        self.items(result);\n    };\n\n    //~~ local storage\n\n    self._saveCurrentSortingToLocalStorage = function () {\n        if (self._initializeLocalStorage()) {\n            var currentSorting = self.currentSorting();\n            if (currentSorting !== undefined)\n                localStorage[self.storageIds.currentSorting] = currentSorting;\n            else localStorage[self.storageIds.currentSorting] = undefined;\n        }\n    };\n\n    self._loadCurrentSortingFromLocalStorage = function () {\n        if (self._initializeLocalStorage()) {\n            if (\n                _.contains(\n                    _.keys(supportedSorting),\n                    localStorage[self.storageIds.currentSorting]\n                )\n            )\n                self.currentSorting(localStorage[self.storageIds.currentSorting]);\n            else self.currentSorting(defaultSorting);\n        }\n    };\n\n    self._saveCurrentFiltersToLocalStorage = function () {\n        if (self._initializeLocalStorage()) {\n            var filters = _.intersection(\n                _.keys(self.supportedFilters),\n                self.currentFilters()\n            );\n            localStorage[self.storageIds.currentFilters] = JSON.stringify(filters);\n        }\n    };\n\n    self._loadCurrentFiltersFromLocalStorage = function () {\n        if (self._initializeLocalStorage()) {\n            self.currentFilters(\n                _.intersection(\n                    _.keys(self.supportedFilters),\n                    JSON.parse(localStorage[self.storageIds.currentFilters])\n                )\n            );\n        }\n    };\n\n    self._savePageSizeToLocalStorage = function (pageSize) {\n        if (self._initializeLocalStorage() && self.persistPageSize) {\n            localStorage[self.storageIds.pageSize] = pageSize;\n        }\n    };\n\n    self.pageSize.subscribe(self._savePageSizeToLocalStorage);\n\n    self._loadPageSizeFromLocalStorage = function () {\n        if (self._initializeLocalStorage() && self.persistPageSize) {\n            self.pageSize(parseInt(localStorage[self.storageIds.pageSize]));\n        }\n    };\n\n    self._initializeLocalStorage = function () {\n        if (!Modernizr.localstorage) return false;\n\n        if (\n            localStorage[self.storageIds.currentSorting] !== undefined &&\n            localStorage[self.storageIds.currentFilters] !== undefined &&\n            JSON.parse(localStorage[self.storageIds.currentFilters]) instanceof Array &&\n            localStorage[self.storageIds.pageSize] !== undefined\n        )\n            return true;\n\n        localStorage[self.storageIds.currentSorting] = self.defaultSorting;\n        localStorage[self.storageIds.currentFilters] = JSON.stringify(\n            self.defaultFilters\n        );\n        localStorage[self.storageIds.pageSize] = self.defaultPageSize;\n\n        return true;\n    };\n\n    self._loadCurrentFiltersFromLocalStorage();\n    self._loadCurrentSortingFromLocalStorage();\n    self._loadPageSizeFromLocalStorage();\n}\n\nfunction formatSize(bytes) {\n    if (!bytes) return \"-\";\n\n    var units = [\"bytes\", \"KB\", \"MB\", \"GB\"];\n    for (var i = 0; i < units.length; i++) {\n        if (bytes < 1024) {\n            return _.sprintf(\"%3.1f%s\", bytes, units[i]);\n        }\n        bytes /= 1024;\n    }\n    return _.sprintf(\"%.1f%s\", bytes, \"TB\");\n}\n\nfunction formatHuman(number) {\n    if (number === undefined) return \"-\";\n    if (number < 1000) return number;\n\n    return _.sprintf(\"%.1fK\", number / 1000);\n}\n\nfunction bytesFromSize(size) {\n    if (size === undefined || size.trim() === \"\") return undefined;\n\n    var parsed = size.match(/^([+]?[0-9]*\\.?[0-9]+)(?:\\s*)?(.*)$/);\n    var number = parsed[1];\n    var unit = parsed[2].trim();\n\n    if (unit === \"\") return parseFloat(number);\n\n    var units = {\n        b: 1,\n        byte: 1,\n        bytes: 1,\n        kb: 1024,\n        mb: Math.pow(1024, 2),\n        gb: Math.pow(1024, 3),\n        tb: Math.pow(1024, 4)\n    };\n    unit = unit.toLowerCase();\n\n    if (!units.hasOwnProperty(unit)) {\n        return undefined;\n    }\n\n    var factor = units[unit];\n    return number * factor;\n}\n\nfunction formatDuration(seconds) {\n    if (!seconds) return \"-\";\n    if (seconds < 1) return \"00:00:00\";\n\n    var s = seconds % 60;\n    var m = (seconds % 3600) / 60;\n    var h = seconds / 3600;\n\n    return _.sprintf(\n        gettext(/* L10N: duration format */ \"%(hour)02d:%(minute)02d:%(second)02d\"),\n        {hour: h, minute: m, second: s}\n    );\n}\n\nfunction formatFuzzyEstimation(seconds, base) {\n    if (!seconds || seconds < 1) return \"-\";\n\n    var m;\n    if (base !== undefined) {\n        m = moment(base);\n    } else {\n        m = moment();\n    }\n\n    m.add(seconds, \"s\");\n    return m.fromNow(true);\n}\n\nfunction formatFuzzyPrintTime(totalSeconds) {\n    /**\n     * Formats a print time estimate in a very fuzzy way.\n     *\n     * Accuracy decreases the higher the estimation is:\n     *\n     *   * less than 30s: \"a few seconds\"\n     *   * 30s to a minute: \"less than a minute\"\n     *   * 1 to 30min: rounded to full minutes, above 30s is minute + 1 (\"27 minutes\", \"2 minutes\")\n     *   * 30min to 40min: \"40 minutes\"\n     *   * 40min to 50min: \"50 minutes\"\n     *   * 50min to 1h: \"1 hour\"\n     *   * 1 to 12h: rounded to half hours, 15min to 45min is \".5\", above that hour + 1 (\"4 hours\", \"2.5 hours\")\n     *   * 12 to 24h: rounded to full hours, above 30min is hour + 1, over 23.5h is \"1 day\"\n     *   * Over a day: rounded to half days, 8h to 16h is \".5\", above that days + 1 (\"1 day\", \"4 days\", \"2.5 days\")\n     */\n\n    if (!totalSeconds || totalSeconds < 1) return \"-\";\n\n    var d = moment.duration(totalSeconds, \"seconds\");\n\n    var seconds = d.seconds();\n    var minutes = d.minutes();\n    var hours = d.hours();\n    var days = d.days();\n\n    var replacements = {\n        days: days,\n        hours: hours,\n        minutes: minutes,\n        seconds: seconds,\n        totalSeconds: totalSeconds\n    };\n\n    var text = \"-\";\n\n    if (days >= 1) {\n        // days\n        if (hours >= 16) {\n            replacements.days += 1;\n\n            if (replacements.days === 1) {\n                text = gettext(\"%(days)d day\");\n            } else {\n                text = gettext(\"%(days)d days\");\n            }\n        } else if (hours >= 8 && hours < 16) {\n            text = gettext(\"%(days)d.5 days\");\n        } else {\n            if (days === 1) {\n                text = gettext(\"%(days)d day\");\n            } else {\n                text = gettext(\"%(days)d days\");\n            }\n        }\n    } else if (hours >= 1) {\n        // only hours\n        if (hours < 12) {\n            if (minutes < 15) {\n                // less than .15 => .0\n                if (hours === 1) {\n                    text = gettext(\"%(hours)d hour\");\n                } else {\n                    text = gettext(\"%(hours)d hours\");\n                }\n            } else if (minutes >= 15 && minutes < 45) {\n                // between .25 and .75 => .5\n                text = gettext(\"%(hours)d.5 hours\");\n            } else {\n                // over .75 => hours + 1\n                replacements.hours += 1;\n\n                if (replacements.hours === 1) {\n                    text = gettext(\"%(hours)d hour\");\n                } else {\n                    text = gettext(\"%(hours)d hours\");\n                }\n            }\n        } else {\n            if (hours === 23 && minutes > 30) {\n                // over 23.5 hours => 1 day\n                text = gettext(\"1 day\");\n            } else {\n                if (minutes > 30) {\n                    // over .5 => hours + 1\n                    replacements.hours += 1;\n                }\n                text = gettext(\"%(hours)d hours\");\n            }\n        }\n    } else if (minutes >= 1) {\n        // only minutes\n        if (minutes < 2) {\n            if (seconds < 30) {\n                text = gettext(\"a minute\");\n            } else {\n                text = gettext(\"2 minutes\");\n            }\n        } else if (minutes < 30) {\n            if (seconds > 30) {\n                replacements.minutes += 1;\n            }\n            text = gettext(\"%(minutes)d minutes\");\n        } else if (minutes <= 40) {\n            text = gettext(\"40 minutes\");\n        } else if (minutes <= 50) {\n            text = gettext(\"50 minutes\");\n        } else {\n            text = gettext(\"1 hour\");\n        }\n    } else {\n        // only seconds\n        if (seconds < 30) {\n            text = gettext(\"a few seconds\");\n        } else {\n            text = gettext(\"less than a minute\");\n        }\n    }\n\n    return _.sprintf(text, replacements);\n}\n\nfunction formatDate(unixTimestamp, options) {\n    if (!options) {\n        options = {seconds: false};\n    }\n\n    if (!unixTimestamp) return \"-\";\n\n    var format = gettext(/* L10N: Date format */ \"YYYY-MM-DD HH:mm\");\n    if (options.seconds) {\n        format = gettext(/* L10N: Date format with seconds */ \"YYYY-MM-DD HH:mm:ss\");\n    }\n\n    return moment.unix(unixTimestamp).format(format);\n}\n\nfunction formatTimeAgo(unixTimestamp) {\n    if (!unixTimestamp) return \"-\";\n    return moment.unix(unixTimestamp).fromNow();\n}\n\nfunction formatFilament(filament) {\n    if (!filament || !filament[\"length\"]) return \"-\";\n    var result = \"%(length).02fm\";\n    if (filament.hasOwnProperty(\"volume\") && filament.volume) {\n        result += \" / \" + \"%(volume).02fcm\u00b3\";\n    }\n    return _.sprintf(result, {\n        length: filament[\"length\"] / 1000,\n        volume: filament[\"volume\"]\n    });\n}\n\nfunction cleanTemperature(temp, offThreshold) {\n    if (temp === undefined || !_.isNumber(temp)) return \"-\";\n    if (offThreshold !== undefined && temp < offThreshold) return gettext(\"off\");\n    return temp;\n}\n\nfunction formatTemperature(temp, showF, offThreshold) {\n    if (temp === undefined || !_.isNumber(temp)) return \"-\";\n    if (offThreshold !== undefined && temp < offThreshold) return gettext(\"off\");\n    if (showF) {\n        return _.sprintf(\"%.1f&deg;C (%.1f&deg;F)\", temp, (temp * 9) / 5 + 32);\n    } else {\n        return _.sprintf(\"%.1f&deg;C\", temp);\n    }\n}\n\nfunction formatNumberK(num) {\n    if (num > 1000) {\n        num = num / 1000.0;\n        return _.sprintf(\"%.2fk\", num);\n    } else {\n        return _.sprintf(\"%i\", num);\n    }\n}\n\nfunction pnotifyAdditionalInfo(inner) {\n    return (\n        '<div class=\"pnotify_additional_info\">' +\n        '<div class=\"pnotify_more\"><a href=\"#\" onclick=\"$(this).children().toggleClass(\\'icon-caret-right icon-caret-down\\').parent().parent().next().slideToggle(\\'fast\\')\">More <i class=\"icon-caret-right\"></i></a></div>' +\n        '<div class=\"pnotify_more_container hide\">' +\n        inner +\n        \"</div>\" +\n        \"</div>\"\n    );\n}\n\nfunction ping(url, callback) {\n    var img = new Image();\n    var calledBack = false;\n\n    img.onload = function () {\n        callback(true);\n        calledBack = true;\n    };\n    img.onerror = function () {\n        if (!calledBack) {\n            callback(true);\n            calledBack = true;\n        }\n    };\n    img.src = url;\n    setTimeout(function () {\n        if (!calledBack) {\n            callback(false);\n            calledBack = true;\n        }\n    }, 1500);\n}\n\nfunction showOfflineOverlay(title, message, reconnectCallback) {\n    if (title === undefined) {\n        title = gettext(\"Server is offline\");\n    }\n\n    $(\"#offline_overlay_title\").text(title);\n    $(\"#offline_overlay_message\").html(message);\n    $(\"#offline_overlay_reconnect\").click(reconnectCallback);\n\n    var overlay = $(\"#offline_overlay\");\n    if (!overlay.is(\":visible\")) overlay.show();\n}\n\nfunction hideOfflineOverlay() {\n    $(\"#offline_overlay\").hide();\n}\n\nfunction showMessageDialog(msg, options) {\n    options = options || {};\n    if (_.isPlainObject(msg)) {\n        options = msg;\n    } else {\n        options.message = msg;\n    }\n\n    var title = options.title || \"\";\n    var message = options.message || \"\";\n    var close = options.close || gettext(\"Close\");\n    var onclose = options.onclose || undefined;\n    var onshow = options.onshow || undefined;\n    var onshown = options.onshown || undefined;\n    var nofade = options.nofade || false;\n\n    if (_.isString(message)) {\n        message = $(\"<p>\" + message + \"</p>\");\n    }\n\n    var modalHeader = $(\n        '<a href=\"javascript:void(0)\" class=\"close\" data-dismiss=\"modal\" aria-hidden=\"true\">&times;</a><h3>' +\n            title +\n            \"</h3>\"\n    );\n    var modalBody = $(message);\n    var modalFooter = $(\n        '<a href=\"javascript:void(0)\" class=\"btn\" data-dismiss=\"modal\" aria-hidden=\"true\">' +\n            close +\n            \"</a>\"\n    );\n\n    var modal = $(\"<div></div>\").addClass(\"modal hide\");\n    if (!nofade) {\n        modal.addClass(\"fade-in\");\n    }\n    modal\n        .append($(\"<div></div>\").addClass(\"modal-header\").append(modalHeader))\n        .append($(\"<div></div>\").addClass(\"modal-body\").append(modalBody))\n        .append($(\"<div></div>\").addClass(\"modal-footer\").append(modalFooter));\n\n    modal.on(\"hidden\", function () {\n        if (onclose && _.isFunction(onclose)) {\n            onclose();\n        }\n    });\n\n    if (onshow) {\n        modal.on(\"show\", onshow);\n    }\n\n    if (onshown) {\n        modal.on(\"shown\", onshown);\n    }\n\n    modal.modal(\"show\");\n    return modal;\n}\n\nfunction showConfirmationDialog(msg, onacknowledge, options) {\n    options = options || {};\n    if (_.isPlainObject(msg)) {\n        options = msg;\n    } else {\n        options.message = msg;\n        options.onproceed = onacknowledge;\n    }\n\n    var title = options.title || gettext(\"Are you sure?\");\n\n    var message = options.message || \"\";\n    var question = options.question || gettext(\"Are you sure you want to proceed?\");\n\n    var html = options.html;\n\n    var checkboxes = options.checkboxes;\n\n    var cancel = options.cancel || gettext(\"Cancel\");\n    var proceed = options.proceed || gettext(\"Proceed\");\n    var proceedClass = options.proceedClass || \"danger\";\n    var onproceed = options.onproceed || undefined;\n    var oncancel = options.oncancel || undefined;\n    var onclose = options.onclose || undefined;\n    var dialogClass = options.dialogClass || \"\";\n    var nofade = options.nofade || false;\n    var noclose = options.noclose || false;\n\n    var modalHeader;\n    if (noclose) {\n        modalHeader = $(\"<h3>\" + title + \"</h3>\");\n    } else {\n        modalHeader = $(\n            '<a href=\"javascript:void(0)\" class=\"close\" data-dismiss=\"modal\" aria-hidden=\"true\">&times;</a><h3>' +\n                title +\n                \"</h3>\"\n        );\n    }\n\n    var modalBody;\n    if (html) {\n        modalBody = $(html);\n    } else {\n        modalBody = $(\"<p>\" + message + \"</p><p>\" + question + \"</p>\");\n    }\n\n    var cancelButton = $('<a href=\"javascript:void(0)\" class=\"btn\">' + cancel + \"</a>\")\n        .attr(\"data-dismiss\", \"modal\")\n        .attr(\"aria-hidden\", \"true\");\n\n    if (!_.isArray(proceed)) {\n        proceed = [proceed];\n    }\n\n    var proceedButtons = [];\n    _.each(proceed, function (text) {\n        proceedButtons.push(\n            $('<a href=\"javascript:void(0)\" class=\"btn\">' + text + \"</a>\").addClass(\n                \"btn-\" + proceedClass\n            )\n        );\n    });\n\n    var modal = $(\"<div></div>\").addClass(\"modal hide\");\n    if (!nofade) {\n        modal.addClass(\"fade-in\");\n    }\n\n    var buttons = $(\"<div></div>\").addClass(\"modal-footer\").append(cancelButton);\n    _.each(proceedButtons, function (button) {\n        buttons.append(button);\n    });\n\n    modal\n        .addClass(dialogClass)\n        .append($(\"<div></div>\").addClass(\"modal-header\").append(modalHeader))\n        .append($(\"<div></div>\").addClass(\"modal-body\").append(modalBody))\n        .append(buttons);\n    modal.on(\"hidden\", function (event) {\n        if (onclose && _.isFunction(onclose)) {\n            onclose(event);\n        }\n    });\n\n    var modalOptions = {};\n    if (noclose) {\n        modalOptions.backdrop = \"static\";\n        modalOptions.keyboard = false;\n    }\n    modal.modal(modalOptions);\n\n    _.each(proceedButtons, function (button, idx) {\n        button.click(function (e) {\n            e.preventDefault();\n            if (onproceed && _.isFunction(onproceed)) {\n                onproceed(idx, e);\n            }\n            modal.modal(\"hide\");\n        });\n    });\n    cancelButton.click(function (e) {\n        if (oncancel && _.isFunction(oncancel)) {\n            oncancel(e);\n        }\n    });\n\n    return modal;\n}\n\nfunction showSelectionDialog(options) {\n    var title = options.title;\n    var message = options.message || undefined;\n    var selections = options.selections || [];\n\n    var maycancel = options.maycancel || false;\n    var cancel = options.cancel || undefined;\n    var onselect = options.onselect || undefined;\n    var onclose = options.onclose || undefined;\n    var dialogClass = options.dialogClass || \"\";\n    var nofade = options.nofade || false;\n\n    // header\n    var modalHeader;\n    if (maycancel) {\n        modalHeader = $(\n            '<a href=\"javascript:void(0)\" class=\"close\" data-dismiss=\"modal\" aria-hidden=\"true\">&times;</a><h3>' +\n                title +\n                \"</h3>\"\n        );\n    } else {\n        modalHeader = $(\"<h3>\" + title + \"</h3>\");\n    }\n\n    // body\n    var buttons = [];\n    var selectionBody = $(\"<div></div>\");\n    var container;\n    var additionalClass;\n\n    if (selections.length === 1) {\n        container = selectionBody;\n        additionalClass = \"btn-block\";\n    } else if (selections.length === 2) {\n        container = $(\"<div class='row-fluid'></div>\");\n        selectionBody.append(container);\n        additionalClass = \"span6\";\n    } else {\n        container = selectionBody;\n        additionalClass = \"btn-block\";\n    }\n\n    _.each(selections, function (s, i) {\n        var button = $(\n            '<button class=\"btn\" style=\"white-space: normal; word-wrap: break-word\" data-index=\"' +\n                i +\n                '\">' +\n                selections[i] +\n                \"</button>\"\n        );\n        if (additionalClass) {\n            button.addClass(additionalClass);\n        }\n        container.append(button);\n        buttons.push(button);\n\n        if (selections.length > 2 && i < selections.length - 1) {\n            container = $(\"<div class='row-fluid'></div>\");\n            selectionBody.append(container);\n        }\n    });\n\n    // divs\n    var headerDiv = $(\"<div></div>\").addClass(\"modal-header\").append(modalHeader);\n\n    var bodyDiv = $(\"<div></div>\").addClass(\"modal-body\");\n    if (message) {\n        bodyDiv.append($(\"<p>\" + message + \"</p>\"));\n    }\n    bodyDiv.append(selectionBody);\n\n    // create modal and do final wiring up\n    var modal = $(\"<div></div>\").addClass(\"modal hide\");\n    if (!nofade) {\n        modal.addClass(\"fade-in\");\n    }\n    if (!cancel) {\n        modal.data(\"backdrop\", \"static\").data(\"keyboard\", \"false\");\n    }\n\n    modal.addClass(dialogClass).append(headerDiv).append(bodyDiv);\n    modal.on(\"hidden\", function (event) {\n        if (onclose && _.isFunction(onclose)) {\n            onclose(event);\n        }\n    });\n    modal.modal(\"show\");\n\n    _.each(buttons, function (button) {\n        button.click(function (e) {\n            e.preventDefault();\n            var index = button.data(\"index\");\n            if (index < 0) {\n                return;\n            }\n\n            if (onselect && _.isFunction(onselect)) {\n                onselect(index, e);\n            }\n            modal.modal(\"hide\");\n        });\n    });\n\n    return modal;\n}\n\n/**\n * Shows a progress modal depending on a supplied promise.\n *\n * Will listen to the supplied promise, update the progress on .progress events and\n * enabling the close button and (optionally) closing the dialog on promise resolve.\n *\n * The calling code should call \"notify\" on the deferred backing the promise and supply:\n *\n *   * the text to display on the progress bar and the optional output field and\n *     a boolean value indicating whether the operation behind that update was successful or not\n *   * a short text to display on the progress bar, a long text to display on the optional output\n *     field and a boolean value indicating whether the operation behind that update was\n *     successful or not\n *\n * Non-successful progress updates will remove the barClassSuccess class from the progress bar and\n * apply the barClassFailure class and also apply the outputClassFailure to the produced line\n * in the output.\n *\n * To determine the progress, calling code should supply the prognosed maximum number of\n * progress events. An internal counter will increment on each progress event and used together\n * with the max value to calculate the percentage to display on the progress bar.\n *\n * If no max value is set, the progress bar will show a striped animation at 100% fill status\n * to visualize \"unknown but ongoing\" status.\n *\n * Available options:\n *\n *   * title: the title of the modal, defaults to \"Progress\"\n *   * message: the message of the modal, defaults to \"\"\n *   * buttonText: the text on the close button, defaults to \"Close\"\n *   * max: maximum number of expected progress events (when 100% will be reached), defaults\n *     to undefined\n *   * close: whether to close the dialog on completion, defaults to false\n *   * output: whether to display the progress texts in an output field, defaults to false\n *   * dialogClass: additional class to apply to the dialog div\n *   * barClassSuccess: additional class for the progress bar while all progress events are\n *     successful\n *   * barClassFailure: additional class for the progress bar when a progress event was\n *     unsuccessful\n *   * outputClassSuccess: additional class for successful output lines\n *   * outputClassFailure: additional class for unsuccessful output lines\n *\n * @param options modal options\n * @param promise promise to monitor\n * @returns {*|jQuery} the modal object\n */\nfunction showProgressModal(options, promise) {\n    var title = options.title || gettext(\"Progress\");\n    var message = options.message || \"\";\n    var buttonText = options.button || gettext(\"Close\");\n    var max = options.max || undefined;\n    var close = options.close || false;\n    var output = options.output || false;\n\n    var dialogClass = options.dialogClass || \"\";\n    var barClassSuccess = options.barClassSuccess || \"\";\n    var barClassFailure = options.barClassFailure || \"bar-danger\";\n    var outputClassSuccess = options.outputClassSuccess || \"\";\n    var outputClassFailure = options.outputClassFailure || \"text-error\";\n\n    var modalHeader = $(\"<h3>\" + title + \"</h3>\");\n    var paragraph = $(\"<p>\" + message + \"</p>\");\n\n    var progress = $('<div class=\"progress progress-text-centered\"></div>');\n    var progressBar = $('<div class=\"bar\"></div>').addClass(barClassSuccess);\n    var progressText = $('<span class=\"progress-text-back\"></span>');\n\n    if (max === undefined) {\n        progress.addClass(\"progress-striped active\");\n        progressBar.width(\"100%\");\n    }\n\n    progress.append(progressBar).append(progressText);\n\n    var button = $('<button class=\"btn\">' + buttonText + \"</button>\")\n        .prop(\"disabled\", true)\n        .attr(\"data-dismiss\", \"modal\")\n        .attr(\"aria-hidden\", \"true\");\n\n    var modalBody = $(\"<div></div>\")\n        .addClass(\"modal-body\")\n        .append(paragraph)\n        .append(progress);\n\n    var pre;\n    if (output) {\n        pre = $(\n            \"<pre class='pre-scrollable pre-output' style='height: 70px; font-size: 0.8em'></pre>\"\n        );\n        modalBody.append(pre);\n    }\n\n    var modal = $(\"<div></div>\")\n        .addClass(\"modal hide fade-in\")\n        .addClass(dialogClass)\n        .append($(\"<div></div>\").addClass(\"modal-header\").append(modalHeader))\n        .append(modalBody)\n        .append($(\"<div></div>\").addClass(\"modal-footer\").append(button));\n    modal.modal({keyboard: false, backdrop: \"static\", show: true});\n\n    var counter = 0;\n    promise\n        .progress(function () {\n            var short, long, success;\n            if (arguments.length === 2) {\n                short = long = arguments[0];\n                success = arguments[1];\n            } else if (arguments.length === 3) {\n                short = arguments[0];\n                long = arguments[1];\n                success = arguments[2];\n            } else {\n                throw Error(\n                    \"Invalid parameters for showProgressModal, expected either (text, success) or (short, long, success)\"\n                );\n            }\n\n            var value;\n\n            if (max === undefined || max <= 0) {\n                value = 100;\n            } else {\n                counter++;\n                value = Math.max(Math.min((counter * 100) / max, 100), 0);\n            }\n\n            // update progress bar\n            progressBar.width(String(value) + \"%\");\n            progressText.text(short);\n            if (value < 50 && progressText.hasClass(\"progress-text-front\")) {\n                progressText\n                    .removeClass(\"progress-text-front\")\n                    .addClass(\"progress-text-back\");\n            } else if (value >= 50 && progressText.hasClass(\"progress-text-back\")) {\n                progressText\n                    .removeClass(\"progress-text-back\")\n                    .addClass(\"progress-text-front\");\n            }\n\n            // if not successful, apply failure class\n            if (!success && !progressBar.hasClass(barClassFailure)) {\n                progressBar.removeClass(barClassSuccess).addClass(barClassFailure);\n            }\n\n            if (output && pre) {\n                if (success) {\n                    pre.append(\n                        $(\"<span class='\" + outputClassSuccess + \"'>\" + long + \"</span>\")\n                    );\n                } else {\n                    pre.append(\n                        $(\"<span class='\" + outputClassFailure + \"'>\" + long + \"</span>\")\n                    );\n                }\n                pre.scrollTop(pre[0].scrollHeight - pre.height());\n            }\n        })\n        .done(function () {\n            button.prop(\"disabled\", false);\n            if (close) {\n                modal.modal(\"hide\");\n            }\n        })\n        .fail(function () {\n            button.prop(\"disabled\", false);\n        });\n\n    return modal;\n}\n\nfunction showReloadOverlay() {\n    $(\"#reloadui_overlay\").show();\n}\n\nfunction wrapPromiseWithAlways(p) {\n    var deferred = $.Deferred();\n    p.always(function () {\n        deferred.resolve.apply(deferred, arguments);\n    });\n    return deferred.promise();\n}\n\nfunction commentableLinesToArray(lines) {\n    return splitTextToArray(lines, \"\\n\", true, function (item) {\n        return !_.startsWith(item, \"#\");\n    });\n}\n\nfunction splitTextToArray(text, sep, stripEmpty, filter) {\n    return _.filter(\n        _.map(text.split(sep), function (item) {\n            return item ? item.trim() : \"\";\n        }),\n        function (item) {\n            return (stripEmpty ? item : true) && (filter ? filter(item) : true);\n        }\n    );\n}\n\n/**\n * Returns true if comparing data and oldData yields changes, false otherwise.\n *\n * E.g.\n *\n *   hasDataChanged(\n *     {foo: \"bar\", fnord: {one: \"1\", two: \"2\", three: \"three\", key: \"value\"}},\n *     {foo: \"bar\", fnord: {one: \"1\", two: \"2\", three: \"3\", four: \"4\"}}\n *   )\n *\n * will return\n *\n *   true\n *\n * and\n *\n *   hasDataChanged(\n *     {foo: \"bar\", fnord: {one: \"1\", two: \"2\", three: \"3\"}},\n *     {foo: \"bar\", fnord: {one: \"1\", two: \"2\", three: \"3\"}}\n *   )\n *\n * will return\n *\n *   false\n *\n * Note that this will assume data and oldData to be structurally identical (same keys)\n * and is optimized to check for value changes, not key updates.\n */\nfunction hasDataChanged(data, oldData) {\n    // noinspection EqualityComparisonWithCoercionJS\n    if (data == oldData && data == undefined) {\n        return false;\n    }\n\n    if (_.isPlainObject(data) && _.isPlainObject(oldData)) {\n        return _.any(_.keys(data), function (key) {\n            return hasDataChanged(data[key], oldData[key]);\n        });\n    } else {\n        return !_.isEqual(data, oldData);\n    }\n}\n\n/**\n * Compare provided data and oldData plain objects and only return those\n * substructures of data that actually changed.\n *\n * E.g.\n *\n *   getOnlyChangedData(\n *     {foo: \"bar\", fnord: {one: \"1\", two: \"2\", three: \"three\"}},\n *     {foo: \"bar\", fnord: {one: \"1\", two: \"2\", three: \"3\"}}\n *   )\n *\n * will return\n *\n *   {fnord: {three: \"three\"}}\n *\n * and\n *\n *   getOnlyChangedData(\n *     {foo: \"bar\", fnord: {one: \"1\", two: \"2\", three: \"3\"}},\n *     {foo: \"bar\", fnord: {one: \"1\", two: \"2\", three: \"3\"}}\n *   )\n *\n * will return\n *\n *   {}\n *\n * Note that this will assume data and oldData to be structurally identical (same keys)\n * and is optimized to check for value changes, not key updates.\n */\nfunction getOnlyChangedData(data, oldData) {\n    // noinspection EqualityComparisonWithCoercionJS\n    if (data == undefined) {\n        return {};\n    }\n\n    // noinspection EqualityComparisonWithCoercionJS\n    if (oldData == undefined) {\n        return data;\n    }\n\n    var f = function (root, oldRoot) {\n        if (!_.isPlainObject(root)) {\n            return root;\n        }\n\n        var retval = {};\n        _.forOwn(root, function (value, key) {\n            var oldValue = undefined;\n            // noinspection EqualityComparisonWithCoercionJS\n            if (oldRoot != undefined && oldRoot.hasOwnProperty(key)) {\n                oldValue = oldRoot[key];\n            }\n            if (_.isPlainObject(value)) {\n                // noinspection EqualityComparisonWithCoercionJS\n                if (oldValue == undefined) {\n                    retval[key] = value;\n                } else if (hasDataChanged(value, oldValue)) {\n                    retval[key] = f(value, oldValue);\n                }\n            } else {\n                // noinspection EqualityComparisonWithCoercionJS\n                if (\n                    !(value == oldValue && value == undefined) &&\n                    !_.isEqual(value, oldValue)\n                ) {\n                    retval[key] = value;\n                }\n            }\n        });\n        return retval;\n    };\n\n    return f(data, oldData);\n}\n\nfunction setOnViewModels(allViewModels, key, value) {\n    setOnViewModelsIf(allViewModels, key, value, undefined);\n}\n\nfunction setOnViewModelsIf(allViewModels, key, value, condition) {\n    if (!allViewModels) return;\n    _.each(allViewModels, function (viewModel) {\n        setOnViewModelIf(viewModel, key, value, condition);\n    });\n}\n\nfunction setOnViewModel(viewModel, key, value) {\n    setOnViewModelIf(viewModel, key, value, undefined);\n}\n\nfunction setOnViewModelIf(viewModel, key, value, condition) {\n    if (condition === undefined || !_.isFunction(condition)) {\n        condition = function () {\n            return true;\n        };\n    }\n\n    try {\n        if (!condition(viewModel)) {\n            return;\n        }\n\n        viewModel[key] = value;\n    } catch (exc) {\n        if (typeof Sentry !== \"undefined\") {\n            Sentry.captureException(exc);\n        }\n        log.error(\n            \"Error while setting\",\n            key,\n            \"to\",\n            value,\n            \"on view model\",\n            viewModel.constructor.name,\n            \":\",\n            exc.stack || exc\n        );\n    }\n}\n\nfunction callViewModels(allViewModels, method, callback) {\n    callViewModelsIf(allViewModels, method, undefined, callback);\n}\n\nfunction callViewModelsIf(allViewModels, method, condition, callback) {\n    if (!allViewModels) return;\n\n    _.each(allViewModels, function (viewModel) {\n        try {\n            callViewModelIf(viewModel, method, condition, callback);\n        } catch (exc) {\n            if (typeof Sentry !== \"undefined\") {\n                Sentry.captureException(exc);\n            }\n            log.error(\n                \"Error calling\",\n                method,\n                \"on view model\",\n                viewModel.constructor.name,\n                \":\",\n                exc.stack || exc\n            );\n        }\n    });\n}\n\nfunction callViewModel(viewModel, method, callback, raiseErrors) {\n    callViewModelIf(viewModel, method, undefined, callback, raiseErrors);\n}\n\nfunction callViewModelIf(viewModel, method, condition, callback, raiseErrors) {\n    raiseErrors = raiseErrors === true || false;\n\n    if (condition === undefined || !_.isFunction(condition)) {\n        condition = function () {\n            return true;\n        };\n    }\n\n    if (!_.isFunction(viewModel[method]) || !condition(viewModel, method)) return;\n\n    var parameters = undefined;\n    if (!_.isFunction(callback)) {\n        // if callback is not a function that means we are supposed to directly\n        // call the view model method instead of providing it to the callback\n        // - let's figure out how\n\n        if (callback === undefined) {\n            // directly call view model method with no parameters\n            parameters = undefined;\n            log.trace(\"Calling method\", method, \"on view model\");\n        } else if (_.isArray(callback)) {\n            // directly call view model method with these parameters\n            parameters = callback;\n            log.trace(\n                \"Calling method\",\n                method,\n                \"on view model with specified parameters\",\n                parameters\n            );\n        } else {\n            // ok, this doesn't make sense, callback is neither undefined nor\n            // an array, we'll return without doing anything\n            return;\n        }\n\n        // we reset this here so we now further down that we want to call\n        // the method directly\n        callback = undefined;\n    } else {\n        log.trace(\n            \"Providing method\",\n            method,\n            \"on view model to specified callback\",\n            callback\n        );\n    }\n\n    try {\n        if (callback === undefined) {\n            if (parameters !== undefined) {\n                // call the method with the provided parameters\n                viewModel[method].apply(viewModel, parameters);\n            } else {\n                // call the method without parameters\n                viewModel[method]();\n            }\n        } else {\n            // provide the method to the callback\n            callback(viewModel[method], viewModel);\n        }\n    } catch (exc) {\n        if (typeof Sentry !== \"undefined\") {\n            Sentry.captureException(exc);\n        }\n        if (raiseErrors) {\n            throw exc;\n        } else {\n            log.error(\n                \"Error calling\",\n                method,\n                \"on view model\",\n                viewModel.constructor.name,\n                \":\",\n                exc.stack || exc\n            );\n        }\n    }\n}\n\nvar sizeObservable = function (observable) {\n    return ko.computed({\n        read: function () {\n            return formatSize(observable());\n        },\n        write: function (value) {\n            var result = bytesFromSize(value);\n            if (result !== undefined) {\n                observable(result);\n            }\n        }\n    });\n};\n\nvar getQueryParameterByName = function (name, url) {\n    // from http://stackoverflow.com/a/901144/2028598\n    if (!url) {\n        url = window.location.href;\n    }\n    name = name.replace(/[\\[\\]]/g, \"\\\\$&\");\n    var regex = new RegExp(\"[?&]\" + name + \"(=([^&#]*)|&|#|$)\"),\n        results = regex.exec(url);\n    if (!results) return null;\n    if (!results[2]) return \"\";\n    return decodeURIComponent(results[2].replace(/\\+/g, \" \"));\n};\n\n/**\n * Escapes unprintable ASCII characters in the provided string.\n *\n * E.g. turns a null byte in the string into \"\\x00\".\n *\n * Characters 0 to 31 excluding 9, 10 and 13 will be escaped, as will\n * 127, 128 to 159 and 255. That should leave printable characters and unicode\n * alone.\n *\n * Originally based on\n * https://gist.github.com/mathiasbynens/1243213#gistcomment-53590\n *\n * @param str The string to escape\n * @returns {string}\n */\nvar escapeUnprintableCharacters = function (str) {\n    var result = \"\";\n    var index = 0;\n    var charCode;\n\n    while (!isNaN((charCode = str.charCodeAt(index)))) {\n        if (\n            (charCode < 32 && charCode !== 9 && charCode !== 10 && charCode !== 13) ||\n            charCode === 127 ||\n            (charCode >= 128 && charCode <= 159) ||\n            charCode === 255\n        ) {\n            // special hex chars\n            result += \"\\\\x\" + (charCode > 15 ? \"\" : \"0\") + charCode.toString(16);\n        } else {\n            // anything else\n            result += str[index];\n        }\n\n        index++;\n    }\n    return result;\n};\n\nvar copyToClipboard = function (text) {\n    var temp = $(\"<textarea>\");\n    $(\"body\").append(temp);\n    temp.val(text).select();\n    document.execCommand(\"copy\");\n    temp.remove();\n};\n\nvar determineWebcamStreamType = function (streamUrl) {\n    if (streamUrl) {\n        if (streamUrl.startsWith(\"webrtc\")) {\n            return \"webrtc\";\n        }\n\n        var lastDotPosition = streamUrl.lastIndexOf(\".\");\n        var firstQuotationSignPosition = streamUrl.indexOf(\"?\");\n        if (\n            lastDotPosition != -1 &&\n            firstQuotationSignPosition != -1 &&\n            lastDotPosition >= firstQuotationSignPosition\n        ) {\n            throw \"Malformed URL. Cannot determine stream type.\";\n        }\n\n        // If we have found a dot, try to extract the extension.\n        if (lastDotPosition > -1) {\n            if (firstQuotationSignPosition > -1) {\n                var extension = streamUrl.slice(\n                    lastDotPosition + 1,\n                    firstQuotationSignPosition - 1\n                );\n            } else {\n                var extension = streamUrl.slice(lastDotPosition + 1);\n            }\n            if (extension.toLowerCase() == \"m3u8\") {\n                return \"hls\";\n            }\n        }\n        // By default, 'mjpg' is the stream type.\n        return \"mjpg\";\n    } else {\n        throw \"Empty streamUrl. Cannot determine stream type.\";\n    }\n};\n\nvar saveToLocalStorage = function (key, data) {\n    if (!Modernizr.localstorage) return;\n    localStorage[key] = JSON.stringify(data);\n};\n\nvar loadFromLocalStorage = function (key, defaultValue) {\n    defaultValue = defaultValue === undefined ? {} : defaultValue;\n\n    if (!Modernizr.localstorage) return defaultValue;\n\n    var currentString = localStorage[key];\n    var current;\n    if (currentString === undefined) {\n        current = defaultValue;\n    } else {\n        try {\n            current = JSON.parse(currentString);\n        } catch (ex) {\n            current = defaultValue;\n        }\n    }\n    return current;\n};\n\nvar deepMerge = function (target, source) {\n    /**\n     * Implements an object deep merge, which contrary to _.merge doesn't try to\n     * merge arrays.\n     */\n    if (!_.isObject(target)) {\n        return target;\n    }\n\n    _.forOwn(source, function (value, key) {\n        if (\n            target.hasOwnProperty(key) &&\n            _.isPlainObject(target[key]) &&\n            _.isPlainObject(value)\n        ) {\n            target[key] = deepMerge(target[key], value);\n        } else {\n            target[key] = value;\n        }\n    });\n\n    return target;\n};\n\nvar isWebRTCAvailable = function () {\n    return (\n        typeof RTCPeerConnection == \"function\" &&\n        typeof RTCPeerConnection.prototype.addEventListener == \"function\" &&\n        typeof RTCPeerConnection.prototype.addTransceiver == \"function\" &&\n        typeof RTCPeerConnection.prototype.createOffer == \"function\" &&\n        typeof RTCPeerConnection.prototype.setLocalDescription == \"function\" &&\n        typeof RTCPeerConnection.prototype.removeEventListener == \"function\" &&\n        typeof RTCPeerConnection.prototype.addEventListener == \"function\" &&\n        typeof RTCPeerConnection.prototype.setRemoteDescription == \"function\"\n    );\n};\n\nvar negotiateWebRTC = function (streamUrl) {\n    pc.addTransceiver(\"video\", {direction: \"recvonly\"});\n    pc.addTransceiver(\"audio\", {direction: \"recvonly\"});\n    return pc\n        .createOffer()\n        .then(function (offer) {\n            return pc.setLocalDescription(offer);\n        })\n        .then(function () {\n            // Wait for ICE gathering to complete\n            return new Promise(function (resolve) {\n                if (pc.iceGatheringState === \"complete\") {\n                    resolve();\n                } else {\n                    function checkState() {\n                        if (pc.iceGatheringState === \"complete\") {\n                            pc.removeEventListener(\"icegatheringstatechange\", checkState);\n                            resolve();\n                        }\n                    }\n                    pc.addEventListener(\"icegatheringstatechange\", checkState);\n                }\n            });\n        })\n        .then(function () {\n            var offer = pc.localDescription;\n            // webrtc://host.com becomes http://host.com\n            // webrtcs://host.com becomes https://host.com\n            streamUrl = \"http\" + streamUrl.slice(\"webrtc\".length);\n            return $.ajax({\n                url: streamUrl,\n                type: \"POST\",\n                dataType: \"json\",\n                data: JSON.stringify({\n                    sdp: offer.sdp,\n                    type: offer.type\n                }),\n                contentType: \"application/json; charset=UTF-8\"\n            });\n        })\n        .then(function (response) {\n            return pc.setRemoteDescription(response);\n        })\n        .catch(function (e) {\n            console.error(e);\n        });\n};\n\nvar startWebRTC = function (videoElement, streamUrl, iceServers) {\n    var config = {\n        sdpSemantics: \"unified-plan\"\n    };\n    if (iceServers) {\n        config.iceServers = [{urls: iceServers}];\n    }\n    pc = new RTCPeerConnection(config);\n    pc.addEventListener(\"track\", function (evt) {\n        if (evt.track.kind == \"video\") {\n            videoElement.srcObject = evt.streams[0];\n        }\n    });\n\n    negotiateWebRTC(streamUrl);\n    return pc;\n};\n", "$(function () {\n    function SettingsViewModel(parameters) {\n        var self = this;\n\n        self.loginState = parameters[0];\n        self.access = parameters[1];\n        self.printerProfiles = parameters[2];\n        self.about = parameters[3];\n\n        // TODO: remove in upcoming version, this is only for backwards compatibility\n        self.users = parameters[4];\n\n        // use this promise to do certain things once the SettingsViewModel has processed\n        // its first request\n        var firstRequest = $.Deferred();\n        self.firstRequest = firstRequest.promise();\n\n        self.allViewModels = [];\n\n        self.receiving = ko.observable(false);\n        self.sending = ko.observable(false);\n        self.exchanging = ko.pureComputed(function () {\n            return self.receiving() || self.sending();\n        });\n        self.outstanding = [];\n\n        self.active = false;\n        self.sawUpdateEventWhileActive = false;\n        self.ignoreNextUpdateEvent = false;\n\n        self.settingsDialog = undefined;\n        self.settings_dialog_update_detected = undefined;\n        self.translationManagerDialog = undefined;\n        self.translationUploadElement = $(\n            \"#settings_appearance_managelanguagesdialog_upload\"\n        );\n        self.translationUploadButton = $(\n            \"#settings_appearance_managelanguagesdialog_upload_start\"\n        );\n\n        self.translationUploadFilename = ko.observable();\n        self.invalidTranslationArchive = ko.pureComputed(function () {\n            var name = self.translationUploadFilename();\n            return (\n                name !== undefined &&\n                !(\n                    _.endsWith(name.toLocaleLowerCase(), \".zip\") ||\n                    _.endsWith(name.toLocaleLowerCase(), \".tar.gz\") ||\n                    _.endsWith(name.toLocaleLowerCase(), \".tgz\") ||\n                    _.endsWith(name.toLocaleLowerCase(), \".tar\")\n                )\n            );\n        });\n        self.enableTranslationUpload = ko.pureComputed(function () {\n            var name = self.translationUploadFilename();\n            return (\n                name !== undefined &&\n                name.trim() != \"\" &&\n                !self.invalidTranslationArchive()\n            );\n        });\n\n        self.translations = new ItemListHelper(\n            \"settings.translations\",\n            {\n                locale: function (a, b) {\n                    // sorts ascending\n                    if (a[\"locale\"].toLocaleLowerCase() < b[\"locale\"].toLocaleLowerCase())\n                        return -1;\n                    if (a[\"locale\"].toLocaleLowerCase() > b[\"locale\"].toLocaleLowerCase())\n                        return 1;\n                    return 0;\n                }\n            },\n            {},\n            \"locale\",\n            [],\n            [],\n            0\n        );\n\n        self.appearance_available_colors = ko.observable([\n            {key: \"default\", name: gettext(\"default\")},\n            {key: \"red\", name: gettext(\"red\")},\n            {key: \"orange\", name: gettext(\"orange\")},\n            {key: \"yellow\", name: gettext(\"yellow\")},\n            {key: \"green\", name: gettext(\"green\")},\n            {key: \"blue\", name: gettext(\"blue\")},\n            {key: \"violet\", name: gettext(\"violet\")},\n            {key: \"black\", name: gettext(\"black\")},\n            {key: \"white\", name: gettext(\"white\")}\n        ]);\n\n        self.appearance_colorName = function (color) {\n            switch (color) {\n                case \"red\":\n                    return gettext(\"red\");\n                case \"orange\":\n                    return gettext(\"orange\");\n                case \"yellow\":\n                    return gettext(\"yellow\");\n                case \"green\":\n                    return gettext(\"green\");\n                case \"blue\":\n                    return gettext(\"blue\");\n                case \"violet\":\n                    return gettext(\"violet\");\n                case \"black\":\n                    return gettext(\"black\");\n                case \"white\":\n                    return gettext(\"white\");\n                case \"default\":\n                    return gettext(\"default\");\n                default:\n                    return color;\n            }\n        };\n\n        self.webcam_available_ratios = [\"16:9\", \"4:3\"];\n        self.webcam_available_videocodecs = [\"libx264\", \"mpeg2video\"];\n\n        var auto_locale = {\n            language: \"_default\",\n            display: gettext(\"Autodetect from browser\"),\n            english: undefined\n        };\n        self.locales = ko.observableArray(\n            [auto_locale].concat(\n                _.sortBy(_.values(AVAILABLE_LOCALES), function (n) {\n                    return n.display;\n                })\n            )\n        );\n        self.locale_languages = _.keys(AVAILABLE_LOCALES);\n\n        self.api_key = ko.observable(undefined);\n        self.api_allowCrossOrigin = ko.observable(undefined);\n\n        self.appearance_name = ko.observable(undefined);\n        self.appearance_color = ko.observable(undefined);\n        self.appearance_colorTransparent = ko.observable();\n        self.appearance_colorIcon = ko.observable();\n        self.appearance_defaultLanguage = ko.observable();\n        self.appearance_showFahrenheitAlso = ko.observable(undefined);\n        self.appearance_fuzzyTimes = ko.observable(undefined);\n        self.appearance_closeModalsWithClick = ko.observable(undefined);\n        self.appearance_showInternalFilename = ko.observable(undefined);\n\n        self.printer_defaultExtrusionLength = ko.observable(undefined);\n\n        self.webcam_webcamEnabled = ko.observable(undefined);\n        self.webcam_timelapseEnabled = ko.observable(undefined);\n        self.webcam_streamUrl = ko.observable(undefined);\n        self.webcam_streamRatio = ko.observable(undefined);\n        self.webcam_streamTimeout = ko.observable(undefined);\n        self.webcam_streamWebrtcIceServers = ko.observable(undefined);\n        self.webcam_snapshotUrl = ko.observable(undefined);\n        self.webcam_snapshotTimeout = ko.observable(undefined);\n        self.webcam_snapshotSslValidation = ko.observable(undefined);\n        self.webcam_ffmpegPath = ko.observable(undefined);\n        self.webcam_ffmpegCommandline = ko.observable(undefined);\n        self.webcam_bitrate = ko.observable(undefined);\n        self.webcam_ffmpegThreads = ko.observable(undefined);\n        self.webcam_ffmpegVideoCodec = ko.observable(undefined);\n        self.webcam_watermark = ko.observable(undefined);\n        self.webcam_flipH = ko.observable(undefined);\n        self.webcam_flipV = ko.observable(undefined);\n        self.webcam_rotate90 = ko.observable(undefined);\n        self.webcam_cacheBuster = ko.observable(undefined);\n\n        self.feature_temperatureGraph = ko.observable(undefined);\n        self.feature_sdSupport = ko.observable(undefined);\n        self.feature_keyboardControl = ko.observable(undefined);\n        self.feature_pollWatched = ko.observable(undefined);\n        self.feature_modelSizeDetection = ko.observable(undefined);\n        self.feature_rememberFileFolder = ko.observable(undefined);\n        self.feature_printStartConfirmation = ko.observable(undefined);\n        self.feature_printCancelConfirmation = ko.observable(undefined);\n        self.feature_uploadOverwriteConfirmation = ko.observable(undefined);\n        self.feature_g90InfluencesExtruder = ko.observable(undefined);\n        self.feature_autoUppercaseBlacklist = ko.observable(undefined);\n\n        self.gcodeAnalysis_runAt = ko.observable(undefined);\n\n        self.serial_port = ko.observable();\n        self.serial_baudrate = ko.observable();\n        self.serial_exclusive = ko.observable();\n        self.serial_lowLatency = ko.observable();\n        self.serial_portOptions = ko.observableArray([]);\n        self.serial_baudrateOptions = ko.observableArray([]);\n        self.serial_autoconnect = ko.observable(undefined);\n        self.serial_timeoutConnection = ko.observable(undefined);\n        self.serial_timeoutDetectionFirst = ko.observable(undefined);\n        self.serial_timeoutDetectionConsecutive = ko.observable(undefined);\n        self.serial_timeoutCommunication = ko.observable(undefined);\n        self.serial_timeoutCommunicationBusy = ko.observable(undefined);\n        self.serial_timeoutTemperature = ko.observable(undefined);\n        self.serial_timeoutTemperatureTargetSet = ko.observable(undefined);\n        self.serial_timeoutTemperatureAutoreport = ko.observable(undefined);\n        self.serial_timeoutSdStatus = ko.observable(undefined);\n        self.serial_timeoutSdStatusAutoreport = ko.observable(undefined);\n        self.serial_timeoutPosAutoreport = ko.observable(undefined);\n        self.serial_timeoutBaudrateDetectionPause = ko.observable(undefined);\n        self.serial_timeoutPositionLogWait = ko.observable(undefined);\n        self.serial_log = ko.observable(undefined);\n        self.serial_additionalPorts = ko.observable(undefined);\n        self.serial_additionalBaudrates = ko.observable(undefined);\n        self.serial_blacklistedPorts = ko.observable(undefined);\n        self.serial_blacklistedBaudrates = ko.observable(undefined);\n        self.serial_longRunningCommands = ko.observable(undefined);\n        self.serial_checksumRequiringCommands = ko.observable(undefined);\n        self.serial_blockedCommands = ko.observable(undefined);\n        self.serial_ignoredCommands = ko.observable(undefined);\n        self.serial_pausingCommands = ko.observable(undefined);\n        self.serial_sdCancelCommand = ko.observable(undefined);\n        self.serial_emergencyCommands = ko.observable(undefined);\n        self.serial_helloCommand = ko.observable(undefined);\n        self.serial_serialErrorBehaviour = ko.observable(\"cancel\");\n        self.serial_triggerOkForM29 = ko.observable(undefined);\n        self.serial_waitForStart = ko.observable(undefined);\n        self.serial_sendChecksum = ko.observable(\"print\");\n        self.serial_sendChecksumWithUnknownCommands = ko.observable(undefined);\n        self.serial_unknownCommandsNeedAck = ko.observable(undefined);\n        self.serial_sdRelativePath = ko.observable(undefined);\n        self.serial_sdLowerCase = ko.observable(undefined);\n        self.serial_sdAlwaysAvailable = ko.observable(undefined);\n        self.serial_swallowOkAfterResend = ko.observable(undefined);\n        self.serial_repetierTargetTemp = ko.observable(undefined);\n        self.serial_disableExternalHeatupDetection = ko.observable(undefined);\n        self.serial_ignoreIdenticalResends = ko.observable(undefined);\n        self.serial_firmwareDetection = ko.observable(undefined);\n        self.serial_blockWhileDwelling = ko.observable(undefined);\n        self.serial_useParityWorkaround = ko.observable(undefined);\n        self.serial_sanityCheckTools = ko.observable(undefined);\n        self.serial_supportResendsWithoutOk = ko.observable(undefined);\n        self.serial_logPositionOnPause = ko.observable(undefined);\n        self.serial_logPositionOnCancel = ko.observable(undefined);\n        self.serial_abortHeatupOnCancel = ko.observable(undefined);\n        self.serial_maxTimeoutsIdle = ko.observable(undefined);\n        self.serial_maxTimeoutsPrinting = ko.observable(undefined);\n        self.serial_maxTimeoutsLong = ko.observable(undefined);\n        self.serial_capAutoreportTemp = ko.observable(undefined);\n        self.serial_capAutoreportSdStatus = ko.observable(undefined);\n        self.serial_capAutoreportPos = ko.observable(undefined);\n        self.serial_capBusyProtocol = ko.observable(undefined);\n        self.serial_capEmergencyParser = ko.observable(undefined);\n        self.serial_capExtendedM20 = ko.observable(undefined);\n        self.serial_sendM112OnError = ko.observable(undefined);\n        self.serial_disableSdPrintingDetection = ko.observable(undefined);\n        self.serial_ackMax = ko.observable(undefined);\n        self.serial_resendRatioThreshold = ko.observable(100);\n        self.serial_resendRatioStart = ko.observable(100);\n        self.serial_ignoreEmptyPorts = ko.observable(undefined);\n        self.serial_enableShutdownActionCommand = ko.observable(undefined);\n\n        self.folder_uploads = ko.observable(undefined);\n        self.folder_timelapse = ko.observable(undefined);\n        self.folder_timelapseTmp = ko.observable(undefined);\n        self.folder_logs = ko.observable(undefined);\n        self.folder_watched = ko.observable(undefined);\n\n        self.scripts_gcode_beforePrintStarted = ko.observable(undefined);\n        self.scripts_gcode_afterPrintDone = ko.observable(undefined);\n        self.scripts_gcode_afterPrintCancelled = ko.observable(undefined);\n        self.scripts_gcode_afterPrintPaused = ko.observable(undefined);\n        self.scripts_gcode_beforePrintResumed = ko.observable(undefined);\n        self.scripts_gcode_afterPrinterConnected = ko.observable(undefined);\n        self.scripts_gcode_beforePrinterDisconnected = ko.observable(undefined);\n        self.scripts_gcode_afterToolChange = ko.observable(undefined);\n        self.scripts_gcode_beforeToolChange = ko.observable(undefined);\n\n        self.temperature_profiles = ko.observableArray(undefined);\n        self.temperature_cutoff = ko.observable(undefined);\n        self.temperature_sendAutomatically = ko.observable(undefined);\n        self.temperature_sendAutomaticallyAfter = ko.observable(undefined);\n\n        self.system_actions = ko.observableArray([]);\n\n        self.terminalFilters = ko.observableArray([]);\n\n        self.server_commands_systemShutdownCommand = ko.observable(undefined);\n        self.server_commands_systemRestartCommand = ko.observable(undefined);\n        self.server_commands_serverRestartCommand = ko.observable(undefined);\n\n        self.server_diskspace_warning = ko.observable();\n        self.server_diskspace_critical = ko.observable();\n        self.server_diskspace_warning_str = sizeObservable(self.server_diskspace_warning);\n        self.server_diskspace_critical_str = sizeObservable(\n            self.server_diskspace_critical\n        );\n\n        self.server_onlineCheck_enabled = ko.observable();\n        self.server_onlineCheck_interval = ko.observable();\n        self.server_onlineCheck_host = ko.observable();\n        self.server_onlineCheck_port = ko.observable();\n        self.server_onlineCheck_name = ko.observable();\n\n        self.server_pluginBlacklist_enabled = ko.observable();\n        self.server_pluginBlacklist_url = ko.observable();\n        self.server_pluginBlacklist_ttl = ko.observable();\n\n        self.server_allowFraming = ko.observable();\n\n        self.settings = undefined;\n        self.lastReceivedSettings = undefined;\n\n        self.webcam_ffmpegPathText = ko.observable();\n        self.webcam_ffmpegPathOk = ko.observable(false);\n        self.webcam_ffmpegPathBroken = ko.observable(false);\n        self.webcam_ffmpegPathReset = function () {\n            self.webcam_ffmpegPathText(\"\");\n            self.webcam_ffmpegPathOk(false);\n            self.webcam_ffmpegPathBroken(false);\n        };\n        self.webcam_streamType = ko.pureComputed(function () {\n            try {\n                return determineWebcamStreamType(self.webcam_streamUrl());\n            } catch (e) {\n                return \"\";\n            }\n        });\n\n        self.server_onlineCheckText = ko.observable();\n        self.server_onlineCheckOk = ko.observable(false);\n        self.server_onlineCheckBroken = ko.observable(false);\n        self.server_onlineCheckReset = function () {\n            self.server_onlineCheckText(\"\");\n            self.server_onlineCheckOk(false);\n            self.server_onlineCheckBroken(false);\n        };\n        self.server_onlineCheckResolutionText = ko.observable();\n        self.server_onlineCheckResolutionOk = ko.observable(false);\n        self.server_onlineCheckResolutionBroken = ko.observable(false);\n        self.server_onlineCheckResolutionReset = function () {\n            self.server_onlineCheckResolutionText(\"\");\n            self.server_onlineCheckResolutionOk(false);\n            self.server_onlineCheckResolutionBroken(false);\n        };\n\n        var folderTypes = [\"uploads\", \"timelapse\", \"timelapseTmp\", \"logs\", \"watched\"];\n\n        var checkForDuplicateFolders = function () {\n            _.each(folderTypes, function (folderType) {\n                var path = self[\"folder_\" + folderType]();\n                var duplicate = false;\n                _.each(folderTypes, function (otherFolderType) {\n                    if (folderType !== otherFolderType) {\n                        duplicate =\n                            duplicate || path === self[\"folder_\" + otherFolderType]();\n                    }\n                });\n                self.testFolderConfigDuplicate[folderType](duplicate);\n            });\n        };\n\n        self.testFolderConfigText = {};\n        self.testFolderConfigOk = {};\n        self.testFolderConfigBroken = {};\n        self.testFolderConfigDuplicate = {};\n        self.testFolderConfigError = {};\n        self.testFolderConfigSuccess = {};\n        _.each(folderTypes, function (folderType) {\n            self.testFolderConfigText[folderType] = ko.observable(\"\");\n            self.testFolderConfigOk[folderType] = ko.observable(false);\n            self.testFolderConfigBroken[folderType] = ko.observable(false);\n            self.testFolderConfigDuplicate[folderType] = ko.observable(false);\n            self.testFolderConfigError[folderType] = ko.pureComputed(function () {\n                return (\n                    self.testFolderConfigBroken[folderType]() ||\n                    self.testFolderConfigDuplicate[folderType]()\n                );\n            });\n            self.testFolderConfigSuccess[folderType] = ko.pureComputed(function () {\n                return (\n                    self.testFolderConfigOk[folderType]() &&\n                    !self.testFolderConfigDuplicate[folderType]()\n                );\n            });\n            self[\"folder_\" + folderType].subscribe(checkForDuplicateFolders);\n        });\n        self.testFolderConfigReset = function () {\n            _.each(folderTypes, function (folderType) {\n                self.testFolderConfigText[folderType](\"\");\n                self.testFolderConfigOk[folderType](false);\n                self.testFolderConfigBroken[folderType](false);\n            });\n        };\n        self.testFoldersDuplicate = ko.pureComputed(function () {\n            var foundDupe = false;\n            _.each(folderTypes, function (folderType) {\n                foundDupe = foundDupe || self.testFolderConfigDuplicate[folderType]();\n            });\n            return foundDupe;\n        });\n\n        self.observableCopies = {\n            feature_waitForStart: \"serial_waitForStart\",\n            feature_sendChecksum: \"serial_sendChecksum\",\n            feature_sdRelativePath: \"serial_sdRelativePath\",\n            feature_sdAlwaysAvailable: \"serial_sdAlwaysAvailable\",\n            feature_swallowOkAfterResend: \"serial_swallowOkAfterResend\",\n            feature_repetierTargetTemp: \"serial_repetierTargetTemp\",\n            feature_disableExternalHeatupDetection:\n                \"serial_disableExternalHeatupDetection\",\n            feature_ignoreIdenticalResends: \"serial_ignoreIdenticalResends\",\n            feature_firmwareDetection: \"serial_firmwareDetection\",\n            feature_blockWhileDwelling: \"serial_blockWhileDwelling\",\n            serial_: \"feature_\"\n        };\n        _.each(self.observableCopies, function (value, key) {\n            if (self.hasOwnProperty(value)) {\n                self[key] = self[value];\n            }\n        });\n\n        self.addTemperatureProfile = function () {\n            self.temperature_profiles.push({\n                name: \"New\",\n                extruder: 0,\n                bed: 0,\n                chamber: 0\n            });\n        };\n\n        self.removeTemperatureProfile = function (profile) {\n            self.temperature_profiles.remove(profile);\n        };\n\n        self.addTerminalFilter = function () {\n            self.terminalFilters.push({\n                name: \"New\",\n                regex: \"(Send:\\\\s+(N\\\\d+\\\\s+)?M105)|(Recv:\\\\s+(ok\\\\s+([PBN]\\\\d+\\\\s+)*)?.*([BCLPR]|T\\\\d*):-?\\\\d+)\"\n            });\n        };\n\n        self.removeTerminalFilter = function (filter) {\n            self.terminalFilters.remove(filter);\n        };\n\n        self.testWebcamStreamUrlBusy = ko.observable(false);\n        self.testWebcamStreamUrl = function () {\n            if (!self.webcam_streamUrl()) {\n                return;\n            }\n\n            if (self.testWebcamStreamUrlBusy()) {\n                return;\n            }\n\n            var text = gettext(\n                \"If you see your webcam stream below, the entered stream URL is ok.\"\n            );\n            var streamType = self.webcam_streamType();\n            var webcam_element;\n            var webrtc_peer_connection;\n            if (streamType == \"mjpg\") {\n                webcam_element = $('<img src=\"' + self.webcam_streamUrl() + '\">');\n            } else if (streamType == \"hls\") {\n                webcam_element = $(\n                    '<video id=\"webcam_hls\" muted autoplay style=\"width: 100%\"/>'\n                );\n                video_element = webcam_element[0];\n                if (video_element.canPlayType(\"application/vnd.apple.mpegurl\")) {\n                    video_element.src = self.webcam_streamUrl();\n                } else if (Hls.isSupported()) {\n                    var hls = new Hls();\n                    hls.loadSource(self.webcam_streamUrl());\n                    hls.attachMedia(video_element);\n                }\n            } else if (isWebRTCAvailable() && streamType == \"webrtc\") {\n                webcam_element = $(\n                    '<video id=\"webcam_webrtc\" muted autoplay playsinline controls style=\"width: 100%\"/>'\n                );\n                video_element = webcam_element[0];\n\n                webrtc_peer_connection = startWebRTC(\n                    video_element,\n                    self.webcam_streamUrl(),\n                    self.webcam_streamWebrtcIceServers()\n                );\n            } else {\n                throw \"Unknown stream type \" + streamType;\n            }\n\n            var message = $(\"<div id='webcamTestContainer'></div>\")\n                .append($(\"<p></p>\"))\n                .append(text)\n                .append(webcam_element);\n\n            self.testWebcamStreamUrlBusy(true);\n            showMessageDialog({\n                title: gettext(\"Stream test\"),\n                message: message,\n                onclose: function () {\n                    self.testWebcamStreamUrlBusy(false);\n                    if (webrtc_peer_connection != null) {\n                        webrtc_peer_connection.close();\n                        webrtc_peer_connection = null;\n                    }\n                }\n            });\n        };\n\n        self.testWebcamSnapshotUrlBusy = ko.observable(false);\n        self.testWebcamSnapshotUrl = function (viewModel, event) {\n            if (!self.webcam_snapshotUrl()) {\n                return;\n            }\n\n            if (self.testWebcamSnapshotUrlBusy()) {\n                return;\n            }\n\n            var errorText = gettext(\n                \"Could not retrieve snapshot URL, please double check the URL\"\n            );\n            var errorTitle = gettext(\"Snapshot test failed\");\n\n            self.testWebcamSnapshotUrlBusy(true);\n            OctoPrint.util\n                .testUrl(self.webcam_snapshotUrl(), {\n                    method: \"GET\",\n                    response: \"bytes\",\n                    timeout: self.webcam_snapshotTimeout(),\n                    validSsl: self.webcam_snapshotSslValidation(),\n                    content_type_whitelist: [\"image/*\"],\n                    content_type_guess: true\n                })\n                .done(function (response) {\n                    if (!response.result) {\n                        if (\n                            response.status &&\n                            response.response &&\n                            response.response.content_type\n                        ) {\n                            // we could contact the server, but something else was wrong, probably the mime type\n                            errorText = gettext(\n                                \"Could retrieve the snapshot URL, but it didn't look like an \" +\n                                    \"image. Got this as a content type header: <code>%(content_type)s</code>. Please \" +\n                                    \"double check that the URL is returning static images, not multipart data \" +\n                                    \"or videos.\"\n                            );\n                            errorText = _.sprintf(errorText, {\n                                content_type: _.escape(response.response.content_type)\n                            });\n                        }\n\n                        showMessageDialog({\n                            title: errorTitle,\n                            message: errorText,\n                            onclose: function () {\n                                self.testWebcamSnapshotUrlBusy(false);\n                            }\n                        });\n                        return;\n                    }\n\n                    var content = response.response.content;\n                    var contentType = response.response.assumed_content_type;\n\n                    var mimeType = \"image/jpeg\";\n                    if (contentType) {\n                        mimeType = contentType.split(\";\")[0];\n                    }\n\n                    var text = gettext(\n                        \"If you see your webcam snapshot picture below, the entered snapshot URL is ok.\"\n                    );\n                    showMessageDialog({\n                        title: gettext(\"Snapshot test\"),\n                        message: $(\n                            \"<p>\" +\n                                text +\n                                '</p><p><img src=\"data:' +\n                                mimeType +\n                                \";base64,\" +\n                                content +\n                                '\" style=\"border: 1px solid black\" /></p>'\n                        ),\n                        onclose: function () {\n                            self.testWebcamSnapshotUrlBusy(false);\n                        }\n                    });\n                })\n                .fail(function () {\n                    showMessageDialog({\n                        title: errorTitle,\n                        message: errorText,\n                        onclose: function () {\n                            self.testWebcamSnapshotUrlBusy(false);\n                        }\n                    });\n                });\n        };\n\n        self.testWebcamFfmpegPathBusy = ko.observable(false);\n        self.testWebcamFfmpegPath = function () {\n            if (!self.webcam_ffmpegPath()) {\n                return;\n            }\n\n            if (self.testWebcamFfmpegPathBusy()) {\n                return;\n            }\n\n            self.testWebcamFfmpegPathBusy(true);\n            OctoPrint.util\n                .testExecutable(self.webcam_ffmpegPath())\n                .done(function (response) {\n                    if (!response.result) {\n                        if (!response.exists) {\n                            self.webcam_ffmpegPathText(gettext(\"The path doesn't exist\"));\n                        } else if (!response.typeok) {\n                            self.webcam_ffmpegPathText(gettext(\"The path is not a file\"));\n                        } else if (!response.access) {\n                            self.webcam_ffmpegPathText(\n                                gettext(\"The path is not an executable\")\n                            );\n                        }\n                    } else {\n                        self.webcam_ffmpegPathText(gettext(\"The path is valid\"));\n                    }\n                    self.webcam_ffmpegPathOk(response.result);\n                    self.webcam_ffmpegPathBroken(!response.result);\n                })\n                .always(function () {\n                    self.testWebcamFfmpegPathBusy(false);\n                });\n        };\n\n        self.testOnlineConnectivityConfigBusy = ko.observable(false);\n        self.testOnlineConnectivityConfig = function () {\n            if (!self.server_onlineCheck_host()) return;\n            if (!self.server_onlineCheck_port()) return;\n            if (self.testOnlineConnectivityConfigBusy()) return;\n\n            self.testOnlineConnectivityConfigBusy(true);\n            OctoPrint.util\n                .testServer(\n                    self.server_onlineCheck_host(),\n                    self.server_onlineCheck_port()\n                )\n                .done(function (response) {\n                    if (!response.result) {\n                        self.server_onlineCheckText(\n                            gettext(\"The server is not reachable\")\n                        );\n                    } else {\n                        self.server_onlineCheckText(gettext(\"The server is reachable\"));\n                    }\n                    self.server_onlineCheckOk(response.result);\n                    self.server_onlineCheckBroken(!response.result);\n                })\n                .always(function () {\n                    self.testOnlineConnectivityConfigBusy(false);\n                });\n        };\n\n        self.testOnlineConnectivityResolutionConfigBusy = ko.observable(false);\n        self.testOnlineConnectivityResolutionConfig = function () {\n            if (!self.server_onlineCheck_name()) return;\n            if (self.testOnlineConnectivityResolutionConfigBusy()) return;\n\n            self.testOnlineConnectivityResolutionConfigBusy(true);\n            OctoPrint.util\n                .testResolution(self.server_onlineCheck_name())\n                .done(function (response) {\n                    if (!response.result) {\n                        self.server_onlineCheckResolutionText(\n                            gettext(\"Name cannot be resolved\")\n                        );\n                    } else {\n                        self.server_onlineCheckResolutionText(\n                            gettext(\"Name can be resolved\")\n                        );\n                    }\n                    self.server_onlineCheckResolutionOk(response.result);\n                    self.server_onlineCheckResolutionBroken(!response.result);\n                })\n                .always(function () {\n                    self.testOnlineConnectivityResolutionConfigBusy(false);\n                });\n        };\n\n        self.testFolderConfigBusy = ko.observable(false);\n        self.testFolderConfig = function (folder) {\n            var observable = \"folder_\" + folder;\n            if (!self.hasOwnProperty(observable)) return;\n\n            if (self.testFolderConfigBusy()) return;\n            self.testFolderConfigBusy(true);\n\n            var opts = {\n                check_type: \"dir\",\n                check_access: \"w\",\n                allow_create_dir: true,\n                check_writable_dir: true\n            };\n            var path = self[observable]();\n            OctoPrint.util\n                .testPath(path, opts)\n                .done(function (response) {\n                    if (!response.result) {\n                        if (response.broken_symlink) {\n                            self.testFolderConfigText[folder](\n                                gettext(\"The path is a broken symlink.\")\n                            );\n                        } else if (!response.exists) {\n                            self.testFolderConfigText[folder](\n                                gettext(\"The path does not exist and cannot be created.\")\n                            );\n                        } else if (!response.typeok) {\n                            self.testFolderConfigText[folder](\n                                gettext(\"The path is not a folder.\")\n                            );\n                        } else if (!response.access) {\n                            self.testFolderConfigText[folder](\n                                gettext(\"The path is not writable.\")\n                            );\n                        }\n                    } else {\n                        self.testFolderConfigText[folder](gettext(\"The path is valid\"));\n                    }\n                    self.testFolderConfigOk[folder](response.result);\n                    self.testFolderConfigBroken[folder](!response.result);\n                })\n                .always(function () {\n                    self.testFolderConfigBusy(false);\n                });\n        };\n\n        self.onSettingsHidden = function () {\n            self.webcam_ffmpegPathReset();\n            self.server_onlineCheckReset();\n            self.server_onlineCheckResolutionReset();\n            self.testFolderConfigReset();\n        };\n\n        self.isDialogActive = function () {\n            return self.settingsDialog.is(\":visible\");\n        };\n\n        self.onStartup = function () {\n            self.settingsDialog = $(\"#settings_dialog\");\n            self.settingsUpdatedDialog = $(\"#settings_dialog_update_detected\");\n            self.translationManagerDialog = $(\n                \"#settings_appearance_managelanguagesdialog\"\n            );\n            self.translationUploadElement = $(\n                \"#settings_appearance_managelanguagesdialog_upload\"\n            );\n            self.translationUploadButton = $(\n                \"#settings_appearance_managelanguagesdialog_upload_start\"\n            );\n\n            self.translationUploadElement.fileupload({\n                dataType: \"json\",\n                maxNumberOfFiles: 1,\n                autoUpload: false,\n                headers: OctoPrint.getRequestHeaders(),\n                add: function (e, data) {\n                    if (data.files.length == 0) {\n                        return false;\n                    }\n\n                    self.translationUploadFilename(data.files[0].name);\n\n                    self.translationUploadButton.unbind(\"click\");\n                    self.translationUploadButton.bind(\"click\", function () {\n                        data.submit();\n                        return false;\n                    });\n                },\n                done: function (e, data) {\n                    self.translationUploadButton.unbind(\"click\");\n                    self.translationUploadFilename(undefined);\n                    self.fromTranslationResponse(data.result);\n                },\n                fail: function (e, data) {\n                    self.translationUploadButton.unbind(\"click\");\n                    self.translationUploadFilename(undefined);\n                }\n            });\n        };\n\n        self.onAllBound = function (allViewModels) {\n            self.allViewModels = allViewModels;\n\n            self.settingsDialog.on(\"show\", function (event) {\n                OctoPrint.coreui.settingsOpen = true;\n                if (event.target.id == \"settings_dialog\") {\n                    self.requestTranslationData();\n                    callViewModels(allViewModels, \"onSettingsShown\");\n                }\n            });\n            self.settingsDialog.on(\"hidden\", function (event) {\n                OctoPrint.coreui.settingsOpen = false;\n                if (event.target.id == \"settings_dialog\") {\n                    callViewModels(allViewModels, \"onSettingsHidden\");\n                }\n            });\n            self.settingsDialog.on(\"beforeSave\", function () {\n                callViewModels(allViewModels, \"onSettingsBeforeSave\");\n            });\n\n            $(\".reload_all\", self.settingsUpdatedDialog).click(function (e) {\n                e.preventDefault();\n                self.settingsUpdatedDialog.modal(\"hide\");\n                self.requestData();\n                return false;\n            });\n            $(\".reload_nonconflicts\", self.settingsUpdatedDialog).click(function (e) {\n                e.preventDefault();\n                self.settingsUpdatedDialog.modal(\"hide\");\n                self.requestData(true);\n                return false;\n            });\n\n            // reset scroll position on tab change\n            $('ul.nav-list a[data-toggle=\"tab\"]', self.settingsDialog).on(\n                \"show\",\n                function () {\n                    self._resetScrollPosition();\n                }\n            );\n        };\n\n        self.show = function (tab) {\n            // select first or specified tab\n            self.selectTab(tab);\n\n            // reset scroll position\n            self._resetScrollPosition();\n\n            // show settings, ensure centered position\n            self.settingsDialog\n                .modal({\n                    minHeight: function () {\n                        return Math.max($.fn.modal.defaults.maxHeight() - 80, 250);\n                    }\n                })\n                .css({\n                    \"margin-left\": function () {\n                        return -($(this).width() / 2);\n                    }\n                });\n\n            return false;\n        };\n\n        self.hide = function () {\n            self.settingsDialog.modal(\"hide\");\n        };\n\n        self.generateApiKey = function () {\n            if (!CONFIG_ACCESS_CONTROL) return;\n\n            showConfirmationDialog(\n                gettext(\n                    \"This will generate a new API Key. The old API Key will cease to function immediately.\"\n                ),\n                function () {\n                    OctoPrint.settings.generateApiKey().done(function (response) {\n                        self.api_key(response.apikey);\n                        self.requestData();\n                    });\n                }\n            );\n        };\n\n        self.copyApiKey = function () {\n            copyToClipboard(self.api_key());\n        };\n\n        self.showTranslationManager = function () {\n            self.translationManagerDialog.modal();\n            return false;\n        };\n\n        self.requestData = function (local) {\n            // handle old parameter format\n            var callback = undefined;\n            if (arguments.length === 2 || _.isFunction(local)) {\n                var exc = new Error();\n                log.warn(\n                    \"The callback parameter of SettingsViewModel.requestData is deprecated, the method now returns a promise, please use that instead. Stacktrace:\",\n                    exc.stack || exc.stacktrace || \"<n/a>\"\n                );\n\n                if (arguments.length === 2) {\n                    callback = arguments[0];\n                    local = arguments[1];\n                } else {\n                    callback = local;\n                    local = false;\n                }\n            }\n\n            // handler for any explicitly provided callbacks\n            var callbackHandler = function () {\n                if (!callback) return;\n                try {\n                    callback();\n                } catch (exc) {\n                    log.error(\n                        \"Error calling settings callback\",\n                        callback,\n                        \":\",\n                        exc.stack || exc.stacktrace || exc\n                    );\n                }\n            };\n\n            // if a request is already active, create a new deferred and return\n            // its promise, it will be resolved in the response handler of the\n            // current request\n            if (self.receiving()) {\n                var deferred = $.Deferred();\n                self.outstanding.push(deferred);\n\n                if (callback) {\n                    // if we have a callback, we need to make sure it will\n                    // get called when the deferred is resolved\n                    deferred.done(callbackHandler);\n                }\n\n                return deferred.promise();\n            }\n\n            // perform the request\n            self.receiving(true);\n            return OctoPrint.settings\n                .get()\n                .always(function () {\n                    self.receiving(false);\n                })\n                .done(function (response) {\n                    self.fromResponse(response, local);\n\n                    if (callback) {\n                        var deferred = $.Deferred();\n                        deferred.done(callbackHandler);\n                        self.outstanding.push(deferred);\n                    }\n\n                    // resolve all promises\n                    var args = arguments;\n                    _.each(self.outstanding, function (deferred) {\n                        deferred.resolve(args);\n                    });\n                    self.outstanding = [];\n                })\n                .fail(function () {\n                    // reject all promises\n                    var args = arguments;\n                    _.each(self.outstanding, function (deferred) {\n                        deferred.reject(args);\n                    });\n                    self.outstanding = [];\n                });\n        };\n\n        self.requestTranslationData = function () {\n            return OctoPrint.languages.list().done(self.fromTranslationResponse);\n        };\n\n        self.fromTranslationResponse = function (response) {\n            var translationsByLocale = {};\n            _.each(response.language_packs, function (item, key) {\n                _.each(item.languages, function (pack) {\n                    var locale = pack.locale;\n                    if (!_.has(translationsByLocale, locale)) {\n                        translationsByLocale[locale] = {\n                            locale: locale,\n                            display: pack.locale_display,\n                            english: pack.locale_english,\n                            packs: []\n                        };\n                    }\n\n                    translationsByLocale[locale][\"packs\"].push({\n                        identifier: key,\n                        display: item.display,\n                        pack: pack\n                    });\n                });\n            });\n\n            var translations = [];\n            _.each(translationsByLocale, function (item) {\n                item[\"packs\"].sort(function (a, b) {\n                    if (a.identifier == \"_core\") return -1;\n                    if (b.identifier == \"_core\") return 1;\n\n                    if (a.display < b.display) return -1;\n                    if (a.display > b.display) return 1;\n                    return 0;\n                });\n                translations.push(item);\n            });\n\n            self.translations.updateItems(translations);\n        };\n\n        self.languagePackDisplay = function (item) {\n            return (\n                item.display +\n                (item.english != undefined ? \" (\" + item.english + \")\" : \"\")\n            );\n        };\n\n        self.languagePacksAvailable = ko.pureComputed(function () {\n            return self.translations.allSize() > 0;\n        });\n\n        self.deleteLanguagePack = function (locale, pack) {\n            OctoPrint.languages.delete(locale, pack).done(self.fromTranslationResponse);\n        };\n\n        /**\n         * Fetches the settings as currently stored in this client instance.\n         */\n        self.getLocalData = function () {\n            var data = {};\n            if (self.settings != undefined) {\n                data = ko.mapping.toJS(self.settings);\n            }\n\n            // some special read functions for various observables\n            var specialMappings = {\n                feature: {\n                    autoUppercaseBlacklist: function () {\n                        return splitTextToArray(\n                            self.feature_autoUppercaseBlacklist(),\n                            \",\",\n                            true\n                        );\n                    }\n                },\n                serial: {\n                    additionalPorts: function () {\n                        return commentableLinesToArray(self.serial_additionalPorts());\n                    },\n                    additionalBaudrates: function () {\n                        return _.map(\n                            splitTextToArray(\n                                self.serial_additionalBaudrates(),\n                                \",\",\n                                true,\n                                function (item) {\n                                    return !isNaN(parseInt(item));\n                                }\n                            ),\n                            function (item) {\n                                return parseInt(item);\n                            }\n                        );\n                    },\n                    blacklistedPorts: function () {\n                        return commentableLinesToArray(self.serial_blacklistedPorts());\n                    },\n                    blacklistedBaudrates: function () {\n                        return _.map(\n                            splitTextToArray(\n                                self.serial_blacklistedBaudrates(),\n                                \",\",\n                                true,\n                                function (item) {\n                                    return !isNaN(parseInt(item));\n                                }\n                            ),\n                            function (item) {\n                                return parseInt(item);\n                            }\n                        );\n                    },\n                    longRunningCommands: function () {\n                        return splitTextToArray(\n                            self.serial_longRunningCommands(),\n                            \",\",\n                            true\n                        );\n                    },\n                    checksumRequiringCommands: function () {\n                        return splitTextToArray(\n                            self.serial_checksumRequiringCommands(),\n                            \",\",\n                            true\n                        );\n                    },\n                    blockedCommands: function () {\n                        return splitTextToArray(self.serial_blockedCommands(), \",\", true);\n                    },\n                    ignoredCommands: function () {\n                        return splitTextToArray(self.serial_ignoredCommands(), \",\", true);\n                    },\n                    pausingCommands: function () {\n                        return splitTextToArray(self.serial_pausingCommands(), \",\", true);\n                    },\n                    emergencyCommands: function () {\n                        return splitTextToArray(\n                            self.serial_emergencyCommands(),\n                            \",\",\n                            true\n                        );\n                    },\n                    externalHeatupDetection: function () {\n                        return !self.serial_disableExternalHeatupDetection();\n                    },\n                    alwaysSendChecksum: function () {\n                        return self.serial_sendChecksum() === \"always\";\n                    },\n                    neverSendChecksum: function () {\n                        return self.serial_sendChecksum() === \"never\";\n                    },\n                    ignoreErrorsFromFirmware: function () {\n                        return self.serial_serialErrorBehaviour() === \"ignore\";\n                    },\n                    disconnectOnErrors: function () {\n                        return self.serial_serialErrorBehaviour() === \"disconnect\";\n                    }\n                },\n                scripts: {\n                    gcode: function () {\n                        // we have a special handler function for the gcode scripts since the\n                        // server will always send us those that have been set already, so we\n                        // can't depend on all keys that we support to be present in the\n                        // original request we iterate through in mapFromObservables to\n                        // generate our response - hence we use our observables instead\n                        //\n                        // Note: If we ever introduce sub categories in the gcode scripts\n                        // here (more _ after the prefix), we'll need to adjust this code\n                        // to be able to cope with that, right now it only strips the prefix\n                        // and uses the rest as key in the result, no recursive translation\n                        // is done!\n                        var result = {};\n                        var prefix = \"scripts_gcode_\";\n                        var observables = _.filter(_.keys(self), function (key) {\n                            return _.startsWith(key, prefix);\n                        });\n                        _.each(observables, function (observable) {\n                            var script = observable.substring(prefix.length);\n                            result[script] = self[observable]();\n                        });\n                        return result;\n                    }\n                },\n                temperature: {\n                    profiles: function () {\n                        var result = [];\n                        _.each(self.temperature_profiles(), function (profile) {\n                            try {\n                                result.push({\n                                    name: profile.name,\n                                    extruder: Math.floor(\n                                        _.isNumber(profile.extruder)\n                                            ? profile.extruder\n                                            : parseInt(profile.extruder)\n                                    ),\n                                    bed: Math.floor(\n                                        _.isNumber(profile.bed)\n                                            ? profile.bed\n                                            : parseInt(profile.bed)\n                                    ),\n                                    chamber: Math.floor(\n                                        _.isNumber(profile.chamber)\n                                            ? profile.chamber\n                                            : _.isNumber(parseInt(profile.chamber))\n                                            ? parseInt(profile.chamber)\n                                            : 0\n                                    )\n                                });\n                            } catch (ex) {\n                                // ignore\n                            }\n                        });\n                        return result;\n                    }\n                },\n                webcam: {\n                    streamWebrtcIceServers: function () {\n                        return splitTextToArray(\n                            self.webcam_streamWebrtcIceServers(),\n                            \",\",\n                            true\n                        );\n                    }\n                }\n            };\n\n            var mapFromObservables = function (data, mapping, keyPrefix) {\n                var flag = false;\n                var result = {};\n\n                // process all key-value-pairs here\n                _.forOwn(data, function (value, key) {\n                    var observable = key;\n                    if (keyPrefix !== undefined) {\n                        observable = keyPrefix + \"_\" + observable;\n                    }\n\n                    if (self.observableCopies.hasOwnProperty(observable)) {\n                        // only a copy, skip\n                        return;\n                    }\n\n                    if (mapping && mapping[key] && _.isFunction(mapping[key])) {\n                        result[key] = mapping[key]();\n                        flag = true;\n                    } else if (_.isPlainObject(value)) {\n                        // value is another object, we'll dive deeper\n                        var subresult = mapFromObservables(\n                            value,\n                            mapping && mapping[key] ? mapping[key] : undefined,\n                            observable\n                        );\n                        if (subresult !== undefined) {\n                            // we only set something on our result if we got something back\n                            result[key] = subresult;\n                            flag = true;\n                        }\n                    } else if (self.hasOwnProperty(observable)) {\n                        result[key] = self[observable]();\n                        flag = true;\n                    }\n                });\n\n                // if we set something on our result (flag is true), we return result, else we return undefined\n                return flag ? result : undefined;\n            };\n\n            // map local observables based on our existing data\n            var dataFromObservables = mapFromObservables(data, specialMappings);\n\n            data = deepMerge(data, dataFromObservables);\n            return data;\n        };\n\n        self.fromResponse = function (response, local) {\n            // server side changes to set\n            var serverChangedData;\n\n            // client side changes to keep\n            var clientChangedData;\n\n            if (local) {\n                // local is true, so we'll keep all local changes and only update what's been updated server side\n                serverChangedData = getOnlyChangedData(\n                    response,\n                    self.lastReceivedSettings\n                );\n                clientChangedData = getOnlyChangedData(\n                    self.getLocalData(),\n                    self.lastReceivedSettings\n                );\n            } else {\n                // local is false or unset, so we'll forcefully update with the settings from the server\n                serverChangedData = response;\n                clientChangedData = undefined;\n            }\n\n            // last received settings reset to response\n            self.lastReceivedSettings = response;\n\n            if (self.settings === undefined) {\n                self.settings = ko.mapping.fromJS(serverChangedData);\n            } else {\n                ko.mapping.fromJS(serverChangedData, self.settings);\n            }\n\n            // some special apply functions for various observables\n            var specialMappings = {\n                appearance: {\n                    defaultLanguage: function (value) {\n                        self.appearance_defaultLanguage(\"_default\");\n                        if (_.includes(self.locale_languages, value)) {\n                            self.appearance_defaultLanguage(value);\n                        }\n                    }\n                },\n                feature: {\n                    autoUppercaseBlacklist: function (value) {\n                        self.feature_autoUppercaseBlacklist(value.join(\", \"));\n                    }\n                },\n                serial: {\n                    additionalPorts: function (value) {\n                        self.serial_additionalPorts(value.join(\"\\n\"));\n                    },\n                    additionalBaudrates: function (value) {\n                        self.serial_additionalBaudrates(value.join(\", \"));\n                    },\n                    blacklistedPorts: function (value) {\n                        self.serial_blacklistedPorts(value.join(\"\\n\"));\n                    },\n                    blacklistedBaudrates: function (value) {\n                        self.serial_blacklistedBaudrates(value.join(\", \"));\n                    },\n                    longRunningCommands: function (value) {\n                        self.serial_longRunningCommands(value.join(\", \"));\n                    },\n                    checksumRequiringCommands: function (value) {\n                        self.serial_checksumRequiringCommands(value.join(\", \"));\n                    },\n                    blockedCommands: function (value) {\n                        self.serial_blockedCommands(value.join(\", \"));\n                    },\n                    ignoredCommands: function (value) {\n                        self.serial_ignoredCommands(value.join(\", \"));\n                    },\n                    pausingCommands: function (value) {\n                        self.serial_pausingCommands(value.join(\", \"));\n                    },\n                    emergencyCommands: function (value) {\n                        self.serial_emergencyCommands(value.join(\", \"));\n                    },\n                    externalHeatupDetection: function (value) {\n                        self.serial_disableExternalHeatupDetection(!value);\n                    },\n                    alwaysSendChecksum: function (value) {\n                        if (value) {\n                            self.serial_sendChecksum(\"always\");\n                        }\n                    },\n                    neverSendChecksum: function (value) {\n                        if (value) {\n                            self.serial_sendChecksum(\"never\");\n                        }\n                    },\n                    ignoreErrorsFromFirmware: function (value) {\n                        if (value) {\n                            self.serial_serialErrorBehaviour(\"ignore\");\n                        }\n                    },\n                    disconnectOnErrors: function (value) {\n                        if (value) {\n                            self.serial_serialErrorBehaviour(\"disconnect\");\n                        }\n                    }\n                },\n                terminalFilters: function (value) {\n                    self.terminalFilters($.extend(true, [], value));\n                },\n                temperature: {\n                    profiles: function (value) {\n                        self.temperature_profiles($.extend(true, [], value));\n                    }\n                },\n                webcam: {\n                    streamWebrtcIceServers: function (value) {\n                        self.webcam_streamWebrtcIceServers(value.join(\", \"));\n                    }\n                }\n            };\n\n            var mapToObservables = function (data, mapping, local, keyPrefix) {\n                if (!_.isPlainObject(data)) {\n                    return;\n                }\n\n                // process all key-value-pairs here\n                _.forOwn(data, function (value, key) {\n                    var observable = key;\n                    if (keyPrefix != undefined) {\n                        observable = keyPrefix + \"_\" + observable;\n                    }\n\n                    if (self.observableCopies.hasOwnProperty(observable)) {\n                        // only a copy, skip\n                        return;\n                    }\n\n                    var haveLocalVersion = local && local.hasOwnProperty(key);\n\n                    if (\n                        mapping &&\n                        mapping[key] &&\n                        _.isFunction(mapping[key]) &&\n                        !haveLocalVersion\n                    ) {\n                        // if we have a custom apply function for this, we'll use it\n                        mapping[key](value);\n                    } else if (_.isPlainObject(value)) {\n                        // value is another object, we'll dive deeper\n                        mapToObservables(\n                            value,\n                            mapping && mapping[key] ? mapping[key] : undefined,\n                            local && local[key] ? local[key] : undefined,\n                            observable\n                        );\n                    } else if (!haveLocalVersion && self.hasOwnProperty(observable)) {\n                        // if we have a matching observable, we'll use that\n                        self[observable](value);\n                    }\n                });\n            };\n\n            mapToObservables(serverChangedData, specialMappings, clientChangedData);\n\n            firstRequest.resolve();\n        };\n\n        self.cancelData = function () {\n            // revert unsaved changes\n            self.fromResponse(self.lastReceivedSettings);\n\n            self.hide();\n        };\n\n        self.saveData = function (data, successCallback, setAsSending) {\n            var options;\n            if (_.isPlainObject(successCallback)) {\n                options = successCallback;\n            } else {\n                options = {\n                    success: successCallback,\n                    sending: setAsSending === true\n                };\n            }\n\n            self.settingsDialog.trigger(\"beforeSave\");\n\n            self.sawUpdateEventWhileSending = false;\n            self.sending(data === undefined || options.sending || false);\n\n            if (data === undefined) {\n                // we also only send data that actually changed when no data is specified\n                var localData = self.getLocalData();\n                data = getOnlyChangedData(localData, self.lastReceivedSettings);\n            }\n\n            // final validation\n            if (self.testFoldersDuplicate()) {\n                // duplicate folders configured, we refuse to send any folder config\n                // to the server\n                delete data.folder;\n            }\n\n            self.active = true;\n            return OctoPrint.settings\n                .save(data)\n                .done(function (data, status, xhr) {\n                    self.ignoreNextUpdateEvent = !self.sawUpdateEventWhileSending;\n                    self.active = false;\n\n                    self.receiving(true);\n                    self.sending(false);\n\n                    try {\n                        self.fromResponse(data);\n                        if (options.success) options.success(data, status, xhr);\n                    } finally {\n                        self.receiving(false);\n                    }\n                })\n                .fail(function (xhr, status, error) {\n                    self.sending(false);\n                    self.active = false;\n                    if (options.error) options.error(xhr, status, error);\n                })\n                .always(function (xhr, status) {\n                    if (options.complete) options.complete(xhr, status);\n                });\n        };\n\n        self.onEventSettingsUpdated = function () {\n            if (self.active) {\n                self.sawUpdateEventWhileActive = true;\n            }\n\n            var preventSettingsRefresh = _.any(self.allViewModels, function (viewModel) {\n                if (viewModel.hasOwnProperty(\"onSettingsPreventRefresh\")) {\n                    try {\n                        return viewModel[\"onSettingsPreventRefresh\"]();\n                    } catch (e) {\n                        log.warn(\n                            \"Error while calling onSettingsPreventRefresh on\",\n                            viewModel,\n                            \":\",\n                            e\n                        );\n                        return false;\n                    }\n                } else {\n                    return false;\n                }\n            });\n\n            if (preventSettingsRefresh) {\n                // if any of our viewmodels prevented this refresh, we'll just return now\n                return;\n            }\n\n            if (self.isDialogActive()) {\n                // dialog is open and not currently busy...\n                if (\n                    self.sending() ||\n                    self.receiving() ||\n                    self.active ||\n                    self.ignoreNextUpdateEvent\n                ) {\n                    self.ignoreNextUpdateEvent = false;\n                    return;\n                }\n\n                if (!hasDataChanged(self.getLocalData(), self.lastReceivedSettings)) {\n                    // we don't have local changes, so just fetch new data\n                    self.requestData();\n                } else {\n                    // we have local changes, show update dialog\n                    self.settingsUpdatedDialog.modal(\"show\");\n                }\n            } else {\n                // dialog is not open, just fetch new data\n                self.requestData();\n            }\n        };\n\n        self._resetScrollPosition = function () {\n            $(\"#settings_dialog_content\", self.settingsDialog).scrollTop(0);\n\n            // also reset any contained tabs/pills/lists to first pane\n            $(\n                '#settings_dialog_content ul.nav-pills a[data-toggle=\"tab\"]:first',\n                self.settingsDialog\n            ).tab(\"show\");\n            $(\n                '#settings_dialog_content ul.nav-list a[data-toggle=\"tab\"]:first',\n                self.settingsDialog\n            ).tab(\"show\");\n            $(\n                '#settings_dialog_content ul.nav-tabs a[data-toggle=\"tab\"]:first',\n                self.settingsDialog\n            ).tab(\"show\");\n        };\n\n        self.selectTab = function (tab) {\n            if (tab != undefined) {\n                if (!_.startsWith(tab, \"#\")) {\n                    tab = \"#\" + tab;\n                }\n                $('ul.nav-list a[href=\"' + tab + '\"]', self.settingsDialog).tab(\"show\");\n            } else {\n                $('ul.nav-list a[data-toggle=\"tab\"]:first', self.settingsDialog).tab(\n                    \"show\"\n                );\n            }\n        };\n\n        self.onServerReconnect = function () {\n            // the settings might have changed if the server was just restarted,\n            // better refresh them now\n            self.requestData();\n        };\n\n        self.onUserPermissionsChanged =\n            self.onUserLoggedIn =\n            self.onUserLoggedOut =\n                function () {\n                    // we might have other user rights now, refresh (but only if startup has fully completed)\n                    if (!self._startupComplete) return;\n                    self.requestData();\n                };\n    }\n\n    OCTOPRINT_VIEWMODELS.push({\n        construct: SettingsViewModel,\n        dependencies: [\n            \"loginStateViewModel\",\n            \"accessViewModel\",\n            \"printerProfilesViewModel\",\n            \"aboutViewModel\",\n            \"usersViewModel\"\n        ],\n        elements: [\"#settings_dialog\", \"#navbar_settings\"]\n    });\n});\n", "<div class=\"control-group\" title=\"{{ _('URL to embed into the UI for live viewing of the webcam stream')|edq }}\">\n    <label class=\"control-label\" for=\"settings-webcamStreamUrl\">{{ _('Stream URL') }}</label>\n    <div class=\"controls\">\n        <div class=\"input-append\">\n            <input type=\"text\" class=\"input-block-level\" data-bind=\"value: webcam_streamUrl, valueUpdate: 'afterkeydown'\" id=\"settings-webcamStreamUrl\">\n            <button class=\"btn\" type=\"button\" data-bind=\"click: testWebcamStreamUrl, enable: webcam_streamUrl() && !testWebcamStreamUrlBusy(), css: {disabled: !webcam_streamUrl() || testWebcamStreamUrlBusy()}\"><i class=\"fas fa-spinner fa-spin\" data-bind=\"visible: testWebcamStreamUrlBusy\"></i> {{ _('Test') }}</button>\n        </div>\n        <span class=\"help-block\">\n            <p>{% trans %}Needs to be reachable from the browser displaying the OctoPrint UI, used to embed the webcam stream into the page.{% endtrans %}</p>\n            <p data-bind=\"visible: webcam_streamType() === 'webrtc'\">{% trans %}<strong>Heads-up!</strong> WebRTC support is still in beta and subject to change, monitor the changelog of future versions closely for heads-ups regarding the WebRTC support in OctoPrint.{% endtrans %}</p>\n        </span>\n    </div>\n</div>\n"], "fixing_code": ["function ItemListHelper(\n    listType,\n    supportedSorting,\n    supportedFilters,\n    defaultSorting,\n    defaultFilters,\n    exclusiveFilters,\n    defaultPageSize,\n    persistPageSize\n) {\n    var self = this;\n\n    self.listType = listType;\n    self.supportedSorting = supportedSorting;\n    self.supportedFilters = supportedFilters;\n    self.defaultSorting = defaultSorting;\n    self.defaultFilters = defaultFilters;\n    self.exclusiveFilters = exclusiveFilters;\n    self.defaultPageSize = defaultPageSize;\n    self.persistPageSize = !!persistPageSize;\n\n    self.searchFunction = undefined;\n\n    self.allItems = [];\n    self.allSize = ko.observable(0);\n\n    self.items = ko.observableArray([]);\n    self.pageSize = ko.observable(self.defaultPageSize);\n    self.currentPage = ko.observable(0);\n    self.currentSorting = ko.observable(self.defaultSorting);\n    self.currentFilters = ko.observableArray(self.defaultFilters);\n    self.selectedItem = ko.observable(undefined);\n    self.filterSearch = ko.observable(true);\n\n    self.storageIds = {\n        currentSorting: self.listType + \".\" + \"currentSorting\",\n        currentFilters: self.listType + \".\" + \"currentFilters\",\n        pageSize: self.listType + \".\" + \"pageSize\"\n    };\n\n    //~~ item handling\n\n    self.refresh = function () {\n        self._updateItems();\n    };\n\n    self.updateItems = function (items) {\n        if (items === undefined) items = [];\n        self.allItems = items;\n        self.allSize(items.length);\n        self._updateItems();\n    };\n\n    self.selectItem = function (matcher) {\n        var itemList = self.items();\n        for (var i = 0; i < itemList.length; i++) {\n            if (matcher(itemList[i])) {\n                self.selectedItem(itemList[i]);\n                return true;\n            }\n        }\n        return false;\n    };\n\n    self.selectNone = function () {\n        self.selectedItem(undefined);\n    };\n\n    self.isSelected = function (data) {\n        return self.selectedItem() === data;\n    };\n\n    self.isSelectedByMatcher = function (matcher) {\n        return matcher(self.selectedItem());\n    };\n\n    self.removeItem = function (matcher) {\n        var index = self.getIndex(matcher, true);\n        if (index > -1) {\n            self.allItems.splice(index, 1);\n            self._updateItems();\n        }\n    };\n\n    self.updateItem = function (matcher, item) {\n        var index = self.allItems.findIndex(matcher);\n        if (index > -1) {\n            self.allItems[index] = item;\n            self._updateItems();\n        }\n    };\n\n    self.addItem = function (item) {\n        self.allItems.push(item);\n        self._updateItems();\n    };\n\n    //~~ pagination\n\n    self.paginatedItems = ko.dependentObservable(function () {\n        if (self.items() === undefined) {\n            return [];\n        } else if (self.pageSize() === 0) {\n            return self.items();\n        } else {\n            var from = Math.max(self.currentPage() * self.pageSize(), 0);\n            var to = Math.min(from + self.pageSize(), self.items().length);\n            return self.items().slice(from, to);\n        }\n    });\n    self.lastPage = ko.dependentObservable(function () {\n        return self.pageSize() === 0\n            ? 1\n            : Math.ceil(self.items().length / self.pageSize()) - 1;\n    });\n    self.pages = ko.dependentObservable(function () {\n        var pages = [];\n        var i;\n\n        if (self.pageSize() === 0) {\n            pages.push({number: 0, text: 1});\n        } else if (self.lastPage() < 7) {\n            for (i = 0; i < self.lastPage() + 1; i++) {\n                pages.push({number: i, text: i + 1});\n            }\n        } else {\n            pages.push({number: 0, text: 1});\n            if (self.currentPage() < 5) {\n                for (i = 1; i < 5; i++) {\n                    pages.push({number: i, text: i + 1});\n                }\n                pages.push({number: -1, text: \"\u2026\"});\n            } else if (self.currentPage() > self.lastPage() - 5) {\n                pages.push({number: -1, text: \"\u2026\"});\n                for (i = self.lastPage() - 4; i < self.lastPage(); i++) {\n                    pages.push({number: i, text: i + 1});\n                }\n            } else {\n                pages.push({number: -1, text: \"\u2026\"});\n                for (i = self.currentPage() - 1; i <= self.currentPage() + 1; i++) {\n                    pages.push({number: i, text: i + 1});\n                }\n                pages.push({number: -1, text: \"\u2026\"});\n            }\n            pages.push({number: self.lastPage(), text: self.lastPage() + 1});\n        }\n        return pages;\n    });\n\n    self.switchToItem = function (matcher) {\n        var pos = -1;\n        var itemList = self.items();\n        for (var i = 0; i < itemList.length; i++) {\n            if (matcher(itemList[i])) {\n                pos = i;\n                break;\n            }\n        }\n\n        if (pos > -1) {\n            var page = Math.floor(pos / self.pageSize());\n            self.changePage(page);\n        }\n    };\n\n    self.changePage = function (newPage) {\n        if (newPage < 0 || newPage > self.lastPage()) return;\n        self.currentPage(newPage);\n    };\n    self.prevPage = function () {\n        if (self.currentPage() > 0) {\n            self.currentPage(self.currentPage() - 1);\n        }\n    };\n    self.nextPage = function () {\n        if (self.currentPage() < self.lastPage()) {\n            self.currentPage(self.currentPage() + 1);\n        }\n    };\n\n    self.getIndex = function (matcher, all) {\n        var itemList;\n        if (all !== undefined && all === true) {\n            itemList = self.allItems;\n        } else {\n            itemList = self.items();\n        }\n\n        for (var i = 0; i < itemList.length; i++) {\n            if (matcher(itemList[i])) {\n                return i;\n            }\n        }\n        return -1;\n    };\n\n    self.getItem = function (matcher, all) {\n        var index = self.getIndex(matcher, all);\n        if (all !== undefined && all === true) {\n            return index > -1 ? self.allItems[index] : undefined;\n        } else {\n            return index > -1 ? self.items()[index] : undefined;\n        }\n    };\n\n    self.resetPage = function () {\n        if (self.currentPage() > self.lastPage()) {\n            self.currentPage(self.lastPage());\n        }\n    };\n\n    //~~ searching\n\n    self.changeSearchFunction = function (searchFunction) {\n        self.searchFunction = searchFunction;\n        self.changePage(0);\n        self._updateItems();\n    };\n\n    self.resetSearch = function () {\n        self.changeSearchFunction(undefined);\n    };\n\n    //~~ sorting\n\n    self.changeSorting = function (sorting) {\n        if (!_.contains(_.keys(self.supportedSorting), sorting)) return;\n\n        self.currentSorting(sorting);\n        self._saveCurrentSortingToLocalStorage();\n\n        self.changePage(0);\n        self._updateItems();\n    };\n\n    //~~ filtering\n\n    self.setFilterSearch = function (enabled) {\n        if (self.filterSearch() === enabled) return;\n\n        self.filterSearch(enabled);\n        self.changePage(0);\n        self._updateItems();\n    };\n\n    self.toggleFilterSearch = function () {\n        self.setFilterSearch(!self.filterSearch());\n    };\n\n    self.toggleFilter = function (filter) {\n        if (!_.contains(_.keys(self.supportedFilters), filter)) return;\n\n        if (_.contains(self.currentFilters(), filter)) {\n            self.removeFilter(filter);\n        } else {\n            self.addFilter(filter);\n        }\n    };\n\n    self.addFilter = function (filter) {\n        if (!_.contains(_.keys(self.supportedFilters), filter)) return;\n\n        for (var i = 0; i < self.exclusiveFilters.length; i++) {\n            if (_.contains(self.exclusiveFilters[i], filter)) {\n                for (var j = 0; j < self.exclusiveFilters[i].length; j++) {\n                    if (self.exclusiveFilters[i][j] === filter) continue;\n                    self.removeFilter(self.exclusiveFilters[i][j]);\n                }\n            }\n        }\n\n        var filters = self.currentFilters();\n        filters.push(filter);\n        self.currentFilters(filters);\n        self._saveCurrentFiltersToLocalStorage();\n\n        self.changePage(0);\n        self._updateItems();\n    };\n\n    self.removeFilter = function (filter) {\n        if (!_.contains(_.keys(self.supportedFilters), filter)) return;\n\n        var filters = self.currentFilters();\n        filters = _.without(filters, filter);\n        self.currentFilters(filters);\n        self._saveCurrentFiltersToLocalStorage();\n\n        self.changePage(0);\n        self._updateItems();\n    };\n\n    //~~ update for sorted and filtered view\n\n    self._updateItems = function () {\n        // determine comparator\n        var comparator = undefined;\n        var currentSorting = self.currentSorting();\n        if (\n            typeof currentSorting !== \"undefined\" &&\n            typeof self.supportedSorting[currentSorting] !== \"undefined\"\n        ) {\n            comparator = self.supportedSorting[currentSorting];\n        }\n\n        // work on all items\n        var result = self.allItems;\n\n        var hasSearch = typeof self.searchFunction !== \"undefined\" && self.searchFunction;\n\n        // filter if we're not searching or have search filtering enabled\n        if (!hasSearch || self.filterSearch()) {\n            var filters = self.currentFilters();\n            _.each(filters, function (filter) {\n                if (\n                    typeof filter !== \"undefined\" &&\n                    typeof supportedFilters[filter] !== \"undefined\"\n                )\n                    result = _.filter(result, supportedFilters[filter]);\n            });\n        }\n\n        // search if necessary\n        if (hasSearch) {\n            result = _.filter(result, self.searchFunction);\n        }\n\n        // sort if necessary\n        if (typeof comparator !== \"undefined\") result.sort(comparator);\n\n        // set result list\n        self.items(result);\n    };\n\n    //~~ local storage\n\n    self._saveCurrentSortingToLocalStorage = function () {\n        if (self._initializeLocalStorage()) {\n            var currentSorting = self.currentSorting();\n            if (currentSorting !== undefined)\n                localStorage[self.storageIds.currentSorting] = currentSorting;\n            else localStorage[self.storageIds.currentSorting] = undefined;\n        }\n    };\n\n    self._loadCurrentSortingFromLocalStorage = function () {\n        if (self._initializeLocalStorage()) {\n            if (\n                _.contains(\n                    _.keys(supportedSorting),\n                    localStorage[self.storageIds.currentSorting]\n                )\n            )\n                self.currentSorting(localStorage[self.storageIds.currentSorting]);\n            else self.currentSorting(defaultSorting);\n        }\n    };\n\n    self._saveCurrentFiltersToLocalStorage = function () {\n        if (self._initializeLocalStorage()) {\n            var filters = _.intersection(\n                _.keys(self.supportedFilters),\n                self.currentFilters()\n            );\n            localStorage[self.storageIds.currentFilters] = JSON.stringify(filters);\n        }\n    };\n\n    self._loadCurrentFiltersFromLocalStorage = function () {\n        if (self._initializeLocalStorage()) {\n            self.currentFilters(\n                _.intersection(\n                    _.keys(self.supportedFilters),\n                    JSON.parse(localStorage[self.storageIds.currentFilters])\n                )\n            );\n        }\n    };\n\n    self._savePageSizeToLocalStorage = function (pageSize) {\n        if (self._initializeLocalStorage() && self.persistPageSize) {\n            localStorage[self.storageIds.pageSize] = pageSize;\n        }\n    };\n\n    self.pageSize.subscribe(self._savePageSizeToLocalStorage);\n\n    self._loadPageSizeFromLocalStorage = function () {\n        if (self._initializeLocalStorage() && self.persistPageSize) {\n            self.pageSize(parseInt(localStorage[self.storageIds.pageSize]));\n        }\n    };\n\n    self._initializeLocalStorage = function () {\n        if (!Modernizr.localstorage) return false;\n\n        if (\n            localStorage[self.storageIds.currentSorting] !== undefined &&\n            localStorage[self.storageIds.currentFilters] !== undefined &&\n            JSON.parse(localStorage[self.storageIds.currentFilters]) instanceof Array &&\n            localStorage[self.storageIds.pageSize] !== undefined\n        )\n            return true;\n\n        localStorage[self.storageIds.currentSorting] = self.defaultSorting;\n        localStorage[self.storageIds.currentFilters] = JSON.stringify(\n            self.defaultFilters\n        );\n        localStorage[self.storageIds.pageSize] = self.defaultPageSize;\n\n        return true;\n    };\n\n    self._loadCurrentFiltersFromLocalStorage();\n    self._loadCurrentSortingFromLocalStorage();\n    self._loadPageSizeFromLocalStorage();\n}\n\nfunction formatSize(bytes) {\n    if (!bytes) return \"-\";\n\n    var units = [\"bytes\", \"KB\", \"MB\", \"GB\"];\n    for (var i = 0; i < units.length; i++) {\n        if (bytes < 1024) {\n            return _.sprintf(\"%3.1f%s\", bytes, units[i]);\n        }\n        bytes /= 1024;\n    }\n    return _.sprintf(\"%.1f%s\", bytes, \"TB\");\n}\n\nfunction formatHuman(number) {\n    if (number === undefined) return \"-\";\n    if (number < 1000) return number;\n\n    return _.sprintf(\"%.1fK\", number / 1000);\n}\n\nfunction bytesFromSize(size) {\n    if (size === undefined || size.trim() === \"\") return undefined;\n\n    var parsed = size.match(/^([+]?[0-9]*\\.?[0-9]+)(?:\\s*)?(.*)$/);\n    var number = parsed[1];\n    var unit = parsed[2].trim();\n\n    if (unit === \"\") return parseFloat(number);\n\n    var units = {\n        b: 1,\n        byte: 1,\n        bytes: 1,\n        kb: 1024,\n        mb: Math.pow(1024, 2),\n        gb: Math.pow(1024, 3),\n        tb: Math.pow(1024, 4)\n    };\n    unit = unit.toLowerCase();\n\n    if (!units.hasOwnProperty(unit)) {\n        return undefined;\n    }\n\n    var factor = units[unit];\n    return number * factor;\n}\n\nfunction formatDuration(seconds) {\n    if (!seconds) return \"-\";\n    if (seconds < 1) return \"00:00:00\";\n\n    var s = seconds % 60;\n    var m = (seconds % 3600) / 60;\n    var h = seconds / 3600;\n\n    return _.sprintf(\n        gettext(/* L10N: duration format */ \"%(hour)02d:%(minute)02d:%(second)02d\"),\n        {hour: h, minute: m, second: s}\n    );\n}\n\nfunction formatFuzzyEstimation(seconds, base) {\n    if (!seconds || seconds < 1) return \"-\";\n\n    var m;\n    if (base !== undefined) {\n        m = moment(base);\n    } else {\n        m = moment();\n    }\n\n    m.add(seconds, \"s\");\n    return m.fromNow(true);\n}\n\nfunction formatFuzzyPrintTime(totalSeconds) {\n    /**\n     * Formats a print time estimate in a very fuzzy way.\n     *\n     * Accuracy decreases the higher the estimation is:\n     *\n     *   * less than 30s: \"a few seconds\"\n     *   * 30s to a minute: \"less than a minute\"\n     *   * 1 to 30min: rounded to full minutes, above 30s is minute + 1 (\"27 minutes\", \"2 minutes\")\n     *   * 30min to 40min: \"40 minutes\"\n     *   * 40min to 50min: \"50 minutes\"\n     *   * 50min to 1h: \"1 hour\"\n     *   * 1 to 12h: rounded to half hours, 15min to 45min is \".5\", above that hour + 1 (\"4 hours\", \"2.5 hours\")\n     *   * 12 to 24h: rounded to full hours, above 30min is hour + 1, over 23.5h is \"1 day\"\n     *   * Over a day: rounded to half days, 8h to 16h is \".5\", above that days + 1 (\"1 day\", \"4 days\", \"2.5 days\")\n     */\n\n    if (!totalSeconds || totalSeconds < 1) return \"-\";\n\n    var d = moment.duration(totalSeconds, \"seconds\");\n\n    var seconds = d.seconds();\n    var minutes = d.minutes();\n    var hours = d.hours();\n    var days = d.days();\n\n    var replacements = {\n        days: days,\n        hours: hours,\n        minutes: minutes,\n        seconds: seconds,\n        totalSeconds: totalSeconds\n    };\n\n    var text = \"-\";\n\n    if (days >= 1) {\n        // days\n        if (hours >= 16) {\n            replacements.days += 1;\n\n            if (replacements.days === 1) {\n                text = gettext(\"%(days)d day\");\n            } else {\n                text = gettext(\"%(days)d days\");\n            }\n        } else if (hours >= 8 && hours < 16) {\n            text = gettext(\"%(days)d.5 days\");\n        } else {\n            if (days === 1) {\n                text = gettext(\"%(days)d day\");\n            } else {\n                text = gettext(\"%(days)d days\");\n            }\n        }\n    } else if (hours >= 1) {\n        // only hours\n        if (hours < 12) {\n            if (minutes < 15) {\n                // less than .15 => .0\n                if (hours === 1) {\n                    text = gettext(\"%(hours)d hour\");\n                } else {\n                    text = gettext(\"%(hours)d hours\");\n                }\n            } else if (minutes >= 15 && minutes < 45) {\n                // between .25 and .75 => .5\n                text = gettext(\"%(hours)d.5 hours\");\n            } else {\n                // over .75 => hours + 1\n                replacements.hours += 1;\n\n                if (replacements.hours === 1) {\n                    text = gettext(\"%(hours)d hour\");\n                } else {\n                    text = gettext(\"%(hours)d hours\");\n                }\n            }\n        } else {\n            if (hours === 23 && minutes > 30) {\n                // over 23.5 hours => 1 day\n                text = gettext(\"1 day\");\n            } else {\n                if (minutes > 30) {\n                    // over .5 => hours + 1\n                    replacements.hours += 1;\n                }\n                text = gettext(\"%(hours)d hours\");\n            }\n        }\n    } else if (minutes >= 1) {\n        // only minutes\n        if (minutes < 2) {\n            if (seconds < 30) {\n                text = gettext(\"a minute\");\n            } else {\n                text = gettext(\"2 minutes\");\n            }\n        } else if (minutes < 30) {\n            if (seconds > 30) {\n                replacements.minutes += 1;\n            }\n            text = gettext(\"%(minutes)d minutes\");\n        } else if (minutes <= 40) {\n            text = gettext(\"40 minutes\");\n        } else if (minutes <= 50) {\n            text = gettext(\"50 minutes\");\n        } else {\n            text = gettext(\"1 hour\");\n        }\n    } else {\n        // only seconds\n        if (seconds < 30) {\n            text = gettext(\"a few seconds\");\n        } else {\n            text = gettext(\"less than a minute\");\n        }\n    }\n\n    return _.sprintf(text, replacements);\n}\n\nfunction formatDate(unixTimestamp, options) {\n    if (!options) {\n        options = {seconds: false};\n    }\n\n    if (!unixTimestamp) return \"-\";\n\n    var format = gettext(/* L10N: Date format */ \"YYYY-MM-DD HH:mm\");\n    if (options.seconds) {\n        format = gettext(/* L10N: Date format with seconds */ \"YYYY-MM-DD HH:mm:ss\");\n    }\n\n    return moment.unix(unixTimestamp).format(format);\n}\n\nfunction formatTimeAgo(unixTimestamp) {\n    if (!unixTimestamp) return \"-\";\n    return moment.unix(unixTimestamp).fromNow();\n}\n\nfunction formatFilament(filament) {\n    if (!filament || !filament[\"length\"]) return \"-\";\n    var result = \"%(length).02fm\";\n    if (filament.hasOwnProperty(\"volume\") && filament.volume) {\n        result += \" / \" + \"%(volume).02fcm\u00b3\";\n    }\n    return _.sprintf(result, {\n        length: filament[\"length\"] / 1000,\n        volume: filament[\"volume\"]\n    });\n}\n\nfunction cleanTemperature(temp, offThreshold) {\n    if (temp === undefined || !_.isNumber(temp)) return \"-\";\n    if (offThreshold !== undefined && temp < offThreshold) return gettext(\"off\");\n    return temp;\n}\n\nfunction formatTemperature(temp, showF, offThreshold) {\n    if (temp === undefined || !_.isNumber(temp)) return \"-\";\n    if (offThreshold !== undefined && temp < offThreshold) return gettext(\"off\");\n    if (showF) {\n        return _.sprintf(\"%.1f&deg;C (%.1f&deg;F)\", temp, (temp * 9) / 5 + 32);\n    } else {\n        return _.sprintf(\"%.1f&deg;C\", temp);\n    }\n}\n\nfunction formatNumberK(num) {\n    if (num > 1000) {\n        num = num / 1000.0;\n        return _.sprintf(\"%.2fk\", num);\n    } else {\n        return _.sprintf(\"%i\", num);\n    }\n}\n\nfunction pnotifyAdditionalInfo(inner) {\n    return (\n        '<div class=\"pnotify_additional_info\">' +\n        '<div class=\"pnotify_more\"><a href=\"#\" onclick=\"$(this).children().toggleClass(\\'icon-caret-right icon-caret-down\\').parent().parent().next().slideToggle(\\'fast\\')\">More <i class=\"icon-caret-right\"></i></a></div>' +\n        '<div class=\"pnotify_more_container hide\">' +\n        inner +\n        \"</div>\" +\n        \"</div>\"\n    );\n}\n\nfunction ping(url, callback) {\n    var img = new Image();\n    var calledBack = false;\n\n    img.onload = function () {\n        callback(true);\n        calledBack = true;\n    };\n    img.onerror = function () {\n        if (!calledBack) {\n            callback(true);\n            calledBack = true;\n        }\n    };\n    img.src = url;\n    setTimeout(function () {\n        if (!calledBack) {\n            callback(false);\n            calledBack = true;\n        }\n    }, 1500);\n}\n\nfunction showOfflineOverlay(title, message, reconnectCallback) {\n    if (title === undefined) {\n        title = gettext(\"Server is offline\");\n    }\n\n    $(\"#offline_overlay_title\").text(title);\n    $(\"#offline_overlay_message\").html(message);\n    $(\"#offline_overlay_reconnect\").click(reconnectCallback);\n\n    var overlay = $(\"#offline_overlay\");\n    if (!overlay.is(\":visible\")) overlay.show();\n}\n\nfunction hideOfflineOverlay() {\n    $(\"#offline_overlay\").hide();\n}\n\nfunction showMessageDialog(msg, options) {\n    options = options || {};\n    if (_.isPlainObject(msg)) {\n        options = msg;\n    } else {\n        options.message = msg;\n    }\n\n    var title = options.title || \"\";\n    var message = options.message || \"\";\n    var close = options.close || gettext(\"Close\");\n    var onclose = options.onclose || undefined;\n    var onshow = options.onshow || undefined;\n    var onshown = options.onshown || undefined;\n    var nofade = options.nofade || false;\n\n    if (_.isString(message)) {\n        message = $(\"<p>\" + message + \"</p>\");\n    }\n\n    var modalHeader = $(\n        '<a href=\"javascript:void(0)\" class=\"close\" data-dismiss=\"modal\" aria-hidden=\"true\">&times;</a><h3>' +\n            title +\n            \"</h3>\"\n    );\n    var modalBody = $(message);\n    var modalFooter = $(\n        '<a href=\"javascript:void(0)\" class=\"btn\" data-dismiss=\"modal\" aria-hidden=\"true\">' +\n            close +\n            \"</a>\"\n    );\n\n    var modal = $(\"<div></div>\").addClass(\"modal hide\");\n    if (!nofade) {\n        modal.addClass(\"fade-in\");\n    }\n    modal\n        .append($(\"<div></div>\").addClass(\"modal-header\").append(modalHeader))\n        .append($(\"<div></div>\").addClass(\"modal-body\").append(modalBody))\n        .append($(\"<div></div>\").addClass(\"modal-footer\").append(modalFooter));\n\n    modal.on(\"hidden\", function () {\n        if (onclose && _.isFunction(onclose)) {\n            onclose();\n        }\n    });\n\n    if (onshow) {\n        modal.on(\"show\", onshow);\n    }\n\n    if (onshown) {\n        modal.on(\"shown\", onshown);\n    }\n\n    modal.modal(\"show\");\n    return modal;\n}\n\nfunction showConfirmationDialog(msg, onacknowledge, options) {\n    options = options || {};\n    if (_.isPlainObject(msg)) {\n        options = msg;\n    } else {\n        options.message = msg;\n        options.onproceed = onacknowledge;\n    }\n\n    var title = options.title || gettext(\"Are you sure?\");\n\n    var message = options.message || \"\";\n    var question = options.question || gettext(\"Are you sure you want to proceed?\");\n\n    var html = options.html;\n\n    var checkboxes = options.checkboxes;\n\n    var cancel = options.cancel || gettext(\"Cancel\");\n    var proceed = options.proceed || gettext(\"Proceed\");\n    var proceedClass = options.proceedClass || \"danger\";\n    var onproceed = options.onproceed || undefined;\n    var oncancel = options.oncancel || undefined;\n    var onclose = options.onclose || undefined;\n    var dialogClass = options.dialogClass || \"\";\n    var nofade = options.nofade || false;\n    var noclose = options.noclose || false;\n\n    var modalHeader;\n    if (noclose) {\n        modalHeader = $(\"<h3>\" + title + \"</h3>\");\n    } else {\n        modalHeader = $(\n            '<a href=\"javascript:void(0)\" class=\"close\" data-dismiss=\"modal\" aria-hidden=\"true\">&times;</a><h3>' +\n                title +\n                \"</h3>\"\n        );\n    }\n\n    var modalBody;\n    if (html) {\n        modalBody = $(html);\n    } else {\n        modalBody = $(\"<p>\" + message + \"</p><p>\" + question + \"</p>\");\n    }\n\n    var cancelButton = $('<a href=\"javascript:void(0)\" class=\"btn\">' + cancel + \"</a>\")\n        .attr(\"data-dismiss\", \"modal\")\n        .attr(\"aria-hidden\", \"true\");\n\n    if (!_.isArray(proceed)) {\n        proceed = [proceed];\n    }\n\n    var proceedButtons = [];\n    _.each(proceed, function (text) {\n        proceedButtons.push(\n            $('<a href=\"javascript:void(0)\" class=\"btn\">' + text + \"</a>\").addClass(\n                \"btn-\" + proceedClass\n            )\n        );\n    });\n\n    var modal = $(\"<div></div>\").addClass(\"modal hide\");\n    if (!nofade) {\n        modal.addClass(\"fade-in\");\n    }\n\n    var buttons = $(\"<div></div>\").addClass(\"modal-footer\").append(cancelButton);\n    _.each(proceedButtons, function (button) {\n        buttons.append(button);\n    });\n\n    modal\n        .addClass(dialogClass)\n        .append($(\"<div></div>\").addClass(\"modal-header\").append(modalHeader))\n        .append($(\"<div></div>\").addClass(\"modal-body\").append(modalBody))\n        .append(buttons);\n    modal.on(\"hidden\", function (event) {\n        if (onclose && _.isFunction(onclose)) {\n            onclose(event);\n        }\n    });\n\n    var modalOptions = {};\n    if (noclose) {\n        modalOptions.backdrop = \"static\";\n        modalOptions.keyboard = false;\n    }\n    modal.modal(modalOptions);\n\n    _.each(proceedButtons, function (button, idx) {\n        button.click(function (e) {\n            e.preventDefault();\n            if (onproceed && _.isFunction(onproceed)) {\n                onproceed(idx, e);\n            }\n            modal.modal(\"hide\");\n        });\n    });\n    cancelButton.click(function (e) {\n        if (oncancel && _.isFunction(oncancel)) {\n            oncancel(e);\n        }\n    });\n\n    return modal;\n}\n\nfunction showSelectionDialog(options) {\n    var title = options.title;\n    var message = options.message || undefined;\n    var selections = options.selections || [];\n\n    var maycancel = options.maycancel || false;\n    var cancel = options.cancel || undefined;\n    var onselect = options.onselect || undefined;\n    var onclose = options.onclose || undefined;\n    var dialogClass = options.dialogClass || \"\";\n    var nofade = options.nofade || false;\n\n    // header\n    var modalHeader;\n    if (maycancel) {\n        modalHeader = $(\n            '<a href=\"javascript:void(0)\" class=\"close\" data-dismiss=\"modal\" aria-hidden=\"true\">&times;</a><h3>' +\n                title +\n                \"</h3>\"\n        );\n    } else {\n        modalHeader = $(\"<h3>\" + title + \"</h3>\");\n    }\n\n    // body\n    var buttons = [];\n    var selectionBody = $(\"<div></div>\");\n    var container;\n    var additionalClass;\n\n    if (selections.length === 1) {\n        container = selectionBody;\n        additionalClass = \"btn-block\";\n    } else if (selections.length === 2) {\n        container = $(\"<div class='row-fluid'></div>\");\n        selectionBody.append(container);\n        additionalClass = \"span6\";\n    } else {\n        container = selectionBody;\n        additionalClass = \"btn-block\";\n    }\n\n    _.each(selections, function (s, i) {\n        var button = $(\n            '<button class=\"btn\" style=\"white-space: normal; word-wrap: break-word\" data-index=\"' +\n                i +\n                '\">' +\n                selections[i] +\n                \"</button>\"\n        );\n        if (additionalClass) {\n            button.addClass(additionalClass);\n        }\n        container.append(button);\n        buttons.push(button);\n\n        if (selections.length > 2 && i < selections.length - 1) {\n            container = $(\"<div class='row-fluid'></div>\");\n            selectionBody.append(container);\n        }\n    });\n\n    // divs\n    var headerDiv = $(\"<div></div>\").addClass(\"modal-header\").append(modalHeader);\n\n    var bodyDiv = $(\"<div></div>\").addClass(\"modal-body\");\n    if (message) {\n        bodyDiv.append($(\"<p>\" + message + \"</p>\"));\n    }\n    bodyDiv.append(selectionBody);\n\n    // create modal and do final wiring up\n    var modal = $(\"<div></div>\").addClass(\"modal hide\");\n    if (!nofade) {\n        modal.addClass(\"fade-in\");\n    }\n    if (!cancel) {\n        modal.data(\"backdrop\", \"static\").data(\"keyboard\", \"false\");\n    }\n\n    modal.addClass(dialogClass).append(headerDiv).append(bodyDiv);\n    modal.on(\"hidden\", function (event) {\n        if (onclose && _.isFunction(onclose)) {\n            onclose(event);\n        }\n    });\n    modal.modal(\"show\");\n\n    _.each(buttons, function (button) {\n        button.click(function (e) {\n            e.preventDefault();\n            var index = button.data(\"index\");\n            if (index < 0) {\n                return;\n            }\n\n            if (onselect && _.isFunction(onselect)) {\n                onselect(index, e);\n            }\n            modal.modal(\"hide\");\n        });\n    });\n\n    return modal;\n}\n\n/**\n * Shows a progress modal depending on a supplied promise.\n *\n * Will listen to the supplied promise, update the progress on .progress events and\n * enabling the close button and (optionally) closing the dialog on promise resolve.\n *\n * The calling code should call \"notify\" on the deferred backing the promise and supply:\n *\n *   * the text to display on the progress bar and the optional output field and\n *     a boolean value indicating whether the operation behind that update was successful or not\n *   * a short text to display on the progress bar, a long text to display on the optional output\n *     field and a boolean value indicating whether the operation behind that update was\n *     successful or not\n *\n * Non-successful progress updates will remove the barClassSuccess class from the progress bar and\n * apply the barClassFailure class and also apply the outputClassFailure to the produced line\n * in the output.\n *\n * To determine the progress, calling code should supply the prognosed maximum number of\n * progress events. An internal counter will increment on each progress event and used together\n * with the max value to calculate the percentage to display on the progress bar.\n *\n * If no max value is set, the progress bar will show a striped animation at 100% fill status\n * to visualize \"unknown but ongoing\" status.\n *\n * Available options:\n *\n *   * title: the title of the modal, defaults to \"Progress\"\n *   * message: the message of the modal, defaults to \"\"\n *   * buttonText: the text on the close button, defaults to \"Close\"\n *   * max: maximum number of expected progress events (when 100% will be reached), defaults\n *     to undefined\n *   * close: whether to close the dialog on completion, defaults to false\n *   * output: whether to display the progress texts in an output field, defaults to false\n *   * dialogClass: additional class to apply to the dialog div\n *   * barClassSuccess: additional class for the progress bar while all progress events are\n *     successful\n *   * barClassFailure: additional class for the progress bar when a progress event was\n *     unsuccessful\n *   * outputClassSuccess: additional class for successful output lines\n *   * outputClassFailure: additional class for unsuccessful output lines\n *\n * @param options modal options\n * @param promise promise to monitor\n * @returns {*|jQuery} the modal object\n */\nfunction showProgressModal(options, promise) {\n    var title = options.title || gettext(\"Progress\");\n    var message = options.message || \"\";\n    var buttonText = options.button || gettext(\"Close\");\n    var max = options.max || undefined;\n    var close = options.close || false;\n    var output = options.output || false;\n\n    var dialogClass = options.dialogClass || \"\";\n    var barClassSuccess = options.barClassSuccess || \"\";\n    var barClassFailure = options.barClassFailure || \"bar-danger\";\n    var outputClassSuccess = options.outputClassSuccess || \"\";\n    var outputClassFailure = options.outputClassFailure || \"text-error\";\n\n    var modalHeader = $(\"<h3>\" + title + \"</h3>\");\n    var paragraph = $(\"<p>\" + message + \"</p>\");\n\n    var progress = $('<div class=\"progress progress-text-centered\"></div>');\n    var progressBar = $('<div class=\"bar\"></div>').addClass(barClassSuccess);\n    var progressText = $('<span class=\"progress-text-back\"></span>');\n\n    if (max === undefined) {\n        progress.addClass(\"progress-striped active\");\n        progressBar.width(\"100%\");\n    }\n\n    progress.append(progressBar).append(progressText);\n\n    var button = $('<button class=\"btn\">' + buttonText + \"</button>\")\n        .prop(\"disabled\", true)\n        .attr(\"data-dismiss\", \"modal\")\n        .attr(\"aria-hidden\", \"true\");\n\n    var modalBody = $(\"<div></div>\")\n        .addClass(\"modal-body\")\n        .append(paragraph)\n        .append(progress);\n\n    var pre;\n    if (output) {\n        pre = $(\n            \"<pre class='pre-scrollable pre-output' style='height: 70px; font-size: 0.8em'></pre>\"\n        );\n        modalBody.append(pre);\n    }\n\n    var modal = $(\"<div></div>\")\n        .addClass(\"modal hide fade-in\")\n        .addClass(dialogClass)\n        .append($(\"<div></div>\").addClass(\"modal-header\").append(modalHeader))\n        .append(modalBody)\n        .append($(\"<div></div>\").addClass(\"modal-footer\").append(button));\n    modal.modal({keyboard: false, backdrop: \"static\", show: true});\n\n    var counter = 0;\n    promise\n        .progress(function () {\n            var short, long, success;\n            if (arguments.length === 2) {\n                short = long = arguments[0];\n                success = arguments[1];\n            } else if (arguments.length === 3) {\n                short = arguments[0];\n                long = arguments[1];\n                success = arguments[2];\n            } else {\n                throw Error(\n                    \"Invalid parameters for showProgressModal, expected either (text, success) or (short, long, success)\"\n                );\n            }\n\n            var value;\n\n            if (max === undefined || max <= 0) {\n                value = 100;\n            } else {\n                counter++;\n                value = Math.max(Math.min((counter * 100) / max, 100), 0);\n            }\n\n            // update progress bar\n            progressBar.width(String(value) + \"%\");\n            progressText.text(short);\n            if (value < 50 && progressText.hasClass(\"progress-text-front\")) {\n                progressText\n                    .removeClass(\"progress-text-front\")\n                    .addClass(\"progress-text-back\");\n            } else if (value >= 50 && progressText.hasClass(\"progress-text-back\")) {\n                progressText\n                    .removeClass(\"progress-text-back\")\n                    .addClass(\"progress-text-front\");\n            }\n\n            // if not successful, apply failure class\n            if (!success && !progressBar.hasClass(barClassFailure)) {\n                progressBar.removeClass(barClassSuccess).addClass(barClassFailure);\n            }\n\n            if (output && pre) {\n                if (success) {\n                    pre.append(\n                        $(\"<span class='\" + outputClassSuccess + \"'>\" + long + \"</span>\")\n                    );\n                } else {\n                    pre.append(\n                        $(\"<span class='\" + outputClassFailure + \"'>\" + long + \"</span>\")\n                    );\n                }\n                pre.scrollTop(pre[0].scrollHeight - pre.height());\n            }\n        })\n        .done(function () {\n            button.prop(\"disabled\", false);\n            if (close) {\n                modal.modal(\"hide\");\n            }\n        })\n        .fail(function () {\n            button.prop(\"disabled\", false);\n        });\n\n    return modal;\n}\n\nfunction showReloadOverlay() {\n    $(\"#reloadui_overlay\").show();\n}\n\nfunction wrapPromiseWithAlways(p) {\n    var deferred = $.Deferred();\n    p.always(function () {\n        deferred.resolve.apply(deferred, arguments);\n    });\n    return deferred.promise();\n}\n\nfunction commentableLinesToArray(lines) {\n    return splitTextToArray(lines, \"\\n\", true, function (item) {\n        return !_.startsWith(item, \"#\");\n    });\n}\n\nfunction splitTextToArray(text, sep, stripEmpty, filter) {\n    return _.filter(\n        _.map(text.split(sep), function (item) {\n            return item ? item.trim() : \"\";\n        }),\n        function (item) {\n            return (stripEmpty ? item : true) && (filter ? filter(item) : true);\n        }\n    );\n}\n\n/**\n * Returns true if comparing data and oldData yields changes, false otherwise.\n *\n * E.g.\n *\n *   hasDataChanged(\n *     {foo: \"bar\", fnord: {one: \"1\", two: \"2\", three: \"three\", key: \"value\"}},\n *     {foo: \"bar\", fnord: {one: \"1\", two: \"2\", three: \"3\", four: \"4\"}}\n *   )\n *\n * will return\n *\n *   true\n *\n * and\n *\n *   hasDataChanged(\n *     {foo: \"bar\", fnord: {one: \"1\", two: \"2\", three: \"3\"}},\n *     {foo: \"bar\", fnord: {one: \"1\", two: \"2\", three: \"3\"}}\n *   )\n *\n * will return\n *\n *   false\n *\n * Note that this will assume data and oldData to be structurally identical (same keys)\n * and is optimized to check for value changes, not key updates.\n */\nfunction hasDataChanged(data, oldData) {\n    // noinspection EqualityComparisonWithCoercionJS\n    if (data == oldData && data == undefined) {\n        return false;\n    }\n\n    if (_.isPlainObject(data) && _.isPlainObject(oldData)) {\n        return _.any(_.keys(data), function (key) {\n            return hasDataChanged(data[key], oldData[key]);\n        });\n    } else {\n        return !_.isEqual(data, oldData);\n    }\n}\n\n/**\n * Compare provided data and oldData plain objects and only return those\n * substructures of data that actually changed.\n *\n * E.g.\n *\n *   getOnlyChangedData(\n *     {foo: \"bar\", fnord: {one: \"1\", two: \"2\", three: \"three\"}},\n *     {foo: \"bar\", fnord: {one: \"1\", two: \"2\", three: \"3\"}}\n *   )\n *\n * will return\n *\n *   {fnord: {three: \"three\"}}\n *\n * and\n *\n *   getOnlyChangedData(\n *     {foo: \"bar\", fnord: {one: \"1\", two: \"2\", three: \"3\"}},\n *     {foo: \"bar\", fnord: {one: \"1\", two: \"2\", three: \"3\"}}\n *   )\n *\n * will return\n *\n *   {}\n *\n * Note that this will assume data and oldData to be structurally identical (same keys)\n * and is optimized to check for value changes, not key updates.\n */\nfunction getOnlyChangedData(data, oldData) {\n    // noinspection EqualityComparisonWithCoercionJS\n    if (data == undefined) {\n        return {};\n    }\n\n    // noinspection EqualityComparisonWithCoercionJS\n    if (oldData == undefined) {\n        return data;\n    }\n\n    var f = function (root, oldRoot) {\n        if (!_.isPlainObject(root)) {\n            return root;\n        }\n\n        var retval = {};\n        _.forOwn(root, function (value, key) {\n            var oldValue = undefined;\n            // noinspection EqualityComparisonWithCoercionJS\n            if (oldRoot != undefined && oldRoot.hasOwnProperty(key)) {\n                oldValue = oldRoot[key];\n            }\n            if (_.isPlainObject(value)) {\n                // noinspection EqualityComparisonWithCoercionJS\n                if (oldValue == undefined) {\n                    retval[key] = value;\n                } else if (hasDataChanged(value, oldValue)) {\n                    retval[key] = f(value, oldValue);\n                }\n            } else {\n                // noinspection EqualityComparisonWithCoercionJS\n                if (\n                    !(value == oldValue && value == undefined) &&\n                    !_.isEqual(value, oldValue)\n                ) {\n                    retval[key] = value;\n                }\n            }\n        });\n        return retval;\n    };\n\n    return f(data, oldData);\n}\n\nfunction setOnViewModels(allViewModels, key, value) {\n    setOnViewModelsIf(allViewModels, key, value, undefined);\n}\n\nfunction setOnViewModelsIf(allViewModels, key, value, condition) {\n    if (!allViewModels) return;\n    _.each(allViewModels, function (viewModel) {\n        setOnViewModelIf(viewModel, key, value, condition);\n    });\n}\n\nfunction setOnViewModel(viewModel, key, value) {\n    setOnViewModelIf(viewModel, key, value, undefined);\n}\n\nfunction setOnViewModelIf(viewModel, key, value, condition) {\n    if (condition === undefined || !_.isFunction(condition)) {\n        condition = function () {\n            return true;\n        };\n    }\n\n    try {\n        if (!condition(viewModel)) {\n            return;\n        }\n\n        viewModel[key] = value;\n    } catch (exc) {\n        if (typeof Sentry !== \"undefined\") {\n            Sentry.captureException(exc);\n        }\n        log.error(\n            \"Error while setting\",\n            key,\n            \"to\",\n            value,\n            \"on view model\",\n            viewModel.constructor.name,\n            \":\",\n            exc.stack || exc\n        );\n    }\n}\n\nfunction callViewModels(allViewModels, method, callback) {\n    callViewModelsIf(allViewModels, method, undefined, callback);\n}\n\nfunction callViewModelsIf(allViewModels, method, condition, callback) {\n    if (!allViewModels) return;\n\n    _.each(allViewModels, function (viewModel) {\n        try {\n            callViewModelIf(viewModel, method, condition, callback);\n        } catch (exc) {\n            if (typeof Sentry !== \"undefined\") {\n                Sentry.captureException(exc);\n            }\n            log.error(\n                \"Error calling\",\n                method,\n                \"on view model\",\n                viewModel.constructor.name,\n                \":\",\n                exc.stack || exc\n            );\n        }\n    });\n}\n\nfunction callViewModel(viewModel, method, callback, raiseErrors) {\n    callViewModelIf(viewModel, method, undefined, callback, raiseErrors);\n}\n\nfunction callViewModelIf(viewModel, method, condition, callback, raiseErrors) {\n    raiseErrors = raiseErrors === true || false;\n\n    if (condition === undefined || !_.isFunction(condition)) {\n        condition = function () {\n            return true;\n        };\n    }\n\n    if (!_.isFunction(viewModel[method]) || !condition(viewModel, method)) return;\n\n    var parameters = undefined;\n    if (!_.isFunction(callback)) {\n        // if callback is not a function that means we are supposed to directly\n        // call the view model method instead of providing it to the callback\n        // - let's figure out how\n\n        if (callback === undefined) {\n            // directly call view model method with no parameters\n            parameters = undefined;\n            log.trace(\"Calling method\", method, \"on view model\");\n        } else if (_.isArray(callback)) {\n            // directly call view model method with these parameters\n            parameters = callback;\n            log.trace(\n                \"Calling method\",\n                method,\n                \"on view model with specified parameters\",\n                parameters\n            );\n        } else {\n            // ok, this doesn't make sense, callback is neither undefined nor\n            // an array, we'll return without doing anything\n            return;\n        }\n\n        // we reset this here so we now further down that we want to call\n        // the method directly\n        callback = undefined;\n    } else {\n        log.trace(\n            \"Providing method\",\n            method,\n            \"on view model to specified callback\",\n            callback\n        );\n    }\n\n    try {\n        if (callback === undefined) {\n            if (parameters !== undefined) {\n                // call the method with the provided parameters\n                viewModel[method].apply(viewModel, parameters);\n            } else {\n                // call the method without parameters\n                viewModel[method]();\n            }\n        } else {\n            // provide the method to the callback\n            callback(viewModel[method], viewModel);\n        }\n    } catch (exc) {\n        if (typeof Sentry !== \"undefined\") {\n            Sentry.captureException(exc);\n        }\n        if (raiseErrors) {\n            throw exc;\n        } else {\n            log.error(\n                \"Error calling\",\n                method,\n                \"on view model\",\n                viewModel.constructor.name,\n                \":\",\n                exc.stack || exc\n            );\n        }\n    }\n}\n\nvar sizeObservable = function (observable) {\n    return ko.computed({\n        read: function () {\n            return formatSize(observable());\n        },\n        write: function (value) {\n            var result = bytesFromSize(value);\n            if (result !== undefined) {\n                observable(result);\n            }\n        }\n    });\n};\n\nvar getQueryParameterByName = function (name, url) {\n    // from http://stackoverflow.com/a/901144/2028598\n    if (!url) {\n        url = window.location.href;\n    }\n    name = name.replace(/[\\[\\]]/g, \"\\\\$&\");\n    var regex = new RegExp(\"[?&]\" + name + \"(=([^&#]*)|&|#|$)\"),\n        results = regex.exec(url);\n    if (!results) return null;\n    if (!results[2]) return \"\";\n    return decodeURIComponent(results[2].replace(/\\+/g, \" \"));\n};\n\n/**\n * Escapes unprintable ASCII characters in the provided string.\n *\n * E.g. turns a null byte in the string into \"\\x00\".\n *\n * Characters 0 to 31 excluding 9, 10 and 13 will be escaped, as will\n * 127, 128 to 159 and 255. That should leave printable characters and unicode\n * alone.\n *\n * Originally based on\n * https://gist.github.com/mathiasbynens/1243213#gistcomment-53590\n *\n * @param str The string to escape\n * @returns {string}\n */\nvar escapeUnprintableCharacters = function (str) {\n    var result = \"\";\n    var index = 0;\n    var charCode;\n\n    while (!isNaN((charCode = str.charCodeAt(index)))) {\n        if (\n            (charCode < 32 && charCode !== 9 && charCode !== 10 && charCode !== 13) ||\n            charCode === 127 ||\n            (charCode >= 128 && charCode <= 159) ||\n            charCode === 255\n        ) {\n            // special hex chars\n            result += \"\\\\x\" + (charCode > 15 ? \"\" : \"0\") + charCode.toString(16);\n        } else {\n            // anything else\n            result += str[index];\n        }\n\n        index++;\n    }\n    return result;\n};\n\nvar copyToClipboard = function (text) {\n    var temp = $(\"<textarea>\");\n    $(\"body\").append(temp);\n    temp.val(text).select();\n    document.execCommand(\"copy\");\n    temp.remove();\n};\n\nvar getExternalHostUrl = function () {\n    var loc = window.location;\n    var port = \"\";\n    if (\n        (loc.protocol === \"http:\" && loc.port !== \"80\") ||\n        (loc.protocol === \"https:\" && loc.port !== \"443\")\n    ) {\n        port = \":\" + loc.port;\n    }\n    return loc.protocol + \"//\" + loc.hostname + port;\n};\n\nvar validateWebcamUrl = function (streamUrl) {\n    if (!streamUrl) {\n        return false;\n    }\n\n    var lower = streamUrl.toLowerCase();\n    var toParse = streamUrl;\n\n    if (lower.startsWith(\"//\")) {\n        // protocol relative\n        toParse = window.location.protocol + streamUrl;\n    } else if (lower.startsWith(\"/\")) {\n        // host relative\n        toParse = getExternalHostUrl() + streamUrl;\n    } else if (\n        lower.startsWith(\"http:\") ||\n        lower.startsWith(\"https:\") ||\n        lower.startsWith(\"webrtc:\")\n    ) {\n        // absolute & http/https/webrtc\n        toParse = streamUrl;\n    } else {\n        return false;\n    }\n\n    try {\n        return new URL(toParse);\n    } catch (e) {\n        return false;\n    }\n};\n\nvar determineWebcamStreamType = function (streamUrl) {\n    if (!streamUrl) {\n        throw \"Empty streamUrl. Cannot determine stream type.\";\n    }\n\n    var parsed = validateWebcamUrl(streamUrl);\n    if (!parsed) {\n        throw \"Invalid streamUrl. Cannot determine stream type.\";\n    }\n\n    if (parsed.protocol === \"webrtc:\") {\n        return \"webrtc\";\n    }\n\n    var lastDotPosition = parsed.pathname.lastIndexOf(\".\");\n    if (lastDotPosition !== -1) {\n        var extension = parsed.pathname.substring(lastDotPosition + 1);\n        if (extension.toLowerCase() === \"m3u8\") {\n            return \"hls\";\n        }\n    }\n\n    // By default, 'mjpg' is the stream type.\n    return \"mjpg\";\n};\n\nvar saveToLocalStorage = function (key, data) {\n    if (!Modernizr.localstorage) return;\n    localStorage[key] = JSON.stringify(data);\n};\n\nvar loadFromLocalStorage = function (key, defaultValue) {\n    defaultValue = defaultValue === undefined ? {} : defaultValue;\n\n    if (!Modernizr.localstorage) return defaultValue;\n\n    var currentString = localStorage[key];\n    var current;\n    if (currentString === undefined) {\n        current = defaultValue;\n    } else {\n        try {\n            current = JSON.parse(currentString);\n        } catch (ex) {\n            current = defaultValue;\n        }\n    }\n    return current;\n};\n\nvar deepMerge = function (target, source) {\n    /**\n     * Implements an object deep merge, which contrary to _.merge doesn't try to\n     * merge arrays.\n     */\n    if (!_.isObject(target)) {\n        return target;\n    }\n\n    _.forOwn(source, function (value, key) {\n        if (\n            target.hasOwnProperty(key) &&\n            _.isPlainObject(target[key]) &&\n            _.isPlainObject(value)\n        ) {\n            target[key] = deepMerge(target[key], value);\n        } else {\n            target[key] = value;\n        }\n    });\n\n    return target;\n};\n\nvar isWebRTCAvailable = function () {\n    return (\n        typeof RTCPeerConnection == \"function\" &&\n        typeof RTCPeerConnection.prototype.addEventListener == \"function\" &&\n        typeof RTCPeerConnection.prototype.addTransceiver == \"function\" &&\n        typeof RTCPeerConnection.prototype.createOffer == \"function\" &&\n        typeof RTCPeerConnection.prototype.setLocalDescription == \"function\" &&\n        typeof RTCPeerConnection.prototype.removeEventListener == \"function\" &&\n        typeof RTCPeerConnection.prototype.addEventListener == \"function\" &&\n        typeof RTCPeerConnection.prototype.setRemoteDescription == \"function\"\n    );\n};\n\nvar negotiateWebRTC = function (streamUrl) {\n    pc.addTransceiver(\"video\", {direction: \"recvonly\"});\n    pc.addTransceiver(\"audio\", {direction: \"recvonly\"});\n    return pc\n        .createOffer()\n        .then(function (offer) {\n            return pc.setLocalDescription(offer);\n        })\n        .then(function () {\n            // Wait for ICE gathering to complete\n            return new Promise(function (resolve) {\n                if (pc.iceGatheringState === \"complete\") {\n                    resolve();\n                } else {\n                    function checkState() {\n                        if (pc.iceGatheringState === \"complete\") {\n                            pc.removeEventListener(\"icegatheringstatechange\", checkState);\n                            resolve();\n                        }\n                    }\n                    pc.addEventListener(\"icegatheringstatechange\", checkState);\n                }\n            });\n        })\n        .then(function () {\n            var offer = pc.localDescription;\n            // webrtc://host.com becomes http://host.com\n            // webrtcs://host.com becomes https://host.com\n            streamUrl = \"http\" + streamUrl.slice(\"webrtc\".length);\n            return $.ajax({\n                url: streamUrl,\n                type: \"POST\",\n                dataType: \"json\",\n                data: JSON.stringify({\n                    sdp: offer.sdp,\n                    type: offer.type\n                }),\n                contentType: \"application/json; charset=UTF-8\"\n            });\n        })\n        .then(function (response) {\n            return pc.setRemoteDescription(response);\n        })\n        .catch(function (e) {\n            console.error(e);\n        });\n};\n\nvar startWebRTC = function (videoElement, streamUrl, iceServers) {\n    var config = {\n        sdpSemantics: \"unified-plan\"\n    };\n    if (iceServers) {\n        config.iceServers = [{urls: iceServers}];\n    }\n    pc = new RTCPeerConnection(config);\n    pc.addEventListener(\"track\", function (evt) {\n        if (evt.track.kind == \"video\") {\n            videoElement.srcObject = evt.streams[0];\n        }\n    });\n\n    negotiateWebRTC(streamUrl);\n    return pc;\n};\n", "$(function () {\n    function SettingsViewModel(parameters) {\n        var self = this;\n\n        self.loginState = parameters[0];\n        self.access = parameters[1];\n        self.printerProfiles = parameters[2];\n        self.about = parameters[3];\n\n        // TODO: remove in upcoming version, this is only for backwards compatibility\n        self.users = parameters[4];\n\n        // use this promise to do certain things once the SettingsViewModel has processed\n        // its first request\n        var firstRequest = $.Deferred();\n        self.firstRequest = firstRequest.promise();\n\n        self.allViewModels = [];\n\n        self.receiving = ko.observable(false);\n        self.sending = ko.observable(false);\n        self.exchanging = ko.pureComputed(function () {\n            return self.receiving() || self.sending();\n        });\n        self.outstanding = [];\n\n        self.active = false;\n        self.sawUpdateEventWhileActive = false;\n        self.ignoreNextUpdateEvent = false;\n\n        self.settingsDialog = undefined;\n        self.settings_dialog_update_detected = undefined;\n        self.translationManagerDialog = undefined;\n        self.translationUploadElement = $(\n            \"#settings_appearance_managelanguagesdialog_upload\"\n        );\n        self.translationUploadButton = $(\n            \"#settings_appearance_managelanguagesdialog_upload_start\"\n        );\n\n        self.translationUploadFilename = ko.observable();\n        self.invalidTranslationArchive = ko.pureComputed(function () {\n            var name = self.translationUploadFilename();\n            return (\n                name !== undefined &&\n                !(\n                    _.endsWith(name.toLocaleLowerCase(), \".zip\") ||\n                    _.endsWith(name.toLocaleLowerCase(), \".tar.gz\") ||\n                    _.endsWith(name.toLocaleLowerCase(), \".tgz\") ||\n                    _.endsWith(name.toLocaleLowerCase(), \".tar\")\n                )\n            );\n        });\n        self.enableTranslationUpload = ko.pureComputed(function () {\n            var name = self.translationUploadFilename();\n            return (\n                name !== undefined &&\n                name.trim() != \"\" &&\n                !self.invalidTranslationArchive()\n            );\n        });\n\n        self.translations = new ItemListHelper(\n            \"settings.translations\",\n            {\n                locale: function (a, b) {\n                    // sorts ascending\n                    if (a[\"locale\"].toLocaleLowerCase() < b[\"locale\"].toLocaleLowerCase())\n                        return -1;\n                    if (a[\"locale\"].toLocaleLowerCase() > b[\"locale\"].toLocaleLowerCase())\n                        return 1;\n                    return 0;\n                }\n            },\n            {},\n            \"locale\",\n            [],\n            [],\n            0\n        );\n\n        self.appearance_available_colors = ko.observable([\n            {key: \"default\", name: gettext(\"default\")},\n            {key: \"red\", name: gettext(\"red\")},\n            {key: \"orange\", name: gettext(\"orange\")},\n            {key: \"yellow\", name: gettext(\"yellow\")},\n            {key: \"green\", name: gettext(\"green\")},\n            {key: \"blue\", name: gettext(\"blue\")},\n            {key: \"violet\", name: gettext(\"violet\")},\n            {key: \"black\", name: gettext(\"black\")},\n            {key: \"white\", name: gettext(\"white\")}\n        ]);\n\n        self.appearance_colorName = function (color) {\n            switch (color) {\n                case \"red\":\n                    return gettext(\"red\");\n                case \"orange\":\n                    return gettext(\"orange\");\n                case \"yellow\":\n                    return gettext(\"yellow\");\n                case \"green\":\n                    return gettext(\"green\");\n                case \"blue\":\n                    return gettext(\"blue\");\n                case \"violet\":\n                    return gettext(\"violet\");\n                case \"black\":\n                    return gettext(\"black\");\n                case \"white\":\n                    return gettext(\"white\");\n                case \"default\":\n                    return gettext(\"default\");\n                default:\n                    return color;\n            }\n        };\n\n        self.webcam_available_ratios = [\"16:9\", \"4:3\"];\n        self.webcam_available_videocodecs = [\"libx264\", \"mpeg2video\"];\n\n        var auto_locale = {\n            language: \"_default\",\n            display: gettext(\"Autodetect from browser\"),\n            english: undefined\n        };\n        self.locales = ko.observableArray(\n            [auto_locale].concat(\n                _.sortBy(_.values(AVAILABLE_LOCALES), function (n) {\n                    return n.display;\n                })\n            )\n        );\n        self.locale_languages = _.keys(AVAILABLE_LOCALES);\n\n        self.api_key = ko.observable(undefined);\n        self.api_allowCrossOrigin = ko.observable(undefined);\n\n        self.appearance_name = ko.observable(undefined);\n        self.appearance_color = ko.observable(undefined);\n        self.appearance_colorTransparent = ko.observable();\n        self.appearance_colorIcon = ko.observable();\n        self.appearance_defaultLanguage = ko.observable();\n        self.appearance_showFahrenheitAlso = ko.observable(undefined);\n        self.appearance_fuzzyTimes = ko.observable(undefined);\n        self.appearance_closeModalsWithClick = ko.observable(undefined);\n        self.appearance_showInternalFilename = ko.observable(undefined);\n\n        self.printer_defaultExtrusionLength = ko.observable(undefined);\n\n        self.webcam_webcamEnabled = ko.observable(undefined);\n        self.webcam_timelapseEnabled = ko.observable(undefined);\n        self.webcam_streamUrl = ko.observable(undefined);\n        self.webcam_streamRatio = ko.observable(undefined);\n        self.webcam_streamTimeout = ko.observable(undefined);\n        self.webcam_streamWebrtcIceServers = ko.observable(undefined);\n        self.webcam_snapshotUrl = ko.observable(undefined);\n        self.webcam_snapshotTimeout = ko.observable(undefined);\n        self.webcam_snapshotSslValidation = ko.observable(undefined);\n        self.webcam_ffmpegPath = ko.observable(undefined);\n        self.webcam_ffmpegCommandline = ko.observable(undefined);\n        self.webcam_bitrate = ko.observable(undefined);\n        self.webcam_ffmpegThreads = ko.observable(undefined);\n        self.webcam_ffmpegVideoCodec = ko.observable(undefined);\n        self.webcam_watermark = ko.observable(undefined);\n        self.webcam_flipH = ko.observable(undefined);\n        self.webcam_flipV = ko.observable(undefined);\n        self.webcam_rotate90 = ko.observable(undefined);\n        self.webcam_cacheBuster = ko.observable(undefined);\n\n        self.feature_temperatureGraph = ko.observable(undefined);\n        self.feature_sdSupport = ko.observable(undefined);\n        self.feature_keyboardControl = ko.observable(undefined);\n        self.feature_pollWatched = ko.observable(undefined);\n        self.feature_modelSizeDetection = ko.observable(undefined);\n        self.feature_rememberFileFolder = ko.observable(undefined);\n        self.feature_printStartConfirmation = ko.observable(undefined);\n        self.feature_printCancelConfirmation = ko.observable(undefined);\n        self.feature_uploadOverwriteConfirmation = ko.observable(undefined);\n        self.feature_g90InfluencesExtruder = ko.observable(undefined);\n        self.feature_autoUppercaseBlacklist = ko.observable(undefined);\n\n        self.gcodeAnalysis_runAt = ko.observable(undefined);\n\n        self.serial_port = ko.observable();\n        self.serial_baudrate = ko.observable();\n        self.serial_exclusive = ko.observable();\n        self.serial_lowLatency = ko.observable();\n        self.serial_portOptions = ko.observableArray([]);\n        self.serial_baudrateOptions = ko.observableArray([]);\n        self.serial_autoconnect = ko.observable(undefined);\n        self.serial_timeoutConnection = ko.observable(undefined);\n        self.serial_timeoutDetectionFirst = ko.observable(undefined);\n        self.serial_timeoutDetectionConsecutive = ko.observable(undefined);\n        self.serial_timeoutCommunication = ko.observable(undefined);\n        self.serial_timeoutCommunicationBusy = ko.observable(undefined);\n        self.serial_timeoutTemperature = ko.observable(undefined);\n        self.serial_timeoutTemperatureTargetSet = ko.observable(undefined);\n        self.serial_timeoutTemperatureAutoreport = ko.observable(undefined);\n        self.serial_timeoutSdStatus = ko.observable(undefined);\n        self.serial_timeoutSdStatusAutoreport = ko.observable(undefined);\n        self.serial_timeoutPosAutoreport = ko.observable(undefined);\n        self.serial_timeoutBaudrateDetectionPause = ko.observable(undefined);\n        self.serial_timeoutPositionLogWait = ko.observable(undefined);\n        self.serial_log = ko.observable(undefined);\n        self.serial_additionalPorts = ko.observable(undefined);\n        self.serial_additionalBaudrates = ko.observable(undefined);\n        self.serial_blacklistedPorts = ko.observable(undefined);\n        self.serial_blacklistedBaudrates = ko.observable(undefined);\n        self.serial_longRunningCommands = ko.observable(undefined);\n        self.serial_checksumRequiringCommands = ko.observable(undefined);\n        self.serial_blockedCommands = ko.observable(undefined);\n        self.serial_ignoredCommands = ko.observable(undefined);\n        self.serial_pausingCommands = ko.observable(undefined);\n        self.serial_sdCancelCommand = ko.observable(undefined);\n        self.serial_emergencyCommands = ko.observable(undefined);\n        self.serial_helloCommand = ko.observable(undefined);\n        self.serial_serialErrorBehaviour = ko.observable(\"cancel\");\n        self.serial_triggerOkForM29 = ko.observable(undefined);\n        self.serial_waitForStart = ko.observable(undefined);\n        self.serial_sendChecksum = ko.observable(\"print\");\n        self.serial_sendChecksumWithUnknownCommands = ko.observable(undefined);\n        self.serial_unknownCommandsNeedAck = ko.observable(undefined);\n        self.serial_sdRelativePath = ko.observable(undefined);\n        self.serial_sdLowerCase = ko.observable(undefined);\n        self.serial_sdAlwaysAvailable = ko.observable(undefined);\n        self.serial_swallowOkAfterResend = ko.observable(undefined);\n        self.serial_repetierTargetTemp = ko.observable(undefined);\n        self.serial_disableExternalHeatupDetection = ko.observable(undefined);\n        self.serial_ignoreIdenticalResends = ko.observable(undefined);\n        self.serial_firmwareDetection = ko.observable(undefined);\n        self.serial_blockWhileDwelling = ko.observable(undefined);\n        self.serial_useParityWorkaround = ko.observable(undefined);\n        self.serial_sanityCheckTools = ko.observable(undefined);\n        self.serial_supportResendsWithoutOk = ko.observable(undefined);\n        self.serial_logPositionOnPause = ko.observable(undefined);\n        self.serial_logPositionOnCancel = ko.observable(undefined);\n        self.serial_abortHeatupOnCancel = ko.observable(undefined);\n        self.serial_maxTimeoutsIdle = ko.observable(undefined);\n        self.serial_maxTimeoutsPrinting = ko.observable(undefined);\n        self.serial_maxTimeoutsLong = ko.observable(undefined);\n        self.serial_capAutoreportTemp = ko.observable(undefined);\n        self.serial_capAutoreportSdStatus = ko.observable(undefined);\n        self.serial_capAutoreportPos = ko.observable(undefined);\n        self.serial_capBusyProtocol = ko.observable(undefined);\n        self.serial_capEmergencyParser = ko.observable(undefined);\n        self.serial_capExtendedM20 = ko.observable(undefined);\n        self.serial_sendM112OnError = ko.observable(undefined);\n        self.serial_disableSdPrintingDetection = ko.observable(undefined);\n        self.serial_ackMax = ko.observable(undefined);\n        self.serial_resendRatioThreshold = ko.observable(100);\n        self.serial_resendRatioStart = ko.observable(100);\n        self.serial_ignoreEmptyPorts = ko.observable(undefined);\n        self.serial_enableShutdownActionCommand = ko.observable(undefined);\n\n        self.folder_uploads = ko.observable(undefined);\n        self.folder_timelapse = ko.observable(undefined);\n        self.folder_timelapseTmp = ko.observable(undefined);\n        self.folder_logs = ko.observable(undefined);\n        self.folder_watched = ko.observable(undefined);\n\n        self.scripts_gcode_beforePrintStarted = ko.observable(undefined);\n        self.scripts_gcode_afterPrintDone = ko.observable(undefined);\n        self.scripts_gcode_afterPrintCancelled = ko.observable(undefined);\n        self.scripts_gcode_afterPrintPaused = ko.observable(undefined);\n        self.scripts_gcode_beforePrintResumed = ko.observable(undefined);\n        self.scripts_gcode_afterPrinterConnected = ko.observable(undefined);\n        self.scripts_gcode_beforePrinterDisconnected = ko.observable(undefined);\n        self.scripts_gcode_afterToolChange = ko.observable(undefined);\n        self.scripts_gcode_beforeToolChange = ko.observable(undefined);\n\n        self.temperature_profiles = ko.observableArray(undefined);\n        self.temperature_cutoff = ko.observable(undefined);\n        self.temperature_sendAutomatically = ko.observable(undefined);\n        self.temperature_sendAutomaticallyAfter = ko.observable(undefined);\n\n        self.system_actions = ko.observableArray([]);\n\n        self.terminalFilters = ko.observableArray([]);\n\n        self.server_commands_systemShutdownCommand = ko.observable(undefined);\n        self.server_commands_systemRestartCommand = ko.observable(undefined);\n        self.server_commands_serverRestartCommand = ko.observable(undefined);\n\n        self.server_diskspace_warning = ko.observable();\n        self.server_diskspace_critical = ko.observable();\n        self.server_diskspace_warning_str = sizeObservable(self.server_diskspace_warning);\n        self.server_diskspace_critical_str = sizeObservable(\n            self.server_diskspace_critical\n        );\n\n        self.server_onlineCheck_enabled = ko.observable();\n        self.server_onlineCheck_interval = ko.observable();\n        self.server_onlineCheck_host = ko.observable();\n        self.server_onlineCheck_port = ko.observable();\n        self.server_onlineCheck_name = ko.observable();\n\n        self.server_pluginBlacklist_enabled = ko.observable();\n        self.server_pluginBlacklist_url = ko.observable();\n        self.server_pluginBlacklist_ttl = ko.observable();\n\n        self.server_allowFraming = ko.observable();\n\n        self.settings = undefined;\n        self.lastReceivedSettings = undefined;\n\n        self.webcam_ffmpegPathText = ko.observable();\n        self.webcam_ffmpegPathOk = ko.observable(false);\n        self.webcam_ffmpegPathBroken = ko.observable(false);\n        self.webcam_ffmpegPathReset = function () {\n            self.webcam_ffmpegPathText(\"\");\n            self.webcam_ffmpegPathOk(false);\n            self.webcam_ffmpegPathBroken(false);\n        };\n        self.webcam_streamType = ko.pureComputed(function () {\n            try {\n                return determineWebcamStreamType(self.webcam_streamUrl());\n            } catch (e) {\n                return \"\";\n            }\n        });\n        self.webcam_streamValid = ko.pureComputed(function () {\n            var url = self.webcam_streamUrl();\n            return !url || validateWebcamUrl(url);\n        });\n\n        self.server_onlineCheckText = ko.observable();\n        self.server_onlineCheckOk = ko.observable(false);\n        self.server_onlineCheckBroken = ko.observable(false);\n        self.server_onlineCheckReset = function () {\n            self.server_onlineCheckText(\"\");\n            self.server_onlineCheckOk(false);\n            self.server_onlineCheckBroken(false);\n        };\n        self.server_onlineCheckResolutionText = ko.observable();\n        self.server_onlineCheckResolutionOk = ko.observable(false);\n        self.server_onlineCheckResolutionBroken = ko.observable(false);\n        self.server_onlineCheckResolutionReset = function () {\n            self.server_onlineCheckResolutionText(\"\");\n            self.server_onlineCheckResolutionOk(false);\n            self.server_onlineCheckResolutionBroken(false);\n        };\n\n        var folderTypes = [\"uploads\", \"timelapse\", \"timelapseTmp\", \"logs\", \"watched\"];\n\n        var checkForDuplicateFolders = function () {\n            _.each(folderTypes, function (folderType) {\n                var path = self[\"folder_\" + folderType]();\n                var duplicate = false;\n                _.each(folderTypes, function (otherFolderType) {\n                    if (folderType !== otherFolderType) {\n                        duplicate =\n                            duplicate || path === self[\"folder_\" + otherFolderType]();\n                    }\n                });\n                self.testFolderConfigDuplicate[folderType](duplicate);\n            });\n        };\n\n        self.testFolderConfigText = {};\n        self.testFolderConfigOk = {};\n        self.testFolderConfigBroken = {};\n        self.testFolderConfigDuplicate = {};\n        self.testFolderConfigError = {};\n        self.testFolderConfigSuccess = {};\n        _.each(folderTypes, function (folderType) {\n            self.testFolderConfigText[folderType] = ko.observable(\"\");\n            self.testFolderConfigOk[folderType] = ko.observable(false);\n            self.testFolderConfigBroken[folderType] = ko.observable(false);\n            self.testFolderConfigDuplicate[folderType] = ko.observable(false);\n            self.testFolderConfigError[folderType] = ko.pureComputed(function () {\n                return (\n                    self.testFolderConfigBroken[folderType]() ||\n                    self.testFolderConfigDuplicate[folderType]()\n                );\n            });\n            self.testFolderConfigSuccess[folderType] = ko.pureComputed(function () {\n                return (\n                    self.testFolderConfigOk[folderType]() &&\n                    !self.testFolderConfigDuplicate[folderType]()\n                );\n            });\n            self[\"folder_\" + folderType].subscribe(checkForDuplicateFolders);\n        });\n        self.testFolderConfigReset = function () {\n            _.each(folderTypes, function (folderType) {\n                self.testFolderConfigText[folderType](\"\");\n                self.testFolderConfigOk[folderType](false);\n                self.testFolderConfigBroken[folderType](false);\n            });\n        };\n        self.testFoldersDuplicate = ko.pureComputed(function () {\n            var foundDupe = false;\n            _.each(folderTypes, function (folderType) {\n                foundDupe = foundDupe || self.testFolderConfigDuplicate[folderType]();\n            });\n            return foundDupe;\n        });\n\n        self.observableCopies = {\n            feature_waitForStart: \"serial_waitForStart\",\n            feature_sendChecksum: \"serial_sendChecksum\",\n            feature_sdRelativePath: \"serial_sdRelativePath\",\n            feature_sdAlwaysAvailable: \"serial_sdAlwaysAvailable\",\n            feature_swallowOkAfterResend: \"serial_swallowOkAfterResend\",\n            feature_repetierTargetTemp: \"serial_repetierTargetTemp\",\n            feature_disableExternalHeatupDetection:\n                \"serial_disableExternalHeatupDetection\",\n            feature_ignoreIdenticalResends: \"serial_ignoreIdenticalResends\",\n            feature_firmwareDetection: \"serial_firmwareDetection\",\n            feature_blockWhileDwelling: \"serial_blockWhileDwelling\",\n            serial_: \"feature_\"\n        };\n        _.each(self.observableCopies, function (value, key) {\n            if (self.hasOwnProperty(value)) {\n                self[key] = self[value];\n            }\n        });\n\n        self.addTemperatureProfile = function () {\n            self.temperature_profiles.push({\n                name: \"New\",\n                extruder: 0,\n                bed: 0,\n                chamber: 0\n            });\n        };\n\n        self.removeTemperatureProfile = function (profile) {\n            self.temperature_profiles.remove(profile);\n        };\n\n        self.addTerminalFilter = function () {\n            self.terminalFilters.push({\n                name: \"New\",\n                regex: \"(Send:\\\\s+(N\\\\d+\\\\s+)?M105)|(Recv:\\\\s+(ok\\\\s+([PBN]\\\\d+\\\\s+)*)?.*([BCLPR]|T\\\\d*):-?\\\\d+)\"\n            });\n        };\n\n        self.removeTerminalFilter = function (filter) {\n            self.terminalFilters.remove(filter);\n        };\n\n        self.testWebcamStreamUrlBusy = ko.observable(false);\n        self.testWebcamStreamUrl = function () {\n            if (!self.webcam_streamUrl()) {\n                return;\n            }\n\n            if (self.testWebcamStreamUrlBusy()) {\n                return;\n            }\n\n            var text = gettext(\n                \"If you see your webcam stream below, the entered stream URL is ok.\"\n            );\n\n            var streamType;\n            try {\n                streamType = self.webcam_streamType();\n            } catch (e) {\n                streamType = \"\";\n            }\n\n            var webcam_element;\n            var webrtc_peer_connection;\n            if (streamType === \"mjpg\") {\n                webcam_element = $('<img src=\"' + self.webcam_streamUrl() + '\">');\n            } else if (streamType === \"hls\") {\n                webcam_element = $(\n                    '<video id=\"webcam_hls\" muted autoplay style=\"width: 100%\"/>'\n                );\n                video_element = webcam_element[0];\n                if (video_element.canPlayType(\"application/vnd.apple.mpegurl\")) {\n                    video_element.src = self.webcam_streamUrl();\n                } else if (Hls.isSupported()) {\n                    var hls = new Hls();\n                    hls.loadSource(self.webcam_streamUrl());\n                    hls.attachMedia(video_element);\n                }\n            } else if (isWebRTCAvailable() && streamType === \"webrtc\") {\n                webcam_element = $(\n                    '<video id=\"webcam_webrtc\" muted autoplay playsinline controls style=\"width: 100%\"/>'\n                );\n                video_element = webcam_element[0];\n\n                webrtc_peer_connection = startWebRTC(\n                    video_element,\n                    self.webcam_streamUrl(),\n                    self.webcam_streamWebrtcIceServers()\n                );\n            } else {\n                throw \"Unknown stream type \" + streamType;\n            }\n\n            var message = $(\"<div id='webcamTestContainer'></div>\")\n                .append($(\"<p></p>\"))\n                .append(text)\n                .append(webcam_element);\n\n            self.testWebcamStreamUrlBusy(true);\n            showMessageDialog({\n                title: gettext(\"Stream test\"),\n                message: message,\n                onclose: function () {\n                    self.testWebcamStreamUrlBusy(false);\n                    if (webrtc_peer_connection != null) {\n                        webrtc_peer_connection.close();\n                        webrtc_peer_connection = null;\n                    }\n                }\n            });\n        };\n\n        self.testWebcamSnapshotUrlBusy = ko.observable(false);\n        self.testWebcamSnapshotUrl = function (viewModel, event) {\n            if (!self.webcam_snapshotUrl()) {\n                return;\n            }\n\n            if (self.testWebcamSnapshotUrlBusy()) {\n                return;\n            }\n\n            var errorText = gettext(\n                \"Could not retrieve snapshot URL, please double check the URL\"\n            );\n            var errorTitle = gettext(\"Snapshot test failed\");\n\n            self.testWebcamSnapshotUrlBusy(true);\n            OctoPrint.util\n                .testUrl(self.webcam_snapshotUrl(), {\n                    method: \"GET\",\n                    response: \"bytes\",\n                    timeout: self.webcam_snapshotTimeout(),\n                    validSsl: self.webcam_snapshotSslValidation(),\n                    content_type_whitelist: [\"image/*\"],\n                    content_type_guess: true\n                })\n                .done(function (response) {\n                    if (!response.result) {\n                        if (\n                            response.status &&\n                            response.response &&\n                            response.response.content_type\n                        ) {\n                            // we could contact the server, but something else was wrong, probably the mime type\n                            errorText = gettext(\n                                \"Could retrieve the snapshot URL, but it didn't look like an \" +\n                                    \"image. Got this as a content type header: <code>%(content_type)s</code>. Please \" +\n                                    \"double check that the URL is returning static images, not multipart data \" +\n                                    \"or videos.\"\n                            );\n                            errorText = _.sprintf(errorText, {\n                                content_type: _.escape(response.response.content_type)\n                            });\n                        }\n\n                        showMessageDialog({\n                            title: errorTitle,\n                            message: errorText,\n                            onclose: function () {\n                                self.testWebcamSnapshotUrlBusy(false);\n                            }\n                        });\n                        return;\n                    }\n\n                    var content = response.response.content;\n                    var contentType = response.response.assumed_content_type;\n\n                    var mimeType = \"image/jpeg\";\n                    if (contentType) {\n                        mimeType = contentType.split(\";\")[0];\n                    }\n\n                    var text = gettext(\n                        \"If you see your webcam snapshot picture below, the entered snapshot URL is ok.\"\n                    );\n                    showMessageDialog({\n                        title: gettext(\"Snapshot test\"),\n                        message: $(\n                            \"<p>\" +\n                                text +\n                                '</p><p><img src=\"data:' +\n                                mimeType +\n                                \";base64,\" +\n                                content +\n                                '\" style=\"border: 1px solid black\" /></p>'\n                        ),\n                        onclose: function () {\n                            self.testWebcamSnapshotUrlBusy(false);\n                        }\n                    });\n                })\n                .fail(function () {\n                    showMessageDialog({\n                        title: errorTitle,\n                        message: errorText,\n                        onclose: function () {\n                            self.testWebcamSnapshotUrlBusy(false);\n                        }\n                    });\n                });\n        };\n\n        self.testWebcamFfmpegPathBusy = ko.observable(false);\n        self.testWebcamFfmpegPath = function () {\n            if (!self.webcam_ffmpegPath()) {\n                return;\n            }\n\n            if (self.testWebcamFfmpegPathBusy()) {\n                return;\n            }\n\n            self.testWebcamFfmpegPathBusy(true);\n            OctoPrint.util\n                .testExecutable(self.webcam_ffmpegPath())\n                .done(function (response) {\n                    if (!response.result) {\n                        if (!response.exists) {\n                            self.webcam_ffmpegPathText(gettext(\"The path doesn't exist\"));\n                        } else if (!response.typeok) {\n                            self.webcam_ffmpegPathText(gettext(\"The path is not a file\"));\n                        } else if (!response.access) {\n                            self.webcam_ffmpegPathText(\n                                gettext(\"The path is not an executable\")\n                            );\n                        }\n                    } else {\n                        self.webcam_ffmpegPathText(gettext(\"The path is valid\"));\n                    }\n                    self.webcam_ffmpegPathOk(response.result);\n                    self.webcam_ffmpegPathBroken(!response.result);\n                })\n                .always(function () {\n                    self.testWebcamFfmpegPathBusy(false);\n                });\n        };\n\n        self.testOnlineConnectivityConfigBusy = ko.observable(false);\n        self.testOnlineConnectivityConfig = function () {\n            if (!self.server_onlineCheck_host()) return;\n            if (!self.server_onlineCheck_port()) return;\n            if (self.testOnlineConnectivityConfigBusy()) return;\n\n            self.testOnlineConnectivityConfigBusy(true);\n            OctoPrint.util\n                .testServer(\n                    self.server_onlineCheck_host(),\n                    self.server_onlineCheck_port()\n                )\n                .done(function (response) {\n                    if (!response.result) {\n                        self.server_onlineCheckText(\n                            gettext(\"The server is not reachable\")\n                        );\n                    } else {\n                        self.server_onlineCheckText(gettext(\"The server is reachable\"));\n                    }\n                    self.server_onlineCheckOk(response.result);\n                    self.server_onlineCheckBroken(!response.result);\n                })\n                .always(function () {\n                    self.testOnlineConnectivityConfigBusy(false);\n                });\n        };\n\n        self.testOnlineConnectivityResolutionConfigBusy = ko.observable(false);\n        self.testOnlineConnectivityResolutionConfig = function () {\n            if (!self.server_onlineCheck_name()) return;\n            if (self.testOnlineConnectivityResolutionConfigBusy()) return;\n\n            self.testOnlineConnectivityResolutionConfigBusy(true);\n            OctoPrint.util\n                .testResolution(self.server_onlineCheck_name())\n                .done(function (response) {\n                    if (!response.result) {\n                        self.server_onlineCheckResolutionText(\n                            gettext(\"Name cannot be resolved\")\n                        );\n                    } else {\n                        self.server_onlineCheckResolutionText(\n                            gettext(\"Name can be resolved\")\n                        );\n                    }\n                    self.server_onlineCheckResolutionOk(response.result);\n                    self.server_onlineCheckResolutionBroken(!response.result);\n                })\n                .always(function () {\n                    self.testOnlineConnectivityResolutionConfigBusy(false);\n                });\n        };\n\n        self.testFolderConfigBusy = ko.observable(false);\n        self.testFolderConfig = function (folder) {\n            var observable = \"folder_\" + folder;\n            if (!self.hasOwnProperty(observable)) return;\n\n            if (self.testFolderConfigBusy()) return;\n            self.testFolderConfigBusy(true);\n\n            var opts = {\n                check_type: \"dir\",\n                check_access: \"w\",\n                allow_create_dir: true,\n                check_writable_dir: true\n            };\n            var path = self[observable]();\n            OctoPrint.util\n                .testPath(path, opts)\n                .done(function (response) {\n                    if (!response.result) {\n                        if (response.broken_symlink) {\n                            self.testFolderConfigText[folder](\n                                gettext(\"The path is a broken symlink.\")\n                            );\n                        } else if (!response.exists) {\n                            self.testFolderConfigText[folder](\n                                gettext(\"The path does not exist and cannot be created.\")\n                            );\n                        } else if (!response.typeok) {\n                            self.testFolderConfigText[folder](\n                                gettext(\"The path is not a folder.\")\n                            );\n                        } else if (!response.access) {\n                            self.testFolderConfigText[folder](\n                                gettext(\"The path is not writable.\")\n                            );\n                        }\n                    } else {\n                        self.testFolderConfigText[folder](gettext(\"The path is valid\"));\n                    }\n                    self.testFolderConfigOk[folder](response.result);\n                    self.testFolderConfigBroken[folder](!response.result);\n                })\n                .always(function () {\n                    self.testFolderConfigBusy(false);\n                });\n        };\n\n        self.onSettingsHidden = function () {\n            self.webcam_ffmpegPathReset();\n            self.server_onlineCheckReset();\n            self.server_onlineCheckResolutionReset();\n            self.testFolderConfigReset();\n        };\n\n        self.isDialogActive = function () {\n            return self.settingsDialog.is(\":visible\");\n        };\n\n        self.onStartup = function () {\n            self.settingsDialog = $(\"#settings_dialog\");\n            self.settingsUpdatedDialog = $(\"#settings_dialog_update_detected\");\n            self.translationManagerDialog = $(\n                \"#settings_appearance_managelanguagesdialog\"\n            );\n            self.translationUploadElement = $(\n                \"#settings_appearance_managelanguagesdialog_upload\"\n            );\n            self.translationUploadButton = $(\n                \"#settings_appearance_managelanguagesdialog_upload_start\"\n            );\n\n            self.translationUploadElement.fileupload({\n                dataType: \"json\",\n                maxNumberOfFiles: 1,\n                autoUpload: false,\n                headers: OctoPrint.getRequestHeaders(),\n                add: function (e, data) {\n                    if (data.files.length == 0) {\n                        return false;\n                    }\n\n                    self.translationUploadFilename(data.files[0].name);\n\n                    self.translationUploadButton.unbind(\"click\");\n                    self.translationUploadButton.bind(\"click\", function () {\n                        data.submit();\n                        return false;\n                    });\n                },\n                done: function (e, data) {\n                    self.translationUploadButton.unbind(\"click\");\n                    self.translationUploadFilename(undefined);\n                    self.fromTranslationResponse(data.result);\n                },\n                fail: function (e, data) {\n                    self.translationUploadButton.unbind(\"click\");\n                    self.translationUploadFilename(undefined);\n                }\n            });\n        };\n\n        self.onAllBound = function (allViewModels) {\n            self.allViewModels = allViewModels;\n\n            self.settingsDialog.on(\"show\", function (event) {\n                OctoPrint.coreui.settingsOpen = true;\n                if (event.target.id == \"settings_dialog\") {\n                    self.requestTranslationData();\n                    callViewModels(allViewModels, \"onSettingsShown\");\n                }\n            });\n            self.settingsDialog.on(\"hidden\", function (event) {\n                OctoPrint.coreui.settingsOpen = false;\n                if (event.target.id == \"settings_dialog\") {\n                    callViewModels(allViewModels, \"onSettingsHidden\");\n                }\n            });\n            self.settingsDialog.on(\"beforeSave\", function () {\n                callViewModels(allViewModels, \"onSettingsBeforeSave\");\n            });\n\n            $(\".reload_all\", self.settingsUpdatedDialog).click(function (e) {\n                e.preventDefault();\n                self.settingsUpdatedDialog.modal(\"hide\");\n                self.requestData();\n                return false;\n            });\n            $(\".reload_nonconflicts\", self.settingsUpdatedDialog).click(function (e) {\n                e.preventDefault();\n                self.settingsUpdatedDialog.modal(\"hide\");\n                self.requestData(true);\n                return false;\n            });\n\n            // reset scroll position on tab change\n            $('ul.nav-list a[data-toggle=\"tab\"]', self.settingsDialog).on(\n                \"show\",\n                function () {\n                    self._resetScrollPosition();\n                }\n            );\n        };\n\n        self.show = function (tab) {\n            // select first or specified tab\n            self.selectTab(tab);\n\n            // reset scroll position\n            self._resetScrollPosition();\n\n            // show settings, ensure centered position\n            self.settingsDialog\n                .modal({\n                    minHeight: function () {\n                        return Math.max($.fn.modal.defaults.maxHeight() - 80, 250);\n                    }\n                })\n                .css({\n                    \"margin-left\": function () {\n                        return -($(this).width() / 2);\n                    }\n                });\n\n            return false;\n        };\n\n        self.hide = function () {\n            self.settingsDialog.modal(\"hide\");\n        };\n\n        self.generateApiKey = function () {\n            if (!CONFIG_ACCESS_CONTROL) return;\n\n            showConfirmationDialog(\n                gettext(\n                    \"This will generate a new API Key. The old API Key will cease to function immediately.\"\n                ),\n                function () {\n                    OctoPrint.settings.generateApiKey().done(function (response) {\n                        self.api_key(response.apikey);\n                        self.requestData();\n                    });\n                }\n            );\n        };\n\n        self.copyApiKey = function () {\n            copyToClipboard(self.api_key());\n        };\n\n        self.showTranslationManager = function () {\n            self.translationManagerDialog.modal();\n            return false;\n        };\n\n        self.requestData = function (local) {\n            // handle old parameter format\n            var callback = undefined;\n            if (arguments.length === 2 || _.isFunction(local)) {\n                var exc = new Error();\n                log.warn(\n                    \"The callback parameter of SettingsViewModel.requestData is deprecated, the method now returns a promise, please use that instead. Stacktrace:\",\n                    exc.stack || exc.stacktrace || \"<n/a>\"\n                );\n\n                if (arguments.length === 2) {\n                    callback = arguments[0];\n                    local = arguments[1];\n                } else {\n                    callback = local;\n                    local = false;\n                }\n            }\n\n            // handler for any explicitly provided callbacks\n            var callbackHandler = function () {\n                if (!callback) return;\n                try {\n                    callback();\n                } catch (exc) {\n                    log.error(\n                        \"Error calling settings callback\",\n                        callback,\n                        \":\",\n                        exc.stack || exc.stacktrace || exc\n                    );\n                }\n            };\n\n            // if a request is already active, create a new deferred and return\n            // its promise, it will be resolved in the response handler of the\n            // current request\n            if (self.receiving()) {\n                var deferred = $.Deferred();\n                self.outstanding.push(deferred);\n\n                if (callback) {\n                    // if we have a callback, we need to make sure it will\n                    // get called when the deferred is resolved\n                    deferred.done(callbackHandler);\n                }\n\n                return deferred.promise();\n            }\n\n            // perform the request\n            self.receiving(true);\n            return OctoPrint.settings\n                .get()\n                .always(function () {\n                    self.receiving(false);\n                })\n                .done(function (response) {\n                    self.fromResponse(response, local);\n\n                    if (callback) {\n                        var deferred = $.Deferred();\n                        deferred.done(callbackHandler);\n                        self.outstanding.push(deferred);\n                    }\n\n                    // resolve all promises\n                    var args = arguments;\n                    _.each(self.outstanding, function (deferred) {\n                        deferred.resolve(args);\n                    });\n                    self.outstanding = [];\n                })\n                .fail(function () {\n                    // reject all promises\n                    var args = arguments;\n                    _.each(self.outstanding, function (deferred) {\n                        deferred.reject(args);\n                    });\n                    self.outstanding = [];\n                });\n        };\n\n        self.requestTranslationData = function () {\n            return OctoPrint.languages.list().done(self.fromTranslationResponse);\n        };\n\n        self.fromTranslationResponse = function (response) {\n            var translationsByLocale = {};\n            _.each(response.language_packs, function (item, key) {\n                _.each(item.languages, function (pack) {\n                    var locale = pack.locale;\n                    if (!_.has(translationsByLocale, locale)) {\n                        translationsByLocale[locale] = {\n                            locale: locale,\n                            display: pack.locale_display,\n                            english: pack.locale_english,\n                            packs: []\n                        };\n                    }\n\n                    translationsByLocale[locale][\"packs\"].push({\n                        identifier: key,\n                        display: item.display,\n                        pack: pack\n                    });\n                });\n            });\n\n            var translations = [];\n            _.each(translationsByLocale, function (item) {\n                item[\"packs\"].sort(function (a, b) {\n                    if (a.identifier == \"_core\") return -1;\n                    if (b.identifier == \"_core\") return 1;\n\n                    if (a.display < b.display) return -1;\n                    if (a.display > b.display) return 1;\n                    return 0;\n                });\n                translations.push(item);\n            });\n\n            self.translations.updateItems(translations);\n        };\n\n        self.languagePackDisplay = function (item) {\n            return (\n                item.display +\n                (item.english != undefined ? \" (\" + item.english + \")\" : \"\")\n            );\n        };\n\n        self.languagePacksAvailable = ko.pureComputed(function () {\n            return self.translations.allSize() > 0;\n        });\n\n        self.deleteLanguagePack = function (locale, pack) {\n            OctoPrint.languages.delete(locale, pack).done(self.fromTranslationResponse);\n        };\n\n        /**\n         * Fetches the settings as currently stored in this client instance.\n         */\n        self.getLocalData = function () {\n            var data = {};\n            if (self.settings != undefined) {\n                data = ko.mapping.toJS(self.settings);\n            }\n\n            // some special read functions for various observables\n            var specialMappings = {\n                feature: {\n                    autoUppercaseBlacklist: function () {\n                        return splitTextToArray(\n                            self.feature_autoUppercaseBlacklist(),\n                            \",\",\n                            true\n                        );\n                    }\n                },\n                serial: {\n                    additionalPorts: function () {\n                        return commentableLinesToArray(self.serial_additionalPorts());\n                    },\n                    additionalBaudrates: function () {\n                        return _.map(\n                            splitTextToArray(\n                                self.serial_additionalBaudrates(),\n                                \",\",\n                                true,\n                                function (item) {\n                                    return !isNaN(parseInt(item));\n                                }\n                            ),\n                            function (item) {\n                                return parseInt(item);\n                            }\n                        );\n                    },\n                    blacklistedPorts: function () {\n                        return commentableLinesToArray(self.serial_blacklistedPorts());\n                    },\n                    blacklistedBaudrates: function () {\n                        return _.map(\n                            splitTextToArray(\n                                self.serial_blacklistedBaudrates(),\n                                \",\",\n                                true,\n                                function (item) {\n                                    return !isNaN(parseInt(item));\n                                }\n                            ),\n                            function (item) {\n                                return parseInt(item);\n                            }\n                        );\n                    },\n                    longRunningCommands: function () {\n                        return splitTextToArray(\n                            self.serial_longRunningCommands(),\n                            \",\",\n                            true\n                        );\n                    },\n                    checksumRequiringCommands: function () {\n                        return splitTextToArray(\n                            self.serial_checksumRequiringCommands(),\n                            \",\",\n                            true\n                        );\n                    },\n                    blockedCommands: function () {\n                        return splitTextToArray(self.serial_blockedCommands(), \",\", true);\n                    },\n                    ignoredCommands: function () {\n                        return splitTextToArray(self.serial_ignoredCommands(), \",\", true);\n                    },\n                    pausingCommands: function () {\n                        return splitTextToArray(self.serial_pausingCommands(), \",\", true);\n                    },\n                    emergencyCommands: function () {\n                        return splitTextToArray(\n                            self.serial_emergencyCommands(),\n                            \",\",\n                            true\n                        );\n                    },\n                    externalHeatupDetection: function () {\n                        return !self.serial_disableExternalHeatupDetection();\n                    },\n                    alwaysSendChecksum: function () {\n                        return self.serial_sendChecksum() === \"always\";\n                    },\n                    neverSendChecksum: function () {\n                        return self.serial_sendChecksum() === \"never\";\n                    },\n                    ignoreErrorsFromFirmware: function () {\n                        return self.serial_serialErrorBehaviour() === \"ignore\";\n                    },\n                    disconnectOnErrors: function () {\n                        return self.serial_serialErrorBehaviour() === \"disconnect\";\n                    }\n                },\n                scripts: {\n                    gcode: function () {\n                        // we have a special handler function for the gcode scripts since the\n                        // server will always send us those that have been set already, so we\n                        // can't depend on all keys that we support to be present in the\n                        // original request we iterate through in mapFromObservables to\n                        // generate our response - hence we use our observables instead\n                        //\n                        // Note: If we ever introduce sub categories in the gcode scripts\n                        // here (more _ after the prefix), we'll need to adjust this code\n                        // to be able to cope with that, right now it only strips the prefix\n                        // and uses the rest as key in the result, no recursive translation\n                        // is done!\n                        var result = {};\n                        var prefix = \"scripts_gcode_\";\n                        var observables = _.filter(_.keys(self), function (key) {\n                            return _.startsWith(key, prefix);\n                        });\n                        _.each(observables, function (observable) {\n                            var script = observable.substring(prefix.length);\n                            result[script] = self[observable]();\n                        });\n                        return result;\n                    }\n                },\n                temperature: {\n                    profiles: function () {\n                        var result = [];\n                        _.each(self.temperature_profiles(), function (profile) {\n                            try {\n                                result.push({\n                                    name: profile.name,\n                                    extruder: Math.floor(\n                                        _.isNumber(profile.extruder)\n                                            ? profile.extruder\n                                            : parseInt(profile.extruder)\n                                    ),\n                                    bed: Math.floor(\n                                        _.isNumber(profile.bed)\n                                            ? profile.bed\n                                            : parseInt(profile.bed)\n                                    ),\n                                    chamber: Math.floor(\n                                        _.isNumber(profile.chamber)\n                                            ? profile.chamber\n                                            : _.isNumber(parseInt(profile.chamber))\n                                            ? parseInt(profile.chamber)\n                                            : 0\n                                    )\n                                });\n                            } catch (ex) {\n                                // ignore\n                            }\n                        });\n                        return result;\n                    }\n                },\n                webcam: {\n                    streamWebrtcIceServers: function () {\n                        return splitTextToArray(\n                            self.webcam_streamWebrtcIceServers(),\n                            \",\",\n                            true\n                        );\n                    }\n                }\n            };\n\n            var mapFromObservables = function (data, mapping, keyPrefix) {\n                var flag = false;\n                var result = {};\n\n                // process all key-value-pairs here\n                _.forOwn(data, function (value, key) {\n                    var observable = key;\n                    if (keyPrefix !== undefined) {\n                        observable = keyPrefix + \"_\" + observable;\n                    }\n\n                    if (self.observableCopies.hasOwnProperty(observable)) {\n                        // only a copy, skip\n                        return;\n                    }\n\n                    if (mapping && mapping[key] && _.isFunction(mapping[key])) {\n                        result[key] = mapping[key]();\n                        flag = true;\n                    } else if (_.isPlainObject(value)) {\n                        // value is another object, we'll dive deeper\n                        var subresult = mapFromObservables(\n                            value,\n                            mapping && mapping[key] ? mapping[key] : undefined,\n                            observable\n                        );\n                        if (subresult !== undefined) {\n                            // we only set something on our result if we got something back\n                            result[key] = subresult;\n                            flag = true;\n                        }\n                    } else if (self.hasOwnProperty(observable)) {\n                        result[key] = self[observable]();\n                        flag = true;\n                    }\n                });\n\n                // if we set something on our result (flag is true), we return result, else we return undefined\n                return flag ? result : undefined;\n            };\n\n            // map local observables based on our existing data\n            var dataFromObservables = mapFromObservables(data, specialMappings);\n\n            data = deepMerge(data, dataFromObservables);\n            return data;\n        };\n\n        self.fromResponse = function (response, local) {\n            // server side changes to set\n            var serverChangedData;\n\n            // client side changes to keep\n            var clientChangedData;\n\n            if (local) {\n                // local is true, so we'll keep all local changes and only update what's been updated server side\n                serverChangedData = getOnlyChangedData(\n                    response,\n                    self.lastReceivedSettings\n                );\n                clientChangedData = getOnlyChangedData(\n                    self.getLocalData(),\n                    self.lastReceivedSettings\n                );\n            } else {\n                // local is false or unset, so we'll forcefully update with the settings from the server\n                serverChangedData = response;\n                clientChangedData = undefined;\n            }\n\n            // last received settings reset to response\n            self.lastReceivedSettings = response;\n\n            if (self.settings === undefined) {\n                self.settings = ko.mapping.fromJS(serverChangedData);\n            } else {\n                ko.mapping.fromJS(serverChangedData, self.settings);\n            }\n\n            // some special apply functions for various observables\n            var specialMappings = {\n                appearance: {\n                    defaultLanguage: function (value) {\n                        self.appearance_defaultLanguage(\"_default\");\n                        if (_.includes(self.locale_languages, value)) {\n                            self.appearance_defaultLanguage(value);\n                        }\n                    }\n                },\n                feature: {\n                    autoUppercaseBlacklist: function (value) {\n                        self.feature_autoUppercaseBlacklist(value.join(\", \"));\n                    }\n                },\n                serial: {\n                    additionalPorts: function (value) {\n                        self.serial_additionalPorts(value.join(\"\\n\"));\n                    },\n                    additionalBaudrates: function (value) {\n                        self.serial_additionalBaudrates(value.join(\", \"));\n                    },\n                    blacklistedPorts: function (value) {\n                        self.serial_blacklistedPorts(value.join(\"\\n\"));\n                    },\n                    blacklistedBaudrates: function (value) {\n                        self.serial_blacklistedBaudrates(value.join(\", \"));\n                    },\n                    longRunningCommands: function (value) {\n                        self.serial_longRunningCommands(value.join(\", \"));\n                    },\n                    checksumRequiringCommands: function (value) {\n                        self.serial_checksumRequiringCommands(value.join(\", \"));\n                    },\n                    blockedCommands: function (value) {\n                        self.serial_blockedCommands(value.join(\", \"));\n                    },\n                    ignoredCommands: function (value) {\n                        self.serial_ignoredCommands(value.join(\", \"));\n                    },\n                    pausingCommands: function (value) {\n                        self.serial_pausingCommands(value.join(\", \"));\n                    },\n                    emergencyCommands: function (value) {\n                        self.serial_emergencyCommands(value.join(\", \"));\n                    },\n                    externalHeatupDetection: function (value) {\n                        self.serial_disableExternalHeatupDetection(!value);\n                    },\n                    alwaysSendChecksum: function (value) {\n                        if (value) {\n                            self.serial_sendChecksum(\"always\");\n                        }\n                    },\n                    neverSendChecksum: function (value) {\n                        if (value) {\n                            self.serial_sendChecksum(\"never\");\n                        }\n                    },\n                    ignoreErrorsFromFirmware: function (value) {\n                        if (value) {\n                            self.serial_serialErrorBehaviour(\"ignore\");\n                        }\n                    },\n                    disconnectOnErrors: function (value) {\n                        if (value) {\n                            self.serial_serialErrorBehaviour(\"disconnect\");\n                        }\n                    }\n                },\n                terminalFilters: function (value) {\n                    self.terminalFilters($.extend(true, [], value));\n                },\n                temperature: {\n                    profiles: function (value) {\n                        self.temperature_profiles($.extend(true, [], value));\n                    }\n                },\n                webcam: {\n                    streamWebrtcIceServers: function (value) {\n                        self.webcam_streamWebrtcIceServers(value.join(\", \"));\n                    }\n                }\n            };\n\n            var mapToObservables = function (data, mapping, local, keyPrefix) {\n                if (!_.isPlainObject(data)) {\n                    return;\n                }\n\n                // process all key-value-pairs here\n                _.forOwn(data, function (value, key) {\n                    var observable = key;\n                    if (keyPrefix != undefined) {\n                        observable = keyPrefix + \"_\" + observable;\n                    }\n\n                    if (self.observableCopies.hasOwnProperty(observable)) {\n                        // only a copy, skip\n                        return;\n                    }\n\n                    var haveLocalVersion = local && local.hasOwnProperty(key);\n\n                    if (\n                        mapping &&\n                        mapping[key] &&\n                        _.isFunction(mapping[key]) &&\n                        !haveLocalVersion\n                    ) {\n                        // if we have a custom apply function for this, we'll use it\n                        mapping[key](value);\n                    } else if (_.isPlainObject(value)) {\n                        // value is another object, we'll dive deeper\n                        mapToObservables(\n                            value,\n                            mapping && mapping[key] ? mapping[key] : undefined,\n                            local && local[key] ? local[key] : undefined,\n                            observable\n                        );\n                    } else if (!haveLocalVersion && self.hasOwnProperty(observable)) {\n                        // if we have a matching observable, we'll use that\n                        self[observable](value);\n                    }\n                });\n            };\n\n            mapToObservables(serverChangedData, specialMappings, clientChangedData);\n\n            firstRequest.resolve();\n        };\n\n        self.cancelData = function () {\n            // revert unsaved changes\n            self.fromResponse(self.lastReceivedSettings);\n\n            self.hide();\n        };\n\n        self.saveData = function (data, successCallback, setAsSending) {\n            var options;\n            if (_.isPlainObject(successCallback)) {\n                options = successCallback;\n            } else {\n                options = {\n                    success: successCallback,\n                    sending: setAsSending === true\n                };\n            }\n\n            self.settingsDialog.trigger(\"beforeSave\");\n\n            self.sawUpdateEventWhileSending = false;\n            self.sending(data === undefined || options.sending || false);\n\n            if (data === undefined) {\n                // we also only send data that actually changed when no data is specified\n                var localData = self.getLocalData();\n                data = getOnlyChangedData(localData, self.lastReceivedSettings);\n            }\n\n            // final validation\n            if (self.testFoldersDuplicate()) {\n                // duplicate folders configured, we refuse to send any folder config\n                // to the server\n                delete data.folder;\n            }\n\n            self.active = true;\n            return OctoPrint.settings\n                .save(data)\n                .done(function (data, status, xhr) {\n                    self.ignoreNextUpdateEvent = !self.sawUpdateEventWhileSending;\n                    self.active = false;\n\n                    self.receiving(true);\n                    self.sending(false);\n\n                    try {\n                        self.fromResponse(data);\n                        if (options.success) options.success(data, status, xhr);\n                    } finally {\n                        self.receiving(false);\n                    }\n                })\n                .fail(function (xhr, status, error) {\n                    self.sending(false);\n                    self.active = false;\n                    if (options.error) options.error(xhr, status, error);\n                })\n                .always(function (xhr, status) {\n                    if (options.complete) options.complete(xhr, status);\n                });\n        };\n\n        self.onEventSettingsUpdated = function () {\n            if (self.active) {\n                self.sawUpdateEventWhileActive = true;\n            }\n\n            var preventSettingsRefresh = _.any(self.allViewModels, function (viewModel) {\n                if (viewModel.hasOwnProperty(\"onSettingsPreventRefresh\")) {\n                    try {\n                        return viewModel[\"onSettingsPreventRefresh\"]();\n                    } catch (e) {\n                        log.warn(\n                            \"Error while calling onSettingsPreventRefresh on\",\n                            viewModel,\n                            \":\",\n                            e\n                        );\n                        return false;\n                    }\n                } else {\n                    return false;\n                }\n            });\n\n            if (preventSettingsRefresh) {\n                // if any of our viewmodels prevented this refresh, we'll just return now\n                return;\n            }\n\n            if (self.isDialogActive()) {\n                // dialog is open and not currently busy...\n                if (\n                    self.sending() ||\n                    self.receiving() ||\n                    self.active ||\n                    self.ignoreNextUpdateEvent\n                ) {\n                    self.ignoreNextUpdateEvent = false;\n                    return;\n                }\n\n                if (!hasDataChanged(self.getLocalData(), self.lastReceivedSettings)) {\n                    // we don't have local changes, so just fetch new data\n                    self.requestData();\n                } else {\n                    // we have local changes, show update dialog\n                    self.settingsUpdatedDialog.modal(\"show\");\n                }\n            } else {\n                // dialog is not open, just fetch new data\n                self.requestData();\n            }\n        };\n\n        self._resetScrollPosition = function () {\n            $(\"#settings_dialog_content\", self.settingsDialog).scrollTop(0);\n\n            // also reset any contained tabs/pills/lists to first pane\n            $(\n                '#settings_dialog_content ul.nav-pills a[data-toggle=\"tab\"]:first',\n                self.settingsDialog\n            ).tab(\"show\");\n            $(\n                '#settings_dialog_content ul.nav-list a[data-toggle=\"tab\"]:first',\n                self.settingsDialog\n            ).tab(\"show\");\n            $(\n                '#settings_dialog_content ul.nav-tabs a[data-toggle=\"tab\"]:first',\n                self.settingsDialog\n            ).tab(\"show\");\n        };\n\n        self.selectTab = function (tab) {\n            if (tab != undefined) {\n                if (!_.startsWith(tab, \"#\")) {\n                    tab = \"#\" + tab;\n                }\n                $('ul.nav-list a[href=\"' + tab + '\"]', self.settingsDialog).tab(\"show\");\n            } else {\n                $('ul.nav-list a[data-toggle=\"tab\"]:first', self.settingsDialog).tab(\n                    \"show\"\n                );\n            }\n        };\n\n        self.onServerReconnect = function () {\n            // the settings might have changed if the server was just restarted,\n            // better refresh them now\n            self.requestData();\n        };\n\n        self.onUserPermissionsChanged =\n            self.onUserLoggedIn =\n            self.onUserLoggedOut =\n                function () {\n                    // we might have other user rights now, refresh (but only if startup has fully completed)\n                    if (!self._startupComplete) return;\n                    self.requestData();\n                };\n    }\n\n    OCTOPRINT_VIEWMODELS.push({\n        construct: SettingsViewModel,\n        dependencies: [\n            \"loginStateViewModel\",\n            \"accessViewModel\",\n            \"printerProfilesViewModel\",\n            \"aboutViewModel\",\n            \"usersViewModel\"\n        ],\n        elements: [\"#settings_dialog\", \"#navbar_settings\"]\n    });\n});\n", "<div class=\"control-group\" title=\"{{ _('URL to embed into the UI for live viewing of the webcam stream')|edq }}\" data-bind=\"css: { error: !webcam_streamValid() }\">\n    <label class=\"control-label\" for=\"settings-webcamStreamUrl\">{{ _('Stream URL') }}</label>\n    <div class=\"controls\">\n        <div class=\"input-append\">\n            <input type=\"text\" class=\"input-block-level\" data-bind=\"value: webcam_streamUrl, valueUpdate: 'afterkeydown'\" id=\"settings-webcamStreamUrl\">\n            <button class=\"btn\" type=\"button\" data-bind=\"click: testWebcamStreamUrl, enable: !testWebcamStreamUrlBusy() && webcam_streamValid(), css: {disabled: testWebcamStreamUrlBusy() || !webcam_streamValid()}\"><i class=\"fas fa-spinner fa-spin\" data-bind=\"visible: testWebcamStreamUrlBusy\"></i> {{ _('Test') }}</button>\n        </div>\n        <span class=\"help-block\">\n            <p>{% trans %}Needs to be reachable from the browser displaying the OctoPrint UI, used to embed the webcam stream into the page.{% endtrans %}</p>\n            <p data-bind=\"visible: webcam_streamType() === 'webrtc'\">{% trans %}<strong>Heads-up!</strong> WebRTC support is still in beta and subject to change, monitor the changelog of future versions closely for heads-ups regarding the WebRTC support in OctoPrint.{% endtrans %}</p>\n        </span>\n    </div>\n</div>\n"], "filenames": ["src/octoprint/static/js/app/helpers.js", "src/octoprint/static/js/app/viewmodels/settings.js", "src/octoprint/templates/snippets/settings/webcam/webcamStreamUrl.jinja2"], "buggy_code_start_loc": [1544, 321, 1], "buggy_code_end_loc": [1579, 471, 7], "fixing_code_start_loc": [1545, 322, 1], "fixing_code_end_loc": [1613, 482, 7], "type": "CWE-79", "message": "Cross-site Scripting (XSS) - Generic in GitHub repository octoprint/octoprint prior to 1.8.0.", "other": {"cve": {"id": "CVE-2022-1432", "sourceIdentifier": "security@huntr.dev", "published": "2022-05-18T14:15:08.193", "lastModified": "2022-05-25T20:18:40.853", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cross-site Scripting (XSS) - Generic in GitHub repository octoprint/octoprint prior to 1.8.0."}, {"lang": "es", "value": "Una vulnerabilidad de tipo Cross-site Scripting (XSS) - Gen\u00e9rico en el repositorio de GitHub octoprint/octoprint versiones anteriores a 1.8.0"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:H/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 6.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.5, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.6, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:H/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "HIGH", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:octoprint:octoprint:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.8.0", "matchCriteriaId": "CDF4E52F-D6FD-49EF-A45A-1C9659EF2C14"}]}]}], "references": [{"url": "https://github.com/octoprint/octoprint/commit/6d259d7e6f5b0de9a1c762831537a386e53978d3", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/cb545c63-a3c1-4d57-8f06-e4593ab389bf", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/octoprint/octoprint/commit/6d259d7e6f5b0de9a1c762831537a386e53978d3"}}