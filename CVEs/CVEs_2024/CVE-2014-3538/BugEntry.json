{"buggy_code": ["2014-05-30  12:51  Christos Zoulas <christos@zoulas.com>\n\n\t* Make the range operator limit the length of the\n\t  regex search.\n\n2014-05-14  19:23  Christos Zoulas <christos@zoulas.com>\n\n\t* PR/347: Windows fixes\n\t* PR/352: Hangul word processor recognition\n\t* PR/354: Encoding irregularities in text files\n\n2014-05-06  6:12  Christos Zoulas <christos@zoulas.com>\n\n\t* Fix uninitialized title in CDF files (Jan Kaluza)\n\n2014-05-04  14:55  Christos Zoulas <christos@zoulas.com>\n\n\t* PR/351: Fix compilation of empty files \n\n2014-04-30  17:39  Christos Zoulas <christos@zoulas.com>\n\n\t* Fix integer formats: We don't specify 'l' or\n\t  'h' and 'hh' specifiers anymore, only 'll' for\n\t  quads and nothing for the rest. This is so that\n\t  magic writing is simpler.\n\n2014-04-01  15:25  Christos Zoulas <christos@zoulas.com>\n\n\t* PR/341: Jan Kaluza, fix memory leak\n\t* PR/342: Jan Kaluza, fix out of bounds read\n\n2014-03-28  15:25  Christos Zoulas <christos@zoulas.com>\n\n\t* Fix issue with long formats not matching fmtcheck\n\n2014-03-26  11:25  Christos Zoulas <christos@zoulas.com>\n\n\t* release 5.18\n\n2014-03-15  17:45  Christos Zoulas <christos@zoulas.com>\n\n\t* add fmtcheck(3) for those who don't have it\n\n2014-03-14  15:12  Christos Zoulas <christos@zoulas.com>\n\n\t* prevent mime entries from being attached to magic\n\t  entries with no descriptions\n\n\t* adjust magic strength for regex type\n\n\t* remove superfluous ascmagic with encoding test\n\n2014-03-06  12:01  Christos Zoulas <christos@zoulas.com>\n\n\t* fix regression fix echo -ne \"\\012\\013\\014\" | file -i -\n\t  which printed \"binary\" instead of \"application/octet-stream\"\n\n\t* add size_t overflow check for magic file size\n\n2014-02-27  16:01  Christos Zoulas <christos@zoulas.com>\n\n\t* experimental support for matching with CFD CLSID\n\n2014-02-18  13:04  Kimmo Suominen (kimmo@suominen.com)\n\n\t* Cache old LC_CTYPE locale before setting it to \"C\", so\n\t  we can use it to restore LC_CTYPE instead of asking\n\t  setlocale() to scan the environment variables.\n\n2014-02-12  18:21  Christos Zoulas <christos@zoulas.com>\n\n\t* Count recursion levels through indirect magic\n\n2014-02-11  10:40  Christos Zoulas <christos@zoulas.com>\n\n\t* Prevent infinite recursion on files with indirect offsets of 0\n\n2014-01-30  21:00  Christos Zoulas <christos@zoulas.com>\n\n\t* Add -E flag that makes file print filesystem errors to stderr\n\t  and exit.\n\n2014-01-08  17:20  Christos Zoulas <christos@zoulas.com>\n\n\t* mime printing could print results from multiple magic entries\n\t  if there were multiple matches.\n\t* in some cases overflow was not detected when computing offsets\n\t  in softmagic.\n\n2013-12-05  12:00  Christos Zoulas <christos@zoulas.com>\n\n\t* use strcasestr() to for cdf strings\n\t* reset to the \"C\" locale while doing regex operations, or case\n\t  insensitive comparisons; this is provisional\n\n2013-11-19  20:10  Christos Zoulas <christos@zoulas.com>\n\n\t* always leave magic file loaded, don't unload for magic_check, etc.\n\t* fix default encoding to binary instead of unknown which broke recently\n\t* handle empty and one byte files, less specially so that\n\t  --mime-encoding does not break completely.\n\t\t`\n2013-11-06  14:40  Christos Zoulas <christos@zoulas.com>\n\n\t* fix erroneous non-zero exit code from non-existant file and message\n\n2013-10-29  14:25  Christos Zoulas <christos@zoulas.com>\n\n\t* add CDF MSI file detection (Guy Helmer)\n\n2013-09-03  11:56  Christos Zoulas <christos@zoulas.com>\n\n\t* Don't mix errors and regular output if there was an error\n\t* in magic_descriptor() don't close the file and try to restore\n\t  its position\n\n2013-05-30  17:25  Christos Zoulas <christos@zoulas.com>\n\n\t* Don't treat magic as an error if offset was past EOF (Christoph Biedl)\n\n2013-05-28  17:25  Christos Zoulas <christos@zoulas.com>\n\t\n\t* Fix spacing issues in softmagic and elf (Jan Kaluza)\n\n2013-05-02  18:00  Christos Zoulas <christos@zoulas.com>\n\n\t* Fix segmentation fault with multiple magic_load commands.\n\n2013-04-22  11:20  Christos Zoulas <christos@zoulas.com>\n\n\t* The way \"default\" was implemented was not very useful\n\t  because the \"if something was printed at that level\"\n\t  was not easily controlled by the user, and the format\n\t  was bound to a string which is too restrictive. Add\n\t  a \"clear\" for that level keyword and make \"default\"\n\t  void. This way one can do:\n\n\t\t>>13\tclear\tx\n\t\t>>13\tlelong\t1\tfoo\n\t\t>>13\tlelong\t2\tbar\n\t\t>>13\tdefault\tx\n\t\t>>>13\tlelong\tx\tunknown %x\n\n2013-03-25  13:20  Christos Zoulas <christos@zoulas.com>\n\n\t* disallow strength setting in \"name\" entries\n\n2013-03-06  21:24  Christos Zoulas <christos@zoulas.com>\n\n\t* fix recursive magic separator printing\n\n2013-02-26  19:28  Christos Zoulas <christos@zoulas.com>\n\n\t* limit recursion level for mget\n\t* fix pread() related breakage in cdf\n\t* handle offsets properly in recursive \"use\"\n\n2013-02-18  10:39  Christos Zoulas <christos@zoulas.com>\n\n\t* add elf reading of debug info to determine if file is stripped\n\t  (Jan Kaluza)\n\t* use pread()\n\n2013-01-25  18:05  Christos Zoulas <christos@zoulas.com>\n\n\t* change mime description size from 64 to 80 to accommodate OOXML.\n\n2013-01-11  14:50  Christos Zoulas <christos@zoulas.com>\n\n\t* Warn about inconsistent continuation levels.\n\t* Change fsmagic to add a space after it prints.\n\n2013-01-10  21:00  Christos Zoulas <christos@zoulas.com>\n\n\t* Make getline public so that file can link against it.\n\t  Perhaps it is better to rename it, or hide it differently.\n\t  Fixes builds on platforms that do not provide it.\n\t  \n2013-01-07  16:30  Christos Zoulas <christos@zoulas.com>\n\n\t* Add SuS d{,1,2,4,8}, u{,1,2,4,8} and document\n\t  what long, int, short, etc is (Guy Harris)\n\n2013-01-06  11:20  Christos Zoulas <christos@zoulas.com>\n\n\t* add magic_version function and constant\n\t* Redo memory allocation and de-allocation.\n\t  (prevents double frees on non mmap platforms)\n\t* Fix bug with name/use having to do with passing\n\t  found state from the parent to the child and back.\n\n2012-12-19   8:47  Christos Zoulas <christos@zoulas.com>\n\n\t* Only print elf capabilities for archs we know (Jan Kaluza)\n\n2012-10-30  19:14  Christos Zoulas <christos@zoulas.com>\n\n\t* Add \"name\" and \"use\" file types in order to look\n\t  inside mach-o files.\n\n2012-09-06  10:40  Christos Zoulas <christos@zoulas.com>\n\n\t* make --version exit 0 (Matthew Schultz)\n\t* add string/T (Jan Kaluza)\n\n2012-08-09  2:15  Christos Zoulas <christos@zoulas.com>\n\n\t* add z and t modifiers for our own vasprintf\n\t* search for $HOME/.magic.mgc if it is there first\n\t* fix reads from a pipe, and preserve errno\n\n2012-05-15  13:12  Christos Zoulas <christos@zoulas.com>\n\n\t* use ctime_r, asctime_r\n\n2012-04-06  17:18  Christos Zoulas <christos@zoulas.com>\n\n\t* Fixes for indirect offsets to handle apple disk formats\n\n2012-04-03  18:26  Christos Zoulas <christos@zoulas.com>\n\n\t* Add windows date field types\n\t* More info for windows shortcuts (incomplete)\n\n2012-02-20  17:33  Christos Zoulas <christos@zoulas.com>\n\n\t* Fix CDF parsing issues found by CERT's fuzzing tool (Will Dormann)\n\n2011-12-15  12:17  Chris Metcalf <cmetcalf@tilera.com>\n\n\t* Support Tilera architectures (tile64, tilepro, tilegx).\n\n2011-12-16  16:33  Reuben Thomas <rrt@sc3d.org>\n\n\t* Add magic for /usr/bin/env Perl scripts\n\t* Weaken generic script magic to avoid clashing with\n\tlanguage-specific magic.\n\n2011-12-08  13:37  Reuben Thomas <rrt@sc3d.org>\n\n\t* Simplify if (p) free(p) to free(p).\n\n2011-12-08  13:07  Reuben Thomas <rrt@sc3d.org>\n\n\t* Remove hardwired token finding (names.h), turning it into soft\n\tmagic. Patterns are either anchored regexs or search/8192. English\n\tlanguage detection and PL/1 detection have been removed as they\n\twere too fragile. -e tokens is still accepted for backwards\n\tcompatibility.\n\t* Move 3ds patterns (which are commented out anyway) into autodesk\n\t(they were, oddly, in c-lang).\n\n2011-12-06  00:16  Reuben Thomas <rrt@sc3d.org>\n\n\t* Tweak strength of generic hash-bang detectors to be less than\n\tspecific ones.\n\t* Make an inconsistent description of Python scripts consistent.\n\n2011-12-05  23:58  Reuben Thomas <rrt@sc3d.org>\n\n\t* Fix minor error in file(1).\n\n2011-11-05  00:00  Reuben Thomas <rrt@sc3d.org>\n\n\t* Fix issue #150 (I hope).\n\n2011-09-22  12:57  Christos Zoulas <christos@zoulas.com>\n\n\t* Python3 binding fixes from Kelly Anderson\n\n2011-09-20  11:32  Christos Zoulas <christos@zoulas.com>\n\n\t* If a string type magic entry is marked as text or binary\n\t  only match text files against text entries and binary\n\t  files against binary entries.\n\n2011-09-01  12:12  Christos Zoulas <christos@zoulas.com>\n\n\t* Don't wait for any subprocess, just the one we forked.\n\n2011-08-26  16:40  Christos Zoulas <christos@zoulas.com>\n\n\t* If the application name is not set in a cdf file, try to see\n\t  if it has a directory with the application name on it.\n\n2011-08-17  14:32  Christos Zoulas <christos@zoulas.com>\n\n\t* Fix ELF lseek(2) madness. Inspired by PR/134 by Jan Kaluza\n\n2011-08-14  09:03  Christos Zoulas <christos@zoulas.com>\n\n\t* Don't use variable string formats.\n\n2011-07-12  12:32  Reuben Thomas <rrt@sc3d.org>\n\n\t* Fix detection of Zip files (Mantis #128).\n\t* Make some minor improvements to file(1).\n\t* Rename MIME types for filesystem objects for consistency with\n\t  xdg-utils. Typically this means that application/x-foo becomes\n\t  inode/foo, but some names also change slightly, e.g.\n\t  application/x-character-device becomes inode/chardevice.\n\n2011-05-10  20:57  Christos Zoulas <christos@zoulas.com>\n\n\t* fix mingw compilation (Abradoks)\n\n2011-05-10  20:57  Christos Zoulas <christos@zoulas.com>\n\n\t* remove patchlevel.h\n\t* Fix read past allocated memory caused by double-incrementing\n\t  a pointer in a loop (reported by Roberto Maar)\n\n2011-03-30  15:45  Christos Zoulas <christos@zoulas.com>\n\n\t* Fix cdf string buffer setting (Sven Anders)\n\n2011-03-20  16:35  Christos Zoulas <christos@zoulas.com>\n\n\t* Eliminate MAXPATHLEN and use dynamic allocation for\n\t  path and file buffers.\n\n2011-03-15  18:15  Christos Zoulas <christos@zoulas.com>\n\n\t* binary tests on magic entries with masks could spuriously\n\t  get converted to ascii.\n\n2011-03-12  18:06  Reuben Thomas <rrt@sc3d.org>\n\n\t* Improve file.man (remove BUGS, present email addresses consistently).\n\n2011-03-07  19:38  Christos Zoulas <christos@zoulas.com>\n\n\t* add lrzip support (from Ville Skytta)\n\n2011-02-10  16:36  Christos Zoulas <christos@zoulas.com>\n\n\t* fix CDF bounds checking (Guy Helmer)\n\n2011-02-10  12:03  Christos Zoulas <christos@zoulas.com>\n\n\t* add cdf_ctime() that prints a meaningful error when time cannot\n\t  be converted.\n\n2011-02-02  20:40  Christos Zoulas <christos@zoulas.com>\n\n\t* help and version output to stdout.\n\n\t* When matching softmagic for ascii files, don't just print\n\t  the softmagic classification, keep going and print the\n\t  text classification too. This fixes broken troff files when\n\t  we moved them from keyword recognition to softmagic\n\t  (they stopped printing \"with CRLF\" etc.)\n\t  Reported by Doug McIlroy.\n\n2011-01-16  19:31  Reuben Thomas <rrt@sc3d.org>\n\n\t* Fix two potential buffer overruns in apprentice_list.\n\n2011-01-14  22:33  Reuben Thomas <rrt@sc3d.org>\n\n\t* New Python binding in pure Python.\n\t* Update libmagic(3).\n\n2011-01-06  21:40  Reuben Thomas <rrt@sc3d.org>\n\n\t* Fix Python bindings (including recent Python 3 compatibility\n\t  update).\n\n2011-01-04  18:43  Reuben Thomas <rrt@sc3d.org>\n\n\t* magic/Makefile.am: make it easier to recover from magic build failures.\n\t* Fix pstring length specifier parsing to avoid generating invalid\n\t  magic files.\n\t* Add pstring length \"J\" (for \"JPEG\") to specify that the length\n\t  include itself.\n\t* Fix JPEG comment parsing at last using pstring/HJ!\n\t* Ignore section 5 man pages in doc/.cvsignore.\n\n2010-12-22  13:12  Christos Zoulas <christos@zoulas.com>\n\n\t* Add pstring/BHhLl to specify the type of the length of pascal\n\t  strings.\n\n2010-11-26  18:39  Reuben Thomas <rrt@sc3d.org>\n\n\t* Fix \"-e soft\": it was ignored when softmagic was called\n\t  during asciimagic.\n\t* Improve comments and use \"unsigned char\" in tar.h/is_tar.c.\n\n2010-11-05  17:26  Reuben Thomas <rrt@sc3d.org>\n\n\t* Make bug reporting addresses more visible.\n\n2010-11-01  18:35  Reuben Thomas <rrt@sc3d.org>\n\n\t* Add tcl magic from Gustaf Neumann\n\n2010-10-24  10:42  Christos Zoulas <christos@zoulas.com>\n\n\t* Fix the whitespace comparing code (Christopher Chittleborough)\n\n2010-10-06  21:05  Christos Zoulas <christos@zoulas.com>\n\n\t* allow string/t to work (Jan Kaluza)\n\n2010-09-20  22:11  Reuben Thomas <rrt@sc3d.org>\n\n\t* Apply some patches from Ubuntu and Fedora.\n\n2010-09-20  21:16  Reuben Thomas <rrt@sc3d.org>\n\n\t* Apply all patches from Debian package 5.04-6 which have not\n\t  already been applied and are not Debian-specific.\n\n2010-09-20  15:24  Reuben Thomas <rrt@sc3d.org>\n\n\t* Minor security fix to softmagic.c (don't use untrusted\n\t  string as printf format).\n\n2010-07-21  12:20  Christos Zoulas <christos@zoulas.com>\n\n\t* MINGW32 portability from LRN\n\n\t* Don't warn about escaping magic regex chars when we are in a regex.\n\n2010-07-19  10:55  Christos Zoulas <christos@zoulas.com>\n\n\t* Only try to print prpsinfo for core files. (Jan Kaluza)\n\n2010-04-22  12:55  Christos Zoulas <christos@zoulas.com>\n\n\t* Try more elf offsets for Debian core files.  (Arnaud Giersch)\n\n2010-02-20  15:18  Reuben Thomas <rrt@sc3d.org>\n\n\t* Clarify which sort of CDF we mean.\n\n2010-02-14  22:58  Reuben Thomas <rrt@sc3d.org>\n\n\t* Re-jig Zip file type magic so that unsupported special\n\t  Zip types (those with \"mimetype\" at offset 30) can be\n\t  recognized.\n\n2010-02-02  21:50  Reuben Thomas <rrt@sc3d.org>\n\n\t* Add support for OCF (EPUB) files (application/epub+zip)\n\n2010-01-28  18:25  Christos Zoulas <christos@zoulas.com>\n\n\t* Fix core-dump from unbound loop:\n\t  https://bugzilla.redhat.com/show_bug.cgi?id=533245\n\n2010-01-22  15:45  Christos Zoulas <christos@zoulas.com>\n\n\t* print proper mime for crystal reports file\n\n\t* print the last summary information of a cdf document, not the\n\t  first so that nested documents print the right info\n\n2010-01-16  18:42  Charles Longeau <chl@tuxfamily.org>\n\n\t* bring back some fixes from OpenBSD:\n\t\t- make gcc2 builds file\n\t\t- fix typos in a magic file comment\n\n2009-11-17  18:35  Christos Zoulas <christos@zoulas.com>\n\n\t* ctime/asctime can return NULL on some OS's although\n\t  they should not (Toshit Antani)\n\n2009-09-14  13:49  Christos Zoulas <christos@zoulas.com>\n\n\t* Centralize magic path handling routines and remove the\n\t  special-casing from file.c so that the python module for\n\t  example comes up with the same magic path (Fixes ~/.magic\n\t  handling) (from Gab)\n\n2009-09-11  23:38  Reuben Thomas <rrt@sc3d.org>\n\n\t* When magic argument is a directory, read the files in\n\t  strcmp-sorted order (fixes Debian bug #488562 and our own FIXME).\n\n2009-09-11  13:11  Reuben Thomas <rrt@sc3d.org>\n\n\t* Combine overlapping epoc and psion magic files into one (epoc).\n\n\t* Add some more EPOC MIME types.\n\n2009-08-19  15:55  Christos Zoulas <christos@zoulas.com>\n\n\t* Fix 3 bugs (From Ian Darwin):\n\t    - file_showstr could move one past the end of the array\n\t    - parse_apple did not nul terminate the string in the overflow case\n\t    - parse_mime truncated the wrong string in the overflow case\n\n2009-08-12  12:28  Robert Byrnes  <byrnes@wildpumpkin.net>\n\n\t* Include Localstuff when compiling magic.\n\n2009-07-15  10:05  Christos Zoulas <christos@zoulas.com>\n\n\t* Fix logic for including mygetopts.h\n\n\t* Make cdf.c compile again with debugging\n\n\t* Add the necessary field handling for crystal reports files to work\n\n2009-06-23 01:34  Reuben Thomas <rrt@sc3d.org>\n\n\t* Stop \"(if\" identifying Lisp files, that's plain dumb!\n\n2009-06-09 22:13  Reuben Thomas <rrt@sc3d.org>\n\n\t* Add a couple of missing MP3 MIME types.\n\n2009-05-27 23:00  Reuben Thomas <rrt@sc3d.org>\n\n\t* Add full range of hash-bang tests for Python and Ruby.\n\n\t* Add MIME types for Python and Ruby scripts.\n\n2009-05-13  10:44  Christos Zoulas <christos@zoulas.com>\n\n\t* off by one in parsing hw capabilities in elf\n\t  (Cheng Renquan)\n\n2009-05-08  13:40  Christos Zoulas <christos@zoulas.com>\n\t\n\t* lint fixes and more from NetBSD\n\n2009-05-06  10:25  Christos Zoulas <christos@zoulas.com>\n\n\t* Avoid null dereference in cdf code (Drew Yao)\n\n\t* More cdf bounds checks and overflow checks\n\n2009-05-01  18:37  Christos Zoulas <christos@zoulas.com>\n\n\t* Buffer overflow fixes from Drew Yao\n\n2009-04-30  17:10  Christos Zoulas <christos@zoulas.com>\n\n\t* Fix more cdf lossage. All the documents I have\n\t  right now print the correct information.\n\n2009-03-27  18:43  Christos Zoulas <christos@zoulas.com>\n\n\t* don't print \\012- separators in the same magic entry \n\t  if it consists of multiple magic printing lines.\n\n2009-03-23  10:20  Christos Zoulas <christos@zoulas.com>\n\n\t* Avoid file descriptor leak in compress code from\n\t  (Daniel Novotny)\n\n2009-03-18  16:50  Christos Zoulas <christos@zoulas.com>\n\n\t* Allow escaping of relation characters, so that we can say \\^[A-Z]\n\t  and the ^ is not eaten as a relation char.\n\n\t* Fix troff and fortran to their previous glory using\n\t  regex. This was broken since their removel from ascmagic.\n\n2009-03-10  16:50  Christos Zoulas <christos@zoulas.com>\n\n\t* don't use strlen in strndup() (Toby Peterson)\n\n2009-03-10  7:45  Christos Zoulas <christos@zoulas.com>\n\n\t* avoid c99 syntax.\n\n2009-02-23 15:45  Christos Zoulas <christos@zoulas.com>\n\n\t* make the cdf code use the buffer first if available,\n\t  and then the fd code.\n\n2009-02-13 13:45  Christos Zoulas <christos@zoulas.com>\n\n\t* look for struct option to determine if getopt.h is usable for IRIX.\n\n\t* sanitize cdf document strings\n\n2009-02-04 13:25  Christos Zoulas <christos@zoulas.com>\n\n\t* fix OS/2 warnings.\n\n2008-12-12 15:50  Christos Zoulas <christos@zoulas.com>\n\n\t* fix initial offset calculation for non 4K sector files\n\n\t* add loop limits to avoid DoS attacks by constructing\n\t  looping sector references.\n\n2008-12-03 13:05  Christos Zoulas <christos@zoulas.com>\n\n\t* fix memory botches on cdf file parsing.\n\n\t* exit with non-zero value for any error, not just for the last\n\t  file processed.\n\n2008-11-09 20:42  Charles Longeau <chl@tuxfamily.org>\n\n\t* Replace all str{cpy,cat} functions with strl{cpy,cat}\n\t* Ensure that strl{cpy,cat} are included in libmagic,\n\t  as needed.\n\n2008-11-06 18:18  Christos Zoulas <christos@zoulas.com>\n\n\t* Handle ID3 format files.\n\n2008-11-06 23:00  Reuben Thomas <rrt@sc3d.org>\n\n\t* Fix --mime, --mime-type and --mime-encoding under new scheme.\n\n\t* Rename \"ascii\" to \"text\" and add \"encoding\" test.\n\n\t* Return a precise (\"utf-16le\" or \"utf-16be\") MIME charset for\n\t  UTF-16.\n\n\t* Fix error in comment caused by automatic indentation adding\n\t  words!\n\n2008-11-06 10:35  Christos Zoulas <christos@astron.com>\n\n\t* use memchr instead of strchr because the string\n\t  might not be NUL terminated (Scott MacVicar)\n\n2008-11-03 07:31  Reuben Thomas <rrt@sc3d.org>\n\n\t* Fix a printf with a non-literal format string.\n\n\t* Fix formatting and punctuation of help for \"--apple\".\n\n2008-10-30 11:00  Reuben Thomas <rrt@sc3d.org>\n\n\t* Correct words counts in comments of struct magic.\n\n\t* Fix handle_annotation to allow both Apple and MIME types to be\n\t  printed, and to return correct code if MIME type is\n\t  printed (1, not 0) or if there's an error (-1 not 1).\n\n\t* Fix output of charset for MIME type (precede with semi-colon;\n\t  fixes Debian bug #501460).\n\n\t* Fix potential attacks via conversion specifications in magic\n\t  strings.\n\n\t* Add a FIXME for Debian bug #488562 (magic files should be\n\t  read in a defined order, by sorting the names).\n\n2008-10-18 16:45  Christos Zoulas <christos@astron.com>\n\n\t* Added APPLE file creator/type\n\n2008-10-12 10:20  Christos Zoulas <christos@astron.com>\n\n\t* Added CDF parsing\n\n2008-10-09 16:40  Christos Zoulas <christos@astron.com>\n\n\t* filesystem and msdos patches (Joerg Jenderek)\n\n2008-10-09 13:20  Christos Zoulas <christos@astron.com>\n\n\t* correct --exclude documentation issues: remove troff and fortran\n\t  and rename \"token\" to \"tokens\". (Randy McMurchy)\n\n2008-10-01 10:30  Christos Zoulas <christos@astron.com>\n\n\t* Read ~/.magic in addition to the default magic file not instead\n\t  of, as documented in the man page.\n\n2008-09-10 21:30  Reuben Thomas  <rrt@sc3d.org>\n\n\t* Comment out graphviz patterns, as they match too many files.\n\n2008-08-30 12:54  Christos Zoulas <christos@astron.com>\n\n\t* Don't eat trailing \\n in magic enties.\n\n\t* Cast defines to allow compilation using a c++ compiler.\n\n2008-08-25 23:56  Reuben Thomas  <rrt@sc3d.org>\n\n\t* Add text/x-lua MIME type for Lua scripts.\n\n\t* Escape { in regex in graphviz patterns.\n\n2008-07-26 00:59  Reuben Thomas  <rrt@sc3d.org>\n\n\t* Add MIME types for special files.\n\n\t* Use access to give more accurate information for files that\n\t  can't be opened.\n\n\t* Add a TODO list.\n\n2008-07-02 11:15  Christos Zoulas  <christos@astron.com>\n\n\t* add !:strength op to adjust magic strength (experimental)\n\n2008-06-16 21:41  Reuben Thomas  <rrt@sc3d.org>\n\n\t* Fix automake error in configure.ac.\n\n\t* Add MIME type for Psion Sketch files.\n\n2008-06-05 08:59  Christos Zoulas  <christos@astron.com>\n\n\t* Don't print warnings about bad namesize in stripped\n\t  binaries with PT_NOTE is still there, and the actual\n\t  note is gone (Jakub Jelinek)\n\n2008-05-28 15:12  Robert Byrnes  <byrnes@wildpumpkin.net>\n\n\t* magic/Magdir/elf:\n\t  Note invalid byte order for little-endian SPARC32PLUS.\n\t  Add SPARC V9 vendor extensions and memory model.\n\n\t* src/elfclass.h:\n\t  Pass target machine to doshn (for Solaris hardware capabilities).\n\n\t* src/readelf.c (doshn):\n\t  Add support for Solaris hardware/software capabilities.\n\n\t* src/readelf.h:\n\t  Ditto.\n\n\t* src/vasprintf.c (dispatch):\n\t  Add support for ll modifier.\n\n2008-05-16 10:25  Christos Zoulas  <christos@astron.com>\n\n\t* Fix compiler warnings.\n\n\t* remove stray printf, and fix a vprintf bug. (Martin Dorey)\n\n2008-05-06 00:13  Robert Byrnes  <byrnes@wildpumpkin.net>\n\n\t* src/Makefile.am:\n\t  Ensure that getopt_long and [v]asprintf are included in libmagic,\n\t  as needed.\n\n\t  Remove unnecessary EXTRA_DIST.\n\n\t* src/Makefile.in:\n\t  Rerun automake.\n\n\t* src/vasprintf.c (dispatch):\n\t  Fix variable precision bug: be sure to step past '*'.\n\n\t* src/vasprintf.c (core):\n\t  Remove unreachable code.\n\n\t* src/apprentice.c (set_test_type):\n\t  Add cast to avoid compiler warning.\n\n2008-04-22 23:45  Christos Zoulas  <christos@astron.com>\n\n\t* Add magic submission guidelines (Abel Cheung)\n\n\t* split msdos and windows magic (Abel Cheung)\n\n2008-04-04 11:00  Christos Zoulas  <christos@astron.com>\n\n\t* >= <= is not supported, so fix the magic and warn about it.\n\t  reported by: Thien-Thi Nguyen <ttn@gnuvola.org>\n\n2008-03-27 16:16  Robert Byrnes  <byrnes@wildpumpkin.net>\n\n\t* src/readelf.c (donote):\n\t  ELF core file command name/line bug fixes and enhancements:\n\n\t  Try larger offsets first to avoid false matches\n\t  from earlier data that happen to look like strings;\n\t  this primarily affected SunOS 5.x 32-bit Intel core files.\n\n\t  Add support for command line (instead of just short name)\n\t  for SunOS 5.x.\n\n\t  Add information about NT_PSINFO for SunOS 5.x.\n\n\t  Only trim whitespace from end of command line.\n\n2007-02-11 01:36 Reuben Thomas <rrt@sc3d.org>\n\n\t* Change strength of ! from MULT to 0, as it matches almost\n\t\t  anything (Reuben Thomas)\n\n\t* Debian fixes (Reuben Thomas)\n\n2007-02-11 00:17 Reuben Thomas <rrt@sc3d.org>\n\n\t* Clarify UTF-8 BOM message (Reuben Thomas)\n\n\t* Add HTML comment to token list in names.h\n\n2007-02-04 15:50 Christos Zoulas <christos@astron.com>\n\n\t* Debian fixes (Reuben Thomas)\n\n2007-02-04 11:31 Christos Zoulas <christos@astron.com>\n\n\t* !:mime annotations in magic files (Reuben Thomas)\n\n2007-01-29 15:35 Christos Zoulas <christos@astron.com>\n\n\t* zero out utime/utimes structs (Gavin Atkinson)\n\n2007-01-26 13:45 Christos Zoulas <christos@astron.com>\n\n\t* reduce writable data from Diego \"Flameeyes\" Petten\n\n2007-12-28 15:06 Christos Zoulas <christos@astron.com>\n\n\t* strtof detection\n\n\t* remove bogus regex magic that could cause a DoS\n\n\t* better mismatch version message\n\n2007-12-27 11:35 Christos Zoulas <christos@astron.com>\n\n\t* bring back some fixes from OpenBSD\n\n\t* treat ELF dynamic objects as executables\n\n\t* fix gcc warnings\n\n2007-12-01 19:55 Christos Zoulas <christos@astron.com>\n\n\t* make sure we have zlib.h and libz to compile the builtin\n\t  decompress code\n\n2007-10-28 20:48 Christos Zoulas <christos@astron.com>\n\n \t* float and double magic support (Behan Webster)\n\n2007-10-28 20:48 Christos Zoulas <christos@astron.com>\n\n\t* Convert fortran to a soft test (Reuben Thomas)\n\n2007-10-23  5:25 Christos Zoulas <christos@astron.com>\n\n\t* Add --with-filename, and --no-filename (Reuben Thomas)\n\n2007-10-23  3:59 Christos Zoulas <christos@astron.com>\n\n\t* Rest of the mime split (Reuben Thomas)\n\n\t* Make usage message generated from the flags so that\n\t  they stay consistent (Reuben Thomas)\n\n2007-10-20  3:06 Christos Zoulas <christos@astron.com>\n\n\t* typo in comment, missing ifdef QUICK, remove unneeded code\n\t\t(Charles Longeau)\n\n2007-10-17  3:33 Christos Zoulas <christos@astron.com>\n\n\t* Fix problem printing -\\012 in some entries\n\n\t* Separate magic type and encoding flags (Reuben Thomas)\n\n2007-10-09  3:55 Christos Zoulas <christos@astron.com>\n\n\t* configure fix for int64 and strndup (Reuben Thomas)\n\n2007-09-26  4:45 Christos Zoulas <christos@astron.com>\n\n\t* Add magic_descriptor() function.\n\n\t* Fix regression in elf reading code where the core name was\n\t  not being printed.\n\n\t* Don't convert NUL's to spaces in {l,b}estring16 (Daniel Dawson)\n\n2007-08-19  6:30 Christos Zoulas <christos@astron.com>\n\n\t* Make mime format consistent so that it can\n\t  be easily parsed:\n\t      mimetype [charset=character-set] [encoding=encoding-mime-type]\n\n\t  Remove spurious extra text from some MIME type printouts\n\t  (mostly in is_tar).\n\n\t  Fix one case where -i produced nothing at all (for a 1-byte file,\n\t  which is now classed as application/octet-stream).\n\n\t  Remove 7/8bit classifications, since they were arbitrary\n\t  and not based on the file data.\n\n\t  This work was done by Reuben Thomas\n\n2007-05-24 10:00 Christos Zoulas <christos@astron.com>\n\n\t* Fix another integer overflow (Colin Percival)\n\n2007-03-26 13:58 Christos Zoulas <christos@astron.com>\n\n\t* make sure that all of struct magic_set is initialized appropriately\n\t  (Brett)\n\n2007-03-25 17:44 Christos Zoulas <christos@astron.com>\n\n\t* reset left bytes in the buffer (Dmitry V. Levin)\n\n\t* compilation failed with COMPILE_ONLY and ENABLE_CONDITIONALS\n\t  (Peter Avalos)\n\n2007-03-15 10:51 Christos Zoulas <christos@astron.com>\n\n\t* fix fortran and nroff reversed tests (Dmitry V. Levin)\n\n\t* fix exclude option (Dmitry V. Levin)\n\n2007-02-08 17:30 Christos Zoulas <christos@astron.com>\n\n\t* fix integer underflow in file_printf which can lead to\n\t  to exploitable heap overflow (Jean-Sebastien Guay-Lero)\n\n2007-02-05 11:35 Christos Zoulas <christos@astron.com>\n\n\t* make socket/pipe reading more robust\n\n2007-01-25 16:01 Christos Zoulas <christos@astron.com>\n\n\t* Centralize all the tests in file_buffer.\n\n\t* Add exclude flag.\n\n2007-01-18 05:29 Anon Ymous <do@not.spam.me>\n\n\t* Move the \"type\" detection code from parse() into its own table\n\t  driven routine.  This avoids maintaining multiple lists in\n\t  file.h.\n\n\t* Add an optional conditional field (ust before the type field).\n\t  This code is wrapped in \"#ifdef ENABLE_CONDITIONALS\" as it is\n\t  likely to go away.\n\n2007-01-16 23:24 Anon Ymous <do@not.spam.me>\n\n\t* Fix an initialization bug in check_mem().\n\n2007-01-16 14:58 Anon Ymous <do@not.spam.me>\n\n\t* Add a \"default\" type to print a message if nothing previously\n\t  matched at that level or since the last default at that\n\t  level.  This is useful for setting up switch-like statements.\n\t  It can also be used to do if/else constructions without a\n\t  redundant second test.\n\n\t* Fix the \"x\" special case test so that one can test for that\n\t  string with \"=x\".\n\n\t* Allow \"search\" to search the entire buffer if the \"/N\"\n\t  search count is missing.\n\n\t* Make \"regex\" work!  It now starts its search at the\n\t  specified offset and takes an (optional) \"/N\" line count to\n\t  specify the search range; otherwise it searches to the end\n\t  of the file.  The match is now grabbed correctly for format\n\t  strings and the offset set to the end of the match.\n\n\t* Add a \"/s\" flag to \"regex\" and \"search\" to set the offset to\n\t  the start of the match.  By default the offset is set to the\n\t  end of the match, as it is with other tests.  This is mostly\n\t  useful for \"regex\".\n\n\t* Make \"search\", \"string\" and \"pstring\" use the same\n\t  file_strncmp() routine so that they support the same flags;\n\t  \"bestring16\" and \"lestring16\" call the same routine, but\n\t  with flags = 0.  Also add a \"/C\" flag (in analogy to \"/c\")\n\t  to ignore the case on uppercase (lowercase) characters in\n\t  the test string.\n\n\t* Strict adherence to C style string escapes.  A warnings are\n\t  printed when compiling.  Note: previously \"\\a\" was\n\t  incorrectly translated to 'a' instead of an <alert> (i.e.,\n\t  BELL, typically 0x07).\n\n\t* Make this compile with \"-Wall -Wextra\" and all the warning\n\t  flags used with WARNS=4 in the NetBSD source.  Also make it\n\t  pass lint.\n\n\t* Many \"cleanups\" and hopefully not too many new bugs!\n\n2007-01-16 14:56 Anon Ymous <do@not.spam.me>\n\n\t* make several more files compile with gcc warnings\n\t  on and also make them pass lint.\n\n2007-01-16 14:54 Anon Ymous <do@not.spam.me>\n\n\t* fix a puts()/putc() usage goof in file.c\n\n\t* make file.c compile with gcc warnings and pass lint\n\n2006-12-11 16:49 Christos Zoulas <christos@astron.com>\n\n\t* fix byteswapping issue\n\n\t* report the number of bytes we tried to\n\t  allocate when allocation fails\n\n\t* add a few missed cases in the strength routine\n\n2006-12-08 16:32 Christos Zoulas <christos@astron.com>\n\n\t* store and print the line number of the magic\n\t  entry for debugging.\n\n\t* if the magic entry did not print anything,\n\t  don't treat it as a match\n\n\t* change the magic strength algorithm to take\n\t  into account the relationship op.\n\n\t* fix a bug in search where we could accidentally\n\t  return a match.\n\n\t* propagate the error return from match to\n\t  file_softmagic.\n\n2006-11-25 13:35 Christos Zoulas <christos@astron.com>\n\n\t* Don't store the current offset in the magic\n\t  struct, because it needs to be restored and\n\t  it was not done properly all the time. Bug\n\t  found by: Arkadiusz Miskiewicz\n\n\t* Fix problem in the '\\0' separator; and don't\n\t  print it as an additional separator; print\n\t  it as the only separator.\n\n2006-11-17 10:51 Christos Zoulas <christos@astron.com>\n\n\t* Added a -0 option to print a '\\0' separator\n\t  Etienne Buira <etienne.buira@free.fr>\n\n2006-10-31 15:14 Christos Zoulas <christos@astron.com>\n\n\t* Check offset before copying (Mike Frysinger)\n\n\t* merge duplicated code\n\n\t* add quad date support\n\n\t* make sure that we nul terminate desc (Ryoji Kanai)\n\n\t* don't process elf notes multiple times\n\n\t* allow -z to report empty compressed files\n\n\t* use calloc to initialize the ascii buffers (Jos van den Oever)\n\n2006-06-08 11:11 Christos Zoulas <christos@astron.com>\n\n\t* QNX fixes (Mike Gorchak)\n\n\t* Add quad support.\n\n\t* FIFO checks (Dr. Werner Fink)\n\n\t* Linux ELF fixes (Dr. Werner Fink)\n\n\t* Magic format checks (Dr. Werner Fink)\n\n\t* Magic format function improvent (Karl Chen)\n\n2006-05-03 11:11 Christos Zoulas <christos@astron.com>\n\n\t* Pick up some elf changes and some constant fixes from SUSE\n\n\t* Identify gnu tar vs. posix tar\n\n\t* When keep going, don't print spurious newlines (Radek Vokal)\n\n2006-04-01 12:02 Christos Zoulas <christos@astron.com>\n\n\t* Use calloc instead of malloc (Mike Frysinger)\n\n\t* Fix configure script to detect wctypes.h (Mike Frysinger)\n\n2006-03-02 16:06 Christos Zoulas <christos@astron.com>\n\n\t* Print empty if the file is (Mike Frysinger)\n\n\t* Don't try to read past the end of the buffer (Mike Frysinger)\n\n\t* Sort magic entries by strength [experimental]\n\n2005-11-29 13:26 Christos Zoulas <christos@astron.com>\n\n\t* Use iswprint() to convert the output string.\n\t    (Bastien Nocera)\n\n2005-10-31 8:54 Christos Zoulas <christos@astron.com>\n\n\t* Fix regression where the core info was not completely processed\n\t    (Radek Vokal)\n\n2005-10-20 11:15 Christos Zoulas <christos@astron.com>\n\n\t* Middle Endian magic (Diomidis Spinellis)\n\n2005-10-17 11:15 Christos Zoulas <christos@astron.com>\n\n\t* Open with O_BINARY for CYGWIN (Corinna Vinschen)\n\n\t* Don't close stdin (Arkadiusz Miskiewicz)\n\n\t* Look for note sections in non executables.\n\n2005-09-20 13:33 Christos Zoulas <christos@astron.com>\n\n\t* Don't print SVR4 Style in core files multiple times\n\t    (Radek Vokal)\n\n2005-08-27 04:09 Christos Zoulas <christos@astron.com>\n\n\t* Cygwin changes Corinna Vinschen\n\n2005-08-18 09:53 Christos Zoulas <christos@astron.com>\n\n\t* Remove erroreous mention of /etc/magic in the file man page\n\t  This is gentoo bug 101639. (Mike Frysinger)\n\n\t* Cross-compile support and detection (Mike Frysinger)\n\n2005-08-12 10:17 Christos Zoulas <christos@astron.com>\n\n\t* Add -h flag and dereference symlinks if POSIXLY_CORRECT\n\t  is set.\n\n2005-07-29 13:57 Christos Zoulas <christos@astron.com>\n\n\t* Avoid search and regex buffer overflows (Kelledin)\n\n2005-07-12 11:48 Christos Zoulas <christos@astron.com>\n\n\t* Provide stub implementations for {v,}nsprintf() for older\n\t  OS's that don't have them.\n\t* Change mbstate_t autoconf detection macro from AC_MBSTATE_T\n\t  to AC_TYPE_MBSTATE_T.\n\n2005-06-25 11:48 Christos Zoulas <christos@astron.com>\n\n\t* Dynamically allocate the string buffers and make the\n\t  default read size 256K.\n\n2005-06-01 00:00 Joerg Sonnenberger <joerg@britannica.bec.de>\n\n\t* Dragonfly ELF note support\n\n2005-03-14 00:00 Giuliano Bertoletti <gb@symbolic.it>\n\n\t* Avoid NULL pointer dereference in time conversion.\n\n2005-03-06 00:00  Joerg Walter <jwalt@mail.garni.ch>\n\n\t* Add indirect magic offset support, and search mode.\n\n2005-01-12 00:00  Stepan Kasal  <kasal@ucw.cz>\n\n\t* src/ascmagic.c (file_ascmagic): Fix three bugs about text files:\n\t  If a CRLF text file happens to have CR at offset HOWMANY - 1\n\t  (currently 0xffff), it should not be counted as CR line\n\t  terminator.\n\t  If a line has length exactly MAXLINELEN, it should not yet be\n\t  treated as a ``very long line'', as MAXLINELEN is ``longest sane\n\t  line length''.\n\t  With CRLF, the line length was not computed correctly, and even\n\t  lines of length MAXLINELEN - 1 were treated as ``very long''.\n\n2004-12-07 14:15  Christos Zoulas  <christos@astron.com>\n\n\t* bzip2 needs a lot of input buffer space on some files\n\t  before it can begin uncompressing. This makes file -z\n\t  fail on some bz2 files. Fix it by giving it a copy of\n\t  the file descriptor to read as much as it wants if we\n\t  have access to it. <christos@astron.com>\n\n2004-11-24 12:39  Christos Zoulas  <christos@astron.com>\n\n\t* Stack smash fix, and ELF more conservative reading.\n\t  Jakub Bogusz <qboosh@pld-linux.org>\n\n2004-11-20 18:50  Christos Zoulas  <christos@astron.com>\n\n\t* New FreeBSD version parsing code:\n\t  Jon Noack <noackjr@alumni.rice.edu>\n\n\t* Hackish support for ucs16 strings <christos@astron.com>\n\n2004-11-13 03:07  Christos Zoulas  <christos@astron.com>\n\n\t* print the file name and line number in syntax errors.\n\n2004 10-12 10:50  Christos Zoulas  <christos@astron.com>\n\n\t* Fix stack overwriting on 0 length strings: Tim Waugh\n\t    <twaugh@redhat.com> Ned Ludd <solar@gentoo.org>\n\n2004-09-27 11:30  Christos Zoulas  <christos@astron.com>\n\n\t* Remove 3rd and 4th copyright clause; approved by Ian Darwin.\n\n\t* Fix small memory leaks; caught by: Tamas Sarlos\n\t    <stamas@csillag.ilab.sztaki.hu>\n\n2004-07-24 16:33  Christos Zoulas  <christos@astron.com>\n\n\t* magic.mime update Danny Milosavljevic <danny.milo@gmx.net>\n\n\t* FreeBSD version update Oliver Eikemeier <eikemeier@fillmore-labs.com>\n\n\t* utime/utimes detection Ian Lance Taylor <ian@wasabisystems.com>\n\n  \t* errors reading elf magic Jakub Bogusz <qboosh@pld-linux.org>\n\n2004-04-12 10:55  Christos Zoulas  <christos@astron.com>\n\n\t* make sure that magic formats match magic types during compilation\n\n\t* fix broken sgi magic file\n\n2004-04-06 20:36  Christos Zoulas  <christos@astron.com>\n\n\t* detect present of mbstate_t Petter Reinholdtsen <pere@hungry.com>\n\n\t* magic fixes\n\n2004-03-22 15:25  Christos Zoulas  <christos@astron.com>\n\n\t* Lots of mime fixes\n\t  (Joerg Ostertag) <ostertag@rechengilde.de>\n\n\t* FreeBSD ELF version handling\n\t  (Edwin Groothuis) <edwin@mavetju.org>\n\n\t* correct cleanup in all cases; don't just close the file.\n\t  (Christos Zoulas) <christos@astron.com>\n\n\t* add gettext message catalogue support\n\t  (Michael Piefel) <piefel@debian.org>\n\n\t* better printout for unreadable files\n\t  (Michael Piefel) <piefel@debian.org>\n\n\t* compensate for missing MAXPATHLEN\n\t  (Michael Piefel) <piefel@debian.org>\n\n\t* add wide character string length computation\n\t  (Michael Piefel) <piefel@debian.org>\n\n\t* Avoid infinite loops caused by bad elf alignments\n\t  or name and description note sizes. Reported by\n\t  (Mikael Magnusson) <mmikael@comhem.se>\n\n2004-03-09 13:55  Christos Zoulas  <christos@astron.com>\n\n\t* Fix possible memory leak on error and add missing regfree\n\t  (Dmitry V. Levin) <ldv@altlinux.org>\n\n2003-12-23 12:12  Christos Zoulas  <christos@astron.com>\n\n\t* fix -k flag (Maciej W. Rozycki)\n\n2003-11-18 14:10  Christos Zoulas  <christos@astron.com>\n\n\t* Try to give us much info as possible on corrupt elf files.\n\t  (Willy Tarreau) <willy@w.ods.org>\n\t* Updated python bindings (Brett Funderburg)\n\t   <brettf@deepfile.com>\n\n2003-11-11 15:03  Christos Zoulas  <christos@astron.com>\n\n\t* Include file.h first, because it includes config.h\n\t  breaks largefile test macros otherwise.\n\t  (Paul Eggert <eggert@CS.UCLA.EDU> via\n\t   Lars Hecking <lhecking@nmrc.ie>)\n\n2003-10-14 21:39  Christos Zoulas  <christos@astron.com>\n\n\t* Python bindings (Brett Funderburg) <brettf@deepfile.com>\n\t* Don't lookup past the end of the buffer\n\t  (Chad Hanson) <chanson@tcs-sec.com>\n\t* Add MAGIC_ERROR and api on magic_errno()\n\n2003-10-08 12:40  Christos Zoulas  <christos@astron.com>\n\n\t* handle error conditions from compile as fatal\n\t  (Antti Kantee) <pooka@netbsd.org>\n\t* handle magic filename parsing sanely\n\t* more magic fixes.\n\t* fix a memory leak (Illes Marton) <illes.marton@balabit.hu>\n\t* describe magic file handling\n\t  (Bryan Henderson) <bryanh@giraffe-data.com>\n\n2003-09-12 15:09  Christos Zoulas  <christos@astron.com>\n\n\t* update magic files.\n\t* remove largefile support from file.h; it breaks things on most OS's\n\n2003-08-10 10:25  Christos Zoulas  <christos@astron.com>\n\n\t* fix unmapping'ing of mmaped files.\n\n2003-07-10 12:03  Christos Zoulas  <christos@astron.com>\n\n\t* don't exit with -1 on error; always exit 1 (Marty Leisner)\n\t* restore utimes code.\n\n2003-06-10 17:03  Christos Zoulas  <christos@astron.com>\n\n\t* make sure we don't access uninitialized memory.\n\t* pass lint\n\t* #ifdef __cplusplus in magic.h\n\n2003-05-25 19:23  Christos Zoulas  <christos@astron.com>\n\n\t* rename cvs magic file to revision to deal with\n\t  case insensitive filesystems.\n\n2003-05-23 17:03  Christos Zoulas  <christos@astron.com>\n\n\t* documentation fixes from Michael Piefel <piefel@debian.org>\n\t* magic fixes (various)\n\t* revert basename magic in .mgc name determination\n\t* buffer protection in uncompress,\n\t  signness issues,\n\t  close files\n\t  Maciej W. Rozycki <macro@ds2.pg.gda.pl\n\n2003-04-21 20:12  Christos Zoulas  <christos@astron.com>\n\n\t* fix zsh magic\n\n2003-04-04 16:59  Christos Zoulas  <christos@astron.com>\n\n\t* fix operand sort order in string.\n\n2003-04-02 17:30  Christos Zoulas  <christos@astron.com>\n\n\t* cleanup namespace in magic.h\n\n2003-04-02 13:50  Christos Zoulas  <christos@astron.com>\n\n\t* Magic additions (Alex Ott)\n\t* Fix bug that broke VPATH compilation (Peter Breitenlohner)\n\n2003-03-28 16:03  Christos Zoulas  <christos@astron.com>\n\n\t* remove packed attribute from magic struct.\n\t* make the magic struct properly aligned.\n\t* bump version number of compiled files to 2.\n\n2003-03-27 13:10  Christos Zoulas  <christos@astron.com>\n\n\t* separate tar detection and run it before softmagic.\n\t* fix reversed symlink test.\n\t* fix version printing.\n\t* make separator a string instead of a char.\n\t* update manual page and sort options.\n\n2003-03-26 11:00  Christos Zoulas  <christos@astron.com>\n\n\t* Pass lint\n\t* make NULL in magic_file mean stdin\n\t* Fix \"-\" argument to file to pass NULL to magic_file\n\t* avoid pointer casts by using memcpy\n\t* rename magic_buf -> magic_buffer\n\t* keep only the first error\n\t* manual page: new sentence, new line\n\t* fix typo in api function (magic_buf -> magic_buffer)\n", ".\\\" $File: magic.man,v 1.82 2014/05/30 16:51:23 christos Exp $\n.Dd June 3, 2014\n.Dt MAGIC __FSECTION__\n.Os\n.\\\" install as magic.4 on USG, magic.5 on V7, Berkeley and Linux systems.\n.Sh NAME\n.Nm magic\n.Nd file command's magic pattern file\n.Sh DESCRIPTION\nThis manual page documents the format of the magic file as\nused by the\n.Xr file __CSECTION__\ncommand, version __VERSION__.\nThe\n.Xr file __CSECTION__\ncommand identifies the type of a file using,\namong other tests,\na test for whether the file contains certain\n.Dq \"magic patterns\" .\nThe file\n.Pa __MAGIC__\nspecifies what patterns are to be tested for, what message or\nMIME type to print if a particular pattern is found,\nand additional information to extract from the file.\n.Pp\nEach line of the file specifies a test to be performed.\nA test compares the data starting at a particular offset\nin the file with a byte value, a string or a numeric value.\nIf the test succeeds, a message is printed.\nThe line consists of the following fields:\n.Bl -tag -width \".Dv message\"\n.It Dv offset\nA number specifying the offset, in bytes, into the file of the data\nwhich is to be tested.\n.It Dv type\nThe type of the data to be tested.\nThe possible values are:\n.Bl -tag -width \".Dv lestring16\"\n.It Dv byte\nA one-byte value.\n.It Dv short\nA two-byte value in this machine's native byte order.\n.It Dv long\nA four-byte value in this machine's native byte order.\n.It Dv quad\nAn eight-byte value in this machine's native byte order.\n.It Dv float\nA 32-bit single precision IEEE floating point number in this machine's native byte order.\n.It Dv double\nA 64-bit double precision IEEE floating point number in this machine's native byte order.\n.It Dv string\nA string of bytes.\nThe string type specification can be optionally followed\nby /[WwcCtbT]*.\nThe\n.Dq W\nflag compacts whitespace in the target, which must\ncontain at least one whitespace character.\nIf the magic has\n.Dv n\nconsecutive blanks, the target needs at least\n.Dv n\nconsecutive blanks to match.\nThe\n.Dq w\nflag treats every blank in the magic as an optional blank.\nThe\n.Dq c\nflag specifies case insensitive matching: lower case\ncharacters in the magic match both lower and upper case characters in the\ntarget, whereas upper case characters in the magic only match upper case\ncharacters in the target.\nThe\n.Dq C\nflag specifies case insensitive matching: upper case\ncharacters in the magic match both lower and upper case characters in the\ntarget, whereas lower case characters in the magic only match upper case\ncharacters in the target.\nTo do a complete case insensitive match, specify both\n.Dq c\nand\n.Dq C .\nThe\n.Dq t\nflag forces the test to be done for text files, while the\n.Dq b\nflag forces the test to be done for binary files.\nThe\n.Dq T\nflag causes the string to be trimmed, i.e. leading and trailing whitespace\nis deleted before the string is printed.\n.It Dv pstring\nA Pascal-style string where the first byte/short/int is interpreted as the\nunsigned length.\nThe length defaults to byte and can be specified as a modifier.\nThe following modifiers are supported:\n.Bl -tag -compact -width B\n.It B\nA byte length (default).\n.It H\nA 2 byte big endian length.\n.It h\nA 2 byte big little length.\n.It L\nA 4 byte big endian length.\n.It l\nA 4 byte big little length.\n.It J\nThe length includes itself in its count.\n.El\nThe string is not NUL terminated.\n.Dq J\nis used rather than the more\nvaluable\n.Dq I\nbecause this type of length is a feature of the JPEG\nformat.\n.It Dv date\nA four-byte value interpreted as a UNIX date.\n.It Dv qdate\nA eight-byte value interpreted as a UNIX date.\n.It Dv ldate\nA four-byte value interpreted as a UNIX-style date, but interpreted as\nlocal time rather than UTC.\n.It Dv qldate\nAn eight-byte value interpreted as a UNIX-style date, but interpreted as\nlocal time rather than UTC.\n.It Dv qwdate\nAn eight-byte value interpreted as a Windows-style date.\n.It Dv beid3\nA 32-bit ID3 length in big-endian byte order.\n.It Dv beshort\nA two-byte value in big-endian byte order.\n.It Dv belong\nA four-byte value in big-endian byte order.\n.It Dv bequad\nAn eight-byte value in big-endian byte order.\n.It Dv befloat\nA 32-bit single precision IEEE floating point number in big-endian byte order.\n.It Dv bedouble\nA 64-bit double precision IEEE floating point number in big-endian byte order.\n.It Dv bedate\nA four-byte value in big-endian byte order,\ninterpreted as a Unix date.\n.It Dv beqdate\nAn eight-byte value in big-endian byte order,\ninterpreted as a Unix date.\n.It Dv beldate\nA four-byte value in big-endian byte order,\ninterpreted as a UNIX-style date, but interpreted as local time rather\nthan UTC.\n.It Dv beqldate\nAn eight-byte value in big-endian byte order,\ninterpreted as a UNIX-style date, but interpreted as local time rather\nthan UTC.\n.It Dv beqwdate\nAn eight-byte value in big-endian byte order,\ninterpreted as a Windows-style date.\n.It Dv bestring16\nA two-byte unicode (UCS16) string in big-endian byte order.\n.It Dv leid3\nA 32-bit ID3 length in little-endian byte order.\n.It Dv leshort\nA two-byte value in little-endian byte order.\n.It Dv lelong\nA four-byte value in little-endian byte order.\n.It Dv lequad\nAn eight-byte value in little-endian byte order.\n.It Dv lefloat\nA 32-bit single precision IEEE floating point number in little-endian byte order.\n.It Dv ledouble\nA 64-bit double precision IEEE floating point number in little-endian byte order.\n.It Dv ledate\nA four-byte value in little-endian byte order,\ninterpreted as a UNIX date.\n.It Dv leqdate\nAn eight-byte value in little-endian byte order,\ninterpreted as a UNIX date.\n.It Dv leldate\nA four-byte value in little-endian byte order,\ninterpreted as a UNIX-style date, but interpreted as local time rather\nthan UTC.\n.It Dv leqldate\nAn eight-byte value in little-endian byte order,\ninterpreted as a UNIX-style date, but interpreted as local time rather\nthan UTC.\n.It Dv leqwdate\nAn eight-byte value in little-endian byte order,\ninterpreted as a Windows-style date.\n.It Dv lestring16\nA two-byte unicode (UCS16) string in little-endian byte order.\n.It Dv melong\nA four-byte value in middle-endian (PDP-11) byte order.\n.It Dv medate\nA four-byte value in middle-endian (PDP-11) byte order,\ninterpreted as a UNIX date.\n.It Dv meldate\nA four-byte value in middle-endian (PDP-11) byte order,\ninterpreted as a UNIX-style date, but interpreted as local time rather\nthan UTC.\n.It Dv indirect\nStarting at the given offset, consult the magic database again.\n.It Dv name\nDefine a\n.Dq named\nmagic instance that can be called from another\n.Dv use\nmagic entry, like a subroutine call.\nNamed instance direct magic offsets are relative to the offset of the\nprevious matched entry, but indirect offsets are relative to the beginning\nof the file as usual.\nNamed magic entries always match.\n.It Dv use\nRecursively call the named magic starting from the current offset.\nIf the name of the referenced begins with a\n.Dv ^\nthen the endianness of the magic is switched; if the magic mentioned\n.Dv leshort\nfor example,\nit is treated as\n.Dv beshort\nand vice versa.\nThis is useful to avoid duplicating the rules for different endianness.\n.It Dv regex\nA regular expression match in extended POSIX regular expression syntax\n(like egrep).\nRegular expressions can take exponential time to process, and their\nperformance is hard to predict, so their use is discouraged.\nWhen used in production environments, their performance\nshould be carefully checked.\nThe size of the string to search should also be limited by specifying\n.Dv /<length> ,\nto avoid performance issues scanning long files.\nThe type specification can also be optionally followed by\n.Dv /[c][s] .\nThe\n.Dq c\nflag makes the match case insensitive, while the\n.Dq s\nflag update the offset to the start offset of the match, rather than the end.\n.Dv ^\nand\n.Dv $\nmatch the beginning and end of individual lines, respectively,\nnot beginning and end of file.\n.It Dv search\nA literal string search starting at the given offset.\nThe same modifier flags can be used as for string patterns.\nThe search expression must contain the range in the form\n.Dv /number,\nthat is the number of positions at which the match will be\nattempted, starting from the start offset.\nThis is suitable for\nsearching larger binary expressions with variable offsets, using\n.Dv \\e\nescapes for special characters.\nThe order of modifier and number is not relevant.\n.It Dv default\nThis is intended to be used with the test\n.Em x\n(which is always true) and it has no type.\nIt matches when no other test at that continuation level has matched before.\nClearing that matched tests for a continuation level, can be done using the\n.Dv clear\ntest.\n.It Dv clear\nThis test is always true and clears the match flag for that continuation level.\nIt is intended to be used with the\n.Dv default\ntest.\n.El\n.Pp\nFor compatibility with the Single\n.Ux\nStandard, the type specifiers\n.Dv dC\nand\n.Dv d1\nare equivalent to\n.Dv byte ,\nthe type specifiers\n.Dv uC\nand\n.Dv u1\nare equivalent to\n.Dv ubyte ,\nthe type specifiers\n.Dv dS\nand\n.Dv d2\nare equivalent to\n.Dv short ,\nthe type specifiers\n.Dv uS\nand\n.Dv u2\nare equivalent to\n.Dv ushort ,\nthe type specifiers\n.Dv dI ,\n.Dv dL ,\nand\n.Dv d4\nare equivalent to\n.Dv long ,\nthe type specifiers\n.Dv uI ,\n.Dv uL ,\nand\n.Dv u4\nare equivalent to\n.Dv ulong ,\nthe type specifier\n.Dv d8\nis equivalent to\n.Dv quad ,\nthe type specifier\n.Dv u8\nis equivalent to\n.Dv uquad ,\nand the type specifier\n.Dv s\nis equivalent to\n.Dv string .\nIn addition, the type specifier\n.Dv dQ\nis equivalent to\n.Dv quad\nand the type specifier\n.Dv uQ\nis equivalent to\n.Dv uquad .\n.Pp\nEach top-level magic pattern (see below for an explanation of levels)\nis classified as text or binary according to the types used.\nTypes\n.Dq regex\nand\n.Dq search\nare classified as text tests, unless non-printable characters are used\nin the pattern.\nAll other tests are classified as binary.\nA top-level\npattern is considered to be a test text when all its patterns are text\npatterns; otherwise, it is considered to be a binary pattern.\nWhen\nmatching a file, binary patterns are tried first; if no match is\nfound, and the file looks like text, then its encoding is determined\nand the text patterns are tried.\n.Pp\nThe numeric types may optionally be followed by\n.Dv \\*[Am]\nand a numeric value,\nto specify that the value is to be AND'ed with the\nnumeric value before any comparisons are done.\nPrepending a\n.Dv u\nto the type indicates that ordered comparisons should be unsigned.\n.It Dv test\nThe value to be compared with the value from the file.\nIf the type is\nnumeric, this value\nis specified in C form; if it is a string, it is specified as a C string\nwith the usual escapes permitted (e.g. \\en for new-line).\n.Pp\nNumeric values\nmay be preceded by a character indicating the operation to be performed.\nIt may be\n.Dv = ,\nto specify that the value from the file must equal the specified value,\n.Dv \\*[Lt] ,\nto specify that the value from the file must be less than the specified\nvalue,\n.Dv \\*[Gt] ,\nto specify that the value from the file must be greater than the specified\nvalue,\n.Dv \\*[Am] ,\nto specify that the value from the file must have set all of the bits\nthat are set in the specified value,\n.Dv ^ ,\nto specify that the value from the file must have clear any of the bits\nthat are set in the specified value, or\n.Dv ~ ,\nthe value specified after is negated before tested.\n.Dv x ,\nto specify that any value will match.\nIf the character is omitted, it is assumed to be\n.Dv = .\nOperators\n.Dv \\*[Am] ,\n.Dv ^ ,\nand\n.Dv ~\ndon't work with floats and doubles.\nThe operator\n.Dv !\\&\nspecifies that the line matches if the test does\n.Em not\nsucceed.\n.Pp\nNumeric values are specified in C form; e.g.\n.Dv 13\nis decimal,\n.Dv 013\nis octal, and\n.Dv 0x13\nis hexadecimal.\n.Pp\nFor string values, the string from the\nfile must match the specified string.\nThe operators\n.Dv = ,\n.Dv \\*[Lt]\nand\n.Dv \\*[Gt]\n(but not\n.Dv \\*[Am] )\ncan be applied to strings.\nThe length used for matching is that of the string argument\nin the magic file.\nThis means that a line can match any non-empty string (usually used to\nthen print the string), with\n.Em \\*[Gt]\\e0\n(because all non-empty strings are greater than the empty string).\n.Pp\nDates are treated as numerical values in the respective internal\nrepresentation.\n.Pp\nThe special test\n.Em x\nalways evaluates to true.\n.It Dv message\nThe message to be printed if the comparison succeeds.\nIf the string contains a\n.Xr printf 3\nformat specification, the value from the file (with any specified masking\nperformed) is printed using the message as the format string.\nIf the string begins with\n.Dq \\eb ,\nthe message printed is the remainder of the string with no whitespace\nadded before it: multiple matches are normally separated by a single\nspace.\n.El\n.Pp\nAn APPLE 4+4 character APPLE creator and type can be specified as:\n.Bd -literal -offset indent\n!:apple\tCREATYPE\n.Ed\n.Pp\nA MIME type is given on a separate line, which must be the next\nnon-blank or comment line after the magic line that identifies the\nfile type, and has the following format:\n.Bd -literal -offset indent\n!:mime\tMIMETYPE\n.Ed\n.Pp\ni.e. the literal string\n.Dq !:mime\nfollowed by the MIME type.\n.Pp\nAn optional strength can be supplied on a separate line which refers to\nthe current magic description using the following format:\n.Bd -literal -offset indent\n!:strength OP VALUE\n.Ed\n.Pp\nThe operand\n.Dv OP\ncan be:\n.Dv + ,\n.Dv - ,\n.Dv * ,\nor\n.Dv /\nand\n.Dv VALUE\nis a constant between 0 and 255.\nThis constant is applied using the specified operand\nto the currently computed default magic strength.\n.Pp\nSome file formats contain additional information which is to be printed\nalong with the file type or need additional tests to determine the true\nfile type.\nThese additional tests are introduced by one or more\n.Em \\*[Gt]\ncharacters preceding the offset.\nThe number of\n.Em \\*[Gt]\non the line indicates the level of the test; a line with no\n.Em \\*[Gt]\nat the beginning is considered to be at level 0.\nTests are arranged in a tree-like hierarchy:\nif the test on a line at level\n.Em n\nsucceeds, all following tests at level\n.Em n+1\nare performed, and the messages printed if the tests succeed, until a line\nwith level\n.Em n\n(or less) appears.\nFor more complex files, one can use empty messages to get just the\n\"if/then\" effect, in the following way:\n.Bd -literal -offset indent\n0      string   MZ\n\\*[Gt]0x18  leshort  \\*[Lt]0x40   MS-DOS executable\n\\*[Gt]0x18  leshort  \\*[Gt]0x3f   extended PC executable (e.g., MS Windows)\n.Ed\n.Pp\nOffsets do not need to be constant, but can also be read from the file\nbeing examined.\nIf the first character following the last\n.Em \\*[Gt]\nis a\n.Em \\&(\nthen the string after the parenthesis is interpreted as an indirect offset.\nThat means that the number after the parenthesis is used as an offset in\nthe file.\nThe value at that offset is read, and is used again as an offset\nin the file.\nIndirect offsets are of the form:\n.Em (( x [.[bislBISL]][+\\-][ y ]) .\nThe value of\n.Em x\nis used as an offset in the file.\nA byte, id3 length, short or long is read at that offset depending on the\n.Em [bislBISLm]\ntype specifier.\nThe capitalized types interpret the number as a big endian\nvalue, whereas the small letter versions interpret the number as a little\nendian value;\nthe\n.Em m\ntype interprets the number as a middle endian (PDP-11) value.\nTo that number the value of\n.Em y\nis added and the result is used as an offset in the file.\nThe default type if one is not specified is long.\n.Pp\nThat way variable length structures can be examined:\n.Bd -literal -offset indent\n# MS Windows executables are also valid MS-DOS executables\n0           string  MZ\n\\*[Gt]0x18       leshort \\*[Lt]0x40   MZ executable (MS-DOS)\n# skip the whole block below if it is not an extended executable\n\\*[Gt]0x18       leshort \\*[Gt]0x3f\n\\*[Gt]\\*[Gt](0x3c.l)  string  PE\\e0\\e0  PE executable (MS-Windows)\n\\*[Gt]\\*[Gt](0x3c.l)  string  LX\\e0\\e0  LX executable (OS/2)\n.Ed\n.Pp\nThis strategy of examining has a drawback: You must make sure that\nyou eventually print something, or users may get empty output (like, when\nthere is neither PE\\e0\\e0 nor LE\\e0\\e0 in the above example)\n.Pp\nIf this indirect offset cannot be used directly, simple calculations are\npossible: appending\n.Em [+-*/%\\*[Am]|^]number\ninside parentheses allows one to modify\nthe value read from the file before it is used as an offset:\n.Bd -literal -offset indent\n# MS Windows executables are also valid MS-DOS executables\n0           string  MZ\n# sometimes, the value at 0x18 is less that 0x40 but there's still an\n# extended executable, simply appended to the file\n\\*[Gt]0x18       leshort \\*[Lt]0x40\n\\*[Gt]\\*[Gt](4.s*512) leshort 0x014c  COFF executable (MS-DOS, DJGPP)\n\\*[Gt]\\*[Gt](4.s*512) leshort !0x014c MZ executable (MS-DOS)\n.Ed\n.Pp\nSometimes you do not know the exact offset as this depends on the length or\nposition (when indirection was used before) of preceding fields.\nYou can specify an offset relative to the end of the last up-level\nfield using\n.Sq \\*[Am]\nas a prefix to the offset:\n.Bd -literal -offset indent\n0           string  MZ\n\\*[Gt]0x18       leshort \\*[Gt]0x3f\n\\*[Gt]\\*[Gt](0x3c.l)  string  PE\\e0\\e0    PE executable (MS-Windows)\n# immediately following the PE signature is the CPU type\n\\*[Gt]\\*[Gt]\\*[Gt]\\*[Am]0       leshort 0x14c     for Intel 80386\n\\*[Gt]\\*[Gt]\\*[Gt]\\*[Am]0       leshort 0x184     for DEC Alpha\n.Ed\n.Pp\nIndirect and relative offsets can be combined:\n.Bd -literal -offset indent\n0             string  MZ\n\\*[Gt]0x18         leshort \\*[Lt]0x40\n\\*[Gt]\\*[Gt](4.s*512)   leshort !0x014c MZ executable (MS-DOS)\n# if it's not COFF, go back 512 bytes and add the offset taken\n# from byte 2/3, which is yet another way of finding the start\n# of the extended executable\n\\*[Gt]\\*[Gt]\\*[Gt]\\*[Am](2.s-514) string  LE      LE executable (MS Windows VxD driver)\n.Ed\n.Pp\nOr the other way around:\n.Bd -literal -offset indent\n0                 string  MZ\n\\*[Gt]0x18             leshort \\*[Gt]0x3f\n\\*[Gt]\\*[Gt](0x3c.l)        string  LE\\e0\\e0  LE executable (MS-Windows)\n# at offset 0x80 (-4, since relative offsets start at the end\n# of the up-level match) inside the LE header, we find the absolute\n# offset to the code area, where we look for a specific signature\n\\*[Gt]\\*[Gt]\\*[Gt](\\*[Am]0x7c.l+0x26) string  UPX     \\eb, UPX compressed\n.Ed\n.Pp\nOr even both!\n.Bd -literal -offset indent\n0                string  MZ\n\\*[Gt]0x18            leshort \\*[Gt]0x3f\n\\*[Gt]\\*[Gt](0x3c.l)       string  LE\\e0\\e0 LE executable (MS-Windows)\n# at offset 0x58 inside the LE header, we find the relative offset\n# to a data area where we look for a specific signature\n\\*[Gt]\\*[Gt]\\*[Gt]\\*[Am](\\*[Am]0x54.l-3)  string  UNACE  \\eb, ACE self-extracting archive\n.Ed\n.Pp\nIf you have to deal with offset/length pairs in your file, even the\nsecond value in a parenthesized expression can be taken from the file itself,\nusing another set of parentheses.\nNote that this additional indirect offset is always relative to the\nstart of the main indirect offset.\n.Bd -literal -offset indent\n0                 string       MZ\n\\*[Gt]0x18             leshort      \\*[Gt]0x3f\n\\*[Gt]\\*[Gt](0x3c.l)        string       PE\\e0\\e0 PE executable (MS-Windows)\n# search for the PE section called \".idata\"...\n\\*[Gt]\\*[Gt]\\*[Gt]\\*[Am]0xf4          search/0x140 .idata\n# ...and go to the end of it, calculated from start+length;\n# these are located 14 and 10 bytes after the section name\n\\*[Gt]\\*[Gt]\\*[Gt]\\*[Gt](\\*[Am]0xe.l+(-4)) string       PK\\e3\\e4 \\eb, ZIP self-extracting archive\n.Ed\n.Pp\nIf you have a list of known avalues at a particular continuation level,\nand you want to provide a switch-like default case:\n.Bd -literal -offset indent\n# clear that continuation level match\n\\*[Gt]18\tclear\n\\*[Gt]18\tlelong\t1\tone\n\\*[Gt]18\tlelong\t2\ttwo\n\\*[Gt]18\tdefault\tx\n# print default match\n\\*[Gt]\\*[Gt]18\tlelong\tx\tunmatched 0x%x\n.Ed\n.Sh SEE ALSO\n.Xr file __CSECTION__\n\\- the command that reads this file.\n.Sh BUGS\nThe formats\n.Dv long ,\n.Dv belong ,\n.Dv lelong ,\n.Dv melong ,\n.Dv short ,\n.Dv beshort ,\nand\n.Dv leshort\ndo not depend on the length of the C data types\n.Dv short\nand\n.Dv long\non the platform, even though the Single\n.Ux\nSpecification implies that they do.  However, as OS X Mountain Lion has\npassed the Single\n.Ux\nSpecification validation suite, and supplies a version of\n.Xr file __CSECTION__\nin which they do not depend on the sizes of the C data types and that is\nbuilt for a 64-bit environment in which\n.Dv long\nis 8 bytes rather than 4 bytes, presumably the validation suite does not\ntest whether, for example\n.Dv long\nrefers to an item with the same size as the C data type\n.Dv long .\nThere should probably be\n.Dv type\nnames\n.Dv int8 ,\n.Dv uint8 ,\n.Dv int16 ,\n.Dv uint16 ,\n.Dv int32 ,\n.Dv uint32 ,\n.Dv int64 ,\nand\n.Dv uint64 ,\nand specified-byte-order variants of them,\nto make it clearer that those types have specified widths.\n.\\\"\n.\\\" From: guy@sun.uucp (Guy Harris)\n.\\\" Newsgroups: net.bugs.usg\n.\\\" Subject: /etc/magic's format isn't well documented\n.\\\" Message-ID: <2752@sun.uucp>\n.\\\" Date: 3 Sep 85 08:19:07 GMT\n.\\\" Organization: Sun Microsystems, Inc.\n.\\\" Lines: 136\n.\\\"\n.\\\" Here's a manual page for the format accepted by the \"file\" made by adding\n.\\\" the changes I posted to the S5R2 version.\n.\\\"\n.\\\" Modified for Ian Darwin's version of the file command.\n", "\n#------------------------------------------------------------\n# $File: android,v 1.2 2013/11/05 14:00:25 christos Exp $\n# Various android related magic entries\n#------------------------------------------------------------\n\n# Dalvik .dex format. http://retrodev.com/android/dexformat.html\n# From <mkf@google.com> \"Mike Fleming\"\n# Fixed to avoid regexec 17 errors on some dex files\n# From <diff@lookout.com> \"Tim Strazzere\"\n0\tstring\tdex\\n\n>0\tregex\tdex\\n[0-9]{2}\\0\tDalvik dex file\n>4\tstring\t>000\t\t\tversion %s\n0\tstring\tdey\\n\n>0\tregex\tdey\\n[0-9]{2}\\0\tDalvik dex file (optimized for host)\n>4\tstring\t>000\t\t\tversion %s\n\n# http://android.stackexchange.com/questions/23357/\\\n# is-there-a-way-to-look-inside-and-modify-an-adb-backup-created-file/\\\n# 23608#23608\n0\tstring\tANDROID\\040BACKUP\\n\tAndroid Backup\n>15\tstring\t1\\n\t\t\t\\b, version 1\n>17\tstring\t0\\n\t\t\t\\b, uncompressed\n>17\tstring\t1\\n\t\t\t\\b, compressed\n>19\tstring\tnone\\n\t\t\t\\b, unencrypted\n>19\tstring\tAES-256\\n\t\t\\b, encrypted AES-256\n\n# Android bootimg format\n# From https://android.googlesource.com/\\\n# platform/system/core/+/master/mkbootimg/bootimg.h\n0\t\tstring\tANDROID!\tAndroid bootimg\n>8\t\tlelong\t>0\t\t\t\\b, kernel\n>>12\tlelong\t>0\t\t\t\\b (0x%x)\n>16\t\tlelong\t>0\t\t\t\\b, ramdisk\n>>20\tlelong\t>0\t\t\t\\b (0x%x)\n>24\t\tlelong\t>0\t\t\t\\b, second stage\n>>28\tlelong\t>0\t\t\t\\b (0x%x)\n>36\t\tlelong\t>0\t\t\t\\b, page size: %d\n>38\t\tstring\t>0\t\t\t\\b, name: %s\n>64\t\tstring\t>0\t\t \t\\b, cmdline (%s)\n# Dalvik .dex format. http://retrodev.com/android/dexformat.html\n# From <mkf@google.com> \"Mike Fleming\"\n# Fixed to avoid regexec 17 errors on some dex files\n# From <diff@lookout.com> \"Tim Strazzere\"\n0\tstring\tdex\\n\n>0\tregex\tdex\\n[0-9]{2}\\0\tDalvik dex file\n>4\tstring\t>000\t\t\tversion %s\n0\tstring\tdey\\n\n>0\tregex\tdey\\n[0-9]{2}\\0\tDalvik dex file (optimized for host)\n>4\tstring\t>000\t\t\tversion %s\n\n# http://android.stackexchange.com/questions/23357/\\\n# is-there-a-way-to-look-inside-and-modify-an-adb-backup-created-file/\\\n# 23608#23608\n0\tstring\tANDROID\\040BACKUP\\n\tAndroid Backup\n>15\tstring\t1\\n\t\t\t\\b, version 1\n>17\tstring\t0\\n\t\t\t\\b, uncompressed\n>17\tstring\t1\\n\t\t\t\\b, compressed\n>19\tstring\tnone\\n\t\t\t\\b, unencrypted\n>19\tstring\tAES-256\\n\t\t\\b, encrypted AES-256\n\n# Android bootimg format\n# From https://android.googlesource.com/\\\n# platform/system/core/+/master/mkbootimg/bootimg.h\n0\t\tstring\tANDROID!\tAndroid bootimg\n>8\t\tlelong\t>0\t\t\t\\b, kernel\n>>12\tlelong\t>0\t\t\t\\b (0x%x)\n>16\t\tlelong\t>0\t\t\t\\b, ramdisk\n>>20\tlelong\t>0\t\t\t\\b (0x%x)\n>24\t\tlelong\t>0\t\t\t\\b, second stage\n>>28\tlelong\t>0\t\t\t\\b (0x%x)\n>36\t\tlelong\t>0\t\t\t\\b, page size: %d\n>38\t\tstring\t>0\t\t\t\\b, name: %s\n>64\t\tstring\t>0\t\t \t\\b, cmdline (%s)\n\n# Android Backup archive\n# From: Ariel Shkedi\n# File extension: .ab\n# No mime-type defined\n# URL: https://github.com/android/platform_frameworks_base/blob/\\\n# 0bacfd2ba68d21a68a3df345b830bc2a1e515b5a/services/java/com/\\\n# android/server/BackupManagerService.java#L2367\n# After the header comes a tar file\n# If compressed, the entire tar file is compressed with JAVA deflate\n#\n# Include the version number hardcoded with the magic string to avoid\n# false positives\n0\tstring/b\tANDROID\\ BACKUP\\n1\\n\tAndroid Backup\n>17\tstring\t\t0\\n\t\t\t\\b, Not-Compressed\n>17\tstring\t\t1\\n\t\t\t\\b, Compressed\n# any string as long as it's not the word none (which is matched below)\n>>19    regex/1\t\t\\^([^n\\n]|n[^o]|no[^n]|non[^e]|none.+).*\t\\b, Encrypted (%s)\n>>19\tstring\t\tnone\\n\t\t\t\\b, Not-Encrypted\n# Commented out because they don't seem useful to print\n# (but they are part of the header - the tar file comes after them):\n#>>>&1\t\tregex/1 .*\t\\b, Password salt: %s\n#>>>>&1\t\tregex/1 .*\t\\b, Master salt: %s\n#>>>>>&1\tregex/1 .*\t\\b, PBKDF2 rounds: %s\n#>>>>>>&1\tregex/1 .*\t\\b, IV: %s\n#>>>>>>>&1\tregex/1 .*\t\\b, Key: %s\n", "\n#------------------------------------------------------------------------------\n# $File: fortran,v 1.6 2009/09/19 16:28:09 christos Exp $\n# FORTRAN source\n0\tregex/100\t\\^[Cc][\\ \\t]\tFORTRAN program\n!:mime\ttext/x-fortran\n!:strength - 5\n", "\n#------------------------------------------------------------------------------\n# $File$\n# graphviz:  file(1) magic for http://www.graphviz.org/\n\n# FIXME: These patterns match too generally. For example, the first\n# line matches a LaTeX file containing the word \"graph\" (with a {\n# following later) and the second line matches this file.\n#0\tregex/100\t[\\r\\n\\t\\ ]*graph[\\r\\n\\t\\ ]+.*\\\\{\tgraphviz graph text\n#!:mime\ttext/vnd.graphviz\n#0\tregex/100\t[\\r\\n\\t\\ ]*digraph[\\r\\n\\t\\ ]+.*\\\\{\tgraphviz digraph text\n#!:mime\ttext/vnd.graphviz\n", "#--------------------------------------------\n# marc21: file(1) magic for MARC 21 Format\n#\n# Kevin Ford (kefo@loc.gov)\n# \n# MARC21 formats are for the representation and communication\n# of bibliographic and related information in machine-readable\n# form.  For more info, see http://www.loc.gov/marc/\n\n\n# leader position 20-21 must be 45\n20\tstring\t45\t\n\n# leader starts with 5 digits, followed by codes specific to MARC format\n>0\tregex/1\t(^[0-9]{5})[acdnp][^bhlnqsu-z]\tMARC21 Bibliographic\n!:mime\tapplication/marc\n>0\tregex/1\t(^[0-9]{5})[acdnosx][z]\tMARC21 Authority\n!:mime\tapplication/marc\n>0\tregex/1\t(^[0-9]{5})[cdn][uvxy]\tMARC21 Holdings\n!:mime\tapplication/marc\n0\tregex/1\t(^[0-9]{5})[acdn][w]\tMARC21 Classification\n!:mime\tapplication/marc\n>0\tregex/1\t(^[0-9]{5})[cdn][q]\tMARC21 Community\n!:mime\tapplication/marc\n\n# leader position 22-23, should be \"00\" but is it?\n>0\tregex/1\t(^.{21})([^0]{2})\t(non-conforming)\n!:mime\tapplication/marc\n", "\n#------------------------------------------------------------------------------\n# $File: scientific,v 1.7 2010/09/20 19:19:17 rrt Exp $\n# scientific:  file(1) magic for scientific formats \n#\n# From: Joe Krahn <krahn@niehs.nih.gov>\n\n########################################################\n# CCP4 data and plot files:\n0\tstring\t\tMTZ\\040\t\tMTZ reflection file\n\n92\tstring\t\tPLOT%%84\tPlot84 plotting file\n>52\tbyte\t\t1\t\t, Little-endian\n>55\tbyte\t\t1\t\t, Big-endian\n\n########################################################\n# Electron density MAP/MASK formats\n\n0\tstring\t\tEZD_MAP\tNEWEZD Electron Density Map\n109\tstring\t\tMAP\\040(  Old EZD Electron Density Map\n\n0\tstring/c\t:-)\\040Origin\tBRIX Electron Density Map\n>170\tstring\t\t>0\t, Sigma:%.12s\n#>4\tstring\t\t>0\t%.178s\n#>4\taddr\t\tx\t%.178s\n\n7\tstring\t\t18\\040!NTITLE\tXPLOR ASCII Electron Density Map\n9\tstring\t\t\\040!NTITLE\\012\\040REMARK\tCNS ASCII electron density map\n\n208\tstring\t\tMAP\\040\tCCP4 Electron Density Map\n# Assumes same stamp for float and double (normal case)\n>212\tbyte\t\t17\t\\b, Big-endian\n>212\tbyte\t\t34\t\\b, VAX format\n>212\tbyte\t\t68\t\\b, Little-endian\n>212\tbyte\t\t85\t\\b, Convex native\n\n############################################################\n# X-Ray Area Detector images\n0\tstring\tR-AXIS4\\ \\ \\ \tR-Axis Area Detector Image:\n>796\tlelong\t<20\t\tLittle-endian, IP #%d,\n>>768\tlelong\t>0\t\tSize=%dx\n>>772\tlelong\t>0\t\t\\b%d\n>796\tbelong\t<20\t\tBig-endian, IP #%d,\n>>768\tbelong\t>0\t\tSize=%dx\n>>772\tbelong\t>0\t\t\\b%d\n\n0\tstring\tRAXIS\\ \\ \\ \\ \\ \tR-Axis Area Detector Image, Win32:\n>796\tlelong\t<20\t\tLittle-endian, IP #%d,\n>>768\tlelong\t>0\t\tSize=%dx\n>>772\tlelong\t>0\t\t\\b%d\n>796\tbelong\t<20\t\tBig-endian, IP #%d,\n>>768\tbelong\t>0\t\tSize=%dx\n>>772\tbelong\t>0\t\t\\b%d\n\n\n1028\tstring\tMMX\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\tMAR Area Detector Image,\n>1072\tulong\t>1\t\tCompressed(%d),\n>1100\tulong\t>1\t\t%d headers,\n>1104\tulong\t>0\t\t%d x\n>1108\tulong\t>0\t\t%d,\n>1120\tulong\t>0\t\t%d bits/pixel\n\n# Type: GEDCOM genealogical (family history) data\n# From: Giuseppe Bilotta\n0       search/1/c\t0\\ HEAD         GEDCOM genealogy text\n>&0     search\t\t1\\ GEDC\n>>&0    search\t\t2\\ VERS         version\n>>>&1   string\t\t>\\0\t\t%s\n# From: Phil Endecott <phil05@chezphil.org>\n0\tstring\t\\000\\060\\000\\040\\000\\110\\000\\105\\000\\101\\000\\104\t\tGEDCOM data\n0\tstring\t\\060\\000\\040\\000\\110\\000\\105\\000\\101\\000\\104\\000\t\tGEDCOM data\n0\tstring\t\\376\\377\\000\\060\\000\\040\\000\\110\\000\\105\\000\\101\\000\\104\tGEDCOM data\n0\tstring\t\\377\\376\\060\\000\\040\\000\\110\\000\\105\\000\\101\\000\\104\\000\tGEDCOM data\n\n# PDB: Protein Data Bank files\n# Adam Buchbinder <adam.buchbinder@gmail.com>\n#\n# http://www.wwpdb.org/documentation/format32/sect2.html\n# http://www.ch.ic.ac.uk/chemime/\n#\n# The PDB file format is fixed-field, 80 columns. From the spec:\n#\n# COLS        DATA\n#  1 -  6      \"HEADER\"\n#  11 - 50     String(40)\n#  51 - 59     Date\n#  63 - 66     IDcode\n#\n# Thus, positions 7-10, 60-62 and 67-80 are spaces. The Date must be in the\n# format DD-MMM-YY, e.g., 01-JAN-70, and the IDcode consists of numbers and\n# uppercase letters. However, examples have been seen without the date string,\n# e.g., the example on the chemime site.\n0\tstring\tHEADER\\ \\ \\ \\ \n>&0\tregex/1\t\\^.{40}\n>>&0\tregex/1\t[0-9]{2}-[A-Z]{3}-[0-9]{2}\\ {3}\n>>>&0\tregex/1s\t[A-Z0-9]{4}.{14}$\n>>>>&0\tregex/1\t[A-Z0-9]{4}\tProtein Data Bank data, ID Code %s\n!:mime\tchemical/x-pdb\n>>>>0\tregex/1\t[0-9]{2}-[A-Z]{3}-[0-9]{2}\t\\b, %s\n\n# Type:\tGDSII Stream file\n0\tbelong\t0x00060002\tGDSII Stream file\n>4\tbyte\t0x00\n>>5\tbyte\tx\t\tversion %d.0\n>4\tbyte\t>0x00\t\tversion %d\n>>5\tbyte\tx\t\t\\b.%d\n", "\n#------------------------------------------------------------------------------\n# $File$\n# troff:  file(1) magic for *roff\n#\n# updated by Daniel Quinlan (quinlan@yggdrasil.com)\n\n# troff input\n0\tsearch/1\t.\\\\\"\t\ttroff or preprocessor input text\n!:mime\ttext/troff\n0\tsearch/1\t'\\\\\"\t\ttroff or preprocessor input text\n!:mime\ttext/troff\n0\tsearch/1\t'.\\\\\"\t\ttroff or preprocessor input text\n!:mime\ttext/troff\n0\tsearch/1\t\\\\\"\t\ttroff or preprocessor input text\n!:mime\ttext/troff\n0\tsearch/1\t'''\t\ttroff or preprocessor input text\n!:mime\ttext/troff\n0\tregex/20\t\\^\\\\.[A-Za-z0-9][A-Za-z0-9][\\ \\t]\ttroff or preprocessor input text\n!:mime\ttext/troff\n0\tregex/20\t\\^\\\\.[A-Za-z0-9][A-Za-z0-9]$\ttroff or preprocessor input text\n!:mime\ttext/troff\n\n# ditroff intermediate output text\n0\tsearch/1\tx\\ T\t\tditroff output text\n>4\tsearch/1\tcat\t\tfor the C/A/T phototypesetter\n>4\tsearch/1\tps\t\tfor PostScript\n>4\tsearch/1\tdvi\t\tfor DVI\n>4\tsearch/1\tascii\t\tfor ASCII\n>4\tsearch/1\tlj4\t\tfor LaserJet 4\n>4\tsearch/1\tlatin1\t\tfor ISO 8859-1 (Latin 1)\n>4\tsearch/1\tX75\t\tfor xditview at 75dpi\n>>7\tsearch/1\t-12\t\t(12pt)\n>4\tsearch/1\tX100\t\tfor xditview at 100dpi\n>>8\tsearch/1\t-12\t\t(12pt)\n\n# output data formats\n0\tstring\t\t\\100\\357\tvery old (C/A/T) troff output data\n", "/*\n * Copyright (c) Ian F. Darwin 1986-1995.\n * Software written by Ian F. Darwin and others;\n * maintained 1995-present by Christos Zoulas and others.\n * \n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice immediately at the beginning of the file, without modification,\n *    this list of conditions, and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *  \n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n/*\n * apprentice - make one pass through /etc/magic, learning its secrets.\n */\n\n#include \"file.h\"\n\n#ifndef\tlint\nFILE_RCSID(\"@(#)$File: apprentice.c,v 1.209 2014/05/13 16:42:17 christos Exp $\")\n#endif\t/* lint */\n\n#include \"magic.h\"\n#include <stdlib.h>\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n#ifdef HAVE_STDDEF_H\n#include <stddef.h>\n#endif\n#include <string.h>\n#include <assert.h>\n#include <ctype.h>\n#include <fcntl.h>\n#ifdef QUICK\n#include <sys/mman.h>\n#endif\n#include <dirent.h>\n#if defined(HAVE_LIMITS_H)\n#include <limits.h>\n#endif\n\n#ifndef SSIZE_MAX\n#define MAXMAGIC_SIZE        ((ssize_t)0x7fffffff)\n#else\n#define MAXMAGIC_SIZE        SSIZE_MAX\n#endif\n\n#define\tEATAB {while (isascii((unsigned char) *l) && \\\n\t\t      isspace((unsigned char) *l))  ++l;}\n#define LOWCASE(l) (isupper((unsigned char) (l)) ? \\\n\t\t\ttolower((unsigned char) (l)) : (l))\n/*\n * Work around a bug in headers on Digital Unix.\n * At least confirmed for: OSF1 V4.0 878\n */\n#if defined(__osf__) && defined(__DECC)\n#ifdef MAP_FAILED\n#undef MAP_FAILED\n#endif\n#endif\n\n#ifndef MAP_FAILED\n#define MAP_FAILED (void *) -1\n#endif\n\n#ifndef MAP_FILE\n#define MAP_FILE 0\n#endif\n\n#define ALLOC_CHUNK\t(size_t)10\n#define ALLOC_INCR\t(size_t)200\n\nstruct magic_entry {\n\tstruct magic *mp;\t\n\tuint32_t cont_count;\n\tuint32_t max_count;\n};\n\nstruct magic_entry_set {\n\tstruct magic_entry *me;\n\tuint32_t count;\n\tuint32_t max;\n};\n\nstruct magic_map {\n\tvoid *p;\n\tsize_t len;\n\tstruct magic *magic[MAGIC_SETS];\n\tuint32_t nmagic[MAGIC_SETS];\n};\n\nint file_formats[FILE_NAMES_SIZE];\nconst size_t file_nformats = FILE_NAMES_SIZE;\nconst char *file_names[FILE_NAMES_SIZE];\nconst size_t file_nnames = FILE_NAMES_SIZE;\n\nprivate int getvalue(struct magic_set *ms, struct magic *, const char **, int);\nprivate int hextoint(int);\nprivate const char *getstr(struct magic_set *, struct magic *, const char *,\n    int);\nprivate int parse(struct magic_set *, struct magic_entry *, const char *,\n    size_t, int);\nprivate void eatsize(const char **);\nprivate int apprentice_1(struct magic_set *, const char *, int);\nprivate size_t apprentice_magic_strength(const struct magic *);\nprivate int apprentice_sort(const void *, const void *);\nprivate void apprentice_list(struct mlist *, int );\nprivate struct magic_map *apprentice_load(struct magic_set *, \n    const char *, int);\nprivate struct mlist *mlist_alloc(void);\nprivate void mlist_free(struct mlist *);\nprivate void byteswap(struct magic *, uint32_t);\nprivate void bs1(struct magic *);\nprivate uint16_t swap2(uint16_t);\nprivate uint32_t swap4(uint32_t);\nprivate uint64_t swap8(uint64_t);\nprivate char *mkdbname(struct magic_set *, const char *, int);\nprivate struct magic_map *apprentice_map(struct magic_set *, const char *);\nprivate void apprentice_unmap(struct magic_map *);\nprivate int apprentice_compile(struct magic_set *, struct magic_map *,\n    const char *);\nprivate int check_format_type(const char *, int);\nprivate int check_format(struct magic_set *, struct magic *);\nprivate int get_op(char);\nprivate int parse_mime(struct magic_set *, struct magic_entry *, const char *);\nprivate int parse_strength(struct magic_set *, struct magic_entry *, const char *);\nprivate int parse_apple(struct magic_set *, struct magic_entry *, const char *);\n\n\nprivate size_t magicsize = sizeof(struct magic);\n\nprivate const char usg_hdr[] = \"cont\\toffset\\ttype\\topcode\\tmask\\tvalue\\tdesc\";\n\nprivate struct {\n\tconst char *name;\n\tsize_t len;\n\tint (*fun)(struct magic_set *, struct magic_entry *, const char *);\n} bang[] = {\n#define\tDECLARE_FIELD(name) { # name, sizeof(# name) - 1, parse_ ## name }\n\tDECLARE_FIELD(mime),\n\tDECLARE_FIELD(apple),\n\tDECLARE_FIELD(strength),\n#undef\tDECLARE_FIELD\n\t{ NULL, 0, NULL }\n};\n\n#ifdef COMPILE_ONLY\n\nint main(int, char *[]);\n\nint\nmain(int argc, char *argv[])\n{\n\tint ret;\n\tstruct magic_set *ms;\n\tchar *progname;\n\n\tif ((progname = strrchr(argv[0], '/')) != NULL)\n\t\tprogname++;\n\telse\n\t\tprogname = argv[0];\n\n\tif (argc != 2) {\n\t\t(void)fprintf(stderr, \"Usage: %s file\\n\", progname);\n\t\treturn 1;\n\t}\n\n\tif ((ms = magic_open(MAGIC_CHECK)) == NULL) {\n\t\t(void)fprintf(stderr, \"%s: %s\\n\", progname, strerror(errno));\n\t\treturn 1;\n\t}\n\tret = magic_compile(ms, argv[1]) == -1 ? 1 : 0;\n\tif (ret == 1)\n\t\t(void)fprintf(stderr, \"%s: %s\\n\", progname, magic_error(ms));\n\tmagic_close(ms);\n\treturn ret;\n}\n#endif /* COMPILE_ONLY */\n\nstruct type_tbl_s {\n\tconst char name[16];\n\tconst size_t len;\n\tconst int type;\n\tconst int format;\n};\n\n/*\n * XXX - the actual Single UNIX Specification says that \"long\" means \"long\",\n * as in the C data type, but we treat it as meaning \"4-byte integer\".\n * Given that the OS X version of file 5.04 did the same, I guess that passes\n * the actual test; having \"long\" be dependent on how big a \"long\" is on\n * the machine running \"file\" is silly.\n */\nstatic const struct type_tbl_s type_tbl[] = {\n# define XX(s)\t\ts, (sizeof(s) - 1)\n# define XX_NULL\t\"\", 0\n\t{ XX(\"invalid\"),\tFILE_INVALID,\t\tFILE_FMT_NONE },\n\t{ XX(\"byte\"),\t\tFILE_BYTE,\t\tFILE_FMT_NUM },\n\t{ XX(\"short\"),\t\tFILE_SHORT,\t\tFILE_FMT_NUM },\n\t{ XX(\"default\"),\tFILE_DEFAULT,\t\tFILE_FMT_NONE },\n\t{ XX(\"long\"),\t\tFILE_LONG,\t\tFILE_FMT_NUM },\n\t{ XX(\"string\"),\t\tFILE_STRING,\t\tFILE_FMT_STR },\n\t{ XX(\"date\"),\t\tFILE_DATE,\t\tFILE_FMT_STR },\n\t{ XX(\"beshort\"),\tFILE_BESHORT,\t\tFILE_FMT_NUM },\n\t{ XX(\"belong\"),\t\tFILE_BELONG,\t\tFILE_FMT_NUM },\n\t{ XX(\"bedate\"),\t\tFILE_BEDATE,\t\tFILE_FMT_STR },\n\t{ XX(\"leshort\"),\tFILE_LESHORT,\t\tFILE_FMT_NUM },\n\t{ XX(\"lelong\"),\t\tFILE_LELONG,\t\tFILE_FMT_NUM },\n\t{ XX(\"ledate\"),\t\tFILE_LEDATE,\t\tFILE_FMT_STR },\n\t{ XX(\"pstring\"),\tFILE_PSTRING,\t\tFILE_FMT_STR },\n\t{ XX(\"ldate\"),\t\tFILE_LDATE,\t\tFILE_FMT_STR },\n\t{ XX(\"beldate\"),\tFILE_BELDATE,\t\tFILE_FMT_STR },\n\t{ XX(\"leldate\"),\tFILE_LELDATE,\t\tFILE_FMT_STR },\n\t{ XX(\"regex\"),\t\tFILE_REGEX,\t\tFILE_FMT_STR },\n\t{ XX(\"bestring16\"),\tFILE_BESTRING16,\tFILE_FMT_STR },\n\t{ XX(\"lestring16\"),\tFILE_LESTRING16,\tFILE_FMT_STR },\n\t{ XX(\"search\"),\t\tFILE_SEARCH,\t\tFILE_FMT_STR },\n\t{ XX(\"medate\"),\t\tFILE_MEDATE,\t\tFILE_FMT_STR },\n\t{ XX(\"meldate\"),\tFILE_MELDATE,\t\tFILE_FMT_STR },\n\t{ XX(\"melong\"),\t\tFILE_MELONG,\t\tFILE_FMT_NUM },\n\t{ XX(\"quad\"),\t\tFILE_QUAD,\t\tFILE_FMT_QUAD },\n\t{ XX(\"lequad\"),\t\tFILE_LEQUAD,\t\tFILE_FMT_QUAD },\n\t{ XX(\"bequad\"),\t\tFILE_BEQUAD,\t\tFILE_FMT_QUAD },\n\t{ XX(\"qdate\"),\t\tFILE_QDATE,\t\tFILE_FMT_STR },\n\t{ XX(\"leqdate\"),\tFILE_LEQDATE,\t\tFILE_FMT_STR },\n\t{ XX(\"beqdate\"),\tFILE_BEQDATE,\t\tFILE_FMT_STR },\n\t{ XX(\"qldate\"),\t\tFILE_QLDATE,\t\tFILE_FMT_STR },\n\t{ XX(\"leqldate\"),\tFILE_LEQLDATE,\t\tFILE_FMT_STR },\n\t{ XX(\"beqldate\"),\tFILE_BEQLDATE,\t\tFILE_FMT_STR },\n\t{ XX(\"float\"),\t\tFILE_FLOAT,\t\tFILE_FMT_FLOAT },\n\t{ XX(\"befloat\"),\tFILE_BEFLOAT,\t\tFILE_FMT_FLOAT },\n\t{ XX(\"lefloat\"),\tFILE_LEFLOAT,\t\tFILE_FMT_FLOAT },\n\t{ XX(\"double\"),\t\tFILE_DOUBLE,\t\tFILE_FMT_DOUBLE },\n\t{ XX(\"bedouble\"),\tFILE_BEDOUBLE,\t\tFILE_FMT_DOUBLE },\n\t{ XX(\"ledouble\"),\tFILE_LEDOUBLE,\t\tFILE_FMT_DOUBLE },\n\t{ XX(\"leid3\"),\t\tFILE_LEID3,\t\tFILE_FMT_NUM },\n\t{ XX(\"beid3\"),\t\tFILE_BEID3,\t\tFILE_FMT_NUM },\n\t{ XX(\"indirect\"),\tFILE_INDIRECT,\t\tFILE_FMT_NUM },\n\t{ XX(\"qwdate\"),\t\tFILE_QWDATE,\t\tFILE_FMT_STR },\n\t{ XX(\"leqwdate\"),\tFILE_LEQWDATE,\t\tFILE_FMT_STR },\n\t{ XX(\"beqwdate\"),\tFILE_BEQWDATE,\t\tFILE_FMT_STR },\n\t{ XX(\"name\"),\t\tFILE_NAME,\t\tFILE_FMT_NONE },\n\t{ XX(\"use\"),\t\tFILE_USE,\t\tFILE_FMT_NONE },\n\t{ XX(\"clear\"),\t\tFILE_CLEAR,\t\tFILE_FMT_NONE },\n\t{ XX_NULL,\t\tFILE_INVALID,\t\tFILE_FMT_NONE },\n};\n\n/*\n * These are not types, and cannot be preceded by \"u\" to make them\n * unsigned.\n */\nstatic const struct type_tbl_s special_tbl[] = {\n\t{ XX(\"name\"),\t\tFILE_NAME,\t\tFILE_FMT_STR },\n\t{ XX(\"use\"),\t\tFILE_USE,\t\tFILE_FMT_STR },\n\t{ XX_NULL,\t\tFILE_INVALID,\t\tFILE_FMT_NONE },\n};\n# undef XX\n# undef XX_NULL\n\nprivate int\nget_type(const struct type_tbl_s *tbl, const char *l, const char **t)\n{\n\tconst struct type_tbl_s *p;\n\n\tfor (p = tbl; p->len; p++) {\n\t\tif (strncmp(l, p->name, p->len) == 0) {\n\t\t\tif (t)\n\t\t\t\t*t = l + p->len;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn p->type;\n}\n\nprivate int\nget_standard_integer_type(const char *l, const char **t)\n{\n\tint type;\n\n\tif (isalpha((unsigned char)l[1])) {\n\t\tswitch (l[1]) {\n\t\tcase 'C':\n\t\t\t/* \"dC\" and \"uC\" */\n\t\t\ttype = FILE_BYTE;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\t/* \"dS\" and \"uS\" */\n\t\t\ttype = FILE_SHORT;\n\t\t\tbreak;\n\t\tcase 'I':\n\t\tcase 'L':\n\t\t\t/*\n\t\t\t * \"dI\", \"dL\", \"uI\", and \"uL\".\n\t\t\t *\n\t\t\t * XXX - the actual Single UNIX Specification says\n\t\t\t * that \"L\" means \"long\", as in the C data type,\n\t\t\t * but we treat it as meaning \"4-byte integer\".\n\t\t\t * Given that the OS X version of file 5.04 did\n\t\t\t * the same, I guess that passes the actual SUS\n\t\t\t * validation suite; having \"dL\" be dependent on\n\t\t\t * how big a \"long\" is on the machine running\n\t\t\t * \"file\" is silly.\n\t\t\t */\n\t\t\ttype = FILE_LONG;\n\t\t\tbreak;\n\t\tcase 'Q':\n\t\t\t/* \"dQ\" and \"uQ\" */\n\t\t\ttype = FILE_QUAD;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* \"d{anything else}\", \"u{anything else}\" */\n\t\t\treturn FILE_INVALID;\n\t\t}\n\t\tl += 2;\n\t} else if (isdigit((unsigned char)l[1])) {\n\t\t/*\n\t\t * \"d{num}\" and \"u{num}\"; we only support {num} values\n\t\t * of 1, 2, 4, and 8 - the Single UNIX Specification\n\t\t * doesn't say anything about whether arbitrary\n\t\t * values should be supported, but both the Solaris 10\n\t\t * and OS X Mountain Lion versions of file passed the\n\t\t * Single UNIX Specification validation suite, and\n\t\t * neither of them support values bigger than 8 or\n\t\t * non-power-of-2 values.\n\t\t */\n\t\tif (isdigit((unsigned char)l[2])) {\n\t\t\t/* Multi-digit, so > 9 */\n\t\t\treturn FILE_INVALID;\n\t\t}\n\t\tswitch (l[1]) {\n\t\tcase '1':\n\t\t\ttype = FILE_BYTE;\n\t\t\tbreak;\n\t\tcase '2':\n\t\t\ttype = FILE_SHORT;\n\t\t\tbreak;\n\t\tcase '4':\n\t\t\ttype = FILE_LONG;\n\t\t\tbreak;\n\t\tcase '8':\n\t\t\ttype = FILE_QUAD;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* XXX - what about 3, 5, 6, or 7? */\n\t\t\treturn FILE_INVALID;\n\t\t}\n\t\tl += 2;\n\t} else {\n\t\t/*\n\t\t * \"d\" or \"u\" by itself.\n\t\t */\n\t\ttype = FILE_LONG;\n\t\t++l;\n\t}\n\tif (t)\n\t\t*t = l;\n\treturn type;\n}\n\nprivate void\ninit_file_tables(void)\n{\n\tstatic int done = 0;\n\tconst struct type_tbl_s *p;\n\n\tif (done)\n\t\treturn;\n\tdone++;\n\n\tfor (p = type_tbl; p->len; p++) {\n\t\tassert(p->type < FILE_NAMES_SIZE);\n\t\tfile_names[p->type] = p->name;\n\t\tfile_formats[p->type] = p->format;\n\t}\n\tassert(p - type_tbl == FILE_NAMES_SIZE);\n}\n\nprivate int\nadd_mlist(struct mlist *mlp, struct magic_map *map, size_t idx)\n{\n\tstruct mlist *ml;\n\n\tif ((ml = CAST(struct mlist *, malloc(sizeof(*ml)))) == NULL)\n\t\treturn -1;\n\n\tml->map = idx == 0 ? map : NULL;\n\tml->magic = map->magic[idx];\n\tml->nmagic = map->nmagic[idx];\n\n\tmlp->prev->next = ml;\n\tml->prev = mlp->prev;\n\tml->next = mlp;\n\tmlp->prev = ml;\n\treturn 0;\n}\n\n/*\n * Handle one file or directory.\n */\nprivate int\napprentice_1(struct magic_set *ms, const char *fn, int action)\n{\n\tstruct mlist *ml;\n\tstruct magic_map *map;\n\tsize_t i;\n\n\tif (magicsize != FILE_MAGICSIZE) {\n\t\tfile_error(ms, 0, \"magic element size %lu != %lu\",\n\t\t    (unsigned long)sizeof(*map->magic[0]),\n\t\t    (unsigned long)FILE_MAGICSIZE);\n\t\treturn -1;\n\t}\n\n\tif (action == FILE_COMPILE) {\n\t\tmap = apprentice_load(ms, fn, action);\n\t\tif (map == NULL)\n\t\t\treturn -1;\n\t\treturn apprentice_compile(ms, map, fn);\n\t}\n\n#ifndef COMPILE_ONLY\n\tmap = apprentice_map(ms, fn);\n\tif (map == NULL) {\n\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\tfile_magwarn(ms, \"using regular magic file `%s'\", fn);\n\t\tmap = apprentice_load(ms, fn, action);\n\t\tif (map == NULL)\n\t\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < MAGIC_SETS; i++) {\n\t\tif (add_mlist(ms->mlist[i], map, i) == -1) {\n\t\t\tfile_oomem(ms, sizeof(*ml));\n\t\t\tapprentice_unmap(map);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (action == FILE_LIST) {\n\t\tfor (i = 0; i < MAGIC_SETS; i++) {\n\t\t\tprintf(\"Set %zu:\\nBinary patterns:\\n\", i);\n\t\t\tapprentice_list(ms->mlist[i], BINTEST);\n\t\t\tprintf(\"Text patterns:\\n\");\n\t\t\tapprentice_list(ms->mlist[i], TEXTTEST);\n\t\t}\n\t}\n\t\n\treturn 0;\n#endif /* COMPILE_ONLY */\n}\n\nprotected void\nfile_ms_free(struct magic_set *ms)\n{\n\tsize_t i;\n\tif (ms == NULL)\n\t\treturn;\n\tfor (i = 0; i < MAGIC_SETS; i++)\n\t\tmlist_free(ms->mlist[i]);\n\tfree(ms->o.pbuf);\n\tfree(ms->o.buf);\n\tfree(ms->c.li);\n\tfree(ms);\n}\n\nprotected struct magic_set *\nfile_ms_alloc(int flags)\n{\n\tstruct magic_set *ms;\n\tsize_t i, len;\n\n\tif ((ms = CAST(struct magic_set *, calloc((size_t)1,\n\t    sizeof(struct magic_set)))) == NULL)\n\t\treturn NULL;\n\n\tif (magic_setflags(ms, flags) == -1) {\n\t\terrno = EINVAL;\n\t\tgoto free;\n\t}\n\n\tms->o.buf = ms->o.pbuf = NULL;\n\tlen = (ms->c.len = 10) * sizeof(*ms->c.li);\n\n\tif ((ms->c.li = CAST(struct level_info *, malloc(len))) == NULL)\n\t\tgoto free;\n\n\tms->event_flags = 0;\n\tms->error = -1;\n\tfor (i = 0; i < MAGIC_SETS; i++)\n\t\tms->mlist[i] = NULL;\n\tms->file = \"unknown\";\n\tms->line = 0;\n\treturn ms;\nfree:\n\tfree(ms);\n\treturn NULL;\n}\n\nprivate void\napprentice_unmap(struct magic_map *map)\n{\n\tif (map == NULL)\n\t\treturn;\n\tif (map->p != NULL) {\n#ifdef QUICK\n\t\tif (map->len)\n\t\t\t(void)munmap(map->p, map->len);\n\t\telse\n#endif\n\t\tfree(map->p);\n\t} else {\n\t\tuint32_t j;\n\t\tfor (j = 0; j < MAGIC_SETS; j++)\n\t\t\tfree(map->magic[j]);\n\t}\n\tfree(map);\n}\n\nprivate struct mlist *\nmlist_alloc(void)\n{\n\tstruct mlist *mlist;\n\tif ((mlist = CAST(struct mlist *, calloc(1, sizeof(*mlist)))) == NULL) {\n\t\treturn NULL;\n\t}\n\tmlist->next = mlist->prev = mlist;\n\treturn mlist;\n}\n\nprivate void\nmlist_free(struct mlist *mlist)\n{\n\tstruct mlist *ml;\n\n\tif (mlist == NULL)\n\t\treturn;\n\n\tfor (ml = mlist->next; ml != mlist;) {\n\t\tstruct mlist *next = ml->next;\n\t\tif (ml->map)\n\t\t\tapprentice_unmap(ml->map);\n\t\tfree(ml);\n\t\tml = next;\n\t}\n\tfree(ml);\n}\n\n/* const char *fn: list of magic files and directories */\nprotected int\nfile_apprentice(struct magic_set *ms, const char *fn, int action)\n{\n\tchar *p, *mfn;\n\tint file_err, errs = -1;\n\tsize_t i;\n\n\tif (ms->mlist[0] != NULL)\n\t\tfile_reset(ms);\n\n\tif ((fn = magic_getpath(fn, action)) == NULL)\n\t\treturn -1;\n\n\tinit_file_tables();\n\n\tif ((mfn = strdup(fn)) == NULL) {\n\t\tfile_oomem(ms, strlen(fn));\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < MAGIC_SETS; i++) {\n\t\tmlist_free(ms->mlist[i]);\n\t\tif ((ms->mlist[i] = mlist_alloc()) == NULL) {\n\t\t\tfile_oomem(ms, sizeof(*ms->mlist[i]));\n\t\t\tif (i != 0) {\n\t\t\t\t--i;\n\t\t\t\tdo\n\t\t\t\t\tmlist_free(ms->mlist[i]);\n\t\t\t\twhile (i != 0);\n\t\t\t}\n\t\t\tfree(mfn);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tfn = mfn;\n\n\twhile (fn) {\n\t\tp = strchr(fn, PATHSEP);\n\t\tif (p)\n\t\t\t*p++ = '\\0';\n\t\tif (*fn == '\\0')\n\t\t\tbreak;\n\t\tfile_err = apprentice_1(ms, fn, action);\n\t\terrs = MAX(errs, file_err);\n\t\tfn = p;\n\t}\n\n\tfree(mfn);\n\n\tif (errs == -1) {\n\t\tfor (i = 0; i < MAGIC_SETS; i++) {\n\t\t\tmlist_free(ms->mlist[i]);\n\t\t\tms->mlist[i] = NULL;\n\t\t}\n\t\tfile_error(ms, 0, \"could not find any valid magic files!\");\n\t\treturn -1;\n\t}\n\n#if 0\n\t/*\n\t * Always leave the database loaded\n\t */\n\tif (action == FILE_LOAD)\n\t\treturn 0;\n\n\tfor (i = 0; i < MAGIC_SETS; i++) {\n\t\tmlist_free(ms->mlist[i]);\n\t\tms->mlist[i] = NULL;\n\t}\n#endif\n\n\tswitch (action) {\n\tcase FILE_LOAD:\n\tcase FILE_COMPILE:\n\tcase FILE_CHECK:\n\tcase FILE_LIST:\n\t\treturn 0;\n\tdefault:\n\t\tfile_error(ms, 0, \"Invalid action %d\", action);\n\t\treturn -1;\n\t}\n}\n\n/*\n * Compute the real length of a magic expression, for the purposes\n * of determining how \"strong\" a magic expression is (approximating\n * how specific its matches are):\n *\t- magic characters count 0 unless escaped.\n *\t- [] expressions count 1\n *\t- {} expressions count 0\n *\t- regular characters or escaped magic characters count 1\n *\t- 0 length expressions count as one\n */\nprivate size_t\nnonmagic(const char *str)\n{\n\tconst char *p;\n\tsize_t rv = 0;\n\n\tfor (p = str; *p; p++)\n\t\tswitch (*p) {\n\t\tcase '\\\\':\t/* Escaped anything counts 1 */\n\t\t\tif (!*++p)\n\t\t\t\tp--;\n\t\t\trv++;\n\t\t\tcontinue;\n\t\tcase '?':\t/* Magic characters count 0 */\n\t\tcase '*':\n\t\tcase '.':\n\t\tcase '+':\n\t\tcase '^':\n\t\tcase '$':\n\t\t\tcontinue;\n\t\tcase '[':\t/* Bracketed expressions count 1 the ']' */\n\t\t\twhile (*p && *p != ']')\n\t\t\t\tp++;\n\t\t\tp--;\n\t\t\tcontinue;\n\t\tcase '{':\t/* Braced expressions count 0 */\n\t\t\twhile (*p && *p != '}')\n\t\t\t\tp++;\n\t\t\tif (!*p)\n\t\t\t\tp--;\n\t\t\tcontinue;\n\t\tdefault:\t/* Anything else counts 1 */\n\t\t\trv++;\n\t\t\tcontinue;\n\t\t}\n\n\treturn rv == 0 ? 1 : rv;\t/* Return at least 1 */\n}\n\n/*\n * Get weight of this magic entry, for sorting purposes.\n */\nprivate size_t\napprentice_magic_strength(const struct magic *m)\n{\n#define MULT 10\n\tsize_t v, val = 2 * MULT;\t/* baseline strength */\n\n\tswitch (m->type) {\n\tcase FILE_DEFAULT:\t/* make sure this sorts last */\n\t\tif (m->factor_op != FILE_FACTOR_OP_NONE)\n\t\t\tabort();\n\t\treturn 0;\n\n\tcase FILE_BYTE:\n\t\tval += 1 * MULT;\n\t\tbreak;\n\n\tcase FILE_SHORT:\n\tcase FILE_LESHORT:\n\tcase FILE_BESHORT:\n\t\tval += 2 * MULT;\n\t\tbreak;\n\n\tcase FILE_LONG:\n\tcase FILE_LELONG:\n\tcase FILE_BELONG:\n\tcase FILE_MELONG:\n\t\tval += 4 * MULT;\n\t\tbreak;\n\n\tcase FILE_PSTRING:\n\tcase FILE_STRING:\n\t\tval += m->vallen * MULT;\n\t\tbreak;\n\n\tcase FILE_BESTRING16:\n\tcase FILE_LESTRING16:\n\t\tval += m->vallen * MULT / 2;\n\t\tbreak;\n\n\tcase FILE_SEARCH:\n\t\tval += m->vallen * MAX(MULT / m->vallen, 1);\n\t\tbreak;\n\n\tcase FILE_REGEX:\n\t\tv = nonmagic(m->value.s);\n\t\tval += v * MAX(MULT / v, 1);\n\t\tbreak;\n\n\tcase FILE_DATE:\n\tcase FILE_LEDATE:\n\tcase FILE_BEDATE:\n\tcase FILE_MEDATE:\n\tcase FILE_LDATE:\n\tcase FILE_LELDATE:\n\tcase FILE_BELDATE:\n\tcase FILE_MELDATE:\n\tcase FILE_FLOAT:\n\tcase FILE_BEFLOAT:\n\tcase FILE_LEFLOAT:\n\t\tval += 4 * MULT;\n\t\tbreak;\n\n\tcase FILE_QUAD:\n\tcase FILE_BEQUAD:\n\tcase FILE_LEQUAD:\n\tcase FILE_QDATE:\n\tcase FILE_LEQDATE:\n\tcase FILE_BEQDATE:\n\tcase FILE_QLDATE:\n\tcase FILE_LEQLDATE:\n\tcase FILE_BEQLDATE:\n\tcase FILE_QWDATE:\n\tcase FILE_LEQWDATE:\n\tcase FILE_BEQWDATE:\n\tcase FILE_DOUBLE:\n\tcase FILE_BEDOUBLE:\n\tcase FILE_LEDOUBLE:\n\t\tval += 8 * MULT;\n\t\tbreak;\n\n\tcase FILE_INDIRECT:\n\tcase FILE_NAME:\n\tcase FILE_USE:\n\t\tbreak;\n\n\tdefault:\n\t\t(void)fprintf(stderr, \"Bad type %d\\n\", m->type);\n\t\tabort();\n\t}\n\n\tswitch (m->reln) {\n\tcase 'x':\t/* matches anything penalize */\n\tcase '!':       /* matches almost anything penalize */\n\t\tval = 0;\n\t\tbreak;\n\n\tcase '=':\t/* Exact match, prefer */\n\t\tval += MULT;\n\t\tbreak;\n\n\tcase '>':\n\tcase '<':\t/* comparison match reduce strength */\n\t\tval -= 2 * MULT;\n\t\tbreak;\n\n\tcase '^':\n\tcase '&':\t/* masking bits, we could count them too */\n\t\tval -= MULT;\n\t\tbreak;\n\n\tdefault:\n\t\t(void)fprintf(stderr, \"Bad relation %c\\n\", m->reln);\n\t\tabort();\n\t}\n\n\tif (val == 0)\t/* ensure we only return 0 for FILE_DEFAULT */\n\t\tval = 1;\n\n\tswitch (m->factor_op) {\n\tcase FILE_FACTOR_OP_NONE:\n\t\tbreak;\n\tcase FILE_FACTOR_OP_PLUS:\n\t\tval += m->factor;\n\t\tbreak;\n\tcase FILE_FACTOR_OP_MINUS:\n\t\tval -= m->factor;\n\t\tbreak;\n\tcase FILE_FACTOR_OP_TIMES:\n\t\tval *= m->factor;\n\t\tbreak;\n\tcase FILE_FACTOR_OP_DIV:\n\t\tval /= m->factor;\n\t\tbreak;\n\tdefault:\n\t\tabort();\n\t}\n\n\t/*\n\t * Magic entries with no description get a bonus because they depend\n\t * on subsequent magic entries to print something.\n\t */\n\tif (m->desc[0] == '\\0')\n\t\tval++;\n\treturn val;\n}\n\n/*  \n * Sort callback for sorting entries by \"strength\" (basically length)\n */\nprivate int\napprentice_sort(const void *a, const void *b)\n{\n\tconst struct magic_entry *ma = CAST(const struct magic_entry *, a);\n\tconst struct magic_entry *mb = CAST(const struct magic_entry *, b);\n\tsize_t sa = apprentice_magic_strength(ma->mp);\n\tsize_t sb = apprentice_magic_strength(mb->mp);\n\tif (sa == sb)\n\t\treturn 0;\n\telse if (sa > sb)\n\t\treturn -1;\n\telse\n\t\treturn 1;\n}\n\n/*  \n * Shows sorted patterns list in the order which is used for the matching\n */\nprivate void\napprentice_list(struct mlist *mlist, int mode)\n{\n\tuint32_t magindex = 0;\n\tstruct mlist *ml;\n\tfor (ml = mlist->next; ml != mlist; ml = ml->next) {\n\t\tfor (magindex = 0; magindex < ml->nmagic; magindex++) {\n\t\t\tstruct magic *m = &ml->magic[magindex];\n\t\t\tif ((m->flag & mode) != mode) {\n\t\t\t\t/* Skip sub-tests */\n\t\t\t\twhile (magindex + 1 < ml->nmagic &&\n\t\t\t\t       ml->magic[magindex + 1].cont_level != 0)\n\t\t\t\t\t++magindex;\n\t\t\t\tcontinue; /* Skip to next top-level test*/\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Try to iterate over the tree until we find item with\n\t\t\t * description/mimetype.\n\t\t\t */\n\t\t\twhile (magindex + 1 < ml->nmagic &&\n\t\t\t       ml->magic[magindex + 1].cont_level != 0 &&\n\t\t\t       *ml->magic[magindex].desc == '\\0' &&\n\t\t\t       *ml->magic[magindex].mimetype == '\\0')\n\t\t\t\tmagindex++;\n\n\t\t\tprintf(\"Strength = %3\" SIZE_T_FORMAT \"u : %s [%s]\\n\",\n\t\t\t    apprentice_magic_strength(m),\n\t\t\t    ml->magic[magindex].desc,\n\t\t\t    ml->magic[magindex].mimetype);\n\t\t}\n\t}\n}\n\nprivate void\nset_test_type(struct magic *mstart, struct magic *m)\n{\n\tswitch (m->type) {\n\tcase FILE_BYTE:\n\tcase FILE_SHORT:\n\tcase FILE_LONG:\n\tcase FILE_DATE:\n\tcase FILE_BESHORT:\n\tcase FILE_BELONG:\n\tcase FILE_BEDATE:\n\tcase FILE_LESHORT:\n\tcase FILE_LELONG:\n\tcase FILE_LEDATE:\n\tcase FILE_LDATE:\n\tcase FILE_BELDATE:\n\tcase FILE_LELDATE:\n\tcase FILE_MEDATE:\n\tcase FILE_MELDATE:\n\tcase FILE_MELONG:\n\tcase FILE_QUAD:\n\tcase FILE_LEQUAD:\n\tcase FILE_BEQUAD:\n\tcase FILE_QDATE:\n\tcase FILE_LEQDATE:\n\tcase FILE_BEQDATE:\n\tcase FILE_QLDATE:\n\tcase FILE_LEQLDATE:\n\tcase FILE_BEQLDATE:\n\tcase FILE_QWDATE:\n\tcase FILE_LEQWDATE:\n\tcase FILE_BEQWDATE:\n\tcase FILE_FLOAT:\n\tcase FILE_BEFLOAT:\n\tcase FILE_LEFLOAT:\n\tcase FILE_DOUBLE:\n\tcase FILE_BEDOUBLE:\n\tcase FILE_LEDOUBLE:\n\t\tmstart->flag |= BINTEST;\n\t\tbreak;\n\tcase FILE_STRING:\n\tcase FILE_PSTRING:\n\tcase FILE_BESTRING16:\n\tcase FILE_LESTRING16:\n\t\t/* Allow text overrides */\n\t\tif (mstart->str_flags & STRING_TEXTTEST)\n\t\t\tmstart->flag |= TEXTTEST;\n\t\telse\n\t\t\tmstart->flag |= BINTEST;\n\t\tbreak;\n\tcase FILE_REGEX:\n\tcase FILE_SEARCH:\n\t\t/* Check for override */\n\t\tif (mstart->str_flags & STRING_BINTEST)\n\t\t\tmstart->flag |= BINTEST;\n\t\tif (mstart->str_flags & STRING_TEXTTEST)\n\t\t\tmstart->flag |= TEXTTEST;\n\t\t    \n\t\tif (mstart->flag & (TEXTTEST|BINTEST))\n\t\t\tbreak;\n\n\t\t/* binary test if pattern is not text */\n\t\tif (file_looks_utf8(m->value.us, (size_t)m->vallen, NULL,\n\t\t    NULL) <= 0)\n\t\t\tmstart->flag |= BINTEST;\n\t\telse\n\t\t\tmstart->flag |= TEXTTEST;\n\t\tbreak;\n\tcase FILE_DEFAULT:\n\t\t/* can't deduce anything; we shouldn't see this at the\n\t\t   top level anyway */\n\t\tbreak;\n\tcase FILE_INVALID:\n\tdefault:\n\t\t/* invalid search type, but no need to complain here */\n\t\tbreak;\n\t}\n}\n\nprivate int\naddentry(struct magic_set *ms, struct magic_entry *me,\n   struct magic_entry_set *mset)\n{\n\tsize_t i = me->mp->type == FILE_NAME ? 1 : 0;\n\tif (mset[i].count == mset[i].max) {\n\t\tstruct magic_entry *mp;\n\n\t\tmset[i].max += ALLOC_INCR;\n\t\tif ((mp = CAST(struct magic_entry *,\n\t\t    realloc(mset[i].me, sizeof(*mp) * mset[i].max))) ==\n\t\t    NULL) {\n\t\t\tfile_oomem(ms, sizeof(*mp) * mset[i].max);\n\t\t\treturn -1;\n\t\t}\n\t\t(void)memset(&mp[mset[i].count], 0, sizeof(*mp) *\n\t\t    ALLOC_INCR);\n\t\tmset[i].me = mp;\n\t}\n\tmset[i].me[mset[i].count++] = *me;\n\tmemset(me, 0, sizeof(*me));\n\treturn 0;\n}\n\n/*\n * Load and parse one file.\n */\nprivate void\nload_1(struct magic_set *ms, int action, const char *fn, int *errs,\n   struct magic_entry_set *mset)\n{\n\tsize_t lineno = 0, llen = 0;\n\tchar *line = NULL;\n\tssize_t len;\n\tstruct magic_entry me;\n\n\tFILE *f = fopen(ms->file = fn, \"r\");\n\tif (f == NULL) {\n\t\tif (errno != ENOENT)\n\t\t\tfile_error(ms, errno, \"cannot read magic file `%s'\",\n\t\t\t\t   fn);\n\t\t(*errs)++;\n\t\treturn;\n\t}\n\n\tmemset(&me, 0, sizeof(me));\n\t/* read and parse this file */\n\tfor (ms->line = 1; (len = getline(&line, &llen, f)) != -1;\n\t    ms->line++) {\n\t\tif (len == 0) /* null line, garbage, etc */\n\t\t\tcontinue;\n\t\tif (line[len - 1] == '\\n') {\n\t\t\tlineno++;\n\t\t\tline[len - 1] = '\\0'; /* delete newline */\n\t\t}\n\t\tswitch (line[0]) {\n\t\tcase '\\0':\t/* empty, do not parse */\n\t\tcase '#':\t/* comment, do not parse */\n\t\t\tcontinue;\n\t\tcase '!':\n\t\t\tif (line[1] == ':') {\n\t\t\t\tsize_t i;\n\n\t\t\t\tfor (i = 0; bang[i].name != NULL; i++) {\n\t\t\t\t\tif ((size_t)(len - 2) > bang[i].len &&\n\t\t\t\t\t    memcmp(bang[i].name, line + 2,\n\t\t\t\t\t    bang[i].len) == 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (bang[i].name == NULL) {\n\t\t\t\t\tfile_error(ms, 0,\n\t\t\t\t\t    \"Unknown !: entry `%s'\", line);\n\t\t\t\t\t(*errs)++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (me.mp == NULL) {\n\t\t\t\t\tfile_error(ms, 0,\n\t\t\t\t\t    \"No current entry for :!%s type\",\n\t\t\t\t\t\tbang[i].name);\n\t\t\t\t\t(*errs)++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif ((*bang[i].fun)(ms, &me,\n\t\t\t\t    line + bang[i].len + 2) != 0) {\n\t\t\t\t\t(*errs)++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*FALLTHROUGH*/\n\t\tdefault:\n\t\tagain:\n\t\t\tswitch (parse(ms, &me, line, lineno, action)) {\n\t\t\tcase 0:\n\t\t\t\tcontinue;\n\t\t\tcase 1:\n\t\t\t\t(void)addentry(ms, &me, mset);\n\t\t\t\tgoto again;\n\t\t\tdefault:\n\t\t\t\t(*errs)++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (me.mp)\n\t\t(void)addentry(ms, &me, mset);\n\tfree(line);\n\t(void)fclose(f);\n}\n\n/*\n * parse a file or directory of files\n * const char *fn: name of magic file or directory\n */\nprivate int\ncmpstrp(const void *p1, const void *p2)\n{\n        return strcmp(*(char *const *)p1, *(char *const *)p2);\n}\n\n\nprivate uint32_t\nset_text_binary(struct magic_set *ms, struct magic_entry *me, uint32_t nme,\n    uint32_t starttest)\n{\n\tstatic const char text[] = \"text\";\n\tstatic const char binary[] = \"binary\";\n\tstatic const size_t len = sizeof(text);\n\n\tuint32_t i = starttest;\n\n\tdo {\n\t\tset_test_type(me[starttest].mp, me[i].mp);\n\t\tif ((ms->flags & MAGIC_DEBUG) == 0)\n\t\t\tcontinue;\n\t\t(void)fprintf(stderr, \"%s%s%s: %s\\n\",\n\t\t    me[i].mp->mimetype,\n\t\t    me[i].mp->mimetype[0] == '\\0' ? \"\" : \"; \",\n\t\t    me[i].mp->desc[0] ? me[i].mp->desc : \"(no description)\",\n\t\t    me[i].mp->flag & BINTEST ? binary : text);\n\t\tif (me[i].mp->flag & BINTEST) {\n\t\t\tchar *p = strstr(me[i].mp->desc, text);\n\t\t\tif (p && (p == me[i].mp->desc ||\n\t\t\t    isspace((unsigned char)p[-1])) &&\n\t\t\t    (p + len - me[i].mp->desc == MAXstring\n\t\t\t    || (p[len] == '\\0' ||\n\t\t\t    isspace((unsigned char)p[len]))))\n\t\t\t\t(void)fprintf(stderr, \"*** Possible \"\n\t\t\t\t    \"binary test for text type\\n\");\n\t\t}\n\t} while (++i < nme && me[i].mp->cont_level != 0);\n\treturn i;\n}\n\nprivate void\nset_last_default(struct magic_set *ms, struct magic_entry *me, uint32_t nme)\n{\n\tuint32_t i;\n\tfor (i = 0; i < nme; i++) {\n\t\tif (me[i].mp->cont_level == 0 &&\n\t\t    me[i].mp->type == FILE_DEFAULT) {\n\t\t\twhile (++i < nme)\n\t\t\t\tif (me[i].mp->cont_level == 0)\n\t\t\t\t\tbreak;\n\t\t\tif (i != nme) {\n\t\t\t\t/* XXX - Ugh! */\n\t\t\t\tms->line = me[i].mp->lineno;\n\t\t\t\tfile_magwarn(ms,\n\t\t\t\t    \"level 0 \\\"default\\\" did not sort last\");\n\t\t\t}\n\t\t\treturn;\t\t\t\t\t    \n\t\t}\n\t}\n}\n\nprivate int\ncoalesce_entries(struct magic_set *ms, struct magic_entry *me, uint32_t nme,\n    struct magic **ma, uint32_t *nma)\n{\n\tuint32_t i, mentrycount = 0;\n\tsize_t slen;\n\n\tfor (i = 0; i < nme; i++)\n\t\tmentrycount += me[i].cont_count;\n\n\tslen = sizeof(**ma) * mentrycount;\n\tif ((*ma = CAST(struct magic *, malloc(slen))) == NULL) {\n\t\tfile_oomem(ms, slen);\n\t\treturn -1;\n\t}\n\n\tmentrycount = 0;\n\tfor (i = 0; i < nme; i++) {\n\t\t(void)memcpy(*ma + mentrycount, me[i].mp,\n\t\t    me[i].cont_count * sizeof(**ma));\n\t\tmentrycount += me[i].cont_count;\n\t}\n\t*nma = mentrycount;\n\treturn 0;\n}\n\nprivate void\nmagic_entry_free(struct magic_entry *me, uint32_t nme)\n{\n\tuint32_t i;\n\tif (me == NULL)\n\t\treturn;\n\tfor (i = 0; i < nme; i++)\n\t\tfree(me[i].mp);\n\tfree(me);\n}\n\nprivate struct magic_map *\napprentice_load(struct magic_set *ms, const char *fn, int action)\n{\n\tint errs = 0;\n\tuint32_t i, j;\n\tsize_t files = 0, maxfiles = 0;\n\tchar **filearr = NULL, *mfn;\n\tstruct stat st;\n\tstruct magic_map *map;\n\tstruct magic_entry_set mset[MAGIC_SETS];\n\tDIR *dir;\n\tstruct dirent *d;\n\n\tmemset(mset, 0, sizeof(mset));\n\tms->flags |= MAGIC_CHECK;\t/* Enable checks for parsed files */\n\n\n\tif ((map = CAST(struct magic_map *, calloc(1, sizeof(*map)))) == NULL)\n\t{\n\t\tfile_oomem(ms, sizeof(*map));\n\t\treturn NULL;\n\t}\n\n\t/* print silly verbose header for USG compat. */\n\tif (action == FILE_CHECK)\n\t\t(void)fprintf(stderr, \"%s\\n\", usg_hdr);\n\n\t/* load directory or file */\n\tif (stat(fn, &st) == 0 && S_ISDIR(st.st_mode)) {\n\t\tdir = opendir(fn);\n\t\tif (!dir) {\n\t\t\terrs++;\n\t\t\tgoto out;\n\t\t}\n\t\twhile ((d = readdir(dir)) != NULL) {\n\t\t\tif (asprintf(&mfn, \"%s/%s\", fn, d->d_name) < 0) {\n\t\t\t\tfile_oomem(ms,\n\t\t\t\t    strlen(fn) + strlen(d->d_name) + 2);\n\t\t\t\terrs++;\n\t\t\t\tclosedir(dir);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (stat(mfn, &st) == -1 || !S_ISREG(st.st_mode)) {\n\t\t\t\tfree(mfn);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (files >= maxfiles) {\n\t\t\t\tsize_t mlen;\n\t\t\t\tmaxfiles = (maxfiles + 1) * 2;\n\t\t\t\tmlen = maxfiles * sizeof(*filearr);\n\t\t\t\tif ((filearr = CAST(char **,\n\t\t\t\t    realloc(filearr, mlen))) == NULL) {\n\t\t\t\t\tfile_oomem(ms, mlen);\n\t\t\t\t\tfree(mfn);\n\t\t\t\t\tclosedir(dir);\n\t\t\t\t\terrs++;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfilearr[files++] = mfn;\n\t\t}\n\t\tclosedir(dir);\n\t\tqsort(filearr, files, sizeof(*filearr), cmpstrp);\n\t\tfor (i = 0; i < files; i++) {\n\t\t\tload_1(ms, action, filearr[i], &errs, mset);\n\t\t\tfree(filearr[i]);\n\t\t}\n\t\tfree(filearr);\n\t} else\n\t\tload_1(ms, action, fn, &errs, mset);\n\tif (errs)\n\t\tgoto out;\n\n\tfor (j = 0; j < MAGIC_SETS; j++) {\n\t\t/* Set types of tests */\n\t\tfor (i = 0; i < mset[j].count; ) {\n\t\t\tif (mset[j].me[i].mp->cont_level != 0) {\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ti = set_text_binary(ms, mset[j].me, mset[j].count, i);\n\t\t}\n\t\tqsort(mset[j].me, mset[j].count, sizeof(*mset[j].me),\n\t\t    apprentice_sort);\n\n\t\t/*\n\t\t * Make sure that any level 0 \"default\" line is last\n\t\t * (if one exists).\n\t\t */\n\t\tset_last_default(ms, mset[j].me, mset[j].count);\n\n\t\t/* coalesce per file arrays into a single one */\n\t\tif (coalesce_entries(ms, mset[j].me, mset[j].count,\n\t\t    &map->magic[j], &map->nmagic[j]) == -1) {\n\t\t\terrs++;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tfor (j = 0; j < MAGIC_SETS; j++)\n\t\tmagic_entry_free(mset[j].me, mset[j].count);\n\n\tif (errs) {\n\t\tapprentice_unmap(map);\n\t\treturn NULL;\n\t}\n\treturn map;\n}\n\n/*\n * extend the sign bit if the comparison is to be signed\n */\nprotected uint64_t\nfile_signextend(struct magic_set *ms, struct magic *m, uint64_t v)\n{\n\tif (!(m->flag & UNSIGNED)) {\n\t\tswitch(m->type) {\n\t\t/*\n\t\t * Do not remove the casts below.  They are\n\t\t * vital.  When later compared with the data,\n\t\t * the sign extension must have happened.\n\t\t */\n\t\tcase FILE_BYTE:\n\t\t\tv = (char) v;\n\t\t\tbreak;\n\t\tcase FILE_SHORT:\n\t\tcase FILE_BESHORT:\n\t\tcase FILE_LESHORT:\n\t\t\tv = (short) v;\n\t\t\tbreak;\n\t\tcase FILE_DATE:\n\t\tcase FILE_BEDATE:\n\t\tcase FILE_LEDATE:\n\t\tcase FILE_MEDATE:\n\t\tcase FILE_LDATE:\n\t\tcase FILE_BELDATE:\n\t\tcase FILE_LELDATE:\n\t\tcase FILE_MELDATE:\n\t\tcase FILE_LONG:\n\t\tcase FILE_BELONG:\n\t\tcase FILE_LELONG:\n\t\tcase FILE_MELONG:\n\t\tcase FILE_FLOAT:\n\t\tcase FILE_BEFLOAT:\n\t\tcase FILE_LEFLOAT:\n\t\t\tv = (int32_t) v;\n\t\t\tbreak;\n\t\tcase FILE_QUAD:\n\t\tcase FILE_BEQUAD:\n\t\tcase FILE_LEQUAD:\n\t\tcase FILE_QDATE:\n\t\tcase FILE_QLDATE:\n\t\tcase FILE_QWDATE:\n\t\tcase FILE_BEQDATE:\n\t\tcase FILE_BEQLDATE:\n\t\tcase FILE_BEQWDATE:\n\t\tcase FILE_LEQDATE:\n\t\tcase FILE_LEQLDATE:\n\t\tcase FILE_LEQWDATE:\n\t\tcase FILE_DOUBLE:\n\t\tcase FILE_BEDOUBLE:\n\t\tcase FILE_LEDOUBLE:\n\t\t\tv = (int64_t) v;\n\t\t\tbreak;\n\t\tcase FILE_STRING:\n\t\tcase FILE_PSTRING:\n\t\tcase FILE_BESTRING16:\n\t\tcase FILE_LESTRING16:\n\t\tcase FILE_REGEX:\n\t\tcase FILE_SEARCH:\n\t\tcase FILE_DEFAULT:\n\t\tcase FILE_INDIRECT:\n\t\tcase FILE_NAME:\n\t\tcase FILE_USE:\n\t\tcase FILE_CLEAR:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\t    file_magwarn(ms, \"cannot happen: m->type=%d\\n\",\n\t\t\t\t    m->type);\n\t\t\treturn ~0U;\n\t\t}\n\t}\n\treturn v;\n}\n\nprivate int\nstring_modifier_check(struct magic_set *ms, struct magic *m)\n{\n\tif ((ms->flags & MAGIC_CHECK) == 0)\n\t\treturn 0;\n\n\tif (m->type != FILE_PSTRING && (m->str_flags & PSTRING_LEN) != 0) {\n\t\tfile_magwarn(ms,\n\t\t    \"'/BHhLl' modifiers are only allowed for pascal strings\\n\");\n\t\treturn -1;\n\t}\n\tswitch (m->type) {\n\tcase FILE_BESTRING16:\n\tcase FILE_LESTRING16:\n\t\tif (m->str_flags != 0) {\n\t\t\tfile_magwarn(ms,\n\t\t\t    \"no modifiers allowed for 16-bit strings\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase FILE_STRING:\n\tcase FILE_PSTRING:\n\t\tif ((m->str_flags & REGEX_OFFSET_START) != 0) {\n\t\t\tfile_magwarn(ms,\n\t\t\t    \"'/%c' only allowed on regex and search\\n\",\n\t\t\t    CHAR_REGEX_OFFSET_START);\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase FILE_SEARCH:\n\t\tif (m->str_range == 0) {\n\t\t\tfile_magwarn(ms,\n\t\t\t    \"missing range; defaulting to %d\\n\",\n                            STRING_DEFAULT_RANGE);\n\t\t\tm->str_range = STRING_DEFAULT_RANGE;\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase FILE_REGEX:\n\t\tif ((m->str_flags & STRING_COMPACT_WHITESPACE) != 0) {\n\t\t\tfile_magwarn(ms, \"'/%c' not allowed on regex\\n\",\n\t\t\t    CHAR_COMPACT_WHITESPACE);\n\t\t\treturn -1;\n\t\t}\n\t\tif ((m->str_flags & STRING_COMPACT_OPTIONAL_WHITESPACE) != 0) {\n\t\t\tfile_magwarn(ms, \"'/%c' not allowed on regex\\n\",\n\t\t\t    CHAR_COMPACT_OPTIONAL_WHITESPACE);\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tfile_magwarn(ms, \"coding error: m->type=%d\\n\",\n\t\t    m->type);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nprivate int\nget_op(char c)\n{\n\tswitch (c) {\n\tcase '&':\n\t\treturn FILE_OPAND;\n\tcase '|':\n\t\treturn FILE_OPOR;\n\tcase '^':\n\t\treturn FILE_OPXOR;\n\tcase '+':\n\t\treturn FILE_OPADD;\n\tcase '-':\n\t\treturn FILE_OPMINUS;\n\tcase '*':\n\t\treturn FILE_OPMULTIPLY;\n\tcase '/':\n\t\treturn FILE_OPDIVIDE;\n\tcase '%':\n\t\treturn FILE_OPMODULO;\n\tdefault:\n\t\treturn -1;\n\t}\n}\n\n#ifdef ENABLE_CONDITIONALS\nprivate int\nget_cond(const char *l, const char **t)\n{\n\tstatic const struct cond_tbl_s {\n\t\tchar name[8];\n\t\tsize_t len;\n\t\tint cond;\n\t} cond_tbl[] = {\n\t\t{ \"if\",\t\t2,\tCOND_IF },\n\t\t{ \"elif\",\t4,\tCOND_ELIF },\n\t\t{ \"else\",\t4,\tCOND_ELSE },\n\t\t{ \"\",\t\t0,\tCOND_NONE },\n\t};\n\tconst struct cond_tbl_s *p;\n\n\tfor (p = cond_tbl; p->len; p++) {\n\t\tif (strncmp(l, p->name, p->len) == 0 &&\n\t\t    isspace((unsigned char)l[p->len])) {\n\t\t\tif (t)\n\t\t\t\t*t = l + p->len;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn p->cond;\n}\n\nprivate int\ncheck_cond(struct magic_set *ms, int cond, uint32_t cont_level)\n{\n\tint last_cond;\n\tlast_cond = ms->c.li[cont_level].last_cond;\n\n\tswitch (cond) {\n\tcase COND_IF:\n\t\tif (last_cond != COND_NONE && last_cond != COND_ELIF) {\n\t\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\t\tfile_magwarn(ms, \"syntax error: `if'\");\n\t\t\treturn -1;\n\t\t}\n\t\tlast_cond = COND_IF;\n\t\tbreak;\n\n\tcase COND_ELIF:\n\t\tif (last_cond != COND_IF && last_cond != COND_ELIF) {\n\t\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\t\tfile_magwarn(ms, \"syntax error: `elif'\");\n\t\t\treturn -1;\n\t\t}\n\t\tlast_cond = COND_ELIF;\n\t\tbreak;\n\n\tcase COND_ELSE:\n\t\tif (last_cond != COND_IF && last_cond != COND_ELIF) {\n\t\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\t\tfile_magwarn(ms, \"syntax error: `else'\");\n\t\t\treturn -1;\n\t\t}\n\t\tlast_cond = COND_NONE;\n\t\tbreak;\n\n\tcase COND_NONE:\n\t\tlast_cond = COND_NONE;\n\t\tbreak;\n\t}\n\n\tms->c.li[cont_level].last_cond = last_cond;\n\treturn 0;\n}\n#endif /* ENABLE_CONDITIONALS */\n\n/*\n * parse one line from magic file, put into magic[index++] if valid\n */\nprivate int\nparse(struct magic_set *ms, struct magic_entry *me, const char *line,\n    size_t lineno, int action)\n{\n#ifdef ENABLE_CONDITIONALS\n\tstatic uint32_t last_cont_level = 0;\n#endif\n\tsize_t i;\n\tstruct magic *m;\n\tconst char *l = line;\n\tchar *t;\n\tint op;\n\tuint32_t cont_level;\n\tint32_t diff;\n\n\tcont_level = 0;\n\n\t/*\n\t * Parse the offset.\n\t */\n\twhile (*l == '>') {\n\t\t++l;\t\t/* step over */\n\t\tcont_level++; \n\t}\n#ifdef ENABLE_CONDITIONALS\n\tif (cont_level == 0 || cont_level > last_cont_level)\n\t\tif (file_check_mem(ms, cont_level) == -1)\n\t\t\treturn -1;\n\tlast_cont_level = cont_level;\n#endif\n\tif (cont_level != 0) {\n\t\tif (me->mp == NULL) {\n\t\t\tfile_magerror(ms, \"No current entry for continuation\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (me->cont_count == 0) {\n\t\t\tfile_magerror(ms, \"Continuations present with 0 count\");\n\t\t\treturn -1;\n\t\t}\n\t\tm = &me->mp[me->cont_count - 1];\n\t\tdiff = (int32_t)cont_level - (int32_t)m->cont_level;\n\t\tif (diff > 1)\n\t\t\tfile_magwarn(ms, \"New continuation level %u is more \"\n\t\t\t    \"than one larger than current level %u\", cont_level,\n\t\t\t    m->cont_level);\n\t\tif (me->cont_count == me->max_count) {\n\t\t\tstruct magic *nm;\n\t\t\tsize_t cnt = me->max_count + ALLOC_CHUNK;\n\t\t\tif ((nm = CAST(struct magic *, realloc(me->mp,\n\t\t\t    sizeof(*nm) * cnt))) == NULL) {\n\t\t\t\tfile_oomem(ms, sizeof(*nm) * cnt);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tme->mp = m = nm;\n\t\t\tme->max_count = CAST(uint32_t, cnt);\n\t\t}\n\t\tm = &me->mp[me->cont_count++];\n\t\t(void)memset(m, 0, sizeof(*m));\n\t\tm->cont_level = cont_level;\n\t} else {\n\t\tstatic const size_t len = sizeof(*m) * ALLOC_CHUNK;\n\t\tif (me->mp != NULL)\n\t\t\treturn 1;\n\t\tif ((m = CAST(struct magic *, malloc(len))) == NULL) {\n\t\t\tfile_oomem(ms, len);\n\t\t\treturn -1;\n\t\t}\n\t\tme->mp = m;\n\t\tme->max_count = ALLOC_CHUNK;\n\t\t(void)memset(m, 0, sizeof(*m));\n\t\tm->factor_op = FILE_FACTOR_OP_NONE;\n\t\tm->cont_level = 0;\n\t\tme->cont_count = 1;\n\t}\n\tm->lineno = CAST(uint32_t, lineno);\n\n\tif (*l == '&') {  /* m->cont_level == 0 checked below. */\n                ++l;            /* step over */\n                m->flag |= OFFADD;\n        }\n\tif (*l == '(') {\n\t\t++l;\t\t/* step over */\n\t\tm->flag |= INDIR;\n\t\tif (m->flag & OFFADD)\n\t\t\tm->flag = (m->flag & ~OFFADD) | INDIROFFADD;\n\n\t\tif (*l == '&') {  /* m->cont_level == 0 checked below */\n\t\t\t++l;            /* step over */\n\t\t\tm->flag |= OFFADD;\n\t\t}\n\t}\n\t/* Indirect offsets are not valid at level 0. */\n\tif (m->cont_level == 0 && (m->flag & (OFFADD | INDIROFFADD)))\n\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\tfile_magwarn(ms, \"relative offset at level 0\");\n\n\t/* get offset, then skip over it */\n\tm->offset = (uint32_t)strtoul(l, &t, 0);\n        if (l == t)\n\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\tfile_magwarn(ms, \"offset `%s' invalid\", l);\n        l = t;\n\n\tif (m->flag & INDIR) {\n\t\tm->in_type = FILE_LONG;\n\t\tm->in_offset = 0;\n\t\t/*\n\t\t * read [.lbs][+-]nnnnn)\n\t\t */\n\t\tif (*l == '.') {\n\t\t\tl++;\n\t\t\tswitch (*l) {\n\t\t\tcase 'l':\n\t\t\t\tm->in_type = FILE_LELONG;\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\tm->in_type = FILE_BELONG;\n\t\t\t\tbreak;\n\t\t\tcase 'm':\n\t\t\t\tm->in_type = FILE_MELONG;\n\t\t\t\tbreak;\n\t\t\tcase 'h':\n\t\t\tcase 's':\n\t\t\t\tm->in_type = FILE_LESHORT;\n\t\t\t\tbreak;\n\t\t\tcase 'H':\n\t\t\tcase 'S':\n\t\t\t\tm->in_type = FILE_BESHORT;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\tcase 'b':\n\t\t\tcase 'C':\n\t\t\tcase 'B':\n\t\t\t\tm->in_type = FILE_BYTE;\n\t\t\t\tbreak;\n\t\t\tcase 'e':\n\t\t\tcase 'f':\n\t\t\tcase 'g':\n\t\t\t\tm->in_type = FILE_LEDOUBLE;\n\t\t\t\tbreak;\n\t\t\tcase 'E':\n\t\t\tcase 'F':\n\t\t\tcase 'G':\n\t\t\t\tm->in_type = FILE_BEDOUBLE;\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\tm->in_type = FILE_LEID3;\n\t\t\t\tbreak;\n\t\t\tcase 'I':\n\t\t\t\tm->in_type = FILE_BEID3;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\t\t\tfile_magwarn(ms,\n\t\t\t\t\t    \"indirect offset type `%c' invalid\",\n\t\t\t\t\t    *l);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tl++;\n\t\t}\n\n\t\tm->in_op = 0;\n\t\tif (*l == '~') {\n\t\t\tm->in_op |= FILE_OPINVERSE;\n\t\t\tl++;\n\t\t}\n\t\tif ((op = get_op(*l)) != -1) {\n\t\t\tm->in_op |= op;\n\t\t\tl++;\n\t\t}\n\t\tif (*l == '(') {\n\t\t\tm->in_op |= FILE_OPINDIRECT;\n\t\t\tl++;\n\t\t}\n\t\tif (isdigit((unsigned char)*l) || *l == '-') {\n\t\t\tm->in_offset = (int32_t)strtol(l, &t, 0);\n\t\t\tif (l == t)\n\t\t\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\t\t\tfile_magwarn(ms,\n\t\t\t\t\t    \"in_offset `%s' invalid\", l);\n\t\t\tl = t;\n\t\t}\n\t\tif (*l++ != ')' || \n\t\t    ((m->in_op & FILE_OPINDIRECT) && *l++ != ')'))\n\t\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\t\tfile_magwarn(ms,\n\t\t\t\t    \"missing ')' in indirect offset\");\n\t}\n\tEATAB;\n\n#ifdef ENABLE_CONDITIONALS\n\tm->cond = get_cond(l, &l);\n\tif (check_cond(ms, m->cond, cont_level) == -1)\n\t\treturn -1;\n\n\tEATAB;\n#endif\n\n\t/*\n\t * Parse the type.\n\t */\n\tif (*l == 'u') {\n\t\t/*\n\t\t * Try it as a keyword type prefixed by \"u\"; match what\n\t\t * follows the \"u\".  If that fails, try it as an SUS\n\t\t * integer type. \n\t\t */\n\t\tm->type = get_type(type_tbl, l + 1, &l);\n\t\tif (m->type == FILE_INVALID) {\n\t\t\t/*\n\t\t\t * Not a keyword type; parse it as an SUS type,\n\t\t\t * 'u' possibly followed by a number or C/S/L.\n\t\t\t */\n\t\t\tm->type = get_standard_integer_type(l, &l);\n\t\t}\n\t\t/* It's unsigned. */\n\t\tif (m->type != FILE_INVALID)\n\t\t\tm->flag |= UNSIGNED;\n\t} else {\n\t\t/*\n\t\t * Try it as a keyword type.  If that fails, try it as\n\t\t * an SUS integer type if it begins with \"d\" or as an\n\t\t * SUS string type if it begins with \"s\".  In any case,\n\t\t * it's not unsigned.\n\t\t */\n\t\tm->type = get_type(type_tbl, l, &l);\n\t\tif (m->type == FILE_INVALID) {\n\t\t\t/*\n\t\t\t * Not a keyword type; parse it as an SUS type,\n\t\t\t * either 'd' possibly followed by a number or\n\t\t\t * C/S/L, or just 's'.\n\t\t\t */\n\t\t\tif (*l == 'd')\n\t\t\t\tm->type = get_standard_integer_type(l, &l);\n\t\t\telse if (*l == 's' && !isalpha((unsigned char)l[1])) {\n\t\t\t\tm->type = FILE_STRING;\n\t\t\t\t++l;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (m->type == FILE_INVALID) {\n\t\t/* Not found - try it as a special keyword. */\n\t\tm->type = get_type(special_tbl, l, &l);\n\t}\n\t\t\t\n\tif (m->type == FILE_INVALID) {\n\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\tfile_magwarn(ms, \"type `%s' invalid\", l);\n\t\treturn -1;\n\t}\n\n\t/* New-style anding: \"0 byte&0x80 =0x80 dynamically linked\" */\n\t/* New and improved: ~ & | ^ + - * / % -- exciting, isn't it? */\n\n\tm->mask_op = 0;\n\tif (*l == '~') {\n\t\tif (!IS_STRING(m->type))\n\t\t\tm->mask_op |= FILE_OPINVERSE;\n\t\telse if (ms->flags & MAGIC_CHECK)\n\t\t\tfile_magwarn(ms, \"'~' invalid for string types\");\n\t\t++l;\n\t}\n\tm->str_range = 0;\n\tm->str_flags = m->type == FILE_PSTRING ? PSTRING_1_LE : 0;\n\tif ((op = get_op(*l)) != -1) {\n\t\tif (!IS_STRING(m->type)) {\n\t\t\tuint64_t val;\n\t\t\t++l;\n\t\t\tm->mask_op |= op;\n\t\t\tval = (uint64_t)strtoull(l, &t, 0);\n\t\t\tl = t;\n\t\t\tm->num_mask = file_signextend(ms, m, val);\n\t\t\teatsize(&l);\n\t\t}\n\t\telse if (op == FILE_OPDIVIDE) {\n\t\t\tint have_range = 0;\n\t\t\twhile (!isspace((unsigned char)*++l)) {\n\t\t\t\tswitch (*l) {\n\t\t\t\tcase '0':  case '1':  case '2':\n\t\t\t\tcase '3':  case '4':  case '5':\n\t\t\t\tcase '6':  case '7':  case '8':\n\t\t\t\tcase '9':\n\t\t\t\t\tif (have_range &&\n\t\t\t\t\t    (ms->flags & MAGIC_CHECK))\n\t\t\t\t\t\tfile_magwarn(ms,\n\t\t\t\t\t\t    \"multiple ranges\");\n\t\t\t\t\thave_range = 1;\n\t\t\t\t\tm->str_range = CAST(uint32_t,\n\t\t\t\t\t    strtoul(l, &t, 0));\n\t\t\t\t\tif (m->str_range == 0)\n\t\t\t\t\t\tfile_magwarn(ms,\n\t\t\t\t\t\t    \"zero range\");\n\t\t\t\t\tl = t - 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHAR_COMPACT_WHITESPACE:\n\t\t\t\t\tm->str_flags |=\n\t\t\t\t\t    STRING_COMPACT_WHITESPACE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHAR_COMPACT_OPTIONAL_WHITESPACE:\n\t\t\t\t\tm->str_flags |=\n\t\t\t\t\t    STRING_COMPACT_OPTIONAL_WHITESPACE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHAR_IGNORE_LOWERCASE:\n\t\t\t\t\tm->str_flags |= STRING_IGNORE_LOWERCASE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHAR_IGNORE_UPPERCASE:\n\t\t\t\t\tm->str_flags |= STRING_IGNORE_UPPERCASE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHAR_REGEX_OFFSET_START:\n\t\t\t\t\tm->str_flags |= REGEX_OFFSET_START;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHAR_BINTEST:\n\t\t\t\t\tm->str_flags |= STRING_BINTEST;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHAR_TEXTTEST:\n\t\t\t\t\tm->str_flags |= STRING_TEXTTEST;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHAR_TRIM:\n\t\t\t\t\tm->str_flags |= STRING_TRIM;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHAR_PSTRING_1_LE:\n\t\t\t\t\tif (m->type != FILE_PSTRING)\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tm->str_flags = (m->str_flags & ~PSTRING_LEN) | PSTRING_1_LE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHAR_PSTRING_2_BE:\n\t\t\t\t\tif (m->type != FILE_PSTRING)\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tm->str_flags = (m->str_flags & ~PSTRING_LEN) | PSTRING_2_BE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHAR_PSTRING_2_LE:\n\t\t\t\t\tif (m->type != FILE_PSTRING)\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tm->str_flags = (m->str_flags & ~PSTRING_LEN) | PSTRING_2_LE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHAR_PSTRING_4_BE:\n\t\t\t\t\tif (m->type != FILE_PSTRING)\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tm->str_flags = (m->str_flags & ~PSTRING_LEN) | PSTRING_4_BE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHAR_PSTRING_4_LE:\n\t\t\t\t\tif (m->type != FILE_PSTRING)\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tm->str_flags = (m->str_flags & ~PSTRING_LEN) | PSTRING_4_LE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHAR_PSTRING_LENGTH_INCLUDES_ITSELF:\n\t\t\t\t\tif (m->type != FILE_PSTRING)\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tm->str_flags |= PSTRING_LENGTH_INCLUDES_ITSELF;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\tbad:\n\t\t\t\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\t\t\t\tfile_magwarn(ms,\n\t\t\t\t\t\t    \"string extension `%c' \"\n\t\t\t\t\t\t    \"invalid\", *l);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\t/* allow multiple '/' for readability */\n\t\t\t\tif (l[1] == '/' &&\n\t\t\t\t    !isspace((unsigned char)l[2]))\n\t\t\t\t\tl++;\n\t\t\t}\n\t\t\tif (string_modifier_check(ms, m) == -1)\n\t\t\t\treturn -1;\n\t\t}\n\t\telse {\n\t\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\t\tfile_magwarn(ms, \"invalid string op: %c\", *t);\n\t\t\treturn -1;\n\t\t}\n\t}\n\t/*\n\t * We used to set mask to all 1's here, instead let's just not do\n\t * anything if mask = 0 (unless you have a better idea)\n\t */\n\tEATAB;\n  \n\tswitch (*l) {\n\tcase '>':\n\tcase '<':\n  \t\tm->reln = *l;\n  \t\t++l;\n\t\tif (*l == '=') {\n\t\t\tif (ms->flags & MAGIC_CHECK) {\n\t\t\t\tfile_magwarn(ms, \"%c= not supported\",\n\t\t\t\t    m->reln);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t   ++l;\n\t\t}\n\t\tbreak;\n\t/* Old-style anding: \"0 byte &0x80 dynamically linked\" */\n\tcase '&':\n\tcase '^':\n\tcase '=':\n  \t\tm->reln = *l;\n  \t\t++l;\n\t\tif (*l == '=') {\n\t\t   /* HP compat: ignore &= etc. */\n\t\t   ++l;\n\t\t}\n\t\tbreak;\n\tcase '!':\n\t\tm->reln = *l;\n\t\t++l;\n\t\tbreak;\n\tdefault:\n  \t\tm->reln = '=';\t/* the default relation */\n\t\tif (*l == 'x' && ((isascii((unsigned char)l[1]) && \n\t\t    isspace((unsigned char)l[1])) || !l[1])) {\n\t\t\tm->reln = *l;\n\t\t\t++l;\n\t\t}\n\t\tbreak;\n\t}\n\t/*\n\t * Grab the value part, except for an 'x' reln.\n\t */\n\tif (m->reln != 'x' && getvalue(ms, m, &l, action))\n\t\treturn -1;\n\n\t/*\n\t * TODO finish this macro and start using it!\n\t * #define offsetcheck {if (offset > HOWMANY-1) \n\t *\tmagwarn(\"offset too big\"); }\n\t */\n\n\t/*\n\t * Now get last part - the description\n\t */\n\tEATAB;\n\tif (l[0] == '\\b') {\n\t\t++l;\n\t\tm->flag |= NOSPACE;\n\t} else if ((l[0] == '\\\\') && (l[1] == 'b')) {\n\t\t++l;\n\t\t++l;\n\t\tm->flag |= NOSPACE;\n\t}\n\tfor (i = 0; (m->desc[i++] = *l++) != '\\0' && i < sizeof(m->desc); )\n\t\tcontinue;\n\tif (i == sizeof(m->desc)) {\n\t\tm->desc[sizeof(m->desc) - 1] = '\\0';\n\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\tfile_magwarn(ms, \"description `%s' truncated\", m->desc);\n\t}\n\n        /*\n\t * We only do this check while compiling, or if any of the magic\n\t * files were not compiled.\n         */\n        if (ms->flags & MAGIC_CHECK) {\n\t\tif (check_format(ms, m) == -1)\n\t\t\treturn -1;\n\t}\n#ifndef COMPILE_ONLY\n\tif (action == FILE_CHECK) {\n\t\tfile_mdump(m);\n\t}\n#endif\n\tm->mimetype[0] = '\\0';\t\t/* initialise MIME type to none */\n\treturn 0;\n}\n\n/*\n * parse a STRENGTH annotation line from magic file, put into magic[index - 1]\n * if valid\n */\nprivate int\nparse_strength(struct magic_set *ms, struct magic_entry *me, const char *line)\n{\n\tconst char *l = line;\n\tchar *el;\n\tunsigned long factor;\n\tstruct magic *m = &me->mp[0];\n\n\tif (m->factor_op != FILE_FACTOR_OP_NONE) {\n\t\tfile_magwarn(ms,\n\t\t    \"Current entry already has a strength type: %c %d\",\n\t\t    m->factor_op, m->factor);\n\t\treturn -1;\n\t}\n\tif (m->type == FILE_NAME) {\n\t\tfile_magwarn(ms, \"%s: Strength setting is not supported in \"\n\t\t    \"\\\"name\\\" magic entries\", m->value.s);\n\t\treturn -1;\n\t}\n\tEATAB;\n\tswitch (*l) {\n\tcase FILE_FACTOR_OP_NONE:\n\tcase FILE_FACTOR_OP_PLUS:\n\tcase FILE_FACTOR_OP_MINUS:\n\tcase FILE_FACTOR_OP_TIMES:\n\tcase FILE_FACTOR_OP_DIV:\n\t\tm->factor_op = *l++;\n\t\tbreak;\n\tdefault:\n\t\tfile_magwarn(ms, \"Unknown factor op `%c'\", *l);\n\t\treturn -1;\n\t}\n\tEATAB;\n\tfactor = strtoul(l, &el, 0);\n\tif (factor > 255) {\n\t\tfile_magwarn(ms, \"Too large factor `%lu'\", factor);\n\t\tgoto out;\n\t}\n\tif (*el && !isspace((unsigned char)*el)) {\n\t\tfile_magwarn(ms, \"Bad factor `%s'\", l);\n\t\tgoto out;\n\t}\n\tm->factor = (uint8_t)factor;\n\tif (m->factor == 0 && m->factor_op == FILE_FACTOR_OP_DIV) {\n\t\tfile_magwarn(ms, \"Cannot have factor op `%c' and factor %u\",\n\t\t    m->factor_op, m->factor);\n\t\tgoto out;\n\t}\n\treturn 0;\nout:\n\tm->factor_op = FILE_FACTOR_OP_NONE;\n\tm->factor = 0;\n\treturn -1;\n}\n\nprivate int\nparse_extra(struct magic_set *ms, struct magic_entry *me, const char *line,\n    off_t off, size_t len, const char *name, int nt)\n{\n\tsize_t i;\n\tconst char *l = line;\n\tstruct magic *m = &me->mp[me->cont_count == 0 ? 0 : me->cont_count - 1];\n\tchar *buf = (char *)m + off;\n\n\tif (buf[0] != '\\0') {\n\t\tlen = nt ? strlen(buf) : len;\n\t\tfile_magwarn(ms, \"Current entry already has a %s type \"\n\t\t    \"`%.*s', new type `%s'\", name, (int)len, buf, l);\n\t\treturn -1;\n\t}\t\n\n\tif (*m->desc == '\\0') {\n\t\tfile_magwarn(ms, \"Current entry does not yet have a \"\n\t\t    \"description for adding a %s type\", name);\n\t\treturn -1;\n\t}\n\n\tEATAB;\n\tfor (i = 0; *l && ((isascii((unsigned char)*l) &&\n\t    isalnum((unsigned char)*l)) || strchr(\"-+/.\", *l)) &&\n\t    i < len; buf[i++] = *l++)\n\t\tcontinue;\n\n\tif (i == len && *l) {\n\t\tif (nt)\n\t\t\tbuf[len - 1] = '\\0';\n\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\tfile_magwarn(ms, \"%s type `%s' truncated %\"\n\t\t\t    SIZE_T_FORMAT \"u\", name, line, i);\n\t} else {\n\t\tif (nt)\n\t\t\tbuf[i] = '\\0';\n\t}\n\n\tif (i > 0)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}\n\n/*\n * Parse an Apple CREATOR/TYPE annotation from magic file and put it into\n * magic[index - 1]\n */\nprivate int\nparse_apple(struct magic_set *ms, struct magic_entry *me, const char *line)\n{\n\tstruct magic *m = &me->mp[0];\n\n\treturn parse_extra(ms, me, line, offsetof(struct magic, apple),\n\t    sizeof(m->apple), \"APPLE\", 0);\n}\n\n/*\n * parse a MIME annotation line from magic file, put into magic[index - 1]\n * if valid\n */\nprivate int\nparse_mime(struct magic_set *ms, struct magic_entry *me, const char *line)\n{\n\tstruct magic *m = &me->mp[0];\n\n\treturn parse_extra(ms, me, line, offsetof(struct magic, mimetype),\n\t    sizeof(m->mimetype), \"MIME\", 1);\n}\n\nprivate int\ncheck_format_type(const char *ptr, int type)\n{\n\tint quad = 0, h;\n\tif (*ptr == '\\0') {\n\t\t/* Missing format string; bad */\n\t\treturn -1;\n\t}\n\n\tswitch (file_formats[type]) {\n\tcase FILE_FMT_QUAD:\n\t\tquad = 1;\n\t\t/*FALLTHROUGH*/\n\tcase FILE_FMT_NUM:\n\t\tif (quad == 0) {\n\t\t\tswitch (type) {\n\t\t\tcase FILE_BYTE:\n\t\t\t\th = 2;\n\t\t\t\tbreak;\n\t\t\tcase FILE_SHORT:\n\t\t\tcase FILE_BESHORT:\n\t\t\tcase FILE_LESHORT:\n\t\t\t\th = 1;\n\t\t\t\tbreak;\n\t\t\tcase FILE_LONG:\n\t\t\tcase FILE_BELONG:\n\t\t\tcase FILE_LELONG:\n\t\t\tcase FILE_MELONG:\n\t\t\tcase FILE_LEID3:\n\t\t\tcase FILE_BEID3:\n\t\t\tcase FILE_INDIRECT:\n\t\t\t\th = 0;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tabort();\n\t\t\t}\n\t\t} else\n\t\t\th = 0;\n\t\tif (*ptr == '-')\n\t\t\tptr++;\n\t\tif (*ptr == '.')\n\t\t\tptr++;\n\t\twhile (isdigit((unsigned char)*ptr)) ptr++;\n\t\tif (*ptr == '.')\n\t\t\tptr++;\n\t\twhile (isdigit((unsigned char)*ptr)) ptr++;\n\t\tif (quad) {\n\t\t\tif (*ptr++ != 'l')\n\t\t\t\treturn -1;\n\t\t\tif (*ptr++ != 'l')\n\t\t\t\treturn -1;\n\t\t}\n\t\n\t\tswitch (*ptr++) {\n#ifdef STRICT_FORMAT \t/* \"long\" formats are int formats for us */\n\t\t/* so don't accept the 'l' modifier */\n\t\tcase 'l':\n\t\t\tswitch (*ptr++) {\n\t\t\tcase 'i':\n\t\t\tcase 'd':\n\t\t\tcase 'u':\n\t\t\tcase 'o':\n\t\t\tcase 'x':\n\t\t\tcase 'X':\n\t\t\t\treturn h != 0 ? -1 : 0;\n\t\t\tdefault:\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\n\t\t/*\n\t\t * Don't accept h and hh modifiers. They make writing\n\t\t * magic entries more complicated, for very little benefit\n\t\t */\n\t\tcase 'h':\n\t\t\tif (h-- <= 0)\n\t\t\t\treturn -1;\n\t\t\tswitch (*ptr++) {\n\t\t\tcase 'h':\n\t\t\t\tif (h-- <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t\tswitch (*ptr++) {\n\t\t\t\tcase 'i':\n\t\t\t\tcase 'd':\n\t\t\t\tcase 'u':\n\t\t\t\tcase 'o':\n\t\t\t\tcase 'x':\n\t\t\t\tcase 'X':\n\t\t\t\t\treturn 0;\n\t\t\t\tdefault:\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\tcase 'i':\n\t\t\tcase 'd':\n\t\t\tcase 'u':\n\t\t\tcase 'o':\n\t\t\tcase 'x':\n\t\t\tcase 'X':\n\t\t\t\treturn h != 0 ? -1 : 0;\n\t\t\tdefault:\n\t\t\t\treturn -1;\n\t\t\t}\n#endif\n\t\tcase 'c':\n\t\t\treturn h != 2 ? -1 : 0;\n\t\tcase 'i':\n\t\tcase 'd':\n\t\tcase 'u':\n\t\tcase 'o':\n\t\tcase 'x':\n\t\tcase 'X':\n#ifdef STRICT_FORMAT\n\t\t\treturn h != 0 ? -1 : 0;\n#else\n\t\t\treturn 0;\n#endif\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t\t\n\tcase FILE_FMT_FLOAT:\n\tcase FILE_FMT_DOUBLE:\n\t\tif (*ptr == '-')\n\t\t\tptr++;\n\t\tif (*ptr == '.')\n\t\t\tptr++;\n\t\twhile (isdigit((unsigned char)*ptr)) ptr++;\n\t\tif (*ptr == '.')\n\t\t\tptr++;\n\t\twhile (isdigit((unsigned char)*ptr)) ptr++;\n\t\n\t\tswitch (*ptr++) {\n\t\tcase 'e':\n\t\tcase 'E':\n\t\tcase 'f':\n\t\tcase 'F':\n\t\tcase 'g':\n\t\tcase 'G':\n\t\t\treturn 0;\n\t\t\t\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t\t\n\n\tcase FILE_FMT_STR:\n\t\tif (*ptr == '-')\n\t\t\tptr++;\n\t\twhile (isdigit((unsigned char )*ptr))\n\t\t\tptr++;\n\t\tif (*ptr == '.') {\n\t\t\tptr++;\n\t\t\twhile (isdigit((unsigned char )*ptr))\n\t\t\t\tptr++;\n\t\t}\n\t\t\n\t\tswitch (*ptr++) {\n\t\tcase 's':\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t\t\n\tdefault:\n\t\t/* internal error */\n\t\tabort();\n\t}\n\t/*NOTREACHED*/\n\treturn -1;\n}\n\t\n/*\n * Check that the optional printf format in description matches\n * the type of the magic.\n */\nprivate int\ncheck_format(struct magic_set *ms, struct magic *m)\n{\n\tchar *ptr;\n\n\tfor (ptr = m->desc; *ptr; ptr++)\n\t\tif (*ptr == '%')\n\t\t\tbreak;\n\tif (*ptr == '\\0') {\n\t\t/* No format string; ok */\n\t\treturn 1;\n\t}\n\n\tassert(file_nformats == file_nnames);\n\n\tif (m->type >= file_nformats) {\n\t\tfile_magwarn(ms, \"Internal error inconsistency between \"\n\t\t    \"m->type and format strings\");\t\t\n\t\treturn -1;\n\t}\n\tif (file_formats[m->type] == FILE_FMT_NONE) {\n\t\tfile_magwarn(ms, \"No format string for `%s' with description \"\n\t\t    \"`%s'\", m->desc, file_names[m->type]);\n\t\treturn -1;\n\t}\n\n\tptr++;\n\tif (check_format_type(ptr, m->type) == -1) {\n\t\t/*\n\t\t * TODO: this error message is unhelpful if the format\n\t\t * string is not one character long\n\t\t */\n\t\tfile_magwarn(ms, \"Printf format `%c' is not valid for type \"\n\t\t    \"`%s' in description `%s'\", *ptr ? *ptr : '?',\n\t\t    file_names[m->type], m->desc);\n\t\treturn -1;\n\t}\n\t\n\tfor (; *ptr; ptr++) {\n\t\tif (*ptr == '%') {\n\t\t\tfile_magwarn(ms,\n\t\t\t    \"Too many format strings (should have at most one) \"\n\t\t\t    \"for `%s' with description `%s'\",\n\t\t\t    file_names[m->type], m->desc);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/* \n * Read a numeric value from a pointer, into the value union of a magic \n * pointer, according to the magic type.  Update the string pointer to point \n * just after the number read.  Return 0 for success, non-zero for failure.\n */\nprivate int\ngetvalue(struct magic_set *ms, struct magic *m, const char **p, int action)\n{\n\tswitch (m->type) {\n\tcase FILE_BESTRING16:\n\tcase FILE_LESTRING16:\n\tcase FILE_STRING:\n\tcase FILE_PSTRING:\n\tcase FILE_REGEX:\n\tcase FILE_SEARCH:\n\tcase FILE_NAME:\n\tcase FILE_USE:\n\t\t*p = getstr(ms, m, *p, action == FILE_COMPILE);\n\t\tif (*p == NULL) {\n\t\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\t\tfile_magwarn(ms, \"cannot get string from `%s'\",\n\t\t\t\t    m->value.s);\n\t\t\treturn -1;\n\t\t}\n\t\tif (m->type == FILE_REGEX) {\n\t\t\tfile_regex_t rx;\n\t\t\tint rc = file_regcomp(&rx, m->value.s, REG_EXTENDED);\n\t\t\tif (rc) {\n\t\t\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\t\t\tfile_regerror(&rx, rc, ms);\n\t\t\t}\n\t\t\tfile_regfree(&rx);\n\t\t\treturn rc ? -1 : 0;\n\t\t}\n\t\treturn 0;\n\tcase FILE_FLOAT:\n\tcase FILE_BEFLOAT:\n\tcase FILE_LEFLOAT:\n\t\tif (m->reln != 'x') {\n\t\t\tchar *ep;\n#ifdef HAVE_STRTOF\n\t\t\tm->value.f = strtof(*p, &ep);\n#else\n\t\t\tm->value.f = (float)strtod(*p, &ep);\n#endif\n\t\t\t*p = ep;\n\t\t}\n\t\treturn 0;\n\tcase FILE_DOUBLE:\n\tcase FILE_BEDOUBLE:\n\tcase FILE_LEDOUBLE:\n\t\tif (m->reln != 'x') {\n\t\t\tchar *ep;\n\t\t\tm->value.d = strtod(*p, &ep);\n\t\t\t*p = ep;\n\t\t}\n\t\treturn 0;\n\tdefault:\n\t\tif (m->reln != 'x') {\n\t\t\tchar *ep;\n\t\t\tm->value.q = file_signextend(ms, m,\n\t\t\t    (uint64_t)strtoull(*p, &ep, 0));\n\t\t\t*p = ep;\n\t\t\teatsize(p);\n\t\t}\n\t\treturn 0;\n\t}\n}\n\n/*\n * Convert a string containing C character escapes.  Stop at an unescaped\n * space or tab.\n * Copy the converted version to \"m->value.s\", and the length in m->vallen.\n * Return updated scan pointer as function result. Warn if set.\n */\nprivate const char *\ngetstr(struct magic_set *ms, struct magic *m, const char *s, int warn)\n{\n\tconst char *origs = s;\n\tchar\t*p = m->value.s;\n\tsize_t  plen = sizeof(m->value.s);\n\tchar \t*origp = p;\n\tchar\t*pmax = p + plen - 1;\n\tint\tc;\n\tint\tval;\n\n\twhile ((c = *s++) != '\\0') {\n\t\tif (isspace((unsigned char) c))\n\t\t\tbreak;\n\t\tif (p >= pmax) {\n\t\t\tfile_error(ms, 0, \"string too long: `%s'\", origs);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (c == '\\\\') {\n\t\t\tswitch(c = *s++) {\n\n\t\t\tcase '\\0':\n\t\t\t\tif (warn)\n\t\t\t\t\tfile_magwarn(ms, \"incomplete escape\");\n\t\t\t\tgoto out;\n\n\t\t\tcase '\\t':\n\t\t\t\tif (warn) {\n\t\t\t\t\tfile_magwarn(ms,\n\t\t\t\t\t    \"escaped tab found, use \\\\t instead\");\n\t\t\t\t\twarn = 0;\t/* already did */\n\t\t\t\t}\n\t\t\t\t/*FALLTHROUGH*/\n\t\t\tdefault:\n\t\t\t\tif (warn) {\n\t\t\t\t\tif (isprint((unsigned char)c)) {\n\t\t\t\t\t\t/* Allow escaping of \n\t\t\t\t\t\t * ``relations'' */\n\t\t\t\t\t\tif (strchr(\"<>&^=!\", c) == NULL\n\t\t\t\t\t\t    && (m->type != FILE_REGEX ||\n\t\t\t\t\t\t    strchr(\"[]().*?^$|{}\", c)\n\t\t\t\t\t\t    == NULL)) {\n\t\t\t\t\t\t\tfile_magwarn(ms, \"no \"\n\t\t\t\t\t\t\t    \"need to escape \"\n\t\t\t\t\t\t\t    \"`%c'\", c);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfile_magwarn(ms,\n\t\t\t\t\t\t    \"unknown escape sequence: \"\n\t\t\t\t\t\t    \"\\\\%03o\", c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*FALLTHROUGH*/\n\t\t\t/* space, perhaps force people to use \\040? */\n\t\t\tcase ' ':\n#if 0\n\t\t\t/*\n\t\t\t * Other things people escape, but shouldn't need to,\n\t\t\t * so we disallow them\n\t\t\t */\n\t\t\tcase '\\'':\n\t\t\tcase '\"':\n\t\t\tcase '?':\n#endif\n\t\t\t/* Relations */\n\t\t\tcase '>':\n\t\t\tcase '<':\n\t\t\tcase '&':\n\t\t\tcase '^':\n\t\t\tcase '=':\n\t\t\tcase '!':\n\t\t\t/* and baskslash itself */\n\t\t\tcase '\\\\':\n\t\t\t\t*p++ = (char) c;\n\t\t\t\tbreak;\n\n\t\t\tcase 'a':\n\t\t\t\t*p++ = '\\a';\n\t\t\t\tbreak;\n\n\t\t\tcase 'b':\n\t\t\t\t*p++ = '\\b';\n\t\t\t\tbreak;\n\n\t\t\tcase 'f':\n\t\t\t\t*p++ = '\\f';\n\t\t\t\tbreak;\n\n\t\t\tcase 'n':\n\t\t\t\t*p++ = '\\n';\n\t\t\t\tbreak;\n\n\t\t\tcase 'r':\n\t\t\t\t*p++ = '\\r';\n\t\t\t\tbreak;\n\n\t\t\tcase 't':\n\t\t\t\t*p++ = '\\t';\n\t\t\t\tbreak;\n\n\t\t\tcase 'v':\n\t\t\t\t*p++ = '\\v';\n\t\t\t\tbreak;\n\n\t\t\t/* \\ and up to 3 octal digits */\n\t\t\tcase '0':\n\t\t\tcase '1':\n\t\t\tcase '2':\n\t\t\tcase '3':\n\t\t\tcase '4':\n\t\t\tcase '5':\n\t\t\tcase '6':\n\t\t\tcase '7':\n\t\t\t\tval = c - '0';\n\t\t\t\tc = *s++;  /* try for 2 */\n\t\t\t\tif (c >= '0' && c <= '7') {\n\t\t\t\t\tval = (val << 3) | (c - '0');\n\t\t\t\t\tc = *s++;  /* try for 3 */\n\t\t\t\t\tif (c >= '0' && c <= '7')\n\t\t\t\t\t\tval = (val << 3) | (c-'0');\n\t\t\t\t\telse\n\t\t\t\t\t\t--s;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\t--s;\n\t\t\t\t*p++ = (char)val;\n\t\t\t\tbreak;\n\n\t\t\t/* \\x and up to 2 hex digits */\n\t\t\tcase 'x':\n\t\t\t\tval = 'x';\t/* Default if no digits */\n\t\t\t\tc = hextoint(*s++);\t/* Get next char */\n\t\t\t\tif (c >= 0) {\n\t\t\t\t\tval = c;\n\t\t\t\t\tc = hextoint(*s++);\n\t\t\t\t\tif (c >= 0)\n\t\t\t\t\t\tval = (val << 4) + c;\n\t\t\t\t\telse\n\t\t\t\t\t\t--s;\n\t\t\t\t} else\n\t\t\t\t\t--s;\n\t\t\t\t*p++ = (char)val;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\t*p++ = (char)c;\n\t}\nout:\n\t*p = '\\0';\n\tm->vallen = CAST(unsigned char, (p - origp));\n\tif (m->type == FILE_PSTRING)\n\t\tm->vallen += (unsigned char)file_pstring_length_size(m);\n\treturn s;\n}\n\n\n/* Single hex char to int; -1 if not a hex char. */\nprivate int\nhextoint(int c)\n{\n\tif (!isascii((unsigned char) c))\n\t\treturn -1;\n\tif (isdigit((unsigned char) c))\n\t\treturn c - '0';\n\tif ((c >= 'a') && (c <= 'f'))\n\t\treturn c + 10 - 'a';\n\tif (( c>= 'A') && (c <= 'F'))\n\t\treturn c + 10 - 'A';\n\treturn -1;\n}\n\n\n/*\n * Print a string containing C character escapes.\n */\nprotected void\nfile_showstr(FILE *fp, const char *s, size_t len)\n{\n\tchar\tc;\n\n\tfor (;;) {\n\t\tif (len == ~0U) {\n\t\t\tc = *s++;\n\t\t\tif (c == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t\telse  {\n\t\t\tif (len-- == 0)\n\t\t\t\tbreak;\n\t\t\tc = *s++;\n\t\t}\n\t\tif (c >= 040 && c <= 0176)\t/* TODO isprint && !iscntrl */\n\t\t\t(void) fputc(c, fp);\n\t\telse {\n\t\t\t(void) fputc('\\\\', fp);\n\t\t\tswitch (c) {\n\t\t\tcase '\\a':\n\t\t\t\t(void) fputc('a', fp);\n\t\t\t\tbreak;\n\n\t\t\tcase '\\b':\n\t\t\t\t(void) fputc('b', fp);\n\t\t\t\tbreak;\n\n\t\t\tcase '\\f':\n\t\t\t\t(void) fputc('f', fp);\n\t\t\t\tbreak;\n\n\t\t\tcase '\\n':\n\t\t\t\t(void) fputc('n', fp);\n\t\t\t\tbreak;\n\n\t\t\tcase '\\r':\n\t\t\t\t(void) fputc('r', fp);\n\t\t\t\tbreak;\n\n\t\t\tcase '\\t':\n\t\t\t\t(void) fputc('t', fp);\n\t\t\t\tbreak;\n\n\t\t\tcase '\\v':\n\t\t\t\t(void) fputc('v', fp);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t(void) fprintf(fp, \"%.3o\", c & 0377);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*\n * eatsize(): Eat the size spec from a number [eg. 10UL]\n */\nprivate void\neatsize(const char **p)\n{\n\tconst char *l = *p;\n\n\tif (LOWCASE(*l) == 'u') \n\t\tl++;\n\n\tswitch (LOWCASE(*l)) {\n\tcase 'l':    /* long */\n\tcase 's':    /* short */\n\tcase 'h':    /* short */\n\tcase 'b':    /* char/byte */\n\tcase 'c':    /* char/byte */\n\t\tl++;\n\t\t/*FALLTHROUGH*/\n\tdefault:\n\t\tbreak;\n\t}\n\n\t*p = l;\n}\n\n/*\n * handle a compiled file.\n */\n\nprivate struct magic_map *\napprentice_map(struct magic_set *ms, const char *fn)\n{\n\tint fd;\n\tstruct stat st;\n\tuint32_t *ptr;\n\tuint32_t version, entries, nentries;\n\tint needsbyteswap;\n\tchar *dbname = NULL;\n\tstruct magic_map *map;\n\tsize_t i;\n\n\tfd = -1;\n\tif ((map = CAST(struct magic_map *, calloc(1, sizeof(*map)))) == NULL) {\n\t\tfile_oomem(ms, sizeof(*map));\n\t\tgoto error;\n\t}\n\n\tdbname = mkdbname(ms, fn, 0);\n\tif (dbname == NULL)\n\t\tgoto error;\n\n\tif ((fd = open(dbname, O_RDONLY|O_BINARY)) == -1)\n\t\tgoto error;\n\n\tif (fstat(fd, &st) == -1) {\n\t\tfile_error(ms, errno, \"cannot stat `%s'\", dbname);\n\t\tgoto error;\n\t}\n\tif (st.st_size < 8 || st.st_size > MAXMAGIC_SIZE) {\n\t\tfile_error(ms, 0, \"file `%s' is too %s\", dbname,\n\t\t    st.st_size < 8 ? \"small\" : \"large\");\n\t\tgoto error;\n\t}\n\n\tmap->len = (size_t)st.st_size;\n#ifdef QUICK\n\tif ((map->p = mmap(0, (size_t)st.st_size, PROT_READ|PROT_WRITE,\n\t    MAP_PRIVATE|MAP_FILE, fd, (off_t)0)) == MAP_FAILED) {\n\t\tfile_error(ms, errno, \"cannot map `%s'\", dbname);\n\t\tgoto error;\n\t}\n#else\n\tif ((map->p = CAST(void *, malloc(map->len))) == NULL) {\n\t\tfile_oomem(ms, map->len);\n\t\tgoto error;\n\t}\n\tif (read(fd, map->p, map->len) != (ssize_t)map->len) {\n\t\tfile_badread(ms);\n\t\tgoto error;\n\t}\n\tmap->len = 0;\n#define RET\t1\n#endif\n\t(void)close(fd);\n\tfd = -1;\n\tptr = CAST(uint32_t *, map->p);\n\tif (*ptr != MAGICNO) {\n\t\tif (swap4(*ptr) != MAGICNO) {\n\t\t\tfile_error(ms, 0, \"bad magic in `%s'\", dbname);\n\t\t\tgoto error;\n\t\t}\n\t\tneedsbyteswap = 1;\n\t} else\n\t\tneedsbyteswap = 0;\n\tif (needsbyteswap)\n\t\tversion = swap4(ptr[1]);\n\telse\n\t\tversion = ptr[1];\n\tif (version != VERSIONNO) {\n\t\tfile_error(ms, 0, \"File %s supports only version %d magic \"\n\t\t    \"files. `%s' is version %d\", VERSION,\n\t\t    VERSIONNO, dbname, version);\n\t\tgoto error;\n\t}\n\tentries = (uint32_t)(st.st_size / sizeof(struct magic));\n\tif ((off_t)(entries * sizeof(struct magic)) != st.st_size) {\n\t\tfile_error(ms, 0, \"Size of `%s' %\" INT64_T_FORMAT \"u is not \"\n\t\t    \"a multiple of %\" SIZE_T_FORMAT \"u\",\n\t\t    dbname, (unsigned long long)st.st_size,\n\t\t    sizeof(struct magic));\n\t\tgoto error;\n\t}\n\tmap->magic[0] = CAST(struct magic *, map->p) + 1;\n\tnentries = 0;\n\tfor (i = 0; i < MAGIC_SETS; i++) {\n\t\tif (needsbyteswap)\n\t\t\tmap->nmagic[i] = swap4(ptr[i + 2]);\n\t\telse\n\t\t\tmap->nmagic[i] = ptr[i + 2];\n\t\tif (i != MAGIC_SETS - 1)\n\t\t\tmap->magic[i + 1] = map->magic[i] + map->nmagic[i];\n\t\tnentries += map->nmagic[i];\n\t}\n\tif (entries != nentries + 1) {\n\t\tfile_error(ms, 0, \"Inconsistent entries in `%s' %u != %u\",\n\t\t    dbname, entries, nentries + 1);\n\t\tgoto error;\n\t}\n\tif (needsbyteswap)\n\t\tfor (i = 0; i < MAGIC_SETS; i++)\n\t\t\tbyteswap(map->magic[i], map->nmagic[i]);\n\tfree(dbname);\n\treturn map;\n\nerror:\n\tif (fd != -1)\n\t\t(void)close(fd);\n\tapprentice_unmap(map);\n\tfree(dbname);\n\treturn NULL;\n}\n\n/*\n * handle an mmaped file.\n */\nprivate int\napprentice_compile(struct magic_set *ms, struct magic_map *map, const char *fn)\n{\n\tstatic const size_t nm = sizeof(*map->nmagic) * MAGIC_SETS;\n\tstatic const size_t m = sizeof(**map->magic);\n\tint fd = -1;\n\tsize_t len;\n\tchar *dbname;\n\tint rv = -1;\n\tuint32_t i;\n\tunion {\n\t\tstruct magic m;\n\t\tuint32_t h[2 + MAGIC_SETS];\n\t} hdr;\n\n\tdbname = mkdbname(ms, fn, 1);\n\n\tif (dbname == NULL) \n\t\tgoto out;\n\n\tif ((fd = open(dbname, O_WRONLY|O_CREAT|O_TRUNC|O_BINARY, 0644)) == -1) \n\t{\n\t\tfile_error(ms, errno, \"cannot open `%s'\", dbname);\n\t\tgoto out;\n\t}\n\tmemset(&hdr, 0, sizeof(hdr));\n\thdr.h[0] = MAGICNO;\n\thdr.h[1] = VERSIONNO;\n\tmemcpy(hdr.h + 2, map->nmagic, nm);\n\n\tif (write(fd, &hdr, sizeof(hdr)) != (ssize_t)sizeof(hdr)) {\n\t\tfile_error(ms, errno, \"error writing `%s'\", dbname);\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < MAGIC_SETS; i++) {\n\t\tlen = m * map->nmagic[i];\n\t\tif (write(fd, map->magic[i], len) != (ssize_t)len) {\n\t\t\tfile_error(ms, errno, \"error writing `%s'\", dbname);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (fd != -1)\n\t\t(void)close(fd);\n\trv = 0;\nout:\n\tfree(dbname);\n\treturn rv;\n}\n\nprivate const char ext[] = \".mgc\";\n/*\n * make a dbname\n */\nprivate char *\nmkdbname(struct magic_set *ms, const char *fn, int strip)\n{\n\tconst char *p, *q;\n\tchar *buf;\n\n\tif (strip) {\n\t\tif ((p = strrchr(fn, '/')) != NULL)\n\t\t\tfn = ++p;\n\t}\n\n\tfor (q = fn; *q; q++)\n\t\tcontinue;\n\t/* Look for .mgc */\n\tfor (p = ext + sizeof(ext) - 1; p >= ext && q >= fn; p--, q--)\n\t\tif (*p != *q)\n\t\t\tbreak;\n\n\t/* Did not find .mgc, restore q */\n\tif (p >= ext)\n\t\twhile (*q)\n\t\t\tq++;\n\n\tq++;\n\t/* Compatibility with old code that looked in .mime */\n\tif (ms->flags & MAGIC_MIME) {\n\t\tif (asprintf(&buf, \"%.*s.mime%s\", (int)(q - fn), fn, ext) < 0)\n\t\t\treturn NULL;\n\t\tif (access(buf, R_OK) != -1) {\n\t\t\tms->flags &= MAGIC_MIME_TYPE;\n\t\t\treturn buf;\n\t\t}\n\t\tfree(buf);\n\t}\n\tif (asprintf(&buf, \"%.*s%s\", (int)(q - fn), fn, ext) < 0)\n\t\treturn NULL;\n\n\t/* Compatibility with old code that looked in .mime */\n\tif (strstr(p, \".mime\") != NULL)\n\t\tms->flags &= MAGIC_MIME_TYPE;\n\treturn buf;\n}\n\n/*\n * Byteswap an mmap'ed file if needed\n */\nprivate void\nbyteswap(struct magic *magic, uint32_t nmagic)\n{\n\tuint32_t i;\n\tfor (i = 0; i < nmagic; i++)\n\t\tbs1(&magic[i]);\n}\n\n/*\n * swap a short\n */\nprivate uint16_t\nswap2(uint16_t sv)\n{\n\tuint16_t rv;\n\tuint8_t *s = (uint8_t *)(void *)&sv; \n\tuint8_t *d = (uint8_t *)(void *)&rv; \n\td[0] = s[1];\n\td[1] = s[0];\n\treturn rv;\n}\n\n/*\n * swap an int\n */\nprivate uint32_t\nswap4(uint32_t sv)\n{\n\tuint32_t rv;\n\tuint8_t *s = (uint8_t *)(void *)&sv; \n\tuint8_t *d = (uint8_t *)(void *)&rv; \n\td[0] = s[3];\n\td[1] = s[2];\n\td[2] = s[1];\n\td[3] = s[0];\n\treturn rv;\n}\n\n/*\n * swap a quad\n */\nprivate uint64_t\nswap8(uint64_t sv)\n{\n\tuint64_t rv;\n\tuint8_t *s = (uint8_t *)(void *)&sv; \n\tuint8_t *d = (uint8_t *)(void *)&rv; \n#if 0\n\td[0] = s[3];\n\td[1] = s[2];\n\td[2] = s[1];\n\td[3] = s[0];\n\td[4] = s[7];\n\td[5] = s[6];\n\td[6] = s[5];\n\td[7] = s[4];\n#else\n\td[0] = s[7];\n\td[1] = s[6];\n\td[2] = s[5];\n\td[3] = s[4];\n\td[4] = s[3];\n\td[5] = s[2];\n\td[6] = s[1];\n\td[7] = s[0];\n#endif\n\treturn rv;\n}\n\n/*\n * byteswap a single magic entry\n */\nprivate void\nbs1(struct magic *m)\n{\n\tm->cont_level = swap2(m->cont_level);\n\tm->offset = swap4((uint32_t)m->offset);\n\tm->in_offset = swap4((uint32_t)m->in_offset);\n\tm->lineno = swap4((uint32_t)m->lineno);\n\tif (IS_STRING(m->type)) {\n\t\tm->str_range = swap4(m->str_range);\n\t\tm->str_flags = swap4(m->str_flags);\n\t}\n\telse {\n\t\tm->value.q = swap8(m->value.q);\n\t\tm->num_mask = swap8(m->num_mask);\n\t}\n}\n\nprotected size_t \nfile_pstring_length_size(const struct magic *m)\n{\n\tswitch (m->str_flags & PSTRING_LEN) {\n\tcase PSTRING_1_LE:\n\t\treturn 1;\n\tcase PSTRING_2_LE:\n\tcase PSTRING_2_BE:\n\t\treturn 2;\n\tcase PSTRING_4_LE:\n\tcase PSTRING_4_BE:\n\t\treturn 4;\n\tdefault:\n\t\tabort();\t/* Impossible */\n\t\treturn 1;\n\t}\n}\nprotected size_t\nfile_pstring_get_length(const struct magic *m, const char *s)\n{\n\tsize_t len = 0;\n\n\tswitch (m->str_flags & PSTRING_LEN) {\n\tcase PSTRING_1_LE:\n\t\tlen = *s;\n\t\tbreak;\n\tcase PSTRING_2_LE:\n\t\tlen = (s[1] << 8) | s[0];\n\t\tbreak;\n\tcase PSTRING_2_BE:\n\t\tlen = (s[0] << 8) | s[1];\n\t\tbreak;\n\tcase PSTRING_4_LE:\n\t\tlen = (s[3] << 24) | (s[2] << 16) | (s[1] << 8) | s[0];\n\t\tbreak;\n\tcase PSTRING_4_BE:\n\t\tlen = (s[0] << 24) | (s[1] << 16) | (s[2] << 8) | s[3];\n\t\tbreak;\n\tdefault:\n\t\tabort();\t/* Impossible */\n\t}\n\n\tif (m->str_flags & PSTRING_LENGTH_INCLUDES_ITSELF)\n\t\tlen -= file_pstring_length_size(m);\n\n\treturn len;\n}\n\nprotected int\nfile_magicfind(struct magic_set *ms, const char *name, struct mlist *v)\n{\n\tuint32_t i, j;\n\tstruct mlist *mlist, *ml;\n\n\tmlist = ms->mlist[1];\n\n\tfor (ml = mlist->next; ml != mlist; ml = ml->next) {\n\t\tstruct magic *ma = ml->magic;\n\t\tuint32_t nma = ml->nmagic;\n\t\tfor (i = 0; i < nma; i++) {\n\t\t\tif (ma[i].type != FILE_NAME)\n\t\t\t\tcontinue;\n\t\t\tif (strcmp(ma[i].value.s, name) == 0) {\n\t\t\t\tv->magic = &ma[i];\n\t\t\t\tfor (j = i + 1; j < nma; j++)\n\t\t\t\t    if (ma[j].cont_level == 0)\n\t\t\t\t\t    break;\n\t\t\t\tv->nmagic = j - i;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n", "/*\n * Copyright (c) Ian F. Darwin 1986-1995.\n * Software written by Ian F. Darwin and others;\n * maintained 1995-present by Christos Zoulas and others.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice immediately at the beginning of the file, without modification,\n *    this list of conditions, and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n/*\n * file.h - definitions for file(1) program\n * @(#)$File: file.h,v 1.150 2014/05/05 20:53:10 christos Exp $\n */\n\n#ifndef __file_h__\n#define __file_h__\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#ifdef WIN32\n  #ifdef _WIN64\n    #define SIZE_T_FORMAT \"I64\"\n  #else\n    #define SIZE_T_FORMAT \"\"\n  #endif\n  #define INT64_T_FORMAT \"I64\"\n#else\n  #define SIZE_T_FORMAT \"z\"\n  #define INT64_T_FORMAT \"ll\"\n#endif\n\n#include <stdio.h>\t/* Include that here, to make sure __P gets defined */\n#include <errno.h>\n#include <fcntl.h>\t/* For open and flags */\n#ifdef HAVE_STDINT_H\n#ifndef __STDC_LIMIT_MACROS\n#define __STDC_LIMIT_MACROS\n#endif\n#include <stdint.h>\n#endif\n#ifdef HAVE_INTTYPES_H\n#include <inttypes.h>\n#endif\n#include <regex.h>\n#include <time.h>\n#include <sys/types.h>\n#include <sys/param.h>\n/* Do this here and now, because struct stat gets re-defined on solaris */\n#include <sys/stat.h>\n#include <stdarg.h>\n\n#define ENABLE_CONDITIONALS\n\n#ifndef MAGIC\n#define MAGIC \"/etc/magic\"\n#endif\n\n#if defined(__EMX__) || defined (WIN32)\n#define PATHSEP\t';'\n#else\n#define PATHSEP\t':'\n#endif\n\n#define private static\n\n#if HAVE_VISIBILITY && !defined(WIN32)\n#define public  __attribute__ ((__visibility__(\"default\")))\n#ifndef protected\n#define protected __attribute__ ((__visibility__(\"hidden\")))\n#endif\n#else\n#define public\n#ifndef protected\n#define protected\n#endif\n#endif\n\n#ifndef __arraycount\n#define __arraycount(a) (sizeof(a) / sizeof(a[0]))\n#endif\n\n#ifndef __GNUC_PREREQ__\n#ifdef __GNUC__\n#define\t__GNUC_PREREQ__(x, y)\t\t\t\t\t\t\\\n\t((__GNUC__ == (x) && __GNUC_MINOR__ >= (y)) ||\t\t\t\\\n\t (__GNUC__ > (x)))\n#else\n#define\t__GNUC_PREREQ__(x, y)\t0\n#endif\n#endif\n\n#ifndef __GNUC__\n#ifndef __attribute__\n#define __attribute__(a)\n#endif\n#endif\n\n#ifndef MIN\n#define\tMIN(a,b)\t(((a) < (b)) ? (a) : (b))\n#endif\n\n#ifndef MAX\n#define\tMAX(a,b)\t(((a) > (b)) ? (a) : (b))\n#endif\n\n#ifndef HOWMANY\n# define HOWMANY (256 * 1024)\t/* how much of the file to look at */\n#endif\n#define MAXMAGIS 8192\t\t/* max entries in any one magic file\n\t\t\t\t   or directory */\n#define MAXDESC\t64\t\t/* max len of text description/MIME type */\n#define MAXMIME\t80\t\t/* max len of text MIME type */\n#define MAXstring 64\t\t/* max len of \"string\" types */\n\n#define MAGICNO\t\t0xF11E041C\n#define VERSIONNO\t11\n#define FILE_MAGICSIZE\t248\n\n#define\tFILE_LOAD\t0\n#define FILE_CHECK\t1\n#define FILE_COMPILE\t2\n#define FILE_LIST\t3\n\nunion VALUETYPE {\n\tuint8_t b;\n\tuint16_t h;\n\tuint32_t l;\n\tuint64_t q;\n\tuint8_t hs[2];\t/* 2 bytes of a fixed-endian \"short\" */\n\tuint8_t hl[4];\t/* 4 bytes of a fixed-endian \"long\" */\n\tuint8_t hq[8];\t/* 8 bytes of a fixed-endian \"quad\" */\n\tchar s[MAXstring];\t/* the search string or regex pattern */\n\tunsigned char us[MAXstring];\n\tfloat f;\n\tdouble d;\n};\n\nstruct magic {\n\t/* Word 1 */\n\tuint16_t cont_level;\t/* level of \">\" */\n\tuint8_t flag;\n#define INDIR\t\t0x01\t/* if '(...)' appears */\n#define OFFADD\t\t0x02\t/* if '>&' or '>...(&' appears */\n#define INDIROFFADD\t0x04\t/* if '>&(' appears */\n#define UNSIGNED\t0x08\t/* comparison is unsigned */\n#define NOSPACE\t\t0x10\t/* suppress space character before output */\n#define BINTEST\t\t0x20\t/* test is for a binary type (set only\n\t\t\t\t   for top-level tests) */\n#define TEXTTEST\t0x40\t/* for passing to file_softmagic */\n\n\tuint8_t factor;\n\n\t/* Word 2 */\n\tuint8_t reln;\t\t/* relation (0=eq, '>'=gt, etc) */\n\tuint8_t vallen;\t\t/* length of string value, if any */\n\tuint8_t type;\t\t/* comparison type (FILE_*) */\n\tuint8_t in_type;\t/* type of indirection */\n#define \t\t\tFILE_INVALID\t0\n#define \t\t\tFILE_BYTE\t1\n#define\t\t\t\tFILE_SHORT\t2\n#define\t\t\t\tFILE_DEFAULT\t3\n#define\t\t\t\tFILE_LONG\t4\n#define\t\t\t\tFILE_STRING\t5\n#define\t\t\t\tFILE_DATE\t6\n#define\t\t\t\tFILE_BESHORT\t7\n#define\t\t\t\tFILE_BELONG\t8\n#define\t\t\t\tFILE_BEDATE\t9\n#define\t\t\t\tFILE_LESHORT\t10\n#define\t\t\t\tFILE_LELONG\t11\n#define\t\t\t\tFILE_LEDATE\t12\n#define\t\t\t\tFILE_PSTRING\t13\n#define\t\t\t\tFILE_LDATE\t14\n#define\t\t\t\tFILE_BELDATE\t15\n#define\t\t\t\tFILE_LELDATE\t16\n#define\t\t\t\tFILE_REGEX\t17\n#define\t\t\t\tFILE_BESTRING16\t18\n#define\t\t\t\tFILE_LESTRING16\t19\n#define\t\t\t\tFILE_SEARCH\t20\n#define\t\t\t\tFILE_MEDATE\t21\n#define\t\t\t\tFILE_MELDATE\t22\n#define\t\t\t\tFILE_MELONG\t23\n#define\t\t\t\tFILE_QUAD\t24\n#define\t\t\t\tFILE_LEQUAD\t25\n#define\t\t\t\tFILE_BEQUAD\t26\n#define\t\t\t\tFILE_QDATE\t27\n#define\t\t\t\tFILE_LEQDATE\t28\n#define\t\t\t\tFILE_BEQDATE\t29\n#define\t\t\t\tFILE_QLDATE\t30\n#define\t\t\t\tFILE_LEQLDATE\t31\n#define\t\t\t\tFILE_BEQLDATE\t32\n#define\t\t\t\tFILE_FLOAT\t33\n#define\t\t\t\tFILE_BEFLOAT\t34\n#define\t\t\t\tFILE_LEFLOAT\t35\n#define\t\t\t\tFILE_DOUBLE\t36\n#define\t\t\t\tFILE_BEDOUBLE\t37\n#define\t\t\t\tFILE_LEDOUBLE\t38\n#define\t\t\t\tFILE_BEID3\t39\n#define\t\t\t\tFILE_LEID3\t40\n#define\t\t\t\tFILE_INDIRECT\t41\n#define\t\t\t\tFILE_QWDATE\t42\n#define\t\t\t\tFILE_LEQWDATE\t43\n#define\t\t\t\tFILE_BEQWDATE\t44\n#define\t\t\t\tFILE_NAME\t45\n#define\t\t\t\tFILE_USE\t46\n#define\t\t\t\tFILE_CLEAR\t47\n#define\t\t\t\tFILE_NAMES_SIZE\t48 /* size of array to contain all names */\n\n#define IS_STRING(t) \\\n\t((t) == FILE_STRING || \\\n\t (t) == FILE_PSTRING || \\\n\t (t) == FILE_BESTRING16 || \\\n\t (t) == FILE_LESTRING16 || \\\n\t (t) == FILE_REGEX || \\\n\t (t) == FILE_SEARCH || \\\n\t (t) == FILE_NAME || \\\n\t (t) == FILE_USE)\n\n#define FILE_FMT_NONE 0\n#define FILE_FMT_NUM  1 /* \"cduxXi\" */\n#define FILE_FMT_STR  2 /* \"s\" */\n#define FILE_FMT_QUAD 3 /* \"ll\" */\n#define FILE_FMT_FLOAT 4 /* \"eEfFgG\" */\n#define FILE_FMT_DOUBLE 5 /* \"eEfFgG\" */\n\n\t/* Word 3 */\n\tuint8_t in_op;\t\t/* operator for indirection */\n\tuint8_t mask_op;\t/* operator for mask */\n#ifdef ENABLE_CONDITIONALS\n\tuint8_t cond;\t\t/* conditional type */\n#else\n\tuint8_t dummy;\n#endif\n\tuint8_t factor_op;\n#define\t\tFILE_FACTOR_OP_PLUS\t'+'\n#define\t\tFILE_FACTOR_OP_MINUS\t'-'\n#define\t\tFILE_FACTOR_OP_TIMES\t'*'\n#define\t\tFILE_FACTOR_OP_DIV\t'/'\n#define\t\tFILE_FACTOR_OP_NONE\t'\\0'\n\n#define\t\t\t\tFILE_OPS\t\"&|^+-*/%\"\n#define\t\t\t\tFILE_OPAND\t0\n#define\t\t\t\tFILE_OPOR\t1\n#define\t\t\t\tFILE_OPXOR\t2\n#define\t\t\t\tFILE_OPADD\t3\n#define\t\t\t\tFILE_OPMINUS\t4\n#define\t\t\t\tFILE_OPMULTIPLY\t5\n#define\t\t\t\tFILE_OPDIVIDE\t6\n#define\t\t\t\tFILE_OPMODULO\t7\n#define\t\t\t\tFILE_OPS_MASK\t0x07 /* mask for above ops */\n#define\t\t\t\tFILE_UNUSED_1\t0x08\n#define\t\t\t\tFILE_UNUSED_2\t0x10\n#define\t\t\t\tFILE_UNUSED_3\t0x20\n#define\t\t\t\tFILE_OPINVERSE\t0x40\n#define\t\t\t\tFILE_OPINDIRECT\t0x80\n\n#ifdef ENABLE_CONDITIONALS\n#define\t\t\t\tCOND_NONE\t0\n#define\t\t\t\tCOND_IF\t\t1\n#define\t\t\t\tCOND_ELIF\t2\n#define\t\t\t\tCOND_ELSE\t3\n#endif /* ENABLE_CONDITIONALS */\n\n\t/* Word 4 */\n\tuint32_t offset;\t/* offset to magic number */\n\t/* Word 5 */\n\tint32_t in_offset;\t/* offset from indirection */\n\t/* Word 6 */\n\tuint32_t lineno;\t/* line number in magic file */\n\t/* Word 7,8 */\n\tunion {\n\t\tuint64_t _mask;\t/* for use with numeric and date types */\n\t\tstruct {\n\t\t\tuint32_t _count;\t/* repeat/line count */\n\t\t\tuint32_t _flags;\t/* modifier flags */\n\t\t} _s;\t\t/* for use with string types */\n\t} _u;\n#define num_mask _u._mask\n#define str_range _u._s._count\n#define str_flags _u._s._flags\n\t/* Words 9-16 */\n\tunion VALUETYPE value;\t/* either number or string */\n\t/* Words 17-32 */\n\tchar desc[MAXDESC];\t/* description */\n\t/* Words 33-52 */\n\tchar mimetype[MAXMIME]; /* MIME type */\n\t/* Words 53-54 */\n\tchar apple[8];\n};\n\n#define BIT(A)   (1 << (A))\n#define STRING_COMPACT_WHITESPACE\t\tBIT(0)\n#define STRING_COMPACT_OPTIONAL_WHITESPACE\tBIT(1)\n#define STRING_IGNORE_LOWERCASE\t\t\tBIT(2)\n#define STRING_IGNORE_UPPERCASE\t\t\tBIT(3)\n#define REGEX_OFFSET_START\t\t\tBIT(4)\n#define STRING_TEXTTEST\t\t\t\tBIT(5)\n#define STRING_BINTEST\t\t\t\tBIT(6)\n#define PSTRING_1_BE\t\t\t\tBIT(7)\n#define PSTRING_1_LE\t\t\t\tBIT(7)\n#define PSTRING_2_BE\t\t\t\tBIT(8)\n#define PSTRING_2_LE\t\t\t\tBIT(9)\n#define PSTRING_4_BE\t\t\t\tBIT(10)\n#define PSTRING_4_LE\t\t\t\tBIT(11)\n#define PSTRING_LEN\t\\\n    (PSTRING_1_BE|PSTRING_2_LE|PSTRING_2_BE|PSTRING_4_LE|PSTRING_4_BE)\n#define PSTRING_LENGTH_INCLUDES_ITSELF\t\tBIT(12)\n#define\tSTRING_TRIM\t\t\t\tBIT(13)\n#define CHAR_COMPACT_WHITESPACE\t\t\t'W'\n#define CHAR_COMPACT_OPTIONAL_WHITESPACE\t'w'\n#define CHAR_IGNORE_LOWERCASE\t\t\t'c'\n#define CHAR_IGNORE_UPPERCASE\t\t\t'C'\n#define CHAR_REGEX_OFFSET_START\t\t\t's'\n#define CHAR_TEXTTEST\t\t\t\t't'\n#define\tCHAR_TRIM\t\t\t\t'T'\n#define CHAR_BINTEST\t\t\t\t'b'\n#define CHAR_PSTRING_1_BE\t\t\t'B'\n#define CHAR_PSTRING_1_LE\t\t\t'B'\n#define CHAR_PSTRING_2_BE\t\t\t'H'\n#define CHAR_PSTRING_2_LE\t\t\t'h'\n#define CHAR_PSTRING_4_BE\t\t\t'L'\n#define CHAR_PSTRING_4_LE\t\t\t'l'\n#define CHAR_PSTRING_LENGTH_INCLUDES_ITSELF     'J'\n#define STRING_IGNORE_CASE\t\t(STRING_IGNORE_LOWERCASE|STRING_IGNORE_UPPERCASE)\n#define STRING_DEFAULT_RANGE\t\t100\n\n\n/* list of magic entries */\nstruct mlist {\n\tstruct magic *magic;\t\t/* array of magic entries */\n\tuint32_t nmagic;\t\t/* number of entries in array */\n\tvoid *map;\t\t\t/* internal resources used by entry */\n\tstruct mlist *next, *prev;\n};\n\n#ifdef __cplusplus\n#define CAST(T, b)\tstatic_cast<T>(b)\n#define RCAST(T, b)\treinterpret_cast<T>(b)\n#else\n#define CAST(T, b)\t(T)(b)\n#define RCAST(T, b)\t(T)(b)\n#endif\n\nstruct level_info {\n\tint32_t off;\n\tint got_match;\n#ifdef ENABLE_CONDITIONALS\n\tint last_match;\n\tint last_cond;\t/* used for error checking by parse() */\n#endif\n};\n\n#define MAGIC_SETS\t2\n\nstruct magic_set {\n\tstruct mlist *mlist[MAGIC_SETS];\t/* list of regular entries */\n\tstruct cont {\n\t\tsize_t len;\n\t\tstruct level_info *li;\n\t} c;\n\tstruct out {\n\t\tchar *buf;\t\t/* Accumulation buffer */\n\t\tchar *pbuf;\t\t/* Printable buffer */\n\t} o;\n\tuint32_t offset;\n\tint error;\n\tint flags;\t\t\t/* Control magic tests. */\n\tint event_flags;\t\t/* Note things that happened. */\n#define \t\tEVENT_HAD_ERR\t\t0x01\n\tconst char *file;\n\tsize_t line;\t\t\t/* current magic line number */\n\n\t/* data for searches */\n\tstruct {\n\t\tconst char *s;\t\t/* start of search in original source */\n\t\tsize_t s_len;\t\t/* length of search region */\n\t\tsize_t offset;\t\t/* starting offset in source: XXX - should this be off_t? */\n\t\tsize_t rm_len;\t\t/* match length */\n\t} search;\n\n\t/* FIXME: Make the string dynamically allocated so that e.g.\n\t   strings matched in files can be longer than MAXstring */\n\tunion VALUETYPE ms_value;\t/* either number or string */\n};\n\n/* Type for Unicode characters */\ntypedef unsigned long unichar;\n\nstruct stat;\n#define FILE_T_LOCAL\t1\n#define FILE_T_WINDOWS\t2\nprotected const char *file_fmttime(uint64_t, int, char *);\nprotected struct magic_set *file_ms_alloc(int);\nprotected void file_ms_free(struct magic_set *);\nprotected int file_buffer(struct magic_set *, int, const char *, const void *,\n    size_t);\nprotected int file_fsmagic(struct magic_set *, const char *, struct stat *);\nprotected int file_pipe2file(struct magic_set *, int, const void *, size_t);\nprotected int file_vprintf(struct magic_set *, const char *, va_list)\n    __attribute__((__format__(__printf__, 2, 0)));\nprotected size_t file_printedlen(const struct magic_set *);\nprotected int file_replace(struct magic_set *, const char *, const char *);\nprotected int file_printf(struct magic_set *, const char *, ...)\n    __attribute__((__format__(__printf__, 2, 3)));\nprotected int file_reset(struct magic_set *);\nprotected int file_tryelf(struct magic_set *, int, const unsigned char *,\n    size_t);\nprotected int file_trycdf(struct magic_set *, int, const unsigned char *,\n    size_t);\n#if HAVE_FORK\nprotected int file_zmagic(struct magic_set *, int, const char *,\n    const unsigned char *, size_t);\n#endif\nprotected int file_ascmagic(struct magic_set *, const unsigned char *, size_t,\n    int);\nprotected int file_ascmagic_with_encoding(struct magic_set *,\n    const unsigned char *, size_t, unichar *, size_t, const char *,\n    const char *, int);\nprotected int file_encoding(struct magic_set *, const unsigned char *, size_t,\n    unichar **, size_t *, const char **, const char **, const char **);\nprotected int file_is_tar(struct magic_set *, const unsigned char *, size_t);\nprotected int file_softmagic(struct magic_set *, const unsigned char *, size_t,\n    size_t, int, int);\nprotected int file_apprentice(struct magic_set *, const char *, int);\nprotected int file_magicfind(struct magic_set *, const char *, struct mlist *);\nprotected uint64_t file_signextend(struct magic_set *, struct magic *,\n    uint64_t);\nprotected void file_badread(struct magic_set *);\nprotected void file_badseek(struct magic_set *);\nprotected void file_oomem(struct magic_set *, size_t);\nprotected void file_error(struct magic_set *, int, const char *, ...)\n    __attribute__((__format__(__printf__, 3, 4)));\nprotected void file_magerror(struct magic_set *, const char *, ...)\n    __attribute__((__format__(__printf__, 2, 3)));\nprotected void file_magwarn(struct magic_set *, const char *, ...)\n    __attribute__((__format__(__printf__, 2, 3)));\nprotected void file_mdump(struct magic *);\nprotected void file_showstr(FILE *, const char *, size_t);\nprotected size_t file_mbswidth(const char *);\nprotected const char *file_getbuffer(struct magic_set *);\nprotected ssize_t sread(int, void *, size_t, int);\nprotected int file_check_mem(struct magic_set *, unsigned int);\nprotected int file_looks_utf8(const unsigned char *, size_t, unichar *,\n    size_t *);\nprotected size_t file_pstring_length_size(const struct magic *);\nprotected size_t file_pstring_get_length(const struct magic *, const char *);\n#ifdef __EMX__\nprotected int file_os2_apptype(struct magic_set *, const char *, const void *,\n    size_t);\n#endif /* __EMX__ */\n\ntypedef struct {\n\tconst char *pat;\n\tchar *old_lc_ctype;\n\tint rc;\n\tregex_t rx;\n} file_regex_t;\n\nprotected int file_regcomp(file_regex_t *, const char *, int);\nprotected int file_regexec(file_regex_t *, const char *, size_t, regmatch_t *,\n    int);\nprotected void file_regfree(file_regex_t *);\nprotected void file_regerror(file_regex_t *, int, struct magic_set *);\n\n#ifndef COMPILE_ONLY\nextern const char *file_names[];\nextern const size_t file_nnames;\n#endif\n\n#ifndef HAVE_STRERROR\nextern int sys_nerr;\nextern char *sys_errlist[];\n#define strerror(e) \\\n\t(((e) >= 0 && (e) < sys_nerr) ? sys_errlist[(e)] : \"Unknown error\")\n#endif\n\n#ifndef HAVE_STRTOUL\n#define strtoul(a, b, c)\tstrtol(a, b, c)\n#endif\n\n#ifndef HAVE_PREAD\nssize_t pread(int, void *, size_t, off_t);\n#endif\n#ifndef HAVE_VASPRINTF\nint vasprintf(char **, const char *, va_list);\n#endif\n#ifndef HAVE_ASPRINTF\nint asprintf(char **, const char *, ...);\n#endif\n\n#ifndef HAVE_STRLCPY\nsize_t strlcpy(char *, const char *, size_t);\n#endif\n#ifndef HAVE_STRLCAT\nsize_t strlcat(char *, const char *, size_t);\n#endif\n#ifndef HAVE_STRCASESTR\nchar *strcasestr(const char *, const char *);\n#endif\n#ifndef HAVE_GETLINE\nssize_t getline(char **, size_t *, FILE *);\nssize_t getdelim(char **, size_t *, int, FILE *);\n#endif\n#ifndef HAVE_CTIME_R\nchar   *ctime_r(const time_t *, char *);\n#endif\n#ifndef HAVE_ASCTIME_R\nchar   *asctime_r(const struct tm *, char *);\n#endif\n#ifndef HAVE_FMTCHECK\nconst char *fmtcheck(const char *, const char *) \n     __attribute__((__format_arg__(2)));\n#endif\n\n#if defined(HAVE_MMAP) && defined(HAVE_SYS_MMAN_H) && !defined(QUICK)\n#define QUICK\n#endif\n\n#ifndef O_BINARY\n#define O_BINARY\t0\n#endif\n\n#ifndef __cplusplus\n#if defined(__GNUC__) && (__GNUC__ >= 3)\n#define FILE_RCSID(id) \\\nstatic const char rcsid[] __attribute__((__used__)) = id;\n#else\n#define FILE_RCSID(id) \\\nstatic const char *rcsid(const char *p) { \\\n\treturn rcsid(p = id); \\\n}\n#endif\n#else\n#define FILE_RCSID(id)\n#endif\n\n#endif /* __file_h__ */\n", "/*\n * Copyright (c) Ian F. Darwin 1986-1995.\n * Software written by Ian F. Darwin and others;\n * maintained 1995-present by Christos Zoulas and others.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice immediately at the beginning of the file, without modification,\n *    this list of conditions, and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n/*\n * softmagic - interpret variable magic from MAGIC\n */\n\n#include \"file.h\"\n\n#ifndef\tlint\nFILE_RCSID(\"@(#)$File: softmagic.c,v 1.188 2014/05/14 23:15:42 christos Exp $\")\n#endif\t/* lint */\n\n#include \"magic.h\"\n#include <assert.h>\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <time.h>\n#if defined(HAVE_LOCALE_H)\n#include <locale.h>\n#endif\n\n\nprivate int match(struct magic_set *, struct magic *, uint32_t,\n    const unsigned char *, size_t, size_t, int, int, int, int, int *, int *,\n    int *);\nprivate int mget(struct magic_set *, const unsigned char *,\n    struct magic *, size_t, size_t, unsigned int, int, int, int, int, int *,\n    int *, int *);\nprivate int magiccheck(struct magic_set *, struct magic *);\nprivate int32_t mprint(struct magic_set *, struct magic *);\nprivate int32_t moffset(struct magic_set *, struct magic *);\nprivate void mdebug(uint32_t, const char *, size_t);\nprivate int mcopy(struct magic_set *, union VALUETYPE *, int, int,\n    const unsigned char *, uint32_t, size_t, size_t);\nprivate int mconvert(struct magic_set *, struct magic *, int);\nprivate int print_sep(struct magic_set *, int);\nprivate int handle_annotation(struct magic_set *, struct magic *);\nprivate void cvt_8(union VALUETYPE *, const struct magic *);\nprivate void cvt_16(union VALUETYPE *, const struct magic *);\nprivate void cvt_32(union VALUETYPE *, const struct magic *);\nprivate void cvt_64(union VALUETYPE *, const struct magic *);\n\n#define OFFSET_OOB(n, o, i)\t((n) < (o) || (i) > ((n) - (o)))\n/*\n * softmagic - lookup one file in parsed, in-memory copy of database\n * Passed the name and FILE * of one file to be typed.\n */\n/*ARGSUSED1*/\t\t/* nbytes passed for regularity, maybe need later */\nprotected int\nfile_softmagic(struct magic_set *ms, const unsigned char *buf, size_t nbytes,\n    size_t level, int mode, int text)\n{\n\tstruct mlist *ml;\n\tint rv, printed_something = 0, need_separator = 0;\n\tfor (ml = ms->mlist[0]->next; ml != ms->mlist[0]; ml = ml->next)\n\t\tif ((rv = match(ms, ml->magic, ml->nmagic, buf, nbytes, 0, mode,\n\t\t    text, 0, level, &printed_something, &need_separator,\n\t\t    NULL)) != 0)\n\t\t\treturn rv;\n\n\treturn 0;\n}\n\n#define FILE_FMTDEBUG\n#ifdef FILE_FMTDEBUG\n#define F(a, b, c) file_fmtcheck((a), (b), (c), __FILE__, __LINE__)\n\nprivate const char * __attribute__((__format_arg__(3)))\nfile_fmtcheck(struct magic_set *ms, const struct magic *m, const char *def,\n\tconst char *file, size_t line)\n{\n\tconst char *ptr = fmtcheck(m->desc, def);\n\tif (ptr == def)\n\t\tfile_magerror(ms,\n\t\t    \"%s, %zu: format `%s' does not match with `%s'\",\n\t\t    file, line, m->desc, def);\n\treturn ptr;\n}\n#else\n#define F(a, b, c) fmtcheck((b)->desc, (c))\n#endif\n\n/*\n * Go through the whole list, stopping if you find a match.  Process all\n * the continuations of that match before returning.\n *\n * We support multi-level continuations:\n *\n *\tAt any time when processing a successful top-level match, there is a\n *\tcurrent continuation level; it represents the level of the last\n *\tsuccessfully matched continuation.\n *\n *\tContinuations above that level are skipped as, if we see one, it\n *\tmeans that the continuation that controls them - i.e, the\n *\tlower-level continuation preceding them - failed to match.\n *\n *\tContinuations below that level are processed as, if we see one,\n *\tit means we've finished processing or skipping higher-level\n *\tcontinuations under the control of a successful or unsuccessful\n *\tlower-level continuation, and are now seeing the next lower-level\n *\tcontinuation and should process it.  The current continuation\n *\tlevel reverts to the level of the one we're seeing.\n *\n *\tContinuations at the current level are processed as, if we see\n *\tone, there's no lower-level continuation that may have failed.\n *\n *\tIf a continuation matches, we bump the current continuation level\n *\tso that higher-level continuations are processed.\n */\nprivate int\nmatch(struct magic_set *ms, struct magic *magic, uint32_t nmagic,\n    const unsigned char *s, size_t nbytes, size_t offset, int mode, int text,\n    int flip, int recursion_level, int *printed_something, int *need_separator,\n    int *returnval)\n{\n\tuint32_t magindex = 0;\n\tunsigned int cont_level = 0;\n\tint returnvalv = 0, e; /* if a match is found it is set to 1*/\n\tint firstline = 1; /* a flag to print X\\n  X\\n- X */\n\tint print = (ms->flags & (MAGIC_MIME|MAGIC_APPLE)) == 0;\n\n\tif (returnval == NULL)\n\t\treturnval = &returnvalv;\n\n\tif (file_check_mem(ms, cont_level) == -1)\n\t\treturn -1;\n\n\tfor (magindex = 0; magindex < nmagic; magindex++) {\n\t\tint flush = 0;\n\t\tstruct magic *m = &magic[magindex];\n\n\t\tif (m->type != FILE_NAME)\n\t\tif ((IS_STRING(m->type) &&\n#define FLT (STRING_BINTEST | STRING_TEXTTEST)\n\t\t     ((text && (m->str_flags & FLT) == STRING_BINTEST) ||\n\t\t      (!text && (m->str_flags & FLT) == STRING_TEXTTEST))) ||\n\t\t    (m->flag & mode) != mode) {\n\t\t\t/* Skip sub-tests */\n\t\t\twhile (magindex + 1 < nmagic &&\n                               magic[magindex + 1].cont_level != 0 &&\n\t\t\t       ++magindex)\n\t\t\t\tcontinue;\n\t\t\tcontinue; /* Skip to next top-level test*/\n\t\t}\n\n\t\tms->offset = m->offset;\n\t\tms->line = m->lineno;\n\n\t\t/* if main entry matches, print it... */\n\t\tswitch (mget(ms, s, m, nbytes, offset, cont_level, mode, text,\n\t\t    flip, recursion_level + 1, printed_something,\n\t\t    need_separator, returnval)) {\n\t\tcase -1:\n\t\t\treturn -1;\n\t\tcase 0:\n\t\t\tflush = m->reln != '!';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (m->type == FILE_INDIRECT)\n\t\t\t\t*returnval = 1;\n\n\t\t\tswitch (magiccheck(ms, m)) {\n\t\t\tcase -1:\n\t\t\t\treturn -1;\n\t\t\tcase 0:\n\t\t\t\tflush++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tflush = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (flush) {\n\t\t\t/*\n\t\t\t * main entry didn't match,\n\t\t\t * flush its continuations\n\t\t\t */\n\t\t\twhile (magindex < nmagic - 1 &&\n\t\t\t    magic[magindex + 1].cont_level != 0)\n\t\t\t\tmagindex++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((e = handle_annotation(ms, m)) != 0) {\n\t\t\t*need_separator = 1;\n\t\t\t*printed_something = 1;\n\t\t\t*returnval = 1;\n\t\t\treturn e;\n\t\t}\n\t\t/*\n\t\t * If we are going to print something, we'll need to print\n\t\t * a blank before we print something else.\n\t\t */\n\t\tif (*m->desc) {\n\t\t\t*need_separator = 1;\n\t\t\t*printed_something = 1;\n\t\t\tif (print_sep(ms, firstline) == -1)\n\t\t\t\treturn -1;\n\t\t}\n\n\n\t\tif (print && mprint(ms, m) == -1)\n\t\t\treturn -1;\n\n\t\tms->c.li[cont_level].off = moffset(ms, m);\n\n\t\t/* and any continuations that match */\n\t\tif (file_check_mem(ms, ++cont_level) == -1)\n\t\t\treturn -1;\n\n\t\twhile (++magindex < nmagic &&\n\t\t    magic[magindex].cont_level != 0) {\n\t\t\tm = &magic[magindex];\n\t\t\tms->line = m->lineno; /* for messages */\n\n\t\t\tif (cont_level < m->cont_level)\n\t\t\t\tcontinue;\n\t\t\tif (cont_level > m->cont_level) {\n\t\t\t\t/*\n\t\t\t\t * We're at the end of the level\n\t\t\t\t * \"cont_level\" continuations.\n\t\t\t\t */\n\t\t\t\tcont_level = m->cont_level;\n\t\t\t}\n\t\t\tms->offset = m->offset;\n\t\t\tif (m->flag & OFFADD) {\n\t\t\t\tms->offset +=\n\t\t\t\t    ms->c.li[cont_level - 1].off;\n\t\t\t}\n\n#ifdef ENABLE_CONDITIONALS\n\t\t\tif (m->cond == COND_ELSE ||\n\t\t\t    m->cond == COND_ELIF) {\n\t\t\t\tif (ms->c.li[cont_level].last_match == 1)\n\t\t\t\t\tcontinue;\n\t\t\t}\n#endif\n\t\t\tswitch (mget(ms, s, m, nbytes, offset, cont_level, mode,\n\t\t\t    text, flip, recursion_level + 1, printed_something,\n\t\t\t    need_separator, returnval)) {\n\t\t\tcase -1:\n\t\t\t\treturn -1;\n\t\t\tcase 0:\n\t\t\t\tif (m->reln != '!')\n\t\t\t\t\tcontinue;\n\t\t\t\tflush = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (m->type == FILE_INDIRECT)\n\t\t\t\t\t*returnval = 1;\n\t\t\t\tflush = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch (flush ? 1 : magiccheck(ms, m)) {\n\t\t\tcase -1:\n\t\t\t\treturn -1;\n\t\t\tcase 0:\n#ifdef ENABLE_CONDITIONALS\n\t\t\t\tms->c.li[cont_level].last_match = 0;\n#endif\n\t\t\t\tbreak;\n\t\t\tdefault:\n#ifdef ENABLE_CONDITIONALS\n\t\t\t\tms->c.li[cont_level].last_match = 1;\n#endif\n\t\t\t\tif (m->type == FILE_CLEAR)\n\t\t\t\t\tms->c.li[cont_level].got_match = 0;\n\t\t\t\telse if (ms->c.li[cont_level].got_match) {\n\t\t\t\t\tif (m->type == FILE_DEFAULT)\n\t\t\t\t\t\tbreak;\n\t\t\t\t} else\n\t\t\t\t\tms->c.li[cont_level].got_match = 1;\n\t\t\t\tif ((e = handle_annotation(ms, m)) != 0) {\n\t\t\t\t\t*need_separator = 1;\n\t\t\t\t\t*printed_something = 1;\n\t\t\t\t\t*returnval = 1;\n\t\t\t\t\treturn e;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * If we are going to print something,\n\t\t\t\t * make sure that we have a separator first.\n\t\t\t\t */\n\t\t\t\tif (*m->desc) {\n\t\t\t\t\tif (!*printed_something) {\n\t\t\t\t\t\t*printed_something = 1;\n\t\t\t\t\t\tif (print_sep(ms, firstline)\n\t\t\t\t\t\t    == -1)\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * This continuation matched.  Print\n\t\t\t\t * its message, with a blank before it\n\t\t\t\t * if the previous item printed and\n\t\t\t\t * this item isn't empty.\n\t\t\t\t */\n\t\t\t\t/* space if previous printed */\n\t\t\t\tif (*need_separator\n\t\t\t\t    && ((m->flag & NOSPACE) == 0)\n\t\t\t\t    && *m->desc) {\n\t\t\t\t\tif (print &&\n\t\t\t\t\t    file_printf(ms, \" \") == -1)\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t*need_separator = 0;\n\t\t\t\t}\n\t\t\t\tif (print && mprint(ms, m) == -1)\n\t\t\t\t\treturn -1;\n\n\t\t\t\tms->c.li[cont_level].off = moffset(ms, m);\n\n\t\t\t\tif (*m->desc)\n\t\t\t\t\t*need_separator = 1;\n\n\t\t\t\t/*\n\t\t\t\t * If we see any continuations\n\t\t\t\t * at a higher level,\n\t\t\t\t * process them.\n\t\t\t\t */\n\t\t\t\tif (file_check_mem(ms, ++cont_level) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (*printed_something) {\n\t\t\tfirstline = 0;\n\t\t\tif (print)\n\t\t\t\t*returnval = 1;\n\t\t}\n\t\tif ((ms->flags & MAGIC_CONTINUE) == 0 && *printed_something) {\n\t\t\treturn *returnval; /* don't keep searching */\n\t\t}\n\t}\n\treturn *returnval;  /* This is hit if -k is set or there is no match */\n}\n\nprivate int\ncheck_fmt(struct magic_set *ms, struct magic *m)\n{\n\tfile_regex_t rx;\n\tint rc, rv = -1;\n\n\tif (strchr(m->desc, '%') == NULL)\n\t\treturn 0;\n\n\trc = file_regcomp(&rx, \"%[-0-9\\\\.]*s\", REG_EXTENDED|REG_NOSUB);\n\tif (rc) {\n\t\tfile_regerror(&rx, rc, ms);\n\t} else {\n\t\trc = file_regexec(&rx, m->desc, 0, 0, 0);\n\t\trv = !rc;\n\t}\n\tfile_regfree(&rx);\n\treturn rv;\n}\n\n#ifndef HAVE_STRNDUP\nchar * strndup(const char *, size_t);\n\nchar *\nstrndup(const char *str, size_t n)\n{\n\tsize_t len;\n\tchar *copy;\n\n\tfor (len = 0; len < n && str[len]; len++)\n\t\tcontinue;\n\tif ((copy = malloc(len + 1)) == NULL)\n\t\treturn NULL;\n\t(void)memcpy(copy, str, len);\n\tcopy[len] = '\\0';\n\treturn copy;\n}\n#endif /* HAVE_STRNDUP */\n\nprivate int32_t\nmprint(struct magic_set *ms, struct magic *m)\n{\n\tuint64_t v;\n\tfloat vf;\n\tdouble vd;\n\tint64_t t = 0;\n \tchar buf[128], tbuf[26];\n\tunion VALUETYPE *p = &ms->ms_value;\n\n  \tswitch (m->type) {\n  \tcase FILE_BYTE:\n\t\tv = file_signextend(ms, m, (uint64_t)p->b);\n\t\tswitch (check_fmt(ms, m)) {\n\t\tcase -1:\n\t\t\treturn -1;\n\t\tcase 1:\n\t\t\t(void)snprintf(buf, sizeof(buf), \"%d\",\n\t\t\t    (unsigned char)v);\n\t\t\tif (file_printf(ms, F(ms, m, \"%s\"), buf) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (file_printf(ms, F(ms, m, \"%d\"),\n\t\t\t    (unsigned char) v) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\t}\n\t\tt = ms->offset + sizeof(char);\n\t\tbreak;\n\n  \tcase FILE_SHORT:\n  \tcase FILE_BESHORT:\n  \tcase FILE_LESHORT:\n\t\tv = file_signextend(ms, m, (uint64_t)p->h);\n\t\tswitch (check_fmt(ms, m)) {\n\t\tcase -1:\n\t\t\treturn -1;\n\t\tcase 1:\n\t\t\t(void)snprintf(buf, sizeof(buf), \"%u\",\n\t\t\t    (unsigned short)v);\n\t\t\tif (file_printf(ms, F(ms, m, \"%s\"), buf) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (file_printf(ms, F(ms, m, \"%u\"),\n\t\t\t    (unsigned short) v) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\t}\n\t\tt = ms->offset + sizeof(short);\n\t\tbreak;\n\n  \tcase FILE_LONG:\n  \tcase FILE_BELONG:\n  \tcase FILE_LELONG:\n  \tcase FILE_MELONG:\n\t\tv = file_signextend(ms, m, (uint64_t)p->l);\n\t\tswitch (check_fmt(ms, m)) {\n\t\tcase -1:\n\t\t\treturn -1;\n\t\tcase 1:\n\t\t\t(void)snprintf(buf, sizeof(buf), \"%u\", (uint32_t) v);\n\t\t\tif (file_printf(ms, F(ms, m, \"%s\"), buf) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (file_printf(ms, F(ms, m, \"%u\"), (uint32_t) v) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\t}\n\t\tt = ms->offset + sizeof(int32_t);\n  \t\tbreak;\n\n  \tcase FILE_QUAD:\n  \tcase FILE_BEQUAD:\n  \tcase FILE_LEQUAD:\n\t\tv = file_signextend(ms, m, p->q);\n\t\tswitch (check_fmt(ms, m)) {\n\t\tcase -1:\n\t\t\treturn -1;\n\t\tcase 1:\n\t\t\t(void)snprintf(buf, sizeof(buf), \"%\" INT64_T_FORMAT \"u\",\n\t\t\t    (unsigned long long)v);\n\t\t\tif (file_printf(ms, F(ms, m, \"%s\"), buf) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (file_printf(ms, F(ms, m, \"%\" INT64_T_FORMAT \"u\"),\n\t\t\t    (unsigned long long) v) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\t}\n\t\tt = ms->offset + sizeof(int64_t);\n  \t\tbreak;\n\n  \tcase FILE_STRING:\n  \tcase FILE_PSTRING:\n  \tcase FILE_BESTRING16:\n  \tcase FILE_LESTRING16:\n\t\tif (m->reln == '=' || m->reln == '!') {\n\t\t\tif (file_printf(ms, F(ms, m, \"%s\"), m->value.s) == -1)\n\t\t\t\treturn -1;\n\t\t\tt = ms->offset + m->vallen;\n\t\t}\n\t\telse {\n\t\t\tchar *str = p->s;\n\n\t\t\t/* compute t before we mangle the string? */\n\t\t\tt = ms->offset + strlen(str);\n\n\t\t\tif (*m->value.s == '\\0')\n\t\t\t\tstr[strcspn(str, \"\\n\")] = '\\0';\n\n\t\t\tif (m->str_flags & STRING_TRIM) {\n\t\t\t\tchar *last;\n\t\t\t\twhile (isspace((unsigned char)*str))\n\t\t\t\t\tstr++;\n\t\t\t\tlast = str;\n\t\t\t\twhile (*last)\n\t\t\t\t\tlast++;\n\t\t\t\t--last;\n\t\t\t\twhile (isspace((unsigned char)*last))\n\t\t\t\t\tlast--;\n\t\t\t\t*++last = '\\0';\n\t\t\t}\n\n\t\t\tif (file_printf(ms, F(ms, m, \"%s\"), str) == -1)\n\t\t\t\treturn -1;\n\n\t\t\tif (m->type == FILE_PSTRING)\n\t\t\t\tt += file_pstring_length_size(m);\n\t\t}\n\t\tbreak;\n\n\tcase FILE_DATE:\n\tcase FILE_BEDATE:\n\tcase FILE_LEDATE:\n\tcase FILE_MEDATE:\n\t\tif (file_printf(ms, F(ms, m, \"%s\"),\n\t\t    file_fmttime(p->l, FILE_T_LOCAL, tbuf)) == -1)\n\t\t\treturn -1;\n\t\tt = ms->offset + sizeof(uint32_t);\n\t\tbreak;\n\n\tcase FILE_LDATE:\n\tcase FILE_BELDATE:\n\tcase FILE_LELDATE:\n\tcase FILE_MELDATE:\n\t\tif (file_printf(ms, F(ms, m, \"%s\"),\n\t\t    file_fmttime(p->l, 0, tbuf)) == -1)\n\t\t\treturn -1;\n\t\tt = ms->offset + sizeof(uint32_t);\n\t\tbreak;\n\n\tcase FILE_QDATE:\n\tcase FILE_BEQDATE:\n\tcase FILE_LEQDATE:\n\t\tif (file_printf(ms, F(ms, m, \"%s\"),\n\t\t    file_fmttime(p->q, FILE_T_LOCAL, tbuf)) == -1)\n\t\t\treturn -1;\n\t\tt = ms->offset + sizeof(uint64_t);\n\t\tbreak;\n\n\tcase FILE_QLDATE:\n\tcase FILE_BEQLDATE:\n\tcase FILE_LEQLDATE:\n\t\tif (file_printf(ms, F(ms, m, \"%s\"),\n\t\t    file_fmttime(p->q, 0, tbuf)) == -1)\n\t\t\treturn -1;\n\t\tt = ms->offset + sizeof(uint64_t);\n\t\tbreak;\n\n\tcase FILE_QWDATE:\n\tcase FILE_BEQWDATE:\n\tcase FILE_LEQWDATE:\n\t\tif (file_printf(ms, F(ms, m, \"%s\"),\n\t\t    file_fmttime(p->q, FILE_T_WINDOWS, tbuf)) == -1)\n\t\t\treturn -1;\n\t\tt = ms->offset + sizeof(uint64_t);\n\t\tbreak;\n\n  \tcase FILE_FLOAT:\n  \tcase FILE_BEFLOAT:\n  \tcase FILE_LEFLOAT:\n\t\tvf = p->f;\n\t\tswitch (check_fmt(ms, m)) {\n\t\tcase -1:\n\t\t\treturn -1;\n\t\tcase 1:\n\t\t\t(void)snprintf(buf, sizeof(buf), \"%g\", vf);\n\t\t\tif (file_printf(ms, F(ms, m, \"%s\"), buf) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (file_printf(ms, F(ms, m, \"%g\"), vf) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\t}\n\t\tt = ms->offset + sizeof(float);\n  \t\tbreak;\n\n  \tcase FILE_DOUBLE:\n  \tcase FILE_BEDOUBLE:\n  \tcase FILE_LEDOUBLE:\n\t\tvd = p->d;\n\t\tswitch (check_fmt(ms, m)) {\n\t\tcase -1:\n\t\t\treturn -1;\n\t\tcase 1:\n\t\t\t(void)snprintf(buf, sizeof(buf), \"%g\", vd);\n\t\t\tif (file_printf(ms, F(ms, m, \"%s\"), buf) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (file_printf(ms, F(ms, m, \"%g\"), vd) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\t}\n\t\tt = ms->offset + sizeof(double);\n  \t\tbreak;\n\n\tcase FILE_REGEX: {\n\t\tchar *cp;\n\t\tint rval;\n\n\t\tcp = strndup((const char *)ms->search.s, ms->search.rm_len);\n\t\tif (cp == NULL) {\n\t\t\tfile_oomem(ms, ms->search.rm_len);\n\t\t\treturn -1;\n\t\t}\n\t\trval = file_printf(ms, F(ms, m, \"%s\"), cp);\n\t\tfree(cp);\n\n\t\tif (rval == -1)\n\t\t\treturn -1;\n\n\t\tif ((m->str_flags & REGEX_OFFSET_START))\n\t\t\tt = ms->search.offset;\n\t\telse\n\t\t\tt = ms->search.offset + ms->search.rm_len;\n\t\tbreak;\n\t}\n\n\tcase FILE_SEARCH:\n\t  \tif (file_printf(ms, F(ms, m, \"%s\"), m->value.s) == -1)\n\t\t\treturn -1;\n\t\tif ((m->str_flags & REGEX_OFFSET_START))\n\t\t\tt = ms->search.offset;\n\t\telse\n\t\t\tt = ms->search.offset + m->vallen;\n\t\tbreak;\n\n\tcase FILE_DEFAULT:\n\tcase FILE_CLEAR:\n\t  \tif (file_printf(ms, \"%s\", m->desc) == -1)\n\t\t\treturn -1;\n\t\tt = ms->offset;\n\t\tbreak;\n\n\tcase FILE_INDIRECT:\n\tcase FILE_USE:\n\tcase FILE_NAME:\n\t\tt = ms->offset;\n\t\tbreak;\n\n\tdefault:\n\t\tfile_magerror(ms, \"invalid m->type (%d) in mprint()\", m->type);\n\t\treturn -1;\n\t}\n\treturn (int32_t)t;\n}\n\nprivate int32_t\nmoffset(struct magic_set *ms, struct magic *m)\n{\n  \tswitch (m->type) {\n  \tcase FILE_BYTE:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(char)));\n\n  \tcase FILE_SHORT:\n  \tcase FILE_BESHORT:\n  \tcase FILE_LESHORT:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(short)));\n\n  \tcase FILE_LONG:\n  \tcase FILE_BELONG:\n  \tcase FILE_LELONG:\n  \tcase FILE_MELONG:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(int32_t)));\n\n  \tcase FILE_QUAD:\n  \tcase FILE_BEQUAD:\n  \tcase FILE_LEQUAD:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(int64_t)));\n\n  \tcase FILE_STRING:\n  \tcase FILE_PSTRING:\n  \tcase FILE_BESTRING16:\n  \tcase FILE_LESTRING16:\n\t\tif (m->reln == '=' || m->reln == '!')\n\t\t\treturn ms->offset + m->vallen;\n\t\telse {\n\t\t\tunion VALUETYPE *p = &ms->ms_value;\n\t\t\tuint32_t t;\n\n\t\t\tif (*m->value.s == '\\0')\n\t\t\t\tp->s[strcspn(p->s, \"\\n\")] = '\\0';\n\t\t\tt = CAST(uint32_t, (ms->offset + strlen(p->s)));\n\t\t\tif (m->type == FILE_PSTRING)\n\t\t\t\tt += (uint32_t)file_pstring_length_size(m);\n\t\t\treturn t;\n\t\t}\n\n\tcase FILE_DATE:\n\tcase FILE_BEDATE:\n\tcase FILE_LEDATE:\n\tcase FILE_MEDATE:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(uint32_t)));\n\n\tcase FILE_LDATE:\n\tcase FILE_BELDATE:\n\tcase FILE_LELDATE:\n\tcase FILE_MELDATE:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(uint32_t)));\n\n\tcase FILE_QDATE:\n\tcase FILE_BEQDATE:\n\tcase FILE_LEQDATE:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(uint64_t)));\n\n\tcase FILE_QLDATE:\n\tcase FILE_BEQLDATE:\n\tcase FILE_LEQLDATE:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(uint64_t)));\n\n  \tcase FILE_FLOAT:\n  \tcase FILE_BEFLOAT:\n  \tcase FILE_LEFLOAT:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(float)));\n\n  \tcase FILE_DOUBLE:\n  \tcase FILE_BEDOUBLE:\n  \tcase FILE_LEDOUBLE:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(double)));\n\n\tcase FILE_REGEX:\n\t\tif ((m->str_flags & REGEX_OFFSET_START) != 0)\n\t\t\treturn CAST(int32_t, ms->search.offset);\n\t\telse\n\t\t\treturn CAST(int32_t, (ms->search.offset +\n\t\t\t    ms->search.rm_len));\n\n\tcase FILE_SEARCH:\n\t\tif ((m->str_flags & REGEX_OFFSET_START) != 0)\n\t\t\treturn CAST(int32_t, ms->search.offset);\n\t\telse\n\t\t\treturn CAST(int32_t, (ms->search.offset + m->vallen));\n\n\tcase FILE_CLEAR:\n\tcase FILE_DEFAULT:\n\tcase FILE_INDIRECT:\n\t\treturn ms->offset;\n\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nprivate int\ncvt_flip(int type, int flip)\n{\n\tif (flip == 0)\n\t\treturn type;\n\tswitch (type) {\n\tcase FILE_BESHORT:\n\t\treturn FILE_LESHORT;\n\tcase FILE_BELONG:\n\t\treturn FILE_LELONG;\n\tcase FILE_BEDATE:\n\t\treturn FILE_LEDATE;\n\tcase FILE_BELDATE:\n\t\treturn FILE_LELDATE;\n\tcase FILE_BEQUAD:\n\t\treturn FILE_LEQUAD;\n\tcase FILE_BEQDATE:\n\t\treturn FILE_LEQDATE;\n\tcase FILE_BEQLDATE:\n\t\treturn FILE_LEQLDATE;\n\tcase FILE_BEQWDATE:\n\t\treturn FILE_LEQWDATE;\n\tcase FILE_LESHORT:\n\t\treturn FILE_BESHORT;\n\tcase FILE_LELONG:\n\t\treturn FILE_BELONG;\n\tcase FILE_LEDATE:\n\t\treturn FILE_BEDATE;\n\tcase FILE_LELDATE:\n\t\treturn FILE_BELDATE;\n\tcase FILE_LEQUAD:\n\t\treturn FILE_BEQUAD;\n\tcase FILE_LEQDATE:\n\t\treturn FILE_BEQDATE;\n\tcase FILE_LEQLDATE:\n\t\treturn FILE_BEQLDATE;\n\tcase FILE_LEQWDATE:\n\t\treturn FILE_BEQWDATE;\n\tcase FILE_BEFLOAT:\n\t\treturn FILE_LEFLOAT;\n\tcase FILE_LEFLOAT:\n\t\treturn FILE_BEFLOAT;\n\tcase FILE_BEDOUBLE:\n\t\treturn FILE_LEDOUBLE;\n\tcase FILE_LEDOUBLE:\n\t\treturn FILE_BEDOUBLE;\n\tdefault:\n\t\treturn type;\n\t}\n}\n#define DO_CVT(fld, cast) \\\n\tif (m->num_mask) \\\n\t\tswitch (m->mask_op & FILE_OPS_MASK) { \\\n\t\tcase FILE_OPAND: \\\n\t\t\tp->fld &= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPOR: \\\n\t\t\tp->fld |= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPXOR: \\\n\t\t\tp->fld ^= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPADD: \\\n\t\t\tp->fld += cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPMINUS: \\\n\t\t\tp->fld -= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPMULTIPLY: \\\n\t\t\tp->fld *= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPDIVIDE: \\\n\t\t\tp->fld /= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPMODULO: \\\n\t\t\tp->fld %= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\t} \\\n\tif (m->mask_op & FILE_OPINVERSE) \\\n\t\tp->fld = ~p->fld \\\n\nprivate void\ncvt_8(union VALUETYPE *p, const struct magic *m)\n{\n\tDO_CVT(b, (uint8_t));\n}\n\nprivate void\ncvt_16(union VALUETYPE *p, const struct magic *m)\n{\n\tDO_CVT(h, (uint16_t));\n}\n\nprivate void\ncvt_32(union VALUETYPE *p, const struct magic *m)\n{\n\tDO_CVT(l, (uint32_t));\n}\n\nprivate void\ncvt_64(union VALUETYPE *p, const struct magic *m)\n{\n\tDO_CVT(q, (uint64_t));\n}\n\n#define DO_CVT2(fld, cast) \\\n\tif (m->num_mask) \\\n\t\tswitch (m->mask_op & FILE_OPS_MASK) { \\\n\t\tcase FILE_OPADD: \\\n\t\t\tp->fld += cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPMINUS: \\\n\t\t\tp->fld -= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPMULTIPLY: \\\n\t\t\tp->fld *= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPDIVIDE: \\\n\t\t\tp->fld /= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\t} \\\n\nprivate void\ncvt_float(union VALUETYPE *p, const struct magic *m)\n{\n\tDO_CVT2(f, (float));\n}\n\nprivate void\ncvt_double(union VALUETYPE *p, const struct magic *m)\n{\n\tDO_CVT2(d, (double));\n}\n\n/*\n * Convert the byte order of the data we are looking at\n * While we're here, let's apply the mask operation\n * (unless you have a better idea)\n */\nprivate int\nmconvert(struct magic_set *ms, struct magic *m, int flip)\n{\n\tunion VALUETYPE *p = &ms->ms_value;\n\n\tswitch (cvt_flip(m->type, flip)) {\n\tcase FILE_BYTE:\n\t\tcvt_8(p, m);\n\t\treturn 1;\n\tcase FILE_SHORT:\n\t\tcvt_16(p, m);\n\t\treturn 1;\n\tcase FILE_LONG:\n\tcase FILE_DATE:\n\tcase FILE_LDATE:\n\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_QUAD:\n\tcase FILE_QDATE:\n\tcase FILE_QLDATE:\n\tcase FILE_QWDATE:\n\t\tcvt_64(p, m);\n\t\treturn 1;\n\tcase FILE_STRING:\n\tcase FILE_BESTRING16:\n\tcase FILE_LESTRING16: {\n\t\t/* Null terminate and eat *trailing* return */\n\t\tp->s[sizeof(p->s) - 1] = '\\0';\n\t\treturn 1;\n\t}\n\tcase FILE_PSTRING: {\n\t\tchar *ptr1 = p->s, *ptr2 = ptr1 + file_pstring_length_size(m);\n\t\tsize_t len = file_pstring_get_length(m, ptr1);\n\t\tif (len >= sizeof(p->s))\n\t\t\tlen = sizeof(p->s) - 1;\n\t\twhile (len--)\n\t\t\t*ptr1++ = *ptr2++;\n\t\t*ptr1 = '\\0';\n\t\treturn 1;\n\t}\n\tcase FILE_BESHORT:\n\t\tp->h = (short)((p->hs[0]<<8)|(p->hs[1]));\n\t\tcvt_16(p, m);\n\t\treturn 1;\n\tcase FILE_BELONG:\n\tcase FILE_BEDATE:\n\tcase FILE_BELDATE:\n\t\tp->l = (int32_t)\n\t\t    ((p->hl[0]<<24)|(p->hl[1]<<16)|(p->hl[2]<<8)|(p->hl[3]));\n\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_BEQUAD:\n\tcase FILE_BEQDATE:\n\tcase FILE_BEQLDATE:\n\tcase FILE_BEQWDATE:\n\t\tp->q = (uint64_t)\n\t\t    (((uint64_t)p->hq[0]<<56)|((uint64_t)p->hq[1]<<48)|\n\t\t     ((uint64_t)p->hq[2]<<40)|((uint64_t)p->hq[3]<<32)|\n\t\t     ((uint64_t)p->hq[4]<<24)|((uint64_t)p->hq[5]<<16)|\n\t\t     ((uint64_t)p->hq[6]<<8)|((uint64_t)p->hq[7]));\n\t\tcvt_64(p, m);\n\t\treturn 1;\n\tcase FILE_LESHORT:\n\t\tp->h = (short)((p->hs[1]<<8)|(p->hs[0]));\n\t\tcvt_16(p, m);\n\t\treturn 1;\n\tcase FILE_LELONG:\n\tcase FILE_LEDATE:\n\tcase FILE_LELDATE:\n\t\tp->l = (int32_t)\n\t\t    ((p->hl[3]<<24)|(p->hl[2]<<16)|(p->hl[1]<<8)|(p->hl[0]));\n\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_LEQUAD:\n\tcase FILE_LEQDATE:\n\tcase FILE_LEQLDATE:\n\tcase FILE_LEQWDATE:\n\t\tp->q = (uint64_t)\n\t\t    (((uint64_t)p->hq[7]<<56)|((uint64_t)p->hq[6]<<48)|\n\t\t     ((uint64_t)p->hq[5]<<40)|((uint64_t)p->hq[4]<<32)|\n\t\t     ((uint64_t)p->hq[3]<<24)|((uint64_t)p->hq[2]<<16)|\n\t\t     ((uint64_t)p->hq[1]<<8)|((uint64_t)p->hq[0]));\n\t\tcvt_64(p, m);\n\t\treturn 1;\n\tcase FILE_MELONG:\n\tcase FILE_MEDATE:\n\tcase FILE_MELDATE:\n\t\tp->l = (int32_t)\n\t\t    ((p->hl[1]<<24)|(p->hl[0]<<16)|(p->hl[3]<<8)|(p->hl[2]));\n\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_FLOAT:\n\t\tcvt_float(p, m);\n\t\treturn 1;\n\tcase FILE_BEFLOAT:\n\t\tp->l =  ((uint32_t)p->hl[0]<<24)|((uint32_t)p->hl[1]<<16)|\n\t\t\t((uint32_t)p->hl[2]<<8) |((uint32_t)p->hl[3]);\n\t\tcvt_float(p, m);\n\t\treturn 1;\n\tcase FILE_LEFLOAT:\n\t\tp->l =  ((uint32_t)p->hl[3]<<24)|((uint32_t)p->hl[2]<<16)|\n\t\t\t((uint32_t)p->hl[1]<<8) |((uint32_t)p->hl[0]);\n\t\tcvt_float(p, m);\n\t\treturn 1;\n\tcase FILE_DOUBLE:\n\t\tcvt_double(p, m);\n\t\treturn 1;\n\tcase FILE_BEDOUBLE:\n\t\tp->q =  ((uint64_t)p->hq[0]<<56)|((uint64_t)p->hq[1]<<48)|\n\t\t\t((uint64_t)p->hq[2]<<40)|((uint64_t)p->hq[3]<<32)|\n\t\t\t((uint64_t)p->hq[4]<<24)|((uint64_t)p->hq[5]<<16)|\n\t\t\t((uint64_t)p->hq[6]<<8) |((uint64_t)p->hq[7]);\n\t\tcvt_double(p, m);\n\t\treturn 1;\n\tcase FILE_LEDOUBLE:\n\t\tp->q =  ((uint64_t)p->hq[7]<<56)|((uint64_t)p->hq[6]<<48)|\n\t\t\t((uint64_t)p->hq[5]<<40)|((uint64_t)p->hq[4]<<32)|\n\t\t\t((uint64_t)p->hq[3]<<24)|((uint64_t)p->hq[2]<<16)|\n\t\t\t((uint64_t)p->hq[1]<<8) |((uint64_t)p->hq[0]);\n\t\tcvt_double(p, m);\n\t\treturn 1;\n\tcase FILE_REGEX:\n\tcase FILE_SEARCH:\n\tcase FILE_DEFAULT:\n\tcase FILE_CLEAR:\n\tcase FILE_NAME:\n\tcase FILE_USE:\n\t\treturn 1;\n\tdefault:\n\t\tfile_magerror(ms, \"invalid type %d in mconvert()\", m->type);\n\t\treturn 0;\n\t}\n}\n\n\nprivate void\nmdebug(uint32_t offset, const char *str, size_t len)\n{\n\t(void) fprintf(stderr, \"mget/%zu @%d: \", len, offset);\n\tfile_showstr(stderr, str, len);\n\t(void) fputc('\\n', stderr);\n\t(void) fputc('\\n', stderr);\n}\n\nprivate int\nmcopy(struct magic_set *ms, union VALUETYPE *p, int type, int indir,\n    const unsigned char *s, uint32_t offset, size_t nbytes, size_t linecnt)\n{\n\t/*\n\t * Note: FILE_SEARCH and FILE_REGEX do not actually copy\n\t * anything, but setup pointers into the source\n\t */\n\tif (indir == 0) {\n\t\tswitch (type) {\n\t\tcase FILE_SEARCH:\n\t\t\tms->search.s = RCAST(const char *, s) + offset;\n\t\t\tms->search.s_len = nbytes - offset;\n\t\t\tms->search.offset = offset;\n\t\t\treturn 0;\n\n\t\tcase FILE_REGEX: {\n\t\t\tconst char *b;\n\t\t\tconst char *c;\n\t\t\tconst char *last;\t/* end of search region */\n\t\t\tconst char *buf;\t/* start of search region */\n\t\t\tconst char *end;\n\t\t\tsize_t lines;\n\n\t\t\tif (s == NULL) {\n\t\t\t\tms->search.s_len = 0;\n\t\t\t\tms->search.s = NULL;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbuf = RCAST(const char *, s) + offset;\n\t\t\tend = last = RCAST(const char *, s) + nbytes;\n\t\t\t/* mget() guarantees buf <= last */\n\t\t\tfor (lines = linecnt, b = buf; lines && b < end &&\n\t\t\t     ((b = CAST(const char *,\n\t\t\t\t memchr(c = b, '\\n', CAST(size_t, (end - b)))))\n\t\t\t     || (b = CAST(const char *,\n\t\t\t\t memchr(c, '\\r', CAST(size_t, (end - c))))));\n\t\t\t     lines--, b++) {\n\t\t\t\tlast = b;\n\t\t\t\tif (b[0] == '\\r' && b[1] == '\\n')\n\t\t\t\t\tb++;\n\t\t\t}\n\t\t\tif (lines)\n\t\t\t\tlast = RCAST(const char *, s) + nbytes;\n\n\t\t\tms->search.s = buf;\n\t\t\tms->search.s_len = last - buf;\n\t\t\tms->search.offset = offset;\n\t\t\tms->search.rm_len = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tcase FILE_BESTRING16:\n\t\tcase FILE_LESTRING16: {\n\t\t\tconst unsigned char *src = s + offset;\n\t\t\tconst unsigned char *esrc = s + nbytes;\n\t\t\tchar *dst = p->s;\n\t\t\tchar *edst = &p->s[sizeof(p->s) - 1];\n\n\t\t\tif (type == FILE_BESTRING16)\n\t\t\t\tsrc++;\n\n\t\t\t/* check that offset is within range */\n\t\t\tif (offset >= nbytes)\n\t\t\t\tbreak;\n\t\t\tfor (/*EMPTY*/; src < esrc; src += 2, dst++) {\n\t\t\t\tif (dst < edst)\n\t\t\t\t\t*dst = *src;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t\tif (*dst == '\\0') {\n\t\t\t\t\tif (type == FILE_BESTRING16 ?\n\t\t\t\t\t    *(src - 1) != '\\0' :\n\t\t\t\t\t    *(src + 1) != '\\0')\n\t\t\t\t\t\t*dst = ' ';\n\t\t\t\t}\n\t\t\t}\n\t\t\t*edst = '\\0';\n\t\t\treturn 0;\n\t\t}\n\t\tcase FILE_STRING:\t/* XXX - these two should not need */\n\t\tcase FILE_PSTRING:\t/* to copy anything, but do anyway. */\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (offset >= nbytes) {\n\t\t(void)memset(p, '\\0', sizeof(*p));\n\t\treturn 0;\n\t}\n\tif (nbytes - offset < sizeof(*p))\n\t\tnbytes = nbytes - offset;\n\telse\n\t\tnbytes = sizeof(*p);\n\n\t(void)memcpy(p, s + offset, nbytes);\n\n\t/*\n\t * the usefulness of padding with zeroes eludes me, it\n\t * might even cause problems\n\t */\n\tif (nbytes < sizeof(*p))\n\t\t(void)memset(((char *)(void *)p) + nbytes, '\\0',\n\t\t    sizeof(*p) - nbytes);\n\treturn 0;\n}\n\nprivate int\nmget(struct magic_set *ms, const unsigned char *s, struct magic *m,\n    size_t nbytes, size_t o, unsigned int cont_level, int mode, int text,\n    int flip, int recursion_level, int *printed_something,\n    int *need_separator, int *returnval)\n{\n\tuint32_t soffset, offset = ms->offset;\n\tuint32_t count = m->str_range;\n\tuint32_t lhs;\n\tint rv, oneed_separator, in_type;\n\tchar *sbuf, *rbuf;\n\tunion VALUETYPE *p = &ms->ms_value;\n\tstruct mlist ml;\n\n\tif (recursion_level >= 20) {\n\t\tfile_error(ms, 0, \"recursion nesting exceeded\");\n\t\treturn -1;\n\t}\n\n\tif (mcopy(ms, p, m->type, m->flag & INDIR, s, (uint32_t)(offset + o),\n\t    (uint32_t)nbytes, count) == -1)\n\t\treturn -1;\n\n\tif ((ms->flags & MAGIC_DEBUG) != 0) {\n\t\tfprintf(stderr, \"mget(type=%d, flag=%x, offset=%u, o=%zu, \"\n\t\t    \"nbytes=%zu, count=%u)\\n\", m->type, m->flag, offset, o,\n\t\t    nbytes, count);\n\t\tmdebug(offset, (char *)(void *)p, sizeof(union VALUETYPE));\n#ifndef COMPILE_ONLY\n\t\tfile_mdump(m);\n#endif\n\t}\n\n\tif (m->flag & INDIR) {\n\t\tint off = m->in_offset;\n\t\tif (m->in_op & FILE_OPINDIRECT) {\n\t\t\tconst union VALUETYPE *q = CAST(const union VALUETYPE *,\n\t\t\t    ((const void *)(s + offset + off)));\n\t\t\tswitch (cvt_flip(m->in_type, flip)) {\n\t\t\tcase FILE_BYTE:\n\t\t\t\toff = q->b;\n\t\t\t\tbreak;\n\t\t\tcase FILE_SHORT:\n\t\t\t\toff = q->h;\n\t\t\t\tbreak;\n\t\t\tcase FILE_BESHORT:\n\t\t\t\toff = (short)((q->hs[0]<<8)|(q->hs[1]));\n\t\t\t\tbreak;\n\t\t\tcase FILE_LESHORT:\n\t\t\t\toff = (short)((q->hs[1]<<8)|(q->hs[0]));\n\t\t\t\tbreak;\n\t\t\tcase FILE_LONG:\n\t\t\t\toff = q->l;\n\t\t\t\tbreak;\n\t\t\tcase FILE_BELONG:\n\t\t\tcase FILE_BEID3:\n\t\t\t\toff = (int32_t)((q->hl[0]<<24)|(q->hl[1]<<16)|\n\t\t\t\t\t\t (q->hl[2]<<8)|(q->hl[3]));\n\t\t\t\tbreak;\n\t\t\tcase FILE_LEID3:\n\t\t\tcase FILE_LELONG:\n\t\t\t\toff = (int32_t)((q->hl[3]<<24)|(q->hl[2]<<16)|\n\t\t\t\t\t\t (q->hl[1]<<8)|(q->hl[0]));\n\t\t\t\tbreak;\n\t\t\tcase FILE_MELONG:\n\t\t\t\toff = (int32_t)((q->hl[1]<<24)|(q->hl[0]<<16)|\n\t\t\t\t\t\t (q->hl[3]<<8)|(q->hl[2]));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\tfprintf(stderr, \"indirect offs=%u\\n\", off);\n\t\t}\n\t\tswitch (in_type = cvt_flip(m->in_type, flip)) {\n\t\tcase FILE_BYTE:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 1))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = p->b & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = p->b | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = p->b ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = p->b + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = p->b - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = p->b * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = p->b / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = p->b % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = p->b;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_BESHORT:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 2))\n\t\t\t\treturn 0;\n\t\t\tlhs = (p->hs[0] << 8) | p->hs[1];\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = lhs & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = lhs | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = lhs ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = lhs + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = lhs - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = lhs * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = lhs / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = lhs % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = lhs;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_LESHORT:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 2))\n\t\t\t\treturn 0;\n\t\t\tlhs = (p->hs[1] << 8) | p->hs[0];\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = lhs & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = lhs | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = lhs ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = lhs + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = lhs - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = lhs * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = lhs / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = lhs % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = lhs;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_SHORT:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 2))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = p->h & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = p->h | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = p->h ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = p->h + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = p->h - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = p->h * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = p->h / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = p->h % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\toffset = p->h;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_BELONG:\n\t\tcase FILE_BEID3:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 4))\n\t\t\t\treturn 0;\n\t\t\tlhs = (p->hl[0] << 24) | (p->hl[1] << 16) |\n\t\t\t    (p->hl[2] << 8) | p->hl[3];\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = lhs & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = lhs | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = lhs ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = lhs + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = lhs - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = lhs * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = lhs / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = lhs % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = lhs;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_LELONG:\n\t\tcase FILE_LEID3:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 4))\n\t\t\t\treturn 0;\n\t\t\tlhs = (p->hl[3] << 24) | (p->hl[2] << 16) |\n\t\t\t    (p->hl[1] << 8) | p->hl[0];\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = lhs & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = lhs | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = lhs ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = lhs + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = lhs - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = lhs * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = lhs / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = lhs % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = lhs;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_MELONG:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 4))\n\t\t\t\treturn 0;\n\t\t\tlhs = (p->hl[1] << 24) | (p->hl[0] << 16) |\n\t\t\t    (p->hl[3] << 8) | p->hl[2];\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = lhs & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = lhs | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = lhs ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = lhs + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = lhs - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = lhs * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = lhs / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = lhs % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = lhs;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_LONG:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 4))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = p->l & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = p->l | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = p->l ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = p->l + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = p->l - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = p->l * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = p->l / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = p->l % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = p->l;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (in_type) {\n\t\tcase FILE_LEID3:\n\t\tcase FILE_BEID3:\n\t\t\toffset = ((((offset >>  0) & 0x7f) <<  0) |\n\t\t\t\t (((offset >>  8) & 0x7f) <<  7) |\n\t\t\t\t (((offset >> 16) & 0x7f) << 14) |\n\t\t\t\t (((offset >> 24) & 0x7f) << 21)) + 10;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (m->flag & INDIROFFADD) {\n\t\t\toffset += ms->c.li[cont_level-1].off;\n\t\t\tif (offset == 0) {\n\t\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t    \"indirect *zero* offset\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\tfprintf(stderr, \"indirect +offs=%u\\n\", offset);\n\t\t}\n\t\tif (mcopy(ms, p, m->type, 0, s, offset, nbytes, count) == -1)\n\t\t\treturn -1;\n\t\tms->offset = offset;\n\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0) {\n\t\t\tmdebug(offset, (char *)(void *)p,\n\t\t\t    sizeof(union VALUETYPE));\n#ifndef COMPILE_ONLY\n\t\t\tfile_mdump(m);\n#endif\n\t\t}\n\t}\n\n\t/* Verify we have enough data to match magic type */\n\tswitch (m->type) {\n\tcase FILE_BYTE:\n\t\tif (OFFSET_OOB(nbytes, offset, 1))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_SHORT:\n\tcase FILE_BESHORT:\n\tcase FILE_LESHORT:\n\t\tif (OFFSET_OOB(nbytes, offset, 2))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_LONG:\n\tcase FILE_BELONG:\n\tcase FILE_LELONG:\n\tcase FILE_MELONG:\n\tcase FILE_DATE:\n\tcase FILE_BEDATE:\n\tcase FILE_LEDATE:\n\tcase FILE_MEDATE:\n\tcase FILE_LDATE:\n\tcase FILE_BELDATE:\n\tcase FILE_LELDATE:\n\tcase FILE_MELDATE:\n\tcase FILE_FLOAT:\n\tcase FILE_BEFLOAT:\n\tcase FILE_LEFLOAT:\n\t\tif (OFFSET_OOB(nbytes, offset, 4))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_DOUBLE:\n\tcase FILE_BEDOUBLE:\n\tcase FILE_LEDOUBLE:\n\t\tif (OFFSET_OOB(nbytes, offset, 8))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_STRING:\n\tcase FILE_PSTRING:\n\tcase FILE_SEARCH:\n\t\tif (OFFSET_OOB(nbytes, offset, m->vallen))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_REGEX:\n\t\tif (nbytes < offset)\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_INDIRECT:\n\t\tif (offset == 0)\n\t\t\treturn 0;\n\t\tif (nbytes < offset)\n\t\t\treturn 0;\n\t\tsbuf = ms->o.buf;\n\t\tsoffset = ms->offset;\n\t\tms->o.buf = NULL;\n\t\tms->offset = 0;\n\t\trv = file_softmagic(ms, s + offset, nbytes - offset,\n\t\t    recursion_level, BINTEST, text);\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\tfprintf(stderr, \"indirect @offs=%u[%d]\\n\", offset, rv);\n\t\trbuf = ms->o.buf;\n\t\tms->o.buf = sbuf;\n\t\tms->offset = soffset;\n\t\tif (rv == 1) {\n\t\t\tif ((ms->flags & (MAGIC_MIME|MAGIC_APPLE)) == 0 &&\n\t\t\t    file_printf(ms, F(ms, m, \"%u\"), offset) == -1) {\n\t\t\t\tfree(rbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (file_printf(ms, \"%s\", rbuf) == -1) {\n\t\t\t\tfree(rbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(rbuf);\n\t\treturn rv;\n\n\tcase FILE_USE:\n\t\tif (nbytes < offset)\n\t\t\treturn 0;\n\t\tsbuf = m->value.s;\n\t\tif (*sbuf == '^') {\n\t\t\tsbuf++;\n\t\t\tflip = !flip;\n\t\t}\n\t\tif (file_magicfind(ms, sbuf, &ml) == -1) {\n\t\t\tfile_error(ms, 0, \"cannot find entry `%s'\", sbuf);\n\t\t\treturn -1;\n\t\t}\n\n\t\toneed_separator = *need_separator;\n\t\tif (m->flag & NOSPACE)\n\t\t\t*need_separator = 0;\n\t\trv = match(ms, ml.magic, ml.nmagic, s, nbytes, offset + o,\n\t\t    mode, text, flip, recursion_level, printed_something,\n\t\t    need_separator, returnval);\n\t\tif (rv != 1)\n\t\t    *need_separator = oneed_separator;\n\t\treturn rv;\n\n\tcase FILE_NAME:\n\t\tif (file_printf(ms, \"%s\", m->desc) == -1)\n\t\t\treturn -1;\n\t\treturn 1;\n\tcase FILE_DEFAULT:\t/* nothing to check */\n\tcase FILE_CLEAR:\n\tdefault:\n\t\tbreak;\n\t}\n\tif (!mconvert(ms, m, flip))\n\t\treturn 0;\n\treturn 1;\n}\n\nprivate uint64_t\nfile_strncmp(const char *s1, const char *s2, size_t len, uint32_t flags)\n{\n\t/*\n\t * Convert the source args to unsigned here so that (1) the\n\t * compare will be unsigned as it is in strncmp() and (2) so\n\t * the ctype functions will work correctly without extra\n\t * casting.\n\t */\n\tconst unsigned char *a = (const unsigned char *)s1;\n\tconst unsigned char *b = (const unsigned char *)s2;\n\tuint64_t v;\n\n\t/*\n\t * What we want here is v = strncmp(s1, s2, len),\n\t * but ignoring any nulls.\n\t */\n\tv = 0;\n\tif (0L == flags) { /* normal string: do it fast */\n\t\twhile (len-- > 0)\n\t\t\tif ((v = *b++ - *a++) != '\\0')\n\t\t\t\tbreak;\n\t}\n\telse { /* combine the others */\n\t\twhile (len-- > 0) {\n\t\t\tif ((flags & STRING_IGNORE_LOWERCASE) &&\n\t\t\t    islower(*a)) {\n\t\t\t\tif ((v = tolower(*b++) - *a++) != '\\0')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if ((flags & STRING_IGNORE_UPPERCASE) &&\n\t\t\t    isupper(*a)) {\n\t\t\t\tif ((v = toupper(*b++) - *a++) != '\\0')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if ((flags & STRING_COMPACT_WHITESPACE) &&\n\t\t\t    isspace(*a)) {\n\t\t\t\ta++;\n\t\t\t\tif (isspace(*b++)) {\n\t\t\t\t\tif (!isspace(*a))\n\t\t\t\t\t\twhile (isspace(*b))\n\t\t\t\t\t\t\tb++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tv = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ((flags & STRING_COMPACT_OPTIONAL_WHITESPACE) &&\n\t\t\t    isspace(*a)) {\n\t\t\t\ta++;\n\t\t\t\twhile (isspace(*b))\n\t\t\t\t\tb++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ((v = *b++ - *a++) != '\\0')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn v;\n}\n\nprivate uint64_t\nfile_strncmp16(const char *a, const char *b, size_t len, uint32_t flags)\n{\n\t/*\n\t * XXX - The 16-bit string compare probably needs to be done\n\t * differently, especially if the flags are to be supported.\n\t * At the moment, I am unsure.\n\t */\n\tflags = 0;\n\treturn file_strncmp(a, b, len, flags);\n}\n\nprivate int\nmagiccheck(struct magic_set *ms, struct magic *m)\n{\n\tuint64_t l = m->value.q;\n\tuint64_t v;\n\tfloat fl, fv;\n\tdouble dl, dv;\n\tint matched;\n\tunion VALUETYPE *p = &ms->ms_value;\n\n\tswitch (m->type) {\n\tcase FILE_BYTE:\n\t\tv = p->b;\n\t\tbreak;\n\n\tcase FILE_SHORT:\n\tcase FILE_BESHORT:\n\tcase FILE_LESHORT:\n\t\tv = p->h;\n\t\tbreak;\n\n\tcase FILE_LONG:\n\tcase FILE_BELONG:\n\tcase FILE_LELONG:\n\tcase FILE_MELONG:\n\tcase FILE_DATE:\n\tcase FILE_BEDATE:\n\tcase FILE_LEDATE:\n\tcase FILE_MEDATE:\n\tcase FILE_LDATE:\n\tcase FILE_BELDATE:\n\tcase FILE_LELDATE:\n\tcase FILE_MELDATE:\n\t\tv = p->l;\n\t\tbreak;\n\n\tcase FILE_QUAD:\n\tcase FILE_LEQUAD:\n\tcase FILE_BEQUAD:\n\tcase FILE_QDATE:\n\tcase FILE_BEQDATE:\n\tcase FILE_LEQDATE:\n\tcase FILE_QLDATE:\n\tcase FILE_BEQLDATE:\n\tcase FILE_LEQLDATE:\n\tcase FILE_QWDATE:\n\tcase FILE_BEQWDATE:\n\tcase FILE_LEQWDATE:\n\t\tv = p->q;\n\t\tbreak;\n\n\tcase FILE_FLOAT:\n\tcase FILE_BEFLOAT:\n\tcase FILE_LEFLOAT:\n\t\tfl = m->value.f;\n\t\tfv = p->f;\n\t\tswitch (m->reln) {\n\t\tcase 'x':\n\t\t\tmatched = 1;\n\t\t\tbreak;\n\n\t\tcase '!':\n\t\t\tmatched = fv != fl;\n\t\t\tbreak;\n\n\t\tcase '=':\n\t\t\tmatched = fv == fl;\n\t\t\tbreak;\n\n\t\tcase '>':\n\t\t\tmatched = fv > fl;\n\t\t\tbreak;\n\n\t\tcase '<':\n\t\t\tmatched = fv < fl;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfile_magerror(ms, \"cannot happen with float: invalid relation `%c'\",\n\t\t\t    m->reln);\n\t\t\treturn -1;\n\t\t}\n\t\treturn matched;\n\n\tcase FILE_DOUBLE:\n\tcase FILE_BEDOUBLE:\n\tcase FILE_LEDOUBLE:\n\t\tdl = m->value.d;\n\t\tdv = p->d;\n\t\tswitch (m->reln) {\n\t\tcase 'x':\n\t\t\tmatched = 1;\n\t\t\tbreak;\n\n\t\tcase '!':\n\t\t\tmatched = dv != dl;\n\t\t\tbreak;\n\n\t\tcase '=':\n\t\t\tmatched = dv == dl;\n\t\t\tbreak;\n\n\t\tcase '>':\n\t\t\tmatched = dv > dl;\n\t\t\tbreak;\n\n\t\tcase '<':\n\t\t\tmatched = dv < dl;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfile_magerror(ms, \"cannot happen with double: invalid relation `%c'\", m->reln);\n\t\t\treturn -1;\n\t\t}\n\t\treturn matched;\n\n\tcase FILE_DEFAULT:\n\tcase FILE_CLEAR:\n\t\tl = 0;\n\t\tv = 0;\n\t\tbreak;\n\n\tcase FILE_STRING:\n\tcase FILE_PSTRING:\n\t\tl = 0;\n\t\tv = file_strncmp(m->value.s, p->s, (size_t)m->vallen, m->str_flags);\n\t\tbreak;\n\n\tcase FILE_BESTRING16:\n\tcase FILE_LESTRING16:\n\t\tl = 0;\n\t\tv = file_strncmp16(m->value.s, p->s, (size_t)m->vallen, m->str_flags);\n\t\tbreak;\n\n\tcase FILE_SEARCH: { /* search ms->search.s for the string m->value.s */\n\t\tsize_t slen;\n\t\tsize_t idx;\n\n\t\tif (ms->search.s == NULL)\n\t\t\treturn 0;\n\n\t\tslen = MIN(m->vallen, sizeof(m->value.s));\n\t\tl = 0;\n\t\tv = 0;\n\n\t\tfor (idx = 0; m->str_range == 0 || idx < m->str_range; idx++) {\n\t\t\tif (slen + idx > ms->search.s_len)\n\t\t\t\tbreak;\n\n\t\t\tv = file_strncmp(m->value.s, ms->search.s + idx, slen, m->str_flags);\n\t\t\tif (v == 0) {\t/* found match */\n\t\t\t\tms->search.offset += idx;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase FILE_REGEX: {\n\t\tint rc;\n\t\tfile_regex_t rx;\n\n\t\tif (ms->search.s == NULL)\n\t\t\treturn 0;\n\n\t\tl = 0;\n\t\trc = file_regcomp(&rx, m->value.s,\n\t\t    REG_EXTENDED|REG_NEWLINE|\n\t\t    ((m->str_flags & STRING_IGNORE_CASE) ? REG_ICASE : 0));\n\t\tif (rc) {\n\t\t\tfile_regerror(&rx, rc, ms);\n\t\t\tv = (uint64_t)-1;\n\t\t} else {\n#ifndef REG_STARTEND\n\t\t\tchar c;\n#endif\n\t\t\tregmatch_t pmatch[1];\n\t\t\tsize_t slen = ms->search.s_len;\n\t\t\t/* Limit by offset if requested */\n\t\t\tif (m->str_range > 0)\n\t\t\t\tslen = MIN(slen, m->str_range);\n#ifndef REG_STARTEND\n#define\tREG_STARTEND\t0\n\t\t\tif (slen != 0)\n\t\t\t\tslen--;\n\t\t\tc = ms->search.s[slen];\n\t\t\t((char *)(intptr_t)ms->search.s)[slen] = '\\0';\n#else\n\t\t\tpmatch[0].rm_so = 0;\n\t\t\tpmatch[0].rm_eo = slen;\n#endif\n\t\t\trc = file_regexec(&rx, (const char *)ms->search.s,\n\t\t\t    1, pmatch, REG_STARTEND);\n#if REG_STARTEND == 0\n\t\t\t((char *)(intptr_t)ms->search.s)[l] = c;\n#endif\n\t\t\tswitch (rc) {\n\t\t\tcase 0:\n\t\t\t\tms->search.s += (int)pmatch[0].rm_so;\n\t\t\t\tms->search.offset += (size_t)pmatch[0].rm_so;\n\t\t\t\tms->search.rm_len =\n\t\t\t\t    (size_t)(pmatch[0].rm_eo - pmatch[0].rm_so);\n\t\t\t\tv = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase REG_NOMATCH:\n\t\t\t\tv = 1;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tfile_regerror(&rx, rc, ms);\n\t\t\t\tv = (uint64_t)-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfile_regfree(&rx);\n\t\tif (v == (uint64_t)-1)\n\t\t\treturn -1;\n\t\tbreak;\n\t}\n\tcase FILE_INDIRECT:\n\tcase FILE_USE:\n\tcase FILE_NAME:\n\t\treturn 1;\n\tdefault:\n\t\tfile_magerror(ms, \"invalid type %d in magiccheck()\", m->type);\n\t\treturn -1;\n\t}\n\n\tv = file_signextend(ms, m, v);\n\n\tswitch (m->reln) {\n\tcase 'x':\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t(void) fprintf(stderr, \"%\" INT64_T_FORMAT\n\t\t\t    \"u == *any* = 1\\n\", (unsigned long long)v);\n\t\tmatched = 1;\n\t\tbreak;\n\n\tcase '!':\n\t\tmatched = v != l;\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t(void) fprintf(stderr, \"%\" INT64_T_FORMAT \"u != %\"\n\t\t\t    INT64_T_FORMAT \"u = %d\\n\", (unsigned long long)v,\n\t\t\t    (unsigned long long)l, matched);\n\t\tbreak;\n\n\tcase '=':\n\t\tmatched = v == l;\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t(void) fprintf(stderr, \"%\" INT64_T_FORMAT \"u == %\"\n\t\t\t    INT64_T_FORMAT \"u = %d\\n\", (unsigned long long)v,\n\t\t\t    (unsigned long long)l, matched);\n\t\tbreak;\n\n\tcase '>':\n\t\tif (m->flag & UNSIGNED) {\n\t\t\tmatched = v > l;\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\t(void) fprintf(stderr, \"%\" INT64_T_FORMAT\n\t\t\t\t    \"u > %\" INT64_T_FORMAT \"u = %d\\n\",\n\t\t\t\t    (unsigned long long)v,\n\t\t\t\t    (unsigned long long)l, matched);\n\t\t}\n\t\telse {\n\t\t\tmatched = (int64_t) v > (int64_t) l;\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\t(void) fprintf(stderr, \"%\" INT64_T_FORMAT\n\t\t\t\t    \"d > %\" INT64_T_FORMAT \"d = %d\\n\",\n\t\t\t\t    (long long)v, (long long)l, matched);\n\t\t}\n\t\tbreak;\n\n\tcase '<':\n\t\tif (m->flag & UNSIGNED) {\n\t\t\tmatched = v < l;\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\t(void) fprintf(stderr, \"%\" INT64_T_FORMAT\n\t\t\t\t    \"u < %\" INT64_T_FORMAT \"u = %d\\n\",\n\t\t\t\t    (unsigned long long)v,\n\t\t\t\t    (unsigned long long)l, matched);\n\t\t}\n\t\telse {\n\t\t\tmatched = (int64_t) v < (int64_t) l;\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\t(void) fprintf(stderr, \"%\" INT64_T_FORMAT\n\t\t\t\t    \"d < %\" INT64_T_FORMAT \"d = %d\\n\",\n\t\t\t\t     (long long)v, (long long)l, matched);\n\t\t}\n\t\tbreak;\n\n\tcase '&':\n\t\tmatched = (v & l) == l;\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t(void) fprintf(stderr, \"((%\" INT64_T_FORMAT \"x & %\"\n\t\t\t    INT64_T_FORMAT \"x) == %\" INT64_T_FORMAT\n\t\t\t    \"x) = %d\\n\", (unsigned long long)v,\n\t\t\t    (unsigned long long)l, (unsigned long long)l,\n\t\t\t    matched);\n\t\tbreak;\n\n\tcase '^':\n\t\tmatched = (v & l) != l;\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t(void) fprintf(stderr, \"((%\" INT64_T_FORMAT \"x & %\"\n\t\t\t    INT64_T_FORMAT \"x) != %\" INT64_T_FORMAT\n\t\t\t    \"x) = %d\\n\", (unsigned long long)v,\n\t\t\t    (unsigned long long)l, (unsigned long long)l,\n\t\t\t    matched);\n\t\tbreak;\n\n\tdefault:\n\t\tfile_magerror(ms, \"cannot happen: invalid relation `%c'\",\n\t\t    m->reln);\n\t\treturn -1;\n\t}\n\n\treturn matched;\n}\n\nprivate int\nhandle_annotation(struct magic_set *ms, struct magic *m)\n{\n\tif (ms->flags & MAGIC_APPLE) {\n\t\tif (file_printf(ms, \"%.8s\", m->apple) == -1)\n\t\t\treturn -1;\n\t\treturn 1;\n\t}\n\tif ((ms->flags & MAGIC_MIME_TYPE) && m->mimetype[0]) {\n\t\tif (file_printf(ms, \"%s\", m->mimetype) == -1)\n\t\t\treturn -1;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nprivate int\nprint_sep(struct magic_set *ms, int firstline)\n{\n\tif (ms->flags & MAGIC_MIME)\n\t\treturn 0;\n\tif (firstline)\n\t\treturn 0;\n\t/*\n\t * we found another match\n\t * put a newline and '-' to do some simple formatting\n\t */\n\treturn file_printf(ms, \"\\n- \");\n}\n"], "fixing_code": ["2014-06-02  14:50  Christos Zoulas <christos@zoulas.com>\n\n\t* Enforce limit of 8K on regex searches that have no limits\n\t* Allow the l modifier for regex to mean line count. Default\n\t  to byte count. If line count is specified, assume a max\n\t  of 80 characters per line to limit the byte count.\n\t* Don't allow conversions to be used for dates, allowing\n\t  the mask field to be used as an offset.\n\n2014-05-30  12:51  Christos Zoulas <christos@zoulas.com>\n\n\t* Make the range operator limit the length of the\n\t  regex search.\n\n2014-05-14  19:23  Christos Zoulas <christos@zoulas.com>\n\n\t* PR/347: Windows fixes\n\t* PR/352: Hangul word processor recognition\n\t* PR/354: Encoding irregularities in text files\n\n2014-05-06  6:12  Christos Zoulas <christos@zoulas.com>\n\n\t* Fix uninitialized title in CDF files (Jan Kaluza)\n\n2014-05-04  14:55  Christos Zoulas <christos@zoulas.com>\n\n\t* PR/351: Fix compilation of empty files \n\n2014-04-30  17:39  Christos Zoulas <christos@zoulas.com>\n\n\t* Fix integer formats: We don't specify 'l' or\n\t  'h' and 'hh' specifiers anymore, only 'll' for\n\t  quads and nothing for the rest. This is so that\n\t  magic writing is simpler.\n\n2014-04-01  15:25  Christos Zoulas <christos@zoulas.com>\n\n\t* PR/341: Jan Kaluza, fix memory leak\n\t* PR/342: Jan Kaluza, fix out of bounds read\n\n2014-03-28  15:25  Christos Zoulas <christos@zoulas.com>\n\n\t* Fix issue with long formats not matching fmtcheck\n\n2014-03-26  11:25  Christos Zoulas <christos@zoulas.com>\n\n\t* release 5.18\n\n2014-03-15  17:45  Christos Zoulas <christos@zoulas.com>\n\n\t* add fmtcheck(3) for those who don't have it\n\n2014-03-14  15:12  Christos Zoulas <christos@zoulas.com>\n\n\t* prevent mime entries from being attached to magic\n\t  entries with no descriptions\n\n\t* adjust magic strength for regex type\n\n\t* remove superfluous ascmagic with encoding test\n\n2014-03-06  12:01  Christos Zoulas <christos@zoulas.com>\n\n\t* fix regression fix echo -ne \"\\012\\013\\014\" | file -i -\n\t  which printed \"binary\" instead of \"application/octet-stream\"\n\n\t* add size_t overflow check for magic file size\n\n2014-02-27  16:01  Christos Zoulas <christos@zoulas.com>\n\n\t* experimental support for matching with CFD CLSID\n\n2014-02-18  13:04  Kimmo Suominen (kimmo@suominen.com)\n\n\t* Cache old LC_CTYPE locale before setting it to \"C\", so\n\t  we can use it to restore LC_CTYPE instead of asking\n\t  setlocale() to scan the environment variables.\n\n2014-02-12  18:21  Christos Zoulas <christos@zoulas.com>\n\n\t* Count recursion levels through indirect magic\n\n2014-02-11  10:40  Christos Zoulas <christos@zoulas.com>\n\n\t* Prevent infinite recursion on files with indirect offsets of 0\n\n2014-01-30  21:00  Christos Zoulas <christos@zoulas.com>\n\n\t* Add -E flag that makes file print filesystem errors to stderr\n\t  and exit.\n\n2014-01-08  17:20  Christos Zoulas <christos@zoulas.com>\n\n\t* mime printing could print results from multiple magic entries\n\t  if there were multiple matches.\n\t* in some cases overflow was not detected when computing offsets\n\t  in softmagic.\n\n2013-12-05  12:00  Christos Zoulas <christos@zoulas.com>\n\n\t* use strcasestr() to for cdf strings\n\t* reset to the \"C\" locale while doing regex operations, or case\n\t  insensitive comparisons; this is provisional\n\n2013-11-19  20:10  Christos Zoulas <christos@zoulas.com>\n\n\t* always leave magic file loaded, don't unload for magic_check, etc.\n\t* fix default encoding to binary instead of unknown which broke recently\n\t* handle empty and one byte files, less specially so that\n\t  --mime-encoding does not break completely.\n\t\t`\n2013-11-06  14:40  Christos Zoulas <christos@zoulas.com>\n\n\t* fix erroneous non-zero exit code from non-existant file and message\n\n2013-10-29  14:25  Christos Zoulas <christos@zoulas.com>\n\n\t* add CDF MSI file detection (Guy Helmer)\n\n2013-09-03  11:56  Christos Zoulas <christos@zoulas.com>\n\n\t* Don't mix errors and regular output if there was an error\n\t* in magic_descriptor() don't close the file and try to restore\n\t  its position\n\n2013-05-30  17:25  Christos Zoulas <christos@zoulas.com>\n\n\t* Don't treat magic as an error if offset was past EOF (Christoph Biedl)\n\n2013-05-28  17:25  Christos Zoulas <christos@zoulas.com>\n\t\n\t* Fix spacing issues in softmagic and elf (Jan Kaluza)\n\n2013-05-02  18:00  Christos Zoulas <christos@zoulas.com>\n\n\t* Fix segmentation fault with multiple magic_load commands.\n\n2013-04-22  11:20  Christos Zoulas <christos@zoulas.com>\n\n\t* The way \"default\" was implemented was not very useful\n\t  because the \"if something was printed at that level\"\n\t  was not easily controlled by the user, and the format\n\t  was bound to a string which is too restrictive. Add\n\t  a \"clear\" for that level keyword and make \"default\"\n\t  void. This way one can do:\n\n\t\t>>13\tclear\tx\n\t\t>>13\tlelong\t1\tfoo\n\t\t>>13\tlelong\t2\tbar\n\t\t>>13\tdefault\tx\n\t\t>>>13\tlelong\tx\tunknown %x\n\n2013-03-25  13:20  Christos Zoulas <christos@zoulas.com>\n\n\t* disallow strength setting in \"name\" entries\n\n2013-03-06  21:24  Christos Zoulas <christos@zoulas.com>\n\n\t* fix recursive magic separator printing\n\n2013-02-26  19:28  Christos Zoulas <christos@zoulas.com>\n\n\t* limit recursion level for mget\n\t* fix pread() related breakage in cdf\n\t* handle offsets properly in recursive \"use\"\n\n2013-02-18  10:39  Christos Zoulas <christos@zoulas.com>\n\n\t* add elf reading of debug info to determine if file is stripped\n\t  (Jan Kaluza)\n\t* use pread()\n\n2013-01-25  18:05  Christos Zoulas <christos@zoulas.com>\n\n\t* change mime description size from 64 to 80 to accommodate OOXML.\n\n2013-01-11  14:50  Christos Zoulas <christos@zoulas.com>\n\n\t* Warn about inconsistent continuation levels.\n\t* Change fsmagic to add a space after it prints.\n\n2013-01-10  21:00  Christos Zoulas <christos@zoulas.com>\n\n\t* Make getline public so that file can link against it.\n\t  Perhaps it is better to rename it, or hide it differently.\n\t  Fixes builds on platforms that do not provide it.\n\t  \n2013-01-07  16:30  Christos Zoulas <christos@zoulas.com>\n\n\t* Add SuS d{,1,2,4,8}, u{,1,2,4,8} and document\n\t  what long, int, short, etc is (Guy Harris)\n\n2013-01-06  11:20  Christos Zoulas <christos@zoulas.com>\n\n\t* add magic_version function and constant\n\t* Redo memory allocation and de-allocation.\n\t  (prevents double frees on non mmap platforms)\n\t* Fix bug with name/use having to do with passing\n\t  found state from the parent to the child and back.\n\n2012-12-19   8:47  Christos Zoulas <christos@zoulas.com>\n\n\t* Only print elf capabilities for archs we know (Jan Kaluza)\n\n2012-10-30  19:14  Christos Zoulas <christos@zoulas.com>\n\n\t* Add \"name\" and \"use\" file types in order to look\n\t  inside mach-o files.\n\n2012-09-06  10:40  Christos Zoulas <christos@zoulas.com>\n\n\t* make --version exit 0 (Matthew Schultz)\n\t* add string/T (Jan Kaluza)\n\n2012-08-09  2:15  Christos Zoulas <christos@zoulas.com>\n\n\t* add z and t modifiers for our own vasprintf\n\t* search for $HOME/.magic.mgc if it is there first\n\t* fix reads from a pipe, and preserve errno\n\n2012-05-15  13:12  Christos Zoulas <christos@zoulas.com>\n\n\t* use ctime_r, asctime_r\n\n2012-04-06  17:18  Christos Zoulas <christos@zoulas.com>\n\n\t* Fixes for indirect offsets to handle apple disk formats\n\n2012-04-03  18:26  Christos Zoulas <christos@zoulas.com>\n\n\t* Add windows date field types\n\t* More info for windows shortcuts (incomplete)\n\n2012-02-20  17:33  Christos Zoulas <christos@zoulas.com>\n\n\t* Fix CDF parsing issues found by CERT's fuzzing tool (Will Dormann)\n\n2011-12-15  12:17  Chris Metcalf <cmetcalf@tilera.com>\n\n\t* Support Tilera architectures (tile64, tilepro, tilegx).\n\n2011-12-16  16:33  Reuben Thomas <rrt@sc3d.org>\n\n\t* Add magic for /usr/bin/env Perl scripts\n\t* Weaken generic script magic to avoid clashing with\n\tlanguage-specific magic.\n\n2011-12-08  13:37  Reuben Thomas <rrt@sc3d.org>\n\n\t* Simplify if (p) free(p) to free(p).\n\n2011-12-08  13:07  Reuben Thomas <rrt@sc3d.org>\n\n\t* Remove hardwired token finding (names.h), turning it into soft\n\tmagic. Patterns are either anchored regexs or search/8192. English\n\tlanguage detection and PL/1 detection have been removed as they\n\twere too fragile. -e tokens is still accepted for backwards\n\tcompatibility.\n\t* Move 3ds patterns (which are commented out anyway) into autodesk\n\t(they were, oddly, in c-lang).\n\n2011-12-06  00:16  Reuben Thomas <rrt@sc3d.org>\n\n\t* Tweak strength of generic hash-bang detectors to be less than\n\tspecific ones.\n\t* Make an inconsistent description of Python scripts consistent.\n\n2011-12-05  23:58  Reuben Thomas <rrt@sc3d.org>\n\n\t* Fix minor error in file(1).\n\n2011-11-05  00:00  Reuben Thomas <rrt@sc3d.org>\n\n\t* Fix issue #150 (I hope).\n\n2011-09-22  12:57  Christos Zoulas <christos@zoulas.com>\n\n\t* Python3 binding fixes from Kelly Anderson\n\n2011-09-20  11:32  Christos Zoulas <christos@zoulas.com>\n\n\t* If a string type magic entry is marked as text or binary\n\t  only match text files against text entries and binary\n\t  files against binary entries.\n\n2011-09-01  12:12  Christos Zoulas <christos@zoulas.com>\n\n\t* Don't wait for any subprocess, just the one we forked.\n\n2011-08-26  16:40  Christos Zoulas <christos@zoulas.com>\n\n\t* If the application name is not set in a cdf file, try to see\n\t  if it has a directory with the application name on it.\n\n2011-08-17  14:32  Christos Zoulas <christos@zoulas.com>\n\n\t* Fix ELF lseek(2) madness. Inspired by PR/134 by Jan Kaluza\n\n2011-08-14  09:03  Christos Zoulas <christos@zoulas.com>\n\n\t* Don't use variable string formats.\n\n2011-07-12  12:32  Reuben Thomas <rrt@sc3d.org>\n\n\t* Fix detection of Zip files (Mantis #128).\n\t* Make some minor improvements to file(1).\n\t* Rename MIME types for filesystem objects for consistency with\n\t  xdg-utils. Typically this means that application/x-foo becomes\n\t  inode/foo, but some names also change slightly, e.g.\n\t  application/x-character-device becomes inode/chardevice.\n\n2011-05-10  20:57  Christos Zoulas <christos@zoulas.com>\n\n\t* fix mingw compilation (Abradoks)\n\n2011-05-10  20:57  Christos Zoulas <christos@zoulas.com>\n\n\t* remove patchlevel.h\n\t* Fix read past allocated memory caused by double-incrementing\n\t  a pointer in a loop (reported by Roberto Maar)\n\n2011-03-30  15:45  Christos Zoulas <christos@zoulas.com>\n\n\t* Fix cdf string buffer setting (Sven Anders)\n\n2011-03-20  16:35  Christos Zoulas <christos@zoulas.com>\n\n\t* Eliminate MAXPATHLEN and use dynamic allocation for\n\t  path and file buffers.\n\n2011-03-15  18:15  Christos Zoulas <christos@zoulas.com>\n\n\t* binary tests on magic entries with masks could spuriously\n\t  get converted to ascii.\n\n2011-03-12  18:06  Reuben Thomas <rrt@sc3d.org>\n\n\t* Improve file.man (remove BUGS, present email addresses consistently).\n\n2011-03-07  19:38  Christos Zoulas <christos@zoulas.com>\n\n\t* add lrzip support (from Ville Skytta)\n\n2011-02-10  16:36  Christos Zoulas <christos@zoulas.com>\n\n\t* fix CDF bounds checking (Guy Helmer)\n\n2011-02-10  12:03  Christos Zoulas <christos@zoulas.com>\n\n\t* add cdf_ctime() that prints a meaningful error when time cannot\n\t  be converted.\n\n2011-02-02  20:40  Christos Zoulas <christos@zoulas.com>\n\n\t* help and version output to stdout.\n\n\t* When matching softmagic for ascii files, don't just print\n\t  the softmagic classification, keep going and print the\n\t  text classification too. This fixes broken troff files when\n\t  we moved them from keyword recognition to softmagic\n\t  (they stopped printing \"with CRLF\" etc.)\n\t  Reported by Doug McIlroy.\n\n2011-01-16  19:31  Reuben Thomas <rrt@sc3d.org>\n\n\t* Fix two potential buffer overruns in apprentice_list.\n\n2011-01-14  22:33  Reuben Thomas <rrt@sc3d.org>\n\n\t* New Python binding in pure Python.\n\t* Update libmagic(3).\n\n2011-01-06  21:40  Reuben Thomas <rrt@sc3d.org>\n\n\t* Fix Python bindings (including recent Python 3 compatibility\n\t  update).\n\n2011-01-04  18:43  Reuben Thomas <rrt@sc3d.org>\n\n\t* magic/Makefile.am: make it easier to recover from magic build failures.\n\t* Fix pstring length specifier parsing to avoid generating invalid\n\t  magic files.\n\t* Add pstring length \"J\" (for \"JPEG\") to specify that the length\n\t  include itself.\n\t* Fix JPEG comment parsing at last using pstring/HJ!\n\t* Ignore section 5 man pages in doc/.cvsignore.\n\n2010-12-22  13:12  Christos Zoulas <christos@zoulas.com>\n\n\t* Add pstring/BHhLl to specify the type of the length of pascal\n\t  strings.\n\n2010-11-26  18:39  Reuben Thomas <rrt@sc3d.org>\n\n\t* Fix \"-e soft\": it was ignored when softmagic was called\n\t  during asciimagic.\n\t* Improve comments and use \"unsigned char\" in tar.h/is_tar.c.\n\n2010-11-05  17:26  Reuben Thomas <rrt@sc3d.org>\n\n\t* Make bug reporting addresses more visible.\n\n2010-11-01  18:35  Reuben Thomas <rrt@sc3d.org>\n\n\t* Add tcl magic from Gustaf Neumann\n\n2010-10-24  10:42  Christos Zoulas <christos@zoulas.com>\n\n\t* Fix the whitespace comparing code (Christopher Chittleborough)\n\n2010-10-06  21:05  Christos Zoulas <christos@zoulas.com>\n\n\t* allow string/t to work (Jan Kaluza)\n\n2010-09-20  22:11  Reuben Thomas <rrt@sc3d.org>\n\n\t* Apply some patches from Ubuntu and Fedora.\n\n2010-09-20  21:16  Reuben Thomas <rrt@sc3d.org>\n\n\t* Apply all patches from Debian package 5.04-6 which have not\n\t  already been applied and are not Debian-specific.\n\n2010-09-20  15:24  Reuben Thomas <rrt@sc3d.org>\n\n\t* Minor security fix to softmagic.c (don't use untrusted\n\t  string as printf format).\n\n2010-07-21  12:20  Christos Zoulas <christos@zoulas.com>\n\n\t* MINGW32 portability from LRN\n\n\t* Don't warn about escaping magic regex chars when we are in a regex.\n\n2010-07-19  10:55  Christos Zoulas <christos@zoulas.com>\n\n\t* Only try to print prpsinfo for core files. (Jan Kaluza)\n\n2010-04-22  12:55  Christos Zoulas <christos@zoulas.com>\n\n\t* Try more elf offsets for Debian core files.  (Arnaud Giersch)\n\n2010-02-20  15:18  Reuben Thomas <rrt@sc3d.org>\n\n\t* Clarify which sort of CDF we mean.\n\n2010-02-14  22:58  Reuben Thomas <rrt@sc3d.org>\n\n\t* Re-jig Zip file type magic so that unsupported special\n\t  Zip types (those with \"mimetype\" at offset 30) can be\n\t  recognized.\n\n2010-02-02  21:50  Reuben Thomas <rrt@sc3d.org>\n\n\t* Add support for OCF (EPUB) files (application/epub+zip)\n\n2010-01-28  18:25  Christos Zoulas <christos@zoulas.com>\n\n\t* Fix core-dump from unbound loop:\n\t  https://bugzilla.redhat.com/show_bug.cgi?id=533245\n\n2010-01-22  15:45  Christos Zoulas <christos@zoulas.com>\n\n\t* print proper mime for crystal reports file\n\n\t* print the last summary information of a cdf document, not the\n\t  first so that nested documents print the right info\n\n2010-01-16  18:42  Charles Longeau <chl@tuxfamily.org>\n\n\t* bring back some fixes from OpenBSD:\n\t\t- make gcc2 builds file\n\t\t- fix typos in a magic file comment\n\n2009-11-17  18:35  Christos Zoulas <christos@zoulas.com>\n\n\t* ctime/asctime can return NULL on some OS's although\n\t  they should not (Toshit Antani)\n\n2009-09-14  13:49  Christos Zoulas <christos@zoulas.com>\n\n\t* Centralize magic path handling routines and remove the\n\t  special-casing from file.c so that the python module for\n\t  example comes up with the same magic path (Fixes ~/.magic\n\t  handling) (from Gab)\n\n2009-09-11  23:38  Reuben Thomas <rrt@sc3d.org>\n\n\t* When magic argument is a directory, read the files in\n\t  strcmp-sorted order (fixes Debian bug #488562 and our own FIXME).\n\n2009-09-11  13:11  Reuben Thomas <rrt@sc3d.org>\n\n\t* Combine overlapping epoc and psion magic files into one (epoc).\n\n\t* Add some more EPOC MIME types.\n\n2009-08-19  15:55  Christos Zoulas <christos@zoulas.com>\n\n\t* Fix 3 bugs (From Ian Darwin):\n\t    - file_showstr could move one past the end of the array\n\t    - parse_apple did not nul terminate the string in the overflow case\n\t    - parse_mime truncated the wrong string in the overflow case\n\n2009-08-12  12:28  Robert Byrnes  <byrnes@wildpumpkin.net>\n\n\t* Include Localstuff when compiling magic.\n\n2009-07-15  10:05  Christos Zoulas <christos@zoulas.com>\n\n\t* Fix logic for including mygetopts.h\n\n\t* Make cdf.c compile again with debugging\n\n\t* Add the necessary field handling for crystal reports files to work\n\n2009-06-23 01:34  Reuben Thomas <rrt@sc3d.org>\n\n\t* Stop \"(if\" identifying Lisp files, that's plain dumb!\n\n2009-06-09 22:13  Reuben Thomas <rrt@sc3d.org>\n\n\t* Add a couple of missing MP3 MIME types.\n\n2009-05-27 23:00  Reuben Thomas <rrt@sc3d.org>\n\n\t* Add full range of hash-bang tests for Python and Ruby.\n\n\t* Add MIME types for Python and Ruby scripts.\n\n2009-05-13  10:44  Christos Zoulas <christos@zoulas.com>\n\n\t* off by one in parsing hw capabilities in elf\n\t  (Cheng Renquan)\n\n2009-05-08  13:40  Christos Zoulas <christos@zoulas.com>\n\t\n\t* lint fixes and more from NetBSD\n\n2009-05-06  10:25  Christos Zoulas <christos@zoulas.com>\n\n\t* Avoid null dereference in cdf code (Drew Yao)\n\n\t* More cdf bounds checks and overflow checks\n\n2009-05-01  18:37  Christos Zoulas <christos@zoulas.com>\n\n\t* Buffer overflow fixes from Drew Yao\n\n2009-04-30  17:10  Christos Zoulas <christos@zoulas.com>\n\n\t* Fix more cdf lossage. All the documents I have\n\t  right now print the correct information.\n\n2009-03-27  18:43  Christos Zoulas <christos@zoulas.com>\n\n\t* don't print \\012- separators in the same magic entry \n\t  if it consists of multiple magic printing lines.\n\n2009-03-23  10:20  Christos Zoulas <christos@zoulas.com>\n\n\t* Avoid file descriptor leak in compress code from\n\t  (Daniel Novotny)\n\n2009-03-18  16:50  Christos Zoulas <christos@zoulas.com>\n\n\t* Allow escaping of relation characters, so that we can say \\^[A-Z]\n\t  and the ^ is not eaten as a relation char.\n\n\t* Fix troff and fortran to their previous glory using\n\t  regex. This was broken since their removel from ascmagic.\n\n2009-03-10  16:50  Christos Zoulas <christos@zoulas.com>\n\n\t* don't use strlen in strndup() (Toby Peterson)\n\n2009-03-10  7:45  Christos Zoulas <christos@zoulas.com>\n\n\t* avoid c99 syntax.\n\n2009-02-23 15:45  Christos Zoulas <christos@zoulas.com>\n\n\t* make the cdf code use the buffer first if available,\n\t  and then the fd code.\n\n2009-02-13 13:45  Christos Zoulas <christos@zoulas.com>\n\n\t* look for struct option to determine if getopt.h is usable for IRIX.\n\n\t* sanitize cdf document strings\n\n2009-02-04 13:25  Christos Zoulas <christos@zoulas.com>\n\n\t* fix OS/2 warnings.\n\n2008-12-12 15:50  Christos Zoulas <christos@zoulas.com>\n\n\t* fix initial offset calculation for non 4K sector files\n\n\t* add loop limits to avoid DoS attacks by constructing\n\t  looping sector references.\n\n2008-12-03 13:05  Christos Zoulas <christos@zoulas.com>\n\n\t* fix memory botches on cdf file parsing.\n\n\t* exit with non-zero value for any error, not just for the last\n\t  file processed.\n\n2008-11-09 20:42  Charles Longeau <chl@tuxfamily.org>\n\n\t* Replace all str{cpy,cat} functions with strl{cpy,cat}\n\t* Ensure that strl{cpy,cat} are included in libmagic,\n\t  as needed.\n\n2008-11-06 18:18  Christos Zoulas <christos@zoulas.com>\n\n\t* Handle ID3 format files.\n\n2008-11-06 23:00  Reuben Thomas <rrt@sc3d.org>\n\n\t* Fix --mime, --mime-type and --mime-encoding under new scheme.\n\n\t* Rename \"ascii\" to \"text\" and add \"encoding\" test.\n\n\t* Return a precise (\"utf-16le\" or \"utf-16be\") MIME charset for\n\t  UTF-16.\n\n\t* Fix error in comment caused by automatic indentation adding\n\t  words!\n\n2008-11-06 10:35  Christos Zoulas <christos@astron.com>\n\n\t* use memchr instead of strchr because the string\n\t  might not be NUL terminated (Scott MacVicar)\n\n2008-11-03 07:31  Reuben Thomas <rrt@sc3d.org>\n\n\t* Fix a printf with a non-literal format string.\n\n\t* Fix formatting and punctuation of help for \"--apple\".\n\n2008-10-30 11:00  Reuben Thomas <rrt@sc3d.org>\n\n\t* Correct words counts in comments of struct magic.\n\n\t* Fix handle_annotation to allow both Apple and MIME types to be\n\t  printed, and to return correct code if MIME type is\n\t  printed (1, not 0) or if there's an error (-1 not 1).\n\n\t* Fix output of charset for MIME type (precede with semi-colon;\n\t  fixes Debian bug #501460).\n\n\t* Fix potential attacks via conversion specifications in magic\n\t  strings.\n\n\t* Add a FIXME for Debian bug #488562 (magic files should be\n\t  read in a defined order, by sorting the names).\n\n2008-10-18 16:45  Christos Zoulas <christos@astron.com>\n\n\t* Added APPLE file creator/type\n\n2008-10-12 10:20  Christos Zoulas <christos@astron.com>\n\n\t* Added CDF parsing\n\n2008-10-09 16:40  Christos Zoulas <christos@astron.com>\n\n\t* filesystem and msdos patches (Joerg Jenderek)\n\n2008-10-09 13:20  Christos Zoulas <christos@astron.com>\n\n\t* correct --exclude documentation issues: remove troff and fortran\n\t  and rename \"token\" to \"tokens\". (Randy McMurchy)\n\n2008-10-01 10:30  Christos Zoulas <christos@astron.com>\n\n\t* Read ~/.magic in addition to the default magic file not instead\n\t  of, as documented in the man page.\n\n2008-09-10 21:30  Reuben Thomas  <rrt@sc3d.org>\n\n\t* Comment out graphviz patterns, as they match too many files.\n\n2008-08-30 12:54  Christos Zoulas <christos@astron.com>\n\n\t* Don't eat trailing \\n in magic enties.\n\n\t* Cast defines to allow compilation using a c++ compiler.\n\n2008-08-25 23:56  Reuben Thomas  <rrt@sc3d.org>\n\n\t* Add text/x-lua MIME type for Lua scripts.\n\n\t* Escape { in regex in graphviz patterns.\n\n2008-07-26 00:59  Reuben Thomas  <rrt@sc3d.org>\n\n\t* Add MIME types for special files.\n\n\t* Use access to give more accurate information for files that\n\t  can't be opened.\n\n\t* Add a TODO list.\n\n2008-07-02 11:15  Christos Zoulas  <christos@astron.com>\n\n\t* add !:strength op to adjust magic strength (experimental)\n\n2008-06-16 21:41  Reuben Thomas  <rrt@sc3d.org>\n\n\t* Fix automake error in configure.ac.\n\n\t* Add MIME type for Psion Sketch files.\n\n2008-06-05 08:59  Christos Zoulas  <christos@astron.com>\n\n\t* Don't print warnings about bad namesize in stripped\n\t  binaries with PT_NOTE is still there, and the actual\n\t  note is gone (Jakub Jelinek)\n\n2008-05-28 15:12  Robert Byrnes  <byrnes@wildpumpkin.net>\n\n\t* magic/Magdir/elf:\n\t  Note invalid byte order for little-endian SPARC32PLUS.\n\t  Add SPARC V9 vendor extensions and memory model.\n\n\t* src/elfclass.h:\n\t  Pass target machine to doshn (for Solaris hardware capabilities).\n\n\t* src/readelf.c (doshn):\n\t  Add support for Solaris hardware/software capabilities.\n\n\t* src/readelf.h:\n\t  Ditto.\n\n\t* src/vasprintf.c (dispatch):\n\t  Add support for ll modifier.\n\n2008-05-16 10:25  Christos Zoulas  <christos@astron.com>\n\n\t* Fix compiler warnings.\n\n\t* remove stray printf, and fix a vprintf bug. (Martin Dorey)\n\n2008-05-06 00:13  Robert Byrnes  <byrnes@wildpumpkin.net>\n\n\t* src/Makefile.am:\n\t  Ensure that getopt_long and [v]asprintf are included in libmagic,\n\t  as needed.\n\n\t  Remove unnecessary EXTRA_DIST.\n\n\t* src/Makefile.in:\n\t  Rerun automake.\n\n\t* src/vasprintf.c (dispatch):\n\t  Fix variable precision bug: be sure to step past '*'.\n\n\t* src/vasprintf.c (core):\n\t  Remove unreachable code.\n\n\t* src/apprentice.c (set_test_type):\n\t  Add cast to avoid compiler warning.\n\n2008-04-22 23:45  Christos Zoulas  <christos@astron.com>\n\n\t* Add magic submission guidelines (Abel Cheung)\n\n\t* split msdos and windows magic (Abel Cheung)\n\n2008-04-04 11:00  Christos Zoulas  <christos@astron.com>\n\n\t* >= <= is not supported, so fix the magic and warn about it.\n\t  reported by: Thien-Thi Nguyen <ttn@gnuvola.org>\n\n2008-03-27 16:16  Robert Byrnes  <byrnes@wildpumpkin.net>\n\n\t* src/readelf.c (donote):\n\t  ELF core file command name/line bug fixes and enhancements:\n\n\t  Try larger offsets first to avoid false matches\n\t  from earlier data that happen to look like strings;\n\t  this primarily affected SunOS 5.x 32-bit Intel core files.\n\n\t  Add support for command line (instead of just short name)\n\t  for SunOS 5.x.\n\n\t  Add information about NT_PSINFO for SunOS 5.x.\n\n\t  Only trim whitespace from end of command line.\n\n2007-02-11 01:36 Reuben Thomas <rrt@sc3d.org>\n\n\t* Change strength of ! from MULT to 0, as it matches almost\n\t\t  anything (Reuben Thomas)\n\n\t* Debian fixes (Reuben Thomas)\n\n2007-02-11 00:17 Reuben Thomas <rrt@sc3d.org>\n\n\t* Clarify UTF-8 BOM message (Reuben Thomas)\n\n\t* Add HTML comment to token list in names.h\n\n2007-02-04 15:50 Christos Zoulas <christos@astron.com>\n\n\t* Debian fixes (Reuben Thomas)\n\n2007-02-04 11:31 Christos Zoulas <christos@astron.com>\n\n\t* !:mime annotations in magic files (Reuben Thomas)\n\n2007-01-29 15:35 Christos Zoulas <christos@astron.com>\n\n\t* zero out utime/utimes structs (Gavin Atkinson)\n\n2007-01-26 13:45 Christos Zoulas <christos@astron.com>\n\n\t* reduce writable data from Diego \"Flameeyes\" Petten\n\n2007-12-28 15:06 Christos Zoulas <christos@astron.com>\n\n\t* strtof detection\n\n\t* remove bogus regex magic that could cause a DoS\n\n\t* better mismatch version message\n\n2007-12-27 11:35 Christos Zoulas <christos@astron.com>\n\n\t* bring back some fixes from OpenBSD\n\n\t* treat ELF dynamic objects as executables\n\n\t* fix gcc warnings\n\n2007-12-01 19:55 Christos Zoulas <christos@astron.com>\n\n\t* make sure we have zlib.h and libz to compile the builtin\n\t  decompress code\n\n2007-10-28 20:48 Christos Zoulas <christos@astron.com>\n\n \t* float and double magic support (Behan Webster)\n\n2007-10-28 20:48 Christos Zoulas <christos@astron.com>\n\n\t* Convert fortran to a soft test (Reuben Thomas)\n\n2007-10-23  5:25 Christos Zoulas <christos@astron.com>\n\n\t* Add --with-filename, and --no-filename (Reuben Thomas)\n\n2007-10-23  3:59 Christos Zoulas <christos@astron.com>\n\n\t* Rest of the mime split (Reuben Thomas)\n\n\t* Make usage message generated from the flags so that\n\t  they stay consistent (Reuben Thomas)\n\n2007-10-20  3:06 Christos Zoulas <christos@astron.com>\n\n\t* typo in comment, missing ifdef QUICK, remove unneeded code\n\t\t(Charles Longeau)\n\n2007-10-17  3:33 Christos Zoulas <christos@astron.com>\n\n\t* Fix problem printing -\\012 in some entries\n\n\t* Separate magic type and encoding flags (Reuben Thomas)\n\n2007-10-09  3:55 Christos Zoulas <christos@astron.com>\n\n\t* configure fix for int64 and strndup (Reuben Thomas)\n\n2007-09-26  4:45 Christos Zoulas <christos@astron.com>\n\n\t* Add magic_descriptor() function.\n\n\t* Fix regression in elf reading code where the core name was\n\t  not being printed.\n\n\t* Don't convert NUL's to spaces in {l,b}estring16 (Daniel Dawson)\n\n2007-08-19  6:30 Christos Zoulas <christos@astron.com>\n\n\t* Make mime format consistent so that it can\n\t  be easily parsed:\n\t      mimetype [charset=character-set] [encoding=encoding-mime-type]\n\n\t  Remove spurious extra text from some MIME type printouts\n\t  (mostly in is_tar).\n\n\t  Fix one case where -i produced nothing at all (for a 1-byte file,\n\t  which is now classed as application/octet-stream).\n\n\t  Remove 7/8bit classifications, since they were arbitrary\n\t  and not based on the file data.\n\n\t  This work was done by Reuben Thomas\n\n2007-05-24 10:00 Christos Zoulas <christos@astron.com>\n\n\t* Fix another integer overflow (Colin Percival)\n\n2007-03-26 13:58 Christos Zoulas <christos@astron.com>\n\n\t* make sure that all of struct magic_set is initialized appropriately\n\t  (Brett)\n\n2007-03-25 17:44 Christos Zoulas <christos@astron.com>\n\n\t* reset left bytes in the buffer (Dmitry V. Levin)\n\n\t* compilation failed with COMPILE_ONLY and ENABLE_CONDITIONALS\n\t  (Peter Avalos)\n\n2007-03-15 10:51 Christos Zoulas <christos@astron.com>\n\n\t* fix fortran and nroff reversed tests (Dmitry V. Levin)\n\n\t* fix exclude option (Dmitry V. Levin)\n\n2007-02-08 17:30 Christos Zoulas <christos@astron.com>\n\n\t* fix integer underflow in file_printf which can lead to\n\t  to exploitable heap overflow (Jean-Sebastien Guay-Lero)\n\n2007-02-05 11:35 Christos Zoulas <christos@astron.com>\n\n\t* make socket/pipe reading more robust\n\n2007-01-25 16:01 Christos Zoulas <christos@astron.com>\n\n\t* Centralize all the tests in file_buffer.\n\n\t* Add exclude flag.\n\n2007-01-18 05:29 Anon Ymous <do@not.spam.me>\n\n\t* Move the \"type\" detection code from parse() into its own table\n\t  driven routine.  This avoids maintaining multiple lists in\n\t  file.h.\n\n\t* Add an optional conditional field (ust before the type field).\n\t  This code is wrapped in \"#ifdef ENABLE_CONDITIONALS\" as it is\n\t  likely to go away.\n\n2007-01-16 23:24 Anon Ymous <do@not.spam.me>\n\n\t* Fix an initialization bug in check_mem().\n\n2007-01-16 14:58 Anon Ymous <do@not.spam.me>\n\n\t* Add a \"default\" type to print a message if nothing previously\n\t  matched at that level or since the last default at that\n\t  level.  This is useful for setting up switch-like statements.\n\t  It can also be used to do if/else constructions without a\n\t  redundant second test.\n\n\t* Fix the \"x\" special case test so that one can test for that\n\t  string with \"=x\".\n\n\t* Allow \"search\" to search the entire buffer if the \"/N\"\n\t  search count is missing.\n\n\t* Make \"regex\" work!  It now starts its search at the\n\t  specified offset and takes an (optional) \"/N\" line count to\n\t  specify the search range; otherwise it searches to the end\n\t  of the file.  The match is now grabbed correctly for format\n\t  strings and the offset set to the end of the match.\n\n\t* Add a \"/s\" flag to \"regex\" and \"search\" to set the offset to\n\t  the start of the match.  By default the offset is set to the\n\t  end of the match, as it is with other tests.  This is mostly\n\t  useful for \"regex\".\n\n\t* Make \"search\", \"string\" and \"pstring\" use the same\n\t  file_strncmp() routine so that they support the same flags;\n\t  \"bestring16\" and \"lestring16\" call the same routine, but\n\t  with flags = 0.  Also add a \"/C\" flag (in analogy to \"/c\")\n\t  to ignore the case on uppercase (lowercase) characters in\n\t  the test string.\n\n\t* Strict adherence to C style string escapes.  A warnings are\n\t  printed when compiling.  Note: previously \"\\a\" was\n\t  incorrectly translated to 'a' instead of an <alert> (i.e.,\n\t  BELL, typically 0x07).\n\n\t* Make this compile with \"-Wall -Wextra\" and all the warning\n\t  flags used with WARNS=4 in the NetBSD source.  Also make it\n\t  pass lint.\n\n\t* Many \"cleanups\" and hopefully not too many new bugs!\n\n2007-01-16 14:56 Anon Ymous <do@not.spam.me>\n\n\t* make several more files compile with gcc warnings\n\t  on and also make them pass lint.\n\n2007-01-16 14:54 Anon Ymous <do@not.spam.me>\n\n\t* fix a puts()/putc() usage goof in file.c\n\n\t* make file.c compile with gcc warnings and pass lint\n\n2006-12-11 16:49 Christos Zoulas <christos@astron.com>\n\n\t* fix byteswapping issue\n\n\t* report the number of bytes we tried to\n\t  allocate when allocation fails\n\n\t* add a few missed cases in the strength routine\n\n2006-12-08 16:32 Christos Zoulas <christos@astron.com>\n\n\t* store and print the line number of the magic\n\t  entry for debugging.\n\n\t* if the magic entry did not print anything,\n\t  don't treat it as a match\n\n\t* change the magic strength algorithm to take\n\t  into account the relationship op.\n\n\t* fix a bug in search where we could accidentally\n\t  return a match.\n\n\t* propagate the error return from match to\n\t  file_softmagic.\n\n2006-11-25 13:35 Christos Zoulas <christos@astron.com>\n\n\t* Don't store the current offset in the magic\n\t  struct, because it needs to be restored and\n\t  it was not done properly all the time. Bug\n\t  found by: Arkadiusz Miskiewicz\n\n\t* Fix problem in the '\\0' separator; and don't\n\t  print it as an additional separator; print\n\t  it as the only separator.\n\n2006-11-17 10:51 Christos Zoulas <christos@astron.com>\n\n\t* Added a -0 option to print a '\\0' separator\n\t  Etienne Buira <etienne.buira@free.fr>\n\n2006-10-31 15:14 Christos Zoulas <christos@astron.com>\n\n\t* Check offset before copying (Mike Frysinger)\n\n\t* merge duplicated code\n\n\t* add quad date support\n\n\t* make sure that we nul terminate desc (Ryoji Kanai)\n\n\t* don't process elf notes multiple times\n\n\t* allow -z to report empty compressed files\n\n\t* use calloc to initialize the ascii buffers (Jos van den Oever)\n\n2006-06-08 11:11 Christos Zoulas <christos@astron.com>\n\n\t* QNX fixes (Mike Gorchak)\n\n\t* Add quad support.\n\n\t* FIFO checks (Dr. Werner Fink)\n\n\t* Linux ELF fixes (Dr. Werner Fink)\n\n\t* Magic format checks (Dr. Werner Fink)\n\n\t* Magic format function improvent (Karl Chen)\n\n2006-05-03 11:11 Christos Zoulas <christos@astron.com>\n\n\t* Pick up some elf changes and some constant fixes from SUSE\n\n\t* Identify gnu tar vs. posix tar\n\n\t* When keep going, don't print spurious newlines (Radek Vokal)\n\n2006-04-01 12:02 Christos Zoulas <christos@astron.com>\n\n\t* Use calloc instead of malloc (Mike Frysinger)\n\n\t* Fix configure script to detect wctypes.h (Mike Frysinger)\n\n2006-03-02 16:06 Christos Zoulas <christos@astron.com>\n\n\t* Print empty if the file is (Mike Frysinger)\n\n\t* Don't try to read past the end of the buffer (Mike Frysinger)\n\n\t* Sort magic entries by strength [experimental]\n\n2005-11-29 13:26 Christos Zoulas <christos@astron.com>\n\n\t* Use iswprint() to convert the output string.\n\t    (Bastien Nocera)\n\n2005-10-31 8:54 Christos Zoulas <christos@astron.com>\n\n\t* Fix regression where the core info was not completely processed\n\t    (Radek Vokal)\n\n2005-10-20 11:15 Christos Zoulas <christos@astron.com>\n\n\t* Middle Endian magic (Diomidis Spinellis)\n\n2005-10-17 11:15 Christos Zoulas <christos@astron.com>\n\n\t* Open with O_BINARY for CYGWIN (Corinna Vinschen)\n\n\t* Don't close stdin (Arkadiusz Miskiewicz)\n\n\t* Look for note sections in non executables.\n\n2005-09-20 13:33 Christos Zoulas <christos@astron.com>\n\n\t* Don't print SVR4 Style in core files multiple times\n\t    (Radek Vokal)\n\n2005-08-27 04:09 Christos Zoulas <christos@astron.com>\n\n\t* Cygwin changes Corinna Vinschen\n\n2005-08-18 09:53 Christos Zoulas <christos@astron.com>\n\n\t* Remove erroreous mention of /etc/magic in the file man page\n\t  This is gentoo bug 101639. (Mike Frysinger)\n\n\t* Cross-compile support and detection (Mike Frysinger)\n\n2005-08-12 10:17 Christos Zoulas <christos@astron.com>\n\n\t* Add -h flag and dereference symlinks if POSIXLY_CORRECT\n\t  is set.\n\n2005-07-29 13:57 Christos Zoulas <christos@astron.com>\n\n\t* Avoid search and regex buffer overflows (Kelledin)\n\n2005-07-12 11:48 Christos Zoulas <christos@astron.com>\n\n\t* Provide stub implementations for {v,}nsprintf() for older\n\t  OS's that don't have them.\n\t* Change mbstate_t autoconf detection macro from AC_MBSTATE_T\n\t  to AC_TYPE_MBSTATE_T.\n\n2005-06-25 11:48 Christos Zoulas <christos@astron.com>\n\n\t* Dynamically allocate the string buffers and make the\n\t  default read size 256K.\n\n2005-06-01 00:00 Joerg Sonnenberger <joerg@britannica.bec.de>\n\n\t* Dragonfly ELF note support\n\n2005-03-14 00:00 Giuliano Bertoletti <gb@symbolic.it>\n\n\t* Avoid NULL pointer dereference in time conversion.\n\n2005-03-06 00:00  Joerg Walter <jwalt@mail.garni.ch>\n\n\t* Add indirect magic offset support, and search mode.\n\n2005-01-12 00:00  Stepan Kasal  <kasal@ucw.cz>\n\n\t* src/ascmagic.c (file_ascmagic): Fix three bugs about text files:\n\t  If a CRLF text file happens to have CR at offset HOWMANY - 1\n\t  (currently 0xffff), it should not be counted as CR line\n\t  terminator.\n\t  If a line has length exactly MAXLINELEN, it should not yet be\n\t  treated as a ``very long line'', as MAXLINELEN is ``longest sane\n\t  line length''.\n\t  With CRLF, the line length was not computed correctly, and even\n\t  lines of length MAXLINELEN - 1 were treated as ``very long''.\n\n2004-12-07 14:15  Christos Zoulas  <christos@astron.com>\n\n\t* bzip2 needs a lot of input buffer space on some files\n\t  before it can begin uncompressing. This makes file -z\n\t  fail on some bz2 files. Fix it by giving it a copy of\n\t  the file descriptor to read as much as it wants if we\n\t  have access to it. <christos@astron.com>\n\n2004-11-24 12:39  Christos Zoulas  <christos@astron.com>\n\n\t* Stack smash fix, and ELF more conservative reading.\n\t  Jakub Bogusz <qboosh@pld-linux.org>\n\n2004-11-20 18:50  Christos Zoulas  <christos@astron.com>\n\n\t* New FreeBSD version parsing code:\n\t  Jon Noack <noackjr@alumni.rice.edu>\n\n\t* Hackish support for ucs16 strings <christos@astron.com>\n\n2004-11-13 03:07  Christos Zoulas  <christos@astron.com>\n\n\t* print the file name and line number in syntax errors.\n\n2004 10-12 10:50  Christos Zoulas  <christos@astron.com>\n\n\t* Fix stack overwriting on 0 length strings: Tim Waugh\n\t    <twaugh@redhat.com> Ned Ludd <solar@gentoo.org>\n\n2004-09-27 11:30  Christos Zoulas  <christos@astron.com>\n\n\t* Remove 3rd and 4th copyright clause; approved by Ian Darwin.\n\n\t* Fix small memory leaks; caught by: Tamas Sarlos\n\t    <stamas@csillag.ilab.sztaki.hu>\n\n2004-07-24 16:33  Christos Zoulas  <christos@astron.com>\n\n\t* magic.mime update Danny Milosavljevic <danny.milo@gmx.net>\n\n\t* FreeBSD version update Oliver Eikemeier <eikemeier@fillmore-labs.com>\n\n\t* utime/utimes detection Ian Lance Taylor <ian@wasabisystems.com>\n\n  \t* errors reading elf magic Jakub Bogusz <qboosh@pld-linux.org>\n\n2004-04-12 10:55  Christos Zoulas  <christos@astron.com>\n\n\t* make sure that magic formats match magic types during compilation\n\n\t* fix broken sgi magic file\n\n2004-04-06 20:36  Christos Zoulas  <christos@astron.com>\n\n\t* detect present of mbstate_t Petter Reinholdtsen <pere@hungry.com>\n\n\t* magic fixes\n\n2004-03-22 15:25  Christos Zoulas  <christos@astron.com>\n\n\t* Lots of mime fixes\n\t  (Joerg Ostertag) <ostertag@rechengilde.de>\n\n\t* FreeBSD ELF version handling\n\t  (Edwin Groothuis) <edwin@mavetju.org>\n\n\t* correct cleanup in all cases; don't just close the file.\n\t  (Christos Zoulas) <christos@astron.com>\n\n\t* add gettext message catalogue support\n\t  (Michael Piefel) <piefel@debian.org>\n\n\t* better printout for unreadable files\n\t  (Michael Piefel) <piefel@debian.org>\n\n\t* compensate for missing MAXPATHLEN\n\t  (Michael Piefel) <piefel@debian.org>\n\n\t* add wide character string length computation\n\t  (Michael Piefel) <piefel@debian.org>\n\n\t* Avoid infinite loops caused by bad elf alignments\n\t  or name and description note sizes. Reported by\n\t  (Mikael Magnusson) <mmikael@comhem.se>\n\n2004-03-09 13:55  Christos Zoulas  <christos@astron.com>\n\n\t* Fix possible memory leak on error and add missing regfree\n\t  (Dmitry V. Levin) <ldv@altlinux.org>\n\n2003-12-23 12:12  Christos Zoulas  <christos@astron.com>\n\n\t* fix -k flag (Maciej W. Rozycki)\n\n2003-11-18 14:10  Christos Zoulas  <christos@astron.com>\n\n\t* Try to give us much info as possible on corrupt elf files.\n\t  (Willy Tarreau) <willy@w.ods.org>\n\t* Updated python bindings (Brett Funderburg)\n\t   <brettf@deepfile.com>\n\n2003-11-11 15:03  Christos Zoulas  <christos@astron.com>\n\n\t* Include file.h first, because it includes config.h\n\t  breaks largefile test macros otherwise.\n\t  (Paul Eggert <eggert@CS.UCLA.EDU> via\n\t   Lars Hecking <lhecking@nmrc.ie>)\n\n2003-10-14 21:39  Christos Zoulas  <christos@astron.com>\n\n\t* Python bindings (Brett Funderburg) <brettf@deepfile.com>\n\t* Don't lookup past the end of the buffer\n\t  (Chad Hanson) <chanson@tcs-sec.com>\n\t* Add MAGIC_ERROR and api on magic_errno()\n\n2003-10-08 12:40  Christos Zoulas  <christos@astron.com>\n\n\t* handle error conditions from compile as fatal\n\t  (Antti Kantee) <pooka@netbsd.org>\n\t* handle magic filename parsing sanely\n\t* more magic fixes.\n\t* fix a memory leak (Illes Marton) <illes.marton@balabit.hu>\n\t* describe magic file handling\n\t  (Bryan Henderson) <bryanh@giraffe-data.com>\n\n2003-09-12 15:09  Christos Zoulas  <christos@astron.com>\n\n\t* update magic files.\n\t* remove largefile support from file.h; it breaks things on most OS's\n\n2003-08-10 10:25  Christos Zoulas  <christos@astron.com>\n\n\t* fix unmapping'ing of mmaped files.\n\n2003-07-10 12:03  Christos Zoulas  <christos@astron.com>\n\n\t* don't exit with -1 on error; always exit 1 (Marty Leisner)\n\t* restore utimes code.\n\n2003-06-10 17:03  Christos Zoulas  <christos@astron.com>\n\n\t* make sure we don't access uninitialized memory.\n\t* pass lint\n\t* #ifdef __cplusplus in magic.h\n\n2003-05-25 19:23  Christos Zoulas  <christos@astron.com>\n\n\t* rename cvs magic file to revision to deal with\n\t  case insensitive filesystems.\n\n2003-05-23 17:03  Christos Zoulas  <christos@astron.com>\n\n\t* documentation fixes from Michael Piefel <piefel@debian.org>\n\t* magic fixes (various)\n\t* revert basename magic in .mgc name determination\n\t* buffer protection in uncompress,\n\t  signness issues,\n\t  close files\n\t  Maciej W. Rozycki <macro@ds2.pg.gda.pl\n\n2003-04-21 20:12  Christos Zoulas  <christos@astron.com>\n\n\t* fix zsh magic\n\n2003-04-04 16:59  Christos Zoulas  <christos@astron.com>\n\n\t* fix operand sort order in string.\n\n2003-04-02 17:30  Christos Zoulas  <christos@astron.com>\n\n\t* cleanup namespace in magic.h\n\n2003-04-02 13:50  Christos Zoulas  <christos@astron.com>\n\n\t* Magic additions (Alex Ott)\n\t* Fix bug that broke VPATH compilation (Peter Breitenlohner)\n\n2003-03-28 16:03  Christos Zoulas  <christos@astron.com>\n\n\t* remove packed attribute from magic struct.\n\t* make the magic struct properly aligned.\n\t* bump version number of compiled files to 2.\n\n2003-03-27 13:10  Christos Zoulas  <christos@astron.com>\n\n\t* separate tar detection and run it before softmagic.\n\t* fix reversed symlink test.\n\t* fix version printing.\n\t* make separator a string instead of a char.\n\t* update manual page and sort options.\n\n2003-03-26 11:00  Christos Zoulas  <christos@astron.com>\n\n\t* Pass lint\n\t* make NULL in magic_file mean stdin\n\t* Fix \"-\" argument to file to pass NULL to magic_file\n\t* avoid pointer casts by using memcpy\n\t* rename magic_buf -> magic_buffer\n\t* keep only the first error\n\t* manual page: new sentence, new line\n\t* fix typo in api function (magic_buf -> magic_buffer)\n", ".\\\" $File: magic.man,v 1.83 2014/06/03 17:36:13 christos Exp $\n.Dd June 3, 2014\n.Dt MAGIC __FSECTION__\n.Os\n.\\\" install as magic.4 on USG, magic.5 on V7, Berkeley and Linux systems.\n.Sh NAME\n.Nm magic\n.Nd file command's magic pattern file\n.Sh DESCRIPTION\nThis manual page documents the format of the magic file as\nused by the\n.Xr file __CSECTION__\ncommand, version __VERSION__.\nThe\n.Xr file __CSECTION__\ncommand identifies the type of a file using,\namong other tests,\na test for whether the file contains certain\n.Dq \"magic patterns\" .\nThe file\n.Pa __MAGIC__\nspecifies what patterns are to be tested for, what message or\nMIME type to print if a particular pattern is found,\nand additional information to extract from the file.\n.Pp\nEach line of the file specifies a test to be performed.\nA test compares the data starting at a particular offset\nin the file with a byte value, a string or a numeric value.\nIf the test succeeds, a message is printed.\nThe line consists of the following fields:\n.Bl -tag -width \".Dv message\"\n.It Dv offset\nA number specifying the offset, in bytes, into the file of the data\nwhich is to be tested.\n.It Dv type\nThe type of the data to be tested.\nThe possible values are:\n.Bl -tag -width \".Dv lestring16\"\n.It Dv byte\nA one-byte value.\n.It Dv short\nA two-byte value in this machine's native byte order.\n.It Dv long\nA four-byte value in this machine's native byte order.\n.It Dv quad\nAn eight-byte value in this machine's native byte order.\n.It Dv float\nA 32-bit single precision IEEE floating point number in this machine's native byte order.\n.It Dv double\nA 64-bit double precision IEEE floating point number in this machine's native byte order.\n.It Dv string\nA string of bytes.\nThe string type specification can be optionally followed\nby /[WwcCtbT]*.\nThe\n.Dq W\nflag compacts whitespace in the target, which must\ncontain at least one whitespace character.\nIf the magic has\n.Dv n\nconsecutive blanks, the target needs at least\n.Dv n\nconsecutive blanks to match.\nThe\n.Dq w\nflag treats every blank in the magic as an optional blank.\nThe\n.Dq c\nflag specifies case insensitive matching: lower case\ncharacters in the magic match both lower and upper case characters in the\ntarget, whereas upper case characters in the magic only match upper case\ncharacters in the target.\nThe\n.Dq C\nflag specifies case insensitive matching: upper case\ncharacters in the magic match both lower and upper case characters in the\ntarget, whereas lower case characters in the magic only match upper case\ncharacters in the target.\nTo do a complete case insensitive match, specify both\n.Dq c\nand\n.Dq C .\nThe\n.Dq t\nflag forces the test to be done for text files, while the\n.Dq b\nflag forces the test to be done for binary files.\nThe\n.Dq T\nflag causes the string to be trimmed, i.e. leading and trailing whitespace\nis deleted before the string is printed.\n.It Dv pstring\nA Pascal-style string where the first byte/short/int is interpreted as the\nunsigned length.\nThe length defaults to byte and can be specified as a modifier.\nThe following modifiers are supported:\n.Bl -tag -compact -width B\n.It B\nA byte length (default).\n.It H\nA 2 byte big endian length.\n.It h\nA 2 byte big little length.\n.It L\nA 4 byte big endian length.\n.It l\nA 4 byte big little length.\n.It J\nThe length includes itself in its count.\n.El\nThe string is not NUL terminated.\n.Dq J\nis used rather than the more\nvaluable\n.Dq I\nbecause this type of length is a feature of the JPEG\nformat.\n.It Dv date\nA four-byte value interpreted as a UNIX date.\n.It Dv qdate\nA eight-byte value interpreted as a UNIX date.\n.It Dv ldate\nA four-byte value interpreted as a UNIX-style date, but interpreted as\nlocal time rather than UTC.\n.It Dv qldate\nAn eight-byte value interpreted as a UNIX-style date, but interpreted as\nlocal time rather than UTC.\n.It Dv qwdate\nAn eight-byte value interpreted as a Windows-style date.\n.It Dv beid3\nA 32-bit ID3 length in big-endian byte order.\n.It Dv beshort\nA two-byte value in big-endian byte order.\n.It Dv belong\nA four-byte value in big-endian byte order.\n.It Dv bequad\nAn eight-byte value in big-endian byte order.\n.It Dv befloat\nA 32-bit single precision IEEE floating point number in big-endian byte order.\n.It Dv bedouble\nA 64-bit double precision IEEE floating point number in big-endian byte order.\n.It Dv bedate\nA four-byte value in big-endian byte order,\ninterpreted as a Unix date.\n.It Dv beqdate\nAn eight-byte value in big-endian byte order,\ninterpreted as a Unix date.\n.It Dv beldate\nA four-byte value in big-endian byte order,\ninterpreted as a UNIX-style date, but interpreted as local time rather\nthan UTC.\n.It Dv beqldate\nAn eight-byte value in big-endian byte order,\ninterpreted as a UNIX-style date, but interpreted as local time rather\nthan UTC.\n.It Dv beqwdate\nAn eight-byte value in big-endian byte order,\ninterpreted as a Windows-style date.\n.It Dv bestring16\nA two-byte unicode (UCS16) string in big-endian byte order.\n.It Dv leid3\nA 32-bit ID3 length in little-endian byte order.\n.It Dv leshort\nA two-byte value in little-endian byte order.\n.It Dv lelong\nA four-byte value in little-endian byte order.\n.It Dv lequad\nAn eight-byte value in little-endian byte order.\n.It Dv lefloat\nA 32-bit single precision IEEE floating point number in little-endian byte order.\n.It Dv ledouble\nA 64-bit double precision IEEE floating point number in little-endian byte order.\n.It Dv ledate\nA four-byte value in little-endian byte order,\ninterpreted as a UNIX date.\n.It Dv leqdate\nAn eight-byte value in little-endian byte order,\ninterpreted as a UNIX date.\n.It Dv leldate\nA four-byte value in little-endian byte order,\ninterpreted as a UNIX-style date, but interpreted as local time rather\nthan UTC.\n.It Dv leqldate\nAn eight-byte value in little-endian byte order,\ninterpreted as a UNIX-style date, but interpreted as local time rather\nthan UTC.\n.It Dv leqwdate\nAn eight-byte value in little-endian byte order,\ninterpreted as a Windows-style date.\n.It Dv lestring16\nA two-byte unicode (UCS16) string in little-endian byte order.\n.It Dv melong\nA four-byte value in middle-endian (PDP-11) byte order.\n.It Dv medate\nA four-byte value in middle-endian (PDP-11) byte order,\ninterpreted as a UNIX date.\n.It Dv meldate\nA four-byte value in middle-endian (PDP-11) byte order,\ninterpreted as a UNIX-style date, but interpreted as local time rather\nthan UTC.\n.It Dv indirect\nStarting at the given offset, consult the magic database again.\n.It Dv name\nDefine a\n.Dq named\nmagic instance that can be called from another\n.Dv use\nmagic entry, like a subroutine call.\nNamed instance direct magic offsets are relative to the offset of the\nprevious matched entry, but indirect offsets are relative to the beginning\nof the file as usual.\nNamed magic entries always match.\n.It Dv use\nRecursively call the named magic starting from the current offset.\nIf the name of the referenced begins with a\n.Dv ^\nthen the endianness of the magic is switched; if the magic mentioned\n.Dv leshort\nfor example,\nit is treated as\n.Dv beshort\nand vice versa.\nThis is useful to avoid duplicating the rules for different endianness.\n.It Dv regex\nA regular expression match in extended POSIX regular expression syntax\n(like egrep).\nRegular expressions can take exponential time to process, and their\nperformance is hard to predict, so their use is discouraged.\nWhen used in production environments, their performance\nshould be carefully checked.\nThe size of the string to search should also be limited by specifying\n.Dv /<length> ,\nto avoid performance issues scanning long files.\nThe type specification can also be optionally followed by\n.Dv /[c][s][l] .\nThe\n.Dq c\nflag makes the match case insensitive, while the\n.Dq s\nflag update the offset to the start offset of the match, rather than the end.\nThe\n.Dq l\nmodifier, changes the limit of length to mean number of lines instead of a\nbyte count.\nLines are delimited by the platforms native line delimiter.\nWhen a line count is specified, an implicit byte count also computed assuming\neach line is 80 characters long.\nIf neither a byte or line count is specified, the search is limited automatically\nto 8KiB.\n.Dv ^\nand\n.Dv $\nmatch the beginning and end of individual lines, respectively,\nnot beginning and end of file.\n.It Dv search\nA literal string search starting at the given offset.\nThe same modifier flags can be used as for string patterns.\nThe search expression must contain the range in the form\n.Dv /number,\nthat is the number of positions at which the match will be\nattempted, starting from the start offset.\nThis is suitable for\nsearching larger binary expressions with variable offsets, using\n.Dv \\e\nescapes for special characters.\nThe order of modifier and number is not relevant.\n.It Dv default\nThis is intended to be used with the test\n.Em x\n(which is always true) and it has no type.\nIt matches when no other test at that continuation level has matched before.\nClearing that matched tests for a continuation level, can be done using the\n.Dv clear\ntest.\n.It Dv clear\nThis test is always true and clears the match flag for that continuation level.\nIt is intended to be used with the\n.Dv default\ntest.\n.El\n.Pp\nFor compatibility with the Single\n.Ux\nStandard, the type specifiers\n.Dv dC\nand\n.Dv d1\nare equivalent to\n.Dv byte ,\nthe type specifiers\n.Dv uC\nand\n.Dv u1\nare equivalent to\n.Dv ubyte ,\nthe type specifiers\n.Dv dS\nand\n.Dv d2\nare equivalent to\n.Dv short ,\nthe type specifiers\n.Dv uS\nand\n.Dv u2\nare equivalent to\n.Dv ushort ,\nthe type specifiers\n.Dv dI ,\n.Dv dL ,\nand\n.Dv d4\nare equivalent to\n.Dv long ,\nthe type specifiers\n.Dv uI ,\n.Dv uL ,\nand\n.Dv u4\nare equivalent to\n.Dv ulong ,\nthe type specifier\n.Dv d8\nis equivalent to\n.Dv quad ,\nthe type specifier\n.Dv u8\nis equivalent to\n.Dv uquad ,\nand the type specifier\n.Dv s\nis equivalent to\n.Dv string .\nIn addition, the type specifier\n.Dv dQ\nis equivalent to\n.Dv quad\nand the type specifier\n.Dv uQ\nis equivalent to\n.Dv uquad .\n.Pp\nEach top-level magic pattern (see below for an explanation of levels)\nis classified as text or binary according to the types used.\nTypes\n.Dq regex\nand\n.Dq search\nare classified as text tests, unless non-printable characters are used\nin the pattern.\nAll other tests are classified as binary.\nA top-level\npattern is considered to be a test text when all its patterns are text\npatterns; otherwise, it is considered to be a binary pattern.\nWhen\nmatching a file, binary patterns are tried first; if no match is\nfound, and the file looks like text, then its encoding is determined\nand the text patterns are tried.\n.Pp\nThe numeric types may optionally be followed by\n.Dv \\*[Am]\nand a numeric value,\nto specify that the value is to be AND'ed with the\nnumeric value before any comparisons are done.\nPrepending a\n.Dv u\nto the type indicates that ordered comparisons should be unsigned.\n.It Dv test\nThe value to be compared with the value from the file.\nIf the type is\nnumeric, this value\nis specified in C form; if it is a string, it is specified as a C string\nwith the usual escapes permitted (e.g. \\en for new-line).\n.Pp\nNumeric values\nmay be preceded by a character indicating the operation to be performed.\nIt may be\n.Dv = ,\nto specify that the value from the file must equal the specified value,\n.Dv \\*[Lt] ,\nto specify that the value from the file must be less than the specified\nvalue,\n.Dv \\*[Gt] ,\nto specify that the value from the file must be greater than the specified\nvalue,\n.Dv \\*[Am] ,\nto specify that the value from the file must have set all of the bits\nthat are set in the specified value,\n.Dv ^ ,\nto specify that the value from the file must have clear any of the bits\nthat are set in the specified value, or\n.Dv ~ ,\nthe value specified after is negated before tested.\n.Dv x ,\nto specify that any value will match.\nIf the character is omitted, it is assumed to be\n.Dv = .\nOperators\n.Dv \\*[Am] ,\n.Dv ^ ,\nand\n.Dv ~\ndon't work with floats and doubles.\nThe operator\n.Dv !\\&\nspecifies that the line matches if the test does\n.Em not\nsucceed.\n.Pp\nNumeric values are specified in C form; e.g.\n.Dv 13\nis decimal,\n.Dv 013\nis octal, and\n.Dv 0x13\nis hexadecimal.\n.Pp\nNumeric operations are not performed on date types, instead the numeric\nvalue is interpreted as an offset.\n.Pp\nFor string values, the string from the\nfile must match the specified string.\nThe operators\n.Dv = ,\n.Dv \\*[Lt]\nand\n.Dv \\*[Gt]\n(but not\n.Dv \\*[Am] )\ncan be applied to strings.\nThe length used for matching is that of the string argument\nin the magic file.\nThis means that a line can match any non-empty string (usually used to\nthen print the string), with\n.Em \\*[Gt]\\e0\n(because all non-empty strings are greater than the empty string).\n.Pp\nDates are treated as numerical values in the respective internal\nrepresentation.\n.Pp\nThe special test\n.Em x\nalways evaluates to true.\n.It Dv message\nThe message to be printed if the comparison succeeds.\nIf the string contains a\n.Xr printf 3\nformat specification, the value from the file (with any specified masking\nperformed) is printed using the message as the format string.\nIf the string begins with\n.Dq \\eb ,\nthe message printed is the remainder of the string with no whitespace\nadded before it: multiple matches are normally separated by a single\nspace.\n.El\n.Pp\nAn APPLE 4+4 character APPLE creator and type can be specified as:\n.Bd -literal -offset indent\n!:apple\tCREATYPE\n.Ed\n.Pp\nA MIME type is given on a separate line, which must be the next\nnon-blank or comment line after the magic line that identifies the\nfile type, and has the following format:\n.Bd -literal -offset indent\n!:mime\tMIMETYPE\n.Ed\n.Pp\ni.e. the literal string\n.Dq !:mime\nfollowed by the MIME type.\n.Pp\nAn optional strength can be supplied on a separate line which refers to\nthe current magic description using the following format:\n.Bd -literal -offset indent\n!:strength OP VALUE\n.Ed\n.Pp\nThe operand\n.Dv OP\ncan be:\n.Dv + ,\n.Dv - ,\n.Dv * ,\nor\n.Dv /\nand\n.Dv VALUE\nis a constant between 0 and 255.\nThis constant is applied using the specified operand\nto the currently computed default magic strength.\n.Pp\nSome file formats contain additional information which is to be printed\nalong with the file type or need additional tests to determine the true\nfile type.\nThese additional tests are introduced by one or more\n.Em \\*[Gt]\ncharacters preceding the offset.\nThe number of\n.Em \\*[Gt]\non the line indicates the level of the test; a line with no\n.Em \\*[Gt]\nat the beginning is considered to be at level 0.\nTests are arranged in a tree-like hierarchy:\nif the test on a line at level\n.Em n\nsucceeds, all following tests at level\n.Em n+1\nare performed, and the messages printed if the tests succeed, until a line\nwith level\n.Em n\n(or less) appears.\nFor more complex files, one can use empty messages to get just the\n\"if/then\" effect, in the following way:\n.Bd -literal -offset indent\n0      string   MZ\n\\*[Gt]0x18  leshort  \\*[Lt]0x40   MS-DOS executable\n\\*[Gt]0x18  leshort  \\*[Gt]0x3f   extended PC executable (e.g., MS Windows)\n.Ed\n.Pp\nOffsets do not need to be constant, but can also be read from the file\nbeing examined.\nIf the first character following the last\n.Em \\*[Gt]\nis a\n.Em \\&(\nthen the string after the parenthesis is interpreted as an indirect offset.\nThat means that the number after the parenthesis is used as an offset in\nthe file.\nThe value at that offset is read, and is used again as an offset\nin the file.\nIndirect offsets are of the form:\n.Em (( x [.[bislBISL]][+\\-][ y ]) .\nThe value of\n.Em x\nis used as an offset in the file.\nA byte, id3 length, short or long is read at that offset depending on the\n.Em [bislBISLm]\ntype specifier.\nThe capitalized types interpret the number as a big endian\nvalue, whereas the small letter versions interpret the number as a little\nendian value;\nthe\n.Em m\ntype interprets the number as a middle endian (PDP-11) value.\nTo that number the value of\n.Em y\nis added and the result is used as an offset in the file.\nThe default type if one is not specified is long.\n.Pp\nThat way variable length structures can be examined:\n.Bd -literal -offset indent\n# MS Windows executables are also valid MS-DOS executables\n0           string  MZ\n\\*[Gt]0x18       leshort \\*[Lt]0x40   MZ executable (MS-DOS)\n# skip the whole block below if it is not an extended executable\n\\*[Gt]0x18       leshort \\*[Gt]0x3f\n\\*[Gt]\\*[Gt](0x3c.l)  string  PE\\e0\\e0  PE executable (MS-Windows)\n\\*[Gt]\\*[Gt](0x3c.l)  string  LX\\e0\\e0  LX executable (OS/2)\n.Ed\n.Pp\nThis strategy of examining has a drawback: You must make sure that\nyou eventually print something, or users may get empty output (like, when\nthere is neither PE\\e0\\e0 nor LE\\e0\\e0 in the above example)\n.Pp\nIf this indirect offset cannot be used directly, simple calculations are\npossible: appending\n.Em [+-*/%\\*[Am]|^]number\ninside parentheses allows one to modify\nthe value read from the file before it is used as an offset:\n.Bd -literal -offset indent\n# MS Windows executables are also valid MS-DOS executables\n0           string  MZ\n# sometimes, the value at 0x18 is less that 0x40 but there's still an\n# extended executable, simply appended to the file\n\\*[Gt]0x18       leshort \\*[Lt]0x40\n\\*[Gt]\\*[Gt](4.s*512) leshort 0x014c  COFF executable (MS-DOS, DJGPP)\n\\*[Gt]\\*[Gt](4.s*512) leshort !0x014c MZ executable (MS-DOS)\n.Ed\n.Pp\nSometimes you do not know the exact offset as this depends on the length or\nposition (when indirection was used before) of preceding fields.\nYou can specify an offset relative to the end of the last up-level\nfield using\n.Sq \\*[Am]\nas a prefix to the offset:\n.Bd -literal -offset indent\n0           string  MZ\n\\*[Gt]0x18       leshort \\*[Gt]0x3f\n\\*[Gt]\\*[Gt](0x3c.l)  string  PE\\e0\\e0    PE executable (MS-Windows)\n# immediately following the PE signature is the CPU type\n\\*[Gt]\\*[Gt]\\*[Gt]\\*[Am]0       leshort 0x14c     for Intel 80386\n\\*[Gt]\\*[Gt]\\*[Gt]\\*[Am]0       leshort 0x184     for DEC Alpha\n.Ed\n.Pp\nIndirect and relative offsets can be combined:\n.Bd -literal -offset indent\n0             string  MZ\n\\*[Gt]0x18         leshort \\*[Lt]0x40\n\\*[Gt]\\*[Gt](4.s*512)   leshort !0x014c MZ executable (MS-DOS)\n# if it's not COFF, go back 512 bytes and add the offset taken\n# from byte 2/3, which is yet another way of finding the start\n# of the extended executable\n\\*[Gt]\\*[Gt]\\*[Gt]\\*[Am](2.s-514) string  LE      LE executable (MS Windows VxD driver)\n.Ed\n.Pp\nOr the other way around:\n.Bd -literal -offset indent\n0                 string  MZ\n\\*[Gt]0x18             leshort \\*[Gt]0x3f\n\\*[Gt]\\*[Gt](0x3c.l)        string  LE\\e0\\e0  LE executable (MS-Windows)\n# at offset 0x80 (-4, since relative offsets start at the end\n# of the up-level match) inside the LE header, we find the absolute\n# offset to the code area, where we look for a specific signature\n\\*[Gt]\\*[Gt]\\*[Gt](\\*[Am]0x7c.l+0x26) string  UPX     \\eb, UPX compressed\n.Ed\n.Pp\nOr even both!\n.Bd -literal -offset indent\n0                string  MZ\n\\*[Gt]0x18            leshort \\*[Gt]0x3f\n\\*[Gt]\\*[Gt](0x3c.l)       string  LE\\e0\\e0 LE executable (MS-Windows)\n# at offset 0x58 inside the LE header, we find the relative offset\n# to a data area where we look for a specific signature\n\\*[Gt]\\*[Gt]\\*[Gt]\\*[Am](\\*[Am]0x54.l-3)  string  UNACE  \\eb, ACE self-extracting archive\n.Ed\n.Pp\nIf you have to deal with offset/length pairs in your file, even the\nsecond value in a parenthesized expression can be taken from the file itself,\nusing another set of parentheses.\nNote that this additional indirect offset is always relative to the\nstart of the main indirect offset.\n.Bd -literal -offset indent\n0                 string       MZ\n\\*[Gt]0x18             leshort      \\*[Gt]0x3f\n\\*[Gt]\\*[Gt](0x3c.l)        string       PE\\e0\\e0 PE executable (MS-Windows)\n# search for the PE section called \".idata\"...\n\\*[Gt]\\*[Gt]\\*[Gt]\\*[Am]0xf4          search/0x140 .idata\n# ...and go to the end of it, calculated from start+length;\n# these are located 14 and 10 bytes after the section name\n\\*[Gt]\\*[Gt]\\*[Gt]\\*[Gt](\\*[Am]0xe.l+(-4)) string       PK\\e3\\e4 \\eb, ZIP self-extracting archive\n.Ed\n.Pp\nIf you have a list of known avalues at a particular continuation level,\nand you want to provide a switch-like default case:\n.Bd -literal -offset indent\n# clear that continuation level match\n\\*[Gt]18\tclear\n\\*[Gt]18\tlelong\t1\tone\n\\*[Gt]18\tlelong\t2\ttwo\n\\*[Gt]18\tdefault\tx\n# print default match\n\\*[Gt]\\*[Gt]18\tlelong\tx\tunmatched 0x%x\n.Ed\n.Sh SEE ALSO\n.Xr file __CSECTION__\n\\- the command that reads this file.\n.Sh BUGS\nThe formats\n.Dv long ,\n.Dv belong ,\n.Dv lelong ,\n.Dv melong ,\n.Dv short ,\n.Dv beshort ,\nand\n.Dv leshort\ndo not depend on the length of the C data types\n.Dv short\nand\n.Dv long\non the platform, even though the Single\n.Ux\nSpecification implies that they do.  However, as OS X Mountain Lion has\npassed the Single\n.Ux\nSpecification validation suite, and supplies a version of\n.Xr file __CSECTION__\nin which they do not depend on the sizes of the C data types and that is\nbuilt for a 64-bit environment in which\n.Dv long\nis 8 bytes rather than 4 bytes, presumably the validation suite does not\ntest whether, for example\n.Dv long\nrefers to an item with the same size as the C data type\n.Dv long .\nThere should probably be\n.Dv type\nnames\n.Dv int8 ,\n.Dv uint8 ,\n.Dv int16 ,\n.Dv uint16 ,\n.Dv int32 ,\n.Dv uint32 ,\n.Dv int64 ,\nand\n.Dv uint64 ,\nand specified-byte-order variants of them,\nto make it clearer that those types have specified widths.\n.\\\"\n.\\\" From: guy@sun.uucp (Guy Harris)\n.\\\" Newsgroups: net.bugs.usg\n.\\\" Subject: /etc/magic's format isn't well documented\n.\\\" Message-ID: <2752@sun.uucp>\n.\\\" Date: 3 Sep 85 08:19:07 GMT\n.\\\" Organization: Sun Microsystems, Inc.\n.\\\" Lines: 136\n.\\\"\n.\\\" Here's a manual page for the format accepted by the \"file\" made by adding\n.\\\" the changes I posted to the S5R2 version.\n.\\\"\n.\\\" Modified for Ian Darwin's version of the file command.\n", "\n#------------------------------------------------------------\n# $File: android,v 1.3 2013/11/08 01:24:22 christos Exp $\n# Various android related magic entries\n#------------------------------------------------------------\n\n# Dalvik .dex format. http://retrodev.com/android/dexformat.html\n# From <mkf@google.com> \"Mike Fleming\"\n# Fixed to avoid regexec 17 errors on some dex files\n# From <diff@lookout.com> \"Tim Strazzere\"\n0\tstring\tdex\\n\n>0\tregex\tdex\\n[0-9]{2}\\0\tDalvik dex file\n>4\tstring\t>000\t\t\tversion %s\n0\tstring\tdey\\n\n>0\tregex\tdey\\n[0-9]{2}\\0\tDalvik dex file (optimized for host)\n>4\tstring\t>000\t\t\tversion %s\n\n# http://android.stackexchange.com/questions/23357/\\\n# is-there-a-way-to-look-inside-and-modify-an-adb-backup-created-file/\\\n# 23608#23608\n0\tstring\tANDROID\\040BACKUP\\n\tAndroid Backup\n>15\tstring\t1\\n\t\t\t\\b, version 1\n>17\tstring\t0\\n\t\t\t\\b, uncompressed\n>17\tstring\t1\\n\t\t\t\\b, compressed\n>19\tstring\tnone\\n\t\t\t\\b, unencrypted\n>19\tstring\tAES-256\\n\t\t\\b, encrypted AES-256\n\n# Android bootimg format\n# From https://android.googlesource.com/\\\n# platform/system/core/+/master/mkbootimg/bootimg.h\n0\t\tstring\tANDROID!\tAndroid bootimg\n>8\t\tlelong\t>0\t\t\t\\b, kernel\n>>12\tlelong\t>0\t\t\t\\b (0x%x)\n>16\t\tlelong\t>0\t\t\t\\b, ramdisk\n>>20\tlelong\t>0\t\t\t\\b (0x%x)\n>24\t\tlelong\t>0\t\t\t\\b, second stage\n>>28\tlelong\t>0\t\t\t\\b (0x%x)\n>36\t\tlelong\t>0\t\t\t\\b, page size: %d\n>38\t\tstring\t>0\t\t\t\\b, name: %s\n>64\t\tstring\t>0\t\t \t\\b, cmdline (%s)\n# Dalvik .dex format. http://retrodev.com/android/dexformat.html\n# From <mkf@google.com> \"Mike Fleming\"\n# Fixed to avoid regexec 17 errors on some dex files\n# From <diff@lookout.com> \"Tim Strazzere\"\n0\tstring\tdex\\n\n>0\tregex\tdex\\n[0-9]{2}\\0\tDalvik dex file\n>4\tstring\t>000\t\t\tversion %s\n0\tstring\tdey\\n\n>0\tregex\tdey\\n[0-9]{2}\\0\tDalvik dex file (optimized for host)\n>4\tstring\t>000\t\t\tversion %s\n\n# http://android.stackexchange.com/questions/23357/\\\n# is-there-a-way-to-look-inside-and-modify-an-adb-backup-created-file/\\\n# 23608#23608\n0\tstring\tANDROID\\040BACKUP\\n\tAndroid Backup\n>15\tstring\t1\\n\t\t\t\\b, version 1\n>17\tstring\t0\\n\t\t\t\\b, uncompressed\n>17\tstring\t1\\n\t\t\t\\b, compressed\n>19\tstring\tnone\\n\t\t\t\\b, unencrypted\n>19\tstring\tAES-256\\n\t\t\\b, encrypted AES-256\n\n# Android bootimg format\n# From https://android.googlesource.com/\\\n# platform/system/core/+/master/mkbootimg/bootimg.h\n0\t\tstring\tANDROID!\tAndroid bootimg\n>8\t\tlelong\t>0\t\t\t\\b, kernel\n>>12\tlelong\t>0\t\t\t\\b (0x%x)\n>16\t\tlelong\t>0\t\t\t\\b, ramdisk\n>>20\tlelong\t>0\t\t\t\\b (0x%x)\n>24\t\tlelong\t>0\t\t\t\\b, second stage\n>>28\tlelong\t>0\t\t\t\\b (0x%x)\n>36\t\tlelong\t>0\t\t\t\\b, page size: %d\n>38\t\tstring\t>0\t\t\t\\b, name: %s\n>64\t\tstring\t>0\t\t \t\\b, cmdline (%s)\n\n# Android Backup archive\n# From: Ariel Shkedi\n# File extension: .ab\n# No mime-type defined\n# URL: https://github.com/android/platform_frameworks_base/blob/\\\n# 0bacfd2ba68d21a68a3df345b830bc2a1e515b5a/services/java/com/\\\n# android/server/BackupManagerService.java#L2367\n# After the header comes a tar file\n# If compressed, the entire tar file is compressed with JAVA deflate\n#\n# Include the version number hardcoded with the magic string to avoid\n# false positives\n0\tstring/b\tANDROID\\ BACKUP\\n1\\n\tAndroid Backup\n>17\tstring\t\t0\\n\t\t\t\\b, Not-Compressed\n>17\tstring\t\t1\\n\t\t\t\\b, Compressed\n# any string as long as it's not the word none (which is matched below)\n>>19    regex/1l\t\\^([^n\\n]|n[^o]|no[^n]|non[^e]|none.+).*\t\\b, Encrypted (%s)\n>>19\tstring\t\tnone\\n\t\t\t\\b, Not-Encrypted\n# Commented out because they don't seem useful to print\n# (but they are part of the header - the tar file comes after them):\n#>>>&1\t\tregex/1l .*\t\\b, Password salt: %s\n#>>>>&1\t\tregex/1l .*\t\\b, Master salt: %s\n#>>>>>&1\tregex/1l .*\t\\b, PBKDF2 rounds: %s\n#>>>>>>&1\tregex/1l .*\t\\b, IV: %s\n#>>>>>>>&1\tregex/1l .*\t\\b, Key: %s\n", "\n#------------------------------------------------------------------------------\n# $File: fortran,v 1.7 2012/06/21 01:55:02 christos Exp $\n# FORTRAN source\n0\tregex/100l\t\\^[Cc][\\ \\t]\tFORTRAN program\n!:mime\ttext/x-fortran\n!:strength - 5\n", "\n#------------------------------------------------------------------------------\n# $File: graphviz,v 1.7 2009/09/19 16:28:09 christos Exp $\n# graphviz:  file(1) magic for http://www.graphviz.org/\n\n# FIXME: These patterns match too generally. For example, the first\n# line matches a LaTeX file containing the word \"graph\" (with a {\n# following later) and the second line matches this file.\n#0\tregex/100l\t[\\r\\n\\t\\ ]*graph[\\r\\n\\t\\ ]+.*\\\\{\tgraphviz graph text\n#!:mime\ttext/vnd.graphviz\n#0\tregex/100l\t[\\r\\n\\t\\ ]*digraph[\\r\\n\\t\\ ]+.*\\\\{\tgraphviz digraph text\n#!:mime\ttext/vnd.graphviz\n", "#--------------------------------------------\n# marc21: file(1) magic for MARC 21 Format\n#\n# Kevin Ford (kefo@loc.gov)\n# \n# MARC21 formats are for the representation and communication\n# of bibliographic and related information in machine-readable\n# form.  For more info, see http://www.loc.gov/marc/\n\n\n# leader position 20-21 must be 45\n20\tstring\t45\t\n\n# leader starts with 5 digits, followed by codes specific to MARC format\n>0\tregex/1l\t(^[0-9]{5})[acdnp][^bhlnqsu-z]\tMARC21 Bibliographic\n!:mime\tapplication/marc\n>0\tregex/1l\t(^[0-9]{5})[acdnosx][z]\tMARC21 Authority\n!:mime\tapplication/marc\n>0\tregex/1l\t(^[0-9]{5})[cdn][uvxy]\tMARC21 Holdings\n!:mime\tapplication/marc\n0\tregex/1l\t(^[0-9]{5})[acdn][w]\tMARC21 Classification\n!:mime\tapplication/marc\n>0\tregex/1l\t(^[0-9]{5})[cdn][q]\tMARC21 Community\n!:mime\tapplication/marc\n\n# leader position 22-23, should be \"00\" but is it?\n>0\tregex/1l\t(^.{21})([^0]{2})\t(non-conforming)\n!:mime\tapplication/marc\n", "\n#------------------------------------------------------------------------------\n# $File: scientific,v 1.8 2014/01/06 17:46:23 rrt Exp $\n# scientific:  file(1) magic for scientific formats \n#\n# From: Joe Krahn <krahn@niehs.nih.gov>\n\n########################################################\n# CCP4 data and plot files:\n0\tstring\t\tMTZ\\040\t\tMTZ reflection file\n\n92\tstring\t\tPLOT%%84\tPlot84 plotting file\n>52\tbyte\t\t1\t\t, Little-endian\n>55\tbyte\t\t1\t\t, Big-endian\n\n########################################################\n# Electron density MAP/MASK formats\n\n0\tstring\t\tEZD_MAP\tNEWEZD Electron Density Map\n109\tstring\t\tMAP\\040(  Old EZD Electron Density Map\n\n0\tstring/c\t:-)\\040Origin\tBRIX Electron Density Map\n>170\tstring\t\t>0\t, Sigma:%.12s\n#>4\tstring\t\t>0\t%.178s\n#>4\taddr\t\tx\t%.178s\n\n7\tstring\t\t18\\040!NTITLE\tXPLOR ASCII Electron Density Map\n9\tstring\t\t\\040!NTITLE\\012\\040REMARK\tCNS ASCII electron density map\n\n208\tstring\t\tMAP\\040\tCCP4 Electron Density Map\n# Assumes same stamp for float and double (normal case)\n>212\tbyte\t\t17\t\\b, Big-endian\n>212\tbyte\t\t34\t\\b, VAX format\n>212\tbyte\t\t68\t\\b, Little-endian\n>212\tbyte\t\t85\t\\b, Convex native\n\n############################################################\n# X-Ray Area Detector images\n0\tstring\tR-AXIS4\\ \\ \\ \tR-Axis Area Detector Image:\n>796\tlelong\t<20\t\tLittle-endian, IP #%d,\n>>768\tlelong\t>0\t\tSize=%dx\n>>772\tlelong\t>0\t\t\\b%d\n>796\tbelong\t<20\t\tBig-endian, IP #%d,\n>>768\tbelong\t>0\t\tSize=%dx\n>>772\tbelong\t>0\t\t\\b%d\n\n0\tstring\tRAXIS\\ \\ \\ \\ \\ \tR-Axis Area Detector Image, Win32:\n>796\tlelong\t<20\t\tLittle-endian, IP #%d,\n>>768\tlelong\t>0\t\tSize=%dx\n>>772\tlelong\t>0\t\t\\b%d\n>796\tbelong\t<20\t\tBig-endian, IP #%d,\n>>768\tbelong\t>0\t\tSize=%dx\n>>772\tbelong\t>0\t\t\\b%d\n\n\n1028\tstring\tMMX\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\tMAR Area Detector Image,\n>1072\tulong\t>1\t\tCompressed(%d),\n>1100\tulong\t>1\t\t%d headers,\n>1104\tulong\t>0\t\t%d x\n>1108\tulong\t>0\t\t%d,\n>1120\tulong\t>0\t\t%d bits/pixel\n\n# Type: GEDCOM genealogical (family history) data\n# From: Giuseppe Bilotta\n0       search/1/c\t0\\ HEAD         GEDCOM genealogy text\n>&0     search\t\t1\\ GEDC\n>>&0    search\t\t2\\ VERS         version\n>>>&1   string\t\t>\\0\t\t%s\n# From: Phil Endecott <phil05@chezphil.org>\n0\tstring\t\\000\\060\\000\\040\\000\\110\\000\\105\\000\\101\\000\\104\t\tGEDCOM data\n0\tstring\t\\060\\000\\040\\000\\110\\000\\105\\000\\101\\000\\104\\000\t\tGEDCOM data\n0\tstring\t\\376\\377\\000\\060\\000\\040\\000\\110\\000\\105\\000\\101\\000\\104\tGEDCOM data\n0\tstring\t\\377\\376\\060\\000\\040\\000\\110\\000\\105\\000\\101\\000\\104\\000\tGEDCOM data\n\n# PDB: Protein Data Bank files\n# Adam Buchbinder <adam.buchbinder@gmail.com>\n#\n# http://www.wwpdb.org/documentation/format32/sect2.html\n# http://www.ch.ic.ac.uk/chemime/\n#\n# The PDB file format is fixed-field, 80 columns. From the spec:\n#\n# COLS        DATA\n#  1 -  6      \"HEADER\"\n#  11 - 50     String(40)\n#  51 - 59     Date\n#  63 - 66     IDcode\n#\n# Thus, positions 7-10, 60-62 and 67-80 are spaces. The Date must be in the\n# format DD-MMM-YY, e.g., 01-JAN-70, and the IDcode consists of numbers and\n# uppercase letters. However, examples have been seen without the date string,\n# e.g., the example on the chemime site.\n0\tstring\tHEADER\\ \\ \\ \\ \n>&0\tregex/1l\t\\^.{40}\n>>&0\tregex/1l\t[0-9]{2}-[A-Z]{3}-[0-9]{2}\\ {3}\n>>>&0\tregex/1ls\t[A-Z0-9]{4}.{14}$\n>>>>&0\tregex/1l\t[A-Z0-9]{4}\tProtein Data Bank data, ID Code %s\n!:mime\tchemical/x-pdb\n>>>>0\tregex/1l\t[0-9]{2}-[A-Z]{3}-[0-9]{2}\t\\b, %s\n\n# Type:\tGDSII Stream file\n0\tbelong\t0x00060002\tGDSII Stream file\n>4\tbyte\t0x00\n>>5\tbyte\tx\t\tversion %d.0\n>4\tbyte\t>0x00\t\tversion %d\n>>5\tbyte\tx\t\t\\b.%d\n", "\n#------------------------------------------------------------------------------\n# $File: troff,v 1.10 2009/09/19 16:28:12 christos Exp $\n# troff:  file(1) magic for *roff\n#\n# updated by Daniel Quinlan (quinlan@yggdrasil.com)\n\n# troff input\n0\tsearch/1\t.\\\\\"\t\ttroff or preprocessor input text\n!:mime\ttext/troff\n0\tsearch/1\t'\\\\\"\t\ttroff or preprocessor input text\n!:mime\ttext/troff\n0\tsearch/1\t'.\\\\\"\t\ttroff or preprocessor input text\n!:mime\ttext/troff\n0\tsearch/1\t\\\\\"\t\ttroff or preprocessor input text\n!:mime\ttext/troff\n0\tsearch/1\t'''\t\ttroff or preprocessor input text\n!:mime\ttext/troff\n0\tregex/20l\t\\^\\\\.[A-Za-z0-9][A-Za-z0-9][\\ \\t]\ttroff or preprocessor input text\n!:mime\ttext/troff\n0\tregex/20l\t\\^\\\\.[A-Za-z0-9][A-Za-z0-9]$\ttroff or preprocessor input text\n!:mime\ttext/troff\n\n# ditroff intermediate output text\n0\tsearch/1\tx\\ T\t\tditroff output text\n>4\tsearch/1\tcat\t\tfor the C/A/T phototypesetter\n>4\tsearch/1\tps\t\tfor PostScript\n>4\tsearch/1\tdvi\t\tfor DVI\n>4\tsearch/1\tascii\t\tfor ASCII\n>4\tsearch/1\tlj4\t\tfor LaserJet 4\n>4\tsearch/1\tlatin1\t\tfor ISO 8859-1 (Latin 1)\n>4\tsearch/1\tX75\t\tfor xditview at 75dpi\n>>7\tsearch/1\t-12\t\t(12pt)\n>4\tsearch/1\tX100\t\tfor xditview at 100dpi\n>>8\tsearch/1\t-12\t\t(12pt)\n\n# output data formats\n0\tstring\t\t\\100\\357\tvery old (C/A/T) troff output data\n", "/*\n * Copyright (c) Ian F. Darwin 1986-1995.\n * Software written by Ian F. Darwin and others;\n * maintained 1995-present by Christos Zoulas and others.\n * \n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice immediately at the beginning of the file, without modification,\n *    this list of conditions, and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *  \n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n/*\n * apprentice - make one pass through /etc/magic, learning its secrets.\n */\n\n#include \"file.h\"\n\n#ifndef\tlint\nFILE_RCSID(\"@(#)$File: apprentice.c,v 1.210 2014/05/14 23:15:42 christos Exp $\")\n#endif\t/* lint */\n\n#include \"magic.h\"\n#include <stdlib.h>\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n#ifdef HAVE_STDDEF_H\n#include <stddef.h>\n#endif\n#include <string.h>\n#include <assert.h>\n#include <ctype.h>\n#include <fcntl.h>\n#ifdef QUICK\n#include <sys/mman.h>\n#endif\n#include <dirent.h>\n#if defined(HAVE_LIMITS_H)\n#include <limits.h>\n#endif\n\n#ifndef SSIZE_MAX\n#define MAXMAGIC_SIZE        ((ssize_t)0x7fffffff)\n#else\n#define MAXMAGIC_SIZE        SSIZE_MAX\n#endif\n\n#define\tEATAB {while (isascii((unsigned char) *l) && \\\n\t\t      isspace((unsigned char) *l))  ++l;}\n#define LOWCASE(l) (isupper((unsigned char) (l)) ? \\\n\t\t\ttolower((unsigned char) (l)) : (l))\n/*\n * Work around a bug in headers on Digital Unix.\n * At least confirmed for: OSF1 V4.0 878\n */\n#if defined(__osf__) && defined(__DECC)\n#ifdef MAP_FAILED\n#undef MAP_FAILED\n#endif\n#endif\n\n#ifndef MAP_FAILED\n#define MAP_FAILED (void *) -1\n#endif\n\n#ifndef MAP_FILE\n#define MAP_FILE 0\n#endif\n\n#define ALLOC_CHUNK\t(size_t)10\n#define ALLOC_INCR\t(size_t)200\n\nstruct magic_entry {\n\tstruct magic *mp;\t\n\tuint32_t cont_count;\n\tuint32_t max_count;\n};\n\nstruct magic_entry_set {\n\tstruct magic_entry *me;\n\tuint32_t count;\n\tuint32_t max;\n};\n\nstruct magic_map {\n\tvoid *p;\n\tsize_t len;\n\tstruct magic *magic[MAGIC_SETS];\n\tuint32_t nmagic[MAGIC_SETS];\n};\n\nint file_formats[FILE_NAMES_SIZE];\nconst size_t file_nformats = FILE_NAMES_SIZE;\nconst char *file_names[FILE_NAMES_SIZE];\nconst size_t file_nnames = FILE_NAMES_SIZE;\n\nprivate int getvalue(struct magic_set *ms, struct magic *, const char **, int);\nprivate int hextoint(int);\nprivate const char *getstr(struct magic_set *, struct magic *, const char *,\n    int);\nprivate int parse(struct magic_set *, struct magic_entry *, const char *,\n    size_t, int);\nprivate void eatsize(const char **);\nprivate int apprentice_1(struct magic_set *, const char *, int);\nprivate size_t apprentice_magic_strength(const struct magic *);\nprivate int apprentice_sort(const void *, const void *);\nprivate void apprentice_list(struct mlist *, int );\nprivate struct magic_map *apprentice_load(struct magic_set *, \n    const char *, int);\nprivate struct mlist *mlist_alloc(void);\nprivate void mlist_free(struct mlist *);\nprivate void byteswap(struct magic *, uint32_t);\nprivate void bs1(struct magic *);\nprivate uint16_t swap2(uint16_t);\nprivate uint32_t swap4(uint32_t);\nprivate uint64_t swap8(uint64_t);\nprivate char *mkdbname(struct magic_set *, const char *, int);\nprivate struct magic_map *apprentice_map(struct magic_set *, const char *);\nprivate void apprentice_unmap(struct magic_map *);\nprivate int apprentice_compile(struct magic_set *, struct magic_map *,\n    const char *);\nprivate int check_format_type(const char *, int);\nprivate int check_format(struct magic_set *, struct magic *);\nprivate int get_op(char);\nprivate int parse_mime(struct magic_set *, struct magic_entry *, const char *);\nprivate int parse_strength(struct magic_set *, struct magic_entry *, const char *);\nprivate int parse_apple(struct magic_set *, struct magic_entry *, const char *);\n\n\nprivate size_t magicsize = sizeof(struct magic);\n\nprivate const char usg_hdr[] = \"cont\\toffset\\ttype\\topcode\\tmask\\tvalue\\tdesc\";\n\nprivate struct {\n\tconst char *name;\n\tsize_t len;\n\tint (*fun)(struct magic_set *, struct magic_entry *, const char *);\n} bang[] = {\n#define\tDECLARE_FIELD(name) { # name, sizeof(# name) - 1, parse_ ## name }\n\tDECLARE_FIELD(mime),\n\tDECLARE_FIELD(apple),\n\tDECLARE_FIELD(strength),\n#undef\tDECLARE_FIELD\n\t{ NULL, 0, NULL }\n};\n\n#ifdef COMPILE_ONLY\n\nint main(int, char *[]);\n\nint\nmain(int argc, char *argv[])\n{\n\tint ret;\n\tstruct magic_set *ms;\n\tchar *progname;\n\n\tif ((progname = strrchr(argv[0], '/')) != NULL)\n\t\tprogname++;\n\telse\n\t\tprogname = argv[0];\n\n\tif (argc != 2) {\n\t\t(void)fprintf(stderr, \"Usage: %s file\\n\", progname);\n\t\treturn 1;\n\t}\n\n\tif ((ms = magic_open(MAGIC_CHECK)) == NULL) {\n\t\t(void)fprintf(stderr, \"%s: %s\\n\", progname, strerror(errno));\n\t\treturn 1;\n\t}\n\tret = magic_compile(ms, argv[1]) == -1 ? 1 : 0;\n\tif (ret == 1)\n\t\t(void)fprintf(stderr, \"%s: %s\\n\", progname, magic_error(ms));\n\tmagic_close(ms);\n\treturn ret;\n}\n#endif /* COMPILE_ONLY */\n\nstruct type_tbl_s {\n\tconst char name[16];\n\tconst size_t len;\n\tconst int type;\n\tconst int format;\n};\n\n/*\n * XXX - the actual Single UNIX Specification says that \"long\" means \"long\",\n * as in the C data type, but we treat it as meaning \"4-byte integer\".\n * Given that the OS X version of file 5.04 did the same, I guess that passes\n * the actual test; having \"long\" be dependent on how big a \"long\" is on\n * the machine running \"file\" is silly.\n */\nstatic const struct type_tbl_s type_tbl[] = {\n# define XX(s)\t\ts, (sizeof(s) - 1)\n# define XX_NULL\t\"\", 0\n\t{ XX(\"invalid\"),\tFILE_INVALID,\t\tFILE_FMT_NONE },\n\t{ XX(\"byte\"),\t\tFILE_BYTE,\t\tFILE_FMT_NUM },\n\t{ XX(\"short\"),\t\tFILE_SHORT,\t\tFILE_FMT_NUM },\n\t{ XX(\"default\"),\tFILE_DEFAULT,\t\tFILE_FMT_NONE },\n\t{ XX(\"long\"),\t\tFILE_LONG,\t\tFILE_FMT_NUM },\n\t{ XX(\"string\"),\t\tFILE_STRING,\t\tFILE_FMT_STR },\n\t{ XX(\"date\"),\t\tFILE_DATE,\t\tFILE_FMT_STR },\n\t{ XX(\"beshort\"),\tFILE_BESHORT,\t\tFILE_FMT_NUM },\n\t{ XX(\"belong\"),\t\tFILE_BELONG,\t\tFILE_FMT_NUM },\n\t{ XX(\"bedate\"),\t\tFILE_BEDATE,\t\tFILE_FMT_STR },\n\t{ XX(\"leshort\"),\tFILE_LESHORT,\t\tFILE_FMT_NUM },\n\t{ XX(\"lelong\"),\t\tFILE_LELONG,\t\tFILE_FMT_NUM },\n\t{ XX(\"ledate\"),\t\tFILE_LEDATE,\t\tFILE_FMT_STR },\n\t{ XX(\"pstring\"),\tFILE_PSTRING,\t\tFILE_FMT_STR },\n\t{ XX(\"ldate\"),\t\tFILE_LDATE,\t\tFILE_FMT_STR },\n\t{ XX(\"beldate\"),\tFILE_BELDATE,\t\tFILE_FMT_STR },\n\t{ XX(\"leldate\"),\tFILE_LELDATE,\t\tFILE_FMT_STR },\n\t{ XX(\"regex\"),\t\tFILE_REGEX,\t\tFILE_FMT_STR },\n\t{ XX(\"bestring16\"),\tFILE_BESTRING16,\tFILE_FMT_STR },\n\t{ XX(\"lestring16\"),\tFILE_LESTRING16,\tFILE_FMT_STR },\n\t{ XX(\"search\"),\t\tFILE_SEARCH,\t\tFILE_FMT_STR },\n\t{ XX(\"medate\"),\t\tFILE_MEDATE,\t\tFILE_FMT_STR },\n\t{ XX(\"meldate\"),\tFILE_MELDATE,\t\tFILE_FMT_STR },\n\t{ XX(\"melong\"),\t\tFILE_MELONG,\t\tFILE_FMT_NUM },\n\t{ XX(\"quad\"),\t\tFILE_QUAD,\t\tFILE_FMT_QUAD },\n\t{ XX(\"lequad\"),\t\tFILE_LEQUAD,\t\tFILE_FMT_QUAD },\n\t{ XX(\"bequad\"),\t\tFILE_BEQUAD,\t\tFILE_FMT_QUAD },\n\t{ XX(\"qdate\"),\t\tFILE_QDATE,\t\tFILE_FMT_STR },\n\t{ XX(\"leqdate\"),\tFILE_LEQDATE,\t\tFILE_FMT_STR },\n\t{ XX(\"beqdate\"),\tFILE_BEQDATE,\t\tFILE_FMT_STR },\n\t{ XX(\"qldate\"),\t\tFILE_QLDATE,\t\tFILE_FMT_STR },\n\t{ XX(\"leqldate\"),\tFILE_LEQLDATE,\t\tFILE_FMT_STR },\n\t{ XX(\"beqldate\"),\tFILE_BEQLDATE,\t\tFILE_FMT_STR },\n\t{ XX(\"float\"),\t\tFILE_FLOAT,\t\tFILE_FMT_FLOAT },\n\t{ XX(\"befloat\"),\tFILE_BEFLOAT,\t\tFILE_FMT_FLOAT },\n\t{ XX(\"lefloat\"),\tFILE_LEFLOAT,\t\tFILE_FMT_FLOAT },\n\t{ XX(\"double\"),\t\tFILE_DOUBLE,\t\tFILE_FMT_DOUBLE },\n\t{ XX(\"bedouble\"),\tFILE_BEDOUBLE,\t\tFILE_FMT_DOUBLE },\n\t{ XX(\"ledouble\"),\tFILE_LEDOUBLE,\t\tFILE_FMT_DOUBLE },\n\t{ XX(\"leid3\"),\t\tFILE_LEID3,\t\tFILE_FMT_NUM },\n\t{ XX(\"beid3\"),\t\tFILE_BEID3,\t\tFILE_FMT_NUM },\n\t{ XX(\"indirect\"),\tFILE_INDIRECT,\t\tFILE_FMT_NUM },\n\t{ XX(\"qwdate\"),\t\tFILE_QWDATE,\t\tFILE_FMT_STR },\n\t{ XX(\"leqwdate\"),\tFILE_LEQWDATE,\t\tFILE_FMT_STR },\n\t{ XX(\"beqwdate\"),\tFILE_BEQWDATE,\t\tFILE_FMT_STR },\n\t{ XX(\"name\"),\t\tFILE_NAME,\t\tFILE_FMT_NONE },\n\t{ XX(\"use\"),\t\tFILE_USE,\t\tFILE_FMT_NONE },\n\t{ XX(\"clear\"),\t\tFILE_CLEAR,\t\tFILE_FMT_NONE },\n\t{ XX_NULL,\t\tFILE_INVALID,\t\tFILE_FMT_NONE },\n};\n\n/*\n * These are not types, and cannot be preceded by \"u\" to make them\n * unsigned.\n */\nstatic const struct type_tbl_s special_tbl[] = {\n\t{ XX(\"name\"),\t\tFILE_NAME,\t\tFILE_FMT_STR },\n\t{ XX(\"use\"),\t\tFILE_USE,\t\tFILE_FMT_STR },\n\t{ XX_NULL,\t\tFILE_INVALID,\t\tFILE_FMT_NONE },\n};\n# undef XX\n# undef XX_NULL\n\nprivate int\nget_type(const struct type_tbl_s *tbl, const char *l, const char **t)\n{\n\tconst struct type_tbl_s *p;\n\n\tfor (p = tbl; p->len; p++) {\n\t\tif (strncmp(l, p->name, p->len) == 0) {\n\t\t\tif (t)\n\t\t\t\t*t = l + p->len;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn p->type;\n}\n\nprivate int\nget_standard_integer_type(const char *l, const char **t)\n{\n\tint type;\n\n\tif (isalpha((unsigned char)l[1])) {\n\t\tswitch (l[1]) {\n\t\tcase 'C':\n\t\t\t/* \"dC\" and \"uC\" */\n\t\t\ttype = FILE_BYTE;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\t/* \"dS\" and \"uS\" */\n\t\t\ttype = FILE_SHORT;\n\t\t\tbreak;\n\t\tcase 'I':\n\t\tcase 'L':\n\t\t\t/*\n\t\t\t * \"dI\", \"dL\", \"uI\", and \"uL\".\n\t\t\t *\n\t\t\t * XXX - the actual Single UNIX Specification says\n\t\t\t * that \"L\" means \"long\", as in the C data type,\n\t\t\t * but we treat it as meaning \"4-byte integer\".\n\t\t\t * Given that the OS X version of file 5.04 did\n\t\t\t * the same, I guess that passes the actual SUS\n\t\t\t * validation suite; having \"dL\" be dependent on\n\t\t\t * how big a \"long\" is on the machine running\n\t\t\t * \"file\" is silly.\n\t\t\t */\n\t\t\ttype = FILE_LONG;\n\t\t\tbreak;\n\t\tcase 'Q':\n\t\t\t/* \"dQ\" and \"uQ\" */\n\t\t\ttype = FILE_QUAD;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* \"d{anything else}\", \"u{anything else}\" */\n\t\t\treturn FILE_INVALID;\n\t\t}\n\t\tl += 2;\n\t} else if (isdigit((unsigned char)l[1])) {\n\t\t/*\n\t\t * \"d{num}\" and \"u{num}\"; we only support {num} values\n\t\t * of 1, 2, 4, and 8 - the Single UNIX Specification\n\t\t * doesn't say anything about whether arbitrary\n\t\t * values should be supported, but both the Solaris 10\n\t\t * and OS X Mountain Lion versions of file passed the\n\t\t * Single UNIX Specification validation suite, and\n\t\t * neither of them support values bigger than 8 or\n\t\t * non-power-of-2 values.\n\t\t */\n\t\tif (isdigit((unsigned char)l[2])) {\n\t\t\t/* Multi-digit, so > 9 */\n\t\t\treturn FILE_INVALID;\n\t\t}\n\t\tswitch (l[1]) {\n\t\tcase '1':\n\t\t\ttype = FILE_BYTE;\n\t\t\tbreak;\n\t\tcase '2':\n\t\t\ttype = FILE_SHORT;\n\t\t\tbreak;\n\t\tcase '4':\n\t\t\ttype = FILE_LONG;\n\t\t\tbreak;\n\t\tcase '8':\n\t\t\ttype = FILE_QUAD;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* XXX - what about 3, 5, 6, or 7? */\n\t\t\treturn FILE_INVALID;\n\t\t}\n\t\tl += 2;\n\t} else {\n\t\t/*\n\t\t * \"d\" or \"u\" by itself.\n\t\t */\n\t\ttype = FILE_LONG;\n\t\t++l;\n\t}\n\tif (t)\n\t\t*t = l;\n\treturn type;\n}\n\nprivate void\ninit_file_tables(void)\n{\n\tstatic int done = 0;\n\tconst struct type_tbl_s *p;\n\n\tif (done)\n\t\treturn;\n\tdone++;\n\n\tfor (p = type_tbl; p->len; p++) {\n\t\tassert(p->type < FILE_NAMES_SIZE);\n\t\tfile_names[p->type] = p->name;\n\t\tfile_formats[p->type] = p->format;\n\t}\n\tassert(p - type_tbl == FILE_NAMES_SIZE);\n}\n\nprivate int\nadd_mlist(struct mlist *mlp, struct magic_map *map, size_t idx)\n{\n\tstruct mlist *ml;\n\n\tif ((ml = CAST(struct mlist *, malloc(sizeof(*ml)))) == NULL)\n\t\treturn -1;\n\n\tml->map = idx == 0 ? map : NULL;\n\tml->magic = map->magic[idx];\n\tml->nmagic = map->nmagic[idx];\n\n\tmlp->prev->next = ml;\n\tml->prev = mlp->prev;\n\tml->next = mlp;\n\tmlp->prev = ml;\n\treturn 0;\n}\n\n/*\n * Handle one file or directory.\n */\nprivate int\napprentice_1(struct magic_set *ms, const char *fn, int action)\n{\n\tstruct mlist *ml;\n\tstruct magic_map *map;\n\tsize_t i;\n\n\tif (magicsize != FILE_MAGICSIZE) {\n\t\tfile_error(ms, 0, \"magic element size %lu != %lu\",\n\t\t    (unsigned long)sizeof(*map->magic[0]),\n\t\t    (unsigned long)FILE_MAGICSIZE);\n\t\treturn -1;\n\t}\n\n\tif (action == FILE_COMPILE) {\n\t\tmap = apprentice_load(ms, fn, action);\n\t\tif (map == NULL)\n\t\t\treturn -1;\n\t\treturn apprentice_compile(ms, map, fn);\n\t}\n\n#ifndef COMPILE_ONLY\n\tmap = apprentice_map(ms, fn);\n\tif (map == NULL) {\n\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\tfile_magwarn(ms, \"using regular magic file `%s'\", fn);\n\t\tmap = apprentice_load(ms, fn, action);\n\t\tif (map == NULL)\n\t\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < MAGIC_SETS; i++) {\n\t\tif (add_mlist(ms->mlist[i], map, i) == -1) {\n\t\t\tfile_oomem(ms, sizeof(*ml));\n\t\t\tapprentice_unmap(map);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (action == FILE_LIST) {\n\t\tfor (i = 0; i < MAGIC_SETS; i++) {\n\t\t\tprintf(\"Set %zu:\\nBinary patterns:\\n\", i);\n\t\t\tapprentice_list(ms->mlist[i], BINTEST);\n\t\t\tprintf(\"Text patterns:\\n\");\n\t\t\tapprentice_list(ms->mlist[i], TEXTTEST);\n\t\t}\n\t}\n\t\n\treturn 0;\n#endif /* COMPILE_ONLY */\n}\n\nprotected void\nfile_ms_free(struct magic_set *ms)\n{\n\tsize_t i;\n\tif (ms == NULL)\n\t\treturn;\n\tfor (i = 0; i < MAGIC_SETS; i++)\n\t\tmlist_free(ms->mlist[i]);\n\tfree(ms->o.pbuf);\n\tfree(ms->o.buf);\n\tfree(ms->c.li);\n\tfree(ms);\n}\n\nprotected struct magic_set *\nfile_ms_alloc(int flags)\n{\n\tstruct magic_set *ms;\n\tsize_t i, len;\n\n\tif ((ms = CAST(struct magic_set *, calloc((size_t)1,\n\t    sizeof(struct magic_set)))) == NULL)\n\t\treturn NULL;\n\n\tif (magic_setflags(ms, flags) == -1) {\n\t\terrno = EINVAL;\n\t\tgoto free;\n\t}\n\n\tms->o.buf = ms->o.pbuf = NULL;\n\tlen = (ms->c.len = 10) * sizeof(*ms->c.li);\n\n\tif ((ms->c.li = CAST(struct level_info *, malloc(len))) == NULL)\n\t\tgoto free;\n\n\tms->event_flags = 0;\n\tms->error = -1;\n\tfor (i = 0; i < MAGIC_SETS; i++)\n\t\tms->mlist[i] = NULL;\n\tms->file = \"unknown\";\n\tms->line = 0;\n\treturn ms;\nfree:\n\tfree(ms);\n\treturn NULL;\n}\n\nprivate void\napprentice_unmap(struct magic_map *map)\n{\n\tif (map == NULL)\n\t\treturn;\n\tif (map->p != NULL) {\n#ifdef QUICK\n\t\tif (map->len)\n\t\t\t(void)munmap(map->p, map->len);\n\t\telse\n#endif\n\t\tfree(map->p);\n\t} else {\n\t\tuint32_t j;\n\t\tfor (j = 0; j < MAGIC_SETS; j++)\n\t\t\tfree(map->magic[j]);\n\t}\n\tfree(map);\n}\n\nprivate struct mlist *\nmlist_alloc(void)\n{\n\tstruct mlist *mlist;\n\tif ((mlist = CAST(struct mlist *, calloc(1, sizeof(*mlist)))) == NULL) {\n\t\treturn NULL;\n\t}\n\tmlist->next = mlist->prev = mlist;\n\treturn mlist;\n}\n\nprivate void\nmlist_free(struct mlist *mlist)\n{\n\tstruct mlist *ml;\n\n\tif (mlist == NULL)\n\t\treturn;\n\n\tfor (ml = mlist->next; ml != mlist;) {\n\t\tstruct mlist *next = ml->next;\n\t\tif (ml->map)\n\t\t\tapprentice_unmap(ml->map);\n\t\tfree(ml);\n\t\tml = next;\n\t}\n\tfree(ml);\n}\n\n/* const char *fn: list of magic files and directories */\nprotected int\nfile_apprentice(struct magic_set *ms, const char *fn, int action)\n{\n\tchar *p, *mfn;\n\tint file_err, errs = -1;\n\tsize_t i;\n\n\tif (ms->mlist[0] != NULL)\n\t\tfile_reset(ms);\n\n\tif ((fn = magic_getpath(fn, action)) == NULL)\n\t\treturn -1;\n\n\tinit_file_tables();\n\n\tif ((mfn = strdup(fn)) == NULL) {\n\t\tfile_oomem(ms, strlen(fn));\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < MAGIC_SETS; i++) {\n\t\tmlist_free(ms->mlist[i]);\n\t\tif ((ms->mlist[i] = mlist_alloc()) == NULL) {\n\t\t\tfile_oomem(ms, sizeof(*ms->mlist[i]));\n\t\t\tif (i != 0) {\n\t\t\t\t--i;\n\t\t\t\tdo\n\t\t\t\t\tmlist_free(ms->mlist[i]);\n\t\t\t\twhile (i != 0);\n\t\t\t}\n\t\t\tfree(mfn);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tfn = mfn;\n\n\twhile (fn) {\n\t\tp = strchr(fn, PATHSEP);\n\t\tif (p)\n\t\t\t*p++ = '\\0';\n\t\tif (*fn == '\\0')\n\t\t\tbreak;\n\t\tfile_err = apprentice_1(ms, fn, action);\n\t\terrs = MAX(errs, file_err);\n\t\tfn = p;\n\t}\n\n\tfree(mfn);\n\n\tif (errs == -1) {\n\t\tfor (i = 0; i < MAGIC_SETS; i++) {\n\t\t\tmlist_free(ms->mlist[i]);\n\t\t\tms->mlist[i] = NULL;\n\t\t}\n\t\tfile_error(ms, 0, \"could not find any valid magic files!\");\n\t\treturn -1;\n\t}\n\n#if 0\n\t/*\n\t * Always leave the database loaded\n\t */\n\tif (action == FILE_LOAD)\n\t\treturn 0;\n\n\tfor (i = 0; i < MAGIC_SETS; i++) {\n\t\tmlist_free(ms->mlist[i]);\n\t\tms->mlist[i] = NULL;\n\t}\n#endif\n\n\tswitch (action) {\n\tcase FILE_LOAD:\n\tcase FILE_COMPILE:\n\tcase FILE_CHECK:\n\tcase FILE_LIST:\n\t\treturn 0;\n\tdefault:\n\t\tfile_error(ms, 0, \"Invalid action %d\", action);\n\t\treturn -1;\n\t}\n}\n\n/*\n * Compute the real length of a magic expression, for the purposes\n * of determining how \"strong\" a magic expression is (approximating\n * how specific its matches are):\n *\t- magic characters count 0 unless escaped.\n *\t- [] expressions count 1\n *\t- {} expressions count 0\n *\t- regular characters or escaped magic characters count 1\n *\t- 0 length expressions count as one\n */\nprivate size_t\nnonmagic(const char *str)\n{\n\tconst char *p;\n\tsize_t rv = 0;\n\n\tfor (p = str; *p; p++)\n\t\tswitch (*p) {\n\t\tcase '\\\\':\t/* Escaped anything counts 1 */\n\t\t\tif (!*++p)\n\t\t\t\tp--;\n\t\t\trv++;\n\t\t\tcontinue;\n\t\tcase '?':\t/* Magic characters count 0 */\n\t\tcase '*':\n\t\tcase '.':\n\t\tcase '+':\n\t\tcase '^':\n\t\tcase '$':\n\t\t\tcontinue;\n\t\tcase '[':\t/* Bracketed expressions count 1 the ']' */\n\t\t\twhile (*p && *p != ']')\n\t\t\t\tp++;\n\t\t\tp--;\n\t\t\tcontinue;\n\t\tcase '{':\t/* Braced expressions count 0 */\n\t\t\twhile (*p && *p != '}')\n\t\t\t\tp++;\n\t\t\tif (!*p)\n\t\t\t\tp--;\n\t\t\tcontinue;\n\t\tdefault:\t/* Anything else counts 1 */\n\t\t\trv++;\n\t\t\tcontinue;\n\t\t}\n\n\treturn rv == 0 ? 1 : rv;\t/* Return at least 1 */\n}\n\n/*\n * Get weight of this magic entry, for sorting purposes.\n */\nprivate size_t\napprentice_magic_strength(const struct magic *m)\n{\n#define MULT 10\n\tsize_t v, val = 2 * MULT;\t/* baseline strength */\n\n\tswitch (m->type) {\n\tcase FILE_DEFAULT:\t/* make sure this sorts last */\n\t\tif (m->factor_op != FILE_FACTOR_OP_NONE)\n\t\t\tabort();\n\t\treturn 0;\n\n\tcase FILE_BYTE:\n\t\tval += 1 * MULT;\n\t\tbreak;\n\n\tcase FILE_SHORT:\n\tcase FILE_LESHORT:\n\tcase FILE_BESHORT:\n\t\tval += 2 * MULT;\n\t\tbreak;\n\n\tcase FILE_LONG:\n\tcase FILE_LELONG:\n\tcase FILE_BELONG:\n\tcase FILE_MELONG:\n\t\tval += 4 * MULT;\n\t\tbreak;\n\n\tcase FILE_PSTRING:\n\tcase FILE_STRING:\n\t\tval += m->vallen * MULT;\n\t\tbreak;\n\n\tcase FILE_BESTRING16:\n\tcase FILE_LESTRING16:\n\t\tval += m->vallen * MULT / 2;\n\t\tbreak;\n\n\tcase FILE_SEARCH:\n\t\tval += m->vallen * MAX(MULT / m->vallen, 1);\n\t\tbreak;\n\n\tcase FILE_REGEX:\n\t\tv = nonmagic(m->value.s);\n\t\tval += v * MAX(MULT / v, 1);\n\t\tbreak;\n\n\tcase FILE_DATE:\n\tcase FILE_LEDATE:\n\tcase FILE_BEDATE:\n\tcase FILE_MEDATE:\n\tcase FILE_LDATE:\n\tcase FILE_LELDATE:\n\tcase FILE_BELDATE:\n\tcase FILE_MELDATE:\n\tcase FILE_FLOAT:\n\tcase FILE_BEFLOAT:\n\tcase FILE_LEFLOAT:\n\t\tval += 4 * MULT;\n\t\tbreak;\n\n\tcase FILE_QUAD:\n\tcase FILE_BEQUAD:\n\tcase FILE_LEQUAD:\n\tcase FILE_QDATE:\n\tcase FILE_LEQDATE:\n\tcase FILE_BEQDATE:\n\tcase FILE_QLDATE:\n\tcase FILE_LEQLDATE:\n\tcase FILE_BEQLDATE:\n\tcase FILE_QWDATE:\n\tcase FILE_LEQWDATE:\n\tcase FILE_BEQWDATE:\n\tcase FILE_DOUBLE:\n\tcase FILE_BEDOUBLE:\n\tcase FILE_LEDOUBLE:\n\t\tval += 8 * MULT;\n\t\tbreak;\n\n\tcase FILE_INDIRECT:\n\tcase FILE_NAME:\n\tcase FILE_USE:\n\t\tbreak;\n\n\tdefault:\n\t\t(void)fprintf(stderr, \"Bad type %d\\n\", m->type);\n\t\tabort();\n\t}\n\n\tswitch (m->reln) {\n\tcase 'x':\t/* matches anything penalize */\n\tcase '!':       /* matches almost anything penalize */\n\t\tval = 0;\n\t\tbreak;\n\n\tcase '=':\t/* Exact match, prefer */\n\t\tval += MULT;\n\t\tbreak;\n\n\tcase '>':\n\tcase '<':\t/* comparison match reduce strength */\n\t\tval -= 2 * MULT;\n\t\tbreak;\n\n\tcase '^':\n\tcase '&':\t/* masking bits, we could count them too */\n\t\tval -= MULT;\n\t\tbreak;\n\n\tdefault:\n\t\t(void)fprintf(stderr, \"Bad relation %c\\n\", m->reln);\n\t\tabort();\n\t}\n\n\tif (val == 0)\t/* ensure we only return 0 for FILE_DEFAULT */\n\t\tval = 1;\n\n\tswitch (m->factor_op) {\n\tcase FILE_FACTOR_OP_NONE:\n\t\tbreak;\n\tcase FILE_FACTOR_OP_PLUS:\n\t\tval += m->factor;\n\t\tbreak;\n\tcase FILE_FACTOR_OP_MINUS:\n\t\tval -= m->factor;\n\t\tbreak;\n\tcase FILE_FACTOR_OP_TIMES:\n\t\tval *= m->factor;\n\t\tbreak;\n\tcase FILE_FACTOR_OP_DIV:\n\t\tval /= m->factor;\n\t\tbreak;\n\tdefault:\n\t\tabort();\n\t}\n\n\t/*\n\t * Magic entries with no description get a bonus because they depend\n\t * on subsequent magic entries to print something.\n\t */\n\tif (m->desc[0] == '\\0')\n\t\tval++;\n\treturn val;\n}\n\n/*  \n * Sort callback for sorting entries by \"strength\" (basically length)\n */\nprivate int\napprentice_sort(const void *a, const void *b)\n{\n\tconst struct magic_entry *ma = CAST(const struct magic_entry *, a);\n\tconst struct magic_entry *mb = CAST(const struct magic_entry *, b);\n\tsize_t sa = apprentice_magic_strength(ma->mp);\n\tsize_t sb = apprentice_magic_strength(mb->mp);\n\tif (sa == sb)\n\t\treturn 0;\n\telse if (sa > sb)\n\t\treturn -1;\n\telse\n\t\treturn 1;\n}\n\n/*  \n * Shows sorted patterns list in the order which is used for the matching\n */\nprivate void\napprentice_list(struct mlist *mlist, int mode)\n{\n\tuint32_t magindex = 0;\n\tstruct mlist *ml;\n\tfor (ml = mlist->next; ml != mlist; ml = ml->next) {\n\t\tfor (magindex = 0; magindex < ml->nmagic; magindex++) {\n\t\t\tstruct magic *m = &ml->magic[magindex];\n\t\t\tif ((m->flag & mode) != mode) {\n\t\t\t\t/* Skip sub-tests */\n\t\t\t\twhile (magindex + 1 < ml->nmagic &&\n\t\t\t\t       ml->magic[magindex + 1].cont_level != 0)\n\t\t\t\t\t++magindex;\n\t\t\t\tcontinue; /* Skip to next top-level test*/\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Try to iterate over the tree until we find item with\n\t\t\t * description/mimetype.\n\t\t\t */\n\t\t\twhile (magindex + 1 < ml->nmagic &&\n\t\t\t       ml->magic[magindex + 1].cont_level != 0 &&\n\t\t\t       *ml->magic[magindex].desc == '\\0' &&\n\t\t\t       *ml->magic[magindex].mimetype == '\\0')\n\t\t\t\tmagindex++;\n\n\t\t\tprintf(\"Strength = %3\" SIZE_T_FORMAT \"u : %s [%s]\\n\",\n\t\t\t    apprentice_magic_strength(m),\n\t\t\t    ml->magic[magindex].desc,\n\t\t\t    ml->magic[magindex].mimetype);\n\t\t}\n\t}\n}\n\nprivate void\nset_test_type(struct magic *mstart, struct magic *m)\n{\n\tswitch (m->type) {\n\tcase FILE_BYTE:\n\tcase FILE_SHORT:\n\tcase FILE_LONG:\n\tcase FILE_DATE:\n\tcase FILE_BESHORT:\n\tcase FILE_BELONG:\n\tcase FILE_BEDATE:\n\tcase FILE_LESHORT:\n\tcase FILE_LELONG:\n\tcase FILE_LEDATE:\n\tcase FILE_LDATE:\n\tcase FILE_BELDATE:\n\tcase FILE_LELDATE:\n\tcase FILE_MEDATE:\n\tcase FILE_MELDATE:\n\tcase FILE_MELONG:\n\tcase FILE_QUAD:\n\tcase FILE_LEQUAD:\n\tcase FILE_BEQUAD:\n\tcase FILE_QDATE:\n\tcase FILE_LEQDATE:\n\tcase FILE_BEQDATE:\n\tcase FILE_QLDATE:\n\tcase FILE_LEQLDATE:\n\tcase FILE_BEQLDATE:\n\tcase FILE_QWDATE:\n\tcase FILE_LEQWDATE:\n\tcase FILE_BEQWDATE:\n\tcase FILE_FLOAT:\n\tcase FILE_BEFLOAT:\n\tcase FILE_LEFLOAT:\n\tcase FILE_DOUBLE:\n\tcase FILE_BEDOUBLE:\n\tcase FILE_LEDOUBLE:\n\t\tmstart->flag |= BINTEST;\n\t\tbreak;\n\tcase FILE_STRING:\n\tcase FILE_PSTRING:\n\tcase FILE_BESTRING16:\n\tcase FILE_LESTRING16:\n\t\t/* Allow text overrides */\n\t\tif (mstart->str_flags & STRING_TEXTTEST)\n\t\t\tmstart->flag |= TEXTTEST;\n\t\telse\n\t\t\tmstart->flag |= BINTEST;\n\t\tbreak;\n\tcase FILE_REGEX:\n\tcase FILE_SEARCH:\n\t\t/* Check for override */\n\t\tif (mstart->str_flags & STRING_BINTEST)\n\t\t\tmstart->flag |= BINTEST;\n\t\tif (mstart->str_flags & STRING_TEXTTEST)\n\t\t\tmstart->flag |= TEXTTEST;\n\t\t    \n\t\tif (mstart->flag & (TEXTTEST|BINTEST))\n\t\t\tbreak;\n\n\t\t/* binary test if pattern is not text */\n\t\tif (file_looks_utf8(m->value.us, (size_t)m->vallen, NULL,\n\t\t    NULL) <= 0)\n\t\t\tmstart->flag |= BINTEST;\n\t\telse\n\t\t\tmstart->flag |= TEXTTEST;\n\t\tbreak;\n\tcase FILE_DEFAULT:\n\t\t/* can't deduce anything; we shouldn't see this at the\n\t\t   top level anyway */\n\t\tbreak;\n\tcase FILE_INVALID:\n\tdefault:\n\t\t/* invalid search type, but no need to complain here */\n\t\tbreak;\n\t}\n}\n\nprivate int\naddentry(struct magic_set *ms, struct magic_entry *me,\n   struct magic_entry_set *mset)\n{\n\tsize_t i = me->mp->type == FILE_NAME ? 1 : 0;\n\tif (mset[i].count == mset[i].max) {\n\t\tstruct magic_entry *mp;\n\n\t\tmset[i].max += ALLOC_INCR;\n\t\tif ((mp = CAST(struct magic_entry *,\n\t\t    realloc(mset[i].me, sizeof(*mp) * mset[i].max))) ==\n\t\t    NULL) {\n\t\t\tfile_oomem(ms, sizeof(*mp) * mset[i].max);\n\t\t\treturn -1;\n\t\t}\n\t\t(void)memset(&mp[mset[i].count], 0, sizeof(*mp) *\n\t\t    ALLOC_INCR);\n\t\tmset[i].me = mp;\n\t}\n\tmset[i].me[mset[i].count++] = *me;\n\tmemset(me, 0, sizeof(*me));\n\treturn 0;\n}\n\n/*\n * Load and parse one file.\n */\nprivate void\nload_1(struct magic_set *ms, int action, const char *fn, int *errs,\n   struct magic_entry_set *mset)\n{\n\tsize_t lineno = 0, llen = 0;\n\tchar *line = NULL;\n\tssize_t len;\n\tstruct magic_entry me;\n\n\tFILE *f = fopen(ms->file = fn, \"r\");\n\tif (f == NULL) {\n\t\tif (errno != ENOENT)\n\t\t\tfile_error(ms, errno, \"cannot read magic file `%s'\",\n\t\t\t\t   fn);\n\t\t(*errs)++;\n\t\treturn;\n\t}\n\n\tmemset(&me, 0, sizeof(me));\n\t/* read and parse this file */\n\tfor (ms->line = 1; (len = getline(&line, &llen, f)) != -1;\n\t    ms->line++) {\n\t\tif (len == 0) /* null line, garbage, etc */\n\t\t\tcontinue;\n\t\tif (line[len - 1] == '\\n') {\n\t\t\tlineno++;\n\t\t\tline[len - 1] = '\\0'; /* delete newline */\n\t\t}\n\t\tswitch (line[0]) {\n\t\tcase '\\0':\t/* empty, do not parse */\n\t\tcase '#':\t/* comment, do not parse */\n\t\t\tcontinue;\n\t\tcase '!':\n\t\t\tif (line[1] == ':') {\n\t\t\t\tsize_t i;\n\n\t\t\t\tfor (i = 0; bang[i].name != NULL; i++) {\n\t\t\t\t\tif ((size_t)(len - 2) > bang[i].len &&\n\t\t\t\t\t    memcmp(bang[i].name, line + 2,\n\t\t\t\t\t    bang[i].len) == 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (bang[i].name == NULL) {\n\t\t\t\t\tfile_error(ms, 0,\n\t\t\t\t\t    \"Unknown !: entry `%s'\", line);\n\t\t\t\t\t(*errs)++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (me.mp == NULL) {\n\t\t\t\t\tfile_error(ms, 0,\n\t\t\t\t\t    \"No current entry for :!%s type\",\n\t\t\t\t\t\tbang[i].name);\n\t\t\t\t\t(*errs)++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif ((*bang[i].fun)(ms, &me,\n\t\t\t\t    line + bang[i].len + 2) != 0) {\n\t\t\t\t\t(*errs)++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*FALLTHROUGH*/\n\t\tdefault:\n\t\tagain:\n\t\t\tswitch (parse(ms, &me, line, lineno, action)) {\n\t\t\tcase 0:\n\t\t\t\tcontinue;\n\t\t\tcase 1:\n\t\t\t\t(void)addentry(ms, &me, mset);\n\t\t\t\tgoto again;\n\t\t\tdefault:\n\t\t\t\t(*errs)++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (me.mp)\n\t\t(void)addentry(ms, &me, mset);\n\tfree(line);\n\t(void)fclose(f);\n}\n\n/*\n * parse a file or directory of files\n * const char *fn: name of magic file or directory\n */\nprivate int\ncmpstrp(const void *p1, const void *p2)\n{\n        return strcmp(*(char *const *)p1, *(char *const *)p2);\n}\n\n\nprivate uint32_t\nset_text_binary(struct magic_set *ms, struct magic_entry *me, uint32_t nme,\n    uint32_t starttest)\n{\n\tstatic const char text[] = \"text\";\n\tstatic const char binary[] = \"binary\";\n\tstatic const size_t len = sizeof(text);\n\n\tuint32_t i = starttest;\n\n\tdo {\n\t\tset_test_type(me[starttest].mp, me[i].mp);\n\t\tif ((ms->flags & MAGIC_DEBUG) == 0)\n\t\t\tcontinue;\n\t\t(void)fprintf(stderr, \"%s%s%s: %s\\n\",\n\t\t    me[i].mp->mimetype,\n\t\t    me[i].mp->mimetype[0] == '\\0' ? \"\" : \"; \",\n\t\t    me[i].mp->desc[0] ? me[i].mp->desc : \"(no description)\",\n\t\t    me[i].mp->flag & BINTEST ? binary : text);\n\t\tif (me[i].mp->flag & BINTEST) {\n\t\t\tchar *p = strstr(me[i].mp->desc, text);\n\t\t\tif (p && (p == me[i].mp->desc ||\n\t\t\t    isspace((unsigned char)p[-1])) &&\n\t\t\t    (p + len - me[i].mp->desc == MAXstring\n\t\t\t    || (p[len] == '\\0' ||\n\t\t\t    isspace((unsigned char)p[len]))))\n\t\t\t\t(void)fprintf(stderr, \"*** Possible \"\n\t\t\t\t    \"binary test for text type\\n\");\n\t\t}\n\t} while (++i < nme && me[i].mp->cont_level != 0);\n\treturn i;\n}\n\nprivate void\nset_last_default(struct magic_set *ms, struct magic_entry *me, uint32_t nme)\n{\n\tuint32_t i;\n\tfor (i = 0; i < nme; i++) {\n\t\tif (me[i].mp->cont_level == 0 &&\n\t\t    me[i].mp->type == FILE_DEFAULT) {\n\t\t\twhile (++i < nme)\n\t\t\t\tif (me[i].mp->cont_level == 0)\n\t\t\t\t\tbreak;\n\t\t\tif (i != nme) {\n\t\t\t\t/* XXX - Ugh! */\n\t\t\t\tms->line = me[i].mp->lineno;\n\t\t\t\tfile_magwarn(ms,\n\t\t\t\t    \"level 0 \\\"default\\\" did not sort last\");\n\t\t\t}\n\t\t\treturn;\t\t\t\t\t    \n\t\t}\n\t}\n}\n\nprivate int\ncoalesce_entries(struct magic_set *ms, struct magic_entry *me, uint32_t nme,\n    struct magic **ma, uint32_t *nma)\n{\n\tuint32_t i, mentrycount = 0;\n\tsize_t slen;\n\n\tfor (i = 0; i < nme; i++)\n\t\tmentrycount += me[i].cont_count;\n\n\tslen = sizeof(**ma) * mentrycount;\n\tif ((*ma = CAST(struct magic *, malloc(slen))) == NULL) {\n\t\tfile_oomem(ms, slen);\n\t\treturn -1;\n\t}\n\n\tmentrycount = 0;\n\tfor (i = 0; i < nme; i++) {\n\t\t(void)memcpy(*ma + mentrycount, me[i].mp,\n\t\t    me[i].cont_count * sizeof(**ma));\n\t\tmentrycount += me[i].cont_count;\n\t}\n\t*nma = mentrycount;\n\treturn 0;\n}\n\nprivate void\nmagic_entry_free(struct magic_entry *me, uint32_t nme)\n{\n\tuint32_t i;\n\tif (me == NULL)\n\t\treturn;\n\tfor (i = 0; i < nme; i++)\n\t\tfree(me[i].mp);\n\tfree(me);\n}\n\nprivate struct magic_map *\napprentice_load(struct magic_set *ms, const char *fn, int action)\n{\n\tint errs = 0;\n\tuint32_t i, j;\n\tsize_t files = 0, maxfiles = 0;\n\tchar **filearr = NULL, *mfn;\n\tstruct stat st;\n\tstruct magic_map *map;\n\tstruct magic_entry_set mset[MAGIC_SETS];\n\tDIR *dir;\n\tstruct dirent *d;\n\n\tmemset(mset, 0, sizeof(mset));\n\tms->flags |= MAGIC_CHECK;\t/* Enable checks for parsed files */\n\n\n\tif ((map = CAST(struct magic_map *, calloc(1, sizeof(*map)))) == NULL)\n\t{\n\t\tfile_oomem(ms, sizeof(*map));\n\t\treturn NULL;\n\t}\n\n\t/* print silly verbose header for USG compat. */\n\tif (action == FILE_CHECK)\n\t\t(void)fprintf(stderr, \"%s\\n\", usg_hdr);\n\n\t/* load directory or file */\n\tif (stat(fn, &st) == 0 && S_ISDIR(st.st_mode)) {\n\t\tdir = opendir(fn);\n\t\tif (!dir) {\n\t\t\terrs++;\n\t\t\tgoto out;\n\t\t}\n\t\twhile ((d = readdir(dir)) != NULL) {\n\t\t\tif (asprintf(&mfn, \"%s/%s\", fn, d->d_name) < 0) {\n\t\t\t\tfile_oomem(ms,\n\t\t\t\t    strlen(fn) + strlen(d->d_name) + 2);\n\t\t\t\terrs++;\n\t\t\t\tclosedir(dir);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (stat(mfn, &st) == -1 || !S_ISREG(st.st_mode)) {\n\t\t\t\tfree(mfn);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (files >= maxfiles) {\n\t\t\t\tsize_t mlen;\n\t\t\t\tmaxfiles = (maxfiles + 1) * 2;\n\t\t\t\tmlen = maxfiles * sizeof(*filearr);\n\t\t\t\tif ((filearr = CAST(char **,\n\t\t\t\t    realloc(filearr, mlen))) == NULL) {\n\t\t\t\t\tfile_oomem(ms, mlen);\n\t\t\t\t\tfree(mfn);\n\t\t\t\t\tclosedir(dir);\n\t\t\t\t\terrs++;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfilearr[files++] = mfn;\n\t\t}\n\t\tclosedir(dir);\n\t\tqsort(filearr, files, sizeof(*filearr), cmpstrp);\n\t\tfor (i = 0; i < files; i++) {\n\t\t\tload_1(ms, action, filearr[i], &errs, mset);\n\t\t\tfree(filearr[i]);\n\t\t}\n\t\tfree(filearr);\n\t} else\n\t\tload_1(ms, action, fn, &errs, mset);\n\tif (errs)\n\t\tgoto out;\n\n\tfor (j = 0; j < MAGIC_SETS; j++) {\n\t\t/* Set types of tests */\n\t\tfor (i = 0; i < mset[j].count; ) {\n\t\t\tif (mset[j].me[i].mp->cont_level != 0) {\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ti = set_text_binary(ms, mset[j].me, mset[j].count, i);\n\t\t}\n\t\tqsort(mset[j].me, mset[j].count, sizeof(*mset[j].me),\n\t\t    apprentice_sort);\n\n\t\t/*\n\t\t * Make sure that any level 0 \"default\" line is last\n\t\t * (if one exists).\n\t\t */\n\t\tset_last_default(ms, mset[j].me, mset[j].count);\n\n\t\t/* coalesce per file arrays into a single one */\n\t\tif (coalesce_entries(ms, mset[j].me, mset[j].count,\n\t\t    &map->magic[j], &map->nmagic[j]) == -1) {\n\t\t\terrs++;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tfor (j = 0; j < MAGIC_SETS; j++)\n\t\tmagic_entry_free(mset[j].me, mset[j].count);\n\n\tif (errs) {\n\t\tapprentice_unmap(map);\n\t\treturn NULL;\n\t}\n\treturn map;\n}\n\n/*\n * extend the sign bit if the comparison is to be signed\n */\nprotected uint64_t\nfile_signextend(struct magic_set *ms, struct magic *m, uint64_t v)\n{\n\tif (!(m->flag & UNSIGNED)) {\n\t\tswitch(m->type) {\n\t\t/*\n\t\t * Do not remove the casts below.  They are\n\t\t * vital.  When later compared with the data,\n\t\t * the sign extension must have happened.\n\t\t */\n\t\tcase FILE_BYTE:\n\t\t\tv = (char) v;\n\t\t\tbreak;\n\t\tcase FILE_SHORT:\n\t\tcase FILE_BESHORT:\n\t\tcase FILE_LESHORT:\n\t\t\tv = (short) v;\n\t\t\tbreak;\n\t\tcase FILE_DATE:\n\t\tcase FILE_BEDATE:\n\t\tcase FILE_LEDATE:\n\t\tcase FILE_MEDATE:\n\t\tcase FILE_LDATE:\n\t\tcase FILE_BELDATE:\n\t\tcase FILE_LELDATE:\n\t\tcase FILE_MELDATE:\n\t\tcase FILE_LONG:\n\t\tcase FILE_BELONG:\n\t\tcase FILE_LELONG:\n\t\tcase FILE_MELONG:\n\t\tcase FILE_FLOAT:\n\t\tcase FILE_BEFLOAT:\n\t\tcase FILE_LEFLOAT:\n\t\t\tv = (int32_t) v;\n\t\t\tbreak;\n\t\tcase FILE_QUAD:\n\t\tcase FILE_BEQUAD:\n\t\tcase FILE_LEQUAD:\n\t\tcase FILE_QDATE:\n\t\tcase FILE_QLDATE:\n\t\tcase FILE_QWDATE:\n\t\tcase FILE_BEQDATE:\n\t\tcase FILE_BEQLDATE:\n\t\tcase FILE_BEQWDATE:\n\t\tcase FILE_LEQDATE:\n\t\tcase FILE_LEQLDATE:\n\t\tcase FILE_LEQWDATE:\n\t\tcase FILE_DOUBLE:\n\t\tcase FILE_BEDOUBLE:\n\t\tcase FILE_LEDOUBLE:\n\t\t\tv = (int64_t) v;\n\t\t\tbreak;\n\t\tcase FILE_STRING:\n\t\tcase FILE_PSTRING:\n\t\tcase FILE_BESTRING16:\n\t\tcase FILE_LESTRING16:\n\t\tcase FILE_REGEX:\n\t\tcase FILE_SEARCH:\n\t\tcase FILE_DEFAULT:\n\t\tcase FILE_INDIRECT:\n\t\tcase FILE_NAME:\n\t\tcase FILE_USE:\n\t\tcase FILE_CLEAR:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\t    file_magwarn(ms, \"cannot happen: m->type=%d\\n\",\n\t\t\t\t    m->type);\n\t\t\treturn ~0U;\n\t\t}\n\t}\n\treturn v;\n}\n\nprivate int\nstring_modifier_check(struct magic_set *ms, struct magic *m)\n{\n\tif ((ms->flags & MAGIC_CHECK) == 0)\n\t\treturn 0;\n\n\tif ((m->type != FILE_REGEX || (m->str_flags & REGEX_LINE_COUNT) == 0) &&\n\t    (m->type != FILE_PSTRING && (m->str_flags & PSTRING_LEN) != 0)) {\n\t\tfile_magwarn(ms,\n\t\t    \"'/BHhLl' modifiers are only allowed for pascal strings\\n\");\n\t\treturn -1;\n\t}\n\tswitch (m->type) {\n\tcase FILE_BESTRING16:\n\tcase FILE_LESTRING16:\n\t\tif (m->str_flags != 0) {\n\t\t\tfile_magwarn(ms,\n\t\t\t    \"no modifiers allowed for 16-bit strings\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase FILE_STRING:\n\tcase FILE_PSTRING:\n\t\tif ((m->str_flags & REGEX_OFFSET_START) != 0) {\n\t\t\tfile_magwarn(ms,\n\t\t\t    \"'/%c' only allowed on regex and search\\n\",\n\t\t\t    CHAR_REGEX_OFFSET_START);\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase FILE_SEARCH:\n\t\tif (m->str_range == 0) {\n\t\t\tfile_magwarn(ms,\n\t\t\t    \"missing range; defaulting to %d\\n\",\n                            STRING_DEFAULT_RANGE);\n\t\t\tm->str_range = STRING_DEFAULT_RANGE;\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase FILE_REGEX:\n\t\tif ((m->str_flags & STRING_COMPACT_WHITESPACE) != 0) {\n\t\t\tfile_magwarn(ms, \"'/%c' not allowed on regex\\n\",\n\t\t\t    CHAR_COMPACT_WHITESPACE);\n\t\t\treturn -1;\n\t\t}\n\t\tif ((m->str_flags & STRING_COMPACT_OPTIONAL_WHITESPACE) != 0) {\n\t\t\tfile_magwarn(ms, \"'/%c' not allowed on regex\\n\",\n\t\t\t    CHAR_COMPACT_OPTIONAL_WHITESPACE);\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tfile_magwarn(ms, \"coding error: m->type=%d\\n\",\n\t\t    m->type);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nprivate int\nget_op(char c)\n{\n\tswitch (c) {\n\tcase '&':\n\t\treturn FILE_OPAND;\n\tcase '|':\n\t\treturn FILE_OPOR;\n\tcase '^':\n\t\treturn FILE_OPXOR;\n\tcase '+':\n\t\treturn FILE_OPADD;\n\tcase '-':\n\t\treturn FILE_OPMINUS;\n\tcase '*':\n\t\treturn FILE_OPMULTIPLY;\n\tcase '/':\n\t\treturn FILE_OPDIVIDE;\n\tcase '%':\n\t\treturn FILE_OPMODULO;\n\tdefault:\n\t\treturn -1;\n\t}\n}\n\n#ifdef ENABLE_CONDITIONALS\nprivate int\nget_cond(const char *l, const char **t)\n{\n\tstatic const struct cond_tbl_s {\n\t\tchar name[8];\n\t\tsize_t len;\n\t\tint cond;\n\t} cond_tbl[] = {\n\t\t{ \"if\",\t\t2,\tCOND_IF },\n\t\t{ \"elif\",\t4,\tCOND_ELIF },\n\t\t{ \"else\",\t4,\tCOND_ELSE },\n\t\t{ \"\",\t\t0,\tCOND_NONE },\n\t};\n\tconst struct cond_tbl_s *p;\n\n\tfor (p = cond_tbl; p->len; p++) {\n\t\tif (strncmp(l, p->name, p->len) == 0 &&\n\t\t    isspace((unsigned char)l[p->len])) {\n\t\t\tif (t)\n\t\t\t\t*t = l + p->len;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn p->cond;\n}\n\nprivate int\ncheck_cond(struct magic_set *ms, int cond, uint32_t cont_level)\n{\n\tint last_cond;\n\tlast_cond = ms->c.li[cont_level].last_cond;\n\n\tswitch (cond) {\n\tcase COND_IF:\n\t\tif (last_cond != COND_NONE && last_cond != COND_ELIF) {\n\t\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\t\tfile_magwarn(ms, \"syntax error: `if'\");\n\t\t\treturn -1;\n\t\t}\n\t\tlast_cond = COND_IF;\n\t\tbreak;\n\n\tcase COND_ELIF:\n\t\tif (last_cond != COND_IF && last_cond != COND_ELIF) {\n\t\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\t\tfile_magwarn(ms, \"syntax error: `elif'\");\n\t\t\treturn -1;\n\t\t}\n\t\tlast_cond = COND_ELIF;\n\t\tbreak;\n\n\tcase COND_ELSE:\n\t\tif (last_cond != COND_IF && last_cond != COND_ELIF) {\n\t\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\t\tfile_magwarn(ms, \"syntax error: `else'\");\n\t\t\treturn -1;\n\t\t}\n\t\tlast_cond = COND_NONE;\n\t\tbreak;\n\n\tcase COND_NONE:\n\t\tlast_cond = COND_NONE;\n\t\tbreak;\n\t}\n\n\tms->c.li[cont_level].last_cond = last_cond;\n\treturn 0;\n}\n#endif /* ENABLE_CONDITIONALS */\n\n/*\n * parse one line from magic file, put into magic[index++] if valid\n */\nprivate int\nparse(struct magic_set *ms, struct magic_entry *me, const char *line,\n    size_t lineno, int action)\n{\n#ifdef ENABLE_CONDITIONALS\n\tstatic uint32_t last_cont_level = 0;\n#endif\n\tsize_t i;\n\tstruct magic *m;\n\tconst char *l = line;\n\tchar *t;\n\tint op;\n\tuint32_t cont_level;\n\tint32_t diff;\n\n\tcont_level = 0;\n\n\t/*\n\t * Parse the offset.\n\t */\n\twhile (*l == '>') {\n\t\t++l;\t\t/* step over */\n\t\tcont_level++; \n\t}\n#ifdef ENABLE_CONDITIONALS\n\tif (cont_level == 0 || cont_level > last_cont_level)\n\t\tif (file_check_mem(ms, cont_level) == -1)\n\t\t\treturn -1;\n\tlast_cont_level = cont_level;\n#endif\n\tif (cont_level != 0) {\n\t\tif (me->mp == NULL) {\n\t\t\tfile_magerror(ms, \"No current entry for continuation\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (me->cont_count == 0) {\n\t\t\tfile_magerror(ms, \"Continuations present with 0 count\");\n\t\t\treturn -1;\n\t\t}\n\t\tm = &me->mp[me->cont_count - 1];\n\t\tdiff = (int32_t)cont_level - (int32_t)m->cont_level;\n\t\tif (diff > 1)\n\t\t\tfile_magwarn(ms, \"New continuation level %u is more \"\n\t\t\t    \"than one larger than current level %u\", cont_level,\n\t\t\t    m->cont_level);\n\t\tif (me->cont_count == me->max_count) {\n\t\t\tstruct magic *nm;\n\t\t\tsize_t cnt = me->max_count + ALLOC_CHUNK;\n\t\t\tif ((nm = CAST(struct magic *, realloc(me->mp,\n\t\t\t    sizeof(*nm) * cnt))) == NULL) {\n\t\t\t\tfile_oomem(ms, sizeof(*nm) * cnt);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tme->mp = m = nm;\n\t\t\tme->max_count = CAST(uint32_t, cnt);\n\t\t}\n\t\tm = &me->mp[me->cont_count++];\n\t\t(void)memset(m, 0, sizeof(*m));\n\t\tm->cont_level = cont_level;\n\t} else {\n\t\tstatic const size_t len = sizeof(*m) * ALLOC_CHUNK;\n\t\tif (me->mp != NULL)\n\t\t\treturn 1;\n\t\tif ((m = CAST(struct magic *, malloc(len))) == NULL) {\n\t\t\tfile_oomem(ms, len);\n\t\t\treturn -1;\n\t\t}\n\t\tme->mp = m;\n\t\tme->max_count = ALLOC_CHUNK;\n\t\t(void)memset(m, 0, sizeof(*m));\n\t\tm->factor_op = FILE_FACTOR_OP_NONE;\n\t\tm->cont_level = 0;\n\t\tme->cont_count = 1;\n\t}\n\tm->lineno = CAST(uint32_t, lineno);\n\n\tif (*l == '&') {  /* m->cont_level == 0 checked below. */\n                ++l;            /* step over */\n                m->flag |= OFFADD;\n        }\n\tif (*l == '(') {\n\t\t++l;\t\t/* step over */\n\t\tm->flag |= INDIR;\n\t\tif (m->flag & OFFADD)\n\t\t\tm->flag = (m->flag & ~OFFADD) | INDIROFFADD;\n\n\t\tif (*l == '&') {  /* m->cont_level == 0 checked below */\n\t\t\t++l;            /* step over */\n\t\t\tm->flag |= OFFADD;\n\t\t}\n\t}\n\t/* Indirect offsets are not valid at level 0. */\n\tif (m->cont_level == 0 && (m->flag & (OFFADD | INDIROFFADD)))\n\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\tfile_magwarn(ms, \"relative offset at level 0\");\n\n\t/* get offset, then skip over it */\n\tm->offset = (uint32_t)strtoul(l, &t, 0);\n        if (l == t)\n\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\tfile_magwarn(ms, \"offset `%s' invalid\", l);\n        l = t;\n\n\tif (m->flag & INDIR) {\n\t\tm->in_type = FILE_LONG;\n\t\tm->in_offset = 0;\n\t\t/*\n\t\t * read [.lbs][+-]nnnnn)\n\t\t */\n\t\tif (*l == '.') {\n\t\t\tl++;\n\t\t\tswitch (*l) {\n\t\t\tcase 'l':\n\t\t\t\tm->in_type = FILE_LELONG;\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\tm->in_type = FILE_BELONG;\n\t\t\t\tbreak;\n\t\t\tcase 'm':\n\t\t\t\tm->in_type = FILE_MELONG;\n\t\t\t\tbreak;\n\t\t\tcase 'h':\n\t\t\tcase 's':\n\t\t\t\tm->in_type = FILE_LESHORT;\n\t\t\t\tbreak;\n\t\t\tcase 'H':\n\t\t\tcase 'S':\n\t\t\t\tm->in_type = FILE_BESHORT;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\tcase 'b':\n\t\t\tcase 'C':\n\t\t\tcase 'B':\n\t\t\t\tm->in_type = FILE_BYTE;\n\t\t\t\tbreak;\n\t\t\tcase 'e':\n\t\t\tcase 'f':\n\t\t\tcase 'g':\n\t\t\t\tm->in_type = FILE_LEDOUBLE;\n\t\t\t\tbreak;\n\t\t\tcase 'E':\n\t\t\tcase 'F':\n\t\t\tcase 'G':\n\t\t\t\tm->in_type = FILE_BEDOUBLE;\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\tm->in_type = FILE_LEID3;\n\t\t\t\tbreak;\n\t\t\tcase 'I':\n\t\t\t\tm->in_type = FILE_BEID3;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\t\t\tfile_magwarn(ms,\n\t\t\t\t\t    \"indirect offset type `%c' invalid\",\n\t\t\t\t\t    *l);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tl++;\n\t\t}\n\n\t\tm->in_op = 0;\n\t\tif (*l == '~') {\n\t\t\tm->in_op |= FILE_OPINVERSE;\n\t\t\tl++;\n\t\t}\n\t\tif ((op = get_op(*l)) != -1) {\n\t\t\tm->in_op |= op;\n\t\t\tl++;\n\t\t}\n\t\tif (*l == '(') {\n\t\t\tm->in_op |= FILE_OPINDIRECT;\n\t\t\tl++;\n\t\t}\n\t\tif (isdigit((unsigned char)*l) || *l == '-') {\n\t\t\tm->in_offset = (int32_t)strtol(l, &t, 0);\n\t\t\tif (l == t)\n\t\t\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\t\t\tfile_magwarn(ms,\n\t\t\t\t\t    \"in_offset `%s' invalid\", l);\n\t\t\tl = t;\n\t\t}\n\t\tif (*l++ != ')' || \n\t\t    ((m->in_op & FILE_OPINDIRECT) && *l++ != ')'))\n\t\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\t\tfile_magwarn(ms,\n\t\t\t\t    \"missing ')' in indirect offset\");\n\t}\n\tEATAB;\n\n#ifdef ENABLE_CONDITIONALS\n\tm->cond = get_cond(l, &l);\n\tif (check_cond(ms, m->cond, cont_level) == -1)\n\t\treturn -1;\n\n\tEATAB;\n#endif\n\n\t/*\n\t * Parse the type.\n\t */\n\tif (*l == 'u') {\n\t\t/*\n\t\t * Try it as a keyword type prefixed by \"u\"; match what\n\t\t * follows the \"u\".  If that fails, try it as an SUS\n\t\t * integer type. \n\t\t */\n\t\tm->type = get_type(type_tbl, l + 1, &l);\n\t\tif (m->type == FILE_INVALID) {\n\t\t\t/*\n\t\t\t * Not a keyword type; parse it as an SUS type,\n\t\t\t * 'u' possibly followed by a number or C/S/L.\n\t\t\t */\n\t\t\tm->type = get_standard_integer_type(l, &l);\n\t\t}\n\t\t/* It's unsigned. */\n\t\tif (m->type != FILE_INVALID)\n\t\t\tm->flag |= UNSIGNED;\n\t} else {\n\t\t/*\n\t\t * Try it as a keyword type.  If that fails, try it as\n\t\t * an SUS integer type if it begins with \"d\" or as an\n\t\t * SUS string type if it begins with \"s\".  In any case,\n\t\t * it's not unsigned.\n\t\t */\n\t\tm->type = get_type(type_tbl, l, &l);\n\t\tif (m->type == FILE_INVALID) {\n\t\t\t/*\n\t\t\t * Not a keyword type; parse it as an SUS type,\n\t\t\t * either 'd' possibly followed by a number or\n\t\t\t * C/S/L, or just 's'.\n\t\t\t */\n\t\t\tif (*l == 'd')\n\t\t\t\tm->type = get_standard_integer_type(l, &l);\n\t\t\telse if (*l == 's' && !isalpha((unsigned char)l[1])) {\n\t\t\t\tm->type = FILE_STRING;\n\t\t\t\t++l;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (m->type == FILE_INVALID) {\n\t\t/* Not found - try it as a special keyword. */\n\t\tm->type = get_type(special_tbl, l, &l);\n\t}\n\t\t\t\n\tif (m->type == FILE_INVALID) {\n\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\tfile_magwarn(ms, \"type `%s' invalid\", l);\n\t\treturn -1;\n\t}\n\n\t/* New-style anding: \"0 byte&0x80 =0x80 dynamically linked\" */\n\t/* New and improved: ~ & | ^ + - * / % -- exciting, isn't it? */\n\n\tm->mask_op = 0;\n\tif (*l == '~') {\n\t\tif (!IS_STRING(m->type))\n\t\t\tm->mask_op |= FILE_OPINVERSE;\n\t\telse if (ms->flags & MAGIC_CHECK)\n\t\t\tfile_magwarn(ms, \"'~' invalid for string types\");\n\t\t++l;\n\t}\n\tm->str_range = 0;\n\tm->str_flags = m->type == FILE_PSTRING ? PSTRING_1_LE : 0;\n\tif ((op = get_op(*l)) != -1) {\n\t\tif (!IS_STRING(m->type)) {\n\t\t\tuint64_t val;\n\t\t\t++l;\n\t\t\tm->mask_op |= op;\n\t\t\tval = (uint64_t)strtoull(l, &t, 0);\n\t\t\tl = t;\n\t\t\tm->num_mask = file_signextend(ms, m, val);\n\t\t\teatsize(&l);\n\t\t}\n\t\telse if (op == FILE_OPDIVIDE) {\n\t\t\tint have_range = 0;\n\t\t\twhile (!isspace((unsigned char)*++l)) {\n\t\t\t\tswitch (*l) {\n\t\t\t\tcase '0':  case '1':  case '2':\n\t\t\t\tcase '3':  case '4':  case '5':\n\t\t\t\tcase '6':  case '7':  case '8':\n\t\t\t\tcase '9':\n\t\t\t\t\tif (have_range &&\n\t\t\t\t\t    (ms->flags & MAGIC_CHECK))\n\t\t\t\t\t\tfile_magwarn(ms,\n\t\t\t\t\t\t    \"multiple ranges\");\n\t\t\t\t\thave_range = 1;\n\t\t\t\t\tm->str_range = CAST(uint32_t,\n\t\t\t\t\t    strtoul(l, &t, 0));\n\t\t\t\t\tif (m->str_range == 0)\n\t\t\t\t\t\tfile_magwarn(ms,\n\t\t\t\t\t\t    \"zero range\");\n\t\t\t\t\tl = t - 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHAR_COMPACT_WHITESPACE:\n\t\t\t\t\tm->str_flags |=\n\t\t\t\t\t    STRING_COMPACT_WHITESPACE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHAR_COMPACT_OPTIONAL_WHITESPACE:\n\t\t\t\t\tm->str_flags |=\n\t\t\t\t\t    STRING_COMPACT_OPTIONAL_WHITESPACE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHAR_IGNORE_LOWERCASE:\n\t\t\t\t\tm->str_flags |= STRING_IGNORE_LOWERCASE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHAR_IGNORE_UPPERCASE:\n\t\t\t\t\tm->str_flags |= STRING_IGNORE_UPPERCASE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHAR_REGEX_OFFSET_START:\n\t\t\t\t\tm->str_flags |= REGEX_OFFSET_START;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHAR_BINTEST:\n\t\t\t\t\tm->str_flags |= STRING_BINTEST;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHAR_TEXTTEST:\n\t\t\t\t\tm->str_flags |= STRING_TEXTTEST;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHAR_TRIM:\n\t\t\t\t\tm->str_flags |= STRING_TRIM;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHAR_PSTRING_1_LE:\n\t\t\t\t\tif (m->type != FILE_PSTRING)\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tm->str_flags = (m->str_flags & ~PSTRING_LEN) | PSTRING_1_LE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHAR_PSTRING_2_BE:\n\t\t\t\t\tif (m->type != FILE_PSTRING)\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tm->str_flags = (m->str_flags & ~PSTRING_LEN) | PSTRING_2_BE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHAR_PSTRING_2_LE:\n\t\t\t\t\tif (m->type != FILE_PSTRING)\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tm->str_flags = (m->str_flags & ~PSTRING_LEN) | PSTRING_2_LE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHAR_PSTRING_4_BE:\n\t\t\t\t\tif (m->type != FILE_PSTRING)\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tm->str_flags = (m->str_flags & ~PSTRING_LEN) | PSTRING_4_BE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHAR_PSTRING_4_LE:\n\t\t\t\t\tswitch (m->type) {\n\t\t\t\t\tcase FILE_PSTRING:\n\t\t\t\t\tcase FILE_REGEX:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\t}\n\t\t\t\t\tm->str_flags = (m->str_flags & ~PSTRING_LEN) | PSTRING_4_LE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHAR_PSTRING_LENGTH_INCLUDES_ITSELF:\n\t\t\t\t\tif (m->type != FILE_PSTRING)\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tm->str_flags |= PSTRING_LENGTH_INCLUDES_ITSELF;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\tbad:\n\t\t\t\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\t\t\t\tfile_magwarn(ms,\n\t\t\t\t\t\t    \"string extension `%c' \"\n\t\t\t\t\t\t    \"invalid\", *l);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\t/* allow multiple '/' for readability */\n\t\t\t\tif (l[1] == '/' &&\n\t\t\t\t    !isspace((unsigned char)l[2]))\n\t\t\t\t\tl++;\n\t\t\t}\n\t\t\tif (string_modifier_check(ms, m) == -1)\n\t\t\t\treturn -1;\n\t\t}\n\t\telse {\n\t\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\t\tfile_magwarn(ms, \"invalid string op: %c\", *t);\n\t\t\treturn -1;\n\t\t}\n\t}\n\t/*\n\t * We used to set mask to all 1's here, instead let's just not do\n\t * anything if mask = 0 (unless you have a better idea)\n\t */\n\tEATAB;\n  \n\tswitch (*l) {\n\tcase '>':\n\tcase '<':\n  \t\tm->reln = *l;\n  \t\t++l;\n\t\tif (*l == '=') {\n\t\t\tif (ms->flags & MAGIC_CHECK) {\n\t\t\t\tfile_magwarn(ms, \"%c= not supported\",\n\t\t\t\t    m->reln);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t   ++l;\n\t\t}\n\t\tbreak;\n\t/* Old-style anding: \"0 byte &0x80 dynamically linked\" */\n\tcase '&':\n\tcase '^':\n\tcase '=':\n  \t\tm->reln = *l;\n  \t\t++l;\n\t\tif (*l == '=') {\n\t\t   /* HP compat: ignore &= etc. */\n\t\t   ++l;\n\t\t}\n\t\tbreak;\n\tcase '!':\n\t\tm->reln = *l;\n\t\t++l;\n\t\tbreak;\n\tdefault:\n  \t\tm->reln = '=';\t/* the default relation */\n\t\tif (*l == 'x' && ((isascii((unsigned char)l[1]) && \n\t\t    isspace((unsigned char)l[1])) || !l[1])) {\n\t\t\tm->reln = *l;\n\t\t\t++l;\n\t\t}\n\t\tbreak;\n\t}\n\t/*\n\t * Grab the value part, except for an 'x' reln.\n\t */\n\tif (m->reln != 'x' && getvalue(ms, m, &l, action))\n\t\treturn -1;\n\n\t/*\n\t * TODO finish this macro and start using it!\n\t * #define offsetcheck {if (offset > HOWMANY-1) \n\t *\tmagwarn(\"offset too big\"); }\n\t */\n\n\t/*\n\t * Now get last part - the description\n\t */\n\tEATAB;\n\tif (l[0] == '\\b') {\n\t\t++l;\n\t\tm->flag |= NOSPACE;\n\t} else if ((l[0] == '\\\\') && (l[1] == 'b')) {\n\t\t++l;\n\t\t++l;\n\t\tm->flag |= NOSPACE;\n\t}\n\tfor (i = 0; (m->desc[i++] = *l++) != '\\0' && i < sizeof(m->desc); )\n\t\tcontinue;\n\tif (i == sizeof(m->desc)) {\n\t\tm->desc[sizeof(m->desc) - 1] = '\\0';\n\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\tfile_magwarn(ms, \"description `%s' truncated\", m->desc);\n\t}\n\n        /*\n\t * We only do this check while compiling, or if any of the magic\n\t * files were not compiled.\n         */\n        if (ms->flags & MAGIC_CHECK) {\n\t\tif (check_format(ms, m) == -1)\n\t\t\treturn -1;\n\t}\n#ifndef COMPILE_ONLY\n\tif (action == FILE_CHECK) {\n\t\tfile_mdump(m);\n\t}\n#endif\n\tm->mimetype[0] = '\\0';\t\t/* initialise MIME type to none */\n\treturn 0;\n}\n\n/*\n * parse a STRENGTH annotation line from magic file, put into magic[index - 1]\n * if valid\n */\nprivate int\nparse_strength(struct magic_set *ms, struct magic_entry *me, const char *line)\n{\n\tconst char *l = line;\n\tchar *el;\n\tunsigned long factor;\n\tstruct magic *m = &me->mp[0];\n\n\tif (m->factor_op != FILE_FACTOR_OP_NONE) {\n\t\tfile_magwarn(ms,\n\t\t    \"Current entry already has a strength type: %c %d\",\n\t\t    m->factor_op, m->factor);\n\t\treturn -1;\n\t}\n\tif (m->type == FILE_NAME) {\n\t\tfile_magwarn(ms, \"%s: Strength setting is not supported in \"\n\t\t    \"\\\"name\\\" magic entries\", m->value.s);\n\t\treturn -1;\n\t}\n\tEATAB;\n\tswitch (*l) {\n\tcase FILE_FACTOR_OP_NONE:\n\tcase FILE_FACTOR_OP_PLUS:\n\tcase FILE_FACTOR_OP_MINUS:\n\tcase FILE_FACTOR_OP_TIMES:\n\tcase FILE_FACTOR_OP_DIV:\n\t\tm->factor_op = *l++;\n\t\tbreak;\n\tdefault:\n\t\tfile_magwarn(ms, \"Unknown factor op `%c'\", *l);\n\t\treturn -1;\n\t}\n\tEATAB;\n\tfactor = strtoul(l, &el, 0);\n\tif (factor > 255) {\n\t\tfile_magwarn(ms, \"Too large factor `%lu'\", factor);\n\t\tgoto out;\n\t}\n\tif (*el && !isspace((unsigned char)*el)) {\n\t\tfile_magwarn(ms, \"Bad factor `%s'\", l);\n\t\tgoto out;\n\t}\n\tm->factor = (uint8_t)factor;\n\tif (m->factor == 0 && m->factor_op == FILE_FACTOR_OP_DIV) {\n\t\tfile_magwarn(ms, \"Cannot have factor op `%c' and factor %u\",\n\t\t    m->factor_op, m->factor);\n\t\tgoto out;\n\t}\n\treturn 0;\nout:\n\tm->factor_op = FILE_FACTOR_OP_NONE;\n\tm->factor = 0;\n\treturn -1;\n}\n\nprivate int\nparse_extra(struct magic_set *ms, struct magic_entry *me, const char *line,\n    off_t off, size_t len, const char *name, int nt)\n{\n\tsize_t i;\n\tconst char *l = line;\n\tstruct magic *m = &me->mp[me->cont_count == 0 ? 0 : me->cont_count - 1];\n\tchar *buf = (char *)m + off;\n\n\tif (buf[0] != '\\0') {\n\t\tlen = nt ? strlen(buf) : len;\n\t\tfile_magwarn(ms, \"Current entry already has a %s type \"\n\t\t    \"`%.*s', new type `%s'\", name, (int)len, buf, l);\n\t\treturn -1;\n\t}\t\n\n\tif (*m->desc == '\\0') {\n\t\tfile_magwarn(ms, \"Current entry does not yet have a \"\n\t\t    \"description for adding a %s type\", name);\n\t\treturn -1;\n\t}\n\n\tEATAB;\n\tfor (i = 0; *l && ((isascii((unsigned char)*l) &&\n\t    isalnum((unsigned char)*l)) || strchr(\"-+/.\", *l)) &&\n\t    i < len; buf[i++] = *l++)\n\t\tcontinue;\n\n\tif (i == len && *l) {\n\t\tif (nt)\n\t\t\tbuf[len - 1] = '\\0';\n\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\tfile_magwarn(ms, \"%s type `%s' truncated %\"\n\t\t\t    SIZE_T_FORMAT \"u\", name, line, i);\n\t} else {\n\t\tif (nt)\n\t\t\tbuf[i] = '\\0';\n\t}\n\n\tif (i > 0)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}\n\n/*\n * Parse an Apple CREATOR/TYPE annotation from magic file and put it into\n * magic[index - 1]\n */\nprivate int\nparse_apple(struct magic_set *ms, struct magic_entry *me, const char *line)\n{\n\tstruct magic *m = &me->mp[0];\n\n\treturn parse_extra(ms, me, line, offsetof(struct magic, apple),\n\t    sizeof(m->apple), \"APPLE\", 0);\n}\n\n/*\n * parse a MIME annotation line from magic file, put into magic[index - 1]\n * if valid\n */\nprivate int\nparse_mime(struct magic_set *ms, struct magic_entry *me, const char *line)\n{\n\tstruct magic *m = &me->mp[0];\n\n\treturn parse_extra(ms, me, line, offsetof(struct magic, mimetype),\n\t    sizeof(m->mimetype), \"MIME\", 1);\n}\n\nprivate int\ncheck_format_type(const char *ptr, int type)\n{\n\tint quad = 0, h;\n\tif (*ptr == '\\0') {\n\t\t/* Missing format string; bad */\n\t\treturn -1;\n\t}\n\n\tswitch (file_formats[type]) {\n\tcase FILE_FMT_QUAD:\n\t\tquad = 1;\n\t\t/*FALLTHROUGH*/\n\tcase FILE_FMT_NUM:\n\t\tif (quad == 0) {\n\t\t\tswitch (type) {\n\t\t\tcase FILE_BYTE:\n\t\t\t\th = 2;\n\t\t\t\tbreak;\n\t\t\tcase FILE_SHORT:\n\t\t\tcase FILE_BESHORT:\n\t\t\tcase FILE_LESHORT:\n\t\t\t\th = 1;\n\t\t\t\tbreak;\n\t\t\tcase FILE_LONG:\n\t\t\tcase FILE_BELONG:\n\t\t\tcase FILE_LELONG:\n\t\t\tcase FILE_MELONG:\n\t\t\tcase FILE_LEID3:\n\t\t\tcase FILE_BEID3:\n\t\t\tcase FILE_INDIRECT:\n\t\t\t\th = 0;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tabort();\n\t\t\t}\n\t\t} else\n\t\t\th = 0;\n\t\tif (*ptr == '-')\n\t\t\tptr++;\n\t\tif (*ptr == '.')\n\t\t\tptr++;\n\t\twhile (isdigit((unsigned char)*ptr)) ptr++;\n\t\tif (*ptr == '.')\n\t\t\tptr++;\n\t\twhile (isdigit((unsigned char)*ptr)) ptr++;\n\t\tif (quad) {\n\t\t\tif (*ptr++ != 'l')\n\t\t\t\treturn -1;\n\t\t\tif (*ptr++ != 'l')\n\t\t\t\treturn -1;\n\t\t}\n\t\n\t\tswitch (*ptr++) {\n#ifdef STRICT_FORMAT \t/* \"long\" formats are int formats for us */\n\t\t/* so don't accept the 'l' modifier */\n\t\tcase 'l':\n\t\t\tswitch (*ptr++) {\n\t\t\tcase 'i':\n\t\t\tcase 'd':\n\t\t\tcase 'u':\n\t\t\tcase 'o':\n\t\t\tcase 'x':\n\t\t\tcase 'X':\n\t\t\t\treturn h != 0 ? -1 : 0;\n\t\t\tdefault:\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\n\t\t/*\n\t\t * Don't accept h and hh modifiers. They make writing\n\t\t * magic entries more complicated, for very little benefit\n\t\t */\n\t\tcase 'h':\n\t\t\tif (h-- <= 0)\n\t\t\t\treturn -1;\n\t\t\tswitch (*ptr++) {\n\t\t\tcase 'h':\n\t\t\t\tif (h-- <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t\tswitch (*ptr++) {\n\t\t\t\tcase 'i':\n\t\t\t\tcase 'd':\n\t\t\t\tcase 'u':\n\t\t\t\tcase 'o':\n\t\t\t\tcase 'x':\n\t\t\t\tcase 'X':\n\t\t\t\t\treturn 0;\n\t\t\t\tdefault:\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\tcase 'i':\n\t\t\tcase 'd':\n\t\t\tcase 'u':\n\t\t\tcase 'o':\n\t\t\tcase 'x':\n\t\t\tcase 'X':\n\t\t\t\treturn h != 0 ? -1 : 0;\n\t\t\tdefault:\n\t\t\t\treturn -1;\n\t\t\t}\n#endif\n\t\tcase 'c':\n\t\t\treturn h != 2 ? -1 : 0;\n\t\tcase 'i':\n\t\tcase 'd':\n\t\tcase 'u':\n\t\tcase 'o':\n\t\tcase 'x':\n\t\tcase 'X':\n#ifdef STRICT_FORMAT\n\t\t\treturn h != 0 ? -1 : 0;\n#else\n\t\t\treturn 0;\n#endif\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t\t\n\tcase FILE_FMT_FLOAT:\n\tcase FILE_FMT_DOUBLE:\n\t\tif (*ptr == '-')\n\t\t\tptr++;\n\t\tif (*ptr == '.')\n\t\t\tptr++;\n\t\twhile (isdigit((unsigned char)*ptr)) ptr++;\n\t\tif (*ptr == '.')\n\t\t\tptr++;\n\t\twhile (isdigit((unsigned char)*ptr)) ptr++;\n\t\n\t\tswitch (*ptr++) {\n\t\tcase 'e':\n\t\tcase 'E':\n\t\tcase 'f':\n\t\tcase 'F':\n\t\tcase 'g':\n\t\tcase 'G':\n\t\t\treturn 0;\n\t\t\t\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t\t\n\n\tcase FILE_FMT_STR:\n\t\tif (*ptr == '-')\n\t\t\tptr++;\n\t\twhile (isdigit((unsigned char )*ptr))\n\t\t\tptr++;\n\t\tif (*ptr == '.') {\n\t\t\tptr++;\n\t\t\twhile (isdigit((unsigned char )*ptr))\n\t\t\t\tptr++;\n\t\t}\n\t\t\n\t\tswitch (*ptr++) {\n\t\tcase 's':\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t\t\n\tdefault:\n\t\t/* internal error */\n\t\tabort();\n\t}\n\t/*NOTREACHED*/\n\treturn -1;\n}\n\t\n/*\n * Check that the optional printf format in description matches\n * the type of the magic.\n */\nprivate int\ncheck_format(struct magic_set *ms, struct magic *m)\n{\n\tchar *ptr;\n\n\tfor (ptr = m->desc; *ptr; ptr++)\n\t\tif (*ptr == '%')\n\t\t\tbreak;\n\tif (*ptr == '\\0') {\n\t\t/* No format string; ok */\n\t\treturn 1;\n\t}\n\n\tassert(file_nformats == file_nnames);\n\n\tif (m->type >= file_nformats) {\n\t\tfile_magwarn(ms, \"Internal error inconsistency between \"\n\t\t    \"m->type and format strings\");\t\t\n\t\treturn -1;\n\t}\n\tif (file_formats[m->type] == FILE_FMT_NONE) {\n\t\tfile_magwarn(ms, \"No format string for `%s' with description \"\n\t\t    \"`%s'\", m->desc, file_names[m->type]);\n\t\treturn -1;\n\t}\n\n\tptr++;\n\tif (check_format_type(ptr, m->type) == -1) {\n\t\t/*\n\t\t * TODO: this error message is unhelpful if the format\n\t\t * string is not one character long\n\t\t */\n\t\tfile_magwarn(ms, \"Printf format `%c' is not valid for type \"\n\t\t    \"`%s' in description `%s'\", *ptr ? *ptr : '?',\n\t\t    file_names[m->type], m->desc);\n\t\treturn -1;\n\t}\n\t\n\tfor (; *ptr; ptr++) {\n\t\tif (*ptr == '%') {\n\t\t\tfile_magwarn(ms,\n\t\t\t    \"Too many format strings (should have at most one) \"\n\t\t\t    \"for `%s' with description `%s'\",\n\t\t\t    file_names[m->type], m->desc);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/* \n * Read a numeric value from a pointer, into the value union of a magic \n * pointer, according to the magic type.  Update the string pointer to point \n * just after the number read.  Return 0 for success, non-zero for failure.\n */\nprivate int\ngetvalue(struct magic_set *ms, struct magic *m, const char **p, int action)\n{\n\tswitch (m->type) {\n\tcase FILE_BESTRING16:\n\tcase FILE_LESTRING16:\n\tcase FILE_STRING:\n\tcase FILE_PSTRING:\n\tcase FILE_REGEX:\n\tcase FILE_SEARCH:\n\tcase FILE_NAME:\n\tcase FILE_USE:\n\t\t*p = getstr(ms, m, *p, action == FILE_COMPILE);\n\t\tif (*p == NULL) {\n\t\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\t\tfile_magwarn(ms, \"cannot get string from `%s'\",\n\t\t\t\t    m->value.s);\n\t\t\treturn -1;\n\t\t}\n\t\tif (m->type == FILE_REGEX) {\n\t\t\tfile_regex_t rx;\n\t\t\tint rc = file_regcomp(&rx, m->value.s, REG_EXTENDED);\n\t\t\tif (rc) {\n\t\t\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\t\t\tfile_regerror(&rx, rc, ms);\n\t\t\t}\n\t\t\tfile_regfree(&rx);\n\t\t\treturn rc ? -1 : 0;\n\t\t}\n\t\treturn 0;\n\tcase FILE_FLOAT:\n\tcase FILE_BEFLOAT:\n\tcase FILE_LEFLOAT:\n\t\tif (m->reln != 'x') {\n\t\t\tchar *ep;\n#ifdef HAVE_STRTOF\n\t\t\tm->value.f = strtof(*p, &ep);\n#else\n\t\t\tm->value.f = (float)strtod(*p, &ep);\n#endif\n\t\t\t*p = ep;\n\t\t}\n\t\treturn 0;\n\tcase FILE_DOUBLE:\n\tcase FILE_BEDOUBLE:\n\tcase FILE_LEDOUBLE:\n\t\tif (m->reln != 'x') {\n\t\t\tchar *ep;\n\t\t\tm->value.d = strtod(*p, &ep);\n\t\t\t*p = ep;\n\t\t}\n\t\treturn 0;\n\tdefault:\n\t\tif (m->reln != 'x') {\n\t\t\tchar *ep;\n\t\t\tm->value.q = file_signextend(ms, m,\n\t\t\t    (uint64_t)strtoull(*p, &ep, 0));\n\t\t\t*p = ep;\n\t\t\teatsize(p);\n\t\t}\n\t\treturn 0;\n\t}\n}\n\n/*\n * Convert a string containing C character escapes.  Stop at an unescaped\n * space or tab.\n * Copy the converted version to \"m->value.s\", and the length in m->vallen.\n * Return updated scan pointer as function result. Warn if set.\n */\nprivate const char *\ngetstr(struct magic_set *ms, struct magic *m, const char *s, int warn)\n{\n\tconst char *origs = s;\n\tchar\t*p = m->value.s;\n\tsize_t  plen = sizeof(m->value.s);\n\tchar \t*origp = p;\n\tchar\t*pmax = p + plen - 1;\n\tint\tc;\n\tint\tval;\n\n\twhile ((c = *s++) != '\\0') {\n\t\tif (isspace((unsigned char) c))\n\t\t\tbreak;\n\t\tif (p >= pmax) {\n\t\t\tfile_error(ms, 0, \"string too long: `%s'\", origs);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (c == '\\\\') {\n\t\t\tswitch(c = *s++) {\n\n\t\t\tcase '\\0':\n\t\t\t\tif (warn)\n\t\t\t\t\tfile_magwarn(ms, \"incomplete escape\");\n\t\t\t\tgoto out;\n\n\t\t\tcase '\\t':\n\t\t\t\tif (warn) {\n\t\t\t\t\tfile_magwarn(ms,\n\t\t\t\t\t    \"escaped tab found, use \\\\t instead\");\n\t\t\t\t\twarn = 0;\t/* already did */\n\t\t\t\t}\n\t\t\t\t/*FALLTHROUGH*/\n\t\t\tdefault:\n\t\t\t\tif (warn) {\n\t\t\t\t\tif (isprint((unsigned char)c)) {\n\t\t\t\t\t\t/* Allow escaping of \n\t\t\t\t\t\t * ``relations'' */\n\t\t\t\t\t\tif (strchr(\"<>&^=!\", c) == NULL\n\t\t\t\t\t\t    && (m->type != FILE_REGEX ||\n\t\t\t\t\t\t    strchr(\"[]().*?^$|{}\", c)\n\t\t\t\t\t\t    == NULL)) {\n\t\t\t\t\t\t\tfile_magwarn(ms, \"no \"\n\t\t\t\t\t\t\t    \"need to escape \"\n\t\t\t\t\t\t\t    \"`%c'\", c);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfile_magwarn(ms,\n\t\t\t\t\t\t    \"unknown escape sequence: \"\n\t\t\t\t\t\t    \"\\\\%03o\", c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*FALLTHROUGH*/\n\t\t\t/* space, perhaps force people to use \\040? */\n\t\t\tcase ' ':\n#if 0\n\t\t\t/*\n\t\t\t * Other things people escape, but shouldn't need to,\n\t\t\t * so we disallow them\n\t\t\t */\n\t\t\tcase '\\'':\n\t\t\tcase '\"':\n\t\t\tcase '?':\n#endif\n\t\t\t/* Relations */\n\t\t\tcase '>':\n\t\t\tcase '<':\n\t\t\tcase '&':\n\t\t\tcase '^':\n\t\t\tcase '=':\n\t\t\tcase '!':\n\t\t\t/* and baskslash itself */\n\t\t\tcase '\\\\':\n\t\t\t\t*p++ = (char) c;\n\t\t\t\tbreak;\n\n\t\t\tcase 'a':\n\t\t\t\t*p++ = '\\a';\n\t\t\t\tbreak;\n\n\t\t\tcase 'b':\n\t\t\t\t*p++ = '\\b';\n\t\t\t\tbreak;\n\n\t\t\tcase 'f':\n\t\t\t\t*p++ = '\\f';\n\t\t\t\tbreak;\n\n\t\t\tcase 'n':\n\t\t\t\t*p++ = '\\n';\n\t\t\t\tbreak;\n\n\t\t\tcase 'r':\n\t\t\t\t*p++ = '\\r';\n\t\t\t\tbreak;\n\n\t\t\tcase 't':\n\t\t\t\t*p++ = '\\t';\n\t\t\t\tbreak;\n\n\t\t\tcase 'v':\n\t\t\t\t*p++ = '\\v';\n\t\t\t\tbreak;\n\n\t\t\t/* \\ and up to 3 octal digits */\n\t\t\tcase '0':\n\t\t\tcase '1':\n\t\t\tcase '2':\n\t\t\tcase '3':\n\t\t\tcase '4':\n\t\t\tcase '5':\n\t\t\tcase '6':\n\t\t\tcase '7':\n\t\t\t\tval = c - '0';\n\t\t\t\tc = *s++;  /* try for 2 */\n\t\t\t\tif (c >= '0' && c <= '7') {\n\t\t\t\t\tval = (val << 3) | (c - '0');\n\t\t\t\t\tc = *s++;  /* try for 3 */\n\t\t\t\t\tif (c >= '0' && c <= '7')\n\t\t\t\t\t\tval = (val << 3) | (c-'0');\n\t\t\t\t\telse\n\t\t\t\t\t\t--s;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\t--s;\n\t\t\t\t*p++ = (char)val;\n\t\t\t\tbreak;\n\n\t\t\t/* \\x and up to 2 hex digits */\n\t\t\tcase 'x':\n\t\t\t\tval = 'x';\t/* Default if no digits */\n\t\t\t\tc = hextoint(*s++);\t/* Get next char */\n\t\t\t\tif (c >= 0) {\n\t\t\t\t\tval = c;\n\t\t\t\t\tc = hextoint(*s++);\n\t\t\t\t\tif (c >= 0)\n\t\t\t\t\t\tval = (val << 4) + c;\n\t\t\t\t\telse\n\t\t\t\t\t\t--s;\n\t\t\t\t} else\n\t\t\t\t\t--s;\n\t\t\t\t*p++ = (char)val;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\t*p++ = (char)c;\n\t}\nout:\n\t*p = '\\0';\n\tm->vallen = CAST(unsigned char, (p - origp));\n\tif (m->type == FILE_PSTRING)\n\t\tm->vallen += (unsigned char)file_pstring_length_size(m);\n\treturn s;\n}\n\n\n/* Single hex char to int; -1 if not a hex char. */\nprivate int\nhextoint(int c)\n{\n\tif (!isascii((unsigned char) c))\n\t\treturn -1;\n\tif (isdigit((unsigned char) c))\n\t\treturn c - '0';\n\tif ((c >= 'a') && (c <= 'f'))\n\t\treturn c + 10 - 'a';\n\tif (( c>= 'A') && (c <= 'F'))\n\t\treturn c + 10 - 'A';\n\treturn -1;\n}\n\n\n/*\n * Print a string containing C character escapes.\n */\nprotected void\nfile_showstr(FILE *fp, const char *s, size_t len)\n{\n\tchar\tc;\n\n\tfor (;;) {\n\t\tif (len == ~0U) {\n\t\t\tc = *s++;\n\t\t\tif (c == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t\telse  {\n\t\t\tif (len-- == 0)\n\t\t\t\tbreak;\n\t\t\tc = *s++;\n\t\t}\n\t\tif (c >= 040 && c <= 0176)\t/* TODO isprint && !iscntrl */\n\t\t\t(void) fputc(c, fp);\n\t\telse {\n\t\t\t(void) fputc('\\\\', fp);\n\t\t\tswitch (c) {\n\t\t\tcase '\\a':\n\t\t\t\t(void) fputc('a', fp);\n\t\t\t\tbreak;\n\n\t\t\tcase '\\b':\n\t\t\t\t(void) fputc('b', fp);\n\t\t\t\tbreak;\n\n\t\t\tcase '\\f':\n\t\t\t\t(void) fputc('f', fp);\n\t\t\t\tbreak;\n\n\t\t\tcase '\\n':\n\t\t\t\t(void) fputc('n', fp);\n\t\t\t\tbreak;\n\n\t\t\tcase '\\r':\n\t\t\t\t(void) fputc('r', fp);\n\t\t\t\tbreak;\n\n\t\t\tcase '\\t':\n\t\t\t\t(void) fputc('t', fp);\n\t\t\t\tbreak;\n\n\t\t\tcase '\\v':\n\t\t\t\t(void) fputc('v', fp);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t(void) fprintf(fp, \"%.3o\", c & 0377);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*\n * eatsize(): Eat the size spec from a number [eg. 10UL]\n */\nprivate void\neatsize(const char **p)\n{\n\tconst char *l = *p;\n\n\tif (LOWCASE(*l) == 'u') \n\t\tl++;\n\n\tswitch (LOWCASE(*l)) {\n\tcase 'l':    /* long */\n\tcase 's':    /* short */\n\tcase 'h':    /* short */\n\tcase 'b':    /* char/byte */\n\tcase 'c':    /* char/byte */\n\t\tl++;\n\t\t/*FALLTHROUGH*/\n\tdefault:\n\t\tbreak;\n\t}\n\n\t*p = l;\n}\n\n/*\n * handle a compiled file.\n */\n\nprivate struct magic_map *\napprentice_map(struct magic_set *ms, const char *fn)\n{\n\tint fd;\n\tstruct stat st;\n\tuint32_t *ptr;\n\tuint32_t version, entries, nentries;\n\tint needsbyteswap;\n\tchar *dbname = NULL;\n\tstruct magic_map *map;\n\tsize_t i;\n\n\tfd = -1;\n\tif ((map = CAST(struct magic_map *, calloc(1, sizeof(*map)))) == NULL) {\n\t\tfile_oomem(ms, sizeof(*map));\n\t\tgoto error;\n\t}\n\n\tdbname = mkdbname(ms, fn, 0);\n\tif (dbname == NULL)\n\t\tgoto error;\n\n\tif ((fd = open(dbname, O_RDONLY|O_BINARY)) == -1)\n\t\tgoto error;\n\n\tif (fstat(fd, &st) == -1) {\n\t\tfile_error(ms, errno, \"cannot stat `%s'\", dbname);\n\t\tgoto error;\n\t}\n\tif (st.st_size < 8 || st.st_size > MAXMAGIC_SIZE) {\n\t\tfile_error(ms, 0, \"file `%s' is too %s\", dbname,\n\t\t    st.st_size < 8 ? \"small\" : \"large\");\n\t\tgoto error;\n\t}\n\n\tmap->len = (size_t)st.st_size;\n#ifdef QUICK\n\tif ((map->p = mmap(0, (size_t)st.st_size, PROT_READ|PROT_WRITE,\n\t    MAP_PRIVATE|MAP_FILE, fd, (off_t)0)) == MAP_FAILED) {\n\t\tfile_error(ms, errno, \"cannot map `%s'\", dbname);\n\t\tgoto error;\n\t}\n#else\n\tif ((map->p = CAST(void *, malloc(map->len))) == NULL) {\n\t\tfile_oomem(ms, map->len);\n\t\tgoto error;\n\t}\n\tif (read(fd, map->p, map->len) != (ssize_t)map->len) {\n\t\tfile_badread(ms);\n\t\tgoto error;\n\t}\n\tmap->len = 0;\n#define RET\t1\n#endif\n\t(void)close(fd);\n\tfd = -1;\n\tptr = CAST(uint32_t *, map->p);\n\tif (*ptr != MAGICNO) {\n\t\tif (swap4(*ptr) != MAGICNO) {\n\t\t\tfile_error(ms, 0, \"bad magic in `%s'\", dbname);\n\t\t\tgoto error;\n\t\t}\n\t\tneedsbyteswap = 1;\n\t} else\n\t\tneedsbyteswap = 0;\n\tif (needsbyteswap)\n\t\tversion = swap4(ptr[1]);\n\telse\n\t\tversion = ptr[1];\n\tif (version != VERSIONNO) {\n\t\tfile_error(ms, 0, \"File %s supports only version %d magic \"\n\t\t    \"files. `%s' is version %d\", VERSION,\n\t\t    VERSIONNO, dbname, version);\n\t\tgoto error;\n\t}\n\tentries = (uint32_t)(st.st_size / sizeof(struct magic));\n\tif ((off_t)(entries * sizeof(struct magic)) != st.st_size) {\n\t\tfile_error(ms, 0, \"Size of `%s' %\" INT64_T_FORMAT \"u is not \"\n\t\t    \"a multiple of %\" SIZE_T_FORMAT \"u\",\n\t\t    dbname, (unsigned long long)st.st_size,\n\t\t    sizeof(struct magic));\n\t\tgoto error;\n\t}\n\tmap->magic[0] = CAST(struct magic *, map->p) + 1;\n\tnentries = 0;\n\tfor (i = 0; i < MAGIC_SETS; i++) {\n\t\tif (needsbyteswap)\n\t\t\tmap->nmagic[i] = swap4(ptr[i + 2]);\n\t\telse\n\t\t\tmap->nmagic[i] = ptr[i + 2];\n\t\tif (i != MAGIC_SETS - 1)\n\t\t\tmap->magic[i + 1] = map->magic[i] + map->nmagic[i];\n\t\tnentries += map->nmagic[i];\n\t}\n\tif (entries != nentries + 1) {\n\t\tfile_error(ms, 0, \"Inconsistent entries in `%s' %u != %u\",\n\t\t    dbname, entries, nentries + 1);\n\t\tgoto error;\n\t}\n\tif (needsbyteswap)\n\t\tfor (i = 0; i < MAGIC_SETS; i++)\n\t\t\tbyteswap(map->magic[i], map->nmagic[i]);\n\tfree(dbname);\n\treturn map;\n\nerror:\n\tif (fd != -1)\n\t\t(void)close(fd);\n\tapprentice_unmap(map);\n\tfree(dbname);\n\treturn NULL;\n}\n\n/*\n * handle an mmaped file.\n */\nprivate int\napprentice_compile(struct magic_set *ms, struct magic_map *map, const char *fn)\n{\n\tstatic const size_t nm = sizeof(*map->nmagic) * MAGIC_SETS;\n\tstatic const size_t m = sizeof(**map->magic);\n\tint fd = -1;\n\tsize_t len;\n\tchar *dbname;\n\tint rv = -1;\n\tuint32_t i;\n\tunion {\n\t\tstruct magic m;\n\t\tuint32_t h[2 + MAGIC_SETS];\n\t} hdr;\n\n\tdbname = mkdbname(ms, fn, 1);\n\n\tif (dbname == NULL) \n\t\tgoto out;\n\n\tif ((fd = open(dbname, O_WRONLY|O_CREAT|O_TRUNC|O_BINARY, 0644)) == -1) \n\t{\n\t\tfile_error(ms, errno, \"cannot open `%s'\", dbname);\n\t\tgoto out;\n\t}\n\tmemset(&hdr, 0, sizeof(hdr));\n\thdr.h[0] = MAGICNO;\n\thdr.h[1] = VERSIONNO;\n\tmemcpy(hdr.h + 2, map->nmagic, nm);\n\n\tif (write(fd, &hdr, sizeof(hdr)) != (ssize_t)sizeof(hdr)) {\n\t\tfile_error(ms, errno, \"error writing `%s'\", dbname);\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < MAGIC_SETS; i++) {\n\t\tlen = m * map->nmagic[i];\n\t\tif (write(fd, map->magic[i], len) != (ssize_t)len) {\n\t\t\tfile_error(ms, errno, \"error writing `%s'\", dbname);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (fd != -1)\n\t\t(void)close(fd);\n\trv = 0;\nout:\n\tfree(dbname);\n\treturn rv;\n}\n\nprivate const char ext[] = \".mgc\";\n/*\n * make a dbname\n */\nprivate char *\nmkdbname(struct magic_set *ms, const char *fn, int strip)\n{\n\tconst char *p, *q;\n\tchar *buf;\n\n\tif (strip) {\n\t\tif ((p = strrchr(fn, '/')) != NULL)\n\t\t\tfn = ++p;\n\t}\n\n\tfor (q = fn; *q; q++)\n\t\tcontinue;\n\t/* Look for .mgc */\n\tfor (p = ext + sizeof(ext) - 1; p >= ext && q >= fn; p--, q--)\n\t\tif (*p != *q)\n\t\t\tbreak;\n\n\t/* Did not find .mgc, restore q */\n\tif (p >= ext)\n\t\twhile (*q)\n\t\t\tq++;\n\n\tq++;\n\t/* Compatibility with old code that looked in .mime */\n\tif (ms->flags & MAGIC_MIME) {\n\t\tif (asprintf(&buf, \"%.*s.mime%s\", (int)(q - fn), fn, ext) < 0)\n\t\t\treturn NULL;\n\t\tif (access(buf, R_OK) != -1) {\n\t\t\tms->flags &= MAGIC_MIME_TYPE;\n\t\t\treturn buf;\n\t\t}\n\t\tfree(buf);\n\t}\n\tif (asprintf(&buf, \"%.*s%s\", (int)(q - fn), fn, ext) < 0)\n\t\treturn NULL;\n\n\t/* Compatibility with old code that looked in .mime */\n\tif (strstr(p, \".mime\") != NULL)\n\t\tms->flags &= MAGIC_MIME_TYPE;\n\treturn buf;\n}\n\n/*\n * Byteswap an mmap'ed file if needed\n */\nprivate void\nbyteswap(struct magic *magic, uint32_t nmagic)\n{\n\tuint32_t i;\n\tfor (i = 0; i < nmagic; i++)\n\t\tbs1(&magic[i]);\n}\n\n/*\n * swap a short\n */\nprivate uint16_t\nswap2(uint16_t sv)\n{\n\tuint16_t rv;\n\tuint8_t *s = (uint8_t *)(void *)&sv; \n\tuint8_t *d = (uint8_t *)(void *)&rv; \n\td[0] = s[1];\n\td[1] = s[0];\n\treturn rv;\n}\n\n/*\n * swap an int\n */\nprivate uint32_t\nswap4(uint32_t sv)\n{\n\tuint32_t rv;\n\tuint8_t *s = (uint8_t *)(void *)&sv; \n\tuint8_t *d = (uint8_t *)(void *)&rv; \n\td[0] = s[3];\n\td[1] = s[2];\n\td[2] = s[1];\n\td[3] = s[0];\n\treturn rv;\n}\n\n/*\n * swap a quad\n */\nprivate uint64_t\nswap8(uint64_t sv)\n{\n\tuint64_t rv;\n\tuint8_t *s = (uint8_t *)(void *)&sv; \n\tuint8_t *d = (uint8_t *)(void *)&rv; \n#if 0\n\td[0] = s[3];\n\td[1] = s[2];\n\td[2] = s[1];\n\td[3] = s[0];\n\td[4] = s[7];\n\td[5] = s[6];\n\td[6] = s[5];\n\td[7] = s[4];\n#else\n\td[0] = s[7];\n\td[1] = s[6];\n\td[2] = s[5];\n\td[3] = s[4];\n\td[4] = s[3];\n\td[5] = s[2];\n\td[6] = s[1];\n\td[7] = s[0];\n#endif\n\treturn rv;\n}\n\n/*\n * byteswap a single magic entry\n */\nprivate void\nbs1(struct magic *m)\n{\n\tm->cont_level = swap2(m->cont_level);\n\tm->offset = swap4((uint32_t)m->offset);\n\tm->in_offset = swap4((uint32_t)m->in_offset);\n\tm->lineno = swap4((uint32_t)m->lineno);\n\tif (IS_STRING(m->type)) {\n\t\tm->str_range = swap4(m->str_range);\n\t\tm->str_flags = swap4(m->str_flags);\n\t}\n\telse {\n\t\tm->value.q = swap8(m->value.q);\n\t\tm->num_mask = swap8(m->num_mask);\n\t}\n}\n\nprotected size_t \nfile_pstring_length_size(const struct magic *m)\n{\n\tswitch (m->str_flags & PSTRING_LEN) {\n\tcase PSTRING_1_LE:\n\t\treturn 1;\n\tcase PSTRING_2_LE:\n\tcase PSTRING_2_BE:\n\t\treturn 2;\n\tcase PSTRING_4_LE:\n\tcase PSTRING_4_BE:\n\t\treturn 4;\n\tdefault:\n\t\tabort();\t/* Impossible */\n\t\treturn 1;\n\t}\n}\nprotected size_t\nfile_pstring_get_length(const struct magic *m, const char *s)\n{\n\tsize_t len = 0;\n\n\tswitch (m->str_flags & PSTRING_LEN) {\n\tcase PSTRING_1_LE:\n\t\tlen = *s;\n\t\tbreak;\n\tcase PSTRING_2_LE:\n\t\tlen = (s[1] << 8) | s[0];\n\t\tbreak;\n\tcase PSTRING_2_BE:\n\t\tlen = (s[0] << 8) | s[1];\n\t\tbreak;\n\tcase PSTRING_4_LE:\n\t\tlen = (s[3] << 24) | (s[2] << 16) | (s[1] << 8) | s[0];\n\t\tbreak;\n\tcase PSTRING_4_BE:\n\t\tlen = (s[0] << 24) | (s[1] << 16) | (s[2] << 8) | s[3];\n\t\tbreak;\n\tdefault:\n\t\tabort();\t/* Impossible */\n\t}\n\n\tif (m->str_flags & PSTRING_LENGTH_INCLUDES_ITSELF)\n\t\tlen -= file_pstring_length_size(m);\n\n\treturn len;\n}\n\nprotected int\nfile_magicfind(struct magic_set *ms, const char *name, struct mlist *v)\n{\n\tuint32_t i, j;\n\tstruct mlist *mlist, *ml;\n\n\tmlist = ms->mlist[1];\n\n\tfor (ml = mlist->next; ml != mlist; ml = ml->next) {\n\t\tstruct magic *ma = ml->magic;\n\t\tuint32_t nma = ml->nmagic;\n\t\tfor (i = 0; i < nma; i++) {\n\t\t\tif (ma[i].type != FILE_NAME)\n\t\t\t\tcontinue;\n\t\t\tif (strcmp(ma[i].value.s, name) == 0) {\n\t\t\t\tv->magic = &ma[i];\n\t\t\t\tfor (j = i + 1; j < nma; j++)\n\t\t\t\t    if (ma[j].cont_level == 0)\n\t\t\t\t\t    break;\n\t\t\t\tv->nmagic = j - i;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n", "/*\n * Copyright (c) Ian F. Darwin 1986-1995.\n * Software written by Ian F. Darwin and others;\n * maintained 1995-present by Christos Zoulas and others.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice immediately at the beginning of the file, without modification,\n *    this list of conditions, and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n/*\n * file.h - definitions for file(1) program\n * @(#)$File: file.h,v 1.151 2014/05/14 23:15:42 christos Exp $\n */\n\n#ifndef __file_h__\n#define __file_h__\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#ifdef WIN32\n  #ifdef _WIN64\n    #define SIZE_T_FORMAT \"I64\"\n  #else\n    #define SIZE_T_FORMAT \"\"\n  #endif\n  #define INT64_T_FORMAT \"I64\"\n#else\n  #define SIZE_T_FORMAT \"z\"\n  #define INT64_T_FORMAT \"ll\"\n#endif\n\n#include <stdio.h>\t/* Include that here, to make sure __P gets defined */\n#include <errno.h>\n#include <fcntl.h>\t/* For open and flags */\n#ifdef HAVE_STDINT_H\n#ifndef __STDC_LIMIT_MACROS\n#define __STDC_LIMIT_MACROS\n#endif\n#include <stdint.h>\n#endif\n#ifdef HAVE_INTTYPES_H\n#include <inttypes.h>\n#endif\n#include <regex.h>\n#include <time.h>\n#include <sys/types.h>\n#include <sys/param.h>\n/* Do this here and now, because struct stat gets re-defined on solaris */\n#include <sys/stat.h>\n#include <stdarg.h>\n\n#define ENABLE_CONDITIONALS\n\n#ifndef MAGIC\n#define MAGIC \"/etc/magic\"\n#endif\n\n#if defined(__EMX__) || defined (WIN32)\n#define PATHSEP\t';'\n#else\n#define PATHSEP\t':'\n#endif\n\n#define private static\n\n#if HAVE_VISIBILITY && !defined(WIN32)\n#define public  __attribute__ ((__visibility__(\"default\")))\n#ifndef protected\n#define protected __attribute__ ((__visibility__(\"hidden\")))\n#endif\n#else\n#define public\n#ifndef protected\n#define protected\n#endif\n#endif\n\n#ifndef __arraycount\n#define __arraycount(a) (sizeof(a) / sizeof(a[0]))\n#endif\n\n#ifndef __GNUC_PREREQ__\n#ifdef __GNUC__\n#define\t__GNUC_PREREQ__(x, y)\t\t\t\t\t\t\\\n\t((__GNUC__ == (x) && __GNUC_MINOR__ >= (y)) ||\t\t\t\\\n\t (__GNUC__ > (x)))\n#else\n#define\t__GNUC_PREREQ__(x, y)\t0\n#endif\n#endif\n\n#ifndef __GNUC__\n#ifndef __attribute__\n#define __attribute__(a)\n#endif\n#endif\n\n#ifndef MIN\n#define\tMIN(a,b)\t(((a) < (b)) ? (a) : (b))\n#endif\n\n#ifndef MAX\n#define\tMAX(a,b)\t(((a) > (b)) ? (a) : (b))\n#endif\n\n#ifndef HOWMANY\n# define HOWMANY (256 * 1024)\t/* how much of the file to look at */\n#endif\n#define MAXMAGIS 8192\t\t/* max entries in any one magic file\n\t\t\t\t   or directory */\n#define MAXDESC\t64\t\t/* max len of text description/MIME type */\n#define MAXMIME\t80\t\t/* max len of text MIME type */\n#define MAXstring 64\t\t/* max len of \"string\" types */\n\n#define MAGICNO\t\t0xF11E041C\n#define VERSIONNO\t12\n#define FILE_MAGICSIZE\t248\n\n#define\tFILE_LOAD\t0\n#define FILE_CHECK\t1\n#define FILE_COMPILE\t2\n#define FILE_LIST\t3\n\nunion VALUETYPE {\n\tuint8_t b;\n\tuint16_t h;\n\tuint32_t l;\n\tuint64_t q;\n\tuint8_t hs[2];\t/* 2 bytes of a fixed-endian \"short\" */\n\tuint8_t hl[4];\t/* 4 bytes of a fixed-endian \"long\" */\n\tuint8_t hq[8];\t/* 8 bytes of a fixed-endian \"quad\" */\n\tchar s[MAXstring];\t/* the search string or regex pattern */\n\tunsigned char us[MAXstring];\n\tfloat f;\n\tdouble d;\n};\n\nstruct magic {\n\t/* Word 1 */\n\tuint16_t cont_level;\t/* level of \">\" */\n\tuint8_t flag;\n#define INDIR\t\t0x01\t/* if '(...)' appears */\n#define OFFADD\t\t0x02\t/* if '>&' or '>...(&' appears */\n#define INDIROFFADD\t0x04\t/* if '>&(' appears */\n#define UNSIGNED\t0x08\t/* comparison is unsigned */\n#define NOSPACE\t\t0x10\t/* suppress space character before output */\n#define BINTEST\t\t0x20\t/* test is for a binary type (set only\n\t\t\t\t   for top-level tests) */\n#define TEXTTEST\t0x40\t/* for passing to file_softmagic */\n\n\tuint8_t factor;\n\n\t/* Word 2 */\n\tuint8_t reln;\t\t/* relation (0=eq, '>'=gt, etc) */\n\tuint8_t vallen;\t\t/* length of string value, if any */\n\tuint8_t type;\t\t/* comparison type (FILE_*) */\n\tuint8_t in_type;\t/* type of indirection */\n#define \t\t\tFILE_INVALID\t0\n#define \t\t\tFILE_BYTE\t1\n#define\t\t\t\tFILE_SHORT\t2\n#define\t\t\t\tFILE_DEFAULT\t3\n#define\t\t\t\tFILE_LONG\t4\n#define\t\t\t\tFILE_STRING\t5\n#define\t\t\t\tFILE_DATE\t6\n#define\t\t\t\tFILE_BESHORT\t7\n#define\t\t\t\tFILE_BELONG\t8\n#define\t\t\t\tFILE_BEDATE\t9\n#define\t\t\t\tFILE_LESHORT\t10\n#define\t\t\t\tFILE_LELONG\t11\n#define\t\t\t\tFILE_LEDATE\t12\n#define\t\t\t\tFILE_PSTRING\t13\n#define\t\t\t\tFILE_LDATE\t14\n#define\t\t\t\tFILE_BELDATE\t15\n#define\t\t\t\tFILE_LELDATE\t16\n#define\t\t\t\tFILE_REGEX\t17\n#define\t\t\t\tFILE_BESTRING16\t18\n#define\t\t\t\tFILE_LESTRING16\t19\n#define\t\t\t\tFILE_SEARCH\t20\n#define\t\t\t\tFILE_MEDATE\t21\n#define\t\t\t\tFILE_MELDATE\t22\n#define\t\t\t\tFILE_MELONG\t23\n#define\t\t\t\tFILE_QUAD\t24\n#define\t\t\t\tFILE_LEQUAD\t25\n#define\t\t\t\tFILE_BEQUAD\t26\n#define\t\t\t\tFILE_QDATE\t27\n#define\t\t\t\tFILE_LEQDATE\t28\n#define\t\t\t\tFILE_BEQDATE\t29\n#define\t\t\t\tFILE_QLDATE\t30\n#define\t\t\t\tFILE_LEQLDATE\t31\n#define\t\t\t\tFILE_BEQLDATE\t32\n#define\t\t\t\tFILE_FLOAT\t33\n#define\t\t\t\tFILE_BEFLOAT\t34\n#define\t\t\t\tFILE_LEFLOAT\t35\n#define\t\t\t\tFILE_DOUBLE\t36\n#define\t\t\t\tFILE_BEDOUBLE\t37\n#define\t\t\t\tFILE_LEDOUBLE\t38\n#define\t\t\t\tFILE_BEID3\t39\n#define\t\t\t\tFILE_LEID3\t40\n#define\t\t\t\tFILE_INDIRECT\t41\n#define\t\t\t\tFILE_QWDATE\t42\n#define\t\t\t\tFILE_LEQWDATE\t43\n#define\t\t\t\tFILE_BEQWDATE\t44\n#define\t\t\t\tFILE_NAME\t45\n#define\t\t\t\tFILE_USE\t46\n#define\t\t\t\tFILE_CLEAR\t47\n#define\t\t\t\tFILE_NAMES_SIZE\t48 /* size of array to contain all names */\n\n#define IS_STRING(t) \\\n\t((t) == FILE_STRING || \\\n\t (t) == FILE_PSTRING || \\\n\t (t) == FILE_BESTRING16 || \\\n\t (t) == FILE_LESTRING16 || \\\n\t (t) == FILE_REGEX || \\\n\t (t) == FILE_SEARCH || \\\n\t (t) == FILE_NAME || \\\n\t (t) == FILE_USE)\n\n#define FILE_FMT_NONE 0\n#define FILE_FMT_NUM  1 /* \"cduxXi\" */\n#define FILE_FMT_STR  2 /* \"s\" */\n#define FILE_FMT_QUAD 3 /* \"ll\" */\n#define FILE_FMT_FLOAT 4 /* \"eEfFgG\" */\n#define FILE_FMT_DOUBLE 5 /* \"eEfFgG\" */\n\n\t/* Word 3 */\n\tuint8_t in_op;\t\t/* operator for indirection */\n\tuint8_t mask_op;\t/* operator for mask */\n#ifdef ENABLE_CONDITIONALS\n\tuint8_t cond;\t\t/* conditional type */\n#else\n\tuint8_t dummy;\n#endif\n\tuint8_t factor_op;\n#define\t\tFILE_FACTOR_OP_PLUS\t'+'\n#define\t\tFILE_FACTOR_OP_MINUS\t'-'\n#define\t\tFILE_FACTOR_OP_TIMES\t'*'\n#define\t\tFILE_FACTOR_OP_DIV\t'/'\n#define\t\tFILE_FACTOR_OP_NONE\t'\\0'\n\n#define\t\t\t\tFILE_OPS\t\"&|^+-*/%\"\n#define\t\t\t\tFILE_OPAND\t0\n#define\t\t\t\tFILE_OPOR\t1\n#define\t\t\t\tFILE_OPXOR\t2\n#define\t\t\t\tFILE_OPADD\t3\n#define\t\t\t\tFILE_OPMINUS\t4\n#define\t\t\t\tFILE_OPMULTIPLY\t5\n#define\t\t\t\tFILE_OPDIVIDE\t6\n#define\t\t\t\tFILE_OPMODULO\t7\n#define\t\t\t\tFILE_OPS_MASK\t0x07 /* mask for above ops */\n#define\t\t\t\tFILE_UNUSED_1\t0x08\n#define\t\t\t\tFILE_UNUSED_2\t0x10\n#define\t\t\t\tFILE_UNUSED_3\t0x20\n#define\t\t\t\tFILE_OPINVERSE\t0x40\n#define\t\t\t\tFILE_OPINDIRECT\t0x80\n\n#ifdef ENABLE_CONDITIONALS\n#define\t\t\t\tCOND_NONE\t0\n#define\t\t\t\tCOND_IF\t\t1\n#define\t\t\t\tCOND_ELIF\t2\n#define\t\t\t\tCOND_ELSE\t3\n#endif /* ENABLE_CONDITIONALS */\n\n\t/* Word 4 */\n\tuint32_t offset;\t/* offset to magic number */\n\t/* Word 5 */\n\tint32_t in_offset;\t/* offset from indirection */\n\t/* Word 6 */\n\tuint32_t lineno;\t/* line number in magic file */\n\t/* Word 7,8 */\n\tunion {\n\t\tuint64_t _mask;\t/* for use with numeric and date types */\n\t\tstruct {\n\t\t\tuint32_t _count;\t/* repeat/line count */\n\t\t\tuint32_t _flags;\t/* modifier flags */\n\t\t} _s;\t\t/* for use with string types */\n\t} _u;\n#define num_mask _u._mask\n#define str_range _u._s._count\n#define str_flags _u._s._flags\n\t/* Words 9-16 */\n\tunion VALUETYPE value;\t/* either number or string */\n\t/* Words 17-32 */\n\tchar desc[MAXDESC];\t/* description */\n\t/* Words 33-52 */\n\tchar mimetype[MAXMIME]; /* MIME type */\n\t/* Words 53-54 */\n\tchar apple[8];\n};\n\n#define BIT(A)   (1 << (A))\n#define STRING_COMPACT_WHITESPACE\t\tBIT(0)\n#define STRING_COMPACT_OPTIONAL_WHITESPACE\tBIT(1)\n#define STRING_IGNORE_LOWERCASE\t\t\tBIT(2)\n#define STRING_IGNORE_UPPERCASE\t\t\tBIT(3)\n#define REGEX_OFFSET_START\t\t\tBIT(4)\n#define STRING_TEXTTEST\t\t\t\tBIT(5)\n#define STRING_BINTEST\t\t\t\tBIT(6)\n#define PSTRING_1_BE\t\t\t\tBIT(7)\n#define PSTRING_1_LE\t\t\t\tBIT(7)\n#define PSTRING_2_BE\t\t\t\tBIT(8)\n#define PSTRING_2_LE\t\t\t\tBIT(9)\n#define PSTRING_4_BE\t\t\t\tBIT(10)\n#define PSTRING_4_LE\t\t\t\tBIT(11)\n#define REGEX_LINE_COUNT\t\t\tBIT(11)\n#define PSTRING_LEN\t\\\n    (PSTRING_1_BE|PSTRING_2_LE|PSTRING_2_BE|PSTRING_4_LE|PSTRING_4_BE)\n#define PSTRING_LENGTH_INCLUDES_ITSELF\t\tBIT(12)\n#define\tSTRING_TRIM\t\t\t\tBIT(13)\n#define CHAR_COMPACT_WHITESPACE\t\t\t'W'\n#define CHAR_COMPACT_OPTIONAL_WHITESPACE\t'w'\n#define CHAR_IGNORE_LOWERCASE\t\t\t'c'\n#define CHAR_IGNORE_UPPERCASE\t\t\t'C'\n#define CHAR_REGEX_OFFSET_START\t\t\t's'\n#define CHAR_TEXTTEST\t\t\t\t't'\n#define\tCHAR_TRIM\t\t\t\t'T'\n#define CHAR_BINTEST\t\t\t\t'b'\n#define CHAR_PSTRING_1_BE\t\t\t'B'\n#define CHAR_PSTRING_1_LE\t\t\t'B'\n#define CHAR_PSTRING_2_BE\t\t\t'H'\n#define CHAR_PSTRING_2_LE\t\t\t'h'\n#define CHAR_PSTRING_4_BE\t\t\t'L'\n#define CHAR_PSTRING_4_LE\t\t\t'l'\n#define CHAR_PSTRING_LENGTH_INCLUDES_ITSELF     'J'\n#define STRING_IGNORE_CASE\t\t(STRING_IGNORE_LOWERCASE|STRING_IGNORE_UPPERCASE)\n#define STRING_DEFAULT_RANGE\t\t100\n\n\n/* list of magic entries */\nstruct mlist {\n\tstruct magic *magic;\t\t/* array of magic entries */\n\tuint32_t nmagic;\t\t/* number of entries in array */\n\tvoid *map;\t\t\t/* internal resources used by entry */\n\tstruct mlist *next, *prev;\n};\n\n#ifdef __cplusplus\n#define CAST(T, b)\tstatic_cast<T>(b)\n#define RCAST(T, b)\treinterpret_cast<T>(b)\n#else\n#define CAST(T, b)\t(T)(b)\n#define RCAST(T, b)\t(T)(b)\n#endif\n\nstruct level_info {\n\tint32_t off;\n\tint got_match;\n#ifdef ENABLE_CONDITIONALS\n\tint last_match;\n\tint last_cond;\t/* used for error checking by parse() */\n#endif\n};\n\n#define MAGIC_SETS\t2\n\nstruct magic_set {\n\tstruct mlist *mlist[MAGIC_SETS];\t/* list of regular entries */\n\tstruct cont {\n\t\tsize_t len;\n\t\tstruct level_info *li;\n\t} c;\n\tstruct out {\n\t\tchar *buf;\t\t/* Accumulation buffer */\n\t\tchar *pbuf;\t\t/* Printable buffer */\n\t} o;\n\tuint32_t offset;\n\tint error;\n\tint flags;\t\t\t/* Control magic tests. */\n\tint event_flags;\t\t/* Note things that happened. */\n#define \t\tEVENT_HAD_ERR\t\t0x01\n\tconst char *file;\n\tsize_t line;\t\t\t/* current magic line number */\n\n\t/* data for searches */\n\tstruct {\n\t\tconst char *s;\t\t/* start of search in original source */\n\t\tsize_t s_len;\t\t/* length of search region */\n\t\tsize_t offset;\t\t/* starting offset in source: XXX - should this be off_t? */\n\t\tsize_t rm_len;\t\t/* match length */\n\t} search;\n\n\t/* FIXME: Make the string dynamically allocated so that e.g.\n\t   strings matched in files can be longer than MAXstring */\n\tunion VALUETYPE ms_value;\t/* either number or string */\n};\n\n/* Type for Unicode characters */\ntypedef unsigned long unichar;\n\nstruct stat;\n#define FILE_T_LOCAL\t1\n#define FILE_T_WINDOWS\t2\nprotected const char *file_fmttime(uint64_t, int, char *);\nprotected struct magic_set *file_ms_alloc(int);\nprotected void file_ms_free(struct magic_set *);\nprotected int file_buffer(struct magic_set *, int, const char *, const void *,\n    size_t);\nprotected int file_fsmagic(struct magic_set *, const char *, struct stat *);\nprotected int file_pipe2file(struct magic_set *, int, const void *, size_t);\nprotected int file_vprintf(struct magic_set *, const char *, va_list)\n    __attribute__((__format__(__printf__, 2, 0)));\nprotected size_t file_printedlen(const struct magic_set *);\nprotected int file_replace(struct magic_set *, const char *, const char *);\nprotected int file_printf(struct magic_set *, const char *, ...)\n    __attribute__((__format__(__printf__, 2, 3)));\nprotected int file_reset(struct magic_set *);\nprotected int file_tryelf(struct magic_set *, int, const unsigned char *,\n    size_t);\nprotected int file_trycdf(struct magic_set *, int, const unsigned char *,\n    size_t);\n#if HAVE_FORK\nprotected int file_zmagic(struct magic_set *, int, const char *,\n    const unsigned char *, size_t);\n#endif\nprotected int file_ascmagic(struct magic_set *, const unsigned char *, size_t,\n    int);\nprotected int file_ascmagic_with_encoding(struct magic_set *,\n    const unsigned char *, size_t, unichar *, size_t, const char *,\n    const char *, int);\nprotected int file_encoding(struct magic_set *, const unsigned char *, size_t,\n    unichar **, size_t *, const char **, const char **, const char **);\nprotected int file_is_tar(struct magic_set *, const unsigned char *, size_t);\nprotected int file_softmagic(struct magic_set *, const unsigned char *, size_t,\n    size_t, int, int);\nprotected int file_apprentice(struct magic_set *, const char *, int);\nprotected int file_magicfind(struct magic_set *, const char *, struct mlist *);\nprotected uint64_t file_signextend(struct magic_set *, struct magic *,\n    uint64_t);\nprotected void file_badread(struct magic_set *);\nprotected void file_badseek(struct magic_set *);\nprotected void file_oomem(struct magic_set *, size_t);\nprotected void file_error(struct magic_set *, int, const char *, ...)\n    __attribute__((__format__(__printf__, 3, 4)));\nprotected void file_magerror(struct magic_set *, const char *, ...)\n    __attribute__((__format__(__printf__, 2, 3)));\nprotected void file_magwarn(struct magic_set *, const char *, ...)\n    __attribute__((__format__(__printf__, 2, 3)));\nprotected void file_mdump(struct magic *);\nprotected void file_showstr(FILE *, const char *, size_t);\nprotected size_t file_mbswidth(const char *);\nprotected const char *file_getbuffer(struct magic_set *);\nprotected ssize_t sread(int, void *, size_t, int);\nprotected int file_check_mem(struct magic_set *, unsigned int);\nprotected int file_looks_utf8(const unsigned char *, size_t, unichar *,\n    size_t *);\nprotected size_t file_pstring_length_size(const struct magic *);\nprotected size_t file_pstring_get_length(const struct magic *, const char *);\n#ifdef __EMX__\nprotected int file_os2_apptype(struct magic_set *, const char *, const void *,\n    size_t);\n#endif /* __EMX__ */\n\ntypedef struct {\n\tconst char *pat;\n\tchar *old_lc_ctype;\n\tint rc;\n\tregex_t rx;\n} file_regex_t;\n\nprotected int file_regcomp(file_regex_t *, const char *, int);\nprotected int file_regexec(file_regex_t *, const char *, size_t, regmatch_t *,\n    int);\nprotected void file_regfree(file_regex_t *);\nprotected void file_regerror(file_regex_t *, int, struct magic_set *);\n\n#ifndef COMPILE_ONLY\nextern const char *file_names[];\nextern const size_t file_nnames;\n#endif\n\n#ifndef HAVE_STRERROR\nextern int sys_nerr;\nextern char *sys_errlist[];\n#define strerror(e) \\\n\t(((e) >= 0 && (e) < sys_nerr) ? sys_errlist[(e)] : \"Unknown error\")\n#endif\n\n#ifndef HAVE_STRTOUL\n#define strtoul(a, b, c)\tstrtol(a, b, c)\n#endif\n\n#ifndef HAVE_PREAD\nssize_t pread(int, void *, size_t, off_t);\n#endif\n#ifndef HAVE_VASPRINTF\nint vasprintf(char **, const char *, va_list);\n#endif\n#ifndef HAVE_ASPRINTF\nint asprintf(char **, const char *, ...);\n#endif\n\n#ifndef HAVE_STRLCPY\nsize_t strlcpy(char *, const char *, size_t);\n#endif\n#ifndef HAVE_STRLCAT\nsize_t strlcat(char *, const char *, size_t);\n#endif\n#ifndef HAVE_STRCASESTR\nchar *strcasestr(const char *, const char *);\n#endif\n#ifndef HAVE_GETLINE\nssize_t getline(char **, size_t *, FILE *);\nssize_t getdelim(char **, size_t *, int, FILE *);\n#endif\n#ifndef HAVE_CTIME_R\nchar   *ctime_r(const time_t *, char *);\n#endif\n#ifndef HAVE_ASCTIME_R\nchar   *asctime_r(const struct tm *, char *);\n#endif\n#ifndef HAVE_FMTCHECK\nconst char *fmtcheck(const char *, const char *) \n     __attribute__((__format_arg__(2)));\n#endif\n\n#if defined(HAVE_MMAP) && defined(HAVE_SYS_MMAN_H) && !defined(QUICK)\n#define QUICK\n#endif\n\n#ifndef O_BINARY\n#define O_BINARY\t0\n#endif\n\n#ifndef __cplusplus\n#if defined(__GNUC__) && (__GNUC__ >= 3)\n#define FILE_RCSID(id) \\\nstatic const char rcsid[] __attribute__((__used__)) = id;\n#else\n#define FILE_RCSID(id) \\\nstatic const char *rcsid(const char *p) { \\\n\treturn rcsid(p = id); \\\n}\n#endif\n#else\n#define FILE_RCSID(id)\n#endif\n\n#endif /* __file_h__ */\n", "/*\n * Copyright (c) Ian F. Darwin 1986-1995.\n * Software written by Ian F. Darwin and others;\n * maintained 1995-present by Christos Zoulas and others.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice immediately at the beginning of the file, without modification,\n *    this list of conditions, and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n/*\n * softmagic - interpret variable magic from MAGIC\n */\n\n#include \"file.h\"\n\n#ifndef\tlint\nFILE_RCSID(\"@(#)$File: softmagic.c,v 1.189 2014/05/30 16:47:44 christos Exp $\")\n#endif\t/* lint */\n\n#include \"magic.h\"\n#include <assert.h>\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <time.h>\n#if defined(HAVE_LOCALE_H)\n#include <locale.h>\n#endif\n\n\nprivate int match(struct magic_set *, struct magic *, uint32_t,\n    const unsigned char *, size_t, size_t, int, int, int, int, int *, int *,\n    int *);\nprivate int mget(struct magic_set *, const unsigned char *,\n    struct magic *, size_t, size_t, unsigned int, int, int, int, int, int *,\n    int *, int *);\nprivate int magiccheck(struct magic_set *, struct magic *);\nprivate int32_t mprint(struct magic_set *, struct magic *);\nprivate int32_t moffset(struct magic_set *, struct magic *);\nprivate void mdebug(uint32_t, const char *, size_t);\nprivate int mcopy(struct magic_set *, union VALUETYPE *, int, int,\n    const unsigned char *, uint32_t, size_t, struct magic *);\nprivate int mconvert(struct magic_set *, struct magic *, int);\nprivate int print_sep(struct magic_set *, int);\nprivate int handle_annotation(struct magic_set *, struct magic *);\nprivate void cvt_8(union VALUETYPE *, const struct magic *);\nprivate void cvt_16(union VALUETYPE *, const struct magic *);\nprivate void cvt_32(union VALUETYPE *, const struct magic *);\nprivate void cvt_64(union VALUETYPE *, const struct magic *);\n\n#define OFFSET_OOB(n, o, i)\t((n) < (o) || (i) > ((n) - (o)))\n/*\n * softmagic - lookup one file in parsed, in-memory copy of database\n * Passed the name and FILE * of one file to be typed.\n */\n/*ARGSUSED1*/\t\t/* nbytes passed for regularity, maybe need later */\nprotected int\nfile_softmagic(struct magic_set *ms, const unsigned char *buf, size_t nbytes,\n    size_t level, int mode, int text)\n{\n\tstruct mlist *ml;\n\tint rv, printed_something = 0, need_separator = 0;\n\tfor (ml = ms->mlist[0]->next; ml != ms->mlist[0]; ml = ml->next)\n\t\tif ((rv = match(ms, ml->magic, ml->nmagic, buf, nbytes, 0, mode,\n\t\t    text, 0, level, &printed_something, &need_separator,\n\t\t    NULL)) != 0)\n\t\t\treturn rv;\n\n\treturn 0;\n}\n\n#define FILE_FMTDEBUG\n#ifdef FILE_FMTDEBUG\n#define F(a, b, c) file_fmtcheck((a), (b), (c), __FILE__, __LINE__)\n\nprivate const char * __attribute__((__format_arg__(3)))\nfile_fmtcheck(struct magic_set *ms, const struct magic *m, const char *def,\n\tconst char *file, size_t line)\n{\n\tconst char *ptr = fmtcheck(m->desc, def);\n\tif (ptr == def)\n\t\tfile_magerror(ms,\n\t\t    \"%s, %zu: format `%s' does not match with `%s'\",\n\t\t    file, line, m->desc, def);\n\treturn ptr;\n}\n#else\n#define F(a, b, c) fmtcheck((b)->desc, (c))\n#endif\n\n/*\n * Go through the whole list, stopping if you find a match.  Process all\n * the continuations of that match before returning.\n *\n * We support multi-level continuations:\n *\n *\tAt any time when processing a successful top-level match, there is a\n *\tcurrent continuation level; it represents the level of the last\n *\tsuccessfully matched continuation.\n *\n *\tContinuations above that level are skipped as, if we see one, it\n *\tmeans that the continuation that controls them - i.e, the\n *\tlower-level continuation preceding them - failed to match.\n *\n *\tContinuations below that level are processed as, if we see one,\n *\tit means we've finished processing or skipping higher-level\n *\tcontinuations under the control of a successful or unsuccessful\n *\tlower-level continuation, and are now seeing the next lower-level\n *\tcontinuation and should process it.  The current continuation\n *\tlevel reverts to the level of the one we're seeing.\n *\n *\tContinuations at the current level are processed as, if we see\n *\tone, there's no lower-level continuation that may have failed.\n *\n *\tIf a continuation matches, we bump the current continuation level\n *\tso that higher-level continuations are processed.\n */\nprivate int\nmatch(struct magic_set *ms, struct magic *magic, uint32_t nmagic,\n    const unsigned char *s, size_t nbytes, size_t offset, int mode, int text,\n    int flip, int recursion_level, int *printed_something, int *need_separator,\n    int *returnval)\n{\n\tuint32_t magindex = 0;\n\tunsigned int cont_level = 0;\n\tint returnvalv = 0, e; /* if a match is found it is set to 1*/\n\tint firstline = 1; /* a flag to print X\\n  X\\n- X */\n\tint print = (ms->flags & (MAGIC_MIME|MAGIC_APPLE)) == 0;\n\n\tif (returnval == NULL)\n\t\treturnval = &returnvalv;\n\n\tif (file_check_mem(ms, cont_level) == -1)\n\t\treturn -1;\n\n\tfor (magindex = 0; magindex < nmagic; magindex++) {\n\t\tint flush = 0;\n\t\tstruct magic *m = &magic[magindex];\n\n\t\tif (m->type != FILE_NAME)\n\t\tif ((IS_STRING(m->type) &&\n#define FLT (STRING_BINTEST | STRING_TEXTTEST)\n\t\t     ((text && (m->str_flags & FLT) == STRING_BINTEST) ||\n\t\t      (!text && (m->str_flags & FLT) == STRING_TEXTTEST))) ||\n\t\t    (m->flag & mode) != mode) {\n\t\t\t/* Skip sub-tests */\n\t\t\twhile (magindex + 1 < nmagic &&\n                               magic[magindex + 1].cont_level != 0 &&\n\t\t\t       ++magindex)\n\t\t\t\tcontinue;\n\t\t\tcontinue; /* Skip to next top-level test*/\n\t\t}\n\n\t\tms->offset = m->offset;\n\t\tms->line = m->lineno;\n\n\t\t/* if main entry matches, print it... */\n\t\tswitch (mget(ms, s, m, nbytes, offset, cont_level, mode, text,\n\t\t    flip, recursion_level + 1, printed_something,\n\t\t    need_separator, returnval)) {\n\t\tcase -1:\n\t\t\treturn -1;\n\t\tcase 0:\n\t\t\tflush = m->reln != '!';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (m->type == FILE_INDIRECT)\n\t\t\t\t*returnval = 1;\n\n\t\t\tswitch (magiccheck(ms, m)) {\n\t\t\tcase -1:\n\t\t\t\treturn -1;\n\t\t\tcase 0:\n\t\t\t\tflush++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tflush = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (flush) {\n\t\t\t/*\n\t\t\t * main entry didn't match,\n\t\t\t * flush its continuations\n\t\t\t */\n\t\t\twhile (magindex < nmagic - 1 &&\n\t\t\t    magic[magindex + 1].cont_level != 0)\n\t\t\t\tmagindex++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((e = handle_annotation(ms, m)) != 0) {\n\t\t\t*need_separator = 1;\n\t\t\t*printed_something = 1;\n\t\t\t*returnval = 1;\n\t\t\treturn e;\n\t\t}\n\t\t/*\n\t\t * If we are going to print something, we'll need to print\n\t\t * a blank before we print something else.\n\t\t */\n\t\tif (*m->desc) {\n\t\t\t*need_separator = 1;\n\t\t\t*printed_something = 1;\n\t\t\tif (print_sep(ms, firstline) == -1)\n\t\t\t\treturn -1;\n\t\t}\n\n\n\t\tif (print && mprint(ms, m) == -1)\n\t\t\treturn -1;\n\n\t\tms->c.li[cont_level].off = moffset(ms, m);\n\n\t\t/* and any continuations that match */\n\t\tif (file_check_mem(ms, ++cont_level) == -1)\n\t\t\treturn -1;\n\n\t\twhile (++magindex < nmagic &&\n\t\t    magic[magindex].cont_level != 0) {\n\t\t\tm = &magic[magindex];\n\t\t\tms->line = m->lineno; /* for messages */\n\n\t\t\tif (cont_level < m->cont_level)\n\t\t\t\tcontinue;\n\t\t\tif (cont_level > m->cont_level) {\n\t\t\t\t/*\n\t\t\t\t * We're at the end of the level\n\t\t\t\t * \"cont_level\" continuations.\n\t\t\t\t */\n\t\t\t\tcont_level = m->cont_level;\n\t\t\t}\n\t\t\tms->offset = m->offset;\n\t\t\tif (m->flag & OFFADD) {\n\t\t\t\tms->offset +=\n\t\t\t\t    ms->c.li[cont_level - 1].off;\n\t\t\t}\n\n#ifdef ENABLE_CONDITIONALS\n\t\t\tif (m->cond == COND_ELSE ||\n\t\t\t    m->cond == COND_ELIF) {\n\t\t\t\tif (ms->c.li[cont_level].last_match == 1)\n\t\t\t\t\tcontinue;\n\t\t\t}\n#endif\n\t\t\tswitch (mget(ms, s, m, nbytes, offset, cont_level, mode,\n\t\t\t    text, flip, recursion_level + 1, printed_something,\n\t\t\t    need_separator, returnval)) {\n\t\t\tcase -1:\n\t\t\t\treturn -1;\n\t\t\tcase 0:\n\t\t\t\tif (m->reln != '!')\n\t\t\t\t\tcontinue;\n\t\t\t\tflush = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (m->type == FILE_INDIRECT)\n\t\t\t\t\t*returnval = 1;\n\t\t\t\tflush = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch (flush ? 1 : magiccheck(ms, m)) {\n\t\t\tcase -1:\n\t\t\t\treturn -1;\n\t\t\tcase 0:\n#ifdef ENABLE_CONDITIONALS\n\t\t\t\tms->c.li[cont_level].last_match = 0;\n#endif\n\t\t\t\tbreak;\n\t\t\tdefault:\n#ifdef ENABLE_CONDITIONALS\n\t\t\t\tms->c.li[cont_level].last_match = 1;\n#endif\n\t\t\t\tif (m->type == FILE_CLEAR)\n\t\t\t\t\tms->c.li[cont_level].got_match = 0;\n\t\t\t\telse if (ms->c.li[cont_level].got_match) {\n\t\t\t\t\tif (m->type == FILE_DEFAULT)\n\t\t\t\t\t\tbreak;\n\t\t\t\t} else\n\t\t\t\t\tms->c.li[cont_level].got_match = 1;\n\t\t\t\tif ((e = handle_annotation(ms, m)) != 0) {\n\t\t\t\t\t*need_separator = 1;\n\t\t\t\t\t*printed_something = 1;\n\t\t\t\t\t*returnval = 1;\n\t\t\t\t\treturn e;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * If we are going to print something,\n\t\t\t\t * make sure that we have a separator first.\n\t\t\t\t */\n\t\t\t\tif (*m->desc) {\n\t\t\t\t\tif (!*printed_something) {\n\t\t\t\t\t\t*printed_something = 1;\n\t\t\t\t\t\tif (print_sep(ms, firstline)\n\t\t\t\t\t\t    == -1)\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * This continuation matched.  Print\n\t\t\t\t * its message, with a blank before it\n\t\t\t\t * if the previous item printed and\n\t\t\t\t * this item isn't empty.\n\t\t\t\t */\n\t\t\t\t/* space if previous printed */\n\t\t\t\tif (*need_separator\n\t\t\t\t    && ((m->flag & NOSPACE) == 0)\n\t\t\t\t    && *m->desc) {\n\t\t\t\t\tif (print &&\n\t\t\t\t\t    file_printf(ms, \" \") == -1)\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t*need_separator = 0;\n\t\t\t\t}\n\t\t\t\tif (print && mprint(ms, m) == -1)\n\t\t\t\t\treturn -1;\n\n\t\t\t\tms->c.li[cont_level].off = moffset(ms, m);\n\n\t\t\t\tif (*m->desc)\n\t\t\t\t\t*need_separator = 1;\n\n\t\t\t\t/*\n\t\t\t\t * If we see any continuations\n\t\t\t\t * at a higher level,\n\t\t\t\t * process them.\n\t\t\t\t */\n\t\t\t\tif (file_check_mem(ms, ++cont_level) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (*printed_something) {\n\t\t\tfirstline = 0;\n\t\t\tif (print)\n\t\t\t\t*returnval = 1;\n\t\t}\n\t\tif ((ms->flags & MAGIC_CONTINUE) == 0 && *printed_something) {\n\t\t\treturn *returnval; /* don't keep searching */\n\t\t}\n\t}\n\treturn *returnval;  /* This is hit if -k is set or there is no match */\n}\n\nprivate int\ncheck_fmt(struct magic_set *ms, struct magic *m)\n{\n\tfile_regex_t rx;\n\tint rc, rv = -1;\n\n\tif (strchr(m->desc, '%') == NULL)\n\t\treturn 0;\n\n\trc = file_regcomp(&rx, \"%[-0-9\\\\.]*s\", REG_EXTENDED|REG_NOSUB);\n\tif (rc) {\n\t\tfile_regerror(&rx, rc, ms);\n\t} else {\n\t\trc = file_regexec(&rx, m->desc, 0, 0, 0);\n\t\trv = !rc;\n\t}\n\tfile_regfree(&rx);\n\treturn rv;\n}\n\n#ifndef HAVE_STRNDUP\nchar * strndup(const char *, size_t);\n\nchar *\nstrndup(const char *str, size_t n)\n{\n\tsize_t len;\n\tchar *copy;\n\n\tfor (len = 0; len < n && str[len]; len++)\n\t\tcontinue;\n\tif ((copy = malloc(len + 1)) == NULL)\n\t\treturn NULL;\n\t(void)memcpy(copy, str, len);\n\tcopy[len] = '\\0';\n\treturn copy;\n}\n#endif /* HAVE_STRNDUP */\n\nprivate int32_t\nmprint(struct magic_set *ms, struct magic *m)\n{\n\tuint64_t v;\n\tfloat vf;\n\tdouble vd;\n\tint64_t t = 0;\n \tchar buf[128], tbuf[26];\n\tunion VALUETYPE *p = &ms->ms_value;\n\n  \tswitch (m->type) {\n  \tcase FILE_BYTE:\n\t\tv = file_signextend(ms, m, (uint64_t)p->b);\n\t\tswitch (check_fmt(ms, m)) {\n\t\tcase -1:\n\t\t\treturn -1;\n\t\tcase 1:\n\t\t\t(void)snprintf(buf, sizeof(buf), \"%d\",\n\t\t\t    (unsigned char)v);\n\t\t\tif (file_printf(ms, F(ms, m, \"%s\"), buf) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (file_printf(ms, F(ms, m, \"%d\"),\n\t\t\t    (unsigned char) v) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\t}\n\t\tt = ms->offset + sizeof(char);\n\t\tbreak;\n\n  \tcase FILE_SHORT:\n  \tcase FILE_BESHORT:\n  \tcase FILE_LESHORT:\n\t\tv = file_signextend(ms, m, (uint64_t)p->h);\n\t\tswitch (check_fmt(ms, m)) {\n\t\tcase -1:\n\t\t\treturn -1;\n\t\tcase 1:\n\t\t\t(void)snprintf(buf, sizeof(buf), \"%u\",\n\t\t\t    (unsigned short)v);\n\t\t\tif (file_printf(ms, F(ms, m, \"%s\"), buf) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (file_printf(ms, F(ms, m, \"%u\"),\n\t\t\t    (unsigned short) v) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\t}\n\t\tt = ms->offset + sizeof(short);\n\t\tbreak;\n\n  \tcase FILE_LONG:\n  \tcase FILE_BELONG:\n  \tcase FILE_LELONG:\n  \tcase FILE_MELONG:\n\t\tv = file_signextend(ms, m, (uint64_t)p->l);\n\t\tswitch (check_fmt(ms, m)) {\n\t\tcase -1:\n\t\t\treturn -1;\n\t\tcase 1:\n\t\t\t(void)snprintf(buf, sizeof(buf), \"%u\", (uint32_t) v);\n\t\t\tif (file_printf(ms, F(ms, m, \"%s\"), buf) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (file_printf(ms, F(ms, m, \"%u\"), (uint32_t) v) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\t}\n\t\tt = ms->offset + sizeof(int32_t);\n  \t\tbreak;\n\n  \tcase FILE_QUAD:\n  \tcase FILE_BEQUAD:\n  \tcase FILE_LEQUAD:\n\t\tv = file_signextend(ms, m, p->q);\n\t\tswitch (check_fmt(ms, m)) {\n\t\tcase -1:\n\t\t\treturn -1;\n\t\tcase 1:\n\t\t\t(void)snprintf(buf, sizeof(buf), \"%\" INT64_T_FORMAT \"u\",\n\t\t\t    (unsigned long long)v);\n\t\t\tif (file_printf(ms, F(ms, m, \"%s\"), buf) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (file_printf(ms, F(ms, m, \"%\" INT64_T_FORMAT \"u\"),\n\t\t\t    (unsigned long long) v) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\t}\n\t\tt = ms->offset + sizeof(int64_t);\n  \t\tbreak;\n\n  \tcase FILE_STRING:\n  \tcase FILE_PSTRING:\n  \tcase FILE_BESTRING16:\n  \tcase FILE_LESTRING16:\n\t\tif (m->reln == '=' || m->reln == '!') {\n\t\t\tif (file_printf(ms, F(ms, m, \"%s\"), m->value.s) == -1)\n\t\t\t\treturn -1;\n\t\t\tt = ms->offset + m->vallen;\n\t\t}\n\t\telse {\n\t\t\tchar *str = p->s;\n\n\t\t\t/* compute t before we mangle the string? */\n\t\t\tt = ms->offset + strlen(str);\n\n\t\t\tif (*m->value.s == '\\0')\n\t\t\t\tstr[strcspn(str, \"\\n\")] = '\\0';\n\n\t\t\tif (m->str_flags & STRING_TRIM) {\n\t\t\t\tchar *last;\n\t\t\t\twhile (isspace((unsigned char)*str))\n\t\t\t\t\tstr++;\n\t\t\t\tlast = str;\n\t\t\t\twhile (*last)\n\t\t\t\t\tlast++;\n\t\t\t\t--last;\n\t\t\t\twhile (isspace((unsigned char)*last))\n\t\t\t\t\tlast--;\n\t\t\t\t*++last = '\\0';\n\t\t\t}\n\n\t\t\tif (file_printf(ms, F(ms, m, \"%s\"), str) == -1)\n\t\t\t\treturn -1;\n\n\t\t\tif (m->type == FILE_PSTRING)\n\t\t\t\tt += file_pstring_length_size(m);\n\t\t}\n\t\tbreak;\n\n\tcase FILE_DATE:\n\tcase FILE_BEDATE:\n\tcase FILE_LEDATE:\n\tcase FILE_MEDATE:\n\t\tif (file_printf(ms, F(ms, m, \"%s\"),\n\t\t    file_fmttime(p->l + m->num_mask, FILE_T_LOCAL, tbuf)) == -1)\n\t\t\treturn -1;\n\t\tt = ms->offset + sizeof(uint32_t);\n\t\tbreak;\n\n\tcase FILE_LDATE:\n\tcase FILE_BELDATE:\n\tcase FILE_LELDATE:\n\tcase FILE_MELDATE:\n\t\tif (file_printf(ms, F(ms, m, \"%s\"),\n\t\t    file_fmttime(p->l + m->num_mask, 0, tbuf)) == -1)\n\t\t\treturn -1;\n\t\tt = ms->offset + sizeof(uint32_t);\n\t\tbreak;\n\n\tcase FILE_QDATE:\n\tcase FILE_BEQDATE:\n\tcase FILE_LEQDATE:\n\t\tif (file_printf(ms, F(ms, m, \"%s\"),\n\t\t    file_fmttime(p->q + m->num_mask, FILE_T_LOCAL, tbuf)) == -1)\n\t\t\treturn -1;\n\t\tt = ms->offset + sizeof(uint64_t);\n\t\tbreak;\n\n\tcase FILE_QLDATE:\n\tcase FILE_BEQLDATE:\n\tcase FILE_LEQLDATE:\n\t\tif (file_printf(ms, F(ms, m, \"%s\"),\n\t\t    file_fmttime(p->q + m->num_mask, 0, tbuf)) == -1)\n\t\t\treturn -1;\n\t\tt = ms->offset + sizeof(uint64_t);\n\t\tbreak;\n\n\tcase FILE_QWDATE:\n\tcase FILE_BEQWDATE:\n\tcase FILE_LEQWDATE:\n\t\tif (file_printf(ms, F(ms, m, \"%s\"),\n\t\t    file_fmttime(p->q + m->num_mask, FILE_T_WINDOWS, tbuf)) == -1)\n\t\t\treturn -1;\n\t\tt = ms->offset + sizeof(uint64_t);\n\t\tbreak;\n\n  \tcase FILE_FLOAT:\n  \tcase FILE_BEFLOAT:\n  \tcase FILE_LEFLOAT:\n\t\tvf = p->f;\n\t\tswitch (check_fmt(ms, m)) {\n\t\tcase -1:\n\t\t\treturn -1;\n\t\tcase 1:\n\t\t\t(void)snprintf(buf, sizeof(buf), \"%g\", vf);\n\t\t\tif (file_printf(ms, F(ms, m, \"%s\"), buf) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (file_printf(ms, F(ms, m, \"%g\"), vf) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\t}\n\t\tt = ms->offset + sizeof(float);\n  \t\tbreak;\n\n  \tcase FILE_DOUBLE:\n  \tcase FILE_BEDOUBLE:\n  \tcase FILE_LEDOUBLE:\n\t\tvd = p->d;\n\t\tswitch (check_fmt(ms, m)) {\n\t\tcase -1:\n\t\t\treturn -1;\n\t\tcase 1:\n\t\t\t(void)snprintf(buf, sizeof(buf), \"%g\", vd);\n\t\t\tif (file_printf(ms, F(ms, m, \"%s\"), buf) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (file_printf(ms, F(ms, m, \"%g\"), vd) == -1)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\t}\n\t\tt = ms->offset + sizeof(double);\n  \t\tbreak;\n\n\tcase FILE_REGEX: {\n\t\tchar *cp;\n\t\tint rval;\n\n\t\tcp = strndup((const char *)ms->search.s, ms->search.rm_len);\n\t\tif (cp == NULL) {\n\t\t\tfile_oomem(ms, ms->search.rm_len);\n\t\t\treturn -1;\n\t\t}\n\t\trval = file_printf(ms, F(ms, m, \"%s\"), cp);\n\t\tfree(cp);\n\n\t\tif (rval == -1)\n\t\t\treturn -1;\n\n\t\tif ((m->str_flags & REGEX_OFFSET_START))\n\t\t\tt = ms->search.offset;\n\t\telse\n\t\t\tt = ms->search.offset + ms->search.rm_len;\n\t\tbreak;\n\t}\n\n\tcase FILE_SEARCH:\n\t  \tif (file_printf(ms, F(ms, m, \"%s\"), m->value.s) == -1)\n\t\t\treturn -1;\n\t\tif ((m->str_flags & REGEX_OFFSET_START))\n\t\t\tt = ms->search.offset;\n\t\telse\n\t\t\tt = ms->search.offset + m->vallen;\n\t\tbreak;\n\n\tcase FILE_DEFAULT:\n\tcase FILE_CLEAR:\n\t  \tif (file_printf(ms, \"%s\", m->desc) == -1)\n\t\t\treturn -1;\n\t\tt = ms->offset;\n\t\tbreak;\n\n\tcase FILE_INDIRECT:\n\tcase FILE_USE:\n\tcase FILE_NAME:\n\t\tt = ms->offset;\n\t\tbreak;\n\n\tdefault:\n\t\tfile_magerror(ms, \"invalid m->type (%d) in mprint()\", m->type);\n\t\treturn -1;\n\t}\n\treturn (int32_t)t;\n}\n\nprivate int32_t\nmoffset(struct magic_set *ms, struct magic *m)\n{\n  \tswitch (m->type) {\n  \tcase FILE_BYTE:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(char)));\n\n  \tcase FILE_SHORT:\n  \tcase FILE_BESHORT:\n  \tcase FILE_LESHORT:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(short)));\n\n  \tcase FILE_LONG:\n  \tcase FILE_BELONG:\n  \tcase FILE_LELONG:\n  \tcase FILE_MELONG:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(int32_t)));\n\n  \tcase FILE_QUAD:\n  \tcase FILE_BEQUAD:\n  \tcase FILE_LEQUAD:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(int64_t)));\n\n  \tcase FILE_STRING:\n  \tcase FILE_PSTRING:\n  \tcase FILE_BESTRING16:\n  \tcase FILE_LESTRING16:\n\t\tif (m->reln == '=' || m->reln == '!')\n\t\t\treturn ms->offset + m->vallen;\n\t\telse {\n\t\t\tunion VALUETYPE *p = &ms->ms_value;\n\t\t\tuint32_t t;\n\n\t\t\tif (*m->value.s == '\\0')\n\t\t\t\tp->s[strcspn(p->s, \"\\n\")] = '\\0';\n\t\t\tt = CAST(uint32_t, (ms->offset + strlen(p->s)));\n\t\t\tif (m->type == FILE_PSTRING)\n\t\t\t\tt += (uint32_t)file_pstring_length_size(m);\n\t\t\treturn t;\n\t\t}\n\n\tcase FILE_DATE:\n\tcase FILE_BEDATE:\n\tcase FILE_LEDATE:\n\tcase FILE_MEDATE:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(uint32_t)));\n\n\tcase FILE_LDATE:\n\tcase FILE_BELDATE:\n\tcase FILE_LELDATE:\n\tcase FILE_MELDATE:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(uint32_t)));\n\n\tcase FILE_QDATE:\n\tcase FILE_BEQDATE:\n\tcase FILE_LEQDATE:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(uint64_t)));\n\n\tcase FILE_QLDATE:\n\tcase FILE_BEQLDATE:\n\tcase FILE_LEQLDATE:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(uint64_t)));\n\n  \tcase FILE_FLOAT:\n  \tcase FILE_BEFLOAT:\n  \tcase FILE_LEFLOAT:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(float)));\n\n  \tcase FILE_DOUBLE:\n  \tcase FILE_BEDOUBLE:\n  \tcase FILE_LEDOUBLE:\n\t\treturn CAST(int32_t, (ms->offset + sizeof(double)));\n\n\tcase FILE_REGEX:\n\t\tif ((m->str_flags & REGEX_OFFSET_START) != 0)\n\t\t\treturn CAST(int32_t, ms->search.offset);\n\t\telse\n\t\t\treturn CAST(int32_t, (ms->search.offset +\n\t\t\t    ms->search.rm_len));\n\n\tcase FILE_SEARCH:\n\t\tif ((m->str_flags & REGEX_OFFSET_START) != 0)\n\t\t\treturn CAST(int32_t, ms->search.offset);\n\t\telse\n\t\t\treturn CAST(int32_t, (ms->search.offset + m->vallen));\n\n\tcase FILE_CLEAR:\n\tcase FILE_DEFAULT:\n\tcase FILE_INDIRECT:\n\t\treturn ms->offset;\n\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nprivate int\ncvt_flip(int type, int flip)\n{\n\tif (flip == 0)\n\t\treturn type;\n\tswitch (type) {\n\tcase FILE_BESHORT:\n\t\treturn FILE_LESHORT;\n\tcase FILE_BELONG:\n\t\treturn FILE_LELONG;\n\tcase FILE_BEDATE:\n\t\treturn FILE_LEDATE;\n\tcase FILE_BELDATE:\n\t\treturn FILE_LELDATE;\n\tcase FILE_BEQUAD:\n\t\treturn FILE_LEQUAD;\n\tcase FILE_BEQDATE:\n\t\treturn FILE_LEQDATE;\n\tcase FILE_BEQLDATE:\n\t\treturn FILE_LEQLDATE;\n\tcase FILE_BEQWDATE:\n\t\treturn FILE_LEQWDATE;\n\tcase FILE_LESHORT:\n\t\treturn FILE_BESHORT;\n\tcase FILE_LELONG:\n\t\treturn FILE_BELONG;\n\tcase FILE_LEDATE:\n\t\treturn FILE_BEDATE;\n\tcase FILE_LELDATE:\n\t\treturn FILE_BELDATE;\n\tcase FILE_LEQUAD:\n\t\treturn FILE_BEQUAD;\n\tcase FILE_LEQDATE:\n\t\treturn FILE_BEQDATE;\n\tcase FILE_LEQLDATE:\n\t\treturn FILE_BEQLDATE;\n\tcase FILE_LEQWDATE:\n\t\treturn FILE_BEQWDATE;\n\tcase FILE_BEFLOAT:\n\t\treturn FILE_LEFLOAT;\n\tcase FILE_LEFLOAT:\n\t\treturn FILE_BEFLOAT;\n\tcase FILE_BEDOUBLE:\n\t\treturn FILE_LEDOUBLE;\n\tcase FILE_LEDOUBLE:\n\t\treturn FILE_BEDOUBLE;\n\tdefault:\n\t\treturn type;\n\t}\n}\n#define DO_CVT(fld, cast) \\\n\tif (m->num_mask) \\\n\t\tswitch (m->mask_op & FILE_OPS_MASK) { \\\n\t\tcase FILE_OPAND: \\\n\t\t\tp->fld &= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPOR: \\\n\t\t\tp->fld |= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPXOR: \\\n\t\t\tp->fld ^= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPADD: \\\n\t\t\tp->fld += cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPMINUS: \\\n\t\t\tp->fld -= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPMULTIPLY: \\\n\t\t\tp->fld *= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPDIVIDE: \\\n\t\t\tp->fld /= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPMODULO: \\\n\t\t\tp->fld %= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\t} \\\n\tif (m->mask_op & FILE_OPINVERSE) \\\n\t\tp->fld = ~p->fld \\\n\nprivate void\ncvt_8(union VALUETYPE *p, const struct magic *m)\n{\n\tDO_CVT(b, (uint8_t));\n}\n\nprivate void\ncvt_16(union VALUETYPE *p, const struct magic *m)\n{\n\tDO_CVT(h, (uint16_t));\n}\n\nprivate void\ncvt_32(union VALUETYPE *p, const struct magic *m)\n{\n\tDO_CVT(l, (uint32_t));\n}\n\nprivate void\ncvt_64(union VALUETYPE *p, const struct magic *m)\n{\n\tDO_CVT(q, (uint64_t));\n}\n\n#define DO_CVT2(fld, cast) \\\n\tif (m->num_mask) \\\n\t\tswitch (m->mask_op & FILE_OPS_MASK) { \\\n\t\tcase FILE_OPADD: \\\n\t\t\tp->fld += cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPMINUS: \\\n\t\t\tp->fld -= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPMULTIPLY: \\\n\t\t\tp->fld *= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\tcase FILE_OPDIVIDE: \\\n\t\t\tp->fld /= cast m->num_mask; \\\n\t\t\tbreak; \\\n\t\t} \\\n\nprivate void\ncvt_float(union VALUETYPE *p, const struct magic *m)\n{\n\tDO_CVT2(f, (float));\n}\n\nprivate void\ncvt_double(union VALUETYPE *p, const struct magic *m)\n{\n\tDO_CVT2(d, (double));\n}\n\n/*\n * Convert the byte order of the data we are looking at\n * While we're here, let's apply the mask operation\n * (unless you have a better idea)\n */\nprivate int\nmconvert(struct magic_set *ms, struct magic *m, int flip)\n{\n\tunion VALUETYPE *p = &ms->ms_value;\n\tuint8_t type;\n\n\tswitch (type = cvt_flip(m->type, flip)) {\n\tcase FILE_BYTE:\n\t\tcvt_8(p, m);\n\t\treturn 1;\n\tcase FILE_SHORT:\n\t\tcvt_16(p, m);\n\t\treturn 1;\n\tcase FILE_LONG:\n\tcase FILE_DATE:\n\tcase FILE_LDATE:\n\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_QUAD:\n\tcase FILE_QDATE:\n\tcase FILE_QLDATE:\n\tcase FILE_QWDATE:\n\t\tcvt_64(p, m);\n\t\treturn 1;\n\tcase FILE_STRING:\n\tcase FILE_BESTRING16:\n\tcase FILE_LESTRING16: {\n\t\t/* Null terminate and eat *trailing* return */\n\t\tp->s[sizeof(p->s) - 1] = '\\0';\n\t\treturn 1;\n\t}\n\tcase FILE_PSTRING: {\n\t\tchar *ptr1 = p->s, *ptr2 = ptr1 + file_pstring_length_size(m);\n\t\tsize_t len = file_pstring_get_length(m, ptr1);\n\t\tif (len >= sizeof(p->s))\n\t\t\tlen = sizeof(p->s) - 1;\n\t\twhile (len--)\n\t\t\t*ptr1++ = *ptr2++;\n\t\t*ptr1 = '\\0';\n\t\treturn 1;\n\t}\n\tcase FILE_BESHORT:\n\t\tp->h = (short)((p->hs[0]<<8)|(p->hs[1]));\n\t\tcvt_16(p, m);\n\t\treturn 1;\n\tcase FILE_BELONG:\n\tcase FILE_BEDATE:\n\tcase FILE_BELDATE:\n\t\tp->l = (int32_t)\n\t\t    ((p->hl[0]<<24)|(p->hl[1]<<16)|(p->hl[2]<<8)|(p->hl[3]));\n\t\tif (type == FILE_BELONG)\n\t\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_BEQUAD:\n\tcase FILE_BEQDATE:\n\tcase FILE_BEQLDATE:\n\tcase FILE_BEQWDATE:\n\t\tp->q = (uint64_t)\n\t\t    (((uint64_t)p->hq[0]<<56)|((uint64_t)p->hq[1]<<48)|\n\t\t     ((uint64_t)p->hq[2]<<40)|((uint64_t)p->hq[3]<<32)|\n\t\t     ((uint64_t)p->hq[4]<<24)|((uint64_t)p->hq[5]<<16)|\n\t\t     ((uint64_t)p->hq[6]<<8)|((uint64_t)p->hq[7]));\n\t\tif (type == FILE_BEQUAD)\n\t\t\tcvt_64(p, m);\n\t\treturn 1;\n\tcase FILE_LESHORT:\n\t\tp->h = (short)((p->hs[1]<<8)|(p->hs[0]));\n\t\tcvt_16(p, m);\n\t\treturn 1;\n\tcase FILE_LELONG:\n\tcase FILE_LEDATE:\n\tcase FILE_LELDATE:\n\t\tp->l = (int32_t)\n\t\t    ((p->hl[3]<<24)|(p->hl[2]<<16)|(p->hl[1]<<8)|(p->hl[0]));\n\t\tif (type == FILE_LELONG)\n\t\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_LEQUAD:\n\tcase FILE_LEQDATE:\n\tcase FILE_LEQLDATE:\n\tcase FILE_LEQWDATE:\n\t\tp->q = (uint64_t)\n\t\t    (((uint64_t)p->hq[7]<<56)|((uint64_t)p->hq[6]<<48)|\n\t\t     ((uint64_t)p->hq[5]<<40)|((uint64_t)p->hq[4]<<32)|\n\t\t     ((uint64_t)p->hq[3]<<24)|((uint64_t)p->hq[2]<<16)|\n\t\t     ((uint64_t)p->hq[1]<<8)|((uint64_t)p->hq[0]));\n\t\tif (type == FILE_LEQUAD)\n\t\t\tcvt_64(p, m);\n\t\treturn 1;\n\tcase FILE_MELONG:\n\tcase FILE_MEDATE:\n\tcase FILE_MELDATE:\n\t\tp->l = (int32_t)\n\t\t    ((p->hl[1]<<24)|(p->hl[0]<<16)|(p->hl[3]<<8)|(p->hl[2]));\n\t\tif (type == FILE_MELONG)\n\t\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_FLOAT:\n\t\tcvt_float(p, m);\n\t\treturn 1;\n\tcase FILE_BEFLOAT:\n\t\tp->l =  ((uint32_t)p->hl[0]<<24)|((uint32_t)p->hl[1]<<16)|\n\t\t\t((uint32_t)p->hl[2]<<8) |((uint32_t)p->hl[3]);\n\t\tcvt_float(p, m);\n\t\treturn 1;\n\tcase FILE_LEFLOAT:\n\t\tp->l =  ((uint32_t)p->hl[3]<<24)|((uint32_t)p->hl[2]<<16)|\n\t\t\t((uint32_t)p->hl[1]<<8) |((uint32_t)p->hl[0]);\n\t\tcvt_float(p, m);\n\t\treturn 1;\n\tcase FILE_DOUBLE:\n\t\tcvt_double(p, m);\n\t\treturn 1;\n\tcase FILE_BEDOUBLE:\n\t\tp->q =  ((uint64_t)p->hq[0]<<56)|((uint64_t)p->hq[1]<<48)|\n\t\t\t((uint64_t)p->hq[2]<<40)|((uint64_t)p->hq[3]<<32)|\n\t\t\t((uint64_t)p->hq[4]<<24)|((uint64_t)p->hq[5]<<16)|\n\t\t\t((uint64_t)p->hq[6]<<8) |((uint64_t)p->hq[7]);\n\t\tcvt_double(p, m);\n\t\treturn 1;\n\tcase FILE_LEDOUBLE:\n\t\tp->q =  ((uint64_t)p->hq[7]<<56)|((uint64_t)p->hq[6]<<48)|\n\t\t\t((uint64_t)p->hq[5]<<40)|((uint64_t)p->hq[4]<<32)|\n\t\t\t((uint64_t)p->hq[3]<<24)|((uint64_t)p->hq[2]<<16)|\n\t\t\t((uint64_t)p->hq[1]<<8) |((uint64_t)p->hq[0]);\n\t\tcvt_double(p, m);\n\t\treturn 1;\n\tcase FILE_REGEX:\n\tcase FILE_SEARCH:\n\tcase FILE_DEFAULT:\n\tcase FILE_CLEAR:\n\tcase FILE_NAME:\n\tcase FILE_USE:\n\t\treturn 1;\n\tdefault:\n\t\tfile_magerror(ms, \"invalid type %d in mconvert()\", m->type);\n\t\treturn 0;\n\t}\n}\n\n\nprivate void\nmdebug(uint32_t offset, const char *str, size_t len)\n{\n\t(void) fprintf(stderr, \"mget/%zu @%d: \", len, offset);\n\tfile_showstr(stderr, str, len);\n\t(void) fputc('\\n', stderr);\n\t(void) fputc('\\n', stderr);\n}\n\nprivate int\nmcopy(struct magic_set *ms, union VALUETYPE *p, int type, int indir,\n    const unsigned char *s, uint32_t offset, size_t nbytes, struct magic *m)\n{\n\t/*\n\t * Note: FILE_SEARCH and FILE_REGEX do not actually copy\n\t * anything, but setup pointers into the source\n\t */\n\tif (indir == 0) {\n\t\tswitch (type) {\n\t\tcase FILE_SEARCH:\n\t\t\tms->search.s = RCAST(const char *, s) + offset;\n\t\t\tms->search.s_len = nbytes - offset;\n\t\t\tms->search.offset = offset;\n\t\t\treturn 0;\n\n\t\tcase FILE_REGEX: {\n\t\t\tconst char *b;\n\t\t\tconst char *c;\n\t\t\tconst char *last;\t/* end of search region */\n\t\t\tconst char *buf;\t/* start of search region */\n\t\t\tconst char *end;\n\t\t\tsize_t lines, linecnt, bytecnt;\n\n\t\t\tif (s == NULL) {\n\t\t\t\tms->search.s_len = 0;\n\t\t\t\tms->search.s = NULL;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (m->str_flags & REGEX_LINE_COUNT) {\n\t\t\t\tlinecnt = m->str_range;\n\t\t\t\tbytecnt = linecnt * 80;\n\t\t\t} else {\n\t\t\t\tlinecnt = 0;\n\t\t\t\tbytecnt = m->str_range;\n\t\t\t}\n\n\t\t\tif (bytecnt == 0)\n\t\t\t\tbytecnt = 8192;\n\t\t\tif (bytecnt > nbytes)\n\t\t\t\tbytecnt = nbytes;\n\n\t\t\tbuf = RCAST(const char *, s) + offset;\n\t\t\tend = last = RCAST(const char *, s) + bytecnt;\n\t\t\t/* mget() guarantees buf <= last */\n\t\t\tfor (lines = linecnt, b = buf; lines && b < end &&\n\t\t\t     ((b = CAST(const char *,\n\t\t\t\t memchr(c = b, '\\n', CAST(size_t, (end - b)))))\n\t\t\t     || (b = CAST(const char *,\n\t\t\t\t memchr(c, '\\r', CAST(size_t, (end - c))))));\n\t\t\t     lines--, b++) {\n\t\t\t\tlast = b;\n\t\t\t\tif (b[0] == '\\r' && b[1] == '\\n')\n\t\t\t\t\tb++;\n\t\t\t}\n\t\t\tif (lines)\n\t\t\t\tlast = RCAST(const char *, s) + bytecnt;\n\n\t\t\tms->search.s = buf;\n\t\t\tms->search.s_len = last - buf;\n\t\t\tms->search.offset = offset;\n\t\t\tms->search.rm_len = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tcase FILE_BESTRING16:\n\t\tcase FILE_LESTRING16: {\n\t\t\tconst unsigned char *src = s + offset;\n\t\t\tconst unsigned char *esrc = s + nbytes;\n\t\t\tchar *dst = p->s;\n\t\t\tchar *edst = &p->s[sizeof(p->s) - 1];\n\n\t\t\tif (type == FILE_BESTRING16)\n\t\t\t\tsrc++;\n\n\t\t\t/* check that offset is within range */\n\t\t\tif (offset >= nbytes)\n\t\t\t\tbreak;\n\t\t\tfor (/*EMPTY*/; src < esrc; src += 2, dst++) {\n\t\t\t\tif (dst < edst)\n\t\t\t\t\t*dst = *src;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t\tif (*dst == '\\0') {\n\t\t\t\t\tif (type == FILE_BESTRING16 ?\n\t\t\t\t\t    *(src - 1) != '\\0' :\n\t\t\t\t\t    *(src + 1) != '\\0')\n\t\t\t\t\t\t*dst = ' ';\n\t\t\t\t}\n\t\t\t}\n\t\t\t*edst = '\\0';\n\t\t\treturn 0;\n\t\t}\n\t\tcase FILE_STRING:\t/* XXX - these two should not need */\n\t\tcase FILE_PSTRING:\t/* to copy anything, but do anyway. */\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (offset >= nbytes) {\n\t\t(void)memset(p, '\\0', sizeof(*p));\n\t\treturn 0;\n\t}\n\tif (nbytes - offset < sizeof(*p))\n\t\tnbytes = nbytes - offset;\n\telse\n\t\tnbytes = sizeof(*p);\n\n\t(void)memcpy(p, s + offset, nbytes);\n\n\t/*\n\t * the usefulness of padding with zeroes eludes me, it\n\t * might even cause problems\n\t */\n\tif (nbytes < sizeof(*p))\n\t\t(void)memset(((char *)(void *)p) + nbytes, '\\0',\n\t\t    sizeof(*p) - nbytes);\n\treturn 0;\n}\n\nprivate int\nmget(struct magic_set *ms, const unsigned char *s, struct magic *m,\n    size_t nbytes, size_t o, unsigned int cont_level, int mode, int text,\n    int flip, int recursion_level, int *printed_something,\n    int *need_separator, int *returnval)\n{\n\tuint32_t soffset, offset = ms->offset;\n\tuint32_t lhs;\n\tint rv, oneed_separator, in_type;\n\tchar *sbuf, *rbuf;\n\tunion VALUETYPE *p = &ms->ms_value;\n\tstruct mlist ml;\n\n\tif (recursion_level >= 20) {\n\t\tfile_error(ms, 0, \"recursion nesting exceeded\");\n\t\treturn -1;\n\t}\n\n\tif (mcopy(ms, p, m->type, m->flag & INDIR, s, (uint32_t)(offset + o),\n\t    (uint32_t)nbytes, m) == -1)\n\t\treturn -1;\n\n\tif ((ms->flags & MAGIC_DEBUG) != 0) {\n\t\tfprintf(stderr, \"mget(type=%d, flag=%x, offset=%u, o=%zu, \"\n\t\t    \"nbytes=%zu)\\n\", m->type, m->flag, offset, o, nbytes);\n\t\tmdebug(offset, (char *)(void *)p, sizeof(union VALUETYPE));\n#ifndef COMPILE_ONLY\n\t\tfile_mdump(m);\n#endif\n\t}\n\n\tif (m->flag & INDIR) {\n\t\tint off = m->in_offset;\n\t\tif (m->in_op & FILE_OPINDIRECT) {\n\t\t\tconst union VALUETYPE *q = CAST(const union VALUETYPE *,\n\t\t\t    ((const void *)(s + offset + off)));\n\t\t\tswitch (cvt_flip(m->in_type, flip)) {\n\t\t\tcase FILE_BYTE:\n\t\t\t\toff = q->b;\n\t\t\t\tbreak;\n\t\t\tcase FILE_SHORT:\n\t\t\t\toff = q->h;\n\t\t\t\tbreak;\n\t\t\tcase FILE_BESHORT:\n\t\t\t\toff = (short)((q->hs[0]<<8)|(q->hs[1]));\n\t\t\t\tbreak;\n\t\t\tcase FILE_LESHORT:\n\t\t\t\toff = (short)((q->hs[1]<<8)|(q->hs[0]));\n\t\t\t\tbreak;\n\t\t\tcase FILE_LONG:\n\t\t\t\toff = q->l;\n\t\t\t\tbreak;\n\t\t\tcase FILE_BELONG:\n\t\t\tcase FILE_BEID3:\n\t\t\t\toff = (int32_t)((q->hl[0]<<24)|(q->hl[1]<<16)|\n\t\t\t\t\t\t (q->hl[2]<<8)|(q->hl[3]));\n\t\t\t\tbreak;\n\t\t\tcase FILE_LEID3:\n\t\t\tcase FILE_LELONG:\n\t\t\t\toff = (int32_t)((q->hl[3]<<24)|(q->hl[2]<<16)|\n\t\t\t\t\t\t (q->hl[1]<<8)|(q->hl[0]));\n\t\t\t\tbreak;\n\t\t\tcase FILE_MELONG:\n\t\t\t\toff = (int32_t)((q->hl[1]<<24)|(q->hl[0]<<16)|\n\t\t\t\t\t\t (q->hl[3]<<8)|(q->hl[2]));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\tfprintf(stderr, \"indirect offs=%u\\n\", off);\n\t\t}\n\t\tswitch (in_type = cvt_flip(m->in_type, flip)) {\n\t\tcase FILE_BYTE:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 1))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = p->b & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = p->b | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = p->b ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = p->b + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = p->b - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = p->b * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = p->b / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = p->b % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = p->b;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_BESHORT:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 2))\n\t\t\t\treturn 0;\n\t\t\tlhs = (p->hs[0] << 8) | p->hs[1];\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = lhs & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = lhs | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = lhs ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = lhs + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = lhs - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = lhs * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = lhs / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = lhs % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = lhs;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_LESHORT:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 2))\n\t\t\t\treturn 0;\n\t\t\tlhs = (p->hs[1] << 8) | p->hs[0];\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = lhs & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = lhs | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = lhs ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = lhs + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = lhs - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = lhs * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = lhs / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = lhs % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = lhs;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_SHORT:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 2))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = p->h & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = p->h | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = p->h ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = p->h + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = p->h - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = p->h * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = p->h / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = p->h % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\toffset = p->h;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_BELONG:\n\t\tcase FILE_BEID3:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 4))\n\t\t\t\treturn 0;\n\t\t\tlhs = (p->hl[0] << 24) | (p->hl[1] << 16) |\n\t\t\t    (p->hl[2] << 8) | p->hl[3];\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = lhs & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = lhs | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = lhs ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = lhs + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = lhs - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = lhs * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = lhs / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = lhs % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = lhs;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_LELONG:\n\t\tcase FILE_LEID3:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 4))\n\t\t\t\treturn 0;\n\t\t\tlhs = (p->hl[3] << 24) | (p->hl[2] << 16) |\n\t\t\t    (p->hl[1] << 8) | p->hl[0];\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = lhs & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = lhs | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = lhs ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = lhs + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = lhs - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = lhs * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = lhs / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = lhs % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = lhs;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_MELONG:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 4))\n\t\t\t\treturn 0;\n\t\t\tlhs = (p->hl[1] << 24) | (p->hl[0] << 16) |\n\t\t\t    (p->hl[3] << 8) | p->hl[2];\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = lhs & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = lhs | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = lhs ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = lhs + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = lhs - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = lhs * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = lhs / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = lhs % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = lhs;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tcase FILE_LONG:\n\t\t\tif (OFFSET_OOB(nbytes, offset, 4))\n\t\t\t\treturn 0;\n\t\t\tif (off) {\n\t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\t\t\tcase FILE_OPAND:\n\t\t\t\t\toffset = p->l & off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPOR:\n\t\t\t\t\toffset = p->l | off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPXOR:\n\t\t\t\t\toffset = p->l ^ off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPADD:\n\t\t\t\t\toffset = p->l + off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMINUS:\n\t\t\t\t\toffset = p->l - off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMULTIPLY:\n\t\t\t\t\toffset = p->l * off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPDIVIDE:\n\t\t\t\t\toffset = p->l / off;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FILE_OPMODULO:\n\t\t\t\t\toffset = p->l % off;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\toffset = p->l;\n\t\t\tif (m->in_op & FILE_OPINVERSE)\n\t\t\t\toffset = ~offset;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (in_type) {\n\t\tcase FILE_LEID3:\n\t\tcase FILE_BEID3:\n\t\t\toffset = ((((offset >>  0) & 0x7f) <<  0) |\n\t\t\t\t (((offset >>  8) & 0x7f) <<  7) |\n\t\t\t\t (((offset >> 16) & 0x7f) << 14) |\n\t\t\t\t (((offset >> 24) & 0x7f) << 21)) + 10;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (m->flag & INDIROFFADD) {\n\t\t\toffset += ms->c.li[cont_level-1].off;\n\t\t\tif (offset == 0) {\n\t\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t    \"indirect *zero* offset\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\tfprintf(stderr, \"indirect +offs=%u\\n\", offset);\n\t\t}\n\t\tif (mcopy(ms, p, m->type, 0, s, offset, nbytes, m) == -1)\n\t\t\treturn -1;\n\t\tms->offset = offset;\n\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0) {\n\t\t\tmdebug(offset, (char *)(void *)p,\n\t\t\t    sizeof(union VALUETYPE));\n#ifndef COMPILE_ONLY\n\t\t\tfile_mdump(m);\n#endif\n\t\t}\n\t}\n\n\t/* Verify we have enough data to match magic type */\n\tswitch (m->type) {\n\tcase FILE_BYTE:\n\t\tif (OFFSET_OOB(nbytes, offset, 1))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_SHORT:\n\tcase FILE_BESHORT:\n\tcase FILE_LESHORT:\n\t\tif (OFFSET_OOB(nbytes, offset, 2))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_LONG:\n\tcase FILE_BELONG:\n\tcase FILE_LELONG:\n\tcase FILE_MELONG:\n\tcase FILE_DATE:\n\tcase FILE_BEDATE:\n\tcase FILE_LEDATE:\n\tcase FILE_MEDATE:\n\tcase FILE_LDATE:\n\tcase FILE_BELDATE:\n\tcase FILE_LELDATE:\n\tcase FILE_MELDATE:\n\tcase FILE_FLOAT:\n\tcase FILE_BEFLOAT:\n\tcase FILE_LEFLOAT:\n\t\tif (OFFSET_OOB(nbytes, offset, 4))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_DOUBLE:\n\tcase FILE_BEDOUBLE:\n\tcase FILE_LEDOUBLE:\n\t\tif (OFFSET_OOB(nbytes, offset, 8))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_STRING:\n\tcase FILE_PSTRING:\n\tcase FILE_SEARCH:\n\t\tif (OFFSET_OOB(nbytes, offset, m->vallen))\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_REGEX:\n\t\tif (nbytes < offset)\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_INDIRECT:\n\t\tif (offset == 0)\n\t\t\treturn 0;\n\t\tif (nbytes < offset)\n\t\t\treturn 0;\n\t\tsbuf = ms->o.buf;\n\t\tsoffset = ms->offset;\n\t\tms->o.buf = NULL;\n\t\tms->offset = 0;\n\t\trv = file_softmagic(ms, s + offset, nbytes - offset,\n\t\t    recursion_level, BINTEST, text);\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\tfprintf(stderr, \"indirect @offs=%u[%d]\\n\", offset, rv);\n\t\trbuf = ms->o.buf;\n\t\tms->o.buf = sbuf;\n\t\tms->offset = soffset;\n\t\tif (rv == 1) {\n\t\t\tif ((ms->flags & (MAGIC_MIME|MAGIC_APPLE)) == 0 &&\n\t\t\t    file_printf(ms, F(ms, m, \"%u\"), offset) == -1) {\n\t\t\t\tfree(rbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (file_printf(ms, \"%s\", rbuf) == -1) {\n\t\t\t\tfree(rbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(rbuf);\n\t\treturn rv;\n\n\tcase FILE_USE:\n\t\tif (nbytes < offset)\n\t\t\treturn 0;\n\t\tsbuf = m->value.s;\n\t\tif (*sbuf == '^') {\n\t\t\tsbuf++;\n\t\t\tflip = !flip;\n\t\t}\n\t\tif (file_magicfind(ms, sbuf, &ml) == -1) {\n\t\t\tfile_error(ms, 0, \"cannot find entry `%s'\", sbuf);\n\t\t\treturn -1;\n\t\t}\n\n\t\toneed_separator = *need_separator;\n\t\tif (m->flag & NOSPACE)\n\t\t\t*need_separator = 0;\n\t\trv = match(ms, ml.magic, ml.nmagic, s, nbytes, offset + o,\n\t\t    mode, text, flip, recursion_level, printed_something,\n\t\t    need_separator, returnval);\n\t\tif (rv != 1)\n\t\t    *need_separator = oneed_separator;\n\t\treturn rv;\n\n\tcase FILE_NAME:\n\t\tif (file_printf(ms, \"%s\", m->desc) == -1)\n\t\t\treturn -1;\n\t\treturn 1;\n\tcase FILE_DEFAULT:\t/* nothing to check */\n\tcase FILE_CLEAR:\n\tdefault:\n\t\tbreak;\n\t}\n\tif (!mconvert(ms, m, flip))\n\t\treturn 0;\n\treturn 1;\n}\n\nprivate uint64_t\nfile_strncmp(const char *s1, const char *s2, size_t len, uint32_t flags)\n{\n\t/*\n\t * Convert the source args to unsigned here so that (1) the\n\t * compare will be unsigned as it is in strncmp() and (2) so\n\t * the ctype functions will work correctly without extra\n\t * casting.\n\t */\n\tconst unsigned char *a = (const unsigned char *)s1;\n\tconst unsigned char *b = (const unsigned char *)s2;\n\tuint64_t v;\n\n\t/*\n\t * What we want here is v = strncmp(s1, s2, len),\n\t * but ignoring any nulls.\n\t */\n\tv = 0;\n\tif (0L == flags) { /* normal string: do it fast */\n\t\twhile (len-- > 0)\n\t\t\tif ((v = *b++ - *a++) != '\\0')\n\t\t\t\tbreak;\n\t}\n\telse { /* combine the others */\n\t\twhile (len-- > 0) {\n\t\t\tif ((flags & STRING_IGNORE_LOWERCASE) &&\n\t\t\t    islower(*a)) {\n\t\t\t\tif ((v = tolower(*b++) - *a++) != '\\0')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if ((flags & STRING_IGNORE_UPPERCASE) &&\n\t\t\t    isupper(*a)) {\n\t\t\t\tif ((v = toupper(*b++) - *a++) != '\\0')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if ((flags & STRING_COMPACT_WHITESPACE) &&\n\t\t\t    isspace(*a)) {\n\t\t\t\ta++;\n\t\t\t\tif (isspace(*b++)) {\n\t\t\t\t\tif (!isspace(*a))\n\t\t\t\t\t\twhile (isspace(*b))\n\t\t\t\t\t\t\tb++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tv = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ((flags & STRING_COMPACT_OPTIONAL_WHITESPACE) &&\n\t\t\t    isspace(*a)) {\n\t\t\t\ta++;\n\t\t\t\twhile (isspace(*b))\n\t\t\t\t\tb++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ((v = *b++ - *a++) != '\\0')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn v;\n}\n\nprivate uint64_t\nfile_strncmp16(const char *a, const char *b, size_t len, uint32_t flags)\n{\n\t/*\n\t * XXX - The 16-bit string compare probably needs to be done\n\t * differently, especially if the flags are to be supported.\n\t * At the moment, I am unsure.\n\t */\n\tflags = 0;\n\treturn file_strncmp(a, b, len, flags);\n}\n\nprivate int\nmagiccheck(struct magic_set *ms, struct magic *m)\n{\n\tuint64_t l = m->value.q;\n\tuint64_t v;\n\tfloat fl, fv;\n\tdouble dl, dv;\n\tint matched;\n\tunion VALUETYPE *p = &ms->ms_value;\n\n\tswitch (m->type) {\n\tcase FILE_BYTE:\n\t\tv = p->b;\n\t\tbreak;\n\n\tcase FILE_SHORT:\n\tcase FILE_BESHORT:\n\tcase FILE_LESHORT:\n\t\tv = p->h;\n\t\tbreak;\n\n\tcase FILE_LONG:\n\tcase FILE_BELONG:\n\tcase FILE_LELONG:\n\tcase FILE_MELONG:\n\tcase FILE_DATE:\n\tcase FILE_BEDATE:\n\tcase FILE_LEDATE:\n\tcase FILE_MEDATE:\n\tcase FILE_LDATE:\n\tcase FILE_BELDATE:\n\tcase FILE_LELDATE:\n\tcase FILE_MELDATE:\n\t\tv = p->l;\n\t\tbreak;\n\n\tcase FILE_QUAD:\n\tcase FILE_LEQUAD:\n\tcase FILE_BEQUAD:\n\tcase FILE_QDATE:\n\tcase FILE_BEQDATE:\n\tcase FILE_LEQDATE:\n\tcase FILE_QLDATE:\n\tcase FILE_BEQLDATE:\n\tcase FILE_LEQLDATE:\n\tcase FILE_QWDATE:\n\tcase FILE_BEQWDATE:\n\tcase FILE_LEQWDATE:\n\t\tv = p->q;\n\t\tbreak;\n\n\tcase FILE_FLOAT:\n\tcase FILE_BEFLOAT:\n\tcase FILE_LEFLOAT:\n\t\tfl = m->value.f;\n\t\tfv = p->f;\n\t\tswitch (m->reln) {\n\t\tcase 'x':\n\t\t\tmatched = 1;\n\t\t\tbreak;\n\n\t\tcase '!':\n\t\t\tmatched = fv != fl;\n\t\t\tbreak;\n\n\t\tcase '=':\n\t\t\tmatched = fv == fl;\n\t\t\tbreak;\n\n\t\tcase '>':\n\t\t\tmatched = fv > fl;\n\t\t\tbreak;\n\n\t\tcase '<':\n\t\t\tmatched = fv < fl;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfile_magerror(ms, \"cannot happen with float: invalid relation `%c'\",\n\t\t\t    m->reln);\n\t\t\treturn -1;\n\t\t}\n\t\treturn matched;\n\n\tcase FILE_DOUBLE:\n\tcase FILE_BEDOUBLE:\n\tcase FILE_LEDOUBLE:\n\t\tdl = m->value.d;\n\t\tdv = p->d;\n\t\tswitch (m->reln) {\n\t\tcase 'x':\n\t\t\tmatched = 1;\n\t\t\tbreak;\n\n\t\tcase '!':\n\t\t\tmatched = dv != dl;\n\t\t\tbreak;\n\n\t\tcase '=':\n\t\t\tmatched = dv == dl;\n\t\t\tbreak;\n\n\t\tcase '>':\n\t\t\tmatched = dv > dl;\n\t\t\tbreak;\n\n\t\tcase '<':\n\t\t\tmatched = dv < dl;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfile_magerror(ms, \"cannot happen with double: invalid relation `%c'\", m->reln);\n\t\t\treturn -1;\n\t\t}\n\t\treturn matched;\n\n\tcase FILE_DEFAULT:\n\tcase FILE_CLEAR:\n\t\tl = 0;\n\t\tv = 0;\n\t\tbreak;\n\n\tcase FILE_STRING:\n\tcase FILE_PSTRING:\n\t\tl = 0;\n\t\tv = file_strncmp(m->value.s, p->s, (size_t)m->vallen, m->str_flags);\n\t\tbreak;\n\n\tcase FILE_BESTRING16:\n\tcase FILE_LESTRING16:\n\t\tl = 0;\n\t\tv = file_strncmp16(m->value.s, p->s, (size_t)m->vallen, m->str_flags);\n\t\tbreak;\n\n\tcase FILE_SEARCH: { /* search ms->search.s for the string m->value.s */\n\t\tsize_t slen;\n\t\tsize_t idx;\n\n\t\tif (ms->search.s == NULL)\n\t\t\treturn 0;\n\n\t\tslen = MIN(m->vallen, sizeof(m->value.s));\n\t\tl = 0;\n\t\tv = 0;\n\n\t\tfor (idx = 0; m->str_range == 0 || idx < m->str_range; idx++) {\n\t\t\tif (slen + idx > ms->search.s_len)\n\t\t\t\tbreak;\n\n\t\t\tv = file_strncmp(m->value.s, ms->search.s + idx, slen,\n\t\t\t    m->str_flags);\n\t\t\tif (v == 0) {\t/* found match */\n\t\t\t\tms->search.offset += idx;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase FILE_REGEX: {\n\t\tint rc;\n\t\tfile_regex_t rx;\n\n\t\tif (ms->search.s == NULL)\n\t\t\treturn 0;\n\n\t\tl = 0;\n\t\trc = file_regcomp(&rx, m->value.s,\n\t\t    REG_EXTENDED|REG_NEWLINE|\n\t\t    ((m->str_flags & STRING_IGNORE_CASE) ? REG_ICASE : 0));\n\t\tif (rc) {\n\t\t\tfile_regerror(&rx, rc, ms);\n\t\t\tv = (uint64_t)-1;\n\t\t} else {\n\t\t\tregmatch_t pmatch[1];\n\t\t\tsize_t slen = ms->search.s_len;\n#ifndef REG_STARTEND\n#define\tREG_STARTEND\t0\n\t\t\tchar c;\n\t\t\tif (slen != 0)\n\t\t\t\tslen--;\n\t\t\tc = ms->search.s[slen];\n\t\t\t((char *)(intptr_t)ms->search.s)[slen] = '\\0';\n#else\n\t\t\tpmatch[0].rm_so = 0;\n\t\t\tpmatch[0].rm_eo = slen;\n#endif\n\t\t\trc = file_regexec(&rx, (const char *)ms->search.s,\n\t\t\t    1, pmatch, REG_STARTEND);\n#if REG_STARTEND == 0\n\t\t\t((char *)(intptr_t)ms->search.s)[l] = c;\n#endif\n\t\t\tswitch (rc) {\n\t\t\tcase 0:\n\t\t\t\tms->search.s += (int)pmatch[0].rm_so;\n\t\t\t\tms->search.offset += (size_t)pmatch[0].rm_so;\n\t\t\t\tms->search.rm_len =\n\t\t\t\t    (size_t)(pmatch[0].rm_eo - pmatch[0].rm_so);\n\t\t\t\tv = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase REG_NOMATCH:\n\t\t\t\tv = 1;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tfile_regerror(&rx, rc, ms);\n\t\t\t\tv = (uint64_t)-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfile_regfree(&rx);\n\t\tif (v == (uint64_t)-1)\n\t\t\treturn -1;\n\t\tbreak;\n\t}\n\tcase FILE_INDIRECT:\n\tcase FILE_USE:\n\tcase FILE_NAME:\n\t\treturn 1;\n\tdefault:\n\t\tfile_magerror(ms, \"invalid type %d in magiccheck()\", m->type);\n\t\treturn -1;\n\t}\n\n\tv = file_signextend(ms, m, v);\n\n\tswitch (m->reln) {\n\tcase 'x':\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t(void) fprintf(stderr, \"%\" INT64_T_FORMAT\n\t\t\t    \"u == *any* = 1\\n\", (unsigned long long)v);\n\t\tmatched = 1;\n\t\tbreak;\n\n\tcase '!':\n\t\tmatched = v != l;\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t(void) fprintf(stderr, \"%\" INT64_T_FORMAT \"u != %\"\n\t\t\t    INT64_T_FORMAT \"u = %d\\n\", (unsigned long long)v,\n\t\t\t    (unsigned long long)l, matched);\n\t\tbreak;\n\n\tcase '=':\n\t\tmatched = v == l;\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t(void) fprintf(stderr, \"%\" INT64_T_FORMAT \"u == %\"\n\t\t\t    INT64_T_FORMAT \"u = %d\\n\", (unsigned long long)v,\n\t\t\t    (unsigned long long)l, matched);\n\t\tbreak;\n\n\tcase '>':\n\t\tif (m->flag & UNSIGNED) {\n\t\t\tmatched = v > l;\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\t(void) fprintf(stderr, \"%\" INT64_T_FORMAT\n\t\t\t\t    \"u > %\" INT64_T_FORMAT \"u = %d\\n\",\n\t\t\t\t    (unsigned long long)v,\n\t\t\t\t    (unsigned long long)l, matched);\n\t\t}\n\t\telse {\n\t\t\tmatched = (int64_t) v > (int64_t) l;\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\t(void) fprintf(stderr, \"%\" INT64_T_FORMAT\n\t\t\t\t    \"d > %\" INT64_T_FORMAT \"d = %d\\n\",\n\t\t\t\t    (long long)v, (long long)l, matched);\n\t\t}\n\t\tbreak;\n\n\tcase '<':\n\t\tif (m->flag & UNSIGNED) {\n\t\t\tmatched = v < l;\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\t(void) fprintf(stderr, \"%\" INT64_T_FORMAT\n\t\t\t\t    \"u < %\" INT64_T_FORMAT \"u = %d\\n\",\n\t\t\t\t    (unsigned long long)v,\n\t\t\t\t    (unsigned long long)l, matched);\n\t\t}\n\t\telse {\n\t\t\tmatched = (int64_t) v < (int64_t) l;\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\t(void) fprintf(stderr, \"%\" INT64_T_FORMAT\n\t\t\t\t    \"d < %\" INT64_T_FORMAT \"d = %d\\n\",\n\t\t\t\t     (long long)v, (long long)l, matched);\n\t\t}\n\t\tbreak;\n\n\tcase '&':\n\t\tmatched = (v & l) == l;\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t(void) fprintf(stderr, \"((%\" INT64_T_FORMAT \"x & %\"\n\t\t\t    INT64_T_FORMAT \"x) == %\" INT64_T_FORMAT\n\t\t\t    \"x) = %d\\n\", (unsigned long long)v,\n\t\t\t    (unsigned long long)l, (unsigned long long)l,\n\t\t\t    matched);\n\t\tbreak;\n\n\tcase '^':\n\t\tmatched = (v & l) != l;\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t(void) fprintf(stderr, \"((%\" INT64_T_FORMAT \"x & %\"\n\t\t\t    INT64_T_FORMAT \"x) != %\" INT64_T_FORMAT\n\t\t\t    \"x) = %d\\n\", (unsigned long long)v,\n\t\t\t    (unsigned long long)l, (unsigned long long)l,\n\t\t\t    matched);\n\t\tbreak;\n\n\tdefault:\n\t\tfile_magerror(ms, \"cannot happen: invalid relation `%c'\",\n\t\t    m->reln);\n\t\treturn -1;\n\t}\n\n\treturn matched;\n}\n\nprivate int\nhandle_annotation(struct magic_set *ms, struct magic *m)\n{\n\tif (ms->flags & MAGIC_APPLE) {\n\t\tif (file_printf(ms, \"%.8s\", m->apple) == -1)\n\t\t\treturn -1;\n\t\treturn 1;\n\t}\n\tif ((ms->flags & MAGIC_MIME_TYPE) && m->mimetype[0]) {\n\t\tif (file_printf(ms, \"%s\", m->mimetype) == -1)\n\t\t\treturn -1;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nprivate int\nprint_sep(struct magic_set *ms, int firstline)\n{\n\tif (ms->flags & MAGIC_MIME)\n\t\treturn 0;\n\tif (firstline)\n\t\treturn 0;\n\t/*\n\t * we found another match\n\t * put a newline and '-' to do some simple formatting\n\t */\n\treturn file_printf(ms, \"\\n- \");\n}\n"], "filenames": ["ChangeLog", "doc/magic.man", "magic/Magdir/android", "magic/Magdir/fortran", "magic/Magdir/graphviz", "magic/Magdir/marc21", "magic/Magdir/scientific", "magic/Magdir/troff", "src/apprentice.c", "src/file.h", "src/softmagic.c"], "buggy_code_start_loc": [0, 1, 3, 3, 3, 15, 3, 3, 35, 30, 35], "buggy_code_end_loc": [0, 408, 101, 6, 12, 28, 100, 22, 1879, 323, 1941], "fixing_code_start_loc": [1, 1, 3, 3, 3, 15, 3, 3, 35, 30, 35], "fixing_code_end_loc": [10, 421, 101, 6, 12, 28, 100, 22, 1886, 325, 1956], "type": "CWE-399", "message": "file before 5.19 does not properly restrict the amount of data read during a regex search, which allows remote attackers to cause a denial of service (CPU consumption) via a crafted file that triggers backtracking during processing of an awk rule.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2013-7345.", "other": {"cve": {"id": "CVE-2014-3538", "sourceIdentifier": "secalert@redhat.com", "published": "2014-07-03T14:55:07.537", "lastModified": "2023-01-19T16:34:16.133", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "file before 5.19 does not properly restrict the amount of data read during a regex search, which allows remote attackers to cause a denial of service (CPU consumption) via a crafted file that triggers backtracking during processing of an awk rule.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2013-7345."}, {"lang": "es", "value": "file anterior a 5.19 no restringe debidamente la cantidad de datos le\u00eddos durante una b\u00fasqueda regex, lo que permite a atacantes remotos causar una denegaci\u00f3n de servicio (consumo de CPU) a trav\u00e9s de un fichero manipulado que provoca un retroceso durante el procesamiento de una norma awk. NOTA: esta vulnerabilidad existe debido a una soluciona incompleta para CVE-2013-7345."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-399"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:christos_zoulas:file:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.18", "matchCriteriaId": "FCDEA321-FC13-42AE-9250-0C6055D9B280"}, {"vulnerable": true, "criteria": "cpe:2.3:a:christos_zoulas:file:5.00:*:*:*:*:*:*:*", "matchCriteriaId": "F6FF256D-3DD4-41A8-B119-D20A493A6EA5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:christos_zoulas:file:5.01:*:*:*:*:*:*:*", "matchCriteriaId": "F1981126-D773-49B6-BD3D-F17BC37352CC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:christos_zoulas:file:5.02:*:*:*:*:*:*:*", "matchCriteriaId": "00EF31A2-E788-4111-8C46-DB6C8F8724C0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:christos_zoulas:file:5.03:*:*:*:*:*:*:*", "matchCriteriaId": "1587EAB1-5322-4264-A7E5-D70DA68F6B80"}, {"vulnerable": true, "criteria": "cpe:2.3:a:christos_zoulas:file:5.04:*:*:*:*:*:*:*", "matchCriteriaId": "DC514A20-168F-4653-8BBA-D068ACA3D2E8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:christos_zoulas:file:5.05:*:*:*:*:*:*:*", "matchCriteriaId": "DE0F4E1A-EA88-4858-9431-E82B2D415FB5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:christos_zoulas:file:5.06:*:*:*:*:*:*:*", "matchCriteriaId": "F7D0625D-452F-4CE1-9A5F-6439AB6DE981"}, {"vulnerable": true, "criteria": "cpe:2.3:a:christos_zoulas:file:5.07:*:*:*:*:*:*:*", "matchCriteriaId": "ECBFF148-DEAA-4D7C-9CFC-556FEADAB619"}, {"vulnerable": true, "criteria": "cpe:2.3:a:christos_zoulas:file:5.08:*:*:*:*:*:*:*", "matchCriteriaId": "C99F7C59-F1C5-4202-A86F-90173D0FCF62"}, {"vulnerable": true, "criteria": "cpe:2.3:a:christos_zoulas:file:5.09:*:*:*:*:*:*:*", "matchCriteriaId": "D0AA7E7E-60C1-40BD-AD21-5FDD92485FD2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:christos_zoulas:file:5.10:*:*:*:*:*:*:*", "matchCriteriaId": "CA4DBB2C-5C87-42C8-BA3D-FF852C467013"}, {"vulnerable": true, "criteria": "cpe:2.3:a:christos_zoulas:file:5.11:*:*:*:*:*:*:*", "matchCriteriaId": "B513E684-36C2-45D7-A166-3B42018AB79C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:christos_zoulas:file:5.12:*:*:*:*:*:*:*", "matchCriteriaId": "5BBA4D40-EE73-4F38-ABA6-3840A67F097F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:christos_zoulas:file:5.13:*:*:*:*:*:*:*", "matchCriteriaId": "8A647100-18D6-4741-B147-BBA95215BF2E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:christos_zoulas:file:5.14:*:*:*:*:*:*:*", "matchCriteriaId": "A6A554A0-AA80-419E-AEBD-6E659300316C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:christos_zoulas:file:5.15:*:*:*:*:*:*:*", "matchCriteriaId": "91B2F536-84E5-44A6-B515-2BD68E9906B3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:christos_zoulas:file:5.16:*:*:*:*:*:*:*", "matchCriteriaId": "3814C047-D9FF-44E6-94FE-29B3B0F9F53A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:christos_zoulas:file:5.17:*:*:*:*:*:*:*", "matchCriteriaId": "B56BEB99-306B-438A-81E4-212AF53D0719"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:php:php:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.4.0", "versionEndExcluding": "5.4.32", "matchCriteriaId": "8CA4B7F2-077A-4430-9C97-B9E4D6702A4E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.5.0", "versionEndExcluding": "5.5.16", "matchCriteriaId": "41894FC6-A57E-40F1-B05F-24E89B1D7810"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "16F59A04-14CF-49E2-9973-645477EA09DA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}], "references": [{"url": "http://lists.apple.com/archives/security-announce/2015/Apr/msg00001.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://mx.gw.com/pipermail/file/2014/001553.html", "source": "secalert@redhat.com", "tags": ["Broken Link"]}, {"url": "http://openwall.com/lists/oss-security/2014/06/30/7", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2014-1327.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2014-1765.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2014-1766.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2016-0760.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://secunia.com/advisories/60696", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.debian.org/security/2014/dsa-3008", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.debian.org/security/2014/dsa-3021", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.oracle.com/technetwork/security-advisory/cpuoct2017-3236626.html", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "http://www.oracle.com/technetwork/topics/security/bulletinjan2015-2370101.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.oracle.com/technetwork/topics/security/linuxbulletinapr2016-2952096.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.oracle.com/technetwork/topics/security/linuxbulletinoct2015-2719645.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/68348", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1098222", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/file/file/commit/4a284c89d6ef11aca34da65da7d673050a5ea320", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/file/file/commit/69a5a43b3b71f53b0577f41264a073f495799610", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/file/file/commit/71a8b6c0d758acb0f73e2e51421a711b5e9d6668", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/file/file/commit/74cafd7de9ec99a14f4480927580e501c8f852c3", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/file/file/commit/758e066df72fb1ac08d2eea91ddc3973d259e991", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://support.apple.com/HT204659", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/file/file/commit/4a284c89d6ef11aca34da65da7d673050a5ea320"}}