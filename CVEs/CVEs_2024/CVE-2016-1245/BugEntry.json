{"buggy_code": ["/* Router advertisement\n * Copyright (C) 2005 6WIND <jean-mickael.guerin@6wind.com>\n * Copyright (C) 1999 Kunihiro Ishiguro\n *\n * This file is part of GNU Zebra.\n *\n * GNU Zebra is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the\n * Free Software Foundation; either version 2, or (at your option) any\n * later version.\n *\n * GNU Zebra is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with GNU Zebra; see the file COPYING.  If not, write to the Free\n * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n * 02111-1307, USA.  \n */\n\n#include <zebra.h>\n\n#include \"memory.h\"\n#include \"sockopt.h\"\n#include \"thread.h\"\n#include \"if.h\"\n#include \"log.h\"\n#include \"prefix.h\"\n#include \"linklist.h\"\n#include \"command.h\"\n#include \"privs.h\"\n#include \"vrf.h\"\n\n#include \"zebra/interface.h\"\n#include \"zebra/rtadv.h\"\n#include \"zebra/debug.h\"\n#include \"zebra/rib.h\"\n#include \"zebra/zserv.h\"\n\nextern struct zebra_privs_t zserv_privs;\n\n#if defined (HAVE_IPV6) && defined (HAVE_RTADV)\n\n#ifdef OPEN_BSD\n#include <netinet/icmp6.h>\n#endif\n\n/* If RFC2133 definition is used. */\n#ifndef IPV6_JOIN_GROUP\n#define IPV6_JOIN_GROUP  IPV6_ADD_MEMBERSHIP \n#endif\n#ifndef IPV6_LEAVE_GROUP\n#define IPV6_LEAVE_GROUP IPV6_DROP_MEMBERSHIP \n#endif\n\n#define ALLNODE   \"ff02::1\"\n#define ALLROUTER \"ff02::2\"\n\nextern struct zebra_t zebrad;\n\nenum rtadv_event {RTADV_START, RTADV_STOP, RTADV_TIMER, \n\t\t  RTADV_TIMER_MSEC, RTADV_READ};\n\nstatic void rtadv_event (struct zebra_vrf *, enum rtadv_event, int);\n\nstatic int if_join_all_router (int, struct interface *);\nstatic int if_leave_all_router (int, struct interface *);\n\nstatic int\nrtadv_recv_packet (int sock, u_char *buf, int buflen,\n\t\t   struct sockaddr_in6 *from, ifindex_t *ifindex,\n\t\t   int *hoplimit)\n{\n  int ret;\n  struct msghdr msg;\n  struct iovec iov;\n  struct cmsghdr  *cmsgptr;\n  struct in6_addr dst;\n\n  char adata[1024];\n\n  /* Fill in message and iovec. */\n  msg.msg_name = (void *) from;\n  msg.msg_namelen = sizeof (struct sockaddr_in6);\n  msg.msg_iov = &iov;\n  msg.msg_iovlen = 1;\n  msg.msg_control = (void *) adata;\n  msg.msg_controllen = sizeof adata;\n  iov.iov_base = buf;\n  iov.iov_len = buflen;\n\n  /* If recvmsg fail return minus value. */\n  ret = recvmsg (sock, &msg, 0);\n  if (ret < 0)\n    return ret;\n\n  for (cmsgptr = ZCMSG_FIRSTHDR(&msg); cmsgptr != NULL;\n       cmsgptr = CMSG_NXTHDR(&msg, cmsgptr)) \n    {\n      /* I want interface index which this packet comes from. */\n      if (cmsgptr->cmsg_level == IPPROTO_IPV6 &&\n\t  cmsgptr->cmsg_type == IPV6_PKTINFO) \n\t{\n\t  struct in6_pktinfo *ptr;\n\t  \n\t  ptr = (struct in6_pktinfo *) CMSG_DATA (cmsgptr);\n\t  *ifindex = ptr->ipi6_ifindex;\n\t  memcpy(&dst, &ptr->ipi6_addr, sizeof(ptr->ipi6_addr));\n        }\n\n      /* Incoming packet's hop limit. */\n      if (cmsgptr->cmsg_level == IPPROTO_IPV6 &&\n\t  cmsgptr->cmsg_type == IPV6_HOPLIMIT)\n\t{\n\t  int *hoptr = (int *) CMSG_DATA (cmsgptr);\n\t  *hoplimit = *hoptr;\n\t}\n    }\n  return ret;\n}\n\n#define RTADV_MSG_SIZE 4096\n\n/* Send router advertisement packet. */\nstatic void\nrtadv_send_packet (int sock, struct interface *ifp)\n{\n  struct msghdr msg;\n  struct iovec iov;\n  struct cmsghdr  *cmsgptr;\n  struct in6_pktinfo *pkt;\n  struct sockaddr_in6 addr;\n#ifdef HAVE_STRUCT_SOCKADDR_DL\n  struct sockaddr_dl *sdl;\n#endif /* HAVE_STRUCT_SOCKADDR_DL */\n  static void *adata = NULL;\n  unsigned char buf[RTADV_MSG_SIZE];\n  struct nd_router_advert *rtadv;\n  int ret;\n  int len = 0;\n  struct zebra_if *zif;\n  struct rtadv_prefix *rprefix;\n  u_char all_nodes_addr[] = {0xff,0x02,0,0,0,0,0,0,0,0,0,0,0,0,0,1};\n  struct listnode *node;\n  u_int16_t pkt_RouterLifetime;\n\n  /*\n   * Allocate control message bufffer.  This is dynamic because\n   * CMSG_SPACE is not guaranteed not to call a function.  Note that\n   * the size will be different on different architectures due to\n   * differing alignment rules.\n   */\n  if (adata == NULL)\n    {\n      /* XXX Free on shutdown. */\n      adata = malloc(CMSG_SPACE(sizeof(struct in6_pktinfo)));\n\t   \n      if (adata == NULL)\n\tzlog_err(\"rtadv_send_packet: can't malloc control data\\n\");\n    }\n\n  /* Logging of packet. */\n  if (IS_ZEBRA_DEBUG_PACKET)\n    zlog_debug (\"Router advertisement send to %s\", ifp->name);\n\n  /* Fill in sockaddr_in6. */\n  memset (&addr, 0, sizeof (struct sockaddr_in6));\n  addr.sin6_family = AF_INET6;\n#ifdef SIN6_LEN\n  addr.sin6_len = sizeof (struct sockaddr_in6);\n#endif /* SIN6_LEN */\n  addr.sin6_port = htons (IPPROTO_ICMPV6);\n  IPV6_ADDR_COPY (&addr.sin6_addr, all_nodes_addr);\n\n  /* Fetch interface information. */\n  zif = ifp->info;\n\n  /* Make router advertisement message. */\n  rtadv = (struct nd_router_advert *) buf;\n\n  rtadv->nd_ra_type = ND_ROUTER_ADVERT;\n  rtadv->nd_ra_code = 0;\n  rtadv->nd_ra_cksum = 0;\n\n  rtadv->nd_ra_curhoplimit = 64;\n\n  /* RFC4191: Default Router Preference is 0 if Router Lifetime is 0. */\n  rtadv->nd_ra_flags_reserved =\n    zif->rtadv.AdvDefaultLifetime == 0 ? 0 : zif->rtadv.DefaultPreference;\n  rtadv->nd_ra_flags_reserved <<= 3;\n\n  if (zif->rtadv.AdvManagedFlag)\n    rtadv->nd_ra_flags_reserved |= ND_RA_FLAG_MANAGED;\n  if (zif->rtadv.AdvOtherConfigFlag)\n    rtadv->nd_ra_flags_reserved |= ND_RA_FLAG_OTHER;\n  if (zif->rtadv.AdvHomeAgentFlag)\n    rtadv->nd_ra_flags_reserved |= ND_RA_FLAG_HOME_AGENT;\n  /* Note that according to Neighbor Discovery (RFC 4861 [18]),\n   * AdvDefaultLifetime is by default based on the value of\n   * MaxRtrAdvInterval.  AdvDefaultLifetime is used in the Router Lifetime\n   * field of Router Advertisements.  Given that this field is expressed\n   * in seconds, a small MaxRtrAdvInterval value can result in a zero\n   * value for this field.  To prevent this, routers SHOULD keep\n   * AdvDefaultLifetime in at least one second, even if the use of\n   * MaxRtrAdvInterval would result in a smaller value. -- RFC6275, 7.5 */\n  pkt_RouterLifetime = zif->rtadv.AdvDefaultLifetime != -1 ?\n    zif->rtadv.AdvDefaultLifetime :\n    MAX (1, 0.003 * zif->rtadv.MaxRtrAdvInterval);\n  rtadv->nd_ra_router_lifetime = htons (pkt_RouterLifetime);\n  rtadv->nd_ra_reachable = htonl (zif->rtadv.AdvReachableTime);\n  rtadv->nd_ra_retransmit = htonl (0);\n\n  len = sizeof (struct nd_router_advert);\n\n  /* If both the Home Agent Preference and Home Agent Lifetime are set to\n   * their default values specified above, this option SHOULD NOT be\n   * included in the Router Advertisement messages sent by this home\n   * agent. -- RFC6275, 7.4 */\n  if\n  (\n    zif->rtadv.AdvHomeAgentFlag &&\n    (zif->rtadv.HomeAgentPreference || zif->rtadv.HomeAgentLifetime != -1)\n  )\n    {\n      struct nd_opt_homeagent_info *ndopt_hai = \n\t(struct nd_opt_homeagent_info *)(buf + len);\n      ndopt_hai->nd_opt_hai_type = ND_OPT_HA_INFORMATION;\n      ndopt_hai->nd_opt_hai_len = 1;\n      ndopt_hai->nd_opt_hai_reserved = 0;\n      ndopt_hai->nd_opt_hai_preference = htons(zif->rtadv.HomeAgentPreference);\n      /* 16-bit unsigned integer.  The lifetime associated with the home\n       * agent in units of seconds.  The default value is the same as the\n       * Router Lifetime, as specified in the main body of the Router\n       * Advertisement.  The maximum value corresponds to 18.2 hours.  A\n       * value of 0 MUST NOT be used. -- RFC6275, 7.5 */\n      ndopt_hai->nd_opt_hai_lifetime = htons\n      (\n        zif->rtadv.HomeAgentLifetime != -1 ?\n        zif->rtadv.HomeAgentLifetime :\n        MAX (1, pkt_RouterLifetime) /* 0 is OK for RL, but not for HAL*/\n      );\n      len += sizeof(struct nd_opt_homeagent_info);\n    }\n\n  if (zif->rtadv.AdvIntervalOption)\n    {\n      struct nd_opt_adv_interval *ndopt_adv = \n\t(struct nd_opt_adv_interval *)(buf + len);\n      ndopt_adv->nd_opt_ai_type = ND_OPT_ADV_INTERVAL;\n      ndopt_adv->nd_opt_ai_len = 1;\n      ndopt_adv->nd_opt_ai_reserved = 0;\n      ndopt_adv->nd_opt_ai_interval = htonl(zif->rtadv.MaxRtrAdvInterval);\n      len += sizeof(struct nd_opt_adv_interval);\n    }\n\n  /* Fill in prefix. */\n  for (ALL_LIST_ELEMENTS_RO (zif->rtadv.AdvPrefixList, node, rprefix))\n    {\n      struct nd_opt_prefix_info *pinfo;\n\n      pinfo = (struct nd_opt_prefix_info *) (buf + len);\n\n      pinfo->nd_opt_pi_type = ND_OPT_PREFIX_INFORMATION;\n      pinfo->nd_opt_pi_len = 4;\n      pinfo->nd_opt_pi_prefix_len = rprefix->prefix.prefixlen;\n\n      pinfo->nd_opt_pi_flags_reserved = 0;\n      if (rprefix->AdvOnLinkFlag)\n\tpinfo->nd_opt_pi_flags_reserved |= ND_OPT_PI_FLAG_ONLINK;\n      if (rprefix->AdvAutonomousFlag)\n\tpinfo->nd_opt_pi_flags_reserved |= ND_OPT_PI_FLAG_AUTO;\n      if (rprefix->AdvRouterAddressFlag)\n\tpinfo->nd_opt_pi_flags_reserved |= ND_OPT_PI_FLAG_RADDR;\n\n      pinfo->nd_opt_pi_valid_time = htonl (rprefix->AdvValidLifetime);\n      pinfo->nd_opt_pi_preferred_time = htonl (rprefix->AdvPreferredLifetime);\n      pinfo->nd_opt_pi_reserved2 = 0;\n\n      IPV6_ADDR_COPY (&pinfo->nd_opt_pi_prefix, &rprefix->prefix.prefix);\n\n#ifdef DEBUG\n      {\n\tu_char buf[INET6_ADDRSTRLEN];\n\n\tzlog_debug (\"DEBUG %s\", inet_ntop (AF_INET6, &pinfo->nd_opt_pi_prefix, \n\t           buf, INET6_ADDRSTRLEN));\n\n      }\n#endif /* DEBUG */\n\n      len += sizeof (struct nd_opt_prefix_info);\n    }\n\n  /* Hardware address. */\n  if (ifp->hw_addr_len != 0)\n    {\n      buf[len++] = ND_OPT_SOURCE_LINKADDR;\n\n      /* Option length should be rounded up to next octet if\n         the link address does not end on an octet boundary. */\n      buf[len++] = (ifp->hw_addr_len + 9) >> 3;\n\n      memcpy (buf + len, ifp->hw_addr, ifp->hw_addr_len);\n      len += ifp->hw_addr_len;\n\n      /* Pad option to end on an octet boundary. */\n      memset (buf + len, 0, -(ifp->hw_addr_len + 2) & 0x7);\n      len += -(ifp->hw_addr_len + 2) & 0x7;\n    }\n\n  /* MTU */\n  if (zif->rtadv.AdvLinkMTU)\n    {\n      struct nd_opt_mtu * opt = (struct nd_opt_mtu *) (buf + len);\n      opt->nd_opt_mtu_type = ND_OPT_MTU;\n      opt->nd_opt_mtu_len = 1;\n      opt->nd_opt_mtu_reserved = 0;\n      opt->nd_opt_mtu_mtu = htonl (zif->rtadv.AdvLinkMTU);\n      len += sizeof (struct nd_opt_mtu);\n    }\n\n  msg.msg_name = (void *) &addr;\n  msg.msg_namelen = sizeof (struct sockaddr_in6);\n  msg.msg_iov = &iov;\n  msg.msg_iovlen = 1;\n  msg.msg_control = (void *) adata;\n  msg.msg_controllen = CMSG_SPACE(sizeof(struct in6_pktinfo));\n  msg.msg_flags = 0;\n  iov.iov_base = buf;\n  iov.iov_len = len;\n\n  cmsgptr = ZCMSG_FIRSTHDR(&msg);\n  cmsgptr->cmsg_len = CMSG_LEN(sizeof(struct in6_pktinfo));\n  cmsgptr->cmsg_level = IPPROTO_IPV6;\n  cmsgptr->cmsg_type = IPV6_PKTINFO;\n\n  pkt = (struct in6_pktinfo *) CMSG_DATA (cmsgptr);\n  memset (&pkt->ipi6_addr, 0, sizeof (struct in6_addr));\n  pkt->ipi6_ifindex = ifp->ifindex;\n\n  ret = sendmsg (sock, &msg, 0);\n  if (ret < 0)\n    {\n      zlog_err (\"rtadv_send_packet: sendmsg %d (%s)\\n\",\n\t\terrno, safe_strerror(errno));\n    }\n}\n\nstatic int\nrtadv_timer (struct thread *thread)\n{\n  struct zebra_vrf *zvrf = THREAD_ARG (thread);\n  struct listnode *node, *nnode;\n  struct interface *ifp;\n  struct zebra_if *zif;\n  int period;\n\n  zvrf->rtadv.ra_timer = NULL;\n  if (zvrf->rtadv.adv_msec_if_count == 0)\n    {\n      period = 1000; /* 1 s */\n      rtadv_event (zvrf, RTADV_TIMER, 1 /* 1 s */);\n    } \n  else\n    {\n      period = 10; /* 10 ms */\n      rtadv_event (zvrf, RTADV_TIMER_MSEC, 10 /* 10 ms */);\n    }\n\n  for (ALL_LIST_ELEMENTS (vrf_iflist (zvrf->vrf_id), node, nnode, ifp))\n    {\n      if (if_is_loopback (ifp) || ! if_is_operative (ifp))\n\tcontinue;\n\n      zif = ifp->info;\n\n      if (zif->rtadv.AdvSendAdvertisements)\n\t{ \n\t  zif->rtadv.AdvIntervalTimer -= period;\n\t  if (zif->rtadv.AdvIntervalTimer <= 0)\n\t    {\n\t      /* FIXME: using MaxRtrAdvInterval each time isn't what section\n\t         6.2.4 of RFC4861 tells to do. */\n\t      zif->rtadv.AdvIntervalTimer = zif->rtadv.MaxRtrAdvInterval;\n\t      rtadv_send_packet (zvrf->rtadv.sock, ifp);\n\t    }\n\t}\n    }\n  return 0;\n}\n\nstatic void\nrtadv_process_solicit (struct interface *ifp)\n{\n  struct zebra_vrf *zvrf = vrf_info_lookup (ifp->vrf_id);\n\n  zlog_info (\"Router solicitation received on %s vrf %u\", ifp->name, zvrf->vrf_id);\n\n  rtadv_send_packet (zvrf->rtadv.sock, ifp);\n}\n\nstatic void\nrtadv_process_advert (void)\n{\n  zlog_info (\"Router advertisement received\");\n}\n\nstatic void\nrtadv_process_packet (u_char *buf, unsigned int len, ifindex_t ifindex,\n    int hoplimit, vrf_id_t vrf_id)\n{\n  struct icmp6_hdr *icmph;\n  struct interface *ifp;\n  struct zebra_if *zif;\n\n  /* Interface search. */\n  ifp = if_lookup_by_index_vrf (ifindex, vrf_id);\n  if (ifp == NULL)\n    {\n      zlog_warn (\"Unknown interface index: %d, vrf %u\", ifindex, vrf_id);\n      return;\n    }\n\n  if (if_is_loopback (ifp))\n    return;\n\n  /* Check interface configuration. */\n  zif = ifp->info;\n  if (! zif->rtadv.AdvSendAdvertisements)\n    return;\n\n  /* ICMP message length check. */\n  if (len < sizeof (struct icmp6_hdr))\n    {\n      zlog_warn (\"Invalid ICMPV6 packet length: %d\", len);\n      return;\n    }\n\n  icmph = (struct icmp6_hdr *) buf;\n\n  /* ICMP message type check. */\n  if (icmph->icmp6_type != ND_ROUTER_SOLICIT &&\n      icmph->icmp6_type != ND_ROUTER_ADVERT)\n    {\n      zlog_warn (\"Unwanted ICMPV6 message type: %d\", icmph->icmp6_type);\n      return;\n    }\n\n  /* Hoplimit check. */\n  if (hoplimit >= 0 && hoplimit != 255)\n    {\n      zlog_warn (\"Invalid hoplimit %d for router advertisement ICMP packet\",\n\t\t hoplimit);\n      return;\n    }\n\n  /* Check ICMP message type. */\n  if (icmph->icmp6_type == ND_ROUTER_SOLICIT)\n    rtadv_process_solicit (ifp);\n  else if (icmph->icmp6_type == ND_ROUTER_ADVERT)\n    rtadv_process_advert ();\n\n  return;\n}\n\nstatic int\nrtadv_read (struct thread *thread)\n{\n  int sock;\n  int len;\n  u_char buf[RTADV_MSG_SIZE];\n  struct sockaddr_in6 from;\n  ifindex_t ifindex = 0;\n  int hoplimit = -1;\n  struct zebra_vrf *zvrf = THREAD_ARG (thread);\n\n  sock = THREAD_FD (thread);\n  zvrf->rtadv.ra_read = NULL;\n\n  /* Register myself. */\n  rtadv_event (zvrf, RTADV_READ, sock);\n\n  len = rtadv_recv_packet (sock, buf, BUFSIZ, &from, &ifindex, &hoplimit);\n\n  if (len < 0) \n    {\n      zlog_warn (\"router solicitation recv failed: %s.\", safe_strerror (errno));\n      return len;\n    }\n\n  rtadv_process_packet (buf, (unsigned)len, ifindex, hoplimit, zvrf->vrf_id);\n\n  return 0;\n}\n\nstatic int\nrtadv_make_socket (vrf_id_t vrf_id)\n{\n  int sock;\n  int ret;\n  struct icmp6_filter filter;\n\n  if ( zserv_privs.change (ZPRIVS_RAISE) )\n       zlog_err (\"rtadv_make_socket: could not raise privs, %s\",\n                  safe_strerror (errno) );\n                  \n  sock = vrf_socket (AF_INET6, SOCK_RAW, IPPROTO_ICMPV6, vrf_id);\n\n  if ( zserv_privs.change (ZPRIVS_LOWER) )\n       zlog_err (\"rtadv_make_socket: could not lower privs, %s\",\n       \t\t\t safe_strerror (errno) );\n\n  /* When we can't make ICMPV6 socket simply back.  Router\n     advertisement feature will not be supported. */\n  if (sock < 0)\n    {\n      close (sock);\n      return -1;\n    }\n\n  ret = setsockopt_ipv6_pktinfo (sock, 1);\n  if (ret < 0)\n    {\n      close (sock);\n      return ret;\n    }\n  ret = setsockopt_ipv6_multicast_loop (sock, 0);\n  if (ret < 0)\n    {\n      close (sock);\n      return ret;\n    }\n  ret = setsockopt_ipv6_unicast_hops (sock, 255);\n  if (ret < 0)\n    {\n      close (sock);\n      return ret;\n    }\n  ret = setsockopt_ipv6_multicast_hops (sock, 255);\n  if (ret < 0)\n    {\n      close (sock);\n      return ret;\n    }\n  ret = setsockopt_ipv6_hoplimit (sock, 1);\n  if (ret < 0)\n    {\n      close (sock);\n      return ret;\n    }\n\n  ICMP6_FILTER_SETBLOCKALL(&filter);\n  ICMP6_FILTER_SETPASS (ND_ROUTER_SOLICIT, &filter);\n  ICMP6_FILTER_SETPASS (ND_ROUTER_ADVERT, &filter);\n\n  ret = setsockopt (sock, IPPROTO_ICMPV6, ICMP6_FILTER, &filter,\n\t\t    sizeof (struct icmp6_filter));\n  if (ret < 0)\n    {\n      zlog_info (\"ICMP6_FILTER set fail: %s\", safe_strerror (errno));\n      return ret;\n    }\n\n  return sock;\n}\n\nstatic struct rtadv_prefix *\nrtadv_prefix_new (void)\n{\n  return XCALLOC (MTYPE_RTADV_PREFIX, sizeof (struct rtadv_prefix));\n}\n\nstatic void\nrtadv_prefix_free (struct rtadv_prefix *rtadv_prefix)\n{\n  XFREE (MTYPE_RTADV_PREFIX, rtadv_prefix);\n}\n\nstatic struct rtadv_prefix *\nrtadv_prefix_lookup (struct list *rplist, struct prefix_ipv6 *p)\n{\n  struct listnode *node;\n  struct rtadv_prefix *rprefix;\n\n  for (ALL_LIST_ELEMENTS_RO (rplist, node, rprefix))\n    if (prefix_same ((struct prefix *) &rprefix->prefix, (struct prefix *) p))\n      return rprefix;\n  return NULL;\n}\n\nstatic struct rtadv_prefix *\nrtadv_prefix_get (struct list *rplist, struct prefix_ipv6 *p)\n{\n  struct rtadv_prefix *rprefix;\n  \n  rprefix = rtadv_prefix_lookup (rplist, p);\n  if (rprefix)\n    return rprefix;\n\n  rprefix = rtadv_prefix_new ();\n  memcpy (&rprefix->prefix, p, sizeof (struct prefix_ipv6));\n  listnode_add (rplist, rprefix);\n\n  return rprefix;\n}\n\nstatic void\nrtadv_prefix_set (struct zebra_if *zif, struct rtadv_prefix *rp)\n{\n  struct rtadv_prefix *rprefix;\n  \n  rprefix = rtadv_prefix_get (zif->rtadv.AdvPrefixList, &rp->prefix);\n\n  /* Set parameters. */\n  rprefix->AdvValidLifetime = rp->AdvValidLifetime;\n  rprefix->AdvPreferredLifetime = rp->AdvPreferredLifetime;\n  rprefix->AdvOnLinkFlag = rp->AdvOnLinkFlag;\n  rprefix->AdvAutonomousFlag = rp->AdvAutonomousFlag;\n  rprefix->AdvRouterAddressFlag = rp->AdvRouterAddressFlag;\n}\n\nstatic int\nrtadv_prefix_reset (struct zebra_if *zif, struct rtadv_prefix *rp)\n{\n  struct rtadv_prefix *rprefix;\n  \n  rprefix = rtadv_prefix_lookup (zif->rtadv.AdvPrefixList, &rp->prefix);\n  if (rprefix != NULL)\n    {\n      listnode_delete (zif->rtadv.AdvPrefixList, (void *) rprefix);\n      rtadv_prefix_free (rprefix);\n      return 1;\n    }\n  else\n    return 0;\n}\n\nDEFUN (ipv6_nd_suppress_ra,\n       ipv6_nd_suppress_ra_cmd,\n       \"ipv6 nd suppress-ra\",\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Suppress Router Advertisement\\n\")\n{\n  struct interface *ifp;\n  struct zebra_if *zif;\n  struct zebra_vrf *zvrf;\n\n  ifp = vty->index;\n  zif = ifp->info;\n  zvrf = vrf_info_lookup (ifp->vrf_id);\n\n  if (if_is_loopback (ifp))\n    {\n      vty_out (vty, \"Invalid interface%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  if (zif->rtadv.AdvSendAdvertisements)\n    {\n      zif->rtadv.AdvSendAdvertisements = 0;\n      zif->rtadv.AdvIntervalTimer = 0;\n      zvrf->rtadv.adv_if_count--;\n\n      if_leave_all_router (zvrf->rtadv.sock, ifp);\n\n      if (zvrf->rtadv.adv_if_count == 0)\n        rtadv_event (zvrf, RTADV_STOP, 0);\n    }\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_ipv6_nd_suppress_ra,\n       no_ipv6_nd_suppress_ra_cmd,\n       \"no ipv6 nd suppress-ra\",\n       NO_STR\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Suppress Router Advertisement\\n\")\n{\n  struct interface *ifp;\n  struct zebra_if *zif;\n  struct zebra_vrf *zvrf;\n\n  ifp = vty->index;\n  zif = ifp->info;\n  zvrf = vrf_info_lookup (ifp->vrf_id);\n\n  if (if_is_loopback (ifp))\n    {\n      vty_out (vty, \"Invalid interface%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  if (! zif->rtadv.AdvSendAdvertisements)\n    {\n      zif->rtadv.AdvSendAdvertisements = 1;\n      zif->rtadv.AdvIntervalTimer = 0;\n      zvrf->rtadv.adv_if_count++;\n\n      if_join_all_router (zvrf->rtadv.sock, ifp);\n\n      if (zvrf->rtadv.adv_if_count == 1)\n        rtadv_event (zvrf, RTADV_START, zvrf->rtadv.sock);\n    }\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (ipv6_nd_ra_interval_msec,\n       ipv6_nd_ra_interval_msec_cmd,\n       \"ipv6 nd ra-interval msec <70-1800000>\",\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Router Advertisement interval\\n\"\n       \"Router Advertisement interval in milliseconds\\n\")\n{\n  unsigned interval;\n  struct interface *ifp = (struct interface *) vty->index;\n  struct zebra_if *zif = ifp->info;\n  struct zebra_vrf *zvrf = vrf_info_lookup (ifp->vrf_id);\n\n  VTY_GET_INTEGER_RANGE (\"router advertisement interval\", interval, argv[0], 70, 1800000);\n  if ((zif->rtadv.AdvDefaultLifetime != -1 && interval > (unsigned)zif->rtadv.AdvDefaultLifetime * 1000))\n  {\n    vty_out (vty, \"This ra-interval would conflict with configured ra-lifetime!%s\", VTY_NEWLINE);\n    return CMD_WARNING;\n  }\n\n  if (zif->rtadv.MaxRtrAdvInterval % 1000)\n    zvrf->rtadv.adv_msec_if_count--;\n\n  if (interval % 1000)\n    zvrf->rtadv.adv_msec_if_count++;\n  \n  zif->rtadv.MaxRtrAdvInterval = interval;\n  zif->rtadv.MinRtrAdvInterval = 0.33 * interval;\n  zif->rtadv.AdvIntervalTimer = 0;\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (ipv6_nd_ra_interval,\n       ipv6_nd_ra_interval_cmd,\n       \"ipv6 nd ra-interval <1-1800>\",\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Router Advertisement interval\\n\"\n       \"Router Advertisement interval in seconds\\n\")\n{\n  unsigned interval;\n  struct interface *ifp = (struct interface *) vty->index;\n  struct zebra_if *zif = ifp->info;\n  struct zebra_vrf *zvrf = vrf_info_lookup (ifp->vrf_id);\n\n  VTY_GET_INTEGER_RANGE (\"router advertisement interval\", interval, argv[0], 1, 1800);\n  if ((zif->rtadv.AdvDefaultLifetime != -1 && interval > (unsigned)zif->rtadv.AdvDefaultLifetime))\n  {\n    vty_out (vty, \"This ra-interval would conflict with configured ra-lifetime!%s\", VTY_NEWLINE);\n    return CMD_WARNING;\n  }\n\n  if (zif->rtadv.MaxRtrAdvInterval % 1000)\n    zvrf->rtadv.adv_msec_if_count--;\n\t\n  /* convert to milliseconds */\n  interval = interval * 1000; \n\t\n  zif->rtadv.MaxRtrAdvInterval = interval;\n  zif->rtadv.MinRtrAdvInterval = 0.33 * interval;\n  zif->rtadv.AdvIntervalTimer = 0;\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_ipv6_nd_ra_interval,\n       no_ipv6_nd_ra_interval_cmd,\n       \"no ipv6 nd ra-interval\",\n       NO_STR\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Router Advertisement interval\\n\")\n{\n  struct interface *ifp;\n  struct zebra_if *zif;\n  struct zebra_vrf *zvrf;\n\n  ifp = (struct interface *) vty->index;\n  zif = ifp->info;\n  zvrf = vrf_info_lookup (ifp->vrf_id);\n\n  if (zif->rtadv.MaxRtrAdvInterval % 1000)\n    zvrf->rtadv.adv_msec_if_count--;\n  \n  zif->rtadv.MaxRtrAdvInterval = RTADV_MAX_RTR_ADV_INTERVAL;\n  zif->rtadv.MinRtrAdvInterval = RTADV_MIN_RTR_ADV_INTERVAL;\n  zif->rtadv.AdvIntervalTimer = zif->rtadv.MaxRtrAdvInterval;\n\n  return CMD_SUCCESS;\n}\n\nALIAS (no_ipv6_nd_ra_interval,\n       no_ipv6_nd_ra_interval_val_cmd,\n       \"no ipv6 nd ra-interval <1-1800>\",\n       NO_STR\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Router Advertisement interval\\n\")\n\nALIAS (no_ipv6_nd_ra_interval,\n       no_ipv6_nd_ra_interval_msec_val_cmd,\n       \"no ipv6 nd ra-interval msec <1-1800000>\",\n       NO_STR\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Router Advertisement interval\\n\"\n       \"Router Advertisement interval in milliseconds\\n\")\n\nDEFUN (ipv6_nd_ra_lifetime,\n       ipv6_nd_ra_lifetime_cmd,\n       \"ipv6 nd ra-lifetime <0-9000>\",\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Router lifetime\\n\"\n       \"Router lifetime in seconds (0 stands for a non-default gw)\\n\")\n{\n  int lifetime;\n  struct interface *ifp;\n  struct zebra_if *zif;\n\n  ifp = (struct interface *) vty->index;\n  zif = ifp->info;\n\n  VTY_GET_INTEGER_RANGE (\"router lifetime\", lifetime, argv[0], 0, 9000);\n\n  /* The value to be placed in the Router Lifetime field\n   * of Router Advertisements sent from the interface,\n   * in seconds.  MUST be either zero or between\n   * MaxRtrAdvInterval and 9000 seconds. -- RFC4861, 6.2.1 */\n  if ((lifetime != 0 && lifetime * 1000 < zif->rtadv.MaxRtrAdvInterval))\n    {\n      vty_out (vty, \"This ra-lifetime would conflict with configured ra-interval%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  zif->rtadv.AdvDefaultLifetime = lifetime;\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_ipv6_nd_ra_lifetime,\n       no_ipv6_nd_ra_lifetime_cmd,\n       \"no ipv6 nd ra-lifetime\",\n       NO_STR\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Router lifetime\\n\")\n{\n  struct interface *ifp;\n  struct zebra_if *zif;\n\n  ifp = (struct interface *) vty->index;\n  zif = ifp->info;\n\n  zif->rtadv.AdvDefaultLifetime = -1;\n\n  return CMD_SUCCESS;\n}\n\nALIAS (no_ipv6_nd_ra_lifetime,\n       no_ipv6_nd_ra_lifetime_val_cmd,\n       \"no ipv6 nd ra-lifetime <0-9000>\",\n       NO_STR\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Router lifetime\\n\"\n       \"Router lifetime in seconds (0 stands for a non-default gw)\\n\")\n\nDEFUN (ipv6_nd_reachable_time,\n       ipv6_nd_reachable_time_cmd,\n       \"ipv6 nd reachable-time <1-3600000>\",\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Reachable time\\n\"\n       \"Reachable time in milliseconds\\n\")\n{\n  struct interface *ifp = (struct interface *) vty->index;\n  struct zebra_if *zif = ifp->info;\n  VTY_GET_INTEGER_RANGE (\"reachable time\", zif->rtadv.AdvReachableTime, argv[0], 1, RTADV_MAX_REACHABLE_TIME);\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_ipv6_nd_reachable_time,\n       no_ipv6_nd_reachable_time_cmd,\n       \"no ipv6 nd reachable-time\",\n       NO_STR\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Reachable time\\n\")\n{\n  struct interface *ifp;\n  struct zebra_if *zif;\n\n  ifp = (struct interface *) vty->index;\n  zif = ifp->info;\n\n  zif->rtadv.AdvReachableTime = 0;\n\n  return CMD_SUCCESS;\n}\n\nALIAS (no_ipv6_nd_reachable_time,\n       no_ipv6_nd_reachable_time_val_cmd,\n       \"no ipv6 nd reachable-time <1-3600000>\",\n       NO_STR\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Reachable time\\n\"\n       \"Reachable time in milliseconds\\n\")\n\nDEFUN (ipv6_nd_homeagent_preference,\n       ipv6_nd_homeagent_preference_cmd,\n       \"ipv6 nd home-agent-preference <0-65535>\",\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Home Agent preference\\n\"\n       \"preference value (default is 0, least preferred)\\n\")\n{\n  struct interface *ifp = (struct interface *) vty->index;\n  struct zebra_if *zif = ifp->info;\n  VTY_GET_INTEGER_RANGE (\"home agent preference\", zif->rtadv.HomeAgentPreference, argv[0], 0, 65535);\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_ipv6_nd_homeagent_preference,\n       no_ipv6_nd_homeagent_preference_cmd,\n       \"no ipv6 nd home-agent-preference\",\n       NO_STR\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Home Agent preference\\n\")\n{\n  struct interface *ifp;\n  struct zebra_if *zif;\n\n  ifp = (struct interface *) vty->index;\n  zif = ifp->info;\n\n  zif->rtadv.HomeAgentPreference = 0;\n\n  return CMD_SUCCESS;\n}\n\nALIAS (no_ipv6_nd_homeagent_preference,\n       no_ipv6_nd_homeagent_preference_val_cmd,\n       \"no ipv6 nd home-agent-preference <0-65535>\",\n       NO_STR\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Home Agent preference\\n\"\n       \"preference value (default is 0, least preferred)\\n\")\n\nDEFUN (ipv6_nd_homeagent_lifetime,\n       ipv6_nd_homeagent_lifetime_cmd,\n       \"ipv6 nd home-agent-lifetime <0-65520>\",\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Home Agent lifetime\\n\"\n       \"Home Agent lifetime in seconds (0 to track ra-lifetime)\\n\")\n{\n  struct interface *ifp = (struct interface *) vty->index;\n  struct zebra_if *zif = ifp->info;\n  VTY_GET_INTEGER_RANGE (\"home agent lifetime\", zif->rtadv.HomeAgentLifetime, argv[0], 0, RTADV_MAX_HALIFETIME);\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_ipv6_nd_homeagent_lifetime,\n       no_ipv6_nd_homeagent_lifetime_cmd,\n       \"no ipv6 nd home-agent-lifetime\",\n       NO_STR\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Home Agent lifetime\\n\")\n{\n  struct interface *ifp;\n  struct zebra_if *zif;\n\n  ifp = (struct interface *) vty->index;\n  zif = ifp->info;\n\n  zif->rtadv.HomeAgentLifetime = -1;\n\n  return CMD_SUCCESS;\n}\n\nALIAS (no_ipv6_nd_homeagent_lifetime,\n       no_ipv6_nd_homeagent_lifetime_val_cmd,\n       \"no ipv6 nd home-agent-lifetime <0-65520>\",\n       NO_STR\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Home Agent lifetime\\n\"\n       \"Home Agent lifetime in seconds (0 to track ra-lifetime)\\n\")\n\nDEFUN (ipv6_nd_managed_config_flag,\n       ipv6_nd_managed_config_flag_cmd,\n       \"ipv6 nd managed-config-flag\",\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Managed address configuration flag\\n\")\n{\n  struct interface *ifp;\n  struct zebra_if *zif;\n\n  ifp = (struct interface *) vty->index;\n  zif = ifp->info;\n\n  zif->rtadv.AdvManagedFlag = 1;\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_ipv6_nd_managed_config_flag,\n       no_ipv6_nd_managed_config_flag_cmd,\n       \"no ipv6 nd managed-config-flag\",\n       NO_STR\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Managed address configuration flag\\n\")\n{\n  struct interface *ifp;\n  struct zebra_if *zif;\n\n  ifp = (struct interface *) vty->index;\n  zif = ifp->info;\n\n  zif->rtadv.AdvManagedFlag = 0;\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (ipv6_nd_homeagent_config_flag,\n       ipv6_nd_homeagent_config_flag_cmd,\n       \"ipv6 nd home-agent-config-flag\",\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Home Agent configuration flag\\n\")\n{\n  struct interface *ifp;\n  struct zebra_if *zif;\n\n  ifp = (struct interface *) vty->index;\n  zif = ifp->info;\n\n  zif->rtadv.AdvHomeAgentFlag = 1;\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_ipv6_nd_homeagent_config_flag,\n       no_ipv6_nd_homeagent_config_flag_cmd,\n       \"no ipv6 nd home-agent-config-flag\",\n       NO_STR\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Home Agent configuration flag\\n\")\n{\n  struct interface *ifp;\n  struct zebra_if *zif;\n\n  ifp = (struct interface *) vty->index;\n  zif = ifp->info;\n\n  zif->rtadv.AdvHomeAgentFlag = 0;\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (ipv6_nd_adv_interval_config_option,\n       ipv6_nd_adv_interval_config_option_cmd,\n       \"ipv6 nd adv-interval-option\",\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Advertisement Interval Option\\n\")\n{\n  struct interface *ifp;\n  struct zebra_if *zif;\n\n  ifp = (struct interface *) vty->index;\n  zif = ifp->info;\n\n  zif->rtadv.AdvIntervalOption = 1;\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_ipv6_nd_adv_interval_config_option,\n       no_ipv6_nd_adv_interval_config_option_cmd,\n       \"no ipv6 nd adv-interval-option\",\n       NO_STR\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Advertisement Interval Option\\n\")\n{\n  struct interface *ifp;\n  struct zebra_if *zif;\n\n  ifp = (struct interface *) vty->index;\n  zif = ifp->info;\n\n  zif->rtadv.AdvIntervalOption = 0;\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (ipv6_nd_other_config_flag,\n       ipv6_nd_other_config_flag_cmd,\n       \"ipv6 nd other-config-flag\",\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Other statefull configuration flag\\n\")\n{\n  struct interface *ifp;\n  struct zebra_if *zif;\n\n  ifp = (struct interface *) vty->index;\n  zif = ifp->info;\n\n  zif->rtadv.AdvOtherConfigFlag = 1;\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_ipv6_nd_other_config_flag,\n       no_ipv6_nd_other_config_flag_cmd,\n       \"no ipv6 nd other-config-flag\",\n       NO_STR\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Other statefull configuration flag\\n\")\n{\n  struct interface *ifp;\n  struct zebra_if *zif;\n\n  ifp = (struct interface *) vty->index;\n  zif = ifp->info;\n\n  zif->rtadv.AdvOtherConfigFlag = 0;\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (ipv6_nd_prefix,\n       ipv6_nd_prefix_cmd,\n       \"ipv6 nd prefix X:X::X:X/M (<0-4294967295>|infinite) \"\n       \"(<0-4294967295>|infinite) (off-link|) (no-autoconfig|) (router-address|)\",\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Prefix information\\n\"\n       \"IPv6 prefix\\n\"\n       \"Valid lifetime in seconds\\n\"\n       \"Infinite valid lifetime\\n\"\n       \"Preferred lifetime in seconds\\n\"\n       \"Infinite preferred lifetime\\n\"\n       \"Do not use prefix for onlink determination\\n\"\n       \"Do not use prefix for autoconfiguration\\n\"\n       \"Set Router Address flag\\n\")\n{\n  int i;\n  int ret;\n  int cursor = 1;\n  struct interface *ifp;\n  struct zebra_if *zebra_if;\n  struct rtadv_prefix rp;\n\n  ifp = (struct interface *) vty->index;\n  zebra_if = ifp->info;\n\n  ret = str2prefix_ipv6 (argv[0], &rp.prefix);\n  if (!ret)\n    {\n      vty_out (vty, \"Malformed IPv6 prefix%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n  apply_mask_ipv6 (&rp.prefix); /* RFC4861 4.6.2 */\n  rp.AdvOnLinkFlag = 1;\n  rp.AdvAutonomousFlag = 1;\n  rp.AdvRouterAddressFlag = 0;\n  rp.AdvValidLifetime = RTADV_VALID_LIFETIME;\n  rp.AdvPreferredLifetime = RTADV_PREFERRED_LIFETIME;\n\n  if (argc > 1)\n    {\n      if ((isdigit((unsigned char)argv[1][0]))\n\t  || strncmp (argv[1], \"i\", 1) == 0)\n\t{\n\t  if ( strncmp (argv[1], \"i\", 1) == 0)\n\t    rp.AdvValidLifetime = UINT32_MAX;\n\t  else\n\t    rp.AdvValidLifetime = (u_int32_t) strtoll (argv[1],\n\t\t(char **)NULL, 10);\n      \n\t  if ( strncmp (argv[2], \"i\", 1) == 0)\n\t    rp.AdvPreferredLifetime = UINT32_MAX;\n\t  else\n\t    rp.AdvPreferredLifetime = (u_int32_t) strtoll (argv[2],\n\t\t(char **)NULL, 10);\n\n\t  if (rp.AdvPreferredLifetime > rp.AdvValidLifetime)\n\t    {\n\t      vty_out (vty, \"Invalid preferred lifetime%s\", VTY_NEWLINE);\n\t      return CMD_WARNING;\n\t    }\n\t  cursor = cursor + 2;\n\t}\n      if (argc > cursor)\n\t{\n\t  for (i = cursor; i < argc; i++)\n\t    {\n\t      if (strncmp (argv[i], \"of\", 2) == 0)\n\t\trp.AdvOnLinkFlag = 0;\n\t      if (strncmp (argv[i], \"no\", 2) == 0)\n\t\trp.AdvAutonomousFlag = 0;\n\t      if (strncmp (argv[i], \"ro\", 2) == 0)\n\t\trp.AdvRouterAddressFlag = 1;\n\t    }\n\t}\n    }\n\n  rtadv_prefix_set (zebra_if, &rp);\n\n  return CMD_SUCCESS;\n}\n\nALIAS (ipv6_nd_prefix,\n       ipv6_nd_prefix_val_nortaddr_cmd,\n       \"ipv6 nd prefix X:X::X:X/M (<0-4294967295>|infinite) \"\n       \"(<0-4294967295>|infinite) (off-link|) (no-autoconfig|)\",\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Prefix information\\n\"\n       \"IPv6 prefix\\n\"\n       \"Valid lifetime in seconds\\n\"\n       \"Infinite valid lifetime\\n\"\n       \"Preferred lifetime in seconds\\n\"\n       \"Infinite preferred lifetime\\n\"\n       \"Do not use prefix for onlink determination\\n\"\n       \"Do not use prefix for autoconfiguration\\n\")\n\nALIAS (ipv6_nd_prefix,\n       ipv6_nd_prefix_val_rev_cmd,\n       \"ipv6 nd prefix X:X::X:X/M (<0-4294967295>|infinite) \"\n       \"(<0-4294967295>|infinite) (no-autoconfig|) (off-link|)\",\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Prefix information\\n\"\n       \"IPv6 prefix\\n\"\n       \"Valid lifetime in seconds\\n\"\n       \"Infinite valid lifetime\\n\"\n       \"Preferred lifetime in seconds\\n\"\n       \"Infinite preferred lifetime\\n\"\n       \"Do not use prefix for autoconfiguration\\n\"\n       \"Do not use prefix for onlink determination\\n\")\n\nALIAS (ipv6_nd_prefix,\n       ipv6_nd_prefix_val_rev_rtaddr_cmd,\n       \"ipv6 nd prefix X:X::X:X/M (<0-4294967295>|infinite) \"\n       \"(<0-4294967295>|infinite) (no-autoconfig|) (off-link|) (router-address|)\",\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Prefix information\\n\"\n       \"IPv6 prefix\\n\"\n       \"Valid lifetime in seconds\\n\"\n       \"Infinite valid lifetime\\n\"\n       \"Preferred lifetime in seconds\\n\"\n       \"Infinite preferred lifetime\\n\"\n       \"Do not use prefix for autoconfiguration\\n\"\n       \"Do not use prefix for onlink determination\\n\"\n       \"Set Router Address flag\\n\")\n\nALIAS (ipv6_nd_prefix,\n       ipv6_nd_prefix_val_noauto_cmd,\n       \"ipv6 nd prefix X:X::X:X/M (<0-4294967295>|infinite) \"\n       \"(<0-4294967295>|infinite) (no-autoconfig|)\",\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Prefix information\\n\"\n       \"IPv6 prefix\\n\"\n       \"Valid lifetime in seconds\\n\"\n       \"Infinite valid lifetime\\n\"\n       \"Preferred lifetime in seconds\\n\"\n       \"Infinite preferred lifetime\\n\"\n       \"Do not use prefix for autoconfiguration\")\n\nALIAS (ipv6_nd_prefix,\n       ipv6_nd_prefix_val_offlink_cmd,\n       \"ipv6 nd prefix X:X::X:X/M (<0-4294967295>|infinite) \"\n       \"(<0-4294967295>|infinite) (off-link|)\",\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Prefix information\\n\"\n       \"IPv6 prefix\\n\"\n       \"Valid lifetime in seconds\\n\"\n       \"Infinite valid lifetime\\n\"\n       \"Preferred lifetime in seconds\\n\"\n       \"Infinite preferred lifetime\\n\"\n       \"Do not use prefix for onlink determination\\n\")\n\nALIAS (ipv6_nd_prefix,\n       ipv6_nd_prefix_val_rtaddr_cmd,\n       \"ipv6 nd prefix X:X::X:X/M (<0-4294967295>|infinite) \"\n       \"(<0-4294967295>|infinite) (router-address|)\",\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Prefix information\\n\"\n       \"IPv6 prefix\\n\"\n       \"Valid lifetime in seconds\\n\"\n       \"Infinite valid lifetime\\n\"\n       \"Preferred lifetime in seconds\\n\"\n       \"Infinite preferred lifetime\\n\"\n       \"Set Router Address flag\\n\")\n\nALIAS (ipv6_nd_prefix,\n       ipv6_nd_prefix_val_cmd,\n       \"ipv6 nd prefix X:X::X:X/M (<0-4294967295>|infinite) \"\n       \"(<0-4294967295>|infinite)\",\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Prefix information\\n\"\n       \"IPv6 prefix\\n\"\n       \"Valid lifetime in seconds\\n\"\n       \"Infinite valid lifetime\\n\"\n       \"Preferred lifetime in seconds\\n\"\n       \"Infinite preferred lifetime\\n\")\n\nALIAS (ipv6_nd_prefix,\n       ipv6_nd_prefix_noval_cmd,\n       \"ipv6 nd prefix X:X::X:X/M (no-autoconfig|) (off-link|)\",\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Prefix information\\n\"\n       \"IPv6 prefix\\n\"\n       \"Do not use prefix for autoconfiguration\\n\"\n       \"Do not use prefix for onlink determination\\n\")\n\nALIAS (ipv6_nd_prefix,\n       ipv6_nd_prefix_noval_rev_cmd,\n       \"ipv6 nd prefix X:X::X:X/M (off-link|) (no-autoconfig|)\",\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Prefix information\\n\"\n       \"IPv6 prefix\\n\"\n       \"Do not use prefix for onlink determination\\n\"\n       \"Do not use prefix for autoconfiguration\\n\")\n\nALIAS (ipv6_nd_prefix,\n       ipv6_nd_prefix_noval_noauto_cmd,\n       \"ipv6 nd prefix X:X::X:X/M (no-autoconfig|)\",\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Prefix information\\n\"\n       \"IPv6 prefix\\n\"\n       \"Do not use prefix for autoconfiguration\\n\")\n\nALIAS (ipv6_nd_prefix,\n       ipv6_nd_prefix_noval_offlink_cmd,\n       \"ipv6 nd prefix X:X::X:X/M (off-link|)\",\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Prefix information\\n\"\n       \"IPv6 prefix\\n\"\n       \"Do not use prefix for onlink determination\\n\")\n\nALIAS (ipv6_nd_prefix,\n       ipv6_nd_prefix_noval_rtaddr_cmd,\n       \"ipv6 nd prefix X:X::X:X/M (router-address|)\",\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Prefix information\\n\"\n       \"IPv6 prefix\\n\"\n       \"Set Router Address flag\\n\")\n\nALIAS (ipv6_nd_prefix,\n       ipv6_nd_prefix_prefix_cmd,\n       \"ipv6 nd prefix X:X::X:X/M\",\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Prefix information\\n\"\n       \"IPv6 prefix\\n\")\n\nDEFUN (no_ipv6_nd_prefix,\n       no_ipv6_nd_prefix_cmd,\n       \"no ipv6 nd prefix IPV6PREFIX\",\n       NO_STR\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Prefix information\\n\"\n       \"IPv6 prefix\\n\")\n{\n  int ret;\n  struct interface *ifp;\n  struct zebra_if *zebra_if;\n  struct rtadv_prefix rp;\n\n  ifp = (struct interface *) vty->index;\n  zebra_if = ifp->info;\n\n  ret = str2prefix_ipv6 (argv[0], &rp.prefix);\n  if (!ret)\n    {\n      vty_out (vty, \"Malformed IPv6 prefix%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n  apply_mask_ipv6 (&rp.prefix); /* RFC4861 4.6.2 */\n\n  ret = rtadv_prefix_reset (zebra_if, &rp);\n  if (!ret)\n    {\n      vty_out (vty, \"Non-exist IPv6 prefix%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (ipv6_nd_router_preference,\n       ipv6_nd_router_preference_cmd,\n       \"ipv6 nd router-preference (high|medium|low)\",\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Default router preference\\n\"\n       \"High default router preference\\n\"\n       \"Low default router preference\\n\"\n       \"Medium default router preference (default)\\n\")\n{\n  struct interface *ifp;\n  struct zebra_if *zif;\n  int i = 0;\n\n  ifp = (struct interface *) vty->index;\n  zif = ifp->info;\n\n  while (0 != rtadv_pref_strs[i])\n    {\n      if (strncmp (argv[0], rtadv_pref_strs[i], 1) == 0)\n\t{\n\t  zif->rtadv.DefaultPreference = i;\n\t  return CMD_SUCCESS;\n\t}\n      i++;\n    }\n\n  return CMD_ERR_NO_MATCH;\n}\n\nDEFUN (no_ipv6_nd_router_preference,\n       no_ipv6_nd_router_preference_cmd,\n       \"no ipv6 nd router-preference\",\n       NO_STR\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Default router preference\\n\")\n{\n  struct interface *ifp;\n  struct zebra_if *zif;\n\n  ifp = (struct interface *) vty->index;\n  zif = ifp->info;\n\n  zif->rtadv.DefaultPreference = RTADV_PREF_MEDIUM; /* Default per RFC4191. */\n\n  return CMD_SUCCESS;\n}\n\nALIAS (no_ipv6_nd_router_preference,\n       no_ipv6_nd_router_preference_val_cmd,\n       \"no ipv6 nd router-preference (high|medium|low)\",\n       NO_STR\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Default router preference\\n\"\n       \"High default router preference\\n\"\n       \"Low default router preference\\n\"\n       \"Medium default router preference (default)\\n\")\n\nDEFUN (ipv6_nd_mtu,\n       ipv6_nd_mtu_cmd,\n       \"ipv6 nd mtu <1-65535>\",\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Advertised MTU\\n\"\n       \"MTU in bytes\\n\")\n{\n  struct interface *ifp = (struct interface *) vty->index;\n  struct zebra_if *zif = ifp->info;\n  VTY_GET_INTEGER_RANGE (\"MTU\", zif->rtadv.AdvLinkMTU, argv[0], 1, 65535);\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_ipv6_nd_mtu,\n       no_ipv6_nd_mtu_cmd,\n       \"no ipv6 nd mtu\",\n       NO_STR\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Advertised MTU\\n\")\n{\n  struct interface *ifp = (struct interface *) vty->index;\n  struct zebra_if *zif = ifp->info;\n  zif->rtadv.AdvLinkMTU = 0;\n  return CMD_SUCCESS;\n}\n\nALIAS (no_ipv6_nd_mtu,\n       no_ipv6_nd_mtu_val_cmd,\n       \"no ipv6 nd mtu <1-65535>\",\n       NO_STR\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Advertised MTU\\n\"\n       \"MTU in bytes\\n\")\n\n/* Write configuration about router advertisement. */\nvoid\nrtadv_config_write (struct vty *vty, struct interface *ifp)\n{\n  struct zebra_if *zif;\n  struct listnode *node;\n  struct rtadv_prefix *rprefix;\n  char buf[PREFIX_STRLEN];\n  int interval;\n\n  zif = ifp->info;\n\n  if (! if_is_loopback (ifp))\n    {\n      if (zif->rtadv.AdvSendAdvertisements)\n\tvty_out (vty, \" no ipv6 nd suppress-ra%s\", VTY_NEWLINE);\n    }\n\n  \n  interval = zif->rtadv.MaxRtrAdvInterval;\n  if (interval % 1000)\n    vty_out (vty, \" ipv6 nd ra-interval msec %d%s\", interval,\n\t     VTY_NEWLINE);\n  else\n    if (interval != RTADV_MAX_RTR_ADV_INTERVAL)\n      vty_out (vty, \" ipv6 nd ra-interval %d%s\", interval / 1000,\n\t     VTY_NEWLINE);\n\n  if (zif->rtadv.AdvIntervalOption)\n    vty_out (vty, \" ipv6 nd adv-interval-option%s\", VTY_NEWLINE);\n\n  if (zif->rtadv.AdvDefaultLifetime != -1)\n    vty_out (vty, \" ipv6 nd ra-lifetime %d%s\", zif->rtadv.AdvDefaultLifetime,\n\t     VTY_NEWLINE);\n\n  if (zif->rtadv.HomeAgentPreference)\n    vty_out (vty, \" ipv6 nd home-agent-preference %u%s\",\n\t     zif->rtadv.HomeAgentPreference, VTY_NEWLINE);\n\n  if (zif->rtadv.HomeAgentLifetime != -1)\n    vty_out (vty, \" ipv6 nd home-agent-lifetime %u%s\",\n\t     zif->rtadv.HomeAgentLifetime, VTY_NEWLINE);\n\n  if (zif->rtadv.AdvHomeAgentFlag)\n    vty_out (vty, \" ipv6 nd home-agent-config-flag%s\", VTY_NEWLINE);\n\n  if (zif->rtadv.AdvReachableTime)\n    vty_out (vty, \" ipv6 nd reachable-time %d%s\", zif->rtadv.AdvReachableTime,\n\t     VTY_NEWLINE);\n\n  if (zif->rtadv.AdvManagedFlag)\n    vty_out (vty, \" ipv6 nd managed-config-flag%s\", VTY_NEWLINE);\n\n  if (zif->rtadv.AdvOtherConfigFlag)\n    vty_out (vty, \" ipv6 nd other-config-flag%s\", VTY_NEWLINE);\n\n  if (zif->rtadv.DefaultPreference != RTADV_PREF_MEDIUM)\n    vty_out (vty, \" ipv6 nd router-preference %s%s\",\n\t     rtadv_pref_strs[zif->rtadv.DefaultPreference],\n\t     VTY_NEWLINE);\n\n  if (zif->rtadv.AdvLinkMTU)\n    vty_out (vty, \" ipv6 nd mtu %d%s\", zif->rtadv.AdvLinkMTU, VTY_NEWLINE);\n\n  for (ALL_LIST_ELEMENTS_RO (zif->rtadv.AdvPrefixList, node, rprefix))\n    {\n      vty_out (vty, \" ipv6 nd prefix %s\",\n               prefix2str (&rprefix->prefix, buf, sizeof(buf)));\n      if ((rprefix->AdvValidLifetime != RTADV_VALID_LIFETIME) || \n\t  (rprefix->AdvPreferredLifetime != RTADV_PREFERRED_LIFETIME))\n\t{\n\t  if (rprefix->AdvValidLifetime == UINT32_MAX)\n\t    vty_out (vty, \" infinite\");\n\t  else\n\t    vty_out (vty, \" %u\", rprefix->AdvValidLifetime);\n\t  if (rprefix->AdvPreferredLifetime == UINT32_MAX)\n\t    vty_out (vty, \" infinite\");\n\t  else\n\t    vty_out (vty, \" %u\", rprefix->AdvPreferredLifetime);\n\t}\n      if (!rprefix->AdvOnLinkFlag)\n\tvty_out (vty, \" off-link\");\n      if (!rprefix->AdvAutonomousFlag)\n\tvty_out (vty, \" no-autoconfig\");\n      if (rprefix->AdvRouterAddressFlag)\n\tvty_out (vty, \" router-address\");\n      vty_out (vty, \"%s\", VTY_NEWLINE);\n    }\n}\n\n\nstatic void\nrtadv_event (struct zebra_vrf *zvrf, enum rtadv_event event, int val)\n{\n  struct rtadv *rtadv = &zvrf->rtadv;\n\n  switch (event)\n    {\n    case RTADV_START:\n      if (! rtadv->ra_read)\n\trtadv->ra_read = thread_add_read (zebrad.master, rtadv_read, zvrf, val);\n      if (! rtadv->ra_timer)\n\trtadv->ra_timer = thread_add_event (zebrad.master, rtadv_timer,\n\t                                    zvrf, 0);\n      break;\n    case RTADV_STOP:\n      if (rtadv->ra_timer)\n\t{\n\t  thread_cancel (rtadv->ra_timer);\n\t  rtadv->ra_timer = NULL;\n\t}\n      if (rtadv->ra_read)\n\t{\n\t  thread_cancel (rtadv->ra_read);\n\t  rtadv->ra_read = NULL;\n\t}\n      break;\n    case RTADV_TIMER:\n      if (! rtadv->ra_timer)\n\trtadv->ra_timer = thread_add_timer (zebrad.master, rtadv_timer, zvrf,\n\t                                    val);\n      break;\n    case RTADV_TIMER_MSEC:\n      if (! rtadv->ra_timer)\n\trtadv->ra_timer = thread_add_timer_msec (zebrad.master, rtadv_timer, \n\t\t\t\t\t    zvrf, val);\n      break;\n    case RTADV_READ:\n      if (! rtadv->ra_read)\n\trtadv->ra_read = thread_add_read (zebrad.master, rtadv_read, zvrf, val);\n      break;\n    default:\n      break;\n    }\n  return;\n}\n\nvoid\nrtadv_init (struct zebra_vrf *zvrf)\n{\n  zvrf->rtadv.sock = rtadv_make_socket (zvrf->vrf_id);\n}\n\nvoid\nrtadv_terminate (struct zebra_vrf *zvrf)\n{\n  rtadv_event (zvrf, RTADV_STOP, 0);\n\n  if (zvrf->rtadv.sock >= 0)\n    {\n      close (zvrf->rtadv.sock);\n      zvrf->rtadv.sock = -1;\n    }\n\n  zvrf->rtadv.adv_if_count = 0;\n  zvrf->rtadv.adv_msec_if_count = 0;\n}\n\nvoid\nrtadv_cmd_init (void)\n{\n  install_element (INTERFACE_NODE, &ipv6_nd_suppress_ra_cmd);\n  install_element (INTERFACE_NODE, &no_ipv6_nd_suppress_ra_cmd);\n  install_element (INTERFACE_NODE, &ipv6_nd_ra_interval_cmd);\n  install_element (INTERFACE_NODE, &ipv6_nd_ra_interval_msec_cmd);\n  install_element (INTERFACE_NODE, &no_ipv6_nd_ra_interval_cmd);\n  install_element (INTERFACE_NODE, &no_ipv6_nd_ra_interval_val_cmd);\n  install_element (INTERFACE_NODE, &no_ipv6_nd_ra_interval_msec_val_cmd);\n  install_element (INTERFACE_NODE, &ipv6_nd_ra_lifetime_cmd);\n  install_element (INTERFACE_NODE, &no_ipv6_nd_ra_lifetime_cmd);\n  install_element (INTERFACE_NODE, &no_ipv6_nd_ra_lifetime_val_cmd);\n  install_element (INTERFACE_NODE, &ipv6_nd_reachable_time_cmd);\n  install_element (INTERFACE_NODE, &no_ipv6_nd_reachable_time_cmd);\n  install_element (INTERFACE_NODE, &no_ipv6_nd_reachable_time_val_cmd);\n  install_element (INTERFACE_NODE, &ipv6_nd_managed_config_flag_cmd);\n  install_element (INTERFACE_NODE, &no_ipv6_nd_managed_config_flag_cmd);\n  install_element (INTERFACE_NODE, &ipv6_nd_other_config_flag_cmd);\n  install_element (INTERFACE_NODE, &no_ipv6_nd_other_config_flag_cmd);\n  install_element (INTERFACE_NODE, &ipv6_nd_homeagent_config_flag_cmd);\n  install_element (INTERFACE_NODE, &no_ipv6_nd_homeagent_config_flag_cmd);\n  install_element (INTERFACE_NODE, &ipv6_nd_homeagent_preference_cmd);\n  install_element (INTERFACE_NODE, &no_ipv6_nd_homeagent_preference_cmd);\n  install_element (INTERFACE_NODE, &no_ipv6_nd_homeagent_preference_val_cmd);\n  install_element (INTERFACE_NODE, &ipv6_nd_homeagent_lifetime_cmd);\n  install_element (INTERFACE_NODE, &no_ipv6_nd_homeagent_lifetime_cmd);\n  install_element (INTERFACE_NODE, &no_ipv6_nd_homeagent_lifetime_val_cmd);\n  install_element (INTERFACE_NODE, &ipv6_nd_adv_interval_config_option_cmd);\n  install_element (INTERFACE_NODE, &no_ipv6_nd_adv_interval_config_option_cmd);\n  install_element (INTERFACE_NODE, &ipv6_nd_prefix_cmd);\n  install_element (INTERFACE_NODE, &ipv6_nd_prefix_val_rev_rtaddr_cmd);\n  install_element (INTERFACE_NODE, &ipv6_nd_prefix_val_nortaddr_cmd);\n  install_element (INTERFACE_NODE, &ipv6_nd_prefix_val_rev_cmd);\n  install_element (INTERFACE_NODE, &ipv6_nd_prefix_val_noauto_cmd);\n  install_element (INTERFACE_NODE, &ipv6_nd_prefix_val_offlink_cmd);\n  install_element (INTERFACE_NODE, &ipv6_nd_prefix_val_rtaddr_cmd);\n  install_element (INTERFACE_NODE, &ipv6_nd_prefix_val_cmd);\n  install_element (INTERFACE_NODE, &ipv6_nd_prefix_noval_cmd);\n  install_element (INTERFACE_NODE, &ipv6_nd_prefix_noval_rev_cmd);\n  install_element (INTERFACE_NODE, &ipv6_nd_prefix_noval_noauto_cmd);\n  install_element (INTERFACE_NODE, &ipv6_nd_prefix_noval_offlink_cmd);\n  install_element (INTERFACE_NODE, &ipv6_nd_prefix_noval_rtaddr_cmd);\n  install_element (INTERFACE_NODE, &ipv6_nd_prefix_prefix_cmd);\n  install_element (INTERFACE_NODE, &no_ipv6_nd_prefix_cmd);\n  install_element (INTERFACE_NODE, &ipv6_nd_router_preference_cmd);\n  install_element (INTERFACE_NODE, &no_ipv6_nd_router_preference_cmd);\n  install_element (INTERFACE_NODE, &no_ipv6_nd_router_preference_val_cmd);\n  install_element (INTERFACE_NODE, &ipv6_nd_mtu_cmd);\n  install_element (INTERFACE_NODE, &no_ipv6_nd_mtu_cmd);\n  install_element (INTERFACE_NODE, &no_ipv6_nd_mtu_val_cmd);\n}\n\nstatic int\nif_join_all_router (int sock, struct interface *ifp)\n{\n  int ret;\n\n  struct ipv6_mreq mreq;\n\n  memset (&mreq, 0, sizeof (struct ipv6_mreq));\n  inet_pton (AF_INET6, ALLROUTER, &mreq.ipv6mr_multiaddr);\n  mreq.ipv6mr_interface = ifp->ifindex;\n\n  ret = setsockopt (sock, IPPROTO_IPV6, IPV6_JOIN_GROUP, \n\t\t    (char *) &mreq, sizeof mreq);\n  if (ret < 0)\n    zlog_warn (\"can't setsockopt IPV6_JOIN_GROUP: %s\", safe_strerror (errno));\n\n  zlog_info (\"rtadv: %s join to all-routers multicast group\", ifp->name);\n\n  return 0;\n}\n\nstatic int\nif_leave_all_router (int sock, struct interface *ifp)\n{\n  int ret;\n\n  struct ipv6_mreq mreq;\n\n  memset (&mreq, 0, sizeof (struct ipv6_mreq));\n  inet_pton (AF_INET6, ALLROUTER, &mreq.ipv6mr_multiaddr);\n  mreq.ipv6mr_interface = ifp->ifindex;\n\n  ret = setsockopt (sock, IPPROTO_IPV6, IPV6_LEAVE_GROUP, \n\t\t    (char *) &mreq, sizeof mreq);\n  if (ret < 0)\n    zlog_warn (\"can't setsockopt IPV6_LEAVE_GROUP: %s\", safe_strerror (errno));\n\n  zlog_info (\"rtadv: %s leave from all-routers multicast group\", ifp->name);\n\n  return 0;\n}\n\n#else\nvoid\nrtadv_init (struct zebra_vrf *zvrf)\n{\n  /* Empty.*/;\n}\nvoid\nrtadv_terminate (struct zebra_vrf *zvrf)\n{\n  /* Empty.*/;\n}\nvoid\nrtadv_cmd_init (void)\n{\n  /* Empty.*/;\n}\n#endif /* HAVE_RTADV && HAVE_IPV6 */\n"], "fixing_code": ["/* Router advertisement\n * Copyright (C) 2005 6WIND <jean-mickael.guerin@6wind.com>\n * Copyright (C) 1999 Kunihiro Ishiguro\n *\n * This file is part of GNU Zebra.\n *\n * GNU Zebra is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the\n * Free Software Foundation; either version 2, or (at your option) any\n * later version.\n *\n * GNU Zebra is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with GNU Zebra; see the file COPYING.  If not, write to the Free\n * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n * 02111-1307, USA.  \n */\n\n#include <zebra.h>\n\n#include \"memory.h\"\n#include \"sockopt.h\"\n#include \"thread.h\"\n#include \"if.h\"\n#include \"log.h\"\n#include \"prefix.h\"\n#include \"linklist.h\"\n#include \"command.h\"\n#include \"privs.h\"\n#include \"vrf.h\"\n\n#include \"zebra/interface.h\"\n#include \"zebra/rtadv.h\"\n#include \"zebra/debug.h\"\n#include \"zebra/rib.h\"\n#include \"zebra/zserv.h\"\n\nextern struct zebra_privs_t zserv_privs;\n\n#if defined (HAVE_IPV6) && defined (HAVE_RTADV)\n\n#ifdef OPEN_BSD\n#include <netinet/icmp6.h>\n#endif\n\n/* If RFC2133 definition is used. */\n#ifndef IPV6_JOIN_GROUP\n#define IPV6_JOIN_GROUP  IPV6_ADD_MEMBERSHIP \n#endif\n#ifndef IPV6_LEAVE_GROUP\n#define IPV6_LEAVE_GROUP IPV6_DROP_MEMBERSHIP \n#endif\n\n#define ALLNODE   \"ff02::1\"\n#define ALLROUTER \"ff02::2\"\n\nextern struct zebra_t zebrad;\n\nenum rtadv_event {RTADV_START, RTADV_STOP, RTADV_TIMER, \n\t\t  RTADV_TIMER_MSEC, RTADV_READ};\n\nstatic void rtadv_event (struct zebra_vrf *, enum rtadv_event, int);\n\nstatic int if_join_all_router (int, struct interface *);\nstatic int if_leave_all_router (int, struct interface *);\n\nstatic int\nrtadv_recv_packet (int sock, u_char *buf, int buflen,\n\t\t   struct sockaddr_in6 *from, ifindex_t *ifindex,\n\t\t   int *hoplimit)\n{\n  int ret;\n  struct msghdr msg;\n  struct iovec iov;\n  struct cmsghdr  *cmsgptr;\n  struct in6_addr dst;\n\n  char adata[1024];\n\n  /* Fill in message and iovec. */\n  msg.msg_name = (void *) from;\n  msg.msg_namelen = sizeof (struct sockaddr_in6);\n  msg.msg_iov = &iov;\n  msg.msg_iovlen = 1;\n  msg.msg_control = (void *) adata;\n  msg.msg_controllen = sizeof adata;\n  iov.iov_base = buf;\n  iov.iov_len = buflen;\n\n  /* If recvmsg fail return minus value. */\n  ret = recvmsg (sock, &msg, 0);\n  if (ret < 0)\n    return ret;\n\n  for (cmsgptr = ZCMSG_FIRSTHDR(&msg); cmsgptr != NULL;\n       cmsgptr = CMSG_NXTHDR(&msg, cmsgptr)) \n    {\n      /* I want interface index which this packet comes from. */\n      if (cmsgptr->cmsg_level == IPPROTO_IPV6 &&\n\t  cmsgptr->cmsg_type == IPV6_PKTINFO) \n\t{\n\t  struct in6_pktinfo *ptr;\n\t  \n\t  ptr = (struct in6_pktinfo *) CMSG_DATA (cmsgptr);\n\t  *ifindex = ptr->ipi6_ifindex;\n\t  memcpy(&dst, &ptr->ipi6_addr, sizeof(ptr->ipi6_addr));\n        }\n\n      /* Incoming packet's hop limit. */\n      if (cmsgptr->cmsg_level == IPPROTO_IPV6 &&\n\t  cmsgptr->cmsg_type == IPV6_HOPLIMIT)\n\t{\n\t  int *hoptr = (int *) CMSG_DATA (cmsgptr);\n\t  *hoplimit = *hoptr;\n\t}\n    }\n  return ret;\n}\n\n#define RTADV_MSG_SIZE 4096\n\n/* Send router advertisement packet. */\nstatic void\nrtadv_send_packet (int sock, struct interface *ifp)\n{\n  struct msghdr msg;\n  struct iovec iov;\n  struct cmsghdr  *cmsgptr;\n  struct in6_pktinfo *pkt;\n  struct sockaddr_in6 addr;\n#ifdef HAVE_STRUCT_SOCKADDR_DL\n  struct sockaddr_dl *sdl;\n#endif /* HAVE_STRUCT_SOCKADDR_DL */\n  static void *adata = NULL;\n  unsigned char buf[RTADV_MSG_SIZE];\n  struct nd_router_advert *rtadv;\n  int ret;\n  int len = 0;\n  struct zebra_if *zif;\n  struct rtadv_prefix *rprefix;\n  u_char all_nodes_addr[] = {0xff,0x02,0,0,0,0,0,0,0,0,0,0,0,0,0,1};\n  struct listnode *node;\n  u_int16_t pkt_RouterLifetime;\n\n  /*\n   * Allocate control message bufffer.  This is dynamic because\n   * CMSG_SPACE is not guaranteed not to call a function.  Note that\n   * the size will be different on different architectures due to\n   * differing alignment rules.\n   */\n  if (adata == NULL)\n    {\n      /* XXX Free on shutdown. */\n      adata = malloc(CMSG_SPACE(sizeof(struct in6_pktinfo)));\n\t   \n      if (adata == NULL)\n\tzlog_err(\"rtadv_send_packet: can't malloc control data\\n\");\n    }\n\n  /* Logging of packet. */\n  if (IS_ZEBRA_DEBUG_PACKET)\n    zlog_debug (\"Router advertisement send to %s\", ifp->name);\n\n  /* Fill in sockaddr_in6. */\n  memset (&addr, 0, sizeof (struct sockaddr_in6));\n  addr.sin6_family = AF_INET6;\n#ifdef SIN6_LEN\n  addr.sin6_len = sizeof (struct sockaddr_in6);\n#endif /* SIN6_LEN */\n  addr.sin6_port = htons (IPPROTO_ICMPV6);\n  IPV6_ADDR_COPY (&addr.sin6_addr, all_nodes_addr);\n\n  /* Fetch interface information. */\n  zif = ifp->info;\n\n  /* Make router advertisement message. */\n  rtadv = (struct nd_router_advert *) buf;\n\n  rtadv->nd_ra_type = ND_ROUTER_ADVERT;\n  rtadv->nd_ra_code = 0;\n  rtadv->nd_ra_cksum = 0;\n\n  rtadv->nd_ra_curhoplimit = 64;\n\n  /* RFC4191: Default Router Preference is 0 if Router Lifetime is 0. */\n  rtadv->nd_ra_flags_reserved =\n    zif->rtadv.AdvDefaultLifetime == 0 ? 0 : zif->rtadv.DefaultPreference;\n  rtadv->nd_ra_flags_reserved <<= 3;\n\n  if (zif->rtadv.AdvManagedFlag)\n    rtadv->nd_ra_flags_reserved |= ND_RA_FLAG_MANAGED;\n  if (zif->rtadv.AdvOtherConfigFlag)\n    rtadv->nd_ra_flags_reserved |= ND_RA_FLAG_OTHER;\n  if (zif->rtadv.AdvHomeAgentFlag)\n    rtadv->nd_ra_flags_reserved |= ND_RA_FLAG_HOME_AGENT;\n  /* Note that according to Neighbor Discovery (RFC 4861 [18]),\n   * AdvDefaultLifetime is by default based on the value of\n   * MaxRtrAdvInterval.  AdvDefaultLifetime is used in the Router Lifetime\n   * field of Router Advertisements.  Given that this field is expressed\n   * in seconds, a small MaxRtrAdvInterval value can result in a zero\n   * value for this field.  To prevent this, routers SHOULD keep\n   * AdvDefaultLifetime in at least one second, even if the use of\n   * MaxRtrAdvInterval would result in a smaller value. -- RFC6275, 7.5 */\n  pkt_RouterLifetime = zif->rtadv.AdvDefaultLifetime != -1 ?\n    zif->rtadv.AdvDefaultLifetime :\n    MAX (1, 0.003 * zif->rtadv.MaxRtrAdvInterval);\n  rtadv->nd_ra_router_lifetime = htons (pkt_RouterLifetime);\n  rtadv->nd_ra_reachable = htonl (zif->rtadv.AdvReachableTime);\n  rtadv->nd_ra_retransmit = htonl (0);\n\n  len = sizeof (struct nd_router_advert);\n\n  /* If both the Home Agent Preference and Home Agent Lifetime are set to\n   * their default values specified above, this option SHOULD NOT be\n   * included in the Router Advertisement messages sent by this home\n   * agent. -- RFC6275, 7.4 */\n  if\n  (\n    zif->rtadv.AdvHomeAgentFlag &&\n    (zif->rtadv.HomeAgentPreference || zif->rtadv.HomeAgentLifetime != -1)\n  )\n    {\n      struct nd_opt_homeagent_info *ndopt_hai = \n\t(struct nd_opt_homeagent_info *)(buf + len);\n      ndopt_hai->nd_opt_hai_type = ND_OPT_HA_INFORMATION;\n      ndopt_hai->nd_opt_hai_len = 1;\n      ndopt_hai->nd_opt_hai_reserved = 0;\n      ndopt_hai->nd_opt_hai_preference = htons(zif->rtadv.HomeAgentPreference);\n      /* 16-bit unsigned integer.  The lifetime associated with the home\n       * agent in units of seconds.  The default value is the same as the\n       * Router Lifetime, as specified in the main body of the Router\n       * Advertisement.  The maximum value corresponds to 18.2 hours.  A\n       * value of 0 MUST NOT be used. -- RFC6275, 7.5 */\n      ndopt_hai->nd_opt_hai_lifetime = htons\n      (\n        zif->rtadv.HomeAgentLifetime != -1 ?\n        zif->rtadv.HomeAgentLifetime :\n        MAX (1, pkt_RouterLifetime) /* 0 is OK for RL, but not for HAL*/\n      );\n      len += sizeof(struct nd_opt_homeagent_info);\n    }\n\n  if (zif->rtadv.AdvIntervalOption)\n    {\n      struct nd_opt_adv_interval *ndopt_adv = \n\t(struct nd_opt_adv_interval *)(buf + len);\n      ndopt_adv->nd_opt_ai_type = ND_OPT_ADV_INTERVAL;\n      ndopt_adv->nd_opt_ai_len = 1;\n      ndopt_adv->nd_opt_ai_reserved = 0;\n      ndopt_adv->nd_opt_ai_interval = htonl(zif->rtadv.MaxRtrAdvInterval);\n      len += sizeof(struct nd_opt_adv_interval);\n    }\n\n  /* Fill in prefix. */\n  for (ALL_LIST_ELEMENTS_RO (zif->rtadv.AdvPrefixList, node, rprefix))\n    {\n      struct nd_opt_prefix_info *pinfo;\n\n      pinfo = (struct nd_opt_prefix_info *) (buf + len);\n\n      pinfo->nd_opt_pi_type = ND_OPT_PREFIX_INFORMATION;\n      pinfo->nd_opt_pi_len = 4;\n      pinfo->nd_opt_pi_prefix_len = rprefix->prefix.prefixlen;\n\n      pinfo->nd_opt_pi_flags_reserved = 0;\n      if (rprefix->AdvOnLinkFlag)\n\tpinfo->nd_opt_pi_flags_reserved |= ND_OPT_PI_FLAG_ONLINK;\n      if (rprefix->AdvAutonomousFlag)\n\tpinfo->nd_opt_pi_flags_reserved |= ND_OPT_PI_FLAG_AUTO;\n      if (rprefix->AdvRouterAddressFlag)\n\tpinfo->nd_opt_pi_flags_reserved |= ND_OPT_PI_FLAG_RADDR;\n\n      pinfo->nd_opt_pi_valid_time = htonl (rprefix->AdvValidLifetime);\n      pinfo->nd_opt_pi_preferred_time = htonl (rprefix->AdvPreferredLifetime);\n      pinfo->nd_opt_pi_reserved2 = 0;\n\n      IPV6_ADDR_COPY (&pinfo->nd_opt_pi_prefix, &rprefix->prefix.prefix);\n\n#ifdef DEBUG\n      {\n\tu_char buf[INET6_ADDRSTRLEN];\n\n\tzlog_debug (\"DEBUG %s\", inet_ntop (AF_INET6, &pinfo->nd_opt_pi_prefix, \n\t           buf, INET6_ADDRSTRLEN));\n\n      }\n#endif /* DEBUG */\n\n      len += sizeof (struct nd_opt_prefix_info);\n    }\n\n  /* Hardware address. */\n  if (ifp->hw_addr_len != 0)\n    {\n      buf[len++] = ND_OPT_SOURCE_LINKADDR;\n\n      /* Option length should be rounded up to next octet if\n         the link address does not end on an octet boundary. */\n      buf[len++] = (ifp->hw_addr_len + 9) >> 3;\n\n      memcpy (buf + len, ifp->hw_addr, ifp->hw_addr_len);\n      len += ifp->hw_addr_len;\n\n      /* Pad option to end on an octet boundary. */\n      memset (buf + len, 0, -(ifp->hw_addr_len + 2) & 0x7);\n      len += -(ifp->hw_addr_len + 2) & 0x7;\n    }\n\n  /* MTU */\n  if (zif->rtadv.AdvLinkMTU)\n    {\n      struct nd_opt_mtu * opt = (struct nd_opt_mtu *) (buf + len);\n      opt->nd_opt_mtu_type = ND_OPT_MTU;\n      opt->nd_opt_mtu_len = 1;\n      opt->nd_opt_mtu_reserved = 0;\n      opt->nd_opt_mtu_mtu = htonl (zif->rtadv.AdvLinkMTU);\n      len += sizeof (struct nd_opt_mtu);\n    }\n\n  msg.msg_name = (void *) &addr;\n  msg.msg_namelen = sizeof (struct sockaddr_in6);\n  msg.msg_iov = &iov;\n  msg.msg_iovlen = 1;\n  msg.msg_control = (void *) adata;\n  msg.msg_controllen = CMSG_SPACE(sizeof(struct in6_pktinfo));\n  msg.msg_flags = 0;\n  iov.iov_base = buf;\n  iov.iov_len = len;\n\n  cmsgptr = ZCMSG_FIRSTHDR(&msg);\n  cmsgptr->cmsg_len = CMSG_LEN(sizeof(struct in6_pktinfo));\n  cmsgptr->cmsg_level = IPPROTO_IPV6;\n  cmsgptr->cmsg_type = IPV6_PKTINFO;\n\n  pkt = (struct in6_pktinfo *) CMSG_DATA (cmsgptr);\n  memset (&pkt->ipi6_addr, 0, sizeof (struct in6_addr));\n  pkt->ipi6_ifindex = ifp->ifindex;\n\n  ret = sendmsg (sock, &msg, 0);\n  if (ret < 0)\n    {\n      zlog_err (\"rtadv_send_packet: sendmsg %d (%s)\\n\",\n\t\terrno, safe_strerror(errno));\n    }\n}\n\nstatic int\nrtadv_timer (struct thread *thread)\n{\n  struct zebra_vrf *zvrf = THREAD_ARG (thread);\n  struct listnode *node, *nnode;\n  struct interface *ifp;\n  struct zebra_if *zif;\n  int period;\n\n  zvrf->rtadv.ra_timer = NULL;\n  if (zvrf->rtadv.adv_msec_if_count == 0)\n    {\n      period = 1000; /* 1 s */\n      rtadv_event (zvrf, RTADV_TIMER, 1 /* 1 s */);\n    } \n  else\n    {\n      period = 10; /* 10 ms */\n      rtadv_event (zvrf, RTADV_TIMER_MSEC, 10 /* 10 ms */);\n    }\n\n  for (ALL_LIST_ELEMENTS (vrf_iflist (zvrf->vrf_id), node, nnode, ifp))\n    {\n      if (if_is_loopback (ifp) || ! if_is_operative (ifp))\n\tcontinue;\n\n      zif = ifp->info;\n\n      if (zif->rtadv.AdvSendAdvertisements)\n\t{ \n\t  zif->rtadv.AdvIntervalTimer -= period;\n\t  if (zif->rtadv.AdvIntervalTimer <= 0)\n\t    {\n\t      /* FIXME: using MaxRtrAdvInterval each time isn't what section\n\t         6.2.4 of RFC4861 tells to do. */\n\t      zif->rtadv.AdvIntervalTimer = zif->rtadv.MaxRtrAdvInterval;\n\t      rtadv_send_packet (zvrf->rtadv.sock, ifp);\n\t    }\n\t}\n    }\n  return 0;\n}\n\nstatic void\nrtadv_process_solicit (struct interface *ifp)\n{\n  struct zebra_vrf *zvrf = vrf_info_lookup (ifp->vrf_id);\n\n  zlog_info (\"Router solicitation received on %s vrf %u\", ifp->name, zvrf->vrf_id);\n\n  rtadv_send_packet (zvrf->rtadv.sock, ifp);\n}\n\nstatic void\nrtadv_process_advert (void)\n{\n  zlog_info (\"Router advertisement received\");\n}\n\nstatic void\nrtadv_process_packet (u_char *buf, unsigned int len, ifindex_t ifindex,\n    int hoplimit, vrf_id_t vrf_id)\n{\n  struct icmp6_hdr *icmph;\n  struct interface *ifp;\n  struct zebra_if *zif;\n\n  /* Interface search. */\n  ifp = if_lookup_by_index_vrf (ifindex, vrf_id);\n  if (ifp == NULL)\n    {\n      zlog_warn (\"Unknown interface index: %d, vrf %u\", ifindex, vrf_id);\n      return;\n    }\n\n  if (if_is_loopback (ifp))\n    return;\n\n  /* Check interface configuration. */\n  zif = ifp->info;\n  if (! zif->rtadv.AdvSendAdvertisements)\n    return;\n\n  /* ICMP message length check. */\n  if (len < sizeof (struct icmp6_hdr))\n    {\n      zlog_warn (\"Invalid ICMPV6 packet length: %d\", len);\n      return;\n    }\n\n  icmph = (struct icmp6_hdr *) buf;\n\n  /* ICMP message type check. */\n  if (icmph->icmp6_type != ND_ROUTER_SOLICIT &&\n      icmph->icmp6_type != ND_ROUTER_ADVERT)\n    {\n      zlog_warn (\"Unwanted ICMPV6 message type: %d\", icmph->icmp6_type);\n      return;\n    }\n\n  /* Hoplimit check. */\n  if (hoplimit >= 0 && hoplimit != 255)\n    {\n      zlog_warn (\"Invalid hoplimit %d for router advertisement ICMP packet\",\n\t\t hoplimit);\n      return;\n    }\n\n  /* Check ICMP message type. */\n  if (icmph->icmp6_type == ND_ROUTER_SOLICIT)\n    rtadv_process_solicit (ifp);\n  else if (icmph->icmp6_type == ND_ROUTER_ADVERT)\n    rtadv_process_advert ();\n\n  return;\n}\n\nstatic int\nrtadv_read (struct thread *thread)\n{\n  int sock;\n  int len;\n  u_char buf[RTADV_MSG_SIZE];\n  struct sockaddr_in6 from;\n  ifindex_t ifindex = 0;\n  int hoplimit = -1;\n  struct zebra_vrf *zvrf = THREAD_ARG (thread);\n\n  sock = THREAD_FD (thread);\n  zvrf->rtadv.ra_read = NULL;\n\n  /* Register myself. */\n  rtadv_event (zvrf, RTADV_READ, sock);\n\n  len = rtadv_recv_packet (sock, buf, sizeof (buf), &from, &ifindex, &hoplimit);\n\n  if (len < 0) \n    {\n      zlog_warn (\"router solicitation recv failed: %s.\", safe_strerror (errno));\n      return len;\n    }\n\n  rtadv_process_packet (buf, (unsigned)len, ifindex, hoplimit, zvrf->vrf_id);\n\n  return 0;\n}\n\nstatic int\nrtadv_make_socket (vrf_id_t vrf_id)\n{\n  int sock;\n  int ret;\n  struct icmp6_filter filter;\n\n  if ( zserv_privs.change (ZPRIVS_RAISE) )\n       zlog_err (\"rtadv_make_socket: could not raise privs, %s\",\n                  safe_strerror (errno) );\n                  \n  sock = vrf_socket (AF_INET6, SOCK_RAW, IPPROTO_ICMPV6, vrf_id);\n\n  if ( zserv_privs.change (ZPRIVS_LOWER) )\n       zlog_err (\"rtadv_make_socket: could not lower privs, %s\",\n       \t\t\t safe_strerror (errno) );\n\n  /* When we can't make ICMPV6 socket simply back.  Router\n     advertisement feature will not be supported. */\n  if (sock < 0)\n    {\n      close (sock);\n      return -1;\n    }\n\n  ret = setsockopt_ipv6_pktinfo (sock, 1);\n  if (ret < 0)\n    {\n      close (sock);\n      return ret;\n    }\n  ret = setsockopt_ipv6_multicast_loop (sock, 0);\n  if (ret < 0)\n    {\n      close (sock);\n      return ret;\n    }\n  ret = setsockopt_ipv6_unicast_hops (sock, 255);\n  if (ret < 0)\n    {\n      close (sock);\n      return ret;\n    }\n  ret = setsockopt_ipv6_multicast_hops (sock, 255);\n  if (ret < 0)\n    {\n      close (sock);\n      return ret;\n    }\n  ret = setsockopt_ipv6_hoplimit (sock, 1);\n  if (ret < 0)\n    {\n      close (sock);\n      return ret;\n    }\n\n  ICMP6_FILTER_SETBLOCKALL(&filter);\n  ICMP6_FILTER_SETPASS (ND_ROUTER_SOLICIT, &filter);\n  ICMP6_FILTER_SETPASS (ND_ROUTER_ADVERT, &filter);\n\n  ret = setsockopt (sock, IPPROTO_ICMPV6, ICMP6_FILTER, &filter,\n\t\t    sizeof (struct icmp6_filter));\n  if (ret < 0)\n    {\n      zlog_info (\"ICMP6_FILTER set fail: %s\", safe_strerror (errno));\n      return ret;\n    }\n\n  return sock;\n}\n\nstatic struct rtadv_prefix *\nrtadv_prefix_new (void)\n{\n  return XCALLOC (MTYPE_RTADV_PREFIX, sizeof (struct rtadv_prefix));\n}\n\nstatic void\nrtadv_prefix_free (struct rtadv_prefix *rtadv_prefix)\n{\n  XFREE (MTYPE_RTADV_PREFIX, rtadv_prefix);\n}\n\nstatic struct rtadv_prefix *\nrtadv_prefix_lookup (struct list *rplist, struct prefix_ipv6 *p)\n{\n  struct listnode *node;\n  struct rtadv_prefix *rprefix;\n\n  for (ALL_LIST_ELEMENTS_RO (rplist, node, rprefix))\n    if (prefix_same ((struct prefix *) &rprefix->prefix, (struct prefix *) p))\n      return rprefix;\n  return NULL;\n}\n\nstatic struct rtadv_prefix *\nrtadv_prefix_get (struct list *rplist, struct prefix_ipv6 *p)\n{\n  struct rtadv_prefix *rprefix;\n  \n  rprefix = rtadv_prefix_lookup (rplist, p);\n  if (rprefix)\n    return rprefix;\n\n  rprefix = rtadv_prefix_new ();\n  memcpy (&rprefix->prefix, p, sizeof (struct prefix_ipv6));\n  listnode_add (rplist, rprefix);\n\n  return rprefix;\n}\n\nstatic void\nrtadv_prefix_set (struct zebra_if *zif, struct rtadv_prefix *rp)\n{\n  struct rtadv_prefix *rprefix;\n  \n  rprefix = rtadv_prefix_get (zif->rtadv.AdvPrefixList, &rp->prefix);\n\n  /* Set parameters. */\n  rprefix->AdvValidLifetime = rp->AdvValidLifetime;\n  rprefix->AdvPreferredLifetime = rp->AdvPreferredLifetime;\n  rprefix->AdvOnLinkFlag = rp->AdvOnLinkFlag;\n  rprefix->AdvAutonomousFlag = rp->AdvAutonomousFlag;\n  rprefix->AdvRouterAddressFlag = rp->AdvRouterAddressFlag;\n}\n\nstatic int\nrtadv_prefix_reset (struct zebra_if *zif, struct rtadv_prefix *rp)\n{\n  struct rtadv_prefix *rprefix;\n  \n  rprefix = rtadv_prefix_lookup (zif->rtadv.AdvPrefixList, &rp->prefix);\n  if (rprefix != NULL)\n    {\n      listnode_delete (zif->rtadv.AdvPrefixList, (void *) rprefix);\n      rtadv_prefix_free (rprefix);\n      return 1;\n    }\n  else\n    return 0;\n}\n\nDEFUN (ipv6_nd_suppress_ra,\n       ipv6_nd_suppress_ra_cmd,\n       \"ipv6 nd suppress-ra\",\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Suppress Router Advertisement\\n\")\n{\n  struct interface *ifp;\n  struct zebra_if *zif;\n  struct zebra_vrf *zvrf;\n\n  ifp = vty->index;\n  zif = ifp->info;\n  zvrf = vrf_info_lookup (ifp->vrf_id);\n\n  if (if_is_loopback (ifp))\n    {\n      vty_out (vty, \"Invalid interface%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  if (zif->rtadv.AdvSendAdvertisements)\n    {\n      zif->rtadv.AdvSendAdvertisements = 0;\n      zif->rtadv.AdvIntervalTimer = 0;\n      zvrf->rtadv.adv_if_count--;\n\n      if_leave_all_router (zvrf->rtadv.sock, ifp);\n\n      if (zvrf->rtadv.adv_if_count == 0)\n        rtadv_event (zvrf, RTADV_STOP, 0);\n    }\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_ipv6_nd_suppress_ra,\n       no_ipv6_nd_suppress_ra_cmd,\n       \"no ipv6 nd suppress-ra\",\n       NO_STR\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Suppress Router Advertisement\\n\")\n{\n  struct interface *ifp;\n  struct zebra_if *zif;\n  struct zebra_vrf *zvrf;\n\n  ifp = vty->index;\n  zif = ifp->info;\n  zvrf = vrf_info_lookup (ifp->vrf_id);\n\n  if (if_is_loopback (ifp))\n    {\n      vty_out (vty, \"Invalid interface%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  if (! zif->rtadv.AdvSendAdvertisements)\n    {\n      zif->rtadv.AdvSendAdvertisements = 1;\n      zif->rtadv.AdvIntervalTimer = 0;\n      zvrf->rtadv.adv_if_count++;\n\n      if_join_all_router (zvrf->rtadv.sock, ifp);\n\n      if (zvrf->rtadv.adv_if_count == 1)\n        rtadv_event (zvrf, RTADV_START, zvrf->rtadv.sock);\n    }\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (ipv6_nd_ra_interval_msec,\n       ipv6_nd_ra_interval_msec_cmd,\n       \"ipv6 nd ra-interval msec <70-1800000>\",\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Router Advertisement interval\\n\"\n       \"Router Advertisement interval in milliseconds\\n\")\n{\n  unsigned interval;\n  struct interface *ifp = (struct interface *) vty->index;\n  struct zebra_if *zif = ifp->info;\n  struct zebra_vrf *zvrf = vrf_info_lookup (ifp->vrf_id);\n\n  VTY_GET_INTEGER_RANGE (\"router advertisement interval\", interval, argv[0], 70, 1800000);\n  if ((zif->rtadv.AdvDefaultLifetime != -1 && interval > (unsigned)zif->rtadv.AdvDefaultLifetime * 1000))\n  {\n    vty_out (vty, \"This ra-interval would conflict with configured ra-lifetime!%s\", VTY_NEWLINE);\n    return CMD_WARNING;\n  }\n\n  if (zif->rtadv.MaxRtrAdvInterval % 1000)\n    zvrf->rtadv.adv_msec_if_count--;\n\n  if (interval % 1000)\n    zvrf->rtadv.adv_msec_if_count++;\n  \n  zif->rtadv.MaxRtrAdvInterval = interval;\n  zif->rtadv.MinRtrAdvInterval = 0.33 * interval;\n  zif->rtadv.AdvIntervalTimer = 0;\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (ipv6_nd_ra_interval,\n       ipv6_nd_ra_interval_cmd,\n       \"ipv6 nd ra-interval <1-1800>\",\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Router Advertisement interval\\n\"\n       \"Router Advertisement interval in seconds\\n\")\n{\n  unsigned interval;\n  struct interface *ifp = (struct interface *) vty->index;\n  struct zebra_if *zif = ifp->info;\n  struct zebra_vrf *zvrf = vrf_info_lookup (ifp->vrf_id);\n\n  VTY_GET_INTEGER_RANGE (\"router advertisement interval\", interval, argv[0], 1, 1800);\n  if ((zif->rtadv.AdvDefaultLifetime != -1 && interval > (unsigned)zif->rtadv.AdvDefaultLifetime))\n  {\n    vty_out (vty, \"This ra-interval would conflict with configured ra-lifetime!%s\", VTY_NEWLINE);\n    return CMD_WARNING;\n  }\n\n  if (zif->rtadv.MaxRtrAdvInterval % 1000)\n    zvrf->rtadv.adv_msec_if_count--;\n\t\n  /* convert to milliseconds */\n  interval = interval * 1000; \n\t\n  zif->rtadv.MaxRtrAdvInterval = interval;\n  zif->rtadv.MinRtrAdvInterval = 0.33 * interval;\n  zif->rtadv.AdvIntervalTimer = 0;\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_ipv6_nd_ra_interval,\n       no_ipv6_nd_ra_interval_cmd,\n       \"no ipv6 nd ra-interval\",\n       NO_STR\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Router Advertisement interval\\n\")\n{\n  struct interface *ifp;\n  struct zebra_if *zif;\n  struct zebra_vrf *zvrf;\n\n  ifp = (struct interface *) vty->index;\n  zif = ifp->info;\n  zvrf = vrf_info_lookup (ifp->vrf_id);\n\n  if (zif->rtadv.MaxRtrAdvInterval % 1000)\n    zvrf->rtadv.adv_msec_if_count--;\n  \n  zif->rtadv.MaxRtrAdvInterval = RTADV_MAX_RTR_ADV_INTERVAL;\n  zif->rtadv.MinRtrAdvInterval = RTADV_MIN_RTR_ADV_INTERVAL;\n  zif->rtadv.AdvIntervalTimer = zif->rtadv.MaxRtrAdvInterval;\n\n  return CMD_SUCCESS;\n}\n\nALIAS (no_ipv6_nd_ra_interval,\n       no_ipv6_nd_ra_interval_val_cmd,\n       \"no ipv6 nd ra-interval <1-1800>\",\n       NO_STR\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Router Advertisement interval\\n\")\n\nALIAS (no_ipv6_nd_ra_interval,\n       no_ipv6_nd_ra_interval_msec_val_cmd,\n       \"no ipv6 nd ra-interval msec <1-1800000>\",\n       NO_STR\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Router Advertisement interval\\n\"\n       \"Router Advertisement interval in milliseconds\\n\")\n\nDEFUN (ipv6_nd_ra_lifetime,\n       ipv6_nd_ra_lifetime_cmd,\n       \"ipv6 nd ra-lifetime <0-9000>\",\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Router lifetime\\n\"\n       \"Router lifetime in seconds (0 stands for a non-default gw)\\n\")\n{\n  int lifetime;\n  struct interface *ifp;\n  struct zebra_if *zif;\n\n  ifp = (struct interface *) vty->index;\n  zif = ifp->info;\n\n  VTY_GET_INTEGER_RANGE (\"router lifetime\", lifetime, argv[0], 0, 9000);\n\n  /* The value to be placed in the Router Lifetime field\n   * of Router Advertisements sent from the interface,\n   * in seconds.  MUST be either zero or between\n   * MaxRtrAdvInterval and 9000 seconds. -- RFC4861, 6.2.1 */\n  if ((lifetime != 0 && lifetime * 1000 < zif->rtadv.MaxRtrAdvInterval))\n    {\n      vty_out (vty, \"This ra-lifetime would conflict with configured ra-interval%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  zif->rtadv.AdvDefaultLifetime = lifetime;\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_ipv6_nd_ra_lifetime,\n       no_ipv6_nd_ra_lifetime_cmd,\n       \"no ipv6 nd ra-lifetime\",\n       NO_STR\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Router lifetime\\n\")\n{\n  struct interface *ifp;\n  struct zebra_if *zif;\n\n  ifp = (struct interface *) vty->index;\n  zif = ifp->info;\n\n  zif->rtadv.AdvDefaultLifetime = -1;\n\n  return CMD_SUCCESS;\n}\n\nALIAS (no_ipv6_nd_ra_lifetime,\n       no_ipv6_nd_ra_lifetime_val_cmd,\n       \"no ipv6 nd ra-lifetime <0-9000>\",\n       NO_STR\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Router lifetime\\n\"\n       \"Router lifetime in seconds (0 stands for a non-default gw)\\n\")\n\nDEFUN (ipv6_nd_reachable_time,\n       ipv6_nd_reachable_time_cmd,\n       \"ipv6 nd reachable-time <1-3600000>\",\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Reachable time\\n\"\n       \"Reachable time in milliseconds\\n\")\n{\n  struct interface *ifp = (struct interface *) vty->index;\n  struct zebra_if *zif = ifp->info;\n  VTY_GET_INTEGER_RANGE (\"reachable time\", zif->rtadv.AdvReachableTime, argv[0], 1, RTADV_MAX_REACHABLE_TIME);\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_ipv6_nd_reachable_time,\n       no_ipv6_nd_reachable_time_cmd,\n       \"no ipv6 nd reachable-time\",\n       NO_STR\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Reachable time\\n\")\n{\n  struct interface *ifp;\n  struct zebra_if *zif;\n\n  ifp = (struct interface *) vty->index;\n  zif = ifp->info;\n\n  zif->rtadv.AdvReachableTime = 0;\n\n  return CMD_SUCCESS;\n}\n\nALIAS (no_ipv6_nd_reachable_time,\n       no_ipv6_nd_reachable_time_val_cmd,\n       \"no ipv6 nd reachable-time <1-3600000>\",\n       NO_STR\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Reachable time\\n\"\n       \"Reachable time in milliseconds\\n\")\n\nDEFUN (ipv6_nd_homeagent_preference,\n       ipv6_nd_homeagent_preference_cmd,\n       \"ipv6 nd home-agent-preference <0-65535>\",\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Home Agent preference\\n\"\n       \"preference value (default is 0, least preferred)\\n\")\n{\n  struct interface *ifp = (struct interface *) vty->index;\n  struct zebra_if *zif = ifp->info;\n  VTY_GET_INTEGER_RANGE (\"home agent preference\", zif->rtadv.HomeAgentPreference, argv[0], 0, 65535);\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_ipv6_nd_homeagent_preference,\n       no_ipv6_nd_homeagent_preference_cmd,\n       \"no ipv6 nd home-agent-preference\",\n       NO_STR\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Home Agent preference\\n\")\n{\n  struct interface *ifp;\n  struct zebra_if *zif;\n\n  ifp = (struct interface *) vty->index;\n  zif = ifp->info;\n\n  zif->rtadv.HomeAgentPreference = 0;\n\n  return CMD_SUCCESS;\n}\n\nALIAS (no_ipv6_nd_homeagent_preference,\n       no_ipv6_nd_homeagent_preference_val_cmd,\n       \"no ipv6 nd home-agent-preference <0-65535>\",\n       NO_STR\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Home Agent preference\\n\"\n       \"preference value (default is 0, least preferred)\\n\")\n\nDEFUN (ipv6_nd_homeagent_lifetime,\n       ipv6_nd_homeagent_lifetime_cmd,\n       \"ipv6 nd home-agent-lifetime <0-65520>\",\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Home Agent lifetime\\n\"\n       \"Home Agent lifetime in seconds (0 to track ra-lifetime)\\n\")\n{\n  struct interface *ifp = (struct interface *) vty->index;\n  struct zebra_if *zif = ifp->info;\n  VTY_GET_INTEGER_RANGE (\"home agent lifetime\", zif->rtadv.HomeAgentLifetime, argv[0], 0, RTADV_MAX_HALIFETIME);\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_ipv6_nd_homeagent_lifetime,\n       no_ipv6_nd_homeagent_lifetime_cmd,\n       \"no ipv6 nd home-agent-lifetime\",\n       NO_STR\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Home Agent lifetime\\n\")\n{\n  struct interface *ifp;\n  struct zebra_if *zif;\n\n  ifp = (struct interface *) vty->index;\n  zif = ifp->info;\n\n  zif->rtadv.HomeAgentLifetime = -1;\n\n  return CMD_SUCCESS;\n}\n\nALIAS (no_ipv6_nd_homeagent_lifetime,\n       no_ipv6_nd_homeagent_lifetime_val_cmd,\n       \"no ipv6 nd home-agent-lifetime <0-65520>\",\n       NO_STR\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Home Agent lifetime\\n\"\n       \"Home Agent lifetime in seconds (0 to track ra-lifetime)\\n\")\n\nDEFUN (ipv6_nd_managed_config_flag,\n       ipv6_nd_managed_config_flag_cmd,\n       \"ipv6 nd managed-config-flag\",\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Managed address configuration flag\\n\")\n{\n  struct interface *ifp;\n  struct zebra_if *zif;\n\n  ifp = (struct interface *) vty->index;\n  zif = ifp->info;\n\n  zif->rtadv.AdvManagedFlag = 1;\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_ipv6_nd_managed_config_flag,\n       no_ipv6_nd_managed_config_flag_cmd,\n       \"no ipv6 nd managed-config-flag\",\n       NO_STR\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Managed address configuration flag\\n\")\n{\n  struct interface *ifp;\n  struct zebra_if *zif;\n\n  ifp = (struct interface *) vty->index;\n  zif = ifp->info;\n\n  zif->rtadv.AdvManagedFlag = 0;\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (ipv6_nd_homeagent_config_flag,\n       ipv6_nd_homeagent_config_flag_cmd,\n       \"ipv6 nd home-agent-config-flag\",\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Home Agent configuration flag\\n\")\n{\n  struct interface *ifp;\n  struct zebra_if *zif;\n\n  ifp = (struct interface *) vty->index;\n  zif = ifp->info;\n\n  zif->rtadv.AdvHomeAgentFlag = 1;\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_ipv6_nd_homeagent_config_flag,\n       no_ipv6_nd_homeagent_config_flag_cmd,\n       \"no ipv6 nd home-agent-config-flag\",\n       NO_STR\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Home Agent configuration flag\\n\")\n{\n  struct interface *ifp;\n  struct zebra_if *zif;\n\n  ifp = (struct interface *) vty->index;\n  zif = ifp->info;\n\n  zif->rtadv.AdvHomeAgentFlag = 0;\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (ipv6_nd_adv_interval_config_option,\n       ipv6_nd_adv_interval_config_option_cmd,\n       \"ipv6 nd adv-interval-option\",\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Advertisement Interval Option\\n\")\n{\n  struct interface *ifp;\n  struct zebra_if *zif;\n\n  ifp = (struct interface *) vty->index;\n  zif = ifp->info;\n\n  zif->rtadv.AdvIntervalOption = 1;\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_ipv6_nd_adv_interval_config_option,\n       no_ipv6_nd_adv_interval_config_option_cmd,\n       \"no ipv6 nd adv-interval-option\",\n       NO_STR\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Advertisement Interval Option\\n\")\n{\n  struct interface *ifp;\n  struct zebra_if *zif;\n\n  ifp = (struct interface *) vty->index;\n  zif = ifp->info;\n\n  zif->rtadv.AdvIntervalOption = 0;\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (ipv6_nd_other_config_flag,\n       ipv6_nd_other_config_flag_cmd,\n       \"ipv6 nd other-config-flag\",\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Other statefull configuration flag\\n\")\n{\n  struct interface *ifp;\n  struct zebra_if *zif;\n\n  ifp = (struct interface *) vty->index;\n  zif = ifp->info;\n\n  zif->rtadv.AdvOtherConfigFlag = 1;\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_ipv6_nd_other_config_flag,\n       no_ipv6_nd_other_config_flag_cmd,\n       \"no ipv6 nd other-config-flag\",\n       NO_STR\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Other statefull configuration flag\\n\")\n{\n  struct interface *ifp;\n  struct zebra_if *zif;\n\n  ifp = (struct interface *) vty->index;\n  zif = ifp->info;\n\n  zif->rtadv.AdvOtherConfigFlag = 0;\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (ipv6_nd_prefix,\n       ipv6_nd_prefix_cmd,\n       \"ipv6 nd prefix X:X::X:X/M (<0-4294967295>|infinite) \"\n       \"(<0-4294967295>|infinite) (off-link|) (no-autoconfig|) (router-address|)\",\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Prefix information\\n\"\n       \"IPv6 prefix\\n\"\n       \"Valid lifetime in seconds\\n\"\n       \"Infinite valid lifetime\\n\"\n       \"Preferred lifetime in seconds\\n\"\n       \"Infinite preferred lifetime\\n\"\n       \"Do not use prefix for onlink determination\\n\"\n       \"Do not use prefix for autoconfiguration\\n\"\n       \"Set Router Address flag\\n\")\n{\n  int i;\n  int ret;\n  int cursor = 1;\n  struct interface *ifp;\n  struct zebra_if *zebra_if;\n  struct rtadv_prefix rp;\n\n  ifp = (struct interface *) vty->index;\n  zebra_if = ifp->info;\n\n  ret = str2prefix_ipv6 (argv[0], &rp.prefix);\n  if (!ret)\n    {\n      vty_out (vty, \"Malformed IPv6 prefix%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n  apply_mask_ipv6 (&rp.prefix); /* RFC4861 4.6.2 */\n  rp.AdvOnLinkFlag = 1;\n  rp.AdvAutonomousFlag = 1;\n  rp.AdvRouterAddressFlag = 0;\n  rp.AdvValidLifetime = RTADV_VALID_LIFETIME;\n  rp.AdvPreferredLifetime = RTADV_PREFERRED_LIFETIME;\n\n  if (argc > 1)\n    {\n      if ((isdigit((unsigned char)argv[1][0]))\n\t  || strncmp (argv[1], \"i\", 1) == 0)\n\t{\n\t  if ( strncmp (argv[1], \"i\", 1) == 0)\n\t    rp.AdvValidLifetime = UINT32_MAX;\n\t  else\n\t    rp.AdvValidLifetime = (u_int32_t) strtoll (argv[1],\n\t\t(char **)NULL, 10);\n      \n\t  if ( strncmp (argv[2], \"i\", 1) == 0)\n\t    rp.AdvPreferredLifetime = UINT32_MAX;\n\t  else\n\t    rp.AdvPreferredLifetime = (u_int32_t) strtoll (argv[2],\n\t\t(char **)NULL, 10);\n\n\t  if (rp.AdvPreferredLifetime > rp.AdvValidLifetime)\n\t    {\n\t      vty_out (vty, \"Invalid preferred lifetime%s\", VTY_NEWLINE);\n\t      return CMD_WARNING;\n\t    }\n\t  cursor = cursor + 2;\n\t}\n      if (argc > cursor)\n\t{\n\t  for (i = cursor; i < argc; i++)\n\t    {\n\t      if (strncmp (argv[i], \"of\", 2) == 0)\n\t\trp.AdvOnLinkFlag = 0;\n\t      if (strncmp (argv[i], \"no\", 2) == 0)\n\t\trp.AdvAutonomousFlag = 0;\n\t      if (strncmp (argv[i], \"ro\", 2) == 0)\n\t\trp.AdvRouterAddressFlag = 1;\n\t    }\n\t}\n    }\n\n  rtadv_prefix_set (zebra_if, &rp);\n\n  return CMD_SUCCESS;\n}\n\nALIAS (ipv6_nd_prefix,\n       ipv6_nd_prefix_val_nortaddr_cmd,\n       \"ipv6 nd prefix X:X::X:X/M (<0-4294967295>|infinite) \"\n       \"(<0-4294967295>|infinite) (off-link|) (no-autoconfig|)\",\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Prefix information\\n\"\n       \"IPv6 prefix\\n\"\n       \"Valid lifetime in seconds\\n\"\n       \"Infinite valid lifetime\\n\"\n       \"Preferred lifetime in seconds\\n\"\n       \"Infinite preferred lifetime\\n\"\n       \"Do not use prefix for onlink determination\\n\"\n       \"Do not use prefix for autoconfiguration\\n\")\n\nALIAS (ipv6_nd_prefix,\n       ipv6_nd_prefix_val_rev_cmd,\n       \"ipv6 nd prefix X:X::X:X/M (<0-4294967295>|infinite) \"\n       \"(<0-4294967295>|infinite) (no-autoconfig|) (off-link|)\",\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Prefix information\\n\"\n       \"IPv6 prefix\\n\"\n       \"Valid lifetime in seconds\\n\"\n       \"Infinite valid lifetime\\n\"\n       \"Preferred lifetime in seconds\\n\"\n       \"Infinite preferred lifetime\\n\"\n       \"Do not use prefix for autoconfiguration\\n\"\n       \"Do not use prefix for onlink determination\\n\")\n\nALIAS (ipv6_nd_prefix,\n       ipv6_nd_prefix_val_rev_rtaddr_cmd,\n       \"ipv6 nd prefix X:X::X:X/M (<0-4294967295>|infinite) \"\n       \"(<0-4294967295>|infinite) (no-autoconfig|) (off-link|) (router-address|)\",\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Prefix information\\n\"\n       \"IPv6 prefix\\n\"\n       \"Valid lifetime in seconds\\n\"\n       \"Infinite valid lifetime\\n\"\n       \"Preferred lifetime in seconds\\n\"\n       \"Infinite preferred lifetime\\n\"\n       \"Do not use prefix for autoconfiguration\\n\"\n       \"Do not use prefix for onlink determination\\n\"\n       \"Set Router Address flag\\n\")\n\nALIAS (ipv6_nd_prefix,\n       ipv6_nd_prefix_val_noauto_cmd,\n       \"ipv6 nd prefix X:X::X:X/M (<0-4294967295>|infinite) \"\n       \"(<0-4294967295>|infinite) (no-autoconfig|)\",\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Prefix information\\n\"\n       \"IPv6 prefix\\n\"\n       \"Valid lifetime in seconds\\n\"\n       \"Infinite valid lifetime\\n\"\n       \"Preferred lifetime in seconds\\n\"\n       \"Infinite preferred lifetime\\n\"\n       \"Do not use prefix for autoconfiguration\")\n\nALIAS (ipv6_nd_prefix,\n       ipv6_nd_prefix_val_offlink_cmd,\n       \"ipv6 nd prefix X:X::X:X/M (<0-4294967295>|infinite) \"\n       \"(<0-4294967295>|infinite) (off-link|)\",\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Prefix information\\n\"\n       \"IPv6 prefix\\n\"\n       \"Valid lifetime in seconds\\n\"\n       \"Infinite valid lifetime\\n\"\n       \"Preferred lifetime in seconds\\n\"\n       \"Infinite preferred lifetime\\n\"\n       \"Do not use prefix for onlink determination\\n\")\n\nALIAS (ipv6_nd_prefix,\n       ipv6_nd_prefix_val_rtaddr_cmd,\n       \"ipv6 nd prefix X:X::X:X/M (<0-4294967295>|infinite) \"\n       \"(<0-4294967295>|infinite) (router-address|)\",\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Prefix information\\n\"\n       \"IPv6 prefix\\n\"\n       \"Valid lifetime in seconds\\n\"\n       \"Infinite valid lifetime\\n\"\n       \"Preferred lifetime in seconds\\n\"\n       \"Infinite preferred lifetime\\n\"\n       \"Set Router Address flag\\n\")\n\nALIAS (ipv6_nd_prefix,\n       ipv6_nd_prefix_val_cmd,\n       \"ipv6 nd prefix X:X::X:X/M (<0-4294967295>|infinite) \"\n       \"(<0-4294967295>|infinite)\",\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Prefix information\\n\"\n       \"IPv6 prefix\\n\"\n       \"Valid lifetime in seconds\\n\"\n       \"Infinite valid lifetime\\n\"\n       \"Preferred lifetime in seconds\\n\"\n       \"Infinite preferred lifetime\\n\")\n\nALIAS (ipv6_nd_prefix,\n       ipv6_nd_prefix_noval_cmd,\n       \"ipv6 nd prefix X:X::X:X/M (no-autoconfig|) (off-link|)\",\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Prefix information\\n\"\n       \"IPv6 prefix\\n\"\n       \"Do not use prefix for autoconfiguration\\n\"\n       \"Do not use prefix for onlink determination\\n\")\n\nALIAS (ipv6_nd_prefix,\n       ipv6_nd_prefix_noval_rev_cmd,\n       \"ipv6 nd prefix X:X::X:X/M (off-link|) (no-autoconfig|)\",\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Prefix information\\n\"\n       \"IPv6 prefix\\n\"\n       \"Do not use prefix for onlink determination\\n\"\n       \"Do not use prefix for autoconfiguration\\n\")\n\nALIAS (ipv6_nd_prefix,\n       ipv6_nd_prefix_noval_noauto_cmd,\n       \"ipv6 nd prefix X:X::X:X/M (no-autoconfig|)\",\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Prefix information\\n\"\n       \"IPv6 prefix\\n\"\n       \"Do not use prefix for autoconfiguration\\n\")\n\nALIAS (ipv6_nd_prefix,\n       ipv6_nd_prefix_noval_offlink_cmd,\n       \"ipv6 nd prefix X:X::X:X/M (off-link|)\",\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Prefix information\\n\"\n       \"IPv6 prefix\\n\"\n       \"Do not use prefix for onlink determination\\n\")\n\nALIAS (ipv6_nd_prefix,\n       ipv6_nd_prefix_noval_rtaddr_cmd,\n       \"ipv6 nd prefix X:X::X:X/M (router-address|)\",\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Prefix information\\n\"\n       \"IPv6 prefix\\n\"\n       \"Set Router Address flag\\n\")\n\nALIAS (ipv6_nd_prefix,\n       ipv6_nd_prefix_prefix_cmd,\n       \"ipv6 nd prefix X:X::X:X/M\",\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Prefix information\\n\"\n       \"IPv6 prefix\\n\")\n\nDEFUN (no_ipv6_nd_prefix,\n       no_ipv6_nd_prefix_cmd,\n       \"no ipv6 nd prefix IPV6PREFIX\",\n       NO_STR\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Prefix information\\n\"\n       \"IPv6 prefix\\n\")\n{\n  int ret;\n  struct interface *ifp;\n  struct zebra_if *zebra_if;\n  struct rtadv_prefix rp;\n\n  ifp = (struct interface *) vty->index;\n  zebra_if = ifp->info;\n\n  ret = str2prefix_ipv6 (argv[0], &rp.prefix);\n  if (!ret)\n    {\n      vty_out (vty, \"Malformed IPv6 prefix%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n  apply_mask_ipv6 (&rp.prefix); /* RFC4861 4.6.2 */\n\n  ret = rtadv_prefix_reset (zebra_if, &rp);\n  if (!ret)\n    {\n      vty_out (vty, \"Non-exist IPv6 prefix%s\", VTY_NEWLINE);\n      return CMD_WARNING;\n    }\n\n  return CMD_SUCCESS;\n}\n\nDEFUN (ipv6_nd_router_preference,\n       ipv6_nd_router_preference_cmd,\n       \"ipv6 nd router-preference (high|medium|low)\",\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Default router preference\\n\"\n       \"High default router preference\\n\"\n       \"Low default router preference\\n\"\n       \"Medium default router preference (default)\\n\")\n{\n  struct interface *ifp;\n  struct zebra_if *zif;\n  int i = 0;\n\n  ifp = (struct interface *) vty->index;\n  zif = ifp->info;\n\n  while (0 != rtadv_pref_strs[i])\n    {\n      if (strncmp (argv[0], rtadv_pref_strs[i], 1) == 0)\n\t{\n\t  zif->rtadv.DefaultPreference = i;\n\t  return CMD_SUCCESS;\n\t}\n      i++;\n    }\n\n  return CMD_ERR_NO_MATCH;\n}\n\nDEFUN (no_ipv6_nd_router_preference,\n       no_ipv6_nd_router_preference_cmd,\n       \"no ipv6 nd router-preference\",\n       NO_STR\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Default router preference\\n\")\n{\n  struct interface *ifp;\n  struct zebra_if *zif;\n\n  ifp = (struct interface *) vty->index;\n  zif = ifp->info;\n\n  zif->rtadv.DefaultPreference = RTADV_PREF_MEDIUM; /* Default per RFC4191. */\n\n  return CMD_SUCCESS;\n}\n\nALIAS (no_ipv6_nd_router_preference,\n       no_ipv6_nd_router_preference_val_cmd,\n       \"no ipv6 nd router-preference (high|medium|low)\",\n       NO_STR\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Default router preference\\n\"\n       \"High default router preference\\n\"\n       \"Low default router preference\\n\"\n       \"Medium default router preference (default)\\n\")\n\nDEFUN (ipv6_nd_mtu,\n       ipv6_nd_mtu_cmd,\n       \"ipv6 nd mtu <1-65535>\",\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Advertised MTU\\n\"\n       \"MTU in bytes\\n\")\n{\n  struct interface *ifp = (struct interface *) vty->index;\n  struct zebra_if *zif = ifp->info;\n  VTY_GET_INTEGER_RANGE (\"MTU\", zif->rtadv.AdvLinkMTU, argv[0], 1, 65535);\n  return CMD_SUCCESS;\n}\n\nDEFUN (no_ipv6_nd_mtu,\n       no_ipv6_nd_mtu_cmd,\n       \"no ipv6 nd mtu\",\n       NO_STR\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Advertised MTU\\n\")\n{\n  struct interface *ifp = (struct interface *) vty->index;\n  struct zebra_if *zif = ifp->info;\n  zif->rtadv.AdvLinkMTU = 0;\n  return CMD_SUCCESS;\n}\n\nALIAS (no_ipv6_nd_mtu,\n       no_ipv6_nd_mtu_val_cmd,\n       \"no ipv6 nd mtu <1-65535>\",\n       NO_STR\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Advertised MTU\\n\"\n       \"MTU in bytes\\n\")\n\n/* Write configuration about router advertisement. */\nvoid\nrtadv_config_write (struct vty *vty, struct interface *ifp)\n{\n  struct zebra_if *zif;\n  struct listnode *node;\n  struct rtadv_prefix *rprefix;\n  char buf[PREFIX_STRLEN];\n  int interval;\n\n  zif = ifp->info;\n\n  if (! if_is_loopback (ifp))\n    {\n      if (zif->rtadv.AdvSendAdvertisements)\n\tvty_out (vty, \" no ipv6 nd suppress-ra%s\", VTY_NEWLINE);\n    }\n\n  \n  interval = zif->rtadv.MaxRtrAdvInterval;\n  if (interval % 1000)\n    vty_out (vty, \" ipv6 nd ra-interval msec %d%s\", interval,\n\t     VTY_NEWLINE);\n  else\n    if (interval != RTADV_MAX_RTR_ADV_INTERVAL)\n      vty_out (vty, \" ipv6 nd ra-interval %d%s\", interval / 1000,\n\t     VTY_NEWLINE);\n\n  if (zif->rtadv.AdvIntervalOption)\n    vty_out (vty, \" ipv6 nd adv-interval-option%s\", VTY_NEWLINE);\n\n  if (zif->rtadv.AdvDefaultLifetime != -1)\n    vty_out (vty, \" ipv6 nd ra-lifetime %d%s\", zif->rtadv.AdvDefaultLifetime,\n\t     VTY_NEWLINE);\n\n  if (zif->rtadv.HomeAgentPreference)\n    vty_out (vty, \" ipv6 nd home-agent-preference %u%s\",\n\t     zif->rtadv.HomeAgentPreference, VTY_NEWLINE);\n\n  if (zif->rtadv.HomeAgentLifetime != -1)\n    vty_out (vty, \" ipv6 nd home-agent-lifetime %u%s\",\n\t     zif->rtadv.HomeAgentLifetime, VTY_NEWLINE);\n\n  if (zif->rtadv.AdvHomeAgentFlag)\n    vty_out (vty, \" ipv6 nd home-agent-config-flag%s\", VTY_NEWLINE);\n\n  if (zif->rtadv.AdvReachableTime)\n    vty_out (vty, \" ipv6 nd reachable-time %d%s\", zif->rtadv.AdvReachableTime,\n\t     VTY_NEWLINE);\n\n  if (zif->rtadv.AdvManagedFlag)\n    vty_out (vty, \" ipv6 nd managed-config-flag%s\", VTY_NEWLINE);\n\n  if (zif->rtadv.AdvOtherConfigFlag)\n    vty_out (vty, \" ipv6 nd other-config-flag%s\", VTY_NEWLINE);\n\n  if (zif->rtadv.DefaultPreference != RTADV_PREF_MEDIUM)\n    vty_out (vty, \" ipv6 nd router-preference %s%s\",\n\t     rtadv_pref_strs[zif->rtadv.DefaultPreference],\n\t     VTY_NEWLINE);\n\n  if (zif->rtadv.AdvLinkMTU)\n    vty_out (vty, \" ipv6 nd mtu %d%s\", zif->rtadv.AdvLinkMTU, VTY_NEWLINE);\n\n  for (ALL_LIST_ELEMENTS_RO (zif->rtadv.AdvPrefixList, node, rprefix))\n    {\n      vty_out (vty, \" ipv6 nd prefix %s\",\n               prefix2str (&rprefix->prefix, buf, sizeof(buf)));\n      if ((rprefix->AdvValidLifetime != RTADV_VALID_LIFETIME) || \n\t  (rprefix->AdvPreferredLifetime != RTADV_PREFERRED_LIFETIME))\n\t{\n\t  if (rprefix->AdvValidLifetime == UINT32_MAX)\n\t    vty_out (vty, \" infinite\");\n\t  else\n\t    vty_out (vty, \" %u\", rprefix->AdvValidLifetime);\n\t  if (rprefix->AdvPreferredLifetime == UINT32_MAX)\n\t    vty_out (vty, \" infinite\");\n\t  else\n\t    vty_out (vty, \" %u\", rprefix->AdvPreferredLifetime);\n\t}\n      if (!rprefix->AdvOnLinkFlag)\n\tvty_out (vty, \" off-link\");\n      if (!rprefix->AdvAutonomousFlag)\n\tvty_out (vty, \" no-autoconfig\");\n      if (rprefix->AdvRouterAddressFlag)\n\tvty_out (vty, \" router-address\");\n      vty_out (vty, \"%s\", VTY_NEWLINE);\n    }\n}\n\n\nstatic void\nrtadv_event (struct zebra_vrf *zvrf, enum rtadv_event event, int val)\n{\n  struct rtadv *rtadv = &zvrf->rtadv;\n\n  switch (event)\n    {\n    case RTADV_START:\n      if (! rtadv->ra_read)\n\trtadv->ra_read = thread_add_read (zebrad.master, rtadv_read, zvrf, val);\n      if (! rtadv->ra_timer)\n\trtadv->ra_timer = thread_add_event (zebrad.master, rtadv_timer,\n\t                                    zvrf, 0);\n      break;\n    case RTADV_STOP:\n      if (rtadv->ra_timer)\n\t{\n\t  thread_cancel (rtadv->ra_timer);\n\t  rtadv->ra_timer = NULL;\n\t}\n      if (rtadv->ra_read)\n\t{\n\t  thread_cancel (rtadv->ra_read);\n\t  rtadv->ra_read = NULL;\n\t}\n      break;\n    case RTADV_TIMER:\n      if (! rtadv->ra_timer)\n\trtadv->ra_timer = thread_add_timer (zebrad.master, rtadv_timer, zvrf,\n\t                                    val);\n      break;\n    case RTADV_TIMER_MSEC:\n      if (! rtadv->ra_timer)\n\trtadv->ra_timer = thread_add_timer_msec (zebrad.master, rtadv_timer, \n\t\t\t\t\t    zvrf, val);\n      break;\n    case RTADV_READ:\n      if (! rtadv->ra_read)\n\trtadv->ra_read = thread_add_read (zebrad.master, rtadv_read, zvrf, val);\n      break;\n    default:\n      break;\n    }\n  return;\n}\n\nvoid\nrtadv_init (struct zebra_vrf *zvrf)\n{\n  zvrf->rtadv.sock = rtadv_make_socket (zvrf->vrf_id);\n}\n\nvoid\nrtadv_terminate (struct zebra_vrf *zvrf)\n{\n  rtadv_event (zvrf, RTADV_STOP, 0);\n\n  if (zvrf->rtadv.sock >= 0)\n    {\n      close (zvrf->rtadv.sock);\n      zvrf->rtadv.sock = -1;\n    }\n\n  zvrf->rtadv.adv_if_count = 0;\n  zvrf->rtadv.adv_msec_if_count = 0;\n}\n\nvoid\nrtadv_cmd_init (void)\n{\n  install_element (INTERFACE_NODE, &ipv6_nd_suppress_ra_cmd);\n  install_element (INTERFACE_NODE, &no_ipv6_nd_suppress_ra_cmd);\n  install_element (INTERFACE_NODE, &ipv6_nd_ra_interval_cmd);\n  install_element (INTERFACE_NODE, &ipv6_nd_ra_interval_msec_cmd);\n  install_element (INTERFACE_NODE, &no_ipv6_nd_ra_interval_cmd);\n  install_element (INTERFACE_NODE, &no_ipv6_nd_ra_interval_val_cmd);\n  install_element (INTERFACE_NODE, &no_ipv6_nd_ra_interval_msec_val_cmd);\n  install_element (INTERFACE_NODE, &ipv6_nd_ra_lifetime_cmd);\n  install_element (INTERFACE_NODE, &no_ipv6_nd_ra_lifetime_cmd);\n  install_element (INTERFACE_NODE, &no_ipv6_nd_ra_lifetime_val_cmd);\n  install_element (INTERFACE_NODE, &ipv6_nd_reachable_time_cmd);\n  install_element (INTERFACE_NODE, &no_ipv6_nd_reachable_time_cmd);\n  install_element (INTERFACE_NODE, &no_ipv6_nd_reachable_time_val_cmd);\n  install_element (INTERFACE_NODE, &ipv6_nd_managed_config_flag_cmd);\n  install_element (INTERFACE_NODE, &no_ipv6_nd_managed_config_flag_cmd);\n  install_element (INTERFACE_NODE, &ipv6_nd_other_config_flag_cmd);\n  install_element (INTERFACE_NODE, &no_ipv6_nd_other_config_flag_cmd);\n  install_element (INTERFACE_NODE, &ipv6_nd_homeagent_config_flag_cmd);\n  install_element (INTERFACE_NODE, &no_ipv6_nd_homeagent_config_flag_cmd);\n  install_element (INTERFACE_NODE, &ipv6_nd_homeagent_preference_cmd);\n  install_element (INTERFACE_NODE, &no_ipv6_nd_homeagent_preference_cmd);\n  install_element (INTERFACE_NODE, &no_ipv6_nd_homeagent_preference_val_cmd);\n  install_element (INTERFACE_NODE, &ipv6_nd_homeagent_lifetime_cmd);\n  install_element (INTERFACE_NODE, &no_ipv6_nd_homeagent_lifetime_cmd);\n  install_element (INTERFACE_NODE, &no_ipv6_nd_homeagent_lifetime_val_cmd);\n  install_element (INTERFACE_NODE, &ipv6_nd_adv_interval_config_option_cmd);\n  install_element (INTERFACE_NODE, &no_ipv6_nd_adv_interval_config_option_cmd);\n  install_element (INTERFACE_NODE, &ipv6_nd_prefix_cmd);\n  install_element (INTERFACE_NODE, &ipv6_nd_prefix_val_rev_rtaddr_cmd);\n  install_element (INTERFACE_NODE, &ipv6_nd_prefix_val_nortaddr_cmd);\n  install_element (INTERFACE_NODE, &ipv6_nd_prefix_val_rev_cmd);\n  install_element (INTERFACE_NODE, &ipv6_nd_prefix_val_noauto_cmd);\n  install_element (INTERFACE_NODE, &ipv6_nd_prefix_val_offlink_cmd);\n  install_element (INTERFACE_NODE, &ipv6_nd_prefix_val_rtaddr_cmd);\n  install_element (INTERFACE_NODE, &ipv6_nd_prefix_val_cmd);\n  install_element (INTERFACE_NODE, &ipv6_nd_prefix_noval_cmd);\n  install_element (INTERFACE_NODE, &ipv6_nd_prefix_noval_rev_cmd);\n  install_element (INTERFACE_NODE, &ipv6_nd_prefix_noval_noauto_cmd);\n  install_element (INTERFACE_NODE, &ipv6_nd_prefix_noval_offlink_cmd);\n  install_element (INTERFACE_NODE, &ipv6_nd_prefix_noval_rtaddr_cmd);\n  install_element (INTERFACE_NODE, &ipv6_nd_prefix_prefix_cmd);\n  install_element (INTERFACE_NODE, &no_ipv6_nd_prefix_cmd);\n  install_element (INTERFACE_NODE, &ipv6_nd_router_preference_cmd);\n  install_element (INTERFACE_NODE, &no_ipv6_nd_router_preference_cmd);\n  install_element (INTERFACE_NODE, &no_ipv6_nd_router_preference_val_cmd);\n  install_element (INTERFACE_NODE, &ipv6_nd_mtu_cmd);\n  install_element (INTERFACE_NODE, &no_ipv6_nd_mtu_cmd);\n  install_element (INTERFACE_NODE, &no_ipv6_nd_mtu_val_cmd);\n}\n\nstatic int\nif_join_all_router (int sock, struct interface *ifp)\n{\n  int ret;\n\n  struct ipv6_mreq mreq;\n\n  memset (&mreq, 0, sizeof (struct ipv6_mreq));\n  inet_pton (AF_INET6, ALLROUTER, &mreq.ipv6mr_multiaddr);\n  mreq.ipv6mr_interface = ifp->ifindex;\n\n  ret = setsockopt (sock, IPPROTO_IPV6, IPV6_JOIN_GROUP, \n\t\t    (char *) &mreq, sizeof mreq);\n  if (ret < 0)\n    zlog_warn (\"can't setsockopt IPV6_JOIN_GROUP: %s\", safe_strerror (errno));\n\n  zlog_info (\"rtadv: %s join to all-routers multicast group\", ifp->name);\n\n  return 0;\n}\n\nstatic int\nif_leave_all_router (int sock, struct interface *ifp)\n{\n  int ret;\n\n  struct ipv6_mreq mreq;\n\n  memset (&mreq, 0, sizeof (struct ipv6_mreq));\n  inet_pton (AF_INET6, ALLROUTER, &mreq.ipv6mr_multiaddr);\n  mreq.ipv6mr_interface = ifp->ifindex;\n\n  ret = setsockopt (sock, IPPROTO_IPV6, IPV6_LEAVE_GROUP, \n\t\t    (char *) &mreq, sizeof mreq);\n  if (ret < 0)\n    zlog_warn (\"can't setsockopt IPV6_LEAVE_GROUP: %s\", safe_strerror (errno));\n\n  zlog_info (\"rtadv: %s leave from all-routers multicast group\", ifp->name);\n\n  return 0;\n}\n\n#else\nvoid\nrtadv_init (struct zebra_vrf *zvrf)\n{\n  /* Empty.*/;\n}\nvoid\nrtadv_terminate (struct zebra_vrf *zvrf)\n{\n  /* Empty.*/;\n}\nvoid\nrtadv_cmd_init (void)\n{\n  /* Empty.*/;\n}\n#endif /* HAVE_RTADV && HAVE_IPV6 */\n"], "filenames": ["zebra/rtadv.c"], "buggy_code_start_loc": [485], "buggy_code_end_loc": [486], "fixing_code_start_loc": [485], "fixing_code_end_loc": [486], "type": "CWE-119", "message": "It was discovered that the zebra daemon in Quagga before 1.0.20161017 suffered from a stack-based buffer overflow when processing IPv6 Neighbor Discovery messages. The root cause was relying on BUFSIZ to be compatible with a message size; however, BUFSIZ is system-dependent.", "other": {"cve": {"id": "CVE-2016-1245", "sourceIdentifier": "security@debian.org", "published": "2017-02-22T23:59:00.143", "lastModified": "2018-01-05T02:30:33.727", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "It was discovered that the zebra daemon in Quagga before 1.0.20161017 suffered from a stack-based buffer overflow when processing IPv6 Neighbor Discovery messages. The root cause was relying on BUFSIZ to be compatible with a message size; however, BUFSIZ is system-dependent."}, {"lang": "es", "value": "Se descubri\u00f3 que el demonio zebra en Quagga en versiones anteriores a 1.0.20161017 sufri\u00f3 un desbordamiento de b\u00fafer basado en pila al procesar mensajes de Neighbor Discovery de IPv6. La causa ra\u00edz radicaba en BUFSIZ para ser compatible con un tama\u00f1o de mensaje; sin embargo, BUFSIZ depende del sistema."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:quagga:quagga:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.0.20160315", "matchCriteriaId": "B646D43D-A1C2-441B-90CE-2929F7BB072A"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}], "references": [{"url": "http://rhn.redhat.com/errata/RHSA-2017-0794.html", "source": "security@debian.org"}, {"url": "http://www.gossamer-threads.com/lists/quagga/users/31952", "source": "security@debian.org", "tags": ["Mailing List", "Mitigation", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/93775", "source": "security@debian.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1386109", "source": "security@debian.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/Quagga/quagga/commit/cfb1fae25f8c092e0d17073eaf7bd428ce1cd546", "source": "security@debian.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201701-48", "source": "security@debian.org"}, {"url": "https://www.debian.org/security/2016/dsa-3695", "source": "security@debian.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Quagga/quagga/commit/cfb1fae25f8c092e0d17073eaf7bd428ce1cd546"}}