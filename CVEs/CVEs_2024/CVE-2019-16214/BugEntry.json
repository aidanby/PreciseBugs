{"buggy_code": ["[package]\nname = \"ir_to_bytecode\"\nversion = \"0.1.0\"\nauthors = [\"Libra Association <opensource@libra.org>\"]\nlicense = \"Apache-2.0\"\npublish = false\nedition = \"2018\"\n\n[dependencies]\nfailure = { path = \"../../../common/failure_ext\", package = \"failure_ext\" }\nir_to_bytecode_syntax = { path = \"syntax\" }\ntypes = { path = \"../../../types\" }\nvm = { path = \"../../vm\" }\nlalrpop-util = \"0.16.3\"\nlog = \"0.4.7\"\ncodespan = \"0.1.3\"\ncodespan-reporting = \"0.1.4\"\nregex = \"1.2.1\"\n\n[dev-dependencies]\ntypes = { path = \"../../../types\", features = [\"testing\"] }\n", "// Copyright (c) The Libra Core Contributors\n// SPDX-License-Identifier: Apache-2.0\n\nuse codespan::{ByteIndex, CodeMap, Span};\nuse codespan_reporting::{emit, termcolor::Buffer, Diagnostic, Label, Severity};\nuse failure::*;\nuse ir_to_bytecode_syntax::syntax;\nuse lalrpop_util::ParseError;\nuse regex::Regex;\nuse std::{\n    collections::hash_map::DefaultHasher,\n    hash::{Hash, Hasher},\n};\nuse types::account_address::AccountAddress;\n\n// Re-export this to make it convenient for other crates.\npub use ir_to_bytecode_syntax::ast;\n\n// Since lalrpop can't handle comments without a custom lexer, we somewhat hackily remove all the\n// comments from the input string before passing it off to lalrpop. We only support single line\n// comments for now. Will later on add in other comment types.\nfn strip_comments(string: &str) -> String {\n    // Remove line comments\n    let line_comments = Regex::new(r\"(?m)//.*$\").unwrap();\n    line_comments.replace_all(string, \"$1\").into_owned()\n}\n\n/// Given the raw input of a file, creates a `ScriptOrModule` enum\n/// Fails with `Err(_)` if the text cannot be parsed`\npub fn parse_script_or_module(s: &str) -> Result<ast::ScriptOrModule> {\n    let stripped_string = &strip_comments(s);\n    let parser = syntax::ScriptOrModuleParser::new();\n    match parser.parse(stripped_string) {\n        Ok(result) => Ok(result),\n        Err(e) => handle_error(e, s),\n    }\n}\n\n/// Given the raw input of a file, creates a `Program` struct\n/// Fails with `Err(_)` if the text cannot be parsed\npub fn parse_program(program_str: &str) -> Result<ast::Program> {\n    let stripped_string = &strip_comments(program_str);\n    let parser = syntax::ProgramParser::new();\n    match parser.parse(stripped_string) {\n        Ok(program) => Ok(program),\n        Err(e) => handle_error(e, program_str),\n    }\n}\n\n/// Given the raw input of a file, creates a `Script` struct\n/// Fails with `Err(_)` if the text cannot be parsed\npub fn parse_script(script_str: &str) -> Result<ast::Script> {\n    let stripped_string = &strip_comments(script_str);\n    let parser = syntax::ScriptParser::new();\n    match parser.parse(stripped_string) {\n        Ok(script) => Ok(script),\n        Err(e) => handle_error(e, script_str),\n    }\n}\n\n/// Given the raw input of a file, creates a single `ModuleDefinition` struct\n/// Fails with `Err(_)` if the text cannot be parsed\npub fn parse_module(modules_str: &str) -> Result<ast::ModuleDefinition> {\n    let stripped_string = &strip_comments(modules_str);\n    let parser = syntax::ModuleParser::new();\n    match parser.parse(stripped_string) {\n        Ok(module) => Ok(module),\n        Err(e) => handle_error(e, modules_str),\n    }\n}\n\n/// Given the raw input of a file, creates a single `Cmd` struct\n/// Fails with `Err(_)` if the text cannot be parsed\npub fn parse_cmd(cmd_str: &str, _sender_address: AccountAddress) -> Result<ast::Cmd> {\n    let stripped_string = &strip_comments(cmd_str);\n    let parser = syntax::CmdParser::new();\n    match parser.parse(stripped_string) {\n        Ok(cmd) => Ok(cmd),\n        Err(e) => handle_error(e, cmd_str),\n    }\n}\n\nfn handle_error<'input, T, Token>(\n    e: lalrpop_util::ParseError<usize, Token, &'static str>,\n    code_str: &'input str,\n) -> Result<T>\nwhere\n    Token: std::fmt::Display,\n{\n    let mut s = DefaultHasher::new();\n    code_str.hash(&mut s);\n    let mut code = CodeMap::new();\n    code.add_filemap(s.finish().to_string().into(), code_str.to_string());\n    let msg = match &e {\n        ParseError::InvalidToken { location } => {\n            let error =\n                Diagnostic::new(Severity::Error, \"Invalid Token\").with_label(Label::new_primary(\n                    Span::new(ByteIndex(*location as u32), ByteIndex(*location as u32)),\n                ));\n            let mut buffer = Buffer::no_color();\n            emit(&mut buffer, &code, &error).unwrap();\n            std::str::from_utf8(buffer.as_slice()).unwrap().to_string()\n        }\n        ParseError::UnrecognizedToken {\n            token: Some((l, tok, r)),\n            expected,\n        } => {\n            let error = Diagnostic::new(Severity::Error, format!(\"Unrecognized Token: {}\", tok))\n                .with_label(\n                    Label::new_primary(Span::new(ByteIndex(*l as u32), ByteIndex(*r as u32)))\n                        .with_message(format!(\n                            \"Expected: {}\",\n                            expected\n                                .iter()\n                                .fold(String::new(), |acc, token| format!(\"{} {},\", acc, token))\n                        )),\n                );\n            let mut buffer = Buffer::no_color();\n            emit(&mut buffer, &code, &error).unwrap();\n            std::str::from_utf8(buffer.as_slice()).unwrap().to_string()\n        }\n        _ => format!(\"{}\", e),\n    };\n    println!(\"{}\", msg);\n    bail!(\"ParserError: {}\", e)\n}\n"], "fixing_code": ["[package]\nname = \"ir_to_bytecode\"\nversion = \"0.1.0\"\nauthors = [\"Libra Association <opensource@libra.org>\"]\nlicense = \"Apache-2.0\"\npublish = false\nedition = \"2018\"\n\n[dependencies]\nfailure = { path = \"../../../common/failure_ext\", package = \"failure_ext\" }\nir_to_bytecode_syntax = { path = \"syntax\" }\ntypes = { path = \"../../../types\" }\nvm = { path = \"../../vm\" }\nlalrpop-util = \"0.16.3\"\nlog = \"0.4.7\"\ncodespan = \"0.1.3\"\ncodespan-reporting = \"0.1.4\"\n\n[dev-dependencies]\ntypes = { path = \"../../../types\", features = [\"testing\"] }\n", "// Copyright (c) The Libra Core Contributors\n// SPDX-License-Identifier: Apache-2.0\n\nuse codespan::{ByteIndex, CodeMap, Span};\nuse codespan_reporting::{emit, termcolor::Buffer, Diagnostic, Label, Severity};\nuse failure::*;\nuse ir_to_bytecode_syntax::syntax;\nuse lalrpop_util::ParseError;\nuse std::{\n    collections::hash_map::DefaultHasher,\n    hash::{Hash, Hasher},\n};\nuse types::account_address::AccountAddress;\n\n// Re-export this to make it convenient for other crates.\npub use ir_to_bytecode_syntax::ast;\n\n/// Determine if a character is an allowed eye-visible (printable) character.\n///\n/// The only allowed printable characters are the printable ascii characters (SPACE through ~) and\n/// tabs. All other characters are invalid and we return false.\npub fn is_permitted_printable_char(c: char) -> bool {\n    let x = c as u32;\n    let is_above_space = x >= 0x20; // Don't allow meta characters\n    let is_below_tilde = x <= 0x7E; // Don't allow DEL meta character\n    let is_tab = x == 0x09; // Allow tabs\n    (is_above_space && is_below_tilde) || is_tab\n}\n\n/// Determine if a character is a permitted newline character.\n///\n/// The only permitted newline character is \\n. All others are invalid.\npub fn is_permitted_newline_char(c: char) -> bool {\n    let x = c as u32;\n    x == 0x0A\n}\n\n/// Determine if a character is permitted character.\n///\n/// A permitted character is either a permitted printable character, or a permitted\n/// newline. Any other characters are disallowed from appearing in the file.\npub fn is_permitted_char(c: char) -> bool {\n    is_permitted_printable_char(c) || is_permitted_newline_char(c)\n}\n\nfn verify_string(string: &str) -> Result<()> {\n    match string.chars().find(|c| !is_permitted_char(*c)) {\n        None => Ok(()),\n        Some(chr) => bail!(\n            \"Parser Error: invalid character {} found when reading file.\\\n             Only ascii printable, tabs (\\\\t), and \\\\n line ending characters are permitted.\",\n            chr\n        ),\n    }\n}\n\nfn strip_comments(source: &str) -> String {\n    const SLASH: char = '/';\n    const SPACE: char = ' ';\n\n    let mut in_comment = false;\n    let mut acc = String::with_capacity(source.len());\n    let mut char_iter = source.chars().peekable();\n\n    while let Some(chr) = char_iter.next() {\n        let at_newline = is_permitted_newline_char(chr);\n        let at_or_after_slash_slash =\n            in_comment || (chr == SLASH && char_iter.peek().map(|c| *c == SLASH).unwrap_or(false));\n        in_comment = !at_newline && at_or_after_slash_slash;\n        acc.push(if in_comment { SPACE } else { chr });\n    }\n\n    acc\n}\n\n// We restrict strings to only ascii visual characters (0x20 <= c <= 0x7E) or a permitted newline\n// character--\\n--or a tab--\\t.\nfn strip_comments_and_verify(string: &str) -> Result<String> {\n    verify_string(string)?;\n    Ok(strip_comments(string))\n}\n\n/// Given the raw input of a file, creates a `ScriptOrModule` enum\n/// Fails with `Err(_)` if the text cannot be parsed`\npub fn parse_script_or_module(s: &str) -> Result<ast::ScriptOrModule> {\n    let stripped_string = &strip_comments(s);\n    let parser = syntax::ScriptOrModuleParser::new();\n    match parser.parse(stripped_string) {\n        Ok(result) => Ok(result),\n        Err(e) => handle_error(e, s),\n    }\n}\n\n/// Given the raw input of a file, creates a `Program` struct\n/// Fails with `Err(_)` if the text cannot be parsed\npub fn parse_program(program_str: &str) -> Result<ast::Program> {\n    let stripped_string = &strip_comments_and_verify(program_str)?;\n    let parser = syntax::ProgramParser::new();\n    match parser.parse(stripped_string) {\n        Ok(program) => Ok(program),\n        Err(e) => handle_error(e, stripped_string),\n    }\n}\n\n/// Given the raw input of a file, creates a `Script` struct\n/// Fails with `Err(_)` if the text cannot be parsed\npub fn parse_script(script_str: &str) -> Result<ast::Script> {\n    let stripped_string = &strip_comments_and_verify(script_str)?;\n    let parser = syntax::ScriptParser::new();\n    match parser.parse(stripped_string) {\n        Ok(script) => Ok(script),\n        Err(e) => handle_error(e, stripped_string),\n    }\n}\n\n/// Given the raw input of a file, creates a single `ModuleDefinition` struct\n/// Fails with `Err(_)` if the text cannot be parsed\npub fn parse_module(modules_str: &str) -> Result<ast::ModuleDefinition> {\n    let stripped_string = &strip_comments_and_verify(modules_str)?;\n    let parser = syntax::ModuleParser::new();\n    match parser.parse(stripped_string) {\n        Ok(module) => Ok(module),\n        Err(e) => handle_error(e, stripped_string),\n    }\n}\n\n/// Given the raw input of a file, creates a single `Cmd` struct\n/// Fails with `Err(_)` if the text cannot be parsed\npub fn parse_cmd(cmd_str: &str, _sender_address: AccountAddress) -> Result<ast::Cmd> {\n    let stripped_string = &strip_comments_and_verify(cmd_str)?;\n    let parser = syntax::CmdParser::new();\n    match parser.parse(stripped_string) {\n        Ok(cmd) => Ok(cmd),\n        Err(e) => handle_error(e, stripped_string),\n    }\n}\n\nfn handle_error<'input, T, Token>(\n    e: lalrpop_util::ParseError<usize, Token, &'static str>,\n    code_str: &'input str,\n) -> Result<T>\nwhere\n    Token: std::fmt::Display,\n{\n    let mut s = DefaultHasher::new();\n    code_str.hash(&mut s);\n    let mut code = CodeMap::new();\n    code.add_filemap(s.finish().to_string().into(), code_str.to_string());\n    let msg = match &e {\n        ParseError::InvalidToken { location } => {\n            let error =\n                Diagnostic::new(Severity::Error, \"Invalid Token\").with_label(Label::new_primary(\n                    Span::new(ByteIndex(*location as u32), ByteIndex(*location as u32)),\n                ));\n            let mut buffer = Buffer::no_color();\n            emit(&mut buffer, &code, &error).unwrap();\n            std::str::from_utf8(buffer.as_slice()).unwrap().to_string()\n        }\n        ParseError::UnrecognizedToken {\n            token: Some((l, tok, r)),\n            expected,\n        } => {\n            let error = Diagnostic::new(Severity::Error, format!(\"Unrecognized Token: {}\", tok))\n                .with_label(\n                    Label::new_primary(Span::new(ByteIndex(*l as u32), ByteIndex(*r as u32)))\n                        .with_message(format!(\n                            \"Expected: {}\",\n                            expected\n                                .iter()\n                                .fold(String::new(), |acc, token| format!(\"{} {},\", acc, token))\n                        )),\n                );\n            let mut buffer = Buffer::no_color();\n            emit(&mut buffer, &code, &error).unwrap();\n            std::str::from_utf8(buffer.as_slice()).unwrap().to_string()\n        }\n        _ => format!(\"{}\", e),\n    };\n    println!(\"{}\", msg);\n    bail!(\"ParserError: {}\", e)\n}\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn verify_character_whitelist() {\n        let mut good_chars = (0x20..=0x7E).collect::<Vec<u8>>();\n        good_chars.push(0x0A);\n        good_chars.push(0x09);\n\n        let mut bad_chars = (0x0..0x09).collect::<Vec<_>>();\n        bad_chars.append(&mut (0x0B..=0x1F).collect::<Vec<_>>());\n        bad_chars.push(0x7F);\n\n        // Test to make sure that all the characters that are in the whitelist pass.\n        {\n            let s = std::str::from_utf8(&good_chars)\n                .expect(\"Failed to construct string containing an invalid character. This shouldn't happen.\");\n            assert!(super::verify_string(s).is_ok());\n        }\n\n        // Test to make sure that we fail for all characters not in the whitelist.\n        for bad_char in bad_chars {\n            good_chars.push(bad_char);\n            let s = std::str::from_utf8(&good_chars)\n                .expect(\"Failed to construct string containing an invalid character. This shouldn't happen.\");\n            assert!(super::verify_string(s).is_err());\n            good_chars.pop();\n        }\n    }\n\n    #[test]\n    fn test_strip_comments() {\n        let mut good_chars = (0x20..=0x7E).map(|x: u8| x as char).collect::<String>();\n        good_chars.push(0x09 as char);\n        good_chars.push(0x0A as char);\n        good_chars.insert(0, 0x2F as char);\n        good_chars.insert(0, 0x2F as char);\n\n        {\n            let x = super::strip_comments(&good_chars);\n            assert!(x.chars().all(|x| x == ' ' || x == '\\t' || x == '\\n'));\n        }\n\n        // Remove the \\n at the end of the line\n        good_chars.pop();\n\n        let bad_chars: Vec<u8> = vec![\n            0x0B, // VT\n            0x0C, // FF\n            0x0D, // CR\n            0x0D, 0x0A, // CRLF\n            0xC2, 0x85, // NEL\n            0xE2, 0x80, 0xA8, // LS\n            0xE2, 0x80, 0xA9, // PS\n            0x1E, // RS\n            0x15, // NL\n            0x76, // NEWLINE\n        ];\n\n        let bad_chars = std::str::from_utf8(&bad_chars).expect(\n            \"Failed to construct string containing an invalid character. This shouldn't happen.\",\n        );\n        for bad_char in bad_chars.chars() {\n            good_chars.push(bad_char);\n            good_chars.push('\\n');\n            good_chars.push('a');\n            let x = super::strip_comments(&good_chars);\n            assert!(x\n                .chars()\n                .all(|c| c == ' ' || c == '\\t' || c == '\\n' || c == 'a'));\n            good_chars.pop();\n            good_chars.pop();\n            good_chars.pop();\n        }\n    }\n}\n"], "filenames": ["language/compiler/ir_to_bytecode/Cargo.toml", "language/compiler/ir_to_bytecode/src/parser.rs"], "buggy_code_start_loc": [18, 9], "buggy_code_end_loc": [19, 126], "fixing_code_start_loc": [17, 8], "fixing_code_end_loc": [17, 258], "type": "NVD-CWE-noinfo", "message": "Libra Core before 2019-09-03 has an erroneous regular expression for inline comments, which makes it easier for attackers to interfere with code auditing by using a nonstandard line-break character for a comment. For example, a Move module author can enter the // sequence (which introduces a single-line comment), followed by very brief comment text, the \\r character, and code that has security-critical functionality. In many popular environments, this code is displayed on a separate line, and thus a reader may infer that the code is executed. However, the code is NOT executed, because language/compiler/ir_to_bytecode/src/parser.rs allows the comment to continue after the \\r character.", "other": {"cve": {"id": "CVE-2019-16214", "sourceIdentifier": "cve@mitre.org", "published": "2019-09-11T04:15:11.887", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Libra Core before 2019-09-03 has an erroneous regular expression for inline comments, which makes it easier for attackers to interfere with code auditing by using a nonstandard line-break character for a comment. For example, a Move module author can enter the // sequence (which introduces a single-line comment), followed by very brief comment text, the \\r character, and code that has security-critical functionality. In many popular environments, this code is displayed on a separate line, and thus a reader may infer that the code is executed. However, the code is NOT executed, because language/compiler/ir_to_bytecode/src/parser.rs allows the comment to continue after the \\r character."}, {"lang": "es", "value": "Libra Core antes del 03-09-2019, presenta una expresi\u00f3n regular err\u00f3nea para comentarios en l\u00ednea, lo que hace m\u00e1s f\u00e1cil para que atacantes interfieran con la auditoria del c\u00f3digo mediante el uso de un car\u00e1cter de salto de l\u00ednea no est\u00e1ndar para un comentario. Por ejemplo, un autor del m\u00f3dulo Move puede ingresar la secuencia // (que introduce un comentario de una sola l\u00ednea), seguido por un texto de comentario muy breve, el car\u00e1cter \\r y el c\u00f3digo que posee una funcionalidad cr\u00edtica para la seguridad. En muchos entornos populares, este c\u00f3digo es desplegado en una l\u00ednea separada y, por lo tanto, un lector puede inferir que el c\u00f3digo est\u00e1 ejecutado. Sin embargo, el c\u00f3digo NO se ejecuta, porque el archivo language/compiler/ir_to_bytecode/src/parser.rs permite que el comentario contin\u00fae despu\u00e9s del car\u00e1cter \\r."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 5.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libra:libra_core:*:*:*:*:*:*:*:*", "versionEndExcluding": "2019-09-03", "matchCriteriaId": "A2E55F3B-1682-470D-83BA-9452A91FBF98"}]}]}], "references": [{"url": "https://blog.openzeppelin.com/libra-vulnerability-release/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://blog.openzeppelin.com/libra-vulnerability-summary/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/libra/libra/commit/7efb0221989f17fdf7f8486730898ed947a1e19e", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/libra/libra/commit/7efb0221989f17fdf7f8486730898ed947a1e19e"}}