{"buggy_code": ["/*\n * Copyright (C) 2014 Red Hat\n * Copyright (C) 2014 Intel Corp.\n * Copyright (c) 2020-2021, The Linux Foundation. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR\n * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n *\n * Authors:\n * Rob Clark <robdclark@gmail.com>\n * Daniel Vetter <daniel.vetter@ffwll.ch>\n */\n\n\n#include <linux/sync_file.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_uapi.h>\n#include <drm/drm_blend.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_debugfs.h>\n#include <drm/drm_device.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_file.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_mode.h>\n#include <drm/drm_print.h>\n#include <drm/drm_writeback.h>\n\n#include \"drm_crtc_internal.h\"\n#include \"drm_internal.h\"\n\nvoid __drm_crtc_commit_free(struct kref *kref)\n{\n\tstruct drm_crtc_commit *commit =\n\t\tcontainer_of(kref, struct drm_crtc_commit, ref);\n\n\tkfree(commit);\n}\nEXPORT_SYMBOL(__drm_crtc_commit_free);\n\n/**\n * drm_crtc_commit_wait - Waits for a commit to complete\n * @commit: &drm_crtc_commit to wait for\n *\n * Waits for a given &drm_crtc_commit to be programmed into the\n * hardware and flipped to.\n *\n * Returns:\n *\n * 0 on success, a negative error code otherwise.\n */\nint drm_crtc_commit_wait(struct drm_crtc_commit *commit)\n{\n\tunsigned long timeout = 10 * HZ;\n\tint ret;\n\n\tif (!commit)\n\t\treturn 0;\n\n\tret = wait_for_completion_timeout(&commit->hw_done, timeout);\n\tif (!ret) {\n\t\tdrm_err(commit->crtc->dev, \"hw_done timed out\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t/*\n\t * Currently no support for overwriting flips, hence\n\t * stall for previous one to execute completely.\n\t */\n\tret = wait_for_completion_timeout(&commit->flip_done, timeout);\n\tif (!ret) {\n\t\tdrm_err(commit->crtc->dev, \"flip_done timed out\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_crtc_commit_wait);\n\n/**\n * drm_atomic_state_default_release -\n * release memory initialized by drm_atomic_state_init\n * @state: atomic state\n *\n * Free all the memory allocated by drm_atomic_state_init.\n * This should only be used by drivers which are still subclassing\n * &drm_atomic_state and haven't switched to &drm_private_state yet.\n */\nvoid drm_atomic_state_default_release(struct drm_atomic_state *state)\n{\n\tkfree(state->connectors);\n\tkfree(state->crtcs);\n\tkfree(state->planes);\n\tkfree(state->private_objs);\n}\nEXPORT_SYMBOL(drm_atomic_state_default_release);\n\n/**\n * drm_atomic_state_init - init new atomic state\n * @dev: DRM device\n * @state: atomic state\n *\n * Default implementation for filling in a new atomic state.\n * This should only be used by drivers which are still subclassing\n * &drm_atomic_state and haven't switched to &drm_private_state yet.\n */\nint\ndrm_atomic_state_init(struct drm_device *dev, struct drm_atomic_state *state)\n{\n\tkref_init(&state->ref);\n\n\t/* TODO legacy paths should maybe do a better job about\n\t * setting this appropriately?\n\t */\n\tstate->allow_modeset = true;\n\n\tstate->crtcs = kcalloc(dev->mode_config.num_crtc,\n\t\t\t       sizeof(*state->crtcs), GFP_KERNEL);\n\tif (!state->crtcs)\n\t\tgoto fail;\n\tstate->planes = kcalloc(dev->mode_config.num_total_plane,\n\t\t\t\tsizeof(*state->planes), GFP_KERNEL);\n\tif (!state->planes)\n\t\tgoto fail;\n\n\tstate->dev = dev;\n\n\tdrm_dbg_atomic(dev, \"Allocated atomic state %p\\n\", state);\n\n\treturn 0;\nfail:\n\tdrm_atomic_state_default_release(state);\n\treturn -ENOMEM;\n}\nEXPORT_SYMBOL(drm_atomic_state_init);\n\n/**\n * drm_atomic_state_alloc - allocate atomic state\n * @dev: DRM device\n *\n * This allocates an empty atomic state to track updates.\n */\nstruct drm_atomic_state *\ndrm_atomic_state_alloc(struct drm_device *dev)\n{\n\tstruct drm_mode_config *config = &dev->mode_config;\n\n\tif (!config->funcs->atomic_state_alloc) {\n\t\tstruct drm_atomic_state *state;\n\n\t\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\t\tif (!state)\n\t\t\treturn NULL;\n\t\tif (drm_atomic_state_init(dev, state) < 0) {\n\t\t\tkfree(state);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn state;\n\t}\n\n\treturn config->funcs->atomic_state_alloc(dev);\n}\nEXPORT_SYMBOL(drm_atomic_state_alloc);\n\n/**\n * drm_atomic_state_default_clear - clear base atomic state\n * @state: atomic state\n *\n * Default implementation for clearing atomic state.\n * This should only be used by drivers which are still subclassing\n * &drm_atomic_state and haven't switched to &drm_private_state yet.\n */\nvoid drm_atomic_state_default_clear(struct drm_atomic_state *state)\n{\n\tstruct drm_device *dev = state->dev;\n\tstruct drm_mode_config *config = &dev->mode_config;\n\tint i;\n\n\tdrm_dbg_atomic(dev, \"Clearing atomic state %p\\n\", state);\n\n\tfor (i = 0; i < state->num_connector; i++) {\n\t\tstruct drm_connector *connector = state->connectors[i].ptr;\n\n\t\tif (!connector)\n\t\t\tcontinue;\n\n\t\tconnector->funcs->atomic_destroy_state(connector,\n\t\t\t\t\t\t       state->connectors[i].state);\n\t\tstate->connectors[i].ptr = NULL;\n\t\tstate->connectors[i].state = NULL;\n\t\tstate->connectors[i].old_state = NULL;\n\t\tstate->connectors[i].new_state = NULL;\n\t\tdrm_connector_put(connector);\n\t}\n\n\tfor (i = 0; i < config->num_crtc; i++) {\n\t\tstruct drm_crtc *crtc = state->crtcs[i].ptr;\n\n\t\tif (!crtc)\n\t\t\tcontinue;\n\n\t\tcrtc->funcs->atomic_destroy_state(crtc,\n\t\t\t\t\t\t  state->crtcs[i].state);\n\n\t\tstate->crtcs[i].ptr = NULL;\n\t\tstate->crtcs[i].state = NULL;\n\t\tstate->crtcs[i].old_state = NULL;\n\t\tstate->crtcs[i].new_state = NULL;\n\n\t\tif (state->crtcs[i].commit) {\n\t\t\tdrm_crtc_commit_put(state->crtcs[i].commit);\n\t\t\tstate->crtcs[i].commit = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < config->num_total_plane; i++) {\n\t\tstruct drm_plane *plane = state->planes[i].ptr;\n\n\t\tif (!plane)\n\t\t\tcontinue;\n\n\t\tplane->funcs->atomic_destroy_state(plane,\n\t\t\t\t\t\t   state->planes[i].state);\n\t\tstate->planes[i].ptr = NULL;\n\t\tstate->planes[i].state = NULL;\n\t\tstate->planes[i].old_state = NULL;\n\t\tstate->planes[i].new_state = NULL;\n\t}\n\n\tfor (i = 0; i < state->num_private_objs; i++) {\n\t\tstruct drm_private_obj *obj = state->private_objs[i].ptr;\n\n\t\tobj->funcs->atomic_destroy_state(obj,\n\t\t\t\t\t\t state->private_objs[i].state);\n\t\tstate->private_objs[i].ptr = NULL;\n\t\tstate->private_objs[i].state = NULL;\n\t\tstate->private_objs[i].old_state = NULL;\n\t\tstate->private_objs[i].new_state = NULL;\n\t}\n\tstate->num_private_objs = 0;\n\n\tif (state->fake_commit) {\n\t\tdrm_crtc_commit_put(state->fake_commit);\n\t\tstate->fake_commit = NULL;\n\t}\n}\nEXPORT_SYMBOL(drm_atomic_state_default_clear);\n\n/**\n * drm_atomic_state_clear - clear state object\n * @state: atomic state\n *\n * When the w/w mutex algorithm detects a deadlock we need to back off and drop\n * all locks. So someone else could sneak in and change the current modeset\n * configuration. Which means that all the state assembled in @state is no\n * longer an atomic update to the current state, but to some arbitrary earlier\n * state. Which could break assumptions the driver's\n * &drm_mode_config_funcs.atomic_check likely relies on.\n *\n * Hence we must clear all cached state and completely start over, using this\n * function.\n */\nvoid drm_atomic_state_clear(struct drm_atomic_state *state)\n{\n\tstruct drm_device *dev = state->dev;\n\tstruct drm_mode_config *config = &dev->mode_config;\n\n\tif (config->funcs->atomic_state_clear)\n\t\tconfig->funcs->atomic_state_clear(state);\n\telse\n\t\tdrm_atomic_state_default_clear(state);\n}\nEXPORT_SYMBOL(drm_atomic_state_clear);\n\n/**\n * __drm_atomic_state_free - free all memory for an atomic state\n * @ref: This atomic state to deallocate\n *\n * This frees all memory associated with an atomic state, including all the\n * per-object state for planes, CRTCs and connectors.\n */\nvoid __drm_atomic_state_free(struct kref *ref)\n{\n\tstruct drm_atomic_state *state = container_of(ref, typeof(*state), ref);\n\tstruct drm_mode_config *config = &state->dev->mode_config;\n\n\tdrm_atomic_state_clear(state);\n\n\tdrm_dbg_atomic(state->dev, \"Freeing atomic state %p\\n\", state);\n\n\tif (config->funcs->atomic_state_free) {\n\t\tconfig->funcs->atomic_state_free(state);\n\t} else {\n\t\tdrm_atomic_state_default_release(state);\n\t\tkfree(state);\n\t}\n}\nEXPORT_SYMBOL(__drm_atomic_state_free);\n\n/**\n * drm_atomic_get_crtc_state - get CRTC state\n * @state: global atomic state object\n * @crtc: CRTC to get state object for\n *\n * This function returns the CRTC state for the given CRTC, allocating it if\n * needed. It will also grab the relevant CRTC lock to make sure that the state\n * is consistent.\n *\n * WARNING: Drivers may only add new CRTC states to a @state if\n * drm_atomic_state.allow_modeset is set, or if it's a driver-internal commit\n * not created by userspace through an IOCTL call.\n *\n * Returns:\n *\n * Either the allocated state or the error code encoded into the pointer. When\n * the error is EDEADLK then the w/w mutex code has detected a deadlock and the\n * entire atomic sequence must be restarted. All other errors are fatal.\n */\nstruct drm_crtc_state *\ndrm_atomic_get_crtc_state(struct drm_atomic_state *state,\n\t\t\t  struct drm_crtc *crtc)\n{\n\tint ret, index = drm_crtc_index(crtc);\n\tstruct drm_crtc_state *crtc_state;\n\n\tWARN_ON(!state->acquire_ctx);\n\n\tcrtc_state = drm_atomic_get_existing_crtc_state(state, crtc);\n\tif (crtc_state)\n\t\treturn crtc_state;\n\n\tret = drm_modeset_lock(&crtc->mutex, state->acquire_ctx);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tcrtc_state = crtc->funcs->atomic_duplicate_state(crtc);\n\tif (!crtc_state)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstate->crtcs[index].state = crtc_state;\n\tstate->crtcs[index].old_state = crtc->state;\n\tstate->crtcs[index].new_state = crtc_state;\n\tstate->crtcs[index].ptr = crtc;\n\tcrtc_state->state = state;\n\n\tdrm_dbg_atomic(state->dev, \"Added [CRTC:%d:%s] %p state to %p\\n\",\n\t\t       crtc->base.id, crtc->name, crtc_state, state);\n\n\treturn crtc_state;\n}\nEXPORT_SYMBOL(drm_atomic_get_crtc_state);\n\nstatic int drm_atomic_crtc_check(const struct drm_crtc_state *old_crtc_state,\n\t\t\t\t const struct drm_crtc_state *new_crtc_state)\n{\n\tstruct drm_crtc *crtc = new_crtc_state->crtc;\n\n\t/* NOTE: we explicitly don't enforce constraints such as primary\n\t * layer covering entire screen, since that is something we want\n\t * to allow (on hw that supports it).  For hw that does not, it\n\t * should be checked in driver's crtc->atomic_check() vfunc.\n\t *\n\t * TODO: Add generic modeset state checks once we support those.\n\t */\n\n\tif (new_crtc_state->active && !new_crtc_state->enable) {\n\t\tdrm_dbg_atomic(crtc->dev,\n\t\t\t       \"[CRTC:%d:%s] active without enabled\\n\",\n\t\t\t       crtc->base.id, crtc->name);\n\t\treturn -EINVAL;\n\t}\n\n\t/* The state->enable vs. state->mode_blob checks can be WARN_ON,\n\t * as this is a kernel-internal detail that userspace should never\n\t * be able to trigger.\n\t */\n\tif (drm_core_check_feature(crtc->dev, DRIVER_ATOMIC) &&\n\t    WARN_ON(new_crtc_state->enable && !new_crtc_state->mode_blob)) {\n\t\tdrm_dbg_atomic(crtc->dev,\n\t\t\t       \"[CRTC:%d:%s] enabled without mode blob\\n\",\n\t\t\t       crtc->base.id, crtc->name);\n\t\treturn -EINVAL;\n\t}\n\n\tif (drm_core_check_feature(crtc->dev, DRIVER_ATOMIC) &&\n\t    WARN_ON(!new_crtc_state->enable && new_crtc_state->mode_blob)) {\n\t\tdrm_dbg_atomic(crtc->dev,\n\t\t\t       \"[CRTC:%d:%s] disabled with mode blob\\n\",\n\t\t\t       crtc->base.id, crtc->name);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Reject event generation for when a CRTC is off and stays off.\n\t * It wouldn't be hard to implement this, but userspace has a track\n\t * record of happily burning through 100% cpu (or worse, crash) when the\n\t * display pipe is suspended. To avoid all that fun just reject updates\n\t * that ask for events since likely that indicates a bug in the\n\t * compositor's drawing loop. This is consistent with the vblank IOCTL\n\t * and legacy page_flip IOCTL which also reject service on a disabled\n\t * pipe.\n\t */\n\tif (new_crtc_state->event &&\n\t    !new_crtc_state->active && !old_crtc_state->active) {\n\t\tdrm_dbg_atomic(crtc->dev,\n\t\t\t       \"[CRTC:%d:%s] requesting event but off\\n\",\n\t\t\t       crtc->base.id, crtc->name);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void drm_atomic_crtc_print_state(struct drm_printer *p,\n\t\tconst struct drm_crtc_state *state)\n{\n\tstruct drm_crtc *crtc = state->crtc;\n\n\tdrm_printf(p, \"crtc[%u]: %s\\n\", crtc->base.id, crtc->name);\n\tdrm_printf(p, \"\\tenable=%d\\n\", state->enable);\n\tdrm_printf(p, \"\\tactive=%d\\n\", state->active);\n\tdrm_printf(p, \"\\tself_refresh_active=%d\\n\", state->self_refresh_active);\n\tdrm_printf(p, \"\\tplanes_changed=%d\\n\", state->planes_changed);\n\tdrm_printf(p, \"\\tmode_changed=%d\\n\", state->mode_changed);\n\tdrm_printf(p, \"\\tactive_changed=%d\\n\", state->active_changed);\n\tdrm_printf(p, \"\\tconnectors_changed=%d\\n\", state->connectors_changed);\n\tdrm_printf(p, \"\\tcolor_mgmt_changed=%d\\n\", state->color_mgmt_changed);\n\tdrm_printf(p, \"\\tplane_mask=%x\\n\", state->plane_mask);\n\tdrm_printf(p, \"\\tconnector_mask=%x\\n\", state->connector_mask);\n\tdrm_printf(p, \"\\tencoder_mask=%x\\n\", state->encoder_mask);\n\tdrm_printf(p, \"\\tmode: \" DRM_MODE_FMT \"\\n\", DRM_MODE_ARG(&state->mode));\n\n\tif (crtc->funcs->atomic_print_state)\n\t\tcrtc->funcs->atomic_print_state(p, state);\n}\n\nstatic int drm_atomic_connector_check(struct drm_connector *connector,\n\t\tstruct drm_connector_state *state)\n{\n\tstruct drm_crtc_state *crtc_state;\n\tstruct drm_writeback_job *writeback_job = state->writeback_job;\n\tconst struct drm_display_info *info = &connector->display_info;\n\n\tstate->max_bpc = info->bpc ? info->bpc : 8;\n\tif (connector->max_bpc_property)\n\t\tstate->max_bpc = min(state->max_bpc, state->max_requested_bpc);\n\n\tif ((connector->connector_type != DRM_MODE_CONNECTOR_WRITEBACK) || !writeback_job)\n\t\treturn 0;\n\n\tif (writeback_job->fb && !state->crtc) {\n\t\tdrm_dbg_atomic(connector->dev,\n\t\t\t       \"[CONNECTOR:%d:%s] framebuffer without CRTC\\n\",\n\t\t\t       connector->base.id, connector->name);\n\t\treturn -EINVAL;\n\t}\n\n\tif (state->crtc)\n\t\tcrtc_state = drm_atomic_get_existing_crtc_state(state->state,\n\t\t\t\t\t\t\t\tstate->crtc);\n\n\tif (writeback_job->fb && !crtc_state->active) {\n\t\tdrm_dbg_atomic(connector->dev,\n\t\t\t       \"[CONNECTOR:%d:%s] has framebuffer, but [CRTC:%d] is off\\n\",\n\t\t\t       connector->base.id, connector->name,\n\t\t\t       state->crtc->base.id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!writeback_job->fb) {\n\t\tif (writeback_job->out_fence) {\n\t\t\tdrm_dbg_atomic(connector->dev,\n\t\t\t\t       \"[CONNECTOR:%d:%s] requesting out-fence without framebuffer\\n\",\n\t\t\t\t       connector->base.id, connector->name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tdrm_writeback_cleanup_job(writeback_job);\n\t\tstate->writeback_job = NULL;\n\t}\n\n\treturn 0;\n}\n\n/**\n * drm_atomic_get_plane_state - get plane state\n * @state: global atomic state object\n * @plane: plane to get state object for\n *\n * This function returns the plane state for the given plane, allocating it if\n * needed. It will also grab the relevant plane lock to make sure that the state\n * is consistent.\n *\n * Returns:\n *\n * Either the allocated state or the error code encoded into the pointer. When\n * the error is EDEADLK then the w/w mutex code has detected a deadlock and the\n * entire atomic sequence must be restarted. All other errors are fatal.\n */\nstruct drm_plane_state *\ndrm_atomic_get_plane_state(struct drm_atomic_state *state,\n\t\t\t  struct drm_plane *plane)\n{\n\tint ret, index = drm_plane_index(plane);\n\tstruct drm_plane_state *plane_state;\n\n\tWARN_ON(!state->acquire_ctx);\n\n\t/* the legacy pointers should never be set */\n\tWARN_ON(plane->fb);\n\tWARN_ON(plane->old_fb);\n\tWARN_ON(plane->crtc);\n\n\tplane_state = drm_atomic_get_existing_plane_state(state, plane);\n\tif (plane_state)\n\t\treturn plane_state;\n\n\tret = drm_modeset_lock(&plane->mutex, state->acquire_ctx);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tplane_state = plane->funcs->atomic_duplicate_state(plane);\n\tif (!plane_state)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstate->planes[index].state = plane_state;\n\tstate->planes[index].ptr = plane;\n\tstate->planes[index].old_state = plane->state;\n\tstate->planes[index].new_state = plane_state;\n\tplane_state->state = state;\n\n\tdrm_dbg_atomic(plane->dev, \"Added [PLANE:%d:%s] %p state to %p\\n\",\n\t\t       plane->base.id, plane->name, plane_state, state);\n\n\tif (plane_state->crtc) {\n\t\tstruct drm_crtc_state *crtc_state;\n\n\t\tcrtc_state = drm_atomic_get_crtc_state(state,\n\t\t\t\t\t\t       plane_state->crtc);\n\t\tif (IS_ERR(crtc_state))\n\t\t\treturn ERR_CAST(crtc_state);\n\t}\n\n\treturn plane_state;\n}\nEXPORT_SYMBOL(drm_atomic_get_plane_state);\n\nstatic bool\nplane_switching_crtc(const struct drm_plane_state *old_plane_state,\n\t\t     const struct drm_plane_state *new_plane_state)\n{\n\tif (!old_plane_state->crtc || !new_plane_state->crtc)\n\t\treturn false;\n\n\tif (old_plane_state->crtc == new_plane_state->crtc)\n\t\treturn false;\n\n\t/* This could be refined, but currently there's no helper or driver code\n\t * to implement direct switching of active planes nor userspace to take\n\t * advantage of more direct plane switching without the intermediate\n\t * full OFF state.\n\t */\n\treturn true;\n}\n\n/**\n * drm_atomic_plane_check - check plane state\n * @old_plane_state: old plane state to check\n * @new_plane_state: new plane state to check\n *\n * Provides core sanity checks for plane state.\n *\n * RETURNS:\n * Zero on success, error code on failure\n */\nstatic int drm_atomic_plane_check(const struct drm_plane_state *old_plane_state,\n\t\t\t\t  const struct drm_plane_state *new_plane_state)\n{\n\tstruct drm_plane *plane = new_plane_state->plane;\n\tstruct drm_crtc *crtc = new_plane_state->crtc;\n\tconst struct drm_framebuffer *fb = new_plane_state->fb;\n\tunsigned int fb_width, fb_height;\n\tstruct drm_mode_rect *clips;\n\tuint32_t num_clips;\n\tint ret;\n\n\t/* either *both* CRTC and FB must be set, or neither */\n\tif (crtc && !fb) {\n\t\tdrm_dbg_atomic(plane->dev, \"[PLANE:%d:%s] CRTC set but no FB\\n\",\n\t\t\t       plane->base.id, plane->name);\n\t\treturn -EINVAL;\n\t} else if (fb && !crtc) {\n\t\tdrm_dbg_atomic(plane->dev, \"[PLANE:%d:%s] FB set but no CRTC\\n\",\n\t\t\t       plane->base.id, plane->name);\n\t\treturn -EINVAL;\n\t}\n\n\t/* if disabled, we don't care about the rest of the state: */\n\tif (!crtc)\n\t\treturn 0;\n\n\t/* Check whether this plane is usable on this CRTC */\n\tif (!(plane->possible_crtcs & drm_crtc_mask(crtc))) {\n\t\tdrm_dbg_atomic(plane->dev,\n\t\t\t       \"Invalid [CRTC:%d:%s] for [PLANE:%d:%s]\\n\",\n\t\t\t       crtc->base.id, crtc->name,\n\t\t\t       plane->base.id, plane->name);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check whether this plane supports the fb pixel format. */\n\tret = drm_plane_check_pixel_format(plane, fb->format->format,\n\t\t\t\t\t   fb->modifier);\n\tif (ret) {\n\t\tdrm_dbg_atomic(plane->dev,\n\t\t\t       \"[PLANE:%d:%s] invalid pixel format %p4cc, modifier 0x%llx\\n\",\n\t\t\t       plane->base.id, plane->name,\n\t\t\t       &fb->format->format, fb->modifier);\n\t\treturn ret;\n\t}\n\n\t/* Give drivers some help against integer overflows */\n\tif (new_plane_state->crtc_w > INT_MAX ||\n\t    new_plane_state->crtc_x > INT_MAX - (int32_t) new_plane_state->crtc_w ||\n\t    new_plane_state->crtc_h > INT_MAX ||\n\t    new_plane_state->crtc_y > INT_MAX - (int32_t) new_plane_state->crtc_h) {\n\t\tdrm_dbg_atomic(plane->dev,\n\t\t\t       \"[PLANE:%d:%s] invalid CRTC coordinates %ux%u+%d+%d\\n\",\n\t\t\t       plane->base.id, plane->name,\n\t\t\t       new_plane_state->crtc_w, new_plane_state->crtc_h,\n\t\t\t       new_plane_state->crtc_x, new_plane_state->crtc_y);\n\t\treturn -ERANGE;\n\t}\n\n\tfb_width = fb->width << 16;\n\tfb_height = fb->height << 16;\n\n\t/* Make sure source coordinates are inside the fb. */\n\tif (new_plane_state->src_w > fb_width ||\n\t    new_plane_state->src_x > fb_width - new_plane_state->src_w ||\n\t    new_plane_state->src_h > fb_height ||\n\t    new_plane_state->src_y > fb_height - new_plane_state->src_h) {\n\t\tdrm_dbg_atomic(plane->dev,\n\t\t\t       \"[PLANE:%d:%s] invalid source coordinates \"\n\t\t\t       \"%u.%06ux%u.%06u+%u.%06u+%u.%06u (fb %ux%u)\\n\",\n\t\t\t       plane->base.id, plane->name,\n\t\t\t       new_plane_state->src_w >> 16,\n\t\t\t       ((new_plane_state->src_w & 0xffff) * 15625) >> 10,\n\t\t\t       new_plane_state->src_h >> 16,\n\t\t\t       ((new_plane_state->src_h & 0xffff) * 15625) >> 10,\n\t\t\t       new_plane_state->src_x >> 16,\n\t\t\t       ((new_plane_state->src_x & 0xffff) * 15625) >> 10,\n\t\t\t       new_plane_state->src_y >> 16,\n\t\t\t       ((new_plane_state->src_y & 0xffff) * 15625) >> 10,\n\t\t\t       fb->width, fb->height);\n\t\treturn -ENOSPC;\n\t}\n\n\tclips = __drm_plane_get_damage_clips(new_plane_state);\n\tnum_clips = drm_plane_get_damage_clips_count(new_plane_state);\n\n\t/* Make sure damage clips are valid and inside the fb. */\n\twhile (num_clips > 0) {\n\t\tif (clips->x1 >= clips->x2 ||\n\t\t    clips->y1 >= clips->y2 ||\n\t\t    clips->x1 < 0 ||\n\t\t    clips->y1 < 0 ||\n\t\t    clips->x2 > fb_width ||\n\t\t    clips->y2 > fb_height) {\n\t\t\tdrm_dbg_atomic(plane->dev,\n\t\t\t\t       \"[PLANE:%d:%s] invalid damage clip %d %d %d %d\\n\",\n\t\t\t\t       plane->base.id, plane->name, clips->x1,\n\t\t\t\t       clips->y1, clips->x2, clips->y2);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tclips++;\n\t\tnum_clips--;\n\t}\n\n\tif (plane_switching_crtc(old_plane_state, new_plane_state)) {\n\t\tdrm_dbg_atomic(plane->dev,\n\t\t\t       \"[PLANE:%d:%s] switching CRTC directly\\n\",\n\t\t\t       plane->base.id, plane->name);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void drm_atomic_plane_print_state(struct drm_printer *p,\n\t\tconst struct drm_plane_state *state)\n{\n\tstruct drm_plane *plane = state->plane;\n\tstruct drm_rect src  = drm_plane_state_src(state);\n\tstruct drm_rect dest = drm_plane_state_dest(state);\n\n\tdrm_printf(p, \"plane[%u]: %s\\n\", plane->base.id, plane->name);\n\tdrm_printf(p, \"\\tcrtc=%s\\n\", state->crtc ? state->crtc->name : \"(null)\");\n\tdrm_printf(p, \"\\tfb=%u\\n\", state->fb ? state->fb->base.id : 0);\n\tif (state->fb)\n\t\tdrm_framebuffer_print_info(p, 2, state->fb);\n\tdrm_printf(p, \"\\tcrtc-pos=\" DRM_RECT_FMT \"\\n\", DRM_RECT_ARG(&dest));\n\tdrm_printf(p, \"\\tsrc-pos=\" DRM_RECT_FP_FMT \"\\n\", DRM_RECT_FP_ARG(&src));\n\tdrm_printf(p, \"\\trotation=%x\\n\", state->rotation);\n\tdrm_printf(p, \"\\tnormalized-zpos=%x\\n\", state->normalized_zpos);\n\tdrm_printf(p, \"\\tcolor-encoding=%s\\n\",\n\t\t   drm_get_color_encoding_name(state->color_encoding));\n\tdrm_printf(p, \"\\tcolor-range=%s\\n\",\n\t\t   drm_get_color_range_name(state->color_range));\n\n\tif (plane->funcs->atomic_print_state)\n\t\tplane->funcs->atomic_print_state(p, state);\n}\n\n/**\n * DOC: handling driver private state\n *\n * Very often the DRM objects exposed to userspace in the atomic modeset api\n * (&drm_connector, &drm_crtc and &drm_plane) do not map neatly to the\n * underlying hardware. Especially for any kind of shared resources (e.g. shared\n * clocks, scaler units, bandwidth and fifo limits shared among a group of\n * planes or CRTCs, and so on) it makes sense to model these as independent\n * objects. Drivers then need to do similar state tracking and commit ordering for\n * such private (since not exposed to userspace) objects as the atomic core and\n * helpers already provide for connectors, planes and CRTCs.\n *\n * To make this easier on drivers the atomic core provides some support to track\n * driver private state objects using struct &drm_private_obj, with the\n * associated state struct &drm_private_state.\n *\n * Similar to userspace-exposed objects, private state structures can be\n * acquired by calling drm_atomic_get_private_obj_state(). This also takes care\n * of locking, hence drivers should not have a need to call drm_modeset_lock()\n * directly. Sequence of the actual hardware state commit is not handled,\n * drivers might need to keep track of struct drm_crtc_commit within subclassed\n * structure of &drm_private_state as necessary, e.g. similar to\n * &drm_plane_state.commit. See also &drm_atomic_state.fake_commit.\n *\n * All private state structures contained in a &drm_atomic_state update can be\n * iterated using for_each_oldnew_private_obj_in_state(),\n * for_each_new_private_obj_in_state() and for_each_old_private_obj_in_state().\n * Drivers are recommended to wrap these for each type of driver private state\n * object they have, filtering on &drm_private_obj.funcs using for_each_if(), at\n * least if they want to iterate over all objects of a given type.\n *\n * An earlier way to handle driver private state was by subclassing struct\n * &drm_atomic_state. But since that encourages non-standard ways to implement\n * the check/commit split atomic requires (by using e.g. \"check and rollback or\n * commit instead\" of \"duplicate state, check, then either commit or release\n * duplicated state) it is deprecated in favour of using &drm_private_state.\n */\n\n/**\n * drm_atomic_private_obj_init - initialize private object\n * @dev: DRM device this object will be attached to\n * @obj: private object\n * @state: initial private object state\n * @funcs: pointer to the struct of function pointers that identify the object\n * type\n *\n * Initialize the private object, which can be embedded into any\n * driver private object that needs its own atomic state.\n */\nvoid\ndrm_atomic_private_obj_init(struct drm_device *dev,\n\t\t\t    struct drm_private_obj *obj,\n\t\t\t    struct drm_private_state *state,\n\t\t\t    const struct drm_private_state_funcs *funcs)\n{\n\tmemset(obj, 0, sizeof(*obj));\n\n\tdrm_modeset_lock_init(&obj->lock);\n\n\tobj->state = state;\n\tobj->funcs = funcs;\n\tlist_add_tail(&obj->head, &dev->mode_config.privobj_list);\n\n\tstate->obj = obj;\n}\nEXPORT_SYMBOL(drm_atomic_private_obj_init);\n\n/**\n * drm_atomic_private_obj_fini - finalize private object\n * @obj: private object\n *\n * Finalize the private object.\n */\nvoid\ndrm_atomic_private_obj_fini(struct drm_private_obj *obj)\n{\n\tlist_del(&obj->head);\n\tobj->funcs->atomic_destroy_state(obj, obj->state);\n\tdrm_modeset_lock_fini(&obj->lock);\n}\nEXPORT_SYMBOL(drm_atomic_private_obj_fini);\n\n/**\n * drm_atomic_get_private_obj_state - get private object state\n * @state: global atomic state\n * @obj: private object to get the state for\n *\n * This function returns the private object state for the given private object,\n * allocating the state if needed. It will also grab the relevant private\n * object lock to make sure that the state is consistent.\n *\n * RETURNS:\n *\n * Either the allocated state or the error code encoded into a pointer.\n */\nstruct drm_private_state *\ndrm_atomic_get_private_obj_state(struct drm_atomic_state *state,\n\t\t\t\t struct drm_private_obj *obj)\n{\n\tint index, num_objs, i, ret;\n\tsize_t size;\n\tstruct __drm_private_objs_state *arr;\n\tstruct drm_private_state *obj_state;\n\n\tfor (i = 0; i < state->num_private_objs; i++)\n\t\tif (obj == state->private_objs[i].ptr)\n\t\t\treturn state->private_objs[i].state;\n\n\tret = drm_modeset_lock(&obj->lock, state->acquire_ctx);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tnum_objs = state->num_private_objs + 1;\n\tsize = sizeof(*state->private_objs) * num_objs;\n\tarr = krealloc(state->private_objs, size, GFP_KERNEL);\n\tif (!arr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstate->private_objs = arr;\n\tindex = state->num_private_objs;\n\tmemset(&state->private_objs[index], 0, sizeof(*state->private_objs));\n\n\tobj_state = obj->funcs->atomic_duplicate_state(obj);\n\tif (!obj_state)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstate->private_objs[index].state = obj_state;\n\tstate->private_objs[index].old_state = obj->state;\n\tstate->private_objs[index].new_state = obj_state;\n\tstate->private_objs[index].ptr = obj;\n\tobj_state->state = state;\n\n\tstate->num_private_objs = num_objs;\n\n\tdrm_dbg_atomic(state->dev,\n\t\t       \"Added new private object %p state %p to %p\\n\",\n\t\t       obj, obj_state, state);\n\n\treturn obj_state;\n}\nEXPORT_SYMBOL(drm_atomic_get_private_obj_state);\n\n/**\n * drm_atomic_get_old_private_obj_state\n * @state: global atomic state object\n * @obj: private_obj to grab\n *\n * This function returns the old private object state for the given private_obj,\n * or NULL if the private_obj is not part of the global atomic state.\n */\nstruct drm_private_state *\ndrm_atomic_get_old_private_obj_state(const struct drm_atomic_state *state,\n\t\t\t\t     struct drm_private_obj *obj)\n{\n\tint i;\n\n\tfor (i = 0; i < state->num_private_objs; i++)\n\t\tif (obj == state->private_objs[i].ptr)\n\t\t\treturn state->private_objs[i].old_state;\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(drm_atomic_get_old_private_obj_state);\n\n/**\n * drm_atomic_get_new_private_obj_state\n * @state: global atomic state object\n * @obj: private_obj to grab\n *\n * This function returns the new private object state for the given private_obj,\n * or NULL if the private_obj is not part of the global atomic state.\n */\nstruct drm_private_state *\ndrm_atomic_get_new_private_obj_state(const struct drm_atomic_state *state,\n\t\t\t\t     struct drm_private_obj *obj)\n{\n\tint i;\n\n\tfor (i = 0; i < state->num_private_objs; i++)\n\t\tif (obj == state->private_objs[i].ptr)\n\t\t\treturn state->private_objs[i].new_state;\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(drm_atomic_get_new_private_obj_state);\n\n/**\n * drm_atomic_get_old_connector_for_encoder - Get old connector for an encoder\n * @state: Atomic state\n * @encoder: The encoder to fetch the connector state for\n *\n * This function finds and returns the connector that was connected to @encoder\n * as specified by the @state.\n *\n * If there is no connector in @state which previously had @encoder connected to\n * it, this function will return NULL. While this may seem like an invalid use\n * case, it is sometimes useful to differentiate commits which had no prior\n * connectors attached to @encoder vs ones that did (and to inspect their\n * state). This is especially true in enable hooks because the pipeline has\n * changed.\n *\n * Returns: The old connector connected to @encoder, or NULL if the encoder is\n * not connected.\n */\nstruct drm_connector *\ndrm_atomic_get_old_connector_for_encoder(const struct drm_atomic_state *state,\n\t\t\t\t\t struct drm_encoder *encoder)\n{\n\tstruct drm_connector_state *conn_state;\n\tstruct drm_connector *connector;\n\tunsigned int i;\n\n\tfor_each_old_connector_in_state(state, connector, conn_state, i) {\n\t\tif (conn_state->best_encoder == encoder)\n\t\t\treturn connector;\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(drm_atomic_get_old_connector_for_encoder);\n\n/**\n * drm_atomic_get_new_connector_for_encoder - Get new connector for an encoder\n * @state: Atomic state\n * @encoder: The encoder to fetch the connector state for\n *\n * This function finds and returns the connector that will be connected to\n * @encoder as specified by the @state.\n *\n * If there is no connector in @state which will have @encoder connected to it,\n * this function will return NULL. While this may seem like an invalid use case,\n * it is sometimes useful to differentiate commits which have no connectors\n * attached to @encoder vs ones that do (and to inspect their state). This is\n * especially true in disable hooks because the pipeline will change.\n *\n * Returns: The new connector connected to @encoder, or NULL if the encoder is\n * not connected.\n */\nstruct drm_connector *\ndrm_atomic_get_new_connector_for_encoder(const struct drm_atomic_state *state,\n\t\t\t\t\t struct drm_encoder *encoder)\n{\n\tstruct drm_connector_state *conn_state;\n\tstruct drm_connector *connector;\n\tunsigned int i;\n\n\tfor_each_new_connector_in_state(state, connector, conn_state, i) {\n\t\tif (conn_state->best_encoder == encoder)\n\t\t\treturn connector;\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(drm_atomic_get_new_connector_for_encoder);\n\n/**\n * drm_atomic_get_old_crtc_for_encoder - Get old crtc for an encoder\n * @state: Atomic state\n * @encoder: The encoder to fetch the crtc state for\n *\n * This function finds and returns the crtc that was connected to @encoder\n * as specified by the @state.\n *\n * Returns: The old crtc connected to @encoder, or NULL if the encoder is\n * not connected.\n */\nstruct drm_crtc *\ndrm_atomic_get_old_crtc_for_encoder(struct drm_atomic_state *state,\n\t\t\t\t    struct drm_encoder *encoder)\n{\n\tstruct drm_connector *connector;\n\tstruct drm_connector_state *conn_state;\n\n\tconnector = drm_atomic_get_old_connector_for_encoder(state, encoder);\n\tif (!connector)\n\t\treturn NULL;\n\n\tconn_state = drm_atomic_get_old_connector_state(state, connector);\n\tif (!conn_state)\n\t\treturn NULL;\n\n\treturn conn_state->crtc;\n}\nEXPORT_SYMBOL(drm_atomic_get_old_crtc_for_encoder);\n\n/**\n * drm_atomic_get_new_crtc_for_encoder - Get new crtc for an encoder\n * @state: Atomic state\n * @encoder: The encoder to fetch the crtc state for\n *\n * This function finds and returns the crtc that will be connected to @encoder\n * as specified by the @state.\n *\n * Returns: The new crtc connected to @encoder, or NULL if the encoder is\n * not connected.\n */\nstruct drm_crtc *\ndrm_atomic_get_new_crtc_for_encoder(struct drm_atomic_state *state,\n\t\t\t\t    struct drm_encoder *encoder)\n{\n\tstruct drm_connector *connector;\n\tstruct drm_connector_state *conn_state;\n\n\tconnector = drm_atomic_get_new_connector_for_encoder(state, encoder);\n\tif (!connector)\n\t\treturn NULL;\n\n\tconn_state = drm_atomic_get_new_connector_state(state, connector);\n\tif (!conn_state)\n\t\treturn NULL;\n\n\treturn conn_state->crtc;\n}\nEXPORT_SYMBOL(drm_atomic_get_new_crtc_for_encoder);\n\n/**\n * drm_atomic_get_connector_state - get connector state\n * @state: global atomic state object\n * @connector: connector to get state object for\n *\n * This function returns the connector state for the given connector,\n * allocating it if needed. It will also grab the relevant connector lock to\n * make sure that the state is consistent.\n *\n * Returns:\n *\n * Either the allocated state or the error code encoded into the pointer. When\n * the error is EDEADLK then the w/w mutex code has detected a deadlock and the\n * entire atomic sequence must be restarted. All other errors are fatal.\n */\nstruct drm_connector_state *\ndrm_atomic_get_connector_state(struct drm_atomic_state *state,\n\t\t\t  struct drm_connector *connector)\n{\n\tint ret, index;\n\tstruct drm_mode_config *config = &connector->dev->mode_config;\n\tstruct drm_connector_state *connector_state;\n\n\tWARN_ON(!state->acquire_ctx);\n\n\tret = drm_modeset_lock(&config->connection_mutex, state->acquire_ctx);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tindex = drm_connector_index(connector);\n\n\tif (index >= state->num_connector) {\n\t\tstruct __drm_connnectors_state *c;\n\t\tint alloc = max(index + 1, config->num_connector);\n\n\t\tc = krealloc_array(state->connectors, alloc,\n\t\t\t\t   sizeof(*state->connectors), GFP_KERNEL);\n\t\tif (!c)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\tstate->connectors = c;\n\t\tmemset(&state->connectors[state->num_connector], 0,\n\t\t       sizeof(*state->connectors) * (alloc - state->num_connector));\n\n\t\tstate->num_connector = alloc;\n\t}\n\n\tif (state->connectors[index].state)\n\t\treturn state->connectors[index].state;\n\n\tconnector_state = connector->funcs->atomic_duplicate_state(connector);\n\tif (!connector_state)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdrm_connector_get(connector);\n\tstate->connectors[index].state = connector_state;\n\tstate->connectors[index].old_state = connector->state;\n\tstate->connectors[index].new_state = connector_state;\n\tstate->connectors[index].ptr = connector;\n\tconnector_state->state = state;\n\n\tdrm_dbg_atomic(connector->dev, \"Added [CONNECTOR:%d:%s] %p state to %p\\n\",\n\t\t\t connector->base.id, connector->name,\n\t\t\t connector_state, state);\n\n\tif (connector_state->crtc) {\n\t\tstruct drm_crtc_state *crtc_state;\n\n\t\tcrtc_state = drm_atomic_get_crtc_state(state,\n\t\t\t\t\t\t       connector_state->crtc);\n\t\tif (IS_ERR(crtc_state))\n\t\t\treturn ERR_CAST(crtc_state);\n\t}\n\n\treturn connector_state;\n}\nEXPORT_SYMBOL(drm_atomic_get_connector_state);\n\nstatic void drm_atomic_connector_print_state(struct drm_printer *p,\n\t\tconst struct drm_connector_state *state)\n{\n\tstruct drm_connector *connector = state->connector;\n\n\tdrm_printf(p, \"connector[%u]: %s\\n\", connector->base.id, connector->name);\n\tdrm_printf(p, \"\\tcrtc=%s\\n\", state->crtc ? state->crtc->name : \"(null)\");\n\tdrm_printf(p, \"\\tself_refresh_aware=%d\\n\", state->self_refresh_aware);\n\tdrm_printf(p, \"\\tmax_requested_bpc=%d\\n\", state->max_requested_bpc);\n\tdrm_printf(p, \"\\tcolorspace=%s\\n\", drm_get_colorspace_name(state->colorspace));\n\n\tif (connector->connector_type == DRM_MODE_CONNECTOR_WRITEBACK)\n\t\tif (state->writeback_job && state->writeback_job->fb)\n\t\t\tdrm_printf(p, \"\\tfb=%d\\n\", state->writeback_job->fb->base.id);\n\n\tif (connector->funcs->atomic_print_state)\n\t\tconnector->funcs->atomic_print_state(p, state);\n}\n\n/**\n * drm_atomic_get_bridge_state - get bridge state\n * @state: global atomic state object\n * @bridge: bridge to get state object for\n *\n * This function returns the bridge state for the given bridge, allocating it\n * if needed. It will also grab the relevant bridge lock to make sure that the\n * state is consistent.\n *\n * Returns:\n *\n * Either the allocated state or the error code encoded into the pointer. When\n * the error is EDEADLK then the w/w mutex code has detected a deadlock and the\n * entire atomic sequence must be restarted.\n */\nstruct drm_bridge_state *\ndrm_atomic_get_bridge_state(struct drm_atomic_state *state,\n\t\t\t    struct drm_bridge *bridge)\n{\n\tstruct drm_private_state *obj_state;\n\n\tobj_state = drm_atomic_get_private_obj_state(state, &bridge->base);\n\tif (IS_ERR(obj_state))\n\t\treturn ERR_CAST(obj_state);\n\n\treturn drm_priv_to_bridge_state(obj_state);\n}\nEXPORT_SYMBOL(drm_atomic_get_bridge_state);\n\n/**\n * drm_atomic_get_old_bridge_state - get old bridge state, if it exists\n * @state: global atomic state object\n * @bridge: bridge to grab\n *\n * This function returns the old bridge state for the given bridge, or NULL if\n * the bridge is not part of the global atomic state.\n */\nstruct drm_bridge_state *\ndrm_atomic_get_old_bridge_state(const struct drm_atomic_state *state,\n\t\t\t\tstruct drm_bridge *bridge)\n{\n\tstruct drm_private_state *obj_state;\n\n\tobj_state = drm_atomic_get_old_private_obj_state(state, &bridge->base);\n\tif (!obj_state)\n\t\treturn NULL;\n\n\treturn drm_priv_to_bridge_state(obj_state);\n}\nEXPORT_SYMBOL(drm_atomic_get_old_bridge_state);\n\n/**\n * drm_atomic_get_new_bridge_state - get new bridge state, if it exists\n * @state: global atomic state object\n * @bridge: bridge to grab\n *\n * This function returns the new bridge state for the given bridge, or NULL if\n * the bridge is not part of the global atomic state.\n */\nstruct drm_bridge_state *\ndrm_atomic_get_new_bridge_state(const struct drm_atomic_state *state,\n\t\t\t\tstruct drm_bridge *bridge)\n{\n\tstruct drm_private_state *obj_state;\n\n\tobj_state = drm_atomic_get_new_private_obj_state(state, &bridge->base);\n\tif (!obj_state)\n\t\treturn NULL;\n\n\treturn drm_priv_to_bridge_state(obj_state);\n}\nEXPORT_SYMBOL(drm_atomic_get_new_bridge_state);\n\n/**\n * drm_atomic_add_encoder_bridges - add bridges attached to an encoder\n * @state: atomic state\n * @encoder: DRM encoder\n *\n * This function adds all bridges attached to @encoder. This is needed to add\n * bridge states to @state and make them available when\n * &drm_bridge_funcs.atomic_check(), &drm_bridge_funcs.atomic_pre_enable(),\n * &drm_bridge_funcs.atomic_enable(),\n * &drm_bridge_funcs.atomic_disable_post_disable() are called.\n *\n * Returns:\n * 0 on success or can fail with -EDEADLK or -ENOMEM. When the error is EDEADLK\n * then the w/w mutex code has detected a deadlock and the entire atomic\n * sequence must be restarted. All other errors are fatal.\n */\nint\ndrm_atomic_add_encoder_bridges(struct drm_atomic_state *state,\n\t\t\t       struct drm_encoder *encoder)\n{\n\tstruct drm_bridge_state *bridge_state;\n\tstruct drm_bridge *bridge;\n\n\tif (!encoder)\n\t\treturn 0;\n\n\tdrm_dbg_atomic(encoder->dev,\n\t\t       \"Adding all bridges for [encoder:%d:%s] to %p\\n\",\n\t\t       encoder->base.id, encoder->name, state);\n\n\tdrm_for_each_bridge_in_chain(encoder, bridge) {\n\t\t/* Skip bridges that don't implement the atomic state hooks. */\n\t\tif (!bridge->funcs->atomic_duplicate_state)\n\t\t\tcontinue;\n\n\t\tbridge_state = drm_atomic_get_bridge_state(state, bridge);\n\t\tif (IS_ERR(bridge_state))\n\t\t\treturn PTR_ERR(bridge_state);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_atomic_add_encoder_bridges);\n\n/**\n * drm_atomic_add_affected_connectors - add connectors for CRTC\n * @state: atomic state\n * @crtc: DRM CRTC\n *\n * This function walks the current configuration and adds all connectors\n * currently using @crtc to the atomic configuration @state. Note that this\n * function must acquire the connection mutex. This can potentially cause\n * unneeded serialization if the update is just for the planes on one CRTC. Hence\n * drivers and helpers should only call this when really needed (e.g. when a\n * full modeset needs to happen due to some change).\n *\n * Returns:\n * 0 on success or can fail with -EDEADLK or -ENOMEM. When the error is EDEADLK\n * then the w/w mutex code has detected a deadlock and the entire atomic\n * sequence must be restarted. All other errors are fatal.\n */\nint\ndrm_atomic_add_affected_connectors(struct drm_atomic_state *state,\n\t\t\t\t   struct drm_crtc *crtc)\n{\n\tstruct drm_mode_config *config = &state->dev->mode_config;\n\tstruct drm_connector *connector;\n\tstruct drm_connector_state *conn_state;\n\tstruct drm_connector_list_iter conn_iter;\n\tstruct drm_crtc_state *crtc_state;\n\tint ret;\n\n\tcrtc_state = drm_atomic_get_crtc_state(state, crtc);\n\tif (IS_ERR(crtc_state))\n\t\treturn PTR_ERR(crtc_state);\n\n\tret = drm_modeset_lock(&config->connection_mutex, state->acquire_ctx);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_dbg_atomic(crtc->dev,\n\t\t       \"Adding all current connectors for [CRTC:%d:%s] to %p\\n\",\n\t\t       crtc->base.id, crtc->name, state);\n\n\t/*\n\t * Changed connectors are already in @state, so only need to look\n\t * at the connector_mask in crtc_state.\n\t */\n\tdrm_connector_list_iter_begin(state->dev, &conn_iter);\n\tdrm_for_each_connector_iter(connector, &conn_iter) {\n\t\tif (!(crtc_state->connector_mask & drm_connector_mask(connector)))\n\t\t\tcontinue;\n\n\t\tconn_state = drm_atomic_get_connector_state(state, connector);\n\t\tif (IS_ERR(conn_state)) {\n\t\t\tdrm_connector_list_iter_end(&conn_iter);\n\t\t\treturn PTR_ERR(conn_state);\n\t\t}\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_atomic_add_affected_connectors);\n\n/**\n * drm_atomic_add_affected_planes - add planes for CRTC\n * @state: atomic state\n * @crtc: DRM CRTC\n *\n * This function walks the current configuration and adds all planes\n * currently used by @crtc to the atomic configuration @state. This is useful\n * when an atomic commit also needs to check all currently enabled plane on\n * @crtc, e.g. when changing the mode. It's also useful when re-enabling a CRTC\n * to avoid special code to force-enable all planes.\n *\n * Since acquiring a plane state will always also acquire the w/w mutex of the\n * current CRTC for that plane (if there is any) adding all the plane states for\n * a CRTC will not reduce parallelism of atomic updates.\n *\n * Returns:\n * 0 on success or can fail with -EDEADLK or -ENOMEM. When the error is EDEADLK\n * then the w/w mutex code has detected a deadlock and the entire atomic\n * sequence must be restarted. All other errors are fatal.\n */\nint\ndrm_atomic_add_affected_planes(struct drm_atomic_state *state,\n\t\t\t       struct drm_crtc *crtc)\n{\n\tconst struct drm_crtc_state *old_crtc_state =\n\t\tdrm_atomic_get_old_crtc_state(state, crtc);\n\tstruct drm_plane *plane;\n\n\tWARN_ON(!drm_atomic_get_new_crtc_state(state, crtc));\n\n\tdrm_dbg_atomic(crtc->dev,\n\t\t       \"Adding all current planes for [CRTC:%d:%s] to %p\\n\",\n\t\t       crtc->base.id, crtc->name, state);\n\n\tdrm_for_each_plane_mask(plane, state->dev, old_crtc_state->plane_mask) {\n\t\tstruct drm_plane_state *plane_state =\n\t\t\tdrm_atomic_get_plane_state(state, plane);\n\n\t\tif (IS_ERR(plane_state))\n\t\t\treturn PTR_ERR(plane_state);\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_atomic_add_affected_planes);\n\n/**\n * drm_atomic_check_only - check whether a given config would work\n * @state: atomic configuration to check\n *\n * Note that this function can return -EDEADLK if the driver needed to acquire\n * more locks but encountered a deadlock. The caller must then do the usual w/w\n * backoff dance and restart. All other errors are fatal.\n *\n * Returns:\n * 0 on success, negative error code on failure.\n */\nint drm_atomic_check_only(struct drm_atomic_state *state)\n{\n\tstruct drm_device *dev = state->dev;\n\tstruct drm_mode_config *config = &dev->mode_config;\n\tstruct drm_plane *plane;\n\tstruct drm_plane_state *old_plane_state;\n\tstruct drm_plane_state *new_plane_state;\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *old_crtc_state;\n\tstruct drm_crtc_state *new_crtc_state;\n\tstruct drm_connector *conn;\n\tstruct drm_connector_state *conn_state;\n\tunsigned int requested_crtc = 0;\n\tunsigned int affected_crtc = 0;\n\tint i, ret = 0;\n\n\tdrm_dbg_atomic(dev, \"checking %p\\n\", state);\n\n\tfor_each_new_crtc_in_state(state, crtc, new_crtc_state, i) {\n\t\tif (new_crtc_state->enable)\n\t\t\trequested_crtc |= drm_crtc_mask(crtc);\n\t}\n\n\tfor_each_oldnew_plane_in_state(state, plane, old_plane_state, new_plane_state, i) {\n\t\tret = drm_atomic_plane_check(old_plane_state, new_plane_state);\n\t\tif (ret) {\n\t\t\tdrm_dbg_atomic(dev, \"[PLANE:%d:%s] atomic core check failed\\n\",\n\t\t\t\t       plane->base.id, plane->name);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tfor_each_oldnew_crtc_in_state(state, crtc, old_crtc_state, new_crtc_state, i) {\n\t\tret = drm_atomic_crtc_check(old_crtc_state, new_crtc_state);\n\t\tif (ret) {\n\t\t\tdrm_dbg_atomic(dev, \"[CRTC:%d:%s] atomic core check failed\\n\",\n\t\t\t\t       crtc->base.id, crtc->name);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tfor_each_new_connector_in_state(state, conn, conn_state, i) {\n\t\tret = drm_atomic_connector_check(conn, conn_state);\n\t\tif (ret) {\n\t\t\tdrm_dbg_atomic(dev, \"[CONNECTOR:%d:%s] atomic core check failed\\n\",\n\t\t\t\t       conn->base.id, conn->name);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (config->funcs->atomic_check) {\n\t\tret = config->funcs->atomic_check(state->dev, state);\n\n\t\tif (ret) {\n\t\t\tdrm_dbg_atomic(dev, \"atomic driver check for %p failed: %d\\n\",\n\t\t\t\t       state, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (!state->allow_modeset) {\n\t\tfor_each_new_crtc_in_state(state, crtc, new_crtc_state, i) {\n\t\t\tif (drm_atomic_crtc_needs_modeset(new_crtc_state)) {\n\t\t\t\tdrm_dbg_atomic(dev, \"[CRTC:%d:%s] requires full modeset\\n\",\n\t\t\t\t\t       crtc->base.id, crtc->name);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor_each_new_crtc_in_state(state, crtc, new_crtc_state, i) {\n\t\tif (new_crtc_state->enable)\n\t\t\taffected_crtc |= drm_crtc_mask(crtc);\n\t}\n\n\t/*\n\t * For commits that allow modesets drivers can add other CRTCs to the\n\t * atomic commit, e.g. when they need to reallocate global resources.\n\t * This can cause spurious EBUSY, which robs compositors of a very\n\t * effective sanity check for their drawing loop. Therefor only allow\n\t * drivers to add unrelated CRTC states for modeset commits.\n\t *\n\t * FIXME: Should add affected_crtc mask to the ATOMIC IOCTL as an output\n\t * so compositors know what's going on.\n\t */\n\tif (affected_crtc != requested_crtc) {\n\t\tdrm_dbg_atomic(dev,\n\t\t\t       \"driver added CRTC to commit: requested 0x%x, affected 0x%0x\\n\",\n\t\t\t       requested_crtc, affected_crtc);\n\t\tWARN(!state->allow_modeset, \"adding CRTC not allowed without modesets: requested 0x%x, affected 0x%0x\\n\",\n\t\t     requested_crtc, affected_crtc);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_atomic_check_only);\n\n/**\n * drm_atomic_commit - commit configuration atomically\n * @state: atomic configuration to check\n *\n * Note that this function can return -EDEADLK if the driver needed to acquire\n * more locks but encountered a deadlock. The caller must then do the usual w/w\n * backoff dance and restart. All other errors are fatal.\n *\n * This function will take its own reference on @state.\n * Callers should always release their reference with drm_atomic_state_put().\n *\n * Returns:\n * 0 on success, negative error code on failure.\n */\nint drm_atomic_commit(struct drm_atomic_state *state)\n{\n\tstruct drm_mode_config *config = &state->dev->mode_config;\n\tstruct drm_printer p = drm_info_printer(state->dev->dev);\n\tint ret;\n\n\tif (drm_debug_enabled(DRM_UT_STATE))\n\t\tdrm_atomic_print_new_state(state, &p);\n\n\tret = drm_atomic_check_only(state);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_dbg_atomic(state->dev, \"committing %p\\n\", state);\n\n\treturn config->funcs->atomic_commit(state->dev, state, false);\n}\nEXPORT_SYMBOL(drm_atomic_commit);\n\n/**\n * drm_atomic_nonblocking_commit - atomic nonblocking commit\n * @state: atomic configuration to check\n *\n * Note that this function can return -EDEADLK if the driver needed to acquire\n * more locks but encountered a deadlock. The caller must then do the usual w/w\n * backoff dance and restart. All other errors are fatal.\n *\n * This function will take its own reference on @state.\n * Callers should always release their reference with drm_atomic_state_put().\n *\n * Returns:\n * 0 on success, negative error code on failure.\n */\nint drm_atomic_nonblocking_commit(struct drm_atomic_state *state)\n{\n\tstruct drm_mode_config *config = &state->dev->mode_config;\n\tint ret;\n\n\tret = drm_atomic_check_only(state);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_dbg_atomic(state->dev, \"committing %p nonblocking\\n\", state);\n\n\treturn config->funcs->atomic_commit(state->dev, state, true);\n}\nEXPORT_SYMBOL(drm_atomic_nonblocking_commit);\n\n/* just used from drm-client and atomic-helper: */\nint __drm_atomic_helper_disable_plane(struct drm_plane *plane,\n\t\t\t\t      struct drm_plane_state *plane_state)\n{\n\tint ret;\n\n\tret = drm_atomic_set_crtc_for_plane(plane_state, NULL);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tdrm_atomic_set_fb_for_plane(plane_state, NULL);\n\tplane_state->crtc_x = 0;\n\tplane_state->crtc_y = 0;\n\tplane_state->crtc_w = 0;\n\tplane_state->crtc_h = 0;\n\tplane_state->src_x = 0;\n\tplane_state->src_y = 0;\n\tplane_state->src_w = 0;\n\tplane_state->src_h = 0;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(__drm_atomic_helper_disable_plane);\n\nstatic int update_output_state(struct drm_atomic_state *state,\n\t\t\t       struct drm_mode_set *set)\n{\n\tstruct drm_device *dev = set->crtc->dev;\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *new_crtc_state;\n\tstruct drm_connector *connector;\n\tstruct drm_connector_state *new_conn_state;\n\tint ret, i;\n\n\tret = drm_modeset_lock(&dev->mode_config.connection_mutex,\n\t\t\t       state->acquire_ctx);\n\tif (ret)\n\t\treturn ret;\n\n\t/* First disable all connectors on the target crtc. */\n\tret = drm_atomic_add_affected_connectors(state, set->crtc);\n\tif (ret)\n\t\treturn ret;\n\n\tfor_each_new_connector_in_state(state, connector, new_conn_state, i) {\n\t\tif (new_conn_state->crtc == set->crtc) {\n\t\t\tret = drm_atomic_set_crtc_for_connector(new_conn_state,\n\t\t\t\t\t\t\t\tNULL);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\t/* Make sure legacy setCrtc always re-trains */\n\t\t\tnew_conn_state->link_status = DRM_LINK_STATUS_GOOD;\n\t\t}\n\t}\n\n\t/* Then set all connectors from set->connectors on the target crtc */\n\tfor (i = 0; i < set->num_connectors; i++) {\n\t\tnew_conn_state = drm_atomic_get_connector_state(state,\n\t\t\t\t\t\t\t\tset->connectors[i]);\n\t\tif (IS_ERR(new_conn_state))\n\t\t\treturn PTR_ERR(new_conn_state);\n\n\t\tret = drm_atomic_set_crtc_for_connector(new_conn_state,\n\t\t\t\t\t\t\tset->crtc);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfor_each_new_crtc_in_state(state, crtc, new_crtc_state, i) {\n\t\t/*\n\t\t * Don't update ->enable for the CRTC in the set_config request,\n\t\t * since a mismatch would indicate a bug in the upper layers.\n\t\t * The actual modeset code later on will catch any\n\t\t * inconsistencies here.\n\t\t */\n\t\tif (crtc == set->crtc)\n\t\t\tcontinue;\n\n\t\tif (!new_crtc_state->connector_mask) {\n\t\t\tret = drm_atomic_set_mode_prop_for_crtc(new_crtc_state,\n\t\t\t\t\t\t\t\tNULL);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tnew_crtc_state->active = false;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/* just used from drm-client and atomic-helper: */\nint __drm_atomic_helper_set_config(struct drm_mode_set *set,\n\t\t\t\t   struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *crtc_state;\n\tstruct drm_plane_state *primary_state;\n\tstruct drm_crtc *crtc = set->crtc;\n\tint hdisplay, vdisplay;\n\tint ret;\n\n\tcrtc_state = drm_atomic_get_crtc_state(state, crtc);\n\tif (IS_ERR(crtc_state))\n\t\treturn PTR_ERR(crtc_state);\n\n\tprimary_state = drm_atomic_get_plane_state(state, crtc->primary);\n\tif (IS_ERR(primary_state))\n\t\treturn PTR_ERR(primary_state);\n\n\tif (!set->mode) {\n\t\tWARN_ON(set->fb);\n\t\tWARN_ON(set->num_connectors);\n\n\t\tret = drm_atomic_set_mode_for_crtc(crtc_state, NULL);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\n\t\tcrtc_state->active = false;\n\n\t\tret = drm_atomic_set_crtc_for_plane(primary_state, NULL);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\n\t\tdrm_atomic_set_fb_for_plane(primary_state, NULL);\n\n\t\tgoto commit;\n\t}\n\n\tWARN_ON(!set->fb);\n\tWARN_ON(!set->num_connectors);\n\n\tret = drm_atomic_set_mode_for_crtc(crtc_state, set->mode);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tcrtc_state->active = true;\n\n\tret = drm_atomic_set_crtc_for_plane(primary_state, crtc);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tdrm_mode_get_hv_timing(set->mode, &hdisplay, &vdisplay);\n\n\tdrm_atomic_set_fb_for_plane(primary_state, set->fb);\n\tprimary_state->crtc_x = 0;\n\tprimary_state->crtc_y = 0;\n\tprimary_state->crtc_w = hdisplay;\n\tprimary_state->crtc_h = vdisplay;\n\tprimary_state->src_x = set->x << 16;\n\tprimary_state->src_y = set->y << 16;\n\tif (drm_rotation_90_or_270(primary_state->rotation)) {\n\t\tprimary_state->src_w = vdisplay << 16;\n\t\tprimary_state->src_h = hdisplay << 16;\n\t} else {\n\t\tprimary_state->src_w = hdisplay << 16;\n\t\tprimary_state->src_h = vdisplay << 16;\n\t}\n\ncommit:\n\tret = update_output_state(state, set);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(__drm_atomic_helper_set_config);\n\nstatic void drm_atomic_private_obj_print_state(struct drm_printer *p,\n\t\t\t\t\t       const struct drm_private_state *state)\n{\n\tstruct drm_private_obj *obj = state->obj;\n\n\tif (obj->funcs->atomic_print_state)\n\t\tobj->funcs->atomic_print_state(p, state);\n}\n\n/**\n * drm_atomic_print_new_state - prints drm atomic state\n * @state: atomic configuration to check\n * @p: drm printer\n *\n * This functions prints the drm atomic state snapshot using the drm printer\n * which is passed to it. This snapshot can be used for debugging purposes.\n *\n * Note that this function looks into the new state objects and hence its not\n * safe to be used after the call to drm_atomic_helper_commit_hw_done().\n */\nvoid drm_atomic_print_new_state(const struct drm_atomic_state *state,\n\t\tstruct drm_printer *p)\n{\n\tstruct drm_plane *plane;\n\tstruct drm_plane_state *plane_state;\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *crtc_state;\n\tstruct drm_connector *connector;\n\tstruct drm_connector_state *connector_state;\n\tstruct drm_private_obj *obj;\n\tstruct drm_private_state *obj_state;\n\tint i;\n\n\tif (!p) {\n\t\tdrm_err(state->dev, \"invalid drm printer\\n\");\n\t\treturn;\n\t}\n\n\tdrm_dbg_atomic(state->dev, \"checking %p\\n\", state);\n\n\tfor_each_new_plane_in_state(state, plane, plane_state, i)\n\t\tdrm_atomic_plane_print_state(p, plane_state);\n\n\tfor_each_new_crtc_in_state(state, crtc, crtc_state, i)\n\t\tdrm_atomic_crtc_print_state(p, crtc_state);\n\n\tfor_each_new_connector_in_state(state, connector, connector_state, i)\n\t\tdrm_atomic_connector_print_state(p, connector_state);\n\n\tfor_each_new_private_obj_in_state(state, obj, obj_state, i)\n\t\tdrm_atomic_private_obj_print_state(p, obj_state);\n}\nEXPORT_SYMBOL(drm_atomic_print_new_state);\n\nstatic void __drm_state_dump(struct drm_device *dev, struct drm_printer *p,\n\t\t\t     bool take_locks)\n{\n\tstruct drm_mode_config *config = &dev->mode_config;\n\tstruct drm_plane *plane;\n\tstruct drm_crtc *crtc;\n\tstruct drm_connector *connector;\n\tstruct drm_connector_list_iter conn_iter;\n\n\tif (!drm_drv_uses_atomic_modeset(dev))\n\t\treturn;\n\n\tlist_for_each_entry(plane, &config->plane_list, head) {\n\t\tif (take_locks)\n\t\t\tdrm_modeset_lock(&plane->mutex, NULL);\n\t\tdrm_atomic_plane_print_state(p, plane->state);\n\t\tif (take_locks)\n\t\t\tdrm_modeset_unlock(&plane->mutex);\n\t}\n\n\tlist_for_each_entry(crtc, &config->crtc_list, head) {\n\t\tif (take_locks)\n\t\t\tdrm_modeset_lock(&crtc->mutex, NULL);\n\t\tdrm_atomic_crtc_print_state(p, crtc->state);\n\t\tif (take_locks)\n\t\t\tdrm_modeset_unlock(&crtc->mutex);\n\t}\n\n\tdrm_connector_list_iter_begin(dev, &conn_iter);\n\tif (take_locks)\n\t\tdrm_modeset_lock(&dev->mode_config.connection_mutex, NULL);\n\tdrm_for_each_connector_iter(connector, &conn_iter)\n\t\tdrm_atomic_connector_print_state(p, connector->state);\n\tif (take_locks)\n\t\tdrm_modeset_unlock(&dev->mode_config.connection_mutex);\n\tdrm_connector_list_iter_end(&conn_iter);\n}\n\n/**\n * drm_state_dump - dump entire device atomic state\n * @dev: the drm device\n * @p: where to print the state to\n *\n * Just for debugging.  Drivers might want an option to dump state\n * to dmesg in case of error irq's.  (Hint, you probably want to\n * ratelimit this!)\n *\n * The caller must wrap this drm_modeset_lock_all_ctx() and\n * drm_modeset_drop_locks(). If this is called from error irq handler, it should\n * not be enabled by default - if you are debugging errors you might\n * not care that this is racey, but calling this without all modeset locks held\n * is inherently unsafe.\n */\nvoid drm_state_dump(struct drm_device *dev, struct drm_printer *p)\n{\n\t__drm_state_dump(dev, p, false);\n}\nEXPORT_SYMBOL(drm_state_dump);\n\n#ifdef CONFIG_DEBUG_FS\nstatic int drm_state_info(struct seq_file *m, void *data)\n{\n\tstruct drm_debugfs_entry *entry = m->private;\n\tstruct drm_device *dev = entry->dev;\n\tstruct drm_printer p = drm_seq_file_printer(m);\n\n\t__drm_state_dump(dev, &p, true);\n\n\treturn 0;\n}\n\n/* any use in debugfs files to dump individual planes/crtc/etc? */\nstatic const struct drm_debugfs_info drm_atomic_debugfs_list[] = {\n\t{\"state\", drm_state_info, 0},\n};\n\nvoid drm_atomic_debugfs_init(struct drm_minor *minor)\n{\n\tdrm_debugfs_add_files(minor->dev, drm_atomic_debugfs_list,\n\t\t\t      ARRAY_SIZE(drm_atomic_debugfs_list));\n}\n#endif\n"], "fixing_code": ["/*\n * Copyright (C) 2014 Red Hat\n * Copyright (C) 2014 Intel Corp.\n * Copyright (c) 2020-2021, The Linux Foundation. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR\n * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n *\n * Authors:\n * Rob Clark <robdclark@gmail.com>\n * Daniel Vetter <daniel.vetter@ffwll.ch>\n */\n\n\n#include <linux/sync_file.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_uapi.h>\n#include <drm/drm_blend.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_debugfs.h>\n#include <drm/drm_device.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_file.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_mode.h>\n#include <drm/drm_print.h>\n#include <drm/drm_writeback.h>\n\n#include \"drm_crtc_internal.h\"\n#include \"drm_internal.h\"\n\nvoid __drm_crtc_commit_free(struct kref *kref)\n{\n\tstruct drm_crtc_commit *commit =\n\t\tcontainer_of(kref, struct drm_crtc_commit, ref);\n\n\tkfree(commit);\n}\nEXPORT_SYMBOL(__drm_crtc_commit_free);\n\n/**\n * drm_crtc_commit_wait - Waits for a commit to complete\n * @commit: &drm_crtc_commit to wait for\n *\n * Waits for a given &drm_crtc_commit to be programmed into the\n * hardware and flipped to.\n *\n * Returns:\n *\n * 0 on success, a negative error code otherwise.\n */\nint drm_crtc_commit_wait(struct drm_crtc_commit *commit)\n{\n\tunsigned long timeout = 10 * HZ;\n\tint ret;\n\n\tif (!commit)\n\t\treturn 0;\n\n\tret = wait_for_completion_timeout(&commit->hw_done, timeout);\n\tif (!ret) {\n\t\tdrm_err(commit->crtc->dev, \"hw_done timed out\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t/*\n\t * Currently no support for overwriting flips, hence\n\t * stall for previous one to execute completely.\n\t */\n\tret = wait_for_completion_timeout(&commit->flip_done, timeout);\n\tif (!ret) {\n\t\tdrm_err(commit->crtc->dev, \"flip_done timed out\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_crtc_commit_wait);\n\n/**\n * drm_atomic_state_default_release -\n * release memory initialized by drm_atomic_state_init\n * @state: atomic state\n *\n * Free all the memory allocated by drm_atomic_state_init.\n * This should only be used by drivers which are still subclassing\n * &drm_atomic_state and haven't switched to &drm_private_state yet.\n */\nvoid drm_atomic_state_default_release(struct drm_atomic_state *state)\n{\n\tkfree(state->connectors);\n\tkfree(state->crtcs);\n\tkfree(state->planes);\n\tkfree(state->private_objs);\n}\nEXPORT_SYMBOL(drm_atomic_state_default_release);\n\n/**\n * drm_atomic_state_init - init new atomic state\n * @dev: DRM device\n * @state: atomic state\n *\n * Default implementation for filling in a new atomic state.\n * This should only be used by drivers which are still subclassing\n * &drm_atomic_state and haven't switched to &drm_private_state yet.\n */\nint\ndrm_atomic_state_init(struct drm_device *dev, struct drm_atomic_state *state)\n{\n\tkref_init(&state->ref);\n\n\t/* TODO legacy paths should maybe do a better job about\n\t * setting this appropriately?\n\t */\n\tstate->allow_modeset = true;\n\n\tstate->crtcs = kcalloc(dev->mode_config.num_crtc,\n\t\t\t       sizeof(*state->crtcs), GFP_KERNEL);\n\tif (!state->crtcs)\n\t\tgoto fail;\n\tstate->planes = kcalloc(dev->mode_config.num_total_plane,\n\t\t\t\tsizeof(*state->planes), GFP_KERNEL);\n\tif (!state->planes)\n\t\tgoto fail;\n\n\t/*\n\t * Because drm_atomic_state can be committed asynchronously we need our\n\t * own reference and cannot rely on the on implied by drm_file in the\n\t * ioctl call.\n\t */\n\tdrm_dev_get(dev);\n\tstate->dev = dev;\n\n\tdrm_dbg_atomic(dev, \"Allocated atomic state %p\\n\", state);\n\n\treturn 0;\nfail:\n\tdrm_atomic_state_default_release(state);\n\treturn -ENOMEM;\n}\nEXPORT_SYMBOL(drm_atomic_state_init);\n\n/**\n * drm_atomic_state_alloc - allocate atomic state\n * @dev: DRM device\n *\n * This allocates an empty atomic state to track updates.\n */\nstruct drm_atomic_state *\ndrm_atomic_state_alloc(struct drm_device *dev)\n{\n\tstruct drm_mode_config *config = &dev->mode_config;\n\n\tif (!config->funcs->atomic_state_alloc) {\n\t\tstruct drm_atomic_state *state;\n\n\t\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\t\tif (!state)\n\t\t\treturn NULL;\n\t\tif (drm_atomic_state_init(dev, state) < 0) {\n\t\t\tkfree(state);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn state;\n\t}\n\n\treturn config->funcs->atomic_state_alloc(dev);\n}\nEXPORT_SYMBOL(drm_atomic_state_alloc);\n\n/**\n * drm_atomic_state_default_clear - clear base atomic state\n * @state: atomic state\n *\n * Default implementation for clearing atomic state.\n * This should only be used by drivers which are still subclassing\n * &drm_atomic_state and haven't switched to &drm_private_state yet.\n */\nvoid drm_atomic_state_default_clear(struct drm_atomic_state *state)\n{\n\tstruct drm_device *dev = state->dev;\n\tstruct drm_mode_config *config = &dev->mode_config;\n\tint i;\n\n\tdrm_dbg_atomic(dev, \"Clearing atomic state %p\\n\", state);\n\n\tfor (i = 0; i < state->num_connector; i++) {\n\t\tstruct drm_connector *connector = state->connectors[i].ptr;\n\n\t\tif (!connector)\n\t\t\tcontinue;\n\n\t\tconnector->funcs->atomic_destroy_state(connector,\n\t\t\t\t\t\t       state->connectors[i].state);\n\t\tstate->connectors[i].ptr = NULL;\n\t\tstate->connectors[i].state = NULL;\n\t\tstate->connectors[i].old_state = NULL;\n\t\tstate->connectors[i].new_state = NULL;\n\t\tdrm_connector_put(connector);\n\t}\n\n\tfor (i = 0; i < config->num_crtc; i++) {\n\t\tstruct drm_crtc *crtc = state->crtcs[i].ptr;\n\n\t\tif (!crtc)\n\t\t\tcontinue;\n\n\t\tcrtc->funcs->atomic_destroy_state(crtc,\n\t\t\t\t\t\t  state->crtcs[i].state);\n\n\t\tstate->crtcs[i].ptr = NULL;\n\t\tstate->crtcs[i].state = NULL;\n\t\tstate->crtcs[i].old_state = NULL;\n\t\tstate->crtcs[i].new_state = NULL;\n\n\t\tif (state->crtcs[i].commit) {\n\t\t\tdrm_crtc_commit_put(state->crtcs[i].commit);\n\t\t\tstate->crtcs[i].commit = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < config->num_total_plane; i++) {\n\t\tstruct drm_plane *plane = state->planes[i].ptr;\n\n\t\tif (!plane)\n\t\t\tcontinue;\n\n\t\tplane->funcs->atomic_destroy_state(plane,\n\t\t\t\t\t\t   state->planes[i].state);\n\t\tstate->planes[i].ptr = NULL;\n\t\tstate->planes[i].state = NULL;\n\t\tstate->planes[i].old_state = NULL;\n\t\tstate->planes[i].new_state = NULL;\n\t}\n\n\tfor (i = 0; i < state->num_private_objs; i++) {\n\t\tstruct drm_private_obj *obj = state->private_objs[i].ptr;\n\n\t\tobj->funcs->atomic_destroy_state(obj,\n\t\t\t\t\t\t state->private_objs[i].state);\n\t\tstate->private_objs[i].ptr = NULL;\n\t\tstate->private_objs[i].state = NULL;\n\t\tstate->private_objs[i].old_state = NULL;\n\t\tstate->private_objs[i].new_state = NULL;\n\t}\n\tstate->num_private_objs = 0;\n\n\tif (state->fake_commit) {\n\t\tdrm_crtc_commit_put(state->fake_commit);\n\t\tstate->fake_commit = NULL;\n\t}\n}\nEXPORT_SYMBOL(drm_atomic_state_default_clear);\n\n/**\n * drm_atomic_state_clear - clear state object\n * @state: atomic state\n *\n * When the w/w mutex algorithm detects a deadlock we need to back off and drop\n * all locks. So someone else could sneak in and change the current modeset\n * configuration. Which means that all the state assembled in @state is no\n * longer an atomic update to the current state, but to some arbitrary earlier\n * state. Which could break assumptions the driver's\n * &drm_mode_config_funcs.atomic_check likely relies on.\n *\n * Hence we must clear all cached state and completely start over, using this\n * function.\n */\nvoid drm_atomic_state_clear(struct drm_atomic_state *state)\n{\n\tstruct drm_device *dev = state->dev;\n\tstruct drm_mode_config *config = &dev->mode_config;\n\n\tif (config->funcs->atomic_state_clear)\n\t\tconfig->funcs->atomic_state_clear(state);\n\telse\n\t\tdrm_atomic_state_default_clear(state);\n}\nEXPORT_SYMBOL(drm_atomic_state_clear);\n\n/**\n * __drm_atomic_state_free - free all memory for an atomic state\n * @ref: This atomic state to deallocate\n *\n * This frees all memory associated with an atomic state, including all the\n * per-object state for planes, CRTCs and connectors.\n */\nvoid __drm_atomic_state_free(struct kref *ref)\n{\n\tstruct drm_atomic_state *state = container_of(ref, typeof(*state), ref);\n\tstruct drm_device *dev = state->dev;\n\tstruct drm_mode_config *config = &dev->mode_config;\n\n\tdrm_atomic_state_clear(state);\n\n\tdrm_dbg_atomic(state->dev, \"Freeing atomic state %p\\n\", state);\n\n\tif (config->funcs->atomic_state_free) {\n\t\tconfig->funcs->atomic_state_free(state);\n\t} else {\n\t\tdrm_atomic_state_default_release(state);\n\t\tkfree(state);\n\t}\n\n\tdrm_dev_put(dev);\n}\nEXPORT_SYMBOL(__drm_atomic_state_free);\n\n/**\n * drm_atomic_get_crtc_state - get CRTC state\n * @state: global atomic state object\n * @crtc: CRTC to get state object for\n *\n * This function returns the CRTC state for the given CRTC, allocating it if\n * needed. It will also grab the relevant CRTC lock to make sure that the state\n * is consistent.\n *\n * WARNING: Drivers may only add new CRTC states to a @state if\n * drm_atomic_state.allow_modeset is set, or if it's a driver-internal commit\n * not created by userspace through an IOCTL call.\n *\n * Returns:\n *\n * Either the allocated state or the error code encoded into the pointer. When\n * the error is EDEADLK then the w/w mutex code has detected a deadlock and the\n * entire atomic sequence must be restarted. All other errors are fatal.\n */\nstruct drm_crtc_state *\ndrm_atomic_get_crtc_state(struct drm_atomic_state *state,\n\t\t\t  struct drm_crtc *crtc)\n{\n\tint ret, index = drm_crtc_index(crtc);\n\tstruct drm_crtc_state *crtc_state;\n\n\tWARN_ON(!state->acquire_ctx);\n\n\tcrtc_state = drm_atomic_get_existing_crtc_state(state, crtc);\n\tif (crtc_state)\n\t\treturn crtc_state;\n\n\tret = drm_modeset_lock(&crtc->mutex, state->acquire_ctx);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tcrtc_state = crtc->funcs->atomic_duplicate_state(crtc);\n\tif (!crtc_state)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstate->crtcs[index].state = crtc_state;\n\tstate->crtcs[index].old_state = crtc->state;\n\tstate->crtcs[index].new_state = crtc_state;\n\tstate->crtcs[index].ptr = crtc;\n\tcrtc_state->state = state;\n\n\tdrm_dbg_atomic(state->dev, \"Added [CRTC:%d:%s] %p state to %p\\n\",\n\t\t       crtc->base.id, crtc->name, crtc_state, state);\n\n\treturn crtc_state;\n}\nEXPORT_SYMBOL(drm_atomic_get_crtc_state);\n\nstatic int drm_atomic_crtc_check(const struct drm_crtc_state *old_crtc_state,\n\t\t\t\t const struct drm_crtc_state *new_crtc_state)\n{\n\tstruct drm_crtc *crtc = new_crtc_state->crtc;\n\n\t/* NOTE: we explicitly don't enforce constraints such as primary\n\t * layer covering entire screen, since that is something we want\n\t * to allow (on hw that supports it).  For hw that does not, it\n\t * should be checked in driver's crtc->atomic_check() vfunc.\n\t *\n\t * TODO: Add generic modeset state checks once we support those.\n\t */\n\n\tif (new_crtc_state->active && !new_crtc_state->enable) {\n\t\tdrm_dbg_atomic(crtc->dev,\n\t\t\t       \"[CRTC:%d:%s] active without enabled\\n\",\n\t\t\t       crtc->base.id, crtc->name);\n\t\treturn -EINVAL;\n\t}\n\n\t/* The state->enable vs. state->mode_blob checks can be WARN_ON,\n\t * as this is a kernel-internal detail that userspace should never\n\t * be able to trigger.\n\t */\n\tif (drm_core_check_feature(crtc->dev, DRIVER_ATOMIC) &&\n\t    WARN_ON(new_crtc_state->enable && !new_crtc_state->mode_blob)) {\n\t\tdrm_dbg_atomic(crtc->dev,\n\t\t\t       \"[CRTC:%d:%s] enabled without mode blob\\n\",\n\t\t\t       crtc->base.id, crtc->name);\n\t\treturn -EINVAL;\n\t}\n\n\tif (drm_core_check_feature(crtc->dev, DRIVER_ATOMIC) &&\n\t    WARN_ON(!new_crtc_state->enable && new_crtc_state->mode_blob)) {\n\t\tdrm_dbg_atomic(crtc->dev,\n\t\t\t       \"[CRTC:%d:%s] disabled with mode blob\\n\",\n\t\t\t       crtc->base.id, crtc->name);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Reject event generation for when a CRTC is off and stays off.\n\t * It wouldn't be hard to implement this, but userspace has a track\n\t * record of happily burning through 100% cpu (or worse, crash) when the\n\t * display pipe is suspended. To avoid all that fun just reject updates\n\t * that ask for events since likely that indicates a bug in the\n\t * compositor's drawing loop. This is consistent with the vblank IOCTL\n\t * and legacy page_flip IOCTL which also reject service on a disabled\n\t * pipe.\n\t */\n\tif (new_crtc_state->event &&\n\t    !new_crtc_state->active && !old_crtc_state->active) {\n\t\tdrm_dbg_atomic(crtc->dev,\n\t\t\t       \"[CRTC:%d:%s] requesting event but off\\n\",\n\t\t\t       crtc->base.id, crtc->name);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void drm_atomic_crtc_print_state(struct drm_printer *p,\n\t\tconst struct drm_crtc_state *state)\n{\n\tstruct drm_crtc *crtc = state->crtc;\n\n\tdrm_printf(p, \"crtc[%u]: %s\\n\", crtc->base.id, crtc->name);\n\tdrm_printf(p, \"\\tenable=%d\\n\", state->enable);\n\tdrm_printf(p, \"\\tactive=%d\\n\", state->active);\n\tdrm_printf(p, \"\\tself_refresh_active=%d\\n\", state->self_refresh_active);\n\tdrm_printf(p, \"\\tplanes_changed=%d\\n\", state->planes_changed);\n\tdrm_printf(p, \"\\tmode_changed=%d\\n\", state->mode_changed);\n\tdrm_printf(p, \"\\tactive_changed=%d\\n\", state->active_changed);\n\tdrm_printf(p, \"\\tconnectors_changed=%d\\n\", state->connectors_changed);\n\tdrm_printf(p, \"\\tcolor_mgmt_changed=%d\\n\", state->color_mgmt_changed);\n\tdrm_printf(p, \"\\tplane_mask=%x\\n\", state->plane_mask);\n\tdrm_printf(p, \"\\tconnector_mask=%x\\n\", state->connector_mask);\n\tdrm_printf(p, \"\\tencoder_mask=%x\\n\", state->encoder_mask);\n\tdrm_printf(p, \"\\tmode: \" DRM_MODE_FMT \"\\n\", DRM_MODE_ARG(&state->mode));\n\n\tif (crtc->funcs->atomic_print_state)\n\t\tcrtc->funcs->atomic_print_state(p, state);\n}\n\nstatic int drm_atomic_connector_check(struct drm_connector *connector,\n\t\tstruct drm_connector_state *state)\n{\n\tstruct drm_crtc_state *crtc_state;\n\tstruct drm_writeback_job *writeback_job = state->writeback_job;\n\tconst struct drm_display_info *info = &connector->display_info;\n\n\tstate->max_bpc = info->bpc ? info->bpc : 8;\n\tif (connector->max_bpc_property)\n\t\tstate->max_bpc = min(state->max_bpc, state->max_requested_bpc);\n\n\tif ((connector->connector_type != DRM_MODE_CONNECTOR_WRITEBACK) || !writeback_job)\n\t\treturn 0;\n\n\tif (writeback_job->fb && !state->crtc) {\n\t\tdrm_dbg_atomic(connector->dev,\n\t\t\t       \"[CONNECTOR:%d:%s] framebuffer without CRTC\\n\",\n\t\t\t       connector->base.id, connector->name);\n\t\treturn -EINVAL;\n\t}\n\n\tif (state->crtc)\n\t\tcrtc_state = drm_atomic_get_existing_crtc_state(state->state,\n\t\t\t\t\t\t\t\tstate->crtc);\n\n\tif (writeback_job->fb && !crtc_state->active) {\n\t\tdrm_dbg_atomic(connector->dev,\n\t\t\t       \"[CONNECTOR:%d:%s] has framebuffer, but [CRTC:%d] is off\\n\",\n\t\t\t       connector->base.id, connector->name,\n\t\t\t       state->crtc->base.id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!writeback_job->fb) {\n\t\tif (writeback_job->out_fence) {\n\t\t\tdrm_dbg_atomic(connector->dev,\n\t\t\t\t       \"[CONNECTOR:%d:%s] requesting out-fence without framebuffer\\n\",\n\t\t\t\t       connector->base.id, connector->name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tdrm_writeback_cleanup_job(writeback_job);\n\t\tstate->writeback_job = NULL;\n\t}\n\n\treturn 0;\n}\n\n/**\n * drm_atomic_get_plane_state - get plane state\n * @state: global atomic state object\n * @plane: plane to get state object for\n *\n * This function returns the plane state for the given plane, allocating it if\n * needed. It will also grab the relevant plane lock to make sure that the state\n * is consistent.\n *\n * Returns:\n *\n * Either the allocated state or the error code encoded into the pointer. When\n * the error is EDEADLK then the w/w mutex code has detected a deadlock and the\n * entire atomic sequence must be restarted. All other errors are fatal.\n */\nstruct drm_plane_state *\ndrm_atomic_get_plane_state(struct drm_atomic_state *state,\n\t\t\t  struct drm_plane *plane)\n{\n\tint ret, index = drm_plane_index(plane);\n\tstruct drm_plane_state *plane_state;\n\n\tWARN_ON(!state->acquire_ctx);\n\n\t/* the legacy pointers should never be set */\n\tWARN_ON(plane->fb);\n\tWARN_ON(plane->old_fb);\n\tWARN_ON(plane->crtc);\n\n\tplane_state = drm_atomic_get_existing_plane_state(state, plane);\n\tif (plane_state)\n\t\treturn plane_state;\n\n\tret = drm_modeset_lock(&plane->mutex, state->acquire_ctx);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tplane_state = plane->funcs->atomic_duplicate_state(plane);\n\tif (!plane_state)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstate->planes[index].state = plane_state;\n\tstate->planes[index].ptr = plane;\n\tstate->planes[index].old_state = plane->state;\n\tstate->planes[index].new_state = plane_state;\n\tplane_state->state = state;\n\n\tdrm_dbg_atomic(plane->dev, \"Added [PLANE:%d:%s] %p state to %p\\n\",\n\t\t       plane->base.id, plane->name, plane_state, state);\n\n\tif (plane_state->crtc) {\n\t\tstruct drm_crtc_state *crtc_state;\n\n\t\tcrtc_state = drm_atomic_get_crtc_state(state,\n\t\t\t\t\t\t       plane_state->crtc);\n\t\tif (IS_ERR(crtc_state))\n\t\t\treturn ERR_CAST(crtc_state);\n\t}\n\n\treturn plane_state;\n}\nEXPORT_SYMBOL(drm_atomic_get_plane_state);\n\nstatic bool\nplane_switching_crtc(const struct drm_plane_state *old_plane_state,\n\t\t     const struct drm_plane_state *new_plane_state)\n{\n\tif (!old_plane_state->crtc || !new_plane_state->crtc)\n\t\treturn false;\n\n\tif (old_plane_state->crtc == new_plane_state->crtc)\n\t\treturn false;\n\n\t/* This could be refined, but currently there's no helper or driver code\n\t * to implement direct switching of active planes nor userspace to take\n\t * advantage of more direct plane switching without the intermediate\n\t * full OFF state.\n\t */\n\treturn true;\n}\n\n/**\n * drm_atomic_plane_check - check plane state\n * @old_plane_state: old plane state to check\n * @new_plane_state: new plane state to check\n *\n * Provides core sanity checks for plane state.\n *\n * RETURNS:\n * Zero on success, error code on failure\n */\nstatic int drm_atomic_plane_check(const struct drm_plane_state *old_plane_state,\n\t\t\t\t  const struct drm_plane_state *new_plane_state)\n{\n\tstruct drm_plane *plane = new_plane_state->plane;\n\tstruct drm_crtc *crtc = new_plane_state->crtc;\n\tconst struct drm_framebuffer *fb = new_plane_state->fb;\n\tunsigned int fb_width, fb_height;\n\tstruct drm_mode_rect *clips;\n\tuint32_t num_clips;\n\tint ret;\n\n\t/* either *both* CRTC and FB must be set, or neither */\n\tif (crtc && !fb) {\n\t\tdrm_dbg_atomic(plane->dev, \"[PLANE:%d:%s] CRTC set but no FB\\n\",\n\t\t\t       plane->base.id, plane->name);\n\t\treturn -EINVAL;\n\t} else if (fb && !crtc) {\n\t\tdrm_dbg_atomic(plane->dev, \"[PLANE:%d:%s] FB set but no CRTC\\n\",\n\t\t\t       plane->base.id, plane->name);\n\t\treturn -EINVAL;\n\t}\n\n\t/* if disabled, we don't care about the rest of the state: */\n\tif (!crtc)\n\t\treturn 0;\n\n\t/* Check whether this plane is usable on this CRTC */\n\tif (!(plane->possible_crtcs & drm_crtc_mask(crtc))) {\n\t\tdrm_dbg_atomic(plane->dev,\n\t\t\t       \"Invalid [CRTC:%d:%s] for [PLANE:%d:%s]\\n\",\n\t\t\t       crtc->base.id, crtc->name,\n\t\t\t       plane->base.id, plane->name);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check whether this plane supports the fb pixel format. */\n\tret = drm_plane_check_pixel_format(plane, fb->format->format,\n\t\t\t\t\t   fb->modifier);\n\tif (ret) {\n\t\tdrm_dbg_atomic(plane->dev,\n\t\t\t       \"[PLANE:%d:%s] invalid pixel format %p4cc, modifier 0x%llx\\n\",\n\t\t\t       plane->base.id, plane->name,\n\t\t\t       &fb->format->format, fb->modifier);\n\t\treturn ret;\n\t}\n\n\t/* Give drivers some help against integer overflows */\n\tif (new_plane_state->crtc_w > INT_MAX ||\n\t    new_plane_state->crtc_x > INT_MAX - (int32_t) new_plane_state->crtc_w ||\n\t    new_plane_state->crtc_h > INT_MAX ||\n\t    new_plane_state->crtc_y > INT_MAX - (int32_t) new_plane_state->crtc_h) {\n\t\tdrm_dbg_atomic(plane->dev,\n\t\t\t       \"[PLANE:%d:%s] invalid CRTC coordinates %ux%u+%d+%d\\n\",\n\t\t\t       plane->base.id, plane->name,\n\t\t\t       new_plane_state->crtc_w, new_plane_state->crtc_h,\n\t\t\t       new_plane_state->crtc_x, new_plane_state->crtc_y);\n\t\treturn -ERANGE;\n\t}\n\n\tfb_width = fb->width << 16;\n\tfb_height = fb->height << 16;\n\n\t/* Make sure source coordinates are inside the fb. */\n\tif (new_plane_state->src_w > fb_width ||\n\t    new_plane_state->src_x > fb_width - new_plane_state->src_w ||\n\t    new_plane_state->src_h > fb_height ||\n\t    new_plane_state->src_y > fb_height - new_plane_state->src_h) {\n\t\tdrm_dbg_atomic(plane->dev,\n\t\t\t       \"[PLANE:%d:%s] invalid source coordinates \"\n\t\t\t       \"%u.%06ux%u.%06u+%u.%06u+%u.%06u (fb %ux%u)\\n\",\n\t\t\t       plane->base.id, plane->name,\n\t\t\t       new_plane_state->src_w >> 16,\n\t\t\t       ((new_plane_state->src_w & 0xffff) * 15625) >> 10,\n\t\t\t       new_plane_state->src_h >> 16,\n\t\t\t       ((new_plane_state->src_h & 0xffff) * 15625) >> 10,\n\t\t\t       new_plane_state->src_x >> 16,\n\t\t\t       ((new_plane_state->src_x & 0xffff) * 15625) >> 10,\n\t\t\t       new_plane_state->src_y >> 16,\n\t\t\t       ((new_plane_state->src_y & 0xffff) * 15625) >> 10,\n\t\t\t       fb->width, fb->height);\n\t\treturn -ENOSPC;\n\t}\n\n\tclips = __drm_plane_get_damage_clips(new_plane_state);\n\tnum_clips = drm_plane_get_damage_clips_count(new_plane_state);\n\n\t/* Make sure damage clips are valid and inside the fb. */\n\twhile (num_clips > 0) {\n\t\tif (clips->x1 >= clips->x2 ||\n\t\t    clips->y1 >= clips->y2 ||\n\t\t    clips->x1 < 0 ||\n\t\t    clips->y1 < 0 ||\n\t\t    clips->x2 > fb_width ||\n\t\t    clips->y2 > fb_height) {\n\t\t\tdrm_dbg_atomic(plane->dev,\n\t\t\t\t       \"[PLANE:%d:%s] invalid damage clip %d %d %d %d\\n\",\n\t\t\t\t       plane->base.id, plane->name, clips->x1,\n\t\t\t\t       clips->y1, clips->x2, clips->y2);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tclips++;\n\t\tnum_clips--;\n\t}\n\n\tif (plane_switching_crtc(old_plane_state, new_plane_state)) {\n\t\tdrm_dbg_atomic(plane->dev,\n\t\t\t       \"[PLANE:%d:%s] switching CRTC directly\\n\",\n\t\t\t       plane->base.id, plane->name);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void drm_atomic_plane_print_state(struct drm_printer *p,\n\t\tconst struct drm_plane_state *state)\n{\n\tstruct drm_plane *plane = state->plane;\n\tstruct drm_rect src  = drm_plane_state_src(state);\n\tstruct drm_rect dest = drm_plane_state_dest(state);\n\n\tdrm_printf(p, \"plane[%u]: %s\\n\", plane->base.id, plane->name);\n\tdrm_printf(p, \"\\tcrtc=%s\\n\", state->crtc ? state->crtc->name : \"(null)\");\n\tdrm_printf(p, \"\\tfb=%u\\n\", state->fb ? state->fb->base.id : 0);\n\tif (state->fb)\n\t\tdrm_framebuffer_print_info(p, 2, state->fb);\n\tdrm_printf(p, \"\\tcrtc-pos=\" DRM_RECT_FMT \"\\n\", DRM_RECT_ARG(&dest));\n\tdrm_printf(p, \"\\tsrc-pos=\" DRM_RECT_FP_FMT \"\\n\", DRM_RECT_FP_ARG(&src));\n\tdrm_printf(p, \"\\trotation=%x\\n\", state->rotation);\n\tdrm_printf(p, \"\\tnormalized-zpos=%x\\n\", state->normalized_zpos);\n\tdrm_printf(p, \"\\tcolor-encoding=%s\\n\",\n\t\t   drm_get_color_encoding_name(state->color_encoding));\n\tdrm_printf(p, \"\\tcolor-range=%s\\n\",\n\t\t   drm_get_color_range_name(state->color_range));\n\n\tif (plane->funcs->atomic_print_state)\n\t\tplane->funcs->atomic_print_state(p, state);\n}\n\n/**\n * DOC: handling driver private state\n *\n * Very often the DRM objects exposed to userspace in the atomic modeset api\n * (&drm_connector, &drm_crtc and &drm_plane) do not map neatly to the\n * underlying hardware. Especially for any kind of shared resources (e.g. shared\n * clocks, scaler units, bandwidth and fifo limits shared among a group of\n * planes or CRTCs, and so on) it makes sense to model these as independent\n * objects. Drivers then need to do similar state tracking and commit ordering for\n * such private (since not exposed to userspace) objects as the atomic core and\n * helpers already provide for connectors, planes and CRTCs.\n *\n * To make this easier on drivers the atomic core provides some support to track\n * driver private state objects using struct &drm_private_obj, with the\n * associated state struct &drm_private_state.\n *\n * Similar to userspace-exposed objects, private state structures can be\n * acquired by calling drm_atomic_get_private_obj_state(). This also takes care\n * of locking, hence drivers should not have a need to call drm_modeset_lock()\n * directly. Sequence of the actual hardware state commit is not handled,\n * drivers might need to keep track of struct drm_crtc_commit within subclassed\n * structure of &drm_private_state as necessary, e.g. similar to\n * &drm_plane_state.commit. See also &drm_atomic_state.fake_commit.\n *\n * All private state structures contained in a &drm_atomic_state update can be\n * iterated using for_each_oldnew_private_obj_in_state(),\n * for_each_new_private_obj_in_state() and for_each_old_private_obj_in_state().\n * Drivers are recommended to wrap these for each type of driver private state\n * object they have, filtering on &drm_private_obj.funcs using for_each_if(), at\n * least if they want to iterate over all objects of a given type.\n *\n * An earlier way to handle driver private state was by subclassing struct\n * &drm_atomic_state. But since that encourages non-standard ways to implement\n * the check/commit split atomic requires (by using e.g. \"check and rollback or\n * commit instead\" of \"duplicate state, check, then either commit or release\n * duplicated state) it is deprecated in favour of using &drm_private_state.\n */\n\n/**\n * drm_atomic_private_obj_init - initialize private object\n * @dev: DRM device this object will be attached to\n * @obj: private object\n * @state: initial private object state\n * @funcs: pointer to the struct of function pointers that identify the object\n * type\n *\n * Initialize the private object, which can be embedded into any\n * driver private object that needs its own atomic state.\n */\nvoid\ndrm_atomic_private_obj_init(struct drm_device *dev,\n\t\t\t    struct drm_private_obj *obj,\n\t\t\t    struct drm_private_state *state,\n\t\t\t    const struct drm_private_state_funcs *funcs)\n{\n\tmemset(obj, 0, sizeof(*obj));\n\n\tdrm_modeset_lock_init(&obj->lock);\n\n\tobj->state = state;\n\tobj->funcs = funcs;\n\tlist_add_tail(&obj->head, &dev->mode_config.privobj_list);\n\n\tstate->obj = obj;\n}\nEXPORT_SYMBOL(drm_atomic_private_obj_init);\n\n/**\n * drm_atomic_private_obj_fini - finalize private object\n * @obj: private object\n *\n * Finalize the private object.\n */\nvoid\ndrm_atomic_private_obj_fini(struct drm_private_obj *obj)\n{\n\tlist_del(&obj->head);\n\tobj->funcs->atomic_destroy_state(obj, obj->state);\n\tdrm_modeset_lock_fini(&obj->lock);\n}\nEXPORT_SYMBOL(drm_atomic_private_obj_fini);\n\n/**\n * drm_atomic_get_private_obj_state - get private object state\n * @state: global atomic state\n * @obj: private object to get the state for\n *\n * This function returns the private object state for the given private object,\n * allocating the state if needed. It will also grab the relevant private\n * object lock to make sure that the state is consistent.\n *\n * RETURNS:\n *\n * Either the allocated state or the error code encoded into a pointer.\n */\nstruct drm_private_state *\ndrm_atomic_get_private_obj_state(struct drm_atomic_state *state,\n\t\t\t\t struct drm_private_obj *obj)\n{\n\tint index, num_objs, i, ret;\n\tsize_t size;\n\tstruct __drm_private_objs_state *arr;\n\tstruct drm_private_state *obj_state;\n\n\tfor (i = 0; i < state->num_private_objs; i++)\n\t\tif (obj == state->private_objs[i].ptr)\n\t\t\treturn state->private_objs[i].state;\n\n\tret = drm_modeset_lock(&obj->lock, state->acquire_ctx);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tnum_objs = state->num_private_objs + 1;\n\tsize = sizeof(*state->private_objs) * num_objs;\n\tarr = krealloc(state->private_objs, size, GFP_KERNEL);\n\tif (!arr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstate->private_objs = arr;\n\tindex = state->num_private_objs;\n\tmemset(&state->private_objs[index], 0, sizeof(*state->private_objs));\n\n\tobj_state = obj->funcs->atomic_duplicate_state(obj);\n\tif (!obj_state)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstate->private_objs[index].state = obj_state;\n\tstate->private_objs[index].old_state = obj->state;\n\tstate->private_objs[index].new_state = obj_state;\n\tstate->private_objs[index].ptr = obj;\n\tobj_state->state = state;\n\n\tstate->num_private_objs = num_objs;\n\n\tdrm_dbg_atomic(state->dev,\n\t\t       \"Added new private object %p state %p to %p\\n\",\n\t\t       obj, obj_state, state);\n\n\treturn obj_state;\n}\nEXPORT_SYMBOL(drm_atomic_get_private_obj_state);\n\n/**\n * drm_atomic_get_old_private_obj_state\n * @state: global atomic state object\n * @obj: private_obj to grab\n *\n * This function returns the old private object state for the given private_obj,\n * or NULL if the private_obj is not part of the global atomic state.\n */\nstruct drm_private_state *\ndrm_atomic_get_old_private_obj_state(const struct drm_atomic_state *state,\n\t\t\t\t     struct drm_private_obj *obj)\n{\n\tint i;\n\n\tfor (i = 0; i < state->num_private_objs; i++)\n\t\tif (obj == state->private_objs[i].ptr)\n\t\t\treturn state->private_objs[i].old_state;\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(drm_atomic_get_old_private_obj_state);\n\n/**\n * drm_atomic_get_new_private_obj_state\n * @state: global atomic state object\n * @obj: private_obj to grab\n *\n * This function returns the new private object state for the given private_obj,\n * or NULL if the private_obj is not part of the global atomic state.\n */\nstruct drm_private_state *\ndrm_atomic_get_new_private_obj_state(const struct drm_atomic_state *state,\n\t\t\t\t     struct drm_private_obj *obj)\n{\n\tint i;\n\n\tfor (i = 0; i < state->num_private_objs; i++)\n\t\tif (obj == state->private_objs[i].ptr)\n\t\t\treturn state->private_objs[i].new_state;\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(drm_atomic_get_new_private_obj_state);\n\n/**\n * drm_atomic_get_old_connector_for_encoder - Get old connector for an encoder\n * @state: Atomic state\n * @encoder: The encoder to fetch the connector state for\n *\n * This function finds and returns the connector that was connected to @encoder\n * as specified by the @state.\n *\n * If there is no connector in @state which previously had @encoder connected to\n * it, this function will return NULL. While this may seem like an invalid use\n * case, it is sometimes useful to differentiate commits which had no prior\n * connectors attached to @encoder vs ones that did (and to inspect their\n * state). This is especially true in enable hooks because the pipeline has\n * changed.\n *\n * Returns: The old connector connected to @encoder, or NULL if the encoder is\n * not connected.\n */\nstruct drm_connector *\ndrm_atomic_get_old_connector_for_encoder(const struct drm_atomic_state *state,\n\t\t\t\t\t struct drm_encoder *encoder)\n{\n\tstruct drm_connector_state *conn_state;\n\tstruct drm_connector *connector;\n\tunsigned int i;\n\n\tfor_each_old_connector_in_state(state, connector, conn_state, i) {\n\t\tif (conn_state->best_encoder == encoder)\n\t\t\treturn connector;\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(drm_atomic_get_old_connector_for_encoder);\n\n/**\n * drm_atomic_get_new_connector_for_encoder - Get new connector for an encoder\n * @state: Atomic state\n * @encoder: The encoder to fetch the connector state for\n *\n * This function finds and returns the connector that will be connected to\n * @encoder as specified by the @state.\n *\n * If there is no connector in @state which will have @encoder connected to it,\n * this function will return NULL. While this may seem like an invalid use case,\n * it is sometimes useful to differentiate commits which have no connectors\n * attached to @encoder vs ones that do (and to inspect their state). This is\n * especially true in disable hooks because the pipeline will change.\n *\n * Returns: The new connector connected to @encoder, or NULL if the encoder is\n * not connected.\n */\nstruct drm_connector *\ndrm_atomic_get_new_connector_for_encoder(const struct drm_atomic_state *state,\n\t\t\t\t\t struct drm_encoder *encoder)\n{\n\tstruct drm_connector_state *conn_state;\n\tstruct drm_connector *connector;\n\tunsigned int i;\n\n\tfor_each_new_connector_in_state(state, connector, conn_state, i) {\n\t\tif (conn_state->best_encoder == encoder)\n\t\t\treturn connector;\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(drm_atomic_get_new_connector_for_encoder);\n\n/**\n * drm_atomic_get_old_crtc_for_encoder - Get old crtc for an encoder\n * @state: Atomic state\n * @encoder: The encoder to fetch the crtc state for\n *\n * This function finds and returns the crtc that was connected to @encoder\n * as specified by the @state.\n *\n * Returns: The old crtc connected to @encoder, or NULL if the encoder is\n * not connected.\n */\nstruct drm_crtc *\ndrm_atomic_get_old_crtc_for_encoder(struct drm_atomic_state *state,\n\t\t\t\t    struct drm_encoder *encoder)\n{\n\tstruct drm_connector *connector;\n\tstruct drm_connector_state *conn_state;\n\n\tconnector = drm_atomic_get_old_connector_for_encoder(state, encoder);\n\tif (!connector)\n\t\treturn NULL;\n\n\tconn_state = drm_atomic_get_old_connector_state(state, connector);\n\tif (!conn_state)\n\t\treturn NULL;\n\n\treturn conn_state->crtc;\n}\nEXPORT_SYMBOL(drm_atomic_get_old_crtc_for_encoder);\n\n/**\n * drm_atomic_get_new_crtc_for_encoder - Get new crtc for an encoder\n * @state: Atomic state\n * @encoder: The encoder to fetch the crtc state for\n *\n * This function finds and returns the crtc that will be connected to @encoder\n * as specified by the @state.\n *\n * Returns: The new crtc connected to @encoder, or NULL if the encoder is\n * not connected.\n */\nstruct drm_crtc *\ndrm_atomic_get_new_crtc_for_encoder(struct drm_atomic_state *state,\n\t\t\t\t    struct drm_encoder *encoder)\n{\n\tstruct drm_connector *connector;\n\tstruct drm_connector_state *conn_state;\n\n\tconnector = drm_atomic_get_new_connector_for_encoder(state, encoder);\n\tif (!connector)\n\t\treturn NULL;\n\n\tconn_state = drm_atomic_get_new_connector_state(state, connector);\n\tif (!conn_state)\n\t\treturn NULL;\n\n\treturn conn_state->crtc;\n}\nEXPORT_SYMBOL(drm_atomic_get_new_crtc_for_encoder);\n\n/**\n * drm_atomic_get_connector_state - get connector state\n * @state: global atomic state object\n * @connector: connector to get state object for\n *\n * This function returns the connector state for the given connector,\n * allocating it if needed. It will also grab the relevant connector lock to\n * make sure that the state is consistent.\n *\n * Returns:\n *\n * Either the allocated state or the error code encoded into the pointer. When\n * the error is EDEADLK then the w/w mutex code has detected a deadlock and the\n * entire atomic sequence must be restarted. All other errors are fatal.\n */\nstruct drm_connector_state *\ndrm_atomic_get_connector_state(struct drm_atomic_state *state,\n\t\t\t  struct drm_connector *connector)\n{\n\tint ret, index;\n\tstruct drm_mode_config *config = &connector->dev->mode_config;\n\tstruct drm_connector_state *connector_state;\n\n\tWARN_ON(!state->acquire_ctx);\n\n\tret = drm_modeset_lock(&config->connection_mutex, state->acquire_ctx);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tindex = drm_connector_index(connector);\n\n\tif (index >= state->num_connector) {\n\t\tstruct __drm_connnectors_state *c;\n\t\tint alloc = max(index + 1, config->num_connector);\n\n\t\tc = krealloc_array(state->connectors, alloc,\n\t\t\t\t   sizeof(*state->connectors), GFP_KERNEL);\n\t\tif (!c)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\tstate->connectors = c;\n\t\tmemset(&state->connectors[state->num_connector], 0,\n\t\t       sizeof(*state->connectors) * (alloc - state->num_connector));\n\n\t\tstate->num_connector = alloc;\n\t}\n\n\tif (state->connectors[index].state)\n\t\treturn state->connectors[index].state;\n\n\tconnector_state = connector->funcs->atomic_duplicate_state(connector);\n\tif (!connector_state)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdrm_connector_get(connector);\n\tstate->connectors[index].state = connector_state;\n\tstate->connectors[index].old_state = connector->state;\n\tstate->connectors[index].new_state = connector_state;\n\tstate->connectors[index].ptr = connector;\n\tconnector_state->state = state;\n\n\tdrm_dbg_atomic(connector->dev, \"Added [CONNECTOR:%d:%s] %p state to %p\\n\",\n\t\t\t connector->base.id, connector->name,\n\t\t\t connector_state, state);\n\n\tif (connector_state->crtc) {\n\t\tstruct drm_crtc_state *crtc_state;\n\n\t\tcrtc_state = drm_atomic_get_crtc_state(state,\n\t\t\t\t\t\t       connector_state->crtc);\n\t\tif (IS_ERR(crtc_state))\n\t\t\treturn ERR_CAST(crtc_state);\n\t}\n\n\treturn connector_state;\n}\nEXPORT_SYMBOL(drm_atomic_get_connector_state);\n\nstatic void drm_atomic_connector_print_state(struct drm_printer *p,\n\t\tconst struct drm_connector_state *state)\n{\n\tstruct drm_connector *connector = state->connector;\n\n\tdrm_printf(p, \"connector[%u]: %s\\n\", connector->base.id, connector->name);\n\tdrm_printf(p, \"\\tcrtc=%s\\n\", state->crtc ? state->crtc->name : \"(null)\");\n\tdrm_printf(p, \"\\tself_refresh_aware=%d\\n\", state->self_refresh_aware);\n\tdrm_printf(p, \"\\tmax_requested_bpc=%d\\n\", state->max_requested_bpc);\n\tdrm_printf(p, \"\\tcolorspace=%s\\n\", drm_get_colorspace_name(state->colorspace));\n\n\tif (connector->connector_type == DRM_MODE_CONNECTOR_WRITEBACK)\n\t\tif (state->writeback_job && state->writeback_job->fb)\n\t\t\tdrm_printf(p, \"\\tfb=%d\\n\", state->writeback_job->fb->base.id);\n\n\tif (connector->funcs->atomic_print_state)\n\t\tconnector->funcs->atomic_print_state(p, state);\n}\n\n/**\n * drm_atomic_get_bridge_state - get bridge state\n * @state: global atomic state object\n * @bridge: bridge to get state object for\n *\n * This function returns the bridge state for the given bridge, allocating it\n * if needed. It will also grab the relevant bridge lock to make sure that the\n * state is consistent.\n *\n * Returns:\n *\n * Either the allocated state or the error code encoded into the pointer. When\n * the error is EDEADLK then the w/w mutex code has detected a deadlock and the\n * entire atomic sequence must be restarted.\n */\nstruct drm_bridge_state *\ndrm_atomic_get_bridge_state(struct drm_atomic_state *state,\n\t\t\t    struct drm_bridge *bridge)\n{\n\tstruct drm_private_state *obj_state;\n\n\tobj_state = drm_atomic_get_private_obj_state(state, &bridge->base);\n\tif (IS_ERR(obj_state))\n\t\treturn ERR_CAST(obj_state);\n\n\treturn drm_priv_to_bridge_state(obj_state);\n}\nEXPORT_SYMBOL(drm_atomic_get_bridge_state);\n\n/**\n * drm_atomic_get_old_bridge_state - get old bridge state, if it exists\n * @state: global atomic state object\n * @bridge: bridge to grab\n *\n * This function returns the old bridge state for the given bridge, or NULL if\n * the bridge is not part of the global atomic state.\n */\nstruct drm_bridge_state *\ndrm_atomic_get_old_bridge_state(const struct drm_atomic_state *state,\n\t\t\t\tstruct drm_bridge *bridge)\n{\n\tstruct drm_private_state *obj_state;\n\n\tobj_state = drm_atomic_get_old_private_obj_state(state, &bridge->base);\n\tif (!obj_state)\n\t\treturn NULL;\n\n\treturn drm_priv_to_bridge_state(obj_state);\n}\nEXPORT_SYMBOL(drm_atomic_get_old_bridge_state);\n\n/**\n * drm_atomic_get_new_bridge_state - get new bridge state, if it exists\n * @state: global atomic state object\n * @bridge: bridge to grab\n *\n * This function returns the new bridge state for the given bridge, or NULL if\n * the bridge is not part of the global atomic state.\n */\nstruct drm_bridge_state *\ndrm_atomic_get_new_bridge_state(const struct drm_atomic_state *state,\n\t\t\t\tstruct drm_bridge *bridge)\n{\n\tstruct drm_private_state *obj_state;\n\n\tobj_state = drm_atomic_get_new_private_obj_state(state, &bridge->base);\n\tif (!obj_state)\n\t\treturn NULL;\n\n\treturn drm_priv_to_bridge_state(obj_state);\n}\nEXPORT_SYMBOL(drm_atomic_get_new_bridge_state);\n\n/**\n * drm_atomic_add_encoder_bridges - add bridges attached to an encoder\n * @state: atomic state\n * @encoder: DRM encoder\n *\n * This function adds all bridges attached to @encoder. This is needed to add\n * bridge states to @state and make them available when\n * &drm_bridge_funcs.atomic_check(), &drm_bridge_funcs.atomic_pre_enable(),\n * &drm_bridge_funcs.atomic_enable(),\n * &drm_bridge_funcs.atomic_disable_post_disable() are called.\n *\n * Returns:\n * 0 on success or can fail with -EDEADLK or -ENOMEM. When the error is EDEADLK\n * then the w/w mutex code has detected a deadlock and the entire atomic\n * sequence must be restarted. All other errors are fatal.\n */\nint\ndrm_atomic_add_encoder_bridges(struct drm_atomic_state *state,\n\t\t\t       struct drm_encoder *encoder)\n{\n\tstruct drm_bridge_state *bridge_state;\n\tstruct drm_bridge *bridge;\n\n\tif (!encoder)\n\t\treturn 0;\n\n\tdrm_dbg_atomic(encoder->dev,\n\t\t       \"Adding all bridges for [encoder:%d:%s] to %p\\n\",\n\t\t       encoder->base.id, encoder->name, state);\n\n\tdrm_for_each_bridge_in_chain(encoder, bridge) {\n\t\t/* Skip bridges that don't implement the atomic state hooks. */\n\t\tif (!bridge->funcs->atomic_duplicate_state)\n\t\t\tcontinue;\n\n\t\tbridge_state = drm_atomic_get_bridge_state(state, bridge);\n\t\tif (IS_ERR(bridge_state))\n\t\t\treturn PTR_ERR(bridge_state);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_atomic_add_encoder_bridges);\n\n/**\n * drm_atomic_add_affected_connectors - add connectors for CRTC\n * @state: atomic state\n * @crtc: DRM CRTC\n *\n * This function walks the current configuration and adds all connectors\n * currently using @crtc to the atomic configuration @state. Note that this\n * function must acquire the connection mutex. This can potentially cause\n * unneeded serialization if the update is just for the planes on one CRTC. Hence\n * drivers and helpers should only call this when really needed (e.g. when a\n * full modeset needs to happen due to some change).\n *\n * Returns:\n * 0 on success or can fail with -EDEADLK or -ENOMEM. When the error is EDEADLK\n * then the w/w mutex code has detected a deadlock and the entire atomic\n * sequence must be restarted. All other errors are fatal.\n */\nint\ndrm_atomic_add_affected_connectors(struct drm_atomic_state *state,\n\t\t\t\t   struct drm_crtc *crtc)\n{\n\tstruct drm_mode_config *config = &state->dev->mode_config;\n\tstruct drm_connector *connector;\n\tstruct drm_connector_state *conn_state;\n\tstruct drm_connector_list_iter conn_iter;\n\tstruct drm_crtc_state *crtc_state;\n\tint ret;\n\n\tcrtc_state = drm_atomic_get_crtc_state(state, crtc);\n\tif (IS_ERR(crtc_state))\n\t\treturn PTR_ERR(crtc_state);\n\n\tret = drm_modeset_lock(&config->connection_mutex, state->acquire_ctx);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_dbg_atomic(crtc->dev,\n\t\t       \"Adding all current connectors for [CRTC:%d:%s] to %p\\n\",\n\t\t       crtc->base.id, crtc->name, state);\n\n\t/*\n\t * Changed connectors are already in @state, so only need to look\n\t * at the connector_mask in crtc_state.\n\t */\n\tdrm_connector_list_iter_begin(state->dev, &conn_iter);\n\tdrm_for_each_connector_iter(connector, &conn_iter) {\n\t\tif (!(crtc_state->connector_mask & drm_connector_mask(connector)))\n\t\t\tcontinue;\n\n\t\tconn_state = drm_atomic_get_connector_state(state, connector);\n\t\tif (IS_ERR(conn_state)) {\n\t\t\tdrm_connector_list_iter_end(&conn_iter);\n\t\t\treturn PTR_ERR(conn_state);\n\t\t}\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_atomic_add_affected_connectors);\n\n/**\n * drm_atomic_add_affected_planes - add planes for CRTC\n * @state: atomic state\n * @crtc: DRM CRTC\n *\n * This function walks the current configuration and adds all planes\n * currently used by @crtc to the atomic configuration @state. This is useful\n * when an atomic commit also needs to check all currently enabled plane on\n * @crtc, e.g. when changing the mode. It's also useful when re-enabling a CRTC\n * to avoid special code to force-enable all planes.\n *\n * Since acquiring a plane state will always also acquire the w/w mutex of the\n * current CRTC for that plane (if there is any) adding all the plane states for\n * a CRTC will not reduce parallelism of atomic updates.\n *\n * Returns:\n * 0 on success or can fail with -EDEADLK or -ENOMEM. When the error is EDEADLK\n * then the w/w mutex code has detected a deadlock and the entire atomic\n * sequence must be restarted. All other errors are fatal.\n */\nint\ndrm_atomic_add_affected_planes(struct drm_atomic_state *state,\n\t\t\t       struct drm_crtc *crtc)\n{\n\tconst struct drm_crtc_state *old_crtc_state =\n\t\tdrm_atomic_get_old_crtc_state(state, crtc);\n\tstruct drm_plane *plane;\n\n\tWARN_ON(!drm_atomic_get_new_crtc_state(state, crtc));\n\n\tdrm_dbg_atomic(crtc->dev,\n\t\t       \"Adding all current planes for [CRTC:%d:%s] to %p\\n\",\n\t\t       crtc->base.id, crtc->name, state);\n\n\tdrm_for_each_plane_mask(plane, state->dev, old_crtc_state->plane_mask) {\n\t\tstruct drm_plane_state *plane_state =\n\t\t\tdrm_atomic_get_plane_state(state, plane);\n\n\t\tif (IS_ERR(plane_state))\n\t\t\treturn PTR_ERR(plane_state);\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_atomic_add_affected_planes);\n\n/**\n * drm_atomic_check_only - check whether a given config would work\n * @state: atomic configuration to check\n *\n * Note that this function can return -EDEADLK if the driver needed to acquire\n * more locks but encountered a deadlock. The caller must then do the usual w/w\n * backoff dance and restart. All other errors are fatal.\n *\n * Returns:\n * 0 on success, negative error code on failure.\n */\nint drm_atomic_check_only(struct drm_atomic_state *state)\n{\n\tstruct drm_device *dev = state->dev;\n\tstruct drm_mode_config *config = &dev->mode_config;\n\tstruct drm_plane *plane;\n\tstruct drm_plane_state *old_plane_state;\n\tstruct drm_plane_state *new_plane_state;\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *old_crtc_state;\n\tstruct drm_crtc_state *new_crtc_state;\n\tstruct drm_connector *conn;\n\tstruct drm_connector_state *conn_state;\n\tunsigned int requested_crtc = 0;\n\tunsigned int affected_crtc = 0;\n\tint i, ret = 0;\n\n\tdrm_dbg_atomic(dev, \"checking %p\\n\", state);\n\n\tfor_each_new_crtc_in_state(state, crtc, new_crtc_state, i) {\n\t\tif (new_crtc_state->enable)\n\t\t\trequested_crtc |= drm_crtc_mask(crtc);\n\t}\n\n\tfor_each_oldnew_plane_in_state(state, plane, old_plane_state, new_plane_state, i) {\n\t\tret = drm_atomic_plane_check(old_plane_state, new_plane_state);\n\t\tif (ret) {\n\t\t\tdrm_dbg_atomic(dev, \"[PLANE:%d:%s] atomic core check failed\\n\",\n\t\t\t\t       plane->base.id, plane->name);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tfor_each_oldnew_crtc_in_state(state, crtc, old_crtc_state, new_crtc_state, i) {\n\t\tret = drm_atomic_crtc_check(old_crtc_state, new_crtc_state);\n\t\tif (ret) {\n\t\t\tdrm_dbg_atomic(dev, \"[CRTC:%d:%s] atomic core check failed\\n\",\n\t\t\t\t       crtc->base.id, crtc->name);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tfor_each_new_connector_in_state(state, conn, conn_state, i) {\n\t\tret = drm_atomic_connector_check(conn, conn_state);\n\t\tif (ret) {\n\t\t\tdrm_dbg_atomic(dev, \"[CONNECTOR:%d:%s] atomic core check failed\\n\",\n\t\t\t\t       conn->base.id, conn->name);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (config->funcs->atomic_check) {\n\t\tret = config->funcs->atomic_check(state->dev, state);\n\n\t\tif (ret) {\n\t\t\tdrm_dbg_atomic(dev, \"atomic driver check for %p failed: %d\\n\",\n\t\t\t\t       state, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (!state->allow_modeset) {\n\t\tfor_each_new_crtc_in_state(state, crtc, new_crtc_state, i) {\n\t\t\tif (drm_atomic_crtc_needs_modeset(new_crtc_state)) {\n\t\t\t\tdrm_dbg_atomic(dev, \"[CRTC:%d:%s] requires full modeset\\n\",\n\t\t\t\t\t       crtc->base.id, crtc->name);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor_each_new_crtc_in_state(state, crtc, new_crtc_state, i) {\n\t\tif (new_crtc_state->enable)\n\t\t\taffected_crtc |= drm_crtc_mask(crtc);\n\t}\n\n\t/*\n\t * For commits that allow modesets drivers can add other CRTCs to the\n\t * atomic commit, e.g. when they need to reallocate global resources.\n\t * This can cause spurious EBUSY, which robs compositors of a very\n\t * effective sanity check for their drawing loop. Therefor only allow\n\t * drivers to add unrelated CRTC states for modeset commits.\n\t *\n\t * FIXME: Should add affected_crtc mask to the ATOMIC IOCTL as an output\n\t * so compositors know what's going on.\n\t */\n\tif (affected_crtc != requested_crtc) {\n\t\tdrm_dbg_atomic(dev,\n\t\t\t       \"driver added CRTC to commit: requested 0x%x, affected 0x%0x\\n\",\n\t\t\t       requested_crtc, affected_crtc);\n\t\tWARN(!state->allow_modeset, \"adding CRTC not allowed without modesets: requested 0x%x, affected 0x%0x\\n\",\n\t\t     requested_crtc, affected_crtc);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_atomic_check_only);\n\n/**\n * drm_atomic_commit - commit configuration atomically\n * @state: atomic configuration to check\n *\n * Note that this function can return -EDEADLK if the driver needed to acquire\n * more locks but encountered a deadlock. The caller must then do the usual w/w\n * backoff dance and restart. All other errors are fatal.\n *\n * This function will take its own reference on @state.\n * Callers should always release their reference with drm_atomic_state_put().\n *\n * Returns:\n * 0 on success, negative error code on failure.\n */\nint drm_atomic_commit(struct drm_atomic_state *state)\n{\n\tstruct drm_mode_config *config = &state->dev->mode_config;\n\tstruct drm_printer p = drm_info_printer(state->dev->dev);\n\tint ret;\n\n\tif (drm_debug_enabled(DRM_UT_STATE))\n\t\tdrm_atomic_print_new_state(state, &p);\n\n\tret = drm_atomic_check_only(state);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_dbg_atomic(state->dev, \"committing %p\\n\", state);\n\n\treturn config->funcs->atomic_commit(state->dev, state, false);\n}\nEXPORT_SYMBOL(drm_atomic_commit);\n\n/**\n * drm_atomic_nonblocking_commit - atomic nonblocking commit\n * @state: atomic configuration to check\n *\n * Note that this function can return -EDEADLK if the driver needed to acquire\n * more locks but encountered a deadlock. The caller must then do the usual w/w\n * backoff dance and restart. All other errors are fatal.\n *\n * This function will take its own reference on @state.\n * Callers should always release their reference with drm_atomic_state_put().\n *\n * Returns:\n * 0 on success, negative error code on failure.\n */\nint drm_atomic_nonblocking_commit(struct drm_atomic_state *state)\n{\n\tstruct drm_mode_config *config = &state->dev->mode_config;\n\tint ret;\n\n\tret = drm_atomic_check_only(state);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_dbg_atomic(state->dev, \"committing %p nonblocking\\n\", state);\n\n\treturn config->funcs->atomic_commit(state->dev, state, true);\n}\nEXPORT_SYMBOL(drm_atomic_nonblocking_commit);\n\n/* just used from drm-client and atomic-helper: */\nint __drm_atomic_helper_disable_plane(struct drm_plane *plane,\n\t\t\t\t      struct drm_plane_state *plane_state)\n{\n\tint ret;\n\n\tret = drm_atomic_set_crtc_for_plane(plane_state, NULL);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tdrm_atomic_set_fb_for_plane(plane_state, NULL);\n\tplane_state->crtc_x = 0;\n\tplane_state->crtc_y = 0;\n\tplane_state->crtc_w = 0;\n\tplane_state->crtc_h = 0;\n\tplane_state->src_x = 0;\n\tplane_state->src_y = 0;\n\tplane_state->src_w = 0;\n\tplane_state->src_h = 0;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(__drm_atomic_helper_disable_plane);\n\nstatic int update_output_state(struct drm_atomic_state *state,\n\t\t\t       struct drm_mode_set *set)\n{\n\tstruct drm_device *dev = set->crtc->dev;\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *new_crtc_state;\n\tstruct drm_connector *connector;\n\tstruct drm_connector_state *new_conn_state;\n\tint ret, i;\n\n\tret = drm_modeset_lock(&dev->mode_config.connection_mutex,\n\t\t\t       state->acquire_ctx);\n\tif (ret)\n\t\treturn ret;\n\n\t/* First disable all connectors on the target crtc. */\n\tret = drm_atomic_add_affected_connectors(state, set->crtc);\n\tif (ret)\n\t\treturn ret;\n\n\tfor_each_new_connector_in_state(state, connector, new_conn_state, i) {\n\t\tif (new_conn_state->crtc == set->crtc) {\n\t\t\tret = drm_atomic_set_crtc_for_connector(new_conn_state,\n\t\t\t\t\t\t\t\tNULL);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\t/* Make sure legacy setCrtc always re-trains */\n\t\t\tnew_conn_state->link_status = DRM_LINK_STATUS_GOOD;\n\t\t}\n\t}\n\n\t/* Then set all connectors from set->connectors on the target crtc */\n\tfor (i = 0; i < set->num_connectors; i++) {\n\t\tnew_conn_state = drm_atomic_get_connector_state(state,\n\t\t\t\t\t\t\t\tset->connectors[i]);\n\t\tif (IS_ERR(new_conn_state))\n\t\t\treturn PTR_ERR(new_conn_state);\n\n\t\tret = drm_atomic_set_crtc_for_connector(new_conn_state,\n\t\t\t\t\t\t\tset->crtc);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfor_each_new_crtc_in_state(state, crtc, new_crtc_state, i) {\n\t\t/*\n\t\t * Don't update ->enable for the CRTC in the set_config request,\n\t\t * since a mismatch would indicate a bug in the upper layers.\n\t\t * The actual modeset code later on will catch any\n\t\t * inconsistencies here.\n\t\t */\n\t\tif (crtc == set->crtc)\n\t\t\tcontinue;\n\n\t\tif (!new_crtc_state->connector_mask) {\n\t\t\tret = drm_atomic_set_mode_prop_for_crtc(new_crtc_state,\n\t\t\t\t\t\t\t\tNULL);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tnew_crtc_state->active = false;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/* just used from drm-client and atomic-helper: */\nint __drm_atomic_helper_set_config(struct drm_mode_set *set,\n\t\t\t\t   struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *crtc_state;\n\tstruct drm_plane_state *primary_state;\n\tstruct drm_crtc *crtc = set->crtc;\n\tint hdisplay, vdisplay;\n\tint ret;\n\n\tcrtc_state = drm_atomic_get_crtc_state(state, crtc);\n\tif (IS_ERR(crtc_state))\n\t\treturn PTR_ERR(crtc_state);\n\n\tprimary_state = drm_atomic_get_plane_state(state, crtc->primary);\n\tif (IS_ERR(primary_state))\n\t\treturn PTR_ERR(primary_state);\n\n\tif (!set->mode) {\n\t\tWARN_ON(set->fb);\n\t\tWARN_ON(set->num_connectors);\n\n\t\tret = drm_atomic_set_mode_for_crtc(crtc_state, NULL);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\n\t\tcrtc_state->active = false;\n\n\t\tret = drm_atomic_set_crtc_for_plane(primary_state, NULL);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\n\t\tdrm_atomic_set_fb_for_plane(primary_state, NULL);\n\n\t\tgoto commit;\n\t}\n\n\tWARN_ON(!set->fb);\n\tWARN_ON(!set->num_connectors);\n\n\tret = drm_atomic_set_mode_for_crtc(crtc_state, set->mode);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tcrtc_state->active = true;\n\n\tret = drm_atomic_set_crtc_for_plane(primary_state, crtc);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tdrm_mode_get_hv_timing(set->mode, &hdisplay, &vdisplay);\n\n\tdrm_atomic_set_fb_for_plane(primary_state, set->fb);\n\tprimary_state->crtc_x = 0;\n\tprimary_state->crtc_y = 0;\n\tprimary_state->crtc_w = hdisplay;\n\tprimary_state->crtc_h = vdisplay;\n\tprimary_state->src_x = set->x << 16;\n\tprimary_state->src_y = set->y << 16;\n\tif (drm_rotation_90_or_270(primary_state->rotation)) {\n\t\tprimary_state->src_w = vdisplay << 16;\n\t\tprimary_state->src_h = hdisplay << 16;\n\t} else {\n\t\tprimary_state->src_w = hdisplay << 16;\n\t\tprimary_state->src_h = vdisplay << 16;\n\t}\n\ncommit:\n\tret = update_output_state(state, set);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(__drm_atomic_helper_set_config);\n\nstatic void drm_atomic_private_obj_print_state(struct drm_printer *p,\n\t\t\t\t\t       const struct drm_private_state *state)\n{\n\tstruct drm_private_obj *obj = state->obj;\n\n\tif (obj->funcs->atomic_print_state)\n\t\tobj->funcs->atomic_print_state(p, state);\n}\n\n/**\n * drm_atomic_print_new_state - prints drm atomic state\n * @state: atomic configuration to check\n * @p: drm printer\n *\n * This functions prints the drm atomic state snapshot using the drm printer\n * which is passed to it. This snapshot can be used for debugging purposes.\n *\n * Note that this function looks into the new state objects and hence its not\n * safe to be used after the call to drm_atomic_helper_commit_hw_done().\n */\nvoid drm_atomic_print_new_state(const struct drm_atomic_state *state,\n\t\tstruct drm_printer *p)\n{\n\tstruct drm_plane *plane;\n\tstruct drm_plane_state *plane_state;\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *crtc_state;\n\tstruct drm_connector *connector;\n\tstruct drm_connector_state *connector_state;\n\tstruct drm_private_obj *obj;\n\tstruct drm_private_state *obj_state;\n\tint i;\n\n\tif (!p) {\n\t\tdrm_err(state->dev, \"invalid drm printer\\n\");\n\t\treturn;\n\t}\n\n\tdrm_dbg_atomic(state->dev, \"checking %p\\n\", state);\n\n\tfor_each_new_plane_in_state(state, plane, plane_state, i)\n\t\tdrm_atomic_plane_print_state(p, plane_state);\n\n\tfor_each_new_crtc_in_state(state, crtc, crtc_state, i)\n\t\tdrm_atomic_crtc_print_state(p, crtc_state);\n\n\tfor_each_new_connector_in_state(state, connector, connector_state, i)\n\t\tdrm_atomic_connector_print_state(p, connector_state);\n\n\tfor_each_new_private_obj_in_state(state, obj, obj_state, i)\n\t\tdrm_atomic_private_obj_print_state(p, obj_state);\n}\nEXPORT_SYMBOL(drm_atomic_print_new_state);\n\nstatic void __drm_state_dump(struct drm_device *dev, struct drm_printer *p,\n\t\t\t     bool take_locks)\n{\n\tstruct drm_mode_config *config = &dev->mode_config;\n\tstruct drm_plane *plane;\n\tstruct drm_crtc *crtc;\n\tstruct drm_connector *connector;\n\tstruct drm_connector_list_iter conn_iter;\n\n\tif (!drm_drv_uses_atomic_modeset(dev))\n\t\treturn;\n\n\tlist_for_each_entry(plane, &config->plane_list, head) {\n\t\tif (take_locks)\n\t\t\tdrm_modeset_lock(&plane->mutex, NULL);\n\t\tdrm_atomic_plane_print_state(p, plane->state);\n\t\tif (take_locks)\n\t\t\tdrm_modeset_unlock(&plane->mutex);\n\t}\n\n\tlist_for_each_entry(crtc, &config->crtc_list, head) {\n\t\tif (take_locks)\n\t\t\tdrm_modeset_lock(&crtc->mutex, NULL);\n\t\tdrm_atomic_crtc_print_state(p, crtc->state);\n\t\tif (take_locks)\n\t\t\tdrm_modeset_unlock(&crtc->mutex);\n\t}\n\n\tdrm_connector_list_iter_begin(dev, &conn_iter);\n\tif (take_locks)\n\t\tdrm_modeset_lock(&dev->mode_config.connection_mutex, NULL);\n\tdrm_for_each_connector_iter(connector, &conn_iter)\n\t\tdrm_atomic_connector_print_state(p, connector->state);\n\tif (take_locks)\n\t\tdrm_modeset_unlock(&dev->mode_config.connection_mutex);\n\tdrm_connector_list_iter_end(&conn_iter);\n}\n\n/**\n * drm_state_dump - dump entire device atomic state\n * @dev: the drm device\n * @p: where to print the state to\n *\n * Just for debugging.  Drivers might want an option to dump state\n * to dmesg in case of error irq's.  (Hint, you probably want to\n * ratelimit this!)\n *\n * The caller must wrap this drm_modeset_lock_all_ctx() and\n * drm_modeset_drop_locks(). If this is called from error irq handler, it should\n * not be enabled by default - if you are debugging errors you might\n * not care that this is racey, but calling this without all modeset locks held\n * is inherently unsafe.\n */\nvoid drm_state_dump(struct drm_device *dev, struct drm_printer *p)\n{\n\t__drm_state_dump(dev, p, false);\n}\nEXPORT_SYMBOL(drm_state_dump);\n\n#ifdef CONFIG_DEBUG_FS\nstatic int drm_state_info(struct seq_file *m, void *data)\n{\n\tstruct drm_debugfs_entry *entry = m->private;\n\tstruct drm_device *dev = entry->dev;\n\tstruct drm_printer p = drm_seq_file_printer(m);\n\n\t__drm_state_dump(dev, &p, true);\n\n\treturn 0;\n}\n\n/* any use in debugfs files to dump individual planes/crtc/etc? */\nstatic const struct drm_debugfs_info drm_atomic_debugfs_list[] = {\n\t{\"state\", drm_state_info, 0},\n};\n\nvoid drm_atomic_debugfs_init(struct drm_minor *minor)\n{\n\tdrm_debugfs_add_files(minor->dev, drm_atomic_debugfs_list,\n\t\t\t      ARRAY_SIZE(drm_atomic_debugfs_list));\n}\n#endif\n"], "filenames": ["drivers/gpu/drm/drm_atomic.c"], "buggy_code_start_loc": [142], "buggy_code_end_loc": [313], "fixing_code_start_loc": [143], "fixing_code_end_loc": [323], "type": "CWE-416", "message": "In the Linux kernel before 6.4.5, drivers/gpu/drm/drm_atomic.c has a use-after-free during a race condition between a nonblocking atomic commit and a driver unload.", "other": {"cve": {"id": "CVE-2023-51043", "sourceIdentifier": "cve@mitre.org", "published": "2024-01-23T11:15:08.820", "lastModified": "2024-01-29T22:42:05.877", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In the Linux kernel before 6.4.5, drivers/gpu/drm/drm_atomic.c has a use-after-free during a race condition between a nonblocking atomic commit and a driver unload."}, {"lang": "es", "value": "En el kernel de Linux anterior a 6.4.5, drivers/gpu/drm/drm_atomic.c tiene un use-after-free durante una condici\u00f3n de ejecuci\u00f3n entre un commit at\u00f3mico sin bloqueo y una descarga del controlador."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.0, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.4.5", "matchCriteriaId": "5819C299-33F3-4B58-B0ED-46B0C73B4A51"}]}]}], "references": [{"url": "https://cdn.kernel.org/pub/linux/kernel/v6.x/ChangeLog-6.4.5", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://github.com/torvalds/linux/commit/4e076c73e4f6e90816b30fcd4a0d7ab365087255", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/4e076c73e4f6e90816b30fcd4a0d7ab365087255"}}