{"buggy_code": ["/* radare - LGPL - Copyright 2018 - pancake */\n\n#include <r_types.h>\n#include <r_util.h>\n#include <r_lib.h>\n#include <r_bin.h>\n#include <ht_uu.h>\n#include \"../i/private.h\"\n#include \"mach0/coresymbolication.h\"\n\n// enable debugging messages\n#define D if (0)\n#define R_UUID_LENGTH 33\n\ntypedef struct symbols_header_t {\n\tut32 magic;\n\tut32 version;\n\tut8 uuid[16];\n\tut32 unk0;\n\tut32 unk1;\n\tut32 slotsize;\n\tut32 addr;\n\tbool valid;\n\tint size;\n} SymbolsHeader;\n\ntypedef struct symbols_metadata_t { // 0x40\n\tut32 cputype;\n\tut32 subtype;\n\tut32 n_segments;\n\tut32 namelen;\n\tut32 name;\n\tbool valid;\n\tut32 size;\n\t//RList *segments;\n\tut32 addr;\n\tint bits;\n\tconst char *arch;\n\tconst char *cpu;\n} SymbolsMetadata;\n\n// header starts at offset 0 and ends at offset 0x40\nstatic SymbolsHeader parseHeader(RBuffer *buf) {\n\tut8 b[64];\n\tSymbolsHeader sh = { 0 };\n\t(void)r_buf_read_at (buf, 0, b, sizeof (b));\n\tsh.magic = r_read_le32 (b);\n\tsh.version = r_read_le32 (b + 4);\n\tsh.valid = sh.magic == 0xff01ff02;\n\tint i;\n\tfor (i = 0; i < 16; i++) {\n\t\tsh.uuid[i] = b[24 + i];\n\t}\n\tsh.unk0 = r_read_le16 (b + 0x28);\n\tsh.unk1 = r_read_le16 (b + 0x2c); // is slotsize + 1 :?\n\tsh.slotsize = r_read_le16 (b + 0x2e);\n\tsh.size = 0x40;\n\treturn sh;\n}\n\nstatic const char *typeString(ut32 n, int *bits) {\n\t*bits = 32;\n\tif (n == 12) { // CPU_SUBTYPE_ARM_V7) {\n\t\treturn \"arm\";\n\t}\n\tif (n == 0x0100000c) { // arm64\n\t\t*bits = 64;\n\t\treturn \"arm\";\n\t}\n\tif (n == 0x0200000c) { // arm64-32\n\t\t//  TODO: must change bits\n\t\t*bits = 64;\n\t\treturn \"arm\";\n\t}\n\treturn \"x86\";\n}\n\nstatic const char *subtypeString(int n) {\n\tif (n == 9) { // CPU_SUBTYPE_ARM_V7) {\n\t\treturn \"armv7\";\n\t}\n\treturn \"?\";\n}\n\n// metadata section starts at offset 0x40 and ends around 0xb0 depending on filenamelength\nstatic SymbolsMetadata parseMetadata(RBuffer *buf, int off) {\n\tSymbolsMetadata sm = { 0 };\n\tut8 b[0x100] = { 0 };\n\t(void)r_buf_read_at (buf, off, b, sizeof (b));\n\tsm.addr = off;\n\tsm.cputype = r_read_le32 (b);\n\tsm.arch = typeString (sm.cputype, &sm.bits);\n\t//  eprintf (\"0x%08x  cputype  0x%x -> %s\\n\", 0x40, sm.cputype, typeString (sm.cputype));\n\t// bits = (strstr (typeString (sm.cputype, &sm.bits), \"64\"))? 64: 32;\n\tsm.subtype = r_read_le32 (b + 4);\n\tsm.cpu = subtypeString (sm.subtype);\n\t//  eprintf (\"0x%08x  subtype  0x%x -> %s\\n\", 0x44, sm.subtype, subtypeString (sm.subtype));\n\tsm.n_segments = r_read_le32 (b + 8);\n\t// int count = r_read_le32 (b + 0x48);\n\tsm.namelen = r_read_le32 (b + 0xc);\n\t// eprintf (\"0x%08x  count    %d\\n\", 0x48, count);\n\t// eprintf (\"0x%08x  strlen   %d\\n\", 0x4c, sm.namelen);\n\t// eprintf (\"0x%08x  filename %s\\n\", 0x50, b + 16);\n\tint delta = 16;\n\t//sm.segments = parseSegments (buf, off + sm.namelen + delta, sm.n_segments);\n\tsm.size = (sm.n_segments * 32) + sm.namelen + delta;\n\n\t// hack to detect format\n\tut32 nm, nm2, nm3;\n\tr_buf_read_at (buf, off + sm.size, (ut8 *)&nm, sizeof (nm));\n\tr_buf_read_at (buf, off + sm.size + 4, (ut8 *)&nm2, sizeof (nm2));\n\tr_buf_read_at (buf, off + sm.size + 8, (ut8 *)&nm3, sizeof (nm3));\n\t// eprintf (\"0x%x next %x %x %x\\n\", off + sm.size, nm, nm2, nm3);\n\tif (r_read_le32 (&nm3) != 0xa1b22b1a) {\n\t\tsm.size -= 8;\n\t\t//\t\tis64 = true;\n\t}\n\treturn sm;\n}\n\nstatic RBinSection *bin_section_from_section(RCoreSymCacheElementSection *sect) {\n\tif (!sect->name) {\n\t\treturn NULL;\n\t}\n\tRBinSection *s = R_NEW0 (RBinSection);\n\tif (!s) {\n\t\treturn NULL;\n\t}\n\ts->name = r_str_ndup (sect->name, 256);\n\ts->size = sect->size;\n\ts->vsize = s->size;\n\ts->paddr = sect->paddr;\n\ts->vaddr = sect->vaddr;\n\ts->add = true;\n\ts->perm = strstr (s->name, \"TEXT\") ? 5 : 4;\n\ts->is_segment = false;\n\treturn s;\n}\n\nstatic RBinSection *bin_section_from_segment(RCoreSymCacheElementSegment *seg) {\n\tif (!seg->name) {\n\t\treturn NULL;\n\t}\n\tRBinSection *s = R_NEW0 (RBinSection);\n\tif (!s) {\n\t\treturn NULL;\n\t}\n\ts->name = r_str_ndup (seg->name, 16);\n\ts->size = seg->size;\n\ts->vsize = seg->vsize;\n\ts->paddr = seg->paddr;\n\ts->vaddr = seg->vaddr;\n\ts->add = true;\n\ts->perm = strstr (s->name, \"TEXT\") ? 5 : 4;\n\ts->is_segment = true;\n\treturn s;\n}\n\nstatic RBinSymbol *bin_symbol_from_symbol(RCoreSymCacheElement *element, RCoreSymCacheElementSymbol *s) {\n\tif (!s->name && !s->mangled_name) {\n\t\treturn NULL;\n\t}\n\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\tif (sym) {\n\t\tif (s->name && s->mangled_name) {\n\t\t\tsym->dname = strdup (s->name);\n\t\t\tsym->name = strdup (s->mangled_name);\n\t\t} else if (s->name) {\n\t\t\tsym->name = strdup (s->name);\n\t\t} else if (s->mangled_name) {\n\t\t\tsym->name = s->mangled_name;\n\t\t}\n\t\tsym->paddr = s->paddr;\n\t\tsym->vaddr = r_coresym_cache_element_pa2va (element, s->paddr);\n\t\tsym->size = s->size;\n\t\tsym->type = R_BIN_TYPE_FUNC_STR;\n\t\tsym->bind = \"NONE\";\n\t}\n\treturn sym;\n}\n\nstatic RCoreSymCacheElement *parseDragons(RBinFile *bf, RBuffer *buf, int off, int bits, R_OWN char *file_name) {\n\tD eprintf (\"Dragons at 0x%x\\n\", off);\n\tut64 size = r_buf_size (buf);\n\tif (off >= size) {\n\t\treturn NULL;\n\t}\n\tsize -= off;\n\tif (!size) {\n\t\treturn NULL;\n\t}\n\tut8 *b = malloc (size);\n\tif (!b) {\n\t\treturn NULL;\n\t}\n\tint available = r_buf_read_at (buf, off, b, size);\n\tif (available != size) {\n\t\teprintf (\"Warning: r_buf_read_at failed\\n\");\n\t\treturn NULL;\n\t}\n#if 0\n\t// after the list of sections, there's a bunch of unknown\n\t// data, brobably dwords, and then the same section list again\n\t// this function aims to parse it.\n\t0x00000138 |1a2b b2a1 0300 0000 1a2b b2a1 e055 0000| .+.......+...U..\n                         n_segments ----.          .--- how many sections ?\n\t0x00000148 |0100 0000 ca55 0000 0400 0000 1800 0000| .....U..........\n\t             .---- how many symbols? 0xc7\n\t0x00000158 |c700 0000 0000 0000 0000 0000 0104 0000| ................\n\t0x00000168 |250b e803 0000 0100 0000 0000 bd55 0000| %............U..\n\t0x00000178 |91bb e903 e35a b42c 93a4 340a 8746 9489| .....Z.,..4..F..\n\t0x00000188 |0cea 4c40 0c00 0000 0900 0000 0000 0000| ..L@............\n\t0x00000198 |0000 0000 0000 0000 0000 0000 0000 0000| ................\n\t0x000001a8 |0080 0000 0000 0000 5f5f 5445 5854 0000| ........__TEXT..\n\t0x000001b8 |0000 0000 0000 0000 0080 0000 0000 0000| ................\n\t0x000001c8 |0040 0000 0000 0000 5f5f 4441 5441 0000| .@......__DATA..\n\t0x000001d8 |0000 0000 0000 0000 00c0 0000 0000 0000| ................\n\t0x000001e8 |0000 0100 0000 0000 5f5f 4c4c 564d 0000| ........__LLVM..\n\t0x000001f8 |0000 0000 0000 0000 00c0 0100 0000 0000| ................\n\t0x00000208 |00c0 0000 0000 0000 5f5f 4c49 4e4b 4544| ........__LINKED\n\t0x00000218 |4954 0000 0000 0000 0000 0000 d069 0000| IT...........i..\n#endif\n\t// eprintf (\"Dragon's magic:\\n\");\n\tint magicCombo = 0;\n\tif (!memcmp (\"\\x1a\\x2b\\xb2\\xa1\", b, 4)) { // 0x130  ?\n\t\tmagicCombo++;\n\t}\n\tif (!memcmp (\"\\x1a\\x2b\\xb2\\xa1\", b + 8, 4)) {\n\t\tmagicCombo++;\n\t}\n\tif (magicCombo != 2) {\n\t\t// hack for C22F7494\n\t\tavailable = r_buf_read_at (buf, off - 8, b, size);\n\t\tif (available != size) {\n\t\t\teprintf (\"Warning: r_buf_read_at failed\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!memcmp (\"\\x1a\\x2b\\xb2\\xa1\", b, 4)) { // 0x130  ?\n\t\t\toff -= 8;\n\t\t} else {\n\t\t\teprintf (\"0x%08x  parsing error: invalid magic retry\\n\", off);\n\t\t}\n\t}\n\tD eprintf (\"0x%08x  magic  OK\\n\", off);\n\tD {\n\t\tconst int e0ss = r_read_le32 (b + 12);\n\t\teprintf (\"0x%08x  eoss   0x%x\\n\", off + 12, e0ss);\n\t}\n\tfree (b);\n\treturn r_coresym_cache_element_new (bf, buf, off + 16, bits, file_name);\n}\n\nstatic bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {\n#if 0\n\tSYMBOLS HEADER\n\n 0\tMAGIC\t02ff01ff\n 4\tVERSION 1 (little endian)\n 8      ffffffff\n16      002b0000 01000000 { 0x2b00, 0x0000 }\n24\tUUID    16 bytes\n40\t2621 d85b 2100 2000 0000 0000 0000 0000\n56\tffff ffff ffff ff7f 0c00 0000 0900 0000\n72\t0400 0000 6800 0000 2f76 6172 2f66 6f6c .... 4, 104 /// 104 length string\n184\n0x000000b8  5f5f 5445 5854 0000 0000 0000 0000 0000 0000 0000 0000 0000 0080 0000 0000 0000  __TEXT..........................\n0x000000d8  5f5f 4441 5441 0000 0000 0000 0000 0000 0080 0000 0000 0000 0040 0000 0000 0000  __DATA...................@......\n0x000000f8  5f5f 4c4c 564d 0000 0000 0000 0000 0000 00c0 0000 0000 0000 0000 0100 0000 0000  __LLVM..........................\n0x00000118  5f5f 4c49 4e4b 4544 4954 0000 0000 0000 00c0 0100 0000 0000 00c0 0000 0000 0000  __LINKEDIT......................\n\n#endif\n\t// 0 - magic check, version ...\n\tSymbolsHeader sh = parseHeader (buf);\n\tif (!sh.valid) {\n\t\teprintf (\"Invalid headers\\n\");\n\t\treturn false;\n\t}\n\tSymbolsMetadata sm = parseMetadata (buf, 0x40);\n\tchar * file_name = NULL;\n\tif (sm.namelen) {\n\t\tfile_name = calloc (sm.namelen + 1, 1);\n\t\tif (!file_name) {\n\t\t\treturn false;\n\t\t}\n\t\tif (r_buf_read_at (buf, 0x50, (ut8*)file_name, sm.namelen) != sm.namelen) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tRCoreSymCacheElement *element = parseDragons (bf, buf, sm.addr + sm.size, sm.bits, file_name);\n\tif (element) {\n\t\t*bin_obj = element;\n\t\treturn true;\n\t}\n\tfree (file_name);\n\treturn false;\n}\n\nstatic RList *sections(RBinFile *bf) {\n\tRList *res = r_list_newf ((RListFree)r_bin_section_free);\n\tr_return_val_if_fail (res && bf->o && bf->o->bin_obj, res);\n\tRCoreSymCacheElement *element = bf->o->bin_obj;\n\tsize_t i;\n\tif (element->segments) {\n\t\tfor (i = 0; i < element->hdr->n_segments; i++) {\n\t\t\tRCoreSymCacheElementSegment *seg = &element->segments[i];\n\t\t\tRBinSection *s = bin_section_from_segment (seg);\n\t\t\tif (s) {\n\t\t\t\tr_list_append (res, s);\n\t\t\t}\n\t\t}\n\t}\n\tif (element->sections) {\n\t\tfor (i = 0; i < element->hdr->n_sections; i++) {\n\t\t\tRCoreSymCacheElementSection *sect = &element->sections[i];\n\t\t\tRBinSection *s = bin_section_from_section (sect);\n\t\t\tif (s) {\n\t\t\t\tr_list_append (res, s);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nstatic ut64 baddr(RBinFile *bf) {\n\treturn 0LL;\n}\n\nstatic RBinInfo *info(RBinFile *bf) {\n\tSymbolsMetadata sm = parseMetadata (bf->buf, 0x40);\n\tRBinInfo *ret = R_NEW0 (RBinInfo);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->file = strdup (bf->file);\n\tret->bclass = strdup (\"symbols\");\n\tret->os = strdup (\"unknown\");\n\tret->arch = sm.arch ? strdup (sm.arch) : NULL;\n\tret->bits = sm.bits;\n\tret->type = strdup (\"Symbols file\");\n\tret->subsystem = strdup (\"llvm\");\n\tret->has_va = true;\n\n\treturn ret;\n}\n\nstatic bool check_buffer(RBinFile *bf, RBuffer *b) {\n\tut8 buf[4];\n\tr_buf_read_at (b, 0, buf, sizeof (buf));\n\treturn !memcmp (buf, \"\\x02\\xff\\x01\\xff\", 4);\n}\n\nstatic RList *symbols(RBinFile *bf) {\n\tRList *res = r_list_newf ((RListFree)r_bin_symbol_free);\n\tr_return_val_if_fail (res && bf->o && bf->o->bin_obj, res);\n\tRCoreSymCacheElement *element = bf->o->bin_obj;\n\tsize_t i;\n\tHtUU *hash = ht_uu_new0 ();\n\tif (!hash) {\n\t\treturn res;\n\t}\n\tbool found = false;\n\tfor (i = 0; i < element->hdr->n_lined_symbols; i++) {\n\t\tRCoreSymCacheElementSymbol *sym = (RCoreSymCacheElementSymbol *)&element->lined_symbols[i];\n\t\tht_uu_find (hash, sym->paddr, &found);\n\t\tif (found) {\n\t\t\tcontinue;\n\t\t}\n\t\tRBinSymbol *s = bin_symbol_from_symbol (element, sym);\n\t\tif (s) {\n\t\t\tr_list_append (res, s);\n\t\t\tht_uu_insert (hash, sym->paddr, 1);\n\t\t}\n\t}\n\tif (element->symbols) {\n\t\tfor (i = 0; i < element->hdr->n_symbols; i++) {\n\t\t\tRCoreSymCacheElementSymbol *sym = &element->symbols[i];\n\t\t\tht_uu_find (hash, sym->paddr, &found);\n\t\t\tif (found) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRBinSymbol *s = bin_symbol_from_symbol (element, sym);\n\t\t\tif (s) {\n\t\t\t\tr_list_append (res, s);\n\t\t\t}\n\t\t}\n\t}\n\tht_uu_free (hash);\n\treturn res;\n}\n\nstatic ut64 size(RBinFile *bf) {\n\treturn UT64_MAX;\n}\n\nstatic void destroy(RBinFile *bf) {\n\tr_coresym_cache_element_free (bf->o->bin_obj);\n}\n\nstatic void header(RBinFile *bf) {\n\tr_return_if_fail (bf && bf->o);\n\n\tRCoreSymCacheElement *element = bf->o->bin_obj;\n\tif (!element) {\n\t\treturn;\n\t}\n\n\tRBin *bin = bf->rbin;\n\tPrintfCallback p = bin->cb_printf;\n\tPJ *pj = pj_new ();\n\tif (!pj) {\n\t\treturn;\n\t}\n\n\tpj_o (pj);\n\tpj_kn (pj, \"cs_version\", element->hdr->version);\n\tpj_kn (pj, \"size\", element->hdr->size);\n\tif (element->file_name) {\n\t\tpj_ks (pj, \"name\", element->file_name);\n\t}\n\tif (element->binary_version) {\n\t\tpj_ks (pj, \"version\", element->binary_version);\n\t}\n\tchar uuidstr[R_UUID_LENGTH];\n\tr_hex_bin2str (element->hdr->uuid, 16, uuidstr);\n\tpj_ks (pj, \"uuid\", uuidstr);\n\tpj_kn (pj, \"segments\", element->hdr->n_segments);\n\tpj_kn (pj, \"sections\", element->hdr->n_sections);\n\tpj_kn (pj, \"symbols\", element->hdr->n_symbols);\n\tpj_kn (pj, \"lined_symbols\", element->hdr->n_lined_symbols);\n\tpj_kn (pj, \"line_info\", element->hdr->n_line_info);\n\tpj_end (pj);\n\n\tp (\"%s\\n\", pj_string (pj));\n\tpj_free (pj);\n}\n\nRBinPlugin r_bin_plugin_symbols = {\n\t.name = \"symbols\",\n\t.desc = \"Apple Symbols file\",\n\t.license = \"MIT\",\n\t.load_buffer = &load_buffer,\n\t.check_buffer = &check_buffer,\n\t.symbols = &symbols,\n\t.sections = &sections,\n\t.size = &size,\n\t.baddr = &baddr,\n\t.info = &info,\n\t.header = &header,\n\t.destroy = &destroy,\n};\n\n#ifndef R2_PLUGIN_INCORE\nR_API RLibStruct radare_plugin = {\n\t.type = R_LIB_TYPE_BIN,\n\t.data = &r_bin_plugin_symbols,\n\t.version = R2_VERSION\n};\n#endif\n"], "fixing_code": ["/* radare - LGPL - Copyright 2018-2022 - pancake */\n\n#include <r_types.h>\n#include <r_util.h>\n#include <r_lib.h>\n#include <r_bin.h>\n#include <ht_uu.h>\n#include \"../i/private.h\"\n#include \"mach0/coresymbolication.h\"\n\n// enable debugging messages\n#define D if (0)\n#define R_UUID_LENGTH 33\n\ntypedef struct symbols_header_t {\n\tut32 magic;\n\tut32 version;\n\tut8 uuid[16];\n\tut32 unk0;\n\tut32 unk1;\n\tut32 slotsize;\n\tut32 addr;\n\tbool valid;\n\tint size;\n} SymbolsHeader;\n\ntypedef struct symbols_metadata_t { // 0x40\n\tut32 cputype;\n\tut32 subtype;\n\tut32 n_segments;\n\tut32 namelen;\n\tut32 name;\n\tbool valid;\n\tut32 size;\n\t//RList *segments;\n\tut32 addr;\n\tint bits;\n\tconst char *arch;\n\tconst char *cpu;\n} SymbolsMetadata;\n\n// header starts at offset 0 and ends at offset 0x40\nstatic SymbolsHeader parseHeader(RBuffer *buf) {\n\tut8 b[64];\n\tSymbolsHeader sh = { 0 };\n\t(void)r_buf_read_at (buf, 0, b, sizeof (b));\n\tsh.magic = r_read_le32 (b);\n\tsh.version = r_read_le32 (b + 4);\n\tsh.valid = sh.magic == 0xff01ff02;\n\tint i;\n\tfor (i = 0; i < 16; i++) {\n\t\tsh.uuid[i] = b[24 + i];\n\t}\n\tsh.unk0 = r_read_le16 (b + 0x28);\n\tsh.unk1 = r_read_le16 (b + 0x2c); // is slotsize + 1 :?\n\tsh.slotsize = r_read_le16 (b + 0x2e);\n\tsh.size = 0x40;\n\treturn sh;\n}\n\nstatic const char *typeString(ut32 n, int *bits) {\n\t*bits = 32;\n\tif (n == 12) { // CPU_SUBTYPE_ARM_V7) {\n\t\treturn \"arm\";\n\t}\n\tif (n == 0x0100000c) { // arm64\n\t\t*bits = 64;\n\t\treturn \"arm\";\n\t}\n\tif (n == 0x0200000c) { // arm64-32\n\t\t//  TODO: must change bits\n\t\t*bits = 64;\n\t\treturn \"arm\";\n\t}\n\treturn \"x86\";\n}\n\nstatic const char *subtypeString(int n) {\n\tif (n == 9) { // CPU_SUBTYPE_ARM_V7) {\n\t\treturn \"armv7\";\n\t}\n\treturn \"?\";\n}\n\n// metadata section starts at offset 0x40 and ends around 0xb0 depending on filenamelength\nstatic SymbolsMetadata parseMetadata(RBuffer *buf, int off) {\n\tSymbolsMetadata sm = { 0 };\n\tut8 b[0x100] = { 0 };\n\t(void)r_buf_read_at (buf, off, b, sizeof (b));\n\tsm.addr = off;\n\tsm.cputype = r_read_le32 (b);\n\tsm.arch = typeString (sm.cputype, &sm.bits);\n\t//  eprintf (\"0x%08x  cputype  0x%x -> %s\\n\", 0x40, sm.cputype, typeString (sm.cputype));\n\t// bits = (strstr (typeString (sm.cputype, &sm.bits), \"64\"))? 64: 32;\n\tsm.subtype = r_read_le32 (b + 4);\n\tsm.cpu = subtypeString (sm.subtype);\n\t//  eprintf (\"0x%08x  subtype  0x%x -> %s\\n\", 0x44, sm.subtype, subtypeString (sm.subtype));\n\tsm.n_segments = r_read_le32 (b + 8);\n\t// int count = r_read_le32 (b + 0x48);\n\tsm.namelen = r_read_le32 (b + 0xc);\n\t// eprintf (\"0x%08x  count    %d\\n\", 0x48, count);\n\t// eprintf (\"0x%08x  strlen   %d\\n\", 0x4c, sm.namelen);\n\t// eprintf (\"0x%08x  filename %s\\n\", 0x50, b + 16);\n\tint delta = 16;\n\t//sm.segments = parseSegments (buf, off + sm.namelen + delta, sm.n_segments);\n\tsm.size = (sm.n_segments * 32) + sm.namelen + delta;\n\n\t// hack to detect format\n\tut32 nm, nm2, nm3;\n\tr_buf_read_at (buf, off + sm.size, (ut8 *)&nm, sizeof (nm));\n\tr_buf_read_at (buf, off + sm.size + 4, (ut8 *)&nm2, sizeof (nm2));\n\tr_buf_read_at (buf, off + sm.size + 8, (ut8 *)&nm3, sizeof (nm3));\n\t// eprintf (\"0x%x next %x %x %x\\n\", off + sm.size, nm, nm2, nm3);\n\tif (r_read_le32 (&nm3) != 0xa1b22b1a) {\n\t\tsm.size -= 8;\n\t\t//\t\tis64 = true;\n\t}\n\treturn sm;\n}\n\nstatic RBinSection *bin_section_from_section(RCoreSymCacheElementSection *sect) {\n\tif (!sect->name) {\n\t\treturn NULL;\n\t}\n\tRBinSection *s = R_NEW0 (RBinSection);\n\tif (!s) {\n\t\treturn NULL;\n\t}\n\ts->name = r_str_ndup (sect->name, 256);\n\ts->size = sect->size;\n\ts->vsize = s->size;\n\ts->paddr = sect->paddr;\n\ts->vaddr = sect->vaddr;\n\ts->add = true;\n\ts->perm = strstr (s->name, \"TEXT\") ? 5 : 4;\n\ts->is_segment = false;\n\treturn s;\n}\n\nstatic RBinSection *bin_section_from_segment(RCoreSymCacheElementSegment *seg) {\n\tif (!seg->name) {\n\t\treturn NULL;\n\t}\n\tRBinSection *s = R_NEW0 (RBinSection);\n\tif (!s) {\n\t\treturn NULL;\n\t}\n\ts->name = r_str_ndup (seg->name, 16);\n\ts->size = seg->size;\n\ts->vsize = seg->vsize;\n\ts->paddr = seg->paddr;\n\ts->vaddr = seg->vaddr;\n\ts->add = true;\n\ts->perm = strstr (s->name, \"TEXT\") ? 5 : 4;\n\ts->is_segment = true;\n\treturn s;\n}\n\nstatic RBinSymbol *bin_symbol_from_symbol(RCoreSymCacheElement *element, RCoreSymCacheElementSymbol *s) {\n\tif (!s->name && !s->mangled_name) {\n\t\treturn NULL;\n\t}\n\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\tif (sym) {\n\t\tif (s->name && s->mangled_name) {\n\t\t\tsym->dname = strdup (s->name);\n\t\t\tsym->name = strdup (s->mangled_name);\n\t\t} else if (s->name) {\n\t\t\tsym->name = strdup (s->name);\n\t\t} else if (s->mangled_name) {\n\t\t\tsym->name = s->mangled_name;\n\t\t}\n\t\tsym->paddr = s->paddr;\n\t\tsym->vaddr = r_coresym_cache_element_pa2va (element, s->paddr);\n\t\tsym->size = s->size;\n\t\tsym->type = R_BIN_TYPE_FUNC_STR;\n\t\tsym->bind = \"NONE\";\n\t}\n\treturn sym;\n}\n\nstatic RCoreSymCacheElement *parseDragons(RBinFile *bf, RBuffer *buf, int off, int bits, R_OWN char *file_name) {\n\tD eprintf (\"Dragons at 0x%x\\n\", off);\n\tut64 size = r_buf_size (buf);\n\tif (off >= size) {\n\t\treturn NULL;\n\t}\n\tsize -= off;\n\tif (!size) {\n\t\treturn NULL;\n\t}\n\tut8 *b = malloc (size);\n\tif (!b) {\n\t\treturn NULL;\n\t}\n\tint available = r_buf_read_at (buf, off, b, size);\n\tif (available != size) {\n\t\teprintf (\"Warning: r_buf_read_at failed\\n\");\n\t\treturn NULL;\n\t}\n#if 0\n\t// after the list of sections, there's a bunch of unknown\n\t// data, brobably dwords, and then the same section list again\n\t// this function aims to parse it.\n\t0x00000138 |1a2b b2a1 0300 0000 1a2b b2a1 e055 0000| .+.......+...U..\n                         n_segments ----.          .--- how many sections ?\n\t0x00000148 |0100 0000 ca55 0000 0400 0000 1800 0000| .....U..........\n\t             .---- how many symbols? 0xc7\n\t0x00000158 |c700 0000 0000 0000 0000 0000 0104 0000| ................\n\t0x00000168 |250b e803 0000 0100 0000 0000 bd55 0000| %............U..\n\t0x00000178 |91bb e903 e35a b42c 93a4 340a 8746 9489| .....Z.,..4..F..\n\t0x00000188 |0cea 4c40 0c00 0000 0900 0000 0000 0000| ..L@............\n\t0x00000198 |0000 0000 0000 0000 0000 0000 0000 0000| ................\n\t0x000001a8 |0080 0000 0000 0000 5f5f 5445 5854 0000| ........__TEXT..\n\t0x000001b8 |0000 0000 0000 0000 0080 0000 0000 0000| ................\n\t0x000001c8 |0040 0000 0000 0000 5f5f 4441 5441 0000| .@......__DATA..\n\t0x000001d8 |0000 0000 0000 0000 00c0 0000 0000 0000| ................\n\t0x000001e8 |0000 0100 0000 0000 5f5f 4c4c 564d 0000| ........__LLVM..\n\t0x000001f8 |0000 0000 0000 0000 00c0 0100 0000 0000| ................\n\t0x00000208 |00c0 0000 0000 0000 5f5f 4c49 4e4b 4544| ........__LINKED\n\t0x00000218 |4954 0000 0000 0000 0000 0000 d069 0000| IT...........i..\n#endif\n\t// eprintf (\"Dragon's magic:\\n\");\n\tint magicCombo = 0;\n\tif (!memcmp (\"\\x1a\\x2b\\xb2\\xa1\", b, 4)) { // 0x130  ?\n\t\tmagicCombo++;\n\t}\n\tif (!memcmp (\"\\x1a\\x2b\\xb2\\xa1\", b + 8, 4)) {\n\t\tmagicCombo++;\n\t}\n\tif (magicCombo != 2) {\n\t\t// hack for C22F7494\n\t\tavailable = r_buf_read_at (buf, off - 8, b, size);\n\t\tif (available != size) {\n\t\t\teprintf (\"Warning: r_buf_read_at failed\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!memcmp (\"\\x1a\\x2b\\xb2\\xa1\", b, 4)) { // 0x130  ?\n\t\t\toff -= 8;\n\t\t} else {\n\t\t\teprintf (\"0x%08x  parsing error: invalid magic retry\\n\", off);\n\t\t}\n\t}\n\tD eprintf (\"0x%08x  magic  OK\\n\", off);\n\tD {\n\t\tconst int e0ss = r_read_le32 (b + 12);\n\t\teprintf (\"0x%08x  eoss   0x%x\\n\", off + 12, e0ss);\n\t}\n\tfree (b);\n\treturn r_coresym_cache_element_new (bf, buf, off + 16, bits, file_name);\n}\n\nstatic bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {\n#if 0\n\tSYMBOLS HEADER\n\n 0\tMAGIC\t02ff01ff\n 4\tVERSION 1 (little endian)\n 8      ffffffff\n16      002b0000 01000000 { 0x2b00, 0x0000 }\n24\tUUID    16 bytes\n40\t2621 d85b 2100 2000 0000 0000 0000 0000\n56\tffff ffff ffff ff7f 0c00 0000 0900 0000\n72\t0400 0000 6800 0000 2f76 6172 2f66 6f6c .... 4, 104 /// 104 length string\n184\n0x000000b8  5f5f 5445 5854 0000 0000 0000 0000 0000 0000 0000 0000 0000 0080 0000 0000 0000  __TEXT..........................\n0x000000d8  5f5f 4441 5441 0000 0000 0000 0000 0000 0080 0000 0000 0000 0040 0000 0000 0000  __DATA...................@......\n0x000000f8  5f5f 4c4c 564d 0000 0000 0000 0000 0000 00c0 0000 0000 0000 0000 0100 0000 0000  __LLVM..........................\n0x00000118  5f5f 4c49 4e4b 4544 4954 0000 0000 0000 00c0 0100 0000 0000 00c0 0000 0000 0000  __LINKEDIT......................\n\n#endif\n\t// 0 - magic check, version ...\n\tSymbolsHeader sh = parseHeader (buf);\n\tif (!sh.valid) {\n\t\teprintf (\"Invalid headers\\n\");\n\t\treturn false;\n\t}\n\tSymbolsMetadata sm = parseMetadata (buf, 0x40);\n\tchar * file_name = NULL;\n\tif (sm.namelen) {\n\t\tfile_name = calloc (sm.namelen + 1, 1);\n\t\tif (!file_name) {\n\t\t\treturn false;\n\t\t}\n\t\tif (r_buf_read_at (buf, 0x50, (ut8*)file_name, sm.namelen) != sm.namelen) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tRCoreSymCacheElement *element = parseDragons (bf, buf, sm.addr + sm.size, sm.bits, file_name);\n\tif (element) {\n\t\t*bin_obj = element;\n\t\treturn true;\n\t}\n\tfree (file_name);\n\treturn false;\n}\n\nstatic RList *sections(RBinFile *bf) {\n\tRList *res = r_list_newf ((RListFree)r_bin_section_free);\n\tr_return_val_if_fail (res && bf->o && bf->o->bin_obj, res);\n\tRCoreSymCacheElement *element = bf->o->bin_obj;\n\tsize_t i;\n\tif (element->segments) {\n\t\tfor (i = 0; i < element->hdr->n_segments; i++) {\n\t\t\tRCoreSymCacheElementSegment *seg = &element->segments[i];\n\t\t\tRBinSection *s = bin_section_from_segment (seg);\n\t\t\tif (s) {\n\t\t\t\tr_list_append (res, s);\n\t\t\t}\n\t\t}\n\t}\n\tif (element->sections) {\n\t\tfor (i = 0; i < element->hdr->n_sections; i++) {\n\t\t\tRCoreSymCacheElementSection *sect = &element->sections[i];\n\t\t\tRBinSection *s = bin_section_from_section (sect);\n\t\t\tif (s) {\n\t\t\t\tr_list_append (res, s);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nstatic ut64 baddr(RBinFile *bf) {\n\treturn 0LL;\n}\n\nstatic RBinInfo *info(RBinFile *bf) {\n\tSymbolsMetadata sm = parseMetadata (bf->buf, 0x40);\n\tRBinInfo *ret = R_NEW0 (RBinInfo);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->file = strdup (bf->file);\n\tret->bclass = strdup (\"symbols\");\n\tret->os = strdup (\"unknown\");\n\tret->arch = sm.arch ? strdup (sm.arch) : NULL;\n\tret->bits = sm.bits;\n\tret->type = strdup (\"Symbols file\");\n\tret->subsystem = strdup (\"llvm\");\n\tret->has_va = true;\n\n\treturn ret;\n}\n\nstatic bool check_buffer(RBinFile *bf, RBuffer *b) {\n\tut8 buf[4];\n\tr_buf_read_at (b, 0, buf, sizeof (buf));\n\treturn !memcmp (buf, \"\\x02\\xff\\x01\\xff\", 4);\n}\n\nstatic RList *symbols(RBinFile *bf) {\n\tRList *res = r_list_newf ((RListFree)r_bin_symbol_free);\n\tr_return_val_if_fail (res && bf->o && bf->o->bin_obj, res);\n\tRCoreSymCacheElement *element = bf->o->bin_obj;\n\tsize_t i;\n\tHtUU *hash = ht_uu_new0 ();\n\tif (!hash) {\n\t\treturn res;\n\t}\n\tbool found = false;\n\tfor (i = 0; i < element->hdr->n_lined_symbols; i++) {\n\t\tRCoreSymCacheElementSymbol *sym = (RCoreSymCacheElementSymbol *)&element->lined_symbols[i];\n\t\tif (!sym) {\n\t\t\tbreak;\n\t\t}\n\t\tht_uu_find (hash, sym->paddr, &found);\n\t\tif (found) {\n\t\t\tcontinue;\n\t\t}\n\t\tRBinSymbol *s = bin_symbol_from_symbol (element, sym);\n\t\tif (s) {\n\t\t\tr_list_append (res, s);\n\t\t\tht_uu_insert (hash, sym->paddr, 1);\n\t\t}\n\t}\n\tif (element->symbols) {\n\t\tfor (i = 0; i < element->hdr->n_symbols; i++) {\n\t\t\tRCoreSymCacheElementSymbol *sym = &element->symbols[i];\n\t\t\tht_uu_find (hash, sym->paddr, &found);\n\t\t\tif (found) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRBinSymbol *s = bin_symbol_from_symbol (element, sym);\n\t\t\tif (s) {\n\t\t\t\tr_list_append (res, s);\n\t\t\t}\n\t\t}\n\t}\n\tht_uu_free (hash);\n\treturn res;\n}\n\nstatic ut64 size(RBinFile *bf) {\n\treturn UT64_MAX;\n}\n\nstatic void destroy(RBinFile *bf) {\n\tr_coresym_cache_element_free (bf->o->bin_obj);\n}\n\nstatic void header(RBinFile *bf) {\n\tr_return_if_fail (bf && bf->o);\n\n\tRCoreSymCacheElement *element = bf->o->bin_obj;\n\tif (!element) {\n\t\treturn;\n\t}\n\n\tRBin *bin = bf->rbin;\n\tPrintfCallback p = bin->cb_printf;\n\tPJ *pj = pj_new ();\n\tif (!pj) {\n\t\treturn;\n\t}\n\n\tpj_o (pj);\n\tpj_kn (pj, \"cs_version\", element->hdr->version);\n\tpj_kn (pj, \"size\", element->hdr->size);\n\tif (element->file_name) {\n\t\tpj_ks (pj, \"name\", element->file_name);\n\t}\n\tif (element->binary_version) {\n\t\tpj_ks (pj, \"version\", element->binary_version);\n\t}\n\tchar uuidstr[R_UUID_LENGTH];\n\tr_hex_bin2str (element->hdr->uuid, 16, uuidstr);\n\tpj_ks (pj, \"uuid\", uuidstr);\n\tpj_kn (pj, \"segments\", element->hdr->n_segments);\n\tpj_kn (pj, \"sections\", element->hdr->n_sections);\n\tpj_kn (pj, \"symbols\", element->hdr->n_symbols);\n\tpj_kn (pj, \"lined_symbols\", element->hdr->n_lined_symbols);\n\tpj_kn (pj, \"line_info\", element->hdr->n_line_info);\n\tpj_end (pj);\n\n\tp (\"%s\\n\", pj_string (pj));\n\tpj_free (pj);\n}\n\nRBinPlugin r_bin_plugin_symbols = {\n\t.name = \"symbols\",\n\t.desc = \"Apple Symbols file\",\n\t.license = \"MIT\",\n\t.load_buffer = &load_buffer,\n\t.check_buffer = &check_buffer,\n\t.symbols = &symbols,\n\t.sections = &sections,\n\t.size = &size,\n\t.baddr = &baddr,\n\t.info = &info,\n\t.header = &header,\n\t.destroy = &destroy,\n};\n\n#ifndef R2_PLUGIN_INCORE\nR_API RLibStruct radare_plugin = {\n\t.type = R_LIB_TYPE_BIN,\n\t.data = &r_bin_plugin_symbols,\n\t.version = R2_VERSION\n};\n#endif\n"], "filenames": ["libr/bin/p/bin_symbols.c"], "buggy_code_start_loc": [1], "buggy_code_end_loc": [363], "fixing_code_start_loc": [1], "fixing_code_end_loc": [367], "type": "CWE-476", "message": "NULL Pointer Dereference in GitHub repository radareorg/radare2 prior to 5.6.4.", "other": {"cve": {"id": "CVE-2022-0712", "sourceIdentifier": "security@huntr.dev", "published": "2022-02-22T18:15:12.487", "lastModified": "2022-04-08T13:53:57.093", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "NULL Pointer Dereference in GitHub repository radareorg/radare2 prior to 5.6.4."}, {"lang": "es", "value": "Una Desreferencia de puntero NULL en el repositorio de GitHub radareorg/radare2 versiones anteriores a 5.6.4"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.5, "impactScore": 3.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.1}, "baseSeverity": "HIGH", "exploitabilityScore": 8.6, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.6.4", "matchCriteriaId": "257C5522-E8C9-42F8-8891-50EDBDD3E873"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}], "references": [{"url": "https://github.com/radareorg/radare2/commit/515e592b9bea0612bc63d8e93239ff35bcf645c7", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/1e572820-e502-49d1-af0e-81833e2eb466", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/BZTIMAS53YT66FUS4QHQAFRJOBMUFG6D/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/E6YBRQ3UCFWJVSOYIKPVUDASZ544TFND/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/radareorg/radare2/commit/515e592b9bea0612bc63d8e93239ff35bcf645c7"}}