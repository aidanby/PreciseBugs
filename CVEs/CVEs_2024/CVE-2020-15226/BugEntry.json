{"buggy_code": ["<?php\n\n/**\n * ---------------------------------------------------------------------\n * GLPI - Gestionnaire Libre de Parc Informatique\n * Copyright (C) 2015-2020 Teclib' and contributors.\n *\n * http://glpi-project.org\n *\n * based on GLPI - Gestionnaire Libre de Parc Informatique\n * Copyright (C) 2003-2014 by the INDEPNET Development Team.\n *\n * ---------------------------------------------------------------------\n *\n * LICENSE\n *\n * This file is part of GLPI.\n *\n * GLPI is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * GLPI is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with GLPI. If not, see <http://www.gnu.org/licenses/>.\n * ---------------------------------------------------------------------\n */\n\n/**\n * @since 9.1\n */\n\nnamespace Glpi\\Api;\n\nuse APIClient;\nuse Auth;\nuse Change;\nuse CommonDevice;\nuse CommonGLPI;\nuse CommonITILObject;\nuse Config;\nuse Contract;\nuse Document;\nuse Dropdown;\nuse Glpi\\Exception\\ForgetPasswordException;\nuse Glpi\\Exception\\PasswordTooWeakException;\nuse Html;\nuse Infocom;\nuse Item_Devices;\nuse Log;\nuse Michelf\\MarkdownExtra;\nuse NetworkEquipment;\nuse NetworkPort;\nuse Notepad;\nuse Problem;\nuse QueryExpression;\nuse SavedSearch;\nuse Search;\nuse Session;\nuse Software;\nuse Ticket;\nuse Toolbox;\nuse User;\n\nabstract class API extends CommonGLPI {\n\n   // permit writing to $_SESSION\n   protected $session_write = false;\n\n   static $api_url = \"\";\n   static $content_type = \"application/json\";\n   protected $format;\n   protected $iptxt         = \"\";\n   protected $ipnum         = \"\";\n   protected $app_tokens    = [];\n   protected $apiclients_id = 0;\n   protected $deprecated_item = null;\n\n   /**\n    * First function used on api call\n    * Parse sended query/parameters and call the corresponding API::method\n    *\n    * @return void self::returnResponse called for output\n    */\n   abstract public function call();\n\n   /**\n    * Needed to transform params of called api in $this->parameters attribute\n    *\n    * @return string endpoint called\n    */\n   abstract protected function parseIncomingParams();\n\n   /**\n    * Generic messages\n    *\n    * @since 9.1\n    *\n    * @param mixed   $response          string message or array of data to send\n    * @param integer $httpcode          http code (see : https://en.wikipedia.org/wiki/List_of_HTTP_status_codes)\n    * @param array   $additionalheaders headers to send with http response (must be an array(key => value))\n    *\n    * @return void\n    */\n   abstract protected function returnResponse($response, $httpcode = 200, $additionalheaders = []);\n\n   /**\n    * Upload and validate files from request and append to $this->parameters['input']\n    *\n    * @return void\n    */\n   abstract protected function manageUploadedFiles();\n\n   /**\n    * Constructor\n    *\n    * @var array $CFG_GLPI\n    * @var DBmysql $DB\n    *\n    * @return void\n    */\n   public function initApi() {\n      global $CFG_GLPI;\n\n      // Load GLPI configuration\n      include_once (GLPI_ROOT . '/inc/includes.php');\n      $variables = get_defined_vars();\n      foreach ($variables as $var => $value) {\n         if ($var === strtoupper($var)) {\n            $GLOBALS[$var] = $value;\n         }\n      }\n\n      // construct api url\n      self::$api_url = trim($CFG_GLPI['url_base_api'], \"/\");\n\n      // Don't display error in result\n      ini_set('display_errors', 'Off');\n\n      // Avoid keeping messages between api calls\n      $_SESSION[\"MESSAGE_AFTER_REDIRECT\"] = [];\n\n      // check if api is enabled\n      if (!$CFG_GLPI['enable_api']) {\n         $this->returnError(__(\"API disabled\"), \"\", \"\", false);\n         exit;\n      }\n\n      // retrieve ip of client\n      $this->iptxt = Toolbox::getRemoteIpAddress();\n      $this->ipnum = (strstr($this->iptxt, ':')===false ? ip2long($this->iptxt) : '');\n\n      // check ip access\n      $apiclient = new APIClient;\n      $where_ip = [];\n      if ($this->ipnum) {\n         $where_ip = [\n            'OR' => [\n               'ipv4_range_start' => null,\n               [\n                  'ipv4_range_start'   => ['<=', $this->ipnum],\n                  'ipv4_range_end'     => ['>=', $this->ipnum]\n               ]\n            ]\n         ];\n      } else {\n         $where_ip = [\n            'OR' => [\n               ['ipv6'  => null],\n               ['ipv6'  => $this->iptxt]\n            ]\n         ];\n      }\n      $found_clients = $apiclient->find(['is_active' => 1] + $where_ip);\n      if (count($found_clients) <= 0) {\n         $this->returnError(__(\"There isn't an active API client matching your IP address in the configuration\").\n                            \" (\".$this->iptxt.\")\",\n                            \"\", \"ERROR_NOT_ALLOWED_IP\", false);\n      }\n      $app_tokens = array_column($found_clients, 'app_token');\n      $apiclients_id = array_column($found_clients, 'id');\n      $this->app_tokens = array_combine($apiclients_id, $app_tokens);\n   }\n\n   /**\n    * Set headers according to cross origin ressource sharing\n    *\n    * @param string $verb Http verb (GET, POST, PUT, DELETE, OPTIONS)\n    *\n    * @return void\n    */\n   protected function cors($verb = 'GET') {\n      if (isset($_SERVER['HTTP_ORIGIN'])) {\n         header(\"Access-Control-Allow-Origin: *\");\n      }\n\n      if ($this->verb == 'GET' || $this->verb == 'OPTIONS') {\n         header(\"Access-Control-Expose-Headers: content-type, content-range, accept-range\");\n      }\n\n      if ($this->verb == \"OPTIONS\") {\n         if (isset($_SERVER['HTTP_ACCESS_CONTROL_REQUEST_METHOD'])) {\n            header(\"Access-Control-Allow-Methods: PUT, GET, POST, DELETE, OPTIONS\");\n         }\n\n         if (isset($_SERVER['HTTP_ACCESS_CONTROL_REQUEST_HEADERS'])) {\n            header(\"Access-Control-Allow-Headers: \".\n                   \"origin, content-type, accept, session-token, authorization\");\n         }\n         exit(0);\n      }\n   }\n\n\n   /**\n    * Init GLPI Session\n    *\n    * @param array $params array with theses options :\n    *    - a couple 'name' & 'password' : 2 parameters to login with user authentication\n    *         OR\n    *    - an 'user_token' defined in User Configuration\n    *\n    * @return array with session_token\n    */\n   protected function initSession($params = []) {\n      global $CFG_GLPI;\n\n      $this->checkAppToken();\n      $this->logEndpointUsage(__FUNCTION__);\n\n      if ((!isset($params['login'])\n           || empty($params['login'])\n           || !isset($params['password'])\n           || empty($params['password']))\n         && (!isset($params['user_token'])\n             || empty($params['user_token']))) {\n         $this->returnError(__(\"parameter(s) login, password or user_token are missing\"), 400,\n                            \"ERROR_LOGIN_PARAMETERS_MISSING\");\n      }\n\n      $auth = new Auth();\n\n      // fill missing params (in case of user_token)\n      if (!isset($params['login'])) {\n         $params['login'] = '';\n      }\n      if (!isset($params['password'])) {\n         $params['password'] = '';\n      }\n\n      $noAuto = true;\n      if (isset($params['user_token']) && !empty($params['user_token'])) {\n         $_REQUEST['user_token'] = $params['user_token'];\n         $noAuto = false;\n\n      } else if (!$CFG_GLPI['enable_api_login_credentials']) {\n         $this->returnError(__(\"usage of initSession resource with credentials is disabled\"), 400,\n                            \"ERROR_LOGIN_WITH_CREDENTIALS_DISABLED\", false);\n      }\n\n      if (!isset($params['auth'])) {\n         $params['auth'] = '';\n      }\n\n      // login on glpi\n      if (!$auth->login($params['login'], $params['password'], $noAuto, false, $params['auth'])) {\n         $err = Html::clean($auth->getErr());\n         if (isset($params['user_token'])\n             && !empty($params['user_token'])) {\n            return $this->returnError(__(\"parameter user_token seems invalid\"), 401, \"ERROR_GLPI_LOGIN_USER_TOKEN\", false);\n         }\n         return $this->returnError($err, 401, \"ERROR_GLPI_LOGIN\", false);\n      }\n\n      // stop session and return session key\n      session_write_close();\n      $data = ['session_token' => $_SESSION['valid_id']];\n\n      // Insert session data if requested\n      $get_full_session = $params['get_full_session'] ?? false;\n      if ($get_full_session) {\n         $data['session'] = $_SESSION;\n      }\n\n      return $data;\n   }\n\n\n   /**\n    * Kill GLPI Session\n    * Use 'session_token' param in $this->parameters\n    *\n    * @return boolean\n    */\n   protected function killSession() {\n\n      $this->initEndpoint(false, __FUNCTION__);\n      return Session::destroy();\n   }\n\n\n   /**\n    * Retrieve GLPI Session initialised by initSession function\n    * Use 'session_token' param in $this->parameters\n    *\n    * @return void\n    */\n   protected function retrieveSession() {\n\n      if (isset($this->parameters['session_token'])\n          && !empty($this->parameters['session_token'])) {\n         $current = session_id();\n         $session = trim($this->parameters['session_token']);\n\n         if (file_exists(GLPI_ROOT . '/inc/downstream.php')) {\n            include_once (GLPI_ROOT . '/inc/downstream.php');\n         }\n\n         if ($session!=$current && !empty($current)) {\n            session_destroy();\n         }\n         if ($session!=$current && !empty($session)) {\n            session_id($session);\n         }\n      }\n   }\n\n\n   /**\n    * Change active entity to the entities_id one.\n    *\n    * @param array $params array with theses options :\n    *   - 'entities_id': (default 'all') ID of the new active entity (\"all\" = load all possible entities). Optionnal\n    *   - 'is_recursive': (default false) Also display sub entities of the active entity.  Optionnal\n    *\n    * @return array|bool\n    */\n   protected function changeActiveEntities($params = []) {\n\n      $this->initEndpoint();\n\n      if (!isset($params['entities_id'])) {\n         $entities_id = 'all';\n      } else {\n         $entities_id = intval($params['entities_id']);\n      }\n\n      if (!isset($params['is_recursive'])) {\n         $params['is_recursive'] = false;\n      } else if (!is_bool($params['is_recursive'])) {\n         return $this->returnError();\n      }\n\n      if (!Session::changeActiveEntities($entities_id, $params['is_recursive'])) {\n         return $this->returnError();\n      }\n\n      return true;\n   }\n\n\n   /**\n    * Return all the possible entity of the current logged user (and for current active profile)\n    *\n    * @param array $params array with theses options :\n    *   - 'is_recursive': (default false) Also display sub entities of the active entity. Optionnal\n    *\n    * @return array of entities (with id and name)\n    */\n   protected function getMyEntities($params = []) {\n\n      $this->initEndpoint();\n\n      if (!isset($params['is_recursive'])) {\n         $params['is_recursive'] = false;\n      }\n\n      $myentities = [];\n      foreach ($_SESSION['glpiactiveprofile']['entities'] as $entity) {\n         if ($entity['is_recursive'] == 1 && $params['is_recursive'] == 1) {\n            $sons = getSonsOf('glpi_entities', $entity['id']);\n            foreach ($sons as $entity_id) {\n               if ($entity_id != $entity['id']) {\n                  $myentities[] = ['id'   => $entity_id,\n                                   'name' => Dropdown::getDropdownName(\"glpi_entities\",\n                                                                       $entity_id)];\n               }\n            }\n         }\n         $myentities[] = ['id' => $entity['id'],\n                          'name' => Dropdown::getDropdownName(\"glpi_entities\",\n                                                                   $entity['id'])];\n      }\n      return ['myentities' => $myentities];\n   }\n\n\n\n\n   /**\n    * return active entities of current logged user\n    *\n    * @return array with 3 keys :\n    *  - active_entity : current set entity\n    *  - active_entity_recursive : boolean, if we see sons of this entity\n    *  - active_entities : array all active entities (active_entity and its sons)\n    */\n   protected function getActiveEntities() {\n\n      $this->initEndpoint();\n\n      $actives_entities = [];\n      foreach (array_values($_SESSION['glpiactiveentities']) as $active_entity) {\n         $actives_entities[] = ['id' => $active_entity];\n      }\n\n      return [\"active_entity\" => [\n                     \"id\"                      => $_SESSION['glpiactive_entity'],\n                     \"active_entity_recursive\" => $_SESSION['glpiactive_entity_recursive'],\n                     \"active_entities\"         => $actives_entities]];\n\n   }\n\n\n\n\n   /**\n    * set a profile to active\n    *\n    * @param array $params with theses options :\n    *    - profiles_id : identifier of profile to set\n    *\n    * @return boolean\n    */\n   protected function changeActiveProfile($params = []) {\n\n      $this->initEndpoint();\n\n      if (!isset($params['profiles_id'])) {\n         $this->returnError();\n      }\n\n      $profiles_id = intval($params['profiles_id']);\n      if (isset($_SESSION['glpiprofiles'][$profiles_id])) {\n         return Session::changeProfile($profiles_id);\n      }\n\n      $this->messageNotfoundError();\n   }\n\n\n\n\n   /**\n    * Return all the profiles associated to logged user\n    *\n    * @return array of profiles (with associated rights)\n    */\n   protected function getMyProfiles() {\n\n      $this->initEndpoint();\n\n      $myprofiles = [];\n      foreach ($_SESSION['glpiprofiles'] as $profiles_id => $profile) {\n         // append if of the profile into values\n         $profile = ['id' => $profiles_id] + $profile;\n\n         // don't keep keys for entities\n         $profile['entities'] = array_values($profile['entities']);\n\n         // don't keep keys for profiles\n         $myprofiles[] = $profile;\n      }\n      return ['myprofiles' => $myprofiles];\n   }\n\n\n\n\n   /**\n    * Return the current active profile\n    *\n    * @return integer the profiles_id\n    */\n   protected function getActiveProfile() {\n\n      $this->initEndpoint();\n      return [\"active_profile\" => $_SESSION['glpiactiveprofile']];\n   }\n\n\n\n\n   /**\n    * Return the current php $_SESSION\n    *\n    * @return array\n    */\n   protected function getFullSession() {\n\n      $this->initEndpoint();\n      return ['session' => $_SESSION];\n   }\n\n\n\n   /**\n    * Return the current $CFG_GLPI\n    *\n    * @return array\n     */\n   protected function getGlpiConfig() {\n      $this->initEndpoint();\n\n      return ['cfg_glpi' => Config::getSafeConfig()];\n   }\n\n\n   /**\n    * Return the instance fields of itemtype identified by id\n    *\n    * @param string  $itemtype itemtype (class) of object\n    * @param integer $id       identifier of object\n    * @param array   $params   with theses options :\n    *    - 'expand_dropdowns': Show dropdown's names instead of id. default: false. Optionnal\n    *    - 'get_hateoas':      Show relation of current item in a links attribute. default: true. Optionnal\n    *    - 'get_sha1':         Get a sha1 signature instead of the full answer. default: false. Optionnal\n    *    - 'with_devices':  Only for [Computer, NetworkEquipment, Peripheral, Phone, Printer], Optionnal.\n    *    - 'with_disks':       Only for Computer, retrieve the associated filesystems. Optionnal.\n    *    - 'with_softwares':   Only for Computer, retrieve the associated softwares installations. Optionnal.\n    *    - 'with_connections': Only for Computer, retrieve the associated direct connections (like peripherals and printers) .Optionnal.\n    *    - 'with_networkports':Retrieve all network connections and advanced network informations. Optionnal.\n    *    - 'with_infocoms':    Retrieve financial and administrative informations. Optionnal.\n    *    - 'with_contracts':   Retrieve associated contracts. Optionnal.\n    *    - 'with_documents':   Retrieve associated external documents. Optionnal.\n    *    - 'with_tickets':     Retrieve associated itil tickets. Optionnal.\n    *    - 'with_problems':    Retrieve associated itil problems. Optionnal.\n    *    - 'with_changes':     Retrieve associated itil changes. Optionnal.\n    *    - 'with_notes':       Retrieve Notes (if exists, not all itemtypes have notes). Optionnal.\n    *    - 'with_logs':        Retrieve historical. Optionnal.\n    *    - 'add_keys_names':   Get friendly names. Optionnal.\n    *\n    * @return array    fields of found object\n    */\n   protected function getItem($itemtype, $id, $params = []) {\n      global $CFG_GLPI, $DB;\n\n      $this->initEndpoint();\n      $itemtype = $this->handleDepreciation($itemtype);\n\n      // default params\n      $default = ['expand_dropdowns'  => false,\n                       'get_hateoas'       => true,\n                       'get_sha1'          => false,\n                       'with_devices'   => false,\n                       'with_disks'        => false,\n                       'with_softwares'    => false,\n                       'with_connections'  => false,\n                       'with_networkports' => false,\n                       'with_infocoms'     => false,\n                       'with_contracts'    => false,\n                       'with_documents'    => false,\n                       'with_tickets'      => false,\n                       'with_problems'     => false,\n                       'with_changes'      => false,\n                       'with_notes'        => false,\n                       'with_logs'         => false,\n                       'add_keys_names'    => [],\n      ];\n      $params = array_merge($default, $params);\n\n      $item = new $itemtype;\n      if (!$item->getFromDB($id)) {\n         return $this->messageNotfoundError();\n      }\n      if (!$item->can($id, READ)) {\n         return $this->messageRightError();\n      }\n\n      $fields = $item->fields;\n\n      // avoid disclosure of critical fields\n      $item::unsetUndisclosedFields($fields);\n\n      // retrieve devices\n      if (isset($params['with_devices'])\n          && $params['with_devices']\n          && in_array($itemtype, Item_Devices::getConcernedItems())) {\n         $all_devices = [];\n         foreach (Item_Devices::getItemAffinities($item->getType()) as $device_type) {\n            $found_devices = getAllDataFromTable(\n               $device_type::getTable(), [\n                  'items_id'     => $item->getID(),\n                  'itemtype'     => $item->getType(),\n                  'is_deleted'   => 0\n               ],\n               true\n            );\n\n            foreach ($found_devices as &$device) {\n               unset($device['items_id']);\n               unset($device['itemtype']);\n               unset($device['is_deleted']);\n            }\n\n            if (!empty($found_devices)) {\n               $all_devices[$device_type] = $found_devices;\n            }\n         }\n         $fields['_devices'] = $all_devices;\n      }\n\n      // retrieve computer disks\n      if (isset($params['with_disks'])\n          && $params['with_disks']\n          && in_array($itemtype, $CFG_GLPI['itemdeviceharddrive_types'])) {\n         // build query to retrive filesystems\n         $fs_iterator = $DB->request([\n            'SELECT'    => [\n               'glpi_filesystems.name AS fsname',\n               'glpi_items_disks.*'\n            ],\n            'FROM'      => 'glpi_items_disks',\n            'LEFT JOIN'  => [\n               'glpi_filesystems' => [\n                  'ON' => [\n                     'glpi_items_disks'   => 'filesystems_id',\n                     'glpi_filesystems'   => 'id'\n                  ]\n               ]\n            ],\n            'WHERE'     => [\n               'items_id'     => $id,\n               'itemtype'     => $itemtype,\n               'is_deleted'   => 0\n            ]\n         ]);\n         $fields['_disks'] = [];\n         while ($data = $fs_iterator->next()) {\n            unset($data['items_id']);\n            unset($data['is_deleted']);\n            $fields['_disks'][] = ['name' => $data];\n         }\n      }\n\n      // retrieve computer softwares\n      if (isset($params['with_softwares'])\n            && $params['with_softwares']\n            && in_array($itemtype, $CFG_GLPI['software_types'])) {\n         $fields['_softwares'] = [];\n         if (!Software::canView()) {\n            $fields['_softwares'] = $this->arrayRightError();\n         } else {\n            $soft_iterator = $DB->request([\n               'SELECT'    => [\n                  'glpi_softwares.softwarecategories_id',\n                  'glpi_softwares.id AS softwares_id',\n                  'glpi_softwareversions.id AS softwareversions_id',\n                  'glpi_items_softwareversions.is_dynamic',\n                  'glpi_softwareversions.states_id',\n                  'glpi_softwares.is_valid'\n               ],\n               'FROM'      => 'glpi_items_softwareversions',\n               'LEFT JOIN' => [\n                  'glpi_softwareversions' => [\n                     'ON' => [\n                        'glpi_items_softwareversions' => 'softwareversions_id',\n                        'glpi_softwareversions'       => 'id'\n                     ]\n                  ],\n                  'glpi_softwares'        => [\n                     'ON' => [\n                        'glpi_softwareversions' => 'softwares_id',\n                        'glpi_softwares'        => 'id'\n                     ]\n                  ]\n               ],\n               'WHERE'     => [\n                  'glpi_items_softwareversions.items_id'   => $id,\n                  'glpi_items_softwareversions.itemtype'   => $itemtype,\n                  'glpi_items_softwareversions.is_deleted' => 0\n               ],\n               'ORDERBY'   => [\n                  'glpi_softwares.name',\n                  'glpi_softwareversions.name'\n               ]\n            ]);\n            while ($data = $soft_iterator->next()) {\n               $fields['_softwares'][] = $data;\n            }\n         }\n      }\n\n      // retrieve item connections\n      if (isset($params['with_connections'])\n          && $params['with_connections']\n          && $itemtype == \"Computer\") {\n         $fields['_connections'] = [];\n         foreach ($CFG_GLPI[\"directconnect_types\"] as $connect_type) {\n            $connect_item = new $connect_type();\n            if ($connect_item->canView()) {\n               $connect_table = getTableForItemType($connect_type);\n               $iterator = $DB->request([\n                  'SELECT'    => [\n                     'glpi_computers_items.id AS assoc_id',\n                     'glpi_computers_items.computers_id AS assoc_computers_id',\n                     'glpi_computers_items.itemtype AS assoc_itemtype',\n                     'glpi_computers_items.items_id AS assoc_items_id',\n                     'glpi_computers_items.is_dynamic AS assoc_is_dynamic',\n                     \"$connect_table.*\"\n                  ],\n                  'FROM'      => 'glpi_computers_items',\n                  'LEFT JOIN' => [\n                     $connect_table => [\n                        'ON' => [\n                           'glpi_computers_items'  => 'items_id',\n                           $connect_table          => 'id'\n                        ]\n                     ]\n                  ],\n                  'WHERE'     => [\n                     'computers_id'                      => $id,\n                     'itemtype'                          => $connect_type,\n                     'glpi_computers_items.is_deleted'   => 0\n                  ]\n               ]);\n               while ($data = $iterator->next()) {\n                  $fields['_connections'][$connect_type][] = $data;\n               }\n            }\n         }\n      }\n\n      // retrieve item networkports\n      if (isset($params['with_networkports'])\n          && $params['with_networkports']) {\n         $fields['_networkports'] = [];\n         if (!NetworkEquipment::canView()) {\n            $fields['_networkports'] = $this->arrayRightError();\n         } else {\n            foreach (NetworkPort::getNetworkPortInstantiations() as $networkport_type) {\n               $netport_table = $networkport_type::getTable();\n               $netp_iterator = $DB->request([\n                  'SELECT'    => [\n                     'netp.id AS netport_id',\n                     'netp.entities_id',\n                     'netp.is_recursive',\n                     'netp.logical_number',\n                     'netp.name',\n                     'netp.mac',\n                     'netp.comment',\n                     'netp.is_dynamic',\n                     'netp_subtable.*'\n                  ],\n                  'FROM'      => 'glpi_networkports AS netp',\n                  'LEFT JOIN' => [\n                     \"$netport_table AS netp_subtable\" => [\n                        'ON' => [\n                           'netp_subtable'   => 'networkports_id',\n                           'netp'            => 'id'\n                        ]\n                     ]\n                  ],\n                  'WHERE'     => [\n                     'netp.instantiation_type'  => $networkport_type,\n                     'netp.items_id'            => $id,\n                     'netp.itemtype'            => $itemtype,\n                     'netp.is_deleted'          => 0\n                  ]\n               ]);\n\n               while ($data = $netp_iterator->next()) {\n                  if (isset($data['netport_id'])) {\n                     // append network name\n                     $concat_expr = new QueryExpression(\n                        \"GROUP_CONCAT(CONCAT(\".$DB->quoteName('ipadr.id').\", \".$DB->quoteValue(Search::SHORTSEP).\" , \".$DB->quoteName('ipadr.name').\")\n                        SEPARATOR \".$DB->quoteValue(Search::LONGSEP).\") AS \".$DB->quoteName('ipadresses')\n                     );\n                     $netn_iterator = $DB->request([\n                        'SELECT'    => [\n                           $concat_expr,\n                           'netn.id AS networknames_id',\n                           'netn.name AS networkname',\n                           'netn.fqdns_id',\n                           'fqdn.name AS fqdn_name',\n                           'fqdn.fqdn'\n                        ],\n                        'FROM'      => [\n                           'glpi_networknames AS netn'\n                        ],\n                        'LEFT JOIN' => [\n                           'glpi_ipaddresses AS ipadr'               => [\n                              'ON' => [\n                                 'ipadr'  => 'items_id',\n                                 'netn'   => 'id',\n                                 [\n                                    'AND' => ['ipadr.itemtype' => 'NetworkName']\n                                 ]\n                              ]\n                           ],\n                           'glpi_fqdns AS fqdn'                      => [\n                              'ON' => [\n                                 'fqdn'   => 'id',\n                                 'netn'   => 'fqdns_id'\n                              ]\n                           ],\n                           'glpi_ipaddresses_ipnetworks AS ipadnet'  => [\n                              'ON' => [\n                                 'ipadnet'   => 'ipaddresses_id',\n                                 'ipadr'     => 'id'\n                              ]\n                           ],\n                           'glpi_ipnetworks AS ipnet'                => [\n                              'ON' => [\n                                 'ipnet'     => 'id',\n                                 'ipadnet'   => 'ipnetworks_id'\n                              ]\n                           ]\n                        ],\n                        'WHERE'     => [\n                           'netn.itemtype'   => 'NetworkPort',\n                           'netn.items_id'   => $data['netport_id']\n                        ],\n                        'GROUPBY'   => [\n                           'netn.id',\n                           'netn.name',\n                           'netn.fqdns_id',\n                           'fqdn.name',\n                           'fqdn.fqdn'\n                        ]\n                     ]);\n\n                     if (count($netn_iterator)) {\n                        $data_netn = $netn_iterator->next();\n\n                        $raw_ipadresses = explode(Search::LONGSEP, $data_netn['ipadresses']);\n                        $ipadresses = [];\n                        foreach ($raw_ipadresses as $ipadress) {\n                           $ipadress = explode(Search::SHORTSEP, $ipadress);\n\n                           //find ip network attached to these ip\n                           $ipnetworks = [];\n                           $ipnet_iterator = $DB->request([\n                              'SELECT'       => [\n                                 'ipnet.id',\n                                 'ipnet.completename',\n                                 'ipnet.name',\n                                 'ipnet.address',\n                                 'ipnet.netmask',\n                                 'ipnet.gateway',\n                                 'ipnet.ipnetworks_id',\n                                 'ipnet.comment'\n                              ],\n                              'FROM'         => 'glpi_ipnetworks AS ipnet',\n                              'INNER JOIN'   => [\n                                 'glpi_ipaddresses_ipnetworks AS ipadnet' => [\n                                    'ON' => [\n                                       'ipadnet'   => 'ipnetworks_id',\n                                       'ipnet'     => 'id'\n                                    ]\n                                 ]\n                              ],\n                              'WHERE'        => [\n                                 'ipadnet.ipaddresses_id'  => $ipadress[0]\n                              ]\n                           ]);\n                           while ($data_ipnet = $ipnet_iterator->next()) {\n                              $ipnetworks[] = $data_ipnet;\n                           }\n\n                           $ipadresses[] = [\n                              'id'        => $ipadress[0],\n                              'name'      => $ipadress[1],\n                              'IPNetwork' => $ipnetworks\n                           ];\n                        }\n\n                        $data['NetworkName'] = [\n                           'id'         => $data_netn['networknames_id'],\n                           'name'       => $data_netn['networkname'],\n                           'fqdns_id'   => $data_netn['fqdns_id'],\n                           'FQDN'       => [\n                              'id'   => $data_netn['fqdns_id'],\n                              'name' => $data_netn['fqdn_name'],\n                              'fqdn' => $data_netn['fqdn']\n                           ],\n                           'IPAddress' => $ipadresses\n                        ];\n                     }\n                  }\n\n                  $fields['_networkports'][$networkport_type][] = $data;\n               }\n            }\n         }\n      }\n\n      // retrieve item infocoms\n      if (isset($params['with_infocoms'])\n          && $params['with_infocoms']) {\n         $fields['_infocoms'] = [];\n         if (!Infocom::canView()) {\n            $fields['_infocoms'] = $this->arrayRightError();\n         } else {\n            $ic = new Infocom();\n            if ($ic->getFromDBforDevice($itemtype, $id)) {\n               $fields['_infocoms'] = $ic->fields;\n            }\n         }\n      }\n\n      // retrieve item contracts\n      if (isset($params['with_contracts'])\n          && $params['with_contracts']) {\n         $fields['_contracts'] = [];\n         if (!Contract::canView()) {\n            $fields['_contracts'] = $this->arrayRightError();\n         } else {\n            $iterator = $DB->request([\n               'SELECT'    => ['glpi_contracts_items.*'],\n               'FROM'      => 'glpi_contracts_items',\n               'LEFT JOIN' => [\n                  'glpi_contracts'  => [\n                     'ON' => [\n                        'glpi_contracts_items'  => 'contracts_id',\n                        'glpi_contracts'        => 'id'\n                     ]\n                  ],\n                  'glpi_entities'   => [\n                     'ON' => [\n                        'glpi_contracts_items'  => 'entities_id',\n                        'glpi_entities'         => 'id'\n                     ]\n                  ]\n               ],\n               'WHERE'     => [\n                  'glpi_contracts_items.items_id'  => $id,\n                  'glpi_contracts_items.itemtype'  => $itemtype\n               ] + getEntitiesRestrictCriteria('glpi_contracts', '', '', true),\n               'ORDERBY'   => 'glpi_contracts.name'\n            ]);\n            while ($data = $iterator->next()) {\n               $fields['_contracts'][] = $data;\n            }\n         }\n      }\n\n      // retrieve item documents\n      if (isset($params['with_documents'])\n          && $params['with_documents']) {\n         $fields['_documents'] = [];\n         if (!($item instanceof CommonITILObject)\n             && $itemtype != 'KnowbaseItem'\n             && $itemtype != 'Reminder'\n             && !Document::canView()) {\n            $fields['_documents'] = $this->arrayRightError();\n         } else {\n            $doc_criteria = [\n               'glpi_documents_items.items_id'  => $id,\n               'glpi_documents_items.itemtype'  => $itemtype\n            ];\n            if ($item instanceof CommonITILObject) {\n               $doc_criteria = [\n                  $item->getAssociatedDocumentsCriteria(),\n                  'timeline_position' => ['>', CommonITILObject::NO_TIMELINE], // skip inlined images\n               ];\n            }\n            $doc_iterator = $DB->request([\n               'SELECT'    => [\n                  'glpi_documents_items.id AS assocID',\n                  'glpi_documents_items.date_creation AS assocdate',\n                  'glpi_entities.id AS entityID',\n                  'glpi_entities.completename AS entity',\n                  'glpi_documentcategories.completename AS headings',\n                  'glpi_documents.*'\n               ],\n               'FROM'      => 'glpi_documents_items',\n               'LEFT JOIN' => [\n                  'glpi_documents'           => [\n                     'ON' => [\n                        'glpi_documents_items'  => 'documents_id',\n                        'glpi_documents'        => 'id'\n                     ]\n                  ],\n                  'glpi_entities'            => [\n                     'ON' => [\n                        'glpi_documents'  => 'entities_id',\n                        'glpi_entities'   => 'id'\n                     ]\n                  ],\n                  'glpi_documentcategories'  => [\n                     'ON' => [\n                        'glpi_documents'           => 'documentcategories_id',\n                        'glpi_documentcategories'  => 'id'\n                     ]\n                  ]\n               ],\n               'WHERE'     => $doc_criteria,\n            ]);\n            while ($data = $doc_iterator->next()) {\n               $fields['_documents'][] = $data;\n            }\n         }\n      }\n\n      // retrieve item tickets\n      if (isset($params['with_tickets'])\n          && $params['with_tickets']) {\n         $fields['_tickets'] = [];\n         if (!Ticket::canView()) {\n            $fields['_tickets'] = $this->arrayRightError();\n         } else {\n            $criteria = Ticket::getCommonCriteria();\n            $criteria['WHERE'] = [\n               'glpi_items_tickets.items_id' => $id,\n               'glpi_items_tickets.itemtype' => $itemtype\n            ] + getEntitiesRestrictCriteria(Ticket::getTable());\n            $iterator = $DB->request($criteria);\n            while ($data = $iterator->next()) {\n               $fields['_tickets'][] = $data;\n            }\n         }\n      }\n\n      // retrieve item problems\n      if (isset($params['with_problems'])\n          && $params['with_problems']) {\n         $fields['_problems'] = [];\n         if (!Problem::canView()) {\n            $fields['_problems'] = $this->arrayRightError();\n         } else {\n            $criteria = Problem::getCommonCriteria();\n            $criteria['WHERE'] = [\n               'glpi_items_problems.items_id' => $id,\n               'glpi_items_problems.itemtype' => $itemtype\n            ] + getEntitiesRestrictCriteria(Problem::getTable());\n            $iterator = $DB->request($criteria);\n            while ($data = $iterator->next()) {\n               $fields['_problems'][] = $data;\n            }\n         }\n      }\n\n      // retrieve item changes\n      if (isset($params['with_changes'])\n          && $params['with_changes']) {\n         $fields['_changes'] = [];\n         if (!Change::canView()) {\n            $fields['_changes'] = $this->arrayRightError();\n         } else {\n            $criteria = Change::getCommonCriteria();\n            $criteria['WHERE'] = [\n               'glpi_changes_items.items_id' => $id,\n               'glpi_changes_items.itemtype' => $itemtype\n            ] + getEntitiesRestrictCriteria(Change::getTable());\n            $iterator = $DB->request($criteria);\n            while ($data = $iterator->next()) {\n               $fields['_changes'][] = $data;\n            }\n         }\n      }\n\n      // retrieve item notes\n      if (isset($params['with_notes'])\n          && $params['with_notes']) {\n         $fields['_notes'] = [];\n         if (!Session::haveRight($itemtype::$rightname, READNOTE)) {\n            $fields['_notes'] = $this->arrayRightError();\n         } else {\n            $fields['_notes'] = Notepad::getAllForItem($item);\n         }\n      }\n\n      // retrieve item logs\n      if (isset($params['with_logs'])\n          && $params['with_logs']) {\n         $fields['_logs'] = [];\n         if (!Session::haveRight($itemtype::$rightname, READNOTE)) {\n            $fields['_logs'] = $this->arrayRightError();\n         } else {\n            $fields['_logs'] = getAllDataFromTable(\n               \"glpi_logs\", [\n                  'items_id'  => $item->getID(),\n                  'itemtype'  => $item->getType()\n               ]\n            );\n         }\n      }\n\n      // expand dropdown (retrieve name of dropdowns) and get hateoas from foreign keys\n      $fields = self::parseDropdowns($fields, $params);\n\n      // get hateoas from children\n      if ($params['get_hateoas']) {\n         $hclasses = self::getHatoasClasses($itemtype);\n         foreach ($hclasses as $hclass) {\n            $fields['links'][] = ['rel'  => $hclass,\n                                       'href' => self::$api_url.\"/$itemtype/\".$item->getID().\"/$hclass/\"];\n         }\n      }\n\n      // get sha1 footprint if needed\n      if ($params['get_sha1']) {\n         $fields = sha1(json_encode($fields, JSON_UNESCAPED_UNICODE\n                                             | JSON_UNESCAPED_SLASHES\n                                             | JSON_NUMERIC_CHECK));\n      }\n\n      if (count($params['add_keys_names']) > 0) {\n         $fields[\"_keys_names\"] = $this->getFriendlyNames(\n            $fields,\n            $params,\n            $itemtype\n         );\n      }\n\n      // Convert fields to the format expected by the deprecated type\n      if ($this->isDeprecated()) {\n         $fields = $this->deprecated_item->mapCurrentToDeprecatedFields($fields);\n         $fields[\"links\"] = $this->deprecated_item->mapCurrentToDeprecatedHateoas(\n            $fields[\"links\"] ?? []\n         );\n      }\n\n      return $fields;\n   }\n\n\n\n   /**\n    * Fill a sub array with a right error\n    *\n    * @return array\n    */\n   protected function arrayRightError() {\n\n      return ['error'   => 401,\n                   'message' => __(\"You don't have permission to perform this action.\")];\n   }\n\n\n\n\n\n   /**\n    * Return a collection of rows of the desired itemtype\n    *\n    * @param string  $itemtype   itemtype (class) of object\n    * @param array   $params     with theses options :\n    * - 'expand_dropdowns' (default: false): show dropdown's names instead of id. Optionnal\n    * - 'get_hateoas'      (default: true): show relations of items in a links attribute. Optionnal\n    * - 'only_id'          (default: false): keep only id in fields list. Optionnal\n    * - 'range'            (default: 0-50): limit the list to start-end attributes\n    * - 'sort'             (default: id): sort by the field.\n    * - 'order'            (default: ASC): ASC(ending) or DESC(ending).\n    * - 'searchText'       (default: NULL): array of filters to pass on the query (with key = field and value the search)\n    * - 'is_deleted'       (default: false): show trashbin. Optionnal\n    * - 'add_keys_names'   (default: []): insert raw name(s) for given itemtype(s) and fkey(s)\n    * @param integer $totalcount output parameter who receive the total count of the query resulat.\n    *                            As this function paginate results (with a mysql LIMIT),\n    *                            we can have the full range. (default 0)\n    *\n    * @return array collection of fields\n    */\n   protected function getItems($itemtype, $params = [], &$totalcount = 0) {\n      global $DB;\n\n      $this->initEndpoint();\n      $itemtype = $this->handleDepreciation($itemtype);\n\n      // default params\n      $default = ['expand_dropdowns' => false,\n                       'get_hateoas'      => true,\n                       'only_id'          => false,\n                       'range'            => \"0-\".$_SESSION['glpilist_limit'],\n                       'sort'             => \"id\",\n                       'order'            => \"ASC\",\n                       'searchText'       => null,\n                       'is_deleted'       => false,\n                       'add_keys_names'   => [],\n      ];\n      $params = array_merge($default, $params);\n\n      if (!$itemtype::canView()) {\n         return $this->messageRightError();\n      }\n\n      $found = [];\n      $item = new $itemtype();\n      $item->getEmpty();\n      $table = getTableForItemType($itemtype);\n\n      // transform range parameter in start and limit variables\n      if (isset($params['range']) > 0) {\n         if (preg_match(\"/^[0-9]+-[0-9]+\\$/\", $params['range'])) {\n            $range = explode(\"-\", $params['range']);\n            $params['start']      = $range[0];\n            $params['list_limit'] = $range[1]-$range[0]+1;\n            $params['range']      = $range;\n         } else {\n            $this->returnError(\"range must be in format : [start-end] with integers\");\n         }\n      } else {\n         $params['range'] = [0, $_SESSION['glpilist_limit']];\n      }\n\n      // check parameters\n      if (isset($params['order'])\n          && !in_array(strtoupper($params['order']), ['DESC', 'ASC'])) {\n         $this->returnError(\"order must be DESC or ASC\");\n      }\n      if (!isset($item->fields[$params['sort']])) {\n         $this->returnError(\"sort param is not a field of $table\");\n      }\n\n      //specific case for restriction\n      $already_linked_table = [];\n      $join = Search::addDefaultJoin($itemtype, $table, $already_linked_table);\n      $where = Search::addDefaultWhere($itemtype);\n      if ($where == '') {\n         $where = \"1=1 \";\n      }\n      if ($item->maybeDeleted()) {\n         $where.= \"AND \".$DB->quoteName(\"$table.is_deleted\").\" = \".(int)$params['is_deleted'];\n      }\n\n      // add filter for a parent itemtype\n      if (isset($this->parameters['parent_itemtype'])\n          && isset($this->parameters['parent_id'])) {\n\n         // check parent itemtype\n         if (!Toolbox::isCommonDBTM($this->parameters['parent_itemtype'])\n            && !Toolbox::isAPIDeprecated($this->parameters['parent_itemtype'])\n         ) {\n            $this->returnError(__(\"parent itemtype not found or not an instance of CommonDBTM\"),\n                               400,\n                               \"ERROR_ITEMTYPE_NOT_FOUND_NOR_COMMONDBTM\");\n         }\n\n         $fk_parent = getForeignKeyFieldForItemType($this->parameters['parent_itemtype']);\n         $fk_child = getForeignKeyFieldForItemType($itemtype);\n\n         // check parent rights\n         $parent_item = new $this->parameters['parent_itemtype'];\n         if (!$parent_item->getFromDB($this->parameters['parent_id'])) {\n            return $this->messageNotfoundError();\n         }\n         if (!$parent_item->can($this->parameters['parent_id'], READ)) {\n            return $this->messageRightError();\n         }\n\n         // filter with parents fields\n         if (isset($item->fields[$fk_parent])) {\n            $where.= \" AND \".$DB->quoteName(\"$table.$fk_parent\").\" = \".(int)$this->parameters['parent_id'];\n         } else if (isset($item->fields['itemtype'])\n                 && isset($item->fields['items_id'])) {\n            $where.= \" AND \".$DB->quoteName(\"$table.itemtype\").\" = \".$DB->quoteValue($this->parameters['parent_itemtype']).\"\n                       AND \".$DB->quoteName(\"$table.items_id\").\" = \".(int)$this->parameters['parent_id'];\n         } else if (isset($parent_item->fields[$fk_child])) {\n            $parentTable = getTableForItemType($this->parameters['parent_itemtype']);\n            $join.= \" LEFT JOIN \".$DB->quoteName($parentTable).\" ON \".$DB->quoteName(\"$parentTable.$fk_child\").\" = \".$DB->quoteName(\"$table.id\");\n            $where.= \" AND \".$DB->quoteName(\"$parentTable.id\").\" = \" . (int)$this->parameters['parent_id'];\n         } else if (isset($parent_item->fields['itemtype'])\n                 && isset($parent_item->fields['items_id'])) {\n            $parentTable = getTableForItemType($this->parameters['parent_itemtype']);\n            $join.= \" LEFT JOIN \".$DB->quoteName($parentTable).\" ON \".$DB->quoteName(\"itemtype\").\"=\".$DB->quoteValue($itemtype).\" AND \".$DB->quoteName(\"$parentTable.items_id\").\" = \".$DB->quoteName(\"$table.id\");\n            $where.= \" AND \".$DB->quoteName(\"$parentTable.id\").\" = \" . (int)$this->parameters['parent_id'];\n         }\n      }\n\n      // filter by searchText parameter\n      if (is_array($params['searchText'])) {\n         if (array_keys($params['searchText']) == ['all']) {\n            $labelfield = \"name\";\n            if ($item instanceof CommonDevice) {\n               $labelfield = \"designation\";\n            } else if ($item instanceof Item_Devices) {\n               $labelfield = \"itemtype\";\n            }\n            $search_value                      = $params['searchText']['all'];\n            $params['searchText'][$labelfield] = $search_value;\n            if ($DB->fieldExists($table, 'comment')) {\n               $params['searchText']['comment'] = $search_value;\n            }\n         }\n\n         // make text search\n         foreach ($params['searchText']  as $filter_field => $filter_value) {\n            if (!empty($filter_value)) {\n               $search_value = Search::makeTextSearch($DB->escape($filter_value));\n               $where.= \" AND (\".$DB->quoteName(\"$table.$filter_field\").\" $search_value)\";\n            }\n         }\n      }\n\n      // filter with entity\n      if ($item->isEntityAssign()\n          // some CommonDBChild classes may not have entities_id fields and isEntityAssign still return true (like ITILTemplateMandatoryField)\n          && array_key_exists('entities_id', $item->fields)) {\n         $where.= \" AND (\". getEntitiesRestrictRequest(\"\",\n                                             $itemtype::getTable(),\n                                             '',\n                                             $_SESSION['glpiactiveentities'],\n                                             $item->maybeRecursive(),\n                                             true);\n\n         if ($item instanceof SavedSearch) {\n            $where.= \" OR \".$itemtype::getTable().\".is_private = 1\";\n         }\n\n         $where.= \")\";\n      }\n\n      // Check if we need to add raw names later on\n      $add_keys_names = count($params['add_keys_names']) > 0;\n\n      // build query\n      $query = \"SELECT DISTINCT \".$DB->quoteName(\"$table.id\").\",  \".$DB->quoteName(\"$table.*\").\"\n                FROM \".$DB->quoteName($table).\"\n                $join\n                WHERE $where\n                ORDER BY \".$DB->quoteName($params['sort']).\" \".$params['order'].\"\n                LIMIT \".(int)$params['start'].\", \".(int)$params['list_limit'];\n      if ($result = $DB->query($query)) {\n         while ($data = $DB->fetchAssoc($result)) {\n            if ($add_keys_names) {\n               // Insert raw names into the data row\n               $data[\"_keys_names\"] = $this->getFriendlyNames(\n                  $data,\n                  $params,\n                  $itemtype\n               );\n            }\n\n            $found[] = $data;\n         }\n      }\n\n      // get result full row counts\n      $count_query = \"SELECT COUNT(*) FROM {$DB->quoteName($table)} $join WHERE $where\";\n      $totalcount = $DB->query($count_query)->fetch_row()[0];\n\n      if ($params['range'][0] > $totalcount) {\n         $this->returnError(\"Provided range exceed total count of data: \".$totalcount,\n                            400,\n                            \"ERROR_RANGE_EXCEED_TOTAL\");\n      }\n\n      foreach ($found as &$fields) {\n         // only keep id in field list\n         if ($params['only_id']) {\n            $fields = ['id' => $fields['id']];\n         }\n\n         // avioid disclosure of critical fields\n         $item::unsetUndisclosedFields($fields);\n\n         // expand dropdown (retrieve name of dropdowns) and get hateoas\n         $fields = self::parseDropdowns($fields, $params);\n\n         // get hateoas from children\n         if ($params['get_hateoas']) {\n            $hclasses = self::getHatoasClasses($itemtype);\n            foreach ($hclasses as $hclass) {\n               $fields['links'][] = ['rel' => $hclass,\n                                          'href' => self::$api_url.\"/$itemtype/\".$fields['id'].\"/$hclass/\"];\n            }\n         }\n      }\n      // Break reference\n      unset($fields);\n\n      // Map values for deprecated itemtypes\n      if ($this->isDeprecated()) {\n         $found = array_map(function($fields) {\n            return $this->deprecated_item->mapCurrentToDeprecatedFields($fields);\n         }, $found);\n      }\n\n      return array_values($found);\n   }\n\n   /**\n    * Return a collection of items queried in input ($items)\n    *\n    * Call self::getItem for each line of $items\n    *\n    * @param array $params with theses options :\n    *    - items:               array containing lines with itemtype and items_id keys\n    *                               Ex: [\n    *                                      [itemtype => 'Ticket', id => 102],\n    *                                      [itemtype => 'User',   id => 10],\n    *                                      [itemtype => 'User',   id => 11],\n    *                                   ]\n    *    - 'expand_dropdowns':  Show dropdown's names instead of id. default: false. Optionnal\n    *    - 'get_hateoas':       Show relation of current item in a links attribute. default: true. Optionnal\n    *    - 'get_sha1':          Get a sha1 signature instead of the full answer. default: false. Optionnal\n    *    - 'with_devices':   Only for [Computer, NetworkEquipment, Peripheral, Phone, Printer], Optionnal.\n    *    - 'with_disks':        Only for Computer, retrieve the associated filesystems. Optionnal.\n    *    - 'with_softwares':    Only for Computer, retrieve the associated softwares installations. Optionnal.\n    *    - 'with_connections':  Only for Computer, retrieve the associated direct connections (like peripherals and printers) .Optionnal.\n    *    - 'with_networkports': Retrieve all network connections and advanced network informations. Optionnal.\n    *    - 'with_infocoms':     Retrieve financial and administrative informations. Optionnal.\n    *    - 'with_contracts':    Retrieve associated contracts. Optionnal.\n    *    - 'with_documents':    Retrieve associated external documents. Optionnal.\n    *    - 'with_tickets':      Retrieve associated itil tickets. Optionnal.\n    *    - 'with_problems':     Retrieve associated itil problems. Optionnal.\n    *    - 'with_changes':      Retrieve associated itil changes. Optionnal.\n    *    - 'with_notes':        Retrieve Notes (if exists, not all itemtypes have notes). Optionnal.\n    *    - 'with_logs':         Retrieve historical. Optionnal.\n    *\n    * @return array collection of glpi object's fields\n    */\n   protected function getMultipleItems($params = []) {\n\n      if (!is_array($params['items'])) {\n         return $this->messageBadArrayError();\n      }\n\n      $allitems = [];\n      foreach ($params['items'] as $item) {\n         if (!isset($item['items_id']) && !isset($item['itemtype'])) {\n            return $this->messageBadArrayError();\n         }\n\n         $fields = $this->getItem($item['itemtype'], $item['items_id'], $params);\n         $allitems[] = $fields;\n      }\n\n      return $allitems;\n   }\n\n\n   /**\n    * List the searchoptions of provided itemtype. To use with searchItems function\n    *\n    * @param string $itemtype             itemtype (class) of object\n    * @param array  $params               parameters\n    * @param bool   $check_depreciation   disable depreciation check, useful\n    *                                     if depreciation have already been\n    *                                     handled by a parent call (e.g. search)\n    *\n    * @return array all searchoptions of specified itemtype\n    */\n   protected function listSearchOptions(\n      $itemtype,\n      $params = [],\n      bool $check_depreciation = true\n   ) {\n      $this->initEndpoint();\n\n      if ($check_depreciation) {\n         $itemtype = $this->handleDepreciation($itemtype);\n      }\n\n      $soptions = Search::getOptions($itemtype);\n\n      if (isset($params['raw'])) {\n         return $soptions;\n      }\n\n      $cleaned_soptions = [];\n      foreach ($soptions as $sID => $option) {\n         if (is_int($sID)) {\n            $available_searchtypes = Search::getActionsFor($itemtype, $sID);\n            unset($available_searchtypes['searchopt']);\n            $available_searchtypes = array_keys($available_searchtypes);\n\n            $cleaned_soptions[$sID] = ['name'                  => $option['name'],\n                                            'table'                 => $option['table'],\n                                            'field'                 => $option['field'],\n                                            'datatype'              => isset($option['datatype'])\n                                                                       ?$option['datatype']\n                                                                       :\"\",\n                                            'nosearch'              => isset($option['nosearch'])\n                                                                       ?$option['nosearch']\n                                                                       :false,\n                                            'nodisplay'             => isset($option['nodisplay'])\n                                                                       ?$option['nodisplay']\n                                                                       :false,\n                                            'available_searchtypes' => $available_searchtypes];\n            $cleaned_soptions[$sID]['uid'] = $this->getSearchOptionUniqID($itemtype,\n                                                                               $option);\n         } else {\n            $cleaned_soptions[$sID] = $option;\n         }\n      }\n\n      if ($check_depreciation && $this->isDeprecated()) {\n         $cleaned_soptions = $this->deprecated_item->mapCurrentToDeprecatedSearchOptions($cleaned_soptions);\n      }\n\n      return $cleaned_soptions;\n   }\n\n\n   /**\n    * Generate an unique id of a searchoption based on:\n    *  - itemtype\n    *  - linkfield\n    *  - joinparams\n    *  - field\n    *\n    * It permits to identify a searchoption with an named index instead a numeric one\n    *\n    * @param CommonDBTM $itemtype current itemtype called on ressource listSearchOption\n    * @param array      $option   current option to generate an unique id\n    *\n    * @return string the unique id\n    */\n   private function getSearchOptionUniqID($itemtype, $option = []) {\n\n      $uid_parts = [$itemtype];\n\n      $sub_itemtype = getItemTypeForTable($option['table']);\n\n      if ((isset($option['joinparams']['beforejoin']['table'])\n           || empty($option['joinparams']))\n          && $option['linkfield'] != getForeignKeyFieldForItemType($sub_itemtype)\n          && $option['linkfield'] != $option['field']) {\n         $uid_parts[] = $option['linkfield'];\n      }\n\n      if (isset($option['joinparams'])) {\n         if (isset($option['joinparams']['beforejoin'])) {\n            $sub_parts  = $this->getSearchOptionUniqIDJoins($option['joinparams']['beforejoin']);\n            $uid_parts = array_merge($uid_parts, $sub_parts);\n         }\n      }\n\n      if (isset($option['joinparams']['beforejoin']['table'])\n          || $sub_itemtype != $itemtype) {\n         $uid_parts[] = $sub_itemtype;\n      }\n\n      $uid_parts[] = $option['field'];\n\n      $uuid = implode('.', $uid_parts);\n\n      return $uuid;\n   }\n\n\n   /**\n    * Generate subpart of a unique id of a search option with parsing joinparams recursively\n    *\n    * @param array $option ['joinparams']['beforejoin'] subpart of a searchoption\n    *\n    * @return array unique id parts\n    */\n   private function getSearchOptionUniqIDJoins($option) {\n\n      $uid_parts = [];\n      if (isset($option['joinparams']['beforejoin'])) {\n         $sub_parts  = $this->getSearchOptionUniqIDJoins($option['joinparams']['beforejoin']);\n         $uid_parts = array_merge($uid_parts, $sub_parts);\n      }\n\n      if (isset($option['table'])) {\n         $uid_parts[] = getItemTypeForTable($option['table']);\n      }\n\n      return $uid_parts;\n   }\n\n\n   /**\n    * Expose the GLPI searchEngine\n    *\n    * @param string $itemtype itemtype (class) of object\n    * @param array  $params   with theses options :\n    *    - 'criteria': array of criterion object to filter search.\n    *        Optionnal.\n    *        Each criterion object must provide :\n    *           - link: (optionnal for 1st element) logical operator in [AND, OR, AND NOT, AND NOT].\n    *           - field: id of searchoptions.\n    *           - searchtype: type of search in [contains, equals, notequals, lessthan, morethan, under, notunder].\n    *           - value : value to search.\n    *    - 'metacriteria' (optionnal): array of metacriterion object to filter search.\n    *                                  Optionnal.\n    *                                  A meta search is a link with another itemtype\n    *                                  (ex: Computer with softwares).\n    *         Each metacriterion object must provide :\n    *            - link: logical operator in [AND, OR, AND NOT, AND NOT]. Mandatory\n    *            - itemtype: second itemtype to link.\n    *            - field: id of searchoptions.\n    *            - searchtype: type of search in [contains, equals, notequals, lessthan, morethan, under, notunder].\n    *            - value : value to search.\n    *    - 'sort' :  id of searchoption to sort by (default 1). Optionnal.\n    *    - 'order' : ASC - Ascending sort / DESC Descending sort (default ASC). Optionnal.\n    *    - 'range' : a string with a couple of number for start and end of pagination separated by a '-'. Ex : 150-200. (default 0-50)\n    *                Optionnal.\n    *    - 'forcedisplay': array of columns to display (default empty = empty use display pref and search criterias).\n    *                      Some columns will be always presents (1-id, 2-name, 80-Entity).\n    *                      Optionnal.\n    *    - 'rawdata': boolean for displaying raws data of Search engine of glpi (like sql request, and full searchoptions)\n    *\n    * @return array of raw rows from Search class\n    */\n   protected function searchItems($itemtype, $params = []) {\n      global $DEBUG_SQL;\n\n      $this->initEndpoint();\n      $itemtype = $this->handleDepreciation($itemtype);\n\n      // check rights\n      if ($itemtype != 'AllAssets'\n          && !$itemtype::canView()) {\n         return $this->messageRightError();\n      }\n\n      // retrieve searchoptions\n      $soptions = $this->listSearchOptions($itemtype, [], false);\n\n      if ($this->isDeprecated()) {\n         $criteria = $this->deprecated_item->mapDeprecatedToCurrentCriteria(\n            $params['criteria'] ?? []\n         );\n\n         if (count($criteria)) {\n            $params['criteria'] = $criteria;\n         }\n      }\n\n      // Check the criterias are valid\n      if (isset($params['criteria']) && is_array($params['criteria'])) {\n\n         // use a recursive closure to check each nested criteria\n         $check_criteria = function($criteria) use (&$check_criteria, $soptions) {\n            foreach ($criteria as $criterion) {\n               // recursive call\n               if (isset($criterion['criteria'])) {\n                  return $check_criteria($criterion['criteria']);\n               }\n\n               if (!isset($criterion['field']) || !isset($criterion['searchtype'])\n                   || !isset($criterion['value'])) {\n                  return __(\"Malformed search criteria\");\n               }\n\n               if (!ctype_digit((string) $criterion['field'])\n                   || !array_key_exists($criterion['field'], $soptions)) {\n                  return __(\"Bad field ID in search criteria\");\n               }\n\n               if (isset($soptions[$criterion['field']])\n                   && isset($soptions[$criterion['field']]['nosearch'])\n                   && $soptions[$criterion['field']]['nosearch']) {\n                  return __(\"Forbidden field ID in search criteria\");\n               }\n            }\n\n            return true;\n         };\n\n         // call the closure\n         $check_criteria_result = $check_criteria($params['criteria']);\n         if ($check_criteria_result !== true) {\n            return $this->returnError($check_criteria_result);\n         }\n      }\n\n      // manage forcedisplay\n      if (isset($params['forcedisplay'])) {\n         if (!is_array($params['forcedisplay'])) {\n            $params['forcedisplay'] = [intval($params['forcedisplay'])];\n         }\n         $params['forcedisplay'] = array_combine($params['forcedisplay'], $params['forcedisplay']);\n      } else {\n         $params['forcedisplay'] = [];\n      }\n      foreach ($params['forcedisplay'] as $forcedisplay) {\n         if (isset($soptions[$forcedisplay]) && isset($soptions[$forcedisplay]['nodisplay'])\n             && $soptions[$forcedisplay]['nodisplay']) {\n            return $this->returnError(__(\"ID is forbidden along with 'forcedisplay' parameter.\"));\n         }\n      }\n\n      // transform range parameter in start and limit variables\n      if (isset($params['range']) > 0) {\n         if (preg_match(\"/^[0-9]+-[0-9]+\\$/\", $params['range'])) {\n            $range = explode(\"-\", $params['range']);\n            $params['start']      = $range[0];\n            $params['list_limit'] = $range[1]-$range[0]+1;\n            $params['range']      = $range;\n         } else {\n            $this->returnError(\"range must be in format : [start-end] with integers\");\n         }\n      } else {\n         $params['range'] = [0, $_SESSION['glpilist_limit']];\n      }\n\n      // force reset\n      $params['reset'] = 'reset';\n\n      // force logging sql queries\n      $_SESSION['glpi_use_mode'] = Session::DEBUG_MODE;\n\n      // call Core Search method\n      $rawdata = Search::getDatas($itemtype, $params, $params['forcedisplay']);\n\n      // probably a sql error\n      if (!isset($rawdata['data']) || count($rawdata['data']) === 0) {\n         $this->returnError(\"Unexpected SQL Error : \".array_splice($DEBUG_SQL['errors'], -2)[0],\n                            500, \"ERROR_SQL\", false);\n      }\n\n      $cleaned_data = ['totalcount' => $rawdata['data']['totalcount'],\n                            'count'      => count($rawdata['data']['rows']),\n                            'sort'       => $rawdata['search']['sort'],\n                            'order'      => $rawdata['search']['order']];\n\n      if ($params['range'][0] > $cleaned_data['totalcount']) {\n         $this->returnError(\"Provided range exceed total count of data: \".$cleaned_data['totalcount'],\n                            400,\n                            \"ERROR_RANGE_EXCEED_TOTAL\");\n      }\n\n      // fix end range\n      if ($params['range'][1] > $cleaned_data['totalcount'] - 1) {\n         $params['range'][1] = $cleaned_data['totalcount'] - 1;\n      }\n\n      //prepare cols (searchoptions_id) for cleaned data\n      $cleaned_cols = [];\n      $uid_cols = [];\n      foreach ($rawdata['data']['cols'] as $col) {\n         $cleaned_cols[] = $col['id'];\n         if (isset($params['uid_cols'])) {\n            // prepare cols with uid\n            $uid_cols[] = $soptions[$col['id']]['uid'];\n         }\n      }\n\n      foreach ($rawdata['data']['rows'] as $row) {\n         $raw = $row['raw'];\n         $id = $raw['id'];\n\n         // keep row itemtype for all asset\n         if ($itemtype == 'AllAssets') {\n            $current_id       = $raw['id'];\n            $current_itemtype = $raw['TYPE'];\n         }\n\n         // retrive value (and manage multiple values)\n         $clean_values = [];\n         foreach ($rawdata['data']['cols'] as $col) {\n            $rvalues = $row[$col['itemtype'] . '_' . $col['id']];\n\n            // manage multiple values (ex: IP adresses)\n            $current_values = [];\n            for ($valindex= 0; $valindex < $rvalues['count']; $valindex++) {\n               $current_values[] = $rvalues[$valindex]['name'];\n            }\n            if (count($current_values) == 1) {\n               $current_values = $current_values[0];\n            }\n\n            $clean_values[] = $current_values;\n         }\n\n         // combine cols (searchoptions_id) with values (raws data)\n         if (isset($params['uid_cols'])) {\n            $current_line = array_combine($uid_cols, $clean_values);\n         } else {\n            $current_line = array_combine($cleaned_cols, $clean_values);\n         }\n\n         // if all asset, provide type in returned data\n         if ($itemtype == 'AllAssets') {\n            $current_line['id']       = $current_id;\n            $current_line['itemtype'] = $current_itemtype;\n         }\n\n         // append to final array\n         if (isset($params['withindexes'])) {\n            $cleaned_data['data'][$id] = $current_line;\n         } else {\n            $cleaned_data['data'][] = $current_line;\n         }\n      }\n\n      // add rows with their html\n      if (isset($params['giveItems'])) {\n         $cleaned_data['data_html'] = [];\n         foreach ($rawdata['data']['rows'] as $row) {\n            $new_row = [];\n            foreach ($row as $cell_key => $cell) {\n               if (isset($cell['displayname'])) {\n                  $new_row[$cell_key] = $cell['displayname'];\n               }\n            }\n            $new_row = array_combine($cleaned_cols, $new_row);\n\n            if (isset($params['withindexes'])) {\n               $cleaned_data['data_html'][$row['id']] = $new_row;\n            } else {\n               $cleaned_data['data_html'][] = $new_row;\n            }\n         }\n      }\n\n      if (isset($params['rawdata'])\n          && $params['rawdata']) {\n         $cleaned_data['rawdata'] = $rawdata;\n      }\n\n      $cleaned_data['content-range'] = implode('-', $params['range']).\n                                       \"/\".$cleaned_data['totalcount'];\n\n      // return data\n      return $cleaned_data;\n   }\n\n\n   /**\n    * Add an object to GLPI\n    *\n    * @param string $itemtype itemtype (class) of object\n    * @param array  $params   with theses options :\n    *    - 'input' : object with fields of itemtype to be inserted.\n    *                You can add several items in one action by passing array of input object.\n    *                Mandatory.\n    *\n    * @return array of id\n    */\n   protected function createItems($itemtype, $params = []) {\n      $this->initEndpoint();\n      $itemtype = $this->handleDepreciation($itemtype);\n\n      $input    = isset($params['input']) ? $params[\"input\"] : null;\n      $item     = new $itemtype;\n\n      if (is_object($input)) {\n         $input = [$input];\n         $isMultiple = false;\n      } else {\n         $isMultiple = true;\n      }\n\n      if ($this->isDeprecated()) {\n         $input = array_map(function($item) {\n            return $this->deprecated_item->mapDeprecatedToCurrentFields($item);\n         }, $input);\n      }\n\n      if (is_array($input)) {\n         $idCollection = [];\n         $failed       = 0;\n         $index        = 0;\n         foreach ($input as $object) {\n            $object      = $this->inputObjectToArray($object);\n            $current_res = [];\n\n            //check rights\n            if (!$item->can(-1, CREATE, $object)) {\n               $failed++;\n               $current_res = ['id'      => false,\n                               'message' => __(\"You don't have permission to perform this action.\")];\n            } else {\n               // add missing entity\n               if (!isset($object['entities_id'])) {\n                  $object['entities_id'] = $_SESSION['glpiactive_entity'];\n               }\n\n               // add an entry to match gui post (which contains submit button)\n               // to force having messages after redirect\n               $object[\"_add\"] = true;\n\n               //add current item\n               $object = Toolbox::sanitize($object);\n               $new_id = $item->add($object);\n               if ($new_id === false) {\n                  $failed++;\n               }\n               $current_res = ['id'      => $new_id,\n                               'message' => $this->getGlpiLastMessage()];\n            }\n\n            // attach fileupload answer\n            if (isset($params['upload_result'])\n                && isset($params['upload_result'][$index])) {\n               $current_res['upload_result'] = $params['upload_result'][$index];\n            }\n\n            // append current result to final collection\n            $idCollection[] = $current_res;\n            $index++;\n         }\n\n         if ($isMultiple) {\n            if ($failed == count($input)) {\n               $this->returnError($idCollection, 400, \"ERROR_GLPI_ADD\", false);\n            } else if ($failed > 0) {\n               $this->returnError($idCollection, 207, \"ERROR_GLPI_PARTIAL_ADD\", false);\n            }\n         } else {\n            if ($failed > 0) {\n               $this->returnError($idCollection[0]['message'], 400, \"ERROR_GLPI_ADD\", false);\n            } else {\n               return $idCollection[0];\n            }\n         }\n         return $idCollection;\n\n      } else {\n         $this->messageBadArrayError();\n      }\n   }\n\n   /**\n    * Transform all stdobject retrieved from a json_decode into arrays\n    *\n    * @since 9.1\n    *\n    * @param  mixed $input can be an object or array\n    *\n    * @return array the cleaned input\n    */\n   private function inputObjectToArray($input) {\n      if (is_object($input)) {\n         $input = get_object_vars($input);\n      }\n\n      if (is_array($input)) {\n         foreach ($input as &$sub_input) {\n            $sub_input = self::inputObjectToArray($sub_input);\n         }\n      }\n\n      return $input;\n   }\n\n\n   /**\n    * Update an object to GLPI\n    *\n    * @param string $itemtype itemtype (class) of object\n    * @param array  $params   with theses options :\n    *    - 'input' : Array of objects with fields of itemtype to be updated.\n    *                Mandatory.\n    *                You must provide in each object a key named 'id' to identify item to update.\n    *\n    * @return   array of boolean\n    */\n   protected function updateItems($itemtype, $params = []) {\n      $this->initEndpoint();\n      $itemtype = $this->handleDepreciation($itemtype);\n\n      $input    = isset($params['input']) ? $params[\"input\"] : null;\n      $item     = new $itemtype;\n\n      if (is_object($input)) {\n         $input = [$input];\n         $isMultiple = false;\n      } else {\n         $isMultiple = true;\n      }\n\n      if ($this->isDeprecated()) {\n         $input = array_map(function($item) {\n            return $this->deprecated_item->mapDeprecatedToCurrentFields($item);\n         }, $input);\n      }\n\n      if (is_array($input)) {\n         $idCollection = [];\n         $failed       = 0;\n         $index        = 0;\n         foreach ($input as $object) {\n            $current_res = [];\n            if (isset($object->id)) {\n               if (!$item->getFromDB($object->id)) {\n                  $failed++;\n                  $current_res = [$object->id => false,\n                                  'message'   => __(\"Item not found\")];\n                  continue;\n               }\n\n               //check rights\n               if (!$item->can($object->id, UPDATE)) {\n                  $failed++;\n                  $current_res = [$object->id => false,\n                                 'message'    => __(\"You don't have permission to perform this action.\")];\n               } else {\n                  // if parent key not provided in input and present in parameter\n                  // (detected from url for example), try to appent it do input\n                  // This is usefull to have logs in parent (and avoid some warnings in commonDBTM)\n                  if (isset($params['parent_itemtype'])\n                      && isset($params['parent_id'])) {\n                     $fk_parent = getForeignKeyFieldForItemType($params['parent_itemtype']);\n                     if (!property_exists($input, $fk_parent)) {\n                        $input->$fk_parent = $params['parent_id'];\n                     }\n                  }\n\n                  //update item\n                  $object = Toolbox::sanitize((array)$object);\n                  $update_return = $item->update($object);\n                  if ($update_return === false) {\n                     $failed++;\n                  }\n                  $current_res = [$item->fields[\"id\"] => $update_return,\n                                  'message'           => $this->getGlpiLastMessage()];\n               }\n\n            }\n\n            // attach fileupload answer\n            if (isset($params['upload_result'])\n                && isset($params['upload_result'][$index])) {\n               $current_res['upload_result'] = $params['upload_result'][$index];\n            }\n\n            // append current result to final collection\n            $idCollection[] = $current_res;\n            $index++;\n         }\n         if ($isMultiple) {\n            if ($failed == count($input)) {\n               $this->returnError($idCollection, 400, \"ERROR_GLPI_UPDATE\", false);\n            } else if ($failed > 0) {\n               $this->returnError($idCollection, 207, \"ERROR_GLPI_PARTIAL_UPDATE\", false);\n            }\n         } else {\n            if ($failed > 0) {\n               $this->returnError($idCollection[0]['message'], 400, \"ERROR_GLPI_UPDATE\", false);\n            } else {\n               return $idCollection; // Return collection, even if the request affects a single item\n            }\n         }\n         return $idCollection;\n\n      } else {\n         $this->messageBadArrayError();\n      }\n   }\n\n\n   /**\n    * Delete one or more objects in GLPI\n    *\n    * @param string $itemtype itemtype (class) of object\n    * @param array  $params   with theses options :\n    *    - 'input' : Array of objects with fields of itemtype to be updated.\n    *                Mandatory.\n    *                You must provide in each object a key named 'id' to identify item to delete.*\n    *    - 'force_purge' : boolean, if itemtype have a trashbin, you can force purge (delete finally).\n    *                      Optionnal.\n    *    - 'history' : boolean, default true, false to disable saving of deletion in global history.\n    *                  Optionnal.\n    *\n    * @return boolean|boolean[]\n    */\n   protected function deleteItems($itemtype, $params = []) {\n\n      $this->initEndpoint();\n      $itemtype = $this->handleDepreciation($itemtype);\n\n      $default  = ['force_purge' => false,\n                        'history'     => true];\n      $params   = array_merge($default, $params);\n      $input    = $params['input'];\n      $item     = new $itemtype;\n\n      if (is_object($input)) {\n         $input = [$input];\n         $isMultiple = false;\n      } else {\n         $isMultiple = true;\n      }\n\n      if ($this->isDeprecated()) {\n         $input = array_map(function($item) {\n            return $this->deprecated_item->mapDeprecatedToCurrentFields($item);\n         }, $input);\n      }\n\n      if (is_array($input)) {\n         $idCollection = [];\n         $failed = 0;\n         foreach ($input as $object) {\n            if (isset($object->id)) {\n               if (!$item->getFromDB($object->id)) {\n                  $failed++;\n                  $idCollection[] = [$object->id => false, 'message' => __(\"Item not found\")];\n                  continue;\n               }\n\n               // Force purge for templates / may not to be deleted / not dynamic lockable items\n               // see CommonDBTM::delete()\n               // TODO Needs factorization\n               if ($item->isTemplate()\n                  || !$item->maybeDeleted()\n                  // Do not take into account deleted field if maybe dynamic but not dynamic\n                  || ($item->useDeletedToLockIfDynamic()\n                        && !$item->isDynamic())) {\n                  $params['force_purge'] = 1;\n               } else {\n                  $params['force_purge'] = filter_var($params['force_purge'], FILTER_VALIDATE_BOOLEAN);\n               }\n\n               //check rights\n               if (($params['force_purge']\n                    && !$item->can($object->id, PURGE))\n                   || (!$params['force_purge']\n                       && !$item->can($object->id, DELETE))) {\n                  $failed++;\n                  $idCollection[] = [\n                        $object->id => false,\n                        'message' => __(\"You don't have permission to perform this action.\")\n                  ];\n               } else {\n                  //delete item\n                  $delete_return = $item->delete((array) $object,\n                                                 $params['force_purge'],\n                                                 $params['history']);\n                  if ($delete_return === false) {\n                     $failed++;\n                  }\n                  $idCollection[] = [$object->id => $delete_return, 'message' => $this->getGlpiLastMessage()];\n               }\n            }\n         }\n         if ($isMultiple) {\n            if ($failed == count($input)) {\n               $this->returnError($idCollection, 400, \"ERROR_GLPI_DELETE\", false);\n            } else if ($failed > 0) {\n               $this->returnError($idCollection, 207, \"ERROR_GLPI_PARTIAL_DELETE\", false);\n            }\n         } else {\n            if ($failed > 0) {\n               $this->returnError($idCollection[0]['message'], 400, \"ERROR_GLPI_DELETE\", false);\n            } else {\n               return $idCollection; // Return collection, even if the request affects a single item\n            }\n         }\n\n         return $idCollection;\n\n      } else {\n         $this->messageBadArrayError();\n      }\n   }\n\n\n   protected function lostPassword($params = []) {\n      global $CFG_GLPI;\n\n      if ($CFG_GLPI['use_notifications'] == '0' || $CFG_GLPI['notifications_mailing'] == '0') {\n         return $this->returnError(__(\"Email notifications are disabled\"));\n      }\n\n      if (!isset($params['email'])) {\n         return $this->returnError(__(\"email parameter missing\"));\n      }\n\n      if (isset($_SESSION['glpiID'])) {\n         return $this->returnError(__(\"A session is active\"));\n      }\n\n      $user = new User();\n      if (!isset($params['password_forget_token'])) {\n         $email = Toolbox::addslashes_deep($params['email']);\n         try {\n            $user->forgetPassword($email);\n         } catch (ForgetPasswordException $e) {\n            return $this->returnError($e->getMessage());\n         }\n         return $this->returnResponse([\n            __(\"An email has been sent to your email address. The email contains information for reset your password.\")\n         ]);\n      } else {\n         $password = isset($params['password']) ? $params['password'] : '';\n         $input = [\n            'email'                    => Toolbox::addslashes_deep($params['email']),\n            'password_forget_token'    => Toolbox::addslashes_deep($params['password_forget_token']),\n            'password'                 => Toolbox::addslashes_deep($password),\n            'password2'                => Toolbox::addslashes_deep($password),\n         ];\n         try {\n            $user->updateForgottenPassword($input);\n            return $this->returnResponse([__(\"Reset password successful.\")]);\n         } catch (ForgetPasswordException $e) {\n            return $this->returnError($e->getMessage());\n         } catch (PasswordTooWeakException $e) {\n            implode('\\n', $e->getMessages());\n            return $this->returnError(implode('\\n', $e->getMessages()));\n         }\n      }\n   }\n\n\n   /**\n    * Function called by each common function of the API.\n    *\n    * We need for each of these to :\n    *  - checks app_token\n    *  - log\n    *  - check session token\n    *  - unlock session if needed (set ip to read-only to permit concurrent calls)\n    *\n    * @param boolean $unlock_session do we need to unlock session (default true)\n    * @param string  $endpoint       name of the current function (default '')\n    *\n    * @return void\n    */\n   private function initEndpoint($unlock_session = true, $endpoint = \"\") {\n\n      if ($endpoint === \"\") {\n         $backtrace = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 2);\n         $endpoint = $backtrace[1]['function'];\n      }\n      $this->checkAppToken();\n      $this->logEndpointUsage($endpoint);\n      $this->checkSessionToken();\n      if ($unlock_session) {\n         $this->unlockSessionIfPossible();\n      }\n   }\n\n\n   /**\n    * Check if the app_toke in case of config ask to\n    *\n    * @return void\n    */\n   private function checkAppToken() {\n\n      // check app token (if needed)\n      if (!isset($this->parameters['app_token'])) {\n         $this->parameters['app_token'] = \"\";\n      }\n      if (!$this->apiclients_id = array_search($this->parameters['app_token'], $this->app_tokens)) {\n         if ($this->parameters['app_token'] != \"\") {\n            $this->returnError(__(\"parameter app_token seems wrong\"), 400,\n                               \"ERROR_WRONG_APP_TOKEN_PARAMETER\");\n         } else {\n            $this->returnError(__(\"missing parameter app_token\"), 400,\n                               \"ERROR_APP_TOKEN_PARAMETERS_MISSING\");\n         }\n      }\n   }\n\n\n   /**\n    * Log usage of the api into glpi historical or log files (defined by api config)\n    *\n    * It stores the ip and the username of the current session.\n    *\n    * @param string $endpoint function called by api to log (default '')\n    *\n    * @return void\n    */\n   private function logEndpointUsage($endpoint = \"\") {\n\n      $username = \"\";\n      if (isset($_SESSION['glpiname'])) {\n         $username = \"(\".$_SESSION['glpiname'].\")\";\n      }\n\n      $apiclient = new APIClient;\n      if ($apiclient->getFromDB($this->apiclients_id)) {\n         $changes = [\n            0,\n            \"\",\n            \"Enpoint '$endpoint' called by \".$this->iptxt.\" $username\"\n         ];\n\n         switch ($apiclient->fields['dolog_method']) {\n            case APIClient::DOLOG_HISTORICAL:\n               Log::history($this->apiclients_id, 'APIClient', $changes, 0,\n                            Log::HISTORY_LOG_SIMPLE_MESSAGE);\n               break;\n\n            case APIClient::DOLOG_LOGS:\n               Toolbox::logInFile(\"api\", $changes[2].\"\\n\");\n               break;\n         }\n      }\n   }\n\n\n   /**\n    * Check that the session_token is provided and match to a valid php session\n    *\n    * @return boolean\n    */\n   protected function checkSessionToken() {\n\n      if (!isset($this->parameters['session_token'])\n          || empty($this->parameters['session_token'])) {\n         return $this->messageSessionTokenMissing();\n      }\n\n      $current = session_id();\n      if ($this->parameters['session_token'] != $current\n          && !empty($current)\n          || !isset($_SESSION['glpiID'])) {\n         return $this->messageSessionError();\n      }\n   }\n\n\n   /**\n    * Unlock the current session (readonly) to permit concurrent call\n    *\n    * @return void\n    */\n   private function unlockSessionIfPossible() {\n\n      if (!$this->session_write) {\n         session_write_close();\n      }\n   }\n\n\n   /**\n    * Get last message added in $_SESSION by Session::addMessageAfterRedirect\n    *\n    * @return array  of messages\n    */\n   private function getGlpiLastMessage() {\n      global $DEBUG_SQL;\n\n      $all_messages             = [];\n\n      $messages_after_redirect  = [];\n\n      if (isset($_SESSION[\"MESSAGE_AFTER_REDIRECT\"])\n          && count($_SESSION[\"MESSAGE_AFTER_REDIRECT\"]) > 0) {\n         $messages_after_redirect = $_SESSION[\"MESSAGE_AFTER_REDIRECT\"];\n         // Clean messages\n         $_SESSION[\"MESSAGE_AFTER_REDIRECT\"] = [];\n      };\n\n      // clean html\n      foreach ($messages_after_redirect as $messages) {\n         foreach ($messages as $message) {\n            $all_messages[] = Html::clean($message);\n         }\n      }\n\n      // get sql errors\n      if (count($all_messages) <= 0\n          && $DEBUG_SQL['errors'] !== null) {\n         $all_messages = $DEBUG_SQL['errors'];\n      }\n\n      if (!end($all_messages)) {\n         return '';\n      }\n      return end($all_messages);\n   }\n\n\n   /**\n    * Show API Debug\n    *\n    * @return void\n    */\n   protected function showDebug() {\n      Html::printCleanArray($this);\n   }\n\n\n   /**\n    * Show API header\n    *\n    * in debug, it add body and some libs (essentialy to colorise markdown)\n    * otherwise, it change only Content-Type of the page\n    *\n    * @param boolean $html  (default false)\n    * @param string  $title (default '')\n    *\n    * @return void\n    */\n   protected function header($html = false, $title = \"\") {\n\n      // Send UTF8 Headers\n      $content_type = static::$content_type;\n      if ($html) {\n         $content_type = \"text/html\";\n      }\n      header(\"Content-Type: $content_type; charset=UTF-8\");\n\n       // Send extra expires header\n      Html::header_nocache();\n\n      if ($html) {\n         if (empty($title)) {\n            $title = $this->getTypeName();\n         }\n\n         Html::includeHeader($title);\n\n         // Body with configured stuff\n         echo \"<body>\";\n         echo \"<div id='page'>\";\n      }\n   }\n\n\n   /**\n    * Display the API Documentation in Html (parsed from markdown)\n    *\n    * @param string $file relative path of documentation file\n    *\n    * @return void\n    */\n   public function inlineDocumentation($file) {\n      $this->header(true, __(\"API Documentation\"));\n      echo Html::css(\"public/lib/prismjs.css\");\n      echo Html::script(\"public/lib/prismjs.js\");\n\n      echo \"<div class='documentation'>\";\n      $documentation = file_get_contents(GLPI_ROOT.'/'.$file);\n      $md = new MarkdownExtra();\n      $md->code_class_prefix = \"language-\";\n      $md->header_id_func = function($headerName) {\n         $headerName = str_replace(['(', ')'], '', $headerName);\n         return rawurlencode(strtolower(strtr($headerName, [' ' => '-'])));\n      };\n      echo $md->transform($documentation);\n      echo \"</div>\";\n\n      Html::nullFooter();\n   }\n\n\n   /**\n    * Transform array of fields passed in parameter :\n    * change value from  integer id to string name of foreign key\n    * You can pass an array of array, this method is recursive.\n    *\n    * @param array   $fields to check and transform\n    * @param boolean $params array of option to enable, could be :\n    *                                 - expand_dropdowns (default false)\n    *                                 - get_hateoas      (default true)\n    *\n    * @return array altered $fields\n    */\n   protected static function parseDropdowns($fields, $params = []) {\n\n      // default params\n      $default = ['expand_dropdowns' => false,\n                       'get_hateoas'      => true];\n      $params = array_merge($default, $params);\n\n      // parse fields recursively\n      foreach ($fields as $key => &$value) {\n         if (is_array($value)) {\n            $value = self::parseDropdowns($value, $params);\n         }\n         if (is_integer($key)) {\n            continue;\n         }\n         if (isForeignKeyField($key)) {\n            // specific key transformations\n            if ($key == \"items_id\" && isset($fields['itemtype'])) {\n               $key = getForeignKeyFieldForItemType($fields['itemtype']);\n            }\n            if ($key == \"auths_id\"\n                && isset($fields['authtype']) && $fields['authtype'] == Auth::LDAP) {\n               $key = \"authldaps_id\";\n            }\n            if ($key == \"default_requesttypes_id\") {\n               $key = \"requesttypes_id\";\n            }\n\n            if (!empty($value)\n                || $key == 'entities_id' && $value >= 0) {\n\n               $tablename = getTableNameForForeignKeyField($key);\n               $itemtype = getItemTypeForTable($tablename);\n\n               // get hateoas\n               if ($params['get_hateoas'] && is_integer($value)) {\n                  $fields['links'][] = ['rel'  => $itemtype,\n                                             'href' => self::$api_url.\"/$itemtype/\".$value];\n               }\n\n               // expand dropdown\n               if ($params['expand_dropdowns']) {\n                  $value = Dropdown::getDropdownName($tablename, $value);\n                  // fix value for inexistent items\n                  if ($value == \"&nbsp;\") {\n                     $value = \"\";\n                  }\n               }\n            }\n         }\n      }\n      return $fields;\n   }\n\n\n   /**\n    * Retrieve all child class for itemtype parameter\n    *\n    * @param string $itemtype Item type\n    *\n    * @return array child classes\n    */\n   static function getHatoasClasses($itemtype) {\n      global $CFG_GLPI;\n\n      $hclasses = [];\n      if (in_array($itemtype, $CFG_GLPI[\"reservation_types\"])) {\n         $hclasses[] = \"ReservationItem\";\n      }\n      if (in_array($itemtype, $CFG_GLPI[\"document_types\"])) {\n         $hclasses[] = \"Document_Item\";\n      }\n      if (in_array($itemtype, $CFG_GLPI[\"contract_types\"])) {\n         $hclasses[] = \"Contract_Item\";\n      }\n      if (in_array($itemtype, $CFG_GLPI[\"infocom_types\"])) {\n         $hclasses[] = \"Infocom\";\n      }\n      if (in_array($itemtype, $CFG_GLPI[\"ticket_types\"])) {\n         $hclasses[] = \"Item_Ticket\";\n      }if (in_array($itemtype, $CFG_GLPI[\"project_asset_types\"])) {\n         $hclasses[] = \"Item_Project\";\n      }\n      if (in_array($itemtype, $CFG_GLPI[\"networkport_types\"])) {\n         $hclasses[] = \"NetworkPort\";\n      }\n      if (in_array($itemtype, $CFG_GLPI[\"itemdevices_types\"])) {\n         //$hclasses[] = \"Item_Devices\";\n         foreach ($CFG_GLPI['device_types'] as $device_type) {\n            if ((($device_type ==\"DeviceMemory\")\n                 && !in_array($itemtype, $CFG_GLPI[\"itemdevicememory_types\"]))\n                || (($device_type ==\"DevicePowerSupply\")\n                    && !in_array($itemtype, $CFG_GLPI[\"itemdevicepowersupply_types\"]))\n                || (($device_type ==\"DeviceNetworkCard\")\n                    && !in_array($itemtype, $CFG_GLPI[\"itemdevicenetworkcard_types\"]))) {\n               continue;\n            }\n            $hclasses[] = \"Item_\".$device_type;\n         }\n      }\n\n      //specific case\n      switch ($itemtype) {\n         case 'Ticket' :\n            $hclasses[] = \"TicketTask\";\n            $hclasses[] = \"TicketValidation\";\n            $hclasses[] = \"TicketCost\";\n            $hclasses[] = \"Problem_Ticket\";\n            $hclasses[] = \"Change_Ticket\";\n            $hclasses[] = \"Item_Ticket\";\n            $hclasses[] = \"ITILSolution\";\n            $hclasses[] = \"ITILFollowup\";\n            break;\n\n         case 'Problem' :\n            $hclasses[] = \"ProblemTask\";\n            $hclasses[] = \"ProblemCost\";\n            $hclasses[] = \"Change_Problem\";\n            $hclasses[] = \"Problem_Ticket\";\n            $hclasses[] = \"Item_Problem\";\n            $hclasses[] = \"ITILSolution\";\n            $hclasses[] = \"ITILFollowup\";\n            break;\n\n         case 'Change' :\n            $hclasses[] = \"ChangeTask\";\n            $hclasses[] = \"ChangeCost\";\n            $hclasses[] = \"Itil_Project\";\n            $hclasses[] = \"Change_Problem\";\n            $hclasses[] = \"Change_Ticket\";\n            $hclasses[] = \"Change_Item\";\n            $hclasses[] = \"ITILSolution\";\n            $hclasses[] = \"ITILFollowup\";\n            break;\n\n         case 'Project' :\n            $hclasses[] = \"ProjectTask\";\n            $hclasses[] = \"ProjectCost\";\n            $hclasses[] = \"Itil_Project\";\n            $hclasses[] = \"Item_Project\";\n            break;\n      }\n\n      return $hclasses;\n   }\n\n\n   /**\n    * Send 404 error to client\n    *\n    * @param boolean $return_error (default true)\n    *\n    * @return void\n    */\n   public function messageNotfoundError($return_error = true) {\n\n      $this->returnError(__(\"Item not found\"),\n                         404,\n                         \"ERROR_ITEM_NOT_FOUND\",\n                         false,\n                         $return_error);\n   }\n\n\n   /**\n    * Send 400 error to client\n    *\n    * @param boolean $return_error (default true)\n    *\n    * @return void\n    */\n   public function messageBadArrayError($return_error = true) {\n\n      $this->returnError(__(\"input parameter must be an array of objects\"),\n                         400,\n                         \"ERROR_BAD_ARRAY\",\n                         true,\n                         $return_error);\n   }\n\n\n   /**\n    * Send 405 error to client\n    *\n    * @param boolean $return_error (default true)\n    *\n    * @return void\n    */\n   public function messageLostError($return_error = true) {\n\n      $this->returnError(__(\"Method Not Allowed\"),\n                         405,\n                         \"ERROR_METHOD_NOT_ALLOWED\",\n                         true,\n                         $return_error);\n   }\n\n\n   /**\n    * Send 401 error to client\n    *\n    * @param boolean $return_error (default true)\n    *\n    * @return void\n    */\n   public function messageRightError($return_error = true) {\n\n      $this->returnError(__(\"You don't have permission to perform this action.\"),\n                         401,\n                         \"ERROR_RIGHT_MISSING\",\n                         false,\n                         $return_error);\n   }\n\n\n   /**\n    * Session Token KO\n    *\n    * @param boolean $return_error (default true)\n    *\n    * @return void\n    */\n   public function messageSessionError($return_error = true) {\n      $this->returnError(__(\"session_token seems invalid\"),\n                         401,\n                         \"ERROR_SESSION_TOKEN_INVALID\",\n                         false,\n                         $return_error);\n   }\n\n\n   /**\n    * Session Token missing\n    *\n    * @param boolean $return_error (default true)\n    *\n    * @return void\n    */\n   public function messageSessionTokenMissing($return_error = true) {\n\n      $this->returnError(__(\"parameter session_token is missing or empty\"),\n                         400,\n                         \"ERROR_SESSION_TOKEN_MISSING\",\n                         true,\n                         $return_error);\n   }\n\n\n   /**\n    * Generic function to send a error message and an error code to client\n    *\n    * @param string  $message         message to send (human readable)(default 'Bad Request')\n    * @param integer $httpcode        http code (see : https://en.wikipedia.org/wiki/List_of_HTTP_status_codes)\n    *                                      (default 400)\n    * @param string  $statuscode      API status (to represent more precisely the current error)\n    *                                      (default ERROR)\n    * @param boolean $docmessage      if true, add a link to inline document in message\n    *                                      (default true)\n    * @param boolean $return_response if true, the error will be send to returnResponse function\n    *                                      (who may exit after sending data), otherwise,\n    *                                      we will return an array with the error\n    *                                      (default true)\n    *\n    * @return array\n    */\n   public function returnError($message = \"Bad Request\", $httpcode = 400, $statuscode = \"ERROR\",\n                               $docmessage = true, $return_response = true) {\n\n      if (empty($httpcode)) {\n         $httpcode = 400;\n      }\n      if (empty($statuscode)) {\n         $statuscode = \"ERROR\";\n      }\n\n      if ($docmessage) {\n         $message .= \"; \".sprintf(__(\"view documentation in your browser at %s\"),\n                                  self::$api_url.\"/#$statuscode\");\n      }\n      if ($return_response) {\n         return $this->returnResponse([$statuscode, $message], $httpcode);\n      }\n      return [$statuscode, $message];\n   }\n\n\n   /**\n    * Get the raw HTTP request body\n    *\n    * @return string\n    */\n   protected function getHttpBody() {\n      return file_get_contents('php://input');\n   }\n\n   /**\n    * Get raw names\n    *\n    * @since 9.5\n    *\n    * @param array  $data           A raw from the database\n    * @param array  $params         API parameters\n    * @param string $self_itemtype  Itemtype the API was called on\n    *\n    * @return array\n    */\n   protected function getFriendlyNames(\n      array $data,\n      array $params,\n      string $self_itemtype\n   ) {\n      $_names = [];\n\n      foreach ($params['add_keys_names'] as $kn_fkey) {\n         if ($kn_fkey == \"id\") {\n            // Get friendlyname for current item\n            $kn_itemtype = $self_itemtype;\n            $kn_id = $data[$kn_itemtype::getIndexName()];\n         } else {\n\n            if (!isset($data[$kn_fkey])) {\n               Toolbox::logWarning(\n                  \"Invalid value: \\\"$kn_fkey\\\" doesn't exist.\n               \");\n               continue;\n            }\n\n            // Get friendlyname for given fkey\n            $kn_itemtype = getItemtypeForForeignKeyField($kn_fkey);\n            $kn_id = $data[$kn_fkey];\n         }\n\n         // Check itemtype is valid\n         $kn_item = getItemForItemtype($kn_itemtype);\n         if (!$kn_item) {\n            Toolbox::logWarning(\n               \"Invalid itemtype \\\"$kn_itemtype\\\" for fkey  \\\"$kn_fkey\\\"\"\n            );\n            continue;\n         }\n\n         $kn_name = $kn_item::getFriendlyNameById($kn_id);\n         $_names[$kn_fkey] = $kn_name;\n      }\n\n      return $_names;\n   }\n\n   /**\n    * Get the profile picture of the given user\n    *\n    * @since 9.5\n    *\n    * @param int|boolean $user_id\n    */\n   public function userPicture($user_id) {\n      $this->initEndpoint();\n\n      // Try to load target user\n      $user = new User();\n      if (!$user->getFromDB($user_id)) {\n         $this->returnError(\"Bad request: user with id '$user_id' not found\");\n      }\n\n      if (!empty($user->fields['picture'])) {\n         // Send file\n         $file = GLPI_PICTURE_DIR . '/' . $user->fields['picture'];\n         Toolbox::sendFile($file, $user->fields['picture']);\n      } else {\n         // No content\n         http_response_code(204);\n      }\n      die;\n   }\n\n   /**\n    * If the given itemtype is deprecated, replace it by it's current\n    * equivalent and keep a reference to the deprecation logic so we can convert\n    * the API input and/or output to the ex\u00eacted format.\n    *\n    * @param string  $itemtype\n    * @return string The corrected itemtype.\n    */\n   public function handleDepreciation(string $itemtype): string {\n      $deprecated = Toolbox::isAPIDeprecated($itemtype);\n\n      if ($deprecated) {\n         // Keep a reference to deprecated item\n         $class = \"Glpi\\Api\\Deprecated\\\\$itemtype\";\n         $this->deprecated_item = new $class();\n\n         // Get correct itemtype\n         $itemtype = $this->deprecated_item->getType();\n      }\n\n      return $itemtype;\n   }\n\n   /**\n    * Check if the current call is using a deprecated item\n    *\n    * @return bool\n    */\n   public function isDeprecated(): bool {\n      return $this->deprecated_item !== null;\n   }\n}\n"], "fixing_code": ["<?php\n\n/**\n * ---------------------------------------------------------------------\n * GLPI - Gestionnaire Libre de Parc Informatique\n * Copyright (C) 2015-2020 Teclib' and contributors.\n *\n * http://glpi-project.org\n *\n * based on GLPI - Gestionnaire Libre de Parc Informatique\n * Copyright (C) 2003-2014 by the INDEPNET Development Team.\n *\n * ---------------------------------------------------------------------\n *\n * LICENSE\n *\n * This file is part of GLPI.\n *\n * GLPI is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * GLPI is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with GLPI. If not, see <http://www.gnu.org/licenses/>.\n * ---------------------------------------------------------------------\n */\n\n/**\n * @since 9.1\n */\n\nnamespace Glpi\\Api;\n\nuse APIClient;\nuse Auth;\nuse Change;\nuse CommonDevice;\nuse CommonGLPI;\nuse CommonITILObject;\nuse Config;\nuse Contract;\nuse Document;\nuse Dropdown;\nuse Glpi\\Exception\\ForgetPasswordException;\nuse Glpi\\Exception\\PasswordTooWeakException;\nuse Html;\nuse Infocom;\nuse Item_Devices;\nuse Log;\nuse Michelf\\MarkdownExtra;\nuse NetworkEquipment;\nuse NetworkPort;\nuse Notepad;\nuse Problem;\nuse QueryExpression;\nuse SavedSearch;\nuse Search;\nuse Session;\nuse Software;\nuse Ticket;\nuse Toolbox;\nuse User;\n\nabstract class API extends CommonGLPI {\n\n   // permit writing to $_SESSION\n   protected $session_write = false;\n\n   static $api_url = \"\";\n   static $content_type = \"application/json\";\n   protected $format;\n   protected $iptxt         = \"\";\n   protected $ipnum         = \"\";\n   protected $app_tokens    = [];\n   protected $apiclients_id = 0;\n   protected $deprecated_item = null;\n\n   /**\n    * First function used on api call\n    * Parse sended query/parameters and call the corresponding API::method\n    *\n    * @return void self::returnResponse called for output\n    */\n   abstract public function call();\n\n   /**\n    * Needed to transform params of called api in $this->parameters attribute\n    *\n    * @return string endpoint called\n    */\n   abstract protected function parseIncomingParams();\n\n   /**\n    * Generic messages\n    *\n    * @since 9.1\n    *\n    * @param mixed   $response          string message or array of data to send\n    * @param integer $httpcode          http code (see : https://en.wikipedia.org/wiki/List_of_HTTP_status_codes)\n    * @param array   $additionalheaders headers to send with http response (must be an array(key => value))\n    *\n    * @return void\n    */\n   abstract protected function returnResponse($response, $httpcode = 200, $additionalheaders = []);\n\n   /**\n    * Upload and validate files from request and append to $this->parameters['input']\n    *\n    * @return void\n    */\n   abstract protected function manageUploadedFiles();\n\n   /**\n    * Constructor\n    *\n    * @var array $CFG_GLPI\n    * @var DBmysql $DB\n    *\n    * @return void\n    */\n   public function initApi() {\n      global $CFG_GLPI;\n\n      // Load GLPI configuration\n      include_once (GLPI_ROOT . '/inc/includes.php');\n      $variables = get_defined_vars();\n      foreach ($variables as $var => $value) {\n         if ($var === strtoupper($var)) {\n            $GLOBALS[$var] = $value;\n         }\n      }\n\n      // construct api url\n      self::$api_url = trim($CFG_GLPI['url_base_api'], \"/\");\n\n      // Don't display error in result\n      ini_set('display_errors', 'Off');\n\n      // Avoid keeping messages between api calls\n      $_SESSION[\"MESSAGE_AFTER_REDIRECT\"] = [];\n\n      // check if api is enabled\n      if (!$CFG_GLPI['enable_api']) {\n         $this->returnError(__(\"API disabled\"), \"\", \"\", false);\n         exit;\n      }\n\n      // retrieve ip of client\n      $this->iptxt = Toolbox::getRemoteIpAddress();\n      $this->ipnum = (strstr($this->iptxt, ':')===false ? ip2long($this->iptxt) : '');\n\n      // check ip access\n      $apiclient = new APIClient;\n      $where_ip = [];\n      if ($this->ipnum) {\n         $where_ip = [\n            'OR' => [\n               'ipv4_range_start' => null,\n               [\n                  'ipv4_range_start'   => ['<=', $this->ipnum],\n                  'ipv4_range_end'     => ['>=', $this->ipnum]\n               ]\n            ]\n         ];\n      } else {\n         $where_ip = [\n            'OR' => [\n               ['ipv6'  => null],\n               ['ipv6'  => $this->iptxt]\n            ]\n         ];\n      }\n      $found_clients = $apiclient->find(['is_active' => 1] + $where_ip);\n      if (count($found_clients) <= 0) {\n         $this->returnError(__(\"There isn't an active API client matching your IP address in the configuration\").\n                            \" (\".$this->iptxt.\")\",\n                            \"\", \"ERROR_NOT_ALLOWED_IP\", false);\n      }\n      $app_tokens = array_column($found_clients, 'app_token');\n      $apiclients_id = array_column($found_clients, 'id');\n      $this->app_tokens = array_combine($apiclients_id, $app_tokens);\n   }\n\n   /**\n    * Set headers according to cross origin ressource sharing\n    *\n    * @param string $verb Http verb (GET, POST, PUT, DELETE, OPTIONS)\n    *\n    * @return void\n    */\n   protected function cors($verb = 'GET') {\n      if (isset($_SERVER['HTTP_ORIGIN'])) {\n         header(\"Access-Control-Allow-Origin: *\");\n      }\n\n      if ($this->verb == 'GET' || $this->verb == 'OPTIONS') {\n         header(\"Access-Control-Expose-Headers: content-type, content-range, accept-range\");\n      }\n\n      if ($this->verb == \"OPTIONS\") {\n         if (isset($_SERVER['HTTP_ACCESS_CONTROL_REQUEST_METHOD'])) {\n            header(\"Access-Control-Allow-Methods: PUT, GET, POST, DELETE, OPTIONS\");\n         }\n\n         if (isset($_SERVER['HTTP_ACCESS_CONTROL_REQUEST_HEADERS'])) {\n            header(\"Access-Control-Allow-Headers: \".\n                   \"origin, content-type, accept, session-token, authorization\");\n         }\n         exit(0);\n      }\n   }\n\n\n   /**\n    * Init GLPI Session\n    *\n    * @param array $params array with theses options :\n    *    - a couple 'name' & 'password' : 2 parameters to login with user authentication\n    *         OR\n    *    - an 'user_token' defined in User Configuration\n    *\n    * @return array with session_token\n    */\n   protected function initSession($params = []) {\n      global $CFG_GLPI;\n\n      $this->checkAppToken();\n      $this->logEndpointUsage(__FUNCTION__);\n\n      if ((!isset($params['login'])\n           || empty($params['login'])\n           || !isset($params['password'])\n           || empty($params['password']))\n         && (!isset($params['user_token'])\n             || empty($params['user_token']))) {\n         $this->returnError(__(\"parameter(s) login, password or user_token are missing\"), 400,\n                            \"ERROR_LOGIN_PARAMETERS_MISSING\");\n      }\n\n      $auth = new Auth();\n\n      // fill missing params (in case of user_token)\n      if (!isset($params['login'])) {\n         $params['login'] = '';\n      }\n      if (!isset($params['password'])) {\n         $params['password'] = '';\n      }\n\n      $noAuto = true;\n      if (isset($params['user_token']) && !empty($params['user_token'])) {\n         $_REQUEST['user_token'] = $params['user_token'];\n         $noAuto = false;\n\n      } else if (!$CFG_GLPI['enable_api_login_credentials']) {\n         $this->returnError(__(\"usage of initSession resource with credentials is disabled\"), 400,\n                            \"ERROR_LOGIN_WITH_CREDENTIALS_DISABLED\", false);\n      }\n\n      if (!isset($params['auth'])) {\n         $params['auth'] = '';\n      }\n\n      // login on glpi\n      if (!$auth->login($params['login'], $params['password'], $noAuto, false, $params['auth'])) {\n         $err = Html::clean($auth->getErr());\n         if (isset($params['user_token'])\n             && !empty($params['user_token'])) {\n            return $this->returnError(__(\"parameter user_token seems invalid\"), 401, \"ERROR_GLPI_LOGIN_USER_TOKEN\", false);\n         }\n         return $this->returnError($err, 401, \"ERROR_GLPI_LOGIN\", false);\n      }\n\n      // stop session and return session key\n      session_write_close();\n      $data = ['session_token' => $_SESSION['valid_id']];\n\n      // Insert session data if requested\n      $get_full_session = $params['get_full_session'] ?? false;\n      if ($get_full_session) {\n         $data['session'] = $_SESSION;\n      }\n\n      return $data;\n   }\n\n\n   /**\n    * Kill GLPI Session\n    * Use 'session_token' param in $this->parameters\n    *\n    * @return boolean\n    */\n   protected function killSession() {\n\n      $this->initEndpoint(false, __FUNCTION__);\n      return Session::destroy();\n   }\n\n\n   /**\n    * Retrieve GLPI Session initialised by initSession function\n    * Use 'session_token' param in $this->parameters\n    *\n    * @return void\n    */\n   protected function retrieveSession() {\n\n      if (isset($this->parameters['session_token'])\n          && !empty($this->parameters['session_token'])) {\n         $current = session_id();\n         $session = trim($this->parameters['session_token']);\n\n         if (file_exists(GLPI_ROOT . '/inc/downstream.php')) {\n            include_once (GLPI_ROOT . '/inc/downstream.php');\n         }\n\n         if ($session!=$current && !empty($current)) {\n            session_destroy();\n         }\n         if ($session!=$current && !empty($session)) {\n            session_id($session);\n         }\n      }\n   }\n\n\n   /**\n    * Change active entity to the entities_id one.\n    *\n    * @param array $params array with theses options :\n    *   - 'entities_id': (default 'all') ID of the new active entity (\"all\" = load all possible entities). Optionnal\n    *   - 'is_recursive': (default false) Also display sub entities of the active entity.  Optionnal\n    *\n    * @return array|bool\n    */\n   protected function changeActiveEntities($params = []) {\n\n      $this->initEndpoint();\n\n      if (!isset($params['entities_id'])) {\n         $entities_id = 'all';\n      } else {\n         $entities_id = intval($params['entities_id']);\n      }\n\n      if (!isset($params['is_recursive'])) {\n         $params['is_recursive'] = false;\n      } else if (!is_bool($params['is_recursive'])) {\n         return $this->returnError();\n      }\n\n      if (!Session::changeActiveEntities($entities_id, $params['is_recursive'])) {\n         return $this->returnError();\n      }\n\n      return true;\n   }\n\n\n   /**\n    * Return all the possible entity of the current logged user (and for current active profile)\n    *\n    * @param array $params array with theses options :\n    *   - 'is_recursive': (default false) Also display sub entities of the active entity. Optionnal\n    *\n    * @return array of entities (with id and name)\n    */\n   protected function getMyEntities($params = []) {\n\n      $this->initEndpoint();\n\n      if (!isset($params['is_recursive'])) {\n         $params['is_recursive'] = false;\n      }\n\n      $myentities = [];\n      foreach ($_SESSION['glpiactiveprofile']['entities'] as $entity) {\n         if ($entity['is_recursive'] == 1 && $params['is_recursive'] == 1) {\n            $sons = getSonsOf('glpi_entities', $entity['id']);\n            foreach ($sons as $entity_id) {\n               if ($entity_id != $entity['id']) {\n                  $myentities[] = ['id'   => $entity_id,\n                                   'name' => Dropdown::getDropdownName(\"glpi_entities\",\n                                                                       $entity_id)];\n               }\n            }\n         }\n         $myentities[] = ['id' => $entity['id'],\n                          'name' => Dropdown::getDropdownName(\"glpi_entities\",\n                                                                   $entity['id'])];\n      }\n      return ['myentities' => $myentities];\n   }\n\n\n\n\n   /**\n    * return active entities of current logged user\n    *\n    * @return array with 3 keys :\n    *  - active_entity : current set entity\n    *  - active_entity_recursive : boolean, if we see sons of this entity\n    *  - active_entities : array all active entities (active_entity and its sons)\n    */\n   protected function getActiveEntities() {\n\n      $this->initEndpoint();\n\n      $actives_entities = [];\n      foreach (array_values($_SESSION['glpiactiveentities']) as $active_entity) {\n         $actives_entities[] = ['id' => $active_entity];\n      }\n\n      return [\"active_entity\" => [\n                     \"id\"                      => $_SESSION['glpiactive_entity'],\n                     \"active_entity_recursive\" => $_SESSION['glpiactive_entity_recursive'],\n                     \"active_entities\"         => $actives_entities]];\n\n   }\n\n\n\n\n   /**\n    * set a profile to active\n    *\n    * @param array $params with theses options :\n    *    - profiles_id : identifier of profile to set\n    *\n    * @return boolean\n    */\n   protected function changeActiveProfile($params = []) {\n\n      $this->initEndpoint();\n\n      if (!isset($params['profiles_id'])) {\n         $this->returnError();\n      }\n\n      $profiles_id = intval($params['profiles_id']);\n      if (isset($_SESSION['glpiprofiles'][$profiles_id])) {\n         return Session::changeProfile($profiles_id);\n      }\n\n      $this->messageNotfoundError();\n   }\n\n\n\n\n   /**\n    * Return all the profiles associated to logged user\n    *\n    * @return array of profiles (with associated rights)\n    */\n   protected function getMyProfiles() {\n\n      $this->initEndpoint();\n\n      $myprofiles = [];\n      foreach ($_SESSION['glpiprofiles'] as $profiles_id => $profile) {\n         // append if of the profile into values\n         $profile = ['id' => $profiles_id] + $profile;\n\n         // don't keep keys for entities\n         $profile['entities'] = array_values($profile['entities']);\n\n         // don't keep keys for profiles\n         $myprofiles[] = $profile;\n      }\n      return ['myprofiles' => $myprofiles];\n   }\n\n\n\n\n   /**\n    * Return the current active profile\n    *\n    * @return integer the profiles_id\n    */\n   protected function getActiveProfile() {\n\n      $this->initEndpoint();\n      return [\"active_profile\" => $_SESSION['glpiactiveprofile']];\n   }\n\n\n\n\n   /**\n    * Return the current php $_SESSION\n    *\n    * @return array\n    */\n   protected function getFullSession() {\n\n      $this->initEndpoint();\n      return ['session' => $_SESSION];\n   }\n\n\n\n   /**\n    * Return the current $CFG_GLPI\n    *\n    * @return array\n     */\n   protected function getGlpiConfig() {\n      $this->initEndpoint();\n\n      return ['cfg_glpi' => Config::getSafeConfig()];\n   }\n\n\n   /**\n    * Return the instance fields of itemtype identified by id\n    *\n    * @param string  $itemtype itemtype (class) of object\n    * @param integer $id       identifier of object\n    * @param array   $params   with theses options :\n    *    - 'expand_dropdowns': Show dropdown's names instead of id. default: false. Optionnal\n    *    - 'get_hateoas':      Show relation of current item in a links attribute. default: true. Optionnal\n    *    - 'get_sha1':         Get a sha1 signature instead of the full answer. default: false. Optionnal\n    *    - 'with_devices':  Only for [Computer, NetworkEquipment, Peripheral, Phone, Printer], Optionnal.\n    *    - 'with_disks':       Only for Computer, retrieve the associated filesystems. Optionnal.\n    *    - 'with_softwares':   Only for Computer, retrieve the associated softwares installations. Optionnal.\n    *    - 'with_connections': Only for Computer, retrieve the associated direct connections (like peripherals and printers) .Optionnal.\n    *    - 'with_networkports':Retrieve all network connections and advanced network informations. Optionnal.\n    *    - 'with_infocoms':    Retrieve financial and administrative informations. Optionnal.\n    *    - 'with_contracts':   Retrieve associated contracts. Optionnal.\n    *    - 'with_documents':   Retrieve associated external documents. Optionnal.\n    *    - 'with_tickets':     Retrieve associated itil tickets. Optionnal.\n    *    - 'with_problems':    Retrieve associated itil problems. Optionnal.\n    *    - 'with_changes':     Retrieve associated itil changes. Optionnal.\n    *    - 'with_notes':       Retrieve Notes (if exists, not all itemtypes have notes). Optionnal.\n    *    - 'with_logs':        Retrieve historical. Optionnal.\n    *    - 'add_keys_names':   Get friendly names. Optionnal.\n    *\n    * @return array    fields of found object\n    */\n   protected function getItem($itemtype, $id, $params = []) {\n      global $CFG_GLPI, $DB;\n\n      $this->initEndpoint();\n      $itemtype = $this->handleDepreciation($itemtype);\n\n      // default params\n      $default = ['expand_dropdowns'  => false,\n                       'get_hateoas'       => true,\n                       'get_sha1'          => false,\n                       'with_devices'   => false,\n                       'with_disks'        => false,\n                       'with_softwares'    => false,\n                       'with_connections'  => false,\n                       'with_networkports' => false,\n                       'with_infocoms'     => false,\n                       'with_contracts'    => false,\n                       'with_documents'    => false,\n                       'with_tickets'      => false,\n                       'with_problems'     => false,\n                       'with_changes'      => false,\n                       'with_notes'        => false,\n                       'with_logs'         => false,\n                       'add_keys_names'    => [],\n      ];\n      $params = array_merge($default, $params);\n\n      $item = new $itemtype;\n      if (!$item->getFromDB($id)) {\n         return $this->messageNotfoundError();\n      }\n      if (!$item->can($id, READ)) {\n         return $this->messageRightError();\n      }\n\n      $fields = $item->fields;\n\n      // avoid disclosure of critical fields\n      $item::unsetUndisclosedFields($fields);\n\n      // retrieve devices\n      if (isset($params['with_devices'])\n          && $params['with_devices']\n          && in_array($itemtype, Item_Devices::getConcernedItems())) {\n         $all_devices = [];\n         foreach (Item_Devices::getItemAffinities($item->getType()) as $device_type) {\n            $found_devices = getAllDataFromTable(\n               $device_type::getTable(), [\n                  'items_id'     => $item->getID(),\n                  'itemtype'     => $item->getType(),\n                  'is_deleted'   => 0\n               ],\n               true\n            );\n\n            foreach ($found_devices as &$device) {\n               unset($device['items_id']);\n               unset($device['itemtype']);\n               unset($device['is_deleted']);\n            }\n\n            if (!empty($found_devices)) {\n               $all_devices[$device_type] = $found_devices;\n            }\n         }\n         $fields['_devices'] = $all_devices;\n      }\n\n      // retrieve computer disks\n      if (isset($params['with_disks'])\n          && $params['with_disks']\n          && in_array($itemtype, $CFG_GLPI['itemdeviceharddrive_types'])) {\n         // build query to retrive filesystems\n         $fs_iterator = $DB->request([\n            'SELECT'    => [\n               'glpi_filesystems.name AS fsname',\n               'glpi_items_disks.*'\n            ],\n            'FROM'      => 'glpi_items_disks',\n            'LEFT JOIN'  => [\n               'glpi_filesystems' => [\n                  'ON' => [\n                     'glpi_items_disks'   => 'filesystems_id',\n                     'glpi_filesystems'   => 'id'\n                  ]\n               ]\n            ],\n            'WHERE'     => [\n               'items_id'     => $id,\n               'itemtype'     => $itemtype,\n               'is_deleted'   => 0\n            ]\n         ]);\n         $fields['_disks'] = [];\n         while ($data = $fs_iterator->next()) {\n            unset($data['items_id']);\n            unset($data['is_deleted']);\n            $fields['_disks'][] = ['name' => $data];\n         }\n      }\n\n      // retrieve computer softwares\n      if (isset($params['with_softwares'])\n            && $params['with_softwares']\n            && in_array($itemtype, $CFG_GLPI['software_types'])) {\n         $fields['_softwares'] = [];\n         if (!Software::canView()) {\n            $fields['_softwares'] = $this->arrayRightError();\n         } else {\n            $soft_iterator = $DB->request([\n               'SELECT'    => [\n                  'glpi_softwares.softwarecategories_id',\n                  'glpi_softwares.id AS softwares_id',\n                  'glpi_softwareversions.id AS softwareversions_id',\n                  'glpi_items_softwareversions.is_dynamic',\n                  'glpi_softwareversions.states_id',\n                  'glpi_softwares.is_valid'\n               ],\n               'FROM'      => 'glpi_items_softwareversions',\n               'LEFT JOIN' => [\n                  'glpi_softwareversions' => [\n                     'ON' => [\n                        'glpi_items_softwareversions' => 'softwareversions_id',\n                        'glpi_softwareversions'       => 'id'\n                     ]\n                  ],\n                  'glpi_softwares'        => [\n                     'ON' => [\n                        'glpi_softwareversions' => 'softwares_id',\n                        'glpi_softwares'        => 'id'\n                     ]\n                  ]\n               ],\n               'WHERE'     => [\n                  'glpi_items_softwareversions.items_id'   => $id,\n                  'glpi_items_softwareversions.itemtype'   => $itemtype,\n                  'glpi_items_softwareversions.is_deleted' => 0\n               ],\n               'ORDERBY'   => [\n                  'glpi_softwares.name',\n                  'glpi_softwareversions.name'\n               ]\n            ]);\n            while ($data = $soft_iterator->next()) {\n               $fields['_softwares'][] = $data;\n            }\n         }\n      }\n\n      // retrieve item connections\n      if (isset($params['with_connections'])\n          && $params['with_connections']\n          && $itemtype == \"Computer\") {\n         $fields['_connections'] = [];\n         foreach ($CFG_GLPI[\"directconnect_types\"] as $connect_type) {\n            $connect_item = new $connect_type();\n            if ($connect_item->canView()) {\n               $connect_table = getTableForItemType($connect_type);\n               $iterator = $DB->request([\n                  'SELECT'    => [\n                     'glpi_computers_items.id AS assoc_id',\n                     'glpi_computers_items.computers_id AS assoc_computers_id',\n                     'glpi_computers_items.itemtype AS assoc_itemtype',\n                     'glpi_computers_items.items_id AS assoc_items_id',\n                     'glpi_computers_items.is_dynamic AS assoc_is_dynamic',\n                     \"$connect_table.*\"\n                  ],\n                  'FROM'      => 'glpi_computers_items',\n                  'LEFT JOIN' => [\n                     $connect_table => [\n                        'ON' => [\n                           'glpi_computers_items'  => 'items_id',\n                           $connect_table          => 'id'\n                        ]\n                     ]\n                  ],\n                  'WHERE'     => [\n                     'computers_id'                      => $id,\n                     'itemtype'                          => $connect_type,\n                     'glpi_computers_items.is_deleted'   => 0\n                  ]\n               ]);\n               while ($data = $iterator->next()) {\n                  $fields['_connections'][$connect_type][] = $data;\n               }\n            }\n         }\n      }\n\n      // retrieve item networkports\n      if (isset($params['with_networkports'])\n          && $params['with_networkports']) {\n         $fields['_networkports'] = [];\n         if (!NetworkEquipment::canView()) {\n            $fields['_networkports'] = $this->arrayRightError();\n         } else {\n            foreach (NetworkPort::getNetworkPortInstantiations() as $networkport_type) {\n               $netport_table = $networkport_type::getTable();\n               $netp_iterator = $DB->request([\n                  'SELECT'    => [\n                     'netp.id AS netport_id',\n                     'netp.entities_id',\n                     'netp.is_recursive',\n                     'netp.logical_number',\n                     'netp.name',\n                     'netp.mac',\n                     'netp.comment',\n                     'netp.is_dynamic',\n                     'netp_subtable.*'\n                  ],\n                  'FROM'      => 'glpi_networkports AS netp',\n                  'LEFT JOIN' => [\n                     \"$netport_table AS netp_subtable\" => [\n                        'ON' => [\n                           'netp_subtable'   => 'networkports_id',\n                           'netp'            => 'id'\n                        ]\n                     ]\n                  ],\n                  'WHERE'     => [\n                     'netp.instantiation_type'  => $networkport_type,\n                     'netp.items_id'            => $id,\n                     'netp.itemtype'            => $itemtype,\n                     'netp.is_deleted'          => 0\n                  ]\n               ]);\n\n               while ($data = $netp_iterator->next()) {\n                  if (isset($data['netport_id'])) {\n                     // append network name\n                     $concat_expr = new QueryExpression(\n                        \"GROUP_CONCAT(CONCAT(\".$DB->quoteName('ipadr.id').\", \".$DB->quoteValue(Search::SHORTSEP).\" , \".$DB->quoteName('ipadr.name').\")\n                        SEPARATOR \".$DB->quoteValue(Search::LONGSEP).\") AS \".$DB->quoteName('ipadresses')\n                     );\n                     $netn_iterator = $DB->request([\n                        'SELECT'    => [\n                           $concat_expr,\n                           'netn.id AS networknames_id',\n                           'netn.name AS networkname',\n                           'netn.fqdns_id',\n                           'fqdn.name AS fqdn_name',\n                           'fqdn.fqdn'\n                        ],\n                        'FROM'      => [\n                           'glpi_networknames AS netn'\n                        ],\n                        'LEFT JOIN' => [\n                           'glpi_ipaddresses AS ipadr'               => [\n                              'ON' => [\n                                 'ipadr'  => 'items_id',\n                                 'netn'   => 'id',\n                                 [\n                                    'AND' => ['ipadr.itemtype' => 'NetworkName']\n                                 ]\n                              ]\n                           ],\n                           'glpi_fqdns AS fqdn'                      => [\n                              'ON' => [\n                                 'fqdn'   => 'id',\n                                 'netn'   => 'fqdns_id'\n                              ]\n                           ],\n                           'glpi_ipaddresses_ipnetworks AS ipadnet'  => [\n                              'ON' => [\n                                 'ipadnet'   => 'ipaddresses_id',\n                                 'ipadr'     => 'id'\n                              ]\n                           ],\n                           'glpi_ipnetworks AS ipnet'                => [\n                              'ON' => [\n                                 'ipnet'     => 'id',\n                                 'ipadnet'   => 'ipnetworks_id'\n                              ]\n                           ]\n                        ],\n                        'WHERE'     => [\n                           'netn.itemtype'   => 'NetworkPort',\n                           'netn.items_id'   => $data['netport_id']\n                        ],\n                        'GROUPBY'   => [\n                           'netn.id',\n                           'netn.name',\n                           'netn.fqdns_id',\n                           'fqdn.name',\n                           'fqdn.fqdn'\n                        ]\n                     ]);\n\n                     if (count($netn_iterator)) {\n                        $data_netn = $netn_iterator->next();\n\n                        $raw_ipadresses = explode(Search::LONGSEP, $data_netn['ipadresses']);\n                        $ipadresses = [];\n                        foreach ($raw_ipadresses as $ipadress) {\n                           $ipadress = explode(Search::SHORTSEP, $ipadress);\n\n                           //find ip network attached to these ip\n                           $ipnetworks = [];\n                           $ipnet_iterator = $DB->request([\n                              'SELECT'       => [\n                                 'ipnet.id',\n                                 'ipnet.completename',\n                                 'ipnet.name',\n                                 'ipnet.address',\n                                 'ipnet.netmask',\n                                 'ipnet.gateway',\n                                 'ipnet.ipnetworks_id',\n                                 'ipnet.comment'\n                              ],\n                              'FROM'         => 'glpi_ipnetworks AS ipnet',\n                              'INNER JOIN'   => [\n                                 'glpi_ipaddresses_ipnetworks AS ipadnet' => [\n                                    'ON' => [\n                                       'ipadnet'   => 'ipnetworks_id',\n                                       'ipnet'     => 'id'\n                                    ]\n                                 ]\n                              ],\n                              'WHERE'        => [\n                                 'ipadnet.ipaddresses_id'  => $ipadress[0]\n                              ]\n                           ]);\n                           while ($data_ipnet = $ipnet_iterator->next()) {\n                              $ipnetworks[] = $data_ipnet;\n                           }\n\n                           $ipadresses[] = [\n                              'id'        => $ipadress[0],\n                              'name'      => $ipadress[1],\n                              'IPNetwork' => $ipnetworks\n                           ];\n                        }\n\n                        $data['NetworkName'] = [\n                           'id'         => $data_netn['networknames_id'],\n                           'name'       => $data_netn['networkname'],\n                           'fqdns_id'   => $data_netn['fqdns_id'],\n                           'FQDN'       => [\n                              'id'   => $data_netn['fqdns_id'],\n                              'name' => $data_netn['fqdn_name'],\n                              'fqdn' => $data_netn['fqdn']\n                           ],\n                           'IPAddress' => $ipadresses\n                        ];\n                     }\n                  }\n\n                  $fields['_networkports'][$networkport_type][] = $data;\n               }\n            }\n         }\n      }\n\n      // retrieve item infocoms\n      if (isset($params['with_infocoms'])\n          && $params['with_infocoms']) {\n         $fields['_infocoms'] = [];\n         if (!Infocom::canView()) {\n            $fields['_infocoms'] = $this->arrayRightError();\n         } else {\n            $ic = new Infocom();\n            if ($ic->getFromDBforDevice($itemtype, $id)) {\n               $fields['_infocoms'] = $ic->fields;\n            }\n         }\n      }\n\n      // retrieve item contracts\n      if (isset($params['with_contracts'])\n          && $params['with_contracts']) {\n         $fields['_contracts'] = [];\n         if (!Contract::canView()) {\n            $fields['_contracts'] = $this->arrayRightError();\n         } else {\n            $iterator = $DB->request([\n               'SELECT'    => ['glpi_contracts_items.*'],\n               'FROM'      => 'glpi_contracts_items',\n               'LEFT JOIN' => [\n                  'glpi_contracts'  => [\n                     'ON' => [\n                        'glpi_contracts_items'  => 'contracts_id',\n                        'glpi_contracts'        => 'id'\n                     ]\n                  ],\n                  'glpi_entities'   => [\n                     'ON' => [\n                        'glpi_contracts_items'  => 'entities_id',\n                        'glpi_entities'         => 'id'\n                     ]\n                  ]\n               ],\n               'WHERE'     => [\n                  'glpi_contracts_items.items_id'  => $id,\n                  'glpi_contracts_items.itemtype'  => $itemtype\n               ] + getEntitiesRestrictCriteria('glpi_contracts', '', '', true),\n               'ORDERBY'   => 'glpi_contracts.name'\n            ]);\n            while ($data = $iterator->next()) {\n               $fields['_contracts'][] = $data;\n            }\n         }\n      }\n\n      // retrieve item documents\n      if (isset($params['with_documents'])\n          && $params['with_documents']) {\n         $fields['_documents'] = [];\n         if (!($item instanceof CommonITILObject)\n             && $itemtype != 'KnowbaseItem'\n             && $itemtype != 'Reminder'\n             && !Document::canView()) {\n            $fields['_documents'] = $this->arrayRightError();\n         } else {\n            $doc_criteria = [\n               'glpi_documents_items.items_id'  => $id,\n               'glpi_documents_items.itemtype'  => $itemtype\n            ];\n            if ($item instanceof CommonITILObject) {\n               $doc_criteria = [\n                  $item->getAssociatedDocumentsCriteria(),\n                  'timeline_position' => ['>', CommonITILObject::NO_TIMELINE], // skip inlined images\n               ];\n            }\n            $doc_iterator = $DB->request([\n               'SELECT'    => [\n                  'glpi_documents_items.id AS assocID',\n                  'glpi_documents_items.date_creation AS assocdate',\n                  'glpi_entities.id AS entityID',\n                  'glpi_entities.completename AS entity',\n                  'glpi_documentcategories.completename AS headings',\n                  'glpi_documents.*'\n               ],\n               'FROM'      => 'glpi_documents_items',\n               'LEFT JOIN' => [\n                  'glpi_documents'           => [\n                     'ON' => [\n                        'glpi_documents_items'  => 'documents_id',\n                        'glpi_documents'        => 'id'\n                     ]\n                  ],\n                  'glpi_entities'            => [\n                     'ON' => [\n                        'glpi_documents'  => 'entities_id',\n                        'glpi_entities'   => 'id'\n                     ]\n                  ],\n                  'glpi_documentcategories'  => [\n                     'ON' => [\n                        'glpi_documents'           => 'documentcategories_id',\n                        'glpi_documentcategories'  => 'id'\n                     ]\n                  ]\n               ],\n               'WHERE'     => $doc_criteria,\n            ]);\n            while ($data = $doc_iterator->next()) {\n               $fields['_documents'][] = $data;\n            }\n         }\n      }\n\n      // retrieve item tickets\n      if (isset($params['with_tickets'])\n          && $params['with_tickets']) {\n         $fields['_tickets'] = [];\n         if (!Ticket::canView()) {\n            $fields['_tickets'] = $this->arrayRightError();\n         } else {\n            $criteria = Ticket::getCommonCriteria();\n            $criteria['WHERE'] = [\n               'glpi_items_tickets.items_id' => $id,\n               'glpi_items_tickets.itemtype' => $itemtype\n            ] + getEntitiesRestrictCriteria(Ticket::getTable());\n            $iterator = $DB->request($criteria);\n            while ($data = $iterator->next()) {\n               $fields['_tickets'][] = $data;\n            }\n         }\n      }\n\n      // retrieve item problems\n      if (isset($params['with_problems'])\n          && $params['with_problems']) {\n         $fields['_problems'] = [];\n         if (!Problem::canView()) {\n            $fields['_problems'] = $this->arrayRightError();\n         } else {\n            $criteria = Problem::getCommonCriteria();\n            $criteria['WHERE'] = [\n               'glpi_items_problems.items_id' => $id,\n               'glpi_items_problems.itemtype' => $itemtype\n            ] + getEntitiesRestrictCriteria(Problem::getTable());\n            $iterator = $DB->request($criteria);\n            while ($data = $iterator->next()) {\n               $fields['_problems'][] = $data;\n            }\n         }\n      }\n\n      // retrieve item changes\n      if (isset($params['with_changes'])\n          && $params['with_changes']) {\n         $fields['_changes'] = [];\n         if (!Change::canView()) {\n            $fields['_changes'] = $this->arrayRightError();\n         } else {\n            $criteria = Change::getCommonCriteria();\n            $criteria['WHERE'] = [\n               'glpi_changes_items.items_id' => $id,\n               'glpi_changes_items.itemtype' => $itemtype\n            ] + getEntitiesRestrictCriteria(Change::getTable());\n            $iterator = $DB->request($criteria);\n            while ($data = $iterator->next()) {\n               $fields['_changes'][] = $data;\n            }\n         }\n      }\n\n      // retrieve item notes\n      if (isset($params['with_notes'])\n          && $params['with_notes']) {\n         $fields['_notes'] = [];\n         if (!Session::haveRight($itemtype::$rightname, READNOTE)) {\n            $fields['_notes'] = $this->arrayRightError();\n         } else {\n            $fields['_notes'] = Notepad::getAllForItem($item);\n         }\n      }\n\n      // retrieve item logs\n      if (isset($params['with_logs'])\n          && $params['with_logs']) {\n         $fields['_logs'] = [];\n         if (!Session::haveRight($itemtype::$rightname, READNOTE)) {\n            $fields['_logs'] = $this->arrayRightError();\n         } else {\n            $fields['_logs'] = getAllDataFromTable(\n               \"glpi_logs\", [\n                  'items_id'  => $item->getID(),\n                  'itemtype'  => $item->getType()\n               ]\n            );\n         }\n      }\n\n      // expand dropdown (retrieve name of dropdowns) and get hateoas from foreign keys\n      $fields = self::parseDropdowns($fields, $params);\n\n      // get hateoas from children\n      if ($params['get_hateoas']) {\n         $hclasses = self::getHatoasClasses($itemtype);\n         foreach ($hclasses as $hclass) {\n            $fields['links'][] = ['rel'  => $hclass,\n                                       'href' => self::$api_url.\"/$itemtype/\".$item->getID().\"/$hclass/\"];\n         }\n      }\n\n      // get sha1 footprint if needed\n      if ($params['get_sha1']) {\n         $fields = sha1(json_encode($fields, JSON_UNESCAPED_UNICODE\n                                             | JSON_UNESCAPED_SLASHES\n                                             | JSON_NUMERIC_CHECK));\n      }\n\n      if (count($params['add_keys_names']) > 0) {\n         $fields[\"_keys_names\"] = $this->getFriendlyNames(\n            $fields,\n            $params,\n            $itemtype\n         );\n      }\n\n      // Convert fields to the format expected by the deprecated type\n      if ($this->isDeprecated()) {\n         $fields = $this->deprecated_item->mapCurrentToDeprecatedFields($fields);\n         $fields[\"links\"] = $this->deprecated_item->mapCurrentToDeprecatedHateoas(\n            $fields[\"links\"] ?? []\n         );\n      }\n\n      return $fields;\n   }\n\n\n\n   /**\n    * Fill a sub array with a right error\n    *\n    * @return array\n    */\n   protected function arrayRightError() {\n\n      return ['error'   => 401,\n                   'message' => __(\"You don't have permission to perform this action.\")];\n   }\n\n\n\n\n\n   /**\n    * Return a collection of rows of the desired itemtype\n    *\n    * @param string  $itemtype   itemtype (class) of object\n    * @param array   $params     with theses options :\n    * - 'expand_dropdowns' (default: false): show dropdown's names instead of id. Optionnal\n    * - 'get_hateoas'      (default: true): show relations of items in a links attribute. Optionnal\n    * - 'only_id'          (default: false): keep only id in fields list. Optionnal\n    * - 'range'            (default: 0-50): limit the list to start-end attributes\n    * - 'sort'             (default: id): sort by the field.\n    * - 'order'            (default: ASC): ASC(ending) or DESC(ending).\n    * - 'searchText'       (default: NULL): array of filters to pass on the query (with key = field and value the search)\n    * - 'is_deleted'       (default: false): show trashbin. Optionnal\n    * - 'add_keys_names'   (default: []): insert raw name(s) for given itemtype(s) and fkey(s)\n    * @param integer $totalcount output parameter who receive the total count of the query resulat.\n    *                            As this function paginate results (with a mysql LIMIT),\n    *                            we can have the full range. (default 0)\n    *\n    * @return array collection of fields\n    */\n   protected function getItems($itemtype, $params = [], &$totalcount = 0) {\n      global $DB;\n\n      $this->initEndpoint();\n      $itemtype = $this->handleDepreciation($itemtype);\n\n      // default params\n      $default = ['expand_dropdowns' => false,\n                       'get_hateoas'      => true,\n                       'only_id'          => false,\n                       'range'            => \"0-\".$_SESSION['glpilist_limit'],\n                       'sort'             => \"id\",\n                       'order'            => \"ASC\",\n                       'searchText'       => null,\n                       'is_deleted'       => false,\n                       'add_keys_names'   => [],\n      ];\n      $params = array_merge($default, $params);\n\n      if (!$itemtype::canView()) {\n         return $this->messageRightError();\n      }\n\n      $found = [];\n      $item = new $itemtype();\n      $item->getEmpty();\n      $table = getTableForItemType($itemtype);\n\n      // transform range parameter in start and limit variables\n      if (isset($params['range']) > 0) {\n         if (preg_match(\"/^[0-9]+-[0-9]+\\$/\", $params['range'])) {\n            $range = explode(\"-\", $params['range']);\n            $params['start']      = $range[0];\n            $params['list_limit'] = $range[1]-$range[0]+1;\n            $params['range']      = $range;\n         } else {\n            $this->returnError(\"range must be in format : [start-end] with integers\");\n         }\n      } else {\n         $params['range'] = [0, $_SESSION['glpilist_limit']];\n      }\n\n      // check parameters\n      if (isset($params['order'])\n          && !in_array(strtoupper($params['order']), ['DESC', 'ASC'])) {\n         $this->returnError(\"order must be DESC or ASC\");\n      }\n      if (!isset($item->fields[$params['sort']])) {\n         $this->returnError(\"sort param is not a field of $table\");\n      }\n\n      //specific case for restriction\n      $already_linked_table = [];\n      $join = Search::addDefaultJoin($itemtype, $table, $already_linked_table);\n      $where = Search::addDefaultWhere($itemtype);\n      if ($where == '') {\n         $where = \"1=1 \";\n      }\n      if ($item->maybeDeleted()) {\n         $where.= \"AND \".$DB->quoteName(\"$table.is_deleted\").\" = \".(int)$params['is_deleted'];\n      }\n\n      // add filter for a parent itemtype\n      if (isset($this->parameters['parent_itemtype'])\n          && isset($this->parameters['parent_id'])) {\n\n         // check parent itemtype\n         if (!Toolbox::isCommonDBTM($this->parameters['parent_itemtype'])\n            && !Toolbox::isAPIDeprecated($this->parameters['parent_itemtype'])\n         ) {\n            $this->returnError(__(\"parent itemtype not found or not an instance of CommonDBTM\"),\n                               400,\n                               \"ERROR_ITEMTYPE_NOT_FOUND_NOR_COMMONDBTM\");\n         }\n\n         $fk_parent = getForeignKeyFieldForItemType($this->parameters['parent_itemtype']);\n         $fk_child = getForeignKeyFieldForItemType($itemtype);\n\n         // check parent rights\n         $parent_item = new $this->parameters['parent_itemtype'];\n         if (!$parent_item->getFromDB($this->parameters['parent_id'])) {\n            return $this->messageNotfoundError();\n         }\n         if (!$parent_item->can($this->parameters['parent_id'], READ)) {\n            return $this->messageRightError();\n         }\n\n         // filter with parents fields\n         if (isset($item->fields[$fk_parent])) {\n            $where.= \" AND \".$DB->quoteName(\"$table.$fk_parent\").\" = \".(int)$this->parameters['parent_id'];\n         } else if (isset($item->fields['itemtype'])\n                 && isset($item->fields['items_id'])) {\n            $where.= \" AND \".$DB->quoteName(\"$table.itemtype\").\" = \".$DB->quoteValue($this->parameters['parent_itemtype']).\"\n                       AND \".$DB->quoteName(\"$table.items_id\").\" = \".(int)$this->parameters['parent_id'];\n         } else if (isset($parent_item->fields[$fk_child])) {\n            $parentTable = getTableForItemType($this->parameters['parent_itemtype']);\n            $join.= \" LEFT JOIN \".$DB->quoteName($parentTable).\" ON \".$DB->quoteName(\"$parentTable.$fk_child\").\" = \".$DB->quoteName(\"$table.id\");\n            $where.= \" AND \".$DB->quoteName(\"$parentTable.id\").\" = \" . (int)$this->parameters['parent_id'];\n         } else if (isset($parent_item->fields['itemtype'])\n                 && isset($parent_item->fields['items_id'])) {\n            $parentTable = getTableForItemType($this->parameters['parent_itemtype']);\n            $join.= \" LEFT JOIN \".$DB->quoteName($parentTable).\" ON \".$DB->quoteName(\"itemtype\").\"=\".$DB->quoteValue($itemtype).\" AND \".$DB->quoteName(\"$parentTable.items_id\").\" = \".$DB->quoteName(\"$table.id\");\n            $where.= \" AND \".$DB->quoteName(\"$parentTable.id\").\" = \" . (int)$this->parameters['parent_id'];\n         }\n      }\n\n      // filter by searchText parameter\n      if (is_array($params['searchText'])) {\n         if (array_keys($params['searchText']) == ['all']) {\n            $labelfield = \"name\";\n            if ($item instanceof CommonDevice) {\n               $labelfield = \"designation\";\n            } else if ($item instanceof Item_Devices) {\n               $labelfield = \"itemtype\";\n            }\n            $search_value                      = $params['searchText']['all'];\n            $params['searchText'][$labelfield] = $search_value;\n            if ($DB->fieldExists($table, 'comment')) {\n               $params['searchText']['comment'] = $search_value;\n            }\n         }\n\n         // make text search\n         foreach ($params['searchText']  as $filter_field => $filter_value) {\n            if (!empty($filter_value)) {\n               $search_value = Search::makeTextSearch($DB->escape($filter_value));\n               $where.= \" AND (\".$DB->quoteName(\"$table.$filter_field\").\" $search_value)\";\n            }\n         }\n      }\n\n      // filter with entity\n      if ($item->isEntityAssign()\n          // some CommonDBChild classes may not have entities_id fields and isEntityAssign still return true (like ITILTemplateMandatoryField)\n          && array_key_exists('entities_id', $item->fields)) {\n         $where.= \" AND (\". getEntitiesRestrictRequest(\"\",\n                                             $itemtype::getTable(),\n                                             '',\n                                             $_SESSION['glpiactiveentities'],\n                                             $item->maybeRecursive(),\n                                             true);\n\n         if ($item instanceof SavedSearch) {\n            $where.= \" OR \".$itemtype::getTable().\".is_private = 1\";\n         }\n\n         $where.= \")\";\n      }\n\n      // Check if we need to add raw names later on\n      $add_keys_names = count($params['add_keys_names']) > 0;\n\n      // build query\n      $query = \"SELECT DISTINCT \".$DB->quoteName(\"$table.id\").\",  \".$DB->quoteName(\"$table.*\").\"\n                FROM \".$DB->quoteName($table).\"\n                $join\n                WHERE $where\n                ORDER BY \".$DB->quoteName($params['sort']).\" \".$params['order'].\"\n                LIMIT \".(int)$params['start'].\", \".(int)$params['list_limit'];\n      if ($result = $DB->query($query)) {\n         while ($data = $DB->fetchAssoc($result)) {\n            if ($add_keys_names) {\n               // Insert raw names into the data row\n               $data[\"_keys_names\"] = $this->getFriendlyNames(\n                  $data,\n                  $params,\n                  $itemtype\n               );\n            }\n\n            $found[] = $data;\n         }\n      }\n\n      // get result full row counts\n      $count_query = \"SELECT COUNT(*) FROM {$DB->quoteName($table)} $join WHERE $where\";\n      $totalcount = $DB->query($count_query)->fetch_row()[0];\n\n      if ($params['range'][0] > $totalcount) {\n         $this->returnError(\"Provided range exceed total count of data: \".$totalcount,\n                            400,\n                            \"ERROR_RANGE_EXCEED_TOTAL\");\n      }\n\n      foreach ($found as &$fields) {\n         // only keep id in field list\n         if ($params['only_id']) {\n            $fields = ['id' => $fields['id']];\n         }\n\n         // avioid disclosure of critical fields\n         $item::unsetUndisclosedFields($fields);\n\n         // expand dropdown (retrieve name of dropdowns) and get hateoas\n         $fields = self::parseDropdowns($fields, $params);\n\n         // get hateoas from children\n         if ($params['get_hateoas']) {\n            $hclasses = self::getHatoasClasses($itemtype);\n            foreach ($hclasses as $hclass) {\n               $fields['links'][] = ['rel' => $hclass,\n                                          'href' => self::$api_url.\"/$itemtype/\".$fields['id'].\"/$hclass/\"];\n            }\n         }\n      }\n      // Break reference\n      unset($fields);\n\n      // Map values for deprecated itemtypes\n      if ($this->isDeprecated()) {\n         $found = array_map(function($fields) {\n            return $this->deprecated_item->mapCurrentToDeprecatedFields($fields);\n         }, $found);\n      }\n\n      return array_values($found);\n   }\n\n   /**\n    * Return a collection of items queried in input ($items)\n    *\n    * Call self::getItem for each line of $items\n    *\n    * @param array $params with theses options :\n    *    - items:               array containing lines with itemtype and items_id keys\n    *                               Ex: [\n    *                                      [itemtype => 'Ticket', id => 102],\n    *                                      [itemtype => 'User',   id => 10],\n    *                                      [itemtype => 'User',   id => 11],\n    *                                   ]\n    *    - 'expand_dropdowns':  Show dropdown's names instead of id. default: false. Optionnal\n    *    - 'get_hateoas':       Show relation of current item in a links attribute. default: true. Optionnal\n    *    - 'get_sha1':          Get a sha1 signature instead of the full answer. default: false. Optionnal\n    *    - 'with_devices':   Only for [Computer, NetworkEquipment, Peripheral, Phone, Printer], Optionnal.\n    *    - 'with_disks':        Only for Computer, retrieve the associated filesystems. Optionnal.\n    *    - 'with_softwares':    Only for Computer, retrieve the associated softwares installations. Optionnal.\n    *    - 'with_connections':  Only for Computer, retrieve the associated direct connections (like peripherals and printers) .Optionnal.\n    *    - 'with_networkports': Retrieve all network connections and advanced network informations. Optionnal.\n    *    - 'with_infocoms':     Retrieve financial and administrative informations. Optionnal.\n    *    - 'with_contracts':    Retrieve associated contracts. Optionnal.\n    *    - 'with_documents':    Retrieve associated external documents. Optionnal.\n    *    - 'with_tickets':      Retrieve associated itil tickets. Optionnal.\n    *    - 'with_problems':     Retrieve associated itil problems. Optionnal.\n    *    - 'with_changes':      Retrieve associated itil changes. Optionnal.\n    *    - 'with_notes':        Retrieve Notes (if exists, not all itemtypes have notes). Optionnal.\n    *    - 'with_logs':         Retrieve historical. Optionnal.\n    *\n    * @return array collection of glpi object's fields\n    */\n   protected function getMultipleItems($params = []) {\n\n      if (!is_array($params['items'])) {\n         return $this->messageBadArrayError();\n      }\n\n      $allitems = [];\n      foreach ($params['items'] as $item) {\n         if (!isset($item['items_id']) && !isset($item['itemtype'])) {\n            return $this->messageBadArrayError();\n         }\n\n         $fields = $this->getItem($item['itemtype'], $item['items_id'], $params);\n         $allitems[] = $fields;\n      }\n\n      return $allitems;\n   }\n\n\n   /**\n    * List the searchoptions of provided itemtype. To use with searchItems function\n    *\n    * @param string $itemtype             itemtype (class) of object\n    * @param array  $params               parameters\n    * @param bool   $check_depreciation   disable depreciation check, useful\n    *                                     if depreciation have already been\n    *                                     handled by a parent call (e.g. search)\n    *\n    * @return array all searchoptions of specified itemtype\n    */\n   protected function listSearchOptions(\n      $itemtype,\n      $params = [],\n      bool $check_depreciation = true\n   ) {\n      $this->initEndpoint();\n\n      if ($check_depreciation) {\n         $itemtype = $this->handleDepreciation($itemtype);\n      }\n\n      $soptions = Search::getOptions($itemtype);\n\n      if (isset($params['raw'])) {\n         return $soptions;\n      }\n\n      $cleaned_soptions = [];\n      foreach ($soptions as $sID => $option) {\n         if (is_int($sID)) {\n            $available_searchtypes = Search::getActionsFor($itemtype, $sID);\n            unset($available_searchtypes['searchopt']);\n            $available_searchtypes = array_keys($available_searchtypes);\n\n            $cleaned_soptions[$sID] = ['name'                  => $option['name'],\n                                            'table'                 => $option['table'],\n                                            'field'                 => $option['field'],\n                                            'datatype'              => isset($option['datatype'])\n                                                                       ?$option['datatype']\n                                                                       :\"\",\n                                            'nosearch'              => isset($option['nosearch'])\n                                                                       ?$option['nosearch']\n                                                                       :false,\n                                            'nodisplay'             => isset($option['nodisplay'])\n                                                                       ?$option['nodisplay']\n                                                                       :false,\n                                            'available_searchtypes' => $available_searchtypes];\n            $cleaned_soptions[$sID]['uid'] = $this->getSearchOptionUniqID($itemtype,\n                                                                               $option);\n         } else {\n            $cleaned_soptions[$sID] = $option;\n         }\n      }\n\n      if ($check_depreciation && $this->isDeprecated()) {\n         $cleaned_soptions = $this->deprecated_item->mapCurrentToDeprecatedSearchOptions($cleaned_soptions);\n      }\n\n      return $cleaned_soptions;\n   }\n\n\n   /**\n    * Generate an unique id of a searchoption based on:\n    *  - itemtype\n    *  - linkfield\n    *  - joinparams\n    *  - field\n    *\n    * It permits to identify a searchoption with an named index instead a numeric one\n    *\n    * @param CommonDBTM $itemtype current itemtype called on ressource listSearchOption\n    * @param array      $option   current option to generate an unique id\n    *\n    * @return string the unique id\n    */\n   private function getSearchOptionUniqID($itemtype, $option = []) {\n\n      $uid_parts = [$itemtype];\n\n      $sub_itemtype = getItemTypeForTable($option['table']);\n\n      if ((isset($option['joinparams']['beforejoin']['table'])\n           || empty($option['joinparams']))\n          && $option['linkfield'] != getForeignKeyFieldForItemType($sub_itemtype)\n          && $option['linkfield'] != $option['field']) {\n         $uid_parts[] = $option['linkfield'];\n      }\n\n      if (isset($option['joinparams'])) {\n         if (isset($option['joinparams']['beforejoin'])) {\n            $sub_parts  = $this->getSearchOptionUniqIDJoins($option['joinparams']['beforejoin']);\n            $uid_parts = array_merge($uid_parts, $sub_parts);\n         }\n      }\n\n      if (isset($option['joinparams']['beforejoin']['table'])\n          || $sub_itemtype != $itemtype) {\n         $uid_parts[] = $sub_itemtype;\n      }\n\n      $uid_parts[] = $option['field'];\n\n      $uuid = implode('.', $uid_parts);\n\n      return $uuid;\n   }\n\n\n   /**\n    * Generate subpart of a unique id of a search option with parsing joinparams recursively\n    *\n    * @param array $option ['joinparams']['beforejoin'] subpart of a searchoption\n    *\n    * @return array unique id parts\n    */\n   private function getSearchOptionUniqIDJoins($option) {\n\n      $uid_parts = [];\n      if (isset($option['joinparams']['beforejoin'])) {\n         $sub_parts  = $this->getSearchOptionUniqIDJoins($option['joinparams']['beforejoin']);\n         $uid_parts = array_merge($uid_parts, $sub_parts);\n      }\n\n      if (isset($option['table'])) {\n         $uid_parts[] = getItemTypeForTable($option['table']);\n      }\n\n      return $uid_parts;\n   }\n\n\n   /**\n    * Expose the GLPI searchEngine\n    *\n    * @param string $itemtype itemtype (class) of object\n    * @param array  $params   with theses options :\n    *    - 'criteria': array of criterion object to filter search.\n    *        Optionnal.\n    *        Each criterion object must provide :\n    *           - link: (optionnal for 1st element) logical operator in [AND, OR, AND NOT, AND NOT].\n    *           - field: id of searchoptions.\n    *           - searchtype: type of search in [contains, equals, notequals, lessthan, morethan, under, notunder].\n    *           - value : value to search.\n    *    - 'metacriteria' (optionnal): array of metacriterion object to filter search.\n    *                                  Optionnal.\n    *                                  A meta search is a link with another itemtype\n    *                                  (ex: Computer with softwares).\n    *         Each metacriterion object must provide :\n    *            - link: logical operator in [AND, OR, AND NOT, AND NOT]. Mandatory\n    *            - itemtype: second itemtype to link.\n    *            - field: id of searchoptions.\n    *            - searchtype: type of search in [contains, equals, notequals, lessthan, morethan, under, notunder].\n    *            - value : value to search.\n    *    - 'sort' :  id of searchoption to sort by (default 1). Optionnal.\n    *    - 'order' : ASC - Ascending sort / DESC Descending sort (default ASC). Optionnal.\n    *    - 'range' : a string with a couple of number for start and end of pagination separated by a '-'. Ex : 150-200. (default 0-50)\n    *                Optionnal.\n    *    - 'forcedisplay': array of columns to display (default empty = empty use display pref and search criterias).\n    *                      Some columns will be always presents (1-id, 2-name, 80-Entity).\n    *                      Optionnal.\n    *    - 'rawdata': boolean for displaying raws data of Search engine of glpi (like sql request, and full searchoptions)\n    *\n    * @return array of raw rows from Search class\n    */\n   protected function searchItems($itemtype, $params = []) {\n      global $DEBUG_SQL;\n\n      $this->initEndpoint();\n      $itemtype = $this->handleDepreciation($itemtype);\n\n      // check rights\n      if ($itemtype != 'AllAssets'\n          && !$itemtype::canView()) {\n         return $this->messageRightError();\n      }\n\n      // retrieve searchoptions\n      $soptions = $this->listSearchOptions($itemtype, [], false);\n\n      if ($this->isDeprecated()) {\n         $criteria = $this->deprecated_item->mapDeprecatedToCurrentCriteria(\n            $params['criteria'] ?? []\n         );\n\n         if (count($criteria)) {\n            $params['criteria'] = $criteria;\n         }\n      }\n\n      // Check the criterias are valid\n      if (isset($params['criteria']) && is_array($params['criteria'])) {\n\n         // use a recursive closure to check each nested criteria\n         $check_criteria = function(&$criteria) use (&$check_criteria, $soptions) {\n            foreach ($criteria as &$criterion) {\n               // recursive call\n               if (isset($criterion['criteria'])) {\n                  return $check_criteria($criterion['criteria']);\n               }\n\n               if (!isset($criterion['field']) || !isset($criterion['searchtype'])\n                   || !isset($criterion['value'])) {\n                  return __(\"Malformed search criteria\");\n               }\n\n               if (!ctype_digit((string) $criterion['field'])\n                   || !array_key_exists($criterion['field'], $soptions)) {\n                  return __(\"Bad field ID in search criteria\");\n               }\n\n               if (isset($soptions[$criterion['field']])\n                   && isset($soptions[$criterion['field']]['nosearch'])\n                   && $soptions[$criterion['field']]['nosearch']) {\n                  return __(\"Forbidden field ID in search criteria\");\n               }\n\n               // Escape value to prevent SQL injection\n               $criterion['value'] = Toolbox::addslashes_deep($criterion['value']);\n            }\n\n            return true;\n         };\n\n         // call the closure\n         $check_criteria_result = $check_criteria($params['criteria']);\n         if ($check_criteria_result !== true) {\n            return $this->returnError($check_criteria_result);\n         }\n      }\n\n      // manage forcedisplay\n      if (isset($params['forcedisplay'])) {\n         if (!is_array($params['forcedisplay'])) {\n            $params['forcedisplay'] = [intval($params['forcedisplay'])];\n         }\n         $params['forcedisplay'] = array_combine($params['forcedisplay'], $params['forcedisplay']);\n      } else {\n         $params['forcedisplay'] = [];\n      }\n      foreach ($params['forcedisplay'] as $forcedisplay) {\n         if (isset($soptions[$forcedisplay]) && isset($soptions[$forcedisplay]['nodisplay'])\n             && $soptions[$forcedisplay]['nodisplay']) {\n            return $this->returnError(__(\"ID is forbidden along with 'forcedisplay' parameter.\"));\n         }\n      }\n\n      // transform range parameter in start and limit variables\n      if (isset($params['range']) > 0) {\n         if (preg_match(\"/^[0-9]+-[0-9]+\\$/\", $params['range'])) {\n            $range = explode(\"-\", $params['range']);\n            $params['start']      = $range[0];\n            $params['list_limit'] = $range[1]-$range[0]+1;\n            $params['range']      = $range;\n         } else {\n            $this->returnError(\"range must be in format : [start-end] with integers\");\n         }\n      } else {\n         $params['range'] = [0, $_SESSION['glpilist_limit']];\n      }\n\n      // force reset\n      $params['reset'] = 'reset';\n\n      // force logging sql queries\n      $_SESSION['glpi_use_mode'] = Session::DEBUG_MODE;\n\n      // call Core Search method\n      $rawdata = Search::getDatas($itemtype, $params, $params['forcedisplay']);\n\n      // probably a sql error\n      if (!isset($rawdata['data']) || count($rawdata['data']) === 0) {\n         $this->returnError(\"Unexpected SQL Error : \".array_splice($DEBUG_SQL['errors'], -2)[0],\n                            500, \"ERROR_SQL\", false);\n      }\n\n      $cleaned_data = ['totalcount' => $rawdata['data']['totalcount'],\n                            'count'      => count($rawdata['data']['rows']),\n                            'sort'       => $rawdata['search']['sort'],\n                            'order'      => $rawdata['search']['order']];\n\n      if ($params['range'][0] > $cleaned_data['totalcount']) {\n         $this->returnError(\"Provided range exceed total count of data: \".$cleaned_data['totalcount'],\n                            400,\n                            \"ERROR_RANGE_EXCEED_TOTAL\");\n      }\n\n      // fix end range\n      if ($params['range'][1] > $cleaned_data['totalcount'] - 1) {\n         $params['range'][1] = $cleaned_data['totalcount'] - 1;\n      }\n\n      //prepare cols (searchoptions_id) for cleaned data\n      $cleaned_cols = [];\n      $uid_cols = [];\n      foreach ($rawdata['data']['cols'] as $col) {\n         $cleaned_cols[] = $col['id'];\n         if (isset($params['uid_cols'])) {\n            // prepare cols with uid\n            $uid_cols[] = $soptions[$col['id']]['uid'];\n         }\n      }\n\n      foreach ($rawdata['data']['rows'] as $row) {\n         $raw = $row['raw'];\n         $id = $raw['id'];\n\n         // keep row itemtype for all asset\n         if ($itemtype == 'AllAssets') {\n            $current_id       = $raw['id'];\n            $current_itemtype = $raw['TYPE'];\n         }\n\n         // retrive value (and manage multiple values)\n         $clean_values = [];\n         foreach ($rawdata['data']['cols'] as $col) {\n            $rvalues = $row[$col['itemtype'] . '_' . $col['id']];\n\n            // manage multiple values (ex: IP adresses)\n            $current_values = [];\n            for ($valindex= 0; $valindex < $rvalues['count']; $valindex++) {\n               $current_values[] = $rvalues[$valindex]['name'];\n            }\n            if (count($current_values) == 1) {\n               $current_values = $current_values[0];\n            }\n\n            $clean_values[] = $current_values;\n         }\n\n         // combine cols (searchoptions_id) with values (raws data)\n         if (isset($params['uid_cols'])) {\n            $current_line = array_combine($uid_cols, $clean_values);\n         } else {\n            $current_line = array_combine($cleaned_cols, $clean_values);\n         }\n\n         // if all asset, provide type in returned data\n         if ($itemtype == 'AllAssets') {\n            $current_line['id']       = $current_id;\n            $current_line['itemtype'] = $current_itemtype;\n         }\n\n         // append to final array\n         if (isset($params['withindexes'])) {\n            $cleaned_data['data'][$id] = $current_line;\n         } else {\n            $cleaned_data['data'][] = $current_line;\n         }\n      }\n\n      // add rows with their html\n      if (isset($params['giveItems'])) {\n         $cleaned_data['data_html'] = [];\n         foreach ($rawdata['data']['rows'] as $row) {\n            $new_row = [];\n            foreach ($row as $cell_key => $cell) {\n               if (isset($cell['displayname'])) {\n                  $new_row[$cell_key] = $cell['displayname'];\n               }\n            }\n            $new_row = array_combine($cleaned_cols, $new_row);\n\n            if (isset($params['withindexes'])) {\n               $cleaned_data['data_html'][$row['id']] = $new_row;\n            } else {\n               $cleaned_data['data_html'][] = $new_row;\n            }\n         }\n      }\n\n      if (isset($params['rawdata'])\n          && $params['rawdata']) {\n         $cleaned_data['rawdata'] = $rawdata;\n      }\n\n      $cleaned_data['content-range'] = implode('-', $params['range']).\n                                       \"/\".$cleaned_data['totalcount'];\n\n      // return data\n      return $cleaned_data;\n   }\n\n\n   /**\n    * Add an object to GLPI\n    *\n    * @param string $itemtype itemtype (class) of object\n    * @param array  $params   with theses options :\n    *    - 'input' : object with fields of itemtype to be inserted.\n    *                You can add several items in one action by passing array of input object.\n    *                Mandatory.\n    *\n    * @return array of id\n    */\n   protected function createItems($itemtype, $params = []) {\n      $this->initEndpoint();\n      $itemtype = $this->handleDepreciation($itemtype);\n\n      $input    = isset($params['input']) ? $params[\"input\"] : null;\n      $item     = new $itemtype;\n\n      if (is_object($input)) {\n         $input = [$input];\n         $isMultiple = false;\n      } else {\n         $isMultiple = true;\n      }\n\n      if ($this->isDeprecated()) {\n         $input = array_map(function($item) {\n            return $this->deprecated_item->mapDeprecatedToCurrentFields($item);\n         }, $input);\n      }\n\n      if (is_array($input)) {\n         $idCollection = [];\n         $failed       = 0;\n         $index        = 0;\n         foreach ($input as $object) {\n            $object      = $this->inputObjectToArray($object);\n            $current_res = [];\n\n            //check rights\n            if (!$item->can(-1, CREATE, $object)) {\n               $failed++;\n               $current_res = ['id'      => false,\n                               'message' => __(\"You don't have permission to perform this action.\")];\n            } else {\n               // add missing entity\n               if (!isset($object['entities_id'])) {\n                  $object['entities_id'] = $_SESSION['glpiactive_entity'];\n               }\n\n               // add an entry to match gui post (which contains submit button)\n               // to force having messages after redirect\n               $object[\"_add\"] = true;\n\n               //add current item\n               $object = Toolbox::sanitize($object);\n               $new_id = $item->add($object);\n               if ($new_id === false) {\n                  $failed++;\n               }\n               $current_res = ['id'      => $new_id,\n                               'message' => $this->getGlpiLastMessage()];\n            }\n\n            // attach fileupload answer\n            if (isset($params['upload_result'])\n                && isset($params['upload_result'][$index])) {\n               $current_res['upload_result'] = $params['upload_result'][$index];\n            }\n\n            // append current result to final collection\n            $idCollection[] = $current_res;\n            $index++;\n         }\n\n         if ($isMultiple) {\n            if ($failed == count($input)) {\n               $this->returnError($idCollection, 400, \"ERROR_GLPI_ADD\", false);\n            } else if ($failed > 0) {\n               $this->returnError($idCollection, 207, \"ERROR_GLPI_PARTIAL_ADD\", false);\n            }\n         } else {\n            if ($failed > 0) {\n               $this->returnError($idCollection[0]['message'], 400, \"ERROR_GLPI_ADD\", false);\n            } else {\n               return $idCollection[0];\n            }\n         }\n         return $idCollection;\n\n      } else {\n         $this->messageBadArrayError();\n      }\n   }\n\n   /**\n    * Transform all stdobject retrieved from a json_decode into arrays\n    *\n    * @since 9.1\n    *\n    * @param  mixed $input can be an object or array\n    *\n    * @return array the cleaned input\n    */\n   private function inputObjectToArray($input) {\n      if (is_object($input)) {\n         $input = get_object_vars($input);\n      }\n\n      if (is_array($input)) {\n         foreach ($input as &$sub_input) {\n            $sub_input = self::inputObjectToArray($sub_input);\n         }\n      }\n\n      return $input;\n   }\n\n\n   /**\n    * Update an object to GLPI\n    *\n    * @param string $itemtype itemtype (class) of object\n    * @param array  $params   with theses options :\n    *    - 'input' : Array of objects with fields of itemtype to be updated.\n    *                Mandatory.\n    *                You must provide in each object a key named 'id' to identify item to update.\n    *\n    * @return   array of boolean\n    */\n   protected function updateItems($itemtype, $params = []) {\n      $this->initEndpoint();\n      $itemtype = $this->handleDepreciation($itemtype);\n\n      $input    = isset($params['input']) ? $params[\"input\"] : null;\n      $item     = new $itemtype;\n\n      if (is_object($input)) {\n         $input = [$input];\n         $isMultiple = false;\n      } else {\n         $isMultiple = true;\n      }\n\n      if ($this->isDeprecated()) {\n         $input = array_map(function($item) {\n            return $this->deprecated_item->mapDeprecatedToCurrentFields($item);\n         }, $input);\n      }\n\n      if (is_array($input)) {\n         $idCollection = [];\n         $failed       = 0;\n         $index        = 0;\n         foreach ($input as $object) {\n            $current_res = [];\n            if (isset($object->id)) {\n               if (!$item->getFromDB($object->id)) {\n                  $failed++;\n                  $current_res = [$object->id => false,\n                                  'message'   => __(\"Item not found\")];\n                  continue;\n               }\n\n               //check rights\n               if (!$item->can($object->id, UPDATE)) {\n                  $failed++;\n                  $current_res = [$object->id => false,\n                                 'message'    => __(\"You don't have permission to perform this action.\")];\n               } else {\n                  // if parent key not provided in input and present in parameter\n                  // (detected from url for example), try to appent it do input\n                  // This is usefull to have logs in parent (and avoid some warnings in commonDBTM)\n                  if (isset($params['parent_itemtype'])\n                      && isset($params['parent_id'])) {\n                     $fk_parent = getForeignKeyFieldForItemType($params['parent_itemtype']);\n                     if (!property_exists($input, $fk_parent)) {\n                        $input->$fk_parent = $params['parent_id'];\n                     }\n                  }\n\n                  //update item\n                  $object = Toolbox::sanitize((array)$object);\n                  $update_return = $item->update($object);\n                  if ($update_return === false) {\n                     $failed++;\n                  }\n                  $current_res = [$item->fields[\"id\"] => $update_return,\n                                  'message'           => $this->getGlpiLastMessage()];\n               }\n\n            }\n\n            // attach fileupload answer\n            if (isset($params['upload_result'])\n                && isset($params['upload_result'][$index])) {\n               $current_res['upload_result'] = $params['upload_result'][$index];\n            }\n\n            // append current result to final collection\n            $idCollection[] = $current_res;\n            $index++;\n         }\n         if ($isMultiple) {\n            if ($failed == count($input)) {\n               $this->returnError($idCollection, 400, \"ERROR_GLPI_UPDATE\", false);\n            } else if ($failed > 0) {\n               $this->returnError($idCollection, 207, \"ERROR_GLPI_PARTIAL_UPDATE\", false);\n            }\n         } else {\n            if ($failed > 0) {\n               $this->returnError($idCollection[0]['message'], 400, \"ERROR_GLPI_UPDATE\", false);\n            } else {\n               return $idCollection; // Return collection, even if the request affects a single item\n            }\n         }\n         return $idCollection;\n\n      } else {\n         $this->messageBadArrayError();\n      }\n   }\n\n\n   /**\n    * Delete one or more objects in GLPI\n    *\n    * @param string $itemtype itemtype (class) of object\n    * @param array  $params   with theses options :\n    *    - 'input' : Array of objects with fields of itemtype to be updated.\n    *                Mandatory.\n    *                You must provide in each object a key named 'id' to identify item to delete.*\n    *    - 'force_purge' : boolean, if itemtype have a trashbin, you can force purge (delete finally).\n    *                      Optionnal.\n    *    - 'history' : boolean, default true, false to disable saving of deletion in global history.\n    *                  Optionnal.\n    *\n    * @return boolean|boolean[]\n    */\n   protected function deleteItems($itemtype, $params = []) {\n\n      $this->initEndpoint();\n      $itemtype = $this->handleDepreciation($itemtype);\n\n      $default  = ['force_purge' => false,\n                        'history'     => true];\n      $params   = array_merge($default, $params);\n      $input    = $params['input'];\n      $item     = new $itemtype;\n\n      if (is_object($input)) {\n         $input = [$input];\n         $isMultiple = false;\n      } else {\n         $isMultiple = true;\n      }\n\n      if ($this->isDeprecated()) {\n         $input = array_map(function($item) {\n            return $this->deprecated_item->mapDeprecatedToCurrentFields($item);\n         }, $input);\n      }\n\n      if (is_array($input)) {\n         $idCollection = [];\n         $failed = 0;\n         foreach ($input as $object) {\n            if (isset($object->id)) {\n               if (!$item->getFromDB($object->id)) {\n                  $failed++;\n                  $idCollection[] = [$object->id => false, 'message' => __(\"Item not found\")];\n                  continue;\n               }\n\n               // Force purge for templates / may not to be deleted / not dynamic lockable items\n               // see CommonDBTM::delete()\n               // TODO Needs factorization\n               if ($item->isTemplate()\n                  || !$item->maybeDeleted()\n                  // Do not take into account deleted field if maybe dynamic but not dynamic\n                  || ($item->useDeletedToLockIfDynamic()\n                        && !$item->isDynamic())) {\n                  $params['force_purge'] = 1;\n               } else {\n                  $params['force_purge'] = filter_var($params['force_purge'], FILTER_VALIDATE_BOOLEAN);\n               }\n\n               //check rights\n               if (($params['force_purge']\n                    && !$item->can($object->id, PURGE))\n                   || (!$params['force_purge']\n                       && !$item->can($object->id, DELETE))) {\n                  $failed++;\n                  $idCollection[] = [\n                        $object->id => false,\n                        'message' => __(\"You don't have permission to perform this action.\")\n                  ];\n               } else {\n                  //delete item\n                  $delete_return = $item->delete((array) $object,\n                                                 $params['force_purge'],\n                                                 $params['history']);\n                  if ($delete_return === false) {\n                     $failed++;\n                  }\n                  $idCollection[] = [$object->id => $delete_return, 'message' => $this->getGlpiLastMessage()];\n               }\n            }\n         }\n         if ($isMultiple) {\n            if ($failed == count($input)) {\n               $this->returnError($idCollection, 400, \"ERROR_GLPI_DELETE\", false);\n            } else if ($failed > 0) {\n               $this->returnError($idCollection, 207, \"ERROR_GLPI_PARTIAL_DELETE\", false);\n            }\n         } else {\n            if ($failed > 0) {\n               $this->returnError($idCollection[0]['message'], 400, \"ERROR_GLPI_DELETE\", false);\n            } else {\n               return $idCollection; // Return collection, even if the request affects a single item\n            }\n         }\n\n         return $idCollection;\n\n      } else {\n         $this->messageBadArrayError();\n      }\n   }\n\n\n   protected function lostPassword($params = []) {\n      global $CFG_GLPI;\n\n      if ($CFG_GLPI['use_notifications'] == '0' || $CFG_GLPI['notifications_mailing'] == '0') {\n         return $this->returnError(__(\"Email notifications are disabled\"));\n      }\n\n      if (!isset($params['email'])) {\n         return $this->returnError(__(\"email parameter missing\"));\n      }\n\n      if (isset($_SESSION['glpiID'])) {\n         return $this->returnError(__(\"A session is active\"));\n      }\n\n      $user = new User();\n      if (!isset($params['password_forget_token'])) {\n         $email = Toolbox::addslashes_deep($params['email']);\n         try {\n            $user->forgetPassword($email);\n         } catch (ForgetPasswordException $e) {\n            return $this->returnError($e->getMessage());\n         }\n         return $this->returnResponse([\n            __(\"An email has been sent to your email address. The email contains information for reset your password.\")\n         ]);\n      } else {\n         $password = isset($params['password']) ? $params['password'] : '';\n         $input = [\n            'email'                    => Toolbox::addslashes_deep($params['email']),\n            'password_forget_token'    => Toolbox::addslashes_deep($params['password_forget_token']),\n            'password'                 => Toolbox::addslashes_deep($password),\n            'password2'                => Toolbox::addslashes_deep($password),\n         ];\n         try {\n            $user->updateForgottenPassword($input);\n            return $this->returnResponse([__(\"Reset password successful.\")]);\n         } catch (ForgetPasswordException $e) {\n            return $this->returnError($e->getMessage());\n         } catch (PasswordTooWeakException $e) {\n            implode('\\n', $e->getMessages());\n            return $this->returnError(implode('\\n', $e->getMessages()));\n         }\n      }\n   }\n\n\n   /**\n    * Function called by each common function of the API.\n    *\n    * We need for each of these to :\n    *  - checks app_token\n    *  - log\n    *  - check session token\n    *  - unlock session if needed (set ip to read-only to permit concurrent calls)\n    *\n    * @param boolean $unlock_session do we need to unlock session (default true)\n    * @param string  $endpoint       name of the current function (default '')\n    *\n    * @return void\n    */\n   private function initEndpoint($unlock_session = true, $endpoint = \"\") {\n\n      if ($endpoint === \"\") {\n         $backtrace = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 2);\n         $endpoint = $backtrace[1]['function'];\n      }\n      $this->checkAppToken();\n      $this->logEndpointUsage($endpoint);\n      $this->checkSessionToken();\n      if ($unlock_session) {\n         $this->unlockSessionIfPossible();\n      }\n   }\n\n\n   /**\n    * Check if the app_toke in case of config ask to\n    *\n    * @return void\n    */\n   private function checkAppToken() {\n\n      // check app token (if needed)\n      if (!isset($this->parameters['app_token'])) {\n         $this->parameters['app_token'] = \"\";\n      }\n      if (!$this->apiclients_id = array_search($this->parameters['app_token'], $this->app_tokens)) {\n         if ($this->parameters['app_token'] != \"\") {\n            $this->returnError(__(\"parameter app_token seems wrong\"), 400,\n                               \"ERROR_WRONG_APP_TOKEN_PARAMETER\");\n         } else {\n            $this->returnError(__(\"missing parameter app_token\"), 400,\n                               \"ERROR_APP_TOKEN_PARAMETERS_MISSING\");\n         }\n      }\n   }\n\n\n   /**\n    * Log usage of the api into glpi historical or log files (defined by api config)\n    *\n    * It stores the ip and the username of the current session.\n    *\n    * @param string $endpoint function called by api to log (default '')\n    *\n    * @return void\n    */\n   private function logEndpointUsage($endpoint = \"\") {\n\n      $username = \"\";\n      if (isset($_SESSION['glpiname'])) {\n         $username = \"(\".$_SESSION['glpiname'].\")\";\n      }\n\n      $apiclient = new APIClient;\n      if ($apiclient->getFromDB($this->apiclients_id)) {\n         $changes = [\n            0,\n            \"\",\n            \"Enpoint '$endpoint' called by \".$this->iptxt.\" $username\"\n         ];\n\n         switch ($apiclient->fields['dolog_method']) {\n            case APIClient::DOLOG_HISTORICAL:\n               Log::history($this->apiclients_id, 'APIClient', $changes, 0,\n                            Log::HISTORY_LOG_SIMPLE_MESSAGE);\n               break;\n\n            case APIClient::DOLOG_LOGS:\n               Toolbox::logInFile(\"api\", $changes[2].\"\\n\");\n               break;\n         }\n      }\n   }\n\n\n   /**\n    * Check that the session_token is provided and match to a valid php session\n    *\n    * @return boolean\n    */\n   protected function checkSessionToken() {\n\n      if (!isset($this->parameters['session_token'])\n          || empty($this->parameters['session_token'])) {\n         return $this->messageSessionTokenMissing();\n      }\n\n      $current = session_id();\n      if ($this->parameters['session_token'] != $current\n          && !empty($current)\n          || !isset($_SESSION['glpiID'])) {\n         return $this->messageSessionError();\n      }\n   }\n\n\n   /**\n    * Unlock the current session (readonly) to permit concurrent call\n    *\n    * @return void\n    */\n   private function unlockSessionIfPossible() {\n\n      if (!$this->session_write) {\n         session_write_close();\n      }\n   }\n\n\n   /**\n    * Get last message added in $_SESSION by Session::addMessageAfterRedirect\n    *\n    * @return array  of messages\n    */\n   private function getGlpiLastMessage() {\n      global $DEBUG_SQL;\n\n      $all_messages             = [];\n\n      $messages_after_redirect  = [];\n\n      if (isset($_SESSION[\"MESSAGE_AFTER_REDIRECT\"])\n          && count($_SESSION[\"MESSAGE_AFTER_REDIRECT\"]) > 0) {\n         $messages_after_redirect = $_SESSION[\"MESSAGE_AFTER_REDIRECT\"];\n         // Clean messages\n         $_SESSION[\"MESSAGE_AFTER_REDIRECT\"] = [];\n      };\n\n      // clean html\n      foreach ($messages_after_redirect as $messages) {\n         foreach ($messages as $message) {\n            $all_messages[] = Html::clean($message);\n         }\n      }\n\n      // get sql errors\n      if (count($all_messages) <= 0\n          && $DEBUG_SQL['errors'] !== null) {\n         $all_messages = $DEBUG_SQL['errors'];\n      }\n\n      if (!end($all_messages)) {\n         return '';\n      }\n      return end($all_messages);\n   }\n\n\n   /**\n    * Show API Debug\n    *\n    * @return void\n    */\n   protected function showDebug() {\n      Html::printCleanArray($this);\n   }\n\n\n   /**\n    * Show API header\n    *\n    * in debug, it add body and some libs (essentialy to colorise markdown)\n    * otherwise, it change only Content-Type of the page\n    *\n    * @param boolean $html  (default false)\n    * @param string  $title (default '')\n    *\n    * @return void\n    */\n   protected function header($html = false, $title = \"\") {\n\n      // Send UTF8 Headers\n      $content_type = static::$content_type;\n      if ($html) {\n         $content_type = \"text/html\";\n      }\n      header(\"Content-Type: $content_type; charset=UTF-8\");\n\n       // Send extra expires header\n      Html::header_nocache();\n\n      if ($html) {\n         if (empty($title)) {\n            $title = $this->getTypeName();\n         }\n\n         Html::includeHeader($title);\n\n         // Body with configured stuff\n         echo \"<body>\";\n         echo \"<div id='page'>\";\n      }\n   }\n\n\n   /**\n    * Display the API Documentation in Html (parsed from markdown)\n    *\n    * @param string $file relative path of documentation file\n    *\n    * @return void\n    */\n   public function inlineDocumentation($file) {\n      $this->header(true, __(\"API Documentation\"));\n      echo Html::css(\"public/lib/prismjs.css\");\n      echo Html::script(\"public/lib/prismjs.js\");\n\n      echo \"<div class='documentation'>\";\n      $documentation = file_get_contents(GLPI_ROOT.'/'.$file);\n      $md = new MarkdownExtra();\n      $md->code_class_prefix = \"language-\";\n      $md->header_id_func = function($headerName) {\n         $headerName = str_replace(['(', ')'], '', $headerName);\n         return rawurlencode(strtolower(strtr($headerName, [' ' => '-'])));\n      };\n      echo $md->transform($documentation);\n      echo \"</div>\";\n\n      Html::nullFooter();\n   }\n\n\n   /**\n    * Transform array of fields passed in parameter :\n    * change value from  integer id to string name of foreign key\n    * You can pass an array of array, this method is recursive.\n    *\n    * @param array   $fields to check and transform\n    * @param boolean $params array of option to enable, could be :\n    *                                 - expand_dropdowns (default false)\n    *                                 - get_hateoas      (default true)\n    *\n    * @return array altered $fields\n    */\n   protected static function parseDropdowns($fields, $params = []) {\n\n      // default params\n      $default = ['expand_dropdowns' => false,\n                       'get_hateoas'      => true];\n      $params = array_merge($default, $params);\n\n      // parse fields recursively\n      foreach ($fields as $key => &$value) {\n         if (is_array($value)) {\n            $value = self::parseDropdowns($value, $params);\n         }\n         if (is_integer($key)) {\n            continue;\n         }\n         if (isForeignKeyField($key)) {\n            // specific key transformations\n            if ($key == \"items_id\" && isset($fields['itemtype'])) {\n               $key = getForeignKeyFieldForItemType($fields['itemtype']);\n            }\n            if ($key == \"auths_id\"\n                && isset($fields['authtype']) && $fields['authtype'] == Auth::LDAP) {\n               $key = \"authldaps_id\";\n            }\n            if ($key == \"default_requesttypes_id\") {\n               $key = \"requesttypes_id\";\n            }\n\n            if (!empty($value)\n                || $key == 'entities_id' && $value >= 0) {\n\n               $tablename = getTableNameForForeignKeyField($key);\n               $itemtype = getItemTypeForTable($tablename);\n\n               // get hateoas\n               if ($params['get_hateoas'] && is_integer($value)) {\n                  $fields['links'][] = ['rel'  => $itemtype,\n                                             'href' => self::$api_url.\"/$itemtype/\".$value];\n               }\n\n               // expand dropdown\n               if ($params['expand_dropdowns']) {\n                  $value = Dropdown::getDropdownName($tablename, $value);\n                  // fix value for inexistent items\n                  if ($value == \"&nbsp;\") {\n                     $value = \"\";\n                  }\n               }\n            }\n         }\n      }\n      return $fields;\n   }\n\n\n   /**\n    * Retrieve all child class for itemtype parameter\n    *\n    * @param string $itemtype Item type\n    *\n    * @return array child classes\n    */\n   static function getHatoasClasses($itemtype) {\n      global $CFG_GLPI;\n\n      $hclasses = [];\n      if (in_array($itemtype, $CFG_GLPI[\"reservation_types\"])) {\n         $hclasses[] = \"ReservationItem\";\n      }\n      if (in_array($itemtype, $CFG_GLPI[\"document_types\"])) {\n         $hclasses[] = \"Document_Item\";\n      }\n      if (in_array($itemtype, $CFG_GLPI[\"contract_types\"])) {\n         $hclasses[] = \"Contract_Item\";\n      }\n      if (in_array($itemtype, $CFG_GLPI[\"infocom_types\"])) {\n         $hclasses[] = \"Infocom\";\n      }\n      if (in_array($itemtype, $CFG_GLPI[\"ticket_types\"])) {\n         $hclasses[] = \"Item_Ticket\";\n      }if (in_array($itemtype, $CFG_GLPI[\"project_asset_types\"])) {\n         $hclasses[] = \"Item_Project\";\n      }\n      if (in_array($itemtype, $CFG_GLPI[\"networkport_types\"])) {\n         $hclasses[] = \"NetworkPort\";\n      }\n      if (in_array($itemtype, $CFG_GLPI[\"itemdevices_types\"])) {\n         //$hclasses[] = \"Item_Devices\";\n         foreach ($CFG_GLPI['device_types'] as $device_type) {\n            if ((($device_type ==\"DeviceMemory\")\n                 && !in_array($itemtype, $CFG_GLPI[\"itemdevicememory_types\"]))\n                || (($device_type ==\"DevicePowerSupply\")\n                    && !in_array($itemtype, $CFG_GLPI[\"itemdevicepowersupply_types\"]))\n                || (($device_type ==\"DeviceNetworkCard\")\n                    && !in_array($itemtype, $CFG_GLPI[\"itemdevicenetworkcard_types\"]))) {\n               continue;\n            }\n            $hclasses[] = \"Item_\".$device_type;\n         }\n      }\n\n      //specific case\n      switch ($itemtype) {\n         case 'Ticket' :\n            $hclasses[] = \"TicketTask\";\n            $hclasses[] = \"TicketValidation\";\n            $hclasses[] = \"TicketCost\";\n            $hclasses[] = \"Problem_Ticket\";\n            $hclasses[] = \"Change_Ticket\";\n            $hclasses[] = \"Item_Ticket\";\n            $hclasses[] = \"ITILSolution\";\n            $hclasses[] = \"ITILFollowup\";\n            break;\n\n         case 'Problem' :\n            $hclasses[] = \"ProblemTask\";\n            $hclasses[] = \"ProblemCost\";\n            $hclasses[] = \"Change_Problem\";\n            $hclasses[] = \"Problem_Ticket\";\n            $hclasses[] = \"Item_Problem\";\n            $hclasses[] = \"ITILSolution\";\n            $hclasses[] = \"ITILFollowup\";\n            break;\n\n         case 'Change' :\n            $hclasses[] = \"ChangeTask\";\n            $hclasses[] = \"ChangeCost\";\n            $hclasses[] = \"Itil_Project\";\n            $hclasses[] = \"Change_Problem\";\n            $hclasses[] = \"Change_Ticket\";\n            $hclasses[] = \"Change_Item\";\n            $hclasses[] = \"ITILSolution\";\n            $hclasses[] = \"ITILFollowup\";\n            break;\n\n         case 'Project' :\n            $hclasses[] = \"ProjectTask\";\n            $hclasses[] = \"ProjectCost\";\n            $hclasses[] = \"Itil_Project\";\n            $hclasses[] = \"Item_Project\";\n            break;\n      }\n\n      return $hclasses;\n   }\n\n\n   /**\n    * Send 404 error to client\n    *\n    * @param boolean $return_error (default true)\n    *\n    * @return void\n    */\n   public function messageNotfoundError($return_error = true) {\n\n      $this->returnError(__(\"Item not found\"),\n                         404,\n                         \"ERROR_ITEM_NOT_FOUND\",\n                         false,\n                         $return_error);\n   }\n\n\n   /**\n    * Send 400 error to client\n    *\n    * @param boolean $return_error (default true)\n    *\n    * @return void\n    */\n   public function messageBadArrayError($return_error = true) {\n\n      $this->returnError(__(\"input parameter must be an array of objects\"),\n                         400,\n                         \"ERROR_BAD_ARRAY\",\n                         true,\n                         $return_error);\n   }\n\n\n   /**\n    * Send 405 error to client\n    *\n    * @param boolean $return_error (default true)\n    *\n    * @return void\n    */\n   public function messageLostError($return_error = true) {\n\n      $this->returnError(__(\"Method Not Allowed\"),\n                         405,\n                         \"ERROR_METHOD_NOT_ALLOWED\",\n                         true,\n                         $return_error);\n   }\n\n\n   /**\n    * Send 401 error to client\n    *\n    * @param boolean $return_error (default true)\n    *\n    * @return void\n    */\n   public function messageRightError($return_error = true) {\n\n      $this->returnError(__(\"You don't have permission to perform this action.\"),\n                         401,\n                         \"ERROR_RIGHT_MISSING\",\n                         false,\n                         $return_error);\n   }\n\n\n   /**\n    * Session Token KO\n    *\n    * @param boolean $return_error (default true)\n    *\n    * @return void\n    */\n   public function messageSessionError($return_error = true) {\n      $this->returnError(__(\"session_token seems invalid\"),\n                         401,\n                         \"ERROR_SESSION_TOKEN_INVALID\",\n                         false,\n                         $return_error);\n   }\n\n\n   /**\n    * Session Token missing\n    *\n    * @param boolean $return_error (default true)\n    *\n    * @return void\n    */\n   public function messageSessionTokenMissing($return_error = true) {\n\n      $this->returnError(__(\"parameter session_token is missing or empty\"),\n                         400,\n                         \"ERROR_SESSION_TOKEN_MISSING\",\n                         true,\n                         $return_error);\n   }\n\n\n   /**\n    * Generic function to send a error message and an error code to client\n    *\n    * @param string  $message         message to send (human readable)(default 'Bad Request')\n    * @param integer $httpcode        http code (see : https://en.wikipedia.org/wiki/List_of_HTTP_status_codes)\n    *                                      (default 400)\n    * @param string  $statuscode      API status (to represent more precisely the current error)\n    *                                      (default ERROR)\n    * @param boolean $docmessage      if true, add a link to inline document in message\n    *                                      (default true)\n    * @param boolean $return_response if true, the error will be send to returnResponse function\n    *                                      (who may exit after sending data), otherwise,\n    *                                      we will return an array with the error\n    *                                      (default true)\n    *\n    * @return array\n    */\n   public function returnError($message = \"Bad Request\", $httpcode = 400, $statuscode = \"ERROR\",\n                               $docmessage = true, $return_response = true) {\n\n      if (empty($httpcode)) {\n         $httpcode = 400;\n      }\n      if (empty($statuscode)) {\n         $statuscode = \"ERROR\";\n      }\n\n      if ($docmessage) {\n         $message .= \"; \".sprintf(__(\"view documentation in your browser at %s\"),\n                                  self::$api_url.\"/#$statuscode\");\n      }\n      if ($return_response) {\n         return $this->returnResponse([$statuscode, $message], $httpcode);\n      }\n      return [$statuscode, $message];\n   }\n\n\n   /**\n    * Get the raw HTTP request body\n    *\n    * @return string\n    */\n   protected function getHttpBody() {\n      return file_get_contents('php://input');\n   }\n\n   /**\n    * Get raw names\n    *\n    * @since 9.5\n    *\n    * @param array  $data           A raw from the database\n    * @param array  $params         API parameters\n    * @param string $self_itemtype  Itemtype the API was called on\n    *\n    * @return array\n    */\n   protected function getFriendlyNames(\n      array $data,\n      array $params,\n      string $self_itemtype\n   ) {\n      $_names = [];\n\n      foreach ($params['add_keys_names'] as $kn_fkey) {\n         if ($kn_fkey == \"id\") {\n            // Get friendlyname for current item\n            $kn_itemtype = $self_itemtype;\n            $kn_id = $data[$kn_itemtype::getIndexName()];\n         } else {\n\n            if (!isset($data[$kn_fkey])) {\n               Toolbox::logWarning(\n                  \"Invalid value: \\\"$kn_fkey\\\" doesn't exist.\n               \");\n               continue;\n            }\n\n            // Get friendlyname for given fkey\n            $kn_itemtype = getItemtypeForForeignKeyField($kn_fkey);\n            $kn_id = $data[$kn_fkey];\n         }\n\n         // Check itemtype is valid\n         $kn_item = getItemForItemtype($kn_itemtype);\n         if (!$kn_item) {\n            Toolbox::logWarning(\n               \"Invalid itemtype \\\"$kn_itemtype\\\" for fkey  \\\"$kn_fkey\\\"\"\n            );\n            continue;\n         }\n\n         $kn_name = $kn_item::getFriendlyNameById($kn_id);\n         $_names[$kn_fkey] = $kn_name;\n      }\n\n      return $_names;\n   }\n\n   /**\n    * Get the profile picture of the given user\n    *\n    * @since 9.5\n    *\n    * @param int|boolean $user_id\n    */\n   public function userPicture($user_id) {\n      $this->initEndpoint();\n\n      // Try to load target user\n      $user = new User();\n      if (!$user->getFromDB($user_id)) {\n         $this->returnError(\"Bad request: user with id '$user_id' not found\");\n      }\n\n      if (!empty($user->fields['picture'])) {\n         // Send file\n         $file = GLPI_PICTURE_DIR . '/' . $user->fields['picture'];\n         Toolbox::sendFile($file, $user->fields['picture']);\n      } else {\n         // No content\n         http_response_code(204);\n      }\n      die;\n   }\n\n   /**\n    * If the given itemtype is deprecated, replace it by it's current\n    * equivalent and keep a reference to the deprecation logic so we can convert\n    * the API input and/or output to the ex\u00eacted format.\n    *\n    * @param string  $itemtype\n    * @return string The corrected itemtype.\n    */\n   public function handleDepreciation(string $itemtype): string {\n      $deprecated = Toolbox::isAPIDeprecated($itemtype);\n\n      if ($deprecated) {\n         // Keep a reference to deprecated item\n         $class = \"Glpi\\Api\\Deprecated\\\\$itemtype\";\n         $this->deprecated_item = new $class();\n\n         // Get correct itemtype\n         $itemtype = $this->deprecated_item->getType();\n      }\n\n      return $itemtype;\n   }\n\n   /**\n    * Check if the current call is using a deprecated item\n    *\n    * @return bool\n    */\n   public function isDeprecated(): bool {\n      return $this->deprecated_item !== null;\n   }\n}\n"], "filenames": ["inc/api/api.class.php"], "buggy_code_start_loc": [1634], "buggy_code_end_loc": [1655], "fixing_code_start_loc": [1634], "fixing_code_end_loc": [1659], "type": "CWE-89", "message": "In GLPI before version 9.5.2, there is a SQL Injection in the API's search function. Not only is it possible to break the SQL syntax, but it is also possible to utilise a UNION SELECT query to reflect sensitive information such as the current database version, or database user. The most likely scenario for this vulnerability is with someone who has an API account to the system. The issue is patched in version 9.5.2. A proof-of-concept with technical details is available in the linked advisory.", "other": {"cve": {"id": "CVE-2020-15226", "sourceIdentifier": "security-advisories@github.com", "published": "2020-10-07T20:15:11.990", "lastModified": "2020-10-14T19:24:33.517", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In GLPI before version 9.5.2, there is a SQL Injection in the API's search function. Not only is it possible to break the SQL syntax, but it is also possible to utilise a UNION SELECT query to reflect sensitive information such as the current database version, or database user. The most likely scenario for this vulnerability is with someone who has an API account to the system. The issue is patched in version 9.5.2. A proof-of-concept with technical details is available in the linked advisory."}, {"lang": "es", "value": "En GLPI versiones anteriores a 9.5.2, se presenta una inyecci\u00f3n SQL en la funci\u00f3n de b\u00fasqueda de la API.&#xa0;No solo es posible romper la sintaxis SQL, sino que tambi\u00e9n es posible utilizar una consulta UNION SELECT para reflejar informaci\u00f3n confidencial como la versi\u00f3n actual de la base de datos o el usuario de la base de datos.&#xa0;El escenario m\u00e1s probable para esta vulnerabilidad es con alguien que tenga una cuenta de API en el sistema.&#xa0;El problema est\u00e1 parcheado en la versi\u00f3n 9.5.2.&#xa0;Una prueba de concepto con detalles t\u00e9cnicos est\u00e1 disponible en el aviso vinculado"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.1, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:glpi-project:glpi:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.5.2", "matchCriteriaId": "4FDDC1DB-791A-495C-84D1-110B95394022"}]}]}], "references": [{"url": "https://github.com/glpi-project/glpi/commit/3dc4475c56b241ad659cc5c7cb5fb65727409cf0", "source": "security-advisories@github.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/glpi-project/glpi/security/advisories/GHSA-jwpv-7m4h-5gvc", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/glpi-project/glpi/commit/3dc4475c56b241ad659cc5c7cb5fb65727409cf0"}}