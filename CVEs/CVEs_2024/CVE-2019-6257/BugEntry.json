{"buggy_code": ["<?php\n\n/**\n * elFinder - file manager for web.\n * Core class.\n *\n * @package elfinder\n * @author  Dmitry (dio) Levashov\n * @author  Troex Nevelin\n * @author  Alexey Sukhotin\n **/\nclass elFinder\n{\n\n    /**\n     * API version number\n     *\n     * @var float\n     **/\n    protected static $ApiVersion = 2.1;\n\n    /**\n     * API version number\n     *\n     * @deprecated\n     * @var string\n     **/\n    protected $version;\n\n    /**\n     * API revision that this connector supports all functions\n     *\n     * @var integer\n     */\n    protected static $ApiRevision = 45;\n\n    /**\n     * Storages (root dirs)\n     *\n     * @var array\n     **/\n    protected $volumes = array();\n\n    /**\n     * elFinder instance\n     *\n     * @var object\n     */\n    public static $instance = null;\n\n    /**\n     * Current request args\n     *\n     * @var array\n     */\n    public static $currentArgs = array();\n\n    /**\n     * Network mount drivers\n     *\n     * @var array\n     */\n    public static $netDrivers = array();\n\n    /**\n     * elFinder global locale\n     *\n     * @var string\n     */\n    public static $locale = '';\n\n    /**\n     * elFinderVolumeDriver default mime.type file path\n     *\n     * @var string\n     */\n    public static $defaultMimefile = '';\n\n    /**\n     * A file save destination path when a temporary content URL is required\n     * on a network volume or the like\n     * It can be overwritten by volume route setting\n     *\n     * @var string\n     */\n    public static $tmpLinkPath = '';\n\n    /**\n     * A file save destination URL when a temporary content URL is required\n     * on a network volume or the like\n     * It can be overwritten by volume route setting\n     *\n     * @var string\n     */\n    public static $tmpLinkUrl = '';\n\n    /**\n     * Temporary content URL lifetime (seconds)\n     *\n     * @var integer\n     */\n    public static $tmpLinkLifeTime = 3600;\n\n    /**\n     * MIME type list handled as a text file\n     *\n     * @var array\n     */\n    public static $textMimes = array(\n        'application/dash+xml',\n        'application/docbook+xml',\n        'application/javascript',\n        'application/json',\n        'application/plt',\n        'application/sat',\n        'application/sql',\n        'application/step',\n        'application/vnd.hp-hpgl',\n        'application/x-awk',\n        'application/x-config',\n        'application/x-csh',\n        'application/x-empty',\n        'application/x-mpegurl',\n        'application/x-perl',\n        'application/x-php',\n        'application/x-web-config',\n        'application/xhtml+xml',\n        'application/xml',\n        'audio/x-mp3-playlist',\n        'image/cgm',\n        'image/svg+xml',\n        'image/vnd.dxf',\n        'model/iges'\n    );\n\n    /**\n     * Maximum memory size to be extended during GD processing\n     * (0: not expanded, -1: unlimited or memory size notation)\n     *\n     * @var integer|string\n     */\n    public static $memoryLimitGD = 0;\n\n    /**\n     * Path of current request flag file for abort check\n     *\n     * @var string\n     */\n    protected static $abortCheckFile = null;\n\n    /**\n     * elFinder session wrapper object\n     *\n     * @var elFinderSessionInterface\n     */\n    protected $session;\n\n    /**\n     * elFinder global sessionCacheKey\n     *\n     * @deprecated\n     * @var string\n     */\n    public static $sessionCacheKey = '';\n\n    /**\n     * Is session closed\n     *\n     * @deprecated\n     * @var bool\n     */\n    private static $sessionClosed = false;\n\n    /**\n     * elFinder base64encodeSessionData\n     * elFinder save session data as `UTF-8`\n     * If the session storage mechanism of the system does not allow `UTF-8`\n     * And it must be `true` option 'base64encodeSessionData' of elFinder\n     * WARNING: When enabling this option, if saving the data passed from the user directly to the session variable,\n     * it make vulnerable to the object injection attack, so use it carefully.\n     * see https://github.com/Studio-42/elFinder/issues/2345\n     *\n     * @var bool\n     */\n    protected static $base64encodeSessionData = false;\n\n    /**\n     * elFinder common tempraly path\n     *\n     * @var string\n     * @default \"./.tmp\" or sys_get_temp_dir()\n     **/\n    protected static $commonTempPath = '';\n\n    /**\n     * Callable function for URL upload filter\n     * The first argument is a URL and the second argument is an instance of the elFinder class\n     * A filter should be return true (to allow) / false (to disallow)\n     *\n     * @var callable\n     * @default null\n     */\n    protected $urlUploadFilter = null;\n\n    /**\n     * Connection flag files path that connection check of current request\n     *\n     * @var string\n     * @default value of $commonTempPath\n     */\n    protected static $connectionFlagsPath = '';\n\n    /**\n     * Additional volume root options for network mounting volume\n     *\n     * @var array\n     */\n    protected $optionsNetVolumes = array();\n\n    /**\n     * Session key of net mount volumes\n     *\n     * @deprecated\n     * @var string\n     */\n    protected $netVolumesSessionKey = '';\n\n    /**\n     * Mounted volumes count\n     * Required to create unique volume id\n     *\n     * @var int\n     **/\n    public static $volumesCnt = 1;\n\n    /**\n     * Default root (storage)\n     *\n     * @var elFinderVolumeDriver\n     **/\n    protected $default = null;\n\n    /**\n     * Commands and required arguments list\n     *\n     * @var array\n     **/\n    protected $commands = array(\n        'open' => array('target' => false, 'tree' => false, 'init' => false, 'mimes' => false, 'compare' => false),\n        'ls' => array('target' => true, 'mimes' => false, 'intersect' => false),\n        'tree' => array('target' => true),\n        'parents' => array('target' => true, 'until' => false),\n        'tmb' => array('targets' => true),\n        'file' => array('target' => true, 'download' => false, 'cpath' => false, 'onetime' => false),\n        'zipdl' => array('targets' => true, 'download' => false),\n        'size' => array('targets' => true),\n        'mkdir' => array('target' => true, 'name' => false, 'dirs' => false),\n        'mkfile' => array('target' => true, 'name' => true, 'mimes' => false),\n        'rm' => array('targets' => true),\n        'rename' => array('target' => true, 'name' => true, 'mimes' => false, 'targets' => false, 'q' => false),\n        'duplicate' => array('targets' => true, 'suffix' => false),\n        'paste' => array('dst' => true, 'targets' => true, 'cut' => false, 'mimes' => false, 'renames' => false, 'hashes' => false, 'suffix' => false),\n        'upload' => array('target' => true, 'FILES' => true, 'mimes' => false, 'html' => false, 'upload' => false, 'name' => false, 'upload_path' => false, 'chunk' => false, 'cid' => false, 'node' => false, 'renames' => false, 'hashes' => false, 'suffix' => false, 'mtime' => false, 'overwrite' => false, 'contentSaveId' => false),\n        'get' => array('target' => true, 'conv' => false),\n        'put' => array('target' => true, 'content' => '', 'mimes' => false, 'encoding' => false),\n        'archive' => array('targets' => true, 'type' => true, 'mimes' => false, 'name' => false),\n        'extract' => array('target' => true, 'mimes' => false, 'makedir' => false),\n        'search' => array('q' => true, 'mimes' => false, 'target' => false, 'type' => false),\n        'info' => array('targets' => true, 'compare' => false),\n        'dim' => array('target' => true, 'substitute' => false),\n        'resize' => array('target' => true, 'width' => false, 'height' => false, 'mode' => false, 'x' => false, 'y' => false, 'degree' => false, 'quality' => false, 'bg' => false),\n        'netmount' => array('protocol' => true, 'host' => true, 'path' => false, 'port' => false, 'user' => false, 'pass' => false, 'alias' => false, 'options' => false),\n        'url' => array('target' => true, 'options' => false),\n        'callback' => array('node' => true, 'json' => false, 'bind' => false, 'done' => false),\n        'chmod' => array('targets' => true, 'mode' => true),\n        'subdirs' => array('targets' => true),\n        'abort' => array('id' => true),\n        'editor' => array('name' => true, 'method' => true, 'args' => false)\n    );\n\n    /**\n     * Plugins instance\n     *\n     * @var array\n     **/\n    protected $plugins = array();\n\n    /**\n     * Commands listeners\n     *\n     * @var array\n     **/\n    protected $listeners = array();\n\n    /**\n     * script work time for debug\n     *\n     * @var string\n     **/\n    protected $time = 0;\n    /**\n     * Is elFinder init correctly?\n     *\n     * @var bool\n     **/\n    protected $loaded = false;\n    /**\n     * Send debug to client?\n     *\n     * @var string\n     **/\n    protected $debug = false;\n\n    /**\n     * Call `session_write_close()` before exec command?\n     *\n     * @var bool\n     */\n    protected $sessionCloseEarlier = true;\n\n    /**\n     * SESSION use commands @see __construct()\n     *\n     * @var array\n     */\n    protected $sessionUseCmds = array();\n\n    /**\n     * session expires timeout\n     *\n     * @var int\n     **/\n    protected $timeout = 0;\n\n    /**\n     * Temp dir path for Upload\n     *\n     * @var string\n     */\n    protected $uploadTempPath = '';\n\n    /**\n     * Max allowed archive files size (0 - no limit)\n     *\n     * @var integer\n     */\n    protected $maxArcFilesSize = 0;\n\n    /**\n     * undocumented class variable\n     *\n     * @var string\n     **/\n    protected $uploadDebug = '';\n\n    /**\n     * Max allowed numbar of targets (0 - no limit)\n     *\n     * @var integer\n     */\n    public $maxTargets = 1000;\n\n    /**\n     * Errors from PHP\n     *\n     * @var array\n     **/\n    public static $phpErrors = array();\n\n    /**\n     * Errors from not mounted volumes\n     *\n     * @var array\n     **/\n    public $mountErrors = array();\n\n\n    /**\n     * Archivers cache\n     *\n     * @var array\n     */\n    public static $archivers = array();\n\n    /**\n     * URL for callback output window for CORS\n     * redirect to this URL when callback output\n     *\n     * @var string URL\n     */\n    protected $callbackWindowURL = '';\n\n    /**\n     * hash of items to unlock on command completion\n     *\n     * @var array hashes\n     */\n    protected $autoUnlocks = array();\n\n    /**\n     * Item locking expiration (seconds)\n     * Default: 3600 secs\n     *\n     * @var integer\n     */\n    protected $itemLockExpire = 3600;\n\n    /**\n     * Additional request querys\n     *\n     * @var array|null\n     */\n    protected $customData = null;\n\n    /**\n     * Ids to remove of session var \"urlContentSaveIds\" for contents uploading by URL\n     *\n     * @var array\n     */\n    protected $removeContentSaveIds = array();\n\n    /**\n     * Flag of throw Error on exec()\n     *\n     * @var boolean\n     */\n    protected $throwErrorOnExec = false;\n\n    // Errors messages\n    const ERROR_UNKNOWN = 'errUnknown';\n    const ERROR_UNKNOWN_CMD = 'errUnknownCmd';\n    const ERROR_CONF = 'errConf';\n    const ERROR_CONF_NO_JSON = 'errJSON';\n    const ERROR_CONF_NO_VOL = 'errNoVolumes';\n    const ERROR_INV_PARAMS = 'errCmdParams';\n    const ERROR_OPEN = 'errOpen';\n    const ERROR_DIR_NOT_FOUND = 'errFolderNotFound';\n    const ERROR_FILE_NOT_FOUND = 'errFileNotFound';     // 'File not found.'\n    const ERROR_TRGDIR_NOT_FOUND = 'errTrgFolderNotFound'; // 'Target folder \"$1\" not found.'\n    const ERROR_NOT_DIR = 'errNotFolder';\n    const ERROR_NOT_FILE = 'errNotFile';\n    const ERROR_PERM_DENIED = 'errPerm';\n    const ERROR_LOCKED = 'errLocked';        // '\"$1\" is locked and can not be renamed, moved or removed.'\n    const ERROR_EXISTS = 'errExists';        // 'File named \"$1\" already exists.'\n    const ERROR_INVALID_NAME = 'errInvName';       // 'Invalid file name.'\n    const ERROR_INVALID_DIRNAME = 'errInvDirname';    // 'Invalid folder name.'\n    const ERROR_MKDIR = 'errMkdir';\n    const ERROR_MKFILE = 'errMkfile';\n    const ERROR_RENAME = 'errRename';\n    const ERROR_COPY = 'errCopy';\n    const ERROR_MOVE = 'errMove';\n    const ERROR_COPY_FROM = 'errCopyFrom';\n    const ERROR_COPY_TO = 'errCopyTo';\n    const ERROR_COPY_ITSELF = 'errCopyInItself';\n    const ERROR_REPLACE = 'errReplace';          // 'Unable to replace \"$1\".'\n    const ERROR_RM = 'errRm';               // 'Unable to remove \"$1\".'\n    const ERROR_RM_SRC = 'errRmSrc';            // 'Unable remove source file(s)'\n    const ERROR_MKOUTLINK = 'errMkOutLink';        // 'Unable to create a link to outside the volume root.'\n    const ERROR_UPLOAD = 'errUpload';           // 'Upload error.'\n    const ERROR_UPLOAD_FILE = 'errUploadFile';       // 'Unable to upload \"$1\".'\n    const ERROR_UPLOAD_NO_FILES = 'errUploadNoFiles';    // 'No files found for upload.'\n    const ERROR_UPLOAD_TOTAL_SIZE = 'errUploadTotalSize';  // 'Data exceeds the maximum allowed size.'\n    const ERROR_UPLOAD_FILE_SIZE = 'errUploadFileSize';   // 'File exceeds maximum allowed size.'\n    const ERROR_UPLOAD_FILE_MIME = 'errUploadMime';       // 'File type not allowed.'\n    const ERROR_UPLOAD_TRANSFER = 'errUploadTransfer';   // '\"$1\" transfer error.'\n    const ERROR_UPLOAD_TEMP = 'errUploadTemp';       // 'Unable to make temporary file for upload.'\n    const ERROR_ACCESS_DENIED = 'errAccess';\n    const ERROR_NOT_REPLACE = 'errNotReplace';       // Object \"$1\" already exists at this location and can not be replaced with object of another type.\n    const ERROR_SAVE = 'errSave';\n    const ERROR_EXTRACT = 'errExtract';\n    const ERROR_ARCHIVE = 'errArchive';\n    const ERROR_NOT_ARCHIVE = 'errNoArchive';\n    const ERROR_ARCHIVE_TYPE = 'errArcType';\n    const ERROR_ARC_SYMLINKS = 'errArcSymlinks';\n    const ERROR_ARC_MAXSIZE = 'errArcMaxSize';\n    const ERROR_RESIZE = 'errResize';\n    const ERROR_RESIZESIZE = 'errResizeSize';\n    const ERROR_UNSUPPORT_TYPE = 'errUsupportType';\n    const ERROR_CONV_UTF8 = 'errConvUTF8';\n    const ERROR_NOT_UTF8_CONTENT = 'errNotUTF8Content';\n    const ERROR_NETMOUNT = 'errNetMount';\n    const ERROR_NETUNMOUNT = 'errNetUnMount';\n    const ERROR_NETMOUNT_NO_DRIVER = 'errNetMountNoDriver';\n    const ERROR_NETMOUNT_FAILED = 'errNetMountFailed';\n    const ERROR_SESSION_EXPIRES = 'errSessionExpires';\n    const ERROR_CREATING_TEMP_DIR = 'errCreatingTempDir';\n    const ERROR_FTP_DOWNLOAD_FILE = 'errFtpDownloadFile';\n    const ERROR_FTP_UPLOAD_FILE = 'errFtpUploadFile';\n    const ERROR_FTP_MKDIR = 'errFtpMkdir';\n    const ERROR_ARCHIVE_EXEC = 'errArchiveExec';\n    const ERROR_EXTRACT_EXEC = 'errExtractExec';\n    const ERROR_SEARCH_TIMEOUT = 'errSearchTimeout';    // 'Timed out while searching \"$1\". Search result is partial.'\n    const ERROR_REAUTH_REQUIRE = 'errReauthRequire';  // 'Re-authorization is required.'\n    const ERROR_MAX_TARGTES = 'errMaxTargets'; // 'Max number of selectable items is $1.'\n\n    /**\n     * Constructor\n     *\n     * @param  array  elFinder and roots configurations\n     *\n     * @author Dmitry (dio) Levashov\n     */\n    public function __construct($opts)\n    {\n        // set default_charset\n        if (version_compare(PHP_VERSION, '5.6', '>=')) {\n            if (($_val = ini_get('iconv.internal_encoding')) && strtoupper($_val) !== 'UTF-8') {\n                ini_set('iconv.internal_encoding', '');\n            }\n            if (($_val = ini_get('mbstring.internal_encoding')) && strtoupper($_val) !== 'UTF-8') {\n                ini_set('mbstring.internal_encoding', '');\n            }\n            if (($_val = ini_get('internal_encoding')) && strtoupper($_val) !== 'UTF-8') {\n                ini_set('internal_encoding', '');\n            }\n        } else {\n            if (function_exists('iconv_set_encoding') && strtoupper(iconv_get_encoding('internal_encoding')) !== 'UTF-8') {\n                iconv_set_encoding('internal_encoding', 'UTF-8');\n            }\n            if (function_exists('mb_internal_encoding') && strtoupper(mb_internal_encoding()) !== 'UTF-8') {\n                mb_internal_encoding('UTF-8');\n            }\n        }\n        ini_set('default_charset', 'UTF-8');\n\n        // define accept constant of server commands path\n        !defined('ELFINDER_TAR_PATH') && define('ELFINDER_TAR_PATH', 'tar');\n        !defined('ELFINDER_GZIP_PATH') && define('ELFINDER_GZIP_PATH', 'gzip');\n        !defined('ELFINDER_BZIP2_PATH') && define('ELFINDER_BZIP2_PATH', 'bzip2');\n        !defined('ELFINDER_XZ_PATH') && define('ELFINDER_XZ_PATH', 'xz');\n        !defined('ELFINDER_ZIP_PATH') && define('ELFINDER_ZIP_PATH', 'zip');\n        !defined('ELFINDER_UNZIP_PATH') && define('ELFINDER_UNZIP_PATH', 'unzip');\n        !defined('ELFINDER_RAR_PATH') && define('ELFINDER_RAR_PATH', 'rar');\n        !defined('ELFINDER_UNRAR_PATH') && define('ELFINDER_UNRAR_PATH', 'unrar');\n        !defined('ELFINDER_7Z_PATH') && define('ELFINDER_7Z_PATH', (substr(PHP_OS, 0, 3) === 'WIN') ? '7z' : '7za');\n        !defined('ELFINDER_CONVERT_PATH') && define('ELFINDER_CONVERT_PATH', 'convert');\n        !defined('ELFINDER_IDENTIFY_PATH') && define('ELFINDER_IDENTIFY_PATH', 'identify');\n        !defined('ELFINDER_EXIFTRAN_PATH') && define('ELFINDER_EXIFTRAN_PATH', 'exiftran');\n        !defined('ELFINDER_JPEGTRAN_PATH') && define('ELFINDER_JPEGTRAN_PATH', 'jpegtran');\n        !defined('ELFINDER_FFMPEG_PATH') && define('ELFINDER_FFMPEG_PATH', 'ffmpeg');\n\n        !defined('ELFINDER_DISABLE_ZIPEDITOR') && define('ELFINDER_DISABLE_ZIPEDITOR', false);\n\n        // enable(true)/disable(false) handling postscript on ImageMagick\n        // Should be `false` as long as there is a Ghostscript vulnerability\n        // see https://artifex.com/news/ghostscript-security-resolved/\n        !defined('ELFINDER_IMAGEMAGICK_PS') && define('ELFINDER_IMAGEMAGICK_PS', false);\n\n        // for backward compat\n        $this->version = (string)self::$ApiVersion;\n\n        // set error handler of WARNING, NOTICE\n        $errLevel = E_WARNING | E_NOTICE | E_USER_WARNING | E_USER_NOTICE | E_STRICT | E_RECOVERABLE_ERROR;\n        if (defined('E_DEPRECATED')) {\n            $errLevel |= E_DEPRECATED | E_USER_DEPRECATED;\n        }\n        set_error_handler('elFinder::phpErrorHandler', $errLevel);\n\n        // Associative array of files to delete at the end of script: ['temp file path' => true]\n        $GLOBALS['elFinderTempFiles'] = array();\n        // regist Shutdown function\n        register_shutdown_function(array('elFinder', 'onShutdown'));\n\n        // convert PATH_INFO to GET query\n        if (!empty($_SERVER['PATH_INFO'])) {\n            $_ps = explode('/', trim($_SERVER['PATH_INFO'], '/'));\n            if (!isset($_GET['cmd'])) {\n                $_cmd = $_ps[0];\n                if (isset($this->commands[$_cmd])) {\n                    $_GET['cmd'] = $_cmd;\n                    $_i = 1;\n                    foreach (array_keys($this->commands[$_cmd]) as $_k) {\n                        if (isset($_ps[$_i])) {\n                            if (!isset($_GET[$_k])) {\n                                $_GET[$_k] = $_ps[$_i];\n                            }\n                        } else {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        // set elFinder instance\n        elFinder::$instance = $this;\n\n        // setup debug mode\n        $this->debug = (isset($opts['debug']) && $opts['debug'] ? true : false);\n        if ($this->debug) {\n            error_reporting(defined('ELFINDER_DEBUG_ERRORLEVEL') ? ELFINDER_DEBUG_ERRORLEVEL : -1);\n            ini_set('display_errors', '1');\n            // clear output buffer and stop output filters\n            while (ob_get_level() && ob_end_clean()) {\n            }\n        }\n\n        if (!interface_exists('elFinderSessionInterface')) {\n            include_once dirname(__FILE__) . '/elFinderSessionInterface.php';\n        }\n\n        // session handler\n        if (!empty($opts['session']) && $opts['session'] instanceof elFinderSessionInterface) {\n            $this->session = $opts['session'];\n        } else {\n            $sessionOpts = array(\n                'base64encode' => !empty($opts['base64encodeSessionData']),\n                'keys' => array(\n                    'default' => !empty($opts['sessionCacheKey']) ? $opts['sessionCacheKey'] : 'elFinderCaches',\n                    'netvolume' => !empty($opts['netVolumesSessionKey']) ? $opts['netVolumesSessionKey'] : 'elFinderNetVolumes'\n                )\n            );\n            if (!class_exists('elFinderSession')) {\n                include_once dirname(__FILE__) . '/elFinderSession.php';\n            }\n            $this->session = new elFinderSession($sessionOpts);\n        }\n        // try session start | restart\n        $this->session->start();\n\n        // 'netmount' added to handle requests synchronously on unmount\n        $sessionUseCmds = array('netmount');\n        if (isset($opts['sessionUseCmds']) && is_array($opts['sessionUseCmds'])) {\n            $sessionUseCmds = array_merge($sessionUseCmds, $opts['sessionUseCmds']);\n        }\n\n        // set self::$volumesCnt by HTTP header \"X-elFinder-VolumesCntStart\"\n        if (isset($_SERVER['HTTP_X_ELFINDER_VOLUMESCNTSTART']) && ($volumesCntStart = intval($_SERVER['HTTP_X_ELFINDER_VOLUMESCNTSTART']))) {\n            self::$volumesCnt = $volumesCntStart;\n        }\n\n        $this->time = $this->utime();\n        $this->sessionCloseEarlier = isset($opts['sessionCloseEarlier']) ? (bool)$opts['sessionCloseEarlier'] : true;\n        $this->sessionUseCmds = array_flip($sessionUseCmds);\n        $this->timeout = (isset($opts['timeout']) ? $opts['timeout'] : 0);\n        $this->uploadTempPath = (isset($opts['uploadTempPath']) ? $opts['uploadTempPath'] : '');\n        $this->callbackWindowURL = (isset($opts['callbackWindowURL']) ? $opts['callbackWindowURL'] : '');\n        $this->maxTargets = (isset($opts['maxTargets']) ? intval($opts['maxTargets']) : $this->maxTargets);\n        elFinder::$commonTempPath = (isset($opts['commonTempPath']) ? realpath($opts['commonTempPath']) : dirname(__FILE__) . '/.tmp');\n        if (!is_writable(elFinder::$commonTempPath)) {\n            elFinder::$commonTempPath = sys_get_temp_dir();\n            if (!is_writable(elFinder::$commonTempPath)) {\n                elFinder::$commonTempPath = '';\n            }\n        }\n        if (isset($opts['connectionFlagsPath']) && is_writable($opts['connectionFlagsPath'] = realpath($opts['connectionFlagsPath']))) {\n            elFinder::$connectionFlagsPath = $opts['connectionFlagsPath'];\n        } else {\n            elFinder::$connectionFlagsPath = elFinder::$commonTempPath;\n        }\n\n        if (!empty($opts['tmpLinkPath'])) {\n            elFinder::$tmpLinkPath = realpath($opts['tmpLinkPath']);\n        }\n        if (!empty($opts['tmpLinkUrl'])) {\n            elFinder::$tmpLinkUrl = $opts['tmpLinkUrl'];\n        }\n        if (!empty($opts['tmpLinkLifeTime'])) {\n            elFinder::$tmpLinkLifeTime = $opts['tmpLinkLifeTime'];\n        }\n        if (!empty($opts['textMimes']) && is_array($opts['textMimes'])) {\n            elfinder::$textMimes = $opts['textMimes'];\n        }\n        if (!empty($opts['urlUploadFilter'])) {\n            $this->urlUploadFilter = $opts['urlUploadFilter'];\n        }\n        $this->maxArcFilesSize = isset($opts['maxArcFilesSize']) ? intval($opts['maxArcFilesSize']) : 0;\n        $this->optionsNetVolumes = (isset($opts['optionsNetVolumes']) && is_array($opts['optionsNetVolumes'])) ? $opts['optionsNetVolumes'] : array();\n        if (isset($opts['itemLockExpire'])) {\n            $this->itemLockExpire = intval($opts['itemLockExpire']);\n        }\n\n        // deprecated settings\n        $this->netVolumesSessionKey = !empty($opts['netVolumesSessionKey']) ? $opts['netVolumesSessionKey'] : 'elFinderNetVolumes';\n        self::$sessionCacheKey = !empty($opts['sessionCacheKey']) ? $opts['sessionCacheKey'] : 'elFinderCaches';\n\n        // check session cache\n        $_optsMD5 = md5(json_encode($opts['roots']));\n        if ($this->session->get('_optsMD5') !== $_optsMD5) {\n            $this->session->set('_optsMD5', $_optsMD5);\n        }\n\n        // setlocale and global locale regists to elFinder::locale\n        self::$locale = !empty($opts['locale']) ? $opts['locale'] : (substr(PHP_OS, 0, 3) === 'WIN' ? 'C' : 'en_US.UTF-8');\n        if (false === setlocale(LC_ALL, self::$locale)) {\n            self::$locale = setlocale(LC_ALL, '0');\n        }\n\n        // set defaultMimefile\n        elFinder::$defaultMimefile = isset($opts['defaultMimefile']) ? $opts['defaultMimefile'] : '';\n\n        // set memoryLimitGD\n        elFinder::$memoryLimitGD = isset($opts['memoryLimitGD']) ? $opts['memoryLimitGD'] : 0;\n\n        // set flag of throwErrorOnExec\n        // `true` need `try{}` block for `$connector->run();`\n        $this->throwErrorOnExec = !empty($opts['throwErrorOnExec']);\n\n        // set archivers\n        elFinder::$archivers = isset($opts['archivers']) && is_array($opts['archivers']) ? $opts['archivers'] : array();\n\n        // bind events listeners\n        if (!empty($opts['bind']) && is_array($opts['bind'])) {\n            $_req = $_SERVER[\"REQUEST_METHOD\"] == 'POST' ? $_POST : $_GET;\n            $_reqCmd = isset($_req['cmd']) ? $_req['cmd'] : '';\n            foreach ($opts['bind'] as $cmd => $handlers) {\n                $doRegist = (strpos($cmd, '*') !== false);\n                if (!$doRegist) {\n                    $doRegist = ($_reqCmd && in_array($_reqCmd, array_map('self::getCmdOfBind', explode(' ', $cmd))));\n                }\n                if ($doRegist) {\n                    // for backward compatibility\n                    if (!is_array($handlers)) {\n                        $handlers = array($handlers);\n                    } else {\n                        if (count($handlers) === 2 && is_callable($handlers)) {\n                            $handlers = array($handlers);\n                        }\n                    }\n                    foreach ($handlers as $handler) {\n                        if ($handler) {\n                            if (is_string($handler) && strpos($handler, '.')) {\n                                list($_domain, $_name, $_method) = array_pad(explode('.', $handler), 3, '');\n                                if (strcasecmp($_domain, 'plugin') === 0) {\n                                    if ($plugin = $this->getPluginInstance($_name, isset($opts['plugin'][$_name]) ? $opts['plugin'][$_name] : array())\n                                        and method_exists($plugin, $_method)) {\n                                        $this->bind($cmd, array($plugin, $_method));\n                                    }\n                                }\n                            } else {\n                                $this->bind($cmd, $handler);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        if (!isset($opts['roots']) || !is_array($opts['roots'])) {\n            $opts['roots'] = array();\n        }\n\n        // try to enable elFinderVolumeFlysystemZipArchiveNetmount to zip editing\n        if (empty(elFinder::$netDrivers['ziparchive'])) {\n            elFinder::$netDrivers['ziparchive'] = 'FlysystemZipArchiveNetmount';\n        }\n\n        // check for net volumes stored in session\n        $netVolumes = $this->getNetVolumes();\n        foreach ($netVolumes as $key => $root) {\n            if (!isset($root['id'])) {\n                // given fixed unique id\n                if (!$root['id'] = $this->getNetVolumeUniqueId($netVolumes)) {\n                    $this->mountErrors[] = 'Netmount Driver \"' . $root['driver'] . '\" : Could\\'t given volume id.';\n                    continue;\n                }\n            }\n            $opts['roots'][$key] = $root;\n        }\n\n        // \"mount\" volumes\n        foreach ($opts['roots'] as $i => $o) {\n            $class = 'elFinderVolume' . (isset($o['driver']) ? $o['driver'] : '');\n\n            if (class_exists($class)) {\n                /* @var elFinderVolumeDriver $volume */\n                $volume = new $class();\n\n                try {\n                    if ($this->maxArcFilesSize && (empty($o['maxArcFilesSize']) || $this->maxArcFilesSize < $o['maxArcFilesSize'])) {\n                        $o['maxArcFilesSize'] = $this->maxArcFilesSize;\n                    }\n                    // pass session handler\n                    $volume->setSession($this->session);\n                    if ($volume->mount($o)) {\n                        // unique volume id (ends on \"_\") - used as prefix to files hash\n                        $id = $volume->id();\n\n                        $this->volumes[$id] = $volume;\n                        if ((!$this->default || $volume->root() !== $volume->defaultPath()) && $volume->isReadable()) {\n                            $this->default = $this->volumes[$id];\n                        }\n                    } else {\n                        $this->removeNetVolume($i, $volume);\n                        $this->mountErrors[] = 'Driver \"' . $class . '\" : ' . implode(' ', $volume->error());\n                    }\n                } catch (Exception $e) {\n                    $this->removeNetVolume($i, $volume);\n                    $this->mountErrors[] = 'Driver \"' . $class . '\" : ' . $e->getMessage();\n                }\n            } else {\n                $this->removeNetVolume($i, null);\n                $this->mountErrors[] = 'Driver \"' . $class . '\" does not exist';\n            }\n        }\n\n        // if at least one readable volume - ii desu >_<\n        $this->loaded = !empty($this->default);\n\n        // restore error handler for now\n        restore_error_handler();\n    }\n\n    /**\n     * Return elFinder session wrapper instance\n     *\n     * @return  elFinderSessionInterface\n     **/\n    public function getSession()\n    {\n        return $this->session;\n    }\n\n    /**\n     * Return true if fm init correctly\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    public function loaded()\n    {\n        return $this->loaded;\n    }\n\n    /**\n     * Return version (api) number\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    public function version()\n    {\n        return self::$ApiVersion;\n    }\n\n    /**\n     * Return revision (api) number\n     *\n     * @return string\n     * @author Naoki Sawada\n     **/\n    public function revision()\n    {\n        return self::$ApiRevision;\n    }\n\n    /**\n     * Add handler to elFinder command\n     *\n     * @param  string  command name\n     * @param  string|array  callback name or array(object, method)\n     *\n     * @return elFinder\n     * @author Dmitry (dio) Levashov\n     **/\n    public function bind($cmd, $handler)\n    {\n        $allCmds = array_keys($this->commands);\n        $cmds = array();\n        foreach (explode(' ', $cmd) as $_cmd) {\n            if ($_cmd !== '') {\n                if ($all = strpos($_cmd, '*') !== false) {\n                    list(, $sub) = array_pad(explode('.', $_cmd), 2, '');\n                    if ($sub) {\n                        $sub = str_replace('\\'', '\\\\\\'', $sub);\n                        $subs = array_fill(0, count($allCmds), $sub);\n                        $cmds = array_merge($cmds, array_map(array('elFinder', 'addSubToBindName'), $allCmds, $subs));\n                    } else {\n                        $cmds = array_merge($cmds, $allCmds);\n                    }\n                } else {\n                    $cmds[] = $_cmd;\n                }\n            }\n        }\n        $cmds = array_unique($cmds);\n\n        foreach ($cmds as $cmd) {\n            if (!isset($this->listeners[$cmd])) {\n                $this->listeners[$cmd] = array();\n            }\n\n            if (is_callable($handler)) {\n                $this->listeners[$cmd][] = $handler;\n            }\n        }\n\n        return $this;\n    }\n\n    /**\n     * Remove event (command exec) handler\n     *\n     * @param  string  command name\n     * @param  string|array  callback name or array(object, method)\n     *\n     * @return elFinder\n     * @author Dmitry (dio) Levashov\n     **/\n    public function unbind($cmd, $handler)\n    {\n        if (!empty($this->listeners[$cmd])) {\n            foreach ($this->listeners[$cmd] as $i => $h) {\n                if ($h === $handler) {\n                    unset($this->listeners[$cmd][$i]);\n                    return $this;\n                }\n            }\n        }\n        return $this;\n    }\n\n    /**\n     * Return true if command exists\n     *\n     * @param  string  command name\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    public function commandExists($cmd)\n    {\n        return $this->loaded && isset($this->commands[$cmd]) && method_exists($this, $cmd);\n    }\n\n    /**\n     * Return root - file's owner (public func of volume())\n     *\n     * @param  string  file hash\n     *\n     * @return elFinderVolumeDriver\n     * @author Naoki Sawada\n     */\n    public function getVolume($hash)\n    {\n        return $this->volume($hash);\n    }\n\n    /**\n     * Return command required arguments info\n     *\n     * @param  string  command name\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    public function commandArgsList($cmd)\n    {\n        if ($this->commandExists($cmd)) {\n            $list = $this->commands[$cmd];\n            $list['reqid'] = false;\n        } else {\n            $list = array();\n        }\n        return $list;\n    }\n\n    private function session_expires()\n    {\n\n        if (!$last = $this->session->get(':LAST_ACTIVITY')) {\n            $this->session->set(':LAST_ACTIVITY', time());\n            return false;\n        }\n\n        if (($this->timeout > 0) && (time() - $last > $this->timeout)) {\n            return true;\n        }\n\n        $this->session->set(':LAST_ACTIVITY', time());\n        return false;\n    }\n\n    /**\n     * Exec command and return result\n     *\n     * @param  string $cmd  command name\n     * @param  array  $args command arguments\n     *\n     * @return array\n     * @throws elFinderAbortException|Exception\n     * @author Dmitry (dio) Levashov\n     **/\n    public function exec($cmd, $args)\n    {\n        // set error handler of WARNING, NOTICE\n        set_error_handler('elFinder::phpErrorHandler', E_WARNING | E_NOTICE | E_USER_WARNING | E_USER_NOTICE);\n\n        // set current request args\n        self::$currentArgs = $args;\n\n        if (!$this->loaded) {\n            return array('error' => $this->error(self::ERROR_CONF, self::ERROR_CONF_NO_VOL));\n        }\n\n        if ($this->session_expires()) {\n            return array('error' => $this->error(self::ERROR_SESSION_EXPIRES));\n        }\n\n        if (!$this->commandExists($cmd)) {\n            return array('error' => $this->error(self::ERROR_UNKNOWN_CMD));\n        }\n\n        // check request id\n        $args['reqid'] = preg_replace('[^0-9a-fA-F]', '', !empty($args['reqid']) ? $args['reqid'] : (!empty($_SERVER['HTTP_X_ELFINDERREQID']) ? $_SERVER['HTTP_X_ELFINDERREQID'] : ''));\n\n        // to abort this request\n        if ($cmd === 'abort') {\n            $this->abort($args);\n            return array('error' => 0);\n        }\n\n        // make flag file and set self::$abortCheckFile\n        if ($args['reqid']) {\n            $this->abort(array('makeFile' => $args['reqid']));\n        }\n\n        if (!empty($args['mimes']) && is_array($args['mimes'])) {\n            foreach ($this->volumes as $id => $v) {\n                $this->volumes[$id]->setMimesFilter($args['mimes']);\n            }\n        }\n\n        // regist shutdown function as fallback\n        register_shutdown_function(array($this, 'itemAutoUnlock'));\n\n        // detect destination dirHash and volume\n        $dstVolume = false;\n        $dst = !empty($args['target']) ? $args['target'] : (!empty($args['dst']) ? $args['dst'] : '');\n        if ($dst) {\n            $dstVolume = $this->volume($dst);\n        } else if (isset($args['targets']) && is_array($args['targets']) && isset($args['targets'][0])) {\n            $dst = $args['targets'][0];\n            $dstVolume = $this->volume($dst);\n            if ($dstVolume && ($_stat = $dstVolume->file($dst)) && !empty($_stat['phash'])) {\n                $dst = $_stat['phash'];\n            } else {\n                $dst = '';\n            }\n        } else if ($cmd === 'open') {\n            // for initial open without args `target`\n            $dstVolume = $this->default;\n            $dst = $dstVolume->defaultPath();\n        }\n\n        $result = null;\n\n        // call pre handlers for this command\n        $args['sessionCloseEarlier'] = isset($this->sessionUseCmds[$cmd]) ? false : $this->sessionCloseEarlier;\n        if (!empty($this->listeners[$cmd . '.pre'])) {\n            foreach ($this->listeners[$cmd . '.pre'] as $handler) {\n                $_res = call_user_func_array($handler, array($cmd, &$args, $this, $dstVolume));\n                if (is_array($_res)) {\n                    if (!empty($_res['preventexec'])) {\n                        $result = array('error' => true);\n                        if ($cmd === 'upload' && !empty($args['node'])) {\n                            $result['callback'] = array(\n                                'node' => $args['node'],\n                                'bind' => $cmd\n                            );\n                        }\n                        if (!empty($_res['results']) && is_array($_res['results'])) {\n                            $result = array_merge($result, $_res['results']);\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n\n        // unlock session data for multiple access\n        if ($this->sessionCloseEarlier && $args['sessionCloseEarlier']) {\n            $this->session->close();\n            // deprecated property\n            elFinder::$sessionClosed = true;\n        }\n\n        if (substr(PHP_OS, 0, 3) === 'WIN') {\n            // set time out\n            elFinder::extendTimeLimit(300);\n        }\n\n        if (!is_array($result)) {\n            try {\n                $result = $this->$cmd($args);\n            } catch (elFinderAbortException $e) {\n                throw $e;\n            } catch (Exception $e) {\n                $result = array(\n                    'error' => htmlspecialchars($e->getMessage()),\n                    'sync' => true\n                );\n                if ($this->throwErrorOnExec) {\n                    throw $e;\n                }\n            }\n        }\n\n        // check change dstDir\n        $changeDst = false;\n        if ($dst && $dstVolume && (!empty($result['added']) || !empty($result['removed']))) {\n            $changeDst = true;\n        }\n\n        foreach ($this->volumes as $volume) {\n            $removed = $volume->removed();\n            if (!empty($removed)) {\n                if (!isset($result['removed'])) {\n                    $result['removed'] = array();\n                }\n                $result['removed'] = array_merge($result['removed'], $removed);\n                if (!$changeDst && $dst && $dstVolume && $volume === $dstVolume) {\n                    $changeDst = true;\n                }\n            }\n            $added = $volume->added();\n            if (!empty($added)) {\n                if (!isset($result['added'])) {\n                    $result['added'] = array();\n                }\n                $result['added'] = array_merge($result['added'], $added);\n                if (!$changeDst && $dst && $dstVolume && $volume === $dstVolume) {\n                    $changeDst = true;\n                }\n            }\n            $volume->resetResultStat();\n        }\n\n        // dstDir is changed\n        if ($changeDst) {\n            if ($dstDir = $dstVolume->dir($dst)) {\n                if (!isset($result['changed'])) {\n                    $result['changed'] = array();\n                }\n                $result['changed'][] = $dstDir;\n            }\n        }\n\n        // call handlers for this command\n        if (!empty($this->listeners[$cmd])) {\n            foreach ($this->listeners[$cmd] as $handler) {\n                if (call_user_func_array($handler, array($cmd, &$result, $args, $this, $dstVolume))) {\n                    // handler return true to force sync client after command completed\n                    $result['sync'] = true;\n                }\n            }\n        }\n\n        // replace removed files info with removed files hashes\n        if (!empty($result['removed'])) {\n            $removed = array();\n            foreach ($result['removed'] as $file) {\n                $removed[] = $file['hash'];\n            }\n            $result['removed'] = array_unique($removed);\n        }\n        // remove hidden files and filter files by mimetypes\n        if (!empty($result['added'])) {\n            $result['added'] = $this->filter($result['added']);\n        }\n        // remove hidden files and filter files by mimetypes\n        if (!empty($result['changed'])) {\n            $result['changed'] = $this->filter($result['changed']);\n        }\n\n        if ($this->debug || !empty($args['debug'])) {\n            $result['debug'] = array(\n                'connector' => 'php',\n                'phpver' => PHP_VERSION,\n                'time' => $this->utime() - $this->time,\n                'memory' => (function_exists('memory_get_peak_usage') ? ceil(memory_get_peak_usage() / 1024) . 'Kb / ' : '') . ceil(memory_get_usage() / 1024) . 'Kb / ' . ini_get('memory_limit'),\n                'upload' => $this->uploadDebug,\n                'volumes' => array(),\n                'mountErrors' => $this->mountErrors,\n                'phpErrors' => elFinder::$phpErrors\n            );\n            elFinder::$phpErrors = array();\n\n            foreach ($this->volumes as $id => $volume) {\n                $result['debug']['volumes'][] = $volume->debug();\n            }\n        }\n\n        // remove sesstion var 'urlContentSaveIds'\n        if ($this->removeContentSaveIds) {\n            $urlContentSaveIds = $this->session->get('urlContentSaveIds', array());\n            foreach (array_keys($this->removeContentSaveIds) as $contentSaveId) {\n                if (isset($urlContentSaveIds[$contentSaveId])) {\n                    unset($urlContentSaveIds[$contentSaveId]);\n                }\n            }\n            if ($urlContentSaveIds) {\n                $this->session->set('urlContentSaveIds', $urlContentSaveIds);\n            } else {\n                $this->session->remove('urlContentSaveIds');\n            }\n        }\n\n        foreach ($this->volumes as $volume) {\n            $volume->saveSessionCache();\n            $volume->umount();\n        }\n\n        // unlock locked items\n        $this->itemAutoUnlock();\n\n        // custom data\n        if ($this->customData !== null) {\n            $result['customData'] = $this->customData ? json_encode($this->customData) : '';\n        }\n\n        if (!empty($result['callback'])) {\n            $result['callback']['json'] = json_encode($result);\n            $this->callback($result['callback']);\n            return array();\n        } else {\n            return $result;\n        }\n    }\n\n    /**\n     * Return file real path\n     *\n     * @param  string $hash file hash\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    public function realpath($hash)\n    {\n        if (($volume = $this->volume($hash)) == false) {\n            return false;\n        }\n        return $volume->realpath($hash);\n    }\n\n    /**\n     * Sets custom data(s).\n     *\n     * @param  string|array $key The key or data array\n     * @param  mixed        $val The value\n     *\n     * @return self    ( elFinder instance )\n     */\n    public function setCustomData($key, $val = null)\n    {\n        if (is_array($key)) {\n            foreach ($key as $k => $v) {\n                $this->customData[$k] = $v;\n            }\n        } else {\n            $this->customData[$key] = $val;\n        }\n        return $this;\n    }\n\n    /**\n     * Removes a custom data.\n     *\n     * @param  string $key The key\n     *\n     * @return self    ( elFinder instance )\n     */\n    public function removeCustomData($key)\n    {\n        $this->customData[$key] = null;\n        return $this;\n    }\n\n    /**\n     * Update sesstion value of a NetVolume option\n     *\n     * @param string $netKey\n     * @param string $optionKey\n     * @param mixed  $val\n     */\n    public function updateNetVolumeOption($netKey, $optionKey, $val)\n    {\n        $netVolumes = $this->getNetVolumes();\n        if (is_string($netKey) && isset($netVolumes[$netKey]) && is_string($optionKey)) {\n            $netVolumes[$netKey][$optionKey] = $val;\n        }\n    }\n\n    /**\n     * remove of session var \"urlContentSaveIds\"\n     *\n     * @param string $id\n     */\n    public function removeUrlContentSaveId($id)\n    {\n        $this->removeContentSaveIds[$id] = true;\n    }\n\n    /**\n     * Return network volumes config.\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     */\n    protected function getNetVolumes()\n    {\n        if ($data = $this->session->get('netvolume', array())) {\n            return $data;\n        }\n        return array();\n    }\n\n    /**\n     * Save network volumes config.\n     *\n     * @param  array $volumes volumes config\n     *\n     * @return void\n     * @author Dmitry (dio) Levashov\n     */\n    protected function saveNetVolumes($volumes)\n    {\n        $this->session->set('netvolume', $volumes);\n    }\n\n    /**\n     * Remove netmount volume\n     *\n     * @param string $key    netvolume key\n     * @param object $volume volume driver instance\n     *\n     * @return bool\n     */\n    protected function removeNetVolume($key, $volume)\n    {\n        $netVolumes = $this->getNetVolumes();\n        $res = true;\n        if (is_object($volume) && method_exists($volume, 'netunmount')) {\n            $res = $volume->netunmount($netVolumes, $key);\n            $volume->clearSessionCache();\n        }\n        if ($res) {\n            if (is_string($key) && isset($netVolumes[$key])) {\n                unset($netVolumes[$key]);\n                $this->saveNetVolumes($netVolumes);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Get plugin instance & set to $this->plugins\n     *\n     * @param  string $name Plugin name (dirctory name)\n     * @param  array  $opts Plugin options (optional)\n     *\n     * @return object | bool Plugin object instance Or false\n     * @author Naoki Sawada\n     */\n    protected function getPluginInstance($name, $opts = array())\n    {\n        $key = strtolower($name);\n        if (!isset($this->plugins[$key])) {\n            $class = 'elFinderPlugin' . $name;\n            // to try auto load\n            if (!class_exists($class)) {\n                $p_file = dirname(__FILE__) . DIRECTORY_SEPARATOR . 'plugins' . DIRECTORY_SEPARATOR . $name . DIRECTORY_SEPARATOR . 'plugin.php';\n                if (is_file($p_file)) {\n                    include_once $p_file;\n                }\n            }\n            if (class_exists($class, false)) {\n                $this->plugins[$key] = new $class($opts);\n            } else {\n                $this->plugins[$key] = false;\n            }\n        }\n        return $this->plugins[$key];\n    }\n\n    /***************************************************************************/\n    /*                                 commands                                */\n    /***************************************************************************/\n\n    /**\n     * Normalize error messages\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    public function error()\n    {\n        $errors = array();\n\n        foreach (func_get_args() as $msg) {\n            if (is_array($msg)) {\n                $errors = array_merge($errors, $msg);\n            } else {\n                $errors[] = $msg;\n            }\n        }\n\n        return count($errors) ? $errors : array(self::ERROR_UNKNOWN);\n    }\n\n    /**\n     * @param $args\n     *\n     * @return array\n     * @throws elFinderAbortException\n     */\n    protected function netmount($args)\n    {\n        $options = array();\n        $protocol = $args['protocol'];\n        $toast = '';\n\n        if ($protocol === 'netunmount') {\n            if (!empty($args['user']) && $volume = $this->volume($args['user'])) {\n                if ($this->removeNetVolume($args['host'], $volume)) {\n                    return array('removed' => array(array('hash' => $volume->root())));\n                }\n            }\n            return array('sync' => true, 'error' => $this->error(self::ERROR_NETUNMOUNT));\n        }\n\n        $driver = isset(self::$netDrivers[$protocol]) ? self::$netDrivers[$protocol] : '';\n        $class = 'elFinderVolume' . $driver;\n\n        if (!class_exists($class)) {\n            return array('error' => $this->error(self::ERROR_NETMOUNT, $args['host'], self::ERROR_NETMOUNT_NO_DRIVER));\n        }\n\n        if (!$args['path']) {\n            $args['path'] = '/';\n        }\n\n        foreach ($args as $k => $v) {\n            if ($k != 'options' && $k != 'protocol' && $v) {\n                $options[$k] = $v;\n            }\n        }\n\n        if (is_array($args['options'])) {\n            foreach ($args['options'] as $key => $value) {\n                $options[$key] = $value;\n            }\n        }\n\n        /* @var elFinderVolumeDriver $volume */\n        $volume = new $class();\n\n        // pass session handler\n        $volume->setSession($this->session);\n\n        if (is_callable(array($volume, 'netmountPrepare'))) {\n            $options = $volume->netmountPrepare($options);\n            if (isset($options['exit'])) {\n                if ($options['exit'] === 'callback') {\n                    $this->callback($options['out']);\n                }\n                return $options;\n            }\n            if (!empty($options['toast'])) {\n                $toast = $options['toast'];\n                unset($options['toast']);\n            }\n        }\n\n        $netVolumes = $this->getNetVolumes();\n\n        if (!isset($options['id'])) {\n            // given fixed unique id\n            if (!$options['id'] = $this->getNetVolumeUniqueId($netVolumes)) {\n                return array('error' => $this->error(self::ERROR_NETMOUNT, $args['host'], 'Could\\'t given volume id.'));\n            }\n        }\n\n        // load additional volume root options\n        if (!empty($this->optionsNetVolumes['*'])) {\n            $options = array_merge($this->optionsNetVolumes['*'], $options);\n        }\n        if (!empty($this->optionsNetVolumes[$protocol])) {\n            $options = array_merge($this->optionsNetVolumes[$protocol], $options);\n        }\n\n        if (!$key = $volume->netMountKey) {\n            $key = md5($protocol . '-' . serialize($options));\n        }\n        $options['netkey'] = $key;\n\n        if (!isset($netVolumes[$key]) && $volume->mount($options)) {\n            // call post-process function of netmount\n            if (is_callable(array($volume, 'postNetmount'))) {\n                $volume->postNetmount($options);\n            }\n            $options['driver'] = $driver;\n            $netVolumes[$key] = $options;\n            $this->saveNetVolumes($netVolumes);\n            $rootstat = $volume->file($volume->root());\n            $res = array('added' => array($rootstat));\n            if ($toast) {\n                $res['toast'] = $toast;\n            }\n            return $res;\n        } else {\n            $this->removeNetVolume(null, $volume);\n            return array('error' => $this->error(self::ERROR_NETMOUNT, $args['host'], implode(' ', $volume->error())));\n        }\n    }\n\n    /**\n     * \"Open\" directory\n     * Return array with following elements\n     *  - cwd          - opened dir info\n     *  - files        - opened dir content [and dirs tree if $args[tree]]\n     *  - api          - api version (if $args[init])\n     *  - uplMaxSize   - if $args[init]\n     *  - error        - on failed\n     *\n     * @param  array  command arguments\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function open($args)\n    {\n        $target = $args['target'];\n        $init = !empty($args['init']);\n        $tree = !empty($args['tree']);\n        $volume = $this->volume($target);\n        $cwd = $volume ? $volume->dir($target) : false;\n        $hash = $init ? 'default folder' : '#' . $target;\n        $compare = '';\n\n        // on init request we can get invalid dir hash -\n        // dir which can not be opened now, but remembered by client,\n        // so open default dir\n        if ((!$cwd || !$cwd['read']) && $init) {\n            $volume = $this->default;\n            $target = $volume->defaultPath();\n            $cwd = $volume->dir($target);\n        }\n\n        if (!$cwd) {\n            return array('error' => $this->error(self::ERROR_OPEN, $hash, self::ERROR_DIR_NOT_FOUND));\n        }\n        if (!$cwd['read']) {\n            return array('error' => $this->error(self::ERROR_OPEN, $hash, self::ERROR_PERM_DENIED));\n        }\n\n        $files = array();\n\n        // get current working directory files list\n        if (($ls = $volume->scandir($cwd['hash'])) === false) {\n            return array('error' => $this->error(self::ERROR_OPEN, $cwd['name'], $volume->error()));\n        }\n\n        if (isset($cwd['dirs']) && $cwd['dirs'] != 1) {\n            $cwd = $volume->dir($target);\n        }\n\n        // get other volume root\n        if ($tree) {\n            foreach ($this->volumes as $id => $v) {\n                $files[] = $v->file($v->root());\n            }\n        }\n\n        // long polling mode\n        if ($args['compare']) {\n            $sleep = max(1, (int)$volume->getOption('lsPlSleep'));\n            $standby = (int)$volume->getOption('plStandby');\n            if ($standby > 0 && $sleep > $standby) {\n                $standby = $sleep;\n            }\n            $limit = max(0, floor($standby / $sleep)) + 1;\n            do {\n                elFinder::extendTimeLimit(30 + $sleep);\n                $_mtime = 0;\n                foreach ($ls as $_f) {\n                    $_mtime = max($_mtime, $_f['ts']);\n                }\n                $compare = strval(count($ls)) . ':' . strval($_mtime);\n                if ($compare !== $args['compare']) {\n                    break;\n                }\n                if (--$limit) {\n                    sleep($sleep);\n                    $volume->clearstatcache();\n                    if (($ls = $volume->scandir($cwd['hash'])) === false) {\n                        break;\n                    }\n                }\n            } while ($limit);\n            if ($ls === false) {\n                return array('error' => $this->error(self::ERROR_OPEN, $cwd['name'], $volume->error()));\n            }\n        }\n\n        if ($ls) {\n            if ($files) {\n                $files = array_merge($files, $ls);\n            } else {\n                $files = $ls;\n            }\n        }\n\n        $result = array(\n            'cwd' => $cwd,\n            'options' => $volume->options($cwd['hash']),\n            'files' => $files\n        );\n\n        if ($compare) {\n            $result['cwd']['compare'] = $compare;\n        }\n\n        if (!empty($args['init'])) {\n            $result['api'] = sprintf('%.1F%03d', self::$ApiVersion, self::$ApiRevision);\n            $result['uplMaxSize'] = ini_get('upload_max_filesize');\n            $result['uplMaxFile'] = ini_get('max_file_uploads');\n            $result['netDrivers'] = array_keys(self::$netDrivers);\n            $result['maxTargets'] = $this->maxTargets;\n            if ($volume) {\n                $result['cwd']['root'] = $volume->root();\n            }\n            if (elfinder::$textMimes) {\n                $result['textMimes'] = elfinder::$textMimes;\n            }\n        }\n\n        return $result;\n    }\n\n    /**\n     * Return dir files names list\n     *\n     * @param  array  command arguments\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function ls($args)\n    {\n        $target = $args['target'];\n        $intersect = isset($args['intersect']) ? $args['intersect'] : array();\n\n        if (($volume = $this->volume($target)) == false\n            || ($list = $volume->ls($target, $intersect)) === false) {\n            return array('error' => $this->error(self::ERROR_OPEN, '#' . $target));\n        }\n        return array('list' => $list);\n    }\n\n    /**\n     * Return subdirs for required directory\n     *\n     * @param  array  command arguments\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function tree($args)\n    {\n        $target = $args['target'];\n\n        if (($volume = $this->volume($target)) == false\n            || ($tree = $volume->tree($target)) == false) {\n            return array('error' => $this->error(self::ERROR_OPEN, '#' . $target));\n        }\n\n        return array('tree' => $tree);\n    }\n\n    /**\n     * Return parents dir for required directory\n     *\n     * @param  array  command arguments\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function parents($args)\n    {\n        $target = $args['target'];\n        $until = $args['until'];\n\n        if (($volume = $this->volume($target)) == false\n            || ($tree = $volume->parents($target, false, $until)) == false) {\n            return array('error' => $this->error(self::ERROR_OPEN, '#' . $target));\n        }\n\n        return array('tree' => $tree);\n    }\n\n    /**\n     * Return new created thumbnails list\n     *\n     * @param  array  command arguments\n     *\n     * @return array\n     * @throws ImagickException\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function tmb($args)\n    {\n\n        $result = array('images' => array());\n        $targets = $args['targets'];\n\n        foreach ($targets as $target) {\n            elFinder::checkAborted();\n\n            if (($volume = $this->volume($target)) != false\n                && (($tmb = $volume->tmb($target)) != false)) {\n                $result['images'][$target] = $tmb;\n            }\n        }\n        return $result;\n    }\n\n    /**\n     * Download files/folders as an archive file\n     * 1st: Return srrsy contains download archive file info\n     * 2nd: Return array contains opened file pointer, root itself and required headers\n     *\n     * @param  array  command arguments\n     *\n     * @return array\n     * @throws Exception\n     * @author Naoki Sawada\n     */\n    protected function zipdl($args)\n    {\n        $targets = $args['targets'];\n        $download = !empty($args['download']);\n        $h404 = 'HTTP/1.x 404 Not Found';\n\n        if (!$download) {\n            //1st: Return array contains download archive file info\n            $error = array(self::ERROR_ARCHIVE);\n            if (($volume = $this->volume($targets[0])) !== false) {\n                if ($dlres = $volume->zipdl($targets)) {\n                    $path = $dlres['path'];\n                    register_shutdown_function(array('elFinder', 'rmFileInDisconnected'), $path);\n                    if (count($targets) === 1) {\n                        $name = basename($volume->path($targets[0]));\n                    } else {\n                        $name = $dlres['prefix'] . '_Files';\n                    }\n                    $name .= '.' . $dlres['ext'];\n                    $uniqid = uniqid();\n                    $this->session->set('zipdl' . $uniqid, basename($path));\n                    $result = array(\n                        'zipdl' => array(\n                            'file' => $uniqid,\n                            'name' => $name,\n                            'mime' => $dlres['mime']\n                        )\n                    );\n                    return $result;\n                }\n                $error = array_merge($error, $volume->error());\n            }\n            return array('error' => $error);\n        } else {\n            // 2nd: Return array contains opened file session key, root itself and required headers\n            if (count($targets) !== 4 || ($volume = $this->volume($targets[0])) == false || !($file = $this->session->get('zipdl' . $targets[1]))) {\n                return array('error' => 'File not found', 'header' => $h404, 'raw' => true);\n            }\n            $this->session->remove('zipdl' . $targets[1]);\n            if ($volume->commandDisabled('zipdl')) {\n                return array('error' => 'File not found', 'header' => $h404, 'raw' => true);\n            }\n            $path = $volume->getTempPath() . DIRECTORY_SEPARATOR . basename($file);\n            if (!is_readable($path) || !is_writable($path)) {\n                return array('error' => 'File not found', 'header' => $h404, 'raw' => true);\n            }\n            // register auto delete on shutdown\n            $GLOBALS['elFinderTempFiles'][$path] = true;\n            // for HTTP headers\n            $name = $targets[2];\n            $mime = $targets[3];\n\n            $filenameEncoded = rawurlencode($name);\n            if (strpos($filenameEncoded, '%') === false) { // ASCII only\n                $filename = 'filename=\"' . $name . '\"';\n            } else {\n                $ua = $_SERVER['HTTP_USER_AGENT'];\n                if (preg_match('/MSIE [4-8]/', $ua)) { // IE < 9 do not support RFC 6266 (RFC 2231/RFC 5987)\n                    $filename = 'filename=\"' . $filenameEncoded . '\"';\n                } elseif (strpos($ua, 'Chrome') === false && strpos($ua, 'Safari') !== false && preg_match('#Version/[3-5]#', $ua)) { // Safari < 6\n                    $filename = 'filename=\"' . str_replace('\"', '', $name) . '\"';\n                } else { // RFC 6266 (RFC 2231/RFC 5987)\n                    $filename = 'filename*=UTF-8\\'\\'' . $filenameEncoded;\n                }\n            }\n\n            $fp = fopen($path, 'rb');\n            $file = fstat($fp);\n            $result = array(\n                'pointer' => $fp,\n                'header' => array(\n                    'Content-Type: ' . $mime,\n                    'Content-Disposition: attachment; ' . $filename,\n                    'Content-Transfer-Encoding: binary',\n                    'Content-Length: ' . $file['size'],\n                    'Accept-Ranges: none',\n                    'Connection: close'\n                )\n            );\n            return $result;\n        }\n    }\n\n    /**\n     * Required to output file in browser when volume URL is not set\n     * Return array contains opened file pointer, root itself and required headers\n     *\n     * @param  array  command arguments\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function file($args)\n    {\n        $target = $args['target'];\n        $download = !empty($args['download']);\n        $onetime = !empty($args['onetime']);\n        //$h304     = 'HTTP/1.1 304 Not Modified';\n        //$h403     = 'HTTP/1.0 403 Access Denied';\n        $h404 = 'HTTP/1.0 404 Not Found';\n        $a404 = array('error' => 'File not found', 'header' => $h404, 'raw' => true);\n\n        if ($onetime) {\n            $volume = null;\n            $tmpdir = elFinder::$commonTempPath;\n            if (!$tmpdir || !is_file($tmpf = $tmpdir . DIRECTORY_SEPARATOR . 'ELF' . $target)) {\n                return $a404;\n            }\n            $GLOBALS['elFinderTempFiles'][$tmpf] = true;\n            if ($file = json_decode(file_get_contents($tmpf), true)) {\n                $src = base64_decode($file['file']);\n                if (!is_file($src) || !($fp = fopen($src, 'rb'))) {\n                    return $a404;\n                }\n                if (strpos($src, $tmpdir) === 0) {\n                    $GLOBALS['elFinderTempFiles'][$src] = true;\n                }\n                unset($file['file']);\n                $file['read'] = true;\n                $file['size'] = filesize($src);\n            } else {\n                return $a404;\n            }\n        } else {\n            if (($volume = $this->volume($target)) == false) {\n                return $a404;\n            }\n\n            if (($file = $volume->file($target)) == false) {\n                return $a404;\n            }\n\n            if (!$file['read']) {\n                return $a404;\n            }\n\n            if (($fp = $volume->open($target)) == false) {\n                return $a404;\n            }\n        }\n\n        // check aborted by user\n        elFinder::checkAborted();\n\n        // allow change MIME type by 'file.pre' callback functions\n        $mime = isset($args['mime']) ? $args['mime'] : $file['mime'];\n        if ($download || $onetime) {\n            $disp = 'attachment';\n        } else {\n            $dispInlineRegex = $volume->getOption('dispInlineRegex');\n            $inlineRegex = false;\n            if ($dispInlineRegex) {\n                $inlineRegex = '#' . str_replace('#', '\\\\#', $dispInlineRegex) . '#';\n                try {\n                    preg_match($inlineRegex, '');\n                } catch (Exception $e) {\n                    $inlineRegex = false;\n                }\n            }\n            if (!$inlineRegex) {\n                $inlineRegex = '#^(?:(?:image|text)|application/x-shockwave-flash$)#';\n            }\n            $disp = preg_match($inlineRegex, $mime) ? 'inline' : 'attachment';\n        }\n\n        $filenameEncoded = rawurlencode($file['name']);\n        if (strpos($filenameEncoded, '%') === false) { // ASCII only\n            $filename = 'filename=\"' . $file['name'] . '\"';\n        } else {\n            $ua = $_SERVER['HTTP_USER_AGENT'];\n            if (preg_match('/MSIE [4-8]/', $ua)) { // IE < 9 do not support RFC 6266 (RFC 2231/RFC 5987)\n                $filename = 'filename=\"' . $filenameEncoded . '\"';\n            } elseif (strpos($ua, 'Chrome') === false && strpos($ua, 'Safari') !== false && preg_match('#Version/[3-5]#', $ua)) { // Safari < 6\n                $filename = 'filename=\"' . str_replace('\"', '', $file['name']) . '\"';\n            } else { // RFC 6266 (RFC 2231/RFC 5987)\n                $filename = 'filename*=UTF-8\\'\\'' . $filenameEncoded;\n            }\n        }\n\n        if ($args['cpath'] && $args['reqid']) {\n            setcookie('elfdl' . $args['reqid'], '1', 0, $args['cpath']);\n        }\n\n        $result = array(\n            'volume' => $volume,\n            'pointer' => $fp,\n            'info' => $file,\n            'header' => array(\n                'Content-Type: ' . $mime,\n                'Content-Disposition: ' . $disp . '; ' . $filename,\n                'Content-Transfer-Encoding: binary',\n                'Content-Length: ' . $file['size'],\n                'Last-Modified: ' . gmdate('D, d M Y H:i:s T', $file['ts']),\n                'Connection: close'\n            )\n        );\n\n        if (!$onetime) {\n            // add cache control headers\n            if ($cacheHeaders = $volume->getOption('cacheHeaders')) {\n                $result['header'] = array_merge($result['header'], $cacheHeaders);\n            }\n\n            // check 'xsendfile'\n            $xsendfile = $volume->getOption('xsendfile');\n            $path = null;\n            if ($xsendfile) {\n                $info = stream_get_meta_data($fp);\n                if ($path = empty($info['uri']) ? null : $info['uri']) {\n                    $basePath = rtrim($volume->getOption('xsendfilePath'), DIRECTORY_SEPARATOR);\n                    if ($basePath) {\n                        $root = rtrim($volume->getRootPath(), DIRECTORY_SEPARATOR);\n                        if (strpos($path, $root) === 0) {\n                            $path = $basePath . substr($path, strlen($root));\n                        } else {\n                            $path = null;\n                        }\n                    }\n                }\n            }\n            if ($path) {\n                $result['header'][] = $xsendfile . ': ' . $path;\n                $result['info']['xsendfile'] = $xsendfile;\n            }\n        }\n\n        // add \"Content-Location\" if file has url data\n        if (isset($file['url']) && $file['url'] && $file['url'] != 1) {\n            $result['header'][] = 'Content-Location: ' . $file['url'];\n        }\n        return $result;\n    }\n\n    /**\n     * Count total files size\n     *\n     * @param  array  command arguments\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function size($args)\n    {\n        $size = 0;\n        $files = 0;\n        $dirs = 0;\n        $itemCount = true;\n        $sizes = array();\n\n        foreach ($args['targets'] as $target) {\n            elFinder::checkAborted();\n            if (($volume = $this->volume($target)) == false\n                || ($file = $volume->file($target)) == false\n                || !$file['read']) {\n                return array('error' => $this->error(self::ERROR_OPEN, '#' . $target));\n            }\n\n            $volRes = $volume->size($target);\n            if (is_array($volRes)) {\n                $sizeInfo = array('size' => 0, 'fileCnt' => 0, 'dirCnt' => 0);\n                if (!empty($volRes['size'])) {\n                    $sizeInfo['size'] = $volRes['size'];\n                    $size += $volRes['size'];\n                }\n                if (!empty($volRes['files'])) {\n                    $sizeInfo['fileCnt'] = $volRes['files'];\n                }\n                if (!empty($volRes['dirs'])) {\n                    $sizeInfo['dirCnt'] = $volRes['dirs'];\n                }\n                if ($itemCount) {\n                    $files += $sizeInfo['fileCnt'];\n                    $dirs += $sizeInfo['dirCnt'];\n                }\n                $sizes[$target] = $sizeInfo;\n            } else if (is_numeric($volRes)) {\n                $size += $volRes;\n                $files = $dirs = 'unknown';\n                $itemCount = false;\n            }\n        }\n        return array('size' => $size, 'fileCnt' => $files, 'dirCnt' => $dirs, 'sizes' => $sizes);\n    }\n\n    /**\n     * Create directory\n     *\n     * @param  array  command arguments\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function mkdir($args)\n    {\n        $target = $args['target'];\n        $name = $args['name'];\n        $dirs = $args['dirs'];\n        if ($name === '' && !$dirs) {\n            return array('error' => $this->error(self::ERROR_INV_PARAMS, 'mkdir'));\n        }\n\n        if (($volume = $this->volume($target)) == false) {\n            return array('error' => $this->error(self::ERROR_MKDIR, $name, self::ERROR_TRGDIR_NOT_FOUND, '#' . $target));\n        }\n        if ($dirs) {\n            sort($dirs);\n            $reset = null;\n            $mkdirs = array();\n            foreach ($dirs as $dir) {\n                $tgt =& $mkdirs;\n                $_names = explode('/', trim($dir, '/'));\n                foreach ($_names as $_key => $_name) {\n                    if (!isset($tgt[$_name])) {\n                        $tgt[$_name] = array();\n                    }\n                    $tgt =& $tgt[$_name];\n                }\n                $tgt =& $reset;\n            }\n            $res = $this->ensureDirsRecursively($volume, $target, $mkdirs);\n            $ret = array(\n                'added' => $res['stats'],\n                'hashes' => $res['hashes']\n            );\n            if ($res['error']) {\n                $ret['warning'] = $this->error(self::ERROR_MKDIR, $res['error'][0], $volume->error());\n            }\n            return $ret;\n        } else {\n            return ($dir = $volume->mkdir($target, $name)) == false\n                ? array('error' => $this->error(self::ERROR_MKDIR, $name, $volume->error()))\n                : array('added' => array($dir));\n        }\n    }\n\n    /**\n     * Create empty file\n     *\n     * @param  array  command arguments\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function mkfile($args)\n    {\n        $target = $args['target'];\n        $name = $args['name'];\n\n        if (($volume = $this->volume($target)) == false) {\n            return array('error' => $this->error(self::ERROR_MKFILE, $name, self::ERROR_TRGDIR_NOT_FOUND, '#' . $target));\n        }\n\n        return ($file = $volume->mkfile($target, $args['name'])) == false\n            ? array('error' => $this->error(self::ERROR_MKFILE, $name, $volume->error()))\n            : array('added' => array($file));\n    }\n\n    /**\n     * Rename file, Accept multiple items >= API 2.1031\n     *\n     * @param  array $args\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     * @author Naoki Sawada\n     */\n    protected function rename($args)\n    {\n        $target = $args['target'];\n        $name = $args['name'];\n        $query = (strpos($args['q'], '*') !== false) ? $args['q'] : '';\n        $targets = $args['targets'];\n        $rms = array();\n        $notfounds = array();\n        $locked = array();\n        $errs = array();\n        $files = array();\n        $removed = array();\n        $res = array();\n        $type = 'normal';\n\n        if (!($volume = $this->volume($target))) {\n            return array('error' => $this->error(self::ERROR_RENAME, '#' . $target, self::ERROR_FILE_NOT_FOUND));\n        }\n\n        if ($targets) {\n            array_unshift($targets, $target);\n            foreach ($targets as $h) {\n                if ($rm = $volume->file($h)) {\n                    if ($this->itemLocked($h)) {\n                        $locked[] = $rm['name'];\n                    } else {\n                        $rm['realpath'] = $volume->realpath($h);\n                        $rms[] = $rm;\n                    }\n                } else {\n                    $notfounds[] = '#' . $h;\n                }\n            }\n            if (!$rms) {\n                $res['error'] = array();\n                if ($notfounds) {\n                    $res['error'] = array(self::ERROR_RENAME, join(', ', $notfounds), self::ERROR_FILE_NOT_FOUND);\n                }\n                if ($locked) {\n                    array_push($res['error'], self::ERROR_LOCKED, join(', ', $locked));\n                }\n                return $res;\n            }\n\n            $res['warning'] = array();\n            if ($notfounds) {\n                array_push($res['warning'], self::ERROR_RENAME, join(', ', $notfounds), self::ERROR_FILE_NOT_FOUND);\n            }\n            if ($locked) {\n                array_push($res['warning'], self::ERROR_LOCKED, join(', ', $locked));\n            }\n\n            if ($query) {\n                // batch rename\n                $splits = elFinder::splitFileExtention($query);\n                if ($splits[1] && $splits[0] === '*') {\n                    $type = 'extention';\n                    $name = $splits[1];\n                } else if (strlen($splits[0]) > 1) {\n                    if (substr($splits[0], -1) === '*') {\n                        $type = 'prefix';\n                        $name = substr($splits[0], 0, strlen($splits[0]) - 1);\n                    } else if (substr($splits[0], 0, 1) === '*') {\n                        $type = 'suffix';\n                        $name = substr($splits[0], 1);\n                    }\n                }\n                if ($type !== 'normal') {\n                    if (!empty($this->listeners['rename.pre'])) {\n                        $_args = array('name' => $name);\n                        foreach ($this->listeners['rename.pre'] as $handler) {\n                            $_res = call_user_func_array($handler, array('rename', &$_args, $this, $volume));\n                            if (!empty($_res['preventexec'])) {\n                                break;\n                            }\n                        }\n                        $name = $_args['name'];\n                    }\n                }\n            }\n            foreach ($rms as $rm) {\n                if ($type === 'normal') {\n                    $rname = $volume->uniqueName($volume->realpath($rm['phash']), $name, '', false);\n                } else {\n                    $rname = $name;\n                    if ($type === 'extention') {\n                        $splits = elFinder::splitFileExtention($rm['name']);\n                        $rname = $splits[0] . '.' . $name;\n                    } else if ($type === 'prefix') {\n                        $rname = $name . $rm['name'];\n                    } else if ($type === 'suffix') {\n                        $splits = elFinder::splitFileExtention($rm['name']);\n                        $rname = $splits[0] . $name . ($splits[1] ? ('.' . $splits[1]) : '');\n                    }\n                    $rname = $volume->uniqueName($volume->realpath($rm['phash']), $rname, '', true);\n                }\n                if ($file = $volume->rename($rm['hash'], $rname)) {\n                    $files[] = $file;\n                    $removed[] = $rm;\n                } else {\n                    $errs[] = $rm['name'];\n                }\n            }\n\n            if (!$files) {\n                $res['error'] = $this->error(self::ERROR_RENAME, join(', ', $errs), $volume->error());\n                if (!$res['warning']) {\n                    unset($res['warning']);\n                }\n                return $res;\n            }\n            if ($errs) {\n                array_push($res['warning'], self::ERROR_RENAME, join(', ', $errs), $volume->error());\n            }\n            if (!$res['warning']) {\n                unset($res['warning']);\n            }\n            $res['added'] = $files;\n            $res['removed'] = $removed;\n            return $res;\n        } else {\n            if (!($rm = $volume->file($target))) {\n                return array('error' => $this->error(self::ERROR_RENAME, '#' . $target, self::ERROR_FILE_NOT_FOUND));\n            }\n            if ($this->itemLocked($target)) {\n                return array('error' => $this->error(self::ERROR_LOCKED, $rm['name']));\n            }\n            $rm['realpath'] = $volume->realpath($target);\n\n            return ($file = $volume->rename($target, $name)) == false\n                ? array('error' => $this->error(self::ERROR_RENAME, $rm['name'], $volume->error()))\n                : array('added' => array($file), 'removed' => array($rm));\n        }\n    }\n\n    /**\n     * Duplicate file - create copy with \"copy %d\" suffix\n     *\n     * @param array $args command arguments\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function duplicate($args)\n    {\n        $targets = is_array($args['targets']) ? $args['targets'] : array();\n        $result = array();\n        $suffix = empty($args['suffix']) ? 'copy' : $args['suffix'];\n\n        $this->itemLock($targets);\n\n        foreach ($targets as $target) {\n            elFinder::checkAborted();\n\n            if (($volume = $this->volume($target)) == false\n                || ($src = $volume->file($target)) == false) {\n                $result['warning'] = $this->error(self::ERROR_COPY, '#' . $target, self::ERROR_FILE_NOT_FOUND);\n                break;\n            }\n\n            if (($file = $volume->duplicate($target, $suffix)) == false) {\n                $result['warning'] = $this->error($volume->error());\n                break;\n            }\n        }\n\n        return $result;\n    }\n\n    /**\n     * Remove dirs/files\n     *\n     * @param array  command arguments\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function rm($args)\n    {\n        $targets = is_array($args['targets']) ? $args['targets'] : array();\n        $result = array('removed' => array());\n\n        foreach ($targets as $target) {\n            elFinder::checkAborted();\n\n            if (($volume = $this->volume($target)) == false) {\n                $result['warning'] = $this->error(self::ERROR_RM, '#' . $target, self::ERROR_FILE_NOT_FOUND);\n                break;\n            }\n\n            if ($this->itemLocked($target)) {\n                $rm = $volume->file($target);\n                $result['warning'] = $this->error(self::ERROR_LOCKED, $rm['name']);\n                break;\n            }\n\n            if (!$volume->rm($target)) {\n                $result['warning'] = $this->error($volume->error());\n                break;\n            }\n        }\n\n        return $result;\n    }\n\n    /**\n     * Return has subdirs\n     *\n     * @param  array  command arguments\n     *\n     * @return array\n     * @author Dmitry Naoki Sawada\n     **/\n    protected function subdirs($args)\n    {\n\n        $result = array('subdirs' => array());\n        $targets = $args['targets'];\n\n        foreach ($targets as $target) {\n            if (($volume = $this->volume($target)) !== false) {\n                $result['subdirs'][$target] = $volume->subdirs($target) ? 1 : 0;\n            }\n        }\n        return $result;\n    }\n\n    /**\n     * Gateway for custom contents editor\n     *\n     * @param  array $args command arguments\n     *\n     * @return array\n     * @author Naoki Sawada\n     */\n    protected function editor($args = array())\n    {\n        /* @var elFinderEditor $editor */\n        $name = $args['name'];\n        if (is_array($name)) {\n            $res = array();\n            foreach ($name as $c) {\n                $class = 'elFinderEditor' . $c;\n                if (class_exists($class)) {\n                    $editor = new $class($this, $args['args']);\n                    $res[$c] = $editor->enabled();\n                } else {\n                    $res[$c] = 0;\n                }\n            }\n            return $res;\n        } else {\n            $class = 'elFinderEditor' . $name;\n            $method = '';\n            if (class_exists($class)) {\n                $editor = new $class($this, $args['args']);\n                $method = $args['method'];\n                if ($editor->isAllowedMethod($method) && method_exists($editor, $method)) {\n                    return $editor->$method();\n                }\n            }\n            return array('error', $this->error(self::ERROR_UNKNOWN_CMD, 'editor.' . $name . '.' . $method));\n        }\n    }\n\n    /**\n     * Abort current request and make flag file to running check\n     *\n     * @param array $args\n     *\n     * @return void\n     */\n    protected function abort($args = array())\n    {\n        if (!elFinder::$connectionFlagsPath || $_SERVER['REQUEST_METHOD'] === 'HEAD') {\n            return;\n        }\n        $flagFile = elFinder::$connectionFlagsPath . DIRECTORY_SEPARATOR . 'elfreq%s';\n        if (!empty($args['makeFile'])) {\n            self::$abortCheckFile = sprintf($flagFile, $args['makeFile']);\n            touch(self::$abortCheckFile);\n            $GLOBALS['elFinderTempFiles'][self::$abortCheckFile] = true;\n            return;\n        }\n\n        $file = !empty($args['id']) ? sprintf($flagFile, $args['id']) : self::$abortCheckFile;\n        $file && is_file($file) && unlink($file);\n    }\n\n    /**\n     * Get remote contents\n     *\n     * @param  string   $url          target url\n     * @param  int      $timeout      timeout (sec)\n     * @param  int      $redirect_max redirect max count\n     * @param  string   $ua\n     * @param  resource $fp\n     *\n     * @return string, resource or bool(false)\n     * @retval  string contents\n     * @retval  resource conttents\n     * @rettval false  error\n     * @author  Naoki Sawada\n     **/\n    protected function get_remote_contents(&$url, $timeout = 30, $redirect_max = 5, $ua = 'Mozilla/5.0', $fp = null)\n    {\n        if (preg_match('~^(?:ht|f)tps?://[-_.!\\~*\\'()a-z0-9;/?:\\@&=+\\$,%#\\*\\[\\]]+~i', $url)) {\n            $info = parse_url($url);\n            $host = strtolower($info['host']);\n            // do not support IPv6 address\n            if (preg_match('/^\\[.*\\]$/', $host)) {\n                return false;\n            }\n            // do not support non dot URL\n            if (strpos($host, '.') === false) {\n                return false;\n            }\n            // disallow including \"localhost\"\n            if (strpos($host, 'localhost') !== false) {\n                return false;\n            }\n            // check IPv4 local loopback\n            if (preg_match('/^(?:127|0177|0x7f)\\.[0-9a-fx.]+$/', $host)) {\n                return false;\n            }\n            // check by URL upload filter\n            if ($this->urlUploadFilter && is_callable($this->urlUploadFilter)) {\n                if (!call_user_func_array($this->urlUploadFilter, array($url, $this))) {\n                    return false;\n                }\n            }\n            $method = (function_exists('curl_exec') && !ini_get('safe_mode') && !ini_get('open_basedir')) ? 'curl_get_contents' : 'fsock_get_contents';\n            return $this->$method($url, $timeout, $redirect_max, $ua, $fp);\n        }\n        return false;\n    }\n\n    /**\n     * Get remote contents with cURL\n     *\n     * @param  string   $url          target url\n     * @param  int      $timeout      timeout (sec)\n     * @param  int      $redirect_max redirect max count\n     * @param  string   $ua\n     * @param  resource $outfp\n     *\n     * @return string, resource or bool(false)\n     * @retval string contents\n     * @retval resource conttents\n     * @retval false  error\n     * @author Naoki Sawada\n     **/\n    protected function curl_get_contents(&$url, $timeout, $redirect_max, $ua, $outfp)\n    {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_HEADER, false);\n        if ($outfp) {\n            curl_setopt($ch, CURLOPT_FILE, $outfp);\n        } else {\n            curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n            curl_setopt($ch, CURLOPT_BINARYTRANSFER, true);\n        }\n        curl_setopt($ch, CURLOPT_LOW_SPEED_LIMIT, 1);\n        curl_setopt($ch, CURLOPT_LOW_SPEED_TIME, $timeout);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);\n        curl_setopt($ch, CURLOPT_MAXREDIRS, $redirect_max);\n        curl_setopt($ch, CURLOPT_USERAGENT, $ua);\n        $result = curl_exec($ch);\n        $url = curl_getinfo($ch, CURLINFO_EFFECTIVE_URL);\n        curl_close($ch);\n        return $outfp ? $outfp : $result;\n    }\n\n    /**\n     * Get remote contents with fsockopen()\n     *\n     * @param  string   $url          url\n     * @param  int      $timeout      timeout (sec)\n     * @param  int      $redirect_max redirect max count\n     * @param  string   $ua\n     * @param  resource $outfp\n     *\n     * @return string, resource or bool(false)\n     * @retval string contents\n     * @retval resource conttents\n     * @retval false  error\n     * @throws elFinderAbortException\n     * @author Naoki Sawada\n     */\n    protected function fsock_get_contents(&$url, $timeout, $redirect_max, $ua, $outfp)\n    {\n        $connect_timeout = 3;\n        $connect_try = 3;\n        $method = 'GET';\n        $readsize = 4096;\n        $ssl = '';\n\n        $getSize = null;\n        $headers = '';\n\n        $arr = parse_url($url);\n        if (!$arr) {\n            // Bad request\n            return false;\n        }\n        if ($arr['scheme'] === 'https') {\n            $ssl = 'ssl://';\n        }\n\n        // query\n        $arr['query'] = isset($arr['query']) ? '?' . $arr['query'] : '';\n        // port\n        $port = isset($arr['port']) ? $arr['port'] : '';\n        $arr['port'] = $port ? $port : ($ssl ? 443 : 80);\n\n        $url_base = $arr['scheme'] . '://' . $arr['host'] . ($port ? (':' . $port) : '');\n        $url_path = isset($arr['path']) ? $arr['path'] : '/';\n        $uri = $url_path . $arr['query'];\n\n        $query = $method . ' ' . $uri . \" HTTP/1.0\\r\\n\";\n        $query .= \"Host: \" . $arr['host'] . \"\\r\\n\";\n        $query .= \"Accept: */*\\r\\n\";\n        $query .= \"Connection: close\\r\\n\";\n        if (!empty($ua)) $query .= \"User-Agent: \" . $ua . \"\\r\\n\";\n        if (!is_null($getSize)) $query .= 'Range: bytes=0-' . ($getSize - 1) . \"\\r\\n\";\n\n        $query .= $headers;\n\n        $query .= \"\\r\\n\";\n\n        $fp = $connect_try_count = 0;\n        while (!$fp && $connect_try_count < $connect_try) {\n\n            $errno = 0;\n            $errstr = \"\";\n            $fp = fsockopen(\n                $ssl . $arr['host'],\n                $arr['port'],\n                $errno, $errstr, $connect_timeout);\n            if ($fp) break;\n            $connect_try_count++;\n            if (connection_aborted()) {\n                throw new elFinderAbortException();\n            }\n            sleep(1); // wait 1sec\n        }\n\n        $fwrite = 0;\n        for ($written = 0; $written < strlen($query); $written += $fwrite) {\n            $fwrite = fwrite($fp, substr($query, $written));\n            if (!$fwrite) {\n                break;\n            }\n        }\n\n        if ($timeout) {\n            socket_set_timeout($fp, $timeout);\n        }\n\n        $_response = '';\n        $header = '';\n        while ($_response !== \"\\r\\n\") {\n            $_response = fgets($fp, $readsize);\n            $header .= $_response;\n        };\n\n        $rccd = array_pad(explode(' ', $header, 2), 2, ''); // array('HTTP/1.1','200')\n        $rc = (int)$rccd[1];\n\n        $ret = false;\n        // Redirect\n        switch ($rc) {\n            case 307: // Temporary Redirect\n            case 303: // See Other\n            case 302: // Moved Temporarily\n            case 301: // Moved Permanently\n                $matches = array();\n                if (preg_match('/^Location: (.+?)(#.+)?$/im', $header, $matches) && --$redirect_max > 0) {\n                    $_url = $url;\n                    $url = trim($matches[1]);\n                    if (!preg_match('/^https?:\\//', $url)) { // no scheme\n                        if ($url{0} != '/') { // Relative path\n                            // to Absolute path\n                            $url = substr($url_path, 0, strrpos($url_path, '/')) . '/' . $url;\n                        }\n                        // add sheme,host\n                        $url = $url_base . $url;\n                    }\n                    if ($_url === $url) {\n                        sleep(1);\n                    }\n                    fclose($fp);\n                    return $this->fsock_get_contents($url, $timeout, $redirect_max, $ua, $outfp);\n                }\n                break;\n            case 200:\n                $ret = true;\n        }\n        if (!$ret) {\n            fclose($fp);\n            return false;\n        }\n\n        $body = '';\n        if (!$outfp) {\n            $outfp = fopen('php://temp', 'rwb');\n            $body = true;\n        }\n        while (fwrite($outfp, fread($fp, $readsize))) {\n            if ($timeout) {\n                $_status = socket_get_status($fp);\n                if ($_status['timed_out']) {\n                    fclose($outfp);\n                    fclose($fp);\n                    return false; // Request Time-out\n                }\n            }\n        }\n        if ($body) {\n            rewind($outfp);\n            $body = stream_get_contents($outfp);\n            fclose($outfp);\n            $outfp = null;\n        }\n\n        fclose($fp);\n\n        return $outfp ? $outfp : $body; // Data\n    }\n\n    /**\n     * Parse Data URI scheme\n     *\n     * @param  string $str\n     * @param  array  $extTable\n     * @param  array  $args\n     *\n     * @return array\n     * @author Naoki Sawada\n     */\n    protected function parse_data_scheme($str, $extTable, $args = null)\n    {\n        $data = $name = $mime = '';\n        // Scheme 'data://' require `allow_url_fopen` and `allow_url_include`\n        if ($fp = fopen('data://' . substr($str, 5), 'rb')) {\n            if ($data = stream_get_contents($fp)) {\n                $meta = stream_get_meta_data($fp);\n                $mime = $meta['mediatype'];\n            }\n            fclose($fp);\n        } else if (preg_match('~^data:(.+?/.+?)?(?:;charset=.+?)?;base64,~', substr($str, 0, 128), $m)) {\n            $data = base64_decode(substr($str, strlen($m[0])));\n            if ($m[1]) {\n                $mime = $m[1];\n            }\n        }\n        if ($data) {\n            $ext = ($mime && isset($extTable[$mime])) ? '.' . $extTable[$mime] : '';\n            // Set name if name eq 'image.png' and $args has 'name' array, e.g. clipboard data\n            if (is_array($args['name']) && isset($args['name'][0])) {\n                $name = $args['name'][0];\n                if ($ext) {\n                    $name = preg_replace('/\\.[^.]*$/', '', $name);\n                }\n            } else {\n                $name = substr(md5($data), 0, 8);\n            }\n            $name .= $ext;\n        } else {\n            $data = $name = '';\n        }\n        return array($data, $name);\n    }\n\n    /**\n     * Detect file MIME Type by local path\n     *\n     * @param  string $path Local path\n     *\n     * @return string file MIME Type\n     * @author Naoki Sawada\n     */\n    protected function detectMimeType($path)\n    {\n        static $type, $finfo;\n        if (!$type) {\n            if (class_exists('finfo', false)) {\n                $tmpFileInfo = explode(';', finfo_file(finfo_open(FILEINFO_MIME), __FILE__));\n            } else {\n                $tmpFileInfo = false;\n            }\n            $regexp = '/text\\/x\\-(php|c\\+\\+)/';\n            if ($tmpFileInfo && preg_match($regexp, array_shift($tmpFileInfo))) {\n                $type = 'finfo';\n                $finfo = finfo_open(FILEINFO_MIME);\n            } elseif (function_exists('mime_content_type')\n                && preg_match($regexp, array_shift(explode(';', mime_content_type(__FILE__))))) {\n                $type = 'mime_content_type';\n            } elseif (function_exists('getimagesize')) {\n                $type = 'getimagesize';\n            } else {\n                $type = 'none';\n            }\n        }\n\n        $mime = '';\n        if ($type === 'finfo') {\n            $mime = finfo_file($finfo, $path);\n        } elseif ($type === 'mime_content_type') {\n            $mime = mime_content_type($path);\n        } elseif ($type === 'getimagesize') {\n            if ($img = getimagesize($path)) {\n                $mime = $img['mime'];\n            }\n        }\n\n        if ($mime) {\n            $mime = explode(';', $mime);\n            $mime = trim($mime[0]);\n\n            if (in_array($mime, array('application/x-empty', 'inode/x-empty'))) {\n                // finfo return this mime for empty files\n                $mime = 'text/plain';\n            } elseif ($mime == 'application/x-zip') {\n                // http://elrte.org/redmine/issues/163\n                $mime = 'application/zip';\n            }\n        }\n\n        return $mime ? $mime : 'unknown';\n    }\n\n    /**\n     * Detect file type extension by local path\n     *\n     * @param  object $volume elFinderVolumeDriver instance\n     * @param  string $path   Local path\n     * @param  string $name   Filename to save\n     *\n     * @return string file type extension with dot\n     * @author Naoki Sawada\n     */\n    protected function detectFileExtension($volume, $path, $name)\n    {\n        $mime = $this->detectMimeType($path);\n        if ($mime === 'unknown') {\n            $mime = 'application/octet-stream';\n        }\n        $ext = $volume->getExtentionByMime($volume->mimeTypeNormalize($mime, $name));\n        return $ext ? ('.' . $ext) : '';\n    }\n\n    /**\n     * Get temporary directory path\n     *\n     * @param  string $volumeTempPath\n     *\n     * @return string\n     * @author Naoki Sawada\n     */\n    private function getTempDir($volumeTempPath = null)\n    {\n        $testDirs = array();\n        if ($this->uploadTempPath) {\n            $testDirs[] = rtrim(realpath($this->uploadTempPath), DIRECTORY_SEPARATOR);\n        }\n        if ($volumeTempPath) {\n            $testDirs[] = rtrim(realpath($volumeTempPath), DIRECTORY_SEPARATOR);\n        }\n        if (elFinder::$commonTempPath) {\n            $testDirs[] = elFinder::$commonTempPath;\n        }\n        $tempDir = '';\n        foreach ($testDirs as $testDir) {\n            if (!$testDir || !is_dir($testDir)) continue;\n            if (is_writable($testDir)) {\n                $tempDir = $testDir;\n                $gc = time() - 3600;\n                foreach (glob($tempDir . DIRECTORY_SEPARATOR . 'ELF*') as $cf) {\n                    if (filemtime($cf) < $gc) {\n                        unlink($cf);\n                    }\n                }\n                break;\n            }\n        }\n        return $tempDir;\n    }\n\n    /**\n     * chmod\n     *\n     * @param array  command arguments\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author David Bartle\n     */\n    protected function chmod($args)\n    {\n        $targets = $args['targets'];\n        $mode = intval((string)$args['mode'], 8);\n\n        if (!is_array($targets)) {\n            $targets = array($targets);\n        }\n\n        $result = array();\n\n        if (($volume = $this->volume($targets[0])) == false) {\n            $result['error'] = $this->error(self::ERROR_CONF_NO_VOL);\n            return $result;\n        }\n\n        $this->itemLock($targets);\n\n        $files = array();\n        $errors = array();\n        foreach ($targets as $target) {\n            elFinder::checkAborted();\n\n            $file = $volume->chmod($target, $mode);\n            if ($file) {\n                $files = array_merge($files, is_array($file) ? $file : array($file));\n            } else {\n                $errors = array_merge($errors, $volume->error());\n            }\n        }\n\n        if ($files) {\n            $result['changed'] = $files;\n            if ($errors) {\n                $result['warning'] = $this->error($errors);\n            }\n        } else {\n            $result['error'] = $this->error($errors);\n        }\n\n        return $result;\n    }\n\n    /**\n     * Check chunked upload files\n     *\n     * @param string $tmpname uploaded temporary file path\n     * @param string $chunk   uploaded chunk file name\n     * @param string $cid     uploaded chunked file id\n     * @param string $tempDir temporary dirctroy path\n     * @param null   $volume\n     *\n     * @return array|null\n     * @throws elFinderAbortException\n     * @author Naoki Sawada\n     */\n    private function checkChunkedFile($tmpname, $chunk, $cid, $tempDir, $volume = null)\n    {\n        /* @var elFinderVolumeDriver $volume */\n        if (preg_match('/^(.+)(\\.\\d+_(\\d+))\\.part$/s', $chunk, $m)) {\n            $fname = $m[1];\n            $encname = md5($cid . '_' . $fname);\n            $base = $tempDir . DIRECTORY_SEPARATOR . 'ELF' . $encname;\n            $clast = intval($m[3]);\n            if (is_null($tmpname)) {\n                ignore_user_abort(true);\n                // chunked file upload fail\n                foreach (glob($base . '*') as $cf) {\n                    unlink($cf);\n                }\n                ignore_user_abort(false);\n                return null;\n            }\n\n            $range = isset($_POST['range']) ? trim($_POST['range']) : '';\n            if ($range && preg_match('/^(\\d+),(\\d+),(\\d+)$/', $range, $ranges)) {\n                $start = $ranges[1];\n                $len = $ranges[2];\n                $size = $ranges[3];\n                $tmp = $base . '.part';\n                $csize = filesize($tmpname);\n\n                $tmpExists = is_file($tmp);\n                if (!$tmpExists) {\n                    // check upload max size\n                    $uploadMaxSize = $volume ? $volume->getUploadMaxSize() : 0;\n                    if ($uploadMaxSize > 0 && $size > $uploadMaxSize) {\n                        return array(self::ERROR_UPLOAD_FILE_SIZE, false);\n                    }\n                    // make temp file\n                    $ok = false;\n                    if ($fp = fopen($tmp, 'wb')) {\n                        flock($fp, LOCK_EX);\n                        $ok = ftruncate($fp, $size);\n                        flock($fp, LOCK_UN);\n                        fclose($fp);\n                        touch($base);\n                    }\n                    if (!$ok) {\n                        unlink($tmp);\n                        return array(self::ERROR_UPLOAD_TEMP, false);\n                    }\n                } else {\n                    // wait until makeing temp file (for anothor session)\n                    $cnt = 1200; // Time limit 120 sec\n                    while (!is_file($base) && --$cnt) {\n                        usleep(100000); // wait 100ms\n                    }\n                    if (!$cnt) {\n                        return array(self::ERROR_UPLOAD_TEMP, false);\n                    }\n                }\n\n                // check size info\n                if ($len != $csize || $start + $len > $size || ($tmpExists && $size != filesize($tmp))) {\n                    return array(self::ERROR_UPLOAD_TEMP, false);\n                }\n\n                // write chunk data\n                $src = fopen($tmpname, 'rb');\n                $fp = fopen($tmp, 'cb');\n                fseek($fp, $start);\n                $writelen = stream_copy_to_stream($src, $fp, $len);\n                fclose($fp);\n                fclose($src);\n\n                try {\n                    // to check connection is aborted\n                    elFinder::checkAborted();\n                } catch (elFinderAbortException $e) {\n                    unlink($tmpname);\n                    is_file($tmp) && unlink($tmp);\n                    is_file($base) && unlink($base);\n                    throw $e;\n                }\n\n                if ($writelen != $len) {\n                    return array(self::ERROR_UPLOAD_TEMP, false);\n                }\n\n                // write counts\n                file_put_contents($base, \"\\0\", FILE_APPEND | LOCK_EX);\n\n                if (filesize($base) >= $clast + 1) {\n                    // Completion\n                    unlink($base);\n                    return array($tmp, $fname);\n                }\n            } else {\n                // old way\n                $part = $base . $m[2];\n                if (move_uploaded_file($tmpname, $part)) {\n                    chmod($part, 0600);\n                    if ($clast < count(glob($base . '*'))) {\n                        $parts = array();\n                        for ($i = 0; $i <= $clast; $i++) {\n                            $name = $base . '.' . $i . '_' . $clast;\n                            if (is_readable($name)) {\n                                $parts[] = $name;\n                            } else {\n                                $parts = null;\n                                break;\n                            }\n                        }\n                        if ($parts) {\n                            if (!is_file($base)) {\n                                touch($base);\n                                if ($resfile = tempnam($tempDir, 'ELF')) {\n                                    $target = fopen($resfile, 'wb');\n                                    foreach ($parts as $f) {\n                                        $fp = fopen($f, 'rb');\n                                        while (!feof($fp)) {\n                                            fwrite($target, fread($fp, 8192));\n                                        }\n                                        fclose($fp);\n                                        unlink($f);\n                                    }\n                                    fclose($target);\n                                    unlink($base);\n                                    return array($resfile, $fname);\n                                }\n                                unlink($base);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return array('', '');\n    }\n\n    /**\n     * Save uploaded files\n     *\n     * @param  array\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function upload($args)\n    {\n        $ngReg = '/[\\/\\\\?*:|\"<>]/';\n        $target = $args['target'];\n        $volume = $this->volume($target);\n        $files = isset($args['FILES']['upload']) && is_array($args['FILES']['upload']) ? $args['FILES']['upload'] : array();\n        $header = empty($args['html']) ? array() : array('header' => 'Content-Type: text/html; charset=utf-8');\n        $result = array_merge(array('added' => array()), $header);\n        $paths = $args['upload_path'] ? $args['upload_path'] : array();\n        $chunk = $args['chunk'] ? $args['chunk'] : '';\n        $cid = $args['cid'] ? (int)$args['cid'] : '';\n        $mtimes = $args['mtime'] ? $args['mtime'] : array();\n        $tmpfname = '';\n\n        if (!$volume) {\n            return array_merge(array('error' => $this->error(self::ERROR_UPLOAD, self::ERROR_TRGDIR_NOT_FOUND, '#' . $target)), $header);\n        }\n\n        // check $chunk\n        if (strpos($chunk, '/') !== false || strpos($chunk, '\\\\') !== false) {\n            return array('error' => $this->error(self::ERROR_UPLOAD));\n        }\n\n        if ($args['overwrite'] !== '') {\n            $volume->setUploadOverwrite($args['overwrite']);\n        }\n\n        $renames = $hashes = array();\n        $suffix = '~';\n        if ($args['renames'] && is_array($args['renames'])) {\n            $renames = array_flip($args['renames']);\n            if (is_string($args['suffix']) && !preg_match($ngReg, $args['suffix'])) {\n                $suffix = $args['suffix'];\n            }\n        }\n        if ($args['hashes'] && is_array($args['hashes'])) {\n            $hashes = array_flip($args['hashes']);\n        }\n\n        $this->itemLock($target);\n\n        // file extentions table by MIME\n        $extTable = array_flip(array_unique($volume->getMimeTable()));\n\n        if (empty($files)) {\n            if (isset($args['upload']) && is_array($args['upload']) && ($tempDir = $this->getTempDir($volume->getTempPath()))) {\n                $names = array();\n                foreach ($args['upload'] as $i => $url) {\n                    // check chunked file upload commit\n                    if ($chunk) {\n                        if ($url === 'chunkfail' && $args['mimes'] === 'chunkfail') {\n                            $this->checkChunkedFile(null, $chunk, $cid, $tempDir);\n                            if (preg_match('/^(.+)(\\.\\d+_(\\d+))\\.part$/s', $chunk, $m)) {\n                                $result['warning'] = $this->error(self::ERROR_UPLOAD_FILE, $m[1], self::ERROR_UPLOAD_TEMP);\n                            }\n                            return $result;\n                        } else {\n                            $tmpfname = $tempDir . '/' . $chunk;\n                            $files['tmp_name'][$i] = $tmpfname;\n                            $files['name'][$i] = $url;\n                            $files['error'][$i] = 0;\n                            $GLOBALS['elFinderTempFiles'][$tmpfname] = true;\n                            break;\n                        }\n                    }\n\n                    $tmpfname = $tempDir . DIRECTORY_SEPARATOR . 'ELF_FATCH_' . md5($url . microtime(true));\n                    $GLOBALS['elFinderTempFiles'][$tmpfname] = true;\n\n                    $_name = '';\n                    // check is data:\n                    if (substr($url, 0, 5) === 'data:') {\n                        list($data, $args['name'][$i]) = $this->parse_data_scheme($url, $extTable, $args);\n                    } else {\n                        $fp = fopen($tmpfname, 'wb');\n                        if ($data = $this->get_remote_contents($url, 30, 5, 'Mozilla/5.0', $fp)) {\n                            // to check connection is aborted\n                            elFinder::checkAborted();\n                            $_name = preg_replace('~^.*?([^/#?]+)(?:\\?.*)?(?:#.*)?$~', '$1', rawurldecode($url));\n                            // Check `Content-Disposition` response header\n                            if ($data && ($headers = get_headers($url, true)) && !empty($headers['Content-Disposition'])) {\n                                if (preg_match('/filename\\*=(?:([a-zA-Z0-9_-]+?)\\'\\')\"?([a-z0-9_.~%-]+)\"?/i', $headers['Content-Disposition'], $m)) {\n                                    $_name = rawurldecode($m[2]);\n                                    if ($m[1] && strtoupper($m[1]) !== 'UTF-8' && function_exists('mb_convert_encoding')) {\n                                        $_name = mb_convert_encoding($_name, 'UTF-8', $m[1]);\n                                    }\n                                } else if (preg_match('/filename=\"?([ a-z0-9_.~%-]+)\"?/i', $headers['Content-Disposition'], $m)) {\n                                    $_name = rawurldecode($m[1]);\n                                }\n                            }\n                        }\n                    }\n                    if ($data) {\n                        if (isset($args['name'][$i])) {\n                            $_name = $args['name'][$i];\n                        }\n                        if ($_name) {\n                            $_ext = '';\n                            if (preg_match('/(\\.[a-z0-9]{1,7})$/', $_name, $_match)) {\n                                $_ext = $_match[1];\n                            }\n                            if ((is_resource($data) && fclose($data)) || file_put_contents($tmpfname, $data)) {\n                                $GLOBALS['elFinderTempFiles'][$tmpfname] = true;\n                                $_name = preg_replace($ngReg, '_', $_name);\n                                list($_a, $_b) = array_pad(explode('.', $_name, 2), 2, '');\n                                if ($_b === '') {\n                                    if ($_ext) {\n                                        rename($tmpfname, $tmpfname . $_ext);\n                                        $tmpfname = $tmpfname . $_ext;\n                                    }\n                                    $_b = $this->detectFileExtension($volume, $tmpfname, $_name);\n                                    $_name = $_a . $_b;\n                                } else {\n                                    $_b = '.' . $_b;\n                                }\n                                if (isset($names[$_name])) {\n                                    $_name = $_a . '_' . $names[$_name]++ . $_b;\n                                } else {\n                                    $names[$_name] = 1;\n                                }\n                                $files['tmp_name'][$i] = $tmpfname;\n                                $files['name'][$i] = $_name;\n                                $files['error'][$i] = 0;\n                                // set to auto rename\n                                $volume->setUploadOverwrite(false);\n                            } else {\n                                unlink($tmpfname);\n                            }\n                        }\n                    }\n                }\n            }\n            if (empty($files)) {\n                return array_merge(array('error' => $this->error(self::ERROR_UPLOAD, self::ERROR_UPLOAD_NO_FILES)), $header);\n            }\n        }\n\n        $addedDirs = array();\n        $errors = array();\n        foreach ($files['name'] as $i => $name) {\n            if (($error = $files['error'][$i]) > 0) {\n                $result['warning'] = $this->error(self::ERROR_UPLOAD_FILE, $name, $error == UPLOAD_ERR_INI_SIZE || $error == UPLOAD_ERR_FORM_SIZE ? self::ERROR_UPLOAD_FILE_SIZE : self::ERROR_UPLOAD_TRANSFER, $error);\n                $this->uploadDebug = 'Upload error code: ' . $error;\n                break;\n            }\n\n            $tmpname = $files['tmp_name'][$i];\n            $thash = ($paths && isset($paths[$i])) ? $paths[$i] : $target;\n            $mtime = isset($mtimes[$i]) ? $mtimes[$i] : 0;\n            if ($name === 'blob') {\n                if ($chunk) {\n                    if ($tempDir = $this->getTempDir($volume->getTempPath())) {\n                        list($tmpname, $name) = $this->checkChunkedFile($tmpname, $chunk, $cid, $tempDir, $volume);\n                        if ($tmpname) {\n                            if ($name === false) {\n                                preg_match('/^(.+)(\\.\\d+_(\\d+))\\.part$/s', $chunk, $m);\n                                $result['error'] = $this->error(self::ERROR_UPLOAD_FILE, $m[1], $tmpname);\n                                $result['_chunkfailure'] = true;\n                                $this->uploadDebug = 'Upload error: ' . $tmpname;\n                            } else if ($name) {\n                                $result['_chunkmerged'] = basename($tmpname);\n                                $result['_name'] = $name;\n                                $result['_mtime'] = $mtime;\n                            }\n                        }\n                    } else {\n                        $result['error'] = $this->error(self::ERROR_UPLOAD_FILE, $chunk, self::ERROR_UPLOAD_TEMP);\n                        $this->uploadDebug = 'Upload error: unable open tmp file';\n                    }\n                    return $result;\n                } else {\n                    // for form clipboard with Google Chrome or Opera\n                    $name = 'image.png';\n                }\n            }\n\n            // Set name if name eq 'image.png' and $args has 'name' array, e.g. clipboard data\n            if (strtolower(substr($name, 0, 5)) === 'image' && is_array($args['name']) && isset($args['name'][$i])) {\n                $type = $files['type'][$i];\n                $name = $args['name'][$i];\n                $ext = isset($extTable[$type]) ? '.' . $extTable[$type] : '';\n                if ($ext) {\n                    $name = preg_replace('/\\.[^.]*$/', '', $name);\n                }\n                $name .= $ext;\n            }\n\n            // do hook function 'upload.presave'\n            if (!empty($this->listeners['upload.presave'])) {\n                foreach ($this->listeners['upload.presave'] as $handler) {\n                    call_user_func_array($handler, array(&$thash, &$name, $tmpname, $this, $volume));\n                }\n            }\n\n            clearstatcache();\n            if ($mtime && is_file($tmpname)) {\n                // for keep timestamp option in the LocalFileSystem volume\n                touch($tmpname, $mtime);\n            }\n\n            if (!is_file($tmpname) || ($fp = fopen($tmpname, 'rb')) === false) {\n                $result['warning'] = $this->error(self::ERROR_UPLOAD_FILE, $name, self::ERROR_UPLOAD_TEMP);\n                $this->uploadDebug = 'Upload error: unable open tmp file';\n                if (!is_uploaded_file($tmpname)) {\n                    if (unlink($tmpname) && $tmpfname) unset($GLOBALS['elFinderTempFiles'][$tmpfname]);\n                    continue;\n                }\n                break;\n            }\n            $rnres = array();\n            if ($thash !== '' && $thash !== $target) {\n                if ($dir = $volume->dir($thash)) {\n                    $_target = $thash;\n                    if (!isset($addedDirs[$thash])) {\n                        $addedDirs[$thash] = true;\n                        $result['added'][] = $dir;\n                        // to support multi-level directory creation\n                        $_phash = isset($dir['phash']) ? $dir['phash'] : null;\n                        while ($_phash && !isset($addedDirs[$_phash]) && $_phash !== $target) {\n                            if ($_dir = $volume->dir($_phash)) {\n                                $addedDirs[$_phash] = true;\n                                $result['added'][] = $_dir;\n                                $_phash = isset($_dir['phash']) ? $_dir['phash'] : null;\n                            } else {\n                                break;\n                            }\n                        }\n                    }\n                } else {\n                    $result['error'] = $this->error(self::ERROR_UPLOAD, self::ERROR_TRGDIR_NOT_FOUND, 'hash@' . $thash);\n                    break;\n                }\n            } else {\n                $_target = $target;\n                // file rename for backup\n                if (isset($renames[$name])) {\n                    $dir = $volume->realpath($_target);\n                    if (isset($hashes[$name])) {\n                        $hash = $hashes[$name];\n                    } else {\n                        $hash = $volume->getHash($dir, $name);\n                    }\n                    $rnres = $this->rename(array('target' => $hash, 'name' => $volume->uniqueName($dir, $name, $suffix, true, 0)));\n                    if (!empty($rnres['error'])) {\n                        $result['warning'] = $rnres['error'];\n                        if (!is_array($rnres['error'])) {\n                            $errors = array_push($errors, $rnres['error']);\n                        } else {\n                            $errors = array_merge($errors, $rnres['error']);\n                        }\n                        continue;\n                    }\n                }\n            }\n            if (!$_target || ($file = $volume->upload($fp, $_target, $name, $tmpname, ($_target === $target) ? $hashes : array())) === false) {\n                $errors = array_merge($errors, $this->error(self::ERROR_UPLOAD_FILE, $name, $volume->error()));\n                fclose($fp);\n                if (!is_uploaded_file($tmpname) && unlink($tmpname)) {\n                    unset($GLOBALS['elFinderTempFiles'][$tmpname]);\n                }\n                continue;\n            }\n\n            is_resource($fp) && fclose($fp);\n            if (!is_uploaded_file($tmpname)) {\n                clearstatcache();\n                if (!is_file($tmpname) || unlink($tmpname)) {\n                    unset($GLOBALS['elFinderTempFiles'][$tmpname]);\n                }\n            }\n            $result['added'][] = $file;\n            if ($rnres) {\n                $result = array_merge_recursive($result, $rnres);\n            }\n        }\n\n        if ($errors) {\n            $result['warning'] = $errors;\n        }\n\n        if ($GLOBALS['elFinderTempFiles']) {\n            foreach (array_keys($GLOBALS['elFinderTempFiles']) as $_temp) {\n                is_file($_temp) && unlink($_temp);\n            }\n        }\n        $result['removed'] = $volume->removed();\n\n        if (!empty($args['node'])) {\n            $result['callback'] = array(\n                'node' => $args['node'],\n                'bind' => 'upload'\n            );\n        }\n        return $result;\n    }\n\n    /**\n     * Copy/move files into new destination\n     *\n     * @param  array  command arguments\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function paste($args)\n    {\n        $dst = $args['dst'];\n        $targets = is_array($args['targets']) ? $args['targets'] : array();\n        $cut = !empty($args['cut']);\n        $error = $cut ? self::ERROR_MOVE : self::ERROR_COPY;\n        $result = array('changed' => array(), 'added' => array(), 'removed' => array(), 'warning' => array());\n\n        if (($dstVolume = $this->volume($dst)) == false) {\n            return array('error' => $this->error($error, '#' . $targets[0], self::ERROR_TRGDIR_NOT_FOUND, '#' . $dst));\n        }\n\n        $this->itemLock($dst);\n\n        $hashes = $renames = array();\n        $suffix = '~';\n        if (!empty($args['renames'])) {\n            $renames = array_flip($args['renames']);\n            if (is_string($args['suffix']) && !preg_match('/[\\/\\\\?*:|\"<>]/', $args['suffix'])) {\n                $suffix = $args['suffix'];\n            }\n        }\n        if (!empty($args['hashes'])) {\n            $hashes = array_flip($args['hashes']);\n        }\n\n        foreach ($targets as $target) {\n            elFinder::checkAborted();\n\n            if (($srcVolume = $this->volume($target)) == false) {\n                $result['warning'] = array_merge($result['warning'], $this->error($error, '#' . $target, self::ERROR_FILE_NOT_FOUND));\n                continue;\n            }\n\n            $rnres = array();\n            if ($renames) {\n                $file = $srcVolume->file($target);\n                if (isset($renames[$file['name']])) {\n                    $dir = $dstVolume->realpath($dst);\n                    if (isset($hashes[$file['name']])) {\n                        $hash = $hashes[$file['name']];\n                    } else {\n                        $hash = $dstVolume->getHash($dir, $file['name']);\n                    }\n                    $rnres = $this->rename(array('target' => $hash, 'name' => $dstVolume->uniqueName($dir, $file['name'], $suffix, true, 0)));\n                    if (!empty($rnres['error'])) {\n                        $result['warning'] = array_merge($result['warning'], $rnres['error']);\n                        continue;\n                    }\n                }\n            }\n\n            if ($cut && $this->itemLocked($target)) {\n                $rm = $srcVolume->file($target);\n                $result['warning'] = array_merge($result['warning'], $this->error(self::ERROR_LOCKED, $rm['name']));\n                continue;\n            }\n\n            if (($file = $dstVolume->paste($srcVolume, $target, $dst, $cut, $hashes)) == false) {\n                $result['warning'] = array_merge($result['warning'], $this->error($dstVolume->error()));\n                continue;\n            }\n\n            if ($error = $dstVolume->error()) {\n                $result['warning'] = array_merge($result['warning'], $this->error($error));\n            }\n\n            $dirChange = !empty($file['dirChange']);\n            unset($file['dirChange']);\n            if ($dirChange) {\n                $result['changed'][] = $file;\n            } else {\n                $result['added'][] = $file;\n            }\n            if ($rnres) {\n                $result = array_merge_recursive($result, $rnres);\n            }\n        }\n        if (count($result['warning']) < 1) {\n            unset($result['warning']);\n        } else {\n            $result['sync'] = true;\n        }\n\n        return $result;\n    }\n\n    /**\n     * Return file content\n     *\n     * @param  array $args command arguments\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function get($args)\n    {\n        $target = $args['target'];\n        $volume = $this->volume($target);\n        $enc = false;\n\n        if (!$volume || ($file = $volume->file($target)) == false) {\n            return array('error' => $this->error(self::ERROR_OPEN, '#' . $target, self::ERROR_FILE_NOT_FOUND));\n        }\n\n        if (($content = $volume->getContents($target)) === false) {\n            return array('error' => $this->error(self::ERROR_OPEN, $volume->path($target), $volume->error()));\n        }\n\n        $mime = isset($file['mime']) ? $file['mime'] : '';\n        if ($mime && (strtolower(substr($mime, 0, 4)) === 'text' || in_array(strtolower($mime), self::$textMimes))) {\n            $enc = '';\n            if ($content !== '') {\n                if (!$args['conv'] || $args['conv'] == '1') {\n                    // detect encoding\n                    if (function_exists('mb_detect_encoding')) {\n                        if ($enc = mb_detect_encoding($content, mb_detect_order(), true)) {\n                            $encu = strtoupper($enc);\n                            if ($encu === 'UTF-8' || $encu === 'ASCII') {\n                                $enc = '';\n                            }\n                        } else {\n                            $enc = 'unknown';\n                        }\n                    } else if (!preg_match('//u', $content)) {\n                        $enc = 'unknown';\n                    }\n                    if ($enc === 'unknown') {\n                        $enc = $volume->getOption('encoding');\n                        if (!$enc || strtoupper($enc) === 'UTF-8') {\n                            $enc = 'unknown';\n                        }\n                    }\n                    if ($enc && $enc !== 'unknown') {\n                        $utf8 = iconv($enc, 'UTF-8', $content);\n                        if ($utf8 === false && function_exists('mb_convert_encoding')) {\n                            $utf8 = mb_convert_encoding($content, 'UTF-8', $enc);\n                            if (mb_convert_encoding($utf8, $enc, 'UTF-8') !== $content) {\n                                $enc = 'unknown';\n                            }\n                        } else {\n                            if ($utf8 === false || iconv('UTF-8', $enc, $utf8) !== $content) {\n                                $enc = 'unknown';\n                            }\n                        }\n                        if ($enc !== 'unknown') {\n                            $content = $utf8;\n                        }\n                    }\n                    if ($enc) {\n                        if ($args['conv'] == '1') {\n                            $args['conv'] = '';\n                            if ($enc === 'unknown') {\n                                $content = false;\n                            }\n                        } else if ($enc === 'unknown') {\n                            return array('doconv' => $enc);\n                        }\n                    }\n                    if ($args['conv'] == '1') {\n                        $args['conv'] = '';\n                    }\n                }\n                if ($args['conv']) {\n                    $enc = $args['conv'];\n                    if (strtoupper($enc) !== 'UTF-8') {\n                        $_content = $content;\n                        $content = iconv($enc, 'UTF-8', $content);\n                        if ($content === false && function_exists('mb_convert_encoding')) {\n                            $content = mb_convert_encoding($_content, 'UTF-8', $enc);\n                        }\n                    } else {\n                        $enc = '';\n                    }\n                }\n            }\n        } else {\n            $content = 'data:' . ($mime ? $mime : 'application/octet-stream') . ';base64,' . base64_encode($content);\n        }\n\n        if ($enc !== false) {\n            $json = false;\n            if ($content !== false) {\n                $json = json_encode($content);\n            }\n            if ($content === false || $json === false || strlen($json) < strlen($content)) {\n                return array('error' => $this->error(self::ERROR_CONV_UTF8, self::ERROR_NOT_UTF8_CONTENT, $volume->path($target)));\n            }\n        }\n\n        $res = array(\n            'header' => array(\n                'Content-Type: application/json'\n            ),\n            'content' => $content\n        );\n\n        // add cache control headers\n        if ($cacheHeaders = $volume->getOption('cacheHeaders')) {\n            $res['header'] = array_merge($res['header'], $cacheHeaders);\n        }\n\n        if ($enc) {\n            $res['encoding'] = $enc;\n        }\n        return $res;\n    }\n\n    /**\n     * Save content into text file\n     *\n     * @param $args\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     */\n    protected function put($args)\n    {\n        $target = $args['target'];\n        $encoding = isset($args['encoding']) ? $args['encoding'] : '';\n\n        if (($volume = $this->volume($target)) == false\n            || ($file = $volume->file($target)) == false) {\n            return array('error' => $this->error(self::ERROR_SAVE, '#' . $target, self::ERROR_FILE_NOT_FOUND));\n        }\n\n        $this->itemLock($target);\n\n        if ($encoding === 'scheme') {\n            if (preg_match('~^https?://~i', $args['content'])) {\n                /** @var resource $fp */\n                $fp = $this->get_remote_contents($args['content'], 30, 5, 'Mozilla/5.0', $volume->tmpfile());\n                if (!$fp) {\n                    return array('error' => self::ERROR_SAVE, $args['content'], self::ERROR_FILE_NOT_FOUND);\n                }\n                $fmeta = stream_get_meta_data($fp);\n                $mime = $this->detectMimeType($fmeta['uri']);\n                if ($mime === 'unknown') {\n                    $mime = 'application/octet-stream';\n                }\n                $mime = $volume->mimeTypeNormalize($mime, $file['name']);\n                $args['content'] = 'data:' . $mime . ';base64,' . base64_encode(file_get_contents($fmeta['uri']));\n            }\n            $encoding = '';\n            $args['content'] = \"\\0\" . $args['content'];\n        } else if ($encoding === 'hash') {\n            $_hash = $args['content'];\n            if ($_src = $this->getVolume($_hash)) {\n                if ($_file = $_src->file($_hash)) {\n                    if ($_data = $_src->getContents($_hash)) {\n                        $args['content'] = 'data:' . $file['mime'] . ';base64,' . base64_encode($_data);\n                    }\n                }\n            }\n            $encoding = '';\n            $args['content'] = \"\\0\" . $args['content'];\n        }\n        if ($encoding) {\n            $content = iconv('UTF-8', $encoding, $args['content']);\n            if ($content === false && function_exists('mb_detect_encoding')) {\n                $content = mb_convert_encoding($args['content'], $encoding, 'UTF-8');\n            }\n            if ($content !== false) {\n                $args['content'] = $content;\n            }\n        }\n        if (($file = $volume->putContents($target, $args['content'])) == false) {\n            return array('error' => $this->error(self::ERROR_SAVE, $volume->path($target), $volume->error()));\n        }\n\n        return array('changed' => array($file));\n    }\n\n    /**\n     * Extract files from archive\n     *\n     * @param  array $args command arguments\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov,\n     * @author Alexey Sukhotin\n     **/\n    protected function extract($args)\n    {\n        $target = $args['target'];\n        $makedir = isset($args['makedir']) ? (bool)$args['makedir'] : null;\n\n        if (($volume = $this->volume($target)) == false\n            || ($file = $volume->file($target)) == false) {\n            return array('error' => $this->error(self::ERROR_EXTRACT, '#' . $target, self::ERROR_FILE_NOT_FOUND));\n        }\n\n        $res = array();\n        if ($file = $volume->extract($target, $makedir)) {\n            $res['added'] = isset($file['read']) ? array($file) : $file;\n            if ($err = $volume->error()) {\n                $res['warning'] = $err;\n            }\n        } else {\n            $res['error'] = $this->error(self::ERROR_EXTRACT, $volume->path($target), $volume->error());\n        }\n        return $res;\n    }\n\n    /**\n     * Create archive\n     *\n     * @param  array $args command arguments\n     *\n     * @return array\n     * @throws Exception\n     * @author Dmitry (dio) Levashov,\n     * @author Alexey Sukhotin\n     */\n    protected function archive($args)\n    {\n        $targets = isset($args['targets']) && is_array($args['targets']) ? $args['targets'] : array();\n        $name = isset($args['name']) ? $args['name'] : '';\n\n        if (($volume = $this->volume($targets[0])) == false) {\n            return $this->error(self::ERROR_ARCHIVE, self::ERROR_TRGDIR_NOT_FOUND);\n        }\n\n        foreach ($targets as $target) {\n            $this->itemLock($target);\n        }\n\n        return ($file = $volume->archive($targets, $args['type'], $name))\n            ? array('added' => array($file))\n            : array('error' => $this->error(self::ERROR_ARCHIVE, $volume->error()));\n    }\n\n    /**\n     * Search files\n     *\n     * @param  array $args command arguments\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry Levashov\n     */\n    protected function search($args)\n    {\n        $q = trim($args['q']);\n        $mimes = !empty($args['mimes']) && is_array($args['mimes']) ? $args['mimes'] : array();\n        $target = !empty($args['target']) ? $args['target'] : null;\n        $type = !empty($args['type']) ? $args['type'] : null;\n        $result = array();\n        $errors = array();\n\n        if ($target) {\n            if ($volume = $this->volume($target)) {\n                $result = $volume->search($q, $mimes, $target, $type);\n                $errors = array_merge($errors, $volume->error());\n            }\n        } else {\n            foreach ($this->volumes as $volume) {\n                $result = array_merge($result, $volume->search($q, $mimes, null, $type));\n                $errors = array_merge($errors, $volume->error());\n            }\n        }\n\n        $result = array('files' => $result);\n        if ($errors) {\n            $result['warning'] = $errors;\n        }\n        return $result;\n    }\n\n    /**\n     * Return file info (used by client \"places\" ui)\n     *\n     * @param  array $args command arguments\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry Levashov\n     */\n    protected function info($args)\n    {\n        $files = array();\n        $compare = null;\n        // long polling mode\n        if ($args['compare'] && count($args['targets']) === 1) {\n            $compare = intval($args['compare']);\n            $hash = $args['targets'][0];\n            if ($volume = $this->volume($hash)) {\n                $standby = (int)$volume->getOption('plStandby');\n                $_compare = false;\n                if (($syncCheckFunc = $volume->getOption('syncCheckFunc')) && is_callable($syncCheckFunc)) {\n                    $_compare = call_user_func_array($syncCheckFunc, array($volume->realpath($hash), $standby, $compare, $volume, $this));\n                }\n                if ($_compare !== false) {\n                    $compare = $_compare;\n                } else {\n                    $sleep = max(1, (int)$volume->getOption('tsPlSleep'));\n                    $limit = max(1, $standby / $sleep) + 1;\n                    do {\n                        elFinder::extendTimeLimit(30 + $sleep);\n                        $volume->clearstatcache();\n                        if (($info = $volume->file($hash)) != false) {\n                            if ($info['ts'] != $compare) {\n                                $compare = $info['ts'];\n                                break;\n                            }\n                        } else {\n                            $compare = 0;\n                            break;\n                        }\n                        if (--$limit) {\n                            sleep($sleep);\n                        }\n                    } while ($limit);\n                }\n            }\n        } else {\n            foreach ($args['targets'] as $hash) {\n                elFinder::checkAborted();\n                if (($volume = $this->volume($hash)) != false\n                    && ($info = $volume->file($hash)) != false) {\n                    $info['path'] = $volume->path($hash);\n                    $files[] = $info;\n                }\n            }\n        }\n\n        $result = array('files' => $files);\n        if (!is_null($compare)) {\n            $result['compare'] = strval($compare);\n        }\n        return $result;\n    }\n\n    /**\n     * Return image dimensions\n     *\n     * @param  array $args command arguments\n     *\n     * @return array\n     * @throws ImagickException\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function dim($args)\n    {\n        $res = array();\n        $target = $args['target'];\n\n        if (($volume = $this->volume($target)) != false) {\n            if ($dim = $volume->dimensions($target, $args)) {\n                if (is_array($dim) && isset($dim['dim'])) {\n                    $res = $dim;\n                } else {\n                    $res = array('dim' => $dim);\n                    if ($subImgLink = $volume->getSubstituteImgLink($target, explode('x', $dim))) {\n                        $res['url'] = $subImgLink;\n                    }\n                }\n            }\n        }\n\n        return $res;\n    }\n\n    /**\n     * Resize image\n     *\n     * @param  array  command arguments\n     *\n     * @return array\n     * @throws ImagickException\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     * @author Alexey Sukhotin\n     */\n    protected function resize($args)\n    {\n        $target = $args['target'];\n        $width = (int)$args['width'];\n        $height = (int)$args['height'];\n        $x = (int)$args['x'];\n        $y = (int)$args['y'];\n        $mode = $args['mode'];\n        $bg = $args['bg'];\n        $degree = (int)$args['degree'];\n        $quality = (int)$args['quality'];\n\n        if (($volume = $this->volume($target)) == false\n            || ($file = $volume->file($target)) == false) {\n            return array('error' => $this->error(self::ERROR_RESIZE, '#' . $target, self::ERROR_FILE_NOT_FOUND));\n        }\n\n        if ($mode !== 'rotate' && ($width < 1 || $height < 1)) {\n            return array('error' => $this->error(self::ERROR_RESIZESIZE));\n        }\n        return ($file = $volume->resize($target, $width, $height, $x, $y, $mode, $bg, $degree, $quality))\n            ? (!empty($file['losslessRotate']) ? $file : array('changed' => array($file)))\n            : array('error' => $this->error(self::ERROR_RESIZE, $volume->path($target), $volume->error()));\n    }\n\n    /**\n     * Return content URL\n     *\n     * @param  array $args command arguments\n     *\n     * @return array\n     * @author Naoki Sawada\n     **/\n    protected function url($args)\n    {\n        $target = $args['target'];\n        $options = isset($args['options']) ? $args['options'] : array();\n        if (($volume = $this->volume($target)) != false) {\n            if (!$volume->commandDisabled('url')) {\n                $url = $volume->getContentUrl($target, $options);\n                return $url ? array('url' => $url) : array();\n            }\n        }\n        return array();\n    }\n\n    /**\n     * Output callback result with JavaScript that control elFinder\n     * or HTTP redirect to callbackWindowURL\n     *\n     * @param  array  command arguments\n     *\n     * @throws elFinderAbortException\n     * @author Naoki Sawada\n     */\n    protected function callback($args)\n    {\n        $checkReg = '/[^a-zA-Z0-9;._-]/';\n        $node = (isset($args['node']) && !preg_match($checkReg, $args['node'])) ? $args['node'] : '';\n        $json = (isset($args['json']) && json_decode($args['json'])) ? $args['json'] : '{}';\n        $bind = (isset($args['bind']) && !preg_match($checkReg, $args['bind'])) ? $args['bind'] : '';\n        $done = (!empty($args['done']));\n\n        while (ob_get_level()) {\n            if (!ob_end_clean()) {\n                break;\n            }\n        }\n\n        if ($done || !$this->callbackWindowURL) {\n            $script = '';\n            if ($node) {\n                if ($bind) {\n                    $trigger = 'elf.trigger(\\'' . $bind . '\\', data);';\n                    $triggerdone = 'elf.trigger(\\'' . $bind . 'done\\');';\n                    $triggerfail = 'elf.trigger(\\'' . $bind . 'fail\\', data);';\n                } else {\n                    $trigger = $triggerdone = $triggerfail = '';\n                }\n                $script .= '\n\t\t\t\t\tvar w = window.opener || window.parent || window;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvar elf = w.document.getElementById(\\'' . $node . '\\').elfinder;\n\t\t\t\t\t\tif (elf) {\n\t\t\t\t\t\t\tvar data = ' . $json . ';\n\t\t\t\t\t\t\tif (data.error) {\n\t\t\t\t\t\t\t\t' . $triggerfail . '\n\t\t\t\t\t\t\t\telf.error(data.error);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdata.warning && elf.error(data.warning);\n\t\t\t\t\t\t\t\tdata.removed && data.removed.length && elf.remove(data);\n\t\t\t\t\t\t\t\tdata.added   && data.added.length   && elf.add(data);\n\t\t\t\t\t\t\t\tdata.changed && data.changed.length && elf.change(data);\n\t\t\t\t\t\t\t\t' . $trigger . '\n\t\t\t\t\t\t\t\t' . $triggerdone . '\n\t\t\t\t\t\t\t\tdata.sync && elf.sync();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch(e) {\n\t\t\t\t\t\t// for CORS\n\t\t\t\t\t\tw.postMessage && w.postMessage(JSON.stringify({bind:\\'' . $bind . '\\',data:' . $json . '}), \\'*\\');\n\t\t\t\t\t}';\n            }\n            $script .= 'window.close();';\n\n            $out = '<!DOCTYPE html><html><head><meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"><meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"><script>' . $script . '</script></head><body><a href=\"#\" onlick=\"window.close();return false;\">Close this window</a></body></html>';\n\n            header('Content-Type: text/html; charset=utf-8');\n            header('Content-Length: ' . strlen($out));\n            header('Cache-Control: private');\n            header('Pragma: no-cache');\n\n            echo $out;\n\n        } else {\n            $url = $this->callbackWindowURL;\n            $url .= ((strpos($url, '?') === false) ? '?' : '&')\n                . '&node=' . rawurlencode($node)\n                . (($json !== '{}') ? ('&json=' . rawurlencode($json)) : '')\n                . ($bind ? ('&bind=' . rawurlencode($bind)) : '')\n                . '&done=1';\n\n            header('Location: ' . $url);\n\n        }\n        throw new elFinderAbortException();\n    }\n\n    /**\n     * PHP error handler, catch error types only E_WARNING | E_NOTICE | E_USER_WARNING | E_USER_NOTICE\n     *\n     * @param int    $errno\n     * @param string $errstr\n     * @param string $errfile\n     * @param int    $errline\n     *\n     * @return boolean\n     */\n    public static function phpErrorHandler($errno, $errstr, $errfile, $errline)\n    {\n        static $base = null;\n\n        $proc = false;\n\n        if (is_null($base)) {\n            $base = dirname(__FILE__) . DIRECTORY_SEPARATOR;\n        }\n\n        if (!(error_reporting() & $errno)) {\n            return $proc;\n        }\n\n        $errfile = str_replace($base, '', $errfile);\n\n        switch ($errno) {\n            case E_WARNING:\n            case E_USER_WARNING:\n                elFinder::$phpErrors[] = \"WARNING: $errstr in $errfile line $errline.\";\n                $proc = true;\n                break;\n\n            case E_NOTICE:\n            case E_USER_NOTICE:\n                elFinder::$phpErrors[] = \"NOTICE: $errstr in $errfile line $errline.\";\n                $proc = true;\n                break;\n\n            case E_STRICT:\n                elFinder::$phpErrors[] = \"STRICT: $errstr in $errfile line $errline.\";\n                $proc = true;\n                break;\n\n            case E_RECOVERABLE_ERROR:\n                elFinder::$phpErrors[] = \"RECOVERABLE_ERROR: $errstr in $errfile line $errline.\";\n                $proc = true;\n                break;\n        }\n\n        if (defined('E_DEPRECATED')) {\n            switch ($errno) {\n                case E_DEPRECATED:\n                case E_USER_DEPRECATED:\n                    elFinder::$phpErrors[] = \"DEPRECATED: $errstr in $errfile line $errline.\";\n                    $proc = true;\n                    break;\n            }\n        }\n\n        return $proc;\n    }\n\n    /***************************************************************************/\n    /*                                   utils                                 */\n    /***************************************************************************/\n\n    /**\n     * Return root - file's owner\n     *\n     * @param  string  file hash\n     *\n     * @return elFinderVolumeDriver|boolean (false)\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function volume($hash)\n    {\n        foreach ($this->volumes as $id => $v) {\n            if (strpos('' . $hash, $id) === 0) {\n                return $this->volumes[$id];\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Return files info array\n     *\n     * @param  array $data one file info or files info\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function toArray($data)\n    {\n        return isset($data['hash']) || !is_array($data) ? array($data) : $data;\n    }\n\n    /**\n     * Return fils hashes list\n     *\n     * @param  array $files files info\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function hashes($files)\n    {\n        $ret = array();\n        foreach ($files as $file) {\n            $ret[] = $file['hash'];\n        }\n        return $ret;\n    }\n\n    /**\n     * Remove from files list hidden files and files with required mime types\n     *\n     * @param  array $files files info\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function filter($files)\n    {\n        $exists = array();\n        foreach ($files as $i => $file) {\n            if (isset($exists[$file['hash']]) || !empty($file['hidden']) || !$this->default->mimeAccepted($file['mime'])) {\n                unset($files[$i]);\n            }\n            $exists[$file['hash']] = true;\n        }\n        return array_values($files);\n    }\n\n    protected function utime()\n    {\n        $time = explode(\" \", microtime());\n        return (double)$time[1] + (double)$time[0];\n    }\n\n    /**\n     * Return Network mount volume unique ID\n     *\n     * @param  array  $netVolumes Saved netvolumes array\n     * @param  string $prefix     Id prefix\n     *\n     * @return string|false\n     * @author Naoki Sawada\n     **/\n    protected function getNetVolumeUniqueId($netVolumes = null, $prefix = 'nm')\n    {\n        if (is_null($netVolumes)) {\n            $netVolumes = $this->getNetVolumes();\n        }\n        $ids = array();\n        foreach ($netVolumes as $vOps) {\n            if (isset($vOps['id']) && strpos($vOps['id'], $prefix) === 0) {\n                $ids[$vOps['id']] = true;\n            }\n        }\n        if (!$ids) {\n            $id = $prefix . '1';\n        } else {\n            $i = 0;\n            while (isset($ids[$prefix . ++$i]) && $i < 10000) ;\n            $id = $prefix . $i;\n            if (isset($ids[$id])) {\n                $id = false;\n            }\n        }\n        return $id;\n    }\n\n    /**\n     * Is item locked?\n     *\n     * @param string $hash\n     *\n     * @return boolean\n     */\n    protected function itemLocked($hash)\n    {\n        if (!elFinder::$commonTempPath) {\n            return false;\n        }\n        $lock = elFinder::$commonTempPath . DIRECTORY_SEPARATOR . $hash . '.lock';\n        if (file_exists($lock)) {\n            if (filemtime($lock) + $this->itemLockExpire < time()) {\n                unlink($lock);\n                return false;\n            }\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Do lock target item\n     *\n     * @param array|string $hashes\n     * @param boolean      $autoUnlock\n     *\n     * @return void\n     */\n    protected function itemLock($hashes, $autoUnlock = true)\n    {\n        if (!elFinder::$commonTempPath) {\n            return;\n        }\n        if (!is_array($hashes)) {\n            $hashes = array($hashes);\n        }\n        foreach ($hashes as $hash) {\n            $lock = elFinder::$commonTempPath . DIRECTORY_SEPARATOR . $hash . '.lock';\n            if ($this->itemLocked($hash)) {\n                $cnt = file_get_contents($lock) + 1;\n            } else {\n                $cnt = 1;\n            }\n            if (file_put_contents($lock, $cnt, LOCK_EX)) {\n                if ($autoUnlock) {\n                    $this->autoUnlocks[] = $hash;\n                }\n            }\n        }\n    }\n\n    /**\n     * Do unlock target item\n     *\n     * @param string $hash\n     *\n     * @return boolean\n     */\n    protected function itemUnlock($hash)\n    {\n        if (!$this->itemLocked($hash)) {\n            return true;\n        }\n        $lock = elFinder::$commonTempPath . DIRECTORY_SEPARATOR . $hash . '.lock';\n        $cnt = file_get_contents($lock);\n        if (--$cnt < 1) {\n            unlink($lock);\n            return true;\n        } else {\n            file_put_contents($lock, $cnt, LOCK_EX);\n            return false;\n        }\n    }\n\n    /**\n     * unlock locked items on command completion\n     *\n     * @return void\n     */\n    public function itemAutoUnlock()\n    {\n        if ($this->autoUnlocks) {\n            foreach ($this->autoUnlocks as $hash) {\n                $this->itemUnlock($hash);\n            }\n            $this->autoUnlocks = array();\n        }\n    }\n\n    /**\n     * Ensure directories recursively\n     *\n     * @param  object $volume Volume object\n     * @param  string $target Target hash\n     * @param  array  $dirs   Array of directory tree to ensure\n     * @param  string $path   Relative path form target hash\n     *\n     * @return array|false      array('stats' => array([stat of maked directory]), 'hashes' => array('[path]' => '[hash]'), 'makes' => array([New directory hashes]), 'error' => array([Error name]))\n     * @author Naoki Sawada\n     **/\n    protected function ensureDirsRecursively($volume, $target, $dirs, $path = '')\n    {\n        $res = array('stats' => array(), 'hashes' => array(), 'makes' => array(), 'error' => array());\n        foreach ($dirs as $name => $sub) {\n            $name = (string)$name;\n            $dir = $newDir = null;\n            if ((($parent = $volume->realpath($target)) && ($dir = $volume->dir($volume->getHash($parent, $name)))) || ($newDir = $volume->mkdir($target, $name))) {\n                $_path = $path . '/' . $name;\n                if ($newDir) {\n                    $res['makes'][] = $newDir['hash'];\n                    $dir = $newDir;\n                }\n                $res['stats'][] = $dir;\n                $res['hashes'][$_path] = $dir['hash'];\n                if (count($sub)) {\n                    $res = array_merge_recursive($res, $this->ensureDirsRecursively($volume, $dir['hash'], $sub, $_path));\n                }\n            } else {\n                $res['error'][] = $name;\n            }\n        }\n        return $res;\n    }\n\n    /***************************************************************************/\n    /*                           static  utils                                 */\n    /***************************************************************************/\n\n    /**\n     * Return full version of API that this connector supports all functions\n     *\n     * @return string\n     */\n    public static function getApiFullVersion()\n    {\n        return (string)self::$ApiVersion . '.' . (string)self::$ApiRevision;\n    }\n\n    /**\n     * Return Is Animation Gif\n     *\n     * @param  string $path server local path of target image\n     *\n     * @return bool\n     */\n    public static function isAnimationGif($path)\n    {\n        list(, , $type) = getimagesize($path);\n        switch ($type) {\n            case IMAGETYPE_GIF:\n                break;\n            default:\n                return false;\n        }\n\n        $imgcnt = 0;\n        $fp = fopen($path, 'rb');\n        fread($fp, 4);\n        $c = fread($fp, 1);\n        if (ord($c) != 0x39) {  // GIF89a\n            return false;\n        }\n\n        while (!feof($fp)) {\n            do {\n                $c = fread($fp, 1);\n            } while (ord($c) != 0x21 && !feof($fp));\n\n            if (feof($fp)) {\n                break;\n            }\n\n            $c2 = fread($fp, 2);\n            if (bin2hex($c2) == \"f904\") {\n                $imgcnt++;\n                if ($imgcnt === 2) {\n                    break;\n                }\n            }\n\n            if (feof($fp)) {\n                break;\n            }\n        }\n\n        if ($imgcnt > 1) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Return Is Animation Png\n     *\n     * @param  string $path server local path of target image\n     *\n     * @return bool\n     */\n    public static function isAnimationPng($path)\n    {\n        list(, , $type) = getimagesize($path);\n        switch ($type) {\n            case IMAGETYPE_PNG:\n                break;\n            default:\n                return false;\n        }\n\n        $fp = fopen($path, 'rb');\n        $img_bytes = fread($fp, 1024);\n        fclose($fp);\n        if ($img_bytes) {\n            if (strpos(substr($img_bytes, 0, strpos($img_bytes, 'IDAT')), 'acTL') !== false) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Return Is seekable stream resource\n     *\n     * @param resource $resource\n     *\n     * @return bool\n     */\n    public static function isSeekableStream($resource)\n    {\n        $metadata = stream_get_meta_data($resource);\n        return $metadata['seekable'];\n    }\n\n    /**\n     * Rewind stream resource\n     *\n     * @param resource $resource\n     *\n     * @return void\n     */\n    public static function rewind($resource)\n    {\n        self::isSeekableStream($resource) && rewind($resource);\n    }\n\n    /**\n     * serialize and base64_encode of session data (If needed)\n     *\n     * @deprecated\n     *\n     * @param  mixed $var target variable\n     *\n     * @author Naoki Sawada\n     * @return mixed|string\n     */\n    public static function sessionDataEncode($var)\n    {\n        if (self::$base64encodeSessionData) {\n            $var = base64_encode(serialize($var));\n        }\n        return $var;\n    }\n\n    /**\n     * base64_decode and unserialize of session data  (If needed)\n     *\n     * @deprecated\n     *\n     * @param  mixed $var     target variable\n     * @param  bool  $checkIs data type for check (array|string|object|int)\n     *\n     * @author Naoki Sawada\n     * @return bool|mixed\n     */\n    public static function sessionDataDecode(&$var, $checkIs = null)\n    {\n        if (self::$base64encodeSessionData) {\n            $data = unserialize(base64_decode($var));\n        } else {\n            $data = $var;\n        }\n        $chk = true;\n        if ($checkIs) {\n            switch ($checkIs) {\n                case 'array':\n                    $chk = is_array($data);\n                    break;\n                case 'string':\n                    $chk = is_string($data);\n                    break;\n                case 'object':\n                    $chk = is_object($data);\n                    break;\n                case 'int':\n                    $chk = is_int($data);\n                    break;\n            }\n        }\n        if (!$chk) {\n            unset($var);\n            return false;\n        }\n        return $data;\n    }\n\n    /**\n     * Call session_write_close() if session is restarted\n     *\n     * @deprecated\n     * @return void\n     */\n    public static function sessionWrite()\n    {\n        if (session_id()) {\n            session_write_close();\n        }\n    }\n\n    /**\n     * Return elFinder static variable\n     *\n     * @param $key\n     *\n     * @return mixed|null\n     */\n    public static function getStaticVar($key)\n    {\n        return isset(elFinder::$$key) ? elFinder::$$key : null;\n    }\n\n    /**\n     * Extend PHP execution time limit and also check connection is aborted\n     *\n     * @param Int $time\n     *\n     * @return void\n     * @throws elFinderAbortException\n     */\n    public static function extendTimeLimit($time = null)\n    {\n        static $defLimit = null;\n        if (!self::aborted()) {\n            if (is_null($defLimit)) {\n                $defLimit = ini_get('max_execution_time');\n            }\n            if ($defLimit != 0) {\n                $time = is_null($time) ? $defLimit : max($defLimit, $time);\n                set_time_limit($time);\n            }\n        } else {\n            throw new elFinderAbortException();\n        }\n    }\n\n    /**\n     * Check connection is aborted\n     * Script stop immediately if connection aborted\n     *\n     * @return void\n     * @throws elFinderAbortException\n     */\n    public static function checkAborted()\n    {\n        elFinder::extendTimeLimit();\n    }\n\n    /**\n     * Return bytes from php.ini value\n     *\n     * @param string $iniName\n     * @param string $val\n     *\n     * @return number\n     */\n    public static function getIniBytes($iniName = '', $val = '')\n    {\n        if ($iniName !== '') {\n            $val = ini_get($iniName);\n            if ($val === false) {\n                return 0;\n            }\n        }\n        $val = trim($val, \"bB \\t\\n\\r\\0\\x0B\");\n        $last = strtolower($val[strlen($val) - 1]);\n        $val = (int)$val;\n        switch ($last) {\n            case 't':\n                $val *= 1024;\n            case 'g':\n                $val *= 1024;\n            case 'm':\n                $val *= 1024;\n            case 'k':\n                $val *= 1024;\n        }\n        return $val;\n    }\n\n    /**\n     * Get script url.\n     *\n     * @return string full URL\n     * @author Naoki Sawada\n     */\n    public static function getConnectorUrl()\n    {\n        $https = (isset($_SERVER['HTTPS']) && strtolower($_SERVER['HTTPS']) !== 'off');\n        $url = ($https ? 'https://' : 'http://')\n            . $_SERVER['SERVER_NAME']                                              // host\n            . (((!$https && $_SERVER['SERVER_PORT'] == 80) || ($https && $_SERVER['SERVER_PORT'] == 443)) ? '' : (':' . $_SERVER['SERVER_PORT']))  // port\n            . $_SERVER['REQUEST_URI'];                                             // path & query\n        list($url) = explode('?', $url);\n\n        return $url;\n    }\n\n    /**\n     * Get stream resource pointer by URL\n     *\n     * @param array $data array('target'=>'URL', 'headers' => array())\n     * @param int   $redirectLimit\n     *\n     * @return resource|boolean\n     * @author Naoki Sawada\n     */\n    public static function getStreamByUrl($data, $redirectLimit = 5)\n    {\n        if (isset($data['target'])) {\n            $data = array(\n                'cnt' => 0,\n                'url' => $data['target'],\n                'headers' => isset($data['headers']) ? $data['headers'] : array(),\n                'cookies' => array(),\n            );\n        }\n        if ($data['cnt'] > $redirectLimit) {\n            return false;\n        }\n        $dlurl = $data['url'];\n        $data['url'] = '';\n        $headers = $data['headers'];\n\n        if ($dlurl) {\n            $url = parse_url($dlurl);\n            $ports = array(\n                'http' => '80',\n                'https' => '443',\n                'ftp' => '21'\n            );\n            $url['scheme'] = strtolower($url['scheme']);\n            if (!isset($url['port']) && isset($ports[$url['scheme']])) {\n                $url['port'] = $ports[$url['scheme']];\n            }\n            if (!isset($url['port'])) {\n                return false;\n            }\n            $cookies = array();\n            if ($data['cookies']) {\n                foreach ($data['cookies'] as $d => $c) {\n                    if (strpos($url['host'], $d) !== false) {\n                        $cookies[] = $c;\n                    }\n                }\n            }\n\n            $transport = ($url['scheme'] === 'https') ? 'tls' : 'tcp';\n            $query = isset($url['query']) ? '?' . $url['query'] : '';\n            $stream = stream_socket_client($transport . '://' . $url['host'] . ':' . $url['port']);\n            stream_set_timeout($stream, 300);\n            fputs($stream, \"GET {$url['path']}{$query} HTTP/1.1\\r\\n\");\n            fputs($stream, \"Host: {$url['host']}\\r\\n\");\n            foreach ($headers as $header) {\n                fputs($stream, trim($header, \"\\r\\n\") . \"\\r\\n\");\n            }\n            fputs($stream, \"Connection: Close\\r\\n\");\n            if ($cookies) {\n                fputs($stream, 'Cookie: ' . implode('; ', $cookies) . \"\\r\\n\");\n            }\n            fputs($stream, \"\\r\\n\");\n            while (($res = trim(fgets($stream))) !== '') {\n                // find redirect\n                if (preg_match('/^Location: (.+)$/', $res, $m)) {\n                    $data['url'] = $m[1];\n                }\n                // fetch cookie\n                if (strpos($res, 'Set-Cookie:') === 0) {\n                    $domain = $url['host'];\n                    if (preg_match('/^Set-Cookie:(.+)(?:domain=\\s*([^ ;]+))?/i', $res, $c1)) {\n                        if (!empty($c1[2])) {\n                            $domain = trim($c1[2]);\n                        }\n                        if (preg_match('/([^ ]+=[^;]+)/', $c1[1], $c2)) {\n                            $data['cookies'][$domain] = $c2[1];\n                        }\n                    }\n                }\n            }\n            if ($data['url']) {\n                ++$data['cnt'];\n                fclose($stream);\n\n                return self::getStreamByUrl($data, $redirectLimit);\n            }\n\n            return $stream;\n        }\n\n        return false;\n    }\n\n    /**\n     * Gets the fetch cookie file for curl.\n     *\n     * @return string  The fetch cookie file.\n     */\n    public function getFetchCookieFile()\n    {\n        $file = '';\n        if ($tmpDir = $this->getTempDir()) {\n            $file = $tmpDir . '/.elFinderAnonymousCookie';\n        }\n        return $file;\n    }\n\n    /**\n     * Call curl_exec() with supported redirect on `safe_mode` or `open_basedir`\n     *\n     * @param resource $curl\n     * @param array    $options\n     * @param array    $headers\n     *\n     * @throws \\Exception\n     * @return mixed\n     * @author Naoki Sawada\n     */\n    public static function curlExec($curl, $options = array(), $headers = array())\n    {\n        $followLocation = (!ini_get('safe_mode') && !ini_get('open_basedir'));\n        if ($followLocation) {\n            curl_setopt($curl, CURLOPT_FOLLOWLOCATION, true);\n        }\n\n        if ($options) {\n            curl_setopt_array($curl, $options);\n        }\n\n        if ($headers) {\n            curl_setopt($curl, CURLOPT_HTTPHEADER, $headers);\n        }\n\n        $result = curl_exec($curl);\n\n        if (!$followLocation && $redirect = curl_getinfo($curl, CURLINFO_REDIRECT_URL)) {\n            if ($stream = self::getStreamByUrl(array('target' => $redirect, 'headers' => $headers))) {\n                $result = stream_get_contents($stream);\n            }\n        }\n\n        if ($result === false) {\n            if (curl_errno($curl)) {\n                throw new \\Exception('curl_exec() failed: ' . curl_error($curl));\n            } else {\n                throw new \\Exception('curl_exec(): empty response');\n            }\n        }\n\n        curl_close($curl);\n\n        return $result;\n    }\n\n    /**\n     * Return bool that current request was aborted by client side\n     *\n     * @return boolean\n     */\n    public static function aborted()\n    {\n        if ($file = self::$abortCheckFile) {\n            (version_compare(PHP_VERSION, '5.3.0') >= 0) ? clearstatcache(true, $file) : clearstatcache();\n            if (!is_file($file)) {\n                // GC (expire 12h)\n                list($ptn) = explode('elfreq', $file);\n                self::GlobGC($ptn . 'elfreq*', 43200);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Return array [\"name without extention\", \"extention\"] by filename\n     *\n     * @param string $name\n     *\n     * @return array\n     */\n    public static function splitFileExtention($name)\n    {\n        if (preg_match('/^(.+?)?\\.((?:tar\\.(?:gz|bz|bz2|z|lzo))|cpio\\.gz|ps\\.gz|xcf\\.(?:gz|bz2)|[a-z0-9]{1,10})$/i', $name, $m)) {\n            return array((string)$m[1], $m[2]);\n        } else {\n            return array($name, '');\n        }\n    }\n\n    /**\n     * Gets the memory size by imageinfo.\n     *\n     * @param      array $imgInfo array that result of getimagesize()\n     *\n     * @return     integer  The memory size by imageinfo.\n     */\n    public static function getMemorySizeByImageInfo($imgInfo)\n    {\n        $width = $imgInfo[0];\n        $height = $imgInfo[1];\n        $bits = isset($imgInfo['bits']) ? $imgInfo['bits'] : 24;\n        $channels = isset($imgInfo['channels']) ? $imgInfo['channels'] : 3;\n        return round(($width * $height * $bits * $channels / 8 + Pow(2, 16)) * 1.65);\n    }\n\n    /**\n     * Auto expand memory for GD processing\n     *\n     * @param      array $imgInfos The image infos\n     */\n    public static function expandMemoryForGD($imgInfos)\n    {\n        if (elFinder::$memoryLimitGD != 0 && $imgInfos && is_array($imgInfos)) {\n            if (!is_array($imgInfos[0])) {\n                $imgInfos = array($imgInfos);\n            }\n            $limit = self::getIniBytes('', elFinder::$memoryLimitGD);\n            $memLimit = self::getIniBytes('memory_limit');\n            $needs = 0;\n            foreach ($imgInfos as $info) {\n                $needs += self::getMemorySizeByImageInfo($info);\n            }\n            $needs += memory_get_usage();\n            if ($needs > $memLimit && ($limit == -1 || $limit > $needs)) {\n                ini_set('memory_limit', $needs);\n            }\n        }\n    }\n\n    /***************************************************************************/\n    /*                                 callbacks                               */\n    /***************************************************************************/\n\n    /**\n     * Get command name of binded \"commandName.subName\"\n     *\n     * @param string $cmd\n     *\n     * @return string\n     */\n    protected static function getCmdOfBind($cmd)\n    {\n        list($ret) = explode('.', $cmd);\n        return trim($ret);\n    }\n\n    /**\n     * Add subName to commandName\n     *\n     * @param string $cmd\n     * @param string $sub\n     *\n     * @return string\n     */\n    protected static function addSubToBindName($cmd, $sub)\n    {\n        return $cmd . '.' . trim($sub);\n    }\n\n    /**\n     * Remove a file if connection is disconnected\n     *\n     * @param string $file\n     */\n    public static function rmFileInDisconnected($file)\n    {\n        (connection_aborted() || connection_status() !== CONNECTION_NORMAL) && is_file($file) && unlink($file);\n    }\n\n    /**\n     * Call back function on shutdown\n     *  - delete files in $GLOBALS['elFinderTempFiles']\n     */\n    public static function onShutdown()\n    {\n        self::$abortCheckFile = null;\n        if (!empty($GLOBALS['elFinderTempFiles'])) {\n            foreach (array_keys($GLOBALS['elFinderTempFiles']) as $f) {\n                is_file($f) && unlink($f);\n            }\n        }\n    }\n\n    /**\n     * Garbage collection with glob\n     *\n     * @param string  $pattern\n     * @param integer $time\n     */\n    public static function GlobGC($pattern, $time)\n    {\n        $now = time();\n        foreach (glob($pattern) as $file) {\n            (filemtime($file) < ($now - $time)) && unlink($file);\n        }\n    }\n\n} // END class\n\n/**\n * Custom exception class for aborting request\n */\nclass elFinderAbortException extends Exception\n{\n}\n"], "fixing_code": ["<?php\n\n/**\n * elFinder - file manager for web.\n * Core class.\n *\n * @package elfinder\n * @author  Dmitry (dio) Levashov\n * @author  Troex Nevelin\n * @author  Alexey Sukhotin\n **/\nclass elFinder\n{\n\n    /**\n     * API version number\n     *\n     * @var float\n     **/\n    protected static $ApiVersion = 2.1;\n\n    /**\n     * API version number\n     *\n     * @deprecated\n     * @var string\n     **/\n    protected $version;\n\n    /**\n     * API revision that this connector supports all functions\n     *\n     * @var integer\n     */\n    protected static $ApiRevision = 45;\n\n    /**\n     * Storages (root dirs)\n     *\n     * @var array\n     **/\n    protected $volumes = array();\n\n    /**\n     * elFinder instance\n     *\n     * @var object\n     */\n    public static $instance = null;\n\n    /**\n     * Current request args\n     *\n     * @var array\n     */\n    public static $currentArgs = array();\n\n    /**\n     * Network mount drivers\n     *\n     * @var array\n     */\n    public static $netDrivers = array();\n\n    /**\n     * elFinder global locale\n     *\n     * @var string\n     */\n    public static $locale = '';\n\n    /**\n     * elFinderVolumeDriver default mime.type file path\n     *\n     * @var string\n     */\n    public static $defaultMimefile = '';\n\n    /**\n     * A file save destination path when a temporary content URL is required\n     * on a network volume or the like\n     * It can be overwritten by volume route setting\n     *\n     * @var string\n     */\n    public static $tmpLinkPath = '';\n\n    /**\n     * A file save destination URL when a temporary content URL is required\n     * on a network volume or the like\n     * It can be overwritten by volume route setting\n     *\n     * @var string\n     */\n    public static $tmpLinkUrl = '';\n\n    /**\n     * Temporary content URL lifetime (seconds)\n     *\n     * @var integer\n     */\n    public static $tmpLinkLifeTime = 3600;\n\n    /**\n     * MIME type list handled as a text file\n     *\n     * @var array\n     */\n    public static $textMimes = array(\n        'application/dash+xml',\n        'application/docbook+xml',\n        'application/javascript',\n        'application/json',\n        'application/plt',\n        'application/sat',\n        'application/sql',\n        'application/step',\n        'application/vnd.hp-hpgl',\n        'application/x-awk',\n        'application/x-config',\n        'application/x-csh',\n        'application/x-empty',\n        'application/x-mpegurl',\n        'application/x-perl',\n        'application/x-php',\n        'application/x-web-config',\n        'application/xhtml+xml',\n        'application/xml',\n        'audio/x-mp3-playlist',\n        'image/cgm',\n        'image/svg+xml',\n        'image/vnd.dxf',\n        'model/iges'\n    );\n\n    /**\n     * Maximum memory size to be extended during GD processing\n     * (0: not expanded, -1: unlimited or memory size notation)\n     *\n     * @var integer|string\n     */\n    public static $memoryLimitGD = 0;\n\n    /**\n     * Path of current request flag file for abort check\n     *\n     * @var string\n     */\n    protected static $abortCheckFile = null;\n\n    /**\n     * elFinder session wrapper object\n     *\n     * @var elFinderSessionInterface\n     */\n    protected $session;\n\n    /**\n     * elFinder global sessionCacheKey\n     *\n     * @deprecated\n     * @var string\n     */\n    public static $sessionCacheKey = '';\n\n    /**\n     * Is session closed\n     *\n     * @deprecated\n     * @var bool\n     */\n    private static $sessionClosed = false;\n\n    /**\n     * elFinder base64encodeSessionData\n     * elFinder save session data as `UTF-8`\n     * If the session storage mechanism of the system does not allow `UTF-8`\n     * And it must be `true` option 'base64encodeSessionData' of elFinder\n     * WARNING: When enabling this option, if saving the data passed from the user directly to the session variable,\n     * it make vulnerable to the object injection attack, so use it carefully.\n     * see https://github.com/Studio-42/elFinder/issues/2345\n     *\n     * @var bool\n     */\n    protected static $base64encodeSessionData = false;\n\n    /**\n     * elFinder common tempraly path\n     *\n     * @var string\n     * @default \"./.tmp\" or sys_get_temp_dir()\n     **/\n    protected static $commonTempPath = '';\n\n    /**\n     * Callable function for URL upload filter\n     * The first argument is a URL and the second argument is an instance of the elFinder class\n     * A filter should be return true (to allow) / false (to disallow)\n     *\n     * @var callable\n     * @default null\n     */\n    protected $urlUploadFilter = null;\n\n    /**\n     * Connection flag files path that connection check of current request\n     *\n     * @var string\n     * @default value of $commonTempPath\n     */\n    protected static $connectionFlagsPath = '';\n\n    /**\n     * Additional volume root options for network mounting volume\n     *\n     * @var array\n     */\n    protected $optionsNetVolumes = array();\n\n    /**\n     * Session key of net mount volumes\n     *\n     * @deprecated\n     * @var string\n     */\n    protected $netVolumesSessionKey = '';\n\n    /**\n     * Mounted volumes count\n     * Required to create unique volume id\n     *\n     * @var int\n     **/\n    public static $volumesCnt = 1;\n\n    /**\n     * Default root (storage)\n     *\n     * @var elFinderVolumeDriver\n     **/\n    protected $default = null;\n\n    /**\n     * Commands and required arguments list\n     *\n     * @var array\n     **/\n    protected $commands = array(\n        'open' => array('target' => false, 'tree' => false, 'init' => false, 'mimes' => false, 'compare' => false),\n        'ls' => array('target' => true, 'mimes' => false, 'intersect' => false),\n        'tree' => array('target' => true),\n        'parents' => array('target' => true, 'until' => false),\n        'tmb' => array('targets' => true),\n        'file' => array('target' => true, 'download' => false, 'cpath' => false, 'onetime' => false),\n        'zipdl' => array('targets' => true, 'download' => false),\n        'size' => array('targets' => true),\n        'mkdir' => array('target' => true, 'name' => false, 'dirs' => false),\n        'mkfile' => array('target' => true, 'name' => true, 'mimes' => false),\n        'rm' => array('targets' => true),\n        'rename' => array('target' => true, 'name' => true, 'mimes' => false, 'targets' => false, 'q' => false),\n        'duplicate' => array('targets' => true, 'suffix' => false),\n        'paste' => array('dst' => true, 'targets' => true, 'cut' => false, 'mimes' => false, 'renames' => false, 'hashes' => false, 'suffix' => false),\n        'upload' => array('target' => true, 'FILES' => true, 'mimes' => false, 'html' => false, 'upload' => false, 'name' => false, 'upload_path' => false, 'chunk' => false, 'cid' => false, 'node' => false, 'renames' => false, 'hashes' => false, 'suffix' => false, 'mtime' => false, 'overwrite' => false, 'contentSaveId' => false),\n        'get' => array('target' => true, 'conv' => false),\n        'put' => array('target' => true, 'content' => '', 'mimes' => false, 'encoding' => false),\n        'archive' => array('targets' => true, 'type' => true, 'mimes' => false, 'name' => false),\n        'extract' => array('target' => true, 'mimes' => false, 'makedir' => false),\n        'search' => array('q' => true, 'mimes' => false, 'target' => false, 'type' => false),\n        'info' => array('targets' => true, 'compare' => false),\n        'dim' => array('target' => true, 'substitute' => false),\n        'resize' => array('target' => true, 'width' => false, 'height' => false, 'mode' => false, 'x' => false, 'y' => false, 'degree' => false, 'quality' => false, 'bg' => false),\n        'netmount' => array('protocol' => true, 'host' => true, 'path' => false, 'port' => false, 'user' => false, 'pass' => false, 'alias' => false, 'options' => false),\n        'url' => array('target' => true, 'options' => false),\n        'callback' => array('node' => true, 'json' => false, 'bind' => false, 'done' => false),\n        'chmod' => array('targets' => true, 'mode' => true),\n        'subdirs' => array('targets' => true),\n        'abort' => array('id' => true),\n        'editor' => array('name' => true, 'method' => true, 'args' => false)\n    );\n\n    /**\n     * Plugins instance\n     *\n     * @var array\n     **/\n    protected $plugins = array();\n\n    /**\n     * Commands listeners\n     *\n     * @var array\n     **/\n    protected $listeners = array();\n\n    /**\n     * script work time for debug\n     *\n     * @var string\n     **/\n    protected $time = 0;\n    /**\n     * Is elFinder init correctly?\n     *\n     * @var bool\n     **/\n    protected $loaded = false;\n    /**\n     * Send debug to client?\n     *\n     * @var string\n     **/\n    protected $debug = false;\n\n    /**\n     * Call `session_write_close()` before exec command?\n     *\n     * @var bool\n     */\n    protected $sessionCloseEarlier = true;\n\n    /**\n     * SESSION use commands @see __construct()\n     *\n     * @var array\n     */\n    protected $sessionUseCmds = array();\n\n    /**\n     * session expires timeout\n     *\n     * @var int\n     **/\n    protected $timeout = 0;\n\n    /**\n     * Temp dir path for Upload\n     *\n     * @var string\n     */\n    protected $uploadTempPath = '';\n\n    /**\n     * Max allowed archive files size (0 - no limit)\n     *\n     * @var integer\n     */\n    protected $maxArcFilesSize = 0;\n\n    /**\n     * undocumented class variable\n     *\n     * @var string\n     **/\n    protected $uploadDebug = '';\n\n    /**\n     * Max allowed numbar of targets (0 - no limit)\n     *\n     * @var integer\n     */\n    public $maxTargets = 1000;\n\n    /**\n     * Errors from PHP\n     *\n     * @var array\n     **/\n    public static $phpErrors = array();\n\n    /**\n     * Errors from not mounted volumes\n     *\n     * @var array\n     **/\n    public $mountErrors = array();\n\n\n    /**\n     * Archivers cache\n     *\n     * @var array\n     */\n    public static $archivers = array();\n\n    /**\n     * URL for callback output window for CORS\n     * redirect to this URL when callback output\n     *\n     * @var string URL\n     */\n    protected $callbackWindowURL = '';\n\n    /**\n     * hash of items to unlock on command completion\n     *\n     * @var array hashes\n     */\n    protected $autoUnlocks = array();\n\n    /**\n     * Item locking expiration (seconds)\n     * Default: 3600 secs\n     *\n     * @var integer\n     */\n    protected $itemLockExpire = 3600;\n\n    /**\n     * Additional request querys\n     *\n     * @var array|null\n     */\n    protected $customData = null;\n\n    /**\n     * Ids to remove of session var \"urlContentSaveIds\" for contents uploading by URL\n     *\n     * @var array\n     */\n    protected $removeContentSaveIds = array();\n\n    /**\n     * Flag of throw Error on exec()\n     *\n     * @var boolean\n     */\n    protected $throwErrorOnExec = false;\n\n    // Errors messages\n    const ERROR_UNKNOWN = 'errUnknown';\n    const ERROR_UNKNOWN_CMD = 'errUnknownCmd';\n    const ERROR_CONF = 'errConf';\n    const ERROR_CONF_NO_JSON = 'errJSON';\n    const ERROR_CONF_NO_VOL = 'errNoVolumes';\n    const ERROR_INV_PARAMS = 'errCmdParams';\n    const ERROR_OPEN = 'errOpen';\n    const ERROR_DIR_NOT_FOUND = 'errFolderNotFound';\n    const ERROR_FILE_NOT_FOUND = 'errFileNotFound';     // 'File not found.'\n    const ERROR_TRGDIR_NOT_FOUND = 'errTrgFolderNotFound'; // 'Target folder \"$1\" not found.'\n    const ERROR_NOT_DIR = 'errNotFolder';\n    const ERROR_NOT_FILE = 'errNotFile';\n    const ERROR_PERM_DENIED = 'errPerm';\n    const ERROR_LOCKED = 'errLocked';        // '\"$1\" is locked and can not be renamed, moved or removed.'\n    const ERROR_EXISTS = 'errExists';        // 'File named \"$1\" already exists.'\n    const ERROR_INVALID_NAME = 'errInvName';       // 'Invalid file name.'\n    const ERROR_INVALID_DIRNAME = 'errInvDirname';    // 'Invalid folder name.'\n    const ERROR_MKDIR = 'errMkdir';\n    const ERROR_MKFILE = 'errMkfile';\n    const ERROR_RENAME = 'errRename';\n    const ERROR_COPY = 'errCopy';\n    const ERROR_MOVE = 'errMove';\n    const ERROR_COPY_FROM = 'errCopyFrom';\n    const ERROR_COPY_TO = 'errCopyTo';\n    const ERROR_COPY_ITSELF = 'errCopyInItself';\n    const ERROR_REPLACE = 'errReplace';          // 'Unable to replace \"$1\".'\n    const ERROR_RM = 'errRm';               // 'Unable to remove \"$1\".'\n    const ERROR_RM_SRC = 'errRmSrc';            // 'Unable remove source file(s)'\n    const ERROR_MKOUTLINK = 'errMkOutLink';        // 'Unable to create a link to outside the volume root.'\n    const ERROR_UPLOAD = 'errUpload';           // 'Upload error.'\n    const ERROR_UPLOAD_FILE = 'errUploadFile';       // 'Unable to upload \"$1\".'\n    const ERROR_UPLOAD_NO_FILES = 'errUploadNoFiles';    // 'No files found for upload.'\n    const ERROR_UPLOAD_TOTAL_SIZE = 'errUploadTotalSize';  // 'Data exceeds the maximum allowed size.'\n    const ERROR_UPLOAD_FILE_SIZE = 'errUploadFileSize';   // 'File exceeds maximum allowed size.'\n    const ERROR_UPLOAD_FILE_MIME = 'errUploadMime';       // 'File type not allowed.'\n    const ERROR_UPLOAD_TRANSFER = 'errUploadTransfer';   // '\"$1\" transfer error.'\n    const ERROR_UPLOAD_TEMP = 'errUploadTemp';       // 'Unable to make temporary file for upload.'\n    const ERROR_ACCESS_DENIED = 'errAccess';\n    const ERROR_NOT_REPLACE = 'errNotReplace';       // Object \"$1\" already exists at this location and can not be replaced with object of another type.\n    const ERROR_SAVE = 'errSave';\n    const ERROR_EXTRACT = 'errExtract';\n    const ERROR_ARCHIVE = 'errArchive';\n    const ERROR_NOT_ARCHIVE = 'errNoArchive';\n    const ERROR_ARCHIVE_TYPE = 'errArcType';\n    const ERROR_ARC_SYMLINKS = 'errArcSymlinks';\n    const ERROR_ARC_MAXSIZE = 'errArcMaxSize';\n    const ERROR_RESIZE = 'errResize';\n    const ERROR_RESIZESIZE = 'errResizeSize';\n    const ERROR_UNSUPPORT_TYPE = 'errUsupportType';\n    const ERROR_CONV_UTF8 = 'errConvUTF8';\n    const ERROR_NOT_UTF8_CONTENT = 'errNotUTF8Content';\n    const ERROR_NETMOUNT = 'errNetMount';\n    const ERROR_NETUNMOUNT = 'errNetUnMount';\n    const ERROR_NETMOUNT_NO_DRIVER = 'errNetMountNoDriver';\n    const ERROR_NETMOUNT_FAILED = 'errNetMountFailed';\n    const ERROR_SESSION_EXPIRES = 'errSessionExpires';\n    const ERROR_CREATING_TEMP_DIR = 'errCreatingTempDir';\n    const ERROR_FTP_DOWNLOAD_FILE = 'errFtpDownloadFile';\n    const ERROR_FTP_UPLOAD_FILE = 'errFtpUploadFile';\n    const ERROR_FTP_MKDIR = 'errFtpMkdir';\n    const ERROR_ARCHIVE_EXEC = 'errArchiveExec';\n    const ERROR_EXTRACT_EXEC = 'errExtractExec';\n    const ERROR_SEARCH_TIMEOUT = 'errSearchTimeout';    // 'Timed out while searching \"$1\". Search result is partial.'\n    const ERROR_REAUTH_REQUIRE = 'errReauthRequire';  // 'Re-authorization is required.'\n    const ERROR_MAX_TARGTES = 'errMaxTargets'; // 'Max number of selectable items is $1.'\n\n    /**\n     * Constructor\n     *\n     * @param  array  elFinder and roots configurations\n     *\n     * @author Dmitry (dio) Levashov\n     */\n    public function __construct($opts)\n    {\n        // set default_charset\n        if (version_compare(PHP_VERSION, '5.6', '>=')) {\n            if (($_val = ini_get('iconv.internal_encoding')) && strtoupper($_val) !== 'UTF-8') {\n                ini_set('iconv.internal_encoding', '');\n            }\n            if (($_val = ini_get('mbstring.internal_encoding')) && strtoupper($_val) !== 'UTF-8') {\n                ini_set('mbstring.internal_encoding', '');\n            }\n            if (($_val = ini_get('internal_encoding')) && strtoupper($_val) !== 'UTF-8') {\n                ini_set('internal_encoding', '');\n            }\n        } else {\n            if (function_exists('iconv_set_encoding') && strtoupper(iconv_get_encoding('internal_encoding')) !== 'UTF-8') {\n                iconv_set_encoding('internal_encoding', 'UTF-8');\n            }\n            if (function_exists('mb_internal_encoding') && strtoupper(mb_internal_encoding()) !== 'UTF-8') {\n                mb_internal_encoding('UTF-8');\n            }\n        }\n        ini_set('default_charset', 'UTF-8');\n\n        // define accept constant of server commands path\n        !defined('ELFINDER_TAR_PATH') && define('ELFINDER_TAR_PATH', 'tar');\n        !defined('ELFINDER_GZIP_PATH') && define('ELFINDER_GZIP_PATH', 'gzip');\n        !defined('ELFINDER_BZIP2_PATH') && define('ELFINDER_BZIP2_PATH', 'bzip2');\n        !defined('ELFINDER_XZ_PATH') && define('ELFINDER_XZ_PATH', 'xz');\n        !defined('ELFINDER_ZIP_PATH') && define('ELFINDER_ZIP_PATH', 'zip');\n        !defined('ELFINDER_UNZIP_PATH') && define('ELFINDER_UNZIP_PATH', 'unzip');\n        !defined('ELFINDER_RAR_PATH') && define('ELFINDER_RAR_PATH', 'rar');\n        !defined('ELFINDER_UNRAR_PATH') && define('ELFINDER_UNRAR_PATH', 'unrar');\n        !defined('ELFINDER_7Z_PATH') && define('ELFINDER_7Z_PATH', (substr(PHP_OS, 0, 3) === 'WIN') ? '7z' : '7za');\n        !defined('ELFINDER_CONVERT_PATH') && define('ELFINDER_CONVERT_PATH', 'convert');\n        !defined('ELFINDER_IDENTIFY_PATH') && define('ELFINDER_IDENTIFY_PATH', 'identify');\n        !defined('ELFINDER_EXIFTRAN_PATH') && define('ELFINDER_EXIFTRAN_PATH', 'exiftran');\n        !defined('ELFINDER_JPEGTRAN_PATH') && define('ELFINDER_JPEGTRAN_PATH', 'jpegtran');\n        !defined('ELFINDER_FFMPEG_PATH') && define('ELFINDER_FFMPEG_PATH', 'ffmpeg');\n\n        !defined('ELFINDER_DISABLE_ZIPEDITOR') && define('ELFINDER_DISABLE_ZIPEDITOR', false);\n\n        // enable(true)/disable(false) handling postscript on ImageMagick\n        // Should be `false` as long as there is a Ghostscript vulnerability\n        // see https://artifex.com/news/ghostscript-security-resolved/\n        !defined('ELFINDER_IMAGEMAGICK_PS') && define('ELFINDER_IMAGEMAGICK_PS', false);\n\n        // for backward compat\n        $this->version = (string)self::$ApiVersion;\n\n        // set error handler of WARNING, NOTICE\n        $errLevel = E_WARNING | E_NOTICE | E_USER_WARNING | E_USER_NOTICE | E_STRICT | E_RECOVERABLE_ERROR;\n        if (defined('E_DEPRECATED')) {\n            $errLevel |= E_DEPRECATED | E_USER_DEPRECATED;\n        }\n        set_error_handler('elFinder::phpErrorHandler', $errLevel);\n\n        // Associative array of files to delete at the end of script: ['temp file path' => true]\n        $GLOBALS['elFinderTempFiles'] = array();\n        // regist Shutdown function\n        register_shutdown_function(array('elFinder', 'onShutdown'));\n\n        // convert PATH_INFO to GET query\n        if (!empty($_SERVER['PATH_INFO'])) {\n            $_ps = explode('/', trim($_SERVER['PATH_INFO'], '/'));\n            if (!isset($_GET['cmd'])) {\n                $_cmd = $_ps[0];\n                if (isset($this->commands[$_cmd])) {\n                    $_GET['cmd'] = $_cmd;\n                    $_i = 1;\n                    foreach (array_keys($this->commands[$_cmd]) as $_k) {\n                        if (isset($_ps[$_i])) {\n                            if (!isset($_GET[$_k])) {\n                                $_GET[$_k] = $_ps[$_i];\n                            }\n                        } else {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        // set elFinder instance\n        elFinder::$instance = $this;\n\n        // setup debug mode\n        $this->debug = (isset($opts['debug']) && $opts['debug'] ? true : false);\n        if ($this->debug) {\n            error_reporting(defined('ELFINDER_DEBUG_ERRORLEVEL') ? ELFINDER_DEBUG_ERRORLEVEL : -1);\n            ini_set('display_errors', '1');\n            // clear output buffer and stop output filters\n            while (ob_get_level() && ob_end_clean()) {\n            }\n        }\n\n        if (!interface_exists('elFinderSessionInterface')) {\n            include_once dirname(__FILE__) . '/elFinderSessionInterface.php';\n        }\n\n        // session handler\n        if (!empty($opts['session']) && $opts['session'] instanceof elFinderSessionInterface) {\n            $this->session = $opts['session'];\n        } else {\n            $sessionOpts = array(\n                'base64encode' => !empty($opts['base64encodeSessionData']),\n                'keys' => array(\n                    'default' => !empty($opts['sessionCacheKey']) ? $opts['sessionCacheKey'] : 'elFinderCaches',\n                    'netvolume' => !empty($opts['netVolumesSessionKey']) ? $opts['netVolumesSessionKey'] : 'elFinderNetVolumes'\n                )\n            );\n            if (!class_exists('elFinderSession')) {\n                include_once dirname(__FILE__) . '/elFinderSession.php';\n            }\n            $this->session = new elFinderSession($sessionOpts);\n        }\n        // try session start | restart\n        $this->session->start();\n\n        // 'netmount' added to handle requests synchronously on unmount\n        $sessionUseCmds = array('netmount');\n        if (isset($opts['sessionUseCmds']) && is_array($opts['sessionUseCmds'])) {\n            $sessionUseCmds = array_merge($sessionUseCmds, $opts['sessionUseCmds']);\n        }\n\n        // set self::$volumesCnt by HTTP header \"X-elFinder-VolumesCntStart\"\n        if (isset($_SERVER['HTTP_X_ELFINDER_VOLUMESCNTSTART']) && ($volumesCntStart = intval($_SERVER['HTTP_X_ELFINDER_VOLUMESCNTSTART']))) {\n            self::$volumesCnt = $volumesCntStart;\n        }\n\n        $this->time = $this->utime();\n        $this->sessionCloseEarlier = isset($opts['sessionCloseEarlier']) ? (bool)$opts['sessionCloseEarlier'] : true;\n        $this->sessionUseCmds = array_flip($sessionUseCmds);\n        $this->timeout = (isset($opts['timeout']) ? $opts['timeout'] : 0);\n        $this->uploadTempPath = (isset($opts['uploadTempPath']) ? $opts['uploadTempPath'] : '');\n        $this->callbackWindowURL = (isset($opts['callbackWindowURL']) ? $opts['callbackWindowURL'] : '');\n        $this->maxTargets = (isset($opts['maxTargets']) ? intval($opts['maxTargets']) : $this->maxTargets);\n        elFinder::$commonTempPath = (isset($opts['commonTempPath']) ? realpath($opts['commonTempPath']) : dirname(__FILE__) . '/.tmp');\n        if (!is_writable(elFinder::$commonTempPath)) {\n            elFinder::$commonTempPath = sys_get_temp_dir();\n            if (!is_writable(elFinder::$commonTempPath)) {\n                elFinder::$commonTempPath = '';\n            }\n        }\n        if (isset($opts['connectionFlagsPath']) && is_writable($opts['connectionFlagsPath'] = realpath($opts['connectionFlagsPath']))) {\n            elFinder::$connectionFlagsPath = $opts['connectionFlagsPath'];\n        } else {\n            elFinder::$connectionFlagsPath = elFinder::$commonTempPath;\n        }\n\n        if (!empty($opts['tmpLinkPath'])) {\n            elFinder::$tmpLinkPath = realpath($opts['tmpLinkPath']);\n        }\n        if (!empty($opts['tmpLinkUrl'])) {\n            elFinder::$tmpLinkUrl = $opts['tmpLinkUrl'];\n        }\n        if (!empty($opts['tmpLinkLifeTime'])) {\n            elFinder::$tmpLinkLifeTime = $opts['tmpLinkLifeTime'];\n        }\n        if (!empty($opts['textMimes']) && is_array($opts['textMimes'])) {\n            elfinder::$textMimes = $opts['textMimes'];\n        }\n        if (!empty($opts['urlUploadFilter'])) {\n            $this->urlUploadFilter = $opts['urlUploadFilter'];\n        }\n        $this->maxArcFilesSize = isset($opts['maxArcFilesSize']) ? intval($opts['maxArcFilesSize']) : 0;\n        $this->optionsNetVolumes = (isset($opts['optionsNetVolumes']) && is_array($opts['optionsNetVolumes'])) ? $opts['optionsNetVolumes'] : array();\n        if (isset($opts['itemLockExpire'])) {\n            $this->itemLockExpire = intval($opts['itemLockExpire']);\n        }\n\n        // deprecated settings\n        $this->netVolumesSessionKey = !empty($opts['netVolumesSessionKey']) ? $opts['netVolumesSessionKey'] : 'elFinderNetVolumes';\n        self::$sessionCacheKey = !empty($opts['sessionCacheKey']) ? $opts['sessionCacheKey'] : 'elFinderCaches';\n\n        // check session cache\n        $_optsMD5 = md5(json_encode($opts['roots']));\n        if ($this->session->get('_optsMD5') !== $_optsMD5) {\n            $this->session->set('_optsMD5', $_optsMD5);\n        }\n\n        // setlocale and global locale regists to elFinder::locale\n        self::$locale = !empty($opts['locale']) ? $opts['locale'] : (substr(PHP_OS, 0, 3) === 'WIN' ? 'C' : 'en_US.UTF-8');\n        if (false === setlocale(LC_ALL, self::$locale)) {\n            self::$locale = setlocale(LC_ALL, '0');\n        }\n\n        // set defaultMimefile\n        elFinder::$defaultMimefile = isset($opts['defaultMimefile']) ? $opts['defaultMimefile'] : '';\n\n        // set memoryLimitGD\n        elFinder::$memoryLimitGD = isset($opts['memoryLimitGD']) ? $opts['memoryLimitGD'] : 0;\n\n        // set flag of throwErrorOnExec\n        // `true` need `try{}` block for `$connector->run();`\n        $this->throwErrorOnExec = !empty($opts['throwErrorOnExec']);\n\n        // set archivers\n        elFinder::$archivers = isset($opts['archivers']) && is_array($opts['archivers']) ? $opts['archivers'] : array();\n\n        // bind events listeners\n        if (!empty($opts['bind']) && is_array($opts['bind'])) {\n            $_req = $_SERVER[\"REQUEST_METHOD\"] == 'POST' ? $_POST : $_GET;\n            $_reqCmd = isset($_req['cmd']) ? $_req['cmd'] : '';\n            foreach ($opts['bind'] as $cmd => $handlers) {\n                $doRegist = (strpos($cmd, '*') !== false);\n                if (!$doRegist) {\n                    $doRegist = ($_reqCmd && in_array($_reqCmd, array_map('self::getCmdOfBind', explode(' ', $cmd))));\n                }\n                if ($doRegist) {\n                    // for backward compatibility\n                    if (!is_array($handlers)) {\n                        $handlers = array($handlers);\n                    } else {\n                        if (count($handlers) === 2 && is_callable($handlers)) {\n                            $handlers = array($handlers);\n                        }\n                    }\n                    foreach ($handlers as $handler) {\n                        if ($handler) {\n                            if (is_string($handler) && strpos($handler, '.')) {\n                                list($_domain, $_name, $_method) = array_pad(explode('.', $handler), 3, '');\n                                if (strcasecmp($_domain, 'plugin') === 0) {\n                                    if ($plugin = $this->getPluginInstance($_name, isset($opts['plugin'][$_name]) ? $opts['plugin'][$_name] : array())\n                                        and method_exists($plugin, $_method)) {\n                                        $this->bind($cmd, array($plugin, $_method));\n                                    }\n                                }\n                            } else {\n                                $this->bind($cmd, $handler);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        if (!isset($opts['roots']) || !is_array($opts['roots'])) {\n            $opts['roots'] = array();\n        }\n\n        // try to enable elFinderVolumeFlysystemZipArchiveNetmount to zip editing\n        if (empty(elFinder::$netDrivers['ziparchive'])) {\n            elFinder::$netDrivers['ziparchive'] = 'FlysystemZipArchiveNetmount';\n        }\n\n        // check for net volumes stored in session\n        $netVolumes = $this->getNetVolumes();\n        foreach ($netVolumes as $key => $root) {\n            if (!isset($root['id'])) {\n                // given fixed unique id\n                if (!$root['id'] = $this->getNetVolumeUniqueId($netVolumes)) {\n                    $this->mountErrors[] = 'Netmount Driver \"' . $root['driver'] . '\" : Could\\'t given volume id.';\n                    continue;\n                }\n            }\n            $opts['roots'][$key] = $root;\n        }\n\n        // \"mount\" volumes\n        foreach ($opts['roots'] as $i => $o) {\n            $class = 'elFinderVolume' . (isset($o['driver']) ? $o['driver'] : '');\n\n            if (class_exists($class)) {\n                /* @var elFinderVolumeDriver $volume */\n                $volume = new $class();\n\n                try {\n                    if ($this->maxArcFilesSize && (empty($o['maxArcFilesSize']) || $this->maxArcFilesSize < $o['maxArcFilesSize'])) {\n                        $o['maxArcFilesSize'] = $this->maxArcFilesSize;\n                    }\n                    // pass session handler\n                    $volume->setSession($this->session);\n                    if ($volume->mount($o)) {\n                        // unique volume id (ends on \"_\") - used as prefix to files hash\n                        $id = $volume->id();\n\n                        $this->volumes[$id] = $volume;\n                        if ((!$this->default || $volume->root() !== $volume->defaultPath()) && $volume->isReadable()) {\n                            $this->default = $this->volumes[$id];\n                        }\n                    } else {\n                        $this->removeNetVolume($i, $volume);\n                        $this->mountErrors[] = 'Driver \"' . $class . '\" : ' . implode(' ', $volume->error());\n                    }\n                } catch (Exception $e) {\n                    $this->removeNetVolume($i, $volume);\n                    $this->mountErrors[] = 'Driver \"' . $class . '\" : ' . $e->getMessage();\n                }\n            } else {\n                $this->removeNetVolume($i, null);\n                $this->mountErrors[] = 'Driver \"' . $class . '\" does not exist';\n            }\n        }\n\n        // if at least one readable volume - ii desu >_<\n        $this->loaded = !empty($this->default);\n\n        // restore error handler for now\n        restore_error_handler();\n    }\n\n    /**\n     * Return elFinder session wrapper instance\n     *\n     * @return  elFinderSessionInterface\n     **/\n    public function getSession()\n    {\n        return $this->session;\n    }\n\n    /**\n     * Return true if fm init correctly\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    public function loaded()\n    {\n        return $this->loaded;\n    }\n\n    /**\n     * Return version (api) number\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    public function version()\n    {\n        return self::$ApiVersion;\n    }\n\n    /**\n     * Return revision (api) number\n     *\n     * @return string\n     * @author Naoki Sawada\n     **/\n    public function revision()\n    {\n        return self::$ApiRevision;\n    }\n\n    /**\n     * Add handler to elFinder command\n     *\n     * @param  string  command name\n     * @param  string|array  callback name or array(object, method)\n     *\n     * @return elFinder\n     * @author Dmitry (dio) Levashov\n     **/\n    public function bind($cmd, $handler)\n    {\n        $allCmds = array_keys($this->commands);\n        $cmds = array();\n        foreach (explode(' ', $cmd) as $_cmd) {\n            if ($_cmd !== '') {\n                if ($all = strpos($_cmd, '*') !== false) {\n                    list(, $sub) = array_pad(explode('.', $_cmd), 2, '');\n                    if ($sub) {\n                        $sub = str_replace('\\'', '\\\\\\'', $sub);\n                        $subs = array_fill(0, count($allCmds), $sub);\n                        $cmds = array_merge($cmds, array_map(array('elFinder', 'addSubToBindName'), $allCmds, $subs));\n                    } else {\n                        $cmds = array_merge($cmds, $allCmds);\n                    }\n                } else {\n                    $cmds[] = $_cmd;\n                }\n            }\n        }\n        $cmds = array_unique($cmds);\n\n        foreach ($cmds as $cmd) {\n            if (!isset($this->listeners[$cmd])) {\n                $this->listeners[$cmd] = array();\n            }\n\n            if (is_callable($handler)) {\n                $this->listeners[$cmd][] = $handler;\n            }\n        }\n\n        return $this;\n    }\n\n    /**\n     * Remove event (command exec) handler\n     *\n     * @param  string  command name\n     * @param  string|array  callback name or array(object, method)\n     *\n     * @return elFinder\n     * @author Dmitry (dio) Levashov\n     **/\n    public function unbind($cmd, $handler)\n    {\n        if (!empty($this->listeners[$cmd])) {\n            foreach ($this->listeners[$cmd] as $i => $h) {\n                if ($h === $handler) {\n                    unset($this->listeners[$cmd][$i]);\n                    return $this;\n                }\n            }\n        }\n        return $this;\n    }\n\n    /**\n     * Return true if command exists\n     *\n     * @param  string  command name\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    public function commandExists($cmd)\n    {\n        return $this->loaded && isset($this->commands[$cmd]) && method_exists($this, $cmd);\n    }\n\n    /**\n     * Return root - file's owner (public func of volume())\n     *\n     * @param  string  file hash\n     *\n     * @return elFinderVolumeDriver\n     * @author Naoki Sawada\n     */\n    public function getVolume($hash)\n    {\n        return $this->volume($hash);\n    }\n\n    /**\n     * Return command required arguments info\n     *\n     * @param  string  command name\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    public function commandArgsList($cmd)\n    {\n        if ($this->commandExists($cmd)) {\n            $list = $this->commands[$cmd];\n            $list['reqid'] = false;\n        } else {\n            $list = array();\n        }\n        return $list;\n    }\n\n    private function session_expires()\n    {\n\n        if (!$last = $this->session->get(':LAST_ACTIVITY')) {\n            $this->session->set(':LAST_ACTIVITY', time());\n            return false;\n        }\n\n        if (($this->timeout > 0) && (time() - $last > $this->timeout)) {\n            return true;\n        }\n\n        $this->session->set(':LAST_ACTIVITY', time());\n        return false;\n    }\n\n    /**\n     * Exec command and return result\n     *\n     * @param  string $cmd  command name\n     * @param  array  $args command arguments\n     *\n     * @return array\n     * @throws elFinderAbortException|Exception\n     * @author Dmitry (dio) Levashov\n     **/\n    public function exec($cmd, $args)\n    {\n        // set error handler of WARNING, NOTICE\n        set_error_handler('elFinder::phpErrorHandler', E_WARNING | E_NOTICE | E_USER_WARNING | E_USER_NOTICE);\n\n        // set current request args\n        self::$currentArgs = $args;\n\n        if (!$this->loaded) {\n            return array('error' => $this->error(self::ERROR_CONF, self::ERROR_CONF_NO_VOL));\n        }\n\n        if ($this->session_expires()) {\n            return array('error' => $this->error(self::ERROR_SESSION_EXPIRES));\n        }\n\n        if (!$this->commandExists($cmd)) {\n            return array('error' => $this->error(self::ERROR_UNKNOWN_CMD));\n        }\n\n        // check request id\n        $args['reqid'] = preg_replace('[^0-9a-fA-F]', '', !empty($args['reqid']) ? $args['reqid'] : (!empty($_SERVER['HTTP_X_ELFINDERREQID']) ? $_SERVER['HTTP_X_ELFINDERREQID'] : ''));\n\n        // to abort this request\n        if ($cmd === 'abort') {\n            $this->abort($args);\n            return array('error' => 0);\n        }\n\n        // make flag file and set self::$abortCheckFile\n        if ($args['reqid']) {\n            $this->abort(array('makeFile' => $args['reqid']));\n        }\n\n        if (!empty($args['mimes']) && is_array($args['mimes'])) {\n            foreach ($this->volumes as $id => $v) {\n                $this->volumes[$id]->setMimesFilter($args['mimes']);\n            }\n        }\n\n        // regist shutdown function as fallback\n        register_shutdown_function(array($this, 'itemAutoUnlock'));\n\n        // detect destination dirHash and volume\n        $dstVolume = false;\n        $dst = !empty($args['target']) ? $args['target'] : (!empty($args['dst']) ? $args['dst'] : '');\n        if ($dst) {\n            $dstVolume = $this->volume($dst);\n        } else if (isset($args['targets']) && is_array($args['targets']) && isset($args['targets'][0])) {\n            $dst = $args['targets'][0];\n            $dstVolume = $this->volume($dst);\n            if ($dstVolume && ($_stat = $dstVolume->file($dst)) && !empty($_stat['phash'])) {\n                $dst = $_stat['phash'];\n            } else {\n                $dst = '';\n            }\n        } else if ($cmd === 'open') {\n            // for initial open without args `target`\n            $dstVolume = $this->default;\n            $dst = $dstVolume->defaultPath();\n        }\n\n        $result = null;\n\n        // call pre handlers for this command\n        $args['sessionCloseEarlier'] = isset($this->sessionUseCmds[$cmd]) ? false : $this->sessionCloseEarlier;\n        if (!empty($this->listeners[$cmd . '.pre'])) {\n            foreach ($this->listeners[$cmd . '.pre'] as $handler) {\n                $_res = call_user_func_array($handler, array($cmd, &$args, $this, $dstVolume));\n                if (is_array($_res)) {\n                    if (!empty($_res['preventexec'])) {\n                        $result = array('error' => true);\n                        if ($cmd === 'upload' && !empty($args['node'])) {\n                            $result['callback'] = array(\n                                'node' => $args['node'],\n                                'bind' => $cmd\n                            );\n                        }\n                        if (!empty($_res['results']) && is_array($_res['results'])) {\n                            $result = array_merge($result, $_res['results']);\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n\n        // unlock session data for multiple access\n        if ($this->sessionCloseEarlier && $args['sessionCloseEarlier']) {\n            $this->session->close();\n            // deprecated property\n            elFinder::$sessionClosed = true;\n        }\n\n        if (substr(PHP_OS, 0, 3) === 'WIN') {\n            // set time out\n            elFinder::extendTimeLimit(300);\n        }\n\n        if (!is_array($result)) {\n            try {\n                $result = $this->$cmd($args);\n            } catch (elFinderAbortException $e) {\n                throw $e;\n            } catch (Exception $e) {\n                $result = array(\n                    'error' => htmlspecialchars($e->getMessage()),\n                    'sync' => true\n                );\n                if ($this->throwErrorOnExec) {\n                    throw $e;\n                }\n            }\n        }\n\n        // check change dstDir\n        $changeDst = false;\n        if ($dst && $dstVolume && (!empty($result['added']) || !empty($result['removed']))) {\n            $changeDst = true;\n        }\n\n        foreach ($this->volumes as $volume) {\n            $removed = $volume->removed();\n            if (!empty($removed)) {\n                if (!isset($result['removed'])) {\n                    $result['removed'] = array();\n                }\n                $result['removed'] = array_merge($result['removed'], $removed);\n                if (!$changeDst && $dst && $dstVolume && $volume === $dstVolume) {\n                    $changeDst = true;\n                }\n            }\n            $added = $volume->added();\n            if (!empty($added)) {\n                if (!isset($result['added'])) {\n                    $result['added'] = array();\n                }\n                $result['added'] = array_merge($result['added'], $added);\n                if (!$changeDst && $dst && $dstVolume && $volume === $dstVolume) {\n                    $changeDst = true;\n                }\n            }\n            $volume->resetResultStat();\n        }\n\n        // dstDir is changed\n        if ($changeDst) {\n            if ($dstDir = $dstVolume->dir($dst)) {\n                if (!isset($result['changed'])) {\n                    $result['changed'] = array();\n                }\n                $result['changed'][] = $dstDir;\n            }\n        }\n\n        // call handlers for this command\n        if (!empty($this->listeners[$cmd])) {\n            foreach ($this->listeners[$cmd] as $handler) {\n                if (call_user_func_array($handler, array($cmd, &$result, $args, $this, $dstVolume))) {\n                    // handler return true to force sync client after command completed\n                    $result['sync'] = true;\n                }\n            }\n        }\n\n        // replace removed files info with removed files hashes\n        if (!empty($result['removed'])) {\n            $removed = array();\n            foreach ($result['removed'] as $file) {\n                $removed[] = $file['hash'];\n            }\n            $result['removed'] = array_unique($removed);\n        }\n        // remove hidden files and filter files by mimetypes\n        if (!empty($result['added'])) {\n            $result['added'] = $this->filter($result['added']);\n        }\n        // remove hidden files and filter files by mimetypes\n        if (!empty($result['changed'])) {\n            $result['changed'] = $this->filter($result['changed']);\n        }\n\n        if ($this->debug || !empty($args['debug'])) {\n            $result['debug'] = array(\n                'connector' => 'php',\n                'phpver' => PHP_VERSION,\n                'time' => $this->utime() - $this->time,\n                'memory' => (function_exists('memory_get_peak_usage') ? ceil(memory_get_peak_usage() / 1024) . 'Kb / ' : '') . ceil(memory_get_usage() / 1024) . 'Kb / ' . ini_get('memory_limit'),\n                'upload' => $this->uploadDebug,\n                'volumes' => array(),\n                'mountErrors' => $this->mountErrors,\n                'phpErrors' => elFinder::$phpErrors\n            );\n            elFinder::$phpErrors = array();\n\n            foreach ($this->volumes as $id => $volume) {\n                $result['debug']['volumes'][] = $volume->debug();\n            }\n        }\n\n        // remove sesstion var 'urlContentSaveIds'\n        if ($this->removeContentSaveIds) {\n            $urlContentSaveIds = $this->session->get('urlContentSaveIds', array());\n            foreach (array_keys($this->removeContentSaveIds) as $contentSaveId) {\n                if (isset($urlContentSaveIds[$contentSaveId])) {\n                    unset($urlContentSaveIds[$contentSaveId]);\n                }\n            }\n            if ($urlContentSaveIds) {\n                $this->session->set('urlContentSaveIds', $urlContentSaveIds);\n            } else {\n                $this->session->remove('urlContentSaveIds');\n            }\n        }\n\n        foreach ($this->volumes as $volume) {\n            $volume->saveSessionCache();\n            $volume->umount();\n        }\n\n        // unlock locked items\n        $this->itemAutoUnlock();\n\n        // custom data\n        if ($this->customData !== null) {\n            $result['customData'] = $this->customData ? json_encode($this->customData) : '';\n        }\n\n        if (!empty($result['callback'])) {\n            $result['callback']['json'] = json_encode($result);\n            $this->callback($result['callback']);\n            return array();\n        } else {\n            return $result;\n        }\n    }\n\n    /**\n     * Return file real path\n     *\n     * @param  string $hash file hash\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    public function realpath($hash)\n    {\n        if (($volume = $this->volume($hash)) == false) {\n            return false;\n        }\n        return $volume->realpath($hash);\n    }\n\n    /**\n     * Sets custom data(s).\n     *\n     * @param  string|array $key The key or data array\n     * @param  mixed        $val The value\n     *\n     * @return self    ( elFinder instance )\n     */\n    public function setCustomData($key, $val = null)\n    {\n        if (is_array($key)) {\n            foreach ($key as $k => $v) {\n                $this->customData[$k] = $v;\n            }\n        } else {\n            $this->customData[$key] = $val;\n        }\n        return $this;\n    }\n\n    /**\n     * Removes a custom data.\n     *\n     * @param  string $key The key\n     *\n     * @return self    ( elFinder instance )\n     */\n    public function removeCustomData($key)\n    {\n        $this->customData[$key] = null;\n        return $this;\n    }\n\n    /**\n     * Update sesstion value of a NetVolume option\n     *\n     * @param string $netKey\n     * @param string $optionKey\n     * @param mixed  $val\n     */\n    public function updateNetVolumeOption($netKey, $optionKey, $val)\n    {\n        $netVolumes = $this->getNetVolumes();\n        if (is_string($netKey) && isset($netVolumes[$netKey]) && is_string($optionKey)) {\n            $netVolumes[$netKey][$optionKey] = $val;\n        }\n    }\n\n    /**\n     * remove of session var \"urlContentSaveIds\"\n     *\n     * @param string $id\n     */\n    public function removeUrlContentSaveId($id)\n    {\n        $this->removeContentSaveIds[$id] = true;\n    }\n\n    /**\n     * Return network volumes config.\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     */\n    protected function getNetVolumes()\n    {\n        if ($data = $this->session->get('netvolume', array())) {\n            return $data;\n        }\n        return array();\n    }\n\n    /**\n     * Save network volumes config.\n     *\n     * @param  array $volumes volumes config\n     *\n     * @return void\n     * @author Dmitry (dio) Levashov\n     */\n    protected function saveNetVolumes($volumes)\n    {\n        $this->session->set('netvolume', $volumes);\n    }\n\n    /**\n     * Remove netmount volume\n     *\n     * @param string $key    netvolume key\n     * @param object $volume volume driver instance\n     *\n     * @return bool\n     */\n    protected function removeNetVolume($key, $volume)\n    {\n        $netVolumes = $this->getNetVolumes();\n        $res = true;\n        if (is_object($volume) && method_exists($volume, 'netunmount')) {\n            $res = $volume->netunmount($netVolumes, $key);\n            $volume->clearSessionCache();\n        }\n        if ($res) {\n            if (is_string($key) && isset($netVolumes[$key])) {\n                unset($netVolumes[$key]);\n                $this->saveNetVolumes($netVolumes);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Get plugin instance & set to $this->plugins\n     *\n     * @param  string $name Plugin name (dirctory name)\n     * @param  array  $opts Plugin options (optional)\n     *\n     * @return object | bool Plugin object instance Or false\n     * @author Naoki Sawada\n     */\n    protected function getPluginInstance($name, $opts = array())\n    {\n        $key = strtolower($name);\n        if (!isset($this->plugins[$key])) {\n            $class = 'elFinderPlugin' . $name;\n            // to try auto load\n            if (!class_exists($class)) {\n                $p_file = dirname(__FILE__) . DIRECTORY_SEPARATOR . 'plugins' . DIRECTORY_SEPARATOR . $name . DIRECTORY_SEPARATOR . 'plugin.php';\n                if (is_file($p_file)) {\n                    include_once $p_file;\n                }\n            }\n            if (class_exists($class, false)) {\n                $this->plugins[$key] = new $class($opts);\n            } else {\n                $this->plugins[$key] = false;\n            }\n        }\n        return $this->plugins[$key];\n    }\n\n    /***************************************************************************/\n    /*                                 commands                                */\n    /***************************************************************************/\n\n    /**\n     * Normalize error messages\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    public function error()\n    {\n        $errors = array();\n\n        foreach (func_get_args() as $msg) {\n            if (is_array($msg)) {\n                $errors = array_merge($errors, $msg);\n            } else {\n                $errors[] = $msg;\n            }\n        }\n\n        return count($errors) ? $errors : array(self::ERROR_UNKNOWN);\n    }\n\n    /**\n     * @param $args\n     *\n     * @return array\n     * @throws elFinderAbortException\n     */\n    protected function netmount($args)\n    {\n        $options = array();\n        $protocol = $args['protocol'];\n        $toast = '';\n\n        if ($protocol === 'netunmount') {\n            if (!empty($args['user']) && $volume = $this->volume($args['user'])) {\n                if ($this->removeNetVolume($args['host'], $volume)) {\n                    return array('removed' => array(array('hash' => $volume->root())));\n                }\n            }\n            return array('sync' => true, 'error' => $this->error(self::ERROR_NETUNMOUNT));\n        }\n\n        $driver = isset(self::$netDrivers[$protocol]) ? self::$netDrivers[$protocol] : '';\n        $class = 'elFinderVolume' . $driver;\n\n        if (!class_exists($class)) {\n            return array('error' => $this->error(self::ERROR_NETMOUNT, $args['host'], self::ERROR_NETMOUNT_NO_DRIVER));\n        }\n\n        if (!$args['path']) {\n            $args['path'] = '/';\n        }\n\n        foreach ($args as $k => $v) {\n            if ($k != 'options' && $k != 'protocol' && $v) {\n                $options[$k] = $v;\n            }\n        }\n\n        if (is_array($args['options'])) {\n            foreach ($args['options'] as $key => $value) {\n                $options[$key] = $value;\n            }\n        }\n\n        /* @var elFinderVolumeDriver $volume */\n        $volume = new $class();\n\n        // pass session handler\n        $volume->setSession($this->session);\n\n        if (is_callable(array($volume, 'netmountPrepare'))) {\n            $options = $volume->netmountPrepare($options);\n            if (isset($options['exit'])) {\n                if ($options['exit'] === 'callback') {\n                    $this->callback($options['out']);\n                }\n                return $options;\n            }\n            if (!empty($options['toast'])) {\n                $toast = $options['toast'];\n                unset($options['toast']);\n            }\n        }\n\n        $netVolumes = $this->getNetVolumes();\n\n        if (!isset($options['id'])) {\n            // given fixed unique id\n            if (!$options['id'] = $this->getNetVolumeUniqueId($netVolumes)) {\n                return array('error' => $this->error(self::ERROR_NETMOUNT, $args['host'], 'Could\\'t given volume id.'));\n            }\n        }\n\n        // load additional volume root options\n        if (!empty($this->optionsNetVolumes['*'])) {\n            $options = array_merge($this->optionsNetVolumes['*'], $options);\n        }\n        if (!empty($this->optionsNetVolumes[$protocol])) {\n            $options = array_merge($this->optionsNetVolumes[$protocol], $options);\n        }\n\n        if (!$key = $volume->netMountKey) {\n            $key = md5($protocol . '-' . serialize($options));\n        }\n        $options['netkey'] = $key;\n\n        if (!isset($netVolumes[$key]) && $volume->mount($options)) {\n            // call post-process function of netmount\n            if (is_callable(array($volume, 'postNetmount'))) {\n                $volume->postNetmount($options);\n            }\n            $options['driver'] = $driver;\n            $netVolumes[$key] = $options;\n            $this->saveNetVolumes($netVolumes);\n            $rootstat = $volume->file($volume->root());\n            $res = array('added' => array($rootstat));\n            if ($toast) {\n                $res['toast'] = $toast;\n            }\n            return $res;\n        } else {\n            $this->removeNetVolume(null, $volume);\n            return array('error' => $this->error(self::ERROR_NETMOUNT, $args['host'], implode(' ', $volume->error())));\n        }\n    }\n\n    /**\n     * \"Open\" directory\n     * Return array with following elements\n     *  - cwd          - opened dir info\n     *  - files        - opened dir content [and dirs tree if $args[tree]]\n     *  - api          - api version (if $args[init])\n     *  - uplMaxSize   - if $args[init]\n     *  - error        - on failed\n     *\n     * @param  array  command arguments\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function open($args)\n    {\n        $target = $args['target'];\n        $init = !empty($args['init']);\n        $tree = !empty($args['tree']);\n        $volume = $this->volume($target);\n        $cwd = $volume ? $volume->dir($target) : false;\n        $hash = $init ? 'default folder' : '#' . $target;\n        $compare = '';\n\n        // on init request we can get invalid dir hash -\n        // dir which can not be opened now, but remembered by client,\n        // so open default dir\n        if ((!$cwd || !$cwd['read']) && $init) {\n            $volume = $this->default;\n            $target = $volume->defaultPath();\n            $cwd = $volume->dir($target);\n        }\n\n        if (!$cwd) {\n            return array('error' => $this->error(self::ERROR_OPEN, $hash, self::ERROR_DIR_NOT_FOUND));\n        }\n        if (!$cwd['read']) {\n            return array('error' => $this->error(self::ERROR_OPEN, $hash, self::ERROR_PERM_DENIED));\n        }\n\n        $files = array();\n\n        // get current working directory files list\n        if (($ls = $volume->scandir($cwd['hash'])) === false) {\n            return array('error' => $this->error(self::ERROR_OPEN, $cwd['name'], $volume->error()));\n        }\n\n        if (isset($cwd['dirs']) && $cwd['dirs'] != 1) {\n            $cwd = $volume->dir($target);\n        }\n\n        // get other volume root\n        if ($tree) {\n            foreach ($this->volumes as $id => $v) {\n                $files[] = $v->file($v->root());\n            }\n        }\n\n        // long polling mode\n        if ($args['compare']) {\n            $sleep = max(1, (int)$volume->getOption('lsPlSleep'));\n            $standby = (int)$volume->getOption('plStandby');\n            if ($standby > 0 && $sleep > $standby) {\n                $standby = $sleep;\n            }\n            $limit = max(0, floor($standby / $sleep)) + 1;\n            do {\n                elFinder::extendTimeLimit(30 + $sleep);\n                $_mtime = 0;\n                foreach ($ls as $_f) {\n                    $_mtime = max($_mtime, $_f['ts']);\n                }\n                $compare = strval(count($ls)) . ':' . strval($_mtime);\n                if ($compare !== $args['compare']) {\n                    break;\n                }\n                if (--$limit) {\n                    sleep($sleep);\n                    $volume->clearstatcache();\n                    if (($ls = $volume->scandir($cwd['hash'])) === false) {\n                        break;\n                    }\n                }\n            } while ($limit);\n            if ($ls === false) {\n                return array('error' => $this->error(self::ERROR_OPEN, $cwd['name'], $volume->error()));\n            }\n        }\n\n        if ($ls) {\n            if ($files) {\n                $files = array_merge($files, $ls);\n            } else {\n                $files = $ls;\n            }\n        }\n\n        $result = array(\n            'cwd' => $cwd,\n            'options' => $volume->options($cwd['hash']),\n            'files' => $files\n        );\n\n        if ($compare) {\n            $result['cwd']['compare'] = $compare;\n        }\n\n        if (!empty($args['init'])) {\n            $result['api'] = sprintf('%.1F%03d', self::$ApiVersion, self::$ApiRevision);\n            $result['uplMaxSize'] = ini_get('upload_max_filesize');\n            $result['uplMaxFile'] = ini_get('max_file_uploads');\n            $result['netDrivers'] = array_keys(self::$netDrivers);\n            $result['maxTargets'] = $this->maxTargets;\n            if ($volume) {\n                $result['cwd']['root'] = $volume->root();\n            }\n            if (elfinder::$textMimes) {\n                $result['textMimes'] = elfinder::$textMimes;\n            }\n        }\n\n        return $result;\n    }\n\n    /**\n     * Return dir files names list\n     *\n     * @param  array  command arguments\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function ls($args)\n    {\n        $target = $args['target'];\n        $intersect = isset($args['intersect']) ? $args['intersect'] : array();\n\n        if (($volume = $this->volume($target)) == false\n            || ($list = $volume->ls($target, $intersect)) === false) {\n            return array('error' => $this->error(self::ERROR_OPEN, '#' . $target));\n        }\n        return array('list' => $list);\n    }\n\n    /**\n     * Return subdirs for required directory\n     *\n     * @param  array  command arguments\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function tree($args)\n    {\n        $target = $args['target'];\n\n        if (($volume = $this->volume($target)) == false\n            || ($tree = $volume->tree($target)) == false) {\n            return array('error' => $this->error(self::ERROR_OPEN, '#' . $target));\n        }\n\n        return array('tree' => $tree);\n    }\n\n    /**\n     * Return parents dir for required directory\n     *\n     * @param  array  command arguments\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function parents($args)\n    {\n        $target = $args['target'];\n        $until = $args['until'];\n\n        if (($volume = $this->volume($target)) == false\n            || ($tree = $volume->parents($target, false, $until)) == false) {\n            return array('error' => $this->error(self::ERROR_OPEN, '#' . $target));\n        }\n\n        return array('tree' => $tree);\n    }\n\n    /**\n     * Return new created thumbnails list\n     *\n     * @param  array  command arguments\n     *\n     * @return array\n     * @throws ImagickException\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function tmb($args)\n    {\n\n        $result = array('images' => array());\n        $targets = $args['targets'];\n\n        foreach ($targets as $target) {\n            elFinder::checkAborted();\n\n            if (($volume = $this->volume($target)) != false\n                && (($tmb = $volume->tmb($target)) != false)) {\n                $result['images'][$target] = $tmb;\n            }\n        }\n        return $result;\n    }\n\n    /**\n     * Download files/folders as an archive file\n     * 1st: Return srrsy contains download archive file info\n     * 2nd: Return array contains opened file pointer, root itself and required headers\n     *\n     * @param  array  command arguments\n     *\n     * @return array\n     * @throws Exception\n     * @author Naoki Sawada\n     */\n    protected function zipdl($args)\n    {\n        $targets = $args['targets'];\n        $download = !empty($args['download']);\n        $h404 = 'HTTP/1.x 404 Not Found';\n\n        if (!$download) {\n            //1st: Return array contains download archive file info\n            $error = array(self::ERROR_ARCHIVE);\n            if (($volume = $this->volume($targets[0])) !== false) {\n                if ($dlres = $volume->zipdl($targets)) {\n                    $path = $dlres['path'];\n                    register_shutdown_function(array('elFinder', 'rmFileInDisconnected'), $path);\n                    if (count($targets) === 1) {\n                        $name = basename($volume->path($targets[0]));\n                    } else {\n                        $name = $dlres['prefix'] . '_Files';\n                    }\n                    $name .= '.' . $dlres['ext'];\n                    $uniqid = uniqid();\n                    $this->session->set('zipdl' . $uniqid, basename($path));\n                    $result = array(\n                        'zipdl' => array(\n                            'file' => $uniqid,\n                            'name' => $name,\n                            'mime' => $dlres['mime']\n                        )\n                    );\n                    return $result;\n                }\n                $error = array_merge($error, $volume->error());\n            }\n            return array('error' => $error);\n        } else {\n            // 2nd: Return array contains opened file session key, root itself and required headers\n            if (count($targets) !== 4 || ($volume = $this->volume($targets[0])) == false || !($file = $this->session->get('zipdl' . $targets[1]))) {\n                return array('error' => 'File not found', 'header' => $h404, 'raw' => true);\n            }\n            $this->session->remove('zipdl' . $targets[1]);\n            if ($volume->commandDisabled('zipdl')) {\n                return array('error' => 'File not found', 'header' => $h404, 'raw' => true);\n            }\n            $path = $volume->getTempPath() . DIRECTORY_SEPARATOR . basename($file);\n            if (!is_readable($path) || !is_writable($path)) {\n                return array('error' => 'File not found', 'header' => $h404, 'raw' => true);\n            }\n            // register auto delete on shutdown\n            $GLOBALS['elFinderTempFiles'][$path] = true;\n            // for HTTP headers\n            $name = $targets[2];\n            $mime = $targets[3];\n\n            $filenameEncoded = rawurlencode($name);\n            if (strpos($filenameEncoded, '%') === false) { // ASCII only\n                $filename = 'filename=\"' . $name . '\"';\n            } else {\n                $ua = $_SERVER['HTTP_USER_AGENT'];\n                if (preg_match('/MSIE [4-8]/', $ua)) { // IE < 9 do not support RFC 6266 (RFC 2231/RFC 5987)\n                    $filename = 'filename=\"' . $filenameEncoded . '\"';\n                } elseif (strpos($ua, 'Chrome') === false && strpos($ua, 'Safari') !== false && preg_match('#Version/[3-5]#', $ua)) { // Safari < 6\n                    $filename = 'filename=\"' . str_replace('\"', '', $name) . '\"';\n                } else { // RFC 6266 (RFC 2231/RFC 5987)\n                    $filename = 'filename*=UTF-8\\'\\'' . $filenameEncoded;\n                }\n            }\n\n            $fp = fopen($path, 'rb');\n            $file = fstat($fp);\n            $result = array(\n                'pointer' => $fp,\n                'header' => array(\n                    'Content-Type: ' . $mime,\n                    'Content-Disposition: attachment; ' . $filename,\n                    'Content-Transfer-Encoding: binary',\n                    'Content-Length: ' . $file['size'],\n                    'Accept-Ranges: none',\n                    'Connection: close'\n                )\n            );\n            return $result;\n        }\n    }\n\n    /**\n     * Required to output file in browser when volume URL is not set\n     * Return array contains opened file pointer, root itself and required headers\n     *\n     * @param  array  command arguments\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function file($args)\n    {\n        $target = $args['target'];\n        $download = !empty($args['download']);\n        $onetime = !empty($args['onetime']);\n        //$h304     = 'HTTP/1.1 304 Not Modified';\n        //$h403     = 'HTTP/1.0 403 Access Denied';\n        $h404 = 'HTTP/1.0 404 Not Found';\n        $a404 = array('error' => 'File not found', 'header' => $h404, 'raw' => true);\n\n        if ($onetime) {\n            $volume = null;\n            $tmpdir = elFinder::$commonTempPath;\n            if (!$tmpdir || !is_file($tmpf = $tmpdir . DIRECTORY_SEPARATOR . 'ELF' . $target)) {\n                return $a404;\n            }\n            $GLOBALS['elFinderTempFiles'][$tmpf] = true;\n            if ($file = json_decode(file_get_contents($tmpf), true)) {\n                $src = base64_decode($file['file']);\n                if (!is_file($src) || !($fp = fopen($src, 'rb'))) {\n                    return $a404;\n                }\n                if (strpos($src, $tmpdir) === 0) {\n                    $GLOBALS['elFinderTempFiles'][$src] = true;\n                }\n                unset($file['file']);\n                $file['read'] = true;\n                $file['size'] = filesize($src);\n            } else {\n                return $a404;\n            }\n        } else {\n            if (($volume = $this->volume($target)) == false) {\n                return $a404;\n            }\n\n            if (($file = $volume->file($target)) == false) {\n                return $a404;\n            }\n\n            if (!$file['read']) {\n                return $a404;\n            }\n\n            if (($fp = $volume->open($target)) == false) {\n                return $a404;\n            }\n        }\n\n        // check aborted by user\n        elFinder::checkAborted();\n\n        // allow change MIME type by 'file.pre' callback functions\n        $mime = isset($args['mime']) ? $args['mime'] : $file['mime'];\n        if ($download || $onetime) {\n            $disp = 'attachment';\n        } else {\n            $dispInlineRegex = $volume->getOption('dispInlineRegex');\n            $inlineRegex = false;\n            if ($dispInlineRegex) {\n                $inlineRegex = '#' . str_replace('#', '\\\\#', $dispInlineRegex) . '#';\n                try {\n                    preg_match($inlineRegex, '');\n                } catch (Exception $e) {\n                    $inlineRegex = false;\n                }\n            }\n            if (!$inlineRegex) {\n                $inlineRegex = '#^(?:(?:image|text)|application/x-shockwave-flash$)#';\n            }\n            $disp = preg_match($inlineRegex, $mime) ? 'inline' : 'attachment';\n        }\n\n        $filenameEncoded = rawurlencode($file['name']);\n        if (strpos($filenameEncoded, '%') === false) { // ASCII only\n            $filename = 'filename=\"' . $file['name'] . '\"';\n        } else {\n            $ua = $_SERVER['HTTP_USER_AGENT'];\n            if (preg_match('/MSIE [4-8]/', $ua)) { // IE < 9 do not support RFC 6266 (RFC 2231/RFC 5987)\n                $filename = 'filename=\"' . $filenameEncoded . '\"';\n            } elseif (strpos($ua, 'Chrome') === false && strpos($ua, 'Safari') !== false && preg_match('#Version/[3-5]#', $ua)) { // Safari < 6\n                $filename = 'filename=\"' . str_replace('\"', '', $file['name']) . '\"';\n            } else { // RFC 6266 (RFC 2231/RFC 5987)\n                $filename = 'filename*=UTF-8\\'\\'' . $filenameEncoded;\n            }\n        }\n\n        if ($args['cpath'] && $args['reqid']) {\n            setcookie('elfdl' . $args['reqid'], '1', 0, $args['cpath']);\n        }\n\n        $result = array(\n            'volume' => $volume,\n            'pointer' => $fp,\n            'info' => $file,\n            'header' => array(\n                'Content-Type: ' . $mime,\n                'Content-Disposition: ' . $disp . '; ' . $filename,\n                'Content-Transfer-Encoding: binary',\n                'Content-Length: ' . $file['size'],\n                'Last-Modified: ' . gmdate('D, d M Y H:i:s T', $file['ts']),\n                'Connection: close'\n            )\n        );\n\n        if (!$onetime) {\n            // add cache control headers\n            if ($cacheHeaders = $volume->getOption('cacheHeaders')) {\n                $result['header'] = array_merge($result['header'], $cacheHeaders);\n            }\n\n            // check 'xsendfile'\n            $xsendfile = $volume->getOption('xsendfile');\n            $path = null;\n            if ($xsendfile) {\n                $info = stream_get_meta_data($fp);\n                if ($path = empty($info['uri']) ? null : $info['uri']) {\n                    $basePath = rtrim($volume->getOption('xsendfilePath'), DIRECTORY_SEPARATOR);\n                    if ($basePath) {\n                        $root = rtrim($volume->getRootPath(), DIRECTORY_SEPARATOR);\n                        if (strpos($path, $root) === 0) {\n                            $path = $basePath . substr($path, strlen($root));\n                        } else {\n                            $path = null;\n                        }\n                    }\n                }\n            }\n            if ($path) {\n                $result['header'][] = $xsendfile . ': ' . $path;\n                $result['info']['xsendfile'] = $xsendfile;\n            }\n        }\n\n        // add \"Content-Location\" if file has url data\n        if (isset($file['url']) && $file['url'] && $file['url'] != 1) {\n            $result['header'][] = 'Content-Location: ' . $file['url'];\n        }\n        return $result;\n    }\n\n    /**\n     * Count total files size\n     *\n     * @param  array  command arguments\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function size($args)\n    {\n        $size = 0;\n        $files = 0;\n        $dirs = 0;\n        $itemCount = true;\n        $sizes = array();\n\n        foreach ($args['targets'] as $target) {\n            elFinder::checkAborted();\n            if (($volume = $this->volume($target)) == false\n                || ($file = $volume->file($target)) == false\n                || !$file['read']) {\n                return array('error' => $this->error(self::ERROR_OPEN, '#' . $target));\n            }\n\n            $volRes = $volume->size($target);\n            if (is_array($volRes)) {\n                $sizeInfo = array('size' => 0, 'fileCnt' => 0, 'dirCnt' => 0);\n                if (!empty($volRes['size'])) {\n                    $sizeInfo['size'] = $volRes['size'];\n                    $size += $volRes['size'];\n                }\n                if (!empty($volRes['files'])) {\n                    $sizeInfo['fileCnt'] = $volRes['files'];\n                }\n                if (!empty($volRes['dirs'])) {\n                    $sizeInfo['dirCnt'] = $volRes['dirs'];\n                }\n                if ($itemCount) {\n                    $files += $sizeInfo['fileCnt'];\n                    $dirs += $sizeInfo['dirCnt'];\n                }\n                $sizes[$target] = $sizeInfo;\n            } else if (is_numeric($volRes)) {\n                $size += $volRes;\n                $files = $dirs = 'unknown';\n                $itemCount = false;\n            }\n        }\n        return array('size' => $size, 'fileCnt' => $files, 'dirCnt' => $dirs, 'sizes' => $sizes);\n    }\n\n    /**\n     * Create directory\n     *\n     * @param  array  command arguments\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function mkdir($args)\n    {\n        $target = $args['target'];\n        $name = $args['name'];\n        $dirs = $args['dirs'];\n        if ($name === '' && !$dirs) {\n            return array('error' => $this->error(self::ERROR_INV_PARAMS, 'mkdir'));\n        }\n\n        if (($volume = $this->volume($target)) == false) {\n            return array('error' => $this->error(self::ERROR_MKDIR, $name, self::ERROR_TRGDIR_NOT_FOUND, '#' . $target));\n        }\n        if ($dirs) {\n            sort($dirs);\n            $reset = null;\n            $mkdirs = array();\n            foreach ($dirs as $dir) {\n                $tgt =& $mkdirs;\n                $_names = explode('/', trim($dir, '/'));\n                foreach ($_names as $_key => $_name) {\n                    if (!isset($tgt[$_name])) {\n                        $tgt[$_name] = array();\n                    }\n                    $tgt =& $tgt[$_name];\n                }\n                $tgt =& $reset;\n            }\n            $res = $this->ensureDirsRecursively($volume, $target, $mkdirs);\n            $ret = array(\n                'added' => $res['stats'],\n                'hashes' => $res['hashes']\n            );\n            if ($res['error']) {\n                $ret['warning'] = $this->error(self::ERROR_MKDIR, $res['error'][0], $volume->error());\n            }\n            return $ret;\n        } else {\n            return ($dir = $volume->mkdir($target, $name)) == false\n                ? array('error' => $this->error(self::ERROR_MKDIR, $name, $volume->error()))\n                : array('added' => array($dir));\n        }\n    }\n\n    /**\n     * Create empty file\n     *\n     * @param  array  command arguments\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function mkfile($args)\n    {\n        $target = $args['target'];\n        $name = $args['name'];\n\n        if (($volume = $this->volume($target)) == false) {\n            return array('error' => $this->error(self::ERROR_MKFILE, $name, self::ERROR_TRGDIR_NOT_FOUND, '#' . $target));\n        }\n\n        return ($file = $volume->mkfile($target, $args['name'])) == false\n            ? array('error' => $this->error(self::ERROR_MKFILE, $name, $volume->error()))\n            : array('added' => array($file));\n    }\n\n    /**\n     * Rename file, Accept multiple items >= API 2.1031\n     *\n     * @param  array $args\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     * @author Naoki Sawada\n     */\n    protected function rename($args)\n    {\n        $target = $args['target'];\n        $name = $args['name'];\n        $query = (strpos($args['q'], '*') !== false) ? $args['q'] : '';\n        $targets = $args['targets'];\n        $rms = array();\n        $notfounds = array();\n        $locked = array();\n        $errs = array();\n        $files = array();\n        $removed = array();\n        $res = array();\n        $type = 'normal';\n\n        if (!($volume = $this->volume($target))) {\n            return array('error' => $this->error(self::ERROR_RENAME, '#' . $target, self::ERROR_FILE_NOT_FOUND));\n        }\n\n        if ($targets) {\n            array_unshift($targets, $target);\n            foreach ($targets as $h) {\n                if ($rm = $volume->file($h)) {\n                    if ($this->itemLocked($h)) {\n                        $locked[] = $rm['name'];\n                    } else {\n                        $rm['realpath'] = $volume->realpath($h);\n                        $rms[] = $rm;\n                    }\n                } else {\n                    $notfounds[] = '#' . $h;\n                }\n            }\n            if (!$rms) {\n                $res['error'] = array();\n                if ($notfounds) {\n                    $res['error'] = array(self::ERROR_RENAME, join(', ', $notfounds), self::ERROR_FILE_NOT_FOUND);\n                }\n                if ($locked) {\n                    array_push($res['error'], self::ERROR_LOCKED, join(', ', $locked));\n                }\n                return $res;\n            }\n\n            $res['warning'] = array();\n            if ($notfounds) {\n                array_push($res['warning'], self::ERROR_RENAME, join(', ', $notfounds), self::ERROR_FILE_NOT_FOUND);\n            }\n            if ($locked) {\n                array_push($res['warning'], self::ERROR_LOCKED, join(', ', $locked));\n            }\n\n            if ($query) {\n                // batch rename\n                $splits = elFinder::splitFileExtention($query);\n                if ($splits[1] && $splits[0] === '*') {\n                    $type = 'extention';\n                    $name = $splits[1];\n                } else if (strlen($splits[0]) > 1) {\n                    if (substr($splits[0], -1) === '*') {\n                        $type = 'prefix';\n                        $name = substr($splits[0], 0, strlen($splits[0]) - 1);\n                    } else if (substr($splits[0], 0, 1) === '*') {\n                        $type = 'suffix';\n                        $name = substr($splits[0], 1);\n                    }\n                }\n                if ($type !== 'normal') {\n                    if (!empty($this->listeners['rename.pre'])) {\n                        $_args = array('name' => $name);\n                        foreach ($this->listeners['rename.pre'] as $handler) {\n                            $_res = call_user_func_array($handler, array('rename', &$_args, $this, $volume));\n                            if (!empty($_res['preventexec'])) {\n                                break;\n                            }\n                        }\n                        $name = $_args['name'];\n                    }\n                }\n            }\n            foreach ($rms as $rm) {\n                if ($type === 'normal') {\n                    $rname = $volume->uniqueName($volume->realpath($rm['phash']), $name, '', false);\n                } else {\n                    $rname = $name;\n                    if ($type === 'extention') {\n                        $splits = elFinder::splitFileExtention($rm['name']);\n                        $rname = $splits[0] . '.' . $name;\n                    } else if ($type === 'prefix') {\n                        $rname = $name . $rm['name'];\n                    } else if ($type === 'suffix') {\n                        $splits = elFinder::splitFileExtention($rm['name']);\n                        $rname = $splits[0] . $name . ($splits[1] ? ('.' . $splits[1]) : '');\n                    }\n                    $rname = $volume->uniqueName($volume->realpath($rm['phash']), $rname, '', true);\n                }\n                if ($file = $volume->rename($rm['hash'], $rname)) {\n                    $files[] = $file;\n                    $removed[] = $rm;\n                } else {\n                    $errs[] = $rm['name'];\n                }\n            }\n\n            if (!$files) {\n                $res['error'] = $this->error(self::ERROR_RENAME, join(', ', $errs), $volume->error());\n                if (!$res['warning']) {\n                    unset($res['warning']);\n                }\n                return $res;\n            }\n            if ($errs) {\n                array_push($res['warning'], self::ERROR_RENAME, join(', ', $errs), $volume->error());\n            }\n            if (!$res['warning']) {\n                unset($res['warning']);\n            }\n            $res['added'] = $files;\n            $res['removed'] = $removed;\n            return $res;\n        } else {\n            if (!($rm = $volume->file($target))) {\n                return array('error' => $this->error(self::ERROR_RENAME, '#' . $target, self::ERROR_FILE_NOT_FOUND));\n            }\n            if ($this->itemLocked($target)) {\n                return array('error' => $this->error(self::ERROR_LOCKED, $rm['name']));\n            }\n            $rm['realpath'] = $volume->realpath($target);\n\n            return ($file = $volume->rename($target, $name)) == false\n                ? array('error' => $this->error(self::ERROR_RENAME, $rm['name'], $volume->error()))\n                : array('added' => array($file), 'removed' => array($rm));\n        }\n    }\n\n    /**\n     * Duplicate file - create copy with \"copy %d\" suffix\n     *\n     * @param array $args command arguments\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function duplicate($args)\n    {\n        $targets = is_array($args['targets']) ? $args['targets'] : array();\n        $result = array();\n        $suffix = empty($args['suffix']) ? 'copy' : $args['suffix'];\n\n        $this->itemLock($targets);\n\n        foreach ($targets as $target) {\n            elFinder::checkAborted();\n\n            if (($volume = $this->volume($target)) == false\n                || ($src = $volume->file($target)) == false) {\n                $result['warning'] = $this->error(self::ERROR_COPY, '#' . $target, self::ERROR_FILE_NOT_FOUND);\n                break;\n            }\n\n            if (($file = $volume->duplicate($target, $suffix)) == false) {\n                $result['warning'] = $this->error($volume->error());\n                break;\n            }\n        }\n\n        return $result;\n    }\n\n    /**\n     * Remove dirs/files\n     *\n     * @param array  command arguments\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function rm($args)\n    {\n        $targets = is_array($args['targets']) ? $args['targets'] : array();\n        $result = array('removed' => array());\n\n        foreach ($targets as $target) {\n            elFinder::checkAborted();\n\n            if (($volume = $this->volume($target)) == false) {\n                $result['warning'] = $this->error(self::ERROR_RM, '#' . $target, self::ERROR_FILE_NOT_FOUND);\n                break;\n            }\n\n            if ($this->itemLocked($target)) {\n                $rm = $volume->file($target);\n                $result['warning'] = $this->error(self::ERROR_LOCKED, $rm['name']);\n                break;\n            }\n\n            if (!$volume->rm($target)) {\n                $result['warning'] = $this->error($volume->error());\n                break;\n            }\n        }\n\n        return $result;\n    }\n\n    /**\n     * Return has subdirs\n     *\n     * @param  array  command arguments\n     *\n     * @return array\n     * @author Dmitry Naoki Sawada\n     **/\n    protected function subdirs($args)\n    {\n\n        $result = array('subdirs' => array());\n        $targets = $args['targets'];\n\n        foreach ($targets as $target) {\n            if (($volume = $this->volume($target)) !== false) {\n                $result['subdirs'][$target] = $volume->subdirs($target) ? 1 : 0;\n            }\n        }\n        return $result;\n    }\n\n    /**\n     * Gateway for custom contents editor\n     *\n     * @param  array $args command arguments\n     *\n     * @return array\n     * @author Naoki Sawada\n     */\n    protected function editor($args = array())\n    {\n        /* @var elFinderEditor $editor */\n        $name = $args['name'];\n        if (is_array($name)) {\n            $res = array();\n            foreach ($name as $c) {\n                $class = 'elFinderEditor' . $c;\n                if (class_exists($class)) {\n                    $editor = new $class($this, $args['args']);\n                    $res[$c] = $editor->enabled();\n                } else {\n                    $res[$c] = 0;\n                }\n            }\n            return $res;\n        } else {\n            $class = 'elFinderEditor' . $name;\n            $method = '';\n            if (class_exists($class)) {\n                $editor = new $class($this, $args['args']);\n                $method = $args['method'];\n                if ($editor->isAllowedMethod($method) && method_exists($editor, $method)) {\n                    return $editor->$method();\n                }\n            }\n            return array('error', $this->error(self::ERROR_UNKNOWN_CMD, 'editor.' . $name . '.' . $method));\n        }\n    }\n\n    /**\n     * Abort current request and make flag file to running check\n     *\n     * @param array $args\n     *\n     * @return void\n     */\n    protected function abort($args = array())\n    {\n        if (!elFinder::$connectionFlagsPath || $_SERVER['REQUEST_METHOD'] === 'HEAD') {\n            return;\n        }\n        $flagFile = elFinder::$connectionFlagsPath . DIRECTORY_SEPARATOR . 'elfreq%s';\n        if (!empty($args['makeFile'])) {\n            self::$abortCheckFile = sprintf($flagFile, $args['makeFile']);\n            touch(self::$abortCheckFile);\n            $GLOBALS['elFinderTempFiles'][self::$abortCheckFile] = true;\n            return;\n        }\n\n        $file = !empty($args['id']) ? sprintf($flagFile, $args['id']) : self::$abortCheckFile;\n        $file && is_file($file) && unlink($file);\n    }\n\n    /**\n     * Get remote contents\n     *\n     * @param  string   $url          target url\n     * @param  int      $timeout      timeout (sec)\n     * @param  int      $redirect_max redirect max count\n     * @param  string   $ua\n     * @param  resource $fp\n     *\n     * @return string, resource or bool(false)\n     * @retval  string contents\n     * @retval  resource conttents\n     * @rettval false  error\n     * @author  Naoki Sawada\n     **/\n    protected function get_remote_contents(&$url, $timeout = 30, $redirect_max = 5, $ua = 'Mozilla/5.0', $fp = null)\n    {\n        if (preg_match('~^(?:ht|f)tps?://[-_.!\\~*\\'()a-z0-9;/?:\\@&=+\\$,%#\\*\\[\\]]+~i', $url)) {\n            $info = parse_url($url);\n            $host = trim(strtolower($info['host']), '.');\n            // do not support IPv6 address\n            if (preg_match('/^\\[.*\\]$/', $host)) {\n                return false;\n            }\n            // do not support non dot host\n            if (strpos($host, '.') === false) {\n                return false;\n            }\n            // do not support URL-encoded host\n            if (strpos($host, '%') !== false) {\n                return false;\n            }\n            // disallow including \"localhost\" and \"localdomain\"\n            if (preg_match('/\\b(?:localhost|localdomain)\\b/', $host)) {\n                return false;\n            }\n            // check IPv4 local loopback, private network and link local\n            if (preg_match('/^0x[0-9a-f]+|[0-9]+(?:\\.(?:0x[0-9a-f]+|[0-9]+)){1,3}$/', $host, $m)) {\n                $long = (int)sprintf('%u', ip2long($host));\n                if (!$long) {\n                    return false;\n                }\n                $local = (int)sprintf('%u', ip2long('127.255.255.255')) >> 24;\n                $prv1 = (int)sprintf('%u', ip2long('10.255.255.255')) >> 24;\n                $prv2 = (int)sprintf('%u', ip2long('172.31.255.255')) >> 20;\n                $prv3 = (int)sprintf('%u', ip2long('192.168.255.255')) >> 16;\n                $link = (int)sprintf('%u', ip2long('169.254.255.255')) >> 16;\n\n                if ($long >> 24 === $local || $long >> 24 === $prv1 || $long >> 20 === $prv2 || $long >> 16 === $prv3 || $long >> 16 === $link) {\n                    return false;\n                }\n            }\n            // dose not support 'user' and 'pass' for security reasons\n            $url = $info['scheme'].'://'.$host.(!empty($info['port'])? (':'.$info['port']) : '').$info['path'].(!empty($info['query'])? ('?'.$info['query']) : '').(!empty($info['fragment'])? ('#'.$info['fragment']) : '');\n            // check by URL upload filter\n            if ($this->urlUploadFilter && is_callable($this->urlUploadFilter)) {\n                if (!call_user_func_array($this->urlUploadFilter, array($url, $this))) {\n                    return false;\n                }\n            }\n            $method = (function_exists('curl_exec') && !ini_get('safe_mode') && !ini_get('open_basedir')) ? 'curl_get_contents' : 'fsock_get_contents';\n            return $this->$method($url, $timeout, $redirect_max, $ua, $fp);\n        }\n        return false;\n    }\n\n    /**\n     * Get remote contents with cURL\n     *\n     * @param  string   $url          target url\n     * @param  int      $timeout      timeout (sec)\n     * @param  int      $redirect_max redirect max count\n     * @param  string   $ua\n     * @param  resource $outfp\n     *\n     * @return string, resource or bool(false)\n     * @retval string contents\n     * @retval resource conttents\n     * @retval false  error\n     * @author Naoki Sawada\n     **/\n    protected function curl_get_contents(&$url, $timeout, $redirect_max, $ua, $outfp)\n    {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $url);\n        curl_setopt($ch, CURLOPT_HEADER, false);\n        if ($outfp) {\n            curl_setopt($ch, CURLOPT_FILE, $outfp);\n        } else {\n            curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n            curl_setopt($ch, CURLOPT_BINARYTRANSFER, true);\n        }\n        curl_setopt($ch, CURLOPT_LOW_SPEED_LIMIT, 1);\n        curl_setopt($ch, CURLOPT_LOW_SPEED_TIME, $timeout);\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);\n        curl_setopt($ch, CURLOPT_MAXREDIRS, $redirect_max);\n        curl_setopt($ch, CURLOPT_USERAGENT, $ua);\n        $result = curl_exec($ch);\n        $url = curl_getinfo($ch, CURLINFO_EFFECTIVE_URL);\n        curl_close($ch);\n        return $outfp ? $outfp : $result;\n    }\n\n    /**\n     * Get remote contents with fsockopen()\n     *\n     * @param  string   $url          url\n     * @param  int      $timeout      timeout (sec)\n     * @param  int      $redirect_max redirect max count\n     * @param  string   $ua\n     * @param  resource $outfp\n     *\n     * @return string, resource or bool(false)\n     * @retval string contents\n     * @retval resource conttents\n     * @retval false  error\n     * @throws elFinderAbortException\n     * @author Naoki Sawada\n     */\n    protected function fsock_get_contents(&$url, $timeout, $redirect_max, $ua, $outfp)\n    {\n        $connect_timeout = 3;\n        $connect_try = 3;\n        $method = 'GET';\n        $readsize = 4096;\n        $ssl = '';\n\n        $getSize = null;\n        $headers = '';\n\n        $arr = parse_url($url);\n        if (!$arr) {\n            // Bad request\n            return false;\n        }\n        if ($arr['scheme'] === 'https') {\n            $ssl = 'ssl://';\n        }\n\n        // query\n        $arr['query'] = isset($arr['query']) ? '?' . $arr['query'] : '';\n        // port\n        $port = isset($arr['port']) ? $arr['port'] : '';\n        $arr['port'] = $port ? $port : ($ssl ? 443 : 80);\n\n        $url_base = $arr['scheme'] . '://' . $arr['host'] . ($port ? (':' . $port) : '');\n        $url_path = isset($arr['path']) ? $arr['path'] : '/';\n        $uri = $url_path . $arr['query'];\n\n        $query = $method . ' ' . $uri . \" HTTP/1.0\\r\\n\";\n        $query .= \"Host: \" . $arr['host'] . \"\\r\\n\";\n        $query .= \"Accept: */*\\r\\n\";\n        $query .= \"Connection: close\\r\\n\";\n        if (!empty($ua)) $query .= \"User-Agent: \" . $ua . \"\\r\\n\";\n        if (!is_null($getSize)) $query .= 'Range: bytes=0-' . ($getSize - 1) . \"\\r\\n\";\n\n        $query .= $headers;\n\n        $query .= \"\\r\\n\";\n\n        $fp = $connect_try_count = 0;\n        while (!$fp && $connect_try_count < $connect_try) {\n\n            $errno = 0;\n            $errstr = \"\";\n            $fp = fsockopen(\n                $ssl . $arr['host'],\n                $arr['port'],\n                $errno, $errstr, $connect_timeout);\n            if ($fp) break;\n            $connect_try_count++;\n            if (connection_aborted()) {\n                throw new elFinderAbortException();\n            }\n            sleep(1); // wait 1sec\n        }\n\n        if (!$fp) {\n            return false;\n        }\n\n        $fwrite = 0;\n        for ($written = 0; $written < strlen($query); $written += $fwrite) {\n            $fwrite = fwrite($fp, substr($query, $written));\n            if (!$fwrite) {\n                break;\n            }\n        }\n\n        if ($timeout) {\n            socket_set_timeout($fp, $timeout);\n        }\n\n        $_response = '';\n        $header = '';\n        while ($_response !== \"\\r\\n\") {\n            $_response = fgets($fp, $readsize);\n            $header .= $_response;\n        };\n\n        $rccd = array_pad(explode(' ', $header, 2), 2, ''); // array('HTTP/1.1','200')\n        $rc = (int)$rccd[1];\n\n        $ret = false;\n        // Redirect\n        switch ($rc) {\n            case 307: // Temporary Redirect\n            case 303: // See Other\n            case 302: // Moved Temporarily\n            case 301: // Moved Permanently\n                $matches = array();\n                if (preg_match('/^Location: (.+?)(#.+)?$/im', $header, $matches) && --$redirect_max > 0) {\n                    $_url = $url;\n                    $url = trim($matches[1]);\n                    if (!preg_match('/^https?:\\//', $url)) { // no scheme\n                        if ($url{0} != '/') { // Relative path\n                            // to Absolute path\n                            $url = substr($url_path, 0, strrpos($url_path, '/')) . '/' . $url;\n                        }\n                        // add sheme,host\n                        $url = $url_base . $url;\n                    }\n                    if ($_url === $url) {\n                        sleep(1);\n                    }\n                    fclose($fp);\n                    return $this->fsock_get_contents($url, $timeout, $redirect_max, $ua, $outfp);\n                }\n                break;\n            case 200:\n                $ret = true;\n        }\n        if (!$ret) {\n            fclose($fp);\n            return false;\n        }\n\n        $body = '';\n        if (!$outfp) {\n            $outfp = fopen('php://temp', 'rwb');\n            $body = true;\n        }\n        while (fwrite($outfp, fread($fp, $readsize))) {\n            if ($timeout) {\n                $_status = socket_get_status($fp);\n                if ($_status['timed_out']) {\n                    fclose($outfp);\n                    fclose($fp);\n                    return false; // Request Time-out\n                }\n            }\n        }\n        if ($body) {\n            rewind($outfp);\n            $body = stream_get_contents($outfp);\n            fclose($outfp);\n            $outfp = null;\n        }\n\n        fclose($fp);\n\n        return $outfp ? $outfp : $body; // Data\n    }\n\n    /**\n     * Parse Data URI scheme\n     *\n     * @param  string $str\n     * @param  array  $extTable\n     * @param  array  $args\n     *\n     * @return array\n     * @author Naoki Sawada\n     */\n    protected function parse_data_scheme($str, $extTable, $args = null)\n    {\n        $data = $name = $mime = '';\n        // Scheme 'data://' require `allow_url_fopen` and `allow_url_include`\n        if ($fp = fopen('data://' . substr($str, 5), 'rb')) {\n            if ($data = stream_get_contents($fp)) {\n                $meta = stream_get_meta_data($fp);\n                $mime = $meta['mediatype'];\n            }\n            fclose($fp);\n        } else if (preg_match('~^data:(.+?/.+?)?(?:;charset=.+?)?;base64,~', substr($str, 0, 128), $m)) {\n            $data = base64_decode(substr($str, strlen($m[0])));\n            if ($m[1]) {\n                $mime = $m[1];\n            }\n        }\n        if ($data) {\n            $ext = ($mime && isset($extTable[$mime])) ? '.' . $extTable[$mime] : '';\n            // Set name if name eq 'image.png' and $args has 'name' array, e.g. clipboard data\n            if (is_array($args['name']) && isset($args['name'][0])) {\n                $name = $args['name'][0];\n                if ($ext) {\n                    $name = preg_replace('/\\.[^.]*$/', '', $name);\n                }\n            } else {\n                $name = substr(md5($data), 0, 8);\n            }\n            $name .= $ext;\n        } else {\n            $data = $name = '';\n        }\n        return array($data, $name);\n    }\n\n    /**\n     * Detect file MIME Type by local path\n     *\n     * @param  string $path Local path\n     *\n     * @return string file MIME Type\n     * @author Naoki Sawada\n     */\n    protected function detectMimeType($path)\n    {\n        static $type, $finfo;\n        if (!$type) {\n            if (class_exists('finfo', false)) {\n                $tmpFileInfo = explode(';', finfo_file(finfo_open(FILEINFO_MIME), __FILE__));\n            } else {\n                $tmpFileInfo = false;\n            }\n            $regexp = '/text\\/x\\-(php|c\\+\\+)/';\n            if ($tmpFileInfo && preg_match($regexp, array_shift($tmpFileInfo))) {\n                $type = 'finfo';\n                $finfo = finfo_open(FILEINFO_MIME);\n            } elseif (function_exists('mime_content_type')\n                && preg_match($regexp, array_shift(explode(';', mime_content_type(__FILE__))))) {\n                $type = 'mime_content_type';\n            } elseif (function_exists('getimagesize')) {\n                $type = 'getimagesize';\n            } else {\n                $type = 'none';\n            }\n        }\n\n        $mime = '';\n        if ($type === 'finfo') {\n            $mime = finfo_file($finfo, $path);\n        } elseif ($type === 'mime_content_type') {\n            $mime = mime_content_type($path);\n        } elseif ($type === 'getimagesize') {\n            if ($img = getimagesize($path)) {\n                $mime = $img['mime'];\n            }\n        }\n\n        if ($mime) {\n            $mime = explode(';', $mime);\n            $mime = trim($mime[0]);\n\n            if (in_array($mime, array('application/x-empty', 'inode/x-empty'))) {\n                // finfo return this mime for empty files\n                $mime = 'text/plain';\n            } elseif ($mime == 'application/x-zip') {\n                // http://elrte.org/redmine/issues/163\n                $mime = 'application/zip';\n            }\n        }\n\n        return $mime ? $mime : 'unknown';\n    }\n\n    /**\n     * Detect file type extension by local path\n     *\n     * @param  object $volume elFinderVolumeDriver instance\n     * @param  string $path   Local path\n     * @param  string $name   Filename to save\n     *\n     * @return string file type extension with dot\n     * @author Naoki Sawada\n     */\n    protected function detectFileExtension($volume, $path, $name)\n    {\n        $mime = $this->detectMimeType($path);\n        if ($mime === 'unknown') {\n            $mime = 'application/octet-stream';\n        }\n        $ext = $volume->getExtentionByMime($volume->mimeTypeNormalize($mime, $name));\n        return $ext ? ('.' . $ext) : '';\n    }\n\n    /**\n     * Get temporary directory path\n     *\n     * @param  string $volumeTempPath\n     *\n     * @return string\n     * @author Naoki Sawada\n     */\n    private function getTempDir($volumeTempPath = null)\n    {\n        $testDirs = array();\n        if ($this->uploadTempPath) {\n            $testDirs[] = rtrim(realpath($this->uploadTempPath), DIRECTORY_SEPARATOR);\n        }\n        if ($volumeTempPath) {\n            $testDirs[] = rtrim(realpath($volumeTempPath), DIRECTORY_SEPARATOR);\n        }\n        if (elFinder::$commonTempPath) {\n            $testDirs[] = elFinder::$commonTempPath;\n        }\n        $tempDir = '';\n        foreach ($testDirs as $testDir) {\n            if (!$testDir || !is_dir($testDir)) continue;\n            if (is_writable($testDir)) {\n                $tempDir = $testDir;\n                $gc = time() - 3600;\n                foreach (glob($tempDir . DIRECTORY_SEPARATOR . 'ELF*') as $cf) {\n                    if (filemtime($cf) < $gc) {\n                        unlink($cf);\n                    }\n                }\n                break;\n            }\n        }\n        return $tempDir;\n    }\n\n    /**\n     * chmod\n     *\n     * @param array  command arguments\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author David Bartle\n     */\n    protected function chmod($args)\n    {\n        $targets = $args['targets'];\n        $mode = intval((string)$args['mode'], 8);\n\n        if (!is_array($targets)) {\n            $targets = array($targets);\n        }\n\n        $result = array();\n\n        if (($volume = $this->volume($targets[0])) == false) {\n            $result['error'] = $this->error(self::ERROR_CONF_NO_VOL);\n            return $result;\n        }\n\n        $this->itemLock($targets);\n\n        $files = array();\n        $errors = array();\n        foreach ($targets as $target) {\n            elFinder::checkAborted();\n\n            $file = $volume->chmod($target, $mode);\n            if ($file) {\n                $files = array_merge($files, is_array($file) ? $file : array($file));\n            } else {\n                $errors = array_merge($errors, $volume->error());\n            }\n        }\n\n        if ($files) {\n            $result['changed'] = $files;\n            if ($errors) {\n                $result['warning'] = $this->error($errors);\n            }\n        } else {\n            $result['error'] = $this->error($errors);\n        }\n\n        return $result;\n    }\n\n    /**\n     * Check chunked upload files\n     *\n     * @param string $tmpname uploaded temporary file path\n     * @param string $chunk   uploaded chunk file name\n     * @param string $cid     uploaded chunked file id\n     * @param string $tempDir temporary dirctroy path\n     * @param null   $volume\n     *\n     * @return array|null\n     * @throws elFinderAbortException\n     * @author Naoki Sawada\n     */\n    private function checkChunkedFile($tmpname, $chunk, $cid, $tempDir, $volume = null)\n    {\n        /* @var elFinderVolumeDriver $volume */\n        if (preg_match('/^(.+)(\\.\\d+_(\\d+))\\.part$/s', $chunk, $m)) {\n            $fname = $m[1];\n            $encname = md5($cid . '_' . $fname);\n            $base = $tempDir . DIRECTORY_SEPARATOR . 'ELF' . $encname;\n            $clast = intval($m[3]);\n            if (is_null($tmpname)) {\n                ignore_user_abort(true);\n                // chunked file upload fail\n                foreach (glob($base . '*') as $cf) {\n                    unlink($cf);\n                }\n                ignore_user_abort(false);\n                return null;\n            }\n\n            $range = isset($_POST['range']) ? trim($_POST['range']) : '';\n            if ($range && preg_match('/^(\\d+),(\\d+),(\\d+)$/', $range, $ranges)) {\n                $start = $ranges[1];\n                $len = $ranges[2];\n                $size = $ranges[3];\n                $tmp = $base . '.part';\n                $csize = filesize($tmpname);\n\n                $tmpExists = is_file($tmp);\n                if (!$tmpExists) {\n                    // check upload max size\n                    $uploadMaxSize = $volume ? $volume->getUploadMaxSize() : 0;\n                    if ($uploadMaxSize > 0 && $size > $uploadMaxSize) {\n                        return array(self::ERROR_UPLOAD_FILE_SIZE, false);\n                    }\n                    // make temp file\n                    $ok = false;\n                    if ($fp = fopen($tmp, 'wb')) {\n                        flock($fp, LOCK_EX);\n                        $ok = ftruncate($fp, $size);\n                        flock($fp, LOCK_UN);\n                        fclose($fp);\n                        touch($base);\n                    }\n                    if (!$ok) {\n                        unlink($tmp);\n                        return array(self::ERROR_UPLOAD_TEMP, false);\n                    }\n                } else {\n                    // wait until makeing temp file (for anothor session)\n                    $cnt = 1200; // Time limit 120 sec\n                    while (!is_file($base) && --$cnt) {\n                        usleep(100000); // wait 100ms\n                    }\n                    if (!$cnt) {\n                        return array(self::ERROR_UPLOAD_TEMP, false);\n                    }\n                }\n\n                // check size info\n                if ($len != $csize || $start + $len > $size || ($tmpExists && $size != filesize($tmp))) {\n                    return array(self::ERROR_UPLOAD_TEMP, false);\n                }\n\n                // write chunk data\n                $src = fopen($tmpname, 'rb');\n                $fp = fopen($tmp, 'cb');\n                fseek($fp, $start);\n                $writelen = stream_copy_to_stream($src, $fp, $len);\n                fclose($fp);\n                fclose($src);\n\n                try {\n                    // to check connection is aborted\n                    elFinder::checkAborted();\n                } catch (elFinderAbortException $e) {\n                    unlink($tmpname);\n                    is_file($tmp) && unlink($tmp);\n                    is_file($base) && unlink($base);\n                    throw $e;\n                }\n\n                if ($writelen != $len) {\n                    return array(self::ERROR_UPLOAD_TEMP, false);\n                }\n\n                // write counts\n                file_put_contents($base, \"\\0\", FILE_APPEND | LOCK_EX);\n\n                if (filesize($base) >= $clast + 1) {\n                    // Completion\n                    unlink($base);\n                    return array($tmp, $fname);\n                }\n            } else {\n                // old way\n                $part = $base . $m[2];\n                if (move_uploaded_file($tmpname, $part)) {\n                    chmod($part, 0600);\n                    if ($clast < count(glob($base . '*'))) {\n                        $parts = array();\n                        for ($i = 0; $i <= $clast; $i++) {\n                            $name = $base . '.' . $i . '_' . $clast;\n                            if (is_readable($name)) {\n                                $parts[] = $name;\n                            } else {\n                                $parts = null;\n                                break;\n                            }\n                        }\n                        if ($parts) {\n                            if (!is_file($base)) {\n                                touch($base);\n                                if ($resfile = tempnam($tempDir, 'ELF')) {\n                                    $target = fopen($resfile, 'wb');\n                                    foreach ($parts as $f) {\n                                        $fp = fopen($f, 'rb');\n                                        while (!feof($fp)) {\n                                            fwrite($target, fread($fp, 8192));\n                                        }\n                                        fclose($fp);\n                                        unlink($f);\n                                    }\n                                    fclose($target);\n                                    unlink($base);\n                                    return array($resfile, $fname);\n                                }\n                                unlink($base);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return array('', '');\n    }\n\n    /**\n     * Save uploaded files\n     *\n     * @param  array\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function upload($args)\n    {\n        $ngReg = '/[\\/\\\\?*:|\"<>]/';\n        $target = $args['target'];\n        $volume = $this->volume($target);\n        $files = isset($args['FILES']['upload']) && is_array($args['FILES']['upload']) ? $args['FILES']['upload'] : array();\n        $header = empty($args['html']) ? array() : array('header' => 'Content-Type: text/html; charset=utf-8');\n        $result = array_merge(array('added' => array()), $header);\n        $paths = $args['upload_path'] ? $args['upload_path'] : array();\n        $chunk = $args['chunk'] ? $args['chunk'] : '';\n        $cid = $args['cid'] ? (int)$args['cid'] : '';\n        $mtimes = $args['mtime'] ? $args['mtime'] : array();\n        $tmpfname = '';\n\n        if (!$volume) {\n            return array_merge(array('error' => $this->error(self::ERROR_UPLOAD, self::ERROR_TRGDIR_NOT_FOUND, '#' . $target)), $header);\n        }\n\n        // check $chunk\n        if (strpos($chunk, '/') !== false || strpos($chunk, '\\\\') !== false) {\n            return array('error' => $this->error(self::ERROR_UPLOAD));\n        }\n\n        if ($args['overwrite'] !== '') {\n            $volume->setUploadOverwrite($args['overwrite']);\n        }\n\n        $renames = $hashes = array();\n        $suffix = '~';\n        if ($args['renames'] && is_array($args['renames'])) {\n            $renames = array_flip($args['renames']);\n            if (is_string($args['suffix']) && !preg_match($ngReg, $args['suffix'])) {\n                $suffix = $args['suffix'];\n            }\n        }\n        if ($args['hashes'] && is_array($args['hashes'])) {\n            $hashes = array_flip($args['hashes']);\n        }\n\n        $this->itemLock($target);\n\n        // file extentions table by MIME\n        $extTable = array_flip(array_unique($volume->getMimeTable()));\n\n        if (empty($files)) {\n            if (isset($args['upload']) && is_array($args['upload']) && ($tempDir = $this->getTempDir($volume->getTempPath()))) {\n                $names = array();\n                foreach ($args['upload'] as $i => $url) {\n                    // check chunked file upload commit\n                    if ($chunk) {\n                        if ($url === 'chunkfail' && $args['mimes'] === 'chunkfail') {\n                            $this->checkChunkedFile(null, $chunk, $cid, $tempDir);\n                            if (preg_match('/^(.+)(\\.\\d+_(\\d+))\\.part$/s', $chunk, $m)) {\n                                $result['warning'] = $this->error(self::ERROR_UPLOAD_FILE, $m[1], self::ERROR_UPLOAD_TEMP);\n                            }\n                            return $result;\n                        } else {\n                            $tmpfname = $tempDir . '/' . $chunk;\n                            $files['tmp_name'][$i] = $tmpfname;\n                            $files['name'][$i] = $url;\n                            $files['error'][$i] = 0;\n                            $GLOBALS['elFinderTempFiles'][$tmpfname] = true;\n                            break;\n                        }\n                    }\n\n                    $tmpfname = $tempDir . DIRECTORY_SEPARATOR . 'ELF_FATCH_' . md5($url . microtime(true));\n                    $GLOBALS['elFinderTempFiles'][$tmpfname] = true;\n\n                    $_name = '';\n                    // check is data:\n                    if (substr($url, 0, 5) === 'data:') {\n                        list($data, $args['name'][$i]) = $this->parse_data_scheme($url, $extTable, $args);\n                    } else {\n                        $fp = fopen($tmpfname, 'wb');\n                        if ($data = $this->get_remote_contents($url, 30, 5, 'Mozilla/5.0', $fp)) {\n                            // to check connection is aborted\n                            elFinder::checkAborted();\n                            $_name = preg_replace('~^.*?([^/#?]+)(?:\\?.*)?(?:#.*)?$~', '$1', rawurldecode($url));\n                            // Check `Content-Disposition` response header\n                            if ($data && ($headers = get_headers($url, true)) && !empty($headers['Content-Disposition'])) {\n                                if (preg_match('/filename\\*=(?:([a-zA-Z0-9_-]+?)\\'\\')\"?([a-z0-9_.~%-]+)\"?/i', $headers['Content-Disposition'], $m)) {\n                                    $_name = rawurldecode($m[2]);\n                                    if ($m[1] && strtoupper($m[1]) !== 'UTF-8' && function_exists('mb_convert_encoding')) {\n                                        $_name = mb_convert_encoding($_name, 'UTF-8', $m[1]);\n                                    }\n                                } else if (preg_match('/filename=\"?([ a-z0-9_.~%-]+)\"?/i', $headers['Content-Disposition'], $m)) {\n                                    $_name = rawurldecode($m[1]);\n                                }\n                            }\n                        }\n                    }\n                    if ($data) {\n                        if (isset($args['name'][$i])) {\n                            $_name = $args['name'][$i];\n                        }\n                        if ($_name) {\n                            $_ext = '';\n                            if (preg_match('/(\\.[a-z0-9]{1,7})$/', $_name, $_match)) {\n                                $_ext = $_match[1];\n                            }\n                            if ((is_resource($data) && fclose($data)) || file_put_contents($tmpfname, $data)) {\n                                $GLOBALS['elFinderTempFiles'][$tmpfname] = true;\n                                $_name = preg_replace($ngReg, '_', $_name);\n                                list($_a, $_b) = array_pad(explode('.', $_name, 2), 2, '');\n                                if ($_b === '') {\n                                    if ($_ext) {\n                                        rename($tmpfname, $tmpfname . $_ext);\n                                        $tmpfname = $tmpfname . $_ext;\n                                    }\n                                    $_b = $this->detectFileExtension($volume, $tmpfname, $_name);\n                                    $_name = $_a . $_b;\n                                } else {\n                                    $_b = '.' . $_b;\n                                }\n                                if (isset($names[$_name])) {\n                                    $_name = $_a . '_' . $names[$_name]++ . $_b;\n                                } else {\n                                    $names[$_name] = 1;\n                                }\n                                $files['tmp_name'][$i] = $tmpfname;\n                                $files['name'][$i] = $_name;\n                                $files['error'][$i] = 0;\n                                // set to auto rename\n                                $volume->setUploadOverwrite(false);\n                            } else {\n                                unlink($tmpfname);\n                            }\n                        }\n                    }\n                }\n            }\n            if (empty($files)) {\n                return array_merge(array('error' => $this->error(self::ERROR_UPLOAD, self::ERROR_UPLOAD_NO_FILES)), $header);\n            }\n        }\n\n        $addedDirs = array();\n        $errors = array();\n        foreach ($files['name'] as $i => $name) {\n            if (($error = $files['error'][$i]) > 0) {\n                $result['warning'] = $this->error(self::ERROR_UPLOAD_FILE, $name, $error == UPLOAD_ERR_INI_SIZE || $error == UPLOAD_ERR_FORM_SIZE ? self::ERROR_UPLOAD_FILE_SIZE : self::ERROR_UPLOAD_TRANSFER, $error);\n                $this->uploadDebug = 'Upload error code: ' . $error;\n                break;\n            }\n\n            $tmpname = $files['tmp_name'][$i];\n            $thash = ($paths && isset($paths[$i])) ? $paths[$i] : $target;\n            $mtime = isset($mtimes[$i]) ? $mtimes[$i] : 0;\n            if ($name === 'blob') {\n                if ($chunk) {\n                    if ($tempDir = $this->getTempDir($volume->getTempPath())) {\n                        list($tmpname, $name) = $this->checkChunkedFile($tmpname, $chunk, $cid, $tempDir, $volume);\n                        if ($tmpname) {\n                            if ($name === false) {\n                                preg_match('/^(.+)(\\.\\d+_(\\d+))\\.part$/s', $chunk, $m);\n                                $result['error'] = $this->error(self::ERROR_UPLOAD_FILE, $m[1], $tmpname);\n                                $result['_chunkfailure'] = true;\n                                $this->uploadDebug = 'Upload error: ' . $tmpname;\n                            } else if ($name) {\n                                $result['_chunkmerged'] = basename($tmpname);\n                                $result['_name'] = $name;\n                                $result['_mtime'] = $mtime;\n                            }\n                        }\n                    } else {\n                        $result['error'] = $this->error(self::ERROR_UPLOAD_FILE, $chunk, self::ERROR_UPLOAD_TEMP);\n                        $this->uploadDebug = 'Upload error: unable open tmp file';\n                    }\n                    return $result;\n                } else {\n                    // for form clipboard with Google Chrome or Opera\n                    $name = 'image.png';\n                }\n            }\n\n            // Set name if name eq 'image.png' and $args has 'name' array, e.g. clipboard data\n            if (strtolower(substr($name, 0, 5)) === 'image' && is_array($args['name']) && isset($args['name'][$i])) {\n                $type = $files['type'][$i];\n                $name = $args['name'][$i];\n                $ext = isset($extTable[$type]) ? '.' . $extTable[$type] : '';\n                if ($ext) {\n                    $name = preg_replace('/\\.[^.]*$/', '', $name);\n                }\n                $name .= $ext;\n            }\n\n            // do hook function 'upload.presave'\n            if (!empty($this->listeners['upload.presave'])) {\n                foreach ($this->listeners['upload.presave'] as $handler) {\n                    call_user_func_array($handler, array(&$thash, &$name, $tmpname, $this, $volume));\n                }\n            }\n\n            clearstatcache();\n            if ($mtime && is_file($tmpname)) {\n                // for keep timestamp option in the LocalFileSystem volume\n                touch($tmpname, $mtime);\n            }\n\n            if (!is_file($tmpname) || ($fp = fopen($tmpname, 'rb')) === false) {\n                $result['warning'] = $this->error(self::ERROR_UPLOAD_FILE, $name, self::ERROR_UPLOAD_TEMP);\n                $this->uploadDebug = 'Upload error: unable open tmp file';\n                if (!is_uploaded_file($tmpname)) {\n                    if (unlink($tmpname) && $tmpfname) unset($GLOBALS['elFinderTempFiles'][$tmpfname]);\n                    continue;\n                }\n                break;\n            }\n            $rnres = array();\n            if ($thash !== '' && $thash !== $target) {\n                if ($dir = $volume->dir($thash)) {\n                    $_target = $thash;\n                    if (!isset($addedDirs[$thash])) {\n                        $addedDirs[$thash] = true;\n                        $result['added'][] = $dir;\n                        // to support multi-level directory creation\n                        $_phash = isset($dir['phash']) ? $dir['phash'] : null;\n                        while ($_phash && !isset($addedDirs[$_phash]) && $_phash !== $target) {\n                            if ($_dir = $volume->dir($_phash)) {\n                                $addedDirs[$_phash] = true;\n                                $result['added'][] = $_dir;\n                                $_phash = isset($_dir['phash']) ? $_dir['phash'] : null;\n                            } else {\n                                break;\n                            }\n                        }\n                    }\n                } else {\n                    $result['error'] = $this->error(self::ERROR_UPLOAD, self::ERROR_TRGDIR_NOT_FOUND, 'hash@' . $thash);\n                    break;\n                }\n            } else {\n                $_target = $target;\n                // file rename for backup\n                if (isset($renames[$name])) {\n                    $dir = $volume->realpath($_target);\n                    if (isset($hashes[$name])) {\n                        $hash = $hashes[$name];\n                    } else {\n                        $hash = $volume->getHash($dir, $name);\n                    }\n                    $rnres = $this->rename(array('target' => $hash, 'name' => $volume->uniqueName($dir, $name, $suffix, true, 0)));\n                    if (!empty($rnres['error'])) {\n                        $result['warning'] = $rnres['error'];\n                        if (!is_array($rnres['error'])) {\n                            $errors = array_push($errors, $rnres['error']);\n                        } else {\n                            $errors = array_merge($errors, $rnres['error']);\n                        }\n                        continue;\n                    }\n                }\n            }\n            if (!$_target || ($file = $volume->upload($fp, $_target, $name, $tmpname, ($_target === $target) ? $hashes : array())) === false) {\n                $errors = array_merge($errors, $this->error(self::ERROR_UPLOAD_FILE, $name, $volume->error()));\n                fclose($fp);\n                if (!is_uploaded_file($tmpname) && unlink($tmpname)) {\n                    unset($GLOBALS['elFinderTempFiles'][$tmpname]);\n                }\n                continue;\n            }\n\n            is_resource($fp) && fclose($fp);\n            if (!is_uploaded_file($tmpname)) {\n                clearstatcache();\n                if (!is_file($tmpname) || unlink($tmpname)) {\n                    unset($GLOBALS['elFinderTempFiles'][$tmpname]);\n                }\n            }\n            $result['added'][] = $file;\n            if ($rnres) {\n                $result = array_merge_recursive($result, $rnres);\n            }\n        }\n\n        if ($errors) {\n            $result['warning'] = $errors;\n        }\n\n        if ($GLOBALS['elFinderTempFiles']) {\n            foreach (array_keys($GLOBALS['elFinderTempFiles']) as $_temp) {\n                is_file($_temp) && unlink($_temp);\n            }\n        }\n        $result['removed'] = $volume->removed();\n\n        if (!empty($args['node'])) {\n            $result['callback'] = array(\n                'node' => $args['node'],\n                'bind' => 'upload'\n            );\n        }\n        return $result;\n    }\n\n    /**\n     * Copy/move files into new destination\n     *\n     * @param  array  command arguments\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function paste($args)\n    {\n        $dst = $args['dst'];\n        $targets = is_array($args['targets']) ? $args['targets'] : array();\n        $cut = !empty($args['cut']);\n        $error = $cut ? self::ERROR_MOVE : self::ERROR_COPY;\n        $result = array('changed' => array(), 'added' => array(), 'removed' => array(), 'warning' => array());\n\n        if (($dstVolume = $this->volume($dst)) == false) {\n            return array('error' => $this->error($error, '#' . $targets[0], self::ERROR_TRGDIR_NOT_FOUND, '#' . $dst));\n        }\n\n        $this->itemLock($dst);\n\n        $hashes = $renames = array();\n        $suffix = '~';\n        if (!empty($args['renames'])) {\n            $renames = array_flip($args['renames']);\n            if (is_string($args['suffix']) && !preg_match('/[\\/\\\\?*:|\"<>]/', $args['suffix'])) {\n                $suffix = $args['suffix'];\n            }\n        }\n        if (!empty($args['hashes'])) {\n            $hashes = array_flip($args['hashes']);\n        }\n\n        foreach ($targets as $target) {\n            elFinder::checkAborted();\n\n            if (($srcVolume = $this->volume($target)) == false) {\n                $result['warning'] = array_merge($result['warning'], $this->error($error, '#' . $target, self::ERROR_FILE_NOT_FOUND));\n                continue;\n            }\n\n            $rnres = array();\n            if ($renames) {\n                $file = $srcVolume->file($target);\n                if (isset($renames[$file['name']])) {\n                    $dir = $dstVolume->realpath($dst);\n                    if (isset($hashes[$file['name']])) {\n                        $hash = $hashes[$file['name']];\n                    } else {\n                        $hash = $dstVolume->getHash($dir, $file['name']);\n                    }\n                    $rnres = $this->rename(array('target' => $hash, 'name' => $dstVolume->uniqueName($dir, $file['name'], $suffix, true, 0)));\n                    if (!empty($rnres['error'])) {\n                        $result['warning'] = array_merge($result['warning'], $rnres['error']);\n                        continue;\n                    }\n                }\n            }\n\n            if ($cut && $this->itemLocked($target)) {\n                $rm = $srcVolume->file($target);\n                $result['warning'] = array_merge($result['warning'], $this->error(self::ERROR_LOCKED, $rm['name']));\n                continue;\n            }\n\n            if (($file = $dstVolume->paste($srcVolume, $target, $dst, $cut, $hashes)) == false) {\n                $result['warning'] = array_merge($result['warning'], $this->error($dstVolume->error()));\n                continue;\n            }\n\n            if ($error = $dstVolume->error()) {\n                $result['warning'] = array_merge($result['warning'], $this->error($error));\n            }\n\n            $dirChange = !empty($file['dirChange']);\n            unset($file['dirChange']);\n            if ($dirChange) {\n                $result['changed'][] = $file;\n            } else {\n                $result['added'][] = $file;\n            }\n            if ($rnres) {\n                $result = array_merge_recursive($result, $rnres);\n            }\n        }\n        if (count($result['warning']) < 1) {\n            unset($result['warning']);\n        } else {\n            $result['sync'] = true;\n        }\n\n        return $result;\n    }\n\n    /**\n     * Return file content\n     *\n     * @param  array $args command arguments\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function get($args)\n    {\n        $target = $args['target'];\n        $volume = $this->volume($target);\n        $enc = false;\n\n        if (!$volume || ($file = $volume->file($target)) == false) {\n            return array('error' => $this->error(self::ERROR_OPEN, '#' . $target, self::ERROR_FILE_NOT_FOUND));\n        }\n\n        if (($content = $volume->getContents($target)) === false) {\n            return array('error' => $this->error(self::ERROR_OPEN, $volume->path($target), $volume->error()));\n        }\n\n        $mime = isset($file['mime']) ? $file['mime'] : '';\n        if ($mime && (strtolower(substr($mime, 0, 4)) === 'text' || in_array(strtolower($mime), self::$textMimes))) {\n            $enc = '';\n            if ($content !== '') {\n                if (!$args['conv'] || $args['conv'] == '1') {\n                    // detect encoding\n                    if (function_exists('mb_detect_encoding')) {\n                        if ($enc = mb_detect_encoding($content, mb_detect_order(), true)) {\n                            $encu = strtoupper($enc);\n                            if ($encu === 'UTF-8' || $encu === 'ASCII') {\n                                $enc = '';\n                            }\n                        } else {\n                            $enc = 'unknown';\n                        }\n                    } else if (!preg_match('//u', $content)) {\n                        $enc = 'unknown';\n                    }\n                    if ($enc === 'unknown') {\n                        $enc = $volume->getOption('encoding');\n                        if (!$enc || strtoupper($enc) === 'UTF-8') {\n                            $enc = 'unknown';\n                        }\n                    }\n                    if ($enc && $enc !== 'unknown') {\n                        $utf8 = iconv($enc, 'UTF-8', $content);\n                        if ($utf8 === false && function_exists('mb_convert_encoding')) {\n                            $utf8 = mb_convert_encoding($content, 'UTF-8', $enc);\n                            if (mb_convert_encoding($utf8, $enc, 'UTF-8') !== $content) {\n                                $enc = 'unknown';\n                            }\n                        } else {\n                            if ($utf8 === false || iconv('UTF-8', $enc, $utf8) !== $content) {\n                                $enc = 'unknown';\n                            }\n                        }\n                        if ($enc !== 'unknown') {\n                            $content = $utf8;\n                        }\n                    }\n                    if ($enc) {\n                        if ($args['conv'] == '1') {\n                            $args['conv'] = '';\n                            if ($enc === 'unknown') {\n                                $content = false;\n                            }\n                        } else if ($enc === 'unknown') {\n                            return array('doconv' => $enc);\n                        }\n                    }\n                    if ($args['conv'] == '1') {\n                        $args['conv'] = '';\n                    }\n                }\n                if ($args['conv']) {\n                    $enc = $args['conv'];\n                    if (strtoupper($enc) !== 'UTF-8') {\n                        $_content = $content;\n                        $content = iconv($enc, 'UTF-8', $content);\n                        if ($content === false && function_exists('mb_convert_encoding')) {\n                            $content = mb_convert_encoding($_content, 'UTF-8', $enc);\n                        }\n                    } else {\n                        $enc = '';\n                    }\n                }\n            }\n        } else {\n            $content = 'data:' . ($mime ? $mime : 'application/octet-stream') . ';base64,' . base64_encode($content);\n        }\n\n        if ($enc !== false) {\n            $json = false;\n            if ($content !== false) {\n                $json = json_encode($content);\n            }\n            if ($content === false || $json === false || strlen($json) < strlen($content)) {\n                return array('error' => $this->error(self::ERROR_CONV_UTF8, self::ERROR_NOT_UTF8_CONTENT, $volume->path($target)));\n            }\n        }\n\n        $res = array(\n            'header' => array(\n                'Content-Type: application/json'\n            ),\n            'content' => $content\n        );\n\n        // add cache control headers\n        if ($cacheHeaders = $volume->getOption('cacheHeaders')) {\n            $res['header'] = array_merge($res['header'], $cacheHeaders);\n        }\n\n        if ($enc) {\n            $res['encoding'] = $enc;\n        }\n        return $res;\n    }\n\n    /**\n     * Save content into text file\n     *\n     * @param $args\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     */\n    protected function put($args)\n    {\n        $target = $args['target'];\n        $encoding = isset($args['encoding']) ? $args['encoding'] : '';\n\n        if (($volume = $this->volume($target)) == false\n            || ($file = $volume->file($target)) == false) {\n            return array('error' => $this->error(self::ERROR_SAVE, '#' . $target, self::ERROR_FILE_NOT_FOUND));\n        }\n\n        $this->itemLock($target);\n\n        if ($encoding === 'scheme') {\n            if (preg_match('~^https?://~i', $args['content'])) {\n                /** @var resource $fp */\n                $fp = $this->get_remote_contents($args['content'], 30, 5, 'Mozilla/5.0', $volume->tmpfile());\n                if (!$fp) {\n                    return array('error' => self::ERROR_SAVE, $args['content'], self::ERROR_FILE_NOT_FOUND);\n                }\n                $fmeta = stream_get_meta_data($fp);\n                $mime = $this->detectMimeType($fmeta['uri']);\n                if ($mime === 'unknown') {\n                    $mime = 'application/octet-stream';\n                }\n                $mime = $volume->mimeTypeNormalize($mime, $file['name']);\n                $args['content'] = 'data:' . $mime . ';base64,' . base64_encode(file_get_contents($fmeta['uri']));\n            }\n            $encoding = '';\n            $args['content'] = \"\\0\" . $args['content'];\n        } else if ($encoding === 'hash') {\n            $_hash = $args['content'];\n            if ($_src = $this->getVolume($_hash)) {\n                if ($_file = $_src->file($_hash)) {\n                    if ($_data = $_src->getContents($_hash)) {\n                        $args['content'] = 'data:' . $file['mime'] . ';base64,' . base64_encode($_data);\n                    }\n                }\n            }\n            $encoding = '';\n            $args['content'] = \"\\0\" . $args['content'];\n        }\n        if ($encoding) {\n            $content = iconv('UTF-8', $encoding, $args['content']);\n            if ($content === false && function_exists('mb_detect_encoding')) {\n                $content = mb_convert_encoding($args['content'], $encoding, 'UTF-8');\n            }\n            if ($content !== false) {\n                $args['content'] = $content;\n            }\n        }\n        if (($file = $volume->putContents($target, $args['content'])) == false) {\n            return array('error' => $this->error(self::ERROR_SAVE, $volume->path($target), $volume->error()));\n        }\n\n        return array('changed' => array($file));\n    }\n\n    /**\n     * Extract files from archive\n     *\n     * @param  array $args command arguments\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov,\n     * @author Alexey Sukhotin\n     **/\n    protected function extract($args)\n    {\n        $target = $args['target'];\n        $makedir = isset($args['makedir']) ? (bool)$args['makedir'] : null;\n\n        if (($volume = $this->volume($target)) == false\n            || ($file = $volume->file($target)) == false) {\n            return array('error' => $this->error(self::ERROR_EXTRACT, '#' . $target, self::ERROR_FILE_NOT_FOUND));\n        }\n\n        $res = array();\n        if ($file = $volume->extract($target, $makedir)) {\n            $res['added'] = isset($file['read']) ? array($file) : $file;\n            if ($err = $volume->error()) {\n                $res['warning'] = $err;\n            }\n        } else {\n            $res['error'] = $this->error(self::ERROR_EXTRACT, $volume->path($target), $volume->error());\n        }\n        return $res;\n    }\n\n    /**\n     * Create archive\n     *\n     * @param  array $args command arguments\n     *\n     * @return array\n     * @throws Exception\n     * @author Dmitry (dio) Levashov,\n     * @author Alexey Sukhotin\n     */\n    protected function archive($args)\n    {\n        $targets = isset($args['targets']) && is_array($args['targets']) ? $args['targets'] : array();\n        $name = isset($args['name']) ? $args['name'] : '';\n\n        if (($volume = $this->volume($targets[0])) == false) {\n            return $this->error(self::ERROR_ARCHIVE, self::ERROR_TRGDIR_NOT_FOUND);\n        }\n\n        foreach ($targets as $target) {\n            $this->itemLock($target);\n        }\n\n        return ($file = $volume->archive($targets, $args['type'], $name))\n            ? array('added' => array($file))\n            : array('error' => $this->error(self::ERROR_ARCHIVE, $volume->error()));\n    }\n\n    /**\n     * Search files\n     *\n     * @param  array $args command arguments\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry Levashov\n     */\n    protected function search($args)\n    {\n        $q = trim($args['q']);\n        $mimes = !empty($args['mimes']) && is_array($args['mimes']) ? $args['mimes'] : array();\n        $target = !empty($args['target']) ? $args['target'] : null;\n        $type = !empty($args['type']) ? $args['type'] : null;\n        $result = array();\n        $errors = array();\n\n        if ($target) {\n            if ($volume = $this->volume($target)) {\n                $result = $volume->search($q, $mimes, $target, $type);\n                $errors = array_merge($errors, $volume->error());\n            }\n        } else {\n            foreach ($this->volumes as $volume) {\n                $result = array_merge($result, $volume->search($q, $mimes, null, $type));\n                $errors = array_merge($errors, $volume->error());\n            }\n        }\n\n        $result = array('files' => $result);\n        if ($errors) {\n            $result['warning'] = $errors;\n        }\n        return $result;\n    }\n\n    /**\n     * Return file info (used by client \"places\" ui)\n     *\n     * @param  array $args command arguments\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry Levashov\n     */\n    protected function info($args)\n    {\n        $files = array();\n        $compare = null;\n        // long polling mode\n        if ($args['compare'] && count($args['targets']) === 1) {\n            $compare = intval($args['compare']);\n            $hash = $args['targets'][0];\n            if ($volume = $this->volume($hash)) {\n                $standby = (int)$volume->getOption('plStandby');\n                $_compare = false;\n                if (($syncCheckFunc = $volume->getOption('syncCheckFunc')) && is_callable($syncCheckFunc)) {\n                    $_compare = call_user_func_array($syncCheckFunc, array($volume->realpath($hash), $standby, $compare, $volume, $this));\n                }\n                if ($_compare !== false) {\n                    $compare = $_compare;\n                } else {\n                    $sleep = max(1, (int)$volume->getOption('tsPlSleep'));\n                    $limit = max(1, $standby / $sleep) + 1;\n                    do {\n                        elFinder::extendTimeLimit(30 + $sleep);\n                        $volume->clearstatcache();\n                        if (($info = $volume->file($hash)) != false) {\n                            if ($info['ts'] != $compare) {\n                                $compare = $info['ts'];\n                                break;\n                            }\n                        } else {\n                            $compare = 0;\n                            break;\n                        }\n                        if (--$limit) {\n                            sleep($sleep);\n                        }\n                    } while ($limit);\n                }\n            }\n        } else {\n            foreach ($args['targets'] as $hash) {\n                elFinder::checkAborted();\n                if (($volume = $this->volume($hash)) != false\n                    && ($info = $volume->file($hash)) != false) {\n                    $info['path'] = $volume->path($hash);\n                    $files[] = $info;\n                }\n            }\n        }\n\n        $result = array('files' => $files);\n        if (!is_null($compare)) {\n            $result['compare'] = strval($compare);\n        }\n        return $result;\n    }\n\n    /**\n     * Return image dimensions\n     *\n     * @param  array $args command arguments\n     *\n     * @return array\n     * @throws ImagickException\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function dim($args)\n    {\n        $res = array();\n        $target = $args['target'];\n\n        if (($volume = $this->volume($target)) != false) {\n            if ($dim = $volume->dimensions($target, $args)) {\n                if (is_array($dim) && isset($dim['dim'])) {\n                    $res = $dim;\n                } else {\n                    $res = array('dim' => $dim);\n                    if ($subImgLink = $volume->getSubstituteImgLink($target, explode('x', $dim))) {\n                        $res['url'] = $subImgLink;\n                    }\n                }\n            }\n        }\n\n        return $res;\n    }\n\n    /**\n     * Resize image\n     *\n     * @param  array  command arguments\n     *\n     * @return array\n     * @throws ImagickException\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     * @author Alexey Sukhotin\n     */\n    protected function resize($args)\n    {\n        $target = $args['target'];\n        $width = (int)$args['width'];\n        $height = (int)$args['height'];\n        $x = (int)$args['x'];\n        $y = (int)$args['y'];\n        $mode = $args['mode'];\n        $bg = $args['bg'];\n        $degree = (int)$args['degree'];\n        $quality = (int)$args['quality'];\n\n        if (($volume = $this->volume($target)) == false\n            || ($file = $volume->file($target)) == false) {\n            return array('error' => $this->error(self::ERROR_RESIZE, '#' . $target, self::ERROR_FILE_NOT_FOUND));\n        }\n\n        if ($mode !== 'rotate' && ($width < 1 || $height < 1)) {\n            return array('error' => $this->error(self::ERROR_RESIZESIZE));\n        }\n        return ($file = $volume->resize($target, $width, $height, $x, $y, $mode, $bg, $degree, $quality))\n            ? (!empty($file['losslessRotate']) ? $file : array('changed' => array($file)))\n            : array('error' => $this->error(self::ERROR_RESIZE, $volume->path($target), $volume->error()));\n    }\n\n    /**\n     * Return content URL\n     *\n     * @param  array $args command arguments\n     *\n     * @return array\n     * @author Naoki Sawada\n     **/\n    protected function url($args)\n    {\n        $target = $args['target'];\n        $options = isset($args['options']) ? $args['options'] : array();\n        if (($volume = $this->volume($target)) != false) {\n            if (!$volume->commandDisabled('url')) {\n                $url = $volume->getContentUrl($target, $options);\n                return $url ? array('url' => $url) : array();\n            }\n        }\n        return array();\n    }\n\n    /**\n     * Output callback result with JavaScript that control elFinder\n     * or HTTP redirect to callbackWindowURL\n     *\n     * @param  array  command arguments\n     *\n     * @throws elFinderAbortException\n     * @author Naoki Sawada\n     */\n    protected function callback($args)\n    {\n        $checkReg = '/[^a-zA-Z0-9;._-]/';\n        $node = (isset($args['node']) && !preg_match($checkReg, $args['node'])) ? $args['node'] : '';\n        $json = (isset($args['json']) && json_decode($args['json'])) ? $args['json'] : '{}';\n        $bind = (isset($args['bind']) && !preg_match($checkReg, $args['bind'])) ? $args['bind'] : '';\n        $done = (!empty($args['done']));\n\n        while (ob_get_level()) {\n            if (!ob_end_clean()) {\n                break;\n            }\n        }\n\n        if ($done || !$this->callbackWindowURL) {\n            $script = '';\n            if ($node) {\n                if ($bind) {\n                    $trigger = 'elf.trigger(\\'' . $bind . '\\', data);';\n                    $triggerdone = 'elf.trigger(\\'' . $bind . 'done\\');';\n                    $triggerfail = 'elf.trigger(\\'' . $bind . 'fail\\', data);';\n                } else {\n                    $trigger = $triggerdone = $triggerfail = '';\n                }\n                $script .= '\n\t\t\t\t\tvar w = window.opener || window.parent || window;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvar elf = w.document.getElementById(\\'' . $node . '\\').elfinder;\n\t\t\t\t\t\tif (elf) {\n\t\t\t\t\t\t\tvar data = ' . $json . ';\n\t\t\t\t\t\t\tif (data.error) {\n\t\t\t\t\t\t\t\t' . $triggerfail . '\n\t\t\t\t\t\t\t\telf.error(data.error);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdata.warning && elf.error(data.warning);\n\t\t\t\t\t\t\t\tdata.removed && data.removed.length && elf.remove(data);\n\t\t\t\t\t\t\t\tdata.added   && data.added.length   && elf.add(data);\n\t\t\t\t\t\t\t\tdata.changed && data.changed.length && elf.change(data);\n\t\t\t\t\t\t\t\t' . $trigger . '\n\t\t\t\t\t\t\t\t' . $triggerdone . '\n\t\t\t\t\t\t\t\tdata.sync && elf.sync();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch(e) {\n\t\t\t\t\t\t// for CORS\n\t\t\t\t\t\tw.postMessage && w.postMessage(JSON.stringify({bind:\\'' . $bind . '\\',data:' . $json . '}), \\'*\\');\n\t\t\t\t\t}';\n            }\n            $script .= 'window.close();';\n\n            $out = '<!DOCTYPE html><html><head><meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"><meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"><script>' . $script . '</script></head><body><a href=\"#\" onlick=\"window.close();return false;\">Close this window</a></body></html>';\n\n            header('Content-Type: text/html; charset=utf-8');\n            header('Content-Length: ' . strlen($out));\n            header('Cache-Control: private');\n            header('Pragma: no-cache');\n\n            echo $out;\n\n        } else {\n            $url = $this->callbackWindowURL;\n            $url .= ((strpos($url, '?') === false) ? '?' : '&')\n                . '&node=' . rawurlencode($node)\n                . (($json !== '{}') ? ('&json=' . rawurlencode($json)) : '')\n                . ($bind ? ('&bind=' . rawurlencode($bind)) : '')\n                . '&done=1';\n\n            header('Location: ' . $url);\n\n        }\n        throw new elFinderAbortException();\n    }\n\n    /**\n     * PHP error handler, catch error types only E_WARNING | E_NOTICE | E_USER_WARNING | E_USER_NOTICE\n     *\n     * @param int    $errno\n     * @param string $errstr\n     * @param string $errfile\n     * @param int    $errline\n     *\n     * @return boolean\n     */\n    public static function phpErrorHandler($errno, $errstr, $errfile, $errline)\n    {\n        static $base = null;\n\n        $proc = false;\n\n        if (is_null($base)) {\n            $base = dirname(__FILE__) . DIRECTORY_SEPARATOR;\n        }\n\n        if (!(error_reporting() & $errno)) {\n            return $proc;\n        }\n\n        $errfile = str_replace($base, '', $errfile);\n\n        switch ($errno) {\n            case E_WARNING:\n            case E_USER_WARNING:\n                elFinder::$phpErrors[] = \"WARNING: $errstr in $errfile line $errline.\";\n                $proc = true;\n                break;\n\n            case E_NOTICE:\n            case E_USER_NOTICE:\n                elFinder::$phpErrors[] = \"NOTICE: $errstr in $errfile line $errline.\";\n                $proc = true;\n                break;\n\n            case E_STRICT:\n                elFinder::$phpErrors[] = \"STRICT: $errstr in $errfile line $errline.\";\n                $proc = true;\n                break;\n\n            case E_RECOVERABLE_ERROR:\n                elFinder::$phpErrors[] = \"RECOVERABLE_ERROR: $errstr in $errfile line $errline.\";\n                $proc = true;\n                break;\n        }\n\n        if (defined('E_DEPRECATED')) {\n            switch ($errno) {\n                case E_DEPRECATED:\n                case E_USER_DEPRECATED:\n                    elFinder::$phpErrors[] = \"DEPRECATED: $errstr in $errfile line $errline.\";\n                    $proc = true;\n                    break;\n            }\n        }\n\n        return $proc;\n    }\n\n    /***************************************************************************/\n    /*                                   utils                                 */\n    /***************************************************************************/\n\n    /**\n     * Return root - file's owner\n     *\n     * @param  string  file hash\n     *\n     * @return elFinderVolumeDriver|boolean (false)\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function volume($hash)\n    {\n        foreach ($this->volumes as $id => $v) {\n            if (strpos('' . $hash, $id) === 0) {\n                return $this->volumes[$id];\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Return files info array\n     *\n     * @param  array $data one file info or files info\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function toArray($data)\n    {\n        return isset($data['hash']) || !is_array($data) ? array($data) : $data;\n    }\n\n    /**\n     * Return fils hashes list\n     *\n     * @param  array $files files info\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function hashes($files)\n    {\n        $ret = array();\n        foreach ($files as $file) {\n            $ret[] = $file['hash'];\n        }\n        return $ret;\n    }\n\n    /**\n     * Remove from files list hidden files and files with required mime types\n     *\n     * @param  array $files files info\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function filter($files)\n    {\n        $exists = array();\n        foreach ($files as $i => $file) {\n            if (isset($exists[$file['hash']]) || !empty($file['hidden']) || !$this->default->mimeAccepted($file['mime'])) {\n                unset($files[$i]);\n            }\n            $exists[$file['hash']] = true;\n        }\n        return array_values($files);\n    }\n\n    protected function utime()\n    {\n        $time = explode(\" \", microtime());\n        return (double)$time[1] + (double)$time[0];\n    }\n\n    /**\n     * Return Network mount volume unique ID\n     *\n     * @param  array  $netVolumes Saved netvolumes array\n     * @param  string $prefix     Id prefix\n     *\n     * @return string|false\n     * @author Naoki Sawada\n     **/\n    protected function getNetVolumeUniqueId($netVolumes = null, $prefix = 'nm')\n    {\n        if (is_null($netVolumes)) {\n            $netVolumes = $this->getNetVolumes();\n        }\n        $ids = array();\n        foreach ($netVolumes as $vOps) {\n            if (isset($vOps['id']) && strpos($vOps['id'], $prefix) === 0) {\n                $ids[$vOps['id']] = true;\n            }\n        }\n        if (!$ids) {\n            $id = $prefix . '1';\n        } else {\n            $i = 0;\n            while (isset($ids[$prefix . ++$i]) && $i < 10000) ;\n            $id = $prefix . $i;\n            if (isset($ids[$id])) {\n                $id = false;\n            }\n        }\n        return $id;\n    }\n\n    /**\n     * Is item locked?\n     *\n     * @param string $hash\n     *\n     * @return boolean\n     */\n    protected function itemLocked($hash)\n    {\n        if (!elFinder::$commonTempPath) {\n            return false;\n        }\n        $lock = elFinder::$commonTempPath . DIRECTORY_SEPARATOR . $hash . '.lock';\n        if (file_exists($lock)) {\n            if (filemtime($lock) + $this->itemLockExpire < time()) {\n                unlink($lock);\n                return false;\n            }\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Do lock target item\n     *\n     * @param array|string $hashes\n     * @param boolean      $autoUnlock\n     *\n     * @return void\n     */\n    protected function itemLock($hashes, $autoUnlock = true)\n    {\n        if (!elFinder::$commonTempPath) {\n            return;\n        }\n        if (!is_array($hashes)) {\n            $hashes = array($hashes);\n        }\n        foreach ($hashes as $hash) {\n            $lock = elFinder::$commonTempPath . DIRECTORY_SEPARATOR . $hash . '.lock';\n            if ($this->itemLocked($hash)) {\n                $cnt = file_get_contents($lock) + 1;\n            } else {\n                $cnt = 1;\n            }\n            if (file_put_contents($lock, $cnt, LOCK_EX)) {\n                if ($autoUnlock) {\n                    $this->autoUnlocks[] = $hash;\n                }\n            }\n        }\n    }\n\n    /**\n     * Do unlock target item\n     *\n     * @param string $hash\n     *\n     * @return boolean\n     */\n    protected function itemUnlock($hash)\n    {\n        if (!$this->itemLocked($hash)) {\n            return true;\n        }\n        $lock = elFinder::$commonTempPath . DIRECTORY_SEPARATOR . $hash . '.lock';\n        $cnt = file_get_contents($lock);\n        if (--$cnt < 1) {\n            unlink($lock);\n            return true;\n        } else {\n            file_put_contents($lock, $cnt, LOCK_EX);\n            return false;\n        }\n    }\n\n    /**\n     * unlock locked items on command completion\n     *\n     * @return void\n     */\n    public function itemAutoUnlock()\n    {\n        if ($this->autoUnlocks) {\n            foreach ($this->autoUnlocks as $hash) {\n                $this->itemUnlock($hash);\n            }\n            $this->autoUnlocks = array();\n        }\n    }\n\n    /**\n     * Ensure directories recursively\n     *\n     * @param  object $volume Volume object\n     * @param  string $target Target hash\n     * @param  array  $dirs   Array of directory tree to ensure\n     * @param  string $path   Relative path form target hash\n     *\n     * @return array|false      array('stats' => array([stat of maked directory]), 'hashes' => array('[path]' => '[hash]'), 'makes' => array([New directory hashes]), 'error' => array([Error name]))\n     * @author Naoki Sawada\n     **/\n    protected function ensureDirsRecursively($volume, $target, $dirs, $path = '')\n    {\n        $res = array('stats' => array(), 'hashes' => array(), 'makes' => array(), 'error' => array());\n        foreach ($dirs as $name => $sub) {\n            $name = (string)$name;\n            $dir = $newDir = null;\n            if ((($parent = $volume->realpath($target)) && ($dir = $volume->dir($volume->getHash($parent, $name)))) || ($newDir = $volume->mkdir($target, $name))) {\n                $_path = $path . '/' . $name;\n                if ($newDir) {\n                    $res['makes'][] = $newDir['hash'];\n                    $dir = $newDir;\n                }\n                $res['stats'][] = $dir;\n                $res['hashes'][$_path] = $dir['hash'];\n                if (count($sub)) {\n                    $res = array_merge_recursive($res, $this->ensureDirsRecursively($volume, $dir['hash'], $sub, $_path));\n                }\n            } else {\n                $res['error'][] = $name;\n            }\n        }\n        return $res;\n    }\n\n    /***************************************************************************/\n    /*                           static  utils                                 */\n    /***************************************************************************/\n\n    /**\n     * Return full version of API that this connector supports all functions\n     *\n     * @return string\n     */\n    public static function getApiFullVersion()\n    {\n        return (string)self::$ApiVersion . '.' . (string)self::$ApiRevision;\n    }\n\n    /**\n     * Return Is Animation Gif\n     *\n     * @param  string $path server local path of target image\n     *\n     * @return bool\n     */\n    public static function isAnimationGif($path)\n    {\n        list(, , $type) = getimagesize($path);\n        switch ($type) {\n            case IMAGETYPE_GIF:\n                break;\n            default:\n                return false;\n        }\n\n        $imgcnt = 0;\n        $fp = fopen($path, 'rb');\n        fread($fp, 4);\n        $c = fread($fp, 1);\n        if (ord($c) != 0x39) {  // GIF89a\n            return false;\n        }\n\n        while (!feof($fp)) {\n            do {\n                $c = fread($fp, 1);\n            } while (ord($c) != 0x21 && !feof($fp));\n\n            if (feof($fp)) {\n                break;\n            }\n\n            $c2 = fread($fp, 2);\n            if (bin2hex($c2) == \"f904\") {\n                $imgcnt++;\n                if ($imgcnt === 2) {\n                    break;\n                }\n            }\n\n            if (feof($fp)) {\n                break;\n            }\n        }\n\n        if ($imgcnt > 1) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Return Is Animation Png\n     *\n     * @param  string $path server local path of target image\n     *\n     * @return bool\n     */\n    public static function isAnimationPng($path)\n    {\n        list(, , $type) = getimagesize($path);\n        switch ($type) {\n            case IMAGETYPE_PNG:\n                break;\n            default:\n                return false;\n        }\n\n        $fp = fopen($path, 'rb');\n        $img_bytes = fread($fp, 1024);\n        fclose($fp);\n        if ($img_bytes) {\n            if (strpos(substr($img_bytes, 0, strpos($img_bytes, 'IDAT')), 'acTL') !== false) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Return Is seekable stream resource\n     *\n     * @param resource $resource\n     *\n     * @return bool\n     */\n    public static function isSeekableStream($resource)\n    {\n        $metadata = stream_get_meta_data($resource);\n        return $metadata['seekable'];\n    }\n\n    /**\n     * Rewind stream resource\n     *\n     * @param resource $resource\n     *\n     * @return void\n     */\n    public static function rewind($resource)\n    {\n        self::isSeekableStream($resource) && rewind($resource);\n    }\n\n    /**\n     * serialize and base64_encode of session data (If needed)\n     *\n     * @deprecated\n     *\n     * @param  mixed $var target variable\n     *\n     * @author Naoki Sawada\n     * @return mixed|string\n     */\n    public static function sessionDataEncode($var)\n    {\n        if (self::$base64encodeSessionData) {\n            $var = base64_encode(serialize($var));\n        }\n        return $var;\n    }\n\n    /**\n     * base64_decode and unserialize of session data  (If needed)\n     *\n     * @deprecated\n     *\n     * @param  mixed $var     target variable\n     * @param  bool  $checkIs data type for check (array|string|object|int)\n     *\n     * @author Naoki Sawada\n     * @return bool|mixed\n     */\n    public static function sessionDataDecode(&$var, $checkIs = null)\n    {\n        if (self::$base64encodeSessionData) {\n            $data = unserialize(base64_decode($var));\n        } else {\n            $data = $var;\n        }\n        $chk = true;\n        if ($checkIs) {\n            switch ($checkIs) {\n                case 'array':\n                    $chk = is_array($data);\n                    break;\n                case 'string':\n                    $chk = is_string($data);\n                    break;\n                case 'object':\n                    $chk = is_object($data);\n                    break;\n                case 'int':\n                    $chk = is_int($data);\n                    break;\n            }\n        }\n        if (!$chk) {\n            unset($var);\n            return false;\n        }\n        return $data;\n    }\n\n    /**\n     * Call session_write_close() if session is restarted\n     *\n     * @deprecated\n     * @return void\n     */\n    public static function sessionWrite()\n    {\n        if (session_id()) {\n            session_write_close();\n        }\n    }\n\n    /**\n     * Return elFinder static variable\n     *\n     * @param $key\n     *\n     * @return mixed|null\n     */\n    public static function getStaticVar($key)\n    {\n        return isset(elFinder::$$key) ? elFinder::$$key : null;\n    }\n\n    /**\n     * Extend PHP execution time limit and also check connection is aborted\n     *\n     * @param Int $time\n     *\n     * @return void\n     * @throws elFinderAbortException\n     */\n    public static function extendTimeLimit($time = null)\n    {\n        static $defLimit = null;\n        if (!self::aborted()) {\n            if (is_null($defLimit)) {\n                $defLimit = ini_get('max_execution_time');\n            }\n            if ($defLimit != 0) {\n                $time = is_null($time) ? $defLimit : max($defLimit, $time);\n                set_time_limit($time);\n            }\n        } else {\n            throw new elFinderAbortException();\n        }\n    }\n\n    /**\n     * Check connection is aborted\n     * Script stop immediately if connection aborted\n     *\n     * @return void\n     * @throws elFinderAbortException\n     */\n    public static function checkAborted()\n    {\n        elFinder::extendTimeLimit();\n    }\n\n    /**\n     * Return bytes from php.ini value\n     *\n     * @param string $iniName\n     * @param string $val\n     *\n     * @return number\n     */\n    public static function getIniBytes($iniName = '', $val = '')\n    {\n        if ($iniName !== '') {\n            $val = ini_get($iniName);\n            if ($val === false) {\n                return 0;\n            }\n        }\n        $val = trim($val, \"bB \\t\\n\\r\\0\\x0B\");\n        $last = strtolower($val[strlen($val) - 1]);\n        $val = (int)$val;\n        switch ($last) {\n            case 't':\n                $val *= 1024;\n            case 'g':\n                $val *= 1024;\n            case 'm':\n                $val *= 1024;\n            case 'k':\n                $val *= 1024;\n        }\n        return $val;\n    }\n\n    /**\n     * Get script url.\n     *\n     * @return string full URL\n     * @author Naoki Sawada\n     */\n    public static function getConnectorUrl()\n    {\n        $https = (isset($_SERVER['HTTPS']) && strtolower($_SERVER['HTTPS']) !== 'off');\n        $url = ($https ? 'https://' : 'http://')\n            . $_SERVER['SERVER_NAME']                                              // host\n            . (((!$https && $_SERVER['SERVER_PORT'] == 80) || ($https && $_SERVER['SERVER_PORT'] == 443)) ? '' : (':' . $_SERVER['SERVER_PORT']))  // port\n            . $_SERVER['REQUEST_URI'];                                             // path & query\n        list($url) = explode('?', $url);\n\n        return $url;\n    }\n\n    /**\n     * Get stream resource pointer by URL\n     *\n     * @param array $data array('target'=>'URL', 'headers' => array())\n     * @param int   $redirectLimit\n     *\n     * @return resource|boolean\n     * @author Naoki Sawada\n     */\n    public static function getStreamByUrl($data, $redirectLimit = 5)\n    {\n        if (isset($data['target'])) {\n            $data = array(\n                'cnt' => 0,\n                'url' => $data['target'],\n                'headers' => isset($data['headers']) ? $data['headers'] : array(),\n                'cookies' => array(),\n            );\n        }\n        if ($data['cnt'] > $redirectLimit) {\n            return false;\n        }\n        $dlurl = $data['url'];\n        $data['url'] = '';\n        $headers = $data['headers'];\n\n        if ($dlurl) {\n            $url = parse_url($dlurl);\n            $ports = array(\n                'http' => '80',\n                'https' => '443',\n                'ftp' => '21'\n            );\n            $url['scheme'] = strtolower($url['scheme']);\n            if (!isset($url['port']) && isset($ports[$url['scheme']])) {\n                $url['port'] = $ports[$url['scheme']];\n            }\n            if (!isset($url['port'])) {\n                return false;\n            }\n            $cookies = array();\n            if ($data['cookies']) {\n                foreach ($data['cookies'] as $d => $c) {\n                    if (strpos($url['host'], $d) !== false) {\n                        $cookies[] = $c;\n                    }\n                }\n            }\n\n            $transport = ($url['scheme'] === 'https') ? 'tls' : 'tcp';\n            $query = isset($url['query']) ? '?' . $url['query'] : '';\n            $stream = stream_socket_client($transport . '://' . $url['host'] . ':' . $url['port']);\n            stream_set_timeout($stream, 300);\n            fputs($stream, \"GET {$url['path']}{$query} HTTP/1.1\\r\\n\");\n            fputs($stream, \"Host: {$url['host']}\\r\\n\");\n            foreach ($headers as $header) {\n                fputs($stream, trim($header, \"\\r\\n\") . \"\\r\\n\");\n            }\n            fputs($stream, \"Connection: Close\\r\\n\");\n            if ($cookies) {\n                fputs($stream, 'Cookie: ' . implode('; ', $cookies) . \"\\r\\n\");\n            }\n            fputs($stream, \"\\r\\n\");\n            while (($res = trim(fgets($stream))) !== '') {\n                // find redirect\n                if (preg_match('/^Location: (.+)$/', $res, $m)) {\n                    $data['url'] = $m[1];\n                }\n                // fetch cookie\n                if (strpos($res, 'Set-Cookie:') === 0) {\n                    $domain = $url['host'];\n                    if (preg_match('/^Set-Cookie:(.+)(?:domain=\\s*([^ ;]+))?/i', $res, $c1)) {\n                        if (!empty($c1[2])) {\n                            $domain = trim($c1[2]);\n                        }\n                        if (preg_match('/([^ ]+=[^;]+)/', $c1[1], $c2)) {\n                            $data['cookies'][$domain] = $c2[1];\n                        }\n                    }\n                }\n            }\n            if ($data['url']) {\n                ++$data['cnt'];\n                fclose($stream);\n\n                return self::getStreamByUrl($data, $redirectLimit);\n            }\n\n            return $stream;\n        }\n\n        return false;\n    }\n\n    /**\n     * Gets the fetch cookie file for curl.\n     *\n     * @return string  The fetch cookie file.\n     */\n    public function getFetchCookieFile()\n    {\n        $file = '';\n        if ($tmpDir = $this->getTempDir()) {\n            $file = $tmpDir . '/.elFinderAnonymousCookie';\n        }\n        return $file;\n    }\n\n    /**\n     * Call curl_exec() with supported redirect on `safe_mode` or `open_basedir`\n     *\n     * @param resource $curl\n     * @param array    $options\n     * @param array    $headers\n     *\n     * @throws \\Exception\n     * @return mixed\n     * @author Naoki Sawada\n     */\n    public static function curlExec($curl, $options = array(), $headers = array())\n    {\n        $followLocation = (!ini_get('safe_mode') && !ini_get('open_basedir'));\n        if ($followLocation) {\n            curl_setopt($curl, CURLOPT_FOLLOWLOCATION, true);\n        }\n\n        if ($options) {\n            curl_setopt_array($curl, $options);\n        }\n\n        if ($headers) {\n            curl_setopt($curl, CURLOPT_HTTPHEADER, $headers);\n        }\n\n        $result = curl_exec($curl);\n\n        if (!$followLocation && $redirect = curl_getinfo($curl, CURLINFO_REDIRECT_URL)) {\n            if ($stream = self::getStreamByUrl(array('target' => $redirect, 'headers' => $headers))) {\n                $result = stream_get_contents($stream);\n            }\n        }\n\n        if ($result === false) {\n            if (curl_errno($curl)) {\n                throw new \\Exception('curl_exec() failed: ' . curl_error($curl));\n            } else {\n                throw new \\Exception('curl_exec(): empty response');\n            }\n        }\n\n        curl_close($curl);\n\n        return $result;\n    }\n\n    /**\n     * Return bool that current request was aborted by client side\n     *\n     * @return boolean\n     */\n    public static function aborted()\n    {\n        if ($file = self::$abortCheckFile) {\n            (version_compare(PHP_VERSION, '5.3.0') >= 0) ? clearstatcache(true, $file) : clearstatcache();\n            if (!is_file($file)) {\n                // GC (expire 12h)\n                list($ptn) = explode('elfreq', $file);\n                self::GlobGC($ptn . 'elfreq*', 43200);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Return array [\"name without extention\", \"extention\"] by filename\n     *\n     * @param string $name\n     *\n     * @return array\n     */\n    public static function splitFileExtention($name)\n    {\n        if (preg_match('/^(.+?)?\\.((?:tar\\.(?:gz|bz|bz2|z|lzo))|cpio\\.gz|ps\\.gz|xcf\\.(?:gz|bz2)|[a-z0-9]{1,10})$/i', $name, $m)) {\n            return array((string)$m[1], $m[2]);\n        } else {\n            return array($name, '');\n        }\n    }\n\n    /**\n     * Gets the memory size by imageinfo.\n     *\n     * @param      array $imgInfo array that result of getimagesize()\n     *\n     * @return     integer  The memory size by imageinfo.\n     */\n    public static function getMemorySizeByImageInfo($imgInfo)\n    {\n        $width = $imgInfo[0];\n        $height = $imgInfo[1];\n        $bits = isset($imgInfo['bits']) ? $imgInfo['bits'] : 24;\n        $channels = isset($imgInfo['channels']) ? $imgInfo['channels'] : 3;\n        return round(($width * $height * $bits * $channels / 8 + Pow(2, 16)) * 1.65);\n    }\n\n    /**\n     * Auto expand memory for GD processing\n     *\n     * @param      array $imgInfos The image infos\n     */\n    public static function expandMemoryForGD($imgInfos)\n    {\n        if (elFinder::$memoryLimitGD != 0 && $imgInfos && is_array($imgInfos)) {\n            if (!is_array($imgInfos[0])) {\n                $imgInfos = array($imgInfos);\n            }\n            $limit = self::getIniBytes('', elFinder::$memoryLimitGD);\n            $memLimit = self::getIniBytes('memory_limit');\n            $needs = 0;\n            foreach ($imgInfos as $info) {\n                $needs += self::getMemorySizeByImageInfo($info);\n            }\n            $needs += memory_get_usage();\n            if ($needs > $memLimit && ($limit == -1 || $limit > $needs)) {\n                ini_set('memory_limit', $needs);\n            }\n        }\n    }\n\n    /***************************************************************************/\n    /*                                 callbacks                               */\n    /***************************************************************************/\n\n    /**\n     * Get command name of binded \"commandName.subName\"\n     *\n     * @param string $cmd\n     *\n     * @return string\n     */\n    protected static function getCmdOfBind($cmd)\n    {\n        list($ret) = explode('.', $cmd);\n        return trim($ret);\n    }\n\n    /**\n     * Add subName to commandName\n     *\n     * @param string $cmd\n     * @param string $sub\n     *\n     * @return string\n     */\n    protected static function addSubToBindName($cmd, $sub)\n    {\n        return $cmd . '.' . trim($sub);\n    }\n\n    /**\n     * Remove a file if connection is disconnected\n     *\n     * @param string $file\n     */\n    public static function rmFileInDisconnected($file)\n    {\n        (connection_aborted() || connection_status() !== CONNECTION_NORMAL) && is_file($file) && unlink($file);\n    }\n\n    /**\n     * Call back function on shutdown\n     *  - delete files in $GLOBALS['elFinderTempFiles']\n     */\n    public static function onShutdown()\n    {\n        self::$abortCheckFile = null;\n        if (!empty($GLOBALS['elFinderTempFiles'])) {\n            foreach (array_keys($GLOBALS['elFinderTempFiles']) as $f) {\n                is_file($f) && unlink($f);\n            }\n        }\n    }\n\n    /**\n     * Garbage collection with glob\n     *\n     * @param string  $pattern\n     * @param integer $time\n     */\n    public static function GlobGC($pattern, $time)\n    {\n        $now = time();\n        foreach (glob($pattern) as $file) {\n            (filemtime($file) < ($now - $time)) && unlink($file);\n        }\n    }\n\n} // END class\n\n/**\n * Custom exception class for aborting request\n */\nclass elFinderAbortException extends Exception\n{\n}\n"], "filenames": ["php/elFinder.class.php"], "buggy_code_start_loc": [2413], "buggy_code_end_loc": [2551], "fixing_code_start_loc": [2413], "fixing_code_end_loc": [2574], "type": "CWE-918", "message": "A Server Side Request Forgery (SSRF) vulnerability in elFinder before 2.1.46 could allow a malicious user to access the content of internal network resources. This occurs in get_remote_contents() in php/elFinder.class.php.", "other": {"cve": {"id": "CVE-2019-6257", "sourceIdentifier": "cve@mitre.org", "published": "2019-01-14T08:29:00.473", "lastModified": "2021-09-09T12:47:56.577", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A Server Side Request Forgery (SSRF) vulnerability in elFinder before 2.1.46 could allow a malicious user to access the content of internal network resources. This occurs in get_remote_contents() in php/elFinder.class.php."}, {"lang": "es", "value": "Una vulnerabilidad de SSRF (Server-Side Request Forgery) en elFinder, en versiones anteriores a la 2.1.46, podr\u00eda permitir a un usuario malicioso acceder al contenido de los recursos de la red interna. Esto ocurre en get_remote_contents() en php/elFinder.class.php."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.7, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.1, "impactScore": 4.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-918"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:std42:elfinder:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.1.46", "matchCriteriaId": "BD436629-59BB-4084-A0EA-8863DBF0CA85"}]}]}], "references": [{"url": "https://github.com/Studio-42/elFinder/blob/68ec63c0aeca3963101aca8f842dc9f2e4c4c6d3/Changelog", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/Studio-42/elFinder/commit/2f522db8f037a66ce9040ee0b216aa4a0359286c", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Studio-42/elFinder/commit/2f522db8f037a66ce9040ee0b216aa4a0359286c"}}