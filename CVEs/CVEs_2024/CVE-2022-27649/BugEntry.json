{"buggy_code": ["package libpod\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/containers/common/pkg/capabilities\"\n\t\"github.com/containers/common/pkg/config\"\n\t\"github.com/containers/podman/v4/libpod/define\"\n\t\"github.com/containers/podman/v4/pkg/errorhandling\"\n\t\"github.com/containers/podman/v4/pkg/lookup\"\n\t\"github.com/containers/podman/v4/pkg/util\"\n\t\"github.com/containers/podman/v4/utils\"\n\tspec \"github.com/opencontainers/runtime-spec/specs-go\"\n\t\"github.com/pkg/errors\"\n\t\"github.com/sirupsen/logrus\"\n\t\"golang.org/x/sys/unix\"\n)\n\n// ExecContainer executes a command in a running container\nfunc (r *ConmonOCIRuntime) ExecContainer(c *Container, sessionID string, options *ExecOptions, streams *define.AttachStreams, newSize *define.TerminalSize) (int, chan error, error) {\n\tif options == nil {\n\t\treturn -1, nil, errors.Wrapf(define.ErrInvalidArg, \"must provide an ExecOptions struct to ExecContainer\")\n\t}\n\tif len(options.Cmd) == 0 {\n\t\treturn -1, nil, errors.Wrapf(define.ErrInvalidArg, \"must provide a command to execute\")\n\t}\n\n\tif sessionID == \"\" {\n\t\treturn -1, nil, errors.Wrapf(define.ErrEmptyID, \"must provide a session ID for exec\")\n\t}\n\n\t// TODO: Should we default this to false?\n\t// Or maybe make streams mandatory?\n\tattachStdin := true\n\tif streams != nil {\n\t\tattachStdin = streams.AttachInput\n\t}\n\n\tvar ociLog string\n\tif logrus.GetLevel() != logrus.DebugLevel && r.supportsJSON {\n\t\tociLog = c.execOCILog(sessionID)\n\t}\n\n\texecCmd, pipes, err := r.startExec(c, sessionID, options, attachStdin, ociLog)\n\tif err != nil {\n\t\treturn -1, nil, err\n\t}\n\n\t// Only close sync pipe. Start and attach are consumed in the attach\n\t// goroutine.\n\tdefer func() {\n\t\tif pipes.syncPipe != nil && !pipes.syncClosed {\n\t\t\terrorhandling.CloseQuiet(pipes.syncPipe)\n\t\t\tpipes.syncClosed = true\n\t\t}\n\t}()\n\n\t// TODO Only create if !detach\n\t// Attach to the container before starting it\n\tattachChan := make(chan error)\n\tgo func() {\n\t\t// attachToExec is responsible for closing pipes\n\t\tattachChan <- c.attachToExec(streams, options.DetachKeys, sessionID, pipes.startPipe, pipes.attachPipe, newSize)\n\t\tclose(attachChan)\n\t}()\n\n\tif err := execCmd.Wait(); err != nil {\n\t\treturn -1, nil, errors.Wrapf(err, \"cannot run conmon\")\n\t}\n\n\tpid, err := readConmonPipeData(r.name, pipes.syncPipe, ociLog)\n\n\treturn pid, attachChan, err\n}\n\n// ExecContainerHTTP executes a new command in an existing container and\n// forwards its standard streams over an attach\nfunc (r *ConmonOCIRuntime) ExecContainerHTTP(ctr *Container, sessionID string, options *ExecOptions, req *http.Request, w http.ResponseWriter,\n\tstreams *HTTPAttachStreams, cancel <-chan bool, hijackDone chan<- bool, holdConnOpen <-chan bool, newSize *define.TerminalSize) (int, chan error, error) {\n\tif streams != nil {\n\t\tif !streams.Stdin && !streams.Stdout && !streams.Stderr {\n\t\t\treturn -1, nil, errors.Wrapf(define.ErrInvalidArg, \"must provide at least one stream to attach to\")\n\t\t}\n\t}\n\n\tif options == nil {\n\t\treturn -1, nil, errors.Wrapf(define.ErrInvalidArg, \"must provide exec options to ExecContainerHTTP\")\n\t}\n\n\tdetachString := config.DefaultDetachKeys\n\tif options.DetachKeys != nil {\n\t\tdetachString = *options.DetachKeys\n\t}\n\tdetachKeys, err := processDetachKeys(detachString)\n\tif err != nil {\n\t\treturn -1, nil, err\n\t}\n\n\t// TODO: Should we default this to false?\n\t// Or maybe make streams mandatory?\n\tattachStdin := true\n\tif streams != nil {\n\t\tattachStdin = streams.Stdin\n\t}\n\n\tvar ociLog string\n\tif logrus.GetLevel() != logrus.DebugLevel && r.supportsJSON {\n\t\tociLog = ctr.execOCILog(sessionID)\n\t}\n\n\texecCmd, pipes, err := r.startExec(ctr, sessionID, options, attachStdin, ociLog)\n\tif err != nil {\n\t\treturn -1, nil, err\n\t}\n\n\t// Only close sync pipe. Start and attach are consumed in the attach\n\t// goroutine.\n\tdefer func() {\n\t\tif pipes.syncPipe != nil && !pipes.syncClosed {\n\t\t\terrorhandling.CloseQuiet(pipes.syncPipe)\n\t\t\tpipes.syncClosed = true\n\t\t}\n\t}()\n\n\tattachChan := make(chan error)\n\tconmonPipeDataChan := make(chan conmonPipeData)\n\tgo func() {\n\t\t// attachToExec is responsible for closing pipes\n\t\tattachChan <- attachExecHTTP(ctr, sessionID, req, w, streams, pipes, detachKeys, options.Terminal, cancel, hijackDone, holdConnOpen, execCmd, conmonPipeDataChan, ociLog, newSize, r.name)\n\t\tclose(attachChan)\n\t}()\n\n\t// NOTE: the channel is needed to communicate conmon's data.  In case\n\t// of an error, the error will be written on the hijacked http\n\t// connection such that remote clients will receive the error.\n\tpipeData := <-conmonPipeDataChan\n\n\treturn pipeData.pid, attachChan, pipeData.err\n}\n\n// conmonPipeData contains the data when reading from conmon's pipe.\ntype conmonPipeData struct {\n\tpid int\n\terr error\n}\n\n// ExecContainerDetached executes a command in a running container, but does\n// not attach to it.\nfunc (r *ConmonOCIRuntime) ExecContainerDetached(ctr *Container, sessionID string, options *ExecOptions, stdin bool) (int, error) {\n\tif options == nil {\n\t\treturn -1, errors.Wrapf(define.ErrInvalidArg, \"must provide exec options to ExecContainerHTTP\")\n\t}\n\n\tvar ociLog string\n\tif logrus.GetLevel() != logrus.DebugLevel && r.supportsJSON {\n\t\tociLog = ctr.execOCILog(sessionID)\n\t}\n\n\texecCmd, pipes, err := r.startExec(ctr, sessionID, options, stdin, ociLog)\n\tif err != nil {\n\t\treturn -1, err\n\t}\n\n\tdefer func() {\n\t\tpipes.cleanup()\n\t}()\n\n\t// Wait for Conmon to tell us we're ready to attach.\n\t// We aren't actually *going* to attach, but this means that we're good\n\t// to proceed.\n\tif _, err := readConmonPipeData(r.name, pipes.attachPipe, \"\"); err != nil {\n\t\treturn -1, err\n\t}\n\n\t// Start the exec session\n\tif err := writeConmonPipeData(pipes.startPipe); err != nil {\n\t\treturn -1, err\n\t}\n\n\t// Wait for conmon to succeed, when return.\n\tif err := execCmd.Wait(); err != nil {\n\t\treturn -1, errors.Wrapf(err, \"cannot run conmon\")\n\t}\n\n\tpid, err := readConmonPipeData(r.name, pipes.syncPipe, ociLog)\n\n\treturn pid, err\n}\n\n// ExecAttachResize resizes the TTY of the given exec session.\nfunc (r *ConmonOCIRuntime) ExecAttachResize(ctr *Container, sessionID string, newSize define.TerminalSize) error {\n\tcontrolFile, err := openControlFile(ctr, ctr.execBundlePath(sessionID))\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer controlFile.Close()\n\n\tif _, err = fmt.Fprintf(controlFile, \"%d %d %d\\n\", 1, newSize.Height, newSize.Width); err != nil {\n\t\treturn errors.Wrapf(err, \"failed to write to ctl file to resize terminal\")\n\t}\n\n\treturn nil\n}\n\n// ExecStopContainer stops a given exec session in a running container.\nfunc (r *ConmonOCIRuntime) ExecStopContainer(ctr *Container, sessionID string, timeout uint) error {\n\tpid, err := ctr.getExecSessionPID(sessionID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlogrus.Debugf(\"Going to stop container %s exec session %s\", ctr.ID(), sessionID)\n\n\t// Is the session dead?\n\t// Ping the PID with signal 0 to see if it still exists.\n\tif err := unix.Kill(pid, 0); err != nil {\n\t\tif err == unix.ESRCH {\n\t\t\treturn nil\n\t\t}\n\t\treturn errors.Wrapf(err, \"error pinging container %s exec session %s PID %d with signal 0\", ctr.ID(), sessionID, pid)\n\t}\n\n\tif timeout > 0 {\n\t\t// Use SIGTERM by default, then SIGSTOP after timeout.\n\t\tlogrus.Debugf(\"Killing exec session %s (PID %d) of container %s with SIGTERM\", sessionID, pid, ctr.ID())\n\t\tif err := unix.Kill(pid, unix.SIGTERM); err != nil {\n\t\t\tif err == unix.ESRCH {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\treturn errors.Wrapf(err, \"error killing container %s exec session %s PID %d with SIGTERM\", ctr.ID(), sessionID, pid)\n\t\t}\n\n\t\t// Wait for the PID to stop\n\t\tif err := waitPidStop(pid, time.Duration(timeout)*time.Second); err != nil {\n\t\t\tlogrus.Infof(\"Timed out waiting for container %s exec session %s to stop, resorting to SIGKILL: %v\", ctr.ID(), sessionID, err)\n\t\t} else {\n\t\t\t// No error, container is dead\n\t\t\treturn nil\n\t\t}\n\t}\n\n\t// SIGTERM did not work. On to SIGKILL.\n\tlogrus.Debugf(\"Killing exec session %s (PID %d) of container %s with SIGKILL\", sessionID, pid, ctr.ID())\n\tif err := unix.Kill(pid, unix.SIGTERM); err != nil {\n\t\tif err == unix.ESRCH {\n\t\t\treturn nil\n\t\t}\n\t\treturn errors.Wrapf(err, \"error killing container %s exec session %s PID %d with SIGKILL\", ctr.ID(), sessionID, pid)\n\t}\n\n\t// Wait for the PID to stop\n\tif err := waitPidStop(pid, killContainerTimeout); err != nil {\n\t\treturn errors.Wrapf(err, \"timed out waiting for container %s exec session %s PID %d to stop after SIGKILL\", ctr.ID(), sessionID, pid)\n\t}\n\n\treturn nil\n}\n\n// ExecUpdateStatus checks if the given exec session is still running.\nfunc (r *ConmonOCIRuntime) ExecUpdateStatus(ctr *Container, sessionID string) (bool, error) {\n\tpid, err := ctr.getExecSessionPID(sessionID)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tlogrus.Debugf(\"Checking status of container %s exec session %s\", ctr.ID(), sessionID)\n\n\t// Is the session dead?\n\t// Ping the PID with signal 0 to see if it still exists.\n\tif err := unix.Kill(pid, 0); err != nil {\n\t\tif err == unix.ESRCH {\n\t\t\treturn false, nil\n\t\t}\n\t\treturn false, errors.Wrapf(err, \"error pinging container %s exec session %s PID %d with signal 0\", ctr.ID(), sessionID, pid)\n\t}\n\n\treturn true, nil\n}\n\n// ExecAttachSocketPath is the path to a container's exec session attach socket.\nfunc (r *ConmonOCIRuntime) ExecAttachSocketPath(ctr *Container, sessionID string) (string, error) {\n\t// We don't even use container, so don't validity check it\n\tif sessionID == \"\" {\n\t\treturn \"\", errors.Wrapf(define.ErrInvalidArg, \"must provide a valid session ID to get attach socket path\")\n\t}\n\n\treturn filepath.Join(ctr.execBundlePath(sessionID), \"attach\"), nil\n}\n\n// This contains pipes used by the exec API.\ntype execPipes struct {\n\tsyncPipe     *os.File\n\tsyncClosed   bool\n\tstartPipe    *os.File\n\tstartClosed  bool\n\tattachPipe   *os.File\n\tattachClosed bool\n}\n\nfunc (p *execPipes) cleanup() {\n\tif p.syncPipe != nil && !p.syncClosed {\n\t\terrorhandling.CloseQuiet(p.syncPipe)\n\t\tp.syncClosed = true\n\t}\n\tif p.startPipe != nil && !p.startClosed {\n\t\terrorhandling.CloseQuiet(p.startPipe)\n\t\tp.startClosed = true\n\t}\n\tif p.attachPipe != nil && !p.attachClosed {\n\t\terrorhandling.CloseQuiet(p.attachPipe)\n\t\tp.attachClosed = true\n\t}\n}\n\n// Start an exec session's conmon parent from the given options.\nfunc (r *ConmonOCIRuntime) startExec(c *Container, sessionID string, options *ExecOptions, attachStdin bool, ociLog string) (_ *exec.Cmd, _ *execPipes, deferredErr error) {\n\tpipes := new(execPipes)\n\n\tif options == nil {\n\t\treturn nil, nil, errors.Wrapf(define.ErrInvalidArg, \"must provide an ExecOptions struct to ExecContainer\")\n\t}\n\tif len(options.Cmd) == 0 {\n\t\treturn nil, nil, errors.Wrapf(define.ErrInvalidArg, \"must provide a command to execute\")\n\t}\n\n\tif sessionID == \"\" {\n\t\treturn nil, nil, errors.Wrapf(define.ErrEmptyID, \"must provide a session ID for exec\")\n\t}\n\n\t// create sync pipe to receive the pid\n\tparentSyncPipe, childSyncPipe, err := newPipe()\n\tif err != nil {\n\t\treturn nil, nil, errors.Wrapf(err, \"error creating socket pair\")\n\t}\n\tpipes.syncPipe = parentSyncPipe\n\n\tdefer func() {\n\t\tif deferredErr != nil {\n\t\t\tpipes.cleanup()\n\t\t}\n\t}()\n\n\t// create start pipe to set the cgroup before running\n\t// attachToExec is responsible for closing parentStartPipe\n\tchildStartPipe, parentStartPipe, err := newPipe()\n\tif err != nil {\n\t\treturn nil, nil, errors.Wrapf(err, \"error creating socket pair\")\n\t}\n\tpipes.startPipe = parentStartPipe\n\n\t// create the attach pipe to allow attach socket to be created before\n\t// $RUNTIME exec starts running. This is to make sure we can capture all output\n\t// from the process through that socket, rather than half reading the log, half attaching to the socket\n\t// attachToExec is responsible for closing parentAttachPipe\n\tparentAttachPipe, childAttachPipe, err := newPipe()\n\tif err != nil {\n\t\treturn nil, nil, errors.Wrapf(err, \"error creating socket pair\")\n\t}\n\tpipes.attachPipe = parentAttachPipe\n\n\tchildrenClosed := false\n\tdefer func() {\n\t\tif !childrenClosed {\n\t\t\terrorhandling.CloseQuiet(childSyncPipe)\n\t\t\terrorhandling.CloseQuiet(childAttachPipe)\n\t\t\terrorhandling.CloseQuiet(childStartPipe)\n\t\t}\n\t}()\n\n\truntimeDir, err := util.GetRuntimeDir()\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tfinalEnv := make([]string, 0, len(options.Env))\n\tfor k, v := range options.Env {\n\t\tfinalEnv = append(finalEnv, fmt.Sprintf(\"%s=%s\", k, v))\n\t}\n\n\tprocessFile, err := prepareProcessExec(c, options, finalEnv, sessionID)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tdefer processFile.Close()\n\n\targs := r.sharedConmonArgs(c, sessionID, c.execBundlePath(sessionID), c.execPidPath(sessionID), c.execLogPath(sessionID), c.execExitFileDir(sessionID), ociLog, define.NoLogging, \"\")\n\n\tif options.PreserveFDs > 0 {\n\t\targs = append(args, formatRuntimeOpts(\"--preserve-fds\", fmt.Sprintf(\"%d\", options.PreserveFDs))...)\n\t}\n\n\tif options.Terminal {\n\t\targs = append(args, \"-t\")\n\t}\n\n\tif attachStdin {\n\t\targs = append(args, \"-i\")\n\t}\n\n\t// Append container ID and command\n\targs = append(args, \"-e\")\n\t// TODO make this optional when we can detach\n\targs = append(args, \"--exec-attach\")\n\targs = append(args, \"--exec-process-spec\", processFile.Name())\n\n\tif len(options.ExitCommand) > 0 {\n\t\targs = append(args, \"--exit-command\", options.ExitCommand[0])\n\t\tfor _, arg := range options.ExitCommand[1:] {\n\t\t\targs = append(args, []string{\"--exit-command-arg\", arg}...)\n\t\t}\n\t\tif options.ExitCommandDelay > 0 {\n\t\t\targs = append(args, []string{\"--exit-delay\", fmt.Sprintf(\"%d\", options.ExitCommandDelay)}...)\n\t\t}\n\t}\n\n\tlogrus.WithFields(logrus.Fields{\n\t\t\"args\": args,\n\t}).Debugf(\"running conmon: %s\", r.conmonPath)\n\texecCmd := exec.Command(r.conmonPath, args...)\n\n\t// TODO: This is commented because it doesn't make much sense in HTTP\n\t// attach, and I'm not certain it does for non-HTTP attach as well.\n\t// if streams != nil {\n\t// \t// Don't add the InputStream to the execCmd. Instead, the data should be passed\n\t// \t// through CopyDetachable\n\t// \tif streams.AttachOutput {\n\t// \t\texecCmd.Stdout = options.Streams.OutputStream\n\t// \t}\n\t// \tif streams.AttachError {\n\t// \t\texecCmd.Stderr = options.Streams.ErrorStream\n\t// \t}\n\t// }\n\n\tconmonEnv := r.configureConmonEnv(c, runtimeDir)\n\n\tvar filesToClose []*os.File\n\tif options.PreserveFDs > 0 {\n\t\tfor fd := 3; fd < int(3+options.PreserveFDs); fd++ {\n\t\t\tf := os.NewFile(uintptr(fd), fmt.Sprintf(\"fd-%d\", fd))\n\t\t\tfilesToClose = append(filesToClose, f)\n\t\t\texecCmd.ExtraFiles = append(execCmd.ExtraFiles, f)\n\t\t}\n\t}\n\n\t// we don't want to step on users fds they asked to preserve\n\t// Since 0-2 are used for stdio, start the fds we pass in at preserveFDs+3\n\texecCmd.Env = r.conmonEnv\n\texecCmd.Env = append(execCmd.Env, fmt.Sprintf(\"_OCI_SYNCPIPE=%d\", options.PreserveFDs+3), fmt.Sprintf(\"_OCI_STARTPIPE=%d\", options.PreserveFDs+4), fmt.Sprintf(\"_OCI_ATTACHPIPE=%d\", options.PreserveFDs+5))\n\texecCmd.Env = append(execCmd.Env, conmonEnv...)\n\n\texecCmd.ExtraFiles = append(execCmd.ExtraFiles, childSyncPipe, childStartPipe, childAttachPipe)\n\texecCmd.Dir = c.execBundlePath(sessionID)\n\texecCmd.SysProcAttr = &syscall.SysProcAttr{\n\t\tSetpgid: true,\n\t}\n\n\terr = startCommandGivenSelinux(execCmd, c)\n\n\t// We don't need children pipes  on the parent side\n\terrorhandling.CloseQuiet(childSyncPipe)\n\terrorhandling.CloseQuiet(childAttachPipe)\n\terrorhandling.CloseQuiet(childStartPipe)\n\tchildrenClosed = true\n\n\tif err != nil {\n\t\treturn nil, nil, errors.Wrapf(err, \"cannot start container %s\", c.ID())\n\t}\n\tif err := r.moveConmonToCgroupAndSignal(c, execCmd, parentStartPipe); err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\t// These fds were passed down to the runtime.  Close them\n\t// and not interfere\n\tfor _, f := range filesToClose {\n\t\terrorhandling.CloseQuiet(f)\n\t}\n\n\treturn execCmd, pipes, nil\n}\n\n// Attach to a container over HTTP\nfunc attachExecHTTP(c *Container, sessionID string, r *http.Request, w http.ResponseWriter, streams *HTTPAttachStreams, pipes *execPipes, detachKeys []byte, isTerminal bool, cancel <-chan bool, hijackDone chan<- bool, holdConnOpen <-chan bool, execCmd *exec.Cmd, conmonPipeDataChan chan<- conmonPipeData, ociLog string, newSize *define.TerminalSize, runtimeName string) (deferredErr error) {\n\t// NOTE: As you may notice, the attach code is quite complex.\n\t// Many things happen concurrently and yet are interdependent.\n\t// If you ever change this function, make sure to write to the\n\t// conmonPipeDataChan in case of an error.\n\n\tif pipes == nil || pipes.startPipe == nil || pipes.attachPipe == nil {\n\t\terr := errors.Wrapf(define.ErrInvalidArg, \"must provide a start and attach pipe to finish an exec attach\")\n\t\tconmonPipeDataChan <- conmonPipeData{-1, err}\n\t\treturn err\n\t}\n\n\tdefer func() {\n\t\tif !pipes.startClosed {\n\t\t\terrorhandling.CloseQuiet(pipes.startPipe)\n\t\t\tpipes.startClosed = true\n\t\t}\n\t\tif !pipes.attachClosed {\n\t\t\terrorhandling.CloseQuiet(pipes.attachPipe)\n\t\t\tpipes.attachClosed = true\n\t\t}\n\t}()\n\n\tlogrus.Debugf(\"Attaching to container %s exec session %s\", c.ID(), sessionID)\n\n\t// set up the socket path, such that it is the correct length and location for exec\n\tsockPath, err := c.execAttachSocketPath(sessionID)\n\tif err != nil {\n\t\tconmonPipeDataChan <- conmonPipeData{-1, err}\n\t\treturn err\n\t}\n\n\t// 2: read from attachFd that the parent process has set up the console socket\n\tif _, err := readConmonPipeData(runtimeName, pipes.attachPipe, \"\"); err != nil {\n\t\tconmonPipeDataChan <- conmonPipeData{-1, err}\n\t\treturn err\n\t}\n\n\t// resize before we start the container process\n\tif newSize != nil {\n\t\terr = c.ociRuntime.ExecAttachResize(c, sessionID, *newSize)\n\t\tif err != nil {\n\t\t\tlogrus.Warnf(\"Resize failed: %v\", err)\n\t\t}\n\t}\n\n\t// 2: then attach\n\tconn, err := openUnixSocket(sockPath)\n\tif err != nil {\n\t\tconmonPipeDataChan <- conmonPipeData{-1, err}\n\t\treturn errors.Wrapf(err, \"failed to connect to container's attach socket: %v\", sockPath)\n\t}\n\tdefer func() {\n\t\tif err := conn.Close(); err != nil {\n\t\t\tlogrus.Errorf(\"Unable to close socket: %q\", err)\n\t\t}\n\t}()\n\n\tattachStdout := true\n\tattachStderr := true\n\tattachStdin := true\n\tif streams != nil {\n\t\tattachStdout = streams.Stdout\n\t\tattachStderr = streams.Stderr\n\t\tattachStdin = streams.Stdin\n\t}\n\n\t// Perform hijack\n\thijacker, ok := w.(http.Hijacker)\n\tif !ok {\n\t\tconmonPipeDataChan <- conmonPipeData{-1, err}\n\t\treturn errors.Errorf(\"unable to hijack connection\")\n\t}\n\n\thttpCon, httpBuf, err := hijacker.Hijack()\n\tif err != nil {\n\t\tconmonPipeDataChan <- conmonPipeData{-1, err}\n\t\treturn errors.Wrapf(err, \"error hijacking connection\")\n\t}\n\n\thijackDone <- true\n\n\t// Write a header to let the client know what happened\n\twriteHijackHeader(r, httpBuf)\n\n\t// Force a flush after the header is written.\n\tif err := httpBuf.Flush(); err != nil {\n\t\tconmonPipeDataChan <- conmonPipeData{-1, err}\n\t\treturn errors.Wrapf(err, \"error flushing HTTP hijack header\")\n\t}\n\n\tgo func() {\n\t\t// Wait for conmon to succeed, when return.\n\t\tif err := execCmd.Wait(); err != nil {\n\t\t\tconmonPipeDataChan <- conmonPipeData{-1, err}\n\t\t} else {\n\t\t\tpid, err := readConmonPipeData(runtimeName, pipes.syncPipe, ociLog)\n\t\t\tif err != nil {\n\t\t\t\thijackWriteError(err, c.ID(), isTerminal, httpBuf)\n\t\t\t\tconmonPipeDataChan <- conmonPipeData{pid, err}\n\t\t\t} else {\n\t\t\t\tconmonPipeDataChan <- conmonPipeData{pid, err}\n\t\t\t}\n\t\t}\n\t\t// We need to hold the connection open until the complete exec\n\t\t// function has finished. This channel will be closed in a defer\n\t\t// in that function, so we can wait for it here.\n\t\t// Can't be a defer, because this would block the function from\n\t\t// returning.\n\t\t<-holdConnOpen\n\t\thijackWriteErrorAndClose(deferredErr, c.ID(), isTerminal, httpCon, httpBuf)\n\t}()\n\n\tstdoutChan := make(chan error)\n\tstdinChan := make(chan error)\n\n\t// Next, STDIN. Avoid entirely if attachStdin unset.\n\tif attachStdin {\n\t\tgo func() {\n\t\t\tlogrus.Debugf(\"Beginning STDIN copy\")\n\t\t\t_, err := utils.CopyDetachable(conn, httpBuf, detachKeys)\n\t\t\tlogrus.Debugf(\"STDIN copy completed\")\n\t\t\tstdinChan <- err\n\t\t}()\n\t}\n\n\t// 4: send start message to child\n\tif err := writeConmonPipeData(pipes.startPipe); err != nil {\n\t\treturn err\n\t}\n\n\t// Handle STDOUT/STDERR *after* start message is sent\n\tgo func() {\n\t\tvar err error\n\t\tif isTerminal {\n\t\t\t// Hack: return immediately if attachStdout not set to\n\t\t\t// emulate Docker.\n\t\t\t// Basically, when terminal is set, STDERR goes nowhere.\n\t\t\t// Everything does over STDOUT.\n\t\t\t// Therefore, if not attaching STDOUT - we'll never copy\n\t\t\t// anything from here.\n\t\t\tlogrus.Debugf(\"Performing terminal HTTP attach for container %s\", c.ID())\n\t\t\tif attachStdout {\n\t\t\t\terr = httpAttachTerminalCopy(conn, httpBuf, c.ID())\n\t\t\t}\n\t\t} else {\n\t\t\tlogrus.Debugf(\"Performing non-terminal HTTP attach for container %s\", c.ID())\n\t\t\terr = httpAttachNonTerminalCopy(conn, httpBuf, c.ID(), attachStdin, attachStdout, attachStderr)\n\t\t}\n\t\tstdoutChan <- err\n\t\tlogrus.Debugf(\"STDOUT/ERR copy completed\")\n\t}()\n\n\tfor {\n\t\tselect {\n\t\tcase err := <-stdoutChan:\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\treturn nil\n\t\tcase err := <-stdinChan:\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t// copy stdin is done, close it\n\t\t\tif connErr := conn.CloseWrite(); connErr != nil {\n\t\t\t\tlogrus.Errorf(\"Unable to close conn: %v\", connErr)\n\t\t\t}\n\t\tcase <-cancel:\n\t\t\treturn nil\n\t\t}\n\t}\n}\n\n// prepareProcessExec returns the path of the process.json used in runc exec -p\n// caller is responsible to close the returned *os.File if needed.\nfunc prepareProcessExec(c *Container, options *ExecOptions, env []string, sessionID string) (*os.File, error) {\n\tf, err := ioutil.TempFile(c.execBundlePath(sessionID), \"exec-process-\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpspec := new(spec.Process)\n\tif err := JSONDeepCopy(c.config.Spec.Process, pspec); err != nil {\n\t\treturn nil, err\n\t}\n\tpspec.SelinuxLabel = c.config.ProcessLabel\n\tpspec.Args = options.Cmd\n\n\t// We need to default this to false else it will inherit terminal as true\n\t// from the container.\n\tpspec.Terminal = false\n\tif options.Terminal {\n\t\tpspec.Terminal = true\n\t}\n\tif len(env) > 0 {\n\t\tpspec.Env = append(pspec.Env, env...)\n\t}\n\n\t// Add secret envs if they exist\n\tmanager, err := c.runtime.SecretsManager()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tfor name, secr := range c.config.EnvSecrets {\n\t\t_, data, err := manager.LookupSecretData(secr.Name)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tpspec.Env = append(pspec.Env, fmt.Sprintf(\"%s=%s\", name, string(data)))\n\t}\n\n\tif options.Cwd != \"\" {\n\t\tpspec.Cwd = options.Cwd\n\t}\n\n\tvar addGroups []string\n\tvar sgids []uint32\n\n\t// if the user is empty, we should inherit the user that the container is currently running with\n\tuser := options.User\n\tif user == \"\" {\n\t\tlogrus.Debugf(\"Set user to %s\", c.config.User)\n\t\tuser = c.config.User\n\t\taddGroups = c.config.Groups\n\t}\n\n\toverrides := c.getUserOverrides()\n\texecUser, err := lookup.GetUserGroupInfo(c.state.Mountpoint, user, overrides)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif len(addGroups) > 0 {\n\t\tsgids, err = lookup.GetContainerGroups(addGroups, c.state.Mountpoint, overrides)\n\t\tif err != nil {\n\t\t\treturn nil, errors.Wrapf(err, \"error looking up supplemental groups for container %s exec session %s\", c.ID(), sessionID)\n\t\t}\n\t}\n\n\t// If user was set, look it up in the container to get a UID to use on\n\t// the host\n\tif user != \"\" || len(sgids) > 0 {\n\t\tif user != \"\" {\n\t\t\tfor _, sgid := range execUser.Sgids {\n\t\t\t\tsgids = append(sgids, uint32(sgid))\n\t\t\t}\n\t\t}\n\t\tprocessUser := spec.User{\n\t\t\tUID:            uint32(execUser.Uid),\n\t\t\tGID:            uint32(execUser.Gid),\n\t\t\tAdditionalGids: sgids,\n\t\t}\n\n\t\tpspec.User = processUser\n\t}\n\n\tctrSpec, err := c.specFromState()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tallCaps, err := capabilities.BoundingSet()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif options.Privileged {\n\t\tpspec.Capabilities.Bounding = allCaps\n\t} else {\n\t\tpspec.Capabilities.Bounding = ctrSpec.Process.Capabilities.Bounding\n\t}\n\tif execUser.Uid == 0 {\n\t\tpspec.Capabilities.Effective = pspec.Capabilities.Bounding\n\t\tpspec.Capabilities.Inheritable = pspec.Capabilities.Bounding\n\t\tpspec.Capabilities.Permitted = pspec.Capabilities.Bounding\n\t\tpspec.Capabilities.Ambient = pspec.Capabilities.Bounding\n\t} else {\n\t\tif user == c.config.User {\n\t\t\tpspec.Capabilities.Effective = ctrSpec.Process.Capabilities.Effective\n\t\t\tpspec.Capabilities.Inheritable = ctrSpec.Process.Capabilities.Effective\n\t\t\tpspec.Capabilities.Permitted = ctrSpec.Process.Capabilities.Effective\n\t\t\tpspec.Capabilities.Ambient = ctrSpec.Process.Capabilities.Effective\n\t\t}\n\t}\n\n\thasHomeSet := false\n\tfor _, s := range pspec.Env {\n\t\tif strings.HasPrefix(s, \"HOME=\") {\n\t\t\thasHomeSet = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif !hasHomeSet {\n\t\tpspec.Env = append(pspec.Env, fmt.Sprintf(\"HOME=%s\", execUser.Home))\n\t}\n\n\tprocessJSON, err := json.Marshal(pspec)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := ioutil.WriteFile(f.Name(), processJSON, 0644); err != nil {\n\t\treturn nil, err\n\t}\n\treturn f, nil\n}\n", "package generate\n\nimport (\n\t\"strings\"\n\n\t\"github.com/containers/common/libimage\"\n\t\"github.com/containers/common/pkg/apparmor\"\n\t\"github.com/containers/common/pkg/capabilities\"\n\t\"github.com/containers/common/pkg/config\"\n\t\"github.com/containers/podman/v4/libpod\"\n\t\"github.com/containers/podman/v4/libpod/define\"\n\t\"github.com/containers/podman/v4/pkg/specgen\"\n\t\"github.com/containers/podman/v4/pkg/util\"\n\t\"github.com/opencontainers/runtime-tools/generate\"\n\t\"github.com/opencontainers/selinux/go-selinux/label\"\n\t\"github.com/pkg/errors\"\n\t\"github.com/sirupsen/logrus\"\n)\n\n// setLabelOpts sets the label options of the SecurityConfig according to the\n// input.\nfunc setLabelOpts(s *specgen.SpecGenerator, runtime *libpod.Runtime, pidConfig specgen.Namespace, ipcConfig specgen.Namespace) error {\n\tif !runtime.EnableLabeling() || s.Privileged {\n\t\ts.SelinuxOpts = label.DisableSecOpt()\n\t\treturn nil\n\t}\n\n\tvar labelOpts []string\n\tif pidConfig.IsHost() {\n\t\tlabelOpts = append(labelOpts, label.DisableSecOpt()...)\n\t} else if pidConfig.IsContainer() {\n\t\tctr, err := runtime.LookupContainer(pidConfig.Value)\n\t\tif err != nil {\n\t\t\treturn errors.Wrapf(err, \"container %q not found\", pidConfig.Value)\n\t\t}\n\t\tsecopts, err := label.DupSecOpt(ctr.ProcessLabel())\n\t\tif err != nil {\n\t\t\treturn errors.Wrapf(err, \"failed to duplicate label %q \", ctr.ProcessLabel())\n\t\t}\n\t\tlabelOpts = append(labelOpts, secopts...)\n\t}\n\n\tif ipcConfig.IsHost() {\n\t\tlabelOpts = append(labelOpts, label.DisableSecOpt()...)\n\t} else if ipcConfig.IsContainer() {\n\t\tctr, err := runtime.LookupContainer(ipcConfig.Value)\n\t\tif err != nil {\n\t\t\treturn errors.Wrapf(err, \"container %q not found\", ipcConfig.Value)\n\t\t}\n\t\tsecopts, err := label.DupSecOpt(ctr.ProcessLabel())\n\t\tif err != nil {\n\t\t\treturn errors.Wrapf(err, \"failed to duplicate label %q \", ctr.ProcessLabel())\n\t\t}\n\t\tlabelOpts = append(labelOpts, secopts...)\n\t}\n\n\ts.SelinuxOpts = append(s.SelinuxOpts, labelOpts...)\n\treturn nil\n}\n\nfunc setupApparmor(s *specgen.SpecGenerator, rtc *config.Config, g *generate.Generator) error {\n\thasProfile := len(s.ApparmorProfile) > 0\n\tif !apparmor.IsEnabled() {\n\t\tif hasProfile && s.ApparmorProfile != \"unconfined\" {\n\t\t\treturn errors.Errorf(\"Apparmor profile %q specified, but Apparmor is not enabled on this system\", s.ApparmorProfile)\n\t\t}\n\t\treturn nil\n\t}\n\t// If privileged and caller did not specify apparmor profiles return\n\tif s.Privileged && !hasProfile {\n\t\treturn nil\n\t}\n\tif !hasProfile {\n\t\ts.ApparmorProfile = rtc.Containers.ApparmorProfile\n\t}\n\tif len(s.ApparmorProfile) > 0 {\n\t\tg.SetProcessApparmorProfile(s.ApparmorProfile)\n\t}\n\n\treturn nil\n}\n\nfunc securityConfigureGenerator(s *specgen.SpecGenerator, g *generate.Generator, newImage *libimage.Image, rtc *config.Config) error {\n\tvar (\n\t\tcaplist []string\n\t\terr     error\n\t)\n\t// HANDLE CAPABILITIES\n\t// NOTE: Must happen before SECCOMP\n\tif s.Privileged {\n\t\tg.SetupPrivileged(true)\n\t\tcaplist, err = capabilities.BoundingSet()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tmergedCaps, err := capabilities.MergeCapabilities(rtc.Containers.DefaultCapabilities, s.CapAdd, s.CapDrop)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tboundingSet, err := capabilities.BoundingSet()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tboundingCaps := make(map[string]interface{})\n\t\tfor _, b := range boundingSet {\n\t\t\tboundingCaps[b] = b\n\t\t}\n\t\tfor _, c := range mergedCaps {\n\t\t\tif _, ok := boundingCaps[c]; ok {\n\t\t\t\tcaplist = append(caplist, c)\n\t\t\t}\n\t\t}\n\n\t\tprivCapsRequired := []string{}\n\n\t\t// If the container image specifies an label with a\n\t\t// capabilities.ContainerImageLabel then split the comma separated list\n\t\t// of capabilities and record them.  This list indicates the only\n\t\t// capabilities, required to run the container.\n\t\tvar capsRequiredRequested []string\n\t\tfor key, val := range s.Labels {\n\t\t\tif util.StringInSlice(key, capabilities.ContainerImageLabels) {\n\t\t\t\tcapsRequiredRequested = strings.Split(val, \",\")\n\t\t\t}\n\t\t}\n\t\tif !s.Privileged && len(capsRequiredRequested) > 0 {\n\t\t\t// Pass capRequiredRequested in CapAdd field to normalize capabilities names\n\t\t\tcapsRequired, err := capabilities.MergeCapabilities(nil, capsRequiredRequested, nil)\n\t\t\tif err != nil {\n\t\t\t\treturn errors.Wrapf(err, \"capabilities requested by user or image are not valid: %q\", strings.Join(capsRequired, \",\"))\n\t\t\t}\n\t\t\t// Verify all capRequired are in the capList\n\t\t\tfor _, cap := range capsRequired {\n\t\t\t\tif !util.StringInSlice(cap, caplist) {\n\t\t\t\t\tprivCapsRequired = append(privCapsRequired, cap)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif len(privCapsRequired) == 0 {\n\t\t\t\tcaplist = capsRequired\n\t\t\t} else {\n\t\t\t\tlogrus.Errorf(\"Capabilities requested by user or image are not allowed by default: %q\", strings.Join(privCapsRequired, \",\"))\n\t\t\t}\n\t\t}\n\t}\n\n\tconfigSpec := g.Config\n\tconfigSpec.Process.Capabilities.Ambient = []string{}\n\tconfigSpec.Process.Capabilities.Bounding = caplist\n\n\tuser := strings.Split(s.User, \":\")[0]\n\n\tif (user == \"\" && s.UserNS.NSMode != specgen.KeepID) || user == \"root\" || user == \"0\" {\n\t\tconfigSpec.Process.Capabilities.Effective = caplist\n\t\tconfigSpec.Process.Capabilities.Permitted = caplist\n\t\tconfigSpec.Process.Capabilities.Inheritable = caplist\n\t} else {\n\t\tmergedCaps, err := capabilities.MergeCapabilities(nil, s.CapAdd, nil)\n\t\tif err != nil {\n\t\t\treturn errors.Wrapf(err, \"capabilities requested by user are not valid: %q\", strings.Join(s.CapAdd, \",\"))\n\t\t}\n\t\tboundingSet, err := capabilities.BoundingSet()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tboundingCaps := make(map[string]interface{})\n\t\tfor _, b := range boundingSet {\n\t\t\tboundingCaps[b] = b\n\t\t}\n\t\tvar userCaps []string\n\t\tfor _, c := range mergedCaps {\n\t\t\tif _, ok := boundingCaps[c]; ok {\n\t\t\t\tuserCaps = append(userCaps, c)\n\t\t\t}\n\t\t}\n\t\tconfigSpec.Process.Capabilities.Effective = userCaps\n\t\tconfigSpec.Process.Capabilities.Permitted = userCaps\n\t\tconfigSpec.Process.Capabilities.Inheritable = userCaps\n\n\t\t// Ambient capabilities were added to Linux 4.3.  Set ambient\n\t\t// capabilities only when the kernel supports them.\n\t\tif supportAmbientCapabilities() {\n\t\t\tconfigSpec.Process.Capabilities.Ambient = userCaps\n\t\t}\n\t}\n\n\tg.SetProcessNoNewPrivileges(s.NoNewPrivileges)\n\n\tif err := setupApparmor(s, rtc, g); err != nil {\n\t\treturn err\n\t}\n\n\t// HANDLE SECCOMP\n\tif s.SeccompProfilePath != \"unconfined\" {\n\t\tseccompConfig, err := getSeccompConfig(s, configSpec, newImage)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tconfigSpec.Linux.Seccomp = seccompConfig\n\t}\n\n\t// Clear default Seccomp profile from Generator for unconfined containers\n\t// and privileged containers which do not specify a seccomp profile.\n\tif s.SeccompProfilePath == \"unconfined\" || (s.Privileged && (s.SeccompProfilePath == \"\" || s.SeccompProfilePath == config.SeccompOverridePath || s.SeccompProfilePath == config.SeccompDefaultPath)) {\n\t\tconfigSpec.Linux.Seccomp = nil\n\t}\n\n\tg.SetRootReadonly(s.ReadOnlyFilesystem)\n\n\tnoUseIPC := s.IpcNS.NSMode == specgen.FromContainer || s.IpcNS.NSMode == specgen.FromPod || s.IpcNS.NSMode == specgen.Host\n\tnoUseNet := s.NetNS.NSMode == specgen.FromContainer || s.NetNS.NSMode == specgen.FromPod || s.NetNS.NSMode == specgen.Host\n\tnoUseUTS := s.UtsNS.NSMode == specgen.FromContainer || s.UtsNS.NSMode == specgen.FromPod || s.UtsNS.NSMode == specgen.Host\n\n\t// Add default sysctls\n\tdefaultSysctls, err := util.ValidateSysctls(rtc.Sysctls())\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor sysctlKey, sysctlVal := range defaultSysctls {\n\t\t// Ignore mqueue sysctls if --ipc=host\n\t\tif noUseIPC && strings.HasPrefix(sysctlKey, \"fs.mqueue.\") {\n\t\t\tlogrus.Infof(\"Sysctl %s=%s ignored in containers.conf, since IPC Namespace set to host\", sysctlKey, sysctlVal)\n\n\t\t\tcontinue\n\t\t}\n\n\t\t// Ignore net sysctls if --net=host\n\t\tif noUseNet && strings.HasPrefix(sysctlKey, \"net.\") {\n\t\t\tlogrus.Infof(\"Sysctl %s=%s ignored in containers.conf, since Network Namespace set to host\", sysctlKey, sysctlVal)\n\t\t\tcontinue\n\t\t}\n\n\t\t// Ignore uts sysctls if --uts=host\n\t\tif noUseUTS && (strings.HasPrefix(sysctlKey, \"kernel.domainname\") || strings.HasPrefix(sysctlKey, \"kernel.hostname\")) {\n\t\t\tlogrus.Infof(\"Sysctl %s=%s ignored in containers.conf, since UTS Namespace set to host\", sysctlKey, sysctlVal)\n\t\t\tcontinue\n\t\t}\n\n\t\tg.AddLinuxSysctl(sysctlKey, sysctlVal)\n\t}\n\n\tfor sysctlKey, sysctlVal := range s.Sysctl {\n\t\tif s.IpcNS.IsHost() && strings.HasPrefix(sysctlKey, \"fs.mqueue.\") {\n\t\t\treturn errors.Wrapf(define.ErrInvalidArg, \"sysctl %s=%s can't be set since IPC Namespace set to host\", sysctlKey, sysctlVal)\n\t\t}\n\n\t\t// Ignore net sysctls if --net=host\n\t\tif s.NetNS.IsHost() && strings.HasPrefix(sysctlKey, \"net.\") {\n\t\t\treturn errors.Wrapf(define.ErrInvalidArg, \"sysctl %s=%s can't be set since Network Namespace set to host\", sysctlKey, sysctlVal)\n\t\t}\n\n\t\t// Ignore uts sysctls if --uts=host\n\t\tif s.UtsNS.IsHost() && (strings.HasPrefix(sysctlKey, \"kernel.domainname\") || strings.HasPrefix(sysctlKey, \"kernel.hostname\")) {\n\t\t\treturn errors.Wrapf(define.ErrInvalidArg, \"sysctl %s=%s can't be set since UTS Namespace set to host\", sysctlKey, sysctlVal)\n\t\t}\n\n\t\tg.AddLinuxSysctl(sysctlKey, sysctlVal)\n\t}\n\n\treturn nil\n}\n", "package integration\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/containers/common/pkg/cgroups\"\n\t\"github.com/containers/podman/v4/pkg/rootless\"\n\t. \"github.com/containers/podman/v4/test/utils\"\n\t\"github.com/containers/storage/pkg/stringid\"\n\t\"github.com/mrunalp/fileutils\"\n\t. \"github.com/onsi/ginkgo\"\n\t. \"github.com/onsi/gomega\"\n\t. \"github.com/onsi/gomega/gexec\"\n)\n\nvar _ = Describe(\"Podman run\", func() {\n\tvar (\n\t\ttempdir    string\n\t\terr        error\n\t\tpodmanTest *PodmanTestIntegration\n\t)\n\n\tBeforeEach(func() {\n\t\ttempdir, err = CreateTempDirInTempDir()\n\t\tif err != nil {\n\t\t\tos.Exit(1)\n\t\t}\n\t\tpodmanTest = PodmanTestCreate(tempdir)\n\t\tpodmanTest.Setup()\n\t\tpodmanTest.SeedImages()\n\t})\n\n\tAfterEach(func() {\n\t\tpodmanTest.Cleanup()\n\t\tf := CurrentGinkgoTestDescription()\n\t\tprocessTestResult(f)\n\t})\n\n\tIt(\"podman run a container based on local image\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", ALPINE, \"ls\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t})\n\n\tIt(\"podman run check /run/.containerenv\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", ALPINE, \"cat\", \"/run/.containerenv\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(Equal(\"\"))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--privileged\", \"--name=test1\", ALPINE, \"cat\", \"/run/.containerenv\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"name=\\\"test1\\\"\"))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"image=\\\"\" + ALPINE + \"\\\"\"))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"-v\", \"/:/host\", ALPINE, \"cat\", \"/run/.containerenv\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"graphRootMounted=1\"))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"-v\", \"/:/host\", \"--privileged\", ALPINE, \"cat\", \"/run/.containerenv\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"graphRootMounted=1\"))\n\t})\n\n\tIt(\"podman run a container based on a complex local image name\", func() {\n\t\timageName := strings.TrimPrefix(nginx, \"quay.io/\")\n\t\tsession := podmanTest.Podman([]string{\"run\", imageName, \"ls\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ErrorToString()).ToNot(ContainSubstring(\"Trying to pull\"))\n\t\tExpect(session).Should(Exit(0))\n\t})\n\n\tIt(\"podman run --signature-policy\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--pull=always\", \"--signature-policy\", \"/no/such/file\", ALPINE})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).To(ExitWithError())\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--pull=always\", \"--signature-policy\", \"/etc/containers/policy.json\", ALPINE})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tif IsRemote() {\n\t\t\tExpect(session).To(ExitWithError())\n\t\t\tExpect(session.ErrorToString()).To(ContainSubstring(\"unknown flag\"))\n\t\t} else {\n\t\t\tExpect(session).Should(Exit(0))\n\t\t}\n\t})\n\n\tIt(\"podman run --rm with --restart\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--restart\", \"\", ALPINE})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--restart\", \"no\", ALPINE})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--restart\", \"on-failure\", ALPINE})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--restart\", \"always\", ALPINE})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).To(ExitWithError())\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--restart\", \"unless-stopped\", ALPINE})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).To(ExitWithError())\n\t})\n\n\tIt(\"podman run a container based on on a short name with localhost\", func() {\n\t\ttag := podmanTest.Podman([]string{\"tag\", nginx, \"localhost/libpod/alpine_nginx:latest\"})\n\t\ttag.WaitWithDefaultTimeout()\n\n\t\trmi := podmanTest.Podman([]string{\"rmi\", nginx})\n\t\trmi.WaitWithDefaultTimeout()\n\n\t\tsession := podmanTest.Podman([]string{\"run\", \"libpod/alpine_nginx:latest\", \"ls\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ErrorToString()).ToNot(ContainSubstring(\"Trying to pull\"))\n\t\tExpect(session).Should(Exit(0))\n\t})\n\n\tIt(\"podman container run a container based on on a short name with localhost\", func() {\n\t\ttag := podmanTest.Podman([]string{\"image\", \"tag\", nginx, \"localhost/libpod/alpine_nginx:latest\"})\n\t\ttag.WaitWithDefaultTimeout()\n\n\t\trmi := podmanTest.Podman([]string{\"image\", \"rm\", nginx})\n\t\trmi.WaitWithDefaultTimeout()\n\n\t\tsession := podmanTest.Podman([]string{\"container\", \"run\", \"libpod/alpine_nginx:latest\", \"ls\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ErrorToString()).ToNot(ContainSubstring(\"Trying to pull\"))\n\t\tExpect(session).Should(Exit(0))\n\t})\n\n\tIt(\"podman run a container based on local image with short options\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"-dt\", ALPINE, \"ls\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t})\n\n\tIt(\"podman run a container based on local image with short options and args\", func() {\n\t\t// regression test for #714\n\t\tsession := podmanTest.Podman([]string{\"run\", ALPINE, \"find\", \"/etc\", \"-name\", \"hosts\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"/etc/hosts\"))\n\t})\n\n\tIt(\"podman create pod with name in /etc/hosts\", func() {\n\t\tname := \"test_container\"\n\t\thostname := \"test_hostname\"\n\t\tsession := podmanTest.Podman([]string{\"run\", \"-ti\", \"--rm\", \"--name\", name, \"--hostname\", hostname, ALPINE, \"cat\", \"/etc/hosts\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(name))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(hostname))\n\t})\n\n\tIt(\"podman run a container based on remote image\", func() {\n\t\t// Changing session to rsession\n\t\trsession := podmanTest.Podman([]string{\"run\", \"-dt\", ALPINE, \"ls\"})\n\t\trsession.WaitWithDefaultTimeout()\n\t\tExpect(rsession).Should(Exit(0))\n\n\t\tlock := GetPortLock(\"5000\")\n\t\tdefer lock.Unlock()\n\t\tsession := podmanTest.Podman([]string{\"run\", \"-d\", \"--name\", \"registry\", \"-p\", \"5000:5000\", registry, \"/entrypoint.sh\", \"/etc/docker/registry/config.yml\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\n\t\tif !WaitContainerReady(podmanTest, \"registry\", \"listening on\", 20, 1) {\n\t\t\tSkip(\"Cannot start docker registry.\")\n\t\t}\n\n\t\trun := podmanTest.Podman([]string{\"run\", \"--tls-verify=false\", ALPINE})\n\t\trun.WaitWithDefaultTimeout()\n\t\tExpect(run).Should(Exit(0))\n\t\tExpect(podmanTest.NumberOfContainers()).To(Equal(3))\n\n\t\t// Now registries.conf will be consulted where localhost:5000\n\t\t// is set to be insecure.\n\t\trun = podmanTest.Podman([]string{\"run\", ALPINE})\n\t\trun.WaitWithDefaultTimeout()\n\t\tExpect(run).Should(Exit(0))\n\t})\n\n\tIt(\"podman run a container with a --rootfs\", func() {\n\t\trootfs := filepath.Join(tempdir, \"rootfs\")\n\t\tuls := filepath.Join(\"/\", \"usr\", \"local\", \"share\")\n\t\tuniqueString := stringid.GenerateNonCryptoID()\n\t\ttestFilePath := filepath.Join(uls, uniqueString)\n\t\ttarball := filepath.Join(tempdir, \"rootfs.tar\")\n\n\t\terr := os.Mkdir(rootfs, 0770)\n\t\tExpect(err).Should(BeNil())\n\n\t\t// Change image in predictable way to validate export\n\t\tcsession := podmanTest.Podman([]string{\"run\", \"--name\", uniqueString, ALPINE,\n\t\t\t\"/bin/sh\", \"-c\", fmt.Sprintf(\"echo %s > %s\", uniqueString, testFilePath)})\n\t\tcsession.WaitWithDefaultTimeout()\n\t\tExpect(csession).Should(Exit(0))\n\n\t\t// Export from working container image guarantees working root\n\t\tesession := podmanTest.Podman([]string{\"export\", \"--output\", tarball, uniqueString})\n\t\tesession.WaitWithDefaultTimeout()\n\t\tExpect(esession).Should(Exit(0))\n\t\tExpect(tarball).Should(BeARegularFile())\n\n\t\t// N/B: This will loose any extended attributes like SELinux types\n\t\tfmt.Fprintf(os.Stderr, \"Extracting container root tarball\\n\")\n\t\ttarsession := SystemExec(\"tar\", []string{\"xf\", tarball, \"-C\", rootfs})\n\t\tExpect(tarsession).Should(Exit(0))\n\t\tExpect(filepath.Join(rootfs, uls)).Should(BeADirectory())\n\n\t\t// Other tests confirm SELinux types, just confirm --rootfs is working.\n\t\tsession := podmanTest.Podman([]string{\"run\", \"-i\", \"--security-opt\", \"label=disable\",\n\t\t\t\"--rootfs\", rootfs, \"cat\", testFilePath})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\n\t\t// Validate changes made in original container and export\n\t\tstdoutLines := session.OutputToStringArray()\n\t\tExpect(stdoutLines).Should(HaveLen(1))\n\t\tExpect(stdoutLines[0]).Should(Equal(uniqueString))\n\n\t\tSkipIfRemote(\"External overlay only work locally\")\n\t\tif os.Getenv(\"container\") != \"\" {\n\t\t\tSkip(\"Overlay mounts not supported when running in a container\")\n\t\t}\n\t\tif rootless.IsRootless() {\n\t\t\tif _, err := exec.LookPath(\"fuse-overlayfs\"); err != nil {\n\t\t\t\tSkip(\"Fuse-Overlayfs required for rootless overlay mount test\")\n\t\t\t}\n\t\t}\n\t\t// Test --rootfs with an external overlay\n\t\t// use --rm to remove container and confirm if we did not leak anything\n\t\tosession := podmanTest.Podman([]string{\"run\", \"-i\", \"--rm\", \"--security-opt\", \"label=disable\",\n\t\t\t\"--rootfs\", rootfs + \":O\", \"cat\", testFilePath})\n\t\tosession.WaitWithDefaultTimeout()\n\t\tExpect(osession).Should(Exit(0))\n\n\t\t// Test podman start stop with overlay\n\t\tosession = podmanTest.Podman([]string{\"run\", \"--name\", \"overlay-foo\", \"--security-opt\", \"label=disable\",\n\t\t\t\"--rootfs\", rootfs + \":O\", \"echo\", \"hello\"})\n\t\tosession.WaitWithDefaultTimeout()\n\t\tExpect(osession).Should(Exit(0))\n\n\t\tosession = podmanTest.Podman([]string{\"stop\", \"overlay-foo\"})\n\t\tosession.WaitWithDefaultTimeout()\n\t\tExpect(osession).Should(Exit(0))\n\n\t\tstartsession := podmanTest.Podman([]string{\"start\", \"--attach\", \"overlay-foo\"})\n\t\tstartsession.WaitWithDefaultTimeout()\n\t\tExpect(startsession).Should(Exit(0))\n\t\tExpect(startsession.OutputToString()).To(Equal(\"hello\"))\n\n\t\t// remove container for above test overlay-foo\n\t\tosession = podmanTest.Podman([]string{\"rm\", \"overlay-foo\"})\n\t\tosession.WaitWithDefaultTimeout()\n\t\tExpect(osession).Should(Exit(0))\n\n\t\t// Test --rootfs with an external overlay with --uidmap\n\t\tosession = podmanTest.Podman([]string{\"run\", \"--uidmap\", \"0:1000:1000\", \"--rm\", \"--security-opt\", \"label=disable\",\n\t\t\t\"--rootfs\", rootfs + \":O\", \"echo\", \"hello\"})\n\t\tosession.WaitWithDefaultTimeout()\n\t\tExpect(osession).Should(Exit(0))\n\t\tExpect(osession.OutputToString()).To(Equal(\"hello\"))\n\t})\n\n\tIt(\"podman run a container with --init\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--name\", \"test\", \"--init\", ALPINE, \"ls\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tresult := podmanTest.Podman([]string{\"inspect\", \"test\"})\n\t\tresult.WaitWithDefaultTimeout()\n\t\tExpect(result).Should(Exit(0))\n\t\tconData := result.InspectContainerToJSON()\n\t\tExpect(conData[0].Path).To(Equal(\"/dev/init\"))\n\t\tExpect(conData[0].Config.Annotations).To(HaveKeyWithValue(\"io.podman.annotations.init\", \"TRUE\"))\n\t})\n\n\tIt(\"podman run a container with --init and --init-path\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--name\", \"test\", \"--init\", \"--init-path\", \"/usr/libexec/podman/catatonit\", ALPINE, \"ls\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tresult := podmanTest.Podman([]string{\"inspect\", \"test\"})\n\t\tresult.WaitWithDefaultTimeout()\n\t\tExpect(result).Should(Exit(0))\n\t\tconData := result.InspectContainerToJSON()\n\t\tExpect(conData[0].Path).To(Equal(\"/dev/init\"))\n\t\tExpect(conData[0].Config.Annotations).To(HaveKeyWithValue(\"io.podman.annotations.init\", \"TRUE\"))\n\t})\n\n\tIt(\"podman run a container without --init\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--name\", \"test\", ALPINE, \"ls\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tresult := podmanTest.Podman([]string{\"inspect\", \"test\"})\n\t\tresult.WaitWithDefaultTimeout()\n\t\tExpect(result).Should(Exit(0))\n\t\tconData := result.InspectContainerToJSON()\n\t\tExpect(conData[0].Path).To(Equal(\"ls\"))\n\t\tExpect(conData[0].Config.Annotations).To(HaveKeyWithValue(\"io.podman.annotations.init\", \"FALSE\"))\n\t})\n\n\tforbidGetCWDSeccompProfile := func() string {\n\t\tin := []byte(`{\"defaultAction\":\"SCMP_ACT_ALLOW\",\"syscalls\":[{\"name\":\"getcwd\",\"action\":\"SCMP_ACT_ERRNO\"}]}`)\n\t\tjsonFile, err := podmanTest.CreateSeccompJSON(in)\n\t\tif err != nil {\n\t\t\tfmt.Println(err)\n\t\t\tSkip(\"Failed to prepare seccomp.json for test.\")\n\t\t}\n\t\treturn jsonFile\n\t}\n\n\tIt(\"podman run mask and unmask path test\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"-d\", \"--name=maskCtr1\", \"--security-opt\", \"unmask=ALL\", \"--security-opt\", \"mask=/proc/acpi\", ALPINE, \"sleep\", \"200\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tsession = podmanTest.Podman([]string{\"exec\", \"maskCtr1\", \"ls\", \"/sys/firmware\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.OutputToString()).To(Not(BeEmpty()))\n\t\tExpect(session).Should(Exit(0))\n\t\tsession = podmanTest.Podman([]string{\"exec\", \"maskCtr1\", \"ls\", \"/proc/acpi\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.OutputToString()).To(BeEmpty())\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"-d\", \"--name=maskCtr2\", \"--security-opt\", \"unmask=/proc/acpi:/sys/firmware\", ALPINE, \"sleep\", \"200\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tsession = podmanTest.Podman([]string{\"exec\", \"maskCtr2\", \"ls\", \"/sys/firmware\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.OutputToString()).To(Not(BeEmpty()))\n\t\tExpect(session).Should(Exit(0))\n\t\tsession = podmanTest.Podman([]string{\"exec\", \"maskCtr2\", \"ls\", \"/proc/acpi\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.OutputToString()).To(Not(BeEmpty()))\n\t\tExpect(session).Should(Exit(0))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"-d\", \"--name=maskCtr3\", \"--security-opt\", \"mask=/sys/power/disk\", ALPINE, \"sleep\", \"200\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tsession = podmanTest.Podman([]string{\"exec\", \"maskCtr3\", \"cat\", \"/sys/power/disk\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.OutputToString()).To(BeEmpty())\n\t\tExpect(session).Should(Exit(0))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"-d\", \"--name=maskCtr4\", \"--security-opt\", \"systempaths=unconfined\", ALPINE, \"sleep\", \"200\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tsession = podmanTest.Podman([]string{\"exec\", \"maskCtr4\", \"ls\", \"/sys/firmware\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.OutputToString()).To(Not(BeEmpty()))\n\t\tExpect(session).Should(Exit(0))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"-d\", \"--name=maskCtr5\", \"--security-opt\", \"systempaths=unconfined\", ALPINE, \"grep\", \"/proc\", \"/proc/self/mounts\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToStringArray()).Should(HaveLen(1))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"-d\", \"--security-opt\", \"unmask=/proc/*\", ALPINE, \"grep\", \"/proc\", \"/proc/self/mounts\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToStringArray()).Should(HaveLen(1))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--security-opt\", \"unmask=/proc/a*\", ALPINE, \"ls\", \"/proc/acpi\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(Not(BeEmpty()))\n\t})\n\n\tIt(\"podman run security-opt unmask on /sys/fs/cgroup\", func() {\n\n\t\tSkipIfCgroupV1(\"podman umask on /sys/fs/cgroup will fail with cgroups V1\")\n\t\tSkipIfRootless(\"/sys/fs/cgroup rw access is needed\")\n\t\trwOnCgroups := \"/sys/fs/cgroup cgroup2 rw\"\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--security-opt\", \"unmask=ALL\", \"--security-opt\", \"mask=/sys/fs/cgroup\", ALPINE, \"cat\", \"/proc/mounts\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(rwOnCgroups))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--security-opt\", \"unmask=/sys/fs/cgroup\", ALPINE, \"cat\", \"/proc/mounts\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(rwOnCgroups))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--security-opt\", \"unmask=/sys/fs/cgroup///\", ALPINE, \"cat\", \"/proc/mounts\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(rwOnCgroups))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--security-opt\", \"unmask=ALL\", ALPINE, \"cat\", \"/proc/mounts\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(rwOnCgroups))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--security-opt\", \"unmask=/sys/fs/cgroup\", \"--security-opt\", \"mask=/sys/fs/cgroup\", ALPINE, \"cat\", \"/proc/mounts\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(rwOnCgroups))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--security-opt\", \"unmask=/sys/fs/cgroup\", ALPINE, \"ls\", \"/sys/fs/cgroup\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).ToNot(BeEmpty())\n\t})\n\n\tIt(\"podman run seccomp test\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"-it\", \"--security-opt\", strings.Join([]string{\"seccomp=\", forbidGetCWDSeccompProfile()}, \"\"), ALPINE, \"pwd\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).To(ExitWithError())\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"Operation not permitted\"))\n\t})\n\n\tIt(\"podman run seccomp test --privileged\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"-it\", \"--privileged\", \"--security-opt\", strings.Join([]string{\"seccomp=\", forbidGetCWDSeccompProfile()}, \"\"), ALPINE, \"pwd\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).To(ExitWithError())\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"Operation not permitted\"))\n\t})\n\n\tIt(\"podman run seccomp test --privileged no profile should be unconfined\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"-it\", \"--privileged\", ALPINE, \"grep\", \"Seccomp\", \"/proc/self/status\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"0\"))\n\t\tExpect(session).Should(Exit(0))\n\t})\n\n\tIt(\"podman run seccomp test no profile should be default\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"-it\", ALPINE, \"grep\", \"Seccomp\", \"/proc/self/status\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"2\"))\n\t\tExpect(session).Should(Exit(0))\n\t})\n\n\tIt(\"podman run capabilities test\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--cap-add\", \"all\", ALPINE, \"cat\", \"/proc/self/status\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--cap-add\", \"sys_admin\", ALPINE, \"cat\", \"/proc/self/status\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--cap-drop\", \"all\", ALPINE, \"cat\", \"/proc/self/status\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--cap-drop\", \"setuid\", ALPINE, \"cat\", \"/proc/self/status\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t})\n\n\tIt(\"podman run user capabilities test\", func() {\n\t\t// We need to ignore the containers.conf on the test distribution for this test\n\t\tos.Setenv(\"CONTAINERS_CONF\", \"/dev/null\")\n\t\tif IsRemote() {\n\t\t\tpodmanTest.RestartRemoteService()\n\t\t}\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--user\", \"bin\", ALPINE, \"grep\", \"CapBnd\", \"/proc/self/status\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"00000000a80425fb\"))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--user\", \"bin\", ALPINE, \"grep\", \"CapEff\", \"/proc/self/status\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"0000000000000000\"))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--user\", \"bin\", ALPINE, \"grep\", \"CapInh\", \"/proc/self/status\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"0000000000000000\"))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--user\", \"root\", ALPINE, \"grep\", \"CapBnd\", \"/proc/self/status\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"00000000a80425fb\"))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--user\", \"root\", ALPINE, \"grep\", \"CapEff\", \"/proc/self/status\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"00000000a80425fb\"))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--user\", \"root\", ALPINE, \"grep\", \"CapInh\", \"/proc/self/status\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"00000000a80425fb\"))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", ALPINE, \"grep\", \"CapBnd\", \"/proc/self/status\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"00000000a80425fb\"))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", ALPINE, \"grep\", \"CapEff\", \"/proc/self/status\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"00000000a80425fb\"))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--user=1000:1000\", \"--cap-add=DAC_OVERRIDE\", \"--rm\", ALPINE, \"grep\", \"CapAmb\", \"/proc/self/status\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"0000000000000002\"))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--user=1000:1000\", \"--cap-add=DAC_OVERRIDE\", \"--rm\", ALPINE, \"grep\", \"CapInh\", \"/proc/self/status\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"0000000000000002\"))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--user=0\", \"--cap-add=DAC_OVERRIDE\", \"--rm\", ALPINE, \"grep\", \"CapAmb\", \"/proc/self/status\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"0000000000000000\"))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--user=0:0\", \"--cap-add=DAC_OVERRIDE\", \"--rm\", ALPINE, \"grep\", \"CapAmb\", \"/proc/self/status\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"0000000000000000\"))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--user=0:0\", \"--cap-add=DAC_OVERRIDE\", \"--rm\", ALPINE, \"grep\", \"CapInh\", \"/proc/self/status\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"00000000a80425fb\"))\n\n\t\tif os.Geteuid() > 0 {\n\t\t\tif os.Getenv(\"SKIP_USERNS\") != \"\" {\n\t\t\t\tSkip(\"Skip userns tests.\")\n\t\t\t}\n\t\t\tif _, err := os.Stat(\"/proc/self/uid_map\"); err != nil {\n\t\t\t\tSkip(\"User namespaces not supported.\")\n\t\t\t}\n\t\t\tsession = podmanTest.Podman([]string{\"run\", \"--userns=keep-id\", \"--cap-add=DAC_OVERRIDE\", \"--rm\", ALPINE, \"grep\", \"CapAmb\", \"/proc/self/status\"})\n\t\t\tsession.WaitWithDefaultTimeout()\n\t\t\tExpect(session).Should(Exit(0))\n\t\t\tExpect(session.OutputToString()).To(ContainSubstring(\"0000000000000002\"))\n\n\t\t\tsession = podmanTest.Podman([]string{\"run\", \"--userns=keep-id\", \"--privileged\", \"--rm\", ALPINE, \"grep\", \"CapInh\", \"/proc/self/status\"})\n\t\t\tsession.WaitWithDefaultTimeout()\n\t\t\tExpect(session).Should(Exit(0))\n\t\t\tExpect(session.OutputToString()).To(ContainSubstring(\"0000000000000000\"))\n\n\t\t\tsession = podmanTest.Podman([]string{\"run\", \"--userns=keep-id\", \"--cap-add=DAC_OVERRIDE\", \"--rm\", ALPINE, \"grep\", \"CapInh\", \"/proc/self/status\"})\n\t\t\tsession.WaitWithDefaultTimeout()\n\t\t\tExpect(session).Should(Exit(0))\n\t\t\tExpect(session.OutputToString()).To(ContainSubstring(\"0000000000000002\"))\n\t\t}\n\t})\n\n\tIt(\"podman run user capabilities test with image\", func() {\n\t\t// We need to ignore the containers.conf on the test distribution for this test\n\t\tos.Setenv(\"CONTAINERS_CONF\", \"/dev/null\")\n\t\tif IsRemote() {\n\t\t\tpodmanTest.RestartRemoteService()\n\t\t}\n\t\tdockerfile := fmt.Sprintf(`FROM %s\nUSER bin`, BB)\n\t\tpodmanTest.BuildImage(dockerfile, \"test\", \"false\")\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--user\", \"bin\", \"test\", \"grep\", \"CapBnd\", \"/proc/self/status\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"00000000a80425fb\"))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--user\", \"bin\", \"test\", \"grep\", \"CapEff\", \"/proc/self/status\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"0000000000000000\"))\n\t})\n\n\tIt(\"podman run limits test\", func() {\n\t\tSkipIfRootlessCgroupsV1(\"Setting limits not supported on cgroupv1 for rootless users\")\n\n\t\tif !isRootless() {\n\t\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--ulimit\", \"rtprio=99\", \"--cap-add=sys_nice\", fedoraMinimal, \"cat\", \"/proc/self/sched\"})\n\t\t\tsession.WaitWithDefaultTimeout()\n\t\t\tExpect(session).Should(Exit(0))\n\t\t}\n\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--ulimit\", \"nofile=2048:2048\", fedoraMinimal, \"ulimit\", \"-n\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"2048\"))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--ulimit\", \"nofile=1024:1028\", fedoraMinimal, \"ulimit\", \"-n\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"1024\"))\n\n\t\tif !CGROUPSV2 {\n\t\t\t// --oom-kill-disable not supported on cgroups v2.\n\t\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--oom-kill-disable=true\", fedoraMinimal, \"echo\", \"memory-hog\"})\n\t\t\tsession.WaitWithDefaultTimeout()\n\t\t\tExpect(session).Should(Exit(0))\n\t\t}\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--oom-score-adj=111\", fedoraMinimal, \"cat\", \"/proc/self/oom_score_adj\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(Equal(\"111\"))\n\t})\n\n\tIt(\"podman run limits host test\", func() {\n\t\tSkipIfRemote(\"This can only be used for local tests\")\n\n\t\tvar l syscall.Rlimit\n\n\t\terr := syscall.Getrlimit(syscall.RLIMIT_NOFILE, &l)\n\t\tExpect(err).To(BeNil())\n\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--ulimit\", \"host\", fedoraMinimal, \"ulimit\", \"-Hn\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\n\t\tulimitCtrStr := strings.TrimSpace(session.OutputToString())\n\t\tulimitCtr, err := strconv.ParseUint(ulimitCtrStr, 10, 0)\n\t\tExpect(err).To(BeNil())\n\n\t\tExpect(ulimitCtr).Should(BeNumerically(\">=\", l.Max))\n\t})\n\n\tIt(\"podman run with cidfile\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--cidfile\", tempdir + \"cidfile\", ALPINE, \"ls\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\terr := os.Remove(tempdir + \"cidfile\")\n\t\tExpect(err).To(BeNil())\n\t})\n\n\tIt(\"podman run sysctl test\", func() {\n\t\tSkipIfRootless(\"Network sysctls are not available root rootless\")\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--sysctl\", \"net.core.somaxconn=65535\", ALPINE, \"sysctl\", \"net.core.somaxconn\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"net.core.somaxconn = 65535\"))\n\n\t\t// network sysctls should fail if --net=host is set\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--net\", \"host\", \"--rm\", \"--sysctl\", \"net.core.somaxconn=65535\", ALPINE, \"sysctl\", \"net.core.somaxconn\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(125))\n\t})\n\n\tIt(\"podman run blkio-weight test\", func() {\n\t\tSkipIfRootlessCgroupsV1(\"Setting blkio-weight not supported on cgroupv1 for rootless users\")\n\t\tSkipIfRootless(\"By default systemd doesn't delegate io to rootless users\")\n\t\tif CGROUPSV2 {\n\t\t\tif _, err := os.Stat(\"/sys/fs/cgroup/io.stat\"); os.IsNotExist(err) {\n\t\t\t\tSkip(\"Kernel does not have io.stat\")\n\t\t\t}\n\t\t\tif _, err := os.Stat(\"/sys/fs/cgroup/system.slice/io.bfq.weight\"); os.IsNotExist(err) {\n\t\t\t\tSkip(\"Kernel does not support BFQ IO scheduler\")\n\t\t\t}\n\t\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--blkio-weight=15\", ALPINE, \"sh\", \"-c\", \"cat /sys/fs/cgroup/io.bfq.weight\"})\n\t\t\tsession.WaitWithDefaultTimeout()\n\t\t\tExpect(session).Should(Exit(0))\n\t\t\t// there was a documentation issue in the kernel that reported a different range [1-10000] for the io controller.\n\t\t\t// older versions of crun/runc used it.  For the time being allow both versions to pass the test.\n\t\t\t// FIXME: drop \"|51\" once all the runtimes we test have the fix in place.\n\t\t\tExpect(strings.Replace(session.OutputToString(), \"default \", \"\", 1)).To(MatchRegexp(\"15|51\"))\n\t\t} else {\n\t\t\tif _, err := os.Stat(\"/sys/fs/cgroup/blkio/blkio.weight\"); os.IsNotExist(err) {\n\t\t\t\tSkip(\"Kernel does not support blkio.weight\")\n\t\t\t}\n\t\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--blkio-weight=15\", ALPINE, \"cat\", \"/sys/fs/cgroup/blkio/blkio.weight\"})\n\t\t\tsession.WaitWithDefaultTimeout()\n\t\t\tExpect(session).Should(Exit(0))\n\t\t\tExpect(session.OutputToString()).To(ContainSubstring(\"15\"))\n\t\t}\n\t})\n\n\tIt(\"podman run device-read-bps test\", func() {\n\t\tSkipIfRootless(\"FIXME: requested cgroup controller `io` is not available\")\n\t\tSkipIfRootlessCgroupsV1(\"Setting device-read-bps not supported on cgroupv1 for rootless users\")\n\n\t\tvar session *PodmanSessionIntegration\n\n\t\tif CGROUPSV2 {\n\t\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--device-read-bps=/dev/zero:1mb\", ALPINE, \"sh\", \"-c\", \"cat /sys/fs/cgroup/$(sed -e 's|0::||' < /proc/self/cgroup)/io.max\"})\n\t\t} else {\n\t\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--device-read-bps=/dev/zero:1mb\", ALPINE, \"cat\", \"/sys/fs/cgroup/blkio/blkio.throttle.read_bps_device\"})\n\t\t}\n\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tif !CGROUPSV2 { // TODO: Test Simplification.  For now, we only care about exit(0) w/ cgroupsv2\n\t\t\tExpect(session.OutputToString()).To(ContainSubstring(\"1048576\"))\n\t\t}\n\t})\n\n\tIt(\"podman run device-write-bps test\", func() {\n\t\tSkipIfRootless(\"FIXME: requested cgroup controller `io` is not available\")\n\t\tSkipIfRootlessCgroupsV1(\"Setting device-write-bps not supported on cgroupv1 for rootless users\")\n\n\t\tvar session *PodmanSessionIntegration\n\n\t\tif CGROUPSV2 {\n\t\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--device-write-bps=/dev/zero:1mb\", ALPINE, \"sh\", \"-c\", \"cat /sys/fs/cgroup/$(sed -e 's|0::||' < /proc/self/cgroup)/io.max\"})\n\t\t} else {\n\t\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--device-write-bps=/dev/zero:1mb\", ALPINE, \"cat\", \"/sys/fs/cgroup/blkio/blkio.throttle.write_bps_device\"})\n\t\t}\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tif !CGROUPSV2 { // TODO: Test Simplification.  For now, we only care about exit(0) w/ cgroupsv2\n\t\t\tExpect(session.OutputToString()).To(ContainSubstring(\"1048576\"))\n\t\t}\n\t})\n\n\tIt(\"podman run device-read-iops test\", func() {\n\t\tSkipIfRootless(\"FIXME: requested cgroup controller `io` is not available\")\n\t\tSkipIfRootlessCgroupsV1(\"Setting device-read-iops not supported on cgroupv1 for rootless users\")\n\t\tvar session *PodmanSessionIntegration\n\n\t\tif CGROUPSV2 {\n\t\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--device-read-iops=/dev/zero:100\", ALPINE, \"sh\", \"-c\", \"cat /sys/fs/cgroup/$(sed -e 's|0::||' < /proc/self/cgroup)/io.max\"})\n\t\t} else {\n\t\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--device-read-iops=/dev/zero:100\", ALPINE, \"cat\", \"/sys/fs/cgroup/blkio/blkio.throttle.read_iops_device\"})\n\t\t}\n\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tif !CGROUPSV2 { // TODO: Test Simplification.  For now, we only care about exit(0) w/ cgroupsv2\n\t\t\tExpect(session.OutputToString()).To(ContainSubstring(\"100\"))\n\t\t}\n\t})\n\n\tIt(\"podman run device-write-iops test\", func() {\n\t\tSkipIfRootless(\"FIXME: requested cgroup controller `io` is not available\")\n\t\tSkipIfRootlessCgroupsV1(\"Setting device-write-iops not supported on cgroupv1 for rootless users\")\n\t\tvar session *PodmanSessionIntegration\n\n\t\tif CGROUPSV2 {\n\t\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--device-write-iops=/dev/zero:100\", ALPINE, \"sh\", \"-c\", \"cat /sys/fs/cgroup/$(sed -e 's|0::||' < /proc/self/cgroup)/io.max\"})\n\t\t} else {\n\t\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--device-write-iops=/dev/zero:100\", ALPINE, \"cat\", \"/sys/fs/cgroup/blkio/blkio.throttle.write_iops_device\"})\n\t\t}\n\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tif !CGROUPSV2 { // TODO: Test Simplification.  For now, we only care about exit(0) w/ cgroupsv2\n\t\t\tExpect(session.OutputToString()).To(ContainSubstring(\"100\"))\n\t\t}\n\t})\n\n\tIt(\"podman run notify_socket\", func() {\n\t\tSkipIfRemote(\"This can only be used for local tests\")\n\n\t\thost := GetHostDistributionInfo()\n\t\tif host.Distribution != \"rhel\" && host.Distribution != \"centos\" && host.Distribution != \"fedora\" {\n\t\t\tSkip(\"this test requires a working runc\")\n\t\t}\n\t\tsock := filepath.Join(podmanTest.TempDir, \"notify\")\n\t\taddr := net.UnixAddr{\n\t\t\tName: sock,\n\t\t\tNet:  \"unixgram\",\n\t\t}\n\t\tsocket, err := net.ListenUnixgram(\"unixgram\", &addr)\n\t\tExpect(err).To(BeNil())\n\t\tdefer os.Remove(sock)\n\t\tdefer socket.Close()\n\n\t\tos.Setenv(\"NOTIFY_SOCKET\", sock)\n\t\tdefer os.Unsetenv(\"NOTIFY_SOCKET\")\n\n\t\tsession := podmanTest.Podman([]string{\"run\", ALPINE, \"printenv\", \"NOTIFY_SOCKET\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(len(session.OutputToStringArray())).To(BeNumerically(\">\", 0))\n\t})\n\n\tIt(\"podman run log-opt\", func() {\n\t\tlog := filepath.Join(podmanTest.TempDir, \"/container.log\")\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--log-driver\", \"k8s-file\", \"--log-opt\", fmt.Sprintf(\"path=%s\", log), ALPINE, \"ls\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\t_, err := os.Stat(log)\n\t\tExpect(err).To(BeNil())\n\t\t_ = os.Remove(log)\n\t})\n\n\tIt(\"podman run tagged image\", func() {\n\t\tpodmanTest.AddImageToRWStore(BB)\n\t\ttag := podmanTest.Podman([]string{\"tag\", BB, \"bb\"})\n\t\ttag.WaitWithDefaultTimeout()\n\t\tExpect(tag).Should(Exit(0))\n\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"bb\", \"ls\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t})\n\n\tIt(\"podman test hooks\", func() {\n\t\thcheck := \"/run/hookscheck\"\n\t\thooksDir := tempdir + \"/hooks\"\n\t\tos.Mkdir(hooksDir, 0755)\n\t\tfileutils.CopyFile(\"hooks/hooks.json\", hooksDir)\n\t\tos.Setenv(\"HOOK_OPTION\", fmt.Sprintf(\"--hooks-dir=%s\", hooksDir))\n\t\tos.Remove(hcheck)\n\t\tsession := podmanTest.Podman([]string{\"run\", ALPINE, \"ls\"})\n\t\tsession.Wait(10)\n\t\tos.Unsetenv(\"HOOK_OPTION\")\n\t\tExpect(session).Should(Exit(0))\n\t})\n\n\tIt(\"podman run with subscription secrets\", func() {\n\t\tSkipIfRemote(\"--default-mount-file option is not supported in podman-remote\")\n\t\tcontainersDir := filepath.Join(podmanTest.TempDir, \"containers\")\n\t\terr := os.MkdirAll(containersDir, 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\tsecretsDir := filepath.Join(podmanTest.TempDir, \"rhel\", \"secrets\")\n\t\terr = os.MkdirAll(secretsDir, 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\tmountsFile := filepath.Join(containersDir, \"mounts.conf\")\n\t\tmountString := secretsDir + \":/run/secrets\"\n\t\terr = ioutil.WriteFile(mountsFile, []byte(mountString), 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\tsecretsFile := filepath.Join(secretsDir, \"test.txt\")\n\t\tsecretsString := \"Testing secrets mount. I am mounted!\"\n\t\terr = ioutil.WriteFile(secretsFile, []byte(secretsString), 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\ttargetDir := tempdir + \"/symlink/target\"\n\t\terr = os.MkdirAll(targetDir, 0755)\n\t\tExpect(err).To(BeNil())\n\t\tkeyFile := filepath.Join(targetDir, \"key.pem\")\n\t\terr = ioutil.WriteFile(keyFile, []byte(mountString), 0755)\n\t\tExpect(err).To(BeNil())\n\t\texecSession := SystemExec(\"ln\", []string{\"-s\", targetDir, filepath.Join(secretsDir, \"mysymlink\")})\n\t\tExpect(execSession).Should(Exit(0))\n\n\t\tsession := podmanTest.Podman([]string{\"--default-mounts-file=\" + mountsFile, \"run\", \"--rm\", ALPINE, \"cat\", \"/run/secrets/test.txt\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(Equal(secretsString))\n\n\t\tsession = podmanTest.Podman([]string{\"--default-mounts-file=\" + mountsFile, \"run\", \"--rm\", ALPINE, \"ls\", \"/run/secrets/mysymlink\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"key.pem\"))\n\t})\n\n\tIt(\"podman run with FIPS mode secrets\", func() {\n\t\tSkipIfRootless(\"rootless can not manipulate system-fips file\")\n\t\tfipsFile := \"/etc/system-fips\"\n\t\terr = ioutil.WriteFile(fipsFile, []byte{}, 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", ALPINE, \"ls\", \"/run/secrets\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"system-fips\"))\n\n\t\terr = os.Remove(fipsFile)\n\t\tExpect(err).To(BeNil())\n\t})\n\n\tIt(\"podman run without group-add\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", ALPINE, \"id\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(Not(ContainSubstring(\"27(video),777,65533(nogroup)\")))\n\t})\n\n\tIt(\"podman run with group-add\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--group-add=audio\", \"--group-add=nogroup\", \"--group-add=777\", ALPINE, \"id\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"777,65533(nogroup)\"))\n\t})\n\n\tIt(\"podman run with user (default)\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", ALPINE, \"id\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"uid=0(root) gid=0(root)\"))\n\t})\n\n\tIt(\"podman run with user (integer, not in /etc/passwd)\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--user=1234\", ALPINE, \"id\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(Equal(\"uid=1234(1234) gid=0(root)\"))\n\t})\n\n\tIt(\"podman run with user (integer, in /etc/passwd)\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--user=8\", ALPINE, \"id\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"uid=8(mail) gid=12(mail)\"))\n\t})\n\n\tIt(\"podman run with user (username)\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--user=mail\", ALPINE, \"id\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"uid=8(mail) gid=12(mail)\"))\n\t})\n\n\tIt(\"podman run with user:group (username:integer)\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--user=mail:21\", ALPINE, \"id\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(Equal(\"uid=8(mail) gid=21(ftp)\"))\n\t})\n\n\tIt(\"podman run with user:group (integer:groupname)\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--user=8:ftp\", ALPINE, \"id\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(Equal(\"uid=8(mail) gid=21(ftp)\"))\n\t})\n\n\tIt(\"podman run with user, verify caps dropped\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--user=1234\", ALPINE, \"grep\", \"CapEff\", \"/proc/self/status\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tcapEff := strings.Split(session.OutputToString(), \" \")\n\t\tExpect(\"0000000000000000\").To(Equal(capEff[1]))\n\t})\n\n\tIt(\"podman run with attach stdin outputs container ID\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--attach\", \"stdin\", ALPINE, \"printenv\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tps := podmanTest.Podman([]string{\"ps\", \"-aq\", \"--no-trunc\"})\n\t\tps.WaitWithDefaultTimeout()\n\t\tExpect(ps).Should(Exit(0))\n\t\tExpect(ps.OutputToString()).To(ContainSubstring(session.OutputToString()))\n\t})\n\n\tIt(\"podman run with attach stdout does not print stderr\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--attach\", \"stdout\", ALPINE, \"ls\", \"/doesnotexist\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.OutputToString()).To(Equal(\"\"))\n\t})\n\n\tIt(\"podman run with attach stderr does not print stdout\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--attach\", \"stderr\", ALPINE, \"ls\", \"/\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(Equal(\"\"))\n\t})\n\n\tIt(\"podman run attach nonsense errors\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--attach\", \"asdfasdf\", ALPINE, \"ls\", \"/\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(125))\n\t})\n\n\tIt(\"podman run exit code on failure to exec\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", ALPINE, \"/etc\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(126))\n\t})\n\n\tIt(\"podman run error on exec\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", ALPINE, \"sh\", \"-c\", \"exit 100\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(100))\n\t})\n\n\tIt(\"podman run with named volume\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", ALPINE, \"stat\", \"-c\", \"%a %Y\", \"/var/tmp\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tperms := session.OutputToString()\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"-v\", \"test:/var/tmp\", ALPINE, \"stat\", \"-c\", \"%a %Y\", \"/var/tmp\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(Equal(perms))\n\t})\n\n\tIt(\"podman run with built-in volume image\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", redis, \"ls\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\n\t\tdockerfile := fmt.Sprintf(`FROM %s\nRUN mkdir -p /myvol/data && chown -R mail.0 /myvol\nVOLUME [\"/myvol/data\"]\nUSER mail`, BB)\n\n\t\tpodmanTest.BuildImage(dockerfile, \"test\", \"false\")\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"test\", \"ls\", \"-al\", \"/myvol/data\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"mail root\"))\n\t})\n\n\tIt(\"podman run --volumes-from flag\", func() {\n\t\tvol := filepath.Join(podmanTest.TempDir, \"vol-test\")\n\t\terr := os.MkdirAll(vol, 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\tfilename := \"test.txt\"\n\t\tvolFile := filepath.Join(vol, filename)\n\t\tdata := \"Testing --volumes-from!!!\"\n\t\terr = ioutil.WriteFile(volFile, []byte(data), 0755)\n\t\tExpect(err).To(BeNil())\n\t\tmountpoint := \"/myvol/\"\n\n\t\tsession := podmanTest.Podman([]string{\"create\", \"--volume\", vol + \":\" + mountpoint + \":z\", ALPINE, \"cat\", mountpoint + filename})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tctrID := session.OutputToString()\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--volumes-from\", ctrID, ALPINE, \"cat\", mountpoint + filename})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(Equal(data))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--volumes-from\", ctrID, ALPINE, \"sh\", \"-c\", \"echo test >> \" + mountpoint + filename})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\n\t\tsession = podmanTest.Podman([]string{\"start\", \"--attach\", ctrID})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(Equal(data + \"test\"))\n\t})\n\n\tIt(\"podman run --volumes-from flag options\", func() {\n\t\tvol := filepath.Join(podmanTest.TempDir, \"vol-test\")\n\t\terr := os.MkdirAll(vol, 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\tfilename := \"test.txt\"\n\t\tvolFile := filepath.Join(vol, filename)\n\t\tdata := \"Testing --volumes-from!!!\"\n\t\terr = ioutil.WriteFile(volFile, []byte(data), 0755)\n\t\tExpect(err).To(BeNil())\n\t\tmountpoint := \"/myvol/\"\n\n\t\tsession := podmanTest.Podman([]string{\"create\", \"--volume\", vol + \":\" + mountpoint, ALPINE, \"cat\", mountpoint + filename})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tctrID := session.OutputToString()\n\n\t\t// check that the read only option works\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--volumes-from\", ctrID + \":ro\", ALPINE, \"touch\", mountpoint + \"abc.txt\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(1))\n\t\tExpect(session.ErrorToString()).To(ContainSubstring(\"Read-only file system\"))\n\n\t\t// check that both z and ro options work\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--volumes-from\", ctrID + \":ro,z\", ALPINE, \"cat\", mountpoint + filename})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(Equal(data))\n\n\t\t// check that multiple ro/rw are not working\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--volumes-from\", ctrID + \":ro,rw\", ALPINE, \"cat\", mountpoint + filename})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(125))\n\t\tExpect(session.ErrorToString()).To(ContainSubstring(\"cannot set ro or rw options more than once\"))\n\n\t\t// check that multiple z options are not working\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--volumes-from\", ctrID + \":z,z,ro\", ALPINE, \"cat\", mountpoint + filename})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(125))\n\t\tExpect(session.ErrorToString()).To(ContainSubstring(\"cannot set :z more than once in mount options\"))\n\n\t\t// create new read only volume\n\t\tsession = podmanTest.Podman([]string{\"create\", \"--volume\", vol + \":\" + mountpoint + \":ro\", ALPINE, \"cat\", mountpoint + filename})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tctrID = session.OutputToString()\n\n\t\t// check if the original volume was mounted as read only that --volumes-from also mount it as read only\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--volumes-from\", ctrID, ALPINE, \"touch\", mountpoint + \"abc.txt\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(1))\n\t\tExpect(session.ErrorToString()).To(ContainSubstring(\"Read-only file system\"))\n\t})\n\n\tIt(\"podman run --volumes-from flag with built-in volumes\", func() {\n\t\tsession := podmanTest.Podman([]string{\"create\", redis, \"sh\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tctrID := session.OutputToString()\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--volumes-from\", ctrID, ALPINE, \"ls\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"data\"))\n\t})\n\n\tIt(\"podman run --volumes flag with multiple volumes\", func() {\n\t\tvol1 := filepath.Join(podmanTest.TempDir, \"vol-test1\")\n\t\terr := os.MkdirAll(vol1, 0755)\n\t\tExpect(err).To(BeNil())\n\t\tvol2 := filepath.Join(podmanTest.TempDir, \"vol-test2\")\n\t\terr = os.MkdirAll(vol2, 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--volume\", vol1 + \":/myvol1:z\", \"--volume\", vol2 + \":/myvol2:z\", ALPINE, \"touch\", \"/myvol2/foo.txt\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t})\n\n\tIt(\"podman run --volumes flag with empty host dir\", func() {\n\t\tvol1 := filepath.Join(podmanTest.TempDir, \"vol-test1\")\n\t\terr := os.MkdirAll(vol1, 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--volume\", \":/myvol1:z\", ALPINE, \"touch\", \"/myvol2/foo.txt\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).To(ExitWithError())\n\t\tExpect(session.ErrorToString()).To(ContainSubstring(\"directory cannot be empty\"))\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--volume\", vol1 + \":\", ALPINE, \"touch\", \"/myvol2/foo.txt\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).To(ExitWithError())\n\t\tExpect(session.ErrorToString()).To(ContainSubstring(\"directory cannot be empty\"))\n\t})\n\n\tIt(\"podman run --mount flag with multiple mounts\", func() {\n\t\tvol1 := filepath.Join(podmanTest.TempDir, \"vol-test1\")\n\t\terr := os.MkdirAll(vol1, 0755)\n\t\tExpect(err).To(BeNil())\n\t\tvol2 := filepath.Join(podmanTest.TempDir, \"vol-test2\")\n\t\terr = os.MkdirAll(vol2, 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--mount\", \"type=bind,src=\" + vol1 + \",target=/myvol1,z\", \"--mount\", \"type=bind,src=\" + vol2 + \",target=/myvol2,z\", ALPINE, \"touch\", \"/myvol2/foo.txt\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t})\n\n\tIt(\"podman run findmnt nothing shared\", func() {\n\t\tvol1 := filepath.Join(podmanTest.TempDir, \"vol-test1\")\n\t\terr := os.MkdirAll(vol1, 0755)\n\t\tExpect(err).To(BeNil())\n\t\tvol2 := filepath.Join(podmanTest.TempDir, \"vol-test2\")\n\t\terr = os.MkdirAll(vol2, 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--volume\", vol1 + \":/myvol1:z\", \"--volume\", vol2 + \":/myvol2:z\", fedoraMinimal, \"findmnt\", \"-o\", \"TARGET,PROPAGATION\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(Not(ContainSubstring(\"shared\")))\n\t})\n\n\tIt(\"podman run findmnt shared\", func() {\n\t\tvol1 := filepath.Join(podmanTest.TempDir, \"vol-test1\")\n\t\terr := os.MkdirAll(vol1, 0755)\n\t\tExpect(err).To(BeNil())\n\t\tvol2 := filepath.Join(podmanTest.TempDir, \"vol-test2\")\n\t\terr = os.MkdirAll(vol2, 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--volume\", vol1 + \":/myvol1:z\", \"--volume\", vol2 + \":/myvol2:shared,z\", fedoraMinimal, \"findmnt\", \"-o\", \"TARGET,PROPAGATION\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tmatch, shared := session.GrepString(\"shared\")\n\t\tExpect(match).Should(BeTrue())\n\t\t// make sure it's only shared (and not 'shared,slave')\n\t\tisSharedOnly := !strings.Contains(shared[0], \"shared,\")\n\t\tExpect(isSharedOnly).Should(BeTrue())\n\t})\n\n\tIt(\"podman run --security-opts proc-opts=\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--security-opt\", \"proc-opts=nosuid,exec\", fedoraMinimal, \"findmnt\", \"-noOPTIONS\", \"/proc\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\toutput := session.OutputToString()\n\t\tExpect(output).To(ContainSubstring(\"nosuid\"))\n\t\tExpect(output).To(Not(ContainSubstring(\"exec\")))\n\t})\n\n\tIt(\"podman run --mount type=bind,bind-nonrecursive\", func() {\n\t\tSkipIfRootless(\"FIXME: rootless users are not allowed to mount bind-nonrecursive (Could this be a Kernel bug?\")\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--mount\", \"type=bind,bind-nonrecursive,slave,src=/,target=/host\", fedoraMinimal, \"findmnt\", \"-nR\", \"/host\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToStringArray()).To(HaveLen(1))\n\t})\n\n\tIt(\"podman run --mount type=devpts,target=/foo/bar\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--mount\", \"type=devpts,target=/foo/bar\", fedoraMinimal, \"stat\", \"-f\", \"-c%T\", \"/foo/bar\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"devpts\"))\n\t})\n\n\tIt(\"podman run --mount type=devpts,target=/dev/pts with uid, gid and mode\", func() {\n\t\t// runc doesn't seem to honor uid= so avoid testing it\n\t\tsession := podmanTest.Podman([]string{\"run\", \"-t\", \"--mount\", \"type=devpts,target=/dev/pts,uid=1000,gid=1001,mode=123\", fedoraMinimal, \"stat\", \"-c%g-%a\", \"/dev/pts/0\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"1001-123\"))\n\t})\n\n\tIt(\"podman run --pod automatically\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"-d\", \"--pod\", \"new:foobar\", ALPINE, \"nc\", \"-l\", \"-p\", \"8686\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--pod\", \"foobar\", ALPINE, \"/bin/sh\", \"-c\", \"echo test | nc -w 1 127.0.0.1 8686\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\n\t\tcheck := podmanTest.Podman([]string{\"pod\", \"ps\", \"--no-trunc\"})\n\t\tcheck.WaitWithDefaultTimeout()\n\t\tExpect(check.OutputToString()).To(ContainSubstring(\"foobar\"))\n\t})\n\n\tIt(\"podman run --pod new with hostname\", func() {\n\t\thostname := \"abc\"\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--pod\", \"new:foobar\", \"--hostname\", hostname, ALPINE, \"cat\", \"/etc/hostname\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(hostname))\n\t})\n\n\tIt(\"podman run --rm should work\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--name\", \"test\", \"--rm\", ALPINE, \"ls\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tsession = podmanTest.Podman([]string{\"wait\", \"test\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).To(ExitWithError())\n\n\t\tnumContainers := podmanTest.NumberOfContainers()\n\t\tExpect(numContainers).To(Equal(0))\n\t})\n\n\tIt(\"podman run --rm failed container should delete itself\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--name\", \"test\", \"--rm\", ALPINE, \"foo\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).To(ExitWithError())\n\t\tsession = podmanTest.Podman([]string{\"wait\", \"test\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).To(ExitWithError())\n\n\t\tnumContainers := podmanTest.NumberOfContainers()\n\t\tExpect(numContainers).To(Equal(0))\n\t})\n\n\tIt(\"podman run failed container should NOT delete itself\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", ALPINE, \"foo\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).To(ExitWithError())\n\t\t// If remote we could have a race condition\n\t\tsession = podmanTest.Podman([]string{\"wait\", \"test\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).To(ExitWithError())\n\n\t\tnumContainers := podmanTest.NumberOfContainers()\n\t\tExpect(numContainers).To(Equal(1))\n\t})\n\tIt(\"podman run readonly container should NOT mount /dev/shm read/only\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--read-only\", ALPINE, \"mount\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\n\t\tExpect(session.OutputToString()).To(Not(ContainSubstring(\"/dev/shm type tmpfs (ro,\")))\n\t})\n\n\tIt(\"podman run readonly container should NOT mount /run noexec\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--read-only\", ALPINE, \"sh\", \"-c\", \"mount  | grep \\\"/run \\\"\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\n\t\tExpect(session.OutputToString()).To(Not(ContainSubstring(\"noexec\")))\n\t})\n\n\tIt(\"podman run with bad healthcheck retries\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"-dt\", \"--health-cmd\", \"[\\\"foo\\\"]\", \"--health-retries\", \"0\", ALPINE, \"top\"})\n\t\tsession.Wait()\n\t\tExpect(session).To(ExitWithError())\n\t\tExpect(session.ErrorToString()).To(ContainSubstring(\"healthcheck-retries must be greater than 0\"))\n\t})\n\n\tIt(\"podman run with bad healthcheck timeout\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"-dt\", \"--health-cmd\", \"foo\", \"--health-timeout\", \"0s\", ALPINE, \"top\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).To(ExitWithError())\n\t\tExpect(session.ErrorToString()).To(ContainSubstring(\"healthcheck-timeout must be at least 1 second\"))\n\t})\n\n\tIt(\"podman run with bad healthcheck start-period\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"-dt\", \"--health-cmd\", \"foo\", \"--health-start-period\", \"-1s\", ALPINE, \"top\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).To(ExitWithError())\n\t\tExpect(session.ErrorToString()).To(ContainSubstring(\"healthcheck-start-period must be 0 seconds or greater\"))\n\t})\n\n\tIt(\"podman run with --add-host and --no-hosts fails\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"-dt\", \"--add-host\", \"test1:127.0.0.1\", \"--no-hosts\", ALPINE, \"top\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).To(ExitWithError())\n\t})\n\n\tIt(\"podman run with restart-policy always restarts containers\", func() {\n\t\ttestDir := filepath.Join(podmanTest.RunRoot, \"restart-test\")\n\t\terr := os.MkdirAll(testDir, 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\taliveFile := filepath.Join(testDir, \"running\")\n\t\tfile, err := os.Create(aliveFile)\n\t\tExpect(err).To(BeNil())\n\t\tfile.Close()\n\n\t\tsession := podmanTest.Podman([]string{\"run\", \"-dt\", \"--restart\", \"always\", \"-v\", fmt.Sprintf(\"%s:/tmp/runroot:Z\", testDir), ALPINE, \"sh\", \"-c\", \"touch /tmp/runroot/ran && while test -r /tmp/runroot/running; do sleep 0.1s; done\"})\n\n\t\tfound := false\n\t\ttestFile := filepath.Join(testDir, \"ran\")\n\t\tfor i := 0; i < 30; i++ {\n\t\t\ttime.Sleep(1 * time.Second)\n\t\t\tif _, err := os.Stat(testFile); err == nil {\n\t\t\t\tfound = true\n\t\t\t\terr = os.Remove(testFile)\n\t\t\t\tExpect(err).To(BeNil())\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tExpect(found).To(BeTrue())\n\n\t\terr = os.Remove(aliveFile)\n\t\tExpect(err).To(BeNil())\n\n\t\tsession.WaitWithDefaultTimeout()\n\n\t\t// 10 seconds to restart the container\n\t\tfound = false\n\t\tfor i := 0; i < 10; i++ {\n\t\t\ttime.Sleep(1 * time.Second)\n\t\t\tif _, err := os.Stat(testFile); err == nil {\n\t\t\t\tfound = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tExpect(found).To(BeTrue())\n\t})\n\n\tIt(\"podman run with cgroups=split\", func() {\n\t\tSkipIfNotSystemd(podmanTest.CgroupManager, \"do not test --cgroups=split if not running on systemd\")\n\t\tSkipIfRootlessCgroupsV1(\"Disable cgroups not supported on cgroupv1 for rootless users\")\n\t\tSkipIfRemote(\"--cgroups=split cannot be used in remote mode\")\n\n\t\tcheckLines := func(lines []string) {\n\t\t\tcgroup := \"\"\n\t\t\tfor _, line := range lines {\n\t\t\t\tparts := strings.SplitN(line, \":\", 3)\n\t\t\t\tif len(parts) < 2 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif !CGROUPSV2 {\n\t\t\t\t\t// ignore unified on cgroup v1.\n\t\t\t\t\t// both runc and crun do not set it.\n\t\t\t\t\t// crun does not set named hierarchies.\n\t\t\t\t\tif parts[1] == \"\" || strings.Contains(parts[1], \"name=\") {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif parts[2] == \"/\" {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif cgroup == \"\" {\n\t\t\t\t\tcgroup = parts[2]\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tExpect(cgroup).To(Equal(parts[2]))\n\t\t\t}\n\t\t}\n\n\t\tcontainer := podmanTest.PodmanSystemdScope([]string{\"run\", \"--rm\", \"--cgroups=split\", ALPINE, \"cat\", \"/proc/self/cgroup\"})\n\t\tcontainer.WaitWithDefaultTimeout()\n\t\tExpect(container).Should(Exit(0))\n\t\tcheckLines(container.OutputToStringArray())\n\n\t\t// check that --cgroups=split is honored also when a container runs in a pod\n\t\tcontainer = podmanTest.PodmanSystemdScope([]string{\"run\", \"--rm\", \"--pod\", \"new:split-test-pod\", \"--cgroups=split\", ALPINE, \"cat\", \"/proc/self/cgroup\"})\n\t\tcontainer.WaitWithDefaultTimeout()\n\t\tExpect(container).Should(Exit(0))\n\t\tcheckLines(container.OutputToStringArray())\n\t})\n\n\tIt(\"podman run with cgroups=disabled runs without cgroups\", func() {\n\t\tSkipIfRootlessCgroupsV1(\"Disable cgroups not supported on cgroupv1 for rootless users\")\n\t\t// Only works on crun\n\t\tif !strings.Contains(podmanTest.OCIRuntime, \"crun\") {\n\t\t\tSkip(\"Test only works on crun\")\n\t\t}\n\n\t\townsCgroup, err := cgroups.UserOwnsCurrentSystemdCgroup()\n\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\tif !ownsCgroup {\n\t\t\t// Podman moves itself to a new cgroup if it doesn't own the current cgroup\n\t\t\tSkip(\"Test only works when Podman owns the current cgroup\")\n\t\t}\n\n\t\ttrim := func(i string) string {\n\t\t\treturn strings.TrimSuffix(i, \"\\n\")\n\t\t}\n\n\t\tcurCgroupsBytes, err := ioutil.ReadFile(\"/proc/self/cgroup\")\n\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\tcurCgroups := trim(string(curCgroupsBytes))\n\t\tfmt.Printf(\"Output:\\n%s\\n\", curCgroups)\n\t\tExpect(curCgroups).ToNot(Equal(\"\"))\n\n\t\tcontainer := podmanTest.Podman([]string{\"run\", \"--cgroupns=host\", \"--cgroups=disabled\", ALPINE, \"cat\", \"/proc/self/cgroup\"})\n\t\tcontainer.WaitWithDefaultTimeout()\n\t\tExpect(container).Should(Exit(0))\n\n\t\tctrCgroups := trim(container.OutputToString())\n\t\tfmt.Printf(\"Output\\n:%s\\n\", ctrCgroups)\n\n\t\tExpect(ctrCgroups).To(Equal(curCgroups))\n\t})\n\n\tIt(\"podman run with cgroups=enabled makes cgroups\", func() {\n\t\tSkipIfRootlessCgroupsV1(\"Enable cgroups not supported on cgroupv1 for rootless users\")\n\t\t// Only works on crun\n\t\tif !strings.Contains(podmanTest.OCIRuntime, \"crun\") {\n\t\t\tSkip(\"Test only works on crun\")\n\t\t}\n\n\t\tcurCgroupsBytes, err := ioutil.ReadFile(\"/proc/self/cgroup\")\n\t\tExpect(err).To(BeNil())\n\t\tvar curCgroups string = string(curCgroupsBytes)\n\t\tfmt.Printf(\"Output:\\n%s\\n\", curCgroups)\n\t\tExpect(curCgroups).To(Not(Equal(\"\")))\n\n\t\tctrName := \"testctr\"\n\t\tcontainer := podmanTest.Podman([]string{\"run\", \"--name\", ctrName, \"-d\", \"--cgroups=enabled\", ALPINE, \"top\"})\n\t\tcontainer.WaitWithDefaultTimeout()\n\t\tExpect(container).Should(Exit(0))\n\n\t\t// Get PID and get cgroups of that PID\n\t\tinspectOut := podmanTest.InspectContainer(ctrName)\n\t\tExpect(inspectOut).To(HaveLen(1))\n\t\tpid := inspectOut[0].State.Pid\n\t\tExpect(pid).To(Not(Equal(0)))\n\n\t\tctrCgroupsBytes, err := ioutil.ReadFile(fmt.Sprintf(\"/proc/%d/cgroup\", pid))\n\t\tExpect(err).To(BeNil())\n\t\tvar ctrCgroups string = string(ctrCgroupsBytes)\n\t\tfmt.Printf(\"Output\\n:%s\\n\", ctrCgroups)\n\t\tExpect(curCgroups).To(Not(Equal(ctrCgroups)))\n\t})\n\n\tIt(\"podman run with cgroups=garbage errors\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"-d\", \"--cgroups=garbage\", ALPINE, \"top\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).To(ExitWithError())\n\t})\n\n\tIt(\"podman run should fail with nonexistent authfile\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--authfile\", \"/tmp/nonexistent\", ALPINE, \"ls\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).To(ExitWithError())\n\t})\n\n\tIt(\"podman run --device-cgroup-rule\", func() {\n\t\tSkipIfRootless(\"rootless users are not allowed to mknod\")\n\t\tdeviceCgroupRule := \"c 42:* rwm\"\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--cap-add\", \"mknod\", \"--name\", \"test\", \"-d\", \"--device-cgroup-rule\", deviceCgroupRule, ALPINE, \"top\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tsession = podmanTest.Podman([]string{\"exec\", \"test\", \"mknod\", \"newDev\", \"c\", \"42\", \"1\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t})\n\n\tIt(\"podman run --replace\", func() {\n\t\t// Make sure we error out with --name.\n\t\tsession := podmanTest.Podman([]string{\"create\", \"--replace\", ALPINE, \"/bin/sh\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(125))\n\n\t\t// Run and replace 5 times in a row the \"same\" container.\n\t\tctrName := \"testCtr\"\n\t\tfor i := 0; i < 5; i++ {\n\t\t\tsession := podmanTest.Podman([]string{\"run\", \"--detach\", \"--replace\", \"--name\", ctrName, ALPINE, \"/bin/sh\"})\n\t\t\tsession.WaitWithDefaultTimeout()\n\t\t\tExpect(session).Should(Exit(0))\n\t\t}\n\t})\n\n\tIt(\"podman run --preserve-fds\", func() {\n\t\tdevNull, err := os.Open(\"/dev/null\")\n\t\tExpect(err).To(BeNil())\n\t\tdefer devNull.Close()\n\t\tfiles := []*os.File{\n\t\t\tdevNull,\n\t\t}\n\t\tsession := podmanTest.PodmanExtraFiles([]string{\"run\", \"--preserve-fds\", \"1\", ALPINE, \"ls\"}, files)\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t})\n\n\tIt(\"podman run --preserve-fds invalid fd\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--preserve-fds\", \"2\", ALPINE})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).To(ExitWithError())\n\t\tExpect(session.ErrorToString()).To(ContainSubstring(\"file descriptor 3 is not available\"))\n\t})\n\n\tIt(\"podman run --privileged and --group-add\", func() {\n\t\tgroupName := \"mail\"\n\t\tsession := podmanTest.Podman([]string{\"run\", \"-t\", \"-i\", \"--group-add\", groupName, \"--privileged\", fedoraMinimal, \"groups\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(groupName))\n\t})\n\n\tIt(\"podman run --tz\", func() {\n\t\ttestDir := filepath.Join(podmanTest.RunRoot, \"tz-test\")\n\t\terr := os.MkdirAll(testDir, 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\ttzFile := filepath.Join(testDir, \"tzfile.txt\")\n\t\tfile, err := os.Create(tzFile)\n\t\tExpect(err).To(BeNil())\n\n\t\t_, err = file.WriteString(\"Hello\")\n\t\tExpect(err).To(BeNil())\n\t\tfile.Close()\n\n\t\tbadTZFile := fmt.Sprintf(\"../../../%s\", tzFile)\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--tz\", badTZFile, \"--rm\", ALPINE, \"date\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).To(ExitWithError())\n\t\tExpect(session.ErrorToString()).To(ContainSubstring(\"error finding timezone for container\"))\n\n\t\terr = os.Remove(tzFile)\n\t\tExpect(err).To(BeNil())\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--tz\", \"foo\", \"--rm\", ALPINE, \"date\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).To(ExitWithError())\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--tz\", \"America\", \"--rm\", ALPINE, \"date\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).To(ExitWithError())\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--tz\", \"Pacific/Honolulu\", \"--rm\", ALPINE, \"date\", \"+'%H %Z'\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"HST\"))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--tz\", \"local\", \"--rm\", ALPINE, \"date\", \"+'%H %Z'\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tt := time.Now()\n\t\tz, _ := t.Zone()\n\t\th := strconv.Itoa(t.Hour())\n\t\tExpect(session.OutputToString()).To(ContainSubstring(z))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(h))\n\n\t})\n\n\tIt(\"podman run verify pids-limit\", func() {\n\t\tSkipIfCgroupV1(\"pids-limit not supported on cgroup V1\")\n\t\tlimit := \"4321\"\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--pids-limit\", limit, \"--net=none\", \"--rm\", ALPINE, \"cat\", \"/sys/fs/cgroup/pids.max\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(limit))\n\t})\n\n\tIt(\"podman run umask\", func() {\n\t\tif !strings.Contains(podmanTest.OCIRuntime, \"crun\") {\n\t\t\tSkip(\"Test only works on crun\")\n\t\t}\n\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", ALPINE, \"sh\", \"-c\", \"umask\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(Equal(\"0022\"))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--umask\", \"0002\", \"--rm\", ALPINE, \"sh\", \"-c\", \"umask\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(Equal(\"0002\"))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--umask\", \"0077\", \"--rm\", fedoraMinimal, \"umask\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(Equal(\"0077\"))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--umask\", \"22\", \"--rm\", ALPINE, \"sh\", \"-c\", \"umask\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(Equal(\"0022\"))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--umask\", \"9999\", \"--rm\", ALPINE, \"sh\", \"-c\", \"umask\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).To(ExitWithError())\n\t\tExpect(session.ErrorToString()).To(ContainSubstring(\"Invalid umask\"))\n\t})\n\n\tIt(\"podman run makes workdir from image\", func() {\n\t\t// BuildImage does not seem to work remote\n\t\tdockerfile := fmt.Sprintf(`FROM %s\nWORKDIR /madethis`, BB)\n\t\tpodmanTest.BuildImage(dockerfile, \"test\", \"false\")\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"test\", \"pwd\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"/madethis\"))\n\t})\n\n\tIt(\"podman run --entrypoint does not use image command\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--entrypoint\", \"/bin/echo\", ALPINE})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\t// We can't guarantee the output is completely empty, some\n\t\t// nonprintables seem to work their way in.\n\t\tExpect(session.OutputToString()).To(Not(ContainSubstring(\"/bin/sh\")))\n\t})\n\n\tIt(\"podman run a container with log-level (lower case)\", func() {\n\t\tsession := podmanTest.Podman([]string{\"--log-level=info\", \"run\", ALPINE, \"ls\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t})\n\n\tIt(\"podman run a container with log-level (upper case)\", func() {\n\t\tsession := podmanTest.Podman([]string{\"--log-level=INFO\", \"run\", ALPINE, \"ls\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t})\n\n\tIt(\"podman run a container with --pull never should fail if no local store\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--pull\", \"never\", \"docker.io/library/debian:latest\", \"ls\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(125))\n\t})\n\n\tIt(\"podman run container with --pull missing and only pull once\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--pull\", \"missing\", cirros, \"ls\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.ErrorToString()).To(ContainSubstring(\"Trying to pull\"))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--pull\", \"missing\", cirros, \"ls\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.ErrorToString()).ToNot(ContainSubstring(\"Trying to pull\"))\n\t})\n\n\tIt(\"podman run container with --pull missing should pull image multiple times\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--pull\", \"always\", cirros, \"ls\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.ErrorToString()).To(ContainSubstring(\"Trying to pull\"))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--pull\", \"always\", cirros, \"ls\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.ErrorToString()).To(ContainSubstring(\"Trying to pull\"))\n\t})\n\n\tIt(\"podman run container with hostname and hostname environment variable\", func() {\n\t\thostnameEnv := \"test123\"\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--hostname\", \"testctr\", \"--env\", fmt.Sprintf(\"HOSTNAME=%s\", hostnameEnv), ALPINE, \"printenv\", \"HOSTNAME\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(hostnameEnv))\n\t})\n\n\tIt(\"podman run --secret\", func() {\n\t\tsecretsString := \"somesecretdata\"\n\t\tsecretFilePath := filepath.Join(podmanTest.TempDir, \"secret\")\n\t\terr := ioutil.WriteFile(secretFilePath, []byte(secretsString), 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\tsession := podmanTest.Podman([]string{\"secret\", \"create\", \"mysecret\", secretFilePath})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--secret\", \"mysecret\", \"--name\", \"secr\", ALPINE, \"cat\", \"/run/secrets/mysecret\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(Equal(secretsString))\n\n\t\tsession = podmanTest.Podman([]string{\"inspect\", \"secr\", \"--format\", \" {{(index .Config.Secrets 0).Name}}\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"mysecret\"))\n\n\t})\n\n\tIt(\"podman run --secret source=mysecret,type=mount\", func() {\n\t\tsecretsString := \"somesecretdata\"\n\t\tsecretFilePath := filepath.Join(podmanTest.TempDir, \"secret\")\n\t\terr := ioutil.WriteFile(secretFilePath, []byte(secretsString), 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\tsession := podmanTest.Podman([]string{\"secret\", \"create\", \"mysecret\", secretFilePath})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--secret\", \"source=mysecret,type=mount\", \"--name\", \"secr\", ALPINE, \"cat\", \"/run/secrets/mysecret\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(Equal(secretsString))\n\n\t\tsession = podmanTest.Podman([]string{\"inspect\", \"secr\", \"--format\", \" {{(index .Config.Secrets 0).Name}}\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"mysecret\"))\n\n\t})\n\n\tIt(\"podman run --secret source=mysecret,type=mount with target\", func() {\n\t\tsecretsString := \"somesecretdata\"\n\t\tsecretFilePath := filepath.Join(podmanTest.TempDir, \"secret\")\n\t\terr := ioutil.WriteFile(secretFilePath, []byte(secretsString), 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\tsession := podmanTest.Podman([]string{\"secret\", \"create\", \"mysecret_target\", secretFilePath})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--secret\", \"source=mysecret_target,type=mount,target=hello\", \"--name\", \"secr_target\", ALPINE, \"cat\", \"/run/secrets/hello\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(Equal(secretsString))\n\n\t\tsession = podmanTest.Podman([]string{\"inspect\", \"secr_target\", \"--format\", \" {{(index .Config.Secrets 0).Name}}\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"mysecret_target\"))\n\n\t})\n\n\tIt(\"podman run --secret source=mysecret,type=mount with target at /tmp\", func() {\n\t\tsecretsString := \"somesecretdata\"\n\t\tsecretFilePath := filepath.Join(podmanTest.TempDir, \"secret\")\n\t\terr := ioutil.WriteFile(secretFilePath, []byte(secretsString), 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\tsession := podmanTest.Podman([]string{\"secret\", \"create\", \"mysecret_target2\", secretFilePath})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--secret\", \"source=mysecret_target2,type=mount,target=/tmp/hello\", \"--name\", \"secr_target2\", ALPINE, \"cat\", \"/tmp/hello\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(Equal(secretsString))\n\n\t\tsession = podmanTest.Podman([]string{\"inspect\", \"secr_target2\", \"--format\", \" {{(index .Config.Secrets 0).Name}}\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"mysecret_target2\"))\n\n\t})\n\n\tIt(\"podman run --secret source=mysecret,type=env\", func() {\n\t\tsecretsString := \"somesecretdata\"\n\t\tsecretFilePath := filepath.Join(podmanTest.TempDir, \"secret\")\n\t\terr := ioutil.WriteFile(secretFilePath, []byte(secretsString), 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\tsession := podmanTest.Podman([]string{\"secret\", \"create\", \"mysecret\", secretFilePath})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--secret\", \"source=mysecret,type=env\", \"--name\", \"secr\", ALPINE, \"printenv\", \"mysecret\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(Equal(secretsString))\n\t})\n\n\tIt(\"podman run --secret target option\", func() {\n\t\tsecretsString := \"somesecretdata\"\n\t\tsecretFilePath := filepath.Join(podmanTest.TempDir, \"secret\")\n\t\terr := ioutil.WriteFile(secretFilePath, []byte(secretsString), 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\tsession := podmanTest.Podman([]string{\"secret\", \"create\", \"mysecret\", secretFilePath})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--secret\", \"source=mysecret,type=env,target=anotherplace\", \"--name\", \"secr\", ALPINE, \"printenv\", \"anotherplace\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(Equal(secretsString))\n\t})\n\n\tIt(\"podman run --secret mount with uid, gid, mode options\", func() {\n\t\tsecretsString := \"somesecretdata\"\n\t\tsecretFilePath := filepath.Join(podmanTest.TempDir, \"secret\")\n\t\terr := ioutil.WriteFile(secretFilePath, []byte(secretsString), 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\tsession := podmanTest.Podman([]string{\"secret\", \"create\", \"mysecret\", secretFilePath})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\n\t\t// check default permissions\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--secret\", \"mysecret\", \"--name\", \"secr\", ALPINE, \"ls\", \"-l\", \"/run/secrets/mysecret\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\toutput := session.OutputToString()\n\t\tExpect(output).To(ContainSubstring(\"-r--r--r--\"))\n\t\tExpect(output).To(ContainSubstring(\"root\"))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--secret\", \"source=mysecret,type=mount,uid=1000,gid=1001,mode=777\", \"--name\", \"secr2\", ALPINE, \"ls\", \"-ln\", \"/run/secrets/mysecret\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\toutput = session.OutputToString()\n\t\tExpect(output).To(ContainSubstring(\"-rwxrwxrwx\"))\n\t\tExpect(output).To(ContainSubstring(\"1000\"))\n\t\tExpect(output).To(ContainSubstring(\"1001\"))\n\t})\n\n\tIt(\"podman run --secret with --user\", func() {\n\t\tsecretsString := \"somesecretdata\"\n\t\tsecretFilePath := filepath.Join(podmanTest.TempDir, \"secret\")\n\t\terr := ioutil.WriteFile(secretFilePath, []byte(secretsString), 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\tsession := podmanTest.Podman([]string{\"secret\", \"create\", \"mysecret\", secretFilePath})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--secret\", \"mysecret\", \"--name\", \"nonroot\", \"--user\", \"200:200\", ALPINE, \"cat\", \"/run/secrets/mysecret\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(Equal(secretsString))\n\t})\n\n\tIt(\"podman run invalid secret option\", func() {\n\t\tsecretsString := \"somesecretdata\"\n\t\tsecretFilePath := filepath.Join(podmanTest.TempDir, \"secret\")\n\t\terr := ioutil.WriteFile(secretFilePath, []byte(secretsString), 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\tsession := podmanTest.Podman([]string{\"secret\", \"create\", \"mysecret\", secretFilePath})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\n\t\t// Invalid type\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--secret\", \"source=mysecret,type=other\", \"--name\", \"secr\", ALPINE, \"printenv\", \"mysecret\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).To(ExitWithError())\n\n\t\t// Invalid option\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--secret\", \"source=mysecret,invalid=invalid\", \"--name\", \"secr\", ALPINE, \"printenv\", \"mysecret\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).To(ExitWithError())\n\n\t\t// Option syntax not valid\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--secret\", \"source=mysecret,type\", \"--name\", \"secr\", ALPINE, \"printenv\", \"mysecret\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).To(ExitWithError())\n\n\t\t// mount option with env type\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--secret\", \"source=mysecret,type=env,uid=1000\", \"--name\", \"secr\", ALPINE, \"printenv\", \"mysecret\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).To(ExitWithError())\n\n\t\t// No source given\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--secret\", \"type=env\", \"--name\", \"secr\", ALPINE, \"printenv\", \"mysecret\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).To(ExitWithError())\n\t})\n\n\tIt(\"podman run --requires\", func() {\n\t\tdepName := \"ctr1\"\n\t\tdepContainer := podmanTest.Podman([]string{\"create\", \"--name\", depName, ALPINE, \"top\"})\n\t\tdepContainer.WaitWithDefaultTimeout()\n\t\tExpect(depContainer).Should(Exit(0))\n\n\t\tmainName := \"ctr2\"\n\t\tmainContainer := podmanTest.Podman([]string{\"run\", \"--name\", mainName, \"--requires\", depName, \"-d\", ALPINE, \"top\"})\n\t\tmainContainer.WaitWithDefaultTimeout()\n\t\tExpect(mainContainer).Should(Exit(0))\n\n\t\tstop := podmanTest.Podman([]string{\"stop\", \"--all\"})\n\t\tstop.WaitWithDefaultTimeout()\n\t\tExpect(stop).Should(Exit(0))\n\n\t\tstart := podmanTest.Podman([]string{\"start\", mainName})\n\t\tstart.WaitWithDefaultTimeout()\n\t\tExpect(start).Should(Exit(0))\n\n\t\trunning := podmanTest.Podman([]string{\"ps\", \"-q\"})\n\t\trunning.WaitWithDefaultTimeout()\n\t\tExpect(running).Should(Exit(0))\n\t\tExpect(running.OutputToStringArray()).To(HaveLen(2))\n\t})\n\n\tIt(\"podman run with pidfile\", func() {\n\t\tSkipIfRemote(\"pidfile not handled by remote\")\n\t\tpidfile := tempdir + \"pidfile\"\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--pidfile\", pidfile, ALPINE, \"ls\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\treadFirstLine := func(path string) string {\n\t\t\tcontent, err := ioutil.ReadFile(path)\n\t\t\tExpect(err).To(BeNil())\n\t\t\treturn strings.Split(string(content), \"\\n\")[0]\n\t\t}\n\t\tcontainerPID := readFirstLine(pidfile)\n\t\t_, err = strconv.Atoi(containerPID) // Make sure it's a proper integer\n\t\tExpect(err).To(BeNil())\n\t})\n\n\tIt(\"podman run check personality support\", func() {\n\t\t// TODO: Remove this as soon as this is merged and made available in our CI https://github.com/opencontainers/runc/pull/3126.\n\t\tif !strings.Contains(podmanTest.OCIRuntime, \"crun\") {\n\t\t\tSkip(\"Test only works on crun\")\n\t\t}\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--personality=LINUX32\", \"--name=testpersonality\", ALPINE, \"uname\", \"-a\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"i686\"))\n\t})\n\n\tIt(\"podman run /dev/shm has nosuid,noexec,nodev\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", ALPINE, \"grep\", \"/dev/shm\", \"/proc/self/mountinfo\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\toutput := session.OutputToString()\n\t\tExpect(output).To(ContainSubstring(\"nosuid\"))\n\t\tExpect(output).To(ContainSubstring(\"noexec\"))\n\t\tExpect(output).To(ContainSubstring(\"nodev\"))\n\t})\n})\n"], "fixing_code": ["package libpod\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/containers/common/pkg/capabilities\"\n\t\"github.com/containers/common/pkg/config\"\n\t\"github.com/containers/podman/v4/libpod/define\"\n\t\"github.com/containers/podman/v4/pkg/errorhandling\"\n\t\"github.com/containers/podman/v4/pkg/lookup\"\n\t\"github.com/containers/podman/v4/pkg/util\"\n\t\"github.com/containers/podman/v4/utils\"\n\tspec \"github.com/opencontainers/runtime-spec/specs-go\"\n\t\"github.com/pkg/errors\"\n\t\"github.com/sirupsen/logrus\"\n\t\"golang.org/x/sys/unix\"\n)\n\n// ExecContainer executes a command in a running container\nfunc (r *ConmonOCIRuntime) ExecContainer(c *Container, sessionID string, options *ExecOptions, streams *define.AttachStreams, newSize *define.TerminalSize) (int, chan error, error) {\n\tif options == nil {\n\t\treturn -1, nil, errors.Wrapf(define.ErrInvalidArg, \"must provide an ExecOptions struct to ExecContainer\")\n\t}\n\tif len(options.Cmd) == 0 {\n\t\treturn -1, nil, errors.Wrapf(define.ErrInvalidArg, \"must provide a command to execute\")\n\t}\n\n\tif sessionID == \"\" {\n\t\treturn -1, nil, errors.Wrapf(define.ErrEmptyID, \"must provide a session ID for exec\")\n\t}\n\n\t// TODO: Should we default this to false?\n\t// Or maybe make streams mandatory?\n\tattachStdin := true\n\tif streams != nil {\n\t\tattachStdin = streams.AttachInput\n\t}\n\n\tvar ociLog string\n\tif logrus.GetLevel() != logrus.DebugLevel && r.supportsJSON {\n\t\tociLog = c.execOCILog(sessionID)\n\t}\n\n\texecCmd, pipes, err := r.startExec(c, sessionID, options, attachStdin, ociLog)\n\tif err != nil {\n\t\treturn -1, nil, err\n\t}\n\n\t// Only close sync pipe. Start and attach are consumed in the attach\n\t// goroutine.\n\tdefer func() {\n\t\tif pipes.syncPipe != nil && !pipes.syncClosed {\n\t\t\terrorhandling.CloseQuiet(pipes.syncPipe)\n\t\t\tpipes.syncClosed = true\n\t\t}\n\t}()\n\n\t// TODO Only create if !detach\n\t// Attach to the container before starting it\n\tattachChan := make(chan error)\n\tgo func() {\n\t\t// attachToExec is responsible for closing pipes\n\t\tattachChan <- c.attachToExec(streams, options.DetachKeys, sessionID, pipes.startPipe, pipes.attachPipe, newSize)\n\t\tclose(attachChan)\n\t}()\n\n\tif err := execCmd.Wait(); err != nil {\n\t\treturn -1, nil, errors.Wrapf(err, \"cannot run conmon\")\n\t}\n\n\tpid, err := readConmonPipeData(r.name, pipes.syncPipe, ociLog)\n\n\treturn pid, attachChan, err\n}\n\n// ExecContainerHTTP executes a new command in an existing container and\n// forwards its standard streams over an attach\nfunc (r *ConmonOCIRuntime) ExecContainerHTTP(ctr *Container, sessionID string, options *ExecOptions, req *http.Request, w http.ResponseWriter,\n\tstreams *HTTPAttachStreams, cancel <-chan bool, hijackDone chan<- bool, holdConnOpen <-chan bool, newSize *define.TerminalSize) (int, chan error, error) {\n\tif streams != nil {\n\t\tif !streams.Stdin && !streams.Stdout && !streams.Stderr {\n\t\t\treturn -1, nil, errors.Wrapf(define.ErrInvalidArg, \"must provide at least one stream to attach to\")\n\t\t}\n\t}\n\n\tif options == nil {\n\t\treturn -1, nil, errors.Wrapf(define.ErrInvalidArg, \"must provide exec options to ExecContainerHTTP\")\n\t}\n\n\tdetachString := config.DefaultDetachKeys\n\tif options.DetachKeys != nil {\n\t\tdetachString = *options.DetachKeys\n\t}\n\tdetachKeys, err := processDetachKeys(detachString)\n\tif err != nil {\n\t\treturn -1, nil, err\n\t}\n\n\t// TODO: Should we default this to false?\n\t// Or maybe make streams mandatory?\n\tattachStdin := true\n\tif streams != nil {\n\t\tattachStdin = streams.Stdin\n\t}\n\n\tvar ociLog string\n\tif logrus.GetLevel() != logrus.DebugLevel && r.supportsJSON {\n\t\tociLog = ctr.execOCILog(sessionID)\n\t}\n\n\texecCmd, pipes, err := r.startExec(ctr, sessionID, options, attachStdin, ociLog)\n\tif err != nil {\n\t\treturn -1, nil, err\n\t}\n\n\t// Only close sync pipe. Start and attach are consumed in the attach\n\t// goroutine.\n\tdefer func() {\n\t\tif pipes.syncPipe != nil && !pipes.syncClosed {\n\t\t\terrorhandling.CloseQuiet(pipes.syncPipe)\n\t\t\tpipes.syncClosed = true\n\t\t}\n\t}()\n\n\tattachChan := make(chan error)\n\tconmonPipeDataChan := make(chan conmonPipeData)\n\tgo func() {\n\t\t// attachToExec is responsible for closing pipes\n\t\tattachChan <- attachExecHTTP(ctr, sessionID, req, w, streams, pipes, detachKeys, options.Terminal, cancel, hijackDone, holdConnOpen, execCmd, conmonPipeDataChan, ociLog, newSize, r.name)\n\t\tclose(attachChan)\n\t}()\n\n\t// NOTE: the channel is needed to communicate conmon's data.  In case\n\t// of an error, the error will be written on the hijacked http\n\t// connection such that remote clients will receive the error.\n\tpipeData := <-conmonPipeDataChan\n\n\treturn pipeData.pid, attachChan, pipeData.err\n}\n\n// conmonPipeData contains the data when reading from conmon's pipe.\ntype conmonPipeData struct {\n\tpid int\n\terr error\n}\n\n// ExecContainerDetached executes a command in a running container, but does\n// not attach to it.\nfunc (r *ConmonOCIRuntime) ExecContainerDetached(ctr *Container, sessionID string, options *ExecOptions, stdin bool) (int, error) {\n\tif options == nil {\n\t\treturn -1, errors.Wrapf(define.ErrInvalidArg, \"must provide exec options to ExecContainerHTTP\")\n\t}\n\n\tvar ociLog string\n\tif logrus.GetLevel() != logrus.DebugLevel && r.supportsJSON {\n\t\tociLog = ctr.execOCILog(sessionID)\n\t}\n\n\texecCmd, pipes, err := r.startExec(ctr, sessionID, options, stdin, ociLog)\n\tif err != nil {\n\t\treturn -1, err\n\t}\n\n\tdefer func() {\n\t\tpipes.cleanup()\n\t}()\n\n\t// Wait for Conmon to tell us we're ready to attach.\n\t// We aren't actually *going* to attach, but this means that we're good\n\t// to proceed.\n\tif _, err := readConmonPipeData(r.name, pipes.attachPipe, \"\"); err != nil {\n\t\treturn -1, err\n\t}\n\n\t// Start the exec session\n\tif err := writeConmonPipeData(pipes.startPipe); err != nil {\n\t\treturn -1, err\n\t}\n\n\t// Wait for conmon to succeed, when return.\n\tif err := execCmd.Wait(); err != nil {\n\t\treturn -1, errors.Wrapf(err, \"cannot run conmon\")\n\t}\n\n\tpid, err := readConmonPipeData(r.name, pipes.syncPipe, ociLog)\n\n\treturn pid, err\n}\n\n// ExecAttachResize resizes the TTY of the given exec session.\nfunc (r *ConmonOCIRuntime) ExecAttachResize(ctr *Container, sessionID string, newSize define.TerminalSize) error {\n\tcontrolFile, err := openControlFile(ctr, ctr.execBundlePath(sessionID))\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer controlFile.Close()\n\n\tif _, err = fmt.Fprintf(controlFile, \"%d %d %d\\n\", 1, newSize.Height, newSize.Width); err != nil {\n\t\treturn errors.Wrapf(err, \"failed to write to ctl file to resize terminal\")\n\t}\n\n\treturn nil\n}\n\n// ExecStopContainer stops a given exec session in a running container.\nfunc (r *ConmonOCIRuntime) ExecStopContainer(ctr *Container, sessionID string, timeout uint) error {\n\tpid, err := ctr.getExecSessionPID(sessionID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlogrus.Debugf(\"Going to stop container %s exec session %s\", ctr.ID(), sessionID)\n\n\t// Is the session dead?\n\t// Ping the PID with signal 0 to see if it still exists.\n\tif err := unix.Kill(pid, 0); err != nil {\n\t\tif err == unix.ESRCH {\n\t\t\treturn nil\n\t\t}\n\t\treturn errors.Wrapf(err, \"error pinging container %s exec session %s PID %d with signal 0\", ctr.ID(), sessionID, pid)\n\t}\n\n\tif timeout > 0 {\n\t\t// Use SIGTERM by default, then SIGSTOP after timeout.\n\t\tlogrus.Debugf(\"Killing exec session %s (PID %d) of container %s with SIGTERM\", sessionID, pid, ctr.ID())\n\t\tif err := unix.Kill(pid, unix.SIGTERM); err != nil {\n\t\t\tif err == unix.ESRCH {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\treturn errors.Wrapf(err, \"error killing container %s exec session %s PID %d with SIGTERM\", ctr.ID(), sessionID, pid)\n\t\t}\n\n\t\t// Wait for the PID to stop\n\t\tif err := waitPidStop(pid, time.Duration(timeout)*time.Second); err != nil {\n\t\t\tlogrus.Infof(\"Timed out waiting for container %s exec session %s to stop, resorting to SIGKILL: %v\", ctr.ID(), sessionID, err)\n\t\t} else {\n\t\t\t// No error, container is dead\n\t\t\treturn nil\n\t\t}\n\t}\n\n\t// SIGTERM did not work. On to SIGKILL.\n\tlogrus.Debugf(\"Killing exec session %s (PID %d) of container %s with SIGKILL\", sessionID, pid, ctr.ID())\n\tif err := unix.Kill(pid, unix.SIGTERM); err != nil {\n\t\tif err == unix.ESRCH {\n\t\t\treturn nil\n\t\t}\n\t\treturn errors.Wrapf(err, \"error killing container %s exec session %s PID %d with SIGKILL\", ctr.ID(), sessionID, pid)\n\t}\n\n\t// Wait for the PID to stop\n\tif err := waitPidStop(pid, killContainerTimeout); err != nil {\n\t\treturn errors.Wrapf(err, \"timed out waiting for container %s exec session %s PID %d to stop after SIGKILL\", ctr.ID(), sessionID, pid)\n\t}\n\n\treturn nil\n}\n\n// ExecUpdateStatus checks if the given exec session is still running.\nfunc (r *ConmonOCIRuntime) ExecUpdateStatus(ctr *Container, sessionID string) (bool, error) {\n\tpid, err := ctr.getExecSessionPID(sessionID)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tlogrus.Debugf(\"Checking status of container %s exec session %s\", ctr.ID(), sessionID)\n\n\t// Is the session dead?\n\t// Ping the PID with signal 0 to see if it still exists.\n\tif err := unix.Kill(pid, 0); err != nil {\n\t\tif err == unix.ESRCH {\n\t\t\treturn false, nil\n\t\t}\n\t\treturn false, errors.Wrapf(err, \"error pinging container %s exec session %s PID %d with signal 0\", ctr.ID(), sessionID, pid)\n\t}\n\n\treturn true, nil\n}\n\n// ExecAttachSocketPath is the path to a container's exec session attach socket.\nfunc (r *ConmonOCIRuntime) ExecAttachSocketPath(ctr *Container, sessionID string) (string, error) {\n\t// We don't even use container, so don't validity check it\n\tif sessionID == \"\" {\n\t\treturn \"\", errors.Wrapf(define.ErrInvalidArg, \"must provide a valid session ID to get attach socket path\")\n\t}\n\n\treturn filepath.Join(ctr.execBundlePath(sessionID), \"attach\"), nil\n}\n\n// This contains pipes used by the exec API.\ntype execPipes struct {\n\tsyncPipe     *os.File\n\tsyncClosed   bool\n\tstartPipe    *os.File\n\tstartClosed  bool\n\tattachPipe   *os.File\n\tattachClosed bool\n}\n\nfunc (p *execPipes) cleanup() {\n\tif p.syncPipe != nil && !p.syncClosed {\n\t\terrorhandling.CloseQuiet(p.syncPipe)\n\t\tp.syncClosed = true\n\t}\n\tif p.startPipe != nil && !p.startClosed {\n\t\terrorhandling.CloseQuiet(p.startPipe)\n\t\tp.startClosed = true\n\t}\n\tif p.attachPipe != nil && !p.attachClosed {\n\t\terrorhandling.CloseQuiet(p.attachPipe)\n\t\tp.attachClosed = true\n\t}\n}\n\n// Start an exec session's conmon parent from the given options.\nfunc (r *ConmonOCIRuntime) startExec(c *Container, sessionID string, options *ExecOptions, attachStdin bool, ociLog string) (_ *exec.Cmd, _ *execPipes, deferredErr error) {\n\tpipes := new(execPipes)\n\n\tif options == nil {\n\t\treturn nil, nil, errors.Wrapf(define.ErrInvalidArg, \"must provide an ExecOptions struct to ExecContainer\")\n\t}\n\tif len(options.Cmd) == 0 {\n\t\treturn nil, nil, errors.Wrapf(define.ErrInvalidArg, \"must provide a command to execute\")\n\t}\n\n\tif sessionID == \"\" {\n\t\treturn nil, nil, errors.Wrapf(define.ErrEmptyID, \"must provide a session ID for exec\")\n\t}\n\n\t// create sync pipe to receive the pid\n\tparentSyncPipe, childSyncPipe, err := newPipe()\n\tif err != nil {\n\t\treturn nil, nil, errors.Wrapf(err, \"error creating socket pair\")\n\t}\n\tpipes.syncPipe = parentSyncPipe\n\n\tdefer func() {\n\t\tif deferredErr != nil {\n\t\t\tpipes.cleanup()\n\t\t}\n\t}()\n\n\t// create start pipe to set the cgroup before running\n\t// attachToExec is responsible for closing parentStartPipe\n\tchildStartPipe, parentStartPipe, err := newPipe()\n\tif err != nil {\n\t\treturn nil, nil, errors.Wrapf(err, \"error creating socket pair\")\n\t}\n\tpipes.startPipe = parentStartPipe\n\n\t// create the attach pipe to allow attach socket to be created before\n\t// $RUNTIME exec starts running. This is to make sure we can capture all output\n\t// from the process through that socket, rather than half reading the log, half attaching to the socket\n\t// attachToExec is responsible for closing parentAttachPipe\n\tparentAttachPipe, childAttachPipe, err := newPipe()\n\tif err != nil {\n\t\treturn nil, nil, errors.Wrapf(err, \"error creating socket pair\")\n\t}\n\tpipes.attachPipe = parentAttachPipe\n\n\tchildrenClosed := false\n\tdefer func() {\n\t\tif !childrenClosed {\n\t\t\terrorhandling.CloseQuiet(childSyncPipe)\n\t\t\terrorhandling.CloseQuiet(childAttachPipe)\n\t\t\terrorhandling.CloseQuiet(childStartPipe)\n\t\t}\n\t}()\n\n\truntimeDir, err := util.GetRuntimeDir()\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tfinalEnv := make([]string, 0, len(options.Env))\n\tfor k, v := range options.Env {\n\t\tfinalEnv = append(finalEnv, fmt.Sprintf(\"%s=%s\", k, v))\n\t}\n\n\tprocessFile, err := prepareProcessExec(c, options, finalEnv, sessionID)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tdefer processFile.Close()\n\n\targs := r.sharedConmonArgs(c, sessionID, c.execBundlePath(sessionID), c.execPidPath(sessionID), c.execLogPath(sessionID), c.execExitFileDir(sessionID), ociLog, define.NoLogging, \"\")\n\n\tif options.PreserveFDs > 0 {\n\t\targs = append(args, formatRuntimeOpts(\"--preserve-fds\", fmt.Sprintf(\"%d\", options.PreserveFDs))...)\n\t}\n\n\tif options.Terminal {\n\t\targs = append(args, \"-t\")\n\t}\n\n\tif attachStdin {\n\t\targs = append(args, \"-i\")\n\t}\n\n\t// Append container ID and command\n\targs = append(args, \"-e\")\n\t// TODO make this optional when we can detach\n\targs = append(args, \"--exec-attach\")\n\targs = append(args, \"--exec-process-spec\", processFile.Name())\n\n\tif len(options.ExitCommand) > 0 {\n\t\targs = append(args, \"--exit-command\", options.ExitCommand[0])\n\t\tfor _, arg := range options.ExitCommand[1:] {\n\t\t\targs = append(args, []string{\"--exit-command-arg\", arg}...)\n\t\t}\n\t\tif options.ExitCommandDelay > 0 {\n\t\t\targs = append(args, []string{\"--exit-delay\", fmt.Sprintf(\"%d\", options.ExitCommandDelay)}...)\n\t\t}\n\t}\n\n\tlogrus.WithFields(logrus.Fields{\n\t\t\"args\": args,\n\t}).Debugf(\"running conmon: %s\", r.conmonPath)\n\texecCmd := exec.Command(r.conmonPath, args...)\n\n\t// TODO: This is commented because it doesn't make much sense in HTTP\n\t// attach, and I'm not certain it does for non-HTTP attach as well.\n\t// if streams != nil {\n\t// \t// Don't add the InputStream to the execCmd. Instead, the data should be passed\n\t// \t// through CopyDetachable\n\t// \tif streams.AttachOutput {\n\t// \t\texecCmd.Stdout = options.Streams.OutputStream\n\t// \t}\n\t// \tif streams.AttachError {\n\t// \t\texecCmd.Stderr = options.Streams.ErrorStream\n\t// \t}\n\t// }\n\n\tconmonEnv := r.configureConmonEnv(c, runtimeDir)\n\n\tvar filesToClose []*os.File\n\tif options.PreserveFDs > 0 {\n\t\tfor fd := 3; fd < int(3+options.PreserveFDs); fd++ {\n\t\t\tf := os.NewFile(uintptr(fd), fmt.Sprintf(\"fd-%d\", fd))\n\t\t\tfilesToClose = append(filesToClose, f)\n\t\t\texecCmd.ExtraFiles = append(execCmd.ExtraFiles, f)\n\t\t}\n\t}\n\n\t// we don't want to step on users fds they asked to preserve\n\t// Since 0-2 are used for stdio, start the fds we pass in at preserveFDs+3\n\texecCmd.Env = r.conmonEnv\n\texecCmd.Env = append(execCmd.Env, fmt.Sprintf(\"_OCI_SYNCPIPE=%d\", options.PreserveFDs+3), fmt.Sprintf(\"_OCI_STARTPIPE=%d\", options.PreserveFDs+4), fmt.Sprintf(\"_OCI_ATTACHPIPE=%d\", options.PreserveFDs+5))\n\texecCmd.Env = append(execCmd.Env, conmonEnv...)\n\n\texecCmd.ExtraFiles = append(execCmd.ExtraFiles, childSyncPipe, childStartPipe, childAttachPipe)\n\texecCmd.Dir = c.execBundlePath(sessionID)\n\texecCmd.SysProcAttr = &syscall.SysProcAttr{\n\t\tSetpgid: true,\n\t}\n\n\terr = startCommandGivenSelinux(execCmd, c)\n\n\t// We don't need children pipes  on the parent side\n\terrorhandling.CloseQuiet(childSyncPipe)\n\terrorhandling.CloseQuiet(childAttachPipe)\n\terrorhandling.CloseQuiet(childStartPipe)\n\tchildrenClosed = true\n\n\tif err != nil {\n\t\treturn nil, nil, errors.Wrapf(err, \"cannot start container %s\", c.ID())\n\t}\n\tif err := r.moveConmonToCgroupAndSignal(c, execCmd, parentStartPipe); err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\t// These fds were passed down to the runtime.  Close them\n\t// and not interfere\n\tfor _, f := range filesToClose {\n\t\terrorhandling.CloseQuiet(f)\n\t}\n\n\treturn execCmd, pipes, nil\n}\n\n// Attach to a container over HTTP\nfunc attachExecHTTP(c *Container, sessionID string, r *http.Request, w http.ResponseWriter, streams *HTTPAttachStreams, pipes *execPipes, detachKeys []byte, isTerminal bool, cancel <-chan bool, hijackDone chan<- bool, holdConnOpen <-chan bool, execCmd *exec.Cmd, conmonPipeDataChan chan<- conmonPipeData, ociLog string, newSize *define.TerminalSize, runtimeName string) (deferredErr error) {\n\t// NOTE: As you may notice, the attach code is quite complex.\n\t// Many things happen concurrently and yet are interdependent.\n\t// If you ever change this function, make sure to write to the\n\t// conmonPipeDataChan in case of an error.\n\n\tif pipes == nil || pipes.startPipe == nil || pipes.attachPipe == nil {\n\t\terr := errors.Wrapf(define.ErrInvalidArg, \"must provide a start and attach pipe to finish an exec attach\")\n\t\tconmonPipeDataChan <- conmonPipeData{-1, err}\n\t\treturn err\n\t}\n\n\tdefer func() {\n\t\tif !pipes.startClosed {\n\t\t\terrorhandling.CloseQuiet(pipes.startPipe)\n\t\t\tpipes.startClosed = true\n\t\t}\n\t\tif !pipes.attachClosed {\n\t\t\terrorhandling.CloseQuiet(pipes.attachPipe)\n\t\t\tpipes.attachClosed = true\n\t\t}\n\t}()\n\n\tlogrus.Debugf(\"Attaching to container %s exec session %s\", c.ID(), sessionID)\n\n\t// set up the socket path, such that it is the correct length and location for exec\n\tsockPath, err := c.execAttachSocketPath(sessionID)\n\tif err != nil {\n\t\tconmonPipeDataChan <- conmonPipeData{-1, err}\n\t\treturn err\n\t}\n\n\t// 2: read from attachFd that the parent process has set up the console socket\n\tif _, err := readConmonPipeData(runtimeName, pipes.attachPipe, \"\"); err != nil {\n\t\tconmonPipeDataChan <- conmonPipeData{-1, err}\n\t\treturn err\n\t}\n\n\t// resize before we start the container process\n\tif newSize != nil {\n\t\terr = c.ociRuntime.ExecAttachResize(c, sessionID, *newSize)\n\t\tif err != nil {\n\t\t\tlogrus.Warnf(\"Resize failed: %v\", err)\n\t\t}\n\t}\n\n\t// 2: then attach\n\tconn, err := openUnixSocket(sockPath)\n\tif err != nil {\n\t\tconmonPipeDataChan <- conmonPipeData{-1, err}\n\t\treturn errors.Wrapf(err, \"failed to connect to container's attach socket: %v\", sockPath)\n\t}\n\tdefer func() {\n\t\tif err := conn.Close(); err != nil {\n\t\t\tlogrus.Errorf(\"Unable to close socket: %q\", err)\n\t\t}\n\t}()\n\n\tattachStdout := true\n\tattachStderr := true\n\tattachStdin := true\n\tif streams != nil {\n\t\tattachStdout = streams.Stdout\n\t\tattachStderr = streams.Stderr\n\t\tattachStdin = streams.Stdin\n\t}\n\n\t// Perform hijack\n\thijacker, ok := w.(http.Hijacker)\n\tif !ok {\n\t\tconmonPipeDataChan <- conmonPipeData{-1, err}\n\t\treturn errors.Errorf(\"unable to hijack connection\")\n\t}\n\n\thttpCon, httpBuf, err := hijacker.Hijack()\n\tif err != nil {\n\t\tconmonPipeDataChan <- conmonPipeData{-1, err}\n\t\treturn errors.Wrapf(err, \"error hijacking connection\")\n\t}\n\n\thijackDone <- true\n\n\t// Write a header to let the client know what happened\n\twriteHijackHeader(r, httpBuf)\n\n\t// Force a flush after the header is written.\n\tif err := httpBuf.Flush(); err != nil {\n\t\tconmonPipeDataChan <- conmonPipeData{-1, err}\n\t\treturn errors.Wrapf(err, \"error flushing HTTP hijack header\")\n\t}\n\n\tgo func() {\n\t\t// Wait for conmon to succeed, when return.\n\t\tif err := execCmd.Wait(); err != nil {\n\t\t\tconmonPipeDataChan <- conmonPipeData{-1, err}\n\t\t} else {\n\t\t\tpid, err := readConmonPipeData(runtimeName, pipes.syncPipe, ociLog)\n\t\t\tif err != nil {\n\t\t\t\thijackWriteError(err, c.ID(), isTerminal, httpBuf)\n\t\t\t\tconmonPipeDataChan <- conmonPipeData{pid, err}\n\t\t\t} else {\n\t\t\t\tconmonPipeDataChan <- conmonPipeData{pid, err}\n\t\t\t}\n\t\t}\n\t\t// We need to hold the connection open until the complete exec\n\t\t// function has finished. This channel will be closed in a defer\n\t\t// in that function, so we can wait for it here.\n\t\t// Can't be a defer, because this would block the function from\n\t\t// returning.\n\t\t<-holdConnOpen\n\t\thijackWriteErrorAndClose(deferredErr, c.ID(), isTerminal, httpCon, httpBuf)\n\t}()\n\n\tstdoutChan := make(chan error)\n\tstdinChan := make(chan error)\n\n\t// Next, STDIN. Avoid entirely if attachStdin unset.\n\tif attachStdin {\n\t\tgo func() {\n\t\t\tlogrus.Debugf(\"Beginning STDIN copy\")\n\t\t\t_, err := utils.CopyDetachable(conn, httpBuf, detachKeys)\n\t\t\tlogrus.Debugf(\"STDIN copy completed\")\n\t\t\tstdinChan <- err\n\t\t}()\n\t}\n\n\t// 4: send start message to child\n\tif err := writeConmonPipeData(pipes.startPipe); err != nil {\n\t\treturn err\n\t}\n\n\t// Handle STDOUT/STDERR *after* start message is sent\n\tgo func() {\n\t\tvar err error\n\t\tif isTerminal {\n\t\t\t// Hack: return immediately if attachStdout not set to\n\t\t\t// emulate Docker.\n\t\t\t// Basically, when terminal is set, STDERR goes nowhere.\n\t\t\t// Everything does over STDOUT.\n\t\t\t// Therefore, if not attaching STDOUT - we'll never copy\n\t\t\t// anything from here.\n\t\t\tlogrus.Debugf(\"Performing terminal HTTP attach for container %s\", c.ID())\n\t\t\tif attachStdout {\n\t\t\t\terr = httpAttachTerminalCopy(conn, httpBuf, c.ID())\n\t\t\t}\n\t\t} else {\n\t\t\tlogrus.Debugf(\"Performing non-terminal HTTP attach for container %s\", c.ID())\n\t\t\terr = httpAttachNonTerminalCopy(conn, httpBuf, c.ID(), attachStdin, attachStdout, attachStderr)\n\t\t}\n\t\tstdoutChan <- err\n\t\tlogrus.Debugf(\"STDOUT/ERR copy completed\")\n\t}()\n\n\tfor {\n\t\tselect {\n\t\tcase err := <-stdoutChan:\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\treturn nil\n\t\tcase err := <-stdinChan:\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t// copy stdin is done, close it\n\t\t\tif connErr := conn.CloseWrite(); connErr != nil {\n\t\t\t\tlogrus.Errorf(\"Unable to close conn: %v\", connErr)\n\t\t\t}\n\t\tcase <-cancel:\n\t\t\treturn nil\n\t\t}\n\t}\n}\n\n// prepareProcessExec returns the path of the process.json used in runc exec -p\n// caller is responsible to close the returned *os.File if needed.\nfunc prepareProcessExec(c *Container, options *ExecOptions, env []string, sessionID string) (*os.File, error) {\n\tf, err := ioutil.TempFile(c.execBundlePath(sessionID), \"exec-process-\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpspec := new(spec.Process)\n\tif err := JSONDeepCopy(c.config.Spec.Process, pspec); err != nil {\n\t\treturn nil, err\n\t}\n\tpspec.SelinuxLabel = c.config.ProcessLabel\n\tpspec.Args = options.Cmd\n\n\t// We need to default this to false else it will inherit terminal as true\n\t// from the container.\n\tpspec.Terminal = false\n\tif options.Terminal {\n\t\tpspec.Terminal = true\n\t}\n\tif len(env) > 0 {\n\t\tpspec.Env = append(pspec.Env, env...)\n\t}\n\n\t// Add secret envs if they exist\n\tmanager, err := c.runtime.SecretsManager()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tfor name, secr := range c.config.EnvSecrets {\n\t\t_, data, err := manager.LookupSecretData(secr.Name)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tpspec.Env = append(pspec.Env, fmt.Sprintf(\"%s=%s\", name, string(data)))\n\t}\n\n\tif options.Cwd != \"\" {\n\t\tpspec.Cwd = options.Cwd\n\t}\n\n\tvar addGroups []string\n\tvar sgids []uint32\n\n\t// if the user is empty, we should inherit the user that the container is currently running with\n\tuser := options.User\n\tif user == \"\" {\n\t\tlogrus.Debugf(\"Set user to %s\", c.config.User)\n\t\tuser = c.config.User\n\t\taddGroups = c.config.Groups\n\t}\n\n\toverrides := c.getUserOverrides()\n\texecUser, err := lookup.GetUserGroupInfo(c.state.Mountpoint, user, overrides)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif len(addGroups) > 0 {\n\t\tsgids, err = lookup.GetContainerGroups(addGroups, c.state.Mountpoint, overrides)\n\t\tif err != nil {\n\t\t\treturn nil, errors.Wrapf(err, \"error looking up supplemental groups for container %s exec session %s\", c.ID(), sessionID)\n\t\t}\n\t}\n\n\t// If user was set, look it up in the container to get a UID to use on\n\t// the host\n\tif user != \"\" || len(sgids) > 0 {\n\t\tif user != \"\" {\n\t\t\tfor _, sgid := range execUser.Sgids {\n\t\t\t\tsgids = append(sgids, uint32(sgid))\n\t\t\t}\n\t\t}\n\t\tprocessUser := spec.User{\n\t\t\tUID:            uint32(execUser.Uid),\n\t\t\tGID:            uint32(execUser.Gid),\n\t\t\tAdditionalGids: sgids,\n\t\t}\n\n\t\tpspec.User = processUser\n\t}\n\n\tctrSpec, err := c.specFromState()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tallCaps, err := capabilities.BoundingSet()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif options.Privileged {\n\t\tpspec.Capabilities.Bounding = allCaps\n\t} else {\n\t\tpspec.Capabilities.Bounding = ctrSpec.Process.Capabilities.Bounding\n\t}\n\n\t// Always unset the inheritable capabilities similarly to what the Linux kernel does\n\t// They are used only when using capabilities with uid != 0.\n\tpspec.Capabilities.Inheritable = []string{}\n\n\tif execUser.Uid == 0 {\n\t\tpspec.Capabilities.Effective = pspec.Capabilities.Bounding\n\t\tpspec.Capabilities.Permitted = pspec.Capabilities.Bounding\n\t} else {\n\t\tif user == c.config.User {\n\t\t\tpspec.Capabilities.Effective = ctrSpec.Process.Capabilities.Effective\n\t\t\tpspec.Capabilities.Inheritable = ctrSpec.Process.Capabilities.Effective\n\t\t\tpspec.Capabilities.Permitted = ctrSpec.Process.Capabilities.Effective\n\t\t\tpspec.Capabilities.Ambient = ctrSpec.Process.Capabilities.Effective\n\t\t}\n\t}\n\n\thasHomeSet := false\n\tfor _, s := range pspec.Env {\n\t\tif strings.HasPrefix(s, \"HOME=\") {\n\t\t\thasHomeSet = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif !hasHomeSet {\n\t\tpspec.Env = append(pspec.Env, fmt.Sprintf(\"HOME=%s\", execUser.Home))\n\t}\n\n\tprocessJSON, err := json.Marshal(pspec)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := ioutil.WriteFile(f.Name(), processJSON, 0644); err != nil {\n\t\treturn nil, err\n\t}\n\treturn f, nil\n}\n", "package generate\n\nimport (\n\t\"strings\"\n\n\t\"github.com/containers/common/libimage\"\n\t\"github.com/containers/common/pkg/apparmor\"\n\t\"github.com/containers/common/pkg/capabilities\"\n\t\"github.com/containers/common/pkg/config\"\n\t\"github.com/containers/podman/v4/libpod\"\n\t\"github.com/containers/podman/v4/libpod/define\"\n\t\"github.com/containers/podman/v4/pkg/specgen\"\n\t\"github.com/containers/podman/v4/pkg/util\"\n\t\"github.com/opencontainers/runtime-tools/generate\"\n\t\"github.com/opencontainers/selinux/go-selinux/label\"\n\t\"github.com/pkg/errors\"\n\t\"github.com/sirupsen/logrus\"\n)\n\n// setLabelOpts sets the label options of the SecurityConfig according to the\n// input.\nfunc setLabelOpts(s *specgen.SpecGenerator, runtime *libpod.Runtime, pidConfig specgen.Namespace, ipcConfig specgen.Namespace) error {\n\tif !runtime.EnableLabeling() || s.Privileged {\n\t\ts.SelinuxOpts = label.DisableSecOpt()\n\t\treturn nil\n\t}\n\n\tvar labelOpts []string\n\tif pidConfig.IsHost() {\n\t\tlabelOpts = append(labelOpts, label.DisableSecOpt()...)\n\t} else if pidConfig.IsContainer() {\n\t\tctr, err := runtime.LookupContainer(pidConfig.Value)\n\t\tif err != nil {\n\t\t\treturn errors.Wrapf(err, \"container %q not found\", pidConfig.Value)\n\t\t}\n\t\tsecopts, err := label.DupSecOpt(ctr.ProcessLabel())\n\t\tif err != nil {\n\t\t\treturn errors.Wrapf(err, \"failed to duplicate label %q \", ctr.ProcessLabel())\n\t\t}\n\t\tlabelOpts = append(labelOpts, secopts...)\n\t}\n\n\tif ipcConfig.IsHost() {\n\t\tlabelOpts = append(labelOpts, label.DisableSecOpt()...)\n\t} else if ipcConfig.IsContainer() {\n\t\tctr, err := runtime.LookupContainer(ipcConfig.Value)\n\t\tif err != nil {\n\t\t\treturn errors.Wrapf(err, \"container %q not found\", ipcConfig.Value)\n\t\t}\n\t\tsecopts, err := label.DupSecOpt(ctr.ProcessLabel())\n\t\tif err != nil {\n\t\t\treturn errors.Wrapf(err, \"failed to duplicate label %q \", ctr.ProcessLabel())\n\t\t}\n\t\tlabelOpts = append(labelOpts, secopts...)\n\t}\n\n\ts.SelinuxOpts = append(s.SelinuxOpts, labelOpts...)\n\treturn nil\n}\n\nfunc setupApparmor(s *specgen.SpecGenerator, rtc *config.Config, g *generate.Generator) error {\n\thasProfile := len(s.ApparmorProfile) > 0\n\tif !apparmor.IsEnabled() {\n\t\tif hasProfile && s.ApparmorProfile != \"unconfined\" {\n\t\t\treturn errors.Errorf(\"Apparmor profile %q specified, but Apparmor is not enabled on this system\", s.ApparmorProfile)\n\t\t}\n\t\treturn nil\n\t}\n\t// If privileged and caller did not specify apparmor profiles return\n\tif s.Privileged && !hasProfile {\n\t\treturn nil\n\t}\n\tif !hasProfile {\n\t\ts.ApparmorProfile = rtc.Containers.ApparmorProfile\n\t}\n\tif len(s.ApparmorProfile) > 0 {\n\t\tg.SetProcessApparmorProfile(s.ApparmorProfile)\n\t}\n\n\treturn nil\n}\n\nfunc securityConfigureGenerator(s *specgen.SpecGenerator, g *generate.Generator, newImage *libimage.Image, rtc *config.Config) error {\n\tvar (\n\t\tcaplist []string\n\t\terr     error\n\t)\n\t// HANDLE CAPABILITIES\n\t// NOTE: Must happen before SECCOMP\n\tif s.Privileged {\n\t\tg.SetupPrivileged(true)\n\t\tcaplist, err = capabilities.BoundingSet()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tmergedCaps, err := capabilities.MergeCapabilities(rtc.Containers.DefaultCapabilities, s.CapAdd, s.CapDrop)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tboundingSet, err := capabilities.BoundingSet()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tboundingCaps := make(map[string]interface{})\n\t\tfor _, b := range boundingSet {\n\t\t\tboundingCaps[b] = b\n\t\t}\n\t\tfor _, c := range mergedCaps {\n\t\t\tif _, ok := boundingCaps[c]; ok {\n\t\t\t\tcaplist = append(caplist, c)\n\t\t\t}\n\t\t}\n\n\t\tprivCapsRequired := []string{}\n\n\t\t// If the container image specifies an label with a\n\t\t// capabilities.ContainerImageLabel then split the comma separated list\n\t\t// of capabilities and record them.  This list indicates the only\n\t\t// capabilities, required to run the container.\n\t\tvar capsRequiredRequested []string\n\t\tfor key, val := range s.Labels {\n\t\t\tif util.StringInSlice(key, capabilities.ContainerImageLabels) {\n\t\t\t\tcapsRequiredRequested = strings.Split(val, \",\")\n\t\t\t}\n\t\t}\n\t\tif !s.Privileged && len(capsRequiredRequested) > 0 {\n\t\t\t// Pass capRequiredRequested in CapAdd field to normalize capabilities names\n\t\t\tcapsRequired, err := capabilities.MergeCapabilities(nil, capsRequiredRequested, nil)\n\t\t\tif err != nil {\n\t\t\t\treturn errors.Wrapf(err, \"capabilities requested by user or image are not valid: %q\", strings.Join(capsRequired, \",\"))\n\t\t\t}\n\t\t\t// Verify all capRequired are in the capList\n\t\t\tfor _, cap := range capsRequired {\n\t\t\t\tif !util.StringInSlice(cap, caplist) {\n\t\t\t\t\tprivCapsRequired = append(privCapsRequired, cap)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif len(privCapsRequired) == 0 {\n\t\t\t\tcaplist = capsRequired\n\t\t\t} else {\n\t\t\t\tlogrus.Errorf(\"Capabilities requested by user or image are not allowed by default: %q\", strings.Join(privCapsRequired, \",\"))\n\t\t\t}\n\t\t}\n\t}\n\n\tconfigSpec := g.Config\n\tconfigSpec.Process.Capabilities.Ambient = []string{}\n\n\t// Always unset the inheritable capabilities similarly to what the Linux kernel does\n\t// They are used only when using capabilities with uid != 0.\n\tconfigSpec.Process.Capabilities.Inheritable = []string{}\n\tconfigSpec.Process.Capabilities.Bounding = caplist\n\n\tuser := strings.Split(s.User, \":\")[0]\n\n\tif (user == \"\" && s.UserNS.NSMode != specgen.KeepID) || user == \"root\" || user == \"0\" {\n\t\tconfigSpec.Process.Capabilities.Effective = caplist\n\t\tconfigSpec.Process.Capabilities.Permitted = caplist\n\t} else {\n\t\tmergedCaps, err := capabilities.MergeCapabilities(nil, s.CapAdd, nil)\n\t\tif err != nil {\n\t\t\treturn errors.Wrapf(err, \"capabilities requested by user are not valid: %q\", strings.Join(s.CapAdd, \",\"))\n\t\t}\n\t\tboundingSet, err := capabilities.BoundingSet()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tboundingCaps := make(map[string]interface{})\n\t\tfor _, b := range boundingSet {\n\t\t\tboundingCaps[b] = b\n\t\t}\n\t\tvar userCaps []string\n\t\tfor _, c := range mergedCaps {\n\t\t\tif _, ok := boundingCaps[c]; ok {\n\t\t\t\tuserCaps = append(userCaps, c)\n\t\t\t}\n\t\t}\n\t\tconfigSpec.Process.Capabilities.Effective = userCaps\n\t\tconfigSpec.Process.Capabilities.Permitted = userCaps\n\n\t\t// Ambient capabilities were added to Linux 4.3.  Set ambient\n\t\t// capabilities only when the kernel supports them.\n\t\tif supportAmbientCapabilities() {\n\t\t\tconfigSpec.Process.Capabilities.Ambient = userCaps\n\t\t\tconfigSpec.Process.Capabilities.Inheritable = userCaps\n\t\t}\n\t}\n\n\tg.SetProcessNoNewPrivileges(s.NoNewPrivileges)\n\n\tif err := setupApparmor(s, rtc, g); err != nil {\n\t\treturn err\n\t}\n\n\t// HANDLE SECCOMP\n\tif s.SeccompProfilePath != \"unconfined\" {\n\t\tseccompConfig, err := getSeccompConfig(s, configSpec, newImage)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tconfigSpec.Linux.Seccomp = seccompConfig\n\t}\n\n\t// Clear default Seccomp profile from Generator for unconfined containers\n\t// and privileged containers which do not specify a seccomp profile.\n\tif s.SeccompProfilePath == \"unconfined\" || (s.Privileged && (s.SeccompProfilePath == \"\" || s.SeccompProfilePath == config.SeccompOverridePath || s.SeccompProfilePath == config.SeccompDefaultPath)) {\n\t\tconfigSpec.Linux.Seccomp = nil\n\t}\n\n\tg.SetRootReadonly(s.ReadOnlyFilesystem)\n\n\tnoUseIPC := s.IpcNS.NSMode == specgen.FromContainer || s.IpcNS.NSMode == specgen.FromPod || s.IpcNS.NSMode == specgen.Host\n\tnoUseNet := s.NetNS.NSMode == specgen.FromContainer || s.NetNS.NSMode == specgen.FromPod || s.NetNS.NSMode == specgen.Host\n\tnoUseUTS := s.UtsNS.NSMode == specgen.FromContainer || s.UtsNS.NSMode == specgen.FromPod || s.UtsNS.NSMode == specgen.Host\n\n\t// Add default sysctls\n\tdefaultSysctls, err := util.ValidateSysctls(rtc.Sysctls())\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor sysctlKey, sysctlVal := range defaultSysctls {\n\t\t// Ignore mqueue sysctls if --ipc=host\n\t\tif noUseIPC && strings.HasPrefix(sysctlKey, \"fs.mqueue.\") {\n\t\t\tlogrus.Infof(\"Sysctl %s=%s ignored in containers.conf, since IPC Namespace set to host\", sysctlKey, sysctlVal)\n\n\t\t\tcontinue\n\t\t}\n\n\t\t// Ignore net sysctls if --net=host\n\t\tif noUseNet && strings.HasPrefix(sysctlKey, \"net.\") {\n\t\t\tlogrus.Infof(\"Sysctl %s=%s ignored in containers.conf, since Network Namespace set to host\", sysctlKey, sysctlVal)\n\t\t\tcontinue\n\t\t}\n\n\t\t// Ignore uts sysctls if --uts=host\n\t\tif noUseUTS && (strings.HasPrefix(sysctlKey, \"kernel.domainname\") || strings.HasPrefix(sysctlKey, \"kernel.hostname\")) {\n\t\t\tlogrus.Infof(\"Sysctl %s=%s ignored in containers.conf, since UTS Namespace set to host\", sysctlKey, sysctlVal)\n\t\t\tcontinue\n\t\t}\n\n\t\tg.AddLinuxSysctl(sysctlKey, sysctlVal)\n\t}\n\n\tfor sysctlKey, sysctlVal := range s.Sysctl {\n\t\tif s.IpcNS.IsHost() && strings.HasPrefix(sysctlKey, \"fs.mqueue.\") {\n\t\t\treturn errors.Wrapf(define.ErrInvalidArg, \"sysctl %s=%s can't be set since IPC Namespace set to host\", sysctlKey, sysctlVal)\n\t\t}\n\n\t\t// Ignore net sysctls if --net=host\n\t\tif s.NetNS.IsHost() && strings.HasPrefix(sysctlKey, \"net.\") {\n\t\t\treturn errors.Wrapf(define.ErrInvalidArg, \"sysctl %s=%s can't be set since Network Namespace set to host\", sysctlKey, sysctlVal)\n\t\t}\n\n\t\t// Ignore uts sysctls if --uts=host\n\t\tif s.UtsNS.IsHost() && (strings.HasPrefix(sysctlKey, \"kernel.domainname\") || strings.HasPrefix(sysctlKey, \"kernel.hostname\")) {\n\t\t\treturn errors.Wrapf(define.ErrInvalidArg, \"sysctl %s=%s can't be set since UTS Namespace set to host\", sysctlKey, sysctlVal)\n\t\t}\n\n\t\tg.AddLinuxSysctl(sysctlKey, sysctlVal)\n\t}\n\n\treturn nil\n}\n", "package integration\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/containers/common/pkg/cgroups\"\n\t\"github.com/containers/podman/v4/pkg/rootless\"\n\t. \"github.com/containers/podman/v4/test/utils\"\n\t\"github.com/containers/storage/pkg/stringid\"\n\t\"github.com/mrunalp/fileutils\"\n\t. \"github.com/onsi/ginkgo\"\n\t. \"github.com/onsi/gomega\"\n\t. \"github.com/onsi/gomega/gexec\"\n)\n\nvar _ = Describe(\"Podman run\", func() {\n\tvar (\n\t\ttempdir    string\n\t\terr        error\n\t\tpodmanTest *PodmanTestIntegration\n\t)\n\n\tBeforeEach(func() {\n\t\ttempdir, err = CreateTempDirInTempDir()\n\t\tif err != nil {\n\t\t\tos.Exit(1)\n\t\t}\n\t\tpodmanTest = PodmanTestCreate(tempdir)\n\t\tpodmanTest.Setup()\n\t\tpodmanTest.SeedImages()\n\t})\n\n\tAfterEach(func() {\n\t\tpodmanTest.Cleanup()\n\t\tf := CurrentGinkgoTestDescription()\n\t\tprocessTestResult(f)\n\t})\n\n\tIt(\"podman run a container based on local image\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", ALPINE, \"ls\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t})\n\n\tIt(\"podman run check /run/.containerenv\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", ALPINE, \"cat\", \"/run/.containerenv\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(Equal(\"\"))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--privileged\", \"--name=test1\", ALPINE, \"cat\", \"/run/.containerenv\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"name=\\\"test1\\\"\"))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"image=\\\"\" + ALPINE + \"\\\"\"))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"-v\", \"/:/host\", ALPINE, \"cat\", \"/run/.containerenv\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"graphRootMounted=1\"))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"-v\", \"/:/host\", \"--privileged\", ALPINE, \"cat\", \"/run/.containerenv\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"graphRootMounted=1\"))\n\t})\n\n\tIt(\"podman run a container based on a complex local image name\", func() {\n\t\timageName := strings.TrimPrefix(nginx, \"quay.io/\")\n\t\tsession := podmanTest.Podman([]string{\"run\", imageName, \"ls\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ErrorToString()).ToNot(ContainSubstring(\"Trying to pull\"))\n\t\tExpect(session).Should(Exit(0))\n\t})\n\n\tIt(\"podman run --signature-policy\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--pull=always\", \"--signature-policy\", \"/no/such/file\", ALPINE})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).To(ExitWithError())\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--pull=always\", \"--signature-policy\", \"/etc/containers/policy.json\", ALPINE})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tif IsRemote() {\n\t\t\tExpect(session).To(ExitWithError())\n\t\t\tExpect(session.ErrorToString()).To(ContainSubstring(\"unknown flag\"))\n\t\t} else {\n\t\t\tExpect(session).Should(Exit(0))\n\t\t}\n\t})\n\n\tIt(\"podman run --rm with --restart\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--restart\", \"\", ALPINE})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--restart\", \"no\", ALPINE})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--restart\", \"on-failure\", ALPINE})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--restart\", \"always\", ALPINE})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).To(ExitWithError())\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--restart\", \"unless-stopped\", ALPINE})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).To(ExitWithError())\n\t})\n\n\tIt(\"podman run a container based on on a short name with localhost\", func() {\n\t\ttag := podmanTest.Podman([]string{\"tag\", nginx, \"localhost/libpod/alpine_nginx:latest\"})\n\t\ttag.WaitWithDefaultTimeout()\n\n\t\trmi := podmanTest.Podman([]string{\"rmi\", nginx})\n\t\trmi.WaitWithDefaultTimeout()\n\n\t\tsession := podmanTest.Podman([]string{\"run\", \"libpod/alpine_nginx:latest\", \"ls\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ErrorToString()).ToNot(ContainSubstring(\"Trying to pull\"))\n\t\tExpect(session).Should(Exit(0))\n\t})\n\n\tIt(\"podman container run a container based on on a short name with localhost\", func() {\n\t\ttag := podmanTest.Podman([]string{\"image\", \"tag\", nginx, \"localhost/libpod/alpine_nginx:latest\"})\n\t\ttag.WaitWithDefaultTimeout()\n\n\t\trmi := podmanTest.Podman([]string{\"image\", \"rm\", nginx})\n\t\trmi.WaitWithDefaultTimeout()\n\n\t\tsession := podmanTest.Podman([]string{\"container\", \"run\", \"libpod/alpine_nginx:latest\", \"ls\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ErrorToString()).ToNot(ContainSubstring(\"Trying to pull\"))\n\t\tExpect(session).Should(Exit(0))\n\t})\n\n\tIt(\"podman run a container based on local image with short options\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"-dt\", ALPINE, \"ls\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t})\n\n\tIt(\"podman run a container based on local image with short options and args\", func() {\n\t\t// regression test for #714\n\t\tsession := podmanTest.Podman([]string{\"run\", ALPINE, \"find\", \"/etc\", \"-name\", \"hosts\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"/etc/hosts\"))\n\t})\n\n\tIt(\"podman create pod with name in /etc/hosts\", func() {\n\t\tname := \"test_container\"\n\t\thostname := \"test_hostname\"\n\t\tsession := podmanTest.Podman([]string{\"run\", \"-ti\", \"--rm\", \"--name\", name, \"--hostname\", hostname, ALPINE, \"cat\", \"/etc/hosts\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(name))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(hostname))\n\t})\n\n\tIt(\"podman run a container based on remote image\", func() {\n\t\t// Changing session to rsession\n\t\trsession := podmanTest.Podman([]string{\"run\", \"-dt\", ALPINE, \"ls\"})\n\t\trsession.WaitWithDefaultTimeout()\n\t\tExpect(rsession).Should(Exit(0))\n\n\t\tlock := GetPortLock(\"5000\")\n\t\tdefer lock.Unlock()\n\t\tsession := podmanTest.Podman([]string{\"run\", \"-d\", \"--name\", \"registry\", \"-p\", \"5000:5000\", registry, \"/entrypoint.sh\", \"/etc/docker/registry/config.yml\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\n\t\tif !WaitContainerReady(podmanTest, \"registry\", \"listening on\", 20, 1) {\n\t\t\tSkip(\"Cannot start docker registry.\")\n\t\t}\n\n\t\trun := podmanTest.Podman([]string{\"run\", \"--tls-verify=false\", ALPINE})\n\t\trun.WaitWithDefaultTimeout()\n\t\tExpect(run).Should(Exit(0))\n\t\tExpect(podmanTest.NumberOfContainers()).To(Equal(3))\n\n\t\t// Now registries.conf will be consulted where localhost:5000\n\t\t// is set to be insecure.\n\t\trun = podmanTest.Podman([]string{\"run\", ALPINE})\n\t\trun.WaitWithDefaultTimeout()\n\t\tExpect(run).Should(Exit(0))\n\t})\n\n\tIt(\"podman run a container with a --rootfs\", func() {\n\t\trootfs := filepath.Join(tempdir, \"rootfs\")\n\t\tuls := filepath.Join(\"/\", \"usr\", \"local\", \"share\")\n\t\tuniqueString := stringid.GenerateNonCryptoID()\n\t\ttestFilePath := filepath.Join(uls, uniqueString)\n\t\ttarball := filepath.Join(tempdir, \"rootfs.tar\")\n\n\t\terr := os.Mkdir(rootfs, 0770)\n\t\tExpect(err).Should(BeNil())\n\n\t\t// Change image in predictable way to validate export\n\t\tcsession := podmanTest.Podman([]string{\"run\", \"--name\", uniqueString, ALPINE,\n\t\t\t\"/bin/sh\", \"-c\", fmt.Sprintf(\"echo %s > %s\", uniqueString, testFilePath)})\n\t\tcsession.WaitWithDefaultTimeout()\n\t\tExpect(csession).Should(Exit(0))\n\n\t\t// Export from working container image guarantees working root\n\t\tesession := podmanTest.Podman([]string{\"export\", \"--output\", tarball, uniqueString})\n\t\tesession.WaitWithDefaultTimeout()\n\t\tExpect(esession).Should(Exit(0))\n\t\tExpect(tarball).Should(BeARegularFile())\n\n\t\t// N/B: This will loose any extended attributes like SELinux types\n\t\tfmt.Fprintf(os.Stderr, \"Extracting container root tarball\\n\")\n\t\ttarsession := SystemExec(\"tar\", []string{\"xf\", tarball, \"-C\", rootfs})\n\t\tExpect(tarsession).Should(Exit(0))\n\t\tExpect(filepath.Join(rootfs, uls)).Should(BeADirectory())\n\n\t\t// Other tests confirm SELinux types, just confirm --rootfs is working.\n\t\tsession := podmanTest.Podman([]string{\"run\", \"-i\", \"--security-opt\", \"label=disable\",\n\t\t\t\"--rootfs\", rootfs, \"cat\", testFilePath})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\n\t\t// Validate changes made in original container and export\n\t\tstdoutLines := session.OutputToStringArray()\n\t\tExpect(stdoutLines).Should(HaveLen(1))\n\t\tExpect(stdoutLines[0]).Should(Equal(uniqueString))\n\n\t\tSkipIfRemote(\"External overlay only work locally\")\n\t\tif os.Getenv(\"container\") != \"\" {\n\t\t\tSkip(\"Overlay mounts not supported when running in a container\")\n\t\t}\n\t\tif rootless.IsRootless() {\n\t\t\tif _, err := exec.LookPath(\"fuse-overlayfs\"); err != nil {\n\t\t\t\tSkip(\"Fuse-Overlayfs required for rootless overlay mount test\")\n\t\t\t}\n\t\t}\n\t\t// Test --rootfs with an external overlay\n\t\t// use --rm to remove container and confirm if we did not leak anything\n\t\tosession := podmanTest.Podman([]string{\"run\", \"-i\", \"--rm\", \"--security-opt\", \"label=disable\",\n\t\t\t\"--rootfs\", rootfs + \":O\", \"cat\", testFilePath})\n\t\tosession.WaitWithDefaultTimeout()\n\t\tExpect(osession).Should(Exit(0))\n\n\t\t// Test podman start stop with overlay\n\t\tosession = podmanTest.Podman([]string{\"run\", \"--name\", \"overlay-foo\", \"--security-opt\", \"label=disable\",\n\t\t\t\"--rootfs\", rootfs + \":O\", \"echo\", \"hello\"})\n\t\tosession.WaitWithDefaultTimeout()\n\t\tExpect(osession).Should(Exit(0))\n\n\t\tosession = podmanTest.Podman([]string{\"stop\", \"overlay-foo\"})\n\t\tosession.WaitWithDefaultTimeout()\n\t\tExpect(osession).Should(Exit(0))\n\n\t\tstartsession := podmanTest.Podman([]string{\"start\", \"--attach\", \"overlay-foo\"})\n\t\tstartsession.WaitWithDefaultTimeout()\n\t\tExpect(startsession).Should(Exit(0))\n\t\tExpect(startsession.OutputToString()).To(Equal(\"hello\"))\n\n\t\t// remove container for above test overlay-foo\n\t\tosession = podmanTest.Podman([]string{\"rm\", \"overlay-foo\"})\n\t\tosession.WaitWithDefaultTimeout()\n\t\tExpect(osession).Should(Exit(0))\n\n\t\t// Test --rootfs with an external overlay with --uidmap\n\t\tosession = podmanTest.Podman([]string{\"run\", \"--uidmap\", \"0:1000:1000\", \"--rm\", \"--security-opt\", \"label=disable\",\n\t\t\t\"--rootfs\", rootfs + \":O\", \"echo\", \"hello\"})\n\t\tosession.WaitWithDefaultTimeout()\n\t\tExpect(osession).Should(Exit(0))\n\t\tExpect(osession.OutputToString()).To(Equal(\"hello\"))\n\t})\n\n\tIt(\"podman run a container with --init\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--name\", \"test\", \"--init\", ALPINE, \"ls\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tresult := podmanTest.Podman([]string{\"inspect\", \"test\"})\n\t\tresult.WaitWithDefaultTimeout()\n\t\tExpect(result).Should(Exit(0))\n\t\tconData := result.InspectContainerToJSON()\n\t\tExpect(conData[0].Path).To(Equal(\"/dev/init\"))\n\t\tExpect(conData[0].Config.Annotations).To(HaveKeyWithValue(\"io.podman.annotations.init\", \"TRUE\"))\n\t})\n\n\tIt(\"podman run a container with --init and --init-path\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--name\", \"test\", \"--init\", \"--init-path\", \"/usr/libexec/podman/catatonit\", ALPINE, \"ls\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tresult := podmanTest.Podman([]string{\"inspect\", \"test\"})\n\t\tresult.WaitWithDefaultTimeout()\n\t\tExpect(result).Should(Exit(0))\n\t\tconData := result.InspectContainerToJSON()\n\t\tExpect(conData[0].Path).To(Equal(\"/dev/init\"))\n\t\tExpect(conData[0].Config.Annotations).To(HaveKeyWithValue(\"io.podman.annotations.init\", \"TRUE\"))\n\t})\n\n\tIt(\"podman run a container without --init\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--name\", \"test\", ALPINE, \"ls\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tresult := podmanTest.Podman([]string{\"inspect\", \"test\"})\n\t\tresult.WaitWithDefaultTimeout()\n\t\tExpect(result).Should(Exit(0))\n\t\tconData := result.InspectContainerToJSON()\n\t\tExpect(conData[0].Path).To(Equal(\"ls\"))\n\t\tExpect(conData[0].Config.Annotations).To(HaveKeyWithValue(\"io.podman.annotations.init\", \"FALSE\"))\n\t})\n\n\tforbidGetCWDSeccompProfile := func() string {\n\t\tin := []byte(`{\"defaultAction\":\"SCMP_ACT_ALLOW\",\"syscalls\":[{\"name\":\"getcwd\",\"action\":\"SCMP_ACT_ERRNO\"}]}`)\n\t\tjsonFile, err := podmanTest.CreateSeccompJSON(in)\n\t\tif err != nil {\n\t\t\tfmt.Println(err)\n\t\t\tSkip(\"Failed to prepare seccomp.json for test.\")\n\t\t}\n\t\treturn jsonFile\n\t}\n\n\tIt(\"podman run mask and unmask path test\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"-d\", \"--name=maskCtr1\", \"--security-opt\", \"unmask=ALL\", \"--security-opt\", \"mask=/proc/acpi\", ALPINE, \"sleep\", \"200\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tsession = podmanTest.Podman([]string{\"exec\", \"maskCtr1\", \"ls\", \"/sys/firmware\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.OutputToString()).To(Not(BeEmpty()))\n\t\tExpect(session).Should(Exit(0))\n\t\tsession = podmanTest.Podman([]string{\"exec\", \"maskCtr1\", \"ls\", \"/proc/acpi\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.OutputToString()).To(BeEmpty())\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"-d\", \"--name=maskCtr2\", \"--security-opt\", \"unmask=/proc/acpi:/sys/firmware\", ALPINE, \"sleep\", \"200\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tsession = podmanTest.Podman([]string{\"exec\", \"maskCtr2\", \"ls\", \"/sys/firmware\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.OutputToString()).To(Not(BeEmpty()))\n\t\tExpect(session).Should(Exit(0))\n\t\tsession = podmanTest.Podman([]string{\"exec\", \"maskCtr2\", \"ls\", \"/proc/acpi\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.OutputToString()).To(Not(BeEmpty()))\n\t\tExpect(session).Should(Exit(0))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"-d\", \"--name=maskCtr3\", \"--security-opt\", \"mask=/sys/power/disk\", ALPINE, \"sleep\", \"200\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tsession = podmanTest.Podman([]string{\"exec\", \"maskCtr3\", \"cat\", \"/sys/power/disk\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.OutputToString()).To(BeEmpty())\n\t\tExpect(session).Should(Exit(0))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"-d\", \"--name=maskCtr4\", \"--security-opt\", \"systempaths=unconfined\", ALPINE, \"sleep\", \"200\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tsession = podmanTest.Podman([]string{\"exec\", \"maskCtr4\", \"ls\", \"/sys/firmware\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.OutputToString()).To(Not(BeEmpty()))\n\t\tExpect(session).Should(Exit(0))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"-d\", \"--name=maskCtr5\", \"--security-opt\", \"systempaths=unconfined\", ALPINE, \"grep\", \"/proc\", \"/proc/self/mounts\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToStringArray()).Should(HaveLen(1))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"-d\", \"--security-opt\", \"unmask=/proc/*\", ALPINE, \"grep\", \"/proc\", \"/proc/self/mounts\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToStringArray()).Should(HaveLen(1))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--security-opt\", \"unmask=/proc/a*\", ALPINE, \"ls\", \"/proc/acpi\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(Not(BeEmpty()))\n\t})\n\n\tIt(\"podman run security-opt unmask on /sys/fs/cgroup\", func() {\n\n\t\tSkipIfCgroupV1(\"podman umask on /sys/fs/cgroup will fail with cgroups V1\")\n\t\tSkipIfRootless(\"/sys/fs/cgroup rw access is needed\")\n\t\trwOnCgroups := \"/sys/fs/cgroup cgroup2 rw\"\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--security-opt\", \"unmask=ALL\", \"--security-opt\", \"mask=/sys/fs/cgroup\", ALPINE, \"cat\", \"/proc/mounts\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(rwOnCgroups))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--security-opt\", \"unmask=/sys/fs/cgroup\", ALPINE, \"cat\", \"/proc/mounts\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(rwOnCgroups))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--security-opt\", \"unmask=/sys/fs/cgroup///\", ALPINE, \"cat\", \"/proc/mounts\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(rwOnCgroups))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--security-opt\", \"unmask=ALL\", ALPINE, \"cat\", \"/proc/mounts\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(rwOnCgroups))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--security-opt\", \"unmask=/sys/fs/cgroup\", \"--security-opt\", \"mask=/sys/fs/cgroup\", ALPINE, \"cat\", \"/proc/mounts\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(rwOnCgroups))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--security-opt\", \"unmask=/sys/fs/cgroup\", ALPINE, \"ls\", \"/sys/fs/cgroup\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).ToNot(BeEmpty())\n\t})\n\n\tIt(\"podman run seccomp test\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"-it\", \"--security-opt\", strings.Join([]string{\"seccomp=\", forbidGetCWDSeccompProfile()}, \"\"), ALPINE, \"pwd\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).To(ExitWithError())\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"Operation not permitted\"))\n\t})\n\n\tIt(\"podman run seccomp test --privileged\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"-it\", \"--privileged\", \"--security-opt\", strings.Join([]string{\"seccomp=\", forbidGetCWDSeccompProfile()}, \"\"), ALPINE, \"pwd\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).To(ExitWithError())\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"Operation not permitted\"))\n\t})\n\n\tIt(\"podman run seccomp test --privileged no profile should be unconfined\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"-it\", \"--privileged\", ALPINE, \"grep\", \"Seccomp\", \"/proc/self/status\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"0\"))\n\t\tExpect(session).Should(Exit(0))\n\t})\n\n\tIt(\"podman run seccomp test no profile should be default\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"-it\", ALPINE, \"grep\", \"Seccomp\", \"/proc/self/status\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"2\"))\n\t\tExpect(session).Should(Exit(0))\n\t})\n\n\tIt(\"podman run capabilities test\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--cap-add\", \"all\", ALPINE, \"cat\", \"/proc/self/status\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--cap-add\", \"sys_admin\", ALPINE, \"cat\", \"/proc/self/status\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--cap-drop\", \"all\", ALPINE, \"cat\", \"/proc/self/status\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--cap-drop\", \"setuid\", ALPINE, \"cat\", \"/proc/self/status\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t})\n\n\tIt(\"podman run user capabilities test\", func() {\n\t\t// We need to ignore the containers.conf on the test distribution for this test\n\t\tos.Setenv(\"CONTAINERS_CONF\", \"/dev/null\")\n\t\tif IsRemote() {\n\t\t\tpodmanTest.RestartRemoteService()\n\t\t}\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--user\", \"bin\", ALPINE, \"grep\", \"CapBnd\", \"/proc/self/status\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"00000000a80425fb\"))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--user\", \"bin\", ALPINE, \"grep\", \"CapEff\", \"/proc/self/status\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"0000000000000000\"))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--user\", \"bin\", ALPINE, \"grep\", \"CapInh\", \"/proc/self/status\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"0000000000000000\"))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--user\", \"root\", ALPINE, \"grep\", \"CapBnd\", \"/proc/self/status\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"00000000a80425fb\"))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--user\", \"root\", ALPINE, \"grep\", \"CapEff\", \"/proc/self/status\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"00000000a80425fb\"))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--user\", \"root\", ALPINE, \"grep\", \"CapInh\", \"/proc/self/status\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"0000000000000000\"))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", ALPINE, \"grep\", \"CapBnd\", \"/proc/self/status\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"00000000a80425fb\"))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", ALPINE, \"grep\", \"CapEff\", \"/proc/self/status\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"00000000a80425fb\"))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--user=1000:1000\", \"--cap-add=DAC_OVERRIDE\", \"--rm\", ALPINE, \"grep\", \"CapAmb\", \"/proc/self/status\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"0000000000000002\"))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--user=1000:1000\", \"--cap-add=DAC_OVERRIDE\", \"--rm\", ALPINE, \"grep\", \"CapInh\", \"/proc/self/status\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"0000000000000002\"))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--user=0\", \"--cap-add=DAC_OVERRIDE\", \"--rm\", ALPINE, \"grep\", \"CapAmb\", \"/proc/self/status\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"0000000000000000\"))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--user=0:0\", \"--cap-add=DAC_OVERRIDE\", \"--rm\", ALPINE, \"grep\", \"CapAmb\", \"/proc/self/status\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"0000000000000000\"))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--user=0:0\", \"--cap-add=DAC_OVERRIDE\", \"--rm\", ALPINE, \"grep\", \"CapInh\", \"/proc/self/status\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"0000000000000000\"))\n\n\t\tif os.Geteuid() > 0 {\n\t\t\tif os.Getenv(\"SKIP_USERNS\") != \"\" {\n\t\t\t\tSkip(\"Skip userns tests.\")\n\t\t\t}\n\t\t\tif _, err := os.Stat(\"/proc/self/uid_map\"); err != nil {\n\t\t\t\tSkip(\"User namespaces not supported.\")\n\t\t\t}\n\t\t\tsession = podmanTest.Podman([]string{\"run\", \"--userns=keep-id\", \"--cap-add=DAC_OVERRIDE\", \"--rm\", ALPINE, \"grep\", \"CapAmb\", \"/proc/self/status\"})\n\t\t\tsession.WaitWithDefaultTimeout()\n\t\t\tExpect(session).Should(Exit(0))\n\t\t\tExpect(session.OutputToString()).To(ContainSubstring(\"0000000000000002\"))\n\n\t\t\tsession = podmanTest.Podman([]string{\"run\", \"--userns=keep-id\", \"--privileged\", \"--rm\", ALPINE, \"grep\", \"CapInh\", \"/proc/self/status\"})\n\t\t\tsession.WaitWithDefaultTimeout()\n\t\t\tExpect(session).Should(Exit(0))\n\t\t\tExpect(session.OutputToString()).To(ContainSubstring(\"0000000000000002\"))\n\n\t\t\tsession = podmanTest.Podman([]string{\"run\", \"--userns=keep-id\", \"--cap-add=DAC_OVERRIDE\", \"--rm\", ALPINE, \"grep\", \"CapInh\", \"/proc/self/status\"})\n\t\t\tsession.WaitWithDefaultTimeout()\n\t\t\tExpect(session).Should(Exit(0))\n\t\t\tExpect(session.OutputToString()).To(ContainSubstring(\"0000000000000002\"))\n\t\t}\n\t})\n\n\tIt(\"podman run user capabilities test with image\", func() {\n\t\t// We need to ignore the containers.conf on the test distribution for this test\n\t\tos.Setenv(\"CONTAINERS_CONF\", \"/dev/null\")\n\t\tif IsRemote() {\n\t\t\tpodmanTest.RestartRemoteService()\n\t\t}\n\t\tdockerfile := fmt.Sprintf(`FROM %s\nUSER bin`, BB)\n\t\tpodmanTest.BuildImage(dockerfile, \"test\", \"false\")\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--user\", \"bin\", \"test\", \"grep\", \"CapBnd\", \"/proc/self/status\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"00000000a80425fb\"))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--user\", \"bin\", \"test\", \"grep\", \"CapEff\", \"/proc/self/status\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"0000000000000000\"))\n\t})\n\n\tIt(\"podman run limits test\", func() {\n\t\tSkipIfRootlessCgroupsV1(\"Setting limits not supported on cgroupv1 for rootless users\")\n\n\t\tif !isRootless() {\n\t\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--ulimit\", \"rtprio=99\", \"--cap-add=sys_nice\", fedoraMinimal, \"cat\", \"/proc/self/sched\"})\n\t\t\tsession.WaitWithDefaultTimeout()\n\t\t\tExpect(session).Should(Exit(0))\n\t\t}\n\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--ulimit\", \"nofile=2048:2048\", fedoraMinimal, \"ulimit\", \"-n\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"2048\"))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--ulimit\", \"nofile=1024:1028\", fedoraMinimal, \"ulimit\", \"-n\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"1024\"))\n\n\t\tif !CGROUPSV2 {\n\t\t\t// --oom-kill-disable not supported on cgroups v2.\n\t\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--oom-kill-disable=true\", fedoraMinimal, \"echo\", \"memory-hog\"})\n\t\t\tsession.WaitWithDefaultTimeout()\n\t\t\tExpect(session).Should(Exit(0))\n\t\t}\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--oom-score-adj=111\", fedoraMinimal, \"cat\", \"/proc/self/oom_score_adj\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(Equal(\"111\"))\n\t})\n\n\tIt(\"podman run limits host test\", func() {\n\t\tSkipIfRemote(\"This can only be used for local tests\")\n\n\t\tvar l syscall.Rlimit\n\n\t\terr := syscall.Getrlimit(syscall.RLIMIT_NOFILE, &l)\n\t\tExpect(err).To(BeNil())\n\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--ulimit\", \"host\", fedoraMinimal, \"ulimit\", \"-Hn\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\n\t\tulimitCtrStr := strings.TrimSpace(session.OutputToString())\n\t\tulimitCtr, err := strconv.ParseUint(ulimitCtrStr, 10, 0)\n\t\tExpect(err).To(BeNil())\n\n\t\tExpect(ulimitCtr).Should(BeNumerically(\">=\", l.Max))\n\t})\n\n\tIt(\"podman run with cidfile\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--cidfile\", tempdir + \"cidfile\", ALPINE, \"ls\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\terr := os.Remove(tempdir + \"cidfile\")\n\t\tExpect(err).To(BeNil())\n\t})\n\n\tIt(\"podman run sysctl test\", func() {\n\t\tSkipIfRootless(\"Network sysctls are not available root rootless\")\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--sysctl\", \"net.core.somaxconn=65535\", ALPINE, \"sysctl\", \"net.core.somaxconn\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"net.core.somaxconn = 65535\"))\n\n\t\t// network sysctls should fail if --net=host is set\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--net\", \"host\", \"--rm\", \"--sysctl\", \"net.core.somaxconn=65535\", ALPINE, \"sysctl\", \"net.core.somaxconn\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(125))\n\t})\n\n\tIt(\"podman run blkio-weight test\", func() {\n\t\tSkipIfRootlessCgroupsV1(\"Setting blkio-weight not supported on cgroupv1 for rootless users\")\n\t\tSkipIfRootless(\"By default systemd doesn't delegate io to rootless users\")\n\t\tif CGROUPSV2 {\n\t\t\tif _, err := os.Stat(\"/sys/fs/cgroup/io.stat\"); os.IsNotExist(err) {\n\t\t\t\tSkip(\"Kernel does not have io.stat\")\n\t\t\t}\n\t\t\tif _, err := os.Stat(\"/sys/fs/cgroup/system.slice/io.bfq.weight\"); os.IsNotExist(err) {\n\t\t\t\tSkip(\"Kernel does not support BFQ IO scheduler\")\n\t\t\t}\n\t\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--blkio-weight=15\", ALPINE, \"sh\", \"-c\", \"cat /sys/fs/cgroup/io.bfq.weight\"})\n\t\t\tsession.WaitWithDefaultTimeout()\n\t\t\tExpect(session).Should(Exit(0))\n\t\t\t// there was a documentation issue in the kernel that reported a different range [1-10000] for the io controller.\n\t\t\t// older versions of crun/runc used it.  For the time being allow both versions to pass the test.\n\t\t\t// FIXME: drop \"|51\" once all the runtimes we test have the fix in place.\n\t\t\tExpect(strings.Replace(session.OutputToString(), \"default \", \"\", 1)).To(MatchRegexp(\"15|51\"))\n\t\t} else {\n\t\t\tif _, err := os.Stat(\"/sys/fs/cgroup/blkio/blkio.weight\"); os.IsNotExist(err) {\n\t\t\t\tSkip(\"Kernel does not support blkio.weight\")\n\t\t\t}\n\t\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--blkio-weight=15\", ALPINE, \"cat\", \"/sys/fs/cgroup/blkio/blkio.weight\"})\n\t\t\tsession.WaitWithDefaultTimeout()\n\t\t\tExpect(session).Should(Exit(0))\n\t\t\tExpect(session.OutputToString()).To(ContainSubstring(\"15\"))\n\t\t}\n\t})\n\n\tIt(\"podman run device-read-bps test\", func() {\n\t\tSkipIfRootless(\"FIXME: requested cgroup controller `io` is not available\")\n\t\tSkipIfRootlessCgroupsV1(\"Setting device-read-bps not supported on cgroupv1 for rootless users\")\n\n\t\tvar session *PodmanSessionIntegration\n\n\t\tif CGROUPSV2 {\n\t\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--device-read-bps=/dev/zero:1mb\", ALPINE, \"sh\", \"-c\", \"cat /sys/fs/cgroup/$(sed -e 's|0::||' < /proc/self/cgroup)/io.max\"})\n\t\t} else {\n\t\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--device-read-bps=/dev/zero:1mb\", ALPINE, \"cat\", \"/sys/fs/cgroup/blkio/blkio.throttle.read_bps_device\"})\n\t\t}\n\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tif !CGROUPSV2 { // TODO: Test Simplification.  For now, we only care about exit(0) w/ cgroupsv2\n\t\t\tExpect(session.OutputToString()).To(ContainSubstring(\"1048576\"))\n\t\t}\n\t})\n\n\tIt(\"podman run device-write-bps test\", func() {\n\t\tSkipIfRootless(\"FIXME: requested cgroup controller `io` is not available\")\n\t\tSkipIfRootlessCgroupsV1(\"Setting device-write-bps not supported on cgroupv1 for rootless users\")\n\n\t\tvar session *PodmanSessionIntegration\n\n\t\tif CGROUPSV2 {\n\t\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--device-write-bps=/dev/zero:1mb\", ALPINE, \"sh\", \"-c\", \"cat /sys/fs/cgroup/$(sed -e 's|0::||' < /proc/self/cgroup)/io.max\"})\n\t\t} else {\n\t\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--device-write-bps=/dev/zero:1mb\", ALPINE, \"cat\", \"/sys/fs/cgroup/blkio/blkio.throttle.write_bps_device\"})\n\t\t}\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tif !CGROUPSV2 { // TODO: Test Simplification.  For now, we only care about exit(0) w/ cgroupsv2\n\t\t\tExpect(session.OutputToString()).To(ContainSubstring(\"1048576\"))\n\t\t}\n\t})\n\n\tIt(\"podman run device-read-iops test\", func() {\n\t\tSkipIfRootless(\"FIXME: requested cgroup controller `io` is not available\")\n\t\tSkipIfRootlessCgroupsV1(\"Setting device-read-iops not supported on cgroupv1 for rootless users\")\n\t\tvar session *PodmanSessionIntegration\n\n\t\tif CGROUPSV2 {\n\t\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--device-read-iops=/dev/zero:100\", ALPINE, \"sh\", \"-c\", \"cat /sys/fs/cgroup/$(sed -e 's|0::||' < /proc/self/cgroup)/io.max\"})\n\t\t} else {\n\t\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--device-read-iops=/dev/zero:100\", ALPINE, \"cat\", \"/sys/fs/cgroup/blkio/blkio.throttle.read_iops_device\"})\n\t\t}\n\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tif !CGROUPSV2 { // TODO: Test Simplification.  For now, we only care about exit(0) w/ cgroupsv2\n\t\t\tExpect(session.OutputToString()).To(ContainSubstring(\"100\"))\n\t\t}\n\t})\n\n\tIt(\"podman run device-write-iops test\", func() {\n\t\tSkipIfRootless(\"FIXME: requested cgroup controller `io` is not available\")\n\t\tSkipIfRootlessCgroupsV1(\"Setting device-write-iops not supported on cgroupv1 for rootless users\")\n\t\tvar session *PodmanSessionIntegration\n\n\t\tif CGROUPSV2 {\n\t\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--device-write-iops=/dev/zero:100\", ALPINE, \"sh\", \"-c\", \"cat /sys/fs/cgroup/$(sed -e 's|0::||' < /proc/self/cgroup)/io.max\"})\n\t\t} else {\n\t\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--device-write-iops=/dev/zero:100\", ALPINE, \"cat\", \"/sys/fs/cgroup/blkio/blkio.throttle.write_iops_device\"})\n\t\t}\n\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tif !CGROUPSV2 { // TODO: Test Simplification.  For now, we only care about exit(0) w/ cgroupsv2\n\t\t\tExpect(session.OutputToString()).To(ContainSubstring(\"100\"))\n\t\t}\n\t})\n\n\tIt(\"podman run notify_socket\", func() {\n\t\tSkipIfRemote(\"This can only be used for local tests\")\n\n\t\thost := GetHostDistributionInfo()\n\t\tif host.Distribution != \"rhel\" && host.Distribution != \"centos\" && host.Distribution != \"fedora\" {\n\t\t\tSkip(\"this test requires a working runc\")\n\t\t}\n\t\tsock := filepath.Join(podmanTest.TempDir, \"notify\")\n\t\taddr := net.UnixAddr{\n\t\t\tName: sock,\n\t\t\tNet:  \"unixgram\",\n\t\t}\n\t\tsocket, err := net.ListenUnixgram(\"unixgram\", &addr)\n\t\tExpect(err).To(BeNil())\n\t\tdefer os.Remove(sock)\n\t\tdefer socket.Close()\n\n\t\tos.Setenv(\"NOTIFY_SOCKET\", sock)\n\t\tdefer os.Unsetenv(\"NOTIFY_SOCKET\")\n\n\t\tsession := podmanTest.Podman([]string{\"run\", ALPINE, \"printenv\", \"NOTIFY_SOCKET\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(len(session.OutputToStringArray())).To(BeNumerically(\">\", 0))\n\t})\n\n\tIt(\"podman run log-opt\", func() {\n\t\tlog := filepath.Join(podmanTest.TempDir, \"/container.log\")\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--log-driver\", \"k8s-file\", \"--log-opt\", fmt.Sprintf(\"path=%s\", log), ALPINE, \"ls\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\t_, err := os.Stat(log)\n\t\tExpect(err).To(BeNil())\n\t\t_ = os.Remove(log)\n\t})\n\n\tIt(\"podman run tagged image\", func() {\n\t\tpodmanTest.AddImageToRWStore(BB)\n\t\ttag := podmanTest.Podman([]string{\"tag\", BB, \"bb\"})\n\t\ttag.WaitWithDefaultTimeout()\n\t\tExpect(tag).Should(Exit(0))\n\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"bb\", \"ls\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t})\n\n\tIt(\"podman test hooks\", func() {\n\t\thcheck := \"/run/hookscheck\"\n\t\thooksDir := tempdir + \"/hooks\"\n\t\tos.Mkdir(hooksDir, 0755)\n\t\tfileutils.CopyFile(\"hooks/hooks.json\", hooksDir)\n\t\tos.Setenv(\"HOOK_OPTION\", fmt.Sprintf(\"--hooks-dir=%s\", hooksDir))\n\t\tos.Remove(hcheck)\n\t\tsession := podmanTest.Podman([]string{\"run\", ALPINE, \"ls\"})\n\t\tsession.Wait(10)\n\t\tos.Unsetenv(\"HOOK_OPTION\")\n\t\tExpect(session).Should(Exit(0))\n\t})\n\n\tIt(\"podman run with subscription secrets\", func() {\n\t\tSkipIfRemote(\"--default-mount-file option is not supported in podman-remote\")\n\t\tcontainersDir := filepath.Join(podmanTest.TempDir, \"containers\")\n\t\terr := os.MkdirAll(containersDir, 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\tsecretsDir := filepath.Join(podmanTest.TempDir, \"rhel\", \"secrets\")\n\t\terr = os.MkdirAll(secretsDir, 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\tmountsFile := filepath.Join(containersDir, \"mounts.conf\")\n\t\tmountString := secretsDir + \":/run/secrets\"\n\t\terr = ioutil.WriteFile(mountsFile, []byte(mountString), 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\tsecretsFile := filepath.Join(secretsDir, \"test.txt\")\n\t\tsecretsString := \"Testing secrets mount. I am mounted!\"\n\t\terr = ioutil.WriteFile(secretsFile, []byte(secretsString), 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\ttargetDir := tempdir + \"/symlink/target\"\n\t\terr = os.MkdirAll(targetDir, 0755)\n\t\tExpect(err).To(BeNil())\n\t\tkeyFile := filepath.Join(targetDir, \"key.pem\")\n\t\terr = ioutil.WriteFile(keyFile, []byte(mountString), 0755)\n\t\tExpect(err).To(BeNil())\n\t\texecSession := SystemExec(\"ln\", []string{\"-s\", targetDir, filepath.Join(secretsDir, \"mysymlink\")})\n\t\tExpect(execSession).Should(Exit(0))\n\n\t\tsession := podmanTest.Podman([]string{\"--default-mounts-file=\" + mountsFile, \"run\", \"--rm\", ALPINE, \"cat\", \"/run/secrets/test.txt\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(Equal(secretsString))\n\n\t\tsession = podmanTest.Podman([]string{\"--default-mounts-file=\" + mountsFile, \"run\", \"--rm\", ALPINE, \"ls\", \"/run/secrets/mysymlink\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"key.pem\"))\n\t})\n\n\tIt(\"podman run with FIPS mode secrets\", func() {\n\t\tSkipIfRootless(\"rootless can not manipulate system-fips file\")\n\t\tfipsFile := \"/etc/system-fips\"\n\t\terr = ioutil.WriteFile(fipsFile, []byte{}, 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", ALPINE, \"ls\", \"/run/secrets\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"system-fips\"))\n\n\t\terr = os.Remove(fipsFile)\n\t\tExpect(err).To(BeNil())\n\t})\n\n\tIt(\"podman run without group-add\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", ALPINE, \"id\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(Not(ContainSubstring(\"27(video),777,65533(nogroup)\")))\n\t})\n\n\tIt(\"podman run with group-add\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--group-add=audio\", \"--group-add=nogroup\", \"--group-add=777\", ALPINE, \"id\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"777,65533(nogroup)\"))\n\t})\n\n\tIt(\"podman run with user (default)\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", ALPINE, \"id\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"uid=0(root) gid=0(root)\"))\n\t})\n\n\tIt(\"podman run with user (integer, not in /etc/passwd)\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--user=1234\", ALPINE, \"id\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(Equal(\"uid=1234(1234) gid=0(root)\"))\n\t})\n\n\tIt(\"podman run with user (integer, in /etc/passwd)\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--user=8\", ALPINE, \"id\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"uid=8(mail) gid=12(mail)\"))\n\t})\n\n\tIt(\"podman run with user (username)\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--user=mail\", ALPINE, \"id\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"uid=8(mail) gid=12(mail)\"))\n\t})\n\n\tIt(\"podman run with user:group (username:integer)\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--user=mail:21\", ALPINE, \"id\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(Equal(\"uid=8(mail) gid=21(ftp)\"))\n\t})\n\n\tIt(\"podman run with user:group (integer:groupname)\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--user=8:ftp\", ALPINE, \"id\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(Equal(\"uid=8(mail) gid=21(ftp)\"))\n\t})\n\n\tIt(\"podman run with user, verify caps dropped\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--user=1234\", ALPINE, \"grep\", \"CapEff\", \"/proc/self/status\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tcapEff := strings.Split(session.OutputToString(), \" \")\n\t\tExpect(\"0000000000000000\").To(Equal(capEff[1]))\n\t})\n\n\tIt(\"podman run with attach stdin outputs container ID\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--attach\", \"stdin\", ALPINE, \"printenv\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tps := podmanTest.Podman([]string{\"ps\", \"-aq\", \"--no-trunc\"})\n\t\tps.WaitWithDefaultTimeout()\n\t\tExpect(ps).Should(Exit(0))\n\t\tExpect(ps.OutputToString()).To(ContainSubstring(session.OutputToString()))\n\t})\n\n\tIt(\"podman run with attach stdout does not print stderr\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--attach\", \"stdout\", ALPINE, \"ls\", \"/doesnotexist\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.OutputToString()).To(Equal(\"\"))\n\t})\n\n\tIt(\"podman run with attach stderr does not print stdout\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--attach\", \"stderr\", ALPINE, \"ls\", \"/\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(Equal(\"\"))\n\t})\n\n\tIt(\"podman run attach nonsense errors\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--attach\", \"asdfasdf\", ALPINE, \"ls\", \"/\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(125))\n\t})\n\n\tIt(\"podman run exit code on failure to exec\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", ALPINE, \"/etc\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(126))\n\t})\n\n\tIt(\"podman run error on exec\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", ALPINE, \"sh\", \"-c\", \"exit 100\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(100))\n\t})\n\n\tIt(\"podman run with named volume\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", ALPINE, \"stat\", \"-c\", \"%a %Y\", \"/var/tmp\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tperms := session.OutputToString()\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"-v\", \"test:/var/tmp\", ALPINE, \"stat\", \"-c\", \"%a %Y\", \"/var/tmp\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(Equal(perms))\n\t})\n\n\tIt(\"podman run with built-in volume image\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", redis, \"ls\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\n\t\tdockerfile := fmt.Sprintf(`FROM %s\nRUN mkdir -p /myvol/data && chown -R mail.0 /myvol\nVOLUME [\"/myvol/data\"]\nUSER mail`, BB)\n\n\t\tpodmanTest.BuildImage(dockerfile, \"test\", \"false\")\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"test\", \"ls\", \"-al\", \"/myvol/data\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"mail root\"))\n\t})\n\n\tIt(\"podman run --volumes-from flag\", func() {\n\t\tvol := filepath.Join(podmanTest.TempDir, \"vol-test\")\n\t\terr := os.MkdirAll(vol, 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\tfilename := \"test.txt\"\n\t\tvolFile := filepath.Join(vol, filename)\n\t\tdata := \"Testing --volumes-from!!!\"\n\t\terr = ioutil.WriteFile(volFile, []byte(data), 0755)\n\t\tExpect(err).To(BeNil())\n\t\tmountpoint := \"/myvol/\"\n\n\t\tsession := podmanTest.Podman([]string{\"create\", \"--volume\", vol + \":\" + mountpoint + \":z\", ALPINE, \"cat\", mountpoint + filename})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tctrID := session.OutputToString()\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--volumes-from\", ctrID, ALPINE, \"cat\", mountpoint + filename})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(Equal(data))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--volumes-from\", ctrID, ALPINE, \"sh\", \"-c\", \"echo test >> \" + mountpoint + filename})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\n\t\tsession = podmanTest.Podman([]string{\"start\", \"--attach\", ctrID})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(Equal(data + \"test\"))\n\t})\n\n\tIt(\"podman run --volumes-from flag options\", func() {\n\t\tvol := filepath.Join(podmanTest.TempDir, \"vol-test\")\n\t\terr := os.MkdirAll(vol, 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\tfilename := \"test.txt\"\n\t\tvolFile := filepath.Join(vol, filename)\n\t\tdata := \"Testing --volumes-from!!!\"\n\t\terr = ioutil.WriteFile(volFile, []byte(data), 0755)\n\t\tExpect(err).To(BeNil())\n\t\tmountpoint := \"/myvol/\"\n\n\t\tsession := podmanTest.Podman([]string{\"create\", \"--volume\", vol + \":\" + mountpoint, ALPINE, \"cat\", mountpoint + filename})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tctrID := session.OutputToString()\n\n\t\t// check that the read only option works\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--volumes-from\", ctrID + \":ro\", ALPINE, \"touch\", mountpoint + \"abc.txt\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(1))\n\t\tExpect(session.ErrorToString()).To(ContainSubstring(\"Read-only file system\"))\n\n\t\t// check that both z and ro options work\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--volumes-from\", ctrID + \":ro,z\", ALPINE, \"cat\", mountpoint + filename})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(Equal(data))\n\n\t\t// check that multiple ro/rw are not working\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--volumes-from\", ctrID + \":ro,rw\", ALPINE, \"cat\", mountpoint + filename})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(125))\n\t\tExpect(session.ErrorToString()).To(ContainSubstring(\"cannot set ro or rw options more than once\"))\n\n\t\t// check that multiple z options are not working\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--volumes-from\", ctrID + \":z,z,ro\", ALPINE, \"cat\", mountpoint + filename})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(125))\n\t\tExpect(session.ErrorToString()).To(ContainSubstring(\"cannot set :z more than once in mount options\"))\n\n\t\t// create new read only volume\n\t\tsession = podmanTest.Podman([]string{\"create\", \"--volume\", vol + \":\" + mountpoint + \":ro\", ALPINE, \"cat\", mountpoint + filename})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tctrID = session.OutputToString()\n\n\t\t// check if the original volume was mounted as read only that --volumes-from also mount it as read only\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--volumes-from\", ctrID, ALPINE, \"touch\", mountpoint + \"abc.txt\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(1))\n\t\tExpect(session.ErrorToString()).To(ContainSubstring(\"Read-only file system\"))\n\t})\n\n\tIt(\"podman run --volumes-from flag with built-in volumes\", func() {\n\t\tsession := podmanTest.Podman([]string{\"create\", redis, \"sh\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tctrID := session.OutputToString()\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--volumes-from\", ctrID, ALPINE, \"ls\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"data\"))\n\t})\n\n\tIt(\"podman run --volumes flag with multiple volumes\", func() {\n\t\tvol1 := filepath.Join(podmanTest.TempDir, \"vol-test1\")\n\t\terr := os.MkdirAll(vol1, 0755)\n\t\tExpect(err).To(BeNil())\n\t\tvol2 := filepath.Join(podmanTest.TempDir, \"vol-test2\")\n\t\terr = os.MkdirAll(vol2, 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--volume\", vol1 + \":/myvol1:z\", \"--volume\", vol2 + \":/myvol2:z\", ALPINE, \"touch\", \"/myvol2/foo.txt\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t})\n\n\tIt(\"podman run --volumes flag with empty host dir\", func() {\n\t\tvol1 := filepath.Join(podmanTest.TempDir, \"vol-test1\")\n\t\terr := os.MkdirAll(vol1, 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--volume\", \":/myvol1:z\", ALPINE, \"touch\", \"/myvol2/foo.txt\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).To(ExitWithError())\n\t\tExpect(session.ErrorToString()).To(ContainSubstring(\"directory cannot be empty\"))\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--volume\", vol1 + \":\", ALPINE, \"touch\", \"/myvol2/foo.txt\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).To(ExitWithError())\n\t\tExpect(session.ErrorToString()).To(ContainSubstring(\"directory cannot be empty\"))\n\t})\n\n\tIt(\"podman run --mount flag with multiple mounts\", func() {\n\t\tvol1 := filepath.Join(podmanTest.TempDir, \"vol-test1\")\n\t\terr := os.MkdirAll(vol1, 0755)\n\t\tExpect(err).To(BeNil())\n\t\tvol2 := filepath.Join(podmanTest.TempDir, \"vol-test2\")\n\t\terr = os.MkdirAll(vol2, 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--mount\", \"type=bind,src=\" + vol1 + \",target=/myvol1,z\", \"--mount\", \"type=bind,src=\" + vol2 + \",target=/myvol2,z\", ALPINE, \"touch\", \"/myvol2/foo.txt\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t})\n\n\tIt(\"podman run findmnt nothing shared\", func() {\n\t\tvol1 := filepath.Join(podmanTest.TempDir, \"vol-test1\")\n\t\terr := os.MkdirAll(vol1, 0755)\n\t\tExpect(err).To(BeNil())\n\t\tvol2 := filepath.Join(podmanTest.TempDir, \"vol-test2\")\n\t\terr = os.MkdirAll(vol2, 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--volume\", vol1 + \":/myvol1:z\", \"--volume\", vol2 + \":/myvol2:z\", fedoraMinimal, \"findmnt\", \"-o\", \"TARGET,PROPAGATION\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(Not(ContainSubstring(\"shared\")))\n\t})\n\n\tIt(\"podman run findmnt shared\", func() {\n\t\tvol1 := filepath.Join(podmanTest.TempDir, \"vol-test1\")\n\t\terr := os.MkdirAll(vol1, 0755)\n\t\tExpect(err).To(BeNil())\n\t\tvol2 := filepath.Join(podmanTest.TempDir, \"vol-test2\")\n\t\terr = os.MkdirAll(vol2, 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--volume\", vol1 + \":/myvol1:z\", \"--volume\", vol2 + \":/myvol2:shared,z\", fedoraMinimal, \"findmnt\", \"-o\", \"TARGET,PROPAGATION\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tmatch, shared := session.GrepString(\"shared\")\n\t\tExpect(match).Should(BeTrue())\n\t\t// make sure it's only shared (and not 'shared,slave')\n\t\tisSharedOnly := !strings.Contains(shared[0], \"shared,\")\n\t\tExpect(isSharedOnly).Should(BeTrue())\n\t})\n\n\tIt(\"podman run --security-opts proc-opts=\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--security-opt\", \"proc-opts=nosuid,exec\", fedoraMinimal, \"findmnt\", \"-noOPTIONS\", \"/proc\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\toutput := session.OutputToString()\n\t\tExpect(output).To(ContainSubstring(\"nosuid\"))\n\t\tExpect(output).To(Not(ContainSubstring(\"exec\")))\n\t})\n\n\tIt(\"podman run --mount type=bind,bind-nonrecursive\", func() {\n\t\tSkipIfRootless(\"FIXME: rootless users are not allowed to mount bind-nonrecursive (Could this be a Kernel bug?\")\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--mount\", \"type=bind,bind-nonrecursive,slave,src=/,target=/host\", fedoraMinimal, \"findmnt\", \"-nR\", \"/host\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToStringArray()).To(HaveLen(1))\n\t})\n\n\tIt(\"podman run --mount type=devpts,target=/foo/bar\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--mount\", \"type=devpts,target=/foo/bar\", fedoraMinimal, \"stat\", \"-f\", \"-c%T\", \"/foo/bar\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"devpts\"))\n\t})\n\n\tIt(\"podman run --mount type=devpts,target=/dev/pts with uid, gid and mode\", func() {\n\t\t// runc doesn't seem to honor uid= so avoid testing it\n\t\tsession := podmanTest.Podman([]string{\"run\", \"-t\", \"--mount\", \"type=devpts,target=/dev/pts,uid=1000,gid=1001,mode=123\", fedoraMinimal, \"stat\", \"-c%g-%a\", \"/dev/pts/0\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"1001-123\"))\n\t})\n\n\tIt(\"podman run --pod automatically\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"-d\", \"--pod\", \"new:foobar\", ALPINE, \"nc\", \"-l\", \"-p\", \"8686\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--pod\", \"foobar\", ALPINE, \"/bin/sh\", \"-c\", \"echo test | nc -w 1 127.0.0.1 8686\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\n\t\tcheck := podmanTest.Podman([]string{\"pod\", \"ps\", \"--no-trunc\"})\n\t\tcheck.WaitWithDefaultTimeout()\n\t\tExpect(check.OutputToString()).To(ContainSubstring(\"foobar\"))\n\t})\n\n\tIt(\"podman run --pod new with hostname\", func() {\n\t\thostname := \"abc\"\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--pod\", \"new:foobar\", \"--hostname\", hostname, ALPINE, \"cat\", \"/etc/hostname\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(hostname))\n\t})\n\n\tIt(\"podman run --rm should work\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--name\", \"test\", \"--rm\", ALPINE, \"ls\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tsession = podmanTest.Podman([]string{\"wait\", \"test\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).To(ExitWithError())\n\n\t\tnumContainers := podmanTest.NumberOfContainers()\n\t\tExpect(numContainers).To(Equal(0))\n\t})\n\n\tIt(\"podman run --rm failed container should delete itself\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--name\", \"test\", \"--rm\", ALPINE, \"foo\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).To(ExitWithError())\n\t\tsession = podmanTest.Podman([]string{\"wait\", \"test\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).To(ExitWithError())\n\n\t\tnumContainers := podmanTest.NumberOfContainers()\n\t\tExpect(numContainers).To(Equal(0))\n\t})\n\n\tIt(\"podman run failed container should NOT delete itself\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", ALPINE, \"foo\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).To(ExitWithError())\n\t\t// If remote we could have a race condition\n\t\tsession = podmanTest.Podman([]string{\"wait\", \"test\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).To(ExitWithError())\n\n\t\tnumContainers := podmanTest.NumberOfContainers()\n\t\tExpect(numContainers).To(Equal(1))\n\t})\n\tIt(\"podman run readonly container should NOT mount /dev/shm read/only\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--read-only\", ALPINE, \"mount\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\n\t\tExpect(session.OutputToString()).To(Not(ContainSubstring(\"/dev/shm type tmpfs (ro,\")))\n\t})\n\n\tIt(\"podman run readonly container should NOT mount /run noexec\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--read-only\", ALPINE, \"sh\", \"-c\", \"mount  | grep \\\"/run \\\"\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\n\t\tExpect(session.OutputToString()).To(Not(ContainSubstring(\"noexec\")))\n\t})\n\n\tIt(\"podman run with bad healthcheck retries\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"-dt\", \"--health-cmd\", \"[\\\"foo\\\"]\", \"--health-retries\", \"0\", ALPINE, \"top\"})\n\t\tsession.Wait()\n\t\tExpect(session).To(ExitWithError())\n\t\tExpect(session.ErrorToString()).To(ContainSubstring(\"healthcheck-retries must be greater than 0\"))\n\t})\n\n\tIt(\"podman run with bad healthcheck timeout\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"-dt\", \"--health-cmd\", \"foo\", \"--health-timeout\", \"0s\", ALPINE, \"top\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).To(ExitWithError())\n\t\tExpect(session.ErrorToString()).To(ContainSubstring(\"healthcheck-timeout must be at least 1 second\"))\n\t})\n\n\tIt(\"podman run with bad healthcheck start-period\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"-dt\", \"--health-cmd\", \"foo\", \"--health-start-period\", \"-1s\", ALPINE, \"top\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).To(ExitWithError())\n\t\tExpect(session.ErrorToString()).To(ContainSubstring(\"healthcheck-start-period must be 0 seconds or greater\"))\n\t})\n\n\tIt(\"podman run with --add-host and --no-hosts fails\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"-dt\", \"--add-host\", \"test1:127.0.0.1\", \"--no-hosts\", ALPINE, \"top\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).To(ExitWithError())\n\t})\n\n\tIt(\"podman run with restart-policy always restarts containers\", func() {\n\t\ttestDir := filepath.Join(podmanTest.RunRoot, \"restart-test\")\n\t\terr := os.MkdirAll(testDir, 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\taliveFile := filepath.Join(testDir, \"running\")\n\t\tfile, err := os.Create(aliveFile)\n\t\tExpect(err).To(BeNil())\n\t\tfile.Close()\n\n\t\tsession := podmanTest.Podman([]string{\"run\", \"-dt\", \"--restart\", \"always\", \"-v\", fmt.Sprintf(\"%s:/tmp/runroot:Z\", testDir), ALPINE, \"sh\", \"-c\", \"touch /tmp/runroot/ran && while test -r /tmp/runroot/running; do sleep 0.1s; done\"})\n\n\t\tfound := false\n\t\ttestFile := filepath.Join(testDir, \"ran\")\n\t\tfor i := 0; i < 30; i++ {\n\t\t\ttime.Sleep(1 * time.Second)\n\t\t\tif _, err := os.Stat(testFile); err == nil {\n\t\t\t\tfound = true\n\t\t\t\terr = os.Remove(testFile)\n\t\t\t\tExpect(err).To(BeNil())\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tExpect(found).To(BeTrue())\n\n\t\terr = os.Remove(aliveFile)\n\t\tExpect(err).To(BeNil())\n\n\t\tsession.WaitWithDefaultTimeout()\n\n\t\t// 10 seconds to restart the container\n\t\tfound = false\n\t\tfor i := 0; i < 10; i++ {\n\t\t\ttime.Sleep(1 * time.Second)\n\t\t\tif _, err := os.Stat(testFile); err == nil {\n\t\t\t\tfound = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tExpect(found).To(BeTrue())\n\t})\n\n\tIt(\"podman run with cgroups=split\", func() {\n\t\tSkipIfNotSystemd(podmanTest.CgroupManager, \"do not test --cgroups=split if not running on systemd\")\n\t\tSkipIfRootlessCgroupsV1(\"Disable cgroups not supported on cgroupv1 for rootless users\")\n\t\tSkipIfRemote(\"--cgroups=split cannot be used in remote mode\")\n\n\t\tcheckLines := func(lines []string) {\n\t\t\tcgroup := \"\"\n\t\t\tfor _, line := range lines {\n\t\t\t\tparts := strings.SplitN(line, \":\", 3)\n\t\t\t\tif len(parts) < 2 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif !CGROUPSV2 {\n\t\t\t\t\t// ignore unified on cgroup v1.\n\t\t\t\t\t// both runc and crun do not set it.\n\t\t\t\t\t// crun does not set named hierarchies.\n\t\t\t\t\tif parts[1] == \"\" || strings.Contains(parts[1], \"name=\") {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif parts[2] == \"/\" {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif cgroup == \"\" {\n\t\t\t\t\tcgroup = parts[2]\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tExpect(cgroup).To(Equal(parts[2]))\n\t\t\t}\n\t\t}\n\n\t\tcontainer := podmanTest.PodmanSystemdScope([]string{\"run\", \"--rm\", \"--cgroups=split\", ALPINE, \"cat\", \"/proc/self/cgroup\"})\n\t\tcontainer.WaitWithDefaultTimeout()\n\t\tExpect(container).Should(Exit(0))\n\t\tcheckLines(container.OutputToStringArray())\n\n\t\t// check that --cgroups=split is honored also when a container runs in a pod\n\t\tcontainer = podmanTest.PodmanSystemdScope([]string{\"run\", \"--rm\", \"--pod\", \"new:split-test-pod\", \"--cgroups=split\", ALPINE, \"cat\", \"/proc/self/cgroup\"})\n\t\tcontainer.WaitWithDefaultTimeout()\n\t\tExpect(container).Should(Exit(0))\n\t\tcheckLines(container.OutputToStringArray())\n\t})\n\n\tIt(\"podman run with cgroups=disabled runs without cgroups\", func() {\n\t\tSkipIfRootlessCgroupsV1(\"Disable cgroups not supported on cgroupv1 for rootless users\")\n\t\t// Only works on crun\n\t\tif !strings.Contains(podmanTest.OCIRuntime, \"crun\") {\n\t\t\tSkip(\"Test only works on crun\")\n\t\t}\n\n\t\townsCgroup, err := cgroups.UserOwnsCurrentSystemdCgroup()\n\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\tif !ownsCgroup {\n\t\t\t// Podman moves itself to a new cgroup if it doesn't own the current cgroup\n\t\t\tSkip(\"Test only works when Podman owns the current cgroup\")\n\t\t}\n\n\t\ttrim := func(i string) string {\n\t\t\treturn strings.TrimSuffix(i, \"\\n\")\n\t\t}\n\n\t\tcurCgroupsBytes, err := ioutil.ReadFile(\"/proc/self/cgroup\")\n\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\tcurCgroups := trim(string(curCgroupsBytes))\n\t\tfmt.Printf(\"Output:\\n%s\\n\", curCgroups)\n\t\tExpect(curCgroups).ToNot(Equal(\"\"))\n\n\t\tcontainer := podmanTest.Podman([]string{\"run\", \"--cgroupns=host\", \"--cgroups=disabled\", ALPINE, \"cat\", \"/proc/self/cgroup\"})\n\t\tcontainer.WaitWithDefaultTimeout()\n\t\tExpect(container).Should(Exit(0))\n\n\t\tctrCgroups := trim(container.OutputToString())\n\t\tfmt.Printf(\"Output\\n:%s\\n\", ctrCgroups)\n\n\t\tExpect(ctrCgroups).To(Equal(curCgroups))\n\t})\n\n\tIt(\"podman run with cgroups=enabled makes cgroups\", func() {\n\t\tSkipIfRootlessCgroupsV1(\"Enable cgroups not supported on cgroupv1 for rootless users\")\n\t\t// Only works on crun\n\t\tif !strings.Contains(podmanTest.OCIRuntime, \"crun\") {\n\t\t\tSkip(\"Test only works on crun\")\n\t\t}\n\n\t\tcurCgroupsBytes, err := ioutil.ReadFile(\"/proc/self/cgroup\")\n\t\tExpect(err).To(BeNil())\n\t\tvar curCgroups string = string(curCgroupsBytes)\n\t\tfmt.Printf(\"Output:\\n%s\\n\", curCgroups)\n\t\tExpect(curCgroups).To(Not(Equal(\"\")))\n\n\t\tctrName := \"testctr\"\n\t\tcontainer := podmanTest.Podman([]string{\"run\", \"--name\", ctrName, \"-d\", \"--cgroups=enabled\", ALPINE, \"top\"})\n\t\tcontainer.WaitWithDefaultTimeout()\n\t\tExpect(container).Should(Exit(0))\n\n\t\t// Get PID and get cgroups of that PID\n\t\tinspectOut := podmanTest.InspectContainer(ctrName)\n\t\tExpect(inspectOut).To(HaveLen(1))\n\t\tpid := inspectOut[0].State.Pid\n\t\tExpect(pid).To(Not(Equal(0)))\n\n\t\tctrCgroupsBytes, err := ioutil.ReadFile(fmt.Sprintf(\"/proc/%d/cgroup\", pid))\n\t\tExpect(err).To(BeNil())\n\t\tvar ctrCgroups string = string(ctrCgroupsBytes)\n\t\tfmt.Printf(\"Output\\n:%s\\n\", ctrCgroups)\n\t\tExpect(curCgroups).To(Not(Equal(ctrCgroups)))\n\t})\n\n\tIt(\"podman run with cgroups=garbage errors\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"-d\", \"--cgroups=garbage\", ALPINE, \"top\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).To(ExitWithError())\n\t})\n\n\tIt(\"podman run should fail with nonexistent authfile\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--authfile\", \"/tmp/nonexistent\", ALPINE, \"ls\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).To(ExitWithError())\n\t})\n\n\tIt(\"podman run --device-cgroup-rule\", func() {\n\t\tSkipIfRootless(\"rootless users are not allowed to mknod\")\n\t\tdeviceCgroupRule := \"c 42:* rwm\"\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--cap-add\", \"mknod\", \"--name\", \"test\", \"-d\", \"--device-cgroup-rule\", deviceCgroupRule, ALPINE, \"top\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tsession = podmanTest.Podman([]string{\"exec\", \"test\", \"mknod\", \"newDev\", \"c\", \"42\", \"1\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t})\n\n\tIt(\"podman run --replace\", func() {\n\t\t// Make sure we error out with --name.\n\t\tsession := podmanTest.Podman([]string{\"create\", \"--replace\", ALPINE, \"/bin/sh\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(125))\n\n\t\t// Run and replace 5 times in a row the \"same\" container.\n\t\tctrName := \"testCtr\"\n\t\tfor i := 0; i < 5; i++ {\n\t\t\tsession := podmanTest.Podman([]string{\"run\", \"--detach\", \"--replace\", \"--name\", ctrName, ALPINE, \"/bin/sh\"})\n\t\t\tsession.WaitWithDefaultTimeout()\n\t\t\tExpect(session).Should(Exit(0))\n\t\t}\n\t})\n\n\tIt(\"podman run --preserve-fds\", func() {\n\t\tdevNull, err := os.Open(\"/dev/null\")\n\t\tExpect(err).To(BeNil())\n\t\tdefer devNull.Close()\n\t\tfiles := []*os.File{\n\t\t\tdevNull,\n\t\t}\n\t\tsession := podmanTest.PodmanExtraFiles([]string{\"run\", \"--preserve-fds\", \"1\", ALPINE, \"ls\"}, files)\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t})\n\n\tIt(\"podman run --preserve-fds invalid fd\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--preserve-fds\", \"2\", ALPINE})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).To(ExitWithError())\n\t\tExpect(session.ErrorToString()).To(ContainSubstring(\"file descriptor 3 is not available\"))\n\t})\n\n\tIt(\"podman run --privileged and --group-add\", func() {\n\t\tgroupName := \"mail\"\n\t\tsession := podmanTest.Podman([]string{\"run\", \"-t\", \"-i\", \"--group-add\", groupName, \"--privileged\", fedoraMinimal, \"groups\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(groupName))\n\t})\n\n\tIt(\"podman run --tz\", func() {\n\t\ttestDir := filepath.Join(podmanTest.RunRoot, \"tz-test\")\n\t\terr := os.MkdirAll(testDir, 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\ttzFile := filepath.Join(testDir, \"tzfile.txt\")\n\t\tfile, err := os.Create(tzFile)\n\t\tExpect(err).To(BeNil())\n\n\t\t_, err = file.WriteString(\"Hello\")\n\t\tExpect(err).To(BeNil())\n\t\tfile.Close()\n\n\t\tbadTZFile := fmt.Sprintf(\"../../../%s\", tzFile)\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--tz\", badTZFile, \"--rm\", ALPINE, \"date\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).To(ExitWithError())\n\t\tExpect(session.ErrorToString()).To(ContainSubstring(\"error finding timezone for container\"))\n\n\t\terr = os.Remove(tzFile)\n\t\tExpect(err).To(BeNil())\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--tz\", \"foo\", \"--rm\", ALPINE, \"date\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).To(ExitWithError())\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--tz\", \"America\", \"--rm\", ALPINE, \"date\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).To(ExitWithError())\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--tz\", \"Pacific/Honolulu\", \"--rm\", ALPINE, \"date\", \"+'%H %Z'\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"HST\"))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--tz\", \"local\", \"--rm\", ALPINE, \"date\", \"+'%H %Z'\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tt := time.Now()\n\t\tz, _ := t.Zone()\n\t\th := strconv.Itoa(t.Hour())\n\t\tExpect(session.OutputToString()).To(ContainSubstring(z))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(h))\n\n\t})\n\n\tIt(\"podman run verify pids-limit\", func() {\n\t\tSkipIfCgroupV1(\"pids-limit not supported on cgroup V1\")\n\t\tlimit := \"4321\"\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--pids-limit\", limit, \"--net=none\", \"--rm\", ALPINE, \"cat\", \"/sys/fs/cgroup/pids.max\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(limit))\n\t})\n\n\tIt(\"podman run umask\", func() {\n\t\tif !strings.Contains(podmanTest.OCIRuntime, \"crun\") {\n\t\t\tSkip(\"Test only works on crun\")\n\t\t}\n\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", ALPINE, \"sh\", \"-c\", \"umask\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(Equal(\"0022\"))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--umask\", \"0002\", \"--rm\", ALPINE, \"sh\", \"-c\", \"umask\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(Equal(\"0002\"))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--umask\", \"0077\", \"--rm\", fedoraMinimal, \"umask\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(Equal(\"0077\"))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--umask\", \"22\", \"--rm\", ALPINE, \"sh\", \"-c\", \"umask\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(Equal(\"0022\"))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--umask\", \"9999\", \"--rm\", ALPINE, \"sh\", \"-c\", \"umask\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).To(ExitWithError())\n\t\tExpect(session.ErrorToString()).To(ContainSubstring(\"Invalid umask\"))\n\t})\n\n\tIt(\"podman run makes workdir from image\", func() {\n\t\t// BuildImage does not seem to work remote\n\t\tdockerfile := fmt.Sprintf(`FROM %s\nWORKDIR /madethis`, BB)\n\t\tpodmanTest.BuildImage(dockerfile, \"test\", \"false\")\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"test\", \"pwd\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"/madethis\"))\n\t})\n\n\tIt(\"podman run --entrypoint does not use image command\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--entrypoint\", \"/bin/echo\", ALPINE})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\t// We can't guarantee the output is completely empty, some\n\t\t// nonprintables seem to work their way in.\n\t\tExpect(session.OutputToString()).To(Not(ContainSubstring(\"/bin/sh\")))\n\t})\n\n\tIt(\"podman run a container with log-level (lower case)\", func() {\n\t\tsession := podmanTest.Podman([]string{\"--log-level=info\", \"run\", ALPINE, \"ls\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t})\n\n\tIt(\"podman run a container with log-level (upper case)\", func() {\n\t\tsession := podmanTest.Podman([]string{\"--log-level=INFO\", \"run\", ALPINE, \"ls\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t})\n\n\tIt(\"podman run a container with --pull never should fail if no local store\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--pull\", \"never\", \"docker.io/library/debian:latest\", \"ls\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(125))\n\t})\n\n\tIt(\"podman run container with --pull missing and only pull once\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--pull\", \"missing\", cirros, \"ls\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.ErrorToString()).To(ContainSubstring(\"Trying to pull\"))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--pull\", \"missing\", cirros, \"ls\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.ErrorToString()).ToNot(ContainSubstring(\"Trying to pull\"))\n\t})\n\n\tIt(\"podman run container with --pull missing should pull image multiple times\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--pull\", \"always\", cirros, \"ls\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.ErrorToString()).To(ContainSubstring(\"Trying to pull\"))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--pull\", \"always\", cirros, \"ls\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.ErrorToString()).To(ContainSubstring(\"Trying to pull\"))\n\t})\n\n\tIt(\"podman run container with hostname and hostname environment variable\", func() {\n\t\thostnameEnv := \"test123\"\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--hostname\", \"testctr\", \"--env\", fmt.Sprintf(\"HOSTNAME=%s\", hostnameEnv), ALPINE, \"printenv\", \"HOSTNAME\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(hostnameEnv))\n\t})\n\n\tIt(\"podman run --secret\", func() {\n\t\tsecretsString := \"somesecretdata\"\n\t\tsecretFilePath := filepath.Join(podmanTest.TempDir, \"secret\")\n\t\terr := ioutil.WriteFile(secretFilePath, []byte(secretsString), 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\tsession := podmanTest.Podman([]string{\"secret\", \"create\", \"mysecret\", secretFilePath})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--secret\", \"mysecret\", \"--name\", \"secr\", ALPINE, \"cat\", \"/run/secrets/mysecret\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(Equal(secretsString))\n\n\t\tsession = podmanTest.Podman([]string{\"inspect\", \"secr\", \"--format\", \" {{(index .Config.Secrets 0).Name}}\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"mysecret\"))\n\n\t})\n\n\tIt(\"podman run --secret source=mysecret,type=mount\", func() {\n\t\tsecretsString := \"somesecretdata\"\n\t\tsecretFilePath := filepath.Join(podmanTest.TempDir, \"secret\")\n\t\terr := ioutil.WriteFile(secretFilePath, []byte(secretsString), 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\tsession := podmanTest.Podman([]string{\"secret\", \"create\", \"mysecret\", secretFilePath})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--secret\", \"source=mysecret,type=mount\", \"--name\", \"secr\", ALPINE, \"cat\", \"/run/secrets/mysecret\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(Equal(secretsString))\n\n\t\tsession = podmanTest.Podman([]string{\"inspect\", \"secr\", \"--format\", \" {{(index .Config.Secrets 0).Name}}\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"mysecret\"))\n\n\t})\n\n\tIt(\"podman run --secret source=mysecret,type=mount with target\", func() {\n\t\tsecretsString := \"somesecretdata\"\n\t\tsecretFilePath := filepath.Join(podmanTest.TempDir, \"secret\")\n\t\terr := ioutil.WriteFile(secretFilePath, []byte(secretsString), 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\tsession := podmanTest.Podman([]string{\"secret\", \"create\", \"mysecret_target\", secretFilePath})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--secret\", \"source=mysecret_target,type=mount,target=hello\", \"--name\", \"secr_target\", ALPINE, \"cat\", \"/run/secrets/hello\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(Equal(secretsString))\n\n\t\tsession = podmanTest.Podman([]string{\"inspect\", \"secr_target\", \"--format\", \" {{(index .Config.Secrets 0).Name}}\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"mysecret_target\"))\n\n\t})\n\n\tIt(\"podman run --secret source=mysecret,type=mount with target at /tmp\", func() {\n\t\tsecretsString := \"somesecretdata\"\n\t\tsecretFilePath := filepath.Join(podmanTest.TempDir, \"secret\")\n\t\terr := ioutil.WriteFile(secretFilePath, []byte(secretsString), 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\tsession := podmanTest.Podman([]string{\"secret\", \"create\", \"mysecret_target2\", secretFilePath})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--secret\", \"source=mysecret_target2,type=mount,target=/tmp/hello\", \"--name\", \"secr_target2\", ALPINE, \"cat\", \"/tmp/hello\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(Equal(secretsString))\n\n\t\tsession = podmanTest.Podman([]string{\"inspect\", \"secr_target2\", \"--format\", \" {{(index .Config.Secrets 0).Name}}\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"mysecret_target2\"))\n\n\t})\n\n\tIt(\"podman run --secret source=mysecret,type=env\", func() {\n\t\tsecretsString := \"somesecretdata\"\n\t\tsecretFilePath := filepath.Join(podmanTest.TempDir, \"secret\")\n\t\terr := ioutil.WriteFile(secretFilePath, []byte(secretsString), 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\tsession := podmanTest.Podman([]string{\"secret\", \"create\", \"mysecret\", secretFilePath})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--secret\", \"source=mysecret,type=env\", \"--name\", \"secr\", ALPINE, \"printenv\", \"mysecret\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(Equal(secretsString))\n\t})\n\n\tIt(\"podman run --secret target option\", func() {\n\t\tsecretsString := \"somesecretdata\"\n\t\tsecretFilePath := filepath.Join(podmanTest.TempDir, \"secret\")\n\t\terr := ioutil.WriteFile(secretFilePath, []byte(secretsString), 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\tsession := podmanTest.Podman([]string{\"secret\", \"create\", \"mysecret\", secretFilePath})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--secret\", \"source=mysecret,type=env,target=anotherplace\", \"--name\", \"secr\", ALPINE, \"printenv\", \"anotherplace\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(Equal(secretsString))\n\t})\n\n\tIt(\"podman run --secret mount with uid, gid, mode options\", func() {\n\t\tsecretsString := \"somesecretdata\"\n\t\tsecretFilePath := filepath.Join(podmanTest.TempDir, \"secret\")\n\t\terr := ioutil.WriteFile(secretFilePath, []byte(secretsString), 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\tsession := podmanTest.Podman([]string{\"secret\", \"create\", \"mysecret\", secretFilePath})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\n\t\t// check default permissions\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--secret\", \"mysecret\", \"--name\", \"secr\", ALPINE, \"ls\", \"-l\", \"/run/secrets/mysecret\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\toutput := session.OutputToString()\n\t\tExpect(output).To(ContainSubstring(\"-r--r--r--\"))\n\t\tExpect(output).To(ContainSubstring(\"root\"))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--secret\", \"source=mysecret,type=mount,uid=1000,gid=1001,mode=777\", \"--name\", \"secr2\", ALPINE, \"ls\", \"-ln\", \"/run/secrets/mysecret\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\toutput = session.OutputToString()\n\t\tExpect(output).To(ContainSubstring(\"-rwxrwxrwx\"))\n\t\tExpect(output).To(ContainSubstring(\"1000\"))\n\t\tExpect(output).To(ContainSubstring(\"1001\"))\n\t})\n\n\tIt(\"podman run --secret with --user\", func() {\n\t\tsecretsString := \"somesecretdata\"\n\t\tsecretFilePath := filepath.Join(podmanTest.TempDir, \"secret\")\n\t\terr := ioutil.WriteFile(secretFilePath, []byte(secretsString), 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\tsession := podmanTest.Podman([]string{\"secret\", \"create\", \"mysecret\", secretFilePath})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--secret\", \"mysecret\", \"--name\", \"nonroot\", \"--user\", \"200:200\", ALPINE, \"cat\", \"/run/secrets/mysecret\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(Equal(secretsString))\n\t})\n\n\tIt(\"podman run invalid secret option\", func() {\n\t\tsecretsString := \"somesecretdata\"\n\t\tsecretFilePath := filepath.Join(podmanTest.TempDir, \"secret\")\n\t\terr := ioutil.WriteFile(secretFilePath, []byte(secretsString), 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\tsession := podmanTest.Podman([]string{\"secret\", \"create\", \"mysecret\", secretFilePath})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\n\t\t// Invalid type\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--secret\", \"source=mysecret,type=other\", \"--name\", \"secr\", ALPINE, \"printenv\", \"mysecret\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).To(ExitWithError())\n\n\t\t// Invalid option\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--secret\", \"source=mysecret,invalid=invalid\", \"--name\", \"secr\", ALPINE, \"printenv\", \"mysecret\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).To(ExitWithError())\n\n\t\t// Option syntax not valid\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--secret\", \"source=mysecret,type\", \"--name\", \"secr\", ALPINE, \"printenv\", \"mysecret\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).To(ExitWithError())\n\n\t\t// mount option with env type\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--secret\", \"source=mysecret,type=env,uid=1000\", \"--name\", \"secr\", ALPINE, \"printenv\", \"mysecret\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).To(ExitWithError())\n\n\t\t// No source given\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--secret\", \"type=env\", \"--name\", \"secr\", ALPINE, \"printenv\", \"mysecret\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).To(ExitWithError())\n\t})\n\n\tIt(\"podman run --requires\", func() {\n\t\tdepName := \"ctr1\"\n\t\tdepContainer := podmanTest.Podman([]string{\"create\", \"--name\", depName, ALPINE, \"top\"})\n\t\tdepContainer.WaitWithDefaultTimeout()\n\t\tExpect(depContainer).Should(Exit(0))\n\n\t\tmainName := \"ctr2\"\n\t\tmainContainer := podmanTest.Podman([]string{\"run\", \"--name\", mainName, \"--requires\", depName, \"-d\", ALPINE, \"top\"})\n\t\tmainContainer.WaitWithDefaultTimeout()\n\t\tExpect(mainContainer).Should(Exit(0))\n\n\t\tstop := podmanTest.Podman([]string{\"stop\", \"--all\"})\n\t\tstop.WaitWithDefaultTimeout()\n\t\tExpect(stop).Should(Exit(0))\n\n\t\tstart := podmanTest.Podman([]string{\"start\", mainName})\n\t\tstart.WaitWithDefaultTimeout()\n\t\tExpect(start).Should(Exit(0))\n\n\t\trunning := podmanTest.Podman([]string{\"ps\", \"-q\"})\n\t\trunning.WaitWithDefaultTimeout()\n\t\tExpect(running).Should(Exit(0))\n\t\tExpect(running.OutputToStringArray()).To(HaveLen(2))\n\t})\n\n\tIt(\"podman run with pidfile\", func() {\n\t\tSkipIfRemote(\"pidfile not handled by remote\")\n\t\tpidfile := tempdir + \"pidfile\"\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--pidfile\", pidfile, ALPINE, \"ls\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\treadFirstLine := func(path string) string {\n\t\t\tcontent, err := ioutil.ReadFile(path)\n\t\t\tExpect(err).To(BeNil())\n\t\t\treturn strings.Split(string(content), \"\\n\")[0]\n\t\t}\n\t\tcontainerPID := readFirstLine(pidfile)\n\t\t_, err = strconv.Atoi(containerPID) // Make sure it's a proper integer\n\t\tExpect(err).To(BeNil())\n\t})\n\n\tIt(\"podman run check personality support\", func() {\n\t\t// TODO: Remove this as soon as this is merged and made available in our CI https://github.com/opencontainers/runc/pull/3126.\n\t\tif !strings.Contains(podmanTest.OCIRuntime, \"crun\") {\n\t\t\tSkip(\"Test only works on crun\")\n\t\t}\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--personality=LINUX32\", \"--name=testpersonality\", ALPINE, \"uname\", \"-a\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"i686\"))\n\t})\n\n\tIt(\"podman run /dev/shm has nosuid,noexec,nodev\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", ALPINE, \"grep\", \"/dev/shm\", \"/proc/self/mountinfo\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session).Should(Exit(0))\n\t\toutput := session.OutputToString()\n\t\tExpect(output).To(ContainSubstring(\"nosuid\"))\n\t\tExpect(output).To(ContainSubstring(\"noexec\"))\n\t\tExpect(output).To(ContainSubstring(\"nodev\"))\n\t})\n})\n"], "filenames": ["libpod/oci_conmon_exec_linux.go", "pkg/specgen/generate/security.go", "test/e2e/run_test.go"], "buggy_code_start_loc": [760, 148, 500], "buggy_code_end_loc": [766, 183, 554], "fixing_code_start_loc": [761, 149, 501], "fixing_code_end_loc": [768, 187, 554], "type": "CWE-276", "message": "A flaw was found in Podman, where containers were started incorrectly with non-empty default permissions. A vulnerability was found in Moby (Docker Engine), where containers were started incorrectly with non-empty inheritable Linux process capabilities. This flaw allows an attacker with access to programs with inheritable file capabilities to elevate those capabilities to the permitted set when execve(2) runs.", "other": {"cve": {"id": "CVE-2022-27649", "sourceIdentifier": "secalert@redhat.com", "published": "2022-04-04T20:15:10.890", "lastModified": "2022-07-22T10:32:42.557", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A flaw was found in Podman, where containers were started incorrectly with non-empty default permissions. A vulnerability was found in Moby (Docker Engine), where containers were started incorrectly with non-empty inheritable Linux process capabilities. This flaw allows an attacker with access to programs with inheritable file capabilities to elevate those capabilities to the permitted set when execve(2) runs."}, {"lang": "es", "value": "Se ha encontrado un fallo en Podman, donde los contenedores eran iniciados incorrectamente con permisos por defecto no vac\u00edos. Se ha  encontrado una vulnerabilidad en Moby (Docker Engine), donde los contenedores eran iniciados incorrectamente con capacidades de proceso Linux heredables no vac\u00edas. Este fallo permite a un atacante con acceso a programas con capacidades de archivo heredables elevar esas capacidades al conjunto permitido cuando es ejecutado execve(2)"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.6, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 6.8, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-276"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-276"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:podman_project:podman:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.0.3", "matchCriteriaId": "604D6316-6B11-47F6-8016-A0091A2B9003"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:developer_tools:1.0:*:*:*:*:*:*:*", "matchCriteriaId": "60937D60-6B78-400F-8D30-7FCF328659A1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:openshift_container_platform:4.0:*:*:*:*:*:*:*", "matchCriteriaId": "932D137F-528B-4526-9A89-CD59FA1AB0FE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4CFF558-3C47-480D-A2F0-BABF26042943"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.6:*:*:*:*:*:*:*", "matchCriteriaId": "3538B4DC-0F7D-4574-8F31-07D52AC854A0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:8.4:*:*:*:*:*:*:*", "matchCriteriaId": "0E3F09B5-569F-4C58-9FCA-3C0953D107B5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:8.6:*:*:*:*:*:*:*", "matchCriteriaId": "6C3741B8-851F-475D-B428-523F4F722350"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_for_ibm_z_systems:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "87C21FE1-EA5C-498F-9C6C-D05F91A88217"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_for_ibm_z_systems:8.6:*:*:*:*:*:*:*", "matchCriteriaId": "4063768E-67FA-4940-8A0C-101C1EFD0D7E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_for_ibm_z_systems_eus:8.4:*:*:*:*:*:*:*", "matchCriteriaId": "8C9BD9AE-46FC-4609-8D99-A3CFE91D58D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_for_ibm_z_systems_eus:8.6:*:*:*:*:*:*:*", "matchCriteriaId": "9EF5C4AC-CA69-41E3-AD93-7AC21931374A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_for_power_little_endian:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "47811209-5CE5-4375-8391-B0A7F6A0E420"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_for_power_little_endian_eus:8.4:*:*:*:*:*:*:*", "matchCriteriaId": "983533DD-3970-4A37-9A9C-582BD48AA1E5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:8.4:*:*:*:*:*:*:*", "matchCriteriaId": "E28F226A-CBC7-4A32-BE58-398FA5B42481"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:8.6:*:*:*:*:*:*:*", "matchCriteriaId": "76C24D94-834A-4E9D-8F73-624AFA99AAA2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_for_power_little_endian_update_services_for_sap_solutions:8.4:*:*:*:*:*:*:*", "matchCriteriaId": "22D095ED-9247-4133-A133-73B7668565E4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_for_power_little_endian_update_services_for_sap_solutions:8.6:*:*:*:*:*:*:*", "matchCriteriaId": "871A5C26-DB7B-4870-A5B2-5DD24C90B4A7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:8.4:*:*:*:*:*:*:*", "matchCriteriaId": "AC10D919-57FD-4725-B8D2-39ECB476902F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:8.6:*:*:*:*:*:*:*", "matchCriteriaId": "1272DF03-7674-4BD4-8E64-94004B195448"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_update_services_for_sap_solutions:8.4:*:*:*:*:*:*:*", "matchCriteriaId": "BC6DD887-9744-43EA-8B3C-44C6B6339590"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_update_services_for_sap_solutions:8.6:*:*:*:*:*:*:*", "matchCriteriaId": "7614E5D3-4643-4CAE-9578-9BB9D558211F"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2066568", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/containers/podman/commit/aafa80918a245edcbdaceb1191d749570f1872d0", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/containers/podman/security/advisories/GHSA-qvf8-p83w-v58j", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/4KDETHL5XCT6RZN2BBNOCEXRZ2W3SFU3/", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/DLUJZV3HBP56ADXU6QH2V7RNYUPMVBXQ/", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/J5WPM42UR6XIBQNQPNQHM32X7S4LJTRX/", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/containers/podman/commit/aafa80918a245edcbdaceb1191d749570f1872d0"}}