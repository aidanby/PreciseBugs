{"buggy_code": ["/* Redis CLI (command line interface)\n *\n * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"fmacros.h\"\n#include \"version.h\"\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <assert.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <math.h>\n\n#include <hiredis.h>\n#include <sds.h> /* use sds.h from hiredis, so that only one set of sds functions will be present in the binary */\n#include \"zmalloc.h\"\n#include \"linenoise.h\"\n#include \"help.h\"\n#include \"anet.h\"\n#include \"ae.h\"\n\n#define UNUSED(V) ((void) V)\n\n#define OUTPUT_STANDARD 0\n#define OUTPUT_RAW 1\n#define OUTPUT_CSV 2\n#define REDIS_CLI_KEEPALIVE_INTERVAL 15 /* seconds */\n#define REDIS_CLI_DEFAULT_PIPE_TIMEOUT 30 /* seconds */\n#define REDIS_CLI_HISTFILE_ENV \"REDISCLI_HISTFILE\"\n#define REDIS_CLI_HISTFILE_DEFAULT \".rediscli_history\"\n#define REDIS_CLI_RCFILE_ENV \"REDISCLI_RCFILE\"\n#define REDIS_CLI_RCFILE_DEFAULT \".redisclirc\"\n\n/* --latency-dist palettes. */\nint spectrum_palette_color_size = 19;\nint spectrum_palette_color[] = {0,233,234,235,237,239,241,243,245,247,144,143,142,184,226,214,208,202,196};\n\nint spectrum_palette_mono_size = 13;\nint spectrum_palette_mono[] = {0,233,234,235,237,239,241,243,245,247,249,251,253};\n\n/* The actual palette in use. */\nint *spectrum_palette;\nint spectrum_palette_size;\n\nstatic redisContext *context;\nstatic struct config {\n    char *hostip;\n    int hostport;\n    char *hostsocket;\n    long repeat;\n    long interval;\n    int dbnum;\n    int interactive;\n    int shutdown;\n    int monitor_mode;\n    int pubsub_mode;\n    int latency_mode;\n    int latency_dist_mode;\n    int latency_history;\n    int lru_test_mode;\n    long long lru_test_sample_size;\n    int cluster_mode;\n    int cluster_reissue_command;\n    int slave_mode;\n    int pipe_mode;\n    int pipe_timeout;\n    int getrdb_mode;\n    int stat_mode;\n    int scan_mode;\n    int intrinsic_latency_mode;\n    int intrinsic_latency_duration;\n    char *pattern;\n    char *rdb_filename;\n    int bigkeys;\n    int hotkeys;\n    int stdinarg; /* get last arg from stdin. (-x option) */\n    char *auth;\n    int output; /* output mode, see OUTPUT_* defines */\n    sds mb_delim;\n    char prompt[128];\n    char *eval;\n    int eval_ldb;\n    int eval_ldb_sync;  /* Ask for synchronous mode of the Lua debugger. */\n    int eval_ldb_end;   /* Lua debugging session ended. */\n    int enable_ldb_on_eval; /* Handle manual SCRIPT DEBUG + EVAL commands. */\n    int last_cmd_type;\n} config;\n\n/* User preferences. */\nstatic struct pref {\n    int hints;\n} pref;\n\nstatic volatile sig_atomic_t force_cancel_loop = 0;\nstatic void usage(void);\nstatic void slaveMode(void);\nchar *redisGitSHA1(void);\nchar *redisGitDirty(void);\nstatic int cliConnect(int force);\n\n/*------------------------------------------------------------------------------\n * Utility functions\n *--------------------------------------------------------------------------- */\n\nstatic long long ustime(void) {\n    struct timeval tv;\n    long long ust;\n\n    gettimeofday(&tv, NULL);\n    ust = ((long long)tv.tv_sec)*1000000;\n    ust += tv.tv_usec;\n    return ust;\n}\n\nstatic long long mstime(void) {\n    return ustime()/1000;\n}\n\nstatic void cliRefreshPrompt(void) {\n    int len;\n\n    if (config.eval_ldb) return;\n    if (config.hostsocket != NULL)\n        len = snprintf(config.prompt,sizeof(config.prompt),\"redis %s\",\n                       config.hostsocket);\n    else\n        len = anetFormatAddr(config.prompt, sizeof(config.prompt),\n                           config.hostip, config.hostport);\n    /* Add [dbnum] if needed */\n    if (config.dbnum != 0)\n        len += snprintf(config.prompt+len,sizeof(config.prompt)-len,\"[%d]\",\n            config.dbnum);\n    snprintf(config.prompt+len,sizeof(config.prompt)-len,\"> \");\n}\n\n/* Return the name of the dotfile for the specified 'dotfilename'.\n * Normally it just concatenates user $HOME to the file specified\n * in 'dotfilename'. However if the environment varialbe 'envoverride'\n * is set, its value is taken as the path.\n *\n * The function returns NULL (if the file is /dev/null or cannot be\n * obtained for some error), or an SDS string that must be freed by\n * the user. */\nstatic sds getDotfilePath(char *envoverride, char *dotfilename) {\n    char *path = NULL;\n    sds dotPath = NULL;\n\n    /* Check the env for a dotfile override. */\n    path = getenv(envoverride);\n    if (path != NULL && *path != '\\0') {\n        if (!strcmp(\"/dev/null\", path)) {\n            return NULL;\n        }\n\n        /* If the env is set, return it. */\n        dotPath = sdsnew(path);\n    } else {\n        char *home = getenv(\"HOME\");\n        if (home != NULL && *home != '\\0') {\n            /* If no override is set use $HOME/<dotfilename>. */\n            dotPath = sdscatprintf(sdsempty(), \"%s/%s\", home, dotfilename);\n        }\n    }\n    return dotPath;\n}\n\n/* URL-style percent decoding. */\n#define isHexChar(c) (isdigit(c) || (c >= 'a' && c <= 'f'))\n#define decodeHexChar(c) (isdigit(c) ? c - '0' : c - 'a' + 10)\n#define decodeHex(h, l) ((decodeHexChar(h) << 4) + decodeHexChar(l))\n\nstatic sds percentDecode(const char *pe, size_t len) {\n    const char *end = pe + len;\n    sds ret = sdsempty();\n    const char *curr = pe;\n\n    while (curr < end) {\n        if (*curr == '%') {\n            if ((end - curr) < 2) {\n                fprintf(stderr, \"Incomplete URI encoding\\n\");\n                exit(1);\n            }\n\n            char h = tolower(*(++curr));\n            char l = tolower(*(++curr));\n            if (!isHexChar(h) || !isHexChar(l)) {\n                fprintf(stderr, \"Illegal character in URI encoding\\n\");\n                exit(1);\n            }\n            char c = decodeHex(h, l);\n            ret = sdscatlen(ret, &c, 1);\n            curr++;\n        } else {\n            ret = sdscatlen(ret, curr++, 1);\n        }\n    }\n\n    return ret;\n}\n\n/* Parse a URI and extract the server connection information.\n * URI scheme is based on the the provisional specification[1] excluding support\n * for query parameters. Valid URIs are:\n *   scheme:    \"redis://\"\n *   authority: [<username> \":\"] <password> \"@\"] [<hostname> [\":\" <port>]]\n *   path:      [\"/\" [<db>]]\n *\n *  [1]: https://www.iana.org/assignments/uri-schemes/prov/redis */\nstatic void parseRedisUri(const char *uri) {\n\n    const char *scheme = \"redis://\";\n    const char *curr = uri;\n    const char *end = uri + strlen(uri);\n    const char *userinfo, *username, *port, *host, *path;\n\n    /* URI must start with a valid scheme. */\n    if (strncasecmp(scheme, curr, strlen(scheme))) {\n        fprintf(stderr,\"Invalid URI scheme\\n\");\n        exit(1);\n    }\n    curr += strlen(scheme);\n    if (curr == end) return;\n\n    /* Extract user info. */\n    if ((userinfo = strchr(curr,'@'))) {\n        if ((username = strchr(curr, ':')) && username < userinfo) {\n            /* If provided, username is ignored. */\n            curr = username + 1;\n        }\n\n        config.auth = percentDecode(curr, userinfo - curr);\n        curr = userinfo + 1;\n    }\n    if (curr == end) return;\n\n    /* Extract host and port. */\n    path = strchr(curr, '/');\n    if (*curr != '/') {\n        host = path ? path - 1 : end;\n        if ((port = strchr(curr, ':'))) {\n            config.hostport = atoi(port + 1);\n            host = port - 1;\n        }\n        config.hostip = sdsnewlen(curr, host - curr + 1);\n    }\n    curr = path ? path + 1 : end;\n    if (curr == end) return;\n\n    /* Extract database number. */\n    config.dbnum = atoi(curr);\n}\n\n/*------------------------------------------------------------------------------\n * Help functions\n *--------------------------------------------------------------------------- */\n\n#define CLI_HELP_COMMAND 1\n#define CLI_HELP_GROUP 2\n\ntypedef struct {\n    int type;\n    int argc;\n    sds *argv;\n    sds full;\n\n    /* Only used for help on commands */\n    struct commandHelp *org;\n} helpEntry;\n\nstatic helpEntry *helpEntries;\nstatic int helpEntriesLen;\n\nstatic sds cliVersion(void) {\n    sds version;\n    version = sdscatprintf(sdsempty(), \"%s\", REDIS_VERSION);\n\n    /* Add git commit and working tree status when available */\n    if (strtoll(redisGitSHA1(),NULL,16)) {\n        version = sdscatprintf(version, \" (git:%s\", redisGitSHA1());\n        if (strtoll(redisGitDirty(),NULL,10))\n            version = sdscatprintf(version, \"-dirty\");\n        version = sdscat(version, \")\");\n    }\n    return version;\n}\n\nstatic void cliInitHelp(void) {\n    int commandslen = sizeof(commandHelp)/sizeof(struct commandHelp);\n    int groupslen = sizeof(commandGroups)/sizeof(char*);\n    int i, len, pos = 0;\n    helpEntry tmp;\n\n    helpEntriesLen = len = commandslen+groupslen;\n    helpEntries = zmalloc(sizeof(helpEntry)*len);\n\n    for (i = 0; i < groupslen; i++) {\n        tmp.argc = 1;\n        tmp.argv = zmalloc(sizeof(sds));\n        tmp.argv[0] = sdscatprintf(sdsempty(),\"@%s\",commandGroups[i]);\n        tmp.full = tmp.argv[0];\n        tmp.type = CLI_HELP_GROUP;\n        tmp.org = NULL;\n        helpEntries[pos++] = tmp;\n    }\n\n    for (i = 0; i < commandslen; i++) {\n        tmp.argv = sdssplitargs(commandHelp[i].name,&tmp.argc);\n        tmp.full = sdsnew(commandHelp[i].name);\n        tmp.type = CLI_HELP_COMMAND;\n        tmp.org = &commandHelp[i];\n        helpEntries[pos++] = tmp;\n    }\n}\n\n/* cliInitHelp() setups the helpEntries array with the command and group\n * names from the help.h file. However the Redis instance we are connecting\n * to may support more commands, so this function integrates the previous\n * entries with additional entries obtained using the COMMAND command\n * available in recent versions of Redis. */\nstatic void cliIntegrateHelp(void) {\n    if (cliConnect(0) == REDIS_ERR) return;\n\n    redisReply *reply = redisCommand(context, \"COMMAND\");\n    if(reply == NULL || reply->type != REDIS_REPLY_ARRAY) return;\n\n    /* Scan the array reported by COMMAND and fill only the entries that\n     * don't already match what we have. */\n    for (size_t j = 0; j < reply->elements; j++) {\n        redisReply *entry = reply->element[j];\n        if (entry->type != REDIS_REPLY_ARRAY || entry->elements < 4 ||\n            entry->element[0]->type != REDIS_REPLY_STRING ||\n            entry->element[1]->type != REDIS_REPLY_INTEGER ||\n            entry->element[3]->type != REDIS_REPLY_INTEGER) return;\n        char *cmdname = entry->element[0]->str;\n        int i;\n\n        for (i = 0; i < helpEntriesLen; i++) {\n            helpEntry *he = helpEntries+i;\n            if (!strcasecmp(he->argv[0],cmdname))\n                break;\n        }\n        if (i != helpEntriesLen) continue;\n\n        helpEntriesLen++;\n        helpEntries = zrealloc(helpEntries,sizeof(helpEntry)*helpEntriesLen);\n        helpEntry *new = helpEntries+(helpEntriesLen-1);\n\n        new->argc = 1;\n        new->argv = zmalloc(sizeof(sds));\n        new->argv[0] = sdsnew(cmdname);\n        new->full = new->argv[0];\n        new->type = CLI_HELP_COMMAND;\n        sdstoupper(new->argv[0]);\n\n        struct commandHelp *ch = zmalloc(sizeof(*ch));\n        ch->name = new->argv[0];\n        ch->params = sdsempty();\n        int args = llabs(entry->element[1]->integer);\n        if (entry->element[3]->integer == 1) {\n            ch->params = sdscat(ch->params,\"key \");\n            args--;\n        }\n        while(args--) ch->params = sdscat(ch->params,\"arg \");\n        if (entry->element[1]->integer < 0)\n            ch->params = sdscat(ch->params,\"...options...\");\n        ch->summary = \"Help not available\";\n        ch->group = 0;\n        ch->since = \"not known\";\n        new->org = ch;\n    }\n    freeReplyObject(reply);\n}\n\n/* Output command help to stdout. */\nstatic void cliOutputCommandHelp(struct commandHelp *help, int group) {\n    printf(\"\\r\\n  \\x1b[1m%s\\x1b[0m \\x1b[90m%s\\x1b[0m\\r\\n\", help->name, help->params);\n    printf(\"  \\x1b[33msummary:\\x1b[0m %s\\r\\n\", help->summary);\n    printf(\"  \\x1b[33msince:\\x1b[0m %s\\r\\n\", help->since);\n    if (group) {\n        printf(\"  \\x1b[33mgroup:\\x1b[0m %s\\r\\n\", commandGroups[help->group]);\n    }\n}\n\n/* Print generic help. */\nstatic void cliOutputGenericHelp(void) {\n    sds version = cliVersion();\n    printf(\n        \"redis-cli %s\\n\"\n        \"To get help about Redis commands type:\\n\"\n        \"      \\\"help @<group>\\\" to get a list of commands in <group>\\n\"\n        \"      \\\"help <command>\\\" for help on <command>\\n\"\n        \"      \\\"help <tab>\\\" to get a list of possible help topics\\n\"\n        \"      \\\"quit\\\" to exit\\n\"\n        \"\\n\"\n        \"To set redis-cli preferences:\\n\"\n        \"      \\\":set hints\\\" enable online hints\\n\"\n        \"      \\\":set nohints\\\" disable online hints\\n\"\n        \"Set your preferences in ~/.redisclirc\\n\",\n        version\n    );\n    sdsfree(version);\n}\n\n/* Output all command help, filtering by group or command name. */\nstatic void cliOutputHelp(int argc, char **argv) {\n    int i, j, len;\n    int group = -1;\n    helpEntry *entry;\n    struct commandHelp *help;\n\n    if (argc == 0) {\n        cliOutputGenericHelp();\n        return;\n    } else if (argc > 0 && argv[0][0] == '@') {\n        len = sizeof(commandGroups)/sizeof(char*);\n        for (i = 0; i < len; i++) {\n            if (strcasecmp(argv[0]+1,commandGroups[i]) == 0) {\n                group = i;\n                break;\n            }\n        }\n    }\n\n    assert(argc > 0);\n    for (i = 0; i < helpEntriesLen; i++) {\n        entry = &helpEntries[i];\n        if (entry->type != CLI_HELP_COMMAND) continue;\n\n        help = entry->org;\n        if (group == -1) {\n            /* Compare all arguments */\n            if (argc == entry->argc) {\n                for (j = 0; j < argc; j++) {\n                    if (strcasecmp(argv[j],entry->argv[j]) != 0) break;\n                }\n                if (j == argc) {\n                    cliOutputCommandHelp(help,1);\n                }\n            }\n        } else {\n            if (group == help->group) {\n                cliOutputCommandHelp(help,0);\n            }\n        }\n    }\n    printf(\"\\r\\n\");\n}\n\n/* Linenoise completion callback. */\nstatic void completionCallback(const char *buf, linenoiseCompletions *lc) {\n    size_t startpos = 0;\n    int mask;\n    int i;\n    size_t matchlen;\n    sds tmp;\n\n    if (strncasecmp(buf,\"help \",5) == 0) {\n        startpos = 5;\n        while (isspace(buf[startpos])) startpos++;\n        mask = CLI_HELP_COMMAND | CLI_HELP_GROUP;\n    } else {\n        mask = CLI_HELP_COMMAND;\n    }\n\n    for (i = 0; i < helpEntriesLen; i++) {\n        if (!(helpEntries[i].type & mask)) continue;\n\n        matchlen = strlen(buf+startpos);\n        if (strncasecmp(buf+startpos,helpEntries[i].full,matchlen) == 0) {\n            tmp = sdsnewlen(buf,startpos);\n            tmp = sdscat(tmp,helpEntries[i].full);\n            linenoiseAddCompletion(lc,tmp);\n            sdsfree(tmp);\n        }\n    }\n}\n\n/* Linenoise hints callback. */\nstatic char *hintsCallback(const char *buf, int *color, int *bold) {\n    if (!pref.hints) return NULL;\n\n    int i, argc, buflen = strlen(buf);\n    sds *argv = sdssplitargs(buf,&argc);\n    int endspace = buflen && isspace(buf[buflen-1]);\n\n    /* Check if the argument list is empty and return ASAP. */\n    if (argc == 0) {\n        sdsfreesplitres(argv,argc);\n        return NULL;\n    }\n\n    for (i = 0; i < helpEntriesLen; i++) {\n        if (!(helpEntries[i].type & CLI_HELP_COMMAND)) continue;\n\n        if (strcasecmp(argv[0],helpEntries[i].full) == 0)\n        {\n            *color = 90;\n            *bold = 0;\n            sds hint = sdsnew(helpEntries[i].org->params);\n\n            /* Remove arguments from the returned hint to show only the\n             * ones the user did not yet typed. */\n            int toremove = argc-1;\n            while(toremove > 0 && sdslen(hint)) {\n                if (hint[0] == '[') break;\n                if (hint[0] == ' ') toremove--;\n                sdsrange(hint,1,-1);\n            }\n\n            /* Add an initial space if needed. */\n            if (!endspace) {\n                sds newhint = sdsnewlen(\" \",1);\n                newhint = sdscatsds(newhint,hint);\n                sdsfree(hint);\n                hint = newhint;\n            }\n\n            sdsfreesplitres(argv,argc);\n            return hint;\n        }\n    }\n    sdsfreesplitres(argv,argc);\n    return NULL;\n}\n\nstatic void freeHintsCallback(void *ptr) {\n    sdsfree(ptr);\n}\n\n/*------------------------------------------------------------------------------\n * Networking / parsing\n *--------------------------------------------------------------------------- */\n\n/* Send AUTH command to the server */\nstatic int cliAuth(void) {\n    redisReply *reply;\n    if (config.auth == NULL) return REDIS_OK;\n\n    reply = redisCommand(context,\"AUTH %s\",config.auth);\n    if (reply != NULL) {\n        freeReplyObject(reply);\n        return REDIS_OK;\n    }\n    return REDIS_ERR;\n}\n\n/* Send SELECT dbnum to the server */\nstatic int cliSelect(void) {\n    redisReply *reply;\n    if (config.dbnum == 0) return REDIS_OK;\n\n    reply = redisCommand(context,\"SELECT %d\",config.dbnum);\n    if (reply != NULL) {\n        int result = REDIS_OK;\n        if (reply->type == REDIS_REPLY_ERROR) result = REDIS_ERR;\n        freeReplyObject(reply);\n        return result;\n    }\n    return REDIS_ERR;\n}\n\n/* Connect to the server. If force is not zero the connection is performed\n * even if there is already a connected socket. */\nstatic int cliConnect(int force) {\n    if (context == NULL || force) {\n        if (context != NULL) {\n            redisFree(context);\n        }\n\n        if (config.hostsocket == NULL) {\n            context = redisConnect(config.hostip,config.hostport);\n        } else {\n            context = redisConnectUnix(config.hostsocket);\n        }\n\n        if (context->err) {\n            fprintf(stderr,\"Could not connect to Redis at \");\n            if (config.hostsocket == NULL)\n                fprintf(stderr,\"%s:%d: %s\\n\",config.hostip,config.hostport,context->errstr);\n            else\n                fprintf(stderr,\"%s: %s\\n\",config.hostsocket,context->errstr);\n            redisFree(context);\n            context = NULL;\n            return REDIS_ERR;\n        }\n\n        /* Set aggressive KEEP_ALIVE socket option in the Redis context socket\n         * in order to prevent timeouts caused by the execution of long\n         * commands. At the same time this improves the detection of real\n         * errors. */\n        anetKeepAlive(NULL, context->fd, REDIS_CLI_KEEPALIVE_INTERVAL);\n\n        /* Do AUTH and select the right DB. */\n        if (cliAuth() != REDIS_OK)\n            return REDIS_ERR;\n        if (cliSelect() != REDIS_OK)\n            return REDIS_ERR;\n    }\n    return REDIS_OK;\n}\n\nstatic void cliPrintContextError(void) {\n    if (context == NULL) return;\n    fprintf(stderr,\"Error: %s\\n\",context->errstr);\n}\n\nstatic sds cliFormatReplyTTY(redisReply *r, char *prefix) {\n    sds out = sdsempty();\n    switch (r->type) {\n    case REDIS_REPLY_ERROR:\n        out = sdscatprintf(out,\"(error) %s\\n\", r->str);\n    break;\n    case REDIS_REPLY_STATUS:\n        out = sdscat(out,r->str);\n        out = sdscat(out,\"\\n\");\n    break;\n    case REDIS_REPLY_INTEGER:\n        out = sdscatprintf(out,\"(integer) %lld\\n\",r->integer);\n    break;\n    case REDIS_REPLY_STRING:\n        /* If you are producing output for the standard output we want\n        * a more interesting output with quoted characters and so forth */\n        out = sdscatrepr(out,r->str,r->len);\n        out = sdscat(out,\"\\n\");\n    break;\n    case REDIS_REPLY_NIL:\n        out = sdscat(out,\"(nil)\\n\");\n    break;\n    case REDIS_REPLY_ARRAY:\n        if (r->elements == 0) {\n            out = sdscat(out,\"(empty list or set)\\n\");\n        } else {\n            unsigned int i, idxlen = 0;\n            char _prefixlen[16];\n            char _prefixfmt[16];\n            sds _prefix;\n            sds tmp;\n\n            /* Calculate chars needed to represent the largest index */\n            i = r->elements;\n            do {\n                idxlen++;\n                i /= 10;\n            } while(i);\n\n            /* Prefix for nested multi bulks should grow with idxlen+2 spaces */\n            memset(_prefixlen,' ',idxlen+2);\n            _prefixlen[idxlen+2] = '\\0';\n            _prefix = sdscat(sdsnew(prefix),_prefixlen);\n\n            /* Setup prefix format for every entry */\n            snprintf(_prefixfmt,sizeof(_prefixfmt),\"%%s%%%ud) \",idxlen);\n\n            for (i = 0; i < r->elements; i++) {\n                /* Don't use the prefix for the first element, as the parent\n                 * caller already prepended the index number. */\n                out = sdscatprintf(out,_prefixfmt,i == 0 ? \"\" : prefix,i+1);\n\n                /* Format the multi bulk entry */\n                tmp = cliFormatReplyTTY(r->element[i],_prefix);\n                out = sdscatlen(out,tmp,sdslen(tmp));\n                sdsfree(tmp);\n            }\n            sdsfree(_prefix);\n        }\n    break;\n    default:\n        fprintf(stderr,\"Unknown reply type: %d\\n\", r->type);\n        exit(1);\n    }\n    return out;\n}\n\nint isColorTerm(void) {\n    char *t = getenv(\"TERM\");\n    return t != NULL && strstr(t,\"xterm\") != NULL;\n}\n\n/* Helper  function for sdsCatColorizedLdbReply() appending colorize strings\n * to an SDS string. */\nsds sdscatcolor(sds o, char *s, size_t len, char *color) {\n    if (!isColorTerm()) return sdscatlen(o,s,len);\n\n    int bold = strstr(color,\"bold\") != NULL;\n    int ccode = 37; /* Defaults to white. */\n    if (strstr(color,\"red\")) ccode = 31;\n    else if (strstr(color,\"green\")) ccode = 32;\n    else if (strstr(color,\"yellow\")) ccode = 33;\n    else if (strstr(color,\"blue\")) ccode = 34;\n    else if (strstr(color,\"magenta\")) ccode = 35;\n    else if (strstr(color,\"cyan\")) ccode = 36;\n    else if (strstr(color,\"white\")) ccode = 37;\n\n    o = sdscatfmt(o,\"\\033[%i;%i;49m\",bold,ccode);\n    o = sdscatlen(o,s,len);\n    o = sdscat(o,\"\\033[0m\");\n    return o;\n}\n\n/* Colorize Lua debugger status replies according to the prefix they\n * have. */\nsds sdsCatColorizedLdbReply(sds o, char *s, size_t len) {\n    char *color = \"white\";\n\n    if (strstr(s,\"<debug>\")) color = \"bold\";\n    if (strstr(s,\"<redis>\")) color = \"green\";\n    if (strstr(s,\"<reply>\")) color = \"cyan\";\n    if (strstr(s,\"<error>\")) color = \"red\";\n    if (strstr(s,\"<hint>\")) color = \"bold\";\n    if (strstr(s,\"<value>\") || strstr(s,\"<retval>\")) color = \"magenta\";\n    if (len > 4 && isdigit(s[3])) {\n        if (s[1] == '>') color = \"yellow\"; /* Current line. */\n        else if (s[2] == '#') color = \"bold\"; /* Break point. */\n    }\n    return sdscatcolor(o,s,len,color);\n}\n\nstatic sds cliFormatReplyRaw(redisReply *r) {\n    sds out = sdsempty(), tmp;\n    size_t i;\n\n    switch (r->type) {\n    case REDIS_REPLY_NIL:\n        /* Nothing... */\n        break;\n    case REDIS_REPLY_ERROR:\n        out = sdscatlen(out,r->str,r->len);\n        out = sdscatlen(out,\"\\n\",1);\n        break;\n    case REDIS_REPLY_STATUS:\n    case REDIS_REPLY_STRING:\n        if (r->type == REDIS_REPLY_STATUS && config.eval_ldb) {\n            /* The Lua debugger replies with arrays of simple (status)\n             * strings. We colorize the output for more fun if this\n             * is a debugging session. */\n\n            /* Detect the end of a debugging session. */\n            if (strstr(r->str,\"<endsession>\") == r->str) {\n                config.enable_ldb_on_eval = 0;\n                config.eval_ldb = 0;\n                config.eval_ldb_end = 1; /* Signal the caller session ended. */\n                config.output = OUTPUT_STANDARD;\n                cliRefreshPrompt();\n            } else {\n                out = sdsCatColorizedLdbReply(out,r->str,r->len);\n            }\n        } else {\n            out = sdscatlen(out,r->str,r->len);\n        }\n        break;\n    case REDIS_REPLY_INTEGER:\n        out = sdscatprintf(out,\"%lld\",r->integer);\n        break;\n    case REDIS_REPLY_ARRAY:\n        for (i = 0; i < r->elements; i++) {\n            if (i > 0) out = sdscat(out,config.mb_delim);\n            tmp = cliFormatReplyRaw(r->element[i]);\n            out = sdscatlen(out,tmp,sdslen(tmp));\n            sdsfree(tmp);\n        }\n        break;\n    default:\n        fprintf(stderr,\"Unknown reply type: %d\\n\", r->type);\n        exit(1);\n    }\n    return out;\n}\n\nstatic sds cliFormatReplyCSV(redisReply *r) {\n    unsigned int i;\n\n    sds out = sdsempty();\n    switch (r->type) {\n    case REDIS_REPLY_ERROR:\n        out = sdscat(out,\"ERROR,\");\n        out = sdscatrepr(out,r->str,strlen(r->str));\n    break;\n    case REDIS_REPLY_STATUS:\n        out = sdscatrepr(out,r->str,r->len);\n    break;\n    case REDIS_REPLY_INTEGER:\n        out = sdscatprintf(out,\"%lld\",r->integer);\n    break;\n    case REDIS_REPLY_STRING:\n        out = sdscatrepr(out,r->str,r->len);\n    break;\n    case REDIS_REPLY_NIL:\n        out = sdscat(out,\"NIL\");\n    break;\n    case REDIS_REPLY_ARRAY:\n        for (i = 0; i < r->elements; i++) {\n            sds tmp = cliFormatReplyCSV(r->element[i]);\n            out = sdscatlen(out,tmp,sdslen(tmp));\n            if (i != r->elements-1) out = sdscat(out,\",\");\n            sdsfree(tmp);\n        }\n    break;\n    default:\n        fprintf(stderr,\"Unknown reply type: %d\\n\", r->type);\n        exit(1);\n    }\n    return out;\n}\n\nstatic int cliReadReply(int output_raw_strings) {\n    void *_reply;\n    redisReply *reply;\n    sds out = NULL;\n    int output = 1;\n\n    if (redisGetReply(context,&_reply) != REDIS_OK) {\n        if (config.shutdown) {\n            redisFree(context);\n            context = NULL;\n            return REDIS_OK;\n        }\n        if (config.interactive) {\n            /* Filter cases where we should reconnect */\n            if (context->err == REDIS_ERR_IO &&\n                (errno == ECONNRESET || errno == EPIPE))\n                return REDIS_ERR;\n            if (context->err == REDIS_ERR_EOF)\n                return REDIS_ERR;\n        }\n        cliPrintContextError();\n        exit(1);\n        return REDIS_ERR; /* avoid compiler warning */\n    }\n\n    reply = (redisReply*)_reply;\n\n    config.last_cmd_type = reply->type;\n\n    /* Check if we need to connect to a different node and reissue the\n     * request. */\n    if (config.cluster_mode && reply->type == REDIS_REPLY_ERROR &&\n        (!strncmp(reply->str,\"MOVED\",5) || !strcmp(reply->str,\"ASK\")))\n    {\n        char *p = reply->str, *s;\n        int slot;\n\n        output = 0;\n        /* Comments show the position of the pointer as:\n         *\n         * [S] for pointer 's'\n         * [P] for pointer 'p'\n         */\n        s = strchr(p,' ');      /* MOVED[S]3999 127.0.0.1:6381 */\n        p = strchr(s+1,' ');    /* MOVED[S]3999[P]127.0.0.1:6381 */\n        *p = '\\0';\n        slot = atoi(s+1);\n        s = strrchr(p+1,':');    /* MOVED 3999[P]127.0.0.1[S]6381 */\n        *s = '\\0';\n        sdsfree(config.hostip);\n        config.hostip = sdsnew(p+1);\n        config.hostport = atoi(s+1);\n        if (config.interactive)\n            printf(\"-> Redirected to slot [%d] located at %s:%d\\n\",\n                slot, config.hostip, config.hostport);\n        config.cluster_reissue_command = 1;\n        cliRefreshPrompt();\n    }\n\n    if (output) {\n        if (output_raw_strings) {\n            out = cliFormatReplyRaw(reply);\n        } else {\n            if (config.output == OUTPUT_RAW) {\n                out = cliFormatReplyRaw(reply);\n                out = sdscat(out,\"\\n\");\n            } else if (config.output == OUTPUT_STANDARD) {\n                out = cliFormatReplyTTY(reply,\"\");\n            } else if (config.output == OUTPUT_CSV) {\n                out = cliFormatReplyCSV(reply);\n                out = sdscat(out,\"\\n\");\n            }\n        }\n        fwrite(out,sdslen(out),1,stdout);\n        sdsfree(out);\n    }\n    freeReplyObject(reply);\n    return REDIS_OK;\n}\n\nstatic int cliSendCommand(int argc, char **argv, long repeat) {\n    char *command = argv[0];\n    size_t *argvlen;\n    int j, output_raw;\n\n    if (!config.eval_ldb && /* In debugging mode, let's pass \"help\" to Redis. */\n        (!strcasecmp(command,\"help\") || !strcasecmp(command,\"?\"))) {\n        cliOutputHelp(--argc, ++argv);\n        return REDIS_OK;\n    }\n\n    if (context == NULL) return REDIS_ERR;\n\n    output_raw = 0;\n    if (!strcasecmp(command,\"info\") ||\n        (argc >= 2 && !strcasecmp(command,\"debug\") &&\n                       !strcasecmp(argv[1],\"htstats\")) ||\n        (argc >= 2 && !strcasecmp(command,\"memory\") &&\n                      (!strcasecmp(argv[1],\"malloc-stats\") ||\n                       !strcasecmp(argv[1],\"doctor\"))) ||\n        (argc == 2 && !strcasecmp(command,\"cluster\") &&\n                      (!strcasecmp(argv[1],\"nodes\") ||\n                       !strcasecmp(argv[1],\"info\"))) ||\n        (argc == 2 && !strcasecmp(command,\"client\") &&\n                       !strcasecmp(argv[1],\"list\")) ||\n        (argc == 3 && !strcasecmp(command,\"latency\") &&\n                       !strcasecmp(argv[1],\"graph\")) ||\n        (argc == 2 && !strcasecmp(command,\"latency\") &&\n                       !strcasecmp(argv[1],\"doctor\")))\n    {\n        output_raw = 1;\n    }\n\n    if (!strcasecmp(command,\"shutdown\")) config.shutdown = 1;\n    if (!strcasecmp(command,\"monitor\")) config.monitor_mode = 1;\n    if (!strcasecmp(command,\"subscribe\") ||\n        !strcasecmp(command,\"psubscribe\")) config.pubsub_mode = 1;\n    if (!strcasecmp(command,\"sync\") ||\n        !strcasecmp(command,\"psync\")) config.slave_mode = 1;\n\n    /* When the user manually calls SCRIPT DEBUG, setup the activation of\n     * debugging mode on the next eval if needed. */\n    if (argc == 3 && !strcasecmp(argv[0],\"script\") &&\n                     !strcasecmp(argv[1],\"debug\"))\n    {\n        if (!strcasecmp(argv[2],\"yes\") || !strcasecmp(argv[2],\"sync\")) {\n            config.enable_ldb_on_eval = 1;\n        } else {\n            config.enable_ldb_on_eval = 0;\n        }\n    }\n\n    /* Actually activate LDB on EVAL if needed. */\n    if (!strcasecmp(command,\"eval\") && config.enable_ldb_on_eval) {\n        config.eval_ldb = 1;\n        config.output = OUTPUT_RAW;\n    }\n\n    /* Setup argument length */\n    argvlen = zmalloc(argc*sizeof(size_t));\n    for (j = 0; j < argc; j++)\n        argvlen[j] = sdslen(argv[j]);\n\n    while(repeat-- > 0) {\n        redisAppendCommandArgv(context,argc,(const char**)argv,argvlen);\n        while (config.monitor_mode) {\n            if (cliReadReply(output_raw) != REDIS_OK) exit(1);\n            fflush(stdout);\n        }\n\n        if (config.pubsub_mode) {\n            if (config.output != OUTPUT_RAW)\n                printf(\"Reading messages... (press Ctrl-C to quit)\\n\");\n            while (1) {\n                if (cliReadReply(output_raw) != REDIS_OK) exit(1);\n            }\n        }\n\n        if (config.slave_mode) {\n            printf(\"Entering slave output mode...  (press Ctrl-C to quit)\\n\");\n            slaveMode();\n            config.slave_mode = 0;\n            zfree(argvlen);\n            return REDIS_ERR;  /* Error = slaveMode lost connection to master */\n        }\n\n        if (cliReadReply(output_raw) != REDIS_OK) {\n            zfree(argvlen);\n            return REDIS_ERR;\n        } else {\n            /* Store database number when SELECT was successfully executed. */\n            if (!strcasecmp(command,\"select\") && argc == 2 && config.last_cmd_type != REDIS_REPLY_ERROR) {\n                config.dbnum = atoi(argv[1]);\n                cliRefreshPrompt();\n            } else if (!strcasecmp(command,\"auth\") && argc == 2) {\n                cliSelect();\n            }\n        }\n        if (config.interval) usleep(config.interval);\n        fflush(stdout); /* Make it grep friendly */\n    }\n\n    zfree(argvlen);\n    return REDIS_OK;\n}\n\n/* Send a command reconnecting the link if needed. */\nstatic redisReply *reconnectingRedisCommand(redisContext *c, const char *fmt, ...) {\n    redisReply *reply = NULL;\n    int tries = 0;\n    va_list ap;\n\n    assert(!c->err);\n    while(reply == NULL) {\n        while (c->err & (REDIS_ERR_IO | REDIS_ERR_EOF)) {\n            printf(\"\\r\\x1b[0K\"); /* Cursor to left edge + clear line. */\n            printf(\"Reconnecting... %d\\r\", ++tries);\n            fflush(stdout);\n\n            redisFree(c);\n            c = redisConnect(config.hostip,config.hostport);\n            usleep(1000000);\n        }\n\n        va_start(ap,fmt);\n        reply = redisvCommand(c,fmt,ap);\n        va_end(ap);\n\n        if (c->err && !(c->err & (REDIS_ERR_IO | REDIS_ERR_EOF))) {\n            fprintf(stderr, \"Error: %s\\n\", c->errstr);\n            exit(1);\n        } else if (tries > 0) {\n            printf(\"\\r\\x1b[0K\"); /* Cursor to left edge + clear line. */\n        }\n    }\n\n    context = c;\n    return reply;\n}\n\n/*------------------------------------------------------------------------------\n * User interface\n *--------------------------------------------------------------------------- */\n\nstatic int parseOptions(int argc, char **argv) {\n    int i;\n\n    for (i = 1; i < argc; i++) {\n        int lastarg = i==argc-1;\n\n        if (!strcmp(argv[i],\"-h\") && !lastarg) {\n            sdsfree(config.hostip);\n            config.hostip = sdsnew(argv[++i]);\n        } else if (!strcmp(argv[i],\"-h\") && lastarg) {\n            usage();\n        } else if (!strcmp(argv[i],\"--help\")) {\n            usage();\n        } else if (!strcmp(argv[i],\"-x\")) {\n            config.stdinarg = 1;\n        } else if (!strcmp(argv[i],\"-p\") && !lastarg) {\n            config.hostport = atoi(argv[++i]);\n        } else if (!strcmp(argv[i],\"-s\") && !lastarg) {\n            config.hostsocket = argv[++i];\n        } else if (!strcmp(argv[i],\"-r\") && !lastarg) {\n            config.repeat = strtoll(argv[++i],NULL,10);\n        } else if (!strcmp(argv[i],\"-i\") && !lastarg) {\n            double seconds = atof(argv[++i]);\n            config.interval = seconds*1000000;\n        } else if (!strcmp(argv[i],\"-n\") && !lastarg) {\n            config.dbnum = atoi(argv[++i]);\n        } else if (!strcmp(argv[i],\"-a\") && !lastarg) {\n            fputs(\"Warning: Using a password with '-a' option on the command line interface may not be safe.\\n\", stderr);\n            config.auth = argv[++i];\n        } else if (!strcmp(argv[i],\"-u\") && !lastarg) {\n            parseRedisUri(argv[++i]);\n        } else if (!strcmp(argv[i],\"--raw\")) {\n            config.output = OUTPUT_RAW;\n        } else if (!strcmp(argv[i],\"--no-raw\")) {\n            config.output = OUTPUT_STANDARD;\n        } else if (!strcmp(argv[i],\"--csv\")) {\n            config.output = OUTPUT_CSV;\n        } else if (!strcmp(argv[i],\"--latency\")) {\n            config.latency_mode = 1;\n        } else if (!strcmp(argv[i],\"--latency-dist\")) {\n            config.latency_dist_mode = 1;\n        } else if (!strcmp(argv[i],\"--mono\")) {\n            spectrum_palette = spectrum_palette_mono;\n            spectrum_palette_size = spectrum_palette_mono_size;\n        } else if (!strcmp(argv[i],\"--latency-history\")) {\n            config.latency_mode = 1;\n            config.latency_history = 1;\n        } else if (!strcmp(argv[i],\"--lru-test\") && !lastarg) {\n            config.lru_test_mode = 1;\n            config.lru_test_sample_size = strtoll(argv[++i],NULL,10);\n        } else if (!strcmp(argv[i],\"--slave\")) {\n            config.slave_mode = 1;\n        } else if (!strcmp(argv[i],\"--stat\")) {\n            config.stat_mode = 1;\n        } else if (!strcmp(argv[i],\"--scan\")) {\n            config.scan_mode = 1;\n        } else if (!strcmp(argv[i],\"--pattern\") && !lastarg) {\n            config.pattern = argv[++i];\n        } else if (!strcmp(argv[i],\"--intrinsic-latency\") && !lastarg) {\n            config.intrinsic_latency_mode = 1;\n            config.intrinsic_latency_duration = atoi(argv[++i]);\n        } else if (!strcmp(argv[i],\"--rdb\") && !lastarg) {\n            config.getrdb_mode = 1;\n            config.rdb_filename = argv[++i];\n        } else if (!strcmp(argv[i],\"--pipe\")) {\n            config.pipe_mode = 1;\n        } else if (!strcmp(argv[i],\"--pipe-timeout\") && !lastarg) {\n            config.pipe_timeout = atoi(argv[++i]);\n        } else if (!strcmp(argv[i],\"--bigkeys\")) {\n            config.bigkeys = 1;\n        } else if (!strcmp(argv[i],\"--hotkeys\")) {\n            config.hotkeys = 1;\n        } else if (!strcmp(argv[i],\"--eval\") && !lastarg) {\n            config.eval = argv[++i];\n        } else if (!strcmp(argv[i],\"--ldb\")) {\n            config.eval_ldb = 1;\n            config.output = OUTPUT_RAW;\n        } else if (!strcmp(argv[i],\"--ldb-sync-mode\")) {\n            config.eval_ldb = 1;\n            config.eval_ldb_sync = 1;\n            config.output = OUTPUT_RAW;\n        } else if (!strcmp(argv[i],\"-c\")) {\n            config.cluster_mode = 1;\n        } else if (!strcmp(argv[i],\"-d\") && !lastarg) {\n            sdsfree(config.mb_delim);\n            config.mb_delim = sdsnew(argv[++i]);\n        } else if (!strcmp(argv[i],\"-v\") || !strcmp(argv[i], \"--version\")) {\n            sds version = cliVersion();\n            printf(\"redis-cli %s\\n\", version);\n            sdsfree(version);\n            exit(0);\n        } else {\n            if (argv[i][0] == '-') {\n                fprintf(stderr,\n                    \"Unrecognized option or bad number of args for: '%s'\\n\",\n                    argv[i]);\n                exit(1);\n            } else {\n                /* Likely the command name, stop here. */\n                break;\n            }\n        }\n    }\n\n    /* --ldb requires --eval. */\n    if (config.eval_ldb && config.eval == NULL) {\n        fprintf(stderr,\"Options --ldb and --ldb-sync-mode require --eval.\\n\");\n        fprintf(stderr,\"Try %s --help for more information.\\n\", argv[0]);\n        exit(1);\n    }\n    return i;\n}\n\nstatic sds readArgFromStdin(void) {\n    char buf[1024];\n    sds arg = sdsempty();\n\n    while(1) {\n        int nread = read(fileno(stdin),buf,1024);\n\n        if (nread == 0) break;\n        else if (nread == -1) {\n            perror(\"Reading from standard input\");\n            exit(1);\n        }\n        arg = sdscatlen(arg,buf,nread);\n    }\n    return arg;\n}\n\nstatic void usage(void) {\n    sds version = cliVersion();\n    fprintf(stderr,\n\"redis-cli %s\\n\"\n\"\\n\"\n\"Usage: redis-cli [OPTIONS] [cmd [arg [arg ...]]]\\n\"\n\"  -h <hostname>      Server hostname (default: 127.0.0.1).\\n\"\n\"  -p <port>          Server port (default: 6379).\\n\"\n\"  -s <socket>        Server socket (overrides hostname and port).\\n\"\n\"  -a <password>      Password to use when connecting to the server.\\n\"\n\"  -u <uri>           Server URI.\\n\"\n\"  -r <repeat>        Execute specified command N times.\\n\"\n\"  -i <interval>      When -r is used, waits <interval> seconds per command.\\n\"\n\"                     It is possible to specify sub-second times like -i 0.1.\\n\"\n\"  -n <db>            Database number.\\n\"\n\"  -x                 Read last argument from STDIN.\\n\"\n\"  -d <delimiter>     Multi-bulk delimiter in for raw formatting (default: \\\\n).\\n\"\n\"  -c                 Enable cluster mode (follow -ASK and -MOVED redirections).\\n\"\n\"  --raw              Use raw formatting for replies (default when STDOUT is\\n\"\n\"                     not a tty).\\n\"\n\"  --no-raw           Force formatted output even when STDOUT is not a tty.\\n\"\n\"  --csv              Output in CSV format.\\n\"\n\"  --stat             Print rolling stats about server: mem, clients, ...\\n\"\n\"  --latency          Enter a special mode continuously sampling latency.\\n\"\n\"                     If you use this mode in an interactive session it runs\\n\"\n\"                     forever displaying real-time stats. Otherwise if --raw or\\n\"\n\"                     --csv is specified, or if you redirect the output to a non\\n\"\n\"                     TTY, it samples the latency for 1 second (you can use\\n\"\n\"                     -i to change the interval), then produces a single output\\n\"\n\"                     and exits.\\n\"\n\"  --latency-history  Like --latency but tracking latency changes over time.\\n\"\n\"                     Default time interval is 15 sec. Change it using -i.\\n\"\n\"  --latency-dist     Shows latency as a spectrum, requires xterm 256 colors.\\n\"\n\"                     Default time interval is 1 sec. Change it using -i.\\n\"\n\"  --lru-test <keys>  Simulate a cache workload with an 80-20 distribution.\\n\"\n\"  --slave            Simulate a slave showing commands received from the master.\\n\"\n\"  --rdb <filename>   Transfer an RDB dump from remote server to local file.\\n\"\n\"  --pipe             Transfer raw Redis protocol from stdin to server.\\n\"\n\"  --pipe-timeout <n> In --pipe mode, abort with error if after sending all data.\\n\"\n\"                     no reply is received within <n> seconds.\\n\"\n\"                     Default timeout: %d. Use 0 to wait forever.\\n\"\n\"  --bigkeys          Sample Redis keys looking for big keys.\\n\"\n\"  --hotkeys          Sample Redis keys looking for hot keys.\\n\"\n\"                     only works when maxmemory-policy is *lfu.\\n\"\n\"  --scan             List all keys using the SCAN command.\\n\"\n\"  --pattern <pat>    Useful with --scan to specify a SCAN pattern.\\n\"\n\"  --intrinsic-latency <sec> Run a test to measure intrinsic system latency.\\n\"\n\"                     The test will run for the specified amount of seconds.\\n\"\n\"  --eval <file>      Send an EVAL command using the Lua script at <file>.\\n\"\n\"  --ldb              Used with --eval enable the Redis Lua debugger.\\n\"\n\"  --ldb-sync-mode    Like --ldb but uses the synchronous Lua debugger, in\\n\"\n\"                     this mode the server is blocked and script changes are\\n\"\n\"                     are not rolled back from the server memory.\\n\"\n\"  --help             Output this help and exit.\\n\"\n\"  --version          Output version and exit.\\n\"\n\"\\n\"\n\"Examples:\\n\"\n\"  cat /etc/passwd | redis-cli -x set mypasswd\\n\"\n\"  redis-cli get mypasswd\\n\"\n\"  redis-cli -r 100 lpush mylist x\\n\"\n\"  redis-cli -r 100 -i 1 info | grep used_memory_human:\\n\"\n\"  redis-cli --eval myscript.lua key1 key2 , arg1 arg2 arg3\\n\"\n\"  redis-cli --scan --pattern '*:12345*'\\n\"\n\"\\n\"\n\"  (Note: when using --eval the comma separates KEYS[] from ARGV[] items)\\n\"\n\"\\n\"\n\"When no command is given, redis-cli starts in interactive mode.\\n\"\n\"Type \\\"help\\\" in interactive mode for information on available commands\\n\"\n\"and settings.\\n\"\n\"\\n\",\n        version, REDIS_CLI_DEFAULT_PIPE_TIMEOUT);\n    sdsfree(version);\n    exit(1);\n}\n\n/* Turn the plain C strings into Sds strings */\nstatic char **convertToSds(int count, char** args) {\n  int j;\n  char **sds = zmalloc(sizeof(char*)*count);\n\n  for(j = 0; j < count; j++)\n    sds[j] = sdsnew(args[j]);\n\n  return sds;\n}\n\nstatic int issueCommandRepeat(int argc, char **argv, long repeat) {\n    while (1) {\n        config.cluster_reissue_command = 0;\n        if (cliSendCommand(argc,argv,repeat) != REDIS_OK) {\n            cliConnect(1);\n\n            /* If we still cannot send the command print error.\n             * We'll try to reconnect the next time. */\n            if (cliSendCommand(argc,argv,repeat) != REDIS_OK) {\n                cliPrintContextError();\n                return REDIS_ERR;\n            }\n         }\n         /* Issue the command again if we got redirected in cluster mode */\n         if (config.cluster_mode && config.cluster_reissue_command) {\n            cliConnect(1);\n         } else {\n             break;\n        }\n    }\n    return REDIS_OK;\n}\n\nstatic int issueCommand(int argc, char **argv) {\n    return issueCommandRepeat(argc, argv, config.repeat);\n}\n\n/* Split the user provided command into multiple SDS arguments.\n * This function normally uses sdssplitargs() from sds.c which is able\n * to understand \"quoted strings\", escapes and so forth. However when\n * we are in Lua debugging mode and the \"eval\" command is used, we want\n * the remaining Lua script (after \"e \" or \"eval \") to be passed verbatim\n * as a single big argument. */\nstatic sds *cliSplitArgs(char *line, int *argc) {\n    if (config.eval_ldb && (strstr(line,\"eval \") == line ||\n                            strstr(line,\"e \") == line))\n    {\n        sds *argv = sds_malloc(sizeof(sds)*2);\n        *argc = 2;\n        int len = strlen(line);\n        int elen = line[1] == ' ' ? 2 : 5; /* \"e \" or \"eval \"? */\n        argv[0] = sdsnewlen(line,elen-1);\n        argv[1] = sdsnewlen(line+elen,len-elen);\n        return argv;\n    } else {\n        return sdssplitargs(line,argc);\n    }\n}\n\n/* Set the CLI preferences. This function is invoked when an interactive\n * \":command\" is called, or when reading ~/.redisclirc file, in order to\n * set user preferences. */\nvoid cliSetPreferences(char **argv, int argc, int interactive) {\n    if (!strcasecmp(argv[0],\":set\") && argc >= 2) {\n        if (!strcasecmp(argv[1],\"hints\")) pref.hints = 1;\n        else if (!strcasecmp(argv[1],\"nohints\")) pref.hints = 0;\n        else {\n            printf(\"%sunknown redis-cli preference '%s'\\n\",\n                interactive ? \"\" : \".redisclirc: \",\n                argv[1]);\n        }\n    } else {\n        printf(\"%sunknown redis-cli internal command '%s'\\n\",\n            interactive ? \"\" : \".redisclirc: \",\n            argv[0]);\n    }\n}\n\n/* Load the ~/.redisclirc file if any. */\nvoid cliLoadPreferences(void) {\n    sds rcfile = getDotfilePath(REDIS_CLI_RCFILE_ENV,REDIS_CLI_RCFILE_DEFAULT);\n    if (rcfile == NULL) return;\n    FILE *fp = fopen(rcfile,\"r\");\n    char buf[1024];\n\n    if (fp) {\n        while(fgets(buf,sizeof(buf),fp) != NULL) {\n            sds *argv;\n            int argc;\n\n            argv = sdssplitargs(buf,&argc);\n            if (argc > 0) cliSetPreferences(argv,argc,0);\n            sdsfreesplitres(argv,argc);\n        }\n        fclose(fp);\n    }\n    sdsfree(rcfile);\n}\n\nstatic void repl(void) {\n    sds historyfile = NULL;\n    int history = 0;\n    char *line;\n    int argc;\n    sds *argv;\n\n    /* Initialize the help and, if possible, use the COMMAND command in order\n     * to retrieve missing entries. */\n    cliInitHelp();\n    cliIntegrateHelp();\n\n    config.interactive = 1;\n    linenoiseSetMultiLine(1);\n    linenoiseSetCompletionCallback(completionCallback);\n    linenoiseSetHintsCallback(hintsCallback);\n    linenoiseSetFreeHintsCallback(freeHintsCallback);\n\n    /* Only use history and load the rc file when stdin is a tty. */\n    if (isatty(fileno(stdin))) {\n        historyfile = getDotfilePath(REDIS_CLI_HISTFILE_ENV,REDIS_CLI_HISTFILE_DEFAULT);\n        //keep in-memory history always regardless if history file can be determined\n        history = 1;\n        if (historyfile != NULL) {\n            linenoiseHistoryLoad(historyfile);\n        }\n        cliLoadPreferences();\n    }\n\n    cliRefreshPrompt();\n    while((line = linenoise(context ? config.prompt : \"not connected> \")) != NULL) {\n        if (line[0] != '\\0') {\n            long repeat = 1;\n            int skipargs = 0;\n            char *endptr = NULL;\n\n            argv = cliSplitArgs(line,&argc);\n\n            /* check if we have a repeat command option and\n             * need to skip the first arg */\n            if (argv && argc > 0) {\n                errno = 0;\n                repeat = strtol(argv[0], &endptr, 10);\n                if (argc > 1 && *endptr == '\\0') {\n                    if (errno == ERANGE || errno == EINVAL || repeat <= 0) {\n                        fputs(\"Invalid redis-cli repeat command option value.\\n\", stdout);\n                        sdsfreesplitres(argv, argc);\n                        linenoiseFree(line);\n                        continue;\n                    }\n                    skipargs = 1;\n                } else {\n                    repeat = 1;\n                }\n            }\n\n            /* Won't save auth command in history file */\n            if (!(argv && argc > 0 && !strcasecmp(argv[0+skipargs], \"auth\"))) {\n                if (history) linenoiseHistoryAdd(line);\n                if (historyfile) linenoiseHistorySave(historyfile);\n            }\n\n            if (argv == NULL) {\n                printf(\"Invalid argument(s)\\n\");\n                linenoiseFree(line);\n                continue;\n            } else if (argc > 0) {\n                if (strcasecmp(argv[0],\"quit\") == 0 ||\n                    strcasecmp(argv[0],\"exit\") == 0)\n                {\n                    exit(0);\n                } else if (argv[0][0] == ':') {\n                    cliSetPreferences(argv,argc,1);\n                    sdsfreesplitres(argv,argc);\n                    linenoiseFree(line);\n                    continue;\n                } else if (strcasecmp(argv[0],\"restart\") == 0) {\n                    if (config.eval) {\n                        config.eval_ldb = 1;\n                        config.output = OUTPUT_RAW;\n                        return; /* Return to evalMode to restart the session. */\n                    } else {\n                        printf(\"Use 'restart' only in Lua debugging mode.\");\n                    }\n                } else if (argc == 3 && !strcasecmp(argv[0],\"connect\")) {\n                    sdsfree(config.hostip);\n                    config.hostip = sdsnew(argv[1]);\n                    config.hostport = atoi(argv[2]);\n                    cliRefreshPrompt();\n                    cliConnect(1);\n                } else if (argc == 1 && !strcasecmp(argv[0],\"clear\")) {\n                    linenoiseClearScreen();\n                } else {\n                    long long start_time = mstime(), elapsed;\n\n                    issueCommandRepeat(argc-skipargs, argv+skipargs, repeat);\n\n                    /* If our debugging session ended, show the EVAL final\n                     * reply. */\n                    if (config.eval_ldb_end) {\n                        config.eval_ldb_end = 0;\n                        cliReadReply(0);\n                        printf(\"\\n(Lua debugging session ended%s)\\n\\n\",\n                            config.eval_ldb_sync ? \"\" :\n                            \" -- dataset changes rolled back\");\n                    }\n\n                    elapsed = mstime()-start_time;\n                    if (elapsed >= 500 &&\n                        config.output == OUTPUT_STANDARD)\n                    {\n                        printf(\"(%.2fs)\\n\",(double)elapsed/1000);\n                    }\n                }\n            }\n            /* Free the argument vector */\n            sdsfreesplitres(argv,argc);\n        }\n        /* linenoise() returns malloc-ed lines like readline() */\n        linenoiseFree(line);\n    }\n    exit(0);\n}\n\nstatic int noninteractive(int argc, char **argv) {\n    int retval = 0;\n    if (config.stdinarg) {\n        argv = zrealloc(argv, (argc+1)*sizeof(char*));\n        argv[argc] = readArgFromStdin();\n        retval = issueCommand(argc+1, argv);\n    } else {\n        retval = issueCommand(argc, argv);\n    }\n    return retval;\n}\n\n/*------------------------------------------------------------------------------\n * Eval mode\n *--------------------------------------------------------------------------- */\n\nstatic int evalMode(int argc, char **argv) {\n    sds script = NULL;\n    FILE *fp;\n    char buf[1024];\n    size_t nread;\n    char **argv2;\n    int j, got_comma, keys;\n    int retval = REDIS_OK;\n\n    while(1) {\n        if (config.eval_ldb) {\n            printf(\n            \"Lua debugging session started, please use:\\n\"\n            \"quit    -- End the session.\\n\"\n            \"restart -- Restart the script in debug mode again.\\n\"\n            \"help    -- Show Lua script debugging commands.\\n\\n\"\n            );\n        }\n\n        sdsfree(script);\n        script = sdsempty();\n        got_comma = 0;\n        keys = 0;\n\n        /* Load the script from the file, as an sds string. */\n        fp = fopen(config.eval,\"r\");\n        if (!fp) {\n            fprintf(stderr,\n                \"Can't open file '%s': %s\\n\", config.eval, strerror(errno));\n            exit(1);\n        }\n        while((nread = fread(buf,1,sizeof(buf),fp)) != 0) {\n            script = sdscatlen(script,buf,nread);\n        }\n        fclose(fp);\n\n        /* If we are debugging a script, enable the Lua debugger. */\n        if (config.eval_ldb) {\n            redisReply *reply = redisCommand(context,\n                    config.eval_ldb_sync ?\n                    \"SCRIPT DEBUG sync\": \"SCRIPT DEBUG yes\");\n            if (reply) freeReplyObject(reply);\n        }\n\n        /* Create our argument vector */\n        argv2 = zmalloc(sizeof(sds)*(argc+3));\n        argv2[0] = sdsnew(\"EVAL\");\n        argv2[1] = script;\n        for (j = 0; j < argc; j++) {\n            if (!got_comma && argv[j][0] == ',' && argv[j][1] == 0) {\n                got_comma = 1;\n                continue;\n            }\n            argv2[j+3-got_comma] = sdsnew(argv[j]);\n            if (!got_comma) keys++;\n        }\n        argv2[2] = sdscatprintf(sdsempty(),\"%d\",keys);\n\n        /* Call it */\n        int eval_ldb = config.eval_ldb; /* Save it, may be reverteed. */\n        retval = issueCommand(argc+3-got_comma, argv2);\n        if (eval_ldb) {\n            if (!config.eval_ldb) {\n                /* If the debugging session ended immediately, there was an\n                 * error compiling the script. Show it and don't enter\n                 * the REPL at all. */\n                printf(\"Eval debugging session can't start:\\n\");\n                cliReadReply(0);\n                break; /* Return to the caller. */\n            } else {\n                strncpy(config.prompt,\"lua debugger> \",sizeof(config.prompt));\n                repl();\n                /* Restart the session if repl() returned. */\n                cliConnect(1);\n                printf(\"\\n\");\n            }\n        } else {\n            break; /* Return to the caller. */\n        }\n    }\n    return retval;\n}\n\n/*------------------------------------------------------------------------------\n * Latency and latency history modes\n *--------------------------------------------------------------------------- */\n\nstatic void latencyModePrint(long long min, long long max, double avg, long long count) {\n    if (config.output == OUTPUT_STANDARD) {\n        printf(\"min: %lld, max: %lld, avg: %.2f (%lld samples)\",\n                min, max, avg, count);\n        fflush(stdout);\n    } else if (config.output == OUTPUT_CSV) {\n        printf(\"%lld,%lld,%.2f,%lld\\n\", min, max, avg, count);\n    } else if (config.output == OUTPUT_RAW) {\n        printf(\"%lld %lld %.2f %lld\\n\", min, max, avg, count);\n    }\n}\n\n#define LATENCY_SAMPLE_RATE 10 /* milliseconds. */\n#define LATENCY_HISTORY_DEFAULT_INTERVAL 15000 /* milliseconds. */\nstatic void latencyMode(void) {\n    redisReply *reply;\n    long long start, latency, min = 0, max = 0, tot = 0, count = 0;\n    long long history_interval =\n        config.interval ? config.interval/1000 :\n                          LATENCY_HISTORY_DEFAULT_INTERVAL;\n    double avg;\n    long long history_start = mstime();\n\n    /* Set a default for the interval in case of --latency option\n     * with --raw, --csv or when it is redirected to non tty. */\n    if (config.interval == 0) {\n        config.interval = 1000;\n    } else {\n        config.interval /= 1000; /* We need to convert to milliseconds. */\n    }\n\n    if (!context) exit(1);\n    while(1) {\n        start = mstime();\n        reply = reconnectingRedisCommand(context,\"PING\");\n        if (reply == NULL) {\n            fprintf(stderr,\"\\nI/O error\\n\");\n            exit(1);\n        }\n        latency = mstime()-start;\n        freeReplyObject(reply);\n        count++;\n        if (count == 1) {\n            min = max = tot = latency;\n            avg = (double) latency;\n        } else {\n            if (latency < min) min = latency;\n            if (latency > max) max = latency;\n            tot += latency;\n            avg = (double) tot/count;\n        }\n\n        if (config.output == OUTPUT_STANDARD) {\n            printf(\"\\x1b[0G\\x1b[2K\"); /* Clear the line. */\n            latencyModePrint(min,max,avg,count);\n        } else {\n            if (config.latency_history) {\n                latencyModePrint(min,max,avg,count);\n            } else if (mstime()-history_start > config.interval) {\n                latencyModePrint(min,max,avg,count);\n                exit(0);\n            }\n        }\n\n        if (config.latency_history && mstime()-history_start > history_interval)\n        {\n            printf(\" -- %.2f seconds range\\n\", (float)(mstime()-history_start)/1000);\n            history_start = mstime();\n            min = max = tot = count = 0;\n        }\n        usleep(LATENCY_SAMPLE_RATE * 1000);\n    }\n}\n\n/*------------------------------------------------------------------------------\n * Latency distribution mode -- requires 256 colors xterm\n *--------------------------------------------------------------------------- */\n\n#define LATENCY_DIST_DEFAULT_INTERVAL 1000 /* milliseconds. */\n\n/* Structure to store samples distribution. */\nstruct distsamples {\n    long long max;   /* Max latency to fit into this interval (usec). */\n    long long count; /* Number of samples in this interval. */\n    int character;   /* Associated character in visualization. */\n};\n\n/* Helper function for latencyDistMode(). Performs the spectrum visualization\n * of the collected samples targeting an xterm 256 terminal.\n *\n * Takes an array of distsamples structures, ordered from smaller to bigger\n * 'max' value. Last sample max must be 0, to mean that it olds all the\n * samples greater than the previous one, and is also the stop sentinel.\n *\n * \"tot' is the total number of samples in the different buckets, so it\n * is the SUM(samples[i].conut) for i to 0 up to the max sample.\n *\n * As a side effect the function sets all the buckets count to 0. */\nvoid showLatencyDistSamples(struct distsamples *samples, long long tot) {\n    int j;\n\n     /* We convert samples into a index inside the palette\n     * proportional to the percentage a given bucket represents.\n     * This way intensity of the different parts of the spectrum\n     * don't change relative to the number of requests, which avoids to\n     * pollute the visualization with non-latency related info. */\n    printf(\"\\033[38;5;0m\"); /* Set foreground color to black. */\n    for (j = 0; ; j++) {\n        int coloridx =\n            ceil((float) samples[j].count / tot * (spectrum_palette_size-1));\n        int color = spectrum_palette[coloridx];\n        printf(\"\\033[48;5;%dm%c\", (int)color, samples[j].character);\n        samples[j].count = 0;\n        if (samples[j].max == 0) break; /* Last sample. */\n    }\n    printf(\"\\033[0m\\n\");\n    fflush(stdout);\n}\n\n/* Show the legend: different buckets values and colors meaning, so\n * that the spectrum is more easily readable. */\nvoid showLatencyDistLegend(void) {\n    int j;\n\n    printf(\"---------------------------------------------\\n\");\n    printf(\". - * #          .01 .125 .25 .5 milliseconds\\n\");\n    printf(\"1,2,3,...,9      from 1 to 9     milliseconds\\n\");\n    printf(\"A,B,C,D,E        10,20,30,40,50  milliseconds\\n\");\n    printf(\"F,G,H,I,J        .1,.2,.3,.4,.5       seconds\\n\");\n    printf(\"K,L,M,N,O,P,Q,?  1,2,4,8,16,30,60,>60 seconds\\n\");\n    printf(\"From 0 to 100%%: \");\n    for (j = 0; j < spectrum_palette_size; j++) {\n        printf(\"\\033[48;5;%dm \", spectrum_palette[j]);\n    }\n    printf(\"\\033[0m\\n\");\n    printf(\"---------------------------------------------\\n\");\n}\n\nstatic void latencyDistMode(void) {\n    redisReply *reply;\n    long long start, latency, count = 0;\n    long long history_interval =\n        config.interval ? config.interval/1000 :\n                          LATENCY_DIST_DEFAULT_INTERVAL;\n    long long history_start = ustime();\n    int j, outputs = 0;\n\n    struct distsamples samples[] = {\n        /* We use a mostly logarithmic scale, with certain linear intervals\n         * which are more interesting than others, like 1-10 milliseconds\n         * range. */\n        {10,0,'.'},         /* 0.01 ms */\n        {125,0,'-'},        /* 0.125 ms */\n        {250,0,'*'},        /* 0.25 ms */\n        {500,0,'#'},        /* 0.5 ms */\n        {1000,0,'1'},       /* 1 ms */\n        {2000,0,'2'},       /* 2 ms */\n        {3000,0,'3'},       /* 3 ms */\n        {4000,0,'4'},       /* 4 ms */\n        {5000,0,'5'},       /* 5 ms */\n        {6000,0,'6'},       /* 6 ms */\n        {7000,0,'7'},       /* 7 ms */\n        {8000,0,'8'},       /* 8 ms */\n        {9000,0,'9'},       /* 9 ms */\n        {10000,0,'A'},      /* 10 ms */\n        {20000,0,'B'},      /* 20 ms */\n        {30000,0,'C'},      /* 30 ms */\n        {40000,0,'D'},      /* 40 ms */\n        {50000,0,'E'},      /* 50 ms */\n        {100000,0,'F'},     /* 0.1 s */\n        {200000,0,'G'},     /* 0.2 s */\n        {300000,0,'H'},     /* 0.3 s */\n        {400000,0,'I'},     /* 0.4 s */\n        {500000,0,'J'},     /* 0.5 s */\n        {1000000,0,'K'},    /* 1 s */\n        {2000000,0,'L'},    /* 2 s */\n        {4000000,0,'M'},    /* 4 s */\n        {8000000,0,'N'},    /* 8 s */\n        {16000000,0,'O'},   /* 16 s */\n        {30000000,0,'P'},   /* 30 s */\n        {60000000,0,'Q'},   /* 1 minute */\n        {0,0,'?'},          /* > 1 minute */\n    };\n\n    if (!context) exit(1);\n    while(1) {\n        start = ustime();\n        reply = reconnectingRedisCommand(context,\"PING\");\n        if (reply == NULL) {\n            fprintf(stderr,\"\\nI/O error\\n\");\n            exit(1);\n        }\n        latency = ustime()-start;\n        freeReplyObject(reply);\n        count++;\n\n        /* Populate the relevant bucket. */\n        for (j = 0; ; j++) {\n            if (samples[j].max == 0 || latency <= samples[j].max) {\n                samples[j].count++;\n                break;\n            }\n        }\n\n        /* From time to time show the spectrum. */\n        if (count && (ustime()-history_start)/1000 > history_interval) {\n            if ((outputs++ % 20) == 0)\n                showLatencyDistLegend();\n            showLatencyDistSamples(samples,count);\n            history_start = ustime();\n            count = 0;\n        }\n        usleep(LATENCY_SAMPLE_RATE * 1000);\n    }\n}\n\n/*------------------------------------------------------------------------------\n * Slave mode\n *--------------------------------------------------------------------------- */\n\n/* Sends SYNC and reads the number of bytes in the payload. Used both by\n * slaveMode() and getRDB(). */\nunsigned long long sendSync(int fd) {\n    /* To start we need to send the SYNC command and return the payload.\n     * The hiredis client lib does not understand this part of the protocol\n     * and we don't want to mess with its buffers, so everything is performed\n     * using direct low-level I/O. */\n    char buf[4096], *p;\n    ssize_t nread;\n\n    /* Send the SYNC command. */\n    if (write(fd,\"SYNC\\r\\n\",6) != 6) {\n        fprintf(stderr,\"Error writing to master\\n\");\n        exit(1);\n    }\n\n    /* Read $<payload>\\r\\n, making sure to read just up to \"\\n\" */\n    p = buf;\n    while(1) {\n        nread = read(fd,p,1);\n        if (nread <= 0) {\n            fprintf(stderr,\"Error reading bulk length while SYNCing\\n\");\n            exit(1);\n        }\n        if (*p == '\\n' && p != buf) break;\n        if (*p != '\\n') p++;\n    }\n    *p = '\\0';\n    if (buf[0] == '-') {\n        printf(\"SYNC with master failed: %s\\n\", buf);\n        exit(1);\n    }\n    return strtoull(buf+1,NULL,10);\n}\n\nstatic void slaveMode(void) {\n    int fd = context->fd;\n    unsigned long long payload = sendSync(fd);\n    char buf[1024];\n    int original_output = config.output;\n\n    fprintf(stderr,\"SYNC with master, discarding %llu \"\n                   \"bytes of bulk transfer...\\n\", payload);\n\n    /* Discard the payload. */\n    while(payload) {\n        ssize_t nread;\n\n        nread = read(fd,buf,(payload > sizeof(buf)) ? sizeof(buf) : payload);\n        if (nread <= 0) {\n            fprintf(stderr,\"Error reading RDB payload while SYNCing\\n\");\n            exit(1);\n        }\n        payload -= nread;\n    }\n    fprintf(stderr,\"SYNC done. Logging commands from master.\\n\");\n\n    /* Now we can use hiredis to read the incoming protocol. */\n    config.output = OUTPUT_CSV;\n    while (cliReadReply(0) == REDIS_OK);\n    config.output = original_output;\n}\n\n/*------------------------------------------------------------------------------\n * RDB transfer mode\n *--------------------------------------------------------------------------- */\n\n/* This function implements --rdb, so it uses the replication protocol in order\n * to fetch the RDB file from a remote server. */\nstatic void getRDB(void) {\n    int s = context->fd;\n    int fd;\n    unsigned long long payload = sendSync(s);\n    char buf[4096];\n\n    fprintf(stderr,\"SYNC sent to master, writing %llu bytes to '%s'\\n\",\n        payload, config.rdb_filename);\n\n    /* Write to file. */\n    if (!strcmp(config.rdb_filename,\"-\")) {\n        fd = STDOUT_FILENO;\n    } else {\n        fd = open(config.rdb_filename, O_CREAT|O_WRONLY, 0644);\n        if (fd == -1) {\n            fprintf(stderr, \"Error opening '%s': %s\\n\", config.rdb_filename,\n                strerror(errno));\n            exit(1);\n        }\n    }\n\n    while(payload) {\n        ssize_t nread, nwritten;\n\n        nread = read(s,buf,(payload > sizeof(buf)) ? sizeof(buf) : payload);\n        if (nread <= 0) {\n            fprintf(stderr,\"I/O Error reading RDB payload from socket\\n\");\n            exit(1);\n        }\n        nwritten = write(fd, buf, nread);\n        if (nwritten != nread) {\n            fprintf(stderr,\"Error writing data to file: %s\\n\",\n                strerror(errno));\n            exit(1);\n        }\n        payload -= nread;\n    }\n    close(s); /* Close the file descriptor ASAP as fsync() may take time. */\n    fsync(fd);\n    fprintf(stderr,\"Transfer finished with success.\\n\");\n    exit(0);\n}\n\n/*------------------------------------------------------------------------------\n * Bulk import (pipe) mode\n *--------------------------------------------------------------------------- */\n\n#define PIPEMODE_WRITE_LOOP_MAX_BYTES (128*1024)\nstatic void pipeMode(void) {\n    int fd = context->fd;\n    long long errors = 0, replies = 0, obuf_len = 0, obuf_pos = 0;\n    char ibuf[1024*16], obuf[1024*16]; /* Input and output buffers */\n    char aneterr[ANET_ERR_LEN];\n    redisReader *reader = redisReaderCreate();\n    redisReply *reply;\n    int eof = 0; /* True once we consumed all the standard input. */\n    int done = 0;\n    char magic[20]; /* Special reply we recognize. */\n    time_t last_read_time = time(NULL);\n\n    srand(time(NULL));\n\n    /* Use non blocking I/O. */\n    if (anetNonBlock(aneterr,fd) == ANET_ERR) {\n        fprintf(stderr, \"Can't set the socket in non blocking mode: %s\\n\",\n            aneterr);\n        exit(1);\n    }\n\n    /* Transfer raw protocol and read replies from the server at the same\n     * time. */\n    while(!done) {\n        int mask = AE_READABLE;\n\n        if (!eof || obuf_len != 0) mask |= AE_WRITABLE;\n        mask = aeWait(fd,mask,1000);\n\n        /* Handle the readable state: we can read replies from the server. */\n        if (mask & AE_READABLE) {\n            ssize_t nread;\n\n            /* Read from socket and feed the hiredis reader. */\n            do {\n                nread = read(fd,ibuf,sizeof(ibuf));\n                if (nread == -1 && errno != EAGAIN && errno != EINTR) {\n                    fprintf(stderr, \"Error reading from the server: %s\\n\",\n                        strerror(errno));\n                    exit(1);\n                }\n                if (nread > 0) {\n                    redisReaderFeed(reader,ibuf,nread);\n                    last_read_time = time(NULL);\n                }\n            } while(nread > 0);\n\n            /* Consume replies. */\n            do {\n                if (redisReaderGetReply(reader,(void**)&reply) == REDIS_ERR) {\n                    fprintf(stderr, \"Error reading replies from server\\n\");\n                    exit(1);\n                }\n                if (reply) {\n                    if (reply->type == REDIS_REPLY_ERROR) {\n                        fprintf(stderr,\"%s\\n\", reply->str);\n                        errors++;\n                    } else if (eof && reply->type == REDIS_REPLY_STRING &&\n                                      reply->len == 20) {\n                        /* Check if this is the reply to our final ECHO\n                         * command. If so everything was received\n                         * from the server. */\n                        if (memcmp(reply->str,magic,20) == 0) {\n                            printf(\"Last reply received from server.\\n\");\n                            done = 1;\n                            replies--;\n                        }\n                    }\n                    replies++;\n                    freeReplyObject(reply);\n                }\n            } while(reply);\n        }\n\n        /* Handle the writable state: we can send protocol to the server. */\n        if (mask & AE_WRITABLE) {\n            ssize_t loop_nwritten = 0;\n\n            while(1) {\n                /* Transfer current buffer to server. */\n                if (obuf_len != 0) {\n                    ssize_t nwritten = write(fd,obuf+obuf_pos,obuf_len);\n\n                    if (nwritten == -1) {\n                        if (errno != EAGAIN && errno != EINTR) {\n                            fprintf(stderr, \"Error writing to the server: %s\\n\",\n                                strerror(errno));\n                            exit(1);\n                        } else {\n                            nwritten = 0;\n                        }\n                    }\n                    obuf_len -= nwritten;\n                    obuf_pos += nwritten;\n                    loop_nwritten += nwritten;\n                    if (obuf_len != 0) break; /* Can't accept more data. */\n                }\n                /* If buffer is empty, load from stdin. */\n                if (obuf_len == 0 && !eof) {\n                    ssize_t nread = read(STDIN_FILENO,obuf,sizeof(obuf));\n\n                    if (nread == 0) {\n                        /* The ECHO sequence starts with a \"\\r\\n\" so that if there\n                         * is garbage in the protocol we read from stdin, the ECHO\n                         * will likely still be properly formatted.\n                         * CRLF is ignored by Redis, so it has no effects. */\n                        char echo[] =\n                        \"\\r\\n*2\\r\\n$4\\r\\nECHO\\r\\n$20\\r\\n01234567890123456789\\r\\n\";\n                        int j;\n\n                        eof = 1;\n                        /* Everything transferred, so we queue a special\n                         * ECHO command that we can match in the replies\n                         * to make sure everything was read from the server. */\n                        for (j = 0; j < 20; j++)\n                            magic[j] = rand() & 0xff;\n                        memcpy(echo+21,magic,20);\n                        memcpy(obuf,echo,sizeof(echo)-1);\n                        obuf_len = sizeof(echo)-1;\n                        obuf_pos = 0;\n                        printf(\"All data transferred. Waiting for the last reply...\\n\");\n                    } else if (nread == -1) {\n                        fprintf(stderr, \"Error reading from stdin: %s\\n\",\n                            strerror(errno));\n                        exit(1);\n                    } else {\n                        obuf_len = nread;\n                        obuf_pos = 0;\n                    }\n                }\n                if ((obuf_len == 0 && eof) ||\n                    loop_nwritten > PIPEMODE_WRITE_LOOP_MAX_BYTES) break;\n            }\n        }\n\n        /* Handle timeout, that is, we reached EOF, and we are not getting\n         * replies from the server for a few seconds, nor the final ECHO is\n         * received. */\n        if (eof && config.pipe_timeout > 0 &&\n            time(NULL)-last_read_time > config.pipe_timeout)\n        {\n            fprintf(stderr,\"No replies for %d seconds: exiting.\\n\",\n                config.pipe_timeout);\n            errors++;\n            break;\n        }\n    }\n    redisReaderFree(reader);\n    printf(\"errors: %lld, replies: %lld\\n\", errors, replies);\n    if (errors)\n        exit(1);\n    else\n        exit(0);\n}\n\n/*------------------------------------------------------------------------------\n * Find big keys\n *--------------------------------------------------------------------------- */\n\n#define TYPE_STRING 0\n#define TYPE_LIST   1\n#define TYPE_SET    2\n#define TYPE_HASH   3\n#define TYPE_ZSET   4\n#define TYPE_STREAM 5\n#define TYPE_NONE   6\n#define TYPE_COUNT  7\n\nstatic redisReply *sendScan(unsigned long long *it) {\n    redisReply *reply = redisCommand(context, \"SCAN %llu\", *it);\n\n    /* Handle any error conditions */\n    if(reply == NULL) {\n        fprintf(stderr, \"\\nI/O error\\n\");\n        exit(1);\n    } else if(reply->type == REDIS_REPLY_ERROR) {\n        fprintf(stderr, \"SCAN error: %s\\n\", reply->str);\n        exit(1);\n    } else if(reply->type != REDIS_REPLY_ARRAY) {\n        fprintf(stderr, \"Non ARRAY response from SCAN!\\n\");\n        exit(1);\n    } else if(reply->elements != 2) {\n        fprintf(stderr, \"Invalid element count from SCAN!\\n\");\n        exit(1);\n    }\n\n    /* Validate our types are correct */\n    assert(reply->element[0]->type == REDIS_REPLY_STRING);\n    assert(reply->element[1]->type == REDIS_REPLY_ARRAY);\n\n    /* Update iterator */\n    *it = strtoull(reply->element[0]->str, NULL, 10);\n\n    return reply;\n}\n\nstatic int getDbSize(void) {\n    redisReply *reply;\n    int size;\n\n    reply = redisCommand(context, \"DBSIZE\");\n\n    if(reply == NULL || reply->type != REDIS_REPLY_INTEGER) {\n        fprintf(stderr, \"Couldn't determine DBSIZE!\\n\");\n        exit(1);\n    }\n\n    /* Grab the number of keys and free our reply */\n    size = reply->integer;\n    freeReplyObject(reply);\n\n    return size;\n}\n\nstatic int toIntType(char *key, char *type) {\n    if(!strcmp(type, \"string\")) {\n        return TYPE_STRING;\n    } else if(!strcmp(type, \"list\")) {\n        return TYPE_LIST;\n    } else if(!strcmp(type, \"set\")) {\n        return TYPE_SET;\n    } else if(!strcmp(type, \"hash\")) {\n        return TYPE_HASH;\n    } else if(!strcmp(type, \"zset\")) {\n        return TYPE_ZSET;\n    } else if(!strcmp(type, \"none\")) {\n        return TYPE_NONE;\n    } else {\n        fprintf(stderr, \"Unknown type '%s' for key '%s'\\n\", type, key);\n        exit(1);\n    }\n}\n\nstatic void getKeyTypes(redisReply *keys, int *types) {\n    redisReply *reply;\n    unsigned int i;\n\n    /* Pipeline TYPE commands */\n    for(i=0;i<keys->elements;i++) {\n        redisAppendCommand(context, \"TYPE %s\", keys->element[i]->str);\n    }\n\n    /* Retrieve types */\n    for(i=0;i<keys->elements;i++) {\n        if(redisGetReply(context, (void**)&reply)!=REDIS_OK) {\n            fprintf(stderr, \"Error getting type for key '%s' (%d: %s)\\n\",\n                keys->element[i]->str, context->err, context->errstr);\n            exit(1);\n        } else if(reply->type != REDIS_REPLY_STATUS) {\n            if(reply->type == REDIS_REPLY_ERROR) {\n                fprintf(stderr, \"TYPE returned an error: %s\\n\", reply->str);\n            } else {\n                fprintf(stderr,\n                    \"Invalid reply type (%d) for TYPE on key '%s'!\\n\",\n                    reply->type, keys->element[i]->str);\n            }\n            exit(1);\n        }\n\n        types[i] = toIntType(keys->element[i]->str, reply->str);\n        freeReplyObject(reply);\n    }\n}\n\nstatic void getKeySizes(redisReply *keys, int *types,\n                        unsigned long long *sizes)\n{\n    redisReply *reply;\n    char *sizecmds[] = {\"STRLEN\",\"LLEN\",\"SCARD\",\"HLEN\",\"ZCARD\"};\n    unsigned int i;\n\n    /* Pipeline size commands */\n    for(i=0;i<keys->elements;i++) {\n        /* Skip keys that were deleted */\n        if(types[i]==TYPE_NONE)\n            continue;\n\n        redisAppendCommand(context, \"%s %s\", sizecmds[types[i]],\n            keys->element[i]->str);\n    }\n\n    /* Retreive sizes */\n    for(i=0;i<keys->elements;i++) {\n        /* Skip keys that dissapeared between SCAN and TYPE */\n        if(types[i] == TYPE_NONE) {\n            sizes[i] = 0;\n            continue;\n        }\n\n        /* Retreive size */\n        if(redisGetReply(context, (void**)&reply)!=REDIS_OK) {\n            fprintf(stderr, \"Error getting size for key '%s' (%d: %s)\\n\",\n                keys->element[i]->str, context->err, context->errstr);\n            exit(1);\n        } else if(reply->type != REDIS_REPLY_INTEGER) {\n            /* Theoretically the key could have been removed and\n             * added as a different type between TYPE and SIZE */\n            fprintf(stderr,\n                \"Warning:  %s on '%s' failed (may have changed type)\\n\",\n                 sizecmds[types[i]], keys->element[i]->str);\n            sizes[i] = 0;\n        } else {\n            sizes[i] = reply->integer;\n        }\n\n        freeReplyObject(reply);\n    }\n}\n\nstatic void findBigKeys(void) {\n    unsigned long long biggest[TYPE_COUNT] = {0}, counts[TYPE_COUNT] = {0}, totalsize[TYPE_COUNT] = {0};\n    unsigned long long sampled = 0, total_keys, totlen=0, *sizes=NULL, it=0;\n    sds maxkeys[TYPE_COUNT] = {0};\n    char *typename[] = {\"string\",\"list\",\"set\",\"hash\",\"zset\",\"stream\",\"none\"};\n    char *typeunit[] = {\"bytes\",\"items\",\"members\",\"fields\",\"members\",\"entries\",\"\"};\n    redisReply *reply, *keys;\n    unsigned int arrsize=0, i;\n    int type, *types=NULL;\n    double pct;\n\n    /* Total keys pre scanning */\n    total_keys = getDbSize();\n\n    /* Status message */\n    printf(\"\\n# Scanning the entire keyspace to find biggest keys as well as\\n\");\n    printf(\"# average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec\\n\");\n    printf(\"# per 100 SCAN commands (not usually needed).\\n\\n\");\n\n    /* New up sds strings to keep track of overall biggest per type */\n    for(i=0;i<TYPE_NONE; i++) {\n        maxkeys[i] = sdsempty();\n        if(!maxkeys[i]) {\n            fprintf(stderr, \"Failed to allocate memory for largest key names!\\n\");\n            exit(1);\n        }\n    }\n\n    /* SCAN loop */\n    do {\n        /* Calculate approximate percentage completion */\n        pct = 100 * (double)sampled/total_keys;\n\n        /* Grab some keys and point to the keys array */\n        reply = sendScan(&it);\n        keys  = reply->element[1];\n\n        /* Reallocate our type and size array if we need to */\n        if(keys->elements > arrsize) {\n            types = zrealloc(types, sizeof(int)*keys->elements);\n            sizes = zrealloc(sizes, sizeof(unsigned long long)*keys->elements);\n\n            if(!types || !sizes) {\n                fprintf(stderr, \"Failed to allocate storage for keys!\\n\");\n                exit(1);\n            }\n\n            arrsize = keys->elements;\n        }\n\n        /* Retreive types and then sizes */\n        getKeyTypes(keys, types);\n        getKeySizes(keys, types, sizes);\n\n        /* Now update our stats */\n        for(i=0;i<keys->elements;i++) {\n            if((type = types[i]) == TYPE_NONE)\n                continue;\n\n            totalsize[type] += sizes[i];\n            counts[type]++;\n            totlen += keys->element[i]->len;\n            sampled++;\n\n            if(biggest[type]<sizes[i]) {\n                printf(\n                   \"[%05.2f%%] Biggest %-6s found so far '%s' with %llu %s\\n\",\n                   pct, typename[type], keys->element[i]->str, sizes[i],\n                   typeunit[type]);\n\n                /* Keep track of biggest key name for this type */\n                maxkeys[type] = sdscpy(maxkeys[type], keys->element[i]->str);\n                if(!maxkeys[type]) {\n                    fprintf(stderr, \"Failed to allocate memory for key!\\n\");\n                    exit(1);\n                }\n\n                /* Keep track of the biggest size for this type */\n                biggest[type] = sizes[i];\n            }\n\n            /* Update overall progress */\n            if(sampled % 1000000 == 0) {\n                printf(\"[%05.2f%%] Sampled %llu keys so far\\n\", pct, sampled);\n            }\n        }\n\n        /* Sleep if we've been directed to do so */\n        if(sampled && (sampled %100) == 0 && config.interval) {\n            usleep(config.interval);\n        }\n\n        freeReplyObject(reply);\n    } while(it != 0);\n\n    if(types) zfree(types);\n    if(sizes) zfree(sizes);\n\n    /* We're done */\n    printf(\"\\n-------- summary -------\\n\\n\");\n\n    printf(\"Sampled %llu keys in the keyspace!\\n\", sampled);\n    printf(\"Total key length in bytes is %llu (avg len %.2f)\\n\\n\",\n       totlen, totlen ? (double)totlen/sampled : 0);\n\n    /* Output the biggest keys we found, for types we did find */\n    for(i=0;i<TYPE_NONE;i++) {\n        if(sdslen(maxkeys[i])>0) {\n            printf(\"Biggest %6s found '%s' has %llu %s\\n\", typename[i], maxkeys[i],\n               biggest[i], typeunit[i]);\n        }\n    }\n\n    printf(\"\\n\");\n\n    for(i=0;i<TYPE_NONE;i++) {\n        printf(\"%llu %ss with %llu %s (%05.2f%% of keys, avg size %.2f)\\n\",\n           counts[i], typename[i], totalsize[i], typeunit[i],\n           sampled ? 100 * (double)counts[i]/sampled : 0,\n           counts[i] ? (double)totalsize[i]/counts[i] : 0);\n    }\n\n    /* Free sds strings containing max keys */\n    for(i=0;i<TYPE_NONE;i++) {\n        sdsfree(maxkeys[i]);\n    }\n\n    /* Success! */\n    exit(0);\n}\n\nstatic void getKeyFreqs(redisReply *keys, unsigned long long *freqs) {\n    redisReply *reply;\n    unsigned int i;\n\n    /* Pipeline OBJECT freq commands */\n    for(i=0;i<keys->elements;i++) {\n        redisAppendCommand(context, \"OBJECT freq %s\", keys->element[i]->str);\n    }\n\n    /* Retrieve freqs */\n    for(i=0;i<keys->elements;i++) {\n        if(redisGetReply(context, (void**)&reply)!=REDIS_OK) {\n            fprintf(stderr, \"Error getting freq for key '%s' (%d: %s)\\n\",\n                keys->element[i]->str, context->err, context->errstr);\n            exit(1);\n        } else if(reply->type != REDIS_REPLY_INTEGER) {\n            if(reply->type == REDIS_REPLY_ERROR) {\n                fprintf(stderr, \"Error: %s\\n\", reply->str);\n                exit(1);\n            } else {\n                fprintf(stderr, \"Warning: OBJECT freq on '%s' failed (may have been deleted)\\n\", keys->element[i]->str);\n                freqs[i] = 0;\n            }\n        } else {\n            freqs[i] = reply->integer;\n        }\n        freeReplyObject(reply);\n    }\n}\n\n#define HOTKEYS_SAMPLE 16\nstatic void findHotKeys(void) {\n    redisReply *keys, *reply;\n    unsigned long long counters[HOTKEYS_SAMPLE] = {0};\n    sds hotkeys[HOTKEYS_SAMPLE] = {NULL};\n    unsigned long long sampled = 0, total_keys, *freqs = NULL, it = 0;\n    unsigned int arrsize = 0, i, k;\n    double pct;\n\n    /* Total keys pre scanning */\n    total_keys = getDbSize();\n\n    /* Status message */\n    printf(\"\\n# Scanning the entire keyspace to find hot keys as well as\\n\");\n    printf(\"# average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec\\n\");\n    printf(\"# per 100 SCAN commands (not usually needed).\\n\\n\");\n\n    /* SCAN loop */\n    do {\n        /* Calculate approximate percentage completion */\n        pct = 100 * (double)sampled/total_keys;\n\n        /* Grab some keys and point to the keys array */\n        reply = sendScan(&it);\n        keys  = reply->element[1];\n\n        /* Reallocate our freqs array if we need to */\n        if(keys->elements > arrsize) {\n            freqs = zrealloc(freqs, sizeof(unsigned long long)*keys->elements);\n\n            if(!freqs) {\n                fprintf(stderr, \"Failed to allocate storage for keys!\\n\");\n                exit(1);\n            }\n\n            arrsize = keys->elements;\n        }\n\n        getKeyFreqs(keys, freqs);\n\n        /* Now update our stats */\n        for(i=0;i<keys->elements;i++) {\n            sampled++;\n            /* Update overall progress */\n            if(sampled % 1000000 == 0) {\n                printf(\"[%05.2f%%] Sampled %llu keys so far\\n\", pct, sampled);\n            }\n\n            /* Use eviction pool here */\n            k = 0;\n            while (k < HOTKEYS_SAMPLE && freqs[i] > counters[k]) k++;\n            if (k == 0) continue;\n            k--;\n            if (k == 0 || counters[k] == 0) {\n                sdsfree(hotkeys[k]);\n            } else {\n                sdsfree(hotkeys[0]);\n                memmove(counters,counters+1,sizeof(counters[0])*k);\n                memmove(hotkeys,hotkeys+1,sizeof(hotkeys[0])*k);\n            }\n            counters[k] = freqs[i];\n            hotkeys[k] = sdsnew(keys->element[i]->str);\n            printf(\n               \"[%05.2f%%] Hot key '%s' found so far with counter %llu\\n\",\n               pct, keys->element[i]->str, freqs[i]);\n        }\n\n        /* Sleep if we've been directed to do so */\n        if(sampled && (sampled %100) == 0 && config.interval) {\n            usleep(config.interval);\n        }\n\n        freeReplyObject(reply);\n    } while(it != 0);\n\n    if (freqs) zfree(freqs);\n\n    /* We're done */\n    printf(\"\\n-------- summary -------\\n\\n\");\n\n    printf(\"Sampled %llu keys in the keyspace!\\n\", sampled);\n\n    for (i=1; i<= HOTKEYS_SAMPLE; i++) {\n        k = HOTKEYS_SAMPLE - i;\n        if(counters[k]>0) {\n            printf(\"hot key found with counter: %llu\\tkeyname: %s\\n\", counters[k], hotkeys[k]);\n            sdsfree(hotkeys[k]);\n        }\n    }\n\n    exit(0);\n}\n\n/*------------------------------------------------------------------------------\n * Stats mode\n *--------------------------------------------------------------------------- */\n\n/* Return the specified INFO field from the INFO command output \"info\".\n * A new buffer is allocated for the result, that needs to be free'd.\n * If the field is not found NULL is returned. */\nstatic char *getInfoField(char *info, char *field) {\n    char *p = strstr(info,field);\n    char *n1, *n2;\n    char *result;\n\n    if (!p) return NULL;\n    p += strlen(field)+1;\n    n1 = strchr(p,'\\r');\n    n2 = strchr(p,',');\n    if (n2 && n2 < n1) n1 = n2;\n    result = zmalloc(sizeof(char)*(n1-p)+1);\n    memcpy(result,p,(n1-p));\n    result[n1-p] = '\\0';\n    return result;\n}\n\n/* Like the above function but automatically convert the result into\n * a long. On error (missing field) LONG_MIN is returned. */\nstatic long getLongInfoField(char *info, char *field) {\n    char *value = getInfoField(info,field);\n    long l;\n\n    if (!value) return LONG_MIN;\n    l = strtol(value,NULL,10);\n    zfree(value);\n    return l;\n}\n\n/* Convert number of bytes into a human readable string of the form:\n * 100B, 2G, 100M, 4K, and so forth. */\nvoid bytesToHuman(char *s, long long n) {\n    double d;\n\n    if (n < 0) {\n        *s = '-';\n        s++;\n        n = -n;\n    }\n    if (n < 1024) {\n        /* Bytes */\n        sprintf(s,\"%lldB\",n);\n        return;\n    } else if (n < (1024*1024)) {\n        d = (double)n/(1024);\n        sprintf(s,\"%.2fK\",d);\n    } else if (n < (1024LL*1024*1024)) {\n        d = (double)n/(1024*1024);\n        sprintf(s,\"%.2fM\",d);\n    } else if (n < (1024LL*1024*1024*1024)) {\n        d = (double)n/(1024LL*1024*1024);\n        sprintf(s,\"%.2fG\",d);\n    }\n}\n\nstatic void statMode(void) {\n    redisReply *reply;\n    long aux, requests = 0;\n    int i = 0;\n\n    while(1) {\n        char buf[64];\n        int j;\n\n        reply = reconnectingRedisCommand(context,\"INFO\");\n        if (reply->type == REDIS_REPLY_ERROR) {\n            printf(\"ERROR: %s\\n\", reply->str);\n            exit(1);\n        }\n\n        if ((i++ % 20) == 0) {\n            printf(\n\"------- data ------ --------------------- load -------------------- - child -\\n\"\n\"keys       mem      clients blocked requests            connections          \\n\");\n        }\n\n        /* Keys */\n        aux = 0;\n        for (j = 0; j < 20; j++) {\n            long k;\n\n            sprintf(buf,\"db%d:keys\",j);\n            k = getLongInfoField(reply->str,buf);\n            if (k == LONG_MIN) continue;\n            aux += k;\n        }\n        sprintf(buf,\"%ld\",aux);\n        printf(\"%-11s\",buf);\n\n        /* Used memory */\n        aux = getLongInfoField(reply->str,\"used_memory\");\n        bytesToHuman(buf,aux);\n        printf(\"%-8s\",buf);\n\n        /* Clients */\n        aux = getLongInfoField(reply->str,\"connected_clients\");\n        sprintf(buf,\"%ld\",aux);\n        printf(\" %-8s\",buf);\n\n        /* Blocked (BLPOPPING) Clients */\n        aux = getLongInfoField(reply->str,\"blocked_clients\");\n        sprintf(buf,\"%ld\",aux);\n        printf(\"%-8s\",buf);\n\n        /* Requests */\n        aux = getLongInfoField(reply->str,\"total_commands_processed\");\n        sprintf(buf,\"%ld (+%ld)\",aux,requests == 0 ? 0 : aux-requests);\n        printf(\"%-19s\",buf);\n        requests = aux;\n\n        /* Connections */\n        aux = getLongInfoField(reply->str,\"total_connections_received\");\n        sprintf(buf,\"%ld\",aux);\n        printf(\" %-12s\",buf);\n\n        /* Children */\n        aux = getLongInfoField(reply->str,\"bgsave_in_progress\");\n        aux |= getLongInfoField(reply->str,\"aof_rewrite_in_progress\") << 1;\n        aux |= getLongInfoField(reply->str,\"loading\") << 2;\n        switch(aux) {\n        case 0: break;\n        case 1:\n            printf(\"SAVE\");\n            break;\n        case 2:\n            printf(\"AOF\");\n            break;\n        case 3:\n            printf(\"SAVE+AOF\");\n            break;\n        case 4:\n            printf(\"LOAD\");\n            break;\n        }\n\n        printf(\"\\n\");\n        freeReplyObject(reply);\n        usleep(config.interval);\n    }\n}\n\n/*------------------------------------------------------------------------------\n * Scan mode\n *--------------------------------------------------------------------------- */\n\nstatic void scanMode(void) {\n    redisReply *reply;\n    unsigned long long cur = 0;\n\n    do {\n        if (config.pattern)\n            reply = redisCommand(context,\"SCAN %llu MATCH %s\",\n                cur,config.pattern);\n        else\n            reply = redisCommand(context,\"SCAN %llu\",cur);\n        if (reply == NULL) {\n            printf(\"I/O error\\n\");\n            exit(1);\n        } else if (reply->type == REDIS_REPLY_ERROR) {\n            printf(\"ERROR: %s\\n\", reply->str);\n            exit(1);\n        } else {\n            unsigned int j;\n\n            cur = strtoull(reply->element[0]->str,NULL,10);\n            for (j = 0; j < reply->element[1]->elements; j++)\n                printf(\"%s\\n\", reply->element[1]->element[j]->str);\n        }\n        freeReplyObject(reply);\n    } while(cur != 0);\n\n    exit(0);\n}\n\n/*------------------------------------------------------------------------------\n * LRU test mode\n *--------------------------------------------------------------------------- */\n\n/* Return an integer from min to max (both inclusive) using a power-law\n * distribution, depending on the value of alpha: the greater the alpha\n * the more bias towards lower values.\n *\n * With alpha = 6.2 the output follows the 80-20 rule where 20% of\n * the returned numbers will account for 80% of the frequency. */\nlong long powerLawRand(long long min, long long max, double alpha) {\n    double pl, r;\n\n    max += 1;\n    r = ((double)rand()) / RAND_MAX;\n    pl = pow(\n        ((pow(max,alpha+1) - pow(min,alpha+1))*r + pow(min,alpha+1)),\n        (1.0/(alpha+1)));\n    return (max-1-(long long)pl)+min;\n}\n\n/* Generates a key name among a set of lru_test_sample_size keys, using\n * an 80-20 distribution. */\nvoid LRUTestGenKey(char *buf, size_t buflen) {\n    snprintf(buf, buflen, \"lru:%lld\",\n        powerLawRand(1, config.lru_test_sample_size, 6.2));\n}\n\n#define LRU_CYCLE_PERIOD 1000 /* 1000 milliseconds. */\n#define LRU_CYCLE_PIPELINE_SIZE 250\nstatic void LRUTestMode(void) {\n    redisReply *reply;\n    char key[128];\n    long long start_cycle;\n    int j;\n\n    srand(time(NULL)^getpid());\n    while(1) {\n        /* Perform cycles of 1 second with 50% writes and 50% reads.\n         * We use pipelining batching writes / reads N times per cycle in order\n         * to fill the target instance easily. */\n        start_cycle = mstime();\n        long long hits = 0, misses = 0;\n        while(mstime() - start_cycle < 1000) {\n            /* Write cycle. */\n            for (j = 0; j < LRU_CYCLE_PIPELINE_SIZE; j++) {\n                char val[6];\n                val[5] = '\\0';\n                for (int i = 0; i < 5; i++) val[i] = 'A'+rand()%('z'-'A');\n                LRUTestGenKey(key,sizeof(key));\n                redisAppendCommand(context, \"SET %s %s\",key,val);\n            }\n            for (j = 0; j < LRU_CYCLE_PIPELINE_SIZE; j++)\n                redisGetReply(context, (void**)&reply);\n\n            /* Read cycle. */\n            for (j = 0; j < LRU_CYCLE_PIPELINE_SIZE; j++) {\n                LRUTestGenKey(key,sizeof(key));\n                redisAppendCommand(context, \"GET %s\",key);\n            }\n            for (j = 0; j < LRU_CYCLE_PIPELINE_SIZE; j++) {\n                if (redisGetReply(context, (void**)&reply) == REDIS_OK) {\n                    switch(reply->type) {\n                        case REDIS_REPLY_ERROR:\n                            printf(\"%s\\n\", reply->str);\n                            break;\n                        case REDIS_REPLY_NIL:\n                            misses++;\n                            break;\n                        default:\n                            hits++;\n                            break;\n                    }\n                }\n            }\n\n            if (context->err) {\n                fprintf(stderr,\"I/O error during LRU test\\n\");\n                exit(1);\n            }\n        }\n        /* Print stats. */\n        printf(\n            \"%lld Gets/sec | Hits: %lld (%.2f%%) | Misses: %lld (%.2f%%)\\n\",\n            hits+misses,\n            hits, (double)hits/(hits+misses)*100,\n            misses, (double)misses/(hits+misses)*100);\n    }\n    exit(0);\n}\n\n/*------------------------------------------------------------------------------\n * Intrisic latency mode.\n *\n * Measure max latency of a running process that does not result from\n * syscalls. Basically this software should provide an hint about how much\n * time the kernel leaves the process without a chance to run.\n *--------------------------------------------------------------------------- */\n\n/* This is just some computation the compiler can't optimize out.\n * Should run in less than 100-200 microseconds even using very\n * slow hardware. Runs in less than 10 microseconds in modern HW. */\nunsigned long compute_something_fast(void) {\n    unsigned char s[256], i, j, t;\n    int count = 1000, k;\n    unsigned long output = 0;\n\n    for (k = 0; k < 256; k++) s[k] = k;\n\n    i = 0;\n    j = 0;\n    while(count--) {\n        i++;\n        j = j + s[i];\n        t = s[i];\n        s[i] = s[j];\n        s[j] = t;\n        output += s[(s[i]+s[j])&255];\n    }\n    return output;\n}\n\nstatic void intrinsicLatencyModeStop(int s) {\n    UNUSED(s);\n    force_cancel_loop = 1;\n}\n\nstatic void intrinsicLatencyMode(void) {\n    long long test_end, run_time, max_latency = 0, runs = 0;\n\n    run_time = config.intrinsic_latency_duration*1000000;\n    test_end = ustime() + run_time;\n    signal(SIGINT, intrinsicLatencyModeStop);\n\n    while(1) {\n        long long start, end, latency;\n\n        start = ustime();\n        compute_something_fast();\n        end = ustime();\n        latency = end-start;\n        runs++;\n        if (latency <= 0) continue;\n\n        /* Reporting */\n        if (latency > max_latency) {\n            max_latency = latency;\n            printf(\"Max latency so far: %lld microseconds.\\n\", max_latency);\n        }\n\n        double avg_us = (double)run_time/runs;\n        double avg_ns = avg_us * 1e3;\n        if (force_cancel_loop || end > test_end) {\n            printf(\"\\n%lld total runs \"\n                \"(avg latency: \"\n                \"%.4f microseconds / %.2f nanoseconds per run).\\n\",\n                runs, avg_us, avg_ns);\n            printf(\"Worst run took %.0fx longer than the average latency.\\n\",\n                max_latency / avg_us);\n            exit(0);\n        }\n    }\n}\n\n/*------------------------------------------------------------------------------\n * Program main()\n *--------------------------------------------------------------------------- */\n\nint main(int argc, char **argv) {\n    int firstarg;\n\n    config.hostip = sdsnew(\"127.0.0.1\");\n    config.hostport = 6379;\n    config.hostsocket = NULL;\n    config.repeat = 1;\n    config.interval = 0;\n    config.dbnum = 0;\n    config.interactive = 0;\n    config.shutdown = 0;\n    config.monitor_mode = 0;\n    config.pubsub_mode = 0;\n    config.latency_mode = 0;\n    config.latency_dist_mode = 0;\n    config.latency_history = 0;\n    config.lru_test_mode = 0;\n    config.lru_test_sample_size = 0;\n    config.cluster_mode = 0;\n    config.slave_mode = 0;\n    config.getrdb_mode = 0;\n    config.stat_mode = 0;\n    config.scan_mode = 0;\n    config.intrinsic_latency_mode = 0;\n    config.pattern = NULL;\n    config.rdb_filename = NULL;\n    config.pipe_mode = 0;\n    config.pipe_timeout = REDIS_CLI_DEFAULT_PIPE_TIMEOUT;\n    config.bigkeys = 0;\n    config.hotkeys = 0;\n    config.stdinarg = 0;\n    config.auth = NULL;\n    config.eval = NULL;\n    config.eval_ldb = 0;\n    config.eval_ldb_end = 0;\n    config.eval_ldb_sync = 0;\n    config.enable_ldb_on_eval = 0;\n    config.last_cmd_type = -1;\n\n    pref.hints = 1;\n\n    spectrum_palette = spectrum_palette_color;\n    spectrum_palette_size = spectrum_palette_color_size;\n\n    if (!isatty(fileno(stdout)) && (getenv(\"FAKETTY\") == NULL))\n        config.output = OUTPUT_RAW;\n    else\n        config.output = OUTPUT_STANDARD;\n    config.mb_delim = sdsnew(\"\\n\");\n\n    firstarg = parseOptions(argc,argv);\n    argc -= firstarg;\n    argv += firstarg;\n\n    /* Latency mode */\n    if (config.latency_mode) {\n        if (cliConnect(0) == REDIS_ERR) exit(1);\n        latencyMode();\n    }\n\n    /* Latency distribution mode */\n    if (config.latency_dist_mode) {\n        if (cliConnect(0) == REDIS_ERR) exit(1);\n        latencyDistMode();\n    }\n\n    /* Slave mode */\n    if (config.slave_mode) {\n        if (cliConnect(0) == REDIS_ERR) exit(1);\n        slaveMode();\n    }\n\n    /* Get RDB mode. */\n    if (config.getrdb_mode) {\n        if (cliConnect(0) == REDIS_ERR) exit(1);\n        getRDB();\n    }\n\n    /* Pipe mode */\n    if (config.pipe_mode) {\n        if (cliConnect(0) == REDIS_ERR) exit(1);\n        pipeMode();\n    }\n\n    /* Find big keys */\n    if (config.bigkeys) {\n        if (cliConnect(0) == REDIS_ERR) exit(1);\n        findBigKeys();\n    }\n\n    /* Find hot keys */\n    if (config.hotkeys) {\n        if (cliConnect(0) == REDIS_ERR) exit(1);\n        findHotKeys();\n    }\n\n    /* Stat mode */\n    if (config.stat_mode) {\n        if (cliConnect(0) == REDIS_ERR) exit(1);\n        if (config.interval == 0) config.interval = 1000000;\n        statMode();\n    }\n\n    /* Scan mode */\n    if (config.scan_mode) {\n        if (cliConnect(0) == REDIS_ERR) exit(1);\n        scanMode();\n    }\n\n    /* LRU test mode */\n    if (config.lru_test_mode) {\n        if (cliConnect(0) == REDIS_ERR) exit(1);\n        LRUTestMode();\n    }\n\n    /* Intrinsic latency mode */\n    if (config.intrinsic_latency_mode) intrinsicLatencyMode();\n\n    /* Start interactive mode when no command is provided */\n    if (argc == 0 && !config.eval) {\n        /* Ignore SIGPIPE in interactive mode to force a reconnect */\n        signal(SIGPIPE, SIG_IGN);\n\n        /* Note that in repl mode we don't abort on connection error.\n         * A new attempt will be performed for every command send. */\n        cliConnect(0);\n        repl();\n    }\n\n    /* Otherwise, we have some arguments to execute */\n    if (cliConnect(0) != REDIS_OK) exit(1);\n    if (config.eval) {\n        return evalMode(argc,argv);\n    } else {\n        return noninteractive(argc,convertToSds(argc,argv));\n    }\n}\n"], "fixing_code": ["/* Redis CLI (command line interface)\n *\n * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"fmacros.h\"\n#include \"version.h\"\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <ctype.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <assert.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <math.h>\n\n#include <hiredis.h>\n#include <sds.h> /* use sds.h from hiredis, so that only one set of sds functions will be present in the binary */\n#include \"zmalloc.h\"\n#include \"linenoise.h\"\n#include \"help.h\"\n#include \"anet.h\"\n#include \"ae.h\"\n\n#define UNUSED(V) ((void) V)\n\n#define OUTPUT_STANDARD 0\n#define OUTPUT_RAW 1\n#define OUTPUT_CSV 2\n#define REDIS_CLI_KEEPALIVE_INTERVAL 15 /* seconds */\n#define REDIS_CLI_DEFAULT_PIPE_TIMEOUT 30 /* seconds */\n#define REDIS_CLI_HISTFILE_ENV \"REDISCLI_HISTFILE\"\n#define REDIS_CLI_HISTFILE_DEFAULT \".rediscli_history\"\n#define REDIS_CLI_RCFILE_ENV \"REDISCLI_RCFILE\"\n#define REDIS_CLI_RCFILE_DEFAULT \".redisclirc\"\n\n/* --latency-dist palettes. */\nint spectrum_palette_color_size = 19;\nint spectrum_palette_color[] = {0,233,234,235,237,239,241,243,245,247,144,143,142,184,226,214,208,202,196};\n\nint spectrum_palette_mono_size = 13;\nint spectrum_palette_mono[] = {0,233,234,235,237,239,241,243,245,247,249,251,253};\n\n/* The actual palette in use. */\nint *spectrum_palette;\nint spectrum_palette_size;\n\nstatic redisContext *context;\nstatic struct config {\n    char *hostip;\n    int hostport;\n    char *hostsocket;\n    long repeat;\n    long interval;\n    int dbnum;\n    int interactive;\n    int shutdown;\n    int monitor_mode;\n    int pubsub_mode;\n    int latency_mode;\n    int latency_dist_mode;\n    int latency_history;\n    int lru_test_mode;\n    long long lru_test_sample_size;\n    int cluster_mode;\n    int cluster_reissue_command;\n    int slave_mode;\n    int pipe_mode;\n    int pipe_timeout;\n    int getrdb_mode;\n    int stat_mode;\n    int scan_mode;\n    int intrinsic_latency_mode;\n    int intrinsic_latency_duration;\n    char *pattern;\n    char *rdb_filename;\n    int bigkeys;\n    int hotkeys;\n    int stdinarg; /* get last arg from stdin. (-x option) */\n    char *auth;\n    int output; /* output mode, see OUTPUT_* defines */\n    sds mb_delim;\n    char prompt[128];\n    char *eval;\n    int eval_ldb;\n    int eval_ldb_sync;  /* Ask for synchronous mode of the Lua debugger. */\n    int eval_ldb_end;   /* Lua debugging session ended. */\n    int enable_ldb_on_eval; /* Handle manual SCRIPT DEBUG + EVAL commands. */\n    int last_cmd_type;\n} config;\n\n/* User preferences. */\nstatic struct pref {\n    int hints;\n} pref;\n\nstatic volatile sig_atomic_t force_cancel_loop = 0;\nstatic void usage(void);\nstatic void slaveMode(void);\nchar *redisGitSHA1(void);\nchar *redisGitDirty(void);\nstatic int cliConnect(int force);\n\n/*------------------------------------------------------------------------------\n * Utility functions\n *--------------------------------------------------------------------------- */\n\nstatic long long ustime(void) {\n    struct timeval tv;\n    long long ust;\n\n    gettimeofday(&tv, NULL);\n    ust = ((long long)tv.tv_sec)*1000000;\n    ust += tv.tv_usec;\n    return ust;\n}\n\nstatic long long mstime(void) {\n    return ustime()/1000;\n}\n\nstatic void cliRefreshPrompt(void) {\n    if (config.eval_ldb) return;\n\n    sds prompt = sdsempty();\n    if (config.hostsocket != NULL) {\n        prompt = sdscatfmt(prompt,\"redis %s\",config.hostsocket);\n    } else {\n        char addr[256];\n        anetFormatAddr(addr, sizeof(addr), config.hostip, config.hostport);\n        prompt = sdscatlen(prompt,addr,strlen(addr));\n    }\n\n    /* Add [dbnum] if needed */\n    if (config.dbnum != 0)\n        prompt = sdscatfmt(prompt,\"[%i]\",config.dbnum);\n\n    /* Copy the prompt in the static buffer. */\n    prompt = sdscatlen(prompt,\"> \",2);\n    snprintf(config.prompt,sizeof(config.prompt),\"%s\",prompt);\n    sdsfree(prompt);\n}\n\n/* Return the name of the dotfile for the specified 'dotfilename'.\n * Normally it just concatenates user $HOME to the file specified\n * in 'dotfilename'. However if the environment varialbe 'envoverride'\n * is set, its value is taken as the path.\n *\n * The function returns NULL (if the file is /dev/null or cannot be\n * obtained for some error), or an SDS string that must be freed by\n * the user. */\nstatic sds getDotfilePath(char *envoverride, char *dotfilename) {\n    char *path = NULL;\n    sds dotPath = NULL;\n\n    /* Check the env for a dotfile override. */\n    path = getenv(envoverride);\n    if (path != NULL && *path != '\\0') {\n        if (!strcmp(\"/dev/null\", path)) {\n            return NULL;\n        }\n\n        /* If the env is set, return it. */\n        dotPath = sdsnew(path);\n    } else {\n        char *home = getenv(\"HOME\");\n        if (home != NULL && *home != '\\0') {\n            /* If no override is set use $HOME/<dotfilename>. */\n            dotPath = sdscatprintf(sdsempty(), \"%s/%s\", home, dotfilename);\n        }\n    }\n    return dotPath;\n}\n\n/* URL-style percent decoding. */\n#define isHexChar(c) (isdigit(c) || (c >= 'a' && c <= 'f'))\n#define decodeHexChar(c) (isdigit(c) ? c - '0' : c - 'a' + 10)\n#define decodeHex(h, l) ((decodeHexChar(h) << 4) + decodeHexChar(l))\n\nstatic sds percentDecode(const char *pe, size_t len) {\n    const char *end = pe + len;\n    sds ret = sdsempty();\n    const char *curr = pe;\n\n    while (curr < end) {\n        if (*curr == '%') {\n            if ((end - curr) < 2) {\n                fprintf(stderr, \"Incomplete URI encoding\\n\");\n                exit(1);\n            }\n\n            char h = tolower(*(++curr));\n            char l = tolower(*(++curr));\n            if (!isHexChar(h) || !isHexChar(l)) {\n                fprintf(stderr, \"Illegal character in URI encoding\\n\");\n                exit(1);\n            }\n            char c = decodeHex(h, l);\n            ret = sdscatlen(ret, &c, 1);\n            curr++;\n        } else {\n            ret = sdscatlen(ret, curr++, 1);\n        }\n    }\n\n    return ret;\n}\n\n/* Parse a URI and extract the server connection information.\n * URI scheme is based on the the provisional specification[1] excluding support\n * for query parameters. Valid URIs are:\n *   scheme:    \"redis://\"\n *   authority: [<username> \":\"] <password> \"@\"] [<hostname> [\":\" <port>]]\n *   path:      [\"/\" [<db>]]\n *\n *  [1]: https://www.iana.org/assignments/uri-schemes/prov/redis */\nstatic void parseRedisUri(const char *uri) {\n\n    const char *scheme = \"redis://\";\n    const char *curr = uri;\n    const char *end = uri + strlen(uri);\n    const char *userinfo, *username, *port, *host, *path;\n\n    /* URI must start with a valid scheme. */\n    if (strncasecmp(scheme, curr, strlen(scheme))) {\n        fprintf(stderr,\"Invalid URI scheme\\n\");\n        exit(1);\n    }\n    curr += strlen(scheme);\n    if (curr == end) return;\n\n    /* Extract user info. */\n    if ((userinfo = strchr(curr,'@'))) {\n        if ((username = strchr(curr, ':')) && username < userinfo) {\n            /* If provided, username is ignored. */\n            curr = username + 1;\n        }\n\n        config.auth = percentDecode(curr, userinfo - curr);\n        curr = userinfo + 1;\n    }\n    if (curr == end) return;\n\n    /* Extract host and port. */\n    path = strchr(curr, '/');\n    if (*curr != '/') {\n        host = path ? path - 1 : end;\n        if ((port = strchr(curr, ':'))) {\n            config.hostport = atoi(port + 1);\n            host = port - 1;\n        }\n        config.hostip = sdsnewlen(curr, host - curr + 1);\n    }\n    curr = path ? path + 1 : end;\n    if (curr == end) return;\n\n    /* Extract database number. */\n    config.dbnum = atoi(curr);\n}\n\n/*------------------------------------------------------------------------------\n * Help functions\n *--------------------------------------------------------------------------- */\n\n#define CLI_HELP_COMMAND 1\n#define CLI_HELP_GROUP 2\n\ntypedef struct {\n    int type;\n    int argc;\n    sds *argv;\n    sds full;\n\n    /* Only used for help on commands */\n    struct commandHelp *org;\n} helpEntry;\n\nstatic helpEntry *helpEntries;\nstatic int helpEntriesLen;\n\nstatic sds cliVersion(void) {\n    sds version;\n    version = sdscatprintf(sdsempty(), \"%s\", REDIS_VERSION);\n\n    /* Add git commit and working tree status when available */\n    if (strtoll(redisGitSHA1(),NULL,16)) {\n        version = sdscatprintf(version, \" (git:%s\", redisGitSHA1());\n        if (strtoll(redisGitDirty(),NULL,10))\n            version = sdscatprintf(version, \"-dirty\");\n        version = sdscat(version, \")\");\n    }\n    return version;\n}\n\nstatic void cliInitHelp(void) {\n    int commandslen = sizeof(commandHelp)/sizeof(struct commandHelp);\n    int groupslen = sizeof(commandGroups)/sizeof(char*);\n    int i, len, pos = 0;\n    helpEntry tmp;\n\n    helpEntriesLen = len = commandslen+groupslen;\n    helpEntries = zmalloc(sizeof(helpEntry)*len);\n\n    for (i = 0; i < groupslen; i++) {\n        tmp.argc = 1;\n        tmp.argv = zmalloc(sizeof(sds));\n        tmp.argv[0] = sdscatprintf(sdsempty(),\"@%s\",commandGroups[i]);\n        tmp.full = tmp.argv[0];\n        tmp.type = CLI_HELP_GROUP;\n        tmp.org = NULL;\n        helpEntries[pos++] = tmp;\n    }\n\n    for (i = 0; i < commandslen; i++) {\n        tmp.argv = sdssplitargs(commandHelp[i].name,&tmp.argc);\n        tmp.full = sdsnew(commandHelp[i].name);\n        tmp.type = CLI_HELP_COMMAND;\n        tmp.org = &commandHelp[i];\n        helpEntries[pos++] = tmp;\n    }\n}\n\n/* cliInitHelp() setups the helpEntries array with the command and group\n * names from the help.h file. However the Redis instance we are connecting\n * to may support more commands, so this function integrates the previous\n * entries with additional entries obtained using the COMMAND command\n * available in recent versions of Redis. */\nstatic void cliIntegrateHelp(void) {\n    if (cliConnect(0) == REDIS_ERR) return;\n\n    redisReply *reply = redisCommand(context, \"COMMAND\");\n    if(reply == NULL || reply->type != REDIS_REPLY_ARRAY) return;\n\n    /* Scan the array reported by COMMAND and fill only the entries that\n     * don't already match what we have. */\n    for (size_t j = 0; j < reply->elements; j++) {\n        redisReply *entry = reply->element[j];\n        if (entry->type != REDIS_REPLY_ARRAY || entry->elements < 4 ||\n            entry->element[0]->type != REDIS_REPLY_STRING ||\n            entry->element[1]->type != REDIS_REPLY_INTEGER ||\n            entry->element[3]->type != REDIS_REPLY_INTEGER) return;\n        char *cmdname = entry->element[0]->str;\n        int i;\n\n        for (i = 0; i < helpEntriesLen; i++) {\n            helpEntry *he = helpEntries+i;\n            if (!strcasecmp(he->argv[0],cmdname))\n                break;\n        }\n        if (i != helpEntriesLen) continue;\n\n        helpEntriesLen++;\n        helpEntries = zrealloc(helpEntries,sizeof(helpEntry)*helpEntriesLen);\n        helpEntry *new = helpEntries+(helpEntriesLen-1);\n\n        new->argc = 1;\n        new->argv = zmalloc(sizeof(sds));\n        new->argv[0] = sdsnew(cmdname);\n        new->full = new->argv[0];\n        new->type = CLI_HELP_COMMAND;\n        sdstoupper(new->argv[0]);\n\n        struct commandHelp *ch = zmalloc(sizeof(*ch));\n        ch->name = new->argv[0];\n        ch->params = sdsempty();\n        int args = llabs(entry->element[1]->integer);\n        if (entry->element[3]->integer == 1) {\n            ch->params = sdscat(ch->params,\"key \");\n            args--;\n        }\n        while(args--) ch->params = sdscat(ch->params,\"arg \");\n        if (entry->element[1]->integer < 0)\n            ch->params = sdscat(ch->params,\"...options...\");\n        ch->summary = \"Help not available\";\n        ch->group = 0;\n        ch->since = \"not known\";\n        new->org = ch;\n    }\n    freeReplyObject(reply);\n}\n\n/* Output command help to stdout. */\nstatic void cliOutputCommandHelp(struct commandHelp *help, int group) {\n    printf(\"\\r\\n  \\x1b[1m%s\\x1b[0m \\x1b[90m%s\\x1b[0m\\r\\n\", help->name, help->params);\n    printf(\"  \\x1b[33msummary:\\x1b[0m %s\\r\\n\", help->summary);\n    printf(\"  \\x1b[33msince:\\x1b[0m %s\\r\\n\", help->since);\n    if (group) {\n        printf(\"  \\x1b[33mgroup:\\x1b[0m %s\\r\\n\", commandGroups[help->group]);\n    }\n}\n\n/* Print generic help. */\nstatic void cliOutputGenericHelp(void) {\n    sds version = cliVersion();\n    printf(\n        \"redis-cli %s\\n\"\n        \"To get help about Redis commands type:\\n\"\n        \"      \\\"help @<group>\\\" to get a list of commands in <group>\\n\"\n        \"      \\\"help <command>\\\" for help on <command>\\n\"\n        \"      \\\"help <tab>\\\" to get a list of possible help topics\\n\"\n        \"      \\\"quit\\\" to exit\\n\"\n        \"\\n\"\n        \"To set redis-cli preferences:\\n\"\n        \"      \\\":set hints\\\" enable online hints\\n\"\n        \"      \\\":set nohints\\\" disable online hints\\n\"\n        \"Set your preferences in ~/.redisclirc\\n\",\n        version\n    );\n    sdsfree(version);\n}\n\n/* Output all command help, filtering by group or command name. */\nstatic void cliOutputHelp(int argc, char **argv) {\n    int i, j, len;\n    int group = -1;\n    helpEntry *entry;\n    struct commandHelp *help;\n\n    if (argc == 0) {\n        cliOutputGenericHelp();\n        return;\n    } else if (argc > 0 && argv[0][0] == '@') {\n        len = sizeof(commandGroups)/sizeof(char*);\n        for (i = 0; i < len; i++) {\n            if (strcasecmp(argv[0]+1,commandGroups[i]) == 0) {\n                group = i;\n                break;\n            }\n        }\n    }\n\n    assert(argc > 0);\n    for (i = 0; i < helpEntriesLen; i++) {\n        entry = &helpEntries[i];\n        if (entry->type != CLI_HELP_COMMAND) continue;\n\n        help = entry->org;\n        if (group == -1) {\n            /* Compare all arguments */\n            if (argc == entry->argc) {\n                for (j = 0; j < argc; j++) {\n                    if (strcasecmp(argv[j],entry->argv[j]) != 0) break;\n                }\n                if (j == argc) {\n                    cliOutputCommandHelp(help,1);\n                }\n            }\n        } else {\n            if (group == help->group) {\n                cliOutputCommandHelp(help,0);\n            }\n        }\n    }\n    printf(\"\\r\\n\");\n}\n\n/* Linenoise completion callback. */\nstatic void completionCallback(const char *buf, linenoiseCompletions *lc) {\n    size_t startpos = 0;\n    int mask;\n    int i;\n    size_t matchlen;\n    sds tmp;\n\n    if (strncasecmp(buf,\"help \",5) == 0) {\n        startpos = 5;\n        while (isspace(buf[startpos])) startpos++;\n        mask = CLI_HELP_COMMAND | CLI_HELP_GROUP;\n    } else {\n        mask = CLI_HELP_COMMAND;\n    }\n\n    for (i = 0; i < helpEntriesLen; i++) {\n        if (!(helpEntries[i].type & mask)) continue;\n\n        matchlen = strlen(buf+startpos);\n        if (strncasecmp(buf+startpos,helpEntries[i].full,matchlen) == 0) {\n            tmp = sdsnewlen(buf,startpos);\n            tmp = sdscat(tmp,helpEntries[i].full);\n            linenoiseAddCompletion(lc,tmp);\n            sdsfree(tmp);\n        }\n    }\n}\n\n/* Linenoise hints callback. */\nstatic char *hintsCallback(const char *buf, int *color, int *bold) {\n    if (!pref.hints) return NULL;\n\n    int i, argc, buflen = strlen(buf);\n    sds *argv = sdssplitargs(buf,&argc);\n    int endspace = buflen && isspace(buf[buflen-1]);\n\n    /* Check if the argument list is empty and return ASAP. */\n    if (argc == 0) {\n        sdsfreesplitres(argv,argc);\n        return NULL;\n    }\n\n    for (i = 0; i < helpEntriesLen; i++) {\n        if (!(helpEntries[i].type & CLI_HELP_COMMAND)) continue;\n\n        if (strcasecmp(argv[0],helpEntries[i].full) == 0)\n        {\n            *color = 90;\n            *bold = 0;\n            sds hint = sdsnew(helpEntries[i].org->params);\n\n            /* Remove arguments from the returned hint to show only the\n             * ones the user did not yet typed. */\n            int toremove = argc-1;\n            while(toremove > 0 && sdslen(hint)) {\n                if (hint[0] == '[') break;\n                if (hint[0] == ' ') toremove--;\n                sdsrange(hint,1,-1);\n            }\n\n            /* Add an initial space if needed. */\n            if (!endspace) {\n                sds newhint = sdsnewlen(\" \",1);\n                newhint = sdscatsds(newhint,hint);\n                sdsfree(hint);\n                hint = newhint;\n            }\n\n            sdsfreesplitres(argv,argc);\n            return hint;\n        }\n    }\n    sdsfreesplitres(argv,argc);\n    return NULL;\n}\n\nstatic void freeHintsCallback(void *ptr) {\n    sdsfree(ptr);\n}\n\n/*------------------------------------------------------------------------------\n * Networking / parsing\n *--------------------------------------------------------------------------- */\n\n/* Send AUTH command to the server */\nstatic int cliAuth(void) {\n    redisReply *reply;\n    if (config.auth == NULL) return REDIS_OK;\n\n    reply = redisCommand(context,\"AUTH %s\",config.auth);\n    if (reply != NULL) {\n        freeReplyObject(reply);\n        return REDIS_OK;\n    }\n    return REDIS_ERR;\n}\n\n/* Send SELECT dbnum to the server */\nstatic int cliSelect(void) {\n    redisReply *reply;\n    if (config.dbnum == 0) return REDIS_OK;\n\n    reply = redisCommand(context,\"SELECT %d\",config.dbnum);\n    if (reply != NULL) {\n        int result = REDIS_OK;\n        if (reply->type == REDIS_REPLY_ERROR) result = REDIS_ERR;\n        freeReplyObject(reply);\n        return result;\n    }\n    return REDIS_ERR;\n}\n\n/* Connect to the server. If force is not zero the connection is performed\n * even if there is already a connected socket. */\nstatic int cliConnect(int force) {\n    if (context == NULL || force) {\n        if (context != NULL) {\n            redisFree(context);\n        }\n\n        if (config.hostsocket == NULL) {\n            context = redisConnect(config.hostip,config.hostport);\n        } else {\n            context = redisConnectUnix(config.hostsocket);\n        }\n\n        if (context->err) {\n            fprintf(stderr,\"Could not connect to Redis at \");\n            if (config.hostsocket == NULL)\n                fprintf(stderr,\"%s:%d: %s\\n\",config.hostip,config.hostport,context->errstr);\n            else\n                fprintf(stderr,\"%s: %s\\n\",config.hostsocket,context->errstr);\n            redisFree(context);\n            context = NULL;\n            return REDIS_ERR;\n        }\n\n        /* Set aggressive KEEP_ALIVE socket option in the Redis context socket\n         * in order to prevent timeouts caused by the execution of long\n         * commands. At the same time this improves the detection of real\n         * errors. */\n        anetKeepAlive(NULL, context->fd, REDIS_CLI_KEEPALIVE_INTERVAL);\n\n        /* Do AUTH and select the right DB. */\n        if (cliAuth() != REDIS_OK)\n            return REDIS_ERR;\n        if (cliSelect() != REDIS_OK)\n            return REDIS_ERR;\n    }\n    return REDIS_OK;\n}\n\nstatic void cliPrintContextError(void) {\n    if (context == NULL) return;\n    fprintf(stderr,\"Error: %s\\n\",context->errstr);\n}\n\nstatic sds cliFormatReplyTTY(redisReply *r, char *prefix) {\n    sds out = sdsempty();\n    switch (r->type) {\n    case REDIS_REPLY_ERROR:\n        out = sdscatprintf(out,\"(error) %s\\n\", r->str);\n    break;\n    case REDIS_REPLY_STATUS:\n        out = sdscat(out,r->str);\n        out = sdscat(out,\"\\n\");\n    break;\n    case REDIS_REPLY_INTEGER:\n        out = sdscatprintf(out,\"(integer) %lld\\n\",r->integer);\n    break;\n    case REDIS_REPLY_STRING:\n        /* If you are producing output for the standard output we want\n        * a more interesting output with quoted characters and so forth */\n        out = sdscatrepr(out,r->str,r->len);\n        out = sdscat(out,\"\\n\");\n    break;\n    case REDIS_REPLY_NIL:\n        out = sdscat(out,\"(nil)\\n\");\n    break;\n    case REDIS_REPLY_ARRAY:\n        if (r->elements == 0) {\n            out = sdscat(out,\"(empty list or set)\\n\");\n        } else {\n            unsigned int i, idxlen = 0;\n            char _prefixlen[16];\n            char _prefixfmt[16];\n            sds _prefix;\n            sds tmp;\n\n            /* Calculate chars needed to represent the largest index */\n            i = r->elements;\n            do {\n                idxlen++;\n                i /= 10;\n            } while(i);\n\n            /* Prefix for nested multi bulks should grow with idxlen+2 spaces */\n            memset(_prefixlen,' ',idxlen+2);\n            _prefixlen[idxlen+2] = '\\0';\n            _prefix = sdscat(sdsnew(prefix),_prefixlen);\n\n            /* Setup prefix format for every entry */\n            snprintf(_prefixfmt,sizeof(_prefixfmt),\"%%s%%%ud) \",idxlen);\n\n            for (i = 0; i < r->elements; i++) {\n                /* Don't use the prefix for the first element, as the parent\n                 * caller already prepended the index number. */\n                out = sdscatprintf(out,_prefixfmt,i == 0 ? \"\" : prefix,i+1);\n\n                /* Format the multi bulk entry */\n                tmp = cliFormatReplyTTY(r->element[i],_prefix);\n                out = sdscatlen(out,tmp,sdslen(tmp));\n                sdsfree(tmp);\n            }\n            sdsfree(_prefix);\n        }\n    break;\n    default:\n        fprintf(stderr,\"Unknown reply type: %d\\n\", r->type);\n        exit(1);\n    }\n    return out;\n}\n\nint isColorTerm(void) {\n    char *t = getenv(\"TERM\");\n    return t != NULL && strstr(t,\"xterm\") != NULL;\n}\n\n/* Helper  function for sdsCatColorizedLdbReply() appending colorize strings\n * to an SDS string. */\nsds sdscatcolor(sds o, char *s, size_t len, char *color) {\n    if (!isColorTerm()) return sdscatlen(o,s,len);\n\n    int bold = strstr(color,\"bold\") != NULL;\n    int ccode = 37; /* Defaults to white. */\n    if (strstr(color,\"red\")) ccode = 31;\n    else if (strstr(color,\"green\")) ccode = 32;\n    else if (strstr(color,\"yellow\")) ccode = 33;\n    else if (strstr(color,\"blue\")) ccode = 34;\n    else if (strstr(color,\"magenta\")) ccode = 35;\n    else if (strstr(color,\"cyan\")) ccode = 36;\n    else if (strstr(color,\"white\")) ccode = 37;\n\n    o = sdscatfmt(o,\"\\033[%i;%i;49m\",bold,ccode);\n    o = sdscatlen(o,s,len);\n    o = sdscat(o,\"\\033[0m\");\n    return o;\n}\n\n/* Colorize Lua debugger status replies according to the prefix they\n * have. */\nsds sdsCatColorizedLdbReply(sds o, char *s, size_t len) {\n    char *color = \"white\";\n\n    if (strstr(s,\"<debug>\")) color = \"bold\";\n    if (strstr(s,\"<redis>\")) color = \"green\";\n    if (strstr(s,\"<reply>\")) color = \"cyan\";\n    if (strstr(s,\"<error>\")) color = \"red\";\n    if (strstr(s,\"<hint>\")) color = \"bold\";\n    if (strstr(s,\"<value>\") || strstr(s,\"<retval>\")) color = \"magenta\";\n    if (len > 4 && isdigit(s[3])) {\n        if (s[1] == '>') color = \"yellow\"; /* Current line. */\n        else if (s[2] == '#') color = \"bold\"; /* Break point. */\n    }\n    return sdscatcolor(o,s,len,color);\n}\n\nstatic sds cliFormatReplyRaw(redisReply *r) {\n    sds out = sdsempty(), tmp;\n    size_t i;\n\n    switch (r->type) {\n    case REDIS_REPLY_NIL:\n        /* Nothing... */\n        break;\n    case REDIS_REPLY_ERROR:\n        out = sdscatlen(out,r->str,r->len);\n        out = sdscatlen(out,\"\\n\",1);\n        break;\n    case REDIS_REPLY_STATUS:\n    case REDIS_REPLY_STRING:\n        if (r->type == REDIS_REPLY_STATUS && config.eval_ldb) {\n            /* The Lua debugger replies with arrays of simple (status)\n             * strings. We colorize the output for more fun if this\n             * is a debugging session. */\n\n            /* Detect the end of a debugging session. */\n            if (strstr(r->str,\"<endsession>\") == r->str) {\n                config.enable_ldb_on_eval = 0;\n                config.eval_ldb = 0;\n                config.eval_ldb_end = 1; /* Signal the caller session ended. */\n                config.output = OUTPUT_STANDARD;\n                cliRefreshPrompt();\n            } else {\n                out = sdsCatColorizedLdbReply(out,r->str,r->len);\n            }\n        } else {\n            out = sdscatlen(out,r->str,r->len);\n        }\n        break;\n    case REDIS_REPLY_INTEGER:\n        out = sdscatprintf(out,\"%lld\",r->integer);\n        break;\n    case REDIS_REPLY_ARRAY:\n        for (i = 0; i < r->elements; i++) {\n            if (i > 0) out = sdscat(out,config.mb_delim);\n            tmp = cliFormatReplyRaw(r->element[i]);\n            out = sdscatlen(out,tmp,sdslen(tmp));\n            sdsfree(tmp);\n        }\n        break;\n    default:\n        fprintf(stderr,\"Unknown reply type: %d\\n\", r->type);\n        exit(1);\n    }\n    return out;\n}\n\nstatic sds cliFormatReplyCSV(redisReply *r) {\n    unsigned int i;\n\n    sds out = sdsempty();\n    switch (r->type) {\n    case REDIS_REPLY_ERROR:\n        out = sdscat(out,\"ERROR,\");\n        out = sdscatrepr(out,r->str,strlen(r->str));\n    break;\n    case REDIS_REPLY_STATUS:\n        out = sdscatrepr(out,r->str,r->len);\n    break;\n    case REDIS_REPLY_INTEGER:\n        out = sdscatprintf(out,\"%lld\",r->integer);\n    break;\n    case REDIS_REPLY_STRING:\n        out = sdscatrepr(out,r->str,r->len);\n    break;\n    case REDIS_REPLY_NIL:\n        out = sdscat(out,\"NIL\");\n    break;\n    case REDIS_REPLY_ARRAY:\n        for (i = 0; i < r->elements; i++) {\n            sds tmp = cliFormatReplyCSV(r->element[i]);\n            out = sdscatlen(out,tmp,sdslen(tmp));\n            if (i != r->elements-1) out = sdscat(out,\",\");\n            sdsfree(tmp);\n        }\n    break;\n    default:\n        fprintf(stderr,\"Unknown reply type: %d\\n\", r->type);\n        exit(1);\n    }\n    return out;\n}\n\nstatic int cliReadReply(int output_raw_strings) {\n    void *_reply;\n    redisReply *reply;\n    sds out = NULL;\n    int output = 1;\n\n    if (redisGetReply(context,&_reply) != REDIS_OK) {\n        if (config.shutdown) {\n            redisFree(context);\n            context = NULL;\n            return REDIS_OK;\n        }\n        if (config.interactive) {\n            /* Filter cases where we should reconnect */\n            if (context->err == REDIS_ERR_IO &&\n                (errno == ECONNRESET || errno == EPIPE))\n                return REDIS_ERR;\n            if (context->err == REDIS_ERR_EOF)\n                return REDIS_ERR;\n        }\n        cliPrintContextError();\n        exit(1);\n        return REDIS_ERR; /* avoid compiler warning */\n    }\n\n    reply = (redisReply*)_reply;\n\n    config.last_cmd_type = reply->type;\n\n    /* Check if we need to connect to a different node and reissue the\n     * request. */\n    if (config.cluster_mode && reply->type == REDIS_REPLY_ERROR &&\n        (!strncmp(reply->str,\"MOVED\",5) || !strcmp(reply->str,\"ASK\")))\n    {\n        char *p = reply->str, *s;\n        int slot;\n\n        output = 0;\n        /* Comments show the position of the pointer as:\n         *\n         * [S] for pointer 's'\n         * [P] for pointer 'p'\n         */\n        s = strchr(p,' ');      /* MOVED[S]3999 127.0.0.1:6381 */\n        p = strchr(s+1,' ');    /* MOVED[S]3999[P]127.0.0.1:6381 */\n        *p = '\\0';\n        slot = atoi(s+1);\n        s = strrchr(p+1,':');    /* MOVED 3999[P]127.0.0.1[S]6381 */\n        *s = '\\0';\n        sdsfree(config.hostip);\n        config.hostip = sdsnew(p+1);\n        config.hostport = atoi(s+1);\n        if (config.interactive)\n            printf(\"-> Redirected to slot [%d] located at %s:%d\\n\",\n                slot, config.hostip, config.hostport);\n        config.cluster_reissue_command = 1;\n        cliRefreshPrompt();\n    }\n\n    if (output) {\n        if (output_raw_strings) {\n            out = cliFormatReplyRaw(reply);\n        } else {\n            if (config.output == OUTPUT_RAW) {\n                out = cliFormatReplyRaw(reply);\n                out = sdscat(out,\"\\n\");\n            } else if (config.output == OUTPUT_STANDARD) {\n                out = cliFormatReplyTTY(reply,\"\");\n            } else if (config.output == OUTPUT_CSV) {\n                out = cliFormatReplyCSV(reply);\n                out = sdscat(out,\"\\n\");\n            }\n        }\n        fwrite(out,sdslen(out),1,stdout);\n        sdsfree(out);\n    }\n    freeReplyObject(reply);\n    return REDIS_OK;\n}\n\nstatic int cliSendCommand(int argc, char **argv, long repeat) {\n    char *command = argv[0];\n    size_t *argvlen;\n    int j, output_raw;\n\n    if (!config.eval_ldb && /* In debugging mode, let's pass \"help\" to Redis. */\n        (!strcasecmp(command,\"help\") || !strcasecmp(command,\"?\"))) {\n        cliOutputHelp(--argc, ++argv);\n        return REDIS_OK;\n    }\n\n    if (context == NULL) return REDIS_ERR;\n\n    output_raw = 0;\n    if (!strcasecmp(command,\"info\") ||\n        (argc >= 2 && !strcasecmp(command,\"debug\") &&\n                       !strcasecmp(argv[1],\"htstats\")) ||\n        (argc >= 2 && !strcasecmp(command,\"memory\") &&\n                      (!strcasecmp(argv[1],\"malloc-stats\") ||\n                       !strcasecmp(argv[1],\"doctor\"))) ||\n        (argc == 2 && !strcasecmp(command,\"cluster\") &&\n                      (!strcasecmp(argv[1],\"nodes\") ||\n                       !strcasecmp(argv[1],\"info\"))) ||\n        (argc == 2 && !strcasecmp(command,\"client\") &&\n                       !strcasecmp(argv[1],\"list\")) ||\n        (argc == 3 && !strcasecmp(command,\"latency\") &&\n                       !strcasecmp(argv[1],\"graph\")) ||\n        (argc == 2 && !strcasecmp(command,\"latency\") &&\n                       !strcasecmp(argv[1],\"doctor\")))\n    {\n        output_raw = 1;\n    }\n\n    if (!strcasecmp(command,\"shutdown\")) config.shutdown = 1;\n    if (!strcasecmp(command,\"monitor\")) config.monitor_mode = 1;\n    if (!strcasecmp(command,\"subscribe\") ||\n        !strcasecmp(command,\"psubscribe\")) config.pubsub_mode = 1;\n    if (!strcasecmp(command,\"sync\") ||\n        !strcasecmp(command,\"psync\")) config.slave_mode = 1;\n\n    /* When the user manually calls SCRIPT DEBUG, setup the activation of\n     * debugging mode on the next eval if needed. */\n    if (argc == 3 && !strcasecmp(argv[0],\"script\") &&\n                     !strcasecmp(argv[1],\"debug\"))\n    {\n        if (!strcasecmp(argv[2],\"yes\") || !strcasecmp(argv[2],\"sync\")) {\n            config.enable_ldb_on_eval = 1;\n        } else {\n            config.enable_ldb_on_eval = 0;\n        }\n    }\n\n    /* Actually activate LDB on EVAL if needed. */\n    if (!strcasecmp(command,\"eval\") && config.enable_ldb_on_eval) {\n        config.eval_ldb = 1;\n        config.output = OUTPUT_RAW;\n    }\n\n    /* Setup argument length */\n    argvlen = zmalloc(argc*sizeof(size_t));\n    for (j = 0; j < argc; j++)\n        argvlen[j] = sdslen(argv[j]);\n\n    while(repeat-- > 0) {\n        redisAppendCommandArgv(context,argc,(const char**)argv,argvlen);\n        while (config.monitor_mode) {\n            if (cliReadReply(output_raw) != REDIS_OK) exit(1);\n            fflush(stdout);\n        }\n\n        if (config.pubsub_mode) {\n            if (config.output != OUTPUT_RAW)\n                printf(\"Reading messages... (press Ctrl-C to quit)\\n\");\n            while (1) {\n                if (cliReadReply(output_raw) != REDIS_OK) exit(1);\n            }\n        }\n\n        if (config.slave_mode) {\n            printf(\"Entering slave output mode...  (press Ctrl-C to quit)\\n\");\n            slaveMode();\n            config.slave_mode = 0;\n            zfree(argvlen);\n            return REDIS_ERR;  /* Error = slaveMode lost connection to master */\n        }\n\n        if (cliReadReply(output_raw) != REDIS_OK) {\n            zfree(argvlen);\n            return REDIS_ERR;\n        } else {\n            /* Store database number when SELECT was successfully executed. */\n            if (!strcasecmp(command,\"select\") && argc == 2 && config.last_cmd_type != REDIS_REPLY_ERROR) {\n                config.dbnum = atoi(argv[1]);\n                cliRefreshPrompt();\n            } else if (!strcasecmp(command,\"auth\") && argc == 2) {\n                cliSelect();\n            }\n        }\n        if (config.interval) usleep(config.interval);\n        fflush(stdout); /* Make it grep friendly */\n    }\n\n    zfree(argvlen);\n    return REDIS_OK;\n}\n\n/* Send a command reconnecting the link if needed. */\nstatic redisReply *reconnectingRedisCommand(redisContext *c, const char *fmt, ...) {\n    redisReply *reply = NULL;\n    int tries = 0;\n    va_list ap;\n\n    assert(!c->err);\n    while(reply == NULL) {\n        while (c->err & (REDIS_ERR_IO | REDIS_ERR_EOF)) {\n            printf(\"\\r\\x1b[0K\"); /* Cursor to left edge + clear line. */\n            printf(\"Reconnecting... %d\\r\", ++tries);\n            fflush(stdout);\n\n            redisFree(c);\n            c = redisConnect(config.hostip,config.hostport);\n            usleep(1000000);\n        }\n\n        va_start(ap,fmt);\n        reply = redisvCommand(c,fmt,ap);\n        va_end(ap);\n\n        if (c->err && !(c->err & (REDIS_ERR_IO | REDIS_ERR_EOF))) {\n            fprintf(stderr, \"Error: %s\\n\", c->errstr);\n            exit(1);\n        } else if (tries > 0) {\n            printf(\"\\r\\x1b[0K\"); /* Cursor to left edge + clear line. */\n        }\n    }\n\n    context = c;\n    return reply;\n}\n\n/*------------------------------------------------------------------------------\n * User interface\n *--------------------------------------------------------------------------- */\n\nstatic int parseOptions(int argc, char **argv) {\n    int i;\n\n    for (i = 1; i < argc; i++) {\n        int lastarg = i==argc-1;\n\n        if (!strcmp(argv[i],\"-h\") && !lastarg) {\n            sdsfree(config.hostip);\n            config.hostip = sdsnew(argv[++i]);\n        } else if (!strcmp(argv[i],\"-h\") && lastarg) {\n            usage();\n        } else if (!strcmp(argv[i],\"--help\")) {\n            usage();\n        } else if (!strcmp(argv[i],\"-x\")) {\n            config.stdinarg = 1;\n        } else if (!strcmp(argv[i],\"-p\") && !lastarg) {\n            config.hostport = atoi(argv[++i]);\n        } else if (!strcmp(argv[i],\"-s\") && !lastarg) {\n            config.hostsocket = argv[++i];\n        } else if (!strcmp(argv[i],\"-r\") && !lastarg) {\n            config.repeat = strtoll(argv[++i],NULL,10);\n        } else if (!strcmp(argv[i],\"-i\") && !lastarg) {\n            double seconds = atof(argv[++i]);\n            config.interval = seconds*1000000;\n        } else if (!strcmp(argv[i],\"-n\") && !lastarg) {\n            config.dbnum = atoi(argv[++i]);\n        } else if (!strcmp(argv[i],\"-a\") && !lastarg) {\n            fputs(\"Warning: Using a password with '-a' option on the command line interface may not be safe.\\n\", stderr);\n            config.auth = argv[++i];\n        } else if (!strcmp(argv[i],\"-u\") && !lastarg) {\n            parseRedisUri(argv[++i]);\n        } else if (!strcmp(argv[i],\"--raw\")) {\n            config.output = OUTPUT_RAW;\n        } else if (!strcmp(argv[i],\"--no-raw\")) {\n            config.output = OUTPUT_STANDARD;\n        } else if (!strcmp(argv[i],\"--csv\")) {\n            config.output = OUTPUT_CSV;\n        } else if (!strcmp(argv[i],\"--latency\")) {\n            config.latency_mode = 1;\n        } else if (!strcmp(argv[i],\"--latency-dist\")) {\n            config.latency_dist_mode = 1;\n        } else if (!strcmp(argv[i],\"--mono\")) {\n            spectrum_palette = spectrum_palette_mono;\n            spectrum_palette_size = spectrum_palette_mono_size;\n        } else if (!strcmp(argv[i],\"--latency-history\")) {\n            config.latency_mode = 1;\n            config.latency_history = 1;\n        } else if (!strcmp(argv[i],\"--lru-test\") && !lastarg) {\n            config.lru_test_mode = 1;\n            config.lru_test_sample_size = strtoll(argv[++i],NULL,10);\n        } else if (!strcmp(argv[i],\"--slave\")) {\n            config.slave_mode = 1;\n        } else if (!strcmp(argv[i],\"--stat\")) {\n            config.stat_mode = 1;\n        } else if (!strcmp(argv[i],\"--scan\")) {\n            config.scan_mode = 1;\n        } else if (!strcmp(argv[i],\"--pattern\") && !lastarg) {\n            config.pattern = argv[++i];\n        } else if (!strcmp(argv[i],\"--intrinsic-latency\") && !lastarg) {\n            config.intrinsic_latency_mode = 1;\n            config.intrinsic_latency_duration = atoi(argv[++i]);\n        } else if (!strcmp(argv[i],\"--rdb\") && !lastarg) {\n            config.getrdb_mode = 1;\n            config.rdb_filename = argv[++i];\n        } else if (!strcmp(argv[i],\"--pipe\")) {\n            config.pipe_mode = 1;\n        } else if (!strcmp(argv[i],\"--pipe-timeout\") && !lastarg) {\n            config.pipe_timeout = atoi(argv[++i]);\n        } else if (!strcmp(argv[i],\"--bigkeys\")) {\n            config.bigkeys = 1;\n        } else if (!strcmp(argv[i],\"--hotkeys\")) {\n            config.hotkeys = 1;\n        } else if (!strcmp(argv[i],\"--eval\") && !lastarg) {\n            config.eval = argv[++i];\n        } else if (!strcmp(argv[i],\"--ldb\")) {\n            config.eval_ldb = 1;\n            config.output = OUTPUT_RAW;\n        } else if (!strcmp(argv[i],\"--ldb-sync-mode\")) {\n            config.eval_ldb = 1;\n            config.eval_ldb_sync = 1;\n            config.output = OUTPUT_RAW;\n        } else if (!strcmp(argv[i],\"-c\")) {\n            config.cluster_mode = 1;\n        } else if (!strcmp(argv[i],\"-d\") && !lastarg) {\n            sdsfree(config.mb_delim);\n            config.mb_delim = sdsnew(argv[++i]);\n        } else if (!strcmp(argv[i],\"-v\") || !strcmp(argv[i], \"--version\")) {\n            sds version = cliVersion();\n            printf(\"redis-cli %s\\n\", version);\n            sdsfree(version);\n            exit(0);\n        } else {\n            if (argv[i][0] == '-') {\n                fprintf(stderr,\n                    \"Unrecognized option or bad number of args for: '%s'\\n\",\n                    argv[i]);\n                exit(1);\n            } else {\n                /* Likely the command name, stop here. */\n                break;\n            }\n        }\n    }\n\n    /* --ldb requires --eval. */\n    if (config.eval_ldb && config.eval == NULL) {\n        fprintf(stderr,\"Options --ldb and --ldb-sync-mode require --eval.\\n\");\n        fprintf(stderr,\"Try %s --help for more information.\\n\", argv[0]);\n        exit(1);\n    }\n    return i;\n}\n\nstatic sds readArgFromStdin(void) {\n    char buf[1024];\n    sds arg = sdsempty();\n\n    while(1) {\n        int nread = read(fileno(stdin),buf,1024);\n\n        if (nread == 0) break;\n        else if (nread == -1) {\n            perror(\"Reading from standard input\");\n            exit(1);\n        }\n        arg = sdscatlen(arg,buf,nread);\n    }\n    return arg;\n}\n\nstatic void usage(void) {\n    sds version = cliVersion();\n    fprintf(stderr,\n\"redis-cli %s\\n\"\n\"\\n\"\n\"Usage: redis-cli [OPTIONS] [cmd [arg [arg ...]]]\\n\"\n\"  -h <hostname>      Server hostname (default: 127.0.0.1).\\n\"\n\"  -p <port>          Server port (default: 6379).\\n\"\n\"  -s <socket>        Server socket (overrides hostname and port).\\n\"\n\"  -a <password>      Password to use when connecting to the server.\\n\"\n\"  -u <uri>           Server URI.\\n\"\n\"  -r <repeat>        Execute specified command N times.\\n\"\n\"  -i <interval>      When -r is used, waits <interval> seconds per command.\\n\"\n\"                     It is possible to specify sub-second times like -i 0.1.\\n\"\n\"  -n <db>            Database number.\\n\"\n\"  -x                 Read last argument from STDIN.\\n\"\n\"  -d <delimiter>     Multi-bulk delimiter in for raw formatting (default: \\\\n).\\n\"\n\"  -c                 Enable cluster mode (follow -ASK and -MOVED redirections).\\n\"\n\"  --raw              Use raw formatting for replies (default when STDOUT is\\n\"\n\"                     not a tty).\\n\"\n\"  --no-raw           Force formatted output even when STDOUT is not a tty.\\n\"\n\"  --csv              Output in CSV format.\\n\"\n\"  --stat             Print rolling stats about server: mem, clients, ...\\n\"\n\"  --latency          Enter a special mode continuously sampling latency.\\n\"\n\"                     If you use this mode in an interactive session it runs\\n\"\n\"                     forever displaying real-time stats. Otherwise if --raw or\\n\"\n\"                     --csv is specified, or if you redirect the output to a non\\n\"\n\"                     TTY, it samples the latency for 1 second (you can use\\n\"\n\"                     -i to change the interval), then produces a single output\\n\"\n\"                     and exits.\\n\"\n\"  --latency-history  Like --latency but tracking latency changes over time.\\n\"\n\"                     Default time interval is 15 sec. Change it using -i.\\n\"\n\"  --latency-dist     Shows latency as a spectrum, requires xterm 256 colors.\\n\"\n\"                     Default time interval is 1 sec. Change it using -i.\\n\"\n\"  --lru-test <keys>  Simulate a cache workload with an 80-20 distribution.\\n\"\n\"  --slave            Simulate a slave showing commands received from the master.\\n\"\n\"  --rdb <filename>   Transfer an RDB dump from remote server to local file.\\n\"\n\"  --pipe             Transfer raw Redis protocol from stdin to server.\\n\"\n\"  --pipe-timeout <n> In --pipe mode, abort with error if after sending all data.\\n\"\n\"                     no reply is received within <n> seconds.\\n\"\n\"                     Default timeout: %d. Use 0 to wait forever.\\n\"\n\"  --bigkeys          Sample Redis keys looking for big keys.\\n\"\n\"  --hotkeys          Sample Redis keys looking for hot keys.\\n\"\n\"                     only works when maxmemory-policy is *lfu.\\n\"\n\"  --scan             List all keys using the SCAN command.\\n\"\n\"  --pattern <pat>    Useful with --scan to specify a SCAN pattern.\\n\"\n\"  --intrinsic-latency <sec> Run a test to measure intrinsic system latency.\\n\"\n\"                     The test will run for the specified amount of seconds.\\n\"\n\"  --eval <file>      Send an EVAL command using the Lua script at <file>.\\n\"\n\"  --ldb              Used with --eval enable the Redis Lua debugger.\\n\"\n\"  --ldb-sync-mode    Like --ldb but uses the synchronous Lua debugger, in\\n\"\n\"                     this mode the server is blocked and script changes are\\n\"\n\"                     are not rolled back from the server memory.\\n\"\n\"  --help             Output this help and exit.\\n\"\n\"  --version          Output version and exit.\\n\"\n\"\\n\"\n\"Examples:\\n\"\n\"  cat /etc/passwd | redis-cli -x set mypasswd\\n\"\n\"  redis-cli get mypasswd\\n\"\n\"  redis-cli -r 100 lpush mylist x\\n\"\n\"  redis-cli -r 100 -i 1 info | grep used_memory_human:\\n\"\n\"  redis-cli --eval myscript.lua key1 key2 , arg1 arg2 arg3\\n\"\n\"  redis-cli --scan --pattern '*:12345*'\\n\"\n\"\\n\"\n\"  (Note: when using --eval the comma separates KEYS[] from ARGV[] items)\\n\"\n\"\\n\"\n\"When no command is given, redis-cli starts in interactive mode.\\n\"\n\"Type \\\"help\\\" in interactive mode for information on available commands\\n\"\n\"and settings.\\n\"\n\"\\n\",\n        version, REDIS_CLI_DEFAULT_PIPE_TIMEOUT);\n    sdsfree(version);\n    exit(1);\n}\n\n/* Turn the plain C strings into Sds strings */\nstatic char **convertToSds(int count, char** args) {\n  int j;\n  char **sds = zmalloc(sizeof(char*)*count);\n\n  for(j = 0; j < count; j++)\n    sds[j] = sdsnew(args[j]);\n\n  return sds;\n}\n\nstatic int issueCommandRepeat(int argc, char **argv, long repeat) {\n    while (1) {\n        config.cluster_reissue_command = 0;\n        if (cliSendCommand(argc,argv,repeat) != REDIS_OK) {\n            cliConnect(1);\n\n            /* If we still cannot send the command print error.\n             * We'll try to reconnect the next time. */\n            if (cliSendCommand(argc,argv,repeat) != REDIS_OK) {\n                cliPrintContextError();\n                return REDIS_ERR;\n            }\n         }\n         /* Issue the command again if we got redirected in cluster mode */\n         if (config.cluster_mode && config.cluster_reissue_command) {\n            cliConnect(1);\n         } else {\n             break;\n        }\n    }\n    return REDIS_OK;\n}\n\nstatic int issueCommand(int argc, char **argv) {\n    return issueCommandRepeat(argc, argv, config.repeat);\n}\n\n/* Split the user provided command into multiple SDS arguments.\n * This function normally uses sdssplitargs() from sds.c which is able\n * to understand \"quoted strings\", escapes and so forth. However when\n * we are in Lua debugging mode and the \"eval\" command is used, we want\n * the remaining Lua script (after \"e \" or \"eval \") to be passed verbatim\n * as a single big argument. */\nstatic sds *cliSplitArgs(char *line, int *argc) {\n    if (config.eval_ldb && (strstr(line,\"eval \") == line ||\n                            strstr(line,\"e \") == line))\n    {\n        sds *argv = sds_malloc(sizeof(sds)*2);\n        *argc = 2;\n        int len = strlen(line);\n        int elen = line[1] == ' ' ? 2 : 5; /* \"e \" or \"eval \"? */\n        argv[0] = sdsnewlen(line,elen-1);\n        argv[1] = sdsnewlen(line+elen,len-elen);\n        return argv;\n    } else {\n        return sdssplitargs(line,argc);\n    }\n}\n\n/* Set the CLI preferences. This function is invoked when an interactive\n * \":command\" is called, or when reading ~/.redisclirc file, in order to\n * set user preferences. */\nvoid cliSetPreferences(char **argv, int argc, int interactive) {\n    if (!strcasecmp(argv[0],\":set\") && argc >= 2) {\n        if (!strcasecmp(argv[1],\"hints\")) pref.hints = 1;\n        else if (!strcasecmp(argv[1],\"nohints\")) pref.hints = 0;\n        else {\n            printf(\"%sunknown redis-cli preference '%s'\\n\",\n                interactive ? \"\" : \".redisclirc: \",\n                argv[1]);\n        }\n    } else {\n        printf(\"%sunknown redis-cli internal command '%s'\\n\",\n            interactive ? \"\" : \".redisclirc: \",\n            argv[0]);\n    }\n}\n\n/* Load the ~/.redisclirc file if any. */\nvoid cliLoadPreferences(void) {\n    sds rcfile = getDotfilePath(REDIS_CLI_RCFILE_ENV,REDIS_CLI_RCFILE_DEFAULT);\n    if (rcfile == NULL) return;\n    FILE *fp = fopen(rcfile,\"r\");\n    char buf[1024];\n\n    if (fp) {\n        while(fgets(buf,sizeof(buf),fp) != NULL) {\n            sds *argv;\n            int argc;\n\n            argv = sdssplitargs(buf,&argc);\n            if (argc > 0) cliSetPreferences(argv,argc,0);\n            sdsfreesplitres(argv,argc);\n        }\n        fclose(fp);\n    }\n    sdsfree(rcfile);\n}\n\nstatic void repl(void) {\n    sds historyfile = NULL;\n    int history = 0;\n    char *line;\n    int argc;\n    sds *argv;\n\n    /* Initialize the help and, if possible, use the COMMAND command in order\n     * to retrieve missing entries. */\n    cliInitHelp();\n    cliIntegrateHelp();\n\n    config.interactive = 1;\n    linenoiseSetMultiLine(1);\n    linenoiseSetCompletionCallback(completionCallback);\n    linenoiseSetHintsCallback(hintsCallback);\n    linenoiseSetFreeHintsCallback(freeHintsCallback);\n\n    /* Only use history and load the rc file when stdin is a tty. */\n    if (isatty(fileno(stdin))) {\n        historyfile = getDotfilePath(REDIS_CLI_HISTFILE_ENV,REDIS_CLI_HISTFILE_DEFAULT);\n        //keep in-memory history always regardless if history file can be determined\n        history = 1;\n        if (historyfile != NULL) {\n            linenoiseHistoryLoad(historyfile);\n        }\n        cliLoadPreferences();\n    }\n\n    cliRefreshPrompt();\n    while((line = linenoise(context ? config.prompt : \"not connected> \")) != NULL) {\n        if (line[0] != '\\0') {\n            long repeat = 1;\n            int skipargs = 0;\n            char *endptr = NULL;\n\n            argv = cliSplitArgs(line,&argc);\n\n            /* check if we have a repeat command option and\n             * need to skip the first arg */\n            if (argv && argc > 0) {\n                errno = 0;\n                repeat = strtol(argv[0], &endptr, 10);\n                if (argc > 1 && *endptr == '\\0') {\n                    if (errno == ERANGE || errno == EINVAL || repeat <= 0) {\n                        fputs(\"Invalid redis-cli repeat command option value.\\n\", stdout);\n                        sdsfreesplitres(argv, argc);\n                        linenoiseFree(line);\n                        continue;\n                    }\n                    skipargs = 1;\n                } else {\n                    repeat = 1;\n                }\n            }\n\n            /* Won't save auth command in history file */\n            if (!(argv && argc > 0 && !strcasecmp(argv[0+skipargs], \"auth\"))) {\n                if (history) linenoiseHistoryAdd(line);\n                if (historyfile) linenoiseHistorySave(historyfile);\n            }\n\n            if (argv == NULL) {\n                printf(\"Invalid argument(s)\\n\");\n                linenoiseFree(line);\n                continue;\n            } else if (argc > 0) {\n                if (strcasecmp(argv[0],\"quit\") == 0 ||\n                    strcasecmp(argv[0],\"exit\") == 0)\n                {\n                    exit(0);\n                } else if (argv[0][0] == ':') {\n                    cliSetPreferences(argv,argc,1);\n                    sdsfreesplitres(argv,argc);\n                    linenoiseFree(line);\n                    continue;\n                } else if (strcasecmp(argv[0],\"restart\") == 0) {\n                    if (config.eval) {\n                        config.eval_ldb = 1;\n                        config.output = OUTPUT_RAW;\n                        return; /* Return to evalMode to restart the session. */\n                    } else {\n                        printf(\"Use 'restart' only in Lua debugging mode.\");\n                    }\n                } else if (argc == 3 && !strcasecmp(argv[0],\"connect\")) {\n                    sdsfree(config.hostip);\n                    config.hostip = sdsnew(argv[1]);\n                    config.hostport = atoi(argv[2]);\n                    cliRefreshPrompt();\n                    cliConnect(1);\n                } else if (argc == 1 && !strcasecmp(argv[0],\"clear\")) {\n                    linenoiseClearScreen();\n                } else {\n                    long long start_time = mstime(), elapsed;\n\n                    issueCommandRepeat(argc-skipargs, argv+skipargs, repeat);\n\n                    /* If our debugging session ended, show the EVAL final\n                     * reply. */\n                    if (config.eval_ldb_end) {\n                        config.eval_ldb_end = 0;\n                        cliReadReply(0);\n                        printf(\"\\n(Lua debugging session ended%s)\\n\\n\",\n                            config.eval_ldb_sync ? \"\" :\n                            \" -- dataset changes rolled back\");\n                    }\n\n                    elapsed = mstime()-start_time;\n                    if (elapsed >= 500 &&\n                        config.output == OUTPUT_STANDARD)\n                    {\n                        printf(\"(%.2fs)\\n\",(double)elapsed/1000);\n                    }\n                }\n            }\n            /* Free the argument vector */\n            sdsfreesplitres(argv,argc);\n        }\n        /* linenoise() returns malloc-ed lines like readline() */\n        linenoiseFree(line);\n    }\n    exit(0);\n}\n\nstatic int noninteractive(int argc, char **argv) {\n    int retval = 0;\n    if (config.stdinarg) {\n        argv = zrealloc(argv, (argc+1)*sizeof(char*));\n        argv[argc] = readArgFromStdin();\n        retval = issueCommand(argc+1, argv);\n    } else {\n        retval = issueCommand(argc, argv);\n    }\n    return retval;\n}\n\n/*------------------------------------------------------------------------------\n * Eval mode\n *--------------------------------------------------------------------------- */\n\nstatic int evalMode(int argc, char **argv) {\n    sds script = NULL;\n    FILE *fp;\n    char buf[1024];\n    size_t nread;\n    char **argv2;\n    int j, got_comma, keys;\n    int retval = REDIS_OK;\n\n    while(1) {\n        if (config.eval_ldb) {\n            printf(\n            \"Lua debugging session started, please use:\\n\"\n            \"quit    -- End the session.\\n\"\n            \"restart -- Restart the script in debug mode again.\\n\"\n            \"help    -- Show Lua script debugging commands.\\n\\n\"\n            );\n        }\n\n        sdsfree(script);\n        script = sdsempty();\n        got_comma = 0;\n        keys = 0;\n\n        /* Load the script from the file, as an sds string. */\n        fp = fopen(config.eval,\"r\");\n        if (!fp) {\n            fprintf(stderr,\n                \"Can't open file '%s': %s\\n\", config.eval, strerror(errno));\n            exit(1);\n        }\n        while((nread = fread(buf,1,sizeof(buf),fp)) != 0) {\n            script = sdscatlen(script,buf,nread);\n        }\n        fclose(fp);\n\n        /* If we are debugging a script, enable the Lua debugger. */\n        if (config.eval_ldb) {\n            redisReply *reply = redisCommand(context,\n                    config.eval_ldb_sync ?\n                    \"SCRIPT DEBUG sync\": \"SCRIPT DEBUG yes\");\n            if (reply) freeReplyObject(reply);\n        }\n\n        /* Create our argument vector */\n        argv2 = zmalloc(sizeof(sds)*(argc+3));\n        argv2[0] = sdsnew(\"EVAL\");\n        argv2[1] = script;\n        for (j = 0; j < argc; j++) {\n            if (!got_comma && argv[j][0] == ',' && argv[j][1] == 0) {\n                got_comma = 1;\n                continue;\n            }\n            argv2[j+3-got_comma] = sdsnew(argv[j]);\n            if (!got_comma) keys++;\n        }\n        argv2[2] = sdscatprintf(sdsempty(),\"%d\",keys);\n\n        /* Call it */\n        int eval_ldb = config.eval_ldb; /* Save it, may be reverteed. */\n        retval = issueCommand(argc+3-got_comma, argv2);\n        if (eval_ldb) {\n            if (!config.eval_ldb) {\n                /* If the debugging session ended immediately, there was an\n                 * error compiling the script. Show it and don't enter\n                 * the REPL at all. */\n                printf(\"Eval debugging session can't start:\\n\");\n                cliReadReply(0);\n                break; /* Return to the caller. */\n            } else {\n                strncpy(config.prompt,\"lua debugger> \",sizeof(config.prompt));\n                repl();\n                /* Restart the session if repl() returned. */\n                cliConnect(1);\n                printf(\"\\n\");\n            }\n        } else {\n            break; /* Return to the caller. */\n        }\n    }\n    return retval;\n}\n\n/*------------------------------------------------------------------------------\n * Latency and latency history modes\n *--------------------------------------------------------------------------- */\n\nstatic void latencyModePrint(long long min, long long max, double avg, long long count) {\n    if (config.output == OUTPUT_STANDARD) {\n        printf(\"min: %lld, max: %lld, avg: %.2f (%lld samples)\",\n                min, max, avg, count);\n        fflush(stdout);\n    } else if (config.output == OUTPUT_CSV) {\n        printf(\"%lld,%lld,%.2f,%lld\\n\", min, max, avg, count);\n    } else if (config.output == OUTPUT_RAW) {\n        printf(\"%lld %lld %.2f %lld\\n\", min, max, avg, count);\n    }\n}\n\n#define LATENCY_SAMPLE_RATE 10 /* milliseconds. */\n#define LATENCY_HISTORY_DEFAULT_INTERVAL 15000 /* milliseconds. */\nstatic void latencyMode(void) {\n    redisReply *reply;\n    long long start, latency, min = 0, max = 0, tot = 0, count = 0;\n    long long history_interval =\n        config.interval ? config.interval/1000 :\n                          LATENCY_HISTORY_DEFAULT_INTERVAL;\n    double avg;\n    long long history_start = mstime();\n\n    /* Set a default for the interval in case of --latency option\n     * with --raw, --csv or when it is redirected to non tty. */\n    if (config.interval == 0) {\n        config.interval = 1000;\n    } else {\n        config.interval /= 1000; /* We need to convert to milliseconds. */\n    }\n\n    if (!context) exit(1);\n    while(1) {\n        start = mstime();\n        reply = reconnectingRedisCommand(context,\"PING\");\n        if (reply == NULL) {\n            fprintf(stderr,\"\\nI/O error\\n\");\n            exit(1);\n        }\n        latency = mstime()-start;\n        freeReplyObject(reply);\n        count++;\n        if (count == 1) {\n            min = max = tot = latency;\n            avg = (double) latency;\n        } else {\n            if (latency < min) min = latency;\n            if (latency > max) max = latency;\n            tot += latency;\n            avg = (double) tot/count;\n        }\n\n        if (config.output == OUTPUT_STANDARD) {\n            printf(\"\\x1b[0G\\x1b[2K\"); /* Clear the line. */\n            latencyModePrint(min,max,avg,count);\n        } else {\n            if (config.latency_history) {\n                latencyModePrint(min,max,avg,count);\n            } else if (mstime()-history_start > config.interval) {\n                latencyModePrint(min,max,avg,count);\n                exit(0);\n            }\n        }\n\n        if (config.latency_history && mstime()-history_start > history_interval)\n        {\n            printf(\" -- %.2f seconds range\\n\", (float)(mstime()-history_start)/1000);\n            history_start = mstime();\n            min = max = tot = count = 0;\n        }\n        usleep(LATENCY_SAMPLE_RATE * 1000);\n    }\n}\n\n/*------------------------------------------------------------------------------\n * Latency distribution mode -- requires 256 colors xterm\n *--------------------------------------------------------------------------- */\n\n#define LATENCY_DIST_DEFAULT_INTERVAL 1000 /* milliseconds. */\n\n/* Structure to store samples distribution. */\nstruct distsamples {\n    long long max;   /* Max latency to fit into this interval (usec). */\n    long long count; /* Number of samples in this interval. */\n    int character;   /* Associated character in visualization. */\n};\n\n/* Helper function for latencyDistMode(). Performs the spectrum visualization\n * of the collected samples targeting an xterm 256 terminal.\n *\n * Takes an array of distsamples structures, ordered from smaller to bigger\n * 'max' value. Last sample max must be 0, to mean that it olds all the\n * samples greater than the previous one, and is also the stop sentinel.\n *\n * \"tot' is the total number of samples in the different buckets, so it\n * is the SUM(samples[i].conut) for i to 0 up to the max sample.\n *\n * As a side effect the function sets all the buckets count to 0. */\nvoid showLatencyDistSamples(struct distsamples *samples, long long tot) {\n    int j;\n\n     /* We convert samples into a index inside the palette\n     * proportional to the percentage a given bucket represents.\n     * This way intensity of the different parts of the spectrum\n     * don't change relative to the number of requests, which avoids to\n     * pollute the visualization with non-latency related info. */\n    printf(\"\\033[38;5;0m\"); /* Set foreground color to black. */\n    for (j = 0; ; j++) {\n        int coloridx =\n            ceil((float) samples[j].count / tot * (spectrum_palette_size-1));\n        int color = spectrum_palette[coloridx];\n        printf(\"\\033[48;5;%dm%c\", (int)color, samples[j].character);\n        samples[j].count = 0;\n        if (samples[j].max == 0) break; /* Last sample. */\n    }\n    printf(\"\\033[0m\\n\");\n    fflush(stdout);\n}\n\n/* Show the legend: different buckets values and colors meaning, so\n * that the spectrum is more easily readable. */\nvoid showLatencyDistLegend(void) {\n    int j;\n\n    printf(\"---------------------------------------------\\n\");\n    printf(\". - * #          .01 .125 .25 .5 milliseconds\\n\");\n    printf(\"1,2,3,...,9      from 1 to 9     milliseconds\\n\");\n    printf(\"A,B,C,D,E        10,20,30,40,50  milliseconds\\n\");\n    printf(\"F,G,H,I,J        .1,.2,.3,.4,.5       seconds\\n\");\n    printf(\"K,L,M,N,O,P,Q,?  1,2,4,8,16,30,60,>60 seconds\\n\");\n    printf(\"From 0 to 100%%: \");\n    for (j = 0; j < spectrum_palette_size; j++) {\n        printf(\"\\033[48;5;%dm \", spectrum_palette[j]);\n    }\n    printf(\"\\033[0m\\n\");\n    printf(\"---------------------------------------------\\n\");\n}\n\nstatic void latencyDistMode(void) {\n    redisReply *reply;\n    long long start, latency, count = 0;\n    long long history_interval =\n        config.interval ? config.interval/1000 :\n                          LATENCY_DIST_DEFAULT_INTERVAL;\n    long long history_start = ustime();\n    int j, outputs = 0;\n\n    struct distsamples samples[] = {\n        /* We use a mostly logarithmic scale, with certain linear intervals\n         * which are more interesting than others, like 1-10 milliseconds\n         * range. */\n        {10,0,'.'},         /* 0.01 ms */\n        {125,0,'-'},        /* 0.125 ms */\n        {250,0,'*'},        /* 0.25 ms */\n        {500,0,'#'},        /* 0.5 ms */\n        {1000,0,'1'},       /* 1 ms */\n        {2000,0,'2'},       /* 2 ms */\n        {3000,0,'3'},       /* 3 ms */\n        {4000,0,'4'},       /* 4 ms */\n        {5000,0,'5'},       /* 5 ms */\n        {6000,0,'6'},       /* 6 ms */\n        {7000,0,'7'},       /* 7 ms */\n        {8000,0,'8'},       /* 8 ms */\n        {9000,0,'9'},       /* 9 ms */\n        {10000,0,'A'},      /* 10 ms */\n        {20000,0,'B'},      /* 20 ms */\n        {30000,0,'C'},      /* 30 ms */\n        {40000,0,'D'},      /* 40 ms */\n        {50000,0,'E'},      /* 50 ms */\n        {100000,0,'F'},     /* 0.1 s */\n        {200000,0,'G'},     /* 0.2 s */\n        {300000,0,'H'},     /* 0.3 s */\n        {400000,0,'I'},     /* 0.4 s */\n        {500000,0,'J'},     /* 0.5 s */\n        {1000000,0,'K'},    /* 1 s */\n        {2000000,0,'L'},    /* 2 s */\n        {4000000,0,'M'},    /* 4 s */\n        {8000000,0,'N'},    /* 8 s */\n        {16000000,0,'O'},   /* 16 s */\n        {30000000,0,'P'},   /* 30 s */\n        {60000000,0,'Q'},   /* 1 minute */\n        {0,0,'?'},          /* > 1 minute */\n    };\n\n    if (!context) exit(1);\n    while(1) {\n        start = ustime();\n        reply = reconnectingRedisCommand(context,\"PING\");\n        if (reply == NULL) {\n            fprintf(stderr,\"\\nI/O error\\n\");\n            exit(1);\n        }\n        latency = ustime()-start;\n        freeReplyObject(reply);\n        count++;\n\n        /* Populate the relevant bucket. */\n        for (j = 0; ; j++) {\n            if (samples[j].max == 0 || latency <= samples[j].max) {\n                samples[j].count++;\n                break;\n            }\n        }\n\n        /* From time to time show the spectrum. */\n        if (count && (ustime()-history_start)/1000 > history_interval) {\n            if ((outputs++ % 20) == 0)\n                showLatencyDistLegend();\n            showLatencyDistSamples(samples,count);\n            history_start = ustime();\n            count = 0;\n        }\n        usleep(LATENCY_SAMPLE_RATE * 1000);\n    }\n}\n\n/*------------------------------------------------------------------------------\n * Slave mode\n *--------------------------------------------------------------------------- */\n\n/* Sends SYNC and reads the number of bytes in the payload. Used both by\n * slaveMode() and getRDB(). */\nunsigned long long sendSync(int fd) {\n    /* To start we need to send the SYNC command and return the payload.\n     * The hiredis client lib does not understand this part of the protocol\n     * and we don't want to mess with its buffers, so everything is performed\n     * using direct low-level I/O. */\n    char buf[4096], *p;\n    ssize_t nread;\n\n    /* Send the SYNC command. */\n    if (write(fd,\"SYNC\\r\\n\",6) != 6) {\n        fprintf(stderr,\"Error writing to master\\n\");\n        exit(1);\n    }\n\n    /* Read $<payload>\\r\\n, making sure to read just up to \"\\n\" */\n    p = buf;\n    while(1) {\n        nread = read(fd,p,1);\n        if (nread <= 0) {\n            fprintf(stderr,\"Error reading bulk length while SYNCing\\n\");\n            exit(1);\n        }\n        if (*p == '\\n' && p != buf) break;\n        if (*p != '\\n') p++;\n    }\n    *p = '\\0';\n    if (buf[0] == '-') {\n        printf(\"SYNC with master failed: %s\\n\", buf);\n        exit(1);\n    }\n    return strtoull(buf+1,NULL,10);\n}\n\nstatic void slaveMode(void) {\n    int fd = context->fd;\n    unsigned long long payload = sendSync(fd);\n    char buf[1024];\n    int original_output = config.output;\n\n    fprintf(stderr,\"SYNC with master, discarding %llu \"\n                   \"bytes of bulk transfer...\\n\", payload);\n\n    /* Discard the payload. */\n    while(payload) {\n        ssize_t nread;\n\n        nread = read(fd,buf,(payload > sizeof(buf)) ? sizeof(buf) : payload);\n        if (nread <= 0) {\n            fprintf(stderr,\"Error reading RDB payload while SYNCing\\n\");\n            exit(1);\n        }\n        payload -= nread;\n    }\n    fprintf(stderr,\"SYNC done. Logging commands from master.\\n\");\n\n    /* Now we can use hiredis to read the incoming protocol. */\n    config.output = OUTPUT_CSV;\n    while (cliReadReply(0) == REDIS_OK);\n    config.output = original_output;\n}\n\n/*------------------------------------------------------------------------------\n * RDB transfer mode\n *--------------------------------------------------------------------------- */\n\n/* This function implements --rdb, so it uses the replication protocol in order\n * to fetch the RDB file from a remote server. */\nstatic void getRDB(void) {\n    int s = context->fd;\n    int fd;\n    unsigned long long payload = sendSync(s);\n    char buf[4096];\n\n    fprintf(stderr,\"SYNC sent to master, writing %llu bytes to '%s'\\n\",\n        payload, config.rdb_filename);\n\n    /* Write to file. */\n    if (!strcmp(config.rdb_filename,\"-\")) {\n        fd = STDOUT_FILENO;\n    } else {\n        fd = open(config.rdb_filename, O_CREAT|O_WRONLY, 0644);\n        if (fd == -1) {\n            fprintf(stderr, \"Error opening '%s': %s\\n\", config.rdb_filename,\n                strerror(errno));\n            exit(1);\n        }\n    }\n\n    while(payload) {\n        ssize_t nread, nwritten;\n\n        nread = read(s,buf,(payload > sizeof(buf)) ? sizeof(buf) : payload);\n        if (nread <= 0) {\n            fprintf(stderr,\"I/O Error reading RDB payload from socket\\n\");\n            exit(1);\n        }\n        nwritten = write(fd, buf, nread);\n        if (nwritten != nread) {\n            fprintf(stderr,\"Error writing data to file: %s\\n\",\n                strerror(errno));\n            exit(1);\n        }\n        payload -= nread;\n    }\n    close(s); /* Close the file descriptor ASAP as fsync() may take time. */\n    fsync(fd);\n    fprintf(stderr,\"Transfer finished with success.\\n\");\n    exit(0);\n}\n\n/*------------------------------------------------------------------------------\n * Bulk import (pipe) mode\n *--------------------------------------------------------------------------- */\n\n#define PIPEMODE_WRITE_LOOP_MAX_BYTES (128*1024)\nstatic void pipeMode(void) {\n    int fd = context->fd;\n    long long errors = 0, replies = 0, obuf_len = 0, obuf_pos = 0;\n    char ibuf[1024*16], obuf[1024*16]; /* Input and output buffers */\n    char aneterr[ANET_ERR_LEN];\n    redisReader *reader = redisReaderCreate();\n    redisReply *reply;\n    int eof = 0; /* True once we consumed all the standard input. */\n    int done = 0;\n    char magic[20]; /* Special reply we recognize. */\n    time_t last_read_time = time(NULL);\n\n    srand(time(NULL));\n\n    /* Use non blocking I/O. */\n    if (anetNonBlock(aneterr,fd) == ANET_ERR) {\n        fprintf(stderr, \"Can't set the socket in non blocking mode: %s\\n\",\n            aneterr);\n        exit(1);\n    }\n\n    /* Transfer raw protocol and read replies from the server at the same\n     * time. */\n    while(!done) {\n        int mask = AE_READABLE;\n\n        if (!eof || obuf_len != 0) mask |= AE_WRITABLE;\n        mask = aeWait(fd,mask,1000);\n\n        /* Handle the readable state: we can read replies from the server. */\n        if (mask & AE_READABLE) {\n            ssize_t nread;\n\n            /* Read from socket and feed the hiredis reader. */\n            do {\n                nread = read(fd,ibuf,sizeof(ibuf));\n                if (nread == -1 && errno != EAGAIN && errno != EINTR) {\n                    fprintf(stderr, \"Error reading from the server: %s\\n\",\n                        strerror(errno));\n                    exit(1);\n                }\n                if (nread > 0) {\n                    redisReaderFeed(reader,ibuf,nread);\n                    last_read_time = time(NULL);\n                }\n            } while(nread > 0);\n\n            /* Consume replies. */\n            do {\n                if (redisReaderGetReply(reader,(void**)&reply) == REDIS_ERR) {\n                    fprintf(stderr, \"Error reading replies from server\\n\");\n                    exit(1);\n                }\n                if (reply) {\n                    if (reply->type == REDIS_REPLY_ERROR) {\n                        fprintf(stderr,\"%s\\n\", reply->str);\n                        errors++;\n                    } else if (eof && reply->type == REDIS_REPLY_STRING &&\n                                      reply->len == 20) {\n                        /* Check if this is the reply to our final ECHO\n                         * command. If so everything was received\n                         * from the server. */\n                        if (memcmp(reply->str,magic,20) == 0) {\n                            printf(\"Last reply received from server.\\n\");\n                            done = 1;\n                            replies--;\n                        }\n                    }\n                    replies++;\n                    freeReplyObject(reply);\n                }\n            } while(reply);\n        }\n\n        /* Handle the writable state: we can send protocol to the server. */\n        if (mask & AE_WRITABLE) {\n            ssize_t loop_nwritten = 0;\n\n            while(1) {\n                /* Transfer current buffer to server. */\n                if (obuf_len != 0) {\n                    ssize_t nwritten = write(fd,obuf+obuf_pos,obuf_len);\n\n                    if (nwritten == -1) {\n                        if (errno != EAGAIN && errno != EINTR) {\n                            fprintf(stderr, \"Error writing to the server: %s\\n\",\n                                strerror(errno));\n                            exit(1);\n                        } else {\n                            nwritten = 0;\n                        }\n                    }\n                    obuf_len -= nwritten;\n                    obuf_pos += nwritten;\n                    loop_nwritten += nwritten;\n                    if (obuf_len != 0) break; /* Can't accept more data. */\n                }\n                /* If buffer is empty, load from stdin. */\n                if (obuf_len == 0 && !eof) {\n                    ssize_t nread = read(STDIN_FILENO,obuf,sizeof(obuf));\n\n                    if (nread == 0) {\n                        /* The ECHO sequence starts with a \"\\r\\n\" so that if there\n                         * is garbage in the protocol we read from stdin, the ECHO\n                         * will likely still be properly formatted.\n                         * CRLF is ignored by Redis, so it has no effects. */\n                        char echo[] =\n                        \"\\r\\n*2\\r\\n$4\\r\\nECHO\\r\\n$20\\r\\n01234567890123456789\\r\\n\";\n                        int j;\n\n                        eof = 1;\n                        /* Everything transferred, so we queue a special\n                         * ECHO command that we can match in the replies\n                         * to make sure everything was read from the server. */\n                        for (j = 0; j < 20; j++)\n                            magic[j] = rand() & 0xff;\n                        memcpy(echo+21,magic,20);\n                        memcpy(obuf,echo,sizeof(echo)-1);\n                        obuf_len = sizeof(echo)-1;\n                        obuf_pos = 0;\n                        printf(\"All data transferred. Waiting for the last reply...\\n\");\n                    } else if (nread == -1) {\n                        fprintf(stderr, \"Error reading from stdin: %s\\n\",\n                            strerror(errno));\n                        exit(1);\n                    } else {\n                        obuf_len = nread;\n                        obuf_pos = 0;\n                    }\n                }\n                if ((obuf_len == 0 && eof) ||\n                    loop_nwritten > PIPEMODE_WRITE_LOOP_MAX_BYTES) break;\n            }\n        }\n\n        /* Handle timeout, that is, we reached EOF, and we are not getting\n         * replies from the server for a few seconds, nor the final ECHO is\n         * received. */\n        if (eof && config.pipe_timeout > 0 &&\n            time(NULL)-last_read_time > config.pipe_timeout)\n        {\n            fprintf(stderr,\"No replies for %d seconds: exiting.\\n\",\n                config.pipe_timeout);\n            errors++;\n            break;\n        }\n    }\n    redisReaderFree(reader);\n    printf(\"errors: %lld, replies: %lld\\n\", errors, replies);\n    if (errors)\n        exit(1);\n    else\n        exit(0);\n}\n\n/*------------------------------------------------------------------------------\n * Find big keys\n *--------------------------------------------------------------------------- */\n\n#define TYPE_STRING 0\n#define TYPE_LIST   1\n#define TYPE_SET    2\n#define TYPE_HASH   3\n#define TYPE_ZSET   4\n#define TYPE_STREAM 5\n#define TYPE_NONE   6\n#define TYPE_COUNT  7\n\nstatic redisReply *sendScan(unsigned long long *it) {\n    redisReply *reply = redisCommand(context, \"SCAN %llu\", *it);\n\n    /* Handle any error conditions */\n    if(reply == NULL) {\n        fprintf(stderr, \"\\nI/O error\\n\");\n        exit(1);\n    } else if(reply->type == REDIS_REPLY_ERROR) {\n        fprintf(stderr, \"SCAN error: %s\\n\", reply->str);\n        exit(1);\n    } else if(reply->type != REDIS_REPLY_ARRAY) {\n        fprintf(stderr, \"Non ARRAY response from SCAN!\\n\");\n        exit(1);\n    } else if(reply->elements != 2) {\n        fprintf(stderr, \"Invalid element count from SCAN!\\n\");\n        exit(1);\n    }\n\n    /* Validate our types are correct */\n    assert(reply->element[0]->type == REDIS_REPLY_STRING);\n    assert(reply->element[1]->type == REDIS_REPLY_ARRAY);\n\n    /* Update iterator */\n    *it = strtoull(reply->element[0]->str, NULL, 10);\n\n    return reply;\n}\n\nstatic int getDbSize(void) {\n    redisReply *reply;\n    int size;\n\n    reply = redisCommand(context, \"DBSIZE\");\n\n    if(reply == NULL || reply->type != REDIS_REPLY_INTEGER) {\n        fprintf(stderr, \"Couldn't determine DBSIZE!\\n\");\n        exit(1);\n    }\n\n    /* Grab the number of keys and free our reply */\n    size = reply->integer;\n    freeReplyObject(reply);\n\n    return size;\n}\n\nstatic int toIntType(char *key, char *type) {\n    if(!strcmp(type, \"string\")) {\n        return TYPE_STRING;\n    } else if(!strcmp(type, \"list\")) {\n        return TYPE_LIST;\n    } else if(!strcmp(type, \"set\")) {\n        return TYPE_SET;\n    } else if(!strcmp(type, \"hash\")) {\n        return TYPE_HASH;\n    } else if(!strcmp(type, \"zset\")) {\n        return TYPE_ZSET;\n    } else if(!strcmp(type, \"none\")) {\n        return TYPE_NONE;\n    } else {\n        fprintf(stderr, \"Unknown type '%s' for key '%s'\\n\", type, key);\n        exit(1);\n    }\n}\n\nstatic void getKeyTypes(redisReply *keys, int *types) {\n    redisReply *reply;\n    unsigned int i;\n\n    /* Pipeline TYPE commands */\n    for(i=0;i<keys->elements;i++) {\n        redisAppendCommand(context, \"TYPE %s\", keys->element[i]->str);\n    }\n\n    /* Retrieve types */\n    for(i=0;i<keys->elements;i++) {\n        if(redisGetReply(context, (void**)&reply)!=REDIS_OK) {\n            fprintf(stderr, \"Error getting type for key '%s' (%d: %s)\\n\",\n                keys->element[i]->str, context->err, context->errstr);\n            exit(1);\n        } else if(reply->type != REDIS_REPLY_STATUS) {\n            if(reply->type == REDIS_REPLY_ERROR) {\n                fprintf(stderr, \"TYPE returned an error: %s\\n\", reply->str);\n            } else {\n                fprintf(stderr,\n                    \"Invalid reply type (%d) for TYPE on key '%s'!\\n\",\n                    reply->type, keys->element[i]->str);\n            }\n            exit(1);\n        }\n\n        types[i] = toIntType(keys->element[i]->str, reply->str);\n        freeReplyObject(reply);\n    }\n}\n\nstatic void getKeySizes(redisReply *keys, int *types,\n                        unsigned long long *sizes)\n{\n    redisReply *reply;\n    char *sizecmds[] = {\"STRLEN\",\"LLEN\",\"SCARD\",\"HLEN\",\"ZCARD\"};\n    unsigned int i;\n\n    /* Pipeline size commands */\n    for(i=0;i<keys->elements;i++) {\n        /* Skip keys that were deleted */\n        if(types[i]==TYPE_NONE)\n            continue;\n\n        redisAppendCommand(context, \"%s %s\", sizecmds[types[i]],\n            keys->element[i]->str);\n    }\n\n    /* Retreive sizes */\n    for(i=0;i<keys->elements;i++) {\n        /* Skip keys that dissapeared between SCAN and TYPE */\n        if(types[i] == TYPE_NONE) {\n            sizes[i] = 0;\n            continue;\n        }\n\n        /* Retreive size */\n        if(redisGetReply(context, (void**)&reply)!=REDIS_OK) {\n            fprintf(stderr, \"Error getting size for key '%s' (%d: %s)\\n\",\n                keys->element[i]->str, context->err, context->errstr);\n            exit(1);\n        } else if(reply->type != REDIS_REPLY_INTEGER) {\n            /* Theoretically the key could have been removed and\n             * added as a different type between TYPE and SIZE */\n            fprintf(stderr,\n                \"Warning:  %s on '%s' failed (may have changed type)\\n\",\n                 sizecmds[types[i]], keys->element[i]->str);\n            sizes[i] = 0;\n        } else {\n            sizes[i] = reply->integer;\n        }\n\n        freeReplyObject(reply);\n    }\n}\n\nstatic void findBigKeys(void) {\n    unsigned long long biggest[TYPE_COUNT] = {0}, counts[TYPE_COUNT] = {0}, totalsize[TYPE_COUNT] = {0};\n    unsigned long long sampled = 0, total_keys, totlen=0, *sizes=NULL, it=0;\n    sds maxkeys[TYPE_COUNT] = {0};\n    char *typename[] = {\"string\",\"list\",\"set\",\"hash\",\"zset\",\"stream\",\"none\"};\n    char *typeunit[] = {\"bytes\",\"items\",\"members\",\"fields\",\"members\",\"entries\",\"\"};\n    redisReply *reply, *keys;\n    unsigned int arrsize=0, i;\n    int type, *types=NULL;\n    double pct;\n\n    /* Total keys pre scanning */\n    total_keys = getDbSize();\n\n    /* Status message */\n    printf(\"\\n# Scanning the entire keyspace to find biggest keys as well as\\n\");\n    printf(\"# average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec\\n\");\n    printf(\"# per 100 SCAN commands (not usually needed).\\n\\n\");\n\n    /* New up sds strings to keep track of overall biggest per type */\n    for(i=0;i<TYPE_NONE; i++) {\n        maxkeys[i] = sdsempty();\n        if(!maxkeys[i]) {\n            fprintf(stderr, \"Failed to allocate memory for largest key names!\\n\");\n            exit(1);\n        }\n    }\n\n    /* SCAN loop */\n    do {\n        /* Calculate approximate percentage completion */\n        pct = 100 * (double)sampled/total_keys;\n\n        /* Grab some keys and point to the keys array */\n        reply = sendScan(&it);\n        keys  = reply->element[1];\n\n        /* Reallocate our type and size array if we need to */\n        if(keys->elements > arrsize) {\n            types = zrealloc(types, sizeof(int)*keys->elements);\n            sizes = zrealloc(sizes, sizeof(unsigned long long)*keys->elements);\n\n            if(!types || !sizes) {\n                fprintf(stderr, \"Failed to allocate storage for keys!\\n\");\n                exit(1);\n            }\n\n            arrsize = keys->elements;\n        }\n\n        /* Retreive types and then sizes */\n        getKeyTypes(keys, types);\n        getKeySizes(keys, types, sizes);\n\n        /* Now update our stats */\n        for(i=0;i<keys->elements;i++) {\n            if((type = types[i]) == TYPE_NONE)\n                continue;\n\n            totalsize[type] += sizes[i];\n            counts[type]++;\n            totlen += keys->element[i]->len;\n            sampled++;\n\n            if(biggest[type]<sizes[i]) {\n                printf(\n                   \"[%05.2f%%] Biggest %-6s found so far '%s' with %llu %s\\n\",\n                   pct, typename[type], keys->element[i]->str, sizes[i],\n                   typeunit[type]);\n\n                /* Keep track of biggest key name for this type */\n                maxkeys[type] = sdscpy(maxkeys[type], keys->element[i]->str);\n                if(!maxkeys[type]) {\n                    fprintf(stderr, \"Failed to allocate memory for key!\\n\");\n                    exit(1);\n                }\n\n                /* Keep track of the biggest size for this type */\n                biggest[type] = sizes[i];\n            }\n\n            /* Update overall progress */\n            if(sampled % 1000000 == 0) {\n                printf(\"[%05.2f%%] Sampled %llu keys so far\\n\", pct, sampled);\n            }\n        }\n\n        /* Sleep if we've been directed to do so */\n        if(sampled && (sampled %100) == 0 && config.interval) {\n            usleep(config.interval);\n        }\n\n        freeReplyObject(reply);\n    } while(it != 0);\n\n    if(types) zfree(types);\n    if(sizes) zfree(sizes);\n\n    /* We're done */\n    printf(\"\\n-------- summary -------\\n\\n\");\n\n    printf(\"Sampled %llu keys in the keyspace!\\n\", sampled);\n    printf(\"Total key length in bytes is %llu (avg len %.2f)\\n\\n\",\n       totlen, totlen ? (double)totlen/sampled : 0);\n\n    /* Output the biggest keys we found, for types we did find */\n    for(i=0;i<TYPE_NONE;i++) {\n        if(sdslen(maxkeys[i])>0) {\n            printf(\"Biggest %6s found '%s' has %llu %s\\n\", typename[i], maxkeys[i],\n               biggest[i], typeunit[i]);\n        }\n    }\n\n    printf(\"\\n\");\n\n    for(i=0;i<TYPE_NONE;i++) {\n        printf(\"%llu %ss with %llu %s (%05.2f%% of keys, avg size %.2f)\\n\",\n           counts[i], typename[i], totalsize[i], typeunit[i],\n           sampled ? 100 * (double)counts[i]/sampled : 0,\n           counts[i] ? (double)totalsize[i]/counts[i] : 0);\n    }\n\n    /* Free sds strings containing max keys */\n    for(i=0;i<TYPE_NONE;i++) {\n        sdsfree(maxkeys[i]);\n    }\n\n    /* Success! */\n    exit(0);\n}\n\nstatic void getKeyFreqs(redisReply *keys, unsigned long long *freqs) {\n    redisReply *reply;\n    unsigned int i;\n\n    /* Pipeline OBJECT freq commands */\n    for(i=0;i<keys->elements;i++) {\n        redisAppendCommand(context, \"OBJECT freq %s\", keys->element[i]->str);\n    }\n\n    /* Retrieve freqs */\n    for(i=0;i<keys->elements;i++) {\n        if(redisGetReply(context, (void**)&reply)!=REDIS_OK) {\n            fprintf(stderr, \"Error getting freq for key '%s' (%d: %s)\\n\",\n                keys->element[i]->str, context->err, context->errstr);\n            exit(1);\n        } else if(reply->type != REDIS_REPLY_INTEGER) {\n            if(reply->type == REDIS_REPLY_ERROR) {\n                fprintf(stderr, \"Error: %s\\n\", reply->str);\n                exit(1);\n            } else {\n                fprintf(stderr, \"Warning: OBJECT freq on '%s' failed (may have been deleted)\\n\", keys->element[i]->str);\n                freqs[i] = 0;\n            }\n        } else {\n            freqs[i] = reply->integer;\n        }\n        freeReplyObject(reply);\n    }\n}\n\n#define HOTKEYS_SAMPLE 16\nstatic void findHotKeys(void) {\n    redisReply *keys, *reply;\n    unsigned long long counters[HOTKEYS_SAMPLE] = {0};\n    sds hotkeys[HOTKEYS_SAMPLE] = {NULL};\n    unsigned long long sampled = 0, total_keys, *freqs = NULL, it = 0;\n    unsigned int arrsize = 0, i, k;\n    double pct;\n\n    /* Total keys pre scanning */\n    total_keys = getDbSize();\n\n    /* Status message */\n    printf(\"\\n# Scanning the entire keyspace to find hot keys as well as\\n\");\n    printf(\"# average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec\\n\");\n    printf(\"# per 100 SCAN commands (not usually needed).\\n\\n\");\n\n    /* SCAN loop */\n    do {\n        /* Calculate approximate percentage completion */\n        pct = 100 * (double)sampled/total_keys;\n\n        /* Grab some keys and point to the keys array */\n        reply = sendScan(&it);\n        keys  = reply->element[1];\n\n        /* Reallocate our freqs array if we need to */\n        if(keys->elements > arrsize) {\n            freqs = zrealloc(freqs, sizeof(unsigned long long)*keys->elements);\n\n            if(!freqs) {\n                fprintf(stderr, \"Failed to allocate storage for keys!\\n\");\n                exit(1);\n            }\n\n            arrsize = keys->elements;\n        }\n\n        getKeyFreqs(keys, freqs);\n\n        /* Now update our stats */\n        for(i=0;i<keys->elements;i++) {\n            sampled++;\n            /* Update overall progress */\n            if(sampled % 1000000 == 0) {\n                printf(\"[%05.2f%%] Sampled %llu keys so far\\n\", pct, sampled);\n            }\n\n            /* Use eviction pool here */\n            k = 0;\n            while (k < HOTKEYS_SAMPLE && freqs[i] > counters[k]) k++;\n            if (k == 0) continue;\n            k--;\n            if (k == 0 || counters[k] == 0) {\n                sdsfree(hotkeys[k]);\n            } else {\n                sdsfree(hotkeys[0]);\n                memmove(counters,counters+1,sizeof(counters[0])*k);\n                memmove(hotkeys,hotkeys+1,sizeof(hotkeys[0])*k);\n            }\n            counters[k] = freqs[i];\n            hotkeys[k] = sdsnew(keys->element[i]->str);\n            printf(\n               \"[%05.2f%%] Hot key '%s' found so far with counter %llu\\n\",\n               pct, keys->element[i]->str, freqs[i]);\n        }\n\n        /* Sleep if we've been directed to do so */\n        if(sampled && (sampled %100) == 0 && config.interval) {\n            usleep(config.interval);\n        }\n\n        freeReplyObject(reply);\n    } while(it != 0);\n\n    if (freqs) zfree(freqs);\n\n    /* We're done */\n    printf(\"\\n-------- summary -------\\n\\n\");\n\n    printf(\"Sampled %llu keys in the keyspace!\\n\", sampled);\n\n    for (i=1; i<= HOTKEYS_SAMPLE; i++) {\n        k = HOTKEYS_SAMPLE - i;\n        if(counters[k]>0) {\n            printf(\"hot key found with counter: %llu\\tkeyname: %s\\n\", counters[k], hotkeys[k]);\n            sdsfree(hotkeys[k]);\n        }\n    }\n\n    exit(0);\n}\n\n/*------------------------------------------------------------------------------\n * Stats mode\n *--------------------------------------------------------------------------- */\n\n/* Return the specified INFO field from the INFO command output \"info\".\n * A new buffer is allocated for the result, that needs to be free'd.\n * If the field is not found NULL is returned. */\nstatic char *getInfoField(char *info, char *field) {\n    char *p = strstr(info,field);\n    char *n1, *n2;\n    char *result;\n\n    if (!p) return NULL;\n    p += strlen(field)+1;\n    n1 = strchr(p,'\\r');\n    n2 = strchr(p,',');\n    if (n2 && n2 < n1) n1 = n2;\n    result = zmalloc(sizeof(char)*(n1-p)+1);\n    memcpy(result,p,(n1-p));\n    result[n1-p] = '\\0';\n    return result;\n}\n\n/* Like the above function but automatically convert the result into\n * a long. On error (missing field) LONG_MIN is returned. */\nstatic long getLongInfoField(char *info, char *field) {\n    char *value = getInfoField(info,field);\n    long l;\n\n    if (!value) return LONG_MIN;\n    l = strtol(value,NULL,10);\n    zfree(value);\n    return l;\n}\n\n/* Convert number of bytes into a human readable string of the form:\n * 100B, 2G, 100M, 4K, and so forth. */\nvoid bytesToHuman(char *s, long long n) {\n    double d;\n\n    if (n < 0) {\n        *s = '-';\n        s++;\n        n = -n;\n    }\n    if (n < 1024) {\n        /* Bytes */\n        sprintf(s,\"%lldB\",n);\n        return;\n    } else if (n < (1024*1024)) {\n        d = (double)n/(1024);\n        sprintf(s,\"%.2fK\",d);\n    } else if (n < (1024LL*1024*1024)) {\n        d = (double)n/(1024*1024);\n        sprintf(s,\"%.2fM\",d);\n    } else if (n < (1024LL*1024*1024*1024)) {\n        d = (double)n/(1024LL*1024*1024);\n        sprintf(s,\"%.2fG\",d);\n    }\n}\n\nstatic void statMode(void) {\n    redisReply *reply;\n    long aux, requests = 0;\n    int i = 0;\n\n    while(1) {\n        char buf[64];\n        int j;\n\n        reply = reconnectingRedisCommand(context,\"INFO\");\n        if (reply->type == REDIS_REPLY_ERROR) {\n            printf(\"ERROR: %s\\n\", reply->str);\n            exit(1);\n        }\n\n        if ((i++ % 20) == 0) {\n            printf(\n\"------- data ------ --------------------- load -------------------- - child -\\n\"\n\"keys       mem      clients blocked requests            connections          \\n\");\n        }\n\n        /* Keys */\n        aux = 0;\n        for (j = 0; j < 20; j++) {\n            long k;\n\n            sprintf(buf,\"db%d:keys\",j);\n            k = getLongInfoField(reply->str,buf);\n            if (k == LONG_MIN) continue;\n            aux += k;\n        }\n        sprintf(buf,\"%ld\",aux);\n        printf(\"%-11s\",buf);\n\n        /* Used memory */\n        aux = getLongInfoField(reply->str,\"used_memory\");\n        bytesToHuman(buf,aux);\n        printf(\"%-8s\",buf);\n\n        /* Clients */\n        aux = getLongInfoField(reply->str,\"connected_clients\");\n        sprintf(buf,\"%ld\",aux);\n        printf(\" %-8s\",buf);\n\n        /* Blocked (BLPOPPING) Clients */\n        aux = getLongInfoField(reply->str,\"blocked_clients\");\n        sprintf(buf,\"%ld\",aux);\n        printf(\"%-8s\",buf);\n\n        /* Requests */\n        aux = getLongInfoField(reply->str,\"total_commands_processed\");\n        sprintf(buf,\"%ld (+%ld)\",aux,requests == 0 ? 0 : aux-requests);\n        printf(\"%-19s\",buf);\n        requests = aux;\n\n        /* Connections */\n        aux = getLongInfoField(reply->str,\"total_connections_received\");\n        sprintf(buf,\"%ld\",aux);\n        printf(\" %-12s\",buf);\n\n        /* Children */\n        aux = getLongInfoField(reply->str,\"bgsave_in_progress\");\n        aux |= getLongInfoField(reply->str,\"aof_rewrite_in_progress\") << 1;\n        aux |= getLongInfoField(reply->str,\"loading\") << 2;\n        switch(aux) {\n        case 0: break;\n        case 1:\n            printf(\"SAVE\");\n            break;\n        case 2:\n            printf(\"AOF\");\n            break;\n        case 3:\n            printf(\"SAVE+AOF\");\n            break;\n        case 4:\n            printf(\"LOAD\");\n            break;\n        }\n\n        printf(\"\\n\");\n        freeReplyObject(reply);\n        usleep(config.interval);\n    }\n}\n\n/*------------------------------------------------------------------------------\n * Scan mode\n *--------------------------------------------------------------------------- */\n\nstatic void scanMode(void) {\n    redisReply *reply;\n    unsigned long long cur = 0;\n\n    do {\n        if (config.pattern)\n            reply = redisCommand(context,\"SCAN %llu MATCH %s\",\n                cur,config.pattern);\n        else\n            reply = redisCommand(context,\"SCAN %llu\",cur);\n        if (reply == NULL) {\n            printf(\"I/O error\\n\");\n            exit(1);\n        } else if (reply->type == REDIS_REPLY_ERROR) {\n            printf(\"ERROR: %s\\n\", reply->str);\n            exit(1);\n        } else {\n            unsigned int j;\n\n            cur = strtoull(reply->element[0]->str,NULL,10);\n            for (j = 0; j < reply->element[1]->elements; j++)\n                printf(\"%s\\n\", reply->element[1]->element[j]->str);\n        }\n        freeReplyObject(reply);\n    } while(cur != 0);\n\n    exit(0);\n}\n\n/*------------------------------------------------------------------------------\n * LRU test mode\n *--------------------------------------------------------------------------- */\n\n/* Return an integer from min to max (both inclusive) using a power-law\n * distribution, depending on the value of alpha: the greater the alpha\n * the more bias towards lower values.\n *\n * With alpha = 6.2 the output follows the 80-20 rule where 20% of\n * the returned numbers will account for 80% of the frequency. */\nlong long powerLawRand(long long min, long long max, double alpha) {\n    double pl, r;\n\n    max += 1;\n    r = ((double)rand()) / RAND_MAX;\n    pl = pow(\n        ((pow(max,alpha+1) - pow(min,alpha+1))*r + pow(min,alpha+1)),\n        (1.0/(alpha+1)));\n    return (max-1-(long long)pl)+min;\n}\n\n/* Generates a key name among a set of lru_test_sample_size keys, using\n * an 80-20 distribution. */\nvoid LRUTestGenKey(char *buf, size_t buflen) {\n    snprintf(buf, buflen, \"lru:%lld\",\n        powerLawRand(1, config.lru_test_sample_size, 6.2));\n}\n\n#define LRU_CYCLE_PERIOD 1000 /* 1000 milliseconds. */\n#define LRU_CYCLE_PIPELINE_SIZE 250\nstatic void LRUTestMode(void) {\n    redisReply *reply;\n    char key[128];\n    long long start_cycle;\n    int j;\n\n    srand(time(NULL)^getpid());\n    while(1) {\n        /* Perform cycles of 1 second with 50% writes and 50% reads.\n         * We use pipelining batching writes / reads N times per cycle in order\n         * to fill the target instance easily. */\n        start_cycle = mstime();\n        long long hits = 0, misses = 0;\n        while(mstime() - start_cycle < 1000) {\n            /* Write cycle. */\n            for (j = 0; j < LRU_CYCLE_PIPELINE_SIZE; j++) {\n                char val[6];\n                val[5] = '\\0';\n                for (int i = 0; i < 5; i++) val[i] = 'A'+rand()%('z'-'A');\n                LRUTestGenKey(key,sizeof(key));\n                redisAppendCommand(context, \"SET %s %s\",key,val);\n            }\n            for (j = 0; j < LRU_CYCLE_PIPELINE_SIZE; j++)\n                redisGetReply(context, (void**)&reply);\n\n            /* Read cycle. */\n            for (j = 0; j < LRU_CYCLE_PIPELINE_SIZE; j++) {\n                LRUTestGenKey(key,sizeof(key));\n                redisAppendCommand(context, \"GET %s\",key);\n            }\n            for (j = 0; j < LRU_CYCLE_PIPELINE_SIZE; j++) {\n                if (redisGetReply(context, (void**)&reply) == REDIS_OK) {\n                    switch(reply->type) {\n                        case REDIS_REPLY_ERROR:\n                            printf(\"%s\\n\", reply->str);\n                            break;\n                        case REDIS_REPLY_NIL:\n                            misses++;\n                            break;\n                        default:\n                            hits++;\n                            break;\n                    }\n                }\n            }\n\n            if (context->err) {\n                fprintf(stderr,\"I/O error during LRU test\\n\");\n                exit(1);\n            }\n        }\n        /* Print stats. */\n        printf(\n            \"%lld Gets/sec | Hits: %lld (%.2f%%) | Misses: %lld (%.2f%%)\\n\",\n            hits+misses,\n            hits, (double)hits/(hits+misses)*100,\n            misses, (double)misses/(hits+misses)*100);\n    }\n    exit(0);\n}\n\n/*------------------------------------------------------------------------------\n * Intrisic latency mode.\n *\n * Measure max latency of a running process that does not result from\n * syscalls. Basically this software should provide an hint about how much\n * time the kernel leaves the process without a chance to run.\n *--------------------------------------------------------------------------- */\n\n/* This is just some computation the compiler can't optimize out.\n * Should run in less than 100-200 microseconds even using very\n * slow hardware. Runs in less than 10 microseconds in modern HW. */\nunsigned long compute_something_fast(void) {\n    unsigned char s[256], i, j, t;\n    int count = 1000, k;\n    unsigned long output = 0;\n\n    for (k = 0; k < 256; k++) s[k] = k;\n\n    i = 0;\n    j = 0;\n    while(count--) {\n        i++;\n        j = j + s[i];\n        t = s[i];\n        s[i] = s[j];\n        s[j] = t;\n        output += s[(s[i]+s[j])&255];\n    }\n    return output;\n}\n\nstatic void intrinsicLatencyModeStop(int s) {\n    UNUSED(s);\n    force_cancel_loop = 1;\n}\n\nstatic void intrinsicLatencyMode(void) {\n    long long test_end, run_time, max_latency = 0, runs = 0;\n\n    run_time = config.intrinsic_latency_duration*1000000;\n    test_end = ustime() + run_time;\n    signal(SIGINT, intrinsicLatencyModeStop);\n\n    while(1) {\n        long long start, end, latency;\n\n        start = ustime();\n        compute_something_fast();\n        end = ustime();\n        latency = end-start;\n        runs++;\n        if (latency <= 0) continue;\n\n        /* Reporting */\n        if (latency > max_latency) {\n            max_latency = latency;\n            printf(\"Max latency so far: %lld microseconds.\\n\", max_latency);\n        }\n\n        double avg_us = (double)run_time/runs;\n        double avg_ns = avg_us * 1e3;\n        if (force_cancel_loop || end > test_end) {\n            printf(\"\\n%lld total runs \"\n                \"(avg latency: \"\n                \"%.4f microseconds / %.2f nanoseconds per run).\\n\",\n                runs, avg_us, avg_ns);\n            printf(\"Worst run took %.0fx longer than the average latency.\\n\",\n                max_latency / avg_us);\n            exit(0);\n        }\n    }\n}\n\n/*------------------------------------------------------------------------------\n * Program main()\n *--------------------------------------------------------------------------- */\n\nint main(int argc, char **argv) {\n    int firstarg;\n\n    config.hostip = sdsnew(\"127.0.0.1\");\n    config.hostport = 6379;\n    config.hostsocket = NULL;\n    config.repeat = 1;\n    config.interval = 0;\n    config.dbnum = 0;\n    config.interactive = 0;\n    config.shutdown = 0;\n    config.monitor_mode = 0;\n    config.pubsub_mode = 0;\n    config.latency_mode = 0;\n    config.latency_dist_mode = 0;\n    config.latency_history = 0;\n    config.lru_test_mode = 0;\n    config.lru_test_sample_size = 0;\n    config.cluster_mode = 0;\n    config.slave_mode = 0;\n    config.getrdb_mode = 0;\n    config.stat_mode = 0;\n    config.scan_mode = 0;\n    config.intrinsic_latency_mode = 0;\n    config.pattern = NULL;\n    config.rdb_filename = NULL;\n    config.pipe_mode = 0;\n    config.pipe_timeout = REDIS_CLI_DEFAULT_PIPE_TIMEOUT;\n    config.bigkeys = 0;\n    config.hotkeys = 0;\n    config.stdinarg = 0;\n    config.auth = NULL;\n    config.eval = NULL;\n    config.eval_ldb = 0;\n    config.eval_ldb_end = 0;\n    config.eval_ldb_sync = 0;\n    config.enable_ldb_on_eval = 0;\n    config.last_cmd_type = -1;\n\n    pref.hints = 1;\n\n    spectrum_palette = spectrum_palette_color;\n    spectrum_palette_size = spectrum_palette_color_size;\n\n    if (!isatty(fileno(stdout)) && (getenv(\"FAKETTY\") == NULL))\n        config.output = OUTPUT_RAW;\n    else\n        config.output = OUTPUT_STANDARD;\n    config.mb_delim = sdsnew(\"\\n\");\n\n    firstarg = parseOptions(argc,argv);\n    argc -= firstarg;\n    argv += firstarg;\n\n    /* Latency mode */\n    if (config.latency_mode) {\n        if (cliConnect(0) == REDIS_ERR) exit(1);\n        latencyMode();\n    }\n\n    /* Latency distribution mode */\n    if (config.latency_dist_mode) {\n        if (cliConnect(0) == REDIS_ERR) exit(1);\n        latencyDistMode();\n    }\n\n    /* Slave mode */\n    if (config.slave_mode) {\n        if (cliConnect(0) == REDIS_ERR) exit(1);\n        slaveMode();\n    }\n\n    /* Get RDB mode. */\n    if (config.getrdb_mode) {\n        if (cliConnect(0) == REDIS_ERR) exit(1);\n        getRDB();\n    }\n\n    /* Pipe mode */\n    if (config.pipe_mode) {\n        if (cliConnect(0) == REDIS_ERR) exit(1);\n        pipeMode();\n    }\n\n    /* Find big keys */\n    if (config.bigkeys) {\n        if (cliConnect(0) == REDIS_ERR) exit(1);\n        findBigKeys();\n    }\n\n    /* Find hot keys */\n    if (config.hotkeys) {\n        if (cliConnect(0) == REDIS_ERR) exit(1);\n        findHotKeys();\n    }\n\n    /* Stat mode */\n    if (config.stat_mode) {\n        if (cliConnect(0) == REDIS_ERR) exit(1);\n        if (config.interval == 0) config.interval = 1000000;\n        statMode();\n    }\n\n    /* Scan mode */\n    if (config.scan_mode) {\n        if (cliConnect(0) == REDIS_ERR) exit(1);\n        scanMode();\n    }\n\n    /* LRU test mode */\n    if (config.lru_test_mode) {\n        if (cliConnect(0) == REDIS_ERR) exit(1);\n        LRUTestMode();\n    }\n\n    /* Intrinsic latency mode */\n    if (config.intrinsic_latency_mode) intrinsicLatencyMode();\n\n    /* Start interactive mode when no command is provided */\n    if (argc == 0 && !config.eval) {\n        /* Ignore SIGPIPE in interactive mode to force a reconnect */\n        signal(SIGPIPE, SIG_IGN);\n\n        /* Note that in repl mode we don't abort on connection error.\n         * A new attempt will be performed for every command send. */\n        cliConnect(0);\n        repl();\n    }\n\n    /* Otherwise, we have some arguments to execute */\n    if (cliConnect(0) != REDIS_OK) exit(1);\n    if (config.eval) {\n        return evalMode(argc,argv);\n    } else {\n        return noninteractive(argc,convertToSds(argc,argv));\n    }\n}\n"], "filenames": ["src/redis-cli.c"], "buggy_code_start_loc": [155], "buggy_code_end_loc": [169], "fixing_code_start_loc": [154], "fixing_code_end_loc": [174], "type": "CWE-119", "message": "Buffer overflow in redis-cli of Redis before 4.0.10 and 5.x before 5.0 RC3 allows an attacker to achieve code execution and escalate to higher privileges via a crafted command line. NOTE: It is unclear whether there are any common situations in which redis-cli is used with, for example, a -h (aka hostname) argument from an untrusted source.", "other": {"cve": {"id": "CVE-2018-12326", "sourceIdentifier": "cve@mitre.org", "published": "2018-06-17T14:29:00.260", "lastModified": "2019-01-17T11:29:04.703", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Buffer overflow in redis-cli of Redis before 4.0.10 and 5.x before 5.0 RC3 allows an attacker to achieve code execution and escalate to higher privileges via a crafted command line. NOTE: It is unclear whether there are any common situations in which redis-cli is used with, for example, a -h (aka hostname) argument from an untrusted source."}, {"lang": "es", "value": "Desbordamiento de b\u00fafer en redis-cli en Redis, en versiones anteriores a la 4.0.10 y versiones 5.x anteriores a la 5.0 RC3 permite que un atacante logre la ejecuci\u00f3n de c\u00f3digo y escale a privilegios m\u00e1s altos mediante una l\u00ednea de comandos manipulada. NOTA: no se sabe a ciencia cierta si hay situaciones comunes en las que se emplea redis-cli, por ejemplo, con un argumento -h (hostname) de una fuente no fiable."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.4, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.5, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redislabs:redis:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.0.10", "matchCriteriaId": "E7C4D4C1-3E71-4A37-909C-2E4D58BC3CE3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redislabs:redis:5.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "E6037E16-4EE7-44F6-9045-DA6B705B0F5B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redislabs:redis:5.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "A6444004-34F9-4FA0-8DA0-A8C9E1BE4447"}]}]}], "references": [{"url": "https://access.redhat.com/errata/RHSA-2019:0052", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2019:0094", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2019:1860", "source": "cve@mitre.org"}, {"url": "https://gist.github.com/fakhrizulkifli/f831f40ec6cde4f744c552503d8698f0", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/antirez/redis/commit/9fdcc15962f9ff4baebe6fdd947816f43f730d50", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://raw.githubusercontent.com/antirez/redis/4.0/00-RELEASENOTES", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://raw.githubusercontent.com/antirez/redis/5.0/00-RELEASENOTES", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.exploit-db.com/exploits/44904/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/antirez/redis/commit/9fdcc15962f9ff4baebe6fdd947816f43f730d50"}}