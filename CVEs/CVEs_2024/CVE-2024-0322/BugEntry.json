{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2017-2023\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / AC3 reframer filter\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/avparse.h>\n#include <gpac/constants.h>\n#include <gpac/filters.h>\n\n#if !defined(GPAC_DISABLE_AV_PARSERS) && !defined(GPAC_DISABLE_RFAC3)\n\ntypedef struct\n{\n\tu64 pos;\n\tDouble duration;\n} AC3Idx;\n\n#define AC3_FRAME_SIZE 1536\n\ntypedef struct\n{\n\t//filter args\n\tDouble index;\n\n\t//only one input pid declared\n\tGF_FilterPid *ipid;\n\t//only one output pid declared\n\tGF_FilterPid *opid;\n\n\tGF_BitStream *bs;\n\tu64 file_pos, cts;\n\tu32 sample_rate, nb_ch;\n\tGF_Fraction64 duration;\n\tDouble start_range;\n\tBool in_seek;\n\tu32 timescale;\n\n\tGF_AC3Config hdr;\n\tu8 *ac3_buffer;\n\tu32 ac3_buffer_size, ac3_buffer_alloc, resume_from;\n\tu64 byte_offset;\n\n\tBool is_playing;\n\tBool is_file, file_loaded;\n\tBool initial_play_done;\n\n\tBool is_eac3;\n\tBool (*ac3_parser_bs)(GF_BitStream*, GF_AC3Config*, Bool);\n\n\tGF_FilterPacket *src_pck;\n\n\tAC3Idx *indexes;\n\tu32 index_alloc_size, index_size;\n\tu32 bitrate;\n\tBool copy_props;\n} GF_AC3DmxCtx;\n\n\n\n\nGF_Err ac3dmx_configure_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_remove)\n{\n\tconst GF_PropertyValue *p;\n\tGF_AC3DmxCtx *ctx = gf_filter_get_udta(filter);\n\n\tif (is_remove) {\n\t\tctx->ipid = NULL;\n\t\tif (ctx->opid) {\n\t\t\tgf_filter_pid_remove(ctx->opid);\n\t\t\tctx->opid = NULL;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tif (! gf_filter_pid_check_caps(pid))\n\t\treturn GF_NOT_SUPPORTED;\n\n\tctx->ipid = pid;\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_TIMESCALE);\n\tif (p) ctx->timescale = p->value.uint;\n\n\tctx->ac3_parser_bs = gf_ac3_parser_bs;\n\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_CODECID);\n\tif (p && p->value.uint==GF_CODECID_EAC3) ctx->is_eac3 = GF_TRUE;\n\telse {\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_MIME);\n\t\tif (p && p->value.string && strstr(p->value.string, \"eac3\")) ctx->is_eac3 = GF_TRUE;\n\t\telse {\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_FILE_EXT);\n\t\t\tif (p && p->value.string && (strstr(p->value.string, \"eac3\")||strstr(p->value.string, \"ec3\"))) ctx->is_eac3 = GF_TRUE;\n\t\t}\n\t}\n\tif (ctx->is_eac3) {\n\t\tctx->ac3_parser_bs = gf_eac3_parser_bs;\n\t}\n\n\tif (ctx->timescale && !ctx->opid) {\n\t\tctx->opid = gf_filter_pid_new(filter);\n\t\tgf_filter_pid_copy_properties(ctx->opid, ctx->ipid);\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_UNFRAMED, NULL);\n\n\t\t//make sure we move to audio (may happen if source filter is writegen)\n\t\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_STREAM_TYPE);\n\t\tif (!p || (p->value.uint==GF_STREAM_FILE)) {\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_AUDIO));\n\t\t}\n\t}\n\tif (ctx->timescale) ctx->copy_props = GF_TRUE;\n\treturn GF_OK;\n}\n\nstatic void ac3dmx_check_dur(GF_Filter *filter, GF_AC3DmxCtx *ctx)\n{\n\tFILE *stream;\n\tGF_BitStream *bs;\n\tGF_AC3Config hdr;\n\tu64 duration, cur_dur, rate;\n\ts32 sr = -1;\n\tconst GF_PropertyValue *p;\n\tif (!ctx->opid || ctx->timescale || ctx->file_loaded) return;\n\n\tif (ctx->index<=0) {\n\t\tctx->file_loaded = GF_TRUE;\n\t\treturn;\n\t}\n\n\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_FILEPATH);\n\tif (!p || !p->value.string || !strncmp(p->value.string, \"gmem://\", 7)) {\n\t\tctx->is_file = GF_FALSE;\n\t\tctx->file_loaded = GF_TRUE;\n\t\treturn;\n\t}\n\tctx->is_file = GF_TRUE;\n\n\tstream = gf_fopen_ex(p->value.string, NULL, \"rb\", GF_TRUE);\n\tif (!stream) {\n\t\tif (gf_fileio_is_main_thread(p->value.string))\n\t\t\tctx->file_loaded = GF_TRUE;\n\t\treturn;\n\t}\n\n\tctx->index_size = 0;\n\n\tbs = gf_bs_from_file(stream, GF_BITSTREAM_READ);\n\tduration = 0;\n\tcur_dur = 0;\n\twhile (\tctx->ac3_parser_bs(bs, &hdr, GF_FALSE) ) {\n\t\tif ((sr>=0) && (sr != hdr.sample_rate)) {\n\t\t\tduration *= hdr.sample_rate;\n\t\t\tduration /= sr;\n\n\t\t\tcur_dur *= hdr.sample_rate;\n\t\t\tcur_dur /= sr;\n\t\t}\n\t\tsr = hdr.sample_rate;\n\t\tduration += AC3_FRAME_SIZE;\n\t\tcur_dur += AC3_FRAME_SIZE;\n\t\tif (cur_dur > ctx->index * sr) {\n\t\t\tif (!ctx->index_alloc_size) ctx->index_alloc_size = 10;\n\t\t\telse if (ctx->index_alloc_size == ctx->index_size) ctx->index_alloc_size *= 2;\n\t\t\tctx->indexes = gf_realloc(ctx->indexes, sizeof(AC3Idx)*ctx->index_alloc_size);\n\t\t\tctx->indexes[ctx->index_size].pos = gf_bs_get_position(bs);\n\t\t\tctx->indexes[ctx->index_size].duration = (Double) duration;\n\t\t\tctx->indexes[ctx->index_size].duration /= sr;\n\t\t\tctx->index_size ++;\n\t\t\tcur_dur = 0;\n\t\t}\n\n\t\tgf_bs_skip_bytes(bs, hdr.framesize);\n\t}\n\trate = gf_bs_get_position(bs);\n\tgf_bs_del(bs);\n\tgf_fclose(stream);\n\n\tif (!ctx->duration.num || (ctx->duration.num  * sr != duration * ctx->duration.den)) {\n\t\tctx->duration.num = (s32) duration;\n\t\tctx->duration.den = sr;\n\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DURATION, & PROP_FRAC64(ctx->duration));\n\n\t\tif (duration && !gf_sys_is_test_mode() ) {\n\t\t\trate *= 8 * ctx->duration.den;\n\t\t\trate /= ctx->duration.num;\n\t\t\tctx->bitrate = (u32) rate;\n\t\t}\n\t}\n\n\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_FILE_CACHED);\n\tif (p && p->value.boolean) ctx->file_loaded = GF_TRUE;\n}\n\nstatic void ac3dmx_check_pid(GF_Filter *filter, GF_AC3DmxCtx *ctx)\n{\n\tu8 *data;\n\tu32 size;\n\tif (!ctx->opid) {\n\t\tctx->opid = gf_filter_pid_new(filter);\n\t\tac3dmx_check_dur(filter, ctx);\n\t}\n\tif ((ctx->sample_rate == ctx->hdr.sample_rate) && (ctx->nb_ch == ctx->hdr.streams[0].channels) && !ctx->copy_props) return;\n\n\tctx->copy_props = GF_FALSE;\n\t//copy properties at init or reconfig\n\tgf_filter_pid_copy_properties(ctx->opid, ctx->ipid);\n\tconst GF_PropertyValue *p = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_STREAM_TYPE);\n\tif (!p || (p->value.uint==GF_STREAM_FILE)) {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_AUDIO));\n\t}\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_SAMPLES_PER_FRAME, & PROP_UINT(AC3_FRAME_SIZE) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_UNFRAMED, & PROP_BOOL(GF_FALSE) );\n\n\tif (ctx->duration.num)\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DURATION, & PROP_FRAC64(ctx->duration));\n\tif (!ctx->timescale && !gf_sys_is_test_mode())\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CAN_DATAREF, & PROP_BOOL(GF_TRUE ) );\n\n\n\tctx->nb_ch = ctx->hdr.streams[0].channels;\n\tif (!ctx->timescale) {\n\t\t//we change sample rate, change cts\n\t\tif (ctx->cts && (ctx->sample_rate != ctx->hdr.sample_rate)) {\n\t\t\tctx->cts = gf_timestamp_rescale(ctx->cts, ctx->sample_rate, ctx->hdr.sample_rate);\n\t\t}\n\t}\n\tctx->sample_rate = ctx->hdr.sample_rate;\n\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TIMESCALE, & PROP_UINT(ctx->timescale ? ctx->timescale : ctx->sample_rate));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_SAMPLE_RATE, & PROP_UINT(ctx->sample_rate));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_NUM_CHANNELS, & PROP_UINT(ctx->nb_ch) );\n\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, & PROP_UINT(ctx->is_eac3 ? GF_CODECID_EAC3 : GF_CODECID_AC3) );\n\n\tctx->hdr.is_ec3 = ctx->is_eac3;\n\tgf_odf_ac3_cfg_write(&ctx->hdr, &data, &size);\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG, & PROP_DATA_NO_COPY(data, size) );\n\n\tif (ctx->bitrate) {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_BITRATE, & PROP_UINT(ctx->bitrate));\n\t}\n\n\tif (ctx->is_file && ctx->index) {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_PLAYBACK_MODE, & PROP_UINT(GF_PLAYBACK_MODE_FASTFORWARD) );\n\t}\n}\n\nstatic Bool ac3dmx_process_event(GF_Filter *filter, const GF_FilterEvent *evt)\n{\n\tu32 i;\n\tGF_FilterEvent fevt;\n\tGF_AC3DmxCtx *ctx = gf_filter_get_udta(filter);\n\n\tswitch (evt->base.type) {\n\tcase GF_FEVT_PLAY:\n\t\tif (!ctx->is_playing) {\n\t\t\tctx->is_playing = GF_TRUE;\n\t\t\tctx->cts = 0;\n\t\t}\n\t\tif (! ctx->is_file) {\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\tctx->start_range = evt->play.start_range;\n\t\tctx->in_seek = GF_TRUE;\n\t\tctx->file_pos = 0;\n\t\tif (ctx->start_range) {\n\t\t\tfor (i=1; i<ctx->index_size; i++) {\n\t\t\t\tif (ctx->indexes[i].duration>ctx->start_range) {\n\t\t\t\t\tctx->cts = (u64) (ctx->indexes[i-1].duration * ctx->sample_rate);\n\t\t\t\t\tctx->file_pos = ctx->indexes[i-1].pos;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!ctx->initial_play_done) {\n\t\t\tctx->initial_play_done = GF_TRUE;\n\t\t\t//seek will not change the current source state, don't send a seek\n\t\t\tif (!ctx->file_pos)\n\t\t\t\treturn GF_TRUE;\n\t\t}\n\t\tctx->ac3_buffer_size = 0;\n\t\tctx->resume_from = 0;\n\t\t//post a seek\n\t\tGF_FEVT_INIT(fevt, GF_FEVT_SOURCE_SEEK, ctx->ipid);\n\t\tfevt.seek.start_offset = ctx->file_pos;\n\t\tgf_filter_pid_send_event(ctx->ipid, &fevt);\n\n\t\t//cancel event\n\t\treturn GF_TRUE;\n\n\tcase GF_FEVT_STOP:\n\t\t//don't cancel event\n\t\tctx->is_playing = GF_FALSE;\n\t\tctx->cts = 0;\n\t\treturn GF_FALSE;\n\n\tcase GF_FEVT_SET_SPEED:\n\t\t//cancel event\n\t\treturn GF_TRUE;\n\tdefault:\n\t\tbreak;\n\t}\n\t//by default don't cancel event - to rework once we have downloading in place\n\treturn GF_FALSE;\n}\n\nstatic GFINLINE void ac3dmx_update_cts(GF_AC3DmxCtx *ctx)\n{\n\tif (ctx->timescale) {\n\t\tu64 inc = AC3_FRAME_SIZE;\n\t\tinc *= ctx->timescale;\n\t\tinc /= ctx->sample_rate;\n\t\tctx->cts += inc;\n\t} else {\n\t\tctx->cts += AC3_FRAME_SIZE;\n\t}\n}\n\nGF_Err ac3dmx_process(GF_Filter *filter)\n{\n\tGF_AC3DmxCtx *ctx = gf_filter_get_udta(filter);\n\tGF_FilterPacket *pck, *dst_pck;\n\tu8 *output;\n\tu8 *start;\n\tu32 pck_size, remain, prev_pck_size;\n\tu64 cts;\n\nrestart:\n\tcts = GF_FILTER_NO_TS;\n\n\t//always reparse duration\n\tif (!ctx->duration.num)\n\t\tac3dmx_check_dur(filter, ctx);\n\n\tif (ctx->opid && !ctx->is_playing)\n\t\treturn GF_OK;\n\n\tpck = gf_filter_pid_get_packet(ctx->ipid);\n\tif (!pck) {\n\t\tif (gf_filter_pid_is_eos(ctx->ipid)) {\n\t\t\tif (!ctx->ac3_buffer_size) {\n\t\t\t\tif (ctx->opid)\n\t\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\t\t\tctx->src_pck = NULL;\n\t\t\t\treturn GF_EOS;\n\t\t\t}\n\t\t} else {\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\tprev_pck_size = ctx->ac3_buffer_size;\n\tif (pck && !ctx->resume_from) {\n\t\tconst u8 *data = gf_filter_pck_get_data(pck, &pck_size);\n\t\tif (!pck_size) {\n\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\treturn GF_OK;\n\t\t}\n\n\t\t//max EAC3 frame is 4096 but we can have side streams, AC3 is 3840 - if we store more than 2 frames consider we have garbage\n\t\tif (ctx->ac3_buffer_size>100000) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[AC3Dmx] Trashing %d garbage bytes\\n\", ctx->ac3_buffer_size));\n\t\t\tctx->ac3_buffer_size = 0;\n\t\t}\n\n\t\tif (ctx->byte_offset != GF_FILTER_NO_BO) {\n\t\t\tu64 byte_offset = gf_filter_pck_get_byte_offset(pck);\n\t\t\tif (!ctx->ac3_buffer_size) {\n\t\t\t\tctx->byte_offset = byte_offset;\n\t\t\t} else if (ctx->byte_offset + ctx->ac3_buffer_size != byte_offset) {\n\t\t\t\tctx->byte_offset = GF_FILTER_NO_BO;\n\t\t\t\tif ((byte_offset != GF_FILTER_NO_BO) && (byte_offset>ctx->ac3_buffer_size) ) {\n\t\t\t\t\tctx->byte_offset = byte_offset - ctx->ac3_buffer_size;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ctx->ac3_buffer_size + pck_size > ctx->ac3_buffer_alloc) {\n\t\t\tctx->ac3_buffer_alloc = ctx->ac3_buffer_size + pck_size;\n\t\t\tctx->ac3_buffer = gf_realloc(ctx->ac3_buffer, ctx->ac3_buffer_alloc);\n\t\t}\n\t\tmemcpy(ctx->ac3_buffer + ctx->ac3_buffer_size, data, pck_size);\n\t\tctx->ac3_buffer_size += pck_size;\n\t}\n\n\t//input pid sets some timescale - we flushed pending data , update cts\n\tif (ctx->timescale && pck) {\n\t\tcts = gf_filter_pck_get_cts(pck);\n\t\t//init cts at first packet\n\t\tif (!ctx->cts && (cts != GF_FILTER_NO_TS))\n\t\t\tctx->cts = cts;\n\t}\n\n\tif (cts == GF_FILTER_NO_TS) {\n\t\t//avoids updating cts\n\t\tprev_pck_size = 0;\n\t}\n\n\tremain = ctx->ac3_buffer_size;\n\tstart = ctx->ac3_buffer;\n\n\tif (ctx->resume_from) {\n\t\tstart += ctx->resume_from - 1;\n\t\tremain -= ctx->resume_from - 1;\n\t\tctx->resume_from = 0;\n\t}\n\n\tif (!ctx->bs) {\n\t\tctx->bs = gf_bs_new(start, remain, GF_BITSTREAM_READ);\n\t} else {\n\t\tgf_bs_reassign_buffer(ctx->bs, start, remain);\n\t}\n\twhile (remain) {\n\t\tu8 *sync;\n\t\tBool res;\n\t\tu32 sync_pos, bytes_to_drop=0;\n\n\t\tres = ctx->ac3_parser_bs(ctx->bs, &ctx->hdr, GF_TRUE);\n\n\t\tsync_pos = (u32) gf_bs_get_position(ctx->bs);\n\n\t\t//if not end of stream or no valid frame\n\t\tif (pck || !ctx->hdr.framesize) {\n\t\t\t//startcode not found or not enough bytes, gather more\n\t\t\tif (!res || (remain < sync_pos + ctx->hdr.framesize)) {\n\t\t\t\tif (sync_pos && ctx->hdr.framesize) {\n\t\t\t\t\tstart += sync_pos;\n\t\t\t\t\tremain -= sync_pos;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tac3dmx_check_pid(filter, ctx);\n\t\t}\n\t\t//may happen with very-short streams\n\t\tif (!ctx->sample_rate)\n\t\t\tac3dmx_check_pid(filter, ctx);\n\n\t\tif (!ctx->is_playing) {\n\t\t\tctx->resume_from = 1 + ctx->ac3_buffer_size - remain;\n\t\t\treturn GF_OK;\n\t\t}\n\n\t\tif (sync_pos) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[AC3Dmx] %d bytes unrecovered before sync word\\n\", sync_pos));\n\t\t}\n\t\tsync = start + sync_pos;\n\n\t\tif (ctx->in_seek) {\n\t\t\tu64 nb_samples_at_seek = (u64) (ctx->start_range * ctx->hdr.sample_rate);\n\t\t\tif (ctx->cts + AC3_FRAME_SIZE >= nb_samples_at_seek) {\n\t\t\t\t//u32 samples_to_discard = (ctx->cts + ctx->dts_inc) - nb_samples_at_seek;\n\t\t\t\tctx->in_seek = GF_FALSE;\n\t\t\t}\n\t\t}\n\n\t\tbytes_to_drop = sync_pos + ctx->hdr.framesize;\n\t\tif (ctx->timescale && !prev_pck_size &&  (cts != GF_FILTER_NO_TS) ) {\n\t\t\t//trust input CTS if diff is more than one sec\n\t\t\tif ((cts > ctx->cts + ctx->timescale) || (ctx->cts > cts + ctx->timescale))\n\t\t\t\tctx->cts = cts;\n\t\t\tcts = GF_FILTER_NO_TS;\n\t\t}\n\n\t\tif (!ctx->in_seek && remain >= ctx->hdr.framesize) {\n\t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->hdr.framesize, &output);\n\t\t\tif (!dst_pck) return GF_OUT_OF_MEM;\n\n\t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\n\t\t\tmemcpy(output, sync, ctx->hdr.framesize);\n\t\t\tgf_filter_pck_set_dts(dst_pck, ctx->cts);\n\t\t\tgf_filter_pck_set_cts(dst_pck, ctx->cts);\n\t\t\tif (ctx->timescale && (ctx->timescale!=ctx->sample_rate))\n\t\t\t\tgf_filter_pck_set_duration(dst_pck, (u32) gf_timestamp_rescale(AC3_FRAME_SIZE, ctx->sample_rate, ctx->timescale));\n\t\t\telse\n\t\t\t\tgf_filter_pck_set_duration(dst_pck, AC3_FRAME_SIZE);\n\t\t\tgf_filter_pck_set_sap(dst_pck, GF_FILTER_SAP_1);\n\t\t\tgf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_TRUE);\n\n\t\t\tif (ctx->byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, ctx->byte_offset + ctx->hdr.framesize);\n\t\t\t}\n\n\t\t\tgf_filter_pck_send(dst_pck);\n\t\t}\n\t\tac3dmx_update_cts(ctx);\n\n\t\t//truncated last frame\n\t\tif (bytes_to_drop>remain) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[ADTSDmx] truncated AC3 frame!\\n\"));\n\t\t\tbytes_to_drop=remain;\n\t\t}\n\n\t\tif (!bytes_to_drop) {\n\t\t\tbytes_to_drop = 1;\n\t\t}\n\t\tstart += bytes_to_drop;\n\t\tremain -= bytes_to_drop;\n\t\tgf_bs_reassign_buffer(ctx->bs, start, remain);\n\n\t\tif (prev_pck_size) {\n\t\t\tif (prev_pck_size > bytes_to_drop) prev_pck_size -= bytes_to_drop;\n\t\t\telse {\n\t\t\t\tprev_pck_size=0;\n\t\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\t\t\tctx->src_pck = pck;\n\t\t\t\tif (pck)\n\t\t\t\t\tgf_filter_pck_ref_props(&ctx->src_pck);\n\t\t\t}\n\t\t}\n\t\tif (ctx->byte_offset != GF_FILTER_NO_BO)\n\t\t\tctx->byte_offset += bytes_to_drop;\n\t}\n\n\tif (!pck) {\n\t\tctx->ac3_buffer_size = 0;\n\t\t//avoid recursive call\n\t\tgoto restart;\n\t} else {\n\t\tif (remain && (remain < ctx->ac3_buffer_size)) {\n\t\t\tmemmove(ctx->ac3_buffer, start, remain);\n\t\t}\n\t\tctx->ac3_buffer_size = remain;\n\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t}\n\treturn GF_OK;\n}\n\nstatic void ac3dmx_finalize(GF_Filter *filter)\n{\n\tGF_AC3DmxCtx *ctx = gf_filter_get_udta(filter);\n\tif (ctx->bs) gf_bs_del(ctx->bs);\n\tif (ctx->ac3_buffer) gf_free(ctx->ac3_buffer);\n\tif (ctx->indexes) gf_free(ctx->indexes);\n}\n\nstatic const char *ac3dmx_probe_data(const u8 *_data, u32 _size, GF_FilterProbeScore *score)\n{\n\tGF_AC3Config ahdr;\n\tu32 i, nb_frames=0;\n\tBool has_broken_frames = GF_FALSE;\n\tu32 pos=0;\n\tconst u8 *data = _data;\n\tu32 size = _size;\n\tu32 nb_ac3_frames=0;\n\n\t//check AC3\n\twhile (1) {\n\t\tahdr.sample_rate = 0;\n\t\tif (! gf_ac3_parser((u8 *) data, size, &pos, &ahdr, GF_FALSE) ) {\n\t\t\tif (ahdr.sample_rate) nb_frames++;\n\t\t \tbreak;\n\t\t}\n\t\tu32 fsize = ahdr.framesize;\n\t\tif (pos) {\n\t\t\tnb_frames=0;\n\t\t\thas_broken_frames = GF_TRUE;\n\t\t\t//what is before is bigger than max ac3 frame size (1920 words), this is packaged ac3 (mkv) at best\n\t\t\tif (pos > 4000)\n\t\t\t\tbreak;\n\t\t}\n\t\tnb_frames++;\n\t\tif (fsize > size+pos) {\n\t\t\tif (!pos && (nb_frames==1)) nb_frames++;\n\t\t\tbreak;\n\t\t}\n\t\tif (nb_frames>4) break;\n\t\tif (size < fsize+pos) break;\n\t\tsize -= fsize+pos;\n\t\tdata += fsize+pos;\n\t}\n\tnb_ac3_frames = nb_frames;\n\n\t//check EAC3\n\tpos=0;\n\tdata = _data;\n\tsize = _size;\n\tnb_frames = 0;\n\tGF_BitStream *bs = gf_bs_new(data, size, GF_BITSTREAM_READ);\n\twhile (gf_bs_available(bs)) {\n\t\tahdr.sample_rate = 0;\n\t\tif (!gf_eac3_parser_bs(bs, &ahdr, GF_FALSE)) {\n\t\t\tif (ahdr.sample_rate) nb_frames++;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (pos != (u32) gf_bs_get_position(bs))\n\t\t\thas_broken_frames = GF_TRUE;\n\t\tnb_frames += ahdr.nb_streams;\n\t\tfor (i=0; i<ahdr.nb_streams; i++)\n\t\t\tnb_frames += ahdr.streams[i].nb_dep_sub ? 1 : 0;\n\t\tgf_bs_skip_bytes(bs, ahdr.framesize);\n\t\tif (!pos && (nb_frames==1) && !gf_bs_available(bs)) nb_frames++;\n\t\tpos+=ahdr.framesize;\n\t\tif (nb_frames>4) break;\n\t}\n\tgf_bs_del(bs);\n\n\tif (nb_frames<nb_ac3_frames) {\n\t\tnb_frames = 0;\n\t}\n\tif (nb_ac3_frames>=2) {\n\t\t*score = has_broken_frames ? GF_FPROBE_MAYBE_NOT_SUPPORTED : GF_FPROBE_SUPPORTED;\n\t\treturn \"audio/ac3\";\n\t}\n\n\tif (nb_frames>=2) {\n\t\t*score = has_broken_frames ? GF_FPROBE_MAYBE_NOT_SUPPORTED : GF_FPROBE_SUPPORTED;\n\t\treturn \"audio/eac3\";\n\t}\n\n\treturn NULL;\n}\n\nstatic const GF_FilterCapability AC3DmxCaps[] =\n{\n\tCAP_UINT(GF_CAPS_INPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_FILE_EXT, \"ac3|eac3|ec3\"),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_MIME, \"audio/x-ac3|audio/ac3|audio/x-eac3|audio/eac3\"),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_AUDIO),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_AC3),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_EAC3),\n\tCAP_BOOL(GF_CAPS_OUTPUT_STATIC_EXCLUDED, GF_PROP_PID_UNFRAMED, GF_TRUE),\n\t{0},\n\tCAP_UINT(GF_CAPS_INPUT_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_AUDIO),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_AC3),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_EAC3),\n\tCAP_BOOL(GF_CAPS_INPUT,GF_PROP_PID_UNFRAMED, GF_TRUE),\n\t{0},\n\tCAP_UINT(GF_CAPS_INPUT_OUTPUT,GF_PROP_PID_STREAM_TYPE, GF_STREAM_ENCRYPTED),\n\tCAP_UINT(GF_CAPS_INPUT, GF_PROP_PID_PROTECTION_SCHEME_TYPE, GF_HLS_SAMPLE_AES_SCHEME),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_AC3),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_EAC3),\n\tCAP_BOOL(GF_CAPS_INPUT,GF_PROP_PID_UNFRAMED, GF_TRUE),\n};\n\n#define OFFS(_n)\t#_n, offsetof(GF_AC3DmxCtx, _n)\nstatic const GF_FilterArgs AC3DmxArgs[] =\n{\n\t{ OFFS(index), \"indexing window length\", GF_PROP_DOUBLE, \"1.0\", NULL, 0},\n\t{0}\n};\n\n\nGF_FilterRegister AC3DmxRegister = {\n\t.name = \"rfac3\",\n\tGF_FS_SET_DESCRIPTION(\"AC3 reframer\")\n\tGF_FS_SET_HELP(\"This filter parses AC3 and E-AC3 files/data and outputs corresponding audio PID and frames.\")\n\t.private_size = sizeof(GF_AC3DmxCtx),\n\t.args = AC3DmxArgs,\n\t.finalize = ac3dmx_finalize,\n\tSETCAPS(AC3DmxCaps),\n\t.configure_pid = ac3dmx_configure_pid,\n\t.process = ac3dmx_process,\n\t.probe_data = ac3dmx_probe_data,\n\t.process_event = ac3dmx_process_event\n};\n\n\nconst GF_FilterRegister *rfac3_register(GF_FilterSession *session)\n{\n\treturn &AC3DmxRegister;\n}\n#else\nconst GF_FilterRegister *rfac3_register(GF_FilterSession *session)\n{\n\treturn NULL;\n}\n#endif // !defined(GPAC_DISABLE_AV_PARSERS) && !defined(GPAC_DISABLE_RFAC3)\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2017-2023\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / AC3 reframer filter\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/avparse.h>\n#include <gpac/constants.h>\n#include <gpac/filters.h>\n\n#if !defined(GPAC_DISABLE_AV_PARSERS) && !defined(GPAC_DISABLE_RFAC3)\n\ntypedef struct\n{\n\tu64 pos;\n\tDouble duration;\n} AC3Idx;\n\n#define AC3_FRAME_SIZE 1536\n\ntypedef struct\n{\n\t//filter args\n\tDouble index;\n\n\t//only one input pid declared\n\tGF_FilterPid *ipid;\n\t//only one output pid declared\n\tGF_FilterPid *opid;\n\n\tGF_BitStream *bs;\n\tu64 file_pos, cts;\n\tu32 sample_rate, nb_ch;\n\tGF_Fraction64 duration;\n\tDouble start_range;\n\tBool in_seek;\n\tu32 timescale;\n\n\tGF_AC3Config hdr;\n\tu8 *ac3_buffer;\n\tu32 ac3_buffer_size, ac3_buffer_alloc, resume_from;\n\tu64 byte_offset;\n\n\tBool is_playing;\n\tBool is_file, file_loaded;\n\tBool initial_play_done;\n\n\tBool is_eac3;\n\tBool (*ac3_parser_bs)(GF_BitStream*, GF_AC3Config*, Bool);\n\n\tGF_FilterPacket *src_pck;\n\n\tAC3Idx *indexes;\n\tu32 index_alloc_size, index_size;\n\tu32 bitrate;\n\tBool copy_props;\n} GF_AC3DmxCtx;\n\n\n\n\nGF_Err ac3dmx_configure_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_remove)\n{\n\tconst GF_PropertyValue *p;\n\tGF_AC3DmxCtx *ctx = gf_filter_get_udta(filter);\n\n\tif (is_remove) {\n\t\tctx->ipid = NULL;\n\t\tif (ctx->opid) {\n\t\t\tgf_filter_pid_remove(ctx->opid);\n\t\t\tctx->opid = NULL;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tif (! gf_filter_pid_check_caps(pid))\n\t\treturn GF_NOT_SUPPORTED;\n\n\tctx->ipid = pid;\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_TIMESCALE);\n\tif (p) ctx->timescale = p->value.uint;\n\n\tctx->ac3_parser_bs = gf_ac3_parser_bs;\n\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_CODECID);\n\tif (p && p->value.uint==GF_CODECID_EAC3) ctx->is_eac3 = GF_TRUE;\n\telse {\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_MIME);\n\t\tif (p && p->value.string && strstr(p->value.string, \"eac3\")) ctx->is_eac3 = GF_TRUE;\n\t\telse {\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_FILE_EXT);\n\t\t\tif (p && p->value.string && (strstr(p->value.string, \"eac3\")||strstr(p->value.string, \"ec3\"))) ctx->is_eac3 = GF_TRUE;\n\t\t}\n\t}\n\tif (ctx->is_eac3) {\n\t\tctx->ac3_parser_bs = gf_eac3_parser_bs;\n\t}\n\n\tif (ctx->timescale && !ctx->opid) {\n\t\tctx->opid = gf_filter_pid_new(filter);\n\t\tgf_filter_pid_copy_properties(ctx->opid, ctx->ipid);\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_UNFRAMED, NULL);\n\n\t\t//make sure we move to audio (may happen if source filter is writegen)\n\t\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_STREAM_TYPE);\n\t\tif (!p || (p->value.uint==GF_STREAM_FILE)) {\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_AUDIO));\n\t\t}\n\t}\n\tif (ctx->timescale) ctx->copy_props = GF_TRUE;\n\treturn GF_OK;\n}\n\nstatic void ac3dmx_check_dur(GF_Filter *filter, GF_AC3DmxCtx *ctx)\n{\n\tFILE *stream;\n\tGF_BitStream *bs;\n\tGF_AC3Config hdr;\n\tu64 duration, cur_dur, rate;\n\ts32 sr = -1;\n\tconst GF_PropertyValue *p;\n\tif (!ctx->opid || ctx->timescale || ctx->file_loaded) return;\n\n\tif (ctx->index<=0) {\n\t\tctx->file_loaded = GF_TRUE;\n\t\treturn;\n\t}\n\n\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_FILEPATH);\n\tif (!p || !p->value.string || !strncmp(p->value.string, \"gmem://\", 7)) {\n\t\tctx->is_file = GF_FALSE;\n\t\tctx->file_loaded = GF_TRUE;\n\t\treturn;\n\t}\n\tctx->is_file = GF_TRUE;\n\n\tstream = gf_fopen_ex(p->value.string, NULL, \"rb\", GF_TRUE);\n\tif (!stream) {\n\t\tif (gf_fileio_is_main_thread(p->value.string))\n\t\t\tctx->file_loaded = GF_TRUE;\n\t\treturn;\n\t}\n\n\tctx->index_size = 0;\n\n\tbs = gf_bs_from_file(stream, GF_BITSTREAM_READ);\n\tduration = 0;\n\tcur_dur = 0;\n\twhile (\tctx->ac3_parser_bs(bs, &hdr, GF_FALSE) ) {\n\t\tif ((sr>=0) && (sr != hdr.sample_rate)) {\n\t\t\tduration *= hdr.sample_rate;\n\t\t\tduration /= sr;\n\n\t\t\tcur_dur *= hdr.sample_rate;\n\t\t\tcur_dur /= sr;\n\t\t}\n\t\tsr = hdr.sample_rate;\n\t\tduration += AC3_FRAME_SIZE;\n\t\tcur_dur += AC3_FRAME_SIZE;\n\t\tif (cur_dur > ctx->index * sr) {\n\t\t\tif (!ctx->index_alloc_size) ctx->index_alloc_size = 10;\n\t\t\telse if (ctx->index_alloc_size == ctx->index_size) ctx->index_alloc_size *= 2;\n\t\t\tctx->indexes = gf_realloc(ctx->indexes, sizeof(AC3Idx)*ctx->index_alloc_size);\n\t\t\tctx->indexes[ctx->index_size].pos = gf_bs_get_position(bs);\n\t\t\tctx->indexes[ctx->index_size].duration = (Double) duration;\n\t\t\tctx->indexes[ctx->index_size].duration /= sr;\n\t\t\tctx->index_size ++;\n\t\t\tcur_dur = 0;\n\t\t}\n\n\t\tgf_bs_skip_bytes(bs, hdr.framesize);\n\t}\n\trate = gf_bs_get_position(bs);\n\tgf_bs_del(bs);\n\tgf_fclose(stream);\n\n\tif (!ctx->duration.num || (ctx->duration.num  * sr != duration * ctx->duration.den)) {\n\t\tctx->duration.num = (s32) duration;\n\t\tctx->duration.den = sr;\n\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DURATION, & PROP_FRAC64(ctx->duration));\n\n\t\tif (duration && !gf_sys_is_test_mode() ) {\n\t\t\trate *= 8 * ctx->duration.den;\n\t\t\trate /= ctx->duration.num;\n\t\t\tctx->bitrate = (u32) rate;\n\t\t}\n\t}\n\n\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_FILE_CACHED);\n\tif (p && p->value.boolean) ctx->file_loaded = GF_TRUE;\n}\n\nstatic void ac3dmx_check_pid(GF_Filter *filter, GF_AC3DmxCtx *ctx)\n{\n\tu8 *data;\n\tu32 size;\n\tif (!ctx->opid) {\n\t\tctx->opid = gf_filter_pid_new(filter);\n\t\tac3dmx_check_dur(filter, ctx);\n\t}\n\tif ((ctx->sample_rate == ctx->hdr.sample_rate) && (ctx->nb_ch == ctx->hdr.streams[0].channels) && !ctx->copy_props) return;\n\n\tctx->copy_props = GF_FALSE;\n\t//copy properties at init or reconfig\n\tgf_filter_pid_copy_properties(ctx->opid, ctx->ipid);\n\tconst GF_PropertyValue *p = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_STREAM_TYPE);\n\tif (!p || (p->value.uint==GF_STREAM_FILE)) {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_AUDIO));\n\t}\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_SAMPLES_PER_FRAME, & PROP_UINT(AC3_FRAME_SIZE) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_UNFRAMED, & PROP_BOOL(GF_FALSE) );\n\n\tif (ctx->duration.num)\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DURATION, & PROP_FRAC64(ctx->duration));\n\tif (!ctx->timescale && !gf_sys_is_test_mode())\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CAN_DATAREF, & PROP_BOOL(GF_TRUE ) );\n\n\n\tctx->nb_ch = ctx->hdr.streams[0].channels;\n\tif (!ctx->timescale) {\n\t\t//we change sample rate, change cts\n\t\tif (ctx->cts && (ctx->sample_rate != ctx->hdr.sample_rate)) {\n\t\t\tctx->cts = gf_timestamp_rescale(ctx->cts, ctx->sample_rate, ctx->hdr.sample_rate);\n\t\t}\n\t}\n\tctx->sample_rate = ctx->hdr.sample_rate;\n\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TIMESCALE, & PROP_UINT(ctx->timescale ? ctx->timescale : ctx->sample_rate));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_SAMPLE_RATE, & PROP_UINT(ctx->sample_rate));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_NUM_CHANNELS, & PROP_UINT(ctx->nb_ch) );\n\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, & PROP_UINT(ctx->is_eac3 ? GF_CODECID_EAC3 : GF_CODECID_AC3) );\n\n\tctx->hdr.is_ec3 = ctx->is_eac3;\n\tgf_odf_ac3_cfg_write(&ctx->hdr, &data, &size);\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG, & PROP_DATA_NO_COPY(data, size) );\n\n\tif (ctx->bitrate) {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_BITRATE, & PROP_UINT(ctx->bitrate));\n\t}\n\n\tif (ctx->is_file && ctx->index) {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_PLAYBACK_MODE, & PROP_UINT(GF_PLAYBACK_MODE_FASTFORWARD) );\n\t}\n}\n\nstatic Bool ac3dmx_process_event(GF_Filter *filter, const GF_FilterEvent *evt)\n{\n\tu32 i;\n\tGF_FilterEvent fevt;\n\tGF_AC3DmxCtx *ctx = gf_filter_get_udta(filter);\n\n\tswitch (evt->base.type) {\n\tcase GF_FEVT_PLAY:\n\t\tif (!ctx->is_playing) {\n\t\t\tctx->is_playing = GF_TRUE;\n\t\t\tctx->cts = 0;\n\t\t}\n\t\tif (! ctx->is_file) {\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\tctx->start_range = evt->play.start_range;\n\t\tctx->in_seek = GF_TRUE;\n\t\tctx->file_pos = 0;\n\t\tif (ctx->start_range) {\n\t\t\tfor (i=1; i<ctx->index_size; i++) {\n\t\t\t\tif (ctx->indexes[i].duration>ctx->start_range) {\n\t\t\t\t\tctx->cts = (u64) (ctx->indexes[i-1].duration * ctx->sample_rate);\n\t\t\t\t\tctx->file_pos = ctx->indexes[i-1].pos;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!ctx->initial_play_done) {\n\t\t\tctx->initial_play_done = GF_TRUE;\n\t\t\t//seek will not change the current source state, don't send a seek\n\t\t\tif (!ctx->file_pos)\n\t\t\t\treturn GF_TRUE;\n\t\t}\n\t\tctx->ac3_buffer_size = 0;\n\t\tctx->resume_from = 0;\n\t\t//post a seek\n\t\tGF_FEVT_INIT(fevt, GF_FEVT_SOURCE_SEEK, ctx->ipid);\n\t\tfevt.seek.start_offset = ctx->file_pos;\n\t\tgf_filter_pid_send_event(ctx->ipid, &fevt);\n\n\t\t//cancel event\n\t\treturn GF_TRUE;\n\n\tcase GF_FEVT_STOP:\n\t\t//don't cancel event\n\t\tctx->is_playing = GF_FALSE;\n\t\tctx->cts = 0;\n\t\treturn GF_FALSE;\n\n\tcase GF_FEVT_SET_SPEED:\n\t\t//cancel event\n\t\treturn GF_TRUE;\n\tdefault:\n\t\tbreak;\n\t}\n\t//by default don't cancel event - to rework once we have downloading in place\n\treturn GF_FALSE;\n}\n\nstatic GFINLINE void ac3dmx_update_cts(GF_AC3DmxCtx *ctx)\n{\n\tif (ctx->timescale) {\n\t\tu64 inc = AC3_FRAME_SIZE;\n\t\tinc *= ctx->timescale;\n\t\tinc /= ctx->sample_rate;\n\t\tctx->cts += inc;\n\t} else {\n\t\tctx->cts += AC3_FRAME_SIZE;\n\t}\n}\n\nGF_Err ac3dmx_process(GF_Filter *filter)\n{\n\tGF_AC3DmxCtx *ctx = gf_filter_get_udta(filter);\n\tGF_FilterPacket *pck, *dst_pck;\n\tu8 *output;\n\tu8 *start;\n\tu32 pck_size, remain, prev_pck_size;\n\tu64 cts;\n\nrestart:\n\tcts = GF_FILTER_NO_TS;\n\n\t//always reparse duration\n\tif (!ctx->duration.num)\n\t\tac3dmx_check_dur(filter, ctx);\n\n\tif (ctx->opid && !ctx->is_playing)\n\t\treturn GF_OK;\n\n\tpck = gf_filter_pid_get_packet(ctx->ipid);\n\tif (!pck) {\n\t\tif (gf_filter_pid_is_eos(ctx->ipid)) {\n\t\t\tif (!ctx->ac3_buffer_size) {\n\t\t\t\tif (ctx->opid)\n\t\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\t\t\tctx->src_pck = NULL;\n\t\t\t\treturn GF_EOS;\n\t\t\t}\n\t\t} else {\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\tprev_pck_size = ctx->ac3_buffer_size;\n\tif (pck && !ctx->resume_from) {\n\t\tconst u8 *data = gf_filter_pck_get_data(pck, &pck_size);\n\t\tif (!pck_size) {\n\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\treturn GF_OK;\n\t\t}\n\n\t\t//max EAC3 frame is 4096 but we can have side streams, AC3 is 3840 - if we store more than 2 frames consider we have garbage\n\t\tif (ctx->ac3_buffer_size>100000) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[AC3Dmx] Trashing %d garbage bytes\\n\", ctx->ac3_buffer_size));\n\t\t\tctx->ac3_buffer_size = 0;\n\t\t}\n\n\t\tif (ctx->byte_offset != GF_FILTER_NO_BO) {\n\t\t\tu64 byte_offset = gf_filter_pck_get_byte_offset(pck);\n\t\t\tif (!ctx->ac3_buffer_size) {\n\t\t\t\tctx->byte_offset = byte_offset;\n\t\t\t} else if (ctx->byte_offset + ctx->ac3_buffer_size != byte_offset) {\n\t\t\t\tctx->byte_offset = GF_FILTER_NO_BO;\n\t\t\t\tif ((byte_offset != GF_FILTER_NO_BO) && (byte_offset>ctx->ac3_buffer_size) ) {\n\t\t\t\t\tctx->byte_offset = byte_offset - ctx->ac3_buffer_size;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ctx->ac3_buffer_size + pck_size > ctx->ac3_buffer_alloc) {\n\t\t\tctx->ac3_buffer_alloc = ctx->ac3_buffer_size + pck_size;\n\t\t\tctx->ac3_buffer = gf_realloc(ctx->ac3_buffer, ctx->ac3_buffer_alloc);\n\t\t}\n\t\tmemcpy(ctx->ac3_buffer + ctx->ac3_buffer_size, data, pck_size);\n\t\tctx->ac3_buffer_size += pck_size;\n\t}\n\n\t//input pid sets some timescale - we flushed pending data , update cts\n\tif (ctx->timescale && pck) {\n\t\tcts = gf_filter_pck_get_cts(pck);\n\t\t//init cts at first packet\n\t\tif (!ctx->cts && (cts != GF_FILTER_NO_TS))\n\t\t\tctx->cts = cts;\n\t}\n\n\tif (cts == GF_FILTER_NO_TS) {\n\t\t//avoids updating cts\n\t\tprev_pck_size = 0;\n\t}\n\n\tremain = ctx->ac3_buffer_size;\n\tstart = ctx->ac3_buffer;\n\n\tif (ctx->resume_from) {\n\t\tstart += ctx->resume_from - 1;\n\t\tremain -= ctx->resume_from - 1;\n\t\tctx->resume_from = 0;\n\t}\n\n\tif (!ctx->bs) {\n\t\tctx->bs = gf_bs_new(start, remain, GF_BITSTREAM_READ);\n\t} else {\n\t\tgf_bs_reassign_buffer(ctx->bs, start, remain);\n\t}\n\twhile (remain) {\n\t\tu8 *sync;\n\t\tBool res;\n\t\tu32 sync_pos, bytes_to_drop=0;\n\n\t\tres = ctx->ac3_parser_bs(ctx->bs, &ctx->hdr, GF_TRUE);\n\n\t\tsync_pos = (u32) gf_bs_get_position(ctx->bs);\n\n\t\t//if not end of stream or no valid frame\n\t\tif (pck || !ctx->hdr.framesize) {\n\t\t\t//startcode not found or not enough bytes, gather more\n\t\t\tif (!res || (remain < sync_pos + ctx->hdr.framesize)) {\n\t\t\t\tif (sync_pos && ctx->hdr.framesize) {\n\t\t\t\t\tstart += sync_pos;\n\t\t\t\t\tremain -= sync_pos;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tac3dmx_check_pid(filter, ctx);\n\t\t}\n\t\t//may happen with very-short streams\n\t\tif (!ctx->sample_rate)\n\t\t\tac3dmx_check_pid(filter, ctx);\n\n\t\tif (!ctx->is_playing) {\n\t\t\tctx->resume_from = 1 + ctx->ac3_buffer_size - remain;\n\t\t\treturn GF_OK;\n\t\t}\n\n\t\tif (sync_pos) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[AC3Dmx] %d bytes unrecovered before sync word\\n\", sync_pos));\n\t\t}\n\t\tsync = start + sync_pos;\n\n\t\tif (ctx->in_seek) {\n\t\t\tu64 nb_samples_at_seek = (u64) (ctx->start_range * ctx->hdr.sample_rate);\n\t\t\tif (ctx->cts + AC3_FRAME_SIZE >= nb_samples_at_seek) {\n\t\t\t\t//u32 samples_to_discard = (ctx->cts + ctx->dts_inc) - nb_samples_at_seek;\n\t\t\t\tctx->in_seek = GF_FALSE;\n\t\t\t}\n\t\t}\n\n\t\tbytes_to_drop = sync_pos + ctx->hdr.framesize;\n\t\tif (ctx->timescale && !prev_pck_size &&  (cts != GF_FILTER_NO_TS) ) {\n\t\t\t//trust input CTS if diff is more than one sec\n\t\t\tif ((cts > ctx->cts + ctx->timescale) || (ctx->cts > cts + ctx->timescale))\n\t\t\t\tctx->cts = cts;\n\t\t\tcts = GF_FILTER_NO_TS;\n\t\t}\n\n\t\tif (!ctx->in_seek && remain >= sync_pos + ctx->hdr.framesize) {\n\t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->hdr.framesize, &output);\n\t\t\tif (!dst_pck) return GF_OUT_OF_MEM;\n\n\t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\t\t\tmemcpy(output, sync, ctx->hdr.framesize);\n\t\t\tgf_filter_pck_set_dts(dst_pck, ctx->cts);\n\t\t\tgf_filter_pck_set_cts(dst_pck, ctx->cts);\n\t\t\tif (ctx->timescale && (ctx->timescale!=ctx->sample_rate))\n\t\t\t\tgf_filter_pck_set_duration(dst_pck, (u32) gf_timestamp_rescale(AC3_FRAME_SIZE, ctx->sample_rate, ctx->timescale));\n\t\t\telse\n\t\t\t\tgf_filter_pck_set_duration(dst_pck, AC3_FRAME_SIZE);\n\t\t\tgf_filter_pck_set_sap(dst_pck, GF_FILTER_SAP_1);\n\t\t\tgf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_TRUE);\n\n\t\t\tif (ctx->byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, ctx->byte_offset + ctx->hdr.framesize);\n\t\t\t}\n\n\t\t\tgf_filter_pck_send(dst_pck);\n\t\t}\n\t\tac3dmx_update_cts(ctx);\n\n\t\t//truncated last frame\n\t\tif (bytes_to_drop>remain) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[ADTSDmx] truncated AC3 frame!\\n\"));\n\t\t\tbytes_to_drop=remain;\n\t\t}\n\n\t\tif (!bytes_to_drop) {\n\t\t\tbytes_to_drop = 1;\n\t\t}\n\t\tstart += bytes_to_drop;\n\t\tremain -= bytes_to_drop;\n\t\tgf_bs_reassign_buffer(ctx->bs, start, remain);\n\n\t\tif (prev_pck_size) {\n\t\t\tif (prev_pck_size > bytes_to_drop) prev_pck_size -= bytes_to_drop;\n\t\t\telse {\n\t\t\t\tprev_pck_size=0;\n\t\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\t\t\tctx->src_pck = pck;\n\t\t\t\tif (pck)\n\t\t\t\t\tgf_filter_pck_ref_props(&ctx->src_pck);\n\t\t\t}\n\t\t}\n\t\tif (ctx->byte_offset != GF_FILTER_NO_BO)\n\t\t\tctx->byte_offset += bytes_to_drop;\n\t}\n\n\tif (!pck) {\n\t\tctx->ac3_buffer_size = 0;\n\t\t//avoid recursive call\n\t\tgoto restart;\n\t} else {\n\t\tif (remain && (remain < ctx->ac3_buffer_size)) {\n\t\t\tmemmove(ctx->ac3_buffer, start, remain);\n\t\t}\n\t\tctx->ac3_buffer_size = remain;\n\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t}\n\treturn GF_OK;\n}\n\nstatic void ac3dmx_finalize(GF_Filter *filter)\n{\n\tGF_AC3DmxCtx *ctx = gf_filter_get_udta(filter);\n\tif (ctx->bs) gf_bs_del(ctx->bs);\n\tif (ctx->ac3_buffer) gf_free(ctx->ac3_buffer);\n\tif (ctx->indexes) gf_free(ctx->indexes);\n}\n\nstatic const char *ac3dmx_probe_data(const u8 *_data, u32 _size, GF_FilterProbeScore *score)\n{\n\tGF_AC3Config ahdr;\n\tu32 i, nb_frames=0;\n\tBool has_broken_frames = GF_FALSE;\n\tu32 pos=0;\n\tconst u8 *data = _data;\n\tu32 size = _size;\n\tu32 nb_ac3_frames=0;\n\n\t//check AC3\n\twhile (1) {\n\t\tahdr.sample_rate = 0;\n\t\tif (! gf_ac3_parser((u8 *) data, size, &pos, &ahdr, GF_FALSE) ) {\n\t\t\tif (ahdr.sample_rate) nb_frames++;\n\t\t \tbreak;\n\t\t}\n\t\tu32 fsize = ahdr.framesize;\n\t\tif (pos) {\n\t\t\tnb_frames=0;\n\t\t\thas_broken_frames = GF_TRUE;\n\t\t\t//what is before is bigger than max ac3 frame size (1920 words), this is packaged ac3 (mkv) at best\n\t\t\tif (pos > 4000)\n\t\t\t\tbreak;\n\t\t}\n\t\tnb_frames++;\n\t\tif (fsize > size+pos) {\n\t\t\tif (!pos && (nb_frames==1)) nb_frames++;\n\t\t\tbreak;\n\t\t}\n\t\tif (nb_frames>4) break;\n\t\tif (size < fsize+pos) break;\n\t\tsize -= fsize+pos;\n\t\tdata += fsize+pos;\n\t}\n\tnb_ac3_frames = nb_frames;\n\n\t//check EAC3\n\tpos=0;\n\tdata = _data;\n\tsize = _size;\n\tnb_frames = 0;\n\tGF_BitStream *bs = gf_bs_new(data, size, GF_BITSTREAM_READ);\n\twhile (gf_bs_available(bs)) {\n\t\tahdr.sample_rate = 0;\n\t\tif (!gf_eac3_parser_bs(bs, &ahdr, GF_FALSE)) {\n\t\t\tif (ahdr.sample_rate) nb_frames++;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (pos != (u32) gf_bs_get_position(bs))\n\t\t\thas_broken_frames = GF_TRUE;\n\t\tnb_frames += ahdr.nb_streams;\n\t\tfor (i=0; i<ahdr.nb_streams; i++)\n\t\t\tnb_frames += ahdr.streams[i].nb_dep_sub ? 1 : 0;\n\t\tgf_bs_skip_bytes(bs, ahdr.framesize);\n\t\tif (!pos && (nb_frames==1) && !gf_bs_available(bs)) nb_frames++;\n\t\tpos+=ahdr.framesize;\n\t\tif (nb_frames>4) break;\n\t}\n\tgf_bs_del(bs);\n\n\tif (nb_frames<nb_ac3_frames) {\n\t\tnb_frames = 0;\n\t}\n\tif (nb_ac3_frames>=2) {\n\t\t*score = has_broken_frames ? GF_FPROBE_MAYBE_NOT_SUPPORTED : GF_FPROBE_SUPPORTED;\n\t\treturn \"audio/ac3\";\n\t}\n\n\tif (nb_frames>=2) {\n\t\t*score = has_broken_frames ? GF_FPROBE_MAYBE_NOT_SUPPORTED : GF_FPROBE_SUPPORTED;\n\t\treturn \"audio/eac3\";\n\t}\n\n\treturn NULL;\n}\n\nstatic const GF_FilterCapability AC3DmxCaps[] =\n{\n\tCAP_UINT(GF_CAPS_INPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_FILE_EXT, \"ac3|eac3|ec3\"),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_MIME, \"audio/x-ac3|audio/ac3|audio/x-eac3|audio/eac3\"),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_AUDIO),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_AC3),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_EAC3),\n\tCAP_BOOL(GF_CAPS_OUTPUT_STATIC_EXCLUDED, GF_PROP_PID_UNFRAMED, GF_TRUE),\n\t{0},\n\tCAP_UINT(GF_CAPS_INPUT_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_AUDIO),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_AC3),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_EAC3),\n\tCAP_BOOL(GF_CAPS_INPUT,GF_PROP_PID_UNFRAMED, GF_TRUE),\n\t{0},\n\tCAP_UINT(GF_CAPS_INPUT_OUTPUT,GF_PROP_PID_STREAM_TYPE, GF_STREAM_ENCRYPTED),\n\tCAP_UINT(GF_CAPS_INPUT, GF_PROP_PID_PROTECTION_SCHEME_TYPE, GF_HLS_SAMPLE_AES_SCHEME),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_AC3),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_EAC3),\n\tCAP_BOOL(GF_CAPS_INPUT,GF_PROP_PID_UNFRAMED, GF_TRUE),\n};\n\n#define OFFS(_n)\t#_n, offsetof(GF_AC3DmxCtx, _n)\nstatic const GF_FilterArgs AC3DmxArgs[] =\n{\n\t{ OFFS(index), \"indexing window length\", GF_PROP_DOUBLE, \"1.0\", NULL, 0},\n\t{0}\n};\n\n\nGF_FilterRegister AC3DmxRegister = {\n\t.name = \"rfac3\",\n\tGF_FS_SET_DESCRIPTION(\"AC3 reframer\")\n\tGF_FS_SET_HELP(\"This filter parses AC3 and E-AC3 files/data and outputs corresponding audio PID and frames.\")\n\t.private_size = sizeof(GF_AC3DmxCtx),\n\t.args = AC3DmxArgs,\n\t.finalize = ac3dmx_finalize,\n\tSETCAPS(AC3DmxCaps),\n\t.configure_pid = ac3dmx_configure_pid,\n\t.process = ac3dmx_process,\n\t.probe_data = ac3dmx_probe_data,\n\t.process_event = ac3dmx_process_event\n};\n\n\nconst GF_FilterRegister *rfac3_register(GF_FilterSession *session)\n{\n\treturn &AC3DmxRegister;\n}\n#else\nconst GF_FilterRegister *rfac3_register(GF_FilterSession *session)\n{\n\treturn NULL;\n}\n#endif // !defined(GPAC_DISABLE_AV_PARSERS) && !defined(GPAC_DISABLE_RFAC3)\n"], "filenames": ["src/filters/reframe_ac3.c"], "buggy_code_start_loc": [483], "buggy_code_end_loc": [489], "fixing_code_start_loc": [483], "fixing_code_end_loc": [487], "type": "CWE-125", "message": "Out-of-bounds Read in GitHub repository gpac/gpac prior to 2.3-DEV.", "other": {"cve": {"id": "CVE-2024-0322", "sourceIdentifier": "security@huntr.dev", "published": "2024-01-08T13:15:09.557", "lastModified": "2024-01-11T17:36:34.290", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Out-of-bounds Read in GitHub repository gpac/gpac prior to 2.3-DEV."}, {"lang": "es", "value": "Fuera de los l\u00edmites Read en el repositorio de GitHub gpac/gpac anterior a 2.3-DEV."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:L/I:N/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 4.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 2.5}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.3.0", "matchCriteriaId": "8427BDFE-346D-45C9-B0BD-1F06E8825368"}, {"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:2.3.0:dev:*:*:*:*:*:*", "matchCriteriaId": "92DC0391-41BE-4FD8-BA6A-C90EE8659840"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/092904b80edbc4dce315684a59cc3184c45c1b70", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.com/bounties/87611fc9-ed7c-43e9-8e52-d83cd270bbec", "source": "security@huntr.dev", "tags": ["Exploit"]}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/092904b80edbc4dce315684a59cc3184c45c1b70"}}