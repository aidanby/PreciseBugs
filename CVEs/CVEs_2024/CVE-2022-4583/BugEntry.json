{"buggy_code": ["package org.lemsml.jlems.io.util;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.JarURLConnection;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Enumeration;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarFile;\nimport java.util.zip.ZipEntry;\n\nimport org.lemsml.jlems.ResourceRoot;\nimport org.lemsml.jlems.core.logging.E;\nimport org.lemsml.jlems.core.sim.ContentError;\n \npublic final class JUtil {\n\n   static Class<?> rootClass = ResourceRoot.class;\n\n   static String fileSep;\n   static String rootPath;\n\n   static String osarch;\n\n   static {\n      fileSep = \"/\"; // System.getProperty(\"file.separator\");\n      rootPath = \"org\" + fileSep + \"psics\";\n   }\n\n\n   private JUtil() {\n\t   \n   }\n   \n\n   public static void setResourceRoot(Class<?> cls)\n   {\n\t   rootClass=cls;\n   }\n   public static String getRelativeResource(Object obj, String path) throws ContentError {\n      return getRelativeResource(obj.getClass(), path);\n   }\n\n\n   public static String getRelativeResource(String s) throws ContentError {\n      return getRelativeResource(rootClass, s);\n   }\n\n   public static String getRelativeResource(Class<?> cls, String path) throws ContentError {\n      String sret = null;\n\n      try {\n        if (path.contains(\"..\")) {\n            path = (new File(path)).getCanonicalPath();\n        }\n        InputStream fis = cls.getResourceAsStream(path);\n        sret = readInputStream(fis);\n\n      } catch (Exception ex) {\n         throw new ContentError(\"ResourceAccess - can't get resource \" + path + \" relative to \" + cls + \": \" + ex);\n      }\n      return sret;\n   }\n\n\n\n\n\n\n   public static void copyResource(Object obj, String fnm, File fdest) throws IOException, ContentError {\n\t   String s = getRelativeResource(obj, fnm);\n\t   FileUtil.writeStringToFile(s, new File(fdest, fnm));\n   }\n\n\n   public static String getXMLResource(String path) throws ContentError {\n      String sp = null;\n      if (path.endsWith(\".xml\") || path.indexOf(\".\") < 0) {\n         E.warning(\"getXMLReousrce should have a dot path, not \" + path);\n         sp = path;\n      } else {\n     //    E.info(\"replacing dots in \" + path + \" with \" + fileSep);\n\n         sp = path.replaceAll(\"\\\\.\", fileSep) + \".xml\";\n      }\n       return getResource(sp);\n   }\n\n\n   public static String getFileResource(String path, String fnm) throws ContentError {\n      String sp = path.replaceAll(\"\\\\.\", fileSep) + fileSep + fnm;\n      return getResource(sp);\n   }\n\n\n   private static String getResource(String pathin) throws ContentError {\n\t   String path = pathin;\n      String sret = null;\n\n      try {\n         if (path.startsWith(rootPath)) {\n            path = path.substring(rootPath.length()+1, path.length());\n\n         //   E.info(\"seeking stream rel to root class \" + path + \" \" + rootClass.getName());\n            InputStream fis = rootClass.getResourceAsStream(path);\n            sret = readInputStream(fis);\n\n         } else {\n            E.warning(\"reading foreign resource from class path?\");\n            InputStream fis = ClassLoader.getSystemResourceAsStream(path);\n            sret = readInputStream(fis);\n         }\n\n      } catch (Exception ex) {\n        throw new ContentError(\"ResourceAccess - cant get \" + path + \" \" + ex);\n        \n      }\n      return sret;\n   }\n\n\n\n   private static String readInputStream(InputStream fis)\n         throws NullPointerException, IOException {\n      String sret = null;\n\n      InputStreamReader insr = new InputStreamReader(fis);\n      BufferedReader fr = new BufferedReader(insr);\n\n      StringBuffer sb = new StringBuffer();\n      while (fr.ready()) {\n         sb.append(fr.readLine());\n         sb.append(\"\\n\");\n      }\n      fr.close();\n      sret = sb.toString();\n\n      return sret;\n   }\n\n\n\n   public static void copyBinaryResource(String respathin, File dest) throws FileNotFoundException, IOException {\n      String respath = respathin;\n\t   if (dest.exists()) {\n      //   E.info(\"destination file already exists - not copying \" + dest);\n         return;\n      }\n\n     // E.info(\"installing \" + dest);\n \n         if (respath.startsWith(rootPath)) {\n            respath = respath.substring(rootPath.length()+1,respath.length());\n         }\n         extractRelativeResource(rootClass, respath, dest);\n   }\n\n\n\n   public static void extractRelativeResource(Class<?> c, String path, File dest) throws\n        FileNotFoundException, IOException {\n\t   InputStream in = c.getResourceAsStream(path);\n \t   \n       OutputStream out = new FileOutputStream(dest);\n       byte[] buf = new byte[1024];\n       int len = in.read(buf);\n       while (true) {\n          if (len > 0) {\n        \t  out.write(buf, 0, len);\n        \t  len = in.read(buf);\n          } else {\n        \t  break;\n          }\n       }\n       in.close();\n       out.close();\n   }\n\n\n \n \n  \n   public static String shortClassName(Object ov) {\n      String cnm = ov.getClass().getName();\n      cnm = cnm.substring(cnm.lastIndexOf(\".\") + 1, cnm.length());\n      return cnm;\n   }\n\n \n\n\n\n   public static void unpackJar(File fjar, File fout) throws IOException {\n    \n      JarFile jf = new JarFile(fjar);\n      Enumeration<JarEntry> en = jf.entries();\n\n      while (en.hasMoreElements()) {\n         JarEntry je = en.nextElement();\n         java.io.File f = new File(fout,  je.getName());\n         if (je.isDirectory()) {\n            f.mkdirs();\n            continue;\n\n         } else {\n            // f.getParentFile().mkdirs();\n\n            if (f.getPath().indexOf(\"META-INF\") >= 0) {\n               // skip it\n            } else {\n            f.getParentFile().mkdirs();\n            java.io.InputStream is = jf.getInputStream(je);\n            java.io.FileOutputStream fos = new FileOutputStream(f);\n\n            // EFF - buffering, file channels??\n            while (is.available() > 0) {\n               fos.write(is.read());\n            }\n            fos.close();\n            is.close();\n         }\n         }\n      }\n\n    //  E.info(\"unpacked jar to \" + fout);\n\n       \n   }\n\n\n\n   public static String absPath(Class<?> base, String pckgname) {\n\t   String rcnm = base.getName();\n\t    rcnm = rcnm.substring(0, rcnm.lastIndexOf(\".\"));\n\t    String ppath = rcnm.replace(\".\", \"/\");\n\t    String path = ppath + \"/\" + pckgname;\n\n\t    if (path.endsWith(\"/.\")) {\n\t    \tpath = path.substring(0, path.length()-2);\n\t    }\n\n\t    return path;\n   }\n\n\n\n   public static String[] getResourceList(Class<?> base, String pckgname, String ext) {\n\n\t    String path = absPath(base, pckgname);\n\n\t   \tArrayList<String> als = new ArrayList<String>();\n\t\ttry {\n\t\t\tClassLoader cld = Thread.currentThread().getContextClassLoader();\n\t\t\tURL resource = cld.getResource(path);\n\t\t\tFile dir = new File(resource.getFile());\n\n\t\t\tif (dir.exists()) {\n\t\t\t\t// we're running from the file system;\n\t\t\t\tfor (String fnm : dir.list()) {\n\t\t\t\t\tif (ext == null || fnm.endsWith(ext)) {\n\t\t\t\t\t\tals.add(fnm);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\t// we're running from a jar file;\n\t\t\t\tJarURLConnection conn = (JarURLConnection) resource.openConnection();\n\t\t\t\tString starts = conn.getEntryName();\n\t\t\t\tJarFile jfile = conn.getJarFile();\n\t\t\t\tEnumeration<JarEntry> e = jfile.entries();\n\t\t\t\twhile (e.hasMoreElements()) {\n\t\t\t\t\tZipEntry entry = e.nextElement();\n\t\t\t\t\tString entryname = entry.getName();\n\t\t\t\t\tif (entryname.startsWith(starts)\n\t\t\t\t\t\t\t&& (entryname.lastIndexOf('/') <= starts.length())) {\n\t\t\t\t\t\tString rnm = entryname.substring(starts.length()+1, entryname.length());\n\t\t\t\t\t\tif (rnm.length() > 1 && (ext == null || rnm.endsWith(ext))) {\n\t\t\t\t\t\t\tals.add(rnm);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} catch (Exception ex) {\n\t\t\tE.error(\"cant list resources? \" + ex);\n\t\t}\n\t\treturn als.toArray(new String[als.size()]);\n\t}\n\n\n\n   \tpublic static void unpackPackage(Class<?> base, String pkgname, File dir) throws FileNotFoundException, IOException {\n   \t\t \n   \t\tString[] sa = getResourceList(base, pkgname, null);\n   \t\tfor (String s : sa) {\n   \t\t\tE.info(\"resource to unpack \" + s);\n   \t\t}\n\n   \t\tfor (String s : sa) {\n   \t\t\tFile fdest = new File(dir, s);\n   \t\t\textractRelativeResource(base, pkgname + \"/\" + s, fdest);\n   \t\t}\n   \t \n   \t}\n\n\n\n\n\n\n\npublic static void showThreads() {\n\n\t   // Find the root thread group\n    ThreadGroup root = Thread.currentThread().getThreadGroup();\n    while (root.getParent() != null) {\n        root = root.getParent();\n    }\n\n    // Visit each thread group\n    visit(root, 0);\n\n}\n\n    // This method recursively visits all thread groups under `group'.\n    public static void visit(ThreadGroup group, int level) {\n        // Get threads in `group'\n        int numThreads = group.activeCount();\n        Thread[] threads = new Thread[numThreads*2];\n        numThreads = group.enumerate(threads, false);\n\n        // Enumerate each thread in `group'\n        for (int i=0; i<numThreads; i++) {\n            // Get thread\n            Thread thread = threads[i];\n            E.info(\"Thread: \" + thread.isDaemon() + \" \" + thread);\n        }\n\n        // Get thread subgroups of `group'\n        int numGroups = group.activeGroupCount();\n        ThreadGroup[] groups = new ThreadGroup[numGroups*2];\n        numGroups = group.enumerate(groups, false);\n\n        // Recursively visit each subgroup\n        for (int i=0; i<numGroups; i++) {\n            visit(groups[i], level+1);\n        }\n    }\n\n\n\tpublic static String getOSArchitecture() throws ContentError {\n\t\tif (osarch == null) {\n\t\t\tString osn = System.getProperty(\"os.name\").toLowerCase();\n\n\t\t\tif (osn.startsWith(\"linux\")) {\n\t\t\t\tosarch = \"linux\";\n\t\t\t} else if (osn.startsWith(\"mac\")) {\n\t\t\t\tosarch = \"mac\";\n\t\t\t} else if (osn.startsWith(\"windows\")) {\n\t\t\t\tosarch = \"windows\";\n\t\t\t} else {\n\t\t\t\tthrow new ContentError(\"unrecognized os \" + osn);\n\t\t\t}\n\t\t}\n\t\treturn osarch;\n\t}\n}\n\n\n"], "fixing_code": ["package org.lemsml.jlems.io.util;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.JarURLConnection;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Enumeration;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarFile;\nimport java.util.zip.ZipEntry;\n\nimport org.lemsml.jlems.ResourceRoot;\nimport org.lemsml.jlems.core.logging.E;\nimport org.lemsml.jlems.core.sim.ContentError;\n \npublic final class JUtil {\n\n   static Class<?> rootClass = ResourceRoot.class;\n\n   static String fileSep;\n   static String rootPath;\n\n   static String osarch;\n\n   static {\n      fileSep = \"/\"; // System.getProperty(\"file.separator\");\n      rootPath = \"org\" + fileSep + \"psics\";\n   }\n\n\n   private JUtil() {\n\t   \n   }\n   \n\n   public static void setResourceRoot(Class<?> cls)\n   {\n\t   rootClass=cls;\n   }\n   public static String getRelativeResource(Object obj, String path) throws ContentError {\n      return getRelativeResource(obj.getClass(), path);\n   }\n\n\n   public static String getRelativeResource(String s) throws ContentError {\n      return getRelativeResource(rootClass, s);\n   }\n\n   public static String getRelativeResource(Class<?> cls, String path) throws ContentError {\n      String sret = null;\n\n      try {\n        if (path.contains(\"..\")) {\n            path = (new File(path)).getCanonicalPath();\n        }\n        InputStream fis = cls.getResourceAsStream(path);\n        sret = readInputStream(fis);\n\n      } catch (Exception ex) {\n         throw new ContentError(\"ResourceAccess - can't get resource \" + path + \" relative to \" + cls + \": \" + ex);\n      }\n      return sret;\n   }\n\n\n\n\n\n\n   public static void copyResource(Object obj, String fnm, File fdest) throws IOException, ContentError {\n\t   String s = getRelativeResource(obj, fnm);\n\t   FileUtil.writeStringToFile(s, new File(fdest, fnm));\n   }\n\n\n   public static String getXMLResource(String path) throws ContentError {\n      String sp = null;\n      if (path.endsWith(\".xml\") || path.indexOf(\".\") < 0) {\n         E.warning(\"getXMLReousrce should have a dot path, not \" + path);\n         sp = path;\n      } else {\n     //    E.info(\"replacing dots in \" + path + \" with \" + fileSep);\n\n         sp = path.replaceAll(\"\\\\.\", fileSep) + \".xml\";\n      }\n       return getResource(sp);\n   }\n\n\n   public static String getFileResource(String path, String fnm) throws ContentError {\n      String sp = path.replaceAll(\"\\\\.\", fileSep) + fileSep + fnm;\n      return getResource(sp);\n   }\n\n\n   private static String getResource(String pathin) throws ContentError {\n\t   String path = pathin;\n      String sret = null;\n\n      try {\n         if (path.startsWith(rootPath)) {\n            path = path.substring(rootPath.length()+1, path.length());\n\n         //   E.info(\"seeking stream rel to root class \" + path + \" \" + rootClass.getName());\n            InputStream fis = rootClass.getResourceAsStream(path);\n            sret = readInputStream(fis);\n\n         } else {\n            E.warning(\"reading foreign resource from class path?\");\n            InputStream fis = ClassLoader.getSystemResourceAsStream(path);\n            sret = readInputStream(fis);\n         }\n\n      } catch (Exception ex) {\n        throw new ContentError(\"ResourceAccess - cant get \" + path + \" \" + ex);\n        \n      }\n      return sret;\n   }\n\n\n\n   private static String readInputStream(InputStream fis)\n         throws NullPointerException, IOException {\n      String sret = null;\n\n      InputStreamReader insr = new InputStreamReader(fis);\n      BufferedReader fr = new BufferedReader(insr);\n\n      StringBuffer sb = new StringBuffer();\n      while (fr.ready()) {\n         sb.append(fr.readLine());\n         sb.append(\"\\n\");\n      }\n      fr.close();\n      sret = sb.toString();\n\n      return sret;\n   }\n\n\n\n   public static void copyBinaryResource(String respathin, File dest) throws FileNotFoundException, IOException {\n      String respath = respathin;\n\t   if (dest.exists()) {\n      //   E.info(\"destination file already exists - not copying \" + dest);\n         return;\n      }\n\n     // E.info(\"installing \" + dest);\n \n         if (respath.startsWith(rootPath)) {\n            respath = respath.substring(rootPath.length()+1,respath.length());\n         }\n         extractRelativeResource(rootClass, respath, dest);\n   }\n\n\n\n   public static void extractRelativeResource(Class<?> c, String path, File dest) throws\n        FileNotFoundException, IOException {\n\t   InputStream in = c.getResourceAsStream(path);\n \t   \n       OutputStream out = new FileOutputStream(dest);\n       byte[] buf = new byte[1024];\n       int len = in.read(buf);\n       while (true) {\n          if (len > 0) {\n        \t  out.write(buf, 0, len);\n        \t  len = in.read(buf);\n          } else {\n        \t  break;\n          }\n       }\n       in.close();\n       out.close();\n   }\n\n\n \n \n  \n   public static String shortClassName(Object ov) {\n      String cnm = ov.getClass().getName();\n      cnm = cnm.substring(cnm.lastIndexOf(\".\") + 1, cnm.length());\n      return cnm;\n   }\n\n \n\n\n\n   public static void unpackJar(File fjar, File fout) throws IOException {\n    \n      JarFile jf = new JarFile(fjar);\n      Enumeration<JarEntry> en = jf.entries();\n\n      while (en.hasMoreElements()) {\n         JarEntry je = en.nextElement();\n         java.io.File f = new File(fout,  je.getName());\n\t\t\t\t\t\t\tif (!f.toPath().normalize().startsWith(fout.toPath().normalize())) {\n\t\t\t\t\t\t\t\tthrow new RuntimeException(\"Bad zip entry\");\n\t\t\t\t\t\t\t}\n         if (je.isDirectory()) {\n            f.mkdirs();\n            continue;\n\n         } else {\n            // f.getParentFile().mkdirs();\n\n            if (f.getPath().indexOf(\"META-INF\") >= 0) {\n               // skip it\n            } else {\n            f.getParentFile().mkdirs();\n            java.io.InputStream is = jf.getInputStream(je);\n            java.io.FileOutputStream fos = new FileOutputStream(f);\n\n            // EFF - buffering, file channels??\n            while (is.available() > 0) {\n               fos.write(is.read());\n            }\n            fos.close();\n            is.close();\n         }\n         }\n      }\n\n    //  E.info(\"unpacked jar to \" + fout);\n\n       \n   }\n\n\n\n   public static String absPath(Class<?> base, String pckgname) {\n\t   String rcnm = base.getName();\n\t    rcnm = rcnm.substring(0, rcnm.lastIndexOf(\".\"));\n\t    String ppath = rcnm.replace(\".\", \"/\");\n\t    String path = ppath + \"/\" + pckgname;\n\n\t    if (path.endsWith(\"/.\")) {\n\t    \tpath = path.substring(0, path.length()-2);\n\t    }\n\n\t    return path;\n   }\n\n\n\n   public static String[] getResourceList(Class<?> base, String pckgname, String ext) {\n\n\t    String path = absPath(base, pckgname);\n\n\t   \tArrayList<String> als = new ArrayList<String>();\n\t\ttry {\n\t\t\tClassLoader cld = Thread.currentThread().getContextClassLoader();\n\t\t\tURL resource = cld.getResource(path);\n\t\t\tFile dir = new File(resource.getFile());\n\n\t\t\tif (dir.exists()) {\n\t\t\t\t// we're running from the file system;\n\t\t\t\tfor (String fnm : dir.list()) {\n\t\t\t\t\tif (ext == null || fnm.endsWith(ext)) {\n\t\t\t\t\t\tals.add(fnm);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\t// we're running from a jar file;\n\t\t\t\tJarURLConnection conn = (JarURLConnection) resource.openConnection();\n\t\t\t\tString starts = conn.getEntryName();\n\t\t\t\tJarFile jfile = conn.getJarFile();\n\t\t\t\tEnumeration<JarEntry> e = jfile.entries();\n\t\t\t\twhile (e.hasMoreElements()) {\n\t\t\t\t\tZipEntry entry = e.nextElement();\n\t\t\t\t\tString entryname = entry.getName();\n\t\t\t\t\tif (entryname.startsWith(starts)\n\t\t\t\t\t\t\t&& (entryname.lastIndexOf('/') <= starts.length())) {\n\t\t\t\t\t\tString rnm = entryname.substring(starts.length()+1, entryname.length());\n\t\t\t\t\t\tif (rnm.length() > 1 && (ext == null || rnm.endsWith(ext))) {\n\t\t\t\t\t\t\tals.add(rnm);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} catch (Exception ex) {\n\t\t\tE.error(\"cant list resources? \" + ex);\n\t\t}\n\t\treturn als.toArray(new String[als.size()]);\n\t}\n\n\n\n   \tpublic static void unpackPackage(Class<?> base, String pkgname, File dir) throws FileNotFoundException, IOException {\n   \t\t \n   \t\tString[] sa = getResourceList(base, pkgname, null);\n   \t\tfor (String s : sa) {\n   \t\t\tE.info(\"resource to unpack \" + s);\n   \t\t}\n\n   \t\tfor (String s : sa) {\n   \t\t\tFile fdest = new File(dir, s);\n   \t\t\textractRelativeResource(base, pkgname + \"/\" + s, fdest);\n   \t\t}\n   \t \n   \t}\n\n\n\n\n\n\n\npublic static void showThreads() {\n\n\t   // Find the root thread group\n    ThreadGroup root = Thread.currentThread().getThreadGroup();\n    while (root.getParent() != null) {\n        root = root.getParent();\n    }\n\n    // Visit each thread group\n    visit(root, 0);\n\n}\n\n    // This method recursively visits all thread groups under `group'.\n    public static void visit(ThreadGroup group, int level) {\n        // Get threads in `group'\n        int numThreads = group.activeCount();\n        Thread[] threads = new Thread[numThreads*2];\n        numThreads = group.enumerate(threads, false);\n\n        // Enumerate each thread in `group'\n        for (int i=0; i<numThreads; i++) {\n            // Get thread\n            Thread thread = threads[i];\n            E.info(\"Thread: \" + thread.isDaemon() + \" \" + thread);\n        }\n\n        // Get thread subgroups of `group'\n        int numGroups = group.activeGroupCount();\n        ThreadGroup[] groups = new ThreadGroup[numGroups*2];\n        numGroups = group.enumerate(groups, false);\n\n        // Recursively visit each subgroup\n        for (int i=0; i<numGroups; i++) {\n            visit(groups[i], level+1);\n        }\n    }\n\n\n\tpublic static String getOSArchitecture() throws ContentError {\n\t\tif (osarch == null) {\n\t\t\tString osn = System.getProperty(\"os.name\").toLowerCase();\n\n\t\t\tif (osn.startsWith(\"linux\")) {\n\t\t\t\tosarch = \"linux\";\n\t\t\t} else if (osn.startsWith(\"mac\")) {\n\t\t\t\tosarch = \"mac\";\n\t\t\t} else if (osn.startsWith(\"windows\")) {\n\t\t\t\tosarch = \"windows\";\n\t\t\t} else {\n\t\t\t\tthrow new ContentError(\"unrecognized os \" + osn);\n\t\t\t}\n\t\t}\n\t\treturn osarch;\n\t}\n}\n\n\n"], "filenames": ["src/main/java/org/lemsml/jlems/io/util/JUtil.java"], "buggy_code_start_loc": [207], "buggy_code_end_loc": [207], "fixing_code_start_loc": [208], "fixing_code_end_loc": [211], "type": "CWE-22", "message": "A vulnerability was found in jLEMS. It has been declared as critical. Affected by this vulnerability is the function unpackJar of the file src/main/java/org/lemsml/jlems/io/util/JUtil.java. The manipulation leads to path traversal. The attack can be launched remotely. The name of the patch is 8c224637d7d561076364a9e3c2c375daeaf463dc. It is recommended to apply a patch to fix this issue. The identifier VDB-216169 was assigned to this vulnerability.", "other": {"cve": {"id": "CVE-2022-4583", "sourceIdentifier": "cna@vuldb.com", "published": "2022-12-17T13:15:09.400", "lastModified": "2023-01-03T17:57:58.537", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in jLEMS. It has been declared as critical. Affected by this vulnerability is the function unpackJar of the file src/main/java/org/lemsml/jlems/io/util/JUtil.java. The manipulation leads to path traversal. The attack can be launched remotely. The name of the patch is 8c224637d7d561076364a9e3c2c375daeaf463dc. It is recommended to apply a patch to fix this issue. The identifier VDB-216169 was assigned to this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.4}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:neuroml:jlems:*:*:*:*:*:lems:*:*", "versionEndExcluding": "2022-07-29", "matchCriteriaId": "6E60DBC1-2F15-42FA-9931-1A49349F89A8"}]}]}], "references": [{"url": "https://github.com/LEMS/jLEMS/commit/8c224637d7d561076364a9e3c2c375daeaf463dc", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/LEMS/jLEMS/pull/103", "source": "cna@vuldb.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.216169", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/LEMS/jLEMS/commit/8c224637d7d561076364a9e3c2c375daeaf463dc"}}