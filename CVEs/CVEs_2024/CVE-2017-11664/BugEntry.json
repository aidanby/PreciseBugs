{"buggy_code": ["/*\n * internal_midi.h -- Midi Wavetable Processing library\n *\n * Copyright (C) WildMIDI Developers 2001-2016\n *\n * This file is part of WildMIDI.\n *\n * WildMIDI is free software: you can redistribute and/or modify the player\n * under the terms of the GNU General Public License and you can redistribute\n * and/or modify the library under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation, either version 3 of\n * the licenses, or(at your option) any later version.\n *\n * WildMIDI is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License and\n * the GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License and the\n * GNU Lesser General Public License along with WildMIDI.  If not,  see\n * <http://www.gnu.org/licenses/>.\n */\n\n#ifndef __INTERNAL_MIDI_H\n#define __INTERNAL_MIDI_H\n\nstruct _channel {\n    uint8_t bank;\n    struct _patch *patch;\n    uint8_t hold;\n    uint8_t volume;\n    uint8_t pressure;\n    uint8_t expression;\n    int8_t  balance;\n    int8_t  pan;\n    int16_t left_adjust;\n    int16_t right_adjust;\n    int16_t pitch;\n    int16_t pitch_range;\n    int32_t pitch_adjust;\n    uint16_t reg_data;\n    uint8_t reg_non;\n    uint8_t isdrum;\n};\n\nstruct _event_data {\n    uint8_t channel;\n    union Data {\n        uint32_t value;\n        char * string;\n    } data;\n};\n\nstruct _note {\n    uint16_t noteid;\n    uint8_t velocity;\n    struct _patch *patch;\n    struct _sample *sample;\n    uint32_t sample_pos;\n    uint32_t sample_inc;\n    int32_t env_inc;\n    uint8_t env;\n    int32_t env_level;\n    uint8_t modes;\n    uint8_t hold;\n    uint8_t active;\n    struct _note *replay;\n    struct _note *next;\n    uint32_t left_mix_volume;\n    uint32_t right_mix_volume;\n    uint8_t is_off;\n    uint8_t ignore_chan_events;\n};\n\nstruct _mdi;\n\nstruct _event {\n    void (*do_event)(struct _mdi *mdi, struct _event_data *data);\n    struct _event_data event_data;\n    uint32_t samples_to_next;\n    uint32_t samples_to_next_fixed;\n};\n\nstruct _mdi {\n    int lock;\n    uint32_t samples_to_mix;\n    struct _event *events;\n    struct _event *current_event;\n    uint32_t event_count;\n    uint32_t events_size; /* try to stay optimally ahead to prevent reallocs */\n    struct _WM_Info extra_info;\n    struct _WM_Info *tmp_info;\n    uint16_t midi_master_vol;\n    struct _channel channel[16];\n    struct _note *note;\n    struct _note note_table[2][16][128];\n\n    struct _patch **patches;\n    uint32_t patch_count;\n    int16_t amp;\n\n    int32_t *mix_buffer;\n    uint32_t mix_buffer_size;\n\n    struct _rvb *reverb;\n\n    int32_t dyn_vol_peak;\n    double dyn_vol_adjust;\n    double dyn_vol;\n    double dyn_vol_to_reach;\n\n    uint8_t is_type2;\n\n    char *lyric;\n};\n\n\nextern int16_t _WM_lin_volume[];\nextern uint32_t _WM_freq_table[];\n\n/* ===================== */\n\n/*\n * All \"do\" functions need to be \"extern\" for playback\n */\nextern void _WM_do_midi_divisions(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_note_off(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_note_on(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_aftertouch(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_control_bank_select(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_control_data_entry_course(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_control_channel_volume(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_control_channel_balance(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_control_channel_pan(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_control_channel_expression(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_control_data_entry_fine(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_control_channel_hold(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_control_data_increment(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_control_data_decrement(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_control_non_registered_param_fine(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_control_non_registered_param_course(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_control_registered_param_fine(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_control_registered_param_course(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_control_channel_sound_off(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_control_channel_controllers_off(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_control_channel_notes_off(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_control_dummy(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_patch(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_channel_pressure(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_pitch(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_sysex_roland_drum_track(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_sysex_gm_reset(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_sysex_roland_reset(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_sysex_yamaha_reset(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_meta_endoftrack(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_meta_tempo(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_meta_timesignature(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_meta_keysignature(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_meta_sequenceno(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_meta_channelprefix(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_meta_portprefix(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_meta_smpteoffset(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_meta_text(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_meta_copyright(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_meta_trackname(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_meta_instrumentname(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_meta_lyric(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_meta_marker(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_meta_cuepoint(struct _mdi *mdi, struct _event_data *data);\n\n/*\n * We need to expose these fuctions for use on some or the parsers due to some\n * formats not being able to trigger these events via _WM_Setup_Midi_Event.\n */\nextern int _WM_midi_setup_noteoff(struct _mdi *mdi, uint8_t channel, uint8_t note, uint8_t velocity);\nextern int _WM_midi_setup_endoftrack(struct _mdi *mdi);\nextern int _WM_midi_setup_tempo(struct _mdi *mdi, uint32_t setting);\n\n/* ===================== */\n\n/*\n * Only non-standard midi event or non-track event setup functions need to be here\n */\nextern int _WM_midi_setup_divisions(struct _mdi *mdi, uint32_t divisions);\n\n/* ===================== */\n\n/*\n * All other declarations\n */\n\nextern struct _mdi * _WM_initMDI(void);\nextern void _WM_freeMDI(struct _mdi *mdi);\nextern uint32_t _WM_SetupMidiEvent(struct _mdi *mdi, uint8_t * event_data, uint8_t running_event);\nextern void _WM_ResetToStart(struct _mdi *mdi);\nextern void _WM_do_pan_adjust(struct _mdi *mdi, uint8_t ch);\nextern void _WM_do_note_off_extra(struct _note *nte);\n/* extern void _WM_DynamicVolumeAdjust(struct _mdi *mdi, int32_t *tmp_buffer, uint32_t buffer_used);*/\nextern void _WM_AdjustChannelVolumes(struct _mdi *mdi, uint8_t ch);\nextern float _WM_GetSamplesPerTick(uint32_t divisions, uint32_t tempo);\n\n#endif /* __INTERNAL_MIDI_H */\n\n", "/*\n * hmi.c -- Midi Wavetable Processing library\n *\n * Copyright (C) WildMIDI Developers 2001-2016\n *\n * This file is part of WildMIDI.\n *\n * WildMIDI is free software: you can redistribute and/or modify the player\n * under the terms of the GNU General Public License and you can redistribute\n * and/or modify the library under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation, either version 3 of\n * the licenses, or(at your option) any later version.\n *\n * WildMIDI is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License and\n * the GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License and the\n * GNU Lesser General Public License along with WildMIDI.  If not,  see\n * <http://www.gnu.org/licenses/>.\n */\n\n#include \"config.h\"\n\n#include <stdint.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n\n#include \"common.h\"\n#include \"wm_error.h\"\n#include \"wildmidi_lib.h\"\n#include \"internal_midi.h\"\n#include \"reverb.h\"\n#include \"f_hmi.h\"\n\n/*\n Turns hmp file data into an event stream\n */\nstruct _mdi *\n_WM_ParseNewHmi(uint8_t *hmi_data, uint32_t hmi_size) {\n    uint32_t hmi_tmp = 0;\n    uint8_t *hmi_base = hmi_data;\n    uint16_t hmi_bpm = 0;\n    uint16_t hmi_division = 0;\n\n//  uint32_t hmi_duration_secs = 0;\n    uint32_t hmi_track_cnt = 0;\n    uint32_t *hmi_track_offset = NULL;\n    uint32_t i = 0;\n    uint32_t j = 0;\n    uint8_t *hmi_addr = NULL;\n    uint32_t *hmi_track_header_length = NULL;\n    struct _mdi *hmi_mdi = NULL;\n    uint32_t tempo_f = 5000000.0;\n    uint32_t *hmi_track_end = NULL;\n    uint8_t hmi_tracks_ended = 0;\n    uint8_t *hmi_running_event = NULL;\n    uint32_t setup_ret = 0;\n    uint32_t *hmi_delta = NULL;\n\n    uint32_t smallest_delta = 0;\n    uint32_t subtract_delta = 0;\n\n    uint32_t sample_count = 0;\n    float sample_count_f = 0;\n    float sample_remainder = 0;\n\n    float samples_per_delta_f = 0.0;\n\n    struct _note {\n        uint32_t length;\n        uint8_t channel;\n    } *note;\n\n    //FIXME: This needs to be used for sanity check.\n    UNUSED(hmi_size);\n\n    if (memcmp(hmi_data, \"HMI-MIDISONG061595\", 18)) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_HMI, NULL, 0);\n        return NULL;\n    }\n\n    //FIXME: Unsure if this is correct but it seems to be the only offset that plays the files at what appears to be the right speed.\n    hmi_bpm = hmi_data[212];\n\n    hmi_division = 60;\n\n    hmi_track_cnt = hmi_data[228];\n\n    hmi_mdi = _WM_initMDI();\n\n    _WM_midi_setup_divisions(hmi_mdi, hmi_division);\n\n    if ((_WM_MixerOptions & WM_MO_ROUNDTEMPO)) {\n        tempo_f = (float) (60000000 / hmi_bpm) + 0.5f;\n    } else {\n        tempo_f = (float) (60000000 / hmi_bpm);\n    }\n    samples_per_delta_f = _WM_GetSamplesPerTick(hmi_division, (uint32_t)tempo_f);\n\n    _WM_midi_setup_tempo(hmi_mdi, (uint32_t)tempo_f);\n\n    hmi_track_offset = (uint32_t *)malloc(sizeof(uint32_t) * hmi_track_cnt);\n    hmi_track_header_length = malloc(sizeof(uint32_t) * hmi_track_cnt);\n    hmi_track_end = malloc(sizeof(uint32_t) * hmi_track_cnt);\n    hmi_delta = malloc(sizeof(uint32_t) * hmi_track_cnt);\n    note = malloc(sizeof(struct _note) * 128 * hmi_track_cnt);\n    hmi_running_event = malloc(sizeof(uint8_t) * 128 * hmi_track_cnt);\n\n    hmi_data += 370;\n\n    smallest_delta = 0xffffffff;\n\n    if (hmi_size < (370 + (hmi_track_cnt * 17))) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_HMI, \"file too short\", 0);\n        goto _hmi_end;\n    }\n\n    hmi_track_offset[0] = *hmi_data; // To keep Xcode happy\n\n    for (i = 0; i < hmi_track_cnt; i++) {\n        hmi_track_offset[i] = *hmi_data++;\n        hmi_track_offset[i] += (*hmi_data++ << 8);\n        hmi_track_offset[i] += (*hmi_data++ << 16);\n        hmi_track_offset[i] += (*hmi_data++ << 24);\n\n        if (hmi_size < (hmi_track_offset[i] + 0x5a + 4)) {\n            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_HMI, \"file too short\", 0);\n            goto _hmi_end;\n        }\n\n        hmi_addr = hmi_base + hmi_track_offset[i];\n\n        if (memcmp(hmi_addr, \"HMI-MIDITRACK\", 13)) {\n            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_HMI, NULL, 0);\n            goto _hmi_end;\n        }\n\n        hmi_track_header_length[i] = hmi_addr[0x57];\n        hmi_track_header_length[i] += (hmi_addr[0x58] << 8);\n        hmi_track_header_length[i] += (hmi_addr[0x59] << 16);\n        hmi_track_header_length[i] += (hmi_addr[0x5a] << 24);\n\n        hmi_addr += hmi_track_header_length[i];\n        hmi_track_offset[i] += hmi_track_header_length[i];\n\n        // Get tracks initial delta and set its samples_till_next;\n        hmi_delta[i] = 0;\n        if (*hmi_addr > 0x7f) {\n            do {\n                hmi_delta[i] = (hmi_delta[i] << 7) + (*hmi_addr & 0x7f);\n                hmi_addr++;\n                hmi_track_offset[i]++;\n            } while (*hmi_addr > 0x7f);\n        }\n        hmi_delta[i] = (hmi_delta[i] << 7) + (*hmi_addr & 0x7f);\n        hmi_track_offset[i]++;\n        hmi_addr++;\n\n        // Find smallest delta to work with\n        if (hmi_delta[i] < smallest_delta) {\n            smallest_delta = hmi_delta[i];\n        }\n\n        hmi_track_end[i] = 0;\n        hmi_running_event[i] = 0;\n\n        for (j = 0; j < 128; j++) {\n            hmi_tmp = (128 * i) + j;\n            note[hmi_tmp].length = 0;\n            note[hmi_tmp].channel = 0;\n        }\n    }\n\n    subtract_delta = smallest_delta;\n    sample_count_f= (((float) smallest_delta * samples_per_delta_f) + sample_remainder);\n\n    sample_count = (uint32_t) sample_count_f;\n    sample_remainder = sample_count_f - (float) sample_count;\n\n    hmi_mdi->events[hmi_mdi->event_count - 1].samples_to_next += sample_count;\n    hmi_mdi->extra_info.approx_total_samples += sample_count;\n\n    while (hmi_tracks_ended < hmi_track_cnt) {\n        smallest_delta = 0;\n        for (i = 0; i < hmi_track_cnt; i++) {\n            if (hmi_track_end[i]) continue;\n\n            // first check to see if any active notes need turning off.\n            for (j = 0; j < 128; j++) {\n                hmi_tmp = (128 * i) + j;\n                if (note[hmi_tmp].length) {\n                    note[hmi_tmp].length -= subtract_delta;\n                    if (note[hmi_tmp].length) {\n                        if ((!smallest_delta) || (smallest_delta > note[hmi_tmp].length)) {\n                            smallest_delta = note[hmi_tmp].length;\n                        }\n                    } else {\n                        _WM_midi_setup_noteoff(hmi_mdi, note[hmi_tmp].channel, j, 0);\n                    }\n                }\n            }\n\n            if (hmi_delta[i]) {\n                hmi_delta[i] -= subtract_delta;\n                if (hmi_delta[i]) {\n                    if ((!smallest_delta) || (smallest_delta > hmi_delta[i])) {\n                        smallest_delta = hmi_delta[i];\n                    }\n                    continue;\n                }\n            }\n\n            do {\n                hmi_data = hmi_base + hmi_track_offset[i];\n                hmi_delta[i] = 0;\n\n                if (hmi_data[0] == 0xfe) {\n                    // HMI only event of some sort.\n                    if (hmi_data[1] == 0x10) {\n                        hmi_tmp = (hmi_data[4] + 5);\n                        hmi_data += hmi_tmp;\n                        hmi_track_offset[i] += hmi_tmp;\n                    } else if (hmi_data[1] == 0x15) {\n                        hmi_data += 4;\n                        hmi_track_offset[i] += 4;\n                    }\n                    hmi_data += 4;\n                    hmi_track_offset[i] += 4;\n                } else {\n                    if ((setup_ret = _WM_SetupMidiEvent(hmi_mdi,hmi_data,hmi_running_event[i])) == 0) {\n                        goto _hmi_end;\n                    }\n                    if ((hmi_data[0] == 0xff) && (hmi_data[1] == 0x2f) && (hmi_data[2] == 0x00)) {\n                        hmi_track_end[i] = 1;\n                        hmi_tracks_ended++;\n                        for(j = 0; j < 128; j++) {\n                            hmi_tmp = (128 * i) + j;\n                            if (note[hmi_tmp].length) {\n                                _WM_midi_setup_noteoff(hmi_mdi, note[hmi_tmp].channel, j, 0);\n                                note[hmi_tmp].length = 0;\n                            }\n                        }\n                        goto _hmi_next_track;\n                    }\n                    // Running event\n                    // 0xff does not alter running event\n                    if ((*hmi_data == 0xF0) || (*hmi_data == 0xF7)) {\n                        // Sysex resets running event data\n                        hmi_running_event[i] = 0;\n                    } else if (*hmi_data < 0xF0) {\n                        // MIDI events 0x80 to 0xEF set running event\n                        if (*hmi_data >= 0x80) {\n                            hmi_running_event[i] = *hmi_data;\n                        }\n                    }\n                    if ((hmi_running_event[i] & 0xf0) == 0x90) {\n                        // note on has extra data to specify how long the note is.\n                        if (*hmi_data > 127) {\n                            hmi_tmp = hmi_data[1];\n                        } else {\n                            hmi_tmp = *hmi_data;\n                        }\n                        hmi_tmp += (i * 128);\n\n                        note[hmi_tmp].channel = hmi_running_event[i] & 0xf;\n\n                        hmi_data += setup_ret;\n                        hmi_track_offset[i] += setup_ret;\n\n                        note[hmi_tmp].length = 0;\n                        if (*hmi_data > 0x7f) {\n                            do {\n                                note[hmi_tmp].length = (note[hmi_tmp].length << 7) | (*hmi_data & 0x7F);\n                                hmi_data++;\n                                hmi_track_offset[i]++;\n                            } while (*hmi_data > 0x7F);\n                        }\n                        note[hmi_tmp].length = (note[hmi_tmp].length << 7) | (*hmi_data & 0x7F);\n                        hmi_data++;\n                        hmi_track_offset[i]++;\n\n                        if (note[hmi_tmp].length) {\n                            if ((!smallest_delta) || (smallest_delta > note[hmi_tmp].length)) {\n                                smallest_delta = note[hmi_tmp].length;\n                            }\n                        } else {\n                            _WM_midi_setup_noteoff(hmi_mdi, note[hmi_tmp].channel, j, 0);\n                        }\n\n                    } else {\n                        hmi_data += setup_ret;\n                        hmi_track_offset[i] += setup_ret;\n                    }\n                }\n\n                // get track delta\n                // hmi_delta[i] = 0; // set at start of loop\n                if (*hmi_data > 0x7f) {\n                    do {\n                        hmi_delta[i] = (hmi_delta[i] << 7) | (*hmi_data & 0x7F);\n                        hmi_data++;\n                        hmi_track_offset[i]++;\n                    } while (*hmi_data > 0x7F);\n                }\n                hmi_delta[i] = (hmi_delta[i] << 7) | (*hmi_data & 0x7F);\n                hmi_data++;\n                hmi_track_offset[i]++;\n            } while (!hmi_delta[i]);\n            if ((!smallest_delta) || (smallest_delta > hmi_delta[i])) {\n                smallest_delta = hmi_delta[i];\n            }\n\n        _hmi_next_track:\n            hmi_tmp = 0;\n            UNUSED(hmi_tmp);\n        }\n\n        // convert smallest delta to samples till next\n        subtract_delta = smallest_delta;\n        sample_count_f= (((float) smallest_delta * samples_per_delta_f) + sample_remainder);\n\n        sample_count = (uint32_t) sample_count_f;\n        sample_remainder = sample_count_f - (float) sample_count;\n\n        hmi_mdi->events[hmi_mdi->event_count - 1].samples_to_next += sample_count;\n        hmi_mdi->extra_info.approx_total_samples += sample_count;\n    }\n\n    if ((hmi_mdi->reverb = _WM_init_reverb(_WM_SampleRate, _WM_reverb_room_width, _WM_reverb_room_length, _WM_reverb_listen_posx, _WM_reverb_listen_posy)) == NULL) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_MEM, \"to init reverb\", 0);\n        goto _hmi_end;\n    }\n\n    hmi_mdi->extra_info.current_sample = 0;\n    hmi_mdi->current_event = &hmi_mdi->events[0];\n    hmi_mdi->samples_to_mix = 0;\n    hmi_mdi->note = NULL;\n\n    _WM_ResetToStart(hmi_mdi);\n\n_hmi_end:\n    free(hmi_track_offset);\n    free(hmi_track_header_length);\n    free(hmi_track_end);\n    free(hmi_delta);\n    free(note);\n    free(hmi_running_event);\n\n    if (hmi_mdi->reverb) return (hmi_mdi);\n    _WM_freeMDI(hmi_mdi);\n    return 0;\n}\n", "/*\n * hmp.c -- Midi Wavetable Processing library\n *\n * Copyright (C) WildMIDI Developers 2001-2016\n *\n * This file is part of WildMIDI.\n *\n * WildMIDI is free software: you can redistribute and/or modify the player\n * under the terms of the GNU General Public License and you can redistribute\n * and/or modify the library under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation, either version 3 of\n * the licenses, or(at your option) any later version.\n *\n * WildMIDI is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License and\n * the GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License and the\n * GNU Lesser General Public License along with WildMIDI.  If not,  see\n * <http://www.gnu.org/licenses/>.\n */\n\n#include \"config.h\"\n\n#include <stdint.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n\n#include \"common.h\"\n#include \"wm_error.h\"\n#include \"wildmidi_lib.h\"\n#include \"internal_midi.h\"\n#include \"reverb.h\"\n#include \"f_hmp.h\"\n\n/*\n Turns hmp file data into an event stream\n */\nstruct _mdi *\n_WM_ParseNewHmp(uint8_t *hmp_data, uint32_t hmp_size) {\n    uint8_t is_hmp2 = 0;\n    uint32_t zero_cnt = 0;\n    uint32_t i = 0;\n    uint32_t hmp_file_length = 0;\n    uint32_t hmp_chunks = 0;\n    uint32_t hmp_divisions = 0;\n    uint32_t hmp_unknown = 0;\n    uint32_t hmp_bpm = 0;\n    uint32_t hmp_song_time = 0;\n    struct _mdi *hmp_mdi;\n    uint8_t **hmp_chunk;\n    uint32_t *chunk_length;\n    uint32_t *chunk_ofs;\n    uint32_t *chunk_delta;\n    uint8_t *chunk_end;\n    uint32_t chunk_num = 0;\n    uint32_t hmp_track = 0;\n//  uint32_t j = 0;\n    uint32_t smallest_delta = 0;\n    uint32_t subtract_delta = 0;\n//  uint32_t chunks_finished = 0;\n    uint32_t end_of_chunks = 0;\n    uint32_t var_len_shift = 0;\n\n    float tempo_f = 500000.0;\n    float samples_per_delta_f = 0.0;\n\n//  uint8_t hmp_event = 0;\n//  uint8_t hmp_channel = 0;\n\n    uint32_t sample_count = 0;\n    float sample_count_f = 0;\n    float sample_remainder = 0;\n\n    if (memcmp(hmp_data, \"HMIMIDIP\", 8)) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_HMP, NULL, 0);\n        return NULL;\n    }\n    hmp_data += 8;\n    hmp_size -= 8;\n\n    if (!memcmp(hmp_data, \"013195\", 6)) {\n        hmp_data += 6;\n        hmp_size -= 6;\n        is_hmp2 = 1;\n    }\n\n    // should be a bunch of \\0's\n    if (is_hmp2) {\n        zero_cnt = 18;\n    } else {\n        zero_cnt = 24;\n    }\n    for (i = 0; i < zero_cnt; i++) {\n        if (hmp_data[i] != 0) {\n            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_HMP, NULL, 0);\n            return NULL;\n        }\n    }\n    hmp_data += zero_cnt;\n    hmp_size -= zero_cnt;\n\n    hmp_file_length = *hmp_data++;\n    hmp_file_length += (*hmp_data++ << 8);\n    hmp_file_length += (*hmp_data++ << 16);\n    hmp_file_length += (*hmp_data++ << 24);\n    hmp_size -= 4;\n\n    UNUSED(hmp_file_length);\n\n    // Next 12 bytes are normally \\0 so skipping over them\n    hmp_data += 12;\n    hmp_size -= 12;\n\n    hmp_chunks = *hmp_data++;\n    hmp_chunks += (*hmp_data++ << 8);\n    hmp_chunks += (*hmp_data++ << 16);\n    hmp_chunks += (*hmp_data++ << 24);\n    hmp_size -= 4;\n\n    // Still decyphering what this is\n    hmp_unknown = *hmp_data++;\n    hmp_unknown += (*hmp_data++ << 8);\n    hmp_unknown += (*hmp_data++ << 16);\n    hmp_unknown += (*hmp_data++ << 24);\n    hmp_size -= 4;\n\n    UNUSED(hmp_unknown);\n\n    // Defaulting: experimenting has found this to be the ideal value\n    hmp_divisions = 60;\n\n    // Beats per minute\n    hmp_bpm = *hmp_data++;\n    hmp_bpm += (*hmp_data++ << 8);\n    hmp_bpm += (*hmp_data++ << 16);\n    hmp_bpm += (*hmp_data++ << 24);\n    hmp_size -= 4;\n\n    /* Slow but needed for accuracy */\n    if ((_WM_MixerOptions & WM_MO_ROUNDTEMPO)) {\n        tempo_f = (float) (60000000 / hmp_bpm) + 0.5f;\n    } else {\n        tempo_f = (float) (60000000 / hmp_bpm);\n    }\n\n    samples_per_delta_f = _WM_GetSamplesPerTick(hmp_divisions, tempo_f);\n\n    //DEBUG\n    //fprintf(stderr, \"DEBUG: Samples Per Delta Tick: %f\\r\\n\",samples_per_delta_f);\n\n    // FIXME: This value is incorrect\n    hmp_song_time = *hmp_data++;\n    hmp_song_time += (*hmp_data++ << 8);\n    hmp_song_time += (*hmp_data++ << 16);\n    hmp_song_time += (*hmp_data++ << 24);\n    hmp_size -= 4;\n\n    // DEBUG\n    //fprintf(stderr,\"DEBUG: ??DIVISIONS??: %u, BPM: %u, ??SONG TIME??: %u:%.2u\\r\\n\",hmp_divisions, hmp_bpm, (hmp_song_time / 60), (hmp_song_time % 60));\n\n    UNUSED(hmp_song_time);\n\n    if (is_hmp2) {\n        hmp_data += 840;\n        hmp_size -= 840;\n    } else {\n        hmp_data += 712;\n        hmp_size -= 712;\n    }\n\n    hmp_mdi = _WM_initMDI();\n\n    _WM_midi_setup_divisions(hmp_mdi, hmp_divisions);\n    _WM_midi_setup_tempo(hmp_mdi, (uint32_t)tempo_f);\n\n    hmp_chunk = malloc(sizeof(uint8_t *) * hmp_chunks);\n    chunk_length = malloc(sizeof(uint32_t) * hmp_chunks);\n    chunk_delta = malloc(sizeof(uint32_t) * hmp_chunks);\n    chunk_ofs = malloc(sizeof(uint32_t) * hmp_chunks);\n    chunk_end = malloc(sizeof(uint8_t) * hmp_chunks);\n\n    smallest_delta = 0xffffffff;\n    // store chunk info for use, and check chunk lengths\n    for (i = 0; i < hmp_chunks; i++) {\n        hmp_chunk[i] = hmp_data;\n        chunk_ofs[i] = 0;\n\n        chunk_num = *hmp_data++;\n        chunk_num += (*hmp_data++ << 8);\n        chunk_num += (*hmp_data++ << 16);\n        chunk_num += (*hmp_data++ << 24);\n        chunk_ofs[i] += 4;\n\n        UNUSED(chunk_num);\n\n        chunk_length[i] = *hmp_data++;\n        chunk_length[i] += (*hmp_data++ << 8);\n        chunk_length[i] += (*hmp_data++ << 16);\n        chunk_length[i] += (*hmp_data++ << 24);\n        chunk_ofs[i] += 4;\n\n        if (chunk_length[i] > hmp_size) {\n            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_HMP, \"file too short\", 0);\n            goto _hmp_end;\n        }\n        hmp_size -= chunk_length[i];\n\n        hmp_track = *hmp_data++;\n        hmp_track += (*hmp_data++ << 8);\n        hmp_track += (*hmp_data++ << 16);\n        hmp_track += (*hmp_data++ << 24);\n        chunk_ofs[i] += 4;\n\n        UNUSED(hmp_track);\n\n        // Start of Midi Data\n        chunk_delta[i] = 0;\n        var_len_shift = 0;\n        if (*hmp_data < 0x80) {\n            do {\n                chunk_delta[i] = chunk_delta[i] | ((*hmp_data++ & 0x7F) << var_len_shift);\n                var_len_shift += 7;\n                chunk_ofs[i]++;\n            } while (*hmp_data < 0x80);\n        }\n        chunk_delta[i] = chunk_delta[i] | ((*hmp_data++ & 0x7F) << var_len_shift);\n        chunk_ofs[i]++;\n\n        if (chunk_delta[i] < smallest_delta) {\n            smallest_delta = chunk_delta[i];\n        }\n\n        // goto start of next chunk\n        hmp_data = hmp_chunk[i] + chunk_length[i];\n        hmp_chunk[i] += chunk_ofs[i]++;\n        chunk_end[i] = 0;\n    }\n\n    subtract_delta = smallest_delta;\n    sample_count_f = (((float) smallest_delta * samples_per_delta_f) + sample_remainder);\n\n    sample_count = (uint32_t) sample_count_f;\n    sample_remainder = sample_count_f - (float) sample_count;\n\n    hmp_mdi->events[hmp_mdi->event_count - 1].samples_to_next += sample_count;\n    hmp_mdi->extra_info.approx_total_samples += sample_count;\n\n    while (end_of_chunks < hmp_chunks) {\n        smallest_delta = 0;\n\n        // DEBUG\n        // fprintf(stderr,\"DEBUG: Delta Ticks: %u\\r\\n\",subtract_delta);\n\n        for (i = 0; i < hmp_chunks; i++) {\n            if (chunk_end[i])\n                continue;\n\n            if (chunk_delta[i]) {\n                chunk_delta[i] -= subtract_delta;\n                if (chunk_delta[i]) {\n                    if ((!smallest_delta)\n                        || (smallest_delta > chunk_delta[i])) {\n                        smallest_delta = chunk_delta[i];\n                    }\n                    continue;\n                }\n            }\n            do {\n                if (((hmp_chunk[i][0] & 0xf0) == 0xb0 ) && ((hmp_chunk[i][1] == 110) || (hmp_chunk[i][1] == 111)) && (hmp_chunk[i][2] > 0x7f)) {\n                    // Reserved for loop markers\n                    // TODO: still deciding what to do about these\n                    hmp_chunk[i] += 3;\n                } else {\n                    uint32_t setup_ret = 0;\n\n                    if ((setup_ret = _WM_SetupMidiEvent(hmp_mdi, hmp_chunk[i], 0)) == 0) {\n                        goto _hmp_end;\n                    }\n\n                    if ((hmp_chunk[i][0] == 0xff) && (hmp_chunk[i][1] == 0x2f) && (hmp_chunk[i][2] == 0x00)) {\n                        /* End of Chunk */\n                        end_of_chunks++;\n                        chunk_end[i] = 1;\n                        hmp_chunk[i] += 3;\n                        goto NEXT_CHUNK;\n                    } else if ((hmp_chunk[i][0] == 0xff) && (hmp_chunk[i][1] == 0x51) && (hmp_chunk[i][2] == 0x03)) {\n                        /* Tempo */\n                        tempo_f = (float)((hmp_chunk[i][3] << 16) + (hmp_chunk[i][4] << 8)+ hmp_chunk[i][5]);\n                        if (tempo_f == 0.0)\n                            tempo_f = 500000.0;\n\n                        // DEBUG\n                        fprintf(stderr,\"DEBUG: Tempo change %f\\r\\n\", tempo_f);\n                    }\n                    hmp_chunk[i] += setup_ret;\n                }\n                var_len_shift = 0;\n                chunk_delta[i] = 0;\n                if (*hmp_chunk[i] < 0x80) {\n                    do {\n                        chunk_delta[i] = chunk_delta[i] + ((*hmp_chunk[i] & 0x7F) << var_len_shift);\n                        var_len_shift += 7;\n                        hmp_chunk[i]++;\n                    } while (*hmp_chunk[i] < 0x80);\n                }\n                chunk_delta[i] = chunk_delta[i] + ((*hmp_chunk[i] & 0x7F) << var_len_shift);\n                hmp_chunk[i]++;\n            } while (!chunk_delta[i]);\n\n            if ((!smallest_delta) || (smallest_delta > chunk_delta[i])) {\n                smallest_delta = chunk_delta[i];\n            }\n        NEXT_CHUNK: continue;\n        }\n\n        subtract_delta = smallest_delta;\n        sample_count_f= (((float) smallest_delta * samples_per_delta_f) + sample_remainder);\n\n        sample_count = (uint32_t) sample_count_f;\n        sample_remainder = sample_count_f - (float) sample_count;\n\n        hmp_mdi->events[hmp_mdi->event_count - 1].samples_to_next += sample_count;\n        hmp_mdi->extra_info.approx_total_samples += sample_count;\n\n        // DEBUG\n        // fprintf(stderr,\"DEBUG: Sample Count %u\\r\\n\",sample_count);\n    }\n\n    if ((hmp_mdi->reverb = _WM_init_reverb(_WM_SampleRate, _WM_reverb_room_width, _WM_reverb_room_length, _WM_reverb_listen_posx, _WM_reverb_listen_posy)) == NULL) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_MEM, \"to init reverb\", 0);\n        goto _hmp_end;\n    }\n\n    hmp_mdi->extra_info.current_sample = 0;\n    hmp_mdi->current_event = &hmp_mdi->events[0];\n    hmp_mdi->samples_to_mix = 0;\n    hmp_mdi->note = NULL;\n\n    _WM_ResetToStart(hmp_mdi);\n\n_hmp_end:\n    free(hmp_chunk);\n    free(chunk_length);\n    free(chunk_delta);\n    free(chunk_ofs);\n    free(chunk_end);\n    if (hmp_mdi->reverb) return (hmp_mdi);\n    _WM_freeMDI(hmp_mdi);\n    return NULL;\n}\n", "/*\n * midi.c -- Midi Wavetable Processing library\n *\n * Copyright (C) WildMIDI Developers 2001-2016\n *\n * This file is part of WildMIDI.\n *\n * WildMIDI is free software: you can redistribute and/or modify the player\n * under the terms of the GNU General Public License and you can redistribute\n * and/or modify the library under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation, either version 3 of\n * the licenses, or(at your option) any later version.\n *\n * WildMIDI is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License and\n * the GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License and the\n * GNU Lesser General Public License along with WildMIDI.  If not,  see\n * <http://www.gnu.org/licenses/>.\n */\n\n#include \"config.h\"\n\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"common.h\"\n#include \"wm_error.h\"\n#include \"f_midi.h\"\n#include \"wildmidi_lib.h\"\n#include \"internal_midi.h\"\n#include \"reverb.h\"\n#include \"sample.h\"\n\n\nstruct _mdi *\n_WM_ParseNewMidi(uint8_t *midi_data, uint32_t midi_size) {\n    struct _mdi *mdi;\n\n    uint32_t tmp_val;\n    uint32_t midi_type;\n    uint32_t track_size;\n    uint8_t **tracks;\n    uint32_t end_of_tracks = 0;\n    uint32_t no_tracks;\n    uint32_t i;\n    uint32_t divisions = 96;\n    uint32_t tempo = 500000;\n    float samples_per_delta_f = 0.0;\n\n    uint32_t sample_count = 0;\n    float sample_count_f = 0.0;\n    float sample_remainder = 0.0;\n    uint8_t *sysex_store = NULL;\n//  uint32_t sysex_store_len = 0;\n\n    uint32_t *track_delta;\n    uint8_t *track_end;\n    uint32_t smallest_delta = 0;\n    uint32_t subtract_delta = 0;\n//  uint32_t tmp_length = 0;\n//  uint8_t current_event = 0;\n//  uint8_t current_event_ch = 0;\n    uint8_t *running_event;\n    uint32_t setup_ret = 0;\n\n    if (midi_size < 14) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(too short)\", 0);\n        return (NULL);\n    }\n\n    if (!memcmp(midi_data, \"RIFF\", 4)) {\n        if (midi_size < 34) {\n            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(too short)\", 0);\n            return (NULL);\n        }\n        midi_data += 20;\n        midi_size -= 20;\n    }\n\n    if (memcmp(midi_data, \"MThd\", 4)) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_MIDI, NULL, 0);\n        return (NULL);\n    }\n    midi_data += 4;\n    midi_size -= 4;\n\n    /*\n     * Get Midi Header Size - must always be 6\n     */\n    tmp_val = *midi_data++ << 24;\n    tmp_val |= *midi_data++ << 16;\n    tmp_val |= *midi_data++ << 8;\n    tmp_val |= *midi_data++;\n    midi_size -= 4;\n    if (tmp_val != 6) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, NULL, 0);\n        return (NULL);\n    }\n\n    /*\n     * Get Midi Format - we only support 0, 1 & 2\n     */\n    tmp_val = *midi_data++ << 8;\n    tmp_val |= *midi_data++;\n    midi_size -= 2;\n    if (tmp_val > 2) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID, NULL, 0);\n        return (NULL);\n    }\n    midi_type = tmp_val;\n\n    /*\n     * Get No. of Tracks\n     */\n    tmp_val = *midi_data++ << 8;\n    tmp_val |= *midi_data++;\n    midi_size -= 2;\n    if (tmp_val < 1) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(no tracks)\", 0);\n        return (NULL);\n    }\n    no_tracks = tmp_val;\n\n    /*\n     * Check that type 0 midi file has only 1 track\n     */\n    if ((midi_type == 0) && (no_tracks > 1)) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID, \"(expected 1 track for type 0 midi file, found more)\", 0);\n        return (NULL);\n    }\n\n    /*\n     * Get Divisions\n     */\n    divisions = *midi_data++ << 8;\n    divisions |= *midi_data++;\n    midi_size -= 2;\n    if (divisions & 0x00008000) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID, NULL, 0);\n        return (NULL);\n    }\n\n    samples_per_delta_f = _WM_GetSamplesPerTick(divisions, tempo);\n\n    mdi = _WM_initMDI();\n    _WM_midi_setup_divisions(mdi,divisions);\n\n    tracks = malloc(sizeof(uint8_t *) * no_tracks);\n    track_delta = malloc(sizeof(uint32_t) * no_tracks);\n    track_end = malloc(sizeof(uint8_t) * no_tracks);\n    running_event = malloc(sizeof(uint8_t) * no_tracks);\n\n    smallest_delta = 0xffffffff;\n    for (i = 0; i < no_tracks; i++) {\n        if (midi_size < 8) {\n            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(too short)\", 0);\n            goto _end;\n        }\n        if (memcmp(midi_data, \"MTrk\", 4) != 0) {\n            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(missing track header)\", 0);\n            goto _end;\n        }\n        midi_data += 4;\n        midi_size -= 4;\n\n        track_size = *midi_data++ << 24;\n        track_size |= *midi_data++ << 16;\n        track_size |= *midi_data++ << 8;\n        track_size |= *midi_data++;\n        midi_size -= 4;\n        if (midi_size < track_size) {\n            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(too short)\", 0);\n            goto _end;\n        }\n        if (track_size < 3) {\n            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(bad track size)\", 0);\n            goto _end;\n        }\n        if ((midi_data[track_size - 3] != 0xFF)\n                || (midi_data[track_size - 2] != 0x2F)\n                || (midi_data[track_size - 1] != 0x00)) {\n            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(missing EOT)\", 0);\n            goto _end;\n        }\n        tracks[i] = midi_data;\n        midi_data += track_size;\n        midi_size -= track_size;\n        track_end[i] = 0;\n        running_event[i] = 0;\n        track_delta[i] = 0;\n\n        while (*tracks[i] > 0x7F) {\n            track_delta[i] = (track_delta[i] << 7) + (*tracks[i] & 0x7F);\n            tracks[i]++;\n        }\n        track_delta[i] = (track_delta[i] << 7) + (*tracks[i] & 0x7F);\n        tracks[i]++;\n\n        if (midi_type == 1 ) {\n            if (track_delta[i] < smallest_delta) {\n                smallest_delta = track_delta[i];\n            }\n        } else {\n            /*\n             * Type 0 & 2 midi only needs delta from 1st track\n             * for initial sample calculations.\n             */\n            if (i == 0) smallest_delta = track_delta[i];\n        }\n    }\n\n    subtract_delta = smallest_delta;\n    sample_count_f = (((float) smallest_delta * samples_per_delta_f) + sample_remainder);\n    sample_count = (uint32_t) sample_count_f;\n    sample_remainder = sample_count_f - (float) sample_count;\n\n    mdi->events[mdi->event_count - 1].samples_to_next += sample_count;\n    mdi->extra_info.approx_total_samples += sample_count;\n\n    /*\n     * Handle type 0 & 2 the same, but type 1 differently\n     */\n    if (midi_type == 1) {\n        /* Type 1 */\n        while (end_of_tracks != no_tracks) {\n            smallest_delta = 0;\n            for (i = 0; i < no_tracks; i++) {\n                if (track_end[i])\n                    continue;\n                if (track_delta[i]) {\n                    track_delta[i] -= subtract_delta;\n                    if (track_delta[i]) {\n                        if ((!smallest_delta)\n                             || (smallest_delta > track_delta[i])) {\n                            smallest_delta = track_delta[i];\n                        }\n                        continue;\n                    }\n                }\n                do {\n                    setup_ret = _WM_SetupMidiEvent(mdi, tracks[i], running_event[i]);\n                    if (setup_ret == 0) {\n                        goto _end;\n                    }\n                    if (tracks[i][0] > 0x7f) {\n                        if (tracks[i][0] < 0xf0) {\n                            /* Events 0x80 - 0xef set running event */\n                            running_event[i] = tracks[i][0];\n                        } else if ((tracks[i][0] == 0xf0) || (tracks[i][0] == 0xf7)) {\n                            /* Sysex resets running event */\n                            running_event[i] = 0;\n                        } else if ((tracks[i][0] == 0xff) && (tracks[i][1] == 0x2f) && (tracks[i][2] == 0x00)) {\n                            /* End of Track */\n                            end_of_tracks++;\n                            track_end[i] = 1;\n                            tracks[i] += 3;\n                            goto NEXT_TRACK;\n                        } else if ((tracks[i][0] == 0xff) && (tracks[i][1] == 0x51) && (tracks[i][2] == 0x03)) {\n                            /* Tempo */\n                            tempo = (tracks[i][3] << 16) + (tracks[i][4] << 8)+ tracks[i][5];\n                            if (!tempo)\n                                tempo = 500000;\n\n                            samples_per_delta_f = _WM_GetSamplesPerTick(divisions, tempo);\n                        }\n                    }\n                    tracks[i] += setup_ret;\n\n                    if (*tracks[i] > 0x7f) {\n                        do {\n                            track_delta[i] = (track_delta[i] << 7) + (*tracks[i] & 0x7F);\n                            tracks[i]++;\n                        } while (*tracks[i] > 0x7f);\n                    }\n                    track_delta[i] = (track_delta[i] << 7) + (*tracks[i] & 0x7F);\n                    tracks[i]++;\n                } while (!track_delta[i]);\n                if ((!smallest_delta) || (smallest_delta > track_delta[i])) {\n                    smallest_delta = track_delta[i];\n                }\n            NEXT_TRACK: continue;\n            }\n\n            subtract_delta = smallest_delta;\n            sample_count_f = (((float) smallest_delta * samples_per_delta_f)\n                              + sample_remainder);\n            sample_count = (uint32_t) sample_count_f;\n            sample_remainder = sample_count_f - (float) sample_count;\n\n            mdi->events[mdi->event_count - 1].samples_to_next += sample_count;\n            mdi->extra_info.approx_total_samples += sample_count;\n        }\n    } else {\n        /* Type 0 & 2 */\n        if (midi_type == 2) {\n            mdi->is_type2 = 1;\n        }\n        sample_remainder = 0.0;\n        for (i = 0; i < no_tracks; i++) {\n            running_event[i] = 0;\n            do {\n                setup_ret = _WM_SetupMidiEvent(mdi, tracks[i], running_event[i]);\n                if (setup_ret == 0) {\n                    goto _end;\n                }\n                if (tracks[i][0] > 0x7f) {\n                    if (tracks[i][0] < 0xf0) {\n                        /* Events 0x80 - 0xef set running event */\n                        running_event[i] = tracks[i][0];\n                    } else if ((tracks[i][0] == 0xf0) || (tracks[i][0] == 0xf7)) {\n                        /* Sysex resets running event */\n                        running_event[i] = 0;\n                    } else if ((tracks[i][0] == 0xff) && (tracks[i][1] == 0x2f) && (tracks[i][2] == 0x00)) {\n                        /* End of Track */\n                        track_end[i] = 1;\n                        goto NEXT_TRACK2;\n                    } else if ((tracks[i][0] == 0xff) && (tracks[i][1] == 0x51) && (tracks[i][2] == 0x03)) {\n                        /* Tempo */\n                        tempo = (tracks[i][3] << 16) + (tracks[i][4] << 8)+ tracks[i][5];\n                        if (!tempo)\n                            tempo = 500000;\n\n                        samples_per_delta_f = _WM_GetSamplesPerTick(divisions, tempo);\n                    }\n                }\n                tracks[i] += setup_ret;\n\n                track_delta[i] = 0;\n                if (*tracks[i] > 0x7f) {\n                    do {\n                        track_delta[i] = (track_delta[i] << 7) + (*tracks[i] & 0x7F);\n                        tracks[i]++;\n                    } while (*tracks[i] > 0x7f);\n                }\n                track_delta[i] = (track_delta[i] << 7) + (*tracks[i] & 0x7F);\n                tracks[i]++;\n\n                sample_count_f = (((float) track_delta[i] * samples_per_delta_f)\n                                  + sample_remainder);\n                sample_count = (uint32_t) sample_count_f;\n                sample_remainder = sample_count_f - (float) sample_count;\n                mdi->events[mdi->event_count - 1].samples_to_next += sample_count;\n                mdi->extra_info.approx_total_samples += sample_count;\n            NEXT_TRACK2:\n                smallest_delta = track_delta[i]; /* Added just to keep Xcode happy */\n                UNUSED(smallest_delta); /* Added to just keep clang happy */\n            } while (track_end[i] == 0);\n        }\n    }\n\n    if ((mdi->reverb = _WM_init_reverb(_WM_SampleRate, _WM_reverb_room_width,\n            _WM_reverb_room_length, _WM_reverb_listen_posx, _WM_reverb_listen_posy))\n          == NULL) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_MEM, \"to init reverb\", 0);\n        goto _end;\n    }\n\n    mdi->extra_info.current_sample = 0;\n    mdi->current_event = &mdi->events[0];\n    mdi->samples_to_mix = 0;\n    mdi->note = NULL;\n\n    _WM_ResetToStart(mdi);\n\n_end:   free(sysex_store);\n    free(track_end);\n    free(track_delta);\n    free(running_event);\n    free(tracks);\n    if (mdi->reverb) return (mdi);\n    _WM_freeMDI(mdi);\n    return (NULL);\n}\n\n/*\n Convert WildMIDI's MDI events into a type 0 MIDI file.\n\n returns\n 0 = successful\n -1 = failed\n\n **out points to place to store stuff\n *outsize points to where to store byte counts\n\n NOTE: This will only write out events that we do support.\n\n *** CAUTION ***\n This will output type 0 midi file reguardless of the original file type.\n Type 2 midi files will have each original track play on the same track one\n after the other in the type 0 file.\n */\nint\n_WM_Event2Midi(struct _mdi *mdi, uint8_t **out, uint32_t *outsize) {\n    uint32_t out_ofs = 0;\n    uint8_t running_event = 0;\n    uint32_t divisions = 96;\n    uint32_t tempo = 500000;\n    float samples_per_tick = 0.0;\n    uint32_t value = 0;\n    float value_f = 0.0;\n    struct _event *event = mdi->events;\n    uint32_t track_size = 0;\n    uint32_t track_start = 0;\n    uint32_t track_count = 0;\n\n    if (!mdi->event_count) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CONVERT, \"(No events to convert)\", 0);\n        return -1;\n    }\n\n    samples_per_tick = _WM_GetSamplesPerTick(divisions, tempo);\n\n    /*\n     Note: This isn't accurate but will allow enough space for\n            events plus delta values.\n     */\n    (*out) = malloc (sizeof(uint8_t) * (mdi->event_count * 12));\n\n    /* Midi Header */\n    (*out)[0] = 'M';\n    (*out)[1] = 'T';\n    (*out)[2] = 'h';\n    (*out)[3] = 'd';\n    (*out)[4] = 0x00;\n    (*out)[5] = 0x00;\n    (*out)[6] = 0x00;\n    (*out)[7] = 0x06;\n    if ((!(_WM_MixerOptions & WM_MO_SAVEASTYPE0)) && (mdi->is_type2)) {\n        /* Type 2 */\n        (*out)[8] = 0x00;\n        (*out)[9] = 0x02;\n    } else {\n        /* Type 0 */\n        (*out)[8] = 0x00;\n        (*out)[9] = 0x00;\n    }\n    /* No. of tracks stored in 10-11 *** See below */\n    /* Division stored in 12-13 *** See below */\n    /* Track Header */\n    (*out)[14] = 'M';\n    (*out)[15] = 'T';\n    (*out)[16] = 'r';\n    (*out)[17] = 'k';\n    /* Track size stored in 18-21 *** see below */\n    out_ofs = 22;\n    track_start = out_ofs;\n    track_count++;\n\n    do {\n        /* TODO Is there a better way? */\n        if (event->do_event == _WM_do_midi_divisions) {\n            // DEBUG\n            // fprintf(stderr,\"Division: %u\\r\\n\",event->event_data.data);\n            divisions = event->event_data.data.value;\n            (*out)[12] = (divisions >> 8) & 0xff;\n            (*out)[13] = divisions & 0xff;\n            samples_per_tick = _WM_GetSamplesPerTick(divisions, tempo);\n        } else if (event->do_event == _WM_do_note_off) {\n            // DEBUG\n            // fprintf(stderr,\"Note Off: %u %.4x\\r\\n\",event->event_data.channel, event->event_data.data);\n            if (running_event != (0x80 | event->event_data.channel)) {\n                (*out)[out_ofs++] = 0x80 | event->event_data.channel;\n                running_event = (*out)[out_ofs - 1];\n            }\n            (*out)[out_ofs++] = (event->event_data.data.value >> 8) & 0xff;\n            (*out)[out_ofs++] = event->event_data.data.value & 0xff;\n        } else if (event->do_event == _WM_do_note_on) {\n            // DEBUG\n            // fprintf(stderr,\"Note On: %u %.4x\\r\\n\",event->event_data.channel, event->event_data.data);\n            if (running_event != (0x90 | event->event_data.channel)) {\n                (*out)[out_ofs++] = 0x90 | event->event_data.channel;\n                running_event = (*out)[out_ofs - 1];\n            }\n            (*out)[out_ofs++] = (event->event_data.data.value >> 8) & 0xff;\n            (*out)[out_ofs++] = event->event_data.data.value & 0xff;\n        } else if (event->do_event == _WM_do_aftertouch) {\n            // DEBUG\n            // fprintf(stderr,\"Aftertouch: %u %.4x\\r\\n\",event->event_data.channel, event->event_data.data);\n            if (running_event != (0xa0 | event->event_data.channel)) {\n                (*out)[out_ofs++] = 0xa0 | event->event_data.channel;\n                running_event = (*out)[out_ofs - 1];\n            }\n            (*out)[out_ofs++] = (event->event_data.data.value >> 8) & 0xff;\n            (*out)[out_ofs++] = event->event_data.data.value & 0xff;\n        } else if (event->do_event == _WM_do_control_bank_select) {\n            // DEBUG\n            // fprintf(stderr,\"Control Bank Select: %u %.4x\\r\\n\",event->event_data.channel, event->event_data.data);\n            if (running_event != (0xb0 | event->event_data.channel)) {\n                (*out)[out_ofs++] = 0xb0 | event->event_data.channel;\n                running_event = (*out)[out_ofs - 1];\n            }\n            (*out)[out_ofs++] = 0;\n            (*out)[out_ofs++] = event->event_data.data.value & 0xff;\n        } else if (event->do_event == _WM_do_control_data_entry_course) {\n            // DEBUG\n            // fprintf(stderr,\"Control Data Entry Course: %u %.4x\\r\\n\",event->event_data.channel, event->event_data.data);\n            if (running_event != (0xb0 | event->event_data.channel)) {\n                (*out)[out_ofs++] = 0xb0 | event->event_data.channel;\n                running_event = (*out)[out_ofs - 1];\n            }\n            (*out)[out_ofs++] = 6;\n            (*out)[out_ofs++] = event->event_data.data.value & 0xff;\n        } else if (event->do_event == _WM_do_control_channel_volume) {\n            // DEBUG\n            // fprintf(stderr,\"Control Channel Volume: %u %.4x\\r\\n\",event->event_data.channel, event->event_data.data);\n            if (running_event != (0xb0 | event->event_data.channel)) {\n                (*out)[out_ofs++] = 0xb0 | event->event_data.channel;\n                running_event = (*out)[out_ofs - 1];\n            }\n            (*out)[out_ofs++] = 7;\n            (*out)[out_ofs++] = event->event_data.data.value & 0xff;\n        } else if (event->do_event == _WM_do_control_channel_balance) {\n            // DEBUG\n            // fprintf(stderr,\"Control Channel Balance: %u %.4x\\r\\n\",event->event_data.channel, event->event_data.data);\n            if (running_event != (0xb0 | event->event_data.channel)) {\n                (*out)[out_ofs++] = 0xb0 | event->event_data.channel;\n                running_event = (*out)[out_ofs - 1];\n            }\n            (*out)[out_ofs++] = 8;\n            (*out)[out_ofs++] = event->event_data.data.value & 0xff;\n        } else if (event->do_event == _WM_do_control_channel_pan) {\n            // DEBUG\n            // fprintf(stderr,\"Control Channel Pan: %u %.4x\\r\\n\",event->event_data.channel, event->event_data.data);\n            if (running_event != (0xb0 | event->event_data.channel)) {\n                (*out)[out_ofs++] = 0xb0 | event->event_data.channel;\n                running_event = (*out)[out_ofs - 1];\n            }\n            (*out)[out_ofs++] = 10;\n            (*out)[out_ofs++] = event->event_data.data.value & 0xff;\n        } else if (event->do_event == _WM_do_control_channel_expression) {\n            // DEBUG\n            // fprintf(stderr,\"Control Channel Expression: %u %.4x\\r\\n\",event->event_data.channel, event->event_data.data);\n            if (running_event != (0xb0 | event->event_data.channel)) {\n                (*out)[out_ofs++] = 0xb0 | event->event_data.channel;\n                running_event = (*out)[out_ofs - 1];\n            }\n            (*out)[out_ofs++] = 11;\n            (*out)[out_ofs++] = event->event_data.data.value & 0xff;\n        } else if (event->do_event == _WM_do_control_data_entry_fine) {\n            // DEBUG\n            // fprintf(stderr,\"Control Data Entry Fine: %u %.4x\\r\\n\",event->event_data.channel, event->event_data.data);\n            if (running_event != (0xb0 | event->event_data.channel)) {\n                (*out)[out_ofs++] = 0xb0 | event->event_data.channel;\n                running_event = (*out)[out_ofs - 1];\n            }\n            (*out)[out_ofs++] = 38;\n            (*out)[out_ofs++] = event->event_data.data.value & 0xff;\n        } else if (event->do_event == _WM_do_control_channel_hold) {\n            // DEBUG\n            // fprintf(stderr,\"Control Channel Hold: %u %.4x\\r\\n\",event->event_data.channel, event->event_data.data);\n            if (running_event != (0xb0 | event->event_data.channel)) {\n                (*out)[out_ofs++] = 0xb0 | event->event_data.channel;\n                running_event = (*out)[out_ofs - 1];\n            }\n            (*out)[out_ofs++] = 64;\n            (*out)[out_ofs++] = event->event_data.data.value & 0xff;\n        } else if (event->do_event == _WM_do_control_data_increment) {\n            // DEBUG\n            // fprintf(stderr,\"Control Data Increment: %u %.4x\\r\\n\",event->event_data.channel, event->event_data.data);\n            if (running_event != (0xb0 | event->event_data.channel)) {\n                (*out)[out_ofs++] = 0xb0 | event->event_data.channel;\n                running_event = (*out)[out_ofs - 1];\n            }\n            (*out)[out_ofs++] = 96;\n            (*out)[out_ofs++] = event->event_data.data.value & 0xff;\n        } else if (event->do_event == _WM_do_control_data_decrement) {\n            // DEBUG\n            //fprintf(stderr,\"Control Data Decrement: %u %.4x\\r\\n\",event->event_data.channel, event->event_data.data);\n            if (running_event != (0xb0 | event->event_data.channel)) {\n                (*out)[out_ofs++] = 0xb0 | event->event_data.channel;\n                running_event = (*out)[out_ofs - 1];\n            }\n            (*out)[out_ofs++] = 97;\n            (*out)[out_ofs++] = event->event_data.data.value & 0xff;\n        } else if (event->do_event == _WM_do_control_non_registered_param_fine) {\n            // DEBUG\n            // fprintf(stderr,\"Control Non Registered Param: %u %.4x\\r\\n\",event->event_data.channel, event->event_data.data);\n            if (running_event != (0xb0 | event->event_data.channel)) {\n                (*out)[out_ofs++] = 0xb0 | event->event_data.channel;\n                running_event = (*out)[out_ofs - 1];\n            }\n            (*out)[out_ofs++] = 98;\n            (*out)[out_ofs++] = event->event_data.data.value & 0x7f;\n        } else if (event->do_event == _WM_do_control_non_registered_param_course) {\n            // DEBUG\n            // fprintf(stderr,\"Control Non Registered Param: %u %.4x\\r\\n\",event->event_data.channel, event->event_data.data);\n            if (running_event != (0xb0 | event->event_data.channel)) {\n                (*out)[out_ofs++] = 0xb0 | event->event_data.channel;\n                running_event = (*out)[out_ofs - 1];\n            }\n            (*out)[out_ofs++] = 99;\n            (*out)[out_ofs++] = (event->event_data.data.value >> 7) & 0x7f;\n        } else if (event->do_event == _WM_do_control_registered_param_fine) {\n            // DEBUG\n            // fprintf(stderr,\"Control Registered Param Fine: %u %.4x\\r\\n\",event->event_data.channel, event->event_data.data);\n            if (running_event != (0xb0 | event->event_data.channel)) {\n                (*out)[out_ofs++] = 0xb0 | event->event_data.channel;\n                running_event = (*out)[out_ofs - 1];\n            }\n            (*out)[out_ofs++] = 100;\n            (*out)[out_ofs++] = event->event_data.data.value & 0x7f;\n        } else if (event->do_event == _WM_do_control_registered_param_course) {\n            // DEBUG\n            // fprintf(stderr,\"Control Registered Param Course: %u %.4x\\r\\n\",event->event_data.channel, event->event_data.data);\n            if (running_event != (0xb0 | event->event_data.channel)) {\n                (*out)[out_ofs++] = 0xb0 | event->event_data.channel;\n                running_event = (*out)[out_ofs - 1];\n            }\n            (*out)[out_ofs++] = 101;\n            (*out)[out_ofs++] = (event->event_data.data.value >> 7) & 0x7f;\n        } else if (event->do_event == _WM_do_control_channel_sound_off) {\n            // DEBUG\n            // fprintf(stderr,\"Control Channel Sound Off: %u %.4x\\r\\n\",event->event_data.channel, event->event_data.data);\n            if (running_event != (0xb0 | event->event_data.channel)) {\n                (*out)[out_ofs++] = 0xb0 | event->event_data.channel;\n                running_event = (*out)[out_ofs - 1];\n            }\n            (*out)[out_ofs++] = 120;\n            (*out)[out_ofs++] = event->event_data.data.value & 0xff;\n        } else if (event->do_event == _WM_do_control_channel_controllers_off) {\n            // DEBUG\n            // fprintf(stderr,\"Control Channel Controllers Off: %u %.4x\\r\\n\",event->event_data.channel, event->event_data.data);\n            if (running_event != (0xb0 | event->event_data.channel)) {\n                (*out)[out_ofs++] = 0xb0 | event->event_data.channel;\n                running_event = (*out)[out_ofs - 1];\n            }\n            (*out)[out_ofs++] = 121;\n            (*out)[out_ofs++] = event->event_data.data.value & 0xff;\n        } else if (event->do_event == _WM_do_control_channel_notes_off) {\n            // DEBUG\n            // fprintf(stderr,\"Control Channel Notes Off: %u %.4x\\r\\n\",event->event_data.channel, event->event_data.data);\n            if (running_event != (0xb0 | event->event_data.channel)) {\n                (*out)[out_ofs++] = 0xb0 | event->event_data.channel;\n                running_event = (*out)[out_ofs - 1];\n            }\n            (*out)[out_ofs++] = 123;\n            (*out)[out_ofs++] = event->event_data.data.value & 0xff;\n        } else if (event->do_event == _WM_do_control_dummy) {\n            // DEBUG\n            // fprintf(stderr,\"Control Dummy Event: %u %.4x\\r\\n\",event->event_data.channel, event->event_data.data);\n            if (running_event != (0xb0 | event->event_data.channel)) {\n                (*out)[out_ofs++] = 0xb0 | event->event_data.channel;\n                running_event = (*out)[out_ofs - 1];\n            }\n            (*out)[out_ofs++] = (event->event_data.data.value >> 8) & 0xff;\n            (*out)[out_ofs++] = event->event_data.data.value & 0xff;\n        } else if (event->do_event == _WM_do_patch) {\n            // DEBUG\n            // fprintf(stderr,\"Patch: %u %.4x\\r\\n\",event->event_data.channel, event->event_data.data);\n            if (running_event != (0xc0 | event->event_data.channel)) {\n                (*out)[out_ofs++] = 0xc0 | event->event_data.channel;\n                running_event = (*out)[out_ofs - 1];\n            }\n            (*out)[out_ofs++] = event->event_data.data.value & 0xff;\n        } else if (event->do_event == _WM_do_channel_pressure) {\n            // DEBUG\n            // fprintf(stderr,\"Channel Pressure: %u %.4x\\r\\n\",event->event_data.channel, event->event_data.data);\n            if (running_event != (0xd0 | event->event_data.channel)) {\n                (*out)[out_ofs++] = 0xd0 | event->event_data.channel;\n                running_event = (*out)[out_ofs - 1];\n            }\n            (*out)[out_ofs++] = event->event_data.data.value & 0xff;\n        } else if (event->do_event == _WM_do_pitch) {\n            // DEBUG\n            // fprintf(stderr,\"Pitch: %u %.4x\\r\\n\",event->event_data.channel, event->event_data.data);\n            if (running_event != (0xe0 | event->event_data.channel)) {\n                (*out)[out_ofs++] = 0xe0 | event->event_data.channel;\n                running_event = (*out)[out_ofs - 1];\n            }\n            (*out)[out_ofs++] = event->event_data.data.value & 0x7f;\n            (*out)[out_ofs++] = (event->event_data.data.value >> 7) & 0x7f;\n        } else if (event->do_event == _WM_do_sysex_roland_drum_track) {\n            // DEBUG\n            // fprintf(stderr,\"Sysex Roland Drum Track: %u %.4x\\r\\n\",event->event_data.channel, event->event_data.data);\n            uint8_t foo[] = {0xf0, 0x09, 0x41, 0x10, 0x42, 0x12, 0x40, 0x00, 0x15, 0x00, 0xf7};\n            uint8_t foo_ch = event->event_data.channel;\n            if (foo_ch == 9) {\n                foo_ch = 0;\n            } else if (foo_ch < 9) {\n                foo_ch++;\n            }\n            foo[7] = 0x10 | foo_ch;\n            foo[9] = event->event_data.data.value;\n            memcpy(&((*out)[out_ofs]),foo,11);\n            out_ofs += 11;\n            running_event = 0;\n        } else if (event->do_event == _WM_do_sysex_gm_reset) {\n            // DEBUG\n            // fprintf(stderr,\"Sysex GM Reset\\r\\n\");\n            uint8_t foo[] = {0xf0, 0x05, 0x7e, 0x7f, 0x09, 0x01, 0xf7};\n            memcpy(&((*out)[out_ofs]),foo,7);\n            out_ofs += 7;\n            running_event = 0;\n        } else if (event->do_event == _WM_do_sysex_roland_reset) {\n            // DEBUG\n            // fprintf(stderr,\"Sysex Roland Reset\\r\\n\");\n            uint8_t foo[] = {0xf0, 0x0a, 0x41, 0x10, 0x42, 0x12, 0x40, 0x00, 0x7f, 0x00, 0x41, 0xf7};\n            memcpy(&((*out)[out_ofs]),foo,12);\n            out_ofs += 12;\n            running_event = 0;\n        } else if (event->do_event == _WM_do_sysex_yamaha_reset) {\n            // DEBUG\n            // fprintf(stderr,\"Sysex Yamaha Reset\\r\\n\");\n            uint8_t foo[] = {0xf0, 0x08, 0x43, 0x10, 0x4c, 0x00, 0x00, 0x7e, 0x00, 0xf7};\n            memcpy(&((*out)[out_ofs]),foo,10);\n            out_ofs += 10;\n            running_event = 0;\n        } else if (event->do_event == _WM_do_meta_endoftrack) {\n            // DEBUG\n            // fprintf(stderr,\"End Of Track\\r\\n\");\n            if ((!(_WM_MixerOptions & WM_MO_SAVEASTYPE0)) && (mdi->is_type2)) {\n                /* Write end of track marker */\n                (*out)[out_ofs++] = 0xff;\n                (*out)[out_ofs++] = 0x2f;\n                (*out)[out_ofs++] = 0x00;\n                track_size = out_ofs - track_start;\n                (*out)[track_start - 4] = (track_size >> 24) & 0xff;\n                (*out)[track_start - 3] = (track_size >> 16) & 0xff;\n                (*out)[track_start - 2] = (track_size >> 8) & 0xff;\n                (*out)[track_start - 1] = track_size & 0xff;\n\n                if (event[1].do_event != NULL) {\n                    (*out)[out_ofs++] = 'M';\n                    (*out)[out_ofs++] = 'T';\n                    (*out)[out_ofs++] = 'r';\n                    (*out)[out_ofs++] = 'k';\n                    track_count++;\n                    out_ofs += 4;\n                    track_start = out_ofs;\n\n                    /* write out a 0 delta */\n                    (*out)[out_ofs++] = 0;\n\n                    running_event = 0;\n                }\n            }\n            goto NEXT_EVENT;\n        } else if (event->do_event == _WM_do_meta_tempo) {\n            // DEBUG\n            // fprintf(stderr,\"Tempo: %u\\r\\n\",event->event_data.data);\n            tempo = event->event_data.data.value & 0xffffff;\n\n            samples_per_tick = _WM_GetSamplesPerTick(divisions, tempo);\n\n            //DEBUG\n            //fprintf(stderr,\"\\rDEBUG: div %i, tempo %i, bpm %f, pps %f, spd %f\\r\\n\", divisions, tempo, bpm_f, pulses_per_second_f, samples_per_delta_f);\n\n            (*out)[out_ofs++] = 0xff;\n            (*out)[out_ofs++] = 0x51;\n            (*out)[out_ofs++] = 0x03;\n            (*out)[out_ofs++] = (tempo & 0xff0000) >> 16;\n            (*out)[out_ofs++] = (tempo & 0xff00) >> 8;\n            (*out)[out_ofs++] = (tempo & 0xff);\n        } else if (event->do_event == _WM_do_meta_timesignature) {\n            // DEBUG\n            // fprintf(stderr,\"Time Signature: %x\\r\\n\",event->event_data.data);\n            (*out)[out_ofs++] = 0xff;\n            (*out)[out_ofs++] = 0x58;\n            (*out)[out_ofs++] = 0x04;\n            (*out)[out_ofs++] = (event->event_data.data.value & 0xff000000) >> 24;\n            (*out)[out_ofs++] = (event->event_data.data.value & 0xff0000) >> 16;\n            (*out)[out_ofs++] = (event->event_data.data.value & 0xff00) >> 8;\n            (*out)[out_ofs++] = (event->event_data.data.value & 0xff);\n        } else if (event->do_event == _WM_do_meta_keysignature) {\n            // DEBUG\n            // fprintf(stderr,\"Key Signature: %x\\r\\n\",event->event_data.data);\n            (*out)[out_ofs++] = 0xff;\n            (*out)[out_ofs++] = 0x59;\n            (*out)[out_ofs++] = 0x02;\n            (*out)[out_ofs++] = (event->event_data.data.value & 0xff00) >> 8;\n            (*out)[out_ofs++] = (event->event_data.data.value & 0xff);\n        } else if (event->do_event == _WM_do_meta_sequenceno) {\n            // DEBUG\n            // fprintf(stderr,\"Sequence Number: %x\\r\\n\",event->event_data.data);\n            (*out)[out_ofs++] = 0xff;\n            (*out)[out_ofs++] = 0x00;\n            (*out)[out_ofs++] = 0x02;\n            (*out)[out_ofs++] = (event->event_data.data.value & 0xff00) >> 8;\n            (*out)[out_ofs++] = (event->event_data.data.value & 0xff);\n        } else if (event->do_event == _WM_do_meta_channelprefix) {\n            // DEBUG\n            // fprintf(stderr,\"Channel Prefix: %x\\r\\n\",event->event_data.data);\n            (*out)[out_ofs++] = 0xff;\n            (*out)[out_ofs++] = 0x20;\n            (*out)[out_ofs++] = 0x01;\n            (*out)[out_ofs++] = (event->event_data.data.value & 0xff);\n        } else if (event->do_event == _WM_do_meta_portprefix) {\n            // DEBUG\n            // fprintf(stderr,\"Port Prefix: %x\\r\\n\",event->event_data.data);\n            (*out)[out_ofs++] = 0xff;\n            (*out)[out_ofs++] = 0x21;\n            (*out)[out_ofs++] = 0x01;\n            (*out)[out_ofs++] = (event->event_data.data.value & 0xff);\n        } else if (event->do_event == _WM_do_meta_smpteoffset) {\n            // DEBUG\n            // fprintf(stderr,\"SMPTE Offset: %x\\r\\n\",event->event_data.data);\n            (*out)[out_ofs++] = 0xff;\n            (*out)[out_ofs++] = 0x54;\n            (*out)[out_ofs++] = 0x05;\n            /*\n             Remember because of the 5 bytes we stored it a little hacky.\n             */\n            (*out)[out_ofs++] = (event->event_data.channel & 0xff);\n            (*out)[out_ofs++] = (event->event_data.data.value & 0xff000000) >> 24;\n            (*out)[out_ofs++] = (event->event_data.data.value & 0xff0000) >> 16;\n            (*out)[out_ofs++] = (event->event_data.data.value & 0xff00) >> 8;\n            (*out)[out_ofs++] = (event->event_data.data.value & 0xff);\n\n        } else if (event->do_event == _WM_do_meta_text) {\n            (*out)[out_ofs++] = 0xff;\n            (*out)[out_ofs++] = 0x01;\n\n            goto _WRITE_TEXT;\n\n        } else if (event->do_event == _WM_do_meta_copyright) {\n            (*out)[out_ofs++] = 0xff;\n            (*out)[out_ofs++] = 0x02;\n\n            goto _WRITE_TEXT;\n\n        } else if (event->do_event == _WM_do_meta_trackname) {\n            (*out)[out_ofs++] = 0xff;\n            (*out)[out_ofs++] = 0x03;\n\n            goto _WRITE_TEXT;\n\n        } else if (event->do_event == _WM_do_meta_instrumentname) {\n            (*out)[out_ofs++] = 0xff;\n            (*out)[out_ofs++] = 0x04;\n\n            goto _WRITE_TEXT;\n\n        } else if (event->do_event == _WM_do_meta_lyric) {\n            (*out)[out_ofs++] = 0xff;\n            (*out)[out_ofs++] = 0x05;\n\n            goto _WRITE_TEXT;\n\n        } else if (event->do_event == _WM_do_meta_marker) {\n            (*out)[out_ofs++] = 0xff;\n            (*out)[out_ofs++] = 0x06;\n\n            goto _WRITE_TEXT;\n\n        } else if (event->do_event == _WM_do_meta_cuepoint) {\n            (*out)[out_ofs++] = 0xff;\n            (*out)[out_ofs++] = 0x07;\n\n            _WRITE_TEXT:\n            value = strlen(event->event_data.data.string);\n            if (value > 0x0fffffff)\n                (*out)[out_ofs++] = (((value >> 28) &0x7f) | 0x80);\n            if (value > 0x1fffff)\n                (*out)[out_ofs++] = (((value >> 21) &0x7f) | 0x80);\n            if (value > 0x3fff)\n                (*out)[out_ofs++] = (((value >> 14) & 0x7f) | 0x80);\n            if (value > 0x7f)\n                (*out)[out_ofs++] = (((value >> 7) & 0x7f) | 0x80);\n            (*out)[out_ofs++] = (value & 0x7f);\n\n            memcpy(&(*out)[out_ofs], event->event_data.data.string, value);\n            out_ofs += value;\n\n        } else {\n            // DEBUG\n            fprintf(stderr,\"Unknown Event %.2x %.4x\\n\",event->event_data.channel, event->event_data.data.value);\n            event++;\n            continue;\n        }\n\n        value_f = (float)event->samples_to_next / samples_per_tick;\n        value = (uint32_t)(value_f + 0.5);\n\n        //DEBUG\n        //fprintf(stderr,\"\\rDEBUG: STN %i, SPD %f, Delta %i\\r\\n\", event->samples_to_next, samples_per_delta_f, value);\n\n        if (value > 0x0fffffff)\n            (*out)[out_ofs++] = (((value >> 28) &0x7f) | 0x80);\n        if (value > 0x1fffff)\n            (*out)[out_ofs++] = (((value >> 21) &0x7f) | 0x80);\n        if (value > 0x3fff)\n            (*out)[out_ofs++] = (((value >> 14) & 0x7f) | 0x80);\n        if (value > 0x7f)\n            (*out)[out_ofs++] = (((value >> 7) & 0x7f) | 0x80);\n        (*out)[out_ofs++] = (value & 0x7f);\n    NEXT_EVENT:\n        event++;\n    } while (event->do_event != NULL);\n\n    if ((_WM_MixerOptions & WM_MO_SAVEASTYPE0) || (!mdi->is_type2)) {\n        /* Write end of track marker */\n        (*out)[out_ofs++] = 0xff;\n        (*out)[out_ofs++] = 0x2f;\n        (*out)[out_ofs++] = 0x00;\n\n        /* Write last track size */\n        track_size = out_ofs - track_start;\n        (*out)[track_start - 4] = (track_size >> 24) & 0xff;\n        (*out)[track_start - 3] = (track_size >> 16) & 0xff;\n        (*out)[track_start - 2] = (track_size >> 8) & 0xff;\n        (*out)[track_start - 1] = track_size & 0xff;\n    }\n    /* write track count */\n    (*out)[10] = (track_count >> 8) & 0xff;\n    (*out)[11] = track_count & 0xff;\n\n    (*out) = realloc((*out), out_ofs);\n    (*outsize) = out_ofs;\n\n    return 0;\n}\n", "/*\n * mus_wm.c -- Midi Wavetable Processing library\n *\n * Copyright (C) WildMIDI Developers 2001-2016\n *\n * This file is part of WildMIDI.\n *\n * WildMIDI is free software: you can redistribute and/or modify the player\n * under the terms of the GNU General Public License and you can redistribute\n * and/or modify the library under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation, either version 3 of\n * the licenses, or(at your option) any later version.\n *\n * WildMIDI is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License and\n * the GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License and the\n * GNU Lesser General Public License along with WildMIDI.  If not,  see\n * <http://www.gnu.org/licenses/>.\n */\n\n#include \"config.h\"\n\n#include <stdint.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n\n#include \"common.h\"\n#include \"wm_error.h\"\n#include \"wildmidi_lib.h\"\n#include \"internal_midi.h\"\n#include \"reverb.h\"\n#include \"f_mus.h\"\n\n#ifdef DEBUG_MUS\n#define MUS_EVENT_DEBUG(dx,dy,dz) fprintf(stderr,\"\\r%s, 0x%.2x, 0x%.8x\\n\",dx,dy,dz)\n#else\n#define MUS_EVENT_DEBUG(dx,dy,dz)\n#endif\n\n\n/*\n Turns hmp file data into an event stream\n */\nstruct _mdi *\n_WM_ParseNewMus(uint8_t *mus_data, uint32_t mus_size) {\n    uint8_t mus_hdr[] = { 'M', 'U', 'S', 0x1A };\n    uint32_t mus_song_ofs = 0;\n    uint32_t mus_song_len = 0;\n    uint16_t mus_ch_cnt1 = 0;\n    uint16_t mus_ch_cnt2 = 0;\n    uint16_t mus_no_instr = 0;\n    uint32_t mus_data_ofs = 0;\n    uint16_t * mus_mid_instr = NULL;\n    uint16_t mus_instr_cnt = 0;\n    struct _mdi *mus_mdi;\n    uint32_t mus_divisions = 60;\n    float tempo_f = 0.0;\n    uint16_t mus_freq = 0;\n    float samples_per_tick_f = 0.0;\n    uint8_t mus_event[] = { 0, 0, 0, 0 };\n    uint8_t mus_event_size = 0;\n    uint8_t mus_prev_vol[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n    uint32_t setup_ret = 0;\n    uint32_t mus_ticks = 0;\n    uint32_t sample_count = 0;\n    float sample_count_f = 0.0;\n    float sample_remainder = 0.0;\n    uint16_t pitchbend_tmp = 0;\n\n    if (mus_size < 17) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_MUS, \"File too short\", 0);\n        return NULL;\n    }\n\n    if (memcmp(mus_data, mus_hdr, 4)) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_MUS, NULL, 0);\n        return NULL;\n    }\n\n    // Get Song Length\n    mus_song_len = (mus_data[5] << 8) | mus_data[4];\n    // Get Song Offset\n    mus_song_ofs = (mus_data[7] << 8) | mus_data[6];\n\n    // Have yet to determine what this actually is.\n    mus_ch_cnt1 = (mus_data[9] << 8) | mus_data[8];\n    mus_ch_cnt2 = (mus_data[11] << 8) | mus_data[10];\n\n    UNUSED(mus_ch_cnt1);\n    UNUSED(mus_ch_cnt2);\n\n    // Number of instruments defined\n    mus_no_instr = (mus_data[13] << 8) | mus_data[12];\n\n    // Skip next 2 data bytes\n    mus_data_ofs = 16;\n\n    // Check that we have enough data to check the rest\n    if (mus_size < (mus_data_ofs + (mus_no_instr << 1) + mus_song_len)) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_MUS, \"File too short\", 0);\n        return NULL;\n    }\n\n    // Instrument definition\n    mus_mid_instr = malloc(mus_no_instr * sizeof(uint16_t));\n    for (mus_instr_cnt = 0; mus_instr_cnt < mus_no_instr; mus_instr_cnt++) {\n        mus_mid_instr[mus_instr_cnt] = (mus_data[mus_data_ofs + 1] << 8) | mus_data[mus_data_ofs];\n        mus_data_ofs += 2;\n    }\n\n    // make sure we are at song offset\n    mus_data_ofs = mus_song_ofs;\n\n    // do some calculations so we know how many samples per mus tick\n    mus_freq = _cvt_get_option(WM_CO_FREQUENCY);\n    if (mus_freq == 0) mus_freq = 140;\n\n    if ((_WM_MixerOptions & WM_MO_ROUNDTEMPO)) {\n        tempo_f = (float) (60000000 / mus_freq) + 0.5f;\n    } else {\n        tempo_f = (float) (60000000 / mus_freq);\n    }\n\n    samples_per_tick_f = _WM_GetSamplesPerTick(mus_divisions, (uint32_t)tempo_f);\n\n    // initialise the mdi structure\n    mus_mdi = _WM_initMDI();\n    _WM_midi_setup_divisions(mus_mdi, mus_divisions);\n    _WM_midi_setup_tempo(mus_mdi, (uint32_t)tempo_f);\n\n    // lets do this\n    do {\n        // Build the event\n    _mus_build_event:\n#if 1\n        // Mus drums happen on channel 15, swap channel 9 & 15\n        // DEBUG\n        MUS_EVENT_DEBUG(\"Before\", mus_data[mus_data_ofs], 0);\n\n        if ((mus_data[mus_data_ofs] & 0x0f) == 0x0f) {\n            mus_data[mus_data_ofs] = (mus_data[mus_data_ofs] & 0xf0) | 0x09;\n        } else if ((mus_data[mus_data_ofs] & 0x0f) == 0x09) {\n            mus_data[mus_data_ofs] = (mus_data[mus_data_ofs] & 0xf0) | 0x0f;\n        }\n        // DEBUG\n        MUS_EVENT_DEBUG(\"After\", mus_data[mus_data_ofs], 0);\n#endif\n        switch ((mus_data[mus_data_ofs] >> 4) & 0x07) {\n            case 0: // Note Off\n                mus_event_size = 2;\n                mus_event[0] = 0x80 | (mus_data[mus_data_ofs] & 0x0f);\n                mus_event[1] = mus_data[mus_data_ofs + 1];\n                mus_event[2] = 0;\n                mus_event[3] = 0;\n                break;\n            case 1: // Note On\n                if (mus_data[mus_data_ofs + 1] & 0x80) {\n                    mus_event_size = 3;\n                    mus_event[0] = 0x90 | (mus_data[mus_data_ofs] & 0x0f);\n                    mus_event[1] = mus_data[mus_data_ofs + 1] & 0x7f;\n                    mus_event[2] = mus_data[mus_data_ofs + 2];\n                    mus_event[3] = 0;\n                    mus_prev_vol[mus_data[mus_data_ofs] & 0x0f] = mus_event[2];\n                } else {\n                    mus_event_size = 2;\n                    mus_event[0] = 0x90 | (mus_data[mus_data_ofs] & 0x0f);\n                    mus_event[1] = mus_data[mus_data_ofs + 1];\n                    mus_event[2] = mus_prev_vol[mus_data[mus_data_ofs] & 0x0f];\n                    mus_event[3] = 0;\n                }\n                break;\n            case 2: // Pitch Bend\n                mus_event_size = 2;\n                mus_event[0] = 0xe0 | (mus_data[mus_data_ofs] & 0x0f);\n\n                pitchbend_tmp = mus_data[mus_data_ofs + 1] << 6;\n                mus_event[1] = pitchbend_tmp & 0x7f;\n                mus_event[2] = (pitchbend_tmp >> 7) & 0x7f;\n                mus_event[3] = 0;\n                break;\n            case 3:\n                mus_event_size = 2;\n                switch (mus_data[mus_data_ofs + 1]) {\n                    case 10: // All Sounds Off\n                        mus_event[0] = 0xb0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = 120;\n                        mus_event[2] = 0;\n                        mus_event[3] = 0;\n                        break;\n                    case 11: // All Notes Off\n                        mus_event[0] = 0xb0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = 123;\n                        mus_event[2] = 0;\n                        mus_event[3] = 0;\n                        break;\n                    case 12: // Mono (Not supported by WildMIDI)\n                        /*\n                         **************************\n                         FIXME: Add dummy mdi event\n                         **************************\n                         */\n                        mus_event[0] = 0xb0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = 126;\n                        mus_event[2] = 0;\n                        mus_event[3] = 0;\n                        break;\n                    case 13: // Poly (Not supported by WildMIDI)\n                        /*\n                         **************************\n                         FIXME: Add dummy mdi event\n                         **************************\n                         */\n                        mus_event[0] = 0xb0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = 127;\n                        mus_event[2] = 0;\n                        mus_event[3] = 0;\n                        break;\n                    case 14: // Reset All Controllers\n                        mus_event[0] = 0xb0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = 121;\n                        mus_event[2] = 0;\n                        mus_event[3] = 0;\n                        break;\n                    default: // Unsupported\n                        goto _mus_next_data;\n                }\n                break;\n            case 4:\n                mus_event_size = 3;\n                switch (mus_data[mus_data_ofs + 1]) {\n                    case 0: // Patch\n                        /*\n                         *************************************************\n                         FIXME: Check if setting is MIDI or MUS instrument\n                         *************************************************\n                         */\n                        mus_event[0] = 0xc0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = mus_data[mus_data_ofs + 2];\n                        mus_event[2] = 0;\n                        mus_event[3] = 0;\n                        break;\n                    case 1: // Bank Select\n                        mus_event[0] = 0xb0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = 0;\n                        mus_event[2] = mus_data[mus_data_ofs + 2];\n                        mus_event[3] = 0;\n                        break;\n                    case 2: // Modulation (Not supported by WildMidi)\n                        mus_event[0] = 0xb0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = 1;\n                        mus_event[2] = mus_data[mus_data_ofs + 2];\n                        mus_event[3] = 0;\n                        break;\n                    case 3: // Volume\n                        mus_event[0] = 0xb0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = 7;\n                        mus_event[2] = mus_data[mus_data_ofs + 2];\n                        mus_event[3] = 0;\n                        break;\n                    case 4: // Pan\n                        mus_event[0] = 0xb0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = 10;\n                        mus_event[2] = mus_data[mus_data_ofs + 2];\n                        mus_event[3] = 0;\n                        break;\n                    case 5: // Expression\n                        mus_event[0] = 0xb0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = 11;\n                        mus_event[2] = mus_data[mus_data_ofs + 2];\n                        mus_event[3] = 0;\n                        break;\n                    case 6: // Reverb (Not supported by WildMidi)\n                        mus_event[0] = 0xb0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = 91;\n                        mus_event[2] = mus_data[mus_data_ofs + 2];\n                        mus_event[3] = 0;\n                        break;\n                    case 7: // Chorus (Not supported by WildMidi)\n                        mus_event[0] = 0xb0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = 93;\n                        mus_event[2] = mus_data[mus_data_ofs + 2];\n                        mus_event[3] = 0;\n                        break;\n                    case 8: // Sustain\n                        mus_event[0] = 0xb0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = 64;\n                        mus_event[2] = mus_data[mus_data_ofs + 2];\n                        mus_event[3] = 0;\n                        break;\n                    case 9: // Soft Peddle (Not supported by WildMidi)\n                        mus_event[0] = 0xb0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = 67;\n                        mus_event[2] = mus_data[mus_data_ofs + 2];\n                        mus_event[3] = 0;\n                        break;\n                    default: // Unsupported\n                        goto _mus_next_data;\n                }\n                break;\n            case 5:\n                mus_event_size = 1;\n                goto _mus_next_data;\n                break;\n            case 6:\n                goto _mus_end_of_song;\n                break;\n            case 7:\n                mus_event_size = 1;\n                goto _mus_next_data;\n                break;\n        }\n\n        setup_ret = _WM_SetupMidiEvent(mus_mdi, (uint8_t *)mus_event, 0);\n        if (setup_ret == 0) {\n            goto _mus_end;\n        }\n\n    _mus_next_data:\n        if (!(mus_data[mus_data_ofs] & 0x80)) {\n            mus_data_ofs += mus_event_size;\n            goto _mus_build_event;\n\n        }\n        mus_data_ofs += mus_event_size;\n\n        mus_ticks = 0;\n        do {\n            mus_ticks = (mus_ticks << 7) | (mus_data[mus_data_ofs++] & 0x7f);\n        } while (mus_data[mus_data_ofs - 1] & 0x80);\n\n        sample_count_f = ((float)mus_ticks * samples_per_tick_f) + sample_remainder;\n        sample_count = (uint32_t)sample_count_f;\n        sample_remainder = sample_count_f - (float)sample_count;\n\n        mus_mdi->events[mus_mdi->event_count - 1].samples_to_next = sample_count;\n        mus_mdi->extra_info.approx_total_samples += sample_count;\n\n    } while (mus_data_ofs < mus_size);\n\n_mus_end_of_song:\n    // Finalise mdi structure\n    if ((mus_mdi->reverb = _WM_init_reverb(_WM_SampleRate, _WM_reverb_room_width, _WM_reverb_room_length, _WM_reverb_listen_posx, _WM_reverb_listen_posy)) == NULL) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_MEM, \"to init reverb\", 0);\n        goto _mus_end;\n    }\n    _WM_midi_setup_endoftrack(mus_mdi);\n    mus_mdi->extra_info.current_sample = 0;\n    mus_mdi->current_event = &mus_mdi->events[0];\n    mus_mdi->samples_to_mix = 0;\n    mus_mdi->note = NULL;\n\n    _WM_ResetToStart(mus_mdi);\n\n_mus_end:\n    free(mus_mid_instr);\n    if (mus_mdi->reverb) return (mus_mdi);\n    _WM_freeMDI(mus_mdi);\n    return NULL;\n}\n", "/*\n * xmi.c -- Midi Wavetable Processing library\n *\n * Copyright (C) WildMIDI Developers 2001-2016\n *\n * This file is part of WildMIDI.\n *\n * WildMIDI is free software: you can redistribute and/or modify the player\n * under the terms of the GNU General Public License and you can redistribute\n * and/or modify the library under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation, either version 3 of\n * the licenses, or(at your option) any later version.\n *\n * WildMIDI is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License and\n * the GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License and the\n * GNU Lesser General Public License along with WildMIDI.  If not,  see\n * <http://www.gnu.org/licenses/>.\n */\n\n#include \"config.h\"\n\n#include <stdint.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n\n#include \"common.h\"\n#include \"wm_error.h\"\n#include \"wildmidi_lib.h\"\n#include \"internal_midi.h\"\n#include \"reverb.h\"\n#include \"f_xmidi.h\"\n\n\nstruct _mdi *_WM_ParseNewXmi(uint8_t *xmi_data, uint32_t xmi_size) {\n    struct _mdi *xmi_mdi = NULL;\n    uint32_t xmi_tmpdata = 0;\n    uint8_t xmi_formcnt = 0;\n    uint32_t xmi_catlen = 0;\n    uint32_t xmi_subformlen = 0;\n    uint32_t i = 0;\n    uint32_t j = 0;\n\n    uint32_t xmi_evntlen = 0;\n    uint32_t xmi_divisions = 60;\n    uint32_t xmi_tempo = 500000;\n    uint32_t xmi_sample_count = 0;\n    float xmi_sample_count_f = 0.0;\n    float xmi_sample_remainder = 0.0;\n    float xmi_samples_per_delta_f = 0.0;\n    uint8_t xmi_ch = 0;\n    uint8_t xmi_note = 0;\n    uint32_t *xmi_notelen = NULL;\n\n    uint32_t setup_ret = 0;\n    uint32_t xmi_delta = 0;\n    uint32_t xmi_lowestdelta = 0;\n\n    uint32_t xmi_evnt_cnt = 0;\n\n\n    if (memcmp(xmi_data,\"FORM\",4)) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_XMI, NULL, 0);\n        return NULL;\n    }\n\n    xmi_data += 4;\n    xmi_size -= 4;\n\n    // bytes until next entry\n    xmi_tmpdata = *xmi_data++ << 24;\n    xmi_tmpdata |= *xmi_data++ << 16;\n    xmi_tmpdata |= *xmi_data++ << 8;\n    xmi_tmpdata |= *xmi_data++;\n    xmi_size -= 4;\n\n    if (memcmp(xmi_data,\"XDIRINFO\",8)) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_XMI, NULL, 0);\n        return NULL;\n    }\n    xmi_data += 8;\n    xmi_size -= 8;\n\n    /*\n     0x00 0x00 0x00 0x02 at this point are unknown\n     so skip over them\n     */\n    xmi_data += 4;\n    xmi_size -= 4;\n\n    // number of forms contained after this point\n    xmi_formcnt = *xmi_data++;\n    if (xmi_formcnt == 0) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_XMI, NULL, 0);\n        return NULL;\n    }\n    xmi_size--;\n\n    /*\n     at this stage unsure if remaining data in\n     this section means anything\n     */\n    xmi_tmpdata -= 13;\n    xmi_data += xmi_tmpdata;\n    xmi_size -= xmi_tmpdata;\n\n    /* FIXME: Check: may not even need to process CAT information */\n    if (memcmp(xmi_data,\"CAT \",4)) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_XMI, NULL, 0);\n        return NULL;\n    }\n    xmi_data += 4;\n    xmi_size -= 4;\n\n    xmi_catlen = *xmi_data++ << 24;\n    xmi_catlen |= *xmi_data++ << 16;\n    xmi_catlen |= *xmi_data++ << 8;\n    xmi_catlen |= *xmi_data++;\n    xmi_size -= 4;\n\n    UNUSED(xmi_catlen);\n\n    if (memcmp(xmi_data,\"XMID\",4)) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_XMI, NULL, 0);\n        return NULL;\n    }\n    xmi_data += 4;\n    xmi_size -= 4;\n\n    xmi_mdi = _WM_initMDI();\n    _WM_midi_setup_divisions(xmi_mdi, xmi_divisions);\n    _WM_midi_setup_tempo(xmi_mdi, xmi_tempo);\n\n    xmi_samples_per_delta_f = _WM_GetSamplesPerTick(xmi_divisions, xmi_tempo);\n\n    xmi_notelen = malloc(sizeof(uint32_t) * 16 * 128);\n    memset(xmi_notelen, 0, (sizeof(uint32_t) * 16 * 128));\n\n    for (i = 0; i < xmi_formcnt; i++) {\n        if (memcmp(xmi_data,\"FORM\",4)) {\n            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_XMI, NULL, 0);\n            goto _xmi_end;\n        }\n        xmi_data += 4;\n        xmi_size -= 4;\n\n        xmi_subformlen = *xmi_data++ << 24;\n        xmi_subformlen |= *xmi_data++ << 16;\n        xmi_subformlen |= *xmi_data++ << 8;\n        xmi_subformlen |= *xmi_data++;\n        xmi_size -= 4;\n\n        if (memcmp(xmi_data,\"XMID\",4)) {\n            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_XMI, NULL, 0);\n            goto _xmi_end;\n        }\n        xmi_data += 4;\n        xmi_size -= 4;\n        xmi_subformlen -= 4;\n\n        // Process Subform\n        do {\n            if (!memcmp(xmi_data,\"TIMB\",4)) {\n                // Holds patch information\n                // FIXME: May not be needed for playback as EVNT seems to\n                //        hold patch events\n                xmi_data += 4;\n\n                xmi_tmpdata = *xmi_data++ << 24;\n                xmi_tmpdata |= *xmi_data++ << 16;\n                xmi_tmpdata |= *xmi_data++ << 8;\n                xmi_tmpdata |= *xmi_data++;\n                xmi_data += xmi_tmpdata;\n                xmi_size -= (8 + xmi_tmpdata);\n                xmi_subformlen -= (8 + xmi_tmpdata);\n\n            } else if (!memcmp(xmi_data,\"RBRN\",4)) {\n                // Unknown what this is\n                // FIXME: May not be needed for playback\n                xmi_data += 4;\n\n                xmi_tmpdata = *xmi_data++ << 24;\n                xmi_tmpdata |= *xmi_data++ << 16;\n                xmi_tmpdata |= *xmi_data++ << 8;\n                xmi_tmpdata |= *xmi_data++;\n                xmi_data += xmi_tmpdata;\n                xmi_size -= (8 + xmi_tmpdata);\n                xmi_subformlen -= (8 + xmi_tmpdata);\n\n            } else if (!memcmp(xmi_data,\"EVNT\",4)) {\n                // EVNT is where all the MIDI music information is stored\n                xmi_data += 4;\n\n                xmi_evnt_cnt++;\n\n                xmi_evntlen = *xmi_data++ << 24;\n                xmi_evntlen |= *xmi_data++ << 16;\n                xmi_evntlen |= *xmi_data++ << 8;\n                xmi_evntlen |= *xmi_data++;\n                xmi_size -= 8;\n                xmi_subformlen -= 8;\n\n                do {\n                    if (*xmi_data < 0x80) {\n                        xmi_delta = 0;\n                        if (*xmi_data > 0x7f) {\n                            while (*xmi_data > 0x7f) {\n                                xmi_delta = (xmi_delta << 7) | (*xmi_data++ & 0x7f);\n                                xmi_size--;\n                                xmi_evntlen--;\n                                xmi_subformlen--;\n                            }\n                        }\n                        xmi_delta = (xmi_delta << 7) | (*xmi_data++ & 0x7f);\n                        xmi_size--;\n                        xmi_evntlen--;\n                        xmi_subformlen--;\n\n                        do {\n                            // determine delta till next event\n                            if ((xmi_lowestdelta != 0) && (xmi_lowestdelta <= xmi_delta)) {\n                                xmi_tmpdata = xmi_lowestdelta;\n                            } else {\n                                xmi_tmpdata = xmi_delta;\n                            }\n\n                            xmi_sample_count_f= (((float) xmi_tmpdata * xmi_samples_per_delta_f) + xmi_sample_remainder);\n\n                            xmi_sample_count = (uint32_t) xmi_sample_count_f;\n                            xmi_sample_remainder = xmi_sample_count_f - (float) xmi_sample_count;\n\n                            xmi_mdi->events[xmi_mdi->event_count - 1].samples_to_next += xmi_sample_count;\n                            xmi_mdi->extra_info.approx_total_samples += xmi_sample_count;\n\n                            xmi_lowestdelta = 0;\n\n                            // scan through on notes\n                            for (j = 0; j < (16*128); j++) {\n                                // only want notes that are on\n                                if (xmi_notelen[j] == 0) continue;\n\n                                // remove delta to next event from on notes\n                                xmi_notelen[j] -= xmi_tmpdata;\n\n                                // Check if we need to turn note off\n                                if (xmi_notelen[j] == 0) {\n                                    xmi_ch = j / 128;\n                                    xmi_note = j - (xmi_ch * 128);\n                                    _WM_midi_setup_noteoff(xmi_mdi, xmi_ch, xmi_note, 0);\n                                } else {\n                                    // otherwise work out new lowest delta\n                                    if ((xmi_lowestdelta == 0) || (xmi_lowestdelta > xmi_notelen[j])) {\n                                        xmi_lowestdelta = xmi_notelen[j];\n                                    }\n                                }\n                            }\n                            xmi_delta -= xmi_tmpdata;\n                        } while (xmi_delta);\n\n                    } else {\n                        if ((xmi_data[0] == 0xff) && (xmi_data[1] == 0x51) && (xmi_data[2] == 0x03)) {\n                            // Ignore tempo events\n                            setup_ret = 6;\n                            goto _XMI_Next_Event;\n                        }\n                        if ((setup_ret = _WM_SetupMidiEvent(xmi_mdi,xmi_data,0)) == 0) {\n                            goto _xmi_end;\n                        }\n\n                        if ((*xmi_data & 0xf0) == 0x90) {\n                            // Note on has extra data stating note length\n                            xmi_ch = *xmi_data & 0x0f;\n                            xmi_note = xmi_data[1];\n                            xmi_data += setup_ret;\n                            xmi_size -= setup_ret;\n                            xmi_evntlen -= setup_ret;\n                            xmi_subformlen -= setup_ret;\n\n                            xmi_tmpdata = 0;\n\n                            if (*xmi_data > 0x7f) {\n                                while (*xmi_data > 0x7f) {\n                                    xmi_tmpdata = (xmi_tmpdata << 7) | (*xmi_data++ & 0x7f);\n                                    xmi_size--;\n                                    xmi_evntlen--;\n                                    xmi_subformlen--;\n                                }\n                            }\n                            xmi_tmpdata = (xmi_tmpdata << 7) | (*xmi_data++ & 0x7f);\n                            xmi_size--;\n                            xmi_evntlen--;\n                            xmi_subformlen--;\n\n                            // store length\n                            xmi_notelen[128 * xmi_ch + xmi_note] = xmi_tmpdata;\n                            if ((xmi_tmpdata > 0) && ((xmi_lowestdelta == 0) || (xmi_tmpdata < xmi_lowestdelta))) {\n                                xmi_lowestdelta = xmi_tmpdata;\n                            }\n\n                        } else {\n                        _XMI_Next_Event:\n                            xmi_data += setup_ret;\n                            xmi_size -= setup_ret;\n                            xmi_evntlen -= setup_ret;\n                            xmi_subformlen -= setup_ret;\n                        }\n                    }\n\n                } while (xmi_evntlen);\n\n            } else {\n                _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_XMI, NULL, 0);\n                goto _xmi_end;\n            }\n\n        } while (xmi_subformlen);\n    }\n\n    // Finalise mdi structure\n    if ((xmi_mdi->reverb = _WM_init_reverb(_WM_SampleRate, _WM_reverb_room_width, _WM_reverb_room_length, _WM_reverb_listen_posx, _WM_reverb_listen_posy)) == NULL) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_MEM, \"to init reverb\", 0);\n        goto _xmi_end;\n    }\n    xmi_mdi->extra_info.current_sample = 0;\n    xmi_mdi->current_event = &xmi_mdi->events[0];\n    xmi_mdi->samples_to_mix = 0;\n    xmi_mdi->note = NULL;\n    /* More than 1 event form in XMI means treat as type 2 */\n    if (xmi_evnt_cnt > 1) {\n        xmi_mdi->is_type2 = 1;\n    }\n    _WM_ResetToStart(xmi_mdi);\n\n_xmi_end:\n    if (xmi_notelen != NULL) free(xmi_notelen);\n    if (xmi_mdi->reverb) return (xmi_mdi);\n    _WM_freeMDI(xmi_mdi);\n    return NULL;\n}\n", "/*\n * internal_midi.c -- Midi Wavetable Processing library\n *\n * Copyright (C) WildMIDI Developers 2001-2016\n *\n * This file is part of WildMIDI.\n *\n * WildMIDI is free software: you can redistribute and/or modify the player\n * under the terms of the GNU General Public License and you can redistribute\n * and/or modify the library under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation, either version 3 of\n * the licenses, or(at your option) any later version.\n *\n * WildMIDI is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License and\n * the GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License and the\n * GNU Lesser General Public License along with WildMIDI.  If not,  see\n * <http://www.gnu.org/licenses/>.\n */\n\n#include \"config.h\"\n\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <math.h>\n\n#include \"common.h\"\n#include \"lock.h\"\n#include \"wm_error.h\"\n#include \"reverb.h\"\n#include \"sample.h\"\n#include \"wildmidi_lib.h\"\n#include \"patches.h\"\n#include \"internal_midi.h\"\n#ifdef __DJGPP__\n#define powf pow /* prefer C89 pow() from libc.a instead of powf() from libm. */\n#endif\n#ifdef WILDMIDI_AMIGA\n#define powf pow\n#endif\n#if defined(__WATCOMC__) || defined(__EMX__)\n#define powf pow\n#endif\n\n#define HOLD_OFF 0x02\n\n// #define DEBUG_MIDI\n\n#ifdef DEBUG_MIDI\n#define MIDI_EVENT_DEBUG(dx,dy,dz) fprintf(stderr,\"\\r%s, 0x%.2x, 0x%.8x\\n\",dx,dy,dz)\n#define MIDI_EVENT_SDEBUG(dx,dy,dz) fprintf(stderr,\"\\r%s, 0x%.2x, %s\\n\",dx,dy,dz)\n#else\n#define MIDI_EVENT_DEBUG(dx,dy,dz)\n#define MIDI_EVENT_SDEBUG(dx,dy,dz)\n#endif\n\n/* f: ( VOLUME / 127.0 ) * 1024.0 */\nint16_t _WM_lin_volume[] = { 0, 8, 16, 24, 32, 40, 48, 56, 64, 72, 80, 88, 96,\n    104, 112, 120, 129, 137, 145, 153, 161, 169, 177, 185, 193, 201, 209, 217,\n    225, 233, 241, 249, 258, 266, 274, 282, 290, 298, 306, 314, 322, 330, 338,\n    346, 354, 362, 370, 378, 387, 395, 403, 411, 419, 427, 435, 443, 451, 459,\n    467, 475, 483, 491, 499, 507, 516, 524, 532, 540, 548, 556, 564, 572, 580,\n    588, 596, 604, 612, 620, 628, 636, 645, 653, 661, 669, 677, 685, 693, 701,\n    709, 717, 725, 733, 741, 749, 757, 765, 774, 782, 790, 798, 806, 814, 822,\n    830, 838, 846, 854, 862, 870, 878, 886, 894, 903, 911, 919, 927, 935, 943,\n    951, 959, 967, 975, 983, 991, 999, 1007, 1015, 1024 };\n\n/* f: As per midi 2 standard */\nstatic float dBm_volume[] = { -999999.999999, -84.15214884, -72.11094901,\n    -65.06729865, -60.06974919, -56.19334866, -53.02609882, -50.34822724,\n    -48.02854936, -45.98244846, -44.15214884, -42.49644143, -40.984899,\n    -39.59441475, -38.30702741, -37.10849848, -35.98734953, -34.93419198,\n    -33.94124863, -33.0020048, -32.11094901, -31.26337705, -30.45524161,\n    -29.6830354, -28.94369917, -28.23454849, -27.55321492, -26.89759827,\n    -26.26582758, -25.65622892, -25.06729865, -24.49768108, -23.94614971,\n    -23.41159124, -22.89299216, -22.38942706, -21.90004881, -21.42407988,\n    -20.96080497, -20.50956456, -20.06974919, -19.64079457, -19.22217722,\n    -18.81341062, -18.41404178, -18.02364829, -17.64183557, -17.26823452,\n    -16.90249934, -16.54430564, -16.19334866, -15.84934179, -15.51201509,\n    -15.18111405, -14.85639845, -14.53764126, -14.22462776, -13.91715461,\n    -13.6150291, -13.31806837, -13.02609882, -12.73895544, -12.45648126,\n    -12.17852686, -11.90494988, -11.63561457, -11.37039142, -11.10915673,\n    -10.85179233, -10.59818521, -10.34822724, -10.10181489, -9.858848981,\n    -9.619234433, -9.382880049, -9.149698303, -8.919605147, -8.692519831,\n    -8.468364731, -8.247065187, -8.028549359, -7.812748083, -7.599594743,\n    -7.389025143, -7.180977396, -6.97539181, -6.772210788, -6.571378733,\n    -6.372841952, -6.176548572, -5.982448461, -5.790493145, -5.600635744,\n    -5.412830896, -5.227034694, -5.043204627, -4.861299517, -4.681279468,\n    -4.503105811, -4.326741054, -4.152148838, -3.979293887, -3.808141968,\n    -3.63865985, -3.470815266, -3.304576875, -3.139914228, -2.976797731,\n    -2.815198619, -2.655088921, -2.496441432, -2.339229687, -2.183427931,\n    -2.029011099, -1.875954785, -1.724235224, -1.573829269, -1.424714368,\n    -1.276868546, -1.130270383, -0.9848989963, -0.8407340256, -0.6977556112,\n    -0.5559443807, -0.4152814317, -0.2757483179, -0.1373270335, 0.0 };\n\n/* f: As per midi 2 standard */\nstatic float dBm_pan_volume[] = { -999999.999999, -38.15389834, -32.13396282,\n    -28.61324502, -26.1160207, -24.179814, -22.5986259, -21.26257033,\n    -20.10605521, -19.08677237, -18.17583419, -17.35263639, -16.60196565,\n    -15.91226889, -15.2745658, -14.6817375, -14.12804519, -13.60879499,\n    -13.12009875, -12.65869962, -12.22184237, -11.80717543, -11.41267571,\n    -11.03659017, -10.67738981, -10.33373306, -10.00443638, -9.6884504,\n    -9.384840381, -9.092770127, -8.811488624, -8.540318866, -8.278648457,\n    -8.025921658, -7.781632628, -7.545319633, -7.316560087, -7.094966257,\n    -6.880181552, -6.671877289, -6.46974987, -6.273518306, -6.082922045,\n    -5.897719045, -5.717684082, -5.542607236, -5.372292553, -5.206556845,\n    -5.045228616, -4.888147106, -4.735161423, -4.586129765, -4.44091872,\n    -4.299402626, -4.161462998, -4.026988004, -3.895871989, -3.76801504,\n    -3.643322591, -3.52170506, -3.403077519, -3.287359388, -3.174474158,\n    -3.064349129, -2.956915181, -2.852106549, -2.749860626, -2.650117773,\n    -2.55282115, -2.457916557, -2.36535228, -2.27507896, -2.187049463,\n    -2.101218759, -2.017543814, -1.935983486,-1.856498429, -1.779051001,\n    -1.703605184, -1.630126502, -1.558581949, -1.48893992, -1.421170148,\n    -1.35524364, -1.291132623, -1.228810491, -1.168251755, -1.109431992,\n    -1.052327808, -0.9969167902, -0.9431774708, -0.8910892898, -0.8406325604,\n    -0.7917884361, -0.7445388804, -0.6988666373, -0.6547552046, -0.612188808,\n    -0.5711523768, -0.5316315211, -0.4936125107, -0.4570822543, -0.4220282808,\n    -0.3884387214, -0.3563022927, -0.3256082808, -0.2963465264, -0.2685074109,\n    -0.2420818435, -0.2170612483, -0.1934375538, -0.1712031815, -0.1503510361,\n    -0.1308744964, -0.1127674066, -0.09602406855, -0.08063923423,\n    -0.06660809932, -0.05392629701, -0.04258989258, -0.03259537844,\n    -0.02393966977, -0.01662010072, -0.01063442111, -0.005980793601,\n    -0.002657791522, -0.000664397052, 0.0 };\n\nuint32_t _WM_freq_table[] = { 837201792, 837685632, 838169728,\n    838653568, 839138240, 839623232, 840108480, 840593984, 841079680,\n    841565184, 842051648, 842538240, 843025152, 843512320, 843999232,\n    844486976, 844975040, 845463360, 845951936, 846440320, 846929536,\n    847418944, 847908608, 848398656, 848888960, 849378944, 849869824,\n    850361024, 850852416, 851344192, 851835584, 852327872, 852820480,\n    853313280, 853806464, 854299328, 854793024, 855287040, 855781312,\n    856275904, 856770752, 857265344, 857760704, 858256448, 858752448,\n    859248704, 859744768, 860241600, 860738752, 861236160, 861733888,\n    862231360, 862729600, 863228160, 863727104, 864226176, 864725696,\n    865224896, 865724864, 866225152, 866725760, 867226688, 867727296,\n    868228736, 868730496, 869232576, 869734912, 870236928, 870739904,\n    871243072, 871746560, 872250368, 872754496, 873258240, 873762880,\n    874267840, 874773184, 875278720, 875783936, 876290112, 876796480,\n    877303232, 877810176, 878317504, 878824512, 879332416, 879840576,\n    880349056, 880857792, 881366272, 881875712, 882385280, 882895296,\n    883405440, 883915456, 884426304, 884937408, 885448832, 885960512,\n    886472512, 886984192, 887496768, 888009728, 888522944, 889036352,\n    889549632, 890063680, 890578048, 891092736, 891607680, 892122368,\n    892637952, 893153792, 893670016, 894186496, 894703232, 895219648,\n    895737024, 896254720, 896772672, 897290880, 897808896, 898327744,\n    898846912, 899366336, 899886144, 900405568, 900925952, 901446592,\n    901967552, 902488768, 903010368, 903531584, 904053760, 904576256,\n    905099008, 905622016, 906144896, 906668480, 907192512, 907716800,\n    908241408, 908765632, 909290816, 909816256, 910342144, 910868160,\n    911394624, 911920768, 912447680, 912975104, 913502720, 914030592,\n    914558208, 915086784, 915615552, 916144768, 916674176, 917203968,\n    917733440, 918263744, 918794496, 919325440, 919856704, 920387712,\n    920919616, 921451840, 921984320, 922517184, 923049728, 923583168,\n    924116928, 924651008, 925185344, 925720000, 926254336, 926789696,\n    927325312, 927861120, 928397440, 928933376, 929470208, 930007296,\n    930544768, 931082560, 931619968, 932158464, 932697152, 933236160,\n    933775488, 934315072, 934854464, 935394688, 935935296, 936476224,\n    937017344, 937558208, 938100160, 938642304, 939184640, 939727488,\n    940269888, 940813312, 941357056, 941900992, 942445440, 942990016,\n    943534400, 944079680, 944625280, 945171200, 945717440, 946263360,\n    946810176, 947357376, 947904832, 948452672, 949000192, 949548608,\n    950097280, 950646400, 951195776, 951745472, 952294912, 952845184,\n    953395904, 953946880, 954498176, 955049216, 955601088, 956153408,\n    956705920, 957258816, 957812032, 958364928, 958918848, 959472960,\n    960027456, 960582272, 961136768, 961692224, 962248000, 962804032,\n    963360448, 963916608, 964473600, 965031040, 965588736, 966146816,\n    966705152, 967263168, 967822144, 968381440, 968941120, 969501056,\n    970060736, 970621376, 971182272, 971743488, 972305088, 972866368,\n    973428608, 973991104, 974554048, 975117312, 975680768, 976243968,\n    976808192, 977372736, 977937536, 978502656, 979067584, 979633344,\n    980199488, 980765888, 981332736, 981899200, 982466688, 983034432,\n    983602624, 984171008, 984739776, 985308160, 985877632, 986447360,\n    987017472, 987587904, 988157952, 988729088, 989300416, 989872192,\n    990444224, 991016000, 991588672, 992161728, 992735168, 993308864,\n    993882880, 994456576, 995031296, 995606336, 996181696, 996757440,\n    997332800, 997909184, 998485888, 999062912, 999640256, 1000217984,\n    1000795392, 1001373696, 1001952448, 1002531520, 1003110848, 1003689920,\n    1004270016, 1004850304, 1005431040, 1006012160, 1006592832, 1007174592,\n    1007756608, 1008339008, 1008921792, 1009504768, 1010087552, 1010671296,\n    1011255360, 1011839808, 1012424576, 1013009024, 1013594368, 1014180160,\n    1014766272, 1015352768, 1015938880, 1016526016, 1017113472, 1017701248,\n    1018289408, 1018877824, 1019465984, 1020055104, 1020644672, 1021234496,\n    1021824768, 1022414528, 1023005440, 1023596608, 1024188160, 1024780096,\n    1025371584, 1025964160, 1026557120, 1027150336, 1027744000, 1028337920,\n    1028931520, 1029526144, 1030121152, 1030716480, 1031312128, 1031907456,\n    1032503808, 1033100480, 1033697536, 1034294912, 1034892032, 1035490048,\n    1036088512, 1036687232, 1037286336, 1037885824, 1038484928, 1039085056,\n    1039685632, 1040286464, 1040887680, 1041488448, 1042090368, 1042692608,\n    1043295168, 1043898176, 1044501440, 1045104384, 1045708288, 1046312640,\n    1046917376, 1047522368, 1048127040, 1048732800, 1049338816, 1049945280,\n    1050552128, 1051158528, 1051765952, 1052373824, 1052982016, 1053590592,\n    1054199424, 1054807936, 1055417600, 1056027456, 1056637760, 1057248448,\n    1057858752, 1058470016, 1059081728, 1059693824, 1060306304, 1060918336,\n    1061531392, 1062144896, 1062758656, 1063372928, 1063987392, 1064601664,\n    1065216896, 1065832448, 1066448448, 1067064704, 1067680704, 1068297728,\n    1068915136, 1069532864, 1070150976, 1070768640, 1071387520, 1072006720,\n    1072626240, 1073246080, 1073866368, 1074486272, 1075107200, 1075728512,\n    1076350208, 1076972160, 1077593856, 1078216704, 1078839680, 1079463296,\n    1080087040, 1080710528, 1081335168, 1081960064, 1082585344, 1083211008,\n    1083836928, 1084462592, 1085089280, 1085716352, 1086343936, 1086971648,\n    1087599104, 1088227712, 1088856576, 1089485824, 1090115456, 1090745472,\n    1091375104, 1092005760, 1092636928, 1093268352, 1093900160, 1094531584,\n    1095164160, 1095796992, 1096430336, 1097064064, 1097697280, 1098331648,\n    1098966400, 1099601536, 1100237056, 1100872832, 1101508224, 1102144768,\n    1102781824, 1103419136, 1104056832, 1104694144, 1105332608, 1105971328,\n    1106610432, 1107249920, 1107889152, 1108529408, 1109170048, 1109811072,\n    1110452352, 1111094144, 1111735552, 1112377984, 1113020928, 1113664128,\n    1114307712, 1114950912, 1115595264, 1116240000, 1116885120, 1117530624,\n    1118175744, 1118821888, 1119468416, 1120115456, 1120762752, 1121410432,\n    1122057856, 1122706176, 1123355136, 1124004224, 1124653824, 1125303040,\n    1125953408, 1126604160, 1127255168, 1127906560, 1128557696, 1129209984,\n    1129862528, 1130515456, 1131168768, 1131822592, 1132475904, 1133130368,\n    1133785216, 1134440448, 1135096064, 1135751296, 1136407680, 1137064448,\n    1137721472, 1138379008, 1139036800, 1139694336, 1140353024, 1141012096,\n    1141671424, 1142331264, 1142990592, 1143651200, 1144312192, 1144973440,\n    1145635200, 1146296448, 1146958976, 1147621760, 1148285056, 1148948608,\n    1149612672, 1150276224, 1150940928, 1151606144, 1152271616, 1152937600,\n    1153603072, 1154269824, 1154936832, 1155604352, 1156272128, 1156939648,\n    1157608192, 1158277248, 1158946560, 1159616384, 1160286464, 1160956288,\n    1161627264, 1162298624, 1162970240, 1163642368, 1164314112, 1164987008,\n    1165660160, 1166333824, 1167007872, 1167681536, 1168356352, 1169031552,\n    1169707136, 1170383104, 1171059584, 1171735552, 1172412672, 1173090304,\n    1173768192, 1174446592, 1175124480, 1175803648, 1176483072, 1177163008,\n    1177843328, 1178523264, 1179204352, 1179885824, 1180567680, 1181249920,\n    1181932544, 1182614912, 1183298304, 1183982208, 1184666368, 1185351040,\n    1186035328, 1186720640, 1187406464, 1188092672, 1188779264, 1189466368,\n    1190152960, 1190840832, 1191528960, 1192217600, 1192906624, 1193595136,\n    1194285056, 1194975232, 1195665792, 1196356736, 1197047296, 1197739136,\n    1198431360, 1199123968, 1199816960, 1200510336, 1201203328, 1201897600,\n    1202592128, 1203287040, 1203982464, 1204677504, 1205373696, 1206070272,\n    1206767232, 1207464704, 1208161664, 1208859904, 1209558528, 1210257536,\n    1210956928, 1211656832, 1212356224, 1213056768, 1213757952, 1214459392,\n    1215161216, 1215862656, 1216565376, 1217268352, 1217971840, 1218675712,\n    1219379200, 1220083840, 1220788992, 1221494528, 1222200448, 1222906752,\n    1223612672, 1224319872, 1225027456, 1225735424, 1226443648, 1227151616,\n    1227860864, 1228570496, 1229280512, 1229990912, 1230700928, 1231412096,\n    1232123776, 1232835840, 1233548288, 1234261248, 1234973696, 1235687424,\n    1236401536, 1237116032, 1237831040, 1238545536, 1239261312, 1239977472,\n    1240694144, 1241411072, 1242128512, 1242845568, 1243563776, 1244282496,\n    1245001600, 1245721088, 1246440192, 1247160448, 1247881216, 1248602368,\n    1249324032, 1250045184, 1250767616, 1251490432, 1252213632, 1252937344,\n    1253661440, 1254385152, 1255110016, 1255835392, 1256561152, 1257287424,\n    1258013184, 1258740096, 1259467648, 1260195456, 1260923648, 1261651584,\n    1262380800, 1263110272, 1263840256, 1264570624, 1265301504, 1266031872,\n    1266763520, 1267495552, 1268227968, 1268961024, 1269693440, 1270427264,\n    1271161472, 1271896064, 1272631168, 1273365760, 1274101632, 1274838016,\n    1275574784, 1276311808, 1277049472, 1277786624, 1278525056, 1279264000,\n    1280003328, 1280743040, 1281482368, 1282222976, 1282963968, 1283705344,\n    1284447232, 1285188736, 1285931392, 1286674560, 1287418240, 1288162176,\n    1288906624, 1289650688, 1290395904, 1291141760, 1291887872, 1292634496,\n    1293380608, 1294128128, 1294875904, 1295624320, 1296373120, 1297122304,\n    1297870976, 1298621056, 1299371520, 1300122496, 1300873856, 1301624832,\n    1302376960, 1303129600, 1303882752, 1304636288, 1305389312, 1306143872,\n    1306898688, 1307654016, 1308409600, 1309165696, 1309921536, 1310678528,\n    1311435904, 1312193920, 1312952192, 1313710080, 1314469248, 1315228928,\n    1315988992, 1316749568, 1317509632, 1318271104, 1319032960, 1319795200,\n    1320557952, 1321321088, 1322083840, 1322847872, 1323612416, 1324377216,\n    1325142656, 1325907584, 1326673920, 1327440512, 1328207744, 1328975360,\n    1329742464, 1330510976, 1331279872, 1332049152, 1332819072, 1333589248,\n    1334359168, 1335130240, 1335901824, 1336673920, 1337446400, 1338218368,\n    1338991744, 1339765632, 1340539904, 1341314560, 1342088832, 1342864512,\n    1343640576, 1344417024, 1345193984, 1345971456, 1346748416, 1347526656,\n    1348305408, 1349084672, 1349864320, 1350643456, 1351424000, 1352205056,\n    1352986496, 1353768448, 1354550784, 1355332608, 1356115968, 1356899712,\n    1357683840, 1358468480, 1359252608, 1360038144, 1360824192, 1361610624,\n    1362397440, 1363183872, 1363971712, 1364760064, 1365548672, 1366337792,\n    1367127424, 1367916672, 1368707200, 1369498240, 1370289664, 1371081472,\n    1371873024, 1372665856, 1373459072, 1374252800, 1375047040, 1375840768,\n    1376635904, 1377431552, 1378227584, 1379024000, 1379820928, 1380617472,\n    1381415296, 1382213760, 1383012480, 1383811840, 1384610560, 1385410816,\n    1386211456, 1387012480, 1387814144, 1388615168, 1389417728, 1390220672,\n    1391024128, 1391827968, 1392632320, 1393436288, 1394241536, 1395047296,\n    1395853568, 1396660224, 1397466368, 1398274048, 1399082112, 1399890688,\n    1400699648, 1401508224, 1402318080, 1403128576, 1403939456, 1404750848,\n    1405562624, 1406374016, 1407186816, 1408000000, 1408813696, 1409627904,\n    1410441728, 1411256704, 1412072320, 1412888320, 1413704960, 1414521856,\n    1415338368, 1416156288, 1416974720, 1417793664, 1418612992, 1419431808,\n    1420252160, 1421072896, 1421894144, 1422715904, 1423537280, 1424359808,\n    1425183104, 1426006784, 1426830848, 1427655296, 1428479488, 1429305088,\n    1430131072, 1430957568, 1431784576, 1432611072, 1433438976, 1434267392,\n    1435096192, 1435925632, 1436754432, 1437584768, 1438415616, 1439246848,\n    1440078720, 1440910848, 1441742720, 1442575872, 1443409664, 1444243584,\n    1445078400, 1445912576, 1446748032, 1447584256, 1448420864, 1449257856,\n    1450094464, 1450932480, 1451771008, 1452609920, 1453449472, 1454289408,\n    1455128960, 1455969920, 1456811264, 1457653248, 1458495616, 1459337600,\n    1460180864, 1461024768, 1461869056, 1462713984, 1463558272, 1464404096,\n    1465250304, 1466097152, 1466944384, 1467792128, 1468639488, 1469488256,\n    1470337408, 1471187200, 1472037376, 1472887168, 1473738368, 1474589952,\n    1475442304, 1476294912, 1477148160, 1478000768, 1478854912, 1479709696,\n    1480564608, 1481420288, 1482275456, 1483132160, 1483989248, 1484846976,\n    1485704960, 1486562688, 1487421696, 1488281344, 1489141504, 1490002048,\n    1490863104, 1491723776, 1492585856, 1493448448, 1494311424, 1495175040,\n    1496038144, 1496902656, 1497767808, 1498633344, 1499499392, 1500365056,\n    1501232128, 1502099712, 1502967808, 1503836416, 1504705536, 1505574016,\n    1506444032, 1507314688, 1508185856, 1509057408, 1509928576, 1510801280,\n    1511674240, 1512547840, 1513421952, 1514295680, 1515170816, 1516046464,\n    1516922624, 1517799296, 1518676224, 1519552896, 1520431104, 1521309824,\n    1522188928, 1523068800, 1523948032, 1524828672, 1525709824, 1526591616,\n    1527473792, 1528355456, 1529238784, 1530122496, 1531006720, 1531891712,\n    1532776832, 1533661824, 1534547968, 1535434880, 1536322304, 1537210112,\n    1538097408, 1538986368, 1539875840, 1540765696, 1541656192, 1542547072,\n    1543437440, 1544329472, 1545221888, 1546114944, 1547008384, 1547901440,\n    1548796032, 1549691136, 1550586624, 1551482752, 1552378368, 1553275520,\n    1554173184, 1555071232, 1555970048, 1556869248, 1557767936, 1558668288,\n    1559568896, 1560470272, 1561372032, 1562273408, 1563176320, 1564079616,\n    1564983424, 1565888000, 1566791808, 1567697408, 1568603392, 1569509760,\n    1570416896, 1571324416, 1572231424, 1573140096, 1574049152, 1574958976,\n    1575869184, 1576778752, 1577689984, 1578601728, 1579514112, 1580426880,\n    1581339264, 1582253056, 1583167488, 1584082432, 1584997888, 1585913984,\n    1586829440, 1587746304, 1588663936, 1589582080, 1590500736, 1591418880,\n    1592338560, 1593258752, 1594179584, 1595100928, 1596021632, 1596944000,\n    1597866880, 1598790272, 1599714304, 1600638848, 1601562752, 1602488320,\n    1603414272, 1604340992, 1605268224, 1606194816, 1607123072, 1608051968,\n    1608981120, 1609911040, 1610841344, 1611771264, 1612702848, 1613634688,\n    1614567168, 1615500288, 1616432896, 1617367040, 1618301824, 1619237120,\n    1620172800, 1621108096, 1622044928, 1622982272, 1623920128, 1624858752,\n    1625797632, 1626736256, 1627676416, 1628616960, 1629558272, 1630499968,\n    1631441152, 1632384000, 1633327232, 1634271232, 1635215744, 1636159744,\n    1637105152, 1638051328, 1638998016, 1639945088, 1640892928, 1641840128,\n    1642788992, 1643738368, 1644688384, 1645638784, 1646588672, 1647540352,\n    1648492416, 1649445120, 1650398464, 1651351168, 1652305408, 1653260288,\n    1654215808, 1655171712, 1656128256, 1657084288, 1658041856, 1659000064,\n    1659958784, 1660918272, 1661876992, 1662837376, 1663798400, 1664759936,\n    1665721984, 1666683520, 1667646720, 1668610560, 1669574784, 1670539776,\n    1671505024, 1672470016, 1673436544, };\n\n\n#if 0 /* NOT NEEDED USES TOO MUCH CPU */\n\nvoid _WM_DynamicVolumeAdjust(struct _mdi *mdi, int32_t *tmp_buffer, uint32_t buffer_used) {\n\n    uint32_t i = 0;\n    uint32_t j = 0;\n\n    int8_t peak_set = 0;\n    int32_t prev_val = 0;\n    uint32_t peak_ofs = 0;\n    int32_t peak = mdi->dyn_vol_peak;\n\n    double volume_to_reach = mdi->dyn_vol_to_reach;\n    double volume = mdi->dyn_vol;\n    double volume_adjust = mdi->dyn_vol_adjust;\n    double tmp_output = 0.0;\n\n#define MAX_DYN_VOL 1.0\n\n    for (i = 0; i < buffer_used; i++) {\n        if ((i == 0) || (i > peak_ofs)) {\n            // Find Next Peak/Troff\n            peak_set = 0;\n            prev_val = peak;\n            peak_ofs = 0;\n            for (j = i; j < buffer_used; j++) {\n                if (peak_set == 0) {\n                    // find what direction the data is going\n                    if (prev_val > tmp_buffer[j]) {\n                        // Going Down\n                        peak_set = -1;\n                    } else if (prev_val < tmp_buffer[j]) {\n                        // Doing Up\n                        peak_set = 1;\n                    } else {\n                        // No direction, keep looking\n                        prev_val = tmp_buffer[j];\n                        continue;\n                    }\n                }\n\n                if (peak_set == 1) {\n                    // Data is going up\n                    if (peak < tmp_buffer[j]) {\n                        peak = tmp_buffer[j];\n                        peak_ofs = j;\n                    } else if (peak > tmp_buffer[j]) {\n                        // Data is starting to go down, we found the peak\n                        break;\n                    }\n                } else { // assume peak_set == -1\n                    // Data is going down\n                    if (peak > tmp_buffer[j]) {\n                        peak = tmp_buffer[j];\n                        peak_ofs = j;\n                    } else if (peak < tmp_buffer[j]) {\n                        // Data is starting to go up, we found the troff\n                        break;\n                    }\n                }\n\n                prev_val = tmp_buffer[j];\n            }\n\n            if (peak_set != 0) {\n                if (peak_set == 1) {\n                    if (peak > 32767) {\n                        volume_to_reach = 32767.0 / (double)peak;\n                    } else {\n                        volume_to_reach = MAX_DYN_VOL;\n                    }\n                } else { // assume peak_set == -1\n                    if (peak < -32768) {\n                        volume_to_reach = -32768.0 / (double)peak;\n                    } else {\n                        volume_to_reach = MAX_DYN_VOL;\n                    }\n                }\n            } else {\n                // No peak found, set volume we want to normal\n                volume_to_reach = MAX_DYN_VOL;\n            }\n\n            if (volume != volume_to_reach) {\n                if (volume_to_reach == MAX_DYN_VOL) {\n                    // if we want normal volume then adjust to it slower\n                    volume_adjust = (volume_to_reach - volume) / ((double)_WM_SampleRate * 0.1);\n                } else {\n                    // if we want to clamp the volume then adjust quickly\n                    volume_adjust = (volume_to_reach - volume) / ((double)_WM_SampleRate * 0.0001);\n                }\n            }\n        }\n\n        // First do we need to do volume adjustments\n        if ((volume_adjust != 0.0) && (volume != volume_to_reach)) {\n                volume += volume_adjust;\n                if (volume_adjust > 0.0) {\n                    // if increasing the volume\n                    if (volume >= MAX_DYN_VOL) {\n                        // we dont boost volume\n                        volume = MAX_DYN_VOL;\n                        volume_adjust = 0.0;\n                    } else if (volume > volume_to_reach) {\n                        // we dont want to go above the level we wanted\n                        volume = volume_to_reach;\n                        volume_adjust = 0.0;\n                    }\n                } else {\n                    // decreasing the volume\n                    if (volume < volume_to_reach) {\n                        // we dont want to go below the level we wanted\n                        volume = volume_to_reach;\n                        volume_adjust = 0.0;\n                    }\n                }\n            }\n\n        // adjust buffer volume\n        tmp_output = (double)tmp_buffer[i] * volume;\n        tmp_buffer[i] = (int32_t)tmp_output;\n    }\n\n    // store required values\n    mdi->dyn_vol_adjust = volume_adjust;\n    mdi->dyn_vol_peak = peak;\n    mdi->dyn_vol = volume;\n    mdi->dyn_vol_to_reach = volume_to_reach;\n}\n\n#endif\n\n/* Should be called in any function that effects note volumes */\nvoid _WM_AdjustNoteVolumes(struct _mdi *mdi, uint8_t ch, struct _note *nte) {\n    float premix_dBm;\n    float premix_lin;\n    uint8_t pan_ofs;\n    float premix_dBm_left;\n    float premix_dBm_right;\n    float premix_left;\n    float premix_right;\n    float volume_adj;\n    uint32_t vol_ofs;\n\n    /*\n     Pointless CPU heating checks to shoosh up a compiler\n     */\n    if (ch > 0x0f) ch = 0x0f;\n\n    if (nte->ignore_chan_events) return;\n\n    pan_ofs = mdi->channel[ch].balance + mdi->channel[ch].pan - 64;\n\n    vol_ofs = (nte->velocity * ((mdi->channel[ch].expression * mdi->channel[ch].volume) / 127)) / 127;\n\n    /*\n     This value is to reduce the chance of clipping.\n     Higher value means lower overall volume,\n     Lower value means higher overall volume.\n     NOTE: The lower the value the higher the chance of clipping.\n     FIXME: Still needs tuning. Clipping heard at a value of 3.75\n     */\n#define VOL_DIVISOR 4.0\n    volume_adj = ((float)_WM_MasterVolume / 1024.0) / VOL_DIVISOR;\n\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, 0);\n\n    if (pan_ofs > 127) pan_ofs = 127;\n    premix_dBm_left = dBm_pan_volume[(127-pan_ofs)];\n    premix_dBm_right = dBm_pan_volume[pan_ofs];\n\n    if (mdi->extra_info.mixer_options & WM_MO_LOG_VOLUME) {\n        premix_dBm = dBm_volume[vol_ofs];\n\n        premix_dBm_left += premix_dBm;\n        premix_dBm_right += premix_dBm;\n\n        premix_left = (powf(10.0,(premix_dBm_left / 20.0))) * volume_adj;\n        premix_right = (powf(10.0,(premix_dBm_right / 20.0))) * volume_adj;\n    } else {\n        premix_lin = (float)(_WM_lin_volume[vol_ofs]) / 1024.0;\n\n        premix_left = premix_lin * powf(10.0, (premix_dBm_left / 20)) * volume_adj;\n        premix_right = premix_lin * powf(10.0, (premix_dBm_right / 20)) * volume_adj;\n    }\n    nte->left_mix_volume = (int32_t)(premix_left * 1024.0);\n    nte->right_mix_volume = (int32_t)(premix_right * 1024.0);\n}\n\n/* Should be called in any function that effects channel volumes */\n/* Calling this function with a value > 15 will make it adjust notes on all channels */\nvoid _WM_AdjustChannelVolumes(struct _mdi *mdi, uint8_t ch) {\n    struct _note *nte = mdi->note;\n    if (nte != NULL) {\n        do {\n            if (ch <= 15) {\n                if ((nte->noteid >> 8) == ch) {\n                    goto _DO_ADJUST;\n                }\n            } else {\n            _DO_ADJUST:\n                if (!nte->ignore_chan_events) {\n                    _WM_AdjustNoteVolumes(mdi, ch, nte);\n                    if (nte->replay) _WM_AdjustNoteVolumes(mdi, ch, nte->replay);\n                }\n            }\n            nte = nte->next;\n        } while (nte != NULL);\n    }\n}\n\nfloat _WM_GetSamplesPerTick(uint32_t divisions, uint32_t tempo) {\n    float microseconds_per_tick;\n    float secs_per_tick;\n    float samples_per_tick;\n\n    /* Slow but needed for accuracy */\n    microseconds_per_tick = (float) tempo / (float) divisions;\n    secs_per_tick = microseconds_per_tick / 1000000.0f;\n    samples_per_tick = _WM_SampleRate * secs_per_tick;\n\n    return (samples_per_tick);\n}\n\nstatic void _WM_CheckEventMemoryPool(struct _mdi *mdi) {\n    if ((mdi->event_count + 1) >= mdi->events_size) {\n        mdi->events_size += MEM_CHUNK;\n        mdi->events = realloc(mdi->events,\n                              (mdi->events_size * sizeof(struct _event)));\n    }\n}\n\nvoid _WM_do_note_off_extra(struct _note *nte) {\n\n    MIDI_EVENT_DEBUG(__FUNCTION__,0, 0);\n    nte->is_off = 0;\n        {\n        if (!(nte->modes & SAMPLE_ENVELOPE)) {\n            if (nte->modes & SAMPLE_LOOP) {\n                nte->modes ^= SAMPLE_LOOP;\n            }\n            nte->env_inc = 0;\n\n        } else if (nte->hold) {\n            nte->hold |= HOLD_OFF;\n/*\n        } else if (nte->modes & SAMPLE_SUSTAIN) {\n            if (nte->env < 3) {\n                nte->env = 3;\n                if (nte->env_level > nte->sample->env_target[3]) {\n                    nte->env_inc = -nte->sample->env_rate[3];\n                } else {\n                    nte->env_inc = nte->sample->env_rate[3];\n                }\n            }\n*/\n        } else if (nte->modes & SAMPLE_CLAMPED) {\n            if (nte->env < 5) {\n                nte->env = 5;\n                if (nte->env_level > nte->sample->env_target[5]) {\n                    nte->env_inc = -nte->sample->env_rate[5];\n                } else {\n                    nte->env_inc = nte->sample->env_rate[5];\n                }\n            }\n        } else if (nte->env < 3) {\n            nte->env = 3;\n            if (nte->env_level > nte->sample->env_target[3]) {\n                nte->env_inc = -nte->sample->env_rate[3];\n            } else {\n                nte->env_inc = nte->sample->env_rate[3];\n            }\n        }\n    }\n}\n\n\nvoid _WM_do_midi_divisions(struct _mdi *mdi, struct _event_data *data) {\n    // placeholder function so we can record divisions in the event stream\n    // for conversion function _WM_Event2Midi()\n    UNUSED(mdi);\n    UNUSED(data);\n    return;\n}\n\nvoid _WM_do_note_off(struct _mdi *mdi, struct _event_data *data) {\n    struct _note *nte;\n    uint8_t ch = data->channel;\n\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n\n    nte = &mdi->note_table[0][ch][(data->data.value >> 8)];\n    if (!nte->active) {\n        nte = &mdi->note_table[1][ch][(data->data.value >> 8)];\n        if (!nte->active) {\n            return;\n        }\n    }\n\n    if ((mdi->channel[ch].isdrum) && (!(nte->modes & SAMPLE_LOOP))) {\n        return;\n    }\n\n    if ((nte->modes & SAMPLE_ENVELOPE) && (nte->env == 0)) {\n        // This is a fix for notes that end before the\n        // initial step of the envelope has completed\n        // making it impossible to hear them at times.\n        nte->is_off = 1;\n    } else {\n        _WM_do_note_off_extra(nte);\n    }\n}\n\nstatic inline uint32_t get_inc(struct _mdi *mdi, struct _note *nte) {\n    int ch = nte->noteid >> 8;\n    int32_t note_f;\n    uint32_t freq;\n\n    if (__builtin_expect((nte->patch->note != 0), 0)) {\n        note_f = nte->patch->note * 100;\n    } else {\n        note_f = (nte->noteid & 0x7f) * 100;\n    }\n    note_f += mdi->channel[ch].pitch_adjust;\n    if (__builtin_expect((note_f < 0), 0)) {\n        note_f = 0;\n    } else if (__builtin_expect((note_f > 12700), 0)) {\n        note_f = 12700;\n    }\n    freq = _WM_freq_table[(note_f % 1200)] >> (10 - (note_f / 1200));\n    return (((freq / ((_WM_SampleRate * 100) / 1024)) * 1024\n             / nte->sample->inc_div));\n}\n\nvoid _WM_do_note_on(struct _mdi *mdi, struct _event_data *data) {\n    struct _note *nte;\n    struct _note *prev_nte;\n    struct _note *nte_array;\n    uint32_t freq = 0;\n    struct _patch *patch;\n    struct _sample *sample;\n    uint8_t ch = data->channel;\n    uint8_t note = (data->data.value >> 8);\n    uint8_t velocity = (data->data.value & 0xFF);\n\n    if (velocity == 0x00) {\n        _WM_do_note_off(mdi, data);\n        return;\n    }\n\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n\n    if (!mdi->channel[ch].isdrum) {\n        patch = mdi->channel[ch].patch;\n        if (patch == NULL) {\n            return;\n        }\n        freq = _WM_freq_table[(note % 12) * 100] >> (10 - (note / 12));\n    } else {\n        patch = _WM_get_patch_data(mdi,\n                               ((mdi->channel[ch].bank << 8) | note | 0x80));\n        if (patch == NULL) {\n            return;\n        }\n        if (patch->note) {\n            freq = _WM_freq_table[(patch->note % 12) * 100]\n            >> (10 - (patch->note / 12));\n        } else {\n            freq = _WM_freq_table[(note % 12) * 100] >> (10 - (note / 12));\n        }\n    }\n\n    sample = _WM_get_sample_data(patch, (freq / 100));\n    if (sample == NULL) {\n        return;\n    }\n\n    nte = &mdi->note_table[0][ch][note];\n\n    if (nte->active) {\n        if ((nte->modes & SAMPLE_ENVELOPE) && (nte->env < 3)\n            && (!(nte->hold & HOLD_OFF)))\n            return;\n        nte->replay = &mdi->note_table[1][ch][note];\n        nte->env = 6;\n        nte->env_inc = -nte->sample->env_rate[6];\n        nte = nte->replay;\n    } else {\n        if (mdi->note_table[1][ch][note].active) {\n            if ((nte->modes & SAMPLE_ENVELOPE) && (nte->env < 3)\n                && (!(nte->hold & HOLD_OFF)))\n                return;\n            mdi->note_table[1][ch][note].replay = nte;\n            mdi->note_table[1][ch][note].env = 6;\n            mdi->note_table[1][ch][note].env_inc =\n            -mdi->note_table[1][ch][note].sample->env_rate[6];\n        } else {\n            nte_array = mdi->note;\n            if (nte_array == NULL) {\n                mdi->note = nte;\n            } else {\n                do {\n                    prev_nte = nte_array;\n                    nte_array = nte_array->next;\n                } while (nte_array);\n                prev_nte->next = nte;\n            }\n            nte->active = 1;\n            nte->next = NULL;\n        }\n    }\n    nte->noteid = (ch << 8) | note;\n    nte->patch = patch;\n    nte->sample = sample;\n    nte->sample_pos = 0;\n    nte->sample_inc = get_inc(mdi, nte);\n    nte->velocity = velocity;\n    nte->env = 0;\n    nte->env_inc = nte->sample->env_rate[0];\n    nte->env_level = 0;\n    nte->modes = sample->modes;\n    nte->hold = mdi->channel[ch].hold;\n    nte->replay = NULL;\n    nte->is_off = 0;\n    nte->ignore_chan_events = 0;\n    _WM_AdjustNoteVolumes(mdi, ch, nte);\n}\n\nvoid _WM_do_aftertouch(struct _mdi *mdi, struct _event_data *data) {\n    struct _note *nte;\n    uint8_t ch = data->channel;\n\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n\n    nte = &mdi->note_table[0][ch][(data->data.value >> 8)];\n    if (!nte->active) {\n        nte = &mdi->note_table[1][ch][(data->data.value >> 8)];\n        if (!nte->active) {\n            return;\n        }\n    }\n\n    nte->velocity = data->data.value & 0xff;\n    _WM_AdjustNoteVolumes(mdi, ch, nte);\n    if (nte->replay) {\n        nte->replay->velocity = data->data.value & 0xff;\n        _WM_AdjustNoteVolumes(mdi, ch, nte->replay);\n    }\n}\n\nvoid _WM_do_control_bank_select(struct _mdi *mdi, struct _event_data *data) {\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n    mdi->channel[ch].bank = data->data.value;\n}\n\nvoid _WM_do_control_data_entry_course(struct _mdi *mdi,\n                                         struct _event_data *data) {\n    uint8_t ch = data->channel;\n    int data_tmp;\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n\n    if ((mdi->channel[ch].reg_non == 0)\n        && (mdi->channel[ch].reg_data == 0x0000)) { /* Pitch Bend Range */\n        data_tmp = mdi->channel[ch].pitch_range % 100;\n        mdi->channel[ch].pitch_range = data->data.value * 100 + data_tmp;\n    /*  printf(\"Data Entry Course: pitch_range: %i\\n\\r\",mdi->channel[ch].pitch_range);*/\n    /*  printf(\"Data Entry Course: data %li\\n\\r\",data->data.value);*/\n    }\n}\n\nvoid _WM_do_control_channel_volume(struct _mdi *mdi,\n                                      struct _event_data *data) {\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n\n    mdi->channel[ch].volume = data->data.value;\n    _WM_AdjustChannelVolumes(mdi, ch);\n}\n\nvoid _WM_do_control_channel_balance(struct _mdi *mdi,\n                                       struct _event_data *data) {\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n\n    mdi->channel[ch].balance = data->data.value;\n    _WM_AdjustChannelVolumes(mdi, ch);\n}\n\nvoid _WM_do_control_channel_pan(struct _mdi *mdi, struct _event_data *data) {\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n\n    mdi->channel[ch].pan = data->data.value;\n    _WM_AdjustChannelVolumes(mdi, ch);\n}\n\nvoid _WM_do_control_channel_expression(struct _mdi *mdi,\n                                          struct _event_data *data) {\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n\n    mdi->channel[ch].expression = data->data.value;\n    _WM_AdjustChannelVolumes(mdi, ch);\n}\n\nvoid _WM_do_control_data_entry_fine(struct _mdi *mdi,\n                                       struct _event_data *data) {\n    uint8_t ch = data->channel;\n    int data_tmp;\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n\n    if ((mdi->channel[ch].reg_non == 0)\n      && (mdi->channel[ch].reg_data == 0x0000)) { /* Pitch Bend Range */\n        data_tmp = mdi->channel[ch].pitch_range / 100;\n        mdi->channel[ch].pitch_range = (data_tmp * 100) + data->data.value;\n    /*  printf(\"Data Entry Fine: pitch_range: %i\\n\\r\",mdi->channel[ch].pitch_range);*/\n    /*  printf(\"Data Entry Fine: data: %li\\n\\r\", data->data.value);*/\n    }\n}\n\nvoid _WM_do_control_channel_hold(struct _mdi *mdi, struct _event_data *data) {\n    struct _note *note_data = mdi->note;\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n\n    if (data->data.value > 63) {\n        mdi->channel[ch].hold = 1;\n    } else {\n        mdi->channel[ch].hold = 0;\n        if (note_data) {\n            do {\n                if ((note_data->noteid >> 8) == ch) {\n                    if (note_data->hold & HOLD_OFF) {\n                        if (note_data->modes & SAMPLE_ENVELOPE) {\n                            if (note_data->modes & SAMPLE_CLAMPED) {\n                                if (note_data->env < 5) {\n                                    note_data->env = 5;\n                                    if (note_data->env_level\n                                        > note_data->sample->env_target[5]) {\n                                        note_data->env_inc =\n                                        -note_data->sample->env_rate[5];\n                                    } else {\n                                        note_data->env_inc =\n                                        note_data->sample->env_rate[5];\n                                    }\n                                }\n                            /*\n                            } else if (note_data->modes & SAMPLE_SUSTAIN) {\n                                if (note_data->env < 3) {\n                                    note_data->env = 3;\n                                    if (note_data->env_level\n                                        > note_data->sample->env_target[3]) {\n                                        note_data->env_inc =\n                                        -note_data->sample->env_rate[3];\n                                    } else {\n                                        note_data->env_inc =\n                                        note_data->sample->env_rate[3];\n                                    }\n                                }\n                             */\n                             } else if (note_data->env < 3) {\n                                note_data->env = 3;\n                                if (note_data->env_level\n                                    > note_data->sample->env_target[3]) {\n                                    note_data->env_inc =\n                                    -note_data->sample->env_rate[3];\n                                } else {\n                                    note_data->env_inc =\n                                    note_data->sample->env_rate[3];\n                                }\n                            }\n                        } else {\n                            if (note_data->modes & SAMPLE_LOOP) {\n                                note_data->modes ^= SAMPLE_LOOP;\n                            }\n                            note_data->env_inc = 0;\n                        }\n                    }\n                    note_data->hold = 0x00;\n                }\n                note_data = note_data->next;\n            } while (note_data);\n        }\n    }\n}\n\nvoid _WM_do_control_data_increment(struct _mdi *mdi,\n                                      struct _event_data *data) {\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n\n    if ((mdi->channel[ch].reg_non == 0)\n        && (mdi->channel[ch].reg_data == 0x0000)) { /* Pitch Bend Range */\n        if (mdi->channel[ch].pitch_range < 0x3FFF)\n            mdi->channel[ch].pitch_range++;\n    }\n}\n\nvoid _WM_do_control_data_decrement(struct _mdi *mdi,\n                                      struct _event_data *data) {\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n\n    if ((mdi->channel[ch].reg_non == 0)\n        && (mdi->channel[ch].reg_data == 0x0000)) { /* Pitch Bend Range */\n        if (mdi->channel[ch].pitch_range > 0)\n            mdi->channel[ch].pitch_range--;\n    }\n}\nvoid _WM_do_control_non_registered_param_fine(struct _mdi *mdi,\n                                            struct _event_data *data) {\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n    mdi->channel[ch].reg_data = (mdi->channel[ch].reg_data & 0x3F80)\n                                | data->data.value;\n    mdi->channel[ch].reg_non = 1;\n}\n\nvoid _WM_do_control_non_registered_param_course(struct _mdi *mdi,\n                                     struct _event_data *data) {\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n    mdi->channel[ch].reg_data = (mdi->channel[ch].reg_data & 0x7F)\n                                | (data->data.value << 7);\n    mdi->channel[ch].reg_non = 1;\n}\n\nvoid _WM_do_control_registered_param_fine(struct _mdi *mdi,\n                                          struct _event_data *data) {\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n    mdi->channel[ch].reg_data = (mdi->channel[ch].reg_data & 0x3F80)\n                                | data->data.value;\n    mdi->channel[ch].reg_non = 0;\n}\n\nvoid _WM_do_control_registered_param_course(struct _mdi *mdi,\n                                            struct _event_data *data) {\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n    mdi->channel[ch].reg_data = (mdi->channel[ch].reg_data & 0x7F)\n                                | (data->data.value << 7);\n    mdi->channel[ch].reg_non = 0;\n}\n\nvoid _WM_do_control_channel_sound_off(struct _mdi *mdi,\n                                      struct _event_data *data) {\n    struct _note *note_data = mdi->note;\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n\n    if (note_data) {\n        do {\n            if ((note_data->noteid >> 8) == ch) {\n                note_data->active = 0;\n                if (note_data->replay) {\n                    note_data->replay = NULL;\n                }\n            }\n            note_data = note_data->next;\n        } while (note_data);\n    }\n}\n\nvoid _WM_do_control_channel_controllers_off(struct _mdi *mdi,\n                                            struct _event_data *data) {\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n\n    mdi->channel[ch].expression = 127;\n    mdi->channel[ch].pressure = 127;\n    mdi->channel[ch].reg_data = 0xffff;\n    mdi->channel[ch].pitch_range = 200;\n    mdi->channel[ch].pitch = 0;\n    mdi->channel[ch].pitch_adjust = 0;\n    mdi->channel[ch].hold = 0;\n\n    _WM_AdjustChannelVolumes(mdi, ch);\n}\n\nvoid _WM_do_control_channel_notes_off(struct _mdi *mdi,\n                                      struct _event_data *data) {\n    struct _note *note_data = mdi->note;\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n\n    if (mdi->channel[ch].isdrum)\n        return;\n    if (note_data) {\n        do {\n            if ((note_data->noteid >> 8) == ch) {\n                if (!note_data->hold) {\n                    if (note_data->modes & SAMPLE_ENVELOPE) {\n                        if (note_data->env < 5) {\n                            if (note_data->env_level\n                                > note_data->sample->env_target[5]) {\n                                note_data->env_inc =\n                                -note_data->sample->env_rate[5];\n                            } else {\n                                note_data->env_inc =\n                                note_data->sample->env_rate[5];\n                            }\n                            note_data->env = 5;\n                        }\n                    }\n                } else {\n                    note_data->hold |= HOLD_OFF;\n                }\n            }\n            note_data = note_data->next;\n        } while (note_data);\n    }\n}\n\nvoid _WM_do_control_dummy(struct _mdi *mdi, struct _event_data *data) {\n#ifdef DEBUG_MIDI\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__, ch, data->data.value);\n#else\n    UNUSED(data);\n#endif\n    UNUSED(mdi);\n}\n\nvoid _WM_do_patch(struct _mdi *mdi, struct _event_data *data) {\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n    if (!mdi->channel[ch].isdrum) {\n        mdi->channel[ch].patch = _WM_get_patch_data(mdi,\n                                                ((mdi->channel[ch].bank << 8) | data->data.value));\n    } else {\n        mdi->channel[ch].bank = data->data.value;\n    }\n}\n\nvoid _WM_do_channel_pressure(struct _mdi *mdi, struct _event_data *data) {\n    uint8_t ch = data->channel;\n    struct _note *note_data = mdi->note;\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n\n    mdi->channel[ch].pressure = data->data.value;\n\n    while (note_data) {\n        if (!note_data->ignore_chan_events) {\n            if ((note_data->noteid >> 8) == ch) {\n                note_data->velocity = data->data.value & 0xff;\n                _WM_AdjustNoteVolumes(mdi, ch, note_data);\n                if (note_data->replay) {\n                    note_data->replay->velocity = data->data.value & 0xff;\n                    _WM_AdjustNoteVolumes(mdi, ch, note_data->replay);\n                }\n            }\n        }\n        note_data = note_data->next;\n    }\n}\n\nvoid _WM_do_pitch(struct _mdi *mdi, struct _event_data *data) {\n    struct _note *note_data = mdi->note;\n    uint8_t ch = data->channel;\n\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n    mdi->channel[ch].pitch = data->data.value - 0x2000;\n\n    if (mdi->channel[ch].pitch < 0) {\n        mdi->channel[ch].pitch_adjust = mdi->channel[ch].pitch_range\n        * mdi->channel[ch].pitch / 8192;\n    } else {\n        mdi->channel[ch].pitch_adjust = mdi->channel[ch].pitch_range\n        * mdi->channel[ch].pitch / 8191;\n    }\n\n    if (note_data) {\n        do {\n            if ((note_data->noteid >> 8) == ch) {\n                note_data->sample_inc = get_inc(mdi, note_data);\n            }\n            note_data = note_data->next;\n        } while (note_data);\n    }\n}\n\nvoid _WM_do_sysex_roland_drum_track(struct _mdi *mdi, struct _event_data *data) {\n    uint8_t ch = data->channel;\n\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n\n    if (data->data.value > 0) {\n        mdi->channel[ch].isdrum = 1;\n        mdi->channel[ch].patch = NULL;\n    } else {\n        mdi->channel[ch].isdrum = 0;\n        mdi->channel[ch].patch = _WM_get_patch_data(mdi, 0);\n    }\n}\n\nvoid _WM_do_sysex_gm_reset(struct _mdi *mdi, struct _event_data *data) {\n    int i;\n\n    if (data != NULL) {\n        MIDI_EVENT_DEBUG(__FUNCTION__,data->channel, data->data.value);\n    } else {\n        MIDI_EVENT_DEBUG(__FUNCTION__,0, 0);\n    }\n\n    for (i = 0; i < 16; i++) {\n        mdi->channel[i].bank = 0;\n        if (i != 9) {\n            mdi->channel[i].patch = _WM_get_patch_data(mdi, 0);\n        } else {\n            mdi->channel[i].patch = NULL;\n        }\n        mdi->channel[i].hold = 0;\n        mdi->channel[i].volume = 100;\n        mdi->channel[i].pressure = 127;\n        mdi->channel[i].expression = 127;\n        mdi->channel[i].balance = 64;\n        mdi->channel[i].pan = 64;\n        mdi->channel[i].pitch = 0;\n        mdi->channel[i].pitch_range = 200;\n        mdi->channel[i].reg_data = 0xFFFF;\n        mdi->channel[i].isdrum = 0;\n    }\n    /* I would not expect notes to be active when this event\n     triggers but we'll adjust active notes as well just in case */\n    _WM_AdjustChannelVolumes(mdi,16); // A setting > 15 adjusts all channels\n\n    mdi->channel[9].isdrum = 1;\n}\n\nvoid _WM_do_sysex_roland_reset(struct _mdi *mdi, struct _event_data *data) {\n#ifdef DEBUG_MIDI\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__, ch, data->data.value);\n#else\n    UNUSED(data);\n#endif\n    _WM_do_sysex_gm_reset(mdi,data);\n}\n\nvoid _WM_do_sysex_yamaha_reset(struct _mdi *mdi, struct _event_data *data) {\n#ifdef DEBUG_MIDI\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__, ch, data->data.value);\n#else\n    UNUSED(data);\n#endif\n    _WM_do_sysex_gm_reset(mdi,data);\n}\n\nvoid _WM_Release_Allowance(struct _mdi *mdi) {\n    uint32_t release = 0;\n    uint32_t longest_release = 0;\n    \n    struct _note *note = mdi->note;\n    \n    while (note != NULL) {\n        \n        if (note->modes & SAMPLE_ENVELOPE) {\n            //ensure envelope isin a release state\n            if (note->env < 4) {\n                note->env = 4;\n            }\n        \n            // make sure this is set\n            note->env_inc = -note->sample->env_rate[note->env];\n        \n            release = note->env_level / -note->env_inc;\n        } else {\n            // Sample release\n            if (note->modes & SAMPLE_LOOP) {\n                note->modes ^= SAMPLE_LOOP;\n            }\n            release = note->sample->data_length - note->sample_pos;\n        }\n        \n        if (release > longest_release) longest_release = release;\n        note->replay = NULL;\n        note = note->next;\n    }\n    \n    mdi->samples_to_mix = longest_release;\n    \n    return;\n}\n\nvoid _WM_do_meta_endoftrack(struct _mdi *mdi, struct _event_data *data) {\n/* placeholder function so we can record eot in the event stream\n * for conversion function _WM_Event2Midi */\n#ifdef DEBUG_MIDI\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__, ch, data->data.value);\n#else\n    UNUSED(data);\n#endif\n\n    _WM_Release_Allowance(mdi);\n    return;\n}\n\nvoid _WM_do_meta_tempo(struct _mdi *mdi, struct _event_data *data) {\n/* placeholder function so we can record tempo in the event stream\n * for conversion function _WM_Event2Midi */\n#ifdef DEBUG_MIDI\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__, ch, data->data.value);\n#else\n    UNUSED(data);\n#endif\n    UNUSED(mdi);\n    return;\n}\n\nvoid _WM_do_meta_timesignature(struct _mdi *mdi, struct _event_data *data) {\n/* placeholder function so we can record tempo in the event stream\n * for conversion function _WM_Event2Midi */\n#ifdef DEBUG_MIDI\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__, ch, data->data.value);\n#else\n    UNUSED(data);\n#endif\n    UNUSED(mdi);\n    return;\n}\n\nvoid _WM_do_meta_keysignature(struct _mdi *mdi, struct _event_data *data) {\n/* placeholder function so we can record tempo in the event stream\n * for conversion function _WM_Event2Midi */\n#ifdef DEBUG_MIDI\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__, ch, data->data.value);\n#else\n    UNUSED(data);\n#endif\n    UNUSED(mdi);\n    return;\n}\n\nvoid _WM_do_meta_sequenceno(struct _mdi *mdi, struct _event_data *data) {\n/* placeholder function so we can record tempo in the event stream\n * for conversion function _WM_Event2Midi */\n#ifdef DEBUG_MIDI\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__, ch, data->data.value);\n#else\n    UNUSED(data);\n#endif\n    UNUSED(mdi);\n    return;\n}\n\nvoid _WM_do_meta_channelprefix(struct _mdi *mdi, struct _event_data *data) {\n/* placeholder function so we can record tempo in the event stream\n * for conversion function _WM_Event2Midi */\n#ifdef DEBUG_MIDI\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__, ch, data->data.value);\n#else\n    UNUSED(data);\n#endif\n    UNUSED(mdi);\n    return;\n}\n\nvoid _WM_do_meta_portprefix(struct _mdi *mdi, struct _event_data *data) {\n/* placeholder function so we can record tempo in the event stream\n * for conversion function _WM_Event2Midi */\n#ifdef DEBUG_MIDI\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__, ch, data->data.value);\n#else\n    UNUSED(data);\n#endif\n    UNUSED(mdi);\n    return;\n}\n\nvoid _WM_do_meta_smpteoffset(struct _mdi *mdi, struct _event_data *data) {\n/* placeholder function so we can record tempo in the event stream\n * for conversion function _WM_Event2Midi */\n#ifdef DEBUG_MIDI\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__, ch, data->data.value);\n#else\n    UNUSED(data);\n#endif\n    UNUSED(mdi);\n    return;\n}\n\nvoid _WM_do_meta_text(struct _mdi *mdi, struct _event_data *data) {\n/* placeholder function so we can record tempo in the event stream\n * for conversion function _WM_Event2Midi */\n#ifdef DEBUG_MIDI\n    uint8_t ch = data->channel;\n    MIDI_EVENT_SDEBUG(__FUNCTION__, ch, data->data.string);\n#endif\n    if (mdi->extra_info.mixer_options & WM_MO_TEXTASLYRIC) {\n        mdi->lyric = data->data.string;\n    }\n\n    return;\n}\n\nvoid _WM_do_meta_copyright(struct _mdi *mdi, struct _event_data *data) {\n/* placeholder function so we can record tempo in the event stream\n * for conversion function _WM_Event2Midi */\n#ifdef DEBUG_MIDI\n    uint8_t ch = data->channel;\n    MIDI_EVENT_SDEBUG(__FUNCTION__, ch, data->data.string);\n#else\n    UNUSED(data);\n#endif\n    UNUSED(mdi);\n    return;\n}\n\nvoid _WM_do_meta_trackname(struct _mdi *mdi, struct _event_data *data) {\n/* placeholder function so we can record tempo in the event stream\n * for conversion function _WM_Event2Midi */\n#ifdef DEBUG_MIDI\n    uint8_t ch = data->channel;\n    MIDI_EVENT_SDEBUG(__FUNCTION__, ch, data->data.string);\n#else\n    UNUSED(data);\n#endif\n    UNUSED(mdi);\n    return;\n}\n\nvoid _WM_do_meta_instrumentname(struct _mdi *mdi, struct _event_data *data) {\n/* placeholder function so we can record tempo in the event stream\n * for conversion function _WM_Event2Midi */\n#ifdef DEBUG_MIDI\n    uint8_t ch = data->channel;\n    MIDI_EVENT_SDEBUG(__FUNCTION__, ch, data->data.string);\n#else\n    UNUSED(data);\n#endif\n    UNUSED(mdi);\n    return;\n}\n\nvoid _WM_do_meta_lyric(struct _mdi *mdi, struct _event_data *data) {\n/* placeholder function so we can record tempo in the event stream\n * for conversion function _WM_Event2Midi */\n#ifdef DEBUG_MIDI\n    uint8_t ch = data->channel;\n    MIDI_EVENT_SDEBUG(__FUNCTION__, ch, data->data.string);\n#endif\n    if (!(mdi->extra_info.mixer_options & WM_MO_TEXTASLYRIC)) {\n        mdi->lyric = data->data.string;\n    }\n    return;\n}\n\nvoid _WM_do_meta_marker(struct _mdi *mdi, struct _event_data *data) {\n/* placeholder function so we can record tempo in the event stream\n * for conversion function _WM_Event2Midi */\n#ifdef DEBUG_MIDI\n    uint8_t ch = data->channel;\n    MIDI_EVENT_SDEBUG(__FUNCTION__, ch, data->data.string);\n#else\n    UNUSED(data);\n#endif\n    UNUSED(mdi);\n    return;\n}\n\nvoid _WM_do_meta_cuepoint(struct _mdi *mdi, struct _event_data *data) {\n/* placeholder function so we can record tempo in the event stream\n * for conversion function _WM_Event2Midi */\n#ifdef DEBUG_MIDI\n    uint8_t ch = data->channel;\n    MIDI_EVENT_SDEBUG(__FUNCTION__, ch, data->data.string);\n#else\n    UNUSED(data);\n#endif\n    UNUSED(mdi);\n    return;\n}\n\nvoid _WM_ResetToStart(struct _mdi *mdi) {\n    struct _event * event = NULL;\n\n    mdi->current_event = mdi->events;\n    mdi->samples_to_mix = 0;\n    mdi->extra_info.current_sample = 0;\n\n    _WM_do_sysex_gm_reset(mdi, NULL);\n\n    /* Ensure last event is NULL */\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = NULL;\n    mdi->events[mdi->event_count].event_data.channel = 0;\n    mdi->events[mdi->event_count].event_data.data.value = 0;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n\n    if (_WM_MixerOptions & WM_MO_STRIPSILENCE) {\n        event = mdi->events;\n        /* Scan for first note on removing any samples as we go */\n        if (event->do_event != *_WM_do_note_on) {\n            do {\n                if (event->samples_to_next != 0) {\n                    mdi->extra_info.approx_total_samples -= event->samples_to_next;\n                    event->samples_to_next = 0;\n                }\n                event++;\n                if (event == NULL) break;\n            } while (event->do_event != *_WM_do_note_on);\n        }\n\n        /* Reverse scan for last note off removing any samples as we go */\n        event = &mdi->events[mdi->event_count - 1];\n        if (event->do_event != *_WM_do_note_off) {\n            do {\n                mdi->extra_info.approx_total_samples -= event->samples_to_next;\n                event->samples_to_next = 0;\n                if (event == mdi->events) break; /* just to be safe */\n                event--;\n            } while (event->do_event != *_WM_do_note_off);\n        }\n        mdi->extra_info.approx_total_samples -= event->samples_to_next;\n        event->samples_to_next = 0;\n    }\n}\n\nint _WM_midi_setup_divisions(struct _mdi *mdi, uint32_t divisions) {\n    MIDI_EVENT_DEBUG(__FUNCTION__,0,0);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_midi_divisions;\n    mdi->events[mdi->event_count].event_data.channel = 0;\n    mdi->events[mdi->event_count].event_data.data.value = divisions;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}\n\nint _WM_midi_setup_noteoff(struct _mdi *mdi, uint8_t channel,\n                           uint8_t note, uint8_t velocity) {\n    MIDI_EVENT_DEBUG(__FUNCTION__,channel, note);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_note_off;\n    mdi->events[mdi->event_count].event_data.channel = channel;\n    mdi->events[mdi->event_count].event_data.data.value = (note << 8) | velocity;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}\n\nstatic int midi_setup_noteon(struct _mdi *mdi, uint8_t channel,\n                             uint8_t note, uint8_t velocity) {\n    MIDI_EVENT_DEBUG(__FUNCTION__,channel, note);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_note_on;\n    mdi->events[mdi->event_count].event_data.channel = channel;\n    mdi->events[mdi->event_count].event_data.data.value = (note << 8) | velocity;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n\n    if (mdi->channel[channel].isdrum)\n        _WM_load_patch(mdi, ((mdi->channel[channel].bank << 8) | (note | 0x80)));\n    return (0);\n}\n\nstatic int midi_setup_aftertouch(struct _mdi *mdi, uint8_t channel,\n                                 uint8_t note, uint8_t pressure) {\n    MIDI_EVENT_DEBUG(__FUNCTION__,channel, note);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_aftertouch;\n    mdi->events[mdi->event_count].event_data.channel = channel;\n    mdi->events[mdi->event_count].event_data.data.value = (note << 8) | pressure;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}\n\nstatic int midi_setup_control(struct _mdi *mdi, uint8_t channel,\n                              uint8_t controller, uint8_t setting) {\n    void (*tmp_event)(struct _mdi *mdi, struct _event_data *data) = NULL;\n    MIDI_EVENT_DEBUG(__FUNCTION__,channel, controller);\n\n    switch (controller) {\n        /*\n         **********************************************************************\n         FIXME: Need to add dummy events for MIDI events we don't support.\n         There is no reason not to store unsupported events in light of our\n         out to midi option.\n         **********************************************************************\n         */\n        case 0:\n            tmp_event = *_WM_do_control_bank_select;\n            mdi->channel[channel].bank = setting;\n            break;\n        case 6:\n            tmp_event = *_WM_do_control_data_entry_course;\n            break;\n        case 7:\n            tmp_event = *_WM_do_control_channel_volume;\n            mdi->channel[channel].volume = setting;\n            break;\n        case 8:\n            tmp_event = *_WM_do_control_channel_balance;\n            break;\n        case 10:\n            tmp_event = *_WM_do_control_channel_pan;\n            break;\n        case 11:\n            tmp_event = *_WM_do_control_channel_expression;\n            break;\n        case 38:\n            tmp_event = *_WM_do_control_data_entry_fine;\n            break;\n        case 64:\n            tmp_event = *_WM_do_control_channel_hold;\n            break;\n        case 96:\n            tmp_event = *_WM_do_control_data_increment;\n            break;\n        case 97:\n            tmp_event = *_WM_do_control_data_decrement;\n            break;\n        case 98:\n            tmp_event = *_WM_do_control_non_registered_param_fine;\n            break;\n        case 99:\n            tmp_event = *_WM_do_control_non_registered_param_course;\n            break;\n        case 100:\n            tmp_event = *_WM_do_control_registered_param_fine;\n            break;\n        case 101:\n            tmp_event = *_WM_do_control_registered_param_course;\n            break;\n        case 120:\n            tmp_event = *_WM_do_control_channel_sound_off;\n            break;\n        case 121:\n            tmp_event = *_WM_do_control_channel_controllers_off;\n            break;\n        case 123:\n            tmp_event = *_WM_do_control_channel_notes_off;\n            break;\n        default:\n            tmp_event = *_WM_do_control_dummy;\n            break;\n    }\n\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = tmp_event;\n    mdi->events[mdi->event_count].event_data.channel = channel;\n    if (tmp_event != *_WM_do_control_dummy) {\n        mdi->events[mdi->event_count].event_data.data.value = setting;\n    } else {\n        mdi->events[mdi->event_count].event_data.data.value = (controller << 8) | setting;\n    }\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}\n\nstatic int midi_setup_patch(struct _mdi *mdi, uint8_t channel, uint8_t patch) {\n    MIDI_EVENT_DEBUG(__FUNCTION__,channel, patch);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_patch;\n    mdi->events[mdi->event_count].event_data.channel = channel;\n    mdi->events[mdi->event_count].event_data.data.value = patch;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n\n    if (mdi->channel[channel].isdrum) {\n        mdi->channel[channel].bank = patch;\n    } else {\n        _WM_load_patch(mdi, ((mdi->channel[channel].bank << 8) | patch));\n        mdi->channel[channel].patch = _WM_get_patch_data(mdi,\n                                                     ((mdi->channel[channel].bank << 8) | patch));\n    }\n    return (0);\n}\n\nstatic int midi_setup_channel_pressure(struct _mdi *mdi, uint8_t channel,\n                                       uint8_t pressure) {\n    MIDI_EVENT_DEBUG(__FUNCTION__,channel, pressure);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_channel_pressure;\n    mdi->events[mdi->event_count].event_data.channel = channel;\n    mdi->events[mdi->event_count].event_data.data.value = pressure;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}\n\nstatic int midi_setup_pitch(struct _mdi *mdi, uint8_t channel, uint16_t pitch) {\n    MIDI_EVENT_DEBUG(__FUNCTION__,channel, pitch);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_pitch;\n    mdi->events[mdi->event_count].event_data.channel = channel;\n    mdi->events[mdi->event_count].event_data.data.value = pitch;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}\n\nstatic int midi_setup_sysex_roland_drum_track(struct _mdi *mdi,\n                                              uint8_t channel, uint16_t setting) {\n    MIDI_EVENT_DEBUG(__FUNCTION__,channel, setting);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = _WM_do_sysex_roland_drum_track;\n    mdi->events[mdi->event_count].event_data.channel = channel;\n    mdi->events[mdi->event_count].event_data.data.value = setting;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n\n    if (setting > 0) {\n        mdi->channel[channel].isdrum = 1;\n    } else {\n        mdi->channel[channel].isdrum = 0;\n    }\n    return (0);\n}\n\nstatic int midi_setup_sysex_gm_reset(struct _mdi *mdi) {\n    MIDI_EVENT_DEBUG(__FUNCTION__,0,0);\n\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_sysex_roland_reset;\n    mdi->events[mdi->event_count].event_data.channel = 0;\n    mdi->events[mdi->event_count].event_data.data.value = 0;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}\n\nstatic int midi_setup_sysex_roland_reset(struct _mdi *mdi) {\n    MIDI_EVENT_DEBUG(__FUNCTION__,0,0);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_sysex_roland_reset;\n    mdi->events[mdi->event_count].event_data.channel = 0;\n    mdi->events[mdi->event_count].event_data.data.value = 0;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}\n\nstatic int midi_setup_sysex_yamaha_reset(struct _mdi *mdi) {\n    MIDI_EVENT_DEBUG(__FUNCTION__,0,0);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_sysex_roland_reset;\n    mdi->events[mdi->event_count].event_data.channel = 0;\n    mdi->events[mdi->event_count].event_data.data.value = 0;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}\n\nint _WM_midi_setup_endoftrack(struct _mdi *mdi) {\n    MIDI_EVENT_DEBUG(__FUNCTION__,0,0);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_meta_endoftrack;\n    mdi->events[mdi->event_count].event_data.channel = 0;\n    mdi->events[mdi->event_count].event_data.data.value = 0;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}\n\nint _WM_midi_setup_tempo(struct _mdi *mdi, uint32_t setting) {\n    MIDI_EVENT_DEBUG(__FUNCTION__,0,setting);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_meta_tempo;\n    mdi->events[mdi->event_count].event_data.channel = 0;\n    mdi->events[mdi->event_count].event_data.data.value = setting;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}\n\nstatic int midi_setup_timesignature(struct _mdi *mdi, uint32_t setting) {\n    MIDI_EVENT_DEBUG(__FUNCTION__,0, setting);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_meta_timesignature;\n    mdi->events[mdi->event_count].event_data.channel = 0;\n    mdi->events[mdi->event_count].event_data.data.value = setting;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}\n\nstatic int midi_setup_keysignature(struct _mdi *mdi, uint32_t setting) {\n    MIDI_EVENT_DEBUG(__FUNCTION__,0, setting);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_meta_keysignature;\n    mdi->events[mdi->event_count].event_data.channel = 0;\n    mdi->events[mdi->event_count].event_data.data.value = setting;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}\n\nstatic int midi_setup_sequenceno(struct _mdi *mdi, uint32_t setting) {\n    MIDI_EVENT_DEBUG(__FUNCTION__,0, setting);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_meta_sequenceno;\n    mdi->events[mdi->event_count].event_data.channel = 0;\n    mdi->events[mdi->event_count].event_data.data.value = setting;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}\n\nstatic int midi_setup_channelprefix(struct _mdi *mdi, uint32_t setting) {\n    MIDI_EVENT_DEBUG(__FUNCTION__,0, setting);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_meta_channelprefix;\n    mdi->events[mdi->event_count].event_data.channel = 0;\n    mdi->events[mdi->event_count].event_data.data.value = setting;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}\n\nstatic int midi_setup_portprefix(struct _mdi *mdi, uint32_t setting) {\n    MIDI_EVENT_DEBUG(__FUNCTION__,0, setting);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_meta_portprefix;\n    mdi->events[mdi->event_count].event_data.channel = 0;\n    mdi->events[mdi->event_count].event_data.data.value = setting;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}\n\nstatic int midi_setup_smpteoffset(struct _mdi *mdi, uint32_t setting) {\n    MIDI_EVENT_DEBUG(__FUNCTION__,0, setting);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_meta_smpteoffset;\n    mdi->events[mdi->event_count].event_data.channel = 0;\n    mdi->events[mdi->event_count].event_data.data.value = setting;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}\n\nstatic void strip_text(char * text) {\n    char * ch_loc = NULL;\n\n    ch_loc = strrchr(text, '\\n');\n    while (ch_loc != NULL) {\n        *ch_loc = ' ';\n        ch_loc = strrchr(text, '\\n');\n    }\n    ch_loc = strrchr(text, '\\r');\n    while (ch_loc != NULL) {\n        *ch_loc = ' ';\n        ch_loc = strrchr(text, '\\r');\n    }\n}\n\nstatic int midi_setup_text(struct _mdi *mdi, char * text) {\n    MIDI_EVENT_SDEBUG(__FUNCTION__,0, text);\n    strip_text(text);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_meta_text;\n    mdi->events[mdi->event_count].event_data.channel = 0;\n    mdi->events[mdi->event_count].event_data.data.string = text;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}\n\nstatic int midi_setup_copyright(struct _mdi *mdi, char * text) {\n    MIDI_EVENT_SDEBUG(__FUNCTION__,0, text);\n    strip_text(text);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_meta_copyright;\n    mdi->events[mdi->event_count].event_data.channel = 0;\n    mdi->events[mdi->event_count].event_data.data.string = text;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}\n\nstatic int midi_setup_trackname(struct _mdi *mdi, char * text) {\n    MIDI_EVENT_SDEBUG(__FUNCTION__,0, text);\n    strip_text(text);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_meta_trackname;\n    mdi->events[mdi->event_count].event_data.channel = 0;\n    mdi->events[mdi->event_count].event_data.data.string = text;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}\n\nstatic int midi_setup_instrumentname(struct _mdi *mdi, char * text) {\n    MIDI_EVENT_SDEBUG(__FUNCTION__,0, text);\n    strip_text(text);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_meta_instrumentname;\n    mdi->events[mdi->event_count].event_data.channel = 0;\n    mdi->events[mdi->event_count].event_data.data.string = text;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}\n\nstatic int midi_setup_lyric(struct _mdi *mdi, char * text) {\n    MIDI_EVENT_SDEBUG(__FUNCTION__,0, text);\n    strip_text(text);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_meta_lyric;\n    mdi->events[mdi->event_count].event_data.channel = 0;\n    mdi->events[mdi->event_count].event_data.data.string = text;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}\n\nstatic int midi_setup_marker(struct _mdi *mdi, char * text) {\n    MIDI_EVENT_SDEBUG(__FUNCTION__,0, text);\n    strip_text(text);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_meta_marker;\n    mdi->events[mdi->event_count].event_data.channel = 0;\n    mdi->events[mdi->event_count].event_data.data.string = text;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}\n\nstatic int midi_setup_cuepoint(struct _mdi *mdi, char * text) {\n    MIDI_EVENT_SDEBUG(__FUNCTION__,0, text);\n    strip_text(text);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_meta_cuepoint;\n    mdi->events[mdi->event_count].event_data.channel = 0;\n    mdi->events[mdi->event_count].event_data.data.string = text;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}\n\nstruct _mdi *\n_WM_initMDI(void) {\n    struct _mdi *mdi;\n\n    mdi = malloc(sizeof(struct _mdi));\n    memset(mdi, 0, (sizeof(struct _mdi)));\n\n    mdi->extra_info.copyright = NULL;\n    mdi->extra_info.mixer_options = _WM_MixerOptions;\n\n    _WM_load_patch(mdi, 0x0000);\n\n    mdi->events_size = MEM_CHUNK;\n    mdi->events = malloc(mdi->events_size * sizeof(struct _event));\n    mdi->event_count = 0;\n    mdi->current_event = mdi->events;\n\n    mdi->samples_to_mix = 0;\n    mdi->extra_info.current_sample = 0;\n    mdi->extra_info.total_midi_time = 0;\n    mdi->extra_info.approx_total_samples = 0;\n\n    mdi->dyn_vol = 1.0;\n    mdi->dyn_vol_adjust = 0.0;\n    mdi->dyn_vol_peak = 0;\n    mdi->dyn_vol_to_reach = 1.0;\n\n    mdi->is_type2 = 0;\n\n    mdi->lyric = NULL;\n\n    _WM_do_sysex_gm_reset(mdi, NULL);\n\n    return (mdi);\n}\n\nvoid _WM_freeMDI(struct _mdi *mdi) {\n    struct _sample *tmp_sample;\n    uint32_t i;\n\n    if (mdi->patch_count != 0) {\n        _WM_Lock(&_WM_patch_lock);\n        for (i = 0; i < mdi->patch_count; i++) {\n            mdi->patches[i]->inuse_count--;\n            if (mdi->patches[i]->inuse_count == 0) {\n                /* free samples here */\n                while (mdi->patches[i]->first_sample) {\n                    tmp_sample = mdi->patches[i]->first_sample->next;\n                    free(mdi->patches[i]->first_sample->data);\n                    free(mdi->patches[i]->first_sample);\n                    mdi->patches[i]->first_sample = tmp_sample;\n                }\n                mdi->patches[i]->loaded = 0;\n            }\n        }\n        _WM_Unlock(&_WM_patch_lock);\n        free(mdi->patches);\n    }\n\n    if (mdi->event_count != 0) {\n        for (i = 0; i < mdi->event_count; i++) {\n            /* Free up the string event storage */\n            if (mdi->events[i].do_event == _WM_do_meta_text) {\n                free(mdi->events[i].event_data.data.string);\n            } else if (mdi->events[i].do_event == _WM_do_meta_text) {\n                free(mdi->events[i].event_data.data.string);\n            } else if (mdi->events[i].do_event == _WM_do_meta_copyright) {\n                free(mdi->events[i].event_data.data.string);\n            } else if (mdi->events[i].do_event == _WM_do_meta_trackname) {\n                free(mdi->events[i].event_data.data.string);\n            } else if (mdi->events[i].do_event == _WM_do_meta_instrumentname) {\n                free(mdi->events[i].event_data.data.string);\n            } else if (mdi->events[i].do_event == _WM_do_meta_lyric) {\n                free(mdi->events[i].event_data.data.string);\n            } else if (mdi->events[i].do_event == _WM_do_meta_marker) {\n                free(mdi->events[i].event_data.data.string);\n            } else if (mdi->events[i].do_event == _WM_do_meta_cuepoint) {\n                free(mdi->events[i].event_data.data.string);\n            }\n        }\n    }\n\n    free(mdi->events);\n    _WM_free_reverb(mdi->reverb);\n    free(mdi->mix_buffer);\n    free(mdi);\n}\n\nuint32_t _WM_SetupMidiEvent(struct _mdi *mdi, uint8_t * event_data, uint8_t running_event) {\n    /*\n     Only add standard MIDI and Sysex events in here.\n     Non-standard events need to be handled by calling function\n     to avoid compatibility issues.\n\n     TODO:\n     Add value limit checks\n     */\n    uint32_t ret_cnt = 0;\n    uint8_t command = 0;\n    uint8_t channel = 0;\n    uint8_t data_1 = 0;\n    uint8_t data_2 = 0;\n    char *text = NULL;\n\n    if (event_data[0] >= 0x80) {\n        command = *event_data & 0xf0;\n        channel = *event_data++ & 0x0f;\n        ret_cnt++;\n    } else {\n        command = running_event & 0xf0;\n        channel = running_event & 0x0f;\n    }\n\n    switch(command) {\n        case 0x80:\n        _SETUP_NOTEOFF:\n            data_1 = *event_data++;\n            data_2 = *event_data++;\n            _WM_midi_setup_noteoff(mdi, channel, data_1, data_2);\n            ret_cnt += 2;\n            break;\n        case 0x90:\n            if (event_data[1] == 0) goto _SETUP_NOTEOFF; /* A velocity of 0 in a note on is actually a note off */\n            data_1 = *event_data++;\n            data_2 = *event_data++;\n            midi_setup_noteon(mdi, channel, data_1, data_2);\n            ret_cnt += 2;\n            break;\n        case 0xa0:\n            data_1 = *event_data++;\n            data_2 = *event_data++;\n            midi_setup_aftertouch(mdi, channel, data_1, data_2);\n            ret_cnt += 2;\n            break;\n        case 0xb0:\n            data_1 = *event_data++;\n            data_2 = *event_data++;\n            midi_setup_control(mdi, channel, data_1, data_2);\n            ret_cnt += 2;\n            break;\n        case 0xc0:\n            data_1 = *event_data++;\n            midi_setup_patch(mdi, channel, data_1);\n            ret_cnt++;\n            break;\n        case 0xd0:\n            data_1 = *event_data++;\n            midi_setup_channel_pressure(mdi, channel, data_1);\n            ret_cnt++;\n            break;\n        case 0xe0:\n            data_1 = *event_data++;\n            data_2 = *event_data++;\n            midi_setup_pitch(mdi, channel, ((data_2 << 7) | (data_1 & 0x7f)));\n            ret_cnt += 2;\n            break;\n        case 0xf0:\n            if (channel == 0x0f) {\n                /*\n                 MIDI Meta Events\n                 */\n                uint32_t tmp_length = 0;\n                if ((event_data[0] == 0x00) && (event_data[1] == 0x02)) {\n                    /*\n                     Sequence Number\n                     We only setting this up here for WM_Event2Midi function\n                     */\n                    midi_setup_sequenceno(mdi, ((event_data[2] << 8) + event_data[3]));\n                    ret_cnt += 4;\n                } else if (event_data[0] == 0x01) {\n                    /* Text Event */\n                    /* Get Length */\n                    event_data++;\n                    ret_cnt++;\n                    if (*event_data > 0x7f) {\n                        do {\n                            tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                            event_data++;\n                            ret_cnt++;\n                        } while (*event_data > 0x7f);\n                    }\n                    tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                    event_data++;\n                    ret_cnt++;\n\n                    text = malloc(tmp_length + 1);\n                    memcpy(text, event_data, tmp_length);\n                    text[tmp_length] = '\\0';\n                    midi_setup_text(mdi, text);\n\n                    ret_cnt += tmp_length;\n\n                } else if (event_data[0] == 0x02) {\n                    /* Copyright Event */\n                    /* Get Length */\n                    event_data++;\n                    ret_cnt++;\n                    if (*event_data > 0x7f) {\n                        do {\n                            tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                            event_data++;\n                            ret_cnt++;\n                        } while (*event_data > 0x7f);\n                    }\n                    tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                    event_data++;\n                    ret_cnt++;\n\n                    /* Copy copyright info in the getinfo struct */\n                    if (mdi->extra_info.copyright) {\n                        mdi->extra_info.copyright = realloc(mdi->extra_info.copyright,(strlen(mdi->extra_info.copyright) + 1 + tmp_length + 1));\n                        memcpy(&mdi->extra_info.copyright[strlen(mdi->extra_info.copyright) + 1], event_data, tmp_length);\n                        mdi->extra_info.copyright[strlen(mdi->extra_info.copyright) + 1 + tmp_length] = '\\0';\n                        mdi->extra_info.copyright[strlen(mdi->extra_info.copyright)] = '\\n';\n                    } else {\n                        mdi->extra_info.copyright = malloc(tmp_length + 1);\n                        memcpy(mdi->extra_info.copyright, event_data, tmp_length);\n                        mdi->extra_info.copyright[tmp_length] = '\\0';\n                    }\n\n                    /* NOTE: free'd when events are cleared during closure of mdi */\n                    text = malloc(tmp_length + 1);\n                    memcpy(text, event_data, tmp_length);\n                    text[tmp_length] = '\\0';\n                    midi_setup_copyright(mdi, text);\n\n                    ret_cnt += tmp_length;\n\n                } else if (event_data[0] == 0x03) {\n                    /* Track Name Event */\n                    /* Get Length */\n                    event_data++;\n                    ret_cnt++;\n                    if (*event_data > 0x7f) {\n                        do {\n                            tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                            event_data++;\n                            ret_cnt++;\n                        } while (*event_data > 0x7f);\n                    }\n                    tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                    event_data++;\n                    ret_cnt++;\n\n                    text = malloc(tmp_length + 1);\n                    memcpy(text, event_data, tmp_length);\n                    text[tmp_length] = '\\0';\n                    midi_setup_trackname(mdi, text);\n\n                    ret_cnt += tmp_length;\n\n                } else if (event_data[0] == 0x04) {\n                    /* Instrument Name Event */\n                    /* Get Length */\n                    event_data++;\n                    ret_cnt++;\n                    if (*event_data > 0x7f) {\n                        do {\n                            tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                            event_data++;\n                            ret_cnt++;\n                        } while (*event_data > 0x7f);\n                    }\n                    tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                    event_data++;\n                    ret_cnt++;\n\n                    text = malloc(tmp_length + 1);\n                    memcpy(text, event_data, tmp_length);\n                    text[tmp_length] = '\\0';\n                    midi_setup_instrumentname(mdi, text);\n\n                    ret_cnt += tmp_length;\n\n                } else if (event_data[0] == 0x05) {\n                    /* Lyric Event */\n                    /* Get Length */\n                    event_data++;\n                    ret_cnt++;\n                    if (*event_data > 0x7f) {\n                        do {\n                            tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                            event_data++;\n                            ret_cnt++;\n                        } while (*event_data > 0x7f);\n                    }\n                    tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                    event_data++;\n                    ret_cnt++;\n\n                    text = malloc(tmp_length + 1);\n                    memcpy(text, event_data, tmp_length);\n                    text[tmp_length] = '\\0';\n                    midi_setup_lyric(mdi, text);\n\n                    ret_cnt += tmp_length;\n\n                } else if (event_data[0] == 0x06) {\n                    /* Marker Event */\n                    /* Get Length */\n                    event_data++;\n                    ret_cnt++;\n                    if (*event_data > 0x7f) {\n                        do {\n                            tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                            event_data++;\n                            ret_cnt++;\n                        } while (*event_data > 0x7f);\n                    }\n                    tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                    event_data++;\n                    ret_cnt++;\n\n                    text = malloc(tmp_length + 1);\n                    memcpy(text, event_data, tmp_length);\n                    text[tmp_length] = '\\0';\n                    midi_setup_marker(mdi, text);\n\n                    ret_cnt += tmp_length;\n\n                } else if (event_data[0] == 0x07) {\n                    /* Cue Point Event */\n                    /* Get Length */\n                    event_data++;\n                    ret_cnt++;\n                    if (*event_data > 0x7f) {\n                        do {\n                            tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                            event_data++;\n                            ret_cnt++;\n                        } while (*event_data > 0x7f);\n                    }\n                    tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                    event_data++;\n                    ret_cnt++;\n\n                    text = malloc(tmp_length + 1);\n                    memcpy(text, event_data, tmp_length);\n                    text[tmp_length] = '\\0';\n                    midi_setup_cuepoint(mdi, text);\n\n                    ret_cnt += tmp_length;\n\n                } else if ((event_data[0] == 0x20) && (event_data[1] == 0x01)) {\n                    /*\n                     Channel Prefix\n                     We only setting this up here for WM_Event2Midi function\n                     */\n                    midi_setup_channelprefix(mdi, event_data[2]);\n                    ret_cnt += 3;\n                } else if ((event_data[0] == 0x21) && (event_data[1] == 0x01)) {\n                    /*\n                     Port Prefix\n                     We only setting this up here for WM_Event2Midi function\n                     */\n                    midi_setup_portprefix(mdi, event_data[2]);\n                    ret_cnt += 3;\n                } else if ((event_data[0] == 0x2F) && (event_data[1] == 0x00)) {\n                    /*\n                     End of Track\n                     Deal with this inside calling function\n                     We only setting this up here for _WM_Event2Midi function\n                     */\n                    _WM_midi_setup_endoftrack(mdi);\n                    ret_cnt += 2;\n                } else if ((event_data[0] == 0x51) && (event_data[1] == 0x03)) {\n                    /*\n                     Tempo\n                     Deal with this inside calling function.\n                     We only setting this up here for _WM_Event2Midi function\n                     */\n                    _WM_midi_setup_tempo(mdi, ((event_data[2] << 16) + (event_data[3] << 8) + event_data[4]));\n                    ret_cnt += 5;\n                } else if ((event_data[0] == 0x54) && (event_data[1] == 0x05)) {\n                    /*\n                     SMPTE Offset\n                     We only setting this up here for WM_Event2Midi function\n                     */\n                    midi_setup_smpteoffset(mdi, ((event_data[3] << 24) + (event_data[4] << 16) + (event_data[5] << 8) + event_data[6]));\n\n                    /*\n                     Because this has 5 bytes of data we gonna \"hack\" it a little\n                     */\n                    mdi->events[mdi->events_size - 1].event_data.channel = event_data[2];\n\n                    ret_cnt += 7;\n                } else if ((event_data[0] == 0x58) && (event_data[1] == 0x04)) {\n                    /*\n                     Time Signature\n                     We only setting this up here for WM_Event2Midi function\n                     */\n                    midi_setup_timesignature(mdi, ((event_data[2] << 24) + (event_data[3] << 16) + (event_data[4] << 8) + event_data[5]));\n                    ret_cnt += 6;\n                } else if ((event_data[0] == 0x59) && (event_data[1] == 0x02)) {\n                    /*\n                     Key Signature\n                     We only setting this up here for WM_Event2Midi function\n                     */\n                    midi_setup_keysignature(mdi, ((event_data[2] << 8) + event_data[3]));\n                    ret_cnt += 4;\n                } else {\n                    /*\n                     Unsupported Meta Event\n                     */\n                    event_data++;\n                    ret_cnt++;\n                    if (*event_data > 0x7f) {\n                        do {\n                            tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                            event_data++;\n                            ret_cnt++;\n                        } while (*event_data > 0x7f);\n                    }\n                    tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                    ret_cnt++;\n                    ret_cnt += tmp_length;\n                }\n\n            } else if ((channel == 0) || (channel == 7)) {\n                /*\n                 Sysex Events\n                 */\n                uint32_t sysex_len = 0;\n                uint8_t *sysex_store = NULL;\n\n                if (*event_data > 0x7f) {\n                    do {\n                        sysex_len = (sysex_len << 7) + (*event_data & 0x7F);\n                        event_data++;\n                        ret_cnt++;\n                    } while (*event_data > 0x7f);\n                }\n                sysex_len = (sysex_len << 7) + (*event_data & 0x7F);\n                event_data++;\n                if (!sysex_len) break;\n                ret_cnt++;\n\n                sysex_store = malloc(sizeof(uint8_t) * sysex_len);\n                memcpy(sysex_store, event_data, sysex_len);\n\n                if (sysex_store[sysex_len - 1] == 0xF7) {\n                    uint8_t rolandsysexid[] = { 0x41, 0x10, 0x42, 0x12 };\n                    if (memcmp(rolandsysexid, sysex_store, 4) == 0) {\n                        /* For Roland Sysex Messages */\n                        /* checksum */\n                        uint8_t sysex_cs = 0;\n                        uint32_t sysex_ofs = 4;\n                        do {\n                            sysex_cs += sysex_store[sysex_ofs];\n                            if (sysex_cs > 0x7F) {\n                                sysex_cs -= 0x80;\n                            }\n                            sysex_ofs++;\n                        } while (sysex_store[sysex_ofs + 1] != 0xf7);\n                        sysex_cs = 128 - sysex_cs;\n                        /* is roland sysex message valid */\n                        if (sysex_cs == sysex_store[sysex_ofs]) {\n                            /* process roland sysex event */\n                            if (sysex_store[4] == 0x40) {\n                                if (((sysex_store[5] & 0xf0) == 0x10) && (sysex_store[6] == 0x15)) {\n                                    /* Roland Drum Track Setting */\n                                    uint8_t sysex_ch = 0x0f & sysex_store[5];\n                                    if (sysex_ch == 0x00) {\n                                        sysex_ch = 0x09;\n                                    } else if (sysex_ch <= 0x09) {\n                                        sysex_ch -= 1;\n                                    }\n                                    midi_setup_sysex_roland_drum_track(mdi, sysex_ch, sysex_store[7]);\n                                } else if ((sysex_store[5] == 0x00) && (sysex_store[6] == 0x7F) && (sysex_store[7] == 0x00)) {\n                                    /* Roland GS Reset */\n                                    midi_setup_sysex_roland_reset(mdi);\n                                }\n                            }\n                        }\n                    } else {\n                        /* For non-Roland Sysex Messages */\n                        uint8_t gm_reset[] = {0x7e, 0x7f, 0x09, 0x01, 0xf7};\n                        uint8_t yamaha_reset[] = {0x43, 0x10, 0x4c, 0x00, 0x00, 0x7e, 0x00, 0xf7};\n\n                        if (memcmp(gm_reset, sysex_store, 5) == 0) {\n                            /* GM Reset */\n                            midi_setup_sysex_gm_reset(mdi);\n                        } else if (memcmp(yamaha_reset,sysex_store,8) == 0) {\n                            /* Yamaha Reset */\n                            midi_setup_sysex_yamaha_reset(mdi);\n                        }\n                    }\n                }\n                free(sysex_store);\n                sysex_store = NULL;\n                /*\n                event_data += sysex_len;\n                */\n                ret_cnt += sysex_len;\n            } else {\n                _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(unrecognized meta type event)\", 0);\n                return 0;\n            }\n            break;\n\n        default: /* Should NEVER get here */\n            ret_cnt = 0;\n            break;\n    }\n    if (ret_cnt == 0)\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(missing event)\", 0);\n    return ret_cnt;\n}\n\n"], "fixing_code": ["/*\n * internal_midi.h -- Midi Wavetable Processing library\n *\n * Copyright (C) WildMIDI Developers 2001-2016\n *\n * This file is part of WildMIDI.\n *\n * WildMIDI is free software: you can redistribute and/or modify the player\n * under the terms of the GNU General Public License and you can redistribute\n * and/or modify the library under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation, either version 3 of\n * the licenses, or(at your option) any later version.\n *\n * WildMIDI is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License and\n * the GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License and the\n * GNU Lesser General Public License along with WildMIDI.  If not,  see\n * <http://www.gnu.org/licenses/>.\n */\n\n#ifndef __INTERNAL_MIDI_H\n#define __INTERNAL_MIDI_H\n\nstruct _channel {\n    uint8_t bank;\n    struct _patch *patch;\n    uint8_t hold;\n    uint8_t volume;\n    uint8_t pressure;\n    uint8_t expression;\n    int8_t  balance;\n    int8_t  pan;\n    int16_t left_adjust;\n    int16_t right_adjust;\n    int16_t pitch;\n    int16_t pitch_range;\n    int32_t pitch_adjust;\n    uint16_t reg_data;\n    uint8_t reg_non;\n    uint8_t isdrum;\n};\n\nstruct _event_data {\n    uint8_t channel;\n    union Data {\n        uint32_t value;\n        char * string;\n    } data;\n};\n\nstruct _note {\n    uint16_t noteid;\n    uint8_t velocity;\n    struct _patch *patch;\n    struct _sample *sample;\n    uint32_t sample_pos;\n    uint32_t sample_inc;\n    int32_t env_inc;\n    uint8_t env;\n    int32_t env_level;\n    uint8_t modes;\n    uint8_t hold;\n    uint8_t active;\n    struct _note *replay;\n    struct _note *next;\n    uint32_t left_mix_volume;\n    uint32_t right_mix_volume;\n    uint8_t is_off;\n    uint8_t ignore_chan_events;\n};\n\nstruct _mdi;\n\nstruct _event {\n    void (*do_event)(struct _mdi *mdi, struct _event_data *data);\n    struct _event_data event_data;\n    uint32_t samples_to_next;\n    uint32_t samples_to_next_fixed;\n};\n\nstruct _mdi {\n    int lock;\n    uint32_t samples_to_mix;\n    struct _event *events;\n    struct _event *current_event;\n    uint32_t event_count;\n    uint32_t events_size; /* try to stay optimally ahead to prevent reallocs */\n    struct _WM_Info extra_info;\n    struct _WM_Info *tmp_info;\n    uint16_t midi_master_vol;\n    struct _channel channel[16];\n    struct _note *note;\n    struct _note note_table[2][16][128];\n\n    struct _patch **patches;\n    uint32_t patch_count;\n    int16_t amp;\n\n    int32_t *mix_buffer;\n    uint32_t mix_buffer_size;\n\n    struct _rvb *reverb;\n\n    int32_t dyn_vol_peak;\n    double dyn_vol_adjust;\n    double dyn_vol;\n    double dyn_vol_to_reach;\n\n    uint8_t is_type2;\n\n    char *lyric;\n};\n\n\nextern int16_t _WM_lin_volume[];\nextern uint32_t _WM_freq_table[];\n\n/* ===================== */\n\n/*\n * All \"do\" functions need to be \"extern\" for playback\n */\nextern void _WM_do_midi_divisions(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_note_off(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_note_on(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_aftertouch(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_control_bank_select(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_control_data_entry_course(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_control_channel_volume(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_control_channel_balance(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_control_channel_pan(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_control_channel_expression(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_control_data_entry_fine(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_control_channel_hold(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_control_data_increment(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_control_data_decrement(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_control_non_registered_param_fine(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_control_non_registered_param_course(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_control_registered_param_fine(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_control_registered_param_course(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_control_channel_sound_off(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_control_channel_controllers_off(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_control_channel_notes_off(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_control_dummy(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_patch(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_channel_pressure(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_pitch(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_sysex_roland_drum_track(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_sysex_gm_reset(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_sysex_roland_reset(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_sysex_yamaha_reset(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_meta_endoftrack(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_meta_tempo(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_meta_timesignature(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_meta_keysignature(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_meta_sequenceno(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_meta_channelprefix(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_meta_portprefix(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_meta_smpteoffset(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_meta_text(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_meta_copyright(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_meta_trackname(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_meta_instrumentname(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_meta_lyric(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_meta_marker(struct _mdi *mdi, struct _event_data *data);\nextern void _WM_do_meta_cuepoint(struct _mdi *mdi, struct _event_data *data);\n\n/*\n * We need to expose these fuctions for use on some or the parsers due to some\n * formats not being able to trigger these events via _WM_Setup_Midi_Event.\n */\nextern int _WM_midi_setup_noteoff(struct _mdi *mdi, uint8_t channel, uint8_t note, uint8_t velocity);\nextern int _WM_midi_setup_endoftrack(struct _mdi *mdi);\nextern int _WM_midi_setup_tempo(struct _mdi *mdi, uint32_t setting);\n\n/* ===================== */\n\n/*\n * Only non-standard midi event or non-track event setup functions need to be here\n */\nextern int _WM_midi_setup_divisions(struct _mdi *mdi, uint32_t divisions);\n\n/* ===================== */\n\n/*\n * All other declarations\n */\n\nextern struct _mdi * _WM_initMDI(void);\nextern void _WM_freeMDI(struct _mdi *mdi);\nextern uint32_t _WM_SetupMidiEvent(struct _mdi *mdi, uint8_t * event_data, uint32_t siz, uint8_t running_event);\nextern void _WM_ResetToStart(struct _mdi *mdi);\nextern void _WM_do_pan_adjust(struct _mdi *mdi, uint8_t ch);\nextern void _WM_do_note_off_extra(struct _note *nte);\n/* extern void _WM_DynamicVolumeAdjust(struct _mdi *mdi, int32_t *tmp_buffer, uint32_t buffer_used);*/\nextern void _WM_AdjustChannelVolumes(struct _mdi *mdi, uint8_t ch);\nextern float _WM_GetSamplesPerTick(uint32_t divisions, uint32_t tempo);\n\n#endif /* __INTERNAL_MIDI_H */\n\n", "/*\n * hmi.c -- Midi Wavetable Processing library\n *\n * Copyright (C) WildMIDI Developers 2001-2016\n *\n * This file is part of WildMIDI.\n *\n * WildMIDI is free software: you can redistribute and/or modify the player\n * under the terms of the GNU General Public License and you can redistribute\n * and/or modify the library under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation, either version 3 of\n * the licenses, or(at your option) any later version.\n *\n * WildMIDI is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License and\n * the GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License and the\n * GNU Lesser General Public License along with WildMIDI.  If not,  see\n * <http://www.gnu.org/licenses/>.\n */\n\n#include \"config.h\"\n\n#include <stdint.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n\n#include \"common.h\"\n#include \"wm_error.h\"\n#include \"wildmidi_lib.h\"\n#include \"internal_midi.h\"\n#include \"reverb.h\"\n#include \"f_hmi.h\"\n\n/*\n Turns hmp file data into an event stream\n */\nstruct _mdi *\n_WM_ParseNewHmi(uint8_t *hmi_data, uint32_t hmi_size) {\n    uint32_t hmi_tmp = 0;\n    uint8_t *hmi_base = hmi_data;\n    uint32_t data_siz;\n    uint16_t hmi_bpm = 0;\n    uint16_t hmi_division = 0;\n\n    uint32_t hmi_track_cnt = 0;\n    uint32_t *hmi_track_offset = NULL;\n    uint32_t i = 0;\n    uint32_t j = 0;\n    uint8_t *hmi_addr = NULL;\n    uint32_t *hmi_track_header_length = NULL;\n    struct _mdi *hmi_mdi = NULL;\n    uint32_t tempo_f = 5000000.0;\n    uint32_t *hmi_track_end = NULL;\n    uint8_t hmi_tracks_ended = 0;\n    uint8_t *hmi_running_event = NULL;\n    uint32_t setup_ret = 0;\n    uint32_t *hmi_delta = NULL;\n\n    uint32_t smallest_delta = 0;\n    uint32_t subtract_delta = 0;\n\n    uint32_t sample_count = 0;\n    float sample_count_f = 0;\n    float sample_remainder = 0;\n\n    float samples_per_delta_f = 0.0;\n\n    struct _note {\n        uint32_t length;\n        uint8_t channel;\n    } *note;\n\n\n    if (memcmp(hmi_data, \"HMI-MIDISONG061595\", 18)) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_HMI, NULL, 0);\n        return NULL;\n    }\n\n    //FIXME: Unsure if this is correct but it seems to be the only offset that plays the files at what appears to be the right speed.\n    hmi_bpm = hmi_data[212];\n\n    hmi_division = 60;\n\n    hmi_track_cnt = hmi_data[228];\n\n    hmi_mdi = _WM_initMDI();\n\n    _WM_midi_setup_divisions(hmi_mdi, hmi_division);\n\n    if ((_WM_MixerOptions & WM_MO_ROUNDTEMPO)) {\n        tempo_f = (float) (60000000 / hmi_bpm) + 0.5f;\n    } else {\n        tempo_f = (float) (60000000 / hmi_bpm);\n    }\n    samples_per_delta_f = _WM_GetSamplesPerTick(hmi_division, (uint32_t)tempo_f);\n\n    _WM_midi_setup_tempo(hmi_mdi, (uint32_t)tempo_f);\n\n    hmi_track_offset = (uint32_t *)malloc(sizeof(uint32_t) * hmi_track_cnt);\n    hmi_track_header_length = malloc(sizeof(uint32_t) * hmi_track_cnt);\n    hmi_track_end = malloc(sizeof(uint32_t) * hmi_track_cnt);\n    hmi_delta = malloc(sizeof(uint32_t) * hmi_track_cnt);\n    note = malloc(sizeof(struct _note) * 128 * hmi_track_cnt);\n    hmi_running_event = malloc(sizeof(uint8_t) * 128 * hmi_track_cnt);\n\n    hmi_data += 370;\n\n    smallest_delta = 0xffffffff;\n\n    if (hmi_size < (370 + (hmi_track_cnt * 17))) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_HMI, \"file too short\", 0);\n        goto _hmi_end;\n    }\n\n    hmi_track_offset[0] = *hmi_data; // To keep Xcode happy\n\n    for (i = 0; i < hmi_track_cnt; i++) {\n        hmi_track_offset[i] = *hmi_data++;\n        hmi_track_offset[i] += (*hmi_data++ << 8);\n        hmi_track_offset[i] += (*hmi_data++ << 16);\n        hmi_track_offset[i] += (*hmi_data++ << 24);\n\n        if (hmi_size < (hmi_track_offset[i] + 0x5a + 4)) {\n            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_HMI, \"file too short\", 0);\n            goto _hmi_end;\n        }\n\n        hmi_addr = hmi_base + hmi_track_offset[i];\n\n        if (memcmp(hmi_addr, \"HMI-MIDITRACK\", 13)) {\n            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_HMI, NULL, 0);\n            goto _hmi_end;\n        }\n\n        hmi_track_header_length[i] = hmi_addr[0x57];\n        hmi_track_header_length[i] += (hmi_addr[0x58] << 8);\n        hmi_track_header_length[i] += (hmi_addr[0x59] << 16);\n        hmi_track_header_length[i] += (hmi_addr[0x5a] << 24);\n\n        hmi_addr += hmi_track_header_length[i];\n        hmi_track_offset[i] += hmi_track_header_length[i];\n\n        // Get tracks initial delta and set its samples_till_next;\n        hmi_delta[i] = 0;\n        if (*hmi_addr > 0x7f) {\n            do {\n                hmi_delta[i] = (hmi_delta[i] << 7) + (*hmi_addr & 0x7f);\n                hmi_addr++;\n                hmi_track_offset[i]++;\n            } while (*hmi_addr > 0x7f);\n        }\n        hmi_delta[i] = (hmi_delta[i] << 7) + (*hmi_addr & 0x7f);\n        hmi_track_offset[i]++;\n        hmi_addr++;\n\n        // Find smallest delta to work with\n        if (hmi_delta[i] < smallest_delta) {\n            smallest_delta = hmi_delta[i];\n        }\n\n        hmi_track_end[i] = 0;\n        hmi_running_event[i] = 0;\n\n        for (j = 0; j < 128; j++) {\n            hmi_tmp = (128 * i) + j;\n            note[hmi_tmp].length = 0;\n            note[hmi_tmp].channel = 0;\n        }\n    }\n\n    subtract_delta = smallest_delta;\n    sample_count_f= (((float) smallest_delta * samples_per_delta_f) + sample_remainder);\n\n    sample_count = (uint32_t) sample_count_f;\n    sample_remainder = sample_count_f - (float) sample_count;\n\n    hmi_mdi->events[hmi_mdi->event_count - 1].samples_to_next += sample_count;\n    hmi_mdi->extra_info.approx_total_samples += sample_count;\n\n    while (hmi_tracks_ended < hmi_track_cnt) {\n        smallest_delta = 0;\n        for (i = 0; i < hmi_track_cnt; i++) {\n            if (hmi_track_end[i]) continue;\n\n            // first check to see if any active notes need turning off.\n            for (j = 0; j < 128; j++) {\n                hmi_tmp = (128 * i) + j;\n                if (note[hmi_tmp].length) {\n                    note[hmi_tmp].length -= subtract_delta;\n                    if (note[hmi_tmp].length) {\n                        if ((!smallest_delta) || (smallest_delta > note[hmi_tmp].length)) {\n                            smallest_delta = note[hmi_tmp].length;\n                        }\n                    } else {\n                        _WM_midi_setup_noteoff(hmi_mdi, note[hmi_tmp].channel, j, 0);\n                    }\n                }\n            }\n\n            if (hmi_delta[i]) {\n                hmi_delta[i] -= subtract_delta;\n                if (hmi_delta[i]) {\n                    if ((!smallest_delta) || (smallest_delta > hmi_delta[i])) {\n                        smallest_delta = hmi_delta[i];\n                    }\n                    continue;\n                }\n            }\n\n            do {\n                hmi_data = hmi_base + hmi_track_offset[i];\n                hmi_delta[i] = 0;\n                if (hmi_track_offset[i] >= hmi_size) {\n                    _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_HMI, \"file too short\", 0);\n                    goto _hmi_end;\n                }\n                data_siz = hmi_size - hmi_track_offset[i];\n\n                if (hmi_data[0] == 0xfe) {\n                    // HMI only event of some sort.\n                    if (hmi_data[1] == 0x10) {\n                        hmi_tmp = (hmi_data[4] + 5);\n                        hmi_data += hmi_tmp;\n                        hmi_track_offset[i] += hmi_tmp;\n                        hmi_tmp += 4;\n                    } else if (hmi_data[1] == 0x15) {\n                        hmi_data += 4;\n                        hmi_track_offset[i] += 4;\n                        hmi_tmp = 8;\n                    } else {\n                        hmi_tmp = 4;\n                    }\n                    hmi_data += 4;\n                    hmi_track_offset[i] += 4;\n                    if (hmi_tmp > data_siz) {\n                        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_HMI, \"file too short\", 0);\n                        goto _hmi_end;\n                    }\n                    data_siz -= hmi_tmp;\n                } else {\n                    if ((setup_ret = _WM_SetupMidiEvent(hmi_mdi,hmi_data,data_siz,hmi_running_event[i])) == 0) {\n                        goto _hmi_end;\n                    }\n                    if ((hmi_data[0] == 0xff) && (hmi_data[1] == 0x2f) && (hmi_data[2] == 0x00)) {\n                        hmi_track_end[i] = 1;\n                        hmi_tracks_ended++;\n                        for(j = 0; j < 128; j++) {\n                            hmi_tmp = (128 * i) + j;\n                            if (note[hmi_tmp].length) {\n                                _WM_midi_setup_noteoff(hmi_mdi, note[hmi_tmp].channel, j, 0);\n                                note[hmi_tmp].length = 0;\n                            }\n                        }\n                        goto _hmi_next_track;\n                    }\n                    // Running event\n                    // 0xff does not alter running event\n                    if ((*hmi_data == 0xF0) || (*hmi_data == 0xF7)) {\n                        // Sysex resets running event data\n                        hmi_running_event[i] = 0;\n                    } else if (*hmi_data < 0xF0) {\n                        // MIDI events 0x80 to 0xEF set running event\n                        if (*hmi_data >= 0x80) {\n                            hmi_running_event[i] = *hmi_data;\n                        }\n                    }\n                    if ((hmi_running_event[i] & 0xf0) == 0x90) {\n                        // note on has extra data to specify how long the note is.\n                        if (*hmi_data > 127) {\n                            hmi_tmp = hmi_data[1];\n                        } else {\n                            hmi_tmp = *hmi_data;\n                        }\n                        hmi_tmp += (i * 128);\n\n                        note[hmi_tmp].channel = hmi_running_event[i] & 0xf;\n\n                        hmi_data += setup_ret;\n                        hmi_track_offset[i] += setup_ret;\n                        data_siz -= setup_ret;\n\n                        note[hmi_tmp].length = 0;\n                        if (data_siz && *hmi_data > 0x7f) {\n                            do {\n                                if (!data_siz) break;\n                                note[hmi_tmp].length = (note[hmi_tmp].length << 7) | (*hmi_data & 0x7F);\n                                hmi_data++;\n                                data_siz--;\n                                hmi_track_offset[i]++;\n                            } while (*hmi_data > 0x7F);\n                        }\n                        if (!data_siz) {\n                            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_HMI, \"file too short\", 0);\n                            goto _hmi_end;\n                        }\n                        note[hmi_tmp].length = (note[hmi_tmp].length << 7) | (*hmi_data & 0x7F);\n                        hmi_data++;\n                        data_siz--;\n                        hmi_track_offset[i]++;\n\n                        if (note[hmi_tmp].length) {\n                            if ((!smallest_delta) || (smallest_delta > note[hmi_tmp].length)) {\n                                smallest_delta = note[hmi_tmp].length;\n                            }\n                        } else {\n                            _WM_midi_setup_noteoff(hmi_mdi, note[hmi_tmp].channel, j, 0);\n                        }\n\n                    } else {\n                        hmi_data += setup_ret;\n                        hmi_track_offset[i] += setup_ret;\n                        data_siz -= setup_ret;\n                    }\n                }\n\n                // get track delta\n                // hmi_delta[i] = 0; // set at start of loop\n                if (data_siz && *hmi_data > 0x7f) {\n                    do {\n                        if (!data_siz) break;\n                        hmi_delta[i] = (hmi_delta[i] << 7) | (*hmi_data & 0x7F);\n                        hmi_data++;\n                        data_siz--;\n                        hmi_track_offset[i]++;\n                    } while (*hmi_data > 0x7F);\n                }\n                if (!data_siz) {\n                    _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_HMI, \"file too short\", 0);\n                    goto _hmi_end;\n                }\n                hmi_delta[i] = (hmi_delta[i] << 7) | (*hmi_data & 0x7F);\n                hmi_data++;\n                data_siz--;\n                hmi_track_offset[i]++;\n            } while (!hmi_delta[i]);\n            if ((!smallest_delta) || (smallest_delta > hmi_delta[i])) {\n                smallest_delta = hmi_delta[i];\n            }\n\n        _hmi_next_track:\n            hmi_tmp = 0;\n            UNUSED(hmi_tmp);\n        }\n\n        // convert smallest delta to samples till next\n        subtract_delta = smallest_delta;\n        sample_count_f= (((float) smallest_delta * samples_per_delta_f) + sample_remainder);\n\n        sample_count = (uint32_t) sample_count_f;\n        sample_remainder = sample_count_f - (float) sample_count;\n\n        hmi_mdi->events[hmi_mdi->event_count - 1].samples_to_next += sample_count;\n        hmi_mdi->extra_info.approx_total_samples += sample_count;\n    }\n\n    if ((hmi_mdi->reverb = _WM_init_reverb(_WM_SampleRate, _WM_reverb_room_width, _WM_reverb_room_length, _WM_reverb_listen_posx, _WM_reverb_listen_posy)) == NULL) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_MEM, \"to init reverb\", 0);\n        goto _hmi_end;\n    }\n\n    hmi_mdi->extra_info.current_sample = 0;\n    hmi_mdi->current_event = &hmi_mdi->events[0];\n    hmi_mdi->samples_to_mix = 0;\n    hmi_mdi->note = NULL;\n\n    _WM_ResetToStart(hmi_mdi);\n\n_hmi_end:\n    free(hmi_track_offset);\n    free(hmi_track_header_length);\n    free(hmi_track_end);\n    free(hmi_delta);\n    free(note);\n    free(hmi_running_event);\n\n    if (hmi_mdi->reverb) return (hmi_mdi);\n    _WM_freeMDI(hmi_mdi);\n    return 0;\n}\n", "/*\n * hmp.c -- Midi Wavetable Processing library\n *\n * Copyright (C) WildMIDI Developers 2001-2016\n *\n * This file is part of WildMIDI.\n *\n * WildMIDI is free software: you can redistribute and/or modify the player\n * under the terms of the GNU General Public License and you can redistribute\n * and/or modify the library under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation, either version 3 of\n * the licenses, or(at your option) any later version.\n *\n * WildMIDI is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License and\n * the GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License and the\n * GNU Lesser General Public License along with WildMIDI.  If not,  see\n * <http://www.gnu.org/licenses/>.\n */\n\n#include \"config.h\"\n\n#include <stdint.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n\n#include \"common.h\"\n#include \"wm_error.h\"\n#include \"wildmidi_lib.h\"\n#include \"internal_midi.h\"\n#include \"reverb.h\"\n#include \"f_hmp.h\"\n\n/*\n Turns hmp file data into an event stream\n */\nstruct _mdi *\n_WM_ParseNewHmp(uint8_t *hmp_data, uint32_t hmp_size) {\n    uint8_t is_hmp2 = 0;\n    uint32_t zero_cnt = 0;\n    uint32_t i = 0;\n    uint32_t hmp_file_length = 0;\n    uint32_t hmp_chunks = 0;\n    uint32_t hmp_divisions = 0;\n    uint32_t hmp_unknown = 0;\n    uint32_t hmp_bpm = 0;\n    uint32_t hmp_song_time = 0;\n    struct _mdi *hmp_mdi;\n    uint8_t **hmp_chunk;\n    uint32_t *chunk_length;\n    uint32_t *chunk_ofs;\n    uint32_t *chunk_delta;\n    uint8_t *chunk_end;\n    uint32_t chunk_num = 0;\n    uint32_t hmp_track = 0;\n//  uint32_t j = 0;\n    uint32_t smallest_delta = 0;\n    uint32_t subtract_delta = 0;\n//  uint32_t chunks_finished = 0;\n    uint32_t end_of_chunks = 0;\n    uint32_t var_len_shift = 0;\n\n    float tempo_f = 500000.0;\n    float samples_per_delta_f = 0.0;\n\n//  uint8_t hmp_event = 0;\n//  uint8_t hmp_channel = 0;\n\n    uint32_t sample_count = 0;\n    float sample_count_f = 0;\n    float sample_remainder = 0;\n\n    if (memcmp(hmp_data, \"HMIMIDIP\", 8)) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_HMP, NULL, 0);\n        return NULL;\n    }\n    hmp_data += 8;\n    hmp_size -= 8;\n\n    if (!memcmp(hmp_data, \"013195\", 6)) {\n        hmp_data += 6;\n        hmp_size -= 6;\n        is_hmp2 = 1;\n    }\n\n    // should be a bunch of \\0's\n    if (is_hmp2) {\n        zero_cnt = 18;\n    } else {\n        zero_cnt = 24;\n    }\n    for (i = 0; i < zero_cnt; i++) {\n        if (hmp_data[i] != 0) {\n            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_HMP, NULL, 0);\n            return NULL;\n        }\n    }\n    hmp_data += zero_cnt;\n    hmp_size -= zero_cnt;\n\n    hmp_file_length = *hmp_data++;\n    hmp_file_length += (*hmp_data++ << 8);\n    hmp_file_length += (*hmp_data++ << 16);\n    hmp_file_length += (*hmp_data++ << 24);\n    hmp_size -= 4;\n\n    UNUSED(hmp_file_length);\n\n    // Next 12 bytes are normally \\0 so skipping over them\n    hmp_data += 12;\n    hmp_size -= 12;\n\n    hmp_chunks = *hmp_data++;\n    hmp_chunks += (*hmp_data++ << 8);\n    hmp_chunks += (*hmp_data++ << 16);\n    hmp_chunks += (*hmp_data++ << 24);\n    hmp_size -= 4;\n\n    // Still decyphering what this is\n    hmp_unknown = *hmp_data++;\n    hmp_unknown += (*hmp_data++ << 8);\n    hmp_unknown += (*hmp_data++ << 16);\n    hmp_unknown += (*hmp_data++ << 24);\n    hmp_size -= 4;\n\n    UNUSED(hmp_unknown);\n\n    // Defaulting: experimenting has found this to be the ideal value\n    hmp_divisions = 60;\n\n    // Beats per minute\n    hmp_bpm = *hmp_data++;\n    hmp_bpm += (*hmp_data++ << 8);\n    hmp_bpm += (*hmp_data++ << 16);\n    hmp_bpm += (*hmp_data++ << 24);\n    hmp_size -= 4;\n\n    /* Slow but needed for accuracy */\n    if ((_WM_MixerOptions & WM_MO_ROUNDTEMPO)) {\n        tempo_f = (float) (60000000 / hmp_bpm) + 0.5f;\n    } else {\n        tempo_f = (float) (60000000 / hmp_bpm);\n    }\n\n    samples_per_delta_f = _WM_GetSamplesPerTick(hmp_divisions, tempo_f);\n\n    //DEBUG\n    //fprintf(stderr, \"DEBUG: Samples Per Delta Tick: %f\\r\\n\",samples_per_delta_f);\n\n    // FIXME: This value is incorrect\n    hmp_song_time = *hmp_data++;\n    hmp_song_time += (*hmp_data++ << 8);\n    hmp_song_time += (*hmp_data++ << 16);\n    hmp_song_time += (*hmp_data++ << 24);\n    hmp_size -= 4;\n\n    // DEBUG\n    //fprintf(stderr,\"DEBUG: ??DIVISIONS??: %u, BPM: %u, ??SONG TIME??: %u:%.2u\\r\\n\",hmp_divisions, hmp_bpm, (hmp_song_time / 60), (hmp_song_time % 60));\n\n    UNUSED(hmp_song_time);\n\n    if (is_hmp2) {\n        hmp_data += 840;\n        hmp_size -= 840;\n    } else {\n        hmp_data += 712;\n        hmp_size -= 712;\n    }\n\n    hmp_mdi = _WM_initMDI();\n\n    _WM_midi_setup_divisions(hmp_mdi, hmp_divisions);\n    _WM_midi_setup_tempo(hmp_mdi, (uint32_t)tempo_f);\n\n    hmp_chunk = malloc(sizeof(uint8_t *) * hmp_chunks);\n    chunk_length = malloc(sizeof(uint32_t) * hmp_chunks);\n    chunk_delta = malloc(sizeof(uint32_t) * hmp_chunks);\n    chunk_ofs = malloc(sizeof(uint32_t) * hmp_chunks);\n    chunk_end = malloc(sizeof(uint8_t) * hmp_chunks);\n\n    smallest_delta = 0xffffffff;\n    // store chunk info for use, and check chunk lengths\n    for (i = 0; i < hmp_chunks; i++) {\n        hmp_chunk[i] = hmp_data;\n        chunk_ofs[i] = 0;\n\n        chunk_num = *hmp_data++;\n        chunk_num += (*hmp_data++ << 8);\n        chunk_num += (*hmp_data++ << 16);\n        chunk_num += (*hmp_data++ << 24);\n        chunk_ofs[i] += 4;\n\n        UNUSED(chunk_num);\n\n        chunk_length[i] = *hmp_data++;\n        chunk_length[i] += (*hmp_data++ << 8);\n        chunk_length[i] += (*hmp_data++ << 16);\n        chunk_length[i] += (*hmp_data++ << 24);\n        chunk_ofs[i] += 4;\n\n        if (chunk_length[i] > hmp_size) {\n            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_HMP, \"file too short\", 0);\n            goto _hmp_end;\n        }\n        hmp_size -= chunk_length[i];\n\n        hmp_track = *hmp_data++;\n        hmp_track += (*hmp_data++ << 8);\n        hmp_track += (*hmp_data++ << 16);\n        hmp_track += (*hmp_data++ << 24);\n        chunk_ofs[i] += 4;\n\n        UNUSED(hmp_track);\n\n        // Start of Midi Data\n        chunk_delta[i] = 0;\n        var_len_shift = 0;\n        if (*hmp_data < 0x80) {\n            do {\n                chunk_delta[i] = chunk_delta[i] | ((*hmp_data++ & 0x7F) << var_len_shift);\n                var_len_shift += 7;\n                chunk_ofs[i]++;\n            } while (*hmp_data < 0x80);\n        }\n        chunk_delta[i] = chunk_delta[i] | ((*hmp_data++ & 0x7F) << var_len_shift);\n        chunk_ofs[i]++;\n\n        if (chunk_delta[i] < smallest_delta) {\n            smallest_delta = chunk_delta[i];\n        }\n\n        // goto start of next chunk\n        hmp_data = hmp_chunk[i] + chunk_length[i];\n        chunk_length[i] -= chunk_ofs[i];\n        hmp_chunk[i] += chunk_ofs[i]++;\n        chunk_end[i] = 0;\n    }\n\n    subtract_delta = smallest_delta;\n    sample_count_f = (((float) smallest_delta * samples_per_delta_f) + sample_remainder);\n\n    sample_count = (uint32_t) sample_count_f;\n    sample_remainder = sample_count_f - (float) sample_count;\n\n    hmp_mdi->events[hmp_mdi->event_count - 1].samples_to_next += sample_count;\n    hmp_mdi->extra_info.approx_total_samples += sample_count;\n\n    while (end_of_chunks < hmp_chunks) {\n        smallest_delta = 0;\n\n        // DEBUG\n        // fprintf(stderr,\"DEBUG: Delta Ticks: %u\\r\\n\",subtract_delta);\n\n        for (i = 0; i < hmp_chunks; i++) {\n            if (chunk_end[i])\n                continue;\n\n            if (chunk_delta[i]) {\n                chunk_delta[i] -= subtract_delta;\n                if (chunk_delta[i]) {\n                    if ((!smallest_delta)\n                        || (smallest_delta > chunk_delta[i])) {\n                        smallest_delta = chunk_delta[i];\n                    }\n                    continue;\n                }\n            }\n            do {\n                if (((hmp_chunk[i][0] & 0xf0) == 0xb0 ) && ((hmp_chunk[i][1] == 110) || (hmp_chunk[i][1] == 111)) && (hmp_chunk[i][2] > 0x7f)) {\n                    // Reserved for loop markers\n                    // TODO: still deciding what to do about these\n                    hmp_chunk[i] += 3;\n                    chunk_length[i] -= 3;\n                } else {\n                    uint32_t setup_ret = 0;\n\n                    if ((setup_ret = _WM_SetupMidiEvent(hmp_mdi, hmp_chunk[i], chunk_length[i], 0)) == 0) {\n                        goto _hmp_end;\n                    }\n\n                    if ((hmp_chunk[i][0] == 0xff) && (hmp_chunk[i][1] == 0x2f) && (hmp_chunk[i][2] == 0x00)) {\n                        /* End of Chunk */\n                        end_of_chunks++;\n                        chunk_end[i] = 1;\n                        chunk_length[i] -= 3;\n                        hmp_chunk[i] += 3;\n                        goto NEXT_CHUNK;\n                    } else if ((hmp_chunk[i][0] == 0xff) && (hmp_chunk[i][1] == 0x51) && (hmp_chunk[i][2] == 0x03)) {\n                        /* Tempo */\n                        tempo_f = (float)((hmp_chunk[i][3] << 16) + (hmp_chunk[i][4] << 8)+ hmp_chunk[i][5]);\n                        if (tempo_f == 0.0)\n                            tempo_f = 500000.0;\n\n                        // DEBUG\n                        fprintf(stderr,\"DEBUG: Tempo change %f\\r\\n\", tempo_f);\n                    }\n                    hmp_chunk[i] += setup_ret;\n                    chunk_length[i] -= setup_ret;\n                }\n                var_len_shift = 0;\n                chunk_delta[i] = 0;\n                if (chunk_length[i] && *hmp_chunk[i] < 0x80) {\n                    do {\n                        if (! chunk_length[i]) break;\n                        chunk_delta[i] = chunk_delta[i] + ((*hmp_chunk[i] & 0x7F) << var_len_shift);\n                        var_len_shift += 7;\n                        hmp_chunk[i]++;\n                        chunk_length[i]--;\n                    } while (*hmp_chunk[i] < 0x80);\n                }\n                if (! chunk_length[i]) {\n                    _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_HMP, \"file too short\", 0);\n                    goto _hmp_end;\n                }\n                chunk_delta[i] = chunk_delta[i] + ((*hmp_chunk[i] & 0x7F) << var_len_shift);\n                hmp_chunk[i]++;\n                chunk_length[i]--;\n            } while (!chunk_delta[i]);\n\n            if ((!smallest_delta) || (smallest_delta > chunk_delta[i])) {\n                smallest_delta = chunk_delta[i];\n            }\n        NEXT_CHUNK: continue;\n        }\n\n        subtract_delta = smallest_delta;\n        sample_count_f= (((float) smallest_delta * samples_per_delta_f) + sample_remainder);\n\n        sample_count = (uint32_t) sample_count_f;\n        sample_remainder = sample_count_f - (float) sample_count;\n\n        hmp_mdi->events[hmp_mdi->event_count - 1].samples_to_next += sample_count;\n        hmp_mdi->extra_info.approx_total_samples += sample_count;\n\n        // DEBUG\n        // fprintf(stderr,\"DEBUG: Sample Count %u\\r\\n\",sample_count);\n    }\n\n    if ((hmp_mdi->reverb = _WM_init_reverb(_WM_SampleRate, _WM_reverb_room_width, _WM_reverb_room_length, _WM_reverb_listen_posx, _WM_reverb_listen_posy)) == NULL) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_MEM, \"to init reverb\", 0);\n        goto _hmp_end;\n    }\n\n    hmp_mdi->extra_info.current_sample = 0;\n    hmp_mdi->current_event = &hmp_mdi->events[0];\n    hmp_mdi->samples_to_mix = 0;\n    hmp_mdi->note = NULL;\n\n    _WM_ResetToStart(hmp_mdi);\n\n_hmp_end:\n    free(hmp_chunk);\n    free(chunk_length);\n    free(chunk_delta);\n    free(chunk_ofs);\n    free(chunk_end);\n    if (hmp_mdi->reverb) return (hmp_mdi);\n    _WM_freeMDI(hmp_mdi);\n    return NULL;\n}\n", "/*\n * midi.c -- Midi Wavetable Processing library\n *\n * Copyright (C) WildMIDI Developers 2001-2016\n *\n * This file is part of WildMIDI.\n *\n * WildMIDI is free software: you can redistribute and/or modify the player\n * under the terms of the GNU General Public License and you can redistribute\n * and/or modify the library under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation, either version 3 of\n * the licenses, or(at your option) any later version.\n *\n * WildMIDI is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License and\n * the GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License and the\n * GNU Lesser General Public License along with WildMIDI.  If not,  see\n * <http://www.gnu.org/licenses/>.\n */\n\n#include \"config.h\"\n\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"common.h\"\n#include \"wm_error.h\"\n#include \"f_midi.h\"\n#include \"wildmidi_lib.h\"\n#include \"internal_midi.h\"\n#include \"reverb.h\"\n#include \"sample.h\"\n\n\nstruct _mdi *\n_WM_ParseNewMidi(uint8_t *midi_data, uint32_t midi_size) {\n    struct _mdi *mdi;\n\n    uint32_t tmp_val;\n    uint32_t midi_type;\n    uint8_t **tracks;\n    uint32_t *track_size;\n    uint32_t end_of_tracks = 0;\n    uint32_t no_tracks;\n    uint32_t i;\n    uint32_t divisions = 96;\n    uint32_t tempo = 500000;\n    float samples_per_delta_f = 0.0;\n\n    uint32_t sample_count = 0;\n    float sample_count_f = 0.0;\n    float sample_remainder = 0.0;\n    uint8_t *sysex_store = NULL;\n\n    uint32_t *track_delta;\n    uint8_t *track_end;\n    uint32_t smallest_delta = 0;\n    uint32_t subtract_delta = 0;\n    uint8_t *running_event;\n    uint32_t setup_ret = 0;\n\n    if (midi_size < 14) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(too short)\", 0);\n        return (NULL);\n    }\n\n    if (!memcmp(midi_data, \"RIFF\", 4)) {\n        if (midi_size < 34) {\n            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(too short)\", 0);\n            return (NULL);\n        }\n        midi_data += 20;\n        midi_size -= 20;\n    }\n\n    if (memcmp(midi_data, \"MThd\", 4)) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_MIDI, NULL, 0);\n        return (NULL);\n    }\n    midi_data += 4;\n    midi_size -= 4;\n\n    /*\n     * Get Midi Header Size - must always be 6\n     */\n    tmp_val = *midi_data++ << 24;\n    tmp_val |= *midi_data++ << 16;\n    tmp_val |= *midi_data++ << 8;\n    tmp_val |= *midi_data++;\n    midi_size -= 4;\n    if (tmp_val != 6) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, NULL, 0);\n        return (NULL);\n    }\n\n    /*\n     * Get Midi Format - we only support 0, 1 & 2\n     */\n    tmp_val = *midi_data++ << 8;\n    tmp_val |= *midi_data++;\n    midi_size -= 2;\n    if (tmp_val > 2) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID, NULL, 0);\n        return (NULL);\n    }\n    midi_type = tmp_val;\n\n    /*\n     * Get No. of Tracks\n     */\n    tmp_val = *midi_data++ << 8;\n    tmp_val |= *midi_data++;\n    midi_size -= 2;\n    if (tmp_val < 1) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(no tracks)\", 0);\n        return (NULL);\n    }\n    no_tracks = tmp_val;\n\n    /*\n     * Check that type 0 midi file has only 1 track\n     */\n    if ((midi_type == 0) && (no_tracks > 1)) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID, \"(expected 1 track for type 0 midi file, found more)\", 0);\n        return (NULL);\n    }\n\n    /*\n     * Get Divisions\n     */\n    divisions = *midi_data++ << 8;\n    divisions |= *midi_data++;\n    midi_size -= 2;\n    if (divisions & 0x00008000) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID, NULL, 0);\n        return (NULL);\n    }\n\n    samples_per_delta_f = _WM_GetSamplesPerTick(divisions, tempo);\n\n    mdi = _WM_initMDI();\n    _WM_midi_setup_divisions(mdi,divisions);\n\n    tracks = malloc(sizeof(uint8_t *) * no_tracks);\n    track_size = malloc(sizeof(uint32_t) * no_tracks);\n    track_delta = malloc(sizeof(uint32_t) * no_tracks);\n    track_end = malloc(sizeof(uint8_t) * no_tracks);\n    running_event = malloc(sizeof(uint8_t) * no_tracks);\n\n    smallest_delta = 0xffffffff;\n    for (i = 0; i < no_tracks; i++) {\n        if (midi_size < 8) {\n            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(too short)\", 0);\n            goto _end;\n        }\n        if (memcmp(midi_data, \"MTrk\", 4) != 0) {\n            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(missing track header)\", 0);\n            goto _end;\n        }\n        midi_data += 4;\n        midi_size -= 4;\n\n        /* track size */\n        tmp_val = *midi_data++ << 24;\n        tmp_val |= *midi_data++ << 16;\n        tmp_val |= *midi_data++ << 8;\n        tmp_val |= *midi_data++;\n        midi_size -= 4;\n        if (midi_size < tmp_val) {\n            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(too short)\", 0);\n            goto _end;\n        }\n        if (tmp_val < 3) {\n            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(bad track size)\", 0);\n            goto _end;\n        }\n        if ((midi_data[tmp_val - 3] != 0xFF)\n                || (midi_data[tmp_val - 2] != 0x2F)\n                || (midi_data[tmp_val - 1] != 0x00)) {\n            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(missing EOT)\", 0);\n            goto _end;\n        }\n        tracks[i] = midi_data;\n        track_size[i] = tmp_val;\n        midi_data += tmp_val;\n        midi_size -= tmp_val;\n        track_end[i] = 0;\n        running_event[i] = 0;\n        track_delta[i] = 0;\n\n        while (*tracks[i] > 0x7F) {\n            track_delta[i] = (track_delta[i] << 7) + (*tracks[i] & 0x7F);\n            tracks[i]++;\n            track_size[i]--;\n        }\n        track_delta[i] = (track_delta[i] << 7) + (*tracks[i] & 0x7F);\n        tracks[i]++;\n        track_size[i]--;\n\n        if (midi_type == 1 ) {\n            if (track_delta[i] < smallest_delta) {\n                smallest_delta = track_delta[i];\n            }\n        } else {\n            /*\n             * Type 0 & 2 midi only needs delta from 1st track\n             * for initial sample calculations.\n             */\n            if (i == 0) smallest_delta = track_delta[i];\n        }\n    }\n\n    subtract_delta = smallest_delta;\n    sample_count_f = (((float) smallest_delta * samples_per_delta_f) + sample_remainder);\n    sample_count = (uint32_t) sample_count_f;\n    sample_remainder = sample_count_f - (float) sample_count;\n\n    mdi->events[mdi->event_count - 1].samples_to_next += sample_count;\n    mdi->extra_info.approx_total_samples += sample_count;\n\n    /*\n     * Handle type 0 & 2 the same, but type 1 differently\n     */\n    if (midi_type == 1) {\n        /* Type 1 */\n        while (end_of_tracks != no_tracks) {\n            smallest_delta = 0;\n            for (i = 0; i < no_tracks; i++) {\n                if (track_end[i])\n                    continue;\n                if (track_delta[i]) {\n                    track_delta[i] -= subtract_delta;\n                    if (track_delta[i]) {\n                        if ((!smallest_delta)\n                             || (smallest_delta > track_delta[i])) {\n                            smallest_delta = track_delta[i];\n                        }\n                        continue;\n                    }\n                }\n                do {\n                    setup_ret = _WM_SetupMidiEvent(mdi, tracks[i], track_size[i], running_event[i]);\n                    if (setup_ret == 0) {\n                        goto _end;\n                    }\n                    if (tracks[i][0] > 0x7f) {\n                        if (tracks[i][0] < 0xf0) {\n                            /* Events 0x80 - 0xef set running event */\n                            running_event[i] = tracks[i][0];\n                        } else if ((tracks[i][0] == 0xf0) || (tracks[i][0] == 0xf7)) {\n                            /* Sysex resets running event */\n                            running_event[i] = 0;\n                        } else if ((tracks[i][0] == 0xff) && (tracks[i][1] == 0x2f) && (tracks[i][2] == 0x00)) {\n                            /* End of Track */\n                            end_of_tracks++;\n                            track_end[i] = 1;\n                            tracks[i] += 3;\n                            track_size[i] -= 3;\n                            goto NEXT_TRACK;\n                        } else if ((tracks[i][0] == 0xff) && (tracks[i][1] == 0x51) && (tracks[i][2] == 0x03)) {\n                            /* Tempo */\n                            tempo = (tracks[i][3] << 16) + (tracks[i][4] << 8)+ tracks[i][5];\n                            if (!tempo)\n                                tempo = 500000;\n\n                            samples_per_delta_f = _WM_GetSamplesPerTick(divisions, tempo);\n                        }\n                    }\n                    tracks[i] += setup_ret;\n                    track_size[i] -= setup_ret;\n\n                    if (*tracks[i] > 0x7f) {\n                        do {\n                            if (!track_size[i]) break;\n                            track_delta[i] = (track_delta[i] << 7) + (*tracks[i] & 0x7F);\n                            tracks[i]++;\n                            track_size[i]--;\n                        } while (*tracks[i] > 0x7f);\n                    }\n                    if (!track_size[i]) {\n                        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(too short)\", 0);\n                        goto _end;\n                    }\n                    track_delta[i] = (track_delta[i] << 7) + (*tracks[i] & 0x7F);\n                    tracks[i]++;\n                    track_size[i]--;\n                } while (!track_delta[i]);\n                if ((!smallest_delta) || (smallest_delta > track_delta[i])) {\n                    smallest_delta = track_delta[i];\n                }\n            NEXT_TRACK: continue;\n            }\n\n            subtract_delta = smallest_delta;\n            sample_count_f = (((float) smallest_delta * samples_per_delta_f)\n                              + sample_remainder);\n            sample_count = (uint32_t) sample_count_f;\n            sample_remainder = sample_count_f - (float) sample_count;\n\n            mdi->events[mdi->event_count - 1].samples_to_next += sample_count;\n            mdi->extra_info.approx_total_samples += sample_count;\n        }\n    } else {\n        /* Type 0 & 2 */\n        if (midi_type == 2) {\n            mdi->is_type2 = 1;\n        }\n        sample_remainder = 0.0;\n        for (i = 0; i < no_tracks; i++) {\n            running_event[i] = 0;\n            do {\n                setup_ret = _WM_SetupMidiEvent(mdi, tracks[i], track_size[i], running_event[i]);\n                if (setup_ret == 0) {\n                    goto _end;\n                }\n                if (tracks[i][0] > 0x7f) {\n                    if (tracks[i][0] < 0xf0) {\n                        /* Events 0x80 - 0xef set running event */\n                        running_event[i] = tracks[i][0];\n                    } else if ((tracks[i][0] == 0xf0) || (tracks[i][0] == 0xf7)) {\n                        /* Sysex resets running event */\n                        running_event[i] = 0;\n                    } else if ((tracks[i][0] == 0xff) && (tracks[i][1] == 0x2f) && (tracks[i][2] == 0x00)) {\n                        /* End of Track */\n                        track_end[i] = 1;\n                        goto NEXT_TRACK2;\n                    } else if ((tracks[i][0] == 0xff) && (tracks[i][1] == 0x51) && (tracks[i][2] == 0x03)) {\n                        /* Tempo */\n                        tempo = (tracks[i][3] << 16) + (tracks[i][4] << 8)+ tracks[i][5];\n                        if (!tempo)\n                            tempo = 500000;\n\n                        samples_per_delta_f = _WM_GetSamplesPerTick(divisions, tempo);\n                    }\n                }\n                tracks[i] += setup_ret;\n                track_size[i] -= setup_ret;\n\n                track_delta[i] = 0;\n                if (*tracks[i] > 0x7f) {\n                    do {\n                        if (!track_size[i]) break;\n                        track_delta[i] = (track_delta[i] << 7) + (*tracks[i] & 0x7F);\n                        tracks[i]++;\n                        track_size[i]--;\n                    } while (*tracks[i] > 0x7f);\n                }\n                if (!track_size[i]) {\n                    _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(too short)\", 0);\n                    goto _end;\n                }\n                track_delta[i] = (track_delta[i] << 7) + (*tracks[i] & 0x7F);\n                tracks[i]++;\n                track_size[i]--;\n\n                sample_count_f = (((float) track_delta[i] * samples_per_delta_f)\n                                  + sample_remainder);\n                sample_count = (uint32_t) sample_count_f;\n                sample_remainder = sample_count_f - (float) sample_count;\n                mdi->events[mdi->event_count - 1].samples_to_next += sample_count;\n                mdi->extra_info.approx_total_samples += sample_count;\n            NEXT_TRACK2:\n                smallest_delta = track_delta[i]; /* Added just to keep Xcode happy */\n                UNUSED(smallest_delta); /* Added to just keep clang happy */\n            } while (track_end[i] == 0);\n        }\n    }\n\n    if ((mdi->reverb = _WM_init_reverb(_WM_SampleRate, _WM_reverb_room_width,\n            _WM_reverb_room_length, _WM_reverb_listen_posx, _WM_reverb_listen_posy))\n          == NULL) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_MEM, \"to init reverb\", 0);\n        goto _end;\n    }\n\n    mdi->extra_info.current_sample = 0;\n    mdi->current_event = &mdi->events[0];\n    mdi->samples_to_mix = 0;\n    mdi->note = NULL;\n\n    _WM_ResetToStart(mdi);\n\n_end:   free(sysex_store);\n    free(track_end);\n    free(track_delta);\n    free(running_event);\n    free(tracks);\n    free(track_size);\n    if (mdi->reverb) return (mdi);\n    _WM_freeMDI(mdi);\n    return (NULL);\n}\n\n/*\n Convert WildMIDI's MDI events into a type 0 MIDI file.\n\n returns\n 0 = successful\n -1 = failed\n\n **out points to place to store stuff\n *outsize points to where to store byte counts\n\n NOTE: This will only write out events that we do support.\n\n *** CAUTION ***\n This will output type 0 midi file reguardless of the original file type.\n Type 2 midi files will have each original track play on the same track one\n after the other in the type 0 file.\n */\nint\n_WM_Event2Midi(struct _mdi *mdi, uint8_t **out, uint32_t *outsize) {\n    uint32_t out_ofs = 0;\n    uint8_t running_event = 0;\n    uint32_t divisions = 96;\n    uint32_t tempo = 500000;\n    float samples_per_tick = 0.0;\n    uint32_t value = 0;\n    float value_f = 0.0;\n    struct _event *event = mdi->events;\n    uint32_t track_size = 0;\n    uint32_t track_start = 0;\n    uint32_t track_count = 0;\n\n    if (!mdi->event_count) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CONVERT, \"(No events to convert)\", 0);\n        return -1;\n    }\n\n    samples_per_tick = _WM_GetSamplesPerTick(divisions, tempo);\n\n    /*\n     Note: This isn't accurate but will allow enough space for\n            events plus delta values.\n     */\n    (*out) = malloc (sizeof(uint8_t) * (mdi->event_count * 12));\n\n    /* Midi Header */\n    (*out)[0] = 'M';\n    (*out)[1] = 'T';\n    (*out)[2] = 'h';\n    (*out)[3] = 'd';\n    (*out)[4] = 0x00;\n    (*out)[5] = 0x00;\n    (*out)[6] = 0x00;\n    (*out)[7] = 0x06;\n    if ((!(_WM_MixerOptions & WM_MO_SAVEASTYPE0)) && (mdi->is_type2)) {\n        /* Type 2 */\n        (*out)[8] = 0x00;\n        (*out)[9] = 0x02;\n    } else {\n        /* Type 0 */\n        (*out)[8] = 0x00;\n        (*out)[9] = 0x00;\n    }\n    /* No. of tracks stored in 10-11 *** See below */\n    /* Division stored in 12-13 *** See below */\n    /* Track Header */\n    (*out)[14] = 'M';\n    (*out)[15] = 'T';\n    (*out)[16] = 'r';\n    (*out)[17] = 'k';\n    /* Track size stored in 18-21 *** see below */\n    out_ofs = 22;\n    track_start = out_ofs;\n    track_count++;\n\n    do {\n        /* TODO Is there a better way? */\n        if (event->do_event == _WM_do_midi_divisions) {\n            // DEBUG\n            // fprintf(stderr,\"Division: %u\\r\\n\",event->event_data.data);\n            divisions = event->event_data.data.value;\n            (*out)[12] = (divisions >> 8) & 0xff;\n            (*out)[13] = divisions & 0xff;\n            samples_per_tick = _WM_GetSamplesPerTick(divisions, tempo);\n        } else if (event->do_event == _WM_do_note_off) {\n            // DEBUG\n            // fprintf(stderr,\"Note Off: %u %.4x\\r\\n\",event->event_data.channel, event->event_data.data);\n            if (running_event != (0x80 | event->event_data.channel)) {\n                (*out)[out_ofs++] = 0x80 | event->event_data.channel;\n                running_event = (*out)[out_ofs - 1];\n            }\n            (*out)[out_ofs++] = (event->event_data.data.value >> 8) & 0xff;\n            (*out)[out_ofs++] = event->event_data.data.value & 0xff;\n        } else if (event->do_event == _WM_do_note_on) {\n            // DEBUG\n            // fprintf(stderr,\"Note On: %u %.4x\\r\\n\",event->event_data.channel, event->event_data.data);\n            if (running_event != (0x90 | event->event_data.channel)) {\n                (*out)[out_ofs++] = 0x90 | event->event_data.channel;\n                running_event = (*out)[out_ofs - 1];\n            }\n            (*out)[out_ofs++] = (event->event_data.data.value >> 8) & 0xff;\n            (*out)[out_ofs++] = event->event_data.data.value & 0xff;\n        } else if (event->do_event == _WM_do_aftertouch) {\n            // DEBUG\n            // fprintf(stderr,\"Aftertouch: %u %.4x\\r\\n\",event->event_data.channel, event->event_data.data);\n            if (running_event != (0xa0 | event->event_data.channel)) {\n                (*out)[out_ofs++] = 0xa0 | event->event_data.channel;\n                running_event = (*out)[out_ofs - 1];\n            }\n            (*out)[out_ofs++] = (event->event_data.data.value >> 8) & 0xff;\n            (*out)[out_ofs++] = event->event_data.data.value & 0xff;\n        } else if (event->do_event == _WM_do_control_bank_select) {\n            // DEBUG\n            // fprintf(stderr,\"Control Bank Select: %u %.4x\\r\\n\",event->event_data.channel, event->event_data.data);\n            if (running_event != (0xb0 | event->event_data.channel)) {\n                (*out)[out_ofs++] = 0xb0 | event->event_data.channel;\n                running_event = (*out)[out_ofs - 1];\n            }\n            (*out)[out_ofs++] = 0;\n            (*out)[out_ofs++] = event->event_data.data.value & 0xff;\n        } else if (event->do_event == _WM_do_control_data_entry_course) {\n            // DEBUG\n            // fprintf(stderr,\"Control Data Entry Course: %u %.4x\\r\\n\",event->event_data.channel, event->event_data.data);\n            if (running_event != (0xb0 | event->event_data.channel)) {\n                (*out)[out_ofs++] = 0xb0 | event->event_data.channel;\n                running_event = (*out)[out_ofs - 1];\n            }\n            (*out)[out_ofs++] = 6;\n            (*out)[out_ofs++] = event->event_data.data.value & 0xff;\n        } else if (event->do_event == _WM_do_control_channel_volume) {\n            // DEBUG\n            // fprintf(stderr,\"Control Channel Volume: %u %.4x\\r\\n\",event->event_data.channel, event->event_data.data);\n            if (running_event != (0xb0 | event->event_data.channel)) {\n                (*out)[out_ofs++] = 0xb0 | event->event_data.channel;\n                running_event = (*out)[out_ofs - 1];\n            }\n            (*out)[out_ofs++] = 7;\n            (*out)[out_ofs++] = event->event_data.data.value & 0xff;\n        } else if (event->do_event == _WM_do_control_channel_balance) {\n            // DEBUG\n            // fprintf(stderr,\"Control Channel Balance: %u %.4x\\r\\n\",event->event_data.channel, event->event_data.data);\n            if (running_event != (0xb0 | event->event_data.channel)) {\n                (*out)[out_ofs++] = 0xb0 | event->event_data.channel;\n                running_event = (*out)[out_ofs - 1];\n            }\n            (*out)[out_ofs++] = 8;\n            (*out)[out_ofs++] = event->event_data.data.value & 0xff;\n        } else if (event->do_event == _WM_do_control_channel_pan) {\n            // DEBUG\n            // fprintf(stderr,\"Control Channel Pan: %u %.4x\\r\\n\",event->event_data.channel, event->event_data.data);\n            if (running_event != (0xb0 | event->event_data.channel)) {\n                (*out)[out_ofs++] = 0xb0 | event->event_data.channel;\n                running_event = (*out)[out_ofs - 1];\n            }\n            (*out)[out_ofs++] = 10;\n            (*out)[out_ofs++] = event->event_data.data.value & 0xff;\n        } else if (event->do_event == _WM_do_control_channel_expression) {\n            // DEBUG\n            // fprintf(stderr,\"Control Channel Expression: %u %.4x\\r\\n\",event->event_data.channel, event->event_data.data);\n            if (running_event != (0xb0 | event->event_data.channel)) {\n                (*out)[out_ofs++] = 0xb0 | event->event_data.channel;\n                running_event = (*out)[out_ofs - 1];\n            }\n            (*out)[out_ofs++] = 11;\n            (*out)[out_ofs++] = event->event_data.data.value & 0xff;\n        } else if (event->do_event == _WM_do_control_data_entry_fine) {\n            // DEBUG\n            // fprintf(stderr,\"Control Data Entry Fine: %u %.4x\\r\\n\",event->event_data.channel, event->event_data.data);\n            if (running_event != (0xb0 | event->event_data.channel)) {\n                (*out)[out_ofs++] = 0xb0 | event->event_data.channel;\n                running_event = (*out)[out_ofs - 1];\n            }\n            (*out)[out_ofs++] = 38;\n            (*out)[out_ofs++] = event->event_data.data.value & 0xff;\n        } else if (event->do_event == _WM_do_control_channel_hold) {\n            // DEBUG\n            // fprintf(stderr,\"Control Channel Hold: %u %.4x\\r\\n\",event->event_data.channel, event->event_data.data);\n            if (running_event != (0xb0 | event->event_data.channel)) {\n                (*out)[out_ofs++] = 0xb0 | event->event_data.channel;\n                running_event = (*out)[out_ofs - 1];\n            }\n            (*out)[out_ofs++] = 64;\n            (*out)[out_ofs++] = event->event_data.data.value & 0xff;\n        } else if (event->do_event == _WM_do_control_data_increment) {\n            // DEBUG\n            // fprintf(stderr,\"Control Data Increment: %u %.4x\\r\\n\",event->event_data.channel, event->event_data.data);\n            if (running_event != (0xb0 | event->event_data.channel)) {\n                (*out)[out_ofs++] = 0xb0 | event->event_data.channel;\n                running_event = (*out)[out_ofs - 1];\n            }\n            (*out)[out_ofs++] = 96;\n            (*out)[out_ofs++] = event->event_data.data.value & 0xff;\n        } else if (event->do_event == _WM_do_control_data_decrement) {\n            // DEBUG\n            //fprintf(stderr,\"Control Data Decrement: %u %.4x\\r\\n\",event->event_data.channel, event->event_data.data);\n            if (running_event != (0xb0 | event->event_data.channel)) {\n                (*out)[out_ofs++] = 0xb0 | event->event_data.channel;\n                running_event = (*out)[out_ofs - 1];\n            }\n            (*out)[out_ofs++] = 97;\n            (*out)[out_ofs++] = event->event_data.data.value & 0xff;\n        } else if (event->do_event == _WM_do_control_non_registered_param_fine) {\n            // DEBUG\n            // fprintf(stderr,\"Control Non Registered Param: %u %.4x\\r\\n\",event->event_data.channel, event->event_data.data);\n            if (running_event != (0xb0 | event->event_data.channel)) {\n                (*out)[out_ofs++] = 0xb0 | event->event_data.channel;\n                running_event = (*out)[out_ofs - 1];\n            }\n            (*out)[out_ofs++] = 98;\n            (*out)[out_ofs++] = event->event_data.data.value & 0x7f;\n        } else if (event->do_event == _WM_do_control_non_registered_param_course) {\n            // DEBUG\n            // fprintf(stderr,\"Control Non Registered Param: %u %.4x\\r\\n\",event->event_data.channel, event->event_data.data);\n            if (running_event != (0xb0 | event->event_data.channel)) {\n                (*out)[out_ofs++] = 0xb0 | event->event_data.channel;\n                running_event = (*out)[out_ofs - 1];\n            }\n            (*out)[out_ofs++] = 99;\n            (*out)[out_ofs++] = (event->event_data.data.value >> 7) & 0x7f;\n        } else if (event->do_event == _WM_do_control_registered_param_fine) {\n            // DEBUG\n            // fprintf(stderr,\"Control Registered Param Fine: %u %.4x\\r\\n\",event->event_data.channel, event->event_data.data);\n            if (running_event != (0xb0 | event->event_data.channel)) {\n                (*out)[out_ofs++] = 0xb0 | event->event_data.channel;\n                running_event = (*out)[out_ofs - 1];\n            }\n            (*out)[out_ofs++] = 100;\n            (*out)[out_ofs++] = event->event_data.data.value & 0x7f;\n        } else if (event->do_event == _WM_do_control_registered_param_course) {\n            // DEBUG\n            // fprintf(stderr,\"Control Registered Param Course: %u %.4x\\r\\n\",event->event_data.channel, event->event_data.data);\n            if (running_event != (0xb0 | event->event_data.channel)) {\n                (*out)[out_ofs++] = 0xb0 | event->event_data.channel;\n                running_event = (*out)[out_ofs - 1];\n            }\n            (*out)[out_ofs++] = 101;\n            (*out)[out_ofs++] = (event->event_data.data.value >> 7) & 0x7f;\n        } else if (event->do_event == _WM_do_control_channel_sound_off) {\n            // DEBUG\n            // fprintf(stderr,\"Control Channel Sound Off: %u %.4x\\r\\n\",event->event_data.channel, event->event_data.data);\n            if (running_event != (0xb0 | event->event_data.channel)) {\n                (*out)[out_ofs++] = 0xb0 | event->event_data.channel;\n                running_event = (*out)[out_ofs - 1];\n            }\n            (*out)[out_ofs++] = 120;\n            (*out)[out_ofs++] = event->event_data.data.value & 0xff;\n        } else if (event->do_event == _WM_do_control_channel_controllers_off) {\n            // DEBUG\n            // fprintf(stderr,\"Control Channel Controllers Off: %u %.4x\\r\\n\",event->event_data.channel, event->event_data.data);\n            if (running_event != (0xb0 | event->event_data.channel)) {\n                (*out)[out_ofs++] = 0xb0 | event->event_data.channel;\n                running_event = (*out)[out_ofs - 1];\n            }\n            (*out)[out_ofs++] = 121;\n            (*out)[out_ofs++] = event->event_data.data.value & 0xff;\n        } else if (event->do_event == _WM_do_control_channel_notes_off) {\n            // DEBUG\n            // fprintf(stderr,\"Control Channel Notes Off: %u %.4x\\r\\n\",event->event_data.channel, event->event_data.data);\n            if (running_event != (0xb0 | event->event_data.channel)) {\n                (*out)[out_ofs++] = 0xb0 | event->event_data.channel;\n                running_event = (*out)[out_ofs - 1];\n            }\n            (*out)[out_ofs++] = 123;\n            (*out)[out_ofs++] = event->event_data.data.value & 0xff;\n        } else if (event->do_event == _WM_do_control_dummy) {\n            // DEBUG\n            // fprintf(stderr,\"Control Dummy Event: %u %.4x\\r\\n\",event->event_data.channel, event->event_data.data);\n            if (running_event != (0xb0 | event->event_data.channel)) {\n                (*out)[out_ofs++] = 0xb0 | event->event_data.channel;\n                running_event = (*out)[out_ofs - 1];\n            }\n            (*out)[out_ofs++] = (event->event_data.data.value >> 8) & 0xff;\n            (*out)[out_ofs++] = event->event_data.data.value & 0xff;\n        } else if (event->do_event == _WM_do_patch) {\n            // DEBUG\n            // fprintf(stderr,\"Patch: %u %.4x\\r\\n\",event->event_data.channel, event->event_data.data);\n            if (running_event != (0xc0 | event->event_data.channel)) {\n                (*out)[out_ofs++] = 0xc0 | event->event_data.channel;\n                running_event = (*out)[out_ofs - 1];\n            }\n            (*out)[out_ofs++] = event->event_data.data.value & 0xff;\n        } else if (event->do_event == _WM_do_channel_pressure) {\n            // DEBUG\n            // fprintf(stderr,\"Channel Pressure: %u %.4x\\r\\n\",event->event_data.channel, event->event_data.data);\n            if (running_event != (0xd0 | event->event_data.channel)) {\n                (*out)[out_ofs++] = 0xd0 | event->event_data.channel;\n                running_event = (*out)[out_ofs - 1];\n            }\n            (*out)[out_ofs++] = event->event_data.data.value & 0xff;\n        } else if (event->do_event == _WM_do_pitch) {\n            // DEBUG\n            // fprintf(stderr,\"Pitch: %u %.4x\\r\\n\",event->event_data.channel, event->event_data.data);\n            if (running_event != (0xe0 | event->event_data.channel)) {\n                (*out)[out_ofs++] = 0xe0 | event->event_data.channel;\n                running_event = (*out)[out_ofs - 1];\n            }\n            (*out)[out_ofs++] = event->event_data.data.value & 0x7f;\n            (*out)[out_ofs++] = (event->event_data.data.value >> 7) & 0x7f;\n        } else if (event->do_event == _WM_do_sysex_roland_drum_track) {\n            // DEBUG\n            // fprintf(stderr,\"Sysex Roland Drum Track: %u %.4x\\r\\n\",event->event_data.channel, event->event_data.data);\n            uint8_t foo[] = {0xf0, 0x09, 0x41, 0x10, 0x42, 0x12, 0x40, 0x00, 0x15, 0x00, 0xf7};\n            uint8_t foo_ch = event->event_data.channel;\n            if (foo_ch == 9) {\n                foo_ch = 0;\n            } else if (foo_ch < 9) {\n                foo_ch++;\n            }\n            foo[7] = 0x10 | foo_ch;\n            foo[9] = event->event_data.data.value;\n            memcpy(&((*out)[out_ofs]),foo,11);\n            out_ofs += 11;\n            running_event = 0;\n        } else if (event->do_event == _WM_do_sysex_gm_reset) {\n            // DEBUG\n            // fprintf(stderr,\"Sysex GM Reset\\r\\n\");\n            uint8_t foo[] = {0xf0, 0x05, 0x7e, 0x7f, 0x09, 0x01, 0xf7};\n            memcpy(&((*out)[out_ofs]),foo,7);\n            out_ofs += 7;\n            running_event = 0;\n        } else if (event->do_event == _WM_do_sysex_roland_reset) {\n            // DEBUG\n            // fprintf(stderr,\"Sysex Roland Reset\\r\\n\");\n            uint8_t foo[] = {0xf0, 0x0a, 0x41, 0x10, 0x42, 0x12, 0x40, 0x00, 0x7f, 0x00, 0x41, 0xf7};\n            memcpy(&((*out)[out_ofs]),foo,12);\n            out_ofs += 12;\n            running_event = 0;\n        } else if (event->do_event == _WM_do_sysex_yamaha_reset) {\n            // DEBUG\n            // fprintf(stderr,\"Sysex Yamaha Reset\\r\\n\");\n            uint8_t foo[] = {0xf0, 0x08, 0x43, 0x10, 0x4c, 0x00, 0x00, 0x7e, 0x00, 0xf7};\n            memcpy(&((*out)[out_ofs]),foo,10);\n            out_ofs += 10;\n            running_event = 0;\n        } else if (event->do_event == _WM_do_meta_endoftrack) {\n            // DEBUG\n            // fprintf(stderr,\"End Of Track\\r\\n\");\n            if ((!(_WM_MixerOptions & WM_MO_SAVEASTYPE0)) && (mdi->is_type2)) {\n                /* Write end of track marker */\n                (*out)[out_ofs++] = 0xff;\n                (*out)[out_ofs++] = 0x2f;\n                (*out)[out_ofs++] = 0x00;\n                track_size = out_ofs - track_start;\n                (*out)[track_start - 4] = (track_size >> 24) & 0xff;\n                (*out)[track_start - 3] = (track_size >> 16) & 0xff;\n                (*out)[track_start - 2] = (track_size >> 8) & 0xff;\n                (*out)[track_start - 1] = track_size & 0xff;\n\n                if (event[1].do_event != NULL) {\n                    (*out)[out_ofs++] = 'M';\n                    (*out)[out_ofs++] = 'T';\n                    (*out)[out_ofs++] = 'r';\n                    (*out)[out_ofs++] = 'k';\n                    track_count++;\n                    out_ofs += 4;\n                    track_start = out_ofs;\n\n                    /* write out a 0 delta */\n                    (*out)[out_ofs++] = 0;\n\n                    running_event = 0;\n                }\n            }\n            goto NEXT_EVENT;\n        } else if (event->do_event == _WM_do_meta_tempo) {\n            // DEBUG\n            // fprintf(stderr,\"Tempo: %u\\r\\n\",event->event_data.data);\n            tempo = event->event_data.data.value & 0xffffff;\n\n            samples_per_tick = _WM_GetSamplesPerTick(divisions, tempo);\n\n            //DEBUG\n            //fprintf(stderr,\"\\rDEBUG: div %i, tempo %i, bpm %f, pps %f, spd %f\\r\\n\", divisions, tempo, bpm_f, pulses_per_second_f, samples_per_delta_f);\n\n            (*out)[out_ofs++] = 0xff;\n            (*out)[out_ofs++] = 0x51;\n            (*out)[out_ofs++] = 0x03;\n            (*out)[out_ofs++] = (tempo & 0xff0000) >> 16;\n            (*out)[out_ofs++] = (tempo & 0xff00) >> 8;\n            (*out)[out_ofs++] = (tempo & 0xff);\n        } else if (event->do_event == _WM_do_meta_timesignature) {\n            // DEBUG\n            // fprintf(stderr,\"Time Signature: %x\\r\\n\",event->event_data.data);\n            (*out)[out_ofs++] = 0xff;\n            (*out)[out_ofs++] = 0x58;\n            (*out)[out_ofs++] = 0x04;\n            (*out)[out_ofs++] = (event->event_data.data.value & 0xff000000) >> 24;\n            (*out)[out_ofs++] = (event->event_data.data.value & 0xff0000) >> 16;\n            (*out)[out_ofs++] = (event->event_data.data.value & 0xff00) >> 8;\n            (*out)[out_ofs++] = (event->event_data.data.value & 0xff);\n        } else if (event->do_event == _WM_do_meta_keysignature) {\n            // DEBUG\n            // fprintf(stderr,\"Key Signature: %x\\r\\n\",event->event_data.data);\n            (*out)[out_ofs++] = 0xff;\n            (*out)[out_ofs++] = 0x59;\n            (*out)[out_ofs++] = 0x02;\n            (*out)[out_ofs++] = (event->event_data.data.value & 0xff00) >> 8;\n            (*out)[out_ofs++] = (event->event_data.data.value & 0xff);\n        } else if (event->do_event == _WM_do_meta_sequenceno) {\n            // DEBUG\n            // fprintf(stderr,\"Sequence Number: %x\\r\\n\",event->event_data.data);\n            (*out)[out_ofs++] = 0xff;\n            (*out)[out_ofs++] = 0x00;\n            (*out)[out_ofs++] = 0x02;\n            (*out)[out_ofs++] = (event->event_data.data.value & 0xff00) >> 8;\n            (*out)[out_ofs++] = (event->event_data.data.value & 0xff);\n        } else if (event->do_event == _WM_do_meta_channelprefix) {\n            // DEBUG\n            // fprintf(stderr,\"Channel Prefix: %x\\r\\n\",event->event_data.data);\n            (*out)[out_ofs++] = 0xff;\n            (*out)[out_ofs++] = 0x20;\n            (*out)[out_ofs++] = 0x01;\n            (*out)[out_ofs++] = (event->event_data.data.value & 0xff);\n        } else if (event->do_event == _WM_do_meta_portprefix) {\n            // DEBUG\n            // fprintf(stderr,\"Port Prefix: %x\\r\\n\",event->event_data.data);\n            (*out)[out_ofs++] = 0xff;\n            (*out)[out_ofs++] = 0x21;\n            (*out)[out_ofs++] = 0x01;\n            (*out)[out_ofs++] = (event->event_data.data.value & 0xff);\n        } else if (event->do_event == _WM_do_meta_smpteoffset) {\n            // DEBUG\n            // fprintf(stderr,\"SMPTE Offset: %x\\r\\n\",event->event_data.data);\n            (*out)[out_ofs++] = 0xff;\n            (*out)[out_ofs++] = 0x54;\n            (*out)[out_ofs++] = 0x05;\n            /*\n             Remember because of the 5 bytes we stored it a little hacky.\n             */\n            (*out)[out_ofs++] = (event->event_data.channel & 0xff);\n            (*out)[out_ofs++] = (event->event_data.data.value & 0xff000000) >> 24;\n            (*out)[out_ofs++] = (event->event_data.data.value & 0xff0000) >> 16;\n            (*out)[out_ofs++] = (event->event_data.data.value & 0xff00) >> 8;\n            (*out)[out_ofs++] = (event->event_data.data.value & 0xff);\n\n        } else if (event->do_event == _WM_do_meta_text) {\n            (*out)[out_ofs++] = 0xff;\n            (*out)[out_ofs++] = 0x01;\n\n            goto _WRITE_TEXT;\n\n        } else if (event->do_event == _WM_do_meta_copyright) {\n            (*out)[out_ofs++] = 0xff;\n            (*out)[out_ofs++] = 0x02;\n\n            goto _WRITE_TEXT;\n\n        } else if (event->do_event == _WM_do_meta_trackname) {\n            (*out)[out_ofs++] = 0xff;\n            (*out)[out_ofs++] = 0x03;\n\n            goto _WRITE_TEXT;\n\n        } else if (event->do_event == _WM_do_meta_instrumentname) {\n            (*out)[out_ofs++] = 0xff;\n            (*out)[out_ofs++] = 0x04;\n\n            goto _WRITE_TEXT;\n\n        } else if (event->do_event == _WM_do_meta_lyric) {\n            (*out)[out_ofs++] = 0xff;\n            (*out)[out_ofs++] = 0x05;\n\n            goto _WRITE_TEXT;\n\n        } else if (event->do_event == _WM_do_meta_marker) {\n            (*out)[out_ofs++] = 0xff;\n            (*out)[out_ofs++] = 0x06;\n\n            goto _WRITE_TEXT;\n\n        } else if (event->do_event == _WM_do_meta_cuepoint) {\n            (*out)[out_ofs++] = 0xff;\n            (*out)[out_ofs++] = 0x07;\n\n            _WRITE_TEXT:\n            value = strlen(event->event_data.data.string);\n            if (value > 0x0fffffff)\n                (*out)[out_ofs++] = (((value >> 28) &0x7f) | 0x80);\n            if (value > 0x1fffff)\n                (*out)[out_ofs++] = (((value >> 21) &0x7f) | 0x80);\n            if (value > 0x3fff)\n                (*out)[out_ofs++] = (((value >> 14) & 0x7f) | 0x80);\n            if (value > 0x7f)\n                (*out)[out_ofs++] = (((value >> 7) & 0x7f) | 0x80);\n            (*out)[out_ofs++] = (value & 0x7f);\n\n            memcpy(&(*out)[out_ofs], event->event_data.data.string, value);\n            out_ofs += value;\n\n        } else {\n            // DEBUG\n            fprintf(stderr,\"Unknown Event %.2x %.4x\\n\",event->event_data.channel, event->event_data.data.value);\n            event++;\n            continue;\n        }\n\n        value_f = (float)event->samples_to_next / samples_per_tick;\n        value = (uint32_t)(value_f + 0.5);\n\n        //DEBUG\n        //fprintf(stderr,\"\\rDEBUG: STN %i, SPD %f, Delta %i\\r\\n\", event->samples_to_next, samples_per_delta_f, value);\n\n        if (value > 0x0fffffff)\n            (*out)[out_ofs++] = (((value >> 28) &0x7f) | 0x80);\n        if (value > 0x1fffff)\n            (*out)[out_ofs++] = (((value >> 21) &0x7f) | 0x80);\n        if (value > 0x3fff)\n            (*out)[out_ofs++] = (((value >> 14) & 0x7f) | 0x80);\n        if (value > 0x7f)\n            (*out)[out_ofs++] = (((value >> 7) & 0x7f) | 0x80);\n        (*out)[out_ofs++] = (value & 0x7f);\n    NEXT_EVENT:\n        event++;\n    } while (event->do_event != NULL);\n\n    if ((_WM_MixerOptions & WM_MO_SAVEASTYPE0) || (!mdi->is_type2)) {\n        /* Write end of track marker */\n        (*out)[out_ofs++] = 0xff;\n        (*out)[out_ofs++] = 0x2f;\n        (*out)[out_ofs++] = 0x00;\n\n        /* Write last track size */\n        track_size = out_ofs - track_start;\n        (*out)[track_start - 4] = (track_size >> 24) & 0xff;\n        (*out)[track_start - 3] = (track_size >> 16) & 0xff;\n        (*out)[track_start - 2] = (track_size >> 8) & 0xff;\n        (*out)[track_start - 1] = track_size & 0xff;\n    }\n    /* write track count */\n    (*out)[10] = (track_count >> 8) & 0xff;\n    (*out)[11] = track_count & 0xff;\n\n    (*out) = realloc((*out), out_ofs);\n    (*outsize) = out_ofs;\n\n    return 0;\n}\n", "/*\n * mus_wm.c -- Midi Wavetable Processing library\n *\n * Copyright (C) WildMIDI Developers 2001-2016\n *\n * This file is part of WildMIDI.\n *\n * WildMIDI is free software: you can redistribute and/or modify the player\n * under the terms of the GNU General Public License and you can redistribute\n * and/or modify the library under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation, either version 3 of\n * the licenses, or(at your option) any later version.\n *\n * WildMIDI is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License and\n * the GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License and the\n * GNU Lesser General Public License along with WildMIDI.  If not,  see\n * <http://www.gnu.org/licenses/>.\n */\n\n#include \"config.h\"\n\n#include <stdint.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n\n#include \"common.h\"\n#include \"wm_error.h\"\n#include \"wildmidi_lib.h\"\n#include \"internal_midi.h\"\n#include \"reverb.h\"\n#include \"f_mus.h\"\n\n#ifdef DEBUG_MUS\n#define MUS_EVENT_DEBUG(dx,dy,dz) fprintf(stderr,\"\\r%s, 0x%.2x, 0x%.8x\\n\",dx,dy,dz)\n#else\n#define MUS_EVENT_DEBUG(dx,dy,dz)\n#endif\n\n\n/*\n Turns hmp file data into an event stream\n */\nstruct _mdi *\n_WM_ParseNewMus(uint8_t *mus_data, uint32_t mus_size) {\n    uint8_t mus_hdr[] = { 'M', 'U', 'S', 0x1A };\n    uint32_t mus_song_ofs = 0;\n    uint32_t mus_song_len = 0;\n    uint16_t mus_ch_cnt1 = 0;\n    uint16_t mus_ch_cnt2 = 0;\n    uint16_t mus_no_instr = 0;\n    uint32_t mus_data_ofs = 0;\n    uint16_t * mus_mid_instr = NULL;\n    uint16_t mus_instr_cnt = 0;\n    struct _mdi *mus_mdi;\n    uint32_t mus_divisions = 60;\n    float tempo_f = 0.0;\n    uint16_t mus_freq = 0;\n    float samples_per_tick_f = 0.0;\n#define MUS_SZ 4\n    uint8_t mus_event[MUS_SZ] = { 0, 0, 0, 0 };\n    uint8_t mus_event_size = 0;\n    uint8_t mus_prev_vol[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n    uint32_t setup_ret = 0;\n    uint32_t mus_ticks = 0;\n    uint32_t sample_count = 0;\n    float sample_count_f = 0.0;\n    float sample_remainder = 0.0;\n    uint16_t pitchbend_tmp = 0;\n\n    if (mus_size < 17) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_MUS, \"File too short\", 0);\n        return NULL;\n    }\n\n    if (memcmp(mus_data, mus_hdr, 4)) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_MUS, NULL, 0);\n        return NULL;\n    }\n\n    // Get Song Length\n    mus_song_len = (mus_data[5] << 8) | mus_data[4];\n    // Get Song Offset\n    mus_song_ofs = (mus_data[7] << 8) | mus_data[6];\n\n    // Have yet to determine what this actually is.\n    mus_ch_cnt1 = (mus_data[9] << 8) | mus_data[8];\n    mus_ch_cnt2 = (mus_data[11] << 8) | mus_data[10];\n\n    UNUSED(mus_ch_cnt1);\n    UNUSED(mus_ch_cnt2);\n\n    // Number of instruments defined\n    mus_no_instr = (mus_data[13] << 8) | mus_data[12];\n\n    // Skip next 2 data bytes\n    mus_data_ofs = 16;\n\n    // Check that we have enough data to check the rest\n    if (mus_size < (mus_data_ofs + (mus_no_instr << 1) + mus_song_len)) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_MUS, \"File too short\", 0);\n        return NULL;\n    }\n\n    // Instrument definition\n    mus_mid_instr = malloc(mus_no_instr * sizeof(uint16_t));\n    for (mus_instr_cnt = 0; mus_instr_cnt < mus_no_instr; mus_instr_cnt++) {\n        mus_mid_instr[mus_instr_cnt] = (mus_data[mus_data_ofs + 1] << 8) | mus_data[mus_data_ofs];\n        mus_data_ofs += 2;\n    }\n\n    // make sure we are at song offset\n    mus_data_ofs = mus_song_ofs;\n\n    // do some calculations so we know how many samples per mus tick\n    mus_freq = _cvt_get_option(WM_CO_FREQUENCY);\n    if (mus_freq == 0) mus_freq = 140;\n\n    if ((_WM_MixerOptions & WM_MO_ROUNDTEMPO)) {\n        tempo_f = (float) (60000000 / mus_freq) + 0.5f;\n    } else {\n        tempo_f = (float) (60000000 / mus_freq);\n    }\n\n    samples_per_tick_f = _WM_GetSamplesPerTick(mus_divisions, (uint32_t)tempo_f);\n\n    // initialise the mdi structure\n    mus_mdi = _WM_initMDI();\n    _WM_midi_setup_divisions(mus_mdi, mus_divisions);\n    _WM_midi_setup_tempo(mus_mdi, (uint32_t)tempo_f);\n\n    // lets do this\n    do {\n        // Build the event\n    _mus_build_event:\n#if 1\n        // Mus drums happen on channel 15, swap channel 9 & 15\n        // DEBUG\n        MUS_EVENT_DEBUG(\"Before\", mus_data[mus_data_ofs], 0);\n\n        if ((mus_data[mus_data_ofs] & 0x0f) == 0x0f) {\n            mus_data[mus_data_ofs] = (mus_data[mus_data_ofs] & 0xf0) | 0x09;\n        } else if ((mus_data[mus_data_ofs] & 0x0f) == 0x09) {\n            mus_data[mus_data_ofs] = (mus_data[mus_data_ofs] & 0xf0) | 0x0f;\n        }\n        // DEBUG\n        MUS_EVENT_DEBUG(\"After\", mus_data[mus_data_ofs], 0);\n#endif\n        switch ((mus_data[mus_data_ofs] >> 4) & 0x07) {\n            case 0: // Note Off\n                mus_event_size = 2;\n                mus_event[0] = 0x80 | (mus_data[mus_data_ofs] & 0x0f);\n                mus_event[1] = mus_data[mus_data_ofs + 1];\n                mus_event[2] = 0;\n                mus_event[3] = 0;\n                break;\n            case 1: // Note On\n                if (mus_data[mus_data_ofs + 1] & 0x80) {\n                    mus_event_size = 3;\n                    mus_event[0] = 0x90 | (mus_data[mus_data_ofs] & 0x0f);\n                    mus_event[1] = mus_data[mus_data_ofs + 1] & 0x7f;\n                    mus_event[2] = mus_data[mus_data_ofs + 2];\n                    mus_event[3] = 0;\n                    mus_prev_vol[mus_data[mus_data_ofs] & 0x0f] = mus_event[2];\n                } else {\n                    mus_event_size = 2;\n                    mus_event[0] = 0x90 | (mus_data[mus_data_ofs] & 0x0f);\n                    mus_event[1] = mus_data[mus_data_ofs + 1];\n                    mus_event[2] = mus_prev_vol[mus_data[mus_data_ofs] & 0x0f];\n                    mus_event[3] = 0;\n                }\n                break;\n            case 2: // Pitch Bend\n                mus_event_size = 2;\n                mus_event[0] = 0xe0 | (mus_data[mus_data_ofs] & 0x0f);\n\n                pitchbend_tmp = mus_data[mus_data_ofs + 1] << 6;\n                mus_event[1] = pitchbend_tmp & 0x7f;\n                mus_event[2] = (pitchbend_tmp >> 7) & 0x7f;\n                mus_event[3] = 0;\n                break;\n            case 3:\n                mus_event_size = 2;\n                switch (mus_data[mus_data_ofs + 1]) {\n                    case 10: // All Sounds Off\n                        mus_event[0] = 0xb0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = 120;\n                        mus_event[2] = 0;\n                        mus_event[3] = 0;\n                        break;\n                    case 11: // All Notes Off\n                        mus_event[0] = 0xb0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = 123;\n                        mus_event[2] = 0;\n                        mus_event[3] = 0;\n                        break;\n                    case 12: // Mono (Not supported by WildMIDI)\n                        /*\n                         **************************\n                         FIXME: Add dummy mdi event\n                         **************************\n                         */\n                        mus_event[0] = 0xb0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = 126;\n                        mus_event[2] = 0;\n                        mus_event[3] = 0;\n                        break;\n                    case 13: // Poly (Not supported by WildMIDI)\n                        /*\n                         **************************\n                         FIXME: Add dummy mdi event\n                         **************************\n                         */\n                        mus_event[0] = 0xb0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = 127;\n                        mus_event[2] = 0;\n                        mus_event[3] = 0;\n                        break;\n                    case 14: // Reset All Controllers\n                        mus_event[0] = 0xb0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = 121;\n                        mus_event[2] = 0;\n                        mus_event[3] = 0;\n                        break;\n                    default: // Unsupported\n                        goto _mus_next_data;\n                }\n                break;\n            case 4:\n                mus_event_size = 3;\n                switch (mus_data[mus_data_ofs + 1]) {\n                    case 0: // Patch\n                        /*\n                         *************************************************\n                         FIXME: Check if setting is MIDI or MUS instrument\n                         *************************************************\n                         */\n                        mus_event[0] = 0xc0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = mus_data[mus_data_ofs + 2];\n                        mus_event[2] = 0;\n                        mus_event[3] = 0;\n                        break;\n                    case 1: // Bank Select\n                        mus_event[0] = 0xb0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = 0;\n                        mus_event[2] = mus_data[mus_data_ofs + 2];\n                        mus_event[3] = 0;\n                        break;\n                    case 2: // Modulation (Not supported by WildMidi)\n                        mus_event[0] = 0xb0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = 1;\n                        mus_event[2] = mus_data[mus_data_ofs + 2];\n                        mus_event[3] = 0;\n                        break;\n                    case 3: // Volume\n                        mus_event[0] = 0xb0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = 7;\n                        mus_event[2] = mus_data[mus_data_ofs + 2];\n                        mus_event[3] = 0;\n                        break;\n                    case 4: // Pan\n                        mus_event[0] = 0xb0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = 10;\n                        mus_event[2] = mus_data[mus_data_ofs + 2];\n                        mus_event[3] = 0;\n                        break;\n                    case 5: // Expression\n                        mus_event[0] = 0xb0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = 11;\n                        mus_event[2] = mus_data[mus_data_ofs + 2];\n                        mus_event[3] = 0;\n                        break;\n                    case 6: // Reverb (Not supported by WildMidi)\n                        mus_event[0] = 0xb0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = 91;\n                        mus_event[2] = mus_data[mus_data_ofs + 2];\n                        mus_event[3] = 0;\n                        break;\n                    case 7: // Chorus (Not supported by WildMidi)\n                        mus_event[0] = 0xb0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = 93;\n                        mus_event[2] = mus_data[mus_data_ofs + 2];\n                        mus_event[3] = 0;\n                        break;\n                    case 8: // Sustain\n                        mus_event[0] = 0xb0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = 64;\n                        mus_event[2] = mus_data[mus_data_ofs + 2];\n                        mus_event[3] = 0;\n                        break;\n                    case 9: // Soft Peddle (Not supported by WildMidi)\n                        mus_event[0] = 0xb0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = 67;\n                        mus_event[2] = mus_data[mus_data_ofs + 2];\n                        mus_event[3] = 0;\n                        break;\n                    default: // Unsupported\n                        goto _mus_next_data;\n                }\n                break;\n            case 5:\n                mus_event_size = 1;\n                goto _mus_next_data;\n                break;\n            case 6:\n                goto _mus_end_of_song;\n                break;\n            case 7:\n                mus_event_size = 1;\n                goto _mus_next_data;\n                break;\n        }\n\n        setup_ret = _WM_SetupMidiEvent(mus_mdi, (uint8_t *)mus_event, MUS_SZ, 0);\n        if (setup_ret == 0) {\n            goto _mus_end;\n        }\n\n    _mus_next_data:\n        if (!(mus_data[mus_data_ofs] & 0x80)) {\n            mus_data_ofs += mus_event_size;\n            goto _mus_build_event;\n\n        }\n        mus_data_ofs += mus_event_size;\n\n        mus_ticks = 0;\n        do {\n            mus_ticks = (mus_ticks << 7) | (mus_data[mus_data_ofs++] & 0x7f);\n        } while (mus_data[mus_data_ofs - 1] & 0x80);\n\n        sample_count_f = ((float)mus_ticks * samples_per_tick_f) + sample_remainder;\n        sample_count = (uint32_t)sample_count_f;\n        sample_remainder = sample_count_f - (float)sample_count;\n\n        mus_mdi->events[mus_mdi->event_count - 1].samples_to_next = sample_count;\n        mus_mdi->extra_info.approx_total_samples += sample_count;\n\n    } while (mus_data_ofs < mus_size);\n\n_mus_end_of_song:\n    // Finalise mdi structure\n    if ((mus_mdi->reverb = _WM_init_reverb(_WM_SampleRate, _WM_reverb_room_width, _WM_reverb_room_length, _WM_reverb_listen_posx, _WM_reverb_listen_posy)) == NULL) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_MEM, \"to init reverb\", 0);\n        goto _mus_end;\n    }\n    _WM_midi_setup_endoftrack(mus_mdi);\n    mus_mdi->extra_info.current_sample = 0;\n    mus_mdi->current_event = &mus_mdi->events[0];\n    mus_mdi->samples_to_mix = 0;\n    mus_mdi->note = NULL;\n\n    _WM_ResetToStart(mus_mdi);\n\n_mus_end:\n    free(mus_mid_instr);\n    if (mus_mdi->reverb) return (mus_mdi);\n    _WM_freeMDI(mus_mdi);\n    return NULL;\n}\n", "/*\n * xmi.c -- Midi Wavetable Processing library\n *\n * Copyright (C) WildMIDI Developers 2001-2016\n *\n * This file is part of WildMIDI.\n *\n * WildMIDI is free software: you can redistribute and/or modify the player\n * under the terms of the GNU General Public License and you can redistribute\n * and/or modify the library under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation, either version 3 of\n * the licenses, or(at your option) any later version.\n *\n * WildMIDI is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License and\n * the GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License and the\n * GNU Lesser General Public License along with WildMIDI.  If not,  see\n * <http://www.gnu.org/licenses/>.\n */\n\n#include \"config.h\"\n\n#include <stdint.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n\n#include \"common.h\"\n#include \"wm_error.h\"\n#include \"wildmidi_lib.h\"\n#include \"internal_midi.h\"\n#include \"reverb.h\"\n#include \"f_xmidi.h\"\n\n\nstruct _mdi *_WM_ParseNewXmi(uint8_t *xmi_data, uint32_t xmi_size) {\n    struct _mdi *xmi_mdi = NULL;\n    uint32_t xmi_tmpdata = 0;\n    uint8_t xmi_formcnt = 0;\n    uint32_t xmi_catlen = 0;\n    uint32_t xmi_subformlen = 0;\n    uint32_t i = 0;\n    uint32_t j = 0;\n\n    uint32_t xmi_evntlen = 0;\n    uint32_t xmi_divisions = 60;\n    uint32_t xmi_tempo = 500000;\n    uint32_t xmi_sample_count = 0;\n    float xmi_sample_count_f = 0.0;\n    float xmi_sample_remainder = 0.0;\n    float xmi_samples_per_delta_f = 0.0;\n    uint8_t xmi_ch = 0;\n    uint8_t xmi_note = 0;\n    uint32_t *xmi_notelen = NULL;\n\n    uint32_t setup_ret = 0;\n    uint32_t xmi_delta = 0;\n    uint32_t xmi_lowestdelta = 0;\n\n    uint32_t xmi_evnt_cnt = 0;\n\n\n    if (memcmp(xmi_data,\"FORM\",4)) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_XMI, NULL, 0);\n        return NULL;\n    }\n\n    xmi_data += 4;\n    xmi_size -= 4;\n\n    // bytes until next entry\n    xmi_tmpdata = *xmi_data++ << 24;\n    xmi_tmpdata |= *xmi_data++ << 16;\n    xmi_tmpdata |= *xmi_data++ << 8;\n    xmi_tmpdata |= *xmi_data++;\n    xmi_size -= 4;\n\n    if (memcmp(xmi_data,\"XDIRINFO\",8)) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_XMI, NULL, 0);\n        return NULL;\n    }\n    xmi_data += 8;\n    xmi_size -= 8;\n\n    /*\n     0x00 0x00 0x00 0x02 at this point are unknown\n     so skip over them\n     */\n    xmi_data += 4;\n    xmi_size -= 4;\n\n    // number of forms contained after this point\n    xmi_formcnt = *xmi_data++;\n    if (xmi_formcnt == 0) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_XMI, NULL, 0);\n        return NULL;\n    }\n    xmi_size--;\n\n    /*\n     at this stage unsure if remaining data in\n     this section means anything\n     */\n    xmi_tmpdata -= 13;\n    xmi_data += xmi_tmpdata;\n    xmi_size -= xmi_tmpdata;\n\n    /* FIXME: Check: may not even need to process CAT information */\n    if (memcmp(xmi_data,\"CAT \",4)) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_XMI, NULL, 0);\n        return NULL;\n    }\n    xmi_data += 4;\n    xmi_size -= 4;\n\n    xmi_catlen = *xmi_data++ << 24;\n    xmi_catlen |= *xmi_data++ << 16;\n    xmi_catlen |= *xmi_data++ << 8;\n    xmi_catlen |= *xmi_data++;\n    xmi_size -= 4;\n\n    UNUSED(xmi_catlen);\n\n    if (memcmp(xmi_data,\"XMID\",4)) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_XMI, NULL, 0);\n        return NULL;\n    }\n    xmi_data += 4;\n    xmi_size -= 4;\n\n    xmi_mdi = _WM_initMDI();\n    _WM_midi_setup_divisions(xmi_mdi, xmi_divisions);\n    _WM_midi_setup_tempo(xmi_mdi, xmi_tempo);\n\n    xmi_samples_per_delta_f = _WM_GetSamplesPerTick(xmi_divisions, xmi_tempo);\n\n    xmi_notelen = malloc(sizeof(uint32_t) * 16 * 128);\n    memset(xmi_notelen, 0, (sizeof(uint32_t) * 16 * 128));\n\n    for (i = 0; i < xmi_formcnt; i++) {\n        if (memcmp(xmi_data,\"FORM\",4)) {\n            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_XMI, NULL, 0);\n            goto _xmi_end;\n        }\n        xmi_data += 4;\n        xmi_size -= 4;\n\n        xmi_subformlen = *xmi_data++ << 24;\n        xmi_subformlen |= *xmi_data++ << 16;\n        xmi_subformlen |= *xmi_data++ << 8;\n        xmi_subformlen |= *xmi_data++;\n        xmi_size -= 4;\n\n        if (memcmp(xmi_data,\"XMID\",4)) {\n            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_XMI, NULL, 0);\n            goto _xmi_end;\n        }\n        xmi_data += 4;\n        xmi_size -= 4;\n        xmi_subformlen -= 4;\n\n        // Process Subform\n        do {\n            if (!memcmp(xmi_data,\"TIMB\",4)) {\n                // Holds patch information\n                // FIXME: May not be needed for playback as EVNT seems to\n                //        hold patch events\n                xmi_data += 4;\n\n                xmi_tmpdata = *xmi_data++ << 24;\n                xmi_tmpdata |= *xmi_data++ << 16;\n                xmi_tmpdata |= *xmi_data++ << 8;\n                xmi_tmpdata |= *xmi_data++;\n                xmi_data += xmi_tmpdata;\n                xmi_size -= (8 + xmi_tmpdata);\n                xmi_subformlen -= (8 + xmi_tmpdata);\n\n            } else if (!memcmp(xmi_data,\"RBRN\",4)) {\n                // Unknown what this is\n                // FIXME: May not be needed for playback\n                xmi_data += 4;\n\n                xmi_tmpdata = *xmi_data++ << 24;\n                xmi_tmpdata |= *xmi_data++ << 16;\n                xmi_tmpdata |= *xmi_data++ << 8;\n                xmi_tmpdata |= *xmi_data++;\n                xmi_data += xmi_tmpdata;\n                xmi_size -= (8 + xmi_tmpdata);\n                xmi_subformlen -= (8 + xmi_tmpdata);\n\n            } else if (!memcmp(xmi_data,\"EVNT\",4)) {\n                // EVNT is where all the MIDI music information is stored\n                xmi_data += 4;\n\n                xmi_evnt_cnt++;\n\n                xmi_evntlen = *xmi_data++ << 24;\n                xmi_evntlen |= *xmi_data++ << 16;\n                xmi_evntlen |= *xmi_data++ << 8;\n                xmi_evntlen |= *xmi_data++;\n                xmi_size -= 8;\n                xmi_subformlen -= 8;\n\n                do {\n                    if (*xmi_data < 0x80) {\n                        xmi_delta = 0;\n                        if (*xmi_data > 0x7f) {\n                            while (*xmi_data > 0x7f) {\n                                xmi_delta = (xmi_delta << 7) | (*xmi_data++ & 0x7f);\n                                xmi_size--;\n                                xmi_evntlen--;\n                                xmi_subformlen--;\n                            }\n                        }\n                        xmi_delta = (xmi_delta << 7) | (*xmi_data++ & 0x7f);\n                        xmi_size--;\n                        xmi_evntlen--;\n                        xmi_subformlen--;\n\n                        do {\n                            // determine delta till next event\n                            if ((xmi_lowestdelta != 0) && (xmi_lowestdelta <= xmi_delta)) {\n                                xmi_tmpdata = xmi_lowestdelta;\n                            } else {\n                                xmi_tmpdata = xmi_delta;\n                            }\n\n                            xmi_sample_count_f= (((float) xmi_tmpdata * xmi_samples_per_delta_f) + xmi_sample_remainder);\n\n                            xmi_sample_count = (uint32_t) xmi_sample_count_f;\n                            xmi_sample_remainder = xmi_sample_count_f - (float) xmi_sample_count;\n\n                            xmi_mdi->events[xmi_mdi->event_count - 1].samples_to_next += xmi_sample_count;\n                            xmi_mdi->extra_info.approx_total_samples += xmi_sample_count;\n\n                            xmi_lowestdelta = 0;\n\n                            // scan through on notes\n                            for (j = 0; j < (16*128); j++) {\n                                // only want notes that are on\n                                if (xmi_notelen[j] == 0) continue;\n\n                                // remove delta to next event from on notes\n                                xmi_notelen[j] -= xmi_tmpdata;\n\n                                // Check if we need to turn note off\n                                if (xmi_notelen[j] == 0) {\n                                    xmi_ch = j / 128;\n                                    xmi_note = j - (xmi_ch * 128);\n                                    _WM_midi_setup_noteoff(xmi_mdi, xmi_ch, xmi_note, 0);\n                                } else {\n                                    // otherwise work out new lowest delta\n                                    if ((xmi_lowestdelta == 0) || (xmi_lowestdelta > xmi_notelen[j])) {\n                                        xmi_lowestdelta = xmi_notelen[j];\n                                    }\n                                }\n                            }\n                            xmi_delta -= xmi_tmpdata;\n                        } while (xmi_delta);\n\n                    } else {\n                        if ((xmi_data[0] == 0xff) && (xmi_data[1] == 0x51) && (xmi_data[2] == 0x03)) {\n                            // Ignore tempo events\n                            setup_ret = 6;\n                            goto _XMI_Next_Event;\n                        }\n                        if ((setup_ret = _WM_SetupMidiEvent(xmi_mdi,xmi_data, xmi_size, 0)) == 0) {\n                            goto _xmi_end;\n                        }\n\n                        if ((*xmi_data & 0xf0) == 0x90) {\n                            // Note on has extra data stating note length\n                            xmi_ch = *xmi_data & 0x0f;\n                            xmi_note = xmi_data[1];\n                            xmi_data += setup_ret;\n                            xmi_size -= setup_ret;\n                            xmi_evntlen -= setup_ret;\n                            xmi_subformlen -= setup_ret;\n\n                            xmi_tmpdata = 0;\n\n                            if (*xmi_data > 0x7f) {\n                                while (*xmi_data > 0x7f) {\n                                    xmi_tmpdata = (xmi_tmpdata << 7) | (*xmi_data++ & 0x7f);\n                                    xmi_size--;\n                                    xmi_evntlen--;\n                                    xmi_subformlen--;\n                                }\n                            }\n                            xmi_tmpdata = (xmi_tmpdata << 7) | (*xmi_data++ & 0x7f);\n                            xmi_size--;\n                            xmi_evntlen--;\n                            xmi_subformlen--;\n\n                            // store length\n                            xmi_notelen[128 * xmi_ch + xmi_note] = xmi_tmpdata;\n                            if ((xmi_tmpdata > 0) && ((xmi_lowestdelta == 0) || (xmi_tmpdata < xmi_lowestdelta))) {\n                                xmi_lowestdelta = xmi_tmpdata;\n                            }\n\n                        } else {\n                        _XMI_Next_Event:\n                            xmi_data += setup_ret;\n                            xmi_size -= setup_ret;\n                            xmi_evntlen -= setup_ret;\n                            xmi_subformlen -= setup_ret;\n                        }\n                    }\n\n                } while (xmi_evntlen);\n\n            } else {\n                _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_XMI, NULL, 0);\n                goto _xmi_end;\n            }\n\n        } while (xmi_subformlen);\n    }\n\n    // Finalise mdi structure\n    if ((xmi_mdi->reverb = _WM_init_reverb(_WM_SampleRate, _WM_reverb_room_width, _WM_reverb_room_length, _WM_reverb_listen_posx, _WM_reverb_listen_posy)) == NULL) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_MEM, \"to init reverb\", 0);\n        goto _xmi_end;\n    }\n    xmi_mdi->extra_info.current_sample = 0;\n    xmi_mdi->current_event = &xmi_mdi->events[0];\n    xmi_mdi->samples_to_mix = 0;\n    xmi_mdi->note = NULL;\n    /* More than 1 event form in XMI means treat as type 2 */\n    if (xmi_evnt_cnt > 1) {\n        xmi_mdi->is_type2 = 1;\n    }\n    _WM_ResetToStart(xmi_mdi);\n\n_xmi_end:\n    if (xmi_notelen != NULL) free(xmi_notelen);\n    if (xmi_mdi->reverb) return (xmi_mdi);\n    _WM_freeMDI(xmi_mdi);\n    return NULL;\n}\n", "/*\n * internal_midi.c -- Midi Wavetable Processing library\n *\n * Copyright (C) WildMIDI Developers 2001-2016\n *\n * This file is part of WildMIDI.\n *\n * WildMIDI is free software: you can redistribute and/or modify the player\n * under the terms of the GNU General Public License and you can redistribute\n * and/or modify the library under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation, either version 3 of\n * the licenses, or(at your option) any later version.\n *\n * WildMIDI is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License and\n * the GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License and the\n * GNU Lesser General Public License along with WildMIDI.  If not,  see\n * <http://www.gnu.org/licenses/>.\n */\n\n#include \"config.h\"\n\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <math.h>\n\n#include \"common.h\"\n#include \"lock.h\"\n#include \"wm_error.h\"\n#include \"reverb.h\"\n#include \"sample.h\"\n#include \"wildmidi_lib.h\"\n#include \"patches.h\"\n#include \"internal_midi.h\"\n#ifdef __DJGPP__\n#define powf pow /* prefer C89 pow() from libc.a instead of powf() from libm. */\n#endif\n#ifdef WILDMIDI_AMIGA\n#define powf pow\n#endif\n#if defined(__WATCOMC__) || defined(__EMX__)\n#define powf pow\n#endif\n\n#define HOLD_OFF 0x02\n\n// #define DEBUG_MIDI\n\n#ifdef DEBUG_MIDI\n#define MIDI_EVENT_DEBUG(dx,dy,dz) fprintf(stderr,\"\\r%s, 0x%.2x, 0x%.8x\\n\",dx,dy,dz)\n#define MIDI_EVENT_SDEBUG(dx,dy,dz) fprintf(stderr,\"\\r%s, 0x%.2x, %s\\n\",dx,dy,dz)\n#else\n#define MIDI_EVENT_DEBUG(dx,dy,dz)\n#define MIDI_EVENT_SDEBUG(dx,dy,dz)\n#endif\n\n/* f: ( VOLUME / 127.0 ) * 1024.0 */\nint16_t _WM_lin_volume[] = { 0, 8, 16, 24, 32, 40, 48, 56, 64, 72, 80, 88, 96,\n    104, 112, 120, 129, 137, 145, 153, 161, 169, 177, 185, 193, 201, 209, 217,\n    225, 233, 241, 249, 258, 266, 274, 282, 290, 298, 306, 314, 322, 330, 338,\n    346, 354, 362, 370, 378, 387, 395, 403, 411, 419, 427, 435, 443, 451, 459,\n    467, 475, 483, 491, 499, 507, 516, 524, 532, 540, 548, 556, 564, 572, 580,\n    588, 596, 604, 612, 620, 628, 636, 645, 653, 661, 669, 677, 685, 693, 701,\n    709, 717, 725, 733, 741, 749, 757, 765, 774, 782, 790, 798, 806, 814, 822,\n    830, 838, 846, 854, 862, 870, 878, 886, 894, 903, 911, 919, 927, 935, 943,\n    951, 959, 967, 975, 983, 991, 999, 1007, 1015, 1024 };\n\n/* f: As per midi 2 standard */\nstatic float dBm_volume[] = { -999999.999999, -84.15214884, -72.11094901,\n    -65.06729865, -60.06974919, -56.19334866, -53.02609882, -50.34822724,\n    -48.02854936, -45.98244846, -44.15214884, -42.49644143, -40.984899,\n    -39.59441475, -38.30702741, -37.10849848, -35.98734953, -34.93419198,\n    -33.94124863, -33.0020048, -32.11094901, -31.26337705, -30.45524161,\n    -29.6830354, -28.94369917, -28.23454849, -27.55321492, -26.89759827,\n    -26.26582758, -25.65622892, -25.06729865, -24.49768108, -23.94614971,\n    -23.41159124, -22.89299216, -22.38942706, -21.90004881, -21.42407988,\n    -20.96080497, -20.50956456, -20.06974919, -19.64079457, -19.22217722,\n    -18.81341062, -18.41404178, -18.02364829, -17.64183557, -17.26823452,\n    -16.90249934, -16.54430564, -16.19334866, -15.84934179, -15.51201509,\n    -15.18111405, -14.85639845, -14.53764126, -14.22462776, -13.91715461,\n    -13.6150291, -13.31806837, -13.02609882, -12.73895544, -12.45648126,\n    -12.17852686, -11.90494988, -11.63561457, -11.37039142, -11.10915673,\n    -10.85179233, -10.59818521, -10.34822724, -10.10181489, -9.858848981,\n    -9.619234433, -9.382880049, -9.149698303, -8.919605147, -8.692519831,\n    -8.468364731, -8.247065187, -8.028549359, -7.812748083, -7.599594743,\n    -7.389025143, -7.180977396, -6.97539181, -6.772210788, -6.571378733,\n    -6.372841952, -6.176548572, -5.982448461, -5.790493145, -5.600635744,\n    -5.412830896, -5.227034694, -5.043204627, -4.861299517, -4.681279468,\n    -4.503105811, -4.326741054, -4.152148838, -3.979293887, -3.808141968,\n    -3.63865985, -3.470815266, -3.304576875, -3.139914228, -2.976797731,\n    -2.815198619, -2.655088921, -2.496441432, -2.339229687, -2.183427931,\n    -2.029011099, -1.875954785, -1.724235224, -1.573829269, -1.424714368,\n    -1.276868546, -1.130270383, -0.9848989963, -0.8407340256, -0.6977556112,\n    -0.5559443807, -0.4152814317, -0.2757483179, -0.1373270335, 0.0 };\n\n/* f: As per midi 2 standard */\nstatic float dBm_pan_volume[] = { -999999.999999, -38.15389834, -32.13396282,\n    -28.61324502, -26.1160207, -24.179814, -22.5986259, -21.26257033,\n    -20.10605521, -19.08677237, -18.17583419, -17.35263639, -16.60196565,\n    -15.91226889, -15.2745658, -14.6817375, -14.12804519, -13.60879499,\n    -13.12009875, -12.65869962, -12.22184237, -11.80717543, -11.41267571,\n    -11.03659017, -10.67738981, -10.33373306, -10.00443638, -9.6884504,\n    -9.384840381, -9.092770127, -8.811488624, -8.540318866, -8.278648457,\n    -8.025921658, -7.781632628, -7.545319633, -7.316560087, -7.094966257,\n    -6.880181552, -6.671877289, -6.46974987, -6.273518306, -6.082922045,\n    -5.897719045, -5.717684082, -5.542607236, -5.372292553, -5.206556845,\n    -5.045228616, -4.888147106, -4.735161423, -4.586129765, -4.44091872,\n    -4.299402626, -4.161462998, -4.026988004, -3.895871989, -3.76801504,\n    -3.643322591, -3.52170506, -3.403077519, -3.287359388, -3.174474158,\n    -3.064349129, -2.956915181, -2.852106549, -2.749860626, -2.650117773,\n    -2.55282115, -2.457916557, -2.36535228, -2.27507896, -2.187049463,\n    -2.101218759, -2.017543814, -1.935983486,-1.856498429, -1.779051001,\n    -1.703605184, -1.630126502, -1.558581949, -1.48893992, -1.421170148,\n    -1.35524364, -1.291132623, -1.228810491, -1.168251755, -1.109431992,\n    -1.052327808, -0.9969167902, -0.9431774708, -0.8910892898, -0.8406325604,\n    -0.7917884361, -0.7445388804, -0.6988666373, -0.6547552046, -0.612188808,\n    -0.5711523768, -0.5316315211, -0.4936125107, -0.4570822543, -0.4220282808,\n    -0.3884387214, -0.3563022927, -0.3256082808, -0.2963465264, -0.2685074109,\n    -0.2420818435, -0.2170612483, -0.1934375538, -0.1712031815, -0.1503510361,\n    -0.1308744964, -0.1127674066, -0.09602406855, -0.08063923423,\n    -0.06660809932, -0.05392629701, -0.04258989258, -0.03259537844,\n    -0.02393966977, -0.01662010072, -0.01063442111, -0.005980793601,\n    -0.002657791522, -0.000664397052, 0.0 };\n\nuint32_t _WM_freq_table[] = { 837201792, 837685632, 838169728,\n    838653568, 839138240, 839623232, 840108480, 840593984, 841079680,\n    841565184, 842051648, 842538240, 843025152, 843512320, 843999232,\n    844486976, 844975040, 845463360, 845951936, 846440320, 846929536,\n    847418944, 847908608, 848398656, 848888960, 849378944, 849869824,\n    850361024, 850852416, 851344192, 851835584, 852327872, 852820480,\n    853313280, 853806464, 854299328, 854793024, 855287040, 855781312,\n    856275904, 856770752, 857265344, 857760704, 858256448, 858752448,\n    859248704, 859744768, 860241600, 860738752, 861236160, 861733888,\n    862231360, 862729600, 863228160, 863727104, 864226176, 864725696,\n    865224896, 865724864, 866225152, 866725760, 867226688, 867727296,\n    868228736, 868730496, 869232576, 869734912, 870236928, 870739904,\n    871243072, 871746560, 872250368, 872754496, 873258240, 873762880,\n    874267840, 874773184, 875278720, 875783936, 876290112, 876796480,\n    877303232, 877810176, 878317504, 878824512, 879332416, 879840576,\n    880349056, 880857792, 881366272, 881875712, 882385280, 882895296,\n    883405440, 883915456, 884426304, 884937408, 885448832, 885960512,\n    886472512, 886984192, 887496768, 888009728, 888522944, 889036352,\n    889549632, 890063680, 890578048, 891092736, 891607680, 892122368,\n    892637952, 893153792, 893670016, 894186496, 894703232, 895219648,\n    895737024, 896254720, 896772672, 897290880, 897808896, 898327744,\n    898846912, 899366336, 899886144, 900405568, 900925952, 901446592,\n    901967552, 902488768, 903010368, 903531584, 904053760, 904576256,\n    905099008, 905622016, 906144896, 906668480, 907192512, 907716800,\n    908241408, 908765632, 909290816, 909816256, 910342144, 910868160,\n    911394624, 911920768, 912447680, 912975104, 913502720, 914030592,\n    914558208, 915086784, 915615552, 916144768, 916674176, 917203968,\n    917733440, 918263744, 918794496, 919325440, 919856704, 920387712,\n    920919616, 921451840, 921984320, 922517184, 923049728, 923583168,\n    924116928, 924651008, 925185344, 925720000, 926254336, 926789696,\n    927325312, 927861120, 928397440, 928933376, 929470208, 930007296,\n    930544768, 931082560, 931619968, 932158464, 932697152, 933236160,\n    933775488, 934315072, 934854464, 935394688, 935935296, 936476224,\n    937017344, 937558208, 938100160, 938642304, 939184640, 939727488,\n    940269888, 940813312, 941357056, 941900992, 942445440, 942990016,\n    943534400, 944079680, 944625280, 945171200, 945717440, 946263360,\n    946810176, 947357376, 947904832, 948452672, 949000192, 949548608,\n    950097280, 950646400, 951195776, 951745472, 952294912, 952845184,\n    953395904, 953946880, 954498176, 955049216, 955601088, 956153408,\n    956705920, 957258816, 957812032, 958364928, 958918848, 959472960,\n    960027456, 960582272, 961136768, 961692224, 962248000, 962804032,\n    963360448, 963916608, 964473600, 965031040, 965588736, 966146816,\n    966705152, 967263168, 967822144, 968381440, 968941120, 969501056,\n    970060736, 970621376, 971182272, 971743488, 972305088, 972866368,\n    973428608, 973991104, 974554048, 975117312, 975680768, 976243968,\n    976808192, 977372736, 977937536, 978502656, 979067584, 979633344,\n    980199488, 980765888, 981332736, 981899200, 982466688, 983034432,\n    983602624, 984171008, 984739776, 985308160, 985877632, 986447360,\n    987017472, 987587904, 988157952, 988729088, 989300416, 989872192,\n    990444224, 991016000, 991588672, 992161728, 992735168, 993308864,\n    993882880, 994456576, 995031296, 995606336, 996181696, 996757440,\n    997332800, 997909184, 998485888, 999062912, 999640256, 1000217984,\n    1000795392, 1001373696, 1001952448, 1002531520, 1003110848, 1003689920,\n    1004270016, 1004850304, 1005431040, 1006012160, 1006592832, 1007174592,\n    1007756608, 1008339008, 1008921792, 1009504768, 1010087552, 1010671296,\n    1011255360, 1011839808, 1012424576, 1013009024, 1013594368, 1014180160,\n    1014766272, 1015352768, 1015938880, 1016526016, 1017113472, 1017701248,\n    1018289408, 1018877824, 1019465984, 1020055104, 1020644672, 1021234496,\n    1021824768, 1022414528, 1023005440, 1023596608, 1024188160, 1024780096,\n    1025371584, 1025964160, 1026557120, 1027150336, 1027744000, 1028337920,\n    1028931520, 1029526144, 1030121152, 1030716480, 1031312128, 1031907456,\n    1032503808, 1033100480, 1033697536, 1034294912, 1034892032, 1035490048,\n    1036088512, 1036687232, 1037286336, 1037885824, 1038484928, 1039085056,\n    1039685632, 1040286464, 1040887680, 1041488448, 1042090368, 1042692608,\n    1043295168, 1043898176, 1044501440, 1045104384, 1045708288, 1046312640,\n    1046917376, 1047522368, 1048127040, 1048732800, 1049338816, 1049945280,\n    1050552128, 1051158528, 1051765952, 1052373824, 1052982016, 1053590592,\n    1054199424, 1054807936, 1055417600, 1056027456, 1056637760, 1057248448,\n    1057858752, 1058470016, 1059081728, 1059693824, 1060306304, 1060918336,\n    1061531392, 1062144896, 1062758656, 1063372928, 1063987392, 1064601664,\n    1065216896, 1065832448, 1066448448, 1067064704, 1067680704, 1068297728,\n    1068915136, 1069532864, 1070150976, 1070768640, 1071387520, 1072006720,\n    1072626240, 1073246080, 1073866368, 1074486272, 1075107200, 1075728512,\n    1076350208, 1076972160, 1077593856, 1078216704, 1078839680, 1079463296,\n    1080087040, 1080710528, 1081335168, 1081960064, 1082585344, 1083211008,\n    1083836928, 1084462592, 1085089280, 1085716352, 1086343936, 1086971648,\n    1087599104, 1088227712, 1088856576, 1089485824, 1090115456, 1090745472,\n    1091375104, 1092005760, 1092636928, 1093268352, 1093900160, 1094531584,\n    1095164160, 1095796992, 1096430336, 1097064064, 1097697280, 1098331648,\n    1098966400, 1099601536, 1100237056, 1100872832, 1101508224, 1102144768,\n    1102781824, 1103419136, 1104056832, 1104694144, 1105332608, 1105971328,\n    1106610432, 1107249920, 1107889152, 1108529408, 1109170048, 1109811072,\n    1110452352, 1111094144, 1111735552, 1112377984, 1113020928, 1113664128,\n    1114307712, 1114950912, 1115595264, 1116240000, 1116885120, 1117530624,\n    1118175744, 1118821888, 1119468416, 1120115456, 1120762752, 1121410432,\n    1122057856, 1122706176, 1123355136, 1124004224, 1124653824, 1125303040,\n    1125953408, 1126604160, 1127255168, 1127906560, 1128557696, 1129209984,\n    1129862528, 1130515456, 1131168768, 1131822592, 1132475904, 1133130368,\n    1133785216, 1134440448, 1135096064, 1135751296, 1136407680, 1137064448,\n    1137721472, 1138379008, 1139036800, 1139694336, 1140353024, 1141012096,\n    1141671424, 1142331264, 1142990592, 1143651200, 1144312192, 1144973440,\n    1145635200, 1146296448, 1146958976, 1147621760, 1148285056, 1148948608,\n    1149612672, 1150276224, 1150940928, 1151606144, 1152271616, 1152937600,\n    1153603072, 1154269824, 1154936832, 1155604352, 1156272128, 1156939648,\n    1157608192, 1158277248, 1158946560, 1159616384, 1160286464, 1160956288,\n    1161627264, 1162298624, 1162970240, 1163642368, 1164314112, 1164987008,\n    1165660160, 1166333824, 1167007872, 1167681536, 1168356352, 1169031552,\n    1169707136, 1170383104, 1171059584, 1171735552, 1172412672, 1173090304,\n    1173768192, 1174446592, 1175124480, 1175803648, 1176483072, 1177163008,\n    1177843328, 1178523264, 1179204352, 1179885824, 1180567680, 1181249920,\n    1181932544, 1182614912, 1183298304, 1183982208, 1184666368, 1185351040,\n    1186035328, 1186720640, 1187406464, 1188092672, 1188779264, 1189466368,\n    1190152960, 1190840832, 1191528960, 1192217600, 1192906624, 1193595136,\n    1194285056, 1194975232, 1195665792, 1196356736, 1197047296, 1197739136,\n    1198431360, 1199123968, 1199816960, 1200510336, 1201203328, 1201897600,\n    1202592128, 1203287040, 1203982464, 1204677504, 1205373696, 1206070272,\n    1206767232, 1207464704, 1208161664, 1208859904, 1209558528, 1210257536,\n    1210956928, 1211656832, 1212356224, 1213056768, 1213757952, 1214459392,\n    1215161216, 1215862656, 1216565376, 1217268352, 1217971840, 1218675712,\n    1219379200, 1220083840, 1220788992, 1221494528, 1222200448, 1222906752,\n    1223612672, 1224319872, 1225027456, 1225735424, 1226443648, 1227151616,\n    1227860864, 1228570496, 1229280512, 1229990912, 1230700928, 1231412096,\n    1232123776, 1232835840, 1233548288, 1234261248, 1234973696, 1235687424,\n    1236401536, 1237116032, 1237831040, 1238545536, 1239261312, 1239977472,\n    1240694144, 1241411072, 1242128512, 1242845568, 1243563776, 1244282496,\n    1245001600, 1245721088, 1246440192, 1247160448, 1247881216, 1248602368,\n    1249324032, 1250045184, 1250767616, 1251490432, 1252213632, 1252937344,\n    1253661440, 1254385152, 1255110016, 1255835392, 1256561152, 1257287424,\n    1258013184, 1258740096, 1259467648, 1260195456, 1260923648, 1261651584,\n    1262380800, 1263110272, 1263840256, 1264570624, 1265301504, 1266031872,\n    1266763520, 1267495552, 1268227968, 1268961024, 1269693440, 1270427264,\n    1271161472, 1271896064, 1272631168, 1273365760, 1274101632, 1274838016,\n    1275574784, 1276311808, 1277049472, 1277786624, 1278525056, 1279264000,\n    1280003328, 1280743040, 1281482368, 1282222976, 1282963968, 1283705344,\n    1284447232, 1285188736, 1285931392, 1286674560, 1287418240, 1288162176,\n    1288906624, 1289650688, 1290395904, 1291141760, 1291887872, 1292634496,\n    1293380608, 1294128128, 1294875904, 1295624320, 1296373120, 1297122304,\n    1297870976, 1298621056, 1299371520, 1300122496, 1300873856, 1301624832,\n    1302376960, 1303129600, 1303882752, 1304636288, 1305389312, 1306143872,\n    1306898688, 1307654016, 1308409600, 1309165696, 1309921536, 1310678528,\n    1311435904, 1312193920, 1312952192, 1313710080, 1314469248, 1315228928,\n    1315988992, 1316749568, 1317509632, 1318271104, 1319032960, 1319795200,\n    1320557952, 1321321088, 1322083840, 1322847872, 1323612416, 1324377216,\n    1325142656, 1325907584, 1326673920, 1327440512, 1328207744, 1328975360,\n    1329742464, 1330510976, 1331279872, 1332049152, 1332819072, 1333589248,\n    1334359168, 1335130240, 1335901824, 1336673920, 1337446400, 1338218368,\n    1338991744, 1339765632, 1340539904, 1341314560, 1342088832, 1342864512,\n    1343640576, 1344417024, 1345193984, 1345971456, 1346748416, 1347526656,\n    1348305408, 1349084672, 1349864320, 1350643456, 1351424000, 1352205056,\n    1352986496, 1353768448, 1354550784, 1355332608, 1356115968, 1356899712,\n    1357683840, 1358468480, 1359252608, 1360038144, 1360824192, 1361610624,\n    1362397440, 1363183872, 1363971712, 1364760064, 1365548672, 1366337792,\n    1367127424, 1367916672, 1368707200, 1369498240, 1370289664, 1371081472,\n    1371873024, 1372665856, 1373459072, 1374252800, 1375047040, 1375840768,\n    1376635904, 1377431552, 1378227584, 1379024000, 1379820928, 1380617472,\n    1381415296, 1382213760, 1383012480, 1383811840, 1384610560, 1385410816,\n    1386211456, 1387012480, 1387814144, 1388615168, 1389417728, 1390220672,\n    1391024128, 1391827968, 1392632320, 1393436288, 1394241536, 1395047296,\n    1395853568, 1396660224, 1397466368, 1398274048, 1399082112, 1399890688,\n    1400699648, 1401508224, 1402318080, 1403128576, 1403939456, 1404750848,\n    1405562624, 1406374016, 1407186816, 1408000000, 1408813696, 1409627904,\n    1410441728, 1411256704, 1412072320, 1412888320, 1413704960, 1414521856,\n    1415338368, 1416156288, 1416974720, 1417793664, 1418612992, 1419431808,\n    1420252160, 1421072896, 1421894144, 1422715904, 1423537280, 1424359808,\n    1425183104, 1426006784, 1426830848, 1427655296, 1428479488, 1429305088,\n    1430131072, 1430957568, 1431784576, 1432611072, 1433438976, 1434267392,\n    1435096192, 1435925632, 1436754432, 1437584768, 1438415616, 1439246848,\n    1440078720, 1440910848, 1441742720, 1442575872, 1443409664, 1444243584,\n    1445078400, 1445912576, 1446748032, 1447584256, 1448420864, 1449257856,\n    1450094464, 1450932480, 1451771008, 1452609920, 1453449472, 1454289408,\n    1455128960, 1455969920, 1456811264, 1457653248, 1458495616, 1459337600,\n    1460180864, 1461024768, 1461869056, 1462713984, 1463558272, 1464404096,\n    1465250304, 1466097152, 1466944384, 1467792128, 1468639488, 1469488256,\n    1470337408, 1471187200, 1472037376, 1472887168, 1473738368, 1474589952,\n    1475442304, 1476294912, 1477148160, 1478000768, 1478854912, 1479709696,\n    1480564608, 1481420288, 1482275456, 1483132160, 1483989248, 1484846976,\n    1485704960, 1486562688, 1487421696, 1488281344, 1489141504, 1490002048,\n    1490863104, 1491723776, 1492585856, 1493448448, 1494311424, 1495175040,\n    1496038144, 1496902656, 1497767808, 1498633344, 1499499392, 1500365056,\n    1501232128, 1502099712, 1502967808, 1503836416, 1504705536, 1505574016,\n    1506444032, 1507314688, 1508185856, 1509057408, 1509928576, 1510801280,\n    1511674240, 1512547840, 1513421952, 1514295680, 1515170816, 1516046464,\n    1516922624, 1517799296, 1518676224, 1519552896, 1520431104, 1521309824,\n    1522188928, 1523068800, 1523948032, 1524828672, 1525709824, 1526591616,\n    1527473792, 1528355456, 1529238784, 1530122496, 1531006720, 1531891712,\n    1532776832, 1533661824, 1534547968, 1535434880, 1536322304, 1537210112,\n    1538097408, 1538986368, 1539875840, 1540765696, 1541656192, 1542547072,\n    1543437440, 1544329472, 1545221888, 1546114944, 1547008384, 1547901440,\n    1548796032, 1549691136, 1550586624, 1551482752, 1552378368, 1553275520,\n    1554173184, 1555071232, 1555970048, 1556869248, 1557767936, 1558668288,\n    1559568896, 1560470272, 1561372032, 1562273408, 1563176320, 1564079616,\n    1564983424, 1565888000, 1566791808, 1567697408, 1568603392, 1569509760,\n    1570416896, 1571324416, 1572231424, 1573140096, 1574049152, 1574958976,\n    1575869184, 1576778752, 1577689984, 1578601728, 1579514112, 1580426880,\n    1581339264, 1582253056, 1583167488, 1584082432, 1584997888, 1585913984,\n    1586829440, 1587746304, 1588663936, 1589582080, 1590500736, 1591418880,\n    1592338560, 1593258752, 1594179584, 1595100928, 1596021632, 1596944000,\n    1597866880, 1598790272, 1599714304, 1600638848, 1601562752, 1602488320,\n    1603414272, 1604340992, 1605268224, 1606194816, 1607123072, 1608051968,\n    1608981120, 1609911040, 1610841344, 1611771264, 1612702848, 1613634688,\n    1614567168, 1615500288, 1616432896, 1617367040, 1618301824, 1619237120,\n    1620172800, 1621108096, 1622044928, 1622982272, 1623920128, 1624858752,\n    1625797632, 1626736256, 1627676416, 1628616960, 1629558272, 1630499968,\n    1631441152, 1632384000, 1633327232, 1634271232, 1635215744, 1636159744,\n    1637105152, 1638051328, 1638998016, 1639945088, 1640892928, 1641840128,\n    1642788992, 1643738368, 1644688384, 1645638784, 1646588672, 1647540352,\n    1648492416, 1649445120, 1650398464, 1651351168, 1652305408, 1653260288,\n    1654215808, 1655171712, 1656128256, 1657084288, 1658041856, 1659000064,\n    1659958784, 1660918272, 1661876992, 1662837376, 1663798400, 1664759936,\n    1665721984, 1666683520, 1667646720, 1668610560, 1669574784, 1670539776,\n    1671505024, 1672470016, 1673436544, };\n\n\n#if 0 /* NOT NEEDED USES TOO MUCH CPU */\n\nvoid _WM_DynamicVolumeAdjust(struct _mdi *mdi, int32_t *tmp_buffer, uint32_t buffer_used) {\n\n    uint32_t i = 0;\n    uint32_t j = 0;\n\n    int8_t peak_set = 0;\n    int32_t prev_val = 0;\n    uint32_t peak_ofs = 0;\n    int32_t peak = mdi->dyn_vol_peak;\n\n    double volume_to_reach = mdi->dyn_vol_to_reach;\n    double volume = mdi->dyn_vol;\n    double volume_adjust = mdi->dyn_vol_adjust;\n    double tmp_output = 0.0;\n\n#define MAX_DYN_VOL 1.0\n\n    for (i = 0; i < buffer_used; i++) {\n        if ((i == 0) || (i > peak_ofs)) {\n            // Find Next Peak/Troff\n            peak_set = 0;\n            prev_val = peak;\n            peak_ofs = 0;\n            for (j = i; j < buffer_used; j++) {\n                if (peak_set == 0) {\n                    // find what direction the data is going\n                    if (prev_val > tmp_buffer[j]) {\n                        // Going Down\n                        peak_set = -1;\n                    } else if (prev_val < tmp_buffer[j]) {\n                        // Doing Up\n                        peak_set = 1;\n                    } else {\n                        // No direction, keep looking\n                        prev_val = tmp_buffer[j];\n                        continue;\n                    }\n                }\n\n                if (peak_set == 1) {\n                    // Data is going up\n                    if (peak < tmp_buffer[j]) {\n                        peak = tmp_buffer[j];\n                        peak_ofs = j;\n                    } else if (peak > tmp_buffer[j]) {\n                        // Data is starting to go down, we found the peak\n                        break;\n                    }\n                } else { // assume peak_set == -1\n                    // Data is going down\n                    if (peak > tmp_buffer[j]) {\n                        peak = tmp_buffer[j];\n                        peak_ofs = j;\n                    } else if (peak < tmp_buffer[j]) {\n                        // Data is starting to go up, we found the troff\n                        break;\n                    }\n                }\n\n                prev_val = tmp_buffer[j];\n            }\n\n            if (peak_set != 0) {\n                if (peak_set == 1) {\n                    if (peak > 32767) {\n                        volume_to_reach = 32767.0 / (double)peak;\n                    } else {\n                        volume_to_reach = MAX_DYN_VOL;\n                    }\n                } else { // assume peak_set == -1\n                    if (peak < -32768) {\n                        volume_to_reach = -32768.0 / (double)peak;\n                    } else {\n                        volume_to_reach = MAX_DYN_VOL;\n                    }\n                }\n            } else {\n                // No peak found, set volume we want to normal\n                volume_to_reach = MAX_DYN_VOL;\n            }\n\n            if (volume != volume_to_reach) {\n                if (volume_to_reach == MAX_DYN_VOL) {\n                    // if we want normal volume then adjust to it slower\n                    volume_adjust = (volume_to_reach - volume) / ((double)_WM_SampleRate * 0.1);\n                } else {\n                    // if we want to clamp the volume then adjust quickly\n                    volume_adjust = (volume_to_reach - volume) / ((double)_WM_SampleRate * 0.0001);\n                }\n            }\n        }\n\n        // First do we need to do volume adjustments\n        if ((volume_adjust != 0.0) && (volume != volume_to_reach)) {\n                volume += volume_adjust;\n                if (volume_adjust > 0.0) {\n                    // if increasing the volume\n                    if (volume >= MAX_DYN_VOL) {\n                        // we dont boost volume\n                        volume = MAX_DYN_VOL;\n                        volume_adjust = 0.0;\n                    } else if (volume > volume_to_reach) {\n                        // we dont want to go above the level we wanted\n                        volume = volume_to_reach;\n                        volume_adjust = 0.0;\n                    }\n                } else {\n                    // decreasing the volume\n                    if (volume < volume_to_reach) {\n                        // we dont want to go below the level we wanted\n                        volume = volume_to_reach;\n                        volume_adjust = 0.0;\n                    }\n                }\n            }\n\n        // adjust buffer volume\n        tmp_output = (double)tmp_buffer[i] * volume;\n        tmp_buffer[i] = (int32_t)tmp_output;\n    }\n\n    // store required values\n    mdi->dyn_vol_adjust = volume_adjust;\n    mdi->dyn_vol_peak = peak;\n    mdi->dyn_vol = volume;\n    mdi->dyn_vol_to_reach = volume_to_reach;\n}\n\n#endif\n\n/* Should be called in any function that effects note volumes */\nvoid _WM_AdjustNoteVolumes(struct _mdi *mdi, uint8_t ch, struct _note *nte) {\n    float premix_dBm;\n    float premix_lin;\n    uint8_t pan_ofs;\n    float premix_dBm_left;\n    float premix_dBm_right;\n    float premix_left;\n    float premix_right;\n    float volume_adj;\n    uint32_t vol_ofs;\n\n    /*\n     Pointless CPU heating checks to shoosh up a compiler\n     */\n    if (ch > 0x0f) ch = 0x0f;\n\n    if (nte->ignore_chan_events) return;\n\n    pan_ofs = mdi->channel[ch].balance + mdi->channel[ch].pan - 64;\n\n    vol_ofs = (nte->velocity * ((mdi->channel[ch].expression * mdi->channel[ch].volume) / 127)) / 127;\n\n    /*\n     This value is to reduce the chance of clipping.\n     Higher value means lower overall volume,\n     Lower value means higher overall volume.\n     NOTE: The lower the value the higher the chance of clipping.\n     FIXME: Still needs tuning. Clipping heard at a value of 3.75\n     */\n#define VOL_DIVISOR 4.0\n    volume_adj = ((float)_WM_MasterVolume / 1024.0) / VOL_DIVISOR;\n\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, 0);\n\n    if (pan_ofs > 127) pan_ofs = 127;\n    premix_dBm_left = dBm_pan_volume[(127-pan_ofs)];\n    premix_dBm_right = dBm_pan_volume[pan_ofs];\n\n    if (mdi->extra_info.mixer_options & WM_MO_LOG_VOLUME) {\n        premix_dBm = dBm_volume[vol_ofs];\n\n        premix_dBm_left += premix_dBm;\n        premix_dBm_right += premix_dBm;\n\n        premix_left = (powf(10.0,(premix_dBm_left / 20.0))) * volume_adj;\n        premix_right = (powf(10.0,(premix_dBm_right / 20.0))) * volume_adj;\n    } else {\n        premix_lin = (float)(_WM_lin_volume[vol_ofs]) / 1024.0;\n\n        premix_left = premix_lin * powf(10.0, (premix_dBm_left / 20)) * volume_adj;\n        premix_right = premix_lin * powf(10.0, (premix_dBm_right / 20)) * volume_adj;\n    }\n    nte->left_mix_volume = (int32_t)(premix_left * 1024.0);\n    nte->right_mix_volume = (int32_t)(premix_right * 1024.0);\n}\n\n/* Should be called in any function that effects channel volumes */\n/* Calling this function with a value > 15 will make it adjust notes on all channels */\nvoid _WM_AdjustChannelVolumes(struct _mdi *mdi, uint8_t ch) {\n    struct _note *nte = mdi->note;\n    if (nte != NULL) {\n        do {\n            if (ch <= 15) {\n                if ((nte->noteid >> 8) == ch) {\n                    goto _DO_ADJUST;\n                }\n            } else {\n            _DO_ADJUST:\n                if (!nte->ignore_chan_events) {\n                    _WM_AdjustNoteVolumes(mdi, ch, nte);\n                    if (nte->replay) _WM_AdjustNoteVolumes(mdi, ch, nte->replay);\n                }\n            }\n            nte = nte->next;\n        } while (nte != NULL);\n    }\n}\n\nfloat _WM_GetSamplesPerTick(uint32_t divisions, uint32_t tempo) {\n    float microseconds_per_tick;\n    float secs_per_tick;\n    float samples_per_tick;\n\n    /* Slow but needed for accuracy */\n    microseconds_per_tick = (float) tempo / (float) divisions;\n    secs_per_tick = microseconds_per_tick / 1000000.0f;\n    samples_per_tick = _WM_SampleRate * secs_per_tick;\n\n    return (samples_per_tick);\n}\n\nstatic void _WM_CheckEventMemoryPool(struct _mdi *mdi) {\n    if ((mdi->event_count + 1) >= mdi->events_size) {\n        mdi->events_size += MEM_CHUNK;\n        mdi->events = realloc(mdi->events,\n                              (mdi->events_size * sizeof(struct _event)));\n    }\n}\n\nvoid _WM_do_note_off_extra(struct _note *nte) {\n\n    MIDI_EVENT_DEBUG(__FUNCTION__,0, 0);\n    nte->is_off = 0;\n        {\n        if (!(nte->modes & SAMPLE_ENVELOPE)) {\n            if (nte->modes & SAMPLE_LOOP) {\n                nte->modes ^= SAMPLE_LOOP;\n            }\n            nte->env_inc = 0;\n\n        } else if (nte->hold) {\n            nte->hold |= HOLD_OFF;\n/*\n        } else if (nte->modes & SAMPLE_SUSTAIN) {\n            if (nte->env < 3) {\n                nte->env = 3;\n                if (nte->env_level > nte->sample->env_target[3]) {\n                    nte->env_inc = -nte->sample->env_rate[3];\n                } else {\n                    nte->env_inc = nte->sample->env_rate[3];\n                }\n            }\n*/\n        } else if (nte->modes & SAMPLE_CLAMPED) {\n            if (nte->env < 5) {\n                nte->env = 5;\n                if (nte->env_level > nte->sample->env_target[5]) {\n                    nte->env_inc = -nte->sample->env_rate[5];\n                } else {\n                    nte->env_inc = nte->sample->env_rate[5];\n                }\n            }\n        } else if (nte->env < 3) {\n            nte->env = 3;\n            if (nte->env_level > nte->sample->env_target[3]) {\n                nte->env_inc = -nte->sample->env_rate[3];\n            } else {\n                nte->env_inc = nte->sample->env_rate[3];\n            }\n        }\n    }\n}\n\n\nvoid _WM_do_midi_divisions(struct _mdi *mdi, struct _event_data *data) {\n    // placeholder function so we can record divisions in the event stream\n    // for conversion function _WM_Event2Midi()\n    UNUSED(mdi);\n    UNUSED(data);\n    return;\n}\n\nvoid _WM_do_note_off(struct _mdi *mdi, struct _event_data *data) {\n    struct _note *nte;\n    uint8_t ch = data->channel;\n\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n\n    nte = &mdi->note_table[0][ch][(data->data.value >> 8)];\n    if (!nte->active) {\n        nte = &mdi->note_table[1][ch][(data->data.value >> 8)];\n        if (!nte->active) {\n            return;\n        }\n    }\n\n    if ((mdi->channel[ch].isdrum) && (!(nte->modes & SAMPLE_LOOP))) {\n        return;\n    }\n\n    if ((nte->modes & SAMPLE_ENVELOPE) && (nte->env == 0)) {\n        // This is a fix for notes that end before the\n        // initial step of the envelope has completed\n        // making it impossible to hear them at times.\n        nte->is_off = 1;\n    } else {\n        _WM_do_note_off_extra(nte);\n    }\n}\n\nstatic inline uint32_t get_inc(struct _mdi *mdi, struct _note *nte) {\n    int ch = nte->noteid >> 8;\n    int32_t note_f;\n    uint32_t freq;\n\n    if (__builtin_expect((nte->patch->note != 0), 0)) {\n        note_f = nte->patch->note * 100;\n    } else {\n        note_f = (nte->noteid & 0x7f) * 100;\n    }\n    note_f += mdi->channel[ch].pitch_adjust;\n    if (__builtin_expect((note_f < 0), 0)) {\n        note_f = 0;\n    } else if (__builtin_expect((note_f > 12700), 0)) {\n        note_f = 12700;\n    }\n    freq = _WM_freq_table[(note_f % 1200)] >> (10 - (note_f / 1200));\n    return (((freq / ((_WM_SampleRate * 100) / 1024)) * 1024\n             / nte->sample->inc_div));\n}\n\nvoid _WM_do_note_on(struct _mdi *mdi, struct _event_data *data) {\n    struct _note *nte;\n    struct _note *prev_nte;\n    struct _note *nte_array;\n    uint32_t freq = 0;\n    struct _patch *patch;\n    struct _sample *sample;\n    uint8_t ch = data->channel;\n    uint8_t note = (data->data.value >> 8);\n    uint8_t velocity = (data->data.value & 0xFF);\n\n    if (velocity == 0x00) {\n        _WM_do_note_off(mdi, data);\n        return;\n    }\n\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n\n    if (!mdi->channel[ch].isdrum) {\n        patch = mdi->channel[ch].patch;\n        if (patch == NULL) {\n            return;\n        }\n        freq = _WM_freq_table[(note % 12) * 100] >> (10 - (note / 12));\n    } else {\n        patch = _WM_get_patch_data(mdi,\n                               ((mdi->channel[ch].bank << 8) | note | 0x80));\n        if (patch == NULL) {\n            return;\n        }\n        if (patch->note) {\n            freq = _WM_freq_table[(patch->note % 12) * 100]\n            >> (10 - (patch->note / 12));\n        } else {\n            freq = _WM_freq_table[(note % 12) * 100] >> (10 - (note / 12));\n        }\n    }\n\n    sample = _WM_get_sample_data(patch, (freq / 100));\n    if (sample == NULL) {\n        return;\n    }\n\n    nte = &mdi->note_table[0][ch][note];\n\n    if (nte->active) {\n        if ((nte->modes & SAMPLE_ENVELOPE) && (nte->env < 3)\n            && (!(nte->hold & HOLD_OFF)))\n            return;\n        nte->replay = &mdi->note_table[1][ch][note];\n        nte->env = 6;\n        nte->env_inc = -nte->sample->env_rate[6];\n        nte = nte->replay;\n    } else {\n        if (mdi->note_table[1][ch][note].active) {\n            if ((nte->modes & SAMPLE_ENVELOPE) && (nte->env < 3)\n                && (!(nte->hold & HOLD_OFF)))\n                return;\n            mdi->note_table[1][ch][note].replay = nte;\n            mdi->note_table[1][ch][note].env = 6;\n            mdi->note_table[1][ch][note].env_inc =\n            -mdi->note_table[1][ch][note].sample->env_rate[6];\n        } else {\n            nte_array = mdi->note;\n            if (nte_array == NULL) {\n                mdi->note = nte;\n            } else {\n                do {\n                    prev_nte = nte_array;\n                    nte_array = nte_array->next;\n                } while (nte_array);\n                prev_nte->next = nte;\n            }\n            nte->active = 1;\n            nte->next = NULL;\n        }\n    }\n    nte->noteid = (ch << 8) | note;\n    nte->patch = patch;\n    nte->sample = sample;\n    nte->sample_pos = 0;\n    nte->sample_inc = get_inc(mdi, nte);\n    nte->velocity = velocity;\n    nte->env = 0;\n    nte->env_inc = nte->sample->env_rate[0];\n    nte->env_level = 0;\n    nte->modes = sample->modes;\n    nte->hold = mdi->channel[ch].hold;\n    nte->replay = NULL;\n    nte->is_off = 0;\n    nte->ignore_chan_events = 0;\n    _WM_AdjustNoteVolumes(mdi, ch, nte);\n}\n\nvoid _WM_do_aftertouch(struct _mdi *mdi, struct _event_data *data) {\n    struct _note *nte;\n    uint8_t ch = data->channel;\n\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n\n    nte = &mdi->note_table[0][ch][(data->data.value >> 8)];\n    if (!nte->active) {\n        nte = &mdi->note_table[1][ch][(data->data.value >> 8)];\n        if (!nte->active) {\n            return;\n        }\n    }\n\n    nte->velocity = data->data.value & 0xff;\n    _WM_AdjustNoteVolumes(mdi, ch, nte);\n    if (nte->replay) {\n        nte->replay->velocity = data->data.value & 0xff;\n        _WM_AdjustNoteVolumes(mdi, ch, nte->replay);\n    }\n}\n\nvoid _WM_do_control_bank_select(struct _mdi *mdi, struct _event_data *data) {\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n    mdi->channel[ch].bank = data->data.value;\n}\n\nvoid _WM_do_control_data_entry_course(struct _mdi *mdi,\n                                         struct _event_data *data) {\n    uint8_t ch = data->channel;\n    int data_tmp;\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n\n    if ((mdi->channel[ch].reg_non == 0)\n        && (mdi->channel[ch].reg_data == 0x0000)) { /* Pitch Bend Range */\n        data_tmp = mdi->channel[ch].pitch_range % 100;\n        mdi->channel[ch].pitch_range = data->data.value * 100 + data_tmp;\n    /*  printf(\"Data Entry Course: pitch_range: %i\\n\\r\",mdi->channel[ch].pitch_range);*/\n    /*  printf(\"Data Entry Course: data %li\\n\\r\",data->data.value);*/\n    }\n}\n\nvoid _WM_do_control_channel_volume(struct _mdi *mdi,\n                                      struct _event_data *data) {\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n\n    mdi->channel[ch].volume = data->data.value;\n    _WM_AdjustChannelVolumes(mdi, ch);\n}\n\nvoid _WM_do_control_channel_balance(struct _mdi *mdi,\n                                       struct _event_data *data) {\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n\n    mdi->channel[ch].balance = data->data.value;\n    _WM_AdjustChannelVolumes(mdi, ch);\n}\n\nvoid _WM_do_control_channel_pan(struct _mdi *mdi, struct _event_data *data) {\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n\n    mdi->channel[ch].pan = data->data.value;\n    _WM_AdjustChannelVolumes(mdi, ch);\n}\n\nvoid _WM_do_control_channel_expression(struct _mdi *mdi,\n                                          struct _event_data *data) {\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n\n    mdi->channel[ch].expression = data->data.value;\n    _WM_AdjustChannelVolumes(mdi, ch);\n}\n\nvoid _WM_do_control_data_entry_fine(struct _mdi *mdi,\n                                       struct _event_data *data) {\n    uint8_t ch = data->channel;\n    int data_tmp;\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n\n    if ((mdi->channel[ch].reg_non == 0)\n      && (mdi->channel[ch].reg_data == 0x0000)) { /* Pitch Bend Range */\n        data_tmp = mdi->channel[ch].pitch_range / 100;\n        mdi->channel[ch].pitch_range = (data_tmp * 100) + data->data.value;\n    /*  printf(\"Data Entry Fine: pitch_range: %i\\n\\r\",mdi->channel[ch].pitch_range);*/\n    /*  printf(\"Data Entry Fine: data: %li\\n\\r\", data->data.value);*/\n    }\n}\n\nvoid _WM_do_control_channel_hold(struct _mdi *mdi, struct _event_data *data) {\n    struct _note *note_data = mdi->note;\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n\n    if (data->data.value > 63) {\n        mdi->channel[ch].hold = 1;\n    } else {\n        mdi->channel[ch].hold = 0;\n        if (note_data) {\n            do {\n                if ((note_data->noteid >> 8) == ch) {\n                    if (note_data->hold & HOLD_OFF) {\n                        if (note_data->modes & SAMPLE_ENVELOPE) {\n                            if (note_data->modes & SAMPLE_CLAMPED) {\n                                if (note_data->env < 5) {\n                                    note_data->env = 5;\n                                    if (note_data->env_level\n                                        > note_data->sample->env_target[5]) {\n                                        note_data->env_inc =\n                                        -note_data->sample->env_rate[5];\n                                    } else {\n                                        note_data->env_inc =\n                                        note_data->sample->env_rate[5];\n                                    }\n                                }\n                            /*\n                            } else if (note_data->modes & SAMPLE_SUSTAIN) {\n                                if (note_data->env < 3) {\n                                    note_data->env = 3;\n                                    if (note_data->env_level\n                                        > note_data->sample->env_target[3]) {\n                                        note_data->env_inc =\n                                        -note_data->sample->env_rate[3];\n                                    } else {\n                                        note_data->env_inc =\n                                        note_data->sample->env_rate[3];\n                                    }\n                                }\n                             */\n                             } else if (note_data->env < 3) {\n                                note_data->env = 3;\n                                if (note_data->env_level\n                                    > note_data->sample->env_target[3]) {\n                                    note_data->env_inc =\n                                    -note_data->sample->env_rate[3];\n                                } else {\n                                    note_data->env_inc =\n                                    note_data->sample->env_rate[3];\n                                }\n                            }\n                        } else {\n                            if (note_data->modes & SAMPLE_LOOP) {\n                                note_data->modes ^= SAMPLE_LOOP;\n                            }\n                            note_data->env_inc = 0;\n                        }\n                    }\n                    note_data->hold = 0x00;\n                }\n                note_data = note_data->next;\n            } while (note_data);\n        }\n    }\n}\n\nvoid _WM_do_control_data_increment(struct _mdi *mdi,\n                                      struct _event_data *data) {\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n\n    if ((mdi->channel[ch].reg_non == 0)\n        && (mdi->channel[ch].reg_data == 0x0000)) { /* Pitch Bend Range */\n        if (mdi->channel[ch].pitch_range < 0x3FFF)\n            mdi->channel[ch].pitch_range++;\n    }\n}\n\nvoid _WM_do_control_data_decrement(struct _mdi *mdi,\n                                      struct _event_data *data) {\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n\n    if ((mdi->channel[ch].reg_non == 0)\n        && (mdi->channel[ch].reg_data == 0x0000)) { /* Pitch Bend Range */\n        if (mdi->channel[ch].pitch_range > 0)\n            mdi->channel[ch].pitch_range--;\n    }\n}\nvoid _WM_do_control_non_registered_param_fine(struct _mdi *mdi,\n                                            struct _event_data *data) {\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n    mdi->channel[ch].reg_data = (mdi->channel[ch].reg_data & 0x3F80)\n                                | data->data.value;\n    mdi->channel[ch].reg_non = 1;\n}\n\nvoid _WM_do_control_non_registered_param_course(struct _mdi *mdi,\n                                     struct _event_data *data) {\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n    mdi->channel[ch].reg_data = (mdi->channel[ch].reg_data & 0x7F)\n                                | (data->data.value << 7);\n    mdi->channel[ch].reg_non = 1;\n}\n\nvoid _WM_do_control_registered_param_fine(struct _mdi *mdi,\n                                          struct _event_data *data) {\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n    mdi->channel[ch].reg_data = (mdi->channel[ch].reg_data & 0x3F80)\n                                | data->data.value;\n    mdi->channel[ch].reg_non = 0;\n}\n\nvoid _WM_do_control_registered_param_course(struct _mdi *mdi,\n                                            struct _event_data *data) {\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n    mdi->channel[ch].reg_data = (mdi->channel[ch].reg_data & 0x7F)\n                                | (data->data.value << 7);\n    mdi->channel[ch].reg_non = 0;\n}\n\nvoid _WM_do_control_channel_sound_off(struct _mdi *mdi,\n                                      struct _event_data *data) {\n    struct _note *note_data = mdi->note;\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n\n    if (note_data) {\n        do {\n            if ((note_data->noteid >> 8) == ch) {\n                note_data->active = 0;\n                if (note_data->replay) {\n                    note_data->replay = NULL;\n                }\n            }\n            note_data = note_data->next;\n        } while (note_data);\n    }\n}\n\nvoid _WM_do_control_channel_controllers_off(struct _mdi *mdi,\n                                            struct _event_data *data) {\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n\n    mdi->channel[ch].expression = 127;\n    mdi->channel[ch].pressure = 127;\n    mdi->channel[ch].reg_data = 0xffff;\n    mdi->channel[ch].pitch_range = 200;\n    mdi->channel[ch].pitch = 0;\n    mdi->channel[ch].pitch_adjust = 0;\n    mdi->channel[ch].hold = 0;\n\n    _WM_AdjustChannelVolumes(mdi, ch);\n}\n\nvoid _WM_do_control_channel_notes_off(struct _mdi *mdi,\n                                      struct _event_data *data) {\n    struct _note *note_data = mdi->note;\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n\n    if (mdi->channel[ch].isdrum)\n        return;\n    if (note_data) {\n        do {\n            if ((note_data->noteid >> 8) == ch) {\n                if (!note_data->hold) {\n                    if (note_data->modes & SAMPLE_ENVELOPE) {\n                        if (note_data->env < 5) {\n                            if (note_data->env_level\n                                > note_data->sample->env_target[5]) {\n                                note_data->env_inc =\n                                -note_data->sample->env_rate[5];\n                            } else {\n                                note_data->env_inc =\n                                note_data->sample->env_rate[5];\n                            }\n                            note_data->env = 5;\n                        }\n                    }\n                } else {\n                    note_data->hold |= HOLD_OFF;\n                }\n            }\n            note_data = note_data->next;\n        } while (note_data);\n    }\n}\n\nvoid _WM_do_control_dummy(struct _mdi *mdi, struct _event_data *data) {\n#ifdef DEBUG_MIDI\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__, ch, data->data.value);\n#else\n    UNUSED(data);\n#endif\n    UNUSED(mdi);\n}\n\nvoid _WM_do_patch(struct _mdi *mdi, struct _event_data *data) {\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n    if (!mdi->channel[ch].isdrum) {\n        mdi->channel[ch].patch = _WM_get_patch_data(mdi,\n                                                ((mdi->channel[ch].bank << 8) | data->data.value));\n    } else {\n        mdi->channel[ch].bank = data->data.value;\n    }\n}\n\nvoid _WM_do_channel_pressure(struct _mdi *mdi, struct _event_data *data) {\n    uint8_t ch = data->channel;\n    struct _note *note_data = mdi->note;\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n\n    mdi->channel[ch].pressure = data->data.value;\n\n    while (note_data) {\n        if (!note_data->ignore_chan_events) {\n            if ((note_data->noteid >> 8) == ch) {\n                note_data->velocity = data->data.value & 0xff;\n                _WM_AdjustNoteVolumes(mdi, ch, note_data);\n                if (note_data->replay) {\n                    note_data->replay->velocity = data->data.value & 0xff;\n                    _WM_AdjustNoteVolumes(mdi, ch, note_data->replay);\n                }\n            }\n        }\n        note_data = note_data->next;\n    }\n}\n\nvoid _WM_do_pitch(struct _mdi *mdi, struct _event_data *data) {\n    struct _note *note_data = mdi->note;\n    uint8_t ch = data->channel;\n\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n    mdi->channel[ch].pitch = data->data.value - 0x2000;\n\n    if (mdi->channel[ch].pitch < 0) {\n        mdi->channel[ch].pitch_adjust = mdi->channel[ch].pitch_range\n        * mdi->channel[ch].pitch / 8192;\n    } else {\n        mdi->channel[ch].pitch_adjust = mdi->channel[ch].pitch_range\n        * mdi->channel[ch].pitch / 8191;\n    }\n\n    if (note_data) {\n        do {\n            if ((note_data->noteid >> 8) == ch) {\n                note_data->sample_inc = get_inc(mdi, note_data);\n            }\n            note_data = note_data->next;\n        } while (note_data);\n    }\n}\n\nvoid _WM_do_sysex_roland_drum_track(struct _mdi *mdi, struct _event_data *data) {\n    uint8_t ch = data->channel;\n\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n\n    if (data->data.value > 0) {\n        mdi->channel[ch].isdrum = 1;\n        mdi->channel[ch].patch = NULL;\n    } else {\n        mdi->channel[ch].isdrum = 0;\n        mdi->channel[ch].patch = _WM_get_patch_data(mdi, 0);\n    }\n}\n\nvoid _WM_do_sysex_gm_reset(struct _mdi *mdi, struct _event_data *data) {\n    int i;\n\n    if (data != NULL) {\n        MIDI_EVENT_DEBUG(__FUNCTION__,data->channel, data->data.value);\n    } else {\n        MIDI_EVENT_DEBUG(__FUNCTION__,0, 0);\n    }\n\n    for (i = 0; i < 16; i++) {\n        mdi->channel[i].bank = 0;\n        if (i != 9) {\n            mdi->channel[i].patch = _WM_get_patch_data(mdi, 0);\n        } else {\n            mdi->channel[i].patch = NULL;\n        }\n        mdi->channel[i].hold = 0;\n        mdi->channel[i].volume = 100;\n        mdi->channel[i].pressure = 127;\n        mdi->channel[i].expression = 127;\n        mdi->channel[i].balance = 64;\n        mdi->channel[i].pan = 64;\n        mdi->channel[i].pitch = 0;\n        mdi->channel[i].pitch_range = 200;\n        mdi->channel[i].reg_data = 0xFFFF;\n        mdi->channel[i].isdrum = 0;\n    }\n    /* I would not expect notes to be active when this event\n     triggers but we'll adjust active notes as well just in case */\n    _WM_AdjustChannelVolumes(mdi,16); // A setting > 15 adjusts all channels\n\n    mdi->channel[9].isdrum = 1;\n}\n\nvoid _WM_do_sysex_roland_reset(struct _mdi *mdi, struct _event_data *data) {\n#ifdef DEBUG_MIDI\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__, ch, data->data.value);\n#else\n    UNUSED(data);\n#endif\n    _WM_do_sysex_gm_reset(mdi,data);\n}\n\nvoid _WM_do_sysex_yamaha_reset(struct _mdi *mdi, struct _event_data *data) {\n#ifdef DEBUG_MIDI\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__, ch, data->data.value);\n#else\n    UNUSED(data);\n#endif\n    _WM_do_sysex_gm_reset(mdi,data);\n}\n\nvoid _WM_Release_Allowance(struct _mdi *mdi) {\n    uint32_t release = 0;\n    uint32_t longest_release = 0;\n    \n    struct _note *note = mdi->note;\n    \n    while (note != NULL) {\n        \n        if (note->modes & SAMPLE_ENVELOPE) {\n            //ensure envelope isin a release state\n            if (note->env < 4) {\n                note->env = 4;\n            }\n        \n            // make sure this is set\n            note->env_inc = -note->sample->env_rate[note->env];\n        \n            release = note->env_level / -note->env_inc;\n        } else {\n            // Sample release\n            if (note->modes & SAMPLE_LOOP) {\n                note->modes ^= SAMPLE_LOOP;\n            }\n            release = note->sample->data_length - note->sample_pos;\n        }\n        \n        if (release > longest_release) longest_release = release;\n        note->replay = NULL;\n        note = note->next;\n    }\n    \n    mdi->samples_to_mix = longest_release;\n    \n    return;\n}\n\nvoid _WM_do_meta_endoftrack(struct _mdi *mdi, struct _event_data *data) {\n/* placeholder function so we can record eot in the event stream\n * for conversion function _WM_Event2Midi */\n#ifdef DEBUG_MIDI\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__, ch, data->data.value);\n#else\n    UNUSED(data);\n#endif\n\n    _WM_Release_Allowance(mdi);\n    return;\n}\n\nvoid _WM_do_meta_tempo(struct _mdi *mdi, struct _event_data *data) {\n/* placeholder function so we can record tempo in the event stream\n * for conversion function _WM_Event2Midi */\n#ifdef DEBUG_MIDI\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__, ch, data->data.value);\n#else\n    UNUSED(data);\n#endif\n    UNUSED(mdi);\n    return;\n}\n\nvoid _WM_do_meta_timesignature(struct _mdi *mdi, struct _event_data *data) {\n/* placeholder function so we can record tempo in the event stream\n * for conversion function _WM_Event2Midi */\n#ifdef DEBUG_MIDI\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__, ch, data->data.value);\n#else\n    UNUSED(data);\n#endif\n    UNUSED(mdi);\n    return;\n}\n\nvoid _WM_do_meta_keysignature(struct _mdi *mdi, struct _event_data *data) {\n/* placeholder function so we can record tempo in the event stream\n * for conversion function _WM_Event2Midi */\n#ifdef DEBUG_MIDI\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__, ch, data->data.value);\n#else\n    UNUSED(data);\n#endif\n    UNUSED(mdi);\n    return;\n}\n\nvoid _WM_do_meta_sequenceno(struct _mdi *mdi, struct _event_data *data) {\n/* placeholder function so we can record tempo in the event stream\n * for conversion function _WM_Event2Midi */\n#ifdef DEBUG_MIDI\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__, ch, data->data.value);\n#else\n    UNUSED(data);\n#endif\n    UNUSED(mdi);\n    return;\n}\n\nvoid _WM_do_meta_channelprefix(struct _mdi *mdi, struct _event_data *data) {\n/* placeholder function so we can record tempo in the event stream\n * for conversion function _WM_Event2Midi */\n#ifdef DEBUG_MIDI\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__, ch, data->data.value);\n#else\n    UNUSED(data);\n#endif\n    UNUSED(mdi);\n    return;\n}\n\nvoid _WM_do_meta_portprefix(struct _mdi *mdi, struct _event_data *data) {\n/* placeholder function so we can record tempo in the event stream\n * for conversion function _WM_Event2Midi */\n#ifdef DEBUG_MIDI\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__, ch, data->data.value);\n#else\n    UNUSED(data);\n#endif\n    UNUSED(mdi);\n    return;\n}\n\nvoid _WM_do_meta_smpteoffset(struct _mdi *mdi, struct _event_data *data) {\n/* placeholder function so we can record tempo in the event stream\n * for conversion function _WM_Event2Midi */\n#ifdef DEBUG_MIDI\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__, ch, data->data.value);\n#else\n    UNUSED(data);\n#endif\n    UNUSED(mdi);\n    return;\n}\n\nvoid _WM_do_meta_text(struct _mdi *mdi, struct _event_data *data) {\n/* placeholder function so we can record tempo in the event stream\n * for conversion function _WM_Event2Midi */\n#ifdef DEBUG_MIDI\n    uint8_t ch = data->channel;\n    MIDI_EVENT_SDEBUG(__FUNCTION__, ch, data->data.string);\n#endif\n    if (mdi->extra_info.mixer_options & WM_MO_TEXTASLYRIC) {\n        mdi->lyric = data->data.string;\n    }\n\n    return;\n}\n\nvoid _WM_do_meta_copyright(struct _mdi *mdi, struct _event_data *data) {\n/* placeholder function so we can record tempo in the event stream\n * for conversion function _WM_Event2Midi */\n#ifdef DEBUG_MIDI\n    uint8_t ch = data->channel;\n    MIDI_EVENT_SDEBUG(__FUNCTION__, ch, data->data.string);\n#else\n    UNUSED(data);\n#endif\n    UNUSED(mdi);\n    return;\n}\n\nvoid _WM_do_meta_trackname(struct _mdi *mdi, struct _event_data *data) {\n/* placeholder function so we can record tempo in the event stream\n * for conversion function _WM_Event2Midi */\n#ifdef DEBUG_MIDI\n    uint8_t ch = data->channel;\n    MIDI_EVENT_SDEBUG(__FUNCTION__, ch, data->data.string);\n#else\n    UNUSED(data);\n#endif\n    UNUSED(mdi);\n    return;\n}\n\nvoid _WM_do_meta_instrumentname(struct _mdi *mdi, struct _event_data *data) {\n/* placeholder function so we can record tempo in the event stream\n * for conversion function _WM_Event2Midi */\n#ifdef DEBUG_MIDI\n    uint8_t ch = data->channel;\n    MIDI_EVENT_SDEBUG(__FUNCTION__, ch, data->data.string);\n#else\n    UNUSED(data);\n#endif\n    UNUSED(mdi);\n    return;\n}\n\nvoid _WM_do_meta_lyric(struct _mdi *mdi, struct _event_data *data) {\n/* placeholder function so we can record tempo in the event stream\n * for conversion function _WM_Event2Midi */\n#ifdef DEBUG_MIDI\n    uint8_t ch = data->channel;\n    MIDI_EVENT_SDEBUG(__FUNCTION__, ch, data->data.string);\n#endif\n    if (!(mdi->extra_info.mixer_options & WM_MO_TEXTASLYRIC)) {\n        mdi->lyric = data->data.string;\n    }\n    return;\n}\n\nvoid _WM_do_meta_marker(struct _mdi *mdi, struct _event_data *data) {\n/* placeholder function so we can record tempo in the event stream\n * for conversion function _WM_Event2Midi */\n#ifdef DEBUG_MIDI\n    uint8_t ch = data->channel;\n    MIDI_EVENT_SDEBUG(__FUNCTION__, ch, data->data.string);\n#else\n    UNUSED(data);\n#endif\n    UNUSED(mdi);\n    return;\n}\n\nvoid _WM_do_meta_cuepoint(struct _mdi *mdi, struct _event_data *data) {\n/* placeholder function so we can record tempo in the event stream\n * for conversion function _WM_Event2Midi */\n#ifdef DEBUG_MIDI\n    uint8_t ch = data->channel;\n    MIDI_EVENT_SDEBUG(__FUNCTION__, ch, data->data.string);\n#else\n    UNUSED(data);\n#endif\n    UNUSED(mdi);\n    return;\n}\n\nvoid _WM_ResetToStart(struct _mdi *mdi) {\n    struct _event * event = NULL;\n\n    mdi->current_event = mdi->events;\n    mdi->samples_to_mix = 0;\n    mdi->extra_info.current_sample = 0;\n\n    _WM_do_sysex_gm_reset(mdi, NULL);\n\n    /* Ensure last event is NULL */\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = NULL;\n    mdi->events[mdi->event_count].event_data.channel = 0;\n    mdi->events[mdi->event_count].event_data.data.value = 0;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n\n    if (_WM_MixerOptions & WM_MO_STRIPSILENCE) {\n        event = mdi->events;\n        /* Scan for first note on removing any samples as we go */\n        if (event->do_event != *_WM_do_note_on) {\n            do {\n                if (event->samples_to_next != 0) {\n                    mdi->extra_info.approx_total_samples -= event->samples_to_next;\n                    event->samples_to_next = 0;\n                }\n                event++;\n                if (event == NULL) break;\n            } while (event->do_event != *_WM_do_note_on);\n        }\n\n        /* Reverse scan for last note off removing any samples as we go */\n        event = &mdi->events[mdi->event_count - 1];\n        if (event->do_event != *_WM_do_note_off) {\n            do {\n                mdi->extra_info.approx_total_samples -= event->samples_to_next;\n                event->samples_to_next = 0;\n                if (event == mdi->events) break; /* just to be safe */\n                event--;\n            } while (event->do_event != *_WM_do_note_off);\n        }\n        mdi->extra_info.approx_total_samples -= event->samples_to_next;\n        event->samples_to_next = 0;\n    }\n}\n\nint _WM_midi_setup_divisions(struct _mdi *mdi, uint32_t divisions) {\n    MIDI_EVENT_DEBUG(__FUNCTION__,0,0);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_midi_divisions;\n    mdi->events[mdi->event_count].event_data.channel = 0;\n    mdi->events[mdi->event_count].event_data.data.value = divisions;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}\n\nint _WM_midi_setup_noteoff(struct _mdi *mdi, uint8_t channel,\n                           uint8_t note, uint8_t velocity) {\n    MIDI_EVENT_DEBUG(__FUNCTION__,channel, note);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_note_off;\n    mdi->events[mdi->event_count].event_data.channel = channel;\n    mdi->events[mdi->event_count].event_data.data.value = (note << 8) | velocity;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}\n\nstatic int midi_setup_noteon(struct _mdi *mdi, uint8_t channel,\n                             uint8_t note, uint8_t velocity) {\n    MIDI_EVENT_DEBUG(__FUNCTION__,channel, note);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_note_on;\n    mdi->events[mdi->event_count].event_data.channel = channel;\n    mdi->events[mdi->event_count].event_data.data.value = (note << 8) | velocity;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n\n    if (mdi->channel[channel].isdrum)\n        _WM_load_patch(mdi, ((mdi->channel[channel].bank << 8) | (note | 0x80)));\n    return (0);\n}\n\nstatic int midi_setup_aftertouch(struct _mdi *mdi, uint8_t channel,\n                                 uint8_t note, uint8_t pressure) {\n    MIDI_EVENT_DEBUG(__FUNCTION__,channel, note);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_aftertouch;\n    mdi->events[mdi->event_count].event_data.channel = channel;\n    mdi->events[mdi->event_count].event_data.data.value = (note << 8) | pressure;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}\n\nstatic int midi_setup_control(struct _mdi *mdi, uint8_t channel,\n                              uint8_t controller, uint8_t setting) {\n    void (*tmp_event)(struct _mdi *mdi, struct _event_data *data) = NULL;\n    MIDI_EVENT_DEBUG(__FUNCTION__,channel, controller);\n\n    switch (controller) {\n        /*\n         **********************************************************************\n         FIXME: Need to add dummy events for MIDI events we don't support.\n         There is no reason not to store unsupported events in light of our\n         out to midi option.\n         **********************************************************************\n         */\n        case 0:\n            tmp_event = *_WM_do_control_bank_select;\n            mdi->channel[channel].bank = setting;\n            break;\n        case 6:\n            tmp_event = *_WM_do_control_data_entry_course;\n            break;\n        case 7:\n            tmp_event = *_WM_do_control_channel_volume;\n            mdi->channel[channel].volume = setting;\n            break;\n        case 8:\n            tmp_event = *_WM_do_control_channel_balance;\n            break;\n        case 10:\n            tmp_event = *_WM_do_control_channel_pan;\n            break;\n        case 11:\n            tmp_event = *_WM_do_control_channel_expression;\n            break;\n        case 38:\n            tmp_event = *_WM_do_control_data_entry_fine;\n            break;\n        case 64:\n            tmp_event = *_WM_do_control_channel_hold;\n            break;\n        case 96:\n            tmp_event = *_WM_do_control_data_increment;\n            break;\n        case 97:\n            tmp_event = *_WM_do_control_data_decrement;\n            break;\n        case 98:\n            tmp_event = *_WM_do_control_non_registered_param_fine;\n            break;\n        case 99:\n            tmp_event = *_WM_do_control_non_registered_param_course;\n            break;\n        case 100:\n            tmp_event = *_WM_do_control_registered_param_fine;\n            break;\n        case 101:\n            tmp_event = *_WM_do_control_registered_param_course;\n            break;\n        case 120:\n            tmp_event = *_WM_do_control_channel_sound_off;\n            break;\n        case 121:\n            tmp_event = *_WM_do_control_channel_controllers_off;\n            break;\n        case 123:\n            tmp_event = *_WM_do_control_channel_notes_off;\n            break;\n        default:\n            tmp_event = *_WM_do_control_dummy;\n            break;\n    }\n\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = tmp_event;\n    mdi->events[mdi->event_count].event_data.channel = channel;\n    if (tmp_event != *_WM_do_control_dummy) {\n        mdi->events[mdi->event_count].event_data.data.value = setting;\n    } else {\n        mdi->events[mdi->event_count].event_data.data.value = (controller << 8) | setting;\n    }\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}\n\nstatic int midi_setup_patch(struct _mdi *mdi, uint8_t channel, uint8_t patch) {\n    MIDI_EVENT_DEBUG(__FUNCTION__,channel, patch);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_patch;\n    mdi->events[mdi->event_count].event_data.channel = channel;\n    mdi->events[mdi->event_count].event_data.data.value = patch;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n\n    if (mdi->channel[channel].isdrum) {\n        mdi->channel[channel].bank = patch;\n    } else {\n        _WM_load_patch(mdi, ((mdi->channel[channel].bank << 8) | patch));\n        mdi->channel[channel].patch = _WM_get_patch_data(mdi,\n                                                     ((mdi->channel[channel].bank << 8) | patch));\n    }\n    return (0);\n}\n\nstatic int midi_setup_channel_pressure(struct _mdi *mdi, uint8_t channel,\n                                       uint8_t pressure) {\n    MIDI_EVENT_DEBUG(__FUNCTION__,channel, pressure);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_channel_pressure;\n    mdi->events[mdi->event_count].event_data.channel = channel;\n    mdi->events[mdi->event_count].event_data.data.value = pressure;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}\n\nstatic int midi_setup_pitch(struct _mdi *mdi, uint8_t channel, uint16_t pitch) {\n    MIDI_EVENT_DEBUG(__FUNCTION__,channel, pitch);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_pitch;\n    mdi->events[mdi->event_count].event_data.channel = channel;\n    mdi->events[mdi->event_count].event_data.data.value = pitch;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}\n\nstatic int midi_setup_sysex_roland_drum_track(struct _mdi *mdi,\n                                              uint8_t channel, uint16_t setting) {\n    MIDI_EVENT_DEBUG(__FUNCTION__,channel, setting);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = _WM_do_sysex_roland_drum_track;\n    mdi->events[mdi->event_count].event_data.channel = channel;\n    mdi->events[mdi->event_count].event_data.data.value = setting;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n\n    if (setting > 0) {\n        mdi->channel[channel].isdrum = 1;\n    } else {\n        mdi->channel[channel].isdrum = 0;\n    }\n    return (0);\n}\n\nstatic int midi_setup_sysex_gm_reset(struct _mdi *mdi) {\n    MIDI_EVENT_DEBUG(__FUNCTION__,0,0);\n\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_sysex_roland_reset;\n    mdi->events[mdi->event_count].event_data.channel = 0;\n    mdi->events[mdi->event_count].event_data.data.value = 0;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}\n\nstatic int midi_setup_sysex_roland_reset(struct _mdi *mdi) {\n    MIDI_EVENT_DEBUG(__FUNCTION__,0,0);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_sysex_roland_reset;\n    mdi->events[mdi->event_count].event_data.channel = 0;\n    mdi->events[mdi->event_count].event_data.data.value = 0;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}\n\nstatic int midi_setup_sysex_yamaha_reset(struct _mdi *mdi) {\n    MIDI_EVENT_DEBUG(__FUNCTION__,0,0);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_sysex_roland_reset;\n    mdi->events[mdi->event_count].event_data.channel = 0;\n    mdi->events[mdi->event_count].event_data.data.value = 0;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}\n\nint _WM_midi_setup_endoftrack(struct _mdi *mdi) {\n    MIDI_EVENT_DEBUG(__FUNCTION__,0,0);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_meta_endoftrack;\n    mdi->events[mdi->event_count].event_data.channel = 0;\n    mdi->events[mdi->event_count].event_data.data.value = 0;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}\n\nint _WM_midi_setup_tempo(struct _mdi *mdi, uint32_t setting) {\n    MIDI_EVENT_DEBUG(__FUNCTION__,0,setting);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_meta_tempo;\n    mdi->events[mdi->event_count].event_data.channel = 0;\n    mdi->events[mdi->event_count].event_data.data.value = setting;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}\n\nstatic int midi_setup_timesignature(struct _mdi *mdi, uint32_t setting) {\n    MIDI_EVENT_DEBUG(__FUNCTION__,0, setting);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_meta_timesignature;\n    mdi->events[mdi->event_count].event_data.channel = 0;\n    mdi->events[mdi->event_count].event_data.data.value = setting;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}\n\nstatic int midi_setup_keysignature(struct _mdi *mdi, uint32_t setting) {\n    MIDI_EVENT_DEBUG(__FUNCTION__,0, setting);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_meta_keysignature;\n    mdi->events[mdi->event_count].event_data.channel = 0;\n    mdi->events[mdi->event_count].event_data.data.value = setting;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}\n\nstatic int midi_setup_sequenceno(struct _mdi *mdi, uint32_t setting) {\n    MIDI_EVENT_DEBUG(__FUNCTION__,0, setting);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_meta_sequenceno;\n    mdi->events[mdi->event_count].event_data.channel = 0;\n    mdi->events[mdi->event_count].event_data.data.value = setting;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}\n\nstatic int midi_setup_channelprefix(struct _mdi *mdi, uint32_t setting) {\n    MIDI_EVENT_DEBUG(__FUNCTION__,0, setting);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_meta_channelprefix;\n    mdi->events[mdi->event_count].event_data.channel = 0;\n    mdi->events[mdi->event_count].event_data.data.value = setting;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}\n\nstatic int midi_setup_portprefix(struct _mdi *mdi, uint32_t setting) {\n    MIDI_EVENT_DEBUG(__FUNCTION__,0, setting);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_meta_portprefix;\n    mdi->events[mdi->event_count].event_data.channel = 0;\n    mdi->events[mdi->event_count].event_data.data.value = setting;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}\n\nstatic int midi_setup_smpteoffset(struct _mdi *mdi, uint32_t setting) {\n    MIDI_EVENT_DEBUG(__FUNCTION__,0, setting);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_meta_smpteoffset;\n    mdi->events[mdi->event_count].event_data.channel = 0;\n    mdi->events[mdi->event_count].event_data.data.value = setting;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}\n\nstatic void strip_text(char * text) {\n    char * ch_loc = NULL;\n\n    ch_loc = strrchr(text, '\\n');\n    while (ch_loc != NULL) {\n        *ch_loc = ' ';\n        ch_loc = strrchr(text, '\\n');\n    }\n    ch_loc = strrchr(text, '\\r');\n    while (ch_loc != NULL) {\n        *ch_loc = ' ';\n        ch_loc = strrchr(text, '\\r');\n    }\n}\n\nstatic int midi_setup_text(struct _mdi *mdi, char * text) {\n    MIDI_EVENT_SDEBUG(__FUNCTION__,0, text);\n    strip_text(text);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_meta_text;\n    mdi->events[mdi->event_count].event_data.channel = 0;\n    mdi->events[mdi->event_count].event_data.data.string = text;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}\n\nstatic int midi_setup_copyright(struct _mdi *mdi, char * text) {\n    MIDI_EVENT_SDEBUG(__FUNCTION__,0, text);\n    strip_text(text);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_meta_copyright;\n    mdi->events[mdi->event_count].event_data.channel = 0;\n    mdi->events[mdi->event_count].event_data.data.string = text;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}\n\nstatic int midi_setup_trackname(struct _mdi *mdi, char * text) {\n    MIDI_EVENT_SDEBUG(__FUNCTION__,0, text);\n    strip_text(text);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_meta_trackname;\n    mdi->events[mdi->event_count].event_data.channel = 0;\n    mdi->events[mdi->event_count].event_data.data.string = text;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}\n\nstatic int midi_setup_instrumentname(struct _mdi *mdi, char * text) {\n    MIDI_EVENT_SDEBUG(__FUNCTION__,0, text);\n    strip_text(text);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_meta_instrumentname;\n    mdi->events[mdi->event_count].event_data.channel = 0;\n    mdi->events[mdi->event_count].event_data.data.string = text;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}\n\nstatic int midi_setup_lyric(struct _mdi *mdi, char * text) {\n    MIDI_EVENT_SDEBUG(__FUNCTION__,0, text);\n    strip_text(text);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_meta_lyric;\n    mdi->events[mdi->event_count].event_data.channel = 0;\n    mdi->events[mdi->event_count].event_data.data.string = text;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}\n\nstatic int midi_setup_marker(struct _mdi *mdi, char * text) {\n    MIDI_EVENT_SDEBUG(__FUNCTION__,0, text);\n    strip_text(text);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_meta_marker;\n    mdi->events[mdi->event_count].event_data.channel = 0;\n    mdi->events[mdi->event_count].event_data.data.string = text;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}\n\nstatic int midi_setup_cuepoint(struct _mdi *mdi, char * text) {\n    MIDI_EVENT_SDEBUG(__FUNCTION__,0, text);\n    strip_text(text);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_meta_cuepoint;\n    mdi->events[mdi->event_count].event_data.channel = 0;\n    mdi->events[mdi->event_count].event_data.data.string = text;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}\n\nstruct _mdi *\n_WM_initMDI(void) {\n    struct _mdi *mdi;\n\n    mdi = malloc(sizeof(struct _mdi));\n    memset(mdi, 0, (sizeof(struct _mdi)));\n\n    mdi->extra_info.copyright = NULL;\n    mdi->extra_info.mixer_options = _WM_MixerOptions;\n\n    _WM_load_patch(mdi, 0x0000);\n\n    mdi->events_size = MEM_CHUNK;\n    mdi->events = malloc(mdi->events_size * sizeof(struct _event));\n    mdi->event_count = 0;\n    mdi->current_event = mdi->events;\n\n    mdi->samples_to_mix = 0;\n    mdi->extra_info.current_sample = 0;\n    mdi->extra_info.total_midi_time = 0;\n    mdi->extra_info.approx_total_samples = 0;\n\n    mdi->dyn_vol = 1.0;\n    mdi->dyn_vol_adjust = 0.0;\n    mdi->dyn_vol_peak = 0;\n    mdi->dyn_vol_to_reach = 1.0;\n\n    mdi->is_type2 = 0;\n\n    mdi->lyric = NULL;\n\n    _WM_do_sysex_gm_reset(mdi, NULL);\n\n    return (mdi);\n}\n\nvoid _WM_freeMDI(struct _mdi *mdi) {\n    struct _sample *tmp_sample;\n    uint32_t i;\n\n    if (mdi->patch_count != 0) {\n        _WM_Lock(&_WM_patch_lock);\n        for (i = 0; i < mdi->patch_count; i++) {\n            mdi->patches[i]->inuse_count--;\n            if (mdi->patches[i]->inuse_count == 0) {\n                /* free samples here */\n                while (mdi->patches[i]->first_sample) {\n                    tmp_sample = mdi->patches[i]->first_sample->next;\n                    free(mdi->patches[i]->first_sample->data);\n                    free(mdi->patches[i]->first_sample);\n                    mdi->patches[i]->first_sample = tmp_sample;\n                }\n                mdi->patches[i]->loaded = 0;\n            }\n        }\n        _WM_Unlock(&_WM_patch_lock);\n        free(mdi->patches);\n    }\n\n    if (mdi->event_count != 0) {\n        for (i = 0; i < mdi->event_count; i++) {\n            /* Free up the string event storage */\n            if (mdi->events[i].do_event == _WM_do_meta_text) {\n                free(mdi->events[i].event_data.data.string);\n            } else if (mdi->events[i].do_event == _WM_do_meta_text) {\n                free(mdi->events[i].event_data.data.string);\n            } else if (mdi->events[i].do_event == _WM_do_meta_copyright) {\n                free(mdi->events[i].event_data.data.string);\n            } else if (mdi->events[i].do_event == _WM_do_meta_trackname) {\n                free(mdi->events[i].event_data.data.string);\n            } else if (mdi->events[i].do_event == _WM_do_meta_instrumentname) {\n                free(mdi->events[i].event_data.data.string);\n            } else if (mdi->events[i].do_event == _WM_do_meta_lyric) {\n                free(mdi->events[i].event_data.data.string);\n            } else if (mdi->events[i].do_event == _WM_do_meta_marker) {\n                free(mdi->events[i].event_data.data.string);\n            } else if (mdi->events[i].do_event == _WM_do_meta_cuepoint) {\n                free(mdi->events[i].event_data.data.string);\n            }\n        }\n    }\n\n    free(mdi->events);\n    _WM_free_reverb(mdi->reverb);\n    free(mdi->mix_buffer);\n    free(mdi);\n}\n\nuint32_t _WM_SetupMidiEvent(struct _mdi *mdi, uint8_t * event_data, uint32_t siz, uint8_t running_event) {\n    /*\n     Only add standard MIDI and Sysex events in here.\n     Non-standard events need to be handled by calling function\n     to avoid compatibility issues.\n\n     TODO:\n     Add value limit checks\n     */\n    uint32_t ret_cnt = 0;\n    uint8_t command = 0;\n    uint8_t channel = 0;\n    uint8_t data_1 = 0;\n    uint8_t data_2 = 0;\n    char *text = NULL;\n\n    if (!siz) goto shortbuf;\n\n    if (event_data[0] >= 0x80) {\n        command = *event_data & 0xf0;\n        channel = *event_data++ & 0x0f;\n        ret_cnt++;\n        if (--siz == 0) goto shortbuf;\n    } else {\n        command = running_event & 0xf0;\n        channel = running_event & 0x0f;\n    }\n\n    switch(command) {\n        case 0x80:\n        _SETUP_NOTEOFF:\n            if (siz < 2) goto shortbuf;\n            data_1 = *event_data++;\n            data_2 = *event_data++;\n            _WM_midi_setup_noteoff(mdi, channel, data_1, data_2);\n            ret_cnt += 2;\n            break;\n        case 0x90:\n            if (event_data[1] == 0) goto _SETUP_NOTEOFF; /* A velocity of 0 in a note on is actually a note off */\n            if (siz < 2) goto shortbuf;\n            data_1 = *event_data++;\n            data_2 = *event_data++;\n            midi_setup_noteon(mdi, channel, data_1, data_2);\n            ret_cnt += 2;\n            break;\n        case 0xa0:\n            if (siz < 2) goto shortbuf;\n            data_1 = *event_data++;\n            data_2 = *event_data++;\n            midi_setup_aftertouch(mdi, channel, data_1, data_2);\n            ret_cnt += 2;\n            break;\n        case 0xb0:\n            if (siz < 2) goto shortbuf;\n            data_1 = *event_data++;\n            data_2 = *event_data++;\n            midi_setup_control(mdi, channel, data_1, data_2);\n            ret_cnt += 2;\n            break;\n        case 0xc0:\n            data_1 = *event_data++;\n            midi_setup_patch(mdi, channel, data_1);\n            ret_cnt++;\n            break;\n        case 0xd0:\n            data_1 = *event_data++;\n            midi_setup_channel_pressure(mdi, channel, data_1);\n            ret_cnt++;\n            break;\n        case 0xe0:\n            if (siz < 2) goto shortbuf;\n            data_1 = *event_data++;\n            data_2 = *event_data++;\n            midi_setup_pitch(mdi, channel, ((data_2 << 7) | (data_1 & 0x7f)));\n            ret_cnt += 2;\n            break;\n        case 0xf0:\n            if (channel == 0x0f) {\n                /*\n                 MIDI Meta Events\n                 */\n                uint32_t tmp_length = 0;\n                if ((event_data[0] == 0x00) && (event_data[1] == 0x02)) {\n                    /*\n                     Sequence Number\n                     We only setting this up here for WM_Event2Midi function\n                     */\n                    if (siz < 4) goto shortbuf;\n                    midi_setup_sequenceno(mdi, ((event_data[2] << 8) + event_data[3]));\n                    ret_cnt += 4;\n                } else if (event_data[0] == 0x01) {\n                    /* Text Event */\n                    /* Get Length */\n                    event_data++;\n                    ret_cnt++;\n                    if (--siz && *event_data > 0x7f) {\n                        do {\n                            if (!siz) break;\n                            tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                            event_data++;\n                            siz--;\n                            ret_cnt++;\n                        } while (*event_data > 0x7f);\n                    }\n                    if (!siz) goto shortbuf;\n                    tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                    event_data++;\n                    ret_cnt++;\n                    if (--siz < tmp_length) goto shortbuf;\n                    if (!tmp_length) break; /* bad file? */\n\n                    text = malloc(tmp_length + 1);\n                    memcpy(text, event_data, tmp_length);\n                    text[tmp_length] = '\\0';\n                    midi_setup_text(mdi, text);\n\n                    ret_cnt += tmp_length;\n\n                } else if (event_data[0] == 0x02) {\n                    /* Copyright Event */\n                    /* Get Length */\n                    event_data++;\n                    ret_cnt++;\n                    if (--siz && *event_data > 0x7f) {\n                        do {\n                            if (!siz) break;\n                            tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                            event_data++;\n                            siz--;\n                            ret_cnt++;\n                        } while (*event_data > 0x7f);\n                    }\n                    if (!siz) goto shortbuf;\n                    tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                    event_data++;\n                    ret_cnt++;\n                    if (--siz < tmp_length) goto shortbuf;\n                    if (!tmp_length) break; /* bad file? */\n\n                    /* Copy copyright info in the getinfo struct */\n                    if (mdi->extra_info.copyright) {\n                        mdi->extra_info.copyright = realloc(mdi->extra_info.copyright,(strlen(mdi->extra_info.copyright) + 1 + tmp_length + 1));\n                        memcpy(&mdi->extra_info.copyright[strlen(mdi->extra_info.copyright) + 1], event_data, tmp_length);\n                        mdi->extra_info.copyright[strlen(mdi->extra_info.copyright) + 1 + tmp_length] = '\\0';\n                        mdi->extra_info.copyright[strlen(mdi->extra_info.copyright)] = '\\n';\n                    } else {\n                        mdi->extra_info.copyright = malloc(tmp_length + 1);\n                        memcpy(mdi->extra_info.copyright, event_data, tmp_length);\n                        mdi->extra_info.copyright[tmp_length] = '\\0';\n                    }\n\n                    /* NOTE: free'd when events are cleared during closure of mdi */\n                    text = malloc(tmp_length + 1);\n                    memcpy(text, event_data, tmp_length);\n                    text[tmp_length] = '\\0';\n                    midi_setup_copyright(mdi, text);\n\n                    ret_cnt += tmp_length;\n\n                } else if (event_data[0] == 0x03) {\n                    /* Track Name Event */\n                    /* Get Length */\n                    event_data++;\n                    ret_cnt++;\n                    if (--siz && *event_data > 0x7f) {\n                        do {\n                            if (!siz) break;\n                            tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                            event_data++;\n                            siz--;\n                            ret_cnt++;\n                        } while (*event_data > 0x7f);\n                    }\n                    if (!siz) goto shortbuf;\n                    tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                    event_data++;\n                    ret_cnt++;\n                    if (--siz < tmp_length) goto shortbuf;\n                    if (!tmp_length) break; /* bad file? */\n\n                    text = malloc(tmp_length + 1);\n                    memcpy(text, event_data, tmp_length);\n                    text[tmp_length] = '\\0';\n                    midi_setup_trackname(mdi, text);\n\n                    ret_cnt += tmp_length;\n\n                } else if (event_data[0] == 0x04) {\n                    /* Instrument Name Event */\n                    /* Get Length */\n                    event_data++;\n                    ret_cnt++;\n                    if (--siz && *event_data > 0x7f) {\n                        do {\n                            if (!siz) break;\n                            tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                            event_data++;\n                            siz--;\n                            ret_cnt++;\n                        } while (*event_data > 0x7f);\n                    }\n                    if (!siz) goto shortbuf;\n                    tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                    event_data++;\n                    ret_cnt++;\n                    if (--siz < tmp_length) goto shortbuf;\n                    if (!tmp_length) break; /* bad file? */\n\n                    text = malloc(tmp_length + 1);\n                    memcpy(text, event_data, tmp_length);\n                    text[tmp_length] = '\\0';\n                    midi_setup_instrumentname(mdi, text);\n\n                    ret_cnt += tmp_length;\n\n                } else if (event_data[0] == 0x05) {\n                    /* Lyric Event */\n                    /* Get Length */\n                    event_data++;\n                    ret_cnt++;\n                    if (--siz && *event_data > 0x7f) {\n                        do {\n                            if (!siz) break;\n                            tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                            event_data++;\n                            siz--;\n                            ret_cnt++;\n                        } while (*event_data > 0x7f);\n                    }\n                    if (!siz) goto shortbuf;\n                    tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                    event_data++;\n                    ret_cnt++;\n                    if (--siz < tmp_length) goto shortbuf;\n                    if (!tmp_length) break; /* bad file? */\n\n                    text = malloc(tmp_length + 1);\n                    memcpy(text, event_data, tmp_length);\n                    text[tmp_length] = '\\0';\n                    midi_setup_lyric(mdi, text);\n\n                    ret_cnt += tmp_length;\n\n                } else if (event_data[0] == 0x06) {\n                    /* Marker Event */\n                    /* Get Length */\n                    event_data++;\n                    ret_cnt++;\n                    if (--siz && *event_data > 0x7f) {\n                        do {\n                            if (!siz) break;\n                            tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                            event_data++;\n                            siz--;\n                            ret_cnt++;\n                        } while (*event_data > 0x7f);\n                    }\n                    if (!siz) goto shortbuf;\n                    tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                    event_data++;\n                    ret_cnt++;\n                    if (--siz < tmp_length) goto shortbuf;\n                    if (!tmp_length) break; /* bad file? */\n\n                    text = malloc(tmp_length + 1);\n                    memcpy(text, event_data, tmp_length);\n                    text[tmp_length] = '\\0';\n                    midi_setup_marker(mdi, text);\n\n                    ret_cnt += tmp_length;\n\n                } else if (event_data[0] == 0x07) {\n                    /* Cue Point Event */\n                    /* Get Length */\n                    event_data++;\n                    ret_cnt++;\n                    if (--siz && *event_data > 0x7f) {\n                        do {\n                            if (!siz) break;\n                            tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                            event_data++;\n                            siz--;\n                            ret_cnt++;\n                        } while (*event_data > 0x7f);\n                    }\n                    if (!siz) goto shortbuf;\n                    tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                    event_data++;\n                    ret_cnt++;\n                    if (--siz < tmp_length) goto shortbuf;\n                    if (!tmp_length) break; /* bad file? */\n\n                    text = malloc(tmp_length + 1);\n                    memcpy(text, event_data, tmp_length);\n                    text[tmp_length] = '\\0';\n                    midi_setup_cuepoint(mdi, text);\n\n                    ret_cnt += tmp_length;\n\n                } else if ((event_data[0] == 0x20) && (event_data[1] == 0x01)) {\n                    /*\n                     Channel Prefix\n                     We only setting this up here for WM_Event2Midi function\n                     */\n                    if (siz < 3) goto shortbuf;\n                    midi_setup_channelprefix(mdi, event_data[2]);\n                    ret_cnt += 3;\n                } else if ((event_data[0] == 0x21) && (event_data[1] == 0x01)) {\n                    /*\n                     Port Prefix\n                     We only setting this up here for WM_Event2Midi function\n                     */\n                    if (siz < 3) goto shortbuf;\n                    midi_setup_portprefix(mdi, event_data[2]);\n                    ret_cnt += 3;\n                } else if ((event_data[0] == 0x2F) && (event_data[1] == 0x00)) {\n                    /*\n                     End of Track\n                     Deal with this inside calling function\n                     We only setting this up here for _WM_Event2Midi function\n                     */\n                    if (siz < 2) goto shortbuf;\n                    _WM_midi_setup_endoftrack(mdi);\n                    ret_cnt += 2;\n                } else if ((event_data[0] == 0x51) && (event_data[1] == 0x03)) {\n                    /*\n                     Tempo\n                     Deal with this inside calling function.\n                     We only setting this up here for _WM_Event2Midi function\n                     */\n                    if (siz < 5) goto shortbuf;\n                    _WM_midi_setup_tempo(mdi, ((event_data[2] << 16) + (event_data[3] << 8) + event_data[4]));\n                    ret_cnt += 5;\n                } else if ((event_data[0] == 0x54) && (event_data[1] == 0x05)) {\n                    if (siz < 7) goto shortbuf;\n                    /*\n                     SMPTE Offset\n                     We only setting this up here for WM_Event2Midi function\n                     */\n                    midi_setup_smpteoffset(mdi, ((event_data[3] << 24) + (event_data[4] << 16) + (event_data[5] << 8) + event_data[6]));\n\n                    /*\n                     Because this has 5 bytes of data we gonna \"hack\" it a little\n                     */\n                    mdi->events[mdi->events_size - 1].event_data.channel = event_data[2];\n\n                    ret_cnt += 7;\n                } else if ((event_data[0] == 0x58) && (event_data[1] == 0x04)) {\n                    /*\n                     Time Signature\n                     We only setting this up here for WM_Event2Midi function\n                     */\n                    if (siz < 6) goto shortbuf;\n                    midi_setup_timesignature(mdi, ((event_data[2] << 24) + (event_data[3] << 16) + (event_data[4] << 8) + event_data[5]));\n                    ret_cnt += 6;\n                } else if ((event_data[0] == 0x59) && (event_data[1] == 0x02)) {\n                    /*\n                     Key Signature\n                     We only setting this up here for WM_Event2Midi function\n                     */\n                    if (siz < 4) goto shortbuf;\n                    midi_setup_keysignature(mdi, ((event_data[2] << 8) + event_data[3]));\n                    ret_cnt += 4;\n                } else {\n                    /*\n                     Unsupported Meta Event\n                     */\n                    event_data++;\n                    ret_cnt++;\n                    if (--siz && *event_data > 0x7f) {\n                        do {\n                            if (!siz) break;\n                            tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                            event_data++;\n                            siz--;\n                            ret_cnt++;\n                        } while (*event_data > 0x7f);\n                    }\n                    if (!siz) goto shortbuf;\n                    tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                    ret_cnt++;\n                    ret_cnt += tmp_length;\n                    if (--siz < tmp_length) goto shortbuf;\n                }\n\n            } else if ((channel == 0) || (channel == 7)) {\n                /*\n                 Sysex Events\n                 */\n                uint32_t sysex_len = 0;\n                uint8_t *sysex_store = NULL;\n\n                if (*event_data > 0x7f) {\n                    do {\n                        if (!siz) break;\n                        sysex_len = (sysex_len << 7) + (*event_data & 0x7F);\n                        event_data++;\n                        siz--;\n                        ret_cnt++;\n                    } while (*event_data > 0x7f);\n                }\n                if (!siz) goto shortbuf;\n                sysex_len = (sysex_len << 7) + (*event_data & 0x7F);\n                event_data++;\n                ret_cnt++;\n                if (--siz < sysex_len) goto shortbuf;\n                if (!sysex_len) break; /* bad file? */\n\n                sysex_store = malloc(sizeof(uint8_t) * sysex_len);\n                memcpy(sysex_store, event_data, sysex_len);\n\n                if (sysex_store[sysex_len - 1] == 0xF7) {\n                    uint8_t rolandsysexid[] = { 0x41, 0x10, 0x42, 0x12 };\n                    if (memcmp(rolandsysexid, sysex_store, 4) == 0) {\n                        /* For Roland Sysex Messages */\n                        /* checksum */\n                        uint8_t sysex_cs = 0;\n                        uint32_t sysex_ofs = 4;\n                        do {\n                            sysex_cs += sysex_store[sysex_ofs];\n                            if (sysex_cs > 0x7F) {\n                                sysex_cs -= 0x80;\n                            }\n                            sysex_ofs++;\n                        } while (sysex_store[sysex_ofs + 1] != 0xf7);\n                        sysex_cs = 128 - sysex_cs;\n                        /* is roland sysex message valid */\n                        if (sysex_cs == sysex_store[sysex_ofs]) {\n                            /* process roland sysex event */\n                            if (sysex_store[4] == 0x40) {\n                                if (((sysex_store[5] & 0xf0) == 0x10) && (sysex_store[6] == 0x15)) {\n                                    /* Roland Drum Track Setting */\n                                    uint8_t sysex_ch = 0x0f & sysex_store[5];\n                                    if (sysex_ch == 0x00) {\n                                        sysex_ch = 0x09;\n                                    } else if (sysex_ch <= 0x09) {\n                                        sysex_ch -= 1;\n                                    }\n                                    midi_setup_sysex_roland_drum_track(mdi, sysex_ch, sysex_store[7]);\n                                } else if ((sysex_store[5] == 0x00) && (sysex_store[6] == 0x7F) && (sysex_store[7] == 0x00)) {\n                                    /* Roland GS Reset */\n                                    midi_setup_sysex_roland_reset(mdi);\n                                }\n                            }\n                        }\n                    } else {\n                        /* For non-Roland Sysex Messages */\n                        uint8_t gm_reset[] = {0x7e, 0x7f, 0x09, 0x01, 0xf7};\n                        uint8_t yamaha_reset[] = {0x43, 0x10, 0x4c, 0x00, 0x00, 0x7e, 0x00, 0xf7};\n\n                        if (memcmp(gm_reset, sysex_store, 5) == 0) {\n                            /* GM Reset */\n                            midi_setup_sysex_gm_reset(mdi);\n                        } else if (memcmp(yamaha_reset,sysex_store,8) == 0) {\n                            /* Yamaha Reset */\n                            midi_setup_sysex_yamaha_reset(mdi);\n                        }\n                    }\n                }\n                free(sysex_store);\n                sysex_store = NULL;\n                /*\n                event_data += sysex_len;\n                */\n                ret_cnt += sysex_len;\n            } else {\n                _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(unrecognized meta type event)\", 0);\n                return 0;\n            }\n            break;\n\n        default: /* Should NEVER get here */\n            ret_cnt = 0;\n            break;\n    }\n    if (ret_cnt == 0)\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(missing event)\", 0);\n    return ret_cnt;\n\nshortbuf:\n    _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(input too short)\", 0);\n    return 0;\n}\n\n"], "filenames": ["include/internal_midi.h", "src/f_hmi.c", "src/f_hmp.c", "src/f_midi.c", "src/f_mus.c", "src/f_xmidi.c", "src/internal_midi.c"], "buggy_code_start_loc": [194, 44, 237, 46, 64, 270, 1965], "buggy_code_end_loc": [195, 309, 310, 374, 318, 271, 2386], "fixing_code_start_loc": [194, 45, 238, 45, 64, 270, 1965], "fixing_code_end_loc": [195, 338, 322, 394, 319, 271, 2449], "type": "CWE-125", "message": "The _WM_SetupMidiEvent function in internal_midi.c:2122 in WildMIDI 0.4.2 can cause a denial of service (invalid memory read and application crash) via a crafted mid file.", "other": {"cve": {"id": "CVE-2017-11664", "sourceIdentifier": "cve@mitre.org", "published": "2017-08-17T16:29:00.330", "lastModified": "2020-11-10T19:39:20.633", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The _WM_SetupMidiEvent function in internal_midi.c:2122 in WildMIDI 0.4.2 can cause a denial of service (invalid memory read and application crash) via a crafted mid file."}, {"lang": "es", "value": "La funci\u00f3n _WM_SetupMidiEvent en internal_midi.c:2122 en WildMIDI 0.4.2 puede provocar una denegaci\u00f3n de servicio (lectura de memoria no v\u00e1lida y bloqueo de aplicaci\u00f3n) mediante un archivo mid manipulado."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mindwerks:wildmidi:0.4.2:*:*:*:*:*:*:*", "matchCriteriaId": "5072089A-8B4C-4AD3-B53B-459FD0F69AB0"}]}]}], "references": [{"url": "http://seclists.org/fulldisclosure/2017/Aug/12", "source": "cve@mitre.org", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/Mindwerks/wildmidi/commit/ad6d7cf88d6673167ca1f517248af9409a9f1be1", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.exploit-db.com/exploits/42433/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/Mindwerks/wildmidi/commit/ad6d7cf88d6673167ca1f517248af9409a9f1be1"}}