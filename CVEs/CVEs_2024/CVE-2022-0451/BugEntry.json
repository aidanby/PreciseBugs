{"buggy_code": ["## 2.17.0\n\n### Core libraries\n\n#### `dart:core`\n\n- Add `Finalizer` and `WeakReference` which can potentially detect when\n  objects are \"garbage collected\".\n\n#### `dart:ffi`\n\n- Add `ref=` and `[]=` methods to the `StructPointer` and `UnionPointer`\n  extensions. They copy a compound instance into a native memory region.\n\n#### `dart:indexed_db`\n\n- `IdbFactory.supportsDatabaseNames` has been deprecated. It will always return\n  `false`.\n\n### Tools\n\n#### Dart command line\n\n- **Breaking Change** [#46100](https://github.com/dart-lang/sdk/issues/46100):\n  The standalone `dart2js` tool has been\n  marked deprecated as previously announced.\n  Its replacement is the `dart compile js` command.\n  Should you find any issues, or missing features, in the replacement\n  command, kindly file [an issue][].\n\n[an issue]: https://github.com/dart-lang/sdk/issues/new\n\n- **Breaking Change** [#46100](https://github.com/dart-lang/sdk/issues/46100):\n  The standalone `dartdoc` tool has been removed as\n  previously announced. Its replacement is the `dart doc` command.\n\n## 2.16.0\n\n### Core libraries\n\n#### `dart:core`\n\n- Add `Error.throwWithStackTrace` which can `throw` an\n  error with an existing stack trace, instead of creating\n  a new stack trace.\n\n#### `dart:io`\n\n- **Breaking Change** [#47653](https://github.com/dart-lang/sdk/issues/47653):\nOn Windows, `Directory.rename` will no longer delete a directory if\n`newPath` specifies one. Instead, a `FileSystemException` will be thrown.\n\n- **Breaking Change** [#47769](https://github.com/dart-lang/sdk/issues/47769):\nThe `Platform.packageRoot` API has been removed. It had been marked deprecated\nin 2018, as it doesn't work with any Dart 2.x release.\n- Add optional `sourcePort` parameter to `Socket.connect`, `Socket.startConnect`, `RawSocket.connect` and `RawSocket.startConnect`\n\n#### `dart:isolate`\n\n- **Breaking Change** [#47769](https://github.com/dart-lang/sdk/issues/47769):\nThe `Isolate.packageRoot` API has been removed. It had been marked deprecated\nin 2018, as it doesn't work with any Dart 2.x release.\n\n### Tools\n\n#### Dart command line\n\n- **Breaking Change** [#46100](https://github.com/dart-lang/sdk/issues/46100):\n  The standalone `dartanalyzer` tool has been\n  marked deprecated as previously announced.\n  Its replacement is the `dart analyze` command.\n  Should you find any issues, or missing features, in the replacement\n  command, kindly file [an issue][].\n\n[an issue]: https://github.com/dart-lang/sdk/issues/new\n\n- **Breaking Change** [#46100](https://github.com/dart-lang/sdk/issues/46100):\n  The standalone `dartdoc` tool has been\n  marked deprecated as previously announced.\n  Its replacement is the `dart doc` command.\n  Should you find any issues, or missing features, in the replacement\n  command, kindly file [an issue][].\n\n[an issue]: https://github.com/dart-lang/sdk/issues/new\n\n#### Pub\n\n- Fixed race conditions in `dart pub get`, `dart run` and `dart pub global run`.\n  It should now be safe to run these concurrently.\n- If (when) Pub crashes it will save a verbose log in\n  `$PUB_CACHE/log/pub_log.txt` This can be used for filing issues to the issue\n  tracker.\n\n  `dart --verbose pub [command]` will also cause the log file to be written.\n- `dart pub add` can now add multiple packages in one command.\n\n#### Linter\n\nUpdated the Linter to `1.18.0`, which includes changes that\n\n- extends `camel_case_types` to cover enums.\n- fixes `no_leading_underscores_for_local_identifiers` to not \n  mis-flag field formal parameters with default values.\n- fixes `prefer_function_declarations_over_variables` to not\n  mis-flag non-final fields.\n- improves performance for `prefer_contains`.\n- updates `exhaustive_cases` to skip deprecated values that\n  redirect to other values.\n- adds new lint: `unnecessary_late`.\n- improves docs for `prefer_initializing_formals`.\n- updates `secure_pubspec_urls` to check `issue_tracker` and\n  `repository` entries.\n- adds new lint: `conditional_uri_does_not_exist`.\n- improves performance for\n  `missing_whitespace_between_adjacent_strings`.\n- adds new lint: `avoid_final_parameters`.\n- adds new lint: `no_leading_underscores_for_library_prefixes`.\n- adds new lint: `no_leading_underscores_for_local_identifiers`.\n- adds new lint: `secure_pubspec_urls`.\n- adds new lint: `sized_box_shrink_expand`.\n- adds new lint: `use_decorated_box`.\n- improves docs for `omit_local_variable_types`.\n\n## 2.15.1 - 2021-12-14\n\nThis is a patch release that fixes:\n\n- an AOT compilation failure in some Flutter apps (issue [#47878][]).\n- `dart pub publish` for servers with a path in the URL (pr\n  [dart-lang/pub#3244][]).\n\n[#47878]: https://github.com/dart-lang/sdk/issues/47878\n[dart-lang/pub#3244]: https://github.com/dart-lang/pub/pull/3244\n\n## 2.15.0 - 2021-12-08\n\n### Language\n\nThe following features are new in the Dart 2.15 [language version][]. To use\nthem, you must set the lower bound on the SDK constraint for your package to\n2.15 or greater (`sdk: '>=2.15.0 <3.0.0'`).\n\n[language version]: https://dart.dev/guides/language/evolution\n\n- **[Constructor tear-offs][]**: Previous Dart versions allowed a method on an\n  instance to be passed as a closure, and similarly for static methods. This is\n  commonly referred to as \"closurizing\" or \"tearing off\" a method. Constructors\n  were not previously eligible for closurization, forcing users to explicitly\n  write wrapper functions when using constructors as first class functions.\n  See the calls to `map()` in this example:\n\n  ```dart\n  class A {\n    int x;\n    A(this.x);\n    A.fromString(String s) : x = int.parse(s);\n  }\n\n  void main() {\n    var listOfInts = [1, 2, 3];\n    var listOfStrings = [\"1\", \"2\", \"3\"];\n    for(var a in listOfInts.map((x) => A(x))) {\n      print(a.x);\n    }\n    for(var a in listOfStrings.map((x) => A.fromString(x))) {\n      print(a.x);\n    }\n  }\n  ```\n\n  New in Dart 2.15, constructors are now allowed to be torn off. Named\n  constructors are closurized using their declared name (here `A.fromString`).\n  To closurize unnamed constructors, use the keyword `new` (here `A.new`).\n  The above example may now be written as:\n\n  ```dart\n  class A {\n    int x;\n    A(this.x);\n    A.fromString(String s) : x = int.parse(s);\n  }\n\n  void main() {\n    var listOfInts = [1, 2, 3];\n    var listOfStrings = [\"1\", \"2\", \"3\"];\n    for(A a in listOfInts.map(A.new)) {\n      print(a.x);\n    }\n    for(A a in listOfStrings.map(A.fromString)) {\n      print(a.x);\n    }\n  }\n  ```\n\n  Constructors for generic classes may be torn off as generic functions, or\n  instantiated at the tear-off site. In the following example, the tear-off\n  `G.new` is used to initialize the variable `f` produces a generic function\n  which may be used to produce an instance of `G<T>` for any type `T` provided\n  when `f` is called. The tear-off `G<String>.new` is used to initialize the\n  variable `g` to produce a non-generic function which may only be used\n  to produce instances of type `G<String>`.\n\n  ```dart\n  class G<T> {\n    T x;\n    G(this.x);\n  }\n\n  void main() {\n    G<T> Function<T>(T x) f = G.new;\n    var x = f<int>(3);\n    G<String> Function(String y) g = G<String>.new;\n    var y = g(\"hello\");\n  }\n  ```\n\n[constructor tear-offs]: https://github.com/dart-lang/language/blob/master/accepted/2.15/constructor-tearoffs/feature-specification.md\n\n- **[Generic type literals][explicit instantiation]**: Previous Dart versions\n  allowed class names to be used as type literals. So for example,`int` may be\n  used as an expression, producing a value of type `Type`. Generic classes (e.g.\n  `List`) could be referred to by name as an expression, but no type arguments\n  could be provided and so only the `dynamic` instantiation could be produced\n  directly as an expression without using indirect methods:\n\n  ```dart\n  // Workaround to capture generic type literals.\n  Type typeOf<T>() => T;\n\n  void main() {\n    var x = int; // The Type literal corresponding to `int`.\n    var y = List; // The Type literal corresponding to `List<dynamic>`.\n    // Use workaround to capture generic type literal.\n    var z = typeOf<List<int>>(); // The Type literal for `List<int>`.\n  }\n  ```\n\n  New in Dart 2.15, instantiations of generic classes may now be used as Type\n  literals:\n\n  ```dart\n  void main() {\n    var x = int; // The Type literal corresponding to `int`.\n    var y = List; // The Type literal corresponding to `List<dynamic>`.\n    var z = List<int>; // The Type literal corresponding to `List<int>`.\n  }\n  ```\n\n- **[Explicit generic method instantiations][explicit instantiation]**: Previous\n  Dart versions allowed generic methods to be implicitly specialized (or\n  \"instantiated\") to non-generic versions when assigned to a location with a\n  compatible monomorphic type. Example:\n\n  ```dart\n  // The generic identity function.\n  T id<T>(T x) => x;\n\n  void main() {\n    // Initialize `intId` with a version of `id` implicitly specialized to\n    // `int`.\n    int Function(int) intId = id;\n    print(intId(3));\n    // Initialize `stringId` with a version of `id` implicitly specialized to\n    // `String`.\n    String Function(String) stringId = id;\n    print(stringId(\"hello\"));\n  }\n  ```\n\n  New in Dart 2.15, generic methods may be explicitly instantiated using the\n  syntax `f<T>` where `f` is the generic method to specialize and `T` is the\n  type argument (in general, type arguments) to be used to specialize the\n  method. Example:\n\n  ```dart\n  // The generic identity function.\n  T id<T>(T x) => x;\n\n  void main() {\n    // Initialize `intId` with a version of `id` explicitly specialized to\n    // `int`.\n    var intId = id<int>;\n    print(intId(3));\n    // Initialize `stringId` with a version of `id` explicitly specialized to\n    // `String`.\n    var stringId = id<String>;\n    print(stringId(\"hello\"));\n  }\n  ```\n\n[explicit instantiation]: https://github.com/dart-lang/language/blob/master/accepted/2.15/constructor-tearoffs/feature-specification.md#explicitly-instantiated-classes-and-functions\n\n- **[Generic instantiation of function objects][object instantiation]**: Generic\n  function instantiation was previously restricted to function declarations. For\n  example, as soon as a function had been torn off, it could not be\n  instantiated:\n\n  ```dart\n  // Before Dart 2.15:\n  X id<X>(X x) => x;\n\n  void main() {\n    var fo = id; // Tear off `id`, creating a function object.\n    var c1 = fo<int>; // Compile-time error: can't instantiate `fo`.\n    int Function(int) c2 = fo; // Same compile-time error.\n    // Constants are treated the same.\n  }\n  ```\n\n  New in Dart 2.15, this restriction has been lifted. It is now possible\n  to obtain a generic instantiation of an existing function object, both\n  explicitly and implicitly (again, this works the same for non-constants):\n\n  ```dart\n  X id<X>(X x) => x;\n  X other<X>(X x) => throw x;\n\n  void main() {\n    const fo = id; // Tear off `id`, creating a function object.\n\n    // Generic function instantiation on `fo` is no longer an error.\n    const c1 = fo<int>; // OK.\n    const int Function(int) c2 = fo; // OK.\n\n    // This also generalizes function instantiation because we can,\n    // e.g., use non-trivial expressions and go via a constructor.\n    const c3 = A(true); // OK.\n  }\n\n  class A {\n    final int Function(int) x;\n    // `(...)<T>` is now allowed, also in a `const` constructor.\n    const A(bool b): x = (b ? id : other)<int>;\n  }\n  ```\n\n[Object instantiation]: https://github.com/dart-lang/language/pull/1812\n\n- Annotations on type parameters of classes can no longer refer to class members\n  without a prefix.  For example, this used to be permitted:\n\n  ```dart\n  class C<@Annotation(foo) T> {\n    static void foo() {}\n  }\n  ```\n\n  Now, the reference must be qualified with the class name, i.e.:\n\n  ```dart\n  class C<@Annotation(C.foo) T> {\n    static void foo() {}\n  }\n  ```\n\n  This brings the implementation behavior in line with the spec.\n\n- Initializer expressions on implicitly typed condition variables can now\n  contribute to type promotion.  For example, this program no longer produces a\n  compile-time error:\n\n  ```dart\n  f(int? i) {\n    var iIsNull = i == null;\n    if (!iIsNull) {\n      print(i + 1); // OK, because `i` is known to be non-null.\n    }\n  }\n  ```\n\n  Previously, the above program had a compile-time error due to a bug\n  ([#1785][]) in type promotion which prevented the initializer expression\n  (`i == null`) from being accounted for when the variable in question\n  (`iIsNull`) lacked an explicit type.\n\n  To avoid causing problems for packages that are intended to work with older\n  versions of Dart, the fix only takes effect when the minimum SDK of the source\n  packages is 2.15 or greater.\n\n[#1785]: https://github.com/dart-lang/language/issues/1785\n\n- Restrictions on members of a class with a constant constructor are relaxed\n  such that they only apply when the class has a _generative_ constant\n  constructor. For example, this used to be an error, but is now permitted:\n\n  ```dart\n  abstract class A {\n    const factory A() = B;\n    var v1;\n    late final v2 = Random().nextInt(10);\n    late final v3;\n  }\n\n  class B implements A {\n    const B([this.v3 = 1]);\n    get v1 => null;\n    set v1(_) => throw 'Cannot mutate B.v1';\n    final v2 = 0;\n    final v3;\n    set v3(_) => throw 'Cannot initialize B.v3';\n  }\n  ```\n\n  This implements a relaxation of the specified rule for a `late final`\n  instance variable, and it brings the implementation behavior in line with\n  the specification in all other cases.\n\n- **Function object canonicalization and equality**: Several corner cases in the\n  area of function object canonicalization and function object equality have\n  been updated, such that all tools behave in the same way, and the behavior\n  matches the specification.\n\n  In particular, function objects are now equal when they are obtained by\n  generic instantiation from the same function with the same actual type\n  arguments, even when that type argument is not known at compile time.\n  When the expressions are constant then the function objects are identical.\n  Constant expressions are treated as such even when they do not occur in a\n  constant context (e.g., `var f = top;`).\n\n### Core libraries\n\n#### `dart:async`\n\n- Make the `unawaited` function's argument nullable, to allow calls like\n  `unawaited(foo?.bar())`.\n\n#### `dart:cli`\n\n- The experimental `waitFor` functionality, and the library containing only that\n  function, are now deprecated.\n\n#### `dart:core`\n\n- Add extension `name` getter on enum values.\n- Add `Enum.compareByIndex` helper function for comparing enum values by index.\n- Add `Enum.compareByName` helper function for comparing enum values by name.\n- Add extension methods on `Iterable<T extends Enum>`, intended for\n  `SomeEnumType.values` lists, to look up values by name.\n- Deprecate `IntegerDivisionByZeroException`.\n  Makes the class also implement `Error`. Code throwing the exception will be\n  migrated to throwing an `Error` instead until the class is unused and\n  ready to be removed.\n  Code catching the class should move to catching `Error` instead\n  (or, for integers, check first for whether it's dividing by zero).\n\n#### `dart:io`\n\n- **Breaking Change** [#46875](https://github.com/dart-lang/sdk/issues/46875):\n  The `SecurityContext` class in `dart:io` has been updated to set the minimum\n  TLS protocol version to TLS1_2_VERSION (1.2) instead of TLS1_VERSION.\n- Add `RawSocket.sendMessage`, `RawSocket.receiveMessage` that allow passing of\n  file handle references via Unix domain sockets.\n\n#### `dart:js_util`\n\n- The `js_util` methods `setProperty`, `callMethod`, and `callConstructor` have\n  been optimized to remove checks on arguments when the checks can be elided.\n  Also, those methods, along with `getProperty` and `newObject`, now support a\n  generic type argument to specify a return type. These two changes make simple\n  `js_util` usage, like reading and writing primitive properties or calling\n  methods with simple arguments, have zero overhead.\n\n#### `dart:web_sql`\n\n- **Breaking Change** [#46316](https://github.com/dart-lang/sdk/issues/46316):\n  The WebSQL standard was abandoned more than 10\n  years ago and is not supported by many browsers. This release completely\n  deletes the `dart:web_sql` library.\n\n#### `dart:html`\n\n- **Breaking Change** [#46316](https://github.com/dart-lang/sdk/issues/46316):\n  Related to the removal of `dart:web_sql` (see above), `window.openDatabase`\n  has been removed.\n\n### Tools\n\n#### Dart command line\n\n- **Breaking Change** [#46100][]: The standalone `dart2native` tool has been\n  removed as previously announced. Its replacements are the\n  `dart compile exe` and `dart compile aot-snapshot` commands, which offer the\n  same functionality.\n\n- **Breaking Change**: The standalone `dartfmt` tool has been removed as\n  previously announced. Its replacement is the `dart format` command.\n\n  Note that `dart format` has [a different set of options and\n  defaults][dartfmt cli] than `dartfmt`.\n\n- When a script is `dart run` it will always be precompiled, but with\n  incremental precompilation for following runs.\n\n#### Dart VM\n\n- **Breaking Change** [#45451](https://github.com/dart-lang/sdk/issues/45451):\n  Support for `dart-ext:`-style native extensions has been removed as previously\n  announced. Use `dart:ffi` to bind to native libraries instead.\n\n- **Breaking Change** [#46754](https://github.com/dart-lang/sdk/issues/46754):\n  Isolates spawned via the `Isolate.spawn()` API are now grouped, operate on the\n  same managed heap and can therefore share various VM-internal data structures.\n\n  This leads to ~100x faster isolate startup latency, ~10-100x lower\n  per-isolate base memory overhead and ~8x faster inter-isolate communication.\n\n  Making isolates operate on the same heap will also make them collaborate on\n  garbage collections, which changes performance characteristics for GC-heavy\n  applications that may - in rare cases - negatively affect pause times or\n  throughput.\n\n- Allow closures both in inter-isolate messages as well as as entrypoints in\n  `Isolate.spawn(<entrypoint>, ...)` calls. Closures and their enclosing context\n  may need to be copied in this process. The enclosing context is - as with\n  normal messages - verified to only contain objects that are sendable.\n\n  Note of caution: The Dart VM's current representation of enclosing variables\n  in closures can make closures hang on to more variables than strictly needed.\n  Using such closures in inter-isolate communication can therefore lead to\n  copying of larger transitive object graphs. If the extended transitive\n  closure includes objects that are illegal to send, the sending will fail.\n  See [#36983](https://github.com/dart-lang/sdk/issues/36983), which tracks this\n  existing memory leak issue.\n\n#### Linter\n\nUpdated the Linter to `1.14.0`, which includes changes that\n- improves performance for `annotate_overrides`, `prefer_contains`, and\n  `prefer_void_to_null`.\n- marks `avoid_dynamic_calls` stable.\n- fixed `avoid_null_checks_in_equality_operators` false positive with\n  non-nullable params.\n- update `avoid_print` to allow `kDebugMode`-wrapped print calls.\n- adds support for constructor tear-offs to `avoid_redundant_argument_values`,\n  `unnecessary_lambdas`, and `unnecessary_parenthesis`.\n- improves messages for `avoid_renaming_method_parameters`.\n- improves regular expression parsing performance for common checks\n  (`camel_case_types`, `file_names`, etc.).\n- fixed `file_names` to report at the start of the file\n  (not the entire compilation unit).\n- allow `while (true) { ... }` in `literal_only_boolean_expressions`.\n- fixed `omit_local_variable_types` false positives.\n- fixed `omit_local_variable_types` to not flag a local type that is required\n  for inference.\n- fixed `overridden_fields` false positive with static fields.\n- fixed `prefer_collection_literals` named typed parameter false positives.\n- fixed `prefer_const_constructors` false positive for deferred imports.\n- fixed `prefer_final_parameters` handling of initializing formals.\n- fixed `prefer_generic_function_type_aliases` false positives with incomplete\n  statements.\n- fixed `prefer_initializing_formals` false positives with factory constructors.\n- fixed `prefer_void_to_null` false positive with overridden properties.\n- fixed `prefer_void_to_null` false positives on overriding returns.\n- fixed `prefer_void_to_null` false positives.\n- adds a new lint: `unnecessary_constructor_name` to flag unnecessary uses of\n  `.new`.\n- updates `unnecessary_getters_setters` to only flag the getter.\n- fixed `unnecessary_parenthesis` false positive with function expressions.\n- fixed `use_build_context_synchronously` false positive in awaits inside\n  anonymous functions.\n- improve control flow analysis for `use_build_context_synchronously`.\n- fixed `use_rethrow_when_possible` false positives.\n- fixed `void_checks` false positives with incomplete source.\n\n### Pub\n\n- If you have analytics enabled `dart pub get` will send\n  [usage metrics](https://github.com/dart-lang/pub/blob/0035a40f25d027130c0314571da53ffafc6d973b/lib/src/solver/result.dart#L131-L175)\n  for packages from pub.dev, intended for popularity analysis.\n- Adds support for token-based authorization to third-party package-repositories\n  with the new command `dart pub token`.\n- Credentials are no longer stored in the pub-cache, but in a platform dependent\n  config directory:\n  * On Linux `$XDG_CONFIG_HOME/dart/pub-credentials.json` if `$XDG_CONFIG_HOME`\n    is defined, otherwise `$HOME/.config/dart/pub-credentials.json`\n  * On Mac OS: `$HOME/Library/Application Support/dart/pub-credentials.json`\n  * On Windows: `%APPDATA%/dart/pub-credentials.json`\n- The syntax for dependencies hosted at a third-party package repository has\n  been simplified. Before you would need to write:\n\n```yaml\ndependencies:\n  colorizer:\n    hosted:\n      name: colorizer\n      url: 'https://custom-pub-server.com'\n    version: ^1.2.3\nenvironment:\n  sdk: '>=2.14.0 < 3.0.0'\n```\n\nNow you can write:\n\n```yaml\ndependencies:\n  colorizer:\n    hosted: 'https://custom-pub-server.com'\n    version: ^1.2.3\nenvironment:\n  sdk: '>=2.15.0 < 3.0.0'\n```\n\nThis feature requires\n[language-version](https://dart.dev/guides/language/evolution#language-versioning)\n2.15 or later, e.g. the `pubspec.yaml` should have an SDK constraint of\n`>=2.15 <3.0.0`.\n\n- Detect potential leaks in `dart pub publish`.\n  When publishing, pub will examine your files for potential secret keys, and\n  warn you.\n\n  To ignore a file that has a false positive, add it to a\n  [`false_secrets`](https://dart.dev/go/false-secrets) section of your\n  `pubspec.yaml`.\n- Fixes unicode terminal detection windows.\n- New flag `--example` to the commands\n  `dart pub get/upgrade/downgrade/add/remove` that will result in the `example/`\n  folder dependencies to be updated after operating in the current directory.\n\n### Other libraries\n\n#### `package:js`\n\n- Extensions on JS interop or native `dart:html` classes can now declare\n  members as `external`. These members are equivalent to regular extension\n  members that use `js_util` to expose the underlying JavaScript.\n\n## 2.14.4 - 2021-10-14\n\nThis is a patch release that fixes:\n\n- a memory leak of analyzer plugins (issue [flutter/flutter#90868][]).\n- the Dart VM sometimes loading expired certificates on Windows (issues\n  [#46370][] and [#47420][]).\n\n[flutter/flutter#90868]: https://github.com/flutter/flutter/issues/90868\n[#46370]: https://github.com/dart-lang/sdk/issues/46370\n[#47420]: https://github.com/dart-lang/sdk/issues/47420\n\n## 2.14.3 - 2021-09-30\n\nThis is a patch release that fixes:\n\n- a code completion performance regression (issue\n  [flutter/flutter-intellij#5761][]).\n- debug information emitted by the Dart VM (issue [#47289][]).\n\n[flutter/flutter-intellij#5761]:\n  https://github.com/flutter/flutter-intellij/issues/5761\n[#47289]: https://github.com/dart-lang/sdk/issues/47289\n\n## 2.14.2 - 2021-09-16\n\nThis is a patch release that fixes:\n\n- two dartdoc crashes (issues [dart-lang/dartdoc#2740][] and\n  [dart-lang/dartdoc#2755][]).\n- error messages when using the `>>>` operator on older language versions\n  (issue [#46886][]).\n- invalid `pubspec.lock` paths on Windows (issue [dart-lang/pub#3012][]).\n\n[dart-lang/dartdoc#2740]: https://github.com/dart-lang/dartdoc/issues/2740\n[dart-lang/dartdoc#2755]: https://github.com/dart-lang/dartdoc/issues/2755\n[#46886]: https://github.com/dart-lang/sdk/issues/46886\n[#45767]: https://github.com/dart-lang/sdk/issues/45767\n[dart-lang/pub#3012]: https://github.com/dart-lang/pub/issues/3012\n\n## 2.14.1 - 2021-09-09\n\n- Fixed an issue specific to the macOS ARM64 (Apple Silicon) SDK, where the Dart\n  commandline tools did not have the expected startup performance.\n\n## 2.14.0 - 2021-09-09\n\n### Language\n\n- Add an unsigned shift right operator `>>>`. Pad with zeroes, ignoring the sign\n  bit. On the web platform `int.>>>` shifts the low 32 bits interpreted as an\n  unsigned integer, so `a >>> b` gives the same result as\n  `a.toUnsigned(32) >>> b` on the VM.\n\n- Prior to Dart 2.14, metadata (annotations) were not permitted to be specified\n  with generic type arguments. This restriction is lifted in Dart Dart 2.14.\n\n  ```dart\n  class C<T> {\n    const C();\n  }\n  @C();      // Previously permitted.\n  @C<int>(); // Previously an error, now permitted.\n  ```\n\n- Prior to Dart 2.14, generic function types were not permitted as arguments to\n  generic classes or functions, nor to be used as generic bounds. This\n  restriction is lifted in Dart 2.14.\n\n  ```dart\n  T wrapWithLogging<T>(T f) {\n    if (f is void Function<T>(T x)) {\n      return <S>(S x) {\n        print(\"Call: f<$S>($x)\");\n        var r = f<S>(x);\n        print(\"Return: $x\");\n        return r;\n      } as T;\n    } // More cases here\n    return f;\n  }\n  void foo<T>(T x) {\n    print(\"Foo!\");\n  }\n  void main() {\n    // Previously an error, now permitted.\n    var f = wrapWithLogging<void Function<T>(T)>(foo);\n    f<int>(3);\n  }\n  ```\n\n### Core libraries\n\n#### `dart:async`\n\n- The uncaught error handlers of `Zone`s are now run in the parent zone of the\n  zone where they were declared. This prevents a throwing handler from causing\n  an infinite loop by repeatedly triggering itself.\n\n- Added `ignore()` as extension member on futures.\n\n- Added `void unawaited(Future)` top-level function to deal with the\n  `unawaited_futures` lint.\n\n#### `dart:core`\n\n- Introduce `Enum` interface implemented by all `enum` declarations.\n\n- The native `DateTime` class now better handles local time around daylight\n  saving changes that are not precisely one hour. (No change on the Web which\n  uses the JavaScript `Date` object.)\n\n- Adds static methods `hash`, `hashAll` and `hashAllUnordered` to the `Object`\n  class. These can be used to combine the hash codes of multiple objects in a\n  consistent way.\n\n- The `Symbol` constructor now accepts any string as argument. Symbols are equal\n  if they were created from the same string.\n\n\n#### `dart:ffi`\n\n- Adds the `DynamicLibrary.providesSymbol` function to check whether a symbol is\n  available in a dynamic library.\n\n#### `dart:html`\n\n- `convertNativeToDart_Dictionary()` now converts objects recursively, this\n  fixes APIs like MediaStreamTrack.getCapabilities that convert between Maps and\n  browser Dictionaries. [#44319]\n- Added some access-control HTTP header names to `HttpHeaders`.\n\n[#44319]: https://github.com/dart-lang/sdk/issues/44319\n\n#### `dart:io`\n\n- BREAKING CHANGE (for pre-migrated null safe code): `HttpClient`'s\n  `.authenticate` and `.authenticateProxy` setter callbacks must now accept a\n  nullable `realm` argument.\n- Added some access-control HTTP header names to `HttpHeaders`.\n\n#### `dart:typed_data`\n\n- **BREAKING CHANGE** (https://github.com/dart-lang/sdk/issues/45115) Most types\n  exposed by this library can no longer be extended, implemented or mixed-in.\n  The affected types are `ByteBuffer`, `TypedData` and _all_ its subclasses,\n  `Int32x4`, `Float32x4`, `Float64x2` and `Endian`.\n\n#### `dart:web_sql`\n\n- `dart:web_sql` is marked deprecated and will be removed in an upcoming\n  release. Also the API `window.openDatabase` in `dart:html` is deprecated as\n  well.\n\n  This API and library was exposing the WebSQL proposed standard. The standard\n  was abandoned more than 5 years ago and is not supported by most browsers. The\n  `dart:web_sql` library has been documented as unsupported and deprecated for\n  many years as well and but wasn't annotated properly until now.\n\n### Dart VM\n\n- **Breaking Change** [#45071][]: `Dart_NewWeakPersistentHandle`'s and\n  `Dart_NewFinalizableHandle`'s `object` parameter no longer accepts `Pointer`s\n  and subtypes of `Struct`. Expandos no longer accept `Pointer`s and subtypes of\n  `Struct`s.\n\n[#45071]: https://github.com/dart-lang/sdk/issues/45071\n\n### Tools\n\n#### Dart command line\n\n- **Breaking Change** [#46100][]: The standalone `dart2native` tool has been\n  marked deprecated, and now prints a warning message. Its replacements are the\n  `dart compile exe` and `dart compile aot-snapshot` commands, which offer the\n  same functionality. The `dart2native` tool will be removed from the Dart SDK\n  in Dart 2.15.\n\n- **Breaking Change**: The standalone `dartfmt` tool has been marked deprecated,\n  and now prints a warning message. Instead, use `dart format`. The `dartfmt`\n  tool will be removed from the Dart SDK in Dart 2.15.\n\n  Note that `dart format` has [a different set of options and\n  defaults][dartfmt cli] than `dartfmt`.\n\n- The `dart create` command has been updated to create projects that use the new\n  'recommended' set of lints from `package:lints`. See\n  https://dart.dev/go/core-lints for more information about these lints.\n\n[#46100]: https://github.com/dart-lang/sdk/issues/46100\n[dartfmt cli]: https://github.com/dart-lang/dart_style/wiki/CLI-Changes\n\n- The `dart analyze` command has been extended to support specifying multiple\n  files or directories to analyze; see also\n  https://github.com/dart-lang/sdk/issues/45352.\n\n- The `dartanalyzer` command's JSON output mode has been changed to emit the\n  JSON output on stdout instead of stderr.\n\n#### dart format\n\n- Simplify and optimize cascade formatting. See:\n  https://github.com/dart-lang/dart_style/pull/1033\n- Don't unnecessarily split argument lists with `/* */` comments.\n- Return correct exit code from `FormatCommand` when formatting stdin.\n- Split empty catch blocks with finally clauses or catches after them.\n\n#### Linter\n\nUpdated the Linter to `1.8.0`, which includes changes that\n- improve performance for `prefer_is_not_empty`.\n- fix false positives in `no_logic_in_create_state`.\n- improve `package_names` to allow dart identifiers as package names.\n- fix a false-positive in `package_names` (causing keywords to wrongly get flagged).\n- fix `avoid_classes_with_only_static_member` to check for inherited members and also\n  flag classes with only methods.\n- fix `curly_braces_in_flow_control_structures` to properly flag terminating `else-if`\n  blocks.\n- improve `always_specify_types` to support type aliases.\n- fix a false positive in `unnecessary_string_interpolations` w/ nullable interpolated\n  strings\n- fix a false positive in `avoid_function_literals_in_foreach_calls` for nullable\n  iterables.\n- fix false positives in `avoid_returning_null` w/ NNBD\n- fix false positives in `use_late_for_private_fields_and_variables` in the presence\n  of const constructors.\n- adds a new lint: `eol_at_end_of_file`.\n- fix case-sensitive false positive in `use_full_hex_values_for_flutter_colors`.\n- improve try-block and switch statement flow analysis for\n  `use_build_context_synchronously`.\n- update `use_setters_to_change_properties` to only highlight a method name, not\n  the entire body and doc comment.\n- update `unnecessary_getters_setters` to allow otherwise \"unnecessary\" getters\n  and setters with annotations.\n- update `missing_whitespace_between_adjacent_strings` to allow String\n  interpolations at the beginning and end of String literals.\n- update `unnecessary_getters_setters` to allow for setters with non-basic\n  assignments (for example, `??=` or `+=`).\n- relax `non_constant_identifier_names` to allow for a trailing underscore.\n- fix false negative in `prefer_final_parameters` where first parameter is\n  final.\n- improve `directives_ordering` sorting of directives with dot paths and\n  dot-separated package names.\n- (internal) migrate to `SecurityLintCode` instead of deprecated\n  `SecurityLintCodeWithUniqueName`.\n- (internal) fix `avoid_types_as_parameter_names` to skip field formal\n  parameters.\n- fix false positives in `prefer_interpolation_to_compose_strings` where the\n  left operand is not a String.\n- fix false positives in `only_throw_errors` for misidentified type variables.\n- add new lint: `depend_on_referenced_packages`.\n- update `avoid_returning_null_for_future` to skip checks for null-safe\n  libraries.\n- add new lint: `use_test_throws_matchers`.\n- relax `sort_child_properties_last` to accept closures after child.\n- improve performance for `prefer_contains` and `prefer_is_empty`.\n- add new lint: `noop_primitive_operations`.\n- mark `avoid_web_libraries_in_flutter` as stable.\n- add new lint: `prefer_final_parameters`.\n- update `prefer_initializing_formals` to allow assignments where identifier\n  names don't match.\n- update `directives_ordering` to checks ordering of `package:` imports in code\n  outside pub packages.\n- add simple reachability analysis to `use_build_context_synchronously` to\n  short-circuit await-discovery in terminating blocks.\n- update `use_build_context_synchronously` to recognize nullable types when\n  accessed from legacy libraries.\n\n#### Pub\n\n- `dart pub publish` now respects `.pubignore` files with gitignore-style rules.\n  `.gitignore` files in the repo are still respected if they are not overridden\n  by a `.pubignore` in the same directory.\n\n  pub no longer queries git for listing the files. This implies:\n\n  - Checked in files will now be ignored if they are included by a `.gitignore`\n    rule.\n  - Global ignores are no longer taken into account.\n  - Even packages that are not in git source control will have their\n    `.gitignore` files respected.\n  - `.gitignore` and `.pubignore` is always case-insensitive on MacOs and\n    Windows (as is default for `git` repositories).\n\n- New flag `dart pub deps --json` gives a machine parsable overview of the\n  current dependencies.\n- New command: `dart pub cache clean`. Will delete everything in your current\n  pub cache.\n- Commands related to a single package now takes a `--directory` option to\n  operate on a package in the given directory instead of the working directory.\n- git dependencies with a relative repo url would previously be interpreted\n  relative to the current package, even for transitive dependencies. This now\n  fails instead.\n\n- Pub now uses a Dart library to read and write tar files. This should fix\n  several issues we had with incompatibilities between different system `tar`s.\n- `PUB_HOSTED_URL` can now include a trailing slash.\n- Incremental compilation is now used for compilation of executables from\n  dependencies when using `dart run <package>:<command>`.\n\n#### Dart2JS\n\n*   **Breaking Change** [#46545][]: Dart2JS emits ES6+ JavaScript by default,\n    thereby no longer supporting legacy browsers. Passing the\n    `--legacy-javascript` flag will let you opt out of this update, but this\n    flag will be removed in a future release. Modern browsers will not be\n    affected, as Dart2JS continues to support [last two major releases][1] of\n    Edge, Safari, Firefox, and Chrome.\n\n[#46545]: https://github.com/dart-lang/sdk/issues/46545\n[1]: https://dart.dev/faq#q-what-browsers-do-you-support-as-javascript-compilation-targets\n\n#### Dart Dev Compiler (DDC)\n\n- **Breaking Change** [#44154][]: Subtyping relations of `package:js` classes\n  have been changed to be more correct and consistent with Dart2JS.\n  Like `anonymous` classes, non-`anonymous` classes will no longer check the\n  underlying type in DDC. The internal type representation of these objects have\n  changed as well, which will affect the `toString` value of these types.\n\n[#44154]: https://github.com/dart-lang/sdk/issues/44154\n\n## 2.13.4 - 2021-06-28\n\nThis is a patch release that fixes:\n\n- a Dart VM compiler crash (issue [flutter/flutter#84212][]).\n- a DDC compiler crash (issue [flutter/flutter#82838][]).\n\n[flutter/flutter#84212]: https://github.com/flutter/flutter/issues/84212\n[flutter/flutter#82838]: https://github.com/flutter/flutter/issues/82838\n\n## 2.13.3 - 2021-06-10\n\nThis is a patch release that fixes:\n\n- a Dart compiler crash (issue [flutter/flutter#83094][]).\n- an analysis server deadlock causing it to stop responding to IDE requests\n  (issue [#45996][]).\n- an analyzer crash when analyzing against `package:meta` `v1.4.0` (issue\n  [#46183][]).\n\n[flutter/flutter#83094]: https://github.com/flutter/flutter/issues/83094\n[#45996]: https://github.com/dart-lang/sdk/issues/45996\n[#46183]: https://github.com/dart-lang/sdk/issues/46183\n\n## 2.13.1 - 2021-05-25\n\nThis is a patch release that fixes:\n\n- incorrect behavior in CastMap (issue [#45473][]).\n- missing nullability from recursive type hierarchies in DDC (issue [#45767][]).\n\n[#45473]: https://github.com/dart-lang/sdk/issues/45473\n[#45767]: https://github.com/dart-lang/sdk/issues/45767\n\n## 2.13.0 - 2021-05-18\n\n### Language\n\n- **Type aliases** [Non-function type aliases][]: Type aliases (names for types\n  introduced via the `typedef` keyword) were previously restricted to only\n  introduce names for function types. In this release, we remove this\n  restriction and allow type aliases to name any kind of type.\n\n  ```dart\n  import 'dart:convert';\n\n  typedef JsonMap = Map<String, dynamic>;\n\n  JsonMap parseJsonMap(String input) => json.decode(input) as JsonMap;\n  ```\n\n  In addition to being usable as type annotations, type aliases that name class\n  types can now also be used anywhere that the underlying class could be used,\n  allowing type aliases to be used to safely rename existing classes.\n\n  ```dart\n  class NewClassName<T> {\n     NewClassName.create(T x);\n     static NewClassName<T> mkOne<T>(T x) => NewClassName<T>.create(x);\n   }\n  @Deprecated(\"Use NewClassName instead\")\n  typedef OldClassName<T> = NewClassName<T>;\n\n  class LegacyClass extends OldClassName<int> {\n    LegacyClass() : super.create(3);\n  }\n  OldClassName<int> legacyCode() {\n    var one = OldClassName.create(1);\n    var two = OldClassName.mkOne(2);\n    return LegacyClass();\n  }\n  ```\n\n  The new type alias feature is only available as part of the 2.13\n  [language version](https://dart.dev/guides/language/evolution). To use this\n  feature, you must set the lower bound on the sdk constraint for your package\n  to 2.13 or greater.\n\n  [non-function type aliases]:\n    https://github.com/dart-lang/language/blob/master/accepted/2.13/nonfunction-type-aliases/feature-specification.md\n\n### Core libraries\n\n#### `dart:collection`\n\n- The `SplayTreeMap` was changed to allow `null` as key if the `compare`\n  function allows it. It now checks that a new key can be used as an argument to\n  the `compare` function when the member is added, _even if the map is empty_\n  (in which case it just compares the key to itself).\n\n- The `SplayTreeSet` was changed to checks that a new element can be used as an\n  argument to the `compare` function when the member is added, _even if the set\n  is empty_ (in which case it just compares the element to itself).\n\n#### `dart:developer`\n\n- Added `serverWebSocketUri` property to `ServiceProtocolInfo`.\n\n### Dart VM\n\n### Tools\n\n#### Analyzer\n\n- Static analyses with \"error\" severity can once again be ignored with comments\n  like `// ignore: code` and `// ignore_for_file: code`. To declare that certain\n  analysis codes, or codes with certain severities (\"error\", \"warning\", and\n  \"info\") cannot be ignored with such comments, list them in\n  `analysis_options.yaml`, under the `analyzer` heading, with a new YAML key,\n  `cannot-ignore`. For example, to declare that \"error\" codes and\n  `unused_import` cannot be ignored, write the following into\n  `analysis_options.yaml`:\n\n  ```yaml\n  analyzer:\n    cannot-ignore:\n      - error\n      - unused_import\n  ```\n\n#### dart format\n\n- Correct constructor initializer indentation after `required` named parameters.\n\n#### Linter\n\nUpdated the Linter to `1.2.1`, which includes:\n\n- Improved `iterable_contains_unrelated_type` to better support `List` content\n  checks.\n- Fixed `camel_case_types` and `prefer_mixin` to support non-function type\n  aliases.\n- Fixed `prefer_mixin` to properly make exceptions for `dart.collection` legacy\n  mixins.\n- Added new lints `avoid_multiple_declarations_per_line`,\n  `use_if_null_to_convert_nulls_to_bools`, `deprecated_consistency`,\n  `use_named_constants`, `use_build_context_synchronously` (experimental).\n- Deprecated `avoid_as`.\n- Migrated library to null-safety.\n\n### Other libraries\n\n#### `package:js`\n\n- **Breaking change:** It is no longer valid to use `String`s that match an\n  `@Native` annotation in an `@JS()` annotation for a non-anonymous JS interop\n  class. This led to erroneous behavior due to the way interceptors work. If you\n  need to work with a native class, prefer `dart:html`, an `@anonymous` class,\n  or `js_util`. See issue [#44211][] for more details.\n\n[#44211]: https://github.com/dart-lang/sdk/issues/44211\n\n## 2.12.4 - 2021-04-15\n\nThis is a patch release that fixes a Dart VM compiler crashes when compiling\ninitializers containing async closures (issue [#45306][]).\n\n[#45306]: https://github.com/dart-lang/sdk/issues/45306\n\n## 2.12.3 - 2021-04-14\n\nThis is a patch release that fixes a vulnerability in `dart:html` related to DOM\nclobbering. See the [vulnerability advisory][cve-2021-22540] for more details.\nThanks again to **Vincenzo di Cicco** for finding and reporting this\nvulnerability.\n\n[cve-2021-22540]:\n  https://github.com/dart-lang/sdk/security/advisories/GHSA-3rfv-4jvg-9522\n\n## 2.12.2 - 2021-03-17\n\nThis is a patch release that fixes crashes reported by Flutter 2 users (issue\n[flutter/flutter#78167][]).\n\n[flutter/flutter#78167]: https://github.com/flutter/flutter/issues/78167\n\n## 2.12.1 - 2021-03-10\n\nThis is a patch release that fixes:\n\n- an unhandled exception in HTTPS connections (issue [#45047][]).\n- a typing issue in the typed_data `+` operator (issue [#45140][]).\n\n[#45047]: https://github.com/dart-lang/sdk/issues/45047\n[#45140]: https://github.com/dart-lang/sdk/issues/45140\n\n## 2.12.0 - 2021-03-03\n\n### Language\n\n- **Breaking Change** [Null safety][] is now enabled by default in all code that\n  has not opted out. With null safety, types in your code are non-nullable by\n  default. Null can only flow into parts of your program where you want it. With\n  null safety, your runtime null-dereference bugs turn into edit-time analysis\n  errors.\n\n  You can opt out of null safety and preserve your code's previous behavior by\n  setting the lower bound of the SDK constraint in your pubspec to 2.11.0 or\n  earlier to request an earlier [language version][]. You can opt out individual\n  Dart files by adding `// @dart=2.11` to the beginning of the file.\n\n  Files that are opted in to null safety may report new compile-time errors.\n  Opting in to null safety also gives you access to other new language features:\n\n  - Smarter flow analysis and type promotion\n  - `required` named parameters\n  - `late` variables\n  - The postfix `!` null assertion operator\n  - The `?..` and `?[]` null-aware operators\n\n- **Breaking Change** [#44660][]: Fixed an implementation bug where `this` would\n  sometimes undergo type promotion in extensions.\n\n[null safety]: https://dart.dev/null-safety/understanding-null-safety\n[language version]:\n  https://dart.dev/guides/language/evolution#language-versioning\n[#44660]: https://github.com/dart-lang/sdk/issues/44660\n\n### Core libraries\n\n#### `dart:async`\n\n- Add extension method `onError()` on `Future` to allow better typing of error\n  callbacks.\n\n#### `dart:collection`\n\n- Add `UnmodifiableSetView` class, which allows users to guarantee that methods\n  that could change underlying `Set` instance can not be invoked.\n\n- Make it explicit that `LinkedList` compares elements by identity, and update\n  `contains()` to take advantage of this.\n\n#### `dart:core`\n\n- Add `Set.unmodifiable()` constructor, which allows users to create\n  unmodifiable `Set` instances.\n\n#### `dart:io`\n\n- `HttpRequest` now correctly follows HTTP 308 redirects\n  (`HttpStatus.permanentRedirect`).\n\n#### `dart:isolate`\n\n- Add `debugName` positional parameter to `ReceivePort` and `RawReceivePort`\n  constructors, a name which can be associated with the port and displayed in\n  tooling.\n- Introduce `Isolate.exit([port, message])` which terminates current isolate\n  and, if `port` is specified, as a last action sends out the `message` out to\n  that `port`.\n\n#### `dart:html`\n\n- `EventStreamSubscription.cancel` has been updated to retain its synchronous\n  timing when running in both sound and unsound null safety modes. See issue\n  [#44157][] for more details.\n\n[#44157]: https://github.com/dart-lang/sdk/issues/44157\n\n### Dart VM\n\n- **Breaking Change** [#42312][]: `Dart_WeakPersistentHandle`s no longer\n  auto-delete themselves when the referenced object is garbage collected to\n  avoid race conditions, but they are still automatically deleted when the\n  isolate group shuts down.\n\n- **Breaking Change** [#42312][]: `Dart_WeakPersistentHandleFinalizer` is\n  renamed to `Dart_HandleFinalizer` and had its `handle` argument removed. All\n  API functions using that type have been updated.\n\n[#42312]: https://github.com/dart-lang/sdk/issues/42312\n\n### Foreign Function Interface (`dart:ffi`)\n\n- **Breaking Change** [#44621][]: Invocations with a generic `T` of `sizeOf<T>`,\n  `Pointer<T>.elementAt()`, `Pointer<T extends Struct>.ref`, and\n  `Pointer<T extends Struct>[]` are being deprecated in the current stable\n  release (2.12), and are planned to be fully removed in the following stable\n  release (2.13). Consequently, `allocate` in `package:ffi` will no longer be\n  able to invoke `sizeOf<T>` generically, and will be deprecated as well.\n  Instead, the `Allocator` it is introduced to `dart:ffi`, and also requires a\n  constant `T` on invocations. For migration notes see the breaking change\n  request.\n\n- **Breaking Change** [#44622][]: Subtypes of `Struct` without any native member\n  are being deprecated in the current stable release (2.12), and are planned to\n  be fully removed in the following stable release (2.13). Migrate opaque types\n  to extend `Opaque` rather than `Struct`.\n\n[#44621]: https://github.com/dart-lang/sdk/issues/44621\n[#44622]: https://github.com/dart-lang/sdk/issues/44622\n\n### Dart2JS\n\n- Remove `--no-defer-class-types` and `--no-new-deferred-split`.\n\n### Tools\n\n#### Analyzer\n\n- Remove the `--use-fasta-parser`, `--preview-dart-2`, and\n  `--enable-assert-initializers` command line options. These options haven't\n  been supported in a while and were no-ops.\n\n- Report diagnostics regarding the\n  [`@internal`](https://pub.dev/documentation/meta/latest/meta/internal-constant.html)\n  annotation.\n\n- Improve diagnostic-reporting regarding the\n  [`@doNotStore`](https://pub.dev/documentation/meta/latest/meta/doNotStore-constant.html)\n  annotation.\n\n- Introduce a diagnostic which is reported when a library member named `main` is\n  not a function.\n\n- Introduce a diagnostic which is reported when a `main` function's first\n  parameter is not a supertype of `List<String>`.\n\n- Introduce diagnostics for when an `// ignore` comment contains an error code\n  which is not being reported, cannot be ignored, or is already being ignored.\n\n- Report diagnostics when using\n  [`@visibleForTesting`](https://pub.dev/documentation/meta/latest/meta/\n  visibleForTesting-constant.html) on top-level variables.\n\n- Fix false positive reports of \"unused element\" for top-level setters and\n  getters.\n\n- Fix false positive reports regarding `@deprecated` field formal parameters at\n  their declaration.\n\n- For null safety, introduce a diagnostic which reports when a null-check will\n  always fail.\n\n- Fix false positive reports regarding optional parameters on private\n  constructors being unused.\n\n- Introduce a diagnostic which is reported when a constructor includes duplicate\n  field formal parameters.\n\n- Improve the \"unused import\" diagnostic when multiple import directives share a\n  common prefix.\n\n- Fix false positive \"unused import\" diagnostic regarding an import which\n  provides an extension method which is used.\n\n- For null safety, improve the messaging of \"use of nullable value\" diagnostics\n  for eight different contexts.\n\n- Fix false positive reports regarding `@visibleForTesting` members in a \"hide\"\n  combinator of an import or export directive.\n\n- Improve the messaging of \"invalid override\" diagnostics.\n\n- Introduce a diagnostic which is reported when `Future<T>.catchError` is called\n  with an `onError` callback which does not return `FutureOr<T>`.\n\n#### dartfmt\n\n- Don't duplicate comments on chained if elements.\n\n- Preserve `?` in initializing formal function-typed parameters.\n\n- Fix performance issue with constructors that have no initializer list.\n\n#### Linter\n\nUpdated the Linter to `0.1.129`, which includes:\n\n- New lints: `avoid_dynamic_calls`, `cast_nullable_to_non_nullable`,\n  `null_check_on_nullable_type_parameter`,\n  `tighten_type_of_initializing_formals`, `unnecessary_null_checks`, and\n  `avoid_type_to_string`.\n\n- Fix crash in `prefer_collection_literals` when there is no static parameter\n  element.\n\n- Fix false negatives for `prefer_collection_literals` when a LinkedHashSet or\n  LinkedHashMap instantiation is passed as the argument to a function in any\n  position other than the first.\n\n- Fix false negatives for `prefer_collection_literals` when a LinkedHashSet or\n  LinkedHashMap instantiation is used in a place with a static type other than\n  Set or Map.\n\n- Update to `package_names` to allow leading underscores.\n\n- Fix crashes in `unnecessary_null_checks` and\n  `missing_whitespace_between_adjacent_strings`.\n\n- Update to `void_checks` for null safety.\n\n- Fix range error in `unnecessary_string_escapes`.\n\n- Fix false positives in `unnecessary_null_types`.\n\n- Fix to `prefer_constructors_over_static_methods` to respect type parameters.\n\n- Update to `always_require_non_null_named_parameters` to be null safety-aware.\n\n- Update to `unnecessary_nullable_for_final_variable_declarations` to allow\n  dynamic.\n\n- Update `overridden_fields` to not report on abstract parent fields.\n\n- Fix to `unrelated_type_equality_checks` for null safety.\n\n- Improvements to `type_init_formals`to allow types not equal to the field type.\n\n- Updates to `public_member_apis` to check generic type aliases.\n\n- Fix `close_sinks` to handle `this`-prefixed property accesses.\n\n- Fix `unawaited_futures` to handle `Future` subtypes.\n\n- Performance improvements to `always_use_package_imports`,\n  `avoid_renaming_method_parameters`, `prefer_relative_imports` and\n  `public_member_api_docs`.\n\n#### Pub\n\n- **Breaking**: The Dart SDK constraint is now **required** in `pubspec.yaml`.\n  You must include a section like:\n\n  ```yaml\n  environment:\n    sdk: \">=2.10.0 <3.0.0\"\n  ```\n\n  See [#44072][].\n\n  For legacy dependencies without an SDK constraint, pub will now assume a\n  default language version of 2.7.\n\n- The top level `pub` executable has been deprecated. Use `dart pub` instead.\n  See [dart tool][].\n\n- New command `dart pub add` that adds new dependencies to your `pubspec.yaml`,\n  and a corresponding `dart pub remove` that removes dependencies.\n\n- New option `dart pub upgrade --major-versions` will update constraints in your\n  `pubspec.yaml` to match the _resolvable_ column reported in\n  `dart pub outdated`. This allows users to easily upgrade to latest version for\n  all dependencies where this is possible, even if such upgrade requires an\n  update to the version constraint in `pubspec.yaml`.\n\n  It is also possible to only upgrade the major version for a subset of your\n  dependencies using `dart pub upgrade --major-versions <dependencies...>`.\n\n- New option `dart pub upgrade --null-safety` will attempt to update constraints\n  in your `pubspec.yaml`, such that only null-safety migrated versions of\n  dependencies are allowed.\n\n- New option `dart pub outdated --mode=null-safety` that will analyze your\n  dependencies for null-safety.\n\n- `dart pub get` and `dart pub upgrade` will highlight dependencies that have\n  been [discontinued](https://dart.dev/tools/pub/publishing#discontinue) on\n  pub.dev.\n\n- `dart pub publish` will now check your pubspec keys for likely typos.\n\n- `dart pub upgrade package_foo` fetchs dependencies but ignores the\n  `pubspec.lock` for `package_foo`, allowing users to only upgrade a subset of\n  dependencies.\n\n- New command `dart pub login` that logs in to pub.dev.\n\n- The `--server` option to `dart pub publish` and `dart pub uploader` are\n  deprecated. Use `publish_to` in your `pubspec.yaml` or set the\n  `$PUB_HOSTED_URL` environment variable.\n\n- `pub global activate` no longer re-precompiles if the current global\n  installation was same version.\n\n- The Flutter SDK constraint upper bound is now ignored in pubspecs and\n  deprecated when publishing. See: [flutter-upper-bound-deprecation][].\n\n[flutter-upper-bound-deprecation]:\n  https://dart.dev/go/flutter-upper-bound-deprecation\n[#44072]: https://github.com/dart-lang/sdk/issues/44072\n[dart tool]: https://dart.dev/tools/dart-tool\n\n## 2.10.5 - 2021-01-21\n\nThis is a patch release that fixes a crash in the Dart VM. (issue [#44563][]).\n\n[#44563]: https://github.com/dart-lang/sdk/issues/44563\n\n## 2.10.4 - 2020-11-12\n\nThis is a patch release that fixes a crash in the Dart VM (issues [#43941][],\n[flutter/flutter#43620][], and [Dart-Code/Dart-Code#2814][]).\n\n[#43941]: https://github.com/dart-lang/sdk/issues/43941\n[flutter/flutter#43620]: https://github.com/flutter/flutter/issues/43620\n[dart-code/dart-code#2814]: https://github.com/Dart-Code/Dart-Code/issues/2814\n\n## 2.10.3 - 2020-10-29\n\nThis is a patch release that fixes the following issues:\n\n- breaking changes in Chrome 86 that affect DDC (issues [#43750][] and\n  [#43193][]).\n- compiler error causing incorrect use of positional parameters when named\n  parameters should be used instead (issues [flutter/flutter#65324][] and\n  [flutter/flutter#68092][]).\n- crashes and/or undefined behavor in AOT compiled code (issues [#43770][] and\n  [#43786][]).\n- AOT compilation of classes with more than 64 unboxed fields (issue\n  [flutter/flutter#67803][]).\n\n[#43750]: https://github.com/dart-lang/sdk/issues/43750\n[#43193]: https://github.com/dart-lang/sdk/issues/43193\n[flutter/flutter#65324]: https://github.com/flutter/flutter/issues/65324\n[flutter/flutter#68092]: https://github.com/flutter/flutter/issues/68092\n[#43770]: https://github.com/dart-lang/sdk/issues/43770\n[#43786]: https://github.com/dart-lang/sdk/issues/43786\n[flutter/flutter#67803]: https://github.com/flutter/flutter/issues/67803\n\n## 2.10.2 - 2020-10-15\n\nThis is a patch release that fixes a DDC compiler crash (issue [#43589]).\n\n[#43589]: https://github.com/dart-lang/sdk/issues/43589\n\n## 2.10.1 - 2020-10-06\n\nThis is a patch release that fixes the following issues:\n\n- crashes when developing Flutter applications (issue [#43464][]).\n- non-deterministic incorrect program behaviour and/or crashes (issue\n  [flutter/flutter#66672][]).\n- uncaught TypeErrors in DDC (issue [#43661][]).\n\n[#43464]: https://github.com/dart-lang/sdk/issues/43464\n[flutter/flutter#66672]: https://github.com/flutter/flutter/issues/66672\n[#43661]: https://github.com/dart-lang/sdk/issues/43661\n\n## 2.10.0 - 2020-09-28\n\n### Core libraries\n\n#### `dart:io`\n\n- Adds `Abort` method to class `HttpClientRequest`, which allows users to cancel\n  outgoing HTTP requests and stop following IO operations.\n- A validation check is added to `path` of class `Cookie`. Having characters\n  ranging from 0x00 to 0x1f and 0x3b (\";\") will lead to a `FormatException`.\n- The `HttpClient` and `HttpServer` classes now have a 1 MiB limit for the total\n  size of the HTTP headers when parsing a request or response, instead of the\n  former 8 KiB limit for each header name and value. This limit cannot be\n  configured at this time.\n\n#### `dart:typed_data`\n\n- Class `BytesBuilder` is moved from `dart:io` to `dart:typed_data`. It's\n  temporarily being exported from `dart:io` as well.\n\n### `dart:uri`\n\n- [#42564]: Solved inconsistency in `Uri.https` and `Uri.http` constructors'\n  `queryParams` type.\n\n### Dart VM\n\n- **Breaking Change** [#42982][]: `dart_api_dl.cc` is renamed to `dart_api_dl.c`\n  and changed to a pure C file.\n- Introduces `Dart_FinalizableHandle`s. They do auto-delete, and the weakly\n  referred object cannot be accessed through them.\n\n### Dart2JS\n\n- Adds support for deferred loading of types seperately from classes. This\n  enables dart2js to make better optimization choices when deferred loading.\n  This work is necessary to address unsoundness in the deferred loading\n  algorithm. Currently, fixing this unsoundness would result in code bloat, but\n  loading types seperately from classes will allow us to fix the unsoundness\n  with only a minimal regression. To explicitly disable deferred loading of\n  types, pass `--no-defer-class-types`. See the original post on the\n  [unsoundness in the deferred loading algorithm][].\n- Enables a new sound deferred splitting algorithm. To explicitly disable the\n  new deferred splitting algorithm, pass `--no-new-deferred-split`. See the\n  original post on the [unsoundness in the deferred loading algorithm][].\n\n[#42982]: https://github.com/dart-lang/sdk/issues/42982\n[unsoundness in the deferred loading algorithm]:\n  https://github.com/dart-lang/sdk/blob/302ad7ab2cd2de936254850550aad128ae76bbb7/CHANGELOG.md#dart2js-3\n\n### Tools\n\n#### dartfmt\n\n- Don't crash when non-ASCII whitespace is trimmed.\n- Split all conditional expressions (`?:`) when they are nested.\n- Handle `external` and `abstract` fields and variables.\n\n#### Linter\n\nUpdated the Linter to `0.1.118`, which includes:\n\n- New lint: `unnecessary_nullable_for_final_variable_declarations`.\n- Fixed NPE in `prefer_asserts_in_initializer_lists`.\n- Fixed range error in `unnecessary_string_escapes`.\n- `unsafe_html` updated to support unique error codes.\n- Updates to `diagnostic_describe_all_properties` to check for `Diagnosticable`s\n  (not `DiagnosticableMixin`s).\n- New lint: `use_late`.\n- Fixed `unnecessary_lambdas` to respect deferred imports.\n- Updated `public_member_api_docs` to check mixins.\n- Updated `unnecessary_statements` to skip `as` expressions.\n- Fixed `prefer_relative_imports` to work with path dependencies.\n\n#### Pub\n\n- `pub run` and `pub global run` accepts a `--(no-)-sound-null-safety` flag,\n  that is passed to the VM.\n- Fix: Avoid multiple recompilation of binaries in global packages.\n- Fix: Avoid exponential behaviour of error reporting from the solver.\n- Fix: Refresh binstubs after recompile in global run.\n\n## 2.9.3 - 2020-09-08\n\nThis is a patch release that fixes DDC to handle a breaking change in Chrome\n(issue [#43193][]).\n\n[#43193]: https://github.com/dart-lang/sdk/issues/43193\n\n## 2.9.2 - 2020-08-26\n\nThis is a patch release that fixes transient StackOverflow exceptions when\nbuilding Flutter applications (issue [flutter/flutter#63560][]).\n\n[flutter/flutter#63560]: https://github.com/flutter/flutter/issues/63560\n\n## 2.9.1 - 2020-08-12\n\nThis is a patch release that fixes unhandled exceptions in some Flutter\napplications (issue [flutter/flutter#63038][]).\n\n[flutter/flutter#63038]: https://github.com/flutter/flutter/issues/63038\n\n## 2.9.0 - 2020-08-05\n\n### Language\n\n### Core libraries\n\n#### `dart:async`\n\n- Adds `Stream.multi` constructor creating streams which can be listened to more\n  than once, and where each individual listener can be controlled independently.\n\n#### `dart:convert`\n\n- **Breaking Change** [#41100][]: When encoding a string containing unpaired\n  surrogates as UTF-8, the unpaired surrogates will be encoded as replacement\n  characters (`U+FFFD`). When decoding UTF-8, encoded surrogates will be treated\n  as malformed input. When decoding UTF-8 with `allowMalformed: true`, the\n  number of replacement characters emitted for malformed input sequences has\n  been changed to match the [WHATWG encoding standard][].\n\n[#41100]: https://github.com/dart-lang/sdk/issues/41100\n[whatwg encoding standard]: https://encoding.spec.whatwg.org/#utf-8-decoder\n\n#### `dart:io`\n\n- [#42006][]: The signature of `exit` has been changed to return the `Never`type\n  instead of `void`. since no code will run after it,\n- Class `OSError` now implements `Exception`. This change means `OSError` will\n  now be caught in catch clauses catching `Exception`s.\n- Added `InternetAddress.tryParse`.\n- [Abstract Unix Domain Socket][] is supported on Linux/Android now. Using an\n  `InternetAddress` with `address` starting with '@' and type being\n  `InternetAddressType.Unix` will create an abstract Unix Domain Socket.\n- On Windows, file APIs can now handle files and directories identified by long\n  paths (greater than 260 characters). It complies with all restrictions from\n  [Long Path on Windows][]. Note that `Directory.current` does not work with\n  long path.\n\n[#42006]: https://github.com/dart-lang/sdk/issues/42006\n[abstract unix domain socket]: http://man7.org/linux/man-pages/man7/unix.7.html\n[long path on windows]:\n  https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file#maximum-path-length-limitation\n\n#### `dart:html`\n\n- **Breaking Change**: `CssClassSet.add()` previously returned `null` if the\n  `CssClassSet` corresponded to multiple elements. In order to align with the\n  null-safe changes in the `Set` interface, it will now return `false` instead.\n  The same applies for `CssClassSet.toggle`.\n\n- `EventStreamSubscription.cancel` method used to return `null`, but since\n  `StreamSubscription.cancel` has changed to be non-nullable, this method\n  returns an empty `Future` instead. Due to an optimization on `null` `Future`s,\n  this method used to complete synchronously, but now that the `Future` is empty\n  instead, it completes asynchronously, therefore potentially invalidating code\n  that relied on the synchronous side-effect. This change will only affect code\n  using sound null-safety. See issue [#41653][] for more details.\n\n- Methods in `Console` have been updated to better reflect the modern Console\n  specification. Particularly of interest are `dir` and `table` which take in\n  extra optional arguments.\n\n[#41653]: https://github.com/dart-lang/sdk/issues/41653\n\n#### `dart:mirrors`\n\n- **Breaking Change** [#42714][]: web compilers (dart2js and DDC) now produce a\n  compile-time error if `dart:mirrors` is imported.\n\n  Most projects should not be affected. Since 2.0.0 this library was unsupported\n  and produced runtime errors on all its APIs. Since then several tools already\n  reject code that use `dart:mirrors` including webdev and flutter tools, we\n  expect few projects to run into this problem.\n\n[#42714]: https://github.com/dart-lang/sdk/issues/42714\n\n### Tools\n\n#### dartfmt\n\n- Add `--fix-single-cascade-statements`.\n- Correctly handle `var` in `--fix-function-typedefs`.\n- Preserve leading indentation in fixed doc comments.\n- Split outer nested control flow elements.\n- Always place a blank line after script tags.\n- Don't add unneeded splits on if elements near comments.\n- Indent blocks in initializers of multiple-variable declarations.\n- Update the null-aware subscript syntax from `?.[]` to `?[]`.\n\n#### Analyzer\n\n- Static analyses with a severity of \"error\" can no longer be ignored with\n  comments (`// ignore: code` and `// ignore_for_file: code`).\n\n#### Linter\n\nUpdated the Linter to `0.1.117`, which includes:\n\n- New lint: `do_not_use_environment`.\n- New lint: `exhaustive_cases`.\n- New lint: `no_default_cases` (experimental).\n- New lint: `sized_box_for_whitespace`.\n- New lint: `use_is_even_rather_than_modulo`.\n- Updated `directives_ordering` to remove third party package special-casing.\n- Updated `prefer_is_empty` to special-case assert initializers and const\n  contexts.\n- Updated `prefer_mixin` to allow \"legacy\" SDK abstract class mixins.\n- Updated `sized_box_for_whitespace` to address false-positives.\n- Updated `type_annotate_public_apis` to allow inferred types in final field\n  assignments.\n- Updated `unnecessary_lambdas` to check for tear-off assignability.\n- Updated `unsafe_html` to use a `SecurityLintCode` (making it un-ignorable) and\n  to include `Window.open`, `Element.html` and `DocumentFragment.html` in unsafe\n  API checks. Also added checks for attributes and methods on extensions.\n\n### Dart VM\n\n- **Breaking Change** [#41100][]: When printing a string using the `print`\n  function, the default implementation (used when not overridden by the embedder\n  or the current zone) will print any unpaired surrogates in the string as\n  replacement characters (`U+FFFD`). Similarly, the `Dart_StringToUTF8` function\n  in the Dart API will convert unpaired surrogates into replacement characters.\n\n### Pub\n\n- `pub run` and `pub global run` accepts a `--enable-experiment` flag enabling\n  experiments in the Dart VM (and language).\n- Warn when publishing the first null-safe version of a package.\n- `pub outdated`:\n  - If the current version of a dependency is a prerelease version, use\n    prereleases for latest if there is no newer stable.\n  - Don't require a `pubspec.lock` file. When the lockfile is missing, the\n    **Current** column is empty.\n- `pub upgrade`: Show summary count of outdated packages after running. It will\n  also only show newer packages if they are not prereleases or the package is\n  already a prerelease.\n- Publishing Flutter plugins using the old plugin format is no longer allowed.\n  Plugins using the old plugin format can still be consumed.\n- `pub run`: Fix precompilation with relative `PUB_CACHE` paths\n  ([#2486](https://github.com/dart-lang/pub/pull/2486)).\n- Preserve Windows line endings in `pubspec.lock` if they are already there\n  ([#2489](https://github.com/dart-lang/pub/pull/2489)).\n- Better terminal color-detection. Use colors in terminals on Windows.\n- Fix git folder names in cache, allowing for ssh-style git dependencies.\n- Fix: Avoid precompilation of dependencies of global packages.\n\n## 2.8.4 - 2020-06-04\n\nThis is a patch release that fixes potential memory leaks in the Dart front-end\n(issues [#42111][] and [#42112][]).\n\n[#42111]: https://github.com/dart-lang/sdk/issues/42111\n[#42112]: https://github.com/dart-lang/sdk/issues/42112\n\n## 2.8.3 - 2020-05-28\n\nThis is a patch release that fixes the following issues:\n\n- crashes in Flutter apps (issue [flutter/flutter#57318][]).\n- a regression in stack traces (issue [#41907][]).\n- re-canonicalization of constants with unboxed fields (issue\n  [flutter/flutter#57190][]).\n\n[flutter/flutter#57318]: https://github.com/flutter/flutter/issues/57318\n[#41907]: https://github.com/dart-lang/sdk/issues/41907\n[flutter/flutter#57190]: https://github.com/flutter/flutter/issues/57190\n\n## 2.8.2 - 2020-05-13\n\nThis is a patch release that fixes an AOT compilation bug in global\ntransformations which manifests as a NoSuchMethod exception (issue\n[flutter/flutter#56479][]).\n\n[flutter/flutter#56479]: https://github.com/flutter/flutter/issues/56479\n\n## 2.8.1 - 2020-05-06\n\nMuch of the changes in this release are in preparation for non-nullable types,\nwhich will arrive in a future version. In anticipation of that, we have made a\nnumber of small but technically breaking changes to several core library APIs in\norder to make them easier to use in a world with non-nullable types. Almost all\nexisting Dart code will be unaffected by these changes, but if you see\nunexpected failures, note the breaking changes listed below.\n\n### Language\n\nThere are no new language features in this release. There are only two minor\nbreaking changes:\n\n- **Breaking change** [#40675][]: Fixed an implementation bug where local\n  variable inference would incorrectly use the promoted type of a type variable.\n\n- **Breaking change** [#41362][]: Dart 2.0.0 made the clauses\n  `implements Function`, `extends Function`, or `with Function` have no effect\n  (spec section 19.6). We fixed an implementation bug that may be visible on\n  some rare scenarios.\n\n[#40675]: https://github.com/dart-lang/sdk/issues/40675\n[#41362]: https://github.com/dart-lang/sdk/issues/41362\n\n### Core libraries\n\n#### `dart:async`\n\n- **Breaking change** [#40676][]: Changed the return type of\n  `StreamSubscription.cancel()` to `Future<void>`. Previously, it was declared\n  to return `Future` and was allowed to return `null` at runtime.\n\n- **Breaking change** [#40681][]: The `runZoned()` function is split into two\n  functions: `runZoned()` and `runZonedGuarded()`, where the latter has a\n  required `onError` parameter, and the former has none. This prepares the\n  functions for null safety where the two functions will differ in the\n  nullability of their return types.\n\n- **Breaking change** [#40683][]: Errors passed to `Completer.completeError()`,\n  `Stream.addError()`, `Future.error()`, etc. can no longer be `null`. These\n  operations now _synchronously_ throw an exception if passed a `null` error.\n\n- Make stack traces non-null [#40130][]. Where methods like\n  `completer.completeError()` allow omitting a stack trace, the platform will\n  now insert a default stack trace rather than propagate a `null` value.\n\n  Error handling functions need no longer be prepared for `null` stack traces.\n\n[#40676]: https://github.com/dart-lang/sdk/issues/40676\n[#40681]: https://github.com/dart-lang/sdk/issues/40681\n[#40683]: https://github.com/dart-lang/sdk/issues/40683\n[#40130]: https://github.com/dart-lang/sdk/issues/40130\n\n#### `dart:core`\n\n- **Breaking change** [#40674][]: Three members on `RuneIterator` no longer\n  return `null` when accessed before the first call to `moveNext()`. Instead,\n  `current` and `rawIndex` return `-1` and `currentAsString` returns an empty\n  string.\n\n- **Breaking change** [#40678][]: The `String.fromEnvironment()` default value\n  for `defaultValue` is now an empty string instead of `null`. Likewise, the\n  default value for `int.fromEnvironment()`'s `defaultValue` parameter is zero.\n  Under null safety, a constructor cannot return `null`, so this prepares these\n  APIs for that.\n\n- The class `CastError` is deprecated, and all implementation specific classes\n  implementing `TypeError` or `CastError` now implement both. In a future\n  release, `CastError` will be removed. See issue [40763][] for details.\n\n- Adds `StackTrace.empty` constant which is the stack trace used as default\n  stack trace when no better alternative is available.\n\n- The class `TypeError` no longer extends `AssertionError`. This also means that\n  it no longer inherits the spurious `message` getter which was added to\n  `AssertionError` when the second operand to `assert` was allowed. The value of\n  that getter on a `TypeError` was the same string as returned by `toString()`,\n  so it is still available.\n\n- `ArgumentError.checkNotNull()` and the `RangeError` static methods\n  `checkValueInInterval()`, `checkValidIndex()` and `checkNotNegative()` all\n  return their first argument on success. This makes these functions more\n  convenient to use in-line in, for example, `=>` function bodies or constructor\n  initialization lists.\n\n[#40674]: https://github.com/dart-lang/sdk/issues/40674\n[#40678]: https://github.com/dart-lang/sdk/issues/40678\n[40763]: https://github.com/dart-lang/sdk/issues/40763\n\n#### `dart:developer`\n\n- The constructors for `TimelineTask` now accept an optional `filterKey`\n  parameter. If provided, the arguments for all events associated with the task\n  will contain an entry named `filterKey`, set to the value of the `filterKey`\n  parameter provided in the constructor. This will be used by tooling to allow\n  for better filtering of timeline events.\n\n#### `dart:html`\n\n- **Breaking Change** [#39627][]: Changed the return type of several HTML native\n  methods involving futures. In return types that matched `Future<List<T>>`,\n  `T was` changed to `dynamic`. These methods would have resulted in a runtime\n  error if they were used.\n\n- **Breaking Change**: `Node.insertAllBefore()` erroneously had a return type of\n  `Node`, even though it was not returning anything. This has been corrected to\n  `void`.\n\n[#39627]: https://github.com/dart-lang/sdk/issues/39627\n\n#### `dart:io`\n\n- Class `HttpParser` will no longer throw an exception when a HTTP response\n  status code is within [0, 999]. Customized status codes in this range are now\n  valid.\n\n- **Breaking change** [#33501][]: The signature of `HttpHeaders` methods `add()`\n  and `set` have been changed to:\n\n  ```dart\n  void add(String name, Object value, {bool preserveHeaderCase: false})\n  void set(String name, Object value, {bool preserveHeaderCase: false})\n  ```\n\n  Setting `preserveHeaderCase` to `true` preserves the case of the `name`\n  parameter instead of converting it to lowercase. The `HttpHeader.forEach()`\n  method provides the current case of each header.\n\n  This is breaking only for classes extending or implementing `HttpHeaders` and\n  having their own `add` or `set` methods without the `bool preserveHeaderCase`\n  named parameter.\n\n- **Breaking change** [#40702][]: The `Socket` class now throws a\n  `SocketException` if the socket has been explicitly destroyed or upgraded to a\n  secure socket upon setting or getting socket options. Previously, setting a\n  socket option would be ignored and getting a socket option would return\n  `null`.\n\n- **Breaking change** [#40483][]: The `Process` class now throws a `StateError`\n  if the process is detached (`ProcessStartMode.detached` and\n  `ProcessStartMode.detachedWithStdio`) upon accessing the `exitCode` getter. It\n  now also throws when not connected to the child process's stdio\n  (`ProcessStartMode.detached` and `ProcessStartMode.inheritStdio`) upon\n  accessing the `stdin`, `stdout`, and `stderr` getters. Previously, these\n  getters would all return `null`.\n\n- **Breaking change** [#40706][]: The dummy object returned if `FileStat.stat()`\n  or `FileStat.statSync()` fail now contains Unix epoch timestamps instead of\n  `null` for the `accessed`, `changed`, and `modified` getters.\n\n- **Breaking change** [#40709][]: The `HeaderValue` class now parses more\n  strictly in two invalid edge cases. This is the class used to parse the\n  semicolon delimited parameters used in the `Accept`, `Authorization`,\n  `Content-Type`, and other such HTTP headers.\n\n  The empty parameter value without double quotes (which is not allowed by the\n  standards) is now parsed as the empty string rather than `null`. E.g.\n  `HeaderValue.parse(\"v;a=\").parameters` now gives `{\"a\": \"\"}` rather than\n  `{\"a\": null}`.\n\n  Invalid inputs with unbalanced double quotes are now rejected. E.g.\n  `HeaderValue.parse('v;a=\"b').parameters` will now throw a `HttpException`\n  instead of giving `{\"a\": \"b\"}`.\n\n- The `HeaderValue.toString()` method now supports parameters with `null` values\n  by omitting the value. `HeaderValue(\"v\", {\"a\": null, \"b\": \"c\"}).toString()`\n  now gives `v; a; b=c`. This behavior can be used to implement some features in\n  the `Accept` and `Sec-WebSocket-Extensions` headers.\n\n  Likewise the empty value and values using characters outside of [RFC 7230\n  tokens][] are now correctly implemented by double quoting such values with\n  escape sequences. For example:\n\n  ```dart\n  HeaderValue(\"v\",\n      {\"a\": \"A\", \"b\": \"(B)\", \"c\": \"\", \"d\": \"\u00f8\", \"e\": \"\\\\\\\"\"}).toString()\n  ```\n\n  Gives: `v;a=A;b=\"(B)\";c=\"\";d=\"\u00f8\";e=\"\\\\\\\"\"`.\n\n- [Unix domain sockets][] are now supported on Linux, Android and MacOS, which\n  can be used by passing a `InternetAddress` of `InternetAddressType.Unix` into\n  the `connect()`, `startConnect()` and `bind()` methods. The `port` argument in\n  those methods will be ignored. The `port` getter always returns 0 for Unix\n  domain sockets.\n\n- Class `InternetAddressType` gains one more option `Unix`, which represents a\n  Unix domain address.\n\n- Class `InternetAddress`:\n\n  - `InternetAddress` constructor gains an optional `type` parameter. To create\n    a Unix domain address, `type` is set to `InternetAddressType.Unix` and\n    `address` is a file path.\n\n  - `InternetAddress` gains a new constructor `fromRawAddress()` that takes an\n    address in byte format for Internet addresses or raw file path for Unix\n    domain addresses.\n\n- **Breaking change** [#40681][]: The static methods `runZoned()` and\n  `runWithHttpOverrides()` on `HttpOverrides` no longer accept\n  `zoneSpecification` and `onError` parameters. Use the `runZoned()` or\n  `runZonedGuarded()` functions from `dart:async` directly if needing to specify\n  those.\n\n- Class `HttpClient` and `HttpServer`, when receiving `HttpRequest` or\n  `HttpClientResponse`, will now put a 8K size limit on its header fields and\n  values.\n\n[#33501]: https://github.com/dart-lang/sdk/issues/33501\n[#40702]: https://github.com/dart-lang/sdk/issues/40702\n[#40483]: https://github.com/dart-lang/sdk/issues/40483\n[#40706]: https://github.com/dart-lang/sdk/issues/40706\n[#40709]: https://github.com/dart-lang/sdk/issues/40709\n[rfc 7230 tokens]: https://tools.ietf.org/html/rfc7230#section-3.2.6\n[unix domain sockets]: https://en.wikipedia.org/wiki/Unix_domain_socket\n\n#### `dart:mirrors`\n\n- Added `MirrorSystem.neverType`.\n\n### Dart VM\n\n- Added `Dart_TypeDynamic`, `Dart_TypeVoid` and `Dart_TypeNever`. Type `dynamic`\n  can no longer by reached using `Dart_GetType(dart:core, dynamic)`.\n\n- Added the following methods to the VM embedding API:\n\n  - `Dart_GetNonNullableType()`\n  - `Dart_GetNullableType()`\n  - `Dart_TypeToNonNullable()`\n  - `Dart_TypeToNullable()`\n  - `Dart_IsLegacyType()`\n  - `Dart_IsNonNullableType()`\n  - `Dart_IsNullableType()`\n\n### Foreign Function Interface (`dart:ffi`)\n\n- **Breaking Change**: Changed `Pointer.asFunction()` and\n  `DynamicLibrary.lookupFunction()` to extension methods. Invoking them\n  dynamically previously already threw an exception, so the runtime behavior\n  stays the same. However, the extension methods are only visible if `dart:ffi`\n  is imported directly. This breaks code where `dart:ffi` is not directly\n  imported. To fix, add:\n\n  ```dart\n  import 'dart:ffi';\n  ```\n\n### Tools\n\n#### Dart Dev Compiler (DDC)\n\nWe fixed several inconsistencies between DDC and Dart2JS so that users less\nfrequently encounter code that is accepted by one compiler but then fails in the\nother.\n\n- **Breaking Change**: Deleted the legacy (analyzer based) version of DDC. For\n  additional details see the [announcement][ddc].\n\n  - The `--kernel` option is now ignored and defaults to true. There is no\n    longer any way to invoke the legacy (analyzer based) version of DDC.\n\n  - Command line arguments that were only used for the legacy DDC have been\n    removed.\n\n  - The pre-compiled `dart_sdk.js` artifacts generated by legacy DDC have been\n    deleted from `dart-sdk/lib/dev_compiler` in favor of the versions located at\n    `dart-sdk/lib/dev_compiler/kernel`.\n\n- **Breaking Change**: Functions passed to JavaScript using the recommended\n  `package:js` interop specification must now be wrapped with a call to\n  `allowInterop`. This behavior was always enforced by Dart2JS, but was not\n  enforced consistently by DDC. It is now enforced by both.\n\n- **Breaking Change**: Constructors in `@JS()` classes must be marked with\n  `external`. Previously the `external` could be omitted in some cases with DDC\n  but doing so would cause incorrect behavior with Dart2JS.\n\n- JS interop classes with an index operator are now static errors.\n\n- All remaining support from the `dart:mirrors` library has been removed. Use of\n  this library on the web has been unsupported and prevented by the Dart build\n  systems since Dart v2.0.0. All known exception cases have been cleaned up.\n  This change makes DDC and Dart2JS now behave consistently.\n\n  The library can still be imported on web apps, but all APIs throw. In a future\n  breaking change release, imports to this library will likely become a\n  compile-time error.\n\n[ddc]: https://github.com/dart-lang/sdk/issues/38994\n\n#### Dart2JS\n\nA new representation of runtime types is enabled by default.\n\nThis change is part of a long term goal of making runtime checks cheaper and\nmore flexible for upcoming changes in the language. The new representation\ndisentangles how types and classes are represented and makes types first-class\nto the compiler. This makes it possible to do certain kind of optimizations on\ntype checks that were not possible before and will enable us to model\nnon-nullable types in the near future.\n\nThis change should not affect the semantics of your application, but it has some\nrelatively small visible effects that we want to highlight:\n\n- Types are now canonicalized, this fixes a long standing bug that Types could\n  not be used in switch cases (issue [17207][]).\n\n- Code-size changes may be visible, but the difference is small overall. It is\n  more visible on smaller apps because the new implementation includes more\n  helper methods. On large apps we have even seen an overall code-size\n  reduction.\n\n- Certain checks are a lot faster. This is less noticeable if you are compiling\n  apps with `-O3` where checks are omitted altogether. Even with `-O3`, the\n  performance of some `is` checks used by your app may improve.\n\n- When using `-O3` and `-O4` incorrect type annotations could surface as errors.\n  The old type representation was accidentally lenient on some invalid type\n  annotations. We have only encountered this issue on programs that were not\n  tested properly at the js-interop program boundary.\n\n- `Type.toString()` has a small change that is rarely visible. For a long time,\n  Dart2JS has had support to erase unused type variables. Today, when Dart2JS is\n  given `--lax-runtime-type-to-string` (currently included in `-O2`, `-O3`, and\n  `-O4`) and it decides to erase the type variable of a class `Foo<T>`, then it\n  compiles expressions like `foo.runtimeType.toString()` to print `Foo`. With\n  the new representation, this will show `Foo<erased>` instead. This change may\n  be visible in error messages produced by type checks involving erased types.\n\nBecause types and classes are represented separately, we will likely reevaluate\nrestrictions of deferred libraries in the near future. For example, we could\nsupport referring to deferred types because types can be downloaded while\nclasses are not.\n\nIn the unlikely case you run into any issues, please file a bug so we can\ninvestigate. You can temporarily force the old type representation by passing\n`--use-old-rti` to Dart2JS if necessary, but our goal is to delete the old type\nrepresentation soon.\n\nIn addition, we fixed some inconsistencies between Dart2JS and DDC:\n\n- JS interop classes with an index operator are now static errors instead of\n  causing invalid code in Dart2JS.\n\n- **Breaking Change**: The subtyping rule for generic functions is now more\n  forgiving. Corresponding type parameter bounds now only need to be mutual\n  subtypes rather than structurally equal up to renaming of bound type variables\n  and equating all top types.\n\n- **Breaking Change**: Types are now normalized. See [normalization][] for the\n  full specification. Types will now be printed in their normal form, and mutual\n  subtypes with the same normal form will now be considered equal.\n\n- **Breaking Change**: Constructors in `@JS()` classes must be marked with\n  `external`. Previously, the external could be omitted for unused constructors.\n  Omitting `external` for a constructor which is used would cause incorrect\n  behavior at runtime, now omitting it on any constructor is a static error.\n\n[17207]: https://github.com/dart-lang/sdk/issues/17207\n[normalization]:\n  https://github.com/dart-lang/language/blob/master/resources/type-system/normalization.md\n\nOther dart2js changes:\n\n- **Breaking Change**: The `--package-root` flag, which was hidden and disabled\n  in Dart 2.0.0, has been completely removed. Passing this flag will now cause\n  `dart2js` to fail.\n\n#### Linter\n\nUpdated the Linter to `0.1.114`, which includes:\n\n- Fixed `avoid_shadowing_type_parameters` to support extensions and mixins.\n- Updated `non_constant_identifier_names` to allow named constructors made up of\n  only underscores (`_`).\n- Updated `avoid_unused_constructor_parameters` to ignore unused params named in\n  all underscores (`_`).\n\n#### Analyzer\n\n- Removed support for the deprecated analysis options file name\n  `.analysis_options`.\n\n#### Pub\n\n- Added `pub outdated` command which lists outdated package dependencies, and\n  gives advice on how to upgrade.\n\n- `pub get` and `pub upgrade` now fetch version information about hosted\n  dependencies in parallel, improving the time package resolution performance.\n\n- `pub get` and `pub upgrade` no longer precompile executables from dependencies\n  by default. Instead they are precompiled on first `pub run`. Use\n  `pub get --precompile` to get the previous behavior.\n\n- Fixed missing retries of DNS failures during `pub get`.\n\n- If code contains imports for packages not listed in the package's\n  `pubspec.yaml` then `pub publish` will reject the package.\n\n- `pub publish` no longer requires the presence of a `homepage` field, if the\n  `repository` field is provided.\n\n- `pub publish` warns if non-pre-release packages depends on pre-release\n  packages or pre-release Dart SDKs.\n\n- Relative paths in `pubspec.lock` now use `/` also on Windows to make the file\n  sharable between machines.\n\n- Fixed language version in [`.dart_tool/package_config.json`][package config]\n  for packages without an explicit SDK constraint. Pub now writes an empty\n  language version where before the language version of the current SDK would be\n  used.\n\n- `%LOCALAPPDATA%` is now preferred over `%APPDATA%` when creating a pub cache\n  directory on Windows. `%LOCALAPPDATA%` is not copied when users roam between\n  devices.\n\n- `pub publish` warns if LICENSE and README.md files are not called those exact\n  names.\n\n- `pub repair cache` downloads hosted packages in parallel.\n\n[package config]:\n  https://github.com/dart-lang/language/blob/master/accepted/future-releases/language-versioning/package-config-file-v2.md\n\n## 2.7.2 - 2020-03-23\n\nThis is a patch release that addresses a vulnerability in `dart:html`\n[NodeValidator][] related to DOM clobbering of `previousSibling`. See the\n[vulnerability advisory][cve-2020-8923] for more details. Thanks to **Vincenzo\ndi Cicco** for finding and reporting this issue.\n\nThis release also improves compatibility with ARMv8 processors (issue [40001][])\nand dart:io stability (issue [40589][]).\n\n[nodevalidator]: https://api.dart.dev/stable/dart-html/NodeValidator-class.html\n[cve-2020-8923]:\n  https://github.com/dart-lang/sdk/security/advisories/GHSA-hfq3-v9pv-p627\n[40001]: https://github.com/dart-lang/sdk/issues/40001\n[40589]: https://github.com/dart-lang/sdk/issues/40589\n\n## 2.7.1 - 2020-01-23\n\nThis is a patch release that improves dart2js compile-time (issue [40217][]).\n\n[40217]: https://github.com/dart-lang/sdk/issues/40217\n\n**Breaking Change**: The Dart SDK for macOS is now only available for x64 (issue\n[39810][]).\n\n[39810]: https://github.com/dart-lang/sdk/issues/39810\n\n## 2.7.0 - 2019-12-11\n\n**Extension methods** -- which we shipped in preview in 2.6.0 -- are no longer\nin preview, and are now officially supported as of 2.7.0. Learn more about them\nhere:\n\nhttps://medium.com/dartlang/extension-methods-2d466cd8b308\n\n### Language\n\n- **Breaking Change**: [Static extension members][] are accessible when imported\n  with a prefix (issue [671][]). In the extension method **preview** launch,\n  importing a library with a prefix hid all extension members in addition to\n  hiding the extension name, thereby making them inaccessible in the importing\n  library except via the explicit override syntax. Based on user feedback, we\n  have changed this to make extensions methods accessible even when imported\n  with a prefix.\n\n      ```dart\n        // \"thing.dart\"\n        class Thing {\n        }\n        extension Show on Thing {\n          void show() {\n            print(\"This is a thing\");\n          }\n       }\n       // \"client.dart\"\n       import \"thing.dart\" as p;\n       void test() {\n         p.Thing().show(); // Previously an error, now resolves to Show.show\n       }\n      ```\n\n[static extension members]:\n  https://github.com/dart-lang/language/blob/master/accepted/2.6/static-extension-members/feature-specification.md\n[671]: https://github.com/dart-lang/language/issues/671\n\n### Core libraries\n\n#### `dart:io`\n\n- **Breaking change**: Added `IOOverrides.serverSocketBind` to aid in writing\n  tests that wish to mock `ServerSocket.bind`.\n\n#### `dart:typed_data`\n\n- Added new constructors, `.sublistView(TypedData, [start, end])` to all\n  `TypedData` classes. The constructor makes it easier, and less error-prone, to\n  create a view of (a slice of) another `TypedData` object.\n\n### Dart VM\n\n- New fields added to existing instances by a reload will now be initialized\n  lazily, as if the field was a late field. This makes the initialization order\n  program-defined, whereas previously it was undefined.\n\n### Tools\n\n#### Linter\n\nThe Linter was updated to `0.1.104`, which includes:\n\n- updated `unnecessary_overrides` to allow overrides when annotations (besides\n  `@override` are specified)\n- updated `file_names` to allow names w/ leading `_`'s (and improved\n  performance)\n- new lint: `unnecessary_final`\n\n#### Pub\n\n- `pub get` generates\n  [`.dart_tool/package_config.json`](https://github.com/dart-lang/language/blob/62c036cc41b10fb543102d2f73ee132d1e2b2a0e/accepted/future-releases/language-versioning/package-config-file-v2.md)\n  in addition to `.packages` to support language versioning.\n\n- `pub publish` now warns about the old flutter plugin registration format.\n\n- `pub publish` now warns about the `author` field in pubspec.yaml being.\n  obsolete.\n\n- Show a proper error message when `git` is not installed.\n\n## 2.6.1 - 2019-11-11\n\nThis is a patch release that reduces dart2js memory usage (issue [27883][]),\nimproves stability on arm64 (issue [39090][]) and updates the Dart FFI\ndocumentation.\n\n[27883]: https://github.com/dart-lang/sdk/issues/27883\n[39090]: https://github.com/dart-lang/sdk/issues/39090\n\n## 2.6.0 - 2019-11-05\n\n### Language\n\n- **[IN PREVIEW]** [Static extension members][]: A new language feature allowing\n  specially declared static functions to be invoked like instance members on\n  expressions of appropriate static types is available in preview.\n\n  Static extension members are declared using a new `extension` declaration.\n  Example:\n\n  ```dart\n  extension MyFancyList<T> on List<T> {\n    /// Whether this list has an even length.\n    bool get isLengthEven => this.length.isEven;\n\n    /// Whether this list has an odd length.\n    bool get isLengthOdd => !isLengthEven;\n\n    /// List of values computed for each pairs of adjacent elements.\n    ///\n    /// The result always has one element less than this list,\n    /// if this list has any elements.\n    List<R> combinePairs<R>(R Function(T, T) combine) =>\n        [for (int i = 1; i < this.length; i++)\n            combine(this[i - 1], this[i])];\n  }\n  ```\n\n  Extension declarations cannot declare instance fields or constructors.\n  Extension members can be invoked explicitly,\n  `MyFancyList(intList).isLengthEven)`, or implicitly, `intList.isLengthEven`,\n  where the latter is recognized by `intList` matching the `List<T>` \"on\" type\n  of the declaration. An extension member cannot be called implicitly on an\n  expression whose static type has a member with the same base-name. In that\n  case, the interface member takes precedence. If multiple extension members\n  apply to the same implicit invocation, the most specific one is used, if there\n  is one such.\n\n  Extensions can be declared on any type, not just interface types.\n\n  ```dart\n  extension IntCounter on int {\n    /// The numbers from this number to, but not including, [end].\n    Iterable<int> to(int end) sync* {\n      int step = end < this ? -1 : 1;\n      for (int i = this; i != end; i += step) yield i;\n    }\n  }\n\n  extension CurryFunction<R, S, T> on R Function(S, T) {\n    /// Curry a binary function with its first argument.\n    R Function(T) curry(S first) => (T second) => this(first, second);\n  }\n  ```\n\n  [static extension members]:\n    https://github.com/dart-lang/language/blob/master/accepted/2.6/static-extension-members/feature-specification.md\n\n- **Breaking change** [#37985](https://github.com/dart-lang/sdk/issues/37985):\n  Inference is changed when using `Null` values in a `FutureOr` context. Namely,\n  constraints of the forms similar to `Null` <: `FutureOr<T>` now yield `Null`\n  as the solution for `T`. For example, the following code will now print\n  \"Null\", and it was printing \"dynamic\" before (note that the anonymous closure\n  `() {}` in the example has `Null` as its return type):\n\n  ```dart\n  import 'dart:async';\n\n  void foo<T>(FutureOr<T> Function() f) { print(T); }\n\n  main() { foo(() {}); }\n  ```\n\n### Core libraries\n\n- Default values of parameters of abstract methods are no longer available via\n  `dart:mirrors`.\n\n#### `dart:developer`\n\n- Added optional `parent` parameter to `TimelineTask` constructor to allow for\n  linking of asynchronous timeline events in the DevTools timeline view.\n\n#### `dart:io`\n\n- Added `enableTimelineLogging` property to `HttpClient` which, when enabled,\n  will post HTTP connection and request information to the developer timeline\n  for all `HttpClient` instances.\n\n### Dart VM\n\n- Added a new tool for AOT compiling Dart programs to native, self-contained\n  executables. See https://dart.dev/tools/dart2native for additional details.\n\n### Foreign Function Interface (`dart:ffi`)\n\n- **Breaking change**: The API now makes use of static extension members. Static\n  extension members enable the `dart:ffi` API to be more precise with types, and\n  provide convenient access to memory through extension getters and setters. The\n  extension members on `Pointer` provide `.value` and `.value =` for accessing\n  the value in native memory and `[]` and `[]=` for indexed access. The method\n  `asExternalTypedData` has been replaced with `asTypedList` extension methods.\n  And finally, `Structs` do no longer have a type argument and are accessed\n  using the extension member `.ref` on `Pointer`. These changes makes the code\n  using `dart:ffi` much more concise.\n- **Breaking change**: The memory management has been removed\n  (`Pointer.allocate` and `Pointer.free`). Instead, memory management is\n  available in [package:ffi](https://pub.dev/packages/ffi).\n- **Breaking change**: `Pointer.offsetBy` was removed, use `cast` and\n  `elementAt` instead.\n- Faster memory load and stores.\n- The dartanalyzer (commandline and IDEs) now reports `dart:ffi` static errors.\n- Callbacks are now supported in AOT (ahead-of-time) compiled code.\n\n### Dart for the Web\n\n#### Dart Dev Compiler (DDC)\n\n- Kernel DDC will no longer accept non-dill files as summary inputs.\n- Removed support for the deprecated web extension.\n\n### Tools\n\n#### Linter\n\nThe Linter was updated to `0.1.101`, which includes:\n\n- fixed `diagnostic_describe_all_properties` to flag properties in\n  `Diagnosticable`s with no debug methods defined\n- fixed `noSuchMethod` exception in `camel_case_extensions` when analyzing\n  unnamed extensions\n- fixed `avoid_print` to catch tear-off usage\n- new lint: `avoid_web_libraries_in_flutter` (experimental)\n- (internal) prepare `unnecessary_lambdas` for coming `MethodInvocation` vs.\n  `FunctionExpressionInvocation` changes\n\n## 2.5.2 - 2019-10-08\n\nThis is a patch release with properly signed binaries required for macOS\nCatalina (Issue [38765][]).\n\n[38765]: https://github.com/dart-lang/sdk/issues/38765\n\n## 2.5.1 - 2019-09-27\n\nThis is a patch release that prevents type inference failures in the analyzer\n(Issue [38365][]).\n\n[38365]: https://github.com/dart-lang/sdk/issues/38365\n\n## 2.5.0 - 2019-09-10\n\n### Language\n\nThe set of operations allowed in constant expressions has been expanded as\ndescribed in the\n[constant update proposal](https://github.com/dart-lang/language/issues/61). The\ncontrol flow and spread collection features shipped in Dart 2.3 are now also\nsupported in constants as\n[described in the specification here](https://github.com/dart-lang/language/blob/master/accepted/2.3/unified-collections/feature-specification.md#constant-semantics).\n\nSpecifically, it is now valid to use the following operations in constant\nexpressions under the appropriate conditions:\n\n- Casts (`e as T`) and type tests (`e is T`).\n- Comparisons to `null`, even for types which override the `==` operator.\n- The `&`, `|`, and `^` binary operators on booleans.\n- The spread operators (`...` and `...?`).\n- An `if` element in a collection literal.\n\n```dart\n// Example: these are now valid constants.\nconst Object i = 3;\nconst list = [i as int];\nconst set = {if (list is List<int>) ...list};\nconst map = {if (i is int) i : \"int\"};\n```\n\nIn addition, the semantics of constant evaluation has been changed as follows:\n\n- The `&&` operator only evaluates its second operand if the first evaluates to\n  true.\n- The `||` operator only evaluates its second operand if the first evaluates to\n  false.\n- The `??` operator only evaluates its second operand if the first evaluates to\n  null.\n- The conditional operator (`e ? e1 : e2`) only evaluates one of the two\n  branches, depending on the value of the first operand.\n\n```dart\n// Example: x is now a valid constant definition.\nconst String s = null;\nconst int x = (s == null) ? 0 : s.length;\n```\n\n### Core libraries\n\n- **Breaking change** [#36900](https://github.com/dart-lang/sdk/issues/36900):\n  The following methods and properties across various core libraries, which used\n  to declare a return type of `List<int>`, were updated to declare a return type\n  of `Uint8List`:\n\n  - `BytesBuilder.takeBytes()`\n  - `BytesBuilder.toBytes()`\n  - `Datagram.data`\n  - `File.readAsBytes()` (`Future<Uint8List>`)\n  - `File.readAsBytesSync()`\n  - `InternetAddress.rawAddress`\n  - `RandomAccessFile.read()` (`Future<Uint8List>`)\n  - `RandomAccessFile.readSync()`\n  - `RawSocket.read()`\n  - `Utf8Codec.encode()` (and `Utf8Encoder.convert()`)\n\n  In addition, the following classes were updated to implement\n  `Stream<Uint8List>` rather than `Stream<List<int>>`:\n\n  - `HttpRequest`\n  - `Socket`\n\n  **Possible errors and how to fix them**\n\n  - > The argument type 'Utf8Decoder' can't be assigned to the parameter type\n    > 'StreamTransformer<Uint8List, dynamic>'\n\n    > type 'Utf8Decoder' is not a subtype of type 'StreamTransformer' of\n    > 'streamTransformer'\"\n\n    You can fix these call sites by updating your code to use\n    `StreamTransformer.bind()` instead of `Stream.transform()`, like so:\n\n    _Before:_ `stream.transform(utf8.decoder)` _After:_\n    `utf8.decoder.bind(stream)`\n\n  - > The argument type 'IOSink' can't be assigned to the parameter type\n    > 'StreamConsumer<Uint8List>'\n\n    > type '\\_IOSinkImpl' is not a subtype of type 'StreamConsumer<Uint8List>'\n    > of 'streamConsumer'\n\n    You can fix these call sites by casting your stream instance to a\n    `Stream<List<int>>` before calling `.pipe()` on the stream, like so:\n\n    _Before:_ `stream.pipe(consumer)` _After:_\n    `stream.cast<List<int>>().pipe(consumer)`\n\n  Finally, the following typed lists were updated to have their `sublist()`\n  methods declare a return type that is the same as the source list:\n\n  - `Int8List.sublist()` \u2192 `Int8List`\n  - `Int16List.sublist()` \u2192 `Int16List`\n  - `Int32List.sublist()` \u2192 `Int32List`\n  - `Int64List.sublist()` \u2192 `Int64List`\n  - `Int32x4List.sublist()` \u2192 `Int32x4List`\n  - `Float32List.sublist()` \u2192 `Float32List`\n  - `Float64List.sublist()` \u2192 `Float64List`\n  - `Float32x4List.sublist()` \u2192 `Float32x4List`\n  - `Float64x2List.sublist()` \u2192 `Float64x2List`\n  - `Uint8List.sublist()` \u2192 `Uint8List`\n  - `Uint8ClampedList.sublist()` \u2192 `Uint8ClampedList`\n  - `Uint16List.sublist()` \u2192 `Uint16List`\n  - `Uint32List.sublist()` \u2192 `Uint32List`\n  - `Uint64List.sublist()` \u2192 `Uint64List`\n\n#### `dart:async`\n\n- Add `value` and `error` constructors on `Stream` to allow easily creating\n  single-value or single-error streams.\n\n#### `dart:core`\n\n- Update `Uri` class to support [RFC6874](https://tools.ietf.org/html/rfc6874):\n  \"%25\" or \"%\" can be appended to the end of a valid IPv6 representing a Zone\n  Identifier. A valid zone ID consists of unreversed character or Percent\n  encoded octet, which was defined in RFC3986. IPv6addrz = IPv6address \"%25\"\n  ZoneID\n\n  [29456]: https://github.com/dart-lang/sdk/issues/29456\n\n#### `dart:io`\n\n- **Breaking change** [#37192](https://github.com/dart-lang/sdk/issues/37192):\n  The `Cookie` class's constructor's `name` and `value` optional positional\n  parameters are now mandatory. The signature changes from:\n\n      Cookie([String name, String value])\n\n  to\n\n      Cookie(String name, String value)\n\n  However, it has not been possible to set `name` and `value` to null since Dart\n  1.3.0 (2014) where a bug made it impossible. Any code not using both\n  parameters or setting any to null would necessarily get a noSuchMethod\n  exception at runtime. This change catches such erroneous uses at compile time.\n  Since code could not previously correctly omit the parameters, this is not\n  really a breaking change.\n\n- **Breaking change** [#37192](https://github.com/dart-lang/sdk/issues/37192):\n  The `Cookie` class's `name` and `value` setters now validates that the strings\n  are made from the allowed character set and are not null. The constructor\n  already made these checks and this fixes the loophole where the setters didn't\n  also validate.\n\n### Dart VM\n\n### Tools\n\n#### Pub\n\n- Clean-up invalid git repositories in cache when fetching from git.\n- **Breaking change** [#36765](https://github.com/dart-lang/sdk/issues/36765):\n  Packages published to [pub.dev](https://pub.dev) can no longer contain git\n  dependencies. These packages will be rejected by the server.\n\n#### Linter\n\nThe Linter was updated to `0.1.96`, which includes:\n\n- fixed false positives in `unnecessary_parens`\n- various changes to migrate to preferred analyzer APIs\n- rule test fixes\n\n#### Dartdoc\n\nDartdoc was updated to `0.28.4`; this version includes several fixes and is\nbased on a newer version of the analyzer package.\n\n## 2.4.1 - 2019-08-07\n\nThis is a patch release that fixes a performance regression in JIT mode, as well\nas a potential crash of our AOT compiler.\n\n### Dart VM\n\n- Fixed a performance regression where usage of `Int32List` could trigger\n  repeated deoptimizations in JIT mode (Issue [37551][]).\n\n- Fixed a bug where usage of a static getter with name `length` could cause a\n  crash in our AOT compiler (Issue [35121][]).\n\n[37551]: https://github.com/dart-lang/sdk/issues/37551\n[35121]: https://github.com/dart-lang/sdk/issues/35121\n\n### Dart Dev Compiler (DDC)\n\nCallbacks passed to JS and wrapped with `allowInterop` or\n`allowInteropCaptureThis` are now strict about argument counts and argument\ntypes. This may mean that tests which were previously passing and relying on\nloose argument checking (too many or too few arguments, or arguments with too\nspecific types like `List<Something>` instead of `List<dynamic>`) may start\nfailing. This changes makes DDC behave more like dart2js with the default flags.\n\n## 2.4.0 - 2019-06-27\n\n### Core libraries\n\n#### `dart:isolate`\n\n- `TransferableTypedData` class was added to facilitate faster cross-isolate\n  communication of `Uint8List` data.\n\n- **Breaking change**: `Isolate.resolvePackageUri` will always throw an\n  `UnsupportedError` when compiled with dart2js or DDC. This was the only\n  remaining API in `dart:isolate` that didn't automatically throw since we\n  dropped support for this library in [Dart 2.0.0][1]. Note that the API already\n  throws in dart2js if the API is used directly without manually setting up a\n  `defaultPackagesBase` hook.\n\n[1]: https://github.com/dart-lang/sdk/blob/main/CHANGELOG.md#200---2018-08-07\n\n#### `dart:developer`\n\n- Exposed `result`, `errorCode` and `errorDetail` getters in\n  `ServiceExtensionResponse` to allow for better debugging of VM service\n  extension RPC results.\n\n#### `dart:io`\n\n- Fixed `Cookie` class interoperability with certain websites by allowing the\n  cookie values to be the empty string (Issue [35804][]) and not stripping\n  double quotes from the value (Issue [33327][]) in accordance with RFC 6265.\n\n  [33327]: https://github.com/dart-lang/sdk/issues/33327\n  [35804]: https://github.com/dart-lang/sdk/issues/35804\n\n- [#36971](https://github.com/dart-lang/sdk/issues/36971): The\n  `HttpClientResponse` interface has been extended with the addition of a new\n  `compressionState` getter, which specifies whether the body of a response was\n  compressed when it was received and whether it has been automatically\n  uncompressed via `HttpClient.autoUncompress`.\n\n  As part of this change, a corresponding new enum was added to `dart:io`:\n  `HttpClientResponseCompressionState`.\n\n  This is a **breaking change** for those implementing the `HttpClientResponse`\n  interface as subclasses will need to implement the new getter.\n\n#### `dart:async`\n\n- **Breaking change** [#36382](https://github.com/dart-lang/sdk/issues/36382):\n  The `await for` allowed `null` as a stream due to a bug in `StreamIterator`\n  class. This bug has now been fixed.\n\n#### `dart:core`\n\n- [#36171](https://github.com/dart-lang/sdk/issues/36171): The `RegExp`\n  interface has been extended with two new constructor named parameters:\n\n  - `unicode:` (`bool`, default: `false`), for Unicode patterns\n  - `dotAll:` (`bool`, default: `false`), to change the matching behavior of '.'\n    to also match line terminating characters.\n\n  Appropriate properties for these named parameters have also been added so\n  their use can be detected after construction.\n\n  In addition, `RegExp` methods that originally returned `Match` objects now\n  return a more specific subtype, `RegExpMatch`, which adds two features:\n\n  - `Iterable<String> groupNames`, a property that contains the names of all\n    named capture groups\n  - `String namedGroup(String name)`, a method that retrieves the match for the\n    given named capture group\n\n  This is a **breaking change** for implementers of the `RegExp` interface.\n  Subclasses will need to add the new properties and may have to update the\n  return types on overridden methods.\n\n### Language\n\n- **Breaking change** [#35097](https://github.com/dart-lang/sdk/issues/35097):\n  Covariance of type variables used in super-interfaces is now enforced. For\n  example, the following code was previously accepted and will now be rejected:\n\n```dart\nclass A<X> {};\nclass B<X> extends A<void Function(X)> {};\n```\n\n- The identifier `async` can now be used in asynchronous and generator\n  functions.\n\n### Dart for the Web\n\n#### Dart Dev Compiler (DDC)\n\n- Improve `NoSuchMethod` errors for failing dynamic calls. Now they include\n  specific information about the nature of the error such as:\n  - Attempting to call a null value.\n  - Calling an object instance with a null `call()` method.\n  - Passing too few or too many arguments.\n  - Passing incorrect named arguments.\n  - Passing too few or too many type arguments.\n  - Passing type arguments to a non-generic method.\n\n### Tools\n\n#### Linter\n\nThe Linter was updated to `0.1.91`, which includes the following changes:\n\n- Fixed missed cases in `prefer_const_constructors`\n- Fixed `prefer_initializing_formals` to no longer suggest API breaking changes\n- Updated `omit_local_variable_types` to allow explicit `dynamic`s\n- Fixed null-reference in `unrelated_type_equality_checks`\n- New lint: `unsafe_html`\n- Broadened `prefer_null_aware_operators` to work beyond local variables.\n- Added `prefer_if_null_operators`.\n- Fixed `prefer_contains` false positives.\n- Fixed `unnecessary_parenthesis` false positives.\n- Fixed `prefer_asserts_in_initializer_lists` false positives\n- Fixed `curly_braces_in_flow_control_structures` to handle more cases\n- New lint: `prefer_double_quotes`\n- New lint: `sort_child_properties_last`\n- Fixed `type_annotate_public_apis` false positive for `static const`\n  initializers\n\n#### Pub\n\n- `pub publish` will no longer warn about missing dependencies for import\n  statements in `example/`.\n- OAuth2 authentication will explicitly ask for the `openid` scope.\n\n## 2.3.2 - 2019-06-11\n\nThis is a patch version release with a security improvement.\n\n### Security vulnerability\n\n- **Security improvement:** On Linux and Android, starting a process with\n  `Process.run`, `Process.runSync`, or `Process.start` would first search the\n  current directory before searching `PATH` (Issue [37101][]). This behavior\n  effectively put the current working directory in the front of `PATH`, even if\n  it wasn't in the `PATH`. This release changes that behavior to only searching\n  the directories in the `PATH` environment variable. Operating systems other\n  than Linux and Android didn't have this behavior and aren't affected by this\n  vulnerability.\n\n  This vulnerability could result in execution of untrusted code if a command\n  without a slash in its name was run inside an untrusted directory containing\n  an executable file with that name:\n\n  ```dart\n  Process.run(\"ls\", workingDirectory: \"/untrusted/directory\")\n  ```\n\n  This would attempt to run `/untrusted/directory/ls` if it existed, even though\n  it is not in the `PATH`. It was always safe to instead use an absolute path or\n  a path containing a slash.\n\n  This vulnerability was introduced in Dart 2.0.0.\n\n[37101]: https://github.com/dart-lang/sdk/issues/37101\n\n## 2.3.1 - 2019-05-21\n\nThis is a patch version release with bug fixes.\n\n### Tools\n\n#### dart2js\n\n- Fixed a bug that caused the compiler to crash when it compiled UI-as-code\n  features within fields (Issue [36864][]).\n\n[36864]: https://github.com/dart-lang/sdk/issues/36864\n\n## 2.3.0 - 2019-05-08\n\nThe focus in this release is on the new \"UI-as-code\" language features which\nmake collections more expressive and declarative.\n\n### Language\n\nFlutter is growing rapidly, which means many Dart users are building UI in code\nout of big deeply-nested expressions. Our goal with 2.3.0 was to [make that kind\nof code easier to write and maintain][ui-as-code]. Collection literals are a\nlarge component, so we focused on three features to make collections more\npowerful. We'll use list literals in the examples below, but these features also\nwork in map and set literals.\n\n[ui-as-code]:\n  https://medium.com/dartlang/making-dart-a-better-language-for-ui-f1ccaf9f546c\n\n#### Spread\n\nPlacing `...` before an expression inside a collection literal unpacks the\nresult of the expression and inserts its elements directly inside the new\ncollection. Where before you had to write something like this:\n\n```dart\nCupertinoPageScaffold(\n  child: ListView(children: [\n    Tab2Header()\n  ]..addAll(buildTab2Conversation())\n    ..add(buildFooter())),\n);\n```\n\nNow you can write this:\n\n```dart\nCupertinoPageScaffold(\n  child: ListView(children: [\n    Tab2Header(),\n    ...buildTab2Conversation(),\n    buildFooter()\n  ]),\n);\n```\n\nIf you know the expression might evaluate to null and you want to treat that as\nequivalent to zero elements, you can use the null-aware spread `...?`.\n\n#### Collection if\n\nSometimes you might want to include one or more elements in a collection only\nunder certain conditions. If you're lucky, you can use a `?:` operator to\nselectively swap out a single element, but if you want to exchange more than one\nor omit elements, you are forced to write imperative code like this:\n\n```dart\nWidget build(BuildContext context) {\n  var children = [\n    IconButton(icon: Icon(Icons.menu)),\n    Expanded(child: title)\n  ];\n\n  if (isAndroid) {\n    children.add(IconButton(icon: Icon(Icons.search)));\n  }\n\n  return Row(children: children);\n}\n```\n\nWe now allow `if` inside collection literals to conditionally omit or (with\n`else`) swap out an element:\n\n```dart\nWidget build(BuildContext context) {\n  return Row(\n    children: [\n      IconButton(icon: Icon(Icons.menu)),\n      Expanded(child: title),\n      if (isAndroid)\n        IconButton(icon: Icon(Icons.search)),\n    ],\n  );\n}\n```\n\nUnlike the existing `?:` operator, a collection `if` can be composed with\nspreads to conditionally include or omit multiple items:\n\n```dart\nWidget build(BuildContext context) {\n  return Row(\n    children: [\n      IconButton(icon: Icon(Icons.menu)),\n      if (isAndroid) ...[\n        Expanded(child: title),\n        IconButton(icon: Icon(Icons.search)),\n      ]\n    ],\n  );\n}\n```\n\n#### Collection for\n\nIn many cases, the higher-order methods on Iterable give you a declarative way\nto modify a collection in the context of a single expression. But some\noperations, especially involving both transforming and filtering, can be\ncumbersome to express in a functional style.\n\nTo solve this problem, you can use `for` inside a collection literal. Each\niteration of the loop produces an element which is then inserted in the\nresulting collection. Consider the following code:\n\n```dart\nvar command = [\n  engineDartPath,\n  frontendServer,\n  ...fileSystemRoots.map((root) => \"--filesystem-root=$root\"),\n  ...entryPoints\n      .where((entryPoint) => fileExists(\"lib/$entryPoint.json\"))\n      .map((entryPoint) => \"lib/$entryPoint\"),\n  mainPath\n];\n```\n\nWith a collection `for`, the code becomes simpler:\n\n```dart\nvar command = [\n  engineDartPath,\n  frontendServer,\n  for (var root in fileSystemRoots) \"--filesystem-root=$root\",\n  for (var entryPoint in entryPoints)\n    if (fileExists(\"lib/$entryPoint.json\")) \"lib/$entryPoint\",\n  mainPath\n];\n```\n\nAs you can see, all three of these features can be freely composed. For full\ndetails of the changes, see [the official proposal][ui-as-code proposal].\n\n[ui-as-code proposal]:\n  https://github.com/dart-lang/language/blob/master/accepted/future-releases/unified-collections/feature-specification.md\n\n**Note: These features are not currently supported in _const_ collection\nliterals. In a future release, we intend to relax this restriction and allow\nspread and collection `if` inside const collections.**\n\n### Core library changes\n\n#### `dart:isolate`\n\n- Added `debugName` property to `Isolate`.\n- Added `debugName` optional parameter to `Isolate.spawn` and\n  `Isolate.spawnUri`.\n\n#### `dart:core`\n\n- RegExp patterns can now use lookbehind assertions.\n- RegExp patterns can now use named capture groups and named backreferences.\n  Currently, named group matches can only be retrieved in Dart either by the\n  implicit index of the named group or by downcasting the returned Match object\n  to the type RegExpMatch. The RegExpMatch interface contains methods for\n  retrieving the available group names and retrieving a match by group name.\n\n### Dart VM\n\n- The VM service now requires an authentication code by default. This behavior\n  can be disabled by providing the `--disable-service-auth-codes` flag.\n\n- Support for deprecated flags '-c' and '--checked' has been removed.\n\n### Dart for the Web\n\n#### dart2js\n\nA binary format was added to dump-info. The old JSON format is still available\nand provided by default, but we are starting to deprecate it. The new binary\nformat is more compact and cheaper to generate. On some large apps we tested, it\nwas 4x faster to serialize and used 6x less memory.\n\nTo use the binary format today, use `--dump-info=binary`, instead of\n`--dump-info`.\n\nWhat to expect next?\n\n- The [visualizer tool][visualizer] will not be updated to support the new\n  binary format, but you can find several command-line tools at\n  `package:dart2js_info` that provide similar features to those in the\n  visualizer.\n\n- The command-line tools in `package:dart2js_info` also work with the old JSON\n  format, so you can start using them even before you enable the new format.\n\n- In a future release `--dump-info` will default to `--dump-info=binary`. At\n  that point, there will be an option to fallback to the JSON format, but the\n  visualizer tool will be deprecated.\n\n- A release after that, the JSON format will no longer be available from\n  dart2js, but may be available from a command-line tool in\n  `package:dart2js_info`.\n\n[visualizer]: https://dart-lang.github.io/dump-info-visualizer/\n\n### Tools\n\n#### dartfmt\n\n- Tweak set literal formatting to follow other collection literals.\n- Add support for \"UI as code\" features.\n- Properly format trailing commas in assertions.\n- Improve indentation of adjacent strings in argument lists.\n\n#### Linter\n\nThe Linter was updated to `0.1.86`, which includes the following changes:\n\n- Added the following lints: `prefer_inlined_adds`,\n  `prefer_for_elements_to_map_fromIterable`,\n  `prefer_if_elements_to_conditional_expressions`,\n  `diagnostic_describe_all_properties`.\n- Updated `file_names` to skip prefixed-extension Dart files (`.css.dart`,\n  `.g.dart`, etc.).\n- Fixed false positives in `unnecessary_parenthesis`.\n\n#### Pub\n\n- Added a CHANGELOG validator that complains if you `pub publish` without\n  mentioning the current version.\n- Removed validation of library names when doing `pub publish`.\n- Added support for `pub global activate`ing package from a custom pub URL.\n- Added subcommand: `pub logout`. Logs you out of the current session.\n\n#### Dart native\n\nInitial support for compiling Dart apps to native machine code has been added.\nTwo new tools have been added to the `bin` folder of the Dart SDK:\n\n- `dart2aot`: AOT (ahead-of-time) compiles a Dart program to native machine\n  code. The tool is supported on Windows, macOS, and Linux.\n\n- `dartaotruntime`: A small runtime used for executing an AOT compiled program.\n\n## 2.2.0 - 2019-02-26\n\n### Language\n\nSets now have a literal syntax like lists and maps do:\n\n```dart\nvar set = {1, 2, 3};\n```\n\nUsing curly braces makes empty sets ambiguous with maps:\n\n```dart\nvar collection = {}; // Empty set or map?\n```\n\nTo avoid breaking existing code, an ambiguous literal is treated as a map. To\ncreate an empty set, you can rely on either a surrounding context type or an\nexplicit type argument:\n\n```dart\n// Variable type forces this to be a set:\nSet<int> set = {};\n\n// A single type argument means this must be a set:\nvar set2 = <int>{};\n```\n\nSet literals are released on all platforms. The `set-literals` experiment flag\nhas been disabled.\n\n### Tools\n\n#### Analyzer\n\n- The `DEPRECATED_MEMBER_USE` hint was split into two hints:\n\n  - `DEPRECATED_MEMBER_USE` reports on usage of `@deprecated` members declared\n    in a different package.\n  - `DEPRECATED_MEMBER_USE_FROM_SAME_PACKAGE` reports on usage of `@deprecated`\n    members declared in the same package.\n\n#### Linter\n\nUpgraded the linter to `0.1.82` which adds the following improvements:\n\n- Added `provide_deprecation_message`, and\n  `use_full_hex_values_for_flutter_colors`, `prefer_null_aware_operators`.\n- Fixed `prefer_const_declarations` set literal false-positives.\n- Updated `prefer_collection_literals` to support set literals.\n- Updated `unnecessary_parenthesis` play nicer with cascades.\n- Removed deprecated lints from the \"all options\" sample.\n- Stopped registering \"default lints\".\n- Fixed `hash_and_equals` to respect `hashCode` fields.\n\n### Other libraries\n\n#### `package:kernel`\n\n- **Breaking change:** The `klass` getter on the `InstanceConstant` class in the\n  Kernel AST API has been renamed to `classNode` for consistency.\n\n- **Breaking change:** Updated `Link` implementation to utilize true symbolic\n  links instead of junctions on Windows. Existing junctions will continue to\n  work with the new `Link` implementation, but all new links will create\n  symbolic links.\n\n  To create a symbolic link, Dart must be run with administrative privileges or\n  Developer Mode must be enabled, otherwise a `FileSystemException` will be\n  raised with errno set to `ERROR_PRIVILEGE_NOT_HELD` (Issue [33966]).\n\n[33966]: https://github.com/dart-lang/sdk/issues/33966\n\n## 2.1.1 - 2019-02-18\n\nThis is a patch version release. Again, the team's focus was mostly on improving\nperformance and stability after the large changes in Dart 2.0.0. In particular,\ndart2js now always uses the \"fast startup\" emitter and the old emitter has been\nremoved.\n\nThere are a couple of very minor **breaking changes:**\n\n- In `dart:io`, adding to a closed `IOSink` now throws a `StateError`.\n\n- On the Dart VM, a soundness hole when using `dart:mirrors` to reflectively\n  invoke a method in an incorrect way that violates its static types has been\n  fixed (Issue [35611][]).\n\n### Language\n\nThis release has no language changes.\n\n### Core library\n\n#### `dart:core`\n\n- Made `DateTime.parse()` also recognize `,` as a valid decimal separator when\n  parsing from a string (Issue [35576][]).\n\n[35576]: https://github.com/dart-lang/sdk/issues/35576\n\n#### `dart:html`\n\n- Added methods `Element.removeAttribute`, `Element.removeAttributeNS`,\n  `Element.hasAttribute` and `Element.hasAttributeNS`. (Issue [35655][]).\n- Improved dart2js compilation of `element.attributes.remove(name)` to generate\n  `element.removeAttribute(name)`, so that there is no performance reason to\n  migrate to the above methods.\n- Fixed a number of `dart:html` bugs:\n\n  - Fixed HTML API's with callback typedef to correctly convert Dart functions\n    to JS functions (Issue [35484]).\n  - HttpStatus constants exposed in `dart:html` (Issue [34318]).\n  - Expose DomName `ondblclick` and `dblclickEvent` for Angular analyzer.\n  - Fixed `removeAll` on `classes`; `elements` parameter should be\n    `Iterable<Object>` to match Set's `removeAll` not `Iterable<E>` (Issue\n    [30278]).\n  - Fixed a number of methods on DataTransferItem, Entry, FileEntry and\n    DirectoryEntry which previously returned NativeJavaScriptObject. This fixes\n    handling drag/drop of files/directories (Issue [35510]).\n  - Added ability to allow local file access from Chrome browser in ddb.\n\n[35655]: https://github.com/dart-lang/sdk/issues/35655\n[30278]: https://github.com/dart-lang/sdk/issues/30278\n[34318]: https://github.com/dart-lang/sdk/issues/34318\n[35484]: https://github.com/dart-lang/sdk/issues/35484\n[35510]: https://github.com/dart-lang/sdk/issues/35510\n\n#### `dart:io`\n\n- **Breaking Change:** Adding to a closed `IOSink` now throws a `StateError`.\n- Added ability to get and set low level socket options.\n\n[29554]: https://github.com/dart-lang/sdk/issues/29554\n\n### Dart VM\n\nIn previous releases it was possible to violate static types using\n`dart:mirrors`. This code would run without any TypeErrors and print\n\"impossible\" output:\n\n```dart\nimport 'dart:mirrors';\n\nclass A {\n  void method(int v) {\n    if (v != null && v is! int) {\n      print(\"This should be impossible: expected null or int got ${v}\");\n    }\n  }\n}\n\nvoid main() {\n  final obj = A();\n  reflect(obj).invoke(#method, ['not-an-number']);\n}\n```\n\nThis bug is fixed now. Only code that already violates static typing will break.\nSee Issue [35611][] for more details.\n\n[35611]: https://github.com/dart-lang/sdk/issues/35611\n\n### Dart for the Web\n\n#### dart2js\n\n- The old \"full emitter\" back-end is removed and dart2js always uses the \"fast\n  startup\" back-end. The generated fast startup code is optimized to load\n  faster, even though it can be slightly larger. The `--fast-startup` and\n  `--no-fast-startup` are allowed but ignored. They will be removed in a future\n  version.\n\n- We fixed a bug in how deferred constructor calls were incorrectly not marked\n  as deferred. The old behavior didn't cause breakages, but was imprecise and\n  pushed more code to the main output unit.\n\n- A new deferred split algorithm implementation was added.\n\n  This implementation fixes a soundness bug and addresses performance issues of\n  the previous implementation, because of that it can have a visible impact on\n  apps. In particular:\n\n  - We fixed a performance issue which was introduced when we migrated to the\n    common front-end. On large apps, the fix can cut 2/3 of the time spent on\n    this task.\n\n  - We fixed a bug in how inferred types were categorized (Issue [35311][]). The\n    old behavior was unsound and could produce broken programs. The fix may\n    cause more code to be pulled into the main output unit.\n\n    This shows up frequently when returning deferred values from closures since\n    the closure's inferred return type is the deferred type. For example, if you\n    have:\n\n    ```dart\n    () async {\n      await deferred_prefix.loadLibrary();\n      return new deferred_prefix.Foo();\n    }\n    ```\n\n    The closure's return type is `Future<Foo>`. The old implementation defers\n    `Foo`, and incorrectly makes the return type `Future<dynamic>`. This may\n    break in places where the correct type is expected.\n\n    The new implementation will not defer `Foo`, and will place it in the main\n    output unit. If your intent is to defer it, then you need to ensure the\n    return type is not inferred to be `Foo`. For example, you can do so by\n    changing the code to a named closure with a declared type, or by ensuring\n    that the return expression has the type you want, like:\n\n    ```dart\n    () async {\n      await deferred_prefix.loadLibrary();\n      return new deferred_prefix.Foo() as dynamic;\n    }\n    ```\n\n    Because the new implementation might require you to inspect and fix your\n    app, we exposed two temporary flags:\n\n  - The `--report-invalid-deferred-types` causes dart2js to run both the old and\n    new algorithms and report any cases where an invalid type was detected.\n\n  - The `--new-deferred-split` flag enables this new algorithm.\n\n- The `--categories=*` flag is being replaced. `--categories=all` was only used\n  for testing and it is no longer supported. `--categories=Server` continues to\n  work at this time but it is deprecated, please use `--server-mode` instead.\n\n- The `--library-root` flag was replaced by `--libraries-spec`. This flag is\n  rarely used by developers invoking dart2js directly. It's important for\n  integrating dart2js with build systems. See `--help` for more details on the\n  new flag.\n\n[35311]: https://github.com/dart-lang/sdk/issues/35311\n\n### Tools\n\n#### Analyzer\n\n- Support for `declarations-casts` has been removed and the `implicit-casts`\n  option now has the combined semantics of both options. This means that users\n  that disable `implicit-casts` might now see errors that were not previously\n  being reported.\n\n- New hints added:\n\n  - `NON_CONST_CALL_TO_LITERAL_CONSTRUCTOR` and\n    `NON_CONST_CALL_TO_LITERAL_CONSTRUCTOR_USING_NEW` inform you when a\n    `@literal` const constructor is called in a non-const context (or with\n    `new`).\n  - `INVALID_LITERAL_ANNOTATION` reports when something other than a const\n    constructor is annotated with `@literal`.\n  - `SUBTYPE_OF_SEALED_CLASS` reports when any class or mixin subclasses\n    (extends, implements, mixes in, or constrains to) a `@sealed` class, and the\n    two are declared in different packages.\n  - `MIXIN_ON_SEALED_CLASS` reports when a `@sealed` class is used as a\n    superclass constraint of a mixin.\n\n#### dartdoc\n\nDefault styles now work much better on mobile. Simple browsing and searching of\nAPI docs now work in many cases.\n\nUpgraded the linter to `0.1.78` which adds the following improvements:\n\n- Added `prefer_final_in_for_each`, `unnecessary_await_in_return`,\n  `use_function_type_syntax_for_parameters`, `avoid_returning_null_for_future`,\n  and `avoid_shadowing_type_parameters`.\n- Updated `invariant_booleans` status to experimental.\n- Fixed `type_annotate_public_apis` false positives on local functions.\n- Fixed `avoid_shadowing_type_parameters` to report shadowed type parameters in\n  generic typedefs.\n- Fixed `use_setters_to_change_properties` to not wrongly lint overriding\n  methods.\n- Fixed `cascade_invocations` to not lint awaited targets.\n- Fixed `prefer_conditional_assignment` false positives.\n- Fixed `join_return_with_assignment` false positives.\n- Fixed `cascade_invocations` false positives.\n- Deprecated `prefer_bool_in_asserts` as it is redundant in Dart 2.\n\n## 2.1.0 - 2018-11-15\n\nThis is a minor version release. The team's focus was mostly on improving\nperformance and stability after the large changes in Dart 2.0.0. Notable\nchanges:\n\n- We've introduced a dedicated syntax for declaring a mixin. Instead of the\n  `class` keyword, it uses `mixin`:\n\n  ```dart\n  mixin SetMixin<E> implements Set<E> {\n    ...\n  }\n  ```\n\n  The new syntax also enables `super` calls inside mixins.\n\n- Integer literals now work in double contexts. When passing a literal number to\n  a function that expects a `double`, you no longer need an explicit `.0` at the\n  end of the number. In releases before 2.1, you need code like this when\n  setting a double like `fontSize`:\n\n  ```dart\n  TextStyle(fontSize: 18.0)\n  ```\n\n  Now you can remove the `.0`:\n\n  ```dart\n  TextStyle(fontSize: 18)\n  ```\n\n  In releases before 2.1, `fontSize : 18` causes a static error. This was a\n  common mistake and source of friction.\n\n- **Breaking change:** A number of static errors that should have been detected\n  and reported were not supported in 2.0.0. These are reported now, which means\n  existing incorrect code may show new errors.\n\n- `dart:core` now exports `Future` and `Stream`. You no longer need to import\n  `dart:async` to use those very common types.\n\n### Language\n\n- Introduced a new syntax for mixin declarations.\n\n  ```dart\n  mixin SetMixin<E> implements Set<E> {\n    ...\n  }\n  ```\n\n  Most classes that are intended to be used as mixins are intended to _only_ be\n  used as mixins. The library author doesn't want users to be able to construct\n  or subclass the class. The new syntax makes that intent clear and enforces it\n  in the type system. It is an error to extend or construct a type declared\n  using `mixin`. (You can implement it since mixins expose an implicit\n  interface.)\n\n  Over time, we expect most mixin declarations to use the new syntax. However,\n  if you have a \"mixin\" class where users _are_ extending or constructing it,\n  note that moving it to the new syntax is a breaking API change since it\n  prevents users from doing that. If you have a type like this that is a mixin\n  as well as being a concrete class and/or superclass, then the existing syntax\n  is what you want.\n\n  If you need to use a `super` inside a mixin, the new syntax is required. This\n  was previously only allowed with the experimental `--supermixins` flag because\n  it has some complex interactions with the type system. The new syntax\n  addresses those issues and lets you use `super` calls by declaring the\n  superclass constraint your mixin requires:\n\n  ```dart\n  class Superclass {\n    superclassMethod() {\n      print(\"in superclass\");\n    }\n  }\n\n  mixin SomeMixin on Superclass {\n    mixinMethod() {\n      // This is OK:\n      super.superclassMethod();\n    }\n  }\n\n  class GoodSub extends Superclass with SomeMixin {}\n\n  class BadSub extends Object with SomeMixin {}\n  // Error: Since the super() call in mixinMethod() can't find a\n  // superclassMethod() to call, this is prohibited.\n  ```\n\n  Even if you don't need to use `super` calls, the new mixin syntax is good\n  because it clearly expresses that you intend the type to be mixed in.\n\n- Allow integer literals to be used in double contexts. An integer literal used\n  in a place where a double is required is now interpreted as a double value.\n  The numerical value of the literal needs to be precisely representable as a\n  double value.\n\n- Integer literals compiled to JavaScript are now allowed to have any value that\n  can be exactly represented as a JavaScript `Number`. They were previously\n  limited to such numbers that were also representable as signed 64-bit\n  integers.\n\n**(Breaking)** A number of static errors that should have been detected and\nreported were not supported in 2.0.0. These are reported now, which means\nexisting incorrect code may show new errors:\n\n- **Setters with the same name as the enclosing class aren't allowed.** (Issue\n  [34225][].) It is not allowed to have a class member with the same name as the\n  enclosing class:\n\n  ```dart\n  class A {\n    set A(int x) {}\n  }\n  ```\n\n  Dart 2.0.0 incorrectly allows this for setters (only). Dart 2.1.0 rejects it.\n\n  _To fix:_ This is unlikely to break anything, since it violates all style\n  guides anyway.\n\n- **Constant constructors cannot redirect to non-constant constructors.** (Issue\n  [34161][].) It is not allowed to have a constant constructor that redirects to\n  a non-constant constructor:\n\n  ```dart\n  class A {\n    const A.foo() : this(); // Redirecting to A()\n    A() {}\n  }\n  ```\n\n  Dart 2.0.0 incorrectly allows this. Dart 2.1.0 rejects it.\n\n  _To fix:_ Make the target of the redirection a properly const constructor.\n\n- **Abstract methods may not unsoundly override a concrete method.** (Issue\n  [32014][].) Concrete methods must be valid implementations of their\n  interfaces:\n\n  ```dart\n  class A {\n    num get thing => 2.0;\n  }\n\n  abstract class B implements A {\n    int get thing;\n  }\n\n  class C extends A with B {}\n  // 'thing' from 'A' is not a valid override of 'thing' from 'B'.\n\n  main() {\n    print(new C().thing.isEven); // Expects an int but gets a double.\n  }\n  ```\n\n  Dart 2.0.0 allows unsound overrides like the above in some cases. Dart 2.1.0\n  rejects them.\n\n  _To fix:_ Relax the type of the invalid override, or tighten the type of the\n  overridden method.\n\n- **Classes can't implement FutureOr.** (Issue [33744][].) Dart doesn't allow\n  classes to implement the FutureOr type:\n\n  ```dart\n  class A implements FutureOr<Object> {}\n  ```\n\n  Dart 2.0.0 allows classes to implement FutureOr. Dart 2.1.0 does not.\n\n  _To fix:_ Don't do this.\n\n- **Type arguments to generic typedefs must satisfy their bounds.** (Issue\n  [33308][].) If a parameterized typedef specifies a bound, actual arguments\n  must be checked against it:\n\n  ```dart\n  class A<X extends int> {}\n\n  typedef F<Y extends int> = A<Y> Function();\n\n  F<num> f = null;\n  ```\n\n  Dart 2.0.0 allows bounds violations like `F<num>` above. Dart 2.1.0 rejects\n  them.\n\n  _To fix:_ Either remove the bound on the typedef parameter, or pass a valid\n  argument to the typedef.\n\n- **Constructor invocations must use valid syntax, even with optional `new`.**\n  (Issue [34403][].) Type arguments to generic named constructors go after the\n  class name, not the constructor name, even when used without an explicit\n  `new`:\n\n  ```dart\n  class A<T> {\n    A.foo() {}\n  }\n\n  main() {\n    A.foo<String>(); // Incorrect syntax, was accepted in 2.0.0.\n    A<String>.foo(); // Correct syntax.\n  }\n  ```\n\n  Dart 2.0.0 accepts the incorrect syntax when the `new` keyword is left out.\n  Dart 2.1.0 correctly rejects this code.\n\n  _To fix:_ Move the type argument to the correct position after the class name.\n\n- **Instance members should shadow prefixes.** (Issue [34498][].) If the same\n  name is used as an import prefix and as a class member name, then the class\n  member name takes precedence in the class scope.\n\n  ```dart\n  import 'dart:core';\n  import 'dart:core' as core;\n\n  class A {\n    core.List get core => null; // \"core\" refers to field, not prefix.\n  }\n  ```\n\n  Dart 2.0.0 incorrectly resolves the use of `core` in `core.List` to the prefix\n  name. Dart 2.1.0 correctly resolves this to the field name.\n\n  _To fix:_ Change the prefix name to something which does not clash with the\n  instance member.\n\n- **Implicit type arguments in extends clauses must satisfy the class bounds.**\n  (Issue [34532][].) Implicit type arguments for generic classes are computed if\n  not passed explicitly, but when used in an `extends` clause they must be\n  checked for validity:\n\n  ```dart\n  class Foo<T> {}\n\n  class Bar<T extends Foo<T>> {}\n\n  class Baz extends Bar {} // Should error because Bar completes to Bar<Foo>\n  ```\n\n  Dart 2.0.0 accepts the broken code above. Dart 2.1.0 rejects it.\n\n  _To fix:_ Provide explicit type arguments to the superclass that satisfy the\n  bound for the superclass.\n\n- **Mixins must correctly override their superclasses.** (Issue [34235][].) In\n  some rare cases, combinations of uses of mixins could result in invalid\n  overrides not being caught:\n\n  ```dart\n  class A {\n    num get thing => 2.0;\n  }\n\n  class M1 {\n    int get thing => 2;\n  }\n\n  class B = A with M1;\n\n  class M2 {\n    num get thing => 2.0;\n  }\n\n  class C extends B with M2 {} // 'thing' from 'M2' not a valid override.\n\n  main() {\n    M1 a = new C();\n    print(a.thing.isEven); // Expects an int but gets a double.\n  }\n  ```\n\n  Dart 2.0.0 accepts the above example. Dart 2.1.0 rejects it.\n\n  _To fix:_ Ensure that overriding methods are correct overrides of their\n  superclasses, either by relaxing the superclass type, or tightening the\n  subclass/mixin type.\n\n[32014]: https://github.com/dart-lang/sdk/issues/32014\n[33308]: https://github.com/dart-lang/sdk/issues/33308\n[33744]: https://github.com/dart-lang/sdk/issues/33744\n[34161]: https://github.com/dart-lang/sdk/issues/34161\n[34225]: https://github.com/dart-lang/sdk/issues/34225\n[34235]: https://github.com/dart-lang/sdk/issues/34235\n[34403]: https://github.com/dart-lang/sdk/issues/34403\n[34498]: https://github.com/dart-lang/sdk/issues/34498\n[34532]: https://github.com/dart-lang/sdk/issues/34532\n\n### Core libraries\n\n#### `dart:async`\n\n- Fixed a bug where calling `stream.take(0).drain(value)` would not correctly\n  forward the `value` through the returned `Future`.\n- Added a `StreamTransformer.fromBind` constructor.\n- Updated `Stream.fromIterable` to send a done event after the error when the\n  iterator's `moveNext` throws, and handle if the `current` getter throws (issue\n  [33431][]).\n\n[33431]: http://dartbug.com/33431\n\n#### `dart:core`\n\n- Added `HashMap.fromEntries` and `LinkedHashmap.fromEntries` constructors.\n- Added `ArgumentError.checkNotNull` utility method.\n- Made `Uri` parsing more permissive about `[` and `]` occurring in the path,\n  query or fragment, and `#` occurring in fragment.\n- Exported `Future` and `Stream` from `dart:core`.\n- Added operators `&`, `|` and `^` to `bool`.\n- Added missing methods to `UnmodifiableMapMixin`. Some maps intended to be\n  unmodifiable incorrectly allowed new methods added in Dart 2 to succeed.\n- Deprecated the `provisional` annotation and the `Provisional` annotation\n  class. These should have been removed before releasing Dart 2.0, and they have\n  no effect.\n\n#### `dart:html`\n\nFixed Service Workers and any Promise/Future API with a Dictionary parameter.\n\nAPIs in dart:html (that take a Dictionary) will receive a Dart Map parameter.\nThe Map parameter must be converted to a Dictionary before passing to the\nbrowser's API. Before this change, any Promise/Future API with a Map/Dictionary\nparameter never called the Promise and didn't return a Dart Future - now it\ndoes.\n\nThis caused a number of breaks especially in Service Workers (register, etc.).\nHere is a complete list of the fixed APIs:\n\n- BackgroundFetchManager\n  - `Future<BackgroundFetchRegistration> fetch(String id, Object requests, [Map options])`\n- CacheStorage\n  - `Future match(/*RequestInfo*/ request, [Map options])`\n- CanMakePayment\n  - `Future<List<Client>> matchAll([Map options])`\n- CookieStore\n  - `Future getAll([Map options])`\n  - `Future set(String name, String value, [Map options])`\n- CredentialsContainer\n  - `Future get([Map options])`\n  - `Future create([Map options])`\n- ImageCapture\n  - `Future setOptions(Map photoSettings)`\n- MediaCapabilities\n  - `Future<MediaCapabilitiesInfo> decodingInfo(Map configuration)`\n  - `Future<MediaCapabilitiesInfo> encodingInfo(Map configuration)`\n- MediaStreamTrack\n  - `Future applyConstraints([Map constraints])`\n- Navigator\n  - `Future requestKeyboardLock([List<String> keyCodes])`\n  - `Future requestMidiAccess([Map options])`\n  - `Future share([Map data])`\n- OffscreenCanvas\n  - `Future<Blob> convertToBlob([Map options])`\n- PaymentInstruments\n  - `Future set(String instrumentKey, Map details)`\n- Permissions\n  - `Future<PermissionStatus> query(Map permission)`\n  - `Future<PermissionStatus> request(Map permissions)`\n  - `Future<PermissionStatus> revoke(Map permission)`\n- PushManager\n  - `Future permissionState([Map options])`\n  - `Future<PushSubscription> subscribe([Map options])`\n- RtcPeerConnection\n\n  - Changed:\n\n    ```dart\n    Future createAnswer([options_OR_successCallback,\n        RtcPeerConnectionErrorCallback failureCallback,\n        Map mediaConstraints])\n    ```\n\n    to:\n\n    ```dart\n    Future<RtcSessionDescription> createAnswer([Map options])\n    ```\n\n  - Changed:\n\n    ```dart\n    Future createOffer([options_OR_successCallback,\n        RtcPeerConnectionErrorCallback failureCallback,\n        Map rtcOfferOptions])\n    ```\n\n    to:\n\n    ```dart\n    Future<RtcSessionDescription> createOffer([Map options])\n    ```\n\n  - Changed:\n\n    ```dart\n    Future setLocalDescription(Map description,\n        VoidCallback successCallback,\n        [RtcPeerConnectionErrorCallback failureCallback])\n    ```\n\n    to:\n\n    ```dart\n    Future setLocalDescription(Map description)\n    ```\n\n  - Changed:\n\n    ```dart\n    Future setLocalDescription(Map description,\n        VoidCallback successCallback,\n        [RtcPeerConnectionErrorCallback failureCallback])\n    ```\n\n    to:\n\n    ```dart\n    Future setRemoteDescription(Map description)\n    ```\n\n- ServiceWorkerContainer\n  - `Future<ServiceWorkerRegistration> register(String url, [Map options])`\n- ServiceWorkerRegistration\n  - `Future<List<Notification>> getNotifications([Map filter])`\n  - `Future showNotification(String title, [Map options])`\n- VRDevice\n  - `Future requestSession([Map options])`\n  - `Future supportsSession([Map options])`\n- VRSession\n  - `Future requestFrameOfReference(String type, [Map options])`\n- Window\n  - `Future fetch(/*RequestInfo*/ input, [Map init])`\n- WorkerGlobalScope\n  - `Future fetch(/*RequestInfo*/ input, [Map init])`\n\nIn addition, exposed Service Worker \"self\" as a static getter named \"instance\".\nThe instance is exposed on four different Service Worker classes and can throw a\nInstanceTypeError if the instance isn't of the class expected\n(WorkerGlobalScope.instance will always work and not throw):\n\n- `SharedWorkerGlobalScope.instance`\n- `DedicatedWorkerGlobalScope.instance`\n- `ServiceWorkerGlobalScope.instance`\n- `WorkerGlobalScope.instance`\n\n#### `dart:io`\n\n- Added new HTTP status codes.\n\n### Dart for the Web\n\n#### dart2js\n\n- **(Breaking)** Duplicate keys in a const map are not allowed and produce a\n  compile-time error. Dart2js used to report this as a warning before. This was\n  already an error in dartanalyzer and DDC and will be an error in other tools\n  in the future as well.\n\n- Added `-O` flag to tune optimization levels. For more details run\n  `dart2js -h -v`.\n\n  We recommend to enable optimizations using the `-O` flag instead of individual\n  flags for each optimization. This is because the `-O` flag is intended to be\n  stable and continue to work in future versions of dart2js, while individual\n  flags may come and go.\n\n  At this time we recommend to test and debug with `-O1` and to deploy with\n  `-O3`.\n\n### Tool Changes\n\n#### dartfmt\n\n- Addressed several dartfmt issues when used with the new CFE parser.\n\n#### Linter\n\nBumped the linter to `0.1.70` which includes the following new lints:\n\n- `avoid_returning_null_for_void`\n- `sort_pub_dependencies`\n- `prefer_mixin`\n- `avoid_implementing_value_types`\n- `flutter_style_todos`\n- `avoid_void_async`\n- `prefer_void_to_null`\n\nand improvements:\n\n- Fixed NPE in `prefer_iterable_whereType`.\n- Improved message display for `await_only_futures`\n- Performance improvements for `null_closures`\n- Mixin support\n- Updated `sort_constructors_first` to apply to all members.\n- Updated `unnecessary_this` to work on field initializers.\n- Updated `unawaited_futures` to ignore assignments within cascades.\n- Improved handling of constant expressions with generic type params.\n- NPE fix for `invariant_booleans`.\n- Improved docs for `unawaited_futures`.\n- Updated `unawaited_futures` to check cascades.\n- Relaxed `void_checks` (allowing `T Function()` to be assigned to\n  `void Function()`).\n- Fixed false positives in `lines_longer_than_80_chars`.\n\n#### Pub\n\n- Renamed the `--checked` flag to `pub run` to `--enable-asserts`.\n- Pub will no longer delete directories named \"packages\".\n- The `--packages-dir` flag is now ignored.\n\n## 2.0.0 - 2018-08-07\n\nThis is the first major version release of Dart since 1.0.0, so it contains many\nsignificant changes across all areas of the platform. Large changes include:\n\n- **(Breaking)** The unsound optional static type system has been replaced with\n  a sound static type system using type inference and runtime checks. This was\n  formerly called \"[strong mode][]\" and only used by the Dart for web products.\n  Now it is the one official static type system for the entire platform and\n  replaces the previous \"checked\" and \"production\" modes.\n\n- **(Breaking)** Functions marked `async` now run synchronously until the first\n  `await` statement. Previously, they would return to the event loop once at the\n  top of the function body before any code runs ([issue 30345][]).\n\n- **(Breaking)** Constants in the core libraries have been renamed from\n  `SCREAMING_CAPS` to `lowerCamelCase`.\n\n- **(Breaking)** Many new methods have been added to core library classes. If\n  you implement the interfaces of these classes, you will need to implement the\n  new methods.\n\n- **(Breaking)** \"dart:isolate\" and \"dart:mirrors\" are no longer supported when\n  using Dart for the web. They are still supported in the command-line VM.\n\n- **(Breaking)** Pub's transformer-based build system has been [replaced by a\n  new build system][transformers].\n\n- The `new` keyword is optional and can be omitted. Likewise, `const` can be\n  omitted inside a const context ([issue 30921][]).\n\n- Dartium is no longer maintained or supported.\n\n[issue 30345]: https://github.com/dart-lang/sdk/issues/30345\n[issue 30921]: https://github.com/dart-lang/sdk/issues/30921\n[strong mode]: https://www.dartlang.org/guides/language/sound-dart\n[transformers]: https://www.dartlang.org/tools/pub/obsolete\n\n### Language\n\n- \"[Strong mode][]\" is now the official type system of the language.\n\n- The `new` keyword is optional and can be omitted. Likewise, `const` can be\n  omitted inside a const context.\n\n- A string in a `part of` declaration may now be used to refer to the library\n  this file is part of. A library part can now declare its library as either:\n\n  ```dart\n  part of name.of.library;\n  ```\n\n  Or:\n\n  ```dart\n  part of \"uriReferenceOfLibrary.dart\";\n  ```\n\n  This allows libraries with no library declarations (and therefore no name) to\n  have parts, and it allows tools to easily find the library of a part file. The\n  Dart 1.0 syntax is supported but deprecated.\n\n- Functions marked `async` now run synchronously until the first `await`\n  statement. Previously, they would return to the event loop once at the top of\n  the function body before any code runs ([issue 30345][]).\n\n- The type `void` is now a Top type like `dynamic`, and `Object`. It also now\n  has new errors for being used where not allowed (such as being assigned to any\n  non-`void`-typed parameter). Some libraries (importantly, mockito) may need to\n  be updated to accept void values to keep their APIs working.\n\n- Future flattening is now done only as specified in the Dart 2.0 spec, rather\n  than more broadly. This means that the following code has an error on the\n  assignment to `y`.\n\n  ```dart\n  test() {\n    Future<int> f;\n    var x = f.then<Future<List<int>>>((x) => []);\n    Future<List<int>> y = x;\n  }\n  ```\n\n- Invocations of `noSuchMethod()` receive default values for optional args. The\n  following program used to print \"No arguments passed\", and now prints \"First\n  argument is 3\".\n\n  ```dart\n  abstract class B {\n    void m([int x = 3]);\n  }\n\n  class A implements B {\n    noSuchMethod(Invocation i) {\n      if (i.positionalArguments.length == 0) {\n        print(\"No arguments passed\");\n      } else {\n        print(\"First argument is ${i.positionalArguments[0]}\");\n      }\n    }\n  }\n\n  void main() {\n    A().m();\n  }\n  ```\n\n- Bounds on generic functions are invariant. The following program now issues an\n  invalid override error ([issue 29014][sdk#29014]):\n\n  ```dart\n  class A {\n    void f<T extends int>() {}\n  }\n\n  class B extends A {\n    @override\n    void f<T extends num>() {}\n  }\n  ```\n\n- Numerous corner case bugs around return statements in synchronous and\n  asynchronous functions fixed. Specifically:\n\n  - Issues [31887][issue 31887], [32881][issue 32881]. Future flattening should\n    not be recursive.\n  - Issues [30638][issue 30638], [32233][issue 32233]. Incorrect downcast errors\n    with `FutureOr`.\n  - Issue [32233][issue 32233]. Errors when returning `FutureOr`.\n  - Issue [33218][issue 33218]. Returns in functions with void related types.\n  - Issue [31278][issue 31278]. Incorrect hint on empty returns in async.\n    functions.\n\n- An empty `return;` in an async function with return type `Future<Object>` does\n  not report an error.\n\n- `return exp;` where `exp` has type `void` in an async function is now an error\n  unless the return type of the function is `void` or `dynamic`.\n\n- Mixed return statements of the form `return;` and `return exp;` are now\n  allowed when `exp` has type `void`.\n\n- A compile time error is emitted for any literal which cannot be exactly\n  represented on the target platform. As a result, dart2js and DDC report errors\n  if an integer literal cannot be represented exactly in JavaScript ([issue\n  33282][]).\n\n- New member conflict rules have been implemented. Most cases of conflicting\n  members with the same name are now static errors ([issue 33235][]).\n\n[sdk#29014]: https://github.com/dart-lang/sdk/issues/29014\n[issue 30638]: https://github.com/dart-lang/sdk/issues/30638\n[issue 31278]: https://github.com/dart-lang/sdk/issues/31278\n[issue 31887]: https://github.com/dart-lang/sdk/issues/31887\n[issue 32233]: https://github.com/dart-lang/sdk/issues/32233\n[issue 32881]: https://github.com/dart-lang/sdk/issues/32881\n[issue 33218]: https://github.com/dart-lang/sdk/issues/33218\n[issue 33235]: https://github.com/dart-lang/sdk/issues/33235\n[issue 33282]: https://github.com/dart-lang/sdk/issues/33282\n[issue 33341]: https://github.com/dart-lang/sdk/issues/33341\n\n### Core libraries\n\n- Replaced `UPPER_CASE` constant names with `lowerCamelCase`. For example,\n  `HTML_ESCAPE` is now `htmlEscape`.\n\n- The Web libraries were re-generated using Chrome 63 WebIDLs ([details][idl]).\n\n[idl]: https://github.com/dart-lang/sdk/wiki/Chrome-63-Dart-Web-Libraries\n\n#### `dart:async`\n\n- `Stream`:\n  - Added `cast` and `castFrom`.\n  - Changed `firstWhere`, `lastWhere`, and `singleWhere` to return `Future<T>`\n    and added an optional `T orElse()` callback.\n- `StreamTransformer`: added `cast` and `castFrom`.\n- `StreamTransformerBase`: new class.\n- `Timer`: added `tick` property.\n- `Zone`\n  - changed to be strong-mode clean. This required some breaking API changes.\n    See https://goo.gl/y9mW2x for more information.\n  - Added `bindBinaryCallbackGuarded`, `bindCallbackGuarded`, and\n    `bindUnaryCallbackGuarded`.\n  - Renamed `Zone.ROOT` to `Zone.root`.\n- Removed the deprecated `defaultValue` parameter on `Stream.firstWhere` and\n  `Stream.lastWhere`.\n- Changed an internal lazily-allocated reusable \"null future\" to always belong\n  to the root zone. This avoids race conditions where the first access to the\n  future determined which zone it would belong to. The zone is only used for\n  _scheduling_ the callback of listeners, the listeners themselves will run in\n  the correct zone in any case. Issue [#32556](http://dartbug.com/32556).\n\n#### `dart:cli`\n\n- _New_ \"provisional\" library for CLI-specific features.\n- `waitFor`: function that suspends a stack to wait for a `Future` to complete.\n\n#### `dart:collection`\n\n- `MapBase`: added `mapToString`.\n- `LinkedHashMap` no longer implements `HashMap`\n- `LinkedHashSet` no longer implements `HashSet`.\n- Added `of` constructor to `Queue`, `ListQueue`, `DoubleLinkedQueue`,\n  `HashSet`, `LinkedHashSet`, `SplayTreeSet`, `Map`, `HashMap`, `LinkedHashMap`,\n  `SplayTreeMap`.\n- Removed `Maps` class. Extend `MapBase` or mix in `MapMixin` instead to provide\n  map method implementations for a class.\n- Removed experimental `Document` method `getCSSCanvasContext` and property\n  `supportsCssCanvasContext`.\n- Removed obsolete `Element` property `xtag` no longer supported in browsers.\n- Exposed `ServiceWorker` class.\n- Added constructor to `MessageChannel` and `MessagePort` `addEventListener`\n  automatically calls `start` method to receive queued messages.\n\n#### `dart:convert`\n\n- `Base64Codec.decode` return type is now `Uint8List`.\n- `JsonUnsupportedObjectError`: added `partialResult` property\n- `LineSplitter` now implements `StreamTransformer<String, String>` instead of\n  `Converter`. It retains `Converter` methods `convert` and\n  `startChunkedConversion`.\n- `Utf8Decoder` when compiled with dart2js uses the browser's `TextDecoder` in\n  some common cases for faster decoding.\n- Renamed `ASCII`, `BASE64`, `BASE64URI`, `JSON`, `LATIN1` and `UTF8` to\n  `ascii`, `base64`, `base64Uri`, `json`, `latin1` and `utf8`.\n- Renamed the `HtmlEscapeMode` constants `UNKNOWN`, `ATTRIBUTE`, `SQ_ATTRIBUTE`\n  and `ELEMENT` to `unknown`, `attribute`, `sqAttribute` and `elements`.\n- Added `jsonEncode`, `jsonDecode`, `base64Encode`, `base64UrlEncode` and\n  `base64Decode` top-level functions.\n- Changed return type of `encode` on `AsciiCodec` and `Latin1Codec`, and\n  `convert` on `AsciiEncoder`, `Latin1Encoder`, to `Uint8List`.\n- Allow `utf8.decoder.fuse(json.decoder)` to ignore leading Unicode BOM.\n\n#### `dart:core`\n\n- `BigInt` class added to support integers greater than 64-bits.\n- Deprecated the `proxy` annotation.\n- Added `Provisional` class and `provisional` field.\n- Added `pragma` annotation.\n- `RegExp` added static `escape` function.\n- The `Uri` class now correctly handles paths while running on Node.js on\n  Windows.\n- Core collection changes:\n  - `Iterable` added members `cast`, `castFrom`, `followedBy` and `whereType`.\n  - `Iterable.singleWhere` added `orElse` parameter.\n  - `List` added `+` operator, `first` and `last` setters, and `indexWhere` and\n    `lastIndexWhere` methods, and static `copyRange` and `writeIterable`\n    methods.\n  - `Map` added `fromEntries` constructor.\n  - `Map` added `addEntries`, `cast`, `entries`, `map`, `removeWhere`, `update`\n    and `updateAll` members.\n  - `MapEntry`: new class used by `Map.entries`.\n  - _Note_: if a class extends `IterableBase`, `ListBase`, `SetBase` or\n    `MapBase` (or uses the corresponding mixins) from `dart:collection`, the new\n    members are implemented automatically.\n  - Added `of` constructor to `List`, `Set`, `Map`.\n- Renamed `double.INFINITY`, `double.NEGATIVE_INFINITY`, `double.NAN`,\n  `double.MAX_FINITE` and `double.MIN_POSITIVE` to `double.infinity`,\n  `double.negativeInfinity`, `double.nan`, `double.maxFinite` and\n  `double.minPositive`.\n- Renamed the following constants in `DateTime` to lower case: `MONDAY` through\n  `SUNDAY`, `DAYS_PER_WEEK` (as `daysPerWeek`), `JANUARY` through `DECEMBER` and\n  `MONTHS_PER_YEAR` (as `monthsPerYear`).\n- Renamed the following constants in `Duration` to lower case:\n  `MICROSECONDS_PER_MILLISECOND` to `microsecondsPerMillisecond`,\n  `MILLISECONDS_PER_SECOND` to `millisecondsPerSecond`, `SECONDS_PER_MINUTE` to\n  `secondsPerMinute`, `MINUTES_PER_HOUR` to `minutesPerHour`, `HOURS_PER_DAY` to\n  `hoursPerDay`, `MICROSECONDS_PER_SECOND` to `microsecondsPerSecond`,\n  `MICROSECONDS_PER_MINUTE` to `microsecondsPerMinute`, `MICROSECONDS_PER_HOUR`\n  to `microsecondsPerHour`, `MICROSECONDS_PER_DAY` to `microsecondsPerDay`,\n  `MILLISECONDS_PER_MINUTE` to `millisecondsPerMinute`, `MILLISECONDS_PER_HOUR`\n  to `millisecondsPerHour`, `MILLISECONDS_PER_DAY` to `millisecondsPerDay`,\n  `SECONDS_PER_HOUR` to `secondsPerHour`, `SECONDS_PER_DAY` to `secondsPerDay`,\n  `MINUTES_PER_DAY` to `minutesPerDay`, and `ZERO` to `zero`.\n- Added `typeArguments` to `Invocation` class.\n- Added constructors to invocation class that allows creation of `Invocation`\n  objects directly, without going through `noSuchMethod`.\n- Added `unaryMinus` and `empty` constant symbols on the `Symbol` class.\n- Changed return type of `UriData.dataAsBytes` to `Uint8List`.\n- Added `tryParse` static method to `int`, `double`, `num`, `BigInt`, `Uri` and\n  `DateTime`.\n- Deprecated `onError` parameter on `int.parse`, `double.parse` and `num.parse`.\n- Deprecated the `NoSuchMethodError` constructor.\n- `int.parse` on the VM no longer accepts unsigned hexadecimal numbers greater\n  than or equal to `2**63` when not prefixed by `0x`. (SDK issue\n  [32858](https://github.com/dart-lang/sdk/issues/32858))\n\n#### `dart:developer`\n\n- `Flow` class added.\n- `Timeline.startSync` and `Timeline.timeSync` now accepts an optional parameter\n  `flow` of type `Flow`. The `flow` parameter is used to generate flow timeline\n  events that are enclosed by the slice described by\n  `Timeline.{start,finish}Sync` and `Timeline.timeSync`.\n\n<!--\nStill need entries for all changes to dart:html since 1.x\n-->\n\n#### `dart:html`\n\n- Removed deprecated `query` and `queryAll`. Use `querySelector` and\n  `querySelectorAll`.\n\n#### `dart:io`\n\n- `HttpStatus` added `UPGRADE_REQUIRED`.\n- `IOOverrides` and `HttpOverrides` added to aid in writing tests that wish to\n  mock varios `dart:io` objects.\n- `Platform.operatingSystemVersion` added that gives a platform-specific String\n  describing the version of the operating system.\n- `ProcessStartMode.INHERIT_STDIO` added, which allows a child process to\n  inherit the parent's stdio handles.\n- `RawZLibFilter` added for low-level access to compression and decompression\n  routines.\n- Unified backends for `SecureSocket`, `SecurityContext`, and `X509Certificate`\n  to be consistent across all platforms. All `SecureSocket`, `SecurityContext`,\n  and `X509Certificate` properties and methods are now supported on iOS and OSX.\n- `SecurityContext.alpnSupported` deprecated as ALPN is now supported on all\n  platforms.\n- `SecurityContext`: added `withTrustedRoots` named optional parameter\n  constructor, which defaults to false.\n- Added a `timeout` parameter to `Socket.connect`, `RawSocket.connect`,\n  `SecureSocket.connect` and `RawSecureSocket.connect`. If a connection attempt\n  takes longer than the duration specified in `timeout`, a `SocketException`\n  will be thrown. Note: if the duration specified in `timeout` is greater than\n  the OS level timeout, a timeout may occur sooner than specified in `timeout`.\n- `Stdin.hasTerminal` added, which is true if stdin is attached to a terminal.\n- `WebSocket` added static `userAgent` property.\n- `RandomAccessFile.close` returns `Future<void>`\n- Added `IOOverrides.socketConnect`.\n- Added Dart-styled constants to `ZLibOptions`, `FileMode`, `FileLock`,\n  `FileSystemEntityType`, `FileSystemEvent`, `ProcessStartMode`,\n  `ProcessSignal`, `InternetAddressType`, `InternetAddress`, `SocketDirection`,\n  `SocketOption`, `RawSocketEvent`, and `StdioType`, and deprecated the old\n  `SCREAMING_CAPS` constants.\n- Added the Dart-styled top-level constants `zlib`, `gzip`, and\n  `systemEncoding`, and deprecated the old `SCREAMING_CAPS` top-level constants.\n- Removed the top-level `FileMode` constants `READ`, `WRITE`, `APPEND`,\n  `WRITE_ONLY`, and `WRITE_ONLY_APPEND`. Please use e.g. `FileMode.read`\n  instead.\n- Added `X509Certificate.der`, `X509Certificate.pem`, and\n  `X509Certificate.sha1`.\n- Added `FileSystemEntity.fromRawPath` constructor to allow for the creation of\n  `FileSystemEntity` using `Uint8List` buffers.\n- Dart-styled constants have been added for `HttpStatus`, `HttpHeaders`,\n  `ContentType`, `HttpClient`, `WebSocketStatus`, `CompressionOptions`, and\n  `WebSocket`. The `SCREAMING_CAPS` constants are marked deprecated. Note that\n  `HttpStatus.CONTINUE` is now `HttpStatus.continue_`, and that e.g.\n  `HttpHeaders.FIELD_NAME` is now `HttpHeaders.fieldNameHeader`.\n- Deprecated `Platform.packageRoot`, which is only used for `packages/`\n  directory resolution which is no longer supported. It will now always return\n  null, which is a value that was always possible for it to return previously.\n- Adds `HttpClient.connectionTimeout`.\n- Adds `{Socket,RawSocket,SecureSocket}.startConnect`. These return a\n  `ConnectionTask`, which can be used to cancel an in-flight connection attempt.\n\n#### `dart:isolate`\n\n- Make `Isolate.spawn` take a type parameter representing the argument type of\n  the provided function. This allows functions with arguments types other than\n  `Object` in strong mode.\n- Rename `IMMEDIATE` and `BEFORE_NEXT_EVENT` on `Isolate` to `immediate` and\n  `beforeNextEvent`.\n- Deprecated `Isolate.packageRoot`, which is only used for `packages/` directory\n  resolution which is no longer supported. It will now always return null, which\n  is a value that was always possible for it to return previously.\n- Deprecated `packageRoot` parameter in `Isolate.spawnUri`, which is was\n  previously used only for `packages/` directory resolution. That style of\n  resolution is no longer supported in Dart 2.\n\n<!--\nStill need entries for all changes to dart:js since 1.x\n-->\n\n#### `dart.math`\n\n- Renamed `E`, `LN10`, `LN`, `LOG2E`, `LOG10E`, `PI`, `SQRT1_2` and `SQRT2` to\n  `e`, `ln10`, `ln`, `log2e`, `log10e`, `pi`, `sqrt1_2` and `sqrt2`.\n\n#### `dart.mirrors`\n\n- Added `IsolateMirror.loadUri`, which allows dynamically loading additional\n  code.\n- Marked `MirrorsUsed` as deprecated. The `MirrorsUsed` annotation was only used\n  to inform the dart2js compiler about how mirrors were used, but dart2js no\n  longer supports the mirrors library altogether.\n\n<!--\nStill need entries for all changes to dart:svg since 1.x\n-->\n\n#### `dart:typed_data`\n\n- Added `Unmodifiable` view classes over all `List` types.\n- Renamed `BYTES_PER_ELEMENT` to `bytesPerElement` on all typed data lists.\n- Renamed constants `XXXX` through `WWWW` on `Float32x4` and `Int32x4` to\n  lower-case `xxxx` through `wwww`.\n- Renamed `Endinanness` to `Endian` and its constants from `BIG_ENDIAN`,\n  `LITTLE_ENDIAN` and `HOST_ENDIAN` to `little`, `big` and `host`.\n\n<!--\nStill need entries for all changes to dart:web_audio,web_gl,web_sql since 1.x\n-->\n\n### Dart VM\n\n- Support for MIPS has been removed.\n\n- Dart `int` is now restricted to 64 bits. On overflow, arithmetic operations\n  wrap around, and integer literals larger than 64 bits are not allowed. See\n  https://github.com/dart-lang/sdk/blob/main/docs/language/informal/int64.md\n  for details.\n\n- The Dart VM no longer attempts to perform `packages/` directory resolution\n  (for loading scripts, and in `Isolate.resolveUri`). Users relying on\n  `packages/` directories should switch to `.packages` files.\n\n### Dart for the Web\n\n- Expose JavaScript Promise APIs using Dart futures. For example,\n  `BackgroundFetchManager.get` is defined as:\n\n  ```dart\n    Future<BackgroundFetchRegistration> get(String id)\n  ```\n\n  It can be used like:\n\n  ```dart\n  BackgroundFetchRegistration result = await fetchMgr.get('abc');\n  ```\n\n  The underlying JS Promise-to-Future mechanism will be exposed as a public API\n  in the future.\n\n#### Dart Dev Compiler (DDC)\n\n- dartdevc will no longer throw an error from `is` checks that return a\n  different result in weak mode (SDK [issue 28988][sdk#28988]). For example:\n\n  ```dart\n  main() {\n    List l = [];\n    // Prints \"false\", does not throw.\n    print(l is List<String>);\n  }\n  ```\n\n- Failed `as` casts on `Iterable<T>`, `Map<T>`, `Future<T>`, and `Stream<T>` are\n  no longer ignored. These failures were ignored to make it easier to migrate\n  Dart 1 code to strong mode, but ignoring them is a hole in the type system.\n  This closes part of that hole. (We still need to stop ignoring \"as\" cast\n  failures on function types, and implicit cast failures on the above types and\n  function types.)\n\n[sdk#28988]: https://github.com/dart-lang/sdk/issues/28988\n\n#### dart2js\n\n- dart2js now compiles programs with Dart 2.0 semantics. Apps are expected to be\n  bigger than before, because Dart 2.0 has many more implicit checks (similar to\n  the `--checked` flag in Dart 1.0).\n\n  We exposed a `--omit-implicit-checks` flag which removes most of the extra\n  implicit checks. Only use this if you have enough test coverage to know that\n  the app will work well without the checks. If a check would have failed and it\n  is omitted, your app may crash or behave in unexpected ways. This flag is\n  similar to `--trust-type-annotations` in Dart 1.0.\n\n- dart2js replaced its front-end with the common front-end (CFE). Thanks to the\n  CFE, dart2js errors are more consistent with all other Dart tools.\n\n- dart2js replaced its source-map implementation. There aren't any big\n  differences, but more data is emitted for synthetic code generated by the\n  compiler.\n\n- `dart:mirrors` support was removed. Frameworks are encouraged to use\n  code-generation instead. Conditional imports indicate that mirrors are not\n  supported, and any API in the mirrors library will throw at runtime.\n\n- The generated output of dart2js can now be run as a webworker.\n\n- `dart:isolate` support was removed. To launch background tasks, please use\n  webworkers instead. APIs for webworkers can be accessed from `dart:html` or\n  JS-interop.\n\n- dart2js no longer supports the `--package-root` flag. This flag was deprecated\n  in favor of `--packages` long ago.\n\n### Tool Changes\n\n#### Analyzer\n\n- The analyzer will no longer issue a warning when a generic type parameter is\n  used as the type in an instance check. For example:\n\n  ```dart\n  test<T>() {\n    print(3 is T); // No warning\n  }\n  ```\n\n- New static checking of `@visibleForTesting` elements. Accessing a method,\n  function, class, etc. annotated with `@visibleForTesting` from a file _not_ in\n  a `test/` directory will result in a new hint ([issue 28273][]).\n\n- Static analysis now respects functions annotated with `@alwaysThrows` ([issue\n  31384][]).\n\n- New hints added:\n\n  - `NULL_AWARE_BEFORE_OPERATOR` when an operator is used after a null-aware\n    access. For example:\n\n    ```dart\n    x?.a - ''; // HINT\n    ```\n\n  - `NULL_AWARE_IN_LOGICAL_OPERATOR` when an expression with null-aware access\n    is used as a condition in logical operators. For example:\n\n    ```dart\n    x.a || x?.b; // HINT\n    ```\n\n- The command line analyzer (dartanalyzer) and the analysis server no longer\n  treat directories named `packages` specially. Previously they had ignored\n  these directories - and their contents - from the point of view of analysis.\n  Now they'll be treated just as regular directories. This special-casing of\n  `packages` directories was to support using symlinks for package: resolution;\n  that functionality is now handled by `.packages` files.\n\n- New static checking of duplicate shown or hidden names in an export directive\n  ([issue 33182][]).\n\n- The analysis server will now only analyze code in Dart 2 mode ('strong mode').\n  It will emit warnings for analysis options files that have\n  `strong-mode: false` set (and will emit a hint for `strong-mode: true`, which\n  is no longer necessary).\n\n- The dartanalyzer `--strong` flag is now deprecated and ignored. The\n  command-line analyzer now only analyzes code in strong mode.\n\n[issue 28273]: https://github.com/dart-lang/sdk/issues/28273\n[issue 31384]: https://github.com/dart-lang/sdk/issues/31384\n[issue 33182]: https://github.com/dart-lang/sdk/issues/33182\n\n#### dartfmt\n\n- Support `assert()` in const constructor initializer lists.\n\n- Better formatting for multi-line strings in argument lists.\n\n- Force splitting an empty block as the then body of an if with an else.\n\n- Support metadata annotations on enum cases.\n\n- Add `--fix` to remove unneeded `new` and `const` keywords, and change `:` to\n  `=` before named parameter default values.\n\n- Change formatting rules around static methods to uniformly format code with\n  and without `new` and `const`.\n\n- Format expressions inside string interpolation.\n\n#### Pub\n\n- Pub has a brand new version solver! It supports all the same features as the\n  old version solver, but it's much less likely to stall out on difficult\n  package graphs, and it's much clearer about why a solution can't be found when\n  version solving fails.\n\n- Remove support for transformers, `pub build`, and `pub serve`. Use the [new\n  build system][transformers] instead.\n\n- There is now a default SDK constraint of `<2.0.0` for any package with no\n  existing upper bound. This allows us to move more safely to 2.0.0. All new\n  packages published on pub will now require an upper bound SDK constraint so\n  future major releases of Dart don't destabilize the package ecosystem.\n\n  All SDK constraint exclusive upper bounds are now treated as though they allow\n  pre-release versions of that upper bound. For example, the SDK constraint\n  `>=1.8.0 <2.0.0` now allows pre-release SDK versions such as `2.0.0-beta.3.0`.\n  This allows early adopters to try out packages that don't explicitly declare\n  support for the new version yet. You can disable this functionality by setting\n  the `PUB_ALLOW_PRERELEASE_SDK` environment variable to `false`.\n\n- Allow depending on a package in a subdirectory of a Git repository. Git\n  dependencies may now include a `path` parameter, indicating that the package\n  exists in a subdirectory of the Git repository. For example:\n\n  ```yaml\n  dependencies:\n    foobar:\n      git:\n        url: git://github.com/dart-lang/multi_package_repo\n        path: pkg/foobar\n  ```\n\n- Added an `--executables` option to `pub deps` command. This will list all\n  available executables that can be run with `pub run`.\n\n- The Flutter `sdk` source will now look for packages in\n  `flutter/bin/cache/pkg/` as well as `flutter/packages/`. In particular, this\n  means that packages can depend on the `sky_engine` package from the `sdk`\n  source ([issue 1775][pub#1775]).\n\n- Pub now caches compiled packages and snapshots in the `.dart_tool/pub`\n  directory, rather than the `.pub` directory ([issue 1795][pub#1795]).\n\n- Other bug fixes and improvements.\n\n[issue 30246]: https://github.com/dart-lang/sdk/issues/30246\n[pub#1679]: https://github.com/dart-lang/pub/issues/1679\n[pub#1684]: https://github.com/dart-lang/pub/issues/1684\n[pub#1775]: https://github.com/dart-lang/pub/issues/1775\n[pub#1795]: https://github.com/dart-lang/pub/issues/1795\n[pub#1823]: https://github.com/dart-lang/pub/issues/1823\n\n## 1.24.3 - 2017-12-14\n\n- Fix for constructing a new SecurityContext that contains the built-in\n  certificate authority roots\n  ([issue 24693](https://github.com/dart-lang/sdk/issues/24693)).\n\n### Core library changes\n\n- `dart:io`\n  - Unified backends for `SecureSocket`, `SecurityContext`, and\n    `X509Certificate` to be consistent across all platforms. All `SecureSocket`,\n    `SecurityContext`, and `X509Certificate` properties and methods are now\n    supported on iOS and OSX.\n\n## 1.24.2 - 2017-06-22\n\n- Fixes for debugging in Dartium.\n  - Fix DevConsole crash with JS\n    ([issue 29873](https://github.com/dart-lang/sdk/issues/29873)).\n  - Fix debugging in WebStorm, NULL returned for JS objects\n    ([issue 29854](https://github.com/dart-lang/sdk/issues/29854)).\n\n## 1.24.1 - 2017-06-14\n\n- Bug fixes for dartdevc support in `pub serve`.\n  - Fixed module config invalidation logic so modules are properly recalculated\n    when package layout changes.\n  - Fixed exception when handling require.js errors that aren't script load\n    errors.\n  - Fixed an issue where requesting the bootstrap.js file before the dart.js\n    file would result in a 404.\n  - Fixed a Safari issue during bootstrapping (note that Safari is still not\n    officially supported but does work for trivial examples).\n- Fix for a Dartium issue where there was no sound in checked mode\n  ([issue 29810](https://github.com/dart-lang/sdk/issues/29810)).\n\n## 1.24.0 - 2017-06-12\n\n### Language\n\n- During a dynamic type check, `void` is not required to be `null` anymore. In\n  practice, this makes overriding `void` functions with non-`void` functions\n  safer.\n\n- During static analysis, a function or setter declared using `=>` with return\n  type `void` now allows the returned expression to have any type. For example,\n  assuming the declaration `int x;`, it is now type correct to have\n  `void f() => ++x;`.\n\n- A new function-type syntax has been added to the language. **Warning**: _In\n  Dart 1.24, this feature is incomplete, and not stable in the Analyzer._\n\n  Intuitively, the type of a function can be constructed by textually replacing\n  the function's name with `Function` in its declaration. For instance, the type\n  of `void foo() {}` would be `void Function()`. The new syntax may be used\n  wherever a type can be written. It is thus now possible to declare fields\n  containing functions without needing to write typedefs: `void Function() x;`.\n  The new function type has one restriction: it may not contain the old-style\n  function-type syntax for its parameters. The following is thus illegal:\n  `void Function(int f())`. `typedefs` have been updated to support this new\n  syntax.\n\n  Examples:\n\n  ```dart\n  typedef F = void Function();  // F is the name for a `void` callback.\n  int Function(int) f;  // A field `f` that contains an int->int function.\n\n  class A<T> {\n    // The parameter `callback` is a function that takes a `T` and returns\n    // `void`.\n    void forEach(void Function(T) callback);\n  }\n\n  // The new function type supports generic arguments.\n  typedef Invoker = T Function<T>(T Function() callback);\n  ```\n\n### Core library changes\n\n- `dart:async`, `dart:core`, `dart:io`\n\n  - Adding to a closed sink, including `IOSink`, is no longer not allowed. In\n    1.24, violations are only reported (on stdout or stderr), but a future\n    version of the Dart SDK will change this to throwing a `StateError`.\n\n- `dart:convert`\n\n  - **BREAKING** Removed the deprecated `ChunkedConverter` class.\n  - JSON maps are now typed as `Map<String, dynamic>` instead of\n    `Map<dynamic, dynamic>`. A JSON-map is not a `HashMap` or `LinkedHashMap`\n    anymore (but just a `Map`).\n\n- `dart:io`\n\n  - Added `Platform.localeName`, needed for accessing the locale on platforms\n    that don't store it in an environment variable.\n  - Added `ProcessInfo.currentRss` and `ProcessInfo.maxRss` for inspecting the\n    Dart VM process current and peak resident set size.\n  - Added `RawSynchronousSocket`, a basic synchronous socket implementation.\n\n- `dart:` web APIs have been updated to align with Chrome v50. This change\n  includes **a large number of changes**, many of which are breaking. In some\n  cases, new class names may conflict with names that exist in existing code.\n\n- `dart:html`\n\n  - **REMOVED** classes: `Bluetooth`, `BluetoothDevice`,\n    `BluetoothGattCharacteristic`, `BluetoothGattRemoteServer`,\n    `BluetoothGattService`, `BluetoothUuid`, `CrossOriginConnectEvent`,\n    `DefaultSessionStartEvent`, `DomSettableTokenList`, `MediaKeyError`,\n    `PeriodicSyncEvent`, `PluginPlaceholderElement`, `ReadableStream`,\n    `StashedMessagePort`, `SyncRegistration`\n\n  - **REMOVED** members:\n\n    - `texImage2DCanvas` was removed from `RenderingContext`.\n    - `endClip` and `startClip` were removed from `Animation`.\n    - `after` and `before` were removed from `CharacterData`, `ChildNode` and\n      `Element`.\n    - `keyLocation` was removed from `KeyboardEvent`. Use `location` instead.\n    - `generateKeyRequest`, `keyAddedEvent`, `keyErrorEvent`, `keyMessageEvent`,\n      `mediaGroup`, `needKeyEvent`, `onKeyAdded`, `onKeyError`, `onKeyMessage`,\n      and `onNeedKey` were removed from `MediaElement`.\n    - `getStorageUpdates` was removed from `Navigator`\n    - `status` was removed from `PermissionStatus`\n    - `getAvailability` was removed from `PreElement`\n\n  - Other behavior changes:\n    - URLs returned in CSS or html are formatted with quoted string. Like\n      `url(\"http://google.com\")` instead of `url(http://google.com)`.\n    - Event timestamp property type changed from `int` to `num`.\n    - Chrome introduced slight layout changes of UI objects. In addition many\n      height/width dimensions are returned in subpixel values (`num` instead of\n      whole numbers).\n    - `setRangeText` with a `selectionMode` value of 'invalid' is no longer\n      valid. Only \"select\", \"start\", \"end\", \"preserve\" are allowed.\n\n- `dart:svg`\n\n  - A large number of additions and removals. Review your use of `dart:svg`\n    carefully.\n\n- `dart:web_audio`\n\n  - new method on `AudioContext` - `createIirFilter` returns a new class\n    `IirFilterNode`.\n\n- `dart:web_gl`\n\n  - new classes: `CompressedTextureAstc`, `ExtColorBufferFloat`,\n    `ExtDisjointTimerQuery`, and `TimerQueryExt`.\n\n  - `ExtFragDepth` added: `readPixels2` and `texImage2D2`.\n\n#### Strong Mode\n\n- Removed ad hoc `Future.then` inference in favor of using `FutureOr`. Prior to\n  adding `FutureOr` to the language, the analyzer implemented an ad hoc type\n  inference for `Future.then` (and overrides) treating it as if the onValue\n  callback was typed to return `FutureOr` for the purposes of inference. This ad\n  hoc inference has been removed now that `FutureOr` has been added.\n\n  Packages that implement `Future` must either type the `onValue` parameter to\n  `.then` as returning `FutureOr<T>`, or else must leave the type of the\n  parameter entirely to allow inference to fill in the type.\n\n- During static analysis, a function or setter declared using `=>` with return\n  type `void` now allows the returned expression to have any type.\n\n### Tool Changes\n\n- Dartium\n\n  Dartium is now based on Chrome v50. See _Core library changes_ above for\n  details on the changed APIs.\n\n- Pub\n\n  - `pub build` and `pub serve`\n\n    - Added support for the Dart Development Compiler.\n\n      Unlike dart2js, this new compiler is modular, which allows pub to do\n      incremental re-builds for `pub serve`, and potentially `pub build` in the\n      future.\n\n      In practice what that means is you can edit your Dart files, refresh in\n      Chrome (or other supported browsers), and see your edits almost\n      immediately. This is because pub is only recompiling your package, not all\n      packages that you depend on.\n\n      There is one caveat with the new compiler, which is that your package and\n      your dependencies must all be strong mode clean. If you are getting an\n      error compiling one of your dependencies, you will need to file bugs or\n      send pull requests to get them strong mode clean.\n\n      There are two ways of opting into the new compiler:\n\n      - Use the new `--web-compiler` flag, which supports `dartdevc`, `dart2js`\n        or `none` as options. This is the easiest way to try things out without\n        changing the default.\n\n      - Add config to your pubspec. There is a new `web` key which supports a\n        single key called `compiler`. This is a map from mode names to compiler\n        to use. For example, to default to dartdevc in debug mode you can add\n        the following to your pubspec:\n\n        ```yaml\n        web:\n          compiler:\n            debug: dartdevc\n        ```\n\n      You can also use the new compiler to run your tests in Chrome much more\n      quickly than you can with dart2js. In order to do that, run\n      `pub serve test --web-compiler=dartdevc`, and then run\n      `pub run test -p chrome --pub-serve=8080`.\n\n    - The `--no-dart2js` flag has been deprecated in favor of\n      `--web-compiler=none`.\n\n    - `pub build` will use a failing exit code if there are errors in any\n      transformer.\n\n  - `pub publish`\n\n    - Added support for the UNLICENSE file.\n\n    - Packages that depend on the Flutter SDK may be published.\n\n  - `pub get` and `pub upgrade`\n\n    - Don't dump a stack trace when a network error occurs while fetching\n      packages.\n\n- dartfmt\n  - Preserve type parameters in new generic function typedef syntax.\n  - Add self-test validation to ensure formatter bugs do not cause user code to\n    be lost.\n\n### Infrastructure changes\n\n- As of this release, we'll show a warning when using the MIPS architecture.\n  Unless we learn about any critical use of Dart on MIPS in the meantime, we're\n  planning to deprecate support for MIPS starting with the next stable release.\n\n## 1.23.0 - 2017-04-21\n\n#### Strong Mode\n\n- Breaking change - it is now a strong mode error if a mixin causes a name\n  conflict between two private members (field/getter/setter/method) from a\n  different library. (SDK issue\n  [28809](https://github.com/dart-lang/sdk/issues/28809)).\n\nlib1.dart:\n\n```dart\nclass A {\n  int _x;\n}\n\nclass B {\n  int _x;\n}\n```\n\nlib2.dart:\n\n```dart\nimport 'lib1.dart';\n\nclass C extends A with B {}\n```\n\n```\n    error \u2022 The private name _x, defined by B, conflicts with the same name defined by A at tmp/lib2.dart:3:24 \u2022 private_collision_in_mixin_application\n```\n\n- Breaking change - strong mode will prefer the expected type to infer generic\n  types, functions, and methods (SDK issue\n  [27586](https://github.com/dart-lang/sdk/issues/27586)).\n\n  ```dart\n  main() {\n    List<Object> foo = /*infers: <Object>*/['hello', 'world'];\n    var bar = /*infers: <String>*/['hello', 'world'];\n  }\n  ```\n\n- Strong mode inference error messages are improved (SDK issue\n  [29108](https://github.com/dart-lang/sdk/issues/29108)).\n\n  ```dart\n  import 'dart:math';\n  test(Iterable/* fix is to add <num> here */ values) {\n    num n = values.fold(values.first as num, max);\n  }\n  ```\n\n  Now produces the error on the generic function \"max\":\n\n  ```\n  Couldn't infer type parameter 'T'.\n\n  Tried to infer 'dynamic' for 'T' which doesn't work:\n    Function type declared as '<T extends num>(T, T) \u2192 T'\n                  used where  '(num, dynamic) \u2192 num' is required.\n\n  Consider passing explicit type argument(s) to the generic.\n  ```\n\n- Strong mode supports overriding fields, `@virtual` is no longer required (SDK\n  issue [28120](https://github.com/dart-lang/sdk/issues/28120)).\n\n  ```dart\n  class C {\n    int x = 42;\n  }\n  class D extends C {\n    get x {\n      print(\"x got called\");\n      return super.x;\n    }\n  }\n  main() {\n    print(new D().x);\n  }\n  ```\n\n- Strong mode down cast composite warnings are no longer issued by default. (SDK\n  issue [28588](https://github.com/dart-lang/sdk/issues/28588)).\n\n```dart\nvoid test() {\n  List untyped = [];\n  List<int> typed = untyped; // No down cast composite warning\n}\n```\n\nTo opt back into the warnings, add the following to the\n[.analysis_options](https://www.dartlang.org/guides/language/analysis-options)\nfile for your project.\n\n```\nanalyzer:\n  errors:\n    strong_mode_down_cast_composite: warning\n```\n\n### Core library changes\n\n- `dart:core`\n  - Added `Uri.isScheme` function to check the scheme of a URI. Example:\n    `uri.isScheme(\"http\")`. Ignores case when comparing.\n  - Make `UriData.parse` validate its input better. If the data is base-64\n    encoded, the data is normalized wrt. alphabet and padding, and it contains\n    invalid base-64 data, parsing fails. Also normalizes non-base-64 data.\n- `dart:io`\n  - Added functions `File.lastAccessed`, `File.lastAccessedSync`,\n    `File.setLastModified`, `File.setLastModifiedSync`, `File.setLastAccessed`,\n    and `File.setLastAccessedSync`.\n  - Added `{Stdin,Stdout}.supportsAnsiEscapes`.\n\n### Dart VM\n\n- Calls to `print()` and `Stdout.write*()` now correctly print unicode\n  characters to the console on Windows. Calls to `Stdout.add*()` behave as\n  before.\n\n### Tool changes\n\n- Analysis\n\n  - `dartanalyzer` now follows the same rules as the analysis server to find an\n    analysis options file, stopping when an analysis options file is found:\n    - Search up the directory hierarchy looking for an analysis options file.\n    - If analyzing a project referencing the [Flutter](https://flutter.io/)\n      package, then use the\n      [default Flutter analysis options](https://github.com/flutter/flutter/blob/master/packages/flutter/lib/analysis_options_user.yaml)\n      found in `package:flutter`.\n    - If in a Bazel workspace, then use the analysis options in\n      `package:dart.analysis_options/default.yaml` if it exists.\n    - Use the default analysis options rules.\n  - In addition, specific to `dartanalyzer`:\n    - an analysis options file can be specified on the command line via\n      `--options` and that file will be used instead of searching for an\n      analysis options file.\n    - any analysis option specified on the command line (e.g. `--strong` or\n      `--no-strong`) takes precedence over any corresponding value specified in\n      the analysis options file.\n\n- Dartium, dart2js, and DDC\n\n  - Imports to `dart:io` are allowed, but the imported library is not supported\n    and will likely fail on most APIs at runtime. This change was made as a\n    stopgap measure to make it easier to write libraries that share code between\n    platforms (like package `http`). This might change again when configuration\n    specific imports are supported.\n\n- Pub\n\n  - Now sends telemetry data to `pub.dartlang.org` to allow better understanding\n    of why a particular package is being accessed.\n  - `pub publish`\n    - Warns if a package imports a package that's not a dependency from within\n      `lib/` or `bin/`, or a package that's not a dev dependency from within\n      `benchmark/`, `example/`, `test/` or `tool/`.\n    - No longer produces \"UID too large\" errors on OS X. All packages are now\n      uploaded with the user and group names set to \"pub\".\n    - No longer fails with a stack overflow when uploading a package that uses\n      Git submodules.\n  - `pub get` and `pub upgrade`\n    - Produce more informative error messages if they're run directly in a\n      package that uses Flutter.\n    - Properly unlock SDK and path dependencies if they have a new version\n      that's also valid according to the user's pubspec.\n\n- dartfmt\n  - Support new generic function typedef syntax.\n  - Make the precedence of cascades more visible.\n  - Fix a couple of places where spurious newlines were inserted.\n  - Correctly report unchanged formatting when reading from stdin.\n  - Ensure space between `-` and `--`. Code that does this is pathological, but\n    it technically meant dartfmt could change the semantics of the code.\n  - Preserve a blank line between enum cases.\n  - Other small formatting tweaks.\n\n## 1.22.1 - 2017-02-22\n\nPatch release, resolves two issues:\n\n- Dart VM crash: [Issue 28072](https://github.com/dart-lang/sdk/issues/28757)\n\n- Dart VM bug combining types, await, and deferred loading:\n  [Issue 28678](https://github.com/dart-lang/sdk/issues/28678)\n\n## 1.22.0 - 2017-02-14\n\n### Language\n\n- Breaking change:\n  ['Generalized tear-offs'](https://github.com/gbracha/generalizedTearOffs/blob/master/proposal.md)\n  are no longer supported, and will cause errors. We updated the language spec\n  and added warnings in 1.21, and are now taking the last step to fully\n  de-support them. They were previously only supported in the VM, and there are\n  almost no known uses of them in the wild.\n\n- The `assert()` statement has been expanded to support an optional second\n  `message` argument (SDK issue\n  [27342](https://github.com/dart-lang/sdk/issues/27342)).\n\n  The message is displayed if the assert fails. It can be any object, and it is\n  accessible as `AssertionError.message`. It can be used to provide more user\n  friendly exception outputs. As an example, the following assert:\n\n  ```dart\n  assert(configFile != null, \"Tool config missing. Please see https://goo.gl/k8iAi for details.\");\n  ```\n\n  would produce the following exception output:\n\n  ```\n  Unhandled exception:\n  'file:///Users/mit/tmp/tool/bin/main.dart': Failed assertion: line 9 pos 10:\n  'configFile != null': Tool config missing. Please see https://goo.gl/k8iAi for details.\n  #0      _AssertionError._doThrowNew (dart:core-patch/errors_patch.dart:33)\n  #1      _AssertionError._throwNew (dart:core-patch/errors_patch.dart:29)\n  #2      main (file:///Users/mit/tmp/tool/bin/main.dart:9:10)\n  ```\n\n- The `Null` type has been moved to the bottom of the type hierarchy. As such,\n  it is considered a subtype of every other type. The `null` _literal_ was\n  always treated as a bottom type. Now the named class `Null` is too:\n\n  ```dart\n  const empty = <Null>[];\n\n  String concatenate(List<String> parts) => parts.join();\n  int sum(List<int> numbers) => numbers.fold(0, (sum, n) => sum + n);\n\n  concatenate(empty); // OK.\n  sum(empty); // OK.\n  ```\n\n- Introduce `covariant` modifier on parameters. It indicates that the parameter\n  (and the corresponding parameter in any method that overrides it) has looser\n  override rules. In strong mode, these require a runtime type check to maintain\n  soundness, but enable an architectural pattern that is useful in some code.\n\n  It lets you specialize a family of classes together, like so:\n\n  ```dart\n  abstract class Predator {\n    void chaseAndEat(covariant Prey p);\n  }\n\n  abstract class Prey {}\n\n  class Mouse extends Prey {}\n\n  class Seal extends Prey {}\n\n  class Cat extends Predator {\n    void chaseAndEat(Mouse m) => ...\n  }\n\n  class Orca extends Predator {\n    void chaseAndEat(Seal s) => ...\n  }\n  ```\n\n  This isn't statically safe, because you could do:\n\n  ```dart\n  Predator predator = new Cat(); // Upcast.\n  predator.chaseAndEat(new Seal()); // Cats can't eat seals!\n  ```\n\n  To preserve soundness in strong mode, in the body of a method that uses a\n  covariant override (here, `Cat.chaseAndEat()`), the compiler automatically\n  inserts a check that the parameter is of the expected type. So the compiler\n  gives you something like:\n\n  ```dart\n  class Cat extends Predator {\n    void chaseAndEat(o) {\n      var m = o as Mouse;\n      ...\n    }\n  }\n  ```\n\n  Spec mode allows this unsound behavior on all parameters, even though users\n  rarely rely on it. Strong mode disallowed it initially. Now, strong mode lets\n  you opt into this behavior in the places where you do want it by using this\n  modifier. Outside of strong mode, the modifier is ignored.\n\n- Change instantiate-to-bounds rules for generic type parameters when running in\n  strong mode. If you leave off the type parameters from a generic type, we need\n  to decide what to fill them in with. Dart 1.0 says just use `dynamic`, but\n  that isn't sound:\n\n  ```dart\n  class Abser<T extends num> {\n     void absThis(T n) { n.abs(); }\n  }\n\n  var a = new Abser(); // Abser<dynamic>.\n  a.absThis(\"not a num\");\n  ```\n\n  We want the body of `absThis()` to be able to safely assume `n` is at least a\n  `num` -- that's why there's a constraint on T, after all. Implicitly using\n  `dynamic` as the type parameter in this example breaks that.\n\n  Instead, strong mode uses the bound. In the above example, it fills it in with\n  `num`, and then the second line where a string is passed becomes a static\n  error.\n\n  However, there are some cases where it is hard to figure out what that default\n  bound should be:\n\n  ```dart\n  class RuhRoh<T extends Comparable<T>> {}\n  ```\n\n  Strong mode's initial behavior sometimes produced surprising, unintended\n  results. For 1.22, we take a simpler approach and then report an error if a\n  good default type argument can't be found.\n\n### Core libraries\n\n- Define `FutureOr<T>` for code that works with either a future or an immediate\n  value of some type. For example, say you do a lot of text manipulation, and\n  you want a handy function to chain a bunch of them:\n\n  ```dart\n  typedef String StringSwizzler(String input);\n\n  String swizzle(String input, List<StringSwizzler> swizzlers) {\n    var result = input;\n    for (var swizzler in swizzlers) {\n      result = swizzler(result);\n    }\n\n    return result;\n  }\n  ```\n\n  This works fine:\n\n  ```dart\n  main() {\n    var result = swizzle(\"input\", [\n      (s) => s.toUpperCase(),\n      (s) => () => s * 2)\n    ]);\n    print(result); // \"INPUTINPUT\".\n  }\n  ```\n\n  Later, you realize you'd also like to support swizzlers that are asynchronous\n  (maybe they look up synonyms for words online). You could make your API\n  strictly asynchronous, but then users of simple synchronous swizzlers have to\n  manually wrap the return value in a `Future.value()`. Ideally, your\n  `swizzle()` function would be \"polymorphic over asynchrony\". It would allow\n  both synchronous and asynchronous swizzlers. Because `await` accepts immediate\n  values, it is easy to implement this dynamically:\n\n  ```dart\n  Future<String> swizzle(String input, List<StringSwizzler> swizzlers) async {\n    var result = input;\n    for (var swizzler in swizzlers) {\n      result = await swizzler(result);\n    }\n\n    return result;\n  }\n\n  main() async {\n    var result = swizzle(\"input\", [\n      (s) => s.toUpperCase(),\n      (s) => new Future.delayed(new Duration(milliseconds: 40), () => s * 2)\n    ]);\n    print(await result);\n  }\n  ```\n\n  What should the declared return type on StringSwizzler be? In the past, you\n  had to use `dynamic` or `Object`, but that doesn't tell the user much. Now,\n  you can do:\n\n  ```dart\n  typedef FutureOr<String> StringSwizzler(String input);\n  ```\n\n  Like the name implies, `FutureOr<String>` is a union type. It can be a\n  `String` or a `Future<String>`, but not anything else. In this case, that's\n  not super useful beyond just stating a more precise type for readers of the\n  code. It does give you a little better error checking in code that uses the\n  result of that.\n\n  `FutureOr<T>` becomes really important in _generic_ methods like\n  `Future.then()`. In those cases, having the type system understand this\n  magical union type helps type inference figure out the type argument of\n  `then()` based on the closure you pass it.\n\n  Previously, strong mode had hard-coded rules for handling `Future.then()`\n  specifically. `FutureOr<T>` exposes that functionality so third-party APIs can\n  take advantage of it too.\n\n### Tool changes\n\n- Dart2Js\n\n  - Remove support for (long-time deprecated) mixin typedefs.\n\n- Pub\n\n  - Avoid using a barback asset server for executables unless they actually use\n    transformers. This makes precompilation substantially faster, produces\n    better error messages when precompilation fails, and allows\n    globally-activated executables to consistently use the\n    `Isolate.resolvePackageUri()` API.\n\n  - On Linux systems, always ignore packages' original file owners and\n    permissions when extracting those packages. This was already the default\n    under most circumstances.\n\n  - Properly close the standard input stream of child processes started using\n    `pub run`.\n\n  - Handle parse errors from the package cache more gracefully. A package whose\n    pubspec can't be parsed will now be ignored by `pub get --offline` and\n    deleted by `pub cache repair`.\n\n  - Make `pub run` run executables in spawned isolates. This lets them handle\n    signals and use standard IO reliably.\n\n  - Fix source-maps produced by dart2js when running in `pub serve`: URL\n    references to assets from packages match the location where `pub serve`\n    serves them (`packages/package_name/` instead of\n    `../packages/package_name/`).\n\n### Infrastructure changes\n\n- The SDK now uses GN rather than gyp to generate its build files, which will\n  now be exclusively ninja flavored. Documentation can be found on our\n  [wiki](https://github.com/dart-lang/sdk/wiki/Building-with-GN). Also see the\n  help message of `tools/gn.py`. This change is in response to the deprecation\n  of gyp. Build file generation with gyp will continue to be available in this\n  release by setting the environment variable `DART_USE_GYP` before running\n  `gclient sync` or `gclient runhooks`, but this will be removed in a future\n  release.\n\n## 1.21.1 - 2017-01-13\n\nPatch release, resolves one issue:\n\n- Dart VM: Snapshots of generic functions fail.\n  [Issue 28072](https://github.com/dart-lang/sdk/issues/28072)\n\n## 1.21.0 - 2016-12-07\n\n### Language\n\n- Support generic method syntax. Type arguments are not available at runtime.\n  For details, check the\n  [informal specification](https://gist.github.com/eernstg/4353d7b4f669745bed3a5423e04a453c).\n- Support access to initializing formals, e.g., the use of `x` to initialize `y`\n  in `class C { var x, y; C(this.x): y = x; }`. Please check the\n  [informal specification](https://gist.github.com/eernstg/cff159be9e34d5ea295d8c24b1a3e594)\n  for details.\n- Don't warn about switch case fallthrough if the case ends in a `rethrow`\n  statement. (SDK issue [27650](https://github.com/dart-lang/sdk/issues/27650))\n- Also don't warn if the entire switch case is wrapped in braces - as long as\n  the block ends with a `break`, `continue`, `rethrow`, `return` or `throw`.\n- Allow `=` as well as `:` as separator for named parameter default values.\n\n  ```dart\n  enableFlags({bool hidden: false}) { \u2026 }\n  ```\n\n  can now be replaced by\n\n  ```dart\n  enableFlags({bool hidden = false}) { \u2026 }\n  ```\n\n  (SDK issue [27559](https://github.com/dart-lang/sdk/issues/27559))\n\n### Core library changes\n\n- `dart:core`: `Set.difference` now takes a `Set<Object>` as argument. (SDK\n  issue [27573](https://github.com/dart-lang/sdk/issues/27573))\n\n- `dart:developer`\n\n  - Added `Service` class.\n    - Allows inspecting and controlling the VM service protocol HTTP server.\n    - Provides an API to access the ID of an `Isolate`.\n\n### Tool changes\n\n- Dart Dev Compiler\n\n  - Support calls to `loadLibrary()` on deferred libraries. Deferred libraries\n    are still loaded eagerly. (SDK issue\n    [27343](https://github.com/dart-lang/sdk/issues/27343))\n\n## 1.20.1 - 2016-10-13\n\nPatch release, resolves one issue:\n\n- Dartium: Fixes a bug that caused crashes. No issue filed.\n\n### Strong Mode\n\n- It is no longer a warning when casting from dynamic to a composite type (SDK\n  issue [27766](https://github.com/dart-lang/sdk/issues/27766)).\n\n  ```dart\n  main() {\n    dynamic obj = <int>[1, 2, 3];\n    // This is now allowed without a warning.\n    List<int> list = obj;\n  }\n  ```\n\n## 1.20.0 - 2016-10-11\n\n### Dart VM\n\n- We have improved the way that the VM locates the native code library for a\n  native extension (e.g. `dart-ext:` import). We have updated this\n  [article on native extensions](https://www.dartlang.org/articles/dart-vm/native-extensions)\n  to reflect the VM's improved behavior.\n\n- Linux builds of the VM will now use the `tcmalloc` library for memory\n  allocation. This has the advantages of better debugging and profiling support\n  and faster small allocations, with the cost of slightly larger initial memory\n  footprint, and slightly slower large allocations.\n\n- We have improved the way the VM searches for trusted root certificates for\n  secure socket connections on Linux. First, the VM will look for trusted root\n  certificates in standard locations on the file system\n  (`/etc/pki/tls/certs/ca-bundle.crt` followed by `/etc/ssl/certs`), and only if\n  these do not exist will it fall back on the builtin trusted root certificates.\n  This behavior can be overridden on Linux with the new flags\n  `--root-certs-file` and `--root-certs-cache`. The former is the path to a file\n  containing the trusted root certificates, and the latter is the path to a\n  directory containing root certificate files hashed using `c_rehash`.\n\n- The VM now throws a catchable `Error` when method compilation fails. This\n  allows easier debugging of syntax errors, especially when testing. (SDK issue\n  [23684](https://github.com/dart-lang/sdk/issues/23684))\n\n### Core library changes\n\n- `dart:core`: Remove deprecated `Resource` class. Use the class in\n  `package:resource` instead.\n- `dart:async`\n  - `Future.wait` now catches synchronous errors and returns them in the\n    returned Future. (SDK issue\n    [27249](https://github.com/dart-lang/sdk/issues/27249))\n  - More aggressively returns a `Future` on `Stream.cancel` operations.\n    Discourages to return `null` from `cancel`. (SDK issue\n    [26777](https://github.com/dart-lang/sdk/issues/26777))\n  - Fixes a few bugs where the cancel future wasn't passed through\n    transformations.\n- `dart:io`\n  - Added `WebSocket.addUtf8Text` to allow sending a pre-encoded text message\n    without a round-trip UTF-8 conversion. (SDK issue\n    [27129](https://github.com/dart-lang/sdk/issues/27129))\n\n### Strong Mode\n\n- Breaking change - it is an error if a generic type parameter cannot be\n  inferred (SDK issue [26992](https://github.com/dart-lang/sdk/issues/26992)).\n\n  ```dart\n  class Cup<T> {\n    Cup(T t);\n  }\n  main() {\n    // Error because:\n    // - if we choose Cup<num> it is not assignable to `cOfInt`,\n    // - if we choose Cup<int> then `n` is not assignable to int.\n    num n;\n    C<int> cOfInt = new C(n);\n  }\n  ```\n\n- New feature - use `@checked` to override a method and tighten a parameter type\n  (SDK issue [25578](https://github.com/dart-lang/sdk/issues/25578)).\n\n  ```dart\n  import 'package:meta/meta.dart' show checked;\n  class View {\n    addChild(View v) {}\n  }\n  class MyView extends View {\n    // this override is legal, it will check at runtime if we actually\n    // got a MyView.\n    addChild(@checked MyView v) {}\n  }\n  main() {\n    dynamic mv = new MyView();\n    mv.addChild(new View()); // runtime error\n  }\n  ```\n\n- New feature - use `@virtual` to allow field overrides in strong mode (SDK\n  issue [27384](https://github.com/dart-lang/sdk/issues/27384)).\n\n  ```dart\n  import 'package:meta/meta.dart' show virtual;\n  class Base {\n    @virtual int x;\n  }\n  class Derived extends Base {\n    int x;\n\n    // Expose the hidden storage slot:\n    int get superX => super.x;\n    set superX(int v) { super.x = v; }\n  }\n  ```\n\n- Breaking change - infer list and map literals from the context type as well as\n  their values, consistent with generic methods and instance creation (SDK issue\n  [27151](https://github.com/dart-lang/sdk/issues/27151)).\n\n  ```dart\n  import 'dart:async';\n  main() async {\n    var b = new Future<B>.value(new B());\n    var c = new Future<C>.value(new C());\n    var/*infer List<Future<A>>*/ list = [b, c];\n    var/*infer List<A>*/ result = await Future.wait(list);\n  }\n  class A {}\n  class B extends A {}\n  class C extends A {}\n  ```\n\n### Tool changes\n\n- `dartfmt` - upgraded to v0.2.10\n\n  - Don't crash on annotations before parameters with trailing commas.\n  - Always split enum declarations if they end in a trailing comma.\n  - Add `--set-exit-if-changed` to set the exit code on a change.\n\n- Pub\n  - Pub no longer generates a `packages/` directory by default. Instead, it\n    generates a `.packages` file, called a package spec. To generate a\n    `packages/` directory in addition to the package spec, use the\n    `--packages-dir` flag with `pub get`, `pub upgrade`, and `pub downgrade`.\n    See the\n    [Good-bye symlinks](http://news.dartlang.org/2016/10/good-bye-symlinks.html)\n    article for details.\n\n## 1.19.1 - 2016-09-08\n\nPatch release, resolves one issue:\n\n- Dartdoc: Fixes a bug that prevented generation of docs. (Dartdoc issue\n  [1233](https://github.com/dart-lang/dartdoc/issues/1233))\n\n## 1.19.0 - 2016-08-26\n\n### Language changes\n\n- The language now allows a trailing comma after the last argument of a call and\n  the last parameter of a function declaration. This can make long argument or\n  parameter lists easier to maintain, as commas can be left as-is when\n  reordering lines. For details, see SDK issue\n  [26644](https://github.com/dart-lang/sdk/issues/26644).\n\n### Tool Changes\n\n- `dartfmt` - upgraded to v0.2.9+1\n\n  - Support trailing commas in argument and parameter lists.\n  - Gracefully handle read-only files.\n  - About a dozen other bug fixes.\n\n- Pub\n\n  - Added a `--no-packages-dir` flag to `pub get`, `pub upgrade`, and\n    `pub downgrade`. When this flag is passed, pub will not generate a\n    `packages/` directory, and will remove that directory and any symlinks to it\n    if they exist. Note that this replaces the unsupported\n    `--no-package-symlinks` flag.\n\n  - Added the ability for packages to declare a constraint on the [Flutter][]\n    SDK:\n\n    ```yaml\n    environment:\n      flutter: ^0.1.2\n      sdk: >=1.19.0 <2.0.0\n    ```\n\n    A Flutter constraint will only be satisfiable when pub is running in the\n    context of the `flutter` executable, and when the Flutter SDK version\n    matches the constraint.\n\n  - Added `sdk` as a new package source that fetches packages from a hard-coded\n    SDK. Currently only the `flutter` SDK is supported:\n\n    ```yaml\n    dependencies:\n      flutter_driver:\n        sdk: flutter\n        version: ^0.0.1\n    ```\n\n    A Flutter `sdk` dependency will only be satisfiable when pub is running in\n    the context of the `flutter` executable, and when the Flutter SDK contains a\n    package with the given name whose version matches the constraint.\n\n  - `tar` files on Linux are now created with `0` as the user and group IDs.\n    This fixes a crash when publishing packages while using Active Directory.\n\n  - Fixed a bug where packages from a hosted HTTP URL were considered the same\n    as packages from an otherwise-identical HTTPS URL.\n\n  - Fixed timer formatting for timers that lasted longer than a minute.\n\n  - Eliminate some false negatives when determining whether global executables\n    are on the user's executable path.\n\n- `dart2js`\n  - `dart2dart` (aka `dart2js --output-type=dart`) has been removed (this was\n    deprecated in Dart 1.11).\n\n[flutter]: https://flutter.io/\n\n### Dart VM\n\n- The dependency on BoringSSL has been rolled forward. Going forward, builds of\n  the Dart VM including secure sockets will require a compiler with C++11\n  support. For details, see the\n  [Building wiki page](https://github.com/dart-lang/sdk/wiki/Building).\n\n### Strong Mode\n\n- New feature - an option to disable implicit casts (SDK issue\n  [26583](https://github.com/dart-lang/sdk/issues/26583)), see the\n  [documentation](https://github.com/dart-lang/dev_compiler/blob/master/doc/STATIC_SAFETY.md#disable-implicit-casts)\n  for usage instructions and examples.\n\n- New feature - an option to disable implicit dynamic (SDK issue\n  [25573](https://github.com/dart-lang/sdk/issues/25573)), see the\n  [documentation](https://github.com/dart-lang/dev_compiler/blob/master/doc/STATIC_SAFETY.md#disable-implicit-dynamic)\n  for usage instructions and examples.\n\n- Breaking change - infer generic type arguments from the constructor invocation\n  arguments (SDK issue [25220](https://github.com/dart-lang/sdk/issues/25220)).\n\n  ```dart\n  var map = new Map<String, String>();\n\n  // infer: Map<String, String>\n  var otherMap = new Map.from(map);\n  ```\n\n- Breaking change - infer local function return type (SDK issue\n  [26414](https://github.com/dart-lang/sdk/issues/26414)).\n\n  ```dart\n  void main() {\n    // infer: return type is int\n    f() { return 40; }\n    int y = f() + 2; // type checks\n    print(y);\n  }\n  ```\n\n- Breaking change - allow type promotion from a generic type parameter (SDK\n  issue [26414](https://github.com/dart-lang/sdk/issues/26965)).\n\n  ```dart\n  void fn/*<T>*/(/*=T*/ object) {\n    if (object is String) {\n      // Treat `object` as `String` inside this block.\n      // But it will require a cast to pass it to something that expects `T`.\n      print(object.substring(1));\n    }\n  }\n  ```\n\n- Breaking change - smarter inference for Future.then (SDK issue\n  [25944](https://github.com/dart-lang/sdk/issues/25944)). Previous workarounds\n  that use async/await or `.then/*<Future<SomeType>>*/` should no longer be\n  necessary.\n\n  ```dart\n  // This will now infer correctly.\n  Future<List<int>> t2 = f.then((_) => [3]);\n  // This infers too.\n  Future<int> t2 = f.then((_) => new Future.value(42));\n  ```\n\n- Breaking change - smarter inference for async functions (SDK issue\n  [25322](https://github.com/dart-lang/sdk/issues/25322)).\n\n  ```dart\n  void test() async {\n    List<int> x = await [4]; // was previously inferred\n    List<int> y = await new Future.value([4]); // now inferred too\n  }\n  ```\n\n- Breaking change - sideways casts are no longer allowed (SDK issue\n  [26120](https://github.com/dart-lang/sdk/issues/26120)).\n\n## 1.18.1 - 2016-08-02\n\nPatch release, resolves two issues and improves performance:\n\n- Debugger: Fixes a bug that crashes the VM (SDK issue\n  [26941](https://github.com/dart-lang/sdk/issues/26941))\n\n- VM: Fixes an optimizer bug involving closures, try, and await (SDK issue\n  [26948](https://github.com/dart-lang/sdk/issues/26948))\n\n- Dart2js: Speeds up generated code on Firefox\n  (https://codereview.chromium.org/2180533002)\n\n## 1.18.0 - 2016-07-27\n\n### Core library changes\n\n- `dart:core`\n  - Improved performance when parsing some common URIs.\n  - Fixed bug in `Uri.resolve` (SDK issue\n    [26804](https://github.com/dart-lang/sdk/issues/26804)).\n- `dart:io`\n  - Adds file locking modes `FileLock.BLOCKING_SHARED` and\n    `FileLock.BLOCKING_EXCLUSIVE`.\n\n## 1.17.1 - 2016-06-10\n\nPatch release, resolves two issues:\n\n- VM: Fixes a bug that caused crashes in async functions. (SDK issue\n  [26668](https://github.com/dart-lang/sdk/issues/26668))\n\n- VM: Fixes a bug that caused garbage collection of reachable weak properties.\n  (https://codereview.chromium.org/2041413005)\n\n## 1.17.0 - 2016-06-08\n\n### Core library changes\n\n- `dart:convert`\n\n  - Deprecate `ChunkedConverter` which was erroneously added in 1.16.\n\n- `dart:core`\n\n  - `Uri.replace` supports iterables as values for the query parameters.\n  - `Uri.parseIPv6Address` returns a `Uint8List`.\n\n- `dart:io`\n  - Added `NetworkInterface.listSupported`, which is `true` when\n    `NetworkInterface.list` is supported, and `false` otherwise. Currently,\n    `NetworkInterface.list` is not supported on Android.\n\n### Tool Changes\n\n- Pub\n\n  - TAR files created while publishing a package on Mac OS and Linux now use a\n    more portable format.\n\n  - Errors caused by invalid arguments now print the full usage information for\n    the command.\n\n  - SDK constraints for dependency overrides are no longer considered when\n    determining the total SDK constraint for a lockfile.\n\n  - A bug has been fixed in which a lockfile was considered up-to-date when it\n    actually wasn't.\n\n  - A bug has been fixed in which `pub get --offline` would crash when a\n    prerelease version was selected.\n\n- Dartium and content shell\n  - Debugging Dart code inside iframes improved, was broken.\n\n## 1.16.1 - 2016-05-24\n\nPatch release, resolves one issue:\n\n- VM: Fixes a bug that caused intermittent hangs on Windows. (SDK issue\n  [26400](https://github.com/dart-lang/sdk/issues/26400))\n\n## 1.16.0 - 2016-04-26\n\n### Core library changes\n\n- `dart:convert`\n\n  - Added `BASE64URL` codec and corresponding `Base64Codec.urlSafe` constructor.\n\n  - Introduce `ChunkedConverter` and deprecate chunked methods on `Converter`.\n\n- `dart:html`\n\n  There have been a number of **BREAKING** changes to align APIs with recent\n  changes in Chrome. These include:\n\n  - Chrome's `ShadowRoot` interface no longer has the methods `getElementById`,\n    `getElementsByClassName`, and `getElementsByTagName`, e.g.,\n\n    ```dart\n    elem.shadowRoot.getElementsByClassName('clazz')\n    ```\n\n    should become:\n\n    ```dart\n    elem.shadowRoot.querySelectorAll('.clazz')\n    ```\n\n  - The `clipboardData` property has been removed from `KeyEvent` and `Event`.\n    It has been moved to the new `ClipboardEvent` class, which is now used by\n    `copy`, `cut`, and `paste` events.\n\n  - The `layer` property has been removed from `KeyEvent` and `UIEvent`. It has\n    been moved to `MouseEvent`.\n\n  - The `Point get page` property has been removed from `UIEvent`. It still\n    exists on `MouseEvent` and `Touch`.\n\n  There have also been a number of other additions and removals to `dart:html`,\n  `dart:indexed_db`, `dart:svg`, `dart:web_audio`, and `dart:web_gl` that\n  correspond to changes to Chrome APIs between v39 and v45. Many of the breaking\n  changes represent APIs that would have caused runtime exceptions when compiled\n  to Javascript and run on recent Chrome releases.\n\n- `dart:io`\n  - Added `SecurityContext.alpnSupported`, which is true if a platform supports\n    ALPN, and false otherwise.\n\n### JavaScript interop\n\nFor performance reasons, a potentially **BREAKING** change was added for\nlibraries that use JS interop. Any Dart file that uses `@JS` annotations on\ndeclarations (top-level functions, classes or class members) to interop with\nJavaScript code will require that the file have the annotation `@JS()` on a\nlibrary directive.\n\n```dart\n@JS()\nlibrary my_library;\n```\n\nThe analyzer will enforce this by generating the error:\n\nThe `@JS()` annotation can only be used if it is also declared on the library\ndirective.\n\nIf part file uses the `@JS()` annotation, the library that uses the part should\nhave the `@JS()` annotation e.g.,\n\n```dart\n// library_1.dart\n@JS()\nlibrary library_1;\n\nimport 'package:js/js.dart';\n\npart 'part_1.dart';\n```\n\n```dart\n// part_1.dart\npart of library_1;\n\n@JS(\"frameworkStabilizers\")\nexternal List<FrameworkStabilizer> get frameworkStabilizers;\n```\n\nIf your library already has a JS module e.g.,\n\n```dart\n@JS('array.utils')\nlibrary my_library;\n```\n\nThen your library will work without any additional changes.\n\n### Analyzer\n\n- Static checking of `for in` statements. These will now produce static\n  warnings:\n\n  ```dart\n  // Not Iterable.\n  for (var i in 1234) { ... }\n\n  // String cannot be assigned to int.\n  for (int n in <String>[\"a\", \"b\"]) { ... }\n  ```\n\n### Tool Changes\n\n- Pub\n\n  - `pub serve` now provides caching headers that should improve the performance\n    of requesting large files multiple times.\n\n  - Both `pub get` and `pub upgrade` now have a `--no-precompile` flag that\n    disables precompilation of executables and transformed dependencies.\n\n  - `pub publish` now resolves symlinks when publishing from a Git repository.\n    This matches the behavior it always had when publishing a package that\n    wasn't in a Git repository.\n\n- Dart Dev Compiler\n\n  - The **experimental** `dartdevc` executable has been added to the SDK.\n\n  - It will help early adopters validate the implementation and provide\n    feedback. `dartdevc` **is not** yet ready for production usage.\n\n  - Read more about the Dart Dev Compiler [here][dartdevc].\n\n[dartdevc]: https://github.com/dart-lang/dev_compiler\n\n## 1.15.0 - 2016-03-09\n\n### Core library changes\n\n- `dart:async`\n\n  - Made `StreamView` class a `const` class.\n\n- `dart:core`\n\n  - Added `Uri.queryParametersAll` to handle multiple query parameters with the\n    same name.\n\n- `dart:io`\n  - Added `SecurityContext.usePrivateKeyBytes`,\n    `SecurityContext.useCertificateChainBytes`,\n    `SecurityContext.setTrustedCertificatesBytes`, and\n    `SecurityContext.setClientAuthoritiesBytes`.\n  - **Breaking** The named `directory` argument of\n    `SecurityContext.setTrustedCertificates` has been removed.\n  - Added support to `SecurityContext` for PKCS12 certificate and key\n    containers.\n  - All calls in `SecurityContext` that accept certificate data now accept an\n    optional named parameter `password`, similar to\n    `SecurityContext.usePrivateKeyBytes`, for use as the password for PKCS12\n    data.\n\n### Tool changes\n\n- Dartium and content shell\n\n  - The Chrome-based tools that ship as part of the Dart SDK - Dartium and\n    content shell - are now based on Chrome version 45 (instead of Chrome 39).\n  - Dart browser libraries (`dart:html`, `dart:svg`, etc) _have not_ been\n    updated.\n    - These are still based on Chrome 39.\n    - These APIs will be updated in a future release.\n  - Note that there are experimental APIs which have changed in the underlying\n    browser, and will not work with the older libraries. For example,\n    `Element.animate`.\n\n- `dartfmt` - upgraded to v0.2.4\n  - Better handling for long collections with comments.\n  - Always put member metadata annotations on their own line.\n  - Indent functions in named argument lists with non-functions.\n  - Force the parameter list to split if a split occurs inside a function-typed\n    parameter.\n  - Don't force a split for before a single named argument if the argument\n    itself splits.\n\n### Service protocol changes\n\n- Fixed a documentation bug where the field `extensionRPCs` in `Isolate` was not\n  marked optional.\n\n### Experimental language features\n\n- Added support for\n  [configuration-specific imports](https://github.com/munificent/dep-interface-libraries/blob/master/Proposal.md).\n  On the VM and `dart2js`, they can be enabled with `--conditional-directives`.\n\n  The analyzer requires additional configuration:\n\n  ```yaml\n  analyzer:\n    language:\n      enableConditionalDirectives: true\n  ```\n\n  Read about [configuring the analyzer] for more details.\n\n[configuring the analyzer]:\n  https://github.com/dart-lang/sdk/tree/master/pkg/analyzer#configuring-the-analyzer\n\n## 1.14.2 - 2016-02-10\n\nPatch release, resolves three issues:\n\n- VM: Fixed a code generation bug on x64. (SDK commit\n  [834b3f02](https://github.com/dart-lang/sdk/commit/834b3f02b6ab740a213fd808e6c6f3269bed80e5))\n\n- `dart:io`: Fixed EOF detection when reading some special device files. (SDK\n  issue [25596](https://github.com/dart-lang/sdk/issues/25596))\n\n- Pub: Fixed an error using hosted dependencies in SDK version 1.14. (Pub issue\n  [1386](https://github.com/dart-lang/pub/issues/1386))\n\n## 1.14.1 - 2016-02-04\n\nPatch release, resolves one issue:\n\n- Debugger: Fixes a VM crash when a debugger attempts to set a break point\n  during isolate initialization. (SDK issue\n  [25618](https://github.com/dart-lang/sdk/issues/25618))\n\n## 1.14.0 - 2016-01-28\n\n### Core library changes\n\n- `dart:async`\n\n  - Added `Future.any` static method.\n  - Added `Stream.fromFutures` constructor.\n\n- `dart:convert`\n\n  - `Base64Decoder.convert` now takes optional `start` and `end` parameters.\n\n- `dart:core`\n\n  - Added `current` getter to `StackTrace` class.\n  - `Uri` class added support for data URIs\n    - Added two new constructors: `dataFromBytes` and `dataFromString`.\n    - Added a `data` getter for `data:` URIs with a new `UriData` class for the\n      return type.\n  - Added `growable` parameter to `List.filled` constructor.\n  - Added microsecond support to `DateTime`: `DateTime.microsecond`,\n    `DateTime.microsecondsSinceEpoch`, and\n    `new DateTime.fromMicrosecondsSinceEpoch`.\n\n- `dart:math`\n\n  - `Random` added a `secure` constructor returning a cryptographically secure\n    random generator which reads from the entropy source provided by the\n    embedder for every generated random value.\n\n- `dart:io`\n\n  - `Platform` added a static `isIOS` getter and `Platform.operatingSystem` may\n    now return `ios`.\n  - `Platform` added a static `packageConfig` getter.\n  - Added support for WebSocket compression as standardized in RFC 7692.\n  - Compression is enabled by default for all WebSocket connections.\n    - The optionally named parameter `compression` on the methods\n      `WebSocket.connect`, `WebSocket.fromUpgradedSocket`, and\n      `WebSocketTransformer.upgrade` and the `WebSocketTransformer` constructor\n      can be used to modify or disable compression using the new\n      `CompressionOptions` class.\n\n- `dart:isolate`\n  - Added **_experimental_** support for [Package Resolution Configuration].\n    - Added `packageConfig` and `packageRoot` instance getters to `Isolate`.\n    - Added a `resolvePackageUri` method to `Isolate`.\n    - Added named arguments `packageConfig` and `automaticPackageResolution` to\n      the `Isolate.spawnUri` constructor.\n\n[package resolution configuration]:\n  https://github.com/dart-lang/dart_enhancement_proposals/blob/master/Accepted/0005%20-%20Package%20Specification/DEP-pkgspec.md\n\n### Tool changes\n\n- `dartfmt`\n\n  - Better line splitting in a variety of cases.\n\n  - Other optimizations and bug fixes.\n\n- Pub\n\n  - **Breaking:** Pub now eagerly emits an error when a pubspec's \"name\" field\n    is not a valid Dart identifier. Since packages with non-identifier names\n    were never allowed to be published, and some of them already caused crashes\n    when being written to a `.packages` file, this is unlikely to break many\n    people in practice.\n\n  - **Breaking:** Support for `barback` versions prior to 0.15.0 (released July\n\n    1.  has been dropped. Pub will no longer install these older barback\n        versions.\n\n  - `pub serve` now GZIPs the assets it serves to make load times more similar\n    to real-world use-cases.\n\n  - `pub deps` now supports a `--no-dev` flag, which causes it to emit the\n    dependency tree as it would be if no `dev_dependencies` were in use. This\n    makes it easier to see your package's dependency footprint as your users\n    will experience it.\n\n  - `pub global run` now detects when a global executable's SDK constraint is no\n    longer met and errors out, rather than trying to run the executable anyway.\n\n  - Pub commands that check whether the lockfile is up-to-date (`pub run`,\n    `pub deps`, `pub serve`, and `pub build`) now do additional verification.\n    They ensure that any path dependencies' pubspecs haven't been changed, and\n    they ensure that the current SDK version is compatible with all\n    dependencies.\n\n  - Fixed a crashing bug when using `pub global run` on a global script that\n    didn't exist.\n\n  - Fixed a crashing bug when a pubspec contains a dependency without a source\n    declared.\n\n## 1.13.2 - 2016-01-06\n\nPatch release, resolves one issue:\n\n- dart2js: Stack traces are not captured correctly (SDK issue [25235]\n  (https://github.com/dart-lang/sdk/issues/25235))\n\n## 1.13.1 - 2015-12-17\n\nPatch release, resolves three issues:\n\n- VM type propagation fix: Resolves a potential crash in the Dart VM (SDK commit\n  [dff13be]\n  (https://github.com/dart-lang/sdk/commit/dff13bef8de104d33b04820136da2d80f3c835d7))\n\n- dart2js crash fix: Resolves a crash in pkg/js and dart2js (SDK issue [24974]\n  (https://github.com/dart-lang/sdk/issues/24974))\n\n- Pub get crash on ARM: Fixes a crash triggered when running 'pub get' on ARM\n  processors such as those on a Raspberry Pi (SDK issue [24855]\n  (https://github.com/dart-lang/sdk/issues/24855))\n\n## 1.13.0 - 2015-11-18\n\n### Core library changes\n\n- `dart:async`\n\n  - `StreamController` added getters for `onListen`, `onPause`, and `onResume`\n    with the corresponding new `typedef void ControllerCallback()`.\n  - `StreamController` added a getter for `onCancel` with the corresponding new\n    `typedef ControllerCancelCallback()`;\n  - `StreamTransformer` instances created with `fromHandlers` with no\n    `handleError` callback now forward stack traces along with errors to the\n    resulting streams.\n\n- `dart:convert`\n\n  - Added support for Base-64 encoding and decoding.\n    - Added new classes `Base64Codec`, `Base64Encoder`, and `Base64Decoder`.\n    - Added new top-level `const Base64Codec BASE64`.\n\n- `dart:core`\n\n  - `Uri` added `removeFragment` method.\n  - `String.allMatches` (implementing `Pattern.allMatches`) is now lazy, as all\n    `allMatches` implementations are intended to be.\n  - `Resource` is deprecated, and will be removed in a future release.\n\n- `dart:developer`\n\n  - Added `Timeline` class for interacting with Observatory's timeline feature.\n  - Added `ServiceExtensionHandler`, `ServiceExtensionResponse`, and\n    `registerExtension` which enable developers to provide their own VM service\n    protocol extensions.\n\n- `dart:html`, `dart:indexed_db`, `dart:svg`, `dart:web_audio`, `dart:web_gl`,\n  `dart:web_sql`\n\n  - The return type of some APIs changed from `double` to `num`. Dartium is now\n    using JS interop for most operations. JS does not distinguish between\n    numeric types, and will return a number as an int if it fits in an int. This\n    will mostly cause an error if you assign to something typed `double` in\n    checked mode. You may need to insert a `toDouble()` call or accept `num`.\n    Examples of APIs that are affected include `Element.getBoundingClientRect`\n    and `TextMetrics.width`.\n\n- `dart:io`\n\n  - **Breaking:** Secure networking has changed, replacing the NSS library with\n    the BoringSSL library. `SecureSocket`, `SecureServerSocket`,\n    `RawSecureSocket`,`RawSecureServerSocket`, `HttpClient`, and `HttpServer`\n    now all use a `SecurityContext` object which contains the certificates and\n    keys used for secure TLS (SSL) networking.\n\n    This is a breaking change for server applications and for some client\n    applications. Certificates and keys are loaded into the `SecurityContext`\n    from PEM files, instead of from an NSS certificate database. Information\n    about how to change applications that use secure networking is at\n    https://www.dartlang.org/server/tls-ssl.html\n\n  - `HttpClient` no longer sends URI fragments in the request. This is not\n    allowed by the HTTP protocol. The `HttpServer` still gracefully receives\n    fragments, but discards them before delivering the request.\n  - To allow connections to be accepted on the same port across different\n    isolates, set the `shared` argument to `true` when creating server socket\n    and `HttpServer` instances.\n    - The deprecated `ServerSocketReference` and `RawServerSocketReference`\n      classes have been removed.\n    - The corresponding `reference` properties on `ServerSocket` and\n      `RawServerSocket` have been removed.\n\n- `dart:isolate`\n  - `spawnUri` added an `environment` named argument.\n\n### Tool changes\n\n- `dart2js` and Dartium now support improved Javascript Interoperability via the\n  [js package](https://pub.dartlang.org/packages/js).\n\n- `docgen` and `dartdocgen` no longer ship in the SDK. The `docgen` sources have\n  been removed from the repository.\n\n- This is the last release to ship the VM's \"legacy debug protocol\". We intend\n  to remove the legacy debug protocol in Dart VM 1.14.\n\n- The VM's Service Protocol has been updated to version 3.0 to take care of a\n  number of issues uncovered by the first few non-observatory clients. This is a\n  potentially breaking change for clients.\n\n- Dartium has been substantially changed. Rather than using C++ calls into\n  Chromium internals for DOM operations it now uses JS interop. The DOM objects\n  in `dart:html` and related libraries now wrap a JavaScript object and delegate\n  operations to it. This should be mostly transparent to users. However,\n  performance and memory characteristics may be different from previous\n  versions. There may be some changes in which DOM objects are wrapped as Dart\n  objects. For example, if you get a reference to a Window object, even through\n  JS interop, you will always see it as a Dart Window, even when used\n  cross-frame. We expect the change to using JS interop will make it much\n  simpler to update to new Chrome versions.\n\n## 1.12.2 - 2015-10-21\n\n### Core library changes\n\n- `dart:io`\n\n  - A memory leak in creation of Process objects is fixed.\n\n## 1.12.1 - 2015-09-08\n\n### Tool changes\n\n- Pub\n\n  - Pub will now respect `.gitignore` when validating a package before it's\n    published. For example, if a `LICENSE` file exists but is ignored, that is\n    now an error.\n\n  - If the package is in a subdirectory of a Git repository and the entire\n    subdirectory is ignored with `.gitignore`, pub will act as though nothing\n    was ignored instead of uploading an empty package.\n\n  - The heuristics for determining when `pub get` needs to be run before various\n    commands have been improved. There should no longer be false positives when\n    non-dependency sections of the pubspec have been modified.\n\n## 1.12.0 - 2015-08-31\n\n### Language changes\n\n- Null-aware operators\n  - `??`: if null operator. `expr1 ?? expr2` evaluates to `expr1` if not `null`,\n    otherwise `expr2`.\n  - `??=`: null-aware assignment. `v ??= expr` causes `v` to be assigned `expr`\n    only if `v` is `null`.\n  - `x?.p`: null-aware access. `x?.p` evaluates to `x.p` if `x` is not `null`,\n    otherwise evaluates to `null`.\n  - `x?.m()`: null-aware method invocation. `x?.m()` invokes `m` only if `x` is\n    not `null`.\n\n### Core library changes\n\n- `dart:async`\n\n  - `StreamController` added setters for the `onListen`, `onPause`, `onResume`\n    and `onCancel` callbacks.\n\n- `dart:convert`\n\n  - `LineSplitter` added a `split` static method returning an `Iterable`.\n\n- `dart:core`\n\n  - `Uri` class now perform path normalization when a URI is created. This\n    removes most `..` and `.` sequences from the URI path. Purely relative paths\n    (no scheme or authority) are allowed to retain some leading \"dot\" segments.\n    Also added `hasAbsolutePath`, `hasEmptyPath`, and `hasScheme` properties.\n\n- `dart:developer`\n\n  - New `log` function to transmit logging events to Observatory.\n\n- `dart:html`\n\n  - `NodeTreeSanitizer` added the `const trusted` field. It can be used instead\n    of defining a `NullTreeSanitizer` class when calling `setInnerHtml` or other\n    methods that create DOM from text. It is also more efficient, skipping the\n    creation of a `DocumentFragment`.\n\n- `dart:io`\n\n  - Added two new file modes, `WRITE_ONLY` and `WRITE_ONLY_APPEND` for opening a\n    file write only.\n    [eaeecf2](https://github.com/dart-lang/sdk/commit/eaeecf2ed13ba6c7fbfd653c3c592974a7120960)\n  - Change stdout/stderr to binary mode on Windows.\n    [4205b29](https://github.com/dart-lang/sdk/commit/4205b2997e01f2cea8e2f44c6f46ed6259ab7277)\n\n- `dart:isolate`\n\n  - Added `onError`, `onExit` and `errorsAreFatal` parameters to\n    `Isolate.spawnUri`.\n\n- `dart:mirrors`\n  - `InstanceMirror.delegate` moved up to `ObjectMirror`.\n  - Fix InstanceMirror.getField optimization when the selector is an operator.\n  - Fix reflective NoSuchMethodErrors to match their non-reflective counterparts\n    when due to argument mismatches. (VM only)\n\n### Tool changes\n\n- Documentation tools\n\n  - `dartdoc` is now the default tool to generate static HTML for API docs.\n    [Learn more](https://pub.dartlang.org/packages/dartdoc).\n\n  - `docgen` and `dartdocgen` have been deprecated. Currently plan is to remove\n    them in 1.13.\n\n- Formatter (`dartfmt`)\n\n  - Over 50 bugs fixed.\n\n  - Optimized line splitter is much faster and produces better output on complex\n    code.\n\n- Observatory\n\n  - Allocation profiling.\n\n  - New feature to display output from logging.\n\n  - Heap snapshot analysis works for 64-bit VMs.\n\n  - Improved ability to inspect typed data, regex and compiled code.\n\n  - Ability to break on all or uncaught exceptions from Observatory's debugger.\n\n  - Ability to set closure-specific breakpoints.\n\n  - 'anext' - step past await/yield.\n\n  - Preserve when a variable has been expanded/unexpanded in the debugger.\n\n  - Keep focus on debugger input box whenever possible.\n\n  - Echo stdout/stderr in the Observatory debugger. Standalone-only so far.\n\n  - Minor fixes to service protocol documentation.\n\n- Pub\n\n  - **Breaking:** various commands that previously ran `pub get` implicitly no\n    longer do so. Instead, they merely check to make sure the \".packages\" file\n    is newer than the pubspec and the lock file, and fail if it's not.\n\n  - Added support for `--verbosity=error` and `--verbosity=warning`.\n\n  - `pub serve` now collapses multiple GET requests into a single line of\n    output. For full output, use `--verbose`.\n\n  - `pub deps` has improved formatting for circular dependencies on the\n    entrypoint package.\n\n  - `pub run` and `pub global run`\n\n    - **Breaking:** to match the behavior of the Dart VM, executables no longer\n      run in checked mode by default. A `--checked` flag has been added to run\n      them in checked mode manually.\n\n    - Faster start time for executables that don't import transformed code.\n\n    - Binstubs for globally-activated executables are now written in the system\n      encoding, rather than always in `UTF-8`. To update existing executables,\n      run `pub cache repair`.\n\n  - `pub get` and `pub upgrade`\n\n    - Pub will now generate a \".packages\" file in addition to the \"packages\"\n      directory when running `pub get` or similar operations, per the [package\n      spec proposal][]. Pub now has a `--no-package-symlinks` flag that will\n      stop \"packages\" directories from being generated at all.\n\n    - An issue where HTTP requests were sometimes made even though `--offline`\n      was passed has been fixed.\n\n    - A bug with `--offline` that caused an unhelpful error message has been\n      fixed.\n\n    - Pub will no longer time out when a package takes a long time to download.\n\n  - `pub publish`\n\n    - Pub will emit a non-zero exit code when it finds a violation while\n      publishing.\n\n    - `.gitignore` files will be respected even if the package isn't at the top\n      level of the Git repository.\n\n  - Barback integration\n\n    - A crashing bug involving transformers that only apply to non-public code\n      has been fixed.\n\n    - A deadlock caused by declaring transformer followed by a lazy transformer\n      (such as the built-in `$dart2js` transformer) has been fixed.\n\n    - A stack overflow caused by a transformer being run multiple times on the\n      package that defines it has been fixed.\n\n    - A transformer that tries to read a non-existent asset in another package\n      will now be re-run if that asset is later created.\n\n[package spec proposal]: https://github.com/lrhn/dep-pkgspec\n\n### VM Service Protocol Changes\n\n- **BREAKING** The service protocol now sends JSON-RPC 2.0-compatible\n  server-to-client events. To reflect this, the service protocol version is now\n  2.0.\n\n- The service protocol now includes a `\"jsonrpc\"` property in its responses, as\n  opposed to `\"json-rpc\"`.\n\n- The service protocol now properly handles requests with non-string ids.\n  Numeric ids are no longer converted to strings, and null ids now don't produce\n  a response.\n\n- Some RPCs that didn't include a `\"jsonrpc\"` property in their responses now\n  include one.\n\n## 1.11.2 - 2015-08-03\n\n### Core library changes\n\n- Fix a bug where `WebSocket.close()` would crash if called after\n  `WebSocket.cancel()`.\n\n## 1.11.1 - 2015-07-02\n\n### Tool changes\n\n- Pub will always load Dart SDK assets from the SDK whose `pub` executable was\n  run, even if a `DART_SDK` environment variable is set.\n\n## 1.11.0 - 2015-06-25\n\n### Core library changes\n\n- `dart:core`\n\n  - `Iterable` added an `empty` constructor.\n    [dcf0286](https://github.com/dart-lang/sdk/commit/dcf0286f5385187a68ce9e66318d3bf19abf454b)\n  - `Iterable` can now be extended directly. An alternative to extending\n    `IterableBase` from `dart:collection`.\n  - `List` added an `unmodifiable` constructor.\n    [r45334](https://code.google.com/p/dart/source/detail?r=45334)\n  - `Map` added an `unmodifiable` constructor.\n    [r45733](https://code.google.com/p/dart/source/detail?r=45733)\n  - `int` added a `gcd` method.\n    [a192ef4](https://github.com/dart-lang/sdk/commit/a192ef4acb95fad1aad1887f59eed071eb5e8201)\n  - `int` added a `modInverse` method.\n    [f6f338c](https://github.com/dart-lang/sdk/commit/f6f338ce67eb8801b350417baacf6d3681b26002)\n  - `StackTrace` added a `fromString` constructor.\n    [68dd6f6](https://github.com/dart-lang/sdk/commit/68dd6f6338e63d0465041d662e778369c02c2ce6)\n  - `Uri` added a `directory` constructor.\n    [d8dbb4a](https://github.com/dart-lang/sdk/commit/d8dbb4a60f5e8a7f874c2a4fbf59eaf1a39f4776)\n  - List iterators may not throw `ConcurrentModificationError` as eagerly in\n    release mode. In checked mode, the modification check is still as eager as\n    possible. [r45198](https://github.com/dart-lang/sdk/commit/5a79c03)\n\n- `dart:developer` - **NEW**\n\n  - Replaces the deprecated `dart:profiler` library.\n  - Adds new functions `debugger` and `inspect`.\n    [6e42aec](https://github.com/dart-lang/sdk/blob/6e42aec4f64cf356dde7bad9426e07e0ea5b58d5/sdk/lib/developer/developer.dart)\n\n- `dart:io`\n\n  - `FileSystemEntity` added a `uri` property.\n    [8cf32dc](https://github.com/dart-lang/sdk/commit/8cf32dc1a1664b516e57f804524e46e55fae88b2)\n  - `Platform` added a `static resolvedExecutable` property.\n    [c05c8c6](https://github.com/dart-lang/sdk/commit/c05c8c66069db91cc2fd48691dfc406c818d411d)\n\n- `dart:html`\n\n  - `Element` methods, `appendHtml` and `insertAdjacentHtml` now take\n    `nodeValidator` and `treeSanitizer` parameters, and the inputs are\n    consistently sanitized.\n    [r45818 announcement](https://groups.google.com/a/dartlang.org/forum/#!topic/announce/GVO7EAcPi6A)\n\n- `dart:isolate`\n\n  - **BREAKING** The positional `priority` parameter of `Isolate.ping` and\n    `Isolate.kill` is now a named parameter named `priority`.\n  - **BREAKING** Removed the `Isolate.AS_EVENT` priority.\n  - `Isolate` methods `ping` and `addOnExitListener` now have a named parameter\n    `response`. [r45092](https://github.com/dart-lang/sdk/commit/1b208bd)\n  - `Isolate.spawnUri` added a named argument `checked`.\n  - Remove the experimental state of the API.\n\n- `dart:profiler` - **DEPRECATED**\n  - This library will be removed in 1.12. Use `dart:developer` instead.\n\n### Tool changes\n\n- This is the first release that does not include the Eclipse-based **Dart\n  Editor**. See [dartlang.org/tools](https://www.dartlang.org/tools/) for\n  alternatives.\n- This is the last release that ships the (unsupported) dart2dart (aka\n  `dart2js --output-type=dart`) utility as part of dart2js\n\n## 1.10.0 - 2015-04-29\n\n### Core library changes\n\n- `dart:convert`\n\n  - **POTENTIALLY BREAKING** Fix behavior of `HtmlEscape`. It no longer escapes\n    no-break space (U+00A0) anywhere or forward slash (`/`, `U+002F`) in element\n    context. Slash is still escaped using `HtmlEscapeMode.UNKNOWN`.\n    [r45003](https://github.com/dart-lang/sdk/commit/8b8223d),\n    [r45153](https://github.com/dart-lang/sdk/commit/8a5d049),\n    [r45189](https://github.com/dart-lang/sdk/commit/3c39ad2)\n\n- `dart:core`\n\n  - `Uri.parse` added `start` and `end` positional arguments.\n\n- `dart:html`\n\n  - **POTENTIALLY BREAKING** `CssClassSet` method arguments must now be\n    'tokens', i.e. non-empty strings with no white-space characters. The\n    implementation was incorrect for class names containing spaces. The fix is\n    to forbid spaces and provide a faster implementation.\n    [Announcement](https://groups.google.com/a/dartlang.org/d/msg/announce/jmUI2XJHfC8/UZUCvJH3p2oJ)\n\n- `dart:io`\n\n  - `ProcessResult` now exposes a constructor.\n  - `import` and `Isolate.spawnUri` now supports the\n    [Data URI scheme](http://en.wikipedia.org/wiki/Data_URI_scheme) on the VM.\n\n## Tool Changes\n\n### pub\n\n- Running `pub run foo` within a package now runs the `foo` executable defined\n  by the `foo` package. The previous behavior ran `bin/foo`. This makes it easy\n  to run binaries in dependencies, for instance `pub run test`.\n\n- On Mac and Linux, signals sent to `pub run` and forwarded to the child\n  command.\n\n## 1.9.3 - 2015-04-14\n\nThis is a bug fix release which merges a number of commits from `bleeding_edge`.\n\n- dart2js: Addresses as issue with minified Javascript output with CSP enabled -\n  [r44453](https://code.google.com/p/dart/source/detail?r=44453)\n\n- Editor: Fixes accidental updating of files in the pub cache during rename\n  refactoring - [r44677](https://code.google.com/p/dart/source/detail?r=44677)\n\n- Editor: Fix for\n  [issue 23032](https://code.google.com/p/dart/issues/detail?id=23032) regarding\n  skipped breakpoints on Windows -\n  [r44824](https://code.google.com/p/dart/source/detail?r=44824)\n\n- dart:mirrors: Fix `MethodMirror.source` when the method is on the first line\n  in a script - [r44957](https://code.google.com/p/dart/source/detail?r=44957),\n  [r44976](https://code.google.com/p/dart/source/detail?r=44976)\n\n- pub: Fix for\n  [issue 23084](https://code.google.com/p/dart/issues/detail?id=23084): Pub can\n  fail to load transformers necessary for local development -\n  [r44876](https://code.google.com/p/dart/source/detail?r=44876)\n\n## 1.9.1 - 2015-03-25\n\n### Language changes\n\n- Support for `async`, `await`, `sync*`, `async*`, `yield`, `yield*`, and\n  `await for`. See the [the language tour][async] for more details.\n\n- Enum support is fully enabled. See [the language tour][enum] for more details.\n\n[async]: https://www.dartlang.org/docs/dart-up-and-running/ch02.html#asynchrony\n[enum]: https://www.dartlang.org/docs/dart-up-and-running/ch02.html#enums\n\n### Tool changes\n\n- The formatter is much more comprehensive and generates much more readable\n  code. See [its tool page][dartfmt] for more details.\n\n- The analysis server is integrated into the IntelliJ plugin and the Dart\n  editor. This allows analysis to run out-of-process, so that interaction\n  remains smooth even for large projects.\n\n- Analysis supports more and better hints, including unused variables and unused\n  private members.\n\n[dartfmt]: https://www.dartlang.org/tools/dartfmt/\n\n### Core library changes\n\n#### Highlights\n\n- There's a new model for shared server sockets with no need for a `Socket`\n  reference.\n\n- A new, much faster [regular expression engine][regexp].\n\n- The Isolate API now works across the VM and `dart2js`.\n\n[regexp]: http://news.dartlang.org/2015/02/irregexp-dart-vms-new-regexp.html\n\n#### Details\n\nFor more information on any of these changes, see the corresponding\ndocumentation on the [Dart API site](http://api.dartlang.org).\n\n- `dart:async`:\n\n  - `Future.wait` added a new named argument, `cleanUp`, which is a callback\n    that releases resources allocated by a successful `Future`.\n\n  - The `SynchronousStreamController` class was added as an explicit name for\n    the type returned when the `sync` argument is passed to\n    `new StreamController`.\n\n- `dart:collection`: The `new SplayTreeSet.from(Iterable)` constructor was\n  added.\n\n- `dart:convert`: `Utf8Encoder.convert` and `Utf8Decoder.convert` added optional\n  `start` and `end` arguments.\n\n- `dart:core`:\n\n  - `RangeError` added new static helper functions: `checkNotNegative`,\n    `checkValidIndex`, `checkValidRange`, and `checkValueInInterval`.\n\n  - `int` added the `modPow` function.\n\n  - `String` added the `replaceFirstMapped` and `replaceRange` functions.\n\n- `dart:io`:\n\n  - Support for locking files to prevent concurrent modification was added. This\n    includes the `File.lock`, `File.lockSync`, `File.unlock`, and\n    `File.unlockSync` functions as well as the `FileLock` class.\n\n  - Support for starting detached processes by passing the named `mode` argument\n    (a `ProcessStartMode`) to `Process.start`. A process can be fully attached,\n    fully detached, or detached except for its standard IO streams.\n\n  - `HttpServer.bind` and `HttpServer.bindSecure` added the `v6Only` named\n    argument. If this is true, only IPv6 connections will be accepted.\n\n  - `HttpServer.bind`, `HttpServer.bindSecure`, `ServerSocket.bind`,\n    `RawServerSocket.bind`, `SecureServerSocket.bind` and\n    `RawSecureServerSocket.bind` added the `shared` named argument. If this is\n    true, multiple servers or sockets in the same Dart process may bind to the\n    same address, and incoming requests will automatically be distributed\n    between them.\n\n  - **Deprecation:** the experimental `ServerSocketReference` and\n    `RawServerSocketReference` classes, as well as getters that returned them,\n    are marked as deprecated. The `shared` named argument should be used\n    instead. These will be removed in Dart 1.10.\n\n  - `Socket.connect` and `RawSocket.connect` added the `sourceAddress` named\n    argument, which specifies the local address to bind when making a\n    connection.\n\n  - The static `Process.killPid` method was added to kill a process with a given\n    PID.\n\n  - `Stdout` added the `nonBlocking` instance property, which returns a\n    non-blocking `IOSink` that writes to standard output.\n\n- `dart:isolate`:\n\n  - The static getter `Isolate.current` was added.\n\n  - The `Isolate` methods `addOnExitListener`, `removeOnExitListener`,\n    `setErrorsFatal`, `addOnErrorListener`, and `removeOnErrorListener` now work\n    on the VM.\n\n  - Isolates spawned via `Isolate.spawn` now allow most objects, including\n    top-level and static functions, to be sent between them.\n\n## 1.8.5 - 2015-01-21\n\n- Code generation for SIMD on ARM and ARM64 is fixed.\n\n- A possible crash on MIPS with newer GCC toolchains has been prevented.\n\n- A segfault when using `rethrow` was fixed ([issue 21795][]).\n\n[issue 21795]: https://code.google.com/p/dart/issues/detail?id=21795\n\n## 1.8.3 - 2014-12-10\n\n- Breakpoints can be set in the Editor using file suffixes ([issue 21280][]).\n\n- IPv6 addresses are properly handled by `HttpClient` in `dart:io`, fixing a\n  crash in pub ([issue 21698][]).\n\n- Issues with the experimental `async`/`await` syntax have been fixed.\n\n- Issues with a set of number operations in the VM have been fixed.\n\n- `ListBase` in `dart:collection` always returns an `Iterable` with the correct\n  type argument.\n\n[issue 21280]: https://code.google.com/p/dart/issues/detail?id=21280\n[issue 21698]: https://code.google.com/p/dart/issues/detail?id=21698\n\n## 1.8.0 - 2014-11-28\n\n- `dart:collection`: `SplayTree` added the `toSet` function.\n\n- `dart:convert`: The `JsonUtf8Encoder` class was added.\n\n- `dart:core`:\n\n  - The `IndexError` class was added for errors caused by an index being outside\n    its expected range.\n\n  - The `new RangeError.index` constructor was added. It forwards to\n    `new IndexError`.\n\n  - `RangeError` added three new properties. `invalidProperty` is the value that\n    caused the error, and `start` and `end` are the minimum and maximum values\n    that the value is allowed to assume.\n\n  - `new RangeError.value` and `new RangeError.range` added an optional\n    `message` argument.\n\n  - The `new String.fromCharCodes` constructor added optional `start` and `end`\n    arguments.\n\n- `dart:io`:\n\n  - Support was added for the [Application-Layer Protocol Negotiation][alpn]\n    extension to the TLS protocol for both the client and server.\n\n  - `SecureSocket.connect`, `SecureServerSocket.bind`,\n    `RawSecureSocket.connect`, `RawSecureSocket.secure`,\n    `RawSecureSocket.secureServer`, and `RawSecureServerSocket.bind` added a\n    `supportedProtocols` named argument for protocol negotiation.\n\n  - `RawSecureServerSocket` added a `supportedProtocols` field.\n\n  - `RawSecureSocket` and `SecureSocket` added a `selectedProtocol` field which\n    contains the protocol selected during protocol negotiation.\n\n[alpn]: https://tools.ietf.org/html/rfc7301\n\n## 1.7.0 - 2014-10-15\n\n### Tool changes\n\n- `pub` now generates binstubs for packages that are globally activated so that\n  they can be put on the user's `PATH` and used as normal executables. See the\n  [`pub global activate` documentation][pub global activate].\n\n- When using `dart2js`, deferred loading now works with multiple Dart apps on\n  the same page.\n\n[pub global activate]:\n  https://www.dartlang.org/tools/pub/cmd/pub-global.html#running-a-script-from-your-path\n\n### Core library changes\n\n- `dart:async`: `Zone`, `ZoneDelegate`, and `ZoneSpecification` added the\n  `errorCallback` function, which allows errors that have been programmatically\n  added to a `Future` or `Stream` to be intercepted.\n\n- `dart:io`:\n\n  - **Breaking change:** `HttpClient.close` must be called for all clients or\n    they will keep the Dart process alive until they time out. This fixes the\n    handling of persistent connections. Previously, the client would shut down\n    immediately after a request.\n\n  - **Breaking change:** `HttpServer` no longer compresses all traffic by\n    default. The new `autoCompress` property can be set to `true` to re-enable\n    compression.\n\n- `dart:isolate`: `Isolate.spawnUri` added the optional `packageRoot` argument,\n  which controls how it resolves `package:` URIs.\n", "// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\nlibrary dart._http;\n\nimport 'dart:_internal'\n    show Since, valueOfNonNullableParamWithDefault, HttpStatus;\nimport 'dart:async';\nimport 'dart:collection'\n    show\n        HashMap,\n        HashSet,\n        ListQueue,\n        LinkedList,\n        LinkedListEntry,\n        UnmodifiableMapView;\nimport 'dart:convert';\nimport 'dart:developer' hide log;\nimport 'dart:io';\nimport 'dart:isolate' show Isolate;\nimport 'dart:math';\nimport 'dart:typed_data';\n\npart 'crypto.dart';\npart 'embedder_config.dart';\npart 'http_date.dart';\npart 'http_headers.dart';\npart 'http_impl.dart';\npart 'http_parser.dart';\npart 'http_session.dart';\npart 'overrides.dart';\npart 'websocket.dart';\npart 'websocket_impl.dart';\n\n/// A server that delivers content, such as web pages, using the HTTP protocol.\n///\n/// Note: [HttpServer] provides low-level HTTP functionality.\n/// We recommend users evaluate the high-level APIs discussed at\n/// [Write HTTP servers](https://dart.dev/tutorials/server/httpserver) on\n/// [dart.dev](https://dart.dev/).\n///\n/// `HttpServer` is a [Stream] that provides [HttpRequest] objects. Each\n/// `HttpRequest` has an associated [HttpResponse] object.\n/// The server responds to a request by writing to that [HttpResponse] object.\n/// The following example shows how to bind an `HttpServer` to an IPv6\n/// [InternetAddress] on port 80 (the standard port for HTTP servers)\n/// and how to listen for requests.\n/// Port 80 is the default HTTP port. However, on most systems accessing\n/// this requires super-user privileges. For local testing consider\n/// using a non-reserved port (1024 and above).\n///\n/// ```dart\n/// import 'dart:io';\n///\n/// Future<void> main() async {\n///   var server = await HttpServer.bind(InternetAddress.anyIPv6, 80);\n///   await server.forEach((HttpRequest request) {\n///     request.response.write('Hello, world!');\n///     request.response.close();\n///   });\n/// }\n/// ```\n///\n/// Incomplete requests, in which all or part of the header is missing, are\n/// ignored, and no exceptions or [HttpRequest] objects are generated for them.\n/// Likewise, when writing to an [HttpResponse], any [Socket] exceptions are\n/// ignored and any future writes are ignored.\n///\n/// The [HttpRequest] exposes the request headers and provides the request body,\n/// if it exists, as a Stream of data. If the body is unread, it is drained\n/// when the server writes to the HttpResponse or closes it.\n///\n/// ## Bind with a secure HTTPS connection\n///\n/// Use [bindSecure] to create an HTTPS server.\n///\n/// The server presents a certificate to the client. The certificate\n/// chain and the private key are set in the [SecurityContext]\n/// object that is passed to [bindSecure].\n///\n/// ```dart\n/// import 'dart:io';\n///\n/// Future<void> main() async {\n///   var chain =\n///       Platform.script.resolve('certificates/server_chain.pem').toFilePath();\n///   var key = Platform.script.resolve('certificates/server_key.pem').toFilePath();\n///   var context = SecurityContext()\n///     ..useCertificateChain(chain)\n///     ..usePrivateKey(key, password: 'dartdart');\n///   var server =\n///       await HttpServer.bindSecure(InternetAddress.anyIPv6, 443, context);\n///   await server.forEach((HttpRequest request) {\n///     request.response.write('Hello, world!');\n///     request.response.close();\n///   });\n/// }\n/// ```\n///\n/// The certificates and keys are PEM files, which can be created and\n/// managed with the tools in OpenSSL.\nabstract class HttpServer implements Stream<HttpRequest> {\n  /// Gets and sets the default value of the `Server` header for all responses\n  /// generated by this [HttpServer].\n  ///\n  /// If [serverHeader] is `null`, no `Server` header will be added to each\n  /// response.\n  ///\n  /// The default value is `null`.\n  String? serverHeader;\n\n  /// Default set of headers added to all response objects.\n  ///\n  /// By default the following headers are in this set:\n  ///\n  ///     Content-Type: text/plain; charset=utf-8\n  ///     X-Frame-Options: SAMEORIGIN\n  ///     X-Content-Type-Options: nosniff\n  ///     X-XSS-Protection: 1; mode=block\n  ///\n  /// If the `Server` header is added here and the `serverHeader` is set as\n  /// well then the value of `serverHeader` takes precedence.\n  HttpHeaders get defaultResponseHeaders;\n\n  /// Whether the [HttpServer] should compress the content, if possible.\n  ///\n  /// The content can only be compressed when the response is using\n  /// chunked Transfer-Encoding and the incoming request has `gzip`\n  /// as an accepted encoding in the Accept-Encoding header.\n  ///\n  /// The default value is `false` (compression disabled).\n  /// To enable, set `autoCompress` to `true`.\n  bool autoCompress = false;\n\n  /// Gets or sets the timeout used for idle keep-alive connections. If no\n  /// further request is seen within [idleTimeout] after the previous request was\n  /// completed, the connection is dropped.\n  ///\n  /// Default is 120 seconds.\n  ///\n  /// Note that it may take up to `2 * idleTimeout` before a idle connection is\n  /// aborted.\n  ///\n  /// To disable, set [idleTimeout] to `null`.\n  Duration? idleTimeout = const Duration(seconds: 120);\n\n  /// Starts listening for HTTP requests on the specified [address] and\n  /// [port].\n  ///\n  /// The [address] can either be a [String] or an\n  /// [InternetAddress]. If [address] is a [String], [bind] will\n  /// perform a [InternetAddress.lookup] and use the first value in the\n  /// list. To listen on the loopback adapter, which will allow only\n  /// incoming connections from the local host, use the value\n  /// [InternetAddress.loopbackIPv4] or\n  /// [InternetAddress.loopbackIPv6]. To allow for incoming\n  /// connection from the network use either one of the values\n  /// [InternetAddress.anyIPv4] or [InternetAddress.anyIPv6] to\n  /// bind to all interfaces or the IP address of a specific interface.\n  ///\n  /// If an IP version 6 (IPv6) address is used, both IP version 6\n  /// (IPv6) and version 4 (IPv4) connections will be accepted. To\n  /// restrict this to version 6 (IPv6) only, use [v6Only] to set\n  /// version 6 only. However, if the address is\n  /// [InternetAddress.loopbackIPv6], only IP version 6 (IPv6) connections\n  /// will be accepted.\n  ///\n  /// If [port] has the value 0 an ephemeral port will be chosen by\n  /// the system. The actual port used can be retrieved using the\n  /// [port] getter.\n  ///\n  /// The optional argument [backlog] can be used to specify the listen\n  /// backlog for the underlying OS listen setup. If [backlog] has the\n  /// value of 0 (the default) a reasonable value will be chosen by\n  /// the system.\n  ///\n  /// The optional argument [shared] specifies whether additional `HttpServer`\n  /// objects can bind to the same combination of `address`, `port` and `v6Only`.\n  /// If `shared` is `true` and more `HttpServer`s from this isolate or other\n  /// isolates are bound to the port, then the incoming connections will be\n  /// distributed among all the bound `HttpServer`s. Connections can be\n  /// distributed over multiple isolates this way.\n  static Future<HttpServer> bind(address, int port,\n          {int backlog = 0, bool v6Only = false, bool shared = false}) =>\n      _HttpServer.bind(address, port, backlog, v6Only, shared);\n\n  /// The [address] can either be a [String] or an\n  /// [InternetAddress]. If [address] is a [String], [bind] will\n  /// perform a [InternetAddress.lookup] and use the first value in the\n  /// list. To listen on the loopback adapter, which will allow only\n  /// incoming connections from the local host, use the value\n  /// [InternetAddress.loopbackIPv4] or\n  /// [InternetAddress.loopbackIPv6]. To allow for incoming\n  /// connection from the network use either one of the values\n  /// [InternetAddress.anyIPv4] or [InternetAddress.anyIPv6] to\n  /// bind to all interfaces or the IP address of a specific interface.\n  ///\n  /// If an IP version 6 (IPv6) address is used, both IP version 6\n  /// (IPv6) and version 4 (IPv4) connections will be accepted. To\n  /// restrict this to version 6 (IPv6) only, use [v6Only] to set\n  /// version 6 only.\n  ///\n  /// If [port] has the value 0 an ephemeral port will be chosen by\n  /// the system. The actual port used can be retrieved using the\n  /// [port] getter.\n  ///\n  /// The optional argument [backlog] can be used to specify the listen\n  /// backlog for the underlying OS listen setup. If [backlog] has the\n  /// value of 0 (the default) a reasonable value will be chosen by\n  /// the system.\n  ///\n  /// If [requestClientCertificate] is true, the server will\n  /// request clients to authenticate with a client certificate.\n  /// The server will advertise the names of trusted issuers of client\n  /// certificates, getting them from a [SecurityContext], where they have been\n  /// set using [SecurityContext.setClientAuthorities].\n  ///\n  /// The optional argument [shared] specifies whether additional `HttpServer`\n  /// objects can bind to the same combination of `address`, `port` and `v6Only`.\n  /// If `shared` is `true` and more `HttpServer`s from this isolate or other\n  /// isolates are bound to the port, then the incoming connections will be\n  /// distributed among all the bound `HttpServer`s. Connections can be\n  /// distributed over multiple isolates this way.\n\n  static Future<HttpServer> bindSecure(\n          address, int port, SecurityContext context,\n          {int backlog = 0,\n          bool v6Only = false,\n          bool requestClientCertificate = false,\n          bool shared = false}) =>\n      _HttpServer.bindSecure(address, port, context, backlog, v6Only,\n          requestClientCertificate, shared);\n\n  /// Attaches the HTTP server to an existing [ServerSocket]. When the\n  /// [HttpServer] is closed, the [HttpServer] will just detach itself,\n  /// closing current connections but not closing [serverSocket].\n  factory HttpServer.listenOn(ServerSocket serverSocket) =>\n      _HttpServer.listenOn(serverSocket);\n\n  /// Permanently stops this [HttpServer] from listening for new\n  /// connections.  This closes the [Stream] of [HttpRequest]s with a\n  /// done event. The returned future completes when the server is\n  /// stopped. For a server started using [bind] or [bindSecure] this\n  /// means that the port listened on no longer in use.\n  ///\n  /// If [force] is `true`, active connections will be closed immediately.\n  Future close({bool force = false});\n\n  /// The port that the server is listening on.\n  ///\n  /// This is the actual port used when a port of zero is\n  /// specified in the [bind] or [bindSecure] call.\n  int get port;\n\n  /// The address that the server is listening on.\n  ///\n  /// This is the actual address used when the original address\n  /// was specified as a hostname.\n  InternetAddress get address;\n\n  /// Sets the timeout, in seconds, for sessions of this [HttpServer].\n  ///\n  /// The default timeout is 20 minutes.\n  set sessionTimeout(int timeout);\n\n  /// A [HttpConnectionsInfo] object summarizing the number of\n  /// current connections handled by the server.\n  HttpConnectionsInfo connectionsInfo();\n}\n\n/// Summary statistics about an [HttpServer]s current socket connections.\nclass HttpConnectionsInfo {\n  /// Total number of socket connections.\n  int total = 0;\n\n  /// Number of active connections where actual request/response\n  /// processing is active.\n  int active = 0;\n\n  /// Number of idle connections held by clients as persistent connections.\n  int idle = 0;\n\n  /// Number of connections which are preparing to close.\n  ///\n  /// Note: These connections are also part of the [active] count as they might\n  /// still be sending data to the client before finally closing.\n  int closing = 0;\n}\n\n/// Headers for HTTP requests and responses.\n///\n/// In some situations, headers are immutable:\n///\n/// * [HttpRequest] and [HttpClientResponse] always have immutable headers.\n///\n/// * [HttpResponse] and [HttpClientRequest] have immutable headers\n///   from the moment the body is written to.\n///\n/// In these situations, the mutating methods throw exceptions.\n///\n/// For all operations on HTTP headers the header name is\n/// case-insensitive.\n///\n/// To set the value of a header use the `set()` method:\n///\n///     request.headers.set(HttpHeaders.cacheControlHeader,\n///                         'max-age=3600, must-revalidate');\n///\n/// To retrieve the value of a header use the `value()` method:\n///\n///     print(request.headers.value(HttpHeaders.userAgentHeader));\n///\n/// An `HttpHeaders` object holds a list of values for each name\n/// as the standard allows. In most cases a name holds only a single value,\n/// The most common mode of operation is to use `set()` for setting a value,\n/// and `value()` for retrieving a value.\nabstract class HttpHeaders {\n  static const acceptHeader = \"accept\";\n  static const acceptCharsetHeader = \"accept-charset\";\n  static const acceptEncodingHeader = \"accept-encoding\";\n  static const acceptLanguageHeader = \"accept-language\";\n  static const acceptRangesHeader = \"accept-ranges\";\n  @Since(\"2.14\")\n  static const accessControlAllowCredentialsHeader =\n      'access-control-allow-credentials';\n  @Since(\"2.14\")\n  static const accessControlAllowHeadersHeader = 'access-control-allow-headers';\n  @Since(\"2.14\")\n  static const accessControlAllowMethodsHeader = 'access-control-allow-methods';\n  @Since(\"2.14\")\n  static const accessControlAllowOriginHeader = 'access-control-allow-origin';\n  @Since(\"2.14\")\n  static const accessControlExposeHeadersHeader =\n      'access-control-expose-headers';\n  @Since(\"2.14\")\n  static const accessControlMaxAgeHeader = 'access-control-max-age';\n  @Since(\"2.14\")\n  static const accessControlRequestHeadersHeader =\n      'access-control-request-headers';\n  @Since(\"2.14\")\n  static const accessControlRequestMethodHeader =\n      'access-control-request-method';\n  static const ageHeader = \"age\";\n  static const allowHeader = \"allow\";\n  static const authorizationHeader = \"authorization\";\n  static const cacheControlHeader = \"cache-control\";\n  static const connectionHeader = \"connection\";\n  static const contentEncodingHeader = \"content-encoding\";\n  static const contentLanguageHeader = \"content-language\";\n  static const contentLengthHeader = \"content-length\";\n  static const contentLocationHeader = \"content-location\";\n  static const contentMD5Header = \"content-md5\";\n  static const contentRangeHeader = \"content-range\";\n  static const contentTypeHeader = \"content-type\";\n  static const dateHeader = \"date\";\n  static const etagHeader = \"etag\";\n  static const expectHeader = \"expect\";\n  static const expiresHeader = \"expires\";\n  static const fromHeader = \"from\";\n  static const hostHeader = \"host\";\n  static const ifMatchHeader = \"if-match\";\n  static const ifModifiedSinceHeader = \"if-modified-since\";\n  static const ifNoneMatchHeader = \"if-none-match\";\n  static const ifRangeHeader = \"if-range\";\n  static const ifUnmodifiedSinceHeader = \"if-unmodified-since\";\n  static const lastModifiedHeader = \"last-modified\";\n  static const locationHeader = \"location\";\n  static const maxForwardsHeader = \"max-forwards\";\n  static const pragmaHeader = \"pragma\";\n  static const proxyAuthenticateHeader = \"proxy-authenticate\";\n  static const proxyAuthorizationHeader = \"proxy-authorization\";\n  static const rangeHeader = \"range\";\n  static const refererHeader = \"referer\";\n  static const retryAfterHeader = \"retry-after\";\n  static const serverHeader = \"server\";\n  static const teHeader = \"te\";\n  static const trailerHeader = \"trailer\";\n  static const transferEncodingHeader = \"transfer-encoding\";\n  static const upgradeHeader = \"upgrade\";\n  static const userAgentHeader = \"user-agent\";\n  static const varyHeader = \"vary\";\n  static const viaHeader = \"via\";\n  static const warningHeader = \"warning\";\n  static const wwwAuthenticateHeader = \"www-authenticate\";\n\n  @Deprecated(\"Use acceptHeader instead\")\n  static const ACCEPT = acceptHeader;\n  @Deprecated(\"Use acceptCharsetHeader instead\")\n  static const ACCEPT_CHARSET = acceptCharsetHeader;\n  @Deprecated(\"Use acceptEncodingHeader instead\")\n  static const ACCEPT_ENCODING = acceptEncodingHeader;\n  @Deprecated(\"Use acceptLanguageHeader instead\")\n  static const ACCEPT_LANGUAGE = acceptLanguageHeader;\n  @Deprecated(\"Use acceptRangesHeader instead\")\n  static const ACCEPT_RANGES = acceptRangesHeader;\n  @Deprecated(\"Use ageHeader instead\")\n  static const AGE = ageHeader;\n  @Deprecated(\"Use allowHeader instead\")\n  static const ALLOW = allowHeader;\n  @Deprecated(\"Use authorizationHeader instead\")\n  static const AUTHORIZATION = authorizationHeader;\n  @Deprecated(\"Use cacheControlHeader instead\")\n  static const CACHE_CONTROL = cacheControlHeader;\n  @Deprecated(\"Use connectionHeader instead\")\n  static const CONNECTION = connectionHeader;\n  @Deprecated(\"Use contentEncodingHeader instead\")\n  static const CONTENT_ENCODING = contentEncodingHeader;\n  @Deprecated(\"Use contentLanguageHeader instead\")\n  static const CONTENT_LANGUAGE = contentLanguageHeader;\n  @Deprecated(\"Use contentLengthHeader instead\")\n  static const CONTENT_LENGTH = contentLengthHeader;\n  @Deprecated(\"Use contentLocationHeader instead\")\n  static const CONTENT_LOCATION = contentLocationHeader;\n  @Deprecated(\"Use contentMD5Header instead\")\n  static const CONTENT_MD5 = contentMD5Header;\n  @Deprecated(\"Use contentRangeHeader instead\")\n  static const CONTENT_RANGE = contentRangeHeader;\n  @Deprecated(\"Use contentTypeHeader instead\")\n  static const CONTENT_TYPE = contentTypeHeader;\n  @Deprecated(\"Use dateHeader instead\")\n  static const DATE = dateHeader;\n  @Deprecated(\"Use etagHeader instead\")\n  static const ETAG = etagHeader;\n  @Deprecated(\"Use expectHeader instead\")\n  static const EXPECT = expectHeader;\n  @Deprecated(\"Use expiresHeader instead\")\n  static const EXPIRES = expiresHeader;\n  @Deprecated(\"Use fromHeader instead\")\n  static const FROM = fromHeader;\n  @Deprecated(\"Use hostHeader instead\")\n  static const HOST = hostHeader;\n  @Deprecated(\"Use ifMatchHeader instead\")\n  static const IF_MATCH = ifMatchHeader;\n  @Deprecated(\"Use ifModifiedSinceHeader instead\")\n  static const IF_MODIFIED_SINCE = ifModifiedSinceHeader;\n  @Deprecated(\"Use ifNoneMatchHeader instead\")\n  static const IF_NONE_MATCH = ifNoneMatchHeader;\n  @Deprecated(\"Use ifRangeHeader instead\")\n  static const IF_RANGE = ifRangeHeader;\n  @Deprecated(\"Use ifUnmodifiedSinceHeader instead\")\n  static const IF_UNMODIFIED_SINCE = ifUnmodifiedSinceHeader;\n  @Deprecated(\"Use lastModifiedHeader instead\")\n  static const LAST_MODIFIED = lastModifiedHeader;\n  @Deprecated(\"Use locationHeader instead\")\n  static const LOCATION = locationHeader;\n  @Deprecated(\"Use maxForwardsHeader instead\")\n  static const MAX_FORWARDS = maxForwardsHeader;\n  @Deprecated(\"Use pragmaHeader instead\")\n  static const PRAGMA = pragmaHeader;\n  @Deprecated(\"Use proxyAuthenticateHeader instead\")\n  static const PROXY_AUTHENTICATE = proxyAuthenticateHeader;\n  @Deprecated(\"Use proxyAuthorizationHeader instead\")\n  static const PROXY_AUTHORIZATION = proxyAuthorizationHeader;\n  @Deprecated(\"Use rangeHeader instead\")\n  static const RANGE = rangeHeader;\n  @Deprecated(\"Use refererHeader instead\")\n  static const REFERER = refererHeader;\n  @Deprecated(\"Use retryAfterHeader instead\")\n  static const RETRY_AFTER = retryAfterHeader;\n  @Deprecated(\"Use serverHeader instead\")\n  static const SERVER = serverHeader;\n  @Deprecated(\"Use teHeader instead\")\n  static const TE = teHeader;\n  @Deprecated(\"Use trailerHeader instead\")\n  static const TRAILER = trailerHeader;\n  @Deprecated(\"Use transferEncodingHeader instead\")\n  static const TRANSFER_ENCODING = transferEncodingHeader;\n  @Deprecated(\"Use upgradeHeader instead\")\n  static const UPGRADE = upgradeHeader;\n  @Deprecated(\"Use userAgentHeader instead\")\n  static const USER_AGENT = userAgentHeader;\n  @Deprecated(\"Use varyHeader instead\")\n  static const VARY = varyHeader;\n  @Deprecated(\"Use viaHeader instead\")\n  static const VIA = viaHeader;\n  @Deprecated(\"Use warningHeader instead\")\n  static const WARNING = warningHeader;\n  @Deprecated(\"Use wwwAuthenticateHeader instead\")\n  static const WWW_AUTHENTICATE = wwwAuthenticateHeader;\n\n  // Cookie headers from RFC 6265.\n  static const cookieHeader = \"cookie\";\n  static const setCookieHeader = \"set-cookie\";\n\n  @Deprecated(\"Use cookieHeader instead\")\n  static const COOKIE = cookieHeader;\n  @Deprecated(\"Use setCookieHeader instead\")\n  static const SET_COOKIE = setCookieHeader;\n\n  // TODO(39783): Document this.\n  static const generalHeaders = [\n    cacheControlHeader,\n    connectionHeader,\n    dateHeader,\n    pragmaHeader,\n    trailerHeader,\n    transferEncodingHeader,\n    upgradeHeader,\n    viaHeader,\n    warningHeader\n  ];\n\n  @Deprecated(\"Use generalHeaders instead\")\n  static const GENERAL_HEADERS = generalHeaders;\n\n  static const entityHeaders = [\n    allowHeader,\n    contentEncodingHeader,\n    contentLanguageHeader,\n    contentLengthHeader,\n    contentLocationHeader,\n    contentMD5Header,\n    contentRangeHeader,\n    contentTypeHeader,\n    expiresHeader,\n    lastModifiedHeader\n  ];\n\n  @Deprecated(\"Use entityHeaders instead\")\n  static const ENTITY_HEADERS = entityHeaders;\n\n  static const responseHeaders = [\n    acceptRangesHeader,\n    ageHeader,\n    etagHeader,\n    locationHeader,\n    proxyAuthenticateHeader,\n    retryAfterHeader,\n    serverHeader,\n    varyHeader,\n    wwwAuthenticateHeader\n  ];\n\n  @Deprecated(\"Use responseHeaders instead\")\n  static const RESPONSE_HEADERS = responseHeaders;\n\n  static const requestHeaders = [\n    acceptHeader,\n    acceptCharsetHeader,\n    acceptEncodingHeader,\n    acceptLanguageHeader,\n    authorizationHeader,\n    expectHeader,\n    fromHeader,\n    hostHeader,\n    ifMatchHeader,\n    ifModifiedSinceHeader,\n    ifNoneMatchHeader,\n    ifRangeHeader,\n    ifUnmodifiedSinceHeader,\n    maxForwardsHeader,\n    proxyAuthorizationHeader,\n    rangeHeader,\n    refererHeader,\n    teHeader,\n    userAgentHeader\n  ];\n\n  @Deprecated(\"Use requestHeaders instead\")\n  static const REQUEST_HEADERS = requestHeaders;\n\n  /// The date specified by the [dateHeader] header, if any.\n  DateTime? date;\n\n  /// The date and time specified by the [expiresHeader] header, if any.\n  DateTime? expires;\n\n  /// The date and time specified by the [ifModifiedSinceHeader] header, if any.\n  DateTime? ifModifiedSince;\n\n  /// The value of the [hostHeader] header, if any.\n  String? host;\n\n  /// The value of the port part of the [hostHeader] header, if any.\n  int? port;\n\n  /// The [ContentType] of the [contentTypeHeader] header, if any.\n  ContentType? contentType;\n\n  /// The value of the [contentLengthHeader] header, if any.\n  ///\n  /// The value is negative if there is no content length set.\n  int contentLength = -1;\n\n  /// Whether the connection is persistent (keep-alive).\n  late bool persistentConnection;\n\n  /// Whether the connection uses chunked transfer encoding.\n  ///\n  /// Reflects and modifies the value of the [transferEncodingHeader] header.\n  late bool chunkedTransferEncoding;\n\n  /// The values for the header named [name].\n  ///\n  /// Returns null if there is no header with the provided name,\n  /// otherwise returns a new list containing the current values.\n  /// Not that modifying the list does not change the header.\n  List<String>? operator [](String name);\n\n  /// Convenience method for the value for a single valued header.\n  ///\n  /// The value must not have more than one value.\n  ///\n  /// Returns `null` if there is no header with the provided name.\n  String? value(String name);\n\n  /// Adds a header value.\n  ///\n  /// The header named [name] will have a string value derived from [value]\n  /// added to its list of values.\n  ///\n  /// Some headers are single valued, and for these, adding a value will\n  /// replace a previous value. If the [value] is a [DateTime], an\n  /// HTTP date format will be applied. If the value is an [Iterable],\n  /// each element will be added separately. For all other\n  /// types the default [Object.toString] method will be used.\n  ///\n  /// Header names are converted to lower-case unless\n  /// [preserveHeaderCase] is set to true. If two header names are\n  /// the same when converted to lower-case, they are considered to be\n  /// the same header, with one set of values.\n  ///\n  /// The current case of the a header name is that of the name used by\n  /// the last [set] or [add] call for that header.\n  void add(String name, Object value,\n      {@Since(\"2.8\") bool preserveHeaderCase = false});\n\n  /// Sets the header [name] to [value].\n  ///\n  /// Removes all existing values for the header named [name] and\n  /// then [add]s [value] to it.\n  void set(String name, Object value,\n      {@Since(\"2.8\") bool preserveHeaderCase = false});\n\n  /// Removes a specific value for a header name.\n  ///\n  /// Some headers have system supplied values which cannot be removed.\n  /// For all other headers and values, the [value] is converted to a string\n  /// in the same way as for [add], then that string value is removed from the\n  /// current values of [name].\n  /// If there are no remaining values for [name], the header is no longer\n  /// considered present.\n  void remove(String name, Object value);\n\n  /// Removes all values for the specified header name.\n  ///\n  /// Some headers have system supplied values which cannot be removed.\n  /// All other values for [name] are removed.\n  /// If there are no remaining values for [name], the header is no longer\n  /// considered present.\n  void removeAll(String name);\n\n  /// Performs the [action] on each header.\n  ///\n  /// The [action] function is called with each header's name and a list\n  /// of the header's values. The casing of the name string is determined by\n  /// the last [add] or [set] operation for that particular header,\n  /// which defaults to lower-casing the header name unless explicitly\n  /// set to preserve the case.\n  void forEach(void Function(String name, List<String> values) action);\n\n  /// Disables folding for the header named [name] when sending the HTTP header.\n  ///\n  /// By default, multiple header values are folded into a\n  /// single header line by separating the values with commas.\n  ///\n  /// The 'set-cookie' header has folding disabled by default.\n  void noFolding(String name);\n\n  /// Removes all headers.\n  ///\n  /// Some headers have system supplied values which cannot be removed.\n  /// All other header values are removed, and header names with not\n  /// remaining values are no longer considered present.\n  void clear();\n}\n\n/// Representation of a header value in the form:\n/// ```plaintext\n/// value; parameter1=value1; parameter2=value2\n/// ```\n///\n/// [HeaderValue] can be used to conveniently build and parse header\n/// values on this form.\n///\n/// Parameter values can be omitted, in which case the value is parsed as `null`.\n/// Values can be doubled quoted to allow characters outside of the RFC 7230\n/// token characters and backslash sequences can be used to represent the double\n/// quote and backslash characters themselves.\n///\n/// To build an \"accepts\" header with the value\n///\n///     text/plain; q=0.3, text/html\n///\n/// use code like this:\n///\n///     HttpClientRequest request = ...;\n///     var v = HeaderValue(\"text/plain\", {\"q\": \"0.3\"});\n///     request.headers.add(HttpHeaders.acceptHeader, v);\n///     request.headers.add(HttpHeaders.acceptHeader, \"text/html\");\n///\n/// To parse the header values use the [parse] static method.\n///\n///     HttpRequest request = ...;\n///     List<String> values = request.headers[HttpHeaders.acceptHeader];\n///     values.forEach((value) {\n///       HeaderValue v = HeaderValue.parse(value);\n///       // Use v.value and v.parameters\n///     });\n///\n/// An instance of [HeaderValue] is immutable.\nabstract class HeaderValue {\n  /// Creates a new header value object setting the value and parameters.\n  factory HeaderValue(\n      [String value = \"\", Map<String, String?> parameters = const {}]) {\n    return _HeaderValue(value, parameters);\n  }\n\n  /// Creates a new header value object from parsing a header value\n  /// string with both value and optional parameters.\n  static HeaderValue parse(String value,\n      {String parameterSeparator = \";\",\n      String? valueSeparator,\n      bool preserveBackslash = false}) {\n    return _HeaderValue.parse(value,\n        parameterSeparator: parameterSeparator,\n        valueSeparator: valueSeparator,\n        preserveBackslash: preserveBackslash);\n  }\n\n  /// The value of the header.\n  String get value;\n\n  /// A map of parameters.\n  ///\n  /// This map cannot be modified.\n  Map<String, String?> get parameters;\n\n  /// Returns the formatted string representation in the form:\n  /// ```plaintext\n  /// value; parameter1=value1; parameter2=value2\n  /// ```\n  String toString();\n}\n\n/// The [session][HttpRequest.session] of an [HttpRequest].\nabstract class HttpSession implements Map {\n  /// The id of the current session.\n  String get id;\n\n  /// Destroys the session.\n  ///\n  /// This terminates the session and any further\n  /// connections with this id will be given a new id and session.\n  void destroy();\n\n  /// Sets a callback that will be called when the session is timed out.\n  ///\n  /// Calling this again will overwrite the previous value.\n  void set onTimeout(void Function() callback);\n\n  /// Whether the session has not yet been sent to the client.\n  bool get isNew;\n}\n\n/// A MIME/IANA media type used as the value of the\n/// [HttpHeaders.contentTypeHeader] header.\n///\n/// A [ContentType] is immutable.\nabstract class ContentType implements HeaderValue {\n  /// Content type for plain text using UTF-8 encoding.\n  ///\n  ///     text/plain; charset=utf-8\n  static final text = ContentType(\"text\", \"plain\", charset: \"utf-8\");\n  @Deprecated(\"Use text instead\")\n  static final TEXT = text;\n\n  /// Content type for HTML using UTF-8 encoding.\n  ///\n  ///    text/html; charset=utf-8\n  static final html = ContentType(\"text\", \"html\", charset: \"utf-8\");\n  @Deprecated(\"Use html instead\")\n  static final HTML = html;\n\n  /// Content type for JSON using UTF-8 encoding.\n  ///\n  ///    application/json; charset=utf-8\n  static final json = ContentType(\"application\", \"json\", charset: \"utf-8\");\n  @Deprecated(\"Use json instead\")\n  static final JSON = json;\n\n  /// Content type for binary data.\n  ///\n  ///    application/octet-stream\n  static final binary = ContentType(\"application\", \"octet-stream\");\n  @Deprecated(\"Use binary instead\")\n  static final BINARY = binary;\n\n  /// Creates a new content type object setting the primary type and\n  /// sub type. The charset and additional parameters can also be set\n  /// using [charset] and [parameters]. If charset is passed and\n  /// [parameters] contains charset as well the passed [charset] will\n  /// override the value in parameters. Keys passed in parameters will be\n  /// converted to lower case. The `charset` entry, whether passed as `charset`\n  /// or in `parameters`, will have its value converted to lower-case.\n  factory ContentType(String primaryType, String subType,\n      {String? charset, Map<String, String?> parameters = const {}}) {\n    return _ContentType(primaryType, subType, charset, parameters);\n  }\n\n  /// Creates a new content type object from parsing a Content-Type\n  /// header value. As primary type, sub type and parameter names and\n  /// values are not case sensitive all these values will be converted\n  /// to lower case. Parsing this string\n  ///\n  ///     text/html; charset=utf-8\n  ///\n  /// will create a content type object with primary type \"text\",\n  /// subtype \"html\" and parameter \"charset\" with value \"utf-8\".\n  /// There may be more parameters supplied, but they are not recognized\n  /// by this class.\n  static ContentType parse(String value) {\n    return _ContentType.parse(value);\n  }\n\n  /// Gets the MIME type and subtype, without any parameters.\n  ///\n  /// For the full content type `text/html;charset=utf-8`,\n  /// the [mimeType] value is the string `text/html`.\n  String get mimeType;\n\n  /// Gets the primary type.\n  ///\n  /// For the full content type `text/html;charset=utf-8`,\n  /// the [primaryType] value is the string `text`.\n  String get primaryType;\n\n  /// Gets the subtype.\n  ///\n  /// For the full content type `text/html;charset=utf-8`,\n  /// the [subType] value is the string `html`.\n  /// May be the empty string.\n  String get subType;\n\n  /// Gets the character set, if any.\n  ///\n  /// For the full content type `text/html;charset=utf-8`,\n  /// the [charset] value is the string `utf-8`.\n  String? get charset;\n}\n\n/// Representation of a cookie. For cookies received by the server as Cookie\n/// header values only [name] and [value] properties will be set. When building a\n/// cookie for the 'set-cookie' header in the server and when receiving cookies\n/// in the client as 'set-cookie' headers all fields can be used.\nabstract class Cookie {\n  /// The name of the cookie.\n  ///\n  /// Must be a `token` as specified in RFC 6265.\n  ///\n  /// The allowed characters in a `token` are the visible ASCII characters,\n  /// U+0021 (`!`) through U+007E (`~`), except the separator characters:\n  /// `(`, `)`, `<`, `>`, `@`, `,`, `;`, `:`, `\\`, `\"`, `/`, `[`, `]`, `?`, `=`,\n  /// `{`, and `}`.\n  late String name;\n\n  /// The value of the cookie.\n  ///\n  /// Must be a `cookie-value` as specified in RFC 6265.\n  ///\n  /// The allowed characters in a cookie value are the visible ASCII characters,\n  /// U+0021 (`!`) through U+007E (`~`) except the characters:\n  /// `\"`, `,`, `;` and `\\`.\n  /// Cookie values may be wrapped in a single pair of double quotes\n  /// (U+0022, `\"`).\n  late String value;\n\n  /// The time at which the cookie expires.\n  DateTime? expires;\n\n  /// The number of seconds until the cookie expires. A zero or negative value\n  /// means the cookie has expired.\n  int? maxAge;\n\n  /// The domain that the cookie applies to.\n  String? domain;\n\n  /// The path within the [domain] that the cookie applies to.\n  String? path;\n\n  /// Whether to only send this cookie on secure connections.\n  bool secure = false;\n\n  /// Whether the cookie is only sent in the HTTP request and is not made\n  /// available to client side scripts.\n  bool httpOnly = false;\n\n  /// Creates a new cookie setting the name and value.\n  ///\n  /// [name] and [value] must be composed of valid characters according to RFC\n  /// 6265.\n  ///\n  /// By default the value of `httpOnly` will be set to `true`.\n  factory Cookie(String name, String value) => _Cookie(name, value);\n\n  /// Creates a new cookie by parsing a header value from a 'set-cookie'\n  /// header.\n  factory Cookie.fromSetCookieValue(String value) {\n    return _Cookie.fromSetCookieValue(value);\n  }\n\n  /// Returns the formatted string representation of the cookie. The\n  /// string representation can be used for setting the Cookie or\n  /// 'set-cookie' headers\n  String toString();\n}\n\n/// A server-side object\n/// that contains the content of and information about an HTTP request.\n///\n/// `HttpRequest` objects are generated by an [HttpServer],\n/// which listens for HTTP requests on a specific host and port.\n/// For each request received, the HttpServer, which is a [Stream],\n/// generates an `HttpRequest` object and adds it to the stream.\n///\n/// An `HttpRequest` object delivers the body content of the request\n/// as a stream of byte lists.\n/// The object also contains information about the request,\n/// such as the method, URI, and headers.\n///\n/// In the following code, an HttpServer listens\n/// for HTTP requests. When the server receives a request,\n/// it uses the HttpRequest object's `method` property to dispatch requests.\n///\n///     final HOST = InternetAddress.loopbackIPv4;\n///     final PORT = 80;\n///\n///     HttpServer.bind(HOST, PORT).then((_server) {\n///       _server.listen((HttpRequest request) {\n///         switch (request.method) {\n///           case 'GET':\n///             handleGetRequest(request);\n///             break;\n///           case 'POST':\n///             ...\n///         }\n///       },\n///       onError: handleError);    // listen() failed.\n///     }).catchError(handleError);\n///\n/// An HttpRequest object provides access to the associated [HttpResponse]\n/// object through the response property.\n/// The server writes its response to the body of the HttpResponse object.\n/// For example, here's a function that responds to a request:\n///\n///     void handleGetRequest(HttpRequest req) {\n///       HttpResponse res = req.response;\n///       res.write('Received request ${req.method}: ${req.uri.path}');\n///       res.close();\n///     }\nabstract class HttpRequest implements Stream<Uint8List> {\n  /// The content length of the request body.\n  ///\n  /// If the size of the request body is not known in advance,\n  /// this value is -1.\n  int get contentLength;\n\n  /// The method, such as 'GET' or 'POST', for the request.\n  String get method;\n\n  /// The URI for the request.\n  ///\n  /// This provides access to the\n  /// path and query string for the request.\n  Uri get uri;\n\n  /// The requested URI for the request.\n  ///\n  /// The returned URI is reconstructed by using http-header fields, to access\n  /// otherwise lost information, e.g. host and scheme.\n  ///\n  /// To reconstruct the scheme, first 'X-Forwarded-Proto' is checked, and then\n  /// falling back to server type.\n  ///\n  /// To reconstruct the host, first 'X-Forwarded-Host' is checked, then 'Host'\n  /// and finally calling back to server.\n  Uri get requestedUri;\n\n  /// The request headers.\n  ///\n  /// The returned [HttpHeaders] are immutable.\n  HttpHeaders get headers;\n\n  /// The cookies in the request, from the \"Cookie\" headers.\n  List<Cookie> get cookies;\n\n  /// The persistent connection state signaled by the client.\n  bool get persistentConnection;\n\n  /// The client certificate of the client making the request.\n  ///\n  /// This value is null if the connection is not a secure TLS or SSL connection,\n  /// or if the server does not request a client certificate, or if the client\n  /// does not provide one.\n  X509Certificate? get certificate;\n\n  /// The session for the given request.\n  ///\n  /// If the session is being initialized by this call,\n  /// [HttpSession.isNew] is true for the returned session.\n  /// See [HttpServer.sessionTimeout] on how to change default timeout.\n  HttpSession get session;\n\n  /// The HTTP protocol version used in the request,\n  /// either \"1.0\" or \"1.1\".\n  String get protocolVersion;\n\n  /// Information about the client connection.\n  ///\n  /// Returns `null` if the socket is not available.\n  HttpConnectionInfo? get connectionInfo;\n\n  /// The [HttpResponse] object, used for sending back the response to the\n  /// client.\n  ///\n  /// If the [contentLength] of the body isn't 0, and the body isn't being read,\n  /// any write calls on the [HttpResponse] automatically drain the request\n  /// body.\n  HttpResponse get response;\n}\n\n/// An HTTP response, which returns the headers and data\n/// from the server to the client in response to an HTTP request.\n///\n/// Every HttpRequest object provides access to the associated [HttpResponse]\n/// object through the `response` property.\n/// The server sends its response to the client by writing to the\n/// HttpResponse object.\n///\n/// ## Writing the response\n///\n/// This class implements [IOSink].\n/// After the header has been set up, the methods\n/// from IOSink, such as `writeln()`, can be used to write\n/// the body of the HTTP response.\n/// Use the `close()` method to close the response and send it to the client.\n///\n///     server.listen((HttpRequest request) {\n///       request.response.write('Hello, world!');\n///       request.response.close();\n///     });\n///\n/// When one of the IOSink methods is used for the\n/// first time, the request header is sent. Calling any methods that\n/// change the header after it is sent throws an exception.\n///\n/// ## Setting the headers\n///\n/// The HttpResponse object has a number of properties for setting up\n/// the HTTP headers of the response.\n/// When writing string data through the IOSink, the encoding used\n/// is determined from the \"charset\" parameter of the\n/// \"Content-Type\" header.\n///\n///     HttpResponse response = ...\n///     response.headers.contentType\n///         = ContentType(\"application\", \"json\", charset: \"utf-8\");\n///     response.write(...);  // Strings written will be UTF-8 encoded.\n///\n/// If no charset is provided the default of ISO-8859-1 (Latin 1) will\n/// be used.\n///\n///     HttpResponse response = ...\n///     response.headers.add(HttpHeaders.contentTypeHeader, \"text/plain\");\n///     response.write(...);  // Strings written will be ISO-8859-1 encoded.\n///\n/// An exception is thrown if you use the `write()` method\n/// while an unsupported content-type is set.\nabstract class HttpResponse implements IOSink {\n  // TODO(ajohnsen): Add documentation of how to pipe a file to the response.\n  /// Gets and sets the content length of the response. If the size of\n  /// the response is not known in advance set the content length to\n  /// -1, which is also the default if not set.\n  int contentLength = -1;\n\n  /// The status code of the response.\n  ///\n  /// Any integer value is accepted. For\n  /// the official HTTP status codes use the fields from\n  /// [HttpStatus]. If no status code is explicitly set the default\n  /// value [HttpStatus.ok] is used.\n  ///\n  /// The status code must be set before the body is written\n  /// to. Setting the status code after writing to the response body or\n  /// closing the response will throw a `StateError`.\n  int statusCode = HttpStatus.ok;\n\n  /// The reason phrase for the response.\n  ///\n  /// If no reason phrase is explicitly set, a default reason phrase is provided.\n  ///\n  /// The reason phrase must be set before the body is written\n  /// to. Setting the reason phrase after writing to the response body\n  /// or closing the response will throw a [StateError].\n  late String reasonPhrase;\n\n  /// Gets and sets the persistent connection state. The initial value\n  /// of this property is the persistent connection state from the\n  /// request.\n  late bool persistentConnection;\n\n  /// Set and get the [deadline] for the response. The deadline is timed from the\n  /// time it's set. Setting a new deadline will override any previous deadline.\n  /// When a deadline is exceeded, the response will be closed and any further\n  /// data ignored.\n  ///\n  /// To disable a deadline, set the [deadline] to `null`.\n  ///\n  /// The [deadline] is `null` by default.\n  Duration? deadline;\n\n  /// Gets or sets if the [HttpResponse] should buffer output.\n  ///\n  /// Default value is `true`.\n  ///\n  /// __Note__: Disabling buffering of the output can result in very poor\n  /// performance, when writing many small chunks.\n  bool bufferOutput = true;\n\n  /// Returns the response headers.\n  ///\n  /// The response headers can be modified until the response body is\n  /// written to or closed. After that they become immutable.\n  HttpHeaders get headers;\n\n  /// Cookies to set in the client (in the 'set-cookie' header).\n  List<Cookie> get cookies;\n\n  /// Respond with a redirect to [location].\n  ///\n  /// The URI in [location] should be absolute, but there are no checks\n  /// to enforce that.\n  ///\n  /// By default the HTTP status code `HttpStatus.movedTemporarily`\n  /// (`302`) is used for the redirect, but an alternative one can be\n  /// specified using the [status] argument.\n  ///\n  /// This method will also call `close`, and the returned future is\n  /// the future returned by `close`.\n  Future redirect(Uri location, {int status = HttpStatus.movedTemporarily});\n\n  /// Detaches the underlying socket from the HTTP server. When the\n  /// socket is detached the HTTP server will no longer perform any\n  /// operations on it.\n  ///\n  /// This is normally used when a HTTP upgrade request is received\n  /// and the communication should continue with a different protocol.\n  ///\n  /// If [writeHeaders] is `true`, the status line and [headers] will be written\n  /// to the socket before it's detached. If `false`, the socket is detached\n  /// immediately, without any data written to the socket. Default is `true`.\n  Future<Socket> detachSocket({bool writeHeaders = true});\n\n  /// Gets information about the client connection. Returns `null` if the\n  /// socket is not available.\n  HttpConnectionInfo? get connectionInfo;\n}\n\n/// An HTTP client for communicating with an HTTP server.\n///\n/// Sends HTTP requests to an HTTP server and receives responses.\n/// Maintains state, including session cookies and other cookies,\n/// between multiple requests to the same server.\n///\n/// Note: [HttpClient] provides low-level HTTP functionality.\n/// We recommend users start with more developer-friendly and composable APIs\n/// found in [`package:http`](https://pub.dev/packages/http).\n///\n/// HttpClient contains a number of methods to send an [HttpClientRequest]\n/// to an Http server and receive an [HttpClientResponse] back.\n/// For example, you can use the [get], [getUrl], [post], and [postUrl] methods\n/// for GET and POST requests, respectively.\n///\n/// ## Making a simple GET request: an example\n///\n/// A `getUrl` request is a two-step process, triggered by two [Future]s.\n/// When the first future completes with a [HttpClientRequest], the underlying\n/// network connection has been established, but no data has been sent.\n/// In the callback function for the first future, the HTTP headers and body\n/// can be set on the request. Either the first write to the request object\n/// or a call to [close] sends the request to the server.\n///\n/// When the HTTP response is received from the server,\n/// the second future, which is returned by close,\n/// completes with an [HttpClientResponse] object.\n/// This object provides access to the headers and body of the response.\n/// The body is available as a stream implemented by `HttpClientResponse`.\n/// If a body is present, it must be read. Otherwise, it leads to resource\n/// leaks. Consider using [HttpClientResponse.drain] if the body is unused.\n///\n/// ```dart import:convert\n/// var client = HttpClient();\n/// try {\n///   HttpClientRequest request = await client.get('localhost', 80, '/file.txt');\n///   // Optionally set up headers...\n///   // Optionally write to the request object...\n///   HttpClientResponse response = await request.close();\n///   // Process the response\n///   final stringData = await response.transform(utf8.decoder).join();\n///   print(stringData);\n/// } finally {\n///   client.close();\n/// }\n/// ```\n///\n/// The future for [HttpClientRequest] is created by methods such as\n/// [getUrl] and [open].\n///\n/// ## HTTPS connections\n///\n/// An `HttpClient` can make HTTPS requests, connecting to a server using\n/// the TLS (SSL) secure networking protocol. Calling [getUrl] with an\n/// https: scheme will work automatically, if the server's certificate is\n/// signed by a root CA (certificate authority) on the default list of\n/// well-known trusted CAs, compiled by Mozilla.\n///\n/// To add a custom trusted certificate authority, or to send a client\n/// certificate to servers that request one, pass a [SecurityContext] object\n/// as the optional `context` argument to the `HttpClient` constructor.\n/// The desired security options can be set on the [SecurityContext] object.\n///\n/// ## Headers\n///\n/// All `HttpClient` requests set the following header by default:\n///\n///     Accept-Encoding: gzip\n///\n/// This allows the HTTP server to use gzip compression for the body if\n/// possible. If this behavior is not desired set the\n/// `Accept-Encoding` header to something else.\n/// To turn off gzip compression of the response, clear this header:\n///\n///      request.headers.removeAll(HttpHeaders.acceptEncodingHeader)\n///\n/// ## Closing the `HttpClient`\n///\n/// `HttpClient` supports persistent connections and caches network\n/// connections to reuse them for multiple requests whenever\n/// possible. This means that network connections can be kept open for\n/// some time after a request has completed. Use [HttpClient.close]\n/// to force the `HttpClient` object to shut down and to close the idle\n/// network connections.\n///\n/// ## Turning proxies on and off\n///\n/// By default the `HttpClient` uses the proxy configuration available\n/// from the environment, see [findProxyFromEnvironment]. To turn off\n/// the use of proxies set the [findProxy] property to `null`.\n///\n///     HttpClient client = HttpClient();\n///     client.findProxy = null;\nabstract class HttpClient {\n  static const int defaultHttpPort = 80;\n  @Deprecated(\"Use defaultHttpPort instead\")\n  static const int DEFAULT_HTTP_PORT = defaultHttpPort;\n\n  static const int defaultHttpsPort = 443;\n  @Deprecated(\"Use defaultHttpsPort instead\")\n  static const int DEFAULT_HTTPS_PORT = defaultHttpsPort;\n\n  /// Enable logging of HTTP requests from all [HttpClient]s to the developer\n  /// timeline.\n  ///\n  /// Default is `false`.\n  static set enableTimelineLogging(bool value) {\n    final enabled = valueOfNonNullableParamWithDefault<bool>(value, false);\n    if (enabled != _enableTimelineLogging) {\n      postEvent('HttpTimelineLoggingStateChange', {\n        'isolateId': Service.getIsolateID(Isolate.current),\n        'enabled': enabled,\n      });\n    }\n    _enableTimelineLogging = enabled;\n  }\n\n  /// Current state of HTTP request logging from all [HttpClient]s to the\n  /// developer timeline.\n  ///\n  /// Default is `false`.\n  static bool get enableTimelineLogging => _enableTimelineLogging;\n\n  static bool _enableTimelineLogging = false;\n\n  /// Gets and sets the idle timeout of non-active persistent (keep-alive)\n  /// connections.\n  ///\n  /// The default value is 15 seconds.\n  Duration idleTimeout = const Duration(seconds: 15);\n\n  /// Gets and sets the connection timeout.\n  ///\n  /// When connecting to a new host exceeds this timeout, a [SocketException]\n  /// is thrown. The timeout applies only to connections initiated after the\n  /// timeout is set.\n  ///\n  /// When this is `null`, the OS default timeout is used. The default is\n  /// `null`.\n  Duration? connectionTimeout;\n\n  /// Gets and sets the maximum number of live connections, to a single host.\n  ///\n  /// Increasing this number may lower performance and take up unwanted\n  /// system resources.\n  ///\n  /// To disable, set to `null`.\n  ///\n  /// Default is `null`.\n  int? maxConnectionsPerHost;\n\n  /// Gets and sets whether the body of a response will be automatically\n  /// uncompressed.\n  ///\n  /// The body of an HTTP response can be compressed. In most\n  /// situations providing the un-compressed body is most\n  /// convenient. Therefore the default behavior is to un-compress the\n  /// body. However in some situations (e.g. implementing a transparent\n  /// proxy) keeping the uncompressed stream is required.\n  ///\n  /// NOTE: Headers in the response are never modified. This means\n  /// that when automatic un-compression is turned on the value of the\n  /// header `Content-Length` will reflect the length of the original\n  /// compressed body. Likewise the header `Content-Encoding` will also\n  /// have the original value indicating compression.\n  ///\n  /// NOTE: Automatic un-compression is only performed if the\n  /// `Content-Encoding` header value is `gzip`.\n  ///\n  /// This value affects all responses produced by this client after the\n  /// value is changed.\n  ///\n  /// To disable, set to `false`.\n  ///\n  /// Default is `true`.\n  bool autoUncompress = true;\n\n  /// Gets and sets the default value of the `User-Agent` header for all requests\n  /// generated by this [HttpClient].\n  ///\n  /// The default value is `Dart/<version> (dart:io)`.\n  ///\n  /// If the userAgent is set to `null`, no default `User-Agent` header will be\n  /// added to each request.\n  String? userAgent;\n\n  factory HttpClient({SecurityContext? context}) {\n    HttpOverrides? overrides = HttpOverrides.current;\n    if (overrides == null) {\n      return _HttpClient(context);\n    }\n    return overrides.createHttpClient(context);\n  }\n\n  /// Opens a HTTP connection.\n  ///\n  /// The HTTP method to use is specified in [method], the server is\n  /// specified using [host] and [port], and the path (including\n  /// a possible query) is specified using [path].\n  /// The path may also contain a URI fragment, which will be ignored.\n  ///\n  /// The `Host` header for the request will be set to the value [host]:[port]\n  /// (if [host] is an IP address, it will still be used in the `Host` header).\n  /// This can be overridden through the [HttpClientRequest] interface before\n  /// the request is sent.\n  ///\n  /// For additional information on the sequence of events during an\n  /// HTTP transaction, and the objects returned by the futures, see\n  /// the overall documentation for the class [HttpClient].\n  Future<HttpClientRequest> open(\n      String method, String host, int port, String path);\n\n  /// Opens a HTTP connection.\n  ///\n  /// The HTTP method is specified in [method] and the URL to use in\n  /// [url].\n  ///\n  /// The `Host` header for the request will be set to the value\n  /// [Uri.host]:[Uri.port] from [url] (if `url.host` is an IP address, it will\n  /// still be used in the `Host` header). This can be overridden through the\n  /// [HttpClientRequest] interface before the request is sent.\n  ///\n  /// For additional information on the sequence of events during an\n  /// HTTP transaction, and the objects returned by the futures, see\n  /// the overall documentation for the class [HttpClient].\n  Future<HttpClientRequest> openUrl(String method, Uri url);\n\n  /// Opens a HTTP connection using the GET method.\n  ///\n  /// The server is specified using [host] and [port], and the path\n  /// (including a possible query) is specified using\n  /// [path].\n  ///\n  /// See [open] for details.\n  Future<HttpClientRequest> get(String host, int port, String path);\n\n  /// Opens a HTTP connection using the GET method.\n  ///\n  /// The URL to use is specified in [url].\n  ///\n  /// See [openUrl] for details.\n  Future<HttpClientRequest> getUrl(Uri url);\n\n  /// Opens a HTTP connection using the POST method.\n  ///\n  /// The server is specified using [host] and [port], and the path\n  /// (including a possible query) is specified using\n  /// [path].\n  ///\n  /// See [open] for details.\n  Future<HttpClientRequest> post(String host, int port, String path);\n\n  /// Opens a HTTP connection using the POST method.\n  ///\n  /// The URL to use is specified in [url].\n  ///\n  /// See [openUrl] for details.\n  Future<HttpClientRequest> postUrl(Uri url);\n\n  /// Opens a HTTP connection using the PUT method.\n  ///\n  /// The server is specified using [host] and [port], and the path\n  /// (including a possible query) is specified using [path].\n  ///\n  /// See [open] for details.\n  Future<HttpClientRequest> put(String host, int port, String path);\n\n  /// Opens a HTTP connection using the PUT method.\n  ///\n  /// The URL to use is specified in [url].\n  ///\n  /// See [openUrl] for details.\n  Future<HttpClientRequest> putUrl(Uri url);\n\n  /// Opens a HTTP connection using the DELETE method.\n  ///\n  /// The server is specified using [host] and [port], and the path\n  /// (including a possible query) is specified using [path].\n  ///\n  /// See [open] for details.\n  Future<HttpClientRequest> delete(String host, int port, String path);\n\n  /// Opens a HTTP connection using the DELETE method.\n  ///\n  /// The URL to use is specified in [url].\n  ///\n  /// See [openUrl] for details.\n  Future<HttpClientRequest> deleteUrl(Uri url);\n\n  /// Opens a HTTP connection using the PATCH method.\n  ///\n  /// The server is specified using [host] and [port], and the path\n  /// (including a possible query) is specified using [path].\n  ///\n  /// See [open] for details.\n  Future<HttpClientRequest> patch(String host, int port, String path);\n\n  /// Opens a HTTP connection using the PATCH method.\n  ///\n  /// The URL to use is specified in [url].\n  ///\n  /// See [openUrl] for details.\n  Future<HttpClientRequest> patchUrl(Uri url);\n\n  /// Opens a HTTP connection using the HEAD method.\n  ///\n  /// The server is specified using [host] and [port], and the path\n  /// (including a possible query) is specified using [path].\n  ///\n  /// See [open] for details.\n  Future<HttpClientRequest> head(String host, int port, String path);\n\n  /// Opens a HTTP connection using the HEAD method.\n  ///\n  /// The URL to use is specified in [url].\n  ///\n  /// See [openUrl] for details.\n  Future<HttpClientRequest> headUrl(Uri url);\n\n  /// Sets the function to be called when a site is requesting\n  /// authentication.\n  ///\n  /// The URL requested, the authentication scheme and the security realm\n  /// from the server are passed in the arguments [f.url], [f.scheme] and\n  /// [f.realm].\n  ///\n  /// The function returns a [Future] which should complete when the\n  /// authentication has been resolved. If credentials cannot be\n  /// provided the [Future] should complete with `false`. If\n  /// credentials are available the function should add these using\n  /// [addCredentials] before completing the [Future] with the value\n  /// `true`.\n  ///\n  /// If the [Future] completes with `true` the request will be retried\n  /// using the updated credentials, however, the retried request will not\n  /// carry the original request payload. Otherwise response processing will\n  /// continue normally.\n  ///\n  /// If it is known that the remote server requires authentication for all\n  /// requests, it is advisable to use [addCredentials] directly, or manually\n  /// set the `'authorization'` header on the request to avoid the overhead\n  /// of a failed request, or issues due to missing request payload on retried\n  /// request.\n  void set authenticate(\n      Future<bool> Function(Uri url, String scheme, String? realm)? f);\n\n  /// Add credentials to be used for authorizing HTTP requests.\n  void addCredentials(Uri url, String realm, HttpClientCredentials credentials);\n\n  /// Sets the function used to resolve the proxy server to be used for\n  /// opening a HTTP connection to the specified [url]. If this\n  /// function is not set, direct connections will always be used.\n  ///\n  /// The string returned by [f] must be in the format used by browser\n  /// PAC (proxy auto-config) scripts. That is either\n  ///\n  ///     \"DIRECT\"\n  ///\n  /// for using a direct connection or\n  ///\n  ///     \"PROXY host:port\"\n  ///\n  /// for using the proxy server `host` on port `port`.\n  ///\n  /// A configuration can contain several configuration elements\n  /// separated by semicolons, e.g.\n  ///\n  ///     \"PROXY host:port; PROXY host2:port2; DIRECT\"\n  ///\n  /// The static function [findProxyFromEnvironment] on this class can\n  /// be used to implement proxy server resolving based on environment\n  /// variables.\n  void set findProxy(String Function(Uri url)? f);\n\n  /// Function for resolving the proxy server to be used for a HTTP\n  /// connection from the proxy configuration specified through\n  /// environment variables.\n  ///\n  /// The following environment variables are taken into account:\n  ///\n  ///     http_proxy\n  ///     https_proxy\n  ///     no_proxy\n  ///     HTTP_PROXY\n  ///     HTTPS_PROXY\n  ///     NO_PROXY\n  ///\n  /// [:http_proxy:] and [:HTTP_PROXY:] specify the proxy server to use for\n  /// http:// urls. Use the format [:hostname:port:]. If no port is used a\n  /// default of 1080 will be used. If both are set the lower case one takes\n  /// precedence.\n  ///\n  /// [:https_proxy:] and [:HTTPS_PROXY:] specify the proxy server to use for\n  /// https:// urls. Use the format [:hostname:port:]. If no port is used a\n  /// default of 1080 will be used. If both are set the lower case one takes\n  /// precedence.\n  ///\n  /// [:no_proxy:] and [:NO_PROXY:] specify a comma separated list of\n  /// postfixes of hostnames for which not to use the proxy\n  /// server. E.g. the value \"localhost,127.0.0.1\" will make requests\n  /// to both \"localhost\" and \"127.0.0.1\" not use a proxy. If both are set\n  /// the lower case one takes precedence.\n  ///\n  /// To activate this way of resolving proxies assign this function to\n  /// the [findProxy] property on the [HttpClient].\n  ///\n  ///     HttpClient client = HttpClient();\n  ///     client.findProxy = HttpClient.findProxyFromEnvironment;\n  ///\n  /// If you don't want to use the system environment you can use a\n  /// different one by wrapping the function.\n  ///\n  ///     HttpClient client = HttpClient();\n  ///     client.findProxy = (url) {\n  ///       return HttpClient.findProxyFromEnvironment(\n  ///           url, environment: {\"http_proxy\": ..., \"no_proxy\": ...});\n  ///     }\n  ///\n  /// If a proxy requires authentication it is possible to configure\n  /// the username and password as well. Use the format\n  /// [:username:password@hostname:port:] to include the username and\n  /// password. Alternatively the API [addProxyCredentials] can be used\n  /// to set credentials for proxies which require authentication.\n  static String findProxyFromEnvironment(Uri url,\n      {Map<String, String>? environment}) {\n    HttpOverrides? overrides = HttpOverrides.current;\n    if (overrides == null) {\n      return _HttpClient._findProxyFromEnvironment(url, environment);\n    }\n    return overrides.findProxyFromEnvironment(url, environment);\n  }\n\n  /// Sets the function to be called when a proxy is requesting\n  /// authentication.\n  ///\n  /// Information on the proxy in use, the authentication scheme\n  /// and the security realm for the authentication\n  /// are passed in the arguments [f.host], [f.port], [f.scheme] and [f.realm].\n  ///\n  /// The function returns a [Future] which should complete when the\n  /// authentication has been resolved. If credentials cannot be\n  /// provided the [Future] should complete with `false`. If\n  /// credentials are available the function should add these using\n  /// [addProxyCredentials] before completing the [Future] with the value\n  /// `true`.\n  ///\n  /// If the [Future] completes with `true` the request will be retried\n  /// using the updated credentials. Otherwise response processing will\n  /// continue normally.\n  void set authenticateProxy(\n      Future<bool> Function(\n              String host, int port, String scheme, String? realm)?\n          f);\n\n  /// Add credentials to be used for authorizing HTTP proxies.\n  void addProxyCredentials(\n      String host, int port, String realm, HttpClientCredentials credentials);\n\n  /// Sets a callback that will decide whether to accept a secure connection\n  /// with a server certificate that cannot be authenticated by any of our\n  /// trusted root certificates.\n  ///\n  /// When an secure HTTP request if made, using this HttpClient, and the\n  /// server returns a server certificate that cannot be authenticated, the\n  /// callback is called asynchronously with the [X509Certificate] object and\n  /// the server's hostname and port.  If the value of [badCertificateCallback]\n  /// is `null`, the bad certificate is rejected, as if the callback\n  /// returned `false`\n  ///\n  /// If the callback returns true, the secure connection is accepted and the\n  /// `Future<HttpClientRequest>` that was returned from the call making the\n  /// request completes with a valid HttpRequest object. If the callback returns\n  /// false, the `Future<HttpClientRequest>` completes with an exception.\n  ///\n  /// If a bad certificate is received on a connection attempt, the library calls\n  /// the function that was the value of badCertificateCallback at the time\n  /// the request is made, even if the value of badCertificateCallback\n  /// has changed since then.\n  void set badCertificateCallback(\n      bool Function(X509Certificate cert, String host, int port)? callback);\n\n  /// Shuts down the HTTP client.\n  ///\n  /// If [force] is `false` (the default) the [HttpClient] will be kept alive\n  /// until all active connections are done. If [force] is `true` any active\n  /// connections will be closed to immediately release all resources. These\n  /// closed connections will receive an error event to indicate that the client\n  /// was shut down. In both cases trying to establish a new connection after\n  /// calling [close] will throw an exception.\n  void close({bool force = false});\n}\n\n/// HTTP request for a client connection.\n///\n/// To set up a request, set the headers using the headers property\n/// provided in this class and write the data to the body of the request.\n/// `HttpClientRequest` is an [IOSink]. Use the methods from IOSink,\n/// such as `writeCharCode()`, to write the body of the HTTP\n/// request. When one of the IOSink methods is used for the first\n/// time, the request header is sent. Calling any methods that\n/// change the header after it is sent throws an exception.\n///\n/// When writing string data through the [IOSink] the\n/// encoding used is determined from the \"charset\" parameter of\n/// the \"Content-Type\" header.\n///\n/// ```dart import:convert\n/// var client = HttpClient();\n/// HttpClientRequest request = await client.get('localhost', 80, '/file.txt');\n/// request.headers.contentType =\n///     ContentType('application', 'json', charset: 'utf-8');\n/// request.write('text content\ud83d\udc4d\ud83c\udfaf'); // Strings written will be UTF-8 encoded.\n/// ```\n///\n/// If no charset is provided the default of ISO-8859-1 (Latin 1) is used.\n///\n/// ```dart\n/// var client = HttpClient();\n/// HttpClientRequest request = await client.get('localhost', 80, '/file.txt');\n/// request.headers.add(HttpHeaders.contentTypeHeader, \"text/plain\");\n/// request.write('bl\u00e5b\u00e6rgr\u00f8d'); // Strings written will be ISO-8859-1 encoded\n/// ```\n///\n/// An exception is thrown if you use an unsupported encoding and the\n/// `write()` method being used takes a string parameter.\nabstract class HttpClientRequest implements IOSink {\n  /// The requested persistent connection state.\n  ///\n  /// The default value is `true`.\n  bool persistentConnection = true;\n\n  /// Whether to follow redirects automatically.\n  ///\n  /// Set this property to `false` if this request should not\n  /// automatically follow redirects. The default is `true`.\n  ///\n  /// Automatic redirect will only happen for \"GET\" and \"HEAD\" requests\n  /// and only for the status codes [HttpStatus.movedPermanently]\n  /// (301), [HttpStatus.found] (302),\n  /// [HttpStatus.movedTemporarily] (302, alias for\n  /// [HttpStatus.found]), [HttpStatus.seeOther] (303),\n  /// [HttpStatus.temporaryRedirect] (307) and\n  /// [HttpStatus.permanentRedirect] (308). For\n  /// [HttpStatus.seeOther] (303) automatic redirect will also happen\n  /// for \"POST\" requests with the method changed to \"GET\" when\n  /// following the redirect.\n  ///\n  /// All headers added to the request will be added to the redirection\n  /// request(s). However, any body send with the request will not be\n  /// part of the redirection request(s).\n  bool followRedirects = true;\n\n  /// Set this property to the maximum number of redirects to follow\n  /// when [followRedirects] is `true`. If this number is exceeded\n  /// an error event will be added with a [RedirectException].\n  ///\n  /// The default value is 5.\n  int maxRedirects = 5;\n\n  /// The method of the request.\n  String get method;\n\n  /// The uri of the request.\n  Uri get uri;\n\n  /// Gets and sets the content length of the request.\n  ///\n  /// If the size of the request is not known in advance set content length to\n  /// -1, which is also the default.\n  int contentLength = -1;\n\n  /// Gets or sets if the [HttpClientRequest] should buffer output.\n  ///\n  /// Default value is `true`.\n  ///\n  /// __Note__: Disabling buffering of the output can result in very poor\n  /// performance, when writing many small chunks.\n  bool bufferOutput = true;\n\n  /// Returns the client request headers.\n  ///\n  /// The client request headers can be modified until the client\n  /// request body is written to or closed. After that they become\n  /// immutable.\n  HttpHeaders get headers;\n\n  /// Cookies to present to the server (in the 'cookie' header).\n  List<Cookie> get cookies;\n\n  /// A [HttpClientResponse] future that will complete once the response is\n  /// available.\n  ///\n  /// If an error occurs before the response is available, this future will\n  /// complete with an error.\n  Future<HttpClientResponse> get done;\n\n  /// Close the request for input. Returns the value of [done].\n  Future<HttpClientResponse> close();\n\n  /// Gets information about the client connection.\n  ///\n  /// Returns `null` if the socket is not available.\n  HttpConnectionInfo? get connectionInfo;\n\n  /// Aborts the client connection.\n  ///\n  /// If the connection has not yet completed, the request is aborted and the\n  /// [done] future (also returned by [close]) is completed with the provided\n  /// [exception] and [stackTrace].\n  /// If [exception] is omitted, it defaults to an [HttpException], and if\n  /// [stackTrace] is omitted, it defaults to [StackTrace.empty].\n  ///\n  /// If the [done] future has already completed, aborting has no effect.\n  ///\n  /// Using the [IOSink] methods (e.g., [write] and [add]) has no effect after\n  /// the request has been aborted\n  ///\n  /// ```dart import:async\n  /// var client = HttpClient();\n  /// HttpClientRequest request = await client.get('localhost', 80, '/file.txt');\n  /// request.write('request content');\n  /// Timer(Duration(seconds: 1), () {\n  ///   request.abort();\n  /// });\n  /// request.close().then((response) {\n  ///   // If response comes back before abort, this callback will be called.\n  /// }, onError: (e) {\n  ///   // If abort() called before response is available, onError will fire.\n  /// });\n  /// ```\n  @Since(\"2.10\")\n  void abort([Object? exception, StackTrace? stackTrace]);\n}\n\n/// HTTP response for a client connection.\n///\n/// The body of a [HttpClientResponse] object is a [Stream] of data from the\n/// server. Use [Stream] methods like [`transform`][Stream.transform] and\n/// [`join`][Stream.join] to access the data.\n///\n/// ```dart import:convert\n/// var client = HttpClient();\n/// try {\n///   HttpClientRequest request = await client.get('localhost', 80, '/file.txt');\n///   HttpClientResponse response = await request.close();\n///   final stringData = await response.transform(utf8.decoder).join();\n///   print(stringData);\n/// } finally {\n///   client.close();\n/// }\n/// ```\nabstract class HttpClientResponse implements Stream<List<int>> {\n  /// Returns the status code.\n  ///\n  /// The status code must be set before the body is written\n  /// to. Setting the status code after writing to the body will throw\n  /// a `StateError`.\n  int get statusCode;\n\n  /// Returns the reason phrase associated with the status code.\n  ///\n  /// The reason phrase must be set before the body is written\n  /// to. Setting the reason phrase after writing to the body will throw\n  /// a `StateError`.\n  String get reasonPhrase;\n\n  /// Returns the content length of the response body. Returns -1 if the size of\n  /// the response body is not known in advance.\n  ///\n  /// If the content length needs to be set, it must be set before the\n  /// body is written to. Setting the content length after writing to the body\n  /// will throw a `StateError`.\n  int get contentLength;\n\n  /// The compression state of the response.\n  ///\n  /// This specifies whether the response bytes were compressed when they were\n  /// received across the wire and whether callers will receive compressed\n  /// or uncompressed bytes when they listed to this response's byte stream.\n  @Since(\"2.4\")\n  HttpClientResponseCompressionState get compressionState;\n\n  /// Gets the persistent connection state returned by the server.\n  ///\n  /// If the persistent connection state needs to be set, it must be\n  /// set before the body is written to. Setting the persistent connection state\n  /// after writing to the body will throw a `StateError`.\n  bool get persistentConnection;\n\n  /// Returns whether the status code is one of the normal redirect\n  /// codes [HttpStatus.movedPermanently], [HttpStatus.found],\n  /// [HttpStatus.movedTemporarily], [HttpStatus.seeOther] and\n  /// [HttpStatus.temporaryRedirect].\n  bool get isRedirect;\n\n  /// Returns the series of redirects this connection has been through. The\n  /// list will be empty if no redirects were followed. [redirects] will be\n  /// updated both in the case of an automatic and a manual redirect.\n  List<RedirectInfo> get redirects;\n\n  /// Redirects this connection to a new URL. The default value for\n  /// [method] is the method for the current request. The default value\n  /// for [url] is the value of the [HttpHeaders.locationHeader] header of\n  /// the current response. All body data must have been read from the\n  /// current response before calling [redirect].\n  ///\n  /// All headers added to the request will be added to the redirection\n  /// request. However, any body sent with the request will not be\n  /// part of the redirection request.\n  ///\n  /// If [followLoops] is set to `true`, redirect will follow the redirect,\n  /// even if the URL was already visited. The default value is `false`.\n  ///\n  /// The method will ignore [HttpClientRequest.maxRedirects]\n  /// and will always perform the redirect.\n  Future<HttpClientResponse> redirect(\n      [String? method, Uri? url, bool? followLoops]);\n\n  /// Returns the client response headers.\n  ///\n  /// The client response headers are immutable.\n  HttpHeaders get headers;\n\n  /// Detach the underlying socket from the HTTP client. When the\n  /// socket is detached the HTTP client will no longer perform any\n  /// operations on it.\n  ///\n  /// This is normally used when a HTTP upgrade is negotiated and the\n  /// communication should continue with a different protocol.\n  Future<Socket> detachSocket();\n\n  /// Cookies set by the server (from the 'set-cookie' header).\n  List<Cookie> get cookies;\n\n  /// Returns the certificate of the HTTPS server providing the response.\n  /// Returns null if the connection is not a secure TLS or SSL connection.\n  X509Certificate? get certificate;\n\n  /// Gets information about the client connection. Returns `null` if the socket\n  /// is not available.\n  HttpConnectionInfo? get connectionInfo;\n}\n\n/// Enum that specifies the compression state of the byte stream of an\n/// [HttpClientResponse].\n///\n/// The values herein allow callers to answer the following questions as they\n/// pertain to an [HttpClientResponse]:\n///\n///  * Can the value of the response's `Content-Length` HTTP header be trusted?\n///  * Does the caller need to manually decompress the response's byte stream?\n///\n/// This enum is accessed via the [HttpClientResponse.compressionState] value.\n@Since(\"2.4\")\nenum HttpClientResponseCompressionState {\n  /// The body of the HTTP response was received and remains in an uncompressed\n  /// state.\n  ///\n  /// In this state, the value of the `Content-Length` HTTP header, if\n  /// specified (non-negative), should match the number of bytes produced by\n  /// the response's byte stream.\n  notCompressed,\n\n  /// The body of the HTTP response was originally compressed, but by virtue of\n  /// the [HttpClient.autoUncompress] configuration option, it has been\n  /// automatically uncompressed.\n  ///\n  /// HTTP headers are not modified, so when a response has been uncompressed\n  /// in this way, the value of the `Content-Length` HTTP header cannot be\n  /// trusted, as it will contain the compressed content length, whereas the\n  /// stream of bytes produced by the response will contain uncompressed bytes.\n  decompressed,\n\n  /// The body of the HTTP response contains compressed bytes.\n  ///\n  /// In this state, the value of the `Content-Length` HTTP header, if\n  /// specified (non-negative), should match the number of bytes produced by\n  /// the response's byte stream.\n  ///\n  /// If the caller wishes to manually uncompress the body of the response,\n  /// it should consult the value of the `Content-Encoding` HTTP header to see\n  /// what type of compression has been applied. See\n  /// <https://tools.ietf.org/html/rfc2616#section-14.11> for more information.\n  compressed,\n}\n\nabstract class HttpClientCredentials {}\n\n/// Represents credentials for basic authentication.\nabstract class HttpClientBasicCredentials extends HttpClientCredentials {\n  factory HttpClientBasicCredentials(String username, String password) =>\n      _HttpClientBasicCredentials(username, password);\n}\n\n/// Represents credentials for digest authentication. Digest\n/// authentication is only supported for servers using the MD5\n/// algorithm and quality of protection (qop) of either \"none\" or\n/// \"auth\".\nabstract class HttpClientDigestCredentials extends HttpClientCredentials {\n  factory HttpClientDigestCredentials(String username, String password) =>\n      _HttpClientDigestCredentials(username, password);\n}\n\n/// Information about an [HttpRequest], [HttpResponse], [HttpClientRequest], or\n/// [HttpClientResponse] connection.\nabstract class HttpConnectionInfo {\n  InternetAddress get remoteAddress;\n  int get remotePort;\n  int get localPort;\n}\n\n/// Redirect information.\nabstract class RedirectInfo {\n  /// Returns the status code used for the redirect.\n  int get statusCode;\n\n  /// Returns the method used for the redirect.\n  String get method;\n\n  /// Returns the location for the redirect.\n  Uri get location;\n}\n\nclass HttpException implements IOException {\n  final String message;\n  final Uri? uri;\n\n  const HttpException(this.message, {this.uri});\n\n  String toString() {\n    var b = StringBuffer()\n      ..write('HttpException: ')\n      ..write(message);\n    var uri = this.uri;\n    if (uri != null) {\n      b.write(', uri = $uri');\n    }\n    return b.toString();\n  }\n}\n\nclass RedirectException implements HttpException {\n  final String message;\n  final List<RedirectInfo> redirects;\n\n  const RedirectException(this.message, this.redirects);\n\n  String toString() => \"RedirectException: $message\";\n\n  Uri get uri => redirects.last.location;\n}\n", "// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart._http;\n\nabstract class HttpProfiler {\n  static const _kType = 'HttpProfile';\n\n  static final Map<int, _HttpProfileData> _profile = {};\n\n  static _HttpProfileData startRequest(\n    String method,\n    Uri uri, {\n    _HttpProfileData? parentRequest,\n  }) {\n    final data = _HttpProfileData(method, uri, parentRequest?._timeline);\n    _profile[data.id] = data;\n    return data;\n  }\n\n  static _HttpProfileData? getHttpProfileRequest(int id) => _profile[id];\n\n  static void clear() => _profile.clear();\n\n  static String toJson(int? updatedSince) {\n    return json.encode({\n      'type': _kType,\n      'timestamp': Timeline.now,\n      'requests': [\n        for (final request in _profile.values.where(\n          (e) {\n            return (updatedSince == null) || e.lastUpdateTime >= updatedSince;\n          },\n        ))\n          request.toJson(),\n      ],\n    });\n  }\n}\n\nclass _HttpProfileEvent {\n  _HttpProfileEvent(this.name, this.arguments);\n  final int timestamp = Timeline.now;\n  final String name;\n  final Map? arguments;\n\n  Map<String, dynamic> toJson() {\n    return <String, dynamic>{\n      'timestamp': timestamp,\n      'event': name,\n      if (arguments != null) 'arguments': arguments,\n    };\n  }\n}\n\nclass _HttpProfileData {\n  _HttpProfileData(String method, this.uri, TimelineTask? parent)\n      : method = method.toUpperCase(),\n        _timeline = TimelineTask(\n          filterKey: 'HTTP/client',\n          parent: parent,\n        ) {\n    // Grab the ID from the timeline event so HTTP profile IDs can be matched\n    // to the timeline.\n    id = _timeline.pass();\n    requestInProgress = true;\n    requestStartTimestamp = Timeline.now;\n    _timeline.start('HTTP CLIENT $method', arguments: {\n      'method': method.toUpperCase(),\n      'uri': uri.toString(),\n    });\n    _updated();\n  }\n\n  void requestEvent(String name, {Map? arguments}) {\n    _timeline.instant(name, arguments: arguments);\n    requestEvents.add(_HttpProfileEvent(name, arguments));\n    _updated();\n  }\n\n  void proxyEvent(_Proxy proxy) {\n    proxyDetails = {\n      if (proxy.host != null) 'host': proxy.host,\n      if (proxy.port != null) 'port': proxy.port,\n      if (proxy.username != null) 'username': proxy.username,\n    };\n    _timeline.instant('Establishing proxy tunnel', arguments: {\n      'proxyDetails': proxyDetails,\n    });\n    _updated();\n  }\n\n  void appendRequestData(Uint8List data) {\n    requestBody.addAll(data);\n    _updated();\n  }\n\n  Map formatHeaders(HttpHeaders headers) {\n    final newHeaders = <String, List<String>>{};\n    headers.forEach((name, values) {\n      newHeaders[name] = values;\n    });\n    return newHeaders;\n  }\n\n  Map? formatConnectionInfo(HttpConnectionInfo? connectionInfo) =>\n      connectionInfo == null\n          ? null\n          : {\n              'localPort': connectionInfo.localPort,\n              'remoteAddress': connectionInfo.remoteAddress.address,\n              'remotePort': connectionInfo.remotePort,\n            };\n\n  void finishRequest({\n    required HttpClientRequest request,\n  }) {\n    // TODO(bkonyi): include encoding?\n    requestInProgress = false;\n    requestEndTimestamp = Timeline.now;\n    requestDetails = <String, dynamic>{\n      // TODO(bkonyi): consider exposing certificate information?\n      // 'certificate': response.certificate,\n      'headers': formatHeaders(request.headers),\n      'connectionInfo': formatConnectionInfo(request.connectionInfo),\n      'contentLength': request.contentLength,\n      'cookies': [\n        for (final cookie in request.cookies) cookie.toString(),\n      ],\n      'followRedirects': request.followRedirects,\n      'maxRedirects': request.maxRedirects,\n      'method': request.method,\n      'persistentConnection': request.persistentConnection,\n      'uri': request.uri.toString(),\n    };\n    _timeline.finish(\n      arguments: requestDetails,\n    );\n    _updated();\n  }\n\n  void startResponse({required HttpClientResponse response}) {\n    List<Map<String, dynamic>> formatRedirectInfo() {\n      final redirects = <Map<String, dynamic>>[];\n      for (final redirect in response.redirects) {\n        redirects.add({\n          'location': redirect.location.toString(),\n          'method': redirect.method,\n          'statusCode': redirect.statusCode,\n        });\n      }\n      return redirects;\n    }\n\n    responseDetails = <String, dynamic>{\n      'headers': formatHeaders(response.headers),\n      'compressionState': response.compressionState.toString(),\n      'connectionInfo': formatConnectionInfo(response.connectionInfo),\n      'contentLength': response.contentLength,\n      'cookies': [\n        for (final cookie in response.cookies) cookie.toString(),\n      ],\n      'isRedirect': response.isRedirect,\n      'persistentConnection': response.persistentConnection,\n      'reasonPhrase': response.reasonPhrase,\n      'redirects': formatRedirectInfo(),\n      'statusCode': response.statusCode,\n    };\n\n    assert(!requestInProgress);\n    responseInProgress = true;\n    _responseTimeline = TimelineTask(\n      parent: _timeline,\n      filterKey: 'HTTP/client',\n    );\n\n    responseStartTimestamp = Timeline.now;\n    _responseTimeline.start(\n      'HTTP CLIENT response of $method',\n      arguments: {\n        'requestUri': uri.toString(),\n        ...responseDetails!,\n      },\n    );\n    _updated();\n  }\n\n  void finishRequestWithError(String error) {\n    requestInProgress = false;\n    requestEndTimestamp = Timeline.now;\n    requestError = error;\n    _timeline.finish(arguments: {\n      'error': error,\n    });\n    _updated();\n  }\n\n  void finishResponse() {\n    responseInProgress = false;\n    responseEndTimestamp = Timeline.now;\n    requestEvent('Content Download');\n    _responseTimeline.finish();\n    _updated();\n  }\n\n  void finishResponseWithError(String error) {\n    // Return if finishResponseWithError has already been called. Can happen if\n    // the response stream is listened to with `cancelOnError: false`.\n    if (!responseInProgress!) return;\n    responseInProgress = false;\n    responseEndTimestamp = Timeline.now;\n    responseError = error;\n    _responseTimeline.finish(arguments: {\n      'error': error,\n    });\n    _updated();\n  }\n\n  void appendResponseData(Uint8List data) {\n    responseBody.addAll(data);\n    _updated();\n  }\n\n  Map<String, dynamic> toJson({bool ref = true}) {\n    return <String, dynamic>{\n      'type': '${ref ? '@' : ''}HttpProfileRequest',\n      'id': id,\n      'isolateId': isolateId,\n      'method': method,\n      'uri': uri.toString(),\n      'startTime': requestStartTimestamp,\n      if (!requestInProgress) 'endTime': requestEndTimestamp,\n      if (!requestInProgress)\n        'request': {\n          'events': <Map<String, dynamic>>[\n            for (final event in requestEvents) event.toJson(),\n          ],\n          if (proxyDetails != null) 'proxyDetails': proxyDetails!,\n          if (requestDetails != null) ...requestDetails!,\n          if (requestError != null) 'error': requestError,\n        },\n      if (responseInProgress != null)\n        'response': <String, dynamic>{\n          'startTime': responseStartTimestamp,\n          ...responseDetails!,\n          if (!responseInProgress!) 'endTime': responseEndTimestamp,\n          if (responseError != null) 'error': responseError,\n        },\n      if (!ref) ...{\n        if (!requestInProgress) 'requestBody': requestBody,\n        if (responseInProgress != null) 'responseBody': responseBody,\n      }\n    };\n  }\n\n  void _updated() => _lastUpdateTime = Timeline.now;\n\n  static final String isolateId = Service.getIsolateID(Isolate.current)!;\n\n  bool requestInProgress = true;\n  bool? responseInProgress;\n\n  late final int id;\n  final String method;\n  final Uri uri;\n\n  late final int requestStartTimestamp;\n  late final int requestEndTimestamp;\n  Map<String, dynamic>? requestDetails;\n  Map<String, dynamic>? proxyDetails;\n  final requestBody = <int>[];\n  String? requestError;\n  final requestEvents = <_HttpProfileEvent>[];\n\n  late final int responseStartTimestamp;\n  late final int responseEndTimestamp;\n  Map<String, dynamic>? responseDetails;\n  final responseBody = <int>[];\n  String? responseError;\n\n  int get lastUpdateTime => _lastUpdateTime;\n  int _lastUpdateTime = 0;\n\n  final TimelineTask _timeline;\n  late TimelineTask _responseTimeline;\n}\n\nint _nextServiceId = 1;\n\n// TODO(ajohnsen): Use other way of getting a unique id.\nabstract class _ServiceObject {\n  int __serviceId = 0;\n  int get _serviceId {\n    if (__serviceId == 0) __serviceId = _nextServiceId++;\n    return __serviceId;\n  }\n\n  Map _toJSON(bool ref);\n\n  String get _servicePath => \"$_serviceTypePath/$_serviceId\";\n\n  String get _serviceTypePath;\n\n  String get _serviceTypeName;\n\n  String _serviceType(bool ref) {\n    if (ref) return \"@$_serviceTypeName\";\n    return _serviceTypeName;\n  }\n}\n\nclass _CopyingBytesBuilder implements BytesBuilder {\n  // Start with 1024 bytes.\n  static const int _INIT_SIZE = 1024;\n\n  static final _emptyList = Uint8List(0);\n\n  int _length = 0;\n  Uint8List _buffer;\n\n  _CopyingBytesBuilder([int initialCapacity = 0])\n      : _buffer = (initialCapacity <= 0)\n            ? _emptyList\n            : Uint8List(_pow2roundup(initialCapacity));\n\n  void add(List<int> bytes) {\n    int bytesLength = bytes.length;\n    if (bytesLength == 0) return;\n    int required = _length + bytesLength;\n    if (_buffer.length < required) {\n      _grow(required);\n    }\n    assert(_buffer.length >= required);\n    if (bytes is Uint8List) {\n      _buffer.setRange(_length, required, bytes);\n    } else {\n      for (int i = 0; i < bytesLength; i++) {\n        _buffer[_length + i] = bytes[i];\n      }\n    }\n    _length = required;\n  }\n\n  void addByte(int byte) {\n    if (_buffer.length == _length) {\n      // The grow algorithm always at least doubles.\n      // If we added one to _length it would quadruple unnecessarily.\n      _grow(_length);\n    }\n    assert(_buffer.length > _length);\n    _buffer[_length] = byte;\n    _length++;\n  }\n\n  void _grow(int required) {\n    // We will create a list in the range of 2-4 times larger than\n    // required.\n    int newSize = required * 2;\n    if (newSize < _INIT_SIZE) {\n      newSize = _INIT_SIZE;\n    } else {\n      newSize = _pow2roundup(newSize);\n    }\n    var newBuffer = Uint8List(newSize);\n    newBuffer.setRange(0, _buffer.length, _buffer);\n    _buffer = newBuffer;\n  }\n\n  Uint8List takeBytes() {\n    if (_length == 0) return _emptyList;\n    var buffer = Uint8List.view(_buffer.buffer, _buffer.offsetInBytes, _length);\n    clear();\n    return buffer;\n  }\n\n  Uint8List toBytes() {\n    if (_length == 0) return _emptyList;\n    return Uint8List.fromList(\n        Uint8List.view(_buffer.buffer, _buffer.offsetInBytes, _length));\n  }\n\n  int get length => _length;\n\n  bool get isEmpty => _length == 0;\n\n  bool get isNotEmpty => _length != 0;\n\n  void clear() {\n    _length = 0;\n    _buffer = _emptyList;\n  }\n\n  static int _pow2roundup(int x) {\n    assert(x > 0);\n    --x;\n    x |= x >> 1;\n    x |= x >> 2;\n    x |= x >> 4;\n    x |= x >> 8;\n    x |= x >> 16;\n    return x + 1;\n  }\n}\n\nconst int _OUTGOING_BUFFER_SIZE = 8 * 1024;\n\ntypedef _BytesConsumer = void Function(List<int> bytes);\n\nclass _HttpIncoming extends Stream<Uint8List> {\n  final int _transferLength;\n  final _dataCompleter = Completer<bool>();\n  final Stream<Uint8List> _stream;\n\n  bool fullBodyRead = false;\n\n  // Common properties.\n  final _HttpHeaders headers;\n  bool upgraded = false;\n\n  // ClientResponse properties.\n  int? statusCode;\n  String? reasonPhrase;\n\n  // Request properties.\n  String? method;\n  Uri? uri;\n\n  bool hasSubscriber = false;\n\n  // The transfer length if the length of the message body as it\n  // appears in the message (RFC 2616 section 4.4). This can be -1 if\n  // the length of the massage body is not known due to transfer\n  // codings.\n  int get transferLength => _transferLength;\n\n  _HttpIncoming(this.headers, this._transferLength, this._stream);\n\n  StreamSubscription<Uint8List> listen(void Function(Uint8List event)? onData,\n      {Function? onError, void Function()? onDone, bool? cancelOnError}) {\n    hasSubscriber = true;\n    return _stream.handleError((error) {\n      throw HttpException(error.message, uri: uri);\n    }).listen(onData,\n        onError: onError, onDone: onDone, cancelOnError: cancelOnError);\n  }\n\n  // Is completed once all data have been received.\n  Future<bool> get dataDone => _dataCompleter.future;\n\n  void close(bool closing) {\n    fullBodyRead = true;\n    hasSubscriber = true;\n    _dataCompleter.complete(closing);\n  }\n}\n\nabstract class _HttpInboundMessageListInt extends Stream<List<int>> {\n  final _HttpIncoming _incoming;\n  List<Cookie>? _cookies;\n\n  _HttpInboundMessageListInt(this._incoming);\n\n  List<Cookie> get cookies => _cookies ??= headers._parseCookies();\n\n  _HttpHeaders get headers => _incoming.headers;\n  String get protocolVersion => headers.protocolVersion;\n  int get contentLength => headers.contentLength;\n  bool get persistentConnection => headers.persistentConnection;\n}\n\nabstract class _HttpInboundMessage extends Stream<Uint8List> {\n  final _HttpIncoming _incoming;\n  List<Cookie>? _cookies;\n\n  _HttpInboundMessage(this._incoming);\n\n  List<Cookie> get cookies => _cookies ??= headers._parseCookies();\n\n  _HttpHeaders get headers => _incoming.headers;\n  String get protocolVersion => headers.protocolVersion;\n  int get contentLength => headers.contentLength;\n  bool get persistentConnection => headers.persistentConnection;\n}\n\nclass _HttpRequest extends _HttpInboundMessage implements HttpRequest {\n  final HttpResponse response;\n\n  final _HttpServer _httpServer;\n\n  final _HttpConnection _httpConnection;\n\n  _HttpSession? _session;\n\n  Uri? _requestedUri;\n\n  _HttpRequest(this.response, _HttpIncoming _incoming, this._httpServer,\n      this._httpConnection)\n      : super(_incoming) {\n    if (headers.protocolVersion == \"1.1\") {\n      response.headers\n        ..chunkedTransferEncoding = true\n        ..persistentConnection = headers.persistentConnection;\n    }\n\n    if (_httpServer._sessionManagerInstance != null) {\n      // Map to session if exists.\n      var sessionIds = cookies\n          .where((cookie) => cookie.name.toUpperCase() == _DART_SESSION_ID)\n          .map<String>((cookie) => cookie.value);\n      for (var sessionId in sessionIds) {\n        var session = _httpServer._sessionManager.getSession(sessionId);\n        _session = session;\n        if (session != null) {\n          session._markSeen();\n          break;\n        }\n      }\n    }\n  }\n\n  StreamSubscription<Uint8List> listen(void Function(Uint8List event)? onData,\n      {Function? onError, void Function()? onDone, bool? cancelOnError}) {\n    return _incoming.listen(onData,\n        onError: onError, onDone: onDone, cancelOnError: cancelOnError);\n  }\n\n  Uri get uri => _incoming.uri!;\n\n  Uri get requestedUri {\n    var requestedUri = _requestedUri;\n    if (requestedUri != null) return requestedUri;\n    var proto = headers['x-forwarded-proto'];\n    var scheme = proto != null\n        ? proto.first\n        : _httpConnection._socket is SecureSocket\n            ? \"https\"\n            : \"http\";\n    var hostList = headers['x-forwarded-host'];\n    String host;\n    if (hostList != null) {\n      host = hostList.first;\n    } else {\n      hostList = headers[HttpHeaders.hostHeader];\n      if (hostList != null) {\n        host = hostList.first;\n      } else {\n        host = \"${_httpServer.address.host}:${_httpServer.port}\";\n      }\n    }\n    return _requestedUri = Uri.parse(\"$scheme://$host$uri\");\n  }\n\n  String get method => _incoming.method!;\n\n  HttpSession get session {\n    var session = _session;\n    if (session != null && !session._destroyed) {\n      return session;\n    }\n    // Create session, store it in connection, and return.\n    return _session = _httpServer._sessionManager.createSession();\n  }\n\n  HttpConnectionInfo? get connectionInfo => _httpConnection.connectionInfo;\n\n  X509Certificate? get certificate {\n    var socket = _httpConnection._socket;\n    if (socket is SecureSocket) return socket.peerCertificate;\n    return null;\n  }\n}\n\nclass _HttpClientResponse extends _HttpInboundMessageListInt\n    implements HttpClientResponse {\n  List<RedirectInfo> get redirects => _httpRequest._responseRedirects;\n\n  // The HttpClient this response belongs to.\n  final _HttpClient _httpClient;\n\n  // The HttpClientRequest of this response.\n  final _HttpClientRequest _httpRequest;\n\n  // The compression state of this response.\n  final HttpClientResponseCompressionState compressionState;\n\n  final _HttpProfileData? _profileData;\n\n  _HttpClientResponse(_HttpIncoming _incoming, this._httpRequest,\n      this._httpClient, this._profileData)\n      : compressionState = _getCompressionState(_httpClient, _incoming.headers),\n        super(_incoming) {\n    // Set uri for potential exceptions.\n    _incoming.uri = _httpRequest.uri;\n  }\n\n  static HttpClientResponseCompressionState _getCompressionState(\n      _HttpClient httpClient, _HttpHeaders headers) {\n    if (headers.value(HttpHeaders.contentEncodingHeader) == \"gzip\") {\n      return httpClient.autoUncompress\n          ? HttpClientResponseCompressionState.decompressed\n          : HttpClientResponseCompressionState.compressed;\n    } else {\n      return HttpClientResponseCompressionState.notCompressed;\n    }\n  }\n\n  int get statusCode => _incoming.statusCode!;\n  String get reasonPhrase => _incoming.reasonPhrase!;\n\n  X509Certificate? get certificate {\n    var socket = _httpRequest._httpClientConnection._socket;\n    if (socket is SecureSocket) return socket.peerCertificate;\n    return null;\n  }\n\n  List<Cookie> get cookies {\n    var cookies = _cookies;\n    if (cookies != null) return cookies;\n    cookies = <Cookie>[];\n    List<String>? values = headers[HttpHeaders.setCookieHeader];\n    if (values != null) {\n      for (var value in values) {\n        cookies.add(Cookie.fromSetCookieValue(value));\n      }\n    }\n    _cookies = cookies;\n    return cookies;\n  }\n\n  bool get isRedirect {\n    if (_httpRequest.method == \"GET\" || _httpRequest.method == \"HEAD\") {\n      return statusCode == HttpStatus.movedPermanently ||\n          statusCode == HttpStatus.permanentRedirect ||\n          statusCode == HttpStatus.found ||\n          statusCode == HttpStatus.seeOther ||\n          statusCode == HttpStatus.temporaryRedirect;\n    } else if (_httpRequest.method == \"POST\") {\n      return statusCode == HttpStatus.seeOther;\n    }\n    return false;\n  }\n\n  Future<HttpClientResponse> redirect(\n      [String? method, Uri? url, bool? followLoops]) {\n    if (method == null) {\n      // Set method as defined by RFC 2616 section 10.3.4.\n      if (statusCode == HttpStatus.seeOther && _httpRequest.method == \"POST\") {\n        method = \"GET\";\n      } else {\n        method = _httpRequest.method;\n      }\n    }\n    if (url == null) {\n      String? location = headers.value(HttpHeaders.locationHeader);\n      if (location == null) {\n        throw StateError(\"Response has no Location header for redirect\");\n      }\n      url = Uri.parse(location);\n    }\n    if (followLoops != true) {\n      for (var redirect in redirects) {\n        if (redirect.location == url) {\n          return Future.error(\n              RedirectException(\"Redirect loop detected\", redirects));\n        }\n      }\n    }\n    return _httpClient\n        ._openUrlFromRequest(method, url, _httpRequest)\n        .then((request) {\n      request._responseRedirects\n        ..addAll(redirects)\n        ..add(_RedirectInfo(statusCode, method!, url!));\n      return request.close();\n    });\n  }\n\n  StreamSubscription<Uint8List> listen(void Function(Uint8List event)? onData,\n      {Function? onError, void Function()? onDone, bool? cancelOnError}) {\n    if (_incoming.upgraded) {\n      _profileData?.finishResponseWithError('Connection was upgraded');\n      // If upgraded, the connection is already 'removed' form the client.\n      // Since listening to upgraded data is 'bogus', simply close and\n      // return empty stream subscription.\n      _httpRequest._httpClientConnection.destroy();\n      return Stream<Uint8List>.empty().listen(null, onDone: onDone);\n    }\n    Stream<Uint8List> stream = _incoming;\n    if (compressionState == HttpClientResponseCompressionState.decompressed) {\n      stream = stream\n          .cast<List<int>>()\n          .transform(gzip.decoder)\n          .transform(const _ToUint8List());\n    }\n    if (_profileData != null) {\n      // If _timeline is not set up, don't add unnecessary map() to the stream.\n      stream = stream.map((data) {\n        _profileData?.appendResponseData(data);\n        return data;\n      });\n    }\n    return stream.listen(onData, onError: (e, st) {\n      _profileData?.finishResponseWithError(e.toString());\n      if (onError == null) {\n        return;\n      }\n      if (onError is void Function(Object, StackTrace)) {\n        onError(e, st);\n      } else {\n        assert(onError is void Function(Object));\n        onError(e);\n      }\n    }, onDone: () {\n      _profileData?.finishResponse();\n      if (onDone != null) {\n        onDone();\n      }\n    }, cancelOnError: cancelOnError);\n  }\n\n  Future<Socket> detachSocket() {\n    _profileData?.finishResponseWithError('Socket has been detached');\n    _httpClient._connectionClosed(_httpRequest._httpClientConnection);\n    return _httpRequest._httpClientConnection.detachSocket();\n  }\n\n  HttpConnectionInfo? get connectionInfo => _httpRequest.connectionInfo;\n\n  bool get _shouldAuthenticateProxy {\n    // Only try to authenticate if there is a challenge in the response.\n    List<String>? challenge = headers[HttpHeaders.proxyAuthenticateHeader];\n    return statusCode == HttpStatus.proxyAuthenticationRequired &&\n        challenge != null &&\n        challenge.length == 1;\n  }\n\n  bool get _shouldAuthenticate {\n    // Only try to authenticate if there is a challenge in the response.\n    List<String>? challenge = headers[HttpHeaders.wwwAuthenticateHeader];\n    return statusCode == HttpStatus.unauthorized &&\n        challenge != null &&\n        challenge.length == 1;\n  }\n\n  Future<HttpClientResponse> _authenticate(bool proxyAuth) {\n    _httpRequest._profileData?.requestEvent('Authentication');\n    Future<HttpClientResponse> retry() {\n      _httpRequest._profileData?.requestEvent('Retrying');\n      // Drain body and retry.\n      return drain().then((_) {\n        return _httpClient\n            ._openUrlFromRequest(\n                _httpRequest.method, _httpRequest.uri, _httpRequest)\n            .then((request) => request.close());\n      });\n    }\n\n    List<String>? authChallenge() {\n      return proxyAuth\n          ? headers[HttpHeaders.proxyAuthenticateHeader]\n          : headers[HttpHeaders.wwwAuthenticateHeader];\n    }\n\n    _Credentials? findCredentials(_AuthenticationScheme scheme) {\n      return proxyAuth\n          ? _httpClient._findProxyCredentials(_httpRequest._proxy, scheme)\n          : _httpClient._findCredentials(_httpRequest.uri, scheme);\n    }\n\n    void removeCredentials(_Credentials cr) {\n      if (proxyAuth) {\n        _httpClient._removeProxyCredentials(cr);\n      } else {\n        _httpClient._removeCredentials(cr);\n      }\n    }\n\n    Future<bool> requestAuthentication(\n        _AuthenticationScheme scheme, String? realm) {\n      if (proxyAuth) {\n        var authenticateProxy = _httpClient._authenticateProxy;\n        if (authenticateProxy == null) {\n          return Future.value(false);\n        }\n        var proxy = _httpRequest._proxy;\n        if (!proxy.isDirect) {\n          return authenticateProxy(\n              proxy.host!, proxy.port!, scheme.toString(), realm);\n        }\n      }\n      var authenticate = _httpClient._authenticate;\n      if (authenticate == null) {\n        return Future.value(false);\n      }\n      return authenticate(_httpRequest.uri, scheme.toString(), realm);\n    }\n\n    List<String> challenge = authChallenge()!;\n    assert(challenge.length == 1);\n    _HeaderValue header =\n        _HeaderValue.parse(challenge[0], parameterSeparator: \",\");\n    _AuthenticationScheme scheme =\n        _AuthenticationScheme.fromString(header.value);\n    String? realm = header.parameters[\"realm\"];\n\n    // See if any matching credentials are available.\n    var cr = findCredentials(scheme);\n    if (cr != null) {\n      // For basic authentication don't retry already used credentials\n      // as they must have already been added to the request causing\n      // this authenticate response.\n      if (cr.scheme == _AuthenticationScheme.BASIC && !cr.used) {\n        // Credentials were found, prepare for retrying the request.\n        return retry();\n      }\n\n      // Digest authentication only supports the MD5 algorithm.\n      if (cr.scheme == _AuthenticationScheme.DIGEST) {\n        var algorithm = header.parameters[\"algorithm\"];\n        if (algorithm == null || algorithm.toLowerCase() == \"md5\") {\n          var nonce = cr.nonce;\n          if (nonce == null || nonce == header.parameters[\"nonce\"]) {\n            // If the nonce is not set then this is the first authenticate\n            // response for these credentials. Set up authentication state.\n            if (nonce == null) {\n              cr\n                ..nonce = header.parameters[\"nonce\"]\n                ..algorithm = \"MD5\"\n                ..qop = header.parameters[\"qop\"]\n                ..nonceCount = 0;\n            }\n            // Credentials were found, prepare for retrying the request.\n            return retry();\n          } else {\n            var staleHeader = header.parameters[\"stale\"];\n            if (staleHeader != null && staleHeader.toLowerCase() == \"true\") {\n              // If stale is true retry with new nonce.\n              cr.nonce = header.parameters[\"nonce\"];\n              // Credentials were found, prepare for retrying the request.\n              return retry();\n            }\n          }\n        }\n      }\n    }\n\n    // Ask for more credentials if none found or the one found has\n    // already been used. If it has already been used it must now be\n    // invalid and is removed.\n    if (cr != null) {\n      removeCredentials(cr);\n      cr = null;\n    }\n    return requestAuthentication(scheme, realm).then((credsAvailable) {\n      if (credsAvailable) {\n        cr = _httpClient._findCredentials(_httpRequest.uri, scheme);\n        return retry();\n      } else {\n        // No credentials available, complete with original response.\n        return this;\n      }\n    });\n  }\n}\n\nclass _ToUint8List extends Converter<List<int>, Uint8List> {\n  const _ToUint8List();\n\n  Uint8List convert(List<int> input) => Uint8List.fromList(input);\n\n  Sink<List<int>> startChunkedConversion(Sink<Uint8List> sink) {\n    return _Uint8ListConversionSink(sink);\n  }\n}\n\nclass _Uint8ListConversionSink implements Sink<List<int>> {\n  const _Uint8ListConversionSink(this._target);\n\n  final Sink<Uint8List> _target;\n\n  void add(List<int> data) {\n    _target.add(Uint8List.fromList(data));\n  }\n\n  void close() {\n    _target.close();\n  }\n}\n\nclass _StreamSinkImpl<T> implements StreamSink<T> {\n  final StreamConsumer<T> _target;\n  final _doneCompleter = Completer<void>();\n  StreamController<T>? _controllerInstance;\n  Completer? _controllerCompleter;\n  bool _isClosed = false;\n  bool _isBound = false;\n  bool _hasError = false;\n\n  _StreamSinkImpl(this._target);\n\n  void add(T data) {\n    if (_isClosed) {\n      throw StateError(\"StreamSink is closed\");\n    }\n    _controller.add(data);\n  }\n\n  void addError(Object error, [StackTrace? stackTrace]) {\n    if (_isClosed) {\n      throw StateError(\"StreamSink is closed\");\n    }\n    _controller.addError(error, stackTrace);\n  }\n\n  Future addStream(Stream<T> stream) {\n    if (_isBound) {\n      throw StateError(\"StreamSink is already bound to a stream\");\n    }\n    _isBound = true;\n    if (_hasError) return done;\n    // Wait for any sync operations to complete.\n    Future targetAddStream() {\n      return _target.addStream(stream).whenComplete(() {\n        _isBound = false;\n      });\n    }\n\n    var controller = _controllerInstance;\n    if (controller == null) return targetAddStream();\n    var future = _controllerCompleter!.future;\n    controller.close();\n    return future.then((_) => targetAddStream());\n  }\n\n  Future flush() {\n    if (_isBound) {\n      throw StateError(\"StreamSink is bound to a stream\");\n    }\n    var controller = _controllerInstance;\n    if (controller == null) return Future.value(this);\n    // Adding an empty stream-controller will return a future that will complete\n    // when all data is done.\n    _isBound = true;\n    var future = _controllerCompleter!.future;\n    controller.close();\n    return future.whenComplete(() {\n      _isBound = false;\n    });\n  }\n\n  Future close() {\n    if (_isBound) {\n      throw StateError(\"StreamSink is bound to a stream\");\n    }\n    if (!_isClosed) {\n      _isClosed = true;\n      var controller = _controllerInstance;\n      if (controller != null) {\n        controller.close();\n      } else {\n        _closeTarget();\n      }\n    }\n    return done;\n  }\n\n  void _closeTarget() {\n    _target.close().then(_completeDoneValue, onError: _completeDoneError);\n  }\n\n  Future get done => _doneCompleter.future;\n\n  void _completeDoneValue(value) {\n    if (!_doneCompleter.isCompleted) {\n      _doneCompleter.complete(value);\n    }\n  }\n\n  void _completeDoneError(Object error, StackTrace stackTrace) {\n    if (!_doneCompleter.isCompleted) {\n      _hasError = true;\n      _doneCompleter.completeError(error, stackTrace);\n    }\n  }\n\n  StreamController<T> get _controller {\n    if (_isBound) {\n      throw StateError(\"StreamSink is bound to a stream\");\n    }\n    if (_isClosed) {\n      throw StateError(\"StreamSink is closed\");\n    }\n    if (_controllerInstance == null) {\n      _controllerInstance = StreamController<T>(sync: true);\n      _controllerCompleter = Completer();\n      _target.addStream(_controller.stream).then((_) {\n        if (_isBound) {\n          // A new stream takes over - forward values to that stream.\n          _controllerCompleter!.complete(this);\n          _controllerCompleter = null;\n          _controllerInstance = null;\n        } else {\n          // No new stream, .close was called. Close _target.\n          _closeTarget();\n        }\n      }, onError: (Object error, StackTrace stackTrace) {\n        if (_isBound) {\n          // A new stream takes over - forward errors to that stream.\n          _controllerCompleter!.completeError(error, stackTrace);\n          _controllerCompleter = null;\n          _controllerInstance = null;\n        } else {\n          // No new stream. No need to close target, as it has already\n          // failed.\n          _completeDoneError(error, stackTrace);\n        }\n      });\n    }\n    return _controllerInstance!;\n  }\n}\n\nclass _IOSinkImpl extends _StreamSinkImpl<List<int>> implements IOSink {\n  Encoding _encoding;\n  bool _encodingMutable = true;\n\n  final _HttpProfileData? _profileData;\n  _IOSinkImpl(\n      StreamConsumer<List<int>> target, this._encoding, this._profileData)\n      : super(target);\n\n  Encoding get encoding => _encoding;\n\n  void set encoding(Encoding value) {\n    if (!_encodingMutable) {\n      throw StateError(\"IOSink encoding is not mutable\");\n    }\n    _encoding = value;\n  }\n\n  void write(Object? obj) {\n    String string = '$obj';\n    if (string.isEmpty) return;\n    _profileData?.appendRequestData(\n      Uint8List.fromList(\n        utf8.encode(string),\n      ),\n    );\n    super.add(_encoding.encode(string));\n  }\n\n  void writeAll(Iterable objects, [String separator = \"\"]) {\n    Iterator iterator = objects.iterator;\n    if (!iterator.moveNext()) return;\n    if (separator.isEmpty) {\n      do {\n        write(iterator.current);\n      } while (iterator.moveNext());\n    } else {\n      write(iterator.current);\n      while (iterator.moveNext()) {\n        write(separator);\n        write(iterator.current);\n      }\n    }\n  }\n\n  void writeln([Object? object = \"\"]) {\n    write(object);\n    write(\"\\n\");\n  }\n\n  void writeCharCode(int charCode) {\n    write(String.fromCharCode(charCode));\n  }\n}\n\nabstract class _HttpOutboundMessage<T> extends _IOSinkImpl {\n  // Used to mark when the body should be written. This is used for HEAD\n  // requests and in error handling.\n  bool _encodingSet = false;\n\n  bool _bufferOutput = true;\n\n  final Uri _uri;\n  final _HttpOutgoing _outgoing;\n\n  final _HttpHeaders headers;\n\n  _HttpOutboundMessage(Uri uri, String protocolVersion, _HttpOutgoing outgoing,\n      _HttpProfileData? profileData,\n      {_HttpHeaders? initialHeaders})\n      : _uri = uri,\n        headers = _HttpHeaders(protocolVersion,\n            defaultPortForScheme: uri.scheme == 'https'\n                ? HttpClient.defaultHttpsPort\n                : HttpClient.defaultHttpPort,\n            initialHeaders: initialHeaders),\n        _outgoing = outgoing,\n        super(outgoing, latin1, profileData) {\n    _outgoing.outbound = this;\n    _encodingMutable = false;\n  }\n\n  int get contentLength => headers.contentLength;\n  void set contentLength(int contentLength) {\n    headers.contentLength = contentLength;\n  }\n\n  bool get persistentConnection => headers.persistentConnection;\n  void set persistentConnection(bool p) {\n    headers.persistentConnection = p;\n  }\n\n  bool get bufferOutput => _bufferOutput;\n  void set bufferOutput(bool bufferOutput) {\n    if (_outgoing.headersWritten) throw StateError(\"Header already sent\");\n    _bufferOutput = bufferOutput;\n  }\n\n  Encoding get encoding {\n    if (_encodingSet && _outgoing.headersWritten) {\n      return _encoding;\n    }\n    String charset;\n    var contentType = headers.contentType;\n    if (contentType != null && contentType.charset != null) {\n      charset = contentType.charset!;\n    } else {\n      charset = \"iso-8859-1\";\n    }\n    return Encoding.getByName(charset) ?? latin1;\n  }\n\n  void add(List<int> data) {\n    if (data.isEmpty) return;\n    _profileData?.appendRequestData(Uint8List.fromList(data));\n    super.add(data);\n  }\n\n  Future addStream(Stream<List<int>> s) {\n    if (_profileData == null) {\n      return super.addStream(s);\n    }\n    return super.addStream(s.map((data) {\n      _profileData?.appendRequestData(Uint8List.fromList(data));\n      return data;\n    }));\n  }\n\n  void write(Object? obj) {\n    if (!_encodingSet) {\n      _encoding = encoding;\n      _encodingSet = true;\n    }\n    super.write(obj);\n  }\n\n  void _writeHeader();\n\n  bool get _isConnectionClosed => false;\n}\n\nclass _HttpResponse extends _HttpOutboundMessage<HttpResponse>\n    implements HttpResponse {\n  int _statusCode = 200;\n  String? _reasonPhrase;\n  List<Cookie>? _cookies;\n  _HttpRequest? _httpRequest;\n  Duration? _deadline;\n  Timer? _deadlineTimer;\n\n  _HttpResponse(Uri uri, String protocolVersion, _HttpOutgoing outgoing,\n      HttpHeaders defaultHeaders, String? serverHeader)\n      : super(uri, protocolVersion, outgoing, null,\n            initialHeaders: defaultHeaders as _HttpHeaders) {\n    if (serverHeader != null) {\n      headers.set(HttpHeaders.serverHeader, serverHeader);\n    }\n  }\n\n  bool get _isConnectionClosed => _httpRequest!._httpConnection._isClosing;\n\n  List<Cookie> get cookies => _cookies ??= <Cookie>[];\n\n  int get statusCode => _statusCode;\n  void set statusCode(int statusCode) {\n    if (_outgoing.headersWritten) throw StateError(\"Header already sent\");\n    _statusCode = statusCode;\n  }\n\n  String get reasonPhrase => _findReasonPhrase(statusCode);\n  void set reasonPhrase(String reasonPhrase) {\n    if (_outgoing.headersWritten) throw StateError(\"Header already sent\");\n    _reasonPhrase = reasonPhrase;\n  }\n\n  Future redirect(Uri location, {int status = HttpStatus.movedTemporarily}) {\n    if (_outgoing.headersWritten) throw StateError(\"Header already sent\");\n    statusCode = status;\n    headers.set(HttpHeaders.locationHeader, location.toString());\n    return close();\n  }\n\n  Future<Socket> detachSocket({bool writeHeaders = true}) {\n    if (_outgoing.headersWritten) throw StateError(\"Headers already sent\");\n    deadline = null; // Be sure to stop any deadline.\n    var future = _httpRequest!._httpConnection.detachSocket();\n    if (writeHeaders) {\n      var headersFuture =\n          _outgoing.writeHeaders(drainRequest: false, setOutgoing: false);\n      assert(headersFuture == null);\n    } else {\n      // Imitate having written the headers.\n      _outgoing.headersWritten = true;\n    }\n    // Close connection so the socket is 'free'.\n    close();\n    done.catchError((_) {\n      // Catch any error on done, as they automatically will be\n      // propagated to the websocket.\n    });\n    return future;\n  }\n\n  HttpConnectionInfo? get connectionInfo => _httpRequest!.connectionInfo;\n\n  Duration? get deadline => _deadline;\n\n  void set deadline(Duration? d) {\n    _deadlineTimer?.cancel();\n    _deadline = d;\n\n    if (d == null) return;\n    _deadlineTimer = Timer(d, () {\n      _httpRequest!._httpConnection.destroy();\n    });\n  }\n\n  void _writeHeader() {\n    BytesBuilder buffer = _CopyingBytesBuilder(_OUTGOING_BUFFER_SIZE);\n\n    // Write status line.\n    if (headers.protocolVersion == \"1.1\") {\n      buffer.add(_Const.HTTP11);\n    } else {\n      buffer.add(_Const.HTTP10);\n    }\n    buffer.addByte(_CharCode.SP);\n    buffer.add(statusCode.toString().codeUnits);\n    buffer.addByte(_CharCode.SP);\n    buffer.add(reasonPhrase.codeUnits);\n    buffer.addByte(_CharCode.CR);\n    buffer.addByte(_CharCode.LF);\n\n    var session = _httpRequest!._session;\n    if (session != null && !session._destroyed) {\n      // Mark as not new.\n      session._isNew = false;\n      // Make sure we only send the current session id.\n      bool found = false;\n      for (int i = 0; i < cookies.length; i++) {\n        if (cookies[i].name.toUpperCase() == _DART_SESSION_ID) {\n          cookies[i]\n            ..value = session.id\n            ..httpOnly = true\n            ..path = \"/\";\n          found = true;\n        }\n      }\n      if (!found) {\n        var cookie = Cookie(_DART_SESSION_ID, session.id);\n        cookies.add(cookie\n          ..httpOnly = true\n          ..path = \"/\");\n      }\n    }\n    // Add all the cookies set to the headers.\n    _cookies?.forEach((cookie) {\n      headers.add(HttpHeaders.setCookieHeader, cookie);\n    });\n\n    headers._finalize();\n\n    // Write headers.\n    headers._build(buffer);\n    buffer.addByte(_CharCode.CR);\n    buffer.addByte(_CharCode.LF);\n    Uint8List headerBytes = buffer.takeBytes();\n    _outgoing.setHeader(headerBytes, headerBytes.length);\n  }\n\n  String _findReasonPhrase(int statusCode) {\n    var reasonPhrase = _reasonPhrase;\n    if (reasonPhrase != null) {\n      return reasonPhrase;\n    }\n\n    switch (statusCode) {\n      case HttpStatus.continue_:\n        return \"Continue\";\n      case HttpStatus.switchingProtocols:\n        return \"Switching Protocols\";\n      case HttpStatus.ok:\n        return \"OK\";\n      case HttpStatus.created:\n        return \"Created\";\n      case HttpStatus.accepted:\n        return \"Accepted\";\n      case HttpStatus.nonAuthoritativeInformation:\n        return \"Non-Authoritative Information\";\n      case HttpStatus.noContent:\n        return \"No Content\";\n      case HttpStatus.resetContent:\n        return \"Reset Content\";\n      case HttpStatus.partialContent:\n        return \"Partial Content\";\n      case HttpStatus.multipleChoices:\n        return \"Multiple Choices\";\n      case HttpStatus.movedPermanently:\n        return \"Moved Permanently\";\n      case HttpStatus.found:\n        return \"Found\";\n      case HttpStatus.seeOther:\n        return \"See Other\";\n      case HttpStatus.notModified:\n        return \"Not Modified\";\n      case HttpStatus.useProxy:\n        return \"Use Proxy\";\n      case HttpStatus.temporaryRedirect:\n        return \"Temporary Redirect\";\n      case HttpStatus.badRequest:\n        return \"Bad Request\";\n      case HttpStatus.unauthorized:\n        return \"Unauthorized\";\n      case HttpStatus.paymentRequired:\n        return \"Payment Required\";\n      case HttpStatus.forbidden:\n        return \"Forbidden\";\n      case HttpStatus.notFound:\n        return \"Not Found\";\n      case HttpStatus.methodNotAllowed:\n        return \"Method Not Allowed\";\n      case HttpStatus.notAcceptable:\n        return \"Not Acceptable\";\n      case HttpStatus.proxyAuthenticationRequired:\n        return \"Proxy Authentication Required\";\n      case HttpStatus.requestTimeout:\n        return \"Request Time-out\";\n      case HttpStatus.conflict:\n        return \"Conflict\";\n      case HttpStatus.gone:\n        return \"Gone\";\n      case HttpStatus.lengthRequired:\n        return \"Length Required\";\n      case HttpStatus.preconditionFailed:\n        return \"Precondition Failed\";\n      case HttpStatus.requestEntityTooLarge:\n        return \"Request Entity Too Large\";\n      case HttpStatus.requestUriTooLong:\n        return \"Request-URI Too Long\";\n      case HttpStatus.unsupportedMediaType:\n        return \"Unsupported Media Type\";\n      case HttpStatus.requestedRangeNotSatisfiable:\n        return \"Requested range not satisfiable\";\n      case HttpStatus.expectationFailed:\n        return \"Expectation Failed\";\n      case HttpStatus.internalServerError:\n        return \"Internal Server Error\";\n      case HttpStatus.notImplemented:\n        return \"Not Implemented\";\n      case HttpStatus.badGateway:\n        return \"Bad Gateway\";\n      case HttpStatus.serviceUnavailable:\n        return \"Service Unavailable\";\n      case HttpStatus.gatewayTimeout:\n        return \"Gateway Time-out\";\n      case HttpStatus.httpVersionNotSupported:\n        return \"Http Version not supported\";\n      default:\n        return \"Status $statusCode\";\n    }\n  }\n}\n\nclass _HttpClientRequest extends _HttpOutboundMessage<HttpClientResponse>\n    implements HttpClientRequest {\n  final String method;\n  final Uri uri;\n  final List<Cookie> cookies = [];\n\n  // The HttpClient this request belongs to.\n  final _HttpClient _httpClient;\n  final _HttpClientConnection _httpClientConnection;\n\n  final Completer<HttpClientResponse> _responseCompleter =\n      Completer<HttpClientResponse>();\n\n  final _Proxy _proxy;\n\n  Future<HttpClientResponse>? _response;\n\n  // TODO(ajohnsen): Get default value from client?\n  bool _followRedirects = true;\n\n  int _maxRedirects = 5;\n\n  final List<RedirectInfo> _responseRedirects = [];\n\n  bool _aborted = false;\n\n  _HttpClientRequest(\n    _HttpOutgoing outgoing,\n    this.uri,\n    this.method,\n    this._proxy,\n    this._httpClient,\n    this._httpClientConnection,\n    _HttpProfileData? _profileData,\n  ) : super(uri, \"1.1\", outgoing, _profileData) {\n    _profileData?.requestEvent('Request sent');\n    // GET and HEAD have 'content-length: 0' by default.\n    if (method == \"GET\" || method == \"HEAD\") {\n      contentLength = 0;\n    } else {\n      headers.chunkedTransferEncoding = true;\n    }\n\n    _responseCompleter.future.then((response) {\n      _profileData?.requestEvent('Waiting (TTFB)');\n      _profileData?.startResponse(\n        // TODO(bkonyi): consider exposing certificate information?\n        // 'certificate': response.certificate,\n        response: response,\n      );\n    }, onError: (e) {});\n  }\n\n  Future<HttpClientResponse> get done => _response ??=\n      Future.wait([_responseCompleter.future, super.done], eagerError: true)\n          .then((list) => list[0]);\n\n  Future<HttpClientResponse> close() {\n    if (!_aborted) {\n      // It will send out the request.\n      super.close();\n    }\n    return done;\n  }\n\n  int get maxRedirects => _maxRedirects;\n  void set maxRedirects(int maxRedirects) {\n    if (_outgoing.headersWritten) throw StateError(\"Request already sent\");\n    _maxRedirects = maxRedirects;\n  }\n\n  bool get followRedirects => _followRedirects;\n  void set followRedirects(bool followRedirects) {\n    if (_outgoing.headersWritten) throw StateError(\"Request already sent\");\n    _followRedirects = followRedirects;\n  }\n\n  HttpConnectionInfo? get connectionInfo =>\n      _httpClientConnection.connectionInfo;\n\n  void _onIncoming(_HttpIncoming incoming) {\n    if (_aborted) {\n      return;\n    }\n    final response =\n        _HttpClientResponse(incoming, this, _httpClient, _profileData);\n    Future<HttpClientResponse> future;\n    if (followRedirects && response.isRedirect) {\n      if (response.redirects.length < maxRedirects) {\n        // Redirect and drain response.\n        future = response\n            .drain()\n            .then<HttpClientResponse>((_) => response.redirect());\n      } else {\n        // End with exception, too many redirects.\n        future = response.drain().then<HttpClientResponse>((_) {\n          return Future<HttpClientResponse>.error(\n              RedirectException(\"Redirect limit exceeded\", response.redirects));\n        });\n      }\n    } else if (response._shouldAuthenticateProxy) {\n      future = response._authenticate(true);\n    } else if (response._shouldAuthenticate) {\n      future = response._authenticate(false);\n    } else {\n      future = Future<HttpClientResponse>.value(response);\n    }\n    future.then((v) {\n      if (!_responseCompleter.isCompleted) {\n        _responseCompleter.complete(v);\n      }\n    }, onError: (e, s) {\n      if (!_responseCompleter.isCompleted) {\n        _responseCompleter.completeError(e, s);\n      }\n    });\n  }\n\n  void _onError(error, StackTrace stackTrace) {\n    if (!_responseCompleter.isCompleted) {\n      _responseCompleter.completeError(error, stackTrace);\n    }\n  }\n\n  // Generate the request URI based on the method and proxy.\n  String _requestUri() {\n    // Generate the request URI starting from the path component.\n    String uriStartingFromPath() {\n      String result = uri.path;\n      if (result.isEmpty) result = \"/\";\n      if (uri.hasQuery) {\n        result = \"$result?${uri.query}\";\n      }\n      return result;\n    }\n\n    if (_proxy.isDirect) {\n      return uriStartingFromPath();\n    } else {\n      if (method == \"CONNECT\") {\n        // For the connect method the request URI is the host:port of\n        // the requested destination of the tunnel (see RFC 2817\n        // section 5.2)\n        return \"${uri.host}:${uri.port}\";\n      } else {\n        if (_httpClientConnection._proxyTunnel) {\n          return uriStartingFromPath();\n        } else {\n          return uri.removeFragment().toString();\n        }\n      }\n    }\n  }\n\n  void add(List<int> data) {\n    if (data.isEmpty || _aborted) return;\n    super.add(data);\n  }\n\n  void write(Object? obj) {\n    if (_aborted) return;\n    super.write(obj);\n  }\n\n  void _writeHeader() {\n    if (_aborted) {\n      _outgoing.setHeader(Uint8List(0), 0);\n      return;\n    }\n    BytesBuilder buffer = _CopyingBytesBuilder(_OUTGOING_BUFFER_SIZE);\n\n    // Write the request method.\n    buffer.add(method.codeUnits);\n    buffer.addByte(_CharCode.SP);\n    // Write the request URI.\n    buffer.add(_requestUri().codeUnits);\n    buffer.addByte(_CharCode.SP);\n    // Write HTTP/1.1.\n    buffer.add(_Const.HTTP11);\n    buffer.addByte(_CharCode.CR);\n    buffer.addByte(_CharCode.LF);\n\n    // Add the cookies to the headers.\n    if (cookies.isNotEmpty) {\n      StringBuffer sb = StringBuffer();\n      for (int i = 0; i < cookies.length; i++) {\n        if (i > 0) sb.write(\"; \");\n        sb\n          ..write(cookies[i].name)\n          ..write(\"=\")\n          ..write(cookies[i].value);\n      }\n      headers.add(HttpHeaders.cookieHeader, sb.toString());\n    }\n\n    headers._finalize();\n\n    // Write headers.\n    headers._build(buffer,\n        skipZeroContentLength: method == \"CONNECT\" ||\n            method == \"DELETE\" ||\n            method == \"GET\" ||\n            method == \"HEAD\");\n    buffer.addByte(_CharCode.CR);\n    buffer.addByte(_CharCode.LF);\n    Uint8List headerBytes = buffer.takeBytes();\n    _outgoing.setHeader(headerBytes, headerBytes.length);\n  }\n\n  void abort([Object? exception, StackTrace? stackTrace]) {\n    _aborted = true;\n    if (!_responseCompleter.isCompleted) {\n      exception ??= HttpException(\"Request has been aborted\");\n      _responseCompleter.completeError(exception, stackTrace);\n      _httpClientConnection.destroy();\n    }\n  }\n}\n\n// Used by _HttpOutgoing as a target of a chunked converter for gzip\n// compression.\nclass _HttpGZipSink extends ByteConversionSink {\n  final _BytesConsumer _consume;\n  _HttpGZipSink(this._consume);\n\n  void add(List<int> chunk) {\n    _consume(chunk);\n  }\n\n  void addSlice(List<int> chunk, int start, int end, bool isLast) {\n    if (chunk is Uint8List) {\n      _consume(Uint8List.view(\n          chunk.buffer, chunk.offsetInBytes + start, end - start));\n    } else {\n      _consume(chunk.sublist(start, end - start));\n    }\n  }\n\n  void close() {}\n}\n\n// The _HttpOutgoing handles all of the following:\n//  - Buffering\n//  - GZip compression\n//  - Content-Length validation.\n//  - Errors.\n//\n// Most notable is the GZip compression, that uses a double-buffering system,\n// one before gzip (_gzipBuffer) and one after (_buffer).\nclass _HttpOutgoing implements StreamConsumer<List<int>> {\n  static const List<int> _footerAndChunk0Length = [\n    _CharCode.CR,\n    _CharCode.LF,\n    0x30,\n    _CharCode.CR,\n    _CharCode.LF,\n    _CharCode.CR,\n    _CharCode.LF\n  ];\n\n  static const List<int> _chunk0Length = [\n    0x30,\n    _CharCode.CR,\n    _CharCode.LF,\n    _CharCode.CR,\n    _CharCode.LF\n  ];\n\n  final Completer<Socket> _doneCompleter = Completer<Socket>();\n  final Socket socket;\n\n  bool ignoreBody = false;\n  bool headersWritten = false;\n\n  Uint8List? _buffer;\n  int _length = 0;\n\n  Future? _closeFuture;\n\n  bool chunked = false;\n  int _pendingChunkedFooter = 0;\n\n  int? contentLength;\n  int _bytesWritten = 0;\n\n  bool _gzip = false;\n  ByteConversionSink? _gzipSink;\n  // _gzipAdd is set iff the sink is being added to. It's used to specify where\n  // gzipped data should be taken (sometimes a controller, sometimes a socket).\n  _BytesConsumer? _gzipAdd;\n  Uint8List? _gzipBuffer;\n  int _gzipBufferLength = 0;\n\n  bool _socketError = false;\n\n  _HttpOutboundMessage? outbound;\n\n  _HttpOutgoing(this.socket);\n\n  // Returns either a future or 'null', if it was able to write headers\n  // immediately.\n  Future<void>? writeHeaders(\n      {bool drainRequest = true, bool setOutgoing = true}) {\n    if (headersWritten) return null;\n    headersWritten = true;\n    Future<void>? drainFuture;\n    bool gzip = false;\n    var response = outbound!;\n    if (response is _HttpResponse) {\n      // Server side.\n      if (response._httpRequest!._httpServer.autoCompress &&\n          response.bufferOutput &&\n          response.headers.chunkedTransferEncoding) {\n        List<String>? acceptEncodings =\n            response._httpRequest!.headers[HttpHeaders.acceptEncodingHeader];\n        List<String>? contentEncoding =\n            response.headers[HttpHeaders.contentEncodingHeader];\n        if (acceptEncodings != null &&\n            contentEncoding == null &&\n            acceptEncodings\n                .expand((list) => list.split(\",\"))\n                .any((encoding) => encoding.trim().toLowerCase() == \"gzip\")) {\n          response.headers.set(HttpHeaders.contentEncodingHeader, \"gzip\");\n          gzip = true;\n        }\n      }\n      if (drainRequest && !response._httpRequest!._incoming.hasSubscriber) {\n        drainFuture = response._httpRequest!.drain<void>().catchError((_) {});\n      }\n    } else {\n      drainRequest = false;\n    }\n    if (!ignoreBody) {\n      if (setOutgoing) {\n        int contentLength = response.headers.contentLength;\n        if (response.headers.chunkedTransferEncoding) {\n          chunked = true;\n          if (gzip) this.gzip = true;\n        } else if (contentLength >= 0) {\n          this.contentLength = contentLength;\n        }\n      }\n      if (drainFuture != null) {\n        return drainFuture.then((_) => response._writeHeader());\n      }\n    }\n    response._writeHeader();\n    return null;\n  }\n\n  Future addStream(Stream<List<int>> stream) {\n    if (_socketError) {\n      stream.listen(null).cancel();\n      return Future.value(outbound);\n    }\n    if (ignoreBody) {\n      stream.drain().catchError((_) {});\n      var future = writeHeaders();\n      if (future != null) {\n        return future.then((_) => close());\n      }\n      return close();\n    }\n    // Use new stream so we are able to pause (see below listen). The\n    // alternative is to use stream.extand, but that won't give us a way of\n    // pausing.\n    var controller = StreamController<List<int>>(sync: true);\n\n    void onData(List<int> data) {\n      if (_socketError) return;\n      if (data.isEmpty) return;\n      if (chunked) {\n        if (_gzip) {\n          _gzipAdd = controller.add;\n          _addGZipChunk(data, _gzipSink!.add);\n          _gzipAdd = null;\n          return;\n        }\n        _addChunk(_chunkHeader(data.length), controller.add);\n        _pendingChunkedFooter = 2;\n      } else {\n        var contentLength = this.contentLength;\n        if (contentLength != null) {\n          _bytesWritten += data.length;\n          if (_bytesWritten > contentLength) {\n            controller.addError(\n                HttpException(\"Content size exceeds specified contentLength. \"\n                    \"$_bytesWritten bytes written while expected \"\n                    \"$contentLength. \"\n                    \"[${String.fromCharCodes(data)}]\"));\n            return;\n          }\n        }\n      }\n      _addChunk(data, controller.add);\n    }\n\n    var sub = stream.listen(onData,\n        onError: controller.addError,\n        onDone: controller.close,\n        cancelOnError: true);\n    controller.onPause = sub.pause;\n    controller.onResume = sub.resume;\n    // Write headers now that we are listening to the stream.\n    if (!headersWritten) {\n      var future = writeHeaders();\n      if (future != null) {\n        // While incoming is being drained, the pauseFuture is non-null. Pause\n        // output until it's drained.\n        sub.pause(future);\n      }\n    }\n    return socket.addStream(controller.stream).then((_) {\n      return outbound;\n    }, onError: (error, stackTrace) {\n      // Be sure to close it in case of an error.\n      if (_gzip) _gzipSink!.close();\n      _socketError = true;\n      _doneCompleter.completeError(error, stackTrace);\n      if (_ignoreError(error)) {\n        return outbound;\n      } else {\n        throw error;\n      }\n    });\n  }\n\n  Future close() {\n    // If we are already closed, return that future.\n    var closeFuture = _closeFuture;\n    if (closeFuture != null) return closeFuture;\n\n    var outbound = this.outbound!;\n    // If we earlier saw an error, return immediate. The notification to\n    // _Http*Connection is already done.\n    if (_socketError) return Future.value(outbound);\n    if (outbound._isConnectionClosed) return Future.value(outbound);\n    if (!headersWritten && !ignoreBody) {\n      if (outbound.headers.contentLength == -1) {\n        // If no body was written, ignoreBody is false (it's not a HEAD\n        // request) and the content-length is unspecified, set contentLength to\n        // 0.\n        outbound.headers.chunkedTransferEncoding = false;\n        outbound.headers.contentLength = 0;\n      } else if (outbound.headers.contentLength > 0) {\n        var error = HttpException(\n            \"No content even though contentLength was specified to be \"\n            \"greater than 0: ${outbound.headers.contentLength}.\",\n            uri: outbound._uri);\n        _doneCompleter.completeError(error);\n        return _closeFuture = Future.error(error);\n      }\n    }\n    // If contentLength was specified, validate it.\n    var contentLength = this.contentLength;\n    if (contentLength != null) {\n      if (_bytesWritten < contentLength) {\n        var error = HttpException(\n            \"Content size below specified contentLength. \"\n            \" $_bytesWritten bytes written but expected \"\n            \"$contentLength.\",\n            uri: outbound._uri);\n        _doneCompleter.completeError(error);\n        return _closeFuture = Future.error(error);\n      }\n    }\n\n    Future finalize() {\n      // In case of chunked encoding (and gzip), handle remaining gzip data and\n      // append the 'footer' for chunked encoding.\n      if (chunked) {\n        if (_gzip) {\n          _gzipAdd = socket.add;\n          if (_gzipBufferLength > 0) {\n            _gzipSink!.add(Uint8List.view(_gzipBuffer!.buffer,\n                _gzipBuffer!.offsetInBytes, _gzipBufferLength));\n          }\n          _gzipBuffer = null;\n          _gzipSink!.close();\n          _gzipAdd = null;\n        }\n        _addChunk(_chunkHeader(0), socket.add);\n      }\n      // Add any remaining data in the buffer.\n      if (_length > 0) {\n        socket.add(\n            Uint8List.view(_buffer!.buffer, _buffer!.offsetInBytes, _length));\n      }\n      // Clear references, for better GC.\n      _buffer = null;\n      // And finally flush it. As we support keep-alive, never close it from\n      // here. Once the socket is flushed, we'll be able to reuse it (signaled\n      // by the 'done' future).\n      return socket.flush().then((_) {\n        _doneCompleter.complete(socket);\n        return outbound;\n      }, onError: (error, stackTrace) {\n        _doneCompleter.completeError(error, stackTrace);\n        if (_ignoreError(error)) {\n          return outbound;\n        } else {\n          throw error;\n        }\n      });\n    }\n\n    var future = writeHeaders();\n    if (future != null) {\n      return _closeFuture = future.whenComplete(finalize);\n    }\n    return _closeFuture = finalize();\n  }\n\n  Future<Socket> get done => _doneCompleter.future;\n\n  void setHeader(List<int> data, int length) {\n    assert(_length == 0);\n    _buffer = data as Uint8List;\n    _length = length;\n  }\n\n  void set gzip(bool value) {\n    _gzip = value;\n    if (value) {\n      _gzipBuffer = Uint8List(_OUTGOING_BUFFER_SIZE);\n      assert(_gzipSink == null);\n      _gzipSink =\n          ZLibEncoder(gzip: true).startChunkedConversion(_HttpGZipSink((data) {\n        // We are closing down prematurely, due to an error. Discard.\n        if (_gzipAdd == null) return;\n        _addChunk(_chunkHeader(data.length), _gzipAdd!);\n        _pendingChunkedFooter = 2;\n        _addChunk(data, _gzipAdd!);\n      }));\n    }\n  }\n\n  bool _ignoreError(error) =>\n      (error is SocketException || error is TlsException) &&\n      outbound is HttpResponse;\n\n  void _addGZipChunk(List<int> chunk, void Function(List<int> data) add) {\n    var bufferOutput = outbound!.bufferOutput;\n    if (!bufferOutput) {\n      add(chunk);\n      return;\n    }\n    var gzipBuffer = _gzipBuffer!;\n    if (chunk.length > gzipBuffer.length - _gzipBufferLength) {\n      add(Uint8List.view(\n          gzipBuffer.buffer, gzipBuffer.offsetInBytes, _gzipBufferLength));\n      _gzipBuffer = Uint8List(_OUTGOING_BUFFER_SIZE);\n      _gzipBufferLength = 0;\n    }\n    if (chunk.length > _OUTGOING_BUFFER_SIZE) {\n      add(chunk);\n    } else {\n      var currentLength = _gzipBufferLength;\n      var newLength = currentLength + chunk.length;\n      _gzipBuffer!.setRange(currentLength, newLength, chunk);\n      _gzipBufferLength = newLength;\n    }\n  }\n\n  void _addChunk(List<int> chunk, void Function(List<int> data) add) {\n    var bufferOutput = outbound!.bufferOutput;\n    if (!bufferOutput) {\n      if (_buffer != null) {\n        // If _buffer is not null, we have not written the header yet. Write\n        // it now.\n        add(Uint8List.view(_buffer!.buffer, _buffer!.offsetInBytes, _length));\n        _buffer = null;\n        _length = 0;\n      }\n      add(chunk);\n      return;\n    }\n    if (chunk.length > _buffer!.length - _length) {\n      add(Uint8List.view(_buffer!.buffer, _buffer!.offsetInBytes, _length));\n      _buffer = Uint8List(_OUTGOING_BUFFER_SIZE);\n      _length = 0;\n    }\n    if (chunk.length > _OUTGOING_BUFFER_SIZE) {\n      add(chunk);\n    } else {\n      _buffer!.setRange(_length, _length + chunk.length, chunk);\n      _length += chunk.length;\n    }\n  }\n\n  List<int> _chunkHeader(int length) {\n    const hexDigits = [\n      0x30,\n      0x31,\n      0x32,\n      0x33,\n      0x34,\n      0x35,\n      0x36,\n      0x37,\n      0x38,\n      0x39,\n      0x41,\n      0x42,\n      0x43,\n      0x44,\n      0x45,\n      0x46\n    ];\n    if (length == 0) {\n      if (_pendingChunkedFooter == 2) return _footerAndChunk0Length;\n      return _chunk0Length;\n    }\n    int size = _pendingChunkedFooter;\n    int len = length;\n    // Compute a fast integer version of (log(length + 1) / log(16)).ceil().\n    while (len > 0) {\n      size++;\n      len >>= 4;\n    }\n    var footerAndHeader = Uint8List(size + 2);\n    if (_pendingChunkedFooter == 2) {\n      footerAndHeader[0] = _CharCode.CR;\n      footerAndHeader[1] = _CharCode.LF;\n    }\n    int index = size;\n    while (index > _pendingChunkedFooter) {\n      footerAndHeader[--index] = hexDigits[length & 15];\n      length = length >> 4;\n    }\n    footerAndHeader[size + 0] = _CharCode.CR;\n    footerAndHeader[size + 1] = _CharCode.LF;\n    return footerAndHeader;\n  }\n}\n\nclass _HttpClientConnection {\n  final String key;\n  final Socket _socket;\n  final bool _proxyTunnel;\n  final SecurityContext? _context;\n  final _HttpParser _httpParser;\n  StreamSubscription? _subscription;\n  final _HttpClient _httpClient;\n  bool _dispose = false;\n  Timer? _idleTimer;\n  bool closed = false;\n  Uri? _currentUri;\n\n  Completer<_HttpIncoming>? _nextResponseCompleter;\n  Future<Socket>? _streamFuture;\n\n  _HttpClientConnection(this.key, this._socket, this._httpClient,\n      [this._proxyTunnel = false, this._context])\n      : _httpParser = _HttpParser.responseParser() {\n    _httpParser.listenToStream(_socket);\n\n    // Set up handlers on the parser here, so we are sure to get 'onDone' from\n    // the parser.\n    _subscription = _httpParser.listen((incoming) {\n      // Only handle one incoming response at the time. Keep the\n      // stream paused until the response have been processed.\n      _subscription!.pause();\n      // We assume the response is not here, until we have send the request.\n      if (_nextResponseCompleter == null) {\n        throw HttpException(\n            \"Unexpected response (unsolicited response without request).\",\n            uri: _currentUri);\n      }\n\n      // Check for status code '100 Continue'. In that case just\n      // consume that response as the final response will follow\n      // it. There is currently no API for the client to wait for\n      // the '100 Continue' response.\n      if (incoming.statusCode == 100) {\n        incoming.drain().then((_) {\n          _subscription!.resume();\n        }).catchError((dynamic error, StackTrace stackTrace) {\n          _nextResponseCompleter!.completeError(\n              HttpException(error.message, uri: _currentUri), stackTrace);\n          _nextResponseCompleter = null;\n        });\n      } else {\n        _nextResponseCompleter!.complete(incoming);\n        _nextResponseCompleter = null;\n      }\n    }, onError: (dynamic error, StackTrace stackTrace) {\n      _nextResponseCompleter?.completeError(\n          HttpException(error.message, uri: _currentUri), stackTrace);\n      _nextResponseCompleter = null;\n    }, onDone: () {\n      _nextResponseCompleter?.completeError(HttpException(\n          \"Connection closed before response was received\",\n          uri: _currentUri));\n      _nextResponseCompleter = null;\n      close();\n    });\n  }\n\n  _HttpClientRequest send(Uri uri, int port, String method, _Proxy proxy,\n      _HttpProfileData? profileData) {\n    if (closed) {\n      throw HttpException(\"Socket closed before request was sent\", uri: uri);\n    }\n    _currentUri = uri;\n    // Start with pausing the parser.\n    _subscription!.pause();\n    if (method == \"CONNECT\") {\n      // Parser will ignore Content-Length or Transfer-Encoding header\n      _httpParser.connectMethod = true;\n    }\n    _ProxyCredentials? proxyCreds; // Credentials used to authorize proxy.\n    _SiteCredentials? creds; // Credentials used to authorize this request.\n    var outgoing = _HttpOutgoing(_socket);\n\n    // Create new request object, wrapping the outgoing connection.\n    var request = _HttpClientRequest(\n        outgoing, uri, method, proxy, _httpClient, this, profileData);\n    // For the Host header an IPv6 address must be enclosed in []'s.\n    var host = uri.host;\n    if (host.contains(':')) host = \"[$host]\";\n    request.headers\n      ..host = host\n      ..port = port\n      ..add(HttpHeaders.acceptEncodingHeader, \"gzip\");\n    if (_httpClient.userAgent != null) {\n      request.headers.add(HttpHeaders.userAgentHeader, _httpClient.userAgent!);\n    }\n    if (proxy.isAuthenticated) {\n      // If the proxy configuration contains user information use that\n      // for proxy basic authorization.\n      String auth =\n          base64Encode(utf8.encode(\"${proxy.username}:${proxy.password}\"));\n      request.headers.set(HttpHeaders.proxyAuthorizationHeader, \"Basic $auth\");\n    } else if (!proxy.isDirect && _httpClient._proxyCredentials.isNotEmpty) {\n      proxyCreds = _httpClient._findProxyCredentials(proxy);\n      if (proxyCreds != null) {\n        proxyCreds.authorize(request);\n      }\n    }\n    if (uri.userInfo != null && uri.userInfo.isNotEmpty) {\n      // If the URL contains user information use that for basic\n      // authorization.\n      String auth = base64Encode(utf8.encode(uri.userInfo));\n      request.headers.set(HttpHeaders.authorizationHeader, \"Basic $auth\");\n    } else {\n      // Look for credentials.\n      creds = _httpClient._findCredentials(uri);\n      if (creds != null) {\n        creds.authorize(request);\n      }\n    }\n\n    // Start sending the request (lazy, delayed until the user provides\n    // data).\n    _httpParser.isHead = method == \"HEAD\";\n    _streamFuture = outgoing.done.then<Socket>((Socket s) {\n      // Request sent, details available for profiling\n      profileData?.finishRequest(request: request);\n\n      // Request sent, set up response completer.\n      var nextResponseCompleter = Completer<_HttpIncoming>();\n      _nextResponseCompleter = nextResponseCompleter;\n\n      // Listen for response.\n      nextResponseCompleter.future.then((incoming) {\n        _currentUri = null;\n        incoming.dataDone.then((closing) {\n          if (incoming.upgraded) {\n            _httpClient._connectionClosed(this);\n            startTimer();\n            return;\n          }\n          // Keep the connection open if the CONNECT request was successful.\n          if (closed ||\n              (method == 'CONNECT' && incoming.statusCode == HttpStatus.ok)) {\n            return;\n          }\n          if (!closing &&\n              !_dispose &&\n              incoming.headers.persistentConnection &&\n              request.persistentConnection) {\n            // Return connection, now we are done.\n            _httpClient._returnConnection(this);\n            _subscription!.resume();\n          } else {\n            destroy();\n          }\n        });\n        // For digest authentication if proxy check if the proxy\n        // requests the client to start using a new nonce for proxy\n        // authentication.\n        if (proxyCreds != null &&\n            proxyCreds.scheme == _AuthenticationScheme.DIGEST) {\n          var authInfo = incoming.headers[\"proxy-authentication-info\"];\n          if (authInfo != null && authInfo.length == 1) {\n            var header =\n                _HeaderValue.parse(authInfo[0], parameterSeparator: ',');\n            var nextnonce = header.parameters[\"nextnonce\"];\n            if (nextnonce != null) proxyCreds.nonce = nextnonce;\n          }\n        }\n        // For digest authentication check if the server requests the\n        // client to start using a new nonce.\n        if (creds != null && creds.scheme == _AuthenticationScheme.DIGEST) {\n          var authInfo = incoming.headers[\"authentication-info\"];\n          if (authInfo != null && authInfo.length == 1) {\n            var header =\n                _HeaderValue.parse(authInfo[0], parameterSeparator: ',');\n            var nextnonce = header.parameters[\"nextnonce\"];\n            if (nextnonce != null) creds.nonce = nextnonce;\n          }\n        }\n        request._onIncoming(incoming);\n      })\n          // If we see a state error, we failed to get the 'first'\n          // element.\n          .catchError((error) {\n        throw HttpException(\"Connection closed before data was received\",\n            uri: uri);\n      }, test: (error) => error is StateError).catchError((error, stackTrace) {\n        // We are done with the socket.\n        destroy();\n        request._onError(error, stackTrace);\n      });\n\n      // Resume the parser now we have a handler.\n      _subscription!.resume();\n      return s;\n    });\n    Future<Socket?>.value(_streamFuture).catchError((e) {\n      destroy();\n    });\n    return request;\n  }\n\n  Future<Socket> detachSocket() {\n    return _streamFuture!\n        .then((_) => _DetachedSocket(_socket, _httpParser.detachIncoming()));\n  }\n\n  void destroy() {\n    closed = true;\n    _httpClient._connectionClosed(this);\n    _socket.destroy();\n  }\n\n  void destroyFromExternal() {\n    closed = true;\n    _httpClient._connectionClosedNoFurtherClosing(this);\n    _socket.destroy();\n  }\n\n  void close() {\n    closed = true;\n    _httpClient._connectionClosed(this);\n    _streamFuture!\n        .timeout(_httpClient.idleTimeout)\n        .then((_) => _socket.destroy());\n  }\n\n  void closeFromExternal() {\n    closed = true;\n    _httpClient._connectionClosedNoFurtherClosing(this);\n    _streamFuture!\n        .timeout(_httpClient.idleTimeout)\n        .then((_) => _socket.destroy());\n  }\n\n  Future<_HttpClientConnection> createProxyTunnel(\n      String host,\n      int port,\n      _Proxy proxy,\n      bool Function(X509Certificate certificate) callback,\n      _HttpProfileData? profileData) {\n    final method = \"CONNECT\";\n    final uri = Uri(host: host, port: port);\n\n    profileData?.proxyEvent(proxy);\n\n    // Notify the profiler that we're starting a sub request.\n    _HttpProfileData? proxyProfileData;\n    if (profileData != null) {\n      proxyProfileData = HttpProfiler.startRequest(\n        method,\n        uri,\n        parentRequest: profileData,\n      );\n    }\n    _HttpClientRequest request = send(\n        Uri(host: host, port: port), port, method, proxy, proxyProfileData);\n    if (proxy.isAuthenticated) {\n      // If the proxy configuration contains user information use that\n      // for proxy basic authorization.\n      String auth =\n          base64Encode(utf8.encode(\"${proxy.username}:${proxy.password}\"));\n      request.headers.set(HttpHeaders.proxyAuthorizationHeader, \"Basic $auth\");\n    }\n    return request.close().then((response) {\n      if (response.statusCode != HttpStatus.ok) {\n        final error = \"Proxy failed to establish tunnel \"\n            \"(${response.statusCode} ${response.reasonPhrase})\";\n        profileData?.requestEvent(error);\n        throw HttpException(error, uri: request.uri);\n      }\n      var socket = (response as _HttpClientResponse)\n          ._httpRequest\n          ._httpClientConnection\n          ._socket;\n      return SecureSocket.secure(socket,\n          host: host, context: _context, onBadCertificate: callback);\n    }).then((secureSocket) {\n      String key = _HttpClientConnection.makeKey(true, host, port);\n      profileData?.requestEvent('Proxy tunnel established');\n      return _HttpClientConnection(\n          key, secureSocket, request._httpClient, true);\n    });\n  }\n\n  HttpConnectionInfo? get connectionInfo => _HttpConnectionInfo.create(_socket);\n\n  static makeKey(bool isSecure, String host, int port) {\n    return isSecure ? \"ssh:$host:$port\" : \"$host:$port\";\n  }\n\n  void stopTimer() {\n    _idleTimer?.cancel();\n    _idleTimer = null;\n  }\n\n  void startTimer() {\n    assert(_idleTimer == null);\n    _idleTimer = Timer(_httpClient.idleTimeout, () {\n      _idleTimer = null;\n      close();\n    });\n  }\n}\n\nclass _ConnectionInfo {\n  final _HttpClientConnection connection;\n  final _Proxy proxy;\n\n  _ConnectionInfo(this.connection, this.proxy);\n}\n\nclass _ConnectionTarget {\n  // Unique key for this connection target.\n  final String key;\n  final String host;\n  final int port;\n  final bool isSecure;\n  final SecurityContext? context;\n  final Set<_HttpClientConnection> _idle = HashSet();\n  final Set<_HttpClientConnection> _active = HashSet();\n  final Set<ConnectionTask> _socketTasks = HashSet();\n  final _pending = ListQueue<void Function()>();\n  int _connecting = 0;\n\n  _ConnectionTarget(\n      this.key, this.host, this.port, this.isSecure, this.context);\n\n  bool get isEmpty => _idle.isEmpty && _active.isEmpty && _connecting == 0;\n\n  bool get hasIdle => _idle.isNotEmpty;\n\n  bool get hasActive => _active.isNotEmpty || _connecting > 0;\n\n  _HttpClientConnection takeIdle() {\n    assert(hasIdle);\n    _HttpClientConnection connection = _idle.first;\n    _idle.remove(connection);\n    connection.stopTimer();\n    _active.add(connection);\n    return connection;\n  }\n\n  _checkPending() {\n    if (_pending.isNotEmpty) {\n      _pending.removeFirst()();\n    }\n  }\n\n  void addNewActive(_HttpClientConnection connection) {\n    _active.add(connection);\n  }\n\n  void returnConnection(_HttpClientConnection connection) {\n    assert(_active.contains(connection));\n    _active.remove(connection);\n    _idle.add(connection);\n    connection.startTimer();\n    _checkPending();\n  }\n\n  void connectionClosed(_HttpClientConnection connection) {\n    assert(!_active.contains(connection) || !_idle.contains(connection));\n    _active.remove(connection);\n    _idle.remove(connection);\n    _checkPending();\n  }\n\n  void close(bool force) {\n    // Always cancel pending socket connections.\n    for (var t in _socketTasks.toList()) {\n      // Make sure the socket is destroyed if the ConnectionTask is cancelled.\n      t.socket.then((s) {\n        s.destroy();\n      }, onError: (e) {});\n      t.cancel();\n    }\n    if (force) {\n      for (var c in _idle.toList()) {\n        c.destroyFromExternal();\n      }\n      for (var c in _active.toList()) {\n        c.destroyFromExternal();\n      }\n    } else {\n      for (var c in _idle.toList()) {\n        c.closeFromExternal();\n      }\n    }\n  }\n\n  Future<_ConnectionInfo> connect(String uriHost, int uriPort, _Proxy proxy,\n      _HttpClient client, _HttpProfileData? profileData) {\n    if (hasIdle) {\n      var connection = takeIdle();\n      client._connectionsChanged();\n      return Future.value(_ConnectionInfo(connection, proxy));\n    }\n    var maxConnectionsPerHost = client.maxConnectionsPerHost;\n    if (maxConnectionsPerHost != null &&\n        _active.length + _connecting >= maxConnectionsPerHost) {\n      var completer = Completer<_ConnectionInfo>();\n      _pending.add(() {\n        completer\n            .complete(connect(uriHost, uriPort, proxy, client, profileData));\n      });\n      return completer.future;\n    }\n    var currentBadCertificateCallback = client._badCertificateCallback;\n\n    bool callback(X509Certificate certificate) {\n      if (currentBadCertificateCallback == null) return false;\n      return currentBadCertificateCallback(certificate, uriHost, uriPort);\n    }\n\n    Future<ConnectionTask> connectionTask = (isSecure && proxy.isDirect\n        ? SecureSocket.startConnect(host, port,\n            context: context, onBadCertificate: callback)\n        : Socket.startConnect(host, port));\n    _connecting++;\n    return connectionTask.then((ConnectionTask task) {\n      _socketTasks.add(task);\n      Future socketFuture = task.socket;\n      final Duration? connectionTimeout = client.connectionTimeout;\n      if (connectionTimeout != null) {\n        socketFuture = socketFuture.timeout(connectionTimeout);\n      }\n      return socketFuture.then((socket) {\n        _connecting--;\n        if (socket.address.type != InternetAddressType.unix) {\n          socket.setOption(SocketOption.tcpNoDelay, true);\n        }\n        var connection =\n            _HttpClientConnection(key, socket, client, false, context);\n        if (isSecure && !proxy.isDirect) {\n          connection._dispose = true;\n          return connection\n              .createProxyTunnel(uriHost, uriPort, proxy, callback, profileData)\n              .then((tunnel) {\n            client\n                ._getConnectionTarget(uriHost, uriPort, true)\n                .addNewActive(tunnel);\n            _socketTasks.remove(task);\n            return _ConnectionInfo(tunnel, proxy);\n          });\n        } else {\n          addNewActive(connection);\n          _socketTasks.remove(task);\n          return _ConnectionInfo(connection, proxy);\n        }\n      }, onError: (error) {\n        // When there is a timeout, there is a race in which the connectionTask\n        // Future won't be completed with an error before the socketFuture here\n        // is completed with a TimeoutException by the onTimeout callback above.\n        // In this case, propagate a SocketException as specified by the\n        // HttpClient.connectionTimeout docs.\n        if (error is TimeoutException) {\n          assert(connectionTimeout != null);\n          _connecting--;\n          _socketTasks.remove(task);\n          task.cancel();\n          throw SocketException(\n              \"HTTP connection timed out after $connectionTimeout, \"\n              \"host: $host, port: $port\");\n        }\n        _socketTasks.remove(task);\n        _checkPending();\n        throw error;\n      });\n    }, onError: (error) {\n      _connecting--;\n      throw error;\n    });\n  }\n}\n\ntypedef BadCertificateCallback = bool Function(\n    X509Certificate cr, String host, int port);\n\nclass _HttpClient implements HttpClient {\n  bool _closing = false;\n  bool _closingForcefully = false;\n  final Map<String, _ConnectionTarget> _connectionTargets =\n      HashMap<String, _ConnectionTarget>();\n  final List<_Credentials> _credentials = [];\n  final List<_ProxyCredentials> _proxyCredentials = [];\n  final SecurityContext? _context;\n  Future<bool> Function(Uri, String scheme, String? realm)? _authenticate;\n  Future<bool> Function(String host, int port, String scheme, String? realm)?\n      _authenticateProxy;\n  String Function(Uri)? _findProxy = HttpClient.findProxyFromEnvironment;\n  Duration _idleTimeout = const Duration(seconds: 15);\n  BadCertificateCallback? _badCertificateCallback;\n\n  Duration get idleTimeout => _idleTimeout;\n\n  Duration? connectionTimeout;\n\n  int? maxConnectionsPerHost;\n\n  bool autoUncompress = true;\n\n  String? userAgent = _getHttpVersion();\n\n  _HttpClient(this._context);\n\n  void set idleTimeout(Duration timeout) {\n    _idleTimeout = timeout;\n    for (var c in _connectionTargets.values) {\n      for (var idle in c._idle) {\n        // Reset timer. This is fine, as it's not happening often.\n        idle.stopTimer();\n        idle.startTimer();\n      }\n    }\n  }\n\n  set badCertificateCallback(\n      bool Function(X509Certificate cert, String host, int port)? callback) {\n    _badCertificateCallback = callback;\n  }\n\n  Future<HttpClientRequest> open(\n      String method, String host, int port, String path) {\n    const int hashMark = 0x23;\n    const int questionMark = 0x3f;\n    int fragmentStart = path.length;\n    int queryStart = path.length;\n    for (int i = path.length - 1; i >= 0; i--) {\n      var char = path.codeUnitAt(i);\n      if (char == hashMark) {\n        fragmentStart = i;\n        queryStart = i;\n      } else if (char == questionMark) {\n        queryStart = i;\n      }\n    }\n    String? query;\n    if (queryStart < fragmentStart) {\n      query = path.substring(queryStart + 1, fragmentStart);\n      path = path.substring(0, queryStart);\n    }\n    Uri uri =\n        Uri(scheme: \"http\", host: host, port: port, path: path, query: query);\n    return _openUrl(method, uri);\n  }\n\n  Future<HttpClientRequest> openUrl(String method, Uri url) =>\n      _openUrl(method, url);\n\n  Future<HttpClientRequest> get(String host, int port, String path) =>\n      open(\"get\", host, port, path);\n\n  Future<HttpClientRequest> getUrl(Uri url) => _openUrl(\"get\", url);\n\n  Future<HttpClientRequest> post(String host, int port, String path) =>\n      open(\"post\", host, port, path);\n\n  Future<HttpClientRequest> postUrl(Uri url) => _openUrl(\"post\", url);\n\n  Future<HttpClientRequest> put(String host, int port, String path) =>\n      open(\"put\", host, port, path);\n\n  Future<HttpClientRequest> putUrl(Uri url) => _openUrl(\"put\", url);\n\n  Future<HttpClientRequest> delete(String host, int port, String path) =>\n      open(\"delete\", host, port, path);\n\n  Future<HttpClientRequest> deleteUrl(Uri url) => _openUrl(\"delete\", url);\n\n  Future<HttpClientRequest> head(String host, int port, String path) =>\n      open(\"head\", host, port, path);\n\n  Future<HttpClientRequest> headUrl(Uri url) => _openUrl(\"head\", url);\n\n  Future<HttpClientRequest> patch(String host, int port, String path) =>\n      open(\"patch\", host, port, path);\n\n  Future<HttpClientRequest> patchUrl(Uri url) => _openUrl(\"patch\", url);\n\n  void close({bool force = false}) {\n    _closing = true;\n    _closingForcefully = force;\n    _closeConnections(_closingForcefully);\n    assert(!_connectionTargets.values.any((s) => s.hasIdle));\n    assert(\n        !force || !_connectionTargets.values.any((s) => s._active.isNotEmpty));\n  }\n\n  set authenticate(\n      Future<bool> Function(Uri url, String scheme, String? realm)? f) {\n    _authenticate = f;\n  }\n\n  void addCredentials(Uri url, String realm, HttpClientCredentials cr) {\n    _credentials\n        .add(_SiteCredentials(url, realm, cr as _HttpClientCredentials));\n  }\n\n  set authenticateProxy(\n      Future<bool> Function(\n              String host, int port, String scheme, String? realm)?\n          f) {\n    _authenticateProxy = f;\n  }\n\n  void addProxyCredentials(\n      String host, int port, String realm, HttpClientCredentials cr) {\n    _proxyCredentials.add(\n        _ProxyCredentials(host, port, realm, cr as _HttpClientCredentials));\n  }\n\n  set findProxy(String Function(Uri uri)? f) => _findProxy = f;\n\n  static void _startRequestTimelineEvent(\n      TimelineTask? timeline, String method, Uri uri) {\n    timeline?.start('HTTP CLIENT ${method.toUpperCase()}', arguments: {\n      'method': method.toUpperCase(),\n      'uri': uri.toString(),\n    });\n  }\n\n  bool _isLoopback(String host) {\n    if (host.isEmpty) return false;\n    if (\"localhost\" == host) return true;\n    try {\n      return InternetAddress(host).isLoopback;\n    } on ArgumentError {\n      return false;\n    }\n  }\n\n  Future<_HttpClientRequest> _openUrl(String method, Uri uri) {\n    if (_closing) {\n      throw StateError(\"Client is closed\");\n    }\n\n    // Ignore any fragments on the request URI.\n    uri = uri.removeFragment();\n\n    if (method == null) {\n      throw ArgumentError(method);\n    }\n    if (method != \"CONNECT\") {\n      if (uri.host.isEmpty) {\n        throw ArgumentError(\"No host specified in URI $uri\");\n      } else if (uri.scheme != \"http\" && uri.scheme != \"https\") {\n        throw ArgumentError(\"Unsupported scheme '${uri.scheme}' in URI $uri\");\n      }\n    }\n\n    _httpConnectionHook(uri);\n\n    bool isSecure = uri.isScheme(\"https\");\n\n    int port = uri.port;\n    if (port == 0) {\n      port =\n          isSecure ? HttpClient.defaultHttpsPort : HttpClient.defaultHttpPort;\n    }\n    // Check to see if a proxy server should be used for this connection.\n    var proxyConf = const _ProxyConfiguration.direct();\n    var findProxy = _findProxy;\n    if (findProxy != null) {\n      // TODO(sgjesse): Keep a map of these as normally only a few\n      // configuration strings will be used.\n      try {\n        proxyConf = _ProxyConfiguration(findProxy(uri));\n      } catch (error, stackTrace) {\n        return Future.error(error, stackTrace);\n      }\n    }\n    _HttpProfileData? profileData;\n    if (HttpClient.enableTimelineLogging) {\n      profileData = HttpProfiler.startRequest(method, uri);\n    }\n    return _getConnection(uri.host, port, proxyConf, isSecure, profileData)\n        .then((_ConnectionInfo info) {\n      _HttpClientRequest send(_ConnectionInfo info) {\n        profileData?.requestEvent('Connection established');\n        return info.connection\n            .send(uri, port, method.toUpperCase(), info.proxy, profileData);\n      }\n\n      // If the connection was closed before the request was sent, create\n      // and use another connection.\n      if (info.connection.closed) {\n        return _getConnection(uri.host, port, proxyConf, isSecure, profileData)\n            .then(send);\n      }\n      return send(info);\n    }, onError: (error) {\n      profileData?.finishRequestWithError(error.toString());\n      throw error;\n    });\n  }\n\n  Future<_HttpClientRequest> _openUrlFromRequest(\n      String method, Uri uri, _HttpClientRequest previous) {\n    // If the new URI is relative (to either '/' or some sub-path),\n    // construct a full URI from the previous one.\n    Uri resolved = previous.uri.resolveUri(uri);\n    return _openUrl(method, resolved).then((_HttpClientRequest request) {\n      request\n        // Only follow redirects if initial request did.\n        ..followRedirects = previous.followRedirects\n        // Allow same number of redirects.\n        ..maxRedirects = previous.maxRedirects;\n      // Copy headers.\n      for (var header in previous.headers._headers.keys) {\n        if (request.headers[header] == null) {\n          request.headers.set(header, previous.headers[header]!);\n        }\n      }\n      return request\n        ..headers.chunkedTransferEncoding = false\n        ..contentLength = 0;\n    });\n  }\n\n  // Return a live connection to the idle pool.\n  void _returnConnection(_HttpClientConnection connection) {\n    _connectionTargets[connection.key]!.returnConnection(connection);\n    _connectionsChanged();\n  }\n\n  // Remove a closed connection from the active set.\n  void _connectionClosed(_HttpClientConnection connection) {\n    connection.stopTimer();\n    var connectionTarget = _connectionTargets[connection.key];\n    if (connectionTarget != null) {\n      connectionTarget.connectionClosed(connection);\n      if (connectionTarget.isEmpty) {\n        _connectionTargets.remove(connection.key);\n      }\n      _connectionsChanged();\n    }\n  }\n\n  // Remove a closed connection and not issue _closeConnections(). If the close\n  // is signaled from user by calling close(), _closeConnections() was called\n  // and prevent further calls.\n  void _connectionClosedNoFurtherClosing(_HttpClientConnection connection) {\n    connection.stopTimer();\n    var connectionTarget = _connectionTargets[connection.key];\n    if (connectionTarget != null) {\n      connectionTarget.connectionClosed(connection);\n      if (connectionTarget.isEmpty) {\n        _connectionTargets.remove(connection.key);\n      }\n    }\n  }\n\n  void _connectionsChanged() {\n    if (_closing) {\n      _closeConnections(_closingForcefully);\n    }\n  }\n\n  void _closeConnections(bool force) {\n    for (var connectionTarget in _connectionTargets.values.toList()) {\n      connectionTarget.close(force);\n    }\n  }\n\n  _ConnectionTarget _getConnectionTarget(String host, int port, bool isSecure) {\n    String key = _HttpClientConnection.makeKey(isSecure, host, port);\n    return _connectionTargets.putIfAbsent(key, () {\n      return _ConnectionTarget(key, host, port, isSecure, _context);\n    });\n  }\n\n  // Get a new _HttpClientConnection, from the matching _ConnectionTarget.\n  Future<_ConnectionInfo> _getConnection(\n      String uriHost,\n      int uriPort,\n      _ProxyConfiguration proxyConf,\n      bool isSecure,\n      _HttpProfileData? profileData) {\n    Iterator<_Proxy> proxies = proxyConf.proxies.iterator;\n\n    Future<_ConnectionInfo> connect(error, stackTrace) {\n      if (!proxies.moveNext()) return Future.error(error, stackTrace);\n      _Proxy proxy = proxies.current;\n      String host = proxy.isDirect ? uriHost : proxy.host!;\n      int port = proxy.isDirect ? uriPort : proxy.port!;\n      return _getConnectionTarget(host, port, isSecure)\n          .connect(uriHost, uriPort, proxy, this, profileData)\n          // On error, continue with next proxy.\n          .catchError(connect);\n    }\n\n    return connect(HttpException(\"No proxies given\"), StackTrace.current);\n  }\n\n  _SiteCredentials? _findCredentials(Uri url, [_AuthenticationScheme? scheme]) {\n    // Look for credentials.\n    _SiteCredentials? cr =\n        _credentials.fold(null, (_SiteCredentials? prev, value) {\n      var siteCredentials = value as _SiteCredentials;\n      if (siteCredentials.applies(url, scheme)) {\n        if (prev == null) return value;\n        return siteCredentials.uri.path.length > prev.uri.path.length\n            ? siteCredentials\n            : prev;\n      } else {\n        return prev;\n      }\n    });\n    return cr;\n  }\n\n  _ProxyCredentials? _findProxyCredentials(_Proxy proxy,\n      [_AuthenticationScheme? scheme]) {\n    // Look for credentials.\n    for (var current in _proxyCredentials) {\n      if (current.applies(proxy, scheme)) {\n        return current;\n      }\n    }\n    return null;\n  }\n\n  void _removeCredentials(_Credentials cr) {\n    int index = _credentials.indexOf(cr);\n    if (index != -1) {\n      _credentials.removeAt(index);\n    }\n  }\n\n  void _removeProxyCredentials(_Credentials cr) {\n    _proxyCredentials.remove(cr);\n  }\n\n  static String _findProxyFromEnvironment(\n      Uri url, Map<String, String>? environment) {\n    String? checkNoProxy(String? option) {\n      if (option == null) return null;\n      Iterator<String> names = option.split(\",\").map((s) => s.trim()).iterator;\n      while (names.moveNext()) {\n        var name = names.current;\n        if ((name.startsWith(\"[\") &&\n                name.endsWith(\"]\") &&\n                \"[${url.host}]\" == name) ||\n            (name.isNotEmpty && url.host.endsWith(name))) {\n          return \"DIRECT\";\n        }\n      }\n      return null;\n    }\n\n    String? checkProxy(String? option) {\n      if (option == null) return null;\n      option = option.trim();\n      if (option.isEmpty) return null;\n      int pos = option.indexOf(\"://\");\n      if (pos >= 0) {\n        option = option.substring(pos + 3);\n      }\n      pos = option.indexOf(\"/\");\n      if (pos >= 0) {\n        option = option.substring(0, pos);\n      }\n      // Add default port if no port configured.\n      if (option.indexOf(\"[\") == 0) {\n        var pos = option.lastIndexOf(\":\");\n        if (option.indexOf(\"]\") > pos) option = \"$option:1080\";\n      } else {\n        if (!option.contains(\":\")) option = \"$option:1080\";\n      }\n      return \"PROXY $option\";\n    }\n\n    // Default to using the process current environment.\n    environment ??= _platformEnvironmentCache;\n\n    String? proxyCfg;\n\n    String? noProxy = environment[\"no_proxy\"] ?? environment[\"NO_PROXY\"];\n    proxyCfg = checkNoProxy(noProxy);\n    if (proxyCfg != null) {\n      return proxyCfg;\n    }\n\n    if (url.scheme == \"http\") {\n      String? proxy = environment[\"http_proxy\"] ?? environment[\"HTTP_PROXY\"];\n      proxyCfg = checkProxy(proxy);\n      if (proxyCfg != null) {\n        return proxyCfg;\n      }\n    } else if (url.scheme == \"https\") {\n      String? proxy = environment[\"https_proxy\"] ?? environment[\"HTTPS_PROXY\"];\n      proxyCfg = checkProxy(proxy);\n      if (proxyCfg != null) {\n        return proxyCfg;\n      }\n    }\n    return \"DIRECT\";\n  }\n\n  static final Map<String, String> _platformEnvironmentCache =\n      Platform.environment;\n}\n\nclass _HttpConnection extends LinkedListEntry<_HttpConnection>\n    with _ServiceObject {\n  static const _ACTIVE = 0;\n  static const _IDLE = 1;\n  static const _CLOSING = 2;\n  static const _DETACHED = 3;\n\n  // Use HashMap, as we don't need to keep order.\n  static final Map<int, _HttpConnection> _connections =\n      HashMap<int, _HttpConnection>();\n\n  final /*_ServerSocket*/ _socket;\n  final _HttpServer _httpServer;\n  final _HttpParser _httpParser;\n  int _state = _IDLE;\n  StreamSubscription? _subscription;\n  bool _idleMark = false;\n  Future? _streamFuture;\n\n  _HttpConnection(this._socket, this._httpServer)\n      : _httpParser = _HttpParser.requestParser() {\n    _connections[_serviceId] = this;\n    _httpParser.listenToStream(_socket);\n    _subscription = _httpParser.listen((incoming) {\n      _httpServer._markActive(this);\n      // If the incoming was closed, close the connection.\n      incoming.dataDone.then((closing) {\n        if (closing) destroy();\n      });\n      // Only handle one incoming request at the time. Keep the\n      // stream paused until the request has been send.\n      _subscription!.pause();\n      _state = _ACTIVE;\n      var outgoing = _HttpOutgoing(_socket);\n      var response = _HttpResponse(\n          incoming.uri!,\n          incoming.headers.protocolVersion,\n          outgoing,\n          _httpServer.defaultResponseHeaders,\n          _httpServer.serverHeader);\n      // Parser found badRequest and sent out Response.\n      if (incoming.statusCode == HttpStatus.badRequest) {\n        response.statusCode = HttpStatus.badRequest;\n      }\n      var request = _HttpRequest(response, incoming, _httpServer, this);\n      _streamFuture = outgoing.done.then((_) {\n        response.deadline = null;\n        if (_state == _DETACHED) return;\n        if (response.persistentConnection &&\n            request.persistentConnection &&\n            incoming.fullBodyRead &&\n            !_httpParser.upgrade &&\n            !_httpServer.closed) {\n          _state = _IDLE;\n          _idleMark = false;\n          _httpServer._markIdle(this);\n          // Resume the subscription for incoming requests as the\n          // request is now processed.\n          _subscription!.resume();\n        } else {\n          // Close socket, keep-alive not used or body sent before\n          // received data was handled.\n          destroy();\n        }\n      }, onError: (_) {\n        destroy();\n      });\n      outgoing.ignoreBody = request.method == \"HEAD\";\n      response._httpRequest = request;\n      _httpServer._handleRequest(request);\n    }, onDone: () {\n      destroy();\n    }, onError: (error) {\n      // Ignore failed requests that was closed before headers was received.\n      destroy();\n    });\n  }\n\n  void markIdle() {\n    _idleMark = true;\n  }\n\n  bool get isMarkedIdle => _idleMark;\n\n  void destroy() {\n    if (_state == _CLOSING || _state == _DETACHED) return;\n    _state = _CLOSING;\n    _socket.destroy();\n    _httpServer._connectionClosed(this);\n    _connections.remove(_serviceId);\n  }\n\n  Future<Socket> detachSocket() {\n    _state = _DETACHED;\n    // Remove connection from server.\n    _httpServer._connectionClosed(this);\n\n    _HttpDetachedIncoming detachedIncoming = _httpParser.detachIncoming();\n\n    return _streamFuture!.then((_) {\n      _connections.remove(_serviceId);\n      return _DetachedSocket(_socket, detachedIncoming);\n    });\n  }\n\n  HttpConnectionInfo? get connectionInfo => _HttpConnectionInfo.create(_socket);\n\n  bool get _isActive => _state == _ACTIVE;\n  bool get _isIdle => _state == _IDLE;\n  bool get _isClosing => _state == _CLOSING;\n  bool get _isDetached => _state == _DETACHED;\n\n  String get _serviceTypePath => 'io/http/serverconnections';\n  String get _serviceTypeName => 'HttpServerConnection';\n\n  Map _toJSON(bool ref) {\n    var name = \"${_socket.address.host}:${_socket.port} <-> \"\n        \"${_socket.remoteAddress.host}:${_socket.remotePort}\";\n    var r = <String, dynamic>{\n      'id': _servicePath,\n      'type': _serviceType(ref),\n      'name': name,\n      'user_name': name,\n    };\n    if (ref) {\n      return r;\n    }\n    r['server'] = _httpServer._toJSON(true);\n    try {\n      r['socket'] = _socket._toJSON(true);\n    } catch (_) {\n      r['socket'] = {\n        'id': _servicePath,\n        'type': '@Socket',\n        'name': 'UserSocket',\n        'user_name': 'UserSocket',\n      };\n    }\n    switch (_state) {\n      case _ACTIVE:\n        r['state'] = \"Active\";\n        break;\n      case _IDLE:\n        r['state'] = \"Idle\";\n        break;\n      case _CLOSING:\n        r['state'] = \"Closing\";\n        break;\n      case _DETACHED:\n        r['state'] = \"Detached\";\n        break;\n      default:\n        r['state'] = 'Unknown';\n        break;\n    }\n    return r;\n  }\n}\n\n// HTTP server waiting for socket connections.\nclass _HttpServer extends Stream<HttpRequest>\n    with _ServiceObject\n    implements HttpServer {\n  // Use default Map so we keep order.\n  static final Map<int, _HttpServer> _servers = <int, _HttpServer>{};\n\n  String? serverHeader;\n  final HttpHeaders defaultResponseHeaders = _initDefaultResponseHeaders();\n  bool autoCompress = false;\n\n  Duration? _idleTimeout;\n  Timer? _idleTimer;\n\n  static Future<HttpServer> bind(\n      address, int port, int backlog, bool v6Only, bool shared) {\n    return ServerSocket.bind(address, port,\n            backlog: backlog, v6Only: v6Only, shared: shared)\n        .then<HttpServer>((socket) {\n      return _HttpServer._(socket, true);\n    });\n  }\n\n  static Future<HttpServer> bindSecure(\n      address,\n      int port,\n      SecurityContext? context,\n      int backlog,\n      bool v6Only,\n      bool requestClientCertificate,\n      bool shared) {\n    return SecureServerSocket.bind(address, port, context,\n            backlog: backlog,\n            v6Only: v6Only,\n            requestClientCertificate: requestClientCertificate,\n            shared: shared)\n        .then<HttpServer>((socket) {\n      return _HttpServer._(socket, true);\n    });\n  }\n\n  _HttpServer._(this._serverSocket, this._closeServer)\n      : _controller = StreamController<HttpRequest>(sync: true) {\n    _controller.onCancel = close;\n    idleTimeout = const Duration(seconds: 120);\n    _servers[_serviceId] = this;\n  }\n\n  _HttpServer.listenOn(this._serverSocket)\n      : _closeServer = false,\n        _controller = StreamController<HttpRequest>(sync: true) {\n    _controller.onCancel = close;\n    idleTimeout = const Duration(seconds: 120);\n    _servers[_serviceId] = this;\n  }\n\n  static HttpHeaders _initDefaultResponseHeaders() {\n    var defaultResponseHeaders = _HttpHeaders('1.1');\n    defaultResponseHeaders.contentType = ContentType.text;\n    defaultResponseHeaders.set('X-Frame-Options', 'SAMEORIGIN');\n    defaultResponseHeaders.set('X-Content-Type-Options', 'nosniff');\n    defaultResponseHeaders.set('X-XSS-Protection', '1; mode=block');\n    return defaultResponseHeaders;\n  }\n\n  Duration? get idleTimeout => _idleTimeout;\n\n  void set idleTimeout(Duration? duration) {\n    var idleTimer = _idleTimer;\n    if (idleTimer != null) {\n      idleTimer.cancel();\n      _idleTimer = null;\n    }\n    _idleTimeout = duration;\n    if (duration != null) {\n      _idleTimer = Timer.periodic(duration, (_) {\n        for (var idle in _idleConnections.toList()) {\n          if (idle.isMarkedIdle) {\n            idle.destroy();\n          } else {\n            idle.markIdle();\n          }\n        }\n      });\n    }\n  }\n\n  StreamSubscription<HttpRequest> listen(\n      void Function(HttpRequest event)? onData,\n      {Function? onError,\n      void Function()? onDone,\n      bool? cancelOnError}) {\n    _serverSocket.listen((Socket socket) {\n      if (socket.address.type != InternetAddressType.unix) {\n        socket.setOption(SocketOption.tcpNoDelay, true);\n      }\n      // Accept the client connection.\n      _HttpConnection connection = _HttpConnection(socket, this);\n      _idleConnections.add(connection);\n    }, onError: (error, stackTrace) {\n      // Ignore HandshakeExceptions as they are bound to a single request,\n      // and are not fatal for the server.\n      if (error is! HandshakeException) {\n        _controller.addError(error, stackTrace);\n      }\n    }, onDone: _controller.close);\n    return _controller.stream.listen(onData,\n        onError: onError, onDone: onDone, cancelOnError: cancelOnError);\n  }\n\n  Future close({bool force = false}) {\n    closed = true;\n    Future result;\n    if (_serverSocket != null && _closeServer) {\n      result = _serverSocket.close();\n    } else {\n      result = Future.value();\n    }\n    idleTimeout = null;\n    if (force) {\n      for (var c in _activeConnections.toList()) {\n        c.destroy();\n      }\n      assert(_activeConnections.isEmpty);\n    }\n    for (var c in _idleConnections.toList()) {\n      c.destroy();\n    }\n    _maybePerformCleanup();\n    return result;\n  }\n\n  void _maybePerformCleanup() {\n    var sessionManager = _sessionManagerInstance;\n    if (closed &&\n        _idleConnections.isEmpty &&\n        _activeConnections.isEmpty &&\n        sessionManager != null) {\n      sessionManager.close();\n      _sessionManagerInstance = null;\n      _servers.remove(_serviceId);\n    }\n  }\n\n  int get port {\n    if (closed) throw HttpException(\"HttpServer is not bound to a socket\");\n    return _serverSocket.port;\n  }\n\n  InternetAddress get address {\n    if (closed) throw HttpException(\"HttpServer is not bound to a socket\");\n    return _serverSocket.address;\n  }\n\n  set sessionTimeout(int timeout) {\n    _sessionManager.sessionTimeout = timeout;\n  }\n\n  void _handleRequest(_HttpRequest request) {\n    if (!closed) {\n      _controller.add(request);\n    } else {\n      request._httpConnection.destroy();\n    }\n  }\n\n  void _connectionClosed(_HttpConnection connection) {\n    // Remove itself from either idle or active connections.\n    connection.unlink();\n    _maybePerformCleanup();\n  }\n\n  void _markIdle(_HttpConnection connection) {\n    _activeConnections.remove(connection);\n    _idleConnections.add(connection);\n  }\n\n  void _markActive(_HttpConnection connection) {\n    _idleConnections.remove(connection);\n    _activeConnections.add(connection);\n  }\n\n  // Lazy init.\n  _HttpSessionManager get _sessionManager =>\n      _sessionManagerInstance ??= _HttpSessionManager();\n\n  HttpConnectionsInfo connectionsInfo() {\n    HttpConnectionsInfo result = HttpConnectionsInfo();\n    result.total = _activeConnections.length + _idleConnections.length;\n    for (var conn in _activeConnections) {\n      if (conn._isActive) {\n        result.active++;\n      } else {\n        assert(conn._isClosing);\n        result.closing++;\n      }\n    }\n    for (var conn in _idleConnections) {\n      result.idle++;\n      assert(conn._isIdle);\n    }\n    return result;\n  }\n\n  String get _serviceTypePath => 'io/http/servers';\n  String get _serviceTypeName => 'HttpServer';\n\n  Map<String, dynamic> _toJSON(bool ref) {\n    var r = <String, dynamic>{\n      'id': _servicePath,\n      'type': _serviceType(ref),\n      'name': '${address.host}:$port',\n      'user_name': '${address.host}:$port',\n    };\n    if (ref) {\n      return r;\n    }\n    try {\n      r['socket'] = _serverSocket._toJSON(true);\n    } catch (_) {\n      r['socket'] = {\n        'id': _servicePath,\n        'type': '@Socket',\n        'name': 'UserSocket',\n        'user_name': 'UserSocket',\n      };\n    }\n    r['port'] = port;\n    r['address'] = address.host;\n    r['active'] = _activeConnections.map((c) => c._toJSON(true)).toList();\n    r['idle'] = _idleConnections.map((c) => c._toJSON(true)).toList();\n    r['closed'] = closed;\n    return r;\n  }\n\n  _HttpSessionManager? _sessionManagerInstance;\n\n  // Indicated if the http server has been closed.\n  bool closed = false;\n\n  // The server listen socket. Untyped as it can be both ServerSocket and\n  // SecureServerSocket.\n  final dynamic /*ServerSocket|SecureServerSocket*/ _serverSocket;\n  final bool _closeServer;\n\n  // Set of currently connected clients.\n  final LinkedList<_HttpConnection> _activeConnections =\n      LinkedList<_HttpConnection>();\n  final LinkedList<_HttpConnection> _idleConnections =\n      LinkedList<_HttpConnection>();\n  final StreamController<HttpRequest> _controller;\n}\n\nclass _ProxyConfiguration {\n  static const String PROXY_PREFIX = \"PROXY \";\n  static const String DIRECT_PREFIX = \"DIRECT\";\n\n  _ProxyConfiguration(String configuration) : proxies = <_Proxy>[] {\n    if (configuration == null) {\n      throw HttpException(\"Invalid proxy configuration $configuration\");\n    }\n    List<String> list = configuration.split(\";\");\n    for (var proxy in list) {\n      proxy = proxy.trim();\n      if (proxy.isNotEmpty) {\n        if (proxy.startsWith(PROXY_PREFIX)) {\n          String? username;\n          String? password;\n          // Skip the \"PROXY \" prefix.\n          proxy = proxy.substring(PROXY_PREFIX.length).trim();\n          // Look for proxy authentication.\n          int at = proxy.indexOf(\"@\");\n          if (at != -1) {\n            String userinfo = proxy.substring(0, at).trim();\n            proxy = proxy.substring(at + 1).trim();\n            int colon = userinfo.indexOf(\":\");\n            if (colon == -1 || colon == 0 || colon == proxy.length - 1) {\n              throw HttpException(\"Invalid proxy configuration $configuration\");\n            }\n            username = userinfo.substring(0, colon).trim();\n            password = userinfo.substring(colon + 1).trim();\n          }\n          // Look for proxy host and port.\n          int colon = proxy.lastIndexOf(\":\");\n          if (colon == -1 || colon == 0 || colon == proxy.length - 1) {\n            throw HttpException(\"Invalid proxy configuration $configuration\");\n          }\n          String host = proxy.substring(0, colon).trim();\n          if (host.startsWith(\"[\") && host.endsWith(\"]\")) {\n            host = host.substring(1, host.length - 1);\n          }\n          String portString = proxy.substring(colon + 1).trim();\n          int port;\n          try {\n            port = int.parse(portString);\n          } on FormatException {\n            throw HttpException(\"Invalid proxy configuration $configuration, \"\n                \"invalid port '$portString'\");\n          }\n          proxies.add(_Proxy(host, port, username, password));\n        } else if (proxy.trim() == DIRECT_PREFIX) {\n          proxies.add(_Proxy.direct());\n        } else {\n          throw HttpException(\"Invalid proxy configuration $configuration\");\n        }\n      }\n    }\n  }\n\n  const _ProxyConfiguration.direct() : proxies = const [_Proxy.direct()];\n\n  final List<_Proxy> proxies;\n}\n\nclass _Proxy {\n  final String? host;\n  final int? port;\n  final String? username;\n  final String? password;\n  final bool isDirect;\n\n  const _Proxy(String this.host, int this.port, this.username, this.password)\n      : isDirect = false;\n  const _Proxy.direct()\n      : host = null,\n        port = null,\n        username = null,\n        password = null,\n        isDirect = true;\n\n  bool get isAuthenticated => username != null;\n}\n\nclass _HttpConnectionInfo implements HttpConnectionInfo {\n  InternetAddress remoteAddress;\n  int remotePort;\n  int localPort;\n\n  _HttpConnectionInfo(this.remoteAddress, this.remotePort, this.localPort);\n\n  static _HttpConnectionInfo? create(Socket socket) {\n    if (socket == null) return null;\n    try {\n      return _HttpConnectionInfo(\n          socket.remoteAddress, socket.remotePort, socket.port);\n    } catch (e) {}\n    return null;\n  }\n}\n\nclass _DetachedSocket extends Stream<Uint8List> implements Socket {\n  final Stream<Uint8List> _incoming;\n  final Socket _socket;\n\n  _DetachedSocket(this._socket, this._incoming);\n\n  StreamSubscription<Uint8List> listen(void Function(Uint8List event)? onData,\n      {Function? onError, void Function()? onDone, bool? cancelOnError}) {\n    return _incoming.listen(onData,\n        onError: onError, onDone: onDone, cancelOnError: cancelOnError);\n  }\n\n  Encoding get encoding => _socket.encoding;\n\n  void set encoding(Encoding value) {\n    _socket.encoding = value;\n  }\n\n  void write(Object? obj) {\n    _socket.write(obj);\n  }\n\n  void writeln([Object? obj = \"\"]) {\n    _socket.writeln(obj);\n  }\n\n  void writeCharCode(int charCode) {\n    _socket.writeCharCode(charCode);\n  }\n\n  void writeAll(Iterable objects, [String separator = \"\"]) {\n    _socket.writeAll(objects, separator);\n  }\n\n  void add(List<int> bytes) {\n    _socket.add(bytes);\n  }\n\n  void addError(Object error, [StackTrace? stackTrace]) =>\n      _socket.addError(error, stackTrace);\n\n  Future addStream(Stream<List<int>> stream) {\n    return _socket.addStream(stream);\n  }\n\n  void destroy() {\n    _socket.destroy();\n  }\n\n  Future flush() => _socket.flush();\n\n  Future close() => _socket.close();\n\n  Future get done => _socket.done;\n\n  int get port => _socket.port;\n\n  InternetAddress get address => _socket.address;\n\n  InternetAddress get remoteAddress => _socket.remoteAddress;\n\n  int get remotePort => _socket.remotePort;\n\n  bool setOption(SocketOption option, bool enabled) {\n    return _socket.setOption(option, enabled);\n  }\n\n  Uint8List getRawOption(RawSocketOption option) {\n    return _socket.getRawOption(option);\n  }\n\n  void setRawOption(RawSocketOption option) {\n    _socket.setRawOption(option);\n  }\n\n  Map _toJSON(bool ref) {\n    return (_socket as dynamic)._toJSON(ref);\n  }\n}\n\nclass _AuthenticationScheme {\n  final int _scheme;\n\n  static const UNKNOWN = _AuthenticationScheme(-1);\n  static const BASIC = _AuthenticationScheme(0);\n  static const DIGEST = _AuthenticationScheme(1);\n\n  const _AuthenticationScheme(this._scheme);\n\n  factory _AuthenticationScheme.fromString(String scheme) {\n    if (scheme.toLowerCase() == \"basic\") return BASIC;\n    if (scheme.toLowerCase() == \"digest\") return DIGEST;\n    return UNKNOWN;\n  }\n\n  String toString() {\n    if (this == BASIC) return \"Basic\";\n    if (this == DIGEST) return \"Digest\";\n    return \"Unknown\";\n  }\n}\n\nabstract class _Credentials {\n  _HttpClientCredentials credentials;\n  String realm;\n  bool used = false;\n\n  // Digest specific fields.\n  String? ha1;\n  String? nonce;\n  String? algorithm;\n  String? qop;\n  int? nonceCount;\n\n  _Credentials(this.credentials, this.realm) {\n    if (credentials.scheme == _AuthenticationScheme.DIGEST) {\n      // Calculate the H(A1) value once. There is no mentioning of\n      // username/password encoding in RFC 2617. However there is an\n      // open draft for adding an additional accept-charset parameter to\n      // the WWW-Authenticate and Proxy-Authenticate headers, see\n      // http://tools.ietf.org/html/draft-reschke-basicauth-enc-06. For\n      // now always use UTF-8 encoding.\n      var creds = credentials as _HttpClientDigestCredentials;\n      var hasher = _MD5()\n        ..add(utf8.encode(creds.username))\n        ..add([_CharCode.COLON])\n        ..add(realm.codeUnits)\n        ..add([_CharCode.COLON])\n        ..add(utf8.encode(creds.password));\n      ha1 = _CryptoUtils.bytesToHex(hasher.close());\n    }\n  }\n\n  _AuthenticationScheme get scheme => credentials.scheme;\n\n  void authorize(HttpClientRequest request);\n}\n\nclass _SiteCredentials extends _Credentials {\n  Uri uri;\n\n  _SiteCredentials(this.uri, realm, _HttpClientCredentials creds)\n      : super(creds, realm);\n\n  bool applies(Uri uri, _AuthenticationScheme? scheme) {\n    if (scheme != null && credentials.scheme != scheme) return false;\n    if (uri.host != this.uri.host) return false;\n    int thisPort =\n        this.uri.port == 0 ? HttpClient.defaultHttpPort : this.uri.port;\n    int otherPort = uri.port == 0 ? HttpClient.defaultHttpPort : uri.port;\n    if (otherPort != thisPort) return false;\n    return uri.path.startsWith(this.uri.path);\n  }\n\n  void authorize(HttpClientRequest request) {\n    // Digest credentials cannot be used without a nonce from the\n    // server.\n    if (credentials.scheme == _AuthenticationScheme.DIGEST && nonce == null) {\n      return;\n    }\n    credentials.authorize(this, request as _HttpClientRequest);\n    used = true;\n  }\n}\n\nclass _ProxyCredentials extends _Credentials {\n  String host;\n  int port;\n\n  _ProxyCredentials(this.host, this.port, realm, _HttpClientCredentials creds)\n      : super(creds, realm);\n\n  bool applies(_Proxy proxy, _AuthenticationScheme? scheme) {\n    if (scheme != null && credentials.scheme != scheme) return false;\n    return proxy.host == host && proxy.port == port;\n  }\n\n  void authorize(HttpClientRequest request) {\n    // Digest credentials cannot be used without a nonce from the\n    // server.\n    if (credentials.scheme == _AuthenticationScheme.DIGEST && nonce == null) {\n      return;\n    }\n    credentials.authorizeProxy(this, request as _HttpClientRequest);\n  }\n}\n\nabstract class _HttpClientCredentials implements HttpClientCredentials {\n  _AuthenticationScheme get scheme;\n  void authorize(_Credentials credentials, _HttpClientRequest request);\n  void authorizeProxy(_ProxyCredentials credentials, HttpClientRequest request);\n}\n\nclass _HttpClientBasicCredentials extends _HttpClientCredentials\n    implements HttpClientBasicCredentials {\n  String username;\n  String password;\n\n  _HttpClientBasicCredentials(this.username, this.password);\n\n  _AuthenticationScheme get scheme => _AuthenticationScheme.BASIC;\n\n  String authorization() {\n    // There is no mentioning of username/password encoding in RFC\n    // 2617. However there is an open draft for adding an additional\n    // accept-charset parameter to the WWW-Authenticate and\n    // Proxy-Authenticate headers, see\n    // http://tools.ietf.org/html/draft-reschke-basicauth-enc-06. For\n    // now always use UTF-8 encoding.\n    String auth = base64Encode(utf8.encode(\"$username:$password\"));\n    return \"Basic $auth\";\n  }\n\n  void authorize(_Credentials _, HttpClientRequest request) {\n    request.headers.set(HttpHeaders.authorizationHeader, authorization());\n  }\n\n  void authorizeProxy(_ProxyCredentials _, HttpClientRequest request) {\n    request.headers.set(HttpHeaders.proxyAuthorizationHeader, authorization());\n  }\n}\n\nclass _HttpClientDigestCredentials extends _HttpClientCredentials\n    implements HttpClientDigestCredentials {\n  String username;\n  String password;\n\n  _HttpClientDigestCredentials(this.username, this.password);\n\n  _AuthenticationScheme get scheme => _AuthenticationScheme.DIGEST;\n\n  String authorization(_Credentials credentials, _HttpClientRequest request) {\n    String requestUri = request._requestUri();\n    _MD5 hasher = _MD5()\n      ..add(request.method.codeUnits)\n      ..add([_CharCode.COLON])\n      ..add(requestUri.codeUnits);\n    var ha2 = _CryptoUtils.bytesToHex(hasher.close());\n\n    bool isAuth = false;\n    String cnonce = \"\";\n    String nc = \"\";\n    hasher = _MD5()\n      ..add(credentials.ha1!.codeUnits)\n      ..add([_CharCode.COLON]);\n    if (credentials.qop == \"auth\") {\n      isAuth = true;\n      cnonce = _CryptoUtils.bytesToHex(_CryptoUtils.getRandomBytes(4));\n      var nonceCount = credentials.nonceCount! + 1;\n      credentials.nonceCount = nonceCount;\n      nc = nonceCount.toRadixString(16).padLeft(9, \"0\");\n      hasher\n        ..add(credentials.nonce!.codeUnits)\n        ..add([_CharCode.COLON])\n        ..add(nc.codeUnits)\n        ..add([_CharCode.COLON])\n        ..add(cnonce.codeUnits)\n        ..add([_CharCode.COLON])\n        ..add(\"auth\".codeUnits)\n        ..add([_CharCode.COLON])\n        ..add(ha2.codeUnits);\n    } else {\n      hasher\n        ..add(credentials.nonce!.codeUnits)\n        ..add([_CharCode.COLON])\n        ..add(ha2.codeUnits);\n    }\n    var response = _CryptoUtils.bytesToHex(hasher.close());\n\n    StringBuffer buffer = StringBuffer()\n      ..write('Digest ')\n      ..write('username=\"$username\"')\n      ..write(', realm=\"${credentials.realm}\"')\n      ..write(', nonce=\"${credentials.nonce}\"')\n      ..write(', uri=\"$requestUri\"')\n      ..write(', algorithm=\"${credentials.algorithm}\"');\n    if (isAuth) {\n      buffer\n        ..write(', qop=\"auth\"')\n        ..write(', cnonce=\"$cnonce\"')\n        ..write(', nc=\"$nc\"');\n    }\n    buffer.write(', response=\"$response\"');\n    return buffer.toString();\n  }\n\n  void authorize(_Credentials credentials, HttpClientRequest request) {\n    request.headers.set(HttpHeaders.authorizationHeader,\n        authorization(credentials, request as _HttpClientRequest));\n  }\n\n  void authorizeProxy(\n      _ProxyCredentials credentials, HttpClientRequest request) {\n    request.headers.set(HttpHeaders.proxyAuthorizationHeader,\n        authorization(credentials, request as _HttpClientRequest));\n  }\n}\n\nclass _RedirectInfo implements RedirectInfo {\n  final int statusCode;\n  final String method;\n  final Uri location;\n  const _RedirectInfo(this.statusCode, this.method, this.location);\n}\n\nString _getHttpVersion() {\n  var version = Platform.version;\n  // Only include major and minor version numbers.\n  int index = version.indexOf('.', version.indexOf('.') + 1);\n  version = version.substring(0, index);\n  return 'Dart/$version (dart:io)';\n}\n", "// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n//\n\nimport \"package:expect/expect.dart\";\nimport \"dart:async\";\nimport \"dart:io\";\n\nFuture<HttpServer> setupServer() {\n  final completer = new Completer<HttpServer>();\n  HttpServer.bind(\"127.0.0.1\", 0).then((server) {\n    var handlers = new Map<String, Function>();\n    addRequestHandler(\n        String path, void handler(HttpRequest request, HttpResponse response)) {\n      handlers[path] = handler;\n    }\n\n    server.listen((HttpRequest request) {\n      if (handlers.containsKey(request.uri.path)) {\n        handlers[request.uri.path]!(request, request.response);\n      } else {\n        request.listen((_) {}, onDone: () {\n          request.response.statusCode = 404;\n          request.response.close();\n        });\n      }\n    });\n\n    void addRedirectHandler(int number, int statusCode) {\n      addRequestHandler(\"/$number\",\n          (HttpRequest request, HttpResponse response) {\n        response.redirect(\n            Uri.parse(\"http://127.0.0.1:${server.port}/${number + 1}\"));\n      });\n    }\n\n    // Setup simple redirect.\n    addRequestHandler(\"/redirect\",\n        (HttpRequest request, HttpResponse response) {\n      response.redirect(Uri.parse(\"http://127.0.0.1:${server.port}/location\"),\n          status: HttpStatus.movedPermanently);\n    });\n    addRequestHandler(\"/location\",\n        (HttpRequest request, HttpResponse response) {\n      response.close();\n    });\n\n    // Setup redirects with relative url.\n    addRequestHandler(\"/redirectUrl\",\n        (HttpRequest request, HttpResponse response) {\n      response.headers.set(HttpHeaders.locationHeader, \"/some/relativeUrl\");\n      response.statusCode = HttpStatus.movedPermanently;\n      response.close();\n    });\n\n    addRequestHandler(\"/some/redirectUrl\",\n        (HttpRequest request, HttpResponse response) {\n      response.headers.set(HttpHeaders.locationHeader, \"relativeUrl\");\n      response.statusCode = HttpStatus.movedPermanently;\n      response.close();\n    });\n\n    addRequestHandler(\"/some/relativeUrl\",\n        (HttpRequest request, HttpResponse response) {\n      response.close();\n    });\n\n    addRequestHandler(\"/some/relativeToAbsolute\",\n        (HttpRequest request, HttpResponse response) {\n      response.redirect(Uri.parse(\"xxx\"), status: HttpStatus.seeOther);\n    });\n\n    addRequestHandler(\"/redirectUrl2\",\n        (HttpRequest request, HttpResponse response) {\n      response.headers.set(HttpHeaders.locationHeader, \"location\");\n      response.statusCode = HttpStatus.movedPermanently;\n      response.close();\n    });\n\n    addRequestHandler(\"/redirectUrl3\",\n        (HttpRequest request, HttpResponse response) {\n      response.headers.set(HttpHeaders.locationHeader, \"./location\");\n      response.statusCode = HttpStatus.movedPermanently;\n      response.close();\n    });\n\n    addRequestHandler(\"/redirectUrl4\",\n        (HttpRequest request, HttpResponse response) {\n      response.headers.set(HttpHeaders.locationHeader, \"./a/b/../../location\");\n      response.statusCode = HttpStatus.movedPermanently;\n      response.close();\n    });\n\n    addRequestHandler(\"/redirectUrl5\",\n        (HttpRequest request, HttpResponse response) {\n      response.headers.set(\n          HttpHeaders.locationHeader, \"//127.0.0.1:${server.port}/location\");\n      response.statusCode = HttpStatus.movedPermanently;\n      response.close();\n    });\n\n    // Setup redirect chain.\n    int n = 1;\n    addRedirectHandler(n++, HttpStatus.movedPermanently);\n    addRedirectHandler(n++, HttpStatus.movedTemporarily);\n    addRedirectHandler(n++, HttpStatus.seeOther);\n    addRedirectHandler(n++, HttpStatus.temporaryRedirect);\n    addRedirectHandler(n++, HttpStatus.permanentRedirect);\n    for (int i = n; i < 10; i++) {\n      addRedirectHandler(i, HttpStatus.movedPermanently);\n    }\n\n    // Setup redirect loop.\n    addRequestHandler(\"/A\", (HttpRequest request, HttpResponse response) {\n      response.headers\n          .set(HttpHeaders.locationHeader, \"http://127.0.0.1:${server.port}/B\");\n      response.statusCode = HttpStatus.movedPermanently;\n      response.close();\n    });\n    addRequestHandler(\"/B\", (HttpRequest request, HttpResponse response) {\n      response.headers\n          .set(HttpHeaders.locationHeader, \"http://127.0.0.1:${server.port}/A\");\n      response.statusCode = HttpStatus.movedTemporarily;\n      response.close();\n    });\n\n    // Setup redirect checking headers.\n    addRequestHandler(\"/src\", (HttpRequest request, HttpResponse response) {\n      Expect.equals(\"value\", request.headers.value(\"X-Request-Header\"));\n      response.headers.set(\n          HttpHeaders.locationHeader, \"http://127.0.0.1:${server.port}/target\");\n      response.statusCode = HttpStatus.movedPermanently;\n      response.close();\n    });\n    addRequestHandler(\"/target\", (HttpRequest request, HttpResponse response) {\n      Expect.equals(\"value\", request.headers.value(\"X-Request-Header\"));\n      response.close();\n    });\n\n    // Setup redirect for 301 where POST should not redirect.\n    addRequestHandler(\"/301src\", (HttpRequest request, HttpResponse response) {\n      Expect.equals(\"POST\", request.method);\n      request.listen((_) {}, onDone: () {\n        response.headers.set(HttpHeaders.locationHeader,\n            \"http://127.0.0.1:${server.port}/301target\");\n        response.statusCode = HttpStatus.movedPermanently;\n        response.close();\n      });\n    });\n    addRequestHandler(\"/301target\",\n        (HttpRequest request, HttpResponse response) {\n      Expect.fail(\"Redirect of POST should not happen\");\n    });\n\n    // Setup redirect for 303 where POST should turn into GET.\n    addRequestHandler(\"/303src\", (HttpRequest request, HttpResponse response) {\n      request.listen((_) {}, onDone: () {\n        Expect.equals(\"POST\", request.method);\n        response.headers.set(HttpHeaders.locationHeader,\n            \"http://127.0.0.1:${server.port}/303target\");\n        response.statusCode = HttpStatus.seeOther;\n        response.close();\n      });\n    });\n    addRequestHandler(\"/303target\",\n        (HttpRequest request, HttpResponse response) {\n      Expect.equals(\"GET\", request.method);\n      response.close();\n    });\n\n    // Setup redirect where we close the connection.\n    addRequestHandler(\"/closing\", (HttpRequest request, HttpResponse response) {\n      response.headers\n          .set(HttpHeaders.locationHeader, \"http://127.0.0.1:${server.port}/\");\n      response.statusCode = HttpStatus.found;\n      response.persistentConnection = false;\n      response.close();\n    });\n\n    completer.complete(server);\n  });\n  return completer.future;\n}\n\nvoid checkRedirects(int redirectCount, HttpClientResponse response) {\n  if (redirectCount < 2) {\n    Expect.isTrue(response.redirects.isEmpty);\n  } else {\n    Expect.equals(redirectCount - 1, response.redirects.length);\n    for (int i = 0; i < redirectCount - 2; i++) {\n      Expect.equals(response.redirects[i].location.path, \"/${i + 2}\");\n    }\n  }\n}\n\nvoid testManualRedirect() {\n  setupServer().then((server) {\n    HttpClient client = new HttpClient();\n\n    int redirectCount = 0;\n    handleResponse(HttpClientResponse response) {\n      response.listen((_) => Expect.fail(\"Response data not expected\"),\n          onDone: () {\n        redirectCount++;\n        if (redirectCount < 10) {\n          Expect.isTrue(response.isRedirect);\n          checkRedirects(redirectCount, response);\n          response.redirect().then(handleResponse);\n        } else {\n          Expect.equals(HttpStatus.notFound, response.statusCode);\n          server.close();\n          client.close();\n        }\n      });\n    }\n\n    client\n        .getUrl(Uri.parse(\"http://127.0.0.1:${server.port}/1\"))\n        .then((HttpClientRequest request) {\n      request.followRedirects = false;\n      return request.close();\n    }).then(handleResponse);\n  });\n}\n\nvoid testManualRedirectWithHeaders() {\n  setupServer().then((server) {\n    HttpClient client = new HttpClient();\n\n    int redirectCount = 0;\n\n    handleResponse(HttpClientResponse response) {\n      response.listen((_) => Expect.fail(\"Response data not expected\"),\n          onDone: () {\n        redirectCount++;\n        if (redirectCount < 2) {\n          Expect.isTrue(response.isRedirect);\n          response.redirect().then(handleResponse);\n        } else {\n          Expect.equals(HttpStatus.ok, response.statusCode);\n          server.close();\n          client.close();\n        }\n      });\n    }\n\n    client\n        .getUrl(Uri.parse(\"http://127.0.0.1:${server.port}/src\"))\n        .then((HttpClientRequest request) {\n      request.followRedirects = false;\n      request.headers.add(\"X-Request-Header\", \"value\");\n      return request.close();\n    }).then(handleResponse);\n  });\n}\n\nvoid testAutoRedirect() {\n  setupServer().then((server) {\n    HttpClient client = new HttpClient();\n\n    client\n        .getUrl(Uri.parse(\"http://127.0.0.1:${server.port}/redirect\"))\n        .then((HttpClientRequest request) {\n      return request.close();\n    }).then((HttpClientResponse response) {\n      response.listen((_) => Expect.fail(\"Response data not expected\"),\n          onDone: () {\n        Expect.equals(1, response.redirects.length);\n        server.close();\n        client.close();\n      });\n    });\n  });\n}\n\nvoid testAutoRedirectWithHeaders() {\n  setupServer().then((server) {\n    HttpClient client = new HttpClient();\n\n    client\n        .getUrl(Uri.parse(\"http://127.0.0.1:${server.port}/src\"))\n        .then((HttpClientRequest request) {\n      request.headers.add(\"X-Request-Header\", \"value\");\n      return request.close();\n    }).then((HttpClientResponse response) {\n      response.listen((_) => Expect.fail(\"Response data not expected\"),\n          onDone: () {\n        Expect.equals(1, response.redirects.length);\n        server.close();\n        client.close();\n      });\n    });\n  });\n}\n\nvoid testAutoRedirect301POST() {\n  setupServer().then((server) {\n    HttpClient client = new HttpClient();\n\n    client\n        .postUrl(Uri.parse(\"http://127.0.0.1:${server.port}/301src\"))\n        .then((HttpClientRequest request) {\n      return request.close();\n    }).then((HttpClientResponse response) {\n      Expect.equals(HttpStatus.movedPermanently, response.statusCode);\n      response.listen((_) => Expect.fail(\"Response data not expected\"),\n          onDone: () {\n        Expect.equals(0, response.redirects.length);\n        server.close();\n        client.close();\n      });\n    });\n  });\n}\n\nvoid testAutoRedirect303POST() {\n  setupServer().then((server) {\n    HttpClient client = new HttpClient();\n\n    client\n        .postUrl(Uri.parse(\"http://127.0.0.1:${server.port}/303src\"))\n        .then((HttpClientRequest request) {\n      return request.close();\n    }).then((HttpClientResponse response) {\n      Expect.equals(HttpStatus.ok, response.statusCode);\n      response.listen((_) => Expect.fail(\"Response data not expected\"),\n          onDone: () {\n        Expect.equals(1, response.redirects.length);\n        server.close();\n        client.close();\n      });\n    });\n  });\n}\n\nvoid testAutoRedirectLimit() {\n  setupServer().then((server) {\n    HttpClient client = new HttpClient();\n\n    Future<HttpClientResponse?>.value(client\n            .getUrl(Uri.parse(\"http://127.0.0.1:${server.port}/1\"))\n            .then((HttpClientRequest request) => request.close()))\n        .catchError((error) {\n      Expect.equals(5, error.redirects.length);\n      server.close();\n      client.close();\n    }, test: (e) => e is RedirectException);\n  });\n}\n\nvoid testRedirectLoop() {\n  setupServer().then((server) {\n    HttpClient client = new HttpClient();\n\n    int redirectCount = 0;\n    Future<HttpClientResponse?>.value(client\n            .getUrl(Uri.parse(\"http://127.0.0.1:${server.port}/A\"))\n            .then((HttpClientRequest request) => request.close()))\n        .catchError((error) {\n      Expect.equals(2, error.redirects.length);\n      server.close();\n      client.close();\n    }, test: (e) => e is RedirectException);\n  });\n}\n\nvoid testRedirectClosingConnection() {\n  setupServer().then((server) {\n    HttpClient client = new HttpClient();\n\n    client\n        .getUrl(Uri.parse(\"http://127.0.0.1:${server.port}/closing\"))\n        .then((request) => request.close())\n        .then((response) {\n      response.listen((_) {}, onDone: () {\n        Expect.equals(1, response.redirects.length);\n        server.close();\n        client.close();\n      });\n    });\n  });\n}\n\nvoid testRedirectRelativeUrl() {\n  testPath(String path) {\n    setupServer().then((server) {\n      HttpClient client = new HttpClient();\n\n      print(path);\n      client\n          .getUrl(Uri.parse(\"http://127.0.0.1:${server.port}$path\"))\n          .then((request) => request.close())\n          .then((response) {\n        response.listen((_) {}, onDone: () {\n          Expect.equals(HttpStatus.ok, response.statusCode);\n          Expect.equals(1, response.redirects.length);\n          server.close();\n          client.close();\n        });\n      });\n    });\n  }\n\n  testPath(\"/redirectUrl\");\n  testPath(\"/some/redirectUrl\");\n  testPath(\"/redirectUrl2\");\n  testPath(\"/redirectUrl3\");\n  testPath(\"/redirectUrl4\");\n  testPath(\"/redirectUrl5\");\n}\n\nvoid testRedirectRelativeToAbsolute() {\n  setupServer().then((server) {\n    HttpClient client = new HttpClient();\n\n    int redirectCount = 0;\n    handleResponse(HttpClientResponse response) {\n      response.listen((_) => Expect.fail(\"Response data not expected\"),\n          onDone: () {\n        Expect.equals(HttpStatus.seeOther, response.statusCode);\n        Expect.equals(\"xxx\", response.headers[\"Location\"]![0]);\n        Expect.isTrue(response.isRedirect);\n        server.close();\n        client.close();\n      });\n    }\n\n    client\n        .getUrl(Uri.parse(\n            \"http://127.0.0.1:${server.port}/some/relativeToAbsolute\"))\n        .then((HttpClientRequest request) {\n      request.followRedirects = false;\n      return request.close();\n    }).then(handleResponse);\n  });\n}\n\nmain() {\n  testManualRedirect();\n  testManualRedirectWithHeaders();\n  testAutoRedirect();\n  testAutoRedirectWithHeaders();\n  testAutoRedirect301POST();\n  testAutoRedirect303POST();\n  testAutoRedirectLimit();\n  testRedirectLoop();\n  testRedirectClosingConnection();\n  testRedirectRelativeUrl();\n  testRedirectRelativeToAbsolute();\n}\n", "// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n//\n\n// @dart = 2.9\n\nimport \"package:expect/expect.dart\";\nimport \"dart:async\";\nimport \"dart:io\";\n\nFuture<HttpServer> setupServer() {\n  Completer completer = new Completer<HttpServer>();\n  HttpServer.bind(\"127.0.0.1\", 0).then((server) {\n    var handlers = new Map<String, Function>();\n    addRequestHandler(\n        String path, void handler(HttpRequest request, HttpResponse response)) {\n      handlers[path] = handler;\n    }\n\n    server.listen((HttpRequest request) {\n      if (handlers.containsKey(request.uri.path)) {\n        handlers[request.uri.path](request, request.response);\n      } else {\n        request.listen((_) {}, onDone: () {\n          request.response.statusCode = 404;\n          request.response.close();\n        });\n      }\n    });\n\n    void addRedirectHandler(int number, int statusCode) {\n      addRequestHandler(\"/$number\",\n          (HttpRequest request, HttpResponse response) {\n        response.redirect(\n            Uri.parse(\"http://127.0.0.1:${server.port}/${number + 1}\"));\n      });\n    }\n\n    // Setup simple redirect.\n    addRequestHandler(\"/redirect\",\n        (HttpRequest request, HttpResponse response) {\n      response.redirect(Uri.parse(\"http://127.0.0.1:${server.port}/location\"),\n          status: HttpStatus.movedPermanently);\n    });\n    addRequestHandler(\"/location\",\n        (HttpRequest request, HttpResponse response) {\n      response.close();\n    });\n\n    // Setup redirects with relative url.\n    addRequestHandler(\"/redirectUrl\",\n        (HttpRequest request, HttpResponse response) {\n      response.headers.set(HttpHeaders.locationHeader, \"/some/relativeUrl\");\n      response.statusCode = HttpStatus.movedPermanently;\n      response.close();\n    });\n\n    addRequestHandler(\"/some/redirectUrl\",\n        (HttpRequest request, HttpResponse response) {\n      response.headers.set(HttpHeaders.locationHeader, \"relativeUrl\");\n      response.statusCode = HttpStatus.movedPermanently;\n      response.close();\n    });\n\n    addRequestHandler(\"/some/relativeUrl\",\n        (HttpRequest request, HttpResponse response) {\n      response.close();\n    });\n\n    addRequestHandler(\"/some/relativeToAbsolute\",\n        (HttpRequest request, HttpResponse response) {\n      response.redirect(Uri.parse(\"xxx\"), status: HttpStatus.seeOther);\n    });\n\n    addRequestHandler(\"/redirectUrl2\",\n        (HttpRequest request, HttpResponse response) {\n      response.headers.set(HttpHeaders.locationHeader, \"location\");\n      response.statusCode = HttpStatus.movedPermanently;\n      response.close();\n    });\n\n    addRequestHandler(\"/redirectUrl3\",\n        (HttpRequest request, HttpResponse response) {\n      response.headers.set(HttpHeaders.locationHeader, \"./location\");\n      response.statusCode = HttpStatus.movedPermanently;\n      response.close();\n    });\n\n    addRequestHandler(\"/redirectUrl4\",\n        (HttpRequest request, HttpResponse response) {\n      response.headers.set(HttpHeaders.locationHeader, \"./a/b/../../location\");\n      response.statusCode = HttpStatus.movedPermanently;\n      response.close();\n    });\n\n    addRequestHandler(\"/redirectUrl5\",\n        (HttpRequest request, HttpResponse response) {\n      response.headers.set(\n          HttpHeaders.locationHeader, \"//127.0.0.1:${server.port}/location\");\n      response.statusCode = HttpStatus.movedPermanently;\n      response.close();\n    });\n\n    // Setup redirect chain.\n    int n = 1;\n    addRedirectHandler(n++, HttpStatus.movedPermanently);\n    addRedirectHandler(n++, HttpStatus.movedTemporarily);\n    addRedirectHandler(n++, HttpStatus.seeOther);\n    addRedirectHandler(n++, HttpStatus.temporaryRedirect);\n    addRedirectHandler(n++, HttpStatus.permanentRedirect);\n    for (int i = n; i < 10; i++) {\n      addRedirectHandler(i, HttpStatus.movedPermanently);\n    }\n\n    // Setup redirect loop.\n    addRequestHandler(\"/A\", (HttpRequest request, HttpResponse response) {\n      response.headers\n          .set(HttpHeaders.locationHeader, \"http://127.0.0.1:${server.port}/B\");\n      response.statusCode = HttpStatus.movedPermanently;\n      response.close();\n    });\n    addRequestHandler(\"/B\", (HttpRequest request, HttpResponse response) {\n      response.headers\n          .set(HttpHeaders.locationHeader, \"http://127.0.0.1:${server.port}/A\");\n      response.statusCode = HttpStatus.movedTemporarily;\n      response.close();\n    });\n\n    // Setup redirect checking headers.\n    addRequestHandler(\"/src\", (HttpRequest request, HttpResponse response) {\n      Expect.equals(\"value\", request.headers.value(\"X-Request-Header\"));\n      response.headers.set(\n          HttpHeaders.locationHeader, \"http://127.0.0.1:${server.port}/target\");\n      response.statusCode = HttpStatus.movedPermanently;\n      response.close();\n    });\n    addRequestHandler(\"/target\", (HttpRequest request, HttpResponse response) {\n      Expect.equals(\"value\", request.headers.value(\"X-Request-Header\"));\n      response.close();\n    });\n\n    // Setup redirect for 301 where POST should not redirect.\n    addRequestHandler(\"/301src\", (HttpRequest request, HttpResponse response) {\n      Expect.equals(\"POST\", request.method);\n      request.listen((_) {}, onDone: () {\n        response.headers.set(HttpHeaders.locationHeader,\n            \"http://127.0.0.1:${server.port}/301target\");\n        response.statusCode = HttpStatus.movedPermanently;\n        response.close();\n      });\n    });\n    addRequestHandler(\"/301target\",\n        (HttpRequest request, HttpResponse response) {\n      Expect.fail(\"Redirect of POST should not happen\");\n    });\n\n    // Setup redirect for 303 where POST should turn into GET.\n    addRequestHandler(\"/303src\", (HttpRequest request, HttpResponse response) {\n      request.listen((_) {}, onDone: () {\n        Expect.equals(\"POST\", request.method);\n        response.headers.set(HttpHeaders.locationHeader,\n            \"http://127.0.0.1:${server.port}/303target\");\n        response.statusCode = HttpStatus.seeOther;\n        response.close();\n      });\n    });\n    addRequestHandler(\"/303target\",\n        (HttpRequest request, HttpResponse response) {\n      Expect.equals(\"GET\", request.method);\n      response.close();\n    });\n\n    // Setup redirect where we close the connection.\n    addRequestHandler(\"/closing\", (HttpRequest request, HttpResponse response) {\n      response.headers\n          .set(HttpHeaders.locationHeader, \"http://127.0.0.1:${server.port}/\");\n      response.statusCode = HttpStatus.found;\n      response.persistentConnection = false;\n      response.close();\n    });\n\n    completer.complete(server);\n  });\n  return completer.future;\n}\n\nvoid checkRedirects(int redirectCount, HttpClientResponse response) {\n  if (redirectCount < 2) {\n    Expect.isTrue(response.redirects.isEmpty);\n  } else {\n    Expect.equals(redirectCount - 1, response.redirects.length);\n    for (int i = 0; i < redirectCount - 2; i++) {\n      Expect.equals(response.redirects[i].location.path, \"/${i + 2}\");\n    }\n  }\n}\n\nvoid testManualRedirect() {\n  setupServer().then((server) {\n    HttpClient client = new HttpClient();\n\n    int redirectCount = 0;\n    handleResponse(HttpClientResponse response) {\n      response.listen((_) => Expect.fail(\"Response data not expected\"),\n          onDone: () {\n        redirectCount++;\n        if (redirectCount < 10) {\n          Expect.isTrue(response.isRedirect);\n          checkRedirects(redirectCount, response);\n          response.redirect().then(handleResponse);\n        } else {\n          Expect.equals(HttpStatus.notFound, response.statusCode);\n          server.close();\n          client.close();\n        }\n      });\n    }\n\n    client\n        .getUrl(Uri.parse(\"http://127.0.0.1:${server.port}/1\"))\n        .then((HttpClientRequest request) {\n      request.followRedirects = false;\n      return request.close();\n    }).then(handleResponse);\n  });\n}\n\nvoid testManualRedirectWithHeaders() {\n  setupServer().then((server) {\n    HttpClient client = new HttpClient();\n\n    int redirectCount = 0;\n\n    handleResponse(HttpClientResponse response) {\n      response.listen((_) => Expect.fail(\"Response data not expected\"),\n          onDone: () {\n        redirectCount++;\n        if (redirectCount < 2) {\n          Expect.isTrue(response.isRedirect);\n          response.redirect().then(handleResponse);\n        } else {\n          Expect.equals(HttpStatus.ok, response.statusCode);\n          server.close();\n          client.close();\n        }\n      });\n    }\n\n    client\n        .getUrl(Uri.parse(\"http://127.0.0.1:${server.port}/src\"))\n        .then((HttpClientRequest request) {\n      request.followRedirects = false;\n      request.headers.add(\"X-Request-Header\", \"value\");\n      return request.close();\n    }).then(handleResponse);\n  });\n}\n\nvoid testAutoRedirect() {\n  setupServer().then((server) {\n    HttpClient client = new HttpClient();\n\n    client\n        .getUrl(Uri.parse(\"http://127.0.0.1:${server.port}/redirect\"))\n        .then((HttpClientRequest request) {\n      return request.close();\n    }).then((HttpClientResponse response) {\n      response.listen((_) => Expect.fail(\"Response data not expected\"),\n          onDone: () {\n        Expect.equals(1, response.redirects.length);\n        server.close();\n        client.close();\n      });\n    });\n  });\n}\n\nvoid testAutoRedirectWithHeaders() {\n  setupServer().then((server) {\n    HttpClient client = new HttpClient();\n\n    client\n        .getUrl(Uri.parse(\"http://127.0.0.1:${server.port}/src\"))\n        .then((HttpClientRequest request) {\n      request.headers.add(\"X-Request-Header\", \"value\");\n      return request.close();\n    }).then((HttpClientResponse response) {\n      response.listen((_) => Expect.fail(\"Response data not expected\"),\n          onDone: () {\n        Expect.equals(1, response.redirects.length);\n        server.close();\n        client.close();\n      });\n    });\n  });\n}\n\nvoid testAutoRedirect301POST() {\n  setupServer().then((server) {\n    HttpClient client = new HttpClient();\n\n    client\n        .postUrl(Uri.parse(\"http://127.0.0.1:${server.port}/301src\"))\n        .then((HttpClientRequest request) {\n      return request.close();\n    }).then((HttpClientResponse response) {\n      Expect.equals(HttpStatus.movedPermanently, response.statusCode);\n      response.listen((_) => Expect.fail(\"Response data not expected\"),\n          onDone: () {\n        Expect.equals(0, response.redirects.length);\n        server.close();\n        client.close();\n      });\n    });\n  });\n}\n\nvoid testAutoRedirect303POST() {\n  setupServer().then((server) {\n    HttpClient client = new HttpClient();\n\n    client\n        .postUrl(Uri.parse(\"http://127.0.0.1:${server.port}/303src\"))\n        .then((HttpClientRequest request) {\n      return request.close();\n    }).then((HttpClientResponse response) {\n      Expect.equals(HttpStatus.ok, response.statusCode);\n      response.listen((_) => Expect.fail(\"Response data not expected\"),\n          onDone: () {\n        Expect.equals(1, response.redirects.length);\n        server.close();\n        client.close();\n      });\n    });\n  });\n}\n\nvoid testAutoRedirectLimit() {\n  setupServer().then((server) {\n    HttpClient client = new HttpClient();\n\n    client\n        .getUrl(Uri.parse(\"http://127.0.0.1:${server.port}/1\"))\n        .then((HttpClientRequest request) => request.close())\n        .catchError((error) {\n      Expect.equals(5, error.redirects.length);\n      server.close();\n      client.close();\n    }, test: (e) => e is RedirectException);\n  });\n}\n\nvoid testRedirectLoop() {\n  setupServer().then((server) {\n    HttpClient client = new HttpClient();\n\n    int redirectCount = 0;\n    client\n        .getUrl(Uri.parse(\"http://127.0.0.1:${server.port}/A\"))\n        .then((HttpClientRequest request) => request.close())\n        .catchError((error) {\n      Expect.equals(2, error.redirects.length);\n      server.close();\n      client.close();\n    }, test: (e) => e is RedirectException);\n  });\n}\n\nvoid testRedirectClosingConnection() {\n  setupServer().then((server) {\n    HttpClient client = new HttpClient();\n\n    client\n        .getUrl(Uri.parse(\"http://127.0.0.1:${server.port}/closing\"))\n        .then((request) => request.close())\n        .then((response) {\n      response.listen((_) {}, onDone: () {\n        Expect.equals(1, response.redirects.length);\n        server.close();\n        client.close();\n      });\n    });\n  });\n}\n\nvoid testRedirectRelativeUrl() {\n  testPath(String path) {\n    setupServer().then((server) {\n      HttpClient client = new HttpClient();\n\n      print(path);\n      client\n          .getUrl(Uri.parse(\"http://127.0.0.1:${server.port}$path\"))\n          .then((request) => request.close())\n          .then((response) {\n        response.listen((_) {}, onDone: () {\n          Expect.equals(HttpStatus.ok, response.statusCode);\n          Expect.equals(1, response.redirects.length);\n          server.close();\n          client.close();\n        });\n      });\n    });\n  }\n\n  testPath(\"/redirectUrl\");\n  testPath(\"/some/redirectUrl\");\n  testPath(\"/redirectUrl2\");\n  testPath(\"/redirectUrl3\");\n  testPath(\"/redirectUrl4\");\n  testPath(\"/redirectUrl5\");\n}\n\nvoid testRedirectRelativeToAbsolute() {\n  setupServer().then((server) {\n    HttpClient client = new HttpClient();\n\n    int redirectCount = 0;\n    handleResponse(HttpClientResponse response) {\n      response.listen((_) => Expect.fail(\"Response data not expected\"),\n          onDone: () {\n        Expect.equals(HttpStatus.seeOther, response.statusCode);\n        Expect.equals(\"xxx\", response.headers[\"Location\"][0]);\n        Expect.isTrue(response.isRedirect);\n        server.close();\n        client.close();\n      });\n    }\n\n    client\n        .getUrl(Uri.parse(\n            \"http://127.0.0.1:${server.port}/some/relativeToAbsolute\"))\n        .then((HttpClientRequest request) {\n      request.followRedirects = false;\n      return request.close();\n    }).then(handleResponse);\n  });\n}\n\nmain() {\n  testManualRedirect();\n  testManualRedirectWithHeaders();\n  testAutoRedirect();\n  testAutoRedirectWithHeaders();\n  testAutoRedirect301POST();\n  testAutoRedirect303POST();\n  testAutoRedirectLimit();\n  testRedirectLoop();\n  testRedirectClosingConnection();\n  testRedirectRelativeUrl();\n  testRedirectRelativeToAbsolute();\n}\n"], "fixing_code": ["## 2.17.0\n\n### Core libraries\n\n#### `dart:core`\n\n- Add `Finalizer` and `WeakReference` which can potentially detect when\n  objects are \"garbage collected\".\n\n#### `dart:ffi`\n\n- Add `ref=` and `[]=` methods to the `StructPointer` and `UnionPointer`\n  extensions. They copy a compound instance into a native memory region.\n\n#### `dart:indexed_db`\n\n- `IdbFactory.supportsDatabaseNames` has been deprecated. It will always return\n  `false`.\n\n#### `dart:io`\n\n- **Breaking Change** [#45410](https://github.com/dart-lang/sdk/issues/45410):\n  `HttpClient` no longer transmits some headers (i.e. `authorization`,\n  `www-authenticate`, `cookie`, `cookie2`) when processing redirects to\n  a different domain.\n\n### Tools\n\n#### Dart command line\n\n- **Breaking Change** [#46100](https://github.com/dart-lang/sdk/issues/46100):\n  The standalone `dart2js` tool has been\n  marked deprecated as previously announced.\n  Its replacement is the `dart compile js` command.\n  Should you find any issues, or missing features, in the replacement\n  command, kindly file [an issue][].\n\n[an issue]: https://github.com/dart-lang/sdk/issues/new\n\n- **Breaking Change** [#46100](https://github.com/dart-lang/sdk/issues/46100):\n  The standalone `dartdoc` tool has been removed as\n  previously announced. Its replacement is the `dart doc` command.\n\n## 2.16.0\n\n### Core libraries\n\n#### `dart:core`\n\n- Add `Error.throwWithStackTrace` which can `throw` an\n  error with an existing stack trace, instead of creating\n  a new stack trace.\n\n#### `dart:io`\n\n- **Breaking Change** [#47653](https://github.com/dart-lang/sdk/issues/47653):\nOn Windows, `Directory.rename` will no longer delete a directory if\n`newPath` specifies one. Instead, a `FileSystemException` will be thrown.\n\n- **Breaking Change** [#47769](https://github.com/dart-lang/sdk/issues/47769):\nThe `Platform.packageRoot` API has been removed. It had been marked deprecated\nin 2018, as it doesn't work with any Dart 2.x release.\n- Add optional `sourcePort` parameter to `Socket.connect`, `Socket.startConnect`, `RawSocket.connect` and `RawSocket.startConnect`\n\n#### `dart:isolate`\n\n- **Breaking Change** [#47769](https://github.com/dart-lang/sdk/issues/47769):\nThe `Isolate.packageRoot` API has been removed. It had been marked deprecated\nin 2018, as it doesn't work with any Dart 2.x release.\n\n### Tools\n\n#### Dart command line\n\n- **Breaking Change** [#46100](https://github.com/dart-lang/sdk/issues/46100):\n  The standalone `dartanalyzer` tool has been\n  marked deprecated as previously announced.\n  Its replacement is the `dart analyze` command.\n  Should you find any issues, or missing features, in the replacement\n  command, kindly file [an issue][].\n\n[an issue]: https://github.com/dart-lang/sdk/issues/new\n\n- **Breaking Change** [#46100](https://github.com/dart-lang/sdk/issues/46100):\n  The standalone `dartdoc` tool has been\n  marked deprecated as previously announced.\n  Its replacement is the `dart doc` command.\n  Should you find any issues, or missing features, in the replacement\n  command, kindly file [an issue][].\n\n[an issue]: https://github.com/dart-lang/sdk/issues/new\n\n#### Pub\n\n- Fixed race conditions in `dart pub get`, `dart run` and `dart pub global run`.\n  It should now be safe to run these concurrently.\n- If (when) Pub crashes it will save a verbose log in\n  `$PUB_CACHE/log/pub_log.txt` This can be used for filing issues to the issue\n  tracker.\n\n  `dart --verbose pub [command]` will also cause the log file to be written.\n- `dart pub add` can now add multiple packages in one command.\n\n#### Linter\n\nUpdated the Linter to `1.18.0`, which includes changes that\n\n- extends `camel_case_types` to cover enums.\n- fixes `no_leading_underscores_for_local_identifiers` to not \n  mis-flag field formal parameters with default values.\n- fixes `prefer_function_declarations_over_variables` to not\n  mis-flag non-final fields.\n- improves performance for `prefer_contains`.\n- updates `exhaustive_cases` to skip deprecated values that\n  redirect to other values.\n- adds new lint: `unnecessary_late`.\n- improves docs for `prefer_initializing_formals`.\n- updates `secure_pubspec_urls` to check `issue_tracker` and\n  `repository` entries.\n- adds new lint: `conditional_uri_does_not_exist`.\n- improves performance for\n  `missing_whitespace_between_adjacent_strings`.\n- adds new lint: `avoid_final_parameters`.\n- adds new lint: `no_leading_underscores_for_library_prefixes`.\n- adds new lint: `no_leading_underscores_for_local_identifiers`.\n- adds new lint: `secure_pubspec_urls`.\n- adds new lint: `sized_box_shrink_expand`.\n- adds new lint: `use_decorated_box`.\n- improves docs for `omit_local_variable_types`.\n\n## 2.15.1 - 2021-12-14\n\nThis is a patch release that fixes:\n\n- an AOT compilation failure in some Flutter apps (issue [#47878][]).\n- `dart pub publish` for servers with a path in the URL (pr\n  [dart-lang/pub#3244][]).\n\n[#47878]: https://github.com/dart-lang/sdk/issues/47878\n[dart-lang/pub#3244]: https://github.com/dart-lang/pub/pull/3244\n\n## 2.15.0 - 2021-12-08\n\n### Language\n\nThe following features are new in the Dart 2.15 [language version][]. To use\nthem, you must set the lower bound on the SDK constraint for your package to\n2.15 or greater (`sdk: '>=2.15.0 <3.0.0'`).\n\n[language version]: https://dart.dev/guides/language/evolution\n\n- **[Constructor tear-offs][]**: Previous Dart versions allowed a method on an\n  instance to be passed as a closure, and similarly for static methods. This is\n  commonly referred to as \"closurizing\" or \"tearing off\" a method. Constructors\n  were not previously eligible for closurization, forcing users to explicitly\n  write wrapper functions when using constructors as first class functions.\n  See the calls to `map()` in this example:\n\n  ```dart\n  class A {\n    int x;\n    A(this.x);\n    A.fromString(String s) : x = int.parse(s);\n  }\n\n  void main() {\n    var listOfInts = [1, 2, 3];\n    var listOfStrings = [\"1\", \"2\", \"3\"];\n    for(var a in listOfInts.map((x) => A(x))) {\n      print(a.x);\n    }\n    for(var a in listOfStrings.map((x) => A.fromString(x))) {\n      print(a.x);\n    }\n  }\n  ```\n\n  New in Dart 2.15, constructors are now allowed to be torn off. Named\n  constructors are closurized using their declared name (here `A.fromString`).\n  To closurize unnamed constructors, use the keyword `new` (here `A.new`).\n  The above example may now be written as:\n\n  ```dart\n  class A {\n    int x;\n    A(this.x);\n    A.fromString(String s) : x = int.parse(s);\n  }\n\n  void main() {\n    var listOfInts = [1, 2, 3];\n    var listOfStrings = [\"1\", \"2\", \"3\"];\n    for(A a in listOfInts.map(A.new)) {\n      print(a.x);\n    }\n    for(A a in listOfStrings.map(A.fromString)) {\n      print(a.x);\n    }\n  }\n  ```\n\n  Constructors for generic classes may be torn off as generic functions, or\n  instantiated at the tear-off site. In the following example, the tear-off\n  `G.new` is used to initialize the variable `f` produces a generic function\n  which may be used to produce an instance of `G<T>` for any type `T` provided\n  when `f` is called. The tear-off `G<String>.new` is used to initialize the\n  variable `g` to produce a non-generic function which may only be used\n  to produce instances of type `G<String>`.\n\n  ```dart\n  class G<T> {\n    T x;\n    G(this.x);\n  }\n\n  void main() {\n    G<T> Function<T>(T x) f = G.new;\n    var x = f<int>(3);\n    G<String> Function(String y) g = G<String>.new;\n    var y = g(\"hello\");\n  }\n  ```\n\n[constructor tear-offs]: https://github.com/dart-lang/language/blob/master/accepted/2.15/constructor-tearoffs/feature-specification.md\n\n- **[Generic type literals][explicit instantiation]**: Previous Dart versions\n  allowed class names to be used as type literals. So for example,`int` may be\n  used as an expression, producing a value of type `Type`. Generic classes (e.g.\n  `List`) could be referred to by name as an expression, but no type arguments\n  could be provided and so only the `dynamic` instantiation could be produced\n  directly as an expression without using indirect methods:\n\n  ```dart\n  // Workaround to capture generic type literals.\n  Type typeOf<T>() => T;\n\n  void main() {\n    var x = int; // The Type literal corresponding to `int`.\n    var y = List; // The Type literal corresponding to `List<dynamic>`.\n    // Use workaround to capture generic type literal.\n    var z = typeOf<List<int>>(); // The Type literal for `List<int>`.\n  }\n  ```\n\n  New in Dart 2.15, instantiations of generic classes may now be used as Type\n  literals:\n\n  ```dart\n  void main() {\n    var x = int; // The Type literal corresponding to `int`.\n    var y = List; // The Type literal corresponding to `List<dynamic>`.\n    var z = List<int>; // The Type literal corresponding to `List<int>`.\n  }\n  ```\n\n- **[Explicit generic method instantiations][explicit instantiation]**: Previous\n  Dart versions allowed generic methods to be implicitly specialized (or\n  \"instantiated\") to non-generic versions when assigned to a location with a\n  compatible monomorphic type. Example:\n\n  ```dart\n  // The generic identity function.\n  T id<T>(T x) => x;\n\n  void main() {\n    // Initialize `intId` with a version of `id` implicitly specialized to\n    // `int`.\n    int Function(int) intId = id;\n    print(intId(3));\n    // Initialize `stringId` with a version of `id` implicitly specialized to\n    // `String`.\n    String Function(String) stringId = id;\n    print(stringId(\"hello\"));\n  }\n  ```\n\n  New in Dart 2.15, generic methods may be explicitly instantiated using the\n  syntax `f<T>` where `f` is the generic method to specialize and `T` is the\n  type argument (in general, type arguments) to be used to specialize the\n  method. Example:\n\n  ```dart\n  // The generic identity function.\n  T id<T>(T x) => x;\n\n  void main() {\n    // Initialize `intId` with a version of `id` explicitly specialized to\n    // `int`.\n    var intId = id<int>;\n    print(intId(3));\n    // Initialize `stringId` with a version of `id` explicitly specialized to\n    // `String`.\n    var stringId = id<String>;\n    print(stringId(\"hello\"));\n  }\n  ```\n\n[explicit instantiation]: https://github.com/dart-lang/language/blob/master/accepted/2.15/constructor-tearoffs/feature-specification.md#explicitly-instantiated-classes-and-functions\n\n- **[Generic instantiation of function objects][object instantiation]**: Generic\n  function instantiation was previously restricted to function declarations. For\n  example, as soon as a function had been torn off, it could not be\n  instantiated:\n\n  ```dart\n  // Before Dart 2.15:\n  X id<X>(X x) => x;\n\n  void main() {\n    var fo = id; // Tear off `id`, creating a function object.\n    var c1 = fo<int>; // Compile-time error: can't instantiate `fo`.\n    int Function(int) c2 = fo; // Same compile-time error.\n    // Constants are treated the same.\n  }\n  ```\n\n  New in Dart 2.15, this restriction has been lifted. It is now possible\n  to obtain a generic instantiation of an existing function object, both\n  explicitly and implicitly (again, this works the same for non-constants):\n\n  ```dart\n  X id<X>(X x) => x;\n  X other<X>(X x) => throw x;\n\n  void main() {\n    const fo = id; // Tear off `id`, creating a function object.\n\n    // Generic function instantiation on `fo` is no longer an error.\n    const c1 = fo<int>; // OK.\n    const int Function(int) c2 = fo; // OK.\n\n    // This also generalizes function instantiation because we can,\n    // e.g., use non-trivial expressions and go via a constructor.\n    const c3 = A(true); // OK.\n  }\n\n  class A {\n    final int Function(int) x;\n    // `(...)<T>` is now allowed, also in a `const` constructor.\n    const A(bool b): x = (b ? id : other)<int>;\n  }\n  ```\n\n[Object instantiation]: https://github.com/dart-lang/language/pull/1812\n\n- Annotations on type parameters of classes can no longer refer to class members\n  without a prefix.  For example, this used to be permitted:\n\n  ```dart\n  class C<@Annotation(foo) T> {\n    static void foo() {}\n  }\n  ```\n\n  Now, the reference must be qualified with the class name, i.e.:\n\n  ```dart\n  class C<@Annotation(C.foo) T> {\n    static void foo() {}\n  }\n  ```\n\n  This brings the implementation behavior in line with the spec.\n\n- Initializer expressions on implicitly typed condition variables can now\n  contribute to type promotion.  For example, this program no longer produces a\n  compile-time error:\n\n  ```dart\n  f(int? i) {\n    var iIsNull = i == null;\n    if (!iIsNull) {\n      print(i + 1); // OK, because `i` is known to be non-null.\n    }\n  }\n  ```\n\n  Previously, the above program had a compile-time error due to a bug\n  ([#1785][]) in type promotion which prevented the initializer expression\n  (`i == null`) from being accounted for when the variable in question\n  (`iIsNull`) lacked an explicit type.\n\n  To avoid causing problems for packages that are intended to work with older\n  versions of Dart, the fix only takes effect when the minimum SDK of the source\n  packages is 2.15 or greater.\n\n[#1785]: https://github.com/dart-lang/language/issues/1785\n\n- Restrictions on members of a class with a constant constructor are relaxed\n  such that they only apply when the class has a _generative_ constant\n  constructor. For example, this used to be an error, but is now permitted:\n\n  ```dart\n  abstract class A {\n    const factory A() = B;\n    var v1;\n    late final v2 = Random().nextInt(10);\n    late final v3;\n  }\n\n  class B implements A {\n    const B([this.v3 = 1]);\n    get v1 => null;\n    set v1(_) => throw 'Cannot mutate B.v1';\n    final v2 = 0;\n    final v3;\n    set v3(_) => throw 'Cannot initialize B.v3';\n  }\n  ```\n\n  This implements a relaxation of the specified rule for a `late final`\n  instance variable, and it brings the implementation behavior in line with\n  the specification in all other cases.\n\n- **Function object canonicalization and equality**: Several corner cases in the\n  area of function object canonicalization and function object equality have\n  been updated, such that all tools behave in the same way, and the behavior\n  matches the specification.\n\n  In particular, function objects are now equal when they are obtained by\n  generic instantiation from the same function with the same actual type\n  arguments, even when that type argument is not known at compile time.\n  When the expressions are constant then the function objects are identical.\n  Constant expressions are treated as such even when they do not occur in a\n  constant context (e.g., `var f = top;`).\n\n### Core libraries\n\n#### `dart:async`\n\n- Make the `unawaited` function's argument nullable, to allow calls like\n  `unawaited(foo?.bar())`.\n\n#### `dart:cli`\n\n- The experimental `waitFor` functionality, and the library containing only that\n  function, are now deprecated.\n\n#### `dart:core`\n\n- Add extension `name` getter on enum values.\n- Add `Enum.compareByIndex` helper function for comparing enum values by index.\n- Add `Enum.compareByName` helper function for comparing enum values by name.\n- Add extension methods on `Iterable<T extends Enum>`, intended for\n  `SomeEnumType.values` lists, to look up values by name.\n- Deprecate `IntegerDivisionByZeroException`.\n  Makes the class also implement `Error`. Code throwing the exception will be\n  migrated to throwing an `Error` instead until the class is unused and\n  ready to be removed.\n  Code catching the class should move to catching `Error` instead\n  (or, for integers, check first for whether it's dividing by zero).\n\n#### `dart:io`\n\n- **Breaking Change** [#46875](https://github.com/dart-lang/sdk/issues/46875):\n  The `SecurityContext` class in `dart:io` has been updated to set the minimum\n  TLS protocol version to TLS1_2_VERSION (1.2) instead of TLS1_VERSION.\n- Add `RawSocket.sendMessage`, `RawSocket.receiveMessage` that allow passing of\n  file handle references via Unix domain sockets.\n\n#### `dart:js_util`\n\n- The `js_util` methods `setProperty`, `callMethod`, and `callConstructor` have\n  been optimized to remove checks on arguments when the checks can be elided.\n  Also, those methods, along with `getProperty` and `newObject`, now support a\n  generic type argument to specify a return type. These two changes make simple\n  `js_util` usage, like reading and writing primitive properties or calling\n  methods with simple arguments, have zero overhead.\n\n#### `dart:web_sql`\n\n- **Breaking Change** [#46316](https://github.com/dart-lang/sdk/issues/46316):\n  The WebSQL standard was abandoned more than 10\n  years ago and is not supported by many browsers. This release completely\n  deletes the `dart:web_sql` library.\n\n#### `dart:html`\n\n- **Breaking Change** [#46316](https://github.com/dart-lang/sdk/issues/46316):\n  Related to the removal of `dart:web_sql` (see above), `window.openDatabase`\n  has been removed.\n\n### Tools\n\n#### Dart command line\n\n- **Breaking Change** [#46100][]: The standalone `dart2native` tool has been\n  removed as previously announced. Its replacements are the\n  `dart compile exe` and `dart compile aot-snapshot` commands, which offer the\n  same functionality.\n\n- **Breaking Change**: The standalone `dartfmt` tool has been removed as\n  previously announced. Its replacement is the `dart format` command.\n\n  Note that `dart format` has [a different set of options and\n  defaults][dartfmt cli] than `dartfmt`.\n\n- When a script is `dart run` it will always be precompiled, but with\n  incremental precompilation for following runs.\n\n#### Dart VM\n\n- **Breaking Change** [#45451](https://github.com/dart-lang/sdk/issues/45451):\n  Support for `dart-ext:`-style native extensions has been removed as previously\n  announced. Use `dart:ffi` to bind to native libraries instead.\n\n- **Breaking Change** [#46754](https://github.com/dart-lang/sdk/issues/46754):\n  Isolates spawned via the `Isolate.spawn()` API are now grouped, operate on the\n  same managed heap and can therefore share various VM-internal data structures.\n\n  This leads to ~100x faster isolate startup latency, ~10-100x lower\n  per-isolate base memory overhead and ~8x faster inter-isolate communication.\n\n  Making isolates operate on the same heap will also make them collaborate on\n  garbage collections, which changes performance characteristics for GC-heavy\n  applications that may - in rare cases - negatively affect pause times or\n  throughput.\n\n- Allow closures both in inter-isolate messages as well as as entrypoints in\n  `Isolate.spawn(<entrypoint>, ...)` calls. Closures and their enclosing context\n  may need to be copied in this process. The enclosing context is - as with\n  normal messages - verified to only contain objects that are sendable.\n\n  Note of caution: The Dart VM's current representation of enclosing variables\n  in closures can make closures hang on to more variables than strictly needed.\n  Using such closures in inter-isolate communication can therefore lead to\n  copying of larger transitive object graphs. If the extended transitive\n  closure includes objects that are illegal to send, the sending will fail.\n  See [#36983](https://github.com/dart-lang/sdk/issues/36983), which tracks this\n  existing memory leak issue.\n\n#### Linter\n\nUpdated the Linter to `1.14.0`, which includes changes that\n- improves performance for `annotate_overrides`, `prefer_contains`, and\n  `prefer_void_to_null`.\n- marks `avoid_dynamic_calls` stable.\n- fixed `avoid_null_checks_in_equality_operators` false positive with\n  non-nullable params.\n- update `avoid_print` to allow `kDebugMode`-wrapped print calls.\n- adds support for constructor tear-offs to `avoid_redundant_argument_values`,\n  `unnecessary_lambdas`, and `unnecessary_parenthesis`.\n- improves messages for `avoid_renaming_method_parameters`.\n- improves regular expression parsing performance for common checks\n  (`camel_case_types`, `file_names`, etc.).\n- fixed `file_names` to report at the start of the file\n  (not the entire compilation unit).\n- allow `while (true) { ... }` in `literal_only_boolean_expressions`.\n- fixed `omit_local_variable_types` false positives.\n- fixed `omit_local_variable_types` to not flag a local type that is required\n  for inference.\n- fixed `overridden_fields` false positive with static fields.\n- fixed `prefer_collection_literals` named typed parameter false positives.\n- fixed `prefer_const_constructors` false positive for deferred imports.\n- fixed `prefer_final_parameters` handling of initializing formals.\n- fixed `prefer_generic_function_type_aliases` false positives with incomplete\n  statements.\n- fixed `prefer_initializing_formals` false positives with factory constructors.\n- fixed `prefer_void_to_null` false positive with overridden properties.\n- fixed `prefer_void_to_null` false positives on overriding returns.\n- fixed `prefer_void_to_null` false positives.\n- adds a new lint: `unnecessary_constructor_name` to flag unnecessary uses of\n  `.new`.\n- updates `unnecessary_getters_setters` to only flag the getter.\n- fixed `unnecessary_parenthesis` false positive with function expressions.\n- fixed `use_build_context_synchronously` false positive in awaits inside\n  anonymous functions.\n- improve control flow analysis for `use_build_context_synchronously`.\n- fixed `use_rethrow_when_possible` false positives.\n- fixed `void_checks` false positives with incomplete source.\n\n### Pub\n\n- If you have analytics enabled `dart pub get` will send\n  [usage metrics](https://github.com/dart-lang/pub/blob/0035a40f25d027130c0314571da53ffafc6d973b/lib/src/solver/result.dart#L131-L175)\n  for packages from pub.dev, intended for popularity analysis.\n- Adds support for token-based authorization to third-party package-repositories\n  with the new command `dart pub token`.\n- Credentials are no longer stored in the pub-cache, but in a platform dependent\n  config directory:\n  * On Linux `$XDG_CONFIG_HOME/dart/pub-credentials.json` if `$XDG_CONFIG_HOME`\n    is defined, otherwise `$HOME/.config/dart/pub-credentials.json`\n  * On Mac OS: `$HOME/Library/Application Support/dart/pub-credentials.json`\n  * On Windows: `%APPDATA%/dart/pub-credentials.json`\n- The syntax for dependencies hosted at a third-party package repository has\n  been simplified. Before you would need to write:\n\n```yaml\ndependencies:\n  colorizer:\n    hosted:\n      name: colorizer\n      url: 'https://custom-pub-server.com'\n    version: ^1.2.3\nenvironment:\n  sdk: '>=2.14.0 < 3.0.0'\n```\n\nNow you can write:\n\n```yaml\ndependencies:\n  colorizer:\n    hosted: 'https://custom-pub-server.com'\n    version: ^1.2.3\nenvironment:\n  sdk: '>=2.15.0 < 3.0.0'\n```\n\nThis feature requires\n[language-version](https://dart.dev/guides/language/evolution#language-versioning)\n2.15 or later, e.g. the `pubspec.yaml` should have an SDK constraint of\n`>=2.15 <3.0.0`.\n\n- Detect potential leaks in `dart pub publish`.\n  When publishing, pub will examine your files for potential secret keys, and\n  warn you.\n\n  To ignore a file that has a false positive, add it to a\n  [`false_secrets`](https://dart.dev/go/false-secrets) section of your\n  `pubspec.yaml`.\n- Fixes unicode terminal detection windows.\n- New flag `--example` to the commands\n  `dart pub get/upgrade/downgrade/add/remove` that will result in the `example/`\n  folder dependencies to be updated after operating in the current directory.\n\n### Other libraries\n\n#### `package:js`\n\n- Extensions on JS interop or native `dart:html` classes can now declare\n  members as `external`. These members are equivalent to regular extension\n  members that use `js_util` to expose the underlying JavaScript.\n\n## 2.14.4 - 2021-10-14\n\nThis is a patch release that fixes:\n\n- a memory leak of analyzer plugins (issue [flutter/flutter#90868][]).\n- the Dart VM sometimes loading expired certificates on Windows (issues\n  [#46370][] and [#47420][]).\n\n[flutter/flutter#90868]: https://github.com/flutter/flutter/issues/90868\n[#46370]: https://github.com/dart-lang/sdk/issues/46370\n[#47420]: https://github.com/dart-lang/sdk/issues/47420\n\n## 2.14.3 - 2021-09-30\n\nThis is a patch release that fixes:\n\n- a code completion performance regression (issue\n  [flutter/flutter-intellij#5761][]).\n- debug information emitted by the Dart VM (issue [#47289][]).\n\n[flutter/flutter-intellij#5761]:\n  https://github.com/flutter/flutter-intellij/issues/5761\n[#47289]: https://github.com/dart-lang/sdk/issues/47289\n\n## 2.14.2 - 2021-09-16\n\nThis is a patch release that fixes:\n\n- two dartdoc crashes (issues [dart-lang/dartdoc#2740][] and\n  [dart-lang/dartdoc#2755][]).\n- error messages when using the `>>>` operator on older language versions\n  (issue [#46886][]).\n- invalid `pubspec.lock` paths on Windows (issue [dart-lang/pub#3012][]).\n\n[dart-lang/dartdoc#2740]: https://github.com/dart-lang/dartdoc/issues/2740\n[dart-lang/dartdoc#2755]: https://github.com/dart-lang/dartdoc/issues/2755\n[#46886]: https://github.com/dart-lang/sdk/issues/46886\n[#45767]: https://github.com/dart-lang/sdk/issues/45767\n[dart-lang/pub#3012]: https://github.com/dart-lang/pub/issues/3012\n\n## 2.14.1 - 2021-09-09\n\n- Fixed an issue specific to the macOS ARM64 (Apple Silicon) SDK, where the Dart\n  commandline tools did not have the expected startup performance.\n\n## 2.14.0 - 2021-09-09\n\n### Language\n\n- Add an unsigned shift right operator `>>>`. Pad with zeroes, ignoring the sign\n  bit. On the web platform `int.>>>` shifts the low 32 bits interpreted as an\n  unsigned integer, so `a >>> b` gives the same result as\n  `a.toUnsigned(32) >>> b` on the VM.\n\n- Prior to Dart 2.14, metadata (annotations) were not permitted to be specified\n  with generic type arguments. This restriction is lifted in Dart Dart 2.14.\n\n  ```dart\n  class C<T> {\n    const C();\n  }\n  @C();      // Previously permitted.\n  @C<int>(); // Previously an error, now permitted.\n  ```\n\n- Prior to Dart 2.14, generic function types were not permitted as arguments to\n  generic classes or functions, nor to be used as generic bounds. This\n  restriction is lifted in Dart 2.14.\n\n  ```dart\n  T wrapWithLogging<T>(T f) {\n    if (f is void Function<T>(T x)) {\n      return <S>(S x) {\n        print(\"Call: f<$S>($x)\");\n        var r = f<S>(x);\n        print(\"Return: $x\");\n        return r;\n      } as T;\n    } // More cases here\n    return f;\n  }\n  void foo<T>(T x) {\n    print(\"Foo!\");\n  }\n  void main() {\n    // Previously an error, now permitted.\n    var f = wrapWithLogging<void Function<T>(T)>(foo);\n    f<int>(3);\n  }\n  ```\n\n### Core libraries\n\n#### `dart:async`\n\n- The uncaught error handlers of `Zone`s are now run in the parent zone of the\n  zone where they were declared. This prevents a throwing handler from causing\n  an infinite loop by repeatedly triggering itself.\n\n- Added `ignore()` as extension member on futures.\n\n- Added `void unawaited(Future)` top-level function to deal with the\n  `unawaited_futures` lint.\n\n#### `dart:core`\n\n- Introduce `Enum` interface implemented by all `enum` declarations.\n\n- The native `DateTime` class now better handles local time around daylight\n  saving changes that are not precisely one hour. (No change on the Web which\n  uses the JavaScript `Date` object.)\n\n- Adds static methods `hash`, `hashAll` and `hashAllUnordered` to the `Object`\n  class. These can be used to combine the hash codes of multiple objects in a\n  consistent way.\n\n- The `Symbol` constructor now accepts any string as argument. Symbols are equal\n  if they were created from the same string.\n\n\n#### `dart:ffi`\n\n- Adds the `DynamicLibrary.providesSymbol` function to check whether a symbol is\n  available in a dynamic library.\n\n#### `dart:html`\n\n- `convertNativeToDart_Dictionary()` now converts objects recursively, this\n  fixes APIs like MediaStreamTrack.getCapabilities that convert between Maps and\n  browser Dictionaries. [#44319]\n- Added some access-control HTTP header names to `HttpHeaders`.\n\n[#44319]: https://github.com/dart-lang/sdk/issues/44319\n\n#### `dart:io`\n\n- BREAKING CHANGE (for pre-migrated null safe code): `HttpClient`'s\n  `.authenticate` and `.authenticateProxy` setter callbacks must now accept a\n  nullable `realm` argument.\n- Added some access-control HTTP header names to `HttpHeaders`.\n\n#### `dart:typed_data`\n\n- **BREAKING CHANGE** (https://github.com/dart-lang/sdk/issues/45115) Most types\n  exposed by this library can no longer be extended, implemented or mixed-in.\n  The affected types are `ByteBuffer`, `TypedData` and _all_ its subclasses,\n  `Int32x4`, `Float32x4`, `Float64x2` and `Endian`.\n\n#### `dart:web_sql`\n\n- `dart:web_sql` is marked deprecated and will be removed in an upcoming\n  release. Also the API `window.openDatabase` in `dart:html` is deprecated as\n  well.\n\n  This API and library was exposing the WebSQL proposed standard. The standard\n  was abandoned more than 5 years ago and is not supported by most browsers. The\n  `dart:web_sql` library has been documented as unsupported and deprecated for\n  many years as well and but wasn't annotated properly until now.\n\n### Dart VM\n\n- **Breaking Change** [#45071][]: `Dart_NewWeakPersistentHandle`'s and\n  `Dart_NewFinalizableHandle`'s `object` parameter no longer accepts `Pointer`s\n  and subtypes of `Struct`. Expandos no longer accept `Pointer`s and subtypes of\n  `Struct`s.\n\n[#45071]: https://github.com/dart-lang/sdk/issues/45071\n\n### Tools\n\n#### Dart command line\n\n- **Breaking Change** [#46100][]: The standalone `dart2native` tool has been\n  marked deprecated, and now prints a warning message. Its replacements are the\n  `dart compile exe` and `dart compile aot-snapshot` commands, which offer the\n  same functionality. The `dart2native` tool will be removed from the Dart SDK\n  in Dart 2.15.\n\n- **Breaking Change**: The standalone `dartfmt` tool has been marked deprecated,\n  and now prints a warning message. Instead, use `dart format`. The `dartfmt`\n  tool will be removed from the Dart SDK in Dart 2.15.\n\n  Note that `dart format` has [a different set of options and\n  defaults][dartfmt cli] than `dartfmt`.\n\n- The `dart create` command has been updated to create projects that use the new\n  'recommended' set of lints from `package:lints`. See\n  https://dart.dev/go/core-lints for more information about these lints.\n\n[#46100]: https://github.com/dart-lang/sdk/issues/46100\n[dartfmt cli]: https://github.com/dart-lang/dart_style/wiki/CLI-Changes\n\n- The `dart analyze` command has been extended to support specifying multiple\n  files or directories to analyze; see also\n  https://github.com/dart-lang/sdk/issues/45352.\n\n- The `dartanalyzer` command's JSON output mode has been changed to emit the\n  JSON output on stdout instead of stderr.\n\n#### dart format\n\n- Simplify and optimize cascade formatting. See:\n  https://github.com/dart-lang/dart_style/pull/1033\n- Don't unnecessarily split argument lists with `/* */` comments.\n- Return correct exit code from `FormatCommand` when formatting stdin.\n- Split empty catch blocks with finally clauses or catches after them.\n\n#### Linter\n\nUpdated the Linter to `1.8.0`, which includes changes that\n- improve performance for `prefer_is_not_empty`.\n- fix false positives in `no_logic_in_create_state`.\n- improve `package_names` to allow dart identifiers as package names.\n- fix a false-positive in `package_names` (causing keywords to wrongly get flagged).\n- fix `avoid_classes_with_only_static_member` to check for inherited members and also\n  flag classes with only methods.\n- fix `curly_braces_in_flow_control_structures` to properly flag terminating `else-if`\n  blocks.\n- improve `always_specify_types` to support type aliases.\n- fix a false positive in `unnecessary_string_interpolations` w/ nullable interpolated\n  strings\n- fix a false positive in `avoid_function_literals_in_foreach_calls` for nullable\n  iterables.\n- fix false positives in `avoid_returning_null` w/ NNBD\n- fix false positives in `use_late_for_private_fields_and_variables` in the presence\n  of const constructors.\n- adds a new lint: `eol_at_end_of_file`.\n- fix case-sensitive false positive in `use_full_hex_values_for_flutter_colors`.\n- improve try-block and switch statement flow analysis for\n  `use_build_context_synchronously`.\n- update `use_setters_to_change_properties` to only highlight a method name, not\n  the entire body and doc comment.\n- update `unnecessary_getters_setters` to allow otherwise \"unnecessary\" getters\n  and setters with annotations.\n- update `missing_whitespace_between_adjacent_strings` to allow String\n  interpolations at the beginning and end of String literals.\n- update `unnecessary_getters_setters` to allow for setters with non-basic\n  assignments (for example, `??=` or `+=`).\n- relax `non_constant_identifier_names` to allow for a trailing underscore.\n- fix false negative in `prefer_final_parameters` where first parameter is\n  final.\n- improve `directives_ordering` sorting of directives with dot paths and\n  dot-separated package names.\n- (internal) migrate to `SecurityLintCode` instead of deprecated\n  `SecurityLintCodeWithUniqueName`.\n- (internal) fix `avoid_types_as_parameter_names` to skip field formal\n  parameters.\n- fix false positives in `prefer_interpolation_to_compose_strings` where the\n  left operand is not a String.\n- fix false positives in `only_throw_errors` for misidentified type variables.\n- add new lint: `depend_on_referenced_packages`.\n- update `avoid_returning_null_for_future` to skip checks for null-safe\n  libraries.\n- add new lint: `use_test_throws_matchers`.\n- relax `sort_child_properties_last` to accept closures after child.\n- improve performance for `prefer_contains` and `prefer_is_empty`.\n- add new lint: `noop_primitive_operations`.\n- mark `avoid_web_libraries_in_flutter` as stable.\n- add new lint: `prefer_final_parameters`.\n- update `prefer_initializing_formals` to allow assignments where identifier\n  names don't match.\n- update `directives_ordering` to checks ordering of `package:` imports in code\n  outside pub packages.\n- add simple reachability analysis to `use_build_context_synchronously` to\n  short-circuit await-discovery in terminating blocks.\n- update `use_build_context_synchronously` to recognize nullable types when\n  accessed from legacy libraries.\n\n#### Pub\n\n- `dart pub publish` now respects `.pubignore` files with gitignore-style rules.\n  `.gitignore` files in the repo are still respected if they are not overridden\n  by a `.pubignore` in the same directory.\n\n  pub no longer queries git for listing the files. This implies:\n\n  - Checked in files will now be ignored if they are included by a `.gitignore`\n    rule.\n  - Global ignores are no longer taken into account.\n  - Even packages that are not in git source control will have their\n    `.gitignore` files respected.\n  - `.gitignore` and `.pubignore` is always case-insensitive on MacOs and\n    Windows (as is default for `git` repositories).\n\n- New flag `dart pub deps --json` gives a machine parsable overview of the\n  current dependencies.\n- New command: `dart pub cache clean`. Will delete everything in your current\n  pub cache.\n- Commands related to a single package now takes a `--directory` option to\n  operate on a package in the given directory instead of the working directory.\n- git dependencies with a relative repo url would previously be interpreted\n  relative to the current package, even for transitive dependencies. This now\n  fails instead.\n\n- Pub now uses a Dart library to read and write tar files. This should fix\n  several issues we had with incompatibilities between different system `tar`s.\n- `PUB_HOSTED_URL` can now include a trailing slash.\n- Incremental compilation is now used for compilation of executables from\n  dependencies when using `dart run <package>:<command>`.\n\n#### Dart2JS\n\n*   **Breaking Change** [#46545][]: Dart2JS emits ES6+ JavaScript by default,\n    thereby no longer supporting legacy browsers. Passing the\n    `--legacy-javascript` flag will let you opt out of this update, but this\n    flag will be removed in a future release. Modern browsers will not be\n    affected, as Dart2JS continues to support [last two major releases][1] of\n    Edge, Safari, Firefox, and Chrome.\n\n[#46545]: https://github.com/dart-lang/sdk/issues/46545\n[1]: https://dart.dev/faq#q-what-browsers-do-you-support-as-javascript-compilation-targets\n\n#### Dart Dev Compiler (DDC)\n\n- **Breaking Change** [#44154][]: Subtyping relations of `package:js` classes\n  have been changed to be more correct and consistent with Dart2JS.\n  Like `anonymous` classes, non-`anonymous` classes will no longer check the\n  underlying type in DDC. The internal type representation of these objects have\n  changed as well, which will affect the `toString` value of these types.\n\n[#44154]: https://github.com/dart-lang/sdk/issues/44154\n\n## 2.13.4 - 2021-06-28\n\nThis is a patch release that fixes:\n\n- a Dart VM compiler crash (issue [flutter/flutter#84212][]).\n- a DDC compiler crash (issue [flutter/flutter#82838][]).\n\n[flutter/flutter#84212]: https://github.com/flutter/flutter/issues/84212\n[flutter/flutter#82838]: https://github.com/flutter/flutter/issues/82838\n\n## 2.13.3 - 2021-06-10\n\nThis is a patch release that fixes:\n\n- a Dart compiler crash (issue [flutter/flutter#83094][]).\n- an analysis server deadlock causing it to stop responding to IDE requests\n  (issue [#45996][]).\n- an analyzer crash when analyzing against `package:meta` `v1.4.0` (issue\n  [#46183][]).\n\n[flutter/flutter#83094]: https://github.com/flutter/flutter/issues/83094\n[#45996]: https://github.com/dart-lang/sdk/issues/45996\n[#46183]: https://github.com/dart-lang/sdk/issues/46183\n\n## 2.13.1 - 2021-05-25\n\nThis is a patch release that fixes:\n\n- incorrect behavior in CastMap (issue [#45473][]).\n- missing nullability from recursive type hierarchies in DDC (issue [#45767][]).\n\n[#45473]: https://github.com/dart-lang/sdk/issues/45473\n[#45767]: https://github.com/dart-lang/sdk/issues/45767\n\n## 2.13.0 - 2021-05-18\n\n### Language\n\n- **Type aliases** [Non-function type aliases][]: Type aliases (names for types\n  introduced via the `typedef` keyword) were previously restricted to only\n  introduce names for function types. In this release, we remove this\n  restriction and allow type aliases to name any kind of type.\n\n  ```dart\n  import 'dart:convert';\n\n  typedef JsonMap = Map<String, dynamic>;\n\n  JsonMap parseJsonMap(String input) => json.decode(input) as JsonMap;\n  ```\n\n  In addition to being usable as type annotations, type aliases that name class\n  types can now also be used anywhere that the underlying class could be used,\n  allowing type aliases to be used to safely rename existing classes.\n\n  ```dart\n  class NewClassName<T> {\n     NewClassName.create(T x);\n     static NewClassName<T> mkOne<T>(T x) => NewClassName<T>.create(x);\n   }\n  @Deprecated(\"Use NewClassName instead\")\n  typedef OldClassName<T> = NewClassName<T>;\n\n  class LegacyClass extends OldClassName<int> {\n    LegacyClass() : super.create(3);\n  }\n  OldClassName<int> legacyCode() {\n    var one = OldClassName.create(1);\n    var two = OldClassName.mkOne(2);\n    return LegacyClass();\n  }\n  ```\n\n  The new type alias feature is only available as part of the 2.13\n  [language version](https://dart.dev/guides/language/evolution). To use this\n  feature, you must set the lower bound on the sdk constraint for your package\n  to 2.13 or greater.\n\n  [non-function type aliases]:\n    https://github.com/dart-lang/language/blob/master/accepted/2.13/nonfunction-type-aliases/feature-specification.md\n\n### Core libraries\n\n#### `dart:collection`\n\n- The `SplayTreeMap` was changed to allow `null` as key if the `compare`\n  function allows it. It now checks that a new key can be used as an argument to\n  the `compare` function when the member is added, _even if the map is empty_\n  (in which case it just compares the key to itself).\n\n- The `SplayTreeSet` was changed to checks that a new element can be used as an\n  argument to the `compare` function when the member is added, _even if the set\n  is empty_ (in which case it just compares the element to itself).\n\n#### `dart:developer`\n\n- Added `serverWebSocketUri` property to `ServiceProtocolInfo`.\n\n### Dart VM\n\n### Tools\n\n#### Analyzer\n\n- Static analyses with \"error\" severity can once again be ignored with comments\n  like `// ignore: code` and `// ignore_for_file: code`. To declare that certain\n  analysis codes, or codes with certain severities (\"error\", \"warning\", and\n  \"info\") cannot be ignored with such comments, list them in\n  `analysis_options.yaml`, under the `analyzer` heading, with a new YAML key,\n  `cannot-ignore`. For example, to declare that \"error\" codes and\n  `unused_import` cannot be ignored, write the following into\n  `analysis_options.yaml`:\n\n  ```yaml\n  analyzer:\n    cannot-ignore:\n      - error\n      - unused_import\n  ```\n\n#### dart format\n\n- Correct constructor initializer indentation after `required` named parameters.\n\n#### Linter\n\nUpdated the Linter to `1.2.1`, which includes:\n\n- Improved `iterable_contains_unrelated_type` to better support `List` content\n  checks.\n- Fixed `camel_case_types` and `prefer_mixin` to support non-function type\n  aliases.\n- Fixed `prefer_mixin` to properly make exceptions for `dart.collection` legacy\n  mixins.\n- Added new lints `avoid_multiple_declarations_per_line`,\n  `use_if_null_to_convert_nulls_to_bools`, `deprecated_consistency`,\n  `use_named_constants`, `use_build_context_synchronously` (experimental).\n- Deprecated `avoid_as`.\n- Migrated library to null-safety.\n\n### Other libraries\n\n#### `package:js`\n\n- **Breaking change:** It is no longer valid to use `String`s that match an\n  `@Native` annotation in an `@JS()` annotation for a non-anonymous JS interop\n  class. This led to erroneous behavior due to the way interceptors work. If you\n  need to work with a native class, prefer `dart:html`, an `@anonymous` class,\n  or `js_util`. See issue [#44211][] for more details.\n\n[#44211]: https://github.com/dart-lang/sdk/issues/44211\n\n## 2.12.4 - 2021-04-15\n\nThis is a patch release that fixes a Dart VM compiler crashes when compiling\ninitializers containing async closures (issue [#45306][]).\n\n[#45306]: https://github.com/dart-lang/sdk/issues/45306\n\n## 2.12.3 - 2021-04-14\n\nThis is a patch release that fixes a vulnerability in `dart:html` related to DOM\nclobbering. See the [vulnerability advisory][cve-2021-22540] for more details.\nThanks again to **Vincenzo di Cicco** for finding and reporting this\nvulnerability.\n\n[cve-2021-22540]:\n  https://github.com/dart-lang/sdk/security/advisories/GHSA-3rfv-4jvg-9522\n\n## 2.12.2 - 2021-03-17\n\nThis is a patch release that fixes crashes reported by Flutter 2 users (issue\n[flutter/flutter#78167][]).\n\n[flutter/flutter#78167]: https://github.com/flutter/flutter/issues/78167\n\n## 2.12.1 - 2021-03-10\n\nThis is a patch release that fixes:\n\n- an unhandled exception in HTTPS connections (issue [#45047][]).\n- a typing issue in the typed_data `+` operator (issue [#45140][]).\n\n[#45047]: https://github.com/dart-lang/sdk/issues/45047\n[#45140]: https://github.com/dart-lang/sdk/issues/45140\n\n## 2.12.0 - 2021-03-03\n\n### Language\n\n- **Breaking Change** [Null safety][] is now enabled by default in all code that\n  has not opted out. With null safety, types in your code are non-nullable by\n  default. Null can only flow into parts of your program where you want it. With\n  null safety, your runtime null-dereference bugs turn into edit-time analysis\n  errors.\n\n  You can opt out of null safety and preserve your code's previous behavior by\n  setting the lower bound of the SDK constraint in your pubspec to 2.11.0 or\n  earlier to request an earlier [language version][]. You can opt out individual\n  Dart files by adding `// @dart=2.11` to the beginning of the file.\n\n  Files that are opted in to null safety may report new compile-time errors.\n  Opting in to null safety also gives you access to other new language features:\n\n  - Smarter flow analysis and type promotion\n  - `required` named parameters\n  - `late` variables\n  - The postfix `!` null assertion operator\n  - The `?..` and `?[]` null-aware operators\n\n- **Breaking Change** [#44660][]: Fixed an implementation bug where `this` would\n  sometimes undergo type promotion in extensions.\n\n[null safety]: https://dart.dev/null-safety/understanding-null-safety\n[language version]:\n  https://dart.dev/guides/language/evolution#language-versioning\n[#44660]: https://github.com/dart-lang/sdk/issues/44660\n\n### Core libraries\n\n#### `dart:async`\n\n- Add extension method `onError()` on `Future` to allow better typing of error\n  callbacks.\n\n#### `dart:collection`\n\n- Add `UnmodifiableSetView` class, which allows users to guarantee that methods\n  that could change underlying `Set` instance can not be invoked.\n\n- Make it explicit that `LinkedList` compares elements by identity, and update\n  `contains()` to take advantage of this.\n\n#### `dart:core`\n\n- Add `Set.unmodifiable()` constructor, which allows users to create\n  unmodifiable `Set` instances.\n\n#### `dart:io`\n\n- `HttpRequest` now correctly follows HTTP 308 redirects\n  (`HttpStatus.permanentRedirect`).\n\n#### `dart:isolate`\n\n- Add `debugName` positional parameter to `ReceivePort` and `RawReceivePort`\n  constructors, a name which can be associated with the port and displayed in\n  tooling.\n- Introduce `Isolate.exit([port, message])` which terminates current isolate\n  and, if `port` is specified, as a last action sends out the `message` out to\n  that `port`.\n\n#### `dart:html`\n\n- `EventStreamSubscription.cancel` has been updated to retain its synchronous\n  timing when running in both sound and unsound null safety modes. See issue\n  [#44157][] for more details.\n\n[#44157]: https://github.com/dart-lang/sdk/issues/44157\n\n### Dart VM\n\n- **Breaking Change** [#42312][]: `Dart_WeakPersistentHandle`s no longer\n  auto-delete themselves when the referenced object is garbage collected to\n  avoid race conditions, but they are still automatically deleted when the\n  isolate group shuts down.\n\n- **Breaking Change** [#42312][]: `Dart_WeakPersistentHandleFinalizer` is\n  renamed to `Dart_HandleFinalizer` and had its `handle` argument removed. All\n  API functions using that type have been updated.\n\n[#42312]: https://github.com/dart-lang/sdk/issues/42312\n\n### Foreign Function Interface (`dart:ffi`)\n\n- **Breaking Change** [#44621][]: Invocations with a generic `T` of `sizeOf<T>`,\n  `Pointer<T>.elementAt()`, `Pointer<T extends Struct>.ref`, and\n  `Pointer<T extends Struct>[]` are being deprecated in the current stable\n  release (2.12), and are planned to be fully removed in the following stable\n  release (2.13). Consequently, `allocate` in `package:ffi` will no longer be\n  able to invoke `sizeOf<T>` generically, and will be deprecated as well.\n  Instead, the `Allocator` it is introduced to `dart:ffi`, and also requires a\n  constant `T` on invocations. For migration notes see the breaking change\n  request.\n\n- **Breaking Change** [#44622][]: Subtypes of `Struct` without any native member\n  are being deprecated in the current stable release (2.12), and are planned to\n  be fully removed in the following stable release (2.13). Migrate opaque types\n  to extend `Opaque` rather than `Struct`.\n\n[#44621]: https://github.com/dart-lang/sdk/issues/44621\n[#44622]: https://github.com/dart-lang/sdk/issues/44622\n\n### Dart2JS\n\n- Remove `--no-defer-class-types` and `--no-new-deferred-split`.\n\n### Tools\n\n#### Analyzer\n\n- Remove the `--use-fasta-parser`, `--preview-dart-2`, and\n  `--enable-assert-initializers` command line options. These options haven't\n  been supported in a while and were no-ops.\n\n- Report diagnostics regarding the\n  [`@internal`](https://pub.dev/documentation/meta/latest/meta/internal-constant.html)\n  annotation.\n\n- Improve diagnostic-reporting regarding the\n  [`@doNotStore`](https://pub.dev/documentation/meta/latest/meta/doNotStore-constant.html)\n  annotation.\n\n- Introduce a diagnostic which is reported when a library member named `main` is\n  not a function.\n\n- Introduce a diagnostic which is reported when a `main` function's first\n  parameter is not a supertype of `List<String>`.\n\n- Introduce diagnostics for when an `// ignore` comment contains an error code\n  which is not being reported, cannot be ignored, or is already being ignored.\n\n- Report diagnostics when using\n  [`@visibleForTesting`](https://pub.dev/documentation/meta/latest/meta/\n  visibleForTesting-constant.html) on top-level variables.\n\n- Fix false positive reports of \"unused element\" for top-level setters and\n  getters.\n\n- Fix false positive reports regarding `@deprecated` field formal parameters at\n  their declaration.\n\n- For null safety, introduce a diagnostic which reports when a null-check will\n  always fail.\n\n- Fix false positive reports regarding optional parameters on private\n  constructors being unused.\n\n- Introduce a diagnostic which is reported when a constructor includes duplicate\n  field formal parameters.\n\n- Improve the \"unused import\" diagnostic when multiple import directives share a\n  common prefix.\n\n- Fix false positive \"unused import\" diagnostic regarding an import which\n  provides an extension method which is used.\n\n- For null safety, improve the messaging of \"use of nullable value\" diagnostics\n  for eight different contexts.\n\n- Fix false positive reports regarding `@visibleForTesting` members in a \"hide\"\n  combinator of an import or export directive.\n\n- Improve the messaging of \"invalid override\" diagnostics.\n\n- Introduce a diagnostic which is reported when `Future<T>.catchError` is called\n  with an `onError` callback which does not return `FutureOr<T>`.\n\n#### dartfmt\n\n- Don't duplicate comments on chained if elements.\n\n- Preserve `?` in initializing formal function-typed parameters.\n\n- Fix performance issue with constructors that have no initializer list.\n\n#### Linter\n\nUpdated the Linter to `0.1.129`, which includes:\n\n- New lints: `avoid_dynamic_calls`, `cast_nullable_to_non_nullable`,\n  `null_check_on_nullable_type_parameter`,\n  `tighten_type_of_initializing_formals`, `unnecessary_null_checks`, and\n  `avoid_type_to_string`.\n\n- Fix crash in `prefer_collection_literals` when there is no static parameter\n  element.\n\n- Fix false negatives for `prefer_collection_literals` when a LinkedHashSet or\n  LinkedHashMap instantiation is passed as the argument to a function in any\n  position other than the first.\n\n- Fix false negatives for `prefer_collection_literals` when a LinkedHashSet or\n  LinkedHashMap instantiation is used in a place with a static type other than\n  Set or Map.\n\n- Update to `package_names` to allow leading underscores.\n\n- Fix crashes in `unnecessary_null_checks` and\n  `missing_whitespace_between_adjacent_strings`.\n\n- Update to `void_checks` for null safety.\n\n- Fix range error in `unnecessary_string_escapes`.\n\n- Fix false positives in `unnecessary_null_types`.\n\n- Fix to `prefer_constructors_over_static_methods` to respect type parameters.\n\n- Update to `always_require_non_null_named_parameters` to be null safety-aware.\n\n- Update to `unnecessary_nullable_for_final_variable_declarations` to allow\n  dynamic.\n\n- Update `overridden_fields` to not report on abstract parent fields.\n\n- Fix to `unrelated_type_equality_checks` for null safety.\n\n- Improvements to `type_init_formals`to allow types not equal to the field type.\n\n- Updates to `public_member_apis` to check generic type aliases.\n\n- Fix `close_sinks` to handle `this`-prefixed property accesses.\n\n- Fix `unawaited_futures` to handle `Future` subtypes.\n\n- Performance improvements to `always_use_package_imports`,\n  `avoid_renaming_method_parameters`, `prefer_relative_imports` and\n  `public_member_api_docs`.\n\n#### Pub\n\n- **Breaking**: The Dart SDK constraint is now **required** in `pubspec.yaml`.\n  You must include a section like:\n\n  ```yaml\n  environment:\n    sdk: \">=2.10.0 <3.0.0\"\n  ```\n\n  See [#44072][].\n\n  For legacy dependencies without an SDK constraint, pub will now assume a\n  default language version of 2.7.\n\n- The top level `pub` executable has been deprecated. Use `dart pub` instead.\n  See [dart tool][].\n\n- New command `dart pub add` that adds new dependencies to your `pubspec.yaml`,\n  and a corresponding `dart pub remove` that removes dependencies.\n\n- New option `dart pub upgrade --major-versions` will update constraints in your\n  `pubspec.yaml` to match the _resolvable_ column reported in\n  `dart pub outdated`. This allows users to easily upgrade to latest version for\n  all dependencies where this is possible, even if such upgrade requires an\n  update to the version constraint in `pubspec.yaml`.\n\n  It is also possible to only upgrade the major version for a subset of your\n  dependencies using `dart pub upgrade --major-versions <dependencies...>`.\n\n- New option `dart pub upgrade --null-safety` will attempt to update constraints\n  in your `pubspec.yaml`, such that only null-safety migrated versions of\n  dependencies are allowed.\n\n- New option `dart pub outdated --mode=null-safety` that will analyze your\n  dependencies for null-safety.\n\n- `dart pub get` and `dart pub upgrade` will highlight dependencies that have\n  been [discontinued](https://dart.dev/tools/pub/publishing#discontinue) on\n  pub.dev.\n\n- `dart pub publish` will now check your pubspec keys for likely typos.\n\n- `dart pub upgrade package_foo` fetchs dependencies but ignores the\n  `pubspec.lock` for `package_foo`, allowing users to only upgrade a subset of\n  dependencies.\n\n- New command `dart pub login` that logs in to pub.dev.\n\n- The `--server` option to `dart pub publish` and `dart pub uploader` are\n  deprecated. Use `publish_to` in your `pubspec.yaml` or set the\n  `$PUB_HOSTED_URL` environment variable.\n\n- `pub global activate` no longer re-precompiles if the current global\n  installation was same version.\n\n- The Flutter SDK constraint upper bound is now ignored in pubspecs and\n  deprecated when publishing. See: [flutter-upper-bound-deprecation][].\n\n[flutter-upper-bound-deprecation]:\n  https://dart.dev/go/flutter-upper-bound-deprecation\n[#44072]: https://github.com/dart-lang/sdk/issues/44072\n[dart tool]: https://dart.dev/tools/dart-tool\n\n## 2.10.5 - 2021-01-21\n\nThis is a patch release that fixes a crash in the Dart VM. (issue [#44563][]).\n\n[#44563]: https://github.com/dart-lang/sdk/issues/44563\n\n## 2.10.4 - 2020-11-12\n\nThis is a patch release that fixes a crash in the Dart VM (issues [#43941][],\n[flutter/flutter#43620][], and [Dart-Code/Dart-Code#2814][]).\n\n[#43941]: https://github.com/dart-lang/sdk/issues/43941\n[flutter/flutter#43620]: https://github.com/flutter/flutter/issues/43620\n[dart-code/dart-code#2814]: https://github.com/Dart-Code/Dart-Code/issues/2814\n\n## 2.10.3 - 2020-10-29\n\nThis is a patch release that fixes the following issues:\n\n- breaking changes in Chrome 86 that affect DDC (issues [#43750][] and\n  [#43193][]).\n- compiler error causing incorrect use of positional parameters when named\n  parameters should be used instead (issues [flutter/flutter#65324][] and\n  [flutter/flutter#68092][]).\n- crashes and/or undefined behavor in AOT compiled code (issues [#43770][] and\n  [#43786][]).\n- AOT compilation of classes with more than 64 unboxed fields (issue\n  [flutter/flutter#67803][]).\n\n[#43750]: https://github.com/dart-lang/sdk/issues/43750\n[#43193]: https://github.com/dart-lang/sdk/issues/43193\n[flutter/flutter#65324]: https://github.com/flutter/flutter/issues/65324\n[flutter/flutter#68092]: https://github.com/flutter/flutter/issues/68092\n[#43770]: https://github.com/dart-lang/sdk/issues/43770\n[#43786]: https://github.com/dart-lang/sdk/issues/43786\n[flutter/flutter#67803]: https://github.com/flutter/flutter/issues/67803\n\n## 2.10.2 - 2020-10-15\n\nThis is a patch release that fixes a DDC compiler crash (issue [#43589]).\n\n[#43589]: https://github.com/dart-lang/sdk/issues/43589\n\n## 2.10.1 - 2020-10-06\n\nThis is a patch release that fixes the following issues:\n\n- crashes when developing Flutter applications (issue [#43464][]).\n- non-deterministic incorrect program behaviour and/or crashes (issue\n  [flutter/flutter#66672][]).\n- uncaught TypeErrors in DDC (issue [#43661][]).\n\n[#43464]: https://github.com/dart-lang/sdk/issues/43464\n[flutter/flutter#66672]: https://github.com/flutter/flutter/issues/66672\n[#43661]: https://github.com/dart-lang/sdk/issues/43661\n\n## 2.10.0 - 2020-09-28\n\n### Core libraries\n\n#### `dart:io`\n\n- Adds `Abort` method to class `HttpClientRequest`, which allows users to cancel\n  outgoing HTTP requests and stop following IO operations.\n- A validation check is added to `path` of class `Cookie`. Having characters\n  ranging from 0x00 to 0x1f and 0x3b (\";\") will lead to a `FormatException`.\n- The `HttpClient` and `HttpServer` classes now have a 1 MiB limit for the total\n  size of the HTTP headers when parsing a request or response, instead of the\n  former 8 KiB limit for each header name and value. This limit cannot be\n  configured at this time.\n\n#### `dart:typed_data`\n\n- Class `BytesBuilder` is moved from `dart:io` to `dart:typed_data`. It's\n  temporarily being exported from `dart:io` as well.\n\n### `dart:uri`\n\n- [#42564]: Solved inconsistency in `Uri.https` and `Uri.http` constructors'\n  `queryParams` type.\n\n### Dart VM\n\n- **Breaking Change** [#42982][]: `dart_api_dl.cc` is renamed to `dart_api_dl.c`\n  and changed to a pure C file.\n- Introduces `Dart_FinalizableHandle`s. They do auto-delete, and the weakly\n  referred object cannot be accessed through them.\n\n### Dart2JS\n\n- Adds support for deferred loading of types seperately from classes. This\n  enables dart2js to make better optimization choices when deferred loading.\n  This work is necessary to address unsoundness in the deferred loading\n  algorithm. Currently, fixing this unsoundness would result in code bloat, but\n  loading types seperately from classes will allow us to fix the unsoundness\n  with only a minimal regression. To explicitly disable deferred loading of\n  types, pass `--no-defer-class-types`. See the original post on the\n  [unsoundness in the deferred loading algorithm][].\n- Enables a new sound deferred splitting algorithm. To explicitly disable the\n  new deferred splitting algorithm, pass `--no-new-deferred-split`. See the\n  original post on the [unsoundness in the deferred loading algorithm][].\n\n[#42982]: https://github.com/dart-lang/sdk/issues/42982\n[unsoundness in the deferred loading algorithm]:\n  https://github.com/dart-lang/sdk/blob/302ad7ab2cd2de936254850550aad128ae76bbb7/CHANGELOG.md#dart2js-3\n\n### Tools\n\n#### dartfmt\n\n- Don't crash when non-ASCII whitespace is trimmed.\n- Split all conditional expressions (`?:`) when they are nested.\n- Handle `external` and `abstract` fields and variables.\n\n#### Linter\n\nUpdated the Linter to `0.1.118`, which includes:\n\n- New lint: `unnecessary_nullable_for_final_variable_declarations`.\n- Fixed NPE in `prefer_asserts_in_initializer_lists`.\n- Fixed range error in `unnecessary_string_escapes`.\n- `unsafe_html` updated to support unique error codes.\n- Updates to `diagnostic_describe_all_properties` to check for `Diagnosticable`s\n  (not `DiagnosticableMixin`s).\n- New lint: `use_late`.\n- Fixed `unnecessary_lambdas` to respect deferred imports.\n- Updated `public_member_api_docs` to check mixins.\n- Updated `unnecessary_statements` to skip `as` expressions.\n- Fixed `prefer_relative_imports` to work with path dependencies.\n\n#### Pub\n\n- `pub run` and `pub global run` accepts a `--(no-)-sound-null-safety` flag,\n  that is passed to the VM.\n- Fix: Avoid multiple recompilation of binaries in global packages.\n- Fix: Avoid exponential behaviour of error reporting from the solver.\n- Fix: Refresh binstubs after recompile in global run.\n\n## 2.9.3 - 2020-09-08\n\nThis is a patch release that fixes DDC to handle a breaking change in Chrome\n(issue [#43193][]).\n\n[#43193]: https://github.com/dart-lang/sdk/issues/43193\n\n## 2.9.2 - 2020-08-26\n\nThis is a patch release that fixes transient StackOverflow exceptions when\nbuilding Flutter applications (issue [flutter/flutter#63560][]).\n\n[flutter/flutter#63560]: https://github.com/flutter/flutter/issues/63560\n\n## 2.9.1 - 2020-08-12\n\nThis is a patch release that fixes unhandled exceptions in some Flutter\napplications (issue [flutter/flutter#63038][]).\n\n[flutter/flutter#63038]: https://github.com/flutter/flutter/issues/63038\n\n## 2.9.0 - 2020-08-05\n\n### Language\n\n### Core libraries\n\n#### `dart:async`\n\n- Adds `Stream.multi` constructor creating streams which can be listened to more\n  than once, and where each individual listener can be controlled independently.\n\n#### `dart:convert`\n\n- **Breaking Change** [#41100][]: When encoding a string containing unpaired\n  surrogates as UTF-8, the unpaired surrogates will be encoded as replacement\n  characters (`U+FFFD`). When decoding UTF-8, encoded surrogates will be treated\n  as malformed input. When decoding UTF-8 with `allowMalformed: true`, the\n  number of replacement characters emitted for malformed input sequences has\n  been changed to match the [WHATWG encoding standard][].\n\n[#41100]: https://github.com/dart-lang/sdk/issues/41100\n[whatwg encoding standard]: https://encoding.spec.whatwg.org/#utf-8-decoder\n\n#### `dart:io`\n\n- [#42006][]: The signature of `exit` has been changed to return the `Never`type\n  instead of `void`. since no code will run after it,\n- Class `OSError` now implements `Exception`. This change means `OSError` will\n  now be caught in catch clauses catching `Exception`s.\n- Added `InternetAddress.tryParse`.\n- [Abstract Unix Domain Socket][] is supported on Linux/Android now. Using an\n  `InternetAddress` with `address` starting with '@' and type being\n  `InternetAddressType.Unix` will create an abstract Unix Domain Socket.\n- On Windows, file APIs can now handle files and directories identified by long\n  paths (greater than 260 characters). It complies with all restrictions from\n  [Long Path on Windows][]. Note that `Directory.current` does not work with\n  long path.\n\n[#42006]: https://github.com/dart-lang/sdk/issues/42006\n[abstract unix domain socket]: http://man7.org/linux/man-pages/man7/unix.7.html\n[long path on windows]:\n  https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file#maximum-path-length-limitation\n\n#### `dart:html`\n\n- **Breaking Change**: `CssClassSet.add()` previously returned `null` if the\n  `CssClassSet` corresponded to multiple elements. In order to align with the\n  null-safe changes in the `Set` interface, it will now return `false` instead.\n  The same applies for `CssClassSet.toggle`.\n\n- `EventStreamSubscription.cancel` method used to return `null`, but since\n  `StreamSubscription.cancel` has changed to be non-nullable, this method\n  returns an empty `Future` instead. Due to an optimization on `null` `Future`s,\n  this method used to complete synchronously, but now that the `Future` is empty\n  instead, it completes asynchronously, therefore potentially invalidating code\n  that relied on the synchronous side-effect. This change will only affect code\n  using sound null-safety. See issue [#41653][] for more details.\n\n- Methods in `Console` have been updated to better reflect the modern Console\n  specification. Particularly of interest are `dir` and `table` which take in\n  extra optional arguments.\n\n[#41653]: https://github.com/dart-lang/sdk/issues/41653\n\n#### `dart:mirrors`\n\n- **Breaking Change** [#42714][]: web compilers (dart2js and DDC) now produce a\n  compile-time error if `dart:mirrors` is imported.\n\n  Most projects should not be affected. Since 2.0.0 this library was unsupported\n  and produced runtime errors on all its APIs. Since then several tools already\n  reject code that use `dart:mirrors` including webdev and flutter tools, we\n  expect few projects to run into this problem.\n\n[#42714]: https://github.com/dart-lang/sdk/issues/42714\n\n### Tools\n\n#### dartfmt\n\n- Add `--fix-single-cascade-statements`.\n- Correctly handle `var` in `--fix-function-typedefs`.\n- Preserve leading indentation in fixed doc comments.\n- Split outer nested control flow elements.\n- Always place a blank line after script tags.\n- Don't add unneeded splits on if elements near comments.\n- Indent blocks in initializers of multiple-variable declarations.\n- Update the null-aware subscript syntax from `?.[]` to `?[]`.\n\n#### Analyzer\n\n- Static analyses with a severity of \"error\" can no longer be ignored with\n  comments (`// ignore: code` and `// ignore_for_file: code`).\n\n#### Linter\n\nUpdated the Linter to `0.1.117`, which includes:\n\n- New lint: `do_not_use_environment`.\n- New lint: `exhaustive_cases`.\n- New lint: `no_default_cases` (experimental).\n- New lint: `sized_box_for_whitespace`.\n- New lint: `use_is_even_rather_than_modulo`.\n- Updated `directives_ordering` to remove third party package special-casing.\n- Updated `prefer_is_empty` to special-case assert initializers and const\n  contexts.\n- Updated `prefer_mixin` to allow \"legacy\" SDK abstract class mixins.\n- Updated `sized_box_for_whitespace` to address false-positives.\n- Updated `type_annotate_public_apis` to allow inferred types in final field\n  assignments.\n- Updated `unnecessary_lambdas` to check for tear-off assignability.\n- Updated `unsafe_html` to use a `SecurityLintCode` (making it un-ignorable) and\n  to include `Window.open`, `Element.html` and `DocumentFragment.html` in unsafe\n  API checks. Also added checks for attributes and methods on extensions.\n\n### Dart VM\n\n- **Breaking Change** [#41100][]: When printing a string using the `print`\n  function, the default implementation (used when not overridden by the embedder\n  or the current zone) will print any unpaired surrogates in the string as\n  replacement characters (`U+FFFD`). Similarly, the `Dart_StringToUTF8` function\n  in the Dart API will convert unpaired surrogates into replacement characters.\n\n### Pub\n\n- `pub run` and `pub global run` accepts a `--enable-experiment` flag enabling\n  experiments in the Dart VM (and language).\n- Warn when publishing the first null-safe version of a package.\n- `pub outdated`:\n  - If the current version of a dependency is a prerelease version, use\n    prereleases for latest if there is no newer stable.\n  - Don't require a `pubspec.lock` file. When the lockfile is missing, the\n    **Current** column is empty.\n- `pub upgrade`: Show summary count of outdated packages after running. It will\n  also only show newer packages if they are not prereleases or the package is\n  already a prerelease.\n- Publishing Flutter plugins using the old plugin format is no longer allowed.\n  Plugins using the old plugin format can still be consumed.\n- `pub run`: Fix precompilation with relative `PUB_CACHE` paths\n  ([#2486](https://github.com/dart-lang/pub/pull/2486)).\n- Preserve Windows line endings in `pubspec.lock` if they are already there\n  ([#2489](https://github.com/dart-lang/pub/pull/2489)).\n- Better terminal color-detection. Use colors in terminals on Windows.\n- Fix git folder names in cache, allowing for ssh-style git dependencies.\n- Fix: Avoid precompilation of dependencies of global packages.\n\n## 2.8.4 - 2020-06-04\n\nThis is a patch release that fixes potential memory leaks in the Dart front-end\n(issues [#42111][] and [#42112][]).\n\n[#42111]: https://github.com/dart-lang/sdk/issues/42111\n[#42112]: https://github.com/dart-lang/sdk/issues/42112\n\n## 2.8.3 - 2020-05-28\n\nThis is a patch release that fixes the following issues:\n\n- crashes in Flutter apps (issue [flutter/flutter#57318][]).\n- a regression in stack traces (issue [#41907][]).\n- re-canonicalization of constants with unboxed fields (issue\n  [flutter/flutter#57190][]).\n\n[flutter/flutter#57318]: https://github.com/flutter/flutter/issues/57318\n[#41907]: https://github.com/dart-lang/sdk/issues/41907\n[flutter/flutter#57190]: https://github.com/flutter/flutter/issues/57190\n\n## 2.8.2 - 2020-05-13\n\nThis is a patch release that fixes an AOT compilation bug in global\ntransformations which manifests as a NoSuchMethod exception (issue\n[flutter/flutter#56479][]).\n\n[flutter/flutter#56479]: https://github.com/flutter/flutter/issues/56479\n\n## 2.8.1 - 2020-05-06\n\nMuch of the changes in this release are in preparation for non-nullable types,\nwhich will arrive in a future version. In anticipation of that, we have made a\nnumber of small but technically breaking changes to several core library APIs in\norder to make them easier to use in a world with non-nullable types. Almost all\nexisting Dart code will be unaffected by these changes, but if you see\nunexpected failures, note the breaking changes listed below.\n\n### Language\n\nThere are no new language features in this release. There are only two minor\nbreaking changes:\n\n- **Breaking change** [#40675][]: Fixed an implementation bug where local\n  variable inference would incorrectly use the promoted type of a type variable.\n\n- **Breaking change** [#41362][]: Dart 2.0.0 made the clauses\n  `implements Function`, `extends Function`, or `with Function` have no effect\n  (spec section 19.6). We fixed an implementation bug that may be visible on\n  some rare scenarios.\n\n[#40675]: https://github.com/dart-lang/sdk/issues/40675\n[#41362]: https://github.com/dart-lang/sdk/issues/41362\n\n### Core libraries\n\n#### `dart:async`\n\n- **Breaking change** [#40676][]: Changed the return type of\n  `StreamSubscription.cancel()` to `Future<void>`. Previously, it was declared\n  to return `Future` and was allowed to return `null` at runtime.\n\n- **Breaking change** [#40681][]: The `runZoned()` function is split into two\n  functions: `runZoned()` and `runZonedGuarded()`, where the latter has a\n  required `onError` parameter, and the former has none. This prepares the\n  functions for null safety where the two functions will differ in the\n  nullability of their return types.\n\n- **Breaking change** [#40683][]: Errors passed to `Completer.completeError()`,\n  `Stream.addError()`, `Future.error()`, etc. can no longer be `null`. These\n  operations now _synchronously_ throw an exception if passed a `null` error.\n\n- Make stack traces non-null [#40130][]. Where methods like\n  `completer.completeError()` allow omitting a stack trace, the platform will\n  now insert a default stack trace rather than propagate a `null` value.\n\n  Error handling functions need no longer be prepared for `null` stack traces.\n\n[#40676]: https://github.com/dart-lang/sdk/issues/40676\n[#40681]: https://github.com/dart-lang/sdk/issues/40681\n[#40683]: https://github.com/dart-lang/sdk/issues/40683\n[#40130]: https://github.com/dart-lang/sdk/issues/40130\n\n#### `dart:core`\n\n- **Breaking change** [#40674][]: Three members on `RuneIterator` no longer\n  return `null` when accessed before the first call to `moveNext()`. Instead,\n  `current` and `rawIndex` return `-1` and `currentAsString` returns an empty\n  string.\n\n- **Breaking change** [#40678][]: The `String.fromEnvironment()` default value\n  for `defaultValue` is now an empty string instead of `null`. Likewise, the\n  default value for `int.fromEnvironment()`'s `defaultValue` parameter is zero.\n  Under null safety, a constructor cannot return `null`, so this prepares these\n  APIs for that.\n\n- The class `CastError` is deprecated, and all implementation specific classes\n  implementing `TypeError` or `CastError` now implement both. In a future\n  release, `CastError` will be removed. See issue [40763][] for details.\n\n- Adds `StackTrace.empty` constant which is the stack trace used as default\n  stack trace when no better alternative is available.\n\n- The class `TypeError` no longer extends `AssertionError`. This also means that\n  it no longer inherits the spurious `message` getter which was added to\n  `AssertionError` when the second operand to `assert` was allowed. The value of\n  that getter on a `TypeError` was the same string as returned by `toString()`,\n  so it is still available.\n\n- `ArgumentError.checkNotNull()` and the `RangeError` static methods\n  `checkValueInInterval()`, `checkValidIndex()` and `checkNotNegative()` all\n  return their first argument on success. This makes these functions more\n  convenient to use in-line in, for example, `=>` function bodies or constructor\n  initialization lists.\n\n[#40674]: https://github.com/dart-lang/sdk/issues/40674\n[#40678]: https://github.com/dart-lang/sdk/issues/40678\n[40763]: https://github.com/dart-lang/sdk/issues/40763\n\n#### `dart:developer`\n\n- The constructors for `TimelineTask` now accept an optional `filterKey`\n  parameter. If provided, the arguments for all events associated with the task\n  will contain an entry named `filterKey`, set to the value of the `filterKey`\n  parameter provided in the constructor. This will be used by tooling to allow\n  for better filtering of timeline events.\n\n#### `dart:html`\n\n- **Breaking Change** [#39627][]: Changed the return type of several HTML native\n  methods involving futures. In return types that matched `Future<List<T>>`,\n  `T was` changed to `dynamic`. These methods would have resulted in a runtime\n  error if they were used.\n\n- **Breaking Change**: `Node.insertAllBefore()` erroneously had a return type of\n  `Node`, even though it was not returning anything. This has been corrected to\n  `void`.\n\n[#39627]: https://github.com/dart-lang/sdk/issues/39627\n\n#### `dart:io`\n\n- Class `HttpParser` will no longer throw an exception when a HTTP response\n  status code is within [0, 999]. Customized status codes in this range are now\n  valid.\n\n- **Breaking change** [#33501][]: The signature of `HttpHeaders` methods `add()`\n  and `set` have been changed to:\n\n  ```dart\n  void add(String name, Object value, {bool preserveHeaderCase: false})\n  void set(String name, Object value, {bool preserveHeaderCase: false})\n  ```\n\n  Setting `preserveHeaderCase` to `true` preserves the case of the `name`\n  parameter instead of converting it to lowercase. The `HttpHeader.forEach()`\n  method provides the current case of each header.\n\n  This is breaking only for classes extending or implementing `HttpHeaders` and\n  having their own `add` or `set` methods without the `bool preserveHeaderCase`\n  named parameter.\n\n- **Breaking change** [#40702][]: The `Socket` class now throws a\n  `SocketException` if the socket has been explicitly destroyed or upgraded to a\n  secure socket upon setting or getting socket options. Previously, setting a\n  socket option would be ignored and getting a socket option would return\n  `null`.\n\n- **Breaking change** [#40483][]: The `Process` class now throws a `StateError`\n  if the process is detached (`ProcessStartMode.detached` and\n  `ProcessStartMode.detachedWithStdio`) upon accessing the `exitCode` getter. It\n  now also throws when not connected to the child process's stdio\n  (`ProcessStartMode.detached` and `ProcessStartMode.inheritStdio`) upon\n  accessing the `stdin`, `stdout`, and `stderr` getters. Previously, these\n  getters would all return `null`.\n\n- **Breaking change** [#40706][]: The dummy object returned if `FileStat.stat()`\n  or `FileStat.statSync()` fail now contains Unix epoch timestamps instead of\n  `null` for the `accessed`, `changed`, and `modified` getters.\n\n- **Breaking change** [#40709][]: The `HeaderValue` class now parses more\n  strictly in two invalid edge cases. This is the class used to parse the\n  semicolon delimited parameters used in the `Accept`, `Authorization`,\n  `Content-Type`, and other such HTTP headers.\n\n  The empty parameter value without double quotes (which is not allowed by the\n  standards) is now parsed as the empty string rather than `null`. E.g.\n  `HeaderValue.parse(\"v;a=\").parameters` now gives `{\"a\": \"\"}` rather than\n  `{\"a\": null}`.\n\n  Invalid inputs with unbalanced double quotes are now rejected. E.g.\n  `HeaderValue.parse('v;a=\"b').parameters` will now throw a `HttpException`\n  instead of giving `{\"a\": \"b\"}`.\n\n- The `HeaderValue.toString()` method now supports parameters with `null` values\n  by omitting the value. `HeaderValue(\"v\", {\"a\": null, \"b\": \"c\"}).toString()`\n  now gives `v; a; b=c`. This behavior can be used to implement some features in\n  the `Accept` and `Sec-WebSocket-Extensions` headers.\n\n  Likewise the empty value and values using characters outside of [RFC 7230\n  tokens][] are now correctly implemented by double quoting such values with\n  escape sequences. For example:\n\n  ```dart\n  HeaderValue(\"v\",\n      {\"a\": \"A\", \"b\": \"(B)\", \"c\": \"\", \"d\": \"\u00f8\", \"e\": \"\\\\\\\"\"}).toString()\n  ```\n\n  Gives: `v;a=A;b=\"(B)\";c=\"\";d=\"\u00f8\";e=\"\\\\\\\"\"`.\n\n- [Unix domain sockets][] are now supported on Linux, Android and MacOS, which\n  can be used by passing a `InternetAddress` of `InternetAddressType.Unix` into\n  the `connect()`, `startConnect()` and `bind()` methods. The `port` argument in\n  those methods will be ignored. The `port` getter always returns 0 for Unix\n  domain sockets.\n\n- Class `InternetAddressType` gains one more option `Unix`, which represents a\n  Unix domain address.\n\n- Class `InternetAddress`:\n\n  - `InternetAddress` constructor gains an optional `type` parameter. To create\n    a Unix domain address, `type` is set to `InternetAddressType.Unix` and\n    `address` is a file path.\n\n  - `InternetAddress` gains a new constructor `fromRawAddress()` that takes an\n    address in byte format for Internet addresses or raw file path for Unix\n    domain addresses.\n\n- **Breaking change** [#40681][]: The static methods `runZoned()` and\n  `runWithHttpOverrides()` on `HttpOverrides` no longer accept\n  `zoneSpecification` and `onError` parameters. Use the `runZoned()` or\n  `runZonedGuarded()` functions from `dart:async` directly if needing to specify\n  those.\n\n- Class `HttpClient` and `HttpServer`, when receiving `HttpRequest` or\n  `HttpClientResponse`, will now put a 8K size limit on its header fields and\n  values.\n\n[#33501]: https://github.com/dart-lang/sdk/issues/33501\n[#40702]: https://github.com/dart-lang/sdk/issues/40702\n[#40483]: https://github.com/dart-lang/sdk/issues/40483\n[#40706]: https://github.com/dart-lang/sdk/issues/40706\n[#40709]: https://github.com/dart-lang/sdk/issues/40709\n[rfc 7230 tokens]: https://tools.ietf.org/html/rfc7230#section-3.2.6\n[unix domain sockets]: https://en.wikipedia.org/wiki/Unix_domain_socket\n\n#### `dart:mirrors`\n\n- Added `MirrorSystem.neverType`.\n\n### Dart VM\n\n- Added `Dart_TypeDynamic`, `Dart_TypeVoid` and `Dart_TypeNever`. Type `dynamic`\n  can no longer by reached using `Dart_GetType(dart:core, dynamic)`.\n\n- Added the following methods to the VM embedding API:\n\n  - `Dart_GetNonNullableType()`\n  - `Dart_GetNullableType()`\n  - `Dart_TypeToNonNullable()`\n  - `Dart_TypeToNullable()`\n  - `Dart_IsLegacyType()`\n  - `Dart_IsNonNullableType()`\n  - `Dart_IsNullableType()`\n\n### Foreign Function Interface (`dart:ffi`)\n\n- **Breaking Change**: Changed `Pointer.asFunction()` and\n  `DynamicLibrary.lookupFunction()` to extension methods. Invoking them\n  dynamically previously already threw an exception, so the runtime behavior\n  stays the same. However, the extension methods are only visible if `dart:ffi`\n  is imported directly. This breaks code where `dart:ffi` is not directly\n  imported. To fix, add:\n\n  ```dart\n  import 'dart:ffi';\n  ```\n\n### Tools\n\n#### Dart Dev Compiler (DDC)\n\nWe fixed several inconsistencies between DDC and Dart2JS so that users less\nfrequently encounter code that is accepted by one compiler but then fails in the\nother.\n\n- **Breaking Change**: Deleted the legacy (analyzer based) version of DDC. For\n  additional details see the [announcement][ddc].\n\n  - The `--kernel` option is now ignored and defaults to true. There is no\n    longer any way to invoke the legacy (analyzer based) version of DDC.\n\n  - Command line arguments that were only used for the legacy DDC have been\n    removed.\n\n  - The pre-compiled `dart_sdk.js` artifacts generated by legacy DDC have been\n    deleted from `dart-sdk/lib/dev_compiler` in favor of the versions located at\n    `dart-sdk/lib/dev_compiler/kernel`.\n\n- **Breaking Change**: Functions passed to JavaScript using the recommended\n  `package:js` interop specification must now be wrapped with a call to\n  `allowInterop`. This behavior was always enforced by Dart2JS, but was not\n  enforced consistently by DDC. It is now enforced by both.\n\n- **Breaking Change**: Constructors in `@JS()` classes must be marked with\n  `external`. Previously the `external` could be omitted in some cases with DDC\n  but doing so would cause incorrect behavior with Dart2JS.\n\n- JS interop classes with an index operator are now static errors.\n\n- All remaining support from the `dart:mirrors` library has been removed. Use of\n  this library on the web has been unsupported and prevented by the Dart build\n  systems since Dart v2.0.0. All known exception cases have been cleaned up.\n  This change makes DDC and Dart2JS now behave consistently.\n\n  The library can still be imported on web apps, but all APIs throw. In a future\n  breaking change release, imports to this library will likely become a\n  compile-time error.\n\n[ddc]: https://github.com/dart-lang/sdk/issues/38994\n\n#### Dart2JS\n\nA new representation of runtime types is enabled by default.\n\nThis change is part of a long term goal of making runtime checks cheaper and\nmore flexible for upcoming changes in the language. The new representation\ndisentangles how types and classes are represented and makes types first-class\nto the compiler. This makes it possible to do certain kind of optimizations on\ntype checks that were not possible before and will enable us to model\nnon-nullable types in the near future.\n\nThis change should not affect the semantics of your application, but it has some\nrelatively small visible effects that we want to highlight:\n\n- Types are now canonicalized, this fixes a long standing bug that Types could\n  not be used in switch cases (issue [17207][]).\n\n- Code-size changes may be visible, but the difference is small overall. It is\n  more visible on smaller apps because the new implementation includes more\n  helper methods. On large apps we have even seen an overall code-size\n  reduction.\n\n- Certain checks are a lot faster. This is less noticeable if you are compiling\n  apps with `-O3` where checks are omitted altogether. Even with `-O3`, the\n  performance of some `is` checks used by your app may improve.\n\n- When using `-O3` and `-O4` incorrect type annotations could surface as errors.\n  The old type representation was accidentally lenient on some invalid type\n  annotations. We have only encountered this issue on programs that were not\n  tested properly at the js-interop program boundary.\n\n- `Type.toString()` has a small change that is rarely visible. For a long time,\n  Dart2JS has had support to erase unused type variables. Today, when Dart2JS is\n  given `--lax-runtime-type-to-string` (currently included in `-O2`, `-O3`, and\n  `-O4`) and it decides to erase the type variable of a class `Foo<T>`, then it\n  compiles expressions like `foo.runtimeType.toString()` to print `Foo`. With\n  the new representation, this will show `Foo<erased>` instead. This change may\n  be visible in error messages produced by type checks involving erased types.\n\nBecause types and classes are represented separately, we will likely reevaluate\nrestrictions of deferred libraries in the near future. For example, we could\nsupport referring to deferred types because types can be downloaded while\nclasses are not.\n\nIn the unlikely case you run into any issues, please file a bug so we can\ninvestigate. You can temporarily force the old type representation by passing\n`--use-old-rti` to Dart2JS if necessary, but our goal is to delete the old type\nrepresentation soon.\n\nIn addition, we fixed some inconsistencies between Dart2JS and DDC:\n\n- JS interop classes with an index operator are now static errors instead of\n  causing invalid code in Dart2JS.\n\n- **Breaking Change**: The subtyping rule for generic functions is now more\n  forgiving. Corresponding type parameter bounds now only need to be mutual\n  subtypes rather than structurally equal up to renaming of bound type variables\n  and equating all top types.\n\n- **Breaking Change**: Types are now normalized. See [normalization][] for the\n  full specification. Types will now be printed in their normal form, and mutual\n  subtypes with the same normal form will now be considered equal.\n\n- **Breaking Change**: Constructors in `@JS()` classes must be marked with\n  `external`. Previously, the external could be omitted for unused constructors.\n  Omitting `external` for a constructor which is used would cause incorrect\n  behavior at runtime, now omitting it on any constructor is a static error.\n\n[17207]: https://github.com/dart-lang/sdk/issues/17207\n[normalization]:\n  https://github.com/dart-lang/language/blob/master/resources/type-system/normalization.md\n\nOther dart2js changes:\n\n- **Breaking Change**: The `--package-root` flag, which was hidden and disabled\n  in Dart 2.0.0, has been completely removed. Passing this flag will now cause\n  `dart2js` to fail.\n\n#### Linter\n\nUpdated the Linter to `0.1.114`, which includes:\n\n- Fixed `avoid_shadowing_type_parameters` to support extensions and mixins.\n- Updated `non_constant_identifier_names` to allow named constructors made up of\n  only underscores (`_`).\n- Updated `avoid_unused_constructor_parameters` to ignore unused params named in\n  all underscores (`_`).\n\n#### Analyzer\n\n- Removed support for the deprecated analysis options file name\n  `.analysis_options`.\n\n#### Pub\n\n- Added `pub outdated` command which lists outdated package dependencies, and\n  gives advice on how to upgrade.\n\n- `pub get` and `pub upgrade` now fetch version information about hosted\n  dependencies in parallel, improving the time package resolution performance.\n\n- `pub get` and `pub upgrade` no longer precompile executables from dependencies\n  by default. Instead they are precompiled on first `pub run`. Use\n  `pub get --precompile` to get the previous behavior.\n\n- Fixed missing retries of DNS failures during `pub get`.\n\n- If code contains imports for packages not listed in the package's\n  `pubspec.yaml` then `pub publish` will reject the package.\n\n- `pub publish` no longer requires the presence of a `homepage` field, if the\n  `repository` field is provided.\n\n- `pub publish` warns if non-pre-release packages depends on pre-release\n  packages or pre-release Dart SDKs.\n\n- Relative paths in `pubspec.lock` now use `/` also on Windows to make the file\n  sharable between machines.\n\n- Fixed language version in [`.dart_tool/package_config.json`][package config]\n  for packages without an explicit SDK constraint. Pub now writes an empty\n  language version where before the language version of the current SDK would be\n  used.\n\n- `%LOCALAPPDATA%` is now preferred over `%APPDATA%` when creating a pub cache\n  directory on Windows. `%LOCALAPPDATA%` is not copied when users roam between\n  devices.\n\n- `pub publish` warns if LICENSE and README.md files are not called those exact\n  names.\n\n- `pub repair cache` downloads hosted packages in parallel.\n\n[package config]:\n  https://github.com/dart-lang/language/blob/master/accepted/future-releases/language-versioning/package-config-file-v2.md\n\n## 2.7.2 - 2020-03-23\n\nThis is a patch release that addresses a vulnerability in `dart:html`\n[NodeValidator][] related to DOM clobbering of `previousSibling`. See the\n[vulnerability advisory][cve-2020-8923] for more details. Thanks to **Vincenzo\ndi Cicco** for finding and reporting this issue.\n\nThis release also improves compatibility with ARMv8 processors (issue [40001][])\nand dart:io stability (issue [40589][]).\n\n[nodevalidator]: https://api.dart.dev/stable/dart-html/NodeValidator-class.html\n[cve-2020-8923]:\n  https://github.com/dart-lang/sdk/security/advisories/GHSA-hfq3-v9pv-p627\n[40001]: https://github.com/dart-lang/sdk/issues/40001\n[40589]: https://github.com/dart-lang/sdk/issues/40589\n\n## 2.7.1 - 2020-01-23\n\nThis is a patch release that improves dart2js compile-time (issue [40217][]).\n\n[40217]: https://github.com/dart-lang/sdk/issues/40217\n\n**Breaking Change**: The Dart SDK for macOS is now only available for x64 (issue\n[39810][]).\n\n[39810]: https://github.com/dart-lang/sdk/issues/39810\n\n## 2.7.0 - 2019-12-11\n\n**Extension methods** -- which we shipped in preview in 2.6.0 -- are no longer\nin preview, and are now officially supported as of 2.7.0. Learn more about them\nhere:\n\nhttps://medium.com/dartlang/extension-methods-2d466cd8b308\n\n### Language\n\n- **Breaking Change**: [Static extension members][] are accessible when imported\n  with a prefix (issue [671][]). In the extension method **preview** launch,\n  importing a library with a prefix hid all extension members in addition to\n  hiding the extension name, thereby making them inaccessible in the importing\n  library except via the explicit override syntax. Based on user feedback, we\n  have changed this to make extensions methods accessible even when imported\n  with a prefix.\n\n      ```dart\n        // \"thing.dart\"\n        class Thing {\n        }\n        extension Show on Thing {\n          void show() {\n            print(\"This is a thing\");\n          }\n       }\n       // \"client.dart\"\n       import \"thing.dart\" as p;\n       void test() {\n         p.Thing().show(); // Previously an error, now resolves to Show.show\n       }\n      ```\n\n[static extension members]:\n  https://github.com/dart-lang/language/blob/master/accepted/2.6/static-extension-members/feature-specification.md\n[671]: https://github.com/dart-lang/language/issues/671\n\n### Core libraries\n\n#### `dart:io`\n\n- **Breaking change**: Added `IOOverrides.serverSocketBind` to aid in writing\n  tests that wish to mock `ServerSocket.bind`.\n\n#### `dart:typed_data`\n\n- Added new constructors, `.sublistView(TypedData, [start, end])` to all\n  `TypedData` classes. The constructor makes it easier, and less error-prone, to\n  create a view of (a slice of) another `TypedData` object.\n\n### Dart VM\n\n- New fields added to existing instances by a reload will now be initialized\n  lazily, as if the field was a late field. This makes the initialization order\n  program-defined, whereas previously it was undefined.\n\n### Tools\n\n#### Linter\n\nThe Linter was updated to `0.1.104`, which includes:\n\n- updated `unnecessary_overrides` to allow overrides when annotations (besides\n  `@override` are specified)\n- updated `file_names` to allow names w/ leading `_`'s (and improved\n  performance)\n- new lint: `unnecessary_final`\n\n#### Pub\n\n- `pub get` generates\n  [`.dart_tool/package_config.json`](https://github.com/dart-lang/language/blob/62c036cc41b10fb543102d2f73ee132d1e2b2a0e/accepted/future-releases/language-versioning/package-config-file-v2.md)\n  in addition to `.packages` to support language versioning.\n\n- `pub publish` now warns about the old flutter plugin registration format.\n\n- `pub publish` now warns about the `author` field in pubspec.yaml being.\n  obsolete.\n\n- Show a proper error message when `git` is not installed.\n\n## 2.6.1 - 2019-11-11\n\nThis is a patch release that reduces dart2js memory usage (issue [27883][]),\nimproves stability on arm64 (issue [39090][]) and updates the Dart FFI\ndocumentation.\n\n[27883]: https://github.com/dart-lang/sdk/issues/27883\n[39090]: https://github.com/dart-lang/sdk/issues/39090\n\n## 2.6.0 - 2019-11-05\n\n### Language\n\n- **[IN PREVIEW]** [Static extension members][]: A new language feature allowing\n  specially declared static functions to be invoked like instance members on\n  expressions of appropriate static types is available in preview.\n\n  Static extension members are declared using a new `extension` declaration.\n  Example:\n\n  ```dart\n  extension MyFancyList<T> on List<T> {\n    /// Whether this list has an even length.\n    bool get isLengthEven => this.length.isEven;\n\n    /// Whether this list has an odd length.\n    bool get isLengthOdd => !isLengthEven;\n\n    /// List of values computed for each pairs of adjacent elements.\n    ///\n    /// The result always has one element less than this list,\n    /// if this list has any elements.\n    List<R> combinePairs<R>(R Function(T, T) combine) =>\n        [for (int i = 1; i < this.length; i++)\n            combine(this[i - 1], this[i])];\n  }\n  ```\n\n  Extension declarations cannot declare instance fields or constructors.\n  Extension members can be invoked explicitly,\n  `MyFancyList(intList).isLengthEven)`, or implicitly, `intList.isLengthEven`,\n  where the latter is recognized by `intList` matching the `List<T>` \"on\" type\n  of the declaration. An extension member cannot be called implicitly on an\n  expression whose static type has a member with the same base-name. In that\n  case, the interface member takes precedence. If multiple extension members\n  apply to the same implicit invocation, the most specific one is used, if there\n  is one such.\n\n  Extensions can be declared on any type, not just interface types.\n\n  ```dart\n  extension IntCounter on int {\n    /// The numbers from this number to, but not including, [end].\n    Iterable<int> to(int end) sync* {\n      int step = end < this ? -1 : 1;\n      for (int i = this; i != end; i += step) yield i;\n    }\n  }\n\n  extension CurryFunction<R, S, T> on R Function(S, T) {\n    /// Curry a binary function with its first argument.\n    R Function(T) curry(S first) => (T second) => this(first, second);\n  }\n  ```\n\n  [static extension members]:\n    https://github.com/dart-lang/language/blob/master/accepted/2.6/static-extension-members/feature-specification.md\n\n- **Breaking change** [#37985](https://github.com/dart-lang/sdk/issues/37985):\n  Inference is changed when using `Null` values in a `FutureOr` context. Namely,\n  constraints of the forms similar to `Null` <: `FutureOr<T>` now yield `Null`\n  as the solution for `T`. For example, the following code will now print\n  \"Null\", and it was printing \"dynamic\" before (note that the anonymous closure\n  `() {}` in the example has `Null` as its return type):\n\n  ```dart\n  import 'dart:async';\n\n  void foo<T>(FutureOr<T> Function() f) { print(T); }\n\n  main() { foo(() {}); }\n  ```\n\n### Core libraries\n\n- Default values of parameters of abstract methods are no longer available via\n  `dart:mirrors`.\n\n#### `dart:developer`\n\n- Added optional `parent` parameter to `TimelineTask` constructor to allow for\n  linking of asynchronous timeline events in the DevTools timeline view.\n\n#### `dart:io`\n\n- Added `enableTimelineLogging` property to `HttpClient` which, when enabled,\n  will post HTTP connection and request information to the developer timeline\n  for all `HttpClient` instances.\n\n### Dart VM\n\n- Added a new tool for AOT compiling Dart programs to native, self-contained\n  executables. See https://dart.dev/tools/dart2native for additional details.\n\n### Foreign Function Interface (`dart:ffi`)\n\n- **Breaking change**: The API now makes use of static extension members. Static\n  extension members enable the `dart:ffi` API to be more precise with types, and\n  provide convenient access to memory through extension getters and setters. The\n  extension members on `Pointer` provide `.value` and `.value =` for accessing\n  the value in native memory and `[]` and `[]=` for indexed access. The method\n  `asExternalTypedData` has been replaced with `asTypedList` extension methods.\n  And finally, `Structs` do no longer have a type argument and are accessed\n  using the extension member `.ref` on `Pointer`. These changes makes the code\n  using `dart:ffi` much more concise.\n- **Breaking change**: The memory management has been removed\n  (`Pointer.allocate` and `Pointer.free`). Instead, memory management is\n  available in [package:ffi](https://pub.dev/packages/ffi).\n- **Breaking change**: `Pointer.offsetBy` was removed, use `cast` and\n  `elementAt` instead.\n- Faster memory load and stores.\n- The dartanalyzer (commandline and IDEs) now reports `dart:ffi` static errors.\n- Callbacks are now supported in AOT (ahead-of-time) compiled code.\n\n### Dart for the Web\n\n#### Dart Dev Compiler (DDC)\n\n- Kernel DDC will no longer accept non-dill files as summary inputs.\n- Removed support for the deprecated web extension.\n\n### Tools\n\n#### Linter\n\nThe Linter was updated to `0.1.101`, which includes:\n\n- fixed `diagnostic_describe_all_properties` to flag properties in\n  `Diagnosticable`s with no debug methods defined\n- fixed `noSuchMethod` exception in `camel_case_extensions` when analyzing\n  unnamed extensions\n- fixed `avoid_print` to catch tear-off usage\n- new lint: `avoid_web_libraries_in_flutter` (experimental)\n- (internal) prepare `unnecessary_lambdas` for coming `MethodInvocation` vs.\n  `FunctionExpressionInvocation` changes\n\n## 2.5.2 - 2019-10-08\n\nThis is a patch release with properly signed binaries required for macOS\nCatalina (Issue [38765][]).\n\n[38765]: https://github.com/dart-lang/sdk/issues/38765\n\n## 2.5.1 - 2019-09-27\n\nThis is a patch release that prevents type inference failures in the analyzer\n(Issue [38365][]).\n\n[38365]: https://github.com/dart-lang/sdk/issues/38365\n\n## 2.5.0 - 2019-09-10\n\n### Language\n\nThe set of operations allowed in constant expressions has been expanded as\ndescribed in the\n[constant update proposal](https://github.com/dart-lang/language/issues/61). The\ncontrol flow and spread collection features shipped in Dart 2.3 are now also\nsupported in constants as\n[described in the specification here](https://github.com/dart-lang/language/blob/master/accepted/2.3/unified-collections/feature-specification.md#constant-semantics).\n\nSpecifically, it is now valid to use the following operations in constant\nexpressions under the appropriate conditions:\n\n- Casts (`e as T`) and type tests (`e is T`).\n- Comparisons to `null`, even for types which override the `==` operator.\n- The `&`, `|`, and `^` binary operators on booleans.\n- The spread operators (`...` and `...?`).\n- An `if` element in a collection literal.\n\n```dart\n// Example: these are now valid constants.\nconst Object i = 3;\nconst list = [i as int];\nconst set = {if (list is List<int>) ...list};\nconst map = {if (i is int) i : \"int\"};\n```\n\nIn addition, the semantics of constant evaluation has been changed as follows:\n\n- The `&&` operator only evaluates its second operand if the first evaluates to\n  true.\n- The `||` operator only evaluates its second operand if the first evaluates to\n  false.\n- The `??` operator only evaluates its second operand if the first evaluates to\n  null.\n- The conditional operator (`e ? e1 : e2`) only evaluates one of the two\n  branches, depending on the value of the first operand.\n\n```dart\n// Example: x is now a valid constant definition.\nconst String s = null;\nconst int x = (s == null) ? 0 : s.length;\n```\n\n### Core libraries\n\n- **Breaking change** [#36900](https://github.com/dart-lang/sdk/issues/36900):\n  The following methods and properties across various core libraries, which used\n  to declare a return type of `List<int>`, were updated to declare a return type\n  of `Uint8List`:\n\n  - `BytesBuilder.takeBytes()`\n  - `BytesBuilder.toBytes()`\n  - `Datagram.data`\n  - `File.readAsBytes()` (`Future<Uint8List>`)\n  - `File.readAsBytesSync()`\n  - `InternetAddress.rawAddress`\n  - `RandomAccessFile.read()` (`Future<Uint8List>`)\n  - `RandomAccessFile.readSync()`\n  - `RawSocket.read()`\n  - `Utf8Codec.encode()` (and `Utf8Encoder.convert()`)\n\n  In addition, the following classes were updated to implement\n  `Stream<Uint8List>` rather than `Stream<List<int>>`:\n\n  - `HttpRequest`\n  - `Socket`\n\n  **Possible errors and how to fix them**\n\n  - > The argument type 'Utf8Decoder' can't be assigned to the parameter type\n    > 'StreamTransformer<Uint8List, dynamic>'\n\n    > type 'Utf8Decoder' is not a subtype of type 'StreamTransformer' of\n    > 'streamTransformer'\"\n\n    You can fix these call sites by updating your code to use\n    `StreamTransformer.bind()` instead of `Stream.transform()`, like so:\n\n    _Before:_ `stream.transform(utf8.decoder)` _After:_\n    `utf8.decoder.bind(stream)`\n\n  - > The argument type 'IOSink' can't be assigned to the parameter type\n    > 'StreamConsumer<Uint8List>'\n\n    > type '\\_IOSinkImpl' is not a subtype of type 'StreamConsumer<Uint8List>'\n    > of 'streamConsumer'\n\n    You can fix these call sites by casting your stream instance to a\n    `Stream<List<int>>` before calling `.pipe()` on the stream, like so:\n\n    _Before:_ `stream.pipe(consumer)` _After:_\n    `stream.cast<List<int>>().pipe(consumer)`\n\n  Finally, the following typed lists were updated to have their `sublist()`\n  methods declare a return type that is the same as the source list:\n\n  - `Int8List.sublist()` \u2192 `Int8List`\n  - `Int16List.sublist()` \u2192 `Int16List`\n  - `Int32List.sublist()` \u2192 `Int32List`\n  - `Int64List.sublist()` \u2192 `Int64List`\n  - `Int32x4List.sublist()` \u2192 `Int32x4List`\n  - `Float32List.sublist()` \u2192 `Float32List`\n  - `Float64List.sublist()` \u2192 `Float64List`\n  - `Float32x4List.sublist()` \u2192 `Float32x4List`\n  - `Float64x2List.sublist()` \u2192 `Float64x2List`\n  - `Uint8List.sublist()` \u2192 `Uint8List`\n  - `Uint8ClampedList.sublist()` \u2192 `Uint8ClampedList`\n  - `Uint16List.sublist()` \u2192 `Uint16List`\n  - `Uint32List.sublist()` \u2192 `Uint32List`\n  - `Uint64List.sublist()` \u2192 `Uint64List`\n\n#### `dart:async`\n\n- Add `value` and `error` constructors on `Stream` to allow easily creating\n  single-value or single-error streams.\n\n#### `dart:core`\n\n- Update `Uri` class to support [RFC6874](https://tools.ietf.org/html/rfc6874):\n  \"%25\" or \"%\" can be appended to the end of a valid IPv6 representing a Zone\n  Identifier. A valid zone ID consists of unreversed character or Percent\n  encoded octet, which was defined in RFC3986. IPv6addrz = IPv6address \"%25\"\n  ZoneID\n\n  [29456]: https://github.com/dart-lang/sdk/issues/29456\n\n#### `dart:io`\n\n- **Breaking change** [#37192](https://github.com/dart-lang/sdk/issues/37192):\n  The `Cookie` class's constructor's `name` and `value` optional positional\n  parameters are now mandatory. The signature changes from:\n\n      Cookie([String name, String value])\n\n  to\n\n      Cookie(String name, String value)\n\n  However, it has not been possible to set `name` and `value` to null since Dart\n  1.3.0 (2014) where a bug made it impossible. Any code not using both\n  parameters or setting any to null would necessarily get a noSuchMethod\n  exception at runtime. This change catches such erroneous uses at compile time.\n  Since code could not previously correctly omit the parameters, this is not\n  really a breaking change.\n\n- **Breaking change** [#37192](https://github.com/dart-lang/sdk/issues/37192):\n  The `Cookie` class's `name` and `value` setters now validates that the strings\n  are made from the allowed character set and are not null. The constructor\n  already made these checks and this fixes the loophole where the setters didn't\n  also validate.\n\n### Dart VM\n\n### Tools\n\n#### Pub\n\n- Clean-up invalid git repositories in cache when fetching from git.\n- **Breaking change** [#36765](https://github.com/dart-lang/sdk/issues/36765):\n  Packages published to [pub.dev](https://pub.dev) can no longer contain git\n  dependencies. These packages will be rejected by the server.\n\n#### Linter\n\nThe Linter was updated to `0.1.96`, which includes:\n\n- fixed false positives in `unnecessary_parens`\n- various changes to migrate to preferred analyzer APIs\n- rule test fixes\n\n#### Dartdoc\n\nDartdoc was updated to `0.28.4`; this version includes several fixes and is\nbased on a newer version of the analyzer package.\n\n## 2.4.1 - 2019-08-07\n\nThis is a patch release that fixes a performance regression in JIT mode, as well\nas a potential crash of our AOT compiler.\n\n### Dart VM\n\n- Fixed a performance regression where usage of `Int32List` could trigger\n  repeated deoptimizations in JIT mode (Issue [37551][]).\n\n- Fixed a bug where usage of a static getter with name `length` could cause a\n  crash in our AOT compiler (Issue [35121][]).\n\n[37551]: https://github.com/dart-lang/sdk/issues/37551\n[35121]: https://github.com/dart-lang/sdk/issues/35121\n\n### Dart Dev Compiler (DDC)\n\nCallbacks passed to JS and wrapped with `allowInterop` or\n`allowInteropCaptureThis` are now strict about argument counts and argument\ntypes. This may mean that tests which were previously passing and relying on\nloose argument checking (too many or too few arguments, or arguments with too\nspecific types like `List<Something>` instead of `List<dynamic>`) may start\nfailing. This changes makes DDC behave more like dart2js with the default flags.\n\n## 2.4.0 - 2019-06-27\n\n### Core libraries\n\n#### `dart:isolate`\n\n- `TransferableTypedData` class was added to facilitate faster cross-isolate\n  communication of `Uint8List` data.\n\n- **Breaking change**: `Isolate.resolvePackageUri` will always throw an\n  `UnsupportedError` when compiled with dart2js or DDC. This was the only\n  remaining API in `dart:isolate` that didn't automatically throw since we\n  dropped support for this library in [Dart 2.0.0][1]. Note that the API already\n  throws in dart2js if the API is used directly without manually setting up a\n  `defaultPackagesBase` hook.\n\n[1]: https://github.com/dart-lang/sdk/blob/main/CHANGELOG.md#200---2018-08-07\n\n#### `dart:developer`\n\n- Exposed `result`, `errorCode` and `errorDetail` getters in\n  `ServiceExtensionResponse` to allow for better debugging of VM service\n  extension RPC results.\n\n#### `dart:io`\n\n- Fixed `Cookie` class interoperability with certain websites by allowing the\n  cookie values to be the empty string (Issue [35804][]) and not stripping\n  double quotes from the value (Issue [33327][]) in accordance with RFC 6265.\n\n  [33327]: https://github.com/dart-lang/sdk/issues/33327\n  [35804]: https://github.com/dart-lang/sdk/issues/35804\n\n- [#36971](https://github.com/dart-lang/sdk/issues/36971): The\n  `HttpClientResponse` interface has been extended with the addition of a new\n  `compressionState` getter, which specifies whether the body of a response was\n  compressed when it was received and whether it has been automatically\n  uncompressed via `HttpClient.autoUncompress`.\n\n  As part of this change, a corresponding new enum was added to `dart:io`:\n  `HttpClientResponseCompressionState`.\n\n  This is a **breaking change** for those implementing the `HttpClientResponse`\n  interface as subclasses will need to implement the new getter.\n\n#### `dart:async`\n\n- **Breaking change** [#36382](https://github.com/dart-lang/sdk/issues/36382):\n  The `await for` allowed `null` as a stream due to a bug in `StreamIterator`\n  class. This bug has now been fixed.\n\n#### `dart:core`\n\n- [#36171](https://github.com/dart-lang/sdk/issues/36171): The `RegExp`\n  interface has been extended with two new constructor named parameters:\n\n  - `unicode:` (`bool`, default: `false`), for Unicode patterns\n  - `dotAll:` (`bool`, default: `false`), to change the matching behavior of '.'\n    to also match line terminating characters.\n\n  Appropriate properties for these named parameters have also been added so\n  their use can be detected after construction.\n\n  In addition, `RegExp` methods that originally returned `Match` objects now\n  return a more specific subtype, `RegExpMatch`, which adds two features:\n\n  - `Iterable<String> groupNames`, a property that contains the names of all\n    named capture groups\n  - `String namedGroup(String name)`, a method that retrieves the match for the\n    given named capture group\n\n  This is a **breaking change** for implementers of the `RegExp` interface.\n  Subclasses will need to add the new properties and may have to update the\n  return types on overridden methods.\n\n### Language\n\n- **Breaking change** [#35097](https://github.com/dart-lang/sdk/issues/35097):\n  Covariance of type variables used in super-interfaces is now enforced. For\n  example, the following code was previously accepted and will now be rejected:\n\n```dart\nclass A<X> {};\nclass B<X> extends A<void Function(X)> {};\n```\n\n- The identifier `async` can now be used in asynchronous and generator\n  functions.\n\n### Dart for the Web\n\n#### Dart Dev Compiler (DDC)\n\n- Improve `NoSuchMethod` errors for failing dynamic calls. Now they include\n  specific information about the nature of the error such as:\n  - Attempting to call a null value.\n  - Calling an object instance with a null `call()` method.\n  - Passing too few or too many arguments.\n  - Passing incorrect named arguments.\n  - Passing too few or too many type arguments.\n  - Passing type arguments to a non-generic method.\n\n### Tools\n\n#### Linter\n\nThe Linter was updated to `0.1.91`, which includes the following changes:\n\n- Fixed missed cases in `prefer_const_constructors`\n- Fixed `prefer_initializing_formals` to no longer suggest API breaking changes\n- Updated `omit_local_variable_types` to allow explicit `dynamic`s\n- Fixed null-reference in `unrelated_type_equality_checks`\n- New lint: `unsafe_html`\n- Broadened `prefer_null_aware_operators` to work beyond local variables.\n- Added `prefer_if_null_operators`.\n- Fixed `prefer_contains` false positives.\n- Fixed `unnecessary_parenthesis` false positives.\n- Fixed `prefer_asserts_in_initializer_lists` false positives\n- Fixed `curly_braces_in_flow_control_structures` to handle more cases\n- New lint: `prefer_double_quotes`\n- New lint: `sort_child_properties_last`\n- Fixed `type_annotate_public_apis` false positive for `static const`\n  initializers\n\n#### Pub\n\n- `pub publish` will no longer warn about missing dependencies for import\n  statements in `example/`.\n- OAuth2 authentication will explicitly ask for the `openid` scope.\n\n## 2.3.2 - 2019-06-11\n\nThis is a patch version release with a security improvement.\n\n### Security vulnerability\n\n- **Security improvement:** On Linux and Android, starting a process with\n  `Process.run`, `Process.runSync`, or `Process.start` would first search the\n  current directory before searching `PATH` (Issue [37101][]). This behavior\n  effectively put the current working directory in the front of `PATH`, even if\n  it wasn't in the `PATH`. This release changes that behavior to only searching\n  the directories in the `PATH` environment variable. Operating systems other\n  than Linux and Android didn't have this behavior and aren't affected by this\n  vulnerability.\n\n  This vulnerability could result in execution of untrusted code if a command\n  without a slash in its name was run inside an untrusted directory containing\n  an executable file with that name:\n\n  ```dart\n  Process.run(\"ls\", workingDirectory: \"/untrusted/directory\")\n  ```\n\n  This would attempt to run `/untrusted/directory/ls` if it existed, even though\n  it is not in the `PATH`. It was always safe to instead use an absolute path or\n  a path containing a slash.\n\n  This vulnerability was introduced in Dart 2.0.0.\n\n[37101]: https://github.com/dart-lang/sdk/issues/37101\n\n## 2.3.1 - 2019-05-21\n\nThis is a patch version release with bug fixes.\n\n### Tools\n\n#### dart2js\n\n- Fixed a bug that caused the compiler to crash when it compiled UI-as-code\n  features within fields (Issue [36864][]).\n\n[36864]: https://github.com/dart-lang/sdk/issues/36864\n\n## 2.3.0 - 2019-05-08\n\nThe focus in this release is on the new \"UI-as-code\" language features which\nmake collections more expressive and declarative.\n\n### Language\n\nFlutter is growing rapidly, which means many Dart users are building UI in code\nout of big deeply-nested expressions. Our goal with 2.3.0 was to [make that kind\nof code easier to write and maintain][ui-as-code]. Collection literals are a\nlarge component, so we focused on three features to make collections more\npowerful. We'll use list literals in the examples below, but these features also\nwork in map and set literals.\n\n[ui-as-code]:\n  https://medium.com/dartlang/making-dart-a-better-language-for-ui-f1ccaf9f546c\n\n#### Spread\n\nPlacing `...` before an expression inside a collection literal unpacks the\nresult of the expression and inserts its elements directly inside the new\ncollection. Where before you had to write something like this:\n\n```dart\nCupertinoPageScaffold(\n  child: ListView(children: [\n    Tab2Header()\n  ]..addAll(buildTab2Conversation())\n    ..add(buildFooter())),\n);\n```\n\nNow you can write this:\n\n```dart\nCupertinoPageScaffold(\n  child: ListView(children: [\n    Tab2Header(),\n    ...buildTab2Conversation(),\n    buildFooter()\n  ]),\n);\n```\n\nIf you know the expression might evaluate to null and you want to treat that as\nequivalent to zero elements, you can use the null-aware spread `...?`.\n\n#### Collection if\n\nSometimes you might want to include one or more elements in a collection only\nunder certain conditions. If you're lucky, you can use a `?:` operator to\nselectively swap out a single element, but if you want to exchange more than one\nor omit elements, you are forced to write imperative code like this:\n\n```dart\nWidget build(BuildContext context) {\n  var children = [\n    IconButton(icon: Icon(Icons.menu)),\n    Expanded(child: title)\n  ];\n\n  if (isAndroid) {\n    children.add(IconButton(icon: Icon(Icons.search)));\n  }\n\n  return Row(children: children);\n}\n```\n\nWe now allow `if` inside collection literals to conditionally omit or (with\n`else`) swap out an element:\n\n```dart\nWidget build(BuildContext context) {\n  return Row(\n    children: [\n      IconButton(icon: Icon(Icons.menu)),\n      Expanded(child: title),\n      if (isAndroid)\n        IconButton(icon: Icon(Icons.search)),\n    ],\n  );\n}\n```\n\nUnlike the existing `?:` operator, a collection `if` can be composed with\nspreads to conditionally include or omit multiple items:\n\n```dart\nWidget build(BuildContext context) {\n  return Row(\n    children: [\n      IconButton(icon: Icon(Icons.menu)),\n      if (isAndroid) ...[\n        Expanded(child: title),\n        IconButton(icon: Icon(Icons.search)),\n      ]\n    ],\n  );\n}\n```\n\n#### Collection for\n\nIn many cases, the higher-order methods on Iterable give you a declarative way\nto modify a collection in the context of a single expression. But some\noperations, especially involving both transforming and filtering, can be\ncumbersome to express in a functional style.\n\nTo solve this problem, you can use `for` inside a collection literal. Each\niteration of the loop produces an element which is then inserted in the\nresulting collection. Consider the following code:\n\n```dart\nvar command = [\n  engineDartPath,\n  frontendServer,\n  ...fileSystemRoots.map((root) => \"--filesystem-root=$root\"),\n  ...entryPoints\n      .where((entryPoint) => fileExists(\"lib/$entryPoint.json\"))\n      .map((entryPoint) => \"lib/$entryPoint\"),\n  mainPath\n];\n```\n\nWith a collection `for`, the code becomes simpler:\n\n```dart\nvar command = [\n  engineDartPath,\n  frontendServer,\n  for (var root in fileSystemRoots) \"--filesystem-root=$root\",\n  for (var entryPoint in entryPoints)\n    if (fileExists(\"lib/$entryPoint.json\")) \"lib/$entryPoint\",\n  mainPath\n];\n```\n\nAs you can see, all three of these features can be freely composed. For full\ndetails of the changes, see [the official proposal][ui-as-code proposal].\n\n[ui-as-code proposal]:\n  https://github.com/dart-lang/language/blob/master/accepted/future-releases/unified-collections/feature-specification.md\n\n**Note: These features are not currently supported in _const_ collection\nliterals. In a future release, we intend to relax this restriction and allow\nspread and collection `if` inside const collections.**\n\n### Core library changes\n\n#### `dart:isolate`\n\n- Added `debugName` property to `Isolate`.\n- Added `debugName` optional parameter to `Isolate.spawn` and\n  `Isolate.spawnUri`.\n\n#### `dart:core`\n\n- RegExp patterns can now use lookbehind assertions.\n- RegExp patterns can now use named capture groups and named backreferences.\n  Currently, named group matches can only be retrieved in Dart either by the\n  implicit index of the named group or by downcasting the returned Match object\n  to the type RegExpMatch. The RegExpMatch interface contains methods for\n  retrieving the available group names and retrieving a match by group name.\n\n### Dart VM\n\n- The VM service now requires an authentication code by default. This behavior\n  can be disabled by providing the `--disable-service-auth-codes` flag.\n\n- Support for deprecated flags '-c' and '--checked' has been removed.\n\n### Dart for the Web\n\n#### dart2js\n\nA binary format was added to dump-info. The old JSON format is still available\nand provided by default, but we are starting to deprecate it. The new binary\nformat is more compact and cheaper to generate. On some large apps we tested, it\nwas 4x faster to serialize and used 6x less memory.\n\nTo use the binary format today, use `--dump-info=binary`, instead of\n`--dump-info`.\n\nWhat to expect next?\n\n- The [visualizer tool][visualizer] will not be updated to support the new\n  binary format, but you can find several command-line tools at\n  `package:dart2js_info` that provide similar features to those in the\n  visualizer.\n\n- The command-line tools in `package:dart2js_info` also work with the old JSON\n  format, so you can start using them even before you enable the new format.\n\n- In a future release `--dump-info` will default to `--dump-info=binary`. At\n  that point, there will be an option to fallback to the JSON format, but the\n  visualizer tool will be deprecated.\n\n- A release after that, the JSON format will no longer be available from\n  dart2js, but may be available from a command-line tool in\n  `package:dart2js_info`.\n\n[visualizer]: https://dart-lang.github.io/dump-info-visualizer/\n\n### Tools\n\n#### dartfmt\n\n- Tweak set literal formatting to follow other collection literals.\n- Add support for \"UI as code\" features.\n- Properly format trailing commas in assertions.\n- Improve indentation of adjacent strings in argument lists.\n\n#### Linter\n\nThe Linter was updated to `0.1.86`, which includes the following changes:\n\n- Added the following lints: `prefer_inlined_adds`,\n  `prefer_for_elements_to_map_fromIterable`,\n  `prefer_if_elements_to_conditional_expressions`,\n  `diagnostic_describe_all_properties`.\n- Updated `file_names` to skip prefixed-extension Dart files (`.css.dart`,\n  `.g.dart`, etc.).\n- Fixed false positives in `unnecessary_parenthesis`.\n\n#### Pub\n\n- Added a CHANGELOG validator that complains if you `pub publish` without\n  mentioning the current version.\n- Removed validation of library names when doing `pub publish`.\n- Added support for `pub global activate`ing package from a custom pub URL.\n- Added subcommand: `pub logout`. Logs you out of the current session.\n\n#### Dart native\n\nInitial support for compiling Dart apps to native machine code has been added.\nTwo new tools have been added to the `bin` folder of the Dart SDK:\n\n- `dart2aot`: AOT (ahead-of-time) compiles a Dart program to native machine\n  code. The tool is supported on Windows, macOS, and Linux.\n\n- `dartaotruntime`: A small runtime used for executing an AOT compiled program.\n\n## 2.2.0 - 2019-02-26\n\n### Language\n\nSets now have a literal syntax like lists and maps do:\n\n```dart\nvar set = {1, 2, 3};\n```\n\nUsing curly braces makes empty sets ambiguous with maps:\n\n```dart\nvar collection = {}; // Empty set or map?\n```\n\nTo avoid breaking existing code, an ambiguous literal is treated as a map. To\ncreate an empty set, you can rely on either a surrounding context type or an\nexplicit type argument:\n\n```dart\n// Variable type forces this to be a set:\nSet<int> set = {};\n\n// A single type argument means this must be a set:\nvar set2 = <int>{};\n```\n\nSet literals are released on all platforms. The `set-literals` experiment flag\nhas been disabled.\n\n### Tools\n\n#### Analyzer\n\n- The `DEPRECATED_MEMBER_USE` hint was split into two hints:\n\n  - `DEPRECATED_MEMBER_USE` reports on usage of `@deprecated` members declared\n    in a different package.\n  - `DEPRECATED_MEMBER_USE_FROM_SAME_PACKAGE` reports on usage of `@deprecated`\n    members declared in the same package.\n\n#### Linter\n\nUpgraded the linter to `0.1.82` which adds the following improvements:\n\n- Added `provide_deprecation_message`, and\n  `use_full_hex_values_for_flutter_colors`, `prefer_null_aware_operators`.\n- Fixed `prefer_const_declarations` set literal false-positives.\n- Updated `prefer_collection_literals` to support set literals.\n- Updated `unnecessary_parenthesis` play nicer with cascades.\n- Removed deprecated lints from the \"all options\" sample.\n- Stopped registering \"default lints\".\n- Fixed `hash_and_equals` to respect `hashCode` fields.\n\n### Other libraries\n\n#### `package:kernel`\n\n- **Breaking change:** The `klass` getter on the `InstanceConstant` class in the\n  Kernel AST API has been renamed to `classNode` for consistency.\n\n- **Breaking change:** Updated `Link` implementation to utilize true symbolic\n  links instead of junctions on Windows. Existing junctions will continue to\n  work with the new `Link` implementation, but all new links will create\n  symbolic links.\n\n  To create a symbolic link, Dart must be run with administrative privileges or\n  Developer Mode must be enabled, otherwise a `FileSystemException` will be\n  raised with errno set to `ERROR_PRIVILEGE_NOT_HELD` (Issue [33966]).\n\n[33966]: https://github.com/dart-lang/sdk/issues/33966\n\n## 2.1.1 - 2019-02-18\n\nThis is a patch version release. Again, the team's focus was mostly on improving\nperformance and stability after the large changes in Dart 2.0.0. In particular,\ndart2js now always uses the \"fast startup\" emitter and the old emitter has been\nremoved.\n\nThere are a couple of very minor **breaking changes:**\n\n- In `dart:io`, adding to a closed `IOSink` now throws a `StateError`.\n\n- On the Dart VM, a soundness hole when using `dart:mirrors` to reflectively\n  invoke a method in an incorrect way that violates its static types has been\n  fixed (Issue [35611][]).\n\n### Language\n\nThis release has no language changes.\n\n### Core library\n\n#### `dart:core`\n\n- Made `DateTime.parse()` also recognize `,` as a valid decimal separator when\n  parsing from a string (Issue [35576][]).\n\n[35576]: https://github.com/dart-lang/sdk/issues/35576\n\n#### `dart:html`\n\n- Added methods `Element.removeAttribute`, `Element.removeAttributeNS`,\n  `Element.hasAttribute` and `Element.hasAttributeNS`. (Issue [35655][]).\n- Improved dart2js compilation of `element.attributes.remove(name)` to generate\n  `element.removeAttribute(name)`, so that there is no performance reason to\n  migrate to the above methods.\n- Fixed a number of `dart:html` bugs:\n\n  - Fixed HTML API's with callback typedef to correctly convert Dart functions\n    to JS functions (Issue [35484]).\n  - HttpStatus constants exposed in `dart:html` (Issue [34318]).\n  - Expose DomName `ondblclick` and `dblclickEvent` for Angular analyzer.\n  - Fixed `removeAll` on `classes`; `elements` parameter should be\n    `Iterable<Object>` to match Set's `removeAll` not `Iterable<E>` (Issue\n    [30278]).\n  - Fixed a number of methods on DataTransferItem, Entry, FileEntry and\n    DirectoryEntry which previously returned NativeJavaScriptObject. This fixes\n    handling drag/drop of files/directories (Issue [35510]).\n  - Added ability to allow local file access from Chrome browser in ddb.\n\n[35655]: https://github.com/dart-lang/sdk/issues/35655\n[30278]: https://github.com/dart-lang/sdk/issues/30278\n[34318]: https://github.com/dart-lang/sdk/issues/34318\n[35484]: https://github.com/dart-lang/sdk/issues/35484\n[35510]: https://github.com/dart-lang/sdk/issues/35510\n\n#### `dart:io`\n\n- **Breaking Change:** Adding to a closed `IOSink` now throws a `StateError`.\n- Added ability to get and set low level socket options.\n\n[29554]: https://github.com/dart-lang/sdk/issues/29554\n\n### Dart VM\n\nIn previous releases it was possible to violate static types using\n`dart:mirrors`. This code would run without any TypeErrors and print\n\"impossible\" output:\n\n```dart\nimport 'dart:mirrors';\n\nclass A {\n  void method(int v) {\n    if (v != null && v is! int) {\n      print(\"This should be impossible: expected null or int got ${v}\");\n    }\n  }\n}\n\nvoid main() {\n  final obj = A();\n  reflect(obj).invoke(#method, ['not-an-number']);\n}\n```\n\nThis bug is fixed now. Only code that already violates static typing will break.\nSee Issue [35611][] for more details.\n\n[35611]: https://github.com/dart-lang/sdk/issues/35611\n\n### Dart for the Web\n\n#### dart2js\n\n- The old \"full emitter\" back-end is removed and dart2js always uses the \"fast\n  startup\" back-end. The generated fast startup code is optimized to load\n  faster, even though it can be slightly larger. The `--fast-startup` and\n  `--no-fast-startup` are allowed but ignored. They will be removed in a future\n  version.\n\n- We fixed a bug in how deferred constructor calls were incorrectly not marked\n  as deferred. The old behavior didn't cause breakages, but was imprecise and\n  pushed more code to the main output unit.\n\n- A new deferred split algorithm implementation was added.\n\n  This implementation fixes a soundness bug and addresses performance issues of\n  the previous implementation, because of that it can have a visible impact on\n  apps. In particular:\n\n  - We fixed a performance issue which was introduced when we migrated to the\n    common front-end. On large apps, the fix can cut 2/3 of the time spent on\n    this task.\n\n  - We fixed a bug in how inferred types were categorized (Issue [35311][]). The\n    old behavior was unsound and could produce broken programs. The fix may\n    cause more code to be pulled into the main output unit.\n\n    This shows up frequently when returning deferred values from closures since\n    the closure's inferred return type is the deferred type. For example, if you\n    have:\n\n    ```dart\n    () async {\n      await deferred_prefix.loadLibrary();\n      return new deferred_prefix.Foo();\n    }\n    ```\n\n    The closure's return type is `Future<Foo>`. The old implementation defers\n    `Foo`, and incorrectly makes the return type `Future<dynamic>`. This may\n    break in places where the correct type is expected.\n\n    The new implementation will not defer `Foo`, and will place it in the main\n    output unit. If your intent is to defer it, then you need to ensure the\n    return type is not inferred to be `Foo`. For example, you can do so by\n    changing the code to a named closure with a declared type, or by ensuring\n    that the return expression has the type you want, like:\n\n    ```dart\n    () async {\n      await deferred_prefix.loadLibrary();\n      return new deferred_prefix.Foo() as dynamic;\n    }\n    ```\n\n    Because the new implementation might require you to inspect and fix your\n    app, we exposed two temporary flags:\n\n  - The `--report-invalid-deferred-types` causes dart2js to run both the old and\n    new algorithms and report any cases where an invalid type was detected.\n\n  - The `--new-deferred-split` flag enables this new algorithm.\n\n- The `--categories=*` flag is being replaced. `--categories=all` was only used\n  for testing and it is no longer supported. `--categories=Server` continues to\n  work at this time but it is deprecated, please use `--server-mode` instead.\n\n- The `--library-root` flag was replaced by `--libraries-spec`. This flag is\n  rarely used by developers invoking dart2js directly. It's important for\n  integrating dart2js with build systems. See `--help` for more details on the\n  new flag.\n\n[35311]: https://github.com/dart-lang/sdk/issues/35311\n\n### Tools\n\n#### Analyzer\n\n- Support for `declarations-casts` has been removed and the `implicit-casts`\n  option now has the combined semantics of both options. This means that users\n  that disable `implicit-casts` might now see errors that were not previously\n  being reported.\n\n- New hints added:\n\n  - `NON_CONST_CALL_TO_LITERAL_CONSTRUCTOR` and\n    `NON_CONST_CALL_TO_LITERAL_CONSTRUCTOR_USING_NEW` inform you when a\n    `@literal` const constructor is called in a non-const context (or with\n    `new`).\n  - `INVALID_LITERAL_ANNOTATION` reports when something other than a const\n    constructor is annotated with `@literal`.\n  - `SUBTYPE_OF_SEALED_CLASS` reports when any class or mixin subclasses\n    (extends, implements, mixes in, or constrains to) a `@sealed` class, and the\n    two are declared in different packages.\n  - `MIXIN_ON_SEALED_CLASS` reports when a `@sealed` class is used as a\n    superclass constraint of a mixin.\n\n#### dartdoc\n\nDefault styles now work much better on mobile. Simple browsing and searching of\nAPI docs now work in many cases.\n\nUpgraded the linter to `0.1.78` which adds the following improvements:\n\n- Added `prefer_final_in_for_each`, `unnecessary_await_in_return`,\n  `use_function_type_syntax_for_parameters`, `avoid_returning_null_for_future`,\n  and `avoid_shadowing_type_parameters`.\n- Updated `invariant_booleans` status to experimental.\n- Fixed `type_annotate_public_apis` false positives on local functions.\n- Fixed `avoid_shadowing_type_parameters` to report shadowed type parameters in\n  generic typedefs.\n- Fixed `use_setters_to_change_properties` to not wrongly lint overriding\n  methods.\n- Fixed `cascade_invocations` to not lint awaited targets.\n- Fixed `prefer_conditional_assignment` false positives.\n- Fixed `join_return_with_assignment` false positives.\n- Fixed `cascade_invocations` false positives.\n- Deprecated `prefer_bool_in_asserts` as it is redundant in Dart 2.\n\n## 2.1.0 - 2018-11-15\n\nThis is a minor version release. The team's focus was mostly on improving\nperformance and stability after the large changes in Dart 2.0.0. Notable\nchanges:\n\n- We've introduced a dedicated syntax for declaring a mixin. Instead of the\n  `class` keyword, it uses `mixin`:\n\n  ```dart\n  mixin SetMixin<E> implements Set<E> {\n    ...\n  }\n  ```\n\n  The new syntax also enables `super` calls inside mixins.\n\n- Integer literals now work in double contexts. When passing a literal number to\n  a function that expects a `double`, you no longer need an explicit `.0` at the\n  end of the number. In releases before 2.1, you need code like this when\n  setting a double like `fontSize`:\n\n  ```dart\n  TextStyle(fontSize: 18.0)\n  ```\n\n  Now you can remove the `.0`:\n\n  ```dart\n  TextStyle(fontSize: 18)\n  ```\n\n  In releases before 2.1, `fontSize : 18` causes a static error. This was a\n  common mistake and source of friction.\n\n- **Breaking change:** A number of static errors that should have been detected\n  and reported were not supported in 2.0.0. These are reported now, which means\n  existing incorrect code may show new errors.\n\n- `dart:core` now exports `Future` and `Stream`. You no longer need to import\n  `dart:async` to use those very common types.\n\n### Language\n\n- Introduced a new syntax for mixin declarations.\n\n  ```dart\n  mixin SetMixin<E> implements Set<E> {\n    ...\n  }\n  ```\n\n  Most classes that are intended to be used as mixins are intended to _only_ be\n  used as mixins. The library author doesn't want users to be able to construct\n  or subclass the class. The new syntax makes that intent clear and enforces it\n  in the type system. It is an error to extend or construct a type declared\n  using `mixin`. (You can implement it since mixins expose an implicit\n  interface.)\n\n  Over time, we expect most mixin declarations to use the new syntax. However,\n  if you have a \"mixin\" class where users _are_ extending or constructing it,\n  note that moving it to the new syntax is a breaking API change since it\n  prevents users from doing that. If you have a type like this that is a mixin\n  as well as being a concrete class and/or superclass, then the existing syntax\n  is what you want.\n\n  If you need to use a `super` inside a mixin, the new syntax is required. This\n  was previously only allowed with the experimental `--supermixins` flag because\n  it has some complex interactions with the type system. The new syntax\n  addresses those issues and lets you use `super` calls by declaring the\n  superclass constraint your mixin requires:\n\n  ```dart\n  class Superclass {\n    superclassMethod() {\n      print(\"in superclass\");\n    }\n  }\n\n  mixin SomeMixin on Superclass {\n    mixinMethod() {\n      // This is OK:\n      super.superclassMethod();\n    }\n  }\n\n  class GoodSub extends Superclass with SomeMixin {}\n\n  class BadSub extends Object with SomeMixin {}\n  // Error: Since the super() call in mixinMethod() can't find a\n  // superclassMethod() to call, this is prohibited.\n  ```\n\n  Even if you don't need to use `super` calls, the new mixin syntax is good\n  because it clearly expresses that you intend the type to be mixed in.\n\n- Allow integer literals to be used in double contexts. An integer literal used\n  in a place where a double is required is now interpreted as a double value.\n  The numerical value of the literal needs to be precisely representable as a\n  double value.\n\n- Integer literals compiled to JavaScript are now allowed to have any value that\n  can be exactly represented as a JavaScript `Number`. They were previously\n  limited to such numbers that were also representable as signed 64-bit\n  integers.\n\n**(Breaking)** A number of static errors that should have been detected and\nreported were not supported in 2.0.0. These are reported now, which means\nexisting incorrect code may show new errors:\n\n- **Setters with the same name as the enclosing class aren't allowed.** (Issue\n  [34225][].) It is not allowed to have a class member with the same name as the\n  enclosing class:\n\n  ```dart\n  class A {\n    set A(int x) {}\n  }\n  ```\n\n  Dart 2.0.0 incorrectly allows this for setters (only). Dart 2.1.0 rejects it.\n\n  _To fix:_ This is unlikely to break anything, since it violates all style\n  guides anyway.\n\n- **Constant constructors cannot redirect to non-constant constructors.** (Issue\n  [34161][].) It is not allowed to have a constant constructor that redirects to\n  a non-constant constructor:\n\n  ```dart\n  class A {\n    const A.foo() : this(); // Redirecting to A()\n    A() {}\n  }\n  ```\n\n  Dart 2.0.0 incorrectly allows this. Dart 2.1.0 rejects it.\n\n  _To fix:_ Make the target of the redirection a properly const constructor.\n\n- **Abstract methods may not unsoundly override a concrete method.** (Issue\n  [32014][].) Concrete methods must be valid implementations of their\n  interfaces:\n\n  ```dart\n  class A {\n    num get thing => 2.0;\n  }\n\n  abstract class B implements A {\n    int get thing;\n  }\n\n  class C extends A with B {}\n  // 'thing' from 'A' is not a valid override of 'thing' from 'B'.\n\n  main() {\n    print(new C().thing.isEven); // Expects an int but gets a double.\n  }\n  ```\n\n  Dart 2.0.0 allows unsound overrides like the above in some cases. Dart 2.1.0\n  rejects them.\n\n  _To fix:_ Relax the type of the invalid override, or tighten the type of the\n  overridden method.\n\n- **Classes can't implement FutureOr.** (Issue [33744][].) Dart doesn't allow\n  classes to implement the FutureOr type:\n\n  ```dart\n  class A implements FutureOr<Object> {}\n  ```\n\n  Dart 2.0.0 allows classes to implement FutureOr. Dart 2.1.0 does not.\n\n  _To fix:_ Don't do this.\n\n- **Type arguments to generic typedefs must satisfy their bounds.** (Issue\n  [33308][].) If a parameterized typedef specifies a bound, actual arguments\n  must be checked against it:\n\n  ```dart\n  class A<X extends int> {}\n\n  typedef F<Y extends int> = A<Y> Function();\n\n  F<num> f = null;\n  ```\n\n  Dart 2.0.0 allows bounds violations like `F<num>` above. Dart 2.1.0 rejects\n  them.\n\n  _To fix:_ Either remove the bound on the typedef parameter, or pass a valid\n  argument to the typedef.\n\n- **Constructor invocations must use valid syntax, even with optional `new`.**\n  (Issue [34403][].) Type arguments to generic named constructors go after the\n  class name, not the constructor name, even when used without an explicit\n  `new`:\n\n  ```dart\n  class A<T> {\n    A.foo() {}\n  }\n\n  main() {\n    A.foo<String>(); // Incorrect syntax, was accepted in 2.0.0.\n    A<String>.foo(); // Correct syntax.\n  }\n  ```\n\n  Dart 2.0.0 accepts the incorrect syntax when the `new` keyword is left out.\n  Dart 2.1.0 correctly rejects this code.\n\n  _To fix:_ Move the type argument to the correct position after the class name.\n\n- **Instance members should shadow prefixes.** (Issue [34498][].) If the same\n  name is used as an import prefix and as a class member name, then the class\n  member name takes precedence in the class scope.\n\n  ```dart\n  import 'dart:core';\n  import 'dart:core' as core;\n\n  class A {\n    core.List get core => null; // \"core\" refers to field, not prefix.\n  }\n  ```\n\n  Dart 2.0.0 incorrectly resolves the use of `core` in `core.List` to the prefix\n  name. Dart 2.1.0 correctly resolves this to the field name.\n\n  _To fix:_ Change the prefix name to something which does not clash with the\n  instance member.\n\n- **Implicit type arguments in extends clauses must satisfy the class bounds.**\n  (Issue [34532][].) Implicit type arguments for generic classes are computed if\n  not passed explicitly, but when used in an `extends` clause they must be\n  checked for validity:\n\n  ```dart\n  class Foo<T> {}\n\n  class Bar<T extends Foo<T>> {}\n\n  class Baz extends Bar {} // Should error because Bar completes to Bar<Foo>\n  ```\n\n  Dart 2.0.0 accepts the broken code above. Dart 2.1.0 rejects it.\n\n  _To fix:_ Provide explicit type arguments to the superclass that satisfy the\n  bound for the superclass.\n\n- **Mixins must correctly override their superclasses.** (Issue [34235][].) In\n  some rare cases, combinations of uses of mixins could result in invalid\n  overrides not being caught:\n\n  ```dart\n  class A {\n    num get thing => 2.0;\n  }\n\n  class M1 {\n    int get thing => 2;\n  }\n\n  class B = A with M1;\n\n  class M2 {\n    num get thing => 2.0;\n  }\n\n  class C extends B with M2 {} // 'thing' from 'M2' not a valid override.\n\n  main() {\n    M1 a = new C();\n    print(a.thing.isEven); // Expects an int but gets a double.\n  }\n  ```\n\n  Dart 2.0.0 accepts the above example. Dart 2.1.0 rejects it.\n\n  _To fix:_ Ensure that overriding methods are correct overrides of their\n  superclasses, either by relaxing the superclass type, or tightening the\n  subclass/mixin type.\n\n[32014]: https://github.com/dart-lang/sdk/issues/32014\n[33308]: https://github.com/dart-lang/sdk/issues/33308\n[33744]: https://github.com/dart-lang/sdk/issues/33744\n[34161]: https://github.com/dart-lang/sdk/issues/34161\n[34225]: https://github.com/dart-lang/sdk/issues/34225\n[34235]: https://github.com/dart-lang/sdk/issues/34235\n[34403]: https://github.com/dart-lang/sdk/issues/34403\n[34498]: https://github.com/dart-lang/sdk/issues/34498\n[34532]: https://github.com/dart-lang/sdk/issues/34532\n\n### Core libraries\n\n#### `dart:async`\n\n- Fixed a bug where calling `stream.take(0).drain(value)` would not correctly\n  forward the `value` through the returned `Future`.\n- Added a `StreamTransformer.fromBind` constructor.\n- Updated `Stream.fromIterable` to send a done event after the error when the\n  iterator's `moveNext` throws, and handle if the `current` getter throws (issue\n  [33431][]).\n\n[33431]: http://dartbug.com/33431\n\n#### `dart:core`\n\n- Added `HashMap.fromEntries` and `LinkedHashmap.fromEntries` constructors.\n- Added `ArgumentError.checkNotNull` utility method.\n- Made `Uri` parsing more permissive about `[` and `]` occurring in the path,\n  query or fragment, and `#` occurring in fragment.\n- Exported `Future` and `Stream` from `dart:core`.\n- Added operators `&`, `|` and `^` to `bool`.\n- Added missing methods to `UnmodifiableMapMixin`. Some maps intended to be\n  unmodifiable incorrectly allowed new methods added in Dart 2 to succeed.\n- Deprecated the `provisional` annotation and the `Provisional` annotation\n  class. These should have been removed before releasing Dart 2.0, and they have\n  no effect.\n\n#### `dart:html`\n\nFixed Service Workers and any Promise/Future API with a Dictionary parameter.\n\nAPIs in dart:html (that take a Dictionary) will receive a Dart Map parameter.\nThe Map parameter must be converted to a Dictionary before passing to the\nbrowser's API. Before this change, any Promise/Future API with a Map/Dictionary\nparameter never called the Promise and didn't return a Dart Future - now it\ndoes.\n\nThis caused a number of breaks especially in Service Workers (register, etc.).\nHere is a complete list of the fixed APIs:\n\n- BackgroundFetchManager\n  - `Future<BackgroundFetchRegistration> fetch(String id, Object requests, [Map options])`\n- CacheStorage\n  - `Future match(/*RequestInfo*/ request, [Map options])`\n- CanMakePayment\n  - `Future<List<Client>> matchAll([Map options])`\n- CookieStore\n  - `Future getAll([Map options])`\n  - `Future set(String name, String value, [Map options])`\n- CredentialsContainer\n  - `Future get([Map options])`\n  - `Future create([Map options])`\n- ImageCapture\n  - `Future setOptions(Map photoSettings)`\n- MediaCapabilities\n  - `Future<MediaCapabilitiesInfo> decodingInfo(Map configuration)`\n  - `Future<MediaCapabilitiesInfo> encodingInfo(Map configuration)`\n- MediaStreamTrack\n  - `Future applyConstraints([Map constraints])`\n- Navigator\n  - `Future requestKeyboardLock([List<String> keyCodes])`\n  - `Future requestMidiAccess([Map options])`\n  - `Future share([Map data])`\n- OffscreenCanvas\n  - `Future<Blob> convertToBlob([Map options])`\n- PaymentInstruments\n  - `Future set(String instrumentKey, Map details)`\n- Permissions\n  - `Future<PermissionStatus> query(Map permission)`\n  - `Future<PermissionStatus> request(Map permissions)`\n  - `Future<PermissionStatus> revoke(Map permission)`\n- PushManager\n  - `Future permissionState([Map options])`\n  - `Future<PushSubscription> subscribe([Map options])`\n- RtcPeerConnection\n\n  - Changed:\n\n    ```dart\n    Future createAnswer([options_OR_successCallback,\n        RtcPeerConnectionErrorCallback failureCallback,\n        Map mediaConstraints])\n    ```\n\n    to:\n\n    ```dart\n    Future<RtcSessionDescription> createAnswer([Map options])\n    ```\n\n  - Changed:\n\n    ```dart\n    Future createOffer([options_OR_successCallback,\n        RtcPeerConnectionErrorCallback failureCallback,\n        Map rtcOfferOptions])\n    ```\n\n    to:\n\n    ```dart\n    Future<RtcSessionDescription> createOffer([Map options])\n    ```\n\n  - Changed:\n\n    ```dart\n    Future setLocalDescription(Map description,\n        VoidCallback successCallback,\n        [RtcPeerConnectionErrorCallback failureCallback])\n    ```\n\n    to:\n\n    ```dart\n    Future setLocalDescription(Map description)\n    ```\n\n  - Changed:\n\n    ```dart\n    Future setLocalDescription(Map description,\n        VoidCallback successCallback,\n        [RtcPeerConnectionErrorCallback failureCallback])\n    ```\n\n    to:\n\n    ```dart\n    Future setRemoteDescription(Map description)\n    ```\n\n- ServiceWorkerContainer\n  - `Future<ServiceWorkerRegistration> register(String url, [Map options])`\n- ServiceWorkerRegistration\n  - `Future<List<Notification>> getNotifications([Map filter])`\n  - `Future showNotification(String title, [Map options])`\n- VRDevice\n  - `Future requestSession([Map options])`\n  - `Future supportsSession([Map options])`\n- VRSession\n  - `Future requestFrameOfReference(String type, [Map options])`\n- Window\n  - `Future fetch(/*RequestInfo*/ input, [Map init])`\n- WorkerGlobalScope\n  - `Future fetch(/*RequestInfo*/ input, [Map init])`\n\nIn addition, exposed Service Worker \"self\" as a static getter named \"instance\".\nThe instance is exposed on four different Service Worker classes and can throw a\nInstanceTypeError if the instance isn't of the class expected\n(WorkerGlobalScope.instance will always work and not throw):\n\n- `SharedWorkerGlobalScope.instance`\n- `DedicatedWorkerGlobalScope.instance`\n- `ServiceWorkerGlobalScope.instance`\n- `WorkerGlobalScope.instance`\n\n#### `dart:io`\n\n- Added new HTTP status codes.\n\n### Dart for the Web\n\n#### dart2js\n\n- **(Breaking)** Duplicate keys in a const map are not allowed and produce a\n  compile-time error. Dart2js used to report this as a warning before. This was\n  already an error in dartanalyzer and DDC and will be an error in other tools\n  in the future as well.\n\n- Added `-O` flag to tune optimization levels. For more details run\n  `dart2js -h -v`.\n\n  We recommend to enable optimizations using the `-O` flag instead of individual\n  flags for each optimization. This is because the `-O` flag is intended to be\n  stable and continue to work in future versions of dart2js, while individual\n  flags may come and go.\n\n  At this time we recommend to test and debug with `-O1` and to deploy with\n  `-O3`.\n\n### Tool Changes\n\n#### dartfmt\n\n- Addressed several dartfmt issues when used with the new CFE parser.\n\n#### Linter\n\nBumped the linter to `0.1.70` which includes the following new lints:\n\n- `avoid_returning_null_for_void`\n- `sort_pub_dependencies`\n- `prefer_mixin`\n- `avoid_implementing_value_types`\n- `flutter_style_todos`\n- `avoid_void_async`\n- `prefer_void_to_null`\n\nand improvements:\n\n- Fixed NPE in `prefer_iterable_whereType`.\n- Improved message display for `await_only_futures`\n- Performance improvements for `null_closures`\n- Mixin support\n- Updated `sort_constructors_first` to apply to all members.\n- Updated `unnecessary_this` to work on field initializers.\n- Updated `unawaited_futures` to ignore assignments within cascades.\n- Improved handling of constant expressions with generic type params.\n- NPE fix for `invariant_booleans`.\n- Improved docs for `unawaited_futures`.\n- Updated `unawaited_futures` to check cascades.\n- Relaxed `void_checks` (allowing `T Function()` to be assigned to\n  `void Function()`).\n- Fixed false positives in `lines_longer_than_80_chars`.\n\n#### Pub\n\n- Renamed the `--checked` flag to `pub run` to `--enable-asserts`.\n- Pub will no longer delete directories named \"packages\".\n- The `--packages-dir` flag is now ignored.\n\n## 2.0.0 - 2018-08-07\n\nThis is the first major version release of Dart since 1.0.0, so it contains many\nsignificant changes across all areas of the platform. Large changes include:\n\n- **(Breaking)** The unsound optional static type system has been replaced with\n  a sound static type system using type inference and runtime checks. This was\n  formerly called \"[strong mode][]\" and only used by the Dart for web products.\n  Now it is the one official static type system for the entire platform and\n  replaces the previous \"checked\" and \"production\" modes.\n\n- **(Breaking)** Functions marked `async` now run synchronously until the first\n  `await` statement. Previously, they would return to the event loop once at the\n  top of the function body before any code runs ([issue 30345][]).\n\n- **(Breaking)** Constants in the core libraries have been renamed from\n  `SCREAMING_CAPS` to `lowerCamelCase`.\n\n- **(Breaking)** Many new methods have been added to core library classes. If\n  you implement the interfaces of these classes, you will need to implement the\n  new methods.\n\n- **(Breaking)** \"dart:isolate\" and \"dart:mirrors\" are no longer supported when\n  using Dart for the web. They are still supported in the command-line VM.\n\n- **(Breaking)** Pub's transformer-based build system has been [replaced by a\n  new build system][transformers].\n\n- The `new` keyword is optional and can be omitted. Likewise, `const` can be\n  omitted inside a const context ([issue 30921][]).\n\n- Dartium is no longer maintained or supported.\n\n[issue 30345]: https://github.com/dart-lang/sdk/issues/30345\n[issue 30921]: https://github.com/dart-lang/sdk/issues/30921\n[strong mode]: https://www.dartlang.org/guides/language/sound-dart\n[transformers]: https://www.dartlang.org/tools/pub/obsolete\n\n### Language\n\n- \"[Strong mode][]\" is now the official type system of the language.\n\n- The `new` keyword is optional and can be omitted. Likewise, `const` can be\n  omitted inside a const context.\n\n- A string in a `part of` declaration may now be used to refer to the library\n  this file is part of. A library part can now declare its library as either:\n\n  ```dart\n  part of name.of.library;\n  ```\n\n  Or:\n\n  ```dart\n  part of \"uriReferenceOfLibrary.dart\";\n  ```\n\n  This allows libraries with no library declarations (and therefore no name) to\n  have parts, and it allows tools to easily find the library of a part file. The\n  Dart 1.0 syntax is supported but deprecated.\n\n- Functions marked `async` now run synchronously until the first `await`\n  statement. Previously, they would return to the event loop once at the top of\n  the function body before any code runs ([issue 30345][]).\n\n- The type `void` is now a Top type like `dynamic`, and `Object`. It also now\n  has new errors for being used where not allowed (such as being assigned to any\n  non-`void`-typed parameter). Some libraries (importantly, mockito) may need to\n  be updated to accept void values to keep their APIs working.\n\n- Future flattening is now done only as specified in the Dart 2.0 spec, rather\n  than more broadly. This means that the following code has an error on the\n  assignment to `y`.\n\n  ```dart\n  test() {\n    Future<int> f;\n    var x = f.then<Future<List<int>>>((x) => []);\n    Future<List<int>> y = x;\n  }\n  ```\n\n- Invocations of `noSuchMethod()` receive default values for optional args. The\n  following program used to print \"No arguments passed\", and now prints \"First\n  argument is 3\".\n\n  ```dart\n  abstract class B {\n    void m([int x = 3]);\n  }\n\n  class A implements B {\n    noSuchMethod(Invocation i) {\n      if (i.positionalArguments.length == 0) {\n        print(\"No arguments passed\");\n      } else {\n        print(\"First argument is ${i.positionalArguments[0]}\");\n      }\n    }\n  }\n\n  void main() {\n    A().m();\n  }\n  ```\n\n- Bounds on generic functions are invariant. The following program now issues an\n  invalid override error ([issue 29014][sdk#29014]):\n\n  ```dart\n  class A {\n    void f<T extends int>() {}\n  }\n\n  class B extends A {\n    @override\n    void f<T extends num>() {}\n  }\n  ```\n\n- Numerous corner case bugs around return statements in synchronous and\n  asynchronous functions fixed. Specifically:\n\n  - Issues [31887][issue 31887], [32881][issue 32881]. Future flattening should\n    not be recursive.\n  - Issues [30638][issue 30638], [32233][issue 32233]. Incorrect downcast errors\n    with `FutureOr`.\n  - Issue [32233][issue 32233]. Errors when returning `FutureOr`.\n  - Issue [33218][issue 33218]. Returns in functions with void related types.\n  - Issue [31278][issue 31278]. Incorrect hint on empty returns in async.\n    functions.\n\n- An empty `return;` in an async function with return type `Future<Object>` does\n  not report an error.\n\n- `return exp;` where `exp` has type `void` in an async function is now an error\n  unless the return type of the function is `void` or `dynamic`.\n\n- Mixed return statements of the form `return;` and `return exp;` are now\n  allowed when `exp` has type `void`.\n\n- A compile time error is emitted for any literal which cannot be exactly\n  represented on the target platform. As a result, dart2js and DDC report errors\n  if an integer literal cannot be represented exactly in JavaScript ([issue\n  33282][]).\n\n- New member conflict rules have been implemented. Most cases of conflicting\n  members with the same name are now static errors ([issue 33235][]).\n\n[sdk#29014]: https://github.com/dart-lang/sdk/issues/29014\n[issue 30638]: https://github.com/dart-lang/sdk/issues/30638\n[issue 31278]: https://github.com/dart-lang/sdk/issues/31278\n[issue 31887]: https://github.com/dart-lang/sdk/issues/31887\n[issue 32233]: https://github.com/dart-lang/sdk/issues/32233\n[issue 32881]: https://github.com/dart-lang/sdk/issues/32881\n[issue 33218]: https://github.com/dart-lang/sdk/issues/33218\n[issue 33235]: https://github.com/dart-lang/sdk/issues/33235\n[issue 33282]: https://github.com/dart-lang/sdk/issues/33282\n[issue 33341]: https://github.com/dart-lang/sdk/issues/33341\n\n### Core libraries\n\n- Replaced `UPPER_CASE` constant names with `lowerCamelCase`. For example,\n  `HTML_ESCAPE` is now `htmlEscape`.\n\n- The Web libraries were re-generated using Chrome 63 WebIDLs ([details][idl]).\n\n[idl]: https://github.com/dart-lang/sdk/wiki/Chrome-63-Dart-Web-Libraries\n\n#### `dart:async`\n\n- `Stream`:\n  - Added `cast` and `castFrom`.\n  - Changed `firstWhere`, `lastWhere`, and `singleWhere` to return `Future<T>`\n    and added an optional `T orElse()` callback.\n- `StreamTransformer`: added `cast` and `castFrom`.\n- `StreamTransformerBase`: new class.\n- `Timer`: added `tick` property.\n- `Zone`\n  - changed to be strong-mode clean. This required some breaking API changes.\n    See https://goo.gl/y9mW2x for more information.\n  - Added `bindBinaryCallbackGuarded`, `bindCallbackGuarded`, and\n    `bindUnaryCallbackGuarded`.\n  - Renamed `Zone.ROOT` to `Zone.root`.\n- Removed the deprecated `defaultValue` parameter on `Stream.firstWhere` and\n  `Stream.lastWhere`.\n- Changed an internal lazily-allocated reusable \"null future\" to always belong\n  to the root zone. This avoids race conditions where the first access to the\n  future determined which zone it would belong to. The zone is only used for\n  _scheduling_ the callback of listeners, the listeners themselves will run in\n  the correct zone in any case. Issue [#32556](http://dartbug.com/32556).\n\n#### `dart:cli`\n\n- _New_ \"provisional\" library for CLI-specific features.\n- `waitFor`: function that suspends a stack to wait for a `Future` to complete.\n\n#### `dart:collection`\n\n- `MapBase`: added `mapToString`.\n- `LinkedHashMap` no longer implements `HashMap`\n- `LinkedHashSet` no longer implements `HashSet`.\n- Added `of` constructor to `Queue`, `ListQueue`, `DoubleLinkedQueue`,\n  `HashSet`, `LinkedHashSet`, `SplayTreeSet`, `Map`, `HashMap`, `LinkedHashMap`,\n  `SplayTreeMap`.\n- Removed `Maps` class. Extend `MapBase` or mix in `MapMixin` instead to provide\n  map method implementations for a class.\n- Removed experimental `Document` method `getCSSCanvasContext` and property\n  `supportsCssCanvasContext`.\n- Removed obsolete `Element` property `xtag` no longer supported in browsers.\n- Exposed `ServiceWorker` class.\n- Added constructor to `MessageChannel` and `MessagePort` `addEventListener`\n  automatically calls `start` method to receive queued messages.\n\n#### `dart:convert`\n\n- `Base64Codec.decode` return type is now `Uint8List`.\n- `JsonUnsupportedObjectError`: added `partialResult` property\n- `LineSplitter` now implements `StreamTransformer<String, String>` instead of\n  `Converter`. It retains `Converter` methods `convert` and\n  `startChunkedConversion`.\n- `Utf8Decoder` when compiled with dart2js uses the browser's `TextDecoder` in\n  some common cases for faster decoding.\n- Renamed `ASCII`, `BASE64`, `BASE64URI`, `JSON`, `LATIN1` and `UTF8` to\n  `ascii`, `base64`, `base64Uri`, `json`, `latin1` and `utf8`.\n- Renamed the `HtmlEscapeMode` constants `UNKNOWN`, `ATTRIBUTE`, `SQ_ATTRIBUTE`\n  and `ELEMENT` to `unknown`, `attribute`, `sqAttribute` and `elements`.\n- Added `jsonEncode`, `jsonDecode`, `base64Encode`, `base64UrlEncode` and\n  `base64Decode` top-level functions.\n- Changed return type of `encode` on `AsciiCodec` and `Latin1Codec`, and\n  `convert` on `AsciiEncoder`, `Latin1Encoder`, to `Uint8List`.\n- Allow `utf8.decoder.fuse(json.decoder)` to ignore leading Unicode BOM.\n\n#### `dart:core`\n\n- `BigInt` class added to support integers greater than 64-bits.\n- Deprecated the `proxy` annotation.\n- Added `Provisional` class and `provisional` field.\n- Added `pragma` annotation.\n- `RegExp` added static `escape` function.\n- The `Uri` class now correctly handles paths while running on Node.js on\n  Windows.\n- Core collection changes:\n  - `Iterable` added members `cast`, `castFrom`, `followedBy` and `whereType`.\n  - `Iterable.singleWhere` added `orElse` parameter.\n  - `List` added `+` operator, `first` and `last` setters, and `indexWhere` and\n    `lastIndexWhere` methods, and static `copyRange` and `writeIterable`\n    methods.\n  - `Map` added `fromEntries` constructor.\n  - `Map` added `addEntries`, `cast`, `entries`, `map`, `removeWhere`, `update`\n    and `updateAll` members.\n  - `MapEntry`: new class used by `Map.entries`.\n  - _Note_: if a class extends `IterableBase`, `ListBase`, `SetBase` or\n    `MapBase` (or uses the corresponding mixins) from `dart:collection`, the new\n    members are implemented automatically.\n  - Added `of` constructor to `List`, `Set`, `Map`.\n- Renamed `double.INFINITY`, `double.NEGATIVE_INFINITY`, `double.NAN`,\n  `double.MAX_FINITE` and `double.MIN_POSITIVE` to `double.infinity`,\n  `double.negativeInfinity`, `double.nan`, `double.maxFinite` and\n  `double.minPositive`.\n- Renamed the following constants in `DateTime` to lower case: `MONDAY` through\n  `SUNDAY`, `DAYS_PER_WEEK` (as `daysPerWeek`), `JANUARY` through `DECEMBER` and\n  `MONTHS_PER_YEAR` (as `monthsPerYear`).\n- Renamed the following constants in `Duration` to lower case:\n  `MICROSECONDS_PER_MILLISECOND` to `microsecondsPerMillisecond`,\n  `MILLISECONDS_PER_SECOND` to `millisecondsPerSecond`, `SECONDS_PER_MINUTE` to\n  `secondsPerMinute`, `MINUTES_PER_HOUR` to `minutesPerHour`, `HOURS_PER_DAY` to\n  `hoursPerDay`, `MICROSECONDS_PER_SECOND` to `microsecondsPerSecond`,\n  `MICROSECONDS_PER_MINUTE` to `microsecondsPerMinute`, `MICROSECONDS_PER_HOUR`\n  to `microsecondsPerHour`, `MICROSECONDS_PER_DAY` to `microsecondsPerDay`,\n  `MILLISECONDS_PER_MINUTE` to `millisecondsPerMinute`, `MILLISECONDS_PER_HOUR`\n  to `millisecondsPerHour`, `MILLISECONDS_PER_DAY` to `millisecondsPerDay`,\n  `SECONDS_PER_HOUR` to `secondsPerHour`, `SECONDS_PER_DAY` to `secondsPerDay`,\n  `MINUTES_PER_DAY` to `minutesPerDay`, and `ZERO` to `zero`.\n- Added `typeArguments` to `Invocation` class.\n- Added constructors to invocation class that allows creation of `Invocation`\n  objects directly, without going through `noSuchMethod`.\n- Added `unaryMinus` and `empty` constant symbols on the `Symbol` class.\n- Changed return type of `UriData.dataAsBytes` to `Uint8List`.\n- Added `tryParse` static method to `int`, `double`, `num`, `BigInt`, `Uri` and\n  `DateTime`.\n- Deprecated `onError` parameter on `int.parse`, `double.parse` and `num.parse`.\n- Deprecated the `NoSuchMethodError` constructor.\n- `int.parse` on the VM no longer accepts unsigned hexadecimal numbers greater\n  than or equal to `2**63` when not prefixed by `0x`. (SDK issue\n  [32858](https://github.com/dart-lang/sdk/issues/32858))\n\n#### `dart:developer`\n\n- `Flow` class added.\n- `Timeline.startSync` and `Timeline.timeSync` now accepts an optional parameter\n  `flow` of type `Flow`. The `flow` parameter is used to generate flow timeline\n  events that are enclosed by the slice described by\n  `Timeline.{start,finish}Sync` and `Timeline.timeSync`.\n\n<!--\nStill need entries for all changes to dart:html since 1.x\n-->\n\n#### `dart:html`\n\n- Removed deprecated `query` and `queryAll`. Use `querySelector` and\n  `querySelectorAll`.\n\n#### `dart:io`\n\n- `HttpStatus` added `UPGRADE_REQUIRED`.\n- `IOOverrides` and `HttpOverrides` added to aid in writing tests that wish to\n  mock varios `dart:io` objects.\n- `Platform.operatingSystemVersion` added that gives a platform-specific String\n  describing the version of the operating system.\n- `ProcessStartMode.INHERIT_STDIO` added, which allows a child process to\n  inherit the parent's stdio handles.\n- `RawZLibFilter` added for low-level access to compression and decompression\n  routines.\n- Unified backends for `SecureSocket`, `SecurityContext`, and `X509Certificate`\n  to be consistent across all platforms. All `SecureSocket`, `SecurityContext`,\n  and `X509Certificate` properties and methods are now supported on iOS and OSX.\n- `SecurityContext.alpnSupported` deprecated as ALPN is now supported on all\n  platforms.\n- `SecurityContext`: added `withTrustedRoots` named optional parameter\n  constructor, which defaults to false.\n- Added a `timeout` parameter to `Socket.connect`, `RawSocket.connect`,\n  `SecureSocket.connect` and `RawSecureSocket.connect`. If a connection attempt\n  takes longer than the duration specified in `timeout`, a `SocketException`\n  will be thrown. Note: if the duration specified in `timeout` is greater than\n  the OS level timeout, a timeout may occur sooner than specified in `timeout`.\n- `Stdin.hasTerminal` added, which is true if stdin is attached to a terminal.\n- `WebSocket` added static `userAgent` property.\n- `RandomAccessFile.close` returns `Future<void>`\n- Added `IOOverrides.socketConnect`.\n- Added Dart-styled constants to `ZLibOptions`, `FileMode`, `FileLock`,\n  `FileSystemEntityType`, `FileSystemEvent`, `ProcessStartMode`,\n  `ProcessSignal`, `InternetAddressType`, `InternetAddress`, `SocketDirection`,\n  `SocketOption`, `RawSocketEvent`, and `StdioType`, and deprecated the old\n  `SCREAMING_CAPS` constants.\n- Added the Dart-styled top-level constants `zlib`, `gzip`, and\n  `systemEncoding`, and deprecated the old `SCREAMING_CAPS` top-level constants.\n- Removed the top-level `FileMode` constants `READ`, `WRITE`, `APPEND`,\n  `WRITE_ONLY`, and `WRITE_ONLY_APPEND`. Please use e.g. `FileMode.read`\n  instead.\n- Added `X509Certificate.der`, `X509Certificate.pem`, and\n  `X509Certificate.sha1`.\n- Added `FileSystemEntity.fromRawPath` constructor to allow for the creation of\n  `FileSystemEntity` using `Uint8List` buffers.\n- Dart-styled constants have been added for `HttpStatus`, `HttpHeaders`,\n  `ContentType`, `HttpClient`, `WebSocketStatus`, `CompressionOptions`, and\n  `WebSocket`. The `SCREAMING_CAPS` constants are marked deprecated. Note that\n  `HttpStatus.CONTINUE` is now `HttpStatus.continue_`, and that e.g.\n  `HttpHeaders.FIELD_NAME` is now `HttpHeaders.fieldNameHeader`.\n- Deprecated `Platform.packageRoot`, which is only used for `packages/`\n  directory resolution which is no longer supported. It will now always return\n  null, which is a value that was always possible for it to return previously.\n- Adds `HttpClient.connectionTimeout`.\n- Adds `{Socket,RawSocket,SecureSocket}.startConnect`. These return a\n  `ConnectionTask`, which can be used to cancel an in-flight connection attempt.\n\n#### `dart:isolate`\n\n- Make `Isolate.spawn` take a type parameter representing the argument type of\n  the provided function. This allows functions with arguments types other than\n  `Object` in strong mode.\n- Rename `IMMEDIATE` and `BEFORE_NEXT_EVENT` on `Isolate` to `immediate` and\n  `beforeNextEvent`.\n- Deprecated `Isolate.packageRoot`, which is only used for `packages/` directory\n  resolution which is no longer supported. It will now always return null, which\n  is a value that was always possible for it to return previously.\n- Deprecated `packageRoot` parameter in `Isolate.spawnUri`, which is was\n  previously used only for `packages/` directory resolution. That style of\n  resolution is no longer supported in Dart 2.\n\n<!--\nStill need entries for all changes to dart:js since 1.x\n-->\n\n#### `dart.math`\n\n- Renamed `E`, `LN10`, `LN`, `LOG2E`, `LOG10E`, `PI`, `SQRT1_2` and `SQRT2` to\n  `e`, `ln10`, `ln`, `log2e`, `log10e`, `pi`, `sqrt1_2` and `sqrt2`.\n\n#### `dart.mirrors`\n\n- Added `IsolateMirror.loadUri`, which allows dynamically loading additional\n  code.\n- Marked `MirrorsUsed` as deprecated. The `MirrorsUsed` annotation was only used\n  to inform the dart2js compiler about how mirrors were used, but dart2js no\n  longer supports the mirrors library altogether.\n\n<!--\nStill need entries for all changes to dart:svg since 1.x\n-->\n\n#### `dart:typed_data`\n\n- Added `Unmodifiable` view classes over all `List` types.\n- Renamed `BYTES_PER_ELEMENT` to `bytesPerElement` on all typed data lists.\n- Renamed constants `XXXX` through `WWWW` on `Float32x4` and `Int32x4` to\n  lower-case `xxxx` through `wwww`.\n- Renamed `Endinanness` to `Endian` and its constants from `BIG_ENDIAN`,\n  `LITTLE_ENDIAN` and `HOST_ENDIAN` to `little`, `big` and `host`.\n\n<!--\nStill need entries for all changes to dart:web_audio,web_gl,web_sql since 1.x\n-->\n\n### Dart VM\n\n- Support for MIPS has been removed.\n\n- Dart `int` is now restricted to 64 bits. On overflow, arithmetic operations\n  wrap around, and integer literals larger than 64 bits are not allowed. See\n  https://github.com/dart-lang/sdk/blob/main/docs/language/informal/int64.md\n  for details.\n\n- The Dart VM no longer attempts to perform `packages/` directory resolution\n  (for loading scripts, and in `Isolate.resolveUri`). Users relying on\n  `packages/` directories should switch to `.packages` files.\n\n### Dart for the Web\n\n- Expose JavaScript Promise APIs using Dart futures. For example,\n  `BackgroundFetchManager.get` is defined as:\n\n  ```dart\n    Future<BackgroundFetchRegistration> get(String id)\n  ```\n\n  It can be used like:\n\n  ```dart\n  BackgroundFetchRegistration result = await fetchMgr.get('abc');\n  ```\n\n  The underlying JS Promise-to-Future mechanism will be exposed as a public API\n  in the future.\n\n#### Dart Dev Compiler (DDC)\n\n- dartdevc will no longer throw an error from `is` checks that return a\n  different result in weak mode (SDK [issue 28988][sdk#28988]). For example:\n\n  ```dart\n  main() {\n    List l = [];\n    // Prints \"false\", does not throw.\n    print(l is List<String>);\n  }\n  ```\n\n- Failed `as` casts on `Iterable<T>`, `Map<T>`, `Future<T>`, and `Stream<T>` are\n  no longer ignored. These failures were ignored to make it easier to migrate\n  Dart 1 code to strong mode, but ignoring them is a hole in the type system.\n  This closes part of that hole. (We still need to stop ignoring \"as\" cast\n  failures on function types, and implicit cast failures on the above types and\n  function types.)\n\n[sdk#28988]: https://github.com/dart-lang/sdk/issues/28988\n\n#### dart2js\n\n- dart2js now compiles programs with Dart 2.0 semantics. Apps are expected to be\n  bigger than before, because Dart 2.0 has many more implicit checks (similar to\n  the `--checked` flag in Dart 1.0).\n\n  We exposed a `--omit-implicit-checks` flag which removes most of the extra\n  implicit checks. Only use this if you have enough test coverage to know that\n  the app will work well without the checks. If a check would have failed and it\n  is omitted, your app may crash or behave in unexpected ways. This flag is\n  similar to `--trust-type-annotations` in Dart 1.0.\n\n- dart2js replaced its front-end with the common front-end (CFE). Thanks to the\n  CFE, dart2js errors are more consistent with all other Dart tools.\n\n- dart2js replaced its source-map implementation. There aren't any big\n  differences, but more data is emitted for synthetic code generated by the\n  compiler.\n\n- `dart:mirrors` support was removed. Frameworks are encouraged to use\n  code-generation instead. Conditional imports indicate that mirrors are not\n  supported, and any API in the mirrors library will throw at runtime.\n\n- The generated output of dart2js can now be run as a webworker.\n\n- `dart:isolate` support was removed. To launch background tasks, please use\n  webworkers instead. APIs for webworkers can be accessed from `dart:html` or\n  JS-interop.\n\n- dart2js no longer supports the `--package-root` flag. This flag was deprecated\n  in favor of `--packages` long ago.\n\n### Tool Changes\n\n#### Analyzer\n\n- The analyzer will no longer issue a warning when a generic type parameter is\n  used as the type in an instance check. For example:\n\n  ```dart\n  test<T>() {\n    print(3 is T); // No warning\n  }\n  ```\n\n- New static checking of `@visibleForTesting` elements. Accessing a method,\n  function, class, etc. annotated with `@visibleForTesting` from a file _not_ in\n  a `test/` directory will result in a new hint ([issue 28273][]).\n\n- Static analysis now respects functions annotated with `@alwaysThrows` ([issue\n  31384][]).\n\n- New hints added:\n\n  - `NULL_AWARE_BEFORE_OPERATOR` when an operator is used after a null-aware\n    access. For example:\n\n    ```dart\n    x?.a - ''; // HINT\n    ```\n\n  - `NULL_AWARE_IN_LOGICAL_OPERATOR` when an expression with null-aware access\n    is used as a condition in logical operators. For example:\n\n    ```dart\n    x.a || x?.b; // HINT\n    ```\n\n- The command line analyzer (dartanalyzer) and the analysis server no longer\n  treat directories named `packages` specially. Previously they had ignored\n  these directories - and their contents - from the point of view of analysis.\n  Now they'll be treated just as regular directories. This special-casing of\n  `packages` directories was to support using symlinks for package: resolution;\n  that functionality is now handled by `.packages` files.\n\n- New static checking of duplicate shown or hidden names in an export directive\n  ([issue 33182][]).\n\n- The analysis server will now only analyze code in Dart 2 mode ('strong mode').\n  It will emit warnings for analysis options files that have\n  `strong-mode: false` set (and will emit a hint for `strong-mode: true`, which\n  is no longer necessary).\n\n- The dartanalyzer `--strong` flag is now deprecated and ignored. The\n  command-line analyzer now only analyzes code in strong mode.\n\n[issue 28273]: https://github.com/dart-lang/sdk/issues/28273\n[issue 31384]: https://github.com/dart-lang/sdk/issues/31384\n[issue 33182]: https://github.com/dart-lang/sdk/issues/33182\n\n#### dartfmt\n\n- Support `assert()` in const constructor initializer lists.\n\n- Better formatting for multi-line strings in argument lists.\n\n- Force splitting an empty block as the then body of an if with an else.\n\n- Support metadata annotations on enum cases.\n\n- Add `--fix` to remove unneeded `new` and `const` keywords, and change `:` to\n  `=` before named parameter default values.\n\n- Change formatting rules around static methods to uniformly format code with\n  and without `new` and `const`.\n\n- Format expressions inside string interpolation.\n\n#### Pub\n\n- Pub has a brand new version solver! It supports all the same features as the\n  old version solver, but it's much less likely to stall out on difficult\n  package graphs, and it's much clearer about why a solution can't be found when\n  version solving fails.\n\n- Remove support for transformers, `pub build`, and `pub serve`. Use the [new\n  build system][transformers] instead.\n\n- There is now a default SDK constraint of `<2.0.0` for any package with no\n  existing upper bound. This allows us to move more safely to 2.0.0. All new\n  packages published on pub will now require an upper bound SDK constraint so\n  future major releases of Dart don't destabilize the package ecosystem.\n\n  All SDK constraint exclusive upper bounds are now treated as though they allow\n  pre-release versions of that upper bound. For example, the SDK constraint\n  `>=1.8.0 <2.0.0` now allows pre-release SDK versions such as `2.0.0-beta.3.0`.\n  This allows early adopters to try out packages that don't explicitly declare\n  support for the new version yet. You can disable this functionality by setting\n  the `PUB_ALLOW_PRERELEASE_SDK` environment variable to `false`.\n\n- Allow depending on a package in a subdirectory of a Git repository. Git\n  dependencies may now include a `path` parameter, indicating that the package\n  exists in a subdirectory of the Git repository. For example:\n\n  ```yaml\n  dependencies:\n    foobar:\n      git:\n        url: git://github.com/dart-lang/multi_package_repo\n        path: pkg/foobar\n  ```\n\n- Added an `--executables` option to `pub deps` command. This will list all\n  available executables that can be run with `pub run`.\n\n- The Flutter `sdk` source will now look for packages in\n  `flutter/bin/cache/pkg/` as well as `flutter/packages/`. In particular, this\n  means that packages can depend on the `sky_engine` package from the `sdk`\n  source ([issue 1775][pub#1775]).\n\n- Pub now caches compiled packages and snapshots in the `.dart_tool/pub`\n  directory, rather than the `.pub` directory ([issue 1795][pub#1795]).\n\n- Other bug fixes and improvements.\n\n[issue 30246]: https://github.com/dart-lang/sdk/issues/30246\n[pub#1679]: https://github.com/dart-lang/pub/issues/1679\n[pub#1684]: https://github.com/dart-lang/pub/issues/1684\n[pub#1775]: https://github.com/dart-lang/pub/issues/1775\n[pub#1795]: https://github.com/dart-lang/pub/issues/1795\n[pub#1823]: https://github.com/dart-lang/pub/issues/1823\n\n## 1.24.3 - 2017-12-14\n\n- Fix for constructing a new SecurityContext that contains the built-in\n  certificate authority roots\n  ([issue 24693](https://github.com/dart-lang/sdk/issues/24693)).\n\n### Core library changes\n\n- `dart:io`\n  - Unified backends for `SecureSocket`, `SecurityContext`, and\n    `X509Certificate` to be consistent across all platforms. All `SecureSocket`,\n    `SecurityContext`, and `X509Certificate` properties and methods are now\n    supported on iOS and OSX.\n\n## 1.24.2 - 2017-06-22\n\n- Fixes for debugging in Dartium.\n  - Fix DevConsole crash with JS\n    ([issue 29873](https://github.com/dart-lang/sdk/issues/29873)).\n  - Fix debugging in WebStorm, NULL returned for JS objects\n    ([issue 29854](https://github.com/dart-lang/sdk/issues/29854)).\n\n## 1.24.1 - 2017-06-14\n\n- Bug fixes for dartdevc support in `pub serve`.\n  - Fixed module config invalidation logic so modules are properly recalculated\n    when package layout changes.\n  - Fixed exception when handling require.js errors that aren't script load\n    errors.\n  - Fixed an issue where requesting the bootstrap.js file before the dart.js\n    file would result in a 404.\n  - Fixed a Safari issue during bootstrapping (note that Safari is still not\n    officially supported but does work for trivial examples).\n- Fix for a Dartium issue where there was no sound in checked mode\n  ([issue 29810](https://github.com/dart-lang/sdk/issues/29810)).\n\n## 1.24.0 - 2017-06-12\n\n### Language\n\n- During a dynamic type check, `void` is not required to be `null` anymore. In\n  practice, this makes overriding `void` functions with non-`void` functions\n  safer.\n\n- During static analysis, a function or setter declared using `=>` with return\n  type `void` now allows the returned expression to have any type. For example,\n  assuming the declaration `int x;`, it is now type correct to have\n  `void f() => ++x;`.\n\n- A new function-type syntax has been added to the language. **Warning**: _In\n  Dart 1.24, this feature is incomplete, and not stable in the Analyzer._\n\n  Intuitively, the type of a function can be constructed by textually replacing\n  the function's name with `Function` in its declaration. For instance, the type\n  of `void foo() {}` would be `void Function()`. The new syntax may be used\n  wherever a type can be written. It is thus now possible to declare fields\n  containing functions without needing to write typedefs: `void Function() x;`.\n  The new function type has one restriction: it may not contain the old-style\n  function-type syntax for its parameters. The following is thus illegal:\n  `void Function(int f())`. `typedefs` have been updated to support this new\n  syntax.\n\n  Examples:\n\n  ```dart\n  typedef F = void Function();  // F is the name for a `void` callback.\n  int Function(int) f;  // A field `f` that contains an int->int function.\n\n  class A<T> {\n    // The parameter `callback` is a function that takes a `T` and returns\n    // `void`.\n    void forEach(void Function(T) callback);\n  }\n\n  // The new function type supports generic arguments.\n  typedef Invoker = T Function<T>(T Function() callback);\n  ```\n\n### Core library changes\n\n- `dart:async`, `dart:core`, `dart:io`\n\n  - Adding to a closed sink, including `IOSink`, is no longer not allowed. In\n    1.24, violations are only reported (on stdout or stderr), but a future\n    version of the Dart SDK will change this to throwing a `StateError`.\n\n- `dart:convert`\n\n  - **BREAKING** Removed the deprecated `ChunkedConverter` class.\n  - JSON maps are now typed as `Map<String, dynamic>` instead of\n    `Map<dynamic, dynamic>`. A JSON-map is not a `HashMap` or `LinkedHashMap`\n    anymore (but just a `Map`).\n\n- `dart:io`\n\n  - Added `Platform.localeName`, needed for accessing the locale on platforms\n    that don't store it in an environment variable.\n  - Added `ProcessInfo.currentRss` and `ProcessInfo.maxRss` for inspecting the\n    Dart VM process current and peak resident set size.\n  - Added `RawSynchronousSocket`, a basic synchronous socket implementation.\n\n- `dart:` web APIs have been updated to align with Chrome v50. This change\n  includes **a large number of changes**, many of which are breaking. In some\n  cases, new class names may conflict with names that exist in existing code.\n\n- `dart:html`\n\n  - **REMOVED** classes: `Bluetooth`, `BluetoothDevice`,\n    `BluetoothGattCharacteristic`, `BluetoothGattRemoteServer`,\n    `BluetoothGattService`, `BluetoothUuid`, `CrossOriginConnectEvent`,\n    `DefaultSessionStartEvent`, `DomSettableTokenList`, `MediaKeyError`,\n    `PeriodicSyncEvent`, `PluginPlaceholderElement`, `ReadableStream`,\n    `StashedMessagePort`, `SyncRegistration`\n\n  - **REMOVED** members:\n\n    - `texImage2DCanvas` was removed from `RenderingContext`.\n    - `endClip` and `startClip` were removed from `Animation`.\n    - `after` and `before` were removed from `CharacterData`, `ChildNode` and\n      `Element`.\n    - `keyLocation` was removed from `KeyboardEvent`. Use `location` instead.\n    - `generateKeyRequest`, `keyAddedEvent`, `keyErrorEvent`, `keyMessageEvent`,\n      `mediaGroup`, `needKeyEvent`, `onKeyAdded`, `onKeyError`, `onKeyMessage`,\n      and `onNeedKey` were removed from `MediaElement`.\n    - `getStorageUpdates` was removed from `Navigator`\n    - `status` was removed from `PermissionStatus`\n    - `getAvailability` was removed from `PreElement`\n\n  - Other behavior changes:\n    - URLs returned in CSS or html are formatted with quoted string. Like\n      `url(\"http://google.com\")` instead of `url(http://google.com)`.\n    - Event timestamp property type changed from `int` to `num`.\n    - Chrome introduced slight layout changes of UI objects. In addition many\n      height/width dimensions are returned in subpixel values (`num` instead of\n      whole numbers).\n    - `setRangeText` with a `selectionMode` value of 'invalid' is no longer\n      valid. Only \"select\", \"start\", \"end\", \"preserve\" are allowed.\n\n- `dart:svg`\n\n  - A large number of additions and removals. Review your use of `dart:svg`\n    carefully.\n\n- `dart:web_audio`\n\n  - new method on `AudioContext` - `createIirFilter` returns a new class\n    `IirFilterNode`.\n\n- `dart:web_gl`\n\n  - new classes: `CompressedTextureAstc`, `ExtColorBufferFloat`,\n    `ExtDisjointTimerQuery`, and `TimerQueryExt`.\n\n  - `ExtFragDepth` added: `readPixels2` and `texImage2D2`.\n\n#### Strong Mode\n\n- Removed ad hoc `Future.then` inference in favor of using `FutureOr`. Prior to\n  adding `FutureOr` to the language, the analyzer implemented an ad hoc type\n  inference for `Future.then` (and overrides) treating it as if the onValue\n  callback was typed to return `FutureOr` for the purposes of inference. This ad\n  hoc inference has been removed now that `FutureOr` has been added.\n\n  Packages that implement `Future` must either type the `onValue` parameter to\n  `.then` as returning `FutureOr<T>`, or else must leave the type of the\n  parameter entirely to allow inference to fill in the type.\n\n- During static analysis, a function or setter declared using `=>` with return\n  type `void` now allows the returned expression to have any type.\n\n### Tool Changes\n\n- Dartium\n\n  Dartium is now based on Chrome v50. See _Core library changes_ above for\n  details on the changed APIs.\n\n- Pub\n\n  - `pub build` and `pub serve`\n\n    - Added support for the Dart Development Compiler.\n\n      Unlike dart2js, this new compiler is modular, which allows pub to do\n      incremental re-builds for `pub serve`, and potentially `pub build` in the\n      future.\n\n      In practice what that means is you can edit your Dart files, refresh in\n      Chrome (or other supported browsers), and see your edits almost\n      immediately. This is because pub is only recompiling your package, not all\n      packages that you depend on.\n\n      There is one caveat with the new compiler, which is that your package and\n      your dependencies must all be strong mode clean. If you are getting an\n      error compiling one of your dependencies, you will need to file bugs or\n      send pull requests to get them strong mode clean.\n\n      There are two ways of opting into the new compiler:\n\n      - Use the new `--web-compiler` flag, which supports `dartdevc`, `dart2js`\n        or `none` as options. This is the easiest way to try things out without\n        changing the default.\n\n      - Add config to your pubspec. There is a new `web` key which supports a\n        single key called `compiler`. This is a map from mode names to compiler\n        to use. For example, to default to dartdevc in debug mode you can add\n        the following to your pubspec:\n\n        ```yaml\n        web:\n          compiler:\n            debug: dartdevc\n        ```\n\n      You can also use the new compiler to run your tests in Chrome much more\n      quickly than you can with dart2js. In order to do that, run\n      `pub serve test --web-compiler=dartdevc`, and then run\n      `pub run test -p chrome --pub-serve=8080`.\n\n    - The `--no-dart2js` flag has been deprecated in favor of\n      `--web-compiler=none`.\n\n    - `pub build` will use a failing exit code if there are errors in any\n      transformer.\n\n  - `pub publish`\n\n    - Added support for the UNLICENSE file.\n\n    - Packages that depend on the Flutter SDK may be published.\n\n  - `pub get` and `pub upgrade`\n\n    - Don't dump a stack trace when a network error occurs while fetching\n      packages.\n\n- dartfmt\n  - Preserve type parameters in new generic function typedef syntax.\n  - Add self-test validation to ensure formatter bugs do not cause user code to\n    be lost.\n\n### Infrastructure changes\n\n- As of this release, we'll show a warning when using the MIPS architecture.\n  Unless we learn about any critical use of Dart on MIPS in the meantime, we're\n  planning to deprecate support for MIPS starting with the next stable release.\n\n## 1.23.0 - 2017-04-21\n\n#### Strong Mode\n\n- Breaking change - it is now a strong mode error if a mixin causes a name\n  conflict between two private members (field/getter/setter/method) from a\n  different library. (SDK issue\n  [28809](https://github.com/dart-lang/sdk/issues/28809)).\n\nlib1.dart:\n\n```dart\nclass A {\n  int _x;\n}\n\nclass B {\n  int _x;\n}\n```\n\nlib2.dart:\n\n```dart\nimport 'lib1.dart';\n\nclass C extends A with B {}\n```\n\n```\n    error \u2022 The private name _x, defined by B, conflicts with the same name defined by A at tmp/lib2.dart:3:24 \u2022 private_collision_in_mixin_application\n```\n\n- Breaking change - strong mode will prefer the expected type to infer generic\n  types, functions, and methods (SDK issue\n  [27586](https://github.com/dart-lang/sdk/issues/27586)).\n\n  ```dart\n  main() {\n    List<Object> foo = /*infers: <Object>*/['hello', 'world'];\n    var bar = /*infers: <String>*/['hello', 'world'];\n  }\n  ```\n\n- Strong mode inference error messages are improved (SDK issue\n  [29108](https://github.com/dart-lang/sdk/issues/29108)).\n\n  ```dart\n  import 'dart:math';\n  test(Iterable/* fix is to add <num> here */ values) {\n    num n = values.fold(values.first as num, max);\n  }\n  ```\n\n  Now produces the error on the generic function \"max\":\n\n  ```\n  Couldn't infer type parameter 'T'.\n\n  Tried to infer 'dynamic' for 'T' which doesn't work:\n    Function type declared as '<T extends num>(T, T) \u2192 T'\n                  used where  '(num, dynamic) \u2192 num' is required.\n\n  Consider passing explicit type argument(s) to the generic.\n  ```\n\n- Strong mode supports overriding fields, `@virtual` is no longer required (SDK\n  issue [28120](https://github.com/dart-lang/sdk/issues/28120)).\n\n  ```dart\n  class C {\n    int x = 42;\n  }\n  class D extends C {\n    get x {\n      print(\"x got called\");\n      return super.x;\n    }\n  }\n  main() {\n    print(new D().x);\n  }\n  ```\n\n- Strong mode down cast composite warnings are no longer issued by default. (SDK\n  issue [28588](https://github.com/dart-lang/sdk/issues/28588)).\n\n```dart\nvoid test() {\n  List untyped = [];\n  List<int> typed = untyped; // No down cast composite warning\n}\n```\n\nTo opt back into the warnings, add the following to the\n[.analysis_options](https://www.dartlang.org/guides/language/analysis-options)\nfile for your project.\n\n```\nanalyzer:\n  errors:\n    strong_mode_down_cast_composite: warning\n```\n\n### Core library changes\n\n- `dart:core`\n  - Added `Uri.isScheme` function to check the scheme of a URI. Example:\n    `uri.isScheme(\"http\")`. Ignores case when comparing.\n  - Make `UriData.parse` validate its input better. If the data is base-64\n    encoded, the data is normalized wrt. alphabet and padding, and it contains\n    invalid base-64 data, parsing fails. Also normalizes non-base-64 data.\n- `dart:io`\n  - Added functions `File.lastAccessed`, `File.lastAccessedSync`,\n    `File.setLastModified`, `File.setLastModifiedSync`, `File.setLastAccessed`,\n    and `File.setLastAccessedSync`.\n  - Added `{Stdin,Stdout}.supportsAnsiEscapes`.\n\n### Dart VM\n\n- Calls to `print()` and `Stdout.write*()` now correctly print unicode\n  characters to the console on Windows. Calls to `Stdout.add*()` behave as\n  before.\n\n### Tool changes\n\n- Analysis\n\n  - `dartanalyzer` now follows the same rules as the analysis server to find an\n    analysis options file, stopping when an analysis options file is found:\n    - Search up the directory hierarchy looking for an analysis options file.\n    - If analyzing a project referencing the [Flutter](https://flutter.io/)\n      package, then use the\n      [default Flutter analysis options](https://github.com/flutter/flutter/blob/master/packages/flutter/lib/analysis_options_user.yaml)\n      found in `package:flutter`.\n    - If in a Bazel workspace, then use the analysis options in\n      `package:dart.analysis_options/default.yaml` if it exists.\n    - Use the default analysis options rules.\n  - In addition, specific to `dartanalyzer`:\n    - an analysis options file can be specified on the command line via\n      `--options` and that file will be used instead of searching for an\n      analysis options file.\n    - any analysis option specified on the command line (e.g. `--strong` or\n      `--no-strong`) takes precedence over any corresponding value specified in\n      the analysis options file.\n\n- Dartium, dart2js, and DDC\n\n  - Imports to `dart:io` are allowed, but the imported library is not supported\n    and will likely fail on most APIs at runtime. This change was made as a\n    stopgap measure to make it easier to write libraries that share code between\n    platforms (like package `http`). This might change again when configuration\n    specific imports are supported.\n\n- Pub\n\n  - Now sends telemetry data to `pub.dartlang.org` to allow better understanding\n    of why a particular package is being accessed.\n  - `pub publish`\n    - Warns if a package imports a package that's not a dependency from within\n      `lib/` or `bin/`, or a package that's not a dev dependency from within\n      `benchmark/`, `example/`, `test/` or `tool/`.\n    - No longer produces \"UID too large\" errors on OS X. All packages are now\n      uploaded with the user and group names set to \"pub\".\n    - No longer fails with a stack overflow when uploading a package that uses\n      Git submodules.\n  - `pub get` and `pub upgrade`\n    - Produce more informative error messages if they're run directly in a\n      package that uses Flutter.\n    - Properly unlock SDK and path dependencies if they have a new version\n      that's also valid according to the user's pubspec.\n\n- dartfmt\n  - Support new generic function typedef syntax.\n  - Make the precedence of cascades more visible.\n  - Fix a couple of places where spurious newlines were inserted.\n  - Correctly report unchanged formatting when reading from stdin.\n  - Ensure space between `-` and `--`. Code that does this is pathological, but\n    it technically meant dartfmt could change the semantics of the code.\n  - Preserve a blank line between enum cases.\n  - Other small formatting tweaks.\n\n## 1.22.1 - 2017-02-22\n\nPatch release, resolves two issues:\n\n- Dart VM crash: [Issue 28072](https://github.com/dart-lang/sdk/issues/28757)\n\n- Dart VM bug combining types, await, and deferred loading:\n  [Issue 28678](https://github.com/dart-lang/sdk/issues/28678)\n\n## 1.22.0 - 2017-02-14\n\n### Language\n\n- Breaking change:\n  ['Generalized tear-offs'](https://github.com/gbracha/generalizedTearOffs/blob/master/proposal.md)\n  are no longer supported, and will cause errors. We updated the language spec\n  and added warnings in 1.21, and are now taking the last step to fully\n  de-support them. They were previously only supported in the VM, and there are\n  almost no known uses of them in the wild.\n\n- The `assert()` statement has been expanded to support an optional second\n  `message` argument (SDK issue\n  [27342](https://github.com/dart-lang/sdk/issues/27342)).\n\n  The message is displayed if the assert fails. It can be any object, and it is\n  accessible as `AssertionError.message`. It can be used to provide more user\n  friendly exception outputs. As an example, the following assert:\n\n  ```dart\n  assert(configFile != null, \"Tool config missing. Please see https://goo.gl/k8iAi for details.\");\n  ```\n\n  would produce the following exception output:\n\n  ```\n  Unhandled exception:\n  'file:///Users/mit/tmp/tool/bin/main.dart': Failed assertion: line 9 pos 10:\n  'configFile != null': Tool config missing. Please see https://goo.gl/k8iAi for details.\n  #0      _AssertionError._doThrowNew (dart:core-patch/errors_patch.dart:33)\n  #1      _AssertionError._throwNew (dart:core-patch/errors_patch.dart:29)\n  #2      main (file:///Users/mit/tmp/tool/bin/main.dart:9:10)\n  ```\n\n- The `Null` type has been moved to the bottom of the type hierarchy. As such,\n  it is considered a subtype of every other type. The `null` _literal_ was\n  always treated as a bottom type. Now the named class `Null` is too:\n\n  ```dart\n  const empty = <Null>[];\n\n  String concatenate(List<String> parts) => parts.join();\n  int sum(List<int> numbers) => numbers.fold(0, (sum, n) => sum + n);\n\n  concatenate(empty); // OK.\n  sum(empty); // OK.\n  ```\n\n- Introduce `covariant` modifier on parameters. It indicates that the parameter\n  (and the corresponding parameter in any method that overrides it) has looser\n  override rules. In strong mode, these require a runtime type check to maintain\n  soundness, but enable an architectural pattern that is useful in some code.\n\n  It lets you specialize a family of classes together, like so:\n\n  ```dart\n  abstract class Predator {\n    void chaseAndEat(covariant Prey p);\n  }\n\n  abstract class Prey {}\n\n  class Mouse extends Prey {}\n\n  class Seal extends Prey {}\n\n  class Cat extends Predator {\n    void chaseAndEat(Mouse m) => ...\n  }\n\n  class Orca extends Predator {\n    void chaseAndEat(Seal s) => ...\n  }\n  ```\n\n  This isn't statically safe, because you could do:\n\n  ```dart\n  Predator predator = new Cat(); // Upcast.\n  predator.chaseAndEat(new Seal()); // Cats can't eat seals!\n  ```\n\n  To preserve soundness in strong mode, in the body of a method that uses a\n  covariant override (here, `Cat.chaseAndEat()`), the compiler automatically\n  inserts a check that the parameter is of the expected type. So the compiler\n  gives you something like:\n\n  ```dart\n  class Cat extends Predator {\n    void chaseAndEat(o) {\n      var m = o as Mouse;\n      ...\n    }\n  }\n  ```\n\n  Spec mode allows this unsound behavior on all parameters, even though users\n  rarely rely on it. Strong mode disallowed it initially. Now, strong mode lets\n  you opt into this behavior in the places where you do want it by using this\n  modifier. Outside of strong mode, the modifier is ignored.\n\n- Change instantiate-to-bounds rules for generic type parameters when running in\n  strong mode. If you leave off the type parameters from a generic type, we need\n  to decide what to fill them in with. Dart 1.0 says just use `dynamic`, but\n  that isn't sound:\n\n  ```dart\n  class Abser<T extends num> {\n     void absThis(T n) { n.abs(); }\n  }\n\n  var a = new Abser(); // Abser<dynamic>.\n  a.absThis(\"not a num\");\n  ```\n\n  We want the body of `absThis()` to be able to safely assume `n` is at least a\n  `num` -- that's why there's a constraint on T, after all. Implicitly using\n  `dynamic` as the type parameter in this example breaks that.\n\n  Instead, strong mode uses the bound. In the above example, it fills it in with\n  `num`, and then the second line where a string is passed becomes a static\n  error.\n\n  However, there are some cases where it is hard to figure out what that default\n  bound should be:\n\n  ```dart\n  class RuhRoh<T extends Comparable<T>> {}\n  ```\n\n  Strong mode's initial behavior sometimes produced surprising, unintended\n  results. For 1.22, we take a simpler approach and then report an error if a\n  good default type argument can't be found.\n\n### Core libraries\n\n- Define `FutureOr<T>` for code that works with either a future or an immediate\n  value of some type. For example, say you do a lot of text manipulation, and\n  you want a handy function to chain a bunch of them:\n\n  ```dart\n  typedef String StringSwizzler(String input);\n\n  String swizzle(String input, List<StringSwizzler> swizzlers) {\n    var result = input;\n    for (var swizzler in swizzlers) {\n      result = swizzler(result);\n    }\n\n    return result;\n  }\n  ```\n\n  This works fine:\n\n  ```dart\n  main() {\n    var result = swizzle(\"input\", [\n      (s) => s.toUpperCase(),\n      (s) => () => s * 2)\n    ]);\n    print(result); // \"INPUTINPUT\".\n  }\n  ```\n\n  Later, you realize you'd also like to support swizzlers that are asynchronous\n  (maybe they look up synonyms for words online). You could make your API\n  strictly asynchronous, but then users of simple synchronous swizzlers have to\n  manually wrap the return value in a `Future.value()`. Ideally, your\n  `swizzle()` function would be \"polymorphic over asynchrony\". It would allow\n  both synchronous and asynchronous swizzlers. Because `await` accepts immediate\n  values, it is easy to implement this dynamically:\n\n  ```dart\n  Future<String> swizzle(String input, List<StringSwizzler> swizzlers) async {\n    var result = input;\n    for (var swizzler in swizzlers) {\n      result = await swizzler(result);\n    }\n\n    return result;\n  }\n\n  main() async {\n    var result = swizzle(\"input\", [\n      (s) => s.toUpperCase(),\n      (s) => new Future.delayed(new Duration(milliseconds: 40), () => s * 2)\n    ]);\n    print(await result);\n  }\n  ```\n\n  What should the declared return type on StringSwizzler be? In the past, you\n  had to use `dynamic` or `Object`, but that doesn't tell the user much. Now,\n  you can do:\n\n  ```dart\n  typedef FutureOr<String> StringSwizzler(String input);\n  ```\n\n  Like the name implies, `FutureOr<String>` is a union type. It can be a\n  `String` or a `Future<String>`, but not anything else. In this case, that's\n  not super useful beyond just stating a more precise type for readers of the\n  code. It does give you a little better error checking in code that uses the\n  result of that.\n\n  `FutureOr<T>` becomes really important in _generic_ methods like\n  `Future.then()`. In those cases, having the type system understand this\n  magical union type helps type inference figure out the type argument of\n  `then()` based on the closure you pass it.\n\n  Previously, strong mode had hard-coded rules for handling `Future.then()`\n  specifically. `FutureOr<T>` exposes that functionality so third-party APIs can\n  take advantage of it too.\n\n### Tool changes\n\n- Dart2Js\n\n  - Remove support for (long-time deprecated) mixin typedefs.\n\n- Pub\n\n  - Avoid using a barback asset server for executables unless they actually use\n    transformers. This makes precompilation substantially faster, produces\n    better error messages when precompilation fails, and allows\n    globally-activated executables to consistently use the\n    `Isolate.resolvePackageUri()` API.\n\n  - On Linux systems, always ignore packages' original file owners and\n    permissions when extracting those packages. This was already the default\n    under most circumstances.\n\n  - Properly close the standard input stream of child processes started using\n    `pub run`.\n\n  - Handle parse errors from the package cache more gracefully. A package whose\n    pubspec can't be parsed will now be ignored by `pub get --offline` and\n    deleted by `pub cache repair`.\n\n  - Make `pub run` run executables in spawned isolates. This lets them handle\n    signals and use standard IO reliably.\n\n  - Fix source-maps produced by dart2js when running in `pub serve`: URL\n    references to assets from packages match the location where `pub serve`\n    serves them (`packages/package_name/` instead of\n    `../packages/package_name/`).\n\n### Infrastructure changes\n\n- The SDK now uses GN rather than gyp to generate its build files, which will\n  now be exclusively ninja flavored. Documentation can be found on our\n  [wiki](https://github.com/dart-lang/sdk/wiki/Building-with-GN). Also see the\n  help message of `tools/gn.py`. This change is in response to the deprecation\n  of gyp. Build file generation with gyp will continue to be available in this\n  release by setting the environment variable `DART_USE_GYP` before running\n  `gclient sync` or `gclient runhooks`, but this will be removed in a future\n  release.\n\n## 1.21.1 - 2017-01-13\n\nPatch release, resolves one issue:\n\n- Dart VM: Snapshots of generic functions fail.\n  [Issue 28072](https://github.com/dart-lang/sdk/issues/28072)\n\n## 1.21.0 - 2016-12-07\n\n### Language\n\n- Support generic method syntax. Type arguments are not available at runtime.\n  For details, check the\n  [informal specification](https://gist.github.com/eernstg/4353d7b4f669745bed3a5423e04a453c).\n- Support access to initializing formals, e.g., the use of `x` to initialize `y`\n  in `class C { var x, y; C(this.x): y = x; }`. Please check the\n  [informal specification](https://gist.github.com/eernstg/cff159be9e34d5ea295d8c24b1a3e594)\n  for details.\n- Don't warn about switch case fallthrough if the case ends in a `rethrow`\n  statement. (SDK issue [27650](https://github.com/dart-lang/sdk/issues/27650))\n- Also don't warn if the entire switch case is wrapped in braces - as long as\n  the block ends with a `break`, `continue`, `rethrow`, `return` or `throw`.\n- Allow `=` as well as `:` as separator for named parameter default values.\n\n  ```dart\n  enableFlags({bool hidden: false}) { \u2026 }\n  ```\n\n  can now be replaced by\n\n  ```dart\n  enableFlags({bool hidden = false}) { \u2026 }\n  ```\n\n  (SDK issue [27559](https://github.com/dart-lang/sdk/issues/27559))\n\n### Core library changes\n\n- `dart:core`: `Set.difference` now takes a `Set<Object>` as argument. (SDK\n  issue [27573](https://github.com/dart-lang/sdk/issues/27573))\n\n- `dart:developer`\n\n  - Added `Service` class.\n    - Allows inspecting and controlling the VM service protocol HTTP server.\n    - Provides an API to access the ID of an `Isolate`.\n\n### Tool changes\n\n- Dart Dev Compiler\n\n  - Support calls to `loadLibrary()` on deferred libraries. Deferred libraries\n    are still loaded eagerly. (SDK issue\n    [27343](https://github.com/dart-lang/sdk/issues/27343))\n\n## 1.20.1 - 2016-10-13\n\nPatch release, resolves one issue:\n\n- Dartium: Fixes a bug that caused crashes. No issue filed.\n\n### Strong Mode\n\n- It is no longer a warning when casting from dynamic to a composite type (SDK\n  issue [27766](https://github.com/dart-lang/sdk/issues/27766)).\n\n  ```dart\n  main() {\n    dynamic obj = <int>[1, 2, 3];\n    // This is now allowed without a warning.\n    List<int> list = obj;\n  }\n  ```\n\n## 1.20.0 - 2016-10-11\n\n### Dart VM\n\n- We have improved the way that the VM locates the native code library for a\n  native extension (e.g. `dart-ext:` import). We have updated this\n  [article on native extensions](https://www.dartlang.org/articles/dart-vm/native-extensions)\n  to reflect the VM's improved behavior.\n\n- Linux builds of the VM will now use the `tcmalloc` library for memory\n  allocation. This has the advantages of better debugging and profiling support\n  and faster small allocations, with the cost of slightly larger initial memory\n  footprint, and slightly slower large allocations.\n\n- We have improved the way the VM searches for trusted root certificates for\n  secure socket connections on Linux. First, the VM will look for trusted root\n  certificates in standard locations on the file system\n  (`/etc/pki/tls/certs/ca-bundle.crt` followed by `/etc/ssl/certs`), and only if\n  these do not exist will it fall back on the builtin trusted root certificates.\n  This behavior can be overridden on Linux with the new flags\n  `--root-certs-file` and `--root-certs-cache`. The former is the path to a file\n  containing the trusted root certificates, and the latter is the path to a\n  directory containing root certificate files hashed using `c_rehash`.\n\n- The VM now throws a catchable `Error` when method compilation fails. This\n  allows easier debugging of syntax errors, especially when testing. (SDK issue\n  [23684](https://github.com/dart-lang/sdk/issues/23684))\n\n### Core library changes\n\n- `dart:core`: Remove deprecated `Resource` class. Use the class in\n  `package:resource` instead.\n- `dart:async`\n  - `Future.wait` now catches synchronous errors and returns them in the\n    returned Future. (SDK issue\n    [27249](https://github.com/dart-lang/sdk/issues/27249))\n  - More aggressively returns a `Future` on `Stream.cancel` operations.\n    Discourages to return `null` from `cancel`. (SDK issue\n    [26777](https://github.com/dart-lang/sdk/issues/26777))\n  - Fixes a few bugs where the cancel future wasn't passed through\n    transformations.\n- `dart:io`\n  - Added `WebSocket.addUtf8Text` to allow sending a pre-encoded text message\n    without a round-trip UTF-8 conversion. (SDK issue\n    [27129](https://github.com/dart-lang/sdk/issues/27129))\n\n### Strong Mode\n\n- Breaking change - it is an error if a generic type parameter cannot be\n  inferred (SDK issue [26992](https://github.com/dart-lang/sdk/issues/26992)).\n\n  ```dart\n  class Cup<T> {\n    Cup(T t);\n  }\n  main() {\n    // Error because:\n    // - if we choose Cup<num> it is not assignable to `cOfInt`,\n    // - if we choose Cup<int> then `n` is not assignable to int.\n    num n;\n    C<int> cOfInt = new C(n);\n  }\n  ```\n\n- New feature - use `@checked` to override a method and tighten a parameter type\n  (SDK issue [25578](https://github.com/dart-lang/sdk/issues/25578)).\n\n  ```dart\n  import 'package:meta/meta.dart' show checked;\n  class View {\n    addChild(View v) {}\n  }\n  class MyView extends View {\n    // this override is legal, it will check at runtime if we actually\n    // got a MyView.\n    addChild(@checked MyView v) {}\n  }\n  main() {\n    dynamic mv = new MyView();\n    mv.addChild(new View()); // runtime error\n  }\n  ```\n\n- New feature - use `@virtual` to allow field overrides in strong mode (SDK\n  issue [27384](https://github.com/dart-lang/sdk/issues/27384)).\n\n  ```dart\n  import 'package:meta/meta.dart' show virtual;\n  class Base {\n    @virtual int x;\n  }\n  class Derived extends Base {\n    int x;\n\n    // Expose the hidden storage slot:\n    int get superX => super.x;\n    set superX(int v) { super.x = v; }\n  }\n  ```\n\n- Breaking change - infer list and map literals from the context type as well as\n  their values, consistent with generic methods and instance creation (SDK issue\n  [27151](https://github.com/dart-lang/sdk/issues/27151)).\n\n  ```dart\n  import 'dart:async';\n  main() async {\n    var b = new Future<B>.value(new B());\n    var c = new Future<C>.value(new C());\n    var/*infer List<Future<A>>*/ list = [b, c];\n    var/*infer List<A>*/ result = await Future.wait(list);\n  }\n  class A {}\n  class B extends A {}\n  class C extends A {}\n  ```\n\n### Tool changes\n\n- `dartfmt` - upgraded to v0.2.10\n\n  - Don't crash on annotations before parameters with trailing commas.\n  - Always split enum declarations if they end in a trailing comma.\n  - Add `--set-exit-if-changed` to set the exit code on a change.\n\n- Pub\n  - Pub no longer generates a `packages/` directory by default. Instead, it\n    generates a `.packages` file, called a package spec. To generate a\n    `packages/` directory in addition to the package spec, use the\n    `--packages-dir` flag with `pub get`, `pub upgrade`, and `pub downgrade`.\n    See the\n    [Good-bye symlinks](http://news.dartlang.org/2016/10/good-bye-symlinks.html)\n    article for details.\n\n## 1.19.1 - 2016-09-08\n\nPatch release, resolves one issue:\n\n- Dartdoc: Fixes a bug that prevented generation of docs. (Dartdoc issue\n  [1233](https://github.com/dart-lang/dartdoc/issues/1233))\n\n## 1.19.0 - 2016-08-26\n\n### Language changes\n\n- The language now allows a trailing comma after the last argument of a call and\n  the last parameter of a function declaration. This can make long argument or\n  parameter lists easier to maintain, as commas can be left as-is when\n  reordering lines. For details, see SDK issue\n  [26644](https://github.com/dart-lang/sdk/issues/26644).\n\n### Tool Changes\n\n- `dartfmt` - upgraded to v0.2.9+1\n\n  - Support trailing commas in argument and parameter lists.\n  - Gracefully handle read-only files.\n  - About a dozen other bug fixes.\n\n- Pub\n\n  - Added a `--no-packages-dir` flag to `pub get`, `pub upgrade`, and\n    `pub downgrade`. When this flag is passed, pub will not generate a\n    `packages/` directory, and will remove that directory and any symlinks to it\n    if they exist. Note that this replaces the unsupported\n    `--no-package-symlinks` flag.\n\n  - Added the ability for packages to declare a constraint on the [Flutter][]\n    SDK:\n\n    ```yaml\n    environment:\n      flutter: ^0.1.2\n      sdk: >=1.19.0 <2.0.0\n    ```\n\n    A Flutter constraint will only be satisfiable when pub is running in the\n    context of the `flutter` executable, and when the Flutter SDK version\n    matches the constraint.\n\n  - Added `sdk` as a new package source that fetches packages from a hard-coded\n    SDK. Currently only the `flutter` SDK is supported:\n\n    ```yaml\n    dependencies:\n      flutter_driver:\n        sdk: flutter\n        version: ^0.0.1\n    ```\n\n    A Flutter `sdk` dependency will only be satisfiable when pub is running in\n    the context of the `flutter` executable, and when the Flutter SDK contains a\n    package with the given name whose version matches the constraint.\n\n  - `tar` files on Linux are now created with `0` as the user and group IDs.\n    This fixes a crash when publishing packages while using Active Directory.\n\n  - Fixed a bug where packages from a hosted HTTP URL were considered the same\n    as packages from an otherwise-identical HTTPS URL.\n\n  - Fixed timer formatting for timers that lasted longer than a minute.\n\n  - Eliminate some false negatives when determining whether global executables\n    are on the user's executable path.\n\n- `dart2js`\n  - `dart2dart` (aka `dart2js --output-type=dart`) has been removed (this was\n    deprecated in Dart 1.11).\n\n[flutter]: https://flutter.io/\n\n### Dart VM\n\n- The dependency on BoringSSL has been rolled forward. Going forward, builds of\n  the Dart VM including secure sockets will require a compiler with C++11\n  support. For details, see the\n  [Building wiki page](https://github.com/dart-lang/sdk/wiki/Building).\n\n### Strong Mode\n\n- New feature - an option to disable implicit casts (SDK issue\n  [26583](https://github.com/dart-lang/sdk/issues/26583)), see the\n  [documentation](https://github.com/dart-lang/dev_compiler/blob/master/doc/STATIC_SAFETY.md#disable-implicit-casts)\n  for usage instructions and examples.\n\n- New feature - an option to disable implicit dynamic (SDK issue\n  [25573](https://github.com/dart-lang/sdk/issues/25573)), see the\n  [documentation](https://github.com/dart-lang/dev_compiler/blob/master/doc/STATIC_SAFETY.md#disable-implicit-dynamic)\n  for usage instructions and examples.\n\n- Breaking change - infer generic type arguments from the constructor invocation\n  arguments (SDK issue [25220](https://github.com/dart-lang/sdk/issues/25220)).\n\n  ```dart\n  var map = new Map<String, String>();\n\n  // infer: Map<String, String>\n  var otherMap = new Map.from(map);\n  ```\n\n- Breaking change - infer local function return type (SDK issue\n  [26414](https://github.com/dart-lang/sdk/issues/26414)).\n\n  ```dart\n  void main() {\n    // infer: return type is int\n    f() { return 40; }\n    int y = f() + 2; // type checks\n    print(y);\n  }\n  ```\n\n- Breaking change - allow type promotion from a generic type parameter (SDK\n  issue [26414](https://github.com/dart-lang/sdk/issues/26965)).\n\n  ```dart\n  void fn/*<T>*/(/*=T*/ object) {\n    if (object is String) {\n      // Treat `object` as `String` inside this block.\n      // But it will require a cast to pass it to something that expects `T`.\n      print(object.substring(1));\n    }\n  }\n  ```\n\n- Breaking change - smarter inference for Future.then (SDK issue\n  [25944](https://github.com/dart-lang/sdk/issues/25944)). Previous workarounds\n  that use async/await or `.then/*<Future<SomeType>>*/` should no longer be\n  necessary.\n\n  ```dart\n  // This will now infer correctly.\n  Future<List<int>> t2 = f.then((_) => [3]);\n  // This infers too.\n  Future<int> t2 = f.then((_) => new Future.value(42));\n  ```\n\n- Breaking change - smarter inference for async functions (SDK issue\n  [25322](https://github.com/dart-lang/sdk/issues/25322)).\n\n  ```dart\n  void test() async {\n    List<int> x = await [4]; // was previously inferred\n    List<int> y = await new Future.value([4]); // now inferred too\n  }\n  ```\n\n- Breaking change - sideways casts are no longer allowed (SDK issue\n  [26120](https://github.com/dart-lang/sdk/issues/26120)).\n\n## 1.18.1 - 2016-08-02\n\nPatch release, resolves two issues and improves performance:\n\n- Debugger: Fixes a bug that crashes the VM (SDK issue\n  [26941](https://github.com/dart-lang/sdk/issues/26941))\n\n- VM: Fixes an optimizer bug involving closures, try, and await (SDK issue\n  [26948](https://github.com/dart-lang/sdk/issues/26948))\n\n- Dart2js: Speeds up generated code on Firefox\n  (https://codereview.chromium.org/2180533002)\n\n## 1.18.0 - 2016-07-27\n\n### Core library changes\n\n- `dart:core`\n  - Improved performance when parsing some common URIs.\n  - Fixed bug in `Uri.resolve` (SDK issue\n    [26804](https://github.com/dart-lang/sdk/issues/26804)).\n- `dart:io`\n  - Adds file locking modes `FileLock.BLOCKING_SHARED` and\n    `FileLock.BLOCKING_EXCLUSIVE`.\n\n## 1.17.1 - 2016-06-10\n\nPatch release, resolves two issues:\n\n- VM: Fixes a bug that caused crashes in async functions. (SDK issue\n  [26668](https://github.com/dart-lang/sdk/issues/26668))\n\n- VM: Fixes a bug that caused garbage collection of reachable weak properties.\n  (https://codereview.chromium.org/2041413005)\n\n## 1.17.0 - 2016-06-08\n\n### Core library changes\n\n- `dart:convert`\n\n  - Deprecate `ChunkedConverter` which was erroneously added in 1.16.\n\n- `dart:core`\n\n  - `Uri.replace` supports iterables as values for the query parameters.\n  - `Uri.parseIPv6Address` returns a `Uint8List`.\n\n- `dart:io`\n  - Added `NetworkInterface.listSupported`, which is `true` when\n    `NetworkInterface.list` is supported, and `false` otherwise. Currently,\n    `NetworkInterface.list` is not supported on Android.\n\n### Tool Changes\n\n- Pub\n\n  - TAR files created while publishing a package on Mac OS and Linux now use a\n    more portable format.\n\n  - Errors caused by invalid arguments now print the full usage information for\n    the command.\n\n  - SDK constraints for dependency overrides are no longer considered when\n    determining the total SDK constraint for a lockfile.\n\n  - A bug has been fixed in which a lockfile was considered up-to-date when it\n    actually wasn't.\n\n  - A bug has been fixed in which `pub get --offline` would crash when a\n    prerelease version was selected.\n\n- Dartium and content shell\n  - Debugging Dart code inside iframes improved, was broken.\n\n## 1.16.1 - 2016-05-24\n\nPatch release, resolves one issue:\n\n- VM: Fixes a bug that caused intermittent hangs on Windows. (SDK issue\n  [26400](https://github.com/dart-lang/sdk/issues/26400))\n\n## 1.16.0 - 2016-04-26\n\n### Core library changes\n\n- `dart:convert`\n\n  - Added `BASE64URL` codec and corresponding `Base64Codec.urlSafe` constructor.\n\n  - Introduce `ChunkedConverter` and deprecate chunked methods on `Converter`.\n\n- `dart:html`\n\n  There have been a number of **BREAKING** changes to align APIs with recent\n  changes in Chrome. These include:\n\n  - Chrome's `ShadowRoot` interface no longer has the methods `getElementById`,\n    `getElementsByClassName`, and `getElementsByTagName`, e.g.,\n\n    ```dart\n    elem.shadowRoot.getElementsByClassName('clazz')\n    ```\n\n    should become:\n\n    ```dart\n    elem.shadowRoot.querySelectorAll('.clazz')\n    ```\n\n  - The `clipboardData` property has been removed from `KeyEvent` and `Event`.\n    It has been moved to the new `ClipboardEvent` class, which is now used by\n    `copy`, `cut`, and `paste` events.\n\n  - The `layer` property has been removed from `KeyEvent` and `UIEvent`. It has\n    been moved to `MouseEvent`.\n\n  - The `Point get page` property has been removed from `UIEvent`. It still\n    exists on `MouseEvent` and `Touch`.\n\n  There have also been a number of other additions and removals to `dart:html`,\n  `dart:indexed_db`, `dart:svg`, `dart:web_audio`, and `dart:web_gl` that\n  correspond to changes to Chrome APIs between v39 and v45. Many of the breaking\n  changes represent APIs that would have caused runtime exceptions when compiled\n  to Javascript and run on recent Chrome releases.\n\n- `dart:io`\n  - Added `SecurityContext.alpnSupported`, which is true if a platform supports\n    ALPN, and false otherwise.\n\n### JavaScript interop\n\nFor performance reasons, a potentially **BREAKING** change was added for\nlibraries that use JS interop. Any Dart file that uses `@JS` annotations on\ndeclarations (top-level functions, classes or class members) to interop with\nJavaScript code will require that the file have the annotation `@JS()` on a\nlibrary directive.\n\n```dart\n@JS()\nlibrary my_library;\n```\n\nThe analyzer will enforce this by generating the error:\n\nThe `@JS()` annotation can only be used if it is also declared on the library\ndirective.\n\nIf part file uses the `@JS()` annotation, the library that uses the part should\nhave the `@JS()` annotation e.g.,\n\n```dart\n// library_1.dart\n@JS()\nlibrary library_1;\n\nimport 'package:js/js.dart';\n\npart 'part_1.dart';\n```\n\n```dart\n// part_1.dart\npart of library_1;\n\n@JS(\"frameworkStabilizers\")\nexternal List<FrameworkStabilizer> get frameworkStabilizers;\n```\n\nIf your library already has a JS module e.g.,\n\n```dart\n@JS('array.utils')\nlibrary my_library;\n```\n\nThen your library will work without any additional changes.\n\n### Analyzer\n\n- Static checking of `for in` statements. These will now produce static\n  warnings:\n\n  ```dart\n  // Not Iterable.\n  for (var i in 1234) { ... }\n\n  // String cannot be assigned to int.\n  for (int n in <String>[\"a\", \"b\"]) { ... }\n  ```\n\n### Tool Changes\n\n- Pub\n\n  - `pub serve` now provides caching headers that should improve the performance\n    of requesting large files multiple times.\n\n  - Both `pub get` and `pub upgrade` now have a `--no-precompile` flag that\n    disables precompilation of executables and transformed dependencies.\n\n  - `pub publish` now resolves symlinks when publishing from a Git repository.\n    This matches the behavior it always had when publishing a package that\n    wasn't in a Git repository.\n\n- Dart Dev Compiler\n\n  - The **experimental** `dartdevc` executable has been added to the SDK.\n\n  - It will help early adopters validate the implementation and provide\n    feedback. `dartdevc` **is not** yet ready for production usage.\n\n  - Read more about the Dart Dev Compiler [here][dartdevc].\n\n[dartdevc]: https://github.com/dart-lang/dev_compiler\n\n## 1.15.0 - 2016-03-09\n\n### Core library changes\n\n- `dart:async`\n\n  - Made `StreamView` class a `const` class.\n\n- `dart:core`\n\n  - Added `Uri.queryParametersAll` to handle multiple query parameters with the\n    same name.\n\n- `dart:io`\n  - Added `SecurityContext.usePrivateKeyBytes`,\n    `SecurityContext.useCertificateChainBytes`,\n    `SecurityContext.setTrustedCertificatesBytes`, and\n    `SecurityContext.setClientAuthoritiesBytes`.\n  - **Breaking** The named `directory` argument of\n    `SecurityContext.setTrustedCertificates` has been removed.\n  - Added support to `SecurityContext` for PKCS12 certificate and key\n    containers.\n  - All calls in `SecurityContext` that accept certificate data now accept an\n    optional named parameter `password`, similar to\n    `SecurityContext.usePrivateKeyBytes`, for use as the password for PKCS12\n    data.\n\n### Tool changes\n\n- Dartium and content shell\n\n  - The Chrome-based tools that ship as part of the Dart SDK - Dartium and\n    content shell - are now based on Chrome version 45 (instead of Chrome 39).\n  - Dart browser libraries (`dart:html`, `dart:svg`, etc) _have not_ been\n    updated.\n    - These are still based on Chrome 39.\n    - These APIs will be updated in a future release.\n  - Note that there are experimental APIs which have changed in the underlying\n    browser, and will not work with the older libraries. For example,\n    `Element.animate`.\n\n- `dartfmt` - upgraded to v0.2.4\n  - Better handling for long collections with comments.\n  - Always put member metadata annotations on their own line.\n  - Indent functions in named argument lists with non-functions.\n  - Force the parameter list to split if a split occurs inside a function-typed\n    parameter.\n  - Don't force a split for before a single named argument if the argument\n    itself splits.\n\n### Service protocol changes\n\n- Fixed a documentation bug where the field `extensionRPCs` in `Isolate` was not\n  marked optional.\n\n### Experimental language features\n\n- Added support for\n  [configuration-specific imports](https://github.com/munificent/dep-interface-libraries/blob/master/Proposal.md).\n  On the VM and `dart2js`, they can be enabled with `--conditional-directives`.\n\n  The analyzer requires additional configuration:\n\n  ```yaml\n  analyzer:\n    language:\n      enableConditionalDirectives: true\n  ```\n\n  Read about [configuring the analyzer] for more details.\n\n[configuring the analyzer]:\n  https://github.com/dart-lang/sdk/tree/master/pkg/analyzer#configuring-the-analyzer\n\n## 1.14.2 - 2016-02-10\n\nPatch release, resolves three issues:\n\n- VM: Fixed a code generation bug on x64. (SDK commit\n  [834b3f02](https://github.com/dart-lang/sdk/commit/834b3f02b6ab740a213fd808e6c6f3269bed80e5))\n\n- `dart:io`: Fixed EOF detection when reading some special device files. (SDK\n  issue [25596](https://github.com/dart-lang/sdk/issues/25596))\n\n- Pub: Fixed an error using hosted dependencies in SDK version 1.14. (Pub issue\n  [1386](https://github.com/dart-lang/pub/issues/1386))\n\n## 1.14.1 - 2016-02-04\n\nPatch release, resolves one issue:\n\n- Debugger: Fixes a VM crash when a debugger attempts to set a break point\n  during isolate initialization. (SDK issue\n  [25618](https://github.com/dart-lang/sdk/issues/25618))\n\n## 1.14.0 - 2016-01-28\n\n### Core library changes\n\n- `dart:async`\n\n  - Added `Future.any` static method.\n  - Added `Stream.fromFutures` constructor.\n\n- `dart:convert`\n\n  - `Base64Decoder.convert` now takes optional `start` and `end` parameters.\n\n- `dart:core`\n\n  - Added `current` getter to `StackTrace` class.\n  - `Uri` class added support for data URIs\n    - Added two new constructors: `dataFromBytes` and `dataFromString`.\n    - Added a `data` getter for `data:` URIs with a new `UriData` class for the\n      return type.\n  - Added `growable` parameter to `List.filled` constructor.\n  - Added microsecond support to `DateTime`: `DateTime.microsecond`,\n    `DateTime.microsecondsSinceEpoch`, and\n    `new DateTime.fromMicrosecondsSinceEpoch`.\n\n- `dart:math`\n\n  - `Random` added a `secure` constructor returning a cryptographically secure\n    random generator which reads from the entropy source provided by the\n    embedder for every generated random value.\n\n- `dart:io`\n\n  - `Platform` added a static `isIOS` getter and `Platform.operatingSystem` may\n    now return `ios`.\n  - `Platform` added a static `packageConfig` getter.\n  - Added support for WebSocket compression as standardized in RFC 7692.\n  - Compression is enabled by default for all WebSocket connections.\n    - The optionally named parameter `compression` on the methods\n      `WebSocket.connect`, `WebSocket.fromUpgradedSocket`, and\n      `WebSocketTransformer.upgrade` and the `WebSocketTransformer` constructor\n      can be used to modify or disable compression using the new\n      `CompressionOptions` class.\n\n- `dart:isolate`\n  - Added **_experimental_** support for [Package Resolution Configuration].\n    - Added `packageConfig` and `packageRoot` instance getters to `Isolate`.\n    - Added a `resolvePackageUri` method to `Isolate`.\n    - Added named arguments `packageConfig` and `automaticPackageResolution` to\n      the `Isolate.spawnUri` constructor.\n\n[package resolution configuration]:\n  https://github.com/dart-lang/dart_enhancement_proposals/blob/master/Accepted/0005%20-%20Package%20Specification/DEP-pkgspec.md\n\n### Tool changes\n\n- `dartfmt`\n\n  - Better line splitting in a variety of cases.\n\n  - Other optimizations and bug fixes.\n\n- Pub\n\n  - **Breaking:** Pub now eagerly emits an error when a pubspec's \"name\" field\n    is not a valid Dart identifier. Since packages with non-identifier names\n    were never allowed to be published, and some of them already caused crashes\n    when being written to a `.packages` file, this is unlikely to break many\n    people in practice.\n\n  - **Breaking:** Support for `barback` versions prior to 0.15.0 (released July\n\n    1.  has been dropped. Pub will no longer install these older barback\n        versions.\n\n  - `pub serve` now GZIPs the assets it serves to make load times more similar\n    to real-world use-cases.\n\n  - `pub deps` now supports a `--no-dev` flag, which causes it to emit the\n    dependency tree as it would be if no `dev_dependencies` were in use. This\n    makes it easier to see your package's dependency footprint as your users\n    will experience it.\n\n  - `pub global run` now detects when a global executable's SDK constraint is no\n    longer met and errors out, rather than trying to run the executable anyway.\n\n  - Pub commands that check whether the lockfile is up-to-date (`pub run`,\n    `pub deps`, `pub serve`, and `pub build`) now do additional verification.\n    They ensure that any path dependencies' pubspecs haven't been changed, and\n    they ensure that the current SDK version is compatible with all\n    dependencies.\n\n  - Fixed a crashing bug when using `pub global run` on a global script that\n    didn't exist.\n\n  - Fixed a crashing bug when a pubspec contains a dependency without a source\n    declared.\n\n## 1.13.2 - 2016-01-06\n\nPatch release, resolves one issue:\n\n- dart2js: Stack traces are not captured correctly (SDK issue [25235]\n  (https://github.com/dart-lang/sdk/issues/25235))\n\n## 1.13.1 - 2015-12-17\n\nPatch release, resolves three issues:\n\n- VM type propagation fix: Resolves a potential crash in the Dart VM (SDK commit\n  [dff13be]\n  (https://github.com/dart-lang/sdk/commit/dff13bef8de104d33b04820136da2d80f3c835d7))\n\n- dart2js crash fix: Resolves a crash in pkg/js and dart2js (SDK issue [24974]\n  (https://github.com/dart-lang/sdk/issues/24974))\n\n- Pub get crash on ARM: Fixes a crash triggered when running 'pub get' on ARM\n  processors such as those on a Raspberry Pi (SDK issue [24855]\n  (https://github.com/dart-lang/sdk/issues/24855))\n\n## 1.13.0 - 2015-11-18\n\n### Core library changes\n\n- `dart:async`\n\n  - `StreamController` added getters for `onListen`, `onPause`, and `onResume`\n    with the corresponding new `typedef void ControllerCallback()`.\n  - `StreamController` added a getter for `onCancel` with the corresponding new\n    `typedef ControllerCancelCallback()`;\n  - `StreamTransformer` instances created with `fromHandlers` with no\n    `handleError` callback now forward stack traces along with errors to the\n    resulting streams.\n\n- `dart:convert`\n\n  - Added support for Base-64 encoding and decoding.\n    - Added new classes `Base64Codec`, `Base64Encoder`, and `Base64Decoder`.\n    - Added new top-level `const Base64Codec BASE64`.\n\n- `dart:core`\n\n  - `Uri` added `removeFragment` method.\n  - `String.allMatches` (implementing `Pattern.allMatches`) is now lazy, as all\n    `allMatches` implementations are intended to be.\n  - `Resource` is deprecated, and will be removed in a future release.\n\n- `dart:developer`\n\n  - Added `Timeline` class for interacting with Observatory's timeline feature.\n  - Added `ServiceExtensionHandler`, `ServiceExtensionResponse`, and\n    `registerExtension` which enable developers to provide their own VM service\n    protocol extensions.\n\n- `dart:html`, `dart:indexed_db`, `dart:svg`, `dart:web_audio`, `dart:web_gl`,\n  `dart:web_sql`\n\n  - The return type of some APIs changed from `double` to `num`. Dartium is now\n    using JS interop for most operations. JS does not distinguish between\n    numeric types, and will return a number as an int if it fits in an int. This\n    will mostly cause an error if you assign to something typed `double` in\n    checked mode. You may need to insert a `toDouble()` call or accept `num`.\n    Examples of APIs that are affected include `Element.getBoundingClientRect`\n    and `TextMetrics.width`.\n\n- `dart:io`\n\n  - **Breaking:** Secure networking has changed, replacing the NSS library with\n    the BoringSSL library. `SecureSocket`, `SecureServerSocket`,\n    `RawSecureSocket`,`RawSecureServerSocket`, `HttpClient`, and `HttpServer`\n    now all use a `SecurityContext` object which contains the certificates and\n    keys used for secure TLS (SSL) networking.\n\n    This is a breaking change for server applications and for some client\n    applications. Certificates and keys are loaded into the `SecurityContext`\n    from PEM files, instead of from an NSS certificate database. Information\n    about how to change applications that use secure networking is at\n    https://www.dartlang.org/server/tls-ssl.html\n\n  - `HttpClient` no longer sends URI fragments in the request. This is not\n    allowed by the HTTP protocol. The `HttpServer` still gracefully receives\n    fragments, but discards them before delivering the request.\n  - To allow connections to be accepted on the same port across different\n    isolates, set the `shared` argument to `true` when creating server socket\n    and `HttpServer` instances.\n    - The deprecated `ServerSocketReference` and `RawServerSocketReference`\n      classes have been removed.\n    - The corresponding `reference` properties on `ServerSocket` and\n      `RawServerSocket` have been removed.\n\n- `dart:isolate`\n  - `spawnUri` added an `environment` named argument.\n\n### Tool changes\n\n- `dart2js` and Dartium now support improved Javascript Interoperability via the\n  [js package](https://pub.dartlang.org/packages/js).\n\n- `docgen` and `dartdocgen` no longer ship in the SDK. The `docgen` sources have\n  been removed from the repository.\n\n- This is the last release to ship the VM's \"legacy debug protocol\". We intend\n  to remove the legacy debug protocol in Dart VM 1.14.\n\n- The VM's Service Protocol has been updated to version 3.0 to take care of a\n  number of issues uncovered by the first few non-observatory clients. This is a\n  potentially breaking change for clients.\n\n- Dartium has been substantially changed. Rather than using C++ calls into\n  Chromium internals for DOM operations it now uses JS interop. The DOM objects\n  in `dart:html` and related libraries now wrap a JavaScript object and delegate\n  operations to it. This should be mostly transparent to users. However,\n  performance and memory characteristics may be different from previous\n  versions. There may be some changes in which DOM objects are wrapped as Dart\n  objects. For example, if you get a reference to a Window object, even through\n  JS interop, you will always see it as a Dart Window, even when used\n  cross-frame. We expect the change to using JS interop will make it much\n  simpler to update to new Chrome versions.\n\n## 1.12.2 - 2015-10-21\n\n### Core library changes\n\n- `dart:io`\n\n  - A memory leak in creation of Process objects is fixed.\n\n## 1.12.1 - 2015-09-08\n\n### Tool changes\n\n- Pub\n\n  - Pub will now respect `.gitignore` when validating a package before it's\n    published. For example, if a `LICENSE` file exists but is ignored, that is\n    now an error.\n\n  - If the package is in a subdirectory of a Git repository and the entire\n    subdirectory is ignored with `.gitignore`, pub will act as though nothing\n    was ignored instead of uploading an empty package.\n\n  - The heuristics for determining when `pub get` needs to be run before various\n    commands have been improved. There should no longer be false positives when\n    non-dependency sections of the pubspec have been modified.\n\n## 1.12.0 - 2015-08-31\n\n### Language changes\n\n- Null-aware operators\n  - `??`: if null operator. `expr1 ?? expr2` evaluates to `expr1` if not `null`,\n    otherwise `expr2`.\n  - `??=`: null-aware assignment. `v ??= expr` causes `v` to be assigned `expr`\n    only if `v` is `null`.\n  - `x?.p`: null-aware access. `x?.p` evaluates to `x.p` if `x` is not `null`,\n    otherwise evaluates to `null`.\n  - `x?.m()`: null-aware method invocation. `x?.m()` invokes `m` only if `x` is\n    not `null`.\n\n### Core library changes\n\n- `dart:async`\n\n  - `StreamController` added setters for the `onListen`, `onPause`, `onResume`\n    and `onCancel` callbacks.\n\n- `dart:convert`\n\n  - `LineSplitter` added a `split` static method returning an `Iterable`.\n\n- `dart:core`\n\n  - `Uri` class now perform path normalization when a URI is created. This\n    removes most `..` and `.` sequences from the URI path. Purely relative paths\n    (no scheme or authority) are allowed to retain some leading \"dot\" segments.\n    Also added `hasAbsolutePath`, `hasEmptyPath`, and `hasScheme` properties.\n\n- `dart:developer`\n\n  - New `log` function to transmit logging events to Observatory.\n\n- `dart:html`\n\n  - `NodeTreeSanitizer` added the `const trusted` field. It can be used instead\n    of defining a `NullTreeSanitizer` class when calling `setInnerHtml` or other\n    methods that create DOM from text. It is also more efficient, skipping the\n    creation of a `DocumentFragment`.\n\n- `dart:io`\n\n  - Added two new file modes, `WRITE_ONLY` and `WRITE_ONLY_APPEND` for opening a\n    file write only.\n    [eaeecf2](https://github.com/dart-lang/sdk/commit/eaeecf2ed13ba6c7fbfd653c3c592974a7120960)\n  - Change stdout/stderr to binary mode on Windows.\n    [4205b29](https://github.com/dart-lang/sdk/commit/4205b2997e01f2cea8e2f44c6f46ed6259ab7277)\n\n- `dart:isolate`\n\n  - Added `onError`, `onExit` and `errorsAreFatal` parameters to\n    `Isolate.spawnUri`.\n\n- `dart:mirrors`\n  - `InstanceMirror.delegate` moved up to `ObjectMirror`.\n  - Fix InstanceMirror.getField optimization when the selector is an operator.\n  - Fix reflective NoSuchMethodErrors to match their non-reflective counterparts\n    when due to argument mismatches. (VM only)\n\n### Tool changes\n\n- Documentation tools\n\n  - `dartdoc` is now the default tool to generate static HTML for API docs.\n    [Learn more](https://pub.dartlang.org/packages/dartdoc).\n\n  - `docgen` and `dartdocgen` have been deprecated. Currently plan is to remove\n    them in 1.13.\n\n- Formatter (`dartfmt`)\n\n  - Over 50 bugs fixed.\n\n  - Optimized line splitter is much faster and produces better output on complex\n    code.\n\n- Observatory\n\n  - Allocation profiling.\n\n  - New feature to display output from logging.\n\n  - Heap snapshot analysis works for 64-bit VMs.\n\n  - Improved ability to inspect typed data, regex and compiled code.\n\n  - Ability to break on all or uncaught exceptions from Observatory's debugger.\n\n  - Ability to set closure-specific breakpoints.\n\n  - 'anext' - step past await/yield.\n\n  - Preserve when a variable has been expanded/unexpanded in the debugger.\n\n  - Keep focus on debugger input box whenever possible.\n\n  - Echo stdout/stderr in the Observatory debugger. Standalone-only so far.\n\n  - Minor fixes to service protocol documentation.\n\n- Pub\n\n  - **Breaking:** various commands that previously ran `pub get` implicitly no\n    longer do so. Instead, they merely check to make sure the \".packages\" file\n    is newer than the pubspec and the lock file, and fail if it's not.\n\n  - Added support for `--verbosity=error` and `--verbosity=warning`.\n\n  - `pub serve` now collapses multiple GET requests into a single line of\n    output. For full output, use `--verbose`.\n\n  - `pub deps` has improved formatting for circular dependencies on the\n    entrypoint package.\n\n  - `pub run` and `pub global run`\n\n    - **Breaking:** to match the behavior of the Dart VM, executables no longer\n      run in checked mode by default. A `--checked` flag has been added to run\n      them in checked mode manually.\n\n    - Faster start time for executables that don't import transformed code.\n\n    - Binstubs for globally-activated executables are now written in the system\n      encoding, rather than always in `UTF-8`. To update existing executables,\n      run `pub cache repair`.\n\n  - `pub get` and `pub upgrade`\n\n    - Pub will now generate a \".packages\" file in addition to the \"packages\"\n      directory when running `pub get` or similar operations, per the [package\n      spec proposal][]. Pub now has a `--no-package-symlinks` flag that will\n      stop \"packages\" directories from being generated at all.\n\n    - An issue where HTTP requests were sometimes made even though `--offline`\n      was passed has been fixed.\n\n    - A bug with `--offline` that caused an unhelpful error message has been\n      fixed.\n\n    - Pub will no longer time out when a package takes a long time to download.\n\n  - `pub publish`\n\n    - Pub will emit a non-zero exit code when it finds a violation while\n      publishing.\n\n    - `.gitignore` files will be respected even if the package isn't at the top\n      level of the Git repository.\n\n  - Barback integration\n\n    - A crashing bug involving transformers that only apply to non-public code\n      has been fixed.\n\n    - A deadlock caused by declaring transformer followed by a lazy transformer\n      (such as the built-in `$dart2js` transformer) has been fixed.\n\n    - A stack overflow caused by a transformer being run multiple times on the\n      package that defines it has been fixed.\n\n    - A transformer that tries to read a non-existent asset in another package\n      will now be re-run if that asset is later created.\n\n[package spec proposal]: https://github.com/lrhn/dep-pkgspec\n\n### VM Service Protocol Changes\n\n- **BREAKING** The service protocol now sends JSON-RPC 2.0-compatible\n  server-to-client events. To reflect this, the service protocol version is now\n  2.0.\n\n- The service protocol now includes a `\"jsonrpc\"` property in its responses, as\n  opposed to `\"json-rpc\"`.\n\n- The service protocol now properly handles requests with non-string ids.\n  Numeric ids are no longer converted to strings, and null ids now don't produce\n  a response.\n\n- Some RPCs that didn't include a `\"jsonrpc\"` property in their responses now\n  include one.\n\n## 1.11.2 - 2015-08-03\n\n### Core library changes\n\n- Fix a bug where `WebSocket.close()` would crash if called after\n  `WebSocket.cancel()`.\n\n## 1.11.1 - 2015-07-02\n\n### Tool changes\n\n- Pub will always load Dart SDK assets from the SDK whose `pub` executable was\n  run, even if a `DART_SDK` environment variable is set.\n\n## 1.11.0 - 2015-06-25\n\n### Core library changes\n\n- `dart:core`\n\n  - `Iterable` added an `empty` constructor.\n    [dcf0286](https://github.com/dart-lang/sdk/commit/dcf0286f5385187a68ce9e66318d3bf19abf454b)\n  - `Iterable` can now be extended directly. An alternative to extending\n    `IterableBase` from `dart:collection`.\n  - `List` added an `unmodifiable` constructor.\n    [r45334](https://code.google.com/p/dart/source/detail?r=45334)\n  - `Map` added an `unmodifiable` constructor.\n    [r45733](https://code.google.com/p/dart/source/detail?r=45733)\n  - `int` added a `gcd` method.\n    [a192ef4](https://github.com/dart-lang/sdk/commit/a192ef4acb95fad1aad1887f59eed071eb5e8201)\n  - `int` added a `modInverse` method.\n    [f6f338c](https://github.com/dart-lang/sdk/commit/f6f338ce67eb8801b350417baacf6d3681b26002)\n  - `StackTrace` added a `fromString` constructor.\n    [68dd6f6](https://github.com/dart-lang/sdk/commit/68dd6f6338e63d0465041d662e778369c02c2ce6)\n  - `Uri` added a `directory` constructor.\n    [d8dbb4a](https://github.com/dart-lang/sdk/commit/d8dbb4a60f5e8a7f874c2a4fbf59eaf1a39f4776)\n  - List iterators may not throw `ConcurrentModificationError` as eagerly in\n    release mode. In checked mode, the modification check is still as eager as\n    possible. [r45198](https://github.com/dart-lang/sdk/commit/5a79c03)\n\n- `dart:developer` - **NEW**\n\n  - Replaces the deprecated `dart:profiler` library.\n  - Adds new functions `debugger` and `inspect`.\n    [6e42aec](https://github.com/dart-lang/sdk/blob/6e42aec4f64cf356dde7bad9426e07e0ea5b58d5/sdk/lib/developer/developer.dart)\n\n- `dart:io`\n\n  - `FileSystemEntity` added a `uri` property.\n    [8cf32dc](https://github.com/dart-lang/sdk/commit/8cf32dc1a1664b516e57f804524e46e55fae88b2)\n  - `Platform` added a `static resolvedExecutable` property.\n    [c05c8c6](https://github.com/dart-lang/sdk/commit/c05c8c66069db91cc2fd48691dfc406c818d411d)\n\n- `dart:html`\n\n  - `Element` methods, `appendHtml` and `insertAdjacentHtml` now take\n    `nodeValidator` and `treeSanitizer` parameters, and the inputs are\n    consistently sanitized.\n    [r45818 announcement](https://groups.google.com/a/dartlang.org/forum/#!topic/announce/GVO7EAcPi6A)\n\n- `dart:isolate`\n\n  - **BREAKING** The positional `priority` parameter of `Isolate.ping` and\n    `Isolate.kill` is now a named parameter named `priority`.\n  - **BREAKING** Removed the `Isolate.AS_EVENT` priority.\n  - `Isolate` methods `ping` and `addOnExitListener` now have a named parameter\n    `response`. [r45092](https://github.com/dart-lang/sdk/commit/1b208bd)\n  - `Isolate.spawnUri` added a named argument `checked`.\n  - Remove the experimental state of the API.\n\n- `dart:profiler` - **DEPRECATED**\n  - This library will be removed in 1.12. Use `dart:developer` instead.\n\n### Tool changes\n\n- This is the first release that does not include the Eclipse-based **Dart\n  Editor**. See [dartlang.org/tools](https://www.dartlang.org/tools/) for\n  alternatives.\n- This is the last release that ships the (unsupported) dart2dart (aka\n  `dart2js --output-type=dart`) utility as part of dart2js\n\n## 1.10.0 - 2015-04-29\n\n### Core library changes\n\n- `dart:convert`\n\n  - **POTENTIALLY BREAKING** Fix behavior of `HtmlEscape`. It no longer escapes\n    no-break space (U+00A0) anywhere or forward slash (`/`, `U+002F`) in element\n    context. Slash is still escaped using `HtmlEscapeMode.UNKNOWN`.\n    [r45003](https://github.com/dart-lang/sdk/commit/8b8223d),\n    [r45153](https://github.com/dart-lang/sdk/commit/8a5d049),\n    [r45189](https://github.com/dart-lang/sdk/commit/3c39ad2)\n\n- `dart:core`\n\n  - `Uri.parse` added `start` and `end` positional arguments.\n\n- `dart:html`\n\n  - **POTENTIALLY BREAKING** `CssClassSet` method arguments must now be\n    'tokens', i.e. non-empty strings with no white-space characters. The\n    implementation was incorrect for class names containing spaces. The fix is\n    to forbid spaces and provide a faster implementation.\n    [Announcement](https://groups.google.com/a/dartlang.org/d/msg/announce/jmUI2XJHfC8/UZUCvJH3p2oJ)\n\n- `dart:io`\n\n  - `ProcessResult` now exposes a constructor.\n  - `import` and `Isolate.spawnUri` now supports the\n    [Data URI scheme](http://en.wikipedia.org/wiki/Data_URI_scheme) on the VM.\n\n## Tool Changes\n\n### pub\n\n- Running `pub run foo` within a package now runs the `foo` executable defined\n  by the `foo` package. The previous behavior ran `bin/foo`. This makes it easy\n  to run binaries in dependencies, for instance `pub run test`.\n\n- On Mac and Linux, signals sent to `pub run` and forwarded to the child\n  command.\n\n## 1.9.3 - 2015-04-14\n\nThis is a bug fix release which merges a number of commits from `bleeding_edge`.\n\n- dart2js: Addresses as issue with minified Javascript output with CSP enabled -\n  [r44453](https://code.google.com/p/dart/source/detail?r=44453)\n\n- Editor: Fixes accidental updating of files in the pub cache during rename\n  refactoring - [r44677](https://code.google.com/p/dart/source/detail?r=44677)\n\n- Editor: Fix for\n  [issue 23032](https://code.google.com/p/dart/issues/detail?id=23032) regarding\n  skipped breakpoints on Windows -\n  [r44824](https://code.google.com/p/dart/source/detail?r=44824)\n\n- dart:mirrors: Fix `MethodMirror.source` when the method is on the first line\n  in a script - [r44957](https://code.google.com/p/dart/source/detail?r=44957),\n  [r44976](https://code.google.com/p/dart/source/detail?r=44976)\n\n- pub: Fix for\n  [issue 23084](https://code.google.com/p/dart/issues/detail?id=23084): Pub can\n  fail to load transformers necessary for local development -\n  [r44876](https://code.google.com/p/dart/source/detail?r=44876)\n\n## 1.9.1 - 2015-03-25\n\n### Language changes\n\n- Support for `async`, `await`, `sync*`, `async*`, `yield`, `yield*`, and\n  `await for`. See the [the language tour][async] for more details.\n\n- Enum support is fully enabled. See [the language tour][enum] for more details.\n\n[async]: https://www.dartlang.org/docs/dart-up-and-running/ch02.html#asynchrony\n[enum]: https://www.dartlang.org/docs/dart-up-and-running/ch02.html#enums\n\n### Tool changes\n\n- The formatter is much more comprehensive and generates much more readable\n  code. See [its tool page][dartfmt] for more details.\n\n- The analysis server is integrated into the IntelliJ plugin and the Dart\n  editor. This allows analysis to run out-of-process, so that interaction\n  remains smooth even for large projects.\n\n- Analysis supports more and better hints, including unused variables and unused\n  private members.\n\n[dartfmt]: https://www.dartlang.org/tools/dartfmt/\n\n### Core library changes\n\n#### Highlights\n\n- There's a new model for shared server sockets with no need for a `Socket`\n  reference.\n\n- A new, much faster [regular expression engine][regexp].\n\n- The Isolate API now works across the VM and `dart2js`.\n\n[regexp]: http://news.dartlang.org/2015/02/irregexp-dart-vms-new-regexp.html\n\n#### Details\n\nFor more information on any of these changes, see the corresponding\ndocumentation on the [Dart API site](http://api.dartlang.org).\n\n- `dart:async`:\n\n  - `Future.wait` added a new named argument, `cleanUp`, which is a callback\n    that releases resources allocated by a successful `Future`.\n\n  - The `SynchronousStreamController` class was added as an explicit name for\n    the type returned when the `sync` argument is passed to\n    `new StreamController`.\n\n- `dart:collection`: The `new SplayTreeSet.from(Iterable)` constructor was\n  added.\n\n- `dart:convert`: `Utf8Encoder.convert` and `Utf8Decoder.convert` added optional\n  `start` and `end` arguments.\n\n- `dart:core`:\n\n  - `RangeError` added new static helper functions: `checkNotNegative`,\n    `checkValidIndex`, `checkValidRange`, and `checkValueInInterval`.\n\n  - `int` added the `modPow` function.\n\n  - `String` added the `replaceFirstMapped` and `replaceRange` functions.\n\n- `dart:io`:\n\n  - Support for locking files to prevent concurrent modification was added. This\n    includes the `File.lock`, `File.lockSync`, `File.unlock`, and\n    `File.unlockSync` functions as well as the `FileLock` class.\n\n  - Support for starting detached processes by passing the named `mode` argument\n    (a `ProcessStartMode`) to `Process.start`. A process can be fully attached,\n    fully detached, or detached except for its standard IO streams.\n\n  - `HttpServer.bind` and `HttpServer.bindSecure` added the `v6Only` named\n    argument. If this is true, only IPv6 connections will be accepted.\n\n  - `HttpServer.bind`, `HttpServer.bindSecure`, `ServerSocket.bind`,\n    `RawServerSocket.bind`, `SecureServerSocket.bind` and\n    `RawSecureServerSocket.bind` added the `shared` named argument. If this is\n    true, multiple servers or sockets in the same Dart process may bind to the\n    same address, and incoming requests will automatically be distributed\n    between them.\n\n  - **Deprecation:** the experimental `ServerSocketReference` and\n    `RawServerSocketReference` classes, as well as getters that returned them,\n    are marked as deprecated. The `shared` named argument should be used\n    instead. These will be removed in Dart 1.10.\n\n  - `Socket.connect` and `RawSocket.connect` added the `sourceAddress` named\n    argument, which specifies the local address to bind when making a\n    connection.\n\n  - The static `Process.killPid` method was added to kill a process with a given\n    PID.\n\n  - `Stdout` added the `nonBlocking` instance property, which returns a\n    non-blocking `IOSink` that writes to standard output.\n\n- `dart:isolate`:\n\n  - The static getter `Isolate.current` was added.\n\n  - The `Isolate` methods `addOnExitListener`, `removeOnExitListener`,\n    `setErrorsFatal`, `addOnErrorListener`, and `removeOnErrorListener` now work\n    on the VM.\n\n  - Isolates spawned via `Isolate.spawn` now allow most objects, including\n    top-level and static functions, to be sent between them.\n\n## 1.8.5 - 2015-01-21\n\n- Code generation for SIMD on ARM and ARM64 is fixed.\n\n- A possible crash on MIPS with newer GCC toolchains has been prevented.\n\n- A segfault when using `rethrow` was fixed ([issue 21795][]).\n\n[issue 21795]: https://code.google.com/p/dart/issues/detail?id=21795\n\n## 1.8.3 - 2014-12-10\n\n- Breakpoints can be set in the Editor using file suffixes ([issue 21280][]).\n\n- IPv6 addresses are properly handled by `HttpClient` in `dart:io`, fixing a\n  crash in pub ([issue 21698][]).\n\n- Issues with the experimental `async`/`await` syntax have been fixed.\n\n- Issues with a set of number operations in the VM have been fixed.\n\n- `ListBase` in `dart:collection` always returns an `Iterable` with the correct\n  type argument.\n\n[issue 21280]: https://code.google.com/p/dart/issues/detail?id=21280\n[issue 21698]: https://code.google.com/p/dart/issues/detail?id=21698\n\n## 1.8.0 - 2014-11-28\n\n- `dart:collection`: `SplayTree` added the `toSet` function.\n\n- `dart:convert`: The `JsonUtf8Encoder` class was added.\n\n- `dart:core`:\n\n  - The `IndexError` class was added for errors caused by an index being outside\n    its expected range.\n\n  - The `new RangeError.index` constructor was added. It forwards to\n    `new IndexError`.\n\n  - `RangeError` added three new properties. `invalidProperty` is the value that\n    caused the error, and `start` and `end` are the minimum and maximum values\n    that the value is allowed to assume.\n\n  - `new RangeError.value` and `new RangeError.range` added an optional\n    `message` argument.\n\n  - The `new String.fromCharCodes` constructor added optional `start` and `end`\n    arguments.\n\n- `dart:io`:\n\n  - Support was added for the [Application-Layer Protocol Negotiation][alpn]\n    extension to the TLS protocol for both the client and server.\n\n  - `SecureSocket.connect`, `SecureServerSocket.bind`,\n    `RawSecureSocket.connect`, `RawSecureSocket.secure`,\n    `RawSecureSocket.secureServer`, and `RawSecureServerSocket.bind` added a\n    `supportedProtocols` named argument for protocol negotiation.\n\n  - `RawSecureServerSocket` added a `supportedProtocols` field.\n\n  - `RawSecureSocket` and `SecureSocket` added a `selectedProtocol` field which\n    contains the protocol selected during protocol negotiation.\n\n[alpn]: https://tools.ietf.org/html/rfc7301\n\n## 1.7.0 - 2014-10-15\n\n### Tool changes\n\n- `pub` now generates binstubs for packages that are globally activated so that\n  they can be put on the user's `PATH` and used as normal executables. See the\n  [`pub global activate` documentation][pub global activate].\n\n- When using `dart2js`, deferred loading now works with multiple Dart apps on\n  the same page.\n\n[pub global activate]:\n  https://www.dartlang.org/tools/pub/cmd/pub-global.html#running-a-script-from-your-path\n\n### Core library changes\n\n- `dart:async`: `Zone`, `ZoneDelegate`, and `ZoneSpecification` added the\n  `errorCallback` function, which allows errors that have been programmatically\n  added to a `Future` or `Stream` to be intercepted.\n\n- `dart:io`:\n\n  - **Breaking change:** `HttpClient.close` must be called for all clients or\n    they will keep the Dart process alive until they time out. This fixes the\n    handling of persistent connections. Previously, the client would shut down\n    immediately after a request.\n\n  - **Breaking change:** `HttpServer` no longer compresses all traffic by\n    default. The new `autoCompress` property can be set to `true` to re-enable\n    compression.\n\n- `dart:isolate`: `Isolate.spawnUri` added the optional `packageRoot` argument,\n  which controls how it resolves `package:` URIs.\n", "// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\nlibrary dart._http;\n\nimport 'dart:_internal'\n    show Since, valueOfNonNullableParamWithDefault, HttpStatus;\nimport 'dart:async';\nimport 'dart:collection'\n    show\n        HashMap,\n        HashSet,\n        ListQueue,\n        LinkedList,\n        LinkedListEntry,\n        UnmodifiableMapView;\nimport 'dart:convert';\nimport 'dart:developer' hide log;\nimport 'dart:io';\nimport 'dart:isolate' show Isolate;\nimport 'dart:math';\nimport 'dart:typed_data';\n\npart 'crypto.dart';\npart 'embedder_config.dart';\npart 'http_date.dart';\npart 'http_headers.dart';\npart 'http_impl.dart';\npart 'http_parser.dart';\npart 'http_session.dart';\npart 'overrides.dart';\npart 'websocket.dart';\npart 'websocket_impl.dart';\n\n/// A server that delivers content, such as web pages, using the HTTP protocol.\n///\n/// Note: [HttpServer] provides low-level HTTP functionality.\n/// We recommend users evaluate the high-level APIs discussed at\n/// [Write HTTP servers](https://dart.dev/tutorials/server/httpserver) on\n/// [dart.dev](https://dart.dev/).\n///\n/// `HttpServer` is a [Stream] that provides [HttpRequest] objects. Each\n/// `HttpRequest` has an associated [HttpResponse] object.\n/// The server responds to a request by writing to that [HttpResponse] object.\n/// The following example shows how to bind an `HttpServer` to an IPv6\n/// [InternetAddress] on port 80 (the standard port for HTTP servers)\n/// and how to listen for requests.\n/// Port 80 is the default HTTP port. However, on most systems accessing\n/// this requires super-user privileges. For local testing consider\n/// using a non-reserved port (1024 and above).\n///\n/// ```dart\n/// import 'dart:io';\n///\n/// Future<void> main() async {\n///   var server = await HttpServer.bind(InternetAddress.anyIPv6, 80);\n///   await server.forEach((HttpRequest request) {\n///     request.response.write('Hello, world!');\n///     request.response.close();\n///   });\n/// }\n/// ```\n///\n/// Incomplete requests, in which all or part of the header is missing, are\n/// ignored, and no exceptions or [HttpRequest] objects are generated for them.\n/// Likewise, when writing to an [HttpResponse], any [Socket] exceptions are\n/// ignored and any future writes are ignored.\n///\n/// The [HttpRequest] exposes the request headers and provides the request body,\n/// if it exists, as a Stream of data. If the body is unread, it is drained\n/// when the server writes to the HttpResponse or closes it.\n///\n/// ## Bind with a secure HTTPS connection\n///\n/// Use [bindSecure] to create an HTTPS server.\n///\n/// The server presents a certificate to the client. The certificate\n/// chain and the private key are set in the [SecurityContext]\n/// object that is passed to [bindSecure].\n///\n/// ```dart\n/// import 'dart:io';\n///\n/// Future<void> main() async {\n///   var chain =\n///       Platform.script.resolve('certificates/server_chain.pem').toFilePath();\n///   var key = Platform.script.resolve('certificates/server_key.pem').toFilePath();\n///   var context = SecurityContext()\n///     ..useCertificateChain(chain)\n///     ..usePrivateKey(key, password: 'dartdart');\n///   var server =\n///       await HttpServer.bindSecure(InternetAddress.anyIPv6, 443, context);\n///   await server.forEach((HttpRequest request) {\n///     request.response.write('Hello, world!');\n///     request.response.close();\n///   });\n/// }\n/// ```\n///\n/// The certificates and keys are PEM files, which can be created and\n/// managed with the tools in OpenSSL.\nabstract class HttpServer implements Stream<HttpRequest> {\n  /// Gets and sets the default value of the `Server` header for all responses\n  /// generated by this [HttpServer].\n  ///\n  /// If [serverHeader] is `null`, no `Server` header will be added to each\n  /// response.\n  ///\n  /// The default value is `null`.\n  String? serverHeader;\n\n  /// Default set of headers added to all response objects.\n  ///\n  /// By default the following headers are in this set:\n  ///\n  ///     Content-Type: text/plain; charset=utf-8\n  ///     X-Frame-Options: SAMEORIGIN\n  ///     X-Content-Type-Options: nosniff\n  ///     X-XSS-Protection: 1; mode=block\n  ///\n  /// If the `Server` header is added here and the `serverHeader` is set as\n  /// well then the value of `serverHeader` takes precedence.\n  HttpHeaders get defaultResponseHeaders;\n\n  /// Whether the [HttpServer] should compress the content, if possible.\n  ///\n  /// The content can only be compressed when the response is using\n  /// chunked Transfer-Encoding and the incoming request has `gzip`\n  /// as an accepted encoding in the Accept-Encoding header.\n  ///\n  /// The default value is `false` (compression disabled).\n  /// To enable, set `autoCompress` to `true`.\n  bool autoCompress = false;\n\n  /// Gets or sets the timeout used for idle keep-alive connections. If no\n  /// further request is seen within [idleTimeout] after the previous request was\n  /// completed, the connection is dropped.\n  ///\n  /// Default is 120 seconds.\n  ///\n  /// Note that it may take up to `2 * idleTimeout` before a idle connection is\n  /// aborted.\n  ///\n  /// To disable, set [idleTimeout] to `null`.\n  Duration? idleTimeout = const Duration(seconds: 120);\n\n  /// Starts listening for HTTP requests on the specified [address] and\n  /// [port].\n  ///\n  /// The [address] can either be a [String] or an\n  /// [InternetAddress]. If [address] is a [String], [bind] will\n  /// perform a [InternetAddress.lookup] and use the first value in the\n  /// list. To listen on the loopback adapter, which will allow only\n  /// incoming connections from the local host, use the value\n  /// [InternetAddress.loopbackIPv4] or\n  /// [InternetAddress.loopbackIPv6]. To allow for incoming\n  /// connection from the network use either one of the values\n  /// [InternetAddress.anyIPv4] or [InternetAddress.anyIPv6] to\n  /// bind to all interfaces or the IP address of a specific interface.\n  ///\n  /// If an IP version 6 (IPv6) address is used, both IP version 6\n  /// (IPv6) and version 4 (IPv4) connections will be accepted. To\n  /// restrict this to version 6 (IPv6) only, use [v6Only] to set\n  /// version 6 only. However, if the address is\n  /// [InternetAddress.loopbackIPv6], only IP version 6 (IPv6) connections\n  /// will be accepted.\n  ///\n  /// If [port] has the value 0 an ephemeral port will be chosen by\n  /// the system. The actual port used can be retrieved using the\n  /// [port] getter.\n  ///\n  /// The optional argument [backlog] can be used to specify the listen\n  /// backlog for the underlying OS listen setup. If [backlog] has the\n  /// value of 0 (the default) a reasonable value will be chosen by\n  /// the system.\n  ///\n  /// The optional argument [shared] specifies whether additional `HttpServer`\n  /// objects can bind to the same combination of `address`, `port` and `v6Only`.\n  /// If `shared` is `true` and more `HttpServer`s from this isolate or other\n  /// isolates are bound to the port, then the incoming connections will be\n  /// distributed among all the bound `HttpServer`s. Connections can be\n  /// distributed over multiple isolates this way.\n  static Future<HttpServer> bind(address, int port,\n          {int backlog = 0, bool v6Only = false, bool shared = false}) =>\n      _HttpServer.bind(address, port, backlog, v6Only, shared);\n\n  /// The [address] can either be a [String] or an\n  /// [InternetAddress]. If [address] is a [String], [bind] will\n  /// perform a [InternetAddress.lookup] and use the first value in the\n  /// list. To listen on the loopback adapter, which will allow only\n  /// incoming connections from the local host, use the value\n  /// [InternetAddress.loopbackIPv4] or\n  /// [InternetAddress.loopbackIPv6]. To allow for incoming\n  /// connection from the network use either one of the values\n  /// [InternetAddress.anyIPv4] or [InternetAddress.anyIPv6] to\n  /// bind to all interfaces or the IP address of a specific interface.\n  ///\n  /// If an IP version 6 (IPv6) address is used, both IP version 6\n  /// (IPv6) and version 4 (IPv4) connections will be accepted. To\n  /// restrict this to version 6 (IPv6) only, use [v6Only] to set\n  /// version 6 only.\n  ///\n  /// If [port] has the value 0 an ephemeral port will be chosen by\n  /// the system. The actual port used can be retrieved using the\n  /// [port] getter.\n  ///\n  /// The optional argument [backlog] can be used to specify the listen\n  /// backlog for the underlying OS listen setup. If [backlog] has the\n  /// value of 0 (the default) a reasonable value will be chosen by\n  /// the system.\n  ///\n  /// If [requestClientCertificate] is true, the server will\n  /// request clients to authenticate with a client certificate.\n  /// The server will advertise the names of trusted issuers of client\n  /// certificates, getting them from a [SecurityContext], where they have been\n  /// set using [SecurityContext.setClientAuthorities].\n  ///\n  /// The optional argument [shared] specifies whether additional `HttpServer`\n  /// objects can bind to the same combination of `address`, `port` and `v6Only`.\n  /// If `shared` is `true` and more `HttpServer`s from this isolate or other\n  /// isolates are bound to the port, then the incoming connections will be\n  /// distributed among all the bound `HttpServer`s. Connections can be\n  /// distributed over multiple isolates this way.\n\n  static Future<HttpServer> bindSecure(\n          address, int port, SecurityContext context,\n          {int backlog = 0,\n          bool v6Only = false,\n          bool requestClientCertificate = false,\n          bool shared = false}) =>\n      _HttpServer.bindSecure(address, port, context, backlog, v6Only,\n          requestClientCertificate, shared);\n\n  /// Attaches the HTTP server to an existing [ServerSocket]. When the\n  /// [HttpServer] is closed, the [HttpServer] will just detach itself,\n  /// closing current connections but not closing [serverSocket].\n  factory HttpServer.listenOn(ServerSocket serverSocket) =>\n      _HttpServer.listenOn(serverSocket);\n\n  /// Permanently stops this [HttpServer] from listening for new\n  /// connections.  This closes the [Stream] of [HttpRequest]s with a\n  /// done event. The returned future completes when the server is\n  /// stopped. For a server started using [bind] or [bindSecure] this\n  /// means that the port listened on no longer in use.\n  ///\n  /// If [force] is `true`, active connections will be closed immediately.\n  Future close({bool force = false});\n\n  /// The port that the server is listening on.\n  ///\n  /// This is the actual port used when a port of zero is\n  /// specified in the [bind] or [bindSecure] call.\n  int get port;\n\n  /// The address that the server is listening on.\n  ///\n  /// This is the actual address used when the original address\n  /// was specified as a hostname.\n  InternetAddress get address;\n\n  /// Sets the timeout, in seconds, for sessions of this [HttpServer].\n  ///\n  /// The default timeout is 20 minutes.\n  set sessionTimeout(int timeout);\n\n  /// A [HttpConnectionsInfo] object summarizing the number of\n  /// current connections handled by the server.\n  HttpConnectionsInfo connectionsInfo();\n}\n\n/// Summary statistics about an [HttpServer]s current socket connections.\nclass HttpConnectionsInfo {\n  /// Total number of socket connections.\n  int total = 0;\n\n  /// Number of active connections where actual request/response\n  /// processing is active.\n  int active = 0;\n\n  /// Number of idle connections held by clients as persistent connections.\n  int idle = 0;\n\n  /// Number of connections which are preparing to close.\n  ///\n  /// Note: These connections are also part of the [active] count as they might\n  /// still be sending data to the client before finally closing.\n  int closing = 0;\n}\n\n/// Headers for HTTP requests and responses.\n///\n/// In some situations, headers are immutable:\n///\n/// * [HttpRequest] and [HttpClientResponse] always have immutable headers.\n///\n/// * [HttpResponse] and [HttpClientRequest] have immutable headers\n///   from the moment the body is written to.\n///\n/// In these situations, the mutating methods throw exceptions.\n///\n/// For all operations on HTTP headers the header name is\n/// case-insensitive.\n///\n/// To set the value of a header use the `set()` method:\n///\n///     request.headers.set(HttpHeaders.cacheControlHeader,\n///                         'max-age=3600, must-revalidate');\n///\n/// To retrieve the value of a header use the `value()` method:\n///\n///     print(request.headers.value(HttpHeaders.userAgentHeader));\n///\n/// An `HttpHeaders` object holds a list of values for each name\n/// as the standard allows. In most cases a name holds only a single value,\n/// The most common mode of operation is to use `set()` for setting a value,\n/// and `value()` for retrieving a value.\nabstract class HttpHeaders {\n  static const acceptHeader = \"accept\";\n  static const acceptCharsetHeader = \"accept-charset\";\n  static const acceptEncodingHeader = \"accept-encoding\";\n  static const acceptLanguageHeader = \"accept-language\";\n  static const acceptRangesHeader = \"accept-ranges\";\n  @Since(\"2.14\")\n  static const accessControlAllowCredentialsHeader =\n      'access-control-allow-credentials';\n  @Since(\"2.14\")\n  static const accessControlAllowHeadersHeader = 'access-control-allow-headers';\n  @Since(\"2.14\")\n  static const accessControlAllowMethodsHeader = 'access-control-allow-methods';\n  @Since(\"2.14\")\n  static const accessControlAllowOriginHeader = 'access-control-allow-origin';\n  @Since(\"2.14\")\n  static const accessControlExposeHeadersHeader =\n      'access-control-expose-headers';\n  @Since(\"2.14\")\n  static const accessControlMaxAgeHeader = 'access-control-max-age';\n  @Since(\"2.14\")\n  static const accessControlRequestHeadersHeader =\n      'access-control-request-headers';\n  @Since(\"2.14\")\n  static const accessControlRequestMethodHeader =\n      'access-control-request-method';\n  static const ageHeader = \"age\";\n  static const allowHeader = \"allow\";\n  static const authorizationHeader = \"authorization\";\n  static const cacheControlHeader = \"cache-control\";\n  static const connectionHeader = \"connection\";\n  static const contentEncodingHeader = \"content-encoding\";\n  static const contentLanguageHeader = \"content-language\";\n  static const contentLengthHeader = \"content-length\";\n  static const contentLocationHeader = \"content-location\";\n  static const contentMD5Header = \"content-md5\";\n  static const contentRangeHeader = \"content-range\";\n  static const contentTypeHeader = \"content-type\";\n  static const dateHeader = \"date\";\n  static const etagHeader = \"etag\";\n  static const expectHeader = \"expect\";\n  static const expiresHeader = \"expires\";\n  static const fromHeader = \"from\";\n  static const hostHeader = \"host\";\n  static const ifMatchHeader = \"if-match\";\n  static const ifModifiedSinceHeader = \"if-modified-since\";\n  static const ifNoneMatchHeader = \"if-none-match\";\n  static const ifRangeHeader = \"if-range\";\n  static const ifUnmodifiedSinceHeader = \"if-unmodified-since\";\n  static const lastModifiedHeader = \"last-modified\";\n  static const locationHeader = \"location\";\n  static const maxForwardsHeader = \"max-forwards\";\n  static const pragmaHeader = \"pragma\";\n  static const proxyAuthenticateHeader = \"proxy-authenticate\";\n  static const proxyAuthorizationHeader = \"proxy-authorization\";\n  static const rangeHeader = \"range\";\n  static const refererHeader = \"referer\";\n  static const retryAfterHeader = \"retry-after\";\n  static const serverHeader = \"server\";\n  static const teHeader = \"te\";\n  static const trailerHeader = \"trailer\";\n  static const transferEncodingHeader = \"transfer-encoding\";\n  static const upgradeHeader = \"upgrade\";\n  static const userAgentHeader = \"user-agent\";\n  static const varyHeader = \"vary\";\n  static const viaHeader = \"via\";\n  static const warningHeader = \"warning\";\n  static const wwwAuthenticateHeader = \"www-authenticate\";\n\n  @Deprecated(\"Use acceptHeader instead\")\n  static const ACCEPT = acceptHeader;\n  @Deprecated(\"Use acceptCharsetHeader instead\")\n  static const ACCEPT_CHARSET = acceptCharsetHeader;\n  @Deprecated(\"Use acceptEncodingHeader instead\")\n  static const ACCEPT_ENCODING = acceptEncodingHeader;\n  @Deprecated(\"Use acceptLanguageHeader instead\")\n  static const ACCEPT_LANGUAGE = acceptLanguageHeader;\n  @Deprecated(\"Use acceptRangesHeader instead\")\n  static const ACCEPT_RANGES = acceptRangesHeader;\n  @Deprecated(\"Use ageHeader instead\")\n  static const AGE = ageHeader;\n  @Deprecated(\"Use allowHeader instead\")\n  static const ALLOW = allowHeader;\n  @Deprecated(\"Use authorizationHeader instead\")\n  static const AUTHORIZATION = authorizationHeader;\n  @Deprecated(\"Use cacheControlHeader instead\")\n  static const CACHE_CONTROL = cacheControlHeader;\n  @Deprecated(\"Use connectionHeader instead\")\n  static const CONNECTION = connectionHeader;\n  @Deprecated(\"Use contentEncodingHeader instead\")\n  static const CONTENT_ENCODING = contentEncodingHeader;\n  @Deprecated(\"Use contentLanguageHeader instead\")\n  static const CONTENT_LANGUAGE = contentLanguageHeader;\n  @Deprecated(\"Use contentLengthHeader instead\")\n  static const CONTENT_LENGTH = contentLengthHeader;\n  @Deprecated(\"Use contentLocationHeader instead\")\n  static const CONTENT_LOCATION = contentLocationHeader;\n  @Deprecated(\"Use contentMD5Header instead\")\n  static const CONTENT_MD5 = contentMD5Header;\n  @Deprecated(\"Use contentRangeHeader instead\")\n  static const CONTENT_RANGE = contentRangeHeader;\n  @Deprecated(\"Use contentTypeHeader instead\")\n  static const CONTENT_TYPE = contentTypeHeader;\n  @Deprecated(\"Use dateHeader instead\")\n  static const DATE = dateHeader;\n  @Deprecated(\"Use etagHeader instead\")\n  static const ETAG = etagHeader;\n  @Deprecated(\"Use expectHeader instead\")\n  static const EXPECT = expectHeader;\n  @Deprecated(\"Use expiresHeader instead\")\n  static const EXPIRES = expiresHeader;\n  @Deprecated(\"Use fromHeader instead\")\n  static const FROM = fromHeader;\n  @Deprecated(\"Use hostHeader instead\")\n  static const HOST = hostHeader;\n  @Deprecated(\"Use ifMatchHeader instead\")\n  static const IF_MATCH = ifMatchHeader;\n  @Deprecated(\"Use ifModifiedSinceHeader instead\")\n  static const IF_MODIFIED_SINCE = ifModifiedSinceHeader;\n  @Deprecated(\"Use ifNoneMatchHeader instead\")\n  static const IF_NONE_MATCH = ifNoneMatchHeader;\n  @Deprecated(\"Use ifRangeHeader instead\")\n  static const IF_RANGE = ifRangeHeader;\n  @Deprecated(\"Use ifUnmodifiedSinceHeader instead\")\n  static const IF_UNMODIFIED_SINCE = ifUnmodifiedSinceHeader;\n  @Deprecated(\"Use lastModifiedHeader instead\")\n  static const LAST_MODIFIED = lastModifiedHeader;\n  @Deprecated(\"Use locationHeader instead\")\n  static const LOCATION = locationHeader;\n  @Deprecated(\"Use maxForwardsHeader instead\")\n  static const MAX_FORWARDS = maxForwardsHeader;\n  @Deprecated(\"Use pragmaHeader instead\")\n  static const PRAGMA = pragmaHeader;\n  @Deprecated(\"Use proxyAuthenticateHeader instead\")\n  static const PROXY_AUTHENTICATE = proxyAuthenticateHeader;\n  @Deprecated(\"Use proxyAuthorizationHeader instead\")\n  static const PROXY_AUTHORIZATION = proxyAuthorizationHeader;\n  @Deprecated(\"Use rangeHeader instead\")\n  static const RANGE = rangeHeader;\n  @Deprecated(\"Use refererHeader instead\")\n  static const REFERER = refererHeader;\n  @Deprecated(\"Use retryAfterHeader instead\")\n  static const RETRY_AFTER = retryAfterHeader;\n  @Deprecated(\"Use serverHeader instead\")\n  static const SERVER = serverHeader;\n  @Deprecated(\"Use teHeader instead\")\n  static const TE = teHeader;\n  @Deprecated(\"Use trailerHeader instead\")\n  static const TRAILER = trailerHeader;\n  @Deprecated(\"Use transferEncodingHeader instead\")\n  static const TRANSFER_ENCODING = transferEncodingHeader;\n  @Deprecated(\"Use upgradeHeader instead\")\n  static const UPGRADE = upgradeHeader;\n  @Deprecated(\"Use userAgentHeader instead\")\n  static const USER_AGENT = userAgentHeader;\n  @Deprecated(\"Use varyHeader instead\")\n  static const VARY = varyHeader;\n  @Deprecated(\"Use viaHeader instead\")\n  static const VIA = viaHeader;\n  @Deprecated(\"Use warningHeader instead\")\n  static const WARNING = warningHeader;\n  @Deprecated(\"Use wwwAuthenticateHeader instead\")\n  static const WWW_AUTHENTICATE = wwwAuthenticateHeader;\n\n  // Cookie headers from RFC 6265.\n  static const cookieHeader = \"cookie\";\n  static const setCookieHeader = \"set-cookie\";\n\n  @Deprecated(\"Use cookieHeader instead\")\n  static const COOKIE = cookieHeader;\n  @Deprecated(\"Use setCookieHeader instead\")\n  static const SET_COOKIE = setCookieHeader;\n\n  // TODO(39783): Document this.\n  static const generalHeaders = [\n    cacheControlHeader,\n    connectionHeader,\n    dateHeader,\n    pragmaHeader,\n    trailerHeader,\n    transferEncodingHeader,\n    upgradeHeader,\n    viaHeader,\n    warningHeader\n  ];\n\n  @Deprecated(\"Use generalHeaders instead\")\n  static const GENERAL_HEADERS = generalHeaders;\n\n  static const entityHeaders = [\n    allowHeader,\n    contentEncodingHeader,\n    contentLanguageHeader,\n    contentLengthHeader,\n    contentLocationHeader,\n    contentMD5Header,\n    contentRangeHeader,\n    contentTypeHeader,\n    expiresHeader,\n    lastModifiedHeader\n  ];\n\n  @Deprecated(\"Use entityHeaders instead\")\n  static const ENTITY_HEADERS = entityHeaders;\n\n  static const responseHeaders = [\n    acceptRangesHeader,\n    ageHeader,\n    etagHeader,\n    locationHeader,\n    proxyAuthenticateHeader,\n    retryAfterHeader,\n    serverHeader,\n    varyHeader,\n    wwwAuthenticateHeader\n  ];\n\n  @Deprecated(\"Use responseHeaders instead\")\n  static const RESPONSE_HEADERS = responseHeaders;\n\n  static const requestHeaders = [\n    acceptHeader,\n    acceptCharsetHeader,\n    acceptEncodingHeader,\n    acceptLanguageHeader,\n    authorizationHeader,\n    expectHeader,\n    fromHeader,\n    hostHeader,\n    ifMatchHeader,\n    ifModifiedSinceHeader,\n    ifNoneMatchHeader,\n    ifRangeHeader,\n    ifUnmodifiedSinceHeader,\n    maxForwardsHeader,\n    proxyAuthorizationHeader,\n    rangeHeader,\n    refererHeader,\n    teHeader,\n    userAgentHeader\n  ];\n\n  @Deprecated(\"Use requestHeaders instead\")\n  static const REQUEST_HEADERS = requestHeaders;\n\n  /// The date specified by the [dateHeader] header, if any.\n  DateTime? date;\n\n  /// The date and time specified by the [expiresHeader] header, if any.\n  DateTime? expires;\n\n  /// The date and time specified by the [ifModifiedSinceHeader] header, if any.\n  DateTime? ifModifiedSince;\n\n  /// The value of the [hostHeader] header, if any.\n  String? host;\n\n  /// The value of the port part of the [hostHeader] header, if any.\n  int? port;\n\n  /// The [ContentType] of the [contentTypeHeader] header, if any.\n  ContentType? contentType;\n\n  /// The value of the [contentLengthHeader] header, if any.\n  ///\n  /// The value is negative if there is no content length set.\n  int contentLength = -1;\n\n  /// Whether the connection is persistent (keep-alive).\n  late bool persistentConnection;\n\n  /// Whether the connection uses chunked transfer encoding.\n  ///\n  /// Reflects and modifies the value of the [transferEncodingHeader] header.\n  late bool chunkedTransferEncoding;\n\n  /// The values for the header named [name].\n  ///\n  /// Returns null if there is no header with the provided name,\n  /// otherwise returns a new list containing the current values.\n  /// Not that modifying the list does not change the header.\n  List<String>? operator [](String name);\n\n  /// Convenience method for the value for a single valued header.\n  ///\n  /// The value must not have more than one value.\n  ///\n  /// Returns `null` if there is no header with the provided name.\n  String? value(String name);\n\n  /// Adds a header value.\n  ///\n  /// The header named [name] will have a string value derived from [value]\n  /// added to its list of values.\n  ///\n  /// Some headers are single valued, and for these, adding a value will\n  /// replace a previous value. If the [value] is a [DateTime], an\n  /// HTTP date format will be applied. If the value is an [Iterable],\n  /// each element will be added separately. For all other\n  /// types the default [Object.toString] method will be used.\n  ///\n  /// Header names are converted to lower-case unless\n  /// [preserveHeaderCase] is set to true. If two header names are\n  /// the same when converted to lower-case, they are considered to be\n  /// the same header, with one set of values.\n  ///\n  /// The current case of the a header name is that of the name used by\n  /// the last [set] or [add] call for that header.\n  void add(String name, Object value,\n      {@Since(\"2.8\") bool preserveHeaderCase = false});\n\n  /// Sets the header [name] to [value].\n  ///\n  /// Removes all existing values for the header named [name] and\n  /// then [add]s [value] to it.\n  void set(String name, Object value,\n      {@Since(\"2.8\") bool preserveHeaderCase = false});\n\n  /// Removes a specific value for a header name.\n  ///\n  /// Some headers have system supplied values which cannot be removed.\n  /// For all other headers and values, the [value] is converted to a string\n  /// in the same way as for [add], then that string value is removed from the\n  /// current values of [name].\n  /// If there are no remaining values for [name], the header is no longer\n  /// considered present.\n  void remove(String name, Object value);\n\n  /// Removes all values for the specified header name.\n  ///\n  /// Some headers have system supplied values which cannot be removed.\n  /// All other values for [name] are removed.\n  /// If there are no remaining values for [name], the header is no longer\n  /// considered present.\n  void removeAll(String name);\n\n  /// Performs the [action] on each header.\n  ///\n  /// The [action] function is called with each header's name and a list\n  /// of the header's values. The casing of the name string is determined by\n  /// the last [add] or [set] operation for that particular header,\n  /// which defaults to lower-casing the header name unless explicitly\n  /// set to preserve the case.\n  void forEach(void Function(String name, List<String> values) action);\n\n  /// Disables folding for the header named [name] when sending the HTTP header.\n  ///\n  /// By default, multiple header values are folded into a\n  /// single header line by separating the values with commas.\n  ///\n  /// The 'set-cookie' header has folding disabled by default.\n  void noFolding(String name);\n\n  /// Removes all headers.\n  ///\n  /// Some headers have system supplied values which cannot be removed.\n  /// All other header values are removed, and header names with not\n  /// remaining values are no longer considered present.\n  void clear();\n}\n\n/// Representation of a header value in the form:\n/// ```plaintext\n/// value; parameter1=value1; parameter2=value2\n/// ```\n///\n/// [HeaderValue] can be used to conveniently build and parse header\n/// values on this form.\n///\n/// Parameter values can be omitted, in which case the value is parsed as `null`.\n/// Values can be doubled quoted to allow characters outside of the RFC 7230\n/// token characters and backslash sequences can be used to represent the double\n/// quote and backslash characters themselves.\n///\n/// To build an \"accepts\" header with the value\n///\n///     text/plain; q=0.3, text/html\n///\n/// use code like this:\n///\n///     HttpClientRequest request = ...;\n///     var v = HeaderValue(\"text/plain\", {\"q\": \"0.3\"});\n///     request.headers.add(HttpHeaders.acceptHeader, v);\n///     request.headers.add(HttpHeaders.acceptHeader, \"text/html\");\n///\n/// To parse the header values use the [parse] static method.\n///\n///     HttpRequest request = ...;\n///     List<String> values = request.headers[HttpHeaders.acceptHeader];\n///     values.forEach((value) {\n///       HeaderValue v = HeaderValue.parse(value);\n///       // Use v.value and v.parameters\n///     });\n///\n/// An instance of [HeaderValue] is immutable.\nabstract class HeaderValue {\n  /// Creates a new header value object setting the value and parameters.\n  factory HeaderValue(\n      [String value = \"\", Map<String, String?> parameters = const {}]) {\n    return _HeaderValue(value, parameters);\n  }\n\n  /// Creates a new header value object from parsing a header value\n  /// string with both value and optional parameters.\n  static HeaderValue parse(String value,\n      {String parameterSeparator = \";\",\n      String? valueSeparator,\n      bool preserveBackslash = false}) {\n    return _HeaderValue.parse(value,\n        parameterSeparator: parameterSeparator,\n        valueSeparator: valueSeparator,\n        preserveBackslash: preserveBackslash);\n  }\n\n  /// The value of the header.\n  String get value;\n\n  /// A map of parameters.\n  ///\n  /// This map cannot be modified.\n  Map<String, String?> get parameters;\n\n  /// Returns the formatted string representation in the form:\n  /// ```plaintext\n  /// value; parameter1=value1; parameter2=value2\n  /// ```\n  String toString();\n}\n\n/// The [session][HttpRequest.session] of an [HttpRequest].\nabstract class HttpSession implements Map {\n  /// The id of the current session.\n  String get id;\n\n  /// Destroys the session.\n  ///\n  /// This terminates the session and any further\n  /// connections with this id will be given a new id and session.\n  void destroy();\n\n  /// Sets a callback that will be called when the session is timed out.\n  ///\n  /// Calling this again will overwrite the previous value.\n  void set onTimeout(void Function() callback);\n\n  /// Whether the session has not yet been sent to the client.\n  bool get isNew;\n}\n\n/// A MIME/IANA media type used as the value of the\n/// [HttpHeaders.contentTypeHeader] header.\n///\n/// A [ContentType] is immutable.\nabstract class ContentType implements HeaderValue {\n  /// Content type for plain text using UTF-8 encoding.\n  ///\n  ///     text/plain; charset=utf-8\n  static final text = ContentType(\"text\", \"plain\", charset: \"utf-8\");\n  @Deprecated(\"Use text instead\")\n  static final TEXT = text;\n\n  /// Content type for HTML using UTF-8 encoding.\n  ///\n  ///    text/html; charset=utf-8\n  static final html = ContentType(\"text\", \"html\", charset: \"utf-8\");\n  @Deprecated(\"Use html instead\")\n  static final HTML = html;\n\n  /// Content type for JSON using UTF-8 encoding.\n  ///\n  ///    application/json; charset=utf-8\n  static final json = ContentType(\"application\", \"json\", charset: \"utf-8\");\n  @Deprecated(\"Use json instead\")\n  static final JSON = json;\n\n  /// Content type for binary data.\n  ///\n  ///    application/octet-stream\n  static final binary = ContentType(\"application\", \"octet-stream\");\n  @Deprecated(\"Use binary instead\")\n  static final BINARY = binary;\n\n  /// Creates a new content type object setting the primary type and\n  /// sub type. The charset and additional parameters can also be set\n  /// using [charset] and [parameters]. If charset is passed and\n  /// [parameters] contains charset as well the passed [charset] will\n  /// override the value in parameters. Keys passed in parameters will be\n  /// converted to lower case. The `charset` entry, whether passed as `charset`\n  /// or in `parameters`, will have its value converted to lower-case.\n  factory ContentType(String primaryType, String subType,\n      {String? charset, Map<String, String?> parameters = const {}}) {\n    return _ContentType(primaryType, subType, charset, parameters);\n  }\n\n  /// Creates a new content type object from parsing a Content-Type\n  /// header value. As primary type, sub type and parameter names and\n  /// values are not case sensitive all these values will be converted\n  /// to lower case. Parsing this string\n  ///\n  ///     text/html; charset=utf-8\n  ///\n  /// will create a content type object with primary type \"text\",\n  /// subtype \"html\" and parameter \"charset\" with value \"utf-8\".\n  /// There may be more parameters supplied, but they are not recognized\n  /// by this class.\n  static ContentType parse(String value) {\n    return _ContentType.parse(value);\n  }\n\n  /// Gets the MIME type and subtype, without any parameters.\n  ///\n  /// For the full content type `text/html;charset=utf-8`,\n  /// the [mimeType] value is the string `text/html`.\n  String get mimeType;\n\n  /// Gets the primary type.\n  ///\n  /// For the full content type `text/html;charset=utf-8`,\n  /// the [primaryType] value is the string `text`.\n  String get primaryType;\n\n  /// Gets the subtype.\n  ///\n  /// For the full content type `text/html;charset=utf-8`,\n  /// the [subType] value is the string `html`.\n  /// May be the empty string.\n  String get subType;\n\n  /// Gets the character set, if any.\n  ///\n  /// For the full content type `text/html;charset=utf-8`,\n  /// the [charset] value is the string `utf-8`.\n  String? get charset;\n}\n\n/// Representation of a cookie. For cookies received by the server as Cookie\n/// header values only [name] and [value] properties will be set. When building a\n/// cookie for the 'set-cookie' header in the server and when receiving cookies\n/// in the client as 'set-cookie' headers all fields can be used.\nabstract class Cookie {\n  /// The name of the cookie.\n  ///\n  /// Must be a `token` as specified in RFC 6265.\n  ///\n  /// The allowed characters in a `token` are the visible ASCII characters,\n  /// U+0021 (`!`) through U+007E (`~`), except the separator characters:\n  /// `(`, `)`, `<`, `>`, `@`, `,`, `;`, `:`, `\\`, `\"`, `/`, `[`, `]`, `?`, `=`,\n  /// `{`, and `}`.\n  late String name;\n\n  /// The value of the cookie.\n  ///\n  /// Must be a `cookie-value` as specified in RFC 6265.\n  ///\n  /// The allowed characters in a cookie value are the visible ASCII characters,\n  /// U+0021 (`!`) through U+007E (`~`) except the characters:\n  /// `\"`, `,`, `;` and `\\`.\n  /// Cookie values may be wrapped in a single pair of double quotes\n  /// (U+0022, `\"`).\n  late String value;\n\n  /// The time at which the cookie expires.\n  DateTime? expires;\n\n  /// The number of seconds until the cookie expires. A zero or negative value\n  /// means the cookie has expired.\n  int? maxAge;\n\n  /// The domain that the cookie applies to.\n  String? domain;\n\n  /// The path within the [domain] that the cookie applies to.\n  String? path;\n\n  /// Whether to only send this cookie on secure connections.\n  bool secure = false;\n\n  /// Whether the cookie is only sent in the HTTP request and is not made\n  /// available to client side scripts.\n  bool httpOnly = false;\n\n  /// Creates a new cookie setting the name and value.\n  ///\n  /// [name] and [value] must be composed of valid characters according to RFC\n  /// 6265.\n  ///\n  /// By default the value of `httpOnly` will be set to `true`.\n  factory Cookie(String name, String value) => _Cookie(name, value);\n\n  /// Creates a new cookie by parsing a header value from a 'set-cookie'\n  /// header.\n  factory Cookie.fromSetCookieValue(String value) {\n    return _Cookie.fromSetCookieValue(value);\n  }\n\n  /// Returns the formatted string representation of the cookie. The\n  /// string representation can be used for setting the Cookie or\n  /// 'set-cookie' headers\n  String toString();\n}\n\n/// A server-side object\n/// that contains the content of and information about an HTTP request.\n///\n/// `HttpRequest` objects are generated by an [HttpServer],\n/// which listens for HTTP requests on a specific host and port.\n/// For each request received, the HttpServer, which is a [Stream],\n/// generates an `HttpRequest` object and adds it to the stream.\n///\n/// An `HttpRequest` object delivers the body content of the request\n/// as a stream of byte lists.\n/// The object also contains information about the request,\n/// such as the method, URI, and headers.\n///\n/// In the following code, an HttpServer listens\n/// for HTTP requests. When the server receives a request,\n/// it uses the HttpRequest object's `method` property to dispatch requests.\n///\n///     final HOST = InternetAddress.loopbackIPv4;\n///     final PORT = 80;\n///\n///     HttpServer.bind(HOST, PORT).then((_server) {\n///       _server.listen((HttpRequest request) {\n///         switch (request.method) {\n///           case 'GET':\n///             handleGetRequest(request);\n///             break;\n///           case 'POST':\n///             ...\n///         }\n///       },\n///       onError: handleError);    // listen() failed.\n///     }).catchError(handleError);\n///\n/// An HttpRequest object provides access to the associated [HttpResponse]\n/// object through the response property.\n/// The server writes its response to the body of the HttpResponse object.\n/// For example, here's a function that responds to a request:\n///\n///     void handleGetRequest(HttpRequest req) {\n///       HttpResponse res = req.response;\n///       res.write('Received request ${req.method}: ${req.uri.path}');\n///       res.close();\n///     }\nabstract class HttpRequest implements Stream<Uint8List> {\n  /// The content length of the request body.\n  ///\n  /// If the size of the request body is not known in advance,\n  /// this value is -1.\n  int get contentLength;\n\n  /// The method, such as 'GET' or 'POST', for the request.\n  String get method;\n\n  /// The URI for the request.\n  ///\n  /// This provides access to the\n  /// path and query string for the request.\n  Uri get uri;\n\n  /// The requested URI for the request.\n  ///\n  /// The returned URI is reconstructed by using http-header fields, to access\n  /// otherwise lost information, e.g. host and scheme.\n  ///\n  /// To reconstruct the scheme, first 'X-Forwarded-Proto' is checked, and then\n  /// falling back to server type.\n  ///\n  /// To reconstruct the host, first 'X-Forwarded-Host' is checked, then 'Host'\n  /// and finally calling back to server.\n  Uri get requestedUri;\n\n  /// The request headers.\n  ///\n  /// The returned [HttpHeaders] are immutable.\n  HttpHeaders get headers;\n\n  /// The cookies in the request, from the \"Cookie\" headers.\n  List<Cookie> get cookies;\n\n  /// The persistent connection state signaled by the client.\n  bool get persistentConnection;\n\n  /// The client certificate of the client making the request.\n  ///\n  /// This value is null if the connection is not a secure TLS or SSL connection,\n  /// or if the server does not request a client certificate, or if the client\n  /// does not provide one.\n  X509Certificate? get certificate;\n\n  /// The session for the given request.\n  ///\n  /// If the session is being initialized by this call,\n  /// [HttpSession.isNew] is true for the returned session.\n  /// See [HttpServer.sessionTimeout] on how to change default timeout.\n  HttpSession get session;\n\n  /// The HTTP protocol version used in the request,\n  /// either \"1.0\" or \"1.1\".\n  String get protocolVersion;\n\n  /// Information about the client connection.\n  ///\n  /// Returns `null` if the socket is not available.\n  HttpConnectionInfo? get connectionInfo;\n\n  /// The [HttpResponse] object, used for sending back the response to the\n  /// client.\n  ///\n  /// If the [contentLength] of the body isn't 0, and the body isn't being read,\n  /// any write calls on the [HttpResponse] automatically drain the request\n  /// body.\n  HttpResponse get response;\n}\n\n/// An HTTP response, which returns the headers and data\n/// from the server to the client in response to an HTTP request.\n///\n/// Every HttpRequest object provides access to the associated [HttpResponse]\n/// object through the `response` property.\n/// The server sends its response to the client by writing to the\n/// HttpResponse object.\n///\n/// ## Writing the response\n///\n/// This class implements [IOSink].\n/// After the header has been set up, the methods\n/// from IOSink, such as `writeln()`, can be used to write\n/// the body of the HTTP response.\n/// Use the `close()` method to close the response and send it to the client.\n///\n///     server.listen((HttpRequest request) {\n///       request.response.write('Hello, world!');\n///       request.response.close();\n///     });\n///\n/// When one of the IOSink methods is used for the\n/// first time, the request header is sent. Calling any methods that\n/// change the header after it is sent throws an exception.\n///\n/// ## Setting the headers\n///\n/// The HttpResponse object has a number of properties for setting up\n/// the HTTP headers of the response.\n/// When writing string data through the IOSink, the encoding used\n/// is determined from the \"charset\" parameter of the\n/// \"Content-Type\" header.\n///\n///     HttpResponse response = ...\n///     response.headers.contentType\n///         = ContentType(\"application\", \"json\", charset: \"utf-8\");\n///     response.write(...);  // Strings written will be UTF-8 encoded.\n///\n/// If no charset is provided the default of ISO-8859-1 (Latin 1) will\n/// be used.\n///\n///     HttpResponse response = ...\n///     response.headers.add(HttpHeaders.contentTypeHeader, \"text/plain\");\n///     response.write(...);  // Strings written will be ISO-8859-1 encoded.\n///\n/// An exception is thrown if you use the `write()` method\n/// while an unsupported content-type is set.\nabstract class HttpResponse implements IOSink {\n  // TODO(ajohnsen): Add documentation of how to pipe a file to the response.\n  /// Gets and sets the content length of the response. If the size of\n  /// the response is not known in advance set the content length to\n  /// -1, which is also the default if not set.\n  int contentLength = -1;\n\n  /// The status code of the response.\n  ///\n  /// Any integer value is accepted. For\n  /// the official HTTP status codes use the fields from\n  /// [HttpStatus]. If no status code is explicitly set the default\n  /// value [HttpStatus.ok] is used.\n  ///\n  /// The status code must be set before the body is written\n  /// to. Setting the status code after writing to the response body or\n  /// closing the response will throw a `StateError`.\n  int statusCode = HttpStatus.ok;\n\n  /// The reason phrase for the response.\n  ///\n  /// If no reason phrase is explicitly set, a default reason phrase is provided.\n  ///\n  /// The reason phrase must be set before the body is written\n  /// to. Setting the reason phrase after writing to the response body\n  /// or closing the response will throw a [StateError].\n  late String reasonPhrase;\n\n  /// Gets and sets the persistent connection state. The initial value\n  /// of this property is the persistent connection state from the\n  /// request.\n  late bool persistentConnection;\n\n  /// Set and get the [deadline] for the response. The deadline is timed from the\n  /// time it's set. Setting a new deadline will override any previous deadline.\n  /// When a deadline is exceeded, the response will be closed and any further\n  /// data ignored.\n  ///\n  /// To disable a deadline, set the [deadline] to `null`.\n  ///\n  /// The [deadline] is `null` by default.\n  Duration? deadline;\n\n  /// Gets or sets if the [HttpResponse] should buffer output.\n  ///\n  /// Default value is `true`.\n  ///\n  /// __Note__: Disabling buffering of the output can result in very poor\n  /// performance, when writing many small chunks.\n  bool bufferOutput = true;\n\n  /// Returns the response headers.\n  ///\n  /// The response headers can be modified until the response body is\n  /// written to or closed. After that they become immutable.\n  HttpHeaders get headers;\n\n  /// Cookies to set in the client (in the 'set-cookie' header).\n  List<Cookie> get cookies;\n\n  /// Respond with a redirect to [location].\n  ///\n  /// The URI in [location] should be absolute, but there are no checks\n  /// to enforce that.\n  ///\n  /// By default the HTTP status code `HttpStatus.movedTemporarily`\n  /// (`302`) is used for the redirect, but an alternative one can be\n  /// specified using the [status] argument.\n  ///\n  /// This method will also call `close`, and the returned future is\n  /// the future returned by `close`.\n  Future redirect(Uri location, {int status = HttpStatus.movedTemporarily});\n\n  /// Detaches the underlying socket from the HTTP server. When the\n  /// socket is detached the HTTP server will no longer perform any\n  /// operations on it.\n  ///\n  /// This is normally used when a HTTP upgrade request is received\n  /// and the communication should continue with a different protocol.\n  ///\n  /// If [writeHeaders] is `true`, the status line and [headers] will be written\n  /// to the socket before it's detached. If `false`, the socket is detached\n  /// immediately, without any data written to the socket. Default is `true`.\n  Future<Socket> detachSocket({bool writeHeaders = true});\n\n  /// Gets information about the client connection. Returns `null` if the\n  /// socket is not available.\n  HttpConnectionInfo? get connectionInfo;\n}\n\n/// An HTTP client for communicating with an HTTP server.\n///\n/// Sends HTTP requests to an HTTP server and receives responses.\n/// Maintains state, including session cookies and other cookies,\n/// between multiple requests to the same server.\n///\n/// Note: [HttpClient] provides low-level HTTP functionality.\n/// We recommend users start with more developer-friendly and composable APIs\n/// found in [`package:http`](https://pub.dev/packages/http).\n///\n/// HttpClient contains a number of methods to send an [HttpClientRequest]\n/// to an Http server and receive an [HttpClientResponse] back.\n/// For example, you can use the [get], [getUrl], [post], and [postUrl] methods\n/// for GET and POST requests, respectively.\n///\n/// ## Making a simple GET request: an example\n///\n/// A `getUrl` request is a two-step process, triggered by two [Future]s.\n/// When the first future completes with a [HttpClientRequest], the underlying\n/// network connection has been established, but no data has been sent.\n/// In the callback function for the first future, the HTTP headers and body\n/// can be set on the request. Either the first write to the request object\n/// or a call to [close] sends the request to the server.\n///\n/// When the HTTP response is received from the server,\n/// the second future, which is returned by close,\n/// completes with an [HttpClientResponse] object.\n/// This object provides access to the headers and body of the response.\n/// The body is available as a stream implemented by `HttpClientResponse`.\n/// If a body is present, it must be read. Otherwise, it leads to resource\n/// leaks. Consider using [HttpClientResponse.drain] if the body is unused.\n///\n/// ```dart import:convert\n/// var client = HttpClient();\n/// try {\n///   HttpClientRequest request = await client.get('localhost', 80, '/file.txt');\n///   // Optionally set up headers...\n///   // Optionally write to the request object...\n///   HttpClientResponse response = await request.close();\n///   // Process the response\n///   final stringData = await response.transform(utf8.decoder).join();\n///   print(stringData);\n/// } finally {\n///   client.close();\n/// }\n/// ```\n///\n/// The future for [HttpClientRequest] is created by methods such as\n/// [getUrl] and [open].\n///\n/// ## HTTPS connections\n///\n/// An `HttpClient` can make HTTPS requests, connecting to a server using\n/// the TLS (SSL) secure networking protocol. Calling [getUrl] with an\n/// https: scheme will work automatically, if the server's certificate is\n/// signed by a root CA (certificate authority) on the default list of\n/// well-known trusted CAs, compiled by Mozilla.\n///\n/// To add a custom trusted certificate authority, or to send a client\n/// certificate to servers that request one, pass a [SecurityContext] object\n/// as the optional `context` argument to the `HttpClient` constructor.\n/// The desired security options can be set on the [SecurityContext] object.\n///\n/// ## Headers\n///\n/// All `HttpClient` requests set the following header by default:\n///\n///     Accept-Encoding: gzip\n///\n/// This allows the HTTP server to use gzip compression for the body if\n/// possible. If this behavior is not desired set the\n/// `Accept-Encoding` header to something else.\n/// To turn off gzip compression of the response, clear this header:\n///\n///      request.headers.removeAll(HttpHeaders.acceptEncodingHeader)\n///\n/// ## Closing the `HttpClient`\n///\n/// `HttpClient` supports persistent connections and caches network\n/// connections to reuse them for multiple requests whenever\n/// possible. This means that network connections can be kept open for\n/// some time after a request has completed. Use [HttpClient.close]\n/// to force the `HttpClient` object to shut down and to close the idle\n/// network connections.\n///\n/// ## Turning proxies on and off\n///\n/// By default the `HttpClient` uses the proxy configuration available\n/// from the environment, see [findProxyFromEnvironment]. To turn off\n/// the use of proxies set the [findProxy] property to `null`.\n///\n///     HttpClient client = HttpClient();\n///     client.findProxy = null;\nabstract class HttpClient {\n  static const int defaultHttpPort = 80;\n  @Deprecated(\"Use defaultHttpPort instead\")\n  static const int DEFAULT_HTTP_PORT = defaultHttpPort;\n\n  static const int defaultHttpsPort = 443;\n  @Deprecated(\"Use defaultHttpsPort instead\")\n  static const int DEFAULT_HTTPS_PORT = defaultHttpsPort;\n\n  /// Enable logging of HTTP requests from all [HttpClient]s to the developer\n  /// timeline.\n  ///\n  /// Default is `false`.\n  static set enableTimelineLogging(bool value) {\n    final enabled = valueOfNonNullableParamWithDefault<bool>(value, false);\n    if (enabled != _enableTimelineLogging) {\n      postEvent('HttpTimelineLoggingStateChange', {\n        'isolateId': Service.getIsolateID(Isolate.current),\n        'enabled': enabled,\n      });\n    }\n    _enableTimelineLogging = enabled;\n  }\n\n  /// Current state of HTTP request logging from all [HttpClient]s to the\n  /// developer timeline.\n  ///\n  /// Default is `false`.\n  static bool get enableTimelineLogging => _enableTimelineLogging;\n\n  static bool _enableTimelineLogging = false;\n\n  /// Gets and sets the idle timeout of non-active persistent (keep-alive)\n  /// connections.\n  ///\n  /// The default value is 15 seconds.\n  Duration idleTimeout = const Duration(seconds: 15);\n\n  /// Gets and sets the connection timeout.\n  ///\n  /// When connecting to a new host exceeds this timeout, a [SocketException]\n  /// is thrown. The timeout applies only to connections initiated after the\n  /// timeout is set.\n  ///\n  /// When this is `null`, the OS default timeout is used. The default is\n  /// `null`.\n  Duration? connectionTimeout;\n\n  /// Gets and sets the maximum number of live connections, to a single host.\n  ///\n  /// Increasing this number may lower performance and take up unwanted\n  /// system resources.\n  ///\n  /// To disable, set to `null`.\n  ///\n  /// Default is `null`.\n  int? maxConnectionsPerHost;\n\n  /// Gets and sets whether the body of a response will be automatically\n  /// uncompressed.\n  ///\n  /// The body of an HTTP response can be compressed. In most\n  /// situations providing the un-compressed body is most\n  /// convenient. Therefore the default behavior is to un-compress the\n  /// body. However in some situations (e.g. implementing a transparent\n  /// proxy) keeping the uncompressed stream is required.\n  ///\n  /// NOTE: Headers in the response are never modified. This means\n  /// that when automatic un-compression is turned on the value of the\n  /// header `Content-Length` will reflect the length of the original\n  /// compressed body. Likewise the header `Content-Encoding` will also\n  /// have the original value indicating compression.\n  ///\n  /// NOTE: Automatic un-compression is only performed if the\n  /// `Content-Encoding` header value is `gzip`.\n  ///\n  /// This value affects all responses produced by this client after the\n  /// value is changed.\n  ///\n  /// To disable, set to `false`.\n  ///\n  /// Default is `true`.\n  bool autoUncompress = true;\n\n  /// Gets and sets the default value of the `User-Agent` header for all requests\n  /// generated by this [HttpClient].\n  ///\n  /// The default value is `Dart/<version> (dart:io)`.\n  ///\n  /// If the userAgent is set to `null`, no default `User-Agent` header will be\n  /// added to each request.\n  String? userAgent;\n\n  factory HttpClient({SecurityContext? context}) {\n    HttpOverrides? overrides = HttpOverrides.current;\n    if (overrides == null) {\n      return _HttpClient(context);\n    }\n    return overrides.createHttpClient(context);\n  }\n\n  /// Opens a HTTP connection.\n  ///\n  /// The HTTP method to use is specified in [method], the server is\n  /// specified using [host] and [port], and the path (including\n  /// a possible query) is specified using [path].\n  /// The path may also contain a URI fragment, which will be ignored.\n  ///\n  /// The `Host` header for the request will be set to the value [host]:[port]\n  /// (if [host] is an IP address, it will still be used in the `Host` header).\n  /// This can be overridden through the [HttpClientRequest] interface before\n  /// the request is sent.\n  ///\n  /// For additional information on the sequence of events during an\n  /// HTTP transaction, and the objects returned by the futures, see\n  /// the overall documentation for the class [HttpClient].\n  Future<HttpClientRequest> open(\n      String method, String host, int port, String path);\n\n  /// Opens a HTTP connection.\n  ///\n  /// The HTTP method is specified in [method] and the URL to use in\n  /// [url].\n  ///\n  /// The `Host` header for the request will be set to the value\n  /// [Uri.host]:[Uri.port] from [url] (if `url.host` is an IP address, it will\n  /// still be used in the `Host` header). This can be overridden through the\n  /// [HttpClientRequest] interface before the request is sent.\n  ///\n  /// For additional information on the sequence of events during an\n  /// HTTP transaction, and the objects returned by the futures, see\n  /// the overall documentation for the class [HttpClient].\n  Future<HttpClientRequest> openUrl(String method, Uri url);\n\n  /// Opens a HTTP connection using the GET method.\n  ///\n  /// The server is specified using [host] and [port], and the path\n  /// (including a possible query) is specified using\n  /// [path].\n  ///\n  /// See [open] for details.\n  Future<HttpClientRequest> get(String host, int port, String path);\n\n  /// Opens a HTTP connection using the GET method.\n  ///\n  /// The URL to use is specified in [url].\n  ///\n  /// See [openUrl] for details.\n  Future<HttpClientRequest> getUrl(Uri url);\n\n  /// Opens a HTTP connection using the POST method.\n  ///\n  /// The server is specified using [host] and [port], and the path\n  /// (including a possible query) is specified using\n  /// [path].\n  ///\n  /// See [open] for details.\n  Future<HttpClientRequest> post(String host, int port, String path);\n\n  /// Opens a HTTP connection using the POST method.\n  ///\n  /// The URL to use is specified in [url].\n  ///\n  /// See [openUrl] for details.\n  Future<HttpClientRequest> postUrl(Uri url);\n\n  /// Opens a HTTP connection using the PUT method.\n  ///\n  /// The server is specified using [host] and [port], and the path\n  /// (including a possible query) is specified using [path].\n  ///\n  /// See [open] for details.\n  Future<HttpClientRequest> put(String host, int port, String path);\n\n  /// Opens a HTTP connection using the PUT method.\n  ///\n  /// The URL to use is specified in [url].\n  ///\n  /// See [openUrl] for details.\n  Future<HttpClientRequest> putUrl(Uri url);\n\n  /// Opens a HTTP connection using the DELETE method.\n  ///\n  /// The server is specified using [host] and [port], and the path\n  /// (including a possible query) is specified using [path].\n  ///\n  /// See [open] for details.\n  Future<HttpClientRequest> delete(String host, int port, String path);\n\n  /// Opens a HTTP connection using the DELETE method.\n  ///\n  /// The URL to use is specified in [url].\n  ///\n  /// See [openUrl] for details.\n  Future<HttpClientRequest> deleteUrl(Uri url);\n\n  /// Opens a HTTP connection using the PATCH method.\n  ///\n  /// The server is specified using [host] and [port], and the path\n  /// (including a possible query) is specified using [path].\n  ///\n  /// See [open] for details.\n  Future<HttpClientRequest> patch(String host, int port, String path);\n\n  /// Opens a HTTP connection using the PATCH method.\n  ///\n  /// The URL to use is specified in [url].\n  ///\n  /// See [openUrl] for details.\n  Future<HttpClientRequest> patchUrl(Uri url);\n\n  /// Opens a HTTP connection using the HEAD method.\n  ///\n  /// The server is specified using [host] and [port], and the path\n  /// (including a possible query) is specified using [path].\n  ///\n  /// See [open] for details.\n  Future<HttpClientRequest> head(String host, int port, String path);\n\n  /// Opens a HTTP connection using the HEAD method.\n  ///\n  /// The URL to use is specified in [url].\n  ///\n  /// See [openUrl] for details.\n  Future<HttpClientRequest> headUrl(Uri url);\n\n  /// Sets the function to be called when a site is requesting\n  /// authentication.\n  ///\n  /// The URL requested, the authentication scheme and the security realm\n  /// from the server are passed in the arguments [f.url], [f.scheme] and\n  /// [f.realm].\n  ///\n  /// The function returns a [Future] which should complete when the\n  /// authentication has been resolved. If credentials cannot be\n  /// provided the [Future] should complete with `false`. If\n  /// credentials are available the function should add these using\n  /// [addCredentials] before completing the [Future] with the value\n  /// `true`.\n  ///\n  /// If the [Future] completes with `true` the request will be retried\n  /// using the updated credentials, however, the retried request will not\n  /// carry the original request payload. Otherwise response processing will\n  /// continue normally.\n  ///\n  /// If it is known that the remote server requires authentication for all\n  /// requests, it is advisable to use [addCredentials] directly, or manually\n  /// set the `'authorization'` header on the request to avoid the overhead\n  /// of a failed request, or issues due to missing request payload on retried\n  /// request.\n  void set authenticate(\n      Future<bool> Function(Uri url, String scheme, String? realm)? f);\n\n  /// Add credentials to be used for authorizing HTTP requests.\n  void addCredentials(Uri url, String realm, HttpClientCredentials credentials);\n\n  /// Sets the function used to resolve the proxy server to be used for\n  /// opening a HTTP connection to the specified [url]. If this\n  /// function is not set, direct connections will always be used.\n  ///\n  /// The string returned by [f] must be in the format used by browser\n  /// PAC (proxy auto-config) scripts. That is either\n  ///\n  ///     \"DIRECT\"\n  ///\n  /// for using a direct connection or\n  ///\n  ///     \"PROXY host:port\"\n  ///\n  /// for using the proxy server `host` on port `port`.\n  ///\n  /// A configuration can contain several configuration elements\n  /// separated by semicolons, e.g.\n  ///\n  ///     \"PROXY host:port; PROXY host2:port2; DIRECT\"\n  ///\n  /// The static function [findProxyFromEnvironment] on this class can\n  /// be used to implement proxy server resolving based on environment\n  /// variables.\n  void set findProxy(String Function(Uri url)? f);\n\n  /// Function for resolving the proxy server to be used for a HTTP\n  /// connection from the proxy configuration specified through\n  /// environment variables.\n  ///\n  /// The following environment variables are taken into account:\n  ///\n  ///     http_proxy\n  ///     https_proxy\n  ///     no_proxy\n  ///     HTTP_PROXY\n  ///     HTTPS_PROXY\n  ///     NO_PROXY\n  ///\n  /// [:http_proxy:] and [:HTTP_PROXY:] specify the proxy server to use for\n  /// http:// urls. Use the format [:hostname:port:]. If no port is used a\n  /// default of 1080 will be used. If both are set the lower case one takes\n  /// precedence.\n  ///\n  /// [:https_proxy:] and [:HTTPS_PROXY:] specify the proxy server to use for\n  /// https:// urls. Use the format [:hostname:port:]. If no port is used a\n  /// default of 1080 will be used. If both are set the lower case one takes\n  /// precedence.\n  ///\n  /// [:no_proxy:] and [:NO_PROXY:] specify a comma separated list of\n  /// postfixes of hostnames for which not to use the proxy\n  /// server. E.g. the value \"localhost,127.0.0.1\" will make requests\n  /// to both \"localhost\" and \"127.0.0.1\" not use a proxy. If both are set\n  /// the lower case one takes precedence.\n  ///\n  /// To activate this way of resolving proxies assign this function to\n  /// the [findProxy] property on the [HttpClient].\n  ///\n  ///     HttpClient client = HttpClient();\n  ///     client.findProxy = HttpClient.findProxyFromEnvironment;\n  ///\n  /// If you don't want to use the system environment you can use a\n  /// different one by wrapping the function.\n  ///\n  ///     HttpClient client = HttpClient();\n  ///     client.findProxy = (url) {\n  ///       return HttpClient.findProxyFromEnvironment(\n  ///           url, environment: {\"http_proxy\": ..., \"no_proxy\": ...});\n  ///     }\n  ///\n  /// If a proxy requires authentication it is possible to configure\n  /// the username and password as well. Use the format\n  /// [:username:password@hostname:port:] to include the username and\n  /// password. Alternatively the API [addProxyCredentials] can be used\n  /// to set credentials for proxies which require authentication.\n  static String findProxyFromEnvironment(Uri url,\n      {Map<String, String>? environment}) {\n    HttpOverrides? overrides = HttpOverrides.current;\n    if (overrides == null) {\n      return _HttpClient._findProxyFromEnvironment(url, environment);\n    }\n    return overrides.findProxyFromEnvironment(url, environment);\n  }\n\n  /// Sets the function to be called when a proxy is requesting\n  /// authentication.\n  ///\n  /// Information on the proxy in use, the authentication scheme\n  /// and the security realm for the authentication\n  /// are passed in the arguments [f.host], [f.port], [f.scheme] and [f.realm].\n  ///\n  /// The function returns a [Future] which should complete when the\n  /// authentication has been resolved. If credentials cannot be\n  /// provided the [Future] should complete with `false`. If\n  /// credentials are available the function should add these using\n  /// [addProxyCredentials] before completing the [Future] with the value\n  /// `true`.\n  ///\n  /// If the [Future] completes with `true` the request will be retried\n  /// using the updated credentials. Otherwise response processing will\n  /// continue normally.\n  void set authenticateProxy(\n      Future<bool> Function(\n              String host, int port, String scheme, String? realm)?\n          f);\n\n  /// Add credentials to be used for authorizing HTTP proxies.\n  void addProxyCredentials(\n      String host, int port, String realm, HttpClientCredentials credentials);\n\n  /// Sets a callback that will decide whether to accept a secure connection\n  /// with a server certificate that cannot be authenticated by any of our\n  /// trusted root certificates.\n  ///\n  /// When an secure HTTP request if made, using this HttpClient, and the\n  /// server returns a server certificate that cannot be authenticated, the\n  /// callback is called asynchronously with the [X509Certificate] object and\n  /// the server's hostname and port.  If the value of [badCertificateCallback]\n  /// is `null`, the bad certificate is rejected, as if the callback\n  /// returned `false`\n  ///\n  /// If the callback returns true, the secure connection is accepted and the\n  /// `Future<HttpClientRequest>` that was returned from the call making the\n  /// request completes with a valid HttpRequest object. If the callback returns\n  /// false, the `Future<HttpClientRequest>` completes with an exception.\n  ///\n  /// If a bad certificate is received on a connection attempt, the library calls\n  /// the function that was the value of badCertificateCallback at the time\n  /// the request is made, even if the value of badCertificateCallback\n  /// has changed since then.\n  void set badCertificateCallback(\n      bool Function(X509Certificate cert, String host, int port)? callback);\n\n  /// Shuts down the HTTP client.\n  ///\n  /// If [force] is `false` (the default) the [HttpClient] will be kept alive\n  /// until all active connections are done. If [force] is `true` any active\n  /// connections will be closed to immediately release all resources. These\n  /// closed connections will receive an error event to indicate that the client\n  /// was shut down. In both cases trying to establish a new connection after\n  /// calling [close] will throw an exception.\n  void close({bool force = false});\n}\n\n/// HTTP request for a client connection.\n///\n/// To set up a request, set the headers using the headers property\n/// provided in this class and write the data to the body of the request.\n/// `HttpClientRequest` is an [IOSink]. Use the methods from IOSink,\n/// such as `writeCharCode()`, to write the body of the HTTP\n/// request. When one of the IOSink methods is used for the first\n/// time, the request header is sent. Calling any methods that\n/// change the header after it is sent throws an exception.\n///\n/// When writing string data through the [IOSink] the\n/// encoding used is determined from the \"charset\" parameter of\n/// the \"Content-Type\" header.\n///\n/// ```dart import:convert\n/// var client = HttpClient();\n/// HttpClientRequest request = await client.get('localhost', 80, '/file.txt');\n/// request.headers.contentType =\n///     ContentType('application', 'json', charset: 'utf-8');\n/// request.write('text content\ud83d\udc4d\ud83c\udfaf'); // Strings written will be UTF-8 encoded.\n/// ```\n///\n/// If no charset is provided the default of ISO-8859-1 (Latin 1) is used.\n///\n/// ```dart\n/// var client = HttpClient();\n/// HttpClientRequest request = await client.get('localhost', 80, '/file.txt');\n/// request.headers.add(HttpHeaders.contentTypeHeader, \"text/plain\");\n/// request.write('bl\u00e5b\u00e6rgr\u00f8d'); // Strings written will be ISO-8859-1 encoded\n/// ```\n///\n/// An exception is thrown if you use an unsupported encoding and the\n/// `write()` method being used takes a string parameter.\nabstract class HttpClientRequest implements IOSink {\n  /// The requested persistent connection state.\n  ///\n  /// The default value is `true`.\n  bool persistentConnection = true;\n\n  /// Whether to follow redirects automatically.\n  ///\n  /// Set this property to `false` if this request should not\n  /// automatically follow redirects. The default is `true`.\n  ///\n  /// Automatic redirect will only happen for \"GET\" and \"HEAD\" requests\n  /// and only for the status codes [HttpStatus.movedPermanently]\n  /// (301), [HttpStatus.found] (302),\n  /// [HttpStatus.movedTemporarily] (302, alias for\n  /// [HttpStatus.found]), [HttpStatus.seeOther] (303),\n  /// [HttpStatus.temporaryRedirect] (307) and\n  /// [HttpStatus.permanentRedirect] (308). For\n  /// [HttpStatus.seeOther] (303) automatic redirect will also happen\n  /// for \"POST\" requests with the method changed to \"GET\" when\n  /// following the redirect.\n  ///\n  /// All headers added to the request will be added to the redirection\n  /// request(s) except when forwarding sensitive headers like\n  /// \"Authorization\", \"WWW-Authenticate\", and \"Cookie\". Those headers\n  /// will be skipped if following a redirect to a domain that is not a\n  /// subdomain match or exact match of the initial domain.\n  /// For example, a redirect from \"foo.com\" to either \"foo.com\" or\n  /// \"sub.foo.com\" will forward the sensitive headers, but a redirect to\n  /// \"bar.com\" will not.\n  ///\n  /// Any body send with the request will not be part of the redirection\n  /// request(s).\n  ///\n  /// For precise control of redirect handling, set this property to `false`\n  /// and make a separate HTTP request to process the redirect. For example:\n  ///\n  /// ```dart\n  /// final client = HttpClient();\n  /// var uri = Uri.parse(\"http://localhost/\");\n  /// var request = await client.getUrl(uri);\n  /// request.followRedirects = false;\n  /// var response = await request.close();\n  /// while (response.isRedirect) {\n  ///   response.drain();\n  ///   final location = response.headers.value(HttpHeaders.locationHeader);\n  ///   if (location != null) {\n  ///     uri = uri.resolve(location);\n  ///     request = await client.getUrl(uri);\n  ///     // Set the body or headers as desired.\n  ///     request.followRedirects = false;\n  ///     response = await request.close();\n  ///   }\n  /// }\n  /// // Do something with the final response.\n  /// ```\n  bool followRedirects = true;\n\n  /// Set this property to the maximum number of redirects to follow\n  /// when [followRedirects] is `true`. If this number is exceeded\n  /// an error event will be added with a [RedirectException].\n  ///\n  /// The default value is 5.\n  int maxRedirects = 5;\n\n  /// The method of the request.\n  String get method;\n\n  /// The uri of the request.\n  Uri get uri;\n\n  /// Gets and sets the content length of the request.\n  ///\n  /// If the size of the request is not known in advance set content length to\n  /// -1, which is also the default.\n  int contentLength = -1;\n\n  /// Gets or sets if the [HttpClientRequest] should buffer output.\n  ///\n  /// Default value is `true`.\n  ///\n  /// __Note__: Disabling buffering of the output can result in very poor\n  /// performance, when writing many small chunks.\n  bool bufferOutput = true;\n\n  /// Returns the client request headers.\n  ///\n  /// The client request headers can be modified until the client\n  /// request body is written to or closed. After that they become\n  /// immutable.\n  HttpHeaders get headers;\n\n  /// Cookies to present to the server (in the 'cookie' header).\n  List<Cookie> get cookies;\n\n  /// A [HttpClientResponse] future that will complete once the response is\n  /// available.\n  ///\n  /// If an error occurs before the response is available, this future will\n  /// complete with an error.\n  Future<HttpClientResponse> get done;\n\n  /// Close the request for input. Returns the value of [done].\n  Future<HttpClientResponse> close();\n\n  /// Gets information about the client connection.\n  ///\n  /// Returns `null` if the socket is not available.\n  HttpConnectionInfo? get connectionInfo;\n\n  /// Aborts the client connection.\n  ///\n  /// If the connection has not yet completed, the request is aborted and the\n  /// [done] future (also returned by [close]) is completed with the provided\n  /// [exception] and [stackTrace].\n  /// If [exception] is omitted, it defaults to an [HttpException], and if\n  /// [stackTrace] is omitted, it defaults to [StackTrace.empty].\n  ///\n  /// If the [done] future has already completed, aborting has no effect.\n  ///\n  /// Using the [IOSink] methods (e.g., [write] and [add]) has no effect after\n  /// the request has been aborted\n  ///\n  /// ```dart import:async\n  /// var client = HttpClient();\n  /// HttpClientRequest request = await client.get('localhost', 80, '/file.txt');\n  /// request.write('request content');\n  /// Timer(Duration(seconds: 1), () {\n  ///   request.abort();\n  /// });\n  /// request.close().then((response) {\n  ///   // If response comes back before abort, this callback will be called.\n  /// }, onError: (e) {\n  ///   // If abort() called before response is available, onError will fire.\n  /// });\n  /// ```\n  @Since(\"2.10\")\n  void abort([Object? exception, StackTrace? stackTrace]);\n}\n\n/// HTTP response for a client connection.\n///\n/// The body of a [HttpClientResponse] object is a [Stream] of data from the\n/// server. Use [Stream] methods like [`transform`][Stream.transform] and\n/// [`join`][Stream.join] to access the data.\n///\n/// ```dart import:convert\n/// var client = HttpClient();\n/// try {\n///   HttpClientRequest request = await client.get('localhost', 80, '/file.txt');\n///   HttpClientResponse response = await request.close();\n///   final stringData = await response.transform(utf8.decoder).join();\n///   print(stringData);\n/// } finally {\n///   client.close();\n/// }\n/// ```\nabstract class HttpClientResponse implements Stream<List<int>> {\n  /// Returns the status code.\n  ///\n  /// The status code must be set before the body is written\n  /// to. Setting the status code after writing to the body will throw\n  /// a `StateError`.\n  int get statusCode;\n\n  /// Returns the reason phrase associated with the status code.\n  ///\n  /// The reason phrase must be set before the body is written\n  /// to. Setting the reason phrase after writing to the body will throw\n  /// a `StateError`.\n  String get reasonPhrase;\n\n  /// Returns the content length of the response body. Returns -1 if the size of\n  /// the response body is not known in advance.\n  ///\n  /// If the content length needs to be set, it must be set before the\n  /// body is written to. Setting the content length after writing to the body\n  /// will throw a `StateError`.\n  int get contentLength;\n\n  /// The compression state of the response.\n  ///\n  /// This specifies whether the response bytes were compressed when they were\n  /// received across the wire and whether callers will receive compressed\n  /// or uncompressed bytes when they listed to this response's byte stream.\n  @Since(\"2.4\")\n  HttpClientResponseCompressionState get compressionState;\n\n  /// Gets the persistent connection state returned by the server.\n  ///\n  /// If the persistent connection state needs to be set, it must be\n  /// set before the body is written to. Setting the persistent connection state\n  /// after writing to the body will throw a `StateError`.\n  bool get persistentConnection;\n\n  /// Returns whether the status code is one of the normal redirect\n  /// codes [HttpStatus.movedPermanently], [HttpStatus.found],\n  /// [HttpStatus.movedTemporarily], [HttpStatus.seeOther] and\n  /// [HttpStatus.temporaryRedirect].\n  bool get isRedirect;\n\n  /// Returns the series of redirects this connection has been through. The\n  /// list will be empty if no redirects were followed. [redirects] will be\n  /// updated both in the case of an automatic and a manual redirect.\n  List<RedirectInfo> get redirects;\n\n  /// Redirects this connection to a new URL. The default value for\n  /// [method] is the method for the current request. The default value\n  /// for [url] is the value of the [HttpHeaders.locationHeader] header of\n  /// the current response. All body data must have been read from the\n  /// current response before calling [redirect].\n  ///\n  /// All headers added to the request will be added to the redirection\n  /// request. However, any body sent with the request will not be\n  /// part of the redirection request.\n  ///\n  /// If [followLoops] is set to `true`, redirect will follow the redirect,\n  /// even if the URL was already visited. The default value is `false`.\n  ///\n  /// The method will ignore [HttpClientRequest.maxRedirects]\n  /// and will always perform the redirect.\n  Future<HttpClientResponse> redirect(\n      [String? method, Uri? url, bool? followLoops]);\n\n  /// Returns the client response headers.\n  ///\n  /// The client response headers are immutable.\n  HttpHeaders get headers;\n\n  /// Detach the underlying socket from the HTTP client. When the\n  /// socket is detached the HTTP client will no longer perform any\n  /// operations on it.\n  ///\n  /// This is normally used when a HTTP upgrade is negotiated and the\n  /// communication should continue with a different protocol.\n  Future<Socket> detachSocket();\n\n  /// Cookies set by the server (from the 'set-cookie' header).\n  List<Cookie> get cookies;\n\n  /// Returns the certificate of the HTTPS server providing the response.\n  /// Returns null if the connection is not a secure TLS or SSL connection.\n  X509Certificate? get certificate;\n\n  /// Gets information about the client connection. Returns `null` if the socket\n  /// is not available.\n  HttpConnectionInfo? get connectionInfo;\n}\n\n/// Enum that specifies the compression state of the byte stream of an\n/// [HttpClientResponse].\n///\n/// The values herein allow callers to answer the following questions as they\n/// pertain to an [HttpClientResponse]:\n///\n///  * Can the value of the response's `Content-Length` HTTP header be trusted?\n///  * Does the caller need to manually decompress the response's byte stream?\n///\n/// This enum is accessed via the [HttpClientResponse.compressionState] value.\n@Since(\"2.4\")\nenum HttpClientResponseCompressionState {\n  /// The body of the HTTP response was received and remains in an uncompressed\n  /// state.\n  ///\n  /// In this state, the value of the `Content-Length` HTTP header, if\n  /// specified (non-negative), should match the number of bytes produced by\n  /// the response's byte stream.\n  notCompressed,\n\n  /// The body of the HTTP response was originally compressed, but by virtue of\n  /// the [HttpClient.autoUncompress] configuration option, it has been\n  /// automatically uncompressed.\n  ///\n  /// HTTP headers are not modified, so when a response has been uncompressed\n  /// in this way, the value of the `Content-Length` HTTP header cannot be\n  /// trusted, as it will contain the compressed content length, whereas the\n  /// stream of bytes produced by the response will contain uncompressed bytes.\n  decompressed,\n\n  /// The body of the HTTP response contains compressed bytes.\n  ///\n  /// In this state, the value of the `Content-Length` HTTP header, if\n  /// specified (non-negative), should match the number of bytes produced by\n  /// the response's byte stream.\n  ///\n  /// If the caller wishes to manually uncompress the body of the response,\n  /// it should consult the value of the `Content-Encoding` HTTP header to see\n  /// what type of compression has been applied. See\n  /// <https://tools.ietf.org/html/rfc2616#section-14.11> for more information.\n  compressed,\n}\n\nabstract class HttpClientCredentials {}\n\n/// Represents credentials for basic authentication.\nabstract class HttpClientBasicCredentials extends HttpClientCredentials {\n  factory HttpClientBasicCredentials(String username, String password) =>\n      _HttpClientBasicCredentials(username, password);\n}\n\n/// Represents credentials for digest authentication. Digest\n/// authentication is only supported for servers using the MD5\n/// algorithm and quality of protection (qop) of either \"none\" or\n/// \"auth\".\nabstract class HttpClientDigestCredentials extends HttpClientCredentials {\n  factory HttpClientDigestCredentials(String username, String password) =>\n      _HttpClientDigestCredentials(username, password);\n}\n\n/// Information about an [HttpRequest], [HttpResponse], [HttpClientRequest], or\n/// [HttpClientResponse] connection.\nabstract class HttpConnectionInfo {\n  InternetAddress get remoteAddress;\n  int get remotePort;\n  int get localPort;\n}\n\n/// Redirect information.\nabstract class RedirectInfo {\n  /// Returns the status code used for the redirect.\n  int get statusCode;\n\n  /// Returns the method used for the redirect.\n  String get method;\n\n  /// Returns the location for the redirect.\n  Uri get location;\n}\n\nclass HttpException implements IOException {\n  final String message;\n  final Uri? uri;\n\n  const HttpException(this.message, {this.uri});\n\n  String toString() {\n    var b = StringBuffer()\n      ..write('HttpException: ')\n      ..write(message);\n    var uri = this.uri;\n    if (uri != null) {\n      b.write(', uri = $uri');\n    }\n    return b.toString();\n  }\n}\n\nclass RedirectException implements HttpException {\n  final String message;\n  final List<RedirectInfo> redirects;\n\n  const RedirectException(this.message, this.redirects);\n\n  String toString() => \"RedirectException: $message\";\n\n  Uri get uri => redirects.last.location;\n}\n", "// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart._http;\n\nabstract class HttpProfiler {\n  static const _kType = 'HttpProfile';\n\n  static final Map<int, _HttpProfileData> _profile = {};\n\n  static _HttpProfileData startRequest(\n    String method,\n    Uri uri, {\n    _HttpProfileData? parentRequest,\n  }) {\n    final data = _HttpProfileData(method, uri, parentRequest?._timeline);\n    _profile[data.id] = data;\n    return data;\n  }\n\n  static _HttpProfileData? getHttpProfileRequest(int id) => _profile[id];\n\n  static void clear() => _profile.clear();\n\n  static String toJson(int? updatedSince) {\n    return json.encode({\n      'type': _kType,\n      'timestamp': Timeline.now,\n      'requests': [\n        for (final request in _profile.values.where(\n          (e) {\n            return (updatedSince == null) || e.lastUpdateTime >= updatedSince;\n          },\n        ))\n          request.toJson(),\n      ],\n    });\n  }\n}\n\nclass _HttpProfileEvent {\n  _HttpProfileEvent(this.name, this.arguments);\n  final int timestamp = Timeline.now;\n  final String name;\n  final Map? arguments;\n\n  Map<String, dynamic> toJson() {\n    return <String, dynamic>{\n      'timestamp': timestamp,\n      'event': name,\n      if (arguments != null) 'arguments': arguments,\n    };\n  }\n}\n\nclass _HttpProfileData {\n  _HttpProfileData(String method, this.uri, TimelineTask? parent)\n      : method = method.toUpperCase(),\n        _timeline = TimelineTask(\n          filterKey: 'HTTP/client',\n          parent: parent,\n        ) {\n    // Grab the ID from the timeline event so HTTP profile IDs can be matched\n    // to the timeline.\n    id = _timeline.pass();\n    requestInProgress = true;\n    requestStartTimestamp = Timeline.now;\n    _timeline.start('HTTP CLIENT $method', arguments: {\n      'method': method.toUpperCase(),\n      'uri': uri.toString(),\n    });\n    _updated();\n  }\n\n  void requestEvent(String name, {Map? arguments}) {\n    _timeline.instant(name, arguments: arguments);\n    requestEvents.add(_HttpProfileEvent(name, arguments));\n    _updated();\n  }\n\n  void proxyEvent(_Proxy proxy) {\n    proxyDetails = {\n      if (proxy.host != null) 'host': proxy.host,\n      if (proxy.port != null) 'port': proxy.port,\n      if (proxy.username != null) 'username': proxy.username,\n    };\n    _timeline.instant('Establishing proxy tunnel', arguments: {\n      'proxyDetails': proxyDetails,\n    });\n    _updated();\n  }\n\n  void appendRequestData(Uint8List data) {\n    requestBody.addAll(data);\n    _updated();\n  }\n\n  Map formatHeaders(HttpHeaders headers) {\n    final newHeaders = <String, List<String>>{};\n    headers.forEach((name, values) {\n      newHeaders[name] = values;\n    });\n    return newHeaders;\n  }\n\n  Map? formatConnectionInfo(HttpConnectionInfo? connectionInfo) =>\n      connectionInfo == null\n          ? null\n          : {\n              'localPort': connectionInfo.localPort,\n              'remoteAddress': connectionInfo.remoteAddress.address,\n              'remotePort': connectionInfo.remotePort,\n            };\n\n  void finishRequest({\n    required HttpClientRequest request,\n  }) {\n    // TODO(bkonyi): include encoding?\n    requestInProgress = false;\n    requestEndTimestamp = Timeline.now;\n    requestDetails = <String, dynamic>{\n      // TODO(bkonyi): consider exposing certificate information?\n      // 'certificate': response.certificate,\n      'headers': formatHeaders(request.headers),\n      'connectionInfo': formatConnectionInfo(request.connectionInfo),\n      'contentLength': request.contentLength,\n      'cookies': [\n        for (final cookie in request.cookies) cookie.toString(),\n      ],\n      'followRedirects': request.followRedirects,\n      'maxRedirects': request.maxRedirects,\n      'method': request.method,\n      'persistentConnection': request.persistentConnection,\n      'uri': request.uri.toString(),\n    };\n    _timeline.finish(\n      arguments: requestDetails,\n    );\n    _updated();\n  }\n\n  void startResponse({required HttpClientResponse response}) {\n    List<Map<String, dynamic>> formatRedirectInfo() {\n      final redirects = <Map<String, dynamic>>[];\n      for (final redirect in response.redirects) {\n        redirects.add({\n          'location': redirect.location.toString(),\n          'method': redirect.method,\n          'statusCode': redirect.statusCode,\n        });\n      }\n      return redirects;\n    }\n\n    responseDetails = <String, dynamic>{\n      'headers': formatHeaders(response.headers),\n      'compressionState': response.compressionState.toString(),\n      'connectionInfo': formatConnectionInfo(response.connectionInfo),\n      'contentLength': response.contentLength,\n      'cookies': [\n        for (final cookie in response.cookies) cookie.toString(),\n      ],\n      'isRedirect': response.isRedirect,\n      'persistentConnection': response.persistentConnection,\n      'reasonPhrase': response.reasonPhrase,\n      'redirects': formatRedirectInfo(),\n      'statusCode': response.statusCode,\n    };\n\n    assert(!requestInProgress);\n    responseInProgress = true;\n    _responseTimeline = TimelineTask(\n      parent: _timeline,\n      filterKey: 'HTTP/client',\n    );\n\n    responseStartTimestamp = Timeline.now;\n    _responseTimeline.start(\n      'HTTP CLIENT response of $method',\n      arguments: {\n        'requestUri': uri.toString(),\n        ...responseDetails!,\n      },\n    );\n    _updated();\n  }\n\n  void finishRequestWithError(String error) {\n    requestInProgress = false;\n    requestEndTimestamp = Timeline.now;\n    requestError = error;\n    _timeline.finish(arguments: {\n      'error': error,\n    });\n    _updated();\n  }\n\n  void finishResponse() {\n    responseInProgress = false;\n    responseEndTimestamp = Timeline.now;\n    requestEvent('Content Download');\n    _responseTimeline.finish();\n    _updated();\n  }\n\n  void finishResponseWithError(String error) {\n    // Return if finishResponseWithError has already been called. Can happen if\n    // the response stream is listened to with `cancelOnError: false`.\n    if (!responseInProgress!) return;\n    responseInProgress = false;\n    responseEndTimestamp = Timeline.now;\n    responseError = error;\n    _responseTimeline.finish(arguments: {\n      'error': error,\n    });\n    _updated();\n  }\n\n  void appendResponseData(Uint8List data) {\n    responseBody.addAll(data);\n    _updated();\n  }\n\n  Map<String, dynamic> toJson({bool ref = true}) {\n    return <String, dynamic>{\n      'type': '${ref ? '@' : ''}HttpProfileRequest',\n      'id': id,\n      'isolateId': isolateId,\n      'method': method,\n      'uri': uri.toString(),\n      'startTime': requestStartTimestamp,\n      if (!requestInProgress) 'endTime': requestEndTimestamp,\n      if (!requestInProgress)\n        'request': {\n          'events': <Map<String, dynamic>>[\n            for (final event in requestEvents) event.toJson(),\n          ],\n          if (proxyDetails != null) 'proxyDetails': proxyDetails!,\n          if (requestDetails != null) ...requestDetails!,\n          if (requestError != null) 'error': requestError,\n        },\n      if (responseInProgress != null)\n        'response': <String, dynamic>{\n          'startTime': responseStartTimestamp,\n          ...responseDetails!,\n          if (!responseInProgress!) 'endTime': responseEndTimestamp,\n          if (responseError != null) 'error': responseError,\n        },\n      if (!ref) ...{\n        if (!requestInProgress) 'requestBody': requestBody,\n        if (responseInProgress != null) 'responseBody': responseBody,\n      }\n    };\n  }\n\n  void _updated() => _lastUpdateTime = Timeline.now;\n\n  static final String isolateId = Service.getIsolateID(Isolate.current)!;\n\n  bool requestInProgress = true;\n  bool? responseInProgress;\n\n  late final int id;\n  final String method;\n  final Uri uri;\n\n  late final int requestStartTimestamp;\n  late final int requestEndTimestamp;\n  Map<String, dynamic>? requestDetails;\n  Map<String, dynamic>? proxyDetails;\n  final requestBody = <int>[];\n  String? requestError;\n  final requestEvents = <_HttpProfileEvent>[];\n\n  late final int responseStartTimestamp;\n  late final int responseEndTimestamp;\n  Map<String, dynamic>? responseDetails;\n  final responseBody = <int>[];\n  String? responseError;\n\n  int get lastUpdateTime => _lastUpdateTime;\n  int _lastUpdateTime = 0;\n\n  final TimelineTask _timeline;\n  late TimelineTask _responseTimeline;\n}\n\nint _nextServiceId = 1;\n\n// TODO(ajohnsen): Use other way of getting a unique id.\nabstract class _ServiceObject {\n  int __serviceId = 0;\n  int get _serviceId {\n    if (__serviceId == 0) __serviceId = _nextServiceId++;\n    return __serviceId;\n  }\n\n  Map _toJSON(bool ref);\n\n  String get _servicePath => \"$_serviceTypePath/$_serviceId\";\n\n  String get _serviceTypePath;\n\n  String get _serviceTypeName;\n\n  String _serviceType(bool ref) {\n    if (ref) return \"@$_serviceTypeName\";\n    return _serviceTypeName;\n  }\n}\n\nclass _CopyingBytesBuilder implements BytesBuilder {\n  // Start with 1024 bytes.\n  static const int _INIT_SIZE = 1024;\n\n  static final _emptyList = Uint8List(0);\n\n  int _length = 0;\n  Uint8List _buffer;\n\n  _CopyingBytesBuilder([int initialCapacity = 0])\n      : _buffer = (initialCapacity <= 0)\n            ? _emptyList\n            : Uint8List(_pow2roundup(initialCapacity));\n\n  void add(List<int> bytes) {\n    int bytesLength = bytes.length;\n    if (bytesLength == 0) return;\n    int required = _length + bytesLength;\n    if (_buffer.length < required) {\n      _grow(required);\n    }\n    assert(_buffer.length >= required);\n    if (bytes is Uint8List) {\n      _buffer.setRange(_length, required, bytes);\n    } else {\n      for (int i = 0; i < bytesLength; i++) {\n        _buffer[_length + i] = bytes[i];\n      }\n    }\n    _length = required;\n  }\n\n  void addByte(int byte) {\n    if (_buffer.length == _length) {\n      // The grow algorithm always at least doubles.\n      // If we added one to _length it would quadruple unnecessarily.\n      _grow(_length);\n    }\n    assert(_buffer.length > _length);\n    _buffer[_length] = byte;\n    _length++;\n  }\n\n  void _grow(int required) {\n    // We will create a list in the range of 2-4 times larger than\n    // required.\n    int newSize = required * 2;\n    if (newSize < _INIT_SIZE) {\n      newSize = _INIT_SIZE;\n    } else {\n      newSize = _pow2roundup(newSize);\n    }\n    var newBuffer = Uint8List(newSize);\n    newBuffer.setRange(0, _buffer.length, _buffer);\n    _buffer = newBuffer;\n  }\n\n  Uint8List takeBytes() {\n    if (_length == 0) return _emptyList;\n    var buffer = Uint8List.view(_buffer.buffer, _buffer.offsetInBytes, _length);\n    clear();\n    return buffer;\n  }\n\n  Uint8List toBytes() {\n    if (_length == 0) return _emptyList;\n    return Uint8List.fromList(\n        Uint8List.view(_buffer.buffer, _buffer.offsetInBytes, _length));\n  }\n\n  int get length => _length;\n\n  bool get isEmpty => _length == 0;\n\n  bool get isNotEmpty => _length != 0;\n\n  void clear() {\n    _length = 0;\n    _buffer = _emptyList;\n  }\n\n  static int _pow2roundup(int x) {\n    assert(x > 0);\n    --x;\n    x |= x >> 1;\n    x |= x >> 2;\n    x |= x >> 4;\n    x |= x >> 8;\n    x |= x >> 16;\n    return x + 1;\n  }\n}\n\nconst int _OUTGOING_BUFFER_SIZE = 8 * 1024;\n\ntypedef _BytesConsumer = void Function(List<int> bytes);\n\nclass _HttpIncoming extends Stream<Uint8List> {\n  final int _transferLength;\n  final _dataCompleter = Completer<bool>();\n  final Stream<Uint8List> _stream;\n\n  bool fullBodyRead = false;\n\n  // Common properties.\n  final _HttpHeaders headers;\n  bool upgraded = false;\n\n  // ClientResponse properties.\n  int? statusCode;\n  String? reasonPhrase;\n\n  // Request properties.\n  String? method;\n  Uri? uri;\n\n  bool hasSubscriber = false;\n\n  // The transfer length if the length of the message body as it\n  // appears in the message (RFC 2616 section 4.4). This can be -1 if\n  // the length of the massage body is not known due to transfer\n  // codings.\n  int get transferLength => _transferLength;\n\n  _HttpIncoming(this.headers, this._transferLength, this._stream);\n\n  StreamSubscription<Uint8List> listen(void Function(Uint8List event)? onData,\n      {Function? onError, void Function()? onDone, bool? cancelOnError}) {\n    hasSubscriber = true;\n    return _stream.handleError((error) {\n      throw HttpException(error.message, uri: uri);\n    }).listen(onData,\n        onError: onError, onDone: onDone, cancelOnError: cancelOnError);\n  }\n\n  // Is completed once all data have been received.\n  Future<bool> get dataDone => _dataCompleter.future;\n\n  void close(bool closing) {\n    fullBodyRead = true;\n    hasSubscriber = true;\n    _dataCompleter.complete(closing);\n  }\n}\n\nabstract class _HttpInboundMessageListInt extends Stream<List<int>> {\n  final _HttpIncoming _incoming;\n  List<Cookie>? _cookies;\n\n  _HttpInboundMessageListInt(this._incoming);\n\n  List<Cookie> get cookies => _cookies ??= headers._parseCookies();\n\n  _HttpHeaders get headers => _incoming.headers;\n  String get protocolVersion => headers.protocolVersion;\n  int get contentLength => headers.contentLength;\n  bool get persistentConnection => headers.persistentConnection;\n}\n\nabstract class _HttpInboundMessage extends Stream<Uint8List> {\n  final _HttpIncoming _incoming;\n  List<Cookie>? _cookies;\n\n  _HttpInboundMessage(this._incoming);\n\n  List<Cookie> get cookies => _cookies ??= headers._parseCookies();\n\n  _HttpHeaders get headers => _incoming.headers;\n  String get protocolVersion => headers.protocolVersion;\n  int get contentLength => headers.contentLength;\n  bool get persistentConnection => headers.persistentConnection;\n}\n\nclass _HttpRequest extends _HttpInboundMessage implements HttpRequest {\n  final HttpResponse response;\n\n  final _HttpServer _httpServer;\n\n  final _HttpConnection _httpConnection;\n\n  _HttpSession? _session;\n\n  Uri? _requestedUri;\n\n  _HttpRequest(this.response, _HttpIncoming _incoming, this._httpServer,\n      this._httpConnection)\n      : super(_incoming) {\n    if (headers.protocolVersion == \"1.1\") {\n      response.headers\n        ..chunkedTransferEncoding = true\n        ..persistentConnection = headers.persistentConnection;\n    }\n\n    if (_httpServer._sessionManagerInstance != null) {\n      // Map to session if exists.\n      var sessionIds = cookies\n          .where((cookie) => cookie.name.toUpperCase() == _DART_SESSION_ID)\n          .map<String>((cookie) => cookie.value);\n      for (var sessionId in sessionIds) {\n        var session = _httpServer._sessionManager.getSession(sessionId);\n        _session = session;\n        if (session != null) {\n          session._markSeen();\n          break;\n        }\n      }\n    }\n  }\n\n  StreamSubscription<Uint8List> listen(void Function(Uint8List event)? onData,\n      {Function? onError, void Function()? onDone, bool? cancelOnError}) {\n    return _incoming.listen(onData,\n        onError: onError, onDone: onDone, cancelOnError: cancelOnError);\n  }\n\n  Uri get uri => _incoming.uri!;\n\n  Uri get requestedUri {\n    var requestedUri = _requestedUri;\n    if (requestedUri != null) return requestedUri;\n    var proto = headers['x-forwarded-proto'];\n    var scheme = proto != null\n        ? proto.first\n        : _httpConnection._socket is SecureSocket\n            ? \"https\"\n            : \"http\";\n    var hostList = headers['x-forwarded-host'];\n    String host;\n    if (hostList != null) {\n      host = hostList.first;\n    } else {\n      hostList = headers[HttpHeaders.hostHeader];\n      if (hostList != null) {\n        host = hostList.first;\n      } else {\n        host = \"${_httpServer.address.host}:${_httpServer.port}\";\n      }\n    }\n    return _requestedUri = Uri.parse(\"$scheme://$host$uri\");\n  }\n\n  String get method => _incoming.method!;\n\n  HttpSession get session {\n    var session = _session;\n    if (session != null && !session._destroyed) {\n      return session;\n    }\n    // Create session, store it in connection, and return.\n    return _session = _httpServer._sessionManager.createSession();\n  }\n\n  HttpConnectionInfo? get connectionInfo => _httpConnection.connectionInfo;\n\n  X509Certificate? get certificate {\n    var socket = _httpConnection._socket;\n    if (socket is SecureSocket) return socket.peerCertificate;\n    return null;\n  }\n}\n\nclass _HttpClientResponse extends _HttpInboundMessageListInt\n    implements HttpClientResponse {\n  List<RedirectInfo> get redirects => _httpRequest._responseRedirects;\n\n  // The HttpClient this response belongs to.\n  final _HttpClient _httpClient;\n\n  // The HttpClientRequest of this response.\n  final _HttpClientRequest _httpRequest;\n\n  // The compression state of this response.\n  final HttpClientResponseCompressionState compressionState;\n\n  final _HttpProfileData? _profileData;\n\n  _HttpClientResponse(_HttpIncoming _incoming, this._httpRequest,\n      this._httpClient, this._profileData)\n      : compressionState = _getCompressionState(_httpClient, _incoming.headers),\n        super(_incoming) {\n    // Set uri for potential exceptions.\n    _incoming.uri = _httpRequest.uri;\n  }\n\n  static HttpClientResponseCompressionState _getCompressionState(\n      _HttpClient httpClient, _HttpHeaders headers) {\n    if (headers.value(HttpHeaders.contentEncodingHeader) == \"gzip\") {\n      return httpClient.autoUncompress\n          ? HttpClientResponseCompressionState.decompressed\n          : HttpClientResponseCompressionState.compressed;\n    } else {\n      return HttpClientResponseCompressionState.notCompressed;\n    }\n  }\n\n  int get statusCode => _incoming.statusCode!;\n  String get reasonPhrase => _incoming.reasonPhrase!;\n\n  X509Certificate? get certificate {\n    var socket = _httpRequest._httpClientConnection._socket;\n    if (socket is SecureSocket) return socket.peerCertificate;\n    return null;\n  }\n\n  List<Cookie> get cookies {\n    var cookies = _cookies;\n    if (cookies != null) return cookies;\n    cookies = <Cookie>[];\n    List<String>? values = headers[HttpHeaders.setCookieHeader];\n    if (values != null) {\n      for (var value in values) {\n        cookies.add(Cookie.fromSetCookieValue(value));\n      }\n    }\n    _cookies = cookies;\n    return cookies;\n  }\n\n  bool get isRedirect {\n    if (_httpRequest.method == \"GET\" || _httpRequest.method == \"HEAD\") {\n      return statusCode == HttpStatus.movedPermanently ||\n          statusCode == HttpStatus.permanentRedirect ||\n          statusCode == HttpStatus.found ||\n          statusCode == HttpStatus.seeOther ||\n          statusCode == HttpStatus.temporaryRedirect;\n    } else if (_httpRequest.method == \"POST\") {\n      return statusCode == HttpStatus.seeOther;\n    }\n    return false;\n  }\n\n  Future<HttpClientResponse> redirect(\n      [String? method, Uri? url, bool? followLoops]) {\n    if (method == null) {\n      // Set method as defined by RFC 2616 section 10.3.4.\n      if (statusCode == HttpStatus.seeOther && _httpRequest.method == \"POST\") {\n        method = \"GET\";\n      } else {\n        method = _httpRequest.method;\n      }\n    }\n    if (url == null) {\n      String? location = headers.value(HttpHeaders.locationHeader);\n      if (location == null) {\n        throw StateError(\"Response has no Location header for redirect\");\n      }\n      url = Uri.parse(location);\n    }\n    if (followLoops != true) {\n      for (var redirect in redirects) {\n        if (redirect.location == url) {\n          return Future.error(\n              RedirectException(\"Redirect loop detected\", redirects));\n        }\n      }\n    }\n    return _httpClient\n        ._openUrlFromRequest(method, url, _httpRequest, isRedirect: true)\n        .then((request) {\n      request._responseRedirects\n        ..addAll(redirects)\n        ..add(_RedirectInfo(statusCode, method!, url!));\n      return request.close();\n    });\n  }\n\n  StreamSubscription<Uint8List> listen(void Function(Uint8List event)? onData,\n      {Function? onError, void Function()? onDone, bool? cancelOnError}) {\n    if (_incoming.upgraded) {\n      _profileData?.finishResponseWithError('Connection was upgraded');\n      // If upgraded, the connection is already 'removed' form the client.\n      // Since listening to upgraded data is 'bogus', simply close and\n      // return empty stream subscription.\n      _httpRequest._httpClientConnection.destroy();\n      return Stream<Uint8List>.empty().listen(null, onDone: onDone);\n    }\n    Stream<Uint8List> stream = _incoming;\n    if (compressionState == HttpClientResponseCompressionState.decompressed) {\n      stream = stream\n          .cast<List<int>>()\n          .transform(gzip.decoder)\n          .transform(const _ToUint8List());\n    }\n    if (_profileData != null) {\n      // If _timeline is not set up, don't add unnecessary map() to the stream.\n      stream = stream.map((data) {\n        _profileData?.appendResponseData(data);\n        return data;\n      });\n    }\n    return stream.listen(onData, onError: (e, st) {\n      _profileData?.finishResponseWithError(e.toString());\n      if (onError == null) {\n        return;\n      }\n      if (onError is void Function(Object, StackTrace)) {\n        onError(e, st);\n      } else {\n        assert(onError is void Function(Object));\n        onError(e);\n      }\n    }, onDone: () {\n      _profileData?.finishResponse();\n      if (onDone != null) {\n        onDone();\n      }\n    }, cancelOnError: cancelOnError);\n  }\n\n  Future<Socket> detachSocket() {\n    _profileData?.finishResponseWithError('Socket has been detached');\n    _httpClient._connectionClosed(_httpRequest._httpClientConnection);\n    return _httpRequest._httpClientConnection.detachSocket();\n  }\n\n  HttpConnectionInfo? get connectionInfo => _httpRequest.connectionInfo;\n\n  bool get _shouldAuthenticateProxy {\n    // Only try to authenticate if there is a challenge in the response.\n    List<String>? challenge = headers[HttpHeaders.proxyAuthenticateHeader];\n    return statusCode == HttpStatus.proxyAuthenticationRequired &&\n        challenge != null &&\n        challenge.length == 1;\n  }\n\n  bool get _shouldAuthenticate {\n    // Only try to authenticate if there is a challenge in the response.\n    List<String>? challenge = headers[HttpHeaders.wwwAuthenticateHeader];\n    return statusCode == HttpStatus.unauthorized &&\n        challenge != null &&\n        challenge.length == 1;\n  }\n\n  Future<HttpClientResponse> _authenticate(bool proxyAuth) {\n    _httpRequest._profileData?.requestEvent('Authentication');\n    Future<HttpClientResponse> retry() {\n      _httpRequest._profileData?.requestEvent('Retrying');\n      // Drain body and retry.\n      return drain().then((_) {\n        return _httpClient\n            ._openUrlFromRequest(\n                _httpRequest.method, _httpRequest.uri, _httpRequest,\n                isRedirect: false)\n            .then((request) => request.close());\n      });\n    }\n\n    List<String>? authChallenge() {\n      return proxyAuth\n          ? headers[HttpHeaders.proxyAuthenticateHeader]\n          : headers[HttpHeaders.wwwAuthenticateHeader];\n    }\n\n    _Credentials? findCredentials(_AuthenticationScheme scheme) {\n      return proxyAuth\n          ? _httpClient._findProxyCredentials(_httpRequest._proxy, scheme)\n          : _httpClient._findCredentials(_httpRequest.uri, scheme);\n    }\n\n    void removeCredentials(_Credentials cr) {\n      if (proxyAuth) {\n        _httpClient._removeProxyCredentials(cr);\n      } else {\n        _httpClient._removeCredentials(cr);\n      }\n    }\n\n    Future<bool> requestAuthentication(\n        _AuthenticationScheme scheme, String? realm) {\n      if (proxyAuth) {\n        var authenticateProxy = _httpClient._authenticateProxy;\n        if (authenticateProxy == null) {\n          return Future.value(false);\n        }\n        var proxy = _httpRequest._proxy;\n        if (!proxy.isDirect) {\n          return authenticateProxy(\n              proxy.host!, proxy.port!, scheme.toString(), realm);\n        }\n      }\n      var authenticate = _httpClient._authenticate;\n      if (authenticate == null) {\n        return Future.value(false);\n      }\n      return authenticate(_httpRequest.uri, scheme.toString(), realm);\n    }\n\n    List<String> challenge = authChallenge()!;\n    assert(challenge.length == 1);\n    _HeaderValue header =\n        _HeaderValue.parse(challenge[0], parameterSeparator: \",\");\n    _AuthenticationScheme scheme =\n        _AuthenticationScheme.fromString(header.value);\n    String? realm = header.parameters[\"realm\"];\n\n    // See if any matching credentials are available.\n    var cr = findCredentials(scheme);\n    if (cr != null) {\n      // For basic authentication don't retry already used credentials\n      // as they must have already been added to the request causing\n      // this authenticate response.\n      if (cr.scheme == _AuthenticationScheme.BASIC && !cr.used) {\n        // Credentials were found, prepare for retrying the request.\n        return retry();\n      }\n\n      // Digest authentication only supports the MD5 algorithm.\n      if (cr.scheme == _AuthenticationScheme.DIGEST) {\n        var algorithm = header.parameters[\"algorithm\"];\n        if (algorithm == null || algorithm.toLowerCase() == \"md5\") {\n          var nonce = cr.nonce;\n          if (nonce == null || nonce == header.parameters[\"nonce\"]) {\n            // If the nonce is not set then this is the first authenticate\n            // response for these credentials. Set up authentication state.\n            if (nonce == null) {\n              cr\n                ..nonce = header.parameters[\"nonce\"]\n                ..algorithm = \"MD5\"\n                ..qop = header.parameters[\"qop\"]\n                ..nonceCount = 0;\n            }\n            // Credentials were found, prepare for retrying the request.\n            return retry();\n          } else {\n            var staleHeader = header.parameters[\"stale\"];\n            if (staleHeader != null && staleHeader.toLowerCase() == \"true\") {\n              // If stale is true retry with new nonce.\n              cr.nonce = header.parameters[\"nonce\"];\n              // Credentials were found, prepare for retrying the request.\n              return retry();\n            }\n          }\n        }\n      }\n    }\n\n    // Ask for more credentials if none found or the one found has\n    // already been used. If it has already been used it must now be\n    // invalid and is removed.\n    if (cr != null) {\n      removeCredentials(cr);\n      cr = null;\n    }\n    return requestAuthentication(scheme, realm).then((credsAvailable) {\n      if (credsAvailable) {\n        cr = _httpClient._findCredentials(_httpRequest.uri, scheme);\n        return retry();\n      } else {\n        // No credentials available, complete with original response.\n        return this;\n      }\n    });\n  }\n}\n\nclass _ToUint8List extends Converter<List<int>, Uint8List> {\n  const _ToUint8List();\n\n  Uint8List convert(List<int> input) => Uint8List.fromList(input);\n\n  Sink<List<int>> startChunkedConversion(Sink<Uint8List> sink) {\n    return _Uint8ListConversionSink(sink);\n  }\n}\n\nclass _Uint8ListConversionSink implements Sink<List<int>> {\n  const _Uint8ListConversionSink(this._target);\n\n  final Sink<Uint8List> _target;\n\n  void add(List<int> data) {\n    _target.add(Uint8List.fromList(data));\n  }\n\n  void close() {\n    _target.close();\n  }\n}\n\nclass _StreamSinkImpl<T> implements StreamSink<T> {\n  final StreamConsumer<T> _target;\n  final _doneCompleter = Completer<void>();\n  StreamController<T>? _controllerInstance;\n  Completer? _controllerCompleter;\n  bool _isClosed = false;\n  bool _isBound = false;\n  bool _hasError = false;\n\n  _StreamSinkImpl(this._target);\n\n  void add(T data) {\n    if (_isClosed) {\n      throw StateError(\"StreamSink is closed\");\n    }\n    _controller.add(data);\n  }\n\n  void addError(Object error, [StackTrace? stackTrace]) {\n    if (_isClosed) {\n      throw StateError(\"StreamSink is closed\");\n    }\n    _controller.addError(error, stackTrace);\n  }\n\n  Future addStream(Stream<T> stream) {\n    if (_isBound) {\n      throw StateError(\"StreamSink is already bound to a stream\");\n    }\n    _isBound = true;\n    if (_hasError) return done;\n    // Wait for any sync operations to complete.\n    Future targetAddStream() {\n      return _target.addStream(stream).whenComplete(() {\n        _isBound = false;\n      });\n    }\n\n    var controller = _controllerInstance;\n    if (controller == null) return targetAddStream();\n    var future = _controllerCompleter!.future;\n    controller.close();\n    return future.then((_) => targetAddStream());\n  }\n\n  Future flush() {\n    if (_isBound) {\n      throw StateError(\"StreamSink is bound to a stream\");\n    }\n    var controller = _controllerInstance;\n    if (controller == null) return Future.value(this);\n    // Adding an empty stream-controller will return a future that will complete\n    // when all data is done.\n    _isBound = true;\n    var future = _controllerCompleter!.future;\n    controller.close();\n    return future.whenComplete(() {\n      _isBound = false;\n    });\n  }\n\n  Future close() {\n    if (_isBound) {\n      throw StateError(\"StreamSink is bound to a stream\");\n    }\n    if (!_isClosed) {\n      _isClosed = true;\n      var controller = _controllerInstance;\n      if (controller != null) {\n        controller.close();\n      } else {\n        _closeTarget();\n      }\n    }\n    return done;\n  }\n\n  void _closeTarget() {\n    _target.close().then(_completeDoneValue, onError: _completeDoneError);\n  }\n\n  Future get done => _doneCompleter.future;\n\n  void _completeDoneValue(value) {\n    if (!_doneCompleter.isCompleted) {\n      _doneCompleter.complete(value);\n    }\n  }\n\n  void _completeDoneError(Object error, StackTrace stackTrace) {\n    if (!_doneCompleter.isCompleted) {\n      _hasError = true;\n      _doneCompleter.completeError(error, stackTrace);\n    }\n  }\n\n  StreamController<T> get _controller {\n    if (_isBound) {\n      throw StateError(\"StreamSink is bound to a stream\");\n    }\n    if (_isClosed) {\n      throw StateError(\"StreamSink is closed\");\n    }\n    if (_controllerInstance == null) {\n      _controllerInstance = StreamController<T>(sync: true);\n      _controllerCompleter = Completer();\n      _target.addStream(_controller.stream).then((_) {\n        if (_isBound) {\n          // A new stream takes over - forward values to that stream.\n          _controllerCompleter!.complete(this);\n          _controllerCompleter = null;\n          _controllerInstance = null;\n        } else {\n          // No new stream, .close was called. Close _target.\n          _closeTarget();\n        }\n      }, onError: (Object error, StackTrace stackTrace) {\n        if (_isBound) {\n          // A new stream takes over - forward errors to that stream.\n          _controllerCompleter!.completeError(error, stackTrace);\n          _controllerCompleter = null;\n          _controllerInstance = null;\n        } else {\n          // No new stream. No need to close target, as it has already\n          // failed.\n          _completeDoneError(error, stackTrace);\n        }\n      });\n    }\n    return _controllerInstance!;\n  }\n}\n\nclass _IOSinkImpl extends _StreamSinkImpl<List<int>> implements IOSink {\n  Encoding _encoding;\n  bool _encodingMutable = true;\n\n  final _HttpProfileData? _profileData;\n  _IOSinkImpl(\n      StreamConsumer<List<int>> target, this._encoding, this._profileData)\n      : super(target);\n\n  Encoding get encoding => _encoding;\n\n  void set encoding(Encoding value) {\n    if (!_encodingMutable) {\n      throw StateError(\"IOSink encoding is not mutable\");\n    }\n    _encoding = value;\n  }\n\n  void write(Object? obj) {\n    String string = '$obj';\n    if (string.isEmpty) return;\n    _profileData?.appendRequestData(\n      Uint8List.fromList(\n        utf8.encode(string),\n      ),\n    );\n    super.add(_encoding.encode(string));\n  }\n\n  void writeAll(Iterable objects, [String separator = \"\"]) {\n    Iterator iterator = objects.iterator;\n    if (!iterator.moveNext()) return;\n    if (separator.isEmpty) {\n      do {\n        write(iterator.current);\n      } while (iterator.moveNext());\n    } else {\n      write(iterator.current);\n      while (iterator.moveNext()) {\n        write(separator);\n        write(iterator.current);\n      }\n    }\n  }\n\n  void writeln([Object? object = \"\"]) {\n    write(object);\n    write(\"\\n\");\n  }\n\n  void writeCharCode(int charCode) {\n    write(String.fromCharCode(charCode));\n  }\n}\n\nabstract class _HttpOutboundMessage<T> extends _IOSinkImpl {\n  // Used to mark when the body should be written. This is used for HEAD\n  // requests and in error handling.\n  bool _encodingSet = false;\n\n  bool _bufferOutput = true;\n\n  final Uri _uri;\n  final _HttpOutgoing _outgoing;\n\n  final _HttpHeaders headers;\n\n  _HttpOutboundMessage(Uri uri, String protocolVersion, _HttpOutgoing outgoing,\n      _HttpProfileData? profileData,\n      {_HttpHeaders? initialHeaders})\n      : _uri = uri,\n        headers = _HttpHeaders(protocolVersion,\n            defaultPortForScheme: uri.scheme == 'https'\n                ? HttpClient.defaultHttpsPort\n                : HttpClient.defaultHttpPort,\n            initialHeaders: initialHeaders),\n        _outgoing = outgoing,\n        super(outgoing, latin1, profileData) {\n    _outgoing.outbound = this;\n    _encodingMutable = false;\n  }\n\n  int get contentLength => headers.contentLength;\n  void set contentLength(int contentLength) {\n    headers.contentLength = contentLength;\n  }\n\n  bool get persistentConnection => headers.persistentConnection;\n  void set persistentConnection(bool p) {\n    headers.persistentConnection = p;\n  }\n\n  bool get bufferOutput => _bufferOutput;\n  void set bufferOutput(bool bufferOutput) {\n    if (_outgoing.headersWritten) throw StateError(\"Header already sent\");\n    _bufferOutput = bufferOutput;\n  }\n\n  Encoding get encoding {\n    if (_encodingSet && _outgoing.headersWritten) {\n      return _encoding;\n    }\n    String charset;\n    var contentType = headers.contentType;\n    if (contentType != null && contentType.charset != null) {\n      charset = contentType.charset!;\n    } else {\n      charset = \"iso-8859-1\";\n    }\n    return Encoding.getByName(charset) ?? latin1;\n  }\n\n  void add(List<int> data) {\n    if (data.isEmpty) return;\n    _profileData?.appendRequestData(Uint8List.fromList(data));\n    super.add(data);\n  }\n\n  Future addStream(Stream<List<int>> s) {\n    if (_profileData == null) {\n      return super.addStream(s);\n    }\n    return super.addStream(s.map((data) {\n      _profileData?.appendRequestData(Uint8List.fromList(data));\n      return data;\n    }));\n  }\n\n  void write(Object? obj) {\n    if (!_encodingSet) {\n      _encoding = encoding;\n      _encodingSet = true;\n    }\n    super.write(obj);\n  }\n\n  void _writeHeader();\n\n  bool get _isConnectionClosed => false;\n}\n\nclass _HttpResponse extends _HttpOutboundMessage<HttpResponse>\n    implements HttpResponse {\n  int _statusCode = 200;\n  String? _reasonPhrase;\n  List<Cookie>? _cookies;\n  _HttpRequest? _httpRequest;\n  Duration? _deadline;\n  Timer? _deadlineTimer;\n\n  _HttpResponse(Uri uri, String protocolVersion, _HttpOutgoing outgoing,\n      HttpHeaders defaultHeaders, String? serverHeader)\n      : super(uri, protocolVersion, outgoing, null,\n            initialHeaders: defaultHeaders as _HttpHeaders) {\n    if (serverHeader != null) {\n      headers.set(HttpHeaders.serverHeader, serverHeader);\n    }\n  }\n\n  bool get _isConnectionClosed => _httpRequest!._httpConnection._isClosing;\n\n  List<Cookie> get cookies => _cookies ??= <Cookie>[];\n\n  int get statusCode => _statusCode;\n  void set statusCode(int statusCode) {\n    if (_outgoing.headersWritten) throw StateError(\"Header already sent\");\n    _statusCode = statusCode;\n  }\n\n  String get reasonPhrase => _findReasonPhrase(statusCode);\n  void set reasonPhrase(String reasonPhrase) {\n    if (_outgoing.headersWritten) throw StateError(\"Header already sent\");\n    _reasonPhrase = reasonPhrase;\n  }\n\n  Future redirect(Uri location, {int status = HttpStatus.movedTemporarily}) {\n    if (_outgoing.headersWritten) throw StateError(\"Header already sent\");\n    statusCode = status;\n    headers.set(HttpHeaders.locationHeader, location.toString());\n    return close();\n  }\n\n  Future<Socket> detachSocket({bool writeHeaders = true}) {\n    if (_outgoing.headersWritten) throw StateError(\"Headers already sent\");\n    deadline = null; // Be sure to stop any deadline.\n    var future = _httpRequest!._httpConnection.detachSocket();\n    if (writeHeaders) {\n      var headersFuture =\n          _outgoing.writeHeaders(drainRequest: false, setOutgoing: false);\n      assert(headersFuture == null);\n    } else {\n      // Imitate having written the headers.\n      _outgoing.headersWritten = true;\n    }\n    // Close connection so the socket is 'free'.\n    close();\n    done.catchError((_) {\n      // Catch any error on done, as they automatically will be\n      // propagated to the websocket.\n    });\n    return future;\n  }\n\n  HttpConnectionInfo? get connectionInfo => _httpRequest!.connectionInfo;\n\n  Duration? get deadline => _deadline;\n\n  void set deadline(Duration? d) {\n    _deadlineTimer?.cancel();\n    _deadline = d;\n\n    if (d == null) return;\n    _deadlineTimer = Timer(d, () {\n      _httpRequest!._httpConnection.destroy();\n    });\n  }\n\n  void _writeHeader() {\n    BytesBuilder buffer = _CopyingBytesBuilder(_OUTGOING_BUFFER_SIZE);\n\n    // Write status line.\n    if (headers.protocolVersion == \"1.1\") {\n      buffer.add(_Const.HTTP11);\n    } else {\n      buffer.add(_Const.HTTP10);\n    }\n    buffer.addByte(_CharCode.SP);\n    buffer.add(statusCode.toString().codeUnits);\n    buffer.addByte(_CharCode.SP);\n    buffer.add(reasonPhrase.codeUnits);\n    buffer.addByte(_CharCode.CR);\n    buffer.addByte(_CharCode.LF);\n\n    var session = _httpRequest!._session;\n    if (session != null && !session._destroyed) {\n      // Mark as not new.\n      session._isNew = false;\n      // Make sure we only send the current session id.\n      bool found = false;\n      for (int i = 0; i < cookies.length; i++) {\n        if (cookies[i].name.toUpperCase() == _DART_SESSION_ID) {\n          cookies[i]\n            ..value = session.id\n            ..httpOnly = true\n            ..path = \"/\";\n          found = true;\n        }\n      }\n      if (!found) {\n        var cookie = Cookie(_DART_SESSION_ID, session.id);\n        cookies.add(cookie\n          ..httpOnly = true\n          ..path = \"/\");\n      }\n    }\n    // Add all the cookies set to the headers.\n    _cookies?.forEach((cookie) {\n      headers.add(HttpHeaders.setCookieHeader, cookie);\n    });\n\n    headers._finalize();\n\n    // Write headers.\n    headers._build(buffer);\n    buffer.addByte(_CharCode.CR);\n    buffer.addByte(_CharCode.LF);\n    Uint8List headerBytes = buffer.takeBytes();\n    _outgoing.setHeader(headerBytes, headerBytes.length);\n  }\n\n  String _findReasonPhrase(int statusCode) {\n    var reasonPhrase = _reasonPhrase;\n    if (reasonPhrase != null) {\n      return reasonPhrase;\n    }\n\n    switch (statusCode) {\n      case HttpStatus.continue_:\n        return \"Continue\";\n      case HttpStatus.switchingProtocols:\n        return \"Switching Protocols\";\n      case HttpStatus.ok:\n        return \"OK\";\n      case HttpStatus.created:\n        return \"Created\";\n      case HttpStatus.accepted:\n        return \"Accepted\";\n      case HttpStatus.nonAuthoritativeInformation:\n        return \"Non-Authoritative Information\";\n      case HttpStatus.noContent:\n        return \"No Content\";\n      case HttpStatus.resetContent:\n        return \"Reset Content\";\n      case HttpStatus.partialContent:\n        return \"Partial Content\";\n      case HttpStatus.multipleChoices:\n        return \"Multiple Choices\";\n      case HttpStatus.movedPermanently:\n        return \"Moved Permanently\";\n      case HttpStatus.found:\n        return \"Found\";\n      case HttpStatus.seeOther:\n        return \"See Other\";\n      case HttpStatus.notModified:\n        return \"Not Modified\";\n      case HttpStatus.useProxy:\n        return \"Use Proxy\";\n      case HttpStatus.temporaryRedirect:\n        return \"Temporary Redirect\";\n      case HttpStatus.badRequest:\n        return \"Bad Request\";\n      case HttpStatus.unauthorized:\n        return \"Unauthorized\";\n      case HttpStatus.paymentRequired:\n        return \"Payment Required\";\n      case HttpStatus.forbidden:\n        return \"Forbidden\";\n      case HttpStatus.notFound:\n        return \"Not Found\";\n      case HttpStatus.methodNotAllowed:\n        return \"Method Not Allowed\";\n      case HttpStatus.notAcceptable:\n        return \"Not Acceptable\";\n      case HttpStatus.proxyAuthenticationRequired:\n        return \"Proxy Authentication Required\";\n      case HttpStatus.requestTimeout:\n        return \"Request Time-out\";\n      case HttpStatus.conflict:\n        return \"Conflict\";\n      case HttpStatus.gone:\n        return \"Gone\";\n      case HttpStatus.lengthRequired:\n        return \"Length Required\";\n      case HttpStatus.preconditionFailed:\n        return \"Precondition Failed\";\n      case HttpStatus.requestEntityTooLarge:\n        return \"Request Entity Too Large\";\n      case HttpStatus.requestUriTooLong:\n        return \"Request-URI Too Long\";\n      case HttpStatus.unsupportedMediaType:\n        return \"Unsupported Media Type\";\n      case HttpStatus.requestedRangeNotSatisfiable:\n        return \"Requested range not satisfiable\";\n      case HttpStatus.expectationFailed:\n        return \"Expectation Failed\";\n      case HttpStatus.internalServerError:\n        return \"Internal Server Error\";\n      case HttpStatus.notImplemented:\n        return \"Not Implemented\";\n      case HttpStatus.badGateway:\n        return \"Bad Gateway\";\n      case HttpStatus.serviceUnavailable:\n        return \"Service Unavailable\";\n      case HttpStatus.gatewayTimeout:\n        return \"Gateway Time-out\";\n      case HttpStatus.httpVersionNotSupported:\n        return \"Http Version not supported\";\n      default:\n        return \"Status $statusCode\";\n    }\n  }\n}\n\nclass _HttpClientRequest extends _HttpOutboundMessage<HttpClientResponse>\n    implements HttpClientRequest {\n  final String method;\n  final Uri uri;\n  final List<Cookie> cookies = [];\n\n  // The HttpClient this request belongs to.\n  final _HttpClient _httpClient;\n  final _HttpClientConnection _httpClientConnection;\n\n  final Completer<HttpClientResponse> _responseCompleter =\n      Completer<HttpClientResponse>();\n\n  final _Proxy _proxy;\n\n  Future<HttpClientResponse>? _response;\n\n  // TODO(ajohnsen): Get default value from client?\n  bool _followRedirects = true;\n\n  int _maxRedirects = 5;\n\n  final List<RedirectInfo> _responseRedirects = [];\n\n  bool _aborted = false;\n\n  _HttpClientRequest(\n    _HttpOutgoing outgoing,\n    this.uri,\n    this.method,\n    this._proxy,\n    this._httpClient,\n    this._httpClientConnection,\n    _HttpProfileData? _profileData,\n  ) : super(uri, \"1.1\", outgoing, _profileData) {\n    _profileData?.requestEvent('Request sent');\n    // GET and HEAD have 'content-length: 0' by default.\n    if (method == \"GET\" || method == \"HEAD\") {\n      contentLength = 0;\n    } else {\n      headers.chunkedTransferEncoding = true;\n    }\n\n    _responseCompleter.future.then((response) {\n      _profileData?.requestEvent('Waiting (TTFB)');\n      _profileData?.startResponse(\n        // TODO(bkonyi): consider exposing certificate information?\n        // 'certificate': response.certificate,\n        response: response,\n      );\n    }, onError: (e) {});\n  }\n\n  Future<HttpClientResponse> get done => _response ??=\n      Future.wait([_responseCompleter.future, super.done], eagerError: true)\n          .then((list) => list[0]);\n\n  Future<HttpClientResponse> close() {\n    if (!_aborted) {\n      // It will send out the request.\n      super.close();\n    }\n    return done;\n  }\n\n  int get maxRedirects => _maxRedirects;\n  void set maxRedirects(int maxRedirects) {\n    if (_outgoing.headersWritten) throw StateError(\"Request already sent\");\n    _maxRedirects = maxRedirects;\n  }\n\n  bool get followRedirects => _followRedirects;\n  void set followRedirects(bool followRedirects) {\n    if (_outgoing.headersWritten) throw StateError(\"Request already sent\");\n    _followRedirects = followRedirects;\n  }\n\n  HttpConnectionInfo? get connectionInfo =>\n      _httpClientConnection.connectionInfo;\n\n  void _onIncoming(_HttpIncoming incoming) {\n    if (_aborted) {\n      return;\n    }\n    final response =\n        _HttpClientResponse(incoming, this, _httpClient, _profileData);\n    Future<HttpClientResponse> future;\n    if (followRedirects && response.isRedirect) {\n      if (response.redirects.length < maxRedirects) {\n        // Redirect and drain response.\n        future = response\n            .drain()\n            .then<HttpClientResponse>((_) => response.redirect());\n      } else {\n        // End with exception, too many redirects.\n        future = response.drain().then<HttpClientResponse>((_) {\n          return Future<HttpClientResponse>.error(\n              RedirectException(\"Redirect limit exceeded\", response.redirects));\n        });\n      }\n    } else if (response._shouldAuthenticateProxy) {\n      future = response._authenticate(true);\n    } else if (response._shouldAuthenticate) {\n      future = response._authenticate(false);\n    } else {\n      future = Future<HttpClientResponse>.value(response);\n    }\n    future.then((v) {\n      if (!_responseCompleter.isCompleted) {\n        _responseCompleter.complete(v);\n      }\n    }, onError: (e, s) {\n      if (!_responseCompleter.isCompleted) {\n        _responseCompleter.completeError(e, s);\n      }\n    });\n  }\n\n  void _onError(error, StackTrace stackTrace) {\n    if (!_responseCompleter.isCompleted) {\n      _responseCompleter.completeError(error, stackTrace);\n    }\n  }\n\n  // Generate the request URI based on the method and proxy.\n  String _requestUri() {\n    // Generate the request URI starting from the path component.\n    String uriStartingFromPath() {\n      String result = uri.path;\n      if (result.isEmpty) result = \"/\";\n      if (uri.hasQuery) {\n        result = \"$result?${uri.query}\";\n      }\n      return result;\n    }\n\n    if (_proxy.isDirect) {\n      return uriStartingFromPath();\n    } else {\n      if (method == \"CONNECT\") {\n        // For the connect method the request URI is the host:port of\n        // the requested destination of the tunnel (see RFC 2817\n        // section 5.2)\n        return \"${uri.host}:${uri.port}\";\n      } else {\n        if (_httpClientConnection._proxyTunnel) {\n          return uriStartingFromPath();\n        } else {\n          return uri.removeFragment().toString();\n        }\n      }\n    }\n  }\n\n  void add(List<int> data) {\n    if (data.isEmpty || _aborted) return;\n    super.add(data);\n  }\n\n  void write(Object? obj) {\n    if (_aborted) return;\n    super.write(obj);\n  }\n\n  void _writeHeader() {\n    if (_aborted) {\n      _outgoing.setHeader(Uint8List(0), 0);\n      return;\n    }\n    BytesBuilder buffer = _CopyingBytesBuilder(_OUTGOING_BUFFER_SIZE);\n\n    // Write the request method.\n    buffer.add(method.codeUnits);\n    buffer.addByte(_CharCode.SP);\n    // Write the request URI.\n    buffer.add(_requestUri().codeUnits);\n    buffer.addByte(_CharCode.SP);\n    // Write HTTP/1.1.\n    buffer.add(_Const.HTTP11);\n    buffer.addByte(_CharCode.CR);\n    buffer.addByte(_CharCode.LF);\n\n    // Add the cookies to the headers.\n    if (cookies.isNotEmpty) {\n      StringBuffer sb = StringBuffer();\n      for (int i = 0; i < cookies.length; i++) {\n        if (i > 0) sb.write(\"; \");\n        sb\n          ..write(cookies[i].name)\n          ..write(\"=\")\n          ..write(cookies[i].value);\n      }\n      headers.add(HttpHeaders.cookieHeader, sb.toString());\n    }\n\n    headers._finalize();\n\n    // Write headers.\n    headers._build(buffer,\n        skipZeroContentLength: method == \"CONNECT\" ||\n            method == \"DELETE\" ||\n            method == \"GET\" ||\n            method == \"HEAD\");\n    buffer.addByte(_CharCode.CR);\n    buffer.addByte(_CharCode.LF);\n    Uint8List headerBytes = buffer.takeBytes();\n    _outgoing.setHeader(headerBytes, headerBytes.length);\n  }\n\n  void abort([Object? exception, StackTrace? stackTrace]) {\n    _aborted = true;\n    if (!_responseCompleter.isCompleted) {\n      exception ??= HttpException(\"Request has been aborted\");\n      _responseCompleter.completeError(exception, stackTrace);\n      _httpClientConnection.destroy();\n    }\n  }\n}\n\n// Used by _HttpOutgoing as a target of a chunked converter for gzip\n// compression.\nclass _HttpGZipSink extends ByteConversionSink {\n  final _BytesConsumer _consume;\n  _HttpGZipSink(this._consume);\n\n  void add(List<int> chunk) {\n    _consume(chunk);\n  }\n\n  void addSlice(List<int> chunk, int start, int end, bool isLast) {\n    if (chunk is Uint8List) {\n      _consume(Uint8List.view(\n          chunk.buffer, chunk.offsetInBytes + start, end - start));\n    } else {\n      _consume(chunk.sublist(start, end - start));\n    }\n  }\n\n  void close() {}\n}\n\n// The _HttpOutgoing handles all of the following:\n//  - Buffering\n//  - GZip compression\n//  - Content-Length validation.\n//  - Errors.\n//\n// Most notable is the GZip compression, that uses a double-buffering system,\n// one before gzip (_gzipBuffer) and one after (_buffer).\nclass _HttpOutgoing implements StreamConsumer<List<int>> {\n  static const List<int> _footerAndChunk0Length = [\n    _CharCode.CR,\n    _CharCode.LF,\n    0x30,\n    _CharCode.CR,\n    _CharCode.LF,\n    _CharCode.CR,\n    _CharCode.LF\n  ];\n\n  static const List<int> _chunk0Length = [\n    0x30,\n    _CharCode.CR,\n    _CharCode.LF,\n    _CharCode.CR,\n    _CharCode.LF\n  ];\n\n  final Completer<Socket> _doneCompleter = Completer<Socket>();\n  final Socket socket;\n\n  bool ignoreBody = false;\n  bool headersWritten = false;\n\n  Uint8List? _buffer;\n  int _length = 0;\n\n  Future? _closeFuture;\n\n  bool chunked = false;\n  int _pendingChunkedFooter = 0;\n\n  int? contentLength;\n  int _bytesWritten = 0;\n\n  bool _gzip = false;\n  ByteConversionSink? _gzipSink;\n  // _gzipAdd is set iff the sink is being added to. It's used to specify where\n  // gzipped data should be taken (sometimes a controller, sometimes a socket).\n  _BytesConsumer? _gzipAdd;\n  Uint8List? _gzipBuffer;\n  int _gzipBufferLength = 0;\n\n  bool _socketError = false;\n\n  _HttpOutboundMessage? outbound;\n\n  _HttpOutgoing(this.socket);\n\n  // Returns either a future or 'null', if it was able to write headers\n  // immediately.\n  Future<void>? writeHeaders(\n      {bool drainRequest = true, bool setOutgoing = true}) {\n    if (headersWritten) return null;\n    headersWritten = true;\n    Future<void>? drainFuture;\n    bool gzip = false;\n    var response = outbound!;\n    if (response is _HttpResponse) {\n      // Server side.\n      if (response._httpRequest!._httpServer.autoCompress &&\n          response.bufferOutput &&\n          response.headers.chunkedTransferEncoding) {\n        List<String>? acceptEncodings =\n            response._httpRequest!.headers[HttpHeaders.acceptEncodingHeader];\n        List<String>? contentEncoding =\n            response.headers[HttpHeaders.contentEncodingHeader];\n        if (acceptEncodings != null &&\n            contentEncoding == null &&\n            acceptEncodings\n                .expand((list) => list.split(\",\"))\n                .any((encoding) => encoding.trim().toLowerCase() == \"gzip\")) {\n          response.headers.set(HttpHeaders.contentEncodingHeader, \"gzip\");\n          gzip = true;\n        }\n      }\n      if (drainRequest && !response._httpRequest!._incoming.hasSubscriber) {\n        drainFuture = response._httpRequest!.drain<void>().catchError((_) {});\n      }\n    } else {\n      drainRequest = false;\n    }\n    if (!ignoreBody) {\n      if (setOutgoing) {\n        int contentLength = response.headers.contentLength;\n        if (response.headers.chunkedTransferEncoding) {\n          chunked = true;\n          if (gzip) this.gzip = true;\n        } else if (contentLength >= 0) {\n          this.contentLength = contentLength;\n        }\n      }\n      if (drainFuture != null) {\n        return drainFuture.then((_) => response._writeHeader());\n      }\n    }\n    response._writeHeader();\n    return null;\n  }\n\n  Future addStream(Stream<List<int>> stream) {\n    if (_socketError) {\n      stream.listen(null).cancel();\n      return Future.value(outbound);\n    }\n    if (ignoreBody) {\n      stream.drain().catchError((_) {});\n      var future = writeHeaders();\n      if (future != null) {\n        return future.then((_) => close());\n      }\n      return close();\n    }\n    // Use new stream so we are able to pause (see below listen). The\n    // alternative is to use stream.extand, but that won't give us a way of\n    // pausing.\n    var controller = StreamController<List<int>>(sync: true);\n\n    void onData(List<int> data) {\n      if (_socketError) return;\n      if (data.isEmpty) return;\n      if (chunked) {\n        if (_gzip) {\n          _gzipAdd = controller.add;\n          _addGZipChunk(data, _gzipSink!.add);\n          _gzipAdd = null;\n          return;\n        }\n        _addChunk(_chunkHeader(data.length), controller.add);\n        _pendingChunkedFooter = 2;\n      } else {\n        var contentLength = this.contentLength;\n        if (contentLength != null) {\n          _bytesWritten += data.length;\n          if (_bytesWritten > contentLength) {\n            controller.addError(\n                HttpException(\"Content size exceeds specified contentLength. \"\n                    \"$_bytesWritten bytes written while expected \"\n                    \"$contentLength. \"\n                    \"[${String.fromCharCodes(data)}]\"));\n            return;\n          }\n        }\n      }\n      _addChunk(data, controller.add);\n    }\n\n    var sub = stream.listen(onData,\n        onError: controller.addError,\n        onDone: controller.close,\n        cancelOnError: true);\n    controller.onPause = sub.pause;\n    controller.onResume = sub.resume;\n    // Write headers now that we are listening to the stream.\n    if (!headersWritten) {\n      var future = writeHeaders();\n      if (future != null) {\n        // While incoming is being drained, the pauseFuture is non-null. Pause\n        // output until it's drained.\n        sub.pause(future);\n      }\n    }\n    return socket.addStream(controller.stream).then((_) {\n      return outbound;\n    }, onError: (error, stackTrace) {\n      // Be sure to close it in case of an error.\n      if (_gzip) _gzipSink!.close();\n      _socketError = true;\n      _doneCompleter.completeError(error, stackTrace);\n      if (_ignoreError(error)) {\n        return outbound;\n      } else {\n        throw error;\n      }\n    });\n  }\n\n  Future close() {\n    // If we are already closed, return that future.\n    var closeFuture = _closeFuture;\n    if (closeFuture != null) return closeFuture;\n\n    var outbound = this.outbound!;\n    // If we earlier saw an error, return immediate. The notification to\n    // _Http*Connection is already done.\n    if (_socketError) return Future.value(outbound);\n    if (outbound._isConnectionClosed) return Future.value(outbound);\n    if (!headersWritten && !ignoreBody) {\n      if (outbound.headers.contentLength == -1) {\n        // If no body was written, ignoreBody is false (it's not a HEAD\n        // request) and the content-length is unspecified, set contentLength to\n        // 0.\n        outbound.headers.chunkedTransferEncoding = false;\n        outbound.headers.contentLength = 0;\n      } else if (outbound.headers.contentLength > 0) {\n        var error = HttpException(\n            \"No content even though contentLength was specified to be \"\n            \"greater than 0: ${outbound.headers.contentLength}.\",\n            uri: outbound._uri);\n        _doneCompleter.completeError(error);\n        return _closeFuture = Future.error(error);\n      }\n    }\n    // If contentLength was specified, validate it.\n    var contentLength = this.contentLength;\n    if (contentLength != null) {\n      if (_bytesWritten < contentLength) {\n        var error = HttpException(\n            \"Content size below specified contentLength. \"\n            \" $_bytesWritten bytes written but expected \"\n            \"$contentLength.\",\n            uri: outbound._uri);\n        _doneCompleter.completeError(error);\n        return _closeFuture = Future.error(error);\n      }\n    }\n\n    Future finalize() {\n      // In case of chunked encoding (and gzip), handle remaining gzip data and\n      // append the 'footer' for chunked encoding.\n      if (chunked) {\n        if (_gzip) {\n          _gzipAdd = socket.add;\n          if (_gzipBufferLength > 0) {\n            _gzipSink!.add(Uint8List.view(_gzipBuffer!.buffer,\n                _gzipBuffer!.offsetInBytes, _gzipBufferLength));\n          }\n          _gzipBuffer = null;\n          _gzipSink!.close();\n          _gzipAdd = null;\n        }\n        _addChunk(_chunkHeader(0), socket.add);\n      }\n      // Add any remaining data in the buffer.\n      if (_length > 0) {\n        socket.add(\n            Uint8List.view(_buffer!.buffer, _buffer!.offsetInBytes, _length));\n      }\n      // Clear references, for better GC.\n      _buffer = null;\n      // And finally flush it. As we support keep-alive, never close it from\n      // here. Once the socket is flushed, we'll be able to reuse it (signaled\n      // by the 'done' future).\n      return socket.flush().then((_) {\n        _doneCompleter.complete(socket);\n        return outbound;\n      }, onError: (error, stackTrace) {\n        _doneCompleter.completeError(error, stackTrace);\n        if (_ignoreError(error)) {\n          return outbound;\n        } else {\n          throw error;\n        }\n      });\n    }\n\n    var future = writeHeaders();\n    if (future != null) {\n      return _closeFuture = future.whenComplete(finalize);\n    }\n    return _closeFuture = finalize();\n  }\n\n  Future<Socket> get done => _doneCompleter.future;\n\n  void setHeader(List<int> data, int length) {\n    assert(_length == 0);\n    _buffer = data as Uint8List;\n    _length = length;\n  }\n\n  void set gzip(bool value) {\n    _gzip = value;\n    if (value) {\n      _gzipBuffer = Uint8List(_OUTGOING_BUFFER_SIZE);\n      assert(_gzipSink == null);\n      _gzipSink =\n          ZLibEncoder(gzip: true).startChunkedConversion(_HttpGZipSink((data) {\n        // We are closing down prematurely, due to an error. Discard.\n        if (_gzipAdd == null) return;\n        _addChunk(_chunkHeader(data.length), _gzipAdd!);\n        _pendingChunkedFooter = 2;\n        _addChunk(data, _gzipAdd!);\n      }));\n    }\n  }\n\n  bool _ignoreError(error) =>\n      (error is SocketException || error is TlsException) &&\n      outbound is HttpResponse;\n\n  void _addGZipChunk(List<int> chunk, void Function(List<int> data) add) {\n    var bufferOutput = outbound!.bufferOutput;\n    if (!bufferOutput) {\n      add(chunk);\n      return;\n    }\n    var gzipBuffer = _gzipBuffer!;\n    if (chunk.length > gzipBuffer.length - _gzipBufferLength) {\n      add(Uint8List.view(\n          gzipBuffer.buffer, gzipBuffer.offsetInBytes, _gzipBufferLength));\n      _gzipBuffer = Uint8List(_OUTGOING_BUFFER_SIZE);\n      _gzipBufferLength = 0;\n    }\n    if (chunk.length > _OUTGOING_BUFFER_SIZE) {\n      add(chunk);\n    } else {\n      var currentLength = _gzipBufferLength;\n      var newLength = currentLength + chunk.length;\n      _gzipBuffer!.setRange(currentLength, newLength, chunk);\n      _gzipBufferLength = newLength;\n    }\n  }\n\n  void _addChunk(List<int> chunk, void Function(List<int> data) add) {\n    var bufferOutput = outbound!.bufferOutput;\n    if (!bufferOutput) {\n      if (_buffer != null) {\n        // If _buffer is not null, we have not written the header yet. Write\n        // it now.\n        add(Uint8List.view(_buffer!.buffer, _buffer!.offsetInBytes, _length));\n        _buffer = null;\n        _length = 0;\n      }\n      add(chunk);\n      return;\n    }\n    if (chunk.length > _buffer!.length - _length) {\n      add(Uint8List.view(_buffer!.buffer, _buffer!.offsetInBytes, _length));\n      _buffer = Uint8List(_OUTGOING_BUFFER_SIZE);\n      _length = 0;\n    }\n    if (chunk.length > _OUTGOING_BUFFER_SIZE) {\n      add(chunk);\n    } else {\n      _buffer!.setRange(_length, _length + chunk.length, chunk);\n      _length += chunk.length;\n    }\n  }\n\n  List<int> _chunkHeader(int length) {\n    const hexDigits = [\n      0x30,\n      0x31,\n      0x32,\n      0x33,\n      0x34,\n      0x35,\n      0x36,\n      0x37,\n      0x38,\n      0x39,\n      0x41,\n      0x42,\n      0x43,\n      0x44,\n      0x45,\n      0x46\n    ];\n    if (length == 0) {\n      if (_pendingChunkedFooter == 2) return _footerAndChunk0Length;\n      return _chunk0Length;\n    }\n    int size = _pendingChunkedFooter;\n    int len = length;\n    // Compute a fast integer version of (log(length + 1) / log(16)).ceil().\n    while (len > 0) {\n      size++;\n      len >>= 4;\n    }\n    var footerAndHeader = Uint8List(size + 2);\n    if (_pendingChunkedFooter == 2) {\n      footerAndHeader[0] = _CharCode.CR;\n      footerAndHeader[1] = _CharCode.LF;\n    }\n    int index = size;\n    while (index > _pendingChunkedFooter) {\n      footerAndHeader[--index] = hexDigits[length & 15];\n      length = length >> 4;\n    }\n    footerAndHeader[size + 0] = _CharCode.CR;\n    footerAndHeader[size + 1] = _CharCode.LF;\n    return footerAndHeader;\n  }\n}\n\nclass _HttpClientConnection {\n  final String key;\n  final Socket _socket;\n  final bool _proxyTunnel;\n  final SecurityContext? _context;\n  final _HttpParser _httpParser;\n  StreamSubscription? _subscription;\n  final _HttpClient _httpClient;\n  bool _dispose = false;\n  Timer? _idleTimer;\n  bool closed = false;\n  Uri? _currentUri;\n\n  Completer<_HttpIncoming>? _nextResponseCompleter;\n  Future<Socket>? _streamFuture;\n\n  _HttpClientConnection(this.key, this._socket, this._httpClient,\n      [this._proxyTunnel = false, this._context])\n      : _httpParser = _HttpParser.responseParser() {\n    _httpParser.listenToStream(_socket);\n\n    // Set up handlers on the parser here, so we are sure to get 'onDone' from\n    // the parser.\n    _subscription = _httpParser.listen((incoming) {\n      // Only handle one incoming response at the time. Keep the\n      // stream paused until the response have been processed.\n      _subscription!.pause();\n      // We assume the response is not here, until we have send the request.\n      if (_nextResponseCompleter == null) {\n        throw HttpException(\n            \"Unexpected response (unsolicited response without request).\",\n            uri: _currentUri);\n      }\n\n      // Check for status code '100 Continue'. In that case just\n      // consume that response as the final response will follow\n      // it. There is currently no API for the client to wait for\n      // the '100 Continue' response.\n      if (incoming.statusCode == 100) {\n        incoming.drain().then((_) {\n          _subscription!.resume();\n        }).catchError((dynamic error, StackTrace stackTrace) {\n          _nextResponseCompleter!.completeError(\n              HttpException(error.message, uri: _currentUri), stackTrace);\n          _nextResponseCompleter = null;\n        });\n      } else {\n        _nextResponseCompleter!.complete(incoming);\n        _nextResponseCompleter = null;\n      }\n    }, onError: (dynamic error, StackTrace stackTrace) {\n      _nextResponseCompleter?.completeError(\n          HttpException(error.message, uri: _currentUri), stackTrace);\n      _nextResponseCompleter = null;\n    }, onDone: () {\n      _nextResponseCompleter?.completeError(HttpException(\n          \"Connection closed before response was received\",\n          uri: _currentUri));\n      _nextResponseCompleter = null;\n      close();\n    });\n  }\n\n  _HttpClientRequest send(Uri uri, int port, String method, _Proxy proxy,\n      _HttpProfileData? profileData) {\n    if (closed) {\n      throw HttpException(\"Socket closed before request was sent\", uri: uri);\n    }\n    _currentUri = uri;\n    // Start with pausing the parser.\n    _subscription!.pause();\n    if (method == \"CONNECT\") {\n      // Parser will ignore Content-Length or Transfer-Encoding header\n      _httpParser.connectMethod = true;\n    }\n    _ProxyCredentials? proxyCreds; // Credentials used to authorize proxy.\n    _SiteCredentials? creds; // Credentials used to authorize this request.\n    var outgoing = _HttpOutgoing(_socket);\n\n    // Create new request object, wrapping the outgoing connection.\n    var request = _HttpClientRequest(\n        outgoing, uri, method, proxy, _httpClient, this, profileData);\n    // For the Host header an IPv6 address must be enclosed in []'s.\n    var host = uri.host;\n    if (host.contains(':')) host = \"[$host]\";\n    request.headers\n      ..host = host\n      ..port = port\n      ..add(HttpHeaders.acceptEncodingHeader, \"gzip\");\n    if (_httpClient.userAgent != null) {\n      request.headers.add(HttpHeaders.userAgentHeader, _httpClient.userAgent!);\n    }\n    if (proxy.isAuthenticated) {\n      // If the proxy configuration contains user information use that\n      // for proxy basic authorization.\n      String auth =\n          base64Encode(utf8.encode(\"${proxy.username}:${proxy.password}\"));\n      request.headers.set(HttpHeaders.proxyAuthorizationHeader, \"Basic $auth\");\n    } else if (!proxy.isDirect && _httpClient._proxyCredentials.isNotEmpty) {\n      proxyCreds = _httpClient._findProxyCredentials(proxy);\n      if (proxyCreds != null) {\n        proxyCreds.authorize(request);\n      }\n    }\n    if (uri.userInfo != null && uri.userInfo.isNotEmpty) {\n      // If the URL contains user information use that for basic\n      // authorization.\n      String auth = base64Encode(utf8.encode(uri.userInfo));\n      request.headers.set(HttpHeaders.authorizationHeader, \"Basic $auth\");\n    } else {\n      // Look for credentials.\n      creds = _httpClient._findCredentials(uri);\n      if (creds != null) {\n        creds.authorize(request);\n      }\n    }\n\n    // Start sending the request (lazy, delayed until the user provides\n    // data).\n    _httpParser.isHead = method == \"HEAD\";\n    _streamFuture = outgoing.done.then<Socket>((Socket s) {\n      // Request sent, details available for profiling\n      profileData?.finishRequest(request: request);\n\n      // Request sent, set up response completer.\n      var nextResponseCompleter = Completer<_HttpIncoming>();\n      _nextResponseCompleter = nextResponseCompleter;\n\n      // Listen for response.\n      nextResponseCompleter.future.then((incoming) {\n        _currentUri = null;\n        incoming.dataDone.then((closing) {\n          if (incoming.upgraded) {\n            _httpClient._connectionClosed(this);\n            startTimer();\n            return;\n          }\n          // Keep the connection open if the CONNECT request was successful.\n          if (closed ||\n              (method == 'CONNECT' && incoming.statusCode == HttpStatus.ok)) {\n            return;\n          }\n          if (!closing &&\n              !_dispose &&\n              incoming.headers.persistentConnection &&\n              request.persistentConnection) {\n            // Return connection, now we are done.\n            _httpClient._returnConnection(this);\n            _subscription!.resume();\n          } else {\n            destroy();\n          }\n        });\n        // For digest authentication if proxy check if the proxy\n        // requests the client to start using a new nonce for proxy\n        // authentication.\n        if (proxyCreds != null &&\n            proxyCreds.scheme == _AuthenticationScheme.DIGEST) {\n          var authInfo = incoming.headers[\"proxy-authentication-info\"];\n          if (authInfo != null && authInfo.length == 1) {\n            var header =\n                _HeaderValue.parse(authInfo[0], parameterSeparator: ',');\n            var nextnonce = header.parameters[\"nextnonce\"];\n            if (nextnonce != null) proxyCreds.nonce = nextnonce;\n          }\n        }\n        // For digest authentication check if the server requests the\n        // client to start using a new nonce.\n        if (creds != null && creds.scheme == _AuthenticationScheme.DIGEST) {\n          var authInfo = incoming.headers[\"authentication-info\"];\n          if (authInfo != null && authInfo.length == 1) {\n            var header =\n                _HeaderValue.parse(authInfo[0], parameterSeparator: ',');\n            var nextnonce = header.parameters[\"nextnonce\"];\n            if (nextnonce != null) creds.nonce = nextnonce;\n          }\n        }\n        request._onIncoming(incoming);\n      })\n          // If we see a state error, we failed to get the 'first'\n          // element.\n          .catchError((error) {\n        throw HttpException(\"Connection closed before data was received\",\n            uri: uri);\n      }, test: (error) => error is StateError).catchError((error, stackTrace) {\n        // We are done with the socket.\n        destroy();\n        request._onError(error, stackTrace);\n      });\n\n      // Resume the parser now we have a handler.\n      _subscription!.resume();\n      return s;\n    });\n    Future<Socket?>.value(_streamFuture).catchError((e) {\n      destroy();\n    });\n    return request;\n  }\n\n  Future<Socket> detachSocket() {\n    return _streamFuture!\n        .then((_) => _DetachedSocket(_socket, _httpParser.detachIncoming()));\n  }\n\n  void destroy() {\n    closed = true;\n    _httpClient._connectionClosed(this);\n    _socket.destroy();\n  }\n\n  void destroyFromExternal() {\n    closed = true;\n    _httpClient._connectionClosedNoFurtherClosing(this);\n    _socket.destroy();\n  }\n\n  void close() {\n    closed = true;\n    _httpClient._connectionClosed(this);\n    _streamFuture!\n        .timeout(_httpClient.idleTimeout)\n        .then((_) => _socket.destroy());\n  }\n\n  void closeFromExternal() {\n    closed = true;\n    _httpClient._connectionClosedNoFurtherClosing(this);\n    _streamFuture!\n        .timeout(_httpClient.idleTimeout)\n        .then((_) => _socket.destroy());\n  }\n\n  Future<_HttpClientConnection> createProxyTunnel(\n      String host,\n      int port,\n      _Proxy proxy,\n      bool Function(X509Certificate certificate) callback,\n      _HttpProfileData? profileData) {\n    final method = \"CONNECT\";\n    final uri = Uri(host: host, port: port);\n\n    profileData?.proxyEvent(proxy);\n\n    // Notify the profiler that we're starting a sub request.\n    _HttpProfileData? proxyProfileData;\n    if (profileData != null) {\n      proxyProfileData = HttpProfiler.startRequest(\n        method,\n        uri,\n        parentRequest: profileData,\n      );\n    }\n    _HttpClientRequest request = send(\n        Uri(host: host, port: port), port, method, proxy, proxyProfileData);\n    if (proxy.isAuthenticated) {\n      // If the proxy configuration contains user information use that\n      // for proxy basic authorization.\n      String auth =\n          base64Encode(utf8.encode(\"${proxy.username}:${proxy.password}\"));\n      request.headers.set(HttpHeaders.proxyAuthorizationHeader, \"Basic $auth\");\n    }\n    return request.close().then((response) {\n      if (response.statusCode != HttpStatus.ok) {\n        final error = \"Proxy failed to establish tunnel \"\n            \"(${response.statusCode} ${response.reasonPhrase})\";\n        profileData?.requestEvent(error);\n        throw HttpException(error, uri: request.uri);\n      }\n      var socket = (response as _HttpClientResponse)\n          ._httpRequest\n          ._httpClientConnection\n          ._socket;\n      return SecureSocket.secure(socket,\n          host: host, context: _context, onBadCertificate: callback);\n    }).then((secureSocket) {\n      String key = _HttpClientConnection.makeKey(true, host, port);\n      profileData?.requestEvent('Proxy tunnel established');\n      return _HttpClientConnection(\n          key, secureSocket, request._httpClient, true);\n    });\n  }\n\n  HttpConnectionInfo? get connectionInfo => _HttpConnectionInfo.create(_socket);\n\n  static makeKey(bool isSecure, String host, int port) {\n    return isSecure ? \"ssh:$host:$port\" : \"$host:$port\";\n  }\n\n  void stopTimer() {\n    _idleTimer?.cancel();\n    _idleTimer = null;\n  }\n\n  void startTimer() {\n    assert(_idleTimer == null);\n    _idleTimer = Timer(_httpClient.idleTimeout, () {\n      _idleTimer = null;\n      close();\n    });\n  }\n}\n\nclass _ConnectionInfo {\n  final _HttpClientConnection connection;\n  final _Proxy proxy;\n\n  _ConnectionInfo(this.connection, this.proxy);\n}\n\nclass _ConnectionTarget {\n  // Unique key for this connection target.\n  final String key;\n  final String host;\n  final int port;\n  final bool isSecure;\n  final SecurityContext? context;\n  final Set<_HttpClientConnection> _idle = HashSet();\n  final Set<_HttpClientConnection> _active = HashSet();\n  final Set<ConnectionTask> _socketTasks = HashSet();\n  final _pending = ListQueue<void Function()>();\n  int _connecting = 0;\n\n  _ConnectionTarget(\n      this.key, this.host, this.port, this.isSecure, this.context);\n\n  bool get isEmpty => _idle.isEmpty && _active.isEmpty && _connecting == 0;\n\n  bool get hasIdle => _idle.isNotEmpty;\n\n  bool get hasActive => _active.isNotEmpty || _connecting > 0;\n\n  _HttpClientConnection takeIdle() {\n    assert(hasIdle);\n    _HttpClientConnection connection = _idle.first;\n    _idle.remove(connection);\n    connection.stopTimer();\n    _active.add(connection);\n    return connection;\n  }\n\n  _checkPending() {\n    if (_pending.isNotEmpty) {\n      _pending.removeFirst()();\n    }\n  }\n\n  void addNewActive(_HttpClientConnection connection) {\n    _active.add(connection);\n  }\n\n  void returnConnection(_HttpClientConnection connection) {\n    assert(_active.contains(connection));\n    _active.remove(connection);\n    _idle.add(connection);\n    connection.startTimer();\n    _checkPending();\n  }\n\n  void connectionClosed(_HttpClientConnection connection) {\n    assert(!_active.contains(connection) || !_idle.contains(connection));\n    _active.remove(connection);\n    _idle.remove(connection);\n    _checkPending();\n  }\n\n  void close(bool force) {\n    // Always cancel pending socket connections.\n    for (var t in _socketTasks.toList()) {\n      // Make sure the socket is destroyed if the ConnectionTask is cancelled.\n      t.socket.then((s) {\n        s.destroy();\n      }, onError: (e) {});\n      t.cancel();\n    }\n    if (force) {\n      for (var c in _idle.toList()) {\n        c.destroyFromExternal();\n      }\n      for (var c in _active.toList()) {\n        c.destroyFromExternal();\n      }\n    } else {\n      for (var c in _idle.toList()) {\n        c.closeFromExternal();\n      }\n    }\n  }\n\n  Future<_ConnectionInfo> connect(String uriHost, int uriPort, _Proxy proxy,\n      _HttpClient client, _HttpProfileData? profileData) {\n    if (hasIdle) {\n      var connection = takeIdle();\n      client._connectionsChanged();\n      return Future.value(_ConnectionInfo(connection, proxy));\n    }\n    var maxConnectionsPerHost = client.maxConnectionsPerHost;\n    if (maxConnectionsPerHost != null &&\n        _active.length + _connecting >= maxConnectionsPerHost) {\n      var completer = Completer<_ConnectionInfo>();\n      _pending.add(() {\n        completer\n            .complete(connect(uriHost, uriPort, proxy, client, profileData));\n      });\n      return completer.future;\n    }\n    var currentBadCertificateCallback = client._badCertificateCallback;\n\n    bool callback(X509Certificate certificate) {\n      if (currentBadCertificateCallback == null) return false;\n      return currentBadCertificateCallback(certificate, uriHost, uriPort);\n    }\n\n    Future<ConnectionTask> connectionTask = (isSecure && proxy.isDirect\n        ? SecureSocket.startConnect(host, port,\n            context: context, onBadCertificate: callback)\n        : Socket.startConnect(host, port));\n    _connecting++;\n    return connectionTask.then((ConnectionTask task) {\n      _socketTasks.add(task);\n      Future socketFuture = task.socket;\n      final Duration? connectionTimeout = client.connectionTimeout;\n      if (connectionTimeout != null) {\n        socketFuture = socketFuture.timeout(connectionTimeout);\n      }\n      return socketFuture.then((socket) {\n        _connecting--;\n        if (socket.address.type != InternetAddressType.unix) {\n          socket.setOption(SocketOption.tcpNoDelay, true);\n        }\n        var connection =\n            _HttpClientConnection(key, socket, client, false, context);\n        if (isSecure && !proxy.isDirect) {\n          connection._dispose = true;\n          return connection\n              .createProxyTunnel(uriHost, uriPort, proxy, callback, profileData)\n              .then((tunnel) {\n            client\n                ._getConnectionTarget(uriHost, uriPort, true)\n                .addNewActive(tunnel);\n            _socketTasks.remove(task);\n            return _ConnectionInfo(tunnel, proxy);\n          });\n        } else {\n          addNewActive(connection);\n          _socketTasks.remove(task);\n          return _ConnectionInfo(connection, proxy);\n        }\n      }, onError: (error) {\n        // When there is a timeout, there is a race in which the connectionTask\n        // Future won't be completed with an error before the socketFuture here\n        // is completed with a TimeoutException by the onTimeout callback above.\n        // In this case, propagate a SocketException as specified by the\n        // HttpClient.connectionTimeout docs.\n        if (error is TimeoutException) {\n          assert(connectionTimeout != null);\n          _connecting--;\n          _socketTasks.remove(task);\n          task.cancel();\n          throw SocketException(\n              \"HTTP connection timed out after $connectionTimeout, \"\n              \"host: $host, port: $port\");\n        }\n        _socketTasks.remove(task);\n        _checkPending();\n        throw error;\n      });\n    }, onError: (error) {\n      _connecting--;\n      throw error;\n    });\n  }\n}\n\ntypedef BadCertificateCallback = bool Function(\n    X509Certificate cr, String host, int port);\n\nclass _HttpClient implements HttpClient {\n  bool _closing = false;\n  bool _closingForcefully = false;\n  final Map<String, _ConnectionTarget> _connectionTargets =\n      HashMap<String, _ConnectionTarget>();\n  final List<_Credentials> _credentials = [];\n  final List<_ProxyCredentials> _proxyCredentials = [];\n  final SecurityContext? _context;\n  Future<bool> Function(Uri, String scheme, String? realm)? _authenticate;\n  Future<bool> Function(String host, int port, String scheme, String? realm)?\n      _authenticateProxy;\n  String Function(Uri)? _findProxy = HttpClient.findProxyFromEnvironment;\n  Duration _idleTimeout = const Duration(seconds: 15);\n  BadCertificateCallback? _badCertificateCallback;\n\n  Duration get idleTimeout => _idleTimeout;\n\n  Duration? connectionTimeout;\n\n  int? maxConnectionsPerHost;\n\n  bool autoUncompress = true;\n\n  String? userAgent = _getHttpVersion();\n\n  _HttpClient(this._context);\n\n  void set idleTimeout(Duration timeout) {\n    _idleTimeout = timeout;\n    for (var c in _connectionTargets.values) {\n      for (var idle in c._idle) {\n        // Reset timer. This is fine, as it's not happening often.\n        idle.stopTimer();\n        idle.startTimer();\n      }\n    }\n  }\n\n  set badCertificateCallback(\n      bool Function(X509Certificate cert, String host, int port)? callback) {\n    _badCertificateCallback = callback;\n  }\n\n  Future<HttpClientRequest> open(\n      String method, String host, int port, String path) {\n    const int hashMark = 0x23;\n    const int questionMark = 0x3f;\n    int fragmentStart = path.length;\n    int queryStart = path.length;\n    for (int i = path.length - 1; i >= 0; i--) {\n      var char = path.codeUnitAt(i);\n      if (char == hashMark) {\n        fragmentStart = i;\n        queryStart = i;\n      } else if (char == questionMark) {\n        queryStart = i;\n      }\n    }\n    String? query;\n    if (queryStart < fragmentStart) {\n      query = path.substring(queryStart + 1, fragmentStart);\n      path = path.substring(0, queryStart);\n    }\n    Uri uri =\n        Uri(scheme: \"http\", host: host, port: port, path: path, query: query);\n    return _openUrl(method, uri);\n  }\n\n  Future<HttpClientRequest> openUrl(String method, Uri url) =>\n      _openUrl(method, url);\n\n  Future<HttpClientRequest> get(String host, int port, String path) =>\n      open(\"get\", host, port, path);\n\n  Future<HttpClientRequest> getUrl(Uri url) => _openUrl(\"get\", url);\n\n  Future<HttpClientRequest> post(String host, int port, String path) =>\n      open(\"post\", host, port, path);\n\n  Future<HttpClientRequest> postUrl(Uri url) => _openUrl(\"post\", url);\n\n  Future<HttpClientRequest> put(String host, int port, String path) =>\n      open(\"put\", host, port, path);\n\n  Future<HttpClientRequest> putUrl(Uri url) => _openUrl(\"put\", url);\n\n  Future<HttpClientRequest> delete(String host, int port, String path) =>\n      open(\"delete\", host, port, path);\n\n  Future<HttpClientRequest> deleteUrl(Uri url) => _openUrl(\"delete\", url);\n\n  Future<HttpClientRequest> head(String host, int port, String path) =>\n      open(\"head\", host, port, path);\n\n  Future<HttpClientRequest> headUrl(Uri url) => _openUrl(\"head\", url);\n\n  Future<HttpClientRequest> patch(String host, int port, String path) =>\n      open(\"patch\", host, port, path);\n\n  Future<HttpClientRequest> patchUrl(Uri url) => _openUrl(\"patch\", url);\n\n  void close({bool force = false}) {\n    _closing = true;\n    _closingForcefully = force;\n    _closeConnections(_closingForcefully);\n    assert(!_connectionTargets.values.any((s) => s.hasIdle));\n    assert(\n        !force || !_connectionTargets.values.any((s) => s._active.isNotEmpty));\n  }\n\n  set authenticate(\n      Future<bool> Function(Uri url, String scheme, String? realm)? f) {\n    _authenticate = f;\n  }\n\n  void addCredentials(Uri url, String realm, HttpClientCredentials cr) {\n    _credentials\n        .add(_SiteCredentials(url, realm, cr as _HttpClientCredentials));\n  }\n\n  set authenticateProxy(\n      Future<bool> Function(\n              String host, int port, String scheme, String? realm)?\n          f) {\n    _authenticateProxy = f;\n  }\n\n  void addProxyCredentials(\n      String host, int port, String realm, HttpClientCredentials cr) {\n    _proxyCredentials.add(\n        _ProxyCredentials(host, port, realm, cr as _HttpClientCredentials));\n  }\n\n  set findProxy(String Function(Uri uri)? f) => _findProxy = f;\n\n  static void _startRequestTimelineEvent(\n      TimelineTask? timeline, String method, Uri uri) {\n    timeline?.start('HTTP CLIENT ${method.toUpperCase()}', arguments: {\n      'method': method.toUpperCase(),\n      'uri': uri.toString(),\n    });\n  }\n\n  bool _isLoopback(String host) {\n    if (host.isEmpty) return false;\n    if (\"localhost\" == host) return true;\n    try {\n      return InternetAddress(host).isLoopback;\n    } on ArgumentError {\n      return false;\n    }\n  }\n\n  Future<_HttpClientRequest> _openUrl(String method, Uri uri) {\n    if (_closing) {\n      throw StateError(\"Client is closed\");\n    }\n\n    // Ignore any fragments on the request URI.\n    uri = uri.removeFragment();\n\n    if (method == null) {\n      throw ArgumentError(method);\n    }\n    if (method != \"CONNECT\") {\n      if (uri.host.isEmpty) {\n        throw ArgumentError(\"No host specified in URI $uri\");\n      } else if (uri.scheme != \"http\" && uri.scheme != \"https\") {\n        throw ArgumentError(\"Unsupported scheme '${uri.scheme}' in URI $uri\");\n      }\n    }\n\n    _httpConnectionHook(uri);\n\n    bool isSecure = uri.isScheme(\"https\");\n\n    int port = uri.port;\n    if (port == 0) {\n      port =\n          isSecure ? HttpClient.defaultHttpsPort : HttpClient.defaultHttpPort;\n    }\n    // Check to see if a proxy server should be used for this connection.\n    var proxyConf = const _ProxyConfiguration.direct();\n    var findProxy = _findProxy;\n    if (findProxy != null) {\n      // TODO(sgjesse): Keep a map of these as normally only a few\n      // configuration strings will be used.\n      try {\n        proxyConf = _ProxyConfiguration(findProxy(uri));\n      } catch (error, stackTrace) {\n        return Future.error(error, stackTrace);\n      }\n    }\n    _HttpProfileData? profileData;\n    if (HttpClient.enableTimelineLogging) {\n      profileData = HttpProfiler.startRequest(method, uri);\n    }\n    return _getConnection(uri.host, port, proxyConf, isSecure, profileData)\n        .then((_ConnectionInfo info) {\n      _HttpClientRequest send(_ConnectionInfo info) {\n        profileData?.requestEvent('Connection established');\n        return info.connection\n            .send(uri, port, method.toUpperCase(), info.proxy, profileData);\n      }\n\n      // If the connection was closed before the request was sent, create\n      // and use another connection.\n      if (info.connection.closed) {\n        return _getConnection(uri.host, port, proxyConf, isSecure, profileData)\n            .then(send);\n      }\n      return send(info);\n    }, onError: (error) {\n      profileData?.finishRequestWithError(error.toString());\n      throw error;\n    });\n  }\n\n  static bool _isSubdomain(Uri subdomain, Uri domain) {\n    return (subdomain.scheme == domain.scheme &&\n        subdomain.port == domain.port &&\n        (subdomain.host == domain.host ||\n            subdomain.host.endsWith(\".\" + domain.host)));\n  }\n\n  static bool _shouldCopyHeaderOnRedirect(\n      String headerKey, Uri originalUrl, Uri redirectUri) {\n    if (_isSubdomain(redirectUri, originalUrl)) {\n      return true;\n    }\n\n    const nonRedirectHeaders = [\n      \"authorization\",\n      \"www-authenticate\",\n      \"cookie\",\n      \"cookie2\"\n    ];\n    return !nonRedirectHeaders.contains(headerKey.toLowerCase());\n  }\n\n  Future<_HttpClientRequest> _openUrlFromRequest(\n      String method, Uri uri, _HttpClientRequest previous,\n      {required bool isRedirect}) {\n    // If the new URI is relative (to either '/' or some sub-path),\n    // construct a full URI from the previous one.\n    Uri resolved = previous.uri.resolveUri(uri);\n    return _openUrl(method, resolved).then((_HttpClientRequest request) {\n      request\n        // Only follow redirects if initial request did.\n        ..followRedirects = previous.followRedirects\n        // Allow same number of redirects.\n        ..maxRedirects = previous.maxRedirects;\n      // Copy headers.\n      for (var header in previous.headers._headers.keys) {\n        if (request.headers[header] == null &&\n            (!isRedirect ||\n                _shouldCopyHeaderOnRedirect(header, resolved, previous.uri))) {\n          request.headers.set(header, previous.headers[header]!);\n        }\n      }\n      return request\n        ..headers.chunkedTransferEncoding = false\n        ..contentLength = 0;\n    });\n  }\n\n  // Return a live connection to the idle pool.\n  void _returnConnection(_HttpClientConnection connection) {\n    _connectionTargets[connection.key]!.returnConnection(connection);\n    _connectionsChanged();\n  }\n\n  // Remove a closed connection from the active set.\n  void _connectionClosed(_HttpClientConnection connection) {\n    connection.stopTimer();\n    var connectionTarget = _connectionTargets[connection.key];\n    if (connectionTarget != null) {\n      connectionTarget.connectionClosed(connection);\n      if (connectionTarget.isEmpty) {\n        _connectionTargets.remove(connection.key);\n      }\n      _connectionsChanged();\n    }\n  }\n\n  // Remove a closed connection and not issue _closeConnections(). If the close\n  // is signaled from user by calling close(), _closeConnections() was called\n  // and prevent further calls.\n  void _connectionClosedNoFurtherClosing(_HttpClientConnection connection) {\n    connection.stopTimer();\n    var connectionTarget = _connectionTargets[connection.key];\n    if (connectionTarget != null) {\n      connectionTarget.connectionClosed(connection);\n      if (connectionTarget.isEmpty) {\n        _connectionTargets.remove(connection.key);\n      }\n    }\n  }\n\n  void _connectionsChanged() {\n    if (_closing) {\n      _closeConnections(_closingForcefully);\n    }\n  }\n\n  void _closeConnections(bool force) {\n    for (var connectionTarget in _connectionTargets.values.toList()) {\n      connectionTarget.close(force);\n    }\n  }\n\n  _ConnectionTarget _getConnectionTarget(String host, int port, bool isSecure) {\n    String key = _HttpClientConnection.makeKey(isSecure, host, port);\n    return _connectionTargets.putIfAbsent(key, () {\n      return _ConnectionTarget(key, host, port, isSecure, _context);\n    });\n  }\n\n  // Get a new _HttpClientConnection, from the matching _ConnectionTarget.\n  Future<_ConnectionInfo> _getConnection(\n      String uriHost,\n      int uriPort,\n      _ProxyConfiguration proxyConf,\n      bool isSecure,\n      _HttpProfileData? profileData) {\n    Iterator<_Proxy> proxies = proxyConf.proxies.iterator;\n\n    Future<_ConnectionInfo> connect(error, stackTrace) {\n      if (!proxies.moveNext()) return Future.error(error, stackTrace);\n      _Proxy proxy = proxies.current;\n      String host = proxy.isDirect ? uriHost : proxy.host!;\n      int port = proxy.isDirect ? uriPort : proxy.port!;\n      return _getConnectionTarget(host, port, isSecure)\n          .connect(uriHost, uriPort, proxy, this, profileData)\n          // On error, continue with next proxy.\n          .catchError(connect);\n    }\n\n    return connect(HttpException(\"No proxies given\"), StackTrace.current);\n  }\n\n  _SiteCredentials? _findCredentials(Uri url, [_AuthenticationScheme? scheme]) {\n    // Look for credentials.\n    _SiteCredentials? cr =\n        _credentials.fold(null, (_SiteCredentials? prev, value) {\n      var siteCredentials = value as _SiteCredentials;\n      if (siteCredentials.applies(url, scheme)) {\n        if (prev == null) return value;\n        return siteCredentials.uri.path.length > prev.uri.path.length\n            ? siteCredentials\n            : prev;\n      } else {\n        return prev;\n      }\n    });\n    return cr;\n  }\n\n  _ProxyCredentials? _findProxyCredentials(_Proxy proxy,\n      [_AuthenticationScheme? scheme]) {\n    // Look for credentials.\n    for (var current in _proxyCredentials) {\n      if (current.applies(proxy, scheme)) {\n        return current;\n      }\n    }\n    return null;\n  }\n\n  void _removeCredentials(_Credentials cr) {\n    int index = _credentials.indexOf(cr);\n    if (index != -1) {\n      _credentials.removeAt(index);\n    }\n  }\n\n  void _removeProxyCredentials(_Credentials cr) {\n    _proxyCredentials.remove(cr);\n  }\n\n  static String _findProxyFromEnvironment(\n      Uri url, Map<String, String>? environment) {\n    String? checkNoProxy(String? option) {\n      if (option == null) return null;\n      Iterator<String> names = option.split(\",\").map((s) => s.trim()).iterator;\n      while (names.moveNext()) {\n        var name = names.current;\n        if ((name.startsWith(\"[\") &&\n                name.endsWith(\"]\") &&\n                \"[${url.host}]\" == name) ||\n            (name.isNotEmpty && url.host.endsWith(name))) {\n          return \"DIRECT\";\n        }\n      }\n      return null;\n    }\n\n    String? checkProxy(String? option) {\n      if (option == null) return null;\n      option = option.trim();\n      if (option.isEmpty) return null;\n      int pos = option.indexOf(\"://\");\n      if (pos >= 0) {\n        option = option.substring(pos + 3);\n      }\n      pos = option.indexOf(\"/\");\n      if (pos >= 0) {\n        option = option.substring(0, pos);\n      }\n      // Add default port if no port configured.\n      if (option.indexOf(\"[\") == 0) {\n        var pos = option.lastIndexOf(\":\");\n        if (option.indexOf(\"]\") > pos) option = \"$option:1080\";\n      } else {\n        if (!option.contains(\":\")) option = \"$option:1080\";\n      }\n      return \"PROXY $option\";\n    }\n\n    // Default to using the process current environment.\n    environment ??= _platformEnvironmentCache;\n\n    String? proxyCfg;\n\n    String? noProxy = environment[\"no_proxy\"] ?? environment[\"NO_PROXY\"];\n    proxyCfg = checkNoProxy(noProxy);\n    if (proxyCfg != null) {\n      return proxyCfg;\n    }\n\n    if (url.scheme == \"http\") {\n      String? proxy = environment[\"http_proxy\"] ?? environment[\"HTTP_PROXY\"];\n      proxyCfg = checkProxy(proxy);\n      if (proxyCfg != null) {\n        return proxyCfg;\n      }\n    } else if (url.scheme == \"https\") {\n      String? proxy = environment[\"https_proxy\"] ?? environment[\"HTTPS_PROXY\"];\n      proxyCfg = checkProxy(proxy);\n      if (proxyCfg != null) {\n        return proxyCfg;\n      }\n    }\n    return \"DIRECT\";\n  }\n\n  static final Map<String, String> _platformEnvironmentCache =\n      Platform.environment;\n}\n\nclass _HttpConnection extends LinkedListEntry<_HttpConnection>\n    with _ServiceObject {\n  static const _ACTIVE = 0;\n  static const _IDLE = 1;\n  static const _CLOSING = 2;\n  static const _DETACHED = 3;\n\n  // Use HashMap, as we don't need to keep order.\n  static final Map<int, _HttpConnection> _connections =\n      HashMap<int, _HttpConnection>();\n\n  final /*_ServerSocket*/ _socket;\n  final _HttpServer _httpServer;\n  final _HttpParser _httpParser;\n  int _state = _IDLE;\n  StreamSubscription? _subscription;\n  bool _idleMark = false;\n  Future? _streamFuture;\n\n  _HttpConnection(this._socket, this._httpServer)\n      : _httpParser = _HttpParser.requestParser() {\n    _connections[_serviceId] = this;\n    _httpParser.listenToStream(_socket);\n    _subscription = _httpParser.listen((incoming) {\n      _httpServer._markActive(this);\n      // If the incoming was closed, close the connection.\n      incoming.dataDone.then((closing) {\n        if (closing) destroy();\n      });\n      // Only handle one incoming request at the time. Keep the\n      // stream paused until the request has been send.\n      _subscription!.pause();\n      _state = _ACTIVE;\n      var outgoing = _HttpOutgoing(_socket);\n      var response = _HttpResponse(\n          incoming.uri!,\n          incoming.headers.protocolVersion,\n          outgoing,\n          _httpServer.defaultResponseHeaders,\n          _httpServer.serverHeader);\n      // Parser found badRequest and sent out Response.\n      if (incoming.statusCode == HttpStatus.badRequest) {\n        response.statusCode = HttpStatus.badRequest;\n      }\n      var request = _HttpRequest(response, incoming, _httpServer, this);\n      _streamFuture = outgoing.done.then((_) {\n        response.deadline = null;\n        if (_state == _DETACHED) return;\n        if (response.persistentConnection &&\n            request.persistentConnection &&\n            incoming.fullBodyRead &&\n            !_httpParser.upgrade &&\n            !_httpServer.closed) {\n          _state = _IDLE;\n          _idleMark = false;\n          _httpServer._markIdle(this);\n          // Resume the subscription for incoming requests as the\n          // request is now processed.\n          _subscription!.resume();\n        } else {\n          // Close socket, keep-alive not used or body sent before\n          // received data was handled.\n          destroy();\n        }\n      }, onError: (_) {\n        destroy();\n      });\n      outgoing.ignoreBody = request.method == \"HEAD\";\n      response._httpRequest = request;\n      _httpServer._handleRequest(request);\n    }, onDone: () {\n      destroy();\n    }, onError: (error) {\n      // Ignore failed requests that was closed before headers was received.\n      destroy();\n    });\n  }\n\n  void markIdle() {\n    _idleMark = true;\n  }\n\n  bool get isMarkedIdle => _idleMark;\n\n  void destroy() {\n    if (_state == _CLOSING || _state == _DETACHED) return;\n    _state = _CLOSING;\n    _socket.destroy();\n    _httpServer._connectionClosed(this);\n    _connections.remove(_serviceId);\n  }\n\n  Future<Socket> detachSocket() {\n    _state = _DETACHED;\n    // Remove connection from server.\n    _httpServer._connectionClosed(this);\n\n    _HttpDetachedIncoming detachedIncoming = _httpParser.detachIncoming();\n\n    return _streamFuture!.then((_) {\n      _connections.remove(_serviceId);\n      return _DetachedSocket(_socket, detachedIncoming);\n    });\n  }\n\n  HttpConnectionInfo? get connectionInfo => _HttpConnectionInfo.create(_socket);\n\n  bool get _isActive => _state == _ACTIVE;\n  bool get _isIdle => _state == _IDLE;\n  bool get _isClosing => _state == _CLOSING;\n  bool get _isDetached => _state == _DETACHED;\n\n  String get _serviceTypePath => 'io/http/serverconnections';\n  String get _serviceTypeName => 'HttpServerConnection';\n\n  Map _toJSON(bool ref) {\n    var name = \"${_socket.address.host}:${_socket.port} <-> \"\n        \"${_socket.remoteAddress.host}:${_socket.remotePort}\";\n    var r = <String, dynamic>{\n      'id': _servicePath,\n      'type': _serviceType(ref),\n      'name': name,\n      'user_name': name,\n    };\n    if (ref) {\n      return r;\n    }\n    r['server'] = _httpServer._toJSON(true);\n    try {\n      r['socket'] = _socket._toJSON(true);\n    } catch (_) {\n      r['socket'] = {\n        'id': _servicePath,\n        'type': '@Socket',\n        'name': 'UserSocket',\n        'user_name': 'UserSocket',\n      };\n    }\n    switch (_state) {\n      case _ACTIVE:\n        r['state'] = \"Active\";\n        break;\n      case _IDLE:\n        r['state'] = \"Idle\";\n        break;\n      case _CLOSING:\n        r['state'] = \"Closing\";\n        break;\n      case _DETACHED:\n        r['state'] = \"Detached\";\n        break;\n      default:\n        r['state'] = 'Unknown';\n        break;\n    }\n    return r;\n  }\n}\n\n// HTTP server waiting for socket connections.\nclass _HttpServer extends Stream<HttpRequest>\n    with _ServiceObject\n    implements HttpServer {\n  // Use default Map so we keep order.\n  static final Map<int, _HttpServer> _servers = <int, _HttpServer>{};\n\n  String? serverHeader;\n  final HttpHeaders defaultResponseHeaders = _initDefaultResponseHeaders();\n  bool autoCompress = false;\n\n  Duration? _idleTimeout;\n  Timer? _idleTimer;\n\n  static Future<HttpServer> bind(\n      address, int port, int backlog, bool v6Only, bool shared) {\n    return ServerSocket.bind(address, port,\n            backlog: backlog, v6Only: v6Only, shared: shared)\n        .then<HttpServer>((socket) {\n      return _HttpServer._(socket, true);\n    });\n  }\n\n  static Future<HttpServer> bindSecure(\n      address,\n      int port,\n      SecurityContext? context,\n      int backlog,\n      bool v6Only,\n      bool requestClientCertificate,\n      bool shared) {\n    return SecureServerSocket.bind(address, port, context,\n            backlog: backlog,\n            v6Only: v6Only,\n            requestClientCertificate: requestClientCertificate,\n            shared: shared)\n        .then<HttpServer>((socket) {\n      return _HttpServer._(socket, true);\n    });\n  }\n\n  _HttpServer._(this._serverSocket, this._closeServer)\n      : _controller = StreamController<HttpRequest>(sync: true) {\n    _controller.onCancel = close;\n    idleTimeout = const Duration(seconds: 120);\n    _servers[_serviceId] = this;\n  }\n\n  _HttpServer.listenOn(this._serverSocket)\n      : _closeServer = false,\n        _controller = StreamController<HttpRequest>(sync: true) {\n    _controller.onCancel = close;\n    idleTimeout = const Duration(seconds: 120);\n    _servers[_serviceId] = this;\n  }\n\n  static HttpHeaders _initDefaultResponseHeaders() {\n    var defaultResponseHeaders = _HttpHeaders('1.1');\n    defaultResponseHeaders.contentType = ContentType.text;\n    defaultResponseHeaders.set('X-Frame-Options', 'SAMEORIGIN');\n    defaultResponseHeaders.set('X-Content-Type-Options', 'nosniff');\n    defaultResponseHeaders.set('X-XSS-Protection', '1; mode=block');\n    return defaultResponseHeaders;\n  }\n\n  Duration? get idleTimeout => _idleTimeout;\n\n  void set idleTimeout(Duration? duration) {\n    var idleTimer = _idleTimer;\n    if (idleTimer != null) {\n      idleTimer.cancel();\n      _idleTimer = null;\n    }\n    _idleTimeout = duration;\n    if (duration != null) {\n      _idleTimer = Timer.periodic(duration, (_) {\n        for (var idle in _idleConnections.toList()) {\n          if (idle.isMarkedIdle) {\n            idle.destroy();\n          } else {\n            idle.markIdle();\n          }\n        }\n      });\n    }\n  }\n\n  StreamSubscription<HttpRequest> listen(\n      void Function(HttpRequest event)? onData,\n      {Function? onError,\n      void Function()? onDone,\n      bool? cancelOnError}) {\n    _serverSocket.listen((Socket socket) {\n      if (socket.address.type != InternetAddressType.unix) {\n        socket.setOption(SocketOption.tcpNoDelay, true);\n      }\n      // Accept the client connection.\n      _HttpConnection connection = _HttpConnection(socket, this);\n      _idleConnections.add(connection);\n    }, onError: (error, stackTrace) {\n      // Ignore HandshakeExceptions as they are bound to a single request,\n      // and are not fatal for the server.\n      if (error is! HandshakeException) {\n        _controller.addError(error, stackTrace);\n      }\n    }, onDone: _controller.close);\n    return _controller.stream.listen(onData,\n        onError: onError, onDone: onDone, cancelOnError: cancelOnError);\n  }\n\n  Future close({bool force = false}) {\n    closed = true;\n    Future result;\n    if (_serverSocket != null && _closeServer) {\n      result = _serverSocket.close();\n    } else {\n      result = Future.value();\n    }\n    idleTimeout = null;\n    if (force) {\n      for (var c in _activeConnections.toList()) {\n        c.destroy();\n      }\n      assert(_activeConnections.isEmpty);\n    }\n    for (var c in _idleConnections.toList()) {\n      c.destroy();\n    }\n    _maybePerformCleanup();\n    return result;\n  }\n\n  void _maybePerformCleanup() {\n    var sessionManager = _sessionManagerInstance;\n    if (closed &&\n        _idleConnections.isEmpty &&\n        _activeConnections.isEmpty &&\n        sessionManager != null) {\n      sessionManager.close();\n      _sessionManagerInstance = null;\n      _servers.remove(_serviceId);\n    }\n  }\n\n  int get port {\n    if (closed) throw HttpException(\"HttpServer is not bound to a socket\");\n    return _serverSocket.port;\n  }\n\n  InternetAddress get address {\n    if (closed) throw HttpException(\"HttpServer is not bound to a socket\");\n    return _serverSocket.address;\n  }\n\n  set sessionTimeout(int timeout) {\n    _sessionManager.sessionTimeout = timeout;\n  }\n\n  void _handleRequest(_HttpRequest request) {\n    if (!closed) {\n      _controller.add(request);\n    } else {\n      request._httpConnection.destroy();\n    }\n  }\n\n  void _connectionClosed(_HttpConnection connection) {\n    // Remove itself from either idle or active connections.\n    connection.unlink();\n    _maybePerformCleanup();\n  }\n\n  void _markIdle(_HttpConnection connection) {\n    _activeConnections.remove(connection);\n    _idleConnections.add(connection);\n  }\n\n  void _markActive(_HttpConnection connection) {\n    _idleConnections.remove(connection);\n    _activeConnections.add(connection);\n  }\n\n  // Lazy init.\n  _HttpSessionManager get _sessionManager =>\n      _sessionManagerInstance ??= _HttpSessionManager();\n\n  HttpConnectionsInfo connectionsInfo() {\n    HttpConnectionsInfo result = HttpConnectionsInfo();\n    result.total = _activeConnections.length + _idleConnections.length;\n    for (var conn in _activeConnections) {\n      if (conn._isActive) {\n        result.active++;\n      } else {\n        assert(conn._isClosing);\n        result.closing++;\n      }\n    }\n    for (var conn in _idleConnections) {\n      result.idle++;\n      assert(conn._isIdle);\n    }\n    return result;\n  }\n\n  String get _serviceTypePath => 'io/http/servers';\n  String get _serviceTypeName => 'HttpServer';\n\n  Map<String, dynamic> _toJSON(bool ref) {\n    var r = <String, dynamic>{\n      'id': _servicePath,\n      'type': _serviceType(ref),\n      'name': '${address.host}:$port',\n      'user_name': '${address.host}:$port',\n    };\n    if (ref) {\n      return r;\n    }\n    try {\n      r['socket'] = _serverSocket._toJSON(true);\n    } catch (_) {\n      r['socket'] = {\n        'id': _servicePath,\n        'type': '@Socket',\n        'name': 'UserSocket',\n        'user_name': 'UserSocket',\n      };\n    }\n    r['port'] = port;\n    r['address'] = address.host;\n    r['active'] = _activeConnections.map((c) => c._toJSON(true)).toList();\n    r['idle'] = _idleConnections.map((c) => c._toJSON(true)).toList();\n    r['closed'] = closed;\n    return r;\n  }\n\n  _HttpSessionManager? _sessionManagerInstance;\n\n  // Indicated if the http server has been closed.\n  bool closed = false;\n\n  // The server listen socket. Untyped as it can be both ServerSocket and\n  // SecureServerSocket.\n  final dynamic /*ServerSocket|SecureServerSocket*/ _serverSocket;\n  final bool _closeServer;\n\n  // Set of currently connected clients.\n  final LinkedList<_HttpConnection> _activeConnections =\n      LinkedList<_HttpConnection>();\n  final LinkedList<_HttpConnection> _idleConnections =\n      LinkedList<_HttpConnection>();\n  final StreamController<HttpRequest> _controller;\n}\n\nclass _ProxyConfiguration {\n  static const String PROXY_PREFIX = \"PROXY \";\n  static const String DIRECT_PREFIX = \"DIRECT\";\n\n  _ProxyConfiguration(String configuration) : proxies = <_Proxy>[] {\n    if (configuration == null) {\n      throw HttpException(\"Invalid proxy configuration $configuration\");\n    }\n    List<String> list = configuration.split(\";\");\n    for (var proxy in list) {\n      proxy = proxy.trim();\n      if (proxy.isNotEmpty) {\n        if (proxy.startsWith(PROXY_PREFIX)) {\n          String? username;\n          String? password;\n          // Skip the \"PROXY \" prefix.\n          proxy = proxy.substring(PROXY_PREFIX.length).trim();\n          // Look for proxy authentication.\n          int at = proxy.indexOf(\"@\");\n          if (at != -1) {\n            String userinfo = proxy.substring(0, at).trim();\n            proxy = proxy.substring(at + 1).trim();\n            int colon = userinfo.indexOf(\":\");\n            if (colon == -1 || colon == 0 || colon == proxy.length - 1) {\n              throw HttpException(\"Invalid proxy configuration $configuration\");\n            }\n            username = userinfo.substring(0, colon).trim();\n            password = userinfo.substring(colon + 1).trim();\n          }\n          // Look for proxy host and port.\n          int colon = proxy.lastIndexOf(\":\");\n          if (colon == -1 || colon == 0 || colon == proxy.length - 1) {\n            throw HttpException(\"Invalid proxy configuration $configuration\");\n          }\n          String host = proxy.substring(0, colon).trim();\n          if (host.startsWith(\"[\") && host.endsWith(\"]\")) {\n            host = host.substring(1, host.length - 1);\n          }\n          String portString = proxy.substring(colon + 1).trim();\n          int port;\n          try {\n            port = int.parse(portString);\n          } on FormatException {\n            throw HttpException(\"Invalid proxy configuration $configuration, \"\n                \"invalid port '$portString'\");\n          }\n          proxies.add(_Proxy(host, port, username, password));\n        } else if (proxy.trim() == DIRECT_PREFIX) {\n          proxies.add(_Proxy.direct());\n        } else {\n          throw HttpException(\"Invalid proxy configuration $configuration\");\n        }\n      }\n    }\n  }\n\n  const _ProxyConfiguration.direct() : proxies = const [_Proxy.direct()];\n\n  final List<_Proxy> proxies;\n}\n\nclass _Proxy {\n  final String? host;\n  final int? port;\n  final String? username;\n  final String? password;\n  final bool isDirect;\n\n  const _Proxy(String this.host, int this.port, this.username, this.password)\n      : isDirect = false;\n  const _Proxy.direct()\n      : host = null,\n        port = null,\n        username = null,\n        password = null,\n        isDirect = true;\n\n  bool get isAuthenticated => username != null;\n}\n\nclass _HttpConnectionInfo implements HttpConnectionInfo {\n  InternetAddress remoteAddress;\n  int remotePort;\n  int localPort;\n\n  _HttpConnectionInfo(this.remoteAddress, this.remotePort, this.localPort);\n\n  static _HttpConnectionInfo? create(Socket socket) {\n    if (socket == null) return null;\n    try {\n      return _HttpConnectionInfo(\n          socket.remoteAddress, socket.remotePort, socket.port);\n    } catch (e) {}\n    return null;\n  }\n}\n\nclass _DetachedSocket extends Stream<Uint8List> implements Socket {\n  final Stream<Uint8List> _incoming;\n  final Socket _socket;\n\n  _DetachedSocket(this._socket, this._incoming);\n\n  StreamSubscription<Uint8List> listen(void Function(Uint8List event)? onData,\n      {Function? onError, void Function()? onDone, bool? cancelOnError}) {\n    return _incoming.listen(onData,\n        onError: onError, onDone: onDone, cancelOnError: cancelOnError);\n  }\n\n  Encoding get encoding => _socket.encoding;\n\n  void set encoding(Encoding value) {\n    _socket.encoding = value;\n  }\n\n  void write(Object? obj) {\n    _socket.write(obj);\n  }\n\n  void writeln([Object? obj = \"\"]) {\n    _socket.writeln(obj);\n  }\n\n  void writeCharCode(int charCode) {\n    _socket.writeCharCode(charCode);\n  }\n\n  void writeAll(Iterable objects, [String separator = \"\"]) {\n    _socket.writeAll(objects, separator);\n  }\n\n  void add(List<int> bytes) {\n    _socket.add(bytes);\n  }\n\n  void addError(Object error, [StackTrace? stackTrace]) =>\n      _socket.addError(error, stackTrace);\n\n  Future addStream(Stream<List<int>> stream) {\n    return _socket.addStream(stream);\n  }\n\n  void destroy() {\n    _socket.destroy();\n  }\n\n  Future flush() => _socket.flush();\n\n  Future close() => _socket.close();\n\n  Future get done => _socket.done;\n\n  int get port => _socket.port;\n\n  InternetAddress get address => _socket.address;\n\n  InternetAddress get remoteAddress => _socket.remoteAddress;\n\n  int get remotePort => _socket.remotePort;\n\n  bool setOption(SocketOption option, bool enabled) {\n    return _socket.setOption(option, enabled);\n  }\n\n  Uint8List getRawOption(RawSocketOption option) {\n    return _socket.getRawOption(option);\n  }\n\n  void setRawOption(RawSocketOption option) {\n    _socket.setRawOption(option);\n  }\n\n  Map _toJSON(bool ref) {\n    return (_socket as dynamic)._toJSON(ref);\n  }\n}\n\nclass _AuthenticationScheme {\n  final int _scheme;\n\n  static const UNKNOWN = _AuthenticationScheme(-1);\n  static const BASIC = _AuthenticationScheme(0);\n  static const DIGEST = _AuthenticationScheme(1);\n\n  const _AuthenticationScheme(this._scheme);\n\n  factory _AuthenticationScheme.fromString(String scheme) {\n    if (scheme.toLowerCase() == \"basic\") return BASIC;\n    if (scheme.toLowerCase() == \"digest\") return DIGEST;\n    return UNKNOWN;\n  }\n\n  String toString() {\n    if (this == BASIC) return \"Basic\";\n    if (this == DIGEST) return \"Digest\";\n    return \"Unknown\";\n  }\n}\n\nabstract class _Credentials {\n  _HttpClientCredentials credentials;\n  String realm;\n  bool used = false;\n\n  // Digest specific fields.\n  String? ha1;\n  String? nonce;\n  String? algorithm;\n  String? qop;\n  int? nonceCount;\n\n  _Credentials(this.credentials, this.realm) {\n    if (credentials.scheme == _AuthenticationScheme.DIGEST) {\n      // Calculate the H(A1) value once. There is no mentioning of\n      // username/password encoding in RFC 2617. However there is an\n      // open draft for adding an additional accept-charset parameter to\n      // the WWW-Authenticate and Proxy-Authenticate headers, see\n      // http://tools.ietf.org/html/draft-reschke-basicauth-enc-06. For\n      // now always use UTF-8 encoding.\n      var creds = credentials as _HttpClientDigestCredentials;\n      var hasher = _MD5()\n        ..add(utf8.encode(creds.username))\n        ..add([_CharCode.COLON])\n        ..add(realm.codeUnits)\n        ..add([_CharCode.COLON])\n        ..add(utf8.encode(creds.password));\n      ha1 = _CryptoUtils.bytesToHex(hasher.close());\n    }\n  }\n\n  _AuthenticationScheme get scheme => credentials.scheme;\n\n  void authorize(HttpClientRequest request);\n}\n\nclass _SiteCredentials extends _Credentials {\n  Uri uri;\n\n  _SiteCredentials(this.uri, realm, _HttpClientCredentials creds)\n      : super(creds, realm);\n\n  bool applies(Uri uri, _AuthenticationScheme? scheme) {\n    if (scheme != null && credentials.scheme != scheme) return false;\n    if (uri.host != this.uri.host) return false;\n    int thisPort =\n        this.uri.port == 0 ? HttpClient.defaultHttpPort : this.uri.port;\n    int otherPort = uri.port == 0 ? HttpClient.defaultHttpPort : uri.port;\n    if (otherPort != thisPort) return false;\n    return uri.path.startsWith(this.uri.path);\n  }\n\n  void authorize(HttpClientRequest request) {\n    // Digest credentials cannot be used without a nonce from the\n    // server.\n    if (credentials.scheme == _AuthenticationScheme.DIGEST && nonce == null) {\n      return;\n    }\n    credentials.authorize(this, request as _HttpClientRequest);\n    used = true;\n  }\n}\n\nclass _ProxyCredentials extends _Credentials {\n  String host;\n  int port;\n\n  _ProxyCredentials(this.host, this.port, realm, _HttpClientCredentials creds)\n      : super(creds, realm);\n\n  bool applies(_Proxy proxy, _AuthenticationScheme? scheme) {\n    if (scheme != null && credentials.scheme != scheme) return false;\n    return proxy.host == host && proxy.port == port;\n  }\n\n  void authorize(HttpClientRequest request) {\n    // Digest credentials cannot be used without a nonce from the\n    // server.\n    if (credentials.scheme == _AuthenticationScheme.DIGEST && nonce == null) {\n      return;\n    }\n    credentials.authorizeProxy(this, request as _HttpClientRequest);\n  }\n}\n\nabstract class _HttpClientCredentials implements HttpClientCredentials {\n  _AuthenticationScheme get scheme;\n  void authorize(_Credentials credentials, _HttpClientRequest request);\n  void authorizeProxy(_ProxyCredentials credentials, HttpClientRequest request);\n}\n\nclass _HttpClientBasicCredentials extends _HttpClientCredentials\n    implements HttpClientBasicCredentials {\n  String username;\n  String password;\n\n  _HttpClientBasicCredentials(this.username, this.password);\n\n  _AuthenticationScheme get scheme => _AuthenticationScheme.BASIC;\n\n  String authorization() {\n    // There is no mentioning of username/password encoding in RFC\n    // 2617. However there is an open draft for adding an additional\n    // accept-charset parameter to the WWW-Authenticate and\n    // Proxy-Authenticate headers, see\n    // http://tools.ietf.org/html/draft-reschke-basicauth-enc-06. For\n    // now always use UTF-8 encoding.\n    String auth = base64Encode(utf8.encode(\"$username:$password\"));\n    return \"Basic $auth\";\n  }\n\n  void authorize(_Credentials _, HttpClientRequest request) {\n    request.headers.set(HttpHeaders.authorizationHeader, authorization());\n  }\n\n  void authorizeProxy(_ProxyCredentials _, HttpClientRequest request) {\n    request.headers.set(HttpHeaders.proxyAuthorizationHeader, authorization());\n  }\n}\n\nclass _HttpClientDigestCredentials extends _HttpClientCredentials\n    implements HttpClientDigestCredentials {\n  String username;\n  String password;\n\n  _HttpClientDigestCredentials(this.username, this.password);\n\n  _AuthenticationScheme get scheme => _AuthenticationScheme.DIGEST;\n\n  String authorization(_Credentials credentials, _HttpClientRequest request) {\n    String requestUri = request._requestUri();\n    _MD5 hasher = _MD5()\n      ..add(request.method.codeUnits)\n      ..add([_CharCode.COLON])\n      ..add(requestUri.codeUnits);\n    var ha2 = _CryptoUtils.bytesToHex(hasher.close());\n\n    bool isAuth = false;\n    String cnonce = \"\";\n    String nc = \"\";\n    hasher = _MD5()\n      ..add(credentials.ha1!.codeUnits)\n      ..add([_CharCode.COLON]);\n    if (credentials.qop == \"auth\") {\n      isAuth = true;\n      cnonce = _CryptoUtils.bytesToHex(_CryptoUtils.getRandomBytes(4));\n      var nonceCount = credentials.nonceCount! + 1;\n      credentials.nonceCount = nonceCount;\n      nc = nonceCount.toRadixString(16).padLeft(9, \"0\");\n      hasher\n        ..add(credentials.nonce!.codeUnits)\n        ..add([_CharCode.COLON])\n        ..add(nc.codeUnits)\n        ..add([_CharCode.COLON])\n        ..add(cnonce.codeUnits)\n        ..add([_CharCode.COLON])\n        ..add(\"auth\".codeUnits)\n        ..add([_CharCode.COLON])\n        ..add(ha2.codeUnits);\n    } else {\n      hasher\n        ..add(credentials.nonce!.codeUnits)\n        ..add([_CharCode.COLON])\n        ..add(ha2.codeUnits);\n    }\n    var response = _CryptoUtils.bytesToHex(hasher.close());\n\n    StringBuffer buffer = StringBuffer()\n      ..write('Digest ')\n      ..write('username=\"$username\"')\n      ..write(', realm=\"${credentials.realm}\"')\n      ..write(', nonce=\"${credentials.nonce}\"')\n      ..write(', uri=\"$requestUri\"')\n      ..write(', algorithm=\"${credentials.algorithm}\"');\n    if (isAuth) {\n      buffer\n        ..write(', qop=\"auth\"')\n        ..write(', cnonce=\"$cnonce\"')\n        ..write(', nc=\"$nc\"');\n    }\n    buffer.write(', response=\"$response\"');\n    return buffer.toString();\n  }\n\n  void authorize(_Credentials credentials, HttpClientRequest request) {\n    request.headers.set(HttpHeaders.authorizationHeader,\n        authorization(credentials, request as _HttpClientRequest));\n  }\n\n  void authorizeProxy(\n      _ProxyCredentials credentials, HttpClientRequest request) {\n    request.headers.set(HttpHeaders.proxyAuthorizationHeader,\n        authorization(credentials, request as _HttpClientRequest));\n  }\n}\n\nclass _RedirectInfo implements RedirectInfo {\n  final int statusCode;\n  final String method;\n  final Uri location;\n  const _RedirectInfo(this.statusCode, this.method, this.location);\n}\n\nString _getHttpVersion() {\n  var version = Platform.version;\n  // Only include major and minor version numbers.\n  int index = version.indexOf('.', version.indexOf('.') + 1);\n  version = version.substring(0, index);\n  return 'Dart/$version (dart:io)';\n}\n", "// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n//\n\nimport \"package:expect/expect.dart\";\nimport \"dart:async\";\nimport \"dart:io\";\n\nFuture<HttpServer> setupServer({Uri? targetServer}) {\n  final completer = new Completer<HttpServer>();\n  HttpServer.bind(\"127.0.0.1\", 0).then((server) {\n    var handlers = new Map<String, Function>();\n    addRequestHandler(\n        String path, void handler(HttpRequest request, HttpResponse response)) {\n      handlers[path] = handler;\n    }\n\n    server.listen((HttpRequest request) {\n      if (handlers.containsKey(request.uri.path)) {\n        handlers[request.uri.path]!(request, request.response);\n      } else {\n        request.listen((_) {}, onDone: () {\n          request.response.statusCode = 404;\n          request.response.close();\n        });\n      }\n    });\n\n    void addRedirectHandler(int number, int statusCode) {\n      addRequestHandler(\"/$number\",\n          (HttpRequest request, HttpResponse response) {\n        response.redirect(\n            Uri.parse(\"http://127.0.0.1:${server.port}/${number + 1}\"));\n      });\n    }\n\n    // Setup simple redirect.\n    addRequestHandler(\"/redirect\",\n        (HttpRequest request, HttpResponse response) {\n      response.redirect(Uri.parse(\"http://127.0.0.1:${server.port}/location\"),\n          status: HttpStatus.movedPermanently);\n    });\n    addRequestHandler(\"/location\",\n        (HttpRequest request, HttpResponse response) {\n      response.close();\n    });\n\n    // Setup redirects with relative url.\n    addRequestHandler(\"/redirectUrl\",\n        (HttpRequest request, HttpResponse response) {\n      response.headers.set(HttpHeaders.locationHeader, \"/some/relativeUrl\");\n      response.statusCode = HttpStatus.movedPermanently;\n      response.close();\n    });\n\n    addRequestHandler(\"/some/redirectUrl\",\n        (HttpRequest request, HttpResponse response) {\n      response.headers.set(HttpHeaders.locationHeader, \"relativeUrl\");\n      response.statusCode = HttpStatus.movedPermanently;\n      response.close();\n    });\n\n    addRequestHandler(\"/some/relativeUrl\",\n        (HttpRequest request, HttpResponse response) {\n      response.close();\n    });\n\n    addRequestHandler(\"/some/relativeToAbsolute\",\n        (HttpRequest request, HttpResponse response) {\n      response.redirect(Uri.parse(\"xxx\"), status: HttpStatus.seeOther);\n    });\n\n    addRequestHandler(\"/redirectUrl2\",\n        (HttpRequest request, HttpResponse response) {\n      response.headers.set(HttpHeaders.locationHeader, \"location\");\n      response.statusCode = HttpStatus.movedPermanently;\n      response.close();\n    });\n\n    addRequestHandler(\"/redirectUrl3\",\n        (HttpRequest request, HttpResponse response) {\n      response.headers.set(HttpHeaders.locationHeader, \"./location\");\n      response.statusCode = HttpStatus.movedPermanently;\n      response.close();\n    });\n\n    addRequestHandler(\"/redirectUrl4\",\n        (HttpRequest request, HttpResponse response) {\n      response.headers.set(HttpHeaders.locationHeader, \"./a/b/../../location\");\n      response.statusCode = HttpStatus.movedPermanently;\n      response.close();\n    });\n\n    addRequestHandler(\"/redirectUrl5\",\n        (HttpRequest request, HttpResponse response) {\n      response.headers.set(\n          HttpHeaders.locationHeader, \"//127.0.0.1:${server.port}/location\");\n      response.statusCode = HttpStatus.movedPermanently;\n      response.close();\n    });\n\n    // Setup redirect chain.\n    int n = 1;\n    addRedirectHandler(n++, HttpStatus.movedPermanently);\n    addRedirectHandler(n++, HttpStatus.movedTemporarily);\n    addRedirectHandler(n++, HttpStatus.seeOther);\n    addRedirectHandler(n++, HttpStatus.temporaryRedirect);\n    addRedirectHandler(n++, HttpStatus.permanentRedirect);\n    for (int i = n; i < 10; i++) {\n      addRedirectHandler(i, HttpStatus.movedPermanently);\n    }\n\n    // Setup redirect loop.\n    addRequestHandler(\"/A\", (HttpRequest request, HttpResponse response) {\n      response.headers\n          .set(HttpHeaders.locationHeader, \"http://127.0.0.1:${server.port}/B\");\n      response.statusCode = HttpStatus.movedPermanently;\n      response.close();\n    });\n    addRequestHandler(\"/B\", (HttpRequest request, HttpResponse response) {\n      response.headers\n          .set(HttpHeaders.locationHeader, \"http://127.0.0.1:${server.port}/A\");\n      response.statusCode = HttpStatus.movedTemporarily;\n      response.close();\n    });\n\n    // Setup redirect checking headers.\n    addRequestHandler(\"/src\", (HttpRequest request, HttpResponse response) {\n      Expect.equals(\"value\", request.headers.value(\"X-Request-Header\"));\n      Expect.isNotNull(request.headers.value(\"Authorization\"),\n          \"expected 'Authorization' header to be set\");\n      response.headers.set(\n          HttpHeaders.locationHeader, \"http://127.0.0.1:${server.port}/target\");\n      response.statusCode = HttpStatus.movedPermanently;\n      response.close();\n    });\n    addRequestHandler(\"/target\", (HttpRequest request, HttpResponse response) {\n      Expect.equals(\"value\", request.headers.value(\"X-Request-Header\"));\n      Expect.isNotNull(request.headers.value(\"Authorization\"),\n          \"expected 'Authorization' header to be set\");\n      response.close();\n    });\n\n    if (targetServer != null) {\n      addRequestHandler(\"/src-crossdomain\",\n          (HttpRequest request, HttpResponse response) {\n        Expect.equals(\"value\", request.headers.value(\"X-Request-Header\"));\n        Expect.isNotNull(request.headers.value(\"Authorization\"),\n            \"expected 'Authorization' header to be set\");\n        response.headers\n            .set(HttpHeaders.locationHeader, targetServer.toString());\n        response.statusCode = HttpStatus.movedPermanently;\n        response.close();\n      });\n    }\n\n    // Setup redirect for 301 where POST should not redirect.\n    addRequestHandler(\"/301src\", (HttpRequest request, HttpResponse response) {\n      Expect.equals(\"POST\", request.method);\n      request.listen((_) {}, onDone: () {\n        response.headers.set(HttpHeaders.locationHeader,\n            \"http://127.0.0.1:${server.port}/301target\");\n        response.statusCode = HttpStatus.movedPermanently;\n        response.close();\n      });\n    });\n    addRequestHandler(\"/301target\",\n        (HttpRequest request, HttpResponse response) {\n      Expect.fail(\"Redirect of POST should not happen\");\n    });\n\n    // Setup redirect for 303 where POST should turn into GET.\n    addRequestHandler(\"/303src\", (HttpRequest request, HttpResponse response) {\n      request.listen((_) {}, onDone: () {\n        Expect.equals(\"POST\", request.method);\n        response.headers.set(HttpHeaders.locationHeader,\n            \"http://127.0.0.1:${server.port}/303target\");\n        response.statusCode = HttpStatus.seeOther;\n        response.close();\n      });\n    });\n    addRequestHandler(\"/303target\",\n        (HttpRequest request, HttpResponse response) {\n      Expect.equals(\"GET\", request.method);\n      response.close();\n    });\n\n    // Setup redirect where we close the connection.\n    addRequestHandler(\"/closing\", (HttpRequest request, HttpResponse response) {\n      response.headers\n          .set(HttpHeaders.locationHeader, \"http://127.0.0.1:${server.port}/\");\n      response.statusCode = HttpStatus.found;\n      response.persistentConnection = false;\n      response.close();\n    });\n\n    completer.complete(server);\n  });\n  return completer.future;\n}\n\n// A second HTTP server used to validate that redirect requests accross domains\n// do *not* include security-related headers.\nFuture<HttpServer> setupTargetServer() {\n  final completer = new Completer<HttpServer>();\n  HttpServer.bind(\"127.0.0.1\", 0).then((server) {\n    var handlers = new Map<String, Function>();\n    addRequestHandler(\n        String path, void handler(HttpRequest request, HttpResponse response)) {\n      handlers[path] = handler;\n    }\n\n    server.listen((HttpRequest request) {\n      if (request.uri.path == \"/target\") {\n        Expect.equals(\"value\", request.headers.value(\"X-Request-Header\"));\n        Expect.isNull(request.headers.value(\"Authorization\"),\n            \"expected 'Authorization' header to be removed on redirect\");\n        request.response.close();\n      } else {\n        request.listen((_) {}, onDone: () {\n          request.response.statusCode = 404;\n          request.response.close();\n        });\n      }\n    });\n\n    completer.complete(server);\n  });\n  return completer.future;\n}\n\nvoid checkRedirects(int redirectCount, HttpClientResponse response) {\n  if (redirectCount < 2) {\n    Expect.isTrue(response.redirects.isEmpty);\n  } else {\n    Expect.equals(redirectCount - 1, response.redirects.length);\n    for (int i = 0; i < redirectCount - 2; i++) {\n      Expect.equals(response.redirects[i].location.path, \"/${i + 2}\");\n    }\n  }\n}\n\nvoid testManualRedirect() {\n  setupServer().then((server) {\n    HttpClient client = new HttpClient();\n\n    int redirectCount = 0;\n    handleResponse(HttpClientResponse response) {\n      response.listen((_) => Expect.fail(\"Response data not expected\"),\n          onDone: () {\n        redirectCount++;\n        if (redirectCount < 10) {\n          Expect.isTrue(response.isRedirect);\n          checkRedirects(redirectCount, response);\n          response.redirect().then(handleResponse);\n        } else {\n          Expect.equals(HttpStatus.notFound, response.statusCode);\n          server.close();\n          client.close();\n        }\n      });\n    }\n\n    client\n        .getUrl(Uri.parse(\"http://127.0.0.1:${server.port}/1\"))\n        .then((HttpClientRequest request) {\n      request.followRedirects = false;\n      return request.close();\n    }).then(handleResponse);\n  });\n}\n\nvoid testManualRedirectWithHeaders() {\n  setupServer().then((server) {\n    HttpClient client = new HttpClient();\n\n    int redirectCount = 0;\n\n    handleResponse(HttpClientResponse response) {\n      response.listen((_) => Expect.fail(\"Response data not expected\"),\n          onDone: () {\n        redirectCount++;\n        if (redirectCount < 2) {\n          Expect.isTrue(response.isRedirect);\n          response.redirect().then(handleResponse);\n        } else {\n          Expect.equals(HttpStatus.ok, response.statusCode);\n          server.close();\n          client.close();\n        }\n      });\n    }\n\n    client\n        .getUrl(Uri.parse(\"http://127.0.0.1:${server.port}/src\"))\n        .then((HttpClientRequest request) {\n      request.followRedirects = false;\n      request.headers.add(\"X-Request-Header\", \"value\");\n      request.headers.add(\"Authorization\", \"Basic ...\");\n      return request.close();\n    }).then(handleResponse);\n  });\n}\n\nvoid testAutoRedirect() {\n  setupServer().then((server) {\n    HttpClient client = new HttpClient();\n\n    client\n        .getUrl(Uri.parse(\"http://127.0.0.1:${server.port}/redirect\"))\n        .then((HttpClientRequest request) {\n      return request.close();\n    }).then((HttpClientResponse response) {\n      response.listen((_) => Expect.fail(\"Response data not expected\"),\n          onDone: () {\n        Expect.equals(1, response.redirects.length);\n        server.close();\n        client.close();\n      });\n    });\n  });\n}\n\nvoid testAutoRedirectWithHeaders() {\n  setupServer().then((server) {\n    HttpClient client = new HttpClient();\n\n    client\n        .getUrl(Uri.parse(\"http://127.0.0.1:${server.port}/src\"))\n        .then((HttpClientRequest request) {\n      request.headers.add(\"X-Request-Header\", \"value\");\n      request.headers.add(\"Authorization\", \"Basic ...\");\n      return request.close();\n    }).then((HttpClientResponse response) {\n      response.listen((_) => Expect.fail(\"Response data not expected\"),\n          onDone: () {\n        Expect.equals(1, response.redirects.length);\n        server.close();\n        client.close();\n      });\n    });\n  });\n}\n\nvoid testCrossDomainAutoRedirectWithHeaders() {\n  setupTargetServer().then((targetServer) {\n    setupServer(\n            targetServer:\n                Uri.parse(\"http://127.0.0.1:${targetServer.port}/target\"))\n        .then((server) {\n      HttpClient client = new HttpClient();\n\n      client\n          .getUrl(Uri.parse(\"http://127.0.0.1:${server.port}/src-crossdomain\"))\n          .then((HttpClientRequest request) {\n        request.headers.add(\"X-Request-Header\", \"value\");\n        request.headers.add(\"Authorization\", \"Basic ...\");\n        return request.close();\n      }).then((HttpClientResponse response) {\n        response.listen((_) => Expect.fail(\"Response data not expected\"),\n            onDone: () {\n          Expect.equals(1, response.redirects.length);\n          targetServer.close();\n          server.close();\n          client.close();\n        });\n      });\n    });\n  });\n}\n\nvoid testAutoRedirect301POST() {\n  setupServer().then((server) {\n    HttpClient client = new HttpClient();\n\n    client\n        .postUrl(Uri.parse(\"http://127.0.0.1:${server.port}/301src\"))\n        .then((HttpClientRequest request) {\n      return request.close();\n    }).then((HttpClientResponse response) {\n      Expect.equals(HttpStatus.movedPermanently, response.statusCode);\n      response.listen((_) => Expect.fail(\"Response data not expected\"),\n          onDone: () {\n        Expect.equals(0, response.redirects.length);\n        server.close();\n        client.close();\n      });\n    });\n  });\n}\n\nvoid testAutoRedirect303POST() {\n  setupServer().then((server) {\n    HttpClient client = new HttpClient();\n\n    client\n        .postUrl(Uri.parse(\"http://127.0.0.1:${server.port}/303src\"))\n        .then((HttpClientRequest request) {\n      return request.close();\n    }).then((HttpClientResponse response) {\n      Expect.equals(HttpStatus.ok, response.statusCode);\n      response.listen((_) => Expect.fail(\"Response data not expected\"),\n          onDone: () {\n        Expect.equals(1, response.redirects.length);\n        server.close();\n        client.close();\n      });\n    });\n  });\n}\n\nvoid testAutoRedirectLimit() {\n  setupServer().then((server) {\n    HttpClient client = new HttpClient();\n\n    Future<HttpClientResponse?>.value(client\n            .getUrl(Uri.parse(\"http://127.0.0.1:${server.port}/1\"))\n            .then((HttpClientRequest request) => request.close()))\n        .catchError((error) {\n      Expect.equals(5, error.redirects.length);\n      server.close();\n      client.close();\n    }, test: (e) => e is RedirectException);\n  });\n}\n\nvoid testRedirectLoop() {\n  setupServer().then((server) {\n    HttpClient client = new HttpClient();\n\n    int redirectCount = 0;\n    Future<HttpClientResponse?>.value(client\n            .getUrl(Uri.parse(\"http://127.0.0.1:${server.port}/A\"))\n            .then((HttpClientRequest request) => request.close()))\n        .catchError((error) {\n      Expect.equals(2, error.redirects.length);\n      server.close();\n      client.close();\n    }, test: (e) => e is RedirectException);\n  });\n}\n\nvoid testRedirectClosingConnection() {\n  setupServer().then((server) {\n    HttpClient client = new HttpClient();\n\n    client\n        .getUrl(Uri.parse(\"http://127.0.0.1:${server.port}/closing\"))\n        .then((request) => request.close())\n        .then((response) {\n      response.listen((_) {}, onDone: () {\n        Expect.equals(1, response.redirects.length);\n        server.close();\n        client.close();\n      });\n    });\n  });\n}\n\nvoid testRedirectRelativeUrl() {\n  testPath(String path) {\n    setupServer().then((server) {\n      HttpClient client = new HttpClient();\n\n      print(path);\n      client\n          .getUrl(Uri.parse(\"http://127.0.0.1:${server.port}$path\"))\n          .then((request) => request.close())\n          .then((response) {\n        response.listen((_) {}, onDone: () {\n          Expect.equals(HttpStatus.ok, response.statusCode);\n          Expect.equals(1, response.redirects.length);\n          server.close();\n          client.close();\n        });\n      });\n    });\n  }\n\n  testPath(\"/redirectUrl\");\n  testPath(\"/some/redirectUrl\");\n  testPath(\"/redirectUrl2\");\n  testPath(\"/redirectUrl3\");\n  testPath(\"/redirectUrl4\");\n  testPath(\"/redirectUrl5\");\n}\n\nvoid testRedirectRelativeToAbsolute() {\n  setupServer().then((server) {\n    HttpClient client = new HttpClient();\n\n    int redirectCount = 0;\n    handleResponse(HttpClientResponse response) {\n      response.listen((_) => Expect.fail(\"Response data not expected\"),\n          onDone: () {\n        Expect.equals(HttpStatus.seeOther, response.statusCode);\n        Expect.equals(\"xxx\", response.headers[\"Location\"]![0]);\n        Expect.isTrue(response.isRedirect);\n        server.close();\n        client.close();\n      });\n    }\n\n    client\n        .getUrl(Uri.parse(\n            \"http://127.0.0.1:${server.port}/some/relativeToAbsolute\"))\n        .then((HttpClientRequest request) {\n      request.followRedirects = false;\n      return request.close();\n    }).then(handleResponse);\n  });\n}\n\nmain() {\n  testManualRedirect();\n  testManualRedirectWithHeaders();\n  testAutoRedirect();\n  testAutoRedirectWithHeaders();\n  testCrossDomainAutoRedirectWithHeaders();\n  testAutoRedirect301POST();\n  testAutoRedirect303POST();\n  testAutoRedirectLimit();\n  testRedirectLoop();\n  testRedirectClosingConnection();\n  testRedirectRelativeUrl();\n  testRedirectRelativeToAbsolute();\n}\n", "// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n//\n\n// @dart = 2.9\n\nimport \"package:expect/expect.dart\";\nimport \"dart:async\";\nimport \"dart:io\";\n\nFuture<HttpServer> setupServer({Uri targetServer}) {\n  Completer completer = new Completer<HttpServer>();\n  HttpServer.bind(\"127.0.0.1\", 0).then((server) {\n    var handlers = new Map<String, Function>();\n    addRequestHandler(\n        String path, void handler(HttpRequest request, HttpResponse response)) {\n      handlers[path] = handler;\n    }\n\n    server.listen((HttpRequest request) {\n      if (handlers.containsKey(request.uri.path)) {\n        handlers[request.uri.path](request, request.response);\n      } else {\n        request.listen((_) {}, onDone: () {\n          request.response.statusCode = 404;\n          request.response.close();\n        });\n      }\n    });\n\n    void addRedirectHandler(int number, int statusCode) {\n      addRequestHandler(\"/$number\",\n          (HttpRequest request, HttpResponse response) {\n        response.redirect(\n            Uri.parse(\"http://127.0.0.1:${server.port}/${number + 1}\"));\n      });\n    }\n\n    // Setup simple redirect.\n    addRequestHandler(\"/redirect\",\n        (HttpRequest request, HttpResponse response) {\n      response.redirect(Uri.parse(\"http://127.0.0.1:${server.port}/location\"),\n          status: HttpStatus.movedPermanently);\n    });\n    addRequestHandler(\"/location\",\n        (HttpRequest request, HttpResponse response) {\n      response.close();\n    });\n\n    // Setup redirects with relative url.\n    addRequestHandler(\"/redirectUrl\",\n        (HttpRequest request, HttpResponse response) {\n      response.headers.set(HttpHeaders.locationHeader, \"/some/relativeUrl\");\n      response.statusCode = HttpStatus.movedPermanently;\n      response.close();\n    });\n\n    addRequestHandler(\"/some/redirectUrl\",\n        (HttpRequest request, HttpResponse response) {\n      response.headers.set(HttpHeaders.locationHeader, \"relativeUrl\");\n      response.statusCode = HttpStatus.movedPermanently;\n      response.close();\n    });\n\n    addRequestHandler(\"/some/relativeUrl\",\n        (HttpRequest request, HttpResponse response) {\n      response.close();\n    });\n\n    addRequestHandler(\"/some/relativeToAbsolute\",\n        (HttpRequest request, HttpResponse response) {\n      response.redirect(Uri.parse(\"xxx\"), status: HttpStatus.seeOther);\n    });\n\n    addRequestHandler(\"/redirectUrl2\",\n        (HttpRequest request, HttpResponse response) {\n      response.headers.set(HttpHeaders.locationHeader, \"location\");\n      response.statusCode = HttpStatus.movedPermanently;\n      response.close();\n    });\n\n    addRequestHandler(\"/redirectUrl3\",\n        (HttpRequest request, HttpResponse response) {\n      response.headers.set(HttpHeaders.locationHeader, \"./location\");\n      response.statusCode = HttpStatus.movedPermanently;\n      response.close();\n    });\n\n    addRequestHandler(\"/redirectUrl4\",\n        (HttpRequest request, HttpResponse response) {\n      response.headers.set(HttpHeaders.locationHeader, \"./a/b/../../location\");\n      response.statusCode = HttpStatus.movedPermanently;\n      response.close();\n    });\n\n    addRequestHandler(\"/redirectUrl5\",\n        (HttpRequest request, HttpResponse response) {\n      response.headers.set(\n          HttpHeaders.locationHeader, \"//127.0.0.1:${server.port}/location\");\n      response.statusCode = HttpStatus.movedPermanently;\n      response.close();\n    });\n\n    // Setup redirect chain.\n    int n = 1;\n    addRedirectHandler(n++, HttpStatus.movedPermanently);\n    addRedirectHandler(n++, HttpStatus.movedTemporarily);\n    addRedirectHandler(n++, HttpStatus.seeOther);\n    addRedirectHandler(n++, HttpStatus.temporaryRedirect);\n    addRedirectHandler(n++, HttpStatus.permanentRedirect);\n    for (int i = n; i < 10; i++) {\n      addRedirectHandler(i, HttpStatus.movedPermanently);\n    }\n\n    // Setup redirect loop.\n    addRequestHandler(\"/A\", (HttpRequest request, HttpResponse response) {\n      response.headers\n          .set(HttpHeaders.locationHeader, \"http://127.0.0.1:${server.port}/B\");\n      response.statusCode = HttpStatus.movedPermanently;\n      response.close();\n    });\n    addRequestHandler(\"/B\", (HttpRequest request, HttpResponse response) {\n      response.headers\n          .set(HttpHeaders.locationHeader, \"http://127.0.0.1:${server.port}/A\");\n      response.statusCode = HttpStatus.movedTemporarily;\n      response.close();\n    });\n\n    // Setup redirect checking headers.\n    addRequestHandler(\"/src\", (HttpRequest request, HttpResponse response) {\n      Expect.equals(\"value\", request.headers.value(\"X-Request-Header\"));\n      Expect.isNotNull(request.headers.value(\"Authorization\"),\n          \"expected 'Authorization' header to be set\");\n      response.headers.set(\n          HttpHeaders.locationHeader, \"http://127.0.0.1:${server.port}/target\");\n      response.statusCode = HttpStatus.movedPermanently;\n      response.close();\n    });\n    addRequestHandler(\"/target\", (HttpRequest request, HttpResponse response) {\n      Expect.equals(\"value\", request.headers.value(\"X-Request-Header\"));\n      Expect.isNotNull(request.headers.value(\"Authorization\"),\n          \"expected 'Authorization' header to be set\");\n      response.close();\n    });\n\n    if (targetServer != null) {\n      addRequestHandler(\"/src-crossdomain\",\n          (HttpRequest request, HttpResponse response) {\n        Expect.equals(\"value\", request.headers.value(\"X-Request-Header\"));\n        Expect.isNotNull(request.headers.value(\"Authorization\"),\n            \"expected 'Authorization' header to be set\");\n        response.headers\n            .set(HttpHeaders.locationHeader, targetServer.toString());\n        response.statusCode = HttpStatus.movedPermanently;\n        response.close();\n      });\n    }\n\n    // Setup redirect for 301 where POST should not redirect.\n    addRequestHandler(\"/301src\", (HttpRequest request, HttpResponse response) {\n      Expect.equals(\"POST\", request.method);\n      request.listen((_) {}, onDone: () {\n        response.headers.set(HttpHeaders.locationHeader,\n            \"http://127.0.0.1:${server.port}/301target\");\n        response.statusCode = HttpStatus.movedPermanently;\n        response.close();\n      });\n    });\n    addRequestHandler(\"/301target\",\n        (HttpRequest request, HttpResponse response) {\n      Expect.fail(\"Redirect of POST should not happen\");\n    });\n\n    // Setup redirect for 303 where POST should turn into GET.\n    addRequestHandler(\"/303src\", (HttpRequest request, HttpResponse response) {\n      request.listen((_) {}, onDone: () {\n        Expect.equals(\"POST\", request.method);\n        response.headers.set(HttpHeaders.locationHeader,\n            \"http://127.0.0.1:${server.port}/303target\");\n        response.statusCode = HttpStatus.seeOther;\n        response.close();\n      });\n    });\n    addRequestHandler(\"/303target\",\n        (HttpRequest request, HttpResponse response) {\n      Expect.equals(\"GET\", request.method);\n      response.close();\n    });\n\n    // Setup redirect where we close the connection.\n    addRequestHandler(\"/closing\", (HttpRequest request, HttpResponse response) {\n      response.headers\n          .set(HttpHeaders.locationHeader, \"http://127.0.0.1:${server.port}/\");\n      response.statusCode = HttpStatus.found;\n      response.persistentConnection = false;\n      response.close();\n    });\n\n    completer.complete(server);\n  });\n  return completer.future;\n}\n\n// A second HTTP server used to validate that redirect requests accross domains\n// do *not* include security-related headers.\nFuture<HttpServer> setupTargetServer() {\n  Completer completer = new Completer<HttpServer>();\n  HttpServer.bind(\"127.0.0.1\", 0).then((server) {\n    var handlers = new Map<String, Function>();\n    addRequestHandler(\n        String path, void handler(HttpRequest request, HttpResponse response)) {\n      handlers[path] = handler;\n    }\n\n    server.listen((HttpRequest request) {\n      if (request.uri.path == \"/target\") {\n        Expect.equals(\"value\", request.headers.value(\"X-Request-Header\"));\n        Expect.isNull(request.headers.value(\"Authorization\"),\n            \"expected 'Authorization' header to be removed on redirect\");\n        request.response.close();\n      } else {\n        request.listen((_) {}, onDone: () {\n          request.response.statusCode = 404;\n          request.response.close();\n        });\n      }\n    });\n\n    completer.complete(server);\n  });\n  return completer.future;\n}\n\nvoid checkRedirects(int redirectCount, HttpClientResponse response) {\n  if (redirectCount < 2) {\n    Expect.isTrue(response.redirects.isEmpty);\n  } else {\n    Expect.equals(redirectCount - 1, response.redirects.length);\n    for (int i = 0; i < redirectCount - 2; i++) {\n      Expect.equals(response.redirects[i].location.path, \"/${i + 2}\");\n    }\n  }\n}\n\nvoid testManualRedirect() {\n  setupServer().then((server) {\n    HttpClient client = new HttpClient();\n\n    int redirectCount = 0;\n    handleResponse(HttpClientResponse response) {\n      response.listen((_) => Expect.fail(\"Response data not expected\"),\n          onDone: () {\n        redirectCount++;\n        if (redirectCount < 10) {\n          Expect.isTrue(response.isRedirect);\n          checkRedirects(redirectCount, response);\n          response.redirect().then(handleResponse);\n        } else {\n          Expect.equals(HttpStatus.notFound, response.statusCode);\n          server.close();\n          client.close();\n        }\n      });\n    }\n\n    client\n        .getUrl(Uri.parse(\"http://127.0.0.1:${server.port}/1\"))\n        .then((HttpClientRequest request) {\n      request.followRedirects = false;\n      return request.close();\n    }).then(handleResponse);\n  });\n}\n\nvoid testManualRedirectWithHeaders() {\n  setupServer().then((server) {\n    HttpClient client = new HttpClient();\n\n    int redirectCount = 0;\n\n    handleResponse(HttpClientResponse response) {\n      response.listen((_) => Expect.fail(\"Response data not expected\"),\n          onDone: () {\n        redirectCount++;\n        if (redirectCount < 2) {\n          Expect.isTrue(response.isRedirect);\n          response.redirect().then(handleResponse);\n        } else {\n          Expect.equals(HttpStatus.ok, response.statusCode);\n          server.close();\n          client.close();\n        }\n      });\n    }\n\n    client\n        .getUrl(Uri.parse(\"http://127.0.0.1:${server.port}/src\"))\n        .then((HttpClientRequest request) {\n      request.followRedirects = false;\n      request.headers.add(\"X-Request-Header\", \"value\");\n      request.headers.add(\"Authorization\", \"Basic ...\");\n      return request.close();\n    }).then(handleResponse);\n  });\n}\n\nvoid testAutoRedirect() {\n  setupServer().then((server) {\n    HttpClient client = new HttpClient();\n\n    client\n        .getUrl(Uri.parse(\"http://127.0.0.1:${server.port}/redirect\"))\n        .then((HttpClientRequest request) {\n      return request.close();\n    }).then((HttpClientResponse response) {\n      response.listen((_) => Expect.fail(\"Response data not expected\"),\n          onDone: () {\n        Expect.equals(1, response.redirects.length);\n        server.close();\n        client.close();\n      });\n    });\n  });\n}\n\nvoid testAutoRedirectWithHeaders() {\n  setupServer().then((server) {\n    HttpClient client = new HttpClient();\n\n    client\n        .getUrl(Uri.parse(\"http://127.0.0.1:${server.port}/src\"))\n        .then((HttpClientRequest request) {\n      request.headers.add(\"X-Request-Header\", \"value\");\n      request.headers.add(\"Authorization\", \"Basic ...\");\n      return request.close();\n    }).then((HttpClientResponse response) {\n      response.listen((_) => Expect.fail(\"Response data not expected\"),\n          onDone: () {\n        Expect.equals(1, response.redirects.length);\n        server.close();\n        client.close();\n      });\n    });\n  });\n}\n\nvoid testCrossDomainAutoRedirectWithHeaders() {\n  setupTargetServer().then((targetServer) {\n    setupServer(\n            targetServer:\n                Uri.parse(\"http://127.0.0.1:${targetServer.port}/target\"))\n        .then((server) {\n      HttpClient client = new HttpClient();\n\n      client\n          .getUrl(Uri.parse(\"http://127.0.0.1:${server.port}/src-crossdomain\"))\n          .then((HttpClientRequest request) {\n        request.headers.add(\"X-Request-Header\", \"value\");\n        request.headers.add(\"Authorization\", \"Basic ...\");\n        return request.close();\n      }).then((HttpClientResponse response) {\n        response.listen((_) => Expect.fail(\"Response data not expected\"),\n            onDone: () {\n          Expect.equals(1, response.redirects.length);\n          targetServer.close();\n          server.close();\n          client.close();\n        });\n      });\n    });\n  });\n}\n\nvoid testAutoRedirect301POST() {\n  setupServer().then((server) {\n    HttpClient client = new HttpClient();\n\n    client\n        .postUrl(Uri.parse(\"http://127.0.0.1:${server.port}/301src\"))\n        .then((HttpClientRequest request) {\n      return request.close();\n    }).then((HttpClientResponse response) {\n      Expect.equals(HttpStatus.movedPermanently, response.statusCode);\n      response.listen((_) => Expect.fail(\"Response data not expected\"),\n          onDone: () {\n        Expect.equals(0, response.redirects.length);\n        server.close();\n        client.close();\n      });\n    });\n  });\n}\n\nvoid testAutoRedirect303POST() {\n  setupServer().then((server) {\n    HttpClient client = new HttpClient();\n\n    client\n        .postUrl(Uri.parse(\"http://127.0.0.1:${server.port}/303src\"))\n        .then((HttpClientRequest request) {\n      return request.close();\n    }).then((HttpClientResponse response) {\n      Expect.equals(HttpStatus.ok, response.statusCode);\n      response.listen((_) => Expect.fail(\"Response data not expected\"),\n          onDone: () {\n        Expect.equals(1, response.redirects.length);\n        server.close();\n        client.close();\n      });\n    });\n  });\n}\n\nvoid testAutoRedirectLimit() {\n  setupServer().then((server) {\n    HttpClient client = new HttpClient();\n\n    client\n        .getUrl(Uri.parse(\"http://127.0.0.1:${server.port}/1\"))\n        .then((HttpClientRequest request) => request.close())\n        .catchError((error) {\n      Expect.equals(5, error.redirects.length);\n      server.close();\n      client.close();\n    }, test: (e) => e is RedirectException);\n  });\n}\n\nvoid testRedirectLoop() {\n  setupServer().then((server) {\n    HttpClient client = new HttpClient();\n\n    int redirectCount = 0;\n    client\n        .getUrl(Uri.parse(\"http://127.0.0.1:${server.port}/A\"))\n        .then((HttpClientRequest request) => request.close())\n        .catchError((error) {\n      Expect.equals(2, error.redirects.length);\n      server.close();\n      client.close();\n    }, test: (e) => e is RedirectException);\n  });\n}\n\nvoid testRedirectClosingConnection() {\n  setupServer().then((server) {\n    HttpClient client = new HttpClient();\n\n    client\n        .getUrl(Uri.parse(\"http://127.0.0.1:${server.port}/closing\"))\n        .then((request) => request.close())\n        .then((response) {\n      response.listen((_) {}, onDone: () {\n        Expect.equals(1, response.redirects.length);\n        server.close();\n        client.close();\n      });\n    });\n  });\n}\n\nvoid testRedirectRelativeUrl() {\n  testPath(String path) {\n    setupServer().then((server) {\n      HttpClient client = new HttpClient();\n\n      print(path);\n      client\n          .getUrl(Uri.parse(\"http://127.0.0.1:${server.port}$path\"))\n          .then((request) => request.close())\n          .then((response) {\n        response.listen((_) {}, onDone: () {\n          Expect.equals(HttpStatus.ok, response.statusCode);\n          Expect.equals(1, response.redirects.length);\n          server.close();\n          client.close();\n        });\n      });\n    });\n  }\n\n  testPath(\"/redirectUrl\");\n  testPath(\"/some/redirectUrl\");\n  testPath(\"/redirectUrl2\");\n  testPath(\"/redirectUrl3\");\n  testPath(\"/redirectUrl4\");\n  testPath(\"/redirectUrl5\");\n}\n\nvoid testRedirectRelativeToAbsolute() {\n  setupServer().then((server) {\n    HttpClient client = new HttpClient();\n\n    int redirectCount = 0;\n    handleResponse(HttpClientResponse response) {\n      response.listen((_) => Expect.fail(\"Response data not expected\"),\n          onDone: () {\n        Expect.equals(HttpStatus.seeOther, response.statusCode);\n        Expect.equals(\"xxx\", response.headers[\"Location\"][0]);\n        Expect.isTrue(response.isRedirect);\n        server.close();\n        client.close();\n      });\n    }\n\n    client\n        .getUrl(Uri.parse(\n            \"http://127.0.0.1:${server.port}/some/relativeToAbsolute\"))\n        .then((HttpClientRequest request) {\n      request.followRedirects = false;\n      return request.close();\n    }).then(handleResponse);\n  });\n}\n\nmain() {\n  testManualRedirect();\n  testManualRedirectWithHeaders();\n  testAutoRedirect();\n  testAutoRedirectWithHeaders();\n  testCrossDomainAutoRedirectWithHeaders();\n  testAutoRedirect301POST();\n  testAutoRedirect303POST();\n  testAutoRedirectLimit();\n  testRedirectLoop();\n  testRedirectClosingConnection();\n  testRedirectRelativeUrl();\n  testRedirectRelativeToAbsolute();\n}\n"], "filenames": ["CHANGELOG.md", "sdk/lib/_http/http.dart", "sdk/lib/_http/http_impl.dart", "tests/standalone/io/http_redirect_test.dart", "tests/standalone_2/io/http_redirect_test.dart"], "buggy_code_start_loc": [18, 1718, 670, 10, 12], "buggy_code_end_loc": [18, 1720, 2732, 443, 445], "fixing_code_start_loc": [19, 1718, 670, 10, 12], "fixing_code_end_loc": [26, 1751, 2758, 521, 523], "type": "CWE-863", "message": "Dart SDK contains the HTTPClient in dart:io library whcih includes authorization headers when handling cross origin redirects. These headers may be explicitly set and contain sensitive information. By default, HttpClient handles redirection logic. If a request is sent to example.com with authorization header and it redirects to an attackers site, they might not expect attacker site to receive authorization header. We recommend updating the Dart SDK to version 2.16.0 or beyond.", "other": {"cve": {"id": "CVE-2022-0451", "sourceIdentifier": "cve-coordination@google.com", "published": "2022-02-18T14:15:07.817", "lastModified": "2022-02-26T03:06:33.100", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Dart SDK contains the HTTPClient in dart:io library whcih includes authorization headers when handling cross origin redirects. These headers may be explicitly set and contain sensitive information. By default, HttpClient handles redirection logic. If a request is sent to example.com with authorization header and it redirects to an attackers site, they might not expect attacker site to receive authorization header. We recommend updating the Dart SDK to version 2.16.0 or beyond."}, {"lang": "es", "value": "Dart SDK contiene la biblioteca HTTPClient en dart:io que incluye encabezados de autorizaci\u00f3n cuando maneja redireccionamientos de origen cruzado. Estos encabezados pueden ser establecidas expl\u00edcitamente y contienen informaci\u00f3n confidencial. Por fallo, HttpClient maneja la l\u00f3gica de redirecci\u00f3n. Si es enviado una petici\u00f3n a example.com con un encabezado de autorizaci\u00f3n y es redirigido a un sitio de atacantes, \u00e9stos podr\u00edan no esperar que el sitio del atacante reciba el encabezado de autorizaci\u00f3n. Recomendamos actualizar Dart SDK a versi\u00f3n 2.16.0 o superior"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "cve-coordination@google.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-863"}]}, {"source": "cve-coordination@google.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-305"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:dart:dart_software_development_kit:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.16.0", "matchCriteriaId": "17D69A94-FDC3-417E-B7EB-FD2CD8CCD8A3"}]}]}], "references": [{"url": "https://dart-review.googlesource.com/c/sdk/+/229947", "source": "cve-coordination@google.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/dart-lang/sdk/commit/57db739be0ad4629079bfa94840064f615d35abc", "source": "cve-coordination@google.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/dart-lang/sdk/commit/57db739be0ad4629079bfa94840064f615d35abc"}}