{"buggy_code": ["# frozen_string_literal: true\n\nrequire \"aasm\"\nrequire \"uri\"\nrequire \"net/http\"\n\nclass Article < Content\n  include PublifyGuid\n  include ConfigManager\n\n  serialize :settings, Hash\n\n  content_fields :body, :extended\n\n  validates :guid, uniqueness: true\n  validates :title, presence: true\n\n  has_many :pings, dependent: :destroy\n  has_many :trackbacks, dependent: :destroy\n  has_many :feedback\n  has_many :triggers, as: :pending_item\n  has_many :comments, dependent: :destroy\n\n  before_save :set_permalink\n  before_create :create_guid\n  after_save :keywords_to_tags, :shorten_url\n\n  scope :child_of, ->(article_id) { where(parent_id: article_id) }\n  scope :published_since, ->(time) { published.where(\"published_at > ?\", time) }\n  scope :withdrawn, -> { where(state: \"withdrawn\").order(default_order) }\n  scope :pending, -> { where(state: \"publication_pending\").order(default_order) }\n\n  scope :bestof, lambda {\n    joins(:feedback).\n      where(\"feedback.type\" => \"Comment\",\n            \"contents.state\" => \"published\").\n      group(\"contents.id\").\n      select(\"contents.*, count(feedback.id) as comment_count\").\n      order(\"comment_count DESC\").\n      limit(5)\n  }\n\n  setting :password, :string, \"\"\n\n  attr_accessor :draft, :keywords\n\n  include AASM\n\n  aasm column: :state do\n    state :draft, initial: true\n    # TODO: Disallow if published_at in past\n    state :publication_pending, after_enter: :trigger_publication\n    state :published, after_enter: :really_send_notifications\n    state :withdrawn\n\n    event :withdraw do\n      transitions from: :published, to: :withdrawn\n      transitions from: :publication_pending, to: :draft\n    end\n\n    event :publish do\n      before do\n        self.published_at ||= Time.zone.now\n      end\n\n      transitions from: [:new, :draft], to: :publication_pending do\n        guard do\n          published_at > Time.zone.now\n        end\n      end\n\n      transitions from: [:new, :draft, :publication_pending], to: :published do\n        guard do\n          published_at <= Time.zone.now\n        end\n      end\n    end\n  end\n\n  def set_permalink\n    return if draft? || permalink.present?\n\n    self.permalink = title.to_permalink\n  end\n\n  def has_child?\n    Article.exists?(parent_id: id)\n  end\n\n  def post_type\n    post_type = self[:post_type]\n    post_type = \"read\" if post_type.blank?\n    post_type\n  end\n\n  def self.last_draft(article_id)\n    article = Article.find(article_id)\n    article = Article.child_of(article.id).first while article.has_child?\n    article\n  end\n\n  def self.search_with(params)\n    params ||= {}\n    scoped = super(params)\n    if %w(no_draft drafts published withdrawn pending).include?(params[:state])\n      scoped = scoped.send(params[:state])\n    end\n\n    scoped.order(\"created_at DESC\")\n  end\n\n  # FIXME: Use keyword params to clean up call sites.\n  def permalink_url(anchor = nil, only_path = false)\n    return unless published?\n\n    @cached_permalink_url ||= {}\n    @cached_permalink_url[\"#{anchor}#{only_path}\"] ||=\n      blog.url_for(permalink_url_options, anchor: anchor, only_path: only_path)\n  end\n\n  def save_attachments!(files)\n    files ||= {}\n    files.each_value { |f| save_attachment!(f) }\n  end\n\n  def save_attachment!(file)\n    resources.create!(upload: file, blog: blog)\n  end\n\n  def comment_url\n    blog.url_for(\"comments?article_id=#{id}\", only_path: true)\n  end\n\n  def preview_comment_url\n    blog.url_for(\"comments/preview?article_id=#{id}\", only_path: true)\n  end\n\n  def feed_url(format)\n    \"#{permalink_url}.#{format.gsub(/\\d/, \"\")}\"\n  end\n\n  def next\n    Article.where(\"published_at > ?\", published_at).order(\"published_at asc\").\n      limit(1).first\n  end\n\n  def previous\n    Article.where(\"published_at < ?\", published_at).order(\"published_at desc\").\n      limit(1).first\n  end\n\n  def publication_month\n    published_at.strftime(\"%Y-%m\")\n  end\n\n  def self.publication_months\n    result = select(\"published_at\").where(\"published_at is not NULL\").where(type: \"Article\")\n    result.map { |it| [it.publication_month] }.uniq\n  end\n\n  # Finds one article which was posted on a certain date and matches the\n  # supplied dashed-title params is a Hash\n  def self.requested_article(params)\n    date_range = PublifyTime.delta(params[:year], params[:month], params[:day])\n\n    req_params = {}\n    req_params[:permalink] = params[:title] if params[:title]\n    req_params[:published_at] = date_range if date_range\n\n    return if req_params.empty? # no search if no params send\n\n    article = published.find_by(req_params)\n    return article if article\n\n    if params[:title]\n      req_params[:permalink] = CGI.escape(params[:title])\n      article = published.find_by(req_params)\n      return article if article\n    end\n  end\n\n  # Fulltext searches the body of published articles\n  def self.search(query, args = {})\n    query_s = query.to_s.strip\n    if !query_s.empty? && args.empty?\n      Article.searchstring(query)\n    elsif !query_s.empty? && !args.empty?\n      Article.searchstring(query).page(args[:page]).per(args[:per])\n    else\n      []\n    end\n  end\n\n  def keywords_to_tags\n    Tag.create_from_article!(self)\n  end\n\n  def interested_users\n    User.where(notify_on_new_articles: true)\n  end\n\n  def notify_user_via_email(user)\n    EmailNotify.send_article(self, user) if user.notify_via_email?\n  end\n\n  def comments_closed?\n    !(allow_comments? && in_feedback_window?)\n  end\n\n  def html_urls\n    urls = []\n    html.gsub(/<a\\s+[^>]*>/) do |tag|\n      urls.push(Regexp.last_match[2].strip) if tag =~ /\\bhref=([\"']?)([^ >\"]+)\\1/\n    end\n    urls.uniq\n  end\n\n  def pings_closed?\n    !(allow_pings? && in_feedback_window?)\n  end\n\n  # check if time to comment is open or not\n  def in_feedback_window?\n    blog.sp_article_auto_close.zero? ||\n      published_at.to_i > blog.sp_article_auto_close.days.ago.to_i\n  end\n\n  # The web interface no longer distinguishes between separate \"body\" and\n  # \"extended\" fields, and instead edits everything in a single edit field,\n  # separating the extended content using \"\\<!--more-->\".\n  def body_and_extended\n    if extended.blank?\n      body\n    else\n      \"#{body}\\n<!--more-->\\n#{extended}\"\n    end\n  end\n\n  # Split apart value around a \"\\<!--more-->\" comment and assign it to our\n  # #body and #extended fields.\n  def body_and_extended=(value)\n    parts = value.split(/\\n?<!--more-->\\n?/, 2)\n    self.body = parts[0]\n    self.extended = parts[1] || \"\"\n  end\n\n  def password_protected?\n    password.present?\n  end\n\n  def add_comment(params)\n    comments.build(params)\n  end\n\n  def access_by?(user)\n    user.admin? || user_id == user.id\n  end\n\n  def allow_comments?\n    return allow_comments unless allow_comments.nil?\n\n    blog.default_allow_comments\n  end\n\n  def allow_pings?\n    return allow_pings unless allow_pings.nil?\n\n    blog.default_allow_pings\n  end\n\n  def published_comments\n    comments.published.oldest_first\n  end\n\n  def published_trackbacks\n    trackbacks.published.oldest_first\n  end\n\n  def published_feedback\n    feedback.published.oldest_first\n  end\n\n  private\n\n  def permalink_url_options\n    format_url = blog.permalink_format.dup\n    format_url.gsub!(\"%year%\", published_at.year.to_s)\n    format_url.gsub!(\"%month%\", sprintf(\"%<month>.2d\", month: published_at.month))\n    format_url.gsub!(\"%day%\", sprintf(\"%<day>.2d\", day: published_at.day))\n    format_url.gsub!(\"%title%\", URI::DEFAULT_PARSER.escape(permalink.to_s))\n    if format_url[0, 1] == \"/\"\n      format_url[1..-1]\n    else\n      format_url\n    end\n  end\n\n  def trigger_publication\n    # TODO: Skip if already published, update when published_at changes\n    Trigger.post_action(published_at, self, \"publish!\")\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\n\nRSpec.describe CommentsController, type: :controller do\n  let!(:blog) { create(:blog) }\n  let(:article) { create(:article) }\n  let(:user) { create(:user) }\n  let(:comment_params) do\n    { body: \"content\", author: \"bob\", email: \"bob@home\", url: \"http://bobs.home/\" }\n  end\n\n  describe \"#create\" do\n    render_views\n\n    it \"creates a comment on the specified article\" do\n      post :create, params: { comment: comment_params, article_id: article.id }\n      aggregate_failures do\n        expect(article.comments.size).to eq(1)\n        comment = article.comments.last\n        expect(comment.author).to eq(\"bob\")\n        expect(comment.body).to eq(\"content\")\n        expect(comment.email).to eq(\"bob@home\")\n        expect(comment.url).to eq(\"http://bobs.home/\")\n      end\n    end\n\n    it \"remembers author info in cookies\" do\n      post :create, params: { comment: comment_params, article_id: article.id }\n      aggregate_failures do\n        expect(cookies[\"author\"]).to eq(\"bob\")\n        expect(cookies[\"gravatar_id\"]).to eq(Digest::MD5.hexdigest(\"bob@home\"))\n        expect(cookies[\"url\"]).to eq(\"http://bobs.home/\")\n      end\n    end\n\n    it \"sets the user if logged in\" do\n      sign_in user\n      post :create, params: { comment: comment_params, article_id: article.id }\n      comment = article.comments.last\n      expect(comment.user).to eq user\n    end\n\n    it \"assigns the created comment\" do\n      post :create, params: { comment: comment_params, article_id: article.id }\n      expect(assigns[:comment]).to eq article.comments.last\n    end\n\n    it \"redirects to the article when using regular post\" do\n      post :create, params: { comment: comment_params, article_id: article.id }\n      expect(response).to redirect_to article.permalink_url\n    end\n\n    it \"renders the comment when using xhr post\" do\n      post :create, xhr: true, params: { comment: comment_params, article_id: article.id }\n      aggregate_failures do\n        expect(response).to render_template(\"articles/comment\")\n        expect(response.body).to have_text \"content\"\n      end\n    end\n  end\n\n  describe \"#preview\" do\n    context \"when using xhr post\" do\n      before do\n        post :preview, xhr: true, params: { comment: comment_params,\n                                            article_id: article.id }\n      end\n\n      it \"assigns a comment with the given parameters\" do\n        comment = assigns[:comment]\n        aggregate_failures do\n          expect(comment.author).to eq(\"bob\")\n          expect(comment.body).to eq(\"content\")\n          expect(comment.email).to eq(\"bob@home\")\n          expect(comment.url).to eq(\"http://bobs.home/\")\n        end\n      end\n\n      it \"assigns the article to the comment\" do\n        expect(assigns[:comment].article).to eq article\n      end\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\nrequire \"timecop\"\n\ndescribe Article, type: :model do\n  let(:blog) { create(:blog) }\n\n  it \"test_content_fields\" do\n    a = blog.articles.build\n    assert_equal [:body, :extended], a.content_fields\n  end\n\n  describe \"#permalink_url\" do\n    describe \"with hostname\" do\n      let(:article) do\n        blog.articles.build(permalink: \"article-3\",\n                            published_at: Time.utc(2004, 6, 1))\n      end\n\n      it \"includes the full blog url\" do\n        article.publish\n        expect(article.permalink_url(nil, false)).\n          to eq \"#{blog.base_url}/2004/06/01/article-3\"\n      end\n    end\n\n    describe \"without hostname\" do\n      let(:article) do\n        blog.articles.build(permalink: \"article-3\",\n                            published_at: Time.utc(2004, 6, 1))\n      end\n\n      it \"includes just the blog root path\" do\n        article.publish\n        expect(article.permalink_url(nil, true)).\n          to eq \"#{blog.root_path}/2004/06/01/article-3\"\n      end\n    end\n\n    # NOTE: URLs must not have any multibyte characters in them. The\n    # browser may display them differently, though.\n    describe \"with a multibyte permalink\" do\n      let(:article) do\n        blog.articles.build(permalink: \"\u30eb\u30d3\u30fc\",\n                            published_at: Time.utc(2004, 6, 1))\n      end\n\n      it \"escapes the multibyte characters\" do\n        article.publish\n        expect(article.permalink_url(nil, true)).\n          to eq(\"#{blog.root_path}/2004/06/01/%E3%83%AB%E3%83%93%E3%83%BC\")\n      end\n    end\n\n    describe \"with a permalink containing a space\" do\n      let(:article) do\n        blog.articles.build(permalink: \"hello there\",\n                            published_at: Time.utc(2004, 6, 1))\n      end\n\n      it \"escapes the space as '%20', not as '+'\" do\n        article.publish\n        expect(article.permalink_url(nil, true)).\n          to eq(\"#{blog.root_path}/2004/06/01/hello%20there\")\n      end\n    end\n\n    describe \"with a permalink containing a plus\" do\n      let(:article) do\n        blog.articles.build(permalink: \"one+two\", published_at: Time.utc(2004,\n                                                                         6, 1))\n      end\n\n      it \"does not escape the plus\" do\n        article.publish\n        expect(article.permalink_url(nil, true)).\n          to eq(\"#{blog.root_path}/2004/06/01/one+two\")\n      end\n    end\n\n    it \"returns nil when the article is not published\" do\n      article = blog.articles.build(permalink: \"one+two\")\n\n      expect(article.permalink_url(nil, true)).to be_nil\n    end\n  end\n\n  describe \"#initialize\" do\n    it \"accepts a settings field in its parameter hash\" do\n      blog.articles.build(\"password\" => \"foo\")\n    end\n  end\n\n  describe \".feed_url\" do\n    let(:article) do\n      build(:article, permalink: \"article-3\", published_at: Time.utc(2004, 6,\n                                                                     1))\n    end\n\n    it \"returns url for atom feed for a Atom 1.0 asked\" do\n      expect(article.feed_url(\"atom10\")).to eq \"#{blog.base_url}/2004/06/01/article-3.atom\"\n    end\n\n    it \"returns url for rss feed for a RSS 2 asked\" do\n      expect(article.feed_url(\"rss20\")).to eq \"#{blog.base_url}/2004/06/01/article-3.rss\"\n    end\n  end\n\n  it \"test_create\" do\n    a = blog.articles.build\n    a.user_id = 1\n    a.body = \"Foo\"\n    a.title = \"Zzz\"\n    assert a.save\n\n    a.tags << Tag.find(create(:tag).id)\n    assert_equal 1, a.tags.size\n\n    b = described_class.find(a.id)\n    assert_equal 1, b.tags.size\n  end\n\n  it \"test_permalink_with_title\" do\n    article = create(:article, permalink: \"article-3\", published_at: Time.utc(2004, 6, 1))\n    assert_equal(article, described_class.requested_article(year: 2004, month: 6, day: 1,\n                                                            title: \"article-3\"))\n    not_found = described_class.requested_article year: 2005, month: \"06\", day: \"01\",\n                                                  title: \"article-5\"\n    expect(not_found).to be_nil\n  end\n\n  it \"test_strip_title\" do\n    assert_equal \"article-3\", \"Article-3\".to_url\n    assert_equal \"article-3\", \"Article 3!?#\".to_url\n    assert_equal \"there-is-sex-in-my-violence\", \"There is Sex in my Violence!\".to_url\n    assert_equal \"article\", \"-article-\".to_url\n    assert_equal \"lorem-ipsum-dolor-sit-amet-consectetaur-adipisicing-elit\",\n                 \"Lorem ipsum dolor sit amet, consectetaur adipisicing elit\".to_url\n    assert_equal \"my-cats-best-friend\", \"My Cat's Best Friend\".to_url\n  end\n\n  describe \"#set_permalink\" do\n    it \"works for simple cases\" do\n      a = blog.articles.build(title: \"Article 3!\", state: :published)\n      a.set_permalink\n      expect(a.permalink).to eq \"article-3\"\n    end\n\n    it \"strips html\" do\n      a = blog.articles.build(title: \"This <i>is</i> a <b>test</b>\", state: :published)\n      a.set_permalink\n      assert_equal \"this-is-a-test\", a.permalink\n    end\n\n    it \"does not escape multibyte characters\" do\n      a = blog.articles.build(title: \"\u30eb\u30d3\u30fc\", state: :published)\n      a.set_permalink\n      expect(a.permalink).to eq(\"\u30eb\u30d3\u30fc\")\n    end\n\n    it \"is called upon saving a published article\" do\n      a = blog.articles.build(title: \"space separated\")\n      a.publish\n      expect(a.permalink).to be_nil\n      a.blog = create(:blog)\n      a.save\n      expect(a.permalink).to eq(\"space-separated\")\n    end\n\n    it \"does nothing for draft articles\" do\n      a = blog.articles.build(title: \"space separated\", state: :draft)\n      a.set_permalink\n      expect(a.permalink).to be_nil\n    end\n  end\n\n  describe \"the html_urls method\" do\n    let(:blog) { create :blog, text_filter: \"none\" }\n\n    before do\n      @article = blog.articles.build\n    end\n\n    it \"extracts URLs from the generated body html\" do\n      @article.body = 'happy halloween <a href=\"http://www.example.com/public\">with</a>'\n      urls = @article.html_urls\n      assert_equal [\"http://www.example.com/public\"], urls\n    end\n\n    it \"onlies match the href attribute\" do\n      @article.body = '<a href=\"http://a/b\">a</a> <a fhref=\"wrong\">wrong</a>'\n      urls = @article.html_urls\n      assert_equal [\"http://a/b\"], urls\n    end\n\n    it \"matches across newlines\" do\n      @article.body = \"<a\\nhref=\\\"http://foo/bar\\\">foo</a>\"\n      urls = @article.html_urls\n      assert_equal [\"http://foo/bar\"], urls\n    end\n\n    it \"matches with single quotes\" do\n      @article.body = \"<a href='http://foo/bar'>foo</a>\"\n      urls = @article.html_urls\n      assert_equal [\"http://foo/bar\"], urls\n    end\n\n    it \"matches with no quotes\" do\n      @article.body = \"<a href=http://foo/bar>foo</a>\"\n      urls = @article.html_urls\n      assert_equal [\"http://foo/bar\"], urls\n    end\n  end\n\n  describe \"Testing redirects\" do\n    it \"a new published article gets a redirect\" do\n      a = blog.articles.create!(title: \"Some title\", body: \"some text\")\n      a.publish!\n      expect(a.redirect).not_to be_nil\n      expect(a.redirect.to_path).to eq(a.permalink_url)\n    end\n\n    it \"a new unpublished article should not get a redirect\" do\n      a = blog.articles.create!(title: \"Some title\", body: \"some text\")\n      expect(a.redirect).to be_nil\n    end\n\n    it \"Changin a published article permalink url should only change the to redirection\" do\n      a = blog.articles.create!(title: \"Some title\", body: \"some text\")\n      a.publish!\n      expect(a.redirect).not_to be_nil\n      expect(a.redirect.to_path).to eq(a.permalink_url)\n      r = a.redirect.from_path\n\n      a.permalink = \"some-new-permalink\"\n      a.save\n      expect(a.redirect).not_to be_nil\n      expect(a.redirect.to_path).to eq(a.permalink_url)\n      expect(a.redirect.from_path).to eq(r)\n    end\n  end\n\n  it \"test_find_published_by_tag_name\" do\n    art1 = create(:article)\n    art2 = create(:article)\n    create(:tag, name: \"foo\", contents: [art1, art2])\n    articles = Tag.find_by(name: \"foo\").published_contents\n    assert_equal 2, articles.size\n  end\n\n  it \"test_future_publishing\" do\n    art = blog.articles.build(title: \"title\", body: \"body\",\n                              published_at: 2.seconds.from_now)\n    art.publish!\n\n    expect(art).to be_publication_pending\n\n    assert_equal 1, Trigger.count\n    assert Trigger.where(pending_item_id: art.id).first\n    assert !art.published?\n    Timecop.freeze(4.seconds.from_now) do\n      Trigger.fire\n    end\n    art.reload\n    assert art.published?\n  end\n\n  it \"test_triggers_are_dependent\" do\n    # TODO: Needs a fix for Rails ticket #5105: has_many: Dependent deleting\n    # does not work with STI\n    skip\n    art = blog.articles.create!(title: \"title\", body: \"body\",\n                                published_at: 1.hour.from_now)\n    assert_equal 1, Trigger.count\n    art.destroy\n    assert_equal 0, Trigger.count\n  end\n\n  it \"test_destroy_file_upload_associations\" do\n    a = create(:article)\n    create(:resource, content: a)\n    create(:resource, content: a)\n    assert_equal 2, a.resources.size\n    a.resources << create(:resource)\n    assert_equal 3, a.resources.size\n    a.destroy\n    assert_equal 0, Resource.where(content_id: a.id).size\n  end\n\n  describe \"#interested_users\" do\n    it \"gathers users interested in new articles\" do\n      henri = create(:user, login: \"henri\", notify_on_new_articles: true)\n      alice = create(:user, login: \"alice\", notify_on_new_articles: true)\n\n      a = build(:article)\n      users = a.interested_users\n      expect(users).to match_array [alice, henri]\n    end\n  end\n\n  it \"test_withdrawal\" do\n    art = create(:article)\n    assert art.published?\n    assert !art.withdrawn?\n    art.withdraw!\n    assert !art.published?\n    assert art.withdrawn?\n    art.reload\n    assert !art.published?\n    assert art.withdrawn?\n  end\n\n  it \"gets only ham not spam comment\" do\n    article = create(:article)\n    ham_comment = create(:comment, article: article)\n    create(:spam_comment, article: article)\n    expect(article.comments.ham).to eq([ham_comment])\n    expect(article.comments.count).to eq(2)\n  end\n\n  describe \"#access_by?\" do\n    before do\n      @alice = build(:user, :as_admin)\n    end\n\n    it \"admin should have access to an article written by another\" do\n      expect(build(:article)).to be_access_by(@alice)\n    end\n\n    it \"admin should have access to an article written by himself\" do\n      article = build(:article, author: @alice)\n      expect(article).to be_access_by(@alice)\n    end\n  end\n\n  describe \"body_and_extended\" do\n    before do\n      @article = blog.articles.build(\n        body: \"basic text\",\n        extended: \"extended text to explain more and more how Publify is wonderful\")\n    end\n\n    it \"combines body and extended content\" do\n      expect(@article.body_and_extended).to eq(\n        \"#{@article.body}\\n<!--more-->\\n#{@article.extended}\")\n    end\n\n    it \"does not insert <!--more--> tags if extended is empty\" do\n      @article.extended = \"\"\n      expect(@article.body_and_extended).to eq(@article.body)\n    end\n  end\n\n  describe \"#search\" do\n    describe \"with one word and result\" do\n      it \"has two items\" do\n        create(:article, extended: \"extended talk\")\n        create(:article, extended: \"Once uppon a time, an extended story\")\n        assert_equal 2, described_class.search(\"extended\").size\n      end\n    end\n  end\n\n  describe \"body_and_extended=\" do\n    before do\n      @article = blog.articles.build\n    end\n\n    it \"splits apart values at <!--more-->\" do\n      @article.body_and_extended = \"foo<!--more-->bar\"\n      expect(@article.body).to eq(\"foo\")\n      expect(@article.extended).to eq(\"bar\")\n    end\n\n    it \"removes newlines around <!--more-->\" do\n      @article.body_and_extended = \"foo\\n<!--more-->\\nbar\"\n      expect(@article.body).to eq(\"foo\")\n      expect(@article.extended).to eq(\"bar\")\n    end\n\n    it \"makes extended empty if no <!--more--> tag\" do\n      @article.body_and_extended = \"foo\"\n      expect(@article.body).to eq(\"foo\")\n      expect(@article.extended).to be_empty\n    end\n\n    it \"preserves extra <!--more--> tags\" do\n      @article.body_and_extended = \"foo<!--more-->bar<!--more-->baz\"\n      expect(@article.body).to eq(\"foo\")\n      expect(@article.extended).to eq(\"bar<!--more-->baz\")\n    end\n\n    it \"is settable via self.attributes=\" do\n      @article.attributes = { body_and_extended: \"foo<!--more-->bar\" }\n      expect(@article.body).to eq(\"foo\")\n      expect(@article.extended).to eq(\"bar\")\n    end\n  end\n\n  describe \"#html\" do\n    let(:article) { build_stubbed :article }\n\n    it \"returns an html_safe string\" do\n      expect(article.html).to be_html_safe\n    end\n  end\n\n  describe \"#comment_url\" do\n    it \"renders complete url of comment\" do\n      article = build_stubbed(:article, id: 123)\n      expect(article.comment_url).\n        to eq(\"#{blog.root_path}/comments?article_id=#{article.id}\")\n    end\n  end\n\n  describe \"#preview_comment_url\" do\n    it \"renders complete url of comment\" do\n      article = build_stubbed(:article, id: 123)\n      expect(article.preview_comment_url).\n        to eq(\"#{blog.root_path}/comments/preview?article_id=#{article.id}\")\n    end\n  end\n\n  describe \"#pings_closed?\" do\n    let!(:blog) do\n      create(:blog, sp_article_auto_close: 30)\n    end\n\n    it \"returns false for a fresh article if it allows pings\" do\n      a = create(:article, allow_pings: true)\n      assert_equal(false, a.pings_closed?)\n    end\n\n    it \"returns true for a fresh article if it does not allow pings\" do\n      a = create(:article, allow_pings: false)\n      assert_equal(true, a.pings_closed?)\n    end\n\n    it \"returns true for an old article even if it allows pings\" do\n      a = create(:article, published_at: 31.days.ago, allow_pings: true)\n      assert_equal(true, a.pings_closed?)\n    end\n  end\n\n  describe \"#published_at_like\" do\n    before do\n      # Note: these choices of times depend on no other articles within\n      # these timeframes existing in test/fixtures/contents.yaml.\n      # In particular, all articles there are from 2005 or earlier, which\n      # is now more than two years ago, except for two, which are from\n      # yesterday and the day before. The existence of those two makes\n      # 1.month.ago not suitable, because yesterday can be last month.\n      @article_two_month_ago = create(:article, published_at: 2.months.ago)\n\n      @article_four_months_ago = create(:article, published_at: 4.months.ago)\n      @article_2_four_months_ago = create(:article, published_at: 4.months.ago)\n\n      @article_two_year_ago = create(:article, published_at: 2.years.ago)\n      @article_2_two_year_ago = create(:article, published_at: 2.years.ago)\n    end\n\n    it \"returns all content for the year if only year sent\" do\n      expect(described_class.published_at_like(2.years.ago.strftime(\"%Y\")).map(&:id).sort).\n        to eq([@article_two_year_ago.id, @article_2_two_year_ago.id].sort)\n    end\n\n    it \"returns all content for the month if year and month sent\" do\n      result = described_class.published_at_like(4.months.ago.strftime(\"%Y-%m\")).\n        map(&:id).sort\n      expect(result).\n        to eq([@article_four_months_ago.id, @article_2_four_months_ago.id].sort)\n    end\n\n    it \"returns all content on this date if date send\" do\n      result = described_class.published_at_like(2.months.ago.strftime(\"%Y-%m-%d\")).\n        map(&:id).sort\n      expect(result).to eq([@article_two_month_ago.id].sort)\n    end\n  end\n\n  describe \"#has_child?\" do\n    it \"is true if article has one to link it by parent_id\" do\n      parent = create(:article)\n      create(:article, parent_id: parent.id)\n      expect(parent).to be_has_child\n    end\n\n    it \"is false if article has no article to link it by parent_id\" do\n      parent = create(:article)\n      create(:article, parent_id: nil)\n      expect(parent).not_to be_has_child\n    end\n  end\n\n  describe \"self#last_draft(id)\" do\n    it \"returns article if no draft associated\" do\n      draft = create(:article, state: \"draft\")\n      expect(described_class.last_draft(draft.id)).to eq(draft)\n    end\n\n    it \"returns draft associated to this article if there are one\" do\n      parent = create(:article)\n      draft = create(:article, parent_id: parent.id, state: \"draft\")\n      expect(described_class.last_draft(draft.id)).to eq(draft)\n    end\n  end\n\n  describe \"an article published just before midnight UTC\" do\n    around do |example|\n      Time.use_zone \"UTC\" do\n        @a = build(:article)\n        @a.set_permalink\n        @a.published_at = \"21 Feb 2011 23:30 UTC\"\n        example.call\n      end\n    end\n\n    describe \"#permalink_url\" do\n      it \"uses UTC to determine correct day\" do\n        expect(@a.permalink_url).to eq \"#{blog.base_url}/2011/02/21/a-big-article\"\n      end\n    end\n\n    describe \"#requested_article\" do\n      it \"uses UTC to determine correct day\" do\n        @a.save\n        a = described_class.requested_article year: 2011, month: 2, day: 21,\n                                              permalink: \"a-big-article\"\n        expect(a).to eq(@a)\n      end\n    end\n  end\n\n  describe \"an article published just after midnight UTC\" do\n    around do |example|\n      Time.use_zone \"UTC\" do\n        @a = build(:article)\n        @a.set_permalink\n        @a.published_at = \"22 Feb 2011 00:30 UTC\"\n        example.call\n      end\n    end\n\n    describe \"#permalink_url\" do\n      it \"uses UTC to determine correct day\" do\n        expect(@a.permalink_url).to eq \"#{blog.base_url}/2011/02/22/a-big-article\"\n      end\n    end\n\n    describe \"#requested_article\" do\n      it \"uses UTC to determine correct day\" do\n        @a.save\n        a = described_class.requested_article year: 2011, month: 2, day: 22,\n                                              permalink: \"a-big-article\"\n        expect(a).to eq(@a)\n      end\n    end\n  end\n\n  describe \"an article published just before midnight JST (+0900)\" do\n    around do |example|\n      Time.use_zone \"Tokyo\" do\n        @a = build(:article)\n        @a.set_permalink\n        @a.published_at = \"31 Dec 2012 23:30 +0900\"\n        example.call\n      end\n    end\n\n    describe \"#permalink_url\" do\n      it \"uses JST to determine correct day\" do\n        expect(@a.permalink_url).to eq \"#{blog.base_url}/2012/12/31/a-big-article\"\n      end\n    end\n\n    describe \"#requested_article\" do\n      it \"uses JST to determine correct day\" do\n        @a.save\n        a = described_class.requested_article year: 2012, month: 12, day: 31,\n                                              permalink: \"a-big-article\"\n        expect(a).to eq(@a)\n      end\n    end\n  end\n\n  describe \"an article published just after midnight JST (+0900)\" do\n    around do |example|\n      @time_zone = Time.zone\n      Time.use_zone \"Tokyo\" do\n        @a = build(:article)\n        @a.set_permalink\n        @a.published_at = \"1 Jan 2013 00:30 +0900\"\n        example.call\n      end\n    end\n\n    describe \"#permalink_url\" do\n      it \"uses JST to determine correct day\" do\n        expect(@a.permalink_url).to eq(\"#{blog.base_url}/2013/01/01/a-big-article\")\n      end\n    end\n\n    describe \"#requested_article\" do\n      it \"uses JST to determine correct day\" do\n        @a.save\n        a = described_class.requested_article year: 2013, month: 1, day: 1,\n                                              permalink: \"a-big-article\"\n        expect(a).to eq(@a)\n      end\n    end\n  end\n\n  describe \"#published_comments\" do\n    let(:article) { create :article }\n\n    it \"does not include withdrawn comments\" do\n      comment = create :published_comment, article: article\n      article.reload\n      expect(article.published_comments).to eq [comment]\n      comment.withdraw!\n      article.reload\n      expect(article.published_comments).to eq []\n    end\n\n    it \"sorts comments newest last\" do\n      old_comment = create :published_comment, article: article, created_at: 2.days.ago\n      new_comment = create :published_comment, article: article, created_at: 1.day.ago\n      article.reload\n      expect(article.published_comments).to eq [old_comment, new_comment]\n    end\n  end\n\n  describe \"#published_trackbacks\" do\n    let(:article) { create :article }\n\n    it \"does not include withdrawn trackbacks\" do\n      trackback = create :trackback, article: article\n      article.reload\n      expect(article.published_trackbacks).to eq [trackback]\n      trackback.withdraw!\n      article.reload\n      expect(article.published_trackbacks).to eq []\n    end\n\n    it \"sorts trackbacks newest last\" do\n      old_trackback = create :trackback, article: article, created_at: 2.days.ago\n      new_trackback = create :trackback, article: article, created_at: 1.day.ago\n      article.reload\n      expect(article.published_trackbacks).to eq [old_trackback, new_trackback]\n    end\n  end\n\n  describe \"#published_feedback\" do\n    let(:article) { create :article }\n\n    it \"does not include withdrawn comments or trackbacks\" do\n      comment = create :published_comment, article: article\n      trackback = create :trackback, article: article\n      article.reload\n      expect(article.published_feedback).to eq [comment, trackback]\n      comment.withdraw!\n      trackback.withdraw!\n      article.reload\n      expect(article.published_feedback).to eq []\n    end\n\n    it \"sorts feedback newest last\" do\n      old_comment = create :published_comment, article: article, created_at: 4.days.ago\n      old_trackback = create :trackback, article: article, created_at: 3.days.ago\n      new_comment = create :published_comment, article: article, created_at: 2.days.ago\n      new_trackback = create :trackback, article: article, created_at: 1.day.ago\n      article.reload\n      expect(article.published_feedback).\n        to eq [old_comment, old_trackback, new_comment, new_trackback]\n    end\n  end\n\n  describe \"save_attachments!\" do\n    it \"calls save_attachment for each file given\" do\n      first_file = OpenStruct.new\n      second_file = OpenStruct.new\n      hash = { a_key: first_file, a_second_key: second_file }\n      article = build(:article)\n      expect(article).to receive(:save_attachment!).with(first_file)\n      expect(article).to receive(:save_attachment!).with(second_file)\n      article.save_attachments!(hash)\n    end\n\n    it \"do nothing with nil given\" do\n      article = build(:article)\n      article.save_attachments!(nil)\n    end\n  end\n\n  describe \"save_attachment!\" do\n    let(:file) { file_upload(\"testfile.txt\", \"text/plain\") }\n\n    it \"adds a new resource\" do\n      article = create(:article)\n      article.save_attachment!(file)\n      article.reload\n\n      resource = article.resources.first\n      upload = resource.upload\n\n      expect(upload.file.basename).to eq \"testfile\"\n    end\n  end\n\n  describe \"#search_with\" do\n    subject { described_class.search_with(params) }\n\n    context \"without article\" do\n      let(:params) { nil }\n\n      it { expect(subject).to be_empty }\n    end\n\n    context \"with an article\" do\n      let(:params) { nil }\n      let!(:article) { create(:article) }\n\n      it { expect(subject).to eq([article]) }\n    end\n\n    context \"with two article but only one matching searchstring\" do\n      let(:params) { { searchstring: \"match the string\" } }\n      let!(:not_found_article) { create(:article) }\n      let!(:article) { create(:article, body: \"this match the string of article\") }\n\n      it { expect(subject).to eq([article]) }\n    end\n\n    context \"with two articles with differents states and published params\" do\n      let(:params) { { state: \"published\" } }\n      let!(:article) { create(:article, state: \"published\") }\n      let!(:draft_article) { create(:article, state: \"draft\") }\n\n      it { expect(subject).to eq([article]) }\n    end\n\n    context \"with two articles with differents states and no params\" do\n      let(:params) { nil }\n      let(:now) { DateTime.new(2011, 3, 12).in_time_zone }\n      let!(:article) { create(:article, state: \"published\", created_at: now) }\n      let!(:last_draft_article) do\n        create(:article, state: \"draft\",\n                         created_at: now + 2.days)\n      end\n      let!(:draft_article) { create(:article, state: \"draft\", created_at: now + 20.days) }\n\n      it { expect(subject).to eq([draft_article, last_draft_article, article]) }\n    end\n  end\n\n  describe \".allow_comments?\" do\n    it \"true if article set to true\" do\n      expect(blog.articles.build(allow_comments: true)).to be_allow_comments\n    end\n\n    it \"false if article set to false\" do\n      expect(blog.articles.build(allow_comments: false)).not_to be_allow_comments\n    end\n\n    context \"given an article with no allow comments state\" do\n      it \"returns true when blog default allow comments is true\" do\n        expect_any_instance_of(Blog).to receive(:default_allow_comments).and_return(true)\n        expect(blog.articles.build(allow_comments: nil)).to be_allow_comments\n      end\n\n      it \"returns false when blog default allow comments is true\" do\n        expect_any_instance_of(Blog).to receive(:default_allow_comments).and_return(false)\n        expect(blog.articles.build(allow_comments: nil)).not_to be_allow_comments\n      end\n    end\n  end\n\n  describe \".allow_pings?\" do\n    it \"true if article set to true\" do\n      expect(blog.articles.build(allow_pings: true)).to be_allow_pings\n    end\n\n    it \"false if article set to false\" do\n      expect(blog.articles.build(allow_pings: false)).not_to be_allow_pings\n    end\n\n    context \"given an article with no allow pings state\" do\n      it \"returns true when blog default allow pings is true\" do\n        expect_any_instance_of(Blog).to receive(:default_allow_pings).and_return(true)\n        expect(blog.articles.build(allow_pings: nil)).to be_allow_pings\n      end\n\n      it \"returns false when blog default allow pings is true\" do\n        expect_any_instance_of(Blog).to receive(:default_allow_pings).and_return(false)\n        expect(blog.articles.build(allow_pings: nil)).not_to be_allow_pings\n      end\n    end\n  end\n\n  describe \"#publication_months\" do\n    it \"returns an empty array when no articles\" do\n      expect(described_class.publication_months).to be_empty\n    end\n\n    it \"returns months of publication for published articles\" do\n      create(:article, published_at: Date.new(2010, 11, 23))\n      create(:article, published_at: Date.new(2002, 4, 9))\n      result = described_class.publication_months\n      expect(result).to match_array [[\"2010-11\"], [\"2002-04\"]]\n    end\n  end\n\n  describe \"published_since\" do\n    let(:time) { DateTime.new(2010, 11, 3, 23, 34).in_time_zone }\n\n    it \"empty when no articles\" do\n      expect(described_class.published_since(time)).to be_empty\n    end\n\n    it \"returns article that was published since\" do\n      article = create(:article, published_at: time + 2.hours)\n      expect(described_class.published_since(time)).to eq [article]\n    end\n\n    it \"returns only article that was published since last visit\" do\n      create(:article, published_at: time - 2.hours)\n      article = create(:article, published_at: time + 2.hours)\n      expect(described_class.published_since(time)).to eq [article]\n    end\n  end\n\n  describe \"bestof\" do\n    it \"returns empty array when no content\" do\n      expect(described_class.bestof).to be_empty\n    end\n\n    it \"returns article with comment count field\" do\n      create(:comment)\n      expect(described_class.bestof.first.comment_count.to_i).to eq 1\n    end\n\n    it \"counts comments but not trackbacks\" do\n      article = create :article\n      create :trackback, article: article\n      create_list :comment, 2, article: article\n\n      expect(described_class.bestof.first.comment_count.to_i).to eq 2\n    end\n\n    it \"returns only 5 articles\" do\n      create_list(:comment, 6)\n      expect(described_class.bestof.length).to eq(5)\n    end\n\n    it \"returns only published articles\" do\n      article = create(:article)\n      create(:comment, article: article)\n      unpublished_article = create(:article, state: \"draft\")\n      create(:comment, article: unpublished_article)\n      expect(described_class.published).to eq([article])\n      expect(described_class.bestof).to eq([article])\n    end\n\n    it \"returns article sorted by comment counts\" do\n      last_article = create(:article)\n      create(:comment, article: last_article)\n\n      first_article = create(:article)\n      create(:comment, article: first_article)\n      create(:comment, article: first_article)\n\n      expect(described_class.bestof).to eq([first_article, last_article])\n    end\n  end\n\n  describe \"update tags from article keywords\" do\n    before { article.save }\n\n    context \"without keywords\" do\n      let(:article) { build(:article, keywords: nil) }\n\n      it { expect(article.tags).to be_empty }\n    end\n\n    context \"with a simple keyword\" do\n      let(:article) { build(:article, keywords: \"foo\") }\n\n      it { expect(article.tags.size).to eq(1) }\n      it { expect(article.tags.first).to be_kind_of(Tag) }\n      it { expect(article.tags.first.name).to eq(\"foo\") }\n    end\n\n    context \"with two keyword separate by a space\" do\n      let(:article) { build(:article, keywords: \"foo bar\") }\n\n      it { expect(article.tags.size).to eq(2) }\n      it { expect(article.tags.map(&:name)).to eq(%w(foo bar)) }\n    end\n\n    context \"with two keyword separate by a coma\" do\n      let(:article) { build(:article, keywords: \"foo, bar\") }\n\n      it { expect(article.tags.size).to eq(2) }\n      it { expect(article.tags.map(&:name)).to eq(%w(foo bar)) }\n    end\n\n    context \"with two keyword with apostrophe\" do\n      let(:article) { build(:article, keywords: \"foo, l'bar\") }\n\n      it { expect(article.tags.size).to eq(3) }\n      it { expect(article.tags.map(&:name)).to eq(%w(foo l bar)) }\n    end\n\n    context \"with two identical keywords\" do\n      let(:article) { build(:article, keywords: \"same, same\") }\n\n      it { expect(article.tags.size).to eq(1) }\n      it { expect(article.tags.map(&:name)).to eq([\"same\"]) }\n    end\n\n    context \"with keywords with dot and quote\" do\n      let(:article) { build(:article, keywords: 'foo \"bar quiz\" web2.0') }\n\n      it { expect(article.tags.map(&:name)).to eq([\"foo\", \"bar-quiz\", \"web2-0\"]) }\n    end\n  end\n\n  describe \"#post_type\" do\n    context \"without post_type\" do\n      let(:article) { build(:article, post_type: \"\") }\n\n      it { expect(article.post_type).to eq(\"read\") }\n    end\n\n    context \"with a oldschool read post_type\" do\n      let(:article) { build(:article, post_type: \"read\") }\n\n      it { expect(article.post_type).to eq(\"read\") }\n    end\n\n    context \"with a specific myletter post_type\" do\n      let(:article) { build(:article, post_type: \"myletter\") }\n\n      it { expect(article.post_type).to eq(\"myletter\") }\n    end\n  end\n\n  describe \"#comments_closed?\" do\n    let!(:blog) do\n      create(:blog, sp_article_auto_close: auto_close_value,\n                    default_allow_comments: true)\n    end\n\n    context \"when auto_close setting is zero\" do\n      let(:auto_close_value) { 0 }\n\n      it \"allows comments for a newly published article\" do\n        art = build :article, published_at: 1.second.ago, blog: blog\n        assert !art.comments_closed?\n      end\n\n      it \"allows comments for a very old article\" do\n        art = build :article, created_at: 1000.days.ago, blog: blog\n        assert !art.comments_closed?\n      end\n    end\n\n    context \"when auto_close setting is nonzero\" do\n      let(:auto_close_value) { 30 }\n\n      it \"allows comments for a recently published article\" do\n        art = build :article, published_at: 29.days.ago, blog: blog\n        assert !art.comments_closed?\n      end\n\n      it \"does not allow comments for an old article\" do\n        art = build :article, published_at: 31.days.ago, blog: blog\n        assert art.comments_closed?\n      end\n    end\n  end\nend\n"], "fixing_code": ["# frozen_string_literal: true\n\nrequire \"aasm\"\nrequire \"uri\"\nrequire \"net/http\"\n\nclass Article < Content\n  include PublifyGuid\n  include ConfigManager\n\n  serialize :settings, Hash\n\n  content_fields :body, :extended\n\n  validates :guid, uniqueness: true\n  validates :title, presence: true\n\n  has_many :pings, dependent: :destroy\n  has_many :trackbacks, dependent: :destroy\n  has_many :feedback\n  has_many :triggers, as: :pending_item\n  has_many :comments, dependent: :destroy\n\n  before_save :set_permalink\n  before_create :create_guid\n  after_save :keywords_to_tags, :shorten_url\n\n  scope :child_of, ->(article_id) { where(parent_id: article_id) }\n  scope :published_since, ->(time) { published.where(\"published_at > ?\", time) }\n  scope :withdrawn, -> { where(state: \"withdrawn\").order(default_order) }\n  scope :pending, -> { where(state: \"publication_pending\").order(default_order) }\n\n  scope :bestof, lambda {\n    joins(:feedback).\n      where(\"feedback.type\" => \"Comment\",\n            \"contents.state\" => \"published\").\n      group(\"contents.id\").\n      select(\"contents.*, count(feedback.id) as comment_count\").\n      order(\"comment_count DESC\").\n      limit(5)\n  }\n\n  setting :password, :string, \"\"\n\n  attr_accessor :draft, :keywords\n\n  include AASM\n\n  aasm column: :state do\n    state :draft, initial: true\n    # TODO: Disallow if published_at in past\n    state :publication_pending, after_enter: :trigger_publication\n    state :published, after_enter: :really_send_notifications\n    state :withdrawn\n\n    event :withdraw do\n      transitions from: :published, to: :withdrawn\n      transitions from: :publication_pending, to: :draft\n    end\n\n    event :publish do\n      before do\n        self.published_at ||= Time.zone.now\n      end\n\n      transitions from: [:new, :draft], to: :publication_pending do\n        guard do\n          published_at > Time.zone.now\n        end\n      end\n\n      transitions from: [:new, :draft, :publication_pending], to: :published do\n        guard do\n          published_at <= Time.zone.now\n        end\n      end\n    end\n  end\n\n  def set_permalink\n    return if draft? || permalink.present?\n\n    self.permalink = title.to_permalink\n  end\n\n  def has_child?\n    Article.exists?(parent_id: id)\n  end\n\n  def post_type\n    post_type = self[:post_type]\n    post_type = \"read\" if post_type.blank?\n    post_type\n  end\n\n  def self.last_draft(article_id)\n    article = Article.find(article_id)\n    article = Article.child_of(article.id).first while article.has_child?\n    article\n  end\n\n  def self.search_with(params)\n    params ||= {}\n    scoped = super(params)\n    if %w(no_draft drafts published withdrawn pending).include?(params[:state])\n      scoped = scoped.send(params[:state])\n    end\n\n    scoped.order(\"created_at DESC\")\n  end\n\n  # FIXME: Use keyword params to clean up call sites.\n  def permalink_url(anchor = nil, only_path = false)\n    return unless published?\n\n    @cached_permalink_url ||= {}\n    @cached_permalink_url[\"#{anchor}#{only_path}\"] ||=\n      blog.url_for(permalink_url_options, anchor: anchor, only_path: only_path)\n  end\n\n  def save_attachments!(files)\n    files ||= {}\n    files.each_value { |f| save_attachment!(f) }\n  end\n\n  def save_attachment!(file)\n    resources.create!(upload: file, blog: blog)\n  end\n\n  def comment_url\n    blog.url_for(\"comments?article_id=#{id}\", only_path: true)\n  end\n\n  def preview_comment_url\n    blog.url_for(\"comments/preview?article_id=#{id}\", only_path: true)\n  end\n\n  def feed_url(format)\n    \"#{permalink_url}.#{format.gsub(/\\d/, \"\")}\"\n  end\n\n  def next\n    Article.where(\"published_at > ?\", published_at).order(\"published_at asc\").\n      limit(1).first\n  end\n\n  def previous\n    Article.where(\"published_at < ?\", published_at).order(\"published_at desc\").\n      limit(1).first\n  end\n\n  def publication_month\n    published_at.strftime(\"%Y-%m\")\n  end\n\n  def self.publication_months\n    result = select(\"published_at\").where(\"published_at is not NULL\").where(type: \"Article\")\n    result.map { |it| [it.publication_month] }.uniq\n  end\n\n  # Finds one article which was posted on a certain date and matches the\n  # supplied dashed-title params is a Hash\n  def self.requested_article(params)\n    date_range = PublifyTime.delta(params[:year], params[:month], params[:day])\n\n    req_params = {}\n    req_params[:permalink] = params[:title] if params[:title]\n    req_params[:published_at] = date_range if date_range\n\n    return if req_params.empty? # no search if no params send\n\n    article = published.find_by(req_params)\n    return article if article\n\n    if params[:title]\n      req_params[:permalink] = CGI.escape(params[:title])\n      article = published.find_by(req_params)\n      return article if article\n    end\n  end\n\n  # Fulltext searches the body of published articles\n  def self.search(query, args = {})\n    query_s = query.to_s.strip\n    if !query_s.empty? && args.empty?\n      Article.searchstring(query)\n    elsif !query_s.empty? && !args.empty?\n      Article.searchstring(query).page(args[:page]).per(args[:per])\n    else\n      []\n    end\n  end\n\n  def keywords_to_tags\n    Tag.create_from_article!(self)\n  end\n\n  def interested_users\n    User.where(notify_on_new_articles: true)\n  end\n\n  def notify_user_via_email(user)\n    EmailNotify.send_article(self, user) if user.notify_via_email?\n  end\n\n  def comments_closed?\n    !(allow_comments? && published? && in_feedback_window?)\n  end\n\n  def html_urls\n    urls = []\n    html.gsub(/<a\\s+[^>]*>/) do |tag|\n      urls.push(Regexp.last_match[2].strip) if tag =~ /\\bhref=([\"']?)([^ >\"]+)\\1/\n    end\n    urls.uniq\n  end\n\n  def pings_closed?\n    !(allow_pings? && in_feedback_window?)\n  end\n\n  # check if time to comment is open or not\n  def in_feedback_window?\n    blog.sp_article_auto_close.zero? ||\n      published_at.to_i > blog.sp_article_auto_close.days.ago.to_i\n  end\n\n  # The web interface no longer distinguishes between separate \"body\" and\n  # \"extended\" fields, and instead edits everything in a single edit field,\n  # separating the extended content using \"\\<!--more-->\".\n  def body_and_extended\n    if extended.blank?\n      body\n    else\n      \"#{body}\\n<!--more-->\\n#{extended}\"\n    end\n  end\n\n  # Split apart value around a \"\\<!--more-->\" comment and assign it to our\n  # #body and #extended fields.\n  def body_and_extended=(value)\n    parts = value.split(/\\n?<!--more-->\\n?/, 2)\n    self.body = parts[0]\n    self.extended = parts[1] || \"\"\n  end\n\n  def password_protected?\n    password.present?\n  end\n\n  def add_comment(params)\n    comments.build(params)\n  end\n\n  def access_by?(user)\n    user.admin? || user_id == user.id\n  end\n\n  def allow_comments?\n    return allow_comments unless allow_comments.nil?\n\n    blog.default_allow_comments\n  end\n\n  def allow_pings?\n    return allow_pings unless allow_pings.nil?\n\n    blog.default_allow_pings\n  end\n\n  def published_comments\n    comments.published.oldest_first\n  end\n\n  def published_trackbacks\n    trackbacks.published.oldest_first\n  end\n\n  def published_feedback\n    feedback.published.oldest_first\n  end\n\n  private\n\n  def permalink_url_options\n    format_url = blog.permalink_format.dup\n    format_url.gsub!(\"%year%\", published_at.year.to_s)\n    format_url.gsub!(\"%month%\", sprintf(\"%<month>.2d\", month: published_at.month))\n    format_url.gsub!(\"%day%\", sprintf(\"%<day>.2d\", day: published_at.day))\n    format_url.gsub!(\"%title%\", URI::DEFAULT_PARSER.escape(permalink.to_s))\n    if format_url[0, 1] == \"/\"\n      format_url[1..-1]\n    else\n      format_url\n    end\n  end\n\n  def trigger_publication\n    # TODO: Skip if already published, update when published_at changes\n    Trigger.post_action(published_at, self, \"publish!\")\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\n\nRSpec.describe CommentsController, type: :controller do\n  let!(:blog) { create(:blog) }\n  let(:article) { create(:article) }\n  let(:user) { create(:user) }\n  let(:comment_params) do\n    { body: \"content\", author: \"bob\", email: \"bob@home\", url: \"http://bobs.home/\" }\n  end\n\n  describe \"#create\" do\n    render_views\n\n    it \"creates a comment on the specified article\" do\n      post :create, params: { comment: comment_params, article_id: article.id }\n      aggregate_failures do\n        expect(article.comments.size).to eq(1)\n        comment = article.comments.last\n        expect(comment.author).to eq(\"bob\")\n        expect(comment.body).to eq(\"content\")\n        expect(comment.email).to eq(\"bob@home\")\n        expect(comment.url).to eq(\"http://bobs.home/\")\n      end\n    end\n\n    it \"remembers author info in cookies\" do\n      post :create, params: { comment: comment_params, article_id: article.id }\n      aggregate_failures do\n        expect(cookies[\"author\"]).to eq(\"bob\")\n        expect(cookies[\"gravatar_id\"]).to eq(Digest::MD5.hexdigest(\"bob@home\"))\n        expect(cookies[\"url\"]).to eq(\"http://bobs.home/\")\n      end\n    end\n\n    it \"sets the user if logged in\" do\n      sign_in user\n      post :create, params: { comment: comment_params, article_id: article.id }\n      comment = article.comments.last\n      expect(comment.user).to eq user\n    end\n\n    it \"assigns the created comment\" do\n      post :create, params: { comment: comment_params, article_id: article.id }\n      expect(assigns[:comment]).to eq article.comments.last\n    end\n\n    it \"redirects to the article when using regular post\" do\n      post :create, params: { comment: comment_params, article_id: article.id }\n      expect(response).to redirect_to article.permalink_url\n    end\n\n    it \"renders the comment when using xhr post\" do\n      post :create, xhr: true, params: { comment: comment_params, article_id: article.id }\n      aggregate_failures do\n        expect(response).to render_template(\"articles/comment\")\n        expect(response.body).to have_text \"content\"\n      end\n    end\n\n    it \"does not allow commenting if article does not allow comments\" do\n      no_comments = create(:article, allow_comments: false)\n      expect do\n        post :create, xhr: true, params: { comment: comment_params,\n                                           article_id: no_comments.id }\n      end.not_to change(no_comments.comments, :count)\n    end\n\n    it \"does not allow commenting if article is draft\" do\n      draft = create(:article, state: \"draft\")\n      expect do\n        post :create, xhr: true, params: { comment: comment_params, article_id: draft.id }\n      end.not_to change(draft.comments, :count)\n    end\n  end\n\n  describe \"#preview\" do\n    context \"when using xhr post\" do\n      before do\n        post :preview, xhr: true, params: { comment: comment_params,\n                                            article_id: article.id }\n      end\n\n      it \"assigns a comment with the given parameters\" do\n        comment = assigns[:comment]\n        aggregate_failures do\n          expect(comment.author).to eq(\"bob\")\n          expect(comment.body).to eq(\"content\")\n          expect(comment.email).to eq(\"bob@home\")\n          expect(comment.url).to eq(\"http://bobs.home/\")\n        end\n      end\n\n      it \"assigns the article to the comment\" do\n        expect(assigns[:comment].article).to eq article\n      end\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\nrequire \"timecop\"\n\ndescribe Article, type: :model do\n  let(:blog) { create(:blog) }\n\n  it \"test_content_fields\" do\n    a = blog.articles.build\n    assert_equal [:body, :extended], a.content_fields\n  end\n\n  describe \"#permalink_url\" do\n    describe \"with hostname\" do\n      let(:article) do\n        blog.articles.build(permalink: \"article-3\",\n                            published_at: Time.utc(2004, 6, 1))\n      end\n\n      it \"includes the full blog url\" do\n        article.publish\n        expect(article.permalink_url(nil, false)).\n          to eq \"#{blog.base_url}/2004/06/01/article-3\"\n      end\n    end\n\n    describe \"without hostname\" do\n      let(:article) do\n        blog.articles.build(permalink: \"article-3\",\n                            published_at: Time.utc(2004, 6, 1))\n      end\n\n      it \"includes just the blog root path\" do\n        article.publish\n        expect(article.permalink_url(nil, true)).\n          to eq \"#{blog.root_path}/2004/06/01/article-3\"\n      end\n    end\n\n    # NOTE: URLs must not have any multibyte characters in them. The\n    # browser may display them differently, though.\n    describe \"with a multibyte permalink\" do\n      let(:article) do\n        blog.articles.build(permalink: \"\u30eb\u30d3\u30fc\",\n                            published_at: Time.utc(2004, 6, 1))\n      end\n\n      it \"escapes the multibyte characters\" do\n        article.publish\n        expect(article.permalink_url(nil, true)).\n          to eq(\"#{blog.root_path}/2004/06/01/%E3%83%AB%E3%83%93%E3%83%BC\")\n      end\n    end\n\n    describe \"with a permalink containing a space\" do\n      let(:article) do\n        blog.articles.build(permalink: \"hello there\",\n                            published_at: Time.utc(2004, 6, 1))\n      end\n\n      it \"escapes the space as '%20', not as '+'\" do\n        article.publish\n        expect(article.permalink_url(nil, true)).\n          to eq(\"#{blog.root_path}/2004/06/01/hello%20there\")\n      end\n    end\n\n    describe \"with a permalink containing a plus\" do\n      let(:article) do\n        blog.articles.build(permalink: \"one+two\", published_at: Time.utc(2004,\n                                                                         6, 1))\n      end\n\n      it \"does not escape the plus\" do\n        article.publish\n        expect(article.permalink_url(nil, true)).\n          to eq(\"#{blog.root_path}/2004/06/01/one+two\")\n      end\n    end\n\n    it \"returns nil when the article is not published\" do\n      article = blog.articles.build(permalink: \"one+two\")\n\n      expect(article.permalink_url(nil, true)).to be_nil\n    end\n  end\n\n  describe \"#initialize\" do\n    it \"accepts a settings field in its parameter hash\" do\n      blog.articles.build(\"password\" => \"foo\")\n    end\n  end\n\n  describe \".feed_url\" do\n    let(:article) do\n      build(:article, permalink: \"article-3\", published_at: Time.utc(2004, 6,\n                                                                     1))\n    end\n\n    it \"returns url for atom feed for a Atom 1.0 asked\" do\n      expect(article.feed_url(\"atom10\")).to eq \"#{blog.base_url}/2004/06/01/article-3.atom\"\n    end\n\n    it \"returns url for rss feed for a RSS 2 asked\" do\n      expect(article.feed_url(\"rss20\")).to eq \"#{blog.base_url}/2004/06/01/article-3.rss\"\n    end\n  end\n\n  it \"test_create\" do\n    a = blog.articles.build\n    a.user_id = 1\n    a.body = \"Foo\"\n    a.title = \"Zzz\"\n    assert a.save\n\n    a.tags << Tag.find(create(:tag).id)\n    assert_equal 1, a.tags.size\n\n    b = described_class.find(a.id)\n    assert_equal 1, b.tags.size\n  end\n\n  it \"test_permalink_with_title\" do\n    article = create(:article, permalink: \"article-3\", published_at: Time.utc(2004, 6, 1))\n    assert_equal(article, described_class.requested_article(year: 2004, month: 6, day: 1,\n                                                            title: \"article-3\"))\n    not_found = described_class.requested_article year: 2005, month: \"06\", day: \"01\",\n                                                  title: \"article-5\"\n    expect(not_found).to be_nil\n  end\n\n  it \"test_strip_title\" do\n    assert_equal \"article-3\", \"Article-3\".to_url\n    assert_equal \"article-3\", \"Article 3!?#\".to_url\n    assert_equal \"there-is-sex-in-my-violence\", \"There is Sex in my Violence!\".to_url\n    assert_equal \"article\", \"-article-\".to_url\n    assert_equal \"lorem-ipsum-dolor-sit-amet-consectetaur-adipisicing-elit\",\n                 \"Lorem ipsum dolor sit amet, consectetaur adipisicing elit\".to_url\n    assert_equal \"my-cats-best-friend\", \"My Cat's Best Friend\".to_url\n  end\n\n  describe \"#set_permalink\" do\n    it \"works for simple cases\" do\n      a = blog.articles.build(title: \"Article 3!\", state: :published)\n      a.set_permalink\n      expect(a.permalink).to eq \"article-3\"\n    end\n\n    it \"strips html\" do\n      a = blog.articles.build(title: \"This <i>is</i> a <b>test</b>\", state: :published)\n      a.set_permalink\n      assert_equal \"this-is-a-test\", a.permalink\n    end\n\n    it \"does not escape multibyte characters\" do\n      a = blog.articles.build(title: \"\u30eb\u30d3\u30fc\", state: :published)\n      a.set_permalink\n      expect(a.permalink).to eq(\"\u30eb\u30d3\u30fc\")\n    end\n\n    it \"is called upon saving a published article\" do\n      a = blog.articles.build(title: \"space separated\")\n      a.publish\n      expect(a.permalink).to be_nil\n      a.blog = create(:blog)\n      a.save\n      expect(a.permalink).to eq(\"space-separated\")\n    end\n\n    it \"does nothing for draft articles\" do\n      a = blog.articles.build(title: \"space separated\", state: :draft)\n      a.set_permalink\n      expect(a.permalink).to be_nil\n    end\n  end\n\n  describe \"the html_urls method\" do\n    let(:blog) { create :blog, text_filter: \"none\" }\n\n    before do\n      @article = blog.articles.build\n    end\n\n    it \"extracts URLs from the generated body html\" do\n      @article.body = 'happy halloween <a href=\"http://www.example.com/public\">with</a>'\n      urls = @article.html_urls\n      assert_equal [\"http://www.example.com/public\"], urls\n    end\n\n    it \"onlies match the href attribute\" do\n      @article.body = '<a href=\"http://a/b\">a</a> <a fhref=\"wrong\">wrong</a>'\n      urls = @article.html_urls\n      assert_equal [\"http://a/b\"], urls\n    end\n\n    it \"matches across newlines\" do\n      @article.body = \"<a\\nhref=\\\"http://foo/bar\\\">foo</a>\"\n      urls = @article.html_urls\n      assert_equal [\"http://foo/bar\"], urls\n    end\n\n    it \"matches with single quotes\" do\n      @article.body = \"<a href='http://foo/bar'>foo</a>\"\n      urls = @article.html_urls\n      assert_equal [\"http://foo/bar\"], urls\n    end\n\n    it \"matches with no quotes\" do\n      @article.body = \"<a href=http://foo/bar>foo</a>\"\n      urls = @article.html_urls\n      assert_equal [\"http://foo/bar\"], urls\n    end\n  end\n\n  describe \"Testing redirects\" do\n    it \"a new published article gets a redirect\" do\n      a = blog.articles.create!(title: \"Some title\", body: \"some text\")\n      a.publish!\n      expect(a.redirect).not_to be_nil\n      expect(a.redirect.to_path).to eq(a.permalink_url)\n    end\n\n    it \"a new unpublished article should not get a redirect\" do\n      a = blog.articles.create!(title: \"Some title\", body: \"some text\")\n      expect(a.redirect).to be_nil\n    end\n\n    it \"Changin a published article permalink url should only change the to redirection\" do\n      a = blog.articles.create!(title: \"Some title\", body: \"some text\")\n      a.publish!\n      expect(a.redirect).not_to be_nil\n      expect(a.redirect.to_path).to eq(a.permalink_url)\n      r = a.redirect.from_path\n\n      a.permalink = \"some-new-permalink\"\n      a.save\n      expect(a.redirect).not_to be_nil\n      expect(a.redirect.to_path).to eq(a.permalink_url)\n      expect(a.redirect.from_path).to eq(r)\n    end\n  end\n\n  it \"test_find_published_by_tag_name\" do\n    art1 = create(:article)\n    art2 = create(:article)\n    create(:tag, name: \"foo\", contents: [art1, art2])\n    articles = Tag.find_by(name: \"foo\").published_contents\n    assert_equal 2, articles.size\n  end\n\n  it \"test_future_publishing\" do\n    art = blog.articles.build(title: \"title\", body: \"body\",\n                              published_at: 2.seconds.from_now)\n    art.publish!\n\n    expect(art).to be_publication_pending\n\n    assert_equal 1, Trigger.count\n    assert Trigger.where(pending_item_id: art.id).first\n    assert !art.published?\n    Timecop.freeze(4.seconds.from_now) do\n      Trigger.fire\n    end\n    art.reload\n    assert art.published?\n  end\n\n  it \"test_triggers_are_dependent\" do\n    # TODO: Needs a fix for Rails ticket #5105: has_many: Dependent deleting\n    # does not work with STI\n    skip\n    art = blog.articles.create!(title: \"title\", body: \"body\",\n                                published_at: 1.hour.from_now)\n    assert_equal 1, Trigger.count\n    art.destroy\n    assert_equal 0, Trigger.count\n  end\n\n  it \"test_destroy_file_upload_associations\" do\n    a = create(:article)\n    create(:resource, content: a)\n    create(:resource, content: a)\n    assert_equal 2, a.resources.size\n    a.resources << create(:resource)\n    assert_equal 3, a.resources.size\n    a.destroy\n    assert_equal 0, Resource.where(content_id: a.id).size\n  end\n\n  describe \"#interested_users\" do\n    it \"gathers users interested in new articles\" do\n      henri = create(:user, login: \"henri\", notify_on_new_articles: true)\n      alice = create(:user, login: \"alice\", notify_on_new_articles: true)\n\n      a = build(:article)\n      users = a.interested_users\n      expect(users).to match_array [alice, henri]\n    end\n  end\n\n  it \"test_withdrawal\" do\n    art = create(:article)\n    assert art.published?\n    assert !art.withdrawn?\n    art.withdraw!\n    assert !art.published?\n    assert art.withdrawn?\n    art.reload\n    assert !art.published?\n    assert art.withdrawn?\n  end\n\n  it \"gets only ham not spam comment\" do\n    article = create(:article)\n    ham_comment = create(:comment, article: article)\n    create(:spam_comment, article: article)\n    expect(article.comments.ham).to eq([ham_comment])\n    expect(article.comments.count).to eq(2)\n  end\n\n  describe \"#access_by?\" do\n    before do\n      @alice = build(:user, :as_admin)\n    end\n\n    it \"admin should have access to an article written by another\" do\n      expect(build(:article)).to be_access_by(@alice)\n    end\n\n    it \"admin should have access to an article written by himself\" do\n      article = build(:article, author: @alice)\n      expect(article).to be_access_by(@alice)\n    end\n  end\n\n  describe \"body_and_extended\" do\n    before do\n      @article = blog.articles.build(\n        body: \"basic text\",\n        extended: \"extended text to explain more and more how Publify is wonderful\")\n    end\n\n    it \"combines body and extended content\" do\n      expect(@article.body_and_extended).to eq(\n        \"#{@article.body}\\n<!--more-->\\n#{@article.extended}\")\n    end\n\n    it \"does not insert <!--more--> tags if extended is empty\" do\n      @article.extended = \"\"\n      expect(@article.body_and_extended).to eq(@article.body)\n    end\n  end\n\n  describe \"#search\" do\n    describe \"with one word and result\" do\n      it \"has two items\" do\n        create(:article, extended: \"extended talk\")\n        create(:article, extended: \"Once uppon a time, an extended story\")\n        assert_equal 2, described_class.search(\"extended\").size\n      end\n    end\n  end\n\n  describe \"body_and_extended=\" do\n    before do\n      @article = blog.articles.build\n    end\n\n    it \"splits apart values at <!--more-->\" do\n      @article.body_and_extended = \"foo<!--more-->bar\"\n      expect(@article.body).to eq(\"foo\")\n      expect(@article.extended).to eq(\"bar\")\n    end\n\n    it \"removes newlines around <!--more-->\" do\n      @article.body_and_extended = \"foo\\n<!--more-->\\nbar\"\n      expect(@article.body).to eq(\"foo\")\n      expect(@article.extended).to eq(\"bar\")\n    end\n\n    it \"makes extended empty if no <!--more--> tag\" do\n      @article.body_and_extended = \"foo\"\n      expect(@article.body).to eq(\"foo\")\n      expect(@article.extended).to be_empty\n    end\n\n    it \"preserves extra <!--more--> tags\" do\n      @article.body_and_extended = \"foo<!--more-->bar<!--more-->baz\"\n      expect(@article.body).to eq(\"foo\")\n      expect(@article.extended).to eq(\"bar<!--more-->baz\")\n    end\n\n    it \"is settable via self.attributes=\" do\n      @article.attributes = { body_and_extended: \"foo<!--more-->bar\" }\n      expect(@article.body).to eq(\"foo\")\n      expect(@article.extended).to eq(\"bar\")\n    end\n  end\n\n  describe \"#html\" do\n    let(:article) { build_stubbed :article }\n\n    it \"returns an html_safe string\" do\n      expect(article.html).to be_html_safe\n    end\n  end\n\n  describe \"#comment_url\" do\n    it \"renders complete url of comment\" do\n      article = build_stubbed(:article, id: 123)\n      expect(article.comment_url).\n        to eq(\"#{blog.root_path}/comments?article_id=#{article.id}\")\n    end\n  end\n\n  describe \"#preview_comment_url\" do\n    it \"renders complete url of comment\" do\n      article = build_stubbed(:article, id: 123)\n      expect(article.preview_comment_url).\n        to eq(\"#{blog.root_path}/comments/preview?article_id=#{article.id}\")\n    end\n  end\n\n  describe \"#pings_closed?\" do\n    let!(:blog) do\n      create(:blog, sp_article_auto_close: 30)\n    end\n\n    it \"returns false for a fresh article if it allows pings\" do\n      a = create(:article, allow_pings: true)\n      assert_equal(false, a.pings_closed?)\n    end\n\n    it \"returns true for a fresh article if it does not allow pings\" do\n      a = create(:article, allow_pings: false)\n      assert_equal(true, a.pings_closed?)\n    end\n\n    it \"returns true for an old article even if it allows pings\" do\n      a = create(:article, published_at: 31.days.ago, allow_pings: true)\n      assert_equal(true, a.pings_closed?)\n    end\n  end\n\n  describe \"#published_at_like\" do\n    before do\n      # Note: these choices of times depend on no other articles within\n      # these timeframes existing in test/fixtures/contents.yaml.\n      # In particular, all articles there are from 2005 or earlier, which\n      # is now more than two years ago, except for two, which are from\n      # yesterday and the day before. The existence of those two makes\n      # 1.month.ago not suitable, because yesterday can be last month.\n      @article_two_month_ago = create(:article, published_at: 2.months.ago)\n\n      @article_four_months_ago = create(:article, published_at: 4.months.ago)\n      @article_2_four_months_ago = create(:article, published_at: 4.months.ago)\n\n      @article_two_year_ago = create(:article, published_at: 2.years.ago)\n      @article_2_two_year_ago = create(:article, published_at: 2.years.ago)\n    end\n\n    it \"returns all content for the year if only year sent\" do\n      expect(described_class.published_at_like(2.years.ago.strftime(\"%Y\")).map(&:id).sort).\n        to eq([@article_two_year_ago.id, @article_2_two_year_ago.id].sort)\n    end\n\n    it \"returns all content for the month if year and month sent\" do\n      result = described_class.published_at_like(4.months.ago.strftime(\"%Y-%m\")).\n        map(&:id).sort\n      expect(result).\n        to eq([@article_four_months_ago.id, @article_2_four_months_ago.id].sort)\n    end\n\n    it \"returns all content on this date if date send\" do\n      result = described_class.published_at_like(2.months.ago.strftime(\"%Y-%m-%d\")).\n        map(&:id).sort\n      expect(result).to eq([@article_two_month_ago.id].sort)\n    end\n  end\n\n  describe \"#has_child?\" do\n    it \"is true if article has one to link it by parent_id\" do\n      parent = create(:article)\n      create(:article, parent_id: parent.id)\n      expect(parent).to be_has_child\n    end\n\n    it \"is false if article has no article to link it by parent_id\" do\n      parent = create(:article)\n      create(:article, parent_id: nil)\n      expect(parent).not_to be_has_child\n    end\n  end\n\n  describe \"self#last_draft(id)\" do\n    it \"returns article if no draft associated\" do\n      draft = create(:article, state: \"draft\")\n      expect(described_class.last_draft(draft.id)).to eq(draft)\n    end\n\n    it \"returns draft associated to this article if there are one\" do\n      parent = create(:article)\n      draft = create(:article, parent_id: parent.id, state: \"draft\")\n      expect(described_class.last_draft(draft.id)).to eq(draft)\n    end\n  end\n\n  describe \"an article published just before midnight UTC\" do\n    around do |example|\n      Time.use_zone \"UTC\" do\n        @a = build(:article)\n        @a.set_permalink\n        @a.published_at = \"21 Feb 2011 23:30 UTC\"\n        example.call\n      end\n    end\n\n    describe \"#permalink_url\" do\n      it \"uses UTC to determine correct day\" do\n        expect(@a.permalink_url).to eq \"#{blog.base_url}/2011/02/21/a-big-article\"\n      end\n    end\n\n    describe \"#requested_article\" do\n      it \"uses UTC to determine correct day\" do\n        @a.save\n        a = described_class.requested_article year: 2011, month: 2, day: 21,\n                                              permalink: \"a-big-article\"\n        expect(a).to eq(@a)\n      end\n    end\n  end\n\n  describe \"an article published just after midnight UTC\" do\n    around do |example|\n      Time.use_zone \"UTC\" do\n        @a = build(:article)\n        @a.set_permalink\n        @a.published_at = \"22 Feb 2011 00:30 UTC\"\n        example.call\n      end\n    end\n\n    describe \"#permalink_url\" do\n      it \"uses UTC to determine correct day\" do\n        expect(@a.permalink_url).to eq \"#{blog.base_url}/2011/02/22/a-big-article\"\n      end\n    end\n\n    describe \"#requested_article\" do\n      it \"uses UTC to determine correct day\" do\n        @a.save\n        a = described_class.requested_article year: 2011, month: 2, day: 22,\n                                              permalink: \"a-big-article\"\n        expect(a).to eq(@a)\n      end\n    end\n  end\n\n  describe \"an article published just before midnight JST (+0900)\" do\n    around do |example|\n      Time.use_zone \"Tokyo\" do\n        @a = build(:article)\n        @a.set_permalink\n        @a.published_at = \"31 Dec 2012 23:30 +0900\"\n        example.call\n      end\n    end\n\n    describe \"#permalink_url\" do\n      it \"uses JST to determine correct day\" do\n        expect(@a.permalink_url).to eq \"#{blog.base_url}/2012/12/31/a-big-article\"\n      end\n    end\n\n    describe \"#requested_article\" do\n      it \"uses JST to determine correct day\" do\n        @a.save\n        a = described_class.requested_article year: 2012, month: 12, day: 31,\n                                              permalink: \"a-big-article\"\n        expect(a).to eq(@a)\n      end\n    end\n  end\n\n  describe \"an article published just after midnight JST (+0900)\" do\n    around do |example|\n      @time_zone = Time.zone\n      Time.use_zone \"Tokyo\" do\n        @a = build(:article)\n        @a.set_permalink\n        @a.published_at = \"1 Jan 2013 00:30 +0900\"\n        example.call\n      end\n    end\n\n    describe \"#permalink_url\" do\n      it \"uses JST to determine correct day\" do\n        expect(@a.permalink_url).to eq(\"#{blog.base_url}/2013/01/01/a-big-article\")\n      end\n    end\n\n    describe \"#requested_article\" do\n      it \"uses JST to determine correct day\" do\n        @a.save\n        a = described_class.requested_article year: 2013, month: 1, day: 1,\n                                              permalink: \"a-big-article\"\n        expect(a).to eq(@a)\n      end\n    end\n  end\n\n  describe \"#published_comments\" do\n    let(:article) { create :article }\n\n    it \"does not include withdrawn comments\" do\n      comment = create :published_comment, article: article\n      article.reload\n      expect(article.published_comments).to eq [comment]\n      comment.withdraw!\n      article.reload\n      expect(article.published_comments).to eq []\n    end\n\n    it \"sorts comments newest last\" do\n      old_comment = create :published_comment, article: article, created_at: 2.days.ago\n      new_comment = create :published_comment, article: article, created_at: 1.day.ago\n      article.reload\n      expect(article.published_comments).to eq [old_comment, new_comment]\n    end\n  end\n\n  describe \"#published_trackbacks\" do\n    let(:article) { create :article }\n\n    it \"does not include withdrawn trackbacks\" do\n      trackback = create :trackback, article: article\n      article.reload\n      expect(article.published_trackbacks).to eq [trackback]\n      trackback.withdraw!\n      article.reload\n      expect(article.published_trackbacks).to eq []\n    end\n\n    it \"sorts trackbacks newest last\" do\n      old_trackback = create :trackback, article: article, created_at: 2.days.ago\n      new_trackback = create :trackback, article: article, created_at: 1.day.ago\n      article.reload\n      expect(article.published_trackbacks).to eq [old_trackback, new_trackback]\n    end\n  end\n\n  describe \"#published_feedback\" do\n    let(:article) { create :article }\n\n    it \"does not include withdrawn comments or trackbacks\" do\n      comment = create :published_comment, article: article\n      trackback = create :trackback, article: article\n      article.reload\n      expect(article.published_feedback).to eq [comment, trackback]\n      comment.withdraw!\n      trackback.withdraw!\n      article.reload\n      expect(article.published_feedback).to eq []\n    end\n\n    it \"sorts feedback newest last\" do\n      old_comment = create :published_comment, article: article, created_at: 4.days.ago\n      old_trackback = create :trackback, article: article, created_at: 3.days.ago\n      new_comment = create :published_comment, article: article, created_at: 2.days.ago\n      new_trackback = create :trackback, article: article, created_at: 1.day.ago\n      article.reload\n      expect(article.published_feedback).\n        to eq [old_comment, old_trackback, new_comment, new_trackback]\n    end\n  end\n\n  describe \"save_attachments!\" do\n    it \"calls save_attachment for each file given\" do\n      first_file = OpenStruct.new\n      second_file = OpenStruct.new\n      hash = { a_key: first_file, a_second_key: second_file }\n      article = build(:article)\n      expect(article).to receive(:save_attachment!).with(first_file)\n      expect(article).to receive(:save_attachment!).with(second_file)\n      article.save_attachments!(hash)\n    end\n\n    it \"do nothing with nil given\" do\n      article = build(:article)\n      article.save_attachments!(nil)\n    end\n  end\n\n  describe \"save_attachment!\" do\n    let(:file) { file_upload(\"testfile.txt\", \"text/plain\") }\n\n    it \"adds a new resource\" do\n      article = create(:article)\n      article.save_attachment!(file)\n      article.reload\n\n      resource = article.resources.first\n      upload = resource.upload\n\n      expect(upload.file.basename).to eq \"testfile\"\n    end\n  end\n\n  describe \"#search_with\" do\n    subject { described_class.search_with(params) }\n\n    context \"without article\" do\n      let(:params) { nil }\n\n      it { expect(subject).to be_empty }\n    end\n\n    context \"with an article\" do\n      let(:params) { nil }\n      let!(:article) { create(:article) }\n\n      it { expect(subject).to eq([article]) }\n    end\n\n    context \"with two article but only one matching searchstring\" do\n      let(:params) { { searchstring: \"match the string\" } }\n      let!(:not_found_article) { create(:article) }\n      let!(:article) { create(:article, body: \"this match the string of article\") }\n\n      it { expect(subject).to eq([article]) }\n    end\n\n    context \"with two articles with differents states and published params\" do\n      let(:params) { { state: \"published\" } }\n      let!(:article) { create(:article, state: \"published\") }\n      let!(:draft_article) { create(:article, state: \"draft\") }\n\n      it { expect(subject).to eq([article]) }\n    end\n\n    context \"with two articles with differents states and no params\" do\n      let(:params) { nil }\n      let(:now) { DateTime.new(2011, 3, 12).in_time_zone }\n      let!(:article) { create(:article, state: \"published\", created_at: now) }\n      let!(:last_draft_article) do\n        create(:article, state: \"draft\",\n                         created_at: now + 2.days)\n      end\n      let!(:draft_article) { create(:article, state: \"draft\", created_at: now + 20.days) }\n\n      it { expect(subject).to eq([draft_article, last_draft_article, article]) }\n    end\n  end\n\n  describe \".allow_comments?\" do\n    it \"true if article set to true\" do\n      expect(blog.articles.build(allow_comments: true)).to be_allow_comments\n    end\n\n    it \"false if article set to false\" do\n      expect(blog.articles.build(allow_comments: false)).not_to be_allow_comments\n    end\n\n    context \"given an article with no allow comments state\" do\n      it \"returns true when blog default allow comments is true\" do\n        expect_any_instance_of(Blog).to receive(:default_allow_comments).and_return(true)\n        expect(blog.articles.build(allow_comments: nil)).to be_allow_comments\n      end\n\n      it \"returns false when blog default allow comments is true\" do\n        expect_any_instance_of(Blog).to receive(:default_allow_comments).and_return(false)\n        expect(blog.articles.build(allow_comments: nil)).not_to be_allow_comments\n      end\n    end\n  end\n\n  describe \".allow_pings?\" do\n    it \"true if article set to true\" do\n      expect(blog.articles.build(allow_pings: true)).to be_allow_pings\n    end\n\n    it \"false if article set to false\" do\n      expect(blog.articles.build(allow_pings: false)).not_to be_allow_pings\n    end\n\n    context \"given an article with no allow pings state\" do\n      it \"returns true when blog default allow pings is true\" do\n        expect_any_instance_of(Blog).to receive(:default_allow_pings).and_return(true)\n        expect(blog.articles.build(allow_pings: nil)).to be_allow_pings\n      end\n\n      it \"returns false when blog default allow pings is true\" do\n        expect_any_instance_of(Blog).to receive(:default_allow_pings).and_return(false)\n        expect(blog.articles.build(allow_pings: nil)).not_to be_allow_pings\n      end\n    end\n  end\n\n  describe \"#publication_months\" do\n    it \"returns an empty array when no articles\" do\n      expect(described_class.publication_months).to be_empty\n    end\n\n    it \"returns months of publication for published articles\" do\n      create(:article, published_at: Date.new(2010, 11, 23))\n      create(:article, published_at: Date.new(2002, 4, 9))\n      result = described_class.publication_months\n      expect(result).to match_array [[\"2010-11\"], [\"2002-04\"]]\n    end\n  end\n\n  describe \"published_since\" do\n    let(:time) { DateTime.new(2010, 11, 3, 23, 34).in_time_zone }\n\n    it \"empty when no articles\" do\n      expect(described_class.published_since(time)).to be_empty\n    end\n\n    it \"returns article that was published since\" do\n      article = create(:article, published_at: time + 2.hours)\n      expect(described_class.published_since(time)).to eq [article]\n    end\n\n    it \"returns only article that was published since last visit\" do\n      create(:article, published_at: time - 2.hours)\n      article = create(:article, published_at: time + 2.hours)\n      expect(described_class.published_since(time)).to eq [article]\n    end\n  end\n\n  describe \"bestof\" do\n    it \"returns empty array when no content\" do\n      expect(described_class.bestof).to be_empty\n    end\n\n    it \"returns article with comment count field\" do\n      create(:comment)\n      expect(described_class.bestof.first.comment_count.to_i).to eq 1\n    end\n\n    it \"counts comments but not trackbacks\" do\n      article = create :article\n      create :trackback, article: article\n      create_list :comment, 2, article: article\n\n      expect(described_class.bestof.first.comment_count.to_i).to eq 2\n    end\n\n    it \"returns only 5 articles\" do\n      create_list(:comment, 6)\n      expect(described_class.bestof.length).to eq(5)\n    end\n\n    it \"returns only published articles\" do\n      article = create(:article)\n      create(:comment, article: article)\n      unpublished_article = create(:article)\n      create(:comment, article: unpublished_article)\n      unpublished_article.update!(state: \"draft\")\n      expect(described_class.published).to eq([article])\n      expect(described_class.bestof).to eq([article])\n    end\n\n    it \"returns article sorted by comment counts\" do\n      last_article = create(:article)\n      create(:comment, article: last_article)\n\n      first_article = create(:article)\n      create(:comment, article: first_article)\n      create(:comment, article: first_article)\n\n      expect(described_class.bestof).to eq([first_article, last_article])\n    end\n  end\n\n  describe \"update tags from article keywords\" do\n    before { article.save }\n\n    context \"without keywords\" do\n      let(:article) { build(:article, keywords: nil) }\n\n      it { expect(article.tags).to be_empty }\n    end\n\n    context \"with a simple keyword\" do\n      let(:article) { build(:article, keywords: \"foo\") }\n\n      it { expect(article.tags.size).to eq(1) }\n      it { expect(article.tags.first).to be_kind_of(Tag) }\n      it { expect(article.tags.first.name).to eq(\"foo\") }\n    end\n\n    context \"with two keyword separate by a space\" do\n      let(:article) { build(:article, keywords: \"foo bar\") }\n\n      it { expect(article.tags.size).to eq(2) }\n      it { expect(article.tags.map(&:name)).to eq(%w(foo bar)) }\n    end\n\n    context \"with two keyword separate by a coma\" do\n      let(:article) { build(:article, keywords: \"foo, bar\") }\n\n      it { expect(article.tags.size).to eq(2) }\n      it { expect(article.tags.map(&:name)).to eq(%w(foo bar)) }\n    end\n\n    context \"with two keyword with apostrophe\" do\n      let(:article) { build(:article, keywords: \"foo, l'bar\") }\n\n      it { expect(article.tags.size).to eq(3) }\n      it { expect(article.tags.map(&:name)).to eq(%w(foo l bar)) }\n    end\n\n    context \"with two identical keywords\" do\n      let(:article) { build(:article, keywords: \"same, same\") }\n\n      it { expect(article.tags.size).to eq(1) }\n      it { expect(article.tags.map(&:name)).to eq([\"same\"]) }\n    end\n\n    context \"with keywords with dot and quote\" do\n      let(:article) { build(:article, keywords: 'foo \"bar quiz\" web2.0') }\n\n      it { expect(article.tags.map(&:name)).to eq([\"foo\", \"bar-quiz\", \"web2-0\"]) }\n    end\n  end\n\n  describe \"#post_type\" do\n    context \"without post_type\" do\n      let(:article) { build(:article, post_type: \"\") }\n\n      it { expect(article.post_type).to eq(\"read\") }\n    end\n\n    context \"with a oldschool read post_type\" do\n      let(:article) { build(:article, post_type: \"read\") }\n\n      it { expect(article.post_type).to eq(\"read\") }\n    end\n\n    context \"with a specific myletter post_type\" do\n      let(:article) { build(:article, post_type: \"myletter\") }\n\n      it { expect(article.post_type).to eq(\"myletter\") }\n    end\n  end\n\n  describe \"#comments_closed?\" do\n    let!(:blog) do\n      create(:blog, sp_article_auto_close: auto_close_value,\n                    default_allow_comments: true)\n    end\n\n    context \"when auto_close setting is zero\" do\n      let(:auto_close_value) { 0 }\n\n      it \"does not allow comments for a draft article\" do\n        art = build :article, state: \"draft\", blog: blog\n        assert art.comments_closed?\n      end\n\n      it \"does not allow comments for an article that will be published in the future\" do\n        art = build :article, state: \"publication_pending\",\n                              published_at: 1.day.from_now, blog: blog\n        assert art.comments_closed?\n      end\n\n      it \"allows comments for a newly published article\" do\n        art = build :article, published_at: 1.second.ago, blog: blog\n        assert !art.comments_closed?\n      end\n\n      it \"allows comments for a very old article\" do\n        art = build :article, created_at: 1000.days.ago, blog: blog\n        assert !art.comments_closed?\n      end\n    end\n\n    context \"when auto_close setting is nonzero\" do\n      let(:auto_close_value) { 30 }\n\n      it \"allows comments for a recently published article\" do\n        art = build :article, published_at: 29.days.ago, blog: blog\n        assert !art.comments_closed?\n      end\n\n      it \"does not allow comments for an old article\" do\n        art = build :article, published_at: 31.days.ago, blog: blog\n        assert art.comments_closed?\n      end\n    end\n  end\nend\n"], "filenames": ["publify_core/app/models/article.rb", "publify_core/spec/controllers/comments_controller_spec.rb", "publify_core/spec/models/article_spec.rb"], "buggy_code_start_loc": [207, 60, 859], "buggy_code_end_loc": [208, 60, 957], "fixing_code_start_loc": [207, 61, 859], "fixing_code_end_loc": [208, 76, 970], "type": "CWE-863", "message": "Improper Access Control in GitHub repository publify/publify prior to 9.2.8.", "other": {"cve": {"id": "CVE-2022-0574", "sourceIdentifier": "security@huntr.dev", "published": "2022-05-16T15:15:08.557", "lastModified": "2022-05-24T20:31:07.033", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Improper Access Control in GitHub repository publify/publify prior to 9.2.8."}, {"lang": "es", "value": "Un Control de Acceso Inapropiado en el repositorio GitHub publify/publify versiones anteriores a 9.2.8"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 2.5}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-863"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-284"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:publify_project:publify:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.2.8", "matchCriteriaId": "3310B9A3-CF26-460A-8F77-9D245D34243B"}]}]}], "references": [{"url": "https://github.com/publify/publify/commit/0e6c66ac2002136517662399bca9d838c80d9739", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/6f322c84-9e20-4df6-97e8-92bc271ede3f", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/publify/publify/commit/0e6c66ac2002136517662399bca9d838c80d9739"}}