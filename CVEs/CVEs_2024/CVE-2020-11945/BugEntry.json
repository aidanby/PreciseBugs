{"buggy_code": ["/*\n * Copyright (C) 1996-2020 The Squid Software Foundation and contributors\n *\n * Squid software is distributed under GPLv2+ license and includes\n * contributions from numerous individuals and organizations.\n * Please see the COPYING and CONTRIBUTORS files for details.\n */\n\n/* DEBUG: section 29    Authenticator */\n\n/* The functions in this file handle authentication.\n * They DO NOT perform access control or auditing.\n * See acl.c for access control and client_side.c for auditing */\n\n#include \"squid.h\"\n#include \"auth/CredentialsCache.h\"\n#include \"auth/digest/Config.h\"\n#include \"auth/digest/Scheme.h\"\n#include \"auth/digest/User.h\"\n#include \"auth/digest/UserRequest.h\"\n#include \"auth/Gadgets.h\"\n#include \"auth/State.h\"\n#include \"base/LookupTable.h\"\n#include \"cache_cf.h\"\n#include \"event.h\"\n#include \"helper.h\"\n#include \"HttpHeaderTools.h\"\n#include \"HttpReply.h\"\n#include \"HttpRequest.h\"\n#include \"md5.h\"\n#include \"mgr/Registration.h\"\n#include \"rfc2617.h\"\n#include \"sbuf/SBuf.h\"\n#include \"SquidTime.h\"\n#include \"Store.h\"\n#include \"StrList.h\"\n#include \"wordlist.h\"\n\n/* digest_nonce_h still uses explicit alloc()/freeOne() MemPool calls.\n * XXX: convert to MEMPROXY_CLASS() API\n */\n#include \"mem/Pool.h\"\n\n#include <random>\n\nstatic AUTHSSTATS authenticateDigestStats;\n\nhelper *digestauthenticators = NULL;\n\nstatic hash_table *digest_nonce_cache;\n\nstatic int authdigest_initialised = 0;\nstatic MemAllocator *digest_nonce_pool = NULL;\n\nenum http_digest_attr_type {\n    DIGEST_USERNAME,\n    DIGEST_REALM,\n    DIGEST_QOP,\n    DIGEST_ALGORITHM,\n    DIGEST_URI,\n    DIGEST_NONCE,\n    DIGEST_NC,\n    DIGEST_CNONCE,\n    DIGEST_RESPONSE,\n    DIGEST_INVALID_ATTR\n};\n\nstatic const LookupTable<http_digest_attr_type>::Record\nDigestAttrs[] = {\n    {\"username\", DIGEST_USERNAME},\n    {\"realm\", DIGEST_REALM},\n    {\"qop\", DIGEST_QOP},\n    {\"algorithm\", DIGEST_ALGORITHM},\n    {\"uri\", DIGEST_URI},\n    {\"nonce\", DIGEST_NONCE},\n    {\"nc\", DIGEST_NC},\n    {\"cnonce\", DIGEST_CNONCE},\n    {\"response\", DIGEST_RESPONSE},\n    {nullptr, DIGEST_INVALID_ATTR}\n};\n\nLookupTable<http_digest_attr_type>\nDigestFieldsLookupTable(DIGEST_INVALID_ATTR, DigestAttrs);\n\n/*\n *\n * Nonce Functions\n *\n */\n\nstatic void authenticateDigestNonceCacheCleanup(void *data);\nstatic digest_nonce_h *authenticateDigestNonceFindNonce(const char *noncehex);\nstatic void authenticateDigestNonceDelete(digest_nonce_h * nonce);\nstatic void authenticateDigestNonceSetup(void);\nstatic void authDigestNonceEncode(digest_nonce_h * nonce);\nstatic void authDigestNonceLink(digest_nonce_h * nonce);\n#if NOT_USED\nstatic int authDigestNonceLinks(digest_nonce_h * nonce);\n#endif\nstatic void authDigestNonceUserUnlink(digest_nonce_h * nonce);\n\nstatic void\nauthDigestNonceEncode(digest_nonce_h * nonce)\n{\n    if (!nonce)\n        return;\n\n    if (nonce->key)\n        xfree(nonce->key);\n\n    SquidMD5_CTX Md5Ctx;\n    HASH H;\n    SquidMD5Init(&Md5Ctx);\n    SquidMD5Update(&Md5Ctx, reinterpret_cast<const uint8_t *>(&nonce->noncedata), sizeof(nonce->noncedata));\n    SquidMD5Final(reinterpret_cast<uint8_t *>(H), &Md5Ctx);\n\n    nonce->key = xcalloc(sizeof(HASHHEX), 1);\n    CvtHex(H, static_cast<char *>(nonce->key));\n}\n\ndigest_nonce_h *\nauthenticateDigestNonceNew(void)\n{\n    digest_nonce_h *newnonce = static_cast < digest_nonce_h * >(digest_nonce_pool->alloc());\n\n    /* NONCE CREATION - NOTES AND REASONING. RBC 20010108\n     * === EXCERPT FROM RFC 2617 ===\n     * The contents of the nonce are implementation dependent. The quality\n     * of the implementation depends on a good choice. A nonce might, for\n     * example, be constructed as the base 64 encoding of\n     *\n     * time-stamp H(time-stamp \":\" ETag \":\" private-key)\n     *\n     * where time-stamp is a server-generated time or other non-repeating\n     * value, ETag is the value of the HTTP ETag header associated with\n     * the requested entity, and private-key is data known only to the\n     * server.  With a nonce of this form a server would recalculate the\n     * hash portion after receiving the client authentication header and\n     * reject the request if it did not match the nonce from that header\n     * or if the time-stamp value is not recent enough. In this way the\n     * server can limit the time of the nonce's validity. The inclusion of\n     * the ETag prevents a replay request for an updated version of the\n     * resource.  (Note: including the IP address of the client in the\n     * nonce would appear to offer the server the ability to limit the\n     * reuse of the nonce to the same client that originally got it.\n     * However, that would break proxy farms, where requests from a single\n     * user often go through different proxies in the farm. Also, IP\n     * address spoofing is not that hard.)\n     * ====\n     *\n     * Now for my reasoning:\n     * We will not accept a unrecognised nonce->we have all recognisable\n     * nonces stored. If we send out unique encodings we guarantee\n     * that a given nonce applies to only one user (barring attacks or\n     * really bad timing with expiry and creation).  Using a random\n     * component in the nonce allows us to loop to find a unique nonce.\n     * We use H(nonce_data) so the nonce is meaningless to the reciever.\n     * So our nonce looks like hex(H(timestamp,randomdata))\n     * And even if our randomness is not very random we don't really care\n     * - the timestamp also guarantees local uniqueness in the input to\n     * the hash function.\n     */\n    // NP: this will likely produce the same randomness sequences for each worker\n    // since they should all start within the 1-second resolution of seed value.\n    static std::mt19937 mt(static_cast<uint32_t>(getCurrentTime() & 0xFFFFFFFF));\n    static xuniform_int_distribution<uint32_t> newRandomData;\n\n    /* create a new nonce */\n    newnonce->nc = 0;\n    newnonce->flags.valid = true;\n    newnonce->noncedata.creationtime = current_time.tv_sec;\n    newnonce->noncedata.randomdata = newRandomData(mt);\n\n    authDigestNonceEncode(newnonce);\n\n    // ensure temporal uniqueness by checking for existing nonce\n    while (authenticateDigestNonceFindNonce((char const *) (newnonce->key))) {\n        /* create a new nonce */\n        newnonce->noncedata.randomdata = newRandomData(mt);\n        authDigestNonceEncode(newnonce);\n    }\n\n    hash_join(digest_nonce_cache, newnonce);\n    /* the cache's link */\n    authDigestNonceLink(newnonce);\n    newnonce->flags.incache = true;\n    debugs(29, 5, \"created nonce \" << newnonce << \" at \" << newnonce->noncedata.creationtime);\n    return newnonce;\n}\n\nstatic void\nauthenticateDigestNonceDelete(digest_nonce_h * nonce)\n{\n    if (nonce) {\n        assert(nonce->references == 0);\n#if UNREACHABLECODE\n\n        if (nonce->flags.incache)\n            hash_remove_link(digest_nonce_cache, nonce);\n\n#endif\n\n        assert(!nonce->flags.incache);\n\n        safe_free(nonce->key);\n\n        digest_nonce_pool->freeOne(nonce);\n    }\n}\n\nstatic void\nauthenticateDigestNonceSetup(void)\n{\n    if (!digest_nonce_pool)\n        digest_nonce_pool = memPoolCreate(\"Digest Scheme nonce's\", sizeof(digest_nonce_h));\n\n    if (!digest_nonce_cache) {\n        digest_nonce_cache = hash_create((HASHCMP *) strcmp, 7921, hash_string);\n        assert(digest_nonce_cache);\n        eventAdd(\"Digest nonce cache maintenance\", authenticateDigestNonceCacheCleanup, NULL, static_cast<Auth::Digest::Config*>(Auth::Config::Find(\"digest\"))->nonceGCInterval, 1);\n    }\n}\n\nvoid\nauthenticateDigestNonceShutdown(void)\n{\n    /*\n     * We empty the cache of any nonces left in there.\n     */\n    digest_nonce_h *nonce;\n\n    if (digest_nonce_cache) {\n        debugs(29, 2, \"Shutting down nonce cache\");\n        hash_first(digest_nonce_cache);\n\n        while ((nonce = ((digest_nonce_h *) hash_next(digest_nonce_cache)))) {\n            assert(nonce->flags.incache);\n            authDigestNoncePurge(nonce);\n        }\n    }\n\n#if DEBUGSHUTDOWN\n    if (digest_nonce_pool) {\n        delete digest_nonce_pool;\n        digest_nonce_pool = NULL;\n    }\n\n#endif\n    debugs(29, 2, \"Nonce cache shutdown\");\n}\n\nstatic void\nauthenticateDigestNonceCacheCleanup(void *)\n{\n    /*\n     * We walk the hash by noncehex as that is the unique key we\n     * use.  For big hash tables we could consider stepping through\n     * the cache, 100/200 entries at a time. Lets see how it flies\n     * first.\n     */\n    digest_nonce_h *nonce;\n    debugs(29, 3, \"Cleaning the nonce cache now\");\n    debugs(29, 3, \"Current time: \" << current_time.tv_sec);\n    hash_first(digest_nonce_cache);\n\n    while ((nonce = ((digest_nonce_h *) hash_next(digest_nonce_cache)))) {\n        debugs(29, 3, \"nonce entry  : \" << nonce << \" '\" << (char *) nonce->key << \"'\");\n        debugs(29, 4, \"Creation time: \" << nonce->noncedata.creationtime);\n\n        if (authDigestNonceIsStale(nonce)) {\n            debugs(29, 4, \"Removing nonce \" << (char *) nonce->key << \" from cache due to timeout.\");\n            assert(nonce->flags.incache);\n            /* invalidate nonce so future requests fail */\n            nonce->flags.valid = false;\n            /* if it is tied to a auth_user, remove the tie */\n            authDigestNonceUserUnlink(nonce);\n            authDigestNoncePurge(nonce);\n        }\n    }\n\n    debugs(29, 3, \"Finished cleaning the nonce cache.\");\n\n    if (static_cast<Auth::Digest::Config*>(Auth::Config::Find(\"digest\"))->active())\n        eventAdd(\"Digest nonce cache maintenance\", authenticateDigestNonceCacheCleanup, NULL, static_cast<Auth::Digest::Config*>(Auth::Config::Find(\"digest\"))->nonceGCInterval, 1);\n}\n\nstatic void\nauthDigestNonceLink(digest_nonce_h * nonce)\n{\n    assert(nonce != NULL);\n    ++nonce->references;\n    debugs(29, 9, \"nonce '\" << nonce << \"' now at '\" << nonce->references << \"'.\");\n}\n\n#if NOT_USED\nstatic int\nauthDigestNonceLinks(digest_nonce_h * nonce)\n{\n    if (!nonce)\n        return -1;\n\n    return nonce->references;\n}\n\n#endif\n\nvoid\nauthDigestNonceUnlink(digest_nonce_h * nonce)\n{\n    assert(nonce != NULL);\n\n    if (nonce->references > 0) {\n        -- nonce->references;\n    } else {\n        debugs(29, DBG_IMPORTANT, \"Attempt to lower nonce \" << nonce << \" refcount below 0!\");\n    }\n\n    debugs(29, 9, \"nonce '\" << nonce << \"' now at '\" << nonce->references << \"'.\");\n\n    if (nonce->references == 0)\n        authenticateDigestNonceDelete(nonce);\n}\n\nconst char *\nauthenticateDigestNonceNonceHex(const digest_nonce_h * nonce)\n{\n    if (!nonce)\n        return NULL;\n\n    return (char const *) nonce->key;\n}\n\nstatic digest_nonce_h *\nauthenticateDigestNonceFindNonce(const char *noncehex)\n{\n    digest_nonce_h *nonce = NULL;\n\n    if (noncehex == NULL)\n        return NULL;\n\n    debugs(29, 9, \"looking for noncehex '\" << noncehex << \"' in the nonce cache.\");\n\n    nonce = static_cast < digest_nonce_h * >(hash_lookup(digest_nonce_cache, noncehex));\n\n    if ((nonce == NULL) || (strcmp(authenticateDigestNonceNonceHex(nonce), noncehex)))\n        return NULL;\n\n    debugs(29, 9, \"Found nonce '\" << nonce << \"'\");\n\n    return nonce;\n}\n\nint\nauthDigestNonceIsValid(digest_nonce_h * nonce, char nc[9])\n{\n    unsigned long intnc;\n    /* do we have a nonce ? */\n\n    if (!nonce)\n        return 0;\n\n    intnc = strtol(nc, NULL, 16);\n\n    /* has it already been invalidated ? */\n    if (!nonce->flags.valid) {\n        debugs(29, 4, \"Nonce already invalidated\");\n        return 0;\n    }\n\n    /* is the nonce-count ok ? */\n    if (!static_cast<Auth::Digest::Config*>(Auth::Config::Find(\"digest\"))->CheckNonceCount) {\n        /* Ignore client supplied NC */\n        intnc = nonce->nc + 1;\n    }\n\n    if ((static_cast<Auth::Digest::Config*>(Auth::Config::Find(\"digest\"))->NonceStrictness && intnc != nonce->nc + 1) ||\n            intnc < nonce->nc + 1) {\n        debugs(29, 4, \"Nonce count doesn't match\");\n        nonce->flags.valid = false;\n        return 0;\n    }\n\n    /* increment the nonce count - we've already checked that intnc is a\n     *  valid representation for us, so we don't need the test here.\n     */\n    nonce->nc = intnc;\n\n    return !authDigestNonceIsStale(nonce);\n}\n\nint\nauthDigestNonceIsStale(digest_nonce_h * nonce)\n{\n    /* do we have a nonce ? */\n\n    if (!nonce)\n        return -1;\n\n    /* Is it already invalidated? */\n    if (!nonce->flags.valid)\n        return -1;\n\n    /* has it's max duration expired? */\n    if (nonce->noncedata.creationtime + static_cast<Auth::Digest::Config*>(Auth::Config::Find(\"digest\"))->noncemaxduration < current_time.tv_sec) {\n        debugs(29, 4, \"Nonce is too old. \" <<\n               nonce->noncedata.creationtime << \" \" <<\n               static_cast<Auth::Digest::Config*>(Auth::Config::Find(\"digest\"))->noncemaxduration << \" \" <<\n               current_time.tv_sec);\n\n        nonce->flags.valid = false;\n        return -1;\n    }\n\n    if (nonce->nc > 99999998) {\n        debugs(29, 4, \"Nonce count overflow\");\n        nonce->flags.valid = false;\n        return -1;\n    }\n\n    if (nonce->nc > static_cast<Auth::Digest::Config*>(Auth::Config::Find(\"digest\"))->noncemaxuses) {\n        debugs(29, 4, \"Nonce count over user limit\");\n        nonce->flags.valid = false;\n        return -1;\n    }\n\n    /* seems ok */\n    return 0;\n}\n\n/**\n * \\retval  0    the digest is not stale yet\n * \\retval -1    the digest will be stale on the next request\n */\nint\nauthDigestNonceLastRequest(digest_nonce_h * nonce)\n{\n    if (!nonce)\n        return -1;\n\n    if (nonce->nc == 99999997) {\n        debugs(29, 4, \"Nonce count about to overflow\");\n        return -1;\n    }\n\n    if (nonce->nc >= static_cast<Auth::Digest::Config*>(Auth::Config::Find(\"digest\"))->noncemaxuses - 1) {\n        debugs(29, 4, \"Nonce count about to hit user limit\");\n        return -1;\n    }\n\n    /* and other tests are possible. */\n    return 0;\n}\n\nvoid\nauthDigestNoncePurge(digest_nonce_h * nonce)\n{\n    if (!nonce)\n        return;\n\n    if (!nonce->flags.incache)\n        return;\n\n    hash_remove_link(digest_nonce_cache, nonce);\n\n    nonce->flags.incache = false;\n\n    /* the cache's link */\n    authDigestNonceUnlink(nonce);\n}\n\nvoid\nAuth::Digest::Config::rotateHelpers()\n{\n    /* schedule closure of existing helpers */\n    if (digestauthenticators) {\n        helperShutdown(digestauthenticators);\n    }\n\n    /* NP: dynamic helper restart will ensure they start up again as needed. */\n}\n\nbool\nAuth::Digest::Config::dump(StoreEntry * entry, const char *name, Auth::Config * scheme) const\n{\n    if (!Auth::Config::dump(entry, name, scheme))\n        return false;\n\n    storeAppendPrintf(entry, \"%s %s nonce_max_count %d\\n%s %s nonce_max_duration %d seconds\\n%s %s nonce_garbage_interval %d seconds\\n\",\n                      name, \"digest\", noncemaxuses,\n                      name, \"digest\", (int) noncemaxduration,\n                      name, \"digest\", (int) nonceGCInterval);\n    storeAppendPrintf(entry, \"%s digest utf8 %s\\n\", name, utf8 ? \"on\" : \"off\");\n    return true;\n}\n\nbool\nAuth::Digest::Config::active() const\n{\n    return authdigest_initialised == 1;\n}\n\nbool\nAuth::Digest::Config::configured() const\n{\n    if ((authenticateProgram != NULL) &&\n            (authenticateChildren.n_max != 0) &&\n            !realm.isEmpty() && (noncemaxduration > -1))\n        return true;\n\n    return false;\n}\n\n/* add the [www-|Proxy-]authenticate header on a 407 or 401 reply */\nvoid\nAuth::Digest::Config::fixHeader(Auth::UserRequest::Pointer auth_user_request, HttpReply *rep, Http::HdrType hdrType, HttpRequest *)\n{\n    if (!authenticateProgram)\n        return;\n\n    bool stale = false;\n    digest_nonce_h *nonce = NULL;\n\n    /* on a 407 or 401 we always use a new nonce */\n    if (auth_user_request != NULL) {\n        Auth::Digest::User *digest_user = dynamic_cast<Auth::Digest::User *>(auth_user_request->user().getRaw());\n\n        if (digest_user) {\n            stale = digest_user->credentials() == Auth::Handshake;\n            if (stale) {\n                nonce = digest_user->currentNonce();\n            }\n        }\n    }\n    if (!nonce) {\n        nonce = authenticateDigestNonceNew();\n    }\n\n    debugs(29, 9, \"Sending type:\" << hdrType <<\n           \" header: 'Digest realm=\\\"\" << realm << \"\\\", nonce=\\\"\" <<\n           authenticateDigestNonceNonceHex(nonce) << \"\\\", qop=\\\"\" << QOP_AUTH <<\n           \"\\\", stale=\" << (stale ? \"true\" : \"false\"));\n\n    /* in the future, for WWW auth we may want to support the domain entry */\n    httpHeaderPutStrf(&rep->header, hdrType, \"Digest realm=\\\"\" SQUIDSBUFPH \"\\\", nonce=\\\"%s\\\", qop=\\\"%s\\\", stale=%s\",\n                      SQUIDSBUFPRINT(realm), authenticateDigestNonceNonceHex(nonce), QOP_AUTH, stale ? \"true\" : \"false\");\n}\n\n/* Initialize helpers and the like for this auth scheme. Called AFTER parsing the\n * config file */\nvoid\nAuth::Digest::Config::init(Auth::Config *)\n{\n    if (authenticateProgram) {\n        authenticateDigestNonceSetup();\n        authdigest_initialised = 1;\n\n        if (digestauthenticators == NULL)\n            digestauthenticators = new helper(\"digestauthenticator\");\n\n        digestauthenticators->cmdline = authenticateProgram;\n\n        digestauthenticators->childs.updateLimits(authenticateChildren);\n\n        digestauthenticators->ipc_type = IPC_STREAM;\n\n        helperOpenServers(digestauthenticators);\n    }\n}\n\nvoid\nAuth::Digest::Config::registerWithCacheManager(void)\n{\n    Mgr::RegisterAction(\"digestauthenticator\",\n                        \"Digest User Authenticator Stats\",\n                        authenticateDigestStats, 0, 1);\n}\n\n/* free any allocated configuration details */\nvoid\nAuth::Digest::Config::done()\n{\n    Auth::Config::done();\n\n    authdigest_initialised = 0;\n\n    if (digestauthenticators)\n        helperShutdown(digestauthenticators);\n\n    if (!shutting_down)\n        return;\n\n    delete digestauthenticators;\n    digestauthenticators = NULL;\n\n    if (authenticateProgram)\n        wordlistDestroy(&authenticateProgram);\n}\n\nAuth::Digest::Config::Config() :\n    nonceGCInterval(5*60),\n    noncemaxduration(30*60),\n    noncemaxuses(50),\n    NonceStrictness(0),\n    CheckNonceCount(1),\n    PostWorkaround(0),\n    utf8(0)\n{}\n\nvoid\nAuth::Digest::Config::parse(Auth::Config * scheme, int n_configured, char *param_str)\n{\n    if (strcmp(param_str, \"program\") == 0) {\n        if (authenticateProgram)\n            wordlistDestroy(&authenticateProgram);\n\n        parse_wordlist(&authenticateProgram);\n\n        requirePathnameExists(\"auth_param digest program\", authenticateProgram->key);\n    } else if (strcmp(param_str, \"nonce_garbage_interval\") == 0) {\n        parse_time_t(&nonceGCInterval);\n    } else if (strcmp(param_str, \"nonce_max_duration\") == 0) {\n        parse_time_t(&noncemaxduration);\n    } else if (strcmp(param_str, \"nonce_max_count\") == 0) {\n        parse_int((int *) &noncemaxuses);\n    } else if (strcmp(param_str, \"nonce_strictness\") == 0) {\n        parse_onoff(&NonceStrictness);\n    } else if (strcmp(param_str, \"check_nonce_count\") == 0) {\n        parse_onoff(&CheckNonceCount);\n    } else if (strcmp(param_str, \"post_workaround\") == 0) {\n        parse_onoff(&PostWorkaround);\n    } else if (strcmp(param_str, \"utf8\") == 0) {\n        parse_onoff(&utf8);\n    } else\n        Auth::Config::parse(scheme, n_configured, param_str);\n}\n\nconst char *\nAuth::Digest::Config::type() const\n{\n    return Auth::Digest::Scheme::GetInstance()->type();\n}\n\nstatic void\nauthenticateDigestStats(StoreEntry * sentry)\n{\n    if (digestauthenticators)\n        digestauthenticators->packStatsInto(sentry, \"Digest Authenticator Statistics\");\n}\n\n/* NonceUserUnlink: remove the reference to auth_user and unlink the node from the list */\n\nstatic void\nauthDigestNonceUserUnlink(digest_nonce_h * nonce)\n{\n    Auth::Digest::User *digest_user;\n    dlink_node *link, *tmplink;\n\n    if (!nonce)\n        return;\n\n    if (!nonce->user)\n        return;\n\n    digest_user = nonce->user;\n\n    /* unlink from the user list. Yes we're crossing structures but this is the only\n     * time this code is needed\n     */\n    link = digest_user->nonces.head;\n\n    while (link) {\n        tmplink = link;\n        link = link->next;\n\n        if (tmplink->data == nonce) {\n            dlinkDelete(tmplink, &digest_user->nonces);\n            authDigestNonceUnlink(static_cast < digest_nonce_h * >(tmplink->data));\n            delete tmplink;\n            link = NULL;\n        }\n    }\n\n    /* this reference to user was not locked because freeeing the user frees\n     * the nonce too.\n     */\n    nonce->user = NULL;\n}\n\n/* authDigesteserLinkNonce: add a nonce to a given user's struct */\nvoid\nauthDigestUserLinkNonce(Auth::Digest::User * user, digest_nonce_h * nonce)\n{\n    dlink_node *node;\n\n    if (!user || !nonce || !nonce->user)\n        return;\n\n    Auth::Digest::User *digest_user = user;\n\n    node = digest_user->nonces.head;\n\n    while (node && (node->data != nonce))\n        node = node->next;\n\n    if (node)\n        return;\n\n    node = new dlink_node;\n\n    dlinkAddTail(nonce, node, &digest_user->nonces);\n\n    authDigestNonceLink(nonce);\n\n    /* ping this nonce to this auth user */\n    assert((nonce->user == NULL) || (nonce->user == user));\n\n    /* we don't lock this reference because removing the user removes the\n     * hash too. Of course if that changes we're stuffed so read the code huh?\n     */\n    nonce->user = user;\n}\n\n/* setup the necessary info to log the username */\nstatic Auth::UserRequest::Pointer\nauthDigestLogUsername(char *username, Auth::UserRequest::Pointer auth_user_request, const char *requestRealm)\n{\n    assert(auth_user_request != NULL);\n\n    /* log the username */\n    debugs(29, 9, \"Creating new user for logging '\" << (username?username:\"[no username]\") << \"'\");\n    Auth::User::Pointer digest_user = new Auth::Digest::User(static_cast<Auth::Digest::Config*>(Auth::Config::Find(\"digest\")), requestRealm);\n    /* save the credentials */\n    digest_user->username(username);\n    /* set the auth_user type */\n    digest_user->auth_type = Auth::AUTH_BROKEN;\n    /* link the request to the user */\n    auth_user_request->user(digest_user);\n    return auth_user_request;\n}\n\n/*\n * Decode a Digest [Proxy-]Auth string, placing the results in the passed\n * Auth_user structure.\n */\nAuth::UserRequest::Pointer\nAuth::Digest::Config::decode(char const *proxy_auth, const char *aRequestRealm)\n{\n    const char *item;\n    const char *p;\n    const char *pos = NULL;\n    char *username = NULL;\n    digest_nonce_h *nonce;\n    int ilen;\n\n    debugs(29, 9, \"beginning\");\n\n    Auth::Digest::UserRequest *digest_request = new Auth::Digest::UserRequest();\n\n    /* trim DIGEST from string */\n\n    while (xisgraph(*proxy_auth))\n        ++proxy_auth;\n\n    /* Trim leading whitespace before decoding */\n    while (xisspace(*proxy_auth))\n        ++proxy_auth;\n\n    String temp(proxy_auth);\n\n    while (strListGetItem(&temp, ',', &item, &ilen, &pos)) {\n        /* isolate directive name & value */\n        size_t nlen;\n        size_t vlen;\n        if ((p = (const char *)memchr(item, '=', ilen)) && (p - item < ilen)) {\n            nlen = p - item;\n            ++p;\n            vlen = ilen - (p - item);\n        } else {\n            nlen = ilen;\n            vlen = 0;\n        }\n\n        SBuf keyName(item, nlen);\n        String value;\n\n        if (vlen > 0) {\n            // see RFC 2617 section 3.2.1 and 3.2.2 for details on the BNF\n\n            if (keyName == SBuf(\"domain\",6) || keyName == SBuf(\"uri\",3)) {\n                // domain is Special. Not a quoted-string, must not be de-quoted. But is wrapped in '\"'\n                // BUG 3077: uri= can also be sent to us in a mangled (invalid!) form like domain\n                if (vlen > 1 && *p == '\"' && *(p + vlen -1) == '\"') {\n                    value.limitInit(p+1, vlen-2);\n                }\n            } else if (keyName == SBuf(\"qop\",3)) {\n                // qop is more special.\n                // On request this must not be quoted-string de-quoted. But is several values wrapped in '\"'\n                // On response this is a single un-quoted token.\n                if (vlen > 1 && *p == '\"' && *(p + vlen -1) == '\"') {\n                    value.limitInit(p+1, vlen-2);\n                } else {\n                    value.limitInit(p, vlen);\n                }\n            } else if (*p == '\"') {\n                if (!httpHeaderParseQuotedString(p, vlen, &value)) {\n                    debugs(29, 9, \"Failed to parse attribute '\" << item << \"' in '\" << temp << \"'\");\n                    continue;\n                }\n            } else {\n                value.limitInit(p, vlen);\n            }\n        } else {\n            debugs(29, 9, \"Failed to parse attribute '\" << item << \"' in '\" << temp << \"'\");\n            continue;\n        }\n\n        /* find type */\n        const http_digest_attr_type t = DigestFieldsLookupTable.lookup(keyName);\n\n        switch (t) {\n        case DIGEST_USERNAME:\n            safe_free(username);\n            if (value.size() != 0)\n                username = xstrndup(value.rawBuf(), value.size() + 1);\n            debugs(29, 9, \"Found Username '\" << username << \"'\");\n            break;\n\n        case DIGEST_REALM:\n            safe_free(digest_request->realm);\n            if (value.size() != 0)\n                digest_request->realm = xstrndup(value.rawBuf(), value.size() + 1);\n            debugs(29, 9, \"Found realm '\" << digest_request->realm << \"'\");\n            break;\n\n        case DIGEST_QOP:\n            safe_free(digest_request->qop);\n            if (value.size() != 0)\n                digest_request->qop = xstrndup(value.rawBuf(), value.size() + 1);\n            debugs(29, 9, \"Found qop '\" << digest_request->qop << \"'\");\n            break;\n\n        case DIGEST_ALGORITHM:\n            safe_free(digest_request->algorithm);\n            if (value.size() != 0)\n                digest_request->algorithm = xstrndup(value.rawBuf(), value.size() + 1);\n            debugs(29, 9, \"Found algorithm '\" << digest_request->algorithm << \"'\");\n            break;\n\n        case DIGEST_URI:\n            safe_free(digest_request->uri);\n            if (value.size() != 0)\n                digest_request->uri = xstrndup(value.rawBuf(), value.size() + 1);\n            debugs(29, 9, \"Found uri '\" << digest_request->uri << \"'\");\n            break;\n\n        case DIGEST_NONCE:\n            safe_free(digest_request->noncehex);\n            if (value.size() != 0)\n                digest_request->noncehex = xstrndup(value.rawBuf(), value.size() + 1);\n            debugs(29, 9, \"Found nonce '\" << digest_request->noncehex << \"'\");\n            break;\n\n        case DIGEST_NC:\n            if (value.size() != 8) {\n                debugs(29, 9, \"Invalid nc '\" << value << \"' in '\" << temp << \"'\");\n            }\n            xstrncpy(digest_request->nc, value.rawBuf(), value.size() + 1);\n            debugs(29, 9, \"Found noncecount '\" << digest_request->nc << \"'\");\n            break;\n\n        case DIGEST_CNONCE:\n            safe_free(digest_request->cnonce);\n            if (value.size() != 0)\n                digest_request->cnonce = xstrndup(value.rawBuf(), value.size() + 1);\n            debugs(29, 9, \"Found cnonce '\" << digest_request->cnonce << \"'\");\n            break;\n\n        case DIGEST_RESPONSE:\n            safe_free(digest_request->response);\n            if (value.size() != 0)\n                digest_request->response = xstrndup(value.rawBuf(), value.size() + 1);\n            debugs(29, 9, \"Found response '\" << digest_request->response << \"'\");\n            break;\n\n        default:\n            debugs(29, 3, \"Unknown attribute '\" << item << \"' in '\" << temp << \"'\");\n            break;\n        }\n    }\n\n    temp.clean();\n\n    /* now we validate the data given to us */\n\n    /*\n     * TODO: on invalid parameters we should return 400, not 407.\n     * Find some clean way of doing this. perhaps return a valid\n     * struct, and set the direction to clientwards combined with\n     * a change to the clientwards handling code (ie let the\n     * clientwards call set the error type (but limited to known\n     * correct values - 400/401/407\n     */\n\n    /* 2069 requirements */\n\n    // return value.\n    Auth::UserRequest::Pointer rv;\n    /* do we have a username ? */\n    if (!username || username[0] == '\\0') {\n        debugs(29, 2, \"Empty or not present username\");\n        rv = authDigestLogUsername(username, digest_request, aRequestRealm);\n        safe_free(username);\n        return rv;\n    }\n\n    /* Sanity check of the username.\n     * \" can not be allowed in usernames until * the digest helper protocol\n     * have been redone\n     */\n    if (strchr(username, '\"')) {\n        debugs(29, 2, \"Unacceptable username '\" << username << \"'\");\n        rv = authDigestLogUsername(username, digest_request, aRequestRealm);\n        safe_free(username);\n        return rv;\n    }\n\n    /* do we have a realm ? */\n    if (!digest_request->realm || digest_request->realm[0] == '\\0') {\n        debugs(29, 2, \"Empty or not present realm\");\n        rv = authDigestLogUsername(username, digest_request, aRequestRealm);\n        safe_free(username);\n        return rv;\n    }\n\n    /* and a nonce? */\n    if (!digest_request->noncehex || digest_request->noncehex[0] == '\\0') {\n        debugs(29, 2, \"Empty or not present nonce\");\n        rv = authDigestLogUsername(username, digest_request, aRequestRealm);\n        safe_free(username);\n        return rv;\n    }\n\n    /* we can't check the URI just yet. We'll check it in the\n     * authenticate phase, but needs to be given */\n    if (!digest_request->uri || digest_request->uri[0] == '\\0') {\n        debugs(29, 2, \"Missing URI field\");\n        rv = authDigestLogUsername(username, digest_request, aRequestRealm);\n        safe_free(username);\n        return rv;\n    }\n\n    /* is the response the correct length? */\n    if (!digest_request->response || strlen(digest_request->response) != 32) {\n        debugs(29, 2, \"Response length invalid\");\n        rv = authDigestLogUsername(username, digest_request, aRequestRealm);\n        safe_free(username);\n        return rv;\n    }\n\n    /* check the algorithm is present and supported */\n    if (!digest_request->algorithm)\n        digest_request->algorithm = xstrndup(\"MD5\", 4);\n    else if (strcmp(digest_request->algorithm, \"MD5\")\n             && strcmp(digest_request->algorithm, \"MD5-sess\")) {\n        debugs(29, 2, \"invalid algorithm specified!\");\n        rv = authDigestLogUsername(username, digest_request, aRequestRealm);\n        safe_free(username);\n        return rv;\n    }\n\n    /* 2617 requirements, indicated by qop */\n    if (digest_request->qop) {\n\n        /* check the qop is what we expected. */\n        if (strcmp(digest_request->qop, QOP_AUTH) != 0) {\n            /* we received a qop option we didn't send */\n            debugs(29, 2, \"Invalid qop option received\");\n            rv = authDigestLogUsername(username, digest_request, aRequestRealm);\n            safe_free(username);\n            return rv;\n        }\n\n        /* check cnonce */\n        if (!digest_request->cnonce || digest_request->cnonce[0] == '\\0') {\n            debugs(29, 2, \"Missing cnonce field\");\n            rv = authDigestLogUsername(username, digest_request, aRequestRealm);\n            safe_free(username);\n            return rv;\n        }\n\n        /* check nc */\n        if (strlen(digest_request->nc) != 8 || strspn(digest_request->nc, \"0123456789abcdefABCDEF\") != 8) {\n            debugs(29, 2, \"invalid nonce count\");\n            rv = authDigestLogUsername(username, digest_request, aRequestRealm);\n            safe_free(username);\n            return rv;\n        }\n    } else {\n        /* cnonce and nc both require qop */\n        if (digest_request->cnonce || digest_request->nc[0] != '\\0') {\n            debugs(29, 2, \"missing qop!\");\n            rv = authDigestLogUsername(username, digest_request, aRequestRealm);\n            safe_free(username);\n            return rv;\n        }\n    }\n\n    /** below nonce state dependent **/\n\n    /* now the nonce */\n    nonce = authenticateDigestNonceFindNonce(digest_request->noncehex);\n    /* check that we're not being hacked / the username hasn't changed */\n    if (nonce && nonce->user && strcmp(username, nonce->user->username())) {\n        debugs(29, 2, \"Username for the nonce does not equal the username for the request\");\n        nonce = NULL;\n    }\n\n    if (!nonce) {\n        /* we couldn't find a matching nonce! */\n        debugs(29, 2, \"Unexpected or invalid nonce received from \" << username);\n        Auth::UserRequest::Pointer auth_request = authDigestLogUsername(username, digest_request, aRequestRealm);\n        auth_request->user()->credentials(Auth::Handshake);\n        safe_free(username);\n        return auth_request;\n    }\n\n    digest_request->nonce = nonce;\n    authDigestNonceLink(nonce);\n\n    /* check that we're not being hacked / the username hasn't changed */\n    if (nonce->user && strcmp(username, nonce->user->username())) {\n        debugs(29, 2, \"Username for the nonce does not equal the username for the request\");\n        rv = authDigestLogUsername(username, digest_request, aRequestRealm);\n        safe_free(username);\n        return rv;\n    }\n\n    /* the method we'll check at the authenticate step as well */\n\n    /* we don't send or parse opaques. Ok so we're flexable ... */\n\n    /* find the user */\n    Auth::Digest::User *digest_user;\n\n    Auth::User::Pointer auth_user;\n\n    SBuf key = Auth::User::BuildUserKey(username, aRequestRealm);\n    if (key.isEmpty() || !(auth_user = Auth::Digest::User::Cache()->lookup(key))) {\n        /* the user doesn't exist in the username cache yet */\n        debugs(29, 9, \"Creating new digest user '\" << username << \"'\");\n        digest_user = new Auth::Digest::User(this, aRequestRealm);\n        /* auth_user is a parent */\n        auth_user = digest_user;\n        /* save the username */\n        digest_user->username(username);\n        /* set the user type */\n        digest_user->auth_type = Auth::AUTH_DIGEST;\n        /* this auth_user struct is the one to get added to the\n         * username cache */\n        /* store user in hash's */\n        digest_user->addToNameCache();\n\n        /*\n         * Add the digest to the user so we can tell if a hacking\n         * or spoofing attack is taking place. We do this by assuming\n         * the user agent won't change user name without warning.\n         */\n        authDigestUserLinkNonce(digest_user, nonce);\n\n        /* auth_user is now linked, we reset these values\n         * after external auth occurs anyway */\n        auth_user->expiretime = current_time.tv_sec;\n    } else {\n        debugs(29, 9, \"Found user '\" << username << \"' in the user cache as '\" << auth_user << \"'\");\n        digest_user = static_cast<Auth::Digest::User *>(auth_user.getRaw());\n        digest_user->credentials(Auth::Unchecked);\n        xfree(username);\n    }\n\n    /*link the request and the user */\n    assert(digest_request != NULL);\n\n    digest_request->user(digest_user);\n    debugs(29, 9, \"username = '\" << digest_user->username() << \"'\\nrealm = '\" <<\n           digest_request->realm << \"'\\nqop = '\" << digest_request->qop <<\n           \"'\\nalgorithm = '\" << digest_request->algorithm << \"'\\nuri = '\" <<\n           digest_request->uri << \"'\\nnonce = '\" << digest_request->noncehex <<\n           \"'\\nnc = '\" << digest_request->nc << \"'\\ncnonce = '\" <<\n           digest_request->cnonce << \"'\\nresponse = '\" <<\n           digest_request->response << \"'\\ndigestnonce = '\" << nonce << \"'\");\n\n    return digest_request;\n}\n\n", "/*\n * Copyright (C) 1996-2020 The Squid Software Foundation and contributors\n *\n * Squid software is distributed under GPLv2+ license and includes\n * contributions from numerous individuals and organizations.\n * Please see the COPYING and CONTRIBUTORS files for details.\n */\n\n#ifndef __AUTH_DIGEST_H__\n#define __AUTH_DIGEST_H__\n\n#if HAVE_AUTH_MODULE_DIGEST\n\n#include \"auth/Config.h\"\n#include \"auth/Gadgets.h\"\n#include \"auth/UserRequest.h\"\n#include \"helper/forward.h\"\n#include \"rfc2617.h\"\n\nnamespace Auth\n{\nnamespace Digest\n{\nclass User;\n}\n}\n\n/* Generic */\ntypedef struct _digest_nonce_data digest_nonce_data;\ntypedef struct _digest_nonce_h digest_nonce_h;\n\n/* data to be encoded into the nonce's hex representation */\nstruct _digest_nonce_data {\n    time_t creationtime;\n    uint32_t randomdata;\n};\n\n/* the nonce structure we'll pass around */\n\nstruct _digest_nonce_h : public hash_link {\n    digest_nonce_data noncedata;\n    /* number of uses we've seen of this nonce */\n    unsigned long nc;\n    /* reference count */\n    short references;\n    /* the auth_user this nonce has been tied to */\n    Auth::Digest::User *user;\n    /* has this nonce been invalidated ? */\n\n    struct {\n        bool valid;\n        bool incache;\n    } flags;\n};\n\nvoid authDigestNonceUnlink(digest_nonce_h * nonce);\nint authDigestNonceIsValid(digest_nonce_h * nonce, char nc[9]);\nint authDigestNonceIsStale(digest_nonce_h * nonce);\nconst char *authenticateDigestNonceNonceHex(const digest_nonce_h * nonce);\nint authDigestNonceLastRequest(digest_nonce_h * nonce);\nvoid authenticateDigestNonceShutdown(void);\nvoid authDigestNoncePurge(digest_nonce_h * nonce);\nvoid authDigestUserLinkNonce(Auth::Digest::User * user, digest_nonce_h * nonce);\ndigest_nonce_h *authenticateDigestNonceNew(void);\n\nnamespace Auth\n{\nnamespace Digest\n{\n\n/** Digest Authentication configuration data */\nclass Config : public Auth::Config\n{\npublic:\n    Config();\n    virtual bool active() const;\n    virtual bool configured() const;\n    virtual Auth::UserRequest::Pointer decode(char const *proxy_auth, const char *requestRealm);\n    virtual void done();\n    virtual void rotateHelpers();\n    virtual bool dump(StoreEntry *, const char *, Auth::Config *) const;\n    virtual void fixHeader(Auth::UserRequest::Pointer, HttpReply *, Http::HdrType, HttpRequest *);\n    virtual void init(Auth::Config *);\n    virtual void parse(Auth::Config *, int, char *);\n    virtual void registerWithCacheManager(void);\n    virtual const char * type() const;\n\npublic:\n    time_t nonceGCInterval;\n    time_t noncemaxduration;\n    unsigned int noncemaxuses;\n    int NonceStrictness;\n    int CheckNonceCount;\n    int PostWorkaround;\n    int utf8;\n};\n\n} // namespace Digest\n} // namespace Auth\n\n/* strings */\n#define QOP_AUTH \"auth\"\n\nextern helper *digestauthenticators;\n\n#endif /* HAVE_AUTH_MODULE_DIGEST */\n#endif\n\n"], "fixing_code": ["/*\n * Copyright (C) 1996-2020 The Squid Software Foundation and contributors\n *\n * Squid software is distributed under GPLv2+ license and includes\n * contributions from numerous individuals and organizations.\n * Please see the COPYING and CONTRIBUTORS files for details.\n */\n\n/* DEBUG: section 29    Authenticator */\n\n/* The functions in this file handle authentication.\n * They DO NOT perform access control or auditing.\n * See acl.c for access control and client_side.c for auditing */\n\n#include \"squid.h\"\n#include \"auth/CredentialsCache.h\"\n#include \"auth/digest/Config.h\"\n#include \"auth/digest/Scheme.h\"\n#include \"auth/digest/User.h\"\n#include \"auth/digest/UserRequest.h\"\n#include \"auth/Gadgets.h\"\n#include \"auth/State.h\"\n#include \"base/LookupTable.h\"\n#include \"cache_cf.h\"\n#include \"event.h\"\n#include \"helper.h\"\n#include \"HttpHeaderTools.h\"\n#include \"HttpReply.h\"\n#include \"HttpRequest.h\"\n#include \"md5.h\"\n#include \"mgr/Registration.h\"\n#include \"rfc2617.h\"\n#include \"sbuf/SBuf.h\"\n#include \"SquidTime.h\"\n#include \"Store.h\"\n#include \"StrList.h\"\n#include \"wordlist.h\"\n\n/* digest_nonce_h still uses explicit alloc()/freeOne() MemPool calls.\n * XXX: convert to MEMPROXY_CLASS() API\n */\n#include \"mem/Pool.h\"\n\n#include <random>\n\nstatic AUTHSSTATS authenticateDigestStats;\n\nhelper *digestauthenticators = NULL;\n\nstatic hash_table *digest_nonce_cache;\n\nstatic int authdigest_initialised = 0;\nstatic MemAllocator *digest_nonce_pool = NULL;\n\nenum http_digest_attr_type {\n    DIGEST_USERNAME,\n    DIGEST_REALM,\n    DIGEST_QOP,\n    DIGEST_ALGORITHM,\n    DIGEST_URI,\n    DIGEST_NONCE,\n    DIGEST_NC,\n    DIGEST_CNONCE,\n    DIGEST_RESPONSE,\n    DIGEST_INVALID_ATTR\n};\n\nstatic const LookupTable<http_digest_attr_type>::Record\nDigestAttrs[] = {\n    {\"username\", DIGEST_USERNAME},\n    {\"realm\", DIGEST_REALM},\n    {\"qop\", DIGEST_QOP},\n    {\"algorithm\", DIGEST_ALGORITHM},\n    {\"uri\", DIGEST_URI},\n    {\"nonce\", DIGEST_NONCE},\n    {\"nc\", DIGEST_NC},\n    {\"cnonce\", DIGEST_CNONCE},\n    {\"response\", DIGEST_RESPONSE},\n    {nullptr, DIGEST_INVALID_ATTR}\n};\n\nLookupTable<http_digest_attr_type>\nDigestFieldsLookupTable(DIGEST_INVALID_ATTR, DigestAttrs);\n\n/*\n *\n * Nonce Functions\n *\n */\n\nstatic void authenticateDigestNonceCacheCleanup(void *data);\nstatic digest_nonce_h *authenticateDigestNonceFindNonce(const char *noncehex);\nstatic void authenticateDigestNonceDelete(digest_nonce_h * nonce);\nstatic void authenticateDigestNonceSetup(void);\nstatic void authDigestNonceEncode(digest_nonce_h * nonce);\nstatic void authDigestNonceLink(digest_nonce_h * nonce);\nstatic void authDigestNonceUserUnlink(digest_nonce_h * nonce);\n\nstatic void\nauthDigestNonceEncode(digest_nonce_h * nonce)\n{\n    if (!nonce)\n        return;\n\n    if (nonce->key)\n        xfree(nonce->key);\n\n    SquidMD5_CTX Md5Ctx;\n    HASH H;\n    SquidMD5Init(&Md5Ctx);\n    SquidMD5Update(&Md5Ctx, reinterpret_cast<const uint8_t *>(&nonce->noncedata), sizeof(nonce->noncedata));\n    SquidMD5Final(reinterpret_cast<uint8_t *>(H), &Md5Ctx);\n\n    nonce->key = xcalloc(sizeof(HASHHEX), 1);\n    CvtHex(H, static_cast<char *>(nonce->key));\n}\n\ndigest_nonce_h *\nauthenticateDigestNonceNew(void)\n{\n    digest_nonce_h *newnonce = static_cast < digest_nonce_h * >(digest_nonce_pool->alloc());\n\n    /* NONCE CREATION - NOTES AND REASONING. RBC 20010108\n     * === EXCERPT FROM RFC 2617 ===\n     * The contents of the nonce are implementation dependent. The quality\n     * of the implementation depends on a good choice. A nonce might, for\n     * example, be constructed as the base 64 encoding of\n     *\n     * time-stamp H(time-stamp \":\" ETag \":\" private-key)\n     *\n     * where time-stamp is a server-generated time or other non-repeating\n     * value, ETag is the value of the HTTP ETag header associated with\n     * the requested entity, and private-key is data known only to the\n     * server.  With a nonce of this form a server would recalculate the\n     * hash portion after receiving the client authentication header and\n     * reject the request if it did not match the nonce from that header\n     * or if the time-stamp value is not recent enough. In this way the\n     * server can limit the time of the nonce's validity. The inclusion of\n     * the ETag prevents a replay request for an updated version of the\n     * resource.  (Note: including the IP address of the client in the\n     * nonce would appear to offer the server the ability to limit the\n     * reuse of the nonce to the same client that originally got it.\n     * However, that would break proxy farms, where requests from a single\n     * user often go through different proxies in the farm. Also, IP\n     * address spoofing is not that hard.)\n     * ====\n     *\n     * Now for my reasoning:\n     * We will not accept a unrecognised nonce->we have all recognisable\n     * nonces stored. If we send out unique encodings we guarantee\n     * that a given nonce applies to only one user (barring attacks or\n     * really bad timing with expiry and creation).  Using a random\n     * component in the nonce allows us to loop to find a unique nonce.\n     * We use H(nonce_data) so the nonce is meaningless to the reciever.\n     * So our nonce looks like hex(H(timestamp,randomdata))\n     * And even if our randomness is not very random we don't really care\n     * - the timestamp also guarantees local uniqueness in the input to\n     * the hash function.\n     */\n    // NP: this will likely produce the same randomness sequences for each worker\n    // since they should all start within the 1-second resolution of seed value.\n    static std::mt19937 mt(static_cast<uint32_t>(getCurrentTime() & 0xFFFFFFFF));\n    static xuniform_int_distribution<uint32_t> newRandomData;\n\n    /* create a new nonce */\n    newnonce->nc = 0;\n    newnonce->flags.valid = true;\n    newnonce->noncedata.creationtime = current_time.tv_sec;\n    newnonce->noncedata.randomdata = newRandomData(mt);\n\n    authDigestNonceEncode(newnonce);\n\n    // ensure temporal uniqueness by checking for existing nonce\n    while (authenticateDigestNonceFindNonce((char const *) (newnonce->key))) {\n        /* create a new nonce */\n        newnonce->noncedata.randomdata = newRandomData(mt);\n        authDigestNonceEncode(newnonce);\n    }\n\n    hash_join(digest_nonce_cache, newnonce);\n    /* the cache's link */\n    authDigestNonceLink(newnonce);\n    newnonce->flags.incache = true;\n    debugs(29, 5, \"created nonce \" << newnonce << \" at \" << newnonce->noncedata.creationtime);\n    return newnonce;\n}\n\nstatic void\nauthenticateDigestNonceDelete(digest_nonce_h * nonce)\n{\n    if (nonce) {\n        assert(nonce->references == 0);\n#if UNREACHABLECODE\n\n        if (nonce->flags.incache)\n            hash_remove_link(digest_nonce_cache, nonce);\n\n#endif\n\n        assert(!nonce->flags.incache);\n\n        safe_free(nonce->key);\n\n        digest_nonce_pool->freeOne(nonce);\n    }\n}\n\nstatic void\nauthenticateDigestNonceSetup(void)\n{\n    if (!digest_nonce_pool)\n        digest_nonce_pool = memPoolCreate(\"Digest Scheme nonce's\", sizeof(digest_nonce_h));\n\n    if (!digest_nonce_cache) {\n        digest_nonce_cache = hash_create((HASHCMP *) strcmp, 7921, hash_string);\n        assert(digest_nonce_cache);\n        eventAdd(\"Digest nonce cache maintenance\", authenticateDigestNonceCacheCleanup, NULL, static_cast<Auth::Digest::Config*>(Auth::Config::Find(\"digest\"))->nonceGCInterval, 1);\n    }\n}\n\nvoid\nauthenticateDigestNonceShutdown(void)\n{\n    /*\n     * We empty the cache of any nonces left in there.\n     */\n    digest_nonce_h *nonce;\n\n    if (digest_nonce_cache) {\n        debugs(29, 2, \"Shutting down nonce cache\");\n        hash_first(digest_nonce_cache);\n\n        while ((nonce = ((digest_nonce_h *) hash_next(digest_nonce_cache)))) {\n            assert(nonce->flags.incache);\n            authDigestNoncePurge(nonce);\n        }\n    }\n\n#if DEBUGSHUTDOWN\n    if (digest_nonce_pool) {\n        delete digest_nonce_pool;\n        digest_nonce_pool = NULL;\n    }\n\n#endif\n    debugs(29, 2, \"Nonce cache shutdown\");\n}\n\nstatic void\nauthenticateDigestNonceCacheCleanup(void *)\n{\n    /*\n     * We walk the hash by noncehex as that is the unique key we\n     * use.  For big hash tables we could consider stepping through\n     * the cache, 100/200 entries at a time. Lets see how it flies\n     * first.\n     */\n    digest_nonce_h *nonce;\n    debugs(29, 3, \"Cleaning the nonce cache now\");\n    debugs(29, 3, \"Current time: \" << current_time.tv_sec);\n    hash_first(digest_nonce_cache);\n\n    while ((nonce = ((digest_nonce_h *) hash_next(digest_nonce_cache)))) {\n        debugs(29, 3, \"nonce entry  : \" << nonce << \" '\" << (char *) nonce->key << \"'\");\n        debugs(29, 4, \"Creation time: \" << nonce->noncedata.creationtime);\n\n        if (authDigestNonceIsStale(nonce)) {\n            debugs(29, 4, \"Removing nonce \" << (char *) nonce->key << \" from cache due to timeout.\");\n            assert(nonce->flags.incache);\n            /* invalidate nonce so future requests fail */\n            nonce->flags.valid = false;\n            /* if it is tied to a auth_user, remove the tie */\n            authDigestNonceUserUnlink(nonce);\n            authDigestNoncePurge(nonce);\n        }\n    }\n\n    debugs(29, 3, \"Finished cleaning the nonce cache.\");\n\n    if (static_cast<Auth::Digest::Config*>(Auth::Config::Find(\"digest\"))->active())\n        eventAdd(\"Digest nonce cache maintenance\", authenticateDigestNonceCacheCleanup, NULL, static_cast<Auth::Digest::Config*>(Auth::Config::Find(\"digest\"))->nonceGCInterval, 1);\n}\n\nstatic void\nauthDigestNonceLink(digest_nonce_h * nonce)\n{\n    assert(nonce != NULL);\n    ++nonce->references;\n    assert(nonce->references != 0); // no overflows\n    debugs(29, 9, \"nonce '\" << nonce << \"' now at '\" << nonce->references << \"'.\");\n}\n\nvoid\nauthDigestNonceUnlink(digest_nonce_h * nonce)\n{\n    assert(nonce != NULL);\n\n    if (nonce->references > 0) {\n        -- nonce->references;\n    } else {\n        debugs(29, DBG_IMPORTANT, \"Attempt to lower nonce \" << nonce << \" refcount below 0!\");\n    }\n\n    debugs(29, 9, \"nonce '\" << nonce << \"' now at '\" << nonce->references << \"'.\");\n\n    if (nonce->references == 0)\n        authenticateDigestNonceDelete(nonce);\n}\n\nconst char *\nauthenticateDigestNonceNonceHex(const digest_nonce_h * nonce)\n{\n    if (!nonce)\n        return NULL;\n\n    return (char const *) nonce->key;\n}\n\nstatic digest_nonce_h *\nauthenticateDigestNonceFindNonce(const char *noncehex)\n{\n    digest_nonce_h *nonce = NULL;\n\n    if (noncehex == NULL)\n        return NULL;\n\n    debugs(29, 9, \"looking for noncehex '\" << noncehex << \"' in the nonce cache.\");\n\n    nonce = static_cast < digest_nonce_h * >(hash_lookup(digest_nonce_cache, noncehex));\n\n    if ((nonce == NULL) || (strcmp(authenticateDigestNonceNonceHex(nonce), noncehex)))\n        return NULL;\n\n    debugs(29, 9, \"Found nonce '\" << nonce << \"'\");\n\n    return nonce;\n}\n\nint\nauthDigestNonceIsValid(digest_nonce_h * nonce, char nc[9])\n{\n    unsigned long intnc;\n    /* do we have a nonce ? */\n\n    if (!nonce)\n        return 0;\n\n    intnc = strtol(nc, NULL, 16);\n\n    /* has it already been invalidated ? */\n    if (!nonce->flags.valid) {\n        debugs(29, 4, \"Nonce already invalidated\");\n        return 0;\n    }\n\n    /* is the nonce-count ok ? */\n    if (!static_cast<Auth::Digest::Config*>(Auth::Config::Find(\"digest\"))->CheckNonceCount) {\n        /* Ignore client supplied NC */\n        intnc = nonce->nc + 1;\n    }\n\n    if ((static_cast<Auth::Digest::Config*>(Auth::Config::Find(\"digest\"))->NonceStrictness && intnc != nonce->nc + 1) ||\n            intnc < nonce->nc + 1) {\n        debugs(29, 4, \"Nonce count doesn't match\");\n        nonce->flags.valid = false;\n        return 0;\n    }\n\n    /* increment the nonce count - we've already checked that intnc is a\n     *  valid representation for us, so we don't need the test here.\n     */\n    nonce->nc = intnc;\n\n    return !authDigestNonceIsStale(nonce);\n}\n\nint\nauthDigestNonceIsStale(digest_nonce_h * nonce)\n{\n    /* do we have a nonce ? */\n\n    if (!nonce)\n        return -1;\n\n    /* Is it already invalidated? */\n    if (!nonce->flags.valid)\n        return -1;\n\n    /* has it's max duration expired? */\n    if (nonce->noncedata.creationtime + static_cast<Auth::Digest::Config*>(Auth::Config::Find(\"digest\"))->noncemaxduration < current_time.tv_sec) {\n        debugs(29, 4, \"Nonce is too old. \" <<\n               nonce->noncedata.creationtime << \" \" <<\n               static_cast<Auth::Digest::Config*>(Auth::Config::Find(\"digest\"))->noncemaxduration << \" \" <<\n               current_time.tv_sec);\n\n        nonce->flags.valid = false;\n        return -1;\n    }\n\n    if (nonce->nc > 99999998) {\n        debugs(29, 4, \"Nonce count overflow\");\n        nonce->flags.valid = false;\n        return -1;\n    }\n\n    if (nonce->nc > static_cast<Auth::Digest::Config*>(Auth::Config::Find(\"digest\"))->noncemaxuses) {\n        debugs(29, 4, \"Nonce count over user limit\");\n        nonce->flags.valid = false;\n        return -1;\n    }\n\n    /* seems ok */\n    return 0;\n}\n\n/**\n * \\retval  0    the digest is not stale yet\n * \\retval -1    the digest will be stale on the next request\n */\nint\nauthDigestNonceLastRequest(digest_nonce_h * nonce)\n{\n    if (!nonce)\n        return -1;\n\n    if (nonce->nc == 99999997) {\n        debugs(29, 4, \"Nonce count about to overflow\");\n        return -1;\n    }\n\n    if (nonce->nc >= static_cast<Auth::Digest::Config*>(Auth::Config::Find(\"digest\"))->noncemaxuses - 1) {\n        debugs(29, 4, \"Nonce count about to hit user limit\");\n        return -1;\n    }\n\n    /* and other tests are possible. */\n    return 0;\n}\n\nvoid\nauthDigestNoncePurge(digest_nonce_h * nonce)\n{\n    if (!nonce)\n        return;\n\n    if (!nonce->flags.incache)\n        return;\n\n    hash_remove_link(digest_nonce_cache, nonce);\n\n    nonce->flags.incache = false;\n\n    /* the cache's link */\n    authDigestNonceUnlink(nonce);\n}\n\nvoid\nAuth::Digest::Config::rotateHelpers()\n{\n    /* schedule closure of existing helpers */\n    if (digestauthenticators) {\n        helperShutdown(digestauthenticators);\n    }\n\n    /* NP: dynamic helper restart will ensure they start up again as needed. */\n}\n\nbool\nAuth::Digest::Config::dump(StoreEntry * entry, const char *name, Auth::Config * scheme) const\n{\n    if (!Auth::Config::dump(entry, name, scheme))\n        return false;\n\n    storeAppendPrintf(entry, \"%s %s nonce_max_count %d\\n%s %s nonce_max_duration %d seconds\\n%s %s nonce_garbage_interval %d seconds\\n\",\n                      name, \"digest\", noncemaxuses,\n                      name, \"digest\", (int) noncemaxduration,\n                      name, \"digest\", (int) nonceGCInterval);\n    storeAppendPrintf(entry, \"%s digest utf8 %s\\n\", name, utf8 ? \"on\" : \"off\");\n    return true;\n}\n\nbool\nAuth::Digest::Config::active() const\n{\n    return authdigest_initialised == 1;\n}\n\nbool\nAuth::Digest::Config::configured() const\n{\n    if ((authenticateProgram != NULL) &&\n            (authenticateChildren.n_max != 0) &&\n            !realm.isEmpty() && (noncemaxduration > -1))\n        return true;\n\n    return false;\n}\n\n/* add the [www-|Proxy-]authenticate header on a 407 or 401 reply */\nvoid\nAuth::Digest::Config::fixHeader(Auth::UserRequest::Pointer auth_user_request, HttpReply *rep, Http::HdrType hdrType, HttpRequest *)\n{\n    if (!authenticateProgram)\n        return;\n\n    bool stale = false;\n    digest_nonce_h *nonce = NULL;\n\n    /* on a 407 or 401 we always use a new nonce */\n    if (auth_user_request != NULL) {\n        Auth::Digest::User *digest_user = dynamic_cast<Auth::Digest::User *>(auth_user_request->user().getRaw());\n\n        if (digest_user) {\n            stale = digest_user->credentials() == Auth::Handshake;\n            if (stale) {\n                nonce = digest_user->currentNonce();\n            }\n        }\n    }\n    if (!nonce) {\n        nonce = authenticateDigestNonceNew();\n    }\n\n    debugs(29, 9, \"Sending type:\" << hdrType <<\n           \" header: 'Digest realm=\\\"\" << realm << \"\\\", nonce=\\\"\" <<\n           authenticateDigestNonceNonceHex(nonce) << \"\\\", qop=\\\"\" << QOP_AUTH <<\n           \"\\\", stale=\" << (stale ? \"true\" : \"false\"));\n\n    /* in the future, for WWW auth we may want to support the domain entry */\n    httpHeaderPutStrf(&rep->header, hdrType, \"Digest realm=\\\"\" SQUIDSBUFPH \"\\\", nonce=\\\"%s\\\", qop=\\\"%s\\\", stale=%s\",\n                      SQUIDSBUFPRINT(realm), authenticateDigestNonceNonceHex(nonce), QOP_AUTH, stale ? \"true\" : \"false\");\n}\n\n/* Initialize helpers and the like for this auth scheme. Called AFTER parsing the\n * config file */\nvoid\nAuth::Digest::Config::init(Auth::Config *)\n{\n    if (authenticateProgram) {\n        authenticateDigestNonceSetup();\n        authdigest_initialised = 1;\n\n        if (digestauthenticators == NULL)\n            digestauthenticators = new helper(\"digestauthenticator\");\n\n        digestauthenticators->cmdline = authenticateProgram;\n\n        digestauthenticators->childs.updateLimits(authenticateChildren);\n\n        digestauthenticators->ipc_type = IPC_STREAM;\n\n        helperOpenServers(digestauthenticators);\n    }\n}\n\nvoid\nAuth::Digest::Config::registerWithCacheManager(void)\n{\n    Mgr::RegisterAction(\"digestauthenticator\",\n                        \"Digest User Authenticator Stats\",\n                        authenticateDigestStats, 0, 1);\n}\n\n/* free any allocated configuration details */\nvoid\nAuth::Digest::Config::done()\n{\n    Auth::Config::done();\n\n    authdigest_initialised = 0;\n\n    if (digestauthenticators)\n        helperShutdown(digestauthenticators);\n\n    if (!shutting_down)\n        return;\n\n    delete digestauthenticators;\n    digestauthenticators = NULL;\n\n    if (authenticateProgram)\n        wordlistDestroy(&authenticateProgram);\n}\n\nAuth::Digest::Config::Config() :\n    nonceGCInterval(5*60),\n    noncemaxduration(30*60),\n    noncemaxuses(50),\n    NonceStrictness(0),\n    CheckNonceCount(1),\n    PostWorkaround(0),\n    utf8(0)\n{}\n\nvoid\nAuth::Digest::Config::parse(Auth::Config * scheme, int n_configured, char *param_str)\n{\n    if (strcmp(param_str, \"program\") == 0) {\n        if (authenticateProgram)\n            wordlistDestroy(&authenticateProgram);\n\n        parse_wordlist(&authenticateProgram);\n\n        requirePathnameExists(\"auth_param digest program\", authenticateProgram->key);\n    } else if (strcmp(param_str, \"nonce_garbage_interval\") == 0) {\n        parse_time_t(&nonceGCInterval);\n    } else if (strcmp(param_str, \"nonce_max_duration\") == 0) {\n        parse_time_t(&noncemaxduration);\n    } else if (strcmp(param_str, \"nonce_max_count\") == 0) {\n        parse_int((int *) &noncemaxuses);\n    } else if (strcmp(param_str, \"nonce_strictness\") == 0) {\n        parse_onoff(&NonceStrictness);\n    } else if (strcmp(param_str, \"check_nonce_count\") == 0) {\n        parse_onoff(&CheckNonceCount);\n    } else if (strcmp(param_str, \"post_workaround\") == 0) {\n        parse_onoff(&PostWorkaround);\n    } else if (strcmp(param_str, \"utf8\") == 0) {\n        parse_onoff(&utf8);\n    } else\n        Auth::Config::parse(scheme, n_configured, param_str);\n}\n\nconst char *\nAuth::Digest::Config::type() const\n{\n    return Auth::Digest::Scheme::GetInstance()->type();\n}\n\nstatic void\nauthenticateDigestStats(StoreEntry * sentry)\n{\n    if (digestauthenticators)\n        digestauthenticators->packStatsInto(sentry, \"Digest Authenticator Statistics\");\n}\n\n/* NonceUserUnlink: remove the reference to auth_user and unlink the node from the list */\n\nstatic void\nauthDigestNonceUserUnlink(digest_nonce_h * nonce)\n{\n    Auth::Digest::User *digest_user;\n    dlink_node *link, *tmplink;\n\n    if (!nonce)\n        return;\n\n    if (!nonce->user)\n        return;\n\n    digest_user = nonce->user;\n\n    /* unlink from the user list. Yes we're crossing structures but this is the only\n     * time this code is needed\n     */\n    link = digest_user->nonces.head;\n\n    while (link) {\n        tmplink = link;\n        link = link->next;\n\n        if (tmplink->data == nonce) {\n            dlinkDelete(tmplink, &digest_user->nonces);\n            authDigestNonceUnlink(static_cast < digest_nonce_h * >(tmplink->data));\n            delete tmplink;\n            link = NULL;\n        }\n    }\n\n    /* this reference to user was not locked because freeeing the user frees\n     * the nonce too.\n     */\n    nonce->user = NULL;\n}\n\n/* authDigesteserLinkNonce: add a nonce to a given user's struct */\nvoid\nauthDigestUserLinkNonce(Auth::Digest::User * user, digest_nonce_h * nonce)\n{\n    dlink_node *node;\n\n    if (!user || !nonce || !nonce->user)\n        return;\n\n    Auth::Digest::User *digest_user = user;\n\n    node = digest_user->nonces.head;\n\n    while (node && (node->data != nonce))\n        node = node->next;\n\n    if (node)\n        return;\n\n    node = new dlink_node;\n\n    dlinkAddTail(nonce, node, &digest_user->nonces);\n\n    authDigestNonceLink(nonce);\n\n    /* ping this nonce to this auth user */\n    assert((nonce->user == NULL) || (nonce->user == user));\n\n    /* we don't lock this reference because removing the user removes the\n     * hash too. Of course if that changes we're stuffed so read the code huh?\n     */\n    nonce->user = user;\n}\n\n/* setup the necessary info to log the username */\nstatic Auth::UserRequest::Pointer\nauthDigestLogUsername(char *username, Auth::UserRequest::Pointer auth_user_request, const char *requestRealm)\n{\n    assert(auth_user_request != NULL);\n\n    /* log the username */\n    debugs(29, 9, \"Creating new user for logging '\" << (username?username:\"[no username]\") << \"'\");\n    Auth::User::Pointer digest_user = new Auth::Digest::User(static_cast<Auth::Digest::Config*>(Auth::Config::Find(\"digest\")), requestRealm);\n    /* save the credentials */\n    digest_user->username(username);\n    /* set the auth_user type */\n    digest_user->auth_type = Auth::AUTH_BROKEN;\n    /* link the request to the user */\n    auth_user_request->user(digest_user);\n    return auth_user_request;\n}\n\n/*\n * Decode a Digest [Proxy-]Auth string, placing the results in the passed\n * Auth_user structure.\n */\nAuth::UserRequest::Pointer\nAuth::Digest::Config::decode(char const *proxy_auth, const char *aRequestRealm)\n{\n    const char *item;\n    const char *p;\n    const char *pos = NULL;\n    char *username = NULL;\n    digest_nonce_h *nonce;\n    int ilen;\n\n    debugs(29, 9, \"beginning\");\n\n    Auth::Digest::UserRequest *digest_request = new Auth::Digest::UserRequest();\n\n    /* trim DIGEST from string */\n\n    while (xisgraph(*proxy_auth))\n        ++proxy_auth;\n\n    /* Trim leading whitespace before decoding */\n    while (xisspace(*proxy_auth))\n        ++proxy_auth;\n\n    String temp(proxy_auth);\n\n    while (strListGetItem(&temp, ',', &item, &ilen, &pos)) {\n        /* isolate directive name & value */\n        size_t nlen;\n        size_t vlen;\n        if ((p = (const char *)memchr(item, '=', ilen)) && (p - item < ilen)) {\n            nlen = p - item;\n            ++p;\n            vlen = ilen - (p - item);\n        } else {\n            nlen = ilen;\n            vlen = 0;\n        }\n\n        SBuf keyName(item, nlen);\n        String value;\n\n        if (vlen > 0) {\n            // see RFC 2617 section 3.2.1 and 3.2.2 for details on the BNF\n\n            if (keyName == SBuf(\"domain\",6) || keyName == SBuf(\"uri\",3)) {\n                // domain is Special. Not a quoted-string, must not be de-quoted. But is wrapped in '\"'\n                // BUG 3077: uri= can also be sent to us in a mangled (invalid!) form like domain\n                if (vlen > 1 && *p == '\"' && *(p + vlen -1) == '\"') {\n                    value.limitInit(p+1, vlen-2);\n                }\n            } else if (keyName == SBuf(\"qop\",3)) {\n                // qop is more special.\n                // On request this must not be quoted-string de-quoted. But is several values wrapped in '\"'\n                // On response this is a single un-quoted token.\n                if (vlen > 1 && *p == '\"' && *(p + vlen -1) == '\"') {\n                    value.limitInit(p+1, vlen-2);\n                } else {\n                    value.limitInit(p, vlen);\n                }\n            } else if (*p == '\"') {\n                if (!httpHeaderParseQuotedString(p, vlen, &value)) {\n                    debugs(29, 9, \"Failed to parse attribute '\" << item << \"' in '\" << temp << \"'\");\n                    continue;\n                }\n            } else {\n                value.limitInit(p, vlen);\n            }\n        } else {\n            debugs(29, 9, \"Failed to parse attribute '\" << item << \"' in '\" << temp << \"'\");\n            continue;\n        }\n\n        /* find type */\n        const http_digest_attr_type t = DigestFieldsLookupTable.lookup(keyName);\n\n        switch (t) {\n        case DIGEST_USERNAME:\n            safe_free(username);\n            if (value.size() != 0)\n                username = xstrndup(value.rawBuf(), value.size() + 1);\n            debugs(29, 9, \"Found Username '\" << username << \"'\");\n            break;\n\n        case DIGEST_REALM:\n            safe_free(digest_request->realm);\n            if (value.size() != 0)\n                digest_request->realm = xstrndup(value.rawBuf(), value.size() + 1);\n            debugs(29, 9, \"Found realm '\" << digest_request->realm << \"'\");\n            break;\n\n        case DIGEST_QOP:\n            safe_free(digest_request->qop);\n            if (value.size() != 0)\n                digest_request->qop = xstrndup(value.rawBuf(), value.size() + 1);\n            debugs(29, 9, \"Found qop '\" << digest_request->qop << \"'\");\n            break;\n\n        case DIGEST_ALGORITHM:\n            safe_free(digest_request->algorithm);\n            if (value.size() != 0)\n                digest_request->algorithm = xstrndup(value.rawBuf(), value.size() + 1);\n            debugs(29, 9, \"Found algorithm '\" << digest_request->algorithm << \"'\");\n            break;\n\n        case DIGEST_URI:\n            safe_free(digest_request->uri);\n            if (value.size() != 0)\n                digest_request->uri = xstrndup(value.rawBuf(), value.size() + 1);\n            debugs(29, 9, \"Found uri '\" << digest_request->uri << \"'\");\n            break;\n\n        case DIGEST_NONCE:\n            safe_free(digest_request->noncehex);\n            if (value.size() != 0)\n                digest_request->noncehex = xstrndup(value.rawBuf(), value.size() + 1);\n            debugs(29, 9, \"Found nonce '\" << digest_request->noncehex << \"'\");\n            break;\n\n        case DIGEST_NC:\n            if (value.size() != 8) {\n                debugs(29, 9, \"Invalid nc '\" << value << \"' in '\" << temp << \"'\");\n            }\n            xstrncpy(digest_request->nc, value.rawBuf(), value.size() + 1);\n            debugs(29, 9, \"Found noncecount '\" << digest_request->nc << \"'\");\n            break;\n\n        case DIGEST_CNONCE:\n            safe_free(digest_request->cnonce);\n            if (value.size() != 0)\n                digest_request->cnonce = xstrndup(value.rawBuf(), value.size() + 1);\n            debugs(29, 9, \"Found cnonce '\" << digest_request->cnonce << \"'\");\n            break;\n\n        case DIGEST_RESPONSE:\n            safe_free(digest_request->response);\n            if (value.size() != 0)\n                digest_request->response = xstrndup(value.rawBuf(), value.size() + 1);\n            debugs(29, 9, \"Found response '\" << digest_request->response << \"'\");\n            break;\n\n        default:\n            debugs(29, 3, \"Unknown attribute '\" << item << \"' in '\" << temp << \"'\");\n            break;\n        }\n    }\n\n    temp.clean();\n\n    /* now we validate the data given to us */\n\n    /*\n     * TODO: on invalid parameters we should return 400, not 407.\n     * Find some clean way of doing this. perhaps return a valid\n     * struct, and set the direction to clientwards combined with\n     * a change to the clientwards handling code (ie let the\n     * clientwards call set the error type (but limited to known\n     * correct values - 400/401/407\n     */\n\n    /* 2069 requirements */\n\n    // return value.\n    Auth::UserRequest::Pointer rv;\n    /* do we have a username ? */\n    if (!username || username[0] == '\\0') {\n        debugs(29, 2, \"Empty or not present username\");\n        rv = authDigestLogUsername(username, digest_request, aRequestRealm);\n        safe_free(username);\n        return rv;\n    }\n\n    /* Sanity check of the username.\n     * \" can not be allowed in usernames until * the digest helper protocol\n     * have been redone\n     */\n    if (strchr(username, '\"')) {\n        debugs(29, 2, \"Unacceptable username '\" << username << \"'\");\n        rv = authDigestLogUsername(username, digest_request, aRequestRealm);\n        safe_free(username);\n        return rv;\n    }\n\n    /* do we have a realm ? */\n    if (!digest_request->realm || digest_request->realm[0] == '\\0') {\n        debugs(29, 2, \"Empty or not present realm\");\n        rv = authDigestLogUsername(username, digest_request, aRequestRealm);\n        safe_free(username);\n        return rv;\n    }\n\n    /* and a nonce? */\n    if (!digest_request->noncehex || digest_request->noncehex[0] == '\\0') {\n        debugs(29, 2, \"Empty or not present nonce\");\n        rv = authDigestLogUsername(username, digest_request, aRequestRealm);\n        safe_free(username);\n        return rv;\n    }\n\n    /* we can't check the URI just yet. We'll check it in the\n     * authenticate phase, but needs to be given */\n    if (!digest_request->uri || digest_request->uri[0] == '\\0') {\n        debugs(29, 2, \"Missing URI field\");\n        rv = authDigestLogUsername(username, digest_request, aRequestRealm);\n        safe_free(username);\n        return rv;\n    }\n\n    /* is the response the correct length? */\n    if (!digest_request->response || strlen(digest_request->response) != 32) {\n        debugs(29, 2, \"Response length invalid\");\n        rv = authDigestLogUsername(username, digest_request, aRequestRealm);\n        safe_free(username);\n        return rv;\n    }\n\n    /* check the algorithm is present and supported */\n    if (!digest_request->algorithm)\n        digest_request->algorithm = xstrndup(\"MD5\", 4);\n    else if (strcmp(digest_request->algorithm, \"MD5\")\n             && strcmp(digest_request->algorithm, \"MD5-sess\")) {\n        debugs(29, 2, \"invalid algorithm specified!\");\n        rv = authDigestLogUsername(username, digest_request, aRequestRealm);\n        safe_free(username);\n        return rv;\n    }\n\n    /* 2617 requirements, indicated by qop */\n    if (digest_request->qop) {\n\n        /* check the qop is what we expected. */\n        if (strcmp(digest_request->qop, QOP_AUTH) != 0) {\n            /* we received a qop option we didn't send */\n            debugs(29, 2, \"Invalid qop option received\");\n            rv = authDigestLogUsername(username, digest_request, aRequestRealm);\n            safe_free(username);\n            return rv;\n        }\n\n        /* check cnonce */\n        if (!digest_request->cnonce || digest_request->cnonce[0] == '\\0') {\n            debugs(29, 2, \"Missing cnonce field\");\n            rv = authDigestLogUsername(username, digest_request, aRequestRealm);\n            safe_free(username);\n            return rv;\n        }\n\n        /* check nc */\n        if (strlen(digest_request->nc) != 8 || strspn(digest_request->nc, \"0123456789abcdefABCDEF\") != 8) {\n            debugs(29, 2, \"invalid nonce count\");\n            rv = authDigestLogUsername(username, digest_request, aRequestRealm);\n            safe_free(username);\n            return rv;\n        }\n    } else {\n        /* cnonce and nc both require qop */\n        if (digest_request->cnonce || digest_request->nc[0] != '\\0') {\n            debugs(29, 2, \"missing qop!\");\n            rv = authDigestLogUsername(username, digest_request, aRequestRealm);\n            safe_free(username);\n            return rv;\n        }\n    }\n\n    /** below nonce state dependent **/\n\n    /* now the nonce */\n    nonce = authenticateDigestNonceFindNonce(digest_request->noncehex);\n    /* check that we're not being hacked / the username hasn't changed */\n    if (nonce && nonce->user && strcmp(username, nonce->user->username())) {\n        debugs(29, 2, \"Username for the nonce does not equal the username for the request\");\n        nonce = NULL;\n    }\n\n    if (!nonce) {\n        /* we couldn't find a matching nonce! */\n        debugs(29, 2, \"Unexpected or invalid nonce received from \" << username);\n        Auth::UserRequest::Pointer auth_request = authDigestLogUsername(username, digest_request, aRequestRealm);\n        auth_request->user()->credentials(Auth::Handshake);\n        safe_free(username);\n        return auth_request;\n    }\n\n    digest_request->nonce = nonce;\n    authDigestNonceLink(nonce);\n\n    /* check that we're not being hacked / the username hasn't changed */\n    if (nonce->user && strcmp(username, nonce->user->username())) {\n        debugs(29, 2, \"Username for the nonce does not equal the username for the request\");\n        rv = authDigestLogUsername(username, digest_request, aRequestRealm);\n        safe_free(username);\n        return rv;\n    }\n\n    /* the method we'll check at the authenticate step as well */\n\n    /* we don't send or parse opaques. Ok so we're flexable ... */\n\n    /* find the user */\n    Auth::Digest::User *digest_user;\n\n    Auth::User::Pointer auth_user;\n\n    SBuf key = Auth::User::BuildUserKey(username, aRequestRealm);\n    if (key.isEmpty() || !(auth_user = Auth::Digest::User::Cache()->lookup(key))) {\n        /* the user doesn't exist in the username cache yet */\n        debugs(29, 9, \"Creating new digest user '\" << username << \"'\");\n        digest_user = new Auth::Digest::User(this, aRequestRealm);\n        /* auth_user is a parent */\n        auth_user = digest_user;\n        /* save the username */\n        digest_user->username(username);\n        /* set the user type */\n        digest_user->auth_type = Auth::AUTH_DIGEST;\n        /* this auth_user struct is the one to get added to the\n         * username cache */\n        /* store user in hash's */\n        digest_user->addToNameCache();\n\n        /*\n         * Add the digest to the user so we can tell if a hacking\n         * or spoofing attack is taking place. We do this by assuming\n         * the user agent won't change user name without warning.\n         */\n        authDigestUserLinkNonce(digest_user, nonce);\n\n        /* auth_user is now linked, we reset these values\n         * after external auth occurs anyway */\n        auth_user->expiretime = current_time.tv_sec;\n    } else {\n        debugs(29, 9, \"Found user '\" << username << \"' in the user cache as '\" << auth_user << \"'\");\n        digest_user = static_cast<Auth::Digest::User *>(auth_user.getRaw());\n        digest_user->credentials(Auth::Unchecked);\n        xfree(username);\n    }\n\n    /*link the request and the user */\n    assert(digest_request != NULL);\n\n    digest_request->user(digest_user);\n    debugs(29, 9, \"username = '\" << digest_user->username() << \"'\\nrealm = '\" <<\n           digest_request->realm << \"'\\nqop = '\" << digest_request->qop <<\n           \"'\\nalgorithm = '\" << digest_request->algorithm << \"'\\nuri = '\" <<\n           digest_request->uri << \"'\\nnonce = '\" << digest_request->noncehex <<\n           \"'\\nnc = '\" << digest_request->nc << \"'\\ncnonce = '\" <<\n           digest_request->cnonce << \"'\\nresponse = '\" <<\n           digest_request->response << \"'\\ndigestnonce = '\" << nonce << \"'\");\n\n    return digest_request;\n}\n\n", "/*\n * Copyright (C) 1996-2020 The Squid Software Foundation and contributors\n *\n * Squid software is distributed under GPLv2+ license and includes\n * contributions from numerous individuals and organizations.\n * Please see the COPYING and CONTRIBUTORS files for details.\n */\n\n#ifndef __AUTH_DIGEST_H__\n#define __AUTH_DIGEST_H__\n\n#if HAVE_AUTH_MODULE_DIGEST\n\n#include \"auth/Config.h\"\n#include \"auth/Gadgets.h\"\n#include \"auth/UserRequest.h\"\n#include \"helper/forward.h\"\n#include \"rfc2617.h\"\n\nnamespace Auth\n{\nnamespace Digest\n{\nclass User;\n}\n}\n\n/* Generic */\ntypedef struct _digest_nonce_data digest_nonce_data;\ntypedef struct _digest_nonce_h digest_nonce_h;\n\n/* data to be encoded into the nonce's hex representation */\nstruct _digest_nonce_data {\n    time_t creationtime;\n    uint32_t randomdata;\n};\n\n/* the nonce structure we'll pass around */\n\nstruct _digest_nonce_h : public hash_link {\n    digest_nonce_data noncedata;\n    /* number of uses we've seen of this nonce */\n    unsigned long nc;\n    /* reference count */\n    uint64_t references;\n    /* the auth_user this nonce has been tied to */\n    Auth::Digest::User *user;\n    /* has this nonce been invalidated ? */\n\n    struct {\n        bool valid;\n        bool incache;\n    } flags;\n};\n\nvoid authDigestNonceUnlink(digest_nonce_h * nonce);\nint authDigestNonceIsValid(digest_nonce_h * nonce, char nc[9]);\nint authDigestNonceIsStale(digest_nonce_h * nonce);\nconst char *authenticateDigestNonceNonceHex(const digest_nonce_h * nonce);\nint authDigestNonceLastRequest(digest_nonce_h * nonce);\nvoid authenticateDigestNonceShutdown(void);\nvoid authDigestNoncePurge(digest_nonce_h * nonce);\nvoid authDigestUserLinkNonce(Auth::Digest::User * user, digest_nonce_h * nonce);\ndigest_nonce_h *authenticateDigestNonceNew(void);\n\nnamespace Auth\n{\nnamespace Digest\n{\n\n/** Digest Authentication configuration data */\nclass Config : public Auth::Config\n{\npublic:\n    Config();\n    virtual bool active() const;\n    virtual bool configured() const;\n    virtual Auth::UserRequest::Pointer decode(char const *proxy_auth, const char *requestRealm);\n    virtual void done();\n    virtual void rotateHelpers();\n    virtual bool dump(StoreEntry *, const char *, Auth::Config *) const;\n    virtual void fixHeader(Auth::UserRequest::Pointer, HttpReply *, Http::HdrType, HttpRequest *);\n    virtual void init(Auth::Config *);\n    virtual void parse(Auth::Config *, int, char *);\n    virtual void registerWithCacheManager(void);\n    virtual const char * type() const;\n\npublic:\n    time_t nonceGCInterval;\n    time_t noncemaxduration;\n    unsigned int noncemaxuses;\n    int NonceStrictness;\n    int CheckNonceCount;\n    int PostWorkaround;\n    int utf8;\n};\n\n} // namespace Digest\n} // namespace Auth\n\n/* strings */\n#define QOP_AUTH \"auth\"\n\nextern helper *digestauthenticators;\n\n#endif /* HAVE_AUTH_MODULE_DIGEST */\n#endif\n\n"], "filenames": ["src/auth/digest/Config.cc", "src/auth/digest/Config.h"], "buggy_code_start_loc": [97, 45], "buggy_code_end_loc": [306, 46], "fixing_code_start_loc": [96, 45], "fixing_code_end_loc": [291, 46], "type": "CWE-190", "message": "An issue was discovered in Squid before 5.0.2. A remote attacker can replay a sniffed Digest Authentication nonce to gain access to resources that are otherwise forbidden. This occurs because the attacker can overflow the nonce reference counter (a short integer). Remote code execution may occur if the pooled token credentials are freed (instead of replayed as valid credentials).", "other": {"cve": {"id": "CVE-2020-11945", "sourceIdentifier": "cve@mitre.org", "published": "2020-04-23T15:15:14.233", "lastModified": "2021-03-17T12:40:42.037", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in Squid before 5.0.2. A remote attacker can replay a sniffed Digest Authentication nonce to gain access to resources that are otherwise forbidden. This occurs because the attacker can overflow the nonce reference counter (a short integer). Remote code execution may occur if the pooled token credentials are freed (instead of replayed as valid credentials)."}, {"lang": "es", "value": "Se detect\u00f3 un problema en Squid versiones anteriores a 5.0.2. Un atacante remoto puede reproducir un nonce Digest Autenticaci\u00f3n rastreado para conseguir acceso a recursos que de otra manera est\u00e1n restringidos. Esto ocurre porque el atacante puede desbordar el contador de referencia nonce (un entero corto). Una ejecuci\u00f3n de c\u00f3digo remota puede presentarse si las credenciales de token agrupadas son liberadas (en lugar de reproducirse como credenciales validas)."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:squid-cache:squid:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0", "versionEndIncluding": "3.5.28", "matchCriteriaId": "FC9F2659-B37B-4E7B-AE40-B91BF3CE4E88"}, {"vulnerable": true, "criteria": "cpe:2.3:a:squid-cache:squid:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.0", "versionEndExcluding": "4.11", "matchCriteriaId": "AEA4C698-1DD0-4229-A80A-2437D56AA38D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:squid-cache:squid:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.0", "versionEndExcluding": "5.0.2", "matchCriteriaId": "665C9300-5D66-4653-84CB-F3C3500F9BBF"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:30:*:*:*:*:*:*:*", "matchCriteriaId": "97A4B8DF-58DA-4AB6-A1F9-331B36409BA3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:32:*:*:*:*:*:*:*", "matchCriteriaId": "36D96259-24BD-44E2-96D9-78CE1D41F956"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.10:*:*:*:*:*:*:*", "matchCriteriaId": "A31C8344-3E02-4EB8-8BD8-4C84B7959624"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:20.04:*:*:*:lts:*:*:*", "matchCriteriaId": "902B8056-9E37-443B-8905-8AA93E2447FB"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-05/msg00018.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://master.squid-cache.org/Versions/v4/changesets/squid-4-eeebf0f37a72a2de08348e85ae34b02c34e9a811.patch", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2020/04/23/2", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.squid-cache.org/Versions/v4/changesets/squid-4-eeebf0f37a72a2de08348e85ae34b02c34e9a811.patch", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://bugzilla.suse.com/show_bug.cgi?id=1170313", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/squid-cache/squid/commit/eeebf0f37a72a2de08348e85ae34b02c34e9a811", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/squid-cache/squid/pull/585", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/07/msg00009.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/4FWQRYZJPHAZBLXJ56FPCHJN5X2FP3VA/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/H4MWXEZAJSOGRJSS2JCJK4WBSND4IV46/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/RV2VZWFJNO3B56IVN56HHKJASG5DYUIX/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202005-05", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20210304-0004/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4356-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2020/dsa-4682", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/squid-cache/squid/commit/eeebf0f37a72a2de08348e85ae34b02c34e9a811"}}