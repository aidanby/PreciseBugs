{"buggy_code": ["<?php\n# MantisBT - A PHP based bugtracking system\n\n# MantisBT is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 2 of the License, or\n# (at your option) any later version.\n#\n# MantisBT is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with MantisBT.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Access API\n *\n * @package CoreAPI\n * @subpackage AccessAPI\n * @copyright Copyright (C) 2000 - 2002  Kenzaburo Ito - kenito@300baud.org\n * @copyright Copyright (C) 2002 - 2012  MantisBT Team - mantisbt-dev@lists.sourceforge.net\n * @link http://www.mantisbt.org\n *\n * @uses authentication_api.php\n * @uses bug_api.php\n * @uses bugnote_api.php\n * @uses config_api.php\n * @uses constant_inc.php\n * @uses current_user_api.php\n * @uses database_api.php\n * @uses error_api.php\n * @uses helper_api.php\n * @uses lang_api.php\n * @uses print_api.php\n * @uses project_api.php\n * @uses string_api.php\n * @uses user_api.php\n */\n\nrequire_api( 'authentication_api.php' );\nrequire_api( 'bug_api.php' );\nrequire_api( 'bugnote_api.php' );\nrequire_api( 'config_api.php' );\nrequire_api( 'constant_inc.php' );\nrequire_api( 'current_user_api.php' );\nrequire_api( 'database_api.php' );\nrequire_api( 'error_api.php' );\nrequire_api( 'helper_api.php' );\nrequire_api( 'lang_api.php' );\nrequire_api( 'print_api.php' );\nrequire_api( 'project_api.php' );\nrequire_api( 'string_api.php' );\nrequire_api( 'user_api.php' );\n\n/**\n *\n * @global array $g_cache_access_matrix\n */\n$g_cache_access_matrix = array();\n\n/**\n *\n * @global array $g_cache_access_matrix_project_ids\n */\n$g_cache_access_matrix_project_ids = array();\n\n/**\n *\n * @global array $g_cache_access_matrix_user_ids\n */\n$g_cache_access_matrix_user_ids = array();\n\n/**\n * Function to be called when a user is attempting to access a page that\n * he/she is not authorised to.  This outputs an access denied message then\n * re-directs to the mainpage.\n */\nfunction access_denied() {\n\tif( !auth_is_user_authenticated() ) {\n\t\tif( basename( $_SERVER['SCRIPT_NAME'] ) != 'login_page.php' ) {\n\t\t\t$t_return_page = $_SERVER['SCRIPT_NAME'];\n\t\t\tif( isset( $_SERVER['QUERY_STRING'] ) ) {\n\t\t\t\t$t_return_page .= '?' . $_SERVER['QUERY_STRING'];\n\t\t\t}\n\t\t\t$t_return_page = string_url( string_sanitize_url( $t_return_page ) );\n\t\t\tprint_header_redirect( 'login_page.php' . '?return=' . $t_return_page );\n\t\t}\n\t} else {\n\t\tif( current_user_is_anonymous() ) {\n\t\t\tif( basename( $_SERVER['SCRIPT_NAME'] ) != 'login_page.php' ) {\n\t\t\t\t$t_return_page = $_SERVER['SCRIPT_NAME'];\n\t\t\t\tif( isset( $_SERVER['QUERY_STRING'] ) ) {\n\t\t\t\t\t$t_return_page .= '?' . $_SERVER['QUERY_STRING'];\n\t\t\t\t}\n\t\t\t\t$t_return_page = string_url( string_sanitize_url( $t_return_page ) );\n\t\t\t\techo '<p class=\"center\">' . error_string( ERROR_ACCESS_DENIED ) . '</p><p class=\"center\">';\n\t\t\t\tprint_bracket_link( helper_mantis_url( 'login_page.php' ) . '?return=' . $t_return_page, lang_get( 'click_to_login' ) );\n\t\t\t\techo '</p><p class=\"center\">';\n\t\t\t\tprint_bracket_link( helper_mantis_url( 'main_page.php' ), lang_get( 'proceed' ) );\n\t\t\t\techo '</p>';\n\t\t\t}\n\t\t} else {\n\t\t\techo '<p class=\"center\">' . error_string( ERROR_ACCESS_DENIED ) . '</p>';\n\t\t\techo '<p class=\"center\">';\n\t\t\tprint_bracket_link( helper_mantis_url( 'main_page.php' ), lang_get( 'proceed' ) );\n\t\t\techo '</p>';\n\t\t}\n\t}\n\texit;\n}\n\n/**\n * retrieves and returns access matrix for a project from cache or caching if required.\n * @param int $p_project_id integer representing project id\n * @return  array returns an array of users->accesslevel for the given user\n * @access private\n */\nfunction access_cache_matrix_project( $p_project_id ) {\n\tglobal $g_cache_access_matrix, $g_cache_access_matrix_project_ids;\n\n\tif( ALL_PROJECTS == (int)$p_project_id ) {\n\t\treturn array();\n\t}\n\n\tif( !in_array( (int) $p_project_id, $g_cache_access_matrix_project_ids ) ) {\n\t\t$t_project_user_list_table = db_get_table( 'project_user_list' );\n\n\t\t$query = \"SELECT user_id, access_level\n\t\t\t\t\t  FROM $t_project_user_list_table\n\t\t\t\t\t  WHERE project_id=\" . db_param();\n\t\t$result = db_query_bound( $query, Array( (int)$p_project_id ) );\n\t\t$count = db_num_rows( $result );\n\t\tfor( $i = 0;$i < $count;$i++ ) {\n\t\t\t$row = db_fetch_array( $result );\n\n\t\t\t$g_cache_access_matrix[(int) $row['user_id']][(int) $p_project_id] = (int) $row['access_level'];\n\t\t}\n\n\t\t$g_cache_access_matrix_project_ids[] = (int) $p_project_id;\n\t}\n\n\t$t_results = array();\n\n\tforeach( $g_cache_access_matrix as $t_user ) {\n\t\tif( isset( $t_user[(int) $p_project_id] ) ) {\n\t\t\t$t_results[(int) $p_project_id] = $t_user[(int) $p_project_id];\n\t\t}\n\t}\n\n\treturn $t_results;\n}\n\n/**\n * retrieves and returns access matrix for a user from cache or caching if required.\n * @param int $p_user_id integer representing user id\n * @return  array returns an array of projects->accesslevel for the given user\n * @access private\n */\nfunction access_cache_matrix_user( $p_user_id ) {\n\tglobal $g_cache_access_matrix, $g_cache_access_matrix_user_ids;\n\n\tif( !in_array( (int) $p_user_id, $g_cache_access_matrix_user_ids ) ) {\n\t\t$t_project_user_list_table = db_get_table( 'project_user_list' );\n\n\t\t$query = \"SELECT project_id, access_level\n\t\t\t\t\t  FROM $t_project_user_list_table\n\t\t\t\t\t  WHERE user_id=\" . db_param();\n\t\t$result = db_query_bound( $query, Array( (int)$p_user_id ) );\n\n\t\t$count = db_num_rows( $result );\n\n\t\t# make sure we always have an array to return\n\t\t$g_cache_access_matrix[(int) $p_user_id] = array();\n\n\t\tfor( $i = 0;$i < $count;$i++ ) {\n\t\t\t$row = db_fetch_array( $result );\n\t\t\t$g_cache_access_matrix[(int) $p_user_id][(int) $row['project_id']] = (int) $row['access_level'];\n\t\t}\n\n\t\t$g_cache_access_matrix_user_ids[] = (int) $p_user_id;\n\t}\n\n\treturn $g_cache_access_matrix[(int) $p_user_id];\n}\n\n/**\n * Check the a user's access against the given \"threshold\" and return true\n * if the user can access, false otherwise.\n * $p_access_level may be a single value, or an array. If it is a single\n * value, treat it as a threshold so return true if user is >= threshold.\n * If it is an array, look for exact matches to one of the values\n * @param int $p_user_access_level user access level\n * @param int|array $p_threshold access threshold, defaults to NOBODY\n * @return bool true or false depending on whether given access level matches the threshold\n * @access public\n */\nfunction access_compare_level( $p_user_access_level, $p_threshold = NOBODY ) {\n\tif( is_array( $p_threshold ) ) {\n\t\treturn( in_array( $p_user_access_level, $p_threshold ) );\n\t} else {\n\t\treturn( $p_user_access_level >= $p_threshold );\n\t}\n}\n\n/**\n * This function only checks the user's global access level, ignoring any\n * overrides they might have at a project level\n * @param int|null $p_user_id integer representing user id, defaults to null to use current user\n * @return int global access level\n * @access public\n */\nfunction access_get_global_level( $p_user_id = null ) {\n\tif( $p_user_id === null ) {\n\t\t$p_user_id = auth_get_current_user_id();\n\t}\n\n\t# Deal with not logged in silently in this case\n\t# @@@ we may be able to remove this and just error\n\t#     and once we default to anon login, we can remove it for sure\n\tif( empty( $p_user_id ) && !auth_is_user_authenticated() ) {\n\t\treturn false;\n\t}\n\n\treturn user_get_field( $p_user_id, 'access_level' );\n}\n\n/**\n * Check the current user's access against the given value and return true\n * if the user's access is equal to or higher, false otherwise.\n * @param int $p_access_level integer representing access level\n * @param int|null $p_user_id integer representing user id, defaults to null to use current user\n * @return bool whether user has access level specified\n * @access public\n */\nfunction access_has_global_level( $p_access_level, $p_user_id = null ) {\n\t# Short circuit the check in this case\n\tif( NOBODY == $p_access_level ) {\n\t\treturn false;\n\t}\n\n\tif( $p_user_id === null ) {\n\t\t$p_user_id = auth_get_current_user_id();\n\t}\n\n\t$t_access_level = access_get_global_level( $p_user_id );\n\n\treturn access_compare_level( $t_access_level, $p_access_level );\n}\n\n/**\n * Check if the user has the specified global access level\n * and deny access to the page if not\n * @see access_has_global_level\n * @param int $p_access_level integer representing access level\n * @param int|null $p_user_id integer representing user id, defaults to null to use current user\n * @access public\n */\nfunction access_ensure_global_level( $p_access_level, $p_user_id = null ) {\n\tif( !access_has_global_level( $p_access_level, $p_user_id ) ) {\n\t\taccess_denied();\n\t}\n}\n\n/**\n * This function checks the project access level first (for the current project\n * if none is specified) and if the user is not listed, it falls back on the\n * user's global access level.\n * @param int $p_project_id integer representing project id to check access against\n * @param int|null $p_user_id integer representing user id, defaults to null to use current user\n * @return int access level user has to given project\n * @access public\n */\nfunction access_get_project_level( $p_project_id = null, $p_user_id = null ) {\n\tif( null === $p_user_id ) {\n\t\t$p_user_id = auth_get_current_user_id();\n\t}\n\n\t# Deal with not logged in silently in this case\n\t/** @todo we may be able to remove this and just error and once we default to anon login, we can remove it for sure */\n\tif( empty( $p_user_id ) && !auth_is_user_authenticated() ) {\n\t\treturn ANYBODY;\n\t}\n\n\tif( null === $p_project_id ) {\n\t\t$p_project_id = helper_get_current_project();\n\t}\n\n\t$t_global_access_level = access_get_global_level( $p_user_id );\n\n\tif( ALL_PROJECTS == $p_project_id || user_is_administrator( $p_user_id ) ) {\n\t\treturn $t_global_access_level;\n\t} else {\n\t\t$t_project_access_level = access_get_local_level( $p_user_id, $p_project_id );\n\t\t$t_project_view_state = project_get_field( $p_project_id, 'view_state' );\n\n\t\t# Try to use the project access level.\n\t\t# If the user is not listed in the project, then try to fall back\n\t\t#  to the global access level\n\t\tif( false === $t_project_access_level ) {\n\t\t\t# If the project is private and the user isn't listed, then they\n\t\t\t# must have the private_project_threshold access level to get in.\n\t\t\tif( VS_PRIVATE == $t_project_view_state ) {\n\t\t\t\tif( access_compare_level( $t_global_access_level, config_get( 'private_project_threshold', null, null, ALL_PROJECTS ) ) ) {\n\t\t\t\t\treturn $t_global_access_level;\n\t\t\t\t} else {\n\t\t\t\t\treturn ANYBODY;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t# project access not set, but the project is public\n\t\t\t\treturn $t_global_access_level;\n\t\t\t}\n\t\t} else {\n\t\t\t# project specific access was set\n\t\t\treturn $t_project_access_level;\n\t\t}\n\t}\n}\n\n/**\n * Check the current user's access against the given value and return true\n * if the user's access is equal to or higher, false otherwise.\n * @param int $p_access_level integer representing access level\n * @param int $p_project_id integer representing project id to check access against\n * @param int|null $p_user_id integer representing user id, defaults to null to use current user\n * @return bool whether user has access level specified\n * @access public\n */\nfunction access_has_project_level( $p_access_level, $p_project_id = null, $p_user_id = null ) {\n\t# Short circuit the check in this case\n\tif( NOBODY == $p_access_level ) {\n\t\treturn false;\n\t}\n\n\tif( null === $p_user_id ) {\n\t\t$p_user_id = auth_get_current_user_id();\n\t}\n\tif( null === $p_project_id ) {\n\t\t$p_project_id = helper_get_current_project();\n\t}\n\n\t$t_access_level = access_get_project_level( $p_project_id, $p_user_id );\n\n\treturn access_compare_level( $t_access_level, $p_access_level );\n}\n\n/**\n * Check if the user has the specified access level for the given project\n * and deny access to the page if not\n * @see access_has_project_level\n * @param int $p_access_level integer representing access level\n * @param int|null $p_project_id integer representing project id to check access against, defaults to null to use current project\n * @param int|null $p_user_id integer representing user id, defaults to null to use current user\n * @access public\n */\nfunction access_ensure_project_level( $p_access_level, $p_project_id = null, $p_user_id = null ) {\n\tif( !access_has_project_level( $p_access_level, $p_project_id, $p_user_id ) ) {\n\t\taccess_denied();\n\t}\n}\n\n/**\n * Check whether the user has the specified access level for any project project\n * @param int $p_access_level integer representing access level\n * @param int|null $p_user_id integer representing user id, defaults to null to use current user\n * @return bool whether user has access level specified\n * @access public\n */\nfunction access_has_any_project( $p_access_level, $p_user_id = null ) {\n\t# Short circuit the check in this case\n\n\tif( NOBODY == $p_access_level ) {\n\t\treturn false;\n\t}\n\n\tif( null === $p_user_id ) {\n\t\t$p_user_id = auth_get_current_user_id();\n\t}\n\n\t$t_projects = project_get_all_rows();\n\tforeach( $t_projects as $t_project ) {\n\t\tif ( access_has_project_level( $p_access_level, $t_project['id'], $p_user_id ) ) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\n/**\n * Check the current user's access against the given value and return true\n * if the user's access is equal to or higher, false otherwise.\n * This function looks up the bug's project and performs an access check\n * against that project\n * @param int $p_access_level integer representing access level\n * @param int $p_bug_id integer representing bug id to check access against\n * @param int|null $p_user_id integer representing user id, defaults to null to use current user\n * @return bool whether user has access level specified\n * @access public\n */\nfunction access_has_bug_level( $p_access_level, $p_bug_id, $p_user_id = null ) {\n\tif( $p_user_id === null ) {\n\t\t$p_user_id = auth_get_current_user_id();\n\t}\n\n\t# Deal with not logged in silently in this case\n\t# @@@ we may be able to remove this and just error\n\t#     and once we default to anon login, we can remove it for sure\n\tif( empty( $p_user_id ) && !auth_is_user_authenticated() ) {\n\t\treturn false;\n\t}\n\n\t$t_project_id = bug_get_field( $p_bug_id, 'project_id' );\n\n\t# check limit_Reporter (Issue #4769)\n\t# reporters can view just issues they reported\n\t$t_limit_reporters = config_get( 'limit_reporters' );\n\tif(( ON === $t_limit_reporters ) && ( !bug_is_user_reporter( $p_bug_id, $p_user_id ) ) && ( !access_has_project_level( REPORTER + 1, $t_project_id, $p_user_id ) ) ) {\n\t\treturn false;\n\t}\n\n\t# If the bug is private and the user is not the reporter, then the\n\t#  the user must also have higher access than private_bug_threshold\n\tif( VS_PRIVATE == bug_get_field( $p_bug_id, 'view_state' ) && !bug_is_user_reporter( $p_bug_id, $p_user_id ) ) {\n\t\t$p_access_level = max( $p_access_level, config_get( 'private_bug_threshold' ) );\n\t}\n\n\treturn access_has_project_level( $p_access_level, $t_project_id, $p_user_id );\n}\n\n/**\n * Check if the user has the specified access level for the given bug\n * and deny access to the page if not\n * @see access_has_bug_level\n * @param int $p_access_level integer representing access level\n * @param int $p_bug_id integer representing bug id to check access against\n * @param int|null $p_user_id integer representing user id, defaults to null to use current user\n * @return bool whether user has access level specified\n * @access public\n */\nfunction access_ensure_bug_level( $p_access_level, $p_bug_id, $p_user_id = null ) {\n\tif( !access_has_bug_level( $p_access_level, $p_bug_id, $p_user_id ) ) {\n\t\taccess_denied();\n\t}\n}\n\n/**\n * Check the current user's access against the given value and return true\n * if the user's access is equal to or higher, false otherwise.\n * This function looks up the bugnote's bug and performs an access check\n * against that bug\n * @param int $p_access_level integer representing access level\n * @param int $p_bugnote_id integer representing bugnote id to check access against\n * @param int|null $p_user_id integer representing user id, defaults to null to use current user\n * @return bool whether user has access level specified\n * @access public\n */\nfunction access_has_bugnote_level( $p_access_level, $p_bugnote_id, $p_user_id = null ) {\n\tif( null === $p_user_id ) {\n\t\t$p_user_id = auth_get_current_user_id();\n\t}\n\n\t# If the bug is private and the user is not the reporter, then the\n\t#  the user must also have higher access than private_bug_threshold\n\tif( VS_PRIVATE == bugnote_get_field( $p_bugnote_id, 'view_state' ) && !bugnote_is_user_reporter( $p_bugnote_id, $p_user_id ) ) {\n\t\t$p_access_level = max( $p_access_level, config_get( 'private_bugnote_threshold' ) );\n\t}\n\n\t$t_bug_id = bugnote_get_field( $p_bugnote_id, 'bug_id' );\n\n\treturn access_has_bug_level( $p_access_level, $t_bug_id, $p_user_id );\n}\n\n/**\n * Check if the user has the specified access level for the given bugnote\n * and deny access to the page if not\n * @see access_has_bugnote_level\n * @param int $p_access_level integer representing access level\n * @param int $p_bugnote_id integer representing bugnote id to check access against\n * @param int|null $p_user_id integer representing user id, defaults to null to use current user\n * @access public\n */\n function access_ensure_bugnote_level( $p_access_level, $p_bugnote_id, $p_user_id = null ) {\n\tif( !access_has_bugnote_level( $p_access_level, $p_bugnote_id, $p_user_id ) ) {\n\t\taccess_denied();\n\t}\n}\n\n/**\n * Check if the current user can close the specified bug\n * @param int $p_bug_id integer representing bug id to check access against\n * @param int|null $p_user_id integer representing user id, defaults to null to use current user\n * @return bool whether user has access to close bugs\n * @access public\n */\n function access_can_close_bug( $p_bug_id, $p_user_id = null ) {\n\tif( null === $p_user_id ) {\n\t\t$p_user_id = auth_get_current_user_id();\n\t}\n\n\t# If allow_reporter_close is enabled, then reporters can always close their own bugs\n\tif( ON == config_get( 'allow_reporter_close' ) && bug_is_user_reporter( $p_bug_id, $p_user_id ) ) {\n\t\treturn true;\n\t}\n\n\t$t_bug = bug_get( $p_bug_id );\n\n\t$t_closed_status_threshold = access_get_status_threshold( config_get( 'bug_closed_status_threshold' ), $t_bug->project_id );\n\n\treturn access_has_bug_level( $t_closed_status_threshold, $p_bug_id, $p_user_id );\n}\n\n/**\n * Make sure that the current user can close the specified bug\n * @see access_can_close_bug\n * @param int $p_bug_id integer representing bug id to check access against\n * @param int|null $p_user_id integer representing user id, defaults to null to use current user\n * @access public\n */\n function access_ensure_can_close_bug( $p_bug_id, $p_user_id = null ) {\n\tif( !access_can_close_bug( $p_bug_id, $p_user_id ) ) {\n\t\taccess_denied();\n\t}\n}\n\n/**\n * Check if the current user can reopen the specified bug\n * @param int $p_bug_id integer representing bug id to check access against\n * @param int|null $p_user_id integer representing user id, defaults to null to use current user\n * @return bool whether user has access to reopen bugs\n * @access public\n */\n function access_can_reopen_bug( $p_bug_id, $p_user_id = null ) {\n\tif( $p_user_id === null ) {\n\t\t$p_user_id = auth_get_current_user_id();\n\t}\n\n\t# If allow_reporter_reopen is enabled, then reporters can always reopen their own bugs\n\tif( ON == config_get( 'allow_reporter_reopen' ) && bug_is_user_reporter( $p_bug_id, $p_user_id ) ) {\n\t\treturn true;\n\t}\n\n\treturn access_has_bug_level( config_get( 'reopen_bug_threshold' ), $p_bug_id, $p_user_id );\n}\n\n/**\n * Make sure that the current user can reopen the specified bug.\n * Calls access_denied if user has no access to terminate script\n * @see access_can_reopen_bug\n * @param int $p_bug_id integer representing bug id to check access against\n * @param int|null $p_user_id integer representing user id, defaults to null to use current user\n * @access public\n */\n function access_ensure_can_reopen_bug( $p_bug_id, $p_user_id = null ) {\n\tif( !access_can_reopen_bug( $p_bug_id, $p_user_id ) ) {\n\t\taccess_denied();\n\t}\n}\n\n/**\n * get the user's access level specific to this project.\n * return false (0) if the user has no access override here\n * @param int $p_user_id Integer representing user id\n * @param int $p_project_id integer representing project id\n * @return bool|int returns false (if no access) or an integer representing level of access\n * @access public\n */\nfunction access_get_local_level( $p_user_id, $p_project_id ) {\n\tglobal $g_cache_access_matrix, $g_cache_access_matrix_project_ids;\n\n\t$p_project_id = (int) $p_project_id;\n\t$p_user_id = (int) $p_user_id;\n\n\tif( in_array( $p_project_id, $g_cache_access_matrix_project_ids ) ) {\n\t\tif( isset( $g_cache_access_matrix[$p_user_id][$p_project_id] ) ) {\n\t\t\treturn $g_cache_access_matrix[$p_user_id][$p_project_id];\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t$t_project_level = access_cache_matrix_user( $p_user_id );\n\n\tif( isset( $t_project_level[$p_project_id] ) ) {\n\t\treturn $t_project_level[$p_project_id];\n\t} else {\n\t\treturn false;\n\t}\n}\n\n/**\n * get the access level required to change the issue to the new status\n * If there is no specific differentiated access level, use the\n * generic update_bug_status_threshold.\n * @param int $p_status\n * @param int $p_project_id Default value ALL_PROJECTS\n * @return int integer representing user level e.g. DEVELOPER\n * @access public\n */\nfunction access_get_status_threshold( $p_status, $p_project_id = ALL_PROJECTS ) {\n\t$t_thresh_array = config_get( 'set_status_threshold', null, null, $p_project_id );\n\tif( isset( $t_thresh_array[(int)$p_status] ) ) {\n\t\treturn (int)$t_thresh_array[(int)$p_status];\n\t} else {\n\t\treturn config_get( 'update_bug_status_threshold', null, null, $p_project_id );\n\t}\n}\n"], "fixing_code": ["<?php\n# MantisBT - A PHP based bugtracking system\n\n# MantisBT is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 2 of the License, or\n# (at your option) any later version.\n#\n# MantisBT is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with MantisBT.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Access API\n *\n * @package CoreAPI\n * @subpackage AccessAPI\n * @copyright Copyright (C) 2000 - 2002  Kenzaburo Ito - kenito@300baud.org\n * @copyright Copyright (C) 2002 - 2012  MantisBT Team - mantisbt-dev@lists.sourceforge.net\n * @link http://www.mantisbt.org\n *\n * @uses authentication_api.php\n * @uses bug_api.php\n * @uses bugnote_api.php\n * @uses config_api.php\n * @uses constant_inc.php\n * @uses current_user_api.php\n * @uses database_api.php\n * @uses error_api.php\n * @uses helper_api.php\n * @uses lang_api.php\n * @uses print_api.php\n * @uses project_api.php\n * @uses string_api.php\n * @uses user_api.php\n */\n\nrequire_api( 'authentication_api.php' );\nrequire_api( 'bug_api.php' );\nrequire_api( 'bugnote_api.php' );\nrequire_api( 'config_api.php' );\nrequire_api( 'constant_inc.php' );\nrequire_api( 'current_user_api.php' );\nrequire_api( 'database_api.php' );\nrequire_api( 'error_api.php' );\nrequire_api( 'helper_api.php' );\nrequire_api( 'lang_api.php' );\nrequire_api( 'print_api.php' );\nrequire_api( 'project_api.php' );\nrequire_api( 'string_api.php' );\nrequire_api( 'user_api.php' );\n\n/**\n *\n * @global array $g_cache_access_matrix\n */\n$g_cache_access_matrix = array();\n\n/**\n *\n * @global array $g_cache_access_matrix_project_ids\n */\n$g_cache_access_matrix_project_ids = array();\n\n/**\n *\n * @global array $g_cache_access_matrix_user_ids\n */\n$g_cache_access_matrix_user_ids = array();\n\n/**\n * Function to be called when a user is attempting to access a page that\n * he/she is not authorised to.  This outputs an access denied message then\n * re-directs to the mainpage.\n */\nfunction access_denied() {\n\tif( !auth_is_user_authenticated() ) {\n\t\tif( basename( $_SERVER['SCRIPT_NAME'] ) != 'login_page.php' ) {\n\t\t\t$t_return_page = $_SERVER['SCRIPT_NAME'];\n\t\t\tif( isset( $_SERVER['QUERY_STRING'] ) ) {\n\t\t\t\t$t_return_page .= '?' . $_SERVER['QUERY_STRING'];\n\t\t\t}\n\t\t\t$t_return_page = string_url( string_sanitize_url( $t_return_page ) );\n\t\t\tprint_header_redirect( 'login_page.php' . '?return=' . $t_return_page );\n\t\t}\n\t} else {\n\t\tif( current_user_is_anonymous() ) {\n\t\t\tif( basename( $_SERVER['SCRIPT_NAME'] ) != 'login_page.php' ) {\n\t\t\t\t$t_return_page = $_SERVER['SCRIPT_NAME'];\n\t\t\t\tif( isset( $_SERVER['QUERY_STRING'] ) ) {\n\t\t\t\t\t$t_return_page .= '?' . $_SERVER['QUERY_STRING'];\n\t\t\t\t}\n\t\t\t\t$t_return_page = string_url( string_sanitize_url( $t_return_page ) );\n\t\t\t\techo '<p class=\"center\">' . error_string( ERROR_ACCESS_DENIED ) . '</p><p class=\"center\">';\n\t\t\t\tprint_bracket_link( helper_mantis_url( 'login_page.php' ) . '?return=' . $t_return_page, lang_get( 'click_to_login' ) );\n\t\t\t\techo '</p><p class=\"center\">';\n\t\t\t\tprint_bracket_link( helper_mantis_url( 'main_page.php' ), lang_get( 'proceed' ) );\n\t\t\t\techo '</p>';\n\t\t\t}\n\t\t} else {\n\t\t\techo '<p class=\"center\">' . error_string( ERROR_ACCESS_DENIED ) . '</p>';\n\t\t\techo '<p class=\"center\">';\n\t\t\tprint_bracket_link( helper_mantis_url( 'main_page.php' ), lang_get( 'proceed' ) );\n\t\t\techo '</p>';\n\t\t}\n\t}\n\texit;\n}\n\n/**\n * retrieves and returns access matrix for a project from cache or caching if required.\n * @param int $p_project_id integer representing project id\n * @return  array returns an array of users->accesslevel for the given user\n * @access private\n */\nfunction access_cache_matrix_project( $p_project_id ) {\n\tglobal $g_cache_access_matrix, $g_cache_access_matrix_project_ids;\n\n\tif( ALL_PROJECTS == (int)$p_project_id ) {\n\t\treturn array();\n\t}\n\n\tif( !in_array( (int) $p_project_id, $g_cache_access_matrix_project_ids ) ) {\n\t\t$t_project_user_list_table = db_get_table( 'project_user_list' );\n\n\t\t$query = \"SELECT user_id, access_level\n\t\t\t\t\t  FROM $t_project_user_list_table\n\t\t\t\t\t  WHERE project_id=\" . db_param();\n\t\t$result = db_query_bound( $query, Array( (int)$p_project_id ) );\n\t\t$count = db_num_rows( $result );\n\t\tfor( $i = 0;$i < $count;$i++ ) {\n\t\t\t$row = db_fetch_array( $result );\n\n\t\t\t$g_cache_access_matrix[(int) $row['user_id']][(int) $p_project_id] = (int) $row['access_level'];\n\t\t}\n\n\t\t$g_cache_access_matrix_project_ids[] = (int) $p_project_id;\n\t}\n\n\t$t_results = array();\n\n\tforeach( $g_cache_access_matrix as $t_user ) {\n\t\tif( isset( $t_user[(int) $p_project_id] ) ) {\n\t\t\t$t_results[(int) $p_project_id] = $t_user[(int) $p_project_id];\n\t\t}\n\t}\n\n\treturn $t_results;\n}\n\n/**\n * retrieves and returns access matrix for a user from cache or caching if required.\n * @param int $p_user_id integer representing user id\n * @return  array returns an array of projects->accesslevel for the given user\n * @access private\n */\nfunction access_cache_matrix_user( $p_user_id ) {\n\tglobal $g_cache_access_matrix, $g_cache_access_matrix_user_ids;\n\n\tif( !in_array( (int) $p_user_id, $g_cache_access_matrix_user_ids ) ) {\n\t\t$t_project_user_list_table = db_get_table( 'project_user_list' );\n\n\t\t$query = \"SELECT project_id, access_level\n\t\t\t\t\t  FROM $t_project_user_list_table\n\t\t\t\t\t  WHERE user_id=\" . db_param();\n\t\t$result = db_query_bound( $query, Array( (int)$p_user_id ) );\n\n\t\t$count = db_num_rows( $result );\n\n\t\t# make sure we always have an array to return\n\t\t$g_cache_access_matrix[(int) $p_user_id] = array();\n\n\t\tfor( $i = 0;$i < $count;$i++ ) {\n\t\t\t$row = db_fetch_array( $result );\n\t\t\t$g_cache_access_matrix[(int) $p_user_id][(int) $row['project_id']] = (int) $row['access_level'];\n\t\t}\n\n\t\t$g_cache_access_matrix_user_ids[] = (int) $p_user_id;\n\t}\n\n\treturn $g_cache_access_matrix[(int) $p_user_id];\n}\n\n/**\n * Check the a user's access against the given \"threshold\" and return true\n * if the user can access, false otherwise.\n * $p_access_level may be a single value, or an array. If it is a single\n * value, treat it as a threshold so return true if user is >= threshold.\n * If it is an array, look for exact matches to one of the values\n * @param int $p_user_access_level user access level\n * @param int|array $p_threshold access threshold, defaults to NOBODY\n * @return bool true or false depending on whether given access level matches the threshold\n * @access public\n */\nfunction access_compare_level( $p_user_access_level, $p_threshold = NOBODY ) {\n\tif( is_array( $p_threshold ) ) {\n\t\treturn( in_array( $p_user_access_level, $p_threshold ) );\n\t} else {\n\t\treturn( $p_user_access_level >= $p_threshold );\n\t}\n}\n\n/**\n * This function only checks the user's global access level, ignoring any\n * overrides they might have at a project level\n * @param int|null $p_user_id integer representing user id, defaults to null to use current user\n * @return int global access level\n * @access public\n */\nfunction access_get_global_level( $p_user_id = null ) {\n\tif( $p_user_id === null ) {\n\t\t$p_user_id = auth_get_current_user_id();\n\t}\n\n\t# Deal with not logged in silently in this case\n\t# @@@ we may be able to remove this and just error\n\t#     and once we default to anon login, we can remove it for sure\n\tif( empty( $p_user_id ) && !auth_is_user_authenticated() ) {\n\t\treturn false;\n\t}\n\n\treturn user_get_field( $p_user_id, 'access_level' );\n}\n\n/**\n * Check the current user's access against the given value and return true\n * if the user's access is equal to or higher, false otherwise.\n * @param int $p_access_level integer representing access level\n * @param int|null $p_user_id integer representing user id, defaults to null to use current user\n * @return bool whether user has access level specified\n * @access public\n */\nfunction access_has_global_level( $p_access_level, $p_user_id = null ) {\n\t# Short circuit the check in this case\n\tif( NOBODY == $p_access_level ) {\n\t\treturn false;\n\t}\n\n\tif( $p_user_id === null ) {\n\t\t$p_user_id = auth_get_current_user_id();\n\t}\n\n\t$t_access_level = access_get_global_level( $p_user_id );\n\n\treturn access_compare_level( $t_access_level, $p_access_level );\n}\n\n/**\n * Check if the user has the specified global access level\n * and deny access to the page if not\n * @see access_has_global_level\n * @param int $p_access_level integer representing access level\n * @param int|null $p_user_id integer representing user id, defaults to null to use current user\n * @access public\n */\nfunction access_ensure_global_level( $p_access_level, $p_user_id = null ) {\n\tif( !access_has_global_level( $p_access_level, $p_user_id ) ) {\n\t\taccess_denied();\n\t}\n}\n\n/**\n * This function checks the project access level first (for the current project\n * if none is specified) and if the user is not listed, it falls back on the\n * user's global access level.\n * @param int $p_project_id integer representing project id to check access against\n * @param int|null $p_user_id integer representing user id, defaults to null to use current user\n * @return int access level user has to given project\n * @access public\n */\nfunction access_get_project_level( $p_project_id = null, $p_user_id = null ) {\n\tif( null === $p_user_id ) {\n\t\t$p_user_id = auth_get_current_user_id();\n\t}\n\n\t# Deal with not logged in silently in this case\n\t/** @todo we may be able to remove this and just error and once we default to anon login, we can remove it for sure */\n\tif( empty( $p_user_id ) && !auth_is_user_authenticated() ) {\n\t\treturn ANYBODY;\n\t}\n\n\tif( null === $p_project_id ) {\n\t\t$p_project_id = helper_get_current_project();\n\t}\n\n\t$t_global_access_level = access_get_global_level( $p_user_id );\n\n\tif( ALL_PROJECTS == $p_project_id || user_is_administrator( $p_user_id ) ) {\n\t\treturn $t_global_access_level;\n\t} else {\n\t\t$t_project_access_level = access_get_local_level( $p_user_id, $p_project_id );\n\t\t$t_project_view_state = project_get_field( $p_project_id, 'view_state' );\n\n\t\t# Try to use the project access level.\n\t\t# If the user is not listed in the project, then try to fall back\n\t\t#  to the global access level\n\t\tif( false === $t_project_access_level ) {\n\t\t\t# If the project is private and the user isn't listed, then they\n\t\t\t# must have the private_project_threshold access level to get in.\n\t\t\tif( VS_PRIVATE == $t_project_view_state ) {\n\t\t\t\tif( access_compare_level( $t_global_access_level, config_get( 'private_project_threshold', null, null, ALL_PROJECTS ) ) ) {\n\t\t\t\t\treturn $t_global_access_level;\n\t\t\t\t} else {\n\t\t\t\t\treturn ANYBODY;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t# project access not set, but the project is public\n\t\t\t\treturn $t_global_access_level;\n\t\t\t}\n\t\t} else {\n\t\t\t# project specific access was set\n\t\t\treturn $t_project_access_level;\n\t\t}\n\t}\n}\n\n/**\n * Check the current user's access against the given value and return true\n * if the user's access is equal to or higher, false otherwise.\n * @param int $p_access_level integer representing access level\n * @param int $p_project_id integer representing project id to check access against\n * @param int|null $p_user_id integer representing user id, defaults to null to use current user\n * @return bool whether user has access level specified\n * @access public\n */\nfunction access_has_project_level( $p_access_level, $p_project_id = null, $p_user_id = null ) {\n\t# Short circuit the check in this case\n\tif( NOBODY == $p_access_level ) {\n\t\treturn false;\n\t}\n\n\tif( null === $p_user_id ) {\n\t\t$p_user_id = auth_get_current_user_id();\n\t}\n\tif( null === $p_project_id ) {\n\t\t$p_project_id = helper_get_current_project();\n\t}\n\n\t$t_access_level = access_get_project_level( $p_project_id, $p_user_id );\n\n\treturn access_compare_level( $t_access_level, $p_access_level );\n}\n\n/**\n * Check if the user has the specified access level for the given project\n * and deny access to the page if not\n * @see access_has_project_level\n * @param int $p_access_level integer representing access level\n * @param int|null $p_project_id integer representing project id to check access against, defaults to null to use current project\n * @param int|null $p_user_id integer representing user id, defaults to null to use current user\n * @access public\n */\nfunction access_ensure_project_level( $p_access_level, $p_project_id = null, $p_user_id = null ) {\n\tif( !access_has_project_level( $p_access_level, $p_project_id, $p_user_id ) ) {\n\t\taccess_denied();\n\t}\n}\n\n/**\n * Check whether the user has the specified access level for any project project\n * @param int $p_access_level integer representing access level\n * @param int|null $p_user_id integer representing user id, defaults to null to use current user\n * @return bool whether user has access level specified\n * @access public\n */\nfunction access_has_any_project( $p_access_level, $p_user_id = null ) {\n\t# Short circuit the check in this case\n\n\tif( NOBODY == $p_access_level ) {\n\t\treturn false;\n\t}\n\n\tif( null === $p_user_id ) {\n\t\t$p_user_id = auth_get_current_user_id();\n\t}\n\n\t$t_projects = project_get_all_rows();\n\tforeach( $t_projects as $t_project ) {\n\t\tif ( access_has_project_level( $p_access_level, $t_project['id'], $p_user_id ) ) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\n/**\n * Check the current user's access against the given value and return true\n * if the user's access is equal to or higher, false otherwise.\n * This function looks up the bug's project and performs an access check\n * against that project\n * @param int $p_access_level integer representing access level\n * @param int $p_bug_id integer representing bug id to check access against\n * @param int|null $p_user_id integer representing user id, defaults to null to use current user\n * @return bool whether user has access level specified\n * @access public\n */\nfunction access_has_bug_level( $p_access_level, $p_bug_id, $p_user_id = null ) {\n\tif( $p_user_id === null ) {\n\t\t$p_user_id = auth_get_current_user_id();\n\t}\n\n\t# Deal with not logged in silently in this case\n\t# @@@ we may be able to remove this and just error\n\t#     and once we default to anon login, we can remove it for sure\n\tif( empty( $p_user_id ) && !auth_is_user_authenticated() ) {\n\t\treturn false;\n\t}\n\n\t$t_project_id = bug_get_field( $p_bug_id, 'project_id' );\n\n\t# check limit_Reporter (Issue #4769)\n\t# reporters can view just issues they reported\n\t$t_limit_reporters = config_get( 'limit_reporters' );\n\tif(( ON === $t_limit_reporters ) && ( !bug_is_user_reporter( $p_bug_id, $p_user_id ) ) && ( !access_has_project_level( REPORTER + 1, $t_project_id, $p_user_id ) ) ) {\n\t\treturn false;\n\t}\n\n\t# If the bug is private and the user is not the reporter, then\n\t# they must also have higher access than private_bug_threshold\n\tif( VS_PRIVATE == bug_get_field( $p_bug_id, 'view_state' ) && !bug_is_user_reporter( $p_bug_id, $p_user_id ) ) {\n\t\t$t_access_level = access_get_project_level( $t_project_id, $p_user_id );\n\t\treturn access_compare_level( $t_access_level, config_get( 'private_bug_threshold' ) )\n\t\t    && access_compare_level( $t_access_level, $p_access_level );\n\t}\n\n\treturn access_has_project_level( $p_access_level, $t_project_id, $p_user_id );\n}\n\n/**\n * Check if the user has the specified access level for the given bug\n * and deny access to the page if not\n * @see access_has_bug_level\n * @param int $p_access_level integer representing access level\n * @param int $p_bug_id integer representing bug id to check access against\n * @param int|null $p_user_id integer representing user id, defaults to null to use current user\n * @return bool whether user has access level specified\n * @access public\n */\nfunction access_ensure_bug_level( $p_access_level, $p_bug_id, $p_user_id = null ) {\n\tif( !access_has_bug_level( $p_access_level, $p_bug_id, $p_user_id ) ) {\n\t\taccess_denied();\n\t}\n}\n\n/**\n * Check the current user's access against the given value and return true\n * if the user's access is equal to or higher, false otherwise.\n * This function looks up the bugnote's bug and performs an access check\n * against that bug\n * @param int $p_access_level integer representing access level\n * @param int $p_bugnote_id integer representing bugnote id to check access against\n * @param int|null $p_user_id integer representing user id, defaults to null to use current user\n * @return bool whether user has access level specified\n * @access public\n */\nfunction access_has_bugnote_level( $p_access_level, $p_bugnote_id, $p_user_id = null ) {\n\tif( null === $p_user_id ) {\n\t\t$p_user_id = auth_get_current_user_id();\n\t}\n\n\t# If the bug is private and the user is not the reporter, then the\n\t#  the user must also have higher access than private_bug_threshold\n\tif( VS_PRIVATE == bugnote_get_field( $p_bugnote_id, 'view_state' ) && !bugnote_is_user_reporter( $p_bugnote_id, $p_user_id ) ) {\n\t\t$p_access_level = max( $p_access_level, config_get( 'private_bugnote_threshold' ) );\n\t}\n\n\t$t_bug_id = bugnote_get_field( $p_bugnote_id, 'bug_id' );\n\n\treturn access_has_bug_level( $p_access_level, $t_bug_id, $p_user_id );\n}\n\n/**\n * Check if the user has the specified access level for the given bugnote\n * and deny access to the page if not\n * @see access_has_bugnote_level\n * @param int $p_access_level integer representing access level\n * @param int $p_bugnote_id integer representing bugnote id to check access against\n * @param int|null $p_user_id integer representing user id, defaults to null to use current user\n * @access public\n */\n function access_ensure_bugnote_level( $p_access_level, $p_bugnote_id, $p_user_id = null ) {\n\tif( !access_has_bugnote_level( $p_access_level, $p_bugnote_id, $p_user_id ) ) {\n\t\taccess_denied();\n\t}\n}\n\n/**\n * Check if the current user can close the specified bug\n * @param int $p_bug_id integer representing bug id to check access against\n * @param int|null $p_user_id integer representing user id, defaults to null to use current user\n * @return bool whether user has access to close bugs\n * @access public\n */\n function access_can_close_bug( $p_bug_id, $p_user_id = null ) {\n\tif( null === $p_user_id ) {\n\t\t$p_user_id = auth_get_current_user_id();\n\t}\n\n\t# If allow_reporter_close is enabled, then reporters can always close their own bugs\n\tif( ON == config_get( 'allow_reporter_close' ) && bug_is_user_reporter( $p_bug_id, $p_user_id ) ) {\n\t\treturn true;\n\t}\n\n\t$t_bug = bug_get( $p_bug_id );\n\n\t$t_closed_status_threshold = access_get_status_threshold( config_get( 'bug_closed_status_threshold' ), $t_bug->project_id );\n\n\treturn access_has_bug_level( $t_closed_status_threshold, $p_bug_id, $p_user_id );\n}\n\n/**\n * Make sure that the current user can close the specified bug\n * @see access_can_close_bug\n * @param int $p_bug_id integer representing bug id to check access against\n * @param int|null $p_user_id integer representing user id, defaults to null to use current user\n * @access public\n */\n function access_ensure_can_close_bug( $p_bug_id, $p_user_id = null ) {\n\tif( !access_can_close_bug( $p_bug_id, $p_user_id ) ) {\n\t\taccess_denied();\n\t}\n}\n\n/**\n * Check if the current user can reopen the specified bug\n * @param int $p_bug_id integer representing bug id to check access against\n * @param int|null $p_user_id integer representing user id, defaults to null to use current user\n * @return bool whether user has access to reopen bugs\n * @access public\n */\n function access_can_reopen_bug( $p_bug_id, $p_user_id = null ) {\n\tif( $p_user_id === null ) {\n\t\t$p_user_id = auth_get_current_user_id();\n\t}\n\n\t# If allow_reporter_reopen is enabled, then reporters can always reopen their own bugs\n\tif( ON == config_get( 'allow_reporter_reopen' ) && bug_is_user_reporter( $p_bug_id, $p_user_id ) ) {\n\t\treturn true;\n\t}\n\n\treturn access_has_bug_level( config_get( 'reopen_bug_threshold' ), $p_bug_id, $p_user_id );\n}\n\n/**\n * Make sure that the current user can reopen the specified bug.\n * Calls access_denied if user has no access to terminate script\n * @see access_can_reopen_bug\n * @param int $p_bug_id integer representing bug id to check access against\n * @param int|null $p_user_id integer representing user id, defaults to null to use current user\n * @access public\n */\n function access_ensure_can_reopen_bug( $p_bug_id, $p_user_id = null ) {\n\tif( !access_can_reopen_bug( $p_bug_id, $p_user_id ) ) {\n\t\taccess_denied();\n\t}\n}\n\n/**\n * get the user's access level specific to this project.\n * return false (0) if the user has no access override here\n * @param int $p_user_id Integer representing user id\n * @param int $p_project_id integer representing project id\n * @return bool|int returns false (if no access) or an integer representing level of access\n * @access public\n */\nfunction access_get_local_level( $p_user_id, $p_project_id ) {\n\tglobal $g_cache_access_matrix, $g_cache_access_matrix_project_ids;\n\n\t$p_project_id = (int) $p_project_id;\n\t$p_user_id = (int) $p_user_id;\n\n\tif( in_array( $p_project_id, $g_cache_access_matrix_project_ids ) ) {\n\t\tif( isset( $g_cache_access_matrix[$p_user_id][$p_project_id] ) ) {\n\t\t\treturn $g_cache_access_matrix[$p_user_id][$p_project_id];\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t$t_project_level = access_cache_matrix_user( $p_user_id );\n\n\tif( isset( $t_project_level[$p_project_id] ) ) {\n\t\treturn $t_project_level[$p_project_id];\n\t} else {\n\t\treturn false;\n\t}\n}\n\n/**\n * get the access level required to change the issue to the new status\n * If there is no specific differentiated access level, use the\n * generic update_bug_status_threshold.\n * @param int $p_status\n * @param int $p_project_id Default value ALL_PROJECTS\n * @return int integer representing user level e.g. DEVELOPER\n * @access public\n */\nfunction access_get_status_threshold( $p_status, $p_project_id = ALL_PROJECTS ) {\n\t$t_thresh_array = config_get( 'set_status_threshold', null, null, $p_project_id );\n\tif( isset( $t_thresh_array[(int)$p_status] ) ) {\n\t\treturn (int)$t_thresh_array[(int)$p_status];\n\t} else {\n\t\treturn config_get( 'update_bug_status_threshold', null, null, $p_project_id );\n\t}\n}\n"], "filenames": ["core/access_api.php"], "buggy_code_start_loc": [423], "buggy_code_end_loc": [427], "fixing_code_start_loc": [423], "fixing_code_end_loc": [429], "type": "CWE-264", "message": "The access_has_bug_level function in core/access_api.php in MantisBT before 1.2.9 does not properly restrict access when the private_bug_view_threshold is set to an array, which allows remote attackers to bypass intended restrictions and perform certain operations on private bug reports.", "other": {"cve": {"id": "CVE-2012-1118", "sourceIdentifier": "secalert@redhat.com", "published": "2012-06-29T19:55:02.860", "lastModified": "2013-08-27T03:21:46.090", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The access_has_bug_level function in core/access_api.php in MantisBT before 1.2.9 does not properly restrict access when the private_bug_view_threshold is set to an array, which allows remote attackers to bypass intended restrictions and perform certain operations on private bug reports."}, {"lang": "es", "value": "La funci\u00f3n access_has_bug_level de core/access_api.php de MantisBT anteriores a 1.2.9 no restringe el acceso apropiadamente si private_bug_view_threshold es configurado a un array, lo que permite a atacantes remotos evitar las restricciones previstas y realizar determinadas acciones en reportes de bug privados."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-264"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.2.8", "matchCriteriaId": "79367D94-9665-49D7-94E4-CC9EFC7439BB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:0.18.0:*:*:*:*:*:*:*", "matchCriteriaId": "AF83F757-4B62-441C-8421-15809E573A83"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:0.19.0:*:*:*:*:*:*:*", "matchCriteriaId": "A608AFEC-B265-4143-99DA-BB2AE9D522BC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:0.19.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "7FCB56AC-4C14-49B1-BEFE-8651BC70476E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:0.19.0a1:*:*:*:*:*:*:*", "matchCriteriaId": "64BCCC4D-D109-4116-A9C3-E5553686A986"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:0.19.0a2:*:*:*:*:*:*:*", "matchCriteriaId": "BAAF1C66-9DC7-4FD3-8651-C5561B2681A5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:0.19.1:*:*:*:*:*:*:*", "matchCriteriaId": "F59BAE6B-C73D-4BE2-AEF9-93F2F4A4373F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:0.19.2:*:*:*:*:*:*:*", "matchCriteriaId": "C9DA5C2F-FB7C-4D95-81DE-24D8EADC5C30"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:0.19.3:*:*:*:*:*:*:*", "matchCriteriaId": "85A3FBD5-163C-4990-B809-A5C9C81A3C6C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:0.19.4:*:*:*:*:*:*:*", "matchCriteriaId": "D3FDF456-9648-4A7C-B15A-2828A32D4962"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:0.19.5:*:*:*:*:*:*:*", "matchCriteriaId": "9EE8BCBE-D864-4311-B73A-DF92162D8DF3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "6B2602F7-2D93-4E1E-9425-4EDD23752029"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "62F6B391-DDE3-4E8E-8582-85EA7287E591"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "80DBD667-1FB9-4354-9150-A190D4D817A2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.0:rc3:*:*:*:*:*:*", "matchCriteriaId": "F27E40C0-263F-452B-8C91-E621A02EFC28"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.0:rc4:*:*:*:*:*:*", "matchCriteriaId": "CB888B14-EA67-4EDB-A3AF-ACD3F0A6227E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.0:rc5:*:*:*:*:*:*", "matchCriteriaId": "1DB45A02-2522-4E10-BC81-48750ACB42DD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.0a1:*:*:*:*:*:*:*", "matchCriteriaId": "AC837ACF-EB55-4E9C-BFC5-83BB04B84BE3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.0a2:*:*:*:*:*:*:*", "matchCriteriaId": "F8826523-FDEE-4C14-8EAC-97C564272CC8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.0a3:*:*:*:*:*:*:*", "matchCriteriaId": "1780295B-215F-4EEE-8CF8-2E3531D7A196"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "86DE3BE3-D6C9-4905-9E61-B70776460604"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "F128A2E2-D509-4B50-95C2-1A31C5B3B31F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "140D5F68-1CAB-458C-BC8B-4F726D657FE8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "0D25F4F5-7678-41C1-93CB-305883A08527"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "D1A1316D-314B-4740-A836-D5E6319F4B28"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.6:*:*:*:*:*:*:*", "matchCriteriaId": "DBD27CCE-28C4-43CC-8CBD-D7FFB46171AC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.7:*:*:*:*:*:*:*", "matchCriteriaId": "97298C43-B881-4C11-ADB6-17A8E43EB84E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.0.8:*:*:*:*:*:*:*", "matchCriteriaId": "7257ADD7-C9B7-4F85-AA13-615DD033FD5C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "02FE950B-5E29-4FAA-9BE5-79F38B4C38F7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "D6F2BA78-D054-4E49-ABCA-637922898BF7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.1.2:*:*:*:*:*:*:*", "matchCriteriaId": "4595B1E3-25AB-489E-A847-FDBF2554DD6D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.1.4:*:*:*:*:*:*:*", "matchCriteriaId": "C11A8F17-5253-475B-89FF-A26EA7531E13"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.1.5:*:*:*:*:*:*:*", "matchCriteriaId": "4A88B09D-CDCF-45FD-B004-13B597DA4F48"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.1.6:*:*:*:*:*:*:*", "matchCriteriaId": "49583BE8-B832-4E9F-B154-47A26C72489D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.1.7:*:*:*:*:*:*:*", "matchCriteriaId": "E2501F40-3630-4528-BE0A-61D4BB6EC7FE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.1.8:*:*:*:*:*:*:*", "matchCriteriaId": "9223DAF7-D03E-4A4E-8AB5-5CEB87DFF2C3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "CFF77ABF-0A03-437A-B241-1EF2BBB83D24"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.2.0a1:*:*:*:*:*:*:*", "matchCriteriaId": "5875D457-28EF-4076-8E04-60CF9CF6D27A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.2.0a2:*:*:*:*:*:*:*", "matchCriteriaId": "301F44D1-21E7-4E00-BF45-2190D1FE21FF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "5F096CD6-534E-4ABF-B2DF-D4B55B8C5F6A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.2.2:*:*:*:*:*:*:*", "matchCriteriaId": "A66AB537-6FBA-4A51-B10C-BF61F54BC01B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.2.3:*:*:*:*:*:*:*", "matchCriteriaId": "A50835BF-D28B-47FF-81F0-C34D95D6F2E9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.2.4:*:*:*:*:*:*:*", "matchCriteriaId": "BA0EB9A6-1DFD-4C17-A002-0899DA252A56"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.2.5:*:*:*:*:*:*:*", "matchCriteriaId": "BBA33285-3EE7-43FD-8347-E7D9A18DC134"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.2.6:*:*:*:*:*:*:*", "matchCriteriaId": "8827C2B4-EBEC-4D64-9AC8-07A048467F40"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.2.7:*:*:*:*:*:*:*", "matchCriteriaId": "1F32DFF4-6448-46FD-9358-4FB1C310EC2E"}]}]}], "references": [{"url": "http://lists.fedoraproject.org/pipermail/package-announce/2012-November/092926.html", "source": "secalert@redhat.com"}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2012-November/093063.html", "source": "secalert@redhat.com"}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2012-November/093064.html", "source": "secalert@redhat.com"}, {"url": "http://security.gentoo.org/glsa/glsa-201211-01.xml", "source": "secalert@redhat.com"}, {"url": "http://www.debian.org/security/2012/dsa-2500", "source": "secalert@redhat.com"}, {"url": "http://www.mantisbt.org/bugs/changelog_page.php?version_id=140", "source": "secalert@redhat.com"}, {"url": "http://www.mantisbt.org/bugs/view.php?id=10124", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2012/03/06/9", "source": "secalert@redhat.com"}, {"url": "http://www.securityfocus.com/bid/52313", "source": "secalert@redhat.com"}, {"url": "https://github.com/mantisbt/mantisbt/commit/eb803ed02105fc919cf5f789e939f2b824162927", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/mantisbt/mantisbt/commit/eb803ed02105fc919cf5f789e939f2b824162927"}}