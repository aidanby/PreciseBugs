{"buggy_code": ["class Api::V1::Accounts::CampaignsController < Api::V1::Accounts::BaseController\n  before_action :campaign, except: [:index, :create]\n  before_action :check_authorization\n\n  def index\n    @campaigns = Current.account.campaigns\n  end\n\n  def create\n    @campaign = Current.account.campaigns.create!(campaign_params)\n  end\n\n  def destroy\n    @campaign.destroy\n    head :ok\n  end\n\n  def show; end\n\n  def update\n    @campaign.update(campaign_params)\n  end\n\n  private\n\n  def campaign\n    @campaign ||= Current.account.campaigns.find_by(display_id: params[:id])\n  end\n\n  def campaign_params\n    params.require(:campaign).permit(:title, :description, :message, :enabled, :trigger_only_during_business_hours, :inbox_id, :sender_id,\n                                     :scheduled_at, audience: [:type, :id], trigger_rules: {})\n  end\nend\n", "# == Schema Information\n#\n# Table name: campaigns\n#\n#  id                                 :bigint           not null, primary key\n#  audience                           :jsonb\n#  campaign_status                    :integer          default(\"active\"), not null\n#  campaign_type                      :integer          default(\"ongoing\"), not null\n#  description                        :text\n#  enabled                            :boolean          default(TRUE)\n#  message                            :text             not null\n#  scheduled_at                       :datetime\n#  title                              :string           not null\n#  trigger_only_during_business_hours :boolean          default(FALSE)\n#  trigger_rules                      :jsonb\n#  created_at                         :datetime         not null\n#  updated_at                         :datetime         not null\n#  account_id                         :bigint           not null\n#  display_id                         :integer          not null\n#  inbox_id                           :bigint           not null\n#  sender_id                          :integer\n#\n# Indexes\n#\n#  index_campaigns_on_account_id       (account_id)\n#  index_campaigns_on_campaign_status  (campaign_status)\n#  index_campaigns_on_campaign_type    (campaign_type)\n#  index_campaigns_on_inbox_id         (inbox_id)\n#  index_campaigns_on_scheduled_at     (scheduled_at)\n#\n# Foreign Keys\n#\n#  fk_rails_...  (account_id => accounts.id) ON DELETE => cascade\n#  fk_rails_...  (inbox_id => inboxes.id) ON DELETE => cascade\n#\nclass Campaign < ApplicationRecord\n  validates :account_id, presence: true\n  validates :inbox_id, presence: true\n  validates :title, presence: true\n  validates :message, presence: true\n  validate :validate_campaign_inbox\n  validate :prevent_completed_campaign_from_update, on: :update\n  belongs_to :account\n  belongs_to :inbox\n  belongs_to :sender, class_name: 'User', optional: true\n\n  enum campaign_type: { ongoing: 0, one_off: 1 }\n  # TODO : enabled attribute is unneccessary . lets move that to the campaign status with additional statuses like draft, disabled etc.\n  enum campaign_status: { active: 0, completed: 1 }\n\n  has_many :conversations, dependent: :nullify, autosave: true\n\n  before_validation :ensure_correct_campaign_attributes\n  after_commit :set_display_id, unless: :display_id?\n\n  def trigger!\n    return unless one_off?\n    return if completed?\n\n    Twilio::OneoffSmsCampaignService.new(campaign: self).perform if inbox.inbox_type == 'Twilio SMS'\n    Sms::OneoffSmsCampaignService.new(campaign: self).perform if inbox.inbox_type == 'Sms'\n  end\n\n  private\n\n  def set_display_id\n    reload\n  end\n\n  def validate_campaign_inbox\n    return unless inbox\n\n    errors.add :inbox, 'Unsupported Inbox type' unless ['Website', 'Twilio SMS', 'Sms'].include? inbox.inbox_type\n  end\n\n  # TO-DO we clean up with better validations when campaigns evolve into more inboxes\n  def ensure_correct_campaign_attributes\n    return if inbox.blank?\n\n    if ['Twilio SMS', 'Sms'].include?(inbox.inbox_type)\n      self.campaign_type = 'one_off'\n      self.scheduled_at ||= Time.now.utc\n    else\n      self.campaign_type = 'ongoing'\n      self.scheduled_at = nil\n    end\n  end\n\n  def prevent_completed_campaign_from_update\n    errors.add :status, 'The campaign is already completed' if !campaign_status_changed? && completed?\n  end\n\n  # creating db triggers\n  trigger.before(:insert).for_each(:row) do\n    \"NEW.display_id := nextval('camp_dpid_seq_' || NEW.account_id);\"\n  end\nend\n", "require 'rails_helper'\n\ndescribe ::Campaigns::CampaignConversationBuilder do\n  let(:account) { create(:account) }\n  let(:inbox) { create(:inbox, account: account) }\n  let(:contact) { create(:contact, account: account, identifier: '123') }\n  let(:contact_inbox) { create(:contact_inbox, contact: contact, inbox: inbox) }\n  let(:campaign) { create(:campaign, inbox: inbox, account: account) }\n\n  describe '#perform' do\n    it 'creates a conversation with campaign id and message with campaign message' do\n      campaign_conversation = described_class.new(\n        contact_inbox_id: contact_inbox.id,\n        campaign_display_id: campaign.display_id\n      ).perform\n\n      expect(campaign_conversation.campaign_id).to eq(campaign.id)\n      expect(campaign_conversation.messages.first.content).to eq(campaign.message)\n    end\n\n    it 'will not create a conversation with campaign id if another conversation exists' do\n      create(:conversation, contact_inbox_id: contact_inbox.id, inbox: inbox, account: account)\n      campaign_conversation = described_class.new(\n        contact_inbox_id: contact_inbox.id,\n        campaign_display_id: campaign.display_id\n      ).perform\n\n      expect(campaign_conversation).to eq(nil)\n    end\n  end\nend\n", "require 'rails_helper'\n\nRSpec.describe 'Campaigns API', type: :request do\n  let(:account) { create(:account) }\n\n  describe 'GET /api/v1/accounts/{account.id}/campaigns' do\n    context 'when it is an unauthenticated user' do\n      it 'returns unauthorized' do\n        get \"/api/v1/accounts/#{account.id}/campaigns\"\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n    end\n\n    context 'when it is an authenticated user' do\n      let(:agent) { create(:user, account: account, role: :agent) }\n      let(:administrator) { create(:user, account: account, role: :administrator) }\n      let!(:campaign) { create(:campaign, account: account) }\n\n      it 'returns unauthorized for agents' do\n        get \"/api/v1/accounts/#{account.id}/campaigns\",\n            headers: agent.create_new_auth_token,\n            as: :json\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n\n      it 'returns all campaigns to administrators' do\n        get \"/api/v1/accounts/#{account.id}/campaigns\",\n            headers: administrator.create_new_auth_token,\n            as: :json\n\n        expect(response).to have_http_status(:success)\n        body = JSON.parse(response.body, symbolize_names: true)\n        expect(body.first[:id]).to eq(campaign.display_id)\n      end\n    end\n  end\n\n  describe 'GET /api/v1/accounts/{account.id}/campaigns/:id' do\n    let(:campaign) { create(:campaign, account: account) }\n\n    context 'when it is an unauthenticated user' do\n      it 'returns unauthorized' do\n        get \"/api/v1/accounts/#{account.id}/campaigns/#{campaign.display_id}\"\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n    end\n\n    context 'when it is an authenticated user' do\n      let(:agent) { create(:user, account: account, role: :agent) }\n      let(:administrator) { create(:user, account: account, role: :administrator) }\n\n      it 'returns unauthorized for agents' do\n        get \"/api/v1/accounts/#{account.id}/campaigns/#{campaign.display_id}\",\n            headers: agent.create_new_auth_token,\n            as: :json\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n\n      it 'shows the campaign for administrators' do\n        get \"/api/v1/accounts/#{account.id}/campaigns/#{campaign.display_id}\",\n            headers: administrator.create_new_auth_token,\n            as: :json\n\n        expect(response).to have_http_status(:success)\n        expect(JSON.parse(response.body, symbolize_names: true)[:id]).to eq(campaign.display_id)\n      end\n    end\n  end\n\n  describe 'POST /api/v1/accounts/{account.id}/campaigns' do\n    let(:inbox) { create(:inbox, account: account) }\n\n    context 'when it is an unauthenticated user' do\n      it 'returns unauthorized' do\n        post \"/api/v1/accounts/#{account.id}/campaigns\",\n             params: { inbox_id: inbox.id, title: 'test', message: 'test message' },\n             as: :json\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n    end\n\n    context 'when it is an authenticated user' do\n      let(:agent) { create(:user, account: account, role: :agent) }\n      let(:administrator) { create(:user, account: account, role: :administrator) }\n\n      it 'returns unauthorized for agents' do\n        post \"/api/v1/accounts/#{account.id}/campaigns\",\n             params: { inbox_id: inbox.id, title: 'test', message: 'test message' },\n             headers: agent.create_new_auth_token,\n             as: :json\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n\n      it 'creates a new campaign' do\n        post \"/api/v1/accounts/#{account.id}/campaigns\",\n             params: { inbox_id: inbox.id, title: 'test', message: 'test message' },\n             headers: administrator.create_new_auth_token,\n             as: :json\n\n        expect(response).to have_http_status(:success)\n        expect(JSON.parse(response.body, symbolize_names: true)[:title]).to eq('test')\n      end\n\n      it 'creates a new oneoff campaign' do\n        twilio_sms = create(:channel_twilio_sms, account: account)\n        twilio_inbox = create(:inbox, channel: twilio_sms)\n        label1 = create(:label, account: account)\n        label2 = create(:label, account: account)\n\n        post \"/api/v1/accounts/#{account.id}/campaigns\",\n             params: {\n               inbox_id: twilio_inbox.id, title: 'test', message: 'test message',\n               scheduled_at: 2.days.from_now,\n               audience: [{ type: 'Label', id: label1.id }, { type: 'Label', id: label2.id }]\n             },\n             headers: administrator.create_new_auth_token,\n             as: :json\n\n        expect(response).to have_http_status(:success)\n        response_data = JSON.parse(response.body, symbolize_names: true)\n        expect(response_data[:campaign_type]).to eq('one_off')\n        expect(response_data[:scheduled_at].present?).to eq true\n        expect(response_data[:audience].pluck(:id)).to include(label1.id, label2.id)\n      end\n    end\n  end\n\n  describe 'PATCH /api/v1/accounts/{account.id}/campaigns/:id' do\n    let(:inbox) { create(:inbox, account: account) }\n    let!(:campaign) { create(:campaign, account: account) }\n\n    context 'when it is an unauthenticated user' do\n      it 'returns unauthorized' do\n        patch \"/api/v1/accounts/#{account.id}/campaigns/#{campaign.display_id}\",\n              params: { inbox_id: inbox.id, title: 'test', message: 'test message' },\n              as: :json\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n    end\n\n    context 'when it is an authenticated user' do\n      let(:agent) { create(:user, account: account, role: :agent) }\n      let(:administrator) { create(:user, account: account, role: :administrator) }\n\n      it 'returns unauthorized for agents' do\n        patch \"/api/v1/accounts/#{account.id}/campaigns/#{campaign.display_id}\",\n              params: { inbox_id: inbox.id, title: 'test', message: 'test message' },\n              headers: agent.create_new_auth_token,\n              as: :json\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n\n      it 'updates the campaign' do\n        patch \"/api/v1/accounts/#{account.id}/campaigns/#{campaign.display_id}\",\n              params: { inbox_id: inbox.id, title: 'test', message: 'test message' },\n              headers: administrator.create_new_auth_token,\n              as: :json\n\n        expect(response).to have_http_status(:success)\n        expect(JSON.parse(response.body, symbolize_names: true)[:title]).to eq('test')\n      end\n    end\n  end\n\n  describe 'DELETE /api/v1/accounts/{account.id}/campaigns/:id' do\n    let(:inbox) { create(:inbox, account: account) }\n    let!(:campaign) { create(:campaign, account: account) }\n\n    context 'when it is an unauthenticated user' do\n      it 'returns unauthorized' do\n        delete \"/api/v1/accounts/#{account.id}/campaigns/#{campaign.display_id}\",\n               as: :json\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n    end\n\n    context 'when it is an authenticated user' do\n      let(:agent) { create(:user, account: account, role: :agent) }\n      let(:administrator) { create(:user, account: account, role: :administrator) }\n\n      it 'return unauthorized if agent' do\n        delete \"/api/v1/accounts/#{account.id}/campaigns/#{campaign.display_id}\",\n               headers: agent.create_new_auth_token,\n               as: :json\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n\n      it 'delete campaign if admin' do\n        delete \"/api/v1/accounts/#{account.id}/campaigns/#{campaign.display_id}\",\n               headers: administrator.create_new_auth_token,\n               as: :json\n\n        expect(response).to have_http_status(:success)\n        expect(::Campaign.exists?(campaign.display_id)).to eq false\n      end\n    end\n  end\nend\n", "require 'rails_helper'\n\nRSpec.describe 'Inboxes API', type: :request do\n  let(:account) { create(:account) }\n  let(:agent) { create(:user, account: account, role: :agent) }\n  let(:admin) { create(:user, account: account, role: :administrator) }\n\n  describe 'GET /api/v1/accounts/{account.id}/inboxes' do\n    context 'when it is an unauthenticated user' do\n      it 'returns unauthorized' do\n        get \"/api/v1/accounts/#{account.id}/inboxes\"\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n    end\n\n    context 'when it is an authenticated user' do\n      let(:agent) { create(:user, account: account, role: :agent) }\n      let(:admin) { create(:user, account: account, role: :administrator) }\n      let(:inbox) { create(:inbox, account: account) }\n\n      before do\n        create(:inbox, account: account)\n        create(:inbox_member, user: agent, inbox: inbox)\n      end\n\n      it 'returns all inboxes of current_account as administrator' do\n        get \"/api/v1/accounts/#{account.id}/inboxes\",\n            headers: admin.create_new_auth_token,\n            as: :json\n\n        expect(response).to have_http_status(:success)\n        expect(JSON.parse(response.body, symbolize_names: true)[:payload].size).to eq(2)\n      end\n\n      it 'returns only assigned inboxes of current_account as agent' do\n        get \"/api/v1/accounts/#{account.id}/inboxes\",\n            headers: agent.create_new_auth_token,\n            as: :json\n\n        expect(response).to have_http_status(:success)\n        expect(JSON.parse(response.body, symbolize_names: true)[:payload].size).to eq(1)\n      end\n    end\n  end\n\n  describe 'GET /api/v1/accounts/{account.id}/inboxes/{inbox.id}' do\n    let(:inbox) { create(:inbox, account: account) }\n\n    context 'when it is an unauthenticated user' do\n      it 'returns unauthorized' do\n        get \"/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}\"\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n    end\n\n    context 'when it is an authenticated user' do\n      let(:agent) { create(:user, account: account, role: :agent) }\n      let(:admin) { create(:user, account: account, role: :administrator) }\n      let(:inbox) { create(:inbox, account: account) }\n\n      it 'returns unauthorized for an agent who is not assigned' do\n        get \"/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}\",\n            headers: agent.create_new_auth_token,\n            as: :json\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n\n      it 'returns the inbox if administrator' do\n        get \"/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}\",\n            headers: admin.create_new_auth_token,\n            as: :json\n\n        expect(response).to have_http_status(:success)\n        expect(JSON.parse(response.body, symbolize_names: true)[:id]).to eq(inbox.id)\n      end\n\n      it 'returns the inbox if assigned inbox is assigned as agent' do\n        create(:inbox_member, user: agent, inbox: inbox)\n        get \"/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}\",\n            headers: agent.create_new_auth_token,\n            as: :json\n\n        expect(response).to have_http_status(:success)\n        expect(JSON.parse(response.body, symbolize_names: true)[:id]).to eq(inbox.id)\n      end\n    end\n  end\n\n  describe 'GET /api/v1/accounts/{account.id}/inboxes/{inbox.id}/assignable_agents' do\n    let(:inbox) { create(:inbox, account: account) }\n\n    context 'when it is an unauthenticated user' do\n      it 'returns unauthorized' do\n        get \"/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}/assignable_agents\"\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n    end\n\n    context 'when it is an authenticated user' do\n      before do\n        create(:inbox_member, user: agent, inbox: inbox)\n      end\n\n      it 'returns all assignable inbox members along with administrators' do\n        get \"/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}/assignable_agents\",\n            headers: admin.create_new_auth_token,\n            as: :json\n\n        expect(response).to have_http_status(:success)\n        response_data = JSON.parse(response.body, symbolize_names: true)[:payload]\n        expect(response_data.size).to eq(2)\n        expect(response_data.pluck(:role)).to include('agent', 'administrator')\n      end\n    end\n  end\n\n  describe 'GET /api/v1/accounts/{account.id}/inboxes/{inbox.id}/campaigns' do\n    let(:inbox) { create(:inbox, account: account) }\n\n    context 'when it is an unauthenticated user' do\n      it 'returns unauthorized' do\n        get \"/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}/campaigns\"\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n    end\n\n    context 'when it is an authenticated user' do\n      let(:agent) { create(:user, account: account, role: :agent) }\n      let(:administrator) { create(:user, account: account, role: :administrator) }\n\n      let!(:campaign) { create(:campaign, account: account, inbox: inbox) }\n\n      it 'returns unauthorized for agents' do\n        get \"/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}/campaigns\",\n            headers: agent.create_new_auth_token,\n            as: :json\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n\n      it 'returns all campaigns belonging to the inbox to administrators' do\n        # create a random campaign\n        create(:campaign, account: account)\n        get \"/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}/campaigns\",\n            headers: administrator.create_new_auth_token,\n            as: :json\n\n        expect(response).to have_http_status(:success)\n        body = JSON.parse(response.body, symbolize_names: true)\n        expect(body.first[:id]).to eq(campaign.display_id)\n        expect(body.length).to eq(1)\n      end\n    end\n  end\n\n  describe 'DELETE /api/v1/accounts/{account.id}/inboxes/{inbox.id}/avatar' do\n    let(:inbox) { create(:inbox, account: account) }\n\n    context 'when it is an unauthenticated user' do\n      it 'returns unauthorized' do\n        delete \"/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}/avatar\"\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n    end\n\n    context 'when it is an authenticated user' do\n      before do\n        create(:inbox_member, user: agent, inbox: inbox)\n        inbox.avatar.attach(io: File.open(Rails.root.join('spec/assets/avatar.png')), filename: 'avatar.png', content_type: 'image/png')\n      end\n\n      it 'delete inbox avatar for administrator user' do\n        delete \"/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}/avatar\",\n               headers: admin.create_new_auth_token,\n               as: :json\n\n        expect { inbox.avatar.attachment.reload }.to raise_error(ActiveRecord::RecordNotFound)\n        expect(response).to have_http_status(:success)\n      end\n\n      it 'returns unauthorized for agent user' do\n        delete \"/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}/avatar\",\n               headers: agent.create_new_auth_token,\n               as: :json\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n    end\n  end\n\n  describe 'DELETE /api/v1/accounts/{account.id}/inboxes/:id' do\n    let(:inbox) { create(:inbox, account: account) }\n\n    context 'when it is an unauthenticated user' do\n      it 'returns unauthorized' do\n        delete \"/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}\"\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n    end\n\n    context 'when it is an authenticated user' do\n      let(:admin) { create(:user, account: account, role: :administrator) }\n\n      it 'deletes inbox' do\n        delete \"/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}\",\n               headers: admin.create_new_auth_token,\n               as: :json\n\n        expect(response).to have_http_status(:success)\n        expect { inbox.reload }.to raise_exception(ActiveRecord::RecordNotFound)\n      end\n\n      it 'is unable to delete inbox of another account' do\n        other_account = create(:account)\n        other_inbox = create(:inbox, account: other_account)\n\n        delete \"/api/v1/accounts/#{account.id}/inboxes/#{other_inbox.id}\",\n               headers: admin.create_new_auth_token,\n               as: :json\n\n        expect(response).to have_http_status(:not_found)\n      end\n\n      it 'is unable to delete inbox as agent' do\n        agent = create(:user, account: account, role: :agent)\n\n        delete \"/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}\",\n               headers: agent.create_new_auth_token,\n               as: :json\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n    end\n  end\n\n  describe 'POST /api/v1/accounts/{account.id}/inboxes' do\n    let(:inbox) { create(:inbox, account: account) }\n\n    context 'when it is an unauthenticated user' do\n      it 'returns unauthorized' do\n        post \"/api/v1/accounts/#{account.id}/inboxes\"\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n    end\n\n    context 'when it is an authenticated user' do\n      let(:admin) { create(:user, account: account, role: :administrator) }\n      let(:valid_params) { { name: 'test', channel: { type: 'web_widget', website_url: 'test.com' } } }\n\n      it 'will not create inbox for agent' do\n        agent = create(:user, account: account, role: :agent)\n\n        post \"/api/v1/accounts/#{account.id}/inboxes\",\n             headers: agent.create_new_auth_token,\n             params: valid_params,\n             as: :json\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n\n      it 'creates a webwidget inbox when administrator' do\n        post \"/api/v1/accounts/#{account.id}/inboxes\",\n             headers: admin.create_new_auth_token,\n             params: valid_params,\n             as: :json\n\n        expect(response).to have_http_status(:success)\n        expect(response.body).to include('test.com')\n      end\n\n      it 'creates a email inbox when administrator' do\n        post \"/api/v1/accounts/#{account.id}/inboxes\",\n             headers: admin.create_new_auth_token,\n             params: { name: 'test', channel: { type: 'email', email: 'test@test.com' } },\n             as: :json\n\n        expect(response).to have_http_status(:success)\n        expect(response.body).to include('test@test.com')\n      end\n\n      it 'creates an api inbox when administrator' do\n        post \"/api/v1/accounts/#{account.id}/inboxes\",\n             headers: admin.create_new_auth_token,\n             params: { name: 'API Inbox', channel: { type: 'api', webhook_url: 'http://test.com' } },\n             as: :json\n\n        expect(response).to have_http_status(:success)\n        expect(response.body).to include('API Inbox')\n      end\n\n      it 'creates a line inbox when administrator' do\n        post \"/api/v1/accounts/#{account.id}/inboxes\",\n             headers: admin.create_new_auth_token,\n             params: { name: 'Line Inbox',\n                       channel: { type: 'line', line_channel_id: SecureRandom.uuid, line_channel_secret: SecureRandom.uuid,\n                                  line_channel_token: SecureRandom.uuid } },\n             as: :json\n\n        expect(response).to have_http_status(:success)\n        expect(response.body).to include('Line Inbox')\n        expect(response.body).to include('callback_webhook_url')\n      end\n\n      it 'creates a sms inbox when administrator' do\n        post \"/api/v1/accounts/#{account.id}/inboxes\",\n             headers: admin.create_new_auth_token,\n             params: { name: 'Sms Inbox',\n                       channel: { type: 'sms', phone_number: '+123456789', provider_config: { test: 'test' } } },\n             as: :json\n\n        expect(response).to have_http_status(:success)\n        expect(response.body).to include('Sms Inbox')\n        expect(response.body).to include('+123456789')\n      end\n\n      it 'creates the webwidget inbox that allow messages after conversation is resolved' do\n        post \"/api/v1/accounts/#{account.id}/inboxes\",\n             headers: admin.create_new_auth_token,\n             params: valid_params,\n             as: :json\n\n        expect(response).to have_http_status(:success)\n        json_response = JSON.parse(response.body)\n        expect(json_response['allow_messages_after_resolved']).to be true\n      end\n    end\n  end\n\n  describe 'PATCH /api/v1/accounts/{account.id}/inboxes/:id' do\n    let(:inbox) { create(:inbox, account: account) }\n\n    context 'when it is an unauthenticated user' do\n      it 'returns unauthorized' do\n        patch \"/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}\"\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n    end\n\n    context 'when it is an authenticated user' do\n      let(:admin) { create(:user, account: account, role: :administrator) }\n      let(:valid_params) { { name: 'new test inbox', enable_auto_assignment: false } }\n\n      it 'will not update inbox for agent' do\n        agent = create(:user, account: account, role: :agent)\n\n        patch \"/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}\",\n              headers: agent.create_new_auth_token,\n              params: valid_params,\n              as: :json\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n\n      it 'updates inbox when administrator' do\n        patch \"/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}\",\n              headers: admin.create_new_auth_token,\n              params: valid_params,\n              as: :json\n\n        expect(response).to have_http_status(:success)\n        expect(inbox.reload.enable_auto_assignment).to be_falsey\n        expect(JSON.parse(response.body)['name']).to eq 'new test inbox'\n      end\n\n      it 'updates api inbox when administrator' do\n        api_channel = create(:channel_api, account: account)\n        api_inbox = create(:inbox, channel: api_channel, account: account)\n\n        patch \"/api/v1/accounts/#{account.id}/inboxes/#{api_inbox.id}\",\n              headers: admin.create_new_auth_token,\n              params: { enable_auto_assignment: false, channel: { webhook_url: 'webhook.test', selected_feature_flags: [] } },\n              as: :json\n\n        expect(response).to have_http_status(:success)\n        expect(api_inbox.reload.enable_auto_assignment).to be_falsey\n        expect(api_channel.reload.webhook_url).to eq('webhook.test')\n      end\n\n      it 'updates twitter inbox when administrator' do\n        api_channel = create(:channel_twitter_profile, account: account, tweets_enabled: true)\n        api_inbox = create(:inbox, channel: api_channel, account: account)\n\n        patch \"/api/v1/accounts/#{account.id}/inboxes/#{api_inbox.id}\",\n              headers: admin.create_new_auth_token,\n              params: { channel: { tweets_enabled: false } },\n              as: :json\n\n        expect(response).to have_http_status(:success)\n        expect(api_channel.reload.tweets_enabled).to eq(false)\n      end\n\n      it 'updates email inbox when administrator' do\n        email_channel = create(:channel_email, account: account)\n        email_inbox = create(:inbox, channel: email_channel, account: account)\n\n        patch \"/api/v1/accounts/#{account.id}/inboxes/#{email_inbox.id}\",\n              headers: admin.create_new_auth_token,\n              params: { enable_auto_assignment: false, channel: { email: 'emailtest@email.test' } },\n              as: :json\n\n        expect(response).to have_http_status(:success)\n        expect(email_inbox.reload.enable_auto_assignment).to be_falsey\n        expect(email_channel.reload.email).to eq('emailtest@email.test')\n      end\n\n      it 'updates email inbox with imap when administrator' do\n        email_channel = create(:channel_email, account: account)\n        email_inbox = create(:inbox, channel: email_channel, account: account)\n\n        imap_connection = double\n        allow(Mail).to receive(:connection).and_return(imap_connection)\n\n        patch \"/api/v1/accounts/#{account.id}/inboxes/#{email_inbox.id}\",\n              headers: admin.create_new_auth_token,\n              params: {\n                channel: {\n                  imap_enabled: true,\n                  imap_address: 'imap.gmail.com',\n                  imap_port: 993,\n                  imap_email: 'imaptest@gmail.com'\n                }\n              },\n              as: :json\n\n        expect(response).to have_http_status(:success)\n        expect(email_channel.reload.imap_enabled).to be true\n        expect(email_channel.reload.imap_address).to eq('imap.gmail.com')\n        expect(email_channel.reload.imap_port).to eq(993)\n      end\n\n      it 'updates email inbox with smtp when administrator' do\n        email_channel = create(:channel_email, account: account)\n        email_inbox = create(:inbox, channel: email_channel, account: account)\n\n        smtp_connection = double\n        allow(smtp_connection).to receive(:finish).and_return(true)\n        allow(Net::SMTP).to receive(:start).and_return(smtp_connection)\n\n        patch \"/api/v1/accounts/#{account.id}/inboxes/#{email_inbox.id}\",\n              headers: admin.create_new_auth_token,\n              params: {\n                channel: {\n                  smtp_enabled: true,\n                  smtp_address: 'smtp.gmail.com',\n                  smtp_port: 587,\n                  smtp_email: 'smtptest@gmail.com'\n                }\n              },\n              as: :json\n\n        expect(response).to have_http_status(:success)\n        expect(email_channel.reload.smtp_enabled).to be true\n        expect(email_channel.reload.smtp_address).to eq('smtp.gmail.com')\n        expect(email_channel.reload.smtp_port).to eq(587)\n      end\n\n      it 'updates avatar when administrator' do\n        # no avatar before upload\n        expect(inbox.avatar.attached?).to eq(false)\n        file = fixture_file_upload(Rails.root.join('spec/assets/avatar.png'), 'image/png')\n        patch \"/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}\",\n              params: valid_params.merge(avatar: file),\n              headers: admin.create_new_auth_token\n\n        expect(response).to have_http_status(:success)\n        inbox.reload\n        expect(inbox.avatar.attached?).to eq(true)\n      end\n\n      it 'updates working hours when administrator' do\n        params = {\n          working_hours: [{ 'day_of_week' => 0, 'open_hour' => 9, 'open_minutes' => 0, 'close_hour' => 17, 'close_minutes' => 0 }],\n          working_hours_enabled: true,\n          out_of_office_message: 'hello'\n        }\n        patch \"/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}\",\n              params: valid_params.merge(params),\n              headers: admin.create_new_auth_token\n\n        expect(response).to have_http_status(:success)\n        inbox.reload\n        expect(inbox.reload.weekly_schedule.find { |schedule| schedule['day_of_week'] == 0 }['open_hour']).to eq 9\n      end\n\n      it 'updates the webwidget inbox to disallow the messages after conversation is resolved' do\n        patch \"/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}\",\n              headers: admin.create_new_auth_token,\n              params: valid_params.merge({ allow_messages_after_resolved: false }),\n              as: :json\n\n        expect(response).to have_http_status(:success)\n        expect(inbox.reload.allow_messages_after_resolved).to be_falsey\n      end\n    end\n  end\n\n  describe 'GET /api/v1/accounts/{account.id}/inboxes/{inbox.id}/agent_bot' do\n    let(:inbox) { create(:inbox, account: account) }\n\n    before do\n      create(:inbox_member, user: agent, inbox: inbox)\n    end\n\n    context 'when it is an unauthenticated user' do\n      it 'returns unauthorized' do\n        get \"/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}/agent_bot\"\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n    end\n\n    context 'when it is an authenticated user' do\n      it 'returns empty when no agent bot is present' do\n        get \"/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}/agent_bot\",\n            headers: agent.create_new_auth_token,\n            as: :json\n\n        expect(response).to have_http_status(:success)\n        inbox_data = JSON.parse(response.body, symbolize_names: true)\n        expect(inbox_data[:agent_bot].blank?).to eq(true)\n      end\n\n      it 'returns the agent bot attached to the inbox' do\n        agent_bot = create(:agent_bot)\n        create(:agent_bot_inbox, agent_bot: agent_bot, inbox: inbox)\n        get \"/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}/agent_bot\",\n            headers: agent.create_new_auth_token,\n            as: :json\n\n        expect(response).to have_http_status(:success)\n        inbox_data = JSON.parse(response.body, symbolize_names: true)\n        expect(inbox_data[:agent_bot][:name]).to eq agent_bot.name\n      end\n    end\n  end\n\n  describe 'POST /api/v1/accounts/{account.id}/inboxes/:id/set_agent_bot' do\n    let(:inbox) { create(:inbox, account: account) }\n    let(:agent_bot) { create(:agent_bot) }\n\n    context 'when it is an unauthenticated user' do\n      it 'returns unauthorized' do\n        post \"/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}/set_agent_bot\"\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n    end\n\n    context 'when it is an authenticated user' do\n      let(:admin) { create(:user, account: account, role: :administrator) }\n      let(:valid_params) { { agent_bot: agent_bot.id } }\n\n      it 'sets the agent bot' do\n        post \"/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}/set_agent_bot\",\n             headers: admin.create_new_auth_token,\n             params: valid_params,\n             as: :json\n\n        expect(response).to have_http_status(:success)\n        expect(inbox.reload.agent_bot.id).to eq agent_bot.id\n      end\n\n      it 'throw error when invalid agent bot id' do\n        post \"/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}/set_agent_bot\",\n             headers: admin.create_new_auth_token,\n             params: { agent_bot: 0 },\n             as: :json\n\n        expect(response).to have_http_status(:not_found)\n      end\n\n      it 'disconnects the agent bot' do\n        post \"/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}/set_agent_bot\",\n             headers: admin.create_new_auth_token,\n             params: { agent_bot: nil },\n             as: :json\n\n        expect(response).to have_http_status(:success)\n        expect(inbox.reload.agent_bot).to be_falsey\n      end\n\n      it 'will not update agent bot when its an agent' do\n        agent = create(:user, account: account, role: :agent)\n\n        post \"/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}/set_agent_bot\",\n             headers: agent.create_new_auth_token,\n             params: valid_params,\n             as: :json\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n    end\n  end\nend\n", "require 'rails_helper'\n\nRSpec.describe '/api/v1/widget/campaigns', type: :request do\n  let(:account) { create(:account) }\n  let(:web_widget) { create(:channel_widget, account: account) }\n  let!(:campaign_1) { create(:campaign, inbox: web_widget.inbox, enabled: true, account: account) }\n  let!(:campaign_2) { create(:campaign, inbox: web_widget.inbox, enabled: false, account: account) }\n\n  describe 'GET /api/v1/widget/campaigns' do\n    let(:params) { { website_token: web_widget.website_token } }\n\n    context 'with correct website token' do\n      it 'returns the list of enabled campaigns' do\n        get '/api/v1/widget/campaigns', params: params\n\n        expect(response).to have_http_status(:success)\n        json_response = JSON.parse(response.body)\n        expect(json_response.length).to eq 1\n        expect(json_response.pluck('id')).to include(campaign_1.display_id)\n        expect(json_response.pluck('id')).not_to include(campaign_2.display_id)\n      end\n    end\n\n    context 'with invalid website token' do\n      it 'returns the list of agents' do\n        get '/api/v1/widget/campaigns', params: { website_token: '' }\n        expect(response).to have_http_status(:not_found)\n      end\n    end\n  end\nend\n", "require 'rails_helper'\ndescribe CampaignListener do\n  let(:listener) { described_class.instance }\n  let(:account) { create(:account) }\n  let(:inbox) { create(:inbox, account: account) }\n  let(:contact) { create(:contact, account: account, identifier: '123') }\n  let(:contact_inbox) { create(:contact_inbox, contact: contact, inbox: inbox) }\n  let(:campaign) { create(:campaign, inbox: inbox, account: account) }\n\n  let!(:event) do\n    Events::Base.new('campaign_triggered', Time.zone.now,\n                     contact_inbox: contact_inbox, event_info: { campaign_id: campaign.display_id })\n  end\n\n  describe '#campaign_triggered' do\n    let(:builder) { double }\n\n    before do\n      allow(Campaigns::CampaignConversationBuilder).to receive(:new).and_return(builder)\n      allow(builder).to receive(:perform)\n    end\n\n    context 'when params contain campaign id' do\n      it 'triggers campaign conversation builder' do\n        expect(Campaigns::CampaignConversationBuilder).to receive(:new)\n          .with({ contact_inbox_id: contact_inbox.id, campaign_display_id: campaign.display_id, conversation_additional_attributes: {} }).once\n        listener.campaign_triggered(event)\n      end\n    end\n\n    context 'when params does not contain campaign id' do\n      it 'does not trigger campaign conversation builder' do\n        event = Events::Base.new('campaign_triggered', Time.zone.now,\n                                 contact_inbox: contact_inbox, event_info: {})\n        expect(Campaigns::CampaignConversationBuilder).to receive(:new).exactly(0).times\n        listener.campaign_triggered(event)\n      end\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire 'rails_helper'\n\nRSpec.describe Campaign, type: :model do\n  describe 'associations' do\n    it { is_expected.to belong_to(:account) }\n    it { is_expected.to belong_to(:inbox) }\n  end\n\n  describe '.before_create' do\n    let(:campaign) { build(:campaign, display_id: nil) }\n\n    before do\n      campaign.save\n      campaign.reload\n    end\n\n    it 'runs before_create callbacks' do\n      expect(campaign.display_id).to eq(1)\n    end\n  end\n\n  context 'when Inbox other then Website or Twilio SMS' do\n    before do\n      stub_request(:post, /graph.facebook.com/)\n    end\n\n    let!(:facebook_channel) { create(:channel_facebook_page) }\n    let!(:facebook_inbox) { create(:inbox, channel: facebook_channel) }\n    let(:campaign) { build(:campaign, inbox: facebook_inbox) }\n\n    it 'would not save the campaigns' do\n      expect(campaign.save).to eq false\n      expect(campaign.errors.full_messages.first).to eq 'Inbox Unsupported Inbox type'\n    end\n  end\n\n  context 'when a campaign is completed' do\n    let!(:campaign) { create(:campaign, campaign_status: :completed) }\n\n    it 'would prevent further updates' do\n      campaign.title = 'new name'\n      expect(campaign.save).to eq false\n      expect(campaign.errors.full_messages.first).to eq 'Status The campaign is already completed'\n    end\n\n    it 'can be deleted' do\n      campaign.destroy!\n      expect(described_class.exists?(campaign.id)).to eq false\n    end\n\n    it 'cant be triggered' do\n      expect(Twilio::OneoffSmsCampaignService).not_to receive(:new).with(campaign: campaign)\n      expect(campaign.trigger!).to eq nil\n    end\n  end\n\n  describe 'ensure_correct_campaign_attributes' do\n    context 'when Twilio SMS campaign' do\n      let!(:twilio_sms) { create(:channel_twilio_sms) }\n      let!(:twilio_inbox) { create(:inbox, channel: twilio_sms) }\n      let(:campaign) { build(:campaign, inbox: twilio_inbox) }\n\n      it 'only saves campaign type as oneoff and wont leave scheduled_at empty' do\n        campaign.campaign_type = 'ongoing'\n        campaign.save!\n        expect(campaign.reload.campaign_type).to eq 'one_off'\n        expect(campaign.scheduled_at.present?).to eq true\n      end\n\n      it 'calls twilio service on trigger!' do\n        sms_service = double\n        expect(Twilio::OneoffSmsCampaignService).to receive(:new).with(campaign: campaign).and_return(sms_service)\n        expect(sms_service).to receive(:perform)\n        campaign.save!\n        campaign.trigger!\n      end\n    end\n\n    context 'when SMS campaign' do\n      let!(:sms_channel) { create(:channel_sms) }\n      let!(:sms_inbox) { create(:inbox, channel: sms_channel) }\n      let(:campaign) { build(:campaign, inbox: sms_inbox) }\n\n      it 'only saves campaign type as oneoff and wont leave scheduled_at empty' do\n        campaign.campaign_type = 'ongoing'\n        campaign.save!\n        expect(campaign.reload.campaign_type).to eq 'one_off'\n        expect(campaign.scheduled_at.present?).to eq true\n      end\n\n      it 'calls sms service on trigger!' do\n        sms_service = double\n        expect(Sms::OneoffSmsCampaignService).to receive(:new).with(campaign: campaign).and_return(sms_service)\n        expect(sms_service).to receive(:perform)\n        campaign.save!\n        campaign.trigger!\n      end\n    end\n\n    context 'when Website campaign' do\n      let(:campaign) { build(:campaign) }\n\n      it 'only saves campaign type as ongoing' do\n        campaign.campaign_type = 'one_off'\n        campaign.save!\n        expect(campaign.reload.campaign_type).to eq 'ongoing'\n      end\n    end\n  end\nend\n"], "fixing_code": ["class Api::V1::Accounts::CampaignsController < Api::V1::Accounts::BaseController\n  before_action :campaign, except: [:index, :create]\n  before_action :check_authorization\n\n  def index\n    @campaigns = Current.account.campaigns\n  end\n\n  def create\n    @campaign = Current.account.campaigns.create!(campaign_params)\n  end\n\n  def destroy\n    @campaign.destroy\n    head :ok\n  end\n\n  def show; end\n\n  def update\n    @campaign.update!(campaign_params)\n  end\n\n  private\n\n  def campaign\n    @campaign ||= Current.account.campaigns.find_by(display_id: params[:id])\n  end\n\n  def campaign_params\n    params.require(:campaign).permit(:title, :description, :message, :enabled, :trigger_only_during_business_hours, :inbox_id, :sender_id,\n                                     :scheduled_at, audience: [:type, :id], trigger_rules: {})\n  end\nend\n", "# == Schema Information\n#\n# Table name: campaigns\n#\n#  id                                 :bigint           not null, primary key\n#  audience                           :jsonb\n#  campaign_status                    :integer          default(\"active\"), not null\n#  campaign_type                      :integer          default(\"ongoing\"), not null\n#  description                        :text\n#  enabled                            :boolean          default(TRUE)\n#  message                            :text             not null\n#  scheduled_at                       :datetime\n#  title                              :string           not null\n#  trigger_only_during_business_hours :boolean          default(FALSE)\n#  trigger_rules                      :jsonb\n#  created_at                         :datetime         not null\n#  updated_at                         :datetime         not null\n#  account_id                         :bigint           not null\n#  display_id                         :integer          not null\n#  inbox_id                           :bigint           not null\n#  sender_id                          :integer\n#\n# Indexes\n#\n#  index_campaigns_on_account_id       (account_id)\n#  index_campaigns_on_campaign_status  (campaign_status)\n#  index_campaigns_on_campaign_type    (campaign_type)\n#  index_campaigns_on_inbox_id         (inbox_id)\n#  index_campaigns_on_scheduled_at     (scheduled_at)\n#\n# Foreign Keys\n#\n#  fk_rails_...  (account_id => accounts.id) ON DELETE => cascade\n#  fk_rails_...  (inbox_id => inboxes.id) ON DELETE => cascade\n#\nrequire 'uri'\nclass Campaign < ApplicationRecord\n  validates :account_id, presence: true\n  validates :inbox_id, presence: true\n  validates :title, presence: true\n  validates :message, presence: true\n  validate :validate_campaign_inbox\n  validate :validate_url\n  validate :prevent_completed_campaign_from_update, on: :update\n  belongs_to :account\n  belongs_to :inbox\n  belongs_to :sender, class_name: 'User', optional: true\n\n  enum campaign_type: { ongoing: 0, one_off: 1 }\n  # TODO : enabled attribute is unneccessary . lets move that to the campaign status with additional statuses like draft, disabled etc.\n  enum campaign_status: { active: 0, completed: 1 }\n\n  has_many :conversations, dependent: :nullify, autosave: true\n\n  before_validation :ensure_correct_campaign_attributes\n  after_commit :set_display_id, unless: :display_id?\n\n  def trigger!\n    return unless one_off?\n    return if completed?\n\n    Twilio::OneoffSmsCampaignService.new(campaign: self).perform if inbox.inbox_type == 'Twilio SMS'\n    Sms::OneoffSmsCampaignService.new(campaign: self).perform if inbox.inbox_type == 'Sms'\n  end\n\n  private\n\n  def set_display_id\n    reload\n  end\n\n  def validate_campaign_inbox\n    return unless inbox\n\n    errors.add :inbox, 'Unsupported Inbox type' unless ['Website', 'Twilio SMS', 'Sms'].include? inbox.inbox_type\n  end\n\n  # TO-DO we clean up with better validations when campaigns evolve into more inboxes\n  def ensure_correct_campaign_attributes\n    return if inbox.blank?\n\n    if ['Twilio SMS', 'Sms'].include?(inbox.inbox_type)\n      self.campaign_type = 'one_off'\n      self.scheduled_at ||= Time.now.utc\n    else\n      self.campaign_type = 'ongoing'\n      self.scheduled_at = nil\n    end\n  end\n\n  def validate_url\n    return unless trigger_rules['url']\n\n    errors.add(:url, 'invalid') if inbox.inbox_type == 'Website' && !url_valid?(trigger_rules['url'])\n  end\n\n  def url_valid?(url)\n    url = begin\n      URI.parse(url)\n    rescue StandardError\n      false\n    end\n    url.is_a?(URI::HTTP) || url.is_a?(URI::HTTPS)\n  end\n\n  def prevent_completed_campaign_from_update\n    errors.add :status, 'The campaign is already completed' if !campaign_status_changed? && completed?\n  end\n\n  # creating db triggers\n  trigger.before(:insert).for_each(:row) do\n    \"NEW.display_id := nextval('camp_dpid_seq_' || NEW.account_id);\"\n  end\nend\n", "require 'rails_helper'\n\ndescribe ::Campaigns::CampaignConversationBuilder do\n  let(:account) { create(:account) }\n  let(:inbox) { create(:inbox, account: account) }\n  let(:contact) { create(:contact, account: account, identifier: '123') }\n  let(:contact_inbox) { create(:contact_inbox, contact: contact, inbox: inbox) }\n  let(:campaign) { create(:campaign, inbox: inbox, account: account, trigger_rules: { url: 'https://test.com' }) }\n\n  describe '#perform' do\n    it 'creates a conversation with campaign id and message with campaign message' do\n      campaign_conversation = described_class.new(\n        contact_inbox_id: contact_inbox.id,\n        campaign_display_id: campaign.display_id\n      ).perform\n\n      expect(campaign_conversation.campaign_id).to eq(campaign.id)\n      expect(campaign_conversation.messages.first.content).to eq(campaign.message)\n    end\n\n    it 'will not create a conversation with campaign id if another conversation exists' do\n      create(:conversation, contact_inbox_id: contact_inbox.id, inbox: inbox, account: account)\n      campaign_conversation = described_class.new(\n        contact_inbox_id: contact_inbox.id,\n        campaign_display_id: campaign.display_id\n      ).perform\n\n      expect(campaign_conversation).to eq(nil)\n    end\n  end\nend\n", "require 'rails_helper'\n\nRSpec.describe 'Campaigns API', type: :request do\n  let(:account) { create(:account) }\n\n  describe 'GET /api/v1/accounts/{account.id}/campaigns' do\n    context 'when it is an unauthenticated user' do\n      it 'returns unauthorized' do\n        get \"/api/v1/accounts/#{account.id}/campaigns\"\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n    end\n\n    context 'when it is an authenticated user' do\n      let(:agent) { create(:user, account: account, role: :agent) }\n      let(:administrator) { create(:user, account: account, role: :administrator) }\n      let!(:campaign) { create(:campaign, account: account, trigger_rules: { url: 'https://test.com' }) }\n\n      it 'returns unauthorized for agents' do\n        get \"/api/v1/accounts/#{account.id}/campaigns\",\n            headers: agent.create_new_auth_token,\n            as: :json\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n\n      it 'returns all campaigns to administrators' do\n        get \"/api/v1/accounts/#{account.id}/campaigns\",\n            headers: administrator.create_new_auth_token,\n            as: :json\n\n        expect(response).to have_http_status(:success)\n        body = JSON.parse(response.body, symbolize_names: true)\n        expect(body.first[:id]).to eq(campaign.display_id)\n      end\n    end\n  end\n\n  describe 'GET /api/v1/accounts/{account.id}/campaigns/:id' do\n    let(:campaign) { create(:campaign, account: account, trigger_rules: { url: 'https://test.com' }) }\n\n    context 'when it is an unauthenticated user' do\n      it 'returns unauthorized' do\n        get \"/api/v1/accounts/#{account.id}/campaigns/#{campaign.display_id}\"\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n    end\n\n    context 'when it is an authenticated user' do\n      let(:agent) { create(:user, account: account, role: :agent) }\n      let(:administrator) { create(:user, account: account, role: :administrator) }\n\n      it 'returns unauthorized for agents' do\n        get \"/api/v1/accounts/#{account.id}/campaigns/#{campaign.display_id}\",\n            headers: agent.create_new_auth_token,\n            as: :json\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n\n      it 'shows the campaign for administrators' do\n        get \"/api/v1/accounts/#{account.id}/campaigns/#{campaign.display_id}\",\n            headers: administrator.create_new_auth_token,\n            as: :json\n\n        expect(response).to have_http_status(:success)\n        expect(JSON.parse(response.body, symbolize_names: true)[:id]).to eq(campaign.display_id)\n      end\n    end\n  end\n\n  describe 'POST /api/v1/accounts/{account.id}/campaigns' do\n    let(:inbox) { create(:inbox, account: account) }\n\n    context 'when it is an unauthenticated user' do\n      it 'returns unauthorized' do\n        post \"/api/v1/accounts/#{account.id}/campaigns\",\n             params: { inbox_id: inbox.id, title: 'test', message: 'test message' },\n             as: :json\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n    end\n\n    context 'when it is an authenticated user' do\n      let(:agent) { create(:user, account: account, role: :agent) }\n      let(:administrator) { create(:user, account: account, role: :administrator) }\n\n      it 'returns unauthorized for agents' do\n        post \"/api/v1/accounts/#{account.id}/campaigns\",\n             params: { inbox_id: inbox.id, title: 'test', message: 'test message' },\n             headers: agent.create_new_auth_token,\n             as: :json\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n\n      it 'creates a new campaign' do\n        post \"/api/v1/accounts/#{account.id}/campaigns\",\n             params: { inbox_id: inbox.id, title: 'test', message: 'test message' },\n             headers: administrator.create_new_auth_token,\n             as: :json\n\n        expect(response).to have_http_status(:success)\n        expect(JSON.parse(response.body, symbolize_names: true)[:title]).to eq('test')\n      end\n\n      it 'creates a new ongoing campaign' do\n        post \"/api/v1/accounts/#{account.id}/campaigns\",\n             params: { inbox_id: inbox.id, title: 'test', message: 'test message', trigger_rules: { url: 'https://test.com' } },\n             headers: administrator.create_new_auth_token,\n             as: :json\n\n        expect(response).to have_http_status(:success)\n        expect(JSON.parse(response.body, symbolize_names: true)[:title]).to eq('test')\n      end\n\n      it 'throws error when invalid url provided for ongoing campaign' do\n        post \"/api/v1/accounts/#{account.id}/campaigns\",\n             params: { inbox_id: inbox.id, title: 'test', message: 'test message', trigger_rules: { url: 'javascript' } },\n             headers: administrator.create_new_auth_token,\n             as: :json\n\n        expect(response).to have_http_status(:unprocessable_entity)\n      end\n\n      it 'creates a new oneoff campaign' do\n        twilio_sms = create(:channel_twilio_sms, account: account)\n        twilio_inbox = create(:inbox, channel: twilio_sms)\n        label1 = create(:label, account: account)\n        label2 = create(:label, account: account)\n\n        post \"/api/v1/accounts/#{account.id}/campaigns\",\n             params: {\n               inbox_id: twilio_inbox.id, title: 'test', message: 'test message',\n               scheduled_at: 2.days.from_now,\n               audience: [{ type: 'Label', id: label1.id }, { type: 'Label', id: label2.id }]\n             },\n             headers: administrator.create_new_auth_token,\n             as: :json\n\n        expect(response).to have_http_status(:success)\n        response_data = JSON.parse(response.body, symbolize_names: true)\n        expect(response_data[:campaign_type]).to eq('one_off')\n        expect(response_data[:scheduled_at].present?).to eq true\n        expect(response_data[:audience].pluck(:id)).to include(label1.id, label2.id)\n      end\n    end\n  end\n\n  describe 'PATCH /api/v1/accounts/{account.id}/campaigns/:id' do\n    let(:inbox) { create(:inbox, account: account) }\n    let!(:campaign) { create(:campaign, account: account, trigger_rules: { url: 'https://test.com' }) }\n\n    context 'when it is an unauthenticated user' do\n      it 'returns unauthorized' do\n        patch \"/api/v1/accounts/#{account.id}/campaigns/#{campaign.display_id}\",\n              params: { inbox_id: inbox.id, title: 'test', message: 'test message' },\n              as: :json\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n    end\n\n    context 'when it is an authenticated user' do\n      let(:agent) { create(:user, account: account, role: :agent) }\n      let(:administrator) { create(:user, account: account, role: :administrator) }\n\n      it 'returns unauthorized for agents' do\n        patch \"/api/v1/accounts/#{account.id}/campaigns/#{campaign.display_id}\",\n              params: { inbox_id: inbox.id, title: 'test', message: 'test message' },\n              headers: agent.create_new_auth_token,\n              as: :json\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n\n      it 'updates the campaign' do\n        patch \"/api/v1/accounts/#{account.id}/campaigns/#{campaign.display_id}\",\n              params: { inbox_id: inbox.id, title: 'test', message: 'test message' },\n              headers: administrator.create_new_auth_token,\n              as: :json\n\n        expect(response).to have_http_status(:success)\n        expect(JSON.parse(response.body, symbolize_names: true)[:title]).to eq('test')\n      end\n    end\n  end\n\n  describe 'DELETE /api/v1/accounts/{account.id}/campaigns/:id' do\n    let(:inbox) { create(:inbox, account: account) }\n    let!(:campaign) { create(:campaign, account: account, trigger_rules: { url: 'https://test.com' }) }\n\n    context 'when it is an unauthenticated user' do\n      it 'returns unauthorized' do\n        delete \"/api/v1/accounts/#{account.id}/campaigns/#{campaign.display_id}\",\n               as: :json\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n    end\n\n    context 'when it is an authenticated user' do\n      let(:agent) { create(:user, account: account, role: :agent) }\n      let(:administrator) { create(:user, account: account, role: :administrator) }\n\n      it 'return unauthorized if agent' do\n        delete \"/api/v1/accounts/#{account.id}/campaigns/#{campaign.display_id}\",\n               headers: agent.create_new_auth_token,\n               as: :json\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n\n      it 'delete campaign if admin' do\n        delete \"/api/v1/accounts/#{account.id}/campaigns/#{campaign.display_id}\",\n               headers: administrator.create_new_auth_token,\n               as: :json\n\n        expect(response).to have_http_status(:success)\n        expect(::Campaign.exists?(campaign.display_id)).to eq false\n      end\n    end\n  end\nend\n", "require 'rails_helper'\n\nRSpec.describe 'Inboxes API', type: :request do\n  let(:account) { create(:account) }\n  let(:agent) { create(:user, account: account, role: :agent) }\n  let(:admin) { create(:user, account: account, role: :administrator) }\n\n  describe 'GET /api/v1/accounts/{account.id}/inboxes' do\n    context 'when it is an unauthenticated user' do\n      it 'returns unauthorized' do\n        get \"/api/v1/accounts/#{account.id}/inboxes\"\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n    end\n\n    context 'when it is an authenticated user' do\n      let(:agent) { create(:user, account: account, role: :agent) }\n      let(:admin) { create(:user, account: account, role: :administrator) }\n      let(:inbox) { create(:inbox, account: account) }\n\n      before do\n        create(:inbox, account: account)\n        create(:inbox_member, user: agent, inbox: inbox)\n      end\n\n      it 'returns all inboxes of current_account as administrator' do\n        get \"/api/v1/accounts/#{account.id}/inboxes\",\n            headers: admin.create_new_auth_token,\n            as: :json\n\n        expect(response).to have_http_status(:success)\n        expect(JSON.parse(response.body, symbolize_names: true)[:payload].size).to eq(2)\n      end\n\n      it 'returns only assigned inboxes of current_account as agent' do\n        get \"/api/v1/accounts/#{account.id}/inboxes\",\n            headers: agent.create_new_auth_token,\n            as: :json\n\n        expect(response).to have_http_status(:success)\n        expect(JSON.parse(response.body, symbolize_names: true)[:payload].size).to eq(1)\n      end\n    end\n  end\n\n  describe 'GET /api/v1/accounts/{account.id}/inboxes/{inbox.id}' do\n    let(:inbox) { create(:inbox, account: account) }\n\n    context 'when it is an unauthenticated user' do\n      it 'returns unauthorized' do\n        get \"/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}\"\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n    end\n\n    context 'when it is an authenticated user' do\n      let(:agent) { create(:user, account: account, role: :agent) }\n      let(:admin) { create(:user, account: account, role: :administrator) }\n      let(:inbox) { create(:inbox, account: account) }\n\n      it 'returns unauthorized for an agent who is not assigned' do\n        get \"/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}\",\n            headers: agent.create_new_auth_token,\n            as: :json\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n\n      it 'returns the inbox if administrator' do\n        get \"/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}\",\n            headers: admin.create_new_auth_token,\n            as: :json\n\n        expect(response).to have_http_status(:success)\n        expect(JSON.parse(response.body, symbolize_names: true)[:id]).to eq(inbox.id)\n      end\n\n      it 'returns the inbox if assigned inbox is assigned as agent' do\n        create(:inbox_member, user: agent, inbox: inbox)\n        get \"/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}\",\n            headers: agent.create_new_auth_token,\n            as: :json\n\n        expect(response).to have_http_status(:success)\n        expect(JSON.parse(response.body, symbolize_names: true)[:id]).to eq(inbox.id)\n      end\n    end\n  end\n\n  describe 'GET /api/v1/accounts/{account.id}/inboxes/{inbox.id}/assignable_agents' do\n    let(:inbox) { create(:inbox, account: account) }\n\n    context 'when it is an unauthenticated user' do\n      it 'returns unauthorized' do\n        get \"/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}/assignable_agents\"\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n    end\n\n    context 'when it is an authenticated user' do\n      before do\n        create(:inbox_member, user: agent, inbox: inbox)\n      end\n\n      it 'returns all assignable inbox members along with administrators' do\n        get \"/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}/assignable_agents\",\n            headers: admin.create_new_auth_token,\n            as: :json\n\n        expect(response).to have_http_status(:success)\n        response_data = JSON.parse(response.body, symbolize_names: true)[:payload]\n        expect(response_data.size).to eq(2)\n        expect(response_data.pluck(:role)).to include('agent', 'administrator')\n      end\n    end\n  end\n\n  describe 'GET /api/v1/accounts/{account.id}/inboxes/{inbox.id}/campaigns' do\n    let(:inbox) { create(:inbox, account: account) }\n\n    context 'when it is an unauthenticated user' do\n      it 'returns unauthorized' do\n        get \"/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}/campaigns\"\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n    end\n\n    context 'when it is an authenticated user' do\n      let(:agent) { create(:user, account: account, role: :agent) }\n      let(:administrator) { create(:user, account: account, role: :administrator) }\n\n      let!(:campaign) { create(:campaign, account: account, inbox: inbox, trigger_rules: { url: 'https://test.com' }) }\n\n      it 'returns unauthorized for agents' do\n        get \"/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}/campaigns\",\n            headers: agent.create_new_auth_token,\n            as: :json\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n\n      it 'returns all campaigns belonging to the inbox to administrators' do\n        # create a random campaign\n        create(:campaign, account: account, trigger_rules: { url: 'https://test.com' })\n        get \"/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}/campaigns\",\n            headers: administrator.create_new_auth_token,\n            as: :json\n\n        expect(response).to have_http_status(:success)\n        body = JSON.parse(response.body, symbolize_names: true)\n        expect(body.first[:id]).to eq(campaign.display_id)\n        expect(body.length).to eq(1)\n      end\n    end\n  end\n\n  describe 'DELETE /api/v1/accounts/{account.id}/inboxes/{inbox.id}/avatar' do\n    let(:inbox) { create(:inbox, account: account) }\n\n    context 'when it is an unauthenticated user' do\n      it 'returns unauthorized' do\n        delete \"/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}/avatar\"\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n    end\n\n    context 'when it is an authenticated user' do\n      before do\n        create(:inbox_member, user: agent, inbox: inbox)\n        inbox.avatar.attach(io: File.open(Rails.root.join('spec/assets/avatar.png')), filename: 'avatar.png', content_type: 'image/png')\n      end\n\n      it 'delete inbox avatar for administrator user' do\n        delete \"/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}/avatar\",\n               headers: admin.create_new_auth_token,\n               as: :json\n\n        expect { inbox.avatar.attachment.reload }.to raise_error(ActiveRecord::RecordNotFound)\n        expect(response).to have_http_status(:success)\n      end\n\n      it 'returns unauthorized for agent user' do\n        delete \"/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}/avatar\",\n               headers: agent.create_new_auth_token,\n               as: :json\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n    end\n  end\n\n  describe 'DELETE /api/v1/accounts/{account.id}/inboxes/:id' do\n    let(:inbox) { create(:inbox, account: account) }\n\n    context 'when it is an unauthenticated user' do\n      it 'returns unauthorized' do\n        delete \"/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}\"\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n    end\n\n    context 'when it is an authenticated user' do\n      let(:admin) { create(:user, account: account, role: :administrator) }\n\n      it 'deletes inbox' do\n        delete \"/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}\",\n               headers: admin.create_new_auth_token,\n               as: :json\n\n        expect(response).to have_http_status(:success)\n        expect { inbox.reload }.to raise_exception(ActiveRecord::RecordNotFound)\n      end\n\n      it 'is unable to delete inbox of another account' do\n        other_account = create(:account)\n        other_inbox = create(:inbox, account: other_account)\n\n        delete \"/api/v1/accounts/#{account.id}/inboxes/#{other_inbox.id}\",\n               headers: admin.create_new_auth_token,\n               as: :json\n\n        expect(response).to have_http_status(:not_found)\n      end\n\n      it 'is unable to delete inbox as agent' do\n        agent = create(:user, account: account, role: :agent)\n\n        delete \"/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}\",\n               headers: agent.create_new_auth_token,\n               as: :json\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n    end\n  end\n\n  describe 'POST /api/v1/accounts/{account.id}/inboxes' do\n    let(:inbox) { create(:inbox, account: account) }\n\n    context 'when it is an unauthenticated user' do\n      it 'returns unauthorized' do\n        post \"/api/v1/accounts/#{account.id}/inboxes\"\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n    end\n\n    context 'when it is an authenticated user' do\n      let(:admin) { create(:user, account: account, role: :administrator) }\n      let(:valid_params) { { name: 'test', channel: { type: 'web_widget', website_url: 'test.com' } } }\n\n      it 'will not create inbox for agent' do\n        agent = create(:user, account: account, role: :agent)\n\n        post \"/api/v1/accounts/#{account.id}/inboxes\",\n             headers: agent.create_new_auth_token,\n             params: valid_params,\n             as: :json\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n\n      it 'creates a webwidget inbox when administrator' do\n        post \"/api/v1/accounts/#{account.id}/inboxes\",\n             headers: admin.create_new_auth_token,\n             params: valid_params,\n             as: :json\n\n        expect(response).to have_http_status(:success)\n        expect(response.body).to include('test.com')\n      end\n\n      it 'creates a email inbox when administrator' do\n        post \"/api/v1/accounts/#{account.id}/inboxes\",\n             headers: admin.create_new_auth_token,\n             params: { name: 'test', channel: { type: 'email', email: 'test@test.com' } },\n             as: :json\n\n        expect(response).to have_http_status(:success)\n        expect(response.body).to include('test@test.com')\n      end\n\n      it 'creates an api inbox when administrator' do\n        post \"/api/v1/accounts/#{account.id}/inboxes\",\n             headers: admin.create_new_auth_token,\n             params: { name: 'API Inbox', channel: { type: 'api', webhook_url: 'http://test.com' } },\n             as: :json\n\n        expect(response).to have_http_status(:success)\n        expect(response.body).to include('API Inbox')\n      end\n\n      it 'creates a line inbox when administrator' do\n        post \"/api/v1/accounts/#{account.id}/inboxes\",\n             headers: admin.create_new_auth_token,\n             params: { name: 'Line Inbox',\n                       channel: { type: 'line', line_channel_id: SecureRandom.uuid, line_channel_secret: SecureRandom.uuid,\n                                  line_channel_token: SecureRandom.uuid } },\n             as: :json\n\n        expect(response).to have_http_status(:success)\n        expect(response.body).to include('Line Inbox')\n        expect(response.body).to include('callback_webhook_url')\n      end\n\n      it 'creates a sms inbox when administrator' do\n        post \"/api/v1/accounts/#{account.id}/inboxes\",\n             headers: admin.create_new_auth_token,\n             params: { name: 'Sms Inbox',\n                       channel: { type: 'sms', phone_number: '+123456789', provider_config: { test: 'test' } } },\n             as: :json\n\n        expect(response).to have_http_status(:success)\n        expect(response.body).to include('Sms Inbox')\n        expect(response.body).to include('+123456789')\n      end\n\n      it 'creates the webwidget inbox that allow messages after conversation is resolved' do\n        post \"/api/v1/accounts/#{account.id}/inboxes\",\n             headers: admin.create_new_auth_token,\n             params: valid_params,\n             as: :json\n\n        expect(response).to have_http_status(:success)\n        json_response = JSON.parse(response.body)\n        expect(json_response['allow_messages_after_resolved']).to be true\n      end\n    end\n  end\n\n  describe 'PATCH /api/v1/accounts/{account.id}/inboxes/:id' do\n    let(:inbox) { create(:inbox, account: account) }\n\n    context 'when it is an unauthenticated user' do\n      it 'returns unauthorized' do\n        patch \"/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}\"\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n    end\n\n    context 'when it is an authenticated user' do\n      let(:admin) { create(:user, account: account, role: :administrator) }\n      let(:valid_params) { { name: 'new test inbox', enable_auto_assignment: false } }\n\n      it 'will not update inbox for agent' do\n        agent = create(:user, account: account, role: :agent)\n\n        patch \"/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}\",\n              headers: agent.create_new_auth_token,\n              params: valid_params,\n              as: :json\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n\n      it 'updates inbox when administrator' do\n        patch \"/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}\",\n              headers: admin.create_new_auth_token,\n              params: valid_params,\n              as: :json\n\n        expect(response).to have_http_status(:success)\n        expect(inbox.reload.enable_auto_assignment).to be_falsey\n        expect(JSON.parse(response.body)['name']).to eq 'new test inbox'\n      end\n\n      it 'updates api inbox when administrator' do\n        api_channel = create(:channel_api, account: account)\n        api_inbox = create(:inbox, channel: api_channel, account: account)\n\n        patch \"/api/v1/accounts/#{account.id}/inboxes/#{api_inbox.id}\",\n              headers: admin.create_new_auth_token,\n              params: { enable_auto_assignment: false, channel: { webhook_url: 'webhook.test', selected_feature_flags: [] } },\n              as: :json\n\n        expect(response).to have_http_status(:success)\n        expect(api_inbox.reload.enable_auto_assignment).to be_falsey\n        expect(api_channel.reload.webhook_url).to eq('webhook.test')\n      end\n\n      it 'updates twitter inbox when administrator' do\n        api_channel = create(:channel_twitter_profile, account: account, tweets_enabled: true)\n        api_inbox = create(:inbox, channel: api_channel, account: account)\n\n        patch \"/api/v1/accounts/#{account.id}/inboxes/#{api_inbox.id}\",\n              headers: admin.create_new_auth_token,\n              params: { channel: { tweets_enabled: false } },\n              as: :json\n\n        expect(response).to have_http_status(:success)\n        expect(api_channel.reload.tweets_enabled).to eq(false)\n      end\n\n      it 'updates email inbox when administrator' do\n        email_channel = create(:channel_email, account: account)\n        email_inbox = create(:inbox, channel: email_channel, account: account)\n\n        patch \"/api/v1/accounts/#{account.id}/inboxes/#{email_inbox.id}\",\n              headers: admin.create_new_auth_token,\n              params: { enable_auto_assignment: false, channel: { email: 'emailtest@email.test' } },\n              as: :json\n\n        expect(response).to have_http_status(:success)\n        expect(email_inbox.reload.enable_auto_assignment).to be_falsey\n        expect(email_channel.reload.email).to eq('emailtest@email.test')\n      end\n\n      it 'updates email inbox with imap when administrator' do\n        email_channel = create(:channel_email, account: account)\n        email_inbox = create(:inbox, channel: email_channel, account: account)\n\n        imap_connection = double\n        allow(Mail).to receive(:connection).and_return(imap_connection)\n\n        patch \"/api/v1/accounts/#{account.id}/inboxes/#{email_inbox.id}\",\n              headers: admin.create_new_auth_token,\n              params: {\n                channel: {\n                  imap_enabled: true,\n                  imap_address: 'imap.gmail.com',\n                  imap_port: 993,\n                  imap_email: 'imaptest@gmail.com'\n                }\n              },\n              as: :json\n\n        expect(response).to have_http_status(:success)\n        expect(email_channel.reload.imap_enabled).to be true\n        expect(email_channel.reload.imap_address).to eq('imap.gmail.com')\n        expect(email_channel.reload.imap_port).to eq(993)\n      end\n\n      it 'updates email inbox with smtp when administrator' do\n        email_channel = create(:channel_email, account: account)\n        email_inbox = create(:inbox, channel: email_channel, account: account)\n\n        smtp_connection = double\n        allow(smtp_connection).to receive(:finish).and_return(true)\n        allow(Net::SMTP).to receive(:start).and_return(smtp_connection)\n\n        patch \"/api/v1/accounts/#{account.id}/inboxes/#{email_inbox.id}\",\n              headers: admin.create_new_auth_token,\n              params: {\n                channel: {\n                  smtp_enabled: true,\n                  smtp_address: 'smtp.gmail.com',\n                  smtp_port: 587,\n                  smtp_email: 'smtptest@gmail.com'\n                }\n              },\n              as: :json\n\n        expect(response).to have_http_status(:success)\n        expect(email_channel.reload.smtp_enabled).to be true\n        expect(email_channel.reload.smtp_address).to eq('smtp.gmail.com')\n        expect(email_channel.reload.smtp_port).to eq(587)\n      end\n\n      it 'updates avatar when administrator' do\n        # no avatar before upload\n        expect(inbox.avatar.attached?).to eq(false)\n        file = fixture_file_upload(Rails.root.join('spec/assets/avatar.png'), 'image/png')\n        patch \"/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}\",\n              params: valid_params.merge(avatar: file),\n              headers: admin.create_new_auth_token\n\n        expect(response).to have_http_status(:success)\n        inbox.reload\n        expect(inbox.avatar.attached?).to eq(true)\n      end\n\n      it 'updates working hours when administrator' do\n        params = {\n          working_hours: [{ 'day_of_week' => 0, 'open_hour' => 9, 'open_minutes' => 0, 'close_hour' => 17, 'close_minutes' => 0 }],\n          working_hours_enabled: true,\n          out_of_office_message: 'hello'\n        }\n        patch \"/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}\",\n              params: valid_params.merge(params),\n              headers: admin.create_new_auth_token\n\n        expect(response).to have_http_status(:success)\n        inbox.reload\n        expect(inbox.reload.weekly_schedule.find { |schedule| schedule['day_of_week'] == 0 }['open_hour']).to eq 9\n      end\n\n      it 'updates the webwidget inbox to disallow the messages after conversation is resolved' do\n        patch \"/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}\",\n              headers: admin.create_new_auth_token,\n              params: valid_params.merge({ allow_messages_after_resolved: false }),\n              as: :json\n\n        expect(response).to have_http_status(:success)\n        expect(inbox.reload.allow_messages_after_resolved).to be_falsey\n      end\n    end\n  end\n\n  describe 'GET /api/v1/accounts/{account.id}/inboxes/{inbox.id}/agent_bot' do\n    let(:inbox) { create(:inbox, account: account) }\n\n    before do\n      create(:inbox_member, user: agent, inbox: inbox)\n    end\n\n    context 'when it is an unauthenticated user' do\n      it 'returns unauthorized' do\n        get \"/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}/agent_bot\"\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n    end\n\n    context 'when it is an authenticated user' do\n      it 'returns empty when no agent bot is present' do\n        get \"/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}/agent_bot\",\n            headers: agent.create_new_auth_token,\n            as: :json\n\n        expect(response).to have_http_status(:success)\n        inbox_data = JSON.parse(response.body, symbolize_names: true)\n        expect(inbox_data[:agent_bot].blank?).to eq(true)\n      end\n\n      it 'returns the agent bot attached to the inbox' do\n        agent_bot = create(:agent_bot)\n        create(:agent_bot_inbox, agent_bot: agent_bot, inbox: inbox)\n        get \"/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}/agent_bot\",\n            headers: agent.create_new_auth_token,\n            as: :json\n\n        expect(response).to have_http_status(:success)\n        inbox_data = JSON.parse(response.body, symbolize_names: true)\n        expect(inbox_data[:agent_bot][:name]).to eq agent_bot.name\n      end\n    end\n  end\n\n  describe 'POST /api/v1/accounts/{account.id}/inboxes/:id/set_agent_bot' do\n    let(:inbox) { create(:inbox, account: account) }\n    let(:agent_bot) { create(:agent_bot) }\n\n    context 'when it is an unauthenticated user' do\n      it 'returns unauthorized' do\n        post \"/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}/set_agent_bot\"\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n    end\n\n    context 'when it is an authenticated user' do\n      let(:admin) { create(:user, account: account, role: :administrator) }\n      let(:valid_params) { { agent_bot: agent_bot.id } }\n\n      it 'sets the agent bot' do\n        post \"/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}/set_agent_bot\",\n             headers: admin.create_new_auth_token,\n             params: valid_params,\n             as: :json\n\n        expect(response).to have_http_status(:success)\n        expect(inbox.reload.agent_bot.id).to eq agent_bot.id\n      end\n\n      it 'throw error when invalid agent bot id' do\n        post \"/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}/set_agent_bot\",\n             headers: admin.create_new_auth_token,\n             params: { agent_bot: 0 },\n             as: :json\n\n        expect(response).to have_http_status(:not_found)\n      end\n\n      it 'disconnects the agent bot' do\n        post \"/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}/set_agent_bot\",\n             headers: admin.create_new_auth_token,\n             params: { agent_bot: nil },\n             as: :json\n\n        expect(response).to have_http_status(:success)\n        expect(inbox.reload.agent_bot).to be_falsey\n      end\n\n      it 'will not update agent bot when its an agent' do\n        agent = create(:user, account: account, role: :agent)\n\n        post \"/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}/set_agent_bot\",\n             headers: agent.create_new_auth_token,\n             params: valid_params,\n             as: :json\n\n        expect(response).to have_http_status(:unauthorized)\n      end\n    end\n  end\nend\n", "require 'rails_helper'\n\nRSpec.describe '/api/v1/widget/campaigns', type: :request do\n  let(:account) { create(:account) }\n  let(:web_widget) { create(:channel_widget, account: account) }\n  let!(:campaign_1) { create(:campaign, inbox: web_widget.inbox, enabled: true, account: account, trigger_rules: { url: 'https://test.com' }) }\n  let!(:campaign_2) { create(:campaign, inbox: web_widget.inbox, enabled: false, account: account, trigger_rules: { url: 'https://test.com' }) }\n\n  describe 'GET /api/v1/widget/campaigns' do\n    let(:params) { { website_token: web_widget.website_token } }\n\n    context 'with correct website token' do\n      it 'returns the list of enabled campaigns' do\n        get '/api/v1/widget/campaigns', params: params\n\n        expect(response).to have_http_status(:success)\n        json_response = JSON.parse(response.body)\n        expect(json_response.length).to eq 1\n        expect(json_response.pluck('id')).to include(campaign_1.display_id)\n        expect(json_response.pluck('id')).not_to include(campaign_2.display_id)\n      end\n    end\n\n    context 'with invalid website token' do\n      it 'returns the list of agents' do\n        get '/api/v1/widget/campaigns', params: { website_token: '' }\n        expect(response).to have_http_status(:not_found)\n      end\n    end\n  end\nend\n", "require 'rails_helper'\ndescribe CampaignListener do\n  let(:listener) { described_class.instance }\n  let(:account) { create(:account) }\n  let(:inbox) { create(:inbox, account: account) }\n  let(:contact) { create(:contact, account: account, identifier: '123') }\n  let(:contact_inbox) { create(:contact_inbox, contact: contact, inbox: inbox) }\n  let(:campaign) { create(:campaign, inbox: inbox, account: account, trigger_rules: { url: 'https://test.com' }) }\n\n  let!(:event) do\n    Events::Base.new('campaign_triggered', Time.zone.now,\n                     contact_inbox: contact_inbox, event_info: { campaign_id: campaign.display_id })\n  end\n\n  describe '#campaign_triggered' do\n    let(:builder) { double }\n\n    before do\n      allow(Campaigns::CampaignConversationBuilder).to receive(:new).and_return(builder)\n      allow(builder).to receive(:perform)\n    end\n\n    context 'when params contain campaign id' do\n      it 'triggers campaign conversation builder' do\n        expect(Campaigns::CampaignConversationBuilder).to receive(:new)\n          .with({ contact_inbox_id: contact_inbox.id, campaign_display_id: campaign.display_id, conversation_additional_attributes: {} }).once\n        listener.campaign_triggered(event)\n      end\n    end\n\n    context 'when params does not contain campaign id' do\n      it 'does not trigger campaign conversation builder' do\n        event = Events::Base.new('campaign_triggered', Time.zone.now,\n                                 contact_inbox: contact_inbox, event_info: {})\n        expect(Campaigns::CampaignConversationBuilder).to receive(:new).exactly(0).times\n        listener.campaign_triggered(event)\n      end\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire 'rails_helper'\n\nRSpec.describe Campaign, type: :model do\n  describe 'associations' do\n    it { is_expected.to belong_to(:account) }\n    it { is_expected.to belong_to(:inbox) }\n  end\n\n  describe '.before_create' do\n    let(:account) { create(:account) }\n    let(:website_channel) { create(:channel_widget, account: account) }\n    let(:website_inbox) { create(:inbox, channel: website_channel, account: account) }\n    let(:campaign) { build(:campaign, inbox: website_inbox, display_id: nil, trigger_rules: { url: 'https://test.com' }) }\n\n    before do\n      campaign.save\n      campaign.reload\n    end\n\n    it 'runs before_create callbacks' do\n      expect(campaign.display_id).to eq(1)\n    end\n  end\n\n  context 'when Inbox other then Website or Twilio SMS' do\n    before do\n      stub_request(:post, /graph.facebook.com/)\n    end\n\n    let!(:facebook_channel) { create(:channel_facebook_page) }\n    let!(:facebook_inbox) { create(:inbox, channel: facebook_channel) }\n    let(:campaign) { build(:campaign, inbox: facebook_inbox) }\n\n    it 'would not save the campaigns' do\n      expect(campaign.save).to eq false\n      expect(campaign.errors.full_messages.first).to eq 'Inbox Unsupported Inbox type'\n    end\n  end\n\n  context 'when a campaign is completed' do\n    let(:account) { create(:account) }\n    let(:web_widget) { create(:channel_widget, account: account) }\n    let!(:campaign) { create(:campaign, inbox: web_widget.inbox, campaign_status: :completed, trigger_rules: { url: 'https://test.com' }) }\n\n    it 'would prevent further updates' do\n      campaign.title = 'new name'\n      expect(campaign.save).to eq false\n      expect(campaign.errors.full_messages.first).to eq 'Status The campaign is already completed'\n    end\n\n    it 'can be deleted' do\n      campaign.destroy!\n      expect(described_class.exists?(campaign.id)).to eq false\n    end\n\n    it 'cant be triggered' do\n      expect(Twilio::OneoffSmsCampaignService).not_to receive(:new).with(campaign: campaign)\n      expect(campaign.trigger!).to eq nil\n    end\n  end\n\n  describe 'ensure_correct_campaign_attributes' do\n    context 'when Twilio SMS campaign' do\n      let!(:twilio_sms) { create(:channel_twilio_sms) }\n      let!(:twilio_inbox) { create(:inbox, channel: twilio_sms) }\n      let(:campaign) { build(:campaign, inbox: twilio_inbox) }\n\n      it 'only saves campaign type as oneoff and wont leave scheduled_at empty' do\n        campaign.campaign_type = 'ongoing'\n        campaign.save!\n        expect(campaign.reload.campaign_type).to eq 'one_off'\n        expect(campaign.scheduled_at.present?).to eq true\n      end\n\n      it 'calls twilio service on trigger!' do\n        sms_service = double\n        expect(Twilio::OneoffSmsCampaignService).to receive(:new).with(campaign: campaign).and_return(sms_service)\n        expect(sms_service).to receive(:perform)\n        campaign.save!\n        campaign.trigger!\n      end\n    end\n\n    context 'when SMS campaign' do\n      let!(:sms_channel) { create(:channel_sms) }\n      let!(:sms_inbox) { create(:inbox, channel: sms_channel) }\n      let(:campaign) { build(:campaign, inbox: sms_inbox) }\n\n      it 'only saves campaign type as oneoff and wont leave scheduled_at empty' do\n        campaign.campaign_type = 'ongoing'\n        campaign.save!\n        expect(campaign.reload.campaign_type).to eq 'one_off'\n        expect(campaign.scheduled_at.present?).to eq true\n      end\n\n      it 'calls sms service on trigger!' do\n        sms_service = double\n        expect(Sms::OneoffSmsCampaignService).to receive(:new).with(campaign: campaign).and_return(sms_service)\n        expect(sms_service).to receive(:perform)\n        campaign.save!\n        campaign.trigger!\n      end\n    end\n\n    context 'when Website campaign' do\n      let(:campaign) { build(:campaign) }\n\n      it 'only saves campaign type as ongoing' do\n        campaign.campaign_type = 'one_off'\n        campaign.save!\n        expect(campaign.reload.campaign_type).to eq 'ongoing'\n      end\n    end\n  end\nend\n"], "filenames": ["app/controllers/api/v1/accounts/campaigns_controller.rb", "app/models/campaign.rb", "spec/builders/campaigns/campaign_conversation_builder_spec.rb", "spec/controllers/api/v1/accounts/campaigns_controller_spec.rb", "spec/controllers/api/v1/accounts/inboxes_controller_spec.rb", "spec/controllers/api/v1/widget/campaigns_controller_spec.rb", "spec/listeners/campaign_listener_spec.rb", "spec/models/campaign_spec.rb"], "buggy_code_start_loc": [21, 35, 8, 18, 136, 6, 8, 12], "buggy_code_end_loc": [22, 88, 9, 176, 149, 8, 9, 41], "fixing_code_start_loc": [21, 36, 8, 18, 136, 6, 8, 12], "fixing_code_end_loc": [22, 106, 9, 195, 149, 8, 9, 46], "type": "CWE-79", "message": "Cross-site Scripting (XSS) - Stored in GitHub repository chatwoot/chatwoot prior to 2.2.0.", "other": {"cve": {"id": "CVE-2022-0527", "sourceIdentifier": "security@huntr.dev", "published": "2022-02-09T05:15:09.377", "lastModified": "2022-02-11T17:15:21.520", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cross-site Scripting (XSS) - Stored in GitHub repository chatwoot/chatwoot prior to 2.2.0."}, {"lang": "es", "value": "Una vulnerabilidad de tipo Cross-site Scripting (XSS) - Almacenado en Maven org.webjars.npm:github-com-chatwoot-chatwoot versiones anteriores a 2.2.0"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:H/UI:R/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.9, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:chatwoot:chatwoot:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.1.1", "matchCriteriaId": "63F871A4-BAE5-45C7-913E-BA49749D4C7A"}]}]}], "references": [{"url": "https://github.com/chatwoot/chatwoot/commit/a737f89c473e64f9abdf8ff13a3e64edefa28877", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/a2f598f6-c142-449a-96f8-b4b2f7a9e228", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/chatwoot/chatwoot/commit/a737f89c473e64f9abdf8ff13a3e64edefa28877"}}