{"buggy_code": ["# find-my-way\n\n[![js-standard-style](https://img.shields.io/badge/code%20style-standard-brightgreen.svg?style=flat)](http://standardjs.com/)  ![Node CI](https://github.com/delvedor/find-my-way/workflows/Node%20CI/badge.svg) [![NPM downloads](https://img.shields.io/npm/dm/find-my-way.svg?style=flat)](https://www.npmjs.com/package/find-my-way)\n\nA crazy fast HTTP router, internally uses an highly performant [Radix Tree](https://en.wikipedia.org/wiki/Radix_tree) (aka compact [Prefix Tree](https://en.wikipedia.org/wiki/Trie)), supports route params, wildcards, and it's framework independent.\n\nIf you want to see a benchmark comparison with the most commonly used routers, see [here](https://github.com/delvedor/router-benchmark).<br>\nDo you need a real-world example that uses this router? Check out [Fastify](https://github.com/fastify/fastify) or [Restify](https://github.com/restify/node-restify).\n\n<a name=\"install\"></a>\n## Install\n```\nnpm i find-my-way --save\n```\n\n<a name=\"usage\"></a>\n## Usage\n```js\nconst http = require('http')\nconst router = require('find-my-way')()\n\nrouter.on('GET', '/', (req, res, params) => {\n  res.end('{\"message\":\"hello world\"}')\n})\n\nconst server = http.createServer((req, res) => {\n  router.lookup(req, res)\n})\n\nserver.listen(3000, err => {\n  if (err) throw err\n  console.log('Server listening on: http://localhost:3000')\n})\n```\n\n<a name=\"api\"></a>\n## API\n<a name=\"constructor\"></a>\n#### FindMyway([options])\nInstance a new router.<br>\nYou can pass a default route with the option `defaultRoute`.\n```js\nconst router = require('find-my-way')({\n  defaultRoute: (req, res) => {\n    res.statusCode = 404\n    res.end()\n  }\n})\n```\n\nIn case of a badly formatted url *(eg: `/hello/%world`)*, by default `find-my-way` will invoke the `defaultRoute`, unless you specify the `onBadUrl` option:\n```js\nconst router = require('find-my-way')({\n  onBadUrl: (path, req, res) => {\n    res.statusCode = 400\n    res.end(`Bad path: ${path}`)\n  }\n})\n```\n\nTrailing slashes can be ignored by supplying the `ignoreTrailingSlash` option:\n```js\nconst router = require('find-my-way')({\n  ignoreTrailingSlash: true\n})\nfunction handler (req, res, params) {\n  res.end('foo')\n}\n// maps \"/foo/\" and \"/foo\" to `handler`\nrouter.on('GET', '/foo/', handler)\n```\n\nYou can set a custom length for parameters in parametric *(standard, regex and multi)* routes by using `maxParamLength` option, the default value is 100 characters.<br/>\n*If the maximum length limit is reached, the default route will be invoked.*\n```js\nconst router = require('find-my-way')({\n  maxParamLength: 500\n})\n```\n\nIf you are using a regex based route, `find-my-way` will throw an error if detects potentially catastrophic exponential-time regular expressions *(internally uses [`safe-regex2`](https://github.com/fastify/safe-regex2))*.<br/>\nIf you want to disable this behavior, pass the option `allowUnsafeRegex`.\n```js\nconst router = require('find-my-way')({\n  allowUnsafeRegex: true\n})\n```\n\nAccording to [RFC3986](https://tools.ietf.org/html/rfc3986#section-6.2.2.1), find-my-way is case sensitive by default.\nYou can disable this by setting the `caseSensitive` option to `false`:\nin that case, all paths will be matched as lowercase, but the route parameters or wildcards will maintain their original letter casing. You can turn off case sensitivity with:\n\n```js\nconst router = require('find-my-way')({\n  caseSensitive: false\n})\n```\n\n<a name=\"custom-versioning\"></a>\nBy default `find-my-way` uses [accept-version](./lib/accept-version.js) strategy to match requests with different versions of the handlers. The matching logic of that strategy is explained [below](#semver). It is possible to define the alternative strategy:\n```js\nconst customVersioning = {\n  // storage factory\n  storage: function () {\n    let versions = {}\n    return {\n      get: (version) => { return versions[version] || null },\n      set: (version, store) => { versions[version] = store },\n      del: (version) => { delete versions[version] },\n      empty: () => { versions = {} }\n    }\n  },\n  deriveVersion: (req, ctx) => {\n    return req.headers['accept']\n  }\n}\n\nconst router = FindMyWay({ versioning: customVersioning });\n```\n\nThe custom strategy object should contain next properties:\n* `storage` - the factory function for the Storage of the handlers based on their version.\n* `deriveVersion` - the function to determine the version based on the request\n\nThe signature of the functions and objects must match the one from the example above.\n\n\n*Please, be aware, if you use custom versioning strategy - you use it on your own risk. This can lead both to the performance degradation and bugs which are not related to `find-my-way` itself*\n\n<a name=\"on\"></a>\n#### on(method, path, [opts], handler, [store])\nRegister a new route.\n```js\nrouter.on('GET', '/example', (req, res, params) => {\n  // your code\n})\n```\nLast argument, `store` is used to pass an object that you can access later inside the handler function. If needed, `store` can be updated.\n```js\nrouter.on('GET', '/example', (req, res, params, store) => {\n  assert.equal(store, { message: 'hello world' })\n}, { message: 'hello world' })\n```\n\n##### Versioned routes\n\nIf needed you can provide a `version` option, which will allow you to declare multiple versions of the same route.\n\n###### default\n<a name=\"semver\"></a>\nDefault versioning strategy is called `accept-version` and it follows the [semver](https://semver.org/) specification.<br/>\nWhen using `lookup`, `find-my-way` will automatically detect the `Accept-Version` header and route the request accordingly.<br/>\nInternally `find-my-way` uses the [`semver-store`](https://github.com/delvedor/semver-store) to get the correct version of the route; *advanced ranges* and *pre-releases* currently are not supported.<br/>\n*Be aware that using this feature will cause a degradation of the overall performances of the router.*\n```js\nrouter.on('GET', '/example', { version: '1.2.0' }, (req, res, params) => {\n  res.end('Hello from 1.2.0!')\n})\n\nrouter.on('GET', '/example', { version: '2.4.0' }, (req, res, params) => {\n  res.end('Hello from 2.4.0!')\n})\n\n// The 'Accept-Version' header could be '1.2.0' as well as '*', '2.x' or '2.4.x'\n```\nIf you declare multiple versions with the same *major* or *minor* `find-my-way` will always choose the highest compatible with the `Accept-Version` header value.\n\n###### custom\nIt's also possible to define a [custom versioning strategy](#custom-versioning) during the `find-my-way` initialization. In this case the logic of matching the request to the specific handler depends on the versioning strategy you use.\n\n##### on(methods[], path, [opts], handler, [store])\nRegister a new route for each method specified in the `methods` array.\nIt comes handy when you need to declare multiple routes with the same handler but different methods.\n```js\nrouter.on(['GET', 'POST'], '/example', (req, res, params) => {\n  // your code\n})\n```\n\n<a name=\"supported-path-formats\"></a>\n##### Supported path formats\nTo register a **parametric** path, use the *colon* before the parameter name. For **wildcard** use the *star*.\n*Remember that static routes are always inserted before parametric and wildcard.*\n\n```js\n// parametric\nrouter.on('GET', '/example/:userId', (req, res, params) => {}))\nrouter.on('GET', '/example/:userId/:secretToken', (req, res, params) => {}))\n\n// wildcard\nrouter.on('GET', '/example/*', (req, res, params) => {}))\n```\n\nRegular expression routes are supported as well, but pay attention, RegExp are very expensive in term of performance!<br>\nIf you want to declare a regular expression route, you must put the regular expression inside round parenthesis after the parameter name.\n```js\n// parametric with regexp\nrouter.on('GET', '/example/:file(^\\\\d+).png', () => {}))\n```\n\nIt's possible to define more than one parameter within the same couple of slash (\"/\"). Such as:\n```js\nrouter.on('GET', '/example/near/:lat-:lng/radius/:r', (req, res, params) => {}))\n```\n*Remember in this case to use the dash (\"-\") as parameters separator.*\n\nFinally it's possible to have multiple parameters with RegExp.\n```js\nrouter.on('GET', '/example/at/:hour(^\\\\d{2})h:minute(^\\\\d{2})m', (req, res, params) => {}))\n```\nIn this case as parameter separator it's possible to use whatever character is not matched by the regular expression.\n\nHaving a route with multiple parameters may affect negatively the performance, so prefer single parameter approach whenever possible, especially on routes which are on the hot path of your application.\n\n<a name=\"match-order\"></a>\n##### Match order\n\nThe routing algorithm matches one chunk at a time (where the chunk is a string between two slashes),\nthis means that it cannot know if a route is static or dynamic until it finishes to match the URL.\n\nThe chunks are matched in the following order:\n\n1. static\n1. parametric\n1. wildcards\n1. parametric(regex)\n1. multi parametric(regex)\n\nSo if you declare the following routes\n\n- `/:userId/foo/bar`\n- `/33/:a(^.*$)/:b`\n\nand the URL of the incoming request is /33/foo/bar,\nthe second route will be matched because the first chunk (33) matches the static chunk.\nIf the URL would have been /32/foo/bar, the first route would have been matched.\n\n<a name=\"supported-methods\"></a>\n##### Supported methods\nThe router is able to route all HTTP methods defined by [`http` core module](https://nodejs.org/api/http.html#http_http_methods).\n\n<a name=\"off\"></a>\n#### off(method, path)\nDeregister a route.\n```js\nrouter.off('GET', '/example')\n// => { handler: Function, params: Object, store: Object}\n// => null\n```\n\n##### off(methods[], path, handler, [store])\nDeregister a route for each method specified in the `methods` array.\nIt comes handy when you need to deregister multiple routes with the same path but different methods.\n```js\nrouter.off(['GET', 'POST'], '/example')\n// => [{ handler: Function, params: Object, store: Object}]\n// => null\n```\n\n<a name=\"reset\"></a>\n#### reset()\nEmpty router.\n```js\nrouter.reset()\n```\n\n##### Caveats\n* It's not possible to register two routes which differs only for their parameters, because internally they would be seen as the same route. In a such case you'll get an early error during the route registration phase. An example is worth thousand words:\n```js\nconst findMyWay = FindMyWay({\n  defaultRoute: (req, res) => {}\n})\n\nfindMyWay.on('GET', '/user/:userId(^\\\\d+)', (req, res, params) => {})\n\nfindMyWay.on('GET', '/user/:username(^[a-z]+)', (req, res, params) => {})\n// Method 'GET' already declared for route ':'\n```\n\n<a name=\"shorthand-methods\"></a>\n##### Shorthand methods\nIf you want an even nicer api, you can also use the shorthand methods to declare your routes.\n\nFor each HTTP supported method, there's the shorthand method. For example:\n```js\nrouter.get(path, handler [, store])\nrouter.delete(path, handler [, store])\nrouter.head(path, handler [, store])\nrouter.patch(path, handler [, store])\nrouter.post(path, handler [, store])\nrouter.put(path, handler [, store])\nrouter.options(path, handler [, store])\n// ...\n```\n\nIf you need a route that supports *all* methods you can use the `all` api.\n```js\nrouter.all(path, handler [, store])\n```\n\n<a name=\"lookup\"></a>\n#### lookup(request, response, [context])\nStart a new search, `request` and `response` are the server req/res objects.<br>\nIf a route is found it will automatically call the handler, otherwise the default route will be called.<br>\nThe url is sanitized internally, all the parameters and wildcards are decoded automatically.\n```js\nrouter.lookup(req, res)\n```\n\n`lookup` accepts an optional context which will be the value of `this` when executing a handler\n```js\nrouter.on('GET', '*', function(req, res) {\n  res.end(this.greeting);\n})\nrouter.lookup(req, res, { greeting: 'Hello, World!' })\n```\n\n<a name=\"find\"></a>\n#### find(method, path [, version])\nReturn (if present) the route registered in *method:path*.<br>\nThe path must be sanitized, all the parameters and wildcards are decoded automatically.<br/>\nYou can also pass an optional version string. In case of the default versioning strategy it should be conform to the [semver](https://semver.org/) specification.\n```js\nrouter.find('GET', '/example')\n// => { handler: Function, params: Object, store: Object}\n// => null\n\nrouter.find('GET', '/example', '1.x')\n// => { handler: Function, params: Object, store: Object}\n// => null\n```\n\n<a name=\"pretty-print\"></a>\n#### prettyPrint()\nPrints the representation of the internal radix tree, useful for debugging.\n```js\nfindMyWay.on('GET', '/test', () => {})\nfindMyWay.on('GET', '/test/hello', () => {})\nfindMyWay.on('GET', '/hello/world', () => {})\n\nconsole.log(findMyWay.prettyPrint())\n// \u2514\u2500\u2500 /\n//   \u251c\u2500\u2500 test (GET)\n//   \u2502   \u2514\u2500\u2500 /hello (GET)\n//   \u2514\u2500\u2500 hello/world (GET)\n```\n\n<a name=\"routes\"></a>\n#### routes\nReturn the all routes **registered** at moment, useful for debugging.\n\n```js\nconst findMyWay = require('find-my-way')()\n\nfindMyWay.on('GET', '/test', () => {})\nfindMyWay.on('GET', '/test/hello', () => {})\n\nconsole.log(findMyWay.routes)\n// Will print\n// [\n//   {\n//     method: 'GET',\n//     path: '/test',\n//     opts: {},\n//     handler: [Function],\n//     store: undefined\n//   },\n//   {\n//     method: 'GET',\n//     path: '/test/hello',\n//     opts: {},\n//     handler: [Function],\n//     store: undefined\n//   }\n// ]\n```\n\n<a name=\"acknowledgements\"></a>\n## Acknowledgements\n\nIt is inspired by the [echo](https://github.com/labstack/echo) router, some parts have been extracted from [trekjs](https://github.com/trekjs) router.\n\n<a name=\"sponsor\"></a>\n#### Past sponsor\n\n- [LetzDoIt](http://www.letzdoitapp.com/)\n\n<a name=\"license\"></a>\n## License\n**[find-my-way - MIT](https://github.com/delvedor/find-my-way/blob/master/LICENSE)**<br>\n**[trekjs/router - MIT](https://github.com/trekjs/router/blob/master/LICENSE)**\n\nCopyright \u00a9 2017-2019 Tomas Della Vedova\n", "'use strict'\n\n/*\n  Char codes:\n    '#': 35\n    '*': 42\n    '-': 45\n    '/': 47\n    ':': 58\n    ';': 59\n    '?': 63\n*/\n\nconst assert = require('assert')\nconst http = require('http')\nconst fastDecode = require('fast-decode-uri-component')\nconst isRegexSafe = require('safe-regex2')\nconst { flattenNode, compressFlattenedNode, prettyPrintFlattenedNode } = require('./lib/pretty-print')\nconst Node = require('./node')\nconst NODE_TYPES = Node.prototype.types\nconst httpMethods = http.METHODS\nconst FULL_PATH_REGEXP = /^https?:\\/\\/.*?\\//\n\nif (!isRegexSafe(FULL_PATH_REGEXP)) {\n  throw new Error('the FULL_PATH_REGEXP is not safe, update this module')\n}\n\nconst acceptVersionStrategy = require('./lib/accept-version')\n\nfunction Router (opts) {\n  if (!(this instanceof Router)) {\n    return new Router(opts)\n  }\n  opts = opts || {}\n\n  if (opts.defaultRoute) {\n    assert(typeof opts.defaultRoute === 'function', 'The default route must be a function')\n    this.defaultRoute = opts.defaultRoute\n  } else {\n    this.defaultRoute = null\n  }\n\n  if (opts.onBadUrl) {\n    assert(typeof opts.onBadUrl === 'function', 'The bad url handler must be a function')\n    this.onBadUrl = opts.onBadUrl\n  } else {\n    this.onBadUrl = null\n  }\n\n  this.caseSensitive = opts.caseSensitive === undefined ? true : opts.caseSensitive\n  this.ignoreTrailingSlash = opts.ignoreTrailingSlash || false\n  this.maxParamLength = opts.maxParamLength || 100\n  this.allowUnsafeRegex = opts.allowUnsafeRegex || false\n  this.versioning = opts.versioning || acceptVersionStrategy\n  this.trees = {}\n  this.routes = []\n}\n\nRouter.prototype.on = function on (method, path, opts, handler, store) {\n  if (typeof opts === 'function') {\n    if (handler !== undefined) {\n      store = handler\n    }\n    handler = opts\n    opts = {}\n  }\n  // path validation\n  assert(typeof path === 'string', 'Path should be a string')\n  assert(path.length > 0, 'The path could not be empty')\n  assert(path[0] === '/' || path[0] === '*', 'The first character of a path should be `/` or `*`')\n  // handler validation\n  assert(typeof handler === 'function', 'Handler should be a function')\n\n  this._on(method, path, opts, handler, store)\n\n  if (this.ignoreTrailingSlash && path !== '/' && !path.endsWith('*')) {\n    if (path.endsWith('/')) {\n      this._on(method, path.slice(0, -1), opts, handler, store)\n    } else {\n      this._on(method, path + '/', opts, handler, store)\n    }\n  }\n}\n\nRouter.prototype._on = function _on (method, path, opts, handler, store) {\n  if (Array.isArray(method)) {\n    for (var k = 0; k < method.length; k++) {\n      this._on(method[k], path, opts, handler, store)\n    }\n    return\n  }\n\n  // method validation\n  assert(typeof method === 'string', 'Method should be a string')\n  assert(httpMethods.indexOf(method) !== -1, `Method '${method}' is not an http method.`)\n\n  // version validation\n  if (opts.version !== undefined) {\n    assert(typeof opts.version === 'string', 'Version should be a string')\n  }\n\n  const params = []\n  var j = 0\n\n  this.routes.push({\n    method: method,\n    path: path,\n    opts: opts,\n    handler: handler,\n    store: store\n  })\n\n  const version = opts.version\n\n  for (var i = 0, len = path.length; i < len; i++) {\n    // search for parametric or wildcard routes\n    // parametric route\n    if (path.charCodeAt(i) === 58) {\n      var nodeType = NODE_TYPES.PARAM\n      j = i + 1\n      var staticPart = path.slice(0, i)\n\n      if (this.caseSensitive === false) {\n        staticPart = staticPart.toLowerCase()\n      }\n\n      // add the static part of the route to the tree\n      this._insert(method, staticPart, NODE_TYPES.STATIC, null, null, null, null, version)\n\n      // isolate the parameter name\n      var isRegex = false\n      while (i < len && path.charCodeAt(i) !== 47) {\n        isRegex = isRegex || path[i] === '('\n        if (isRegex) {\n          i = getClosingParenthensePosition(path, i) + 1\n          break\n        } else if (path.charCodeAt(i) !== 45) {\n          i++\n        } else {\n          break\n        }\n      }\n\n      if (isRegex && (i === len || path.charCodeAt(i) === 47)) {\n        nodeType = NODE_TYPES.REGEX\n      } else if (i < len && path.charCodeAt(i) !== 47) {\n        nodeType = NODE_TYPES.MULTI_PARAM\n      }\n\n      var parameter = path.slice(j, i)\n      var regex = isRegex ? parameter.slice(parameter.indexOf('('), i) : null\n      if (isRegex) {\n        regex = new RegExp(regex)\n        if (!this.allowUnsafeRegex) {\n          assert(isRegexSafe(regex), `The regex '${regex.toString()}' is not safe!`)\n        }\n      }\n      params.push(parameter.slice(0, isRegex ? parameter.indexOf('(') : i))\n\n      path = path.slice(0, j) + path.slice(i)\n      i = j\n      len = path.length\n\n      // if the path is ended\n      if (i === len) {\n        var completedPath = path.slice(0, i)\n        if (this.caseSensitive === false) {\n          completedPath = completedPath.toLowerCase()\n        }\n        return this._insert(method, completedPath, nodeType, params, handler, store, regex, version)\n      }\n      // add the parameter and continue with the search\n      staticPart = path.slice(0, i)\n      if (this.caseSensitive === false) {\n        staticPart = staticPart.toLowerCase()\n      }\n      this._insert(method, staticPart, nodeType, params, null, null, regex, version)\n\n      i--\n    // wildcard route\n    } else if (path.charCodeAt(i) === 42) {\n      this._insert(method, path.slice(0, i), NODE_TYPES.STATIC, null, null, null, null, version)\n      // add the wildcard parameter\n      params.push('*')\n      return this._insert(method, path.slice(0, len), NODE_TYPES.MATCH_ALL, params, handler, store, null, version)\n    }\n  }\n\n  if (this.caseSensitive === false) {\n    path = path.toLowerCase()\n  }\n\n  // static route\n  this._insert(method, path, NODE_TYPES.STATIC, params, handler, store, null, version)\n}\n\nRouter.prototype._insert = function _insert (method, path, kind, params, handler, store, regex, version) {\n  const route = path\n  var prefix = ''\n  var pathLen = 0\n  var prefixLen = 0\n  var len = 0\n  var max = 0\n  var node = null\n\n  var currentNode = this.trees[method]\n  if (typeof currentNode === 'undefined') {\n    currentNode = new Node({ method: method, versions: this.versioning.storage() })\n    this.trees[method] = currentNode\n  }\n\n  while (true) {\n    prefix = currentNode.prefix\n    prefixLen = prefix.length\n    pathLen = path.length\n    len = 0\n\n    // search for the longest common prefix\n    max = pathLen < prefixLen ? pathLen : prefixLen\n    while (len < max && path[len] === prefix[len]) len++\n\n    // the longest common prefix is smaller than the current prefix\n    // let's split the node and add a new child\n    if (len < prefixLen) {\n      node = new Node(\n        {\n          method: method,\n          prefix: prefix.slice(len),\n          children: currentNode.children,\n          kind: currentNode.kind,\n          handler: currentNode.handler,\n          regex: currentNode.regex,\n          versions: currentNode.versions\n        }\n      )\n      if (currentNode.wildcardChild !== null) {\n        node.wildcardChild = currentNode.wildcardChild\n      }\n\n      // reset the parent\n      currentNode\n        .reset(prefix.slice(0, len), this.versioning.storage())\n        .addChild(node)\n\n      // if the longest common prefix has the same length of the current path\n      // the handler should be added to the current node, to a child otherwise\n      if (len === pathLen) {\n        if (version) {\n          assert(!currentNode.getVersionHandler(version), `Method '${method}' already declared for route '${route}' version '${version}'`)\n          currentNode.setVersionHandler(version, handler, params, store)\n        } else {\n          assert(!currentNode.handler, `Method '${method}' already declared for route '${route}'`)\n          currentNode.setHandler(handler, params, store)\n        }\n        currentNode.kind = kind\n      } else {\n        node = new Node({\n          method: method,\n          prefix: path.slice(len),\n          kind: kind,\n          handlers: null,\n          regex: regex,\n          versions: this.versioning.storage()\n        })\n        if (version) {\n          node.setVersionHandler(version, handler, params, store)\n        } else {\n          node.setHandler(handler, params, store)\n        }\n        currentNode.addChild(node)\n      }\n\n    // the longest common prefix is smaller than the path length,\n    // but is higher than the prefix\n    } else if (len < pathLen) {\n      // remove the prefix\n      path = path.slice(len)\n      // check if there is a child with the label extracted from the new path\n      node = currentNode.findByLabel(path)\n      // there is a child within the given label, we must go deepen in the tree\n      if (node) {\n        currentNode = node\n        continue\n      }\n      // there are not children within the given label, let's create a new one!\n      node = new Node({ method: method, prefix: path, kind: kind, regex: regex, versions: this.versioning.storage() })\n      if (version) {\n        node.setVersionHandler(version, handler, params, store)\n      } else {\n        node.setHandler(handler, params, store)\n      }\n\n      currentNode.addChild(node)\n\n    // the node already exist\n    } else if (handler) {\n      if (version) {\n        assert(!currentNode.getVersionHandler(version), `Method '${method}' already declared for route '${route}' version '${version}'`)\n        currentNode.setVersionHandler(version, handler, params, store)\n      } else {\n        assert(!currentNode.handler, `Method '${method}' already declared for route '${route}'`)\n        currentNode.setHandler(handler, params, store)\n      }\n    }\n    return\n  }\n}\n\nRouter.prototype.reset = function reset () {\n  this.trees = {}\n  this.routes = []\n}\n\nRouter.prototype.off = function off (method, path) {\n  var self = this\n\n  if (Array.isArray(method)) {\n    return method.map(function (method) {\n      return self.off(method, path)\n    })\n  }\n\n  // method validation\n  assert(typeof method === 'string', 'Method should be a string')\n  assert(httpMethods.indexOf(method) !== -1, `Method '${method}' is not an http method.`)\n  // path validation\n  assert(typeof path === 'string', 'Path should be a string')\n  assert(path.length > 0, 'The path could not be empty')\n  assert(path[0] === '/' || path[0] === '*', 'The first character of a path should be `/` or `*`')\n\n  // Rebuild tree without the specific route\n  const ignoreTrailingSlash = this.ignoreTrailingSlash\n  var newRoutes = self.routes.filter(function (route) {\n    if (!ignoreTrailingSlash) {\n      return !(method === route.method && path === route.path)\n    }\n    if (path.endsWith('/')) {\n      const routeMatches = path === route.path || path.slice(0, -1) === route.path\n      return !(method === route.method && routeMatches)\n    }\n    const routeMatches = path === route.path || (path + '/') === route.path\n    return !(method === route.method && routeMatches)\n  })\n  if (ignoreTrailingSlash) {\n    newRoutes = newRoutes.filter(function (route, i, ar) {\n      if (route.path.endsWith('/') && i < ar.length - 1) {\n        return route.path.slice(0, -1) !== ar[i + 1].path\n      } else if (route.path.endsWith('/') === false && i < ar.length - 1) {\n        return (route.path + '/') !== ar[i + 1].path\n      }\n      return true\n    })\n  }\n  self.reset()\n  newRoutes.forEach(function (route) {\n    self.on(route.method, route.path, route.opts, route.handler, route.store)\n  })\n}\n\nRouter.prototype.lookup = function lookup (req, res, ctx) {\n  var handle = this.find(req.method, sanitizeUrl(req.url), this.versioning.deriveVersion(req, ctx))\n  if (handle === null) return this._defaultRoute(req, res, ctx)\n  return ctx === undefined\n    ? handle.handler(req, res, handle.params, handle.store)\n    : handle.handler.call(ctx, req, res, handle.params, handle.store)\n}\n\nRouter.prototype.find = function find (method, path, version) {\n  var currentNode = this.trees[method]\n  if (!currentNode) return null\n\n  if (path.charCodeAt(0) !== 47) { // 47 is '/'\n    path = path.replace(FULL_PATH_REGEXP, '/')\n  }\n\n  var originalPath = path\n  var originalPathLength = path.length\n\n  if (this.caseSensitive === false) {\n    path = path.toLowerCase()\n  }\n\n  var maxParamLength = this.maxParamLength\n  var wildcardNode = null\n  var pathLenWildcard = 0\n  var decoded = null\n  var pindex = 0\n  var params = []\n  var i = 0\n  var idxInOriginalPath = 0\n\n  while (true) {\n    var pathLen = path.length\n    var prefix = currentNode.prefix\n    var prefixLen = prefix.length\n    var len = 0\n    var previousPath = path\n    // found the route\n    if (pathLen === 0 || path === prefix) {\n      var handle = version === undefined\n        ? currentNode.handler\n        : currentNode.getVersionHandler(version)\n      if (handle !== null && handle !== undefined) {\n        var paramsObj = {}\n        if (handle.paramsLength > 0) {\n          var paramNames = handle.params\n\n          for (i = 0; i < handle.paramsLength; i++) {\n            paramsObj[paramNames[i]] = params[i]\n          }\n        }\n\n        return {\n          handler: handle.handler,\n          params: paramsObj,\n          store: handle.store\n        }\n      }\n    }\n\n    // search for the longest common prefix\n    i = pathLen < prefixLen ? pathLen : prefixLen\n    while (len < i && path.charCodeAt(len) === prefix.charCodeAt(len)) len++\n\n    if (len === prefixLen) {\n      path = path.slice(len)\n      pathLen = path.length\n      idxInOriginalPath += len\n    }\n\n    var node = version === undefined\n      ? currentNode.findChild(path)\n      : currentNode.findVersionChild(version, path)\n\n    if (node === null) {\n      node = currentNode.parametricBrother\n      if (node === null) {\n        return this._getWildcardNode(wildcardNode, originalPath, pathLenWildcard)\n      }\n\n      var goBack = previousPath.charCodeAt(0) === 47 ? previousPath : '/' + previousPath\n      if (originalPath.indexOf(goBack) === -1) {\n        // we need to know the outstanding path so far from the originalPath since the last encountered \"/\" and assign it to previousPath.\n        // e.g originalPath: /aa/bbb/cc, path: bb/cc\n        // outstanding path: /bbb/cc\n        var pathDiff = originalPath.slice(0, originalPathLength - pathLen)\n        previousPath = pathDiff.slice(pathDiff.lastIndexOf('/') + 1, pathDiff.length) + path\n      }\n      idxInOriginalPath = idxInOriginalPath -\n        (previousPath.length - path.length)\n      path = previousPath\n      pathLen = previousPath.length\n      len = prefixLen\n    }\n\n    var kind = node.kind\n\n    // static route\n    if (kind === NODE_TYPES.STATIC) {\n      // if exist, save the wildcard child\n      if (currentNode.wildcardChild !== null) {\n        wildcardNode = currentNode.wildcardChild\n        pathLenWildcard = pathLen\n      }\n      currentNode = node\n      continue\n    }\n\n    if (len !== prefixLen) {\n      return this._getWildcardNode(wildcardNode, originalPath, pathLenWildcard)\n    }\n\n    // if exist, save the wildcard child\n    if (currentNode.wildcardChild !== null) {\n      wildcardNode = currentNode.wildcardChild\n      pathLenWildcard = pathLen\n    }\n\n    // parametric route\n    if (kind === NODE_TYPES.PARAM) {\n      currentNode = node\n      i = path.indexOf('/')\n      if (i === -1) i = pathLen\n      if (i > maxParamLength) return null\n      decoded = fastDecode(originalPath.slice(idxInOriginalPath, idxInOriginalPath + i))\n      if (decoded === null) {\n        return this.onBadUrl !== null\n          ? this._onBadUrl(originalPath.slice(idxInOriginalPath, idxInOriginalPath + i))\n          : null\n      }\n      params[pindex++] = decoded\n      path = path.slice(i)\n      idxInOriginalPath += i\n      continue\n    }\n\n    // wildcard route\n    if (kind === NODE_TYPES.MATCH_ALL) {\n      decoded = fastDecode(originalPath.slice(idxInOriginalPath))\n      if (decoded === null) {\n        return this.onBadUrl !== null\n          ? this._onBadUrl(originalPath.slice(idxInOriginalPath))\n          : null\n      }\n      params[pindex] = decoded\n      currentNode = node\n      path = ''\n      continue\n    }\n\n    // parametric(regex) route\n    if (kind === NODE_TYPES.REGEX) {\n      currentNode = node\n      i = path.indexOf('/')\n      if (i === -1) i = pathLen\n      if (i > maxParamLength) return null\n      decoded = fastDecode(originalPath.slice(idxInOriginalPath, idxInOriginalPath + i))\n      if (decoded === null) {\n        return this.onBadUrl !== null\n          ? this._onBadUrl(originalPath.slice(idxInOriginalPath, idxInOriginalPath + i))\n          : null\n      }\n      if (!node.regex.test(decoded)) return null\n      params[pindex++] = decoded\n      path = path.slice(i)\n      idxInOriginalPath += i\n      continue\n    }\n\n    // multiparametric route\n    if (kind === NODE_TYPES.MULTI_PARAM) {\n      currentNode = node\n      i = 0\n      if (node.regex !== null) {\n        var matchedParameter = path.match(node.regex)\n        if (matchedParameter === null) return null\n        i = matchedParameter[1].length\n      } else {\n        while (i < pathLen && path.charCodeAt(i) !== 47 && path.charCodeAt(i) !== 45) i++\n        if (i > maxParamLength) return null\n      }\n      decoded = fastDecode(originalPath.slice(idxInOriginalPath, idxInOriginalPath + i))\n      if (decoded === null) {\n        return this.onBadUrl !== null\n          ? this._onBadUrl(originalPath.slice(idxInOriginalPath, idxInOriginalPath + i))\n          : null\n      }\n      params[pindex++] = decoded\n      path = path.slice(i)\n      idxInOriginalPath += i\n      continue\n    }\n\n    wildcardNode = null\n  }\n}\n\nRouter.prototype._getWildcardNode = function (node, path, len) {\n  if (node === null) return null\n  var decoded = fastDecode(path.slice(-len))\n  if (decoded === null) {\n    return this.onBadUrl !== null\n      ? this._onBadUrl(path.slice(-len))\n      : null\n  }\n  var handle = node.handler\n  if (handle !== null && handle !== undefined) {\n    return {\n      handler: handle.handler,\n      params: { '*': decoded },\n      store: handle.store\n    }\n  }\n  return null\n}\n\nRouter.prototype._defaultRoute = function (req, res, ctx) {\n  if (this.defaultRoute !== null) {\n    return ctx === undefined\n      ? this.defaultRoute(req, res)\n      : this.defaultRoute.call(ctx, req, res)\n  } else {\n    res.statusCode = 404\n    res.end()\n  }\n}\n\nRouter.prototype._onBadUrl = function (path) {\n  const onBadUrl = this.onBadUrl\n  return {\n    handler: (req, res, ctx) => onBadUrl(path, req, res),\n    params: {},\n    store: null\n  }\n}\n\nRouter.prototype.prettyPrint = function () {\n  const root = {\n    prefix: '/',\n    nodes: [],\n    children: {}\n  }\n\n  for (const node of Object.values(this.trees)) {\n    if (node) {\n      flattenNode(root, node)\n    }\n  }\n\n  compressFlattenedNode(root)\n\n  return prettyPrintFlattenedNode(root, '', true)\n}\n\nfor (var i in http.METHODS) {\n  /* eslint no-prototype-builtins: \"off\" */\n  if (!http.METHODS.hasOwnProperty(i)) continue\n  const m = http.METHODS[i]\n  const methodName = m.toLowerCase()\n\n  if (Router.prototype[methodName]) throw new Error('Method already exists: ' + methodName)\n\n  Router.prototype[methodName] = function (path, handler, store) {\n    return this.on(m, path, handler, store)\n  }\n}\n\nRouter.prototype.all = function (path, handler, store) {\n  this.on(httpMethods, path, handler, store)\n}\n\nmodule.exports = Router\n\nfunction sanitizeUrl (url) {\n  for (var i = 0, len = url.length; i < len; i++) {\n    var charCode = url.charCodeAt(i)\n    // Some systems do not follow RFC and separate the path and query\n    // string with a `;` character (code 59), e.g. `/foo;jsessionid=123456`.\n    // Thus, we need to split on `;` as well as `?` and `#`.\n    if (charCode === 63 || charCode === 59 || charCode === 35) {\n      return url.slice(0, i)\n    }\n  }\n  return url\n}\n\nfunction getClosingParenthensePosition (path, idx) {\n  // `path.indexOf()` will always return the first position of the closing parenthese,\n  // but it's inefficient for grouped or wrong regexp expressions.\n  // see issues #62 and #63 for more info\n\n  var parentheses = 1\n\n  while (idx < path.length) {\n    idx++\n\n    // ignore skipped chars\n    if (path[idx] === '\\\\') {\n      idx++\n      continue\n    }\n\n    if (path[idx] === ')') {\n      parentheses--\n    } else if (path[idx] === '(') {\n      parentheses++\n    }\n\n    if (!parentheses) return idx\n  }\n\n  throw new TypeError('Invalid regexp expression in \"' + path + '\"')\n}\n", "'use strict'\n\nconst SemVerStore = require('semver-store')\n\nmodule.exports = {\n  storage: SemVerStore,\n  deriveVersion: function (req, ctx) {\n    return req.headers['accept-version']\n  }\n}\n", "'use strict'\n\nconst t = require('tap')\nconst test = t.test\nconst FindMyWay = require('../')\nconst noop = () => {}\n\ntest('A route could support multiple versions (find) / 1', t => {\n  t.plan(7)\n\n  const findMyWay = FindMyWay()\n\n  findMyWay.on('GET', '/', { version: '1.2.3' }, noop)\n  findMyWay.on('GET', '/', { version: '3.2.0' }, noop)\n\n  t.ok(findMyWay.find('GET', '/', '1.x'))\n  t.ok(findMyWay.find('GET', '/', '1.2.3'))\n  t.ok(findMyWay.find('GET', '/', '3.x'))\n  t.ok(findMyWay.find('GET', '/', '3.2.0'))\n  t.notOk(findMyWay.find('GET', '/', '2.x'))\n  t.notOk(findMyWay.find('GET', '/', '2.3.4'))\n  t.notOk(findMyWay.find('GET', '/', '3.2.1'))\n})\n\ntest('A route could support multiple versions (find) / 2', t => {\n  t.plan(7)\n\n  const findMyWay = FindMyWay()\n\n  findMyWay.on('GET', '/test', { version: '1.2.3' }, noop)\n  findMyWay.on('GET', '/test', { version: '3.2.0' }, noop)\n\n  t.ok(findMyWay.find('GET', '/test', '1.x'))\n  t.ok(findMyWay.find('GET', '/test', '1.2.3'))\n  t.ok(findMyWay.find('GET', '/test', '3.x'))\n  t.ok(findMyWay.find('GET', '/test', '3.2.0'))\n  t.notOk(findMyWay.find('GET', '/test', '2.x'))\n  t.notOk(findMyWay.find('GET', '/test', '2.3.4'))\n  t.notOk(findMyWay.find('GET', '/test', '3.2.1'))\n})\n\ntest('A route could support multiple versions (find) / 3', t => {\n  t.plan(10)\n\n  const findMyWay = FindMyWay()\n\n  findMyWay.on('GET', '/test/:id/hello', { version: '1.2.3' }, noop)\n  findMyWay.on('GET', '/test/:id/hello', { version: '3.2.0' }, noop)\n  findMyWay.on('GET', '/test/name/hello', { version: '4.0.0' }, noop)\n\n  t.ok(findMyWay.find('GET', '/test/1234/hello', '1.x'))\n  t.ok(findMyWay.find('GET', '/test/1234/hello', '1.2.3'))\n  t.ok(findMyWay.find('GET', '/test/1234/hello', '3.x'))\n  t.ok(findMyWay.find('GET', '/test/1234/hello', '3.2.0'))\n  t.ok(findMyWay.find('GET', '/test/name/hello', '4.x'))\n  t.ok(findMyWay.find('GET', '/test/name/hello', '3.x'))\n  t.notOk(findMyWay.find('GET', '/test/1234/hello', '2.x'))\n  t.notOk(findMyWay.find('GET', '/test/1234/hello', '2.3.4'))\n  t.notOk(findMyWay.find('GET', '/test/1234/hello', '3.2.1'))\n  t.notOk(findMyWay.find('GET', '/test/1234/hello', '4.x'))\n})\n\ntest('A route could support multiple versions (find) / 4', t => {\n  t.plan(8)\n\n  const findMyWay = FindMyWay()\n\n  findMyWay.on('GET', '/test/*', { version: '1.2.3' }, noop)\n  findMyWay.on('GET', '/test/hello', { version: '3.2.0' }, noop)\n\n  t.ok(findMyWay.find('GET', '/test/1234/hello', '1.x'))\n  t.ok(findMyWay.find('GET', '/test/1234/hello', '1.2.3'))\n  t.ok(findMyWay.find('GET', '/test/hello', '3.x'))\n  t.ok(findMyWay.find('GET', '/test/hello', '3.2.0'))\n  t.notOk(findMyWay.find('GET', '/test/1234/hello', '3.2.0'))\n  t.notOk(findMyWay.find('GET', '/test/1234/hello', '3.x'))\n  t.notOk(findMyWay.find('GET', '/test/1234/hello', '2.x'))\n  t.notOk(findMyWay.find('GET', '/test/hello', '2.x'))\n})\n\ntest('A route could support multiple versions (find) / 5', t => {\n  t.plan(1)\n\n  const findMyWay = FindMyWay()\n\n  findMyWay.on('GET', '/', { version: '1.2.3' }, () => false)\n  findMyWay.on('GET', '/', { version: '3.2.0' }, () => true)\n\n  t.ok(findMyWay.find('GET', '/', '*').handler())\n})\n\ntest('Find with a version but without versioned routes', t => {\n  t.plan(1)\n\n  const findMyWay = FindMyWay()\n\n  findMyWay.on('GET', '/', noop)\n\n  t.notOk(findMyWay.find('GET', '/', '1.x'))\n})\n\ntest('A route could support multiple versions (lookup)', t => {\n  t.plan(7)\n\n  const findMyWay = FindMyWay({\n    defaultRoute: (req, res) => {\n      const versions = ['2.x', '2.3.4', '3.2.1']\n      t.ok(versions.indexOf(req.headers['accept-version']) > -1)\n    }\n  })\n\n  findMyWay.on('GET', '/', { version: '1.2.3' }, (req, res) => {\n    const versions = ['1.x', '1.2.3']\n    t.ok(versions.indexOf(req.headers['accept-version']) > -1)\n  })\n\n  findMyWay.on('GET', '/', { version: '3.2.0' }, (req, res) => {\n    const versions = ['3.x', '3.2.0']\n    t.ok(versions.indexOf(req.headers['accept-version']) > -1)\n  })\n\n  findMyWay.lookup({\n    method: 'GET',\n    url: '/',\n    headers: { 'accept-version': '1.x' }\n  }, null)\n\n  findMyWay.lookup({\n    method: 'GET',\n    url: '/',\n    headers: { 'accept-version': '1.2.3' }\n  }, null)\n\n  findMyWay.lookup({\n    method: 'GET',\n    url: '/',\n    headers: { 'accept-version': '3.x' }\n  }, null)\n\n  findMyWay.lookup({\n    method: 'GET',\n    url: '/',\n    headers: { 'accept-version': '3.2.0' }\n  }, null)\n\n  findMyWay.lookup({\n    method: 'GET',\n    url: '/',\n    headers: { 'accept-version': '2.x' }\n  }, null)\n\n  findMyWay.lookup({\n    method: 'GET',\n    url: '/',\n    headers: { 'accept-version': '2.3.4' }\n  }, null)\n\n  findMyWay.lookup({\n    method: 'GET',\n    url: '/',\n    headers: { 'accept-version': '3.2.1' }\n  }, null)\n})\n\ntest('It should always choose the highest version of a route', t => {\n  t.plan(3)\n\n  const findMyWay = FindMyWay()\n\n  findMyWay.on('GET', '/', { version: '2.3.0' }, (req, res) => {\n    t.fail('We should not be here')\n  })\n\n  findMyWay.on('GET', '/', { version: '2.4.0' }, (req, res) => {\n    t.pass('Yeah!')\n  })\n\n  findMyWay.on('GET', '/', { version: '3.3.0' }, (req, res) => {\n    t.pass('Yeah!')\n  })\n\n  findMyWay.on('GET', '/', { version: '3.2.0' }, (req, res) => {\n    t.fail('We should not be here')\n  })\n\n  findMyWay.on('GET', '/', { version: '3.2.2' }, (req, res) => {\n    t.fail('We should not be here')\n  })\n\n  findMyWay.on('GET', '/', { version: '4.4.0' }, (req, res) => {\n    t.fail('We should not be here')\n  })\n\n  findMyWay.on('GET', '/', { version: '4.3.2' }, (req, res) => {\n    t.pass('Yeah!')\n  })\n\n  findMyWay.lookup({\n    method: 'GET',\n    url: '/',\n    headers: { 'accept-version': '2.x' }\n  }, null)\n\n  findMyWay.lookup({\n    method: 'GET',\n    url: '/',\n    headers: { 'accept-version': '3.x' }\n  }, null)\n\n  findMyWay.lookup({\n    method: 'GET',\n    url: '/',\n    headers: { 'accept-version': '4.3.x' }\n  }, null)\n})\n\ntest('Declare the same route with and without version', t => {\n  t.plan(2)\n\n  const findMyWay = FindMyWay()\n\n  findMyWay.on('GET', '/', noop)\n  findMyWay.on('GET', '/', { version: '1.2.0' }, noop)\n\n  t.ok(findMyWay.find('GET', '/', '1.x'))\n  t.ok(findMyWay.find('GET', '/'))\n})\n\ntest('It should throw if you declare multiple times the same route', t => {\n  t.plan(1)\n\n  const findMyWay = FindMyWay()\n\n  findMyWay.on('GET', '/', { version: '1.2.3' }, noop)\n\n  try {\n    findMyWay.on('GET', '/', { version: '1.2.3' }, noop)\n    t.fail('It should throw')\n  } catch (err) {\n    t.is(err.message, 'Method \\'GET\\' already declared for route \\'/\\' version \\'1.2.3\\'')\n  }\n})\n"], "fixing_code": ["# find-my-way\n\n[![js-standard-style](https://img.shields.io/badge/code%20style-standard-brightgreen.svg?style=flat)](http://standardjs.com/)  ![Node CI](https://github.com/delvedor/find-my-way/workflows/Node%20CI/badge.svg) [![NPM downloads](https://img.shields.io/npm/dm/find-my-way.svg?style=flat)](https://www.npmjs.com/package/find-my-way)\n\nA crazy fast HTTP router, internally uses an highly performant [Radix Tree](https://en.wikipedia.org/wiki/Radix_tree) (aka compact [Prefix Tree](https://en.wikipedia.org/wiki/Trie)), supports route params, wildcards, and it's framework independent.\n\nIf you want to see a benchmark comparison with the most commonly used routers, see [here](https://github.com/delvedor/router-benchmark).<br>\nDo you need a real-world example that uses this router? Check out [Fastify](https://github.com/fastify/fastify) or [Restify](https://github.com/restify/node-restify).\n\n<a name=\"install\"></a>\n## Install\n```\nnpm i find-my-way --save\n```\n\n<a name=\"usage\"></a>\n## Usage\n```js\nconst http = require('http')\nconst router = require('find-my-way')()\n\nrouter.on('GET', '/', (req, res, params) => {\n  res.end('{\"message\":\"hello world\"}')\n})\n\nconst server = http.createServer((req, res) => {\n  router.lookup(req, res)\n})\n\nserver.listen(3000, err => {\n  if (err) throw err\n  console.log('Server listening on: http://localhost:3000')\n})\n```\n\n<a name=\"api\"></a>\n## API\n<a name=\"constructor\"></a>\n#### FindMyway([options])\nInstance a new router.<br>\nYou can pass a default route with the option `defaultRoute`.\n```js\nconst router = require('find-my-way')({\n  defaultRoute: (req, res) => {\n    res.statusCode = 404\n    res.end()\n  }\n})\n```\n\nIn case of a badly formatted url *(eg: `/hello/%world`)*, by default `find-my-way` will invoke the `defaultRoute`, unless you specify the `onBadUrl` option:\n```js\nconst router = require('find-my-way')({\n  onBadUrl: (path, req, res) => {\n    res.statusCode = 400\n    res.end(`Bad path: ${path}`)\n  }\n})\n```\n\nTrailing slashes can be ignored by supplying the `ignoreTrailingSlash` option:\n```js\nconst router = require('find-my-way')({\n  ignoreTrailingSlash: true\n})\nfunction handler (req, res, params) {\n  res.end('foo')\n}\n// maps \"/foo/\" and \"/foo\" to `handler`\nrouter.on('GET', '/foo/', handler)\n```\n\nYou can set a custom length for parameters in parametric *(standard, regex and multi)* routes by using `maxParamLength` option, the default value is 100 characters.<br/>\n*If the maximum length limit is reached, the default route will be invoked.*\n```js\nconst router = require('find-my-way')({\n  maxParamLength: 500\n})\n```\n\nIf you are using a regex based route, `find-my-way` will throw an error if detects potentially catastrophic exponential-time regular expressions *(internally uses [`safe-regex2`](https://github.com/fastify/safe-regex2))*.<br/>\nIf you want to disable this behavior, pass the option `allowUnsafeRegex`.\n```js\nconst router = require('find-my-way')({\n  allowUnsafeRegex: true\n})\n```\n\nAccording to [RFC3986](https://tools.ietf.org/html/rfc3986#section-6.2.2.1), find-my-way is case sensitive by default.\nYou can disable this by setting the `caseSensitive` option to `false`:\nin that case, all paths will be matched as lowercase, but the route parameters or wildcards will maintain their original letter casing. You can turn off case sensitivity with:\n\n```js\nconst router = require('find-my-way')({\n  caseSensitive: false\n})\n```\n\n<a name=\"custom-versioning\"></a>\nBy default `find-my-way` uses [accept-version](./lib/accept-version.js) strategy to match requests with different versions of the handlers. The matching logic of that strategy is explained [below](#semver). It is possible to define the alternative strategy:\n```js\nconst customVersioning = {\n  // storage factory\n  storage: function () {\n    let versions = {}\n    return {\n      get: (version) => { return versions[version] || null },\n      set: (version, store) => { versions[version] = store },\n      del: (version) => { delete versions[version] },\n      empty: () => { versions = {} }\n    }\n  },\n  deriveVersion: (req, ctx) => {\n    return req.headers['accept']\n  }\n}\n\nconst router = FindMyWay({ versioning: customVersioning });\n```\n\nThe custom strategy object should contain next properties:\n* `storage` - the factory function for the Storage of the handlers based on their version.\n* `deriveVersion` - the function to determine the version based on the request\n\nThe signature of the functions and objects must match the one from the example above.\n\n\n*Please, be aware, if you use custom versioning strategy - you use it on your own risk. This can lead both to the performance degradation and bugs which are not related to `find-my-way` itself*\n\n<a name=\"on\"></a>\n#### on(method, path, [opts], handler, [store])\nRegister a new route.\n```js\nrouter.on('GET', '/example', (req, res, params) => {\n  // your code\n})\n```\nLast argument, `store` is used to pass an object that you can access later inside the handler function. If needed, `store` can be updated.\n```js\nrouter.on('GET', '/example', (req, res, params, store) => {\n  assert.equal(store, { message: 'hello world' })\n}, { message: 'hello world' })\n```\n\n##### Versioned routes\n\nIf needed you can provide a `version` option, which will allow you to declare multiple versions of the same route. If you never configure a versioned route, the `'Accept-Version'` header will be ignored.\n\nRemember to set a [Vary](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Vary) header in your responses with the value you are using for deifning the versioning (e.g.: 'Accept-Version'), to prevent cache poisoning attacks. You can also configure this as part your Proxy/CDN.\n\n###### default\n<a name=\"semver\"></a>\nDefault versioning strategy is called `accept-version` and it follows the [semver](https://semver.org/) specification.<br/>\nWhen using `lookup`, `find-my-way` will automatically detect the `Accept-Version` header and route the request accordingly.<br/>\nInternally `find-my-way` uses the [`semver-store`](https://github.com/delvedor/semver-store) to get the correct version of the route; *advanced ranges* and *pre-releases* currently are not supported.<br/>\n*Be aware that using this feature will cause a degradation of the overall performances of the router.*\n```js\nrouter.on('GET', '/example', { version: '1.2.0' }, (req, res, params) => {\n  res.end('Hello from 1.2.0!')\n})\n\nrouter.on('GET', '/example', { version: '2.4.0' }, (req, res, params) => {\n  res.end('Hello from 2.4.0!')\n})\n\n// The 'Accept-Version' header could be '1.2.0' as well as '*', '2.x' or '2.4.x'\n```\nIf you declare multiple versions with the same *major* or *minor* `find-my-way` will always choose the highest compatible with the `Accept-Version` header value.\n\n###### custom\nIt's also possible to define a [custom versioning strategy](#custom-versioning) during the `find-my-way` initialization. In this case the logic of matching the request to the specific handler depends on the versioning strategy you use.\n\n##### on(methods[], path, [opts], handler, [store])\nRegister a new route for each method specified in the `methods` array.\nIt comes handy when you need to declare multiple routes with the same handler but different methods.\n```js\nrouter.on(['GET', 'POST'], '/example', (req, res, params) => {\n  // your code\n})\n```\n\n<a name=\"supported-path-formats\"></a>\n##### Supported path formats\nTo register a **parametric** path, use the *colon* before the parameter name. For **wildcard** use the *star*.\n*Remember that static routes are always inserted before parametric and wildcard.*\n\n```js\n// parametric\nrouter.on('GET', '/example/:userId', (req, res, params) => {}))\nrouter.on('GET', '/example/:userId/:secretToken', (req, res, params) => {}))\n\n// wildcard\nrouter.on('GET', '/example/*', (req, res, params) => {}))\n```\n\nRegular expression routes are supported as well, but pay attention, RegExp are very expensive in term of performance!<br>\nIf you want to declare a regular expression route, you must put the regular expression inside round parenthesis after the parameter name.\n```js\n// parametric with regexp\nrouter.on('GET', '/example/:file(^\\\\d+).png', () => {}))\n```\n\nIt's possible to define more than one parameter within the same couple of slash (\"/\"). Such as:\n```js\nrouter.on('GET', '/example/near/:lat-:lng/radius/:r', (req, res, params) => {}))\n```\n*Remember in this case to use the dash (\"-\") as parameters separator.*\n\nFinally it's possible to have multiple parameters with RegExp.\n```js\nrouter.on('GET', '/example/at/:hour(^\\\\d{2})h:minute(^\\\\d{2})m', (req, res, params) => {}))\n```\nIn this case as parameter separator it's possible to use whatever character is not matched by the regular expression.\n\nHaving a route with multiple parameters may affect negatively the performance, so prefer single parameter approach whenever possible, especially on routes which are on the hot path of your application.\n\n<a name=\"match-order\"></a>\n##### Match order\n\nThe routing algorithm matches one chunk at a time (where the chunk is a string between two slashes),\nthis means that it cannot know if a route is static or dynamic until it finishes to match the URL.\n\nThe chunks are matched in the following order:\n\n1. static\n1. parametric\n1. wildcards\n1. parametric(regex)\n1. multi parametric(regex)\n\nSo if you declare the following routes\n\n- `/:userId/foo/bar`\n- `/33/:a(^.*$)/:b`\n\nand the URL of the incoming request is /33/foo/bar,\nthe second route will be matched because the first chunk (33) matches the static chunk.\nIf the URL would have been /32/foo/bar, the first route would have been matched.\n\n<a name=\"supported-methods\"></a>\n##### Supported methods\nThe router is able to route all HTTP methods defined by [`http` core module](https://nodejs.org/api/http.html#http_http_methods).\n\n<a name=\"off\"></a>\n#### off(method, path)\nDeregister a route.\n```js\nrouter.off('GET', '/example')\n// => { handler: Function, params: Object, store: Object}\n// => null\n```\n\n##### off(methods[], path, handler, [store])\nDeregister a route for each method specified in the `methods` array.\nIt comes handy when you need to deregister multiple routes with the same path but different methods.\n```js\nrouter.off(['GET', 'POST'], '/example')\n// => [{ handler: Function, params: Object, store: Object}]\n// => null\n```\n\n<a name=\"reset\"></a>\n#### reset()\nEmpty router.\n```js\nrouter.reset()\n```\n\n##### Caveats\n* It's not possible to register two routes which differs only for their parameters, because internally they would be seen as the same route. In a such case you'll get an early error during the route registration phase. An example is worth thousand words:\n```js\nconst findMyWay = FindMyWay({\n  defaultRoute: (req, res) => {}\n})\n\nfindMyWay.on('GET', '/user/:userId(^\\\\d+)', (req, res, params) => {})\n\nfindMyWay.on('GET', '/user/:username(^[a-z]+)', (req, res, params) => {})\n// Method 'GET' already declared for route ':'\n```\n\n<a name=\"shorthand-methods\"></a>\n##### Shorthand methods\nIf you want an even nicer api, you can also use the shorthand methods to declare your routes.\n\nFor each HTTP supported method, there's the shorthand method. For example:\n```js\nrouter.get(path, handler [, store])\nrouter.delete(path, handler [, store])\nrouter.head(path, handler [, store])\nrouter.patch(path, handler [, store])\nrouter.post(path, handler [, store])\nrouter.put(path, handler [, store])\nrouter.options(path, handler [, store])\n// ...\n```\n\nIf you need a route that supports *all* methods you can use the `all` api.\n```js\nrouter.all(path, handler [, store])\n```\n\n<a name=\"lookup\"></a>\n#### lookup(request, response, [context])\nStart a new search, `request` and `response` are the server req/res objects.<br>\nIf a route is found it will automatically call the handler, otherwise the default route will be called.<br>\nThe url is sanitized internally, all the parameters and wildcards are decoded automatically.\n```js\nrouter.lookup(req, res)\n```\n\n`lookup` accepts an optional context which will be the value of `this` when executing a handler\n```js\nrouter.on('GET', '*', function(req, res) {\n  res.end(this.greeting);\n})\nrouter.lookup(req, res, { greeting: 'Hello, World!' })\n```\n\n<a name=\"find\"></a>\n#### find(method, path [, version])\nReturn (if present) the route registered in *method:path*.<br>\nThe path must be sanitized, all the parameters and wildcards are decoded automatically.<br/>\nYou can also pass an optional version string. In case of the default versioning strategy it should be conform to the [semver](https://semver.org/) specification.\n```js\nrouter.find('GET', '/example')\n// => { handler: Function, params: Object, store: Object}\n// => null\n\nrouter.find('GET', '/example', '1.x')\n// => { handler: Function, params: Object, store: Object}\n// => null\n```\n\n<a name=\"pretty-print\"></a>\n#### prettyPrint()\nPrints the representation of the internal radix tree, useful for debugging.\n```js\nfindMyWay.on('GET', '/test', () => {})\nfindMyWay.on('GET', '/test/hello', () => {})\nfindMyWay.on('GET', '/hello/world', () => {})\n\nconsole.log(findMyWay.prettyPrint())\n// \u2514\u2500\u2500 /\n//   \u251c\u2500\u2500 test (GET)\n//   \u2502   \u2514\u2500\u2500 /hello (GET)\n//   \u2514\u2500\u2500 hello/world (GET)\n```\n\n<a name=\"routes\"></a>\n#### routes\nReturn the all routes **registered** at moment, useful for debugging.\n\n```js\nconst findMyWay = require('find-my-way')()\n\nfindMyWay.on('GET', '/test', () => {})\nfindMyWay.on('GET', '/test/hello', () => {})\n\nconsole.log(findMyWay.routes)\n// Will print\n// [\n//   {\n//     method: 'GET',\n//     path: '/test',\n//     opts: {},\n//     handler: [Function],\n//     store: undefined\n//   },\n//   {\n//     method: 'GET',\n//     path: '/test/hello',\n//     opts: {},\n//     handler: [Function],\n//     store: undefined\n//   }\n// ]\n```\n\n<a name=\"acknowledgements\"></a>\n## Acknowledgements\n\nIt is inspired by the [echo](https://github.com/labstack/echo) router, some parts have been extracted from [trekjs](https://github.com/trekjs) router.\n\n<a name=\"sponsor\"></a>\n#### Past sponsor\n\n- [LetzDoIt](http://www.letzdoitapp.com/)\n\n<a name=\"license\"></a>\n## License\n**[find-my-way - MIT](https://github.com/delvedor/find-my-way/blob/master/LICENSE)**<br>\n**[trekjs/router - MIT](https://github.com/trekjs/router/blob/master/LICENSE)**\n\nCopyright \u00a9 2017-2019 Tomas Della Vedova\n", "'use strict'\n\n/*\n  Char codes:\n    '#': 35\n    '*': 42\n    '-': 45\n    '/': 47\n    ':': 58\n    ';': 59\n    '?': 63\n*/\n\nconst assert = require('assert')\nconst http = require('http')\nconst fastDecode = require('fast-decode-uri-component')\nconst isRegexSafe = require('safe-regex2')\nconst { flattenNode, compressFlattenedNode, prettyPrintFlattenedNode } = require('./lib/pretty-print')\nconst Node = require('./node')\nconst NODE_TYPES = Node.prototype.types\nconst httpMethods = http.METHODS\nconst FULL_PATH_REGEXP = /^https?:\\/\\/.*?\\//\n\nif (!isRegexSafe(FULL_PATH_REGEXP)) {\n  throw new Error('the FULL_PATH_REGEXP is not safe, update this module')\n}\n\nconst acceptVersionStrategy = require('./lib/accept-version')\n\nfunction Router (opts) {\n  if (!(this instanceof Router)) {\n    return new Router(opts)\n  }\n  opts = opts || {}\n\n  if (opts.defaultRoute) {\n    assert(typeof opts.defaultRoute === 'function', 'The default route must be a function')\n    this.defaultRoute = opts.defaultRoute\n  } else {\n    this.defaultRoute = null\n  }\n\n  if (opts.onBadUrl) {\n    assert(typeof opts.onBadUrl === 'function', 'The bad url handler must be a function')\n    this.onBadUrl = opts.onBadUrl\n  } else {\n    this.onBadUrl = null\n  }\n\n  this.caseSensitive = opts.caseSensitive === undefined ? true : opts.caseSensitive\n  this.ignoreTrailingSlash = opts.ignoreTrailingSlash || false\n  this.maxParamLength = opts.maxParamLength || 100\n  this.allowUnsafeRegex = opts.allowUnsafeRegex || false\n  this.versioning = opts.versioning || acceptVersionStrategy(false)\n  this.trees = {}\n  this.routes = []\n}\n\nRouter.prototype.on = function on (method, path, opts, handler, store) {\n  if (typeof opts === 'function') {\n    if (handler !== undefined) {\n      store = handler\n    }\n    handler = opts\n    opts = {}\n  }\n  // path validation\n  assert(typeof path === 'string', 'Path should be a string')\n  assert(path.length > 0, 'The path could not be empty')\n  assert(path[0] === '/' || path[0] === '*', 'The first character of a path should be `/` or `*`')\n  // handler validation\n  assert(typeof handler === 'function', 'Handler should be a function')\n\n  this._on(method, path, opts, handler, store)\n\n  if (this.ignoreTrailingSlash && path !== '/' && !path.endsWith('*')) {\n    if (path.endsWith('/')) {\n      this._on(method, path.slice(0, -1), opts, handler, store)\n    } else {\n      this._on(method, path + '/', opts, handler, store)\n    }\n  }\n}\n\nRouter.prototype._on = function _on (method, path, opts, handler, store) {\n  if (Array.isArray(method)) {\n    for (var k = 0; k < method.length; k++) {\n      this._on(method[k], path, opts, handler, store)\n    }\n    return\n  }\n\n  // method validation\n  assert(typeof method === 'string', 'Method should be a string')\n  assert(httpMethods.indexOf(method) !== -1, `Method '${method}' is not an http method.`)\n\n  // version validation\n  if (opts.version !== undefined) {\n    assert(typeof opts.version === 'string', 'Version should be a string')\n  }\n\n  const params = []\n  var j = 0\n\n  this.routes.push({\n    method: method,\n    path: path,\n    opts: opts,\n    handler: handler,\n    store: store\n  })\n\n  const version = opts.version\n  if (version != null && this.versioning.disabled) {\n    this.versioning = acceptVersionStrategy(true)\n  }\n\n  for (var i = 0, len = path.length; i < len; i++) {\n    // search for parametric or wildcard routes\n    // parametric route\n    if (path.charCodeAt(i) === 58) {\n      var nodeType = NODE_TYPES.PARAM\n      j = i + 1\n      var staticPart = path.slice(0, i)\n\n      if (this.caseSensitive === false) {\n        staticPart = staticPart.toLowerCase()\n      }\n\n      // add the static part of the route to the tree\n      this._insert(method, staticPart, NODE_TYPES.STATIC, null, null, null, null, version)\n\n      // isolate the parameter name\n      var isRegex = false\n      while (i < len && path.charCodeAt(i) !== 47) {\n        isRegex = isRegex || path[i] === '('\n        if (isRegex) {\n          i = getClosingParenthensePosition(path, i) + 1\n          break\n        } else if (path.charCodeAt(i) !== 45) {\n          i++\n        } else {\n          break\n        }\n      }\n\n      if (isRegex && (i === len || path.charCodeAt(i) === 47)) {\n        nodeType = NODE_TYPES.REGEX\n      } else if (i < len && path.charCodeAt(i) !== 47) {\n        nodeType = NODE_TYPES.MULTI_PARAM\n      }\n\n      var parameter = path.slice(j, i)\n      var regex = isRegex ? parameter.slice(parameter.indexOf('('), i) : null\n      if (isRegex) {\n        regex = new RegExp(regex)\n        if (!this.allowUnsafeRegex) {\n          assert(isRegexSafe(regex), `The regex '${regex.toString()}' is not safe!`)\n        }\n      }\n      params.push(parameter.slice(0, isRegex ? parameter.indexOf('(') : i))\n\n      path = path.slice(0, j) + path.slice(i)\n      i = j\n      len = path.length\n\n      // if the path is ended\n      if (i === len) {\n        var completedPath = path.slice(0, i)\n        if (this.caseSensitive === false) {\n          completedPath = completedPath.toLowerCase()\n        }\n        return this._insert(method, completedPath, nodeType, params, handler, store, regex, version)\n      }\n      // add the parameter and continue with the search\n      staticPart = path.slice(0, i)\n      if (this.caseSensitive === false) {\n        staticPart = staticPart.toLowerCase()\n      }\n      this._insert(method, staticPart, nodeType, params, null, null, regex, version)\n\n      i--\n    // wildcard route\n    } else if (path.charCodeAt(i) === 42) {\n      this._insert(method, path.slice(0, i), NODE_TYPES.STATIC, null, null, null, null, version)\n      // add the wildcard parameter\n      params.push('*')\n      return this._insert(method, path.slice(0, len), NODE_TYPES.MATCH_ALL, params, handler, store, null, version)\n    }\n  }\n\n  if (this.caseSensitive === false) {\n    path = path.toLowerCase()\n  }\n\n  // static route\n  this._insert(method, path, NODE_TYPES.STATIC, params, handler, store, null, version)\n}\n\nRouter.prototype._insert = function _insert (method, path, kind, params, handler, store, regex, version) {\n  const route = path\n  var prefix = ''\n  var pathLen = 0\n  var prefixLen = 0\n  var len = 0\n  var max = 0\n  var node = null\n\n  var currentNode = this.trees[method]\n  if (typeof currentNode === 'undefined') {\n    currentNode = new Node({ method: method, versions: this.versioning.storage() })\n    this.trees[method] = currentNode\n  }\n\n  while (true) {\n    prefix = currentNode.prefix\n    prefixLen = prefix.length\n    pathLen = path.length\n    len = 0\n\n    // search for the longest common prefix\n    max = pathLen < prefixLen ? pathLen : prefixLen\n    while (len < max && path[len] === prefix[len]) len++\n\n    // the longest common prefix is smaller than the current prefix\n    // let's split the node and add a new child\n    if (len < prefixLen) {\n      node = new Node(\n        {\n          method: method,\n          prefix: prefix.slice(len),\n          children: currentNode.children,\n          kind: currentNode.kind,\n          handler: currentNode.handler,\n          regex: currentNode.regex,\n          versions: currentNode.versions\n        }\n      )\n      if (currentNode.wildcardChild !== null) {\n        node.wildcardChild = currentNode.wildcardChild\n      }\n\n      // reset the parent\n      currentNode\n        .reset(prefix.slice(0, len), this.versioning.storage())\n        .addChild(node)\n\n      // if the longest common prefix has the same length of the current path\n      // the handler should be added to the current node, to a child otherwise\n      if (len === pathLen) {\n        if (version) {\n          assert(!currentNode.getVersionHandler(version), `Method '${method}' already declared for route '${route}' version '${version}'`)\n          currentNode.setVersionHandler(version, handler, params, store)\n        } else {\n          assert(!currentNode.handler, `Method '${method}' already declared for route '${route}'`)\n          currentNode.setHandler(handler, params, store)\n        }\n        currentNode.kind = kind\n      } else {\n        node = new Node({\n          method: method,\n          prefix: path.slice(len),\n          kind: kind,\n          handlers: null,\n          regex: regex,\n          versions: this.versioning.storage()\n        })\n        if (version) {\n          node.setVersionHandler(version, handler, params, store)\n        } else {\n          node.setHandler(handler, params, store)\n        }\n        currentNode.addChild(node)\n      }\n\n    // the longest common prefix is smaller than the path length,\n    // but is higher than the prefix\n    } else if (len < pathLen) {\n      // remove the prefix\n      path = path.slice(len)\n      // check if there is a child with the label extracted from the new path\n      node = currentNode.findByLabel(path)\n      // there is a child within the given label, we must go deepen in the tree\n      if (node) {\n        currentNode = node\n        continue\n      }\n      // there are not children within the given label, let's create a new one!\n      node = new Node({ method: method, prefix: path, kind: kind, regex: regex, versions: this.versioning.storage() })\n      if (version) {\n        node.setVersionHandler(version, handler, params, store)\n      } else {\n        node.setHandler(handler, params, store)\n      }\n\n      currentNode.addChild(node)\n\n    // the node already exist\n    } else if (handler) {\n      if (version) {\n        assert(!currentNode.getVersionHandler(version), `Method '${method}' already declared for route '${route}' version '${version}'`)\n        currentNode.setVersionHandler(version, handler, params, store)\n      } else {\n        assert(!currentNode.handler, `Method '${method}' already declared for route '${route}'`)\n        currentNode.setHandler(handler, params, store)\n      }\n    }\n    return\n  }\n}\n\nRouter.prototype.reset = function reset () {\n  this.trees = {}\n  this.routes = []\n}\n\nRouter.prototype.off = function off (method, path) {\n  var self = this\n\n  if (Array.isArray(method)) {\n    return method.map(function (method) {\n      return self.off(method, path)\n    })\n  }\n\n  // method validation\n  assert(typeof method === 'string', 'Method should be a string')\n  assert(httpMethods.indexOf(method) !== -1, `Method '${method}' is not an http method.`)\n  // path validation\n  assert(typeof path === 'string', 'Path should be a string')\n  assert(path.length > 0, 'The path could not be empty')\n  assert(path[0] === '/' || path[0] === '*', 'The first character of a path should be `/` or `*`')\n\n  // Rebuild tree without the specific route\n  const ignoreTrailingSlash = this.ignoreTrailingSlash\n  var newRoutes = self.routes.filter(function (route) {\n    if (!ignoreTrailingSlash) {\n      return !(method === route.method && path === route.path)\n    }\n    if (path.endsWith('/')) {\n      const routeMatches = path === route.path || path.slice(0, -1) === route.path\n      return !(method === route.method && routeMatches)\n    }\n    const routeMatches = path === route.path || (path + '/') === route.path\n    return !(method === route.method && routeMatches)\n  })\n  if (ignoreTrailingSlash) {\n    newRoutes = newRoutes.filter(function (route, i, ar) {\n      if (route.path.endsWith('/') && i < ar.length - 1) {\n        return route.path.slice(0, -1) !== ar[i + 1].path\n      } else if (route.path.endsWith('/') === false && i < ar.length - 1) {\n        return (route.path + '/') !== ar[i + 1].path\n      }\n      return true\n    })\n  }\n  self.reset()\n  newRoutes.forEach(function (route) {\n    self.on(route.method, route.path, route.opts, route.handler, route.store)\n  })\n}\n\nRouter.prototype.lookup = function lookup (req, res, ctx) {\n  var handle = this.find(req.method, sanitizeUrl(req.url), this.versioning.deriveVersion(req, ctx))\n  if (handle === null) return this._defaultRoute(req, res, ctx)\n  return ctx === undefined\n    ? handle.handler(req, res, handle.params, handle.store)\n    : handle.handler.call(ctx, req, res, handle.params, handle.store)\n}\n\nRouter.prototype.find = function find (method, path, version) {\n  var currentNode = this.trees[method]\n  if (!currentNode) return null\n\n  if (path.charCodeAt(0) !== 47) { // 47 is '/'\n    path = path.replace(FULL_PATH_REGEXP, '/')\n  }\n\n  var originalPath = path\n  var originalPathLength = path.length\n\n  if (this.caseSensitive === false) {\n    path = path.toLowerCase()\n  }\n\n  var maxParamLength = this.maxParamLength\n  var wildcardNode = null\n  var pathLenWildcard = 0\n  var decoded = null\n  var pindex = 0\n  var params = []\n  var i = 0\n  var idxInOriginalPath = 0\n\n  while (true) {\n    var pathLen = path.length\n    var prefix = currentNode.prefix\n    var prefixLen = prefix.length\n    var len = 0\n    var previousPath = path\n    // found the route\n    if (pathLen === 0 || path === prefix) {\n      var handle = version === undefined\n        ? currentNode.handler\n        : currentNode.getVersionHandler(version)\n      if (handle !== null && handle !== undefined) {\n        var paramsObj = {}\n        if (handle.paramsLength > 0) {\n          var paramNames = handle.params\n\n          for (i = 0; i < handle.paramsLength; i++) {\n            paramsObj[paramNames[i]] = params[i]\n          }\n        }\n\n        return {\n          handler: handle.handler,\n          params: paramsObj,\n          store: handle.store\n        }\n      }\n    }\n\n    // search for the longest common prefix\n    i = pathLen < prefixLen ? pathLen : prefixLen\n    while (len < i && path.charCodeAt(len) === prefix.charCodeAt(len)) len++\n\n    if (len === prefixLen) {\n      path = path.slice(len)\n      pathLen = path.length\n      idxInOriginalPath += len\n    }\n\n    var node = version === undefined\n      ? currentNode.findChild(path)\n      : currentNode.findVersionChild(version, path)\n\n    if (node === null) {\n      node = currentNode.parametricBrother\n      if (node === null) {\n        return this._getWildcardNode(wildcardNode, originalPath, pathLenWildcard)\n      }\n\n      var goBack = previousPath.charCodeAt(0) === 47 ? previousPath : '/' + previousPath\n      if (originalPath.indexOf(goBack) === -1) {\n        // we need to know the outstanding path so far from the originalPath since the last encountered \"/\" and assign it to previousPath.\n        // e.g originalPath: /aa/bbb/cc, path: bb/cc\n        // outstanding path: /bbb/cc\n        var pathDiff = originalPath.slice(0, originalPathLength - pathLen)\n        previousPath = pathDiff.slice(pathDiff.lastIndexOf('/') + 1, pathDiff.length) + path\n      }\n      idxInOriginalPath = idxInOriginalPath -\n        (previousPath.length - path.length)\n      path = previousPath\n      pathLen = previousPath.length\n      len = prefixLen\n    }\n\n    var kind = node.kind\n\n    // static route\n    if (kind === NODE_TYPES.STATIC) {\n      // if exist, save the wildcard child\n      if (currentNode.wildcardChild !== null) {\n        wildcardNode = currentNode.wildcardChild\n        pathLenWildcard = pathLen\n      }\n      currentNode = node\n      continue\n    }\n\n    if (len !== prefixLen) {\n      return this._getWildcardNode(wildcardNode, originalPath, pathLenWildcard)\n    }\n\n    // if exist, save the wildcard child\n    if (currentNode.wildcardChild !== null) {\n      wildcardNode = currentNode.wildcardChild\n      pathLenWildcard = pathLen\n    }\n\n    // parametric route\n    if (kind === NODE_TYPES.PARAM) {\n      currentNode = node\n      i = path.indexOf('/')\n      if (i === -1) i = pathLen\n      if (i > maxParamLength) return null\n      decoded = fastDecode(originalPath.slice(idxInOriginalPath, idxInOriginalPath + i))\n      if (decoded === null) {\n        return this.onBadUrl !== null\n          ? this._onBadUrl(originalPath.slice(idxInOriginalPath, idxInOriginalPath + i))\n          : null\n      }\n      params[pindex++] = decoded\n      path = path.slice(i)\n      idxInOriginalPath += i\n      continue\n    }\n\n    // wildcard route\n    if (kind === NODE_TYPES.MATCH_ALL) {\n      decoded = fastDecode(originalPath.slice(idxInOriginalPath))\n      if (decoded === null) {\n        return this.onBadUrl !== null\n          ? this._onBadUrl(originalPath.slice(idxInOriginalPath))\n          : null\n      }\n      params[pindex] = decoded\n      currentNode = node\n      path = ''\n      continue\n    }\n\n    // parametric(regex) route\n    if (kind === NODE_TYPES.REGEX) {\n      currentNode = node\n      i = path.indexOf('/')\n      if (i === -1) i = pathLen\n      if (i > maxParamLength) return null\n      decoded = fastDecode(originalPath.slice(idxInOriginalPath, idxInOriginalPath + i))\n      if (decoded === null) {\n        return this.onBadUrl !== null\n          ? this._onBadUrl(originalPath.slice(idxInOriginalPath, idxInOriginalPath + i))\n          : null\n      }\n      if (!node.regex.test(decoded)) return null\n      params[pindex++] = decoded\n      path = path.slice(i)\n      idxInOriginalPath += i\n      continue\n    }\n\n    // multiparametric route\n    if (kind === NODE_TYPES.MULTI_PARAM) {\n      currentNode = node\n      i = 0\n      if (node.regex !== null) {\n        var matchedParameter = path.match(node.regex)\n        if (matchedParameter === null) return null\n        i = matchedParameter[1].length\n      } else {\n        while (i < pathLen && path.charCodeAt(i) !== 47 && path.charCodeAt(i) !== 45) i++\n        if (i > maxParamLength) return null\n      }\n      decoded = fastDecode(originalPath.slice(idxInOriginalPath, idxInOriginalPath + i))\n      if (decoded === null) {\n        return this.onBadUrl !== null\n          ? this._onBadUrl(originalPath.slice(idxInOriginalPath, idxInOriginalPath + i))\n          : null\n      }\n      params[pindex++] = decoded\n      path = path.slice(i)\n      idxInOriginalPath += i\n      continue\n    }\n\n    wildcardNode = null\n  }\n}\n\nRouter.prototype._getWildcardNode = function (node, path, len) {\n  if (node === null) return null\n  var decoded = fastDecode(path.slice(-len))\n  if (decoded === null) {\n    return this.onBadUrl !== null\n      ? this._onBadUrl(path.slice(-len))\n      : null\n  }\n  var handle = node.handler\n  if (handle !== null && handle !== undefined) {\n    return {\n      handler: handle.handler,\n      params: { '*': decoded },\n      store: handle.store\n    }\n  }\n  return null\n}\n\nRouter.prototype._defaultRoute = function (req, res, ctx) {\n  if (this.defaultRoute !== null) {\n    return ctx === undefined\n      ? this.defaultRoute(req, res)\n      : this.defaultRoute.call(ctx, req, res)\n  } else {\n    res.statusCode = 404\n    res.end()\n  }\n}\n\nRouter.prototype._onBadUrl = function (path) {\n  const onBadUrl = this.onBadUrl\n  return {\n    handler: (req, res, ctx) => onBadUrl(path, req, res),\n    params: {},\n    store: null\n  }\n}\n\nRouter.prototype.prettyPrint = function () {\n  const root = {\n    prefix: '/',\n    nodes: [],\n    children: {}\n  }\n\n  for (const node of Object.values(this.trees)) {\n    if (node) {\n      flattenNode(root, node)\n    }\n  }\n\n  compressFlattenedNode(root)\n\n  return prettyPrintFlattenedNode(root, '', true)\n}\n\nfor (var i in http.METHODS) {\n  /* eslint no-prototype-builtins: \"off\" */\n  if (!http.METHODS.hasOwnProperty(i)) continue\n  const m = http.METHODS[i]\n  const methodName = m.toLowerCase()\n\n  if (Router.prototype[methodName]) throw new Error('Method already exists: ' + methodName)\n\n  Router.prototype[methodName] = function (path, handler, store) {\n    return this.on(m, path, handler, store)\n  }\n}\n\nRouter.prototype.all = function (path, handler, store) {\n  this.on(httpMethods, path, handler, store)\n}\n\nmodule.exports = Router\n\nfunction sanitizeUrl (url) {\n  for (var i = 0, len = url.length; i < len; i++) {\n    var charCode = url.charCodeAt(i)\n    // Some systems do not follow RFC and separate the path and query\n    // string with a `;` character (code 59), e.g. `/foo;jsessionid=123456`.\n    // Thus, we need to split on `;` as well as `?` and `#`.\n    if (charCode === 63 || charCode === 59 || charCode === 35) {\n      return url.slice(0, i)\n    }\n  }\n  return url\n}\n\nfunction getClosingParenthensePosition (path, idx) {\n  // `path.indexOf()` will always return the first position of the closing parenthese,\n  // but it's inefficient for grouped or wrong regexp expressions.\n  // see issues #62 and #63 for more info\n\n  var parentheses = 1\n\n  while (idx < path.length) {\n    idx++\n\n    // ignore skipped chars\n    if (path[idx] === '\\\\') {\n      idx++\n      continue\n    }\n\n    if (path[idx] === ')') {\n      parentheses--\n    } else if (path[idx] === '(') {\n      parentheses++\n    }\n\n    if (!parentheses) return idx\n  }\n\n  throw new TypeError('Invalid regexp expression in \"' + path + '\"')\n}\n", "'use strict'\n\nconst SemVerStore = require('semver-store')\n\nfunction build (enabled) {\n  if (enabled) {\n    return {\n      storage: SemVerStore,\n      deriveVersion: function (req, ctx) {\n        return req.headers['accept-version']\n      }\n    }\n  }\n  return {\n    storage: SemVerStore,\n    deriveVersion: function (req, ctx) {},\n    disabled: true\n  }\n}\n\nmodule.exports = build\n", "'use strict'\n\nconst t = require('tap')\nconst test = t.test\nconst FindMyWay = require('../')\nconst noop = () => {}\n\ntest('A route could support multiple versions (find) / 1', t => {\n  t.plan(7)\n\n  const findMyWay = FindMyWay()\n\n  findMyWay.on('GET', '/', { version: '1.2.3' }, noop)\n  findMyWay.on('GET', '/', { version: '3.2.0' }, noop)\n\n  t.ok(findMyWay.find('GET', '/', '1.x'))\n  t.ok(findMyWay.find('GET', '/', '1.2.3'))\n  t.ok(findMyWay.find('GET', '/', '3.x'))\n  t.ok(findMyWay.find('GET', '/', '3.2.0'))\n  t.notOk(findMyWay.find('GET', '/', '2.x'))\n  t.notOk(findMyWay.find('GET', '/', '2.3.4'))\n  t.notOk(findMyWay.find('GET', '/', '3.2.1'))\n})\n\ntest('A route could support multiple versions (find) / 2', t => {\n  t.plan(7)\n\n  const findMyWay = FindMyWay()\n\n  findMyWay.on('GET', '/test', { version: '1.2.3' }, noop)\n  findMyWay.on('GET', '/test', { version: '3.2.0' }, noop)\n\n  t.ok(findMyWay.find('GET', '/test', '1.x'))\n  t.ok(findMyWay.find('GET', '/test', '1.2.3'))\n  t.ok(findMyWay.find('GET', '/test', '3.x'))\n  t.ok(findMyWay.find('GET', '/test', '3.2.0'))\n  t.notOk(findMyWay.find('GET', '/test', '2.x'))\n  t.notOk(findMyWay.find('GET', '/test', '2.3.4'))\n  t.notOk(findMyWay.find('GET', '/test', '3.2.1'))\n})\n\ntest('A route could support multiple versions (find) / 3', t => {\n  t.plan(10)\n\n  const findMyWay = FindMyWay()\n\n  findMyWay.on('GET', '/test/:id/hello', { version: '1.2.3' }, noop)\n  findMyWay.on('GET', '/test/:id/hello', { version: '3.2.0' }, noop)\n  findMyWay.on('GET', '/test/name/hello', { version: '4.0.0' }, noop)\n\n  t.ok(findMyWay.find('GET', '/test/1234/hello', '1.x'))\n  t.ok(findMyWay.find('GET', '/test/1234/hello', '1.2.3'))\n  t.ok(findMyWay.find('GET', '/test/1234/hello', '3.x'))\n  t.ok(findMyWay.find('GET', '/test/1234/hello', '3.2.0'))\n  t.ok(findMyWay.find('GET', '/test/name/hello', '4.x'))\n  t.ok(findMyWay.find('GET', '/test/name/hello', '3.x'))\n  t.notOk(findMyWay.find('GET', '/test/1234/hello', '2.x'))\n  t.notOk(findMyWay.find('GET', '/test/1234/hello', '2.3.4'))\n  t.notOk(findMyWay.find('GET', '/test/1234/hello', '3.2.1'))\n  t.notOk(findMyWay.find('GET', '/test/1234/hello', '4.x'))\n})\n\ntest('A route could support multiple versions (find) / 4', t => {\n  t.plan(8)\n\n  const findMyWay = FindMyWay()\n\n  findMyWay.on('GET', '/test/*', { version: '1.2.3' }, noop)\n  findMyWay.on('GET', '/test/hello', { version: '3.2.0' }, noop)\n\n  t.ok(findMyWay.find('GET', '/test/1234/hello', '1.x'))\n  t.ok(findMyWay.find('GET', '/test/1234/hello', '1.2.3'))\n  t.ok(findMyWay.find('GET', '/test/hello', '3.x'))\n  t.ok(findMyWay.find('GET', '/test/hello', '3.2.0'))\n  t.notOk(findMyWay.find('GET', '/test/1234/hello', '3.2.0'))\n  t.notOk(findMyWay.find('GET', '/test/1234/hello', '3.x'))\n  t.notOk(findMyWay.find('GET', '/test/1234/hello', '2.x'))\n  t.notOk(findMyWay.find('GET', '/test/hello', '2.x'))\n})\n\ntest('A route could support multiple versions (find) / 5', t => {\n  t.plan(1)\n\n  const findMyWay = FindMyWay()\n\n  findMyWay.on('GET', '/', { version: '1.2.3' }, () => false)\n  findMyWay.on('GET', '/', { version: '3.2.0' }, () => true)\n\n  t.ok(findMyWay.find('GET', '/', '*').handler())\n})\n\ntest('Find with a version but without versioned routes', t => {\n  t.plan(1)\n\n  const findMyWay = FindMyWay()\n\n  findMyWay.on('GET', '/', noop)\n\n  t.notOk(findMyWay.find('GET', '/', '1.x'))\n})\n\ntest('A route could support multiple versions (lookup)', t => {\n  t.plan(7)\n\n  const findMyWay = FindMyWay({\n    defaultRoute: (req, res) => {\n      const versions = ['2.x', '2.3.4', '3.2.1']\n      t.ok(versions.indexOf(req.headers['accept-version']) > -1)\n    }\n  })\n\n  findMyWay.on('GET', '/', { version: '1.2.3' }, (req, res) => {\n    const versions = ['1.x', '1.2.3']\n    t.ok(versions.indexOf(req.headers['accept-version']) > -1)\n  })\n\n  findMyWay.on('GET', '/', { version: '3.2.0' }, (req, res) => {\n    const versions = ['3.x', '3.2.0']\n    t.ok(versions.indexOf(req.headers['accept-version']) > -1)\n  })\n\n  findMyWay.lookup({\n    method: 'GET',\n    url: '/',\n    headers: { 'accept-version': '1.x' }\n  }, null)\n\n  findMyWay.lookup({\n    method: 'GET',\n    url: '/',\n    headers: { 'accept-version': '1.2.3' }\n  }, null)\n\n  findMyWay.lookup({\n    method: 'GET',\n    url: '/',\n    headers: { 'accept-version': '3.x' }\n  }, null)\n\n  findMyWay.lookup({\n    method: 'GET',\n    url: '/',\n    headers: { 'accept-version': '3.2.0' }\n  }, null)\n\n  findMyWay.lookup({\n    method: 'GET',\n    url: '/',\n    headers: { 'accept-version': '2.x' }\n  }, null)\n\n  findMyWay.lookup({\n    method: 'GET',\n    url: '/',\n    headers: { 'accept-version': '2.3.4' }\n  }, null)\n\n  findMyWay.lookup({\n    method: 'GET',\n    url: '/',\n    headers: { 'accept-version': '3.2.1' }\n  }, null)\n})\n\ntest('It should always choose the highest version of a route', t => {\n  t.plan(3)\n\n  const findMyWay = FindMyWay()\n\n  findMyWay.on('GET', '/', { version: '2.3.0' }, (req, res) => {\n    t.fail('We should not be here')\n  })\n\n  findMyWay.on('GET', '/', { version: '2.4.0' }, (req, res) => {\n    t.pass('Yeah!')\n  })\n\n  findMyWay.on('GET', '/', { version: '3.3.0' }, (req, res) => {\n    t.pass('Yeah!')\n  })\n\n  findMyWay.on('GET', '/', { version: '3.2.0' }, (req, res) => {\n    t.fail('We should not be here')\n  })\n\n  findMyWay.on('GET', '/', { version: '3.2.2' }, (req, res) => {\n    t.fail('We should not be here')\n  })\n\n  findMyWay.on('GET', '/', { version: '4.4.0' }, (req, res) => {\n    t.fail('We should not be here')\n  })\n\n  findMyWay.on('GET', '/', { version: '4.3.2' }, (req, res) => {\n    t.pass('Yeah!')\n  })\n\n  findMyWay.lookup({\n    method: 'GET',\n    url: '/',\n    headers: { 'accept-version': '2.x' }\n  }, null)\n\n  findMyWay.lookup({\n    method: 'GET',\n    url: '/',\n    headers: { 'accept-version': '3.x' }\n  }, null)\n\n  findMyWay.lookup({\n    method: 'GET',\n    url: '/',\n    headers: { 'accept-version': '4.3.x' }\n  }, null)\n})\n\ntest('Declare the same route with and without version', t => {\n  t.plan(2)\n\n  const findMyWay = FindMyWay()\n\n  findMyWay.on('GET', '/', noop)\n  findMyWay.on('GET', '/', { version: '1.2.0' }, noop)\n\n  t.ok(findMyWay.find('GET', '/', '1.x'))\n  t.ok(findMyWay.find('GET', '/'))\n})\n\ntest('It should throw if you declare multiple times the same route', t => {\n  t.plan(1)\n\n  const findMyWay = FindMyWay()\n\n  findMyWay.on('GET', '/', { version: '1.2.3' }, noop)\n\n  try {\n    findMyWay.on('GET', '/', { version: '1.2.3' }, noop)\n    t.fail('It should throw')\n  } catch (err) {\n    t.is(err.message, 'Method \\'GET\\' already declared for route \\'/\\' version \\'1.2.3\\'')\n  }\n})\n\ntest('Versioning won\\'t work if there are no versioned routes', t => {\n  t.plan(2)\n\n  const findMyWay = FindMyWay({\n    defaultRoute: (req, res) => {\n      t.fail('We should not be here')\n    }\n  })\n\n  findMyWay.on('GET', '/', (req, res) => {\n    t.pass('Yeah!')\n  })\n\n  findMyWay.lookup({\n    method: 'GET',\n    url: '/',\n    headers: { 'accept-version': '2.x' }\n  }, null)\n\n  findMyWay.lookup({\n    method: 'GET',\n    url: '/'\n  }, null)\n})\n"], "filenames": ["README.md", "index.js", "lib/accept-version.js", "test/version.default-versioning.test.js"], "buggy_code_start_loc": [147, 54, 5, 242], "buggy_code_end_loc": [148, 113, 10, 242], "fixing_code_start_loc": [147, 54, 5, 243], "fixing_code_end_loc": [150, 117, 22, 268], "type": "CWE-444", "message": "This affects the package find-my-way before 2.2.5, from 3.0.0 and before 3.0.5. It accepts the Accept-Version' header by default, and if versioned routes are not being used, this could lead to a denial of service. Accept-Version can be used as an unkeyed header in a cache poisoning attack.", "other": {"cve": {"id": "CVE-2020-7764", "sourceIdentifier": "report@snyk.io", "published": "2020-11-08T16:15:12.183", "lastModified": "2020-11-16T17:21:37.873", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "This affects the package find-my-way before 2.2.5, from 3.0.0 and before 3.0.5. It accepts the Accept-Version' header by default, and if versioned routes are not being used, this could lead to a denial of service. Accept-Version can be used as an unkeyed header in a cache poisoning attack."}, {"lang": "es", "value": "Esto afecta al paquete find-my-way versiones anteriores a 2.2.5, desde versiones 3.0.0 y anteriores a 3.0.5.&#xa0;Acepta el encabezado Accept-Version por defecto, y si las rutas versionadas no est\u00e1n siendo usadas, esto podr\u00eda conllevar a una denegaci\u00f3n de servicio.&#xa0;Accept-Version puede ser usado como un encabezado sin clave en un ataque de envenenamiento de cach\u00e9"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-444"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:find-my-way_project:find-my-way:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.2.5", "matchCriteriaId": "34BC0E9A-AB9E-44C9-A0A7-8D21C891BB80"}, {"vulnerable": true, "criteria": "cpe:2.3:a:find-my-way_project:find-my-way:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0", "versionEndExcluding": "3.0.5", "matchCriteriaId": "B1FED956-AFAB-4CD5-99B0-77E8EC660115"}]}]}], "references": [{"url": "https://github.com/delvedor/find-my-way/commit/ab408354690e6b9cf3c4724befb3b3fa4bb90aac", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JS-FINDMYWAY-1038269", "source": "report@snyk.io", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/delvedor/find-my-way/commit/ab408354690e6b9cf3c4724befb3b3fa4bb90aac"}}