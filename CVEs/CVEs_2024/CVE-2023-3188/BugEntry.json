{"buggy_code": ["package webfinger\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n)\n\n// GetWebfingerLinks will return webfinger data for an account.\nfunc GetWebfingerLinks(account string) ([]map[string]interface{}, error) {\n\ttype webfingerResponse struct {\n\t\tLinks []map[string]interface{} `json:\"links\"`\n\t}\n\n\taccount = strings.TrimLeft(account, \"@\") // remove any leading @\n\taccountComponents := strings.Split(account, \"@\")\n\tfediverseServer := accountComponents[1]\n\n\t// HTTPS is required.\n\trequestURL, err := url.Parse(\"https://\" + fediverseServer)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to parse fediverse server host %s\", fediverseServer)\n\t}\n\n\trequestURL.Path = \"/.well-known/webfinger\"\n\tquery := requestURL.Query()\n\tquery.Add(\"resource\", fmt.Sprintf(\"acct:%s\", account))\n\trequestURL.RawQuery = query.Encode()\n\n\tresponse, err := http.DefaultClient.Get(requestURL.String())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdefer response.Body.Close()\n\n\tvar links webfingerResponse\n\tdecoder := json.NewDecoder(response.Body)\n\tif err := decoder.Decode(&links); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn links.Links, nil\n}\n", "package indieauth\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/owncast/owncast/core/data\"\n\t\"github.com/pkg/errors\"\n\tlog \"github.com/sirupsen/logrus\"\n)\n\nvar (\n\tpendingAuthRequests = make(map[string]*Request)\n\tlock                = sync.Mutex{}\n)\n\nconst registrationTimeout = time.Minute * 10\n\nfunc init() {\n\tgo setupExpiredRequestPruner()\n}\n\n// Clear out any pending requests that have been pending for greater than\n// the specified timeout value.\nfunc setupExpiredRequestPruner() {\n\tpruneExpiredRequestsTimer := time.NewTicker(registrationTimeout)\n\n\tfor range pruneExpiredRequestsTimer.C {\n\t\tlock.Lock()\n\t\tlog.Debugln(\"Pruning expired IndieAuth requests.\")\n\t\tfor k, v := range pendingAuthRequests {\n\t\t\tif time.Since(v.Timestamp) > registrationTimeout {\n\t\t\t\tdelete(pendingAuthRequests, k)\n\t\t\t}\n\t\t}\n\t\tlock.Unlock()\n\t}\n}\n\n// StartAuthFlow will begin the IndieAuth flow by generating an auth request.\nfunc StartAuthFlow(authHost, userID, accessToken, displayName string) (*url.URL, error) {\n\tif len(pendingAuthRequests) >= maxPendingRequests {\n\t\treturn nil, errors.New(\"Please try again later. Too many pending requests.\")\n\t}\n\n\tserverURL := data.GetServerURL()\n\tif serverURL == \"\" {\n\t\treturn nil, errors.New(\"Owncast server URL must be set when using auth\")\n\t}\n\n\tr, err := createAuthRequest(authHost, userID, displayName, accessToken, serverURL)\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"unable to generate IndieAuth request\")\n\t}\n\n\tpendingAuthRequests[r.State] = r\n\n\treturn r.Redirect, nil\n}\n\n// HandleCallbackCode will handle the callback from the IndieAuth server\n// to continue the next step of the auth flow.\nfunc HandleCallbackCode(code, state string) (*Request, *Response, error) {\n\trequest, exists := pendingAuthRequests[state]\n\tif !exists {\n\t\treturn nil, nil, errors.New(\"no auth requests pending\")\n\t}\n\n\tdata := url.Values{}\n\tdata.Set(\"grant_type\", \"authorization_code\")\n\tdata.Set(\"code\", code)\n\tdata.Set(\"client_id\", request.ClientID)\n\tdata.Set(\"redirect_uri\", request.Callback.String())\n\tdata.Set(\"code_verifier\", request.CodeVerifier)\n\n\tclient := &http.Client{}\n\tr, err := http.NewRequest(\"POST\", request.Endpoint.String(), strings.NewReader(data.Encode())) // URL-encoded payload\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tr.Header.Add(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\tr.Header.Add(\"Content-Length\", strconv.Itoa(len(data.Encode())))\n\n\tres, err := client.Do(r)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tdefer res.Body.Close()\n\tbody, err := io.ReadAll(res.Body)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar response Response\n\tif err := json.Unmarshal(body, &response); err != nil {\n\t\treturn nil, nil, errors.Wrap(err, \"unable to parse IndieAuth response: \"+string(body))\n\t}\n\n\tif response.Error != \"\" || response.ErrorDescription != \"\" {\n\t\terrorText := makeIndieAuthClientErrorText(response.Error)\n\t\tlog.Debugln(\"IndieAuth error:\", response.Error, response.ErrorDescription)\n\t\treturn nil, nil, fmt.Errorf(\"IndieAuth error: %s - %s\", errorText, response.ErrorDescription)\n\t}\n\n\t// In case this IndieAuth server does not use OAuth error keys or has internal\n\t// issues resulting in unstructured errors.\n\tif res.StatusCode < 200 || res.StatusCode > 299 {\n\t\tlog.Debugln(\"IndieAuth error. status code:\", res.StatusCode, \"body:\", string(body))\n\t\treturn nil, nil, errors.New(\"there was an error authenticating against IndieAuth server\")\n\t}\n\n\t// Trim any trailing slash so we can accurately compare the two \"me\" values\n\tmeResponseVerifier := strings.TrimRight(response.Me, \"/\")\n\tmeRequestVerifier := strings.TrimRight(request.Me.String(), \"/\")\n\n\t// What we sent and what we got back must match\n\tif meRequestVerifier != meResponseVerifier {\n\t\treturn nil, nil, errors.New(\"indieauth response does not match the initial anticipated auth destination\")\n\t}\n\n\treturn request, &response, nil\n}\n\n// Error value should be from this list:\n// https://datatracker.ietf.org/doc/html/rfc6749#section-5.2\nfunc makeIndieAuthClientErrorText(err string) string {\n\tswitch err {\n\tcase \"invalid_request\", \"invalid_client\":\n\t\treturn \"The authentication request was invalid. Please report this to the Owncast project.\"\n\tcase \"invalid_grant\", \"unauthorized_client\":\n\t\treturn \"This authorization request is unauthorized.\"\n\tcase \"unsupported_grant_type\":\n\t\treturn \"The authorization grant type is not supported by the authorization server.\"\n\tdefault:\n\t\treturn err\n\t}\n}\n"], "fixing_code": ["package webfinger\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n)\n\n// GetWebfingerLinks will return webfinger data for an account.\nfunc GetWebfingerLinks(account string) ([]map[string]interface{}, error) {\n\ttype webfingerResponse struct {\n\t\tLinks []map[string]interface{} `json:\"links\"`\n\t}\n\n\taccount = strings.TrimLeft(account, \"@\") // remove any leading @\n\taccountComponents := strings.Split(account, \"@\")\n\tfediverseServer := accountComponents[1]\n\n\t// HTTPS is required.\n\trequestURL, err := url.Parse(\"https://\" + fediverseServer)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to parse fediverse server host %s\", fediverseServer)\n\t}\n\n\trequestURL.Path = \"/.well-known/webfinger\"\n\tquery := requestURL.Query()\n\tquery.Add(\"resource\", fmt.Sprintf(\"acct:%s\", account))\n\trequestURL.RawQuery = query.Encode()\n\n\t// Do not support redirects.\n\tclient := &http.Client{\n\t\tCheckRedirect: func(req *http.Request, via []*http.Request) error {\n\t\t\treturn http.ErrUseLastResponse\n\t\t},\n\t}\n\n\tresponse, err := client.Get(requestURL.String())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdefer response.Body.Close()\n\n\tvar links webfingerResponse\n\tdecoder := json.NewDecoder(response.Body)\n\tif err := decoder.Decode(&links); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn links.Links, nil\n}\n", "package indieauth\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/owncast/owncast/core/data\"\n\t\"github.com/pkg/errors\"\n\tlog \"github.com/sirupsen/logrus\"\n)\n\nvar (\n\tpendingAuthRequests = make(map[string]*Request)\n\tlock                = sync.Mutex{}\n)\n\nconst registrationTimeout = time.Minute * 10\n\nfunc init() {\n\tgo setupExpiredRequestPruner()\n}\n\n// Clear out any pending requests that have been pending for greater than\n// the specified timeout value.\nfunc setupExpiredRequestPruner() {\n\tpruneExpiredRequestsTimer := time.NewTicker(registrationTimeout)\n\n\tfor range pruneExpiredRequestsTimer.C {\n\t\tlock.Lock()\n\t\tlog.Debugln(\"Pruning expired IndieAuth requests.\")\n\t\tfor k, v := range pendingAuthRequests {\n\t\t\tif time.Since(v.Timestamp) > registrationTimeout {\n\t\t\t\tdelete(pendingAuthRequests, k)\n\t\t\t}\n\t\t}\n\t\tlock.Unlock()\n\t}\n}\n\n// StartAuthFlow will begin the IndieAuth flow by generating an auth request.\nfunc StartAuthFlow(authHost, userID, accessToken, displayName string) (*url.URL, error) {\n\tif len(pendingAuthRequests) >= maxPendingRequests {\n\t\treturn nil, errors.New(\"Please try again later. Too many pending requests.\")\n\t}\n\n\tserverURL := data.GetServerURL()\n\tif serverURL == \"\" {\n\t\treturn nil, errors.New(\"Owncast server URL must be set when using auth\")\n\t}\n\n\tr, err := createAuthRequest(authHost, userID, displayName, accessToken, serverURL)\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"unable to generate IndieAuth request\")\n\t}\n\n\tpendingAuthRequests[r.State] = r\n\n\treturn r.Redirect, nil\n}\n\n// HandleCallbackCode will handle the callback from the IndieAuth server\n// to continue the next step of the auth flow.\nfunc HandleCallbackCode(code, state string) (*Request, *Response, error) {\n\trequest, exists := pendingAuthRequests[state]\n\tif !exists {\n\t\treturn nil, nil, errors.New(\"no auth requests pending\")\n\t}\n\n\tdata := url.Values{}\n\tdata.Set(\"grant_type\", \"authorization_code\")\n\tdata.Set(\"code\", code)\n\tdata.Set(\"client_id\", request.ClientID)\n\tdata.Set(\"redirect_uri\", request.Callback.String())\n\tdata.Set(\"code_verifier\", request.CodeVerifier)\n\n\t// Do not support redirects.\n\tclient := &http.Client{\n\t\tCheckRedirect: func(req *http.Request, via []*http.Request) error {\n\t\t\treturn http.ErrUseLastResponse\n\t\t},\n\t}\n\n\tr, err := http.NewRequest(\"POST\", request.Endpoint.String(), strings.NewReader(data.Encode())) // URL-encoded payload\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tr.Header.Add(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\tr.Header.Add(\"Content-Length\", strconv.Itoa(len(data.Encode())))\n\n\tres, err := client.Do(r)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tdefer res.Body.Close()\n\tbody, err := io.ReadAll(res.Body)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar response Response\n\tif err := json.Unmarshal(body, &response); err != nil {\n\t\treturn nil, nil, errors.Wrap(err, \"unable to parse IndieAuth response: \"+string(body))\n\t}\n\n\tif response.Error != \"\" || response.ErrorDescription != \"\" {\n\t\terrorText := makeIndieAuthClientErrorText(response.Error)\n\t\tlog.Debugln(\"IndieAuth error:\", response.Error, response.ErrorDescription)\n\t\treturn nil, nil, fmt.Errorf(\"IndieAuth error: %s - %s\", errorText, response.ErrorDescription)\n\t}\n\n\t// In case this IndieAuth server does not use OAuth error keys or has internal\n\t// issues resulting in unstructured errors.\n\tif res.StatusCode < 200 || res.StatusCode > 299 {\n\t\tlog.Debugln(\"IndieAuth error. status code:\", res.StatusCode, \"body:\", string(body))\n\t\treturn nil, nil, errors.New(\"there was an error authenticating against IndieAuth server\")\n\t}\n\n\t// Trim any trailing slash so we can accurately compare the two \"me\" values\n\tmeResponseVerifier := strings.TrimRight(response.Me, \"/\")\n\tmeRequestVerifier := strings.TrimRight(request.Me.String(), \"/\")\n\n\t// What we sent and what we got back must match\n\tif meRequestVerifier != meResponseVerifier {\n\t\treturn nil, nil, errors.New(\"indieauth response does not match the initial anticipated auth destination\")\n\t}\n\n\treturn request, &response, nil\n}\n\n// Error value should be from this list:\n// https://datatracker.ietf.org/doc/html/rfc6749#section-5.2\nfunc makeIndieAuthClientErrorText(err string) string {\n\tswitch err {\n\tcase \"invalid_request\", \"invalid_client\":\n\t\treturn \"The authentication request was invalid. Please report this to the Owncast project.\"\n\tcase \"invalid_grant\", \"unauthorized_client\":\n\t\treturn \"This authorization request is unauthorized.\"\n\tcase \"unsupported_grant_type\":\n\t\treturn \"The authorization grant type is not supported by the authorization server.\"\n\tdefault:\n\t\treturn err\n\t}\n}\n"], "filenames": ["activitypub/webfinger/webfinger.go", "auth/indieauth/client.go"], "buggy_code_start_loc": [32, 83], "buggy_code_end_loc": [33, 84], "fixing_code_start_loc": [32, 83], "fixing_code_end_loc": [40, 90], "type": "CWE-918", "message": "Server-Side Request Forgery (SSRF) in GitHub repository owncast/owncast prior to 0.1.0.", "other": {"cve": {"id": "CVE-2023-3188", "sourceIdentifier": "security@huntr.dev", "published": "2023-06-10T02:15:09.157", "lastModified": "2023-06-16T03:47:37.890", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Server-Side Request Forgery (SSRF) in GitHub repository owncast/owncast prior to 0.1.0."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 2.5}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 8.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.7}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-918"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:owncast_project:owncast:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.1.0", "matchCriteriaId": "90B3824C-C8FF-45C5-A8D3-A6E9D4B12650"}]}]}], "references": [{"url": "https://github.com/owncast/owncast/commit/f40135dbf28093864482f9662c23e478ea192b16", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/0d0d526a-1c39-4e6a-b081-d3914468e495", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/owncast/owncast/commit/f40135dbf28093864482f9662c23e478ea192b16"}}