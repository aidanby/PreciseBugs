{"buggy_code": ["# Copyright (c) 2010-2012 OpenStack, LLC.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n# implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport base64\nfrom hashlib import sha1\nimport hmac\nfrom httplib import HTTPConnection\nfrom httplib import HTTPSConnection\nimport json\nimport swift\nfrom time import gmtime\nfrom time import strftime\nfrom time import time\nfrom traceback import format_exc\nfrom urllib import quote\nfrom urllib import unquote\nfrom uuid import uuid4\n\nfrom eventlet.timeout import Timeout\nfrom eventlet import TimeoutError\nfrom swift.common.swob import HTTPAccepted\nfrom swift.common.swob import HTTPBadRequest\nfrom swift.common.swob import HTTPConflict\nfrom swift.common.swob import HTTPCreated\nfrom swift.common.swob import HTTPForbidden\nfrom swift.common.swob import HTTPMethodNotAllowed\nfrom swift.common.swob import HTTPMovedPermanently\nfrom swift.common.swob import HTTPNoContent\nfrom swift.common.swob import HTTPNotFound\nfrom swift.common.swob import HTTPUnauthorized\nfrom swift.common.swob import Request\nfrom swift.common.swob import Response\n\nfrom swift.common.bufferedhttp import http_connect_raw as http_connect\nfrom swift.common.middleware.acl import clean_acl\nfrom swift.common.middleware.acl import parse_acl\nfrom swift.common.middleware.acl import referrer_allowed\nfrom swift.common.utils import cache_from_env\nfrom swift.common.utils import get_logger\nfrom swift.common.utils import get_remote_client\nfrom swift.common.utils import split_path\nfrom swift.common.utils import TRUE_VALUES\nfrom swift.common.utils import urlparse\nimport swift.common.wsgi\n\nimport swauth.authtypes\nfrom swauth import swift_version\n\n\nSWIFT_MIN_VERSION = \"2.2.0\"\nCONTENT_TYPE_JSON = 'application/json'\n\n\nclass Swauth(object):\n    \"\"\"Scalable authentication and authorization system that uses Swift as its\n    backing store.\n\n    :param app: The next WSGI app in the pipeline\n    :param conf: The dict of configuration values\n    \"\"\"\n\n    def __init__(self, app, conf):\n        self.app = app\n        self.conf = conf\n        self.logger = get_logger(conf, log_route='swauth')\n        if not swift_version.at_least(SWIFT_MIN_VERSION):\n            msg = (\"Your Swift installation is too old (%s). You need at \"\n                   \"least %s.\" % (swift.__version__, SWIFT_MIN_VERSION))\n            self.logger.critical(msg)\n            raise ValueError(msg)\n        self.log_headers = conf.get('log_headers', 'no').lower() in TRUE_VALUES\n        self.reseller_prefix = conf.get('reseller_prefix', 'AUTH').strip()\n        if self.reseller_prefix and self.reseller_prefix[-1] != '_':\n            self.reseller_prefix += '_'\n        self.auth_prefix = conf.get('auth_prefix', '/auth/')\n        if not self.auth_prefix:\n            self.auth_prefix = '/auth/'\n        if self.auth_prefix[0] != '/':\n            self.auth_prefix = '/' + self.auth_prefix\n        if self.auth_prefix[-1] != '/':\n            self.auth_prefix += '/'\n        self.swauth_remote = conf.get('swauth_remote')\n        if self.swauth_remote:\n            self.swauth_remote = self.swauth_remote.rstrip('/')\n            if not self.swauth_remote:\n                msg = _('Invalid swauth_remote set in conf file! Exiting.')\n                self.logger.critical(msg)\n                raise ValueError(msg)\n            self.swauth_remote_parsed = urlparse(self.swauth_remote)\n            if self.swauth_remote_parsed.scheme not in ('http', 'https'):\n                msg = _('Cannot handle protocol scheme %(schema)s '\n                        'for url %(url)s!') % \\\n                   (self.swauth_remote_parsed.scheme, repr(self.swauth_remote))\n                self.logger.critical(msg)\n                raise ValueError(msg)\n        self.swauth_remote_timeout = int(conf.get('swauth_remote_timeout', 10))\n        self.auth_account = '%s.auth' % self.reseller_prefix\n        self.default_swift_cluster = conf.get('default_swift_cluster',\n            'local#http://127.0.0.1:8080/v1')\n        # This setting is a little messy because of the options it has to\n        # provide. The basic format is cluster_name#url, such as the default\n        # value of local#http://127.0.0.1:8080/v1.\n        # If the URL given to the user needs to differ from the url used by\n        # Swauth to create/delete accounts, there's a more complex format:\n        # cluster_name#url#url, such as\n        # local#https://public.com:8080/v1#http://private.com:8080/v1.\n        cluster_parts = self.default_swift_cluster.split('#', 2)\n        self.dsc_name = cluster_parts[0]\n        if len(cluster_parts) == 3:\n            self.dsc_url = cluster_parts[1].rstrip('/')\n            self.dsc_url2 = cluster_parts[2].rstrip('/')\n        elif len(cluster_parts) == 2:\n            self.dsc_url = self.dsc_url2 = cluster_parts[1].rstrip('/')\n        else:\n            raise ValueError('Invalid cluster format')\n        self.dsc_parsed = urlparse(self.dsc_url)\n        if self.dsc_parsed.scheme not in ('http', 'https'):\n            raise ValueError('Cannot handle protocol scheme %s for url %s' %\n                             (self.dsc_parsed.scheme, repr(self.dsc_url)))\n        self.dsc_parsed2 = urlparse(self.dsc_url2)\n        if self.dsc_parsed2.scheme not in ('http', 'https'):\n            raise ValueError('Cannot handle protocol scheme %s for url %s' %\n                             (self.dsc_parsed2.scheme, repr(self.dsc_url2)))\n        self.super_admin_key = conf.get('super_admin_key')\n        if not self.super_admin_key and not self.swauth_remote:\n            msg = _('No super_admin_key set in conf file; Swauth '\n                    'administration features will be disabled.')\n            self.logger.warning(msg)\n        self.token_life = int(conf.get('token_life', 86400))\n        self.max_token_life = int(conf.get('max_token_life', self.token_life))\n        self.timeout = int(conf.get('node_timeout', 10))\n        self.itoken = None\n        self.itoken_expires = None\n        self.allowed_sync_hosts = [h.strip()\n            for h in conf.get('allowed_sync_hosts', '127.0.0.1').split(',')\n            if h.strip()]\n        # Get an instance of our auth_type encoder for saving and checking the\n        # user's key\n        self.auth_type = conf.get('auth_type', 'Plaintext').title()\n        self.auth_encoder = getattr(swauth.authtypes, self.auth_type, None)\n        if self.auth_encoder is None:\n            raise ValueError('Invalid auth_type in config file: %s'\n                             % self.auth_type)\n        # If auth_type_salt is not set in conf file, a random salt will be\n        # generated for each new password to be encoded.\n        self.auth_encoder.salt = conf.get('auth_type_salt', None)\n\n        # Due to security concerns, S3 support is disabled by default.\n        self.s3_support = conf.get('s3_support', 'off').lower() in TRUE_VALUES\n        if self.s3_support and self.auth_type != 'Plaintext' \\\n                and not self.auth_encoder.salt:\n            msg = _('S3 support requires salt to be manually set in conf '\n                    'file using auth_type_salt config option.')\n            self.logger.warning(msg)\n            self.s3_support = False\n\n        self.allow_overrides = \\\n            conf.get('allow_overrides', 't').lower() in TRUE_VALUES\n        self.agent = '%(orig)s Swauth'\n        self.swift_source = 'SWTH'\n        self.default_storage_policy = conf.get('default_storage_policy', None)\n\n    def make_pre_authed_request(self, env, method=None, path=None, body=None,\n                                headers=None):\n        \"\"\"Nearly the same as swift.common.wsgi.make_pre_authed_request\n        except that this also always sets the 'swift.source' and user\n        agent.\n\n        Newer Swift code will support swift_source as a kwarg, but we\n        do it this way so we don't have to have a newer Swift.\n\n        Since we're doing this anyway, we may as well set the user\n        agent too since we always do that.\n        \"\"\"\n        if self.default_storage_policy:\n            sp = self.default_storage_policy\n            if headers:\n                headers.update({'X-Storage-Policy': sp})\n            else:\n                headers = {'X-Storage-Policy': sp}\n        subreq = swift.common.wsgi.make_pre_authed_request(\n            env, method=method, path=path, body=body, headers=headers,\n            agent=self.agent)\n        subreq.environ['swift.source'] = self.swift_source\n        return subreq\n\n    def __call__(self, env, start_response):\n        \"\"\"Accepts a standard WSGI application call, authenticating the request\n        and installing callback hooks for authorization and ACL header\n        validation. For an authenticated request, REMOTE_USER will be set to a\n        comma separated list of the user's groups.\n\n        With a non-empty reseller prefix, acts as the definitive auth service\n        for just tokens and accounts that begin with that prefix, but will deny\n        requests outside this prefix if no other auth middleware overrides it.\n\n        With an empty reseller prefix, acts as the definitive auth service only\n        for tokens that validate to a non-empty set of groups. For all other\n        requests, acts as the fallback auth service when no other auth\n        middleware overrides it.\n\n        Alternatively, if the request matches the self.auth_prefix, the request\n        will be routed through the internal auth request handler (self.handle).\n        This is to handle creating users, accounts, granting tokens, etc.\n        \"\"\"\n        if 'keystone.identity' in env:\n            return self.app(env, start_response)\n        # We're going to consider OPTIONS requests harmless and the CORS\n        # support in the Swift proxy needs to get them.\n        if env.get('REQUEST_METHOD') == 'OPTIONS':\n            return self.app(env, start_response)\n        if self.allow_overrides and env.get('swift.authorize_override', False):\n            return self.app(env, start_response)\n        if not self.swauth_remote:\n            if env.get('PATH_INFO', '') == self.auth_prefix[:-1]:\n                return HTTPMovedPermanently(add_slash=True)(env,\n                                                            start_response)\n            elif env.get('PATH_INFO', '').startswith(self.auth_prefix):\n                return self.handle(env, start_response)\n        s3 = env.get('HTTP_AUTHORIZATION')\n        if s3 and not self.s3_support:\n            msg = 'S3 support is disabled in swauth.'\n            return HTTPBadRequest(body=msg)(env, start_response)\n        token = env.get('HTTP_X_AUTH_TOKEN', env.get('HTTP_X_STORAGE_TOKEN'))\n        if token and len(token) > swauth.authtypes.MAX_TOKEN_LENGTH:\n            return HTTPBadRequest(body='Token exceeds maximum length.')(env,\n                                                                start_response)\n        if s3 or (token and token.startswith(self.reseller_prefix)):\n            # Note: Empty reseller_prefix will match all tokens.\n            groups = self.get_groups(env, token)\n            if groups:\n                env['REMOTE_USER'] = groups\n                user = groups and groups.split(',', 1)[0] or ''\n                # We know the proxy logs the token, so we augment it just a bit\n                # to also log the authenticated user.\n                env['HTTP_X_AUTH_TOKEN'] = \\\n                    '%s,%s' % (user, 's3' if s3 else token)\n                env['swift.authorize'] = self.authorize\n                env['swift.clean_acl'] = clean_acl\n                if '.reseller_admin' in groups:\n                    env['reseller_request'] = True\n            else:\n                # Unauthorized token\n                if self.reseller_prefix and token and \\\n                        token.startswith(self.reseller_prefix):\n                    # Because I know I'm the definitive auth for this token, I\n                    # can deny it outright.\n                    return HTTPUnauthorized()(env, start_response)\n                # Because I'm not certain if I'm the definitive auth, I won't\n                # overwrite swift.authorize and I'll just set a delayed denial\n                # if nothing else overrides me.\n                elif 'swift.authorize' not in env:\n                    env['swift.authorize'] = self.denied_response\n        else:\n            if self.reseller_prefix:\n                # With a non-empty reseller_prefix, I would like to be called\n                # back for anonymous access to accounts I know I'm the\n                # definitive auth for.\n                try:\n                    version, rest = split_path(env.get('PATH_INFO', ''),\n                                               1, 2, True)\n                except ValueError:\n                    rest = None\n                if rest and rest.startswith(self.reseller_prefix):\n                    # Handle anonymous access to accounts I'm the definitive\n                    # auth for.\n                    env['swift.authorize'] = self.authorize\n                    env['swift.clean_acl'] = clean_acl\n                # Not my token, not my account, I can't authorize this request,\n                # deny all is a good idea if not already set...\n                elif 'swift.authorize' not in env:\n                    env['swift.authorize'] = self.denied_response\n            # Because I'm not certain if I'm the definitive auth for empty\n            # reseller_prefixed accounts, I won't overwrite swift.authorize.\n            elif 'swift.authorize' not in env:\n                env['swift.authorize'] = self.authorize\n                env['swift.clean_acl'] = clean_acl\n        return self.app(env, start_response)\n\n    def get_groups(self, env, token):\n        \"\"\"Get groups for the given token.\n\n        :param env: The current WSGI environment dictionary.\n        :param token: Token to validate and return a group string for.\n\n        :returns: None if the token is invalid or a string containing a comma\n                  separated list of groups the authenticated user is a member\n                  of. The first group in the list is also considered a unique\n                  identifier for that user.\n        \"\"\"\n        groups = None\n        memcache_client = cache_from_env(env)\n        if memcache_client:\n            memcache_key = '%s/auth/%s' % (self.reseller_prefix, token)\n            cached_auth_data = memcache_client.get(memcache_key)\n            if cached_auth_data:\n                expires, groups = cached_auth_data\n                if expires < time():\n                    groups = None\n\n        if env.get('HTTP_AUTHORIZATION'):\n            if not self.s3_support:\n                self.logger.warning('S3 support is disabled in swauth.')\n                return None\n            if self.swauth_remote:\n                # TODO(gholt): Support S3-style authorization with\n                # swauth_remote mode\n                self.logger.warning('S3-style authorization not supported yet '\n                                 'with swauth_remote mode.')\n                return None\n            try:\n                account = env['HTTP_AUTHORIZATION'].split(' ')[1]\n                account, user, sign = account.split(':')\n            except Exception:\n                self.logger.debug(\n                    'Swauth cannot parse Authorization header value %r' %\n                    env['HTTP_AUTHORIZATION'])\n                return None\n            path = quote('/v1/%s/%s/%s' % (self.auth_account, account, user))\n            resp = self.make_pre_authed_request(\n                env, 'GET', path).get_response(self.app)\n            if resp.status_int // 100 != 2:\n                return None\n\n            if 'x-object-meta-account-id' in resp.headers:\n                account_id = resp.headers['x-object-meta-account-id']\n            else:\n                path = quote('/v1/%s/%s' % (self.auth_account, account))\n                resp2 = self.make_pre_authed_request(\n                    env, 'HEAD', path).get_response(self.app)\n                if resp2.status_int // 100 != 2:\n                    return None\n                account_id = resp2.headers['x-container-meta-account-id']\n\n            path = env['PATH_INFO']\n            env['PATH_INFO'] = path.replace(\"%s:%s\" % (account, user),\n                                            account_id, 1)\n            detail = json.loads(resp.body)\n            if detail:\n                creds = detail.get('auth')\n                try:\n                    auth_encoder, creds_dict = \\\n                        swauth.authtypes.validate_creds(creds)\n                except ValueError as e:\n                    self.logger.error('%s' % e.args[0])\n                    return None\n\n            password = creds_dict['hash']\n            msg = base64.urlsafe_b64decode(unquote(token))\n\n            # https://bugs.python.org/issue5285\n            if isinstance(password, unicode):\n                password = password.encode('utf-8')\n            if isinstance(msg, unicode):\n                msg = msg.encode('utf-8')\n\n            s = base64.encodestring(hmac.new(password,\n                                             msg, sha1).digest()).strip()\n            if s != sign:\n                return None\n            groups = [g['name'] for g in detail['groups']]\n            if '.admin' in groups:\n                groups.remove('.admin')\n                groups.append(account_id)\n            groups = ','.join(groups)\n            return groups\n\n        if not groups:\n            if self.swauth_remote:\n                with Timeout(self.swauth_remote_timeout):\n                    conn = http_connect(self.swauth_remote_parsed.hostname,\n                        self.swauth_remote_parsed.port, 'GET',\n                        '%s/v2/.token/%s' % (self.swauth_remote_parsed.path,\n                                             quote(token)),\n                        ssl=(self.swauth_remote_parsed.scheme == 'https'))\n                    resp = conn.getresponse()\n                    resp.read()\n                    conn.close()\n                if resp.status // 100 != 2:\n                    return None\n                expires_from_now = float(resp.getheader('x-auth-ttl'))\n                groups = resp.getheader('x-auth-groups')\n                if memcache_client:\n                    memcache_client.set(\n                        memcache_key, (time() + expires_from_now, groups),\n                        time=expires_from_now)\n            else:\n                path = quote('/v1/%s/.token_%s/%s' %\n                             (self.auth_account, token[-1], token))\n                resp = self.make_pre_authed_request(\n                    env, 'GET', path).get_response(self.app)\n                if resp.status_int // 100 != 2:\n                    return None\n                detail = json.loads(resp.body)\n                if detail['expires'] < time():\n                    self.make_pre_authed_request(\n                        env, 'DELETE', path).get_response(self.app)\n                    return None\n                groups = [g['name'] for g in detail['groups']]\n                if '.admin' in groups:\n                    groups.remove('.admin')\n                    groups.append(detail['account_id'])\n                groups = ','.join(groups)\n                if memcache_client:\n                    memcache_client.set(\n                        memcache_key,\n                        (detail['expires'], groups),\n                        time=float(detail['expires'] - time()))\n        return groups\n\n    def authorize(self, req):\n        \"\"\"Returns None if the request is authorized to continue or a standard\n        WSGI response callable if not.\n        \"\"\"\n        try:\n            version, account, container, obj = split_path(req.path, 1, 4, True)\n        except ValueError:\n            return HTTPNotFound(request=req)\n        if not account or not account.startswith(self.reseller_prefix):\n            return self.denied_response(req)\n        user_groups = (req.remote_user or '').split(',')\n        if '.reseller_admin' in user_groups and \\\n                account != self.reseller_prefix and \\\n                account[len(self.reseller_prefix)] != '.':\n            req.environ['swift_owner'] = True\n            return None\n        if account in user_groups and \\\n                (req.method not in ('DELETE', 'PUT') or container):\n            # If the user is admin for the account and is not trying to do an\n            # account DELETE or PUT...\n            req.environ['swift_owner'] = True\n            return None\n        if (req.environ.get('swift_sync_key') and\n            req.environ['swift_sync_key'] ==\n                req.headers.get('x-container-sync-key', None) and\n            'x-timestamp' in req.headers and\n            (req.remote_addr in self.allowed_sync_hosts or\n             get_remote_client(req) in self.allowed_sync_hosts)):\n            return None\n        referrers, groups = parse_acl(getattr(req, 'acl', None))\n        if referrer_allowed(req.referer, referrers):\n            if obj or '.rlistings' in groups:\n                return None\n            return self.denied_response(req)\n        if not req.remote_user:\n            return self.denied_response(req)\n        for user_group in user_groups:\n            if user_group in groups:\n                return None\n        return self.denied_response(req)\n\n    def denied_response(self, req):\n        \"\"\"Returns a standard WSGI response callable with the status of 403 or 401\n        depending on whether the REMOTE_USER is set or not.\n        \"\"\"\n        if not hasattr(req, 'credentials_valid'):\n            req.credentials_valid = None\n        if req.remote_user or req.credentials_valid:\n            return HTTPForbidden(request=req)\n        else:\n            return HTTPUnauthorized(request=req)\n\n    def handle(self, env, start_response):\n        \"\"\"WSGI entry point for auth requests (ones that match the\n        self.auth_prefix).\n        Wraps env in swob.Request object and passes it down.\n\n        :param env: WSGI environment dictionary\n        :param start_response: WSGI callable\n        \"\"\"\n        try:\n            req = Request(env)\n            if self.auth_prefix:\n                req.path_info_pop()\n            req.bytes_transferred = '-'\n            req.client_disconnect = False\n            if 'x-storage-token' in req.headers and \\\n                    'x-auth-token' not in req.headers:\n                req.headers['x-auth-token'] = req.headers['x-storage-token']\n            if 'eventlet.posthooks' in env:\n                env['eventlet.posthooks'].append(\n                    (self.posthooklogger, (req,), {}))\n                return self.handle_request(req)(env, start_response)\n            else:\n                # Lack of posthook support means that we have to log on the\n                # start of the response, rather than after all the data has\n                # been sent. This prevents logging client disconnects\n                # differently than full transmissions.\n                response = self.handle_request(req)(env, start_response)\n                self.posthooklogger(env, req)\n                return response\n        except (Exception, TimeoutError):\n            print(\"EXCEPTION IN handle: %s: %s\" % (format_exc(), env))\n            start_response('500 Server Error',\n                           [('Content-Type', 'text/plain')])\n            return ['Internal server error.\\n']\n\n    def handle_request(self, req):\n        \"\"\"Entry point for auth requests (ones that match the self.auth_prefix).\n        Should return a WSGI-style callable (such as swob.Response).\n\n        :param req: swob.Request object\n        \"\"\"\n        req.start_time = time()\n        handler = None\n        try:\n            version, account, user, _junk = split_path(req.path_info,\n                minsegs=0, maxsegs=4, rest_with_last=True)\n        except ValueError:\n            return HTTPNotFound(request=req)\n        if version in ('v1', 'v1.0', 'auth'):\n            if req.method == 'GET':\n                handler = self.handle_get_token\n        elif version == 'v2':\n            if not self.super_admin_key:\n                return HTTPNotFound(request=req)\n            req.path_info_pop()\n            if req.method == 'GET':\n                if not account and not user:\n                    handler = self.handle_get_reseller\n                elif account:\n                    if not user:\n                        handler = self.handle_get_account\n                    elif account == '.token':\n                        req.path_info_pop()\n                        handler = self.handle_validate_token\n                    else:\n                        handler = self.handle_get_user\n            elif req.method == 'PUT':\n                if not user:\n                    handler = self.handle_put_account\n                else:\n                    handler = self.handle_put_user\n            elif req.method == 'DELETE':\n                if not user:\n                    handler = self.handle_delete_account\n                else:\n                    handler = self.handle_delete_user\n            elif req.method == 'POST':\n                if account == '.prep':\n                    handler = self.handle_prep\n                elif user == '.services':\n                    handler = self.handle_set_services\n        else:\n            handler = self.handle_webadmin\n        if not handler:\n            req.response = HTTPBadRequest(request=req)\n        else:\n            req.response = handler(req)\n        return req.response\n\n    def handle_webadmin(self, req):\n        if req.method not in ('GET', 'HEAD'):\n            return HTTPMethodNotAllowed(request=req)\n        subpath = req.path[len(self.auth_prefix):] or 'index.html'\n        path = quote('/v1/%s/.webadmin/%s' % (self.auth_account, subpath))\n        req.response = self.make_pre_authed_request(\n            req.environ, req.method, path).get_response(self.app)\n        return req.response\n\n    def handle_prep(self, req):\n        \"\"\"Handles the POST v2/.prep call for preparing the backing store Swift\n        cluster for use with the auth subsystem. Can only be called by\n        .super_admin.\n\n        :param req: The swob.Request to process.\n        :returns: swob.Response, 204 on success\n        \"\"\"\n        if not self.is_super_admin(req):\n            return self.denied_response(req)\n        path = quote('/v1/%s' % self.auth_account)\n        resp = self.make_pre_authed_request(\n            req.environ, 'PUT', path).get_response(self.app)\n        if resp.status_int // 100 != 2:\n            raise Exception('Could not create the main auth account: %s %s' %\n                            (path, resp.status))\n        path = quote('/v1/%s/.account_id' % self.auth_account)\n        resp = self.make_pre_authed_request(\n            req.environ, 'PUT', path).get_response(self.app)\n        if resp.status_int // 100 != 2:\n            raise Exception('Could not create container: %s %s' %\n                            (path, resp.status))\n        for container in xrange(16):\n            path = quote('/v1/%s/.token_%x' % (self.auth_account, container))\n            resp = self.make_pre_authed_request(\n                req.environ, 'PUT', path).get_response(self.app)\n            if resp.status_int // 100 != 2:\n                raise Exception('Could not create container: %s %s' %\n                                (path, resp.status))\n        return HTTPNoContent(request=req)\n\n    def handle_get_reseller(self, req):\n        \"\"\"Handles the GET v2 call for getting general reseller information\n        (currently just a list of accounts). Can only be called by a\n        .reseller_admin.\n\n        On success, a JSON dictionary will be returned with a single `accounts`\n        key whose value is list of dicts. Each dict represents an account and\n        currently only contains the single key `name`. For example::\n\n            {\"accounts\": [{\"name\": \"reseller\"}, {\"name\": \"test\"},\n                          {\"name\": \"test2\"}]}\n\n        :param req: The swob.Request to process.\n        :returns: swob.Response, 2xx on success with a JSON dictionary as\n                  explained above.\n        \"\"\"\n        if not self.is_reseller_admin(req):\n            return self.denied_response(req)\n        listing = []\n        marker = ''\n        while True:\n            path = '/v1/%s?format=json&marker=%s' % (quote(self.auth_account),\n                                                     quote(marker))\n            resp = self.make_pre_authed_request(\n                req.environ, 'GET', path).get_response(self.app)\n            if resp.status_int // 100 != 2:\n                raise Exception('Could not list main auth account: %s %s' %\n                                (path, resp.status))\n            sublisting = json.loads(resp.body)\n            if not sublisting:\n                break\n            for container in sublisting:\n                if container['name'][0] != '.':\n                    listing.append({'name': container['name']})\n            marker = sublisting[-1]['name'].encode('utf-8')\n        return Response(body=json.dumps({'accounts': listing}),\n                        content_type=CONTENT_TYPE_JSON)\n\n    def handle_get_account(self, req):\n        \"\"\"Handles the GET v2/<account> call for getting account information.\n        Can only be called by an account .admin.\n\n        On success, a JSON dictionary will be returned containing the keys\n        `account_id`, `services`, and `users`. The `account_id` is the value\n        used when creating service accounts. The `services` value is a dict as\n        described in the :func:`handle_get_token` call. The `users` value is a\n        list of dicts, each dict representing a user and currently only\n        containing the single key `name`. For example::\n\n             {\"account_id\": \"AUTH_018c3946-23f8-4efb-a8fb-b67aae8e4162\",\n              \"services\": {\"storage\": {\"default\": \"local\",\n                           \"local\": \"http://127.0.0.1:8080/v1/AUTH_018c3946\"}},\n              \"users\": [{\"name\": \"tester\"}, {\"name\": \"tester3\"}]}\n\n        :param req: The swob.Request to process.\n        :returns: swob.Response, 2xx on success with a JSON dictionary as\n                  explained above.\n        \"\"\"\n        account = req.path_info_pop()\n        if req.path_info or not account or account[0] == '.':\n            return HTTPBadRequest(request=req)\n        if not self.is_account_admin(req, account):\n            return self.denied_response(req)\n        path = quote('/v1/%s/%s/.services' % (self.auth_account, account))\n        resp = self.make_pre_authed_request(\n            req.environ, 'GET', path).get_response(self.app)\n        if resp.status_int == 404:\n            return HTTPNotFound(request=req)\n        if resp.status_int // 100 != 2:\n            raise Exception('Could not obtain the .services object: %s %s' %\n                            (path, resp.status))\n        services = json.loads(resp.body)\n        listing = []\n        marker = ''\n        while True:\n            path = '/v1/%s?format=json&marker=%s' % (quote('%s/%s' %\n                (self.auth_account, account)), quote(marker))\n            resp = self.make_pre_authed_request(\n                req.environ, 'GET', path).get_response(self.app)\n            if resp.status_int == 404:\n                return HTTPNotFound(request=req)\n            if resp.status_int // 100 != 2:\n                raise Exception('Could not list in main auth account: %s %s' %\n                                (path, resp.status))\n            account_id = resp.headers['X-Container-Meta-Account-Id']\n            sublisting = json.loads(resp.body)\n            if not sublisting:\n                break\n            for obj in sublisting:\n                if obj['name'][0] != '.':\n                    listing.append({'name': obj['name']})\n            marker = sublisting[-1]['name'].encode('utf-8')\n        return Response(content_type=CONTENT_TYPE_JSON,\n                        body=json.dumps({'account_id': account_id,\n                                         'services': services,\n                                         'users': listing}))\n\n    def handle_set_services(self, req):\n        \"\"\"Handles the POST v2/<account>/.services call for setting services\n        information. Can only be called by a reseller .admin.\n\n        In the :func:`handle_get_account` (GET v2/<account>) call, a section of\n        the returned JSON dict is `services`. This section looks something like\n        this::\n\n              \"services\": {\"storage\": {\"default\": \"local\",\n                            \"local\": \"http://127.0.0.1:8080/v1/AUTH_018c3946\"}}\n\n        Making use of this section is described in :func:`handle_get_token`.\n\n        This function allows setting values within this section for the\n        <account>, allowing the addition of new service end points or updating\n        existing ones.\n\n        The body of the POST request should contain a JSON dict with the\n        following format::\n\n            {\"service_name\": {\"end_point_name\": \"end_point_value\"}}\n\n        There can be multiple services and multiple end points in the same\n        call.\n\n        Any new services or end points will be added to the existing set of\n        services and end points. Any existing services with the same service\n        name will be merged with the new end points. Any existing end points\n        with the same end point name will have their values updated.\n\n        The updated services dictionary will be returned on success.\n\n        :param req: The swob.Request to process.\n        :returns: swob.Response, 2xx on success with the udpated services JSON\n                  dict as described above\n        \"\"\"\n        if not self.is_reseller_admin(req):\n            return self.denied_response(req)\n        account = req.path_info_pop()\n        if req.path_info != '/.services' or not account or account[0] == '.':\n            return HTTPBadRequest(request=req)\n        try:\n            new_services = json.loads(req.body)\n        except ValueError as err:\n            return HTTPBadRequest(body=str(err))\n        # Get the current services information\n        path = quote('/v1/%s/%s/.services' % (self.auth_account, account))\n        resp = self.make_pre_authed_request(\n            req.environ, 'GET', path).get_response(self.app)\n        if resp.status_int == 404:\n            return HTTPNotFound(request=req)\n        if resp.status_int // 100 != 2:\n            raise Exception('Could not obtain services info: %s %s' %\n                            (path, resp.status))\n        services = json.loads(resp.body)\n        for new_service, value in new_services.iteritems():\n            if new_service in services:\n                services[new_service].update(value)\n            else:\n                services[new_service] = value\n        # Save the new services information\n        services = json.dumps(services)\n        resp = self.make_pre_authed_request(\n            req.environ, 'PUT', path, services).get_response(self.app)\n        if resp.status_int // 100 != 2:\n            raise Exception('Could not save .services object: %s %s' %\n                            (path, resp.status))\n        return Response(request=req, body=services,\n                        content_type=CONTENT_TYPE_JSON)\n\n    def handle_put_account(self, req):\n        \"\"\"Handles the PUT v2/<account> call for adding an account to the auth\n        system. Can only be called by a .reseller_admin.\n\n        By default, a newly created UUID4 will be used with the reseller prefix\n        as the account id used when creating corresponding service accounts.\n        However, you can provide an X-Account-Suffix header to replace the\n        UUID4 part.\n\n        :param req: The swob.Request to process.\n        :returns: swob.Response, 2xx on success.\n        \"\"\"\n        if not self.is_reseller_admin(req):\n            return self.denied_response(req)\n        account = req.path_info_pop()\n        if req.path_info or not account or account[0] == '.':\n            return HTTPBadRequest(request=req)\n\n        account_suffix = req.headers.get('x-account-suffix')\n        if not account_suffix:\n            account_suffix = str(uuid4())\n        # Create the new account in the Swift cluster\n        path = quote('%s/%s%s' % (self.dsc_parsed2.path,\n                                  self.reseller_prefix, account_suffix))\n        try:\n            conn = self.get_conn()\n            conn.request('PUT', path,\n                        headers={'X-Auth-Token': self.get_itoken(req.environ),\n                                 'Content-Length': '0'})\n            resp = conn.getresponse()\n            resp.read()\n            if resp.status // 100 != 2:\n                raise Exception('Could not create account on the Swift '\n                    'cluster: %s %s %s' % (path, resp.status, resp.reason))\n        except (Exception, TimeoutError):\n            self.logger.error(_('ERROR: Exception while trying to communicate '\n                'with %(scheme)s://%(host)s:%(port)s/%(path)s'),\n                {'scheme': self.dsc_parsed2.scheme,\n                 'host': self.dsc_parsed2.hostname,\n                 'port': self.dsc_parsed2.port, 'path': path})\n            raise\n        # Ensure the container in the main auth account exists (this\n        # container represents the new account)\n        path = quote('/v1/%s/%s' % (self.auth_account, account))\n        resp = self.make_pre_authed_request(\n            req.environ, 'HEAD', path).get_response(self.app)\n        if resp.status_int == 404:\n            resp = self.make_pre_authed_request(\n                req.environ, 'PUT', path).get_response(self.app)\n            if resp.status_int // 100 != 2:\n                raise Exception('Could not create account within main auth '\n                    'account: %s %s' % (path, resp.status))\n        elif resp.status_int // 100 == 2:\n            if 'x-container-meta-account-id' in resp.headers:\n                # Account was already created\n                return HTTPAccepted(request=req)\n        else:\n            raise Exception('Could not verify account within main auth '\n                'account: %s %s' % (path, resp.status))\n        # Record the mapping from account id back to account name\n        path = quote('/v1/%s/.account_id/%s%s' %\n                     (self.auth_account, self.reseller_prefix, account_suffix))\n        resp = self.make_pre_authed_request(\n            req.environ, 'PUT', path, account).get_response(self.app)\n        if resp.status_int // 100 != 2:\n            raise Exception('Could not create account id mapping: %s %s' %\n                            (path, resp.status))\n        # Record the cluster url(s) for the account\n        path = quote('/v1/%s/%s/.services' % (self.auth_account, account))\n        services = {'storage': {}}\n        services['storage'][self.dsc_name] = '%s/%s%s' % (self.dsc_url,\n            self.reseller_prefix, account_suffix)\n        services['storage']['default'] = self.dsc_name\n        resp = self.make_pre_authed_request(\n            req.environ, 'PUT', path,\n            json.dumps(services)).get_response(self.app)\n        if resp.status_int // 100 != 2:\n            raise Exception('Could not create .services object: %s %s' %\n                            (path, resp.status))\n        # Record the mapping from account name to the account id\n        path = quote('/v1/%s/%s' % (self.auth_account, account))\n        resp = self.make_pre_authed_request(\n            req.environ, 'POST', path,\n            headers={'X-Container-Meta-Account-Id': '%s%s' % (\n                self.reseller_prefix, account_suffix)}).get_response(self.app)\n        if resp.status_int // 100 != 2:\n            raise Exception('Could not record the account id on the account: '\n                            '%s %s' % (path, resp.status))\n        return HTTPCreated(request=req)\n\n    def handle_delete_account(self, req):\n        \"\"\"Handles the DELETE v2/<account> call for removing an account from the\n        auth system. Can only be called by a .reseller_admin.\n\n        :param req: The swob.Request to process.\n        :returns: swob.Response, 2xx on success.\n        \"\"\"\n        if not self.is_reseller_admin(req):\n            return self.denied_response(req)\n        account = req.path_info_pop()\n        if req.path_info or not account or account[0] == '.':\n            return HTTPBadRequest(request=req)\n        # Make sure the account has no users and get the account_id\n        marker = ''\n        while True:\n            path = '/v1/%s?format=json&marker=%s' % (quote('%s/%s' %\n                (self.auth_account, account)), quote(marker))\n            resp = self.make_pre_authed_request(\n                req.environ, 'GET', path).get_response(self.app)\n            if resp.status_int == 404:\n                return HTTPNotFound(request=req)\n            if resp.status_int // 100 != 2:\n                raise Exception('Could not list in main auth account: %s %s' %\n                                (path, resp.status))\n            account_id = resp.headers['x-container-meta-account-id']\n            sublisting = json.loads(resp.body)\n            if not sublisting:\n                break\n            for obj in sublisting:\n                if obj['name'][0] != '.':\n                    return HTTPConflict(request=req)\n            marker = sublisting[-1]['name'].encode('utf-8')\n        # Obtain the listing of services the account is on.\n        path = quote('/v1/%s/%s/.services' % (self.auth_account, account))\n        resp = self.make_pre_authed_request(\n            req.environ, 'GET', path).get_response(self.app)\n        if resp.status_int // 100 != 2 and resp.status_int != 404:\n            raise Exception('Could not obtain .services object: %s %s' %\n                            (path, resp.status))\n        if resp.status_int // 100 == 2:\n            services = json.loads(resp.body)\n            # Delete the account on each cluster it is on.\n            deleted_any = False\n            for name, url in services['storage'].iteritems():\n                if name != 'default':\n                    parsed = urlparse(url)\n                    conn = self.get_conn(parsed)\n                    conn.request('DELETE', parsed.path,\n                        headers={'X-Auth-Token': self.get_itoken(req.environ)})\n                    resp = conn.getresponse()\n                    resp.read()\n                    if resp.status == 409:\n                        if deleted_any:\n                            raise Exception('Managed to delete one or more '\n                                'service end points, but failed with: '\n                                '%s %s %s' % (url, resp.status, resp.reason))\n                        else:\n                            return HTTPConflict(request=req)\n                    if resp.status // 100 != 2 and resp.status != 404:\n                        raise Exception('Could not delete account on the '\n                            'Swift cluster: %s %s %s' %\n                            (url, resp.status, resp.reason))\n                    deleted_any = True\n            # Delete the .services object itself.\n            path = quote('/v1/%s/%s/.services' %\n                         (self.auth_account, account))\n            resp = self.make_pre_authed_request(\n                req.environ, 'DELETE', path).get_response(self.app)\n            if resp.status_int // 100 != 2 and resp.status_int != 404:\n                raise Exception('Could not delete .services object: %s %s' %\n                                (path, resp.status))\n        # Delete the account id mapping for the account.\n        path = quote('/v1/%s/.account_id/%s' %\n                     (self.auth_account, account_id))\n        resp = self.make_pre_authed_request(\n            req.environ, 'DELETE', path).get_response(self.app)\n        if resp.status_int // 100 != 2 and resp.status_int != 404:\n            raise Exception('Could not delete account id mapping: %s %s' %\n                            (path, resp.status))\n        # Delete the account marker itself.\n        path = quote('/v1/%s/%s' % (self.auth_account, account))\n        resp = self.make_pre_authed_request(\n            req.environ, 'DELETE', path).get_response(self.app)\n        if resp.status_int // 100 != 2 and resp.status_int != 404:\n            raise Exception('Could not delete account marked: %s %s' %\n                            (path, resp.status))\n        return HTTPNoContent(request=req)\n\n    def handle_get_user(self, req):\n        \"\"\"Handles the GET v2/<account>/<user> call for getting user information.\n        Can only be called by an account .admin.\n\n        On success, a JSON dict will be returned as described::\n\n            {\"groups\": [  # List of groups the user is a member of\n                {\"name\": \"<act>:<usr>\"},\n                    # The first group is a unique user identifier\n                {\"name\": \"<account>\"},\n                    # The second group is the auth account name\n                {\"name\": \"<additional-group>\"}\n                    # There may be additional groups, .admin being a special\n                    # group indicating an account admin and .reseller_admin\n                    # indicating a reseller admin.\n             ],\n             \"auth\": \"plaintext:<key>\"\n             # The auth-type and key for the user; currently only plaintext is\n             # implemented.\n            }\n\n        For example::\n\n            {\"groups\": [{\"name\": \"test:tester\"}, {\"name\": \"test\"},\n                        {\"name\": \".admin\"}],\n             \"auth\": \"plaintext:testing\"}\n\n        If the <user> in the request is the special user `.groups`, the JSON\n        dict will contain a single key of `groups` whose value is a list of\n        dicts representing the active groups within the account. Each dict\n        currently has the single key `name`. For example::\n\n            {\"groups\": [{\"name\": \".admin\"}, {\"name\": \"test\"},\n                        {\"name\": \"test:tester\"}, {\"name\": \"test:tester3\"}]}\n\n        :param req: The swob.Request to process.\n        :returns: swob.Response, 2xx on success with a JSON dictionary as\n                  explained above.\n        \"\"\"\n        account = req.path_info_pop()\n        user = req.path_info_pop()\n        if req.path_info or not account or account[0] == '.' or not user or \\\n                (user[0] == '.' and user != '.groups'):\n            return HTTPBadRequest(request=req)\n        if not self.is_account_admin(req, account):\n            return self.denied_response(req)\n\n        # get information for each user for the specified\n        # account and create a list of all groups that the users\n        # are part of\n        if user == '.groups':\n            # TODO(gholt): This could be very slow for accounts with a really\n            # large number of users. Speed could be improved by concurrently\n            # requesting user group information. Then again, I don't *know*\n            # it's slow for `normal` use cases, so testing should be done.\n            groups = set()\n            marker = ''\n            while True:\n                path = '/v1/%s?format=json&marker=%s' % (quote('%s/%s' %\n                    (self.auth_account, account)), quote(marker))\n                resp = self.make_pre_authed_request(\n                    req.environ, 'GET', path).get_response(self.app)\n                if resp.status_int == 404:\n                    return HTTPNotFound(request=req)\n                if resp.status_int // 100 != 2:\n                    raise Exception('Could not list in main auth account: '\n                                    '%s %s' % (path, resp.status))\n                sublisting = json.loads(resp.body)\n                if not sublisting:\n                    break\n                for obj in sublisting:\n                    if obj['name'][0] != '.':\n\n                        # get list of groups for each user\n                        user_json = self.get_user_detail(req, account,\n                                                         obj['name'])\n                        if user_json is None:\n                            raise Exception('Could not retrieve user object: '\n                                            '%s:%s %s' % (account, user, 404))\n                        groups.update(\n                            g['name'] for g in json.loads(user_json)['groups'])\n                marker = sublisting[-1]['name'].encode('utf-8')\n            body = json.dumps(\n                {'groups': [{'name': g} for g in sorted(groups)]})\n        else:\n            # get information for specific user,\n            # if user doesn't exist, return HTTPNotFound\n            body = self.get_user_detail(req, account, user)\n            if body is None:\n                return HTTPNotFound(request=req)\n\n            display_groups = [g['name'] for g in json.loads(body)['groups']]\n            if ('.admin' in display_groups and\n                not self.is_reseller_admin(req)) or \\\n               ('.reseller_admin' in display_groups and\n                    not self.is_super_admin(req)):\n                    return self.denied_response(req)\n        return Response(body=body, content_type=CONTENT_TYPE_JSON)\n\n    def handle_put_user(self, req):\n        \"\"\"Handles the PUT v2/<account>/<user> call for adding a user to an\n        account.\n\n        X-Auth-User-Key represents the user's key (url encoded),\n        - OR -\n        X-Auth-User-Key-Hash represents the user's hashed key (url encoded),\n        X-Auth-User-Admin may be set to `true` to create an account .admin, and\n        X-Auth-User-Reseller-Admin may be set to `true` to create a\n        .reseller_admin.\n\n        Creating users\n        **************\n        Can only be called by an account .admin unless the user is to be a\n        .reseller_admin, in which case the request must be by .super_admin.\n\n        Changing password/key\n        *********************\n        1) reseller_admin key can be changed by super_admin and by himself.\n        2) admin key can be changed by any admin in same account,\n           reseller_admin, super_admin and himself.\n        3) Regular user key can be changed by any admin in his account,\n           reseller_admin, super_admin and himself.\n\n        :param req: The swob.Request to process.\n        :returns: swob.Response, 2xx on success.\n        \"\"\"\n        # Validate path info\n        account = req.path_info_pop()\n        user = req.path_info_pop()\n        key = unquote(req.headers.get('x-auth-user-key', ''))\n        key_hash = unquote(req.headers.get('x-auth-user-key-hash', ''))\n        admin = req.headers.get('x-auth-user-admin') == 'true'\n        reseller_admin = \\\n            req.headers.get('x-auth-user-reseller-admin') == 'true'\n        if reseller_admin:\n            admin = True\n        if req.path_info or not account or account[0] == '.' or not user or \\\n                user[0] == '.' or (not key and not key_hash):\n            return HTTPBadRequest(request=req)\n        if key_hash:\n            try:\n                swauth.authtypes.validate_creds(key_hash)\n            except ValueError:\n                return HTTPBadRequest(request=req)\n\n        user_arg = account + ':' + user\n        if reseller_admin:\n            if not self.is_super_admin(req) and\\\n                    not self.is_user_changing_own_key(req, user_arg):\n                        return self.denied_response(req)\n        elif not self.is_account_admin(req, account) and\\\n                not self.is_user_changing_own_key(req, user_arg):\n                    return self.denied_response(req)\n\n        path = quote('/v1/%s/%s' % (self.auth_account, account))\n        resp = self.make_pre_authed_request(\n            req.environ, 'HEAD', path).get_response(self.app)\n        if resp.status_int // 100 != 2:\n            raise Exception('Could not retrieve account id value: %s %s' %\n                            (path, resp.status))\n        headers = {'X-Object-Meta-Account-Id':\n                   resp.headers['x-container-meta-account-id']}\n        # Create the object in the main auth account (this object represents\n        # the user)\n        path = quote('/v1/%s/%s/%s' % (self.auth_account, account, user))\n        groups = ['%s:%s' % (account, user), account]\n        if admin:\n            groups.append('.admin')\n        if reseller_admin:\n            groups.append('.reseller_admin')\n        auth_value = key_hash or self.auth_encoder().encode(key)\n        resp = self.make_pre_authed_request(\n            req.environ, 'PUT', path,\n            json.dumps({'auth': auth_value,\n                        'groups': [{'name': g} for g in groups]}),\n            headers=headers).get_response(self.app)\n        if resp.status_int == 404:\n            return HTTPNotFound(request=req)\n        if resp.status_int // 100 != 2:\n            raise Exception('Could not create user object: %s %s' %\n                            (path, resp.status))\n        return HTTPCreated(request=req)\n\n    def handle_delete_user(self, req):\n        \"\"\"Handles the DELETE v2/<account>/<user> call for deleting a user from an\n        account.\n\n        Can only be called by an account .admin.\n\n        :param req: The swob.Request to process.\n        :returns: swob.Response, 2xx on success.\n        \"\"\"\n        # Validate path info\n        account = req.path_info_pop()\n        user = req.path_info_pop()\n        if req.path_info or not account or account[0] == '.' or not user or \\\n                user[0] == '.':\n            return HTTPBadRequest(request=req)\n\n        # if user to be deleted is reseller_admin, then requesting\n        # user must be the super_admin\n        is_reseller_admin = self.is_user_reseller_admin(req, account, user)\n        if not is_reseller_admin and not req.credentials_valid:\n            # if user to be deleted can't be found, return 404\n            return HTTPNotFound(request=req)\n        elif is_reseller_admin and not self.is_super_admin(req):\n            return HTTPForbidden(request=req)\n\n        if not self.is_account_admin(req, account):\n            return self.denied_response(req)\n\n        # Delete the user's existing token, if any.\n        path = quote('/v1/%s/%s/%s' % (self.auth_account, account, user))\n        resp = self.make_pre_authed_request(\n            req.environ, 'HEAD', path).get_response(self.app)\n        if resp.status_int == 404:\n            return HTTPNotFound(request=req)\n        elif resp.status_int // 100 != 2:\n            raise Exception('Could not obtain user details: %s %s' %\n                            (path, resp.status))\n        candidate_token = resp.headers.get('x-object-meta-auth-token')\n        if candidate_token:\n            path = quote('/v1/%s/.token_%s/%s' %\n                (self.auth_account, candidate_token[-1], candidate_token))\n            resp = self.make_pre_authed_request(\n                req.environ, 'DELETE', path).get_response(self.app)\n            if resp.status_int // 100 != 2 and resp.status_int != 404:\n                raise Exception('Could not delete possibly existing token: '\n                                '%s %s' % (path, resp.status))\n        # Delete the user entry itself.\n        path = quote('/v1/%s/%s/%s' % (self.auth_account, account, user))\n        resp = self.make_pre_authed_request(\n            req.environ, 'DELETE', path).get_response(self.app)\n        if resp.status_int // 100 != 2 and resp.status_int != 404:\n            raise Exception('Could not delete the user object: %s %s' %\n                            (path, resp.status))\n        return HTTPNoContent(request=req)\n\n    def is_user_reseller_admin(self, req, account, user):\n        \"\"\"Returns True if the user is a .reseller_admin.\n\n        :param account: account user is part of\n        :param user: the user\n        :returns: True if user .reseller_admin, False\n                  if user is not a reseller_admin and None if the user\n                  doesn't exist.\n        \"\"\"\n        req.credentials_valid = True\n        user_json = self.get_user_detail(req, account, user)\n        if user_json is None:\n            req.credentials_valid = False\n            return False\n\n        user_detail = json.loads(user_json)\n\n        return '.reseller_admin' in (g['name'] for g in user_detail['groups'])\n\n    def handle_get_token(self, req):\n        \"\"\"Handles the various `request for token and service end point(s)` calls.\n        There are various formats to support the various auth servers in the\n        past. Examples::\n\n            GET <auth-prefix>/v1/<act>/auth\n                X-Auth-User: <act>:<usr>  or  X-Storage-User: <usr>\n                X-Auth-Key: <key>         or  X-Storage-Pass: <key>\n            GET <auth-prefix>/auth\n                X-Auth-User: <act>:<usr>  or  X-Storage-User: <act>:<usr>\n                X-Auth-Key: <key>         or  X-Storage-Pass: <key>\n            GET <auth-prefix>/v1.0\n                X-Auth-User: <act>:<usr>  or  X-Storage-User: <act>:<usr>\n                X-Auth-Key: <key>         or  X-Storage-Pass: <key>\n\n        Values should be url encoded, \"act%3Ausr\" instead of \"act:usr\" for\n        example; however, for backwards compatibility the colon may be included\n        unencoded.\n\n        On successful authentication, the response will have X-Auth-Token and\n        X-Storage-Token set to the token to use with Swift and X-Storage-URL\n        set to the URL to the default Swift cluster to use.\n\n        The response body will be set to the account's services JSON object as\n        described here::\n\n            {\"storage\": {     # Represents the Swift storage service end points\n                \"default\": \"cluster1\", # Indicates which cluster is the default\n                \"cluster1\": \"<URL to use with Swift>\",\n                    # A Swift cluster that can be used with this account,\n                    # \"cluster1\" is the name of the cluster which is usually a\n                    # location indicator (like \"dfw\" for a datacenter region).\n                \"cluster2\": \"<URL to use with Swift>\"\n                    # Another Swift cluster that can be used with this account,\n                    # there will always be at least one Swift cluster to use or\n                    # this whole \"storage\" dict won't be included at all.\n             },\n             \"servers\": {       # Represents the Nova server service end points\n                # Expected to be similar to the \"storage\" dict, but not\n                # implemented yet.\n             },\n             # Possibly other service dicts, not implemented yet.\n            }\n\n        One can also include an \"X-Auth-New-Token: true\" header to\n        force issuing a new token and revoking any old token, even if\n        it hasn't expired yet.\n\n        :param req: The swob.Request to process.\n        :returns: swob.Response, 2xx on success with data set as explained\n                  above.\n        \"\"\"\n        # Validate the request info\n        try:\n            pathsegs = split_path(req.path_info, minsegs=1, maxsegs=3,\n                                  rest_with_last=True)\n        except ValueError:\n            return HTTPNotFound(request=req)\n        if pathsegs[0] == 'v1' and pathsegs[2] == 'auth':\n            account = pathsegs[1]\n            user = req.headers.get('x-storage-user')\n            if not user:\n                user = unquote(req.headers.get('x-auth-user', ''))\n                if not user or ':' not in user:\n                    return HTTPUnauthorized(request=req)\n                account2, user = user.split(':', 1)\n                if account != account2:\n                    return HTTPUnauthorized(request=req)\n            key = req.headers.get('x-storage-pass')\n            if not key:\n                key = unquote(req.headers.get('x-auth-key', ''))\n        elif pathsegs[0] in ('auth', 'v1.0'):\n            user = unquote(req.headers.get('x-auth-user', ''))\n            if not user:\n                user = req.headers.get('x-storage-user')\n            if not user or ':' not in user:\n                return HTTPUnauthorized(request=req)\n            account, user = user.split(':', 1)\n            key = unquote(req.headers.get('x-auth-key', ''))\n            if not key:\n                key = req.headers.get('x-storage-pass')\n        else:\n            return HTTPBadRequest(request=req)\n        if not all((account, user, key)):\n            return HTTPUnauthorized(request=req)\n        if user == '.super_admin' and self.super_admin_key and \\\n                key == self.super_admin_key:\n            token = self.get_itoken(req.environ)\n            url = '%s/%s.auth' % (self.dsc_url, self.reseller_prefix)\n            return Response(\n                request=req,\n                content_type=CONTENT_TYPE_JSON,\n                body=json.dumps({'storage': {'default': 'local',\n                                             'local': url}}),\n                headers={'x-auth-token': token,\n                         'x-storage-token': token,\n                         'x-storage-url': url})\n\n        # Authenticate user\n        path = quote('/v1/%s/%s/%s' % (self.auth_account, account, user))\n        resp = self.make_pre_authed_request(\n            req.environ, 'GET', path).get_response(self.app)\n        if resp.status_int == 404:\n            return HTTPUnauthorized(request=req)\n        if resp.status_int // 100 != 2:\n            raise Exception('Could not obtain user details: %s %s' %\n                            (path, resp.status))\n        user_detail = json.loads(resp.body)\n        if not self.credentials_match(user_detail, key):\n            return HTTPUnauthorized(request=req)\n        # See if a token already exists and hasn't expired\n        token = None\n        expires = None\n        candidate_token = resp.headers.get('x-object-meta-auth-token')\n        if candidate_token:\n            path = quote('/v1/%s/.token_%s/%s' %\n                (self.auth_account, candidate_token[-1], candidate_token))\n            delete_token = False\n            try:\n                if req.headers.get('x-auth-new-token', 'false').lower() in \\\n                        TRUE_VALUES:\n                    delete_token = True\n                else:\n                    resp = self.make_pre_authed_request(\n                        req.environ, 'GET', path).get_response(self.app)\n                    if resp.status_int // 100 == 2:\n                        token_detail = json.loads(resp.body)\n                        if token_detail['expires'] > time():\n                            token = candidate_token\n                            expires = token_detail['expires']\n                        else:\n                            delete_token = True\n                    elif resp.status_int != 404:\n                        raise Exception(\n                            'Could not detect whether a token already exists: '\n                            '%s %s' % (path, resp.status))\n            finally:\n                if delete_token:\n                    self.make_pre_authed_request(\n                        req.environ, 'DELETE', path).get_response(self.app)\n                    memcache_client = cache_from_env(req.environ)\n                    if memcache_client:\n                        memcache_key = '%s/auth/%s' % (self.reseller_prefix,\n                                                       candidate_token)\n                        memcache_client.delete(memcache_key)\n        # Create a new token if one didn't exist\n        if not token:\n            # Retrieve account id, we'll save this in the token\n            path = quote('/v1/%s/%s' % (self.auth_account, account))\n            resp = self.make_pre_authed_request(\n                req.environ, 'HEAD', path).get_response(self.app)\n            if resp.status_int // 100 != 2:\n                raise Exception('Could not retrieve account id value: '\n                                '%s %s' % (path, resp.status))\n            account_id = \\\n                resp.headers['x-container-meta-account-id']\n            # Generate new token\n            token = '%stk%s' % (self.reseller_prefix, uuid4().hex)\n            # Save token info\n            path = quote('/v1/%s/.token_%s/%s' %\n                         (self.auth_account, token[-1], token))\n            try:\n                token_life = min(\n                    int(req.headers.get('x-auth-token-lifetime',\n                                        self.token_life)),\n                    self.max_token_life)\n            except ValueError:\n                token_life = self.token_life\n            expires = int(time() + token_life)\n            resp = self.make_pre_authed_request(\n                req.environ, 'PUT', path,\n                json.dumps({'account': account, 'user': user,\n                'account_id': account_id,\n                'groups': user_detail['groups'],\n                'expires': expires})).get_response(self.app)\n            if resp.status_int // 100 != 2:\n                raise Exception('Could not create new token: %s %s' %\n                                (path, resp.status))\n            # Record the token with the user info for future use.\n            path = quote('/v1/%s/%s/%s' % (self.auth_account, account, user))\n            resp = self.make_pre_authed_request(\n                req.environ, 'POST', path,\n                headers={'X-Object-Meta-Auth-Token': token}\n            ).get_response(self.app)\n            if resp.status_int // 100 != 2:\n                raise Exception('Could not save new token: %s %s' %\n                                (path, resp.status))\n        # Get the services information\n        path = quote('/v1/%s/%s/.services' % (self.auth_account, account))\n        resp = self.make_pre_authed_request(\n            req.environ, 'GET', path).get_response(self.app)\n        if resp.status_int // 100 != 2:\n            raise Exception('Could not obtain services info: %s %s' %\n                            (path, resp.status))\n        detail = json.loads(resp.body)\n        url = detail['storage'][detail['storage']['default']]\n        return Response(\n            request=req,\n            body=resp.body,\n            content_type=CONTENT_TYPE_JSON,\n            headers={'x-auth-token': token,\n                     'x-storage-token': token,\n                     'x-auth-token-expires': str(int(expires - time())),\n                     'x-storage-url': url})\n\n    def handle_validate_token(self, req):\n        \"\"\"Handles the GET v2/.token/<token> call for validating a token, usually\n        called by a service like Swift.\n\n        On a successful validation, X-Auth-TTL will be set for how much longer\n        this token is valid and X-Auth-Groups will contain a comma separated\n        list of groups the user belongs to.\n\n        The first group listed will be a unique identifier for the user the\n        token represents.\n\n        .reseller_admin is a special group that indicates the user should be\n        allowed to do anything on any account.\n\n        :param req: The swob.Request to process.\n        :returns: swob.Response, 2xx on success with data set as explained\n                  above.\n        \"\"\"\n        token = req.path_info_pop()\n        if req.path_info or not token.startswith(self.reseller_prefix):\n            return HTTPBadRequest(request=req)\n        expires = groups = None\n        memcache_client = cache_from_env(req.environ)\n        if memcache_client:\n            memcache_key = '%s/auth/%s' % (self.reseller_prefix, token)\n            cached_auth_data = memcache_client.get(memcache_key)\n            if cached_auth_data:\n                expires, groups = cached_auth_data\n                if expires < time():\n                    groups = None\n        if not groups:\n            path = quote('/v1/%s/.token_%s/%s' %\n                         (self.auth_account, token[-1], token))\n            resp = self.make_pre_authed_request(\n                req.environ, 'GET', path).get_response(self.app)\n            if resp.status_int // 100 != 2:\n                return HTTPNotFound(request=req)\n            detail = json.loads(resp.body)\n            expires = detail['expires']\n            if expires < time():\n                self.make_pre_authed_request(\n                    req.environ, 'DELETE', path).get_response(self.app)\n                return HTTPNotFound(request=req)\n            groups = [g['name'] for g in detail['groups']]\n            if '.admin' in groups:\n                groups.remove('.admin')\n                groups.append(detail['account_id'])\n            groups = ','.join(groups)\n        return HTTPNoContent(headers={'X-Auth-TTL': expires - time(),\n                                      'X-Auth-Groups': groups})\n\n    def get_conn(self, urlparsed=None):\n        \"\"\"Returns an HTTPConnection based on the urlparse result given or the\n        default Swift cluster (internal url) urlparse result.\n\n        :param urlparsed: The result from urlparse.urlparse or None to use the\n                          default Swift cluster's value\n        \"\"\"\n        if not urlparsed:\n            urlparsed = self.dsc_parsed2\n        if urlparsed.scheme == 'http':\n            return HTTPConnection(urlparsed.netloc)\n        else:\n            return HTTPSConnection(urlparsed.netloc)\n\n    def get_itoken(self, env):\n        \"\"\"Returns the current internal token to use for the auth system's own\n        actions with other services. Each process will create its own\n        itoken and the token will be deleted and recreated based on the\n        token_life configuration value. The itoken information is stored in\n        memcache because the auth process that is asked by Swift to validate\n        the token may not be the same as the auth process that created the\n        token.\n        \"\"\"\n        if not self.itoken or self.itoken_expires < time() or \\\n                env.get('HTTP_X_AUTH_NEW_TOKEN', 'false').lower() in \\\n                TRUE_VALUES:\n            self.itoken = '%sitk%s' % (self.reseller_prefix, uuid4().hex)\n            memcache_key = '%s/auth/%s' % (self.reseller_prefix, self.itoken)\n            self.itoken_expires = time() + self.token_life\n            memcache_client = cache_from_env(env)\n            if not memcache_client:\n                raise Exception(\n                    'No memcache set up; required for Swauth middleware')\n            memcache_client.set(\n                memcache_key,\n                (self.itoken_expires,\n                 '.auth,.reseller_admin,%s.auth' % self.reseller_prefix),\n                time=self.token_life)\n        return self.itoken\n\n    def get_admin_detail(self, req):\n        \"\"\"Returns the dict for the user specified as the admin in the request\n        with the addition of an `account` key set to the admin user's account.\n\n        :param req: The swob request to retrieve X-Auth-Admin-User and\n                    X-Auth-Admin-Key from.\n        :returns: The dict for the admin user with the addition of the\n                  `account` key.\n        \"\"\"\n        if ':' not in req.headers.get('x-auth-admin-user', ''):\n            return None\n        admin_account, admin_user = \\\n            req.headers.get('x-auth-admin-user').split(':', 1)\n        user_json = self.get_user_detail(req, admin_account, admin_user)\n        if user_json is None:\n            return None\n        admin_detail = json.loads(user_json)\n        admin_detail['account'] = admin_account\n        return admin_detail\n\n    def get_user_detail(self, req, account, user):\n        \"\"\"Returns the response body of a GET request for the specified user\n        The body is in JSON format and contains all user information.\n\n        :param req: The swob request\n        :param account: the account the user is a member of\n        :param user: the user\n\n        :returns: A JSON response with the user detail information, None\n                  if the user doesn't exist\n        \"\"\"\n        path = quote('/v1/%s/%s/%s' % (self.auth_account, account, user))\n        resp = self.make_pre_authed_request(\n            req.environ, 'GET', path).get_response(self.app)\n        if resp.status_int == 404:\n            return None\n        if resp.status_int // 100 != 2:\n            raise Exception('Could not get user object: %s %s' %\n                            (path, resp.status))\n        return resp.body\n\n    def credentials_match(self, user_detail, key):\n        \"\"\"Returns True if the key is valid for the user_detail.\n        It will use auth_encoder type the password was encoded with,\n        to check for a key match.\n\n        :param user_detail: The dict for the user.\n        :param key: The key to validate for the user.\n        :returns: True if the key is valid for the user, False if not.\n        \"\"\"\n        if user_detail:\n            creds = user_detail.get('auth')\n            try:\n                auth_encoder, creds_dict = \\\n                    swauth.authtypes.validate_creds(creds)\n            except ValueError as e:\n                self.logger.error('%s' % e.args[0])\n                return False\n        return user_detail and auth_encoder.match(key, creds, **creds_dict)\n\n    def is_user_changing_own_key(self, req, user):\n        \"\"\"Check if the user is changing his own key.\n\n        :param req: The swob.Request to check. This contains x-auth-admin-user\n                    and x-auth-admin-key headers which are credentials of the\n                    user sending the request.\n        :param user: User whose password is to be changed.\n        :returns: True if user is changing his own key, False if not.\n        \"\"\"\n        admin_detail = self.get_admin_detail(req)\n        if not admin_detail:\n            # The user does not exist\n            return False\n\n        # If user is not admin/reseller_admin and x-auth-user-admin or\n        # x-auth-user-reseller-admin headers are present in request, he may be\n        # attempting to escalate himself as admin/reseller_admin!\n        if '.admin' not in (g['name'] for g in admin_detail['groups']):\n            if req.headers.get('x-auth-user-admin') == 'true' or \\\n                    req.headers.get('x-auth-user-reseller-admin') == 'true':\n                        return False\n        if '.reseller_admin' not in \\\n            (g['name'] for g in admin_detail['groups']) and \\\n                req.headers.get('x-auth-user-reseller-admin') == 'true':\n                    return False\n\n        return req.headers.get('x-auth-admin-user') == user and \\\n            self.credentials_match(admin_detail,\n                                   req.headers.get('x-auth-admin-key'))\n\n    def is_super_admin(self, req):\n        \"\"\"Returns True if the admin specified in the request represents the\n        .super_admin.\n\n        :param req: The swob.Request to check.\n        :param returns: True if .super_admin.\n        \"\"\"\n        return req.headers.get('x-auth-admin-user') == '.super_admin' and \\\n            self.super_admin_key and \\\n            req.headers.get('x-auth-admin-key') == self.super_admin_key\n\n    def is_reseller_admin(self, req, admin_detail=None):\n        \"\"\"Returns True if the admin specified in the request represents a\n        .reseller_admin.\n\n        :param req: The swob.Request to check.\n        :param admin_detail: The previously retrieved dict from\n                             :func:`get_admin_detail` or None for this function\n                             to retrieve the admin_detail itself.\n        :param returns: True if .reseller_admin.\n        \"\"\"\n        req.credentials_valid = False\n        if self.is_super_admin(req):\n            return True\n        if not admin_detail:\n            admin_detail = self.get_admin_detail(req)\n        if not self.credentials_match(admin_detail,\n                                      req.headers.get('x-auth-admin-key')):\n            return False\n        req.credentials_valid = True\n        return '.reseller_admin' in (g['name'] for g in admin_detail['groups'])\n\n    def is_account_admin(self, req, account):\n        \"\"\"Returns True if the admin specified in the request represents a .admin\n        for the account specified.\n\n        :param req: The swob.Request to check.\n        :param account: The account to check for .admin against.\n        :param returns: True if .admin.\n        \"\"\"\n        req.credentials_valid = False\n        if self.is_super_admin(req):\n            return True\n        admin_detail = self.get_admin_detail(req)\n        if admin_detail:\n            if self.is_reseller_admin(req, admin_detail=admin_detail):\n                return True\n            if not self.credentials_match(admin_detail,\n                                          req.headers.get('x-auth-admin-key')):\n                return False\n            req.credentials_valid = True\n            return admin_detail and admin_detail['account'] == account and \\\n                '.admin' in (g['name'] for g in admin_detail['groups'])\n        return False\n\n    def posthooklogger(self, env, req):\n        if not req.path.startswith(self.auth_prefix):\n            return\n        response = getattr(req, 'response', None)\n        if not response:\n            return\n        trans_time = '%.4f' % (time() - req.start_time)\n        the_request = quote(unquote(req.path))\n        if req.query_string:\n            the_request = the_request + '?' + req.query_string\n        # remote user for zeus\n        client = req.headers.get('x-cluster-client-ip')\n        if not client and 'x-forwarded-for' in req.headers:\n            # remote user for other lbs\n            client = req.headers['x-forwarded-for'].split(',')[0].strip()\n        logged_headers = None\n        if self.log_headers:\n            logged_headers = '\\n'.join('%s: %s' % (k, v)\n                                       for k, v in req.headers.items())\n        status_int = response.status_int\n        if getattr(req, 'client_disconnect', False) or \\\n                getattr(response, 'client_disconnect', False):\n            status_int = 499\n        self.logger.info(' '.join(quote(str(x)) for x in (client or '-',\n            req.remote_addr or '-', strftime('%d/%b/%Y/%H/%M/%S', gmtime()),\n            req.method, the_request, req.environ['SERVER_PROTOCOL'],\n            status_int, req.referer or '-', req.user_agent or '-',\n            req.headers.get('x-auth-token',\n                req.headers.get('x-auth-admin-user', '-')),\n            getattr(req, 'bytes_transferred', 0) or '-',\n            getattr(response, 'bytes_transferred', 0) or '-',\n            req.headers.get('etag', '-'),\n            req.headers.get('x-trans-id', '-'), logged_headers or '-',\n            trans_time)))\n\n\ndef filter_factory(global_conf, **local_conf):\n    \"\"\"Returns a WSGI filter app for use with paste.deploy.\"\"\"\n    conf = global_conf.copy()\n    conf.update(local_conf)\n\n    def auth_filter(app):\n        return Swauth(app, conf)\n    return auth_filter\n", "# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n# implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\n# Pablo Llopis 2011\n\nimport mock\nfrom swauth import authtypes\nimport unittest\n\n\nclass TestValidation(unittest.TestCase):\n    def test_validate_creds(self):\n        creds = 'plaintext:keystring'\n        creds_dict = dict(type='plaintext', salt=None, hash='keystring')\n        auth_encoder, parsed_creds = authtypes.validate_creds(creds)\n        self.assertEqual(parsed_creds, creds_dict)\n        self.assertTrue(isinstance(auth_encoder, authtypes.Plaintext))\n\n        creds = 'sha1:salt$d50dc700c296e23ce5b41f7431a0e01f69010f06'\n        creds_dict = dict(type='sha1', salt='salt',\n                          hash='d50dc700c296e23ce5b41f7431a0e01f69010f06')\n        auth_encoder, parsed_creds = authtypes.validate_creds(creds)\n        self.assertEqual(parsed_creds, creds_dict)\n        self.assertTrue(isinstance(auth_encoder, authtypes.Sha1))\n\n        creds = ('sha512:salt$482e73705fac6909e2d78e8bbaf65ac3ca1473'\n                 '8f445cc2367b7daa3f0e8f3dcfe798e426b9e332776c8da59c'\n                 '0c11d4832931d1bf48830f670ecc6ceb04fbad0f')\n        creds_dict = dict(type='sha512', salt='salt',\n                          hash='482e73705fac6909e2d78e8bbaf65ac3ca1473'\n                               '8f445cc2367b7daa3f0e8f3dcfe798e426b9e3'\n                               '32776c8da59c0c11d4832931d1bf48830f670e'\n                               'cc6ceb04fbad0f')\n        auth_encoder, parsed_creds = authtypes.validate_creds(creds)\n        self.assertEqual(parsed_creds, creds_dict)\n        self.assertTrue(isinstance(auth_encoder, authtypes.Sha512))\n\n    def test_validate_creds_fail(self):\n        # wrong format, missing `:`\n        creds = 'unknown;keystring'\n        self.assertRaisesRegexp(ValueError, \"Missing ':' in .*\",\n                                authtypes.validate_creds, creds)\n        # unknown auth_type\n        creds = 'unknown:keystring'\n        self.assertRaisesRegexp(ValueError, \"Invalid auth_type: .*\",\n                                authtypes.validate_creds, creds)\n        # wrong plaintext keystring\n        creds = 'plaintext:'\n        self.assertRaisesRegexp(ValueError, \"Key must have non-zero length!\",\n                                authtypes.validate_creds, creds)\n        # wrong sha1 format, missing `$`\n        creds = 'sha1:saltkeystring'\n        self.assertRaisesRegexp(ValueError, \"Missing '\\$' in .*\",\n                                authtypes.validate_creds, creds)\n        # wrong sha1 format, missing salt\n        creds = 'sha1:$hash'\n        self.assertRaisesRegexp(ValueError, \"Salt must have non-zero length!\",\n                                authtypes.validate_creds, creds)\n        # wrong sha1 format, missing hash\n        creds = 'sha1:salt$'\n        self.assertRaisesRegexp(ValueError, \"Hash must have 40 chars!\",\n                                authtypes.validate_creds, creds)\n        # wrong sha1 format, short hash\n        creds = 'sha1:salt$short_hash'\n        self.assertRaisesRegexp(ValueError, \"Hash must have 40 chars!\",\n                                authtypes.validate_creds, creds)\n        # wrong sha1 format, wrong format\n        creds = 'sha1:salt$' + \"z\" * 40\n        self.assertRaisesRegexp(ValueError, \"Hash must be hexadecimal!\",\n                                authtypes.validate_creds, creds)\n        # wrong sha512 format, missing `$`\n        creds = 'sha512:saltkeystring'\n        self.assertRaisesRegexp(ValueError, \"Missing '\\$' in .*\",\n                                authtypes.validate_creds, creds)\n        # wrong sha512 format, missing salt\n        creds = 'sha512:$hash'\n        self.assertRaisesRegexp(ValueError, \"Salt must have non-zero length!\",\n                                authtypes.validate_creds, creds)\n        # wrong sha512 format, missing hash\n        creds = 'sha512:salt$'\n        self.assertRaisesRegexp(ValueError, \"Hash must have 128 chars!\",\n                                authtypes.validate_creds, creds)\n        # wrong sha512 format, short hash\n        creds = 'sha512:salt$short_hash'\n        self.assertRaisesRegexp(ValueError, \"Hash must have 128 chars!\",\n                                authtypes.validate_creds, creds)\n        # wrong sha1 format, wrong format\n        creds = 'sha512:salt$' + \"z\" * 128\n        self.assertRaisesRegexp(ValueError, \"Hash must be hexadecimal!\",\n                                authtypes.validate_creds, creds)\n\n\nclass TestPlaintext(unittest.TestCase):\n\n    def setUp(self):\n        self.auth_encoder = authtypes.Plaintext()\n\n    def test_plaintext_encode(self):\n        enc_key = self.auth_encoder.encode('keystring')\n        self.assertEqual('plaintext:keystring', enc_key)\n\n    def test_plaintext_valid_match(self):\n        creds = 'plaintext:keystring'\n        match = self.auth_encoder.match('keystring', creds)\n        self.assertEqual(match, True)\n\n    def test_plaintext_invalid_match(self):\n        creds = 'plaintext:other-keystring'\n        match = self.auth_encoder.match('keystring', creds)\n        self.assertEqual(match, False)\n\n\nclass TestSha1(unittest.TestCase):\n\n    def setUp(self):\n        self.auth_encoder = authtypes.Sha1()\n        self.auth_encoder.salt = 'salt'\n\n    @mock.patch('swauth.authtypes.os')\n    def test_sha1_encode(self, os):\n        os.urandom.return_value.encode.return_value.rstrip \\\n            .return_value = 'salt'\n        enc_key = self.auth_encoder.encode('keystring')\n        self.assertEqual('sha1:salt$d50dc700c296e23ce5b41f7431a0e01f69010f06',\n                         enc_key)\n\n    def test_sha1_valid_match(self):\n        creds = 'sha1:salt$d50dc700c296e23ce5b41f7431a0e01f69010f06'\n        creds_dict = dict(type='sha1', salt='salt',\n                          hash='d50dc700c296e23ce5b41f7431a0e01f69010f06')\n        match = self.auth_encoder.match('keystring', creds, **creds_dict)\n        self.assertEqual(match, True)\n\n    def test_sha1_invalid_match(self):\n        creds = 'sha1:salt$deadbabedeadbabedeadbabec0ffeebadc0ffeee'\n        creds_dict = dict(type='sha1', salt='salt',\n                          hash='deadbabedeadbabedeadbabec0ffeebadc0ffeee')\n        match = self.auth_encoder.match('keystring', creds, **creds_dict)\n        self.assertEqual(match, False)\n\n        creds = 'sha1:salt$d50dc700c296e23ce5b41f7431a0e01f69010f06'\n        creds_dict = dict(type='sha1', salt='salt',\n                          hash='d50dc700c296e23ce5b41f7431a0e01f69010f06')\n        match = self.auth_encoder.match('keystring2', creds, **creds_dict)\n        self.assertEqual(match, False)\n\n\nclass TestSha512(unittest.TestCase):\n\n    def setUp(self):\n        self.auth_encoder = authtypes.Sha512()\n        self.auth_encoder.salt = 'salt'\n\n    @mock.patch('swauth.authtypes.os')\n    def test_sha512_encode(self, os):\n        os.urandom.return_value.encode.return_value.rstrip \\\n            .return_value = 'salt'\n        enc_key = self.auth_encoder.encode('keystring')\n        self.assertEqual('sha512:salt$482e73705fac6909e2d78e8bbaf65ac3ca1473'\n                         '8f445cc2367b7daa3f0e8f3dcfe798e426b9e332776c8da59c'\n                         '0c11d4832931d1bf48830f670ecc6ceb04fbad0f', enc_key)\n\n    def test_sha512_valid_match(self):\n        creds = ('sha512:salt$482e73705fac6909e2d78e8bbaf65ac3ca14738f445cc2'\n                 '367b7daa3f0e8f3dcfe798e426b9e332776c8da59c0c11d4832931d1bf'\n                 '48830f670ecc6ceb04fbad0f')\n        creds_dict = dict(type='sha512', salt='salt',\n                          hash='482e73705fac6909e2d78e8bbaf65ac3ca14738f445cc2'\n                               '367b7daa3f0e8f3dcfe798e426b9e332776c8da59c0c11'\n                               'd4832931d1bf48830f670ecc6ceb04fbad0f')\n        match = self.auth_encoder.match('keystring', creds, **creds_dict)\n        self.assertEqual(match, True)\n\n    def test_sha512_invalid_match(self):\n        creds = ('sha512:salt$deadbabedeadbabedeadbabedeadbabedeadbabedeadba'\n                 'bedeadbabedeadbabedeadbabedeadbabedeadbabedeadbabedeadbabe'\n                 'c0ffeebadc0ffeeec0ffeeba')\n        creds_dict = dict(type='sha512', salt='salt',\n                          hash='deadbabedeadbabedeadbabedeadbabedeadbabedeadba'\n                               'bedeadbabedeadbabedeadbabedeadbabedeadbabedead'\n                               'babedeadbabec0ffeebadc0ffeeec0ffeeba')\n        match = self.auth_encoder.match('keystring', creds, **creds_dict)\n        self.assertEqual(match, False)\n\n        creds = ('sha512:salt$482e73705fac6909e2d78e8bbaf65ac3ca14738f445cc2'\n                 '367b7daa3f0e8f3dcfe798e426b9e332776c8da59c0c11d4832931d1bf'\n                 '48830f670ecc6ceb04fbad0f')\n        creds_dict = dict(type='sha512', salt='salt',\n                          hash='482e73705fac6909e2d78e8bbaf65ac3ca14738f445cc2'\n                               '367b7daa3f0e8f3dcfe798e426b9e332776c8da59c0c11'\n                               'd4832931d1bf48830f670ecc6ceb04fbad0f')\n        match = self.auth_encoder.match('keystring2', creds, **creds_dict)\n        self.assertEqual(match, False)\n\nif __name__ == '__main__':\n    unittest.main()\n", "# Copyright (c) 2010-2011 OpenStack, LLC.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n# implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom contextlib import contextmanager\nimport hashlib\nimport json\nimport mock\nfrom time import time\nimport unittest\nfrom urllib import quote\n\nfrom swift.common.swob import Request\nfrom swift.common.swob import Response\n\nfrom swauth.authtypes import MAX_TOKEN_LENGTH\nfrom swauth import middleware as auth\n\n\nCONTENT_TYPE_JSON = 'application/json'\nDEFAULT_TOKEN_LIFE = 86400\nMAX_TOKEN_LIFE = 100000\n\n\nclass FakeMemcache(object):\n\n    def __init__(self):\n        self.store = {}\n\n    def get(self, key):\n        return self.store.get(key)\n\n    def set(self, key, value, time=0):\n        self.store[key] = value\n        return True\n\n    def incr(self, key, time=0):\n        self.store[key] = self.store.setdefault(key, 0) + 1\n        return self.store[key]\n\n    @contextmanager\n    def soft_lock(self, key, retries=5, time=0):\n        yield True\n\n    def delete(self, key):\n        try:\n            del self.store[key]\n        except Exception:\n            pass\n        return True\n\n\nclass FakeApp(object):\n\n    def __init__(self, status_headers_body_iter=None, acl=None, sync_key=None):\n        self.calls = 0\n        self.status_headers_body_iter = status_headers_body_iter\n        if not self.status_headers_body_iter:\n            self.status_headers_body_iter = iter([('404 Not Found', {}, '')])\n        self.acl = acl\n        self.sync_key = sync_key\n\n    def __call__(self, env, start_response):\n        self.calls += 1\n        self.request = Request.blank('', environ=env)\n        if self.acl:\n            self.request.acl = self.acl\n        if self.sync_key:\n            self.request.environ['swift_sync_key'] = self.sync_key\n        if 'swift.authorize' in env:\n            resp = env['swift.authorize'](self.request)\n            if resp:\n                return resp(env, start_response)\n        status, headers, body = self.status_headers_body_iter.next()\n        return Response(status=status, headers=headers,\n                        body=body)(env, start_response)\n\n\nclass FakeConn(object):\n\n    def __init__(self, status_headers_body_iter=None):\n        self.calls = 0\n        self.status_headers_body_iter = status_headers_body_iter\n        if not self.status_headers_body_iter:\n            self.status_headers_body_iter = iter([('404 Not Found', {}, '')])\n\n    def request(self, method, path, headers):\n        self.calls += 1\n        self.request_path = path\n        self.status, self.headers, self.body = \\\n            self.status_headers_body_iter.next()\n        self.status, self.reason = self.status.split(' ', 1)\n        self.status = int(self.status)\n\n    def getresponse(self):\n        return self\n\n    def read(self):\n        body = self.body\n        self.body = ''\n        return body\n\n\nclass TestAuth(unittest.TestCase):\n\n    def setUp(self):\n        self.test_auth = \\\n            auth.filter_factory({\n                'super_admin_key': 'supertest',\n                'token_life': str(DEFAULT_TOKEN_LIFE),\n                'max_token_life': str(MAX_TOKEN_LIFE)})(FakeApp())\n\n    def test_salt(self):\n        for auth_type in ('sha1', 'sha512'):\n            # Salt not manually set\n            test_auth = \\\n                auth.filter_factory({\n                    'super_admin_key': 'supertest',\n                    'token_life': str(DEFAULT_TOKEN_LIFE),\n                    'max_token_life': str(MAX_TOKEN_LIFE),\n                    'auth_type': auth_type})(FakeApp())\n            self.assertEqual(test_auth.auth_encoder.salt, None)\n            mock_urandom = mock.Mock(return_value=\"abc\")\n            with mock.patch(\"os.urandom\", mock_urandom):\n                h_key = test_auth.auth_encoder().encode(\"key\")\n            self.assertTrue(mock_urandom.called)\n            prefix = auth_type + \":\" + \"abc\".encode('base64').rstrip() + '$'\n            self.assertTrue(h_key.startswith(prefix))\n\n            # Salt manually set\n            test_auth = \\\n                auth.filter_factory({\n                    'super_admin_key': 'supertest',\n                    'token_life': str(DEFAULT_TOKEN_LIFE),\n                    'max_token_life': str(MAX_TOKEN_LIFE),\n                    'auth_type': auth_type,\n                    'auth_type_salt': \"mysalt\"})(FakeApp())\n            self.assertEqual(test_auth.auth_encoder.salt, \"mysalt\")\n            mock_urandom = mock.Mock()\n            with mock.patch(\"os.urandom\", mock_urandom):\n                h_key = test_auth.auth_encoder().encode(\"key\")\n            self.assertFalse(mock_urandom.called)\n            prefix = auth_type + \":\" + \"mysalt\" + '$'\n            self.assertTrue(h_key.startswith(prefix))\n\n    def test_swift_version(self):\n        app = FakeApp()\n\n        with mock.patch('swauth.swift_version.at_least') as mock_at_least:\n            mock_at_least.return_value = False\n            self.assertRaises(ValueError, auth.filter_factory({}), app)\n\n    def test_super_admin_key_not_required(self):\n        auth.filter_factory({})(FakeApp())\n\n    def test_reseller_prefix_init(self):\n        app = FakeApp()\n        ath = auth.filter_factory({'super_admin_key': 'supertest'})(app)\n        self.assertEqual(ath.reseller_prefix, 'AUTH_')\n        ath = auth.filter_factory({'super_admin_key': 'supertest',\n                                   'reseller_prefix': 'TEST'})(app)\n        self.assertEqual(ath.reseller_prefix, 'TEST_')\n        ath = auth.filter_factory({'super_admin_key': 'supertest',\n                                   'reseller_prefix': 'TEST_'})(app)\n        self.assertEqual(ath.reseller_prefix, 'TEST_')\n\n    def test_auth_prefix_init(self):\n        app = FakeApp()\n        ath = auth.filter_factory({'super_admin_key': 'supertest'})(app)\n        self.assertEqual(ath.auth_prefix, '/auth/')\n        ath = auth.filter_factory({'super_admin_key': 'supertest',\n                                   'auth_prefix': ''})(app)\n        self.assertEqual(ath.auth_prefix, '/auth/')\n        ath = auth.filter_factory({'super_admin_key': 'supertest',\n                                   'auth_prefix': '/test/'})(app)\n        self.assertEqual(ath.auth_prefix, '/test/')\n        ath = auth.filter_factory({'super_admin_key': 'supertest',\n                                   'auth_prefix': '/test'})(app)\n        self.assertEqual(ath.auth_prefix, '/test/')\n        ath = auth.filter_factory({'super_admin_key': 'supertest',\n                                   'auth_prefix': 'test/'})(app)\n        self.assertEqual(ath.auth_prefix, '/test/')\n        ath = auth.filter_factory({'super_admin_key': 'supertest',\n                                   'auth_prefix': 'test'})(app)\n        self.assertEqual(ath.auth_prefix, '/test/')\n\n    def test_no_auth_type_init(self):\n        app = FakeApp()\n        ath = auth.filter_factory({})(app)\n        self.assertEqual(ath.auth_type, 'Plaintext')\n\n    def test_valid_auth_type_init(self):\n        app = FakeApp()\n        ath = auth.filter_factory({'auth_type': 'sha1'})(app)\n        self.assertEqual(ath.auth_type, 'Sha1')\n        ath = auth.filter_factory({'auth_type': 'plaintext'})(app)\n        self.assertEqual(ath.auth_type, 'Plaintext')\n\n    def test_invalid_auth_type_init(self):\n        app = FakeApp()\n        exc = None\n        try:\n            auth.filter_factory({'auth_type': 'NONEXISTANT'})(app)\n        except Exception as err:\n            exc = err\n        self.assertEqual(str(exc),\n                         'Invalid auth_type in config file: %s' %\n                         'Nonexistant')\n\n    def test_default_swift_cluster_init(self):\n        app = FakeApp()\n        self.assertRaises(ValueError, auth.filter_factory({\n            'super_admin_key': 'supertest',\n            'default_swift_cluster': 'local#badscheme://host/path'}), app)\n        ath = auth.filter_factory({'super_admin_key': 'supertest'})(app)\n        self.assertEqual(ath.default_swift_cluster,\n                         'local#http://127.0.0.1:8080/v1')\n        ath = auth.filter_factory({'super_admin_key': 'supertest',\n            'default_swift_cluster': 'local#http://host/path'})(app)\n        self.assertEqual(ath.default_swift_cluster,\n                         'local#http://host/path')\n        ath = auth.filter_factory({'super_admin_key': 'supertest',\n            'default_swift_cluster': 'local#https://host/path/'})(app)\n        self.assertEqual(ath.dsc_url, 'https://host/path')\n        self.assertEqual(ath.dsc_url2, 'https://host/path')\n        ath = auth.filter_factory({'super_admin_key': 'supertest',\n            'default_swift_cluster':\n                'local#https://host/path/#http://host2/path2/'})(app)\n        self.assertEqual(ath.dsc_url, 'https://host/path')\n        self.assertEqual(ath.dsc_url2, 'http://host2/path2')\n\n    def test_credentials_match_auth_encoder_type(self):\n        plaintext_auth = {'auth': 'plaintext:key'}\n        sha1_key = (\"sha1:T0YFdhqN4uDRWiYLxWa7H2T8AewG4fEYQyJFRLsgcfk=$46c58\"\n                    \"07eb8a32e8f404fea9eaaeb60b7e1207ff1\")\n        sha1_auth = {'auth': sha1_key}\n        sha512_key = (\"sha512:aSm0jEeqIp46T5YLZy1r8+cXs/Xzs1S4VUwVauhBs44=$ef\"\n                      \"7332ec1288bf69c75682eb8d459d5a84baa7e43f45949c242a9af9\"\n                      \"7130ef16ac361fe1aa33a789e218122b83c54ef1923fc015080741\"\n                      \"ca21f6187329f6cb7a\")\n        sha512_auth = {'auth': sha512_key}\n\n        # test all possible config settings work with all possible auth types\n        for auth_type in ('plaintext', 'sha1', 'sha512'):\n            test_auth = auth.filter_factory({'super_admin_key': 'superkey',\n                'auth_type': auth_type})(FakeApp())\n            for detail in (plaintext_auth, sha1_auth, sha512_auth):\n                self.assertTrue(test_auth.credentials_match(detail, 'key'))\n            # test invalid auth type stored\n            invalid_detail = {'auth': 'Junk:key'}\n            test_auth.logger = mock.Mock()\n            self.assertFalse(test_auth.credentials_match(invalid_detail,\n                                                         'key'))\n            # make sure error is logged\n            test_auth.logger.called_once_with('Invalid auth_type Junk')\n\n    def test_top_level_denied(self):\n        resp = Request.blank('/').get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n\n    def test_anon(self):\n        resp = Request.blank('/v1/AUTH_account').get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n        self.assertEqual(resp.environ['swift.authorize'],\n                         self.test_auth.authorize)\n\n    def test_auth_deny_non_reseller_prefix(self):\n        resp = Request.blank('/v1/BLAH_account',\n            headers={'X-Auth-Token': 'BLAH_t'}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n        self.assertEqual(resp.environ['swift.authorize'],\n                         self.test_auth.denied_response)\n\n    def test_auth_deny_non_reseller_prefix_no_override(self):\n        fake_authorize = lambda x: Response(status='500 Fake')\n        resp = Request.blank('/v1/BLAH_account',\n            headers={'X-Auth-Token': 'BLAH_t'},\n            environ={'swift.authorize': fake_authorize}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(resp.environ['swift.authorize'], fake_authorize)\n\n    def test_auth_no_reseller_prefix_deny(self):\n        # Ensures that when we have no reseller prefix, we don't deny a request\n        # outright but set up a denial swift.authorize and pass the request on\n        # down the chain.\n        local_app = FakeApp()\n        local_auth = auth.filter_factory({'super_admin_key': 'supertest',\n                                          'reseller_prefix': ''})(local_app)\n        resp = Request.blank('/v1/account',\n            headers={'X-Auth-Token': 't'}).get_response(local_auth)\n        self.assertEqual(resp.status_int, 401)\n        # one for checking auth, two for request passed along\n        self.assertEqual(local_app.calls, 2)\n        self.assertEqual(resp.environ['swift.authorize'],\n                         local_auth.denied_response)\n\n    def test_auth_no_reseller_prefix_allow(self):\n        # Ensures that when we have no reseller prefix, we can still allow\n        # access if our auth server accepts requests\n        local_app = FakeApp(iter([\n            ('200 Ok', {},\n             json.dumps({'account': 'act', 'user': 'act:usr',\n                         'account_id': 'AUTH_cfa',\n                         'groups': [{'name': 'act:usr'}, {'name': 'act'},\n                                    {'name': '.admin'}],\n                         'expires': time() + 60})),\n            ('204 No Content', {}, '')]))\n        local_auth = auth.filter_factory({'super_admin_key': 'supertest',\n                                          'reseller_prefix': ''})(local_app)\n        resp = Request.blank('/v1/act',\n            headers={'X-Auth-Token': 't'}).get_response(local_auth)\n        self.assertEqual(resp.status_int, 204)\n        self.assertEqual(local_app.calls, 2)\n        self.assertEqual(resp.environ['swift.authorize'],\n                         local_auth.authorize)\n\n    def test_auth_no_reseller_prefix_no_token(self):\n        # Check that normally we set up a call back to our authorize.\n        local_auth = \\\n            auth.filter_factory({'super_admin_key': 'supertest',\n                                 'reseller_prefix': ''})(FakeApp(iter([])))\n        resp = Request.blank('/v1/account').get_response(local_auth)\n        self.assertEqual(resp.status_int, 401)\n        self.assertEqual(resp.environ['swift.authorize'],\n                         local_auth.authorize)\n        # Now make sure we don't override an existing swift.authorize when we\n        # have no reseller prefix.\n        local_auth = \\\n            auth.filter_factory({'super_admin_key': 'supertest',\n                                 'reseller_prefix': ''})(FakeApp())\n        local_authorize = lambda req: Response('test')\n        resp = Request.blank('/v1/account', environ={'swift.authorize':\n            local_authorize}).get_response(local_auth)\n        self.assertEqual(resp.status_int, 200)\n        self.assertEqual(resp.environ['swift.authorize'], local_authorize)\n\n    def test_auth_fail(self):\n        resp = Request.blank('/v1/AUTH_cfa',\n            headers={'X-Auth-Token': 'AUTH_t'}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n\n    def test_auth_success(self):\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {},\n             json.dumps({'account': 'act', 'user': 'act:usr',\n                         'account_id': 'AUTH_cfa',\n                         'groups': [{'name': 'act:usr'}, {'name': 'act'},\n                                    {'name': '.admin'}],\n                         'expires': time() + 60})),\n            ('204 No Content', {}, '')]))\n        resp = Request.blank('/v1/AUTH_cfa',\n            headers={'X-Auth-Token': 'AUTH_t'}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 204)\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n    def test_auth_memcache(self):\n        # First run our test without memcache, showing we need to return the\n        # token contents twice.\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {},\n             json.dumps({'account': 'act', 'user': 'act:usr',\n                         'account_id': 'AUTH_cfa',\n                         'groups': [{'name': 'act:usr'}, {'name': 'act'},\n                                    {'name': '.admin'}],\n                         'expires': time() + 60})),\n            ('204 No Content', {}, ''),\n            ('200 Ok', {},\n             json.dumps({'account': 'act', 'user': 'act:usr',\n                         'account_id': 'AUTH_cfa',\n                         'groups': [{'name': 'act:usr'}, {'name': 'act'},\n                                    {'name': '.admin'}],\n                         'expires': time() + 60})),\n            ('204 No Content', {}, '')]))\n        resp = Request.blank('/v1/AUTH_cfa',\n            headers={'X-Auth-Token': 'AUTH_t'}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 204)\n        resp = Request.blank('/v1/AUTH_cfa',\n            headers={'X-Auth-Token': 'AUTH_t'}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 204)\n        self.assertEqual(self.test_auth.app.calls, 4)\n        # Now run our test with memcache, showing we no longer need to return\n        # the token contents twice.\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {},\n             json.dumps({'account': 'act', 'user': 'act:usr',\n                         'account_id': 'AUTH_cfa',\n                         'groups': [{'name': 'act:usr'}, {'name': 'act'},\n                                    {'name': '.admin'}],\n                         'expires': time() + 60})),\n            ('204 No Content', {}, ''),\n            # Don't need a second token object returned if memcache is used\n            ('204 No Content', {}, '')]))\n        fake_memcache = FakeMemcache()\n        resp = Request.blank('/v1/AUTH_cfa',\n            headers={'X-Auth-Token': 'AUTH_t'},\n            environ={'swift.cache': fake_memcache}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 204)\n        resp = Request.blank('/v1/AUTH_cfa',\n            headers={'X-Auth-Token': 'AUTH_t'},\n            environ={'swift.cache': fake_memcache}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 204)\n        self.assertEqual(self.test_auth.app.calls, 3)\n\n    def test_auth_just_expired(self):\n        self.test_auth.app = FakeApp(iter([\n            # Request for token (which will have expired)\n            ('200 Ok', {},\n             json.dumps({'account': 'act', 'user': 'act:usr',\n                         'account_id': 'AUTH_cfa',\n                         'groups': [{'name': 'act:usr'}, {'name': 'act'},\n                                    {'name': '.admin'}],\n                         'expires': time() - 1})),\n            # Request to delete token\n            ('204 No Content', {}, '')]))\n        resp = Request.blank('/v1/AUTH_cfa',\n            headers={'X-Auth-Token': 'AUTH_t'}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n    def test_middleware_storage_token(self):\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {},\n             json.dumps({'account': 'act', 'user': 'act:usr',\n                         'account_id': 'AUTH_cfa',\n                         'groups': [{'name': 'act:usr'}, {'name': 'act'},\n                                    {'name': '.admin'}],\n                         'expires': time() + 60})),\n            ('204 No Content', {}, '')]))\n        resp = Request.blank('/v1/AUTH_cfa',\n            headers={'X-Storage-Token': 'AUTH_t'}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 204)\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n    def test_authorize_bad_path(self):\n        req = Request.blank('/badpath')\n        resp = self.test_auth.authorize(req)\n        self.assertEqual(resp.status_int, 401)\n        req = Request.blank('/badpath')\n        req.remote_user = 'act:usr,act,AUTH_cfa'\n        resp = self.test_auth.authorize(req)\n        self.assertEqual(resp.status_int, 403)\n\n    def test_authorize_account_access(self):\n        req = Request.blank('/v1/AUTH_cfa')\n        req.remote_user = 'act:usr,act,AUTH_cfa'\n        self.assertEqual(self.test_auth.authorize(req), None)\n        req = Request.blank('/v1/AUTH_cfa')\n        req.remote_user = 'act:usr,act'\n        resp = self.test_auth.authorize(req)\n        self.assertEqual(resp.status_int, 403)\n\n    def test_authorize_acl_group_access(self):\n        req = Request.blank('/v1/AUTH_cfa')\n        req.remote_user = 'act:usr,act'\n        resp = self.test_auth.authorize(req)\n        self.assertEqual(resp.status_int, 403)\n        req = Request.blank('/v1/AUTH_cfa')\n        req.remote_user = 'act:usr,act'\n        req.acl = 'act'\n        self.assertEqual(self.test_auth.authorize(req), None)\n        req = Request.blank('/v1/AUTH_cfa')\n        req.remote_user = 'act:usr,act'\n        req.acl = 'act:usr'\n        self.assertEqual(self.test_auth.authorize(req), None)\n        req = Request.blank('/v1/AUTH_cfa')\n        req.remote_user = 'act:usr,act'\n        req.acl = 'act2'\n        resp = self.test_auth.authorize(req)\n        self.assertEqual(resp.status_int, 403)\n        req = Request.blank('/v1/AUTH_cfa')\n        req.remote_user = 'act:usr,act'\n        req.acl = 'act:usr2'\n        resp = self.test_auth.authorize(req)\n        self.assertEqual(resp.status_int, 403)\n\n    def test_deny_cross_reseller(self):\n        # Tests that cross-reseller is denied, even if ACLs/group names match\n        req = Request.blank('/v1/OTHER_cfa')\n        req.remote_user = 'act:usr,act,AUTH_cfa'\n        req.acl = 'act'\n        resp = self.test_auth.authorize(req)\n        self.assertEqual(resp.status_int, 403)\n\n    def test_authorize_acl_referrer_access(self):\n        req = Request.blank('/v1/AUTH_cfa/c')\n        req.remote_user = 'act:usr,act'\n        resp = self.test_auth.authorize(req)\n        self.assertEqual(resp.status_int, 403)\n        req = Request.blank('/v1/AUTH_cfa/c')\n        req.remote_user = 'act:usr,act'\n        req.acl = '.r:*,.rlistings'\n        self.assertEqual(self.test_auth.authorize(req), None)\n        req = Request.blank('/v1/AUTH_cfa/c')\n        req.remote_user = 'act:usr,act'\n        req.acl = '.r:*'  # No listings allowed\n        resp = self.test_auth.authorize(req)\n        self.assertEqual(resp.status_int, 403)\n        req = Request.blank('/v1/AUTH_cfa/c')\n        req.remote_user = 'act:usr,act'\n        req.acl = '.r:.example.com,.rlistings'\n        resp = self.test_auth.authorize(req)\n        self.assertEqual(resp.status_int, 403)\n        req = Request.blank('/v1/AUTH_cfa/c')\n        req.remote_user = 'act:usr,act'\n        req.referer = 'http://www.example.com/index.html'\n        req.acl = '.r:.example.com,.rlistings'\n        self.assertEqual(self.test_auth.authorize(req), None)\n        req = Request.blank('/v1/AUTH_cfa/c')\n        resp = self.test_auth.authorize(req)\n        self.assertEqual(resp.status_int, 401)\n        req = Request.blank('/v1/AUTH_cfa/c')\n        req.acl = '.r:*,.rlistings'\n        self.assertEqual(self.test_auth.authorize(req), None)\n        req = Request.blank('/v1/AUTH_cfa/c')\n        req.acl = '.r:*'  # No listings allowed\n        resp = self.test_auth.authorize(req)\n        self.assertEqual(resp.status_int, 401)\n        req = Request.blank('/v1/AUTH_cfa/c')\n        req.acl = '.r:.example.com,.rlistings'\n        resp = self.test_auth.authorize(req)\n        self.assertEqual(resp.status_int, 401)\n        req = Request.blank('/v1/AUTH_cfa/c')\n        req.referer = 'http://www.example.com/index.html'\n        req.acl = '.r:.example.com,.rlistings'\n        self.assertEqual(self.test_auth.authorize(req), None)\n\n    def test_detect_reseller_request(self):\n        req = self._make_request('/v1/AUTH_admin',\n                                 headers={'X-Auth-Token': 'AUTH_t'})\n        cache_key = 'AUTH_/auth/AUTH_t'\n        cache_entry = (time() + 3600, '.reseller_admin')\n        req.environ['swift.cache'].set(cache_key, cache_entry)\n        req.get_response(self.test_auth)\n        self.assertTrue(req.environ.get('reseller_request'))\n\n    def test_account_put_permissions(self):\n        req = Request.blank('/v1/AUTH_new', environ={'REQUEST_METHOD': 'PUT'})\n        req.remote_user = 'act:usr,act'\n        resp = self.test_auth.authorize(req)\n        self.assertEqual(resp.status_int, 403)\n\n        req = Request.blank('/v1/AUTH_new', environ={'REQUEST_METHOD': 'PUT'})\n        req.remote_user = 'act:usr,act,AUTH_other'\n        resp = self.test_auth.authorize(req)\n        self.assertEqual(resp.status_int, 403)\n\n        # Even PUTs to your own account as account admin should fail\n        req = Request.blank('/v1/AUTH_old', environ={'REQUEST_METHOD': 'PUT'})\n        req.remote_user = 'act:usr,act,AUTH_old'\n        resp = self.test_auth.authorize(req)\n        self.assertEqual(resp.status_int, 403)\n\n        req = Request.blank('/v1/AUTH_new', environ={'REQUEST_METHOD': 'PUT'})\n        req.remote_user = 'act:usr,act,.reseller_admin'\n        resp = self.test_auth.authorize(req)\n        self.assertEqual(resp, None)\n\n        # .super_admin is not something the middleware should ever see or care\n        # about\n        req = Request.blank('/v1/AUTH_new', environ={'REQUEST_METHOD': 'PUT'})\n        req.remote_user = 'act:usr,act,.super_admin'\n        resp = self.test_auth.authorize(req)\n        self.assertEqual(resp.status_int, 403)\n\n    def test_account_delete_permissions(self):\n        req = Request.blank('/v1/AUTH_new',\n                            environ={'REQUEST_METHOD': 'DELETE'})\n        req.remote_user = 'act:usr,act'\n        resp = self.test_auth.authorize(req)\n        self.assertEqual(resp.status_int, 403)\n\n        req = Request.blank('/v1/AUTH_new',\n                            environ={'REQUEST_METHOD': 'DELETE'})\n        req.remote_user = 'act:usr,act,AUTH_other'\n        resp = self.test_auth.authorize(req)\n        self.assertEqual(resp.status_int, 403)\n\n        # Even DELETEs to your own account as account admin should fail\n        req = Request.blank('/v1/AUTH_old',\n                            environ={'REQUEST_METHOD': 'DELETE'})\n        req.remote_user = 'act:usr,act,AUTH_old'\n        resp = self.test_auth.authorize(req)\n        self.assertEqual(resp.status_int, 403)\n\n        req = Request.blank('/v1/AUTH_new',\n                            environ={'REQUEST_METHOD': 'DELETE'})\n        req.remote_user = 'act:usr,act,.reseller_admin'\n        resp = self.test_auth.authorize(req)\n        self.assertEqual(resp, None)\n\n        # .super_admin is not something the middleware should ever see or care\n        # about\n        req = Request.blank('/v1/AUTH_new',\n                            environ={'REQUEST_METHOD': 'DELETE'})\n        req.remote_user = 'act:usr,act,.super_admin'\n        resp = self.test_auth.authorize(req)\n        resp = self.test_auth.authorize(req)\n        self.assertEqual(resp.status_int, 403)\n\n    def test_get_token_fail(self):\n        resp = Request.blank('/auth/v1.0').get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n        resp = Request.blank('/auth/v1.0',\n            headers={'X-Auth-User': 'act:usr',\n                     'X-Auth-Key': 'key'}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n\n    def test_get_token_fail_invalid_key(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object\n            ('200 Ok', {},\n             json.dumps({\"auth\": \"plaintext:key\",\n                         \"groups\": [{'name': \"act:usr\"}, {'name': \"act\"},\n                                    {'name': \".admin\"}]}))]))\n        resp = Request.blank('/auth/v1.0',\n            headers={'X-Auth-User': 'act:usr',\n                     'X-Auth-Key': 'invalid'}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_get_token_fail_invalid_x_auth_user_format(self):\n        resp = Request.blank('/auth/v1/act/auth',\n            headers={'X-Auth-User': 'usr',\n                     'X-Auth-Key': 'key'}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n\n    def test_get_token_fail_non_matching_account_in_request(self):\n        resp = Request.blank('/auth/v1/act/auth',\n            headers={'X-Auth-User': 'act2:usr',\n                     'X-Auth-Key': 'key'}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n\n    def test_get_token_fail_bad_path(self):\n        resp = Request.blank('/auth/v1/act/auth/invalid',\n            headers={'X-Auth-User': 'act:usr',\n                     'X-Auth-Key': 'key'}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 400)\n\n    def test_get_token_fail_missing_key(self):\n        resp = Request.blank('/auth/v1/act/auth',\n            headers={'X-Auth-User': 'act:usr'}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n\n    def test_get_token_fail_get_user_details(self):\n        self.test_auth.app = FakeApp(iter([\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v1.0',\n            headers={'X-Auth-User': 'act:usr',\n                     'X-Auth-Key': 'key'}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_get_token_fail_get_account(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object\n            ('200 Ok', {},\n             json.dumps({\"auth\": \"plaintext:key\",\n                         \"groups\": [{'name': \"act:usr\"}, {'name': \"act\"},\n                                    {'name': \".admin\"}]})),\n            # GET of account\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v1.0',\n            headers={'X-Auth-User': 'act:usr',\n                     'X-Auth-Key': 'key'}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n    def test_get_token_fail_put_new_token(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object\n            ('200 Ok', {},\n             json.dumps({\"auth\": \"plaintext:key\",\n                         \"groups\": [{'name': \"act:usr\"}, {'name': \"act\"},\n                                    {'name': \".admin\"}]})),\n            # GET of account\n            ('204 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, ''),\n            # PUT of new token\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v1.0',\n            headers={'X-Auth-User': 'act:usr',\n                     'X-Auth-Key': 'key'}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 3)\n\n    def test_get_token_fail_post_to_user(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object\n            ('200 Ok', {},\n             json.dumps({\"auth\": \"plaintext:key\",\n                         \"groups\": [{'name': \"act:usr\"}, {'name': \"act\"},\n                                    {'name': \".admin\"}]})),\n            # GET of account\n            ('204 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, ''),\n            # PUT of new token\n            ('201 Created', {}, ''),\n            # POST of token to user object\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v1.0',\n            headers={'X-Auth-User': 'act:usr',\n                     'X-Auth-Key': 'key'}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 4)\n\n    def test_get_token_fail_get_services(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object\n            ('200 Ok', {},\n             json.dumps({\"auth\": \"plaintext:key\",\n                         \"groups\": [{'name': \"act:usr\"}, {'name': \"act\"},\n                                    {'name': \".admin\"}]})),\n            # GET of account\n            ('204 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, ''),\n            # PUT of new token\n            ('201 Created', {}, ''),\n            # POST of token to user object\n            ('204 No Content', {}, ''),\n            # GET of services object\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v1.0',\n            headers={'X-Auth-User': 'act:usr',\n                     'X-Auth-Key': 'key'}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 5)\n\n    def test_get_token_fail_get_existing_token(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object\n            ('200 Ok', {'X-Object-Meta-Auth-Token': 'AUTH_tktest'},\n             json.dumps({\"auth\": \"plaintext:key\",\n                         \"groups\": [{'name': \"act:usr\"}, {'name': \"act\"},\n                                    {'name': \".admin\"}]})),\n            # GET of token\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v1.0',\n            headers={'X-Auth-User': 'act:usr',\n                     'X-Auth-Key': 'key'}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n    def test_get_token_success_v1_0(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object\n            ('200 Ok', {},\n             json.dumps({\"auth\": \"plaintext:key\",\n                         \"groups\": [{'name': \"act:usr\"}, {'name': \"act\"},\n                                    {'name': \".admin\"}]})),\n            # GET of account\n            ('204 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, ''),\n            # PUT of new token\n            ('201 Created', {}, ''),\n            # POST of token to user object\n            ('204 No Content', {}, ''),\n            # GET of services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n             \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}}))]))\n        resp = Request.blank('/auth/v1.0',\n            headers={'X-Auth-User': 'act:usr',\n                     'X-Auth-Key': 'key'}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 200)\n        self.assertEqual(resp.content_type, CONTENT_TYPE_JSON)\n        self.assertTrue(resp.headers.get('x-auth-token',\n            '').startswith('AUTH_tk'), resp.headers.get('x-auth-token'))\n        self.assertEqual(resp.headers.get('x-auth-token'),\n                         resp.headers.get('x-storage-token'))\n        self.assertEqual(resp.headers.get('x-storage-url'),\n                         'http://127.0.0.1:8080/v1/AUTH_cfa')\n        self.assertEqual(json.loads(resp.body),\n            {\"storage\": {\"default\": \"local\",\n             \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}})\n        self.assertEqual(self.test_auth.app.calls, 5)\n\n    def test_get_token_success_v1_0_with_user_token_life(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object\n            ('200 Ok', {},\n             json.dumps({\"auth\": \"plaintext:key\",\n                         \"groups\": [{'name': \"act:usr\"}, {'name': \"act\"},\n                                    {'name': \".admin\"}]})),\n            # GET of account\n            ('204 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, ''),\n            # PUT of new token\n            ('201 Created', {}, ''),\n            # POST of token to user object\n            ('204 No Content', {}, ''),\n            # GET of services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n             \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}}))]))\n        resp = Request.blank('/auth/v1.0',\n            headers={'X-Auth-User': 'act:usr',\n                     'X-Auth-Key': 'key',\n                     'X-Auth-Token-Lifetime': 10}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 200)\n        self.assertEqual(resp.content_type, CONTENT_TYPE_JSON)\n        left = int(resp.headers['x-auth-token-expires'])\n        self.assertTrue(left > 0, '%d > 0' % left)\n        self.assertTrue(left <= 10, '%d <= 10' % left)\n        self.assertTrue(resp.headers.get('x-auth-token',\n            '').startswith('AUTH_tk'), resp.headers.get('x-auth-token'))\n        self.assertEqual(resp.headers.get('x-auth-token'),\n                         resp.headers.get('x-storage-token'))\n        self.assertEqual(resp.headers.get('x-storage-url'),\n                         'http://127.0.0.1:8080/v1/AUTH_cfa')\n        self.assertEqual(json.loads(resp.body),\n            {\"storage\": {\"default\": \"local\",\n             \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}})\n        self.assertEqual(self.test_auth.app.calls, 5)\n\n    def test_get_token_success_v1_0_with_user_token_life_past_max(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object\n            ('200 Ok', {},\n             json.dumps({\"auth\": \"plaintext:key\",\n                         \"groups\": [{'name': \"act:usr\"}, {'name': \"act\"},\n                                    {'name': \".admin\"}]})),\n            # GET of account\n            ('204 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, ''),\n            # PUT of new token\n            ('201 Created', {}, ''),\n            # POST of token to user object\n            ('204 No Content', {}, ''),\n            # GET of services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n             \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}}))]))\n        req = Request.blank(\n            '/auth/v1.0',\n            headers={'X-Auth-User': 'act:usr',\n                     'X-Auth-Key': 'key',\n                     'X-Auth-Token-Lifetime': MAX_TOKEN_LIFE * 10})\n        resp = req.get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 200)\n        self.assertEqual(resp.content_type, CONTENT_TYPE_JSON)\n        left = int(resp.headers['x-auth-token-expires'])\n        self.assertTrue(left > DEFAULT_TOKEN_LIFE,\n                        '%d > %d' % (left, DEFAULT_TOKEN_LIFE))\n        self.assertTrue(left <= MAX_TOKEN_LIFE,\n                        '%d <= %d' % (left, MAX_TOKEN_LIFE))\n        self.assertTrue(resp.headers.get('x-auth-token',\n            '').startswith('AUTH_tk'), resp.headers.get('x-auth-token'))\n        self.assertEqual(resp.headers.get('x-auth-token'),\n                         resp.headers.get('x-storage-token'))\n        self.assertEqual(resp.headers.get('x-storage-url'),\n                         'http://127.0.0.1:8080/v1/AUTH_cfa')\n        self.assertEqual(json.loads(resp.body),\n            {\"storage\": {\"default\": \"local\",\n             \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}})\n        self.assertEqual(self.test_auth.app.calls, 5)\n\n    def test_get_token_success_v1_act_auth(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object\n            ('200 Ok', {},\n             json.dumps({\"auth\": \"plaintext:key\",\n                         \"groups\": [{'name': \"act:usr\"}, {'name': \"act\"},\n                                    {'name': \".admin\"}]})),\n            # GET of account\n            ('204 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, ''),\n            # PUT of new token\n            ('201 Created', {}, ''),\n            # POST of token to user object\n            ('204 No Content', {}, ''),\n            # GET of services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n             \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}}))]))\n        resp = Request.blank('/auth/v1/act/auth',\n            headers={'X-Storage-User': 'usr',\n                     'X-Storage-Pass': 'key'}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 200)\n        self.assertEqual(resp.content_type, CONTENT_TYPE_JSON)\n        self.assertTrue(resp.headers.get('x-auth-token',\n            '').startswith('AUTH_tk'), resp.headers.get('x-auth-token'))\n        self.assertEqual(resp.headers.get('x-auth-token'),\n                         resp.headers.get('x-storage-token'))\n        self.assertEqual(resp.headers.get('x-storage-url'),\n                         'http://127.0.0.1:8080/v1/AUTH_cfa')\n        self.assertEqual(json.loads(resp.body),\n            {\"storage\": {\"default\": \"local\",\n             \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}})\n        self.assertEqual(self.test_auth.app.calls, 5)\n\n    def test_get_token_success_storage_instead_of_auth(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object\n            ('200 Ok', {},\n             json.dumps({\"auth\": \"plaintext:key\",\n                         \"groups\": [{'name': \"act:usr\"}, {'name': \"act\"},\n                                    {'name': \".admin\"}]})),\n            # GET of account\n            ('204 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, ''),\n            # PUT of new token\n            ('201 Created', {}, ''),\n            # POST of token to user object\n            ('204 No Content', {}, ''),\n            # GET of services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n             \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}}))]))\n        resp = Request.blank('/auth/v1.0',\n            headers={'X-Storage-User': 'act:usr',\n                     'X-Storage-Pass': 'key'}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 200)\n        self.assertEqual(resp.content_type, CONTENT_TYPE_JSON)\n        self.assertTrue(resp.headers.get('x-auth-token',\n            '').startswith('AUTH_tk'), resp.headers.get('x-auth-token'))\n        self.assertEqual(resp.headers.get('x-auth-token'),\n                         resp.headers.get('x-storage-token'))\n        self.assertEqual(resp.headers.get('x-storage-url'),\n                         'http://127.0.0.1:8080/v1/AUTH_cfa')\n        self.assertEqual(json.loads(resp.body),\n            {\"storage\": {\"default\": \"local\",\n             \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}})\n        self.assertEqual(self.test_auth.app.calls, 5)\n\n    def test_get_token_success_v1_act_auth_auth_instead_of_storage(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object\n            ('200 Ok', {},\n             json.dumps({\"auth\": \"plaintext:key\",\n                         \"groups\": [{'name': \"act:usr\"}, {'name': \"act\"},\n                                    {'name': \".admin\"}]})),\n            # GET of account\n            ('204 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, ''),\n            # PUT of new token\n            ('201 Created', {}, ''),\n            # POST of token to user object\n            ('204 No Content', {}, ''),\n            # GET of services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n             \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}}))]))\n        resp = Request.blank('/auth/v1/act/auth',\n            headers={'X-Auth-User': 'act:usr',\n                     'X-Auth-Key': 'key'}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 200)\n        self.assertEqual(resp.content_type, CONTENT_TYPE_JSON)\n        self.assertTrue(resp.headers.get('x-auth-token',\n            '').startswith('AUTH_tk'), resp.headers.get('x-auth-token'))\n        self.assertEqual(resp.headers.get('x-auth-token'),\n                         resp.headers.get('x-storage-token'))\n        self.assertEqual(resp.headers.get('x-storage-url'),\n                         'http://127.0.0.1:8080/v1/AUTH_cfa')\n        self.assertEqual(json.loads(resp.body),\n            {\"storage\": {\"default\": \"local\",\n             \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}})\n        self.assertEqual(self.test_auth.app.calls, 5)\n\n    def test_get_token_success_existing_token(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object\n            ('200 Ok', {'X-Object-Meta-Auth-Token': 'AUTH_tktest'},\n             json.dumps({\"auth\": \"plaintext:key\",\n                         \"groups\": [{'name': \"act:usr\"}, {'name': \"act\"},\n                                    {'name': \".admin\"}]})),\n            # GET of token\n            ('200 Ok', {}, json.dumps({\"account\": \"act\", \"user\": \"usr\",\n             \"account_id\": \"AUTH_cfa\", \"groups\": [{'name': \"act:usr\"},\n             {'name': \"key\"}, {'name': \".admin\"}],\n             \"expires\": 9999999999.9999999})),\n            # GET of services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n             \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}}))]))\n        resp = Request.blank('/auth/v1.0',\n            headers={'X-Auth-User': 'act:usr',\n                     'X-Auth-Key': 'key'}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 200)\n        self.assertEqual(resp.content_type, CONTENT_TYPE_JSON)\n        self.assertEqual(resp.headers.get('x-auth-token'), 'AUTH_tktest')\n        self.assertEqual(resp.headers.get('x-auth-token'),\n                         resp.headers.get('x-storage-token'))\n        self.assertEqual(resp.headers.get('x-storage-url'),\n                         'http://127.0.0.1:8080/v1/AUTH_cfa')\n        self.assertEqual(json.loads(resp.body),\n            {\"storage\": {\"default\": \"local\",\n             \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}})\n        self.assertEqual(self.test_auth.app.calls, 3)\n\n    def test_get_token_success_existing_token_but_request_new_one(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object\n            ('200 Ok', {'X-Object-Meta-Auth-Token': 'AUTH_tktest'},\n             json.dumps({\"auth\": \"plaintext:key\",\n                         \"groups\": [{'name': \"act:usr\"}, {'name': \"act\"},\n                                    {'name': \".admin\"}]})),\n            # DELETE of expired token\n            ('204 No Content', {}, ''),\n            # GET of account\n            ('204 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, ''),\n            # PUT of new token\n            ('201 Created', {}, ''),\n            # POST of token to user object\n            ('204 No Content', {}, ''),\n            # GET of services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n             \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}}))]))\n        resp = Request.blank('/auth/v1.0',\n            headers={'X-Auth-User': 'act:usr',\n                     'X-Auth-Key': 'key',\n                     'X-Auth-New-Token': 'true'}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 200)\n        self.assertEqual(resp.content_type, CONTENT_TYPE_JSON)\n        self.assertNotEqual(resp.headers.get('x-auth-token'), 'AUTH_tktest')\n        self.assertEqual(resp.headers.get('x-auth-token'),\n                         resp.headers.get('x-storage-token'))\n        self.assertEqual(resp.headers.get('x-storage-url'),\n                         'http://127.0.0.1:8080/v1/AUTH_cfa')\n        self.assertEqual(json.loads(resp.body),\n            {\"storage\": {\"default\": \"local\",\n             \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}})\n        self.assertEqual(self.test_auth.app.calls, 6)\n\n    def test_get_token_success_existing_token_expired(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object\n            ('200 Ok', {'X-Object-Meta-Auth-Token': 'AUTH_tktest'},\n             json.dumps({\"auth\": \"plaintext:key\",\n                         \"groups\": [{'name': \"act:usr\"}, {'name': \"act\"},\n                                    {'name': \".admin\"}]})),\n            # GET of token\n            ('200 Ok', {}, json.dumps({\"account\": \"act\", \"user\": \"usr\",\n             \"account_id\": \"AUTH_cfa\", \"groups\": [{'name': \"act:usr\"},\n             {'name': \"key\"}, {'name': \".admin\"}],\n             \"expires\": 0.0})),\n            # DELETE of expired token\n            ('204 No Content', {}, ''),\n            # GET of account\n            ('204 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, ''),\n            # PUT of new token\n            ('201 Created', {}, ''),\n            # POST of token to user object\n            ('204 No Content', {}, ''),\n            # GET of services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n             \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}}))]))\n        resp = Request.blank('/auth/v1.0',\n            headers={'X-Auth-User': 'act:usr',\n                     'X-Auth-Key': 'key'}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 200)\n        self.assertEqual(resp.content_type, CONTENT_TYPE_JSON)\n        self.assertNotEqual(resp.headers.get('x-auth-token'), 'AUTH_tktest')\n        self.assertEqual(resp.headers.get('x-auth-token'),\n                         resp.headers.get('x-storage-token'))\n        self.assertEqual(resp.headers.get('x-storage-url'),\n                         'http://127.0.0.1:8080/v1/AUTH_cfa')\n        self.assertEqual(json.loads(resp.body),\n            {\"storage\": {\"default\": \"local\",\n             \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}})\n        self.assertEqual(self.test_auth.app.calls, 7)\n\n    def test_get_token_success_existing_token_expired_fail_deleting_old(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object\n            ('200 Ok', {'X-Object-Meta-Auth-Token': 'AUTH_tktest'},\n             json.dumps({\"auth\": \"plaintext:key\",\n                         \"groups\": [{'name': \"act:usr\"}, {'name': \"act\"},\n                                    {'name': \".admin\"}]})),\n            # GET of token\n            ('200 Ok', {}, json.dumps({\"account\": \"act\", \"user\": \"usr\",\n             \"account_id\": \"AUTH_cfa\", \"groups\": [{'name': \"act:usr\"},\n             {'name': \"key\"}, {'name': \".admin\"}],\n             \"expires\": 0.0})),\n            # DELETE of expired token\n            ('503 Service Unavailable', {}, ''),\n            # GET of account\n            ('204 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, ''),\n            # PUT of new token\n            ('201 Created', {}, ''),\n            # POST of token to user object\n            ('204 No Content', {}, ''),\n            # GET of services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n             \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}}))]))\n        resp = Request.blank('/auth/v1.0',\n            headers={'X-Auth-User': 'act:usr',\n                     'X-Auth-Key': 'key'}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 200)\n        self.assertEqual(resp.content_type, CONTENT_TYPE_JSON)\n        self.assertNotEqual(resp.headers.get('x-auth-token'), 'AUTH_tktest')\n        self.assertEqual(resp.headers.get('x-auth-token'),\n                         resp.headers.get('x-storage-token'))\n        self.assertEqual(resp.headers.get('x-storage-url'),\n                         'http://127.0.0.1:8080/v1/AUTH_cfa')\n        self.assertEqual(json.loads(resp.body),\n            {\"storage\": {\"default\": \"local\",\n             \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}})\n        self.assertEqual(self.test_auth.app.calls, 7)\n\n    def test_prep_success(self):\n        list_to_iter = [\n            # PUT of .auth account\n            ('201 Created', {}, ''),\n            # PUT of .account_id container\n            ('201 Created', {}, '')]\n        # PUT of .token* containers\n        for x in xrange(16):\n            list_to_iter.append(('201 Created', {}, ''))\n        self.test_auth.app = FakeApp(iter(list_to_iter))\n        resp = Request.blank('/auth/v2/.prep',\n            environ={'REQUEST_METHOD': 'POST'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 204)\n        self.assertEqual(self.test_auth.app.calls, 18)\n\n    def test_prep_bad_method(self):\n        resp = Request.blank('/auth/v2/.prep',\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 400)\n        resp = Request.blank('/auth/v2/.prep',\n            environ={'REQUEST_METHOD': 'HEAD'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 400)\n        resp = Request.blank('/auth/v2/.prep',\n            environ={'REQUEST_METHOD': 'PUT'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 400)\n\n    def test_prep_bad_creds(self):\n        resp = Request.blank('/auth/v2/.prep',\n            environ={'REQUEST_METHOD': 'POST'},\n            headers={'X-Auth-Admin-User': 'super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n        resp = Request.blank('/auth/v2/.prep',\n            environ={'REQUEST_METHOD': 'POST'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'upertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n        resp = Request.blank('/auth/v2/.prep',\n            environ={'REQUEST_METHOD': 'POST'},\n            headers={'X-Auth-Admin-User': '.super_admin'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n        resp = Request.blank('/auth/v2/.prep',\n            environ={'REQUEST_METHOD': 'POST'},\n            headers={'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n        resp = Request.blank('/auth/v2/.prep',\n            environ={'REQUEST_METHOD': 'POST'}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n\n    def test_prep_fail_account_create(self):\n        self.test_auth.app = FakeApp(iter([\n            # PUT of .auth account\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v2/.prep',\n            environ={'REQUEST_METHOD': 'POST'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_prep_fail_token_container_create(self):\n        self.test_auth.app = FakeApp(iter([\n            # PUT of .auth account\n            ('201 Created', {}, ''),\n            # PUT of .token container\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v2/.prep',\n            environ={'REQUEST_METHOD': 'POST'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n    def test_prep_fail_account_id_container_create(self):\n        self.test_auth.app = FakeApp(iter([\n            # PUT of .auth account\n            ('201 Created', {}, ''),\n            # PUT of .token container\n            ('201 Created', {}, ''),\n            # PUT of .account_id container\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v2/.prep',\n            environ={'REQUEST_METHOD': 'POST'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 3)\n\n    def test_get_reseller_success(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of .auth account (list containers)\n            ('200 Ok', {}, json.dumps([\n                {\"name\": \".token\", \"count\": 0, \"bytes\": 0},\n                {\"name\": \".account_id\", \"count\": 0, \"bytes\": 0},\n                {\"name\": \"act\", \"count\": 0, \"bytes\": 0}])),\n            # GET of .auth account (list containers continuation)\n            ('200 Ok', {}, '[]')]))\n        resp = Request.blank('/auth/v2',\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 200)\n        self.assertEqual(resp.content_type, CONTENT_TYPE_JSON)\n        self.assertEqual(json.loads(resp.body),\n                         {\"accounts\": [{\"name\": \"act\"}]})\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:adm\"},\n             {\"name\": \"test\"}, {\"name\": \".admin\"},\n             {\"name\": \".reseller_admin\"}], \"auth\": \"plaintext:key\"})),\n            # GET of .auth account (list containers)\n            ('200 Ok', {}, json.dumps([\n                {\"name\": \".token\", \"count\": 0, \"bytes\": 0},\n                {\"name\": \".account_id\", \"count\": 0, \"bytes\": 0},\n                {\"name\": \"act\", \"count\": 0, \"bytes\": 0}])),\n            # GET of .auth account (list containers continuation)\n            ('200 Ok', {}, '[]')]))\n        resp = Request.blank('/auth/v2',\n            headers={'X-Auth-Admin-User': 'act:adm',\n                     'X-Auth-Admin-Key': 'key'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 200)\n        self.assertEqual(resp.content_type, CONTENT_TYPE_JSON)\n        self.assertEqual(json.loads(resp.body),\n                         {\"accounts\": [{\"name\": \"act\"}]})\n        self.assertEqual(self.test_auth.app.calls, 3)\n\n    def test_get_reseller_fail_bad_creds(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object\n            ('404 Not Found', {}, '')]))\n        resp = Request.blank('/auth/v2',\n            headers={'X-Auth-Admin-User': 'super:admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object (account admin, but not reseller admin)\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:adm\"},\n             {\"name\": \"test\"}, {\"name\": \".admin\"}],\n             \"auth\": \"plaintext:key\"}))]))\n        resp = Request.blank('/auth/v2',\n            headers={'X-Auth-Admin-User': 'act:adm',\n                     'X-Auth-Admin-Key': 'key'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 403)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object (regular user)\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:usr\"},\n             {\"name\": \"test\"}], \"auth\": \"plaintext:key\"}))]))\n        resp = Request.blank('/auth/v2',\n            headers={'X-Auth-Admin-User': 'act:usr',\n                     'X-Auth-Admin-Key': 'key'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 403)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_get_reseller_fail_listing(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of .auth account (list containers)\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v2',\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n        self.test_auth.app = FakeApp(iter([\n            # GET of .auth account (list containers)\n            ('200 Ok', {}, json.dumps([\n                {\"name\": \".token\", \"count\": 0, \"bytes\": 0},\n                {\"name\": \".account_id\", \"count\": 0, \"bytes\": 0},\n                {\"name\": \"act\", \"count\": 0, \"bytes\": 0}])),\n            # GET of .auth account (list containers continuation)\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v2',\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n    def test_get_account_success(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of .services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n                \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}})),\n            # GET of account container (list objects)\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'},\n             json.dumps([\n                {\"name\": \".services\", \"hash\": \"etag\", \"bytes\": 112,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.618110\"},\n                {\"name\": \"tester\", \"hash\": \"etag\", \"bytes\": 104,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.736680\"},\n                {\"name\": \"tester3\", \"hash\": \"etag\", \"bytes\": 86,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:28.135530\"}])),\n            # GET of account container (list objects continuation)\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, '[]')]))\n        resp = Request.blank('/auth/v2/act',\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 200)\n        self.assertEqual(resp.content_type, CONTENT_TYPE_JSON)\n        self.assertEqual(json.loads(resp.body),\n            {'account_id': 'AUTH_cfa',\n             'services': {'storage':\n                          {'default': 'local',\n                          'local': 'http://127.0.0.1:8080/v1/AUTH_cfa'}},\n             'users': [{'name': 'tester'}, {'name': 'tester3'}]})\n        self.assertEqual(self.test_auth.app.calls, 3)\n\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:adm\"},\n             {\"name\": \"test\"}, {\"name\": \".admin\"}],\n             \"auth\": \"plaintext:key\"})),\n            # GET of .services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n                \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}})),\n            # GET of account container (list objects)\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'},\n             json.dumps([\n                {\"name\": \".services\", \"hash\": \"etag\", \"bytes\": 112,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.618110\"},\n                {\"name\": \"tester\", \"hash\": \"etag\", \"bytes\": 104,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.736680\"},\n                {\"name\": \"tester3\", \"hash\": \"etag\", \"bytes\": 86,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:28.135530\"}])),\n            # GET of account container (list objects continuation)\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, '[]')]))\n        resp = Request.blank('/auth/v2/act',\n            headers={'X-Auth-Admin-User': 'act:adm',\n                     'X-Auth-Admin-Key': 'key'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 200)\n        self.assertEqual(resp.content_type, CONTENT_TYPE_JSON)\n        self.assertEqual(json.loads(resp.body),\n            {'account_id': 'AUTH_cfa',\n             'services': {'storage':\n                          {'default': 'local',\n                           'local': 'http://127.0.0.1:8080/v1/AUTH_cfa'}},\n             'users': [{'name': 'tester'}, {'name': 'tester3'}]})\n        self.assertEqual(self.test_auth.app.calls, 4)\n\n    def test_get_account_fail_bad_account_name(self):\n        resp = Request.blank('/auth/v2/.token',\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 400)\n        resp = Request.blank('/auth/v2/.anything',\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 400)\n\n    def test_get_account_fail_creds(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object\n            ('404 Not Found', {}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            headers={'X-Auth-Admin-User': 'super:admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object (account admin, but wrong account)\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act2:adm\"},\n             {\"name\": \"test\"}, {\"name\": \".admin\"}],\n             \"auth\": \"plaintext:key\"}))]))\n        resp = Request.blank('/auth/v2/act',\n            headers={'X-Auth-Admin-User': 'act2:adm',\n                     'X-Auth-Admin-Key': 'key'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 403)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object (regular user)\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:usr\"},\n             {\"name\": \"test\"}], \"auth\": \"plaintext:key\"}))]))\n        resp = Request.blank('/auth/v2/act',\n            headers={'X-Auth-Admin-User': 'act:usr',\n                     'X-Auth-Admin-Key': 'key'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 403)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_get_account_fail_get_services(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of .services object\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n        self.test_auth.app = FakeApp(iter([\n            # GET of .services object\n            ('404 Not Found', {}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 404)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_get_account_fail_listing(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of .services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n                \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}})),\n            # GET of account container (list objects)\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n        self.test_auth.app = FakeApp(iter([\n            # GET of .services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n                \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}})),\n            # GET of account container (list objects)\n            ('404 Not Found', {}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 404)\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n        self.test_auth.app = FakeApp(iter([\n            # GET of .services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n                \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}})),\n            # GET of account container (list objects)\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'},\n             json.dumps([\n                {\"name\": \".services\", \"hash\": \"etag\", \"bytes\": 112,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.618110\"},\n                {\"name\": \"tester\", \"hash\": \"etag\", \"bytes\": 104,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.736680\"},\n                {\"name\": \"tester3\", \"hash\": \"etag\", \"bytes\": 86,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:28.135530\"}])),\n            # GET of account container (list objects continuation)\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 3)\n\n    def test_set_services_new_service(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of .services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n                \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}})),\n            # PUT of new .services object\n            ('204 No Content', {}, '')]))\n        resp = Request.blank('/auth/v2/act/.services',\n            environ={'REQUEST_METHOD': 'POST'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'},\n            body=json.dumps({'new_service': {'new_endpoint': 'new_value'}})\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 200)\n        self.assertEqual(resp.content_type, CONTENT_TYPE_JSON)\n        self.assertEqual(json.loads(resp.body),\n            {'storage': {'default': 'local',\n                         'local': 'http://127.0.0.1:8080/v1/AUTH_cfa'},\n             'new_service': {'new_endpoint': 'new_value'}})\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n    def test_set_services_new_endpoint(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of .services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n                \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}})),\n            # PUT of new .services object\n            ('204 No Content', {}, '')]))\n        resp = Request.blank('/auth/v2/act/.services',\n            environ={'REQUEST_METHOD': 'POST'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'},\n            body=json.dumps({'storage': {'new_endpoint': 'new_value'}})\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 200)\n        self.assertEqual(resp.content_type, CONTENT_TYPE_JSON)\n        self.assertEqual(json.loads(resp.body),\n            {'storage': {'default': 'local',\n                         'local': 'http://127.0.0.1:8080/v1/AUTH_cfa',\n                         'new_endpoint': 'new_value'}})\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n    def test_set_services_update_endpoint(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of .services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n                \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}})),\n            # PUT of new .services object\n            ('204 No Content', {}, '')]))\n        resp = Request.blank('/auth/v2/act/.services',\n            environ={'REQUEST_METHOD': 'POST'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'},\n            body=json.dumps({'storage': {'local': 'new_value'}})\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 200)\n        self.assertEqual(resp.content_type, CONTENT_TYPE_JSON)\n        self.assertEqual(json.loads(resp.body),\n            {'storage': {'default': 'local',\n                         'local': 'new_value'}})\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n    def test_set_services_fail_bad_creds(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object\n            ('404 Not Found', {}, '')]))\n        resp = Request.blank('/auth/v2/act/.services',\n            environ={'REQUEST_METHOD': 'POST'},\n            headers={'X-Auth-Admin-User': 'super:admin',\n                     'X-Auth-Admin-Key': 'supertest'},\n            body=json.dumps({'storage': {'local': 'new_value'}})\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object (account admin, but not reseller admin)\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:adm\"},\n             {\"name\": \"test\"}, {\"name\": \".admin\"}],\n             \"auth\": \"plaintext:key\"}))]))\n        resp = Request.blank('/auth/v2/act/.services',\n            environ={'REQUEST_METHOD': 'POST'},\n            headers={'X-Auth-Admin-User': 'act:adm',\n                     'X-Auth-Admin-Key': 'key'},\n            body=json.dumps({'storage': {'local': 'new_value'}})\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 403)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object (regular user)\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:usr\"},\n             {\"name\": \"test\"}], \"auth\": \"plaintext:key\"}))]))\n        resp = Request.blank('/auth/v2/act/.services',\n            environ={'REQUEST_METHOD': 'POST'},\n            headers={'X-Auth-Admin-User': 'act:usr',\n                     'X-Auth-Admin-Key': 'key'},\n            body=json.dumps({'storage': {'local': 'new_value'}})\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 403)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_set_services_fail_bad_account_name(self):\n        resp = Request.blank('/auth/v2/.act/.services',\n            environ={'REQUEST_METHOD': 'POST'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'},\n            body=json.dumps({'storage': {'local': 'new_value'}})\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 400)\n\n    def test_set_services_fail_bad_json(self):\n        resp = Request.blank('/auth/v2/act/.services',\n            environ={'REQUEST_METHOD': 'POST'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'},\n            body='garbage'\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 400)\n        resp = Request.blank('/auth/v2/act/.services',\n            environ={'REQUEST_METHOD': 'POST'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'},\n            body=''\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 400)\n\n    def test_set_services_fail_get_services(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of .services object\n            ('503 Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v2/act/.services',\n            environ={'REQUEST_METHOD': 'POST'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'},\n            body=json.dumps({'new_service': {'new_endpoint': 'new_value'}})\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n        self.test_auth.app = FakeApp(iter([\n            # GET of .services object\n            ('404 Not Found', {}, '')]))\n        resp = Request.blank('/auth/v2/act/.services',\n            environ={'REQUEST_METHOD': 'POST'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'},\n            body=json.dumps({'new_service': {'new_endpoint': 'new_value'}})\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 404)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_set_services_fail_put_services(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of .services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n                \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}})),\n            # PUT of new .services object\n            ('503 Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v2/act/.services',\n            environ={'REQUEST_METHOD': 'POST'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'},\n            body=json.dumps({'new_service': {'new_endpoint': 'new_value'}})\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n    def test_put_account_success(self):\n        conn = FakeConn(iter([\n            # PUT of storage account itself\n            ('201 Created', {}, '')]))\n        self.test_auth.get_conn = lambda: conn\n        self.test_auth.app = FakeApp(iter([\n            # Initial HEAD of account container to check for pre-existence\n            ('404 Not Found', {}, ''),\n            # PUT of account container\n            ('204 No Content', {}, ''),\n            # PUT of .account_id mapping object\n            ('204 No Content', {}, ''),\n            # PUT of .services object\n            ('204 No Content', {}, ''),\n            # POST to account container updating X-Container-Meta-Account-Id\n            ('204 No Content', {}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'PUT', 'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 201)\n        self.assertEqual(self.test_auth.app.calls, 5)\n        self.assertEqual(conn.calls, 1)\n\n    def test_put_account_success_preexist_but_not_completed(self):\n        conn = FakeConn(iter([\n            # PUT of storage account itself\n            ('201 Created', {}, '')]))\n        self.test_auth.get_conn = lambda: conn\n        self.test_auth.app = FakeApp(iter([\n            # Initial HEAD of account container to check for pre-existence\n            # We're going to show it as existing this time, but with no\n            # X-Container-Meta-Account-Id, indicating a failed previous attempt\n            ('200 Ok', {}, ''),\n            # PUT of .account_id mapping object\n            ('204 No Content', {}, ''),\n            # PUT of .services object\n            ('204 No Content', {}, ''),\n            # POST to account container updating X-Container-Meta-Account-Id\n            ('204 No Content', {}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'PUT', 'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 201)\n        self.assertEqual(self.test_auth.app.calls, 4)\n        self.assertEqual(conn.calls, 1)\n\n    def test_put_account_success_preexist_and_completed(self):\n        conn = FakeConn(iter([\n            # PUT of storage account itself\n            ('201 Created', {}, '')]))\n        self.test_auth.get_conn = lambda: conn\n        self.test_auth.app = FakeApp(iter([\n            # Initial HEAD of account container to check for pre-existence\n            # We're going to show it as existing this time, and with an\n            # X-Container-Meta-Account-Id, indicating it already exists\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'PUT', 'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 202)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_put_account_success_with_given_suffix(self):\n        conn = FakeConn(iter([\n            # PUT of storage account itself\n            ('201 Created', {}, '')]))\n        self.test_auth.get_conn = lambda: conn\n        self.test_auth.app = FakeApp(iter([\n            # Initial HEAD of account container to check for pre-existence\n            ('404 Not Found', {}, ''),\n            # PUT of account container\n            ('204 No Content', {}, ''),\n            # PUT of .account_id mapping object\n            ('204 No Content', {}, ''),\n            # PUT of .services object\n            ('204 No Content', {}, ''),\n            # POST to account container updating X-Container-Meta-Account-Id\n            ('204 No Content', {}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'PUT', 'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest',\n                     'X-Account-Suffix': 'test-suffix'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 201)\n        self.assertEqual(conn.request_path, '/v1/AUTH_test-suffix')\n        self.assertEqual(self.test_auth.app.calls, 5)\n        self.assertEqual(conn.calls, 1)\n\n    def test_put_account_fail_bad_creds(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object\n            ('404 Not Found', {}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'PUT', 'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': 'super:admin',\n                     'X-Auth-Admin-Key': 'supertest'},\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object (account admin, but not reseller admin)\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:adm\"},\n             {\"name\": \"test\"}, {\"name\": \".admin\"}],\n             \"auth\": \"plaintext:key\"}))]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'PUT', 'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': 'act:adm',\n                     'X-Auth-Admin-Key': 'key'},\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 403)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object (regular user)\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:usr\"},\n             {\"name\": \"test\"}], \"auth\": \"plaintext:key\"}))]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'PUT', 'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': 'act:usr',\n                     'X-Auth-Admin-Key': 'key'},\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 403)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_put_account_fail_invalid_account_name(self):\n        resp = Request.blank('/auth/v2/.act',\n            environ={'REQUEST_METHOD': 'PUT', 'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'},\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 400)\n\n    def test_put_account_fail_on_storage_account_put(self):\n        conn = FakeConn(iter([\n            # PUT of storage account itself\n            ('503 Service Unavailable', {}, '')]))\n        self.test_auth.get_conn = lambda: conn\n        self.test_auth.app = FakeApp(iter([\n        ]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'PUT', 'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(conn.calls, 1)\n        self.assertEqual(self.test_auth.app.calls, 0)\n\n    def test_put_account_fail_on_initial_account_head(self):\n        conn = FakeConn(iter([\n            # PUT of storage account itself\n            ('201 Created', {}, '')]))\n        self.test_auth.get_conn = lambda: conn\n        self.test_auth.app = FakeApp(iter([\n            # Initial HEAD of account container to check for pre-existence\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'PUT', 'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_put_account_fail_on_account_marker_put(self):\n        conn = FakeConn(iter([\n            # PUT of storage account itself\n            ('201 Created', {}, '')]))\n        self.test_auth.get_conn = lambda: conn\n        self.test_auth.app = FakeApp(iter([\n            # Initial HEAD of account container to check for pre-existence\n            ('404 Not Found', {}, ''),\n            # PUT of account container\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'PUT', 'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n    def test_put_account_fail_on_account_id_mapping(self):\n        conn = FakeConn(iter([\n            # PUT of storage account itself\n            ('201 Created', {}, '')]))\n        self.test_auth.get_conn = lambda: conn\n        self.test_auth.app = FakeApp(iter([\n            # Initial HEAD of account container to check for pre-existence\n            ('404 Not Found', {}, ''),\n            # PUT of account container\n            ('204 No Content', {}, ''),\n            # PUT of .account_id mapping object\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'PUT', 'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(conn.calls, 1)\n        self.assertEqual(self.test_auth.app.calls, 3)\n\n    def test_put_account_fail_on_services_object(self):\n        conn = FakeConn(iter([\n            # PUT of storage account itself\n            ('201 Created', {}, '')]))\n        self.test_auth.get_conn = lambda: conn\n        self.test_auth.app = FakeApp(iter([\n            # Initial HEAD of account container to check for pre-existence\n            ('404 Not Found', {}, ''),\n            # PUT of account container\n            ('204 No Content', {}, ''),\n            # PUT of .account_id mapping object\n            ('204 No Content', {}, ''),\n            # PUT of .services object\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'PUT', 'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(conn.calls, 1)\n        self.assertEqual(self.test_auth.app.calls, 4)\n\n    def test_put_account_fail_on_post_mapping(self):\n        conn = FakeConn(iter([\n            # PUT of storage account itself\n            ('201 Created', {}, '')]))\n        self.test_auth.get_conn = lambda: conn\n        self.test_auth.app = FakeApp(iter([\n            # Initial HEAD of account container to check for pre-existence\n            ('404 Not Found', {}, ''),\n            # PUT of account container\n            ('204 No Content', {}, ''),\n            # PUT of .account_id mapping object\n            ('204 No Content', {}, ''),\n            # PUT of .services object\n            ('204 No Content', {}, ''),\n            # POST to account container updating X-Container-Meta-Account-Id\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'PUT', 'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(conn.calls, 1)\n        self.assertEqual(self.test_auth.app.calls, 5)\n\n    def test_delete_account_success(self):\n        conn = FakeConn(iter([\n            # DELETE of storage account itself\n            ('204 No Content', {}, '')]))\n        self.test_auth.get_conn = lambda x: conn\n        self.test_auth.app = FakeApp(iter([\n            # Account's container listing, checking for users\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'},\n             json.dumps([\n                {\"name\": \".services\", \"hash\": \"etag\", \"bytes\": 112,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.618110\"}])),\n            # Account's container listing, checking for users (continuation)\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, '[]'),\n            # GET the .services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n                \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}})),\n            # DELETE the .services object\n            ('204 No Content', {}, ''),\n            # DELETE the .account_id mapping object\n            ('204 No Content', {}, ''),\n            # DELETE the account container\n            ('204 No Content', {}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'DELETE',\n                     'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 204)\n        self.assertEqual(self.test_auth.app.calls, 6)\n        self.assertEqual(conn.calls, 1)\n\n    def test_delete_account_success_missing_services(self):\n        self.test_auth.app = FakeApp(iter([\n            # Account's container listing, checking for users\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'},\n             json.dumps([\n                {\"name\": \".services\", \"hash\": \"etag\", \"bytes\": 112,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.618110\"}])),\n            # Account's container listing, checking for users (continuation)\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, '[]'),\n            # GET the .services object\n            ('404 Not Found', {}, ''),\n            # DELETE the .account_id mapping object\n            ('204 No Content', {}, ''),\n            # DELETE the account container\n            ('204 No Content', {}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'DELETE',\n                     'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 204)\n        self.assertEqual(self.test_auth.app.calls, 5)\n\n    def test_delete_account_success_missing_storage_account(self):\n        conn = FakeConn(iter([\n            # DELETE of storage account itself\n            ('404 Not Found', {}, '')]))\n        self.test_auth.get_conn = lambda x: conn\n        self.test_auth.app = FakeApp(iter([\n            # Account's container listing, checking for users\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'},\n             json.dumps([\n                {\"name\": \".services\", \"hash\": \"etag\", \"bytes\": 112,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.618110\"}])),\n            # Account's container listing, checking for users (continuation)\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, '[]'),\n            # GET the .services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n                \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}})),\n            # DELETE the .services object\n            ('204 No Content', {}, ''),\n            # DELETE the .account_id mapping object\n            ('204 No Content', {}, ''),\n            # DELETE the account container\n            ('204 No Content', {}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'DELETE',\n                     'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 204)\n        self.assertEqual(self.test_auth.app.calls, 6)\n        self.assertEqual(conn.calls, 1)\n\n    def test_delete_account_success_missing_account_id_mapping(self):\n        conn = FakeConn(iter([\n            # DELETE of storage account itself\n            ('204 No Content', {}, '')]))\n        self.test_auth.get_conn = lambda x: conn\n        self.test_auth.app = FakeApp(iter([\n            # Account's container listing, checking for users\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'},\n             json.dumps([\n                {\"name\": \".services\", \"hash\": \"etag\", \"bytes\": 112,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.618110\"}])),\n            # Account's container listing, checking for users (continuation)\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, '[]'),\n            # GET the .services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n                \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}})),\n            # DELETE the .services object\n            ('204 No Content', {}, ''),\n            # DELETE the .account_id mapping object\n            ('404 Not Found', {}, ''),\n            # DELETE the account container\n            ('204 No Content', {}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'DELETE',\n                     'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 204)\n        self.assertEqual(self.test_auth.app.calls, 6)\n        self.assertEqual(conn.calls, 1)\n\n    def test_delete_account_success_missing_account_container_at_end(self):\n        conn = FakeConn(iter([\n            # DELETE of storage account itself\n            ('204 No Content', {}, '')]))\n        self.test_auth.get_conn = lambda x: conn\n        self.test_auth.app = FakeApp(iter([\n            # Account's container listing, checking for users\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'},\n             json.dumps([\n                {\"name\": \".services\", \"hash\": \"etag\", \"bytes\": 112,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.618110\"}])),\n            # Account's container listing, checking for users (continuation)\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, '[]'),\n            # GET the .services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n                \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}})),\n            # DELETE the .services object\n            ('204 No Content', {}, ''),\n            # DELETE the .account_id mapping object\n            ('204 No Content', {}, ''),\n            # DELETE the account container\n            ('404 Not Found', {}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'DELETE',\n                     'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 204)\n        self.assertEqual(self.test_auth.app.calls, 6)\n        self.assertEqual(conn.calls, 1)\n\n    def test_delete_account_fail_bad_creds(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object\n            ('404 Not Found', {}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'DELETE',\n                     'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': 'super:admin',\n                     'X-Auth-Admin-Key': 'supertest'},\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object (account admin, but not reseller admin)\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:adm\"},\n             {\"name\": \"test\"}, {\"name\": \".admin\"}],\n             \"auth\": \"plaintext:key\"}))]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'DELETE',\n                     'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': 'act:adm',\n                     'X-Auth-Admin-Key': 'key'},\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 403)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object (regular user)\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:usr\"},\n             {\"name\": \"test\"}], \"auth\": \"plaintext:key\"}))]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'DELETE',\n                     'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': 'act:usr',\n                     'X-Auth-Admin-Key': 'key'},\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 403)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_delete_account_fail_invalid_account_name(self):\n        resp = Request.blank('/auth/v2/.act',\n            environ={'REQUEST_METHOD': 'DELETE'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 400)\n\n    def test_delete_account_fail_not_found(self):\n        self.test_auth.app = FakeApp(iter([\n            # Account's container listing, checking for users\n            ('404 Not Found', {}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'DELETE',\n                     'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 404)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_delete_account_fail_not_found_concurrency(self):\n        self.test_auth.app = FakeApp(iter([\n            # Account's container listing, checking for users\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'},\n             json.dumps([\n                {\"name\": \".services\", \"hash\": \"etag\", \"bytes\": 112,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.618110\"}])),\n            # Account's container listing, checking for users (continuation)\n            ('404 Not Found', {}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'DELETE',\n                     'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 404)\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n    def test_delete_account_fail_list_account(self):\n        self.test_auth.app = FakeApp(iter([\n            # Account's container listing, checking for users\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'DELETE',\n                     'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_delete_account_fail_list_account_concurrency(self):\n        self.test_auth.app = FakeApp(iter([\n            # Account's container listing, checking for users\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'},\n             json.dumps([\n                {\"name\": \".services\", \"hash\": \"etag\", \"bytes\": 112,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.618110\"}])),\n            # Account's container listing, checking for users (continuation)\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'DELETE',\n                     'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n    def test_delete_account_fail_has_users(self):\n        self.test_auth.app = FakeApp(iter([\n            # Account's container listing, checking for users\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'},\n             json.dumps([\n                {\"name\": \".services\", \"hash\": \"etag\", \"bytes\": 112,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.618110\"},\n                {\"name\": \"tester\", \"hash\": \"etag\", \"bytes\": 104,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.736680\"}]))]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'DELETE',\n                     'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 409)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_delete_account_fail_has_users2(self):\n        self.test_auth.app = FakeApp(iter([\n            # Account's container listing, checking for users\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'},\n             json.dumps([\n                {\"name\": \".services\", \"hash\": \"etag\", \"bytes\": 112,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.618110\"}])),\n            # Account's container listing, checking for users (continuation)\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'},\n             json.dumps([\n                {\"name\": \"tester\", \"hash\": \"etag\", \"bytes\": 104,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.736680\"}]))]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'DELETE',\n                     'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 409)\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n    def test_delete_account_fail_get_services(self):\n        self.test_auth.app = FakeApp(iter([\n            # Account's container listing, checking for users\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'},\n             json.dumps([\n                {\"name\": \".services\", \"hash\": \"etag\", \"bytes\": 112,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.618110\"}])),\n            # Account's container listing, checking for users (continuation)\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, '[]'),\n            # GET the .services object\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'DELETE',\n                     'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 3)\n\n    def test_delete_account_fail_delete_storage_account(self):\n        conn = FakeConn(iter([\n            # DELETE of storage account itself\n            ('409 Conflict', {}, '')]))\n        self.test_auth.get_conn = lambda x: conn\n        self.test_auth.app = FakeApp(iter([\n            # Account's container listing, checking for users\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'},\n             json.dumps([\n                {\"name\": \".services\", \"hash\": \"etag\", \"bytes\": 112,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.618110\"}])),\n            # Account's container listing, checking for users (continuation)\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, '[]'),\n            # GET the .services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n                \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}}))]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'DELETE',\n                     'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 409)\n        self.assertEqual(self.test_auth.app.calls, 3)\n        self.assertEqual(conn.calls, 1)\n\n    def test_delete_account_fail_delete_storage_account2(self):\n        conn = FakeConn(iter([\n            # DELETE of storage account itself\n            ('204 No Content', {}, ''),\n            # DELETE of storage account itself\n            ('409 Conflict', {}, '')]))\n        self.test_auth.get_conn = lambda x: conn\n        self.test_auth.app = FakeApp(iter([\n            # Account's container listing, checking for users\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'},\n             json.dumps([\n                {\"name\": \".services\", \"hash\": \"etag\", \"bytes\": 112,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.618110\"}])),\n            # Account's container listing, checking for users (continuation)\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, '[]'),\n            # GET the .services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n                \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\",\n                \"other\": \"http://127.0.0.1:8080/v1/AUTH_cfa2\"}}))]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'DELETE',\n                     'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 3)\n        self.assertEqual(conn.calls, 2)\n\n    def test_delete_account_fail_delete_storage_account3(self):\n        conn = FakeConn(iter([\n            # DELETE of storage account itself\n            ('503 Service Unavailable', {}, '')]))\n        self.test_auth.get_conn = lambda x: conn\n        self.test_auth.app = FakeApp(iter([\n            # Account's container listing, checking for users\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'},\n             json.dumps([\n                {\"name\": \".services\", \"hash\": \"etag\", \"bytes\": 112,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.618110\"}])),\n            # Account's container listing, checking for users (continuation)\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, '[]'),\n            # GET the .services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n                \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}}))]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'DELETE',\n                     'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 3)\n        self.assertEqual(conn.calls, 1)\n\n    def test_delete_account_fail_delete_storage_account4(self):\n        conn = FakeConn(iter([\n            # DELETE of storage account itself\n            ('204 No Content', {}, ''),\n            # DELETE of storage account itself\n            ('503 Service Unavailable', {}, '')]))\n        self.test_auth.get_conn = lambda x: conn\n        self.test_auth.app = FakeApp(iter([\n            # Account's container listing, checking for users\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'},\n             json.dumps([\n                {\"name\": \".services\", \"hash\": \"etag\", \"bytes\": 112,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.618110\"}])),\n            # Account's container listing, checking for users (continuation)\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, '[]'),\n            # GET the .services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n                \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\",\n                \"other\": \"http://127.0.0.1:8080/v1/AUTH_cfa2\"}}))]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'DELETE',\n                     'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 3)\n        self.assertEqual(conn.calls, 2)\n\n    def test_delete_account_fail_delete_services(self):\n        conn = FakeConn(iter([\n            # DELETE of storage account itself\n            ('204 No Content', {}, '')]))\n        self.test_auth.get_conn = lambda x: conn\n        self.test_auth.app = FakeApp(iter([\n            # Account's container listing, checking for users\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'},\n             json.dumps([\n                {\"name\": \".services\", \"hash\": \"etag\", \"bytes\": 112,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.618110\"}])),\n            # Account's container listing, checking for users (continuation)\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, '[]'),\n            # GET the .services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n                \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}})),\n            # DELETE the .services object\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'DELETE',\n                     'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 4)\n        self.assertEqual(conn.calls, 1)\n\n    def test_delete_account_fail_delete_account_id_mapping(self):\n        conn = FakeConn(iter([\n            # DELETE of storage account itself\n            ('204 No Content', {}, '')]))\n        self.test_auth.get_conn = lambda x: conn\n        self.test_auth.app = FakeApp(iter([\n            # Account's container listing, checking for users\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'},\n             json.dumps([\n                {\"name\": \".services\", \"hash\": \"etag\", \"bytes\": 112,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.618110\"}])),\n            # Account's container listing, checking for users (continuation)\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, '[]'),\n            # GET the .services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n                \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}})),\n            # DELETE the .services object\n            ('204 No Content', {}, ''),\n            # DELETE the .account_id mapping object\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'DELETE',\n                     'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 5)\n        self.assertEqual(conn.calls, 1)\n\n    def test_delete_account_fail_delete_account_container(self):\n        conn = FakeConn(iter([\n            # DELETE of storage account itself\n            ('204 No Content', {}, '')]))\n        self.test_auth.get_conn = lambda x: conn\n        self.test_auth.app = FakeApp(iter([\n            # Account's container listing, checking for users\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'},\n             json.dumps([\n                {\"name\": \".services\", \"hash\": \"etag\", \"bytes\": 112,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.618110\"}])),\n            # Account's container listing, checking for users (continuation)\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, '[]'),\n            # GET the .services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n                \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}})),\n            # DELETE the .services object\n            ('204 No Content', {}, ''),\n            # DELETE the .account_id mapping object\n            ('204 No Content', {}, ''),\n            # DELETE the account container\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'DELETE',\n                     'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 6)\n        self.assertEqual(conn.calls, 1)\n\n    def test_get_user_success(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object\n            ('200 Ok', {}, json.dumps(\n                {\"groups\": [{\"name\": \"act:usr\"}, {\"name\": \"act\"},\n                            {\"name\": \".admin\"}],\n                 \"auth\": \"plaintext:key\"}))]))\n        resp = Request.blank('/auth/v2/act/usr',\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 200)\n        self.assertEqual(resp.content_type, CONTENT_TYPE_JSON)\n        self.assertEqual(resp.body, json.dumps(\n            {\"groups\": [{\"name\": \"act:usr\"}, {\"name\": \"act\"},\n                        {\"name\": \".admin\"}],\n             \"auth\": \"plaintext:key\"}))\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_get_user_fail_no_super_admin_key(self):\n        local_auth = auth.filter_factory({})(FakeApp(iter([\n            # GET of user object (but we should never get here)\n            ('200 Ok', {}, json.dumps(\n                {\"groups\": [{\"name\": \"act:usr\"}, {\"name\": \"act\"},\n                            {\"name\": \".admin\"}],\n                 \"auth\": \"plaintext:key\"}))])))\n        resp = Request.blank('/auth/v2/act/usr',\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(local_auth)\n        self.assertEqual(resp.status_int, 404)\n        self.assertEqual(local_auth.app.calls, 0)\n\n    def test_get_user_groups_success(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of account container (list objects)\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'},\n             json.dumps([\n                {\"name\": \".services\", \"hash\": \"etag\", \"bytes\": 112,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.618110\"},\n                {\"name\": \"tester\", \"hash\": \"etag\", \"bytes\": 104,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.736680\"},\n                {\"name\": \"tester3\", \"hash\": \"etag\", \"bytes\": 86,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:28.135530\"}])),\n            # GET of user object\n            ('200 Ok', {}, json.dumps(\n                {\"groups\": [{\"name\": \"act:tester\"}, {\"name\": \"act\"},\n                            {\"name\": \".admin\"}],\n                 \"auth\": \"plaintext:key\"})),\n            # GET of user object\n            ('200 Ok', {}, json.dumps(\n                {\"groups\": [{\"name\": \"act:tester3\"}, {\"name\": \"act\"}],\n                 \"auth\": \"plaintext:key3\"})),\n            # GET of account container (list objects continuation)\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, '[]')]))\n        resp = Request.blank('/auth/v2/act/.groups',\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 200)\n        self.assertEqual(resp.content_type, CONTENT_TYPE_JSON)\n        self.assertEqual(resp.body, json.dumps(\n            {\"groups\": [{\"name\": \".admin\"}, {\"name\": \"act\"},\n                        {\"name\": \"act:tester\"}, {\"name\": \"act:tester3\"}]}))\n        self.assertEqual(self.test_auth.app.calls, 4)\n\n    def test_get_user_groups_success2(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of account container (list objects)\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'},\n             json.dumps([\n                {\"name\": \".services\", \"hash\": \"etag\", \"bytes\": 112,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.618110\"},\n                {\"name\": \"tester\", \"hash\": \"etag\", \"bytes\": 104,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.736680\"}])),\n            # GET of user object\n            ('200 Ok', {}, json.dumps(\n                {\"groups\": [{\"name\": \"act:tester\"}, {\"name\": \"act\"},\n                            {\"name\": \".admin\"}],\n                 \"auth\": \"plaintext:key\"})),\n            # GET of account container (list objects continuation)\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'},\n             json.dumps([\n                {\"name\": \"tester3\", \"hash\": \"etag\", \"bytes\": 86,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:28.135530\"}])),\n            # GET of user object\n            ('200 Ok', {}, json.dumps(\n                {\"groups\": [{\"name\": \"act:tester3\"}, {\"name\": \"act\"}],\n                 \"auth\": \"plaintext:key3\"})),\n            # GET of account container (list objects continuation)\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, '[]')]))\n        resp = Request.blank('/auth/v2/act/.groups',\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 200)\n        self.assertEqual(resp.content_type, CONTENT_TYPE_JSON)\n        self.assertEqual(resp.body, json.dumps(\n            {\"groups\": [{\"name\": \".admin\"}, {\"name\": \"act\"},\n                        {\"name\": \"act:tester\"}, {\"name\": \"act:tester3\"}]}))\n        self.assertEqual(self.test_auth.app.calls, 5)\n\n    def test_get_user_fail_invalid_account(self):\n        resp = Request.blank('/auth/v2/.invalid/usr',\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 400)\n\n    def test_get_user_fail_invalid_user(self):\n        resp = Request.blank('/auth/v2/act/.invalid',\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 400)\n\n    def test_get_user_fail_bad_creds(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object\n            ('404 Not Found', {}, '')]))\n        resp = Request.blank('/auth/v2/act/usr',\n            headers={'X-Auth-Admin-User': 'super:admin',\n                     'X-Auth-Admin-Key': 'supertest'},\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object (regular user)\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:usr\"},\n             {\"name\": \"test\"}], \"auth\": \"plaintext:key\"}))]))\n        resp = Request.blank('/auth/v2/act/usr',\n            headers={'X-Auth-Admin-User': 'act:usr',\n                     'X-Auth-Admin-Key': 'key'},\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 403)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_get_user_account_admin_success(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object (account admin, but not reseller admin)\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:adm\"},\n             {\"name\": \"test\"}, {\"name\": \".admin\"}],\n             \"auth\": \"plaintext:key\"})),\n            # GET of requested user object\n            ('200 Ok', {}, json.dumps(\n                {\"groups\": [{\"name\": \"act:usr\"}, {\"name\": \"act\"}],\n                 \"auth\": \"plaintext:key\"}))]))\n        resp = Request.blank('/auth/v2/act/usr',\n            headers={'X-Auth-Admin-User': 'act:adm',\n                     'X-Auth-Admin-Key': 'key'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 200)\n        self.assertEqual(resp.content_type, CONTENT_TYPE_JSON)\n        self.assertEqual(resp.body, json.dumps(\n            {\"groups\": [{\"name\": \"act:usr\"}, {\"name\": \"act\"}],\n             \"auth\": \"plaintext:key\"}))\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n    def test_get_user_account_admin_fail_getting_account_admin(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object (account admin check)\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:adm\"},\n             {\"name\": \"test\"}, {\"name\": \".admin\"}],\n             \"auth\": \"plaintext:key\"})),\n            # GET of requested user object [who is an .admin as well]\n            ('200 Ok', {}, json.dumps(\n                {\"groups\": [{\"name\": \"act:usr\"}, {\"name\": \"act\"},\n                            {\"name\": \".admin\"}],\n                 \"auth\": \"plaintext:key\"})),\n            # GET of user object (reseller admin check [and fail here])\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:adm\"},\n             {\"name\": \"test\"}, {\"name\": \".admin\"}],\n             \"auth\": \"plaintext:key\"}))]))\n        resp = Request.blank('/auth/v2/act/usr',\n            headers={'X-Auth-Admin-User': 'act:adm',\n                     'X-Auth-Admin-Key': 'key'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 403)\n        self.assertEqual(self.test_auth.app.calls, 3)\n\n    def test_get_user_account_admin_fail_getting_reseller_admin(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object (account admin check)\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:adm\"},\n             {\"name\": \"test\"}, {\"name\": \".admin\"}],\n             \"auth\": \"plaintext:key\"})),\n            # GET of requested user object [who is a .reseller_admin]\n            ('200 Ok', {}, json.dumps(\n                {\"groups\": [{\"name\": \"act:usr\"}, {\"name\": \"act\"},\n                            {\"name\": \".reseller_admin\"}],\n                 \"auth\": \"plaintext:key\"}))]))\n        resp = Request.blank('/auth/v2/act/usr',\n            headers={'X-Auth-Admin-User': 'act:adm',\n                     'X-Auth-Admin-Key': 'key'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 403)\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n    def test_get_user_reseller_admin_fail_getting_reseller_admin(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object (account admin check)\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:adm\"},\n             {\"name\": \"test\"}, {\"name\": \".reseller_admin\"}],\n             \"auth\": \"plaintext:key\"})),\n            # GET of requested user object [who also is a .reseller_admin]\n            ('200 Ok', {}, json.dumps(\n                {\"groups\": [{\"name\": \"act:usr\"}, {\"name\": \"act\"},\n                            {\"name\": \".reseller_admin\"}],\n                 \"auth\": \"plaintext:key\"}))]))\n        resp = Request.blank('/auth/v2/act/usr',\n            headers={'X-Auth-Admin-User': 'act:adm',\n                     'X-Auth-Admin-Key': 'key'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 403)\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n    def test_get_user_super_admin_succeed_getting_reseller_admin(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of requested user object\n            ('200 Ok', {}, json.dumps(\n                {\"groups\": [{\"name\": \"act:usr\"}, {\"name\": \"act\"},\n                            {\"name\": \".reseller_admin\"}],\n                 \"auth\": \"plaintext:key\"}))]))\n        resp = Request.blank('/auth/v2/act/usr',\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 200)\n        self.assertEqual(resp.content_type, CONTENT_TYPE_JSON)\n        self.assertEqual(resp.body, json.dumps(\n            {\"groups\": [{\"name\": \"act:usr\"}, {\"name\": \"act\"},\n                        {\"name\": \".reseller_admin\"}],\n             \"auth\": \"plaintext:key\"}))\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_get_user_groups_not_found(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of account container (list objects)\n            ('404 Not Found', {}, '')]))\n        resp = Request.blank('/auth/v2/act/.groups',\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 404)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_get_user_groups_fail_listing(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of account container (list objects)\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v2/act/.groups',\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_get_user_groups_fail_get_user(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of account container (list objects)\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'},\n             json.dumps([\n                {\"name\": \".services\", \"hash\": \"etag\", \"bytes\": 112,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.618110\"},\n                {\"name\": \"tester\", \"hash\": \"etag\", \"bytes\": 104,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.736680\"},\n                {\"name\": \"tester3\", \"hash\": \"etag\", \"bytes\": 86,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:28.135530\"}])),\n            # GET of user object\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v2/act/.groups',\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n    def test_get_user_not_found(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object\n            ('404 Not Found', {}, '')]))\n        resp = Request.blank('/auth/v2/act/usr',\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 404)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_get_user_fail(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v2/act/usr',\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest',\n                     'X-Auth-User-Key': 'key'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_put_user_fail_invalid_account(self):\n        resp = Request.blank('/auth/v2/.invalid/usr',\n            environ={'REQUEST_METHOD': 'PUT'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest',\n                     'X-Auth-User-Key': 'key'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 400)\n\n    def test_put_user_fail_invalid_user(self):\n        resp = Request.blank('/auth/v2/act/.usr',\n            environ={'REQUEST_METHOD': 'PUT'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest',\n                     'X-Auth-User-Key': 'key'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 400)\n\n    def test_put_user_fail_no_user_key(self):\n        resp = Request.blank('/auth/v2/act/usr',\n            environ={'REQUEST_METHOD': 'PUT'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 400)\n\n    def test_put_user_reseller_admin_fail_bad_creds(self):\n        self.test_auth.app = FakeApp(iter([\n            # Checking if user is changing his own key. This is called.\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:rdm\"},\n             {\"name\": \"test\"}, {\"name\": \".admin\"},\n             {\"name\": \".reseller_admin\"}], \"auth\": \"plaintext:key\"})),\n            # GET of user object (reseller admin)\n            # This shouldn't actually get called, checked\n            # below\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:rdm\"},\n             {\"name\": \"test\"}, {\"name\": \".admin\"},\n             {\"name\": \".reseller_admin\"}], \"auth\": \"plaintext:key\"}))]))\n        resp = Request.blank('/auth/v2/act/usr',\n            environ={'REQUEST_METHOD': 'PUT'},\n            headers={'X-Auth-Admin-User': 'act:rdm',\n                     'X-Auth-Admin-Key': 'key',\n                     'X-Auth-User-Key': 'key',\n                     'X-Auth-User-Reseller-Admin': 'true'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n        self.test_auth.app = FakeApp(iter([\n            # Checking if user is changing his own key. This is called.\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:adm\"},\n             {\"name\": \"test\"}, {\"name\": \".admin\"}],\n                \"auth\": \"plaintext:key\"})),\n            # GET of user object (account admin, but not reseller admin)\n            # This shouldn't actually get called, checked\n            # below\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:adm\"},\n             {\"name\": \"test\"}, {\"name\": \".admin\"}],\n                \"auth\": \"plaintext:key\"}))]))\n        resp = Request.blank('/auth/v2/act/usr',\n            environ={'REQUEST_METHOD': 'PUT'},\n            headers={'X-Auth-Admin-User': 'act:adm',\n                     'X-Auth-Admin-Key': 'key',\n                     'X-Auth-User-Key': 'key',\n                     'X-Auth-User-Reseller-Admin': 'true'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n        self.test_auth.app = FakeApp(iter([\n            # Checking if user is changing his own key. This is called.\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:usr\"},\n             {\"name\": \"test\"}], \"auth\": \"plaintext:key\"})),\n            # GET of user object (regular user)\n            # This shouldn't actually get called, checked\n            # below\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:usr\"},\n             {\"name\": \"test\"}], \"auth\": \"plaintext:key\"}))]))\n        resp = Request.blank('/auth/v2/act/usr',\n            environ={'REQUEST_METHOD': 'PUT'},\n            headers={'X-Auth-Admin-User': 'act:adm',\n                     'X-Auth-Admin-Key': 'key',\n                     'X-Auth-User-Key': 'key',\n                     'X-Auth-User-Reseller-Admin': 'true'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_put_user_account_admin_fail_bad_creds(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object (account admin, but wrong account)\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act2:adm\"},\n             {\"name\": \"test\"}, {\"name\": \".admin\"}],\n             \"auth\": \"plaintext:key\"})),\n            # Checking if user is changing his own key.\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:adm\"},\n             {\"name\": \"test\"}, {\"name\": \".admin\"}],\n             \"auth\": \"plaintext:key\"}))]))\n        resp = Request.blank('/auth/v2/act/usr',\n            environ={'REQUEST_METHOD': 'PUT'},\n            headers={'X-Auth-Admin-User': 'act2:adm',\n                     'X-Auth-Admin-Key': 'key',\n                     'X-Auth-User-Key': 'key',\n                     'X-Auth-User-Admin': 'true'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 403)\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object (regular user)\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:usr\"},\n             {\"name\": \"test\"}], \"auth\": \"plaintext:key\"})),\n            # Checking if user is changing his own key.\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:usr\"},\n             {\"name\": \"test\"}], \"auth\": \"plaintext:key\"}))]))\n        resp = Request.blank('/auth/v2/act/usr',\n            environ={'REQUEST_METHOD': 'PUT'},\n            headers={'X-Auth-Admin-User': 'act:usr',\n                     'X-Auth-Admin-Key': 'key',\n                     'X-Auth-User-Key': 'key',\n                     'X-Auth-User-Admin': 'true'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 403)\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n    def test_put_user_regular_fail_bad_creds(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object (account admin, but wrong\n            # account)\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act2:adm\"},\n             {\"name\": \"test\"}, {\"name\": \".admin\"}],\n                \"auth\": \"plaintext:key\"})),\n            # Checking if user is changing his own key.\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:adm\"},\n             {\"name\": \"test\"}, {\"name\": \".admin\"}],\n                \"auth\": \"plaintext:key\"}))]))\n        resp = Request.blank('/auth/v2/act/usr',\n            environ={'REQUEST_METHOD': 'PUT'},\n            headers={'X-Auth-Admin-User': 'act2:adm',\n                     'X-Auth-Admin-Key': 'key',\n                     'X-Auth-User-Key': 'key'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 403)\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object (regular user)\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:usr\"},\n             {\"name\": \"test\"}], \"auth\": \"plaintext:key\"})),\n            # Checking if user is changing his own key.\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:usr\"},\n             {\"name\": \"test\"}], \"auth\": \"plaintext:key\"}))]))\n        resp = Request.blank('/auth/v2/act2/usr',\n            environ={'REQUEST_METHOD': 'PUT'},\n            headers={'X-Auth-Admin-User': 'act:usr',\n                     'X-Auth-Admin-Key': 'key',\n                     'X-Auth-User-Key': 'key'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 403)\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n    def test_put_user_regular_success(self):\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, ''),\n            # PUT of user object\n            ('201 Created', {}, '')]))\n        resp = Request.blank('/auth/v2/act/usr',\n            environ={'REQUEST_METHOD': 'PUT'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest',\n                     'X-Auth-User-Key': 'key'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 201)\n        self.assertEqual(self.test_auth.app.calls, 2)\n        self.assertEqual(json.loads(self.test_auth.app.request.body),\n            {\"groups\": [{\"name\": \"act:usr\"}, {\"name\": \"act\"}],\n             \"auth\": \"plaintext:key\"})\n\n    def test_put_user_special_chars_success(self):\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, ''),\n            # PUT of user object\n            ('201 Created', {}, '')]))\n        resp = Request.blank('/auth/v2/act/u_s-r',\n            environ={'REQUEST_METHOD': 'PUT'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest',\n                     'X-Auth-User-Key': 'key'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 201)\n        self.assertEqual(self.test_auth.app.calls, 2)\n        self.assertEqual(json.loads(self.test_auth.app.request.body),\n            {\"groups\": [{\"name\": \"act:u_s-r\"}, {\"name\": \"act\"}],\n             \"auth\": \"plaintext:key\"})\n\n    def test_put_user_account_admin_success(self):\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, ''),\n            # PUT of user object\n            ('201 Created', {}, '')]))\n        resp = Request.blank('/auth/v2/act/usr',\n            environ={'REQUEST_METHOD': 'PUT'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest',\n                     'X-Auth-User-Key': 'key',\n                     'X-Auth-User-Admin': 'true'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 201)\n        self.assertEqual(self.test_auth.app.calls, 2)\n        self.assertEqual(json.loads(self.test_auth.app.request.body),\n            {\"groups\": [{\"name\": \"act:usr\"}, {\"name\": \"act\"},\n                        {\"name\": \".admin\"}],\n             \"auth\": \"plaintext:key\"})\n\n    def test_put_user_reseller_admin_success(self):\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, ''),\n            # PUT of user object\n            ('201 Created', {}, '')]))\n        resp = Request.blank('/auth/v2/act/usr',\n            environ={'REQUEST_METHOD': 'PUT'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest',\n                     'X-Auth-User-Key': 'key',\n                     'X-Auth-User-Reseller-Admin': 'true'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 201)\n        self.assertEqual(self.test_auth.app.calls, 2)\n        self.assertEqual(json.loads(self.test_auth.app.request.body),\n            {\"groups\": [{\"name\": \"act:usr\"}, {\"name\": \"act\"},\n                        {\"name\": \".admin\"}, {\"name\": \".reseller_admin\"}],\n             \"auth\": \"plaintext:key\"})\n\n    def test_put_user_fail_not_found(self):\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, ''),\n            # PUT of user object\n            ('404 Not Found', {}, '')]))\n        resp = Request.blank('/auth/v2/act/usr',\n            environ={'REQUEST_METHOD': 'PUT'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest',\n                     'X-Auth-User-Key': 'key'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 404)\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n    def test_put_user_fail(self):\n        self.test_auth.app = FakeApp(iter([\n            # PUT of user object\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v2/act/usr',\n            environ={'REQUEST_METHOD': 'PUT'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest',\n                     'X-Auth-User-Key': 'key'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_put_user_key_hash(self):\n        key_hash = (\"sha512:aSm0jEeqIp46T5YLZy1r8+cXs/Xzs1S4VUwVauhBs44=$ef\"\n                    \"7332ec1288bf69c75682eb8d459d5a84baa7e43f45949c242a9af9\"\n                    \"7130ef16ac361fe1aa33a789e218122b83c54ef1923fc015080741\"\n                    \"ca21f6187329f6cb7a\")\n\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, ''),\n            # PUT of user object\n            ('201 Created', {}, '')]))\n        resp = Request.blank('/auth/v2/act/usr',\n            environ={'REQUEST_METHOD': 'PUT'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest',\n                     'X-Auth-User-Key-Hash': quote(key_hash)}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 201)\n        self.assertEqual(self.test_auth.app.calls, 2)\n        self.assertEqual(json.loads(self.test_auth.app.request.body),\n            {\"groups\": [{\"name\": \"act:usr\"}, {\"name\": \"act\"}],\n             \"auth\": key_hash})\n\n    def test_put_user_key_hash_wrong_type(self):\n        key_hash = \"wrong_auth_type:1234\"\n\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, ''),\n            # PUT of user object\n            ('201 Created', {}, '')]))\n        resp = Request.blank('/auth/v2/act/usr',\n            environ={'REQUEST_METHOD': 'PUT'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest',\n                     'X-Auth-User-Key-Hash': quote(key_hash)}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 400)\n        self.assertEqual(self.test_auth.app.calls, 0)\n\n    def test_put_user_key_hash_wrong_format(self):\n        key_hash = \"1234\"\n\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, ''),\n            # PUT of user object\n            ('201 Created', {}, '')]))\n        resp = Request.blank('/auth/v2/act/usr',\n            environ={'REQUEST_METHOD': 'PUT'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest',\n                     'X-Auth-User-Key-Hash': quote(key_hash)}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 400)\n        self.assertEqual(self.test_auth.app.calls, 0)\n\n    def test_delete_user_bad_creds(self):\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act2:adm\"},\n             {\"name\": \"test\"}, {\"name\": \".admin\"}],\n                \"auth\": \"plaintext:key\"})),\n            # GET of user object (account admin, but wrong account)\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act2:adm\"},\n             {\"name\": \"test\"}, {\"name\": \".admin\"}],\n             \"auth\": \"plaintext:key\"}))]))\n        resp = Request.blank('/auth/v2/act/usr',\n            environ={'REQUEST_METHOD': 'DELETE'},\n            headers={'X-Auth-Admin-User': 'act2:adm',\n                     'X-Auth-Admin-Key': 'key'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 403)\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:usr\"},\n             {\"name\": \"test\"}], \"auth\": \"plaintext:key\"})),\n            # GET of user object (regular user)\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:usr\"},\n             {\"name\": \"test\"}], \"auth\": \"plaintext:key\"}))]))\n        resp = Request.blank('/auth/v2/act/usr',\n            environ={'REQUEST_METHOD': 'DELETE'},\n            headers={'X-Auth-Admin-User': 'act:usr',\n                     'X-Auth-Admin-Key': 'key'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 403)\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n    def test_delete_reseller_admin_user_fail(self):\n        self.test_auth.app = FakeApp(iter([\n            # is user being deleted a reseller_admin\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act2:re_adm\"},\n             {\"name\": \"act2\"}, {\"name\": \".admin\"},\n                {\"name\": \".reseller_admin\"}], \"auth\": \"plaintext:key\"})),\n            # GET of user object\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act2:adm\"},\n             {\"name\": \"act2\"}, {\"name\": \".admin\"}],\n                \"auth\": \"plaintext:key\"}))]))\n\n        resp = Request.blank('/auth/v2/act2/re_adm',\n                             environ={\n                                 'REQUEST_METHOD': 'DELETE'},\n                             headers={\n                                 'X-Auth-Admin-User':\n                                 'act2:adm',\n                                 'X-Auth-Admin-Key': 'key'}\n                             ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 403)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_delete_reseller_admin_user_success(self):\n        self.test_auth.app = FakeApp(iter([\n            # is user being deleted a reseller_admin\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act2:re_adm\"},\n             {\"name\": \"act2\"}, {\"name\": \".admin\"},\n                {\"name\": \".reseller_admin\"}], \"auth\": \"plaintext:key\"})),\n            # HEAD of user object\n            ('200 Ok',\n             {'X-Object-Meta-Auth-Token': 'AUTH_tk'}, ''),\n            # DELETE of token\n            ('204 No Content', {}, ''),\n            # DELETE of user object\n            ('204 No Content', {}, '')]))\n\n        resp = Request.blank('/auth/v2/act2/re_adm',\n                             environ={\n                                 'REQUEST_METHOD': 'DELETE'},\n                             headers={\n                                 'X-Auth-Admin-User':\n                                 '.super_admin',\n                                 'X-Auth-Admin-Key': 'supertest'}\n                             ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 204)\n        self.assertEqual(self.test_auth.app.calls, 4)\n\n    def test_delete_user_invalid_account(self):\n        resp = Request.blank('/auth/v2/.invalid/usr',\n            environ={'REQUEST_METHOD': 'DELETE'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 400)\n\n    def test_delete_user_invalid_user(self):\n        resp = Request.blank('/auth/v2/act/.invalid',\n            environ={'REQUEST_METHOD': 'DELETE'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 400)\n\n    def test_delete_user_not_found(self):\n        self.test_auth.app = FakeApp(iter([\n            # HEAD of user object\n            ('404 Not Found', {}, '')]))\n        resp = Request.blank('/auth/v2/act/usr',\n            environ={'REQUEST_METHOD': 'DELETE'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 404)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_delete_user_fail_head_user(self):\n        self.test_auth.app = FakeApp(iter([\n            # HEAD of user object\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v2/act/usr',\n            environ={'REQUEST_METHOD': 'DELETE'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_delete_user_fail_delete_token(self):\n        self.test_auth.app = FakeApp(iter([\n            # is user reseller_admin\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:usr\"},\n             {\"name\": \"test\"}], \"auth\": \"plaintext:key\"})),\n            # HEAD of user object\n            ('200 Ok', {'X-Object-Meta-Auth-Token': 'AUTH_tk'}, ''),\n            # DELETE of token\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v2/act/usr',\n            environ={'REQUEST_METHOD': 'DELETE'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 3)\n\n    def test_delete_user_fail_delete_user(self):\n        self.test_auth.app = FakeApp(iter([\n            # is user reseller_admin\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:usr\"},\n             {\"name\": \"test\"}], \"auth\": \"plaintext:key\"})),\n            # HEAD of user object\n            ('200 Ok', {'X-Object-Meta-Auth-Token': 'AUTH_tk'}, ''),\n            # DELETE of token\n            ('204 No Content', {}, ''),\n            # DELETE of user object\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v2/act/usr',\n            environ={'REQUEST_METHOD': 'DELETE'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 4)\n\n    def test_delete_user_success(self):\n        self.test_auth.app = FakeApp(iter([\n            # is user reseller_admin\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:usr\"},\n             {\"name\": \"test\"}], \"auth\": \"plaintext:key\"})),\n            # HEAD of user object\n            ('200 Ok', {'X-Object-Meta-Auth-Token': 'AUTH_tk'}, ''),\n            # DELETE of token\n            ('204 No Content', {}, ''),\n            # DELETE of user object\n            ('204 No Content', {}, '')]))\n        resp = Request.blank('/auth/v2/act/usr',\n            environ={'REQUEST_METHOD': 'DELETE'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 204)\n        self.assertEqual(self.test_auth.app.calls, 4)\n\n    def test_delete_user_success_missing_user_at_end(self):\n        self.test_auth.app = FakeApp(iter([\n            # is user reseller_admin\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:usr\"},\n             {\"name\": \"test\"}], \"auth\": \"plaintext:key\"})),\n            # HEAD of user object\n            ('200 Ok', {'X-Object-Meta-Auth-Token': 'AUTH_tk'}, ''),\n            # DELETE of token\n            ('204 No Content', {}, ''),\n            # DELETE of user object\n            ('404 Not Found', {}, '')]))\n        resp = Request.blank('/auth/v2/act/usr',\n            environ={'REQUEST_METHOD': 'DELETE'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 204)\n        self.assertEqual(self.test_auth.app.calls, 4)\n\n    def test_delete_user_success_missing_token(self):\n        self.test_auth.app = FakeApp(iter([\n            # is user reseller_admin\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:usr\"},\n             {\"name\": \"test\"}], \"auth\": \"plaintext:key\"})),\n            # HEAD of user object\n            ('200 Ok', {'X-Object-Meta-Auth-Token': 'AUTH_tk'}, ''),\n            # DELETE of token\n            ('404 Not Found', {}, ''),\n            # DELETE of user object\n            ('204 No Content', {}, '')]))\n        resp = Request.blank('/auth/v2/act/usr',\n            environ={'REQUEST_METHOD': 'DELETE'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 204)\n        self.assertEqual(self.test_auth.app.calls, 4)\n\n    def test_delete_user_success_no_token(self):\n        self.test_auth.app = FakeApp(iter([\n            # is user reseller_admin\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:usr\"},\n             {\"name\": \"test\"}], \"auth\": \"plaintext:key\"})),\n            # HEAD of user object\n            ('200 Ok', {}, ''),\n            # DELETE of user object\n            ('204 No Content', {}, '')]))\n        resp = Request.blank('/auth/v2/act/usr',\n            environ={'REQUEST_METHOD': 'DELETE'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 204)\n        self.assertEqual(self.test_auth.app.calls, 3)\n\n    def test_validate_token_bad_prefix(self):\n        resp = Request.blank('/auth/v2/.token/BAD_token') \\\n            .get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 400)\n\n    def test_validate_token_tmi(self):\n        resp = Request.blank('/auth/v2/.token/AUTH_token/tmi') \\\n            .get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 400)\n\n    def test_validate_token_bad_memcache(self):\n        fake_memcache = FakeMemcache()\n        fake_memcache.set('AUTH_/auth/AUTH_token', 'bogus')\n        resp = Request.blank('/auth/v2/.token/AUTH_token',\n            environ={'swift.cache':\n            fake_memcache}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n\n    def test_validate_token_from_memcache(self):\n        fake_memcache = FakeMemcache()\n        fake_memcache.set('AUTH_/auth/AUTH_token', (time() + 1, 'act:usr,act'))\n        resp = Request.blank('/auth/v2/.token/AUTH_token',\n            environ={'swift.cache':\n            fake_memcache}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 204)\n        self.assertEqual(resp.headers.get('x-auth-groups'), 'act:usr,act')\n        self.assertTrue(float(resp.headers['x-auth-ttl']) < 1,\n                     resp.headers['x-auth-ttl'])\n\n    def test_validate_token_from_memcache_expired(self):\n        fake_memcache = FakeMemcache()\n        fake_memcache.set('AUTH_/auth/AUTH_token', (time() - 1, 'act:usr,act'))\n        resp = Request.blank('/auth/v2/.token/AUTH_token',\n            environ={'swift.cache':\n            fake_memcache}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 404)\n        self.assertTrue('x-auth-groups' not in resp.headers)\n        self.assertTrue('x-auth-ttl' not in resp.headers)\n\n    def test_validate_token_from_object(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of token object\n            ('200 Ok', {}, json.dumps({'groups': [{'name': 'act:usr'},\n             {'name': 'act'}], 'expires': time() + 1}))]))\n        resp = Request.blank('/auth/v2/.token/AUTH_token'\n                             ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 204)\n        self.assertEqual(self.test_auth.app.calls, 1)\n        self.assertEqual(resp.headers.get('x-auth-groups'), 'act:usr,act')\n        self.assertTrue(float(resp.headers['x-auth-ttl']) < 1,\n                     resp.headers['x-auth-ttl'])\n\n    def test_validate_token_from_object_expired(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of token object\n            ('200 Ok', {}, json.dumps({'groups': 'act:usr,act',\n             'expires': time() - 1})),\n            # DELETE of expired token object\n            ('204 No Content', {}, '')]))\n        resp = Request.blank('/auth/v2/.token/AUTH_token'\n                             ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 404)\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n    def test_validate_token_from_object_with_admin(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of token object\n            ('200 Ok', {}, json.dumps({'account_id': 'AUTH_cfa', 'groups':\n             [{'name': 'act:usr'}, {'name': 'act'}, {'name': '.admin'}],\n             'expires': time() + 1}))]))\n        resp = Request.blank('/auth/v2/.token/AUTH_token'\n                             ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 204)\n        self.assertEqual(self.test_auth.app.calls, 1)\n        self.assertEqual(resp.headers.get('x-auth-groups'),\n                         'act:usr,act,AUTH_cfa')\n        self.assertTrue(float(resp.headers['x-auth-ttl']) < 1,\n                     resp.headers['x-auth-ttl'])\n\n    def test_get_conn_default(self):\n        conn = self.test_auth.get_conn()\n        self.assertEqual(conn.__class__, auth.HTTPConnection)\n        self.assertEqual(conn.host, '127.0.0.1')\n        self.assertEqual(conn.port, 8080)\n\n    def test_get_conn_default_https(self):\n        local_auth = auth.filter_factory({'super_admin_key': 'supertest',\n            'default_swift_cluster': 'local#https://1.2.3.4/v1'})(FakeApp())\n        conn = local_auth.get_conn()\n        self.assertEqual(conn.__class__, auth.HTTPSConnection)\n        self.assertEqual(conn.host, '1.2.3.4')\n        self.assertEqual(conn.port, 443)\n\n    def test_get_conn_overridden(self):\n        local_auth = auth.filter_factory({'super_admin_key': 'supertest',\n            'default_swift_cluster': 'local#https://1.2.3.4/v1'})(FakeApp())\n        conn = \\\n            local_auth.get_conn(urlparsed=auth.urlparse('http://5.6.7.8/v1'))\n        self.assertEqual(conn.__class__, auth.HTTPConnection)\n        self.assertEqual(conn.host, '5.6.7.8')\n        self.assertEqual(conn.port, 80)\n\n    def test_get_conn_overridden_https(self):\n        local_auth = auth.filter_factory({'super_admin_key': 'supertest',\n            'default_swift_cluster': 'local#http://1.2.3.4/v1'})(FakeApp())\n        conn = \\\n            local_auth.get_conn(urlparsed=auth.urlparse('https://5.6.7.8/v1'))\n        self.assertEqual(conn.__class__, auth.HTTPSConnection)\n        self.assertEqual(conn.host, '5.6.7.8')\n        self.assertEqual(conn.port, 443)\n\n    def test_get_itoken_fail_no_memcache(self):\n        exc = None\n        try:\n            self.test_auth.get_itoken({})\n        except Exception as err:\n            exc = err\n        self.assertEqual(str(exc),\n                         'No memcache set up; required for Swauth middleware')\n\n    def test_get_itoken_success(self):\n        fmc = FakeMemcache()\n        itk = self.test_auth.get_itoken({'swift.cache': fmc})\n        self.assertTrue(itk.startswith('AUTH_itk'), itk)\n        expires, groups = fmc.get('AUTH_/auth/%s' % itk)\n        self.assertTrue(expires > time(), expires)\n        self.assertEqual(groups, '.auth,.reseller_admin,AUTH_.auth')\n\n    def test_get_admin_detail_fail_no_colon(self):\n        self.test_auth.app = FakeApp(iter([]))\n        self.assertEqual(self.test_auth.get_admin_detail(Request.blank('/')),\n                         None)\n        self.assertEqual(self.test_auth.get_admin_detail(Request.blank('/',\n            headers={'X-Auth-Admin-User': 'usr'})), None)\n        self.assertRaises(StopIteration, self.test_auth.get_admin_detail,\n            Request.blank('/', headers={'X-Auth-Admin-User': 'act:usr'}))\n\n    def test_get_admin_detail_fail_user_not_found(self):\n        self.test_auth.app = FakeApp(iter([('404 Not Found', {}, '')]))\n        self.assertEqual(self.test_auth.get_admin_detail(Request.blank('/',\n            headers={'X-Auth-Admin-User': 'act:usr'})), None)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_get_admin_detail_fail_get_user_error(self):\n        self.test_auth.app = FakeApp(iter([\n            ('503 Service Unavailable', {}, '')]))\n        exc = None\n        try:\n            self.test_auth.get_admin_detail(Request.blank('/',\n                headers={'X-Auth-Admin-User': 'act:usr'}))\n        except Exception as err:\n            exc = err\n        self.assertEqual(str(exc), 'Could not get user object: '\n            '/v1/AUTH_.auth/act/usr 503 Service Unavailable')\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_get_admin_detail_success(self):\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {},\n             json.dumps({\"auth\": \"plaintext:key\",\n                         \"groups\": [{'name': \"act:usr\"}, {'name': \"act\"},\n                                    {'name': \".admin\"}]}))]))\n        detail = self.test_auth.get_admin_detail(Request.blank('/',\n                    headers={'X-Auth-Admin-User': 'act:usr'}))\n        self.assertEqual(self.test_auth.app.calls, 1)\n        self.assertEqual(detail, {'account': 'act',\n            'auth': 'plaintext:key',\n            'groups': [{'name': 'act:usr'}, {'name': 'act'},\n                       {'name': '.admin'}]})\n\n    def test_get_user_detail_success(self):\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {},\n             json.dumps({\"auth\": \"plaintext:key\",\n                         \"groups\": [{'name': \"act:usr\"}, {'name': \"act\"},\n                                    {'name': \".admin\"}]}))]))\n        detail = self.test_auth.get_user_detail(\n            Request.blank('/',\n                          headers={'X-Auth-Admin-User': 'act:usr'}),\n            'act', 'usr')\n        self.assertEqual(self.test_auth.app.calls, 1)\n        detail_json = json.loads(detail)\n        self.assertEqual(\"plaintext:key\", detail_json['auth'])\n\n    def test_get_user_detail_fail_user_doesnt_exist(self):\n        self.test_auth.app = FakeApp(\n            iter([('404 Not Found', {}, '')]))\n        detail = self.test_auth.get_user_detail(\n            Request.blank('/',\n                          headers={'X-Auth-Admin-User': 'act:usr'}),\n            'act', 'usr')\n        self.assertEqual(self.test_auth.app.calls, 1)\n        self.assertEqual(detail, None)\n\n    def test_get_user_detail_fail_exception(self):\n        self.test_auth.app = FakeApp(iter([\n            ('503 Service Unavailable', {}, '')]))\n        exc = None\n        try:\n            self.test_auth.get_user_detail(\n                Request.blank('/',\n                              headers={'X-Auth-Admin-User': 'act:usr'}),\n                'act', 'usr')\n        except Exception as err:\n            exc = err\n        self.assertEqual(str(exc), 'Could not get user object: '\n                         '/v1/AUTH_.auth/act/usr 503 Service Unavailable')\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_is_user_reseller_admin_success(self):\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {},\n             json.dumps({\"auth\": \"plaintext:key\",\n                         \"groups\": [{'name': \"act:usr\"}, {'name': \"act\"},\n                                    {'name': \".reseller_admin\"}]}))]))\n        result = self.test_auth.is_user_reseller_admin(\n            Request.blank('/',\n                          headers={'X-Auth-Admin-User': 'act:usr'}),\n            'act', 'usr')\n        self.assertEqual(self.test_auth.app.calls, 1)\n        self.assertTrue(result)\n\n    def test_is_user_reseller_admin_fail(self):\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {},\n             json.dumps({\"auth\": \"plaintext:key\",\n                         \"groups\": [{'name': \"act:usr\"}, {'name': \"act\"},\n                                    {'name': \".admin\"}]}))]))\n        result = self.test_auth.is_user_reseller_admin(\n            Request.blank('/',\n                          headers={'X-Auth-Admin-User': 'act:usr'}),\n            'act', 'usr')\n        self.assertEqual(self.test_auth.app.calls, 1)\n        self.assertFalse(result)\n\n    def test_is_user_reseller_admin_fail_user_doesnt_exist(self):\n        self.test_auth.app = FakeApp(\n            iter([('404 Not Found', {}, '')]))\n        req = Request.blank('/', headers={'X-Auth-Admin-User': 'act:usr'})\n        result = self.test_auth.is_user_reseller_admin(req, 'act', 'usr')\n        self.assertEqual(self.test_auth.app.calls, 1)\n        self.assertFalse(result)\n        self.assertFalse(req.credentials_valid)\n\n    def test_credentials_match_success(self):\n        self.assertTrue(self.test_auth.credentials_match(\n            {'auth': 'plaintext:key'}, 'key'))\n\n    def test_credentials_match_fail_no_details(self):\n        self.assertTrue(not self.test_auth.credentials_match(None, 'notkey'))\n\n    def test_credentials_match_fail_plaintext(self):\n        self.assertTrue(not self.test_auth.credentials_match(\n            {'auth': 'plaintext:key'}, 'notkey'))\n\n    def test_is_user_changing_own_key_err(self):\n        # User does not exist\n        self.test_auth.app = FakeApp(\n            iter([('404 Not Found', {}, '')]))\n        req = Request.blank('/auth/v2/act/usr',\n                            environ={\n                                'REQUEST_METHOD': 'PUT'},\n                            headers={\n                                'X-Auth-Admin-User': 'act:usr',\n                                'X-Auth-Admin-Key': 'key',\n                                'X-Auth-User-Key': 'key'})\n        self.assertTrue(\n            not self.test_auth.is_user_changing_own_key(req, 'act:usr'))\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n        # user attempting to escalate himself as admin\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:usr\"},\n             {\"name\": \"test\"}], \"auth\": \"plaintext:key\"}))]))\n        req = Request.blank('/auth/v2/act/usr',\n                            environ={\n                                'REQUEST_METHOD': 'PUT'},\n                            headers={\n                                'X-Auth-Admin-User': 'act:usr',\n                                'X-Auth-Admin-Key': 'key',\n                                'X-Auth-User-Key': 'key',\n                                'X-Auth-User-Admin': 'true'})\n        self.assertTrue(\n            not self.test_auth.is_user_changing_own_key(req, 'act:usr'))\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n        # admin attempting to escalate himself as reseller_admin\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:adm\"},\n             {\"name\": \"test\"}, {\"name\": \".admin\"}],\n                \"auth\": \"plaintext:key\"}))]))\n        req = Request.blank('/auth/v2/act/adm',\n                            environ={\n                                'REQUEST_METHOD': 'PUT'},\n                            headers={\n                                'X-Auth-Admin-User': 'act:adm',\n                                'X-Auth-Admin-Key': 'key',\n                                'X-Auth-User-Key': 'key',\n                                'X-Auth-User-Reseller-Admin': 'true'})\n        self.assertTrue(\n            not self.test_auth.is_user_changing_own_key(req, 'act:adm'))\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n        # different user\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:usr\"},\n             {\"name\": \"test\"}], \"auth\": \"plaintext:key\"}))]))\n        req = Request.blank('/auth/v2/act/usr2',\n                            environ={\n                                'REQUEST_METHOD': 'PUT'},\n                            headers={\n                                'X-Auth-Admin-User': 'act:usr',\n                                'X-Auth-Admin-Key': 'key',\n                                'X-Auth-User-Key': 'key'})\n        self.assertTrue(\n            not self.test_auth.is_user_changing_own_key(req, 'act:usr2'))\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n        # wrong key\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:usr\"},\n             {\"name\": \"test\"}], \"auth\": \"plaintext:key\"}))]))\n        req = Request.blank('/auth/v2/act/usr',\n                            environ={\n                                'REQUEST_METHOD': 'PUT'},\n                            headers={\n                                'X-Auth-Admin-User': 'act:usr',\n                                'X-Auth-Admin-Key': 'wrongkey',\n                                'X-Auth-User-Key': 'newkey'})\n        self.assertTrue(\n            not self.test_auth.is_user_changing_own_key(req, 'act:usr'))\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_is_super_admin_success(self):\n        self.assertTrue(self.test_auth.is_super_admin(Request.blank('/',\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'})))\n\n    def test_is_super_admin_fail_bad_key(self):\n        self.assertTrue(not self.test_auth.is_super_admin(Request.blank('/',\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'bad'})))\n        self.assertTrue(not self.test_auth.is_super_admin(Request.blank('/',\n            headers={'X-Auth-Admin-User': '.super_admin'})))\n        self.assertTrue(not self.test_auth.is_super_admin(Request.blank('/')))\n\n    def test_is_super_admin_fail_bad_user(self):\n        self.assertTrue(not self.test_auth.is_super_admin(Request.blank('/',\n            headers={'X-Auth-Admin-User': 'bad',\n                     'X-Auth-Admin-Key': 'supertest'})))\n        self.assertTrue(not self.test_auth.is_super_admin(Request.blank('/',\n            headers={'X-Auth-Admin-Key': 'supertest'})))\n        self.assertTrue(not self.test_auth.is_super_admin(Request.blank('/')))\n\n    def test_is_reseller_admin_success_is_super_admin(self):\n        self.assertTrue(self.test_auth.is_reseller_admin(Request.blank('/',\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'})))\n\n    def test_is_reseller_admin_success_called_get_admin_detail(self):\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {},\n             json.dumps({'auth': 'plaintext:key',\n                         'groups': [{'name': 'act:rdm'}, {'name': 'act'},\n                                    {'name': '.admin'},\n                                    {'name': '.reseller_admin'}]}))]))\n        self.assertTrue(self.test_auth.is_reseller_admin(Request.blank('/',\n            headers={'X-Auth-Admin-User': 'act:rdm',\n                     'X-Auth-Admin-Key': 'key'})))\n\n    def test_is_reseller_admin_fail_only_account_admin(self):\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {},\n             json.dumps({'auth': 'plaintext:key',\n                         'groups': [{'name': 'act:adm'}, {'name': 'act'},\n                                    {'name': '.admin'}]}))]))\n        self.assertTrue(not self.test_auth.is_reseller_admin(Request.blank('/',\n            headers={'X-Auth-Admin-User': 'act:adm',\n                     'X-Auth-Admin-Key': 'key'})))\n\n    def test_is_reseller_admin_fail_regular_user(self):\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {},\n             json.dumps({'auth': 'plaintext:key',\n                         'groups': [{'name': 'act:usr'}, {'name': 'act'}]}))]))\n        self.assertTrue(not self.test_auth.is_reseller_admin(Request.blank('/',\n            headers={'X-Auth-Admin-User': 'act:usr',\n                     'X-Auth-Admin-Key': 'key'})))\n\n    def test_is_reseller_admin_fail_bad_key(self):\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {},\n             json.dumps({'auth': 'plaintext:key',\n                         'groups': [{'name': 'act:rdm'}, {'name': 'act'},\n                                    {'name': '.admin'},\n                                    {'name': '.reseller_admin'}]}))]))\n        self.assertTrue(not self.test_auth.is_reseller_admin(Request.blank('/',\n            headers={'X-Auth-Admin-User': 'act:rdm',\n                     'X-Auth-Admin-Key': 'bad'})))\n\n    def test_is_account_admin_success_is_super_admin(self):\n        self.assertTrue(self.test_auth.is_account_admin(Request.blank('/',\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}), 'act'))\n\n    def test_is_account_admin_success_is_reseller_admin(self):\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {},\n             json.dumps({'auth': 'plaintext:key',\n                         'groups': [{'name': 'act:rdm'}, {'name': 'act'},\n                                    {'name': '.admin'},\n                                    {'name': '.reseller_admin'}]}))]))\n        self.assertTrue(self.test_auth.is_account_admin(Request.blank('/',\n            headers={'X-Auth-Admin-User': 'act:rdm',\n                     'X-Auth-Admin-Key': 'key'}), 'act'))\n\n    def test_is_account_admin_success(self):\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {},\n             json.dumps({'auth': 'plaintext:key',\n                         'groups': [{'name': 'act:adm'}, {'name': 'act'},\n                                    {'name': '.admin'}]}))]))\n        self.assertTrue(self.test_auth.is_account_admin(Request.blank('/',\n            headers={'X-Auth-Admin-User': 'act:adm',\n                     'X-Auth-Admin-Key': 'key'}), 'act'))\n\n    def test_is_account_admin_fail_account_admin_different_account(self):\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {},\n             json.dumps({'auth': 'plaintext:key',\n                         'groups': [{'name': 'act2:adm'}, {'name': 'act2'},\n                                    {'name': '.admin'}]}))]))\n        self.assertTrue(not self.test_auth.is_account_admin(Request.blank('/',\n            headers={'X-Auth-Admin-User': 'act2:adm',\n                     'X-Auth-Admin-Key': 'key'}), 'act'))\n\n    def test_is_account_admin_fail_regular_user(self):\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {},\n             json.dumps({'auth': 'plaintext:key',\n                         'groups': [{'name': 'act:usr'}, {'name': 'act'}]}))]))\n        self.assertTrue(not self.test_auth.is_account_admin(Request.blank('/',\n            headers={'X-Auth-Admin-User': 'act:usr',\n                     'X-Auth-Admin-Key': 'key'}), 'act'))\n\n    def test_is_account_admin_fail_bad_key(self):\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {},\n             json.dumps({'auth': 'plaintext:key',\n                         'groups': [{'name': 'act:rdm'}, {'name': 'act'},\n                                    {'name': '.admin'},\n                                    {'name': '.reseller_admin'}]}))]))\n        self.assertTrue(not self.test_auth.is_account_admin(Request.blank('/',\n            headers={'X-Auth-Admin-User': 'act:rdm',\n                     'X-Auth-Admin-Key': 'bad'}), 'act'))\n\n    def test_reseller_admin_but_account_is_internal_use_only(self):\n        req = Request.blank('/v1/AUTH_.auth',\n                            environ={'REQUEST_METHOD': 'GET'})\n        req.remote_user = 'act:usr,act,.reseller_admin'\n        resp = self.test_auth.authorize(req)\n        self.assertEqual(resp.status_int, 403)\n\n    def test_reseller_admin_but_account_is_exactly_reseller_prefix(self):\n        req = Request.blank('/v1/AUTH_', environ={'REQUEST_METHOD': 'GET'})\n        req.remote_user = 'act:usr,act,.reseller_admin'\n        resp = self.test_auth.authorize(req)\n        self.assertEqual(resp.status_int, 403)\n\n    def _get_token_success_v1_0_encoded(self, saved_user, saved_key, sent_user,\n                                        sent_key):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object\n            ('200 Ok', {},\n             json.dumps({\"auth\": \"plaintext:%s\" % saved_key,\n                         \"groups\": [{'name': saved_user}, {'name': \"act\"},\n                                    {'name': \".admin\"}]})),\n            # GET of account\n            ('204 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, ''),\n            # PUT of new token\n            ('201 Created', {}, ''),\n            # POST of token to user object\n            ('204 No Content', {}, ''),\n            # GET of services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n             \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}}))]))\n        resp = Request.blank('/auth/v1.0',\n            headers={'X-Auth-User': sent_user,\n                     'X-Auth-Key': sent_key}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 200)\n        self.assertEqual(resp.content_type, CONTENT_TYPE_JSON)\n        self.assertTrue(resp.headers.get('x-auth-token',\n            '').startswith('AUTH_tk'), resp.headers.get('x-auth-token'))\n        self.assertEqual(resp.headers.get('x-auth-token'),\n                         resp.headers.get('x-storage-token'))\n        self.assertEqual(resp.headers.get('x-storage-url'),\n                         'http://127.0.0.1:8080/v1/AUTH_cfa')\n        self.assertEqual(json.loads(resp.body),\n            {\"storage\": {\"default\": \"local\",\n             \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}})\n        self.assertEqual(self.test_auth.app.calls, 5)\n\n    def test_get_token_success_v1_0_encoded1(self):\n        self._get_token_success_v1_0_encoded(\n            'act:usr', 'key', 'act%3ausr', 'key')\n\n    def test_get_token_success_v1_0_encoded2(self):\n        self._get_token_success_v1_0_encoded(\n            'act:u s r', 'key', 'act%3au%20s%20r', 'key')\n\n    def test_get_token_success_v1_0_encoded3(self):\n        self._get_token_success_v1_0_encoded(\n            'act:u s r', 'k:e:y', 'act%3au%20s%20r', 'k%3Ae%3ay')\n\n    def test_allowed_sync_hosts(self):\n        a = auth.filter_factory({'super_admin_key': 'supertest'})(FakeApp())\n        self.assertEqual(a.allowed_sync_hosts, ['127.0.0.1'])\n        a = auth.filter_factory({'super_admin_key': 'supertest',\n            'allowed_sync_hosts':\n                '1.1.1.1,2.1.1.1, 3.1.1.1 , 4.1.1.1,, , 5.1.1.1'})(FakeApp())\n        self.assertEqual(a.allowed_sync_hosts,\n            ['1.1.1.1', '2.1.1.1', '3.1.1.1', '4.1.1.1', '5.1.1.1'])\n\n    def test_reseller_admin_is_owner(self):\n        orig_authorize = self.test_auth.authorize\n        owner_values = []\n\n        def mitm_authorize(req):\n            rv = orig_authorize(req)\n            owner_values.append(req.environ.get('swift_owner', False))\n            return rv\n\n        self.test_auth.authorize = mitm_authorize\n\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {},\n             json.dumps({'account': 'other', 'user': 'other:usr',\n                         'account_id': 'AUTH_other',\n                         'groups': [{'name': 'other:usr'}, {'name': 'other'},\n                                    {'name': '.reseller_admin'}],\n                         'expires': time() + 60})),\n            ('204 No Content', {}, '')]))\n        req = Request.blank('/v1/AUTH_cfa', headers={'X-Auth-Token': 'AUTH_t'})\n        resp = req.get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 204)\n        self.assertEqual(owner_values, [True])\n\n    def test_admin_is_owner(self):\n        orig_authorize = self.test_auth.authorize\n        owner_values = []\n\n        def mitm_authorize(req):\n            rv = orig_authorize(req)\n            owner_values.append(req.environ.get('swift_owner', False))\n            return rv\n\n        self.test_auth.authorize = mitm_authorize\n\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {},\n             json.dumps({'account': 'act', 'user': 'act:usr',\n                         'account_id': 'AUTH_cfa',\n                         'groups': [{'name': 'act:usr'}, {'name': 'act'},\n                                    {'name': '.admin'}],\n                         'expires': time() + 60})),\n            ('204 No Content', {}, '')]))\n        req = Request.blank('/v1/AUTH_cfa', headers={'X-Auth-Token': 'AUTH_t'})\n        resp = req.get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 204)\n        self.assertEqual(owner_values, [True])\n\n    def test_regular_is_not_owner(self):\n        orig_authorize = self.test_auth.authorize\n        owner_values = []\n\n        def mitm_authorize(req):\n            rv = orig_authorize(req)\n            owner_values.append(req.environ.get('swift_owner', False))\n            return rv\n\n        self.test_auth.authorize = mitm_authorize\n\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {},\n             json.dumps({'account': 'act', 'user': 'act:usr',\n                         'account_id': 'AUTH_cfa',\n                         'groups': [{'name': 'act:usr'}, {'name': 'act'}],\n                         'expires': time() + 60})),\n            ('204 No Content', {}, '')]), acl='act:usr')\n        req = Request.blank('/v1/AUTH_cfa/c',\n                            headers={'X-Auth-Token': 'AUTH_t'})\n        resp = req.get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 204)\n        self.assertEqual(owner_values, [False])\n\n    def test_sync_request_success(self):\n        self.test_auth.app = FakeApp(iter([('204 No Content', {}, '')]),\n                                     sync_key='secret')\n        req = Request.blank('/v1/AUTH_cfa/c/o',\n            environ={'REQUEST_METHOD': 'DELETE'},\n            headers={'x-container-sync-key': 'secret',\n                     'x-timestamp': '123.456'})\n        req.remote_addr = '127.0.0.1'\n        resp = req.get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 204)\n\n    def test_sync_request_fail_key(self):\n        self.test_auth.app = FakeApp(iter([('204 No Content', {}, '')]),\n                                     sync_key='secret')\n        req = Request.blank('/v1/AUTH_cfa/c/o',\n            environ={'REQUEST_METHOD': 'DELETE'},\n            headers={'x-container-sync-key': 'wrongsecret',\n                     'x-timestamp': '123.456'})\n        req.remote_addr = '127.0.0.1'\n        resp = req.get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n\n        self.test_auth.app = FakeApp(iter([('204 No Content', {}, '')]),\n                                     sync_key='othersecret')\n        req = Request.blank('/v1/AUTH_cfa/c/o',\n            environ={'REQUEST_METHOD': 'DELETE'},\n            headers={'x-container-sync-key': 'secret',\n                     'x-timestamp': '123.456'})\n        req.remote_addr = '127.0.0.1'\n        resp = req.get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n\n        self.test_auth.app = FakeApp(iter([('204 No Content', {}, '')]),\n                                     sync_key=None)\n        req = Request.blank('/v1/AUTH_cfa/c/o',\n            environ={'REQUEST_METHOD': 'DELETE'},\n            headers={'x-container-sync-key': 'secret',\n                     'x-timestamp': '123.456'})\n        req.remote_addr = '127.0.0.1'\n        resp = req.get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n\n    def test_sync_request_fail_no_timestamp(self):\n        self.test_auth.app = FakeApp(iter([('204 No Content', {}, '')]),\n                                     sync_key='secret')\n        req = Request.blank('/v1/AUTH_cfa/c/o',\n            environ={'REQUEST_METHOD': 'DELETE'},\n            headers={'x-container-sync-key': 'secret'})\n        req.remote_addr = '127.0.0.1'\n        resp = req.get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n\n    def test_sync_request_fail_sync_host(self):\n        self.test_auth.app = FakeApp(iter([('204 No Content', {}, '')]),\n                                     sync_key='secret')\n        req = Request.blank('/v1/AUTH_cfa/c/o',\n            environ={'REQUEST_METHOD': 'DELETE'},\n            headers={'x-container-sync-key': 'secret',\n                     'x-timestamp': '123.456'})\n        req.remote_addr = '127.0.0.2'\n        resp = req.get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n\n    def test_sync_request_success_lb_sync_host(self):\n        self.test_auth.app = FakeApp(iter([('204 No Content', {}, '')]),\n                                     sync_key='secret')\n        req = Request.blank('/v1/AUTH_cfa/c/o',\n            environ={'REQUEST_METHOD': 'DELETE'},\n            headers={'x-container-sync-key': 'secret',\n                     'x-timestamp': '123.456',\n                     'x-forwarded-for': '127.0.0.1'})\n        req.remote_addr = '127.0.0.2'\n        resp = req.get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 204)\n\n        self.test_auth.app = FakeApp(iter([('204 No Content', {}, '')]),\n                                     sync_key='secret')\n        req = Request.blank('/v1/AUTH_cfa/c/o',\n            environ={'REQUEST_METHOD': 'DELETE'},\n            headers={'x-container-sync-key': 'secret',\n                     'x-timestamp': '123.456',\n                     'x-cluster-client-ip': '127.0.0.1'})\n        req.remote_addr = '127.0.0.2'\n        resp = req.get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 204)\n\n    def _make_request(self, path, **kwargs):\n        req = Request.blank(path, **kwargs)\n        req.environ['swift.cache'] = FakeMemcache()\n        return req\n\n    def test_override_asked_for_but_not_allowed(self):\n        self.test_auth = \\\n            auth.filter_factory({'allow_overrides': 'false'})(FakeApp())\n        req = self._make_request('/v1/AUTH_account',\n                                 environ={'swift.authorize_override': True})\n        resp = req.get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n        self.assertEqual(resp.environ['swift.authorize'],\n                         self.test_auth.authorize)\n\n    def test_override_asked_for_and_allowed(self):\n        self.test_auth = \\\n            auth.filter_factory({'allow_overrides': 'true'})(FakeApp())\n        req = self._make_request('/v1/AUTH_account',\n                                 environ={'swift.authorize_override': True})\n        resp = req.get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 404)\n        self.assertTrue('swift.authorize' not in resp.environ)\n\n    def test_override_default_allowed(self):\n        req = self._make_request('/v1/AUTH_account',\n                                 environ={'swift.authorize_override': True})\n        resp = req.get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 404)\n        self.assertTrue('swift.authorize' not in resp.environ)\n\n    def test_token_too_long(self):\n        req = self._make_request('/v1/AUTH_account', headers={\n            'x-auth-token': 'a' * MAX_TOKEN_LENGTH})\n        resp = req.get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n        self.assertNotEqual(resp.body, 'Token exceeds maximum length.')\n        req = self._make_request('/v1/AUTH_account', headers={\n            'x-auth-token': 'a' * (MAX_TOKEN_LENGTH + 1)})\n        resp = req.get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 400)\n        self.assertEqual(resp.body, 'Token exceeds maximum length.')\n\n    def test_s3_enabled_when_conditions_are_met(self):\n        # auth_type_salt needs to be set\n        for atype in ('Sha1', 'Sha512'):\n            test_auth = \\\n                auth.filter_factory({\n                    'super_admin_key': 'supertest',\n                    's3_support': 'on',\n                    'auth_type_salt': 'blah',\n                    'auth_type': atype})(FakeApp())\n            self.assertTrue(test_auth.s3_support)\n        # auth_type_salt need not be set for Plaintext\n        test_auth = \\\n            auth.filter_factory({\n                'super_admin_key': 'supertest',\n                's3_support': 'on',\n                'auth_type': 'Plaintext'})(FakeApp())\n        self.assertTrue(test_auth.s3_support)\n\n    def test_s3_disabled_when_conditions_not_met(self):\n        # Conf says that it wants s3 support but other conditions are not met\n        # In that case s3 support should be disabled.\n        for atype in ('Sha1', 'Sha512'):\n            # auth_type_salt is not set\n            test_auth = \\\n                auth.filter_factory({\n                    'super_admin_key': 'supertest',\n                    's3_support': 'on',\n                    'auth_type': atype})(FakeApp())\n            self.assertFalse(test_auth.s3_support)\n\n    def test_s3_authorization_default_off(self):\n        self.assertFalse(self.test_auth.s3_support)\n        req = self._make_request('/v1/AUTH_account', headers={\n            'authorization': 's3_header'})\n        resp = req.get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 400)  # HTTPBadRequest\n        self.assertTrue(resp.environ.get('swift.authorize') is None)\n\n    def test_s3_turned_off_get_groups(self):\n        env = \\\n            {'HTTP_AUTHORIZATION': 's3 header'}\n        token = 'whatever'\n        self.test_auth.logger = mock.Mock()\n        self.assertEqual(self.test_auth.get_groups(env, token), None)\n\n    def test_default_storage_policy(self):\n        ath = auth.filter_factory({})(FakeApp())\n        self.assertEqual(ath.default_storage_policy, None)\n\n        ath = \\\n            auth.filter_factory({'default_storage_policy': 'ssd'})(FakeApp())\n        self.assertEqual(ath.default_storage_policy, 'ssd')\n\n    def test_s3_creds_unicode(self):\n        self.test_auth.s3_support = True\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {},\n             json.dumps({\"auth\": unicode(\"plaintext:key)\"),\n                         \"groups\": [{'name': \"act:usr\"}, {'name': \"act\"},\n                                    {'name': \".admin\"}]})),\n            ('204 Ok', {'X-Container-Meta-Account-Id': 'AUTH_act'}, '')]))\n        env = \\\n            {'HTTP_AUTHORIZATION': 'AWS act:user:3yW7oFFWOn+fhHMu7E47RKotL1Q=',\n             'PATH_INFO': '/v1/AUTH_act/c1'}\n        token = 'UFVUCgoKRnJpLCAyNiBGZWIgMjAxNiAwNjo0NT'\\\n                'ozNCArMDAwMAovY29udGFpbmVyMw=='\n        self.assertEqual(self.test_auth.get_groups(env, token), None)\n\n    def test_s3_only_hash_passed_to_hmac(self):\n        self.test_auth.s3_support = True\n        key = 'dadada'\n        salt = 'zuck'\n        key_hash = hashlib.sha1('%s%s' % (salt, key)).hexdigest()\n        auth_stored = \"sha1:%s$%s\" % (salt, key_hash)\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {},\n             json.dumps({\"auth\": auth_stored,\n                         \"groups\": [{'name': \"act:usr\"}, {'name': \"act\"},\n                                    {'name': \".admin\"}]})),\n            ('204 Ok', {'X-Container-Meta-Account-Id': 'AUTH_act'}, '')]))\n        env = \\\n            {'HTTP_AUTHORIZATION': 'AWS act:user:whatever',\n             'PATH_INFO': '/v1/AUTH_act/c1'}\n        token = 'UFVUCgoKRnJpLCAyNiBGZWIgMjAxNiAwNjo0NT'\\\n                'ozNCArMDAwMAovY29udGFpbmVyMw=='\n        mock_hmac_new = mock.MagicMock()\n        with mock.patch('hmac.new', mock_hmac_new):\n            self.test_auth.get_groups(env, token)\n        self.assertTrue(mock_hmac_new.called)\n        # Assert that string passed to hmac.new is only the hash\n        self.assertEqual(mock_hmac_new.call_args[0][0], key_hash)\n\n\nif __name__ == '__main__':\n    unittest.main()\n"], "fixing_code": ["# Copyright (c) 2010-2012 OpenStack, LLC.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n# implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport base64\nfrom hashlib import sha1\nfrom hashlib import sha512\nimport hmac\nfrom httplib import HTTPConnection\nfrom httplib import HTTPSConnection\nimport json\nimport swift\nfrom time import gmtime\nfrom time import strftime\nfrom time import time\nfrom traceback import format_exc\nfrom urllib import quote\nfrom urllib import unquote\nfrom uuid import uuid4\n\nfrom eventlet.timeout import Timeout\nfrom eventlet import TimeoutError\nfrom swift.common.swob import HTTPAccepted\nfrom swift.common.swob import HTTPBadRequest\nfrom swift.common.swob import HTTPConflict\nfrom swift.common.swob import HTTPCreated\nfrom swift.common.swob import HTTPForbidden\nfrom swift.common.swob import HTTPMethodNotAllowed\nfrom swift.common.swob import HTTPMovedPermanently\nfrom swift.common.swob import HTTPNoContent\nfrom swift.common.swob import HTTPNotFound\nfrom swift.common.swob import HTTPUnauthorized\nfrom swift.common.swob import Request\nfrom swift.common.swob import Response\n\nfrom swift.common.bufferedhttp import http_connect_raw as http_connect\nfrom swift.common.middleware.acl import clean_acl\nfrom swift.common.middleware.acl import parse_acl\nfrom swift.common.middleware.acl import referrer_allowed\nfrom swift.common.utils import cache_from_env\nfrom swift.common.utils import get_logger\nfrom swift.common.utils import get_remote_client\nfrom swift.common.utils import HASH_PATH_PREFIX\nfrom swift.common.utils import HASH_PATH_SUFFIX\nfrom swift.common.utils import split_path\nfrom swift.common.utils import TRUE_VALUES\nfrom swift.common.utils import urlparse\nimport swift.common.wsgi\n\nimport swauth.authtypes\nfrom swauth import swift_version\n\n\nSWIFT_MIN_VERSION = \"2.2.0\"\nCONTENT_TYPE_JSON = 'application/json'\n\n\nclass Swauth(object):\n    \"\"\"Scalable authentication and authorization system that uses Swift as its\n    backing store.\n\n    :param app: The next WSGI app in the pipeline\n    :param conf: The dict of configuration values\n    \"\"\"\n\n    def __init__(self, app, conf):\n        self.app = app\n        self.conf = conf\n        self.logger = get_logger(conf, log_route='swauth')\n        if not swift_version.at_least(SWIFT_MIN_VERSION):\n            msg = (\"Your Swift installation is too old (%s). You need at \"\n                   \"least %s.\" % (swift.__version__, SWIFT_MIN_VERSION))\n            self.logger.critical(msg)\n            raise ValueError(msg)\n        self.log_headers = conf.get('log_headers', 'no').lower() in TRUE_VALUES\n        self.reseller_prefix = conf.get('reseller_prefix', 'AUTH').strip()\n        if self.reseller_prefix and self.reseller_prefix[-1] != '_':\n            self.reseller_prefix += '_'\n        self.auth_prefix = conf.get('auth_prefix', '/auth/')\n        if not self.auth_prefix:\n            self.auth_prefix = '/auth/'\n        if self.auth_prefix[0] != '/':\n            self.auth_prefix = '/' + self.auth_prefix\n        if self.auth_prefix[-1] != '/':\n            self.auth_prefix += '/'\n        self.swauth_remote = conf.get('swauth_remote')\n        if self.swauth_remote:\n            self.swauth_remote = self.swauth_remote.rstrip('/')\n            if not self.swauth_remote:\n                msg = _('Invalid swauth_remote set in conf file! Exiting.')\n                self.logger.critical(msg)\n                raise ValueError(msg)\n            self.swauth_remote_parsed = urlparse(self.swauth_remote)\n            if self.swauth_remote_parsed.scheme not in ('http', 'https'):\n                msg = _('Cannot handle protocol scheme %(schema)s '\n                        'for url %(url)s!') % \\\n                   (self.swauth_remote_parsed.scheme, repr(self.swauth_remote))\n                self.logger.critical(msg)\n                raise ValueError(msg)\n        self.swauth_remote_timeout = int(conf.get('swauth_remote_timeout', 10))\n        self.auth_account = '%s.auth' % self.reseller_prefix\n        self.default_swift_cluster = conf.get('default_swift_cluster',\n            'local#http://127.0.0.1:8080/v1')\n        # This setting is a little messy because of the options it has to\n        # provide. The basic format is cluster_name#url, such as the default\n        # value of local#http://127.0.0.1:8080/v1.\n        # If the URL given to the user needs to differ from the url used by\n        # Swauth to create/delete accounts, there's a more complex format:\n        # cluster_name#url#url, such as\n        # local#https://public.com:8080/v1#http://private.com:8080/v1.\n        cluster_parts = self.default_swift_cluster.split('#', 2)\n        self.dsc_name = cluster_parts[0]\n        if len(cluster_parts) == 3:\n            self.dsc_url = cluster_parts[1].rstrip('/')\n            self.dsc_url2 = cluster_parts[2].rstrip('/')\n        elif len(cluster_parts) == 2:\n            self.dsc_url = self.dsc_url2 = cluster_parts[1].rstrip('/')\n        else:\n            raise ValueError('Invalid cluster format')\n        self.dsc_parsed = urlparse(self.dsc_url)\n        if self.dsc_parsed.scheme not in ('http', 'https'):\n            raise ValueError('Cannot handle protocol scheme %s for url %s' %\n                             (self.dsc_parsed.scheme, repr(self.dsc_url)))\n        self.dsc_parsed2 = urlparse(self.dsc_url2)\n        if self.dsc_parsed2.scheme not in ('http', 'https'):\n            raise ValueError('Cannot handle protocol scheme %s for url %s' %\n                             (self.dsc_parsed2.scheme, repr(self.dsc_url2)))\n        self.super_admin_key = conf.get('super_admin_key')\n        if not self.super_admin_key and not self.swauth_remote:\n            msg = _('No super_admin_key set in conf file; Swauth '\n                    'administration features will be disabled.')\n            self.logger.warning(msg)\n        self.token_life = int(conf.get('token_life', 86400))\n        self.max_token_life = int(conf.get('max_token_life', self.token_life))\n        self.timeout = int(conf.get('node_timeout', 10))\n        self.itoken = None\n        self.itoken_expires = None\n        self.allowed_sync_hosts = [h.strip()\n            for h in conf.get('allowed_sync_hosts', '127.0.0.1').split(',')\n            if h.strip()]\n        # Get an instance of our auth_type encoder for saving and checking the\n        # user's key\n        self.auth_type = conf.get('auth_type', 'Plaintext').title()\n        self.auth_encoder = getattr(swauth.authtypes, self.auth_type, None)\n        if self.auth_encoder is None:\n            raise ValueError('Invalid auth_type in config file: %s'\n                             % self.auth_type)\n        # If auth_type_salt is not set in conf file, a random salt will be\n        # generated for each new password to be encoded.\n        self.auth_encoder.salt = conf.get('auth_type_salt', None)\n\n        # Due to security concerns, S3 support is disabled by default.\n        self.s3_support = conf.get('s3_support', 'off').lower() in TRUE_VALUES\n        if self.s3_support and self.auth_type != 'Plaintext' \\\n                and not self.auth_encoder.salt:\n            msg = _('S3 support requires salt to be manually set in conf '\n                    'file using auth_type_salt config option.')\n            self.logger.warning(msg)\n            self.s3_support = False\n\n        self.allow_overrides = \\\n            conf.get('allow_overrides', 't').lower() in TRUE_VALUES\n        self.agent = '%(orig)s Swauth'\n        self.swift_source = 'SWTH'\n        self.default_storage_policy = conf.get('default_storage_policy', None)\n\n    def make_pre_authed_request(self, env, method=None, path=None, body=None,\n                                headers=None):\n        \"\"\"Nearly the same as swift.common.wsgi.make_pre_authed_request\n        except that this also always sets the 'swift.source' and user\n        agent.\n\n        Newer Swift code will support swift_source as a kwarg, but we\n        do it this way so we don't have to have a newer Swift.\n\n        Since we're doing this anyway, we may as well set the user\n        agent too since we always do that.\n        \"\"\"\n        if self.default_storage_policy:\n            sp = self.default_storage_policy\n            if headers:\n                headers.update({'X-Storage-Policy': sp})\n            else:\n                headers = {'X-Storage-Policy': sp}\n        subreq = swift.common.wsgi.make_pre_authed_request(\n            env, method=method, path=path, body=body, headers=headers,\n            agent=self.agent)\n        subreq.environ['swift.source'] = self.swift_source\n        return subreq\n\n    def __call__(self, env, start_response):\n        \"\"\"Accepts a standard WSGI application call, authenticating the request\n        and installing callback hooks for authorization and ACL header\n        validation. For an authenticated request, REMOTE_USER will be set to a\n        comma separated list of the user's groups.\n\n        With a non-empty reseller prefix, acts as the definitive auth service\n        for just tokens and accounts that begin with that prefix, but will deny\n        requests outside this prefix if no other auth middleware overrides it.\n\n        With an empty reseller prefix, acts as the definitive auth service only\n        for tokens that validate to a non-empty set of groups. For all other\n        requests, acts as the fallback auth service when no other auth\n        middleware overrides it.\n\n        Alternatively, if the request matches the self.auth_prefix, the request\n        will be routed through the internal auth request handler (self.handle).\n        This is to handle creating users, accounts, granting tokens, etc.\n        \"\"\"\n        if 'keystone.identity' in env:\n            return self.app(env, start_response)\n        # We're going to consider OPTIONS requests harmless and the CORS\n        # support in the Swift proxy needs to get them.\n        if env.get('REQUEST_METHOD') == 'OPTIONS':\n            return self.app(env, start_response)\n        if self.allow_overrides and env.get('swift.authorize_override', False):\n            return self.app(env, start_response)\n        if not self.swauth_remote:\n            if env.get('PATH_INFO', '') == self.auth_prefix[:-1]:\n                return HTTPMovedPermanently(add_slash=True)(env,\n                                                            start_response)\n            elif env.get('PATH_INFO', '').startswith(self.auth_prefix):\n                return self.handle(env, start_response)\n        s3 = env.get('HTTP_AUTHORIZATION')\n        if s3 and not self.s3_support:\n            msg = 'S3 support is disabled in swauth.'\n            return HTTPBadRequest(body=msg)(env, start_response)\n        token = env.get('HTTP_X_AUTH_TOKEN', env.get('HTTP_X_STORAGE_TOKEN'))\n        if token and len(token) > swauth.authtypes.MAX_TOKEN_LENGTH:\n            return HTTPBadRequest(body='Token exceeds maximum length.')(env,\n                                                                start_response)\n        if s3 or (token and token.startswith(self.reseller_prefix)):\n            # Note: Empty reseller_prefix will match all tokens.\n            groups = self.get_groups(env, token)\n            if groups:\n                env['REMOTE_USER'] = groups\n                user = groups and groups.split(',', 1)[0] or ''\n                # We know the proxy logs the token, so we augment it just a bit\n                # to also log the authenticated user.\n                env['HTTP_X_AUTH_TOKEN'] = \\\n                    '%s,%s' % (user, 's3' if s3 else token)\n                env['swift.authorize'] = self.authorize\n                env['swift.clean_acl'] = clean_acl\n                if '.reseller_admin' in groups:\n                    env['reseller_request'] = True\n            else:\n                # Unauthorized token\n                if self.reseller_prefix and token and \\\n                        token.startswith(self.reseller_prefix):\n                    # Because I know I'm the definitive auth for this token, I\n                    # can deny it outright.\n                    return HTTPUnauthorized()(env, start_response)\n                # Because I'm not certain if I'm the definitive auth, I won't\n                # overwrite swift.authorize and I'll just set a delayed denial\n                # if nothing else overrides me.\n                elif 'swift.authorize' not in env:\n                    env['swift.authorize'] = self.denied_response\n        else:\n            if self.reseller_prefix:\n                # With a non-empty reseller_prefix, I would like to be called\n                # back for anonymous access to accounts I know I'm the\n                # definitive auth for.\n                try:\n                    version, rest = split_path(env.get('PATH_INFO', ''),\n                                               1, 2, True)\n                except ValueError:\n                    rest = None\n                if rest and rest.startswith(self.reseller_prefix):\n                    # Handle anonymous access to accounts I'm the definitive\n                    # auth for.\n                    env['swift.authorize'] = self.authorize\n                    env['swift.clean_acl'] = clean_acl\n                # Not my token, not my account, I can't authorize this request,\n                # deny all is a good idea if not already set...\n                elif 'swift.authorize' not in env:\n                    env['swift.authorize'] = self.denied_response\n            # Because I'm not certain if I'm the definitive auth for empty\n            # reseller_prefixed accounts, I won't overwrite swift.authorize.\n            elif 'swift.authorize' not in env:\n                env['swift.authorize'] = self.authorize\n                env['swift.clean_acl'] = clean_acl\n        return self.app(env, start_response)\n\n    def _get_concealed_token(self, token):\n        \"\"\"Returns hashed token to be used as object name in Swift.\n\n        Tokens are stored in auth account but object names are visible in Swift\n        logs. Object names are hashed from token.\n        \"\"\"\n        enc_key = \"%s:%s:%s\" % (HASH_PATH_PREFIX, token, HASH_PATH_SUFFIX)\n        return sha512(enc_key).hexdigest()\n\n    def get_groups(self, env, token):\n        \"\"\"Get groups for the given token.\n\n        :param env: The current WSGI environment dictionary.\n        :param token: Token to validate and return a group string for.\n\n        :returns: None if the token is invalid or a string containing a comma\n                  separated list of groups the authenticated user is a member\n                  of. The first group in the list is also considered a unique\n                  identifier for that user.\n        \"\"\"\n        groups = None\n        memcache_client = cache_from_env(env)\n        if memcache_client:\n            memcache_key = '%s/auth/%s' % (self.reseller_prefix, token)\n            cached_auth_data = memcache_client.get(memcache_key)\n            if cached_auth_data:\n                expires, groups = cached_auth_data\n                if expires < time():\n                    groups = None\n\n        if env.get('HTTP_AUTHORIZATION'):\n            if not self.s3_support:\n                self.logger.warning('S3 support is disabled in swauth.')\n                return None\n            if self.swauth_remote:\n                # TODO(gholt): Support S3-style authorization with\n                # swauth_remote mode\n                self.logger.warning('S3-style authorization not supported yet '\n                                 'with swauth_remote mode.')\n                return None\n            try:\n                account = env['HTTP_AUTHORIZATION'].split(' ')[1]\n                account, user, sign = account.split(':')\n            except Exception:\n                self.logger.debug(\n                    'Swauth cannot parse Authorization header value %r' %\n                    env['HTTP_AUTHORIZATION'])\n                return None\n            path = quote('/v1/%s/%s/%s' % (self.auth_account, account, user))\n            resp = self.make_pre_authed_request(\n                env, 'GET', path).get_response(self.app)\n            if resp.status_int // 100 != 2:\n                return None\n\n            if 'x-object-meta-account-id' in resp.headers:\n                account_id = resp.headers['x-object-meta-account-id']\n            else:\n                path = quote('/v1/%s/%s' % (self.auth_account, account))\n                resp2 = self.make_pre_authed_request(\n                    env, 'HEAD', path).get_response(self.app)\n                if resp2.status_int // 100 != 2:\n                    return None\n                account_id = resp2.headers['x-container-meta-account-id']\n\n            path = env['PATH_INFO']\n            env['PATH_INFO'] = path.replace(\"%s:%s\" % (account, user),\n                                            account_id, 1)\n            detail = json.loads(resp.body)\n            if detail:\n                creds = detail.get('auth')\n                try:\n                    auth_encoder, creds_dict = \\\n                        swauth.authtypes.validate_creds(creds)\n                except ValueError as e:\n                    self.logger.error('%s' % e.args[0])\n                    return None\n\n            password = creds_dict['hash']\n            msg = base64.urlsafe_b64decode(unquote(token))\n\n            # https://bugs.python.org/issue5285\n            if isinstance(password, unicode):\n                password = password.encode('utf-8')\n            if isinstance(msg, unicode):\n                msg = msg.encode('utf-8')\n\n            s = base64.encodestring(hmac.new(password,\n                                             msg, sha1).digest()).strip()\n            if s != sign:\n                return None\n            groups = [g['name'] for g in detail['groups']]\n            if '.admin' in groups:\n                groups.remove('.admin')\n                groups.append(account_id)\n            groups = ','.join(groups)\n            return groups\n\n        if not groups:\n            if self.swauth_remote:\n                with Timeout(self.swauth_remote_timeout):\n                    conn = http_connect(self.swauth_remote_parsed.hostname,\n                        self.swauth_remote_parsed.port, 'GET',\n                        '%s/v2/.token/%s' % (self.swauth_remote_parsed.path,\n                                             quote(token)),\n                        ssl=(self.swauth_remote_parsed.scheme == 'https'))\n                    resp = conn.getresponse()\n                    resp.read()\n                    conn.close()\n                if resp.status // 100 != 2:\n                    return None\n                expires_from_now = float(resp.getheader('x-auth-ttl'))\n                groups = resp.getheader('x-auth-groups')\n                if memcache_client:\n                    memcache_client.set(\n                        memcache_key, (time() + expires_from_now, groups),\n                        time=expires_from_now)\n            else:\n                object_name = self._get_concealed_token(token)\n                path = quote('/v1/%s/.token_%s/%s' %\n                             (self.auth_account, object_name[-1], object_name))\n                resp = self.make_pre_authed_request(\n                    env, 'GET', path).get_response(self.app)\n                if resp.status_int // 100 != 2:\n                    return None\n                detail = json.loads(resp.body)\n                if detail['expires'] < time():\n                    self.make_pre_authed_request(\n                        env, 'DELETE', path).get_response(self.app)\n                    return None\n                groups = [g['name'] for g in detail['groups']]\n                if '.admin' in groups:\n                    groups.remove('.admin')\n                    groups.append(detail['account_id'])\n                groups = ','.join(groups)\n                if memcache_client:\n                    memcache_client.set(\n                        memcache_key,\n                        (detail['expires'], groups),\n                        time=float(detail['expires'] - time()))\n        return groups\n\n    def authorize(self, req):\n        \"\"\"Returns None if the request is authorized to continue or a standard\n        WSGI response callable if not.\n        \"\"\"\n        try:\n            version, account, container, obj = split_path(req.path, 1, 4, True)\n        except ValueError:\n            return HTTPNotFound(request=req)\n        if not account or not account.startswith(self.reseller_prefix):\n            return self.denied_response(req)\n        user_groups = (req.remote_user or '').split(',')\n        if '.reseller_admin' in user_groups and \\\n                account != self.reseller_prefix and \\\n                account[len(self.reseller_prefix)] != '.':\n            req.environ['swift_owner'] = True\n            return None\n        if account in user_groups and \\\n                (req.method not in ('DELETE', 'PUT') or container):\n            # If the user is admin for the account and is not trying to do an\n            # account DELETE or PUT...\n            req.environ['swift_owner'] = True\n            return None\n        if (req.environ.get('swift_sync_key') and\n            req.environ['swift_sync_key'] ==\n                req.headers.get('x-container-sync-key', None) and\n            'x-timestamp' in req.headers and\n            (req.remote_addr in self.allowed_sync_hosts or\n             get_remote_client(req) in self.allowed_sync_hosts)):\n            return None\n        referrers, groups = parse_acl(getattr(req, 'acl', None))\n        if referrer_allowed(req.referer, referrers):\n            if obj or '.rlistings' in groups:\n                return None\n            return self.denied_response(req)\n        if not req.remote_user:\n            return self.denied_response(req)\n        for user_group in user_groups:\n            if user_group in groups:\n                return None\n        return self.denied_response(req)\n\n    def denied_response(self, req):\n        \"\"\"Returns a standard WSGI response callable with the status of 403 or 401\n        depending on whether the REMOTE_USER is set or not.\n        \"\"\"\n        if not hasattr(req, 'credentials_valid'):\n            req.credentials_valid = None\n        if req.remote_user or req.credentials_valid:\n            return HTTPForbidden(request=req)\n        else:\n            return HTTPUnauthorized(request=req)\n\n    def handle(self, env, start_response):\n        \"\"\"WSGI entry point for auth requests (ones that match the\n        self.auth_prefix).\n        Wraps env in swob.Request object and passes it down.\n\n        :param env: WSGI environment dictionary\n        :param start_response: WSGI callable\n        \"\"\"\n        try:\n            req = Request(env)\n            if self.auth_prefix:\n                req.path_info_pop()\n            req.bytes_transferred = '-'\n            req.client_disconnect = False\n            if 'x-storage-token' in req.headers and \\\n                    'x-auth-token' not in req.headers:\n                req.headers['x-auth-token'] = req.headers['x-storage-token']\n            if 'eventlet.posthooks' in env:\n                env['eventlet.posthooks'].append(\n                    (self.posthooklogger, (req,), {}))\n                return self.handle_request(req)(env, start_response)\n            else:\n                # Lack of posthook support means that we have to log on the\n                # start of the response, rather than after all the data has\n                # been sent. This prevents logging client disconnects\n                # differently than full transmissions.\n                response = self.handle_request(req)(env, start_response)\n                self.posthooklogger(env, req)\n                return response\n        except (Exception, TimeoutError):\n            print(\"EXCEPTION IN handle: %s: %s\" % (format_exc(), env))\n            start_response('500 Server Error',\n                           [('Content-Type', 'text/plain')])\n            return ['Internal server error.\\n']\n\n    def handle_request(self, req):\n        \"\"\"Entry point for auth requests (ones that match the self.auth_prefix).\n        Should return a WSGI-style callable (such as swob.Response).\n\n        :param req: swob.Request object\n        \"\"\"\n        req.start_time = time()\n        handler = None\n        try:\n            version, account, user, _junk = split_path(req.path_info,\n                minsegs=0, maxsegs=4, rest_with_last=True)\n        except ValueError:\n            return HTTPNotFound(request=req)\n        if version in ('v1', 'v1.0', 'auth'):\n            if req.method == 'GET':\n                handler = self.handle_get_token\n        elif version == 'v2':\n            if not self.super_admin_key:\n                return HTTPNotFound(request=req)\n            req.path_info_pop()\n            if req.method == 'GET':\n                if not account and not user:\n                    handler = self.handle_get_reseller\n                elif account:\n                    if not user:\n                        handler = self.handle_get_account\n                    elif account == '.token':\n                        req.path_info_pop()\n                        handler = self.handle_validate_token\n                    else:\n                        handler = self.handle_get_user\n            elif req.method == 'PUT':\n                if not user:\n                    handler = self.handle_put_account\n                else:\n                    handler = self.handle_put_user\n            elif req.method == 'DELETE':\n                if not user:\n                    handler = self.handle_delete_account\n                else:\n                    handler = self.handle_delete_user\n            elif req.method == 'POST':\n                if account == '.prep':\n                    handler = self.handle_prep\n                elif user == '.services':\n                    handler = self.handle_set_services\n        else:\n            handler = self.handle_webadmin\n        if not handler:\n            req.response = HTTPBadRequest(request=req)\n        else:\n            req.response = handler(req)\n        return req.response\n\n    def handle_webadmin(self, req):\n        if req.method not in ('GET', 'HEAD'):\n            return HTTPMethodNotAllowed(request=req)\n        subpath = req.path[len(self.auth_prefix):] or 'index.html'\n        path = quote('/v1/%s/.webadmin/%s' % (self.auth_account, subpath))\n        req.response = self.make_pre_authed_request(\n            req.environ, req.method, path).get_response(self.app)\n        return req.response\n\n    def handle_prep(self, req):\n        \"\"\"Handles the POST v2/.prep call for preparing the backing store Swift\n        cluster for use with the auth subsystem. Can only be called by\n        .super_admin.\n\n        :param req: The swob.Request to process.\n        :returns: swob.Response, 204 on success\n        \"\"\"\n        if not self.is_super_admin(req):\n            return self.denied_response(req)\n        path = quote('/v1/%s' % self.auth_account)\n        resp = self.make_pre_authed_request(\n            req.environ, 'PUT', path).get_response(self.app)\n        if resp.status_int // 100 != 2:\n            raise Exception('Could not create the main auth account: %s %s' %\n                            (path, resp.status))\n        path = quote('/v1/%s/.account_id' % self.auth_account)\n        resp = self.make_pre_authed_request(\n            req.environ, 'PUT', path).get_response(self.app)\n        if resp.status_int // 100 != 2:\n            raise Exception('Could not create container: %s %s' %\n                            (path, resp.status))\n        for container in xrange(16):\n            path = quote('/v1/%s/.token_%x' % (self.auth_account, container))\n            resp = self.make_pre_authed_request(\n                req.environ, 'PUT', path).get_response(self.app)\n            if resp.status_int // 100 != 2:\n                raise Exception('Could not create container: %s %s' %\n                                (path, resp.status))\n        return HTTPNoContent(request=req)\n\n    def handle_get_reseller(self, req):\n        \"\"\"Handles the GET v2 call for getting general reseller information\n        (currently just a list of accounts). Can only be called by a\n        .reseller_admin.\n\n        On success, a JSON dictionary will be returned with a single `accounts`\n        key whose value is list of dicts. Each dict represents an account and\n        currently only contains the single key `name`. For example::\n\n            {\"accounts\": [{\"name\": \"reseller\"}, {\"name\": \"test\"},\n                          {\"name\": \"test2\"}]}\n\n        :param req: The swob.Request to process.\n        :returns: swob.Response, 2xx on success with a JSON dictionary as\n                  explained above.\n        \"\"\"\n        if not self.is_reseller_admin(req):\n            return self.denied_response(req)\n        listing = []\n        marker = ''\n        while True:\n            path = '/v1/%s?format=json&marker=%s' % (quote(self.auth_account),\n                                                     quote(marker))\n            resp = self.make_pre_authed_request(\n                req.environ, 'GET', path).get_response(self.app)\n            if resp.status_int // 100 != 2:\n                raise Exception('Could not list main auth account: %s %s' %\n                                (path, resp.status))\n            sublisting = json.loads(resp.body)\n            if not sublisting:\n                break\n            for container in sublisting:\n                if container['name'][0] != '.':\n                    listing.append({'name': container['name']})\n            marker = sublisting[-1]['name'].encode('utf-8')\n        return Response(body=json.dumps({'accounts': listing}),\n                        content_type=CONTENT_TYPE_JSON)\n\n    def handle_get_account(self, req):\n        \"\"\"Handles the GET v2/<account> call for getting account information.\n        Can only be called by an account .admin.\n\n        On success, a JSON dictionary will be returned containing the keys\n        `account_id`, `services`, and `users`. The `account_id` is the value\n        used when creating service accounts. The `services` value is a dict as\n        described in the :func:`handle_get_token` call. The `users` value is a\n        list of dicts, each dict representing a user and currently only\n        containing the single key `name`. For example::\n\n             {\"account_id\": \"AUTH_018c3946-23f8-4efb-a8fb-b67aae8e4162\",\n              \"services\": {\"storage\": {\"default\": \"local\",\n                           \"local\": \"http://127.0.0.1:8080/v1/AUTH_018c3946\"}},\n              \"users\": [{\"name\": \"tester\"}, {\"name\": \"tester3\"}]}\n\n        :param req: The swob.Request to process.\n        :returns: swob.Response, 2xx on success with a JSON dictionary as\n                  explained above.\n        \"\"\"\n        account = req.path_info_pop()\n        if req.path_info or not account or account[0] == '.':\n            return HTTPBadRequest(request=req)\n        if not self.is_account_admin(req, account):\n            return self.denied_response(req)\n        path = quote('/v1/%s/%s/.services' % (self.auth_account, account))\n        resp = self.make_pre_authed_request(\n            req.environ, 'GET', path).get_response(self.app)\n        if resp.status_int == 404:\n            return HTTPNotFound(request=req)\n        if resp.status_int // 100 != 2:\n            raise Exception('Could not obtain the .services object: %s %s' %\n                            (path, resp.status))\n        services = json.loads(resp.body)\n        listing = []\n        marker = ''\n        while True:\n            path = '/v1/%s?format=json&marker=%s' % (quote('%s/%s' %\n                (self.auth_account, account)), quote(marker))\n            resp = self.make_pre_authed_request(\n                req.environ, 'GET', path).get_response(self.app)\n            if resp.status_int == 404:\n                return HTTPNotFound(request=req)\n            if resp.status_int // 100 != 2:\n                raise Exception('Could not list in main auth account: %s %s' %\n                                (path, resp.status))\n            account_id = resp.headers['X-Container-Meta-Account-Id']\n            sublisting = json.loads(resp.body)\n            if not sublisting:\n                break\n            for obj in sublisting:\n                if obj['name'][0] != '.':\n                    listing.append({'name': obj['name']})\n            marker = sublisting[-1]['name'].encode('utf-8')\n        return Response(content_type=CONTENT_TYPE_JSON,\n                        body=json.dumps({'account_id': account_id,\n                                         'services': services,\n                                         'users': listing}))\n\n    def handle_set_services(self, req):\n        \"\"\"Handles the POST v2/<account>/.services call for setting services\n        information. Can only be called by a reseller .admin.\n\n        In the :func:`handle_get_account` (GET v2/<account>) call, a section of\n        the returned JSON dict is `services`. This section looks something like\n        this::\n\n              \"services\": {\"storage\": {\"default\": \"local\",\n                            \"local\": \"http://127.0.0.1:8080/v1/AUTH_018c3946\"}}\n\n        Making use of this section is described in :func:`handle_get_token`.\n\n        This function allows setting values within this section for the\n        <account>, allowing the addition of new service end points or updating\n        existing ones.\n\n        The body of the POST request should contain a JSON dict with the\n        following format::\n\n            {\"service_name\": {\"end_point_name\": \"end_point_value\"}}\n\n        There can be multiple services and multiple end points in the same\n        call.\n\n        Any new services or end points will be added to the existing set of\n        services and end points. Any existing services with the same service\n        name will be merged with the new end points. Any existing end points\n        with the same end point name will have their values updated.\n\n        The updated services dictionary will be returned on success.\n\n        :param req: The swob.Request to process.\n        :returns: swob.Response, 2xx on success with the udpated services JSON\n                  dict as described above\n        \"\"\"\n        if not self.is_reseller_admin(req):\n            return self.denied_response(req)\n        account = req.path_info_pop()\n        if req.path_info != '/.services' or not account or account[0] == '.':\n            return HTTPBadRequest(request=req)\n        try:\n            new_services = json.loads(req.body)\n        except ValueError as err:\n            return HTTPBadRequest(body=str(err))\n        # Get the current services information\n        path = quote('/v1/%s/%s/.services' % (self.auth_account, account))\n        resp = self.make_pre_authed_request(\n            req.environ, 'GET', path).get_response(self.app)\n        if resp.status_int == 404:\n            return HTTPNotFound(request=req)\n        if resp.status_int // 100 != 2:\n            raise Exception('Could not obtain services info: %s %s' %\n                            (path, resp.status))\n        services = json.loads(resp.body)\n        for new_service, value in new_services.iteritems():\n            if new_service in services:\n                services[new_service].update(value)\n            else:\n                services[new_service] = value\n        # Save the new services information\n        services = json.dumps(services)\n        resp = self.make_pre_authed_request(\n            req.environ, 'PUT', path, services).get_response(self.app)\n        if resp.status_int // 100 != 2:\n            raise Exception('Could not save .services object: %s %s' %\n                            (path, resp.status))\n        return Response(request=req, body=services,\n                        content_type=CONTENT_TYPE_JSON)\n\n    def handle_put_account(self, req):\n        \"\"\"Handles the PUT v2/<account> call for adding an account to the auth\n        system. Can only be called by a .reseller_admin.\n\n        By default, a newly created UUID4 will be used with the reseller prefix\n        as the account id used when creating corresponding service accounts.\n        However, you can provide an X-Account-Suffix header to replace the\n        UUID4 part.\n\n        :param req: The swob.Request to process.\n        :returns: swob.Response, 2xx on success.\n        \"\"\"\n        if not self.is_reseller_admin(req):\n            return self.denied_response(req)\n        account = req.path_info_pop()\n        if req.path_info or not account or account[0] == '.':\n            return HTTPBadRequest(request=req)\n\n        account_suffix = req.headers.get('x-account-suffix')\n        if not account_suffix:\n            account_suffix = str(uuid4())\n        # Create the new account in the Swift cluster\n        path = quote('%s/%s%s' % (self.dsc_parsed2.path,\n                                  self.reseller_prefix, account_suffix))\n        try:\n            conn = self.get_conn()\n            conn.request('PUT', path,\n                        headers={'X-Auth-Token': self.get_itoken(req.environ),\n                                 'Content-Length': '0'})\n            resp = conn.getresponse()\n            resp.read()\n            if resp.status // 100 != 2:\n                raise Exception('Could not create account on the Swift '\n                    'cluster: %s %s %s' % (path, resp.status, resp.reason))\n        except (Exception, TimeoutError):\n            self.logger.error(_('ERROR: Exception while trying to communicate '\n                'with %(scheme)s://%(host)s:%(port)s/%(path)s'),\n                {'scheme': self.dsc_parsed2.scheme,\n                 'host': self.dsc_parsed2.hostname,\n                 'port': self.dsc_parsed2.port, 'path': path})\n            raise\n        # Ensure the container in the main auth account exists (this\n        # container represents the new account)\n        path = quote('/v1/%s/%s' % (self.auth_account, account))\n        resp = self.make_pre_authed_request(\n            req.environ, 'HEAD', path).get_response(self.app)\n        if resp.status_int == 404:\n            resp = self.make_pre_authed_request(\n                req.environ, 'PUT', path).get_response(self.app)\n            if resp.status_int // 100 != 2:\n                raise Exception('Could not create account within main auth '\n                    'account: %s %s' % (path, resp.status))\n        elif resp.status_int // 100 == 2:\n            if 'x-container-meta-account-id' in resp.headers:\n                # Account was already created\n                return HTTPAccepted(request=req)\n        else:\n            raise Exception('Could not verify account within main auth '\n                'account: %s %s' % (path, resp.status))\n        # Record the mapping from account id back to account name\n        path = quote('/v1/%s/.account_id/%s%s' %\n                     (self.auth_account, self.reseller_prefix, account_suffix))\n        resp = self.make_pre_authed_request(\n            req.environ, 'PUT', path, account).get_response(self.app)\n        if resp.status_int // 100 != 2:\n            raise Exception('Could not create account id mapping: %s %s' %\n                            (path, resp.status))\n        # Record the cluster url(s) for the account\n        path = quote('/v1/%s/%s/.services' % (self.auth_account, account))\n        services = {'storage': {}}\n        services['storage'][self.dsc_name] = '%s/%s%s' % (self.dsc_url,\n            self.reseller_prefix, account_suffix)\n        services['storage']['default'] = self.dsc_name\n        resp = self.make_pre_authed_request(\n            req.environ, 'PUT', path,\n            json.dumps(services)).get_response(self.app)\n        if resp.status_int // 100 != 2:\n            raise Exception('Could not create .services object: %s %s' %\n                            (path, resp.status))\n        # Record the mapping from account name to the account id\n        path = quote('/v1/%s/%s' % (self.auth_account, account))\n        resp = self.make_pre_authed_request(\n            req.environ, 'POST', path,\n            headers={'X-Container-Meta-Account-Id': '%s%s' % (\n                self.reseller_prefix, account_suffix)}).get_response(self.app)\n        if resp.status_int // 100 != 2:\n            raise Exception('Could not record the account id on the account: '\n                            '%s %s' % (path, resp.status))\n        return HTTPCreated(request=req)\n\n    def handle_delete_account(self, req):\n        \"\"\"Handles the DELETE v2/<account> call for removing an account from the\n        auth system. Can only be called by a .reseller_admin.\n\n        :param req: The swob.Request to process.\n        :returns: swob.Response, 2xx on success.\n        \"\"\"\n        if not self.is_reseller_admin(req):\n            return self.denied_response(req)\n        account = req.path_info_pop()\n        if req.path_info or not account or account[0] == '.':\n            return HTTPBadRequest(request=req)\n        # Make sure the account has no users and get the account_id\n        marker = ''\n        while True:\n            path = '/v1/%s?format=json&marker=%s' % (quote('%s/%s' %\n                (self.auth_account, account)), quote(marker))\n            resp = self.make_pre_authed_request(\n                req.environ, 'GET', path).get_response(self.app)\n            if resp.status_int == 404:\n                return HTTPNotFound(request=req)\n            if resp.status_int // 100 != 2:\n                raise Exception('Could not list in main auth account: %s %s' %\n                                (path, resp.status))\n            account_id = resp.headers['x-container-meta-account-id']\n            sublisting = json.loads(resp.body)\n            if not sublisting:\n                break\n            for obj in sublisting:\n                if obj['name'][0] != '.':\n                    return HTTPConflict(request=req)\n            marker = sublisting[-1]['name'].encode('utf-8')\n        # Obtain the listing of services the account is on.\n        path = quote('/v1/%s/%s/.services' % (self.auth_account, account))\n        resp = self.make_pre_authed_request(\n            req.environ, 'GET', path).get_response(self.app)\n        if resp.status_int // 100 != 2 and resp.status_int != 404:\n            raise Exception('Could not obtain .services object: %s %s' %\n                            (path, resp.status))\n        if resp.status_int // 100 == 2:\n            services = json.loads(resp.body)\n            # Delete the account on each cluster it is on.\n            deleted_any = False\n            for name, url in services['storage'].iteritems():\n                if name != 'default':\n                    parsed = urlparse(url)\n                    conn = self.get_conn(parsed)\n                    conn.request('DELETE', parsed.path,\n                        headers={'X-Auth-Token': self.get_itoken(req.environ)})\n                    resp = conn.getresponse()\n                    resp.read()\n                    if resp.status == 409:\n                        if deleted_any:\n                            raise Exception('Managed to delete one or more '\n                                'service end points, but failed with: '\n                                '%s %s %s' % (url, resp.status, resp.reason))\n                        else:\n                            return HTTPConflict(request=req)\n                    if resp.status // 100 != 2 and resp.status != 404:\n                        raise Exception('Could not delete account on the '\n                            'Swift cluster: %s %s %s' %\n                            (url, resp.status, resp.reason))\n                    deleted_any = True\n            # Delete the .services object itself.\n            path = quote('/v1/%s/%s/.services' %\n                         (self.auth_account, account))\n            resp = self.make_pre_authed_request(\n                req.environ, 'DELETE', path).get_response(self.app)\n            if resp.status_int // 100 != 2 and resp.status_int != 404:\n                raise Exception('Could not delete .services object: %s %s' %\n                                (path, resp.status))\n        # Delete the account id mapping for the account.\n        path = quote('/v1/%s/.account_id/%s' %\n                     (self.auth_account, account_id))\n        resp = self.make_pre_authed_request(\n            req.environ, 'DELETE', path).get_response(self.app)\n        if resp.status_int // 100 != 2 and resp.status_int != 404:\n            raise Exception('Could not delete account id mapping: %s %s' %\n                            (path, resp.status))\n        # Delete the account marker itself.\n        path = quote('/v1/%s/%s' % (self.auth_account, account))\n        resp = self.make_pre_authed_request(\n            req.environ, 'DELETE', path).get_response(self.app)\n        if resp.status_int // 100 != 2 and resp.status_int != 404:\n            raise Exception('Could not delete account marked: %s %s' %\n                            (path, resp.status))\n        return HTTPNoContent(request=req)\n\n    def handle_get_user(self, req):\n        \"\"\"Handles the GET v2/<account>/<user> call for getting user information.\n        Can only be called by an account .admin.\n\n        On success, a JSON dict will be returned as described::\n\n            {\"groups\": [  # List of groups the user is a member of\n                {\"name\": \"<act>:<usr>\"},\n                    # The first group is a unique user identifier\n                {\"name\": \"<account>\"},\n                    # The second group is the auth account name\n                {\"name\": \"<additional-group>\"}\n                    # There may be additional groups, .admin being a special\n                    # group indicating an account admin and .reseller_admin\n                    # indicating a reseller admin.\n             ],\n             \"auth\": \"plaintext:<key>\"\n             # The auth-type and key for the user; currently only plaintext is\n             # implemented.\n            }\n\n        For example::\n\n            {\"groups\": [{\"name\": \"test:tester\"}, {\"name\": \"test\"},\n                        {\"name\": \".admin\"}],\n             \"auth\": \"plaintext:testing\"}\n\n        If the <user> in the request is the special user `.groups`, the JSON\n        dict will contain a single key of `groups` whose value is a list of\n        dicts representing the active groups within the account. Each dict\n        currently has the single key `name`. For example::\n\n            {\"groups\": [{\"name\": \".admin\"}, {\"name\": \"test\"},\n                        {\"name\": \"test:tester\"}, {\"name\": \"test:tester3\"}]}\n\n        :param req: The swob.Request to process.\n        :returns: swob.Response, 2xx on success with a JSON dictionary as\n                  explained above.\n        \"\"\"\n        account = req.path_info_pop()\n        user = req.path_info_pop()\n        if req.path_info or not account or account[0] == '.' or not user or \\\n                (user[0] == '.' and user != '.groups'):\n            return HTTPBadRequest(request=req)\n        if not self.is_account_admin(req, account):\n            return self.denied_response(req)\n\n        # get information for each user for the specified\n        # account and create a list of all groups that the users\n        # are part of\n        if user == '.groups':\n            # TODO(gholt): This could be very slow for accounts with a really\n            # large number of users. Speed could be improved by concurrently\n            # requesting user group information. Then again, I don't *know*\n            # it's slow for `normal` use cases, so testing should be done.\n            groups = set()\n            marker = ''\n            while True:\n                path = '/v1/%s?format=json&marker=%s' % (quote('%s/%s' %\n                    (self.auth_account, account)), quote(marker))\n                resp = self.make_pre_authed_request(\n                    req.environ, 'GET', path).get_response(self.app)\n                if resp.status_int == 404:\n                    return HTTPNotFound(request=req)\n                if resp.status_int // 100 != 2:\n                    raise Exception('Could not list in main auth account: '\n                                    '%s %s' % (path, resp.status))\n                sublisting = json.loads(resp.body)\n                if not sublisting:\n                    break\n                for obj in sublisting:\n                    if obj['name'][0] != '.':\n\n                        # get list of groups for each user\n                        user_json = self.get_user_detail(req, account,\n                                                         obj['name'])\n                        if user_json is None:\n                            raise Exception('Could not retrieve user object: '\n                                            '%s:%s %s' % (account, user, 404))\n                        groups.update(\n                            g['name'] for g in json.loads(user_json)['groups'])\n                marker = sublisting[-1]['name'].encode('utf-8')\n            body = json.dumps(\n                {'groups': [{'name': g} for g in sorted(groups)]})\n        else:\n            # get information for specific user,\n            # if user doesn't exist, return HTTPNotFound\n            body = self.get_user_detail(req, account, user)\n            if body is None:\n                return HTTPNotFound(request=req)\n\n            display_groups = [g['name'] for g in json.loads(body)['groups']]\n            if ('.admin' in display_groups and\n                not self.is_reseller_admin(req)) or \\\n               ('.reseller_admin' in display_groups and\n                    not self.is_super_admin(req)):\n                    return self.denied_response(req)\n        return Response(body=body, content_type=CONTENT_TYPE_JSON)\n\n    def handle_put_user(self, req):\n        \"\"\"Handles the PUT v2/<account>/<user> call for adding a user to an\n        account.\n\n        X-Auth-User-Key represents the user's key (url encoded),\n        - OR -\n        X-Auth-User-Key-Hash represents the user's hashed key (url encoded),\n        X-Auth-User-Admin may be set to `true` to create an account .admin, and\n        X-Auth-User-Reseller-Admin may be set to `true` to create a\n        .reseller_admin.\n\n        Creating users\n        **************\n        Can only be called by an account .admin unless the user is to be a\n        .reseller_admin, in which case the request must be by .super_admin.\n\n        Changing password/key\n        *********************\n        1) reseller_admin key can be changed by super_admin and by himself.\n        2) admin key can be changed by any admin in same account,\n           reseller_admin, super_admin and himself.\n        3) Regular user key can be changed by any admin in his account,\n           reseller_admin, super_admin and himself.\n\n        :param req: The swob.Request to process.\n        :returns: swob.Response, 2xx on success.\n        \"\"\"\n        # Validate path info\n        account = req.path_info_pop()\n        user = req.path_info_pop()\n        key = unquote(req.headers.get('x-auth-user-key', ''))\n        key_hash = unquote(req.headers.get('x-auth-user-key-hash', ''))\n        admin = req.headers.get('x-auth-user-admin') == 'true'\n        reseller_admin = \\\n            req.headers.get('x-auth-user-reseller-admin') == 'true'\n        if reseller_admin:\n            admin = True\n        if req.path_info or not account or account[0] == '.' or not user or \\\n                user[0] == '.' or (not key and not key_hash):\n            return HTTPBadRequest(request=req)\n        if key_hash:\n            try:\n                swauth.authtypes.validate_creds(key_hash)\n            except ValueError:\n                return HTTPBadRequest(request=req)\n\n        user_arg = account + ':' + user\n        if reseller_admin:\n            if not self.is_super_admin(req) and\\\n                    not self.is_user_changing_own_key(req, user_arg):\n                        return self.denied_response(req)\n        elif not self.is_account_admin(req, account) and\\\n                not self.is_user_changing_own_key(req, user_arg):\n                    return self.denied_response(req)\n\n        path = quote('/v1/%s/%s' % (self.auth_account, account))\n        resp = self.make_pre_authed_request(\n            req.environ, 'HEAD', path).get_response(self.app)\n        if resp.status_int // 100 != 2:\n            raise Exception('Could not retrieve account id value: %s %s' %\n                            (path, resp.status))\n        headers = {'X-Object-Meta-Account-Id':\n                   resp.headers['x-container-meta-account-id']}\n        # Create the object in the main auth account (this object represents\n        # the user)\n        path = quote('/v1/%s/%s/%s' % (self.auth_account, account, user))\n        groups = ['%s:%s' % (account, user), account]\n        if admin:\n            groups.append('.admin')\n        if reseller_admin:\n            groups.append('.reseller_admin')\n        auth_value = key_hash or self.auth_encoder().encode(key)\n        resp = self.make_pre_authed_request(\n            req.environ, 'PUT', path,\n            json.dumps({'auth': auth_value,\n                        'groups': [{'name': g} for g in groups]}),\n            headers=headers).get_response(self.app)\n        if resp.status_int == 404:\n            return HTTPNotFound(request=req)\n        if resp.status_int // 100 != 2:\n            raise Exception('Could not create user object: %s %s' %\n                            (path, resp.status))\n        return HTTPCreated(request=req)\n\n    def handle_delete_user(self, req):\n        \"\"\"Handles the DELETE v2/<account>/<user> call for deleting a user from an\n        account.\n\n        Can only be called by an account .admin.\n\n        :param req: The swob.Request to process.\n        :returns: swob.Response, 2xx on success.\n        \"\"\"\n        # Validate path info\n        account = req.path_info_pop()\n        user = req.path_info_pop()\n        if req.path_info or not account or account[0] == '.' or not user or \\\n                user[0] == '.':\n            return HTTPBadRequest(request=req)\n\n        # if user to be deleted is reseller_admin, then requesting\n        # user must be the super_admin\n        is_reseller_admin = self.is_user_reseller_admin(req, account, user)\n        if not is_reseller_admin and not req.credentials_valid:\n            # if user to be deleted can't be found, return 404\n            return HTTPNotFound(request=req)\n        elif is_reseller_admin and not self.is_super_admin(req):\n            return HTTPForbidden(request=req)\n\n        if not self.is_account_admin(req, account):\n            return self.denied_response(req)\n\n        # Delete the user's existing token, if any.\n        path = quote('/v1/%s/%s/%s' % (self.auth_account, account, user))\n        resp = self.make_pre_authed_request(\n            req.environ, 'HEAD', path).get_response(self.app)\n        if resp.status_int == 404:\n            return HTTPNotFound(request=req)\n        elif resp.status_int // 100 != 2:\n            raise Exception('Could not obtain user details: %s %s' %\n                            (path, resp.status))\n        candidate_token = resp.headers.get('x-object-meta-auth-token')\n        if candidate_token:\n            object_name = self._get_concealed_token(candidate_token)\n            path = quote('/v1/%s/.token_%s/%s' %\n                (self.auth_account, object_name[-1], object_name))\n            resp = self.make_pre_authed_request(\n                req.environ, 'DELETE', path).get_response(self.app)\n            if resp.status_int // 100 != 2 and resp.status_int != 404:\n                raise Exception('Could not delete possibly existing token: '\n                                '%s %s' % (path, resp.status))\n        # Delete the user entry itself.\n        path = quote('/v1/%s/%s/%s' % (self.auth_account, account, user))\n        resp = self.make_pre_authed_request(\n            req.environ, 'DELETE', path).get_response(self.app)\n        if resp.status_int // 100 != 2 and resp.status_int != 404:\n            raise Exception('Could not delete the user object: %s %s' %\n                            (path, resp.status))\n        return HTTPNoContent(request=req)\n\n    def is_user_reseller_admin(self, req, account, user):\n        \"\"\"Returns True if the user is a .reseller_admin.\n\n        :param account: account user is part of\n        :param user: the user\n        :returns: True if user .reseller_admin, False\n                  if user is not a reseller_admin and None if the user\n                  doesn't exist.\n        \"\"\"\n        req.credentials_valid = True\n        user_json = self.get_user_detail(req, account, user)\n        if user_json is None:\n            req.credentials_valid = False\n            return False\n\n        user_detail = json.loads(user_json)\n\n        return '.reseller_admin' in (g['name'] for g in user_detail['groups'])\n\n    def handle_get_token(self, req):\n        \"\"\"Handles the various `request for token and service end point(s)` calls.\n        There are various formats to support the various auth servers in the\n        past. Examples::\n\n            GET <auth-prefix>/v1/<act>/auth\n                X-Auth-User: <act>:<usr>  or  X-Storage-User: <usr>\n                X-Auth-Key: <key>         or  X-Storage-Pass: <key>\n            GET <auth-prefix>/auth\n                X-Auth-User: <act>:<usr>  or  X-Storage-User: <act>:<usr>\n                X-Auth-Key: <key>         or  X-Storage-Pass: <key>\n            GET <auth-prefix>/v1.0\n                X-Auth-User: <act>:<usr>  or  X-Storage-User: <act>:<usr>\n                X-Auth-Key: <key>         or  X-Storage-Pass: <key>\n\n        Values should be url encoded, \"act%3Ausr\" instead of \"act:usr\" for\n        example; however, for backwards compatibility the colon may be included\n        unencoded.\n\n        On successful authentication, the response will have X-Auth-Token and\n        X-Storage-Token set to the token to use with Swift and X-Storage-URL\n        set to the URL to the default Swift cluster to use.\n\n        The response body will be set to the account's services JSON object as\n        described here::\n\n            {\"storage\": {     # Represents the Swift storage service end points\n                \"default\": \"cluster1\", # Indicates which cluster is the default\n                \"cluster1\": \"<URL to use with Swift>\",\n                    # A Swift cluster that can be used with this account,\n                    # \"cluster1\" is the name of the cluster which is usually a\n                    # location indicator (like \"dfw\" for a datacenter region).\n                \"cluster2\": \"<URL to use with Swift>\"\n                    # Another Swift cluster that can be used with this account,\n                    # there will always be at least one Swift cluster to use or\n                    # this whole \"storage\" dict won't be included at all.\n             },\n             \"servers\": {       # Represents the Nova server service end points\n                # Expected to be similar to the \"storage\" dict, but not\n                # implemented yet.\n             },\n             # Possibly other service dicts, not implemented yet.\n            }\n\n        One can also include an \"X-Auth-New-Token: true\" header to\n        force issuing a new token and revoking any old token, even if\n        it hasn't expired yet.\n\n        :param req: The swob.Request to process.\n        :returns: swob.Response, 2xx on success with data set as explained\n                  above.\n        \"\"\"\n        # Validate the request info\n        try:\n            pathsegs = split_path(req.path_info, minsegs=1, maxsegs=3,\n                                  rest_with_last=True)\n        except ValueError:\n            return HTTPNotFound(request=req)\n        if pathsegs[0] == 'v1' and pathsegs[2] == 'auth':\n            account = pathsegs[1]\n            user = req.headers.get('x-storage-user')\n            if not user:\n                user = unquote(req.headers.get('x-auth-user', ''))\n                if not user or ':' not in user:\n                    return HTTPUnauthorized(request=req)\n                account2, user = user.split(':', 1)\n                if account != account2:\n                    return HTTPUnauthorized(request=req)\n            key = req.headers.get('x-storage-pass')\n            if not key:\n                key = unquote(req.headers.get('x-auth-key', ''))\n        elif pathsegs[0] in ('auth', 'v1.0'):\n            user = unquote(req.headers.get('x-auth-user', ''))\n            if not user:\n                user = req.headers.get('x-storage-user')\n            if not user or ':' not in user:\n                return HTTPUnauthorized(request=req)\n            account, user = user.split(':', 1)\n            key = unquote(req.headers.get('x-auth-key', ''))\n            if not key:\n                key = req.headers.get('x-storage-pass')\n        else:\n            return HTTPBadRequest(request=req)\n        if not all((account, user, key)):\n            return HTTPUnauthorized(request=req)\n        if user == '.super_admin' and self.super_admin_key and \\\n                key == self.super_admin_key:\n            token = self.get_itoken(req.environ)\n            url = '%s/%s.auth' % (self.dsc_url, self.reseller_prefix)\n            return Response(\n                request=req,\n                content_type=CONTENT_TYPE_JSON,\n                body=json.dumps({'storage': {'default': 'local',\n                                             'local': url}}),\n                headers={'x-auth-token': token,\n                         'x-storage-token': token,\n                         'x-storage-url': url})\n\n        # Authenticate user\n        path = quote('/v1/%s/%s/%s' % (self.auth_account, account, user))\n        resp = self.make_pre_authed_request(\n            req.environ, 'GET', path).get_response(self.app)\n        if resp.status_int == 404:\n            return HTTPUnauthorized(request=req)\n        if resp.status_int // 100 != 2:\n            raise Exception('Could not obtain user details: %s %s' %\n                            (path, resp.status))\n        user_detail = json.loads(resp.body)\n        if not self.credentials_match(user_detail, key):\n            return HTTPUnauthorized(request=req)\n        # See if a token already exists and hasn't expired\n        token = None\n        expires = None\n        candidate_token = resp.headers.get('x-object-meta-auth-token')\n        if candidate_token:\n            object_name = self._get_concealed_token(candidate_token)\n            path = quote('/v1/%s/.token_%s/%s' %\n                (self.auth_account, object_name[-1], object_name))\n            delete_token = False\n            try:\n                if req.headers.get('x-auth-new-token', 'false').lower() in \\\n                        TRUE_VALUES:\n                    delete_token = True\n                else:\n                    resp = self.make_pre_authed_request(\n                        req.environ, 'GET', path).get_response(self.app)\n                    if resp.status_int // 100 == 2:\n                        token_detail = json.loads(resp.body)\n                        if token_detail['expires'] > time():\n                            token = candidate_token\n                            expires = token_detail['expires']\n                        else:\n                            delete_token = True\n                    elif resp.status_int != 404:\n                        raise Exception(\n                            'Could not detect whether a token already exists: '\n                            '%s %s' % (path, resp.status))\n            finally:\n                if delete_token:\n                    self.make_pre_authed_request(\n                        req.environ, 'DELETE', path).get_response(self.app)\n                    memcache_client = cache_from_env(req.environ)\n                    if memcache_client:\n                        memcache_key = '%s/auth/%s' % (self.reseller_prefix,\n                                                       candidate_token)\n                        memcache_client.delete(memcache_key)\n        # Create a new token if one didn't exist\n        if not token:\n            # Retrieve account id, we'll save this in the token\n            path = quote('/v1/%s/%s' % (self.auth_account, account))\n            resp = self.make_pre_authed_request(\n                req.environ, 'HEAD', path).get_response(self.app)\n            if resp.status_int // 100 != 2:\n                raise Exception('Could not retrieve account id value: '\n                                '%s %s' % (path, resp.status))\n            account_id = \\\n                resp.headers['x-container-meta-account-id']\n            # Generate new token\n            token = '%stk%s' % (self.reseller_prefix, uuid4().hex)\n            # Save token info\n            object_name = self._get_concealed_token(token)\n            path = quote('/v1/%s/.token_%s/%s' %\n                         (self.auth_account, object_name[-1], object_name))\n            try:\n                token_life = min(\n                    int(req.headers.get('x-auth-token-lifetime',\n                                        self.token_life)),\n                    self.max_token_life)\n            except ValueError:\n                token_life = self.token_life\n            expires = int(time() + token_life)\n            resp = self.make_pre_authed_request(\n                req.environ, 'PUT', path,\n                json.dumps({'account': account, 'user': user,\n                'account_id': account_id,\n                'groups': user_detail['groups'],\n                'expires': expires})).get_response(self.app)\n            if resp.status_int // 100 != 2:\n                raise Exception('Could not create new token: %s %s' %\n                                (path, resp.status))\n            # Record the token with the user info for future use.\n            path = quote('/v1/%s/%s/%s' % (self.auth_account, account, user))\n            resp = self.make_pre_authed_request(\n                req.environ, 'POST', path,\n                headers={'X-Object-Meta-Auth-Token': token}\n            ).get_response(self.app)\n            if resp.status_int // 100 != 2:\n                raise Exception('Could not save new token: %s %s' %\n                                (path, resp.status))\n        # Get the services information\n        path = quote('/v1/%s/%s/.services' % (self.auth_account, account))\n        resp = self.make_pre_authed_request(\n            req.environ, 'GET', path).get_response(self.app)\n        if resp.status_int // 100 != 2:\n            raise Exception('Could not obtain services info: %s %s' %\n                            (path, resp.status))\n        detail = json.loads(resp.body)\n        url = detail['storage'][detail['storage']['default']]\n        return Response(\n            request=req,\n            body=resp.body,\n            content_type=CONTENT_TYPE_JSON,\n            headers={'x-auth-token': token,\n                     'x-storage-token': token,\n                     'x-auth-token-expires': str(int(expires - time())),\n                     'x-storage-url': url})\n\n    def handle_validate_token(self, req):\n        \"\"\"Handles the GET v2/.token/<token> call for validating a token, usually\n        called by a service like Swift.\n\n        On a successful validation, X-Auth-TTL will be set for how much longer\n        this token is valid and X-Auth-Groups will contain a comma separated\n        list of groups the user belongs to.\n\n        The first group listed will be a unique identifier for the user the\n        token represents.\n\n        .reseller_admin is a special group that indicates the user should be\n        allowed to do anything on any account.\n\n        :param req: The swob.Request to process.\n        :returns: swob.Response, 2xx on success with data set as explained\n                  above.\n        \"\"\"\n        token = req.path_info_pop()\n        if req.path_info or not token.startswith(self.reseller_prefix):\n            return HTTPBadRequest(request=req)\n        expires = groups = None\n        memcache_client = cache_from_env(req.environ)\n        if memcache_client:\n            memcache_key = '%s/auth/%s' % (self.reseller_prefix, token)\n            cached_auth_data = memcache_client.get(memcache_key)\n            if cached_auth_data:\n                expires, groups = cached_auth_data\n                if expires < time():\n                    groups = None\n        if not groups:\n            object_name = self._get_concealed_token(token)\n            path = quote('/v1/%s/.token_%s/%s' %\n                         (self.auth_account, object_name[-1], object_name))\n            resp = self.make_pre_authed_request(\n                req.environ, 'GET', path).get_response(self.app)\n            if resp.status_int // 100 != 2:\n                return HTTPNotFound(request=req)\n            detail = json.loads(resp.body)\n            expires = detail['expires']\n            if expires < time():\n                self.make_pre_authed_request(\n                    req.environ, 'DELETE', path).get_response(self.app)\n                return HTTPNotFound(request=req)\n            groups = [g['name'] for g in detail['groups']]\n            if '.admin' in groups:\n                groups.remove('.admin')\n                groups.append(detail['account_id'])\n            groups = ','.join(groups)\n        return HTTPNoContent(headers={'X-Auth-TTL': expires - time(),\n                                      'X-Auth-Groups': groups})\n\n    def get_conn(self, urlparsed=None):\n        \"\"\"Returns an HTTPConnection based on the urlparse result given or the\n        default Swift cluster (internal url) urlparse result.\n\n        :param urlparsed: The result from urlparse.urlparse or None to use the\n                          default Swift cluster's value\n        \"\"\"\n        if not urlparsed:\n            urlparsed = self.dsc_parsed2\n        if urlparsed.scheme == 'http':\n            return HTTPConnection(urlparsed.netloc)\n        else:\n            return HTTPSConnection(urlparsed.netloc)\n\n    def get_itoken(self, env):\n        \"\"\"Returns the current internal token to use for the auth system's own\n        actions with other services. Each process will create its own\n        itoken and the token will be deleted and recreated based on the\n        token_life configuration value. The itoken information is stored in\n        memcache because the auth process that is asked by Swift to validate\n        the token may not be the same as the auth process that created the\n        token.\n        \"\"\"\n        if not self.itoken or self.itoken_expires < time() or \\\n                env.get('HTTP_X_AUTH_NEW_TOKEN', 'false').lower() in \\\n                TRUE_VALUES:\n            self.itoken = '%sitk%s' % (self.reseller_prefix, uuid4().hex)\n            memcache_key = '%s/auth/%s' % (self.reseller_prefix, self.itoken)\n            self.itoken_expires = time() + self.token_life\n            memcache_client = cache_from_env(env)\n            if not memcache_client:\n                raise Exception(\n                    'No memcache set up; required for Swauth middleware')\n            memcache_client.set(\n                memcache_key,\n                (self.itoken_expires,\n                 '.auth,.reseller_admin,%s.auth' % self.reseller_prefix),\n                time=self.token_life)\n        return self.itoken\n\n    def get_admin_detail(self, req):\n        \"\"\"Returns the dict for the user specified as the admin in the request\n        with the addition of an `account` key set to the admin user's account.\n\n        :param req: The swob request to retrieve X-Auth-Admin-User and\n                    X-Auth-Admin-Key from.\n        :returns: The dict for the admin user with the addition of the\n                  `account` key.\n        \"\"\"\n        if ':' not in req.headers.get('x-auth-admin-user', ''):\n            return None\n        admin_account, admin_user = \\\n            req.headers.get('x-auth-admin-user').split(':', 1)\n        user_json = self.get_user_detail(req, admin_account, admin_user)\n        if user_json is None:\n            return None\n        admin_detail = json.loads(user_json)\n        admin_detail['account'] = admin_account\n        return admin_detail\n\n    def get_user_detail(self, req, account, user):\n        \"\"\"Returns the response body of a GET request for the specified user\n        The body is in JSON format and contains all user information.\n\n        :param req: The swob request\n        :param account: the account the user is a member of\n        :param user: the user\n\n        :returns: A JSON response with the user detail information, None\n                  if the user doesn't exist\n        \"\"\"\n        path = quote('/v1/%s/%s/%s' % (self.auth_account, account, user))\n        resp = self.make_pre_authed_request(\n            req.environ, 'GET', path).get_response(self.app)\n        if resp.status_int == 404:\n            return None\n        if resp.status_int // 100 != 2:\n            raise Exception('Could not get user object: %s %s' %\n                            (path, resp.status))\n        return resp.body\n\n    def credentials_match(self, user_detail, key):\n        \"\"\"Returns True if the key is valid for the user_detail.\n        It will use auth_encoder type the password was encoded with,\n        to check for a key match.\n\n        :param user_detail: The dict for the user.\n        :param key: The key to validate for the user.\n        :returns: True if the key is valid for the user, False if not.\n        \"\"\"\n        if user_detail:\n            creds = user_detail.get('auth')\n            try:\n                auth_encoder, creds_dict = \\\n                    swauth.authtypes.validate_creds(creds)\n            except ValueError as e:\n                self.logger.error('%s' % e.args[0])\n                return False\n        return user_detail and auth_encoder.match(key, creds, **creds_dict)\n\n    def is_user_changing_own_key(self, req, user):\n        \"\"\"Check if the user is changing his own key.\n\n        :param req: The swob.Request to check. This contains x-auth-admin-user\n                    and x-auth-admin-key headers which are credentials of the\n                    user sending the request.\n        :param user: User whose password is to be changed.\n        :returns: True if user is changing his own key, False if not.\n        \"\"\"\n        admin_detail = self.get_admin_detail(req)\n        if not admin_detail:\n            # The user does not exist\n            return False\n\n        # If user is not admin/reseller_admin and x-auth-user-admin or\n        # x-auth-user-reseller-admin headers are present in request, he may be\n        # attempting to escalate himself as admin/reseller_admin!\n        if '.admin' not in (g['name'] for g in admin_detail['groups']):\n            if req.headers.get('x-auth-user-admin') == 'true' or \\\n                    req.headers.get('x-auth-user-reseller-admin') == 'true':\n                        return False\n        if '.reseller_admin' not in \\\n            (g['name'] for g in admin_detail['groups']) and \\\n                req.headers.get('x-auth-user-reseller-admin') == 'true':\n                    return False\n\n        return req.headers.get('x-auth-admin-user') == user and \\\n            self.credentials_match(admin_detail,\n                                   req.headers.get('x-auth-admin-key'))\n\n    def is_super_admin(self, req):\n        \"\"\"Returns True if the admin specified in the request represents the\n        .super_admin.\n\n        :param req: The swob.Request to check.\n        :param returns: True if .super_admin.\n        \"\"\"\n        return req.headers.get('x-auth-admin-user') == '.super_admin' and \\\n            self.super_admin_key and \\\n            req.headers.get('x-auth-admin-key') == self.super_admin_key\n\n    def is_reseller_admin(self, req, admin_detail=None):\n        \"\"\"Returns True if the admin specified in the request represents a\n        .reseller_admin.\n\n        :param req: The swob.Request to check.\n        :param admin_detail: The previously retrieved dict from\n                             :func:`get_admin_detail` or None for this function\n                             to retrieve the admin_detail itself.\n        :param returns: True if .reseller_admin.\n        \"\"\"\n        req.credentials_valid = False\n        if self.is_super_admin(req):\n            return True\n        if not admin_detail:\n            admin_detail = self.get_admin_detail(req)\n        if not self.credentials_match(admin_detail,\n                                      req.headers.get('x-auth-admin-key')):\n            return False\n        req.credentials_valid = True\n        return '.reseller_admin' in (g['name'] for g in admin_detail['groups'])\n\n    def is_account_admin(self, req, account):\n        \"\"\"Returns True if the admin specified in the request represents a .admin\n        for the account specified.\n\n        :param req: The swob.Request to check.\n        :param account: The account to check for .admin against.\n        :param returns: True if .admin.\n        \"\"\"\n        req.credentials_valid = False\n        if self.is_super_admin(req):\n            return True\n        admin_detail = self.get_admin_detail(req)\n        if admin_detail:\n            if self.is_reseller_admin(req, admin_detail=admin_detail):\n                return True\n            if not self.credentials_match(admin_detail,\n                                          req.headers.get('x-auth-admin-key')):\n                return False\n            req.credentials_valid = True\n            return admin_detail and admin_detail['account'] == account and \\\n                '.admin' in (g['name'] for g in admin_detail['groups'])\n        return False\n\n    def posthooklogger(self, env, req):\n        if not req.path.startswith(self.auth_prefix):\n            return\n        response = getattr(req, 'response', None)\n        if not response:\n            return\n        trans_time = '%.4f' % (time() - req.start_time)\n        the_request = quote(unquote(req.path))\n        if req.query_string:\n            the_request = the_request + '?' + req.query_string\n        # remote user for zeus\n        client = req.headers.get('x-cluster-client-ip')\n        if not client and 'x-forwarded-for' in req.headers:\n            # remote user for other lbs\n            client = req.headers['x-forwarded-for'].split(',')[0].strip()\n        logged_headers = None\n        if self.log_headers:\n            logged_headers = '\\n'.join('%s: %s' % (k, v)\n                                       for k, v in req.headers.items())\n        status_int = response.status_int\n        if getattr(req, 'client_disconnect', False) or \\\n                getattr(response, 'client_disconnect', False):\n            status_int = 499\n        self.logger.info(' '.join(quote(str(x)) for x in (client or '-',\n            req.remote_addr or '-', strftime('%d/%b/%Y/%H/%M/%S', gmtime()),\n            req.method, the_request, req.environ['SERVER_PROTOCOL'],\n            status_int, req.referer or '-', req.user_agent or '-',\n            req.headers.get('x-auth-token',\n                req.headers.get('x-auth-admin-user', '-')),\n            getattr(req, 'bytes_transferred', 0) or '-',\n            getattr(response, 'bytes_transferred', 0) or '-',\n            req.headers.get('etag', '-'),\n            req.headers.get('x-trans-id', '-'), logged_headers or '-',\n            trans_time)))\n\n\ndef filter_factory(global_conf, **local_conf):\n    \"\"\"Returns a WSGI filter app for use with paste.deploy.\"\"\"\n    conf = global_conf.copy()\n    conf.update(local_conf)\n\n    def auth_filter(app):\n        return Swauth(app, conf)\n    return auth_filter\n", "# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n# implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\n# Pablo Llopis 2011\n\nimport mock\nfrom swauth import authtypes\nimport unittest\n\n\nclass TestValidation(unittest.TestCase):\n    def test_validate_creds(self):\n        creds = 'plaintext:keystring'\n        creds_dict = dict(type='plaintext', salt=None, hash='keystring')\n        auth_encoder, parsed_creds = authtypes.validate_creds(creds)\n        self.assertEqual(parsed_creds, creds_dict)\n        self.assertTrue(isinstance(auth_encoder, authtypes.Plaintext))\n\n        creds = 'sha1:salt$d50dc700c296e23ce5b41f7431a0e01f69010f06'\n        creds_dict = dict(type='sha1', salt='salt',\n                          hash='d50dc700c296e23ce5b41f7431a0e01f69010f06')\n        auth_encoder, parsed_creds = authtypes.validate_creds(creds)\n        self.assertEqual(parsed_creds, creds_dict)\n        self.assertTrue(isinstance(auth_encoder, authtypes.Sha1))\n\n        creds = ('sha512:salt$482e73705fac6909e2d78e8bbaf65ac3ca1473'\n                 '8f445cc2367b7daa3f0e8f3dcfe798e426b9e332776c8da59c'\n                 '0c11d4832931d1bf48830f670ecc6ceb04fbad0f')\n        creds_dict = dict(type='sha512', salt='salt',\n                          hash='482e73705fac6909e2d78e8bbaf65ac3ca1473'\n                               '8f445cc2367b7daa3f0e8f3dcfe798e426b9e3'\n                               '32776c8da59c0c11d4832931d1bf48830f670e'\n                               'cc6ceb04fbad0f')\n        auth_encoder, parsed_creds = authtypes.validate_creds(creds)\n        self.assertEqual(parsed_creds, creds_dict)\n        self.assertTrue(isinstance(auth_encoder, authtypes.Sha512))\n\n    def test_validate_creds_fail(self):\n        # wrong format, missing `:`\n        creds = 'unknown;keystring'\n        self.assertRaisesRegexp(ValueError, \"Missing ':' in .*\",\n                                authtypes.validate_creds, creds)\n        # unknown auth_type\n        creds = 'unknown:keystring'\n        self.assertRaisesRegexp(ValueError, \"Invalid auth_type: .*\",\n                                authtypes.validate_creds, creds)\n        # wrong plaintext keystring\n        creds = 'plaintext:'\n        self.assertRaisesRegexp(ValueError, \"Key must have non-zero length!\",\n                                authtypes.validate_creds, creds)\n        # wrong sha1 format, missing `$`\n        creds = 'sha1:saltkeystring'\n        self.assertRaisesRegexp(ValueError, \"Missing '\\$' in .*\",\n                                authtypes.validate_creds, creds)\n        # wrong sha1 format, missing salt\n        creds = 'sha1:$hash'\n        self.assertRaisesRegexp(ValueError, \"Salt must have non-zero length!\",\n                                authtypes.validate_creds, creds)\n        # wrong sha1 format, missing hash\n        creds = 'sha1:salt$'\n        self.assertRaisesRegexp(ValueError, \"Hash must have 40 chars!\",\n                                authtypes.validate_creds, creds)\n        # wrong sha1 format, short hash\n        creds = 'sha1:salt$short_hash'\n        self.assertRaisesRegexp(ValueError, \"Hash must have 40 chars!\",\n                                authtypes.validate_creds, creds)\n        # wrong sha1 format, wrong format\n        creds = 'sha1:salt$' + \"z\" * 40\n        self.assertRaisesRegexp(ValueError, \"Hash must be hexadecimal!\",\n                                authtypes.validate_creds, creds)\n        # wrong sha512 format, missing `$`\n        creds = 'sha512:saltkeystring'\n        self.assertRaisesRegexp(ValueError, \"Missing '\\$' in .*\",\n                                authtypes.validate_creds, creds)\n        # wrong sha512 format, missing salt\n        creds = 'sha512:$hash'\n        self.assertRaisesRegexp(ValueError, \"Salt must have non-zero length!\",\n                                authtypes.validate_creds, creds)\n        # wrong sha512 format, missing hash\n        creds = 'sha512:salt$'\n        self.assertRaisesRegexp(ValueError, \"Hash must have 128 chars!\",\n                                authtypes.validate_creds, creds)\n        # wrong sha512 format, short hash\n        creds = 'sha512:salt$short_hash'\n        self.assertRaisesRegexp(ValueError, \"Hash must have 128 chars!\",\n                                authtypes.validate_creds, creds)\n        # wrong sha1 format, wrong format\n        creds = 'sha512:salt$' + \"z\" * 128\n        self.assertRaisesRegexp(ValueError, \"Hash must be hexadecimal!\",\n                                authtypes.validate_creds, creds)\n\n\nclass TestPlaintext(unittest.TestCase):\n\n    def setUp(self):\n        self.auth_encoder = authtypes.Plaintext()\n\n    def test_plaintext_encode(self):\n        enc_key = self.auth_encoder.encode('keystring')\n        self.assertEqual('plaintext:keystring', enc_key)\n\n    def test_plaintext_valid_match(self):\n        creds = 'plaintext:keystring'\n        match = self.auth_encoder.match('keystring', creds)\n        self.assertEqual(match, True)\n\n    def test_plaintext_invalid_match(self):\n        creds = 'plaintext:other-keystring'\n        match = self.auth_encoder.match('keystring', creds)\n        self.assertEqual(match, False)\n\n\nclass TestSha1(unittest.TestCase):\n\n    def setUp(self):\n        self.auth_encoder = authtypes.Sha1()\n        self.auth_encoder.salt = 'salt'\n\n    @mock.patch('swauth.authtypes.os')\n    def test_sha1_encode(self, os):\n        os.urandom.return_value.encode.return_value.rstrip \\\n            .return_value = 'salt'\n        enc_key = self.auth_encoder.encode('keystring')\n        self.assertEqual('sha1:salt$d50dc700c296e23ce5b41f7431a0e01f69010f06',\n                         enc_key)\n\n    def test_sha1_valid_match(self):\n        creds = 'sha1:salt$d50dc700c296e23ce5b41f7431a0e01f69010f06'\n        creds_dict = dict(type='sha1', salt='salt',\n                          hash='d50dc700c296e23ce5b41f7431a0e01f69010f06')\n        match = self.auth_encoder.match('keystring', creds, **creds_dict)\n        self.assertEqual(match, True)\n\n    def test_sha1_invalid_match(self):\n        creds = 'sha1:salt$deadbabedeadbabedeadbabec0ffeebadc0ffeee'\n        creds_dict = dict(type='sha1', salt='salt',\n                          hash='deadbabedeadbabedeadbabec0ffeebadc0ffeee')\n        match = self.auth_encoder.match('keystring', creds, **creds_dict)\n        self.assertEqual(match, False)\n\n        creds = 'sha1:salt$d50dc700c296e23ce5b41f7431a0e01f69010f06'\n        creds_dict = dict(type='sha1', salt='salt',\n                          hash='d50dc700c296e23ce5b41f7431a0e01f69010f06')\n        match = self.auth_encoder.match('keystring2', creds, **creds_dict)\n        self.assertEqual(match, False)\n\n\nclass TestSha512(unittest.TestCase):\n\n    def setUp(self):\n        self.auth_encoder = authtypes.Sha512()\n        self.auth_encoder.salt = 'salt'\n\n    @mock.patch('swauth.authtypes.os')\n    def test_sha512_encode(self, os):\n        os.urandom.return_value.encode.return_value.rstrip \\\n            .return_value = 'salt'\n        enc_key = self.auth_encoder.encode('keystring')\n        self.assertEqual('sha512:salt$482e73705fac6909e2d78e8bbaf65ac3ca1473'\n                         '8f445cc2367b7daa3f0e8f3dcfe798e426b9e332776c8da59c'\n                         '0c11d4832931d1bf48830f670ecc6ceb04fbad0f', enc_key)\n\n    def test_sha512_valid_match(self):\n        creds = ('sha512:salt$482e73705fac6909e2d78e8bbaf65ac3ca14738f445cc2'\n                 '367b7daa3f0e8f3dcfe798e426b9e332776c8da59c0c11d4832931d1bf'\n                 '48830f670ecc6ceb04fbad0f')\n        creds_dict = dict(type='sha512', salt='salt',\n                          hash='482e73705fac6909e2d78e8bbaf65ac3ca14738f445cc2'\n                               '367b7daa3f0e8f3dcfe798e426b9e332776c8da59c0c11'\n                               'd4832931d1bf48830f670ecc6ceb04fbad0f')\n        match = self.auth_encoder.match('keystring', creds, **creds_dict)\n        self.assertEqual(match, True)\n\n    def test_sha512_invalid_match(self):\n        creds = ('sha512:salt$deadbabedeadbabedeadbabedeadbabedeadbabedeadba'\n                 'bedeadbabedeadbabedeadbabedeadbabedeadbabedeadbabedeadbabe'\n                 'c0ffeebadc0ffeeec0ffeeba')\n        creds_dict = dict(type='sha512', salt='salt',\n                          hash='deadbabedeadbabedeadbabedeadbabedeadbabedeadba'\n                               'bedeadbabedeadbabedeadbabedeadbabedeadbabedead'\n                               'babedeadbabec0ffeebadc0ffeeec0ffeeba')\n        match = self.auth_encoder.match('keystring', creds, **creds_dict)\n        self.assertEqual(match, False)\n\n        creds = ('sha512:salt$482e73705fac6909e2d78e8bbaf65ac3ca14738f445cc2'\n                 '367b7daa3f0e8f3dcfe798e426b9e332776c8da59c0c11d4832931d1bf'\n                 '48830f670ecc6ceb04fbad0f')\n        creds_dict = dict(type='sha512', salt='salt',\n                          hash='482e73705fac6909e2d78e8bbaf65ac3ca14738f445cc2'\n                               '367b7daa3f0e8f3dcfe798e426b9e332776c8da59c0c11'\n                               'd4832931d1bf48830f670ecc6ceb04fbad0f')\n        match = self.auth_encoder.match('keystring2', creds, **creds_dict)\n        self.assertEqual(match, False)\n\n\nif __name__ == '__main__':\n    unittest.main()\n", "# Copyright (c) 2010-2011 OpenStack, LLC.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n# implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom contextlib import contextmanager\nimport hashlib\nimport json\nimport mock\nfrom time import time\nimport unittest\nfrom urllib import quote\n\nfrom swift.common.swob import Request\nfrom swift.common.swob import Response\n\nfrom swauth.authtypes import MAX_TOKEN_LENGTH\nfrom swauth import middleware as auth\n\n\nCONTENT_TYPE_JSON = 'application/json'\nDEFAULT_TOKEN_LIFE = 86400\nMAX_TOKEN_LIFE = 100000\n\n\nclass FakeMemcache(object):\n\n    def __init__(self):\n        self.store = {}\n\n    def get(self, key):\n        return self.store.get(key)\n\n    def set(self, key, value, time=0):\n        self.store[key] = value\n        return True\n\n    def incr(self, key, time=0):\n        self.store[key] = self.store.setdefault(key, 0) + 1\n        return self.store[key]\n\n    @contextmanager\n    def soft_lock(self, key, retries=5, time=0):\n        yield True\n\n    def delete(self, key):\n        try:\n            del self.store[key]\n        except Exception:\n            pass\n        return True\n\n\nclass FakeApp(object):\n\n    def __init__(self, status_headers_body_iter=None, acl=None, sync_key=None):\n        self.calls = 0\n        self.status_headers_body_iter = status_headers_body_iter\n        if not self.status_headers_body_iter:\n            self.status_headers_body_iter = iter([('404 Not Found', {}, '')])\n        self.acl = acl\n        self.sync_key = sync_key\n\n    def __call__(self, env, start_response):\n        self.calls += 1\n        self.request = Request.blank('', environ=env)\n        if self.acl:\n            self.request.acl = self.acl\n        if self.sync_key:\n            self.request.environ['swift_sync_key'] = self.sync_key\n        if 'swift.authorize' in env:\n            resp = env['swift.authorize'](self.request)\n            if resp:\n                return resp(env, start_response)\n        status, headers, body = self.status_headers_body_iter.next()\n        return Response(status=status, headers=headers,\n                        body=body)(env, start_response)\n\n\nclass FakeConn(object):\n\n    def __init__(self, status_headers_body_iter=None):\n        self.calls = 0\n        self.status_headers_body_iter = status_headers_body_iter\n        if not self.status_headers_body_iter:\n            self.status_headers_body_iter = iter([('404 Not Found', {}, '')])\n\n    def request(self, method, path, headers):\n        self.calls += 1\n        self.request_path = path\n        self.status, self.headers, self.body = \\\n            self.status_headers_body_iter.next()\n        self.status, self.reason = self.status.split(' ', 1)\n        self.status = int(self.status)\n\n    def getresponse(self):\n        return self\n\n    def read(self):\n        body = self.body\n        self.body = ''\n        return body\n\n\nclass TestAuth(unittest.TestCase):\n\n    def setUp(self):\n        self.test_auth = \\\n            auth.filter_factory({\n                'super_admin_key': 'supertest',\n                'token_life': str(DEFAULT_TOKEN_LIFE),\n                'max_token_life': str(MAX_TOKEN_LIFE)})(FakeApp())\n\n    def test_salt(self):\n        for auth_type in ('sha1', 'sha512'):\n            # Salt not manually set\n            test_auth = \\\n                auth.filter_factory({\n                    'super_admin_key': 'supertest',\n                    'token_life': str(DEFAULT_TOKEN_LIFE),\n                    'max_token_life': str(MAX_TOKEN_LIFE),\n                    'auth_type': auth_type})(FakeApp())\n            self.assertEqual(test_auth.auth_encoder.salt, None)\n            mock_urandom = mock.Mock(return_value=\"abc\")\n            with mock.patch(\"os.urandom\", mock_urandom):\n                h_key = test_auth.auth_encoder().encode(\"key\")\n            self.assertTrue(mock_urandom.called)\n            prefix = auth_type + \":\" + \"abc\".encode('base64').rstrip() + '$'\n            self.assertTrue(h_key.startswith(prefix))\n\n            # Salt manually set\n            test_auth = \\\n                auth.filter_factory({\n                    'super_admin_key': 'supertest',\n                    'token_life': str(DEFAULT_TOKEN_LIFE),\n                    'max_token_life': str(MAX_TOKEN_LIFE),\n                    'auth_type': auth_type,\n                    'auth_type_salt': \"mysalt\"})(FakeApp())\n            self.assertEqual(test_auth.auth_encoder.salt, \"mysalt\")\n            mock_urandom = mock.Mock()\n            with mock.patch(\"os.urandom\", mock_urandom):\n                h_key = test_auth.auth_encoder().encode(\"key\")\n            self.assertFalse(mock_urandom.called)\n            prefix = auth_type + \":\" + \"mysalt\" + '$'\n            self.assertTrue(h_key.startswith(prefix))\n\n    def test_swift_version(self):\n        app = FakeApp()\n\n        with mock.patch('swauth.swift_version.at_least') as mock_at_least:\n            mock_at_least.return_value = False\n            self.assertRaises(ValueError, auth.filter_factory({}), app)\n\n    def test_super_admin_key_not_required(self):\n        auth.filter_factory({})(FakeApp())\n\n    def test_reseller_prefix_init(self):\n        app = FakeApp()\n        ath = auth.filter_factory({'super_admin_key': 'supertest'})(app)\n        self.assertEqual(ath.reseller_prefix, 'AUTH_')\n        ath = auth.filter_factory({'super_admin_key': 'supertest',\n                                   'reseller_prefix': 'TEST'})(app)\n        self.assertEqual(ath.reseller_prefix, 'TEST_')\n        ath = auth.filter_factory({'super_admin_key': 'supertest',\n                                   'reseller_prefix': 'TEST_'})(app)\n        self.assertEqual(ath.reseller_prefix, 'TEST_')\n\n    def test_auth_prefix_init(self):\n        app = FakeApp()\n        ath = auth.filter_factory({'super_admin_key': 'supertest'})(app)\n        self.assertEqual(ath.auth_prefix, '/auth/')\n        ath = auth.filter_factory({'super_admin_key': 'supertest',\n                                   'auth_prefix': ''})(app)\n        self.assertEqual(ath.auth_prefix, '/auth/')\n        ath = auth.filter_factory({'super_admin_key': 'supertest',\n                                   'auth_prefix': '/test/'})(app)\n        self.assertEqual(ath.auth_prefix, '/test/')\n        ath = auth.filter_factory({'super_admin_key': 'supertest',\n                                   'auth_prefix': '/test'})(app)\n        self.assertEqual(ath.auth_prefix, '/test/')\n        ath = auth.filter_factory({'super_admin_key': 'supertest',\n                                   'auth_prefix': 'test/'})(app)\n        self.assertEqual(ath.auth_prefix, '/test/')\n        ath = auth.filter_factory({'super_admin_key': 'supertest',\n                                   'auth_prefix': 'test'})(app)\n        self.assertEqual(ath.auth_prefix, '/test/')\n\n    def test_no_auth_type_init(self):\n        app = FakeApp()\n        ath = auth.filter_factory({})(app)\n        self.assertEqual(ath.auth_type, 'Plaintext')\n\n    def test_valid_auth_type_init(self):\n        app = FakeApp()\n        ath = auth.filter_factory({'auth_type': 'sha1'})(app)\n        self.assertEqual(ath.auth_type, 'Sha1')\n        ath = auth.filter_factory({'auth_type': 'plaintext'})(app)\n        self.assertEqual(ath.auth_type, 'Plaintext')\n\n    def test_invalid_auth_type_init(self):\n        app = FakeApp()\n        exc = None\n        try:\n            auth.filter_factory({'auth_type': 'NONEXISTANT'})(app)\n        except Exception as err:\n            exc = err\n        self.assertEqual(str(exc),\n                         'Invalid auth_type in config file: %s' %\n                         'Nonexistant')\n\n    def test_default_swift_cluster_init(self):\n        app = FakeApp()\n        self.assertRaises(ValueError, auth.filter_factory({\n            'super_admin_key': 'supertest',\n            'default_swift_cluster': 'local#badscheme://host/path'}), app)\n        ath = auth.filter_factory({'super_admin_key': 'supertest'})(app)\n        self.assertEqual(ath.default_swift_cluster,\n                         'local#http://127.0.0.1:8080/v1')\n        ath = auth.filter_factory({'super_admin_key': 'supertest',\n            'default_swift_cluster': 'local#http://host/path'})(app)\n        self.assertEqual(ath.default_swift_cluster,\n                         'local#http://host/path')\n        ath = auth.filter_factory({'super_admin_key': 'supertest',\n            'default_swift_cluster': 'local#https://host/path/'})(app)\n        self.assertEqual(ath.dsc_url, 'https://host/path')\n        self.assertEqual(ath.dsc_url2, 'https://host/path')\n        ath = auth.filter_factory({'super_admin_key': 'supertest',\n            'default_swift_cluster':\n                'local#https://host/path/#http://host2/path2/'})(app)\n        self.assertEqual(ath.dsc_url, 'https://host/path')\n        self.assertEqual(ath.dsc_url2, 'http://host2/path2')\n\n    def test_credentials_match_auth_encoder_type(self):\n        plaintext_auth = {'auth': 'plaintext:key'}\n        sha1_key = (\"sha1:T0YFdhqN4uDRWiYLxWa7H2T8AewG4fEYQyJFRLsgcfk=$46c58\"\n                    \"07eb8a32e8f404fea9eaaeb60b7e1207ff1\")\n        sha1_auth = {'auth': sha1_key}\n        sha512_key = (\"sha512:aSm0jEeqIp46T5YLZy1r8+cXs/Xzs1S4VUwVauhBs44=$ef\"\n                      \"7332ec1288bf69c75682eb8d459d5a84baa7e43f45949c242a9af9\"\n                      \"7130ef16ac361fe1aa33a789e218122b83c54ef1923fc015080741\"\n                      \"ca21f6187329f6cb7a\")\n        sha512_auth = {'auth': sha512_key}\n\n        # test all possible config settings work with all possible auth types\n        for auth_type in ('plaintext', 'sha1', 'sha512'):\n            test_auth = auth.filter_factory({'super_admin_key': 'superkey',\n                'auth_type': auth_type})(FakeApp())\n            for detail in (plaintext_auth, sha1_auth, sha512_auth):\n                self.assertTrue(test_auth.credentials_match(detail, 'key'))\n            # test invalid auth type stored\n            invalid_detail = {'auth': 'Junk:key'}\n            test_auth.logger = mock.Mock()\n            self.assertFalse(test_auth.credentials_match(invalid_detail,\n                                                         'key'))\n            # make sure error is logged\n            test_auth.logger.called_once_with('Invalid auth_type Junk')\n\n    def test_top_level_denied(self):\n        resp = Request.blank('/').get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n\n    def test_anon(self):\n        resp = Request.blank('/v1/AUTH_account').get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n        self.assertEqual(resp.environ['swift.authorize'],\n                         self.test_auth.authorize)\n\n    def test_auth_deny_non_reseller_prefix(self):\n        resp = Request.blank('/v1/BLAH_account',\n            headers={'X-Auth-Token': 'BLAH_t'}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n        self.assertEqual(resp.environ['swift.authorize'],\n                         self.test_auth.denied_response)\n\n    def test_auth_deny_non_reseller_prefix_no_override(self):\n        fake_authorize = lambda x: Response(status='500 Fake')\n        resp = Request.blank('/v1/BLAH_account',\n            headers={'X-Auth-Token': 'BLAH_t'},\n            environ={'swift.authorize': fake_authorize}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(resp.environ['swift.authorize'], fake_authorize)\n\n    def test_auth_no_reseller_prefix_deny(self):\n        # Ensures that when we have no reseller prefix, we don't deny a request\n        # outright but set up a denial swift.authorize and pass the request on\n        # down the chain.\n        local_app = FakeApp()\n        local_auth = auth.filter_factory({'super_admin_key': 'supertest',\n                                          'reseller_prefix': ''})(local_app)\n        resp = Request.blank('/v1/account',\n            headers={'X-Auth-Token': 't'}).get_response(local_auth)\n        self.assertEqual(resp.status_int, 401)\n        # one for checking auth, two for request passed along\n        self.assertEqual(local_app.calls, 2)\n        self.assertEqual(resp.environ['swift.authorize'],\n                         local_auth.denied_response)\n\n    def test_auth_no_reseller_prefix_allow(self):\n        # Ensures that when we have no reseller prefix, we can still allow\n        # access if our auth server accepts requests\n        local_app = FakeApp(iter([\n            ('200 Ok', {},\n             json.dumps({'account': 'act', 'user': 'act:usr',\n                         'account_id': 'AUTH_cfa',\n                         'groups': [{'name': 'act:usr'}, {'name': 'act'},\n                                    {'name': '.admin'}],\n                         'expires': time() + 60})),\n            ('204 No Content', {}, '')]))\n        local_auth = auth.filter_factory({'super_admin_key': 'supertest',\n                                          'reseller_prefix': ''})(local_app)\n        resp = Request.blank('/v1/act',\n            headers={'X-Auth-Token': 't'}).get_response(local_auth)\n        self.assertEqual(resp.status_int, 204)\n        self.assertEqual(local_app.calls, 2)\n        self.assertEqual(resp.environ['swift.authorize'],\n                         local_auth.authorize)\n\n    def test_auth_no_reseller_prefix_no_token(self):\n        # Check that normally we set up a call back to our authorize.\n        local_auth = \\\n            auth.filter_factory({'super_admin_key': 'supertest',\n                                 'reseller_prefix': ''})(FakeApp(iter([])))\n        resp = Request.blank('/v1/account').get_response(local_auth)\n        self.assertEqual(resp.status_int, 401)\n        self.assertEqual(resp.environ['swift.authorize'],\n                         local_auth.authorize)\n        # Now make sure we don't override an existing swift.authorize when we\n        # have no reseller prefix.\n        local_auth = \\\n            auth.filter_factory({'super_admin_key': 'supertest',\n                                 'reseller_prefix': ''})(FakeApp())\n        local_authorize = lambda req: Response('test')\n        resp = Request.blank('/v1/account', environ={'swift.authorize':\n            local_authorize}).get_response(local_auth)\n        self.assertEqual(resp.status_int, 200)\n        self.assertEqual(resp.environ['swift.authorize'], local_authorize)\n\n    def test_auth_fail(self):\n        resp = Request.blank('/v1/AUTH_cfa',\n            headers={'X-Auth-Token': 'AUTH_t'}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n\n    def test_auth_success(self):\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {},\n             json.dumps({'account': 'act', 'user': 'act:usr',\n                         'account_id': 'AUTH_cfa',\n                         'groups': [{'name': 'act:usr'}, {'name': 'act'},\n                                    {'name': '.admin'}],\n                         'expires': time() + 60})),\n            ('204 No Content', {}, '')]))\n        resp = Request.blank('/v1/AUTH_cfa',\n            headers={'X-Auth-Token': 'AUTH_t'}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 204)\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n    def test_auth_memcache(self):\n        # First run our test without memcache, showing we need to return the\n        # token contents twice.\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {},\n             json.dumps({'account': 'act', 'user': 'act:usr',\n                         'account_id': 'AUTH_cfa',\n                         'groups': [{'name': 'act:usr'}, {'name': 'act'},\n                                    {'name': '.admin'}],\n                         'expires': time() + 60})),\n            ('204 No Content', {}, ''),\n            ('200 Ok', {},\n             json.dumps({'account': 'act', 'user': 'act:usr',\n                         'account_id': 'AUTH_cfa',\n                         'groups': [{'name': 'act:usr'}, {'name': 'act'},\n                                    {'name': '.admin'}],\n                         'expires': time() + 60})),\n            ('204 No Content', {}, '')]))\n        resp = Request.blank('/v1/AUTH_cfa',\n            headers={'X-Auth-Token': 'AUTH_t'}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 204)\n        resp = Request.blank('/v1/AUTH_cfa',\n            headers={'X-Auth-Token': 'AUTH_t'}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 204)\n        self.assertEqual(self.test_auth.app.calls, 4)\n        # Now run our test with memcache, showing we no longer need to return\n        # the token contents twice.\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {},\n             json.dumps({'account': 'act', 'user': 'act:usr',\n                         'account_id': 'AUTH_cfa',\n                         'groups': [{'name': 'act:usr'}, {'name': 'act'},\n                                    {'name': '.admin'}],\n                         'expires': time() + 60})),\n            ('204 No Content', {}, ''),\n            # Don't need a second token object returned if memcache is used\n            ('204 No Content', {}, '')]))\n        fake_memcache = FakeMemcache()\n        resp = Request.blank('/v1/AUTH_cfa',\n            headers={'X-Auth-Token': 'AUTH_t'},\n            environ={'swift.cache': fake_memcache}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 204)\n        resp = Request.blank('/v1/AUTH_cfa',\n            headers={'X-Auth-Token': 'AUTH_t'},\n            environ={'swift.cache': fake_memcache}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 204)\n        self.assertEqual(self.test_auth.app.calls, 3)\n\n    def test_auth_just_expired(self):\n        self.test_auth.app = FakeApp(iter([\n            # Request for token (which will have expired)\n            ('200 Ok', {},\n             json.dumps({'account': 'act', 'user': 'act:usr',\n                         'account_id': 'AUTH_cfa',\n                         'groups': [{'name': 'act:usr'}, {'name': 'act'},\n                                    {'name': '.admin'}],\n                         'expires': time() - 1})),\n            # Request to delete token\n            ('204 No Content', {}, '')]))\n        resp = Request.blank('/v1/AUTH_cfa',\n            headers={'X-Auth-Token': 'AUTH_t'}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n    def test_middleware_storage_token(self):\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {},\n             json.dumps({'account': 'act', 'user': 'act:usr',\n                         'account_id': 'AUTH_cfa',\n                         'groups': [{'name': 'act:usr'}, {'name': 'act'},\n                                    {'name': '.admin'}],\n                         'expires': time() + 60})),\n            ('204 No Content', {}, '')]))\n        resp = Request.blank('/v1/AUTH_cfa',\n            headers={'X-Storage-Token': 'AUTH_t'}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 204)\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n    def test_authorize_bad_path(self):\n        req = Request.blank('/badpath')\n        resp = self.test_auth.authorize(req)\n        self.assertEqual(resp.status_int, 401)\n        req = Request.blank('/badpath')\n        req.remote_user = 'act:usr,act,AUTH_cfa'\n        resp = self.test_auth.authorize(req)\n        self.assertEqual(resp.status_int, 403)\n\n    def test_authorize_account_access(self):\n        req = Request.blank('/v1/AUTH_cfa')\n        req.remote_user = 'act:usr,act,AUTH_cfa'\n        self.assertEqual(self.test_auth.authorize(req), None)\n        req = Request.blank('/v1/AUTH_cfa')\n        req.remote_user = 'act:usr,act'\n        resp = self.test_auth.authorize(req)\n        self.assertEqual(resp.status_int, 403)\n\n    def test_authorize_acl_group_access(self):\n        req = Request.blank('/v1/AUTH_cfa')\n        req.remote_user = 'act:usr,act'\n        resp = self.test_auth.authorize(req)\n        self.assertEqual(resp.status_int, 403)\n        req = Request.blank('/v1/AUTH_cfa')\n        req.remote_user = 'act:usr,act'\n        req.acl = 'act'\n        self.assertEqual(self.test_auth.authorize(req), None)\n        req = Request.blank('/v1/AUTH_cfa')\n        req.remote_user = 'act:usr,act'\n        req.acl = 'act:usr'\n        self.assertEqual(self.test_auth.authorize(req), None)\n        req = Request.blank('/v1/AUTH_cfa')\n        req.remote_user = 'act:usr,act'\n        req.acl = 'act2'\n        resp = self.test_auth.authorize(req)\n        self.assertEqual(resp.status_int, 403)\n        req = Request.blank('/v1/AUTH_cfa')\n        req.remote_user = 'act:usr,act'\n        req.acl = 'act:usr2'\n        resp = self.test_auth.authorize(req)\n        self.assertEqual(resp.status_int, 403)\n\n    def test_deny_cross_reseller(self):\n        # Tests that cross-reseller is denied, even if ACLs/group names match\n        req = Request.blank('/v1/OTHER_cfa')\n        req.remote_user = 'act:usr,act,AUTH_cfa'\n        req.acl = 'act'\n        resp = self.test_auth.authorize(req)\n        self.assertEqual(resp.status_int, 403)\n\n    def test_authorize_acl_referrer_access(self):\n        req = Request.blank('/v1/AUTH_cfa/c')\n        req.remote_user = 'act:usr,act'\n        resp = self.test_auth.authorize(req)\n        self.assertEqual(resp.status_int, 403)\n        req = Request.blank('/v1/AUTH_cfa/c')\n        req.remote_user = 'act:usr,act'\n        req.acl = '.r:*,.rlistings'\n        self.assertEqual(self.test_auth.authorize(req), None)\n        req = Request.blank('/v1/AUTH_cfa/c')\n        req.remote_user = 'act:usr,act'\n        req.acl = '.r:*'  # No listings allowed\n        resp = self.test_auth.authorize(req)\n        self.assertEqual(resp.status_int, 403)\n        req = Request.blank('/v1/AUTH_cfa/c')\n        req.remote_user = 'act:usr,act'\n        req.acl = '.r:.example.com,.rlistings'\n        resp = self.test_auth.authorize(req)\n        self.assertEqual(resp.status_int, 403)\n        req = Request.blank('/v1/AUTH_cfa/c')\n        req.remote_user = 'act:usr,act'\n        req.referer = 'http://www.example.com/index.html'\n        req.acl = '.r:.example.com,.rlistings'\n        self.assertEqual(self.test_auth.authorize(req), None)\n        req = Request.blank('/v1/AUTH_cfa/c')\n        resp = self.test_auth.authorize(req)\n        self.assertEqual(resp.status_int, 401)\n        req = Request.blank('/v1/AUTH_cfa/c')\n        req.acl = '.r:*,.rlistings'\n        self.assertEqual(self.test_auth.authorize(req), None)\n        req = Request.blank('/v1/AUTH_cfa/c')\n        req.acl = '.r:*'  # No listings allowed\n        resp = self.test_auth.authorize(req)\n        self.assertEqual(resp.status_int, 401)\n        req = Request.blank('/v1/AUTH_cfa/c')\n        req.acl = '.r:.example.com,.rlistings'\n        resp = self.test_auth.authorize(req)\n        self.assertEqual(resp.status_int, 401)\n        req = Request.blank('/v1/AUTH_cfa/c')\n        req.referer = 'http://www.example.com/index.html'\n        req.acl = '.r:.example.com,.rlistings'\n        self.assertEqual(self.test_auth.authorize(req), None)\n\n    def test_detect_reseller_request(self):\n        req = self._make_request('/v1/AUTH_admin',\n                                 headers={'X-Auth-Token': 'AUTH_t'})\n        cache_key = 'AUTH_/auth/AUTH_t'\n        cache_entry = (time() + 3600, '.reseller_admin')\n        req.environ['swift.cache'].set(cache_key, cache_entry)\n        req.get_response(self.test_auth)\n        self.assertTrue(req.environ.get('reseller_request'))\n\n    def test_account_put_permissions(self):\n        req = Request.blank('/v1/AUTH_new', environ={'REQUEST_METHOD': 'PUT'})\n        req.remote_user = 'act:usr,act'\n        resp = self.test_auth.authorize(req)\n        self.assertEqual(resp.status_int, 403)\n\n        req = Request.blank('/v1/AUTH_new', environ={'REQUEST_METHOD': 'PUT'})\n        req.remote_user = 'act:usr,act,AUTH_other'\n        resp = self.test_auth.authorize(req)\n        self.assertEqual(resp.status_int, 403)\n\n        # Even PUTs to your own account as account admin should fail\n        req = Request.blank('/v1/AUTH_old', environ={'REQUEST_METHOD': 'PUT'})\n        req.remote_user = 'act:usr,act,AUTH_old'\n        resp = self.test_auth.authorize(req)\n        self.assertEqual(resp.status_int, 403)\n\n        req = Request.blank('/v1/AUTH_new', environ={'REQUEST_METHOD': 'PUT'})\n        req.remote_user = 'act:usr,act,.reseller_admin'\n        resp = self.test_auth.authorize(req)\n        self.assertEqual(resp, None)\n\n        # .super_admin is not something the middleware should ever see or care\n        # about\n        req = Request.blank('/v1/AUTH_new', environ={'REQUEST_METHOD': 'PUT'})\n        req.remote_user = 'act:usr,act,.super_admin'\n        resp = self.test_auth.authorize(req)\n        self.assertEqual(resp.status_int, 403)\n\n    def test_account_delete_permissions(self):\n        req = Request.blank('/v1/AUTH_new',\n                            environ={'REQUEST_METHOD': 'DELETE'})\n        req.remote_user = 'act:usr,act'\n        resp = self.test_auth.authorize(req)\n        self.assertEqual(resp.status_int, 403)\n\n        req = Request.blank('/v1/AUTH_new',\n                            environ={'REQUEST_METHOD': 'DELETE'})\n        req.remote_user = 'act:usr,act,AUTH_other'\n        resp = self.test_auth.authorize(req)\n        self.assertEqual(resp.status_int, 403)\n\n        # Even DELETEs to your own account as account admin should fail\n        req = Request.blank('/v1/AUTH_old',\n                            environ={'REQUEST_METHOD': 'DELETE'})\n        req.remote_user = 'act:usr,act,AUTH_old'\n        resp = self.test_auth.authorize(req)\n        self.assertEqual(resp.status_int, 403)\n\n        req = Request.blank('/v1/AUTH_new',\n                            environ={'REQUEST_METHOD': 'DELETE'})\n        req.remote_user = 'act:usr,act,.reseller_admin'\n        resp = self.test_auth.authorize(req)\n        self.assertEqual(resp, None)\n\n        # .super_admin is not something the middleware should ever see or care\n        # about\n        req = Request.blank('/v1/AUTH_new',\n                            environ={'REQUEST_METHOD': 'DELETE'})\n        req.remote_user = 'act:usr,act,.super_admin'\n        resp = self.test_auth.authorize(req)\n        resp = self.test_auth.authorize(req)\n        self.assertEqual(resp.status_int, 403)\n\n    def test_get_token_fail(self):\n        resp = Request.blank('/auth/v1.0').get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n        resp = Request.blank('/auth/v1.0',\n            headers={'X-Auth-User': 'act:usr',\n                     'X-Auth-Key': 'key'}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n\n    def test_get_token_fail_invalid_key(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object\n            ('200 Ok', {},\n             json.dumps({\"auth\": \"plaintext:key\",\n                         \"groups\": [{'name': \"act:usr\"}, {'name': \"act\"},\n                                    {'name': \".admin\"}]}))]))\n        resp = Request.blank('/auth/v1.0',\n            headers={'X-Auth-User': 'act:usr',\n                     'X-Auth-Key': 'invalid'}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_get_token_fail_invalid_x_auth_user_format(self):\n        resp = Request.blank('/auth/v1/act/auth',\n            headers={'X-Auth-User': 'usr',\n                     'X-Auth-Key': 'key'}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n\n    def test_get_token_fail_non_matching_account_in_request(self):\n        resp = Request.blank('/auth/v1/act/auth',\n            headers={'X-Auth-User': 'act2:usr',\n                     'X-Auth-Key': 'key'}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n\n    def test_get_token_fail_bad_path(self):\n        resp = Request.blank('/auth/v1/act/auth/invalid',\n            headers={'X-Auth-User': 'act:usr',\n                     'X-Auth-Key': 'key'}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 400)\n\n    def test_get_token_fail_missing_key(self):\n        resp = Request.blank('/auth/v1/act/auth',\n            headers={'X-Auth-User': 'act:usr'}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n\n    def test_get_token_fail_get_user_details(self):\n        self.test_auth.app = FakeApp(iter([\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v1.0',\n            headers={'X-Auth-User': 'act:usr',\n                     'X-Auth-Key': 'key'}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_get_token_fail_get_account(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object\n            ('200 Ok', {},\n             json.dumps({\"auth\": \"plaintext:key\",\n                         \"groups\": [{'name': \"act:usr\"}, {'name': \"act\"},\n                                    {'name': \".admin\"}]})),\n            # GET of account\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v1.0',\n            headers={'X-Auth-User': 'act:usr',\n                     'X-Auth-Key': 'key'}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n    def test_get_token_fail_put_new_token(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object\n            ('200 Ok', {},\n             json.dumps({\"auth\": \"plaintext:key\",\n                         \"groups\": [{'name': \"act:usr\"}, {'name': \"act\"},\n                                    {'name': \".admin\"}]})),\n            # GET of account\n            ('204 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, ''),\n            # PUT of new token\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v1.0',\n            headers={'X-Auth-User': 'act:usr',\n                     'X-Auth-Key': 'key'}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 3)\n\n    def test_get_token_fail_post_to_user(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object\n            ('200 Ok', {},\n             json.dumps({\"auth\": \"plaintext:key\",\n                         \"groups\": [{'name': \"act:usr\"}, {'name': \"act\"},\n                                    {'name': \".admin\"}]})),\n            # GET of account\n            ('204 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, ''),\n            # PUT of new token\n            ('201 Created', {}, ''),\n            # POST of token to user object\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v1.0',\n            headers={'X-Auth-User': 'act:usr',\n                     'X-Auth-Key': 'key'}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 4)\n\n    def test_get_token_fail_get_services(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object\n            ('200 Ok', {},\n             json.dumps({\"auth\": \"plaintext:key\",\n                         \"groups\": [{'name': \"act:usr\"}, {'name': \"act\"},\n                                    {'name': \".admin\"}]})),\n            # GET of account\n            ('204 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, ''),\n            # PUT of new token\n            ('201 Created', {}, ''),\n            # POST of token to user object\n            ('204 No Content', {}, ''),\n            # GET of services object\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v1.0',\n            headers={'X-Auth-User': 'act:usr',\n                     'X-Auth-Key': 'key'}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 5)\n\n    def test_get_token_fail_get_existing_token(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object\n            ('200 Ok', {'X-Object-Meta-Auth-Token': 'AUTH_tktest'},\n             json.dumps({\"auth\": \"plaintext:key\",\n                         \"groups\": [{'name': \"act:usr\"}, {'name': \"act\"},\n                                    {'name': \".admin\"}]})),\n            # GET of token\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v1.0',\n            headers={'X-Auth-User': 'act:usr',\n                     'X-Auth-Key': 'key'}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n    def test_get_token_success_v1_0(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object\n            ('200 Ok', {},\n             json.dumps({\"auth\": \"plaintext:key\",\n                         \"groups\": [{'name': \"act:usr\"}, {'name': \"act\"},\n                                    {'name': \".admin\"}]})),\n            # GET of account\n            ('204 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, ''),\n            # PUT of new token\n            ('201 Created', {}, ''),\n            # POST of token to user object\n            ('204 No Content', {}, ''),\n            # GET of services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n             \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}}))]))\n        resp = Request.blank('/auth/v1.0',\n            headers={'X-Auth-User': 'act:usr',\n                     'X-Auth-Key': 'key'}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 200)\n        self.assertEqual(resp.content_type, CONTENT_TYPE_JSON)\n        self.assertTrue(resp.headers.get('x-auth-token',\n            '').startswith('AUTH_tk'), resp.headers.get('x-auth-token'))\n        self.assertEqual(resp.headers.get('x-auth-token'),\n                         resp.headers.get('x-storage-token'))\n        self.assertEqual(resp.headers.get('x-storage-url'),\n                         'http://127.0.0.1:8080/v1/AUTH_cfa')\n        self.assertEqual(json.loads(resp.body),\n            {\"storage\": {\"default\": \"local\",\n             \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}})\n        self.assertEqual(self.test_auth.app.calls, 5)\n\n    def test_get_token_success_v1_0_with_user_token_life(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object\n            ('200 Ok', {},\n             json.dumps({\"auth\": \"plaintext:key\",\n                         \"groups\": [{'name': \"act:usr\"}, {'name': \"act\"},\n                                    {'name': \".admin\"}]})),\n            # GET of account\n            ('204 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, ''),\n            # PUT of new token\n            ('201 Created', {}, ''),\n            # POST of token to user object\n            ('204 No Content', {}, ''),\n            # GET of services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n             \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}}))]))\n        resp = Request.blank('/auth/v1.0',\n            headers={'X-Auth-User': 'act:usr',\n                     'X-Auth-Key': 'key',\n                     'X-Auth-Token-Lifetime': 10}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 200)\n        self.assertEqual(resp.content_type, CONTENT_TYPE_JSON)\n        left = int(resp.headers['x-auth-token-expires'])\n        self.assertTrue(left > 0, '%d > 0' % left)\n        self.assertTrue(left <= 10, '%d <= 10' % left)\n        self.assertTrue(resp.headers.get('x-auth-token',\n            '').startswith('AUTH_tk'), resp.headers.get('x-auth-token'))\n        self.assertEqual(resp.headers.get('x-auth-token'),\n                         resp.headers.get('x-storage-token'))\n        self.assertEqual(resp.headers.get('x-storage-url'),\n                         'http://127.0.0.1:8080/v1/AUTH_cfa')\n        self.assertEqual(json.loads(resp.body),\n            {\"storage\": {\"default\": \"local\",\n             \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}})\n        self.assertEqual(self.test_auth.app.calls, 5)\n\n    def test_get_token_success_v1_0_with_user_token_life_past_max(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object\n            ('200 Ok', {},\n             json.dumps({\"auth\": \"plaintext:key\",\n                         \"groups\": [{'name': \"act:usr\"}, {'name': \"act\"},\n                                    {'name': \".admin\"}]})),\n            # GET of account\n            ('204 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, ''),\n            # PUT of new token\n            ('201 Created', {}, ''),\n            # POST of token to user object\n            ('204 No Content', {}, ''),\n            # GET of services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n             \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}}))]))\n        req = Request.blank(\n            '/auth/v1.0',\n            headers={'X-Auth-User': 'act:usr',\n                     'X-Auth-Key': 'key',\n                     'X-Auth-Token-Lifetime': MAX_TOKEN_LIFE * 10})\n        resp = req.get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 200)\n        self.assertEqual(resp.content_type, CONTENT_TYPE_JSON)\n        left = int(resp.headers['x-auth-token-expires'])\n        self.assertTrue(left > DEFAULT_TOKEN_LIFE,\n                        '%d > %d' % (left, DEFAULT_TOKEN_LIFE))\n        self.assertTrue(left <= MAX_TOKEN_LIFE,\n                        '%d <= %d' % (left, MAX_TOKEN_LIFE))\n        self.assertTrue(resp.headers.get('x-auth-token',\n            '').startswith('AUTH_tk'), resp.headers.get('x-auth-token'))\n        self.assertEqual(resp.headers.get('x-auth-token'),\n                         resp.headers.get('x-storage-token'))\n        self.assertEqual(resp.headers.get('x-storage-url'),\n                         'http://127.0.0.1:8080/v1/AUTH_cfa')\n        self.assertEqual(json.loads(resp.body),\n            {\"storage\": {\"default\": \"local\",\n             \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}})\n        self.assertEqual(self.test_auth.app.calls, 5)\n\n    def test_get_token_success_v1_act_auth(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object\n            ('200 Ok', {},\n             json.dumps({\"auth\": \"plaintext:key\",\n                         \"groups\": [{'name': \"act:usr\"}, {'name': \"act\"},\n                                    {'name': \".admin\"}]})),\n            # GET of account\n            ('204 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, ''),\n            # PUT of new token\n            ('201 Created', {}, ''),\n            # POST of token to user object\n            ('204 No Content', {}, ''),\n            # GET of services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n             \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}}))]))\n        resp = Request.blank('/auth/v1/act/auth',\n            headers={'X-Storage-User': 'usr',\n                     'X-Storage-Pass': 'key'}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 200)\n        self.assertEqual(resp.content_type, CONTENT_TYPE_JSON)\n        self.assertTrue(resp.headers.get('x-auth-token',\n            '').startswith('AUTH_tk'), resp.headers.get('x-auth-token'))\n        self.assertEqual(resp.headers.get('x-auth-token'),\n                         resp.headers.get('x-storage-token'))\n        self.assertEqual(resp.headers.get('x-storage-url'),\n                         'http://127.0.0.1:8080/v1/AUTH_cfa')\n        self.assertEqual(json.loads(resp.body),\n            {\"storage\": {\"default\": \"local\",\n             \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}})\n        self.assertEqual(self.test_auth.app.calls, 5)\n\n    def test_get_token_success_storage_instead_of_auth(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object\n            ('200 Ok', {},\n             json.dumps({\"auth\": \"plaintext:key\",\n                         \"groups\": [{'name': \"act:usr\"}, {'name': \"act\"},\n                                    {'name': \".admin\"}]})),\n            # GET of account\n            ('204 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, ''),\n            # PUT of new token\n            ('201 Created', {}, ''),\n            # POST of token to user object\n            ('204 No Content', {}, ''),\n            # GET of services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n             \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}}))]))\n        resp = Request.blank('/auth/v1.0',\n            headers={'X-Storage-User': 'act:usr',\n                     'X-Storage-Pass': 'key'}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 200)\n        self.assertEqual(resp.content_type, CONTENT_TYPE_JSON)\n        self.assertTrue(resp.headers.get('x-auth-token',\n            '').startswith('AUTH_tk'), resp.headers.get('x-auth-token'))\n        self.assertEqual(resp.headers.get('x-auth-token'),\n                         resp.headers.get('x-storage-token'))\n        self.assertEqual(resp.headers.get('x-storage-url'),\n                         'http://127.0.0.1:8080/v1/AUTH_cfa')\n        self.assertEqual(json.loads(resp.body),\n            {\"storage\": {\"default\": \"local\",\n             \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}})\n        self.assertEqual(self.test_auth.app.calls, 5)\n\n    def test_get_token_success_v1_act_auth_auth_instead_of_storage(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object\n            ('200 Ok', {},\n             json.dumps({\"auth\": \"plaintext:key\",\n                         \"groups\": [{'name': \"act:usr\"}, {'name': \"act\"},\n                                    {'name': \".admin\"}]})),\n            # GET of account\n            ('204 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, ''),\n            # PUT of new token\n            ('201 Created', {}, ''),\n            # POST of token to user object\n            ('204 No Content', {}, ''),\n            # GET of services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n             \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}}))]))\n        resp = Request.blank('/auth/v1/act/auth',\n            headers={'X-Auth-User': 'act:usr',\n                     'X-Auth-Key': 'key'}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 200)\n        self.assertEqual(resp.content_type, CONTENT_TYPE_JSON)\n        self.assertTrue(resp.headers.get('x-auth-token',\n            '').startswith('AUTH_tk'), resp.headers.get('x-auth-token'))\n        self.assertEqual(resp.headers.get('x-auth-token'),\n                         resp.headers.get('x-storage-token'))\n        self.assertEqual(resp.headers.get('x-storage-url'),\n                         'http://127.0.0.1:8080/v1/AUTH_cfa')\n        self.assertEqual(json.loads(resp.body),\n            {\"storage\": {\"default\": \"local\",\n             \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}})\n        self.assertEqual(self.test_auth.app.calls, 5)\n\n    def test_get_token_success_existing_token(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object\n            ('200 Ok', {'X-Object-Meta-Auth-Token': 'AUTH_tktest'},\n             json.dumps({\"auth\": \"plaintext:key\",\n                         \"groups\": [{'name': \"act:usr\"}, {'name': \"act\"},\n                                    {'name': \".admin\"}]})),\n            # GET of token\n            ('200 Ok', {}, json.dumps({\"account\": \"act\", \"user\": \"usr\",\n             \"account_id\": \"AUTH_cfa\", \"groups\": [{'name': \"act:usr\"},\n             {'name': \"key\"}, {'name': \".admin\"}],\n             \"expires\": 9999999999.9999999})),\n            # GET of services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n             \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}}))]))\n        resp = Request.blank('/auth/v1.0',\n            headers={'X-Auth-User': 'act:usr',\n                     'X-Auth-Key': 'key'}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 200)\n        self.assertEqual(resp.content_type, CONTENT_TYPE_JSON)\n        self.assertEqual(resp.headers.get('x-auth-token'), 'AUTH_tktest')\n        self.assertEqual(resp.headers.get('x-auth-token'),\n                         resp.headers.get('x-storage-token'))\n        self.assertEqual(resp.headers.get('x-storage-url'),\n                         'http://127.0.0.1:8080/v1/AUTH_cfa')\n        self.assertEqual(json.loads(resp.body),\n            {\"storage\": {\"default\": \"local\",\n             \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}})\n        self.assertEqual(self.test_auth.app.calls, 3)\n\n    def test_get_token_success_existing_token_but_request_new_one(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object\n            ('200 Ok', {'X-Object-Meta-Auth-Token': 'AUTH_tktest'},\n             json.dumps({\"auth\": \"plaintext:key\",\n                         \"groups\": [{'name': \"act:usr\"}, {'name': \"act\"},\n                                    {'name': \".admin\"}]})),\n            # DELETE of expired token\n            ('204 No Content', {}, ''),\n            # GET of account\n            ('204 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, ''),\n            # PUT of new token\n            ('201 Created', {}, ''),\n            # POST of token to user object\n            ('204 No Content', {}, ''),\n            # GET of services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n             \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}}))]))\n        resp = Request.blank('/auth/v1.0',\n            headers={'X-Auth-User': 'act:usr',\n                     'X-Auth-Key': 'key',\n                     'X-Auth-New-Token': 'true'}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 200)\n        self.assertEqual(resp.content_type, CONTENT_TYPE_JSON)\n        self.assertNotEqual(resp.headers.get('x-auth-token'), 'AUTH_tktest')\n        self.assertEqual(resp.headers.get('x-auth-token'),\n                         resp.headers.get('x-storage-token'))\n        self.assertEqual(resp.headers.get('x-storage-url'),\n                         'http://127.0.0.1:8080/v1/AUTH_cfa')\n        self.assertEqual(json.loads(resp.body),\n            {\"storage\": {\"default\": \"local\",\n             \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}})\n        self.assertEqual(self.test_auth.app.calls, 6)\n\n    def test_get_token_success_existing_token_expired(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object\n            ('200 Ok', {'X-Object-Meta-Auth-Token': 'AUTH_tktest'},\n             json.dumps({\"auth\": \"plaintext:key\",\n                         \"groups\": [{'name': \"act:usr\"}, {'name': \"act\"},\n                                    {'name': \".admin\"}]})),\n            # GET of token\n            ('200 Ok', {}, json.dumps({\"account\": \"act\", \"user\": \"usr\",\n             \"account_id\": \"AUTH_cfa\", \"groups\": [{'name': \"act:usr\"},\n             {'name': \"key\"}, {'name': \".admin\"}],\n             \"expires\": 0.0})),\n            # DELETE of expired token\n            ('204 No Content', {}, ''),\n            # GET of account\n            ('204 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, ''),\n            # PUT of new token\n            ('201 Created', {}, ''),\n            # POST of token to user object\n            ('204 No Content', {}, ''),\n            # GET of services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n             \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}}))]))\n        resp = Request.blank('/auth/v1.0',\n            headers={'X-Auth-User': 'act:usr',\n                     'X-Auth-Key': 'key'}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 200)\n        self.assertEqual(resp.content_type, CONTENT_TYPE_JSON)\n        self.assertNotEqual(resp.headers.get('x-auth-token'), 'AUTH_tktest')\n        self.assertEqual(resp.headers.get('x-auth-token'),\n                         resp.headers.get('x-storage-token'))\n        self.assertEqual(resp.headers.get('x-storage-url'),\n                         'http://127.0.0.1:8080/v1/AUTH_cfa')\n        self.assertEqual(json.loads(resp.body),\n            {\"storage\": {\"default\": \"local\",\n             \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}})\n        self.assertEqual(self.test_auth.app.calls, 7)\n\n    def test_get_token_success_existing_token_expired_fail_deleting_old(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object\n            ('200 Ok', {'X-Object-Meta-Auth-Token': 'AUTH_tktest'},\n             json.dumps({\"auth\": \"plaintext:key\",\n                         \"groups\": [{'name': \"act:usr\"}, {'name': \"act\"},\n                                    {'name': \".admin\"}]})),\n            # GET of token\n            ('200 Ok', {}, json.dumps({\"account\": \"act\", \"user\": \"usr\",\n             \"account_id\": \"AUTH_cfa\", \"groups\": [{'name': \"act:usr\"},\n             {'name': \"key\"}, {'name': \".admin\"}],\n             \"expires\": 0.0})),\n            # DELETE of expired token\n            ('503 Service Unavailable', {}, ''),\n            # GET of account\n            ('204 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, ''),\n            # PUT of new token\n            ('201 Created', {}, ''),\n            # POST of token to user object\n            ('204 No Content', {}, ''),\n            # GET of services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n             \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}}))]))\n        resp = Request.blank('/auth/v1.0',\n            headers={'X-Auth-User': 'act:usr',\n                     'X-Auth-Key': 'key'}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 200)\n        self.assertEqual(resp.content_type, CONTENT_TYPE_JSON)\n        self.assertNotEqual(resp.headers.get('x-auth-token'), 'AUTH_tktest')\n        self.assertEqual(resp.headers.get('x-auth-token'),\n                         resp.headers.get('x-storage-token'))\n        self.assertEqual(resp.headers.get('x-storage-url'),\n                         'http://127.0.0.1:8080/v1/AUTH_cfa')\n        self.assertEqual(json.loads(resp.body),\n            {\"storage\": {\"default\": \"local\",\n             \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}})\n        self.assertEqual(self.test_auth.app.calls, 7)\n\n    def test_prep_success(self):\n        list_to_iter = [\n            # PUT of .auth account\n            ('201 Created', {}, ''),\n            # PUT of .account_id container\n            ('201 Created', {}, '')]\n        # PUT of .token* containers\n        for x in xrange(16):\n            list_to_iter.append(('201 Created', {}, ''))\n        self.test_auth.app = FakeApp(iter(list_to_iter))\n        resp = Request.blank('/auth/v2/.prep',\n            environ={'REQUEST_METHOD': 'POST'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 204)\n        self.assertEqual(self.test_auth.app.calls, 18)\n\n    def test_prep_bad_method(self):\n        resp = Request.blank('/auth/v2/.prep',\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 400)\n        resp = Request.blank('/auth/v2/.prep',\n            environ={'REQUEST_METHOD': 'HEAD'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 400)\n        resp = Request.blank('/auth/v2/.prep',\n            environ={'REQUEST_METHOD': 'PUT'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 400)\n\n    def test_prep_bad_creds(self):\n        resp = Request.blank('/auth/v2/.prep',\n            environ={'REQUEST_METHOD': 'POST'},\n            headers={'X-Auth-Admin-User': 'super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n        resp = Request.blank('/auth/v2/.prep',\n            environ={'REQUEST_METHOD': 'POST'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'upertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n        resp = Request.blank('/auth/v2/.prep',\n            environ={'REQUEST_METHOD': 'POST'},\n            headers={'X-Auth-Admin-User': '.super_admin'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n        resp = Request.blank('/auth/v2/.prep',\n            environ={'REQUEST_METHOD': 'POST'},\n            headers={'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n        resp = Request.blank('/auth/v2/.prep',\n            environ={'REQUEST_METHOD': 'POST'}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n\n    def test_prep_fail_account_create(self):\n        self.test_auth.app = FakeApp(iter([\n            # PUT of .auth account\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v2/.prep',\n            environ={'REQUEST_METHOD': 'POST'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_prep_fail_token_container_create(self):\n        self.test_auth.app = FakeApp(iter([\n            # PUT of .auth account\n            ('201 Created', {}, ''),\n            # PUT of .token container\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v2/.prep',\n            environ={'REQUEST_METHOD': 'POST'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n    def test_prep_fail_account_id_container_create(self):\n        self.test_auth.app = FakeApp(iter([\n            # PUT of .auth account\n            ('201 Created', {}, ''),\n            # PUT of .token container\n            ('201 Created', {}, ''),\n            # PUT of .account_id container\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v2/.prep',\n            environ={'REQUEST_METHOD': 'POST'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 3)\n\n    def test_get_reseller_success(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of .auth account (list containers)\n            ('200 Ok', {}, json.dumps([\n                {\"name\": \".token\", \"count\": 0, \"bytes\": 0},\n                {\"name\": \".account_id\", \"count\": 0, \"bytes\": 0},\n                {\"name\": \"act\", \"count\": 0, \"bytes\": 0}])),\n            # GET of .auth account (list containers continuation)\n            ('200 Ok', {}, '[]')]))\n        resp = Request.blank('/auth/v2',\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 200)\n        self.assertEqual(resp.content_type, CONTENT_TYPE_JSON)\n        self.assertEqual(json.loads(resp.body),\n                         {\"accounts\": [{\"name\": \"act\"}]})\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:adm\"},\n             {\"name\": \"test\"}, {\"name\": \".admin\"},\n             {\"name\": \".reseller_admin\"}], \"auth\": \"plaintext:key\"})),\n            # GET of .auth account (list containers)\n            ('200 Ok', {}, json.dumps([\n                {\"name\": \".token\", \"count\": 0, \"bytes\": 0},\n                {\"name\": \".account_id\", \"count\": 0, \"bytes\": 0},\n                {\"name\": \"act\", \"count\": 0, \"bytes\": 0}])),\n            # GET of .auth account (list containers continuation)\n            ('200 Ok', {}, '[]')]))\n        resp = Request.blank('/auth/v2',\n            headers={'X-Auth-Admin-User': 'act:adm',\n                     'X-Auth-Admin-Key': 'key'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 200)\n        self.assertEqual(resp.content_type, CONTENT_TYPE_JSON)\n        self.assertEqual(json.loads(resp.body),\n                         {\"accounts\": [{\"name\": \"act\"}]})\n        self.assertEqual(self.test_auth.app.calls, 3)\n\n    def test_get_reseller_fail_bad_creds(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object\n            ('404 Not Found', {}, '')]))\n        resp = Request.blank('/auth/v2',\n            headers={'X-Auth-Admin-User': 'super:admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object (account admin, but not reseller admin)\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:adm\"},\n             {\"name\": \"test\"}, {\"name\": \".admin\"}],\n             \"auth\": \"plaintext:key\"}))]))\n        resp = Request.blank('/auth/v2',\n            headers={'X-Auth-Admin-User': 'act:adm',\n                     'X-Auth-Admin-Key': 'key'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 403)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object (regular user)\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:usr\"},\n             {\"name\": \"test\"}], \"auth\": \"plaintext:key\"}))]))\n        resp = Request.blank('/auth/v2',\n            headers={'X-Auth-Admin-User': 'act:usr',\n                     'X-Auth-Admin-Key': 'key'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 403)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_get_reseller_fail_listing(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of .auth account (list containers)\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v2',\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n        self.test_auth.app = FakeApp(iter([\n            # GET of .auth account (list containers)\n            ('200 Ok', {}, json.dumps([\n                {\"name\": \".token\", \"count\": 0, \"bytes\": 0},\n                {\"name\": \".account_id\", \"count\": 0, \"bytes\": 0},\n                {\"name\": \"act\", \"count\": 0, \"bytes\": 0}])),\n            # GET of .auth account (list containers continuation)\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v2',\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n    def test_get_account_success(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of .services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n                \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}})),\n            # GET of account container (list objects)\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'},\n             json.dumps([\n                {\"name\": \".services\", \"hash\": \"etag\", \"bytes\": 112,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.618110\"},\n                {\"name\": \"tester\", \"hash\": \"etag\", \"bytes\": 104,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.736680\"},\n                {\"name\": \"tester3\", \"hash\": \"etag\", \"bytes\": 86,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:28.135530\"}])),\n            # GET of account container (list objects continuation)\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, '[]')]))\n        resp = Request.blank('/auth/v2/act',\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 200)\n        self.assertEqual(resp.content_type, CONTENT_TYPE_JSON)\n        self.assertEqual(json.loads(resp.body),\n            {'account_id': 'AUTH_cfa',\n             'services': {'storage':\n                          {'default': 'local',\n                          'local': 'http://127.0.0.1:8080/v1/AUTH_cfa'}},\n             'users': [{'name': 'tester'}, {'name': 'tester3'}]})\n        self.assertEqual(self.test_auth.app.calls, 3)\n\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:adm\"},\n             {\"name\": \"test\"}, {\"name\": \".admin\"}],\n             \"auth\": \"plaintext:key\"})),\n            # GET of .services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n                \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}})),\n            # GET of account container (list objects)\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'},\n             json.dumps([\n                {\"name\": \".services\", \"hash\": \"etag\", \"bytes\": 112,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.618110\"},\n                {\"name\": \"tester\", \"hash\": \"etag\", \"bytes\": 104,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.736680\"},\n                {\"name\": \"tester3\", \"hash\": \"etag\", \"bytes\": 86,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:28.135530\"}])),\n            # GET of account container (list objects continuation)\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, '[]')]))\n        resp = Request.blank('/auth/v2/act',\n            headers={'X-Auth-Admin-User': 'act:adm',\n                     'X-Auth-Admin-Key': 'key'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 200)\n        self.assertEqual(resp.content_type, CONTENT_TYPE_JSON)\n        self.assertEqual(json.loads(resp.body),\n            {'account_id': 'AUTH_cfa',\n             'services': {'storage':\n                          {'default': 'local',\n                           'local': 'http://127.0.0.1:8080/v1/AUTH_cfa'}},\n             'users': [{'name': 'tester'}, {'name': 'tester3'}]})\n        self.assertEqual(self.test_auth.app.calls, 4)\n\n    def test_get_account_fail_bad_account_name(self):\n        resp = Request.blank('/auth/v2/.token',\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 400)\n        resp = Request.blank('/auth/v2/.anything',\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 400)\n\n    def test_get_account_fail_creds(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object\n            ('404 Not Found', {}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            headers={'X-Auth-Admin-User': 'super:admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object (account admin, but wrong account)\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act2:adm\"},\n             {\"name\": \"test\"}, {\"name\": \".admin\"}],\n             \"auth\": \"plaintext:key\"}))]))\n        resp = Request.blank('/auth/v2/act',\n            headers={'X-Auth-Admin-User': 'act2:adm',\n                     'X-Auth-Admin-Key': 'key'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 403)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object (regular user)\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:usr\"},\n             {\"name\": \"test\"}], \"auth\": \"plaintext:key\"}))]))\n        resp = Request.blank('/auth/v2/act',\n            headers={'X-Auth-Admin-User': 'act:usr',\n                     'X-Auth-Admin-Key': 'key'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 403)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_get_account_fail_get_services(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of .services object\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n        self.test_auth.app = FakeApp(iter([\n            # GET of .services object\n            ('404 Not Found', {}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 404)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_get_account_fail_listing(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of .services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n                \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}})),\n            # GET of account container (list objects)\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n        self.test_auth.app = FakeApp(iter([\n            # GET of .services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n                \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}})),\n            # GET of account container (list objects)\n            ('404 Not Found', {}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 404)\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n        self.test_auth.app = FakeApp(iter([\n            # GET of .services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n                \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}})),\n            # GET of account container (list objects)\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'},\n             json.dumps([\n                {\"name\": \".services\", \"hash\": \"etag\", \"bytes\": 112,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.618110\"},\n                {\"name\": \"tester\", \"hash\": \"etag\", \"bytes\": 104,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.736680\"},\n                {\"name\": \"tester3\", \"hash\": \"etag\", \"bytes\": 86,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:28.135530\"}])),\n            # GET of account container (list objects continuation)\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 3)\n\n    def test_set_services_new_service(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of .services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n                \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}})),\n            # PUT of new .services object\n            ('204 No Content', {}, '')]))\n        resp = Request.blank('/auth/v2/act/.services',\n            environ={'REQUEST_METHOD': 'POST'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'},\n            body=json.dumps({'new_service': {'new_endpoint': 'new_value'}})\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 200)\n        self.assertEqual(resp.content_type, CONTENT_TYPE_JSON)\n        self.assertEqual(json.loads(resp.body),\n            {'storage': {'default': 'local',\n                         'local': 'http://127.0.0.1:8080/v1/AUTH_cfa'},\n             'new_service': {'new_endpoint': 'new_value'}})\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n    def test_set_services_new_endpoint(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of .services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n                \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}})),\n            # PUT of new .services object\n            ('204 No Content', {}, '')]))\n        resp = Request.blank('/auth/v2/act/.services',\n            environ={'REQUEST_METHOD': 'POST'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'},\n            body=json.dumps({'storage': {'new_endpoint': 'new_value'}})\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 200)\n        self.assertEqual(resp.content_type, CONTENT_TYPE_JSON)\n        self.assertEqual(json.loads(resp.body),\n            {'storage': {'default': 'local',\n                         'local': 'http://127.0.0.1:8080/v1/AUTH_cfa',\n                         'new_endpoint': 'new_value'}})\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n    def test_set_services_update_endpoint(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of .services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n                \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}})),\n            # PUT of new .services object\n            ('204 No Content', {}, '')]))\n        resp = Request.blank('/auth/v2/act/.services',\n            environ={'REQUEST_METHOD': 'POST'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'},\n            body=json.dumps({'storage': {'local': 'new_value'}})\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 200)\n        self.assertEqual(resp.content_type, CONTENT_TYPE_JSON)\n        self.assertEqual(json.loads(resp.body),\n            {'storage': {'default': 'local',\n                         'local': 'new_value'}})\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n    def test_set_services_fail_bad_creds(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object\n            ('404 Not Found', {}, '')]))\n        resp = Request.blank('/auth/v2/act/.services',\n            environ={'REQUEST_METHOD': 'POST'},\n            headers={'X-Auth-Admin-User': 'super:admin',\n                     'X-Auth-Admin-Key': 'supertest'},\n            body=json.dumps({'storage': {'local': 'new_value'}})\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object (account admin, but not reseller admin)\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:adm\"},\n             {\"name\": \"test\"}, {\"name\": \".admin\"}],\n             \"auth\": \"plaintext:key\"}))]))\n        resp = Request.blank('/auth/v2/act/.services',\n            environ={'REQUEST_METHOD': 'POST'},\n            headers={'X-Auth-Admin-User': 'act:adm',\n                     'X-Auth-Admin-Key': 'key'},\n            body=json.dumps({'storage': {'local': 'new_value'}})\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 403)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object (regular user)\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:usr\"},\n             {\"name\": \"test\"}], \"auth\": \"plaintext:key\"}))]))\n        resp = Request.blank('/auth/v2/act/.services',\n            environ={'REQUEST_METHOD': 'POST'},\n            headers={'X-Auth-Admin-User': 'act:usr',\n                     'X-Auth-Admin-Key': 'key'},\n            body=json.dumps({'storage': {'local': 'new_value'}})\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 403)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_set_services_fail_bad_account_name(self):\n        resp = Request.blank('/auth/v2/.act/.services',\n            environ={'REQUEST_METHOD': 'POST'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'},\n            body=json.dumps({'storage': {'local': 'new_value'}})\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 400)\n\n    def test_set_services_fail_bad_json(self):\n        resp = Request.blank('/auth/v2/act/.services',\n            environ={'REQUEST_METHOD': 'POST'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'},\n            body='garbage'\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 400)\n        resp = Request.blank('/auth/v2/act/.services',\n            environ={'REQUEST_METHOD': 'POST'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'},\n            body=''\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 400)\n\n    def test_set_services_fail_get_services(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of .services object\n            ('503 Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v2/act/.services',\n            environ={'REQUEST_METHOD': 'POST'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'},\n            body=json.dumps({'new_service': {'new_endpoint': 'new_value'}})\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n        self.test_auth.app = FakeApp(iter([\n            # GET of .services object\n            ('404 Not Found', {}, '')]))\n        resp = Request.blank('/auth/v2/act/.services',\n            environ={'REQUEST_METHOD': 'POST'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'},\n            body=json.dumps({'new_service': {'new_endpoint': 'new_value'}})\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 404)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_set_services_fail_put_services(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of .services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n                \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}})),\n            # PUT of new .services object\n            ('503 Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v2/act/.services',\n            environ={'REQUEST_METHOD': 'POST'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'},\n            body=json.dumps({'new_service': {'new_endpoint': 'new_value'}})\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n    def test_put_account_success(self):\n        conn = FakeConn(iter([\n            # PUT of storage account itself\n            ('201 Created', {}, '')]))\n        self.test_auth.get_conn = lambda: conn\n        self.test_auth.app = FakeApp(iter([\n            # Initial HEAD of account container to check for pre-existence\n            ('404 Not Found', {}, ''),\n            # PUT of account container\n            ('204 No Content', {}, ''),\n            # PUT of .account_id mapping object\n            ('204 No Content', {}, ''),\n            # PUT of .services object\n            ('204 No Content', {}, ''),\n            # POST to account container updating X-Container-Meta-Account-Id\n            ('204 No Content', {}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'PUT', 'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 201)\n        self.assertEqual(self.test_auth.app.calls, 5)\n        self.assertEqual(conn.calls, 1)\n\n    def test_put_account_success_preexist_but_not_completed(self):\n        conn = FakeConn(iter([\n            # PUT of storage account itself\n            ('201 Created', {}, '')]))\n        self.test_auth.get_conn = lambda: conn\n        self.test_auth.app = FakeApp(iter([\n            # Initial HEAD of account container to check for pre-existence\n            # We're going to show it as existing this time, but with no\n            # X-Container-Meta-Account-Id, indicating a failed previous attempt\n            ('200 Ok', {}, ''),\n            # PUT of .account_id mapping object\n            ('204 No Content', {}, ''),\n            # PUT of .services object\n            ('204 No Content', {}, ''),\n            # POST to account container updating X-Container-Meta-Account-Id\n            ('204 No Content', {}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'PUT', 'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 201)\n        self.assertEqual(self.test_auth.app.calls, 4)\n        self.assertEqual(conn.calls, 1)\n\n    def test_put_account_success_preexist_and_completed(self):\n        conn = FakeConn(iter([\n            # PUT of storage account itself\n            ('201 Created', {}, '')]))\n        self.test_auth.get_conn = lambda: conn\n        self.test_auth.app = FakeApp(iter([\n            # Initial HEAD of account container to check for pre-existence\n            # We're going to show it as existing this time, and with an\n            # X-Container-Meta-Account-Id, indicating it already exists\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'PUT', 'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 202)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_put_account_success_with_given_suffix(self):\n        conn = FakeConn(iter([\n            # PUT of storage account itself\n            ('201 Created', {}, '')]))\n        self.test_auth.get_conn = lambda: conn\n        self.test_auth.app = FakeApp(iter([\n            # Initial HEAD of account container to check for pre-existence\n            ('404 Not Found', {}, ''),\n            # PUT of account container\n            ('204 No Content', {}, ''),\n            # PUT of .account_id mapping object\n            ('204 No Content', {}, ''),\n            # PUT of .services object\n            ('204 No Content', {}, ''),\n            # POST to account container updating X-Container-Meta-Account-Id\n            ('204 No Content', {}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'PUT', 'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest',\n                     'X-Account-Suffix': 'test-suffix'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 201)\n        self.assertEqual(conn.request_path, '/v1/AUTH_test-suffix')\n        self.assertEqual(self.test_auth.app.calls, 5)\n        self.assertEqual(conn.calls, 1)\n\n    def test_put_account_fail_bad_creds(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object\n            ('404 Not Found', {}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'PUT', 'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': 'super:admin',\n                     'X-Auth-Admin-Key': 'supertest'},\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object (account admin, but not reseller admin)\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:adm\"},\n             {\"name\": \"test\"}, {\"name\": \".admin\"}],\n             \"auth\": \"plaintext:key\"}))]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'PUT', 'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': 'act:adm',\n                     'X-Auth-Admin-Key': 'key'},\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 403)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object (regular user)\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:usr\"},\n             {\"name\": \"test\"}], \"auth\": \"plaintext:key\"}))]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'PUT', 'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': 'act:usr',\n                     'X-Auth-Admin-Key': 'key'},\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 403)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_put_account_fail_invalid_account_name(self):\n        resp = Request.blank('/auth/v2/.act',\n            environ={'REQUEST_METHOD': 'PUT', 'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'},\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 400)\n\n    def test_put_account_fail_on_storage_account_put(self):\n        conn = FakeConn(iter([\n            # PUT of storage account itself\n            ('503 Service Unavailable', {}, '')]))\n        self.test_auth.get_conn = lambda: conn\n        self.test_auth.app = FakeApp(iter([\n        ]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'PUT', 'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(conn.calls, 1)\n        self.assertEqual(self.test_auth.app.calls, 0)\n\n    def test_put_account_fail_on_initial_account_head(self):\n        conn = FakeConn(iter([\n            # PUT of storage account itself\n            ('201 Created', {}, '')]))\n        self.test_auth.get_conn = lambda: conn\n        self.test_auth.app = FakeApp(iter([\n            # Initial HEAD of account container to check for pre-existence\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'PUT', 'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_put_account_fail_on_account_marker_put(self):\n        conn = FakeConn(iter([\n            # PUT of storage account itself\n            ('201 Created', {}, '')]))\n        self.test_auth.get_conn = lambda: conn\n        self.test_auth.app = FakeApp(iter([\n            # Initial HEAD of account container to check for pre-existence\n            ('404 Not Found', {}, ''),\n            # PUT of account container\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'PUT', 'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n    def test_put_account_fail_on_account_id_mapping(self):\n        conn = FakeConn(iter([\n            # PUT of storage account itself\n            ('201 Created', {}, '')]))\n        self.test_auth.get_conn = lambda: conn\n        self.test_auth.app = FakeApp(iter([\n            # Initial HEAD of account container to check for pre-existence\n            ('404 Not Found', {}, ''),\n            # PUT of account container\n            ('204 No Content', {}, ''),\n            # PUT of .account_id mapping object\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'PUT', 'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(conn.calls, 1)\n        self.assertEqual(self.test_auth.app.calls, 3)\n\n    def test_put_account_fail_on_services_object(self):\n        conn = FakeConn(iter([\n            # PUT of storage account itself\n            ('201 Created', {}, '')]))\n        self.test_auth.get_conn = lambda: conn\n        self.test_auth.app = FakeApp(iter([\n            # Initial HEAD of account container to check for pre-existence\n            ('404 Not Found', {}, ''),\n            # PUT of account container\n            ('204 No Content', {}, ''),\n            # PUT of .account_id mapping object\n            ('204 No Content', {}, ''),\n            # PUT of .services object\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'PUT', 'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(conn.calls, 1)\n        self.assertEqual(self.test_auth.app.calls, 4)\n\n    def test_put_account_fail_on_post_mapping(self):\n        conn = FakeConn(iter([\n            # PUT of storage account itself\n            ('201 Created', {}, '')]))\n        self.test_auth.get_conn = lambda: conn\n        self.test_auth.app = FakeApp(iter([\n            # Initial HEAD of account container to check for pre-existence\n            ('404 Not Found', {}, ''),\n            # PUT of account container\n            ('204 No Content', {}, ''),\n            # PUT of .account_id mapping object\n            ('204 No Content', {}, ''),\n            # PUT of .services object\n            ('204 No Content', {}, ''),\n            # POST to account container updating X-Container-Meta-Account-Id\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'PUT', 'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(conn.calls, 1)\n        self.assertEqual(self.test_auth.app.calls, 5)\n\n    def test_delete_account_success(self):\n        conn = FakeConn(iter([\n            # DELETE of storage account itself\n            ('204 No Content', {}, '')]))\n        self.test_auth.get_conn = lambda x: conn\n        self.test_auth.app = FakeApp(iter([\n            # Account's container listing, checking for users\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'},\n             json.dumps([\n                {\"name\": \".services\", \"hash\": \"etag\", \"bytes\": 112,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.618110\"}])),\n            # Account's container listing, checking for users (continuation)\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, '[]'),\n            # GET the .services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n                \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}})),\n            # DELETE the .services object\n            ('204 No Content', {}, ''),\n            # DELETE the .account_id mapping object\n            ('204 No Content', {}, ''),\n            # DELETE the account container\n            ('204 No Content', {}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'DELETE',\n                     'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 204)\n        self.assertEqual(self.test_auth.app.calls, 6)\n        self.assertEqual(conn.calls, 1)\n\n    def test_delete_account_success_missing_services(self):\n        self.test_auth.app = FakeApp(iter([\n            # Account's container listing, checking for users\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'},\n             json.dumps([\n                {\"name\": \".services\", \"hash\": \"etag\", \"bytes\": 112,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.618110\"}])),\n            # Account's container listing, checking for users (continuation)\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, '[]'),\n            # GET the .services object\n            ('404 Not Found', {}, ''),\n            # DELETE the .account_id mapping object\n            ('204 No Content', {}, ''),\n            # DELETE the account container\n            ('204 No Content', {}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'DELETE',\n                     'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 204)\n        self.assertEqual(self.test_auth.app.calls, 5)\n\n    def test_delete_account_success_missing_storage_account(self):\n        conn = FakeConn(iter([\n            # DELETE of storage account itself\n            ('404 Not Found', {}, '')]))\n        self.test_auth.get_conn = lambda x: conn\n        self.test_auth.app = FakeApp(iter([\n            # Account's container listing, checking for users\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'},\n             json.dumps([\n                {\"name\": \".services\", \"hash\": \"etag\", \"bytes\": 112,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.618110\"}])),\n            # Account's container listing, checking for users (continuation)\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, '[]'),\n            # GET the .services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n                \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}})),\n            # DELETE the .services object\n            ('204 No Content', {}, ''),\n            # DELETE the .account_id mapping object\n            ('204 No Content', {}, ''),\n            # DELETE the account container\n            ('204 No Content', {}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'DELETE',\n                     'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 204)\n        self.assertEqual(self.test_auth.app.calls, 6)\n        self.assertEqual(conn.calls, 1)\n\n    def test_delete_account_success_missing_account_id_mapping(self):\n        conn = FakeConn(iter([\n            # DELETE of storage account itself\n            ('204 No Content', {}, '')]))\n        self.test_auth.get_conn = lambda x: conn\n        self.test_auth.app = FakeApp(iter([\n            # Account's container listing, checking for users\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'},\n             json.dumps([\n                {\"name\": \".services\", \"hash\": \"etag\", \"bytes\": 112,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.618110\"}])),\n            # Account's container listing, checking for users (continuation)\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, '[]'),\n            # GET the .services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n                \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}})),\n            # DELETE the .services object\n            ('204 No Content', {}, ''),\n            # DELETE the .account_id mapping object\n            ('404 Not Found', {}, ''),\n            # DELETE the account container\n            ('204 No Content', {}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'DELETE',\n                     'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 204)\n        self.assertEqual(self.test_auth.app.calls, 6)\n        self.assertEqual(conn.calls, 1)\n\n    def test_delete_account_success_missing_account_container_at_end(self):\n        conn = FakeConn(iter([\n            # DELETE of storage account itself\n            ('204 No Content', {}, '')]))\n        self.test_auth.get_conn = lambda x: conn\n        self.test_auth.app = FakeApp(iter([\n            # Account's container listing, checking for users\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'},\n             json.dumps([\n                {\"name\": \".services\", \"hash\": \"etag\", \"bytes\": 112,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.618110\"}])),\n            # Account's container listing, checking for users (continuation)\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, '[]'),\n            # GET the .services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n                \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}})),\n            # DELETE the .services object\n            ('204 No Content', {}, ''),\n            # DELETE the .account_id mapping object\n            ('204 No Content', {}, ''),\n            # DELETE the account container\n            ('404 Not Found', {}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'DELETE',\n                     'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 204)\n        self.assertEqual(self.test_auth.app.calls, 6)\n        self.assertEqual(conn.calls, 1)\n\n    def test_delete_account_fail_bad_creds(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object\n            ('404 Not Found', {}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'DELETE',\n                     'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': 'super:admin',\n                     'X-Auth-Admin-Key': 'supertest'},\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object (account admin, but not reseller admin)\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:adm\"},\n             {\"name\": \"test\"}, {\"name\": \".admin\"}],\n             \"auth\": \"plaintext:key\"}))]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'DELETE',\n                     'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': 'act:adm',\n                     'X-Auth-Admin-Key': 'key'},\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 403)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object (regular user)\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:usr\"},\n             {\"name\": \"test\"}], \"auth\": \"plaintext:key\"}))]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'DELETE',\n                     'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': 'act:usr',\n                     'X-Auth-Admin-Key': 'key'},\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 403)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_delete_account_fail_invalid_account_name(self):\n        resp = Request.blank('/auth/v2/.act',\n            environ={'REQUEST_METHOD': 'DELETE'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 400)\n\n    def test_delete_account_fail_not_found(self):\n        self.test_auth.app = FakeApp(iter([\n            # Account's container listing, checking for users\n            ('404 Not Found', {}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'DELETE',\n                     'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 404)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_delete_account_fail_not_found_concurrency(self):\n        self.test_auth.app = FakeApp(iter([\n            # Account's container listing, checking for users\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'},\n             json.dumps([\n                {\"name\": \".services\", \"hash\": \"etag\", \"bytes\": 112,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.618110\"}])),\n            # Account's container listing, checking for users (continuation)\n            ('404 Not Found', {}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'DELETE',\n                     'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 404)\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n    def test_delete_account_fail_list_account(self):\n        self.test_auth.app = FakeApp(iter([\n            # Account's container listing, checking for users\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'DELETE',\n                     'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_delete_account_fail_list_account_concurrency(self):\n        self.test_auth.app = FakeApp(iter([\n            # Account's container listing, checking for users\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'},\n             json.dumps([\n                {\"name\": \".services\", \"hash\": \"etag\", \"bytes\": 112,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.618110\"}])),\n            # Account's container listing, checking for users (continuation)\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'DELETE',\n                     'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n    def test_delete_account_fail_has_users(self):\n        self.test_auth.app = FakeApp(iter([\n            # Account's container listing, checking for users\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'},\n             json.dumps([\n                {\"name\": \".services\", \"hash\": \"etag\", \"bytes\": 112,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.618110\"},\n                {\"name\": \"tester\", \"hash\": \"etag\", \"bytes\": 104,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.736680\"}]))]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'DELETE',\n                     'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 409)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_delete_account_fail_has_users2(self):\n        self.test_auth.app = FakeApp(iter([\n            # Account's container listing, checking for users\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'},\n             json.dumps([\n                {\"name\": \".services\", \"hash\": \"etag\", \"bytes\": 112,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.618110\"}])),\n            # Account's container listing, checking for users (continuation)\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'},\n             json.dumps([\n                {\"name\": \"tester\", \"hash\": \"etag\", \"bytes\": 104,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.736680\"}]))]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'DELETE',\n                     'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 409)\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n    def test_delete_account_fail_get_services(self):\n        self.test_auth.app = FakeApp(iter([\n            # Account's container listing, checking for users\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'},\n             json.dumps([\n                {\"name\": \".services\", \"hash\": \"etag\", \"bytes\": 112,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.618110\"}])),\n            # Account's container listing, checking for users (continuation)\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, '[]'),\n            # GET the .services object\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'DELETE',\n                     'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 3)\n\n    def test_delete_account_fail_delete_storage_account(self):\n        conn = FakeConn(iter([\n            # DELETE of storage account itself\n            ('409 Conflict', {}, '')]))\n        self.test_auth.get_conn = lambda x: conn\n        self.test_auth.app = FakeApp(iter([\n            # Account's container listing, checking for users\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'},\n             json.dumps([\n                {\"name\": \".services\", \"hash\": \"etag\", \"bytes\": 112,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.618110\"}])),\n            # Account's container listing, checking for users (continuation)\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, '[]'),\n            # GET the .services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n                \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}}))]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'DELETE',\n                     'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 409)\n        self.assertEqual(self.test_auth.app.calls, 3)\n        self.assertEqual(conn.calls, 1)\n\n    def test_delete_account_fail_delete_storage_account2(self):\n        conn = FakeConn(iter([\n            # DELETE of storage account itself\n            ('204 No Content', {}, ''),\n            # DELETE of storage account itself\n            ('409 Conflict', {}, '')]))\n        self.test_auth.get_conn = lambda x: conn\n        self.test_auth.app = FakeApp(iter([\n            # Account's container listing, checking for users\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'},\n             json.dumps([\n                {\"name\": \".services\", \"hash\": \"etag\", \"bytes\": 112,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.618110\"}])),\n            # Account's container listing, checking for users (continuation)\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, '[]'),\n            # GET the .services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n                \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\",\n                \"other\": \"http://127.0.0.1:8080/v1/AUTH_cfa2\"}}))]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'DELETE',\n                     'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 3)\n        self.assertEqual(conn.calls, 2)\n\n    def test_delete_account_fail_delete_storage_account3(self):\n        conn = FakeConn(iter([\n            # DELETE of storage account itself\n            ('503 Service Unavailable', {}, '')]))\n        self.test_auth.get_conn = lambda x: conn\n        self.test_auth.app = FakeApp(iter([\n            # Account's container listing, checking for users\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'},\n             json.dumps([\n                {\"name\": \".services\", \"hash\": \"etag\", \"bytes\": 112,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.618110\"}])),\n            # Account's container listing, checking for users (continuation)\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, '[]'),\n            # GET the .services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n                \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}}))]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'DELETE',\n                     'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 3)\n        self.assertEqual(conn.calls, 1)\n\n    def test_delete_account_fail_delete_storage_account4(self):\n        conn = FakeConn(iter([\n            # DELETE of storage account itself\n            ('204 No Content', {}, ''),\n            # DELETE of storage account itself\n            ('503 Service Unavailable', {}, '')]))\n        self.test_auth.get_conn = lambda x: conn\n        self.test_auth.app = FakeApp(iter([\n            # Account's container listing, checking for users\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'},\n             json.dumps([\n                {\"name\": \".services\", \"hash\": \"etag\", \"bytes\": 112,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.618110\"}])),\n            # Account's container listing, checking for users (continuation)\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, '[]'),\n            # GET the .services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n                \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\",\n                \"other\": \"http://127.0.0.1:8080/v1/AUTH_cfa2\"}}))]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'DELETE',\n                     'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 3)\n        self.assertEqual(conn.calls, 2)\n\n    def test_delete_account_fail_delete_services(self):\n        conn = FakeConn(iter([\n            # DELETE of storage account itself\n            ('204 No Content', {}, '')]))\n        self.test_auth.get_conn = lambda x: conn\n        self.test_auth.app = FakeApp(iter([\n            # Account's container listing, checking for users\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'},\n             json.dumps([\n                {\"name\": \".services\", \"hash\": \"etag\", \"bytes\": 112,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.618110\"}])),\n            # Account's container listing, checking for users (continuation)\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, '[]'),\n            # GET the .services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n                \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}})),\n            # DELETE the .services object\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'DELETE',\n                     'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 4)\n        self.assertEqual(conn.calls, 1)\n\n    def test_delete_account_fail_delete_account_id_mapping(self):\n        conn = FakeConn(iter([\n            # DELETE of storage account itself\n            ('204 No Content', {}, '')]))\n        self.test_auth.get_conn = lambda x: conn\n        self.test_auth.app = FakeApp(iter([\n            # Account's container listing, checking for users\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'},\n             json.dumps([\n                {\"name\": \".services\", \"hash\": \"etag\", \"bytes\": 112,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.618110\"}])),\n            # Account's container listing, checking for users (continuation)\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, '[]'),\n            # GET the .services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n                \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}})),\n            # DELETE the .services object\n            ('204 No Content', {}, ''),\n            # DELETE the .account_id mapping object\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'DELETE',\n                     'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 5)\n        self.assertEqual(conn.calls, 1)\n\n    def test_delete_account_fail_delete_account_container(self):\n        conn = FakeConn(iter([\n            # DELETE of storage account itself\n            ('204 No Content', {}, '')]))\n        self.test_auth.get_conn = lambda x: conn\n        self.test_auth.app = FakeApp(iter([\n            # Account's container listing, checking for users\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'},\n             json.dumps([\n                {\"name\": \".services\", \"hash\": \"etag\", \"bytes\": 112,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.618110\"}])),\n            # Account's container listing, checking for users (continuation)\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, '[]'),\n            # GET the .services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n                \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}})),\n            # DELETE the .services object\n            ('204 No Content', {}, ''),\n            # DELETE the .account_id mapping object\n            ('204 No Content', {}, ''),\n            # DELETE the account container\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v2/act',\n            environ={'REQUEST_METHOD': 'DELETE',\n                     'swift.cache': FakeMemcache()},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 6)\n        self.assertEqual(conn.calls, 1)\n\n    def test_get_user_success(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object\n            ('200 Ok', {}, json.dumps(\n                {\"groups\": [{\"name\": \"act:usr\"}, {\"name\": \"act\"},\n                            {\"name\": \".admin\"}],\n                 \"auth\": \"plaintext:key\"}))]))\n        resp = Request.blank('/auth/v2/act/usr',\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 200)\n        self.assertEqual(resp.content_type, CONTENT_TYPE_JSON)\n        self.assertEqual(resp.body, json.dumps(\n            {\"groups\": [{\"name\": \"act:usr\"}, {\"name\": \"act\"},\n                        {\"name\": \".admin\"}],\n             \"auth\": \"plaintext:key\"}))\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_get_user_fail_no_super_admin_key(self):\n        local_auth = auth.filter_factory({})(FakeApp(iter([\n            # GET of user object (but we should never get here)\n            ('200 Ok', {}, json.dumps(\n                {\"groups\": [{\"name\": \"act:usr\"}, {\"name\": \"act\"},\n                            {\"name\": \".admin\"}],\n                 \"auth\": \"plaintext:key\"}))])))\n        resp = Request.blank('/auth/v2/act/usr',\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(local_auth)\n        self.assertEqual(resp.status_int, 404)\n        self.assertEqual(local_auth.app.calls, 0)\n\n    def test_get_user_groups_success(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of account container (list objects)\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'},\n             json.dumps([\n                {\"name\": \".services\", \"hash\": \"etag\", \"bytes\": 112,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.618110\"},\n                {\"name\": \"tester\", \"hash\": \"etag\", \"bytes\": 104,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.736680\"},\n                {\"name\": \"tester3\", \"hash\": \"etag\", \"bytes\": 86,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:28.135530\"}])),\n            # GET of user object\n            ('200 Ok', {}, json.dumps(\n                {\"groups\": [{\"name\": \"act:tester\"}, {\"name\": \"act\"},\n                            {\"name\": \".admin\"}],\n                 \"auth\": \"plaintext:key\"})),\n            # GET of user object\n            ('200 Ok', {}, json.dumps(\n                {\"groups\": [{\"name\": \"act:tester3\"}, {\"name\": \"act\"}],\n                 \"auth\": \"plaintext:key3\"})),\n            # GET of account container (list objects continuation)\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, '[]')]))\n        resp = Request.blank('/auth/v2/act/.groups',\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 200)\n        self.assertEqual(resp.content_type, CONTENT_TYPE_JSON)\n        self.assertEqual(resp.body, json.dumps(\n            {\"groups\": [{\"name\": \".admin\"}, {\"name\": \"act\"},\n                        {\"name\": \"act:tester\"}, {\"name\": \"act:tester3\"}]}))\n        self.assertEqual(self.test_auth.app.calls, 4)\n\n    def test_get_user_groups_success2(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of account container (list objects)\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'},\n             json.dumps([\n                {\"name\": \".services\", \"hash\": \"etag\", \"bytes\": 112,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.618110\"},\n                {\"name\": \"tester\", \"hash\": \"etag\", \"bytes\": 104,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.736680\"}])),\n            # GET of user object\n            ('200 Ok', {}, json.dumps(\n                {\"groups\": [{\"name\": \"act:tester\"}, {\"name\": \"act\"},\n                            {\"name\": \".admin\"}],\n                 \"auth\": \"plaintext:key\"})),\n            # GET of account container (list objects continuation)\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'},\n             json.dumps([\n                {\"name\": \"tester3\", \"hash\": \"etag\", \"bytes\": 86,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:28.135530\"}])),\n            # GET of user object\n            ('200 Ok', {}, json.dumps(\n                {\"groups\": [{\"name\": \"act:tester3\"}, {\"name\": \"act\"}],\n                 \"auth\": \"plaintext:key3\"})),\n            # GET of account container (list objects continuation)\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, '[]')]))\n        resp = Request.blank('/auth/v2/act/.groups',\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 200)\n        self.assertEqual(resp.content_type, CONTENT_TYPE_JSON)\n        self.assertEqual(resp.body, json.dumps(\n            {\"groups\": [{\"name\": \".admin\"}, {\"name\": \"act\"},\n                        {\"name\": \"act:tester\"}, {\"name\": \"act:tester3\"}]}))\n        self.assertEqual(self.test_auth.app.calls, 5)\n\n    def test_get_user_fail_invalid_account(self):\n        resp = Request.blank('/auth/v2/.invalid/usr',\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 400)\n\n    def test_get_user_fail_invalid_user(self):\n        resp = Request.blank('/auth/v2/act/.invalid',\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 400)\n\n    def test_get_user_fail_bad_creds(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object\n            ('404 Not Found', {}, '')]))\n        resp = Request.blank('/auth/v2/act/usr',\n            headers={'X-Auth-Admin-User': 'super:admin',\n                     'X-Auth-Admin-Key': 'supertest'},\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object (regular user)\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:usr\"},\n             {\"name\": \"test\"}], \"auth\": \"plaintext:key\"}))]))\n        resp = Request.blank('/auth/v2/act/usr',\n            headers={'X-Auth-Admin-User': 'act:usr',\n                     'X-Auth-Admin-Key': 'key'},\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 403)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_get_user_account_admin_success(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object (account admin, but not reseller admin)\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:adm\"},\n             {\"name\": \"test\"}, {\"name\": \".admin\"}],\n             \"auth\": \"plaintext:key\"})),\n            # GET of requested user object\n            ('200 Ok', {}, json.dumps(\n                {\"groups\": [{\"name\": \"act:usr\"}, {\"name\": \"act\"}],\n                 \"auth\": \"plaintext:key\"}))]))\n        resp = Request.blank('/auth/v2/act/usr',\n            headers={'X-Auth-Admin-User': 'act:adm',\n                     'X-Auth-Admin-Key': 'key'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 200)\n        self.assertEqual(resp.content_type, CONTENT_TYPE_JSON)\n        self.assertEqual(resp.body, json.dumps(\n            {\"groups\": [{\"name\": \"act:usr\"}, {\"name\": \"act\"}],\n             \"auth\": \"plaintext:key\"}))\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n    def test_get_user_account_admin_fail_getting_account_admin(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object (account admin check)\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:adm\"},\n             {\"name\": \"test\"}, {\"name\": \".admin\"}],\n             \"auth\": \"plaintext:key\"})),\n            # GET of requested user object [who is an .admin as well]\n            ('200 Ok', {}, json.dumps(\n                {\"groups\": [{\"name\": \"act:usr\"}, {\"name\": \"act\"},\n                            {\"name\": \".admin\"}],\n                 \"auth\": \"plaintext:key\"})),\n            # GET of user object (reseller admin check [and fail here])\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:adm\"},\n             {\"name\": \"test\"}, {\"name\": \".admin\"}],\n             \"auth\": \"plaintext:key\"}))]))\n        resp = Request.blank('/auth/v2/act/usr',\n            headers={'X-Auth-Admin-User': 'act:adm',\n                     'X-Auth-Admin-Key': 'key'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 403)\n        self.assertEqual(self.test_auth.app.calls, 3)\n\n    def test_get_user_account_admin_fail_getting_reseller_admin(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object (account admin check)\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:adm\"},\n             {\"name\": \"test\"}, {\"name\": \".admin\"}],\n             \"auth\": \"plaintext:key\"})),\n            # GET of requested user object [who is a .reseller_admin]\n            ('200 Ok', {}, json.dumps(\n                {\"groups\": [{\"name\": \"act:usr\"}, {\"name\": \"act\"},\n                            {\"name\": \".reseller_admin\"}],\n                 \"auth\": \"plaintext:key\"}))]))\n        resp = Request.blank('/auth/v2/act/usr',\n            headers={'X-Auth-Admin-User': 'act:adm',\n                     'X-Auth-Admin-Key': 'key'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 403)\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n    def test_get_user_reseller_admin_fail_getting_reseller_admin(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object (account admin check)\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:adm\"},\n             {\"name\": \"test\"}, {\"name\": \".reseller_admin\"}],\n             \"auth\": \"plaintext:key\"})),\n            # GET of requested user object [who also is a .reseller_admin]\n            ('200 Ok', {}, json.dumps(\n                {\"groups\": [{\"name\": \"act:usr\"}, {\"name\": \"act\"},\n                            {\"name\": \".reseller_admin\"}],\n                 \"auth\": \"plaintext:key\"}))]))\n        resp = Request.blank('/auth/v2/act/usr',\n            headers={'X-Auth-Admin-User': 'act:adm',\n                     'X-Auth-Admin-Key': 'key'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 403)\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n    def test_get_user_super_admin_succeed_getting_reseller_admin(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of requested user object\n            ('200 Ok', {}, json.dumps(\n                {\"groups\": [{\"name\": \"act:usr\"}, {\"name\": \"act\"},\n                            {\"name\": \".reseller_admin\"}],\n                 \"auth\": \"plaintext:key\"}))]))\n        resp = Request.blank('/auth/v2/act/usr',\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 200)\n        self.assertEqual(resp.content_type, CONTENT_TYPE_JSON)\n        self.assertEqual(resp.body, json.dumps(\n            {\"groups\": [{\"name\": \"act:usr\"}, {\"name\": \"act\"},\n                        {\"name\": \".reseller_admin\"}],\n             \"auth\": \"plaintext:key\"}))\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_get_user_groups_not_found(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of account container (list objects)\n            ('404 Not Found', {}, '')]))\n        resp = Request.blank('/auth/v2/act/.groups',\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 404)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_get_user_groups_fail_listing(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of account container (list objects)\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v2/act/.groups',\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_get_user_groups_fail_get_user(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of account container (list objects)\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'},\n             json.dumps([\n                {\"name\": \".services\", \"hash\": \"etag\", \"bytes\": 112,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.618110\"},\n                {\"name\": \"tester\", \"hash\": \"etag\", \"bytes\": 104,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:27.736680\"},\n                {\"name\": \"tester3\", \"hash\": \"etag\", \"bytes\": 86,\n                 \"content_type\": \"application/octet-stream\",\n                 \"last_modified\": \"2010-12-03T17:16:28.135530\"}])),\n            # GET of user object\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v2/act/.groups',\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n    def test_get_user_not_found(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object\n            ('404 Not Found', {}, '')]))\n        resp = Request.blank('/auth/v2/act/usr',\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 404)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_get_user_fail(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v2/act/usr',\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest',\n                     'X-Auth-User-Key': 'key'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_put_user_fail_invalid_account(self):\n        resp = Request.blank('/auth/v2/.invalid/usr',\n            environ={'REQUEST_METHOD': 'PUT'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest',\n                     'X-Auth-User-Key': 'key'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 400)\n\n    def test_put_user_fail_invalid_user(self):\n        resp = Request.blank('/auth/v2/act/.usr',\n            environ={'REQUEST_METHOD': 'PUT'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest',\n                     'X-Auth-User-Key': 'key'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 400)\n\n    def test_put_user_fail_no_user_key(self):\n        resp = Request.blank('/auth/v2/act/usr',\n            environ={'REQUEST_METHOD': 'PUT'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 400)\n\n    def test_put_user_reseller_admin_fail_bad_creds(self):\n        self.test_auth.app = FakeApp(iter([\n            # Checking if user is changing his own key. This is called.\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:rdm\"},\n             {\"name\": \"test\"}, {\"name\": \".admin\"},\n             {\"name\": \".reseller_admin\"}], \"auth\": \"plaintext:key\"})),\n            # GET of user object (reseller admin)\n            # This shouldn't actually get called, checked\n            # below\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:rdm\"},\n             {\"name\": \"test\"}, {\"name\": \".admin\"},\n             {\"name\": \".reseller_admin\"}], \"auth\": \"plaintext:key\"}))]))\n        resp = Request.blank('/auth/v2/act/usr',\n            environ={'REQUEST_METHOD': 'PUT'},\n            headers={'X-Auth-Admin-User': 'act:rdm',\n                     'X-Auth-Admin-Key': 'key',\n                     'X-Auth-User-Key': 'key',\n                     'X-Auth-User-Reseller-Admin': 'true'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n        self.test_auth.app = FakeApp(iter([\n            # Checking if user is changing his own key. This is called.\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:adm\"},\n             {\"name\": \"test\"}, {\"name\": \".admin\"}],\n                \"auth\": \"plaintext:key\"})),\n            # GET of user object (account admin, but not reseller admin)\n            # This shouldn't actually get called, checked\n            # below\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:adm\"},\n             {\"name\": \"test\"}, {\"name\": \".admin\"}],\n                \"auth\": \"plaintext:key\"}))]))\n        resp = Request.blank('/auth/v2/act/usr',\n            environ={'REQUEST_METHOD': 'PUT'},\n            headers={'X-Auth-Admin-User': 'act:adm',\n                     'X-Auth-Admin-Key': 'key',\n                     'X-Auth-User-Key': 'key',\n                     'X-Auth-User-Reseller-Admin': 'true'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n        self.test_auth.app = FakeApp(iter([\n            # Checking if user is changing his own key. This is called.\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:usr\"},\n             {\"name\": \"test\"}], \"auth\": \"plaintext:key\"})),\n            # GET of user object (regular user)\n            # This shouldn't actually get called, checked\n            # below\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:usr\"},\n             {\"name\": \"test\"}], \"auth\": \"plaintext:key\"}))]))\n        resp = Request.blank('/auth/v2/act/usr',\n            environ={'REQUEST_METHOD': 'PUT'},\n            headers={'X-Auth-Admin-User': 'act:adm',\n                     'X-Auth-Admin-Key': 'key',\n                     'X-Auth-User-Key': 'key',\n                     'X-Auth-User-Reseller-Admin': 'true'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_put_user_account_admin_fail_bad_creds(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object (account admin, but wrong account)\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act2:adm\"},\n             {\"name\": \"test\"}, {\"name\": \".admin\"}],\n             \"auth\": \"plaintext:key\"})),\n            # Checking if user is changing his own key.\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:adm\"},\n             {\"name\": \"test\"}, {\"name\": \".admin\"}],\n             \"auth\": \"plaintext:key\"}))]))\n        resp = Request.blank('/auth/v2/act/usr',\n            environ={'REQUEST_METHOD': 'PUT'},\n            headers={'X-Auth-Admin-User': 'act2:adm',\n                     'X-Auth-Admin-Key': 'key',\n                     'X-Auth-User-Key': 'key',\n                     'X-Auth-User-Admin': 'true'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 403)\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object (regular user)\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:usr\"},\n             {\"name\": \"test\"}], \"auth\": \"plaintext:key\"})),\n            # Checking if user is changing his own key.\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:usr\"},\n             {\"name\": \"test\"}], \"auth\": \"plaintext:key\"}))]))\n        resp = Request.blank('/auth/v2/act/usr',\n            environ={'REQUEST_METHOD': 'PUT'},\n            headers={'X-Auth-Admin-User': 'act:usr',\n                     'X-Auth-Admin-Key': 'key',\n                     'X-Auth-User-Key': 'key',\n                     'X-Auth-User-Admin': 'true'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 403)\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n    def test_put_user_regular_fail_bad_creds(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object (account admin, but wrong\n            # account)\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act2:adm\"},\n             {\"name\": \"test\"}, {\"name\": \".admin\"}],\n                \"auth\": \"plaintext:key\"})),\n            # Checking if user is changing his own key.\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:adm\"},\n             {\"name\": \"test\"}, {\"name\": \".admin\"}],\n                \"auth\": \"plaintext:key\"}))]))\n        resp = Request.blank('/auth/v2/act/usr',\n            environ={'REQUEST_METHOD': 'PUT'},\n            headers={'X-Auth-Admin-User': 'act2:adm',\n                     'X-Auth-Admin-Key': 'key',\n                     'X-Auth-User-Key': 'key'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 403)\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object (regular user)\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:usr\"},\n             {\"name\": \"test\"}], \"auth\": \"plaintext:key\"})),\n            # Checking if user is changing his own key.\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:usr\"},\n             {\"name\": \"test\"}], \"auth\": \"plaintext:key\"}))]))\n        resp = Request.blank('/auth/v2/act2/usr',\n            environ={'REQUEST_METHOD': 'PUT'},\n            headers={'X-Auth-Admin-User': 'act:usr',\n                     'X-Auth-Admin-Key': 'key',\n                     'X-Auth-User-Key': 'key'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 403)\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n    def test_put_user_regular_success(self):\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, ''),\n            # PUT of user object\n            ('201 Created', {}, '')]))\n        resp = Request.blank('/auth/v2/act/usr',\n            environ={'REQUEST_METHOD': 'PUT'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest',\n                     'X-Auth-User-Key': 'key'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 201)\n        self.assertEqual(self.test_auth.app.calls, 2)\n        self.assertEqual(json.loads(self.test_auth.app.request.body),\n            {\"groups\": [{\"name\": \"act:usr\"}, {\"name\": \"act\"}],\n             \"auth\": \"plaintext:key\"})\n\n    def test_put_user_special_chars_success(self):\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, ''),\n            # PUT of user object\n            ('201 Created', {}, '')]))\n        resp = Request.blank('/auth/v2/act/u_s-r',\n            environ={'REQUEST_METHOD': 'PUT'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest',\n                     'X-Auth-User-Key': 'key'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 201)\n        self.assertEqual(self.test_auth.app.calls, 2)\n        self.assertEqual(json.loads(self.test_auth.app.request.body),\n            {\"groups\": [{\"name\": \"act:u_s-r\"}, {\"name\": \"act\"}],\n             \"auth\": \"plaintext:key\"})\n\n    def test_put_user_account_admin_success(self):\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, ''),\n            # PUT of user object\n            ('201 Created', {}, '')]))\n        resp = Request.blank('/auth/v2/act/usr',\n            environ={'REQUEST_METHOD': 'PUT'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest',\n                     'X-Auth-User-Key': 'key',\n                     'X-Auth-User-Admin': 'true'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 201)\n        self.assertEqual(self.test_auth.app.calls, 2)\n        self.assertEqual(json.loads(self.test_auth.app.request.body),\n            {\"groups\": [{\"name\": \"act:usr\"}, {\"name\": \"act\"},\n                        {\"name\": \".admin\"}],\n             \"auth\": \"plaintext:key\"})\n\n    def test_put_user_reseller_admin_success(self):\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, ''),\n            # PUT of user object\n            ('201 Created', {}, '')]))\n        resp = Request.blank('/auth/v2/act/usr',\n            environ={'REQUEST_METHOD': 'PUT'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest',\n                     'X-Auth-User-Key': 'key',\n                     'X-Auth-User-Reseller-Admin': 'true'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 201)\n        self.assertEqual(self.test_auth.app.calls, 2)\n        self.assertEqual(json.loads(self.test_auth.app.request.body),\n            {\"groups\": [{\"name\": \"act:usr\"}, {\"name\": \"act\"},\n                        {\"name\": \".admin\"}, {\"name\": \".reseller_admin\"}],\n             \"auth\": \"plaintext:key\"})\n\n    def test_put_user_fail_not_found(self):\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, ''),\n            # PUT of user object\n            ('404 Not Found', {}, '')]))\n        resp = Request.blank('/auth/v2/act/usr',\n            environ={'REQUEST_METHOD': 'PUT'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest',\n                     'X-Auth-User-Key': 'key'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 404)\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n    def test_put_user_fail(self):\n        self.test_auth.app = FakeApp(iter([\n            # PUT of user object\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v2/act/usr',\n            environ={'REQUEST_METHOD': 'PUT'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest',\n                     'X-Auth-User-Key': 'key'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_put_user_key_hash(self):\n        key_hash = (\"sha512:aSm0jEeqIp46T5YLZy1r8+cXs/Xzs1S4VUwVauhBs44=$ef\"\n                    \"7332ec1288bf69c75682eb8d459d5a84baa7e43f45949c242a9af9\"\n                    \"7130ef16ac361fe1aa33a789e218122b83c54ef1923fc015080741\"\n                    \"ca21f6187329f6cb7a\")\n\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, ''),\n            # PUT of user object\n            ('201 Created', {}, '')]))\n        resp = Request.blank('/auth/v2/act/usr',\n            environ={'REQUEST_METHOD': 'PUT'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest',\n                     'X-Auth-User-Key-Hash': quote(key_hash)}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 201)\n        self.assertEqual(self.test_auth.app.calls, 2)\n        self.assertEqual(json.loads(self.test_auth.app.request.body),\n            {\"groups\": [{\"name\": \"act:usr\"}, {\"name\": \"act\"}],\n             \"auth\": key_hash})\n\n    def test_put_user_key_hash_wrong_type(self):\n        key_hash = \"wrong_auth_type:1234\"\n\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, ''),\n            # PUT of user object\n            ('201 Created', {}, '')]))\n        resp = Request.blank('/auth/v2/act/usr',\n            environ={'REQUEST_METHOD': 'PUT'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest',\n                     'X-Auth-User-Key-Hash': quote(key_hash)}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 400)\n        self.assertEqual(self.test_auth.app.calls, 0)\n\n    def test_put_user_key_hash_wrong_format(self):\n        key_hash = \"1234\"\n\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, ''),\n            # PUT of user object\n            ('201 Created', {}, '')]))\n        resp = Request.blank('/auth/v2/act/usr',\n            environ={'REQUEST_METHOD': 'PUT'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest',\n                     'X-Auth-User-Key-Hash': quote(key_hash)}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 400)\n        self.assertEqual(self.test_auth.app.calls, 0)\n\n    def test_delete_user_bad_creds(self):\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act2:adm\"},\n             {\"name\": \"test\"}, {\"name\": \".admin\"}],\n                \"auth\": \"plaintext:key\"})),\n            # GET of user object (account admin, but wrong account)\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act2:adm\"},\n             {\"name\": \"test\"}, {\"name\": \".admin\"}],\n             \"auth\": \"plaintext:key\"}))]))\n        resp = Request.blank('/auth/v2/act/usr',\n            environ={'REQUEST_METHOD': 'DELETE'},\n            headers={'X-Auth-Admin-User': 'act2:adm',\n                     'X-Auth-Admin-Key': 'key'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 403)\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:usr\"},\n             {\"name\": \"test\"}], \"auth\": \"plaintext:key\"})),\n            # GET of user object (regular user)\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:usr\"},\n             {\"name\": \"test\"}], \"auth\": \"plaintext:key\"}))]))\n        resp = Request.blank('/auth/v2/act/usr',\n            environ={'REQUEST_METHOD': 'DELETE'},\n            headers={'X-Auth-Admin-User': 'act:usr',\n                     'X-Auth-Admin-Key': 'key'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 403)\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n    def test_delete_reseller_admin_user_fail(self):\n        self.test_auth.app = FakeApp(iter([\n            # is user being deleted a reseller_admin\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act2:re_adm\"},\n             {\"name\": \"act2\"}, {\"name\": \".admin\"},\n                {\"name\": \".reseller_admin\"}], \"auth\": \"plaintext:key\"})),\n            # GET of user object\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act2:adm\"},\n             {\"name\": \"act2\"}, {\"name\": \".admin\"}],\n                \"auth\": \"plaintext:key\"}))]))\n\n        resp = Request.blank('/auth/v2/act2/re_adm',\n                             environ={\n                                 'REQUEST_METHOD': 'DELETE'},\n                             headers={\n                                 'X-Auth-Admin-User':\n                                 'act2:adm',\n                                 'X-Auth-Admin-Key': 'key'}\n                             ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 403)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_delete_reseller_admin_user_success(self):\n        self.test_auth.app = FakeApp(iter([\n            # is user being deleted a reseller_admin\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act2:re_adm\"},\n             {\"name\": \"act2\"}, {\"name\": \".admin\"},\n                {\"name\": \".reseller_admin\"}], \"auth\": \"plaintext:key\"})),\n            # HEAD of user object\n            ('200 Ok',\n             {'X-Object-Meta-Auth-Token': 'AUTH_tk'}, ''),\n            # DELETE of token\n            ('204 No Content', {}, ''),\n            # DELETE of user object\n            ('204 No Content', {}, '')]))\n\n        resp = Request.blank('/auth/v2/act2/re_adm',\n                             environ={\n                                 'REQUEST_METHOD': 'DELETE'},\n                             headers={\n                                 'X-Auth-Admin-User':\n                                 '.super_admin',\n                                 'X-Auth-Admin-Key': 'supertest'}\n                             ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 204)\n        self.assertEqual(self.test_auth.app.calls, 4)\n\n    def test_delete_user_invalid_account(self):\n        resp = Request.blank('/auth/v2/.invalid/usr',\n            environ={'REQUEST_METHOD': 'DELETE'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 400)\n\n    def test_delete_user_invalid_user(self):\n        resp = Request.blank('/auth/v2/act/.invalid',\n            environ={'REQUEST_METHOD': 'DELETE'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 400)\n\n    def test_delete_user_not_found(self):\n        self.test_auth.app = FakeApp(iter([\n            # HEAD of user object\n            ('404 Not Found', {}, '')]))\n        resp = Request.blank('/auth/v2/act/usr',\n            environ={'REQUEST_METHOD': 'DELETE'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 404)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_delete_user_fail_head_user(self):\n        self.test_auth.app = FakeApp(iter([\n            # HEAD of user object\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v2/act/usr',\n            environ={'REQUEST_METHOD': 'DELETE'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_delete_user_fail_delete_token(self):\n        self.test_auth.app = FakeApp(iter([\n            # is user reseller_admin\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:usr\"},\n             {\"name\": \"test\"}], \"auth\": \"plaintext:key\"})),\n            # HEAD of user object\n            ('200 Ok', {'X-Object-Meta-Auth-Token': 'AUTH_tk'}, ''),\n            # DELETE of token\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v2/act/usr',\n            environ={'REQUEST_METHOD': 'DELETE'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 3)\n\n    def test_delete_user_fail_delete_user(self):\n        self.test_auth.app = FakeApp(iter([\n            # is user reseller_admin\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:usr\"},\n             {\"name\": \"test\"}], \"auth\": \"plaintext:key\"})),\n            # HEAD of user object\n            ('200 Ok', {'X-Object-Meta-Auth-Token': 'AUTH_tk'}, ''),\n            # DELETE of token\n            ('204 No Content', {}, ''),\n            # DELETE of user object\n            ('503 Service Unavailable', {}, '')]))\n        resp = Request.blank('/auth/v2/act/usr',\n            environ={'REQUEST_METHOD': 'DELETE'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n        self.assertEqual(self.test_auth.app.calls, 4)\n\n    def test_delete_user_success(self):\n        self.test_auth.app = FakeApp(iter([\n            # is user reseller_admin\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:usr\"},\n             {\"name\": \"test\"}], \"auth\": \"plaintext:key\"})),\n            # HEAD of user object\n            ('200 Ok', {'X-Object-Meta-Auth-Token': 'AUTH_tk'}, ''),\n            # DELETE of token\n            ('204 No Content', {}, ''),\n            # DELETE of user object\n            ('204 No Content', {}, '')]))\n        resp = Request.blank('/auth/v2/act/usr',\n            environ={'REQUEST_METHOD': 'DELETE'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 204)\n        self.assertEqual(self.test_auth.app.calls, 4)\n\n    def test_delete_user_success_missing_user_at_end(self):\n        self.test_auth.app = FakeApp(iter([\n            # is user reseller_admin\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:usr\"},\n             {\"name\": \"test\"}], \"auth\": \"plaintext:key\"})),\n            # HEAD of user object\n            ('200 Ok', {'X-Object-Meta-Auth-Token': 'AUTH_tk'}, ''),\n            # DELETE of token\n            ('204 No Content', {}, ''),\n            # DELETE of user object\n            ('404 Not Found', {}, '')]))\n        resp = Request.blank('/auth/v2/act/usr',\n            environ={'REQUEST_METHOD': 'DELETE'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 204)\n        self.assertEqual(self.test_auth.app.calls, 4)\n\n    def test_delete_user_success_missing_token(self):\n        self.test_auth.app = FakeApp(iter([\n            # is user reseller_admin\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:usr\"},\n             {\"name\": \"test\"}], \"auth\": \"plaintext:key\"})),\n            # HEAD of user object\n            ('200 Ok', {'X-Object-Meta-Auth-Token': 'AUTH_tk'}, ''),\n            # DELETE of token\n            ('404 Not Found', {}, ''),\n            # DELETE of user object\n            ('204 No Content', {}, '')]))\n        resp = Request.blank('/auth/v2/act/usr',\n            environ={'REQUEST_METHOD': 'DELETE'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 204)\n        self.assertEqual(self.test_auth.app.calls, 4)\n\n    def test_delete_user_success_no_token(self):\n        self.test_auth.app = FakeApp(iter([\n            # is user reseller_admin\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:usr\"},\n             {\"name\": \"test\"}], \"auth\": \"plaintext:key\"})),\n            # HEAD of user object\n            ('200 Ok', {}, ''),\n            # DELETE of user object\n            ('204 No Content', {}, '')]))\n        resp = Request.blank('/auth/v2/act/usr',\n            environ={'REQUEST_METHOD': 'DELETE'},\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}\n            ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 204)\n        self.assertEqual(self.test_auth.app.calls, 3)\n\n    def test_validate_token_bad_prefix(self):\n        resp = Request.blank('/auth/v2/.token/BAD_token') \\\n            .get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 400)\n\n    def test_validate_token_tmi(self):\n        resp = Request.blank('/auth/v2/.token/AUTH_token/tmi') \\\n            .get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 400)\n\n    def test_validate_token_bad_memcache(self):\n        fake_memcache = FakeMemcache()\n        fake_memcache.set('AUTH_/auth/AUTH_token', 'bogus')\n        resp = Request.blank('/auth/v2/.token/AUTH_token',\n            environ={'swift.cache':\n            fake_memcache}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 500)\n\n    def test_validate_token_from_memcache(self):\n        fake_memcache = FakeMemcache()\n        fake_memcache.set('AUTH_/auth/AUTH_token', (time() + 1, 'act:usr,act'))\n        resp = Request.blank('/auth/v2/.token/AUTH_token',\n            environ={'swift.cache':\n            fake_memcache}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 204)\n        self.assertEqual(resp.headers.get('x-auth-groups'), 'act:usr,act')\n        self.assertTrue(float(resp.headers['x-auth-ttl']) < 1,\n                     resp.headers['x-auth-ttl'])\n\n    def test_validate_token_from_memcache_expired(self):\n        fake_memcache = FakeMemcache()\n        fake_memcache.set('AUTH_/auth/AUTH_token', (time() - 1, 'act:usr,act'))\n        resp = Request.blank('/auth/v2/.token/AUTH_token',\n            environ={'swift.cache':\n            fake_memcache}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 404)\n        self.assertTrue('x-auth-groups' not in resp.headers)\n        self.assertTrue('x-auth-ttl' not in resp.headers)\n\n    def test_validate_token_from_object(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of token object\n            ('200 Ok', {}, json.dumps({'groups': [{'name': 'act:usr'},\n             {'name': 'act'}], 'expires': time() + 1}))]))\n        resp = Request.blank('/auth/v2/.token/AUTH_token'\n                             ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 204)\n        self.assertEqual(self.test_auth.app.calls, 1)\n        self.assertEqual(resp.headers.get('x-auth-groups'), 'act:usr,act')\n        self.assertTrue(float(resp.headers['x-auth-ttl']) < 1,\n                     resp.headers['x-auth-ttl'])\n\n    def test_validate_token_from_object_expired(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of token object\n            ('200 Ok', {}, json.dumps({'groups': 'act:usr,act',\n             'expires': time() - 1})),\n            # DELETE of expired token object\n            ('204 No Content', {}, '')]))\n        resp = Request.blank('/auth/v2/.token/AUTH_token'\n                             ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 404)\n        self.assertEqual(self.test_auth.app.calls, 2)\n\n    def test_validate_token_from_object_with_admin(self):\n        self.test_auth.app = FakeApp(iter([\n            # GET of token object\n            ('200 Ok', {}, json.dumps({'account_id': 'AUTH_cfa', 'groups':\n             [{'name': 'act:usr'}, {'name': 'act'}, {'name': '.admin'}],\n             'expires': time() + 1}))]))\n        resp = Request.blank('/auth/v2/.token/AUTH_token'\n                             ).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 204)\n        self.assertEqual(self.test_auth.app.calls, 1)\n        self.assertEqual(resp.headers.get('x-auth-groups'),\n                         'act:usr,act,AUTH_cfa')\n        self.assertTrue(float(resp.headers['x-auth-ttl']) < 1,\n                     resp.headers['x-auth-ttl'])\n\n    def test_get_conn_default(self):\n        conn = self.test_auth.get_conn()\n        self.assertEqual(conn.__class__, auth.HTTPConnection)\n        self.assertEqual(conn.host, '127.0.0.1')\n        self.assertEqual(conn.port, 8080)\n\n    def test_get_conn_default_https(self):\n        local_auth = auth.filter_factory({'super_admin_key': 'supertest',\n            'default_swift_cluster': 'local#https://1.2.3.4/v1'})(FakeApp())\n        conn = local_auth.get_conn()\n        self.assertEqual(conn.__class__, auth.HTTPSConnection)\n        self.assertEqual(conn.host, '1.2.3.4')\n        self.assertEqual(conn.port, 443)\n\n    def test_get_conn_overridden(self):\n        local_auth = auth.filter_factory({'super_admin_key': 'supertest',\n            'default_swift_cluster': 'local#https://1.2.3.4/v1'})(FakeApp())\n        conn = \\\n            local_auth.get_conn(urlparsed=auth.urlparse('http://5.6.7.8/v1'))\n        self.assertEqual(conn.__class__, auth.HTTPConnection)\n        self.assertEqual(conn.host, '5.6.7.8')\n        self.assertEqual(conn.port, 80)\n\n    def test_get_conn_overridden_https(self):\n        local_auth = auth.filter_factory({'super_admin_key': 'supertest',\n            'default_swift_cluster': 'local#http://1.2.3.4/v1'})(FakeApp())\n        conn = \\\n            local_auth.get_conn(urlparsed=auth.urlparse('https://5.6.7.8/v1'))\n        self.assertEqual(conn.__class__, auth.HTTPSConnection)\n        self.assertEqual(conn.host, '5.6.7.8')\n        self.assertEqual(conn.port, 443)\n\n    def test_get_itoken_fail_no_memcache(self):\n        exc = None\n        try:\n            self.test_auth.get_itoken({})\n        except Exception as err:\n            exc = err\n        self.assertEqual(str(exc),\n                         'No memcache set up; required for Swauth middleware')\n\n    def test_get_itoken_success(self):\n        fmc = FakeMemcache()\n        itk = self.test_auth.get_itoken({'swift.cache': fmc})\n        self.assertTrue(itk.startswith('AUTH_itk'), itk)\n        expires, groups = fmc.get('AUTH_/auth/%s' % itk)\n        self.assertTrue(expires > time(), expires)\n        self.assertEqual(groups, '.auth,.reseller_admin,AUTH_.auth')\n\n    def test_get_admin_detail_fail_no_colon(self):\n        self.test_auth.app = FakeApp(iter([]))\n        self.assertEqual(self.test_auth.get_admin_detail(Request.blank('/')),\n                         None)\n        self.assertEqual(self.test_auth.get_admin_detail(Request.blank('/',\n            headers={'X-Auth-Admin-User': 'usr'})), None)\n        self.assertRaises(StopIteration, self.test_auth.get_admin_detail,\n            Request.blank('/', headers={'X-Auth-Admin-User': 'act:usr'}))\n\n    def test_get_admin_detail_fail_user_not_found(self):\n        self.test_auth.app = FakeApp(iter([('404 Not Found', {}, '')]))\n        self.assertEqual(self.test_auth.get_admin_detail(Request.blank('/',\n            headers={'X-Auth-Admin-User': 'act:usr'})), None)\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_get_admin_detail_fail_get_user_error(self):\n        self.test_auth.app = FakeApp(iter([\n            ('503 Service Unavailable', {}, '')]))\n        exc = None\n        try:\n            self.test_auth.get_admin_detail(Request.blank('/',\n                headers={'X-Auth-Admin-User': 'act:usr'}))\n        except Exception as err:\n            exc = err\n        self.assertEqual(str(exc), 'Could not get user object: '\n            '/v1/AUTH_.auth/act/usr 503 Service Unavailable')\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_get_admin_detail_success(self):\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {},\n             json.dumps({\"auth\": \"plaintext:key\",\n                         \"groups\": [{'name': \"act:usr\"}, {'name': \"act\"},\n                                    {'name': \".admin\"}]}))]))\n        detail = self.test_auth.get_admin_detail(Request.blank('/',\n                    headers={'X-Auth-Admin-User': 'act:usr'}))\n        self.assertEqual(self.test_auth.app.calls, 1)\n        self.assertEqual(detail, {'account': 'act',\n            'auth': 'plaintext:key',\n            'groups': [{'name': 'act:usr'}, {'name': 'act'},\n                       {'name': '.admin'}]})\n\n    def test_get_user_detail_success(self):\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {},\n             json.dumps({\"auth\": \"plaintext:key\",\n                         \"groups\": [{'name': \"act:usr\"}, {'name': \"act\"},\n                                    {'name': \".admin\"}]}))]))\n        detail = self.test_auth.get_user_detail(\n            Request.blank('/',\n                          headers={'X-Auth-Admin-User': 'act:usr'}),\n            'act', 'usr')\n        self.assertEqual(self.test_auth.app.calls, 1)\n        detail_json = json.loads(detail)\n        self.assertEqual(\"plaintext:key\", detail_json['auth'])\n\n    def test_get_user_detail_fail_user_doesnt_exist(self):\n        self.test_auth.app = FakeApp(\n            iter([('404 Not Found', {}, '')]))\n        detail = self.test_auth.get_user_detail(\n            Request.blank('/',\n                          headers={'X-Auth-Admin-User': 'act:usr'}),\n            'act', 'usr')\n        self.assertEqual(self.test_auth.app.calls, 1)\n        self.assertEqual(detail, None)\n\n    def test_get_user_detail_fail_exception(self):\n        self.test_auth.app = FakeApp(iter([\n            ('503 Service Unavailable', {}, '')]))\n        exc = None\n        try:\n            self.test_auth.get_user_detail(\n                Request.blank('/',\n                              headers={'X-Auth-Admin-User': 'act:usr'}),\n                'act', 'usr')\n        except Exception as err:\n            exc = err\n        self.assertEqual(str(exc), 'Could not get user object: '\n                         '/v1/AUTH_.auth/act/usr 503 Service Unavailable')\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_is_user_reseller_admin_success(self):\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {},\n             json.dumps({\"auth\": \"plaintext:key\",\n                         \"groups\": [{'name': \"act:usr\"}, {'name': \"act\"},\n                                    {'name': \".reseller_admin\"}]}))]))\n        result = self.test_auth.is_user_reseller_admin(\n            Request.blank('/',\n                          headers={'X-Auth-Admin-User': 'act:usr'}),\n            'act', 'usr')\n        self.assertEqual(self.test_auth.app.calls, 1)\n        self.assertTrue(result)\n\n    def test_is_user_reseller_admin_fail(self):\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {},\n             json.dumps({\"auth\": \"plaintext:key\",\n                         \"groups\": [{'name': \"act:usr\"}, {'name': \"act\"},\n                                    {'name': \".admin\"}]}))]))\n        result = self.test_auth.is_user_reseller_admin(\n            Request.blank('/',\n                          headers={'X-Auth-Admin-User': 'act:usr'}),\n            'act', 'usr')\n        self.assertEqual(self.test_auth.app.calls, 1)\n        self.assertFalse(result)\n\n    def test_is_user_reseller_admin_fail_user_doesnt_exist(self):\n        self.test_auth.app = FakeApp(\n            iter([('404 Not Found', {}, '')]))\n        req = Request.blank('/', headers={'X-Auth-Admin-User': 'act:usr'})\n        result = self.test_auth.is_user_reseller_admin(req, 'act', 'usr')\n        self.assertEqual(self.test_auth.app.calls, 1)\n        self.assertFalse(result)\n        self.assertFalse(req.credentials_valid)\n\n    def test_credentials_match_success(self):\n        self.assertTrue(self.test_auth.credentials_match(\n            {'auth': 'plaintext:key'}, 'key'))\n\n    def test_credentials_match_fail_no_details(self):\n        self.assertTrue(not self.test_auth.credentials_match(None, 'notkey'))\n\n    def test_credentials_match_fail_plaintext(self):\n        self.assertTrue(not self.test_auth.credentials_match(\n            {'auth': 'plaintext:key'}, 'notkey'))\n\n    def test_is_user_changing_own_key_err(self):\n        # User does not exist\n        self.test_auth.app = FakeApp(\n            iter([('404 Not Found', {}, '')]))\n        req = Request.blank('/auth/v2/act/usr',\n                            environ={\n                                'REQUEST_METHOD': 'PUT'},\n                            headers={\n                                'X-Auth-Admin-User': 'act:usr',\n                                'X-Auth-Admin-Key': 'key',\n                                'X-Auth-User-Key': 'key'})\n        self.assertTrue(\n            not self.test_auth.is_user_changing_own_key(req, 'act:usr'))\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n        # user attempting to escalate himself as admin\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:usr\"},\n             {\"name\": \"test\"}], \"auth\": \"plaintext:key\"}))]))\n        req = Request.blank('/auth/v2/act/usr',\n                            environ={\n                                'REQUEST_METHOD': 'PUT'},\n                            headers={\n                                'X-Auth-Admin-User': 'act:usr',\n                                'X-Auth-Admin-Key': 'key',\n                                'X-Auth-User-Key': 'key',\n                                'X-Auth-User-Admin': 'true'})\n        self.assertTrue(\n            not self.test_auth.is_user_changing_own_key(req, 'act:usr'))\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n        # admin attempting to escalate himself as reseller_admin\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:adm\"},\n             {\"name\": \"test\"}, {\"name\": \".admin\"}],\n                \"auth\": \"plaintext:key\"}))]))\n        req = Request.blank('/auth/v2/act/adm',\n                            environ={\n                                'REQUEST_METHOD': 'PUT'},\n                            headers={\n                                'X-Auth-Admin-User': 'act:adm',\n                                'X-Auth-Admin-Key': 'key',\n                                'X-Auth-User-Key': 'key',\n                                'X-Auth-User-Reseller-Admin': 'true'})\n        self.assertTrue(\n            not self.test_auth.is_user_changing_own_key(req, 'act:adm'))\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n        # different user\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:usr\"},\n             {\"name\": \"test\"}], \"auth\": \"plaintext:key\"}))]))\n        req = Request.blank('/auth/v2/act/usr2',\n                            environ={\n                                'REQUEST_METHOD': 'PUT'},\n                            headers={\n                                'X-Auth-Admin-User': 'act:usr',\n                                'X-Auth-Admin-Key': 'key',\n                                'X-Auth-User-Key': 'key'})\n        self.assertTrue(\n            not self.test_auth.is_user_changing_own_key(req, 'act:usr2'))\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n        # wrong key\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {}, json.dumps({\"groups\": [{\"name\": \"act:usr\"},\n             {\"name\": \"test\"}], \"auth\": \"plaintext:key\"}))]))\n        req = Request.blank('/auth/v2/act/usr',\n                            environ={\n                                'REQUEST_METHOD': 'PUT'},\n                            headers={\n                                'X-Auth-Admin-User': 'act:usr',\n                                'X-Auth-Admin-Key': 'wrongkey',\n                                'X-Auth-User-Key': 'newkey'})\n        self.assertTrue(\n            not self.test_auth.is_user_changing_own_key(req, 'act:usr'))\n        self.assertEqual(self.test_auth.app.calls, 1)\n\n    def test_is_super_admin_success(self):\n        self.assertTrue(self.test_auth.is_super_admin(Request.blank('/',\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'})))\n\n    def test_is_super_admin_fail_bad_key(self):\n        self.assertTrue(not self.test_auth.is_super_admin(Request.blank('/',\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'bad'})))\n        self.assertTrue(not self.test_auth.is_super_admin(Request.blank('/',\n            headers={'X-Auth-Admin-User': '.super_admin'})))\n        self.assertTrue(not self.test_auth.is_super_admin(Request.blank('/')))\n\n    def test_is_super_admin_fail_bad_user(self):\n        self.assertTrue(not self.test_auth.is_super_admin(Request.blank('/',\n            headers={'X-Auth-Admin-User': 'bad',\n                     'X-Auth-Admin-Key': 'supertest'})))\n        self.assertTrue(not self.test_auth.is_super_admin(Request.blank('/',\n            headers={'X-Auth-Admin-Key': 'supertest'})))\n        self.assertTrue(not self.test_auth.is_super_admin(Request.blank('/')))\n\n    def test_is_reseller_admin_success_is_super_admin(self):\n        self.assertTrue(self.test_auth.is_reseller_admin(Request.blank('/',\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'})))\n\n    def test_is_reseller_admin_success_called_get_admin_detail(self):\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {},\n             json.dumps({'auth': 'plaintext:key',\n                         'groups': [{'name': 'act:rdm'}, {'name': 'act'},\n                                    {'name': '.admin'},\n                                    {'name': '.reseller_admin'}]}))]))\n        self.assertTrue(self.test_auth.is_reseller_admin(Request.blank('/',\n            headers={'X-Auth-Admin-User': 'act:rdm',\n                     'X-Auth-Admin-Key': 'key'})))\n\n    def test_is_reseller_admin_fail_only_account_admin(self):\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {},\n             json.dumps({'auth': 'plaintext:key',\n                         'groups': [{'name': 'act:adm'}, {'name': 'act'},\n                                    {'name': '.admin'}]}))]))\n        self.assertTrue(not self.test_auth.is_reseller_admin(Request.blank('/',\n            headers={'X-Auth-Admin-User': 'act:adm',\n                     'X-Auth-Admin-Key': 'key'})))\n\n    def test_is_reseller_admin_fail_regular_user(self):\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {},\n             json.dumps({'auth': 'plaintext:key',\n                         'groups': [{'name': 'act:usr'}, {'name': 'act'}]}))]))\n        self.assertTrue(not self.test_auth.is_reseller_admin(Request.blank('/',\n            headers={'X-Auth-Admin-User': 'act:usr',\n                     'X-Auth-Admin-Key': 'key'})))\n\n    def test_is_reseller_admin_fail_bad_key(self):\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {},\n             json.dumps({'auth': 'plaintext:key',\n                         'groups': [{'name': 'act:rdm'}, {'name': 'act'},\n                                    {'name': '.admin'},\n                                    {'name': '.reseller_admin'}]}))]))\n        self.assertTrue(not self.test_auth.is_reseller_admin(Request.blank('/',\n            headers={'X-Auth-Admin-User': 'act:rdm',\n                     'X-Auth-Admin-Key': 'bad'})))\n\n    def test_is_account_admin_success_is_super_admin(self):\n        self.assertTrue(self.test_auth.is_account_admin(Request.blank('/',\n            headers={'X-Auth-Admin-User': '.super_admin',\n                     'X-Auth-Admin-Key': 'supertest'}), 'act'))\n\n    def test_is_account_admin_success_is_reseller_admin(self):\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {},\n             json.dumps({'auth': 'plaintext:key',\n                         'groups': [{'name': 'act:rdm'}, {'name': 'act'},\n                                    {'name': '.admin'},\n                                    {'name': '.reseller_admin'}]}))]))\n        self.assertTrue(self.test_auth.is_account_admin(Request.blank('/',\n            headers={'X-Auth-Admin-User': 'act:rdm',\n                     'X-Auth-Admin-Key': 'key'}), 'act'))\n\n    def test_is_account_admin_success(self):\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {},\n             json.dumps({'auth': 'plaintext:key',\n                         'groups': [{'name': 'act:adm'}, {'name': 'act'},\n                                    {'name': '.admin'}]}))]))\n        self.assertTrue(self.test_auth.is_account_admin(Request.blank('/',\n            headers={'X-Auth-Admin-User': 'act:adm',\n                     'X-Auth-Admin-Key': 'key'}), 'act'))\n\n    def test_is_account_admin_fail_account_admin_different_account(self):\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {},\n             json.dumps({'auth': 'plaintext:key',\n                         'groups': [{'name': 'act2:adm'}, {'name': 'act2'},\n                                    {'name': '.admin'}]}))]))\n        self.assertTrue(not self.test_auth.is_account_admin(Request.blank('/',\n            headers={'X-Auth-Admin-User': 'act2:adm',\n                     'X-Auth-Admin-Key': 'key'}), 'act'))\n\n    def test_is_account_admin_fail_regular_user(self):\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {},\n             json.dumps({'auth': 'plaintext:key',\n                         'groups': [{'name': 'act:usr'}, {'name': 'act'}]}))]))\n        self.assertTrue(not self.test_auth.is_account_admin(Request.blank('/',\n            headers={'X-Auth-Admin-User': 'act:usr',\n                     'X-Auth-Admin-Key': 'key'}), 'act'))\n\n    def test_is_account_admin_fail_bad_key(self):\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {},\n             json.dumps({'auth': 'plaintext:key',\n                         'groups': [{'name': 'act:rdm'}, {'name': 'act'},\n                                    {'name': '.admin'},\n                                    {'name': '.reseller_admin'}]}))]))\n        self.assertTrue(not self.test_auth.is_account_admin(Request.blank('/',\n            headers={'X-Auth-Admin-User': 'act:rdm',\n                     'X-Auth-Admin-Key': 'bad'}), 'act'))\n\n    def test_reseller_admin_but_account_is_internal_use_only(self):\n        req = Request.blank('/v1/AUTH_.auth',\n                            environ={'REQUEST_METHOD': 'GET'})\n        req.remote_user = 'act:usr,act,.reseller_admin'\n        resp = self.test_auth.authorize(req)\n        self.assertEqual(resp.status_int, 403)\n\n    def test_reseller_admin_but_account_is_exactly_reseller_prefix(self):\n        req = Request.blank('/v1/AUTH_', environ={'REQUEST_METHOD': 'GET'})\n        req.remote_user = 'act:usr,act,.reseller_admin'\n        resp = self.test_auth.authorize(req)\n        self.assertEqual(resp.status_int, 403)\n\n    def _get_token_success_v1_0_encoded(self, saved_user, saved_key, sent_user,\n                                        sent_key):\n        self.test_auth.app = FakeApp(iter([\n            # GET of user object\n            ('200 Ok', {},\n             json.dumps({\"auth\": \"plaintext:%s\" % saved_key,\n                         \"groups\": [{'name': saved_user}, {'name': \"act\"},\n                                    {'name': \".admin\"}]})),\n            # GET of account\n            ('204 Ok', {'X-Container-Meta-Account-Id': 'AUTH_cfa'}, ''),\n            # PUT of new token\n            ('201 Created', {}, ''),\n            # POST of token to user object\n            ('204 No Content', {}, ''),\n            # GET of services object\n            ('200 Ok', {}, json.dumps({\"storage\": {\"default\": \"local\",\n             \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}}))]))\n        resp = Request.blank('/auth/v1.0',\n            headers={'X-Auth-User': sent_user,\n                     'X-Auth-Key': sent_key}).get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 200)\n        self.assertEqual(resp.content_type, CONTENT_TYPE_JSON)\n        self.assertTrue(resp.headers.get('x-auth-token',\n            '').startswith('AUTH_tk'), resp.headers.get('x-auth-token'))\n        self.assertEqual(resp.headers.get('x-auth-token'),\n                         resp.headers.get('x-storage-token'))\n        self.assertEqual(resp.headers.get('x-storage-url'),\n                         'http://127.0.0.1:8080/v1/AUTH_cfa')\n        self.assertEqual(json.loads(resp.body),\n            {\"storage\": {\"default\": \"local\",\n             \"local\": \"http://127.0.0.1:8080/v1/AUTH_cfa\"}})\n        self.assertEqual(self.test_auth.app.calls, 5)\n\n    def test_get_token_success_v1_0_encoded1(self):\n        self._get_token_success_v1_0_encoded(\n            'act:usr', 'key', 'act%3ausr', 'key')\n\n    def test_get_token_success_v1_0_encoded2(self):\n        self._get_token_success_v1_0_encoded(\n            'act:u s r', 'key', 'act%3au%20s%20r', 'key')\n\n    def test_get_token_success_v1_0_encoded3(self):\n        self._get_token_success_v1_0_encoded(\n            'act:u s r', 'k:e:y', 'act%3au%20s%20r', 'k%3Ae%3ay')\n\n    def test_allowed_sync_hosts(self):\n        a = auth.filter_factory({'super_admin_key': 'supertest'})(FakeApp())\n        self.assertEqual(a.allowed_sync_hosts, ['127.0.0.1'])\n        a = auth.filter_factory({'super_admin_key': 'supertest',\n            'allowed_sync_hosts':\n                '1.1.1.1,2.1.1.1, 3.1.1.1 , 4.1.1.1,, , 5.1.1.1'})(FakeApp())\n        self.assertEqual(a.allowed_sync_hosts,\n            ['1.1.1.1', '2.1.1.1', '3.1.1.1', '4.1.1.1', '5.1.1.1'])\n\n    def test_reseller_admin_is_owner(self):\n        orig_authorize = self.test_auth.authorize\n        owner_values = []\n\n        def mitm_authorize(req):\n            rv = orig_authorize(req)\n            owner_values.append(req.environ.get('swift_owner', False))\n            return rv\n\n        self.test_auth.authorize = mitm_authorize\n\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {},\n             json.dumps({'account': 'other', 'user': 'other:usr',\n                         'account_id': 'AUTH_other',\n                         'groups': [{'name': 'other:usr'}, {'name': 'other'},\n                                    {'name': '.reseller_admin'}],\n                         'expires': time() + 60})),\n            ('204 No Content', {}, '')]))\n        req = Request.blank('/v1/AUTH_cfa', headers={'X-Auth-Token': 'AUTH_t'})\n        resp = req.get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 204)\n        self.assertEqual(owner_values, [True])\n\n    def test_admin_is_owner(self):\n        orig_authorize = self.test_auth.authorize\n        owner_values = []\n\n        def mitm_authorize(req):\n            rv = orig_authorize(req)\n            owner_values.append(req.environ.get('swift_owner', False))\n            return rv\n\n        self.test_auth.authorize = mitm_authorize\n\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {},\n             json.dumps({'account': 'act', 'user': 'act:usr',\n                         'account_id': 'AUTH_cfa',\n                         'groups': [{'name': 'act:usr'}, {'name': 'act'},\n                                    {'name': '.admin'}],\n                         'expires': time() + 60})),\n            ('204 No Content', {}, '')]))\n        req = Request.blank('/v1/AUTH_cfa', headers={'X-Auth-Token': 'AUTH_t'})\n        resp = req.get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 204)\n        self.assertEqual(owner_values, [True])\n\n    def test_regular_is_not_owner(self):\n        orig_authorize = self.test_auth.authorize\n        owner_values = []\n\n        def mitm_authorize(req):\n            rv = orig_authorize(req)\n            owner_values.append(req.environ.get('swift_owner', False))\n            return rv\n\n        self.test_auth.authorize = mitm_authorize\n\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {},\n             json.dumps({'account': 'act', 'user': 'act:usr',\n                         'account_id': 'AUTH_cfa',\n                         'groups': [{'name': 'act:usr'}, {'name': 'act'}],\n                         'expires': time() + 60})),\n            ('204 No Content', {}, '')]), acl='act:usr')\n        req = Request.blank('/v1/AUTH_cfa/c',\n                            headers={'X-Auth-Token': 'AUTH_t'})\n        resp = req.get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 204)\n        self.assertEqual(owner_values, [False])\n\n    def test_sync_request_success(self):\n        self.test_auth.app = FakeApp(iter([('204 No Content', {}, '')]),\n                                     sync_key='secret')\n        req = Request.blank('/v1/AUTH_cfa/c/o',\n            environ={'REQUEST_METHOD': 'DELETE'},\n            headers={'x-container-sync-key': 'secret',\n                     'x-timestamp': '123.456'})\n        req.remote_addr = '127.0.0.1'\n        resp = req.get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 204)\n\n    def test_sync_request_fail_key(self):\n        self.test_auth.app = FakeApp(iter([('204 No Content', {}, '')]),\n                                     sync_key='secret')\n        req = Request.blank('/v1/AUTH_cfa/c/o',\n            environ={'REQUEST_METHOD': 'DELETE'},\n            headers={'x-container-sync-key': 'wrongsecret',\n                     'x-timestamp': '123.456'})\n        req.remote_addr = '127.0.0.1'\n        resp = req.get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n\n        self.test_auth.app = FakeApp(iter([('204 No Content', {}, '')]),\n                                     sync_key='othersecret')\n        req = Request.blank('/v1/AUTH_cfa/c/o',\n            environ={'REQUEST_METHOD': 'DELETE'},\n            headers={'x-container-sync-key': 'secret',\n                     'x-timestamp': '123.456'})\n        req.remote_addr = '127.0.0.1'\n        resp = req.get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n\n        self.test_auth.app = FakeApp(iter([('204 No Content', {}, '')]),\n                                     sync_key=None)\n        req = Request.blank('/v1/AUTH_cfa/c/o',\n            environ={'REQUEST_METHOD': 'DELETE'},\n            headers={'x-container-sync-key': 'secret',\n                     'x-timestamp': '123.456'})\n        req.remote_addr = '127.0.0.1'\n        resp = req.get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n\n    def test_sync_request_fail_no_timestamp(self):\n        self.test_auth.app = FakeApp(iter([('204 No Content', {}, '')]),\n                                     sync_key='secret')\n        req = Request.blank('/v1/AUTH_cfa/c/o',\n            environ={'REQUEST_METHOD': 'DELETE'},\n            headers={'x-container-sync-key': 'secret'})\n        req.remote_addr = '127.0.0.1'\n        resp = req.get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n\n    def test_sync_request_fail_sync_host(self):\n        self.test_auth.app = FakeApp(iter([('204 No Content', {}, '')]),\n                                     sync_key='secret')\n        req = Request.blank('/v1/AUTH_cfa/c/o',\n            environ={'REQUEST_METHOD': 'DELETE'},\n            headers={'x-container-sync-key': 'secret',\n                     'x-timestamp': '123.456'})\n        req.remote_addr = '127.0.0.2'\n        resp = req.get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n\n    def test_sync_request_success_lb_sync_host(self):\n        self.test_auth.app = FakeApp(iter([('204 No Content', {}, '')]),\n                                     sync_key='secret')\n        req = Request.blank('/v1/AUTH_cfa/c/o',\n            environ={'REQUEST_METHOD': 'DELETE'},\n            headers={'x-container-sync-key': 'secret',\n                     'x-timestamp': '123.456',\n                     'x-forwarded-for': '127.0.0.1'})\n        req.remote_addr = '127.0.0.2'\n        resp = req.get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 204)\n\n        self.test_auth.app = FakeApp(iter([('204 No Content', {}, '')]),\n                                     sync_key='secret')\n        req = Request.blank('/v1/AUTH_cfa/c/o',\n            environ={'REQUEST_METHOD': 'DELETE'},\n            headers={'x-container-sync-key': 'secret',\n                     'x-timestamp': '123.456',\n                     'x-cluster-client-ip': '127.0.0.1'})\n        req.remote_addr = '127.0.0.2'\n        resp = req.get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 204)\n\n    def _make_request(self, path, **kwargs):\n        req = Request.blank(path, **kwargs)\n        req.environ['swift.cache'] = FakeMemcache()\n        return req\n\n    def test_override_asked_for_but_not_allowed(self):\n        self.test_auth = \\\n            auth.filter_factory({'allow_overrides': 'false'})(FakeApp())\n        req = self._make_request('/v1/AUTH_account',\n                                 environ={'swift.authorize_override': True})\n        resp = req.get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n        self.assertEqual(resp.environ['swift.authorize'],\n                         self.test_auth.authorize)\n\n    def test_override_asked_for_and_allowed(self):\n        self.test_auth = \\\n            auth.filter_factory({'allow_overrides': 'true'})(FakeApp())\n        req = self._make_request('/v1/AUTH_account',\n                                 environ={'swift.authorize_override': True})\n        resp = req.get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 404)\n        self.assertTrue('swift.authorize' not in resp.environ)\n\n    def test_override_default_allowed(self):\n        req = self._make_request('/v1/AUTH_account',\n                                 environ={'swift.authorize_override': True})\n        resp = req.get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 404)\n        self.assertTrue('swift.authorize' not in resp.environ)\n\n    def test_token_too_long(self):\n        req = self._make_request('/v1/AUTH_account', headers={\n            'x-auth-token': 'a' * MAX_TOKEN_LENGTH})\n        resp = req.get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 401)\n        self.assertNotEqual(resp.body, 'Token exceeds maximum length.')\n        req = self._make_request('/v1/AUTH_account', headers={\n            'x-auth-token': 'a' * (MAX_TOKEN_LENGTH + 1)})\n        resp = req.get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 400)\n        self.assertEqual(resp.body, 'Token exceeds maximum length.')\n\n    def test_s3_enabled_when_conditions_are_met(self):\n        # auth_type_salt needs to be set\n        for atype in ('Sha1', 'Sha512'):\n            test_auth = \\\n                auth.filter_factory({\n                    'super_admin_key': 'supertest',\n                    's3_support': 'on',\n                    'auth_type_salt': 'blah',\n                    'auth_type': atype})(FakeApp())\n            self.assertTrue(test_auth.s3_support)\n        # auth_type_salt need not be set for Plaintext\n        test_auth = \\\n            auth.filter_factory({\n                'super_admin_key': 'supertest',\n                's3_support': 'on',\n                'auth_type': 'Plaintext'})(FakeApp())\n        self.assertTrue(test_auth.s3_support)\n\n    def test_s3_disabled_when_conditions_not_met(self):\n        # Conf says that it wants s3 support but other conditions are not met\n        # In that case s3 support should be disabled.\n        for atype in ('Sha1', 'Sha512'):\n            # auth_type_salt is not set\n            test_auth = \\\n                auth.filter_factory({\n                    'super_admin_key': 'supertest',\n                    's3_support': 'on',\n                    'auth_type': atype})(FakeApp())\n            self.assertFalse(test_auth.s3_support)\n\n    def test_s3_authorization_default_off(self):\n        self.assertFalse(self.test_auth.s3_support)\n        req = self._make_request('/v1/AUTH_account', headers={\n            'authorization': 's3_header'})\n        resp = req.get_response(self.test_auth)\n        self.assertEqual(resp.status_int, 400)  # HTTPBadRequest\n        self.assertTrue(resp.environ.get('swift.authorize') is None)\n\n    def test_s3_turned_off_get_groups(self):\n        env = \\\n            {'HTTP_AUTHORIZATION': 's3 header'}\n        token = 'whatever'\n        self.test_auth.logger = mock.Mock()\n        self.assertEqual(self.test_auth.get_groups(env, token), None)\n\n    def test_default_storage_policy(self):\n        ath = auth.filter_factory({})(FakeApp())\n        self.assertEqual(ath.default_storage_policy, None)\n\n        ath = \\\n            auth.filter_factory({'default_storage_policy': 'ssd'})(FakeApp())\n        self.assertEqual(ath.default_storage_policy, 'ssd')\n\n    def test_s3_creds_unicode(self):\n        self.test_auth.s3_support = True\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {},\n             json.dumps({\"auth\": unicode(\"plaintext:key)\"),\n                         \"groups\": [{'name': \"act:usr\"}, {'name': \"act\"},\n                                    {'name': \".admin\"}]})),\n            ('204 Ok', {'X-Container-Meta-Account-Id': 'AUTH_act'}, '')]))\n        env = \\\n            {'HTTP_AUTHORIZATION': 'AWS act:user:3yW7oFFWOn+fhHMu7E47RKotL1Q=',\n             'PATH_INFO': '/v1/AUTH_act/c1'}\n        token = 'UFVUCgoKRnJpLCAyNiBGZWIgMjAxNiAwNjo0NT'\\\n                'ozNCArMDAwMAovY29udGFpbmVyMw=='\n        self.assertEqual(self.test_auth.get_groups(env, token), None)\n\n    def test_s3_only_hash_passed_to_hmac(self):\n        self.test_auth.s3_support = True\n        key = 'dadada'\n        salt = 'zuck'\n        key_hash = hashlib.sha1('%s%s' % (salt, key)).hexdigest()\n        auth_stored = \"sha1:%s$%s\" % (salt, key_hash)\n        self.test_auth.app = FakeApp(iter([\n            ('200 Ok', {},\n             json.dumps({\"auth\": auth_stored,\n                         \"groups\": [{'name': \"act:usr\"}, {'name': \"act\"},\n                                    {'name': \".admin\"}]})),\n            ('204 Ok', {'X-Container-Meta-Account-Id': 'AUTH_act'}, '')]))\n        env = \\\n            {'HTTP_AUTHORIZATION': 'AWS act:user:whatever',\n             'PATH_INFO': '/v1/AUTH_act/c1'}\n        token = 'UFVUCgoKRnJpLCAyNiBGZWIgMjAxNiAwNjo0NT'\\\n                'ozNCArMDAwMAovY29udGFpbmVyMw=='\n        mock_hmac_new = mock.MagicMock()\n        with mock.patch('hmac.new', mock_hmac_new):\n            self.test_auth.get_groups(env, token)\n        self.assertTrue(mock_hmac_new.called)\n        # Assert that string passed to hmac.new is only the hash\n        self.assertEqual(mock_hmac_new.call_args[0][0], key_hash)\n\n    def test_get_concealed_token(self):\n        auth.HASH_PATH_PREFIX = 'start'\n        auth.HASH_PATH_SUFFIX = 'end'\n        token = 'token'\n\n        # Check sha512 of \"start:token:end\"\n        hashed_token = self.test_auth._get_concealed_token(token)\n        self.assertEqual(hashed_token,\n                'cb320540b0b4c69eb83de2ffb80714cb6766e2d06b5579d1a35a9c4c3fb62'\n                '981ec50bcc3fb94521133e69a87d1efcb83efd78f35a06b6375e410201476'\n                '0722f6')\n\n        # Check sha512 of \"start:token2:end\"\n        token = 'token2'\n        hashed_token = self.test_auth._get_concealed_token(token)\n        self.assertEqual(hashed_token,\n                'ca400a6f884c168357f6af0609fda66aecd5aa613147167487495dd9f39fd'\n                '8a77288568e65857294f01e398d7f14328e855f18517ccf94185d849e7f34'\n                'f4259d')\n\n        # Check sha512 of \"start2:token2:end\"\n        auth.HASH_PATH_PREFIX = 'start2'\n        hashed_token = self.test_auth._get_concealed_token(token)\n        self.assertEqual(hashed_token,\n                'ad594a69f44dd6e0aad54e360b01f15bd4833ccb4dcd9116d7aba0c25fb95'\n                '670155b8cc7175def7aeeb4624a0f2bb7da5f0b204a4680ea7947d3d6a045'\n                '22bdde')\n\n        # Check sha512 of \"start2:token2:end2\"\n        auth.HASH_PATH_SUFFIX = 'end2'\n        hashed_token = self.test_auth._get_concealed_token(token)\n        self.assertEqual(hashed_token,\n                '446af2473ad6b28319a0fe02719a9d715b9941d12e0709851aedb4f53b890'\n                '693e7f1328e68d870fe114f35f4ed9648b16a5013182db50d3d1f79a660f2'\n                '0e078e')\n\n\nif __name__ == '__main__':\n    unittest.main()\n"], "filenames": ["swauth/middleware.py", "test/unit/test_authtypes.py", "test/unit/test_middleware.py"], "buggy_code_start_loc": [17, 204, 4127], "buggy_code_end_loc": [1444, 204, 4127], "fixing_code_start_loc": [18, 205, 4128], "fixing_code_end_loc": [1461, 206, 4164], "type": "CWE-287", "message": "An issue was discovered in middleware.py in OpenStack Swauth through 1.2.0 when used with OpenStack Swift through 2.15.1. The Swift object store and proxy server are saving (unhashed) tokens retrieved from the Swauth middleware authentication mechanism to a log file as part of a GET URI. This allows attackers to bypass authentication by inserting a token into an X-Auth-Token header of a new request. NOTE: github.com/openstack/swauth URLs do not mean that Swauth is maintained by an official OpenStack project team.", "other": {"cve": {"id": "CVE-2017-16613", "sourceIdentifier": "cve@mitre.org", "published": "2017-11-21T13:29:00.267", "lastModified": "2017-12-12T18:03:27.630", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in middleware.py in OpenStack Swauth through 1.2.0 when used with OpenStack Swift through 2.15.1. The Swift object store and proxy server are saving (unhashed) tokens retrieved from the Swauth middleware authentication mechanism to a log file as part of a GET URI. This allows attackers to bypass authentication by inserting a token into an X-Auth-Token header of a new request. NOTE: github.com/openstack/swauth URLs do not mean that Swauth is maintained by an official OpenStack project team."}, {"lang": "es", "value": "Se descubri\u00f3 un problema en middleware.py en OpenStack Swauth hasta la versi\u00f3n 1.2.0 cuando se utiliza con OpenStack Swift hasta la versi\u00f3n 2.15.1. El servidor proxy y el almac\u00e9n de objetos de Swift guardan los tokens (sin los hashes correspondientes) que se recuperan del mecanismo de autenticaci\u00f3n de middleware de Swauth en un archivo de log como parte de una URI GET. Esto permite que los atacantes omitan la autenticaci\u00f3n insertando un token en una cabecera X-Auth-Token de una nueva petici\u00f3n. NOTA: las URL de github.com/openstack/swauth no quieren decir que hay un equipo oficial del proyecto OpenStack que mantenga Swauth."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openstack:swauth:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.2.0", "matchCriteriaId": "569523A9-D620-4EBF-A80E-F920C81D96ED"}, {"vulnerable": true, "criteria": "cpe:2.3:a:openstack:swift:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.15.1", "matchCriteriaId": "DC9FBBDE-80EF-4E50-B65B-D2EB7FAF3CF3"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/101926", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=882314", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://bugs.launchpad.net/swift/+bug/1655781", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/openstack/swauth/commit/70af7986265a3defea054c46efc82d0698917298", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2017/dsa-4044", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/openstack/swauth/commit/70af7986265a3defea054c46efc82d0698917298"}}