{"buggy_code": ["## Master\n\n* Features\n  * Add pumactl `thread-backtraces` command to print thread backtraces (#2053)\n  * Configuration: `environment` is read from `RAILS_ENV`, if `RACK_ENV` can't be found (#2022)\n  * Do not set user_config to quiet by default to allow for file config (#2074)\n  * `Puma.stats` now returns a Hash instead of a JSON string (#2086)\n  * `GC.compact` is called before fork if available (#2093)\n  * Add `requests_count` to workers stats. (#2106)\n  * Changed #connected_port to #connected_ports (#2076)\n  * `--control` has been removed. Use `--control-url` (#1487)\n  * `worker_directory` has been removed. Use `directory`\n\n* Bugfixes\n  * Windows update extconf.rb for use with ssp and varied Ruby/MSYS2 combinations (#2069)\n  * Preserve `BUNDLE_GEMFILE` env var when using `prune_bundler` (#1893)\n  * Send 408 request timeout even when queue requests is disabled (#2119)\n  * Rescue IO::WaitReadable instead of EAGAIN for blocking read (#2121)\n\n* Refactor\n  * Remove unused loader argument from Plugin initializer (#2095)\n  * Simplify `Configuration.random_token` and remove insecure fallback (#2102)\n  * Simplify `Runner#start_control` URL parsing (#2111)\n  * Removed the IOBuffer extension and replaced with Ruby (#1980)\n\n## 4.3.2 and 3.12.3 / 2020-02-27\n\n* Security\n  * Fix: Prevent HTTP Response splitting via CR/LF in header values. CVE-2020-5247.\n\n## 4.3.1 and 3.12.2 / 2019-12-05\n\n* Security\n  * Fix: a poorly-behaved client could use keepalive requests to monopolize Puma's reactor and create a denial of service attack. CVE-2019-16770.\n\n## 4.3.0 / 2019-11-07\n\n* Features\n  * Strip whitespace at end of HTTP headers (#2010)\n  * Optimize HTTP parser for JRuby (#2012)\n  * Add SSL support for the control app and cli (#2046, #2052)\n\n* Bugfixes\n  * Fix Errno::EINVAL when SSL is enabled and browser rejects cert (#1564)\n  * Fix pumactl defaulting puma to development if an environment was not specified (#2035)\n  * Fix closing file stream when reading pid from pidfile (#2048)\n  * Fix a typo in configuration option `--extra_runtime_dependencies` (#2050)\n\n## 4.2.1 / 2019-10-07\n\n* 3 bugfixes\n  * Fix socket activation of systemd (pre-existing) unix binder files (#1842, #1988)\n  * Deal with multiple calls to bind correctly (#1986, #1994, #2006)\n  * Accepts symbols for `verify_mode` (#1222)\n\n## 4.2.0 / 2019-09-23\n\n* 6 features\n  * Pumactl has a new -e environment option and reads `config/puma/<environment>.rb` config files (#1885)\n  * Semicolons are now allowed in URL paths (MRI only), useful for Angular or Redmine (#1934)\n  * Allow extra dependencies to be defined when using prune_bundler (#1105)\n  * Puma now reports the correct port when binding to port 0, also reports other listeners when binding to localhost (#1786)\n  * Sending SIGINFO to any Puma worker now prints currently active threads and their backtraces (#1320)\n  * Puma threads all now have their name set on Ruby 2.3+ (#1968)\n* 4 bugfixes\n  * Fix some misbehavior with phased restart and externally SIGTERMed workers (#1908, #1952)\n  * Fix socket closing on error (#1941)\n  * Removed unnecessary SIGINT trap for JRuby that caused some race conditions (#1961)\n  * Fix socket files being left around after process stopped (#1970)\n* Absolutely thousands of lines of test improvements and fixes thanks to @MSP-Greg\n\n## 4.1.1 / 2019-09-05\n\n* 3 bugfixes\n  * Revert our attempt to not dup STDOUT/STDERR (#1946)\n  * Fix socket close on error (#1941)\n  * Fix workers not shutting down correctly (#1908)\n\n## 4.1.0 / 2019-08-08\n\n* 4 features\n  * Add REQUEST_PATH on parse error message (#1831)\n  * You can now easily add custom log formatters with the `log_formatter` config option (#1816)\n  * Puma.stats now provides process start times (#1844)\n  * Add support for disabling TLSv1.1 (#1836)\n\n* 7 bugfixes\n  * Fix issue where Puma was creating zombie process entries (#1887)\n  * Fix bugs with line-endings and chunked encoding (#1812)\n  * RACK_URL_SCHEME is now set correctly in all conditions (#1491)\n  * We no longer mutate global STDOUT/STDERR, particularly the sync setting (#1837)\n  * SSL read_nonblock no longer blocks (#1857)\n  * Swallow connection errors when sending early hints (#1822)\n  * Backtrace no longer dumped when invalid pumactl commands are run (#1863)\n\n* 5 other\n  * Avoid casting worker_timeout twice (#1838)\n  * Removed a call to private that wasn't doing anything (#1882)\n  * README, Rakefile, docs and test cleanups (#1848, #1847, #1846, #1853, #1859, #1850, #1866, #1870, #1872, #1833, #1888)\n  * Puma.io has proper documentation now (https://puma.io/puma/)\n  * Added the Contributor Covenant CoC\n\n* 1 known issue\n  * Some users are still experiencing issues surrounding socket activation and Unix sockets (#1842)\n\n## 4.0.1 / 2019-07-11\n\n* 2 bugfixes\n  * Fix socket removed after reload - should fix problems with systemd socket activation. (#1829)\n  * Add extconf tests for DTLS_method & TLS_server_method, use in minissl.rb. Should fix \"undefined symbol: DTLS_method\" when compiling against old OpenSSL versions. (#1832)\n* 1 other\n  * Removed unnecessary RUBY_VERSION checks. (#1827)\n\n## 4.0.0 / 2019-06-25\n\n* 9 features\n  * Add support for disabling TLSv1.0 (#1562)\n  * Request body read time metric (#1569)\n  * Add out_of_band hook (#1648)\n  * Re-implement (native) IOBuffer for JRuby (#1691)\n  * Min worker timeout (#1716)\n  * Add option to suppress SignalException on SIGTERM (#1690)\n  * Allow mutual TLS CA to be set using `ssl_bind` DSL (#1689)\n  * Reactor now uses nio4r instead of `select` (#1728)\n  * Add status to pumactl with pidfile (#1824)\n\n* 10 bugfixes\n  * Do not accept new requests on shutdown (#1685, #1808)\n  * Fix 3 corner cases when request body is chunked (#1508)\n  * Change pid existence check's condition branches (#1650)\n  * Don't call .stop on a server that doesn't exist (#1655)\n  * Implemented NID_X9_62_prime256v1 (P-256) curve over P-521 (#1671)\n  * Fix @notify.close can't modify frozen IOError (RuntimeError) (#1583)\n  * Fix Java 8 support (#1773)\n  * Fix error `uninitialized constant Puma::Cluster` (#1731)\n  * Fix `not_token` being able to be set to true (#1803)\n  * Fix \"Hang on SIGTERM with ruby 2.6 in clustered mode\" ([PR #1741], [#1674], [#1720], [#1730], [#1755])\n\n[PR #1741]: https://github.com/puma/puma/pull/1741\n[#1674]: https://github.com/puma/puma/issues/1674\n[#1720]: https://github.com/puma/puma/issues/1720\n[#1730]: https://github.com/puma/puma/issues/1730\n[#1755]: https://github.com/puma/puma/issues/1755\n\n## 3.12.1 / 2019-03-19\n\n* 1 features\n  * Internal strings are frozen (#1649)\n* 3 bugfixes\n  * Fix chunked ending check (#1607)\n  * Rack handler should use provided default host (#1700)\n  * Better support for detecting runtimes that support `fork` (#1630)\n\n## 3.12.0 / 2018-07-13\n\n* 5 features:\n  * You can now specify which SSL ciphers the server should support, default is unchanged (#1478)\n  * The setting for Puma's `max_threads` is now in `Puma.stats` (#1604)\n  * Pool capacity is now in `Puma.stats` (#1579)\n  * Installs restricted to Ruby 2.2+ (#1506)\n  * `--control` is now deprecated in favor of `--control-url` (#1487)\n\n* 2 bugfixes:\n  * Workers will no longer accept more web requests than they have capacity to process. This prevents an issue where one worker would accept lots of requests while starving other workers (#1563)\n  * In a test env puma now emits the stack on an exception (#1557)\n\n## 3.11.4 / 2018-04-12\n\n* 2 features:\n  * Manage puma as a service using rc.d (#1529)\n  * Server stats are now available from a top level method (#1532)\n* 5 bugfixes:\n  * Fix parsing CLI options (#1482)\n  * Order of stderr and stdout is made before redirecting to a log file (#1511)\n  * Init.d fix of `ps -p` to check if pid exists (#1545)\n  * Early hints bugfix (#1550)\n  * Purge interrupt queue when closing socket fails (#1553)\n\n## 3.11.3 / 2018-03-05\n\n* 3 bugfixes:\n  * Add closed? to MiniSSL::Socket for use in reactor (#1510)\n  * Handle EOFError at the toplevel of the server threads (#1524) (#1507)\n  * Deal with zero sized bodies when using SSL (#1483)\n\n## 3.11.2 / 2018-01-19\n\n* 1 bugfix:\n  * Deal with read\\_nonblock returning nil early\n\n## 3.11.1 / 2018-01-18\n\n* 1 bugfix:\n  * Handle read\\_nonblock returning nil when the socket close (#1502)\n\n## 3.11.0 / 2017-11-20\n\n* 2 features:\n  * HTTP 103 Early Hints (#1403)\n  * 421/451 status codes now have correct status messages attached (#1435)\n\n* 9 bugfixes:\n  * Environment config files (/config/puma/<ENV>.rb) load correctly (#1340)\n  * Specify windows dependencies correctly (#1434, #1436)\n  * puma/events required in test helper (#1418)\n  * Correct control CLI's option help text (#1416)\n  * Remove a warning for unused variable in mini_ssl (#1409)\n  * Correct pumactl docs argument ordering (#1427)\n  * Fix an uninitialized variable warning in server.rb (#1430)\n  * Fix docs typo/error in Launcher init (#1429)\n  * Deal with leading spaces in RUBYOPT (#1455)\n\n* 2 other:\n  * Add docs about internals (#1425, #1452)\n  * Tons of test fixes from @MSP-Greg (#1439, #1442, #1464)\n\n## 3.10.0 / 2017-08-17\n\n* 3 features:\n  * The status server has a new /gc and /gc-status command. (#1384)\n  * The persistent and first data timeouts are now configurable (#1111)\n  * Implemented RFC 2324 (#1392)\n\n* 12 bugfixes:\n  * Not really a Puma bug, but @NickolasVashchenko created a gem to workaround a Ruby bug that some users of Puma may be experiencing. See README for more. (#1347)\n  * Fix hangups with SSL and persistent connections. (#1334)\n  * Fix Rails double-binding to a port (#1383)\n  * Fix incorrect thread names (#1368)\n  * Fix issues with /etc/hosts and JRuby where localhost addresses were not correct. (#1318)\n  * Fix compatibility with RUBYOPT=\"--enable-frozen-string-literal\" (#1376)\n  * Fixed some compiler warnings (#1388)\n  * We actually run the integration tests in CI now (#1390)\n  * No longer shipping unnecessary directories in the gemfile (#1391)\n  * If RUBYOPT is nil, we no longer blow up on restart. (#1385)\n  * Correct response to SIGINT (#1377)\n  * Proper exit code returned when we receive a TERM signal (#1337)\n\n* 3 refactors:\n  * Various test improvements from @grosser\n  * Rubocop (#1325)\n  * Hoe has been removed (#1395)\n\n* 1 known issue:\n  * Socket activation doesn't work in JRuby. Their fault, not ours. (#1367)\n\n## 3.9.1 / 2017-06-03\n\n* 2 bugfixes:\n  * Fixed compatibility with older Bundler versions (#1314)\n  * Some internal test/development cleanup (#1311, #1313)\n\n## 3.9.0 / 2017-06-01\n\n* 2 features:\n  * The ENV is now reset to its original values when Puma restarts via USR1/USR2 (#1260) (MRI only, no JRuby support)\n  * Puma will no longer accept more clients than the maximum number of threads. (#1278)\n\n* 9 bugfixes:\n  * Reduce information leakage by preventing HTTP parse errors from writing environment hashes to STDERR (#1306)\n  * Fix SSL/WebSocket compatibility (#1274)\n  * HTTP headers with empty values are no longer omitted from responses. (#1261)\n  * Fix a Rack env key which was set to nil. (#1259)\n  * peercert has been implemented for JRuby (#1248)\n  * Fix port settings when using rails s (#1277, #1290)\n  * Fix compat w/LibreSSL (#1285)\n  * Fix restarting Puma w/symlinks and a new Gemfile (#1282)\n  * Replace Dir.exists? with Dir.exist? (#1294)\n\n* 1 known issue:\n  * A bug in MRI 2.2+ can result in IOError: stream closed. See #1206. This issue has existed since at least Puma 3.6, and probably further back.\n\n* 1 refactor:\n  * Lots of test fixups from @grosser.\n\n## 3.8.2 / 2017-03-14\n\n* 1 bugfix:\n  * Deal with getsockopt with TCP\\_INFO failing for sockets that say they're TCP but aren't really. (#1241)\n\n## 3.8.1 / 2017-03-10\n\n* 1 bugfix:\n  * Remove method call to method that no longer exists (#1239)\n\n## 3.8.0 / 2017-03-09\n\n* 2 bugfixes:\n  * Port from rack handler does not take precedence over config file in Rails 5.1.0.beta2+ and 5.0.1.rc3+ (#1234)\n  * The `tmp/restart.txt` plugin no longer restricts the user from running more than one server from the same folder at a time (#1226)\n\n* 1 feature:\n  * Closed clients are aborted to save capacity (#1227)\n\n* 1 refactor:\n  * Bundler is no longer a dependency from tests (#1213)\n\n## 3.7.1 / 2017-02-20\n\n* 2 bugfixes:\n  * Fix typo which blew up MiniSSL (#1182)\n  * Stop overriding command-line options with the config file (#1203)\n\n## 3.7.0 / 2017-01-04\n\n* 6 minor features:\n  * Allow rack handler to accept ssl host. (#1129)\n  * Refactor TTOU processing. TTOU now handles multiple signals at once. (#1165)\n  * Pickup any remaining chunk data as the next request.\n  * Prevent short term thread churn - increased auto trim default to 30 seconds.\n  * Raise error when `stdout` or `stderr` is not writable. (#1175)\n  * Add Rack 2.0 support to gemspec. (#1068)\n\n* 5 refactors:\n  * Compare host and server name only once per call. (#1091)\n  * Minor refactor on Thread pool (#1088)\n  * Removed a ton of unused constants, variables and files.\n  * Use MRI macros when allocating heap memory\n  * Use hooks for on\\_booted event. (#1160)\n\n* 14 bugfixes:\n  * Add eof? method to NullIO? (#1169)\n  * Fix Puma startup in provided init.d script (#1061)\n  * Fix default SSL mode back to none. (#1036)\n  * Fixed the issue of @listeners getting nil io (#1120)\n  * Make `get_dh1024` compatible with OpenSSL v1.1.0 (#1178)\n  * More gracefully deal with SSL sessions. Fixes #1002\n  * Move puma.rb to just autoloads. Fixes #1063\n  * MiniSSL: Provide write as <<. Fixes #1089\n  * Prune bundler should inherit fds (#1114)\n  * Replace use of Process.getpgid which does not behave as intended on all platforms (#1110)\n  * Transfer encoding header should be downcased before comparison (#1135)\n  * Use same write log logic for hijacked requests. (#1081)\n  * Fix `uninitialized constant Puma::StateFile` (#1138)\n  * Fix access priorities of each level in LeveledOptions (#1118)\n\n* 3 others:\n\n  * Lots of tests added/fixed/improved. Switched to Minitest from Test::Unit. Big thanks to @frodsan.\n  * Lots of documentation added/improved.\n  * Add license indicators to the HTTP extension. (#1075)\n\n## 3.6.2 / 2016-11-22\n\n* 1 bug fix:\n\n  * Revert #1118/Fix access priorities of each level in LeveledOptions. This\n    had an unintentional side effect of changing the importance of command line\n    options, such as -p.\n\n## 3.6.1 / 2016-11-21\n\n* 8 bug fixes:\n\n  * Fix Puma start in init.d script.\n  * Fix default SSL mode back to none. Fixes #1036\n  * Fixed the issue of @listeners getting nil io, fix rails restart (#1120)\n  * More gracefully deal with SSL sessions. Fixes #1002\n  * Prevent short term thread churn.\n  * Provide write as <<. Fixes #1089\n  * Fix access priorities of each level in LeveledOptions - fixes TTIN.\n  * Stub description files updated for init.d.\n\n* 2 new project committers:\n\n  * Nate Berkopec (@nateberkopec)\n  * Richard Schneeman (@schneems)\n\n## 3.6.0 / 2016-07-24\n\n* 12 bug fixes:\n  * Add ability to detect a shutting down server. Fixes #932\n  * Add support for Expect: 100-continue. Fixes #519\n  * Check SSLContext better. Fixes #828\n  * Clarify behavior of '-t num'. Fixes #984\n  * Don't default to VERIFY_PEER. Fixes #1028\n  * Don't use ENV['PWD'] on windows. Fixes #1023\n  * Enlarge the scope of catching app exceptions. Fixes #1027\n  * Execute background hooks after daemonizing. Fixes #925\n  * Handle HUP as a stop unless there is IO redirection. Fixes #911\n  * Implement chunked request handling. Fixes #620\n  * Just rescue exception to return a 500. Fixes #1027\n  * Redirect IO in the jruby daemon mode. Fixes #778\n\n## 3.5.2 / 2016-07-20\n\n* 1 bug fix:\n  * Don't let persistent_timeout be nil\n\n* 1 PR merged:\n  * Merge pull request #1021 from benzrf/patch-1\n\n## 3.5.1 / 2016-07-20\n\n* 1 bug fix:\n  * Be sure to only listen on host:port combos once. Fixes #1022\n\n## 3.5.0 / 2016-07-18\n\n* 1 minor features:\n  * Allow persistent_timeout to be configured via the dsl.\n\n* 9 bug fixes:\n  * Allow a bare % in a query string. Fixes #958\n  * Explicitly listen on all localhost addresses. Fixes #782\n  * Fix `TCPLogger` log error in tcp cluster mode.\n  * Fix puma/puma#968 Cannot bind SSL port due to missing verify_mode option\n  * Fix puma/puma#968 Default verify_mode to peer\n  * Log any exceptions in ThreadPool. Fixes #1010\n  * Silence connection errors in the reactor. Fixes #959\n  * Tiny fixes in hook documentation for #840\n  * It should not log requests if we want it to be quiet\n\n* 5 doc fixes:\n  * Add How to stop Puma on Heroku using plugins to the example directory\n  * Provide both hot and phased restart in jungle script\n  * Update reference to the instances management script\n  * Update default number of threads\n  * Fix typo in example config\n\n* 14 PRs merged:\n  * Merge pull request #1007 from willnet/patch-1\n  * Merge pull request #1014 from jeznet/patch-1\n  * Merge pull request #1015 from bf4/patch-1\n  * Merge pull request #1017 from jorihardman/configurable_persistent_timeout\n  * Merge pull request #954 from jf/master\n  * Merge pull request #955 from jf/add-request-info-to-standard-error-rescue\n  * Merge pull request #956 from maxkwallace/master\n  * Merge pull request #960 from kmayer/kmayer-plugins-heroku-restart\n  * Merge pull request #969 from frankwong15/master\n  * Merge pull request #970 from willnet/delete-blank-document\n  * Merge pull request #974 from rocketjob/feature/name_threads\n  * Merge pull request #977 from snow/master\n  * Merge pull request #981 from zach-chai/patch-1\n  * Merge pull request #993 from scorix/master\n\n## 3.4.0 / 2016-04-07\n\n* 2 minor features:\n  * Add ability to force threads to stop on shutdown. Fixes #938\n  * Detect and commit seppuku when fork(2) fails. Fixes #529\n\n* 3 unknowns:\n  * Ignore errors trying to update the backport tables. Fixes #788\n  * Invoke the lowlevel_error in more places to allow for exception tracking. Fixes #894\n  * Update the query string when an absolute URI is used. Fixes #937\n\n* 5 doc fixes:\n  * Add Process Monitors section to top-level README\n  * Better document the hooks. Fixes #840\n  * docs/system.md sample config refinements and elaborations\n  * Fix typos at couple of places.\n  * Cleanup warnings\n\n* 3 PRs merged:\n  * Merge pull request #945 from dekellum/systemd-docs-refined\n  * Merge pull request #946 from vipulnsward/rm-pid\n  * Merge pull request #947 from vipulnsward/housekeeping-typos\n\n## 3.3.0 / 2016-04-05\n\n* 2 minor features:\n  * Allow overriding options of Configuration object\n  * Rename to inherit_ssl_listener like inherit_tcp|unix\n\n* 2 doc fixes:\n  * Add docs/systemd.md (with socket activation sub-section)\n  * Document UNIX signals with cluster on README.md\n\n* 3 PRs merged:\n  * Merge pull request #936 from prathamesh-sonpatki/allow-overriding-config-options\n  * Merge pull request #940 from kyledrake/signalsdoc\n  * Merge pull request #942 from dekellum/socket-activate-improve\n\n## 3.2.0 / 2016-03-20\n\n* 1 deprecation removal:\n  * Delete capistrano.rb\n\n* 3 bug fixes:\n  * Detect gems.rb as well as Gemfile\n  * Simplify and fix logic for directory to use when restarting for all phases\n  * Speed up phased-restart start\n\n* 2 PRs merged:\n  * Merge pull request #927 from jlecour/gemfile_variants\n  * Merge pull request #931 from joneslee85/patch-10\n\n## 3.1.1 / 2016-03-17\n\n* 4 bug fixes:\n  * Disable USR1 usage on JRuby\n  * Fixes #922 - Correctly define file encoding as UTF-8\n  * Set a more explicit SERVER_SOFTWARE Rack variable\n  * Show RUBY_ENGINE_VERSION if available. Fixes #923\n\n* 3 PRs merged:\n  * Merge pull request #912 from tricknotes/fix-allow-failures-in-travis-yml\n  * Merge pull request #921 from swrobel/patch-1\n  * Merge pull request #924 from tbrisker/patch-1\n\n## 3.1.0 / 2016-03-05\n\n* 1 minor feature:\n  * Add 'import' directive to config file. Fixes #916\n\n* 5 bug fixes:\n  * Add 'fetch' to options. Fixes #913\n  * Fix jruby daemonization. Fixes #918\n  * Recreate the proper args manually. Fixes #910\n  * Require 'time' to get iso8601. Fixes #914\n\n## 3.0.2 / 2016-02-26\n\n* 5 bug fixes:\n\n  * Fix 'undefined local variable or method `pid` for #<Puma::ControlCLI:0x007f185fcef968>' when execute pumactl with `--pid` option.\n  * Fix 'undefined method `windows?` for Puma:Module' when execute pumactl.\n  * Harden tmp_restart against errors related to the restart file\n  * Make `plugin :tmp_restart` behavior correct in Windows.\n  * fix uninitialized constant Puma::ControlCLI::StateFile\n\n* 3 PRs merged:\n\n  * Merge pull request #901 from mitto/fix-pumactl-uninitialized-constant-statefile\n  * Merge pull request #902 from corrupt952/fix_undefined_method_and_variable_when_execute_pumactl\n  * Merge pull request #905 from Eric-Guo/master\n\n## 3.0.1 / 2016-02-25\n\n* 1 bug fix:\n\n  * Removed the experimental support for async.callback as it broke\n    websockets entirely. Seems no server has both hijack and async.callback\n    and thus faye is totally confused what to do and doesn't work.\n\n## 3.0.0 / 2016-02-25\n\n* 2 major changes:\n\n  * Ruby pre-2.0 is no longer supported. We'll do our best to not add\n    features that break those rubies but will no longer be testing\n    with them.\n  * Don't log requests by default. Fixes #852\n\n* 2 major features:\n\n  * Plugin support! Plugins can interact with configuration as well\n    as provide augment server functionality!\n  * Experimental env['async.callback'] support\n\n* 4 minor features:\n\n  * Listen to unix socket with provided backlog if any\n  * Improves the clustered stats to report worker stats\n  * Pass the env to the lowlevel_error handler. Fixes #854\n  * Treat path-like hosts as unix sockets. Fixes #824\n\n* 5 bug fixes:\n\n  * Clean thread locals when using keepalive. Fixes #823\n  * Cleanup compiler warnings. Fixes #815\n  * Expose closed? for use by the reactor. Fixes #835\n  * Move signal handlers to separate method to prevent space leak. Fixes #798\n  * Signal not full on worker exit #876\n\n* 5 doc fixes:\n\n  * Update README.md with various grammar fixes\n  * Use newest version of Minitest\n  * Add directory configuration docs, fix typo [ci skip]\n  * Remove old COPYING notice. Fixes #849\n\n* 10 merged PRs:\n\n  * Merge pull request #871 from deepj/travis\n  * Merge pull request #874 from wallclockbuilder/master\n  * Merge pull request #883 from dadah89/igor/trim_only_worker\n  * Merge pull request #884 from uistudio/async-callback\n  * Merge pull request #888 from mlarraz/tick_minitest\n  * Merge pull request #890 from todd/directory_docs\n  * Merge pull request #891 from ctaintor/improve_clustered_status\n  * Merge pull request #893 from spastorino/add_missing_require\n  * Merge pull request #897 from zendesk/master\n  * Merge pull request #899 from kch/kch-readme-fixes\n\n## 2.16.0 / 2016-01-27\n\n* 7 minor features:\n\n  * Add 'set_remote_address' config option\n  * Allow to run puma in silent mode\n  * Expose cli options in DSL\n  * Support passing JRuby keystore info in ssl_bind DSL\n  * Allow umask for unix:/// style control urls\n  * Expose `old_worker_count` in stats url\n  * Support TLS client auth (verify_mode) in jruby\n\n* 7 bug fixes:\n\n  * Don't persist before_fork hook in state file\n  * Reload bundler before pulling in rack. Fixes #859\n  * Remove NEWRELIC_DISPATCHER env variable\n  * Cleanup C code\n  * Use Timeout.timeout instead of Object.timeout\n  * Make phased restarts faster\n  * Ignore the case of certain headers, because HTTP\n\n* 1 doc changes:\n\n  * Test against the latest Ruby 2.1, 2.2, 2.3, head and JRuby 9.0.4.0 on Travis\n\n* 12 merged PRs\n  * Merge pull request #822 from kwugirl/remove_NEWRELIC_DISPATCHER\n  * Merge pull request #833 from joemiller/jruby-client-tls-auth\n  * Merge pull request #837 from YuriSolovyov/ssl-keystore-jruby\n  * Merge pull request #839 from mezuka/master\n  * Merge pull request #845 from deepj/timeout-deprecation\n  * Merge pull request #846 from sriedel/strip_before_fork\n  * Merge pull request #850 from deepj/travis\n  * Merge pull request #853 from Jeffrey6052/patch-1\n  * Merge pull request #857 from zendesk/faster_phased_restarts\n  * Merge pull request #858 from mlarraz/fix_some_warnings\n  * Merge pull request #860 from zendesk/expose_old_worker_count\n  * Merge pull request #861 from zendesk/allow_control_url_umask\n\n## 2.15.3 / 2015-11-07\n\n* 1 bug fix:\n\n  * Fix JRuby parser\n\n## 2.15.2 / 2015-11-06\n\n* 2 bug fixes:\n  * ext/puma_http11: handle duplicate headers as per RFC\n  * Only set ctx.ca iff there is a params['ca'] to set with.\n\n* 2 PRs merged:\n  * Merge pull request #818 from unleashed/support-duplicate-headers\n  * Merge pull request #819 from VictorLowther/fix-ca-and-verify_null-exception\n\n## 2.15.1 / 2015-11-06\n\n* 1 bug fix:\n\n  * Allow older openssl versions\n\n## 2.15.0 / 2015-11-06\n\n* 6 minor features:\n  * Allow setting ca without setting a verify mode\n  * Make jungle for init.d support rbenv\n  * Use SSL_CTX_use_certificate_chain_file for full chain\n  * cluster: add worker_boot_timeout option\n  * configuration: allow empty tags to mean no tag desired\n  * puma/cli: support specifying STD{OUT,ERR} redirections and append mode\n\n* 5 bug fixes:\n  * Disable SSL Compression\n  * Fix bug setting worker_directory when using a symlink directory\n  * Fix error message in DSL that was slightly inaccurate\n  * Pumactl: set correct process name. Fixes #563\n  * thread_pool: fix race condition when shutting down workers\n\n* 10 doc fixes:\n  * Add before_fork explanation in Readme.md\n  * Correct spelling in DEPLOYMENT.md\n  * Correct spelling in docs/nginx.md\n  * Fix spelling errors.\n  * Fix typo in deployment description\n  * Fix typos (it's -> its) in events.rb and server.rb\n  * fixing for typo mentioned in #803\n  * Spelling correction for README\n  * thread_pool: fix typos in comment\n  * More explicit docs for worker_timeout\n\n* 18 PRs merged:\n  * Merge pull request #768 from nathansamson/patch-1\n  * Merge pull request #773 from rossta/spelling_corrections\n  * Merge pull request #774 from snow/master\n  * Merge pull request #781 from sunsations/fix-typo\n  * Merge pull request #791 from unleashed/allow_empty_tags\n  * Merge pull request #793 from robdimarco/fix-working-directory-symlink-bug\n  * Merge pull request #794 from peterkeen/patch-1\n  * Merge pull request #795 from unleashed/redirects-from-cmdline\n  * Merge pull request #796 from cschneid/fix_dsl_message\n  * Merge pull request #799 from annafw/master\n  * Merge pull request #800 from liamseanbrady/fix_typo\n  * Merge pull request #801 from scottjg/ssl-chain-file\n  * Merge pull request #802 from scottjg/ssl-crimes\n  * Merge pull request #804 from burningTyger/patch-2\n  * Merge pull request #809 from unleashed/threadpool-fix-race-in-shutdown\n  * Merge pull request #810 from vlmonk/fix-pumactl-restart-bug\n  * Merge pull request #814 from schneems/schneems/worker_timeout-docs\n  * Merge pull request #817 from unleashed/worker-boot-timeout\n\n## 2.14.0 / 2015-09-18\n\n* 1 minor feature:\n  * Make building with SSL support optional\n\n* 1 bug fix:\n  * Use Rack::Builder if available. Fixes #735\n\n## 2.13.4 / 2015-08-16\n\n* 1 bug fix:\n  * Use the environment possible set by the config early and from\n    the config file later (if set).\n\n## 2.13.3 / 2015-08-15\n\nSeriously, I need to revamp config with tests.\n\n* 1 bug fix:\n  * Fix preserving options before cleaning for state. Fixes #769\n\n## 2.13.2 / 2015-08-15\n\nThe \"clearly I don't have enough tests for the config\" release.\n\n* 1 bug fix:\n  * Fix another place binds wasn't initialized. Fixes #767\n\n## 2.13.1 / 2015-08-15\n\n* 2 bug fixes:\n  * Fix binds being masked in config files. Fixes #765\n  * Use options from the config file properly in pumactl. Fixes #764\n\n## 2.13.0 / 2015-08-14\n\n* 1 minor feature:\n  * Add before_fork hooks option.\n\n* 3 bug fixes:\n  * Check for OPENSSL_NO_ECDH before using ECDH\n  * Eliminate logging overhead from JRuby SSL\n  * Prefer cli options over config file ones. Fixes #669\n\n* 1 deprecation:\n  * Add deprecation warning to capistrano.rb. Fixes #673\n\n* 4 PRs merged:\n  * Merge pull request #668 from kcollignon/patch-1\n  * Merge pull request #754 from nathansamson/before_boot\n  * Merge pull request #759 from BenV/fix-centos6-build\n  * Merge pull request #761 from looker/no-log\n\n## 2.12.3 / 2015-08-03\n\n* 8 minor bugs fixed:\n  * Fix Capistrano 'uninitialized constant Puma' error.\n  * Fix some ancient and incorrect error handling code\n  * Fix uninitialized constant error\n  * Remove toplevel rack interspection, require rack on load instead\n  * Skip empty parts when chunking\n  * Switch from inject to each in config_ru_binds iteration\n  * Wrap SSLv3 spec in version guard.\n  * ruby 1.8.7 compatibility patches\n\n* 4 PRs merged:\n  * Merge pull request #742 from deivid-rodriguez/fix_missing_require\n  * Merge pull request #743 from matthewd/skip-empty-chunks\n  * Merge pull request #749 from huacnlee/fix-cap-uninitialized-puma-error\n  * Merge pull request #751 from costi/compat_1_8_7\n\n* 1 test fix:\n  * Add 1.8.7, rbx-1 (allow failures) to Travis.\n\n## 2.12.2 / 2015-07-17\n\n* 2 bug fix:\n  * Pull over and use Rack::URLMap. Fixes #741\n  * Stub out peercert on JRuby for now. Fixes #739\n\n## 2.12.1 / 2015-07-16\n\n* 2 bug fixes:\n  * Use a constant format. Fixes #737\n  * Use strerror for Windows sake. Fixes #733\n\n* 1 doc change:\n  * typo fix: occured -> occurred\n\n* 1 PR merged:\n  * Merge pull request #736 from paulanunda/paulanunda/typo-fix\n\n## 2.12.0 / 2015-07-14\n\n* 13 bug fixes:\n  * Add thread reaping to thread pool\n  * Do not automatically use chunked responses when hijacked\n  * Do not suppress Content-Length on partial hijack\n  * Don't allow any exceptions to terminate a thread\n  * Handle ENOTCONN client disconnects when setting REMOTE_ADDR\n  * Handle very early exit of cluster mode. Fixes #722\n  * Install rack when running tests on travis to use rack/lint\n  * Make puma -v and -h return success exit code\n  * Make pumactl load config/puma.rb by default\n  * Pass options from pumactl properly when pruning. Fixes #694\n  * Remove rack dependency. Fixes #705\n  * Remove the default Content-Type: text/plain\n  * Add Client Side Certificate Auth\n\n* 8 doc/test changes:\n  * Added example sourcing of environment vars\n  * Added tests for bind configuration on rackup file\n  * Fix example config text\n  * Update DEPLOYMENT.md\n  * Update Readme with example of custom error handler\n  * ci: Improve Travis settings\n  * ci: Start running tests against JRuby 9k on Travis\n  * ci: Convert to container infrastructure for travisci\n\n* 2 ops changes:\n  * Check for system-wide rbenv\n  * capistrano: Add additional env when start rails\n\n* 16 PRs merged:\n  * Merge pull request #686 from jjb/patch-2\n  * Merge pull request #693 from rob-murray/update-example-config\n  * Merge pull request #697 from spk/tests-bind-on-rackup-file\n  * Merge pull request #699 from deees/fix/require_rack_builder\n  * Merge pull request #701 from deepj/master\n  * Merge pull request #702 from Jimdo/thread-reaping\n  * Merge pull request #703 from deepj/travis\n  * Merge pull request #704 from grega/master\n  * Merge pull request #709 from lian/master\n  * Merge pull request #711 from julik/master\n  * Merge pull request #712 from yakara-ltd/pumactl-default-config\n  * Merge pull request #715 from RobotJiang/master\n  * Merge pull request #725 from rwz/master\n  * Merge pull request #726 from strenuus/handle-client-disconnect\n  * Merge pull request #729 from allaire/patch-1\n  * Merge pull request #730 from iamjarvo/container-infrastructure\n\n## 2.11.3 / 2015-05-18\n\n* 5 bug fixes:\n  * Be sure to unlink tempfiles after a request. Fixes #690\n  * Coerce the key to a string before checking. (thar be symbols). Fixes #684\n  * Fix hang on bad SSL handshake\n  * Remove `enable_SSLv3` support from JRuby\n\n* 1 PR merged:\n  * Merge pull request #698 from looker/hang-handshake\n\n## 2.11.2 / 2015-04-11\n\n* 2 minor features:\n  * Add `on_worker_fork` hook, which allows to mimic Unicorn's behavior\n  * Add shutdown_debug config option\n\n* 4 bug fixes:\n  * Fix the Config constants not being available in the DSL. Fixes #683\n  * Ignore multiple port declarations\n  * Proper 'Connection' header handling compatible with HTTP 1.[01] protocols\n  * Use \"Puma\" instead of \"puma\" to reporting to New Relic\n\n* 1 doc fixes:\n  * Add Gitter badge.\n\n* 6 PRs merged:\n  * Merge pull request #657 from schneems/schneems/puma-once-port\n  * Merge pull request #658 from Tomohiro/newrelic-dispatcher-default-update\n  * Merge pull request #662 from basecrm/connection-compatibility\n  * Merge pull request #664 from fxposter/on-worker-fork\n  * Merge pull request #667 from JuanitoFatas/doc/gemspec\n  * Merge pull request #672 from chulkilee/refactor\n\n## 2.11.1 / 2015-02-11\n\n* 2 bug fixes:\n  * Avoid crash in strange restart conditions\n  * Inject the GEM_HOME that bundler into puma-wild's env. Fixes #653\n\n* 2 PRs merged:\n  * Merge pull request #644 from bpaquet/master\n  * Merge pull request #646 from mkonecny/master\n\n## 2.11.0 / 2015-01-20\n\n* 9 bug fixes:\n  * Add mode as an additional bind option to unix sockets. Fixes #630\n  * Advertise HTTPS properly after a hot restart\n  * Don't write lowlevel_error_handler to state\n  * Fix phased restart with stuck requests\n  * Handle spaces in the path properly. Fixes #622\n  * Set a default REMOTE_ADDR to avoid using peeraddr on unix sockets. Fixes #583\n  * Skip device number checking on jruby. Fixes #586\n  * Update extconf.rb to compile correctly on OS X\n  * redirect io right after daemonizing so startup errors are shown. Fixes #359\n\n* 6 minor features:\n  * Add a configuration option that prevents puma from queueing requests.\n  * Add reload_worker_directory\n  * Add the ability to pass environment variables to the init script (for Jungle).\n  * Add the proctitle tag to the worker. Fixes #633\n  * Infer a proctitle tag based on the directory\n  * Update lowlevel error message to be more meaningful.\n\n* 10 PRs merged:\n  * Merge pull request #478 from rubencaro/master\n  * Merge pull request #610 from kwilczynski/master\n  * Merge pull request #611 from jasonl/better-lowlevel-message\n  * Merge pull request #616 from jc00ke/master\n  * Merge pull request #623 from raldred/patch-1\n  * Merge pull request #628 from rdpoor/master\n  * Merge pull request #634 from deepj/master\n  * Merge pull request #637 from raskhadafi/patch-1\n  * Merge pull request #639 from ebeigarts/fix-phased-restarts\n  * Merge pull request #640 from codehotter/issue-612-dependent-requests-deadlock\n\n## 2.10.2 / 2014-11-26\n\n* 1 bug fix:\n  * Conditionalize thread local cleaning, fixes perf degradation fix\n    The code to clean out all Thread locals adds pretty significant\n    overhead to a each request, so it has to be turned on explicitly\n    if a user needs it.\n\n## 2.10.1 / 2014-11-24\n\n* 1 bug fix:\n  * Load the app after daemonizing because the app might start threads.\n\n  This change means errors loading the app are now reported only in the redirected\n  stdout/stderr.\n\n  If you're app has problems starting up, start it without daemon mode initially\n  to test.\n\n## 2.10.0 / 2014-11-23\n\n* 3 minor features:\n  * Added on_worker_shutdown hook mechanism\n  * Allow binding to ipv6 addresses for ssl URIs\n  * Warn about any threads started during app preload\n\n* 5 bug fixes:\n  * Clean out a threads local data before doing work\n  * Disable SSLv3. Fixes #591\n  * First change the directory to use the correct Gemfile.\n  * Only use config.ru binds if specified. Fixes #606\n  * Strongish cipher suite with FS support for some browsers\n\n* 2 doc changes:\n  * Change umask examples to more permissive values\n  * fix typo in README.md\n\n* 9 Merged PRs:\n  * Merge pull request #560 from raskhadafi/prune_bundler-bug\n  * Merge pull request #566 from sheltond/master\n  * Merge pull request #593 from andruby/patch-1\n  * Merge pull request #594 from hassox/thread-cleanliness\n  * Merge pull request #596 from burningTyger/patch-1\n  * Merge pull request #601 from sorentwo/friendly-umask\n  * Merge pull request #602 from 1334/patch-1\n  * Merge pull request #608 from Gu1/master\n  * Merge remote-tracking branch 'origin/pr/538'\n\n## 2.9.2 / 2014-10-25\n\n* 8 bug fixes:\n  * Fix puma-wild handling a restart properly. Fixes #550\n  * JRuby SSL POODLE update\n  * Keep deprecated features warnings\n  * Log the current time when Puma shuts down.\n  * Fix cross-platform extension library detection\n  * Use the correct Windows names for OpenSSL.\n  * Better error logging during startup\n  * Fixing sexist error messages\n\n* 6 PRs merged:\n  * Merge pull request #549 from bsnape/log-shutdown-time\n  * Merge pull request #553 from lowjoel/master\n  * Merge pull request #568 from mariuz/patch-1\n  * Merge pull request #578 from danielbuechele/patch-1\n  * Merge pull request #581 from alexch/slightly-better-logging\n  * Merge pull request #590 from looker/jruby_disable_sslv3\n\n## 2.9.1 / 2014-09-05\n\n* 4 bug fixes:\n  * Cleanup the SSL related structures properly, fixes memory leak\n  * Fix thread spawning edge case.\n  * Force a worker check after a worker boots, don't wait 5sec. Fixes #574\n  * Implement SIGHUP for logs reopening\n\n* 2 PRs merged:\n  * Merge pull request #561 from theoldreader/sighup\n  * Merge pull request #570 from havenwood/spawn-thread-edge-case\n\n## 2.9.0 / 2014-07-12\n\n* 1 minor feature:\n  * Add SSL support for JRuby\n\n* 3 bug fixes:\n  * Typo BUNDLER_GEMFILE -> BUNDLE_GEMFILE\n  * Use fast_write because we can't trust syswrite\n  * pumactl - do not modify original ARGV\n\n* 4 doc fixes:\n  * BSD-3-Clause over BSD to avoid confusion\n  * Deploy doc: clarification of the GIL\n  * Fix typo in DEPLOYMENT.md\n  * Update README.md\n\n* 6 PRs merged:\n  * Merge pull request #520 from misfo/patch-2\n  * Merge pull request #530 from looker/jruby-ssl\n  * Merge pull request #537 from vlmonk/patch-1\n  * Merge pull request #540 from allaire/patch-1\n  * Merge pull request #544 from chulkilee/bsd-3-clause\n  * Merge pull request #551 from jcxplorer/patch-1\n\n## 2.8.2 / 2014-04-12\n\n* 4 bug fixes:\n  * During upgrade, change directory in main process instead of workers.\n  * Close the client properly on error\n  * Capistrano: fallback from phased restart to start when not started\n  * Allow tag option in conf file\n\n* 4 doc fixes:\n  * Fix Puma daemon service README typo\n  * `preload_app!` instead of `preload_app`\n  * add preload_app and prune_bundler to example config\n  * allow changing of worker_timeout in config file\n\n* 11 PRs merged:\n  * Merge pull request #487 from ckuttruff/master\n  * Merge pull request #492 from ckuttruff/master\n  * Merge pull request #493 from alepore/config_tag\n  * Merge pull request #503 from mariuz/patch-1\n  * Merge pull request #505 from sammcj/patch-1\n  * Merge pull request #506 from FlavourSys/config_worker_timeout\n  * Merge pull request #510 from momer/rescue-block-handle-servers-fix\n  * Merge pull request #511 from macool/patch-1\n  * Merge pull request #514 from edogawaconan/refactor_env\n  * Merge pull request #517 from misfo/patch-1\n  * Merge pull request #518 from LongMan/master\n\n## 2.8.1 / 2014-03-06\n\n* 1 bug fixes:\n  * Run puma-wild with proper deps for prune_bundler\n\n* 2 doc changes:\n  * Described the configuration file finding behavior added in 2.8.0 and how to disable it.\n  * Start the deployment doc\n\n* 6 PRs merged:\n  * Merge pull request #471 from arthurnn/fix_test\n  * Merge pull request #485 from joneslee85/patch-9\n  * Merge pull request #486 from joshwlewis/patch-1\n  * Merge pull request #490 from tobinibot/patch-1\n  * Merge pull request #491 from brianknight10/clarify-no-config\n\n## 2.8.0 / 2014-02-28\n\n* 8 minor features:\n  * Add ability to autoload a config file. Fixes #438\n  * Add ability to detect and terminate hung workers. Fixes #333\n  * Add booted_workers to stats response\n  * Add config to customize the default error message\n  * Add prune_bundler option\n  * Add worker indexes, expose them via on_worker_boot. Fixes #440\n  * Add pretty process name\n  * Show the ruby version in use\n\n* 7 bug fixes:\n  * Added 408 status on timeout.\n  * Be more hostile with sockets that write block. Fixes #449\n  * Expect at_exit to exclusively remove the pidfile. Fixes #444\n  * Expose latency and listen backlog via bind query. Fixes #370\n  * JRuby raises IOError if the socket is there. Fixes #377\n  * Process requests fairly. Fixes #406\n  * Rescue SystemCallError as well. Fixes #425\n\n* 4 doc changes:\n  * Add 2.1.0 to the matrix\n  * Add Code Climate badge to README\n  * Create signals.md\n  * Set the license to BSD. Fixes #432\n\n* 14 PRs merged:\n  * Merge pull request #428 from alexeyfrank/capistrano_default_hooks\n  * Merge pull request #429 from namusyaka/revert-const_defined\n  * Merge pull request #431 from mrb/master\n  * Merge pull request #433 from alepore/process-name\n  * Merge pull request #437 from ibrahima/master\n  * Merge pull request #446 from sudara/master\n  * Merge pull request #451 from pwiebe/status_408\n  * Merge pull request #453 from joevandyk/patch-1\n  * Merge pull request #470 from arthurnn/fix_458\n  * Merge pull request #472 from rubencaro/master\n  * Merge pull request #480 from jjb/docs-on-running-test-suite\n  * Merge pull request #481 from schneems/master\n  * Merge pull request #482 from prathamesh-sonpatki/signals-doc-cleanup\n  * Merge pull request #483 from YotpoLtd/master\n\n## 2.7.1 / 2013-12-05\n\n* 1 bug fix:\n\n  * Keep STDOUT/STDERR the right mode. Fixes #422\n\n## 2.7.0 / 2013-12-03\n\n* 1 minor feature:\n  * Adding TTIN and TTOU to increment/decrement workers\n\n* N bug fixes:\n  * Always use our Process.daemon because it's not busted\n  * Add capistrano restart failback to start.\n  * Change position of `cd` so that rvm gemset is loaded\n  * Clarify some platform specifics\n  * Do not close the pipe sockets when retrying\n  * Fix String#byteslice for Ruby 1.9.1, 1.9.2\n  * Fix compatibility with 1.8.7.\n  * Handle IOError closed stream in IO.select\n  * Increase the max URI path length to 2048 chars from 1024 chars\n  * Upstart jungle use config/puma.rb instead\n\n## 2.6.0 / 2013-09-13\n\n* 2 minor features:\n  * Add support for event hooks\n  ** Add a hook for state transitions\n  * Add phased restart to capistrano recipe.\n\n* 4 bug fixes:\n  * Convince workers to stop by SIGKILL after timeout\n  * Define RSTRING_NOT_MODIFIED for Rubinius performance\n  * Handle BrokenPipe, StandardError and IOError in fat_wrote and break out\n  * Return success status to the invoking environment\n\n## 2.5.1 / 2013-08-13\n\n* 2 bug fixes:\n\n  * Keep jruby daemon mode from retrying on a hot restart\n  * Extract version from const.rb in gemspec\n\n## 2.5.0 / 2013-08-08\n\n* 2 minor features:\n  * Allow configuring pumactl with config.rb\n  * make `pumactl restart` start puma if not running\n\n* 6 bug fixes:\n  * Autodetect ruby managers and home directory in upstart script\n  * Convert header values to string before sending.\n  * Correctly report phased-restart availability\n  * Fix pidfile creation/deletion race on jruby daemonization\n  * Use integers when comparing thread counts\n  * Fix typo in using lopez express (raw tcp) mode\n\n* 6 misc changes:\n  * Fix typo in phased-restart response\n  * Uncomment setuid/setgid by default in upstart\n  * Use Puma::Const::PUMA_VERSION in gemspec\n  * Update upstart comments to reflect new commandline\n  * Remove obsolete pumactl instructions; refer to pumactl for details\n  * Make Bundler used puma.gemspec version agnostic\n\n## 2.4.1 / 2013-08-07\n\n* 1 experimental feature:\n  * Support raw tcp servers (aka Lopez Express mode)\n\n## 2.4.0 / 2013-07-22\n\n* 5 minor features:\n  * Add PUMA_JRUBY_DAEMON_OPTS to get around agent starting twice\n  * Add ability to drain accept socket on shutdown\n  * Add port to DSL\n  * Adds support for using puma config file in capistrano deploys.\n  * Make phased_restart fallback to restart if not available\n\n* 10 bug fixes:\n\n  * Be sure to only delete the pid in the master. Fixes #334\n  * Call out -C/--config flags\n  * Change parser symbol names to avoid clash. Fixes #179\n  * Convert thread pool sizes to integers\n  * Detect when the jruby daemon child doesn't start properly\n  * Fix typo in CLI help\n  * Improve the logging output when hijack is used. Fixes #332\n  * Remove unnecessary thread pool size conversions\n  * Setup :worker_boot as an Array. Fixes #317\n  * Use 127.0.0.1 as REMOTE_ADDR of unix client. Fixes #309\n\n\n## 2.3.2 / 2013-07-08\n\n* 1 bug fix:\n\n  * Move starting control server to after daemonization.\n\n## 2.3.1 / 2013-07-06\n\n* 2 bug fixes:\n\n  * Include the right files in the Manifest.\n  * Disable inheriting connections on restart on windows. Fixes #166\n\n* 1 doc change:\n  * Better document some platform constraints\n\n## 2.3.0 / 2013-07-05\n\n* 1 major bug fix:\n\n  * Stabilize control server, add support in cluster mode\n\n* 5 minor bug fixes:\n\n  * Add ability to cleanup stale unix sockets\n  * Check status data better. Fixes #292\n  * Convert raw IO errors to ConnectionError. Fixes #274\n  * Fix sending Content-Type and Content-Length for no body status. Fixes #304\n  * Pass state path through to `pumactl start`. Fixes #287\n\n* 2 internal changes:\n\n  * Refactored modes into seperate classes that CLI uses\n  * Changed CLI to take an Events object instead of stdout/stderr (API change)\n\n## 2.2.2 / 2013-07-02\n\n* 1 bug fix:\n\n  * Fix restart_command in the config\n\n## 2.2.1 / 2013-07-02\n\n* 1 minor feature:\n\n  * Introduce preload flag\n\n* 1 bug fix:\n\n  * Pass custom restart command in JRuby\n\n## 2.2.0 / 2013-07-01\n\n* 1 major feature:\n\n  * Add ability to preload rack app\n\n* 2 minor bugfixes:\n\n  * Don't leak info when not in development. Fixes #256\n  * Load the app, then bind the ports\n\n## 2.1.1 / 2013-06-20\n\n* 2 minor bug fixes:\n\n  * Fix daemonization on jruby\n  * Load the application before daemonizing. Fixes #285\n\n## 2.1.0 / 2013-06-18\n\n* 3 minor features:\n  * Allow listening socket to be configured via Capistrano variable\n  * Output results from 'stat's command when using pumactl\n  * Support systemd socket activation\n\n* 15 bug fixes:\n  * Deal with pipes closing while stopping. Fixes #270\n  * Error out early if there is no app configured\n  * Handle ConnectionError rather than the lowlevel exceptions\n  * tune with `-C` config file and `on_worker_boot`\n  * use `-w`\n  * Fixed some typos in upstart scripts\n  * Make sure to use bytesize instead of size (MiniSSL write)\n  * Fix an error in puma-manager.conf\n  * fix: stop leaking sockets on restart (affects ruby 1.9.3 or before)\n  * Ignore errors on the cross-thread pipe. Fixes #246\n  * Ignore errors while uncorking the socket (it might already be closed)\n  * Ignore the body on a HEAD request. Fixes #278\n  * Handle all engine data when possible. Fixes #251.\n  * Handle all read exceptions properly. Fixes #252\n  * Handle errors from the server better\n\n* 3 doc changes:\n  * Add note about on_worker_boot hook\n  * Add some documentation for Clustered mode\n  * Added quotes to /etc/puma.conf\n\n## 2.0.1 / 2013-04-30\n\n* 1 bug fix:\n\n  * Fix not starting on JRuby properly\n\n## 2.0.0 / 2013-04-29\n\nRailsConf 2013 edition!\n\n* 2 doc changes:\n  * Start with rackup -s Puma, NOT rackup -s puma.\n  * Minor doc fixes in the README.md, Capistrano section\n\n* 2 bug fixes:\n  * Fix reading RACK_ENV properly. Fixes #234\n  * Make cap recipe handle tmp/sockets; fixes #228\n\n* 3 minor changes:\n  * Fix capistrano recipe\n  * Fix stdout/stderr logs to sync outputs\n  * allow binding to IPv6 addresses\n\n## 2.0.0.b7 / 2013-03-18\n\n* 5 minor enhancements:\n\n  * Add -q option for :start\n  * Add -V, --version\n  * Add default Rack handler helper\n  * Upstart support\n  * Set worker directory from configuration file\n\n* 12 bug fixes:\n\n  * Close the binder in the right place. Fixes #192\n  * Handle early term in workers. Fixes #206\n  * Make sure that the default port is 80 when the request doesn't include HTTP_X_FORWARDED_PROTO.\n  * Prevent Errno::EBADF errors on restart when running ruby 2.0\n  * Record the proper @master_pid\n  * Respect the header HTTP_X_FORWARDED_PROTO when the host doesn't include a port number.\n  * Retry EAGAIN/EWOULDBLOCK during syswrite\n  * Run exec properly to restart. Fixes #154\n  * Set Rack run_once to false\n  * Syncronize all access to @timeouts. Fixes #208\n  * Write out the state post-daemonize. Fixes #189\n  * Prevent crash when all workers are gone\n\n## 2.0.0.b6 / 2013-02-06\n\n* 2 minor enhancements:\n\n  * Add hook for running when a worker boots\n  * Advertise the Configuration object for apps to use.\n\n* 1 bug fix:\n\n  * Change directory in working during upgrade. Fixes #185\n\n## 2.0.0.b5 / 2013-02-05\n\n* 2 major features:\n  * Add phased worker upgrade\n  * Add support for the rack hijack protocol\n\n* 2 minor features:\n  * Add -R to specify the restart command\n  * Add config file option to specify the restart command\n\n* 5 bug fixes:\n  * Cleanup pipes properly. Fixes #182\n  * Daemonize earlier so that we don't lose app threads. Fixes #183\n  * Drain the notification pipe. Fixes #176, thanks @cryo28\n  * Move write_pid to after we daemonize. Fixes #180\n  * Redirect IO properly and emit message for checkpointing\n\n## 2.0.0.b4 / 2012-12-12\n\n* 4 bug fixes:\n  * Properly check #syswrite's value for variable sized buffers. Fixes #170\n  * Shutdown status server properly\n  * Handle char vs byte and mixing syswrite with write properly\n  * made MiniSSL validate key/cert file existence\n\n## 2.0.0.b3 / 2012-11-22\n\n* 1 bug fix:\n  * Package right files in gem\n\n## 2.0.0.b2 / 2012-11-18\n* 5 minor feature:\n  * Now Puma is bundled with an capistrano recipe. Just require\n     'puma/capistrano' in you deploy.rb\n  * Only inject CommonLogger in development mode\n  * Add -p option to pumactl\n  * Add ability to use pumactl to start a server\n  * Add options to daemonize puma\n\n* 7 bug fixes:\n  * Reset the IOBuffer properly. Fixes #148\n  * Shutdown gracefully on JRuby with Ctrl-C\n  * Various methods to get newrelic to start. Fixes #128\n  * fixing syntax error at capistrano recipe\n  * Force ECONNRESET when read returns nil\n  * Be sure to empty the drain the todo before shutting down. Fixes #155\n  * allow for alternate locations for status app\n\n## 2.0.0.b1 / 2012-09-11\n\n* 1 major feature:\n  * Optional worker process mode (-w) to allow for process scaling in\n    addition to thread scaling\n\n* 1 bug fix:\n  * Introduce Puma::MiniSSL to be able to properly control doing\n    nonblocking SSL\n\nNOTE: SSL support in JRuby is not supported at present. Support will\nbe added back in a future date when a java Puma::MiniSSL is added.\n\n## 1.6.3 / 2012-09-04\n\n* 1 bug fix:\n  * Close sockets waiting in the reactor when a hot restart is performed\n    so that browsers reconnect on the next request\n\n## 1.6.2 / 2012-08-27\n\n* 1 bug fix:\n  * Rescue StandardError instead of IOError to handle SystemCallErrors\n    as well as other application exceptions inside the reactor.\n\n## 1.6.1 / 2012-07-23\n\n* 1 packaging bug fixed:\n  * Include missing files\n\n## 1.6.0 / 2012-07-23\n\n* 1 major bug fix:\n  * Prevent slow clients from starving the server by introducing a\n    dedicated IO reactor thread. Credit for reporting goes to @meh.\n\n## 1.5.0 / 2012-07-19\n\n* 7 contributors to this release:\n  * Christian Mayer\n  * Dar\u00edo Javier Cravero\n  * Dirkjan Bussink\n  * Gianluca Padovani\n  * Santiago Pastorino\n  * Thibault Jouan\n  * tomykaira\n\n* 6 bug fixes:\n  * Define RSTRING_NOT_MODIFIED for Rubinius\n  * Convert status to integer. Fixes #123\n  * Delete pidfile when stopping the server\n  * Allow compilation with -Werror=format-security option\n  * Fix wrong HTTP version for a HTTP/1.0 request\n  * Use String#bytesize instead of String#length\n\n* 3 minor features:\n  * Added support for setting RACK_ENV via the CLI, config file, and rack app\n  * Allow Server#run to run sync. Fixes #111\n  * Puma can now run on windows\n\n## 1.4.0 / 2012-06-04\n\n* 1 bug fix:\n  * SCRIPT_NAME should be passed from env to allow mounting apps\n\n* 1 experimental feature:\n  * Add puma.socket key for direct socket access\n\n## 1.3.1 / 2012-05-15\n\n* 2 bug fixes:\n  * use #bytesize instead of #length for Content-Length header\n  * Use StringIO properly. Fixes #98\n\n## 1.3.0 / 2012-05-08\n\n* 2 minor features:\n  * Return valid Rack responses (passes Lint) from status server\n  * Add -I option to specify $LOAD_PATH directories\n\n* 4 bug fixes:\n  * Don't join the server thread inside the signal handle. Fixes #94\n  * Make NullIO#read mimic IO#read\n  * Only stop the status server if it's started. Fixes #84\n  * Set RACK_ENV early in cli also. Fixes #78\n\n* 1 new contributor:\n  * Jesse Cooke\n\n## 1.2.2 / 2012-04-28\n\n* 4 bug fixes:\n\n  * Report a lowlevel error to stderr\n  * Set a fallback SERVER_NAME and SERVER_PORT\n  * Keep the encoding of the body correct. Fixes #79\n  * show error.to_s along with backtrace for low-level error\n\n## 1.2.1 / 2012-04-11\n\n 1 bug fix:\n\n   * Fix rack.url_scheme for SSL servers. Fixes #65\n\n## 1.2.0 / 2012-04-11\n\n 1 major feature:\n\n   * When possible, the internal restart does a \"hot restart\" meaning\n     the server sockets remains open, so no connections are lost.\n\n 1 minor feature:\n\n    * More helpful fallback error message\n\n 6 bug fixes:\n\n    * Pass the proper args to unknown_error. Fixes #54, #58\n    * Stop the control server before restarting. Fixes #61\n    * Fix reporting https only on a true SSL connection\n    * Set the default content type to 'text/plain'. Fixes #63\n    * Use REUSEADDR. Fixes #60\n    * Shutdown gracefully on SIGTERM. Fixes #53\n\n 2 new contributors:\n\n   * Seamus Abshere\n   * Steve Richert\n\n## 1.1.1 / 2012-03-30\n\n 1 bugfix:\n\n   * Include puma/compat.rb in the gem (oops!)\n\n## 1.1.0 / 2012-03-30\n\n 1 bugfix:\n\n   * Make sure that the unix socket has the perms 0777 by default\n\n 1 minor feature:\n\n   * Add umask param to the unix:// bind to set the umask\n\n## 1.0.0 / 2012-03-29\n\n* Released!\n\n## Ignore - this is for maintainers to copy-paste during release\n## Master\n\n* Features\n  * Your feature goes here (#Github Number)\n\n* Bugfixes\n  * Your bugfix goes here (#Github Number)\n", "#encoding: utf-8\n# frozen_string_literal: true\n\nmodule Puma\n  class UnsupportedOption < RuntimeError\n  end\n\n\n  # Every standard HTTP code mapped to the appropriate message.  These are\n  # used so frequently that they are placed directly in Puma for easy\n  # access rather than Puma::Const itself.\n\n  # Every standard HTTP code mapped to the appropriate message.\n  # Generated with:\n  # curl -s https://www.iana.org/assignments/http-status-codes/http-status-codes-1.csv | \\\n  #   ruby -ne 'm = /^(\\d{3}),(?!Unassigned|\\(Unused\\))([^,]+)/.match($_) and \\\n  #             puts \"#{m[1]} => \\x27#{m[2].strip}\\x27,\"'\n  HTTP_STATUS_CODES = {\n    100 => 'Continue',\n    101 => 'Switching Protocols',\n    102 => 'Processing',\n    200 => 'OK',\n    201 => 'Created',\n    202 => 'Accepted',\n    203 => 'Non-Authoritative Information',\n    204 => 'No Content',\n    205 => 'Reset Content',\n    206 => 'Partial Content',\n    207 => 'Multi-Status',\n    208 => 'Already Reported',\n    226 => 'IM Used',\n    300 => 'Multiple Choices',\n    301 => 'Moved Permanently',\n    302 => 'Found',\n    303 => 'See Other',\n    304 => 'Not Modified',\n    305 => 'Use Proxy',\n    307 => 'Temporary Redirect',\n    308 => 'Permanent Redirect',\n    400 => 'Bad Request',\n    401 => 'Unauthorized',\n    402 => 'Payment Required',\n    403 => 'Forbidden',\n    404 => 'Not Found',\n    405 => 'Method Not Allowed',\n    406 => 'Not Acceptable',\n    407 => 'Proxy Authentication Required',\n    408 => 'Request Timeout',\n    409 => 'Conflict',\n    410 => 'Gone',\n    411 => 'Length Required',\n    412 => 'Precondition Failed',\n    413 => 'Payload Too Large',\n    414 => 'URI Too Long',\n    415 => 'Unsupported Media Type',\n    416 => 'Range Not Satisfiable',\n    417 => 'Expectation Failed',\n    418 => 'I\\'m A Teapot',\n    421 => 'Misdirected Request',\n    422 => 'Unprocessable Entity',\n    423 => 'Locked',\n    424 => 'Failed Dependency',\n    426 => 'Upgrade Required',\n    428 => 'Precondition Required',\n    429 => 'Too Many Requests',\n    431 => 'Request Header Fields Too Large',\n    451 => 'Unavailable For Legal Reasons',\n    500 => 'Internal Server Error',\n    501 => 'Not Implemented',\n    502 => 'Bad Gateway',\n    503 => 'Service Unavailable',\n    504 => 'Gateway Timeout',\n    505 => 'HTTP Version Not Supported',\n    506 => 'Variant Also Negotiates',\n    507 => 'Insufficient Storage',\n    508 => 'Loop Detected',\n    510 => 'Not Extended',\n    511 => 'Network Authentication Required'\n  }\n\n  # For some HTTP status codes the client only expects headers.\n  #\n\n  STATUS_WITH_NO_ENTITY_BODY = {\n    204 => true,\n    205 => true,\n    304 => true\n  }\n\n  # Frequently used constants when constructing requests or responses.  Many times\n  # the constant just refers to a string with the same contents.  Using these constants\n  # gave about a 3% to 10% performance improvement over using the strings directly.\n  #\n  # The constants are frozen because Hash#[]= when called with a String key dups\n  # the String UNLESS the String is frozen. This saves us therefore 2 object\n  # allocations when creating the env hash later.\n  #\n  # While Puma does try to emulate the CGI/1.2 protocol, it does not use the REMOTE_IDENT,\n  # REMOTE_USER, or REMOTE_HOST parameters since those are either a security problem or\n  # too taxing on performance.\n  module Const\n\n    PUMA_VERSION = VERSION = \"4.3.2\".freeze\n    CODE_NAME = \"Mysterious Traveller\".freeze\n    PUMA_SERVER_STRING = ['puma', PUMA_VERSION, CODE_NAME].join(' ').freeze\n\n    FAST_TRACK_KA_TIMEOUT = 0.2\n\n    # The default number of seconds for another request within a persistent\n    # session.\n    PERSISTENT_TIMEOUT = 20\n\n    # The default number of seconds to wait until we get the first data\n    # for the request\n    FIRST_DATA_TIMEOUT = 30\n\n    # How long to wait when getting some write blocking on the socket when\n    # sending data back\n    WRITE_TIMEOUT = 10\n\n    # How many requests to attempt inline before sending a client back to\n    # the reactor to be subject to normal ordering. The idea here is that\n    # we amortize the cost of going back to the reactor for a well behaved\n    # but very \"greedy\" client across 10 requests. This prevents a not\n    # well behaved client from monopolizing the thread forever.\n    MAX_FAST_INLINE = 10\n\n    # The original URI requested by the client.\n    REQUEST_URI= 'REQUEST_URI'.freeze\n    REQUEST_PATH = 'REQUEST_PATH'.freeze\n    QUERY_STRING = 'QUERY_STRING'.freeze\n    CONTENT_LENGTH = \"CONTENT_LENGTH\".freeze\n\n    PATH_INFO = 'PATH_INFO'.freeze\n\n    PUMA_TMP_BASE = \"puma\".freeze\n\n    ERROR_RESPONSE = {\n      # Indicate that we couldn't parse the request\n      400 => \"HTTP/1.1 400 Bad Request\\r\\n\\r\\n\".freeze,\n      # The standard empty 404 response for bad requests.  Use Error4040Handler for custom stuff.\n      404 => \"HTTP/1.1 404 Not Found\\r\\nConnection: close\\r\\nServer: Puma #{PUMA_VERSION}\\r\\n\\r\\nNOT FOUND\".freeze,\n      # The standard empty 408 response for requests that timed out.\n      408 => \"HTTP/1.1 408 Request Timeout\\r\\nConnection: close\\r\\nServer: Puma #{PUMA_VERSION}\\r\\n\\r\\n\".freeze,\n      # Indicate that there was an internal error, obviously.\n      500 => \"HTTP/1.1 500 Internal Server Error\\r\\n\\r\\n\".freeze,\n      # A common header for indicating the server is too busy.  Not used yet.\n      503 => \"HTTP/1.1 503 Service Unavailable\\r\\n\\r\\nBUSY\".freeze\n    }\n\n    # The basic max request size we'll try to read.\n    CHUNK_SIZE = 16 * 1024\n\n    # This is the maximum header that is allowed before a client is booted.  The parser detects\n    # this, but we'd also like to do this as well.\n    MAX_HEADER = 1024 * (80 + 32)\n\n    # Maximum request body size before it is moved out of memory and into a tempfile for reading.\n    MAX_BODY = MAX_HEADER\n\n    REQUEST_METHOD = \"REQUEST_METHOD\".freeze\n    HEAD = \"HEAD\".freeze\n    # ETag is based on the apache standard of hex mtime-size-inode (inode is 0 on win32)\n    LINE_END = \"\\r\\n\".freeze\n    REMOTE_ADDR = \"REMOTE_ADDR\".freeze\n    HTTP_X_FORWARDED_FOR = \"HTTP_X_FORWARDED_FOR\".freeze\n    HTTP_X_FORWARDED_SSL = \"HTTP_X_FORWARDED_SSL\".freeze\n    HTTP_X_FORWARDED_SCHEME = \"HTTP_X_FORWARDED_SCHEME\".freeze\n    HTTP_X_FORWARDED_PROTO = \"HTTP_X_FORWARDED_PROTO\".freeze\n\n    SERVER_NAME = \"SERVER_NAME\".freeze\n    SERVER_PORT = \"SERVER_PORT\".freeze\n    HTTP_HOST = \"HTTP_HOST\".freeze\n    PORT_80 = \"80\".freeze\n    PORT_443 = \"443\".freeze\n    LOCALHOST = \"localhost\".freeze\n    LOCALHOST_IP = \"127.0.0.1\".freeze\n    LOCALHOST_ADDR = \"127.0.0.1:0\".freeze\n\n    SERVER_PROTOCOL = \"SERVER_PROTOCOL\".freeze\n    HTTP_11 = \"HTTP/1.1\".freeze\n\n    SERVER_SOFTWARE = \"SERVER_SOFTWARE\".freeze\n    GATEWAY_INTERFACE = \"GATEWAY_INTERFACE\".freeze\n    CGI_VER = \"CGI/1.2\".freeze\n\n    STOP_COMMAND = \"?\".freeze\n    HALT_COMMAND = \"!\".freeze\n    RESTART_COMMAND = \"R\".freeze\n\n    RACK_INPUT = \"rack.input\".freeze\n    RACK_URL_SCHEME = \"rack.url_scheme\".freeze\n    RACK_AFTER_REPLY = \"rack.after_reply\".freeze\n    PUMA_SOCKET = \"puma.socket\".freeze\n    PUMA_CONFIG = \"puma.config\".freeze\n    PUMA_PEERCERT = \"puma.peercert\".freeze\n\n    HTTP = \"http\".freeze\n    HTTPS = \"https\".freeze\n\n    HTTPS_KEY = \"HTTPS\".freeze\n\n    HTTP_VERSION = \"HTTP_VERSION\".freeze\n    HTTP_CONNECTION = \"HTTP_CONNECTION\".freeze\n    HTTP_EXPECT = \"HTTP_EXPECT\".freeze\n    CONTINUE = \"100-continue\".freeze\n\n    HTTP_11_100 = \"HTTP/1.1 100 Continue\\r\\n\\r\\n\".freeze\n    HTTP_11_200 = \"HTTP/1.1 200 OK\\r\\n\".freeze\n    HTTP_10_200 = \"HTTP/1.0 200 OK\\r\\n\".freeze\n\n    CLOSE = \"close\".freeze\n    KEEP_ALIVE = \"keep-alive\".freeze\n\n    CONTENT_LENGTH2 = \"content-length\".freeze\n    CONTENT_LENGTH_S = \"Content-Length: \".freeze\n    TRANSFER_ENCODING = \"transfer-encoding\".freeze\n    TRANSFER_ENCODING2 = \"HTTP_TRANSFER_ENCODING\".freeze\n\n    CONNECTION_CLOSE = \"Connection: close\\r\\n\".freeze\n    CONNECTION_KEEP_ALIVE = \"Connection: Keep-Alive\\r\\n\".freeze\n\n    TRANSFER_ENCODING_CHUNKED = \"Transfer-Encoding: chunked\\r\\n\".freeze\n    CLOSE_CHUNKED = \"0\\r\\n\\r\\n\".freeze\n\n    CHUNKED = \"chunked\".freeze\n\n    COLON = \": \".freeze\n\n    NEWLINE = \"\\n\".freeze\n    CRLF_REGEX = /[\\r\\n]/.freeze\n\n    HIJACK_P = \"rack.hijack?\".freeze\n    HIJACK = \"rack.hijack\".freeze\n    HIJACK_IO = \"rack.hijack_io\".freeze\n\n    EARLY_HINTS = \"rack.early_hints\".freeze\n\n    # Mininum interval to checks worker health\n    WORKER_CHECK_INTERVAL = 5\n\n  end\nend\n", "# frozen_string_literal: true\n\nrequire 'stringio'\n\nrequire 'puma/thread_pool'\nrequire 'puma/const'\nrequire 'puma/events'\nrequire 'puma/null_io'\nrequire 'puma/reactor'\nrequire 'puma/client'\nrequire 'puma/binder'\nrequire 'puma/accept_nonblock'\nrequire 'puma/util'\nrequire 'puma/io_buffer'\n\nrequire 'puma/puma_http11'\n\nrequire 'socket'\nrequire 'forwardable'\n\nmodule Puma\n\n  # The HTTP Server itself. Serves out a single Rack app.\n  #\n  # This class is used by the `Puma::Single` and `Puma::Cluster` classes\n  # to generate one or more `Puma::Server` instances capable of handling requests.\n  # Each Puma process will contain one `Puma::Server` instance.\n  #\n  # The `Puma::Server` instance pulls requests from the socket, adds them to a\n  # `Puma::Reactor` where they get eventually passed to a `Puma::ThreadPool`.\n  #\n  # Each `Puma::Server` will have one reactor and one thread pool.\n  class Server\n\n    include Puma::Const\n    extend Forwardable\n\n    attr_reader :thread\n    attr_reader :events\n    attr_reader :requests_count\n    attr_accessor :app\n\n    attr_accessor :min_threads\n    attr_accessor :max_threads\n    attr_accessor :persistent_timeout\n    attr_accessor :auto_trim_time\n    attr_accessor :reaping_time\n    attr_accessor :first_data_timeout\n\n    # Create a server for the rack app +app+.\n    #\n    # +events+ is an object which will be called when certain error events occur\n    # to be handled. See Puma::Events for the list of current methods to implement.\n    #\n    # Server#run returns a thread that you can join on to wait for the server\n    # to do its work.\n    #\n    def initialize(app, events=Events.stdio, options={})\n      @app = app\n      @events = events\n\n      @check, @notify = Puma::Util.pipe\n\n      @status = :stop\n\n      @min_threads = 0\n      @max_threads = 16\n      @auto_trim_time = 30\n      @reaping_time = 1\n\n      @thread = nil\n      @thread_pool = nil\n      @early_hints = nil\n\n      @persistent_timeout = options.fetch(:persistent_timeout, PERSISTENT_TIMEOUT)\n      @first_data_timeout = options.fetch(:first_data_timeout, FIRST_DATA_TIMEOUT)\n\n      @binder = Binder.new(events)\n\n      @leak_stack_on_error = true\n\n      @options = options\n      @queue_requests = options[:queue_requests].nil? ? true : options[:queue_requests]\n\n      ENV['RACK_ENV'] ||= \"development\"\n\n      @mode = :http\n\n      @precheck_closing = true\n\n      @requests_count = 0\n    end\n\n    attr_accessor :binder, :leak_stack_on_error, :early_hints\n\n    def_delegators :@binder, :add_tcp_listener, :add_ssl_listener, :add_unix_listener, :connected_ports\n\n    def inherit_binder(bind)\n      @binder = bind\n    end\n\n    def tcp_mode!\n      @mode = :tcp\n    end\n\n    # On Linux, use TCP_CORK to better control how the TCP stack\n    # packetizes our stream. This improves both latency and throughput.\n    #\n    if RUBY_PLATFORM =~ /linux/\n      UNPACK_TCP_STATE_FROM_TCP_INFO = \"C\".freeze\n\n      # 6 == Socket::IPPROTO_TCP\n      # 3 == TCP_CORK\n      # 1/0 == turn on/off\n      def cork_socket(socket)\n        begin\n          socket.setsockopt(6, 3, 1) if socket.kind_of? TCPSocket\n        rescue IOError, SystemCallError\n          Thread.current.purge_interrupt_queue if Thread.current.respond_to? :purge_interrupt_queue\n        end\n      end\n\n      def uncork_socket(socket)\n        begin\n          socket.setsockopt(6, 3, 0) if socket.kind_of? TCPSocket\n        rescue IOError, SystemCallError\n          Thread.current.purge_interrupt_queue if Thread.current.respond_to? :purge_interrupt_queue\n        end\n      end\n\n      def closed_socket?(socket)\n        return false unless socket.kind_of? TCPSocket\n        return false unless @precheck_closing\n\n        begin\n          tcp_info = socket.getsockopt(Socket::SOL_TCP, Socket::TCP_INFO)\n        rescue IOError, SystemCallError\n          Thread.current.purge_interrupt_queue if Thread.current.respond_to? :purge_interrupt_queue\n          @precheck_closing = false\n          false\n        else\n          state = tcp_info.unpack(UNPACK_TCP_STATE_FROM_TCP_INFO)[0]\n          # TIME_WAIT: 6, CLOSE: 7, CLOSE_WAIT: 8, LAST_ACK: 9, CLOSING: 11\n          (state >= 6 && state <= 9) || state == 11\n        end\n      end\n    else\n      def cork_socket(socket)\n      end\n\n      def uncork_socket(socket)\n      end\n\n      def closed_socket?(socket)\n        false\n      end\n    end\n\n    def backlog\n      @thread_pool and @thread_pool.backlog\n    end\n\n    def running\n      @thread_pool and @thread_pool.spawned\n    end\n\n\n    # This number represents the number of requests that\n    # the server is capable of taking right now.\n    #\n    # For example if the number is 5 then it means\n    # there are 5 threads sitting idle ready to take\n    # a request. If one request comes in, then the\n    # value would be 4 until it finishes processing.\n    def pool_capacity\n      @thread_pool and @thread_pool.pool_capacity\n    end\n\n    # Lopez Mode == raw tcp apps\n\n    def run_lopez_mode(background=true)\n      @thread_pool = ThreadPool.new(@min_threads,\n                                    @max_threads,\n                                    Hash) do |client, tl|\n\n        io = client.to_io\n        addr = io.peeraddr.last\n\n        if addr.empty?\n          # Set unix socket addrs to localhost\n          addr = \"127.0.0.1:0\"\n        else\n          addr = \"#{addr}:#{io.peeraddr[1]}\"\n        end\n\n        env = { 'thread' => tl, REMOTE_ADDR => addr }\n\n        begin\n          @app.call env, client.to_io\n        rescue Object => e\n          STDERR.puts \"! Detected exception at toplevel: #{e.message} (#{e.class})\"\n          STDERR.puts e.backtrace\n        end\n\n        client.close unless env['detach']\n      end\n\n      @events.fire :state, :running\n\n      if background\n        @thread = Thread.new do\n          Puma.set_thread_name \"server\"\n          handle_servers_lopez_mode\n        end\n        return @thread\n      else\n        handle_servers_lopez_mode\n      end\n    end\n\n    def handle_servers_lopez_mode\n      begin\n        check = @check\n        sockets = [check] + @binder.ios\n        pool = @thread_pool\n\n        while @status == :run\n          begin\n            ios = IO.select sockets\n            ios.first.each do |sock|\n              if sock == check\n                break if handle_check\n              else\n                begin\n                  if io = sock.accept_nonblock\n                    client = Client.new io, nil\n                    pool << client\n                  end\n                rescue SystemCallError\n                  # nothing\n                rescue Errno::ECONNABORTED\n                  # client closed the socket even before accept\n                  begin\n                    io.close\n                  rescue\n                    Thread.current.purge_interrupt_queue if Thread.current.respond_to? :purge_interrupt_queue\n                  end\n                end\n              end\n            end\n          rescue Object => e\n            @events.unknown_error self, e, \"Listen loop\"\n          end\n        end\n\n        @events.fire :state, @status\n\n        graceful_shutdown if @status == :stop || @status == :restart\n\n      rescue Exception => e\n        STDERR.puts \"Exception handling servers: #{e.message} (#{e.class})\"\n        STDERR.puts e.backtrace\n      ensure\n        begin\n          @check.close\n        rescue\n          Thread.current.purge_interrupt_queue if Thread.current.respond_to? :purge_interrupt_queue\n        end\n\n        # Prevent can't modify frozen IOError (RuntimeError)\n        begin\n          @notify.close\n        rescue IOError\n          # no biggy\n        end\n      end\n\n      @events.fire :state, :done\n    end\n    # Runs the server.\n    #\n    # If +background+ is true (the default) then a thread is spun\n    # up in the background to handle requests. Otherwise requests\n    # are handled synchronously.\n    #\n    def run(background=true)\n      BasicSocket.do_not_reverse_lookup = true\n\n      @events.fire :state, :booting\n\n      @status = :run\n\n      if @mode == :tcp\n        return run_lopez_mode(background)\n      end\n\n      queue_requests = @queue_requests\n\n      @thread_pool = ThreadPool.new(@min_threads,\n                                    @max_threads,\n                                    ::Puma::IOBuffer) do |client, buffer|\n\n        # Advertise this server into the thread\n        Thread.current[ThreadLocalKey] = self\n\n        process_now = false\n\n        begin\n          if queue_requests\n            process_now = client.eagerly_finish\n          else\n            client.finish(@first_data_timeout)\n            process_now = true\n          end\n        rescue MiniSSL::SSLError => e\n          ssl_socket = client.io\n          addr = ssl_socket.peeraddr.last\n          cert = ssl_socket.peercert\n\n          client.close\n\n          @events.ssl_error self, addr, cert, e\n        rescue HttpParserError => e\n          client.write_error(400)\n          client.close\n\n          @events.parse_error self, client.env, e\n        rescue ConnectionError, EOFError\n          client.close\n        else\n          if process_now\n            process_client client, buffer\n          else\n            client.set_timeout @first_data_timeout\n            @reactor.add client\n          end\n        end\n      end\n\n      @thread_pool.clean_thread_locals = @options[:clean_thread_locals]\n\n      if queue_requests\n        @reactor = Reactor.new self, @thread_pool\n        @reactor.run_in_thread\n      end\n\n      if @reaping_time\n        @thread_pool.auto_reap!(@reaping_time)\n      end\n\n      if @auto_trim_time\n        @thread_pool.auto_trim!(@auto_trim_time)\n      end\n\n      @events.fire :state, :running\n\n      if background\n        @thread = Thread.new do\n          Puma.set_thread_name \"server\"\n          handle_servers\n        end\n        return @thread\n      else\n        handle_servers\n      end\n    end\n\n    def handle_servers\n      begin\n        check = @check\n        sockets = [check] + @binder.ios\n        pool = @thread_pool\n        queue_requests = @queue_requests\n\n        remote_addr_value = nil\n        remote_addr_header = nil\n\n        case @options[:remote_address]\n        when :value\n          remote_addr_value = @options[:remote_address_value]\n        when :header\n          remote_addr_header = @options[:remote_address_header]\n        end\n\n        while @status == :run\n          begin\n            ios = IO.select sockets\n            ios.first.each do |sock|\n              if sock == check\n                break if handle_check\n              else\n                begin\n                  if io = sock.accept_nonblock\n                    client = Client.new io, @binder.env(sock)\n                    if remote_addr_value\n                      client.peerip = remote_addr_value\n                    elsif remote_addr_header\n                      client.remote_addr_header = remote_addr_header\n                    end\n\n                    pool << client\n                    busy_threads = pool.wait_until_not_full\n                    if busy_threads == 0\n                      @options[:out_of_band].each(&:call) if @options[:out_of_band]\n                    end\n                  end\n                rescue SystemCallError\n                  # nothing\n                rescue Errno::ECONNABORTED\n                  # client closed the socket even before accept\n                  begin\n                    io.close\n                  rescue\n                    Thread.current.purge_interrupt_queue if Thread.current.respond_to? :purge_interrupt_queue\n                  end\n                end\n              end\n            end\n          rescue Object => e\n            @events.unknown_error self, e, \"Listen loop\"\n          end\n        end\n\n        @events.fire :state, @status\n\n        graceful_shutdown if @status == :stop || @status == :restart\n        if queue_requests\n          @reactor.clear!\n          @reactor.shutdown\n        end\n      rescue Exception => e\n        STDERR.puts \"Exception handling servers: #{e.message} (#{e.class})\"\n        STDERR.puts e.backtrace\n      ensure\n        @check.close\n        @notify.close\n      end\n\n      @events.fire :state, :done\n    end\n\n    # :nodoc:\n    def handle_check\n      cmd = @check.read(1)\n\n      case cmd\n      when STOP_COMMAND\n        @status = :stop\n        return true\n      when HALT_COMMAND\n        @status = :halt\n        return true\n      when RESTART_COMMAND\n        @status = :restart\n        return true\n      end\n\n      return false\n    end\n\n    # Given a connection on +client+, handle the incoming requests.\n    #\n    # This method support HTTP Keep-Alive so it may, depending on if the client\n    # indicates that it supports keep alive, wait for another request before\n    # returning.\n    #\n    def process_client(client, buffer)\n      begin\n\n        clean_thread_locals = @options[:clean_thread_locals]\n        close_socket = true\n\n        requests = 0\n\n        while true\n          case handle_request(client, buffer)\n          when false\n            return\n          when :async\n            close_socket = false\n            return\n          when true\n            return unless @queue_requests\n            buffer.reset\n\n            ThreadPool.clean_thread_locals if clean_thread_locals\n\n            requests += 1\n\n            check_for_more_data = @status == :run\n\n            if requests >= MAX_FAST_INLINE\n              # This will mean that reset will only try to use the data it already\n              # has buffered and won't try to read more data. What this means is that\n              # every client, independent of their request speed, gets treated like a slow\n              # one once every MAX_FAST_INLINE requests.\n              check_for_more_data = false\n            end\n\n            unless client.reset(check_for_more_data)\n              close_socket = false\n              client.set_timeout @persistent_timeout\n              @reactor.add client\n              return\n            end\n          end\n        end\n\n      # The client disconnected while we were reading data\n      rescue ConnectionError\n        # Swallow them. The ensure tries to close +client+ down\n\n      # SSL handshake error\n      rescue MiniSSL::SSLError => e\n        lowlevel_error(e, client.env)\n\n        ssl_socket = client.io\n        addr = ssl_socket.peeraddr.last\n        cert = ssl_socket.peercert\n\n        close_socket = true\n\n        @events.ssl_error self, addr, cert, e\n\n      # The client doesn't know HTTP well\n      rescue HttpParserError => e\n        lowlevel_error(e, client.env)\n\n        client.write_error(400)\n\n        @events.parse_error self, client.env, e\n\n      # Server error\n      rescue StandardError => e\n        lowlevel_error(e, client.env)\n\n        client.write_error(500)\n\n        @events.unknown_error self, e, \"Read\"\n\n      ensure\n        buffer.reset\n\n        begin\n          client.close if close_socket\n        rescue IOError, SystemCallError\n          Thread.current.purge_interrupt_queue if Thread.current.respond_to? :purge_interrupt_queue\n          # Already closed\n        rescue StandardError => e\n          @events.unknown_error self, e, \"Client\"\n        end\n      end\n    end\n\n    # Given a Hash +env+ for the request read from +client+, add\n    # and fixup keys to comply with Rack's env guidelines.\n    #\n    def normalize_env(env, client)\n      if host = env[HTTP_HOST]\n        if colon = host.index(\":\")\n          env[SERVER_NAME] = host[0, colon]\n          env[SERVER_PORT] = host[colon+1, host.bytesize]\n        else\n          env[SERVER_NAME] = host\n          env[SERVER_PORT] = default_server_port(env)\n        end\n      else\n        env[SERVER_NAME] = LOCALHOST\n        env[SERVER_PORT] = default_server_port(env)\n      end\n\n      unless env[REQUEST_PATH]\n        # it might be a dumbass full host request header\n        uri = URI.parse(env[REQUEST_URI])\n        env[REQUEST_PATH] = uri.path\n\n        raise \"No REQUEST PATH\" unless env[REQUEST_PATH]\n\n        # A nil env value will cause a LintError (and fatal errors elsewhere),\n        # so only set the env value if there actually is a value.\n        env[QUERY_STRING] = uri.query if uri.query\n      end\n\n      env[PATH_INFO] = env[REQUEST_PATH]\n\n      # From http://www.ietf.org/rfc/rfc3875 :\n      # \"Script authors should be aware that the REMOTE_ADDR and\n      # REMOTE_HOST meta-variables (see sections 4.1.8 and 4.1.9)\n      # may not identify the ultimate source of the request.\n      # They identify the client for the immediate request to the\n      # server; that client may be a proxy, gateway, or other\n      # intermediary acting on behalf of the actual source client.\"\n      #\n\n      unless env.key?(REMOTE_ADDR)\n        begin\n          addr = client.peerip\n        rescue Errno::ENOTCONN\n          # Client disconnects can result in an inability to get the\n          # peeraddr from the socket; default to localhost.\n          addr = LOCALHOST_IP\n        end\n\n        # Set unix socket addrs to localhost\n        addr = LOCALHOST_IP if addr.empty?\n\n        env[REMOTE_ADDR] = addr\n      end\n    end\n\n    def default_server_port(env)\n      if ['on', HTTPS].include?(env[HTTPS_KEY]) || env[HTTP_X_FORWARDED_PROTO].to_s[0...5] == HTTPS || env[HTTP_X_FORWARDED_SCHEME] == HTTPS || env[HTTP_X_FORWARDED_SSL] == \"on\"\n        PORT_443\n      else\n        PORT_80\n      end\n    end\n\n    # Takes the request +req+, invokes the Rack application to construct\n    # the response and writes it back to +req.io+.\n    #\n    # The second parameter +lines+ is a IO-like object unique to this thread.\n    # This is normally an instance of Puma::IOBuffer.\n    #\n    # It'll return +false+ when the connection is closed, this doesn't mean\n    # that the response wasn't successful.\n    #\n    # It'll return +:async+ if the connection remains open but will be handled\n    # elsewhere, i.e. the connection has been hijacked by the Rack application.\n    #\n    # Finally, it'll return +true+ on keep-alive connections.\n    def handle_request(req, lines)\n      @requests_count +=1\n\n      env = req.env\n      client = req.io\n\n      return false if closed_socket?(client)\n\n      normalize_env env, req\n\n      env[PUMA_SOCKET] = client\n\n      if env[HTTPS_KEY] && client.peercert\n        env[PUMA_PEERCERT] = client.peercert\n      end\n\n      env[HIJACK_P] = true\n      env[HIJACK] = req\n\n      body = req.body\n\n      head = env[REQUEST_METHOD] == HEAD\n\n      env[RACK_INPUT] = body\n      env[RACK_URL_SCHEME] = default_server_port(env) == PORT_443 ? HTTPS : HTTP\n\n      if @early_hints\n        env[EARLY_HINTS] = lambda { |headers|\n          begin\n            fast_write client, \"HTTP/1.1 103 Early Hints\\r\\n\".freeze\n\n            headers.each_pair do |k, vs|\n              if vs.respond_to?(:to_s) && !vs.to_s.empty?\n                vs.to_s.split(NEWLINE).each do |v|\n                  fast_write client, \"#{k}: #{v}\\r\\n\"\n                end\n              else\n                fast_write client, \"#{k}: #{vs}\\r\\n\"\n              end\n            end\n\n            fast_write client, \"\\r\\n\".freeze\n          rescue ConnectionError\n            # noop, if we lost the socket we just won't send the early hints\n          end\n        }\n      end\n\n      # A rack extension. If the app writes #call'ables to this\n      # array, we will invoke them when the request is done.\n      #\n      after_reply = env[RACK_AFTER_REPLY] = []\n\n      begin\n        begin\n          status, headers, res_body = @app.call(env)\n\n          return :async if req.hijacked\n          # Checking to see if an attacker is trying to inject headers into the response\n          headers.reject! { |_k, v| CRLF_REGEX =~ v.to_s }\n\n          status = status.to_i\n\n          if status == -1\n            unless headers.empty? and res_body == []\n              raise \"async response must have empty headers and body\"\n            end\n\n            return :async\n          end\n        rescue ThreadPool::ForceShutdown => e\n          @events.log \"Detected force shutdown of a thread, returning 503\"\n          @events.unknown_error self, e, \"Rack app\"\n\n          status = 503\n          headers = {}\n          res_body = [\"Request was internally terminated early\\n\"]\n\n        rescue Exception => e\n          @events.unknown_error self, e, \"Rack app\", env\n\n          status, headers, res_body = lowlevel_error(e, env)\n        end\n\n        content_length = nil\n        no_body = head\n\n        if res_body.kind_of? Array and res_body.size == 1\n          content_length = res_body[0].bytesize\n        end\n\n        cork_socket client\n\n        line_ending = LINE_END\n        colon = COLON\n\n        http_11 = if env[HTTP_VERSION] == HTTP_11\n          allow_chunked = true\n          keep_alive = env.fetch(HTTP_CONNECTION, \"\").downcase != CLOSE\n          include_keepalive_header = false\n\n          # An optimization. The most common response is 200, so we can\n          # reply with the proper 200 status without having to compute\n          # the response header.\n          #\n          if status == 200\n            lines << HTTP_11_200\n          else\n            lines.append \"HTTP/1.1 \", status.to_s, \" \",\n                         fetch_status_code(status), line_ending\n\n            no_body ||= status < 200 || STATUS_WITH_NO_ENTITY_BODY[status]\n          end\n          true\n        else\n          allow_chunked = false\n          keep_alive = env.fetch(HTTP_CONNECTION, \"\").downcase == KEEP_ALIVE\n          include_keepalive_header = keep_alive\n\n          # Same optimization as above for HTTP/1.1\n          #\n          if status == 200\n            lines << HTTP_10_200\n          else\n            lines.append \"HTTP/1.0 \", status.to_s, \" \",\n                         fetch_status_code(status), line_ending\n\n            no_body ||= status < 200 || STATUS_WITH_NO_ENTITY_BODY[status]\n          end\n          false\n        end\n\n        response_hijack = nil\n\n        headers.each do |k, vs|\n          case k.downcase\n          when CONTENT_LENGTH2\n            content_length = vs\n            next\n          when TRANSFER_ENCODING\n            allow_chunked = false\n            content_length = nil\n          when HIJACK\n            response_hijack = vs\n            next\n          end\n\n          if vs.respond_to?(:to_s) && !vs.to_s.empty?\n            vs.to_s.split(NEWLINE).each do |v|\n              lines.append k, colon, v, line_ending\n            end\n          else\n            lines.append k, colon, line_ending\n          end\n        end\n\n        if include_keepalive_header\n          lines << CONNECTION_KEEP_ALIVE\n        elsif http_11 && !keep_alive\n          lines << CONNECTION_CLOSE\n        end\n\n        if no_body\n          if content_length and status != 204\n            lines.append CONTENT_LENGTH_S, content_length.to_s, line_ending\n          end\n\n          lines << line_ending\n          fast_write client, lines.to_s\n          return keep_alive\n        end\n\n        if content_length\n          lines.append CONTENT_LENGTH_S, content_length.to_s, line_ending\n          chunked = false\n        elsif !response_hijack and allow_chunked\n          lines << TRANSFER_ENCODING_CHUNKED\n          chunked = true\n        end\n\n        lines << line_ending\n\n        fast_write client, lines.to_s\n\n        if response_hijack\n          response_hijack.call client\n          return :async\n        end\n\n        begin\n          res_body.each do |part|\n            next if part.bytesize.zero?\n            if chunked\n              fast_write client, part.bytesize.to_s(16)\n              fast_write client, line_ending\n              fast_write client, part\n              fast_write client, line_ending\n            else\n              fast_write client, part\n            end\n\n            client.flush\n          end\n\n          if chunked\n            fast_write client, CLOSE_CHUNKED\n            client.flush\n          end\n        rescue SystemCallError, IOError\n          raise ConnectionError, \"Connection error detected during write\"\n        end\n\n      ensure\n        uncork_socket client\n\n        body.close\n        req.tempfile.unlink if req.tempfile\n        res_body.close if res_body.respond_to? :close\n\n        after_reply.each { |o| o.call }\n      end\n\n      return keep_alive\n    end\n\n    def fetch_status_code(status)\n      HTTP_STATUS_CODES.fetch(status) { 'CUSTOM' }\n    end\n    private :fetch_status_code\n\n    # Given the request +env+ from +client+ and the partial body +body+\n    # plus a potential Content-Length value +cl+, finish reading\n    # the body and return it.\n    #\n    # If the body is larger than MAX_BODY, a Tempfile object is used\n    # for the body, otherwise a StringIO is used.\n    #\n    def read_body(env, client, body, cl)\n      content_length = cl.to_i\n\n      remain = content_length - body.bytesize\n\n      return StringIO.new(body) if remain <= 0\n\n      # Use a Tempfile if there is a lot of data left\n      if remain > MAX_BODY\n        stream = Tempfile.new(Const::PUMA_TMP_BASE)\n        stream.binmode\n      else\n        # The body[0,0] trick is to get an empty string in the same\n        # encoding as body.\n        stream = StringIO.new body[0,0]\n      end\n\n      stream.write body\n\n      # Read an odd sized chunk so we can read even sized ones\n      # after this\n      chunk = client.readpartial(remain % CHUNK_SIZE)\n\n      # No chunk means a closed socket\n      unless chunk\n        stream.close\n        return nil\n      end\n\n      remain -= stream.write(chunk)\n\n      # Raed the rest of the chunks\n      while remain > 0\n        chunk = client.readpartial(CHUNK_SIZE)\n        unless chunk\n          stream.close\n          return nil\n        end\n\n        remain -= stream.write(chunk)\n      end\n\n      stream.rewind\n\n      return stream\n    end\n\n    # A fallback rack response if +@app+ raises as exception.\n    #\n    def lowlevel_error(e, env)\n      if handler = @options[:lowlevel_error_handler]\n        if handler.arity == 1\n          return handler.call(e)\n        else\n          return handler.call(e, env)\n        end\n      end\n\n      if @leak_stack_on_error\n        [500, {}, [\"Puma caught this error: #{e.message} (#{e.class})\\n#{e.backtrace.join(\"\\n\")}\"]]\n      else\n        [500, {}, [\"An unhandled lowlevel error occurred. The application logs may have details.\\n\"]]\n      end\n    end\n\n    # Wait for all outstanding requests to finish.\n    #\n    def graceful_shutdown\n      if @options[:shutdown_debug]\n        threads = Thread.list\n        total = threads.size\n\n        pid = Process.pid\n\n        $stdout.syswrite \"#{pid}: === Begin thread backtrace dump ===\\n\"\n\n        threads.each_with_index do |t,i|\n          $stdout.syswrite \"#{pid}: Thread #{i+1}/#{total}: #{t.inspect}\\n\"\n          $stdout.syswrite \"#{pid}: #{t.backtrace.join(\"\\n#{pid}: \")}\\n\\n\"\n        end\n        $stdout.syswrite \"#{pid}: === End thread backtrace dump ===\\n\"\n      end\n\n      if @options[:drain_on_shutdown]\n        count = 0\n\n        while true\n          ios = IO.select @binder.ios, nil, nil, 0\n          break unless ios\n\n          ios.first.each do |sock|\n            begin\n              if io = sock.accept_nonblock\n                count += 1\n                client = Client.new io, @binder.env(sock)\n                @thread_pool << client\n              end\n            rescue SystemCallError\n            end\n          end\n        end\n\n        @events.debug \"Drained #{count} additional connections.\"\n      end\n\n      if @status != :restart\n        @binder.close\n      end\n\n      if @thread_pool\n        if timeout = @options[:force_shutdown_after]\n          @thread_pool.shutdown timeout.to_i\n        else\n          @thread_pool.shutdown\n        end\n      end\n    end\n\n    def notify_safely(message)\n      begin\n        @notify << message\n      rescue IOError\n         # The server, in another thread, is shutting down\n        Thread.current.purge_interrupt_queue if Thread.current.respond_to? :purge_interrupt_queue\n      rescue RuntimeError => e\n        # Temporary workaround for https://bugs.ruby-lang.org/issues/13239\n        if e.message.include?('IOError')\n          Thread.current.purge_interrupt_queue if Thread.current.respond_to? :purge_interrupt_queue\n        else\n          raise e\n        end\n      end\n    end\n    private :notify_safely\n\n    # Stops the acceptor thread and then causes the worker threads to finish\n    # off the request queue before finally exiting.\n\n    def stop(sync=false)\n      notify_safely(STOP_COMMAND)\n      @thread.join if @thread && sync\n    end\n\n    def halt(sync=false)\n      notify_safely(HALT_COMMAND)\n      @thread.join if @thread && sync\n    end\n\n    def begin_restart\n      notify_safely(RESTART_COMMAND)\n    end\n\n    def fast_write(io, str)\n      n = 0\n      while true\n        begin\n          n = io.syswrite str\n        rescue Errno::EAGAIN, Errno::EWOULDBLOCK\n          if !IO.select(nil, [io], nil, WRITE_TIMEOUT)\n            raise ConnectionError, \"Socket timeout writing data\"\n          end\n\n          retry\n        rescue  Errno::EPIPE, SystemCallError, IOError\n          raise ConnectionError, \"Socket timeout writing data\"\n        end\n\n        return if n == str.bytesize\n        str = str.byteslice(n..-1)\n      end\n    end\n    private :fast_write\n\n    ThreadLocalKey = :puma_server\n\n    def self.current\n      Thread.current[ThreadLocalKey]\n    end\n\n    def shutting_down?\n      @status == :stop || @status == :restart\n    end\n  end\nend\n", "require_relative \"helper\"\n\nclass TestPumaServer < Minitest::Test\n  parallelize_me!\n\n  def setup\n    @port = 0\n    @host = \"127.0.0.1\"\n\n    @ios = []\n\n    @app = ->(env) { [200, {}, [env['rack.url_scheme']]] }\n\n    @events = Puma::Events.strings\n    @server = Puma::Server.new @app, @events\n  end\n\n  def teardown\n    @server.stop(true)\n    @ios.each { |io| io.close if io && !io.closed? }\n  end\n\n  def server_run(app: @app, early_hints: false)\n    @server.app = app\n    @server.add_tcp_listener @host, @port\n    @server.early_hints = true if early_hints\n    @server.run\n  end\n\n  def header(sock)\n    header = []\n    while true\n      line = sock.gets\n      break if line == \"\\r\\n\"\n      header << line.strip\n    end\n\n    header\n  end\n\n  def send_http_and_read(req)\n    port = @server.connected_ports[0]\n    sock = TCPSocket.new @host, port\n    @ios << sock\n    sock << req\n    sock.read\n  end\n\n  def send_http(req)\n    port = @server.connected_ports[0]\n    sock = TCPSocket.new @host, port\n    @ios << sock\n    sock << req\n    sock\n  end\n\n  def test_proper_stringio_body\n    data = nil\n\n    server_run app: ->(env) do\n      data = env['rack.input'].read\n      [200, {}, [\"ok\"]]\n    end\n\n    fifteen = \"1\" * 15\n\n    sock = send_http \"PUT / HTTP/1.0\\r\\nContent-Length: 30\\r\\n\\r\\n#{fifteen}\"\n\n    sleep 0.1 # important so that the previous data is sent as a packet\n    sock << fifteen\n\n    sock.read\n\n    assert_equal \"#{fifteen}#{fifteen}\", data\n  end\n\n  def test_puma_socket\n    body = \"HTTP/1.1 750 Upgraded to Awesome\\r\\nDone: Yep!\\r\\n\"\n    server_run app: ->(env) do\n      io = env['puma.socket']\n      io.write body\n      io.close\n      [-1, {}, []]\n    end\n\n    data = send_http_and_read \"PUT / HTTP/1.0\\r\\n\\r\\nHello\"\n\n    assert_equal body, data\n  end\n\n  def test_very_large_return\n    giant = \"x\" * 2056610\n\n    server_run app: ->(env) do\n      [200, {}, [giant]]\n    end\n\n    sock = send_http \"GET / HTTP/1.0\\r\\n\\r\\n\"\n\n    while true\n      line = sock.gets\n      break if line == \"\\r\\n\"\n    end\n\n    out = sock.read\n\n    assert_equal giant.bytesize, out.bytesize\n  end\n\n  def test_respect_x_forwarded_proto\n    env = {}\n    env['HOST'] = \"example.com\"\n    env['HTTP_X_FORWARDED_PROTO'] = \"https,http\"\n\n    assert_equal \"443\", @server.default_server_port(env)\n  end\n\n  def test_respect_x_forwarded_ssl_on\n    env = {}\n    env['HOST'] = 'example.com'\n    env['HTTP_X_FORWARDED_SSL'] = 'on'\n\n    assert_equal \"443\", @server.default_server_port(env)\n  end\n\n  def test_respect_x_forwarded_scheme\n    env = {}\n    env['HOST'] = 'example.com'\n    env['HTTP_X_FORWARDED_SCHEME'] = 'https'\n\n    assert_equal '443', @server.default_server_port(env)\n  end\n\n  def test_default_server_port\n    server_run app: ->(env) do\n      [200, {}, [env['SERVER_PORT']]]\n    end\n\n    req = Net::HTTP::Get.new '/'\n    req['HOST'] = 'example.com'\n\n    port = @server.connected_ports[0]\n    res = Net::HTTP.start @host, port do |http|\n      http.request(req)\n    end\n\n    assert_equal \"80\", res.body\n  end\n\n  def test_default_server_port_respects_x_forwarded_proto\n    server_run app: ->(env) do\n      [200, {}, [env['SERVER_PORT']]]\n    end\n\n    req = Net::HTTP::Get.new(\"/\")\n    req['HOST'] = \"example.com\"\n    req['X_FORWARDED_PROTO'] = \"https,http\"\n\n    port = @server.connected_ports[0]\n    res = Net::HTTP.start @host, port do |http|\n      http.request(req)\n    end\n\n    assert_equal \"443\", res.body\n  end\n\n  def test_HEAD_has_no_body\n    server_run app: ->(env) { [200, {\"Foo\" => \"Bar\"}, [\"hello\"]] }\n\n    data = send_http_and_read \"HEAD / HTTP/1.0\\r\\n\\r\\n\"\n\n    assert_equal \"HTTP/1.0 200 OK\\r\\nFoo: Bar\\r\\nContent-Length: 5\\r\\n\\r\\n\", data\n  end\n\n  def test_GET_with_empty_body_has_sane_chunking\n    server_run app: ->(env) { [200, {}, [\"\"]] }\n\n    data = send_http_and_read \"HEAD / HTTP/1.0\\r\\n\\r\\n\"\n\n    assert_equal \"HTTP/1.0 200 OK\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n  end\n\n  def test_early_hints_works\n    server_run early_hints: true, app: ->(env) do\n     env['rack.early_hints'].call(\"Link\" => \"</style.css>; rel=preload; as=style\\n</script.js>; rel=preload\")\n     [200, { \"X-Hello\" => \"World\" }, [\"Hello world!\"]]\n    end\n\n    data = send_http_and_read \"HEAD / HTTP/1.0\\r\\n\\r\\n\"\n\n    expected_data = (<<EOF\nHTTP/1.1 103 Early Hints\nLink: </style.css>; rel=preload; as=style\nLink: </script.js>; rel=preload\n\nHTTP/1.0 200 OK\nX-Hello: World\nContent-Length: 12\nEOF\n).split(\"\\n\").join(\"\\r\\n\") + \"\\r\\n\\r\\n\"\n\n    assert_equal true, @server.early_hints\n    assert_equal expected_data, data\n  end\n\n  def test_early_hints_are_ignored_if_connection_lost\n\n    def @server.fast_write(*args)\n      raise Puma::ConnectionError\n    end\n\n    server_run early_hints: true, app: ->(env) do\n      env['rack.early_hints'].call(\"Link\" => \"</script.js>; rel=preload\")\n      [200, { \"X-Hello\" => \"World\" }, [\"Hello world!\"]]\n    end\n\n    # This request will cause the server to try and send early hints\n    _ = send_http \"HEAD / HTTP/1.0\\r\\n\\r\\n\"\n\n    # Give the server some time to try to write (and fail)\n    sleep 0.1\n\n    # Expect no errors in stderr\n    assert @events.stderr.pos.zero?, \"Server didn't swallow the connection error\"\n  end\n\n  def test_early_hints_is_off_by_default\n    server_run app: ->(env) do\n     assert_nil env['rack.early_hints']\n     [200, { \"X-Hello\" => \"World\" }, [\"Hello world!\"]]\n    end\n\n    data = send_http_and_read \"HEAD / HTTP/1.0\\r\\n\\r\\n\"\n\n    expected_data = (<<EOF\nHTTP/1.0 200 OK\nX-Hello: World\nContent-Length: 12\nEOF\n).split(\"\\n\").join(\"\\r\\n\") + \"\\r\\n\\r\\n\"\n\n    assert_nil @server.early_hints\n    assert_equal expected_data, data\n  end\n\n  def test_GET_with_no_body_has_sane_chunking\n    server_run app: ->(env) { [200, {}, []] }\n\n    data = send_http_and_read \"HEAD / HTTP/1.0\\r\\n\\r\\n\"\n\n    assert_equal \"HTTP/1.0 200 OK\\r\\n\\r\\n\", data\n  end\n\n  def test_doesnt_print_backtrace_in_production\n    @server.leak_stack_on_error = false\n    server_run app: ->(env) { raise \"don't leak me bro\" }\n\n    data = send_http_and_read \"GET / HTTP/1.0\\r\\n\\r\\n\"\n\n    refute_match(/don't leak me bro/, data)\n    assert_match(/HTTP\\/1.0 500 Internal Server Error/, data)\n  end\n\n  def test_prints_custom_error\n    re = lambda { |err| [302, {'Content-Type' => 'text', 'Location' => 'foo.html'}, ['302 found']] }\n    @server = Puma::Server.new @app, @events, {:lowlevel_error_handler => re}\n\n    server_run app: ->(env) { raise \"don't leak me bro\" }\n\n    data = send_http_and_read \"GET / HTTP/1.0\\r\\n\\r\\n\"\n\n    assert_match(/HTTP\\/1.0 302 Found/, data)\n  end\n\n  def test_leh_gets_env_as_well\n    re = lambda { |err,env|\n      env['REQUEST_PATH'] || raise('where is env?')\n      [302, {'Content-Type' => 'text', 'Location' => 'foo.html'}, ['302 found']]\n    }\n\n    @server = Puma::Server.new @app, @events, {:lowlevel_error_handler => re}\n\n    server_run app: ->(env) { raise \"don't leak me bro\" }\n\n    data = send_http_and_read \"GET / HTTP/1.0\\r\\n\\r\\n\"\n\n    assert_match(/HTTP\\/1.0 302 Found/, data)\n  end\n\n  def test_custom_http_codes_10\n    server_run app: ->(env) { [449, {}, [\"\"]] }\n\n    data = send_http_and_read \"GET / HTTP/1.0\\r\\n\\r\\n\"\n\n    assert_equal \"HTTP/1.0 449 CUSTOM\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n  end\n\n  def test_custom_http_codes_11\n    server_run app: ->(env) { [449, {}, [\"\"]] }\n\n    data = send_http_and_read \"GET / HTTP/1.1\\r\\nConnection: close\\r\\n\\r\\n\"\n\n    assert_equal \"HTTP/1.1 449 CUSTOM\\r\\nConnection: close\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n  end\n\n  def test_HEAD_returns_content_headers\n    server_run app: ->(env) { [200, {\"Content-Type\" => \"application/pdf\",\n                                     \"Content-Length\" => \"4242\"}, []] }\n\n    data = send_http_and_read \"HEAD / HTTP/1.0\\r\\n\\r\\n\"\n\n    assert_equal \"HTTP/1.0 200 OK\\r\\nContent-Type: application/pdf\\r\\nContent-Length: 4242\\r\\n\\r\\n\", data\n  end\n\n  def test_status_hook_fires_when_server_changes_states\n\n    states = []\n\n    @events.register(:state) { |s| states << s }\n\n    server_run app: ->(env) { [200, {}, [\"\"]] }\n\n    _ = send_http_and_read \"HEAD / HTTP/1.0\\r\\n\\r\\n\"\n\n    assert_equal [:booting, :running], states\n\n    @server.stop(true)\n\n    assert_equal [:booting, :running, :stop, :done], states\n  end\n\n  def test_timeout_in_data_phase\n    @server.first_data_timeout = 2\n    server_run\n\n    sock = send_http \"POST / HTTP/1.1\\r\\nHost: test.com\\r\\nContent-Type: text/plain\\r\\nContent-Length: 5\\r\\n\\r\\n\"\n\n    data = sock.gets\n\n    assert_equal \"HTTP/1.1 408 Request Timeout\\r\\n\", data\n  end\n\n  def test_timeout_data_no_queue\n    @server = Puma::Server.new @app, @events, queue_requests: false\n    test_timeout_in_data_phase\n  end\n\n  def test_http_11_keep_alive_with_body\n    server_run app: ->(env) { [200, {\"Content-Type\" => \"plain/text\"}, [\"hello\\n\"]] }\n\n    sock = send_http \"GET / HTTP/1.1\\r\\nConnection: Keep-Alive\\r\\n\\r\\n\"\n\n    h = header sock\n\n    body = sock.gets\n\n    assert_equal [\"HTTP/1.1 200 OK\", \"Content-Type: plain/text\", \"Content-Length: 6\"], h\n    assert_equal \"hello\\n\", body\n\n    sock.close\n  end\n\n  def test_http_11_close_with_body\n    server_run app: ->(env) { [200, {\"Content-Type\" => \"plain/text\"}, [\"hello\"]] }\n\n    data = send_http_and_read \"GET / HTTP/1.1\\r\\nConnection: close\\r\\n\\r\\n\"\n\n    assert_equal \"HTTP/1.1 200 OK\\r\\nContent-Type: plain/text\\r\\nConnection: close\\r\\nContent-Length: 5\\r\\n\\r\\nhello\", data\n  end\n\n  def test_http_11_keep_alive_without_body\n    server_run app: ->(env) { [204, {}, []] }\n\n    sock = send_http \"GET / HTTP/1.1\\r\\nConnection: Keep-Alive\\r\\n\\r\\n\"\n\n    h = header sock\n\n    assert_equal [\"HTTP/1.1 204 No Content\"], h\n  end\n\n  def test_http_11_close_without_body\n    server_run app: ->(env) { [204, {}, []] }\n\n    sock = send_http \"GET / HTTP/1.1\\r\\nConnection: close\\r\\n\\r\\n\"\n\n    h = header sock\n\n    assert_equal [\"HTTP/1.1 204 No Content\", \"Connection: close\"], h\n  end\n\n  def test_http_10_keep_alive_with_body\n    server_run app: ->(env) { [200, {\"Content-Type\" => \"plain/text\"}, [\"hello\\n\"]] }\n\n    sock = send_http \"GET / HTTP/1.0\\r\\nConnection: Keep-Alive\\r\\n\\r\\n\"\n\n    h = header sock\n\n    body = sock.gets\n\n    assert_equal [\"HTTP/1.0 200 OK\", \"Content-Type: plain/text\", \"Connection: Keep-Alive\", \"Content-Length: 6\"], h\n    assert_equal \"hello\\n\", body\n  end\n\n  def test_http_10_close_with_body\n    server_run app: ->(env) { [200, {\"Content-Type\" => \"plain/text\"}, [\"hello\"]] }\n\n    data = send_http_and_read \"GET / HTTP/1.0\\r\\nConnection: close\\r\\n\\r\\n\"\n\n    assert_equal \"HTTP/1.0 200 OK\\r\\nContent-Type: plain/text\\r\\nContent-Length: 5\\r\\n\\r\\nhello\", data\n  end\n\n  def test_http_10_partial_hijack_with_content_length\n    body_parts = ['abc', 'de']\n\n    server_run app: ->(env) do\n      hijack_lambda = proc do | io |\n        io.write(body_parts[0])\n        io.write(body_parts[1])\n        io.close\n      end\n      [200, {\"Content-Length\" => \"5\", 'rack.hijack' => hijack_lambda}, nil]\n    end\n\n    data = send_http_and_read \"GET / HTTP/1.0\\r\\nConnection: close\\r\\n\\r\\n\"\n\n    assert_equal \"HTTP/1.0 200 OK\\r\\nContent-Length: 5\\r\\n\\r\\nabcde\", data\n  end\n\n  def test_http_10_keep_alive_without_body\n    server_run app: ->(env) { [204, {}, []] }\n\n    sock = send_http \"GET / HTTP/1.0\\r\\nConnection: Keep-Alive\\r\\n\\r\\n\"\n\n    h = header sock\n\n    assert_equal [\"HTTP/1.0 204 No Content\", \"Connection: Keep-Alive\"], h\n  end\n\n  def test_http_10_close_without_body\n    server_run app: ->(env) { [204, {}, []] }\n\n    data = send_http_and_read \"GET / HTTP/1.0\\r\\nConnection: close\\r\\n\\r\\n\"\n\n    assert_equal \"HTTP/1.0 204 No Content\\r\\n\\r\\n\", data\n  end\n\n  def test_Expect_100\n    server_run app: ->(env) { [200, {}, [\"\"]] }\n\n    data = send_http_and_read \"GET / HTTP/1.1\\r\\nConnection: close\\r\\nExpect: 100-continue\\r\\n\\r\\n\"\n\n    assert_equal \"HTTP/1.1 100 Continue\\r\\n\\r\\nHTTP/1.1 200 OK\\r\\nConnection: close\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n  end\n\n  def test_chunked_request\n    body = nil\n    server_run app: ->(env) {\n      body = env['rack.input'].read\n      [200, {}, [\"\"]]\n    }\n\n    data = send_http_and_read \"GET / HTTP/1.1\\r\\nConnection: close\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n1\\r\\nh\\r\\n4\\r\\nello\\r\\n0\\r\\n\\r\\n\"\n\n    assert_equal \"HTTP/1.1 200 OK\\r\\nConnection: close\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n    assert_equal \"hello\", body\n  end\n\n  def test_chunked_request_pause_before_value\n    body = nil\n    server_run app: ->(env) {\n      body = env['rack.input'].read\n      [200, {}, [\"\"]]\n    }\n\n    sock = send_http \"GET / HTTP/1.1\\r\\nConnection: close\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n1\\r\\n\"\n    sleep 1\n\n    sock << \"h\\r\\n4\\r\\nello\\r\\n0\\r\\n\\r\\n\"\n\n    data = sock.read\n\n    assert_equal \"HTTP/1.1 200 OK\\r\\nConnection: close\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n    assert_equal \"hello\", body\n  end\n\n  def test_chunked_request_pause_between_chunks\n    body = nil\n    server_run app: ->(env) {\n      body = env['rack.input'].read\n      [200, {}, [\"\"]]\n    }\n\n    sock = send_http \"GET / HTTP/1.1\\r\\nConnection: close\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n1\\r\\nh\\r\\n\"\n    sleep 1\n\n    sock << \"4\\r\\nello\\r\\n0\\r\\n\\r\\n\"\n\n    data = sock.read\n\n    assert_equal \"HTTP/1.1 200 OK\\r\\nConnection: close\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n    assert_equal \"hello\", body\n  end\n\n  def test_chunked_request_pause_mid_count\n    body = nil\n    server_run app: ->(env) {\n      body = env['rack.input'].read\n      [200, {}, [\"\"]]\n    }\n\n    sock = send_http \"GET / HTTP/1.1\\r\\nConnection: close\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n1\\r\"\n    sleep 1\n\n    sock << \"\\nh\\r\\n4\\r\\nello\\r\\n0\\r\\n\\r\\n\"\n\n    data = sock.read\n\n    assert_equal \"HTTP/1.1 200 OK\\r\\nConnection: close\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n    assert_equal \"hello\", body\n  end\n\n  def test_chunked_request_pause_before_count_newline\n    body = nil\n    server_run app: ->(env) {\n      body = env['rack.input'].read\n      [200, {}, [\"\"]]\n    }\n\n    sock = send_http \"GET / HTTP/1.1\\r\\nConnection: close\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n1\"\n    sleep 1\n\n    sock << \"\\r\\nh\\r\\n4\\r\\nello\\r\\n0\\r\\n\\r\\n\"\n\n    data = sock.read\n\n    assert_equal \"HTTP/1.1 200 OK\\r\\nConnection: close\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n    assert_equal \"hello\", body\n  end\n\n  def test_chunked_request_pause_mid_value\n    body = nil\n    server_run app: ->(env) {\n      body = env['rack.input'].read\n      [200, {}, [\"\"]]\n    }\n\n    sock = send_http \"GET / HTTP/1.1\\r\\nConnection: close\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n1\\r\\nh\\r\\n4\\r\\ne\"\n    sleep 1\n\n    sock << \"llo\\r\\n0\\r\\n\\r\\n\"\n\n    data = sock.read\n\n    assert_equal \"HTTP/1.1 200 OK\\r\\nConnection: close\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n    assert_equal \"hello\", body\n  end\n\n  def test_chunked_request_pause_between_cr_lf_after_size_of_second_chunk\n    body = nil\n    server_run app: ->(env)  {\n      body = env['rack.input'].read\n      [200, {}, [\"\"]]\n    }\n\n    part1 = 'a' * 4200\n\n    chunked_body = \"#{part1.size.to_s(16)}\\r\\n#{part1}\\r\\n1\\r\\nb\\r\\n0\\r\\n\\r\\n\"\n\n    sock = send_http \"PUT /path HTTP/1.1\\r\\nConnection: close\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n\"\n\n    sleep 0.1\n\n    sock << chunked_body[0..-10]\n\n    sleep 0.1\n\n    sock << chunked_body[-9..-1]\n\n    data = sock.read\n\n    assert_equal \"HTTP/1.1 200 OK\\r\\nConnection: close\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n    assert_equal (part1 + 'b'), body\n  end\n\n  def test_chunked_request_pause_between_closing_cr_lf\n    body = nil\n    server_run app: ->(env) {\n      body = env['rack.input'].read\n      [200, {}, [\"\"]]\n    }\n\n    sock = send_http \"PUT /path HTTP/1.1\\r\\nConnection: close\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n5\\r\\nhello\\r\"\n\n    sleep 1\n\n    sock << \"\\n0\\r\\n\\r\\n\"\n\n    data = sock.read\n\n    assert_equal \"HTTP/1.1 200 OK\\r\\nConnection: close\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n    assert_equal 'hello', body\n  end\n\n  def test_chunked_request_pause_before_closing_cr_lf\n    body = nil\n    server_run app: ->(env) {\n      body = env['rack.input'].read\n      [200, {}, [\"\"]]\n    }\n\n    sock = send_http \"PUT /path HTTP/1.1\\r\\nConnection: close\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n5\\r\\nhello\"\n\n    sleep 1\n\n    sock << \"\\r\\n0\\r\\n\\r\\n\"\n\n    data = sock.read\n\n    assert_equal \"HTTP/1.1 200 OK\\r\\nConnection: close\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n    assert_equal 'hello', body\n  end\n\n  def test_chunked_request_header_case\n    body = nil\n    server_run app: ->(env) {\n      body = env['rack.input'].read\n      [200, {}, [\"\"]]\n    }\n\n    data = send_http_and_read \"GET / HTTP/1.1\\r\\nConnection: close\\r\\nTransfer-Encoding: Chunked\\r\\n\\r\\n1\\r\\nh\\r\\n4\\r\\nello\\r\\n0\\r\\n\\r\\n\"\n\n    assert_equal \"HTTP/1.1 200 OK\\r\\nConnection: close\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n    assert_equal \"hello\", body\n  end\n\n  def test_chunked_keep_alive\n    body = nil\n    server_run app: ->(env) {\n      body = env['rack.input'].read\n      [200, {}, [\"\"]]\n    }\n\n    sock = send_http \"GET / HTTP/1.1\\r\\nConnection: Keep-Alive\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n1\\r\\nh\\r\\n4\\r\\nello\\r\\n0\\r\\n\\r\\n\"\n\n    h = header sock\n\n    assert_equal [\"HTTP/1.1 200 OK\", \"Content-Length: 0\"], h\n    assert_equal \"hello\", body\n\n    sock.close\n  end\n\n  def test_chunked_keep_alive_two_back_to_back\n    body = nil\n    server_run app: ->(env) {\n      body = env['rack.input'].read\n      [200, {}, [\"\"]]\n    }\n\n    sock = send_http \"GET / HTTP/1.1\\r\\nConnection: Keep-Alive\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n1\\r\\nh\\r\\n4\\r\\nello\\r\\n0\\r\\n\"\n\n    last_crlf_written = false\n    last_crlf_writer = Thread.new do\n      sleep 0.1\n      sock << \"\\r\"\n      sleep 0.1\n      sock << \"\\n\"\n      last_crlf_written = true\n    end\n\n    h = header(sock)\n    assert_equal [\"HTTP/1.1 200 OK\", \"Content-Length: 0\"], h\n    assert_equal \"hello\", body\n    assert_equal true, last_crlf_written\n\n    last_crlf_writer.join\n\n    sock << \"GET / HTTP/1.1\\r\\nConnection: Keep-Alive\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n4\\r\\ngood\\r\\n3\\r\\nbye\\r\\n0\\r\\n\\r\\n\"\n    sleep 0.1\n\n    h = header(sock)\n\n    assert_equal [\"HTTP/1.1 200 OK\", \"Content-Length: 0\"], h\n    assert_equal \"goodbye\", body\n\n    sock.close\n  end\n\n  def test_chunked_keep_alive_two_back_to_back_with_set_remote_address\n    body = nil\n    remote_addr =nil\n    @server = Puma::Server.new @app, @events, { remote_address: :header, remote_address_header: 'HTTP_X_FORWARDED_FOR'}\n    server_run app: ->(env) {\n      body = env['rack.input'].read\n      remote_addr = env['REMOTE_ADDR']\n      [200, {}, [\"\"]]\n    }\n\n    sock = send_http \"GET / HTTP/1.1\\r\\nX-Forwarded-For: 127.0.0.1\\r\\nConnection: Keep-Alive\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n1\\r\\nh\\r\\n4\\r\\nello\\r\\n0\\r\\n\\r\\n\"\n\n    h = header sock\n    assert_equal [\"HTTP/1.1 200 OK\", \"Content-Length: 0\"], h\n    assert_equal \"hello\", body\n    assert_equal \"127.0.0.1\", remote_addr\n\n    sock << \"GET / HTTP/1.1\\r\\nX-Forwarded-For: 127.0.0.2\\r\\nConnection: Keep-Alive\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n4\\r\\ngood\\r\\n3\\r\\nbye\\r\\n0\\r\\n\\r\\n\"\n    sleep 0.1\n\n    h = header(sock)\n\n    assert_equal [\"HTTP/1.1 200 OK\", \"Content-Length: 0\"], h\n    assert_equal \"goodbye\", body\n    assert_equal \"127.0.0.2\", remote_addr\n\n    sock.close\n  end\n\n  def test_empty_header_values\n    server_run app: ->(env) { [200, {\"X-Empty-Header\" => \"\"}, []] }\n\n    data = send_http_and_read \"HEAD / HTTP/1.0\\r\\n\\r\\n\"\n\n    assert_equal \"HTTP/1.0 200 OK\\r\\nX-Empty-Header: \\r\\n\\r\\n\", data\n  end\n\n  def test_request_body_wait\n    request_body_wait = nil\n    server_run app: ->(env) {\n      request_body_wait = env['puma.request_body_wait']\n      [204, {}, []]\n    }\n\n    sock = send_http \"POST / HTTP/1.1\\r\\nHost: test.com\\r\\nContent-Type: text/plain\\r\\nContent-Length: 5\\r\\n\\r\\nh\"\n    sleep 1\n    sock << \"ello\"\n\n    sock.gets\n\n    # Could be 1000 but the tests get flaky. We don't care if it's extremely precise so much as that\n    # it is set to a reasonable number.\n    assert_operator request_body_wait, :>=, 900\n  end\n\n  def test_request_body_wait_chunked\n    request_body_wait = nil\n    server_run app: ->(env) {\n      request_body_wait = env['puma.request_body_wait']\n      [204, {}, []]\n    }\n\n    sock = send_http \"GET / HTTP/1.1\\r\\nConnection: close\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n1\\r\\nh\\r\\n\"\n    sleep 3\n    sock << \"4\\r\\nello\\r\\n0\\r\\n\\r\\n\"\n\n    sock.gets\n\n    # Could be 1000 but the tests get flaky. We don't care if it's extremely precise so much as that\n    # it is set to a reasonable number.\n    assert_operator request_body_wait, :>=, 900\n  end\n\n  def test_open_connection_wait\n    server_run app: ->(_) { [200, {}, [\"Hello\"]] }\n    s = send_http nil\n    sleep 0.1\n    s << \"GET / HTTP/1.0\\r\\n\\r\\n\"\n    assert_equal 'Hello', s.readlines.last\n  end\n\n  def test_open_connection_wait_no_queue\n    @server = Puma::Server.new @app, @events, queue_requests: false\n    test_open_connection_wait\n  end\n\n  # https://github.com/ruby/ruby/commit/d9d4a28f1cdd05a0e8dabb36d747d40bbcc30f16\n  def test_prevent_response_splitting_headers\n    server_run app: ->(_) { [200, {'X-header' => \"malicious\\r\\nCookie: hack\"}, [\"Hello\"]] }\n    data = send_http_and_read \"HEAD / HTTP/1.0\\r\\n\\r\\n\"\n    refute_match 'hack', data\n  end\n\n  def test_prevent_response_splitting_headers_cr\n    server_run app: ->(_) { [200, {'X-header' => \"malicious\\rCookie: hack\"}, [\"Hello\"]] }\n    data = send_http_and_read \"HEAD / HTTP/1.0\\r\\n\\r\\n\"\n    refute_match 'hack', data\n  end\n\n  def test_prevent_response_splitting_headers_lf\n    server_run app: ->(_) { [200, {'X-header' => \"malicious\\nCookie: hack\"}, [\"Hello\"]] }\n    data = send_http_and_read \"HEAD / HTTP/1.0\\r\\n\\r\\n\"\n    refute_match 'hack', data\n  end\nend\n"], "fixing_code": ["## Master\n\n* Features\n  * Add pumactl `thread-backtraces` command to print thread backtraces (#2053)\n  * Configuration: `environment` is read from `RAILS_ENV`, if `RACK_ENV` can't be found (#2022)\n  * Do not set user_config to quiet by default to allow for file config (#2074)\n  * `Puma.stats` now returns a Hash instead of a JSON string (#2086)\n  * `GC.compact` is called before fork if available (#2093)\n  * Add `requests_count` to workers stats. (#2106)\n  * Changed #connected_port to #connected_ports (#2076)\n  * `--control` has been removed. Use `--control-url` (#1487)\n  * `worker_directory` has been removed. Use `directory`\n\n* Bugfixes\n  * Windows update extconf.rb for use with ssp and varied Ruby/MSYS2 combinations (#2069)\n  * Preserve `BUNDLE_GEMFILE` env var when using `prune_bundler` (#1893)\n  * Send 408 request timeout even when queue requests is disabled (#2119)\n  * Rescue IO::WaitReadable instead of EAGAIN for blocking read (#2121)\n\n* Refactor\n  * Remove unused loader argument from Plugin initializer (#2095)\n  * Simplify `Configuration.random_token` and remove insecure fallback (#2102)\n  * Simplify `Runner#start_control` URL parsing (#2111)\n  * Removed the IOBuffer extension and replaced with Ruby (#1980)\n\n\n## 4.3.3 and 3.12.4 / 2020-02-28\n  * Bugfixes\n    * Fix: Fixes a problem where we weren't splitting headers correctly on newlines (#2132)\n  * Security\n    * Fix: Prevent HTTP Response splitting via CR in early hints.\n\n## 4.3.2 and 3.12.3 / 2020-02-27\n\n* Security\n  * Fix: Prevent HTTP Response splitting via CR/LF in header values. CVE-2020-5247.\n\n## 4.3.1 and 3.12.2 / 2019-12-05\n\n* Security\n  * Fix: a poorly-behaved client could use keepalive requests to monopolize Puma's reactor and create a denial of service attack. CVE-2019-16770.\n\n## 4.3.0 / 2019-11-07\n\n* Features\n  * Strip whitespace at end of HTTP headers (#2010)\n  * Optimize HTTP parser for JRuby (#2012)\n  * Add SSL support for the control app and cli (#2046, #2052)\n\n* Bugfixes\n  * Fix Errno::EINVAL when SSL is enabled and browser rejects cert (#1564)\n  * Fix pumactl defaulting puma to development if an environment was not specified (#2035)\n  * Fix closing file stream when reading pid from pidfile (#2048)\n  * Fix a typo in configuration option `--extra_runtime_dependencies` (#2050)\n\n## 4.2.1 / 2019-10-07\n\n* 3 bugfixes\n  * Fix socket activation of systemd (pre-existing) unix binder files (#1842, #1988)\n  * Deal with multiple calls to bind correctly (#1986, #1994, #2006)\n  * Accepts symbols for `verify_mode` (#1222)\n\n## 4.2.0 / 2019-09-23\n\n* 6 features\n  * Pumactl has a new -e environment option and reads `config/puma/<environment>.rb` config files (#1885)\n  * Semicolons are now allowed in URL paths (MRI only), useful for Angular or Redmine (#1934)\n  * Allow extra dependencies to be defined when using prune_bundler (#1105)\n  * Puma now reports the correct port when binding to port 0, also reports other listeners when binding to localhost (#1786)\n  * Sending SIGINFO to any Puma worker now prints currently active threads and their backtraces (#1320)\n  * Puma threads all now have their name set on Ruby 2.3+ (#1968)\n* 4 bugfixes\n  * Fix some misbehavior with phased restart and externally SIGTERMed workers (#1908, #1952)\n  * Fix socket closing on error (#1941)\n  * Removed unnecessary SIGINT trap for JRuby that caused some race conditions (#1961)\n  * Fix socket files being left around after process stopped (#1970)\n* Absolutely thousands of lines of test improvements and fixes thanks to @MSP-Greg\n\n## 4.1.1 / 2019-09-05\n\n* 3 bugfixes\n  * Revert our attempt to not dup STDOUT/STDERR (#1946)\n  * Fix socket close on error (#1941)\n  * Fix workers not shutting down correctly (#1908)\n\n## 4.1.0 / 2019-08-08\n\n* 4 features\n  * Add REQUEST_PATH on parse error message (#1831)\n  * You can now easily add custom log formatters with the `log_formatter` config option (#1816)\n  * Puma.stats now provides process start times (#1844)\n  * Add support for disabling TLSv1.1 (#1836)\n\n* 7 bugfixes\n  * Fix issue where Puma was creating zombie process entries (#1887)\n  * Fix bugs with line-endings and chunked encoding (#1812)\n  * RACK_URL_SCHEME is now set correctly in all conditions (#1491)\n  * We no longer mutate global STDOUT/STDERR, particularly the sync setting (#1837)\n  * SSL read_nonblock no longer blocks (#1857)\n  * Swallow connection errors when sending early hints (#1822)\n  * Backtrace no longer dumped when invalid pumactl commands are run (#1863)\n\n* 5 other\n  * Avoid casting worker_timeout twice (#1838)\n  * Removed a call to private that wasn't doing anything (#1882)\n  * README, Rakefile, docs and test cleanups (#1848, #1847, #1846, #1853, #1859, #1850, #1866, #1870, #1872, #1833, #1888)\n  * Puma.io has proper documentation now (https://puma.io/puma/)\n  * Added the Contributor Covenant CoC\n\n* 1 known issue\n  * Some users are still experiencing issues surrounding socket activation and Unix sockets (#1842)\n\n## 4.0.1 / 2019-07-11\n\n* 2 bugfixes\n  * Fix socket removed after reload - should fix problems with systemd socket activation. (#1829)\n  * Add extconf tests for DTLS_method & TLS_server_method, use in minissl.rb. Should fix \"undefined symbol: DTLS_method\" when compiling against old OpenSSL versions. (#1832)\n* 1 other\n  * Removed unnecessary RUBY_VERSION checks. (#1827)\n\n## 4.0.0 / 2019-06-25\n\n* 9 features\n  * Add support for disabling TLSv1.0 (#1562)\n  * Request body read time metric (#1569)\n  * Add out_of_band hook (#1648)\n  * Re-implement (native) IOBuffer for JRuby (#1691)\n  * Min worker timeout (#1716)\n  * Add option to suppress SignalException on SIGTERM (#1690)\n  * Allow mutual TLS CA to be set using `ssl_bind` DSL (#1689)\n  * Reactor now uses nio4r instead of `select` (#1728)\n  * Add status to pumactl with pidfile (#1824)\n\n* 10 bugfixes\n  * Do not accept new requests on shutdown (#1685, #1808)\n  * Fix 3 corner cases when request body is chunked (#1508)\n  * Change pid existence check's condition branches (#1650)\n  * Don't call .stop on a server that doesn't exist (#1655)\n  * Implemented NID_X9_62_prime256v1 (P-256) curve over P-521 (#1671)\n  * Fix @notify.close can't modify frozen IOError (RuntimeError) (#1583)\n  * Fix Java 8 support (#1773)\n  * Fix error `uninitialized constant Puma::Cluster` (#1731)\n  * Fix `not_token` being able to be set to true (#1803)\n  * Fix \"Hang on SIGTERM with ruby 2.6 in clustered mode\" ([PR #1741], [#1674], [#1720], [#1730], [#1755])\n\n[PR #1741]: https://github.com/puma/puma/pull/1741\n[#1674]: https://github.com/puma/puma/issues/1674\n[#1720]: https://github.com/puma/puma/issues/1720\n[#1730]: https://github.com/puma/puma/issues/1730\n[#1755]: https://github.com/puma/puma/issues/1755\n\n## 3.12.1 / 2019-03-19\n\n* 1 features\n  * Internal strings are frozen (#1649)\n* 3 bugfixes\n  * Fix chunked ending check (#1607)\n  * Rack handler should use provided default host (#1700)\n  * Better support for detecting runtimes that support `fork` (#1630)\n\n## 3.12.0 / 2018-07-13\n\n* 5 features:\n  * You can now specify which SSL ciphers the server should support, default is unchanged (#1478)\n  * The setting for Puma's `max_threads` is now in `Puma.stats` (#1604)\n  * Pool capacity is now in `Puma.stats` (#1579)\n  * Installs restricted to Ruby 2.2+ (#1506)\n  * `--control` is now deprecated in favor of `--control-url` (#1487)\n\n* 2 bugfixes:\n  * Workers will no longer accept more web requests than they have capacity to process. This prevents an issue where one worker would accept lots of requests while starving other workers (#1563)\n  * In a test env puma now emits the stack on an exception (#1557)\n\n## 3.11.4 / 2018-04-12\n\n* 2 features:\n  * Manage puma as a service using rc.d (#1529)\n  * Server stats are now available from a top level method (#1532)\n* 5 bugfixes:\n  * Fix parsing CLI options (#1482)\n  * Order of stderr and stdout is made before redirecting to a log file (#1511)\n  * Init.d fix of `ps -p` to check if pid exists (#1545)\n  * Early hints bugfix (#1550)\n  * Purge interrupt queue when closing socket fails (#1553)\n\n## 3.11.3 / 2018-03-05\n\n* 3 bugfixes:\n  * Add closed? to MiniSSL::Socket for use in reactor (#1510)\n  * Handle EOFError at the toplevel of the server threads (#1524) (#1507)\n  * Deal with zero sized bodies when using SSL (#1483)\n\n## 3.11.2 / 2018-01-19\n\n* 1 bugfix:\n  * Deal with read\\_nonblock returning nil early\n\n## 3.11.1 / 2018-01-18\n\n* 1 bugfix:\n  * Handle read\\_nonblock returning nil when the socket close (#1502)\n\n## 3.11.0 / 2017-11-20\n\n* 2 features:\n  * HTTP 103 Early Hints (#1403)\n  * 421/451 status codes now have correct status messages attached (#1435)\n\n* 9 bugfixes:\n  * Environment config files (/config/puma/<ENV>.rb) load correctly (#1340)\n  * Specify windows dependencies correctly (#1434, #1436)\n  * puma/events required in test helper (#1418)\n  * Correct control CLI's option help text (#1416)\n  * Remove a warning for unused variable in mini_ssl (#1409)\n  * Correct pumactl docs argument ordering (#1427)\n  * Fix an uninitialized variable warning in server.rb (#1430)\n  * Fix docs typo/error in Launcher init (#1429)\n  * Deal with leading spaces in RUBYOPT (#1455)\n\n* 2 other:\n  * Add docs about internals (#1425, #1452)\n  * Tons of test fixes from @MSP-Greg (#1439, #1442, #1464)\n\n## 3.10.0 / 2017-08-17\n\n* 3 features:\n  * The status server has a new /gc and /gc-status command. (#1384)\n  * The persistent and first data timeouts are now configurable (#1111)\n  * Implemented RFC 2324 (#1392)\n\n* 12 bugfixes:\n  * Not really a Puma bug, but @NickolasVashchenko created a gem to workaround a Ruby bug that some users of Puma may be experiencing. See README for more. (#1347)\n  * Fix hangups with SSL and persistent connections. (#1334)\n  * Fix Rails double-binding to a port (#1383)\n  * Fix incorrect thread names (#1368)\n  * Fix issues with /etc/hosts and JRuby where localhost addresses were not correct. (#1318)\n  * Fix compatibility with RUBYOPT=\"--enable-frozen-string-literal\" (#1376)\n  * Fixed some compiler warnings (#1388)\n  * We actually run the integration tests in CI now (#1390)\n  * No longer shipping unnecessary directories in the gemfile (#1391)\n  * If RUBYOPT is nil, we no longer blow up on restart. (#1385)\n  * Correct response to SIGINT (#1377)\n  * Proper exit code returned when we receive a TERM signal (#1337)\n\n* 3 refactors:\n  * Various test improvements from @grosser\n  * Rubocop (#1325)\n  * Hoe has been removed (#1395)\n\n* 1 known issue:\n  * Socket activation doesn't work in JRuby. Their fault, not ours. (#1367)\n\n## 3.9.1 / 2017-06-03\n\n* 2 bugfixes:\n  * Fixed compatibility with older Bundler versions (#1314)\n  * Some internal test/development cleanup (#1311, #1313)\n\n## 3.9.0 / 2017-06-01\n\n* 2 features:\n  * The ENV is now reset to its original values when Puma restarts via USR1/USR2 (#1260) (MRI only, no JRuby support)\n  * Puma will no longer accept more clients than the maximum number of threads. (#1278)\n\n* 9 bugfixes:\n  * Reduce information leakage by preventing HTTP parse errors from writing environment hashes to STDERR (#1306)\n  * Fix SSL/WebSocket compatibility (#1274)\n  * HTTP headers with empty values are no longer omitted from responses. (#1261)\n  * Fix a Rack env key which was set to nil. (#1259)\n  * peercert has been implemented for JRuby (#1248)\n  * Fix port settings when using rails s (#1277, #1290)\n  * Fix compat w/LibreSSL (#1285)\n  * Fix restarting Puma w/symlinks and a new Gemfile (#1282)\n  * Replace Dir.exists? with Dir.exist? (#1294)\n\n* 1 known issue:\n  * A bug in MRI 2.2+ can result in IOError: stream closed. See #1206. This issue has existed since at least Puma 3.6, and probably further back.\n\n* 1 refactor:\n  * Lots of test fixups from @grosser.\n\n## 3.8.2 / 2017-03-14\n\n* 1 bugfix:\n  * Deal with getsockopt with TCP\\_INFO failing for sockets that say they're TCP but aren't really. (#1241)\n\n## 3.8.1 / 2017-03-10\n\n* 1 bugfix:\n  * Remove method call to method that no longer exists (#1239)\n\n## 3.8.0 / 2017-03-09\n\n* 2 bugfixes:\n  * Port from rack handler does not take precedence over config file in Rails 5.1.0.beta2+ and 5.0.1.rc3+ (#1234)\n  * The `tmp/restart.txt` plugin no longer restricts the user from running more than one server from the same folder at a time (#1226)\n\n* 1 feature:\n  * Closed clients are aborted to save capacity (#1227)\n\n* 1 refactor:\n  * Bundler is no longer a dependency from tests (#1213)\n\n## 3.7.1 / 2017-02-20\n\n* 2 bugfixes:\n  * Fix typo which blew up MiniSSL (#1182)\n  * Stop overriding command-line options with the config file (#1203)\n\n## 3.7.0 / 2017-01-04\n\n* 6 minor features:\n  * Allow rack handler to accept ssl host. (#1129)\n  * Refactor TTOU processing. TTOU now handles multiple signals at once. (#1165)\n  * Pickup any remaining chunk data as the next request.\n  * Prevent short term thread churn - increased auto trim default to 30 seconds.\n  * Raise error when `stdout` or `stderr` is not writable. (#1175)\n  * Add Rack 2.0 support to gemspec. (#1068)\n\n* 5 refactors:\n  * Compare host and server name only once per call. (#1091)\n  * Minor refactor on Thread pool (#1088)\n  * Removed a ton of unused constants, variables and files.\n  * Use MRI macros when allocating heap memory\n  * Use hooks for on\\_booted event. (#1160)\n\n* 14 bugfixes:\n  * Add eof? method to NullIO? (#1169)\n  * Fix Puma startup in provided init.d script (#1061)\n  * Fix default SSL mode back to none. (#1036)\n  * Fixed the issue of @listeners getting nil io (#1120)\n  * Make `get_dh1024` compatible with OpenSSL v1.1.0 (#1178)\n  * More gracefully deal with SSL sessions. Fixes #1002\n  * Move puma.rb to just autoloads. Fixes #1063\n  * MiniSSL: Provide write as <<. Fixes #1089\n  * Prune bundler should inherit fds (#1114)\n  * Replace use of Process.getpgid which does not behave as intended on all platforms (#1110)\n  * Transfer encoding header should be downcased before comparison (#1135)\n  * Use same write log logic for hijacked requests. (#1081)\n  * Fix `uninitialized constant Puma::StateFile` (#1138)\n  * Fix access priorities of each level in LeveledOptions (#1118)\n\n* 3 others:\n\n  * Lots of tests added/fixed/improved. Switched to Minitest from Test::Unit. Big thanks to @frodsan.\n  * Lots of documentation added/improved.\n  * Add license indicators to the HTTP extension. (#1075)\n\n## 3.6.2 / 2016-11-22\n\n* 1 bug fix:\n\n  * Revert #1118/Fix access priorities of each level in LeveledOptions. This\n    had an unintentional side effect of changing the importance of command line\n    options, such as -p.\n\n## 3.6.1 / 2016-11-21\n\n* 8 bug fixes:\n\n  * Fix Puma start in init.d script.\n  * Fix default SSL mode back to none. Fixes #1036\n  * Fixed the issue of @listeners getting nil io, fix rails restart (#1120)\n  * More gracefully deal with SSL sessions. Fixes #1002\n  * Prevent short term thread churn.\n  * Provide write as <<. Fixes #1089\n  * Fix access priorities of each level in LeveledOptions - fixes TTIN.\n  * Stub description files updated for init.d.\n\n* 2 new project committers:\n\n  * Nate Berkopec (@nateberkopec)\n  * Richard Schneeman (@schneems)\n\n## 3.6.0 / 2016-07-24\n\n* 12 bug fixes:\n  * Add ability to detect a shutting down server. Fixes #932\n  * Add support for Expect: 100-continue. Fixes #519\n  * Check SSLContext better. Fixes #828\n  * Clarify behavior of '-t num'. Fixes #984\n  * Don't default to VERIFY_PEER. Fixes #1028\n  * Don't use ENV['PWD'] on windows. Fixes #1023\n  * Enlarge the scope of catching app exceptions. Fixes #1027\n  * Execute background hooks after daemonizing. Fixes #925\n  * Handle HUP as a stop unless there is IO redirection. Fixes #911\n  * Implement chunked request handling. Fixes #620\n  * Just rescue exception to return a 500. Fixes #1027\n  * Redirect IO in the jruby daemon mode. Fixes #778\n\n## 3.5.2 / 2016-07-20\n\n* 1 bug fix:\n  * Don't let persistent_timeout be nil\n\n* 1 PR merged:\n  * Merge pull request #1021 from benzrf/patch-1\n\n## 3.5.1 / 2016-07-20\n\n* 1 bug fix:\n  * Be sure to only listen on host:port combos once. Fixes #1022\n\n## 3.5.0 / 2016-07-18\n\n* 1 minor features:\n  * Allow persistent_timeout to be configured via the dsl.\n\n* 9 bug fixes:\n  * Allow a bare % in a query string. Fixes #958\n  * Explicitly listen on all localhost addresses. Fixes #782\n  * Fix `TCPLogger` log error in tcp cluster mode.\n  * Fix puma/puma#968 Cannot bind SSL port due to missing verify_mode option\n  * Fix puma/puma#968 Default verify_mode to peer\n  * Log any exceptions in ThreadPool. Fixes #1010\n  * Silence connection errors in the reactor. Fixes #959\n  * Tiny fixes in hook documentation for #840\n  * It should not log requests if we want it to be quiet\n\n* 5 doc fixes:\n  * Add How to stop Puma on Heroku using plugins to the example directory\n  * Provide both hot and phased restart in jungle script\n  * Update reference to the instances management script\n  * Update default number of threads\n  * Fix typo in example config\n\n* 14 PRs merged:\n  * Merge pull request #1007 from willnet/patch-1\n  * Merge pull request #1014 from jeznet/patch-1\n  * Merge pull request #1015 from bf4/patch-1\n  * Merge pull request #1017 from jorihardman/configurable_persistent_timeout\n  * Merge pull request #954 from jf/master\n  * Merge pull request #955 from jf/add-request-info-to-standard-error-rescue\n  * Merge pull request #956 from maxkwallace/master\n  * Merge pull request #960 from kmayer/kmayer-plugins-heroku-restart\n  * Merge pull request #969 from frankwong15/master\n  * Merge pull request #970 from willnet/delete-blank-document\n  * Merge pull request #974 from rocketjob/feature/name_threads\n  * Merge pull request #977 from snow/master\n  * Merge pull request #981 from zach-chai/patch-1\n  * Merge pull request #993 from scorix/master\n\n## 3.4.0 / 2016-04-07\n\n* 2 minor features:\n  * Add ability to force threads to stop on shutdown. Fixes #938\n  * Detect and commit seppuku when fork(2) fails. Fixes #529\n\n* 3 unknowns:\n  * Ignore errors trying to update the backport tables. Fixes #788\n  * Invoke the lowlevel_error in more places to allow for exception tracking. Fixes #894\n  * Update the query string when an absolute URI is used. Fixes #937\n\n* 5 doc fixes:\n  * Add Process Monitors section to top-level README\n  * Better document the hooks. Fixes #840\n  * docs/system.md sample config refinements and elaborations\n  * Fix typos at couple of places.\n  * Cleanup warnings\n\n* 3 PRs merged:\n  * Merge pull request #945 from dekellum/systemd-docs-refined\n  * Merge pull request #946 from vipulnsward/rm-pid\n  * Merge pull request #947 from vipulnsward/housekeeping-typos\n\n## 3.3.0 / 2016-04-05\n\n* 2 minor features:\n  * Allow overriding options of Configuration object\n  * Rename to inherit_ssl_listener like inherit_tcp|unix\n\n* 2 doc fixes:\n  * Add docs/systemd.md (with socket activation sub-section)\n  * Document UNIX signals with cluster on README.md\n\n* 3 PRs merged:\n  * Merge pull request #936 from prathamesh-sonpatki/allow-overriding-config-options\n  * Merge pull request #940 from kyledrake/signalsdoc\n  * Merge pull request #942 from dekellum/socket-activate-improve\n\n## 3.2.0 / 2016-03-20\n\n* 1 deprecation removal:\n  * Delete capistrano.rb\n\n* 3 bug fixes:\n  * Detect gems.rb as well as Gemfile\n  * Simplify and fix logic for directory to use when restarting for all phases\n  * Speed up phased-restart start\n\n* 2 PRs merged:\n  * Merge pull request #927 from jlecour/gemfile_variants\n  * Merge pull request #931 from joneslee85/patch-10\n\n## 3.1.1 / 2016-03-17\n\n* 4 bug fixes:\n  * Disable USR1 usage on JRuby\n  * Fixes #922 - Correctly define file encoding as UTF-8\n  * Set a more explicit SERVER_SOFTWARE Rack variable\n  * Show RUBY_ENGINE_VERSION if available. Fixes #923\n\n* 3 PRs merged:\n  * Merge pull request #912 from tricknotes/fix-allow-failures-in-travis-yml\n  * Merge pull request #921 from swrobel/patch-1\n  * Merge pull request #924 from tbrisker/patch-1\n\n## 3.1.0 / 2016-03-05\n\n* 1 minor feature:\n  * Add 'import' directive to config file. Fixes #916\n\n* 5 bug fixes:\n  * Add 'fetch' to options. Fixes #913\n  * Fix jruby daemonization. Fixes #918\n  * Recreate the proper args manually. Fixes #910\n  * Require 'time' to get iso8601. Fixes #914\n\n## 3.0.2 / 2016-02-26\n\n* 5 bug fixes:\n\n  * Fix 'undefined local variable or method `pid` for #<Puma::ControlCLI:0x007f185fcef968>' when execute pumactl with `--pid` option.\n  * Fix 'undefined method `windows?` for Puma:Module' when execute pumactl.\n  * Harden tmp_restart against errors related to the restart file\n  * Make `plugin :tmp_restart` behavior correct in Windows.\n  * fix uninitialized constant Puma::ControlCLI::StateFile\n\n* 3 PRs merged:\n\n  * Merge pull request #901 from mitto/fix-pumactl-uninitialized-constant-statefile\n  * Merge pull request #902 from corrupt952/fix_undefined_method_and_variable_when_execute_pumactl\n  * Merge pull request #905 from Eric-Guo/master\n\n## 3.0.1 / 2016-02-25\n\n* 1 bug fix:\n\n  * Removed the experimental support for async.callback as it broke\n    websockets entirely. Seems no server has both hijack and async.callback\n    and thus faye is totally confused what to do and doesn't work.\n\n## 3.0.0 / 2016-02-25\n\n* 2 major changes:\n\n  * Ruby pre-2.0 is no longer supported. We'll do our best to not add\n    features that break those rubies but will no longer be testing\n    with them.\n  * Don't log requests by default. Fixes #852\n\n* 2 major features:\n\n  * Plugin support! Plugins can interact with configuration as well\n    as provide augment server functionality!\n  * Experimental env['async.callback'] support\n\n* 4 minor features:\n\n  * Listen to unix socket with provided backlog if any\n  * Improves the clustered stats to report worker stats\n  * Pass the env to the lowlevel_error handler. Fixes #854\n  * Treat path-like hosts as unix sockets. Fixes #824\n\n* 5 bug fixes:\n\n  * Clean thread locals when using keepalive. Fixes #823\n  * Cleanup compiler warnings. Fixes #815\n  * Expose closed? for use by the reactor. Fixes #835\n  * Move signal handlers to separate method to prevent space leak. Fixes #798\n  * Signal not full on worker exit #876\n\n* 5 doc fixes:\n\n  * Update README.md with various grammar fixes\n  * Use newest version of Minitest\n  * Add directory configuration docs, fix typo [ci skip]\n  * Remove old COPYING notice. Fixes #849\n\n* 10 merged PRs:\n\n  * Merge pull request #871 from deepj/travis\n  * Merge pull request #874 from wallclockbuilder/master\n  * Merge pull request #883 from dadah89/igor/trim_only_worker\n  * Merge pull request #884 from uistudio/async-callback\n  * Merge pull request #888 from mlarraz/tick_minitest\n  * Merge pull request #890 from todd/directory_docs\n  * Merge pull request #891 from ctaintor/improve_clustered_status\n  * Merge pull request #893 from spastorino/add_missing_require\n  * Merge pull request #897 from zendesk/master\n  * Merge pull request #899 from kch/kch-readme-fixes\n\n## 2.16.0 / 2016-01-27\n\n* 7 minor features:\n\n  * Add 'set_remote_address' config option\n  * Allow to run puma in silent mode\n  * Expose cli options in DSL\n  * Support passing JRuby keystore info in ssl_bind DSL\n  * Allow umask for unix:/// style control urls\n  * Expose `old_worker_count` in stats url\n  * Support TLS client auth (verify_mode) in jruby\n\n* 7 bug fixes:\n\n  * Don't persist before_fork hook in state file\n  * Reload bundler before pulling in rack. Fixes #859\n  * Remove NEWRELIC_DISPATCHER env variable\n  * Cleanup C code\n  * Use Timeout.timeout instead of Object.timeout\n  * Make phased restarts faster\n  * Ignore the case of certain headers, because HTTP\n\n* 1 doc changes:\n\n  * Test against the latest Ruby 2.1, 2.2, 2.3, head and JRuby 9.0.4.0 on Travis\n\n* 12 merged PRs\n  * Merge pull request #822 from kwugirl/remove_NEWRELIC_DISPATCHER\n  * Merge pull request #833 from joemiller/jruby-client-tls-auth\n  * Merge pull request #837 from YuriSolovyov/ssl-keystore-jruby\n  * Merge pull request #839 from mezuka/master\n  * Merge pull request #845 from deepj/timeout-deprecation\n  * Merge pull request #846 from sriedel/strip_before_fork\n  * Merge pull request #850 from deepj/travis\n  * Merge pull request #853 from Jeffrey6052/patch-1\n  * Merge pull request #857 from zendesk/faster_phased_restarts\n  * Merge pull request #858 from mlarraz/fix_some_warnings\n  * Merge pull request #860 from zendesk/expose_old_worker_count\n  * Merge pull request #861 from zendesk/allow_control_url_umask\n\n## 2.15.3 / 2015-11-07\n\n* 1 bug fix:\n\n  * Fix JRuby parser\n\n## 2.15.2 / 2015-11-06\n\n* 2 bug fixes:\n  * ext/puma_http11: handle duplicate headers as per RFC\n  * Only set ctx.ca iff there is a params['ca'] to set with.\n\n* 2 PRs merged:\n  * Merge pull request #818 from unleashed/support-duplicate-headers\n  * Merge pull request #819 from VictorLowther/fix-ca-and-verify_null-exception\n\n## 2.15.1 / 2015-11-06\n\n* 1 bug fix:\n\n  * Allow older openssl versions\n\n## 2.15.0 / 2015-11-06\n\n* 6 minor features:\n  * Allow setting ca without setting a verify mode\n  * Make jungle for init.d support rbenv\n  * Use SSL_CTX_use_certificate_chain_file for full chain\n  * cluster: add worker_boot_timeout option\n  * configuration: allow empty tags to mean no tag desired\n  * puma/cli: support specifying STD{OUT,ERR} redirections and append mode\n\n* 5 bug fixes:\n  * Disable SSL Compression\n  * Fix bug setting worker_directory when using a symlink directory\n  * Fix error message in DSL that was slightly inaccurate\n  * Pumactl: set correct process name. Fixes #563\n  * thread_pool: fix race condition when shutting down workers\n\n* 10 doc fixes:\n  * Add before_fork explanation in Readme.md\n  * Correct spelling in DEPLOYMENT.md\n  * Correct spelling in docs/nginx.md\n  * Fix spelling errors.\n  * Fix typo in deployment description\n  * Fix typos (it's -> its) in events.rb and server.rb\n  * fixing for typo mentioned in #803\n  * Spelling correction for README\n  * thread_pool: fix typos in comment\n  * More explicit docs for worker_timeout\n\n* 18 PRs merged:\n  * Merge pull request #768 from nathansamson/patch-1\n  * Merge pull request #773 from rossta/spelling_corrections\n  * Merge pull request #774 from snow/master\n  * Merge pull request #781 from sunsations/fix-typo\n  * Merge pull request #791 from unleashed/allow_empty_tags\n  * Merge pull request #793 from robdimarco/fix-working-directory-symlink-bug\n  * Merge pull request #794 from peterkeen/patch-1\n  * Merge pull request #795 from unleashed/redirects-from-cmdline\n  * Merge pull request #796 from cschneid/fix_dsl_message\n  * Merge pull request #799 from annafw/master\n  * Merge pull request #800 from liamseanbrady/fix_typo\n  * Merge pull request #801 from scottjg/ssl-chain-file\n  * Merge pull request #802 from scottjg/ssl-crimes\n  * Merge pull request #804 from burningTyger/patch-2\n  * Merge pull request #809 from unleashed/threadpool-fix-race-in-shutdown\n  * Merge pull request #810 from vlmonk/fix-pumactl-restart-bug\n  * Merge pull request #814 from schneems/schneems/worker_timeout-docs\n  * Merge pull request #817 from unleashed/worker-boot-timeout\n\n## 2.14.0 / 2015-09-18\n\n* 1 minor feature:\n  * Make building with SSL support optional\n\n* 1 bug fix:\n  * Use Rack::Builder if available. Fixes #735\n\n## 2.13.4 / 2015-08-16\n\n* 1 bug fix:\n  * Use the environment possible set by the config early and from\n    the config file later (if set).\n\n## 2.13.3 / 2015-08-15\n\nSeriously, I need to revamp config with tests.\n\n* 1 bug fix:\n  * Fix preserving options before cleaning for state. Fixes #769\n\n## 2.13.2 / 2015-08-15\n\nThe \"clearly I don't have enough tests for the config\" release.\n\n* 1 bug fix:\n  * Fix another place binds wasn't initialized. Fixes #767\n\n## 2.13.1 / 2015-08-15\n\n* 2 bug fixes:\n  * Fix binds being masked in config files. Fixes #765\n  * Use options from the config file properly in pumactl. Fixes #764\n\n## 2.13.0 / 2015-08-14\n\n* 1 minor feature:\n  * Add before_fork hooks option.\n\n* 3 bug fixes:\n  * Check for OPENSSL_NO_ECDH before using ECDH\n  * Eliminate logging overhead from JRuby SSL\n  * Prefer cli options over config file ones. Fixes #669\n\n* 1 deprecation:\n  * Add deprecation warning to capistrano.rb. Fixes #673\n\n* 4 PRs merged:\n  * Merge pull request #668 from kcollignon/patch-1\n  * Merge pull request #754 from nathansamson/before_boot\n  * Merge pull request #759 from BenV/fix-centos6-build\n  * Merge pull request #761 from looker/no-log\n\n## 2.12.3 / 2015-08-03\n\n* 8 minor bugs fixed:\n  * Fix Capistrano 'uninitialized constant Puma' error.\n  * Fix some ancient and incorrect error handling code\n  * Fix uninitialized constant error\n  * Remove toplevel rack interspection, require rack on load instead\n  * Skip empty parts when chunking\n  * Switch from inject to each in config_ru_binds iteration\n  * Wrap SSLv3 spec in version guard.\n  * ruby 1.8.7 compatibility patches\n\n* 4 PRs merged:\n  * Merge pull request #742 from deivid-rodriguez/fix_missing_require\n  * Merge pull request #743 from matthewd/skip-empty-chunks\n  * Merge pull request #749 from huacnlee/fix-cap-uninitialized-puma-error\n  * Merge pull request #751 from costi/compat_1_8_7\n\n* 1 test fix:\n  * Add 1.8.7, rbx-1 (allow failures) to Travis.\n\n## 2.12.2 / 2015-07-17\n\n* 2 bug fix:\n  * Pull over and use Rack::URLMap. Fixes #741\n  * Stub out peercert on JRuby for now. Fixes #739\n\n## 2.12.1 / 2015-07-16\n\n* 2 bug fixes:\n  * Use a constant format. Fixes #737\n  * Use strerror for Windows sake. Fixes #733\n\n* 1 doc change:\n  * typo fix: occured -> occurred\n\n* 1 PR merged:\n  * Merge pull request #736 from paulanunda/paulanunda/typo-fix\n\n## 2.12.0 / 2015-07-14\n\n* 13 bug fixes:\n  * Add thread reaping to thread pool\n  * Do not automatically use chunked responses when hijacked\n  * Do not suppress Content-Length on partial hijack\n  * Don't allow any exceptions to terminate a thread\n  * Handle ENOTCONN client disconnects when setting REMOTE_ADDR\n  * Handle very early exit of cluster mode. Fixes #722\n  * Install rack when running tests on travis to use rack/lint\n  * Make puma -v and -h return success exit code\n  * Make pumactl load config/puma.rb by default\n  * Pass options from pumactl properly when pruning. Fixes #694\n  * Remove rack dependency. Fixes #705\n  * Remove the default Content-Type: text/plain\n  * Add Client Side Certificate Auth\n\n* 8 doc/test changes:\n  * Added example sourcing of environment vars\n  * Added tests for bind configuration on rackup file\n  * Fix example config text\n  * Update DEPLOYMENT.md\n  * Update Readme with example of custom error handler\n  * ci: Improve Travis settings\n  * ci: Start running tests against JRuby 9k on Travis\n  * ci: Convert to container infrastructure for travisci\n\n* 2 ops changes:\n  * Check for system-wide rbenv\n  * capistrano: Add additional env when start rails\n\n* 16 PRs merged:\n  * Merge pull request #686 from jjb/patch-2\n  * Merge pull request #693 from rob-murray/update-example-config\n  * Merge pull request #697 from spk/tests-bind-on-rackup-file\n  * Merge pull request #699 from deees/fix/require_rack_builder\n  * Merge pull request #701 from deepj/master\n  * Merge pull request #702 from Jimdo/thread-reaping\n  * Merge pull request #703 from deepj/travis\n  * Merge pull request #704 from grega/master\n  * Merge pull request #709 from lian/master\n  * Merge pull request #711 from julik/master\n  * Merge pull request #712 from yakara-ltd/pumactl-default-config\n  * Merge pull request #715 from RobotJiang/master\n  * Merge pull request #725 from rwz/master\n  * Merge pull request #726 from strenuus/handle-client-disconnect\n  * Merge pull request #729 from allaire/patch-1\n  * Merge pull request #730 from iamjarvo/container-infrastructure\n\n## 2.11.3 / 2015-05-18\n\n* 5 bug fixes:\n  * Be sure to unlink tempfiles after a request. Fixes #690\n  * Coerce the key to a string before checking. (thar be symbols). Fixes #684\n  * Fix hang on bad SSL handshake\n  * Remove `enable_SSLv3` support from JRuby\n\n* 1 PR merged:\n  * Merge pull request #698 from looker/hang-handshake\n\n## 2.11.2 / 2015-04-11\n\n* 2 minor features:\n  * Add `on_worker_fork` hook, which allows to mimic Unicorn's behavior\n  * Add shutdown_debug config option\n\n* 4 bug fixes:\n  * Fix the Config constants not being available in the DSL. Fixes #683\n  * Ignore multiple port declarations\n  * Proper 'Connection' header handling compatible with HTTP 1.[01] protocols\n  * Use \"Puma\" instead of \"puma\" to reporting to New Relic\n\n* 1 doc fixes:\n  * Add Gitter badge.\n\n* 6 PRs merged:\n  * Merge pull request #657 from schneems/schneems/puma-once-port\n  * Merge pull request #658 from Tomohiro/newrelic-dispatcher-default-update\n  * Merge pull request #662 from basecrm/connection-compatibility\n  * Merge pull request #664 from fxposter/on-worker-fork\n  * Merge pull request #667 from JuanitoFatas/doc/gemspec\n  * Merge pull request #672 from chulkilee/refactor\n\n## 2.11.1 / 2015-02-11\n\n* 2 bug fixes:\n  * Avoid crash in strange restart conditions\n  * Inject the GEM_HOME that bundler into puma-wild's env. Fixes #653\n\n* 2 PRs merged:\n  * Merge pull request #644 from bpaquet/master\n  * Merge pull request #646 from mkonecny/master\n\n## 2.11.0 / 2015-01-20\n\n* 9 bug fixes:\n  * Add mode as an additional bind option to unix sockets. Fixes #630\n  * Advertise HTTPS properly after a hot restart\n  * Don't write lowlevel_error_handler to state\n  * Fix phased restart with stuck requests\n  * Handle spaces in the path properly. Fixes #622\n  * Set a default REMOTE_ADDR to avoid using peeraddr on unix sockets. Fixes #583\n  * Skip device number checking on jruby. Fixes #586\n  * Update extconf.rb to compile correctly on OS X\n  * redirect io right after daemonizing so startup errors are shown. Fixes #359\n\n* 6 minor features:\n  * Add a configuration option that prevents puma from queueing requests.\n  * Add reload_worker_directory\n  * Add the ability to pass environment variables to the init script (for Jungle).\n  * Add the proctitle tag to the worker. Fixes #633\n  * Infer a proctitle tag based on the directory\n  * Update lowlevel error message to be more meaningful.\n\n* 10 PRs merged:\n  * Merge pull request #478 from rubencaro/master\n  * Merge pull request #610 from kwilczynski/master\n  * Merge pull request #611 from jasonl/better-lowlevel-message\n  * Merge pull request #616 from jc00ke/master\n  * Merge pull request #623 from raldred/patch-1\n  * Merge pull request #628 from rdpoor/master\n  * Merge pull request #634 from deepj/master\n  * Merge pull request #637 from raskhadafi/patch-1\n  * Merge pull request #639 from ebeigarts/fix-phased-restarts\n  * Merge pull request #640 from codehotter/issue-612-dependent-requests-deadlock\n\n## 2.10.2 / 2014-11-26\n\n* 1 bug fix:\n  * Conditionalize thread local cleaning, fixes perf degradation fix\n    The code to clean out all Thread locals adds pretty significant\n    overhead to a each request, so it has to be turned on explicitly\n    if a user needs it.\n\n## 2.10.1 / 2014-11-24\n\n* 1 bug fix:\n  * Load the app after daemonizing because the app might start threads.\n\n  This change means errors loading the app are now reported only in the redirected\n  stdout/stderr.\n\n  If you're app has problems starting up, start it without daemon mode initially\n  to test.\n\n## 2.10.0 / 2014-11-23\n\n* 3 minor features:\n  * Added on_worker_shutdown hook mechanism\n  * Allow binding to ipv6 addresses for ssl URIs\n  * Warn about any threads started during app preload\n\n* 5 bug fixes:\n  * Clean out a threads local data before doing work\n  * Disable SSLv3. Fixes #591\n  * First change the directory to use the correct Gemfile.\n  * Only use config.ru binds if specified. Fixes #606\n  * Strongish cipher suite with FS support for some browsers\n\n* 2 doc changes:\n  * Change umask examples to more permissive values\n  * fix typo in README.md\n\n* 9 Merged PRs:\n  * Merge pull request #560 from raskhadafi/prune_bundler-bug\n  * Merge pull request #566 from sheltond/master\n  * Merge pull request #593 from andruby/patch-1\n  * Merge pull request #594 from hassox/thread-cleanliness\n  * Merge pull request #596 from burningTyger/patch-1\n  * Merge pull request #601 from sorentwo/friendly-umask\n  * Merge pull request #602 from 1334/patch-1\n  * Merge pull request #608 from Gu1/master\n  * Merge remote-tracking branch 'origin/pr/538'\n\n## 2.9.2 / 2014-10-25\n\n* 8 bug fixes:\n  * Fix puma-wild handling a restart properly. Fixes #550\n  * JRuby SSL POODLE update\n  * Keep deprecated features warnings\n  * Log the current time when Puma shuts down.\n  * Fix cross-platform extension library detection\n  * Use the correct Windows names for OpenSSL.\n  * Better error logging during startup\n  * Fixing sexist error messages\n\n* 6 PRs merged:\n  * Merge pull request #549 from bsnape/log-shutdown-time\n  * Merge pull request #553 from lowjoel/master\n  * Merge pull request #568 from mariuz/patch-1\n  * Merge pull request #578 from danielbuechele/patch-1\n  * Merge pull request #581 from alexch/slightly-better-logging\n  * Merge pull request #590 from looker/jruby_disable_sslv3\n\n## 2.9.1 / 2014-09-05\n\n* 4 bug fixes:\n  * Cleanup the SSL related structures properly, fixes memory leak\n  * Fix thread spawning edge case.\n  * Force a worker check after a worker boots, don't wait 5sec. Fixes #574\n  * Implement SIGHUP for logs reopening\n\n* 2 PRs merged:\n  * Merge pull request #561 from theoldreader/sighup\n  * Merge pull request #570 from havenwood/spawn-thread-edge-case\n\n## 2.9.0 / 2014-07-12\n\n* 1 minor feature:\n  * Add SSL support for JRuby\n\n* 3 bug fixes:\n  * Typo BUNDLER_GEMFILE -> BUNDLE_GEMFILE\n  * Use fast_write because we can't trust syswrite\n  * pumactl - do not modify original ARGV\n\n* 4 doc fixes:\n  * BSD-3-Clause over BSD to avoid confusion\n  * Deploy doc: clarification of the GIL\n  * Fix typo in DEPLOYMENT.md\n  * Update README.md\n\n* 6 PRs merged:\n  * Merge pull request #520 from misfo/patch-2\n  * Merge pull request #530 from looker/jruby-ssl\n  * Merge pull request #537 from vlmonk/patch-1\n  * Merge pull request #540 from allaire/patch-1\n  * Merge pull request #544 from chulkilee/bsd-3-clause\n  * Merge pull request #551 from jcxplorer/patch-1\n\n## 2.8.2 / 2014-04-12\n\n* 4 bug fixes:\n  * During upgrade, change directory in main process instead of workers.\n  * Close the client properly on error\n  * Capistrano: fallback from phased restart to start when not started\n  * Allow tag option in conf file\n\n* 4 doc fixes:\n  * Fix Puma daemon service README typo\n  * `preload_app!` instead of `preload_app`\n  * add preload_app and prune_bundler to example config\n  * allow changing of worker_timeout in config file\n\n* 11 PRs merged:\n  * Merge pull request #487 from ckuttruff/master\n  * Merge pull request #492 from ckuttruff/master\n  * Merge pull request #493 from alepore/config_tag\n  * Merge pull request #503 from mariuz/patch-1\n  * Merge pull request #505 from sammcj/patch-1\n  * Merge pull request #506 from FlavourSys/config_worker_timeout\n  * Merge pull request #510 from momer/rescue-block-handle-servers-fix\n  * Merge pull request #511 from macool/patch-1\n  * Merge pull request #514 from edogawaconan/refactor_env\n  * Merge pull request #517 from misfo/patch-1\n  * Merge pull request #518 from LongMan/master\n\n## 2.8.1 / 2014-03-06\n\n* 1 bug fixes:\n  * Run puma-wild with proper deps for prune_bundler\n\n* 2 doc changes:\n  * Described the configuration file finding behavior added in 2.8.0 and how to disable it.\n  * Start the deployment doc\n\n* 6 PRs merged:\n  * Merge pull request #471 from arthurnn/fix_test\n  * Merge pull request #485 from joneslee85/patch-9\n  * Merge pull request #486 from joshwlewis/patch-1\n  * Merge pull request #490 from tobinibot/patch-1\n  * Merge pull request #491 from brianknight10/clarify-no-config\n\n## 2.8.0 / 2014-02-28\n\n* 8 minor features:\n  * Add ability to autoload a config file. Fixes #438\n  * Add ability to detect and terminate hung workers. Fixes #333\n  * Add booted_workers to stats response\n  * Add config to customize the default error message\n  * Add prune_bundler option\n  * Add worker indexes, expose them via on_worker_boot. Fixes #440\n  * Add pretty process name\n  * Show the ruby version in use\n\n* 7 bug fixes:\n  * Added 408 status on timeout.\n  * Be more hostile with sockets that write block. Fixes #449\n  * Expect at_exit to exclusively remove the pidfile. Fixes #444\n  * Expose latency and listen backlog via bind query. Fixes #370\n  * JRuby raises IOError if the socket is there. Fixes #377\n  * Process requests fairly. Fixes #406\n  * Rescue SystemCallError as well. Fixes #425\n\n* 4 doc changes:\n  * Add 2.1.0 to the matrix\n  * Add Code Climate badge to README\n  * Create signals.md\n  * Set the license to BSD. Fixes #432\n\n* 14 PRs merged:\n  * Merge pull request #428 from alexeyfrank/capistrano_default_hooks\n  * Merge pull request #429 from namusyaka/revert-const_defined\n  * Merge pull request #431 from mrb/master\n  * Merge pull request #433 from alepore/process-name\n  * Merge pull request #437 from ibrahima/master\n  * Merge pull request #446 from sudara/master\n  * Merge pull request #451 from pwiebe/status_408\n  * Merge pull request #453 from joevandyk/patch-1\n  * Merge pull request #470 from arthurnn/fix_458\n  * Merge pull request #472 from rubencaro/master\n  * Merge pull request #480 from jjb/docs-on-running-test-suite\n  * Merge pull request #481 from schneems/master\n  * Merge pull request #482 from prathamesh-sonpatki/signals-doc-cleanup\n  * Merge pull request #483 from YotpoLtd/master\n\n## 2.7.1 / 2013-12-05\n\n* 1 bug fix:\n\n  * Keep STDOUT/STDERR the right mode. Fixes #422\n\n## 2.7.0 / 2013-12-03\n\n* 1 minor feature:\n  * Adding TTIN and TTOU to increment/decrement workers\n\n* N bug fixes:\n  * Always use our Process.daemon because it's not busted\n  * Add capistrano restart failback to start.\n  * Change position of `cd` so that rvm gemset is loaded\n  * Clarify some platform specifics\n  * Do not close the pipe sockets when retrying\n  * Fix String#byteslice for Ruby 1.9.1, 1.9.2\n  * Fix compatibility with 1.8.7.\n  * Handle IOError closed stream in IO.select\n  * Increase the max URI path length to 2048 chars from 1024 chars\n  * Upstart jungle use config/puma.rb instead\n\n## 2.6.0 / 2013-09-13\n\n* 2 minor features:\n  * Add support for event hooks\n  ** Add a hook for state transitions\n  * Add phased restart to capistrano recipe.\n\n* 4 bug fixes:\n  * Convince workers to stop by SIGKILL after timeout\n  * Define RSTRING_NOT_MODIFIED for Rubinius performance\n  * Handle BrokenPipe, StandardError and IOError in fat_wrote and break out\n  * Return success status to the invoking environment\n\n## 2.5.1 / 2013-08-13\n\n* 2 bug fixes:\n\n  * Keep jruby daemon mode from retrying on a hot restart\n  * Extract version from const.rb in gemspec\n\n## 2.5.0 / 2013-08-08\n\n* 2 minor features:\n  * Allow configuring pumactl with config.rb\n  * make `pumactl restart` start puma if not running\n\n* 6 bug fixes:\n  * Autodetect ruby managers and home directory in upstart script\n  * Convert header values to string before sending.\n  * Correctly report phased-restart availability\n  * Fix pidfile creation/deletion race on jruby daemonization\n  * Use integers when comparing thread counts\n  * Fix typo in using lopez express (raw tcp) mode\n\n* 6 misc changes:\n  * Fix typo in phased-restart response\n  * Uncomment setuid/setgid by default in upstart\n  * Use Puma::Const::PUMA_VERSION in gemspec\n  * Update upstart comments to reflect new commandline\n  * Remove obsolete pumactl instructions; refer to pumactl for details\n  * Make Bundler used puma.gemspec version agnostic\n\n## 2.4.1 / 2013-08-07\n\n* 1 experimental feature:\n  * Support raw tcp servers (aka Lopez Express mode)\n\n## 2.4.0 / 2013-07-22\n\n* 5 minor features:\n  * Add PUMA_JRUBY_DAEMON_OPTS to get around agent starting twice\n  * Add ability to drain accept socket on shutdown\n  * Add port to DSL\n  * Adds support for using puma config file in capistrano deploys.\n  * Make phased_restart fallback to restart if not available\n\n* 10 bug fixes:\n\n  * Be sure to only delete the pid in the master. Fixes #334\n  * Call out -C/--config flags\n  * Change parser symbol names to avoid clash. Fixes #179\n  * Convert thread pool sizes to integers\n  * Detect when the jruby daemon child doesn't start properly\n  * Fix typo in CLI help\n  * Improve the logging output when hijack is used. Fixes #332\n  * Remove unnecessary thread pool size conversions\n  * Setup :worker_boot as an Array. Fixes #317\n  * Use 127.0.0.1 as REMOTE_ADDR of unix client. Fixes #309\n\n\n## 2.3.2 / 2013-07-08\n\n* 1 bug fix:\n\n  * Move starting control server to after daemonization.\n\n## 2.3.1 / 2013-07-06\n\n* 2 bug fixes:\n\n  * Include the right files in the Manifest.\n  * Disable inheriting connections on restart on windows. Fixes #166\n\n* 1 doc change:\n  * Better document some platform constraints\n\n## 2.3.0 / 2013-07-05\n\n* 1 major bug fix:\n\n  * Stabilize control server, add support in cluster mode\n\n* 5 minor bug fixes:\n\n  * Add ability to cleanup stale unix sockets\n  * Check status data better. Fixes #292\n  * Convert raw IO errors to ConnectionError. Fixes #274\n  * Fix sending Content-Type and Content-Length for no body status. Fixes #304\n  * Pass state path through to `pumactl start`. Fixes #287\n\n* 2 internal changes:\n\n  * Refactored modes into seperate classes that CLI uses\n  * Changed CLI to take an Events object instead of stdout/stderr (API change)\n\n## 2.2.2 / 2013-07-02\n\n* 1 bug fix:\n\n  * Fix restart_command in the config\n\n## 2.2.1 / 2013-07-02\n\n* 1 minor feature:\n\n  * Introduce preload flag\n\n* 1 bug fix:\n\n  * Pass custom restart command in JRuby\n\n## 2.2.0 / 2013-07-01\n\n* 1 major feature:\n\n  * Add ability to preload rack app\n\n* 2 minor bugfixes:\n\n  * Don't leak info when not in development. Fixes #256\n  * Load the app, then bind the ports\n\n## 2.1.1 / 2013-06-20\n\n* 2 minor bug fixes:\n\n  * Fix daemonization on jruby\n  * Load the application before daemonizing. Fixes #285\n\n## 2.1.0 / 2013-06-18\n\n* 3 minor features:\n  * Allow listening socket to be configured via Capistrano variable\n  * Output results from 'stat's command when using pumactl\n  * Support systemd socket activation\n\n* 15 bug fixes:\n  * Deal with pipes closing while stopping. Fixes #270\n  * Error out early if there is no app configured\n  * Handle ConnectionError rather than the lowlevel exceptions\n  * tune with `-C` config file and `on_worker_boot`\n  * use `-w`\n  * Fixed some typos in upstart scripts\n  * Make sure to use bytesize instead of size (MiniSSL write)\n  * Fix an error in puma-manager.conf\n  * fix: stop leaking sockets on restart (affects ruby 1.9.3 or before)\n  * Ignore errors on the cross-thread pipe. Fixes #246\n  * Ignore errors while uncorking the socket (it might already be closed)\n  * Ignore the body on a HEAD request. Fixes #278\n  * Handle all engine data when possible. Fixes #251.\n  * Handle all read exceptions properly. Fixes #252\n  * Handle errors from the server better\n\n* 3 doc changes:\n  * Add note about on_worker_boot hook\n  * Add some documentation for Clustered mode\n  * Added quotes to /etc/puma.conf\n\n## 2.0.1 / 2013-04-30\n\n* 1 bug fix:\n\n  * Fix not starting on JRuby properly\n\n## 2.0.0 / 2013-04-29\n\nRailsConf 2013 edition!\n\n* 2 doc changes:\n  * Start with rackup -s Puma, NOT rackup -s puma.\n  * Minor doc fixes in the README.md, Capistrano section\n\n* 2 bug fixes:\n  * Fix reading RACK_ENV properly. Fixes #234\n  * Make cap recipe handle tmp/sockets; fixes #228\n\n* 3 minor changes:\n  * Fix capistrano recipe\n  * Fix stdout/stderr logs to sync outputs\n  * allow binding to IPv6 addresses\n\n## 2.0.0.b7 / 2013-03-18\n\n* 5 minor enhancements:\n\n  * Add -q option for :start\n  * Add -V, --version\n  * Add default Rack handler helper\n  * Upstart support\n  * Set worker directory from configuration file\n\n* 12 bug fixes:\n\n  * Close the binder in the right place. Fixes #192\n  * Handle early term in workers. Fixes #206\n  * Make sure that the default port is 80 when the request doesn't include HTTP_X_FORWARDED_PROTO.\n  * Prevent Errno::EBADF errors on restart when running ruby 2.0\n  * Record the proper @master_pid\n  * Respect the header HTTP_X_FORWARDED_PROTO when the host doesn't include a port number.\n  * Retry EAGAIN/EWOULDBLOCK during syswrite\n  * Run exec properly to restart. Fixes #154\n  * Set Rack run_once to false\n  * Syncronize all access to @timeouts. Fixes #208\n  * Write out the state post-daemonize. Fixes #189\n  * Prevent crash when all workers are gone\n\n## 2.0.0.b6 / 2013-02-06\n\n* 2 minor enhancements:\n\n  * Add hook for running when a worker boots\n  * Advertise the Configuration object for apps to use.\n\n* 1 bug fix:\n\n  * Change directory in working during upgrade. Fixes #185\n\n## 2.0.0.b5 / 2013-02-05\n\n* 2 major features:\n  * Add phased worker upgrade\n  * Add support for the rack hijack protocol\n\n* 2 minor features:\n  * Add -R to specify the restart command\n  * Add config file option to specify the restart command\n\n* 5 bug fixes:\n  * Cleanup pipes properly. Fixes #182\n  * Daemonize earlier so that we don't lose app threads. Fixes #183\n  * Drain the notification pipe. Fixes #176, thanks @cryo28\n  * Move write_pid to after we daemonize. Fixes #180\n  * Redirect IO properly and emit message for checkpointing\n\n## 2.0.0.b4 / 2012-12-12\n\n* 4 bug fixes:\n  * Properly check #syswrite's value for variable sized buffers. Fixes #170\n  * Shutdown status server properly\n  * Handle char vs byte and mixing syswrite with write properly\n  * made MiniSSL validate key/cert file existence\n\n## 2.0.0.b3 / 2012-11-22\n\n* 1 bug fix:\n  * Package right files in gem\n\n## 2.0.0.b2 / 2012-11-18\n* 5 minor feature:\n  * Now Puma is bundled with an capistrano recipe. Just require\n     'puma/capistrano' in you deploy.rb\n  * Only inject CommonLogger in development mode\n  * Add -p option to pumactl\n  * Add ability to use pumactl to start a server\n  * Add options to daemonize puma\n\n* 7 bug fixes:\n  * Reset the IOBuffer properly. Fixes #148\n  * Shutdown gracefully on JRuby with Ctrl-C\n  * Various methods to get newrelic to start. Fixes #128\n  * fixing syntax error at capistrano recipe\n  * Force ECONNRESET when read returns nil\n  * Be sure to empty the drain the todo before shutting down. Fixes #155\n  * allow for alternate locations for status app\n\n## 2.0.0.b1 / 2012-09-11\n\n* 1 major feature:\n  * Optional worker process mode (-w) to allow for process scaling in\n    addition to thread scaling\n\n* 1 bug fix:\n  * Introduce Puma::MiniSSL to be able to properly control doing\n    nonblocking SSL\n\nNOTE: SSL support in JRuby is not supported at present. Support will\nbe added back in a future date when a java Puma::MiniSSL is added.\n\n## 1.6.3 / 2012-09-04\n\n* 1 bug fix:\n  * Close sockets waiting in the reactor when a hot restart is performed\n    so that browsers reconnect on the next request\n\n## 1.6.2 / 2012-08-27\n\n* 1 bug fix:\n  * Rescue StandardError instead of IOError to handle SystemCallErrors\n    as well as other application exceptions inside the reactor.\n\n## 1.6.1 / 2012-07-23\n\n* 1 packaging bug fixed:\n  * Include missing files\n\n## 1.6.0 / 2012-07-23\n\n* 1 major bug fix:\n  * Prevent slow clients from starving the server by introducing a\n    dedicated IO reactor thread. Credit for reporting goes to @meh.\n\n## 1.5.0 / 2012-07-19\n\n* 7 contributors to this release:\n  * Christian Mayer\n  * Dar\u00edo Javier Cravero\n  * Dirkjan Bussink\n  * Gianluca Padovani\n  * Santiago Pastorino\n  * Thibault Jouan\n  * tomykaira\n\n* 6 bug fixes:\n  * Define RSTRING_NOT_MODIFIED for Rubinius\n  * Convert status to integer. Fixes #123\n  * Delete pidfile when stopping the server\n  * Allow compilation with -Werror=format-security option\n  * Fix wrong HTTP version for a HTTP/1.0 request\n  * Use String#bytesize instead of String#length\n\n* 3 minor features:\n  * Added support for setting RACK_ENV via the CLI, config file, and rack app\n  * Allow Server#run to run sync. Fixes #111\n  * Puma can now run on windows\n\n## 1.4.0 / 2012-06-04\n\n* 1 bug fix:\n  * SCRIPT_NAME should be passed from env to allow mounting apps\n\n* 1 experimental feature:\n  * Add puma.socket key for direct socket access\n\n## 1.3.1 / 2012-05-15\n\n* 2 bug fixes:\n  * use #bytesize instead of #length for Content-Length header\n  * Use StringIO properly. Fixes #98\n\n## 1.3.0 / 2012-05-08\n\n* 2 minor features:\n  * Return valid Rack responses (passes Lint) from status server\n  * Add -I option to specify $LOAD_PATH directories\n\n* 4 bug fixes:\n  * Don't join the server thread inside the signal handle. Fixes #94\n  * Make NullIO#read mimic IO#read\n  * Only stop the status server if it's started. Fixes #84\n  * Set RACK_ENV early in cli also. Fixes #78\n\n* 1 new contributor:\n  * Jesse Cooke\n\n## 1.2.2 / 2012-04-28\n\n* 4 bug fixes:\n\n  * Report a lowlevel error to stderr\n  * Set a fallback SERVER_NAME and SERVER_PORT\n  * Keep the encoding of the body correct. Fixes #79\n  * show error.to_s along with backtrace for low-level error\n\n## 1.2.1 / 2012-04-11\n\n 1 bug fix:\n\n   * Fix rack.url_scheme for SSL servers. Fixes #65\n\n## 1.2.0 / 2012-04-11\n\n 1 major feature:\n\n   * When possible, the internal restart does a \"hot restart\" meaning\n     the server sockets remains open, so no connections are lost.\n\n 1 minor feature:\n\n    * More helpful fallback error message\n\n 6 bug fixes:\n\n    * Pass the proper args to unknown_error. Fixes #54, #58\n    * Stop the control server before restarting. Fixes #61\n    * Fix reporting https only on a true SSL connection\n    * Set the default content type to 'text/plain'. Fixes #63\n    * Use REUSEADDR. Fixes #60\n    * Shutdown gracefully on SIGTERM. Fixes #53\n\n 2 new contributors:\n\n   * Seamus Abshere\n   * Steve Richert\n\n## 1.1.1 / 2012-03-30\n\n 1 bugfix:\n\n   * Include puma/compat.rb in the gem (oops!)\n\n## 1.1.0 / 2012-03-30\n\n 1 bugfix:\n\n   * Make sure that the unix socket has the perms 0777 by default\n\n 1 minor feature:\n\n   * Add umask param to the unix:// bind to set the umask\n\n## 1.0.0 / 2012-03-29\n\n* Released!\n\n## Ignore - this is for maintainers to copy-paste during release\n## Master\n\n* Features\n  * Your feature goes here (#Github Number)\n\n* Bugfixes\n  * Your bugfix goes here (#Github Number)\n", "#encoding: utf-8\n# frozen_string_literal: true\n\nmodule Puma\n  class UnsupportedOption < RuntimeError\n  end\n\n\n  # Every standard HTTP code mapped to the appropriate message.  These are\n  # used so frequently that they are placed directly in Puma for easy\n  # access rather than Puma::Const itself.\n\n  # Every standard HTTP code mapped to the appropriate message.\n  # Generated with:\n  # curl -s https://www.iana.org/assignments/http-status-codes/http-status-codes-1.csv | \\\n  #   ruby -ne 'm = /^(\\d{3}),(?!Unassigned|\\(Unused\\))([^,]+)/.match($_) and \\\n  #             puts \"#{m[1]} => \\x27#{m[2].strip}\\x27,\"'\n  HTTP_STATUS_CODES = {\n    100 => 'Continue',\n    101 => 'Switching Protocols',\n    102 => 'Processing',\n    200 => 'OK',\n    201 => 'Created',\n    202 => 'Accepted',\n    203 => 'Non-Authoritative Information',\n    204 => 'No Content',\n    205 => 'Reset Content',\n    206 => 'Partial Content',\n    207 => 'Multi-Status',\n    208 => 'Already Reported',\n    226 => 'IM Used',\n    300 => 'Multiple Choices',\n    301 => 'Moved Permanently',\n    302 => 'Found',\n    303 => 'See Other',\n    304 => 'Not Modified',\n    305 => 'Use Proxy',\n    307 => 'Temporary Redirect',\n    308 => 'Permanent Redirect',\n    400 => 'Bad Request',\n    401 => 'Unauthorized',\n    402 => 'Payment Required',\n    403 => 'Forbidden',\n    404 => 'Not Found',\n    405 => 'Method Not Allowed',\n    406 => 'Not Acceptable',\n    407 => 'Proxy Authentication Required',\n    408 => 'Request Timeout',\n    409 => 'Conflict',\n    410 => 'Gone',\n    411 => 'Length Required',\n    412 => 'Precondition Failed',\n    413 => 'Payload Too Large',\n    414 => 'URI Too Long',\n    415 => 'Unsupported Media Type',\n    416 => 'Range Not Satisfiable',\n    417 => 'Expectation Failed',\n    418 => 'I\\'m A Teapot',\n    421 => 'Misdirected Request',\n    422 => 'Unprocessable Entity',\n    423 => 'Locked',\n    424 => 'Failed Dependency',\n    426 => 'Upgrade Required',\n    428 => 'Precondition Required',\n    429 => 'Too Many Requests',\n    431 => 'Request Header Fields Too Large',\n    451 => 'Unavailable For Legal Reasons',\n    500 => 'Internal Server Error',\n    501 => 'Not Implemented',\n    502 => 'Bad Gateway',\n    503 => 'Service Unavailable',\n    504 => 'Gateway Timeout',\n    505 => 'HTTP Version Not Supported',\n    506 => 'Variant Also Negotiates',\n    507 => 'Insufficient Storage',\n    508 => 'Loop Detected',\n    510 => 'Not Extended',\n    511 => 'Network Authentication Required'\n  }\n\n  # For some HTTP status codes the client only expects headers.\n  #\n\n  STATUS_WITH_NO_ENTITY_BODY = {\n    204 => true,\n    205 => true,\n    304 => true\n  }\n\n  # Frequently used constants when constructing requests or responses.  Many times\n  # the constant just refers to a string with the same contents.  Using these constants\n  # gave about a 3% to 10% performance improvement over using the strings directly.\n  #\n  # The constants are frozen because Hash#[]= when called with a String key dups\n  # the String UNLESS the String is frozen. This saves us therefore 2 object\n  # allocations when creating the env hash later.\n  #\n  # While Puma does try to emulate the CGI/1.2 protocol, it does not use the REMOTE_IDENT,\n  # REMOTE_USER, or REMOTE_HOST parameters since those are either a security problem or\n  # too taxing on performance.\n  module Const\n\n    PUMA_VERSION = VERSION = \"4.3.2\".freeze\n    CODE_NAME = \"Mysterious Traveller\".freeze\n    PUMA_SERVER_STRING = ['puma', PUMA_VERSION, CODE_NAME].join(' ').freeze\n\n    FAST_TRACK_KA_TIMEOUT = 0.2\n\n    # The default number of seconds for another request within a persistent\n    # session.\n    PERSISTENT_TIMEOUT = 20\n\n    # The default number of seconds to wait until we get the first data\n    # for the request\n    FIRST_DATA_TIMEOUT = 30\n\n    # How long to wait when getting some write blocking on the socket when\n    # sending data back\n    WRITE_TIMEOUT = 10\n\n    # How many requests to attempt inline before sending a client back to\n    # the reactor to be subject to normal ordering. The idea here is that\n    # we amortize the cost of going back to the reactor for a well behaved\n    # but very \"greedy\" client across 10 requests. This prevents a not\n    # well behaved client from monopolizing the thread forever.\n    MAX_FAST_INLINE = 10\n\n    # The original URI requested by the client.\n    REQUEST_URI= 'REQUEST_URI'.freeze\n    REQUEST_PATH = 'REQUEST_PATH'.freeze\n    QUERY_STRING = 'QUERY_STRING'.freeze\n    CONTENT_LENGTH = \"CONTENT_LENGTH\".freeze\n\n    PATH_INFO = 'PATH_INFO'.freeze\n\n    PUMA_TMP_BASE = \"puma\".freeze\n\n    ERROR_RESPONSE = {\n      # Indicate that we couldn't parse the request\n      400 => \"HTTP/1.1 400 Bad Request\\r\\n\\r\\n\".freeze,\n      # The standard empty 404 response for bad requests.  Use Error4040Handler for custom stuff.\n      404 => \"HTTP/1.1 404 Not Found\\r\\nConnection: close\\r\\nServer: Puma #{PUMA_VERSION}\\r\\n\\r\\nNOT FOUND\".freeze,\n      # The standard empty 408 response for requests that timed out.\n      408 => \"HTTP/1.1 408 Request Timeout\\r\\nConnection: close\\r\\nServer: Puma #{PUMA_VERSION}\\r\\n\\r\\n\".freeze,\n      # Indicate that there was an internal error, obviously.\n      500 => \"HTTP/1.1 500 Internal Server Error\\r\\n\\r\\n\".freeze,\n      # A common header for indicating the server is too busy.  Not used yet.\n      503 => \"HTTP/1.1 503 Service Unavailable\\r\\n\\r\\nBUSY\".freeze\n    }\n\n    # The basic max request size we'll try to read.\n    CHUNK_SIZE = 16 * 1024\n\n    # This is the maximum header that is allowed before a client is booted.  The parser detects\n    # this, but we'd also like to do this as well.\n    MAX_HEADER = 1024 * (80 + 32)\n\n    # Maximum request body size before it is moved out of memory and into a tempfile for reading.\n    MAX_BODY = MAX_HEADER\n\n    REQUEST_METHOD = \"REQUEST_METHOD\".freeze\n    HEAD = \"HEAD\".freeze\n    # ETag is based on the apache standard of hex mtime-size-inode (inode is 0 on win32)\n    LINE_END = \"\\r\\n\".freeze\n    REMOTE_ADDR = \"REMOTE_ADDR\".freeze\n    HTTP_X_FORWARDED_FOR = \"HTTP_X_FORWARDED_FOR\".freeze\n    HTTP_X_FORWARDED_SSL = \"HTTP_X_FORWARDED_SSL\".freeze\n    HTTP_X_FORWARDED_SCHEME = \"HTTP_X_FORWARDED_SCHEME\".freeze\n    HTTP_X_FORWARDED_PROTO = \"HTTP_X_FORWARDED_PROTO\".freeze\n\n    SERVER_NAME = \"SERVER_NAME\".freeze\n    SERVER_PORT = \"SERVER_PORT\".freeze\n    HTTP_HOST = \"HTTP_HOST\".freeze\n    PORT_80 = \"80\".freeze\n    PORT_443 = \"443\".freeze\n    LOCALHOST = \"localhost\".freeze\n    LOCALHOST_IP = \"127.0.0.1\".freeze\n    LOCALHOST_ADDR = \"127.0.0.1:0\".freeze\n\n    SERVER_PROTOCOL = \"SERVER_PROTOCOL\".freeze\n    HTTP_11 = \"HTTP/1.1\".freeze\n\n    SERVER_SOFTWARE = \"SERVER_SOFTWARE\".freeze\n    GATEWAY_INTERFACE = \"GATEWAY_INTERFACE\".freeze\n    CGI_VER = \"CGI/1.2\".freeze\n\n    STOP_COMMAND = \"?\".freeze\n    HALT_COMMAND = \"!\".freeze\n    RESTART_COMMAND = \"R\".freeze\n\n    RACK_INPUT = \"rack.input\".freeze\n    RACK_URL_SCHEME = \"rack.url_scheme\".freeze\n    RACK_AFTER_REPLY = \"rack.after_reply\".freeze\n    PUMA_SOCKET = \"puma.socket\".freeze\n    PUMA_CONFIG = \"puma.config\".freeze\n    PUMA_PEERCERT = \"puma.peercert\".freeze\n\n    HTTP = \"http\".freeze\n    HTTPS = \"https\".freeze\n\n    HTTPS_KEY = \"HTTPS\".freeze\n\n    HTTP_VERSION = \"HTTP_VERSION\".freeze\n    HTTP_CONNECTION = \"HTTP_CONNECTION\".freeze\n    HTTP_EXPECT = \"HTTP_EXPECT\".freeze\n    CONTINUE = \"100-continue\".freeze\n\n    HTTP_11_100 = \"HTTP/1.1 100 Continue\\r\\n\\r\\n\".freeze\n    HTTP_11_200 = \"HTTP/1.1 200 OK\\r\\n\".freeze\n    HTTP_10_200 = \"HTTP/1.0 200 OK\\r\\n\".freeze\n\n    CLOSE = \"close\".freeze\n    KEEP_ALIVE = \"keep-alive\".freeze\n\n    CONTENT_LENGTH2 = \"content-length\".freeze\n    CONTENT_LENGTH_S = \"Content-Length: \".freeze\n    TRANSFER_ENCODING = \"transfer-encoding\".freeze\n    TRANSFER_ENCODING2 = \"HTTP_TRANSFER_ENCODING\".freeze\n\n    CONNECTION_CLOSE = \"Connection: close\\r\\n\".freeze\n    CONNECTION_KEEP_ALIVE = \"Connection: Keep-Alive\\r\\n\".freeze\n\n    TRANSFER_ENCODING_CHUNKED = \"Transfer-Encoding: chunked\\r\\n\".freeze\n    CLOSE_CHUNKED = \"0\\r\\n\\r\\n\".freeze\n\n    CHUNKED = \"chunked\".freeze\n\n    COLON = \": \".freeze\n\n    NEWLINE = \"\\n\".freeze\n    HTTP_INJECTION_REGEX = /[\\r\\n]/.freeze\n\n    HIJACK_P = \"rack.hijack?\".freeze\n    HIJACK = \"rack.hijack\".freeze\n    HIJACK_IO = \"rack.hijack_io\".freeze\n\n    EARLY_HINTS = \"rack.early_hints\".freeze\n\n    # Mininum interval to checks worker health\n    WORKER_CHECK_INTERVAL = 5\n\n  end\nend\n", "# frozen_string_literal: true\n\nrequire 'stringio'\n\nrequire 'puma/thread_pool'\nrequire 'puma/const'\nrequire 'puma/events'\nrequire 'puma/null_io'\nrequire 'puma/reactor'\nrequire 'puma/client'\nrequire 'puma/binder'\nrequire 'puma/accept_nonblock'\nrequire 'puma/util'\nrequire 'puma/io_buffer'\n\nrequire 'puma/puma_http11'\n\nrequire 'socket'\nrequire 'forwardable'\n\nmodule Puma\n\n  # The HTTP Server itself. Serves out a single Rack app.\n  #\n  # This class is used by the `Puma::Single` and `Puma::Cluster` classes\n  # to generate one or more `Puma::Server` instances capable of handling requests.\n  # Each Puma process will contain one `Puma::Server` instance.\n  #\n  # The `Puma::Server` instance pulls requests from the socket, adds them to a\n  # `Puma::Reactor` where they get eventually passed to a `Puma::ThreadPool`.\n  #\n  # Each `Puma::Server` will have one reactor and one thread pool.\n  class Server\n\n    include Puma::Const\n    extend Forwardable\n\n    attr_reader :thread\n    attr_reader :events\n    attr_reader :requests_count\n    attr_accessor :app\n\n    attr_accessor :min_threads\n    attr_accessor :max_threads\n    attr_accessor :persistent_timeout\n    attr_accessor :auto_trim_time\n    attr_accessor :reaping_time\n    attr_accessor :first_data_timeout\n\n    # Create a server for the rack app +app+.\n    #\n    # +events+ is an object which will be called when certain error events occur\n    # to be handled. See Puma::Events for the list of current methods to implement.\n    #\n    # Server#run returns a thread that you can join on to wait for the server\n    # to do its work.\n    #\n    def initialize(app, events=Events.stdio, options={})\n      @app = app\n      @events = events\n\n      @check, @notify = Puma::Util.pipe\n\n      @status = :stop\n\n      @min_threads = 0\n      @max_threads = 16\n      @auto_trim_time = 30\n      @reaping_time = 1\n\n      @thread = nil\n      @thread_pool = nil\n      @early_hints = nil\n\n      @persistent_timeout = options.fetch(:persistent_timeout, PERSISTENT_TIMEOUT)\n      @first_data_timeout = options.fetch(:first_data_timeout, FIRST_DATA_TIMEOUT)\n\n      @binder = Binder.new(events)\n\n      @leak_stack_on_error = true\n\n      @options = options\n      @queue_requests = options[:queue_requests].nil? ? true : options[:queue_requests]\n\n      ENV['RACK_ENV'] ||= \"development\"\n\n      @mode = :http\n\n      @precheck_closing = true\n\n      @requests_count = 0\n    end\n\n    attr_accessor :binder, :leak_stack_on_error, :early_hints\n\n    def_delegators :@binder, :add_tcp_listener, :add_ssl_listener, :add_unix_listener, :connected_ports\n\n    def inherit_binder(bind)\n      @binder = bind\n    end\n\n    def tcp_mode!\n      @mode = :tcp\n    end\n\n    # On Linux, use TCP_CORK to better control how the TCP stack\n    # packetizes our stream. This improves both latency and throughput.\n    #\n    if RUBY_PLATFORM =~ /linux/\n      UNPACK_TCP_STATE_FROM_TCP_INFO = \"C\".freeze\n\n      # 6 == Socket::IPPROTO_TCP\n      # 3 == TCP_CORK\n      # 1/0 == turn on/off\n      def cork_socket(socket)\n        begin\n          socket.setsockopt(6, 3, 1) if socket.kind_of? TCPSocket\n        rescue IOError, SystemCallError\n          Thread.current.purge_interrupt_queue if Thread.current.respond_to? :purge_interrupt_queue\n        end\n      end\n\n      def uncork_socket(socket)\n        begin\n          socket.setsockopt(6, 3, 0) if socket.kind_of? TCPSocket\n        rescue IOError, SystemCallError\n          Thread.current.purge_interrupt_queue if Thread.current.respond_to? :purge_interrupt_queue\n        end\n      end\n\n      def closed_socket?(socket)\n        return false unless socket.kind_of? TCPSocket\n        return false unless @precheck_closing\n\n        begin\n          tcp_info = socket.getsockopt(Socket::SOL_TCP, Socket::TCP_INFO)\n        rescue IOError, SystemCallError\n          Thread.current.purge_interrupt_queue if Thread.current.respond_to? :purge_interrupt_queue\n          @precheck_closing = false\n          false\n        else\n          state = tcp_info.unpack(UNPACK_TCP_STATE_FROM_TCP_INFO)[0]\n          # TIME_WAIT: 6, CLOSE: 7, CLOSE_WAIT: 8, LAST_ACK: 9, CLOSING: 11\n          (state >= 6 && state <= 9) || state == 11\n        end\n      end\n    else\n      def cork_socket(socket)\n      end\n\n      def uncork_socket(socket)\n      end\n\n      def closed_socket?(socket)\n        false\n      end\n    end\n\n    def backlog\n      @thread_pool and @thread_pool.backlog\n    end\n\n    def running\n      @thread_pool and @thread_pool.spawned\n    end\n\n\n    # This number represents the number of requests that\n    # the server is capable of taking right now.\n    #\n    # For example if the number is 5 then it means\n    # there are 5 threads sitting idle ready to take\n    # a request. If one request comes in, then the\n    # value would be 4 until it finishes processing.\n    def pool_capacity\n      @thread_pool and @thread_pool.pool_capacity\n    end\n\n    # Lopez Mode == raw tcp apps\n\n    def run_lopez_mode(background=true)\n      @thread_pool = ThreadPool.new(@min_threads,\n                                    @max_threads,\n                                    Hash) do |client, tl|\n\n        io = client.to_io\n        addr = io.peeraddr.last\n\n        if addr.empty?\n          # Set unix socket addrs to localhost\n          addr = \"127.0.0.1:0\"\n        else\n          addr = \"#{addr}:#{io.peeraddr[1]}\"\n        end\n\n        env = { 'thread' => tl, REMOTE_ADDR => addr }\n\n        begin\n          @app.call env, client.to_io\n        rescue Object => e\n          STDERR.puts \"! Detected exception at toplevel: #{e.message} (#{e.class})\"\n          STDERR.puts e.backtrace\n        end\n\n        client.close unless env['detach']\n      end\n\n      @events.fire :state, :running\n\n      if background\n        @thread = Thread.new do\n          Puma.set_thread_name \"server\"\n          handle_servers_lopez_mode\n        end\n        return @thread\n      else\n        handle_servers_lopez_mode\n      end\n    end\n\n    def handle_servers_lopez_mode\n      begin\n        check = @check\n        sockets = [check] + @binder.ios\n        pool = @thread_pool\n\n        while @status == :run\n          begin\n            ios = IO.select sockets\n            ios.first.each do |sock|\n              if sock == check\n                break if handle_check\n              else\n                begin\n                  if io = sock.accept_nonblock\n                    client = Client.new io, nil\n                    pool << client\n                  end\n                rescue SystemCallError\n                  # nothing\n                rescue Errno::ECONNABORTED\n                  # client closed the socket even before accept\n                  begin\n                    io.close\n                  rescue\n                    Thread.current.purge_interrupt_queue if Thread.current.respond_to? :purge_interrupt_queue\n                  end\n                end\n              end\n            end\n          rescue Object => e\n            @events.unknown_error self, e, \"Listen loop\"\n          end\n        end\n\n        @events.fire :state, @status\n\n        graceful_shutdown if @status == :stop || @status == :restart\n\n      rescue Exception => e\n        STDERR.puts \"Exception handling servers: #{e.message} (#{e.class})\"\n        STDERR.puts e.backtrace\n      ensure\n        begin\n          @check.close\n        rescue\n          Thread.current.purge_interrupt_queue if Thread.current.respond_to? :purge_interrupt_queue\n        end\n\n        # Prevent can't modify frozen IOError (RuntimeError)\n        begin\n          @notify.close\n        rescue IOError\n          # no biggy\n        end\n      end\n\n      @events.fire :state, :done\n    end\n    # Runs the server.\n    #\n    # If +background+ is true (the default) then a thread is spun\n    # up in the background to handle requests. Otherwise requests\n    # are handled synchronously.\n    #\n    def run(background=true)\n      BasicSocket.do_not_reverse_lookup = true\n\n      @events.fire :state, :booting\n\n      @status = :run\n\n      if @mode == :tcp\n        return run_lopez_mode(background)\n      end\n\n      queue_requests = @queue_requests\n\n      @thread_pool = ThreadPool.new(@min_threads,\n                                    @max_threads,\n                                    ::Puma::IOBuffer) do |client, buffer|\n\n        # Advertise this server into the thread\n        Thread.current[ThreadLocalKey] = self\n\n        process_now = false\n\n        begin\n          if queue_requests\n            process_now = client.eagerly_finish\n          else\n            client.finish(@first_data_timeout)\n            process_now = true\n          end\n        rescue MiniSSL::SSLError => e\n          ssl_socket = client.io\n          addr = ssl_socket.peeraddr.last\n          cert = ssl_socket.peercert\n\n          client.close\n\n          @events.ssl_error self, addr, cert, e\n        rescue HttpParserError => e\n          client.write_error(400)\n          client.close\n\n          @events.parse_error self, client.env, e\n        rescue ConnectionError, EOFError\n          client.close\n        else\n          if process_now\n            process_client client, buffer\n          else\n            client.set_timeout @first_data_timeout\n            @reactor.add client\n          end\n        end\n      end\n\n      @thread_pool.clean_thread_locals = @options[:clean_thread_locals]\n\n      if queue_requests\n        @reactor = Reactor.new self, @thread_pool\n        @reactor.run_in_thread\n      end\n\n      if @reaping_time\n        @thread_pool.auto_reap!(@reaping_time)\n      end\n\n      if @auto_trim_time\n        @thread_pool.auto_trim!(@auto_trim_time)\n      end\n\n      @events.fire :state, :running\n\n      if background\n        @thread = Thread.new do\n          Puma.set_thread_name \"server\"\n          handle_servers\n        end\n        return @thread\n      else\n        handle_servers\n      end\n    end\n\n    def handle_servers\n      begin\n        check = @check\n        sockets = [check] + @binder.ios\n        pool = @thread_pool\n        queue_requests = @queue_requests\n\n        remote_addr_value = nil\n        remote_addr_header = nil\n\n        case @options[:remote_address]\n        when :value\n          remote_addr_value = @options[:remote_address_value]\n        when :header\n          remote_addr_header = @options[:remote_address_header]\n        end\n\n        while @status == :run\n          begin\n            ios = IO.select sockets\n            ios.first.each do |sock|\n              if sock == check\n                break if handle_check\n              else\n                begin\n                  if io = sock.accept_nonblock\n                    client = Client.new io, @binder.env(sock)\n                    if remote_addr_value\n                      client.peerip = remote_addr_value\n                    elsif remote_addr_header\n                      client.remote_addr_header = remote_addr_header\n                    end\n\n                    pool << client\n                    busy_threads = pool.wait_until_not_full\n                    if busy_threads == 0\n                      @options[:out_of_band].each(&:call) if @options[:out_of_band]\n                    end\n                  end\n                rescue SystemCallError\n                  # nothing\n                rescue Errno::ECONNABORTED\n                  # client closed the socket even before accept\n                  begin\n                    io.close\n                  rescue\n                    Thread.current.purge_interrupt_queue if Thread.current.respond_to? :purge_interrupt_queue\n                  end\n                end\n              end\n            end\n          rescue Object => e\n            @events.unknown_error self, e, \"Listen loop\"\n          end\n        end\n\n        @events.fire :state, @status\n\n        graceful_shutdown if @status == :stop || @status == :restart\n        if queue_requests\n          @reactor.clear!\n          @reactor.shutdown\n        end\n      rescue Exception => e\n        STDERR.puts \"Exception handling servers: #{e.message} (#{e.class})\"\n        STDERR.puts e.backtrace\n      ensure\n        @check.close\n        @notify.close\n      end\n\n      @events.fire :state, :done\n    end\n\n    # :nodoc:\n    def handle_check\n      cmd = @check.read(1)\n\n      case cmd\n      when STOP_COMMAND\n        @status = :stop\n        return true\n      when HALT_COMMAND\n        @status = :halt\n        return true\n      when RESTART_COMMAND\n        @status = :restart\n        return true\n      end\n\n      return false\n    end\n\n    # Given a connection on +client+, handle the incoming requests.\n    #\n    # This method support HTTP Keep-Alive so it may, depending on if the client\n    # indicates that it supports keep alive, wait for another request before\n    # returning.\n    #\n    def process_client(client, buffer)\n      begin\n\n        clean_thread_locals = @options[:clean_thread_locals]\n        close_socket = true\n\n        requests = 0\n\n        while true\n          case handle_request(client, buffer)\n          when false\n            return\n          when :async\n            close_socket = false\n            return\n          when true\n            return unless @queue_requests\n            buffer.reset\n\n            ThreadPool.clean_thread_locals if clean_thread_locals\n\n            requests += 1\n\n            check_for_more_data = @status == :run\n\n            if requests >= MAX_FAST_INLINE\n              # This will mean that reset will only try to use the data it already\n              # has buffered and won't try to read more data. What this means is that\n              # every client, independent of their request speed, gets treated like a slow\n              # one once every MAX_FAST_INLINE requests.\n              check_for_more_data = false\n            end\n\n            unless client.reset(check_for_more_data)\n              close_socket = false\n              client.set_timeout @persistent_timeout\n              @reactor.add client\n              return\n            end\n          end\n        end\n\n      # The client disconnected while we were reading data\n      rescue ConnectionError\n        # Swallow them. The ensure tries to close +client+ down\n\n      # SSL handshake error\n      rescue MiniSSL::SSLError => e\n        lowlevel_error(e, client.env)\n\n        ssl_socket = client.io\n        addr = ssl_socket.peeraddr.last\n        cert = ssl_socket.peercert\n\n        close_socket = true\n\n        @events.ssl_error self, addr, cert, e\n\n      # The client doesn't know HTTP well\n      rescue HttpParserError => e\n        lowlevel_error(e, client.env)\n\n        client.write_error(400)\n\n        @events.parse_error self, client.env, e\n\n      # Server error\n      rescue StandardError => e\n        lowlevel_error(e, client.env)\n\n        client.write_error(500)\n\n        @events.unknown_error self, e, \"Read\"\n\n      ensure\n        buffer.reset\n\n        begin\n          client.close if close_socket\n        rescue IOError, SystemCallError\n          Thread.current.purge_interrupt_queue if Thread.current.respond_to? :purge_interrupt_queue\n          # Already closed\n        rescue StandardError => e\n          @events.unknown_error self, e, \"Client\"\n        end\n      end\n    end\n\n    # Given a Hash +env+ for the request read from +client+, add\n    # and fixup keys to comply with Rack's env guidelines.\n    #\n    def normalize_env(env, client)\n      if host = env[HTTP_HOST]\n        if colon = host.index(\":\")\n          env[SERVER_NAME] = host[0, colon]\n          env[SERVER_PORT] = host[colon+1, host.bytesize]\n        else\n          env[SERVER_NAME] = host\n          env[SERVER_PORT] = default_server_port(env)\n        end\n      else\n        env[SERVER_NAME] = LOCALHOST\n        env[SERVER_PORT] = default_server_port(env)\n      end\n\n      unless env[REQUEST_PATH]\n        # it might be a dumbass full host request header\n        uri = URI.parse(env[REQUEST_URI])\n        env[REQUEST_PATH] = uri.path\n\n        raise \"No REQUEST PATH\" unless env[REQUEST_PATH]\n\n        # A nil env value will cause a LintError (and fatal errors elsewhere),\n        # so only set the env value if there actually is a value.\n        env[QUERY_STRING] = uri.query if uri.query\n      end\n\n      env[PATH_INFO] = env[REQUEST_PATH]\n\n      # From http://www.ietf.org/rfc/rfc3875 :\n      # \"Script authors should be aware that the REMOTE_ADDR and\n      # REMOTE_HOST meta-variables (see sections 4.1.8 and 4.1.9)\n      # may not identify the ultimate source of the request.\n      # They identify the client for the immediate request to the\n      # server; that client may be a proxy, gateway, or other\n      # intermediary acting on behalf of the actual source client.\"\n      #\n\n      unless env.key?(REMOTE_ADDR)\n        begin\n          addr = client.peerip\n        rescue Errno::ENOTCONN\n          # Client disconnects can result in an inability to get the\n          # peeraddr from the socket; default to localhost.\n          addr = LOCALHOST_IP\n        end\n\n        # Set unix socket addrs to localhost\n        addr = LOCALHOST_IP if addr.empty?\n\n        env[REMOTE_ADDR] = addr\n      end\n    end\n\n    def default_server_port(env)\n      if ['on', HTTPS].include?(env[HTTPS_KEY]) || env[HTTP_X_FORWARDED_PROTO].to_s[0...5] == HTTPS || env[HTTP_X_FORWARDED_SCHEME] == HTTPS || env[HTTP_X_FORWARDED_SSL] == \"on\"\n        PORT_443\n      else\n        PORT_80\n      end\n    end\n\n    # Takes the request +req+, invokes the Rack application to construct\n    # the response and writes it back to +req.io+.\n    #\n    # The second parameter +lines+ is a IO-like object unique to this thread.\n    # This is normally an instance of Puma::IOBuffer.\n    #\n    # It'll return +false+ when the connection is closed, this doesn't mean\n    # that the response wasn't successful.\n    #\n    # It'll return +:async+ if the connection remains open but will be handled\n    # elsewhere, i.e. the connection has been hijacked by the Rack application.\n    #\n    # Finally, it'll return +true+ on keep-alive connections.\n    def handle_request(req, lines)\n      @requests_count +=1\n\n      env = req.env\n      client = req.io\n\n      return false if closed_socket?(client)\n\n      normalize_env env, req\n\n      env[PUMA_SOCKET] = client\n\n      if env[HTTPS_KEY] && client.peercert\n        env[PUMA_PEERCERT] = client.peercert\n      end\n\n      env[HIJACK_P] = true\n      env[HIJACK] = req\n\n      body = req.body\n\n      head = env[REQUEST_METHOD] == HEAD\n\n      env[RACK_INPUT] = body\n      env[RACK_URL_SCHEME] = default_server_port(env) == PORT_443 ? HTTPS : HTTP\n\n      if @early_hints\n        env[EARLY_HINTS] = lambda { |headers|\n          begin\n            fast_write client, \"HTTP/1.1 103 Early Hints\\r\\n\".freeze\n\n            headers.each_pair do |k, vs|\n              if vs.respond_to?(:to_s) && !vs.to_s.empty?\n                vs.to_s.split(NEWLINE).each do |v|\n                  next if possible_header_injection?(v)\n                  fast_write client, \"#{k}: #{v}\\r\\n\"\n                end\n              else\n                fast_write client, \"#{k}: #{vs}\\r\\n\"\n              end\n            end\n\n            fast_write client, \"\\r\\n\".freeze\n          rescue ConnectionError\n            # noop, if we lost the socket we just won't send the early hints\n          end\n        }\n      end\n\n      # A rack extension. If the app writes #call'ables to this\n      # array, we will invoke them when the request is done.\n      #\n      after_reply = env[RACK_AFTER_REPLY] = []\n\n      begin\n        begin\n          status, headers, res_body = @app.call(env)\n\n          return :async if req.hijacked\n\n          status = status.to_i\n\n          if status == -1\n            unless headers.empty? and res_body == []\n              raise \"async response must have empty headers and body\"\n            end\n\n            return :async\n          end\n        rescue ThreadPool::ForceShutdown => e\n          @events.log \"Detected force shutdown of a thread, returning 503\"\n          @events.unknown_error self, e, \"Rack app\"\n\n          status = 503\n          headers = {}\n          res_body = [\"Request was internally terminated early\\n\"]\n\n        rescue Exception => e\n          @events.unknown_error self, e, \"Rack app\", env\n\n          status, headers, res_body = lowlevel_error(e, env)\n        end\n\n        content_length = nil\n        no_body = head\n\n        if res_body.kind_of? Array and res_body.size == 1\n          content_length = res_body[0].bytesize\n        end\n\n        cork_socket client\n\n        line_ending = LINE_END\n        colon = COLON\n\n        http_11 = if env[HTTP_VERSION] == HTTP_11\n          allow_chunked = true\n          keep_alive = env.fetch(HTTP_CONNECTION, \"\").downcase != CLOSE\n          include_keepalive_header = false\n\n          # An optimization. The most common response is 200, so we can\n          # reply with the proper 200 status without having to compute\n          # the response header.\n          #\n          if status == 200\n            lines << HTTP_11_200\n          else\n            lines.append \"HTTP/1.1 \", status.to_s, \" \",\n                         fetch_status_code(status), line_ending\n\n            no_body ||= status < 200 || STATUS_WITH_NO_ENTITY_BODY[status]\n          end\n          true\n        else\n          allow_chunked = false\n          keep_alive = env.fetch(HTTP_CONNECTION, \"\").downcase == KEEP_ALIVE\n          include_keepalive_header = keep_alive\n\n          # Same optimization as above for HTTP/1.1\n          #\n          if status == 200\n            lines << HTTP_10_200\n          else\n            lines.append \"HTTP/1.0 \", status.to_s, \" \",\n                         fetch_status_code(status), line_ending\n\n            no_body ||= status < 200 || STATUS_WITH_NO_ENTITY_BODY[status]\n          end\n          false\n        end\n\n        response_hijack = nil\n\n        headers.each do |k, vs|\n          case k.downcase\n          when CONTENT_LENGTH2\n            next if possible_header_injection?(vs)\n            content_length = vs\n            next\n          when TRANSFER_ENCODING\n            allow_chunked = false\n            content_length = nil\n          when HIJACK\n            response_hijack = vs\n            next\n          end\n\n          if vs.respond_to?(:to_s) && !vs.to_s.empty?\n            vs.to_s.split(NEWLINE).each do |v|\n              next if possible_header_injection?(v)\n              lines.append k, colon, v, line_ending\n            end\n          else\n            lines.append k, colon, line_ending\n          end\n        end\n\n        if include_keepalive_header\n          lines << CONNECTION_KEEP_ALIVE\n        elsif http_11 && !keep_alive\n          lines << CONNECTION_CLOSE\n        end\n\n        if no_body\n          if content_length and status != 204\n            lines.append CONTENT_LENGTH_S, content_length.to_s, line_ending\n          end\n\n          lines << line_ending\n          fast_write client, lines.to_s\n          return keep_alive\n        end\n\n        if content_length\n          lines.append CONTENT_LENGTH_S, content_length.to_s, line_ending\n          chunked = false\n        elsif !response_hijack and allow_chunked\n          lines << TRANSFER_ENCODING_CHUNKED\n          chunked = true\n        end\n\n        lines << line_ending\n\n        fast_write client, lines.to_s\n\n        if response_hijack\n          response_hijack.call client\n          return :async\n        end\n\n        begin\n          res_body.each do |part|\n            next if part.bytesize.zero?\n            if chunked\n              fast_write client, part.bytesize.to_s(16)\n              fast_write client, line_ending\n              fast_write client, part\n              fast_write client, line_ending\n            else\n              fast_write client, part\n            end\n\n            client.flush\n          end\n\n          if chunked\n            fast_write client, CLOSE_CHUNKED\n            client.flush\n          end\n        rescue SystemCallError, IOError\n          raise ConnectionError, \"Connection error detected during write\"\n        end\n\n      ensure\n        uncork_socket client\n\n        body.close\n        req.tempfile.unlink if req.tempfile\n        res_body.close if res_body.respond_to? :close\n\n        after_reply.each { |o| o.call }\n      end\n\n      return keep_alive\n    end\n\n    def fetch_status_code(status)\n      HTTP_STATUS_CODES.fetch(status) { 'CUSTOM' }\n    end\n    private :fetch_status_code\n\n    # Given the request +env+ from +client+ and the partial body +body+\n    # plus a potential Content-Length value +cl+, finish reading\n    # the body and return it.\n    #\n    # If the body is larger than MAX_BODY, a Tempfile object is used\n    # for the body, otherwise a StringIO is used.\n    #\n    def read_body(env, client, body, cl)\n      content_length = cl.to_i\n\n      remain = content_length - body.bytesize\n\n      return StringIO.new(body) if remain <= 0\n\n      # Use a Tempfile if there is a lot of data left\n      if remain > MAX_BODY\n        stream = Tempfile.new(Const::PUMA_TMP_BASE)\n        stream.binmode\n      else\n        # The body[0,0] trick is to get an empty string in the same\n        # encoding as body.\n        stream = StringIO.new body[0,0]\n      end\n\n      stream.write body\n\n      # Read an odd sized chunk so we can read even sized ones\n      # after this\n      chunk = client.readpartial(remain % CHUNK_SIZE)\n\n      # No chunk means a closed socket\n      unless chunk\n        stream.close\n        return nil\n      end\n\n      remain -= stream.write(chunk)\n\n      # Raed the rest of the chunks\n      while remain > 0\n        chunk = client.readpartial(CHUNK_SIZE)\n        unless chunk\n          stream.close\n          return nil\n        end\n\n        remain -= stream.write(chunk)\n      end\n\n      stream.rewind\n\n      return stream\n    end\n\n    # A fallback rack response if +@app+ raises as exception.\n    #\n    def lowlevel_error(e, env)\n      if handler = @options[:lowlevel_error_handler]\n        if handler.arity == 1\n          return handler.call(e)\n        else\n          return handler.call(e, env)\n        end\n      end\n\n      if @leak_stack_on_error\n        [500, {}, [\"Puma caught this error: #{e.message} (#{e.class})\\n#{e.backtrace.join(\"\\n\")}\"]]\n      else\n        [500, {}, [\"An unhandled lowlevel error occurred. The application logs may have details.\\n\"]]\n      end\n    end\n\n    # Wait for all outstanding requests to finish.\n    #\n    def graceful_shutdown\n      if @options[:shutdown_debug]\n        threads = Thread.list\n        total = threads.size\n\n        pid = Process.pid\n\n        $stdout.syswrite \"#{pid}: === Begin thread backtrace dump ===\\n\"\n\n        threads.each_with_index do |t,i|\n          $stdout.syswrite \"#{pid}: Thread #{i+1}/#{total}: #{t.inspect}\\n\"\n          $stdout.syswrite \"#{pid}: #{t.backtrace.join(\"\\n#{pid}: \")}\\n\\n\"\n        end\n        $stdout.syswrite \"#{pid}: === End thread backtrace dump ===\\n\"\n      end\n\n      if @options[:drain_on_shutdown]\n        count = 0\n\n        while true\n          ios = IO.select @binder.ios, nil, nil, 0\n          break unless ios\n\n          ios.first.each do |sock|\n            begin\n              if io = sock.accept_nonblock\n                count += 1\n                client = Client.new io, @binder.env(sock)\n                @thread_pool << client\n              end\n            rescue SystemCallError\n            end\n          end\n        end\n\n        @events.debug \"Drained #{count} additional connections.\"\n      end\n\n      if @status != :restart\n        @binder.close\n      end\n\n      if @thread_pool\n        if timeout = @options[:force_shutdown_after]\n          @thread_pool.shutdown timeout.to_i\n        else\n          @thread_pool.shutdown\n        end\n      end\n    end\n\n    def notify_safely(message)\n      begin\n        @notify << message\n      rescue IOError\n         # The server, in another thread, is shutting down\n        Thread.current.purge_interrupt_queue if Thread.current.respond_to? :purge_interrupt_queue\n      rescue RuntimeError => e\n        # Temporary workaround for https://bugs.ruby-lang.org/issues/13239\n        if e.message.include?('IOError')\n          Thread.current.purge_interrupt_queue if Thread.current.respond_to? :purge_interrupt_queue\n        else\n          raise e\n        end\n      end\n    end\n    private :notify_safely\n\n    # Stops the acceptor thread and then causes the worker threads to finish\n    # off the request queue before finally exiting.\n\n    def stop(sync=false)\n      notify_safely(STOP_COMMAND)\n      @thread.join if @thread && sync\n    end\n\n    def halt(sync=false)\n      notify_safely(HALT_COMMAND)\n      @thread.join if @thread && sync\n    end\n\n    def begin_restart\n      notify_safely(RESTART_COMMAND)\n    end\n\n    def fast_write(io, str)\n      n = 0\n      while true\n        begin\n          n = io.syswrite str\n        rescue Errno::EAGAIN, Errno::EWOULDBLOCK\n          if !IO.select(nil, [io], nil, WRITE_TIMEOUT)\n            raise ConnectionError, \"Socket timeout writing data\"\n          end\n\n          retry\n        rescue  Errno::EPIPE, SystemCallError, IOError\n          raise ConnectionError, \"Socket timeout writing data\"\n        end\n\n        return if n == str.bytesize\n        str = str.byteslice(n..-1)\n      end\n    end\n    private :fast_write\n\n    ThreadLocalKey = :puma_server\n\n    def self.current\n      Thread.current[ThreadLocalKey]\n    end\n\n    def shutting_down?\n      @status == :stop || @status == :restart\n    end\n\n    def possible_header_injection?(header_value)\n      HTTP_INJECTION_REGEX =~ header_value.to_s\n    end\n    private :possible_header_injection?\n  end\nend\n", "require_relative \"helper\"\n\nclass TestPumaServer < Minitest::Test\n  parallelize_me!\n\n  def setup\n    @port = 0\n    @host = \"127.0.0.1\"\n\n    @ios = []\n\n    @app = ->(env) { [200, {}, [env['rack.url_scheme']]] }\n\n    @events = Puma::Events.strings\n    @server = Puma::Server.new @app, @events\n  end\n\n  def teardown\n    @server.stop(true)\n    @ios.each { |io| io.close if io && !io.closed? }\n  end\n\n  def server_run(app: @app, early_hints: false)\n    @server.app = app\n    @server.add_tcp_listener @host, @port\n    @server.early_hints = true if early_hints\n    @server.run\n  end\n\n  def header(sock)\n    header = []\n    while true\n      line = sock.gets\n      break if line == \"\\r\\n\"\n      header << line.strip\n    end\n\n    header\n  end\n\n  def send_http_and_read(req)\n    port = @server.connected_ports[0]\n    sock = TCPSocket.new @host, port\n    @ios << sock\n    sock << req\n    sock.read\n  end\n\n  def send_http(req)\n    port = @server.connected_ports[0]\n    sock = TCPSocket.new @host, port\n    @ios << sock\n    sock << req\n    sock\n  end\n\n  def test_proper_stringio_body\n    data = nil\n\n    server_run app: ->(env) do\n      data = env['rack.input'].read\n      [200, {}, [\"ok\"]]\n    end\n\n    fifteen = \"1\" * 15\n\n    sock = send_http \"PUT / HTTP/1.0\\r\\nContent-Length: 30\\r\\n\\r\\n#{fifteen}\"\n\n    sleep 0.1 # important so that the previous data is sent as a packet\n    sock << fifteen\n\n    sock.read\n\n    assert_equal \"#{fifteen}#{fifteen}\", data\n  end\n\n  def test_puma_socket\n    body = \"HTTP/1.1 750 Upgraded to Awesome\\r\\nDone: Yep!\\r\\n\"\n    server_run app: ->(env) do\n      io = env['puma.socket']\n      io.write body\n      io.close\n      [-1, {}, []]\n    end\n\n    data = send_http_and_read \"PUT / HTTP/1.0\\r\\n\\r\\nHello\"\n\n    assert_equal body, data\n  end\n\n  def test_very_large_return\n    giant = \"x\" * 2056610\n\n    server_run app: ->(env) do\n      [200, {}, [giant]]\n    end\n\n    sock = send_http \"GET / HTTP/1.0\\r\\n\\r\\n\"\n\n    while true\n      line = sock.gets\n      break if line == \"\\r\\n\"\n    end\n\n    out = sock.read\n\n    assert_equal giant.bytesize, out.bytesize\n  end\n\n  def test_respect_x_forwarded_proto\n    env = {}\n    env['HOST'] = \"example.com\"\n    env['HTTP_X_FORWARDED_PROTO'] = \"https,http\"\n\n    assert_equal \"443\", @server.default_server_port(env)\n  end\n\n  def test_respect_x_forwarded_ssl_on\n    env = {}\n    env['HOST'] = 'example.com'\n    env['HTTP_X_FORWARDED_SSL'] = 'on'\n\n    assert_equal \"443\", @server.default_server_port(env)\n  end\n\n  def test_respect_x_forwarded_scheme\n    env = {}\n    env['HOST'] = 'example.com'\n    env['HTTP_X_FORWARDED_SCHEME'] = 'https'\n\n    assert_equal '443', @server.default_server_port(env)\n  end\n\n  def test_default_server_port\n    server_run app: ->(env) do\n      [200, {}, [env['SERVER_PORT']]]\n    end\n\n    req = Net::HTTP::Get.new '/'\n    req['HOST'] = 'example.com'\n\n    port = @server.connected_ports[0]\n    res = Net::HTTP.start @host, port do |http|\n      http.request(req)\n    end\n\n    assert_equal \"80\", res.body\n  end\n\n  def test_default_server_port_respects_x_forwarded_proto\n    server_run app: ->(env) do\n      [200, {}, [env['SERVER_PORT']]]\n    end\n\n    req = Net::HTTP::Get.new(\"/\")\n    req['HOST'] = \"example.com\"\n    req['X_FORWARDED_PROTO'] = \"https,http\"\n\n    port = @server.connected_ports[0]\n    res = Net::HTTP.start @host, port do |http|\n      http.request(req)\n    end\n\n    assert_equal \"443\", res.body\n  end\n\n  def test_HEAD_has_no_body\n    server_run app: ->(env) { [200, {\"Foo\" => \"Bar\"}, [\"hello\"]] }\n\n    data = send_http_and_read \"HEAD / HTTP/1.0\\r\\n\\r\\n\"\n\n    assert_equal \"HTTP/1.0 200 OK\\r\\nFoo: Bar\\r\\nContent-Length: 5\\r\\n\\r\\n\", data\n  end\n\n  def test_GET_with_empty_body_has_sane_chunking\n    server_run app: ->(env) { [200, {}, [\"\"]] }\n\n    data = send_http_and_read \"HEAD / HTTP/1.0\\r\\n\\r\\n\"\n\n    assert_equal \"HTTP/1.0 200 OK\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n  end\n\n  def test_early_hints_works\n    server_run early_hints: true, app: ->(env) do\n     env['rack.early_hints'].call(\"Link\" => \"</style.css>; rel=preload; as=style\\n</script.js>; rel=preload\")\n     [200, { \"X-Hello\" => \"World\" }, [\"Hello world!\"]]\n    end\n\n    data = send_http_and_read \"HEAD / HTTP/1.0\\r\\n\\r\\n\"\n\n    expected_data = (<<EOF\nHTTP/1.1 103 Early Hints\nLink: </style.css>; rel=preload; as=style\nLink: </script.js>; rel=preload\n\nHTTP/1.0 200 OK\nX-Hello: World\nContent-Length: 12\nEOF\n).split(\"\\n\").join(\"\\r\\n\") + \"\\r\\n\\r\\n\"\n\n    assert_equal true, @server.early_hints\n    assert_equal expected_data, data\n  end\n\n  def test_early_hints_are_ignored_if_connection_lost\n\n    def @server.fast_write(*args)\n      raise Puma::ConnectionError\n    end\n\n    server_run early_hints: true, app: ->(env) do\n      env['rack.early_hints'].call(\"Link\" => \"</script.js>; rel=preload\")\n      [200, { \"X-Hello\" => \"World\" }, [\"Hello world!\"]]\n    end\n\n    # This request will cause the server to try and send early hints\n    _ = send_http \"HEAD / HTTP/1.0\\r\\n\\r\\n\"\n\n    # Give the server some time to try to write (and fail)\n    sleep 0.1\n\n    # Expect no errors in stderr\n    assert @events.stderr.pos.zero?, \"Server didn't swallow the connection error\"\n  end\n\n  def test_early_hints_is_off_by_default\n    server_run app: ->(env) do\n     assert_nil env['rack.early_hints']\n     [200, { \"X-Hello\" => \"World\" }, [\"Hello world!\"]]\n    end\n\n    data = send_http_and_read \"HEAD / HTTP/1.0\\r\\n\\r\\n\"\n\n    expected_data = (<<EOF\nHTTP/1.0 200 OK\nX-Hello: World\nContent-Length: 12\nEOF\n).split(\"\\n\").join(\"\\r\\n\") + \"\\r\\n\\r\\n\"\n\n    assert_nil @server.early_hints\n    assert_equal expected_data, data\n  end\n\n  def test_GET_with_no_body_has_sane_chunking\n    server_run app: ->(env) { [200, {}, []] }\n\n    data = send_http_and_read \"HEAD / HTTP/1.0\\r\\n\\r\\n\"\n\n    assert_equal \"HTTP/1.0 200 OK\\r\\n\\r\\n\", data\n  end\n\n  def test_doesnt_print_backtrace_in_production\n    @server.leak_stack_on_error = false\n    server_run app: ->(env) { raise \"don't leak me bro\" }\n\n    data = send_http_and_read \"GET / HTTP/1.0\\r\\n\\r\\n\"\n\n    refute_match(/don't leak me bro/, data)\n    assert_match(/HTTP\\/1.0 500 Internal Server Error/, data)\n  end\n\n  def test_prints_custom_error\n    re = lambda { |err| [302, {'Content-Type' => 'text', 'Location' => 'foo.html'}, ['302 found']] }\n    @server = Puma::Server.new @app, @events, {:lowlevel_error_handler => re}\n\n    server_run app: ->(env) { raise \"don't leak me bro\" }\n\n    data = send_http_and_read \"GET / HTTP/1.0\\r\\n\\r\\n\"\n\n    assert_match(/HTTP\\/1.0 302 Found/, data)\n  end\n\n  def test_leh_gets_env_as_well\n    re = lambda { |err,env|\n      env['REQUEST_PATH'] || raise('where is env?')\n      [302, {'Content-Type' => 'text', 'Location' => 'foo.html'}, ['302 found']]\n    }\n\n    @server = Puma::Server.new @app, @events, {:lowlevel_error_handler => re}\n\n    server_run app: ->(env) { raise \"don't leak me bro\" }\n\n    data = send_http_and_read \"GET / HTTP/1.0\\r\\n\\r\\n\"\n\n    assert_match(/HTTP\\/1.0 302 Found/, data)\n  end\n\n  def test_custom_http_codes_10\n    server_run app: ->(env) { [449, {}, [\"\"]] }\n\n    data = send_http_and_read \"GET / HTTP/1.0\\r\\n\\r\\n\"\n\n    assert_equal \"HTTP/1.0 449 CUSTOM\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n  end\n\n  def test_custom_http_codes_11\n    server_run app: ->(env) { [449, {}, [\"\"]] }\n\n    data = send_http_and_read \"GET / HTTP/1.1\\r\\nConnection: close\\r\\n\\r\\n\"\n\n    assert_equal \"HTTP/1.1 449 CUSTOM\\r\\nConnection: close\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n  end\n\n  def test_HEAD_returns_content_headers\n    server_run app: ->(env) { [200, {\"Content-Type\" => \"application/pdf\",\n                                     \"Content-Length\" => \"4242\"}, []] }\n\n    data = send_http_and_read \"HEAD / HTTP/1.0\\r\\n\\r\\n\"\n\n    assert_equal \"HTTP/1.0 200 OK\\r\\nContent-Type: application/pdf\\r\\nContent-Length: 4242\\r\\n\\r\\n\", data\n  end\n\n  def test_status_hook_fires_when_server_changes_states\n\n    states = []\n\n    @events.register(:state) { |s| states << s }\n\n    server_run app: ->(env) { [200, {}, [\"\"]] }\n\n    _ = send_http_and_read \"HEAD / HTTP/1.0\\r\\n\\r\\n\"\n\n    assert_equal [:booting, :running], states\n\n    @server.stop(true)\n\n    assert_equal [:booting, :running, :stop, :done], states\n  end\n\n  def test_timeout_in_data_phase\n    @server.first_data_timeout = 2\n    server_run\n\n    sock = send_http \"POST / HTTP/1.1\\r\\nHost: test.com\\r\\nContent-Type: text/plain\\r\\nContent-Length: 5\\r\\n\\r\\n\"\n\n    data = sock.gets\n\n    assert_equal \"HTTP/1.1 408 Request Timeout\\r\\n\", data\n  end\n\n  def test_timeout_data_no_queue\n    @server = Puma::Server.new @app, @events, queue_requests: false\n    test_timeout_in_data_phase\n  end\n\n  def test_http_11_keep_alive_with_body\n    server_run app: ->(env) { [200, {\"Content-Type\" => \"plain/text\"}, [\"hello\\n\"]] }\n\n    sock = send_http \"GET / HTTP/1.1\\r\\nConnection: Keep-Alive\\r\\n\\r\\n\"\n\n    h = header sock\n\n    body = sock.gets\n\n    assert_equal [\"HTTP/1.1 200 OK\", \"Content-Type: plain/text\", \"Content-Length: 6\"], h\n    assert_equal \"hello\\n\", body\n\n    sock.close\n  end\n\n  def test_http_11_close_with_body\n    server_run app: ->(env) { [200, {\"Content-Type\" => \"plain/text\"}, [\"hello\"]] }\n\n    data = send_http_and_read \"GET / HTTP/1.1\\r\\nConnection: close\\r\\n\\r\\n\"\n\n    assert_equal \"HTTP/1.1 200 OK\\r\\nContent-Type: plain/text\\r\\nConnection: close\\r\\nContent-Length: 5\\r\\n\\r\\nhello\", data\n  end\n\n  def test_http_11_keep_alive_without_body\n    server_run app: ->(env) { [204, {}, []] }\n\n    sock = send_http \"GET / HTTP/1.1\\r\\nConnection: Keep-Alive\\r\\n\\r\\n\"\n\n    h = header sock\n\n    assert_equal [\"HTTP/1.1 204 No Content\"], h\n  end\n\n  def test_http_11_close_without_body\n    server_run app: ->(env) { [204, {}, []] }\n\n    sock = send_http \"GET / HTTP/1.1\\r\\nConnection: close\\r\\n\\r\\n\"\n\n    h = header sock\n\n    assert_equal [\"HTTP/1.1 204 No Content\", \"Connection: close\"], h\n  end\n\n  def test_http_10_keep_alive_with_body\n    server_run app: ->(env) { [200, {\"Content-Type\" => \"plain/text\"}, [\"hello\\n\"]] }\n\n    sock = send_http \"GET / HTTP/1.0\\r\\nConnection: Keep-Alive\\r\\n\\r\\n\"\n\n    h = header sock\n\n    body = sock.gets\n\n    assert_equal [\"HTTP/1.0 200 OK\", \"Content-Type: plain/text\", \"Connection: Keep-Alive\", \"Content-Length: 6\"], h\n    assert_equal \"hello\\n\", body\n  end\n\n  def test_http_10_close_with_body\n    server_run app: ->(env) { [200, {\"Content-Type\" => \"plain/text\"}, [\"hello\"]] }\n\n    data = send_http_and_read \"GET / HTTP/1.0\\r\\nConnection: close\\r\\n\\r\\n\"\n\n    assert_equal \"HTTP/1.0 200 OK\\r\\nContent-Type: plain/text\\r\\nContent-Length: 5\\r\\n\\r\\nhello\", data\n  end\n\n  def test_http_10_partial_hijack_with_content_length\n    body_parts = ['abc', 'de']\n\n    server_run app: ->(env) do\n      hijack_lambda = proc do | io |\n        io.write(body_parts[0])\n        io.write(body_parts[1])\n        io.close\n      end\n      [200, {\"Content-Length\" => \"5\", 'rack.hijack' => hijack_lambda}, nil]\n    end\n\n    data = send_http_and_read \"GET / HTTP/1.0\\r\\nConnection: close\\r\\n\\r\\n\"\n\n    assert_equal \"HTTP/1.0 200 OK\\r\\nContent-Length: 5\\r\\n\\r\\nabcde\", data\n  end\n\n  def test_http_10_keep_alive_without_body\n    server_run app: ->(env) { [204, {}, []] }\n\n    sock = send_http \"GET / HTTP/1.0\\r\\nConnection: Keep-Alive\\r\\n\\r\\n\"\n\n    h = header sock\n\n    assert_equal [\"HTTP/1.0 204 No Content\", \"Connection: Keep-Alive\"], h\n  end\n\n  def test_http_10_close_without_body\n    server_run app: ->(env) { [204, {}, []] }\n\n    data = send_http_and_read \"GET / HTTP/1.0\\r\\nConnection: close\\r\\n\\r\\n\"\n\n    assert_equal \"HTTP/1.0 204 No Content\\r\\n\\r\\n\", data\n  end\n\n  def test_Expect_100\n    server_run app: ->(env) { [200, {}, [\"\"]] }\n\n    data = send_http_and_read \"GET / HTTP/1.1\\r\\nConnection: close\\r\\nExpect: 100-continue\\r\\n\\r\\n\"\n\n    assert_equal \"HTTP/1.1 100 Continue\\r\\n\\r\\nHTTP/1.1 200 OK\\r\\nConnection: close\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n  end\n\n  def test_chunked_request\n    body = nil\n    server_run app: ->(env) {\n      body = env['rack.input'].read\n      [200, {}, [\"\"]]\n    }\n\n    data = send_http_and_read \"GET / HTTP/1.1\\r\\nConnection: close\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n1\\r\\nh\\r\\n4\\r\\nello\\r\\n0\\r\\n\\r\\n\"\n\n    assert_equal \"HTTP/1.1 200 OK\\r\\nConnection: close\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n    assert_equal \"hello\", body\n  end\n\n  def test_chunked_request_pause_before_value\n    body = nil\n    server_run app: ->(env) {\n      body = env['rack.input'].read\n      [200, {}, [\"\"]]\n    }\n\n    sock = send_http \"GET / HTTP/1.1\\r\\nConnection: close\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n1\\r\\n\"\n    sleep 1\n\n    sock << \"h\\r\\n4\\r\\nello\\r\\n0\\r\\n\\r\\n\"\n\n    data = sock.read\n\n    assert_equal \"HTTP/1.1 200 OK\\r\\nConnection: close\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n    assert_equal \"hello\", body\n  end\n\n  def test_chunked_request_pause_between_chunks\n    body = nil\n    server_run app: ->(env) {\n      body = env['rack.input'].read\n      [200, {}, [\"\"]]\n    }\n\n    sock = send_http \"GET / HTTP/1.1\\r\\nConnection: close\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n1\\r\\nh\\r\\n\"\n    sleep 1\n\n    sock << \"4\\r\\nello\\r\\n0\\r\\n\\r\\n\"\n\n    data = sock.read\n\n    assert_equal \"HTTP/1.1 200 OK\\r\\nConnection: close\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n    assert_equal \"hello\", body\n  end\n\n  def test_chunked_request_pause_mid_count\n    body = nil\n    server_run app: ->(env) {\n      body = env['rack.input'].read\n      [200, {}, [\"\"]]\n    }\n\n    sock = send_http \"GET / HTTP/1.1\\r\\nConnection: close\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n1\\r\"\n    sleep 1\n\n    sock << \"\\nh\\r\\n4\\r\\nello\\r\\n0\\r\\n\\r\\n\"\n\n    data = sock.read\n\n    assert_equal \"HTTP/1.1 200 OK\\r\\nConnection: close\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n    assert_equal \"hello\", body\n  end\n\n  def test_chunked_request_pause_before_count_newline\n    body = nil\n    server_run app: ->(env) {\n      body = env['rack.input'].read\n      [200, {}, [\"\"]]\n    }\n\n    sock = send_http \"GET / HTTP/1.1\\r\\nConnection: close\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n1\"\n    sleep 1\n\n    sock << \"\\r\\nh\\r\\n4\\r\\nello\\r\\n0\\r\\n\\r\\n\"\n\n    data = sock.read\n\n    assert_equal \"HTTP/1.1 200 OK\\r\\nConnection: close\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n    assert_equal \"hello\", body\n  end\n\n  def test_chunked_request_pause_mid_value\n    body = nil\n    server_run app: ->(env) {\n      body = env['rack.input'].read\n      [200, {}, [\"\"]]\n    }\n\n    sock = send_http \"GET / HTTP/1.1\\r\\nConnection: close\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n1\\r\\nh\\r\\n4\\r\\ne\"\n    sleep 1\n\n    sock << \"llo\\r\\n0\\r\\n\\r\\n\"\n\n    data = sock.read\n\n    assert_equal \"HTTP/1.1 200 OK\\r\\nConnection: close\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n    assert_equal \"hello\", body\n  end\n\n  def test_chunked_request_pause_between_cr_lf_after_size_of_second_chunk\n    body = nil\n    server_run app: ->(env)  {\n      body = env['rack.input'].read\n      [200, {}, [\"\"]]\n    }\n\n    part1 = 'a' * 4200\n\n    chunked_body = \"#{part1.size.to_s(16)}\\r\\n#{part1}\\r\\n1\\r\\nb\\r\\n0\\r\\n\\r\\n\"\n\n    sock = send_http \"PUT /path HTTP/1.1\\r\\nConnection: close\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n\"\n\n    sleep 0.1\n\n    sock << chunked_body[0..-10]\n\n    sleep 0.1\n\n    sock << chunked_body[-9..-1]\n\n    data = sock.read\n\n    assert_equal \"HTTP/1.1 200 OK\\r\\nConnection: close\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n    assert_equal (part1 + 'b'), body\n  end\n\n  def test_chunked_request_pause_between_closing_cr_lf\n    body = nil\n    server_run app: ->(env) {\n      body = env['rack.input'].read\n      [200, {}, [\"\"]]\n    }\n\n    sock = send_http \"PUT /path HTTP/1.1\\r\\nConnection: close\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n5\\r\\nhello\\r\"\n\n    sleep 1\n\n    sock << \"\\n0\\r\\n\\r\\n\"\n\n    data = sock.read\n\n    assert_equal \"HTTP/1.1 200 OK\\r\\nConnection: close\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n    assert_equal 'hello', body\n  end\n\n  def test_chunked_request_pause_before_closing_cr_lf\n    body = nil\n    server_run app: ->(env) {\n      body = env['rack.input'].read\n      [200, {}, [\"\"]]\n    }\n\n    sock = send_http \"PUT /path HTTP/1.1\\r\\nConnection: close\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n5\\r\\nhello\"\n\n    sleep 1\n\n    sock << \"\\r\\n0\\r\\n\\r\\n\"\n\n    data = sock.read\n\n    assert_equal \"HTTP/1.1 200 OK\\r\\nConnection: close\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n    assert_equal 'hello', body\n  end\n\n  def test_chunked_request_header_case\n    body = nil\n    server_run app: ->(env) {\n      body = env['rack.input'].read\n      [200, {}, [\"\"]]\n    }\n\n    data = send_http_and_read \"GET / HTTP/1.1\\r\\nConnection: close\\r\\nTransfer-Encoding: Chunked\\r\\n\\r\\n1\\r\\nh\\r\\n4\\r\\nello\\r\\n0\\r\\n\\r\\n\"\n\n    assert_equal \"HTTP/1.1 200 OK\\r\\nConnection: close\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n    assert_equal \"hello\", body\n  end\n\n  def test_chunked_keep_alive\n    body = nil\n    server_run app: ->(env) {\n      body = env['rack.input'].read\n      [200, {}, [\"\"]]\n    }\n\n    sock = send_http \"GET / HTTP/1.1\\r\\nConnection: Keep-Alive\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n1\\r\\nh\\r\\n4\\r\\nello\\r\\n0\\r\\n\\r\\n\"\n\n    h = header sock\n\n    assert_equal [\"HTTP/1.1 200 OK\", \"Content-Length: 0\"], h\n    assert_equal \"hello\", body\n\n    sock.close\n  end\n\n  def test_chunked_keep_alive_two_back_to_back\n    body = nil\n    server_run app: ->(env) {\n      body = env['rack.input'].read\n      [200, {}, [\"\"]]\n    }\n\n    sock = send_http \"GET / HTTP/1.1\\r\\nConnection: Keep-Alive\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n1\\r\\nh\\r\\n4\\r\\nello\\r\\n0\\r\\n\"\n\n    last_crlf_written = false\n    last_crlf_writer = Thread.new do\n      sleep 0.1\n      sock << \"\\r\"\n      sleep 0.1\n      sock << \"\\n\"\n      last_crlf_written = true\n    end\n\n    h = header(sock)\n    assert_equal [\"HTTP/1.1 200 OK\", \"Content-Length: 0\"], h\n    assert_equal \"hello\", body\n    assert_equal true, last_crlf_written\n\n    last_crlf_writer.join\n\n    sock << \"GET / HTTP/1.1\\r\\nConnection: Keep-Alive\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n4\\r\\ngood\\r\\n3\\r\\nbye\\r\\n0\\r\\n\\r\\n\"\n    sleep 0.1\n\n    h = header(sock)\n\n    assert_equal [\"HTTP/1.1 200 OK\", \"Content-Length: 0\"], h\n    assert_equal \"goodbye\", body\n\n    sock.close\n  end\n\n  def test_chunked_keep_alive_two_back_to_back_with_set_remote_address\n    body = nil\n    remote_addr =nil\n    @server = Puma::Server.new @app, @events, { remote_address: :header, remote_address_header: 'HTTP_X_FORWARDED_FOR'}\n    server_run app: ->(env) {\n      body = env['rack.input'].read\n      remote_addr = env['REMOTE_ADDR']\n      [200, {}, [\"\"]]\n    }\n\n    sock = send_http \"GET / HTTP/1.1\\r\\nX-Forwarded-For: 127.0.0.1\\r\\nConnection: Keep-Alive\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n1\\r\\nh\\r\\n4\\r\\nello\\r\\n0\\r\\n\\r\\n\"\n\n    h = header sock\n    assert_equal [\"HTTP/1.1 200 OK\", \"Content-Length: 0\"], h\n    assert_equal \"hello\", body\n    assert_equal \"127.0.0.1\", remote_addr\n\n    sock << \"GET / HTTP/1.1\\r\\nX-Forwarded-For: 127.0.0.2\\r\\nConnection: Keep-Alive\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n4\\r\\ngood\\r\\n3\\r\\nbye\\r\\n0\\r\\n\\r\\n\"\n    sleep 0.1\n\n    h = header(sock)\n\n    assert_equal [\"HTTP/1.1 200 OK\", \"Content-Length: 0\"], h\n    assert_equal \"goodbye\", body\n    assert_equal \"127.0.0.2\", remote_addr\n\n    sock.close\n  end\n\n  def test_empty_header_values\n    server_run app: ->(env) { [200, {\"X-Empty-Header\" => \"\"}, []] }\n\n    data = send_http_and_read \"HEAD / HTTP/1.0\\r\\n\\r\\n\"\n\n    assert_equal \"HTTP/1.0 200 OK\\r\\nX-Empty-Header: \\r\\n\\r\\n\", data\n  end\n\n  def test_request_body_wait\n    request_body_wait = nil\n    server_run app: ->(env) {\n      request_body_wait = env['puma.request_body_wait']\n      [204, {}, []]\n    }\n\n    sock = send_http \"POST / HTTP/1.1\\r\\nHost: test.com\\r\\nContent-Type: text/plain\\r\\nContent-Length: 5\\r\\n\\r\\nh\"\n    sleep 1\n    sock << \"ello\"\n\n    sock.gets\n\n    # Could be 1000 but the tests get flaky. We don't care if it's extremely precise so much as that\n    # it is set to a reasonable number.\n    assert_operator request_body_wait, :>=, 900\n  end\n\n  def test_request_body_wait_chunked\n    request_body_wait = nil\n    server_run app: ->(env) {\n      request_body_wait = env['puma.request_body_wait']\n      [204, {}, []]\n    }\n\n    sock = send_http \"GET / HTTP/1.1\\r\\nConnection: close\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n1\\r\\nh\\r\\n\"\n    sleep 3\n    sock << \"4\\r\\nello\\r\\n0\\r\\n\\r\\n\"\n\n    sock.gets\n\n    # Could be 1000 but the tests get flaky. We don't care if it's extremely precise so much as that\n    # it is set to a reasonable number.\n    assert_operator request_body_wait, :>=, 900\n  end\n\n  def test_open_connection_wait\n    server_run app: ->(_) { [200, {}, [\"Hello\"]] }\n    s = send_http nil\n    sleep 0.1\n    s << \"GET / HTTP/1.0\\r\\n\\r\\n\"\n    assert_equal 'Hello', s.readlines.last\n  end\n\n  def test_open_connection_wait_no_queue\n    @server = Puma::Server.new @app, @events, queue_requests: false\n    test_open_connection_wait\n  end\n\n  # Rack may pass a newline in a header expecting us to split it.\n  def test_newline_splits\n    server_run app: ->(_) { [200, {'X-header' => \"first line\\nsecond line\"}, [\"Hello\"]] }\n\n    data = send_http_and_read \"HEAD / HTTP/1.0\\r\\n\\r\\n\"\n\n    assert_match \"X-header: first line\\r\\nX-header: second line\\r\\n\", data\n  end\n\n  def test_newline_splits_in_early_hint\n    server_run early_hints: true, app: ->(env) do\n      env['rack.early_hints'].call({'X-header' => \"first line\\nsecond line\"})\n      [200, {}, [\"Hello world!\"]]\n    end\n\n    data = send_http_and_read \"HEAD / HTTP/1.0\\r\\n\\r\\n\"\n\n    assert_match \"X-header: first line\\r\\nX-header: second line\\r\\n\", data\n  end\n\n  # To comply with the Rack spec, we have to split header field values\n  # containing newlines into multiple headers.\n  def assert_does_not_allow_http_injection(app, opts = {})\n    server_run(early_hints: opts[:early_hints], app: app)\n\n    data = send_http_and_read \"HEAD / HTTP/1.0\\r\\n\\r\\n\"\n\n    refute_match(/[\\r\\n]Cookie: hack[\\r\\n]/, data)\n  end\n\n  # HTTP Injection Tests\n  #\n  # Puma should prevent injection of CR and LF characters into headers, either as\n  # CRLF or CR or LF, because browsers may interpret it at as a line end and\n  # allow untrusted input in the header to split the header or start the\n  # response body. While it's not documented anywhere and they shouldn't be doing\n  # it, Chrome and curl recognize a lone CR as a line end. According to RFC,\n  # clients SHOULD interpret LF as a line end for robustness, and CRLF is the\n  # specced line end.\n  #\n  # There are three different tests because there are three ways to set header\n  # content in Puma. Regular (rack env), early hints, and a special case for\n  # overriding content-length.\n  {\"cr\" => \"\\r\", \"lf\" => \"\\n\", \"crlf\" => \"\\r\\n\"}.each do |suffix, line_ending|\n    # The cr-only case for the following test was CVE-2020-5247\n    define_method(\"test_prevent_response_splitting_headers_#{suffix}\") do\n      app = ->(_) { [200, {'X-header' => \"untrusted input#{line_ending}Cookie: hack\"}, [\"Hello\"]] }\n      assert_does_not_allow_http_injection(app)\n    end\n\n    define_method(\"test_prevent_response_splitting_headers_early_hint_#{suffix}\") do\n      app = ->(env) do\n        env['rack.early_hints'].call(\"X-header\" => \"untrusted input#{line_ending}Cookie: hack\")\n        [200, {}, [\"Hello\"]]\n      end\n      assert_does_not_allow_http_injection(app, early_hints: true)\n    end\n\n    define_method(\"test_prevent_content_length_injection_#{suffix}\") do\n      app = ->(_) { [200, {'content-length' => \"untrusted input#{line_ending}Cookie: hack\"}, [\"Hello\"]] }\n      assert_does_not_allow_http_injection(app)\n    end\n  end\nend\n"], "filenames": ["History.md", "lib/puma/const.rb", "lib/puma/server.rb", "test/test_puma_server.rb"], "buggy_code_start_loc": [24, 231, 665, 775], "buggy_code_end_loc": [24, 232, 1050, 792], "fixing_code_start_loc": [25, 231, 666, 775], "fixing_code_end_loc": [32, 232, 1057, 837], "type": "CWE-74", "message": "In Puma (RubyGem) before 4.3.3 and 3.12.4, if an application using Puma allows untrusted input in an early-hints header, an attacker can use a carriage return character to end the header and inject malicious content, such as additional headers or an entirely new response body. This vulnerability is known as HTTP Response Splitting. While not an attack in itself, response splitting is a vector for several other attacks, such as cross-site scripting (XSS). This is related to CVE-2020-5247, which fixed this vulnerability but only for regular responses. This has been fixed in 4.3.3 and 3.12.4.", "other": {"cve": {"id": "CVE-2020-5249", "sourceIdentifier": "security-advisories@github.com", "published": "2020-03-02T16:15:12.330", "lastModified": "2020-04-09T17:15:13.093", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In Puma (RubyGem) before 4.3.3 and 3.12.4, if an application using Puma allows untrusted input in an early-hints header, an attacker can use a carriage return character to end the header and inject malicious content, such as additional headers or an entirely new response body. This vulnerability is known as HTTP Response Splitting. While not an attack in itself, response splitting is a vector for several other attacks, such as cross-site scripting (XSS). This is related to CVE-2020-5247, which fixed this vulnerability but only for regular responses. This has been fixed in 4.3.3 and 3.12.4."}, {"lang": "es", "value": "En Puma (RubyGem) versiones anteriores a 3.3 y 3.12.4, si una aplicaci\u00f3n que usa Puma permite una entrada no confiable en un encabezado early-hint, un atacante puede usar un car\u00e1cter retorno de carro para finalizar el encabezado e inyectar contenido malicioso, tales como encabezados adicionales o un cuerpo de respuesta completamente nuevo. Esta vulnerabilidad se conoce como Divisi\u00f3n de Respuesta HTTP. Si bien no es un ataque en s\u00ed mismo, la divisi\u00f3n de la respuesta es un vector para varios otros ataques, tales como un cross-site scripting (XSS). Esto est\u00e1 relacionado con CVE-2020-5247, que corrigi\u00f3 esta vulnerabilidad pero solo para respuestas regulares. Esto se ha corregido en las versiones 4.3.3 y 3.12.4."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 3.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-74"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-113"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:puma:puma:*:*:*:*:*:ruby:*:*", "versionEndIncluding": "3.12.3", "matchCriteriaId": "4556E64B-1B65-4A1B-815E-3FFF181459A4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:puma:puma:*:*:*:*:*:ruby:*:*", "versionStartIncluding": "4.0.0", "versionEndIncluding": "4.3.2", "matchCriteriaId": "8E03463F-61DD-4FE9-97FE-F9BA7DC394A1"}]}]}], "references": [{"url": "https://github.com/puma/puma/commit/c22712fc93284a45a93f9ad7023888f3a65524f3", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/puma/puma/security/advisories/GHSA-33vf-4xgg-9r58", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/puma/puma/security/advisories/GHSA-84j7-475p-hp8v", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/BMJ3CGZ3DLBJ5WUUKMI5ZFXFJQMXJZIK/", "source": "security-advisories@github.com"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/DIHVO3CQMU7BZC7FCTSRJ33YDNS3GFPK/", "source": "security-advisories@github.com"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/NJ3LL5F5QADB6LM46GXZETREAKZMQNRD/", "source": "security-advisories@github.com"}, {"url": "https://owasp.org/www-community/attacks/HTTP_Response_Splitting", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/puma/puma/commit/c22712fc93284a45a93f9ad7023888f3a65524f3"}}