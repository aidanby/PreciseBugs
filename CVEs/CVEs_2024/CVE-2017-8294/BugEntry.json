{"buggy_code": ["/*\nCopyright (c) 2013-2014. The YARA Authors. All Rights Reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\nlist of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors\nmay be used to endorse or promote products derived from this software without\nspecific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#define _GNU_SOURCE\n\n#include <string.h>\n#include <assert.h>\n#include <time.h>\n#include <math.h>\n\n#include <yara/endian.h>\n#include <yara/exec.h>\n#include <yara/limits.h>\n#include <yara/error.h>\n#include <yara/object.h>\n#include <yara/modules.h>\n#include <yara/re.h>\n#include <yara/strutils.h>\n#include <yara/utils.h>\n#include <yara/mem.h>\n\n#include <yara.h>\n\n\n#define MEM_SIZE   MAX_LOOP_NESTING * LOOP_LOCAL_VARS\n\n\n#define push(x)  \\\n    if (sp < stack_size) \\\n    { \\\n      stack[sp++] = (x); \\\n    } \\\n    else \\\n    { \\\n      result = ERROR_EXEC_STACK_OVERFLOW; \\\n      stop = TRUE; \\\n      break; \\\n    } \\\n\n\n#define pop(x)  x = stack[--sp]\n\n#define is_undef(x) IS_UNDEFINED((x).i)\n\n#define ensure_defined(x) \\\n    if (is_undef(x)) \\\n    { \\\n      r1.i = UNDEFINED; \\\n      push(r1); \\\n      break; \\\n    }\n\n\n#define little_endian_uint8_t(x)     (x)\n#define little_endian_int8_t(x)      (x)\n#define little_endian_uint16_t(x)    yr_le16toh(x)\n#define little_endian_int16_t(x)     yr_le16toh(x)\n#define little_endian_uint32_t(x)    yr_le32toh(x)\n#define little_endian_int32_t(x)     yr_le32toh(x)\n\n#define big_endian_uint8_t(x)        (x)\n#define big_endian_int8_t(x)         (x)\n#define big_endian_uint16_t(x)       yr_be16toh(x)\n#define big_endian_int16_t(x)        yr_be16toh(x)\n#define big_endian_uint32_t(x)       yr_be32toh(x)\n#define big_endian_int32_t(x)        yr_be32toh(x)\n\n\n#define function_read(type, endianess) \\\n    int64_t read_##type##_##endianess(YR_MEMORY_BLOCK_ITERATOR* iterator, size_t offset) \\\n    { \\\n      YR_MEMORY_BLOCK* block = iterator->first(iterator); \\\n      while (block != NULL) \\\n      { \\\n        if (offset >= block->base && \\\n            block->size >= sizeof(type) && \\\n            offset <= block->base + block->size - sizeof(type)) \\\n        { \\\n          type result; \\\n          uint8_t* data = block->fetch_data(block); \\\n          if (data == NULL) \\\n            return UNDEFINED; \\\n          result = *(type *)(data + offset - block->base); \\\n          result = endianess##_##type(result); \\\n          return result; \\\n        } \\\n        block = iterator->next(iterator); \\\n      } \\\n      return UNDEFINED; \\\n    };\n\n\nfunction_read(uint8_t, little_endian)\nfunction_read(uint16_t, little_endian)\nfunction_read(uint32_t, little_endian)\nfunction_read(int8_t, little_endian)\nfunction_read(int16_t, little_endian)\nfunction_read(int32_t, little_endian)\nfunction_read(uint8_t, big_endian)\nfunction_read(uint16_t, big_endian)\nfunction_read(uint32_t, big_endian)\nfunction_read(int8_t, big_endian)\nfunction_read(int16_t, big_endian)\nfunction_read(int32_t, big_endian)\n\n\nstatic uint8_t* jmp_if(\n    int condition,\n    uint8_t* ip)\n{\n  uint8_t* result;\n\n  if (condition)\n  {\n    result = *(uint8_t**)(ip + 1);\n\n    // ip will be incremented at the end of the execution loop,\n    // decrement it here to compensate.\n\n    result--;\n  }\n  else\n  {\n    result = ip + sizeof(uint64_t);\n  }\n\n  return result;\n}\n\n\nint yr_execute_code(\n    YR_RULES* rules,\n    YR_SCAN_CONTEXT* context,\n    int timeout,\n    time_t start_time)\n{\n  int64_t mem[MEM_SIZE];\n  int32_t sp = 0;\n  uint8_t* ip = rules->code_start;\n\n  YR_VALUE args[MAX_FUNCTION_ARGS];\n  YR_VALUE *stack;\n  YR_VALUE r1;\n  YR_VALUE r2;\n  YR_VALUE r3;\n\n  #ifdef PROFILING_ENABLED\n  YR_RULE* current_rule = NULL;\n  #endif\n\n  YR_RULE* rule;\n  YR_MATCH* match;\n  YR_OBJECT_FUNCTION* function;\n\n  char* identifier;\n  char* args_fmt;\n\n  int i;\n  int found;\n  int count;\n  int result = ERROR_SUCCESS;\n  int stop = FALSE;\n  int cycle = 0;\n  int tidx = context->tidx;\n  int stack_size;\n\n  #ifdef PROFILING_ENABLED\n  clock_t start = clock();\n  #endif\n\n  yr_get_configuration(YR_CONFIG_STACK_SIZE, (void*) &stack_size);\n\n  stack = (YR_VALUE*) yr_malloc(stack_size * sizeof(YR_VALUE));\n\n  if (stack == NULL)\n    return ERROR_INSUFFICIENT_MEMORY;\n\n  while(!stop)\n  {\n    switch(*ip)\n    {\n      case OP_HALT:\n        assert(sp == 0); // When HALT is reached the stack should be empty.\n        stop = TRUE;\n        break;\n\n      case OP_PUSH:\n        r1.i = *(uint64_t*)(ip + 1);\n        ip += sizeof(uint64_t);\n        push(r1);\n        break;\n\n      case OP_POP:\n        pop(r1);\n        break;\n\n      case OP_CLEAR_M:\n        r1.i = *(uint64_t*)(ip + 1);\n        ip += sizeof(uint64_t);\n        mem[r1.i] = 0;\n        break;\n\n      case OP_ADD_M:\n        r1.i = *(uint64_t*)(ip + 1);\n        ip += sizeof(uint64_t);\n        pop(r2);\n        if (!is_undef(r2))\n          mem[r1.i] += r2.i;\n        break;\n\n      case OP_INCR_M:\n        r1.i = *(uint64_t*)(ip + 1);\n        ip += sizeof(uint64_t);\n        mem[r1.i]++;\n        break;\n\n      case OP_PUSH_M:\n        r1.i = *(uint64_t*)(ip + 1);\n        ip += sizeof(uint64_t);\n        r1.i = mem[r1.i];\n        push(r1);\n        break;\n\n      case OP_POP_M:\n        r1.i = *(uint64_t*)(ip + 1);\n        ip += sizeof(uint64_t);\n        pop(r2);\n        mem[r1.i] = r2.i;\n        break;\n\n      case OP_SWAPUNDEF:\n        r1.i = *(uint64_t*)(ip + 1);\n        ip += sizeof(uint64_t);\n        pop(r2);\n\n        if (is_undef(r2))\n        {\n          r1.i = mem[r1.i];\n          push(r1);\n        }\n        else\n        {\n          push(r2);\n        }\n        break;\n\n      case OP_JNUNDEF:\n        pop(r1);\n        push(r1);\n\n        ip = jmp_if(!is_undef(r1), ip);\n        break;\n\n      case OP_JLE:\n        pop(r2);\n        pop(r1);\n        push(r1);\n        push(r2);\n\n        ip = jmp_if(r1.i <= r2.i, ip);\n        break;\n\n      case OP_JTRUE:\n        pop(r1);\n        push(r1);\n\n        ip = jmp_if(!is_undef(r1) && r1.i, ip);\n        break;\n\n      case OP_JFALSE:\n        pop(r1);\n        push(r1);\n\n        ip = jmp_if(is_undef(r1) || !r1.i, ip);\n        break;\n\n      case OP_AND:\n        pop(r2);\n        pop(r1);\n\n        if (is_undef(r1) || is_undef(r2))\n          r1.i = 0;\n        else\n          r1.i = r1.i && r2.i;\n\n        push(r1);\n        break;\n\n      case OP_OR:\n        pop(r2);\n        pop(r1);\n\n        if (is_undef(r1))\n        {\n          push(r2);\n        }\n        else if (is_undef(r2))\n        {\n          push(r1);\n        }\n        else\n        {\n          r1.i = r1.i || r2.i;\n          push(r1);\n        }\n        break;\n\n      case OP_NOT:\n        pop(r1);\n\n        if (is_undef(r1))\n          r1.i = UNDEFINED;\n        else\n          r1.i= !r1.i;\n\n        push(r1);\n        break;\n\n      case OP_MOD:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        if (r2.i != 0)\n          r1.i = r1.i % r2.i;\n        else\n          r1.i = UNDEFINED;\n        push(r1);\n        break;\n\n      case OP_SHR:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i >> r2.i;\n        push(r1);\n        break;\n\n      case OP_SHL:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i << r2.i;\n        push(r1);\n        break;\n\n      case OP_BITWISE_NOT:\n        pop(r1);\n        ensure_defined(r1);\n        r1.i = ~r1.i;\n        push(r1);\n        break;\n\n      case OP_BITWISE_AND:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i & r2.i;\n        push(r1);\n        break;\n\n      case OP_BITWISE_OR:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i | r2.i;\n        push(r1);\n        break;\n\n      case OP_BITWISE_XOR:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i ^ r2.i;\n        push(r1);\n        break;\n\n      case OP_PUSH_RULE:\n        rule = *(YR_RULE**)(ip + 1);\n        ip += sizeof(uint64_t);\n        r1.i = rule->t_flags[tidx] & RULE_TFLAGS_MATCH ? 1 : 0;\n        push(r1);\n        break;\n\n      case OP_INIT_RULE:\n        #ifdef PROFILING_ENABLED\n        current_rule = *(YR_RULE**)(ip + 1);\n        #endif\n        ip += sizeof(uint64_t);\n        break;\n\n      case OP_MATCH_RULE:\n        pop(r1);\n        rule = *(YR_RULE**)(ip + 1);\n        ip += sizeof(uint64_t);\n\n        if (!is_undef(r1) && r1.i)\n          rule->t_flags[tidx] |= RULE_TFLAGS_MATCH;\n        else if (RULE_IS_GLOBAL(rule))\n          rule->ns->t_flags[tidx] |= NAMESPACE_TFLAGS_UNSATISFIED_GLOBAL;\n\n        #ifdef PROFILING_ENABLED\n        rule->clock_ticks += clock() - start;\n        start = clock();\n        #endif\n        break;\n\n      case OP_OBJ_LOAD:\n        identifier = *(char**)(ip + 1);\n        ip += sizeof(uint64_t);\n\n        r1.o = (YR_OBJECT*) yr_hash_table_lookup(\n            context->objects_table,\n            identifier,\n            NULL);\n\n        assert(r1.o != NULL);\n        push(r1);\n        break;\n\n      case OP_OBJ_FIELD:\n        identifier = *(char**)(ip + 1);\n        ip += sizeof(uint64_t);\n\n        pop(r1);\n        ensure_defined(r1);\n\n        r1.o = yr_object_lookup_field(r1.o, identifier);\n\n        assert(r1.o != NULL);\n        push(r1);\n        break;\n\n      case OP_OBJ_VALUE:\n        pop(r1);\n        ensure_defined(r1);\n\n        switch(r1.o->type)\n        {\n          case OBJECT_TYPE_INTEGER:\n            r1.i = ((YR_OBJECT_INTEGER*) r1.o)->value;\n            break;\n\n          case OBJECT_TYPE_FLOAT:\n            if (isnan(((YR_OBJECT_DOUBLE*) r1.o)->value))\n              r1.i = UNDEFINED;\n            else\n              r1.d = ((YR_OBJECT_DOUBLE*) r1.o)->value;\n            break;\n\n          case OBJECT_TYPE_STRING:\n            if (((YR_OBJECT_STRING*) r1.o)->value == NULL)\n              r1.i = UNDEFINED;\n            else\n              r1.p = ((YR_OBJECT_STRING*) r1.o)->value;\n            break;\n\n          default:\n            assert(FALSE);\n        }\n\n        push(r1);\n        break;\n\n      case OP_INDEX_ARRAY:\n        pop(r1);  // index\n        pop(r2);  // array\n\n        ensure_defined(r1);\n        ensure_defined(r2);\n        assert(r2.o->type == OBJECT_TYPE_ARRAY);\n\n        r1.o = yr_object_array_get_item(r2.o, 0, (int) r1.i);\n\n        if (r1.o == NULL)\n          r1.i = UNDEFINED;\n\n        push(r1);\n        break;\n\n      case OP_LOOKUP_DICT:\n        pop(r1);  // key\n        pop(r2);  // dictionary\n\n        ensure_defined(r1);\n        ensure_defined(r2);\n        assert(r2.o->type == OBJECT_TYPE_DICTIONARY);\n\n        r1.o = yr_object_dict_get_item(\n            r2.o, 0, r1.ss->c_string);\n\n        if (r1.o == NULL)\n          r1.i = UNDEFINED;\n\n        push(r1);\n        break;\n\n      case OP_CALL:\n        args_fmt = *(char**)(ip + 1);\n        ip += sizeof(uint64_t);\n\n        i = (int) strlen(args_fmt);\n        count = 0;\n\n        // pop arguments from stack and copy them to args array\n\n        while (i > 0)\n        {\n          pop(r1);\n\n          if (is_undef(r1))  // count the number of undefined args\n            count++;\n\n          args[i - 1] = r1;\n          i--;\n        }\n\n        pop(r2);\n        ensure_defined(r2);\n\n        if (count > 0)\n        {\n          // if there are undefined args, result for function call\n          // is undefined as well.\n\n          r1.i = UNDEFINED;\n          push(r1);\n          break;\n        }\n\n        function = (YR_OBJECT_FUNCTION*) r2.o;\n        result = ERROR_INTERNAL_FATAL_ERROR;\n\n        for (i = 0; i < MAX_OVERLOADED_FUNCTIONS; i++)\n        {\n          if (function->prototypes[i].arguments_fmt == NULL)\n            break;\n\n          if (strcmp(function->prototypes[i].arguments_fmt, args_fmt) == 0)\n          {\n            result = function->prototypes[i].code(args, context, function);\n            break;\n          }\n        }\n\n        assert(i < MAX_OVERLOADED_FUNCTIONS);\n\n        if (result == ERROR_SUCCESS)\n        {\n          r1.o = function->return_obj;\n          push(r1);\n        }\n        else\n        {\n          stop = TRUE;\n        }\n\n        break;\n\n      case OP_FOUND:\n        pop(r1);\n        r1.i = r1.s->matches[tidx].tail != NULL ? 1 : 0;\n        push(r1);\n        break;\n\n      case OP_FOUND_AT:\n        pop(r2);\n        pop(r1);\n\n        if (is_undef(r1))\n        {\n          r1.i = 0;\n          push(r1);\n          break;\n        }\n\n        match = r2.s->matches[tidx].head;\n        r3.i = FALSE;\n\n        while (match != NULL)\n        {\n          if (r1.i == match->base + match->offset)\n          {\n            r3.i = TRUE;\n            break;\n          }\n\n          if (r1.i < match->base + match->offset)\n            break;\n\n          match = match->next;\n        }\n\n        push(r3);\n        break;\n\n      case OP_FOUND_IN:\n        pop(r3);\n        pop(r2);\n        pop(r1);\n\n        ensure_defined(r1);\n        ensure_defined(r2);\n\n        match = r3.s->matches[tidx].head;\n        r3.i = FALSE;\n\n        while (match != NULL && !r3.i)\n        {\n          if (match->base + match->offset >= r1.i &&\n              match->base + match->offset <= r2.i)\n          {\n            r3.i = TRUE;\n          }\n\n          if (match->base + match->offset > r2.i)\n            break;\n\n          match = match->next;\n        }\n\n        push(r3);\n        break;\n\n      case OP_COUNT:\n        pop(r1);\n        r1.i = r1.s->matches[tidx].count;\n        push(r1);\n        break;\n\n      case OP_OFFSET:\n        pop(r2);\n        pop(r1);\n\n        ensure_defined(r1);\n\n        match = r2.s->matches[tidx].head;\n        i = 1;\n        r3.i = UNDEFINED;\n\n        while (match != NULL && r3.i == UNDEFINED)\n        {\n          if (r1.i == i)\n            r3.i = match->base + match->offset;\n\n          i++;\n          match = match->next;\n        }\n\n        push(r3);\n        break;\n\n      case OP_LENGTH:\n        pop(r2);\n        pop(r1);\n\n        ensure_defined(r1);\n\n        match = r2.s->matches[tidx].head;\n        i = 1;\n        r3.i = UNDEFINED;\n\n        while (match != NULL && r3.i == UNDEFINED)\n        {\n          if (r1.i == i)\n            r3.i = match->match_length;\n\n          i++;\n          match = match->next;\n        }\n\n        push(r3);\n        break;\n\n      case OP_OF:\n        found = 0;\n        count = 0;\n        pop(r1);\n\n        while (!is_undef(r1))\n        {\n          if (r1.s->matches[tidx].tail != NULL)\n            found++;\n          count++;\n          pop(r1);\n        }\n\n        pop(r2);\n\n        if (is_undef(r2))\n          r1.i = found >= count ? 1 : 0;\n        else\n          r1.i = found >= r2.i ? 1 : 0;\n\n        push(r1);\n        break;\n\n      case OP_FILESIZE:\n        r1.i = context->file_size;\n        push(r1);\n        break;\n\n      case OP_ENTRYPOINT:\n        r1.i = context->entry_point;\n        push(r1);\n        break;\n\n      case OP_INT8:\n        pop(r1);\n        r1.i = read_int8_t_little_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_INT16:\n        pop(r1);\n        r1.i = read_int16_t_little_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_INT32:\n        pop(r1);\n        r1.i = read_int32_t_little_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_UINT8:\n        pop(r1);\n        r1.i = read_uint8_t_little_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_UINT16:\n        pop(r1);\n        r1.i = read_uint16_t_little_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_UINT32:\n        pop(r1);\n        r1.i = read_uint32_t_little_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_INT8BE:\n        pop(r1);\n        r1.i = read_int8_t_big_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_INT16BE:\n        pop(r1);\n        r1.i = read_int16_t_big_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_INT32BE:\n        pop(r1);\n        r1.i = read_int32_t_big_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_UINT8BE:\n        pop(r1);\n        r1.i = read_uint8_t_big_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_UINT16BE:\n        pop(r1);\n        r1.i = read_uint16_t_big_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_UINT32BE:\n        pop(r1);\n        r1.i = read_uint32_t_big_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_CONTAINS:\n        pop(r2);\n        pop(r1);\n\n        ensure_defined(r1);\n        ensure_defined(r2);\n\n        r1.i = memmem(r1.ss->c_string, r1.ss->length,\n                      r2.ss->c_string, r2.ss->length) != NULL;\n        push(r1);\n        break;\n\n      case OP_IMPORT:\n        r1.i = *(uint64_t*)(ip + 1);\n        ip += sizeof(uint64_t);\n\n        result = yr_modules_load((char*) r1.p, context);\n\n        if (result != ERROR_SUCCESS)\n          stop = TRUE;\n\n        break;\n\n      case OP_MATCHES:\n\n        pop(r2);\n        pop(r1);\n\n        ensure_defined(r2);\n        ensure_defined(r1);\n\n        if (r1.ss->length == 0)\n        {\n          r1.i = FALSE;\n          push(r1);\n          break;\n        }\n\n        r1.i = yr_re_exec(\n          (uint8_t*) r2.re->code,\n          (uint8_t*) r1.ss->c_string,\n          r1.ss->length,\n          r2.re->flags | RE_FLAGS_SCAN,\n          NULL,\n          NULL) >= 0;\n\n        push(r1);\n        break;\n\n      case OP_INT_TO_DBL:\n        r1.i = *(uint64_t*)(ip + 1);\n        ip += sizeof(uint64_t);\n        r2 = stack[sp - r1.i];\n        if (is_undef(r2))\n          stack[sp - r1.i].i = UNDEFINED;\n        else\n          stack[sp - r1.i].d = (double) r2.i;\n        break;\n\n      case OP_STR_TO_BOOL:\n        pop(r1);\n        ensure_defined(r1);\n        r1.i = r1.ss->length > 0;\n        push(r1);\n        break;\n\n      case OP_INT_EQ:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i == r2.i;\n        push(r1);\n        break;\n\n      case OP_INT_NEQ:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i != r2.i;\n        push(r1);\n        break;\n\n      case OP_INT_LT:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i < r2.i;\n        push(r1);\n        break;\n\n      case OP_INT_GT:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i > r2.i;\n        push(r1);\n        break;\n\n      case OP_INT_LE:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i <= r2.i;\n        push(r1);\n        break;\n\n      case OP_INT_GE:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i >= r2.i;\n        push(r1);\n        break;\n\n      case OP_INT_ADD:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i + r2.i;\n        push(r1);\n        break;\n\n      case OP_INT_SUB:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i - r2.i;\n        push(r1);\n        break;\n\n      case OP_INT_MUL:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i * r2.i;\n        push(r1);\n        break;\n\n      case OP_INT_DIV:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        if (r2.i != 0)\n          r1.i = r1.i / r2.i;\n        else\n          r1.i = UNDEFINED;\n        push(r1);\n        break;\n\n      case OP_INT_MINUS:\n        pop(r1);\n        ensure_defined(r1);\n        r1.i = -r1.i;\n        push(r1);\n        break;\n\n      case OP_DBL_LT:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.d < r2.d;\n        push(r1);\n        break;\n\n      case OP_DBL_GT:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.d > r2.d;\n        push(r1);\n        break;\n\n      case OP_DBL_LE:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.d <= r2.d;\n        push(r1);\n        break;\n\n      case OP_DBL_GE:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.d >= r2.d;\n        push(r1);\n        break;\n\n      case OP_DBL_EQ:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.d == r2.d;\n        push(r1);\n        break;\n\n      case OP_DBL_NEQ:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.d != r2.d;\n        push(r1);\n        break;\n\n      case OP_DBL_ADD:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.d = r1.d + r2.d;\n        push(r1);\n        break;\n\n      case OP_DBL_SUB:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.d = r1.d - r2.d;\n        push(r1);\n        break;\n\n      case OP_DBL_MUL:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.d = r1.d * r2.d;\n        push(r1);\n        break;\n\n      case OP_DBL_DIV:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.d = r1.d / r2.d;\n        push(r1);\n        break;\n\n      case OP_DBL_MINUS:\n        pop(r1);\n        ensure_defined(r1);\n        r1.d = -r1.d;\n        push(r1);\n        break;\n\n      case OP_STR_EQ:\n      case OP_STR_NEQ:\n      case OP_STR_LT:\n      case OP_STR_LE:\n      case OP_STR_GT:\n      case OP_STR_GE:\n\n        pop(r2);\n        pop(r1);\n\n        ensure_defined(r1);\n        ensure_defined(r2);\n\n        switch(*ip)\n        {\n          case OP_STR_EQ:\n            r1.i = (sized_string_cmp(r1.ss, r2.ss) == 0);\n            break;\n          case OP_STR_NEQ:\n            r1.i = (sized_string_cmp(r1.ss, r2.ss) != 0);\n            break;\n          case OP_STR_LT:\n            r1.i = (sized_string_cmp(r1.ss, r2.ss) < 0);\n            break;\n          case OP_STR_LE:\n            r1.i = (sized_string_cmp(r1.ss, r2.ss) <= 0);\n            break;\n          case OP_STR_GT:\n            r1.i = (sized_string_cmp(r1.ss, r2.ss) > 0);\n            break;\n          case OP_STR_GE:\n            r1.i = (sized_string_cmp(r1.ss, r2.ss) >= 0);\n            break;\n        }\n\n        push(r1);\n        break;\n\n      default:\n        // Unknown instruction, this shouldn't happen.\n        assert(FALSE);\n    }\n\n    if (timeout > 0)  // timeout == 0 means no timeout\n    {\n      // Check for timeout every 10 instruction cycles.\n\n      if (++cycle == 10)\n      {\n        if (difftime(time(NULL), start_time) > timeout)\n        {\n          #ifdef PROFILING_ENABLED\n          assert(current_rule != NULL);\n          current_rule->clock_ticks += clock() - start;\n          #endif\n          result = ERROR_SCAN_TIMEOUT;\n          stop = TRUE;\n        }\n\n        cycle = 0;\n      }\n    }\n\n    ip++;\n  }\n\n  yr_modules_unload_all(context);\n  yr_free(stack);\n\n  return result;\n}\n", "/*\nCopyright (c) 2013. The YARA Authors. All Rights Reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\nlist of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors\nmay be used to endorse or promote products derived from this software without\nspecific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#ifndef YR_RE_H\n#define YR_RE_H\n\n#include <ctype.h>\n\n#include <yara/arena.h>\n#include <yara/sizedstr.h>\n\n#define RE_NODE_LITERAL             1\n#define RE_NODE_MASKED_LITERAL      2\n#define RE_NODE_ANY                 3\n#define RE_NODE_CONCAT              4\n#define RE_NODE_ALT                 5\n#define RE_NODE_RANGE               6\n#define RE_NODE_STAR                7\n#define RE_NODE_PLUS                8\n#define RE_NODE_CLASS               9\n#define RE_NODE_WORD_CHAR           10\n#define RE_NODE_NON_WORD_CHAR       11\n#define RE_NODE_SPACE               12\n#define RE_NODE_NON_SPACE           13\n#define RE_NODE_DIGIT               14\n#define RE_NODE_NON_DIGIT           15\n#define RE_NODE_EMPTY               16\n#define RE_NODE_ANCHOR_START        17\n#define RE_NODE_ANCHOR_END          18\n#define RE_NODE_WORD_BOUNDARY       19\n#define RE_NODE_NON_WORD_BOUNDARY   20\n#define RE_NODE_RANGE_ANY           21\n\n\n#define RE_OPCODE_ANY                   0xA0\n#define RE_OPCODE_ANY_EXCEPT_NEW_LINE   0xA1\n#define RE_OPCODE_LITERAL               0xA2\n#define RE_OPCODE_MASKED_LITERAL        0xA4\n#define RE_OPCODE_CLASS                 0xA5\n#define RE_OPCODE_WORD_CHAR             0xA7\n#define RE_OPCODE_NON_WORD_CHAR         0xA8\n#define RE_OPCODE_SPACE                 0xA9\n#define RE_OPCODE_NON_SPACE             0xAA\n#define RE_OPCODE_DIGIT                 0xAB\n#define RE_OPCODE_NON_DIGIT             0xAC\n#define RE_OPCODE_MATCH                 0xAD\n\n#define RE_OPCODE_MATCH_AT_END          0xB0\n#define RE_OPCODE_MATCH_AT_START        0xB1\n#define RE_OPCODE_WORD_BOUNDARY         0xB2\n#define RE_OPCODE_NON_WORD_BOUNDARY     0xB3\n#define RE_OPCODE_REPEAT_ANY_GREEDY     0xB4\n#define RE_OPCODE_REPEAT_ANY_UNGREEDY   0xB5\n\n#define RE_OPCODE_SPLIT_A               0xC0\n#define RE_OPCODE_SPLIT_B               0xC1\n#define RE_OPCODE_JUMP                  0xC2\n#define RE_OPCODE_REPEAT_START_GREEDY   0xC3\n#define RE_OPCODE_REPEAT_END_GREEDY     0xC4\n#define RE_OPCODE_REPEAT_START_UNGREEDY 0xC5\n#define RE_OPCODE_REPEAT_END_UNGREEDY   0xC6\n\n\n#define RE_FLAGS_FAST_REGEXP            0x02\n#define RE_FLAGS_BACKWARDS              0x04\n#define RE_FLAGS_EXHAUSTIVE             0x08\n#define RE_FLAGS_WIDE                   0x10\n#define RE_FLAGS_NO_CASE                0x20\n#define RE_FLAGS_SCAN                   0x40\n#define RE_FLAGS_DOT_ALL                0x80\n#define RE_FLAGS_NOT_AT_START          0x100\n#define RE_FLAGS_GREEDY                0x400\n#define RE_FLAGS_UNGREEDY              0x800\n\n\ntypedef struct RE RE;\ntypedef struct RE_AST RE_AST;\ntypedef struct RE_NODE RE_NODE;\ntypedef struct RE_ERROR RE_ERROR;\n\ntypedef uint8_t RE_SPLIT_ID_TYPE;\n\n\n#define CHAR_IN_CLASS(chr, cls)  \\\n    ((cls)[(chr) / 8] & 1 << ((chr) % 8))\n\n\n#define IS_WORD_CHAR(chr) \\\n    (isalnum(chr) || (chr) == '_')\n\n\nstruct RE_NODE\n{\n  int type;\n\n  union {\n    int value;\n    int count;\n    int start;\n  };\n\n  union {\n    int mask;\n    int end;\n  };\n\n  int greedy;\n\n  uint8_t* class_vector;\n\n  RE_NODE* left;\n  RE_NODE* right;\n\n  uint8_t* forward_code;\n  uint8_t* backward_code;\n};\n\n\nstruct RE_AST\n{\n  uint32_t flags;\n  RE_NODE* root_node;\n};\n\n\nstruct RE\n{\n  uint32_t flags;\n  uint8_t code[0];\n};\n\n\nstruct RE_ERROR\n{\n  char message[512];\n};\n\n\ntypedef int RE_MATCH_CALLBACK_FUNC(\n    uint8_t* match,\n    int match_length,\n    int flags,\n    void* args);\n\n\nint yr_re_ast_create(\n    RE_AST** re_ast);\n\nvoid yr_re_ast_destroy(\n    RE_AST* re_ast);\n\nvoid yr_re_ast_print(\n    RE_AST* re_ast);\n\nSIZED_STRING* yr_re_ast_extract_literal(\n    RE_AST* re_ast);\n\n\nint yr_re_ast_contains_dot_star(\n    RE_AST* re_ast);\n\n\nint yr_re_ast_split_at_chaining_point(\n    RE_AST* re_ast,\n    RE_AST** result_re_ast,\n    RE_AST** remainder_re_ast,\n    int32_t* min_gap,\n    int32_t* max_gap);\n\n\nint yr_re_ast_emit_code(\n    RE_AST* re_ast,\n    YR_ARENA* arena,\n    int backwards_code);\n\n\nRE_NODE* yr_re_node_create(\n    int type,\n    RE_NODE* left,\n    RE_NODE* right);\n\n\nvoid yr_re_node_destroy(\n    RE_NODE* node);\n\n\nint yr_re_exec(\n    uint8_t* re_code,\n    uint8_t* input,\n    size_t input_size,\n    int flags,\n    RE_MATCH_CALLBACK_FUNC callback,\n    void* callback_args);\n\n\nint yr_re_fast_exec(\n    uint8_t* re_code,\n    uint8_t* input,\n    size_t input_size,\n    int flags,\n    RE_MATCH_CALLBACK_FUNC callback,\n    void* callback_args);\n\n\nint yr_re_parse(\n    const char* re_string,\n    RE_AST** re_ast,\n    RE_ERROR* error);\n\n\nint yr_re_parse_hex(\n    const char* hex_string,\n    RE_AST** re_ast,\n    RE_ERROR* error);\n\n\nint yr_re_compile(\n    const char* re_string,\n    int flags,\n    YR_ARENA* code_arena,\n    RE** re,\n    RE_ERROR* error);\n\n\nint yr_re_match(\n    RE* re,\n    const char* target);\n\n\nint yr_re_initialize(void);\n\n\nint yr_re_finalize(void);\n\n\nint yr_re_finalize_thread(void);\n\n#endif\n", "/*\nCopyright (c) 2013. The YARA Authors. All Rights Reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\nlist of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors\nmay be used to endorse or promote products derived from this software without\nspecific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\n/*\n\nThis module implements a regular expressions engine based on Thompson's\nalgorithm as described by Russ Cox in http://swtch.com/~rsc/regexp/regexp2.html.\n\nWhat the article names a \"thread\" has been named a \"fiber\" in this code, in\norder to avoid confusion with operating system threads.\n\n*/\n\n#include <assert.h>\n#include <string.h>\n#include <limits.h>\n\n#include <yara/limits.h>\n#include <yara/globals.h>\n#include <yara/utils.h>\n#include <yara/mem.h>\n#include <yara/re.h>\n#include <yara/error.h>\n#include <yara/threading.h>\n#include <yara/re_lexer.h>\n#include <yara/hex_lexer.h>\n\n// Maximum allowed split ID, also limiting the number of split instructions\n// allowed in a regular expression. This number can't be increased\n// over 255 without changing RE_SPLIT_ID_TYPE.\n#define RE_MAX_SPLIT_ID     128\n\n// Maximum stack size for regexp evaluation\n#define RE_MAX_STACK      1024\n\n// Maximum code size for a compiled regexp\n#define RE_MAX_CODE_SIZE  32768\n\n// Maximum input size scanned by yr_re_exec\n#define RE_SCAN_LIMIT     4096\n\n// Maximum number of fibers\n#define RE_MAX_FIBERS     1024\n\n\n#define EMIT_BACKWARDS                  0x01\n#define EMIT_DONT_SET_FORWARDS_CODE     0x02\n#define EMIT_DONT_SET_BACKWARDS_CODE    0x04\n\n\ntypedef struct _RE_REPEAT_ARGS\n{\n  uint16_t  min;\n  uint16_t  max;\n  int32_t   offset;\n\n} RE_REPEAT_ARGS;\n\n\ntypedef struct _RE_REPEAT_ANY_ARGS\n{\n  uint16_t   min;\n  uint16_t   max;\n\n} RE_REPEAT_ANY_ARGS;\n\n\ntypedef struct _RE_EMIT_CONTEXT {\n\n  YR_ARENA*         arena;\n  RE_SPLIT_ID_TYPE  next_split_id;\n\n} RE_EMIT_CONTEXT;\n\n\ntypedef struct _RE_FIBER\n{\n  uint8_t* ip;    // instruction pointer\n  int32_t  sp;    // stack pointer\n  int32_t  rc;    // repeat counter\n\n  uint16_t stack[RE_MAX_STACK];\n\n  struct _RE_FIBER* prev;\n  struct _RE_FIBER* next;\n\n} RE_FIBER;\n\n\ntypedef struct _RE_FIBER_LIST\n{\n  RE_FIBER* head;\n  RE_FIBER* tail;\n\n} RE_FIBER_LIST;\n\n\ntypedef struct _RE_FIBER_POOL\n{\n  int fiber_count;\n  RE_FIBER_LIST fibers;\n\n} RE_FIBER_POOL;\n\n\ntypedef struct _RE_THREAD_STORAGE\n{\n  RE_FIBER_POOL fiber_pool;\n\n} RE_THREAD_STORAGE;\n\n\nYR_THREAD_STORAGE_KEY thread_storage_key = 0;\n\n\n//\n// yr_re_initialize\n//\n// Should be called by main thread before any other\n// function from this module.\n//\n\nint yr_re_initialize(void)\n{\n  return yr_thread_storage_create(&thread_storage_key);\n}\n\n//\n// yr_re_finalize\n//\n// Should be called by main thread after every other thread\n// stopped using functions from this module.\n//\n\nint yr_re_finalize(void)\n{\n  yr_thread_storage_destroy(&thread_storage_key);\n\n  thread_storage_key = 0;\n  return ERROR_SUCCESS;\n}\n\n//\n// yr_re_finalize_thread\n//\n// Should be called by every thread using this module\n// before exiting.\n//\n\nint yr_re_finalize_thread(void)\n{\n  RE_FIBER* fiber;\n  RE_FIBER* next_fiber;\n  RE_THREAD_STORAGE* storage;\n\n  if (thread_storage_key != 0)\n    storage = (RE_THREAD_STORAGE*) yr_thread_storage_get_value(\n        &thread_storage_key);\n  else\n    return ERROR_SUCCESS;\n\n  if (storage != NULL)\n  {\n    fiber = storage->fiber_pool.fibers.head;\n\n    while (fiber != NULL)\n    {\n      next_fiber = fiber->next;\n      yr_free(fiber);\n      fiber = next_fiber;\n    }\n\n    yr_free(storage);\n  }\n\n  return yr_thread_storage_set_value(&thread_storage_key, NULL);\n}\n\n\nRE_NODE* yr_re_node_create(\n    int type,\n    RE_NODE* left,\n    RE_NODE* right)\n{\n  RE_NODE* result = (RE_NODE*) yr_malloc(sizeof(RE_NODE));\n\n  if (result != NULL)\n  {\n    result->type = type;\n    result->left = left;\n    result->right = right;\n    result->greedy = TRUE;\n    result->forward_code = NULL;\n    result->backward_code = NULL;\n  }\n\n  return result;\n}\n\n\nvoid yr_re_node_destroy(\n    RE_NODE* node)\n{\n  if (node->left != NULL)\n    yr_re_node_destroy(node->left);\n\n  if (node->right != NULL)\n    yr_re_node_destroy(node->right);\n\n  if (node->type == RE_NODE_CLASS)\n    yr_free(node->class_vector);\n\n  yr_free(node);\n}\n\n\nint yr_re_ast_create(\n    RE_AST** re_ast)\n{\n  *re_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));\n\n  if (*re_ast == NULL)\n    return ERROR_INSUFFICIENT_MEMORY;\n\n  (*re_ast)->flags = 0;\n  (*re_ast)->root_node = NULL;\n\n  return ERROR_SUCCESS;\n}\n\n\nvoid yr_re_ast_destroy(\n    RE_AST* re_ast)\n{\n  if (re_ast->root_node != NULL)\n    yr_re_node_destroy(re_ast->root_node);\n\n  yr_free(re_ast);\n}\n\n\n//\n// yr_re_parse\n//\n// Parses a regexp but don't emit its code. A further call to\n// yr_re_emit_code is required to get the code.\n//\n\nint yr_re_parse(\n    const char* re_string,\n    RE_AST** re_ast,\n    RE_ERROR* error)\n{\n  return yr_parse_re_string(re_string, re_ast, error);\n}\n\n\n//\n// yr_re_parse_hex\n//\n// Parses a hex string but don't emit its code. A further call to\n// yr_re_emit_code is required to get the code.\n//\n\nint yr_re_parse_hex(\n    const char* hex_string,\n    RE_AST** re_ast,\n    RE_ERROR* error)\n{\n  return yr_parse_hex_string(hex_string, re_ast, error);\n}\n\n\n//\n// yr_re_compile\n//\n// Parses the regexp and emit its code to the provided code_arena.\n//\n\nint yr_re_compile(\n    const char* re_string,\n    int flags,\n    YR_ARENA* code_arena,\n    RE** re,\n    RE_ERROR* error)\n{\n  RE_AST* re_ast;\n  RE _re;\n\n  FAIL_ON_ERROR(yr_arena_reserve_memory(\n      code_arena, sizeof(int64_t) + RE_MAX_CODE_SIZE));\n\n  FAIL_ON_ERROR(yr_re_parse(re_string, &re_ast, error));\n\n  _re.flags = flags;\n\n  FAIL_ON_ERROR_WITH_CLEANUP(\n      yr_arena_write_data(\n          code_arena,\n          &_re,\n          sizeof(_re),\n          (void**) re),\n      yr_re_ast_destroy(re_ast));\n\n  FAIL_ON_ERROR_WITH_CLEANUP(\n      yr_re_ast_emit_code(re_ast, code_arena, FALSE),\n      yr_re_ast_destroy(re_ast));\n\n  yr_re_ast_destroy(re_ast);\n\n  return ERROR_SUCCESS;\n}\n\n\n//\n// yr_re_match\n//\n// Verifies if the target string matches the pattern\n//\n// Args:\n//    RE* re          -  A pointer to a compiled regexp\n//    char* target    -  Target string\n//\n// Returns:\n//    See return codes for yr_re_exec\n\n\nint yr_re_match(\n    RE* re,\n    const char* target)\n{\n  return yr_re_exec(\n      re->code,\n      (uint8_t*) target,\n      strlen(target),\n      re->flags | RE_FLAGS_SCAN,\n      NULL,\n      NULL);\n}\n\n\n//\n// yr_re_ast_extract_literal\n//\n// Verifies if the provided regular expression is just a literal string\n// like \"abc\", \"12345\", without any wildcard, operator, etc. In that case\n// returns the string as a SIZED_STRING, or returns NULL if otherwise.\n//\n// The caller is responsible for deallocating the returned SIZED_STRING by\n// calling yr_free.\n//\n\nSIZED_STRING* yr_re_ast_extract_literal(\n    RE_AST* re_ast)\n{\n  SIZED_STRING* string;\n  RE_NODE* node = re_ast->root_node;\n\n  int i, length = 0;\n  char tmp;\n\n  while (node != NULL)\n  {\n    length++;\n\n    if (node->type == RE_NODE_LITERAL)\n      break;\n\n    if (node->type != RE_NODE_CONCAT)\n      return NULL;\n\n    if (node->right == NULL ||\n        node->right->type != RE_NODE_LITERAL)\n      return NULL;\n\n    node = node->left;\n  }\n\n  string = (SIZED_STRING*) yr_malloc(sizeof(SIZED_STRING) + length);\n\n  if (string == NULL)\n    return NULL;\n\n  string->length = 0;\n\n  node = re_ast->root_node;\n\n  while (node->type == RE_NODE_CONCAT)\n  {\n    string->c_string[string->length++] = node->right->value;\n    node = node->left;\n  }\n\n  string->c_string[string->length++] = node->value;\n\n  // The string ends up reversed. Reverse it back to its original value.\n\n  for (i = 0; i < length / 2; i++)\n  {\n    tmp = string->c_string[i];\n    string->c_string[i] = string->c_string[length - i - 1];\n    string->c_string[length - i - 1] = tmp;\n  }\n\n  return string;\n}\n\n\nint _yr_re_node_contains_dot_star(\n    RE_NODE* re_node)\n{\n  if (re_node->type == RE_NODE_STAR && re_node->left->type == RE_NODE_ANY)\n    return TRUE;\n\n  if (re_node->left != NULL && _yr_re_node_contains_dot_star(re_node->left))\n    return TRUE;\n\n  if (re_node->right != NULL && _yr_re_node_contains_dot_star(re_node->right))\n    return TRUE;\n\n  return FALSE;\n}\n\n\nint yr_re_ast_contains_dot_star(\n    RE_AST* re_ast)\n{\n  return _yr_re_node_contains_dot_star(re_ast->root_node);\n}\n\n\n//\n// yr_re_ast_split_at_chaining_point\n//\n// In some cases splitting a regular expression in two is more efficient that\n// having a single regular expression. This happens when the regular expression\n// contains a large repetition of any character, for example: /foo.{0,1000}bar/\n// In this case the regexp is split in /foo/ and /bar/ where /bar/ is \"chained\"\n// to /foo/. This means that /foo/ and /bar/ are handled as individual regexps\n// and when both matches YARA verifies if the distance between the matches\n// complies with the {0,1000} restriction.\n\n// This function traverses the regexp's tree looking for nodes where the regxp\n// should be split. It expects a left-unbalanced tree where the right child of\n// a RE_NODE_CONCAT can't be another RE_NODE_CONCAT. A RE_NODE_CONCAT must be\n// always the left child of its parent if the parent is also a RE_NODE_CONCAT.\n//\n\nint yr_re_ast_split_at_chaining_point(\n    RE_AST* re_ast,\n    RE_AST** result_re_ast,\n    RE_AST** remainder_re_ast,\n    int32_t* min_gap,\n    int32_t* max_gap)\n{\n  RE_NODE* node = re_ast->root_node;\n  RE_NODE* child = re_ast->root_node->left;\n  RE_NODE* parent = NULL;\n\n  int result;\n\n  *result_re_ast = re_ast;\n  *remainder_re_ast = NULL;\n  *min_gap = 0;\n  *max_gap = 0;\n\n  while (child != NULL && child->type == RE_NODE_CONCAT)\n  {\n    if (child->right != NULL &&\n        child->right->type == RE_NODE_RANGE_ANY &&\n        child->right->greedy == FALSE &&\n        (child->right->start > STRING_CHAINING_THRESHOLD ||\n         child->right->end > STRING_CHAINING_THRESHOLD))\n    {\n      result = yr_re_ast_create(remainder_re_ast);\n\n      if (result != ERROR_SUCCESS)\n        return result;\n\n      (*remainder_re_ast)->root_node = child->left;\n      (*remainder_re_ast)->flags = re_ast->flags;\n\n      child->left = NULL;\n\n      if (parent != NULL)\n        parent->left = node->right;\n      else\n        (*result_re_ast)->root_node = node->right;\n\n      node->right = NULL;\n\n      *min_gap = child->right->start;\n      *max_gap = child->right->end;\n\n      yr_re_node_destroy(node);\n\n      return ERROR_SUCCESS;\n    }\n\n    parent = node;\n    node = child;\n    child = child->left;\n  }\n\n  return ERROR_SUCCESS;\n}\n\n\nint _yr_emit_inst(\n    RE_EMIT_CONTEXT* emit_context,\n    uint8_t opcode,\n    uint8_t** instruction_addr,\n    int* code_size)\n{\n  FAIL_ON_ERROR(yr_arena_write_data(\n      emit_context->arena,\n      &opcode,\n      sizeof(uint8_t),\n      (void**) instruction_addr));\n\n  *code_size = sizeof(uint8_t);\n\n  return ERROR_SUCCESS;\n}\n\n\nint _yr_emit_inst_arg_uint8(\n    RE_EMIT_CONTEXT* emit_context,\n    uint8_t opcode,\n    uint8_t argument,\n    uint8_t** instruction_addr,\n    uint8_t** argument_addr,\n    int* code_size)\n{\n  FAIL_ON_ERROR(yr_arena_write_data(\n      emit_context->arena,\n      &opcode,\n      sizeof(uint8_t),\n      (void**) instruction_addr));\n\n  FAIL_ON_ERROR(yr_arena_write_data(\n      emit_context->arena,\n      &argument,\n      sizeof(uint8_t),\n      (void**) argument_addr));\n\n  *code_size = 2 * sizeof(uint8_t);\n\n  return ERROR_SUCCESS;\n}\n\n\nint _yr_emit_inst_arg_uint16(\n    RE_EMIT_CONTEXT* emit_context,\n    uint8_t opcode,\n    uint16_t argument,\n    uint8_t** instruction_addr,\n    uint16_t** argument_addr,\n    int* code_size)\n{\n  FAIL_ON_ERROR(yr_arena_write_data(\n      emit_context->arena,\n      &opcode,\n      sizeof(uint8_t),\n      (void**) instruction_addr));\n\n  FAIL_ON_ERROR(yr_arena_write_data(\n      emit_context->arena,\n      &argument,\n      sizeof(uint16_t),\n      (void**) argument_addr));\n\n  *code_size = sizeof(uint8_t) + sizeof(uint16_t);\n\n  return ERROR_SUCCESS;\n}\n\n\nint _yr_emit_inst_arg_uint32(\n    RE_EMIT_CONTEXT* emit_context,\n    uint8_t opcode,\n    uint32_t argument,\n    uint8_t** instruction_addr,\n    uint32_t** argument_addr,\n    int* code_size)\n{\n  FAIL_ON_ERROR(yr_arena_write_data(\n      emit_context->arena,\n      &opcode,\n      sizeof(uint8_t),\n      (void**) instruction_addr));\n\n  FAIL_ON_ERROR(yr_arena_write_data(\n      emit_context->arena,\n      &argument,\n      sizeof(uint32_t),\n      (void**) argument_addr));\n\n  *code_size = sizeof(uint8_t) + sizeof(uint32_t);\n\n  return ERROR_SUCCESS;\n}\n\n\nint _yr_emit_inst_arg_int16(\n    RE_EMIT_CONTEXT* emit_context,\n    uint8_t opcode,\n    int16_t argument,\n    uint8_t** instruction_addr,\n    int16_t** argument_addr,\n    int* code_size)\n{\n  FAIL_ON_ERROR(yr_arena_write_data(\n      emit_context->arena,\n      &opcode,\n      sizeof(uint8_t),\n      (void**) instruction_addr));\n\n  FAIL_ON_ERROR(yr_arena_write_data(\n      emit_context->arena,\n      &argument,\n      sizeof(int16_t),\n      (void**) argument_addr));\n\n  *code_size = sizeof(uint8_t) + sizeof(int16_t);\n\n  return ERROR_SUCCESS;\n}\n\n\nint _yr_emit_inst_arg_struct(\n    RE_EMIT_CONTEXT* emit_context,\n    uint8_t opcode,\n    void* structure,\n    size_t structure_size,\n    uint8_t** instruction_addr,\n    void** argument_addr,\n    int* code_size)\n{\n  FAIL_ON_ERROR(yr_arena_write_data(\n      emit_context->arena,\n      &opcode,\n      sizeof(uint8_t),\n      (void**) instruction_addr));\n\n  FAIL_ON_ERROR(yr_arena_write_data(\n      emit_context->arena,\n      structure,\n      structure_size,\n      (void**) argument_addr));\n\n  *code_size = sizeof(uint8_t) + structure_size;\n\n  return ERROR_SUCCESS;\n}\n\n\nint _yr_emit_split(\n    RE_EMIT_CONTEXT* emit_context,\n    uint8_t opcode,\n    int16_t argument,\n    uint8_t** instruction_addr,\n    int16_t** argument_addr,\n    int* code_size)\n{\n  assert(opcode == RE_OPCODE_SPLIT_A || opcode == RE_OPCODE_SPLIT_B);\n\n  if (emit_context->next_split_id == RE_MAX_SPLIT_ID)\n    return ERROR_REGULAR_EXPRESSION_TOO_COMPLEX;\n\n  FAIL_ON_ERROR(yr_arena_write_data(\n      emit_context->arena,\n      &opcode,\n      sizeof(uint8_t),\n      (void**) instruction_addr));\n\n  FAIL_ON_ERROR(yr_arena_write_data(\n      emit_context->arena,\n      &emit_context->next_split_id,\n      sizeof(RE_SPLIT_ID_TYPE),\n      NULL));\n\n  emit_context->next_split_id++;\n\n  FAIL_ON_ERROR(yr_arena_write_data(\n      emit_context->arena,\n      &argument,\n      sizeof(int16_t),\n      (void**) argument_addr));\n\n  *code_size = sizeof(uint8_t) + sizeof(RE_SPLIT_ID_TYPE) + sizeof(int16_t);\n\n  return ERROR_SUCCESS;\n}\n\n\nint _yr_re_emit(\n    RE_EMIT_CONTEXT* emit_context,\n    RE_NODE* re_node,\n    int flags,\n    uint8_t** code_addr,\n    int* code_size)\n{\n  int branch_size;\n  int split_size;\n  int inst_size;\n  int jmp_size;\n\n  int emit_split;\n  int emit_repeat;\n  int emit_prolog;\n  int emit_epilog;\n\n  RE_REPEAT_ARGS repeat_args;\n  RE_REPEAT_ARGS* repeat_start_args_addr;\n  RE_REPEAT_ANY_ARGS repeat_any_args;\n\n  RE_NODE* left;\n  RE_NODE* right;\n\n  int16_t* split_offset_addr = NULL;\n  int16_t* jmp_offset_addr = NULL;\n  uint8_t* instruction_addr = NULL;\n\n  *code_size = 0;\n\n  switch(re_node->type)\n  {\n  case RE_NODE_LITERAL:\n\n    FAIL_ON_ERROR(_yr_emit_inst_arg_uint8(\n        emit_context,\n        RE_OPCODE_LITERAL,\n        re_node->value,\n        &instruction_addr,\n        NULL,\n        code_size));\n    break;\n\n  case RE_NODE_MASKED_LITERAL:\n\n    FAIL_ON_ERROR(_yr_emit_inst_arg_uint16(\n        emit_context,\n        RE_OPCODE_MASKED_LITERAL,\n        re_node->mask << 8 | re_node->value,\n        &instruction_addr,\n        NULL,\n        code_size));\n    break;\n\n  case RE_NODE_WORD_CHAR:\n\n    FAIL_ON_ERROR(_yr_emit_inst(\n        emit_context,\n        RE_OPCODE_WORD_CHAR,\n        &instruction_addr,\n        code_size));\n    break;\n\n  case RE_NODE_NON_WORD_CHAR:\n\n    FAIL_ON_ERROR(_yr_emit_inst(\n        emit_context,\n        RE_OPCODE_NON_WORD_CHAR,\n        &instruction_addr,\n        code_size));\n    break;\n\n  case RE_NODE_WORD_BOUNDARY:\n\n    FAIL_ON_ERROR(_yr_emit_inst(\n        emit_context,\n        RE_OPCODE_WORD_BOUNDARY,\n        &instruction_addr,\n        code_size));\n    break;\n\n  case RE_NODE_NON_WORD_BOUNDARY:\n\n    FAIL_ON_ERROR(_yr_emit_inst(\n        emit_context,\n        RE_OPCODE_NON_WORD_BOUNDARY,\n        &instruction_addr,\n        code_size));\n    break;\n\n  case RE_NODE_SPACE:\n\n    FAIL_ON_ERROR(_yr_emit_inst(\n        emit_context,\n        RE_OPCODE_SPACE,\n        &instruction_addr,\n        code_size));\n    break;\n\n  case RE_NODE_NON_SPACE:\n\n    FAIL_ON_ERROR(_yr_emit_inst(\n        emit_context,\n        RE_OPCODE_NON_SPACE,\n        &instruction_addr,\n        code_size));\n    break;\n\n  case RE_NODE_DIGIT:\n\n    FAIL_ON_ERROR(_yr_emit_inst(\n        emit_context,\n        RE_OPCODE_DIGIT,\n        &instruction_addr,\n        code_size));\n    break;\n\n  case RE_NODE_NON_DIGIT:\n\n    FAIL_ON_ERROR(_yr_emit_inst(\n        emit_context,\n        RE_OPCODE_NON_DIGIT,\n        &instruction_addr,\n        code_size));\n    break;\n\n  case RE_NODE_ANY:\n\n    FAIL_ON_ERROR(_yr_emit_inst(\n        emit_context,\n        RE_OPCODE_ANY,\n        &instruction_addr,\n        code_size));\n    break;\n\n  case RE_NODE_CLASS:\n\n    FAIL_ON_ERROR(_yr_emit_inst(\n        emit_context,\n        RE_OPCODE_CLASS,\n        &instruction_addr,\n        code_size));\n\n    FAIL_ON_ERROR(yr_arena_write_data(\n        emit_context->arena,\n        re_node->class_vector,\n        32,\n        NULL));\n\n    *code_size += 32;\n    break;\n\n  case RE_NODE_ANCHOR_START:\n\n    FAIL_ON_ERROR(_yr_emit_inst(\n        emit_context,\n        RE_OPCODE_MATCH_AT_START,\n        &instruction_addr,\n        code_size));\n    break;\n\n  case RE_NODE_ANCHOR_END:\n\n    FAIL_ON_ERROR(_yr_emit_inst(\n        emit_context,\n        RE_OPCODE_MATCH_AT_END,\n        &instruction_addr,\n        code_size));\n    break;\n\n  case RE_NODE_CONCAT:\n\n    if (flags & EMIT_BACKWARDS)\n    {\n      left = re_node->right;\n      right = re_node->left;\n    }\n    else\n    {\n      left = re_node->left;\n      right = re_node->right;\n    }\n\n    FAIL_ON_ERROR(_yr_re_emit(\n        emit_context,\n        left,\n        flags,\n        &instruction_addr,\n        &branch_size));\n\n    *code_size += branch_size;\n\n    FAIL_ON_ERROR(_yr_re_emit(\n        emit_context,\n        right,\n        flags,\n        NULL,\n        &branch_size));\n\n    *code_size += branch_size;\n\n    break;\n\n  case RE_NODE_PLUS:\n\n    // Code for e+ looks like:\n    //\n    //          L1: code for e\n    //              split L1, L2\n    //          L2:\n\n    FAIL_ON_ERROR(_yr_re_emit(\n        emit_context,\n        re_node->left,\n        flags,\n        &instruction_addr,\n        &branch_size));\n\n    *code_size += branch_size;\n\n    FAIL_ON_ERROR(_yr_emit_split(\n        emit_context,\n        re_node->greedy ? RE_OPCODE_SPLIT_B : RE_OPCODE_SPLIT_A,\n        -branch_size,\n        NULL,\n        &split_offset_addr,\n        &split_size));\n\n    *code_size += split_size;\n    break;\n\n  case RE_NODE_STAR:\n\n    // Code for e* looks like:\n    //\n    //          L1: split L1, L2\n    //              code for e\n    //              jmp L1\n    //          L2:\n\n    FAIL_ON_ERROR(_yr_emit_split(\n        emit_context,\n        re_node->greedy ? RE_OPCODE_SPLIT_A : RE_OPCODE_SPLIT_B,\n        0,\n        &instruction_addr,\n        &split_offset_addr,\n        &split_size));\n\n    *code_size += split_size;\n\n    FAIL_ON_ERROR(_yr_re_emit(\n        emit_context,\n        re_node->left,\n        flags,\n        NULL,\n        &branch_size));\n\n    *code_size += branch_size;\n\n    // Emit jump with offset set to 0.\n\n    FAIL_ON_ERROR(_yr_emit_inst_arg_int16(\n        emit_context,\n        RE_OPCODE_JUMP,\n        -(branch_size + split_size),\n        NULL,\n        &jmp_offset_addr,\n        &jmp_size));\n\n    *code_size += jmp_size;\n\n    // Update split offset.\n    *split_offset_addr = split_size + branch_size + jmp_size;\n    break;\n\n  case RE_NODE_ALT:\n\n    // Code for e1|e2 looks like:\n    //\n    //              split L1, L2\n    //          L1: code for e1\n    //              jmp L3\n    //          L2: code for e2\n    //          L3:\n\n    // Emit a split instruction with offset set to 0 temporarily. Offset\n    // will be updated after we know the size of the code generated for\n    // the left node (e1).\n\n    FAIL_ON_ERROR(_yr_emit_split(\n        emit_context,\n        RE_OPCODE_SPLIT_A,\n        0,\n        &instruction_addr,\n        &split_offset_addr,\n        &split_size));\n\n    *code_size += split_size;\n\n    FAIL_ON_ERROR(_yr_re_emit(\n        emit_context,\n        re_node->left,\n        flags,\n        NULL,\n        &branch_size));\n\n    *code_size += branch_size;\n\n    // Emit jump with offset set to 0.\n\n    FAIL_ON_ERROR(_yr_emit_inst_arg_int16(\n        emit_context,\n        RE_OPCODE_JUMP,\n        0,\n        NULL,\n        &jmp_offset_addr,\n        &jmp_size));\n\n    *code_size += jmp_size;\n\n    // Update split offset.\n    *split_offset_addr = split_size + branch_size + jmp_size;\n\n    FAIL_ON_ERROR(_yr_re_emit(\n        emit_context,\n        re_node->right,\n        flags,\n        NULL,\n        &branch_size));\n\n    *code_size += branch_size;\n\n    // Update offset for jmp instruction.\n    *jmp_offset_addr = branch_size + jmp_size;\n    break;\n\n  case RE_NODE_RANGE_ANY:\n\n    repeat_any_args.min = re_node->start;\n    repeat_any_args.max = re_node->end;\n\n    FAIL_ON_ERROR(_yr_emit_inst_arg_struct(\n        emit_context,\n        re_node->greedy ?\n            RE_OPCODE_REPEAT_ANY_GREEDY :\n            RE_OPCODE_REPEAT_ANY_UNGREEDY,\n        &repeat_any_args,\n        sizeof(repeat_any_args),\n        &instruction_addr,\n        NULL,\n        &inst_size));\n\n    *code_size += inst_size;\n    break;\n\n  case RE_NODE_RANGE:\n\n    // Code for e{n,m} looks like:\n    //\n    //            code for e              ---   prolog\n    //            repeat_start n, m, L1   --+\n    //        L0: code for e                |   repeat\n    //            repeat_end n, m, L0     --+\n    //        L1: split L2, L3            ---   split\n    //        L2: code for e              ---   epilog\n    //        L3:\n    //\n    // Not all sections (prolog, repeat, split and epilog) are generated in all\n    // cases, it depends on the values of n and m. The following table shows\n    // which sections are generated for the first few values of n and m.\n    //\n    //        n,m   prolog  repeat      split  epilog\n    //                      (min,max)\n    //        ---------------------------------------\n    //        0,0     -       -           -      -\n    //        0,1     -       -           X      X\n    //        0,2     -       0,1         X      X\n    //        0,3     -       0,2         X      X\n    //        0,M     -       0,M-1       X      X\n    //\n    //        1,1     X       -           -      -\n    //        1,2     X       -           X      X\n    //        1,3     X       0,1         X      X\n    //        1,4     X       1,2         X      X\n    //        1,M     X       1,M-2       X      X\n    //\n    //        2,2     X       -           -      X\n    //        2,3     X       1,1         X      X\n    //        2,4     X       1,2         X      X\n    //        2,M     X       1,M-2       X      X\n    //\n    //        3,3     X       1,1         -      X\n    //        3,4     X       2,2         X      X\n    //        3,M     X       2,M-1       X      X\n    //\n    // The code can't consists simply in the repeat section, the prolog and\n    // epilog are required because we can't have atoms pointing to code inside\n    // the repeat loop. Atoms' forwards_code will point to code in the prolog\n    // and backwards_code will point to code in the epilog (or in prolog if\n    // epilog wasn't generated, like in n=1,m=1)\n\n    emit_prolog = re_node->start > 0;\n    emit_repeat = re_node->end > re_node->start + 1 || re_node->end > 2;\n    emit_split = re_node->end > re_node->start;\n    emit_epilog = re_node->end > re_node->start || re_node->end > 1;\n\n    if (emit_prolog)\n    {\n      FAIL_ON_ERROR(_yr_re_emit(\n          emit_context,\n          re_node->left,\n          flags,\n          &instruction_addr,\n          &branch_size));\n\n       *code_size += branch_size;\n    }\n\n    if (emit_repeat)\n    {\n      repeat_args.min = re_node->start;\n      repeat_args.max = re_node->end;\n\n      if (emit_prolog)\n      {\n        repeat_args.max--;\n        repeat_args.min--;\n      }\n\n      if (emit_split)\n        repeat_args.max--;\n      else\n        repeat_args.min--;\n\n      repeat_args.offset = 0;\n\n      FAIL_ON_ERROR(_yr_emit_inst_arg_struct(\n          emit_context,\n          re_node->greedy ?\n              RE_OPCODE_REPEAT_START_GREEDY :\n              RE_OPCODE_REPEAT_START_UNGREEDY,\n          &repeat_args,\n          sizeof(repeat_args),\n          emit_prolog ? NULL : &instruction_addr,\n          (void**) &repeat_start_args_addr,\n          &inst_size));\n\n      *code_size += inst_size;\n\n      FAIL_ON_ERROR(_yr_re_emit(\n          emit_context,\n          re_node->left,\n          flags | EMIT_DONT_SET_FORWARDS_CODE | EMIT_DONT_SET_BACKWARDS_CODE,\n          NULL,\n          &branch_size));\n\n      *code_size += branch_size;\n\n      repeat_start_args_addr->offset = 2 * inst_size + branch_size;\n      repeat_args.offset = -branch_size;\n\n      FAIL_ON_ERROR(_yr_emit_inst_arg_struct(\n          emit_context,\n          re_node->greedy ?\n              RE_OPCODE_REPEAT_END_GREEDY :\n              RE_OPCODE_REPEAT_END_UNGREEDY,\n          &repeat_args,\n          sizeof(repeat_args),\n          NULL,\n          NULL,\n          &inst_size));\n\n      *code_size += inst_size;\n    }\n\n    if (emit_split)\n    {\n      FAIL_ON_ERROR(_yr_emit_split(\n          emit_context,\n          re_node->greedy ?\n              RE_OPCODE_SPLIT_A :\n              RE_OPCODE_SPLIT_B,\n          0,\n          NULL,\n          &split_offset_addr,\n          &split_size));\n\n      *code_size += split_size;\n    }\n\n    if (emit_epilog)\n    {\n      FAIL_ON_ERROR(_yr_re_emit(\n          emit_context,\n          re_node->left,\n          emit_prolog ? flags | EMIT_DONT_SET_FORWARDS_CODE : flags,\n          emit_prolog || emit_repeat ? NULL : &instruction_addr,\n          &branch_size));\n\n      *code_size += branch_size;\n    }\n\n    if (emit_split)\n      *split_offset_addr = split_size + branch_size;\n\n    break;\n  }\n\n  if (flags & EMIT_BACKWARDS)\n  {\n    if (!(flags & EMIT_DONT_SET_BACKWARDS_CODE))\n      re_node->backward_code = instruction_addr + *code_size;\n  }\n  else\n  {\n    if (!(flags & EMIT_DONT_SET_FORWARDS_CODE))\n      re_node->forward_code = instruction_addr;\n  }\n\n  if (code_addr != NULL)\n    *code_addr = instruction_addr;\n\n  return ERROR_SUCCESS;\n}\n\n\nint yr_re_ast_emit_code(\n    RE_AST* re_ast,\n    YR_ARENA* arena,\n    int backwards_code)\n{\n  RE_EMIT_CONTEXT emit_context;\n\n  int code_size;\n  int total_size;\n\n  // Ensure that we have enough contiguous memory space in the arena to\n  // contain the regular expression code. The code can't span over multiple\n  // non-contiguous pages.\n\n  FAIL_ON_ERROR(yr_arena_reserve_memory(arena, RE_MAX_CODE_SIZE));\n\n  // Emit code for matching the regular expressions forwards.\n\n  total_size = 0;\n  emit_context.arena = arena;\n  emit_context.next_split_id = 0;\n\n  FAIL_ON_ERROR(_yr_re_emit(\n      &emit_context,\n      re_ast->root_node,\n      backwards_code ? EMIT_BACKWARDS : 0,\n      NULL,\n      &code_size));\n\n  total_size += code_size;\n\n  FAIL_ON_ERROR(_yr_emit_inst(\n      &emit_context,\n      RE_OPCODE_MATCH,\n      NULL,\n      &code_size));\n\n  total_size += code_size;\n\n  if (total_size > RE_MAX_CODE_SIZE)\n    return ERROR_REGULAR_EXPRESSION_TOO_LARGE;\n\n  return ERROR_SUCCESS;\n}\n\n\nint _yr_re_alloc_storage(\n    RE_THREAD_STORAGE** storage)\n{\n  *storage = (RE_THREAD_STORAGE*) yr_thread_storage_get_value(\n      &thread_storage_key);\n\n  if (*storage == NULL)\n  {\n    *storage = (RE_THREAD_STORAGE*) yr_malloc(sizeof(RE_THREAD_STORAGE));\n\n    if (*storage == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n\n    (*storage)->fiber_pool.fiber_count = 0;\n    (*storage)->fiber_pool.fibers.head = NULL;\n    (*storage)->fiber_pool.fibers.tail = NULL;\n\n    FAIL_ON_ERROR(\n        yr_thread_storage_set_value(&thread_storage_key, *storage));\n  }\n\n  return ERROR_SUCCESS;\n}\n\n\nint _yr_re_fiber_create(\n    RE_FIBER_POOL* fiber_pool,\n    RE_FIBER** new_fiber)\n{\n  RE_FIBER* fiber;\n\n  if (fiber_pool->fibers.head != NULL)\n  {\n    fiber = fiber_pool->fibers.head;\n    fiber_pool->fibers.head = fiber->next;\n\n    if (fiber_pool->fibers.tail == fiber)\n      fiber_pool->fibers.tail = NULL;\n  }\n  else\n  {\n    if (fiber_pool->fiber_count == RE_MAX_FIBERS)\n      return ERROR_TOO_MANY_RE_FIBERS;\n\n    fiber = (RE_FIBER*) yr_malloc(sizeof(RE_FIBER));\n\n    if (fiber == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n\n    fiber_pool->fiber_count++;\n  }\n\n  fiber->ip = NULL;\n  fiber->sp = -1;\n  fiber->rc = -1;\n  fiber->next = NULL;\n  fiber->prev = NULL;\n\n  *new_fiber = fiber;\n\n  return ERROR_SUCCESS;\n}\n\n\n//\n// _yr_re_fiber_append\n//\n// Appends 'fiber' to 'fiber_list'\n//\n\nvoid _yr_re_fiber_append(\n    RE_FIBER_LIST* fiber_list,\n    RE_FIBER* fiber)\n{\n  assert(fiber->prev == NULL);\n  assert(fiber->next == NULL);\n\n  fiber->prev = fiber_list->tail;\n\n  if (fiber_list->tail != NULL)\n    fiber_list->tail->next = fiber;\n\n  fiber_list->tail = fiber;\n\n  if (fiber_list->head == NULL)\n    fiber_list->head = fiber;\n\n  assert(fiber_list->tail->next == NULL);\n  assert(fiber_list->head->prev == NULL);\n}\n\n\n//\n// _yr_re_fiber_exists\n//\n// Verifies if a fiber with the same properties (ip, rc, sp, and stack values)\n// than 'target_fiber' exists in 'fiber_list'. The list is iterated from\n// the start until 'last_fiber' (inclusive). Fibers past 'last_fiber' are not\n// taken into account.\n//\n\nint _yr_re_fiber_exists(\n    RE_FIBER_LIST* fiber_list,\n    RE_FIBER* target_fiber,\n    RE_FIBER* last_fiber)\n{\n  RE_FIBER* fiber = fiber_list->head;\n\n  int equal_stacks;\n  int i;\n\n\n  if (last_fiber == NULL)\n    return FALSE;\n\n  while (fiber != last_fiber->next)\n  {\n    if (fiber->ip == target_fiber->ip &&\n        fiber->sp == target_fiber->sp &&\n        fiber->rc == target_fiber->rc)\n    {\n      equal_stacks = TRUE;\n\n      for (i = 0; i <= fiber->sp; i++)\n      {\n        if (fiber->stack[i] != target_fiber->stack[i])\n        {\n          equal_stacks = FALSE;\n          break;\n        }\n      }\n\n      if (equal_stacks)\n        return TRUE;\n    }\n\n    fiber = fiber->next;\n  }\n\n  return FALSE;\n}\n\n\n//\n// _yr_re_fiber_split\n//\n// Clones a fiber in fiber_list and inserts the cloned fiber just after.\n// the original one. If fiber_list is:\n//\n//   f1 -> f2 -> f3 -> f4\n//\n// Splitting f2 will result in:\n//\n//   f1 -> f2 -> cloned f2 -> f3 -> f4\n//\n\nint _yr_re_fiber_split(\n    RE_FIBER_LIST* fiber_list,\n    RE_FIBER_POOL* fiber_pool,\n    RE_FIBER* fiber,\n    RE_FIBER** new_fiber)\n{\n  int32_t i;\n\n  FAIL_ON_ERROR(_yr_re_fiber_create(fiber_pool, new_fiber));\n\n  (*new_fiber)->sp = fiber->sp;\n  (*new_fiber)->ip = fiber->ip;\n  (*new_fiber)->rc = fiber->rc;\n\n  for (i = 0; i <= fiber->sp; i++)\n    (*new_fiber)->stack[i] = fiber->stack[i];\n\n  (*new_fiber)->next = fiber->next;\n  (*new_fiber)->prev = fiber;\n\n  if (fiber->next != NULL)\n    fiber->next->prev = *new_fiber;\n\n  fiber->next = *new_fiber;\n\n  if (fiber_list->tail == fiber)\n    fiber_list->tail = *new_fiber;\n\n  assert(fiber_list->tail->next == NULL);\n  assert(fiber_list->head->prev == NULL);\n\n  return ERROR_SUCCESS;\n}\n\n\n//\n// _yr_re_fiber_kill\n//\n// Kills a given fiber by removing it from the fiber list and putting it\n// in the fiber pool.\n//\n\nRE_FIBER* _yr_re_fiber_kill(\n    RE_FIBER_LIST* fiber_list,\n    RE_FIBER_POOL* fiber_pool,\n    RE_FIBER* fiber)\n{\n  RE_FIBER* next_fiber = fiber->next;\n\n  if (fiber->prev != NULL)\n    fiber->prev->next = next_fiber;\n\n  if (next_fiber != NULL)\n    next_fiber->prev = fiber->prev;\n\n  if (fiber_pool->fibers.tail != NULL)\n    fiber_pool->fibers.tail->next = fiber;\n\n  if (fiber_list->tail == fiber)\n    fiber_list->tail = fiber->prev;\n\n  if (fiber_list->head == fiber)\n    fiber_list->head = next_fiber;\n\n  fiber->next = NULL;\n  fiber->prev = fiber_pool->fibers.tail;\n  fiber_pool->fibers.tail = fiber;\n\n  if (fiber_pool->fibers.head == NULL)\n    fiber_pool->fibers.head = fiber;\n\n  return next_fiber;\n}\n\n\n//\n// _yr_re_fiber_kill_tail\n//\n// Kills all fibers from the given one up to the end of the fiber list.\n//\n\nvoid _yr_re_fiber_kill_tail(\n  RE_FIBER_LIST* fiber_list,\n  RE_FIBER_POOL* fiber_pool,\n  RE_FIBER* fiber)\n{\n  RE_FIBER* prev_fiber = fiber->prev;\n\n  if (prev_fiber != NULL)\n    prev_fiber->next = NULL;\n\n  fiber->prev = fiber_pool->fibers.tail;\n\n  if (fiber_pool->fibers.tail != NULL)\n    fiber_pool->fibers.tail->next = fiber;\n\n  fiber_pool->fibers.tail = fiber_list->tail;\n  fiber_list->tail = prev_fiber;\n\n  if (fiber_list->head == fiber)\n    fiber_list->head = NULL;\n\n  if (fiber_pool->fibers.head == NULL)\n    fiber_pool->fibers.head = fiber;\n}\n\n\n//\n// _yr_re_fiber_kill_tail\n//\n// Kills all fibers in the fiber list.\n//\n\nvoid _yr_re_fiber_kill_all(\n    RE_FIBER_LIST* fiber_list,\n    RE_FIBER_POOL* fiber_pool)\n{\n  if (fiber_list->head != NULL)\n    _yr_re_fiber_kill_tail(fiber_list, fiber_pool, fiber_list->head);\n}\n\n\n//\n// _yr_re_fiber_sync\n//\n// Executes a fiber until reaching an \"matching\" instruction. A \"matching\"\n// instruction is one that actually reads a byte from the input and performs\n// some matching. If the fiber reaches a split instruction, the new fiber is\n// also synced.\n//\n\nint _yr_re_fiber_sync(\n    RE_FIBER_LIST* fiber_list,\n    RE_FIBER_POOL* fiber_pool,\n    RE_FIBER* fiber_to_sync)\n{\n  // A array for keeping track of which split instructions has been already\n  // executed. Each split instruction within a regexp has an associated ID\n  // between 0 and RE_MAX_SPLIT_ID. Keeping track of executed splits is\n  // required to avoid infinite loops in regexps like (a*)* or (a|)*\n\n  RE_SPLIT_ID_TYPE splits_executed[RE_MAX_SPLIT_ID];\n  RE_SPLIT_ID_TYPE splits_executed_count = 0;\n  RE_SPLIT_ID_TYPE split_id, splits_executed_idx;\n\n  int split_already_executed;\n\n  RE_REPEAT_ARGS* repeat_args;\n  RE_REPEAT_ANY_ARGS* repeat_any_args;\n\n  RE_FIBER* fiber;\n  RE_FIBER* last;\n  RE_FIBER* prev;\n  RE_FIBER* next;\n  RE_FIBER* branch_a;\n  RE_FIBER* branch_b;\n\n  fiber = fiber_to_sync;\n  prev = fiber_to_sync->prev;\n  last = fiber_to_sync->next;\n\n  while(fiber != last)\n  {\n    uint8_t opcode = *fiber->ip;\n\n    switch(opcode)\n    {\n      case RE_OPCODE_SPLIT_A:\n      case RE_OPCODE_SPLIT_B:\n\n        split_id = *(RE_SPLIT_ID_TYPE*)(fiber->ip + 1);\n        split_already_executed = FALSE;\n\n        for (splits_executed_idx = 0;\n             splits_executed_idx < splits_executed_count;\n             splits_executed_idx++)\n        {\n          if (split_id == splits_executed[splits_executed_idx])\n          {\n            split_already_executed = TRUE;\n            break;\n          }\n        }\n\n        if (split_already_executed)\n        {\n          fiber = _yr_re_fiber_kill(fiber_list, fiber_pool, fiber);\n        }\n        else\n        {\n          branch_a = fiber;\n\n          FAIL_ON_ERROR(_yr_re_fiber_split(\n              fiber_list, fiber_pool, branch_a, &branch_b));\n\n          // With RE_OPCODE_SPLIT_A the current fiber continues at the next\n          // instruction in the stream (branch A), while the newly created\n          // fiber starts at the address indicated by the instruction (branch B)\n          // RE_OPCODE_SPLIT_B has the opposite behavior.\n\n          if (opcode == RE_OPCODE_SPLIT_B)\n            yr_swap(branch_a, branch_b, RE_FIBER*);\n\n          // Branch A continues at the next instruction\n\n          branch_a->ip += (sizeof(RE_SPLIT_ID_TYPE) + 3);\n\n          // Branch B adds the offset encoded in the opcode to its instruction\n          // pointer.\n\n          branch_b->ip += *(int16_t*)(\n              branch_b->ip\n              + 1  // opcode size\n              + sizeof(RE_SPLIT_ID_TYPE));\n\n          splits_executed[splits_executed_count] = split_id;\n          splits_executed_count++;\n        }\n\n        break;\n\n      case RE_OPCODE_REPEAT_START_GREEDY:\n      case RE_OPCODE_REPEAT_START_UNGREEDY:\n\n        repeat_args = (RE_REPEAT_ARGS*)(fiber->ip + 1);\n        assert(repeat_args->max > 0);\n        branch_a = fiber;\n\n        if (repeat_args->min == 0)\n        {\n          FAIL_ON_ERROR(_yr_re_fiber_split(\n              fiber_list, fiber_pool, branch_a, &branch_b));\n\n          if (opcode == RE_OPCODE_REPEAT_START_UNGREEDY)\n            yr_swap(branch_a, branch_b, RE_FIBER*);\n\n          branch_b->ip += repeat_args->offset;\n        }\n\n        branch_a->stack[++branch_a->sp] = 0;\n        branch_a->ip += (1 + sizeof(RE_REPEAT_ARGS));\n        break;\n\n      case RE_OPCODE_REPEAT_END_GREEDY:\n      case RE_OPCODE_REPEAT_END_UNGREEDY:\n\n        repeat_args = (RE_REPEAT_ARGS*)(fiber->ip + 1);\n        fiber->stack[fiber->sp]++;\n\n        if (fiber->stack[fiber->sp] < repeat_args->min)\n        {\n          fiber->ip += repeat_args->offset;\n          break;\n        }\n\n        branch_a = fiber;\n\n        if (fiber->stack[fiber->sp] < repeat_args->max)\n        {\n          FAIL_ON_ERROR(_yr_re_fiber_split(\n              fiber_list, fiber_pool, branch_a, &branch_b));\n\n          if (opcode == RE_OPCODE_REPEAT_END_GREEDY)\n            yr_swap(branch_a, branch_b, RE_FIBER*);\n\n          branch_a->sp--;\n          branch_b->ip += repeat_args->offset;\n        }\n\n        branch_a->ip += (1 + sizeof(RE_REPEAT_ARGS));\n        break;\n\n      case RE_OPCODE_REPEAT_ANY_GREEDY:\n      case RE_OPCODE_REPEAT_ANY_UNGREEDY:\n\n        repeat_any_args = (RE_REPEAT_ANY_ARGS*)(fiber->ip + 1);\n\n        // If repetition counter (rc) is -1 it means that we are reaching this\n        // instruction from the previous one in the instructions stream. In\n        // this case let's initialize the counter to 0 and start looping.\n\n        if (fiber->rc == -1)\n          fiber->rc = 0;\n\n        if (fiber->rc < repeat_any_args->min)\n        {\n          // Increase repetition counter and continue with next fiber. The\n          // instruction pointer for this fiber is not incremented yet, this\n          // fiber spins in this same instruction until reaching the minimum\n          // number of repetitions.\n\n          fiber->rc++;\n          fiber = fiber->next;\n        }\n        else if (fiber->rc < repeat_any_args->max)\n        {\n          // Once the minimum number of repetitions are matched one fiber\n          // remains spinning in this instruction until reaching the maximum\n          // number of repetitions while new fibers are created. New fibers\n          // start executing at the next instruction.\n\n          next = fiber->next;\n          branch_a = fiber;\n\n          FAIL_ON_ERROR(_yr_re_fiber_split(\n              fiber_list, fiber_pool, branch_a, &branch_b));\n\n          if (opcode == RE_OPCODE_REPEAT_ANY_UNGREEDY)\n            yr_swap(branch_a, branch_b, RE_FIBER*);\n\n          branch_a->rc++;\n          branch_b->ip += (1 + sizeof(RE_REPEAT_ANY_ARGS));\n          branch_b->rc = -1;\n\n          _yr_re_fiber_sync(fiber_list, fiber_pool, branch_b);\n\n          fiber = next;\n        }\n        else\n        {\n          // When the maximum number of repetitions is reached the fiber keeps\n          // executing at the next instruction. The repetition counter is set\n          // to -1 indicating that we are not spinning in a repeat instruction\n          // anymore.\n\n          fiber->ip += (1 + sizeof(RE_REPEAT_ANY_ARGS));\n          fiber->rc = -1;\n        }\n\n        break;\n\n      case RE_OPCODE_JUMP:\n        fiber->ip += *(int16_t*)(fiber->ip + 1);\n        break;\n\n      default:\n        if (_yr_re_fiber_exists(fiber_list, fiber, prev))\n          fiber = _yr_re_fiber_kill(fiber_list, fiber_pool, fiber);\n        else\n          fiber = fiber->next;\n    }\n  }\n\n  return ERROR_SUCCESS;\n}\n\n\n//\n// yr_re_exec\n//\n// Executes a regular expression\n//\n// Args:\n//   uint8_t* re_code                 - Regexp code be executed\n//   uint8_t* input                   - Pointer to input data\n//   size_t input_size                - Input data size\n//   int flags                        - Flags:\n//      RE_FLAGS_SCAN\n//      RE_FLAGS_BACKWARDS\n//      RE_FLAGS_EXHAUSTIVE\n//      RE_FLAGS_WIDE\n//      RE_FLAGS_NOT_AT_START\n//      RE_FLAGS_NO_CASE\n//      RE_FLAGS_DOT_ALL\n//   RE_MATCH_CALLBACK_FUNC callback  - Callback function\n//   void* callback_args              - Callback argument\n//\n// Returns:\n//    Integer indicating the number of matching bytes, including 0 when\n//    matching an empty regexp. Negative values indicate:\n//      -1  No match\n//      -2  Not enough memory\n//      -3  Too many matches\n//      -4  Too many fibers\n//      -5  Unknown fatal error\n\nint yr_re_exec(\n    uint8_t* re_code,\n    uint8_t* input_data,\n    size_t input_size,\n    int flags,\n    RE_MATCH_CALLBACK_FUNC callback,\n    void* callback_args)\n{\n  uint8_t* ip;\n  uint8_t* input;\n  uint8_t mask;\n  uint8_t value;\n\n  RE_FIBER_LIST fibers;\n  RE_THREAD_STORAGE* storage;\n  RE_FIBER* fiber;\n  RE_FIBER* next_fiber;\n\n  int error;\n  int bytes_matched;\n  int max_bytes_matched;\n  int match;\n  int character_size;\n  int input_incr;\n  int kill;\n  int action;\n  int result = -1;\n\n  #define ACTION_NONE       0\n  #define ACTION_CONTINUE   1\n  #define ACTION_KILL       2\n  #define ACTION_KILL_TAIL  3\n\n  #define prolog if (bytes_matched >= max_bytes_matched) \\\n      { \\\n        action = ACTION_KILL; \\\n        break; \\\n      }\n\n  #define fail_if_error(e) switch (e) { \\\n        case ERROR_INSUFFICIENT_MEMORY: \\\n          return -2; \\\n        case ERROR_TOO_MANY_RE_FIBERS: \\\n          return -4; \\\n      }\n\n  if (_yr_re_alloc_storage(&storage) != ERROR_SUCCESS)\n    return -2;\n\n  if (flags & RE_FLAGS_WIDE)\n    character_size = 2;\n  else\n    character_size = 1;\n\n  input = input_data;\n  input_incr = character_size;\n\n  if (flags & RE_FLAGS_BACKWARDS)\n  {\n    input -= character_size;\n    input_incr = -input_incr;\n  }\n\n  max_bytes_matched = (int) yr_min(input_size, RE_SCAN_LIMIT);\n\n  // Round down max_bytes_matched to a multiple of character_size, this way if\n  // character_size is 2 and input_size is odd we are ignoring the\n  // extra byte which can't match anyways.\n\n  max_bytes_matched = max_bytes_matched - max_bytes_matched % character_size;\n  bytes_matched = 0;\n\n  error = _yr_re_fiber_create(&storage->fiber_pool, &fiber);\n  fail_if_error(error);\n\n  fiber->ip = re_code;\n  fibers.head = fiber;\n  fibers.tail = fiber;\n\n  error = _yr_re_fiber_sync(&fibers, &storage->fiber_pool, fiber);\n  fail_if_error(error);\n\n  while (fibers.head != NULL)\n  {\n    fiber = fibers.head;\n\n    while(fiber != NULL)\n    {\n      ip = fiber->ip;\n      action = ACTION_NONE;\n\n      switch(*ip)\n      {\n        case RE_OPCODE_ANY:\n          prolog;\n          match = (flags & RE_FLAGS_DOT_ALL) || (*input != 0x0A);\n          action = match ? ACTION_NONE : ACTION_KILL;\n          fiber->ip += 1;\n          break;\n\n        case RE_OPCODE_REPEAT_ANY_GREEDY:\n        case RE_OPCODE_REPEAT_ANY_UNGREEDY:\n          prolog;\n          match = (flags & RE_FLAGS_DOT_ALL) || (*input != 0x0A);\n          action = match ? ACTION_NONE : ACTION_KILL;\n\n          // The instruction pointer is not incremented here. The current fiber\n          // spins in this instruction until reaching the required number of\n          // repetitions. The code controlling the number of repetitions is in\n          // _yr_re_fiber_sync.\n\n          break;\n\n        case RE_OPCODE_LITERAL:\n          prolog;\n          if (flags & RE_FLAGS_NO_CASE)\n            match = yr_lowercase[*input] == yr_lowercase[*(ip + 1)];\n          else\n            match = (*input == *(ip + 1));\n          action = match ? ACTION_NONE : ACTION_KILL;\n          fiber->ip += 2;\n          break;\n\n        case RE_OPCODE_MASKED_LITERAL:\n          prolog;\n          value = *(int16_t*)(ip + 1) & 0xFF;\n          mask = *(int16_t*)(ip + 1) >> 8;\n\n          // We don't need to take into account the case-insensitive\n          // case because this opcode is only used with hex strings,\n          // which can't be case-insensitive.\n\n          match = ((*input & mask) == value);\n          action = match ? ACTION_NONE : ACTION_KILL;\n          fiber->ip += 3;\n          break;\n\n        case RE_OPCODE_CLASS:\n          prolog;\n          match = CHAR_IN_CLASS(*input, ip + 1);\n          if (!match && (flags & RE_FLAGS_NO_CASE))\n            match = CHAR_IN_CLASS(yr_altercase[*input], ip + 1);\n          action = match ? ACTION_NONE : ACTION_KILL;\n          fiber->ip += 33;\n          break;\n\n        case RE_OPCODE_WORD_CHAR:\n          prolog;\n          match = IS_WORD_CHAR(*input);\n          action = match ? ACTION_NONE : ACTION_KILL;\n          fiber->ip += 1;\n          break;\n\n        case RE_OPCODE_NON_WORD_CHAR:\n          prolog;\n          match = !IS_WORD_CHAR(*input);\n          action = match ? ACTION_NONE : ACTION_KILL;\n          fiber->ip += 1;\n          break;\n\n        case RE_OPCODE_SPACE:\n        case RE_OPCODE_NON_SPACE:\n\n          prolog;\n\n          switch(*input)\n          {\n            case ' ':\n            case '\\t':\n            case '\\r':\n            case '\\n':\n            case '\\v':\n            case '\\f':\n              match = TRUE;\n              break;\n            default:\n              match = FALSE;\n          }\n\n          if (*ip == RE_OPCODE_NON_SPACE)\n            match = !match;\n\n          action = match ? ACTION_NONE : ACTION_KILL;\n          fiber->ip += 1;\n          break;\n\n        case RE_OPCODE_DIGIT:\n          prolog;\n          match = isdigit(*input);\n          action = match ? ACTION_NONE : ACTION_KILL;\n          fiber->ip += 1;\n          break;\n\n        case RE_OPCODE_NON_DIGIT:\n          prolog;\n          match = !isdigit(*input);\n          action = match ? ACTION_NONE : ACTION_KILL;\n          fiber->ip += 1;\n          break;\n\n        case RE_OPCODE_WORD_BOUNDARY:\n        case RE_OPCODE_NON_WORD_BOUNDARY:\n\n          if (bytes_matched == 0 &&\n              !(flags & RE_FLAGS_NOT_AT_START) &&\n              !(flags & RE_FLAGS_BACKWARDS))\n            match = TRUE;\n          else if (bytes_matched >= max_bytes_matched)\n            match = TRUE;\n          else if (IS_WORD_CHAR(*(input - input_incr)) != IS_WORD_CHAR(*input))\n            match = TRUE;\n          else\n            match = FALSE;\n\n          if (*ip == RE_OPCODE_NON_WORD_BOUNDARY)\n            match = !match;\n\n          action = match ? ACTION_CONTINUE : ACTION_KILL;\n          fiber->ip += 1;\n          break;\n\n        case RE_OPCODE_MATCH_AT_START:\n          if (flags & RE_FLAGS_BACKWARDS)\n            kill = input_size > (size_t) bytes_matched;\n          else\n            kill = (flags & RE_FLAGS_NOT_AT_START) || (bytes_matched != 0);\n          action = kill ? ACTION_KILL : ACTION_CONTINUE;\n          fiber->ip += 1;\n          break;\n\n        case RE_OPCODE_MATCH_AT_END:\n          kill = flags & RE_FLAGS_BACKWARDS ||\n                 input_size > (size_t) bytes_matched;\n          action = kill ? ACTION_KILL : ACTION_CONTINUE;\n          fiber->ip += 1;\n          break;\n\n        case RE_OPCODE_MATCH:\n\n          result = bytes_matched;\n\n          if (flags & RE_FLAGS_EXHAUSTIVE)\n          {\n            if (callback != NULL)\n            {\n              int cb_result;\n\n              if (flags & RE_FLAGS_BACKWARDS)\n                cb_result = callback(\n                    input + character_size,\n                    bytes_matched,\n                    flags,\n                    callback_args);\n              else\n                cb_result = callback(\n                    input_data,\n                    bytes_matched,\n                    flags,\n                    callback_args);\n\n              switch(cb_result)\n              {\n                case ERROR_INSUFFICIENT_MEMORY:\n                  return -2;\n                case ERROR_TOO_MANY_MATCHES:\n                  return -3;\n                default:\n                  if (cb_result != ERROR_SUCCESS)\n                    return -4;\n              }\n            }\n\n            action = ACTION_KILL;\n          }\n          else\n          {\n            action = ACTION_KILL_TAIL;\n          }\n\n          break;\n\n        default:\n          assert(FALSE);\n      }\n\n      switch(action)\n      {\n        case ACTION_KILL:\n          fiber = _yr_re_fiber_kill(&fibers, &storage->fiber_pool, fiber);\n          break;\n\n        case ACTION_KILL_TAIL:\n          _yr_re_fiber_kill_tail(&fibers, &storage->fiber_pool, fiber);\n          fiber = NULL;\n          break;\n\n        case ACTION_CONTINUE:\n          error = _yr_re_fiber_sync(&fibers, &storage->fiber_pool, fiber);\n          fail_if_error(error);\n          break;\n\n        default:\n          next_fiber = fiber->next;\n          error = _yr_re_fiber_sync(&fibers, &storage->fiber_pool, fiber);\n          fail_if_error(error);\n          fiber = next_fiber;\n      }\n    }\n\n    if (flags & RE_FLAGS_WIDE &&\n        bytes_matched < max_bytes_matched &&\n        *(input + 1) != 0)\n    {\n      _yr_re_fiber_kill_all(&fibers, &storage->fiber_pool);\n    }\n\n    input += input_incr;\n    bytes_matched += character_size;\n\n    if (flags & RE_FLAGS_SCAN && bytes_matched < max_bytes_matched)\n    {\n      error = _yr_re_fiber_create(&storage->fiber_pool, &fiber);\n      fail_if_error(error);\n\n      fiber->ip = re_code;\n      _yr_re_fiber_append(&fibers, fiber);\n\n      error = _yr_re_fiber_sync(&fibers, &storage->fiber_pool, fiber);\n      fail_if_error(error);\n    }\n  }\n\n  return result;\n}\n\n\nint yr_re_fast_exec(\n    uint8_t* code,\n    uint8_t* input_data,\n    size_t input_size,\n    int flags,\n    RE_MATCH_CALLBACK_FUNC callback,\n    void* callback_args)\n{\n  RE_REPEAT_ANY_ARGS* repeat_any_args;\n\n  uint8_t* code_stack[MAX_FAST_RE_STACK];\n  uint8_t* input_stack[MAX_FAST_RE_STACK];\n  int matches_stack[MAX_FAST_RE_STACK];\n\n  uint8_t* ip = code;\n  uint8_t* input = input_data;\n  uint8_t* next_input;\n  uint8_t* next_opcode;\n  uint8_t mask;\n  uint8_t value;\n\n  int i;\n  int stop;\n  int input_incr;\n  int sp = 0;\n  int bytes_matched;\n  int max_bytes_matched = input_size;\n\n  input_incr = flags & RE_FLAGS_BACKWARDS ? -1 : 1;\n\n  if (flags & RE_FLAGS_BACKWARDS)\n    input--;\n\n  code_stack[sp] = code;\n  input_stack[sp] = input;\n  matches_stack[sp] = 0;\n  sp++;\n\n  while (sp > 0)\n  {\n    sp--;\n    ip = code_stack[sp];\n    input = input_stack[sp];\n    bytes_matched = matches_stack[sp];\n    stop = FALSE;\n\n    while(!stop)\n    {\n      if (*ip == RE_OPCODE_MATCH)\n      {\n        if (flags & RE_FLAGS_EXHAUSTIVE)\n        {\n          int cb_result = callback(\n             flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data,\n             bytes_matched,\n             flags,\n             callback_args);\n\n          switch(cb_result)\n          {\n            case ERROR_INSUFFICIENT_MEMORY:\n              return -2;\n            case ERROR_TOO_MANY_MATCHES:\n              return -3;\n            default:\n              if (cb_result != ERROR_SUCCESS)\n                return -4;\n          }\n\n          break;\n        }\n        else\n        {\n          return bytes_matched;\n        }\n      }\n\n      if (bytes_matched >= max_bytes_matched)\n        break;\n\n      switch(*ip)\n      {\n        case RE_OPCODE_LITERAL:\n\n          if (*input == *(ip + 1))\n          {\n            bytes_matched++;\n            input += input_incr;\n            ip += 2;\n          }\n          else\n          {\n            stop = TRUE;\n          }\n\n          break;\n\n        case RE_OPCODE_MASKED_LITERAL:\n\n          value = *(int16_t*)(ip + 1) & 0xFF;\n          mask = *(int16_t*)(ip + 1) >> 8;\n\n          if ((*input & mask) == value)\n          {\n            bytes_matched++;\n            input += input_incr;\n            ip += 3;\n          }\n          else\n          {\n            stop = TRUE;\n          }\n\n          break;\n\n        case RE_OPCODE_ANY:\n\n          bytes_matched++;\n          input += input_incr;\n          ip += 1;\n\n          break;\n\n        case RE_OPCODE_REPEAT_ANY_UNGREEDY:\n\n          repeat_any_args = (RE_REPEAT_ANY_ARGS*)(ip + 1);\n          next_opcode = ip + 1 + sizeof(RE_REPEAT_ANY_ARGS);\n\n          for (i = repeat_any_args->min + 1; i <= repeat_any_args->max; i++)\n          {\n            next_input = input + i * input_incr;\n\n            if (bytes_matched + i >= max_bytes_matched)\n              break;\n\n            if ( *(next_opcode) != RE_OPCODE_LITERAL ||\n                (*(next_opcode) == RE_OPCODE_LITERAL &&\n                 *(next_opcode + 1) == *next_input))\n            {\n              if (sp >= MAX_FAST_RE_STACK)\n                return -4;\n\n              code_stack[sp] = next_opcode;\n              input_stack[sp] = next_input;\n              matches_stack[sp] = bytes_matched + i;\n              sp++;\n            }\n          }\n\n          input += input_incr * repeat_any_args->min;\n          bytes_matched += repeat_any_args->min;\n          ip = next_opcode;\n\n          break;\n\n        default:\n          assert(FALSE);\n      }\n    }\n  }\n\n  return -1;\n}\n\n\nvoid _yr_re_print_node(\n    RE_NODE* re_node)\n{\n  int i;\n\n  if (re_node == NULL)\n    return;\n\n  switch(re_node->type)\n  {\n  case RE_NODE_ALT:\n    printf(\"Alt(\");\n    _yr_re_print_node(re_node->left);\n    printf(\", \");\n    _yr_re_print_node(re_node->right);\n    printf(\")\");\n    break;\n\n  case RE_NODE_CONCAT:\n    printf(\"Cat(\");\n    _yr_re_print_node(re_node->left);\n    printf(\", \");\n    _yr_re_print_node(re_node->right);\n    printf(\")\");\n    break;\n\n  case RE_NODE_STAR:\n    printf(\"Star(\");\n    _yr_re_print_node(re_node->left);\n    printf(\")\");\n    break;\n\n  case RE_NODE_PLUS:\n    printf(\"Plus(\");\n    _yr_re_print_node(re_node->left);\n    printf(\")\");\n    break;\n\n  case RE_NODE_LITERAL:\n    printf(\"Lit(%02X)\", re_node->value);\n    break;\n\n  case RE_NODE_MASKED_LITERAL:\n    printf(\"MaskedLit(%02X,%02X)\", re_node->value, re_node->mask);\n    break;\n\n  case RE_NODE_WORD_CHAR:\n    printf(\"WordChar\");\n    break;\n\n  case RE_NODE_NON_WORD_CHAR:\n    printf(\"NonWordChar\");\n    break;\n\n  case RE_NODE_SPACE:\n    printf(\"Space\");\n    break;\n\n  case RE_NODE_NON_SPACE:\n    printf(\"NonSpace\");\n    break;\n\n  case RE_NODE_DIGIT:\n    printf(\"Digit\");\n    break;\n\n  case RE_NODE_NON_DIGIT:\n    printf(\"NonDigit\");\n    break;\n\n  case RE_NODE_ANY:\n    printf(\"Any\");\n    break;\n\n  case RE_NODE_RANGE:\n    printf(\"Range(%d-%d, \", re_node->start, re_node->end);\n    _yr_re_print_node(re_node->left);\n    printf(\")\");\n    break;\n\n  case RE_NODE_CLASS:\n    printf(\"Class(\");\n    for (i = 0; i < 256; i++)\n      if (CHAR_IN_CLASS(i, re_node->class_vector))\n        printf(\"%02X,\", i);\n    printf(\")\");\n    break;\n\n  default:\n    printf(\"???\");\n    break;\n  }\n}\n\nvoid yr_re_print(\n    RE_AST* re_ast)\n{\n  _yr_re_print_node(re_ast->root_node);\n}\n", "/*\nCopyright (c) 2014. The YARA Authors. All Rights Reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\nlist of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors\nmay be used to endorse or promote products derived from this software without\nspecific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#include <assert.h>\n#include <stdlib.h>\n#include <ctype.h>\n\n#include <yara/globals.h>\n#include <yara/limits.h>\n#include <yara/utils.h>\n#include <yara/re.h>\n#include <yara/types.h>\n#include <yara/error.h>\n#include <yara/libyara.h>\n#include <yara/scan.h>\n\n\ntypedef struct _CALLBACK_ARGS\n{\n  YR_STRING* string;\n  YR_SCAN_CONTEXT* context;\n\n  uint8_t* data;\n  size_t data_size;\n  size_t data_base;\n\n  int forward_matches;\n  int full_word;\n\n} CALLBACK_ARGS;\n\n\nint _yr_scan_compare(\n    uint8_t* data,\n    size_t data_size,\n    uint8_t* string,\n    size_t string_length)\n{\n  uint8_t* s1 = data;\n  uint8_t* s2 = string;\n\n  size_t i = 0;\n\n  if (data_size < string_length)\n    return 0;\n\n  while (i < string_length && *s1++ == *s2++)\n    i++;\n\n  return (int) ((i == string_length) ? i : 0);\n}\n\n\nint _yr_scan_icompare(\n    uint8_t* data,\n    size_t data_size,\n    uint8_t* string,\n    size_t string_length)\n{\n  uint8_t* s1 = data;\n  uint8_t* s2 = string;\n\n  size_t i = 0;\n\n  if (data_size < string_length)\n    return 0;\n\n  while (i < string_length && yr_lowercase[*s1++] == yr_lowercase[*s2++])\n    i++;\n\n  return (int) ((i == string_length) ? i : 0);\n}\n\n\nint _yr_scan_wcompare(\n    uint8_t* data,\n    size_t data_size,\n    uint8_t* string,\n    size_t string_length)\n{\n  uint8_t* s1 = data;\n  uint8_t* s2 = string;\n\n  size_t i = 0;\n\n  if (data_size < string_length * 2)\n    return 0;\n\n  while (i < string_length && *s1 == *s2)\n  {\n    s1+=2;\n    s2++;\n    i++;\n  }\n\n  return (int) ((i == string_length) ? i * 2 : 0);\n}\n\n\nint _yr_scan_wicompare(\n    uint8_t* data,\n    size_t data_size,\n    uint8_t* string,\n    size_t string_length)\n{\n  uint8_t* s1 = data;\n  uint8_t* s2 = string;\n\n  size_t i = 0;\n\n  if (data_size < string_length * 2)\n    return 0;\n\n  while (i < string_length && yr_lowercase[*s1] == yr_lowercase[*s2])\n  {\n    s1+=2;\n    s2++;\n    i++;\n  }\n\n  return (int) ((i == string_length) ? i * 2 : 0);\n}\n\n\nvoid _yr_scan_update_match_chain_length(\n    int tidx,\n    YR_STRING* string,\n    YR_MATCH* match_to_update,\n    int chain_length)\n{\n  YR_MATCH* match;\n\n  if (match_to_update->chain_length == chain_length)\n    return;\n\n  match_to_update->chain_length = chain_length;\n\n  if (string->chained_to == NULL)\n    return;\n\n  match = string->chained_to->unconfirmed_matches[tidx].head;\n\n  while (match != NULL)\n  {\n    int64_t ending_offset = match->offset + match->match_length;\n\n    if (ending_offset + string->chain_gap_max >= match_to_update->offset &&\n        ending_offset + string->chain_gap_min <= match_to_update->offset)\n    {\n      _yr_scan_update_match_chain_length(\n          tidx, string->chained_to, match, chain_length + 1);\n    }\n\n    match = match->next;\n  }\n}\n\n\nint _yr_scan_add_match_to_list(\n    YR_MATCH* match,\n    YR_MATCHES* matches_list,\n    int replace_if_exists)\n{\n  YR_MATCH* insertion_point = matches_list->tail;\n\n  if (matches_list->count == MAX_STRING_MATCHES)\n    return ERROR_TOO_MANY_MATCHES;\n\n  while (insertion_point != NULL)\n  {\n    if (match->offset == insertion_point->offset)\n    {\n      if (replace_if_exists)\n      {\n        insertion_point->match_length = match->match_length;\n        insertion_point->data_length = match->data_length;\n        insertion_point->data = match->data;\n      }\n\n      return ERROR_SUCCESS;\n    }\n\n    if (match->offset > insertion_point->offset)\n      break;\n\n    insertion_point = insertion_point->prev;\n  }\n\n  match->prev = insertion_point;\n\n  if (insertion_point != NULL)\n  {\n    match->next = insertion_point->next;\n    insertion_point->next = match;\n  }\n  else\n  {\n    match->next = matches_list->head;\n    matches_list->head = match;\n  }\n\n  matches_list->count++;\n\n  if (match->next != NULL)\n    match->next->prev = match;\n  else\n    matches_list->tail = match;\n\n  return ERROR_SUCCESS;\n}\n\n\nvoid _yr_scan_remove_match_from_list(\n    YR_MATCH* match,\n    YR_MATCHES* matches_list)\n{\n  if (match->prev != NULL)\n    match->prev->next = match->next;\n\n  if (match->next != NULL)\n    match->next->prev = match->prev;\n\n  if (matches_list->head == match)\n    matches_list->head = match->next;\n\n  if (matches_list->tail == match)\n    matches_list->tail = match->prev;\n\n  matches_list->count--;\n  match->next = NULL;\n  match->prev = NULL;\n}\n\n\nint _yr_scan_verify_chained_string_match(\n    YR_STRING* matching_string,\n    YR_SCAN_CONTEXT* context,\n    uint8_t* match_data,\n    uint64_t match_base,\n    uint64_t match_offset,\n    int32_t match_length)\n{\n  YR_STRING* string;\n  YR_MATCH* match;\n  YR_MATCH* next_match;\n  YR_MATCH* new_match;\n\n  uint64_t lower_offset;\n  uint64_t ending_offset;\n  int32_t full_chain_length;\n\n  int tidx = context->tidx;\n  int add_match = FALSE;\n\n  if (matching_string->chained_to == NULL)\n  {\n    add_match = TRUE;\n  }\n  else\n  {\n    if (matching_string->unconfirmed_matches[tidx].head != NULL)\n      lower_offset = matching_string->unconfirmed_matches[tidx].head->offset;\n    else\n      lower_offset = match_offset;\n\n    match = matching_string->chained_to->unconfirmed_matches[tidx].head;\n\n    while (match != NULL)\n    {\n      next_match = match->next;\n      ending_offset = match->offset + match->match_length;\n\n      if (ending_offset + matching_string->chain_gap_max < lower_offset)\n      {\n        _yr_scan_remove_match_from_list(\n            match, &matching_string->chained_to->unconfirmed_matches[tidx]);\n      }\n      else\n      {\n        if (ending_offset + matching_string->chain_gap_max >= match_offset &&\n            ending_offset + matching_string->chain_gap_min <= match_offset)\n        {\n          add_match = TRUE;\n          break;\n        }\n      }\n\n      match = next_match;\n    }\n  }\n\n  if (add_match)\n  {\n    if (STRING_IS_CHAIN_TAIL(matching_string))\n    {\n      // Chain tails must be chained to some other string\n      assert(matching_string->chained_to != NULL);\n\n      match = matching_string->chained_to->unconfirmed_matches[tidx].head;\n\n      while (match != NULL)\n      {\n        ending_offset = match->offset + match->match_length;\n\n        if (ending_offset + matching_string->chain_gap_max >= match_offset &&\n            ending_offset + matching_string->chain_gap_min <= match_offset)\n        {\n          _yr_scan_update_match_chain_length(\n              tidx, matching_string->chained_to, match, 1);\n        }\n\n        match = match->next;\n      }\n\n      full_chain_length = 0;\n      string = matching_string;\n\n      while(string->chained_to != NULL)\n      {\n        full_chain_length++;\n        string = string->chained_to;\n      }\n\n      // \"string\" points now to the head of the strings chain\n\n      match = string->unconfirmed_matches[tidx].head;\n\n      while (match != NULL)\n      {\n        next_match = match->next;\n\n        if (match->chain_length == full_chain_length)\n        {\n          _yr_scan_remove_match_from_list(\n              match, &string->unconfirmed_matches[tidx]);\n\n          match->match_length = (int32_t) \\\n              (match_offset - match->offset + match_length);\n\n          match->data_length = yr_min(match->match_length, MAX_MATCH_DATA);\n\n          FAIL_ON_ERROR(yr_arena_write_data(\n              context->matches_arena,\n              match_data - match_offset + match->offset,\n              match->data_length,\n              (void**) &match->data));\n\n          FAIL_ON_ERROR(_yr_scan_add_match_to_list(\n              match, &string->matches[tidx], FALSE));\n        }\n\n        match = next_match;\n      }\n    }\n    else\n    {\n      if (matching_string->matches[tidx].count == 0 &&\n          matching_string->unconfirmed_matches[tidx].count == 0)\n      {\n        // If this is the first match for the string, put the string in the\n        // list of strings whose flags needs to be cleared after the scan.\n\n        FAIL_ON_ERROR(yr_arena_write_data(\n            context->matching_strings_arena,\n            &matching_string,\n            sizeof(matching_string),\n            NULL));\n      }\n\n      FAIL_ON_ERROR(yr_arena_allocate_memory(\n          context->matches_arena,\n          sizeof(YR_MATCH),\n          (void**) &new_match));\n\n      new_match->data_length = yr_min(match_length, MAX_MATCH_DATA);\n\n      FAIL_ON_ERROR(yr_arena_write_data(\n          context->matches_arena,\n          match_data,\n          new_match->data_length,\n          (void**) &new_match->data));\n\n      new_match->base = match_base;\n      new_match->offset = match_offset;\n      new_match->match_length = match_length;\n      new_match->chain_length = 0;\n      new_match->prev = NULL;\n      new_match->next = NULL;\n\n      FAIL_ON_ERROR(_yr_scan_add_match_to_list(\n          new_match,\n          &matching_string->unconfirmed_matches[tidx],\n          FALSE));\n    }\n  }\n\n  return ERROR_SUCCESS;\n}\n\n\nint _yr_scan_match_callback(\n    uint8_t* match_data,\n    int32_t match_length,\n    int flags,\n    void* args)\n{\n  CALLBACK_ARGS* callback_args = (CALLBACK_ARGS*) args;\n\n  YR_STRING* string = callback_args->string;\n  YR_MATCH* new_match;\n\n  int result = ERROR_SUCCESS;\n  int tidx = callback_args->context->tidx;\n\n  size_t match_offset = match_data - callback_args->data;\n\n  // total match length is the sum of backward and forward matches.\n  match_length += callback_args->forward_matches;\n\n  if (callback_args->full_word)\n  {\n    if (flags & RE_FLAGS_WIDE)\n    {\n      if (match_offset >= 2 &&\n          *(match_data - 1) == 0 &&\n          isalnum(*(match_data - 2)))\n        return ERROR_SUCCESS;\n\n      if (match_offset + match_length + 1 < callback_args->data_size &&\n          *(match_data + match_length + 1) == 0 &&\n          isalnum(*(match_data + match_length)))\n        return ERROR_SUCCESS;\n    }\n    else\n    {\n      if (match_offset >= 1 &&\n          isalnum(*(match_data - 1)))\n        return ERROR_SUCCESS;\n\n      if (match_offset + match_length < callback_args->data_size &&\n          isalnum(*(match_data + match_length)))\n        return ERROR_SUCCESS;\n    }\n  }\n\n  if (STRING_IS_CHAIN_PART(string))\n  {\n    result = _yr_scan_verify_chained_string_match(\n        string,\n        callback_args->context,\n        match_data,\n        callback_args->data_base,\n        match_offset,\n        match_length);\n  }\n  else\n  {\n    if (string->matches[tidx].count == 0)\n    {\n      // If this is the first match for the string, put the string in the\n      // list of strings whose flags needs to be cleared after the scan.\n\n      FAIL_ON_ERROR(yr_arena_write_data(\n          callback_args->context->matching_strings_arena,\n          &string,\n          sizeof(string),\n          NULL));\n    }\n\n    FAIL_ON_ERROR(yr_arena_allocate_memory(\n        callback_args->context->matches_arena,\n        sizeof(YR_MATCH),\n        (void**) &new_match));\n\n    new_match->data_length = yr_min(match_length, MAX_MATCH_DATA);\n\n    FAIL_ON_ERROR(yr_arena_write_data(\n        callback_args->context->matches_arena,\n        match_data,\n        new_match->data_length,\n        (void**) &new_match->data));\n\n    if (result == ERROR_SUCCESS)\n    {\n      new_match->base = callback_args->data_base;\n      new_match->offset = match_offset;\n      new_match->match_length = match_length;\n      new_match->prev = NULL;\n      new_match->next = NULL;\n\n      FAIL_ON_ERROR(_yr_scan_add_match_to_list(\n          new_match,\n          &string->matches[tidx],\n          STRING_IS_GREEDY_REGEXP(string)));\n    }\n  }\n\n  return result;\n}\n\n\ntypedef int (*RE_EXEC_FUNC)(\n    uint8_t* code,\n    uint8_t* input,\n    size_t input_size,\n    int flags,\n    RE_MATCH_CALLBACK_FUNC callback,\n    void* callback_args);\n\n\nint _yr_scan_verify_re_match(\n    YR_SCAN_CONTEXT* context,\n    YR_AC_MATCH* ac_match,\n    uint8_t* data,\n    size_t data_size,\n    size_t data_base,\n    size_t offset)\n{\n  CALLBACK_ARGS callback_args;\n  RE_EXEC_FUNC exec;\n\n  int forward_matches = -1;\n  int backward_matches = -1;\n  int flags = 0;\n\n  if (STRING_IS_GREEDY_REGEXP(ac_match->string))\n    flags |= RE_FLAGS_GREEDY;\n\n  if (STRING_IS_NO_CASE(ac_match->string))\n    flags |= RE_FLAGS_NO_CASE;\n\n  if (STRING_IS_DOT_ALL(ac_match->string))\n    flags |= RE_FLAGS_DOT_ALL;\n\n  if (STRING_IS_FAST_REGEXP(ac_match->string))\n    exec = yr_re_fast_exec;\n  else\n    exec = yr_re_exec;\n\n  if (STRING_IS_ASCII(ac_match->string))\n  {\n    forward_matches = exec(\n        ac_match->forward_code,\n        data + offset,\n        data_size - offset,\n        offset > 0 ? flags | RE_FLAGS_NOT_AT_START : flags,\n        NULL,\n        NULL);\n  }\n\n  if (STRING_IS_WIDE(ac_match->string) && forward_matches == -1)\n  {\n    flags |= RE_FLAGS_WIDE;\n    forward_matches = exec(\n        ac_match->forward_code,\n        data + offset,\n        data_size - offset,\n        offset > 0 ? flags | RE_FLAGS_NOT_AT_START : flags,\n        NULL,\n        NULL);\n  }\n\n  switch(forward_matches)\n  {\n    case -1:\n      return ERROR_SUCCESS;\n    case -2:\n      return ERROR_INSUFFICIENT_MEMORY;\n    case -3:\n      return ERROR_TOO_MANY_MATCHES;\n    case -4:\n      return ERROR_TOO_MANY_RE_FIBERS;\n    case -5:\n      return ERROR_INTERNAL_FATAL_ERROR;\n  }\n\n  if (forward_matches == 0 && ac_match->backward_code == NULL)\n    return ERROR_SUCCESS;\n\n  callback_args.string = ac_match->string;\n  callback_args.context = context;\n  callback_args.data = data;\n  callback_args.data_size = data_size;\n  callback_args.data_base = data_base;\n  callback_args.forward_matches = forward_matches;\n  callback_args.full_word = STRING_IS_FULL_WORD(ac_match->string);\n\n  if (ac_match->backward_code != NULL)\n  {\n    backward_matches = exec(\n        ac_match->backward_code,\n        data + offset,\n        offset,\n        flags | RE_FLAGS_BACKWARDS | RE_FLAGS_EXHAUSTIVE,\n        _yr_scan_match_callback,\n        (void*) &callback_args);\n\n    switch(backward_matches)\n    {\n      case -2:\n        return ERROR_INSUFFICIENT_MEMORY;\n      case -3:\n        return ERROR_TOO_MANY_MATCHES;\n      case -4:\n        return ERROR_TOO_MANY_RE_FIBERS;\n      case -5:\n        return ERROR_INTERNAL_FATAL_ERROR;\n    }\n  }\n  else\n  {\n    FAIL_ON_ERROR(_yr_scan_match_callback(\n        data + offset, 0, flags, &callback_args));\n  }\n\n  return ERROR_SUCCESS;\n}\n\n\nint _yr_scan_verify_literal_match(\n    YR_SCAN_CONTEXT* context,\n    YR_AC_MATCH* ac_match,\n    uint8_t* data,\n    size_t data_size,\n    size_t data_base,\n    size_t offset)\n{\n  int flags = 0;\n  int forward_matches = 0;\n\n  CALLBACK_ARGS callback_args;\n  YR_STRING* string = ac_match->string;\n\n  if (STRING_FITS_IN_ATOM(string))\n  {\n    forward_matches = ac_match->backtrack;\n  }\n  else if (STRING_IS_NO_CASE(string))\n  {\n    if (STRING_IS_ASCII(string))\n    {\n      forward_matches = _yr_scan_icompare(\n          data + offset,\n          data_size - offset,\n          string->string,\n          string->length);\n    }\n\n    if (STRING_IS_WIDE(string) && forward_matches == 0)\n    {\n      forward_matches = _yr_scan_wicompare(\n          data + offset,\n          data_size - offset,\n          string->string,\n          string->length);\n    }\n  }\n  else\n  {\n    if (STRING_IS_ASCII(string))\n    {\n      forward_matches = _yr_scan_compare(\n          data + offset,\n          data_size - offset,\n          string->string,\n          string->length);\n    }\n\n    if (STRING_IS_WIDE(string) && forward_matches == 0)\n    {\n      forward_matches = _yr_scan_wcompare(\n          data + offset,\n          data_size - offset,\n          string->string,\n          string->length);\n    }\n  }\n\n  if (forward_matches == 0)\n    return ERROR_SUCCESS;\n\n  if (forward_matches == string->length * 2)\n    flags |= RE_FLAGS_WIDE;\n\n  if (STRING_IS_NO_CASE(string))\n    flags |= RE_FLAGS_NO_CASE;\n\n  callback_args.context = context;\n  callback_args.string = string;\n  callback_args.data = data;\n  callback_args.data_size = data_size;\n  callback_args.data_base = data_base;\n  callback_args.forward_matches = forward_matches;\n  callback_args.full_word = STRING_IS_FULL_WORD(string);\n\n  FAIL_ON_ERROR(_yr_scan_match_callback(\n      data + offset, 0, flags, &callback_args));\n\n  return ERROR_SUCCESS;\n}\n\n\nint yr_scan_verify_match(\n    YR_SCAN_CONTEXT* context,\n    YR_AC_MATCH* ac_match,\n    uint8_t* data,\n    size_t data_size,\n    size_t data_base,\n    size_t offset)\n{\n  YR_STRING* string = ac_match->string;\n\n  #ifdef PROFILING_ENABLED\n  clock_t start = clock();\n  #endif\n\n  if (data_size - offset <= 0)\n    return ERROR_SUCCESS;\n\n  if (context->flags & SCAN_FLAGS_FAST_MODE &&\n      STRING_IS_SINGLE_MATCH(string) &&\n      string->matches[context->tidx].head != NULL)\n    return ERROR_SUCCESS;\n\n  if (STRING_IS_FIXED_OFFSET(string) &&\n      string->fixed_offset != data_base + offset)\n    return ERROR_SUCCESS;\n\n  if (STRING_IS_LITERAL(string))\n  {\n    FAIL_ON_ERROR(_yr_scan_verify_literal_match(\n        context, ac_match, data, data_size, data_base, offset));\n  }\n  else\n  {\n    FAIL_ON_ERROR(_yr_scan_verify_re_match(\n        context, ac_match, data, data_size, data_base, offset));\n  }\n\n  #ifdef PROFILING_ENABLED\n  string->clock_ticks += clock() - start;\n  #endif\n\n  return ERROR_SUCCESS;\n}\n", "/*\nCopyright (c) 2016. The YARA Authors. All Rights Reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\nlist of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors\nmay be used to endorse or promote products derived from this software without\nspecific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#include <yara.h>\n#include \"blob.h\"\n#include \"util.h\"\n\n#if defined(_WIN32) || defined(__CYGWIN__)\n#include <fileapi.h>\n#else\n#include <unistd.h>\n#endif\n#include <fcntl.h>\n\nstatic void test_boolean_operators()\n{\n  assert_true_rule(\n      \"rule test { condition: true }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: true or false }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: true and true }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 0x1 and 0x2}\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: false }\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: true and false }\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: false or false }\", NULL);\n}\n\n\nstatic void test_comparison_operators()\n{\n  assert_true_rule(\n      \"rule test { condition: 2 > 1 }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1 < 2 }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 2 >= 1 }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1 <= 1 }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1 == 1 }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1.5 == 1.5}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1.0 == 1}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1.5 >= 1.0}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1.5 >= 1}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1.0 >= 1}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 0.5 < 1}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 0.5 <= 1}\", NULL);\n\n  assert_true_rule(\n      \"rule rest { condition: 1.0 <= 1}\", NULL);\n\n  assert_true_rule(\n      \"rule rest { condition: \\\"abc\\\" == \\\"abc\\\"}\", NULL);\n\n  assert_true_rule(\n      \"rule rest { condition: \\\"abc\\\" <= \\\"abc\\\"}\", NULL);\n\n  assert_true_rule(\n      \"rule rest { condition: \\\"abc\\\" >= \\\"abc\\\"}\", NULL);\n\n  assert_true_rule(\n      \"rule rest { condition: \\\"ab\\\" < \\\"abc\\\"}\", NULL);\n\n  assert_true_rule(\n      \"rule rest { condition: \\\"abc\\\" > \\\"ab\\\"}\", NULL);\n\n  assert_true_rule(\n      \"rule rest { condition: \\\"abc\\\" < \\\"abd\\\"}\", NULL);\n\n  assert_true_rule(\n      \"rule rest { condition: \\\"abd\\\" > \\\"abc\\\"}\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: 1 != 1}\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: 1 != 1.0}\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: 2 > 3}\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: 2.1 < 2}\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: \\\"abc\\\" != \\\"abc\\\"}\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: \\\"abc\\\" > \\\"abc\\\"}\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: \\\"abc\\\" < \\\"abc\\\"}\", NULL);\n\n}\n\nstatic void test_arithmetic_operators()\n{\n  assert_true_rule(\n      \"rule test { condition: (1 + 1) * 2 == (9 - 1) \\\\ 2 }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 5 % 2 == 1 }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1.5 + 1.5 == 3}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 3 \\\\ 2 == 1}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 3.0 \\\\ 2 == 1.5}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1 + -1 == 0}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: -1 + -1 == -2}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 4 --2 * 2 == 8}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: -1.0 * 1 == -1.0}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1-1 == 0}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: -2.0-3.0 == -5}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: --1 == 1}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1--1 == 2}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: -0x01 == -1}\", NULL);\n\n}\n\n\nstatic void test_bitwise_operators()\n{\n  assert_true_rule(\n      \"rule test { condition: 0x55 | 0xAA == 0xFF }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { condition: ~0xAA ^ 0x5A & 0xFF == (~0xAA) ^ (0x5A & 0xFF) }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { condition: ~0x55 & 0xFF == 0xAA }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 8 >> 2 == 2 }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1 << 3 == 8 }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1 | 3 ^ 3 == 1 | (3 ^ 3) }\",\n      NULL);\n\n  assert_false_rule(\n      \"rule test { condition: ~0xAA ^ 0x5A & 0xFF == 0x0F }\",\n      NULL);\n\n  assert_false_rule(\n      \"rule test { condition: 1 | 3 ^ 3 == (1 | 3) ^ 3}\",\n      NULL);\n\n}\n\n\nstatic void test_syntax()\n{\n  assert_error(\n      \"rule test { strings: $a = \\\"a\\\" $a = \\\"a\\\" condition: all of them }\",\n      ERROR_DUPLICATED_STRING_IDENTIFIER);\n}\n\n\nstatic void test_anonymous_strings()\n{\n  assert_true_rule(\n      \"rule test { strings: $ = \\\"a\\\" $ = \\\"b\\\" condition: all of them }\",\n      \"ab\");\n}\n\n\nstatic void test_strings()\n{\n  char* str = \"---- abc ---- xyz\";\n  uint8_t blob[] = \"---- a\\0b\\0c\\0 -\\0-\\0-\\0-\\0x\\0y\\0z\\0\";\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"a\\\" condition: $a }\",\n      str);\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"ab\\\" condition: $a }\",\n      str);\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"abc\\\" condition: $a }\",\n      str);\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"xyz\\\" condition: $a }\",\n      str);\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"abc\\\" nocase fullword condition: $a }\",\n      str);\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"aBc\\\" nocase  condition: $a }\",\n      str);\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"abc\\\" fullword condition: $a }\",\n      str);\n\n  assert_false_rule(\n      \"rule test { strings: $a = \\\"a\\\" fullword condition: $a }\",\n      str);\n\n  assert_false_rule(\n      \"rule test { strings: $a = \\\"ab\\\" fullword condition: $a }\",\n      str);\n\n  assert_false_rule(\n      \"rule test { strings: $a = \\\"abc\\\" wide fullword condition: $a }\",\n      str);\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"a\\\" wide condition: $a }\",\n      blob);\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"a\\\" wide ascii condition: $a }\",\n      blob);\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"ab\\\" wide condition: $a }\",\n      blob);\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"ab\\\" wide ascii condition: $a }\",\n      blob);\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"abc\\\" wide condition: $a }\",\n      blob);\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"abc\\\" wide nocase fullword condition: $a }\",\n      blob);\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"aBc\\\" wide nocase condition: $a }\",\n      blob);\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"aBc\\\" wide ascii nocase condition: $a }\",\n      blob);\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"---xyz\\\" wide nocase condition: $a }\",\n      blob);\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"abc\\\" fullword condition: $a }\",\n      \"abc\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = \\\"abc\\\" fullword condition: $a }\",\n      \"xabcx\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = \\\"abc\\\" fullword condition: $a }\",\n      \"xabc\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = \\\"abc\\\" fullword condition: $a }\",\n      \"abcx\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = \\\"abc\\\" ascii wide fullword condition: $a }\",\n      \"abcx\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"abc\\\" ascii wide fullword condition: $a }\",\n      \"a\\0abc\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"abc\\\" wide fullword condition: $a }\",\n      \"a\\0b\\0c\\0\");\n\n  assert_false_rule_blob(\n      \"rule test { strings: $a = \\\"abc\\\" wide fullword condition: $a }\",\n      \"x\\0a\\0b\\0c\\0x\\0\");\n\n  assert_false_rule_blob(\n      \"rule test { strings: $a = \\\"ab\\\" wide fullword condition: $a }\",\n      \"x\\0a\\0b\\0\");\n\n  assert_false_rule_blob(\n      \"rule test { strings: $a = \\\"abc\\\" wide fullword condition: $a }\",\n      \"x\\0a\\0b\\0c\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"abc\\\" wide fullword condition: $a }\",\n      \"x\\001a\\0b\\0c\\0\");\n\n  assert_true_rule(\n      \"rule test {\\n\\\n         strings:\\n\\\n             $a = \\\"abcdef\\\"\\n\\\n             $b = \\\"cdef\\\"\\n\\\n             $c = \\\"ef\\\"\\n\\\n         condition:\\n\\\n             all of them\\n\\\n       }\", \"abcdef\");\n}\n\n\nstatic void test_wildcard_strings()\n{\n  assert_true_rule_blob(\n      \"rule test {\\n\\\n         strings:\\n\\\n             $s1 = \\\"abc\\\"\\n\\\n             $s2 = \\\"xyz\\\"\\n\\\n         condition:\\n\\\n             for all of ($*) : ($)\\n\\\n      }\",\n      \"---- abc ---- A\\x00\"\"B\\x00\"\"C\\x00 ---- xyz\");\n}\n\n\nstatic void test_hex_strings()\n{\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 64 01 00 00 60 01 } \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 64 0? 00 00 ?0 01 } \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\\\n\n      \"rule test { \\\n        strings: $a = { 6? 01 00 00 60 0? } \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 64 01 [1-3] 60 01 } \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 64 01 [1-3] (60|61) 01 } \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 4D 5A [-] 6A 2A [-] 58 C3} \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 4D 5A [300-] 6A 2A [-] 58 C3} \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 2e 7? (65 | ?? ) 78 } \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_false_rule_blob(\n      \"rule test { \\\n        strings: $a = { 4D 5A [0-300] 6A 2A } \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_false_rule_blob(\n      \"rule test { \\\n        strings: $a = { 4D 5A [0-128] 45 [0-128] 01 [0-128]  C3 } \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [-] 38 39 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [-] // Inline comment\\n\\r \\\n          38 39 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 /* Inline comment */ [-] 38 39 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 /* Inline multi-line\\n\\r \\\n                                 comment */ [-] 38 39 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = {\\n 31 32 [-] 38 39 \\n\\r} \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [-] 33 34 [-] 38 39 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [1] 34 35 [2] 38 39 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test {\\\n         strings: $a = { 31 32 [1-] 34 35 [1-] 38 39 } \\\n         condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [0-3] 34 35 [1-] 38 39 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [0-2] 35 [1-] 37 38 39 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [0-1] 33 } \\\n        condition: !a == 3}\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [0-1] 34 } \\\n        condition: !a == 4}\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [0-2] 34 } \\\n        condition: !a == 4 }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [-] 38 39 } \\\n        condition: all of them }\",\n      \"1234567890\");\n\n  assert_false_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [-] 32 33 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_false_rule(\n      \"rule test { \\\n        strings: $a = { 35 36 [-] 31 32 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_false_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [2-] 34 35 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [0-1] 33 34 [0-2] 36 37 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [0-1] 34 35 [0-2] 36 37 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_false_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [0-3] 37 38 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [1] 33 34 } \\\n        condition: $a }\",\n      \"12\\n34\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = {31 32 [3-6] 32} \\\n        condition: !a == 6 }\",\n      \"12111222\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = {31 [0-3] (32|33)} \\\n        condition: !a == 2 }\",\n      \"122222222\");\n\n  assert_error(\n      \"rule test { \\\n        strings: $a = { 01 [0] 02 } \\\n        condition: $a }\",\n      ERROR_INVALID_HEX_STRING);\n\n  assert_error(\n      \"rule test { \\\n        strings: $a = { [-] 01 02 } condition: $a }\",\n      ERROR_INVALID_HEX_STRING);\n\n  assert_error(\n      \"rule test { \\\n        strings: $a = { 01 02 [-] } \\\n        condition: $a }\",\n      ERROR_INVALID_HEX_STRING);\n\n  assert_error(\n      \"rule test { \\\n        strings: $a = { 01 02 ([-] 03 | 04) } \\\n        condition: $a }\",\n      ERROR_INVALID_HEX_STRING);\n\n  assert_error(\n      \"rule test { \\\n        strings: $a = { 01 02 (03 [-] | 04) } \\\n        condition: $a }\",\n      ERROR_INVALID_HEX_STRING);\n\n  assert_error(\n      \"rule test { \\\n        strings: $a = { 01 02 (03 | 04 [-]) } \\\n        condition: $a \",\n      ERROR_INVALID_HEX_STRING);\n\n  /* TODO: tests.py:551 ff. */\n}\n\n\nstatic void test_count()\n{\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"ssi\\\" condition: #a == 2 }\",\n      \"mississippi\");\n}\n\n\nstatic void test_at()\n{\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = \\\"ssi\\\" \\\n        condition: $a at 2 and $a at 5 }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = \\\"mis\\\" \\\n        condition: $a at ~0xFF & 0xFF }\",\n      \"mississippi\");\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 00 00 00 00 ?? 74 65 78 74 } \\\n        condition: $a at 308}\",\n      PE32_FILE);\n}\n\n\nstatic void test_in()\n{\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 6a 2a 58 c3 } \\\n        condition: $a in (entrypoint .. entrypoint + 1) }\",\n      PE32_FILE);\n}\n\n\nstatic void test_offset()\n{\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"ssi\\\" condition: @a == 2 }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"ssi\\\" condition: @a == @a[1] }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"ssi\\\" condition: @a[2] == 5 }\",\n      \"mississippi\");\n}\n\n\nstatic void test_length()\n{\n  assert_true_rule(\n      \"rule test { strings: $a = /m.*?ssi/ condition: !a == 5 }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /m.*?ssi/ condition: !a[1] == 5 }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /m.*ssi/ condition: !a == 8 }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /m.*ssi/ condition: !a[1] == 8 }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ssi.*ppi/ condition: !a[1] == 9 }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ssi.*ppi/ condition: !a[2] == 6 }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = { 6D [1-3] 73 73 69 } condition: !a == 5}\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = { 6D [-] 73 73 69 } condition: !a == 5}\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = { 6D [-] 70 70 69 } condition: !a == 11}\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = { 6D 69 73 73 [-] 70 69 } condition: !a == 11}\",\n      \"mississippi\");\n}\n\n\nstatic void test_of()\n{\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"ssi\\\" $b = \\\"mis\\\" $c = \\\"oops\\\" \"\n      \"condition: any of them }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"ssi\\\" $b = \\\"mis\\\" $c = \\\"oops\\\" \"\n      \"condition: 1 of them }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"ssi\\\" $b = \\\"mis\\\" $c = \\\"oops\\\" \"\n      \"condition: 2 of them }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a1 = \\\"dummy1\\\" $b1 = \\\"dummy1\\\" $b2 = \\\"ssi\\\"\"\n      \"condition: any of ($a*, $b*) }\",\n      \"mississippi\");\n\n  assert_true_rule_blob(\n      \"rule test { \\\n         strings: \\\n           $ = /abc/ \\\n           $ = /def/ \\\n           $ = /ghi/ \\\n         condition: \\\n           for any of ($*) : ( for any i in (1..#): (uint8(@[i] - 1) == 0x00) )\\\n       }\",\n       \"abc\\000def\\000ghi\");\n\n  assert_false_rule(\n      \"rule test { \\\n        strings: \\\n          $a = \\\"ssi\\\" \\\n          $b = \\\"mis\\\" \\\n          $c = \\\"oops\\\" \\\n        condition: \\\n          all of them \\\n      }\",\n      \"mississippi\");\n\n  assert_error(\n      \"rule test { condition: all of ($a*) }\",\n      ERROR_UNDEFINED_STRING);\n\n  assert_error(\n      \"rule test { condition: all of them }\",\n      ERROR_UNDEFINED_STRING);\n}\n\n\nvoid test_for()\n{\n  assert_true_rule(\n      \"rule test { \\\n        strings: \\\n          $a = \\\"ssi\\\" \\\n        condition: \\\n          for all i in (1..#a) : (@a[i] >= 2 and @a[i] <= 5) \\\n      }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: \\\n          $a = \\\"ssi\\\" \\\n          $b = \\\"mi\\\" \\\n        condition: \\\n          for all i in (1..#a) : ( for all j in (1..#b) : (@a[i] >= @b[j])) \\\n      }\",\n      \"mississippi\");\n\n  assert_false_rule(\n      \"rule test { \\\n        strings: \\\n          $a = \\\"ssi\\\" \\\n        condition: \\\n          for all i in (1..#a) : (@a[i] == 5) \\\n      }\",\n      \"mississippi\");\n}\n\n\nvoid test_re()\n{\n  assert_true_rule(\n      \"rule test { strings: $a = /ssi/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ssi(s|p)/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ssim*/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ssa?/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /Miss/ nocase condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /(M|N)iss/ nocase condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /[M-N]iss/ nocase condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /(Mi|ssi)ssippi/ nocase condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ppi\\\\tmi/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ppi\\\\.mi/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /^mississippi/ fullword condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /mississippi.*mississippi$/s condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = /^ssi/ condition: $a }\",\n      \"mississippi\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = /ssi$/ condition: $a }\",\n      \"mississippi\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = /ssissi/ fullword condition: $a }\",\n      \"mississippi\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = /^[isp]+/ condition: $a }\",\n      \"mississippi\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /a.{1,2}b/ wide condition: !a == 6 }\",\n      \"a\\0x\\0b\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /a.{1,2}b/ wide condition: !a == 8 }\",\n      \"a\\0x\\0x\\0b\\0\");\n\n  assert_regexp_syntax_error(\")\");\n  assert_true_regexp(\"abc\", \"abc\", \"abc\");\n  assert_false_regexp(\"abc\", \"xbc\");\n  assert_false_regexp(\"abc\", \"axc\");\n  assert_false_regexp(\"abc\", \"abx\");\n  assert_true_regexp(\"abc\", \"xabcx\", \"abc\");\n  assert_true_regexp(\"abc\", \"ababc\", \"abc\");\n  assert_true_regexp(\"a.c\", \"abc\", \"abc\");\n  assert_false_regexp(\"a.b\", \"a\\nb\");\n  assert_false_regexp(\"a.*b\", \"acc\\nccb\");\n  assert_false_regexp(\"a.{4,5}b\", \"acc\\nccb\");\n  assert_true_regexp(\"a.b\", \"a\\rb\", \"a\\rb\");\n  assert_true_regexp(\"ab*c\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab*c\", \"ac\", \"ac\");\n  assert_true_regexp(\"ab*bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab*bc\", \"abbc\", \"abbc\");\n  assert_true_regexp(\"a.*bb\", \"abbbb\", \"abbbb\");\n  assert_true_regexp(\"a.*?bbb\", \"abbbbbb\", \"abbb\");\n  assert_true_regexp(\"a.*c\", \"ac\", \"ac\");\n  assert_true_regexp(\"a.*c\", \"axyzc\", \"axyzc\");\n  assert_true_regexp(\"ab+c\", \"abbc\", \"abbc\");\n  assert_false_regexp(\"ab+c\", \"ac\");\n  assert_true_regexp(\"ab+\", \"abbbb\", \"abbbb\");\n  assert_true_regexp(\"ab+?\", \"abbbb\", \"ab\");\n  assert_false_regexp(\"ab+bc\", \"abc\");\n  assert_false_regexp(\"ab+bc\", \"abq\");\n  assert_true_regexp(\"a+b+c\", \"aabbabc\", \"abc\");\n  assert_false_regexp(\"ab?bc\", \"abbbbc\");\n  assert_true_regexp(\"ab?c\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab*?\", \"abbb\", \"a\");\n  assert_true_regexp(\"ab?c\", \"ac\", \"ac\");\n  assert_true_regexp(\"ab??\", \"ab\", \"a\");\n  assert_true_regexp(\"a(b|x)c\", \"abc\", \"abc\");\n  assert_true_regexp(\"a(b|x)c\", \"axc\", \"axc\");\n  assert_true_regexp(\"a(b|.)c\", \"axc\", \"axc\");\n  assert_true_regexp(\"a(b|x|y)c\", \"ayc\", \"ayc\");\n  assert_true_regexp(\"(a+|b)*\", \"ab\", \"ab\");\n  assert_true_regexp(\"a|b|c|d|e\", \"e\", \"e\");\n  assert_true_regexp(\"(a|b|c|d|e)f\", \"ef\", \"ef\");\n  assert_true_regexp(\".b{2}\", \"abb\", \"abb\");\n  assert_true_regexp(\".b{2,3}\", \"abbb\", \"abbb\");\n  assert_true_regexp(\".b{2,3}?\", \"abbb\", \"abb\");\n  assert_true_regexp(\"ab{2,3}c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\"ab{2,3}?c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\".b{2,3}cccc\", \"abbbcccc\", \"abbbcccc\");\n  assert_true_regexp(\".b{2,3}?cccc\", \"abbbcccc\", \"bbbcccc\");\n  assert_true_regexp(\"a.b{2,3}cccc\", \"aabbbcccc\", \"aabbbcccc\");\n  assert_true_regexp(\"ab{2,3}c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\"ab{2,3}?c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\"ab{0,1}?c\", \"abc\", \"abc\");\n  assert_true_regexp(\"a{0,1}?bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"a{0,1}bc\", \"bbc\", \"bc\");\n  assert_true_regexp(\"a{0,1}?bc\", \"abc\", \"bc\");\n  assert_true_regexp(\"aa{0,1}?bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"aa{0,1}?bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"aa{0,1}bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab{1}c\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab{1,2}c\", \"abbc\", \"abbc\");\n  assert_true_regexp(\"ab{1,}c\", \"abbbc\", \"abbbc\");\n  assert_false_regexp(\"ab{1,}b\", \"ab\");\n  assert_false_regexp(\"ab{1}c\", \"abbc\");\n  assert_true_regexp(\"ab{0,}c\", \"ac\", \"ac\");\n  assert_true_regexp(\"ab{1,1}c\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab{0,}c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\"ab{,3}c\", \"abbbc\", \"abbbc\");\n  assert_false_regexp(\"ab{,2}c\", \"abbbc\");\n  assert_false_regexp(\"ab{4,5}bc\", \"abbbbc\");\n  assert_true_regexp(\"ab{0,1}\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{0,2}\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\"ab{0,3}\", \"abbbbb\", \"abbb\");\n  assert_true_regexp(\"ab{0,4}\", \"abbbbb\", \"abbbb\");\n  assert_true_regexp(\"ab{1,1}\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{1,2}\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\"ab{1,3}\", \"abbbbb\", \"abbb\");\n  assert_true_regexp(\"ab{2,2}\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\"ab{2,3}\", \"abbbbb\", \"abbb\");\n  assert_true_regexp(\"ab{1,3}?\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{0,1}?\", \"abbbbb\", \"a\");\n  assert_true_regexp(\"ab{0,2}?\", \"abbbbb\", \"a\");\n  assert_true_regexp(\"ab{0,3}?\", \"abbbbb\", \"a\");\n  assert_true_regexp(\"ab{0,4}?\", \"abbbbb\", \"a\");\n  assert_true_regexp(\"ab{1,1}?\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{1,2}?\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{1,3}?\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{2,2}?\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\"ab{2,3}?\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\".(abc){0,1}\", \"xabcabcabcabc\", \"xabc\");\n  assert_true_regexp(\".(abc){0,2}\", \"xabcabcabcabc\", \"xabcabc\");\n  assert_true_regexp(\"x{1,2}abcd\", \"xxxxabcd\", \"xxabcd\");\n  assert_true_regexp(\"x{1,2}abcd\", \"xxxxabcd\", \"xxabcd\");\n  assert_true_regexp(\"ab{.*}\", \"ab{c}\", \"ab{c}\");\n  assert_true_regexp(\".(aa){1,2}\", \"aaaaaaaaaa\", \"aaaaa\");\n  assert_true_regexp(\"a.(bc.){2}\", \"aabcabca\", \"aabcabca\");\n  assert_true_regexp(\"(ab{1,2}c){1,3}\", \"abbcabc\", \"abbcabc\");\n  assert_true_regexp(\"ab(c|cc){1,3}d\", \"abccccccd\", \"abccccccd\");\n  assert_true_regexp(\"a[bx]c\", \"abc\", \"abc\");\n  assert_true_regexp(\"a[bx]c\", \"axc\", \"axc\");\n  assert_true_regexp(\"a[0-9]*b\", \"ab\", \"ab\");\n  assert_true_regexp(\"a[0-9]*b\", \"a0123456789b\", \"a0123456789b\");\n  assert_true_regexp(\"[0-9a-f]+\", \"0123456789abcdef\", \"0123456789abcdef\");\n  assert_true_regexp(\"[0-9a-f]+\", \"xyz0123456789xyz\", \"0123456789\");\n  assert_true_regexp(\"a[\\\\s\\\\S]b\", \"a b\", \"a b\");\n  assert_true_regexp(\"a[\\\\d\\\\D]b\", \"a1b\", \"a1b\");\n  assert_false_regexp(\"[x-z]+\", \"abc\");\n  assert_true_regexp(\"a[-]?c\", \"ac\", \"ac\");\n  assert_true_regexp(\"a[-b]\", \"a-\", \"a-\");\n  assert_true_regexp(\"a[-b]\", \"ab\", \"ab\");\n  assert_true_regexp(\"a[b-]\", \"a-\", \"a-\");\n  assert_true_regexp(\"a[b-]\", \"ab\", \"ab\");\n  assert_true_regexp(\"[a-c-e]\", \"b\", \"b\");\n  assert_true_regexp(\"[a-c-e]\", \"-\", \"-\");\n  assert_false_regexp(\"[a-c-e]\", \"d\");\n  assert_regexp_syntax_error(\"[b-a]\");\n  assert_regexp_syntax_error(\"(abc\");\n  assert_regexp_syntax_error(\"abc)\");\n  assert_regexp_syntax_error(\"a[]b\");\n  assert_true_regexp(\"a[\\\\-b]\", \"a-\", \"a-\");\n  assert_true_regexp(\"a[\\\\-b]\", \"ab\", \"ab\");\n  assert_true_regexp(\"a]\", \"a]\", \"a]\");\n  assert_true_regexp(\"a[]]b\", \"a]b\", \"a]b\");\n  assert_true_regexp(\"a[\\\\]]b\", \"a]b\", \"a]b\");\n  assert_true_regexp(\"a[^bc]d\", \"aed\", \"aed\");\n  assert_false_regexp(\"a[^bc]d\", \"abd\");\n  assert_true_regexp(\"a[^-b]c\", \"adc\", \"adc\");\n  assert_false_regexp(\"a[^-b]c\", \"a-c\");\n  assert_false_regexp(\"a[^]b]c\", \"a]c\");\n  assert_true_regexp(\"a[^]b]c\", \"adc\", \"adc\");\n  assert_true_regexp(\"[^ab]*\", \"cde\", \"cde\");\n  assert_regexp_syntax_error(\")(\");\n  assert_true_regexp(\"a\\\\sb\", \"a b\", \"a b\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\tb\", \"a\\tb\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\rb\", \"a\\rb\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\nb\", \"a\\nb\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\vb\", \"a\\vb\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\fb\", \"a\\fb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a b\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\tb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\rb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\nb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\vb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\fb\");\n  assert_true_regexp(\"\\\\n\\\\r\\\\t\\\\f\\\\a\", \"\\n\\r\\t\\f\\a\", \"\\n\\r\\t\\f\\a\");\n  assert_true_regexp(\"[\\\\n][\\\\r][\\\\t][\\\\f][\\\\a]\", \"\\n\\r\\t\\f\\a\", \"\\n\\r\\t\\f\\a\");\n  assert_true_regexp(\"\\\\x01\\\\x02\\\\x03\", \"\\x01\\x02\\x03\", \"\\x01\\x02\\x03\");\n  assert_true_regexp(\"[\\\\x01-\\\\x03]+\", \"\\x01\\x02\\x03\", \"\\x01\\x02\\x03\");\n  assert_false_regexp(\"[\\\\x00-\\\\x02]+\", \"\\x03\\x04\\x05\");\n  assert_true_regexp(\"[\\\\x5D]\", \"]\", \"]\");\n  assert_true_regexp(\"[\\\\0x5A-\\\\x5D]\", \"\\x5B\", \"\\x5B\");\n  assert_true_regexp(\"[\\\\x5D-\\\\x5F]\", \"\\x5E\", \"\\x5E\");\n  assert_true_regexp(\"[\\\\x5C-\\\\x5F]\", \"\\x5E\", \"\\x5E\");\n  assert_true_regexp(\"[\\\\x5D-\\\\x5F]\", \"\\x5E\", \"\\x5E\");\n  assert_true_regexp(\"a\\\\wc\", \"abc\", \"abc\");\n  assert_true_regexp(\"a\\\\wc\", \"a_c\", \"a_c\");\n  assert_true_regexp(\"a\\\\wc\", \"a0c\", \"a0c\");\n  assert_false_regexp(\"a\\\\wc\", \"a*c\");\n  assert_true_regexp(\"\\\\w+\", \"--ab_cd0123--\", \"ab_cd0123\");\n  assert_true_regexp(\"[\\\\w]+\", \"--ab_cd0123--\", \"ab_cd0123\");\n  assert_true_regexp(\"\\\\D+\", \"1234abc5678\", \"abc\");\n  assert_true_regexp(\"[\\\\d]+\", \"0123456789\", \"0123456789\");\n  assert_true_regexp(\"[\\\\D]+\", \"1234abc5678\", \"abc\");\n  assert_true_regexp(\"[\\\\da-fA-F]+\", \"123abc\", \"123abc\");\n  assert_false_regexp(\"^(ab|cd)e\", \"abcde\");\n  assert_true_regexp(\"(abc|)ef\", \"abcdef\", \"ef\");\n  assert_true_regexp(\"(abc|)ef\", \"abcef\", \"abcef\");\n  assert_true_regexp(\"\\\\babc\", \"abc\", \"abc\");\n  assert_true_regexp(\"abc\\\\b\", \"abc\", \"abc\");\n  assert_false_regexp(\"\\\\babc\", \"1abc\");\n  assert_false_regexp(\"abc\\\\b\", \"abc1\");\n  assert_true_regexp(\"abc\\\\s\\\\b\", \"abc x\", \"abc \");\n  assert_false_regexp(\"abc\\\\s\\\\b\", \"abc  \");\n  assert_true_regexp(\"\\\\babc\\\\b\", \" abc \", \"abc\");\n  assert_true_regexp(\"\\\\b\\\\w\\\\w\\\\w\\\\b\", \" abc \", \"abc\");\n  assert_true_regexp(\"\\\\w\\\\w\\\\w\\\\b\", \"abcd\", \"bcd\");\n  assert_true_regexp(\"\\\\b\\\\w\\\\w\\\\w\", \"abcd\", \"abc\");\n  assert_false_regexp(\"\\\\b\\\\w\\\\w\\\\w\\\\b\", \"abcd\");\n  assert_false_regexp(\"\\\\Babc\", \"abc\");\n  assert_false_regexp(\"abc\\\\B\", \"abc\");\n  assert_true_regexp(\"\\\\Babc\", \"1abc\", \"abc\");\n  assert_true_regexp(\"abc\\\\B\", \"abc1\", \"abc\");\n  assert_false_regexp(\"abc\\\\s\\\\B\", \"abc x\");\n  assert_true_regexp(\"abc\\\\s\\\\B\", \"abc  \", \"abc \");\n  assert_true_regexp(\"\\\\w\\\\w\\\\w\\\\B\", \"abcd\", \"abc\");\n  assert_true_regexp(\"\\\\B\\\\w\\\\w\\\\w\", \"abcd\", \"bcd\");\n  assert_false_regexp(\"\\\\B\\\\w\\\\w\\\\w\\\\B\", \"abcd\");\n\n  // This is allowed in most regexp engines but in order to keep the\n  // grammar free of shift/reduce conflicts I've decided not supporting\n  // it. Users can use the (abc|) form instead.\n  assert_regexp_syntax_error(\"(|abc)ef\");\n\n  assert_true_regexp(\"((a)(b)c)(d)\", \"abcd\", \"abcd\");\n  assert_true_regexp(\"(a|b)c*d\", \"abcd\", \"bcd\");\n  assert_true_regexp(\"(ab|ab*)bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"a([bc]*)c*\", \"abc\", \"abc\");\n  assert_true_regexp(\"a([bc]*)c*\", \"ac\", \"ac\");\n  assert_true_regexp(\"a([bc]*)c*\", \"a\", \"a\");\n  assert_true_regexp(\"a([bc]*)(c*d)\", \"abcd\", \"abcd\");\n  assert_true_regexp(\"a([bc]+)(c*d)\", \"abcd\", \"abcd\");\n  assert_true_regexp(\"a([bc]*)(c+d)\", \"abcd\", \"abcd\");\n  assert_true_regexp(\"a[bcd]*dcdcde\", \"adcdcde\", \"adcdcde\");\n  assert_false_regexp(\"a[bcd]+dcdcde\", \"adcdcde\");\n  assert_true_regexp(\"\\\\((.*), (.*)\\\\)\", \"(a, b)\", \"(a, b)\");\n  assert_true_regexp(\"abc|123$\", \"abcx\", \"abc\");\n  assert_false_regexp(\"abc|123$\", \"123x\");\n  assert_true_regexp(\"abc|^123\", \"123\", \"123\");\n  assert_false_regexp(\"abc|^123\", \"x123\");\n  assert_true_regexp(\"^abc$\", \"abc\", \"abc\");\n  assert_false_regexp(\"^abc$\", \"abcc\");\n  assert_true_regexp(\"^abc\", \"abcc\", \"abc\");\n  assert_false_regexp(\"^abc$\", \"aabc\");\n  assert_false_regexp(\"abc^\", \"abc\");\n  assert_false_regexp(\"ab^c\", \"abc\");\n  assert_false_regexp(\"a^bcdef\", \"abcdef\")\n  assert_true_regexp(\"abc$\", \"aabc\", \"abc\");\n  assert_false_regexp(\"$abc\", \"abc\");\n  assert_true_regexp(\"(a|a$)bcd\", \"abcd\", \"abcd\");\n  assert_false_regexp(\"(a$|a$)bcd\", \"abcd\");\n  assert_false_regexp(\"(abc$|ab$)\", \"abcd\");\n  assert_true_regexp(\"^a(bc+|b[eh])g|.h$\", \"abhg\", \"abhg\");\n  assert_true_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"effgz\", \"effgz\");\n  assert_true_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"ij\", \"ij\");\n  assert_false_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"effg\");\n  assert_false_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"bcdd\");\n  assert_true_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"reffgz\", \"effgz\");\n\n  // Test case for issue #324\n  assert_true_regexp(\"whatever|   x.   x\", \"   xy   x\", \"   xy   x\");\n\n  // test case for issue #503, \\x without two following hex-digits\n  assert_regexp_syntax_error(\"\\\\x0\");\n  assert_regexp_syntax_error(\"\\\\x\");\n\n  assert_regexp_syntax_error(\"x{0,0}\");\n  assert_regexp_syntax_error(\"x{0}\");\n\n  assert_regexp_syntax_error(\"\\\\xxy\");\n\n  assert_error(\n      \"rule test { strings: $a = /a\\\\/ condition: $a }\",\n      ERROR_SYNTAX_ERROR);\n\n  assert_error(\n      \"rule test { strings: $a = /[a\\\\/ condition: $a }\",\n      ERROR_SYNTAX_ERROR);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = /MZ.{300,}t/ \\\n        condition: !a == 317 }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = /MZ.{300,}?t/ \\\n        condition: !a == 314 }\",\n      PE32_FILE);\n}\n\n\nstatic void test_entrypoint()\n{\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 6a 2a 58 c3 } \\\n        condition: $a at entrypoint }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { b8 01 00 00 00 bb 2a } \\\n        condition: $a at entrypoint }\",\n      ELF32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { b8 01 00 00 00 bb 2a } \\\n        condition: $a at entrypoint }\",\n      ELF64_FILE);\n\n  assert_false_rule(\n      \"rule test { condition: entrypoint >= 0 }\",\n      NULL);\n}\n\n\nstatic void test_filesize()\n{\n  char rule[80];\n\n  snprintf(\n      rule,\n      sizeof(rule),\n      \"rule test { condition: filesize == %zd }\",\n      sizeof(PE32_FILE));\n\n  assert_true_rule_blob(\n      rule,\n      PE32_FILE);\n}\n\n\nstatic void test_comments()\n{\n  assert_true_rule(\n      \"rule test {\\n\\\n         condition:\\n\\\n             //  this is a comment\\n\\\n             /*** this is a comment ***/\\n\\\n             /* /* /*\\n\\\n                 this is a comment\\n\\\n             */\\n\\\n             true\\n\\\n      }\",\n      NULL);\n}\n\nstatic void test_matches_operator()\n{\n  assert_true_rule(\n      \"rule test { condition: \\\"foo\\\" matches /foo/ }\",\n      NULL);\n\n  assert_false_rule(\n      \"rule test { condition: \\\"foo\\\" matches /bar/ }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { condition: \\\"FoO\\\" matches /fOo/i }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { condition: \\\"xxFoOxx\\\" matches /fOo/i }\",\n      NULL);\n\n  assert_false_rule(\n      \"rule test { condition: \\\"xxFoOxx\\\" matches /^fOo/i }\",\n      NULL);\n\n  assert_false_rule(\n      \"rule test { condition: \\\"xxFoOxx\\\" matches /fOo$/i }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { condition: \\\"foo\\\" matches /^foo$/i }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { condition: \\\"foo\\\\nbar\\\" matches /foo.*bar/s }\",\n      NULL);\n\n  assert_false_rule(\n      \"rule test { condition: \\\"foo\\\\nbar\\\" matches /foo.*bar/ }\",\n      NULL);\n}\n\n\nstatic void test_global_rules()\n{\n  assert_true_rule(\n      \"global private rule global_rule { \\\n        condition: \\\n          true \\\n      } \\\n      rule test { \\\n        condition: true \\\n      }\",\n      NULL);\n\n  assert_false_rule(\n      \"global private rule global_rule { \\\n        condition: \\\n          false \\\n      } \\\n      rule test { \\\n        condition: true \\\n      }\",\n      NULL);\n}\n\n\nstatic void test_modules()\n{\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.constants.one + 1 == tests.constants.two \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.constants.foo == \\\"foo\\\" \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.constants.empty == \\\"\\\"  \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.empty() == \\\"\\\"  \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.struct_array[1].i == 1  \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.struct_array[0].i == 1 or true \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.integer_array[0] == 0 \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.integer_array[1] == 1 \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.string_array[0] == \\\"foo\\\" \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.string_array[2] == \\\"baz\\\" \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.string_dict[\\\"foo\\\"] == \\\"foo\\\" \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.string_dict[\\\"bar\\\"] == \\\"bar\\\" \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.isum(1,2) == 3 \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.isum(1,2,3) == 6 \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.fsum(1.0,2.0) == 3.0 \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.fsum(1.0,2.0,3.0) == 6.0 \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.length(\\\"dummy\\\") == 5 \\\n      }\",\n      NULL);\n\n\n  assert_false_rule(\n      \"import \\\"tests\\\" \\\n      rule test { condition: tests.struct_array[0].i == 1  \\\n      }\",\n      NULL);\n\n  assert_false_rule(\n      \"import \\\"tests\\\" \\\n      rule test { condition: tests.isum(1,1) == 3 \\\n      }\",\n      NULL);\n\n  assert_false_rule(\n      \"import \\\"tests\\\" \\\n      rule test { condition: tests.fsum(1.0,1.0) == 3.0 \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n      rule test { condition: tests.match(/foo/,\\\"foo\\\") == 3 \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n      rule test { condition: tests.match(/foo/,\\\"bar\\\") == -1\\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n      rule test { condition: tests.match(/foo.bar/i,\\\"FOO\\\\nBAR\\\") == -1\\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n      rule test { condition: tests.match(/foo.bar/is,\\\"FOO\\\\nBAR\\\") == 7\\\n      }\",\n      NULL);\n\n  assert_error(\n      \"import \\\"\\\\x00\\\"\",\n      ERROR_INVALID_MODULE_NAME);\n\n  assert_error(\n      \"import \\\"\\\"\",\n      ERROR_INVALID_MODULE_NAME);\n}\n\n#if defined(HASH_MODULE)\nstatic void test_hash_module()\n{\n  uint8_t blob[] = {0x61, 0x62, 0x63, 0x64, 0x65};\n\n  assert_true_rule_blob(\n      \"import \\\"hash\\\" \\\n       rule test { \\\n        condition: \\\n          hash.md5(0, filesize) == \\\n            \\\"ab56b4d92b40713acc5af89985d4b786\\\" \\\n            and \\\n          hash.md5(1, filesize) == \\\n            \\\"e02cfbe5502b64aa5ae9f2d0d69eaa8d\\\" \\\n            and \\\n          hash.sha1(0, filesize) == \\\n            \\\"03de6c570bfe24bfc328ccd7ca46b76eadaf4334\\\" \\\n            and \\\n          hash.sha1(1, filesize) == \\\n            \\\"a302d65ae4d9e768a1538d53605f203fd8e2d6e2\\\" \\\n            and \\\n          hash.sha256(0, filesize) == \\\n            \\\"36bbe50ed96841d10443bcb670d6554f0a34b761be67ec9c4a8ad2c0c44ca42c\\\" \\\n            and \\\n          hash.sha256(1, filesize) == \\\n            \\\"aaaaf2863e043b9df604158ad5c16ff1adaf3fd7e9fcea5dcb322b6762b3b59a\\\" \\\n      }\",\n      blob);\n\n  // Test hash caching mechanism\n\n  assert_true_rule_blob(\n      \"import \\\"hash\\\" \\\n       rule test { \\\n        condition: \\\n          hash.md5(0, filesize) == \\\n            \\\"ab56b4d92b40713acc5af89985d4b786\\\" \\\n            and \\\n          hash.md5(1, filesize) == \\\n            \\\"e02cfbe5502b64aa5ae9f2d0d69eaa8d\\\" \\\n            and \\\n          hash.md5(0, filesize) == \\\n            \\\"ab56b4d92b40713acc5af89985d4b786\\\" \\\n            and \\\n          hash.md5(1, filesize) == \\\n            \\\"e02cfbe5502b64aa5ae9f2d0d69eaa8d\\\" \\\n      }\",\n      blob);\n}\n#endif\n\n\nvoid test_integer_functions()\n{\n  assert_true_rule(\n      \"rule test { condition: uint8(0) == 0xAA}\",\n      \"\\xaa\\xbb\\xcc\\xdd\");\n\n  assert_true_rule(\n      \"rule test { condition: uint16(0) == 0xBBAA}\",\n      \"\\xaa\\xbb\\xcc\\xdd\");\n\n  assert_true_rule(\n      \"rule test { condition: uint32(0) == 0xDDCCBBAA}\",\n      \"\\xaa\\xbb\\xcc\\xdd\");\n\n  assert_true_rule(\n      \"rule test { condition: uint8be(0) == 0xAA}\",\n      \"\\xaa\\xbb\\xcc\\xdd\");\n\n  assert_true_rule(\n      \"rule test { condition: uint16be(0) == 0xAABB}\",\n      \"\\xaa\\xbb\\xcc\\xdd\");\n\n  assert_true_rule(\n      \"rule test { condition: uint32be(0) == 0xAABBCCDD}\",\n      \"\\xaa\\xbb\\xcc\\xdd\");\n}\n\n\nvoid test_file_descriptor()\n{\n  YR_COMPILER* compiler = NULL;\n  YR_RULES* rules = NULL;\n\n#if defined(_WIN32) || defined(__CYGWIN__)\n  HANDLE fd = CreateFile(\"tests/data/true.yar\", GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);\n  if (fd == INVALID_HANDLE_VALUE)\n  {\n    fputs(\"CreateFile failed\", stderr);\n    exit(1);\n  }\n#else\n  int fd = open(\"tests/data/true.yar\", O_RDONLY);\n  if (fd < 0)\n  {\n    perror(\"open\");\n    exit(EXIT_FAILURE);\n  }\n#endif\n  if (yr_compiler_create(&compiler) != ERROR_SUCCESS)\n  {\n    perror(\"yr_compiler_create\");\n    exit(EXIT_FAILURE);\n  }\n\n  if (yr_compiler_add_fd(compiler, fd, NULL, NULL) != 0) {\n    perror(\"yr_compiler_add_fd\");\n    exit(EXIT_FAILURE);\n  }\n\n#if defined(_WIN32) || defined(__CYGWIN__)\n  CloseHandle(fd);\n#else\n  close(fd);\n#endif\n\n  if (yr_compiler_get_rules(compiler, &rules) != ERROR_SUCCESS) {\n    perror(\"yr_compiler_add_fd\");\n    exit(EXIT_FAILURE);\n  }\n\n  if (compiler)\n  {\n    yr_compiler_destroy(compiler);\n  }\n  if (rules)\n  {\n    yr_rules_destroy(rules);\n  }\n\n  return;\n}\n\n\nint main(int argc, char** argv)\n{\n  yr_initialize();\n\n  test_boolean_operators();\n  test_comparison_operators();\n  test_arithmetic_operators();\n  test_bitwise_operators();\n  test_matches_operator();\n  test_syntax();\n  test_anonymous_strings();\n  test_strings();\n  test_wildcard_strings();\n  test_hex_strings();\n  test_count();\n  test_at();\n  test_in();\n  test_offset();\n  test_length();\n  test_of();\n  test_for();\n  test_re();\n  test_filesize();\n  // test_compile_file();\n  // test_compile_files();\n  // test_include_files();\n  // test_externals();\n  // test_callback();\n  // test_compare();\n  test_comments();\n  test_modules();\n  test_integer_functions();\n  // test_string_io();\n  test_entrypoint();\n  test_global_rules();\n\n  #if defined(HASH_MODULE)\n  test_hash_module();\n  #endif\n\n  test_file_descriptor();\n\n  yr_finalize();\n\n  return 0;\n}\n"], "fixing_code": ["/*\nCopyright (c) 2013-2014. The YARA Authors. All Rights Reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\nlist of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors\nmay be used to endorse or promote products derived from this software without\nspecific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#define _GNU_SOURCE\n\n#include <string.h>\n#include <assert.h>\n#include <time.h>\n#include <math.h>\n\n#include <yara/endian.h>\n#include <yara/exec.h>\n#include <yara/limits.h>\n#include <yara/error.h>\n#include <yara/object.h>\n#include <yara/modules.h>\n#include <yara/re.h>\n#include <yara/strutils.h>\n#include <yara/utils.h>\n#include <yara/mem.h>\n\n#include <yara.h>\n\n\n#define MEM_SIZE   MAX_LOOP_NESTING * LOOP_LOCAL_VARS\n\n\n#define push(x)  \\\n    if (sp < stack_size) \\\n    { \\\n      stack[sp++] = (x); \\\n    } \\\n    else \\\n    { \\\n      result = ERROR_EXEC_STACK_OVERFLOW; \\\n      stop = TRUE; \\\n      break; \\\n    } \\\n\n\n#define pop(x)  x = stack[--sp]\n\n#define is_undef(x) IS_UNDEFINED((x).i)\n\n#define ensure_defined(x) \\\n    if (is_undef(x)) \\\n    { \\\n      r1.i = UNDEFINED; \\\n      push(r1); \\\n      break; \\\n    }\n\n\n#define little_endian_uint8_t(x)     (x)\n#define little_endian_int8_t(x)      (x)\n#define little_endian_uint16_t(x)    yr_le16toh(x)\n#define little_endian_int16_t(x)     yr_le16toh(x)\n#define little_endian_uint32_t(x)    yr_le32toh(x)\n#define little_endian_int32_t(x)     yr_le32toh(x)\n\n#define big_endian_uint8_t(x)        (x)\n#define big_endian_int8_t(x)         (x)\n#define big_endian_uint16_t(x)       yr_be16toh(x)\n#define big_endian_int16_t(x)        yr_be16toh(x)\n#define big_endian_uint32_t(x)       yr_be32toh(x)\n#define big_endian_int32_t(x)        yr_be32toh(x)\n\n\n#define function_read(type, endianess) \\\n    int64_t read_##type##_##endianess(YR_MEMORY_BLOCK_ITERATOR* iterator, size_t offset) \\\n    { \\\n      YR_MEMORY_BLOCK* block = iterator->first(iterator); \\\n      while (block != NULL) \\\n      { \\\n        if (offset >= block->base && \\\n            block->size >= sizeof(type) && \\\n            offset <= block->base + block->size - sizeof(type)) \\\n        { \\\n          type result; \\\n          uint8_t* data = block->fetch_data(block); \\\n          if (data == NULL) \\\n            return UNDEFINED; \\\n          result = *(type *)(data + offset - block->base); \\\n          result = endianess##_##type(result); \\\n          return result; \\\n        } \\\n        block = iterator->next(iterator); \\\n      } \\\n      return UNDEFINED; \\\n    };\n\n\nfunction_read(uint8_t, little_endian)\nfunction_read(uint16_t, little_endian)\nfunction_read(uint32_t, little_endian)\nfunction_read(int8_t, little_endian)\nfunction_read(int16_t, little_endian)\nfunction_read(int32_t, little_endian)\nfunction_read(uint8_t, big_endian)\nfunction_read(uint16_t, big_endian)\nfunction_read(uint32_t, big_endian)\nfunction_read(int8_t, big_endian)\nfunction_read(int16_t, big_endian)\nfunction_read(int32_t, big_endian)\n\n\nstatic uint8_t* jmp_if(\n    int condition,\n    uint8_t* ip)\n{\n  uint8_t* result;\n\n  if (condition)\n  {\n    result = *(uint8_t**)(ip + 1);\n\n    // ip will be incremented at the end of the execution loop,\n    // decrement it here to compensate.\n\n    result--;\n  }\n  else\n  {\n    result = ip + sizeof(uint64_t);\n  }\n\n  return result;\n}\n\n\nint yr_execute_code(\n    YR_RULES* rules,\n    YR_SCAN_CONTEXT* context,\n    int timeout,\n    time_t start_time)\n{\n  int64_t mem[MEM_SIZE];\n  int32_t sp = 0;\n  uint8_t* ip = rules->code_start;\n\n  YR_VALUE args[MAX_FUNCTION_ARGS];\n  YR_VALUE *stack;\n  YR_VALUE r1;\n  YR_VALUE r2;\n  YR_VALUE r3;\n\n  #ifdef PROFILING_ENABLED\n  YR_RULE* current_rule = NULL;\n  #endif\n\n  YR_RULE* rule;\n  YR_MATCH* match;\n  YR_OBJECT_FUNCTION* function;\n\n  char* identifier;\n  char* args_fmt;\n\n  int i;\n  int found;\n  int count;\n  int result = ERROR_SUCCESS;\n  int stop = FALSE;\n  int cycle = 0;\n  int tidx = context->tidx;\n  int stack_size;\n\n  #ifdef PROFILING_ENABLED\n  clock_t start = clock();\n  #endif\n\n  yr_get_configuration(YR_CONFIG_STACK_SIZE, (void*) &stack_size);\n\n  stack = (YR_VALUE*) yr_malloc(stack_size * sizeof(YR_VALUE));\n\n  if (stack == NULL)\n    return ERROR_INSUFFICIENT_MEMORY;\n\n  while(!stop)\n  {\n    switch(*ip)\n    {\n      case OP_HALT:\n        assert(sp == 0); // When HALT is reached the stack should be empty.\n        stop = TRUE;\n        break;\n\n      case OP_PUSH:\n        r1.i = *(uint64_t*)(ip + 1);\n        ip += sizeof(uint64_t);\n        push(r1);\n        break;\n\n      case OP_POP:\n        pop(r1);\n        break;\n\n      case OP_CLEAR_M:\n        r1.i = *(uint64_t*)(ip + 1);\n        ip += sizeof(uint64_t);\n        mem[r1.i] = 0;\n        break;\n\n      case OP_ADD_M:\n        r1.i = *(uint64_t*)(ip + 1);\n        ip += sizeof(uint64_t);\n        pop(r2);\n        if (!is_undef(r2))\n          mem[r1.i] += r2.i;\n        break;\n\n      case OP_INCR_M:\n        r1.i = *(uint64_t*)(ip + 1);\n        ip += sizeof(uint64_t);\n        mem[r1.i]++;\n        break;\n\n      case OP_PUSH_M:\n        r1.i = *(uint64_t*)(ip + 1);\n        ip += sizeof(uint64_t);\n        r1.i = mem[r1.i];\n        push(r1);\n        break;\n\n      case OP_POP_M:\n        r1.i = *(uint64_t*)(ip + 1);\n        ip += sizeof(uint64_t);\n        pop(r2);\n        mem[r1.i] = r2.i;\n        break;\n\n      case OP_SWAPUNDEF:\n        r1.i = *(uint64_t*)(ip + 1);\n        ip += sizeof(uint64_t);\n        pop(r2);\n\n        if (is_undef(r2))\n        {\n          r1.i = mem[r1.i];\n          push(r1);\n        }\n        else\n        {\n          push(r2);\n        }\n        break;\n\n      case OP_JNUNDEF:\n        pop(r1);\n        push(r1);\n\n        ip = jmp_if(!is_undef(r1), ip);\n        break;\n\n      case OP_JLE:\n        pop(r2);\n        pop(r1);\n        push(r1);\n        push(r2);\n\n        ip = jmp_if(r1.i <= r2.i, ip);\n        break;\n\n      case OP_JTRUE:\n        pop(r1);\n        push(r1);\n\n        ip = jmp_if(!is_undef(r1) && r1.i, ip);\n        break;\n\n      case OP_JFALSE:\n        pop(r1);\n        push(r1);\n\n        ip = jmp_if(is_undef(r1) || !r1.i, ip);\n        break;\n\n      case OP_AND:\n        pop(r2);\n        pop(r1);\n\n        if (is_undef(r1) || is_undef(r2))\n          r1.i = 0;\n        else\n          r1.i = r1.i && r2.i;\n\n        push(r1);\n        break;\n\n      case OP_OR:\n        pop(r2);\n        pop(r1);\n\n        if (is_undef(r1))\n        {\n          push(r2);\n        }\n        else if (is_undef(r2))\n        {\n          push(r1);\n        }\n        else\n        {\n          r1.i = r1.i || r2.i;\n          push(r1);\n        }\n        break;\n\n      case OP_NOT:\n        pop(r1);\n\n        if (is_undef(r1))\n          r1.i = UNDEFINED;\n        else\n          r1.i= !r1.i;\n\n        push(r1);\n        break;\n\n      case OP_MOD:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        if (r2.i != 0)\n          r1.i = r1.i % r2.i;\n        else\n          r1.i = UNDEFINED;\n        push(r1);\n        break;\n\n      case OP_SHR:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i >> r2.i;\n        push(r1);\n        break;\n\n      case OP_SHL:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i << r2.i;\n        push(r1);\n        break;\n\n      case OP_BITWISE_NOT:\n        pop(r1);\n        ensure_defined(r1);\n        r1.i = ~r1.i;\n        push(r1);\n        break;\n\n      case OP_BITWISE_AND:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i & r2.i;\n        push(r1);\n        break;\n\n      case OP_BITWISE_OR:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i | r2.i;\n        push(r1);\n        break;\n\n      case OP_BITWISE_XOR:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i ^ r2.i;\n        push(r1);\n        break;\n\n      case OP_PUSH_RULE:\n        rule = *(YR_RULE**)(ip + 1);\n        ip += sizeof(uint64_t);\n        r1.i = rule->t_flags[tidx] & RULE_TFLAGS_MATCH ? 1 : 0;\n        push(r1);\n        break;\n\n      case OP_INIT_RULE:\n        #ifdef PROFILING_ENABLED\n        current_rule = *(YR_RULE**)(ip + 1);\n        #endif\n        ip += sizeof(uint64_t);\n        break;\n\n      case OP_MATCH_RULE:\n        pop(r1);\n        rule = *(YR_RULE**)(ip + 1);\n        ip += sizeof(uint64_t);\n\n        if (!is_undef(r1) && r1.i)\n          rule->t_flags[tidx] |= RULE_TFLAGS_MATCH;\n        else if (RULE_IS_GLOBAL(rule))\n          rule->ns->t_flags[tidx] |= NAMESPACE_TFLAGS_UNSATISFIED_GLOBAL;\n\n        #ifdef PROFILING_ENABLED\n        rule->clock_ticks += clock() - start;\n        start = clock();\n        #endif\n        break;\n\n      case OP_OBJ_LOAD:\n        identifier = *(char**)(ip + 1);\n        ip += sizeof(uint64_t);\n\n        r1.o = (YR_OBJECT*) yr_hash_table_lookup(\n            context->objects_table,\n            identifier,\n            NULL);\n\n        assert(r1.o != NULL);\n        push(r1);\n        break;\n\n      case OP_OBJ_FIELD:\n        identifier = *(char**)(ip + 1);\n        ip += sizeof(uint64_t);\n\n        pop(r1);\n        ensure_defined(r1);\n\n        r1.o = yr_object_lookup_field(r1.o, identifier);\n\n        assert(r1.o != NULL);\n        push(r1);\n        break;\n\n      case OP_OBJ_VALUE:\n        pop(r1);\n        ensure_defined(r1);\n\n        switch(r1.o->type)\n        {\n          case OBJECT_TYPE_INTEGER:\n            r1.i = ((YR_OBJECT_INTEGER*) r1.o)->value;\n            break;\n\n          case OBJECT_TYPE_FLOAT:\n            if (isnan(((YR_OBJECT_DOUBLE*) r1.o)->value))\n              r1.i = UNDEFINED;\n            else\n              r1.d = ((YR_OBJECT_DOUBLE*) r1.o)->value;\n            break;\n\n          case OBJECT_TYPE_STRING:\n            if (((YR_OBJECT_STRING*) r1.o)->value == NULL)\n              r1.i = UNDEFINED;\n            else\n              r1.p = ((YR_OBJECT_STRING*) r1.o)->value;\n            break;\n\n          default:\n            assert(FALSE);\n        }\n\n        push(r1);\n        break;\n\n      case OP_INDEX_ARRAY:\n        pop(r1);  // index\n        pop(r2);  // array\n\n        ensure_defined(r1);\n        ensure_defined(r2);\n        assert(r2.o->type == OBJECT_TYPE_ARRAY);\n\n        r1.o = yr_object_array_get_item(r2.o, 0, (int) r1.i);\n\n        if (r1.o == NULL)\n          r1.i = UNDEFINED;\n\n        push(r1);\n        break;\n\n      case OP_LOOKUP_DICT:\n        pop(r1);  // key\n        pop(r2);  // dictionary\n\n        ensure_defined(r1);\n        ensure_defined(r2);\n        assert(r2.o->type == OBJECT_TYPE_DICTIONARY);\n\n        r1.o = yr_object_dict_get_item(\n            r2.o, 0, r1.ss->c_string);\n\n        if (r1.o == NULL)\n          r1.i = UNDEFINED;\n\n        push(r1);\n        break;\n\n      case OP_CALL:\n        args_fmt = *(char**)(ip + 1);\n        ip += sizeof(uint64_t);\n\n        i = (int) strlen(args_fmt);\n        count = 0;\n\n        // pop arguments from stack and copy them to args array\n\n        while (i > 0)\n        {\n          pop(r1);\n\n          if (is_undef(r1))  // count the number of undefined args\n            count++;\n\n          args[i - 1] = r1;\n          i--;\n        }\n\n        pop(r2);\n        ensure_defined(r2);\n\n        if (count > 0)\n        {\n          // if there are undefined args, result for function call\n          // is undefined as well.\n\n          r1.i = UNDEFINED;\n          push(r1);\n          break;\n        }\n\n        function = (YR_OBJECT_FUNCTION*) r2.o;\n        result = ERROR_INTERNAL_FATAL_ERROR;\n\n        for (i = 0; i < MAX_OVERLOADED_FUNCTIONS; i++)\n        {\n          if (function->prototypes[i].arguments_fmt == NULL)\n            break;\n\n          if (strcmp(function->prototypes[i].arguments_fmt, args_fmt) == 0)\n          {\n            result = function->prototypes[i].code(args, context, function);\n            break;\n          }\n        }\n\n        assert(i < MAX_OVERLOADED_FUNCTIONS);\n\n        if (result == ERROR_SUCCESS)\n        {\n          r1.o = function->return_obj;\n          push(r1);\n        }\n        else\n        {\n          stop = TRUE;\n        }\n\n        break;\n\n      case OP_FOUND:\n        pop(r1);\n        r1.i = r1.s->matches[tidx].tail != NULL ? 1 : 0;\n        push(r1);\n        break;\n\n      case OP_FOUND_AT:\n        pop(r2);\n        pop(r1);\n\n        if (is_undef(r1))\n        {\n          r1.i = 0;\n          push(r1);\n          break;\n        }\n\n        match = r2.s->matches[tidx].head;\n        r3.i = FALSE;\n\n        while (match != NULL)\n        {\n          if (r1.i == match->base + match->offset)\n          {\n            r3.i = TRUE;\n            break;\n          }\n\n          if (r1.i < match->base + match->offset)\n            break;\n\n          match = match->next;\n        }\n\n        push(r3);\n        break;\n\n      case OP_FOUND_IN:\n        pop(r3);\n        pop(r2);\n        pop(r1);\n\n        ensure_defined(r1);\n        ensure_defined(r2);\n\n        match = r3.s->matches[tidx].head;\n        r3.i = FALSE;\n\n        while (match != NULL && !r3.i)\n        {\n          if (match->base + match->offset >= r1.i &&\n              match->base + match->offset <= r2.i)\n          {\n            r3.i = TRUE;\n          }\n\n          if (match->base + match->offset > r2.i)\n            break;\n\n          match = match->next;\n        }\n\n        push(r3);\n        break;\n\n      case OP_COUNT:\n        pop(r1);\n        r1.i = r1.s->matches[tidx].count;\n        push(r1);\n        break;\n\n      case OP_OFFSET:\n        pop(r2);\n        pop(r1);\n\n        ensure_defined(r1);\n\n        match = r2.s->matches[tidx].head;\n        i = 1;\n        r3.i = UNDEFINED;\n\n        while (match != NULL && r3.i == UNDEFINED)\n        {\n          if (r1.i == i)\n            r3.i = match->base + match->offset;\n\n          i++;\n          match = match->next;\n        }\n\n        push(r3);\n        break;\n\n      case OP_LENGTH:\n        pop(r2);\n        pop(r1);\n\n        ensure_defined(r1);\n\n        match = r2.s->matches[tidx].head;\n        i = 1;\n        r3.i = UNDEFINED;\n\n        while (match != NULL && r3.i == UNDEFINED)\n        {\n          if (r1.i == i)\n            r3.i = match->match_length;\n\n          i++;\n          match = match->next;\n        }\n\n        push(r3);\n        break;\n\n      case OP_OF:\n        found = 0;\n        count = 0;\n        pop(r1);\n\n        while (!is_undef(r1))\n        {\n          if (r1.s->matches[tidx].tail != NULL)\n            found++;\n          count++;\n          pop(r1);\n        }\n\n        pop(r2);\n\n        if (is_undef(r2))\n          r1.i = found >= count ? 1 : 0;\n        else\n          r1.i = found >= r2.i ? 1 : 0;\n\n        push(r1);\n        break;\n\n      case OP_FILESIZE:\n        r1.i = context->file_size;\n        push(r1);\n        break;\n\n      case OP_ENTRYPOINT:\n        r1.i = context->entry_point;\n        push(r1);\n        break;\n\n      case OP_INT8:\n        pop(r1);\n        r1.i = read_int8_t_little_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_INT16:\n        pop(r1);\n        r1.i = read_int16_t_little_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_INT32:\n        pop(r1);\n        r1.i = read_int32_t_little_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_UINT8:\n        pop(r1);\n        r1.i = read_uint8_t_little_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_UINT16:\n        pop(r1);\n        r1.i = read_uint16_t_little_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_UINT32:\n        pop(r1);\n        r1.i = read_uint32_t_little_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_INT8BE:\n        pop(r1);\n        r1.i = read_int8_t_big_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_INT16BE:\n        pop(r1);\n        r1.i = read_int16_t_big_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_INT32BE:\n        pop(r1);\n        r1.i = read_int32_t_big_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_UINT8BE:\n        pop(r1);\n        r1.i = read_uint8_t_big_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_UINT16BE:\n        pop(r1);\n        r1.i = read_uint16_t_big_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_UINT32BE:\n        pop(r1);\n        r1.i = read_uint32_t_big_endian(context->iterator, (size_t) r1.i);\n        push(r1);\n        break;\n\n      case OP_CONTAINS:\n        pop(r2);\n        pop(r1);\n\n        ensure_defined(r1);\n        ensure_defined(r2);\n\n        r1.i = memmem(r1.ss->c_string, r1.ss->length,\n                      r2.ss->c_string, r2.ss->length) != NULL;\n        push(r1);\n        break;\n\n      case OP_IMPORT:\n        r1.i = *(uint64_t*)(ip + 1);\n        ip += sizeof(uint64_t);\n\n        result = yr_modules_load((char*) r1.p, context);\n\n        if (result != ERROR_SUCCESS)\n          stop = TRUE;\n\n        break;\n\n      case OP_MATCHES:\n\n        pop(r2);\n        pop(r1);\n\n        ensure_defined(r2);\n        ensure_defined(r1);\n\n        if (r1.ss->length == 0)\n        {\n          r1.i = FALSE;\n          push(r1);\n          break;\n        }\n\n        r1.i = yr_re_exec(\n          (uint8_t*) r2.re->code,\n          (uint8_t*) r1.ss->c_string,\n          r1.ss->length,\n          0,\n          r2.re->flags | RE_FLAGS_SCAN,\n          NULL,\n          NULL) >= 0;\n\n        push(r1);\n        break;\n\n      case OP_INT_TO_DBL:\n        r1.i = *(uint64_t*)(ip + 1);\n        ip += sizeof(uint64_t);\n        r2 = stack[sp - r1.i];\n        if (is_undef(r2))\n          stack[sp - r1.i].i = UNDEFINED;\n        else\n          stack[sp - r1.i].d = (double) r2.i;\n        break;\n\n      case OP_STR_TO_BOOL:\n        pop(r1);\n        ensure_defined(r1);\n        r1.i = r1.ss->length > 0;\n        push(r1);\n        break;\n\n      case OP_INT_EQ:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i == r2.i;\n        push(r1);\n        break;\n\n      case OP_INT_NEQ:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i != r2.i;\n        push(r1);\n        break;\n\n      case OP_INT_LT:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i < r2.i;\n        push(r1);\n        break;\n\n      case OP_INT_GT:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i > r2.i;\n        push(r1);\n        break;\n\n      case OP_INT_LE:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i <= r2.i;\n        push(r1);\n        break;\n\n      case OP_INT_GE:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i >= r2.i;\n        push(r1);\n        break;\n\n      case OP_INT_ADD:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i + r2.i;\n        push(r1);\n        break;\n\n      case OP_INT_SUB:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i - r2.i;\n        push(r1);\n        break;\n\n      case OP_INT_MUL:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.i * r2.i;\n        push(r1);\n        break;\n\n      case OP_INT_DIV:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        if (r2.i != 0)\n          r1.i = r1.i / r2.i;\n        else\n          r1.i = UNDEFINED;\n        push(r1);\n        break;\n\n      case OP_INT_MINUS:\n        pop(r1);\n        ensure_defined(r1);\n        r1.i = -r1.i;\n        push(r1);\n        break;\n\n      case OP_DBL_LT:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.d < r2.d;\n        push(r1);\n        break;\n\n      case OP_DBL_GT:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.d > r2.d;\n        push(r1);\n        break;\n\n      case OP_DBL_LE:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.d <= r2.d;\n        push(r1);\n        break;\n\n      case OP_DBL_GE:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.d >= r2.d;\n        push(r1);\n        break;\n\n      case OP_DBL_EQ:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.d == r2.d;\n        push(r1);\n        break;\n\n      case OP_DBL_NEQ:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.i = r1.d != r2.d;\n        push(r1);\n        break;\n\n      case OP_DBL_ADD:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.d = r1.d + r2.d;\n        push(r1);\n        break;\n\n      case OP_DBL_SUB:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.d = r1.d - r2.d;\n        push(r1);\n        break;\n\n      case OP_DBL_MUL:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.d = r1.d * r2.d;\n        push(r1);\n        break;\n\n      case OP_DBL_DIV:\n        pop(r2);\n        pop(r1);\n        ensure_defined(r2);\n        ensure_defined(r1);\n        r1.d = r1.d / r2.d;\n        push(r1);\n        break;\n\n      case OP_DBL_MINUS:\n        pop(r1);\n        ensure_defined(r1);\n        r1.d = -r1.d;\n        push(r1);\n        break;\n\n      case OP_STR_EQ:\n      case OP_STR_NEQ:\n      case OP_STR_LT:\n      case OP_STR_LE:\n      case OP_STR_GT:\n      case OP_STR_GE:\n\n        pop(r2);\n        pop(r1);\n\n        ensure_defined(r1);\n        ensure_defined(r2);\n\n        switch(*ip)\n        {\n          case OP_STR_EQ:\n            r1.i = (sized_string_cmp(r1.ss, r2.ss) == 0);\n            break;\n          case OP_STR_NEQ:\n            r1.i = (sized_string_cmp(r1.ss, r2.ss) != 0);\n            break;\n          case OP_STR_LT:\n            r1.i = (sized_string_cmp(r1.ss, r2.ss) < 0);\n            break;\n          case OP_STR_LE:\n            r1.i = (sized_string_cmp(r1.ss, r2.ss) <= 0);\n            break;\n          case OP_STR_GT:\n            r1.i = (sized_string_cmp(r1.ss, r2.ss) > 0);\n            break;\n          case OP_STR_GE:\n            r1.i = (sized_string_cmp(r1.ss, r2.ss) >= 0);\n            break;\n        }\n\n        push(r1);\n        break;\n\n      default:\n        // Unknown instruction, this shouldn't happen.\n        assert(FALSE);\n    }\n\n    if (timeout > 0)  // timeout == 0 means no timeout\n    {\n      // Check for timeout every 10 instruction cycles.\n\n      if (++cycle == 10)\n      {\n        if (difftime(time(NULL), start_time) > timeout)\n        {\n          #ifdef PROFILING_ENABLED\n          assert(current_rule != NULL);\n          current_rule->clock_ticks += clock() - start;\n          #endif\n          result = ERROR_SCAN_TIMEOUT;\n          stop = TRUE;\n        }\n\n        cycle = 0;\n      }\n    }\n\n    ip++;\n  }\n\n  yr_modules_unload_all(context);\n  yr_free(stack);\n\n  return result;\n}\n", "/*\nCopyright (c) 2013. The YARA Authors. All Rights Reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\nlist of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors\nmay be used to endorse or promote products derived from this software without\nspecific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#ifndef YR_RE_H\n#define YR_RE_H\n\n#include <ctype.h>\n\n#include <yara/arena.h>\n#include <yara/sizedstr.h>\n\n#define RE_NODE_LITERAL             1\n#define RE_NODE_MASKED_LITERAL      2\n#define RE_NODE_ANY                 3\n#define RE_NODE_CONCAT              4\n#define RE_NODE_ALT                 5\n#define RE_NODE_RANGE               6\n#define RE_NODE_STAR                7\n#define RE_NODE_PLUS                8\n#define RE_NODE_CLASS               9\n#define RE_NODE_WORD_CHAR           10\n#define RE_NODE_NON_WORD_CHAR       11\n#define RE_NODE_SPACE               12\n#define RE_NODE_NON_SPACE           13\n#define RE_NODE_DIGIT               14\n#define RE_NODE_NON_DIGIT           15\n#define RE_NODE_EMPTY               16\n#define RE_NODE_ANCHOR_START        17\n#define RE_NODE_ANCHOR_END          18\n#define RE_NODE_WORD_BOUNDARY       19\n#define RE_NODE_NON_WORD_BOUNDARY   20\n#define RE_NODE_RANGE_ANY           21\n\n\n#define RE_OPCODE_ANY                   0xA0\n#define RE_OPCODE_ANY_EXCEPT_NEW_LINE   0xA1\n#define RE_OPCODE_LITERAL               0xA2\n#define RE_OPCODE_MASKED_LITERAL        0xA4\n#define RE_OPCODE_CLASS                 0xA5\n#define RE_OPCODE_WORD_CHAR             0xA7\n#define RE_OPCODE_NON_WORD_CHAR         0xA8\n#define RE_OPCODE_SPACE                 0xA9\n#define RE_OPCODE_NON_SPACE             0xAA\n#define RE_OPCODE_DIGIT                 0xAB\n#define RE_OPCODE_NON_DIGIT             0xAC\n#define RE_OPCODE_MATCH                 0xAD\n\n#define RE_OPCODE_MATCH_AT_END          0xB0\n#define RE_OPCODE_MATCH_AT_START        0xB1\n#define RE_OPCODE_WORD_BOUNDARY         0xB2\n#define RE_OPCODE_NON_WORD_BOUNDARY     0xB3\n#define RE_OPCODE_REPEAT_ANY_GREEDY     0xB4\n#define RE_OPCODE_REPEAT_ANY_UNGREEDY   0xB5\n\n#define RE_OPCODE_SPLIT_A               0xC0\n#define RE_OPCODE_SPLIT_B               0xC1\n#define RE_OPCODE_JUMP                  0xC2\n#define RE_OPCODE_REPEAT_START_GREEDY   0xC3\n#define RE_OPCODE_REPEAT_END_GREEDY     0xC4\n#define RE_OPCODE_REPEAT_START_UNGREEDY 0xC5\n#define RE_OPCODE_REPEAT_END_UNGREEDY   0xC6\n\n\n#define RE_FLAGS_FAST_REGEXP            0x02\n#define RE_FLAGS_BACKWARDS              0x04\n#define RE_FLAGS_EXHAUSTIVE             0x08\n#define RE_FLAGS_WIDE                   0x10\n#define RE_FLAGS_NO_CASE                0x20\n#define RE_FLAGS_SCAN                   0x40\n#define RE_FLAGS_DOT_ALL                0x80\n#define RE_FLAGS_GREEDY                0x400\n#define RE_FLAGS_UNGREEDY              0x800\n\n\ntypedef struct RE RE;\ntypedef struct RE_AST RE_AST;\ntypedef struct RE_NODE RE_NODE;\ntypedef struct RE_ERROR RE_ERROR;\n\ntypedef uint8_t RE_SPLIT_ID_TYPE;\n\n\nstruct RE_NODE\n{\n  int type;\n\n  union {\n    int value;\n    int count;\n    int start;\n  };\n\n  union {\n    int mask;\n    int end;\n  };\n\n  int greedy;\n\n  uint8_t* class_vector;\n\n  RE_NODE* left;\n  RE_NODE* right;\n\n  uint8_t* forward_code;\n  uint8_t* backward_code;\n};\n\n\nstruct RE_AST\n{\n  uint32_t flags;\n  RE_NODE* root_node;\n};\n\n\nstruct RE\n{\n  uint32_t flags;\n  uint8_t code[0];\n};\n\n\nstruct RE_ERROR\n{\n  char message[512];\n};\n\n\ntypedef int RE_MATCH_CALLBACK_FUNC(\n    uint8_t* match,\n    int match_length,\n    int flags,\n    void* args);\n\n\nint yr_re_ast_create(\n    RE_AST** re_ast);\n\nvoid yr_re_ast_destroy(\n    RE_AST* re_ast);\n\nvoid yr_re_ast_print(\n    RE_AST* re_ast);\n\nSIZED_STRING* yr_re_ast_extract_literal(\n    RE_AST* re_ast);\n\n\nint yr_re_ast_contains_dot_star(\n    RE_AST* re_ast);\n\n\nint yr_re_ast_split_at_chaining_point(\n    RE_AST* re_ast,\n    RE_AST** result_re_ast,\n    RE_AST** remainder_re_ast,\n    int32_t* min_gap,\n    int32_t* max_gap);\n\n\nint yr_re_ast_emit_code(\n    RE_AST* re_ast,\n    YR_ARENA* arena,\n    int backwards_code);\n\n\nRE_NODE* yr_re_node_create(\n    int type,\n    RE_NODE* left,\n    RE_NODE* right);\n\n\nvoid yr_re_node_destroy(\n    RE_NODE* node);\n\n\nint yr_re_exec(\n    uint8_t* re_code,\n    uint8_t* input,\n    size_t input_forwards_size,\n    size_t input_backwards_size,\n    int flags,\n    RE_MATCH_CALLBACK_FUNC callback,\n    void* callback_args);\n\n\nint yr_re_fast_exec(\n    uint8_t* re_code,\n    uint8_t* input,\n    size_t input_forwards_size,\n    size_t input_backwards_size,\n    int flags,\n    RE_MATCH_CALLBACK_FUNC callback,\n    void* callback_args);\n\n\nint yr_re_parse(\n    const char* re_string,\n    RE_AST** re_ast,\n    RE_ERROR* error);\n\n\nint yr_re_parse_hex(\n    const char* hex_string,\n    RE_AST** re_ast,\n    RE_ERROR* error);\n\n\nint yr_re_compile(\n    const char* re_string,\n    int flags,\n    YR_ARENA* code_arena,\n    RE** re,\n    RE_ERROR* error);\n\n\nint yr_re_match(\n    RE* re,\n    const char* target);\n\n\nint yr_re_initialize(void);\n\n\nint yr_re_finalize(void);\n\n\nint yr_re_finalize_thread(void);\n\n#endif\n", "/*\nCopyright (c) 2013. The YARA Authors. All Rights Reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\nlist of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors\nmay be used to endorse or promote products derived from this software without\nspecific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\n/*\n\nThis module implements a regular expressions engine based on Thompson's\nalgorithm as described by Russ Cox in http://swtch.com/~rsc/regexp/regexp2.html.\n\nWhat the article names a \"thread\" has been named a \"fiber\" in this code, in\norder to avoid confusion with operating system threads.\n\n*/\n\n#include <assert.h>\n#include <string.h>\n#include <limits.h>\n\n#include <yara/limits.h>\n#include <yara/globals.h>\n#include <yara/utils.h>\n#include <yara/mem.h>\n#include <yara/re.h>\n#include <yara/error.h>\n#include <yara/threading.h>\n#include <yara/re_lexer.h>\n#include <yara/hex_lexer.h>\n\n// Maximum allowed split ID, also limiting the number of split instructions\n// allowed in a regular expression. This number can't be increased\n// over 255 without changing RE_SPLIT_ID_TYPE.\n#define RE_MAX_SPLIT_ID     128\n\n// Maximum stack size for regexp evaluation\n#define RE_MAX_STACK      1024\n\n// Maximum code size for a compiled regexp\n#define RE_MAX_CODE_SIZE  32768\n\n// Maximum input size scanned by yr_re_exec\n#define RE_SCAN_LIMIT     4096\n\n// Maximum number of fibers\n#define RE_MAX_FIBERS     1024\n\n\n#define EMIT_BACKWARDS                  0x01\n#define EMIT_DONT_SET_FORWARDS_CODE     0x02\n#define EMIT_DONT_SET_BACKWARDS_CODE    0x04\n\n\ntypedef struct _RE_REPEAT_ARGS\n{\n  uint16_t  min;\n  uint16_t  max;\n  int32_t   offset;\n\n} RE_REPEAT_ARGS;\n\n\ntypedef struct _RE_REPEAT_ANY_ARGS\n{\n  uint16_t   min;\n  uint16_t   max;\n\n} RE_REPEAT_ANY_ARGS;\n\n\ntypedef struct _RE_EMIT_CONTEXT {\n\n  YR_ARENA*         arena;\n  RE_SPLIT_ID_TYPE  next_split_id;\n\n} RE_EMIT_CONTEXT;\n\n\ntypedef struct _RE_FIBER\n{\n  uint8_t* ip;    // instruction pointer\n  int32_t  sp;    // stack pointer\n  int32_t  rc;    // repeat counter\n\n  uint16_t stack[RE_MAX_STACK];\n\n  struct _RE_FIBER* prev;\n  struct _RE_FIBER* next;\n\n} RE_FIBER;\n\n\ntypedef struct _RE_FIBER_LIST\n{\n  RE_FIBER* head;\n  RE_FIBER* tail;\n\n} RE_FIBER_LIST;\n\n\ntypedef struct _RE_FIBER_POOL\n{\n  int fiber_count;\n  RE_FIBER_LIST fibers;\n\n} RE_FIBER_POOL;\n\n\ntypedef struct _RE_THREAD_STORAGE\n{\n  RE_FIBER_POOL fiber_pool;\n\n} RE_THREAD_STORAGE;\n\n\nYR_THREAD_STORAGE_KEY thread_storage_key = 0;\n\n\n#define CHAR_IN_CLASS(chr, cls)  \\\n    ((cls)[(chr) / 8] & 1 << ((chr) % 8))\n\n\nint _yr_re_is_word_char(\n    uint8_t* input,\n    int character_size)\n{\n  int result = ((isalnum(*input) || (*input) == '_'));\n\n  if (character_size == 2)\n    result = result && (*(input + 1) == 0);\n\n  return result;\n}\n\n\n\n//\n// yr_re_initialize\n//\n// Should be called by main thread before any other\n// function from this module.\n//\n\nint yr_re_initialize(void)\n{\n  return yr_thread_storage_create(&thread_storage_key);\n}\n\n//\n// yr_re_finalize\n//\n// Should be called by main thread after every other thread\n// stopped using functions from this module.\n//\n\nint yr_re_finalize(void)\n{\n  yr_thread_storage_destroy(&thread_storage_key);\n\n  thread_storage_key = 0;\n  return ERROR_SUCCESS;\n}\n\n//\n// yr_re_finalize_thread\n//\n// Should be called by every thread using this module\n// before exiting.\n//\n\nint yr_re_finalize_thread(void)\n{\n  RE_FIBER* fiber;\n  RE_FIBER* next_fiber;\n  RE_THREAD_STORAGE* storage;\n\n  if (thread_storage_key != 0)\n    storage = (RE_THREAD_STORAGE*) yr_thread_storage_get_value(\n        &thread_storage_key);\n  else\n    return ERROR_SUCCESS;\n\n  if (storage != NULL)\n  {\n    fiber = storage->fiber_pool.fibers.head;\n\n    while (fiber != NULL)\n    {\n      next_fiber = fiber->next;\n      yr_free(fiber);\n      fiber = next_fiber;\n    }\n\n    yr_free(storage);\n  }\n\n  return yr_thread_storage_set_value(&thread_storage_key, NULL);\n}\n\n\nRE_NODE* yr_re_node_create(\n    int type,\n    RE_NODE* left,\n    RE_NODE* right)\n{\n  RE_NODE* result = (RE_NODE*) yr_malloc(sizeof(RE_NODE));\n\n  if (result != NULL)\n  {\n    result->type = type;\n    result->left = left;\n    result->right = right;\n    result->greedy = TRUE;\n    result->forward_code = NULL;\n    result->backward_code = NULL;\n  }\n\n  return result;\n}\n\n\nvoid yr_re_node_destroy(\n    RE_NODE* node)\n{\n  if (node->left != NULL)\n    yr_re_node_destroy(node->left);\n\n  if (node->right != NULL)\n    yr_re_node_destroy(node->right);\n\n  if (node->type == RE_NODE_CLASS)\n    yr_free(node->class_vector);\n\n  yr_free(node);\n}\n\n\nint yr_re_ast_create(\n    RE_AST** re_ast)\n{\n  *re_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));\n\n  if (*re_ast == NULL)\n    return ERROR_INSUFFICIENT_MEMORY;\n\n  (*re_ast)->flags = 0;\n  (*re_ast)->root_node = NULL;\n\n  return ERROR_SUCCESS;\n}\n\n\nvoid yr_re_ast_destroy(\n    RE_AST* re_ast)\n{\n  if (re_ast->root_node != NULL)\n    yr_re_node_destroy(re_ast->root_node);\n\n  yr_free(re_ast);\n}\n\n\n//\n// yr_re_parse\n//\n// Parses a regexp but don't emit its code. A further call to\n// yr_re_emit_code is required to get the code.\n//\n\nint yr_re_parse(\n    const char* re_string,\n    RE_AST** re_ast,\n    RE_ERROR* error)\n{\n  return yr_parse_re_string(re_string, re_ast, error);\n}\n\n\n//\n// yr_re_parse_hex\n//\n// Parses a hex string but don't emit its code. A further call to\n// yr_re_emit_code is required to get the code.\n//\n\nint yr_re_parse_hex(\n    const char* hex_string,\n    RE_AST** re_ast,\n    RE_ERROR* error)\n{\n  return yr_parse_hex_string(hex_string, re_ast, error);\n}\n\n\n//\n// yr_re_compile\n//\n// Parses the regexp and emit its code to the provided code_arena.\n//\n\nint yr_re_compile(\n    const char* re_string,\n    int flags,\n    YR_ARENA* code_arena,\n    RE** re,\n    RE_ERROR* error)\n{\n  RE_AST* re_ast;\n  RE _re;\n\n  FAIL_ON_ERROR(yr_arena_reserve_memory(\n      code_arena, sizeof(int64_t) + RE_MAX_CODE_SIZE));\n\n  FAIL_ON_ERROR(yr_re_parse(re_string, &re_ast, error));\n\n  _re.flags = flags;\n\n  FAIL_ON_ERROR_WITH_CLEANUP(\n      yr_arena_write_data(\n          code_arena,\n          &_re,\n          sizeof(_re),\n          (void**) re),\n      yr_re_ast_destroy(re_ast));\n\n  FAIL_ON_ERROR_WITH_CLEANUP(\n      yr_re_ast_emit_code(re_ast, code_arena, FALSE),\n      yr_re_ast_destroy(re_ast));\n\n  yr_re_ast_destroy(re_ast);\n\n  return ERROR_SUCCESS;\n}\n\n\n//\n// yr_re_match\n//\n// Verifies if the target string matches the pattern\n//\n// Args:\n//    RE* re          -  A pointer to a compiled regexp\n//    char* target    -  Target string\n//\n// Returns:\n//    See return codes for yr_re_exec\n\n\nint yr_re_match(\n    RE* re,\n    const char* target)\n{\n  return yr_re_exec(\n      re->code,\n      (uint8_t*) target,\n      strlen(target),\n      0,\n      re->flags | RE_FLAGS_SCAN,\n      NULL,\n      NULL);\n}\n\n\n//\n// yr_re_ast_extract_literal\n//\n// Verifies if the provided regular expression is just a literal string\n// like \"abc\", \"12345\", without any wildcard, operator, etc. In that case\n// returns the string as a SIZED_STRING, or returns NULL if otherwise.\n//\n// The caller is responsible for deallocating the returned SIZED_STRING by\n// calling yr_free.\n//\n\nSIZED_STRING* yr_re_ast_extract_literal(\n    RE_AST* re_ast)\n{\n  SIZED_STRING* string;\n  RE_NODE* node = re_ast->root_node;\n\n  int i, length = 0;\n  char tmp;\n\n  while (node != NULL)\n  {\n    length++;\n\n    if (node->type == RE_NODE_LITERAL)\n      break;\n\n    if (node->type != RE_NODE_CONCAT)\n      return NULL;\n\n    if (node->right == NULL ||\n        node->right->type != RE_NODE_LITERAL)\n      return NULL;\n\n    node = node->left;\n  }\n\n  string = (SIZED_STRING*) yr_malloc(sizeof(SIZED_STRING) + length);\n\n  if (string == NULL)\n    return NULL;\n\n  string->length = 0;\n\n  node = re_ast->root_node;\n\n  while (node->type == RE_NODE_CONCAT)\n  {\n    string->c_string[string->length++] = node->right->value;\n    node = node->left;\n  }\n\n  string->c_string[string->length++] = node->value;\n\n  // The string ends up reversed. Reverse it back to its original value.\n\n  for (i = 0; i < length / 2; i++)\n  {\n    tmp = string->c_string[i];\n    string->c_string[i] = string->c_string[length - i - 1];\n    string->c_string[length - i - 1] = tmp;\n  }\n\n  return string;\n}\n\n\nint _yr_re_node_contains_dot_star(\n    RE_NODE* re_node)\n{\n  if (re_node->type == RE_NODE_STAR && re_node->left->type == RE_NODE_ANY)\n    return TRUE;\n\n  if (re_node->left != NULL && _yr_re_node_contains_dot_star(re_node->left))\n    return TRUE;\n\n  if (re_node->right != NULL && _yr_re_node_contains_dot_star(re_node->right))\n    return TRUE;\n\n  return FALSE;\n}\n\n\nint yr_re_ast_contains_dot_star(\n    RE_AST* re_ast)\n{\n  return _yr_re_node_contains_dot_star(re_ast->root_node);\n}\n\n\n//\n// yr_re_ast_split_at_chaining_point\n//\n// In some cases splitting a regular expression in two is more efficient that\n// having a single regular expression. This happens when the regular expression\n// contains a large repetition of any character, for example: /foo.{0,1000}bar/\n// In this case the regexp is split in /foo/ and /bar/ where /bar/ is \"chained\"\n// to /foo/. This means that /foo/ and /bar/ are handled as individual regexps\n// and when both matches YARA verifies if the distance between the matches\n// complies with the {0,1000} restriction.\n\n// This function traverses the regexp's tree looking for nodes where the regxp\n// should be split. It expects a left-unbalanced tree where the right child of\n// a RE_NODE_CONCAT can't be another RE_NODE_CONCAT. A RE_NODE_CONCAT must be\n// always the left child of its parent if the parent is also a RE_NODE_CONCAT.\n//\n\nint yr_re_ast_split_at_chaining_point(\n    RE_AST* re_ast,\n    RE_AST** result_re_ast,\n    RE_AST** remainder_re_ast,\n    int32_t* min_gap,\n    int32_t* max_gap)\n{\n  RE_NODE* node = re_ast->root_node;\n  RE_NODE* child = re_ast->root_node->left;\n  RE_NODE* parent = NULL;\n\n  int result;\n\n  *result_re_ast = re_ast;\n  *remainder_re_ast = NULL;\n  *min_gap = 0;\n  *max_gap = 0;\n\n  while (child != NULL && child->type == RE_NODE_CONCAT)\n  {\n    if (child->right != NULL &&\n        child->right->type == RE_NODE_RANGE_ANY &&\n        child->right->greedy == FALSE &&\n        (child->right->start > STRING_CHAINING_THRESHOLD ||\n         child->right->end > STRING_CHAINING_THRESHOLD))\n    {\n      result = yr_re_ast_create(remainder_re_ast);\n\n      if (result != ERROR_SUCCESS)\n        return result;\n\n      (*remainder_re_ast)->root_node = child->left;\n      (*remainder_re_ast)->flags = re_ast->flags;\n\n      child->left = NULL;\n\n      if (parent != NULL)\n        parent->left = node->right;\n      else\n        (*result_re_ast)->root_node = node->right;\n\n      node->right = NULL;\n\n      *min_gap = child->right->start;\n      *max_gap = child->right->end;\n\n      yr_re_node_destroy(node);\n\n      return ERROR_SUCCESS;\n    }\n\n    parent = node;\n    node = child;\n    child = child->left;\n  }\n\n  return ERROR_SUCCESS;\n}\n\n\nint _yr_emit_inst(\n    RE_EMIT_CONTEXT* emit_context,\n    uint8_t opcode,\n    uint8_t** instruction_addr,\n    int* code_size)\n{\n  FAIL_ON_ERROR(yr_arena_write_data(\n      emit_context->arena,\n      &opcode,\n      sizeof(uint8_t),\n      (void**) instruction_addr));\n\n  *code_size = sizeof(uint8_t);\n\n  return ERROR_SUCCESS;\n}\n\n\nint _yr_emit_inst_arg_uint8(\n    RE_EMIT_CONTEXT* emit_context,\n    uint8_t opcode,\n    uint8_t argument,\n    uint8_t** instruction_addr,\n    uint8_t** argument_addr,\n    int* code_size)\n{\n  FAIL_ON_ERROR(yr_arena_write_data(\n      emit_context->arena,\n      &opcode,\n      sizeof(uint8_t),\n      (void**) instruction_addr));\n\n  FAIL_ON_ERROR(yr_arena_write_data(\n      emit_context->arena,\n      &argument,\n      sizeof(uint8_t),\n      (void**) argument_addr));\n\n  *code_size = 2 * sizeof(uint8_t);\n\n  return ERROR_SUCCESS;\n}\n\n\nint _yr_emit_inst_arg_uint16(\n    RE_EMIT_CONTEXT* emit_context,\n    uint8_t opcode,\n    uint16_t argument,\n    uint8_t** instruction_addr,\n    uint16_t** argument_addr,\n    int* code_size)\n{\n  FAIL_ON_ERROR(yr_arena_write_data(\n      emit_context->arena,\n      &opcode,\n      sizeof(uint8_t),\n      (void**) instruction_addr));\n\n  FAIL_ON_ERROR(yr_arena_write_data(\n      emit_context->arena,\n      &argument,\n      sizeof(uint16_t),\n      (void**) argument_addr));\n\n  *code_size = sizeof(uint8_t) + sizeof(uint16_t);\n\n  return ERROR_SUCCESS;\n}\n\n\nint _yr_emit_inst_arg_uint32(\n    RE_EMIT_CONTEXT* emit_context,\n    uint8_t opcode,\n    uint32_t argument,\n    uint8_t** instruction_addr,\n    uint32_t** argument_addr,\n    int* code_size)\n{\n  FAIL_ON_ERROR(yr_arena_write_data(\n      emit_context->arena,\n      &opcode,\n      sizeof(uint8_t),\n      (void**) instruction_addr));\n\n  FAIL_ON_ERROR(yr_arena_write_data(\n      emit_context->arena,\n      &argument,\n      sizeof(uint32_t),\n      (void**) argument_addr));\n\n  *code_size = sizeof(uint8_t) + sizeof(uint32_t);\n\n  return ERROR_SUCCESS;\n}\n\n\nint _yr_emit_inst_arg_int16(\n    RE_EMIT_CONTEXT* emit_context,\n    uint8_t opcode,\n    int16_t argument,\n    uint8_t** instruction_addr,\n    int16_t** argument_addr,\n    int* code_size)\n{\n  FAIL_ON_ERROR(yr_arena_write_data(\n      emit_context->arena,\n      &opcode,\n      sizeof(uint8_t),\n      (void**) instruction_addr));\n\n  FAIL_ON_ERROR(yr_arena_write_data(\n      emit_context->arena,\n      &argument,\n      sizeof(int16_t),\n      (void**) argument_addr));\n\n  *code_size = sizeof(uint8_t) + sizeof(int16_t);\n\n  return ERROR_SUCCESS;\n}\n\n\nint _yr_emit_inst_arg_struct(\n    RE_EMIT_CONTEXT* emit_context,\n    uint8_t opcode,\n    void* structure,\n    size_t structure_size,\n    uint8_t** instruction_addr,\n    void** argument_addr,\n    int* code_size)\n{\n  FAIL_ON_ERROR(yr_arena_write_data(\n      emit_context->arena,\n      &opcode,\n      sizeof(uint8_t),\n      (void**) instruction_addr));\n\n  FAIL_ON_ERROR(yr_arena_write_data(\n      emit_context->arena,\n      structure,\n      structure_size,\n      (void**) argument_addr));\n\n  *code_size = sizeof(uint8_t) + structure_size;\n\n  return ERROR_SUCCESS;\n}\n\n\nint _yr_emit_split(\n    RE_EMIT_CONTEXT* emit_context,\n    uint8_t opcode,\n    int16_t argument,\n    uint8_t** instruction_addr,\n    int16_t** argument_addr,\n    int* code_size)\n{\n  assert(opcode == RE_OPCODE_SPLIT_A || opcode == RE_OPCODE_SPLIT_B);\n\n  if (emit_context->next_split_id == RE_MAX_SPLIT_ID)\n    return ERROR_REGULAR_EXPRESSION_TOO_COMPLEX;\n\n  FAIL_ON_ERROR(yr_arena_write_data(\n      emit_context->arena,\n      &opcode,\n      sizeof(uint8_t),\n      (void**) instruction_addr));\n\n  FAIL_ON_ERROR(yr_arena_write_data(\n      emit_context->arena,\n      &emit_context->next_split_id,\n      sizeof(RE_SPLIT_ID_TYPE),\n      NULL));\n\n  emit_context->next_split_id++;\n\n  FAIL_ON_ERROR(yr_arena_write_data(\n      emit_context->arena,\n      &argument,\n      sizeof(int16_t),\n      (void**) argument_addr));\n\n  *code_size = sizeof(uint8_t) + sizeof(RE_SPLIT_ID_TYPE) + sizeof(int16_t);\n\n  return ERROR_SUCCESS;\n}\n\n\nint _yr_re_emit(\n    RE_EMIT_CONTEXT* emit_context,\n    RE_NODE* re_node,\n    int flags,\n    uint8_t** code_addr,\n    int* code_size)\n{\n  int branch_size;\n  int split_size;\n  int inst_size;\n  int jmp_size;\n\n  int emit_split;\n  int emit_repeat;\n  int emit_prolog;\n  int emit_epilog;\n\n  RE_REPEAT_ARGS repeat_args;\n  RE_REPEAT_ARGS* repeat_start_args_addr;\n  RE_REPEAT_ANY_ARGS repeat_any_args;\n\n  RE_NODE* left;\n  RE_NODE* right;\n\n  int16_t* split_offset_addr = NULL;\n  int16_t* jmp_offset_addr = NULL;\n  uint8_t* instruction_addr = NULL;\n\n  *code_size = 0;\n\n  switch(re_node->type)\n  {\n  case RE_NODE_LITERAL:\n\n    FAIL_ON_ERROR(_yr_emit_inst_arg_uint8(\n        emit_context,\n        RE_OPCODE_LITERAL,\n        re_node->value,\n        &instruction_addr,\n        NULL,\n        code_size));\n    break;\n\n  case RE_NODE_MASKED_LITERAL:\n\n    FAIL_ON_ERROR(_yr_emit_inst_arg_uint16(\n        emit_context,\n        RE_OPCODE_MASKED_LITERAL,\n        re_node->mask << 8 | re_node->value,\n        &instruction_addr,\n        NULL,\n        code_size));\n    break;\n\n  case RE_NODE_WORD_CHAR:\n\n    FAIL_ON_ERROR(_yr_emit_inst(\n        emit_context,\n        RE_OPCODE_WORD_CHAR,\n        &instruction_addr,\n        code_size));\n    break;\n\n  case RE_NODE_NON_WORD_CHAR:\n\n    FAIL_ON_ERROR(_yr_emit_inst(\n        emit_context,\n        RE_OPCODE_NON_WORD_CHAR,\n        &instruction_addr,\n        code_size));\n    break;\n\n  case RE_NODE_WORD_BOUNDARY:\n\n    FAIL_ON_ERROR(_yr_emit_inst(\n        emit_context,\n        RE_OPCODE_WORD_BOUNDARY,\n        &instruction_addr,\n        code_size));\n    break;\n\n  case RE_NODE_NON_WORD_BOUNDARY:\n\n    FAIL_ON_ERROR(_yr_emit_inst(\n        emit_context,\n        RE_OPCODE_NON_WORD_BOUNDARY,\n        &instruction_addr,\n        code_size));\n    break;\n\n  case RE_NODE_SPACE:\n\n    FAIL_ON_ERROR(_yr_emit_inst(\n        emit_context,\n        RE_OPCODE_SPACE,\n        &instruction_addr,\n        code_size));\n    break;\n\n  case RE_NODE_NON_SPACE:\n\n    FAIL_ON_ERROR(_yr_emit_inst(\n        emit_context,\n        RE_OPCODE_NON_SPACE,\n        &instruction_addr,\n        code_size));\n    break;\n\n  case RE_NODE_DIGIT:\n\n    FAIL_ON_ERROR(_yr_emit_inst(\n        emit_context,\n        RE_OPCODE_DIGIT,\n        &instruction_addr,\n        code_size));\n    break;\n\n  case RE_NODE_NON_DIGIT:\n\n    FAIL_ON_ERROR(_yr_emit_inst(\n        emit_context,\n        RE_OPCODE_NON_DIGIT,\n        &instruction_addr,\n        code_size));\n    break;\n\n  case RE_NODE_ANY:\n\n    FAIL_ON_ERROR(_yr_emit_inst(\n        emit_context,\n        RE_OPCODE_ANY,\n        &instruction_addr,\n        code_size));\n    break;\n\n  case RE_NODE_CLASS:\n\n    FAIL_ON_ERROR(_yr_emit_inst(\n        emit_context,\n        RE_OPCODE_CLASS,\n        &instruction_addr,\n        code_size));\n\n    FAIL_ON_ERROR(yr_arena_write_data(\n        emit_context->arena,\n        re_node->class_vector,\n        32,\n        NULL));\n\n    *code_size += 32;\n    break;\n\n  case RE_NODE_ANCHOR_START:\n\n    FAIL_ON_ERROR(_yr_emit_inst(\n        emit_context,\n        RE_OPCODE_MATCH_AT_START,\n        &instruction_addr,\n        code_size));\n    break;\n\n  case RE_NODE_ANCHOR_END:\n\n    FAIL_ON_ERROR(_yr_emit_inst(\n        emit_context,\n        RE_OPCODE_MATCH_AT_END,\n        &instruction_addr,\n        code_size));\n    break;\n\n  case RE_NODE_CONCAT:\n\n    if (flags & EMIT_BACKWARDS)\n    {\n      left = re_node->right;\n      right = re_node->left;\n    }\n    else\n    {\n      left = re_node->left;\n      right = re_node->right;\n    }\n\n    FAIL_ON_ERROR(_yr_re_emit(\n        emit_context,\n        left,\n        flags,\n        &instruction_addr,\n        &branch_size));\n\n    *code_size += branch_size;\n\n    FAIL_ON_ERROR(_yr_re_emit(\n        emit_context,\n        right,\n        flags,\n        NULL,\n        &branch_size));\n\n    *code_size += branch_size;\n\n    break;\n\n  case RE_NODE_PLUS:\n\n    // Code for e+ looks like:\n    //\n    //          L1: code for e\n    //              split L1, L2\n    //          L2:\n\n    FAIL_ON_ERROR(_yr_re_emit(\n        emit_context,\n        re_node->left,\n        flags,\n        &instruction_addr,\n        &branch_size));\n\n    *code_size += branch_size;\n\n    FAIL_ON_ERROR(_yr_emit_split(\n        emit_context,\n        re_node->greedy ? RE_OPCODE_SPLIT_B : RE_OPCODE_SPLIT_A,\n        -branch_size,\n        NULL,\n        &split_offset_addr,\n        &split_size));\n\n    *code_size += split_size;\n    break;\n\n  case RE_NODE_STAR:\n\n    // Code for e* looks like:\n    //\n    //          L1: split L1, L2\n    //              code for e\n    //              jmp L1\n    //          L2:\n\n    FAIL_ON_ERROR(_yr_emit_split(\n        emit_context,\n        re_node->greedy ? RE_OPCODE_SPLIT_A : RE_OPCODE_SPLIT_B,\n        0,\n        &instruction_addr,\n        &split_offset_addr,\n        &split_size));\n\n    *code_size += split_size;\n\n    FAIL_ON_ERROR(_yr_re_emit(\n        emit_context,\n        re_node->left,\n        flags,\n        NULL,\n        &branch_size));\n\n    *code_size += branch_size;\n\n    // Emit jump with offset set to 0.\n\n    FAIL_ON_ERROR(_yr_emit_inst_arg_int16(\n        emit_context,\n        RE_OPCODE_JUMP,\n        -(branch_size + split_size),\n        NULL,\n        &jmp_offset_addr,\n        &jmp_size));\n\n    *code_size += jmp_size;\n\n    // Update split offset.\n    *split_offset_addr = split_size + branch_size + jmp_size;\n    break;\n\n  case RE_NODE_ALT:\n\n    // Code for e1|e2 looks like:\n    //\n    //              split L1, L2\n    //          L1: code for e1\n    //              jmp L3\n    //          L2: code for e2\n    //          L3:\n\n    // Emit a split instruction with offset set to 0 temporarily. Offset\n    // will be updated after we know the size of the code generated for\n    // the left node (e1).\n\n    FAIL_ON_ERROR(_yr_emit_split(\n        emit_context,\n        RE_OPCODE_SPLIT_A,\n        0,\n        &instruction_addr,\n        &split_offset_addr,\n        &split_size));\n\n    *code_size += split_size;\n\n    FAIL_ON_ERROR(_yr_re_emit(\n        emit_context,\n        re_node->left,\n        flags,\n        NULL,\n        &branch_size));\n\n    *code_size += branch_size;\n\n    // Emit jump with offset set to 0.\n\n    FAIL_ON_ERROR(_yr_emit_inst_arg_int16(\n        emit_context,\n        RE_OPCODE_JUMP,\n        0,\n        NULL,\n        &jmp_offset_addr,\n        &jmp_size));\n\n    *code_size += jmp_size;\n\n    // Update split offset.\n    *split_offset_addr = split_size + branch_size + jmp_size;\n\n    FAIL_ON_ERROR(_yr_re_emit(\n        emit_context,\n        re_node->right,\n        flags,\n        NULL,\n        &branch_size));\n\n    *code_size += branch_size;\n\n    // Update offset for jmp instruction.\n    *jmp_offset_addr = branch_size + jmp_size;\n    break;\n\n  case RE_NODE_RANGE_ANY:\n\n    repeat_any_args.min = re_node->start;\n    repeat_any_args.max = re_node->end;\n\n    FAIL_ON_ERROR(_yr_emit_inst_arg_struct(\n        emit_context,\n        re_node->greedy ?\n            RE_OPCODE_REPEAT_ANY_GREEDY :\n            RE_OPCODE_REPEAT_ANY_UNGREEDY,\n        &repeat_any_args,\n        sizeof(repeat_any_args),\n        &instruction_addr,\n        NULL,\n        &inst_size));\n\n    *code_size += inst_size;\n    break;\n\n  case RE_NODE_RANGE:\n\n    // Code for e{n,m} looks like:\n    //\n    //            code for e              ---   prolog\n    //            repeat_start n, m, L1   --+\n    //        L0: code for e                |   repeat\n    //            repeat_end n, m, L0     --+\n    //        L1: split L2, L3            ---   split\n    //        L2: code for e              ---   epilog\n    //        L3:\n    //\n    // Not all sections (prolog, repeat, split and epilog) are generated in all\n    // cases, it depends on the values of n and m. The following table shows\n    // which sections are generated for the first few values of n and m.\n    //\n    //        n,m   prolog  repeat      split  epilog\n    //                      (min,max)\n    //        ---------------------------------------\n    //        0,0     -       -           -      -\n    //        0,1     -       -           X      X\n    //        0,2     -       0,1         X      X\n    //        0,3     -       0,2         X      X\n    //        0,M     -       0,M-1       X      X\n    //\n    //        1,1     X       -           -      -\n    //        1,2     X       -           X      X\n    //        1,3     X       0,1         X      X\n    //        1,4     X       1,2         X      X\n    //        1,M     X       1,M-2       X      X\n    //\n    //        2,2     X       -           -      X\n    //        2,3     X       1,1         X      X\n    //        2,4     X       1,2         X      X\n    //        2,M     X       1,M-2       X      X\n    //\n    //        3,3     X       1,1         -      X\n    //        3,4     X       2,2         X      X\n    //        3,M     X       2,M-1       X      X\n    //\n    // The code can't consists simply in the repeat section, the prolog and\n    // epilog are required because we can't have atoms pointing to code inside\n    // the repeat loop. Atoms' forwards_code will point to code in the prolog\n    // and backwards_code will point to code in the epilog (or in prolog if\n    // epilog wasn't generated, like in n=1,m=1)\n\n    emit_prolog = re_node->start > 0;\n    emit_repeat = re_node->end > re_node->start + 1 || re_node->end > 2;\n    emit_split = re_node->end > re_node->start;\n    emit_epilog = re_node->end > re_node->start || re_node->end > 1;\n\n    if (emit_prolog)\n    {\n      FAIL_ON_ERROR(_yr_re_emit(\n          emit_context,\n          re_node->left,\n          flags,\n          &instruction_addr,\n          &branch_size));\n\n       *code_size += branch_size;\n    }\n\n    if (emit_repeat)\n    {\n      repeat_args.min = re_node->start;\n      repeat_args.max = re_node->end;\n\n      if (emit_prolog)\n      {\n        repeat_args.max--;\n        repeat_args.min--;\n      }\n\n      if (emit_split)\n        repeat_args.max--;\n      else\n        repeat_args.min--;\n\n      repeat_args.offset = 0;\n\n      FAIL_ON_ERROR(_yr_emit_inst_arg_struct(\n          emit_context,\n          re_node->greedy ?\n              RE_OPCODE_REPEAT_START_GREEDY :\n              RE_OPCODE_REPEAT_START_UNGREEDY,\n          &repeat_args,\n          sizeof(repeat_args),\n          emit_prolog ? NULL : &instruction_addr,\n          (void**) &repeat_start_args_addr,\n          &inst_size));\n\n      *code_size += inst_size;\n\n      FAIL_ON_ERROR(_yr_re_emit(\n          emit_context,\n          re_node->left,\n          flags | EMIT_DONT_SET_FORWARDS_CODE | EMIT_DONT_SET_BACKWARDS_CODE,\n          NULL,\n          &branch_size));\n\n      *code_size += branch_size;\n\n      repeat_start_args_addr->offset = 2 * inst_size + branch_size;\n      repeat_args.offset = -branch_size;\n\n      FAIL_ON_ERROR(_yr_emit_inst_arg_struct(\n          emit_context,\n          re_node->greedy ?\n              RE_OPCODE_REPEAT_END_GREEDY :\n              RE_OPCODE_REPEAT_END_UNGREEDY,\n          &repeat_args,\n          sizeof(repeat_args),\n          NULL,\n          NULL,\n          &inst_size));\n\n      *code_size += inst_size;\n    }\n\n    if (emit_split)\n    {\n      FAIL_ON_ERROR(_yr_emit_split(\n          emit_context,\n          re_node->greedy ?\n              RE_OPCODE_SPLIT_A :\n              RE_OPCODE_SPLIT_B,\n          0,\n          NULL,\n          &split_offset_addr,\n          &split_size));\n\n      *code_size += split_size;\n    }\n\n    if (emit_epilog)\n    {\n      FAIL_ON_ERROR(_yr_re_emit(\n          emit_context,\n          re_node->left,\n          emit_prolog ? flags | EMIT_DONT_SET_FORWARDS_CODE : flags,\n          emit_prolog || emit_repeat ? NULL : &instruction_addr,\n          &branch_size));\n\n      *code_size += branch_size;\n    }\n\n    if (emit_split)\n      *split_offset_addr = split_size + branch_size;\n\n    break;\n  }\n\n  if (flags & EMIT_BACKWARDS)\n  {\n    if (!(flags & EMIT_DONT_SET_BACKWARDS_CODE))\n      re_node->backward_code = instruction_addr + *code_size;\n  }\n  else\n  {\n    if (!(flags & EMIT_DONT_SET_FORWARDS_CODE))\n      re_node->forward_code = instruction_addr;\n  }\n\n  if (code_addr != NULL)\n    *code_addr = instruction_addr;\n\n  return ERROR_SUCCESS;\n}\n\n\nint yr_re_ast_emit_code(\n    RE_AST* re_ast,\n    YR_ARENA* arena,\n    int backwards_code)\n{\n  RE_EMIT_CONTEXT emit_context;\n\n  int code_size;\n  int total_size;\n\n  // Ensure that we have enough contiguous memory space in the arena to\n  // contain the regular expression code. The code can't span over multiple\n  // non-contiguous pages.\n\n  FAIL_ON_ERROR(yr_arena_reserve_memory(arena, RE_MAX_CODE_SIZE));\n\n  // Emit code for matching the regular expressions forwards.\n\n  total_size = 0;\n  emit_context.arena = arena;\n  emit_context.next_split_id = 0;\n\n  FAIL_ON_ERROR(_yr_re_emit(\n      &emit_context,\n      re_ast->root_node,\n      backwards_code ? EMIT_BACKWARDS : 0,\n      NULL,\n      &code_size));\n\n  total_size += code_size;\n\n  FAIL_ON_ERROR(_yr_emit_inst(\n      &emit_context,\n      RE_OPCODE_MATCH,\n      NULL,\n      &code_size));\n\n  total_size += code_size;\n\n  if (total_size > RE_MAX_CODE_SIZE)\n    return ERROR_REGULAR_EXPRESSION_TOO_LARGE;\n\n  return ERROR_SUCCESS;\n}\n\n\nint _yr_re_alloc_storage(\n    RE_THREAD_STORAGE** storage)\n{\n  *storage = (RE_THREAD_STORAGE*) yr_thread_storage_get_value(\n      &thread_storage_key);\n\n  if (*storage == NULL)\n  {\n    *storage = (RE_THREAD_STORAGE*) yr_malloc(sizeof(RE_THREAD_STORAGE));\n\n    if (*storage == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n\n    (*storage)->fiber_pool.fiber_count = 0;\n    (*storage)->fiber_pool.fibers.head = NULL;\n    (*storage)->fiber_pool.fibers.tail = NULL;\n\n    FAIL_ON_ERROR(\n        yr_thread_storage_set_value(&thread_storage_key, *storage));\n  }\n\n  return ERROR_SUCCESS;\n}\n\n\nint _yr_re_fiber_create(\n    RE_FIBER_POOL* fiber_pool,\n    RE_FIBER** new_fiber)\n{\n  RE_FIBER* fiber;\n\n  if (fiber_pool->fibers.head != NULL)\n  {\n    fiber = fiber_pool->fibers.head;\n    fiber_pool->fibers.head = fiber->next;\n\n    if (fiber_pool->fibers.tail == fiber)\n      fiber_pool->fibers.tail = NULL;\n  }\n  else\n  {\n    if (fiber_pool->fiber_count == RE_MAX_FIBERS)\n      return ERROR_TOO_MANY_RE_FIBERS;\n\n    fiber = (RE_FIBER*) yr_malloc(sizeof(RE_FIBER));\n\n    if (fiber == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n\n    fiber_pool->fiber_count++;\n  }\n\n  fiber->ip = NULL;\n  fiber->sp = -1;\n  fiber->rc = -1;\n  fiber->next = NULL;\n  fiber->prev = NULL;\n\n  *new_fiber = fiber;\n\n  return ERROR_SUCCESS;\n}\n\n\n//\n// _yr_re_fiber_append\n//\n// Appends 'fiber' to 'fiber_list'\n//\n\nvoid _yr_re_fiber_append(\n    RE_FIBER_LIST* fiber_list,\n    RE_FIBER* fiber)\n{\n  assert(fiber->prev == NULL);\n  assert(fiber->next == NULL);\n\n  fiber->prev = fiber_list->tail;\n\n  if (fiber_list->tail != NULL)\n    fiber_list->tail->next = fiber;\n\n  fiber_list->tail = fiber;\n\n  if (fiber_list->head == NULL)\n    fiber_list->head = fiber;\n\n  assert(fiber_list->tail->next == NULL);\n  assert(fiber_list->head->prev == NULL);\n}\n\n\n//\n// _yr_re_fiber_exists\n//\n// Verifies if a fiber with the same properties (ip, rc, sp, and stack values)\n// than 'target_fiber' exists in 'fiber_list'. The list is iterated from\n// the start until 'last_fiber' (inclusive). Fibers past 'last_fiber' are not\n// taken into account.\n//\n\nint _yr_re_fiber_exists(\n    RE_FIBER_LIST* fiber_list,\n    RE_FIBER* target_fiber,\n    RE_FIBER* last_fiber)\n{\n  RE_FIBER* fiber = fiber_list->head;\n\n  int equal_stacks;\n  int i;\n\n\n  if (last_fiber == NULL)\n    return FALSE;\n\n  while (fiber != last_fiber->next)\n  {\n    if (fiber->ip == target_fiber->ip &&\n        fiber->sp == target_fiber->sp &&\n        fiber->rc == target_fiber->rc)\n    {\n      equal_stacks = TRUE;\n\n      for (i = 0; i <= fiber->sp; i++)\n      {\n        if (fiber->stack[i] != target_fiber->stack[i])\n        {\n          equal_stacks = FALSE;\n          break;\n        }\n      }\n\n      if (equal_stacks)\n        return TRUE;\n    }\n\n    fiber = fiber->next;\n  }\n\n  return FALSE;\n}\n\n\n//\n// _yr_re_fiber_split\n//\n// Clones a fiber in fiber_list and inserts the cloned fiber just after.\n// the original one. If fiber_list is:\n//\n//   f1 -> f2 -> f3 -> f4\n//\n// Splitting f2 will result in:\n//\n//   f1 -> f2 -> cloned f2 -> f3 -> f4\n//\n\nint _yr_re_fiber_split(\n    RE_FIBER_LIST* fiber_list,\n    RE_FIBER_POOL* fiber_pool,\n    RE_FIBER* fiber,\n    RE_FIBER** new_fiber)\n{\n  int32_t i;\n\n  FAIL_ON_ERROR(_yr_re_fiber_create(fiber_pool, new_fiber));\n\n  (*new_fiber)->sp = fiber->sp;\n  (*new_fiber)->ip = fiber->ip;\n  (*new_fiber)->rc = fiber->rc;\n\n  for (i = 0; i <= fiber->sp; i++)\n    (*new_fiber)->stack[i] = fiber->stack[i];\n\n  (*new_fiber)->next = fiber->next;\n  (*new_fiber)->prev = fiber;\n\n  if (fiber->next != NULL)\n    fiber->next->prev = *new_fiber;\n\n  fiber->next = *new_fiber;\n\n  if (fiber_list->tail == fiber)\n    fiber_list->tail = *new_fiber;\n\n  assert(fiber_list->tail->next == NULL);\n  assert(fiber_list->head->prev == NULL);\n\n  return ERROR_SUCCESS;\n}\n\n\n//\n// _yr_re_fiber_kill\n//\n// Kills a given fiber by removing it from the fiber list and putting it\n// in the fiber pool.\n//\n\nRE_FIBER* _yr_re_fiber_kill(\n    RE_FIBER_LIST* fiber_list,\n    RE_FIBER_POOL* fiber_pool,\n    RE_FIBER* fiber)\n{\n  RE_FIBER* next_fiber = fiber->next;\n\n  if (fiber->prev != NULL)\n    fiber->prev->next = next_fiber;\n\n  if (next_fiber != NULL)\n    next_fiber->prev = fiber->prev;\n\n  if (fiber_pool->fibers.tail != NULL)\n    fiber_pool->fibers.tail->next = fiber;\n\n  if (fiber_list->tail == fiber)\n    fiber_list->tail = fiber->prev;\n\n  if (fiber_list->head == fiber)\n    fiber_list->head = next_fiber;\n\n  fiber->next = NULL;\n  fiber->prev = fiber_pool->fibers.tail;\n  fiber_pool->fibers.tail = fiber;\n\n  if (fiber_pool->fibers.head == NULL)\n    fiber_pool->fibers.head = fiber;\n\n  return next_fiber;\n}\n\n\n//\n// _yr_re_fiber_kill_tail\n//\n// Kills all fibers from the given one up to the end of the fiber list.\n//\n\nvoid _yr_re_fiber_kill_tail(\n  RE_FIBER_LIST* fiber_list,\n  RE_FIBER_POOL* fiber_pool,\n  RE_FIBER* fiber)\n{\n  RE_FIBER* prev_fiber = fiber->prev;\n\n  if (prev_fiber != NULL)\n    prev_fiber->next = NULL;\n\n  fiber->prev = fiber_pool->fibers.tail;\n\n  if (fiber_pool->fibers.tail != NULL)\n    fiber_pool->fibers.tail->next = fiber;\n\n  fiber_pool->fibers.tail = fiber_list->tail;\n  fiber_list->tail = prev_fiber;\n\n  if (fiber_list->head == fiber)\n    fiber_list->head = NULL;\n\n  if (fiber_pool->fibers.head == NULL)\n    fiber_pool->fibers.head = fiber;\n}\n\n\n//\n// _yr_re_fiber_kill_tail\n//\n// Kills all fibers in the fiber list.\n//\n\nvoid _yr_re_fiber_kill_all(\n    RE_FIBER_LIST* fiber_list,\n    RE_FIBER_POOL* fiber_pool)\n{\n  if (fiber_list->head != NULL)\n    _yr_re_fiber_kill_tail(fiber_list, fiber_pool, fiber_list->head);\n}\n\n\n//\n// _yr_re_fiber_sync\n//\n// Executes a fiber until reaching an \"matching\" instruction. A \"matching\"\n// instruction is one that actually reads a byte from the input and performs\n// some matching. If the fiber reaches a split instruction, the new fiber is\n// also synced.\n//\n\nint _yr_re_fiber_sync(\n    RE_FIBER_LIST* fiber_list,\n    RE_FIBER_POOL* fiber_pool,\n    RE_FIBER* fiber_to_sync)\n{\n  // A array for keeping track of which split instructions has been already\n  // executed. Each split instruction within a regexp has an associated ID\n  // between 0 and RE_MAX_SPLIT_ID. Keeping track of executed splits is\n  // required to avoid infinite loops in regexps like (a*)* or (a|)*\n\n  RE_SPLIT_ID_TYPE splits_executed[RE_MAX_SPLIT_ID];\n  RE_SPLIT_ID_TYPE splits_executed_count = 0;\n  RE_SPLIT_ID_TYPE split_id, splits_executed_idx;\n\n  int split_already_executed;\n\n  RE_REPEAT_ARGS* repeat_args;\n  RE_REPEAT_ANY_ARGS* repeat_any_args;\n\n  RE_FIBER* fiber;\n  RE_FIBER* last;\n  RE_FIBER* prev;\n  RE_FIBER* next;\n  RE_FIBER* branch_a;\n  RE_FIBER* branch_b;\n\n  fiber = fiber_to_sync;\n  prev = fiber_to_sync->prev;\n  last = fiber_to_sync->next;\n\n  while(fiber != last)\n  {\n    uint8_t opcode = *fiber->ip;\n\n    switch(opcode)\n    {\n      case RE_OPCODE_SPLIT_A:\n      case RE_OPCODE_SPLIT_B:\n\n        split_id = *(RE_SPLIT_ID_TYPE*)(fiber->ip + 1);\n        split_already_executed = FALSE;\n\n        for (splits_executed_idx = 0;\n             splits_executed_idx < splits_executed_count;\n             splits_executed_idx++)\n        {\n          if (split_id == splits_executed[splits_executed_idx])\n          {\n            split_already_executed = TRUE;\n            break;\n          }\n        }\n\n        if (split_already_executed)\n        {\n          fiber = _yr_re_fiber_kill(fiber_list, fiber_pool, fiber);\n        }\n        else\n        {\n          branch_a = fiber;\n\n          FAIL_ON_ERROR(_yr_re_fiber_split(\n              fiber_list, fiber_pool, branch_a, &branch_b));\n\n          // With RE_OPCODE_SPLIT_A the current fiber continues at the next\n          // instruction in the stream (branch A), while the newly created\n          // fiber starts at the address indicated by the instruction (branch B)\n          // RE_OPCODE_SPLIT_B has the opposite behavior.\n\n          if (opcode == RE_OPCODE_SPLIT_B)\n            yr_swap(branch_a, branch_b, RE_FIBER*);\n\n          // Branch A continues at the next instruction\n\n          branch_a->ip += (sizeof(RE_SPLIT_ID_TYPE) + 3);\n\n          // Branch B adds the offset encoded in the opcode to its instruction\n          // pointer.\n\n          branch_b->ip += *(int16_t*)(\n              branch_b->ip\n              + 1  // opcode size\n              + sizeof(RE_SPLIT_ID_TYPE));\n\n          splits_executed[splits_executed_count] = split_id;\n          splits_executed_count++;\n        }\n\n        break;\n\n      case RE_OPCODE_REPEAT_START_GREEDY:\n      case RE_OPCODE_REPEAT_START_UNGREEDY:\n\n        repeat_args = (RE_REPEAT_ARGS*)(fiber->ip + 1);\n        assert(repeat_args->max > 0);\n        branch_a = fiber;\n\n        if (repeat_args->min == 0)\n        {\n          FAIL_ON_ERROR(_yr_re_fiber_split(\n              fiber_list, fiber_pool, branch_a, &branch_b));\n\n          if (opcode == RE_OPCODE_REPEAT_START_UNGREEDY)\n            yr_swap(branch_a, branch_b, RE_FIBER*);\n\n          branch_b->ip += repeat_args->offset;\n        }\n\n        branch_a->stack[++branch_a->sp] = 0;\n        branch_a->ip += (1 + sizeof(RE_REPEAT_ARGS));\n        break;\n\n      case RE_OPCODE_REPEAT_END_GREEDY:\n      case RE_OPCODE_REPEAT_END_UNGREEDY:\n\n        repeat_args = (RE_REPEAT_ARGS*)(fiber->ip + 1);\n        fiber->stack[fiber->sp]++;\n\n        if (fiber->stack[fiber->sp] < repeat_args->min)\n        {\n          fiber->ip += repeat_args->offset;\n          break;\n        }\n\n        branch_a = fiber;\n\n        if (fiber->stack[fiber->sp] < repeat_args->max)\n        {\n          FAIL_ON_ERROR(_yr_re_fiber_split(\n              fiber_list, fiber_pool, branch_a, &branch_b));\n\n          if (opcode == RE_OPCODE_REPEAT_END_GREEDY)\n            yr_swap(branch_a, branch_b, RE_FIBER*);\n\n          branch_a->sp--;\n          branch_b->ip += repeat_args->offset;\n        }\n\n        branch_a->ip += (1 + sizeof(RE_REPEAT_ARGS));\n        break;\n\n      case RE_OPCODE_REPEAT_ANY_GREEDY:\n      case RE_OPCODE_REPEAT_ANY_UNGREEDY:\n\n        repeat_any_args = (RE_REPEAT_ANY_ARGS*)(fiber->ip + 1);\n\n        // If repetition counter (rc) is -1 it means that we are reaching this\n        // instruction from the previous one in the instructions stream. In\n        // this case let's initialize the counter to 0 and start looping.\n\n        if (fiber->rc == -1)\n          fiber->rc = 0;\n\n        if (fiber->rc < repeat_any_args->min)\n        {\n          // Increase repetition counter and continue with next fiber. The\n          // instruction pointer for this fiber is not incremented yet, this\n          // fiber spins in this same instruction until reaching the minimum\n          // number of repetitions.\n\n          fiber->rc++;\n          fiber = fiber->next;\n        }\n        else if (fiber->rc < repeat_any_args->max)\n        {\n          // Once the minimum number of repetitions are matched one fiber\n          // remains spinning in this instruction until reaching the maximum\n          // number of repetitions while new fibers are created. New fibers\n          // start executing at the next instruction.\n\n          next = fiber->next;\n          branch_a = fiber;\n\n          FAIL_ON_ERROR(_yr_re_fiber_split(\n              fiber_list, fiber_pool, branch_a, &branch_b));\n\n          if (opcode == RE_OPCODE_REPEAT_ANY_UNGREEDY)\n            yr_swap(branch_a, branch_b, RE_FIBER*);\n\n          branch_a->rc++;\n          branch_b->ip += (1 + sizeof(RE_REPEAT_ANY_ARGS));\n          branch_b->rc = -1;\n\n          _yr_re_fiber_sync(fiber_list, fiber_pool, branch_b);\n\n          fiber = next;\n        }\n        else\n        {\n          // When the maximum number of repetitions is reached the fiber keeps\n          // executing at the next instruction. The repetition counter is set\n          // to -1 indicating that we are not spinning in a repeat instruction\n          // anymore.\n\n          fiber->ip += (1 + sizeof(RE_REPEAT_ANY_ARGS));\n          fiber->rc = -1;\n        }\n\n        break;\n\n      case RE_OPCODE_JUMP:\n        fiber->ip += *(int16_t*)(fiber->ip + 1);\n        break;\n\n      default:\n        if (_yr_re_fiber_exists(fiber_list, fiber, prev))\n          fiber = _yr_re_fiber_kill(fiber_list, fiber_pool, fiber);\n        else\n          fiber = fiber->next;\n    }\n  }\n\n  return ERROR_SUCCESS;\n}\n\n\n//\n// yr_re_exec\n//\n// Executes a regular expression. The specified regular expression will try to\n// match the data starting at the address specified by \"input\". The \"input\"\n// pointer can point to any address inside a memory buffer. Arguments\n// \"input_forwards_size\" and \"input_backwards_size\" indicate how many bytes\n// can be accesible starting at \"input\" and going forwards and backwards\n// respectively.\n//\n//   <--- input_backwards_size -->|<----------- input_forwards_size -------->\n//  |--------  memory buffer  -----------------------------------------------|\n//                                ^\n//                              input\n//\n// Args:\n//   uint8_t* re_code                 - Regexp code be executed\n//   uint8_t* input                   - Pointer to input data\n//   size_t input_forwards_size       - Number of accessible bytes starting at\n//                                      \"input\" and going forwards.\n//   size_t input_backwards_size      - Number of accessible bytes starting at\n//                                      \"input\" and going backwards\n//   int flags                        - Flags:\n//      RE_FLAGS_SCAN\n//      RE_FLAGS_BACKWARDS\n//      RE_FLAGS_EXHAUSTIVE\n//      RE_FLAGS_WIDE\n//      RE_FLAGS_NO_CASE\n//      RE_FLAGS_DOT_ALL\n//   RE_MATCH_CALLBACK_FUNC callback  - Callback function\n//   void* callback_args              - Callback argument\n//\n// Returns:\n//    Integer indicating the number of matching bytes, including 0 when\n//    matching an empty regexp. Negative values indicate:\n//      -1  No match\n//      -2  Not enough memory\n//      -3  Too many matches\n//      -4  Too many fibers\n//      -5  Unknown fatal error\n\n\nint yr_re_exec(\n    uint8_t* re_code,\n    uint8_t* input_data,\n    size_t input_forwards_size,\n    size_t input_backwards_size,\n    int flags,\n    RE_MATCH_CALLBACK_FUNC callback,\n    void* callback_args)\n{\n  uint8_t* ip;\n  uint8_t* input;\n  uint8_t mask;\n  uint8_t value;\n\n  RE_FIBER_LIST fibers;\n  RE_THREAD_STORAGE* storage;\n  RE_FIBER* fiber;\n  RE_FIBER* next_fiber;\n\n  int error;\n  int bytes_matched;\n  int max_bytes_matched;\n  int match;\n  int character_size;\n  int input_incr;\n  int kill;\n  int action;\n  int result = -1;\n\n  #define ACTION_NONE       0\n  #define ACTION_CONTINUE   1\n  #define ACTION_KILL       2\n  #define ACTION_KILL_TAIL  3\n\n  #define prolog { \\\n      if ((bytes_matched >= max_bytes_matched) || \\\n          (character_size == 2 && *(input + 1) != 0)) \\\n      { \\\n        action = ACTION_KILL; \\\n        break; \\\n      } \\\n    }\n\n  #define fail_if_error(e) { \\\n      switch (e) { \\\n        case ERROR_INSUFFICIENT_MEMORY: \\\n          return -2; \\\n        case ERROR_TOO_MANY_RE_FIBERS: \\\n          return -4; \\\n      } \\\n    }\n\n  if (_yr_re_alloc_storage(&storage) != ERROR_SUCCESS)\n    return -2;\n\n  if (flags & RE_FLAGS_WIDE)\n    character_size = 2;\n  else\n    character_size = 1;\n\n  input = input_data;\n  input_incr = character_size;\n\n  if (flags & RE_FLAGS_BACKWARDS)\n  {\n    max_bytes_matched = (int) yr_min(input_backwards_size, RE_SCAN_LIMIT);\n    input -= character_size;\n    input_incr = -input_incr;\n  }\n  else\n  {\n    max_bytes_matched = (int) yr_min(input_forwards_size, RE_SCAN_LIMIT);\n  }\n\n  // Round down max_bytes_matched to a multiple of character_size, this way if\n  // character_size is 2 and max_bytes_matched is odd we are ignoring the\n  // extra byte which can't match anyways.\n\n  max_bytes_matched = max_bytes_matched - max_bytes_matched % character_size;\n  bytes_matched = 0;\n\n  error = _yr_re_fiber_create(&storage->fiber_pool, &fiber);\n  fail_if_error(error);\n\n  fiber->ip = re_code;\n  fibers.head = fiber;\n  fibers.tail = fiber;\n\n  error = _yr_re_fiber_sync(&fibers, &storage->fiber_pool, fiber);\n  fail_if_error(error);\n\n  while (fibers.head != NULL)\n  {\n    fiber = fibers.head;\n\n    while(fiber != NULL)\n    {\n      ip = fiber->ip;\n      action = ACTION_NONE;\n\n      switch(*ip)\n      {\n        case RE_OPCODE_ANY:\n          prolog;\n          match = (flags & RE_FLAGS_DOT_ALL) || (*input != 0x0A);\n          action = match ? ACTION_NONE : ACTION_KILL;\n          fiber->ip += 1;\n          break;\n\n        case RE_OPCODE_REPEAT_ANY_GREEDY:\n        case RE_OPCODE_REPEAT_ANY_UNGREEDY:\n          prolog;\n          match = (flags & RE_FLAGS_DOT_ALL) || (*input != 0x0A);\n          action = match ? ACTION_NONE : ACTION_KILL;\n\n          // The instruction pointer is not incremented here. The current fiber\n          // spins in this instruction until reaching the required number of\n          // repetitions. The code controlling the number of repetitions is in\n          // _yr_re_fiber_sync.\n\n          break;\n\n        case RE_OPCODE_LITERAL:\n          prolog;\n          if (flags & RE_FLAGS_NO_CASE)\n            match = yr_lowercase[*input] == yr_lowercase[*(ip + 1)];\n          else\n            match = (*input == *(ip + 1));\n          action = match ? ACTION_NONE : ACTION_KILL;\n          fiber->ip += 2;\n          break;\n\n        case RE_OPCODE_MASKED_LITERAL:\n          prolog;\n          value = *(int16_t*)(ip + 1) & 0xFF;\n          mask = *(int16_t*)(ip + 1) >> 8;\n\n          // We don't need to take into account the case-insensitive\n          // case because this opcode is only used with hex strings,\n          // which can't be case-insensitive.\n\n          match = ((*input & mask) == value);\n          action = match ? ACTION_NONE : ACTION_KILL;\n          fiber->ip += 3;\n          break;\n\n        case RE_OPCODE_CLASS:\n          prolog;\n          match = CHAR_IN_CLASS(*input, ip + 1);\n          if (!match && (flags & RE_FLAGS_NO_CASE))\n            match = CHAR_IN_CLASS(yr_altercase[*input], ip + 1);\n          action = match ? ACTION_NONE : ACTION_KILL;\n          fiber->ip += 33;\n          break;\n\n        case RE_OPCODE_WORD_CHAR:\n          prolog;\n          match = _yr_re_is_word_char(input, character_size);\n          action = match ? ACTION_NONE : ACTION_KILL;\n          fiber->ip += 1;\n          break;\n\n        case RE_OPCODE_NON_WORD_CHAR:\n          prolog;\n          match = !_yr_re_is_word_char(input, character_size);\n          action = match ? ACTION_NONE : ACTION_KILL;\n          fiber->ip += 1;\n          break;\n\n        case RE_OPCODE_SPACE:\n        case RE_OPCODE_NON_SPACE:\n\n          prolog;\n\n          switch(*input)\n          {\n            case ' ':\n            case '\\t':\n            case '\\r':\n            case '\\n':\n            case '\\v':\n            case '\\f':\n              match = TRUE;\n              break;\n            default:\n              match = FALSE;\n          }\n\n          if (*ip == RE_OPCODE_NON_SPACE)\n            match = !match;\n\n          action = match ? ACTION_NONE : ACTION_KILL;\n          fiber->ip += 1;\n          break;\n\n        case RE_OPCODE_DIGIT:\n          prolog;\n          match = isdigit(*input);\n          action = match ? ACTION_NONE : ACTION_KILL;\n          fiber->ip += 1;\n          break;\n\n        case RE_OPCODE_NON_DIGIT:\n          prolog;\n          match = !isdigit(*input);\n          action = match ? ACTION_NONE : ACTION_KILL;\n          fiber->ip += 1;\n          break;\n\n        case RE_OPCODE_WORD_BOUNDARY:\n        case RE_OPCODE_NON_WORD_BOUNDARY:\n\n          if (bytes_matched == 0 && input_backwards_size < character_size)\n          {\n            match = TRUE;\n          }\n          else if (bytes_matched >= max_bytes_matched)\n          {\n            match = TRUE;\n          }\n          else\n          {\n            assert(input <  input_data + input_forwards_size);\n            assert(input >= input_data - input_backwards_size);\n\n            assert(input - input_incr <  input_data + input_forwards_size);\n            assert(input - input_incr >= input_data - input_backwards_size);\n\n            match = _yr_re_is_word_char(input, character_size) != \\\n                    _yr_re_is_word_char(input - input_incr, character_size);\n          }\n\n          if (*ip == RE_OPCODE_NON_WORD_BOUNDARY)\n            match = !match;\n\n          action = match ? ACTION_CONTINUE : ACTION_KILL;\n          fiber->ip += 1;\n          break;\n\n        case RE_OPCODE_MATCH_AT_START:\n          if (flags & RE_FLAGS_BACKWARDS)\n            kill = input_backwards_size > (size_t) bytes_matched;\n          else\n            kill = input_backwards_size > 0 || (bytes_matched != 0);\n          action = kill ? ACTION_KILL : ACTION_CONTINUE;\n          fiber->ip += 1;\n          break;\n\n        case RE_OPCODE_MATCH_AT_END:\n          kill = flags & RE_FLAGS_BACKWARDS ||\n                 input_forwards_size > (size_t) bytes_matched;\n          action = kill ? ACTION_KILL : ACTION_CONTINUE;\n          fiber->ip += 1;\n          break;\n\n        case RE_OPCODE_MATCH:\n\n          result = bytes_matched;\n\n          if (flags & RE_FLAGS_EXHAUSTIVE)\n          {\n            if (callback != NULL)\n            {\n              int cb_result;\n\n              if (flags & RE_FLAGS_BACKWARDS)\n                cb_result = callback(\n                    input + character_size,\n                    bytes_matched,\n                    flags,\n                    callback_args);\n              else\n                cb_result = callback(\n                    input_data,\n                    bytes_matched,\n                    flags,\n                    callback_args);\n\n              switch(cb_result)\n              {\n                case ERROR_INSUFFICIENT_MEMORY:\n                  return -2;\n                case ERROR_TOO_MANY_MATCHES:\n                  return -3;\n                default:\n                  if (cb_result != ERROR_SUCCESS)\n                    return -4;\n              }\n            }\n\n            action = ACTION_KILL;\n          }\n          else\n          {\n            action = ACTION_KILL_TAIL;\n          }\n\n          break;\n\n        default:\n          assert(FALSE);\n      }\n\n      switch(action)\n      {\n        case ACTION_KILL:\n          fiber = _yr_re_fiber_kill(&fibers, &storage->fiber_pool, fiber);\n          break;\n\n        case ACTION_KILL_TAIL:\n          _yr_re_fiber_kill_tail(&fibers, &storage->fiber_pool, fiber);\n          fiber = NULL;\n          break;\n\n        case ACTION_CONTINUE:\n          error = _yr_re_fiber_sync(&fibers, &storage->fiber_pool, fiber);\n          fail_if_error(error);\n          break;\n\n        default:\n          next_fiber = fiber->next;\n          error = _yr_re_fiber_sync(&fibers, &storage->fiber_pool, fiber);\n          fail_if_error(error);\n          fiber = next_fiber;\n      }\n    }\n\n    input += input_incr;\n    bytes_matched += character_size;\n\n    if (flags & RE_FLAGS_SCAN && bytes_matched < max_bytes_matched)\n    {\n      error = _yr_re_fiber_create(&storage->fiber_pool, &fiber);\n      fail_if_error(error);\n\n      fiber->ip = re_code;\n      _yr_re_fiber_append(&fibers, fiber);\n\n      error = _yr_re_fiber_sync(&fibers, &storage->fiber_pool, fiber);\n      fail_if_error(error);\n    }\n  }\n\n  return result;\n}\n\n\nint yr_re_fast_exec(\n    uint8_t* code,\n    uint8_t* input_data,\n    size_t input_forwards_size,\n    size_t input_backwards_size,\n    int flags,\n    RE_MATCH_CALLBACK_FUNC callback,\n    void* callback_args)\n{\n  RE_REPEAT_ANY_ARGS* repeat_any_args;\n\n  uint8_t* code_stack[MAX_FAST_RE_STACK];\n  uint8_t* input_stack[MAX_FAST_RE_STACK];\n  int matches_stack[MAX_FAST_RE_STACK];\n\n  uint8_t* ip = code;\n  uint8_t* input = input_data;\n  uint8_t* next_input;\n  uint8_t* next_opcode;\n  uint8_t mask;\n  uint8_t value;\n\n  int i;\n  int stop;\n  int input_incr;\n  int sp = 0;\n  int bytes_matched;\n  int max_bytes_matched;\n\n  max_bytes_matched = flags & RE_FLAGS_BACKWARDS ?\n      input_backwards_size :\n      input_forwards_size;\n\n  input_incr = flags & RE_FLAGS_BACKWARDS ? -1 : 1;\n\n  if (flags & RE_FLAGS_BACKWARDS)\n    input--;\n\n  code_stack[sp] = code;\n  input_stack[sp] = input;\n  matches_stack[sp] = 0;\n  sp++;\n\n  while (sp > 0)\n  {\n    sp--;\n    ip = code_stack[sp];\n    input = input_stack[sp];\n    bytes_matched = matches_stack[sp];\n    stop = FALSE;\n\n    while(!stop)\n    {\n      if (*ip == RE_OPCODE_MATCH)\n      {\n        if (flags & RE_FLAGS_EXHAUSTIVE)\n        {\n          int cb_result = callback(\n             flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data,\n             bytes_matched,\n             flags,\n             callback_args);\n\n          switch(cb_result)\n          {\n            case ERROR_INSUFFICIENT_MEMORY:\n              return -2;\n            case ERROR_TOO_MANY_MATCHES:\n              return -3;\n            default:\n              if (cb_result != ERROR_SUCCESS)\n                return -4;\n          }\n\n          break;\n        }\n        else\n        {\n          return bytes_matched;\n        }\n      }\n\n      if (bytes_matched >= max_bytes_matched)\n        break;\n\n      switch(*ip)\n      {\n        case RE_OPCODE_LITERAL:\n\n          if (*input == *(ip + 1))\n          {\n            bytes_matched++;\n            input += input_incr;\n            ip += 2;\n          }\n          else\n          {\n            stop = TRUE;\n          }\n\n          break;\n\n        case RE_OPCODE_MASKED_LITERAL:\n\n          value = *(int16_t*)(ip + 1) & 0xFF;\n          mask = *(int16_t*)(ip + 1) >> 8;\n\n          if ((*input & mask) == value)\n          {\n            bytes_matched++;\n            input += input_incr;\n            ip += 3;\n          }\n          else\n          {\n            stop = TRUE;\n          }\n\n          break;\n\n        case RE_OPCODE_ANY:\n\n          bytes_matched++;\n          input += input_incr;\n          ip += 1;\n\n          break;\n\n        case RE_OPCODE_REPEAT_ANY_UNGREEDY:\n\n          repeat_any_args = (RE_REPEAT_ANY_ARGS*)(ip + 1);\n          next_opcode = ip + 1 + sizeof(RE_REPEAT_ANY_ARGS);\n\n          for (i = repeat_any_args->min + 1; i <= repeat_any_args->max; i++)\n          {\n            next_input = input + i * input_incr;\n\n            if (bytes_matched + i >= max_bytes_matched)\n              break;\n\n            if ( *(next_opcode) != RE_OPCODE_LITERAL ||\n                (*(next_opcode) == RE_OPCODE_LITERAL &&\n                 *(next_opcode + 1) == *next_input))\n            {\n              if (sp >= MAX_FAST_RE_STACK)\n                return -4;\n\n              code_stack[sp] = next_opcode;\n              input_stack[sp] = next_input;\n              matches_stack[sp] = bytes_matched + i;\n              sp++;\n            }\n          }\n\n          input += input_incr * repeat_any_args->min;\n          bytes_matched += repeat_any_args->min;\n          ip = next_opcode;\n\n          break;\n\n        default:\n          assert(FALSE);\n      }\n    }\n  }\n\n  return -1;\n}\n\n\nvoid _yr_re_print_node(\n    RE_NODE* re_node)\n{\n  int i;\n\n  if (re_node == NULL)\n    return;\n\n  switch(re_node->type)\n  {\n  case RE_NODE_ALT:\n    printf(\"Alt(\");\n    _yr_re_print_node(re_node->left);\n    printf(\", \");\n    _yr_re_print_node(re_node->right);\n    printf(\")\");\n    break;\n\n  case RE_NODE_CONCAT:\n    printf(\"Cat(\");\n    _yr_re_print_node(re_node->left);\n    printf(\", \");\n    _yr_re_print_node(re_node->right);\n    printf(\")\");\n    break;\n\n  case RE_NODE_STAR:\n    printf(\"Star(\");\n    _yr_re_print_node(re_node->left);\n    printf(\")\");\n    break;\n\n  case RE_NODE_PLUS:\n    printf(\"Plus(\");\n    _yr_re_print_node(re_node->left);\n    printf(\")\");\n    break;\n\n  case RE_NODE_LITERAL:\n    printf(\"Lit(%02X)\", re_node->value);\n    break;\n\n  case RE_NODE_MASKED_LITERAL:\n    printf(\"MaskedLit(%02X,%02X)\", re_node->value, re_node->mask);\n    break;\n\n  case RE_NODE_WORD_CHAR:\n    printf(\"WordChar\");\n    break;\n\n  case RE_NODE_NON_WORD_CHAR:\n    printf(\"NonWordChar\");\n    break;\n\n  case RE_NODE_SPACE:\n    printf(\"Space\");\n    break;\n\n  case RE_NODE_NON_SPACE:\n    printf(\"NonSpace\");\n    break;\n\n  case RE_NODE_DIGIT:\n    printf(\"Digit\");\n    break;\n\n  case RE_NODE_NON_DIGIT:\n    printf(\"NonDigit\");\n    break;\n\n  case RE_NODE_ANY:\n    printf(\"Any\");\n    break;\n\n  case RE_NODE_RANGE:\n    printf(\"Range(%d-%d, \", re_node->start, re_node->end);\n    _yr_re_print_node(re_node->left);\n    printf(\")\");\n    break;\n\n  case RE_NODE_CLASS:\n    printf(\"Class(\");\n    for (i = 0; i < 256; i++)\n      if (CHAR_IN_CLASS(i, re_node->class_vector))\n        printf(\"%02X,\", i);\n    printf(\")\");\n    break;\n\n  default:\n    printf(\"???\");\n    break;\n  }\n}\n\nvoid yr_re_print(\n    RE_AST* re_ast)\n{\n  _yr_re_print_node(re_ast->root_node);\n}\n", "/*\nCopyright (c) 2014. The YARA Authors. All Rights Reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\nlist of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors\nmay be used to endorse or promote products derived from this software without\nspecific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#include <assert.h>\n#include <stdlib.h>\n#include <ctype.h>\n\n#include <yara/globals.h>\n#include <yara/limits.h>\n#include <yara/utils.h>\n#include <yara/re.h>\n#include <yara/types.h>\n#include <yara/error.h>\n#include <yara/libyara.h>\n#include <yara/scan.h>\n\n\ntypedef struct _CALLBACK_ARGS\n{\n  YR_STRING* string;\n  YR_SCAN_CONTEXT* context;\n\n  uint8_t* data;\n  size_t data_size;\n  size_t data_base;\n\n  int forward_matches;\n  int full_word;\n\n} CALLBACK_ARGS;\n\n\nint _yr_scan_compare(\n    uint8_t* data,\n    size_t data_size,\n    uint8_t* string,\n    size_t string_length)\n{\n  uint8_t* s1 = data;\n  uint8_t* s2 = string;\n\n  size_t i = 0;\n\n  if (data_size < string_length)\n    return 0;\n\n  while (i < string_length && *s1++ == *s2++)\n    i++;\n\n  return (int) ((i == string_length) ? i : 0);\n}\n\n\nint _yr_scan_icompare(\n    uint8_t* data,\n    size_t data_size,\n    uint8_t* string,\n    size_t string_length)\n{\n  uint8_t* s1 = data;\n  uint8_t* s2 = string;\n\n  size_t i = 0;\n\n  if (data_size < string_length)\n    return 0;\n\n  while (i < string_length && yr_lowercase[*s1++] == yr_lowercase[*s2++])\n    i++;\n\n  return (int) ((i == string_length) ? i : 0);\n}\n\n\nint _yr_scan_wcompare(\n    uint8_t* data,\n    size_t data_size,\n    uint8_t* string,\n    size_t string_length)\n{\n  uint8_t* s1 = data;\n  uint8_t* s2 = string;\n\n  size_t i = 0;\n\n  if (data_size < string_length * 2)\n    return 0;\n\n  while (i < string_length && *s1 == *s2)\n  {\n    s1+=2;\n    s2++;\n    i++;\n  }\n\n  return (int) ((i == string_length) ? i * 2 : 0);\n}\n\n\nint _yr_scan_wicompare(\n    uint8_t* data,\n    size_t data_size,\n    uint8_t* string,\n    size_t string_length)\n{\n  uint8_t* s1 = data;\n  uint8_t* s2 = string;\n\n  size_t i = 0;\n\n  if (data_size < string_length * 2)\n    return 0;\n\n  while (i < string_length && yr_lowercase[*s1] == yr_lowercase[*s2])\n  {\n    s1+=2;\n    s2++;\n    i++;\n  }\n\n  return (int) ((i == string_length) ? i * 2 : 0);\n}\n\n\nvoid _yr_scan_update_match_chain_length(\n    int tidx,\n    YR_STRING* string,\n    YR_MATCH* match_to_update,\n    int chain_length)\n{\n  YR_MATCH* match;\n\n  if (match_to_update->chain_length == chain_length)\n    return;\n\n  match_to_update->chain_length = chain_length;\n\n  if (string->chained_to == NULL)\n    return;\n\n  match = string->chained_to->unconfirmed_matches[tidx].head;\n\n  while (match != NULL)\n  {\n    int64_t ending_offset = match->offset + match->match_length;\n\n    if (ending_offset + string->chain_gap_max >= match_to_update->offset &&\n        ending_offset + string->chain_gap_min <= match_to_update->offset)\n    {\n      _yr_scan_update_match_chain_length(\n          tidx, string->chained_to, match, chain_length + 1);\n    }\n\n    match = match->next;\n  }\n}\n\n\nint _yr_scan_add_match_to_list(\n    YR_MATCH* match,\n    YR_MATCHES* matches_list,\n    int replace_if_exists)\n{\n  YR_MATCH* insertion_point = matches_list->tail;\n\n  if (matches_list->count == MAX_STRING_MATCHES)\n    return ERROR_TOO_MANY_MATCHES;\n\n  while (insertion_point != NULL)\n  {\n    if (match->offset == insertion_point->offset)\n    {\n      if (replace_if_exists)\n      {\n        insertion_point->match_length = match->match_length;\n        insertion_point->data_length = match->data_length;\n        insertion_point->data = match->data;\n      }\n\n      return ERROR_SUCCESS;\n    }\n\n    if (match->offset > insertion_point->offset)\n      break;\n\n    insertion_point = insertion_point->prev;\n  }\n\n  match->prev = insertion_point;\n\n  if (insertion_point != NULL)\n  {\n    match->next = insertion_point->next;\n    insertion_point->next = match;\n  }\n  else\n  {\n    match->next = matches_list->head;\n    matches_list->head = match;\n  }\n\n  matches_list->count++;\n\n  if (match->next != NULL)\n    match->next->prev = match;\n  else\n    matches_list->tail = match;\n\n  return ERROR_SUCCESS;\n}\n\n\nvoid _yr_scan_remove_match_from_list(\n    YR_MATCH* match,\n    YR_MATCHES* matches_list)\n{\n  if (match->prev != NULL)\n    match->prev->next = match->next;\n\n  if (match->next != NULL)\n    match->next->prev = match->prev;\n\n  if (matches_list->head == match)\n    matches_list->head = match->next;\n\n  if (matches_list->tail == match)\n    matches_list->tail = match->prev;\n\n  matches_list->count--;\n  match->next = NULL;\n  match->prev = NULL;\n}\n\n\nint _yr_scan_verify_chained_string_match(\n    YR_STRING* matching_string,\n    YR_SCAN_CONTEXT* context,\n    uint8_t* match_data,\n    uint64_t match_base,\n    uint64_t match_offset,\n    int32_t match_length)\n{\n  YR_STRING* string;\n  YR_MATCH* match;\n  YR_MATCH* next_match;\n  YR_MATCH* new_match;\n\n  uint64_t lower_offset;\n  uint64_t ending_offset;\n  int32_t full_chain_length;\n\n  int tidx = context->tidx;\n  int add_match = FALSE;\n\n  if (matching_string->chained_to == NULL)\n  {\n    add_match = TRUE;\n  }\n  else\n  {\n    if (matching_string->unconfirmed_matches[tidx].head != NULL)\n      lower_offset = matching_string->unconfirmed_matches[tidx].head->offset;\n    else\n      lower_offset = match_offset;\n\n    match = matching_string->chained_to->unconfirmed_matches[tidx].head;\n\n    while (match != NULL)\n    {\n      next_match = match->next;\n      ending_offset = match->offset + match->match_length;\n\n      if (ending_offset + matching_string->chain_gap_max < lower_offset)\n      {\n        _yr_scan_remove_match_from_list(\n            match, &matching_string->chained_to->unconfirmed_matches[tidx]);\n      }\n      else\n      {\n        if (ending_offset + matching_string->chain_gap_max >= match_offset &&\n            ending_offset + matching_string->chain_gap_min <= match_offset)\n        {\n          add_match = TRUE;\n          break;\n        }\n      }\n\n      match = next_match;\n    }\n  }\n\n  if (add_match)\n  {\n    if (STRING_IS_CHAIN_TAIL(matching_string))\n    {\n      // Chain tails must be chained to some other string\n      assert(matching_string->chained_to != NULL);\n\n      match = matching_string->chained_to->unconfirmed_matches[tidx].head;\n\n      while (match != NULL)\n      {\n        ending_offset = match->offset + match->match_length;\n\n        if (ending_offset + matching_string->chain_gap_max >= match_offset &&\n            ending_offset + matching_string->chain_gap_min <= match_offset)\n        {\n          _yr_scan_update_match_chain_length(\n              tidx, matching_string->chained_to, match, 1);\n        }\n\n        match = match->next;\n      }\n\n      full_chain_length = 0;\n      string = matching_string;\n\n      while(string->chained_to != NULL)\n      {\n        full_chain_length++;\n        string = string->chained_to;\n      }\n\n      // \"string\" points now to the head of the strings chain\n\n      match = string->unconfirmed_matches[tidx].head;\n\n      while (match != NULL)\n      {\n        next_match = match->next;\n\n        if (match->chain_length == full_chain_length)\n        {\n          _yr_scan_remove_match_from_list(\n              match, &string->unconfirmed_matches[tidx]);\n\n          match->match_length = (int32_t) \\\n              (match_offset - match->offset + match_length);\n\n          match->data_length = yr_min(match->match_length, MAX_MATCH_DATA);\n\n          FAIL_ON_ERROR(yr_arena_write_data(\n              context->matches_arena,\n              match_data - match_offset + match->offset,\n              match->data_length,\n              (void**) &match->data));\n\n          FAIL_ON_ERROR(_yr_scan_add_match_to_list(\n              match, &string->matches[tidx], FALSE));\n        }\n\n        match = next_match;\n      }\n    }\n    else\n    {\n      if (matching_string->matches[tidx].count == 0 &&\n          matching_string->unconfirmed_matches[tidx].count == 0)\n      {\n        // If this is the first match for the string, put the string in the\n        // list of strings whose flags needs to be cleared after the scan.\n\n        FAIL_ON_ERROR(yr_arena_write_data(\n            context->matching_strings_arena,\n            &matching_string,\n            sizeof(matching_string),\n            NULL));\n      }\n\n      FAIL_ON_ERROR(yr_arena_allocate_memory(\n          context->matches_arena,\n          sizeof(YR_MATCH),\n          (void**) &new_match));\n\n      new_match->data_length = yr_min(match_length, MAX_MATCH_DATA);\n\n      FAIL_ON_ERROR(yr_arena_write_data(\n          context->matches_arena,\n          match_data,\n          new_match->data_length,\n          (void**) &new_match->data));\n\n      new_match->base = match_base;\n      new_match->offset = match_offset;\n      new_match->match_length = match_length;\n      new_match->chain_length = 0;\n      new_match->prev = NULL;\n      new_match->next = NULL;\n\n      FAIL_ON_ERROR(_yr_scan_add_match_to_list(\n          new_match,\n          &matching_string->unconfirmed_matches[tidx],\n          FALSE));\n    }\n  }\n\n  return ERROR_SUCCESS;\n}\n\n\nint _yr_scan_match_callback(\n    uint8_t* match_data,\n    int32_t match_length,\n    int flags,\n    void* args)\n{\n  CALLBACK_ARGS* callback_args = (CALLBACK_ARGS*) args;\n\n  YR_STRING* string = callback_args->string;\n  YR_MATCH* new_match;\n\n  int result = ERROR_SUCCESS;\n  int tidx = callback_args->context->tidx;\n\n  size_t match_offset = match_data - callback_args->data;\n\n  // total match length is the sum of backward and forward matches.\n  match_length += callback_args->forward_matches;\n\n  if (callback_args->full_word)\n  {\n    if (flags & RE_FLAGS_WIDE)\n    {\n      if (match_offset >= 2 &&\n          *(match_data - 1) == 0 &&\n          isalnum(*(match_data - 2)))\n        return ERROR_SUCCESS;\n\n      if (match_offset + match_length + 1 < callback_args->data_size &&\n          *(match_data + match_length + 1) == 0 &&\n          isalnum(*(match_data + match_length)))\n        return ERROR_SUCCESS;\n    }\n    else\n    {\n      if (match_offset >= 1 &&\n          isalnum(*(match_data - 1)))\n        return ERROR_SUCCESS;\n\n      if (match_offset + match_length < callback_args->data_size &&\n          isalnum(*(match_data + match_length)))\n        return ERROR_SUCCESS;\n    }\n  }\n\n  if (STRING_IS_CHAIN_PART(string))\n  {\n    result = _yr_scan_verify_chained_string_match(\n        string,\n        callback_args->context,\n        match_data,\n        callback_args->data_base,\n        match_offset,\n        match_length);\n  }\n  else\n  {\n    if (string->matches[tidx].count == 0)\n    {\n      // If this is the first match for the string, put the string in the\n      // list of strings whose flags needs to be cleared after the scan.\n\n      FAIL_ON_ERROR(yr_arena_write_data(\n          callback_args->context->matching_strings_arena,\n          &string,\n          sizeof(string),\n          NULL));\n    }\n\n    FAIL_ON_ERROR(yr_arena_allocate_memory(\n        callback_args->context->matches_arena,\n        sizeof(YR_MATCH),\n        (void**) &new_match));\n\n    new_match->data_length = yr_min(match_length, MAX_MATCH_DATA);\n\n    FAIL_ON_ERROR(yr_arena_write_data(\n        callback_args->context->matches_arena,\n        match_data,\n        new_match->data_length,\n        (void**) &new_match->data));\n\n    if (result == ERROR_SUCCESS)\n    {\n      new_match->base = callback_args->data_base;\n      new_match->offset = match_offset;\n      new_match->match_length = match_length;\n      new_match->prev = NULL;\n      new_match->next = NULL;\n\n      FAIL_ON_ERROR(_yr_scan_add_match_to_list(\n          new_match,\n          &string->matches[tidx],\n          STRING_IS_GREEDY_REGEXP(string)));\n    }\n  }\n\n  return result;\n}\n\n\ntypedef int (*RE_EXEC_FUNC)(\n    uint8_t* code,\n    uint8_t* input,\n    size_t input_forwards_size,\n    size_t input_backwards_size,\n    int flags,\n    RE_MATCH_CALLBACK_FUNC callback,\n    void* callback_args);\n\n\nint _yr_scan_verify_re_match(\n    YR_SCAN_CONTEXT* context,\n    YR_AC_MATCH* ac_match,\n    uint8_t* data,\n    size_t data_size,\n    size_t data_base,\n    size_t offset)\n{\n  CALLBACK_ARGS callback_args;\n  RE_EXEC_FUNC exec;\n\n  int forward_matches = -1;\n  int backward_matches = -1;\n  int flags = 0;\n\n  if (STRING_IS_GREEDY_REGEXP(ac_match->string))\n    flags |= RE_FLAGS_GREEDY;\n\n  if (STRING_IS_NO_CASE(ac_match->string))\n    flags |= RE_FLAGS_NO_CASE;\n\n  if (STRING_IS_DOT_ALL(ac_match->string))\n    flags |= RE_FLAGS_DOT_ALL;\n\n  if (STRING_IS_FAST_REGEXP(ac_match->string))\n    exec = yr_re_fast_exec;\n  else\n    exec = yr_re_exec;\n\n  if (STRING_IS_ASCII(ac_match->string))\n  {\n    forward_matches = exec(\n        ac_match->forward_code,\n        data + offset,\n        data_size - offset,\n        offset,\n        flags,\n        NULL,\n        NULL);\n  }\n\n  if (STRING_IS_WIDE(ac_match->string) && forward_matches == -1)\n  {\n    flags |= RE_FLAGS_WIDE;\n    forward_matches = exec(\n        ac_match->forward_code,\n        data + offset,\n        data_size - offset,\n        offset,\n        flags,\n        NULL,\n        NULL);\n  }\n\n  switch(forward_matches)\n  {\n    case -1:\n      return ERROR_SUCCESS;\n    case -2:\n      return ERROR_INSUFFICIENT_MEMORY;\n    case -3:\n      return ERROR_TOO_MANY_MATCHES;\n    case -4:\n      return ERROR_TOO_MANY_RE_FIBERS;\n    case -5:\n      return ERROR_INTERNAL_FATAL_ERROR;\n  }\n\n  if (forward_matches == 0 && ac_match->backward_code == NULL)\n    return ERROR_SUCCESS;\n\n  callback_args.string = ac_match->string;\n  callback_args.context = context;\n  callback_args.data = data;\n  callback_args.data_size = data_size;\n  callback_args.data_base = data_base;\n  callback_args.forward_matches = forward_matches;\n  callback_args.full_word = STRING_IS_FULL_WORD(ac_match->string);\n\n  if (ac_match->backward_code != NULL)\n  {\n    backward_matches = exec(\n        ac_match->backward_code,\n        data + offset,\n        data_size - offset,\n        offset,\n        flags | RE_FLAGS_BACKWARDS | RE_FLAGS_EXHAUSTIVE,\n        _yr_scan_match_callback,\n        (void*) &callback_args);\n\n    switch(backward_matches)\n    {\n      case -2:\n        return ERROR_INSUFFICIENT_MEMORY;\n      case -3:\n        return ERROR_TOO_MANY_MATCHES;\n      case -4:\n        return ERROR_TOO_MANY_RE_FIBERS;\n      case -5:\n        return ERROR_INTERNAL_FATAL_ERROR;\n    }\n  }\n  else\n  {\n    FAIL_ON_ERROR(_yr_scan_match_callback(\n        data + offset, 0, flags, &callback_args));\n  }\n\n  return ERROR_SUCCESS;\n}\n\n\nint _yr_scan_verify_literal_match(\n    YR_SCAN_CONTEXT* context,\n    YR_AC_MATCH* ac_match,\n    uint8_t* data,\n    size_t data_size,\n    size_t data_base,\n    size_t offset)\n{\n  int flags = 0;\n  int forward_matches = 0;\n\n  CALLBACK_ARGS callback_args;\n  YR_STRING* string = ac_match->string;\n\n  if (STRING_FITS_IN_ATOM(string))\n  {\n    forward_matches = ac_match->backtrack;\n  }\n  else if (STRING_IS_NO_CASE(string))\n  {\n    if (STRING_IS_ASCII(string))\n    {\n      forward_matches = _yr_scan_icompare(\n          data + offset,\n          data_size - offset,\n          string->string,\n          string->length);\n    }\n\n    if (STRING_IS_WIDE(string) && forward_matches == 0)\n    {\n      forward_matches = _yr_scan_wicompare(\n          data + offset,\n          data_size - offset,\n          string->string,\n          string->length);\n    }\n  }\n  else\n  {\n    if (STRING_IS_ASCII(string))\n    {\n      forward_matches = _yr_scan_compare(\n          data + offset,\n          data_size - offset,\n          string->string,\n          string->length);\n    }\n\n    if (STRING_IS_WIDE(string) && forward_matches == 0)\n    {\n      forward_matches = _yr_scan_wcompare(\n          data + offset,\n          data_size - offset,\n          string->string,\n          string->length);\n    }\n  }\n\n  if (forward_matches == 0)\n    return ERROR_SUCCESS;\n\n  if (forward_matches == string->length * 2)\n    flags |= RE_FLAGS_WIDE;\n\n  if (STRING_IS_NO_CASE(string))\n    flags |= RE_FLAGS_NO_CASE;\n\n  callback_args.context = context;\n  callback_args.string = string;\n  callback_args.data = data;\n  callback_args.data_size = data_size;\n  callback_args.data_base = data_base;\n  callback_args.forward_matches = forward_matches;\n  callback_args.full_word = STRING_IS_FULL_WORD(string);\n\n  FAIL_ON_ERROR(_yr_scan_match_callback(\n      data + offset, 0, flags, &callback_args));\n\n  return ERROR_SUCCESS;\n}\n\n\nint yr_scan_verify_match(\n    YR_SCAN_CONTEXT* context,\n    YR_AC_MATCH* ac_match,\n    uint8_t* data,\n    size_t data_size,\n    size_t data_base,\n    size_t offset)\n{\n  YR_STRING* string = ac_match->string;\n\n  #ifdef PROFILING_ENABLED\n  clock_t start = clock();\n  #endif\n\n  if (data_size - offset <= 0)\n    return ERROR_SUCCESS;\n\n  if (context->flags & SCAN_FLAGS_FAST_MODE &&\n      STRING_IS_SINGLE_MATCH(string) &&\n      string->matches[context->tidx].head != NULL)\n    return ERROR_SUCCESS;\n\n  if (STRING_IS_FIXED_OFFSET(string) &&\n      string->fixed_offset != data_base + offset)\n    return ERROR_SUCCESS;\n\n  if (STRING_IS_LITERAL(string))\n  {\n    FAIL_ON_ERROR(_yr_scan_verify_literal_match(\n        context, ac_match, data, data_size, data_base, offset));\n  }\n  else\n  {\n    FAIL_ON_ERROR(_yr_scan_verify_re_match(\n        context, ac_match, data, data_size, data_base, offset));\n  }\n\n  #ifdef PROFILING_ENABLED\n  string->clock_ticks += clock() - start;\n  #endif\n\n  return ERROR_SUCCESS;\n}\n", "/*\nCopyright (c) 2016. The YARA Authors. All Rights Reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\nlist of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors\nmay be used to endorse or promote products derived from this software without\nspecific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#include <yara.h>\n#include \"blob.h\"\n#include \"util.h\"\n\n#if defined(_WIN32) || defined(__CYGWIN__)\n#include <fileapi.h>\n#else\n#include <unistd.h>\n#endif\n#include <fcntl.h>\n\nstatic void test_boolean_operators()\n{\n  assert_true_rule(\n      \"rule test { condition: true }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: true or false }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: true and true }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 0x1 and 0x2}\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: false }\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: true and false }\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: false or false }\", NULL);\n}\n\n\nstatic void test_comparison_operators()\n{\n  assert_true_rule(\n      \"rule test { condition: 2 > 1 }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1 < 2 }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 2 >= 1 }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1 <= 1 }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1 == 1 }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1.5 == 1.5}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1.0 == 1}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1.5 >= 1.0}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1.5 >= 1}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1.0 >= 1}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 0.5 < 1}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 0.5 <= 1}\", NULL);\n\n  assert_true_rule(\n      \"rule rest { condition: 1.0 <= 1}\", NULL);\n\n  assert_true_rule(\n      \"rule rest { condition: \\\"abc\\\" == \\\"abc\\\"}\", NULL);\n\n  assert_true_rule(\n      \"rule rest { condition: \\\"abc\\\" <= \\\"abc\\\"}\", NULL);\n\n  assert_true_rule(\n      \"rule rest { condition: \\\"abc\\\" >= \\\"abc\\\"}\", NULL);\n\n  assert_true_rule(\n      \"rule rest { condition: \\\"ab\\\" < \\\"abc\\\"}\", NULL);\n\n  assert_true_rule(\n      \"rule rest { condition: \\\"abc\\\" > \\\"ab\\\"}\", NULL);\n\n  assert_true_rule(\n      \"rule rest { condition: \\\"abc\\\" < \\\"abd\\\"}\", NULL);\n\n  assert_true_rule(\n      \"rule rest { condition: \\\"abd\\\" > \\\"abc\\\"}\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: 1 != 1}\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: 1 != 1.0}\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: 2 > 3}\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: 2.1 < 2}\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: \\\"abc\\\" != \\\"abc\\\"}\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: \\\"abc\\\" > \\\"abc\\\"}\", NULL);\n\n  assert_false_rule(\n      \"rule test { condition: \\\"abc\\\" < \\\"abc\\\"}\", NULL);\n\n}\n\nstatic void test_arithmetic_operators()\n{\n  assert_true_rule(\n      \"rule test { condition: (1 + 1) * 2 == (9 - 1) \\\\ 2 }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 5 % 2 == 1 }\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1.5 + 1.5 == 3}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 3 \\\\ 2 == 1}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 3.0 \\\\ 2 == 1.5}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1 + -1 == 0}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: -1 + -1 == -2}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 4 --2 * 2 == 8}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: -1.0 * 1 == -1.0}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1-1 == 0}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: -2.0-3.0 == -5}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: --1 == 1}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1--1 == 2}\", NULL);\n\n  assert_true_rule(\n      \"rule test { condition: -0x01 == -1}\", NULL);\n\n}\n\n\nstatic void test_bitwise_operators()\n{\n  assert_true_rule(\n      \"rule test { condition: 0x55 | 0xAA == 0xFF }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { condition: ~0xAA ^ 0x5A & 0xFF == (~0xAA) ^ (0x5A & 0xFF) }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { condition: ~0x55 & 0xFF == 0xAA }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 8 >> 2 == 2 }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1 << 3 == 8 }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { condition: 1 | 3 ^ 3 == 1 | (3 ^ 3) }\",\n      NULL);\n\n  assert_false_rule(\n      \"rule test { condition: ~0xAA ^ 0x5A & 0xFF == 0x0F }\",\n      NULL);\n\n  assert_false_rule(\n      \"rule test { condition: 1 | 3 ^ 3 == (1 | 3) ^ 3}\",\n      NULL);\n\n}\n\n\nstatic void test_syntax()\n{\n  assert_error(\n      \"rule test { strings: $a = \\\"a\\\" $a = \\\"a\\\" condition: all of them }\",\n      ERROR_DUPLICATED_STRING_IDENTIFIER);\n}\n\n\nstatic void test_anonymous_strings()\n{\n  assert_true_rule(\n      \"rule test { strings: $ = \\\"a\\\" $ = \\\"b\\\" condition: all of them }\",\n      \"ab\");\n}\n\n\nstatic void test_strings()\n{\n  char* str = \"---- abc ---- xyz\";\n  uint8_t blob[] = \"---- a\\0b\\0c\\0 -\\0-\\0-\\0-\\0x\\0y\\0z\\0\";\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"a\\\" condition: $a }\",\n      str);\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"ab\\\" condition: $a }\",\n      str);\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"abc\\\" condition: $a }\",\n      str);\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"xyz\\\" condition: $a }\",\n      str);\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"abc\\\" nocase fullword condition: $a }\",\n      str);\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"aBc\\\" nocase  condition: $a }\",\n      str);\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"abc\\\" fullword condition: $a }\",\n      str);\n\n  assert_false_rule(\n      \"rule test { strings: $a = \\\"a\\\" fullword condition: $a }\",\n      str);\n\n  assert_false_rule(\n      \"rule test { strings: $a = \\\"ab\\\" fullword condition: $a }\",\n      str);\n\n  assert_false_rule(\n      \"rule test { strings: $a = \\\"abc\\\" wide fullword condition: $a }\",\n      str);\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"a\\\" wide condition: $a }\",\n      blob);\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"a\\\" wide ascii condition: $a }\",\n      blob);\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"ab\\\" wide condition: $a }\",\n      blob);\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"ab\\\" wide ascii condition: $a }\",\n      blob);\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"abc\\\" wide condition: $a }\",\n      blob);\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"abc\\\" wide nocase fullword condition: $a }\",\n      blob);\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"aBc\\\" wide nocase condition: $a }\",\n      blob);\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"aBc\\\" wide ascii nocase condition: $a }\",\n      blob);\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"---xyz\\\" wide nocase condition: $a }\",\n      blob);\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"abc\\\" fullword condition: $a }\",\n      \"abc\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = \\\"abc\\\" fullword condition: $a }\",\n      \"xabcx\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = \\\"abc\\\" fullword condition: $a }\",\n      \"xabc\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = \\\"abc\\\" fullword condition: $a }\",\n      \"abcx\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = \\\"abc\\\" ascii wide fullword condition: $a }\",\n      \"abcx\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"abc\\\" ascii wide fullword condition: $a }\",\n      \"a\\0abc\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"abc\\\" wide fullword condition: $a }\",\n      \"a\\0b\\0c\\0\");\n\n  assert_false_rule_blob(\n      \"rule test { strings: $a = \\\"abc\\\" wide fullword condition: $a }\",\n      \"x\\0a\\0b\\0c\\0x\\0\");\n\n  assert_false_rule_blob(\n      \"rule test { strings: $a = \\\"ab\\\" wide fullword condition: $a }\",\n      \"x\\0a\\0b\\0\");\n\n  assert_false_rule_blob(\n      \"rule test { strings: $a = \\\"abc\\\" wide fullword condition: $a }\",\n      \"x\\0a\\0b\\0c\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = \\\"abc\\\" wide fullword condition: $a }\",\n      \"x\\001a\\0b\\0c\\0\");\n\n  assert_true_rule(\n      \"rule test {\\n\\\n         strings:\\n\\\n             $a = \\\"abcdef\\\"\\n\\\n             $b = \\\"cdef\\\"\\n\\\n             $c = \\\"ef\\\"\\n\\\n         condition:\\n\\\n             all of them\\n\\\n       }\", \"abcdef\");\n}\n\n\nstatic void test_wildcard_strings()\n{\n  assert_true_rule_blob(\n      \"rule test {\\n\\\n         strings:\\n\\\n             $s1 = \\\"abc\\\"\\n\\\n             $s2 = \\\"xyz\\\"\\n\\\n         condition:\\n\\\n             for all of ($*) : ($)\\n\\\n      }\",\n      \"---- abc ---- A\\x00\"\"B\\x00\"\"C\\x00 ---- xyz\");\n}\n\n\nstatic void test_hex_strings()\n{\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 64 01 00 00 60 01 } \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 64 0? 00 00 ?0 01 } \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\\\n\n      \"rule test { \\\n        strings: $a = { 6? 01 00 00 60 0? } \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 64 01 [1-3] 60 01 } \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 64 01 [1-3] (60|61) 01 } \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 4D 5A [-] 6A 2A [-] 58 C3} \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 4D 5A [300-] 6A 2A [-] 58 C3} \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 2e 7? (65 | ?? ) 78 } \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_false_rule_blob(\n      \"rule test { \\\n        strings: $a = { 4D 5A [0-300] 6A 2A } \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_false_rule_blob(\n      \"rule test { \\\n        strings: $a = { 4D 5A [0-128] 45 [0-128] 01 [0-128]  C3 } \\\n        condition: $a }\",\n      PE32_FILE);\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [-] 38 39 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [-] // Inline comment\\n\\r \\\n          38 39 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 /* Inline comment */ [-] 38 39 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 /* Inline multi-line\\n\\r \\\n                                 comment */ [-] 38 39 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = {\\n 31 32 [-] 38 39 \\n\\r} \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [-] 33 34 [-] 38 39 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [1] 34 35 [2] 38 39 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test {\\\n         strings: $a = { 31 32 [1-] 34 35 [1-] 38 39 } \\\n         condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [0-3] 34 35 [1-] 38 39 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [0-2] 35 [1-] 37 38 39 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [0-1] 33 } \\\n        condition: !a == 3}\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [0-1] 34 } \\\n        condition: !a == 4}\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [0-2] 34 } \\\n        condition: !a == 4 }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [-] 38 39 } \\\n        condition: all of them }\",\n      \"1234567890\");\n\n  assert_false_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [-] 32 33 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_false_rule(\n      \"rule test { \\\n        strings: $a = { 35 36 [-] 31 32 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_false_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [2-] 34 35 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [0-1] 33 34 [0-2] 36 37 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [0-1] 34 35 [0-2] 36 37 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_false_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [0-3] 37 38 } \\\n        condition: $a }\",\n      \"1234567890\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = { 31 32 [1] 33 34 } \\\n        condition: $a }\",\n      \"12\\n34\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = {31 32 [3-6] 32} \\\n        condition: !a == 6 }\",\n      \"12111222\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = {31 [0-3] (32|33)} \\\n        condition: !a == 2 }\",\n      \"122222222\");\n\n  assert_error(\n      \"rule test { \\\n        strings: $a = { 01 [0] 02 } \\\n        condition: $a }\",\n      ERROR_INVALID_HEX_STRING);\n\n  assert_error(\n      \"rule test { \\\n        strings: $a = { [-] 01 02 } condition: $a }\",\n      ERROR_INVALID_HEX_STRING);\n\n  assert_error(\n      \"rule test { \\\n        strings: $a = { 01 02 [-] } \\\n        condition: $a }\",\n      ERROR_INVALID_HEX_STRING);\n\n  assert_error(\n      \"rule test { \\\n        strings: $a = { 01 02 ([-] 03 | 04) } \\\n        condition: $a }\",\n      ERROR_INVALID_HEX_STRING);\n\n  assert_error(\n      \"rule test { \\\n        strings: $a = { 01 02 (03 [-] | 04) } \\\n        condition: $a }\",\n      ERROR_INVALID_HEX_STRING);\n\n  assert_error(\n      \"rule test { \\\n        strings: $a = { 01 02 (03 | 04 [-]) } \\\n        condition: $a \",\n      ERROR_INVALID_HEX_STRING);\n\n  /* TODO: tests.py:551 ff. */\n}\n\n\nstatic void test_count()\n{\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"ssi\\\" condition: #a == 2 }\",\n      \"mississippi\");\n}\n\n\nstatic void test_at()\n{\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = \\\"ssi\\\" \\\n        condition: $a at 2 and $a at 5 }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: $a = \\\"mis\\\" \\\n        condition: $a at ~0xFF & 0xFF }\",\n      \"mississippi\");\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 00 00 00 00 ?? 74 65 78 74 } \\\n        condition: $a at 308}\",\n      PE32_FILE);\n}\n\n\nstatic void test_in()\n{\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 6a 2a 58 c3 } \\\n        condition: $a in (entrypoint .. entrypoint + 1) }\",\n      PE32_FILE);\n}\n\n\nstatic void test_offset()\n{\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"ssi\\\" condition: @a == 2 }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"ssi\\\" condition: @a == @a[1] }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"ssi\\\" condition: @a[2] == 5 }\",\n      \"mississippi\");\n}\n\n\nstatic void test_length()\n{\n  assert_true_rule(\n      \"rule test { strings: $a = /m.*?ssi/ condition: !a == 5 }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /m.*?ssi/ condition: !a[1] == 5 }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /m.*ssi/ condition: !a == 8 }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /m.*ssi/ condition: !a[1] == 8 }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ssi.*ppi/ condition: !a[1] == 9 }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ssi.*ppi/ condition: !a[2] == 6 }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = { 6D [1-3] 73 73 69 } condition: !a == 5}\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = { 6D [-] 73 73 69 } condition: !a == 5}\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = { 6D [-] 70 70 69 } condition: !a == 11}\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = { 6D 69 73 73 [-] 70 69 } condition: !a == 11}\",\n      \"mississippi\");\n}\n\n\nstatic void test_of()\n{\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"ssi\\\" $b = \\\"mis\\\" $c = \\\"oops\\\" \"\n      \"condition: any of them }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"ssi\\\" $b = \\\"mis\\\" $c = \\\"oops\\\" \"\n      \"condition: 1 of them }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = \\\"ssi\\\" $b = \\\"mis\\\" $c = \\\"oops\\\" \"\n      \"condition: 2 of them }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a1 = \\\"dummy1\\\" $b1 = \\\"dummy1\\\" $b2 = \\\"ssi\\\"\"\n      \"condition: any of ($a*, $b*) }\",\n      \"mississippi\");\n\n  assert_true_rule_blob(\n      \"rule test { \\\n         strings: \\\n           $ = /abc/ \\\n           $ = /def/ \\\n           $ = /ghi/ \\\n         condition: \\\n           for any of ($*) : ( for any i in (1..#): (uint8(@[i] - 1) == 0x00) )\\\n       }\",\n       \"abc\\000def\\000ghi\");\n\n  assert_false_rule(\n      \"rule test { \\\n        strings: \\\n          $a = \\\"ssi\\\" \\\n          $b = \\\"mis\\\" \\\n          $c = \\\"oops\\\" \\\n        condition: \\\n          all of them \\\n      }\",\n      \"mississippi\");\n\n  assert_error(\n      \"rule test { condition: all of ($a*) }\",\n      ERROR_UNDEFINED_STRING);\n\n  assert_error(\n      \"rule test { condition: all of them }\",\n      ERROR_UNDEFINED_STRING);\n}\n\n\nvoid test_for()\n{\n  assert_true_rule(\n      \"rule test { \\\n        strings: \\\n          $a = \\\"ssi\\\" \\\n        condition: \\\n          for all i in (1..#a) : (@a[i] >= 2 and @a[i] <= 5) \\\n      }\",\n      \"mississippi\");\n\n  assert_true_rule(\n      \"rule test { \\\n        strings: \\\n          $a = \\\"ssi\\\" \\\n          $b = \\\"mi\\\" \\\n        condition: \\\n          for all i in (1..#a) : ( for all j in (1..#b) : (@a[i] >= @b[j])) \\\n      }\",\n      \"mississippi\");\n\n  assert_false_rule(\n      \"rule test { \\\n        strings: \\\n          $a = \\\"ssi\\\" \\\n        condition: \\\n          for all i in (1..#a) : (@a[i] == 5) \\\n      }\",\n      \"mississippi\");\n}\n\n\nvoid test_re()\n{\n  assert_true_rule(\n      \"rule test { strings: $a = /ssi/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ssi(s|p)/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ssim*/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ssa?/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /Miss/ nocase condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /(M|N)iss/ nocase condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /[M-N]iss/ nocase condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /(Mi|ssi)ssippi/ nocase condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ppi\\\\tmi/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /ppi\\\\.mi/ condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /^mississippi/ fullword condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_true_rule(\n      \"rule test { strings: $a = /mississippi.*mississippi$/s condition: $a }\",\n      \"mississippi\\tmississippi.mississippi\\nmississippi\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = /^ssi/ condition: $a }\",\n      \"mississippi\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = /ssi$/ condition: $a }\",\n      \"mississippi\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = /ssissi/ fullword condition: $a }\",\n      \"mississippi\");\n\n  assert_false_rule(\n      \"rule test { strings: $a = /^[isp]+/ condition: $a }\",\n      \"mississippi\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /a.{1,2}b/ wide condition: !a == 6 }\",\n      \"a\\0x\\0b\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /a.{1,2}b/ wide condition: !a == 8 }\",\n      \"a\\0x\\0x\\0b\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n      \"a\\0b\\0c\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n      \"\\0a\\0b\\0c\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n      \"\\ta\\0b\\0c\\0\");\n\n  assert_false_rule_blob(\n      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n      \"x\\0a\\0b\\0c\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /\\\\babc/ wide condition: $a }\",\n      \"x\\ta\\0b\\0c\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n      \"a\\0b\\0c\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n      \"a\\0b\\0c\\0\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n      \"a\\0b\\0c\\0\\t\");\n\n  assert_false_rule_blob(\n      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n      \"a\\0b\\0c\\0x\\0\");\n\n  assert_true_rule_blob(\n      \"rule test { strings: $a = /abc\\\\b/ wide condition: $a }\",\n      \"a\\0b\\0c\\0b\\t\");\n\n  assert_false_rule_blob(\n      \"rule test { strings: $a = /\\\\b/ wide condition: $a }\",\n      \"abc\");\n\n  assert_regexp_syntax_error(\")\");\n  assert_true_regexp(\"abc\", \"abc\", \"abc\");\n  assert_false_regexp(\"abc\", \"xbc\");\n  assert_false_regexp(\"abc\", \"axc\");\n  assert_false_regexp(\"abc\", \"abx\");\n  assert_true_regexp(\"abc\", \"xabcx\", \"abc\");\n  assert_true_regexp(\"abc\", \"ababc\", \"abc\");\n  assert_true_regexp(\"a.c\", \"abc\", \"abc\");\n  assert_false_regexp(\"a.b\", \"a\\nb\");\n  assert_false_regexp(\"a.*b\", \"acc\\nccb\");\n  assert_false_regexp(\"a.{4,5}b\", \"acc\\nccb\");\n  assert_true_regexp(\"a.b\", \"a\\rb\", \"a\\rb\");\n  assert_true_regexp(\"ab*c\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab*c\", \"ac\", \"ac\");\n  assert_true_regexp(\"ab*bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab*bc\", \"abbc\", \"abbc\");\n  assert_true_regexp(\"a.*bb\", \"abbbb\", \"abbbb\");\n  assert_true_regexp(\"a.*?bbb\", \"abbbbbb\", \"abbb\");\n  assert_true_regexp(\"a.*c\", \"ac\", \"ac\");\n  assert_true_regexp(\"a.*c\", \"axyzc\", \"axyzc\");\n  assert_true_regexp(\"ab+c\", \"abbc\", \"abbc\");\n  assert_false_regexp(\"ab+c\", \"ac\");\n  assert_true_regexp(\"ab+\", \"abbbb\", \"abbbb\");\n  assert_true_regexp(\"ab+?\", \"abbbb\", \"ab\");\n  assert_false_regexp(\"ab+bc\", \"abc\");\n  assert_false_regexp(\"ab+bc\", \"abq\");\n  assert_true_regexp(\"a+b+c\", \"aabbabc\", \"abc\");\n  assert_false_regexp(\"ab?bc\", \"abbbbc\");\n  assert_true_regexp(\"ab?c\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab*?\", \"abbb\", \"a\");\n  assert_true_regexp(\"ab?c\", \"ac\", \"ac\");\n  assert_true_regexp(\"ab??\", \"ab\", \"a\");\n  assert_true_regexp(\"a(b|x)c\", \"abc\", \"abc\");\n  assert_true_regexp(\"a(b|x)c\", \"axc\", \"axc\");\n  assert_true_regexp(\"a(b|.)c\", \"axc\", \"axc\");\n  assert_true_regexp(\"a(b|x|y)c\", \"ayc\", \"ayc\");\n  assert_true_regexp(\"(a+|b)*\", \"ab\", \"ab\");\n  assert_true_regexp(\"a|b|c|d|e\", \"e\", \"e\");\n  assert_true_regexp(\"(a|b|c|d|e)f\", \"ef\", \"ef\");\n  assert_true_regexp(\".b{2}\", \"abb\", \"abb\");\n  assert_true_regexp(\".b{2,3}\", \"abbb\", \"abbb\");\n  assert_true_regexp(\".b{2,3}?\", \"abbb\", \"abb\");\n  assert_true_regexp(\"ab{2,3}c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\"ab{2,3}?c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\".b{2,3}cccc\", \"abbbcccc\", \"abbbcccc\");\n  assert_true_regexp(\".b{2,3}?cccc\", \"abbbcccc\", \"bbbcccc\");\n  assert_true_regexp(\"a.b{2,3}cccc\", \"aabbbcccc\", \"aabbbcccc\");\n  assert_true_regexp(\"ab{2,3}c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\"ab{2,3}?c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\"ab{0,1}?c\", \"abc\", \"abc\");\n  assert_true_regexp(\"a{0,1}?bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"a{0,1}bc\", \"bbc\", \"bc\");\n  assert_true_regexp(\"a{0,1}?bc\", \"abc\", \"bc\");\n  assert_true_regexp(\"aa{0,1}?bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"aa{0,1}?bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"aa{0,1}bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab{1}c\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab{1,2}c\", \"abbc\", \"abbc\");\n  assert_true_regexp(\"ab{1,}c\", \"abbbc\", \"abbbc\");\n  assert_false_regexp(\"ab{1,}b\", \"ab\");\n  assert_false_regexp(\"ab{1}c\", \"abbc\");\n  assert_true_regexp(\"ab{0,}c\", \"ac\", \"ac\");\n  assert_true_regexp(\"ab{1,1}c\", \"abc\", \"abc\");\n  assert_true_regexp(\"ab{0,}c\", \"abbbc\", \"abbbc\");\n  assert_true_regexp(\"ab{,3}c\", \"abbbc\", \"abbbc\");\n  assert_false_regexp(\"ab{,2}c\", \"abbbc\");\n  assert_false_regexp(\"ab{4,5}bc\", \"abbbbc\");\n  assert_true_regexp(\"ab{0,1}\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{0,2}\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\"ab{0,3}\", \"abbbbb\", \"abbb\");\n  assert_true_regexp(\"ab{0,4}\", \"abbbbb\", \"abbbb\");\n  assert_true_regexp(\"ab{1,1}\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{1,2}\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\"ab{1,3}\", \"abbbbb\", \"abbb\");\n  assert_true_regexp(\"ab{2,2}\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\"ab{2,3}\", \"abbbbb\", \"abbb\");\n  assert_true_regexp(\"ab{1,3}?\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{0,1}?\", \"abbbbb\", \"a\");\n  assert_true_regexp(\"ab{0,2}?\", \"abbbbb\", \"a\");\n  assert_true_regexp(\"ab{0,3}?\", \"abbbbb\", \"a\");\n  assert_true_regexp(\"ab{0,4}?\", \"abbbbb\", \"a\");\n  assert_true_regexp(\"ab{1,1}?\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{1,2}?\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{1,3}?\", \"abbbbb\", \"ab\");\n  assert_true_regexp(\"ab{2,2}?\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\"ab{2,3}?\", \"abbbbb\", \"abb\");\n  assert_true_regexp(\".(abc){0,1}\", \"xabcabcabcabc\", \"xabc\");\n  assert_true_regexp(\".(abc){0,2}\", \"xabcabcabcabc\", \"xabcabc\");\n  assert_true_regexp(\"x{1,2}abcd\", \"xxxxabcd\", \"xxabcd\");\n  assert_true_regexp(\"x{1,2}abcd\", \"xxxxabcd\", \"xxabcd\");\n  assert_true_regexp(\"ab{.*}\", \"ab{c}\", \"ab{c}\");\n  assert_true_regexp(\".(aa){1,2}\", \"aaaaaaaaaa\", \"aaaaa\");\n  assert_true_regexp(\"a.(bc.){2}\", \"aabcabca\", \"aabcabca\");\n  assert_true_regexp(\"(ab{1,2}c){1,3}\", \"abbcabc\", \"abbcabc\");\n  assert_true_regexp(\"ab(c|cc){1,3}d\", \"abccccccd\", \"abccccccd\");\n  assert_true_regexp(\"a[bx]c\", \"abc\", \"abc\");\n  assert_true_regexp(\"a[bx]c\", \"axc\", \"axc\");\n  assert_true_regexp(\"a[0-9]*b\", \"ab\", \"ab\");\n  assert_true_regexp(\"a[0-9]*b\", \"a0123456789b\", \"a0123456789b\");\n  assert_true_regexp(\"[0-9a-f]+\", \"0123456789abcdef\", \"0123456789abcdef\");\n  assert_true_regexp(\"[0-9a-f]+\", \"xyz0123456789xyz\", \"0123456789\");\n  assert_true_regexp(\"a[\\\\s\\\\S]b\", \"a b\", \"a b\");\n  assert_true_regexp(\"a[\\\\d\\\\D]b\", \"a1b\", \"a1b\");\n  assert_false_regexp(\"[x-z]+\", \"abc\");\n  assert_true_regexp(\"a[-]?c\", \"ac\", \"ac\");\n  assert_true_regexp(\"a[-b]\", \"a-\", \"a-\");\n  assert_true_regexp(\"a[-b]\", \"ab\", \"ab\");\n  assert_true_regexp(\"a[b-]\", \"a-\", \"a-\");\n  assert_true_regexp(\"a[b-]\", \"ab\", \"ab\");\n  assert_true_regexp(\"[a-c-e]\", \"b\", \"b\");\n  assert_true_regexp(\"[a-c-e]\", \"-\", \"-\");\n  assert_false_regexp(\"[a-c-e]\", \"d\");\n  assert_regexp_syntax_error(\"[b-a]\");\n  assert_regexp_syntax_error(\"(abc\");\n  assert_regexp_syntax_error(\"abc)\");\n  assert_regexp_syntax_error(\"a[]b\");\n  assert_true_regexp(\"a[\\\\-b]\", \"a-\", \"a-\");\n  assert_true_regexp(\"a[\\\\-b]\", \"ab\", \"ab\");\n  assert_true_regexp(\"a]\", \"a]\", \"a]\");\n  assert_true_regexp(\"a[]]b\", \"a]b\", \"a]b\");\n  assert_true_regexp(\"a[\\\\]]b\", \"a]b\", \"a]b\");\n  assert_true_regexp(\"a[^bc]d\", \"aed\", \"aed\");\n  assert_false_regexp(\"a[^bc]d\", \"abd\");\n  assert_true_regexp(\"a[^-b]c\", \"adc\", \"adc\");\n  assert_false_regexp(\"a[^-b]c\", \"a-c\");\n  assert_false_regexp(\"a[^]b]c\", \"a]c\");\n  assert_true_regexp(\"a[^]b]c\", \"adc\", \"adc\");\n  assert_true_regexp(\"[^ab]*\", \"cde\", \"cde\");\n  assert_regexp_syntax_error(\")(\");\n  assert_true_regexp(\"a\\\\sb\", \"a b\", \"a b\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\tb\", \"a\\tb\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\rb\", \"a\\rb\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\nb\", \"a\\nb\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\vb\", \"a\\vb\");\n  assert_true_regexp(\"a\\\\sb\", \"a\\fb\", \"a\\fb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a b\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\tb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\rb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\nb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\vb\");\n  assert_false_regexp(\"a\\\\Sb\", \"a\\fb\");\n  assert_true_regexp(\"\\\\n\\\\r\\\\t\\\\f\\\\a\", \"\\n\\r\\t\\f\\a\", \"\\n\\r\\t\\f\\a\");\n  assert_true_regexp(\"[\\\\n][\\\\r][\\\\t][\\\\f][\\\\a]\", \"\\n\\r\\t\\f\\a\", \"\\n\\r\\t\\f\\a\");\n  assert_true_regexp(\"\\\\x01\\\\x02\\\\x03\", \"\\x01\\x02\\x03\", \"\\x01\\x02\\x03\");\n  assert_true_regexp(\"[\\\\x01-\\\\x03]+\", \"\\x01\\x02\\x03\", \"\\x01\\x02\\x03\");\n  assert_false_regexp(\"[\\\\x00-\\\\x02]+\", \"\\x03\\x04\\x05\");\n  assert_true_regexp(\"[\\\\x5D]\", \"]\", \"]\");\n  assert_true_regexp(\"[\\\\0x5A-\\\\x5D]\", \"\\x5B\", \"\\x5B\");\n  assert_true_regexp(\"[\\\\x5D-\\\\x5F]\", \"\\x5E\", \"\\x5E\");\n  assert_true_regexp(\"[\\\\x5C-\\\\x5F]\", \"\\x5E\", \"\\x5E\");\n  assert_true_regexp(\"[\\\\x5D-\\\\x5F]\", \"\\x5E\", \"\\x5E\");\n  assert_true_regexp(\"a\\\\wc\", \"abc\", \"abc\");\n  assert_true_regexp(\"a\\\\wc\", \"a_c\", \"a_c\");\n  assert_true_regexp(\"a\\\\wc\", \"a0c\", \"a0c\");\n  assert_false_regexp(\"a\\\\wc\", \"a*c\");\n  assert_true_regexp(\"\\\\w+\", \"--ab_cd0123--\", \"ab_cd0123\");\n  assert_true_regexp(\"[\\\\w]+\", \"--ab_cd0123--\", \"ab_cd0123\");\n  assert_true_regexp(\"\\\\D+\", \"1234abc5678\", \"abc\");\n  assert_true_regexp(\"[\\\\d]+\", \"0123456789\", \"0123456789\");\n  assert_true_regexp(\"[\\\\D]+\", \"1234abc5678\", \"abc\");\n  assert_true_regexp(\"[\\\\da-fA-F]+\", \"123abc\", \"123abc\");\n  assert_false_regexp(\"^(ab|cd)e\", \"abcde\");\n  assert_true_regexp(\"(abc|)ef\", \"abcdef\", \"ef\");\n  assert_true_regexp(\"(abc|)ef\", \"abcef\", \"abcef\");\n  assert_true_regexp(\"\\\\babc\", \"abc\", \"abc\");\n  assert_true_regexp(\"abc\\\\b\", \"abc\", \"abc\");\n  assert_false_regexp(\"\\\\babc\", \"1abc\");\n  assert_false_regexp(\"abc\\\\b\", \"abc1\");\n  assert_true_regexp(\"abc\\\\s\\\\b\", \"abc x\", \"abc \");\n  assert_false_regexp(\"abc\\\\s\\\\b\", \"abc  \");\n  assert_true_regexp(\"\\\\babc\\\\b\", \" abc \", \"abc\");\n  assert_true_regexp(\"\\\\b\\\\w\\\\w\\\\w\\\\b\", \" abc \", \"abc\");\n  assert_true_regexp(\"\\\\w\\\\w\\\\w\\\\b\", \"abcd\", \"bcd\");\n  assert_true_regexp(\"\\\\b\\\\w\\\\w\\\\w\", \"abcd\", \"abc\");\n  assert_false_regexp(\"\\\\b\\\\w\\\\w\\\\w\\\\b\", \"abcd\");\n  assert_false_regexp(\"\\\\Babc\", \"abc\");\n  assert_false_regexp(\"abc\\\\B\", \"abc\");\n  assert_true_regexp(\"\\\\Babc\", \"1abc\", \"abc\");\n  assert_true_regexp(\"abc\\\\B\", \"abc1\", \"abc\");\n  assert_false_regexp(\"abc\\\\s\\\\B\", \"abc x\");\n  assert_true_regexp(\"abc\\\\s\\\\B\", \"abc  \", \"abc \");\n  assert_true_regexp(\"\\\\w\\\\w\\\\w\\\\B\", \"abcd\", \"abc\");\n  assert_true_regexp(\"\\\\B\\\\w\\\\w\\\\w\", \"abcd\", \"bcd\");\n  assert_false_regexp(\"\\\\B\\\\w\\\\w\\\\w\\\\B\", \"abcd\");\n\n  // This is allowed in most regexp engines but in order to keep the\n  // grammar free of shift/reduce conflicts I've decided not supporting\n  // it. Users can use the (abc|) form instead.\n  assert_regexp_syntax_error(\"(|abc)ef\");\n\n  assert_true_regexp(\"((a)(b)c)(d)\", \"abcd\", \"abcd\");\n  assert_true_regexp(\"(a|b)c*d\", \"abcd\", \"bcd\");\n  assert_true_regexp(\"(ab|ab*)bc\", \"abc\", \"abc\");\n  assert_true_regexp(\"a([bc]*)c*\", \"abc\", \"abc\");\n  assert_true_regexp(\"a([bc]*)c*\", \"ac\", \"ac\");\n  assert_true_regexp(\"a([bc]*)c*\", \"a\", \"a\");\n  assert_true_regexp(\"a([bc]*)(c*d)\", \"abcd\", \"abcd\");\n  assert_true_regexp(\"a([bc]+)(c*d)\", \"abcd\", \"abcd\");\n  assert_true_regexp(\"a([bc]*)(c+d)\", \"abcd\", \"abcd\");\n  assert_true_regexp(\"a[bcd]*dcdcde\", \"adcdcde\", \"adcdcde\");\n  assert_false_regexp(\"a[bcd]+dcdcde\", \"adcdcde\");\n  assert_true_regexp(\"\\\\((.*), (.*)\\\\)\", \"(a, b)\", \"(a, b)\");\n  assert_true_regexp(\"abc|123$\", \"abcx\", \"abc\");\n  assert_false_regexp(\"abc|123$\", \"123x\");\n  assert_true_regexp(\"abc|^123\", \"123\", \"123\");\n  assert_false_regexp(\"abc|^123\", \"x123\");\n  assert_true_regexp(\"^abc$\", \"abc\", \"abc\");\n  assert_false_regexp(\"^abc$\", \"abcc\");\n  assert_true_regexp(\"^abc\", \"abcc\", \"abc\");\n  assert_false_regexp(\"^abc$\", \"aabc\");\n  assert_false_regexp(\"abc^\", \"abc\");\n  assert_false_regexp(\"ab^c\", \"abc\");\n  assert_false_regexp(\"a^bcdef\", \"abcdef\")\n  assert_true_regexp(\"abc$\", \"aabc\", \"abc\");\n  assert_false_regexp(\"$abc\", \"abc\");\n  assert_true_regexp(\"(a|a$)bcd\", \"abcd\", \"abcd\");\n  assert_false_regexp(\"(a$|a$)bcd\", \"abcd\");\n  assert_false_regexp(\"(abc$|ab$)\", \"abcd\");\n  assert_true_regexp(\"^a(bc+|b[eh])g|.h$\", \"abhg\", \"abhg\");\n  assert_true_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"effgz\", \"effgz\");\n  assert_true_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"ij\", \"ij\");\n  assert_false_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"effg\");\n  assert_false_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"bcdd\");\n  assert_true_regexp(\"(bc+d$|ef*g.|h?i(j|k))\", \"reffgz\", \"effgz\");\n\n  // Test case for issue #324\n  assert_true_regexp(\"whatever|   x.   x\", \"   xy   x\", \"   xy   x\");\n\n  // test case for issue #503, \\x without two following hex-digits\n  assert_regexp_syntax_error(\"\\\\x0\");\n  assert_regexp_syntax_error(\"\\\\x\");\n\n  assert_regexp_syntax_error(\"x{0,0}\");\n  assert_regexp_syntax_error(\"x{0}\");\n\n  assert_regexp_syntax_error(\"\\\\xxy\");\n\n  assert_error(\n      \"rule test { strings: $a = /a\\\\/ condition: $a }\",\n      ERROR_SYNTAX_ERROR);\n\n  assert_error(\n      \"rule test { strings: $a = /[a\\\\/ condition: $a }\",\n      ERROR_SYNTAX_ERROR);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = /MZ.{300,}t/ \\\n        condition: !a == 317 }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = /MZ.{300,}?t/ \\\n        condition: !a == 314 }\",\n      PE32_FILE);\n}\n\n\nstatic void test_entrypoint()\n{\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { 6a 2a 58 c3 } \\\n        condition: $a at entrypoint }\",\n      PE32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { b8 01 00 00 00 bb 2a } \\\n        condition: $a at entrypoint }\",\n      ELF32_FILE);\n\n  assert_true_rule_blob(\n      \"rule test { \\\n        strings: $a = { b8 01 00 00 00 bb 2a } \\\n        condition: $a at entrypoint }\",\n      ELF64_FILE);\n\n  assert_false_rule(\n      \"rule test { condition: entrypoint >= 0 }\",\n      NULL);\n}\n\n\nstatic void test_filesize()\n{\n  char rule[80];\n\n  snprintf(\n      rule,\n      sizeof(rule),\n      \"rule test { condition: filesize == %zd }\",\n      sizeof(PE32_FILE));\n\n  assert_true_rule_blob(\n      rule,\n      PE32_FILE);\n}\n\n\nstatic void test_comments()\n{\n  assert_true_rule(\n      \"rule test {\\n\\\n         condition:\\n\\\n             //  this is a comment\\n\\\n             /*** this is a comment ***/\\n\\\n             /* /* /*\\n\\\n                 this is a comment\\n\\\n             */\\n\\\n             true\\n\\\n      }\",\n      NULL);\n}\n\nstatic void test_matches_operator()\n{\n  assert_true_rule(\n      \"rule test { condition: \\\"foo\\\" matches /foo/ }\",\n      NULL);\n\n  assert_false_rule(\n      \"rule test { condition: \\\"foo\\\" matches /bar/ }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { condition: \\\"FoO\\\" matches /fOo/i }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { condition: \\\"xxFoOxx\\\" matches /fOo/i }\",\n      NULL);\n\n  assert_false_rule(\n      \"rule test { condition: \\\"xxFoOxx\\\" matches /^fOo/i }\",\n      NULL);\n\n  assert_false_rule(\n      \"rule test { condition: \\\"xxFoOxx\\\" matches /fOo$/i }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { condition: \\\"foo\\\" matches /^foo$/i }\",\n      NULL);\n\n  assert_true_rule(\n      \"rule test { condition: \\\"foo\\\\nbar\\\" matches /foo.*bar/s }\",\n      NULL);\n\n  assert_false_rule(\n      \"rule test { condition: \\\"foo\\\\nbar\\\" matches /foo.*bar/ }\",\n      NULL);\n}\n\n\nstatic void test_global_rules()\n{\n  assert_true_rule(\n      \"global private rule global_rule { \\\n        condition: \\\n          true \\\n      } \\\n      rule test { \\\n        condition: true \\\n      }\",\n      NULL);\n\n  assert_false_rule(\n      \"global private rule global_rule { \\\n        condition: \\\n          false \\\n      } \\\n      rule test { \\\n        condition: true \\\n      }\",\n      NULL);\n}\n\n\nstatic void test_modules()\n{\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.constants.one + 1 == tests.constants.two \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.constants.foo == \\\"foo\\\" \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.constants.empty == \\\"\\\"  \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.empty() == \\\"\\\"  \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.struct_array[1].i == 1  \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.struct_array[0].i == 1 or true \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.integer_array[0] == 0 \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.integer_array[1] == 1 \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.string_array[0] == \\\"foo\\\" \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.string_array[2] == \\\"baz\\\" \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.string_dict[\\\"foo\\\"] == \\\"foo\\\" \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.string_dict[\\\"bar\\\"] == \\\"bar\\\" \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.isum(1,2) == 3 \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.isum(1,2,3) == 6 \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.fsum(1.0,2.0) == 3.0 \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.fsum(1.0,2.0,3.0) == 6.0 \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n       rule test { \\\n        condition: tests.length(\\\"dummy\\\") == 5 \\\n      }\",\n      NULL);\n\n\n  assert_false_rule(\n      \"import \\\"tests\\\" \\\n      rule test { condition: tests.struct_array[0].i == 1  \\\n      }\",\n      NULL);\n\n  assert_false_rule(\n      \"import \\\"tests\\\" \\\n      rule test { condition: tests.isum(1,1) == 3 \\\n      }\",\n      NULL);\n\n  assert_false_rule(\n      \"import \\\"tests\\\" \\\n      rule test { condition: tests.fsum(1.0,1.0) == 3.0 \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n      rule test { condition: tests.match(/foo/,\\\"foo\\\") == 3 \\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n      rule test { condition: tests.match(/foo/,\\\"bar\\\") == -1\\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n      rule test { condition: tests.match(/foo.bar/i,\\\"FOO\\\\nBAR\\\") == -1\\\n      }\",\n      NULL);\n\n  assert_true_rule(\n      \"import \\\"tests\\\" \\\n      rule test { condition: tests.match(/foo.bar/is,\\\"FOO\\\\nBAR\\\") == 7\\\n      }\",\n      NULL);\n\n  assert_error(\n      \"import \\\"\\\\x00\\\"\",\n      ERROR_INVALID_MODULE_NAME);\n\n  assert_error(\n      \"import \\\"\\\"\",\n      ERROR_INVALID_MODULE_NAME);\n}\n\n#if defined(HASH_MODULE)\nstatic void test_hash_module()\n{\n  uint8_t blob[] = {0x61, 0x62, 0x63, 0x64, 0x65};\n\n  assert_true_rule_blob(\n      \"import \\\"hash\\\" \\\n       rule test { \\\n        condition: \\\n          hash.md5(0, filesize) == \\\n            \\\"ab56b4d92b40713acc5af89985d4b786\\\" \\\n            and \\\n          hash.md5(1, filesize) == \\\n            \\\"e02cfbe5502b64aa5ae9f2d0d69eaa8d\\\" \\\n            and \\\n          hash.sha1(0, filesize) == \\\n            \\\"03de6c570bfe24bfc328ccd7ca46b76eadaf4334\\\" \\\n            and \\\n          hash.sha1(1, filesize) == \\\n            \\\"a302d65ae4d9e768a1538d53605f203fd8e2d6e2\\\" \\\n            and \\\n          hash.sha256(0, filesize) == \\\n            \\\"36bbe50ed96841d10443bcb670d6554f0a34b761be67ec9c4a8ad2c0c44ca42c\\\" \\\n            and \\\n          hash.sha256(1, filesize) == \\\n            \\\"aaaaf2863e043b9df604158ad5c16ff1adaf3fd7e9fcea5dcb322b6762b3b59a\\\" \\\n      }\",\n      blob);\n\n  // Test hash caching mechanism\n\n  assert_true_rule_blob(\n      \"import \\\"hash\\\" \\\n       rule test { \\\n        condition: \\\n          hash.md5(0, filesize) == \\\n            \\\"ab56b4d92b40713acc5af89985d4b786\\\" \\\n            and \\\n          hash.md5(1, filesize) == \\\n            \\\"e02cfbe5502b64aa5ae9f2d0d69eaa8d\\\" \\\n            and \\\n          hash.md5(0, filesize) == \\\n            \\\"ab56b4d92b40713acc5af89985d4b786\\\" \\\n            and \\\n          hash.md5(1, filesize) == \\\n            \\\"e02cfbe5502b64aa5ae9f2d0d69eaa8d\\\" \\\n      }\",\n      blob);\n}\n#endif\n\n\nvoid test_integer_functions()\n{\n  assert_true_rule(\n      \"rule test { condition: uint8(0) == 0xAA}\",\n      \"\\xaa\\xbb\\xcc\\xdd\");\n\n  assert_true_rule(\n      \"rule test { condition: uint16(0) == 0xBBAA}\",\n      \"\\xaa\\xbb\\xcc\\xdd\");\n\n  assert_true_rule(\n      \"rule test { condition: uint32(0) == 0xDDCCBBAA}\",\n      \"\\xaa\\xbb\\xcc\\xdd\");\n\n  assert_true_rule(\n      \"rule test { condition: uint8be(0) == 0xAA}\",\n      \"\\xaa\\xbb\\xcc\\xdd\");\n\n  assert_true_rule(\n      \"rule test { condition: uint16be(0) == 0xAABB}\",\n      \"\\xaa\\xbb\\xcc\\xdd\");\n\n  assert_true_rule(\n      \"rule test { condition: uint32be(0) == 0xAABBCCDD}\",\n      \"\\xaa\\xbb\\xcc\\xdd\");\n}\n\n\nvoid test_file_descriptor()\n{\n  YR_COMPILER* compiler = NULL;\n  YR_RULES* rules = NULL;\n\n#if defined(_WIN32) || defined(__CYGWIN__)\n  HANDLE fd = CreateFile(\"tests/data/true.yar\", GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);\n  if (fd == INVALID_HANDLE_VALUE)\n  {\n    fputs(\"CreateFile failed\", stderr);\n    exit(1);\n  }\n#else\n  int fd = open(\"tests/data/true.yar\", O_RDONLY);\n  if (fd < 0)\n  {\n    perror(\"open\");\n    exit(EXIT_FAILURE);\n  }\n#endif\n  if (yr_compiler_create(&compiler) != ERROR_SUCCESS)\n  {\n    perror(\"yr_compiler_create\");\n    exit(EXIT_FAILURE);\n  }\n\n  if (yr_compiler_add_fd(compiler, fd, NULL, NULL) != 0) {\n    perror(\"yr_compiler_add_fd\");\n    exit(EXIT_FAILURE);\n  }\n\n#if defined(_WIN32) || defined(__CYGWIN__)\n  CloseHandle(fd);\n#else\n  close(fd);\n#endif\n\n  if (yr_compiler_get_rules(compiler, &rules) != ERROR_SUCCESS) {\n    perror(\"yr_compiler_add_fd\");\n    exit(EXIT_FAILURE);\n  }\n\n  if (compiler)\n  {\n    yr_compiler_destroy(compiler);\n  }\n  if (rules)\n  {\n    yr_rules_destroy(rules);\n  }\n\n  return;\n}\n\n\nint main(int argc, char** argv)\n{\n  yr_initialize();\n\n  test_boolean_operators();\n  test_comparison_operators();\n  test_arithmetic_operators();\n  test_bitwise_operators();\n  test_matches_operator();\n  test_syntax();\n  test_anonymous_strings();\n  test_strings();\n  test_wildcard_strings();\n  test_hex_strings();\n  test_count();\n  test_at();\n  test_in();\n  test_offset();\n  test_length();\n  test_of();\n  test_for();\n  test_re();\n  test_filesize();\n  // test_compile_file();\n  // test_compile_files();\n  // test_include_files();\n  // test_externals();\n  // test_callback();\n  // test_compare();\n  test_comments();\n  test_modules();\n  test_integer_functions();\n  // test_string_io();\n  test_entrypoint();\n  test_global_rules();\n\n  #if defined(HASH_MODULE)\n  test_hash_module();\n  #endif\n\n  test_file_descriptor();\n\n  yr_finalize();\n\n  return 0;\n}\n"], "filenames": ["libyara/exec.c", "libyara/include/yara/re.h", "libyara/re.c", "libyara/scan.c", "tests/test-rules.c"], "buggy_code_start_loc": [852, 97, 142, 531, 902], "buggy_code_end_loc": [852, 226, 2191, 618, 902], "fixing_code_start_loc": [853, 96, 143, 531, 903], "fixing_code_end_loc": [854, 219, 2239, 623, 947], "type": "CWE-125", "message": "libyara/re.c in the regex component in YARA 3.5.0 allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via a crafted rule that is mishandled in the yr_re_exec function.", "other": {"cve": {"id": "CVE-2017-8294", "sourceIdentifier": "cve@mitre.org", "published": "2017-04-27T14:59:00.310", "lastModified": "2017-05-03T12:21:47.400", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "libyara/re.c in the regex component in YARA 3.5.0 allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via a crafted rule that is mishandled in the yr_re_exec function."}, {"lang": "es", "value": "libyara/re.c en el componente regex de YARA 3.5.0 permite a atacantes remotos provocar una denegaci\u00f3n de servicio (lectura fuera de l\u00edmites y ca\u00edda de la aplicaci\u00f3n) a trav\u00e9s de una regla manipulada que es mal gestionada en yr_re_exec function."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:virustotal:yara:3.5.0:*:*:*:*:*:*:*", "matchCriteriaId": "0254F781-4B89-4557-8F17-1F228A3A8216"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/98072", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/VirusTotal/yara/commit/83d799804648c2a0895d40a19835d9b757c6fa4e", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/VirusTotal/yara/issues/646", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}]}, "github_commit_url": "https://github.com/VirusTotal/yara/commit/83d799804648c2a0895d40a19835d9b757c6fa4e"}}