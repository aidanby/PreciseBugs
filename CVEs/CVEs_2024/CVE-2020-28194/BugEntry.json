{"buggy_code": ["#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/mman.h>\n#include <linux/mman.h>\n#include <arpa/inet.h>\n\n#include \"log.h\"\n#include \"mempool.h\"\n\n#include \"radius_p.h\"\n\n#include \"memdebug.h\"\n\nstatic mempool_t packet_pool;\nstatic mempool_t attr_pool;\nstatic mempool_t buf_pool;\n\nstruct rad_packet_t *rad_packet_alloc(int code)\n{\n\tstruct rad_packet_t *pack;\n\n\tpack = mempool_alloc(packet_pool);\n\tif (!pack) {\n\t\tlog_emerg(\"radius:packet: out of memory\\n\");\n\t\treturn NULL;\n\t}\n\n\tmemset(pack, 0, sizeof(*pack));\n\tpack->code = code;\n\tpack->len = 20;\n\tpack->id = 1;\n\tINIT_LIST_HEAD(&pack->attrs);\n\n\treturn pack;\n}\n\nvoid print_buf(uint8_t *buf,int size)\n{\n\tint i;\n\tfor(i=0;i<size;i++)\n\t\tprintf(\"%x \",buf[i]);\n\tprintf(\"\\n\");\n}\n\nint rad_packet_build(struct rad_packet_t *pack, uint8_t *RA)\n{\n\tstruct rad_attr_t *attr;\n\tuint8_t *ptr;\n\n\tif (!pack->buf) {\n\t\t//ptr = mmap(NULL, REQ_LENGTH_MAX, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0);\n\t\tptr = mempool_alloc(buf_pool);\n\n\t\t//if (ptr == MAP_FAILED) {\n\t\tif (!ptr) {\n\t\t\tlog_emerg(\"radius:packet: out of memory\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tpack->buf = ptr;\n\t} else\n\t\tptr = pack->buf;\n\n\t*ptr = pack->code; ptr++;\n\t*ptr = pack->id; ptr++;\n\t*(uint16_t*)ptr = htons(pack->len); ptr+= 2;\n\tmemcpy(ptr, RA, 16);\tptr+=16;\n\n\tlist_for_each_entry(attr, &pack->attrs, entry) {\n\t\tif (attr->vendor) {\n\t\t\t*ptr = 26; ptr++;\n\t\t\t*ptr = attr->len + 2 + 6; ptr++;\n\t\t\t*(uint32_t *)ptr = htonl(attr->vendor->id); ptr+=4;\n\t\t}\n\t\t*ptr = attr->attr->id; ptr++;\n\t\t*ptr = attr->len + 2; ptr++;\n\t\tswitch(attr->attr->type) {\n\t\t\tcase ATTR_TYPE_INTEGER:\n\t\t\t\t*(uint32_t*)ptr = htonl(attr->val.integer);\n\t\t\t\tbreak;\n\t\t\tcase ATTR_TYPE_OCTETS:\n\t\t\tcase ATTR_TYPE_STRING:\n\t\t\t\tmemcpy(ptr, attr->val.string, attr->len);\n\t\t\t\tbreak;\n\t\t\tcase ATTR_TYPE_IPADDR:\n\t\t\tcase ATTR_TYPE_IFID:\n\t\t\tcase ATTR_TYPE_IPV6ADDR:\n\t\t\t\tmemcpy(ptr, &attr->val, attr->len);\n\t\t\t\tbreak;\n\t\t\tcase ATTR_TYPE_DATE:\n\t\t\t\t*(uint32_t*)ptr = htonl(attr->val.date);\n\t\t\t\tbreak;\n\t\t\tcase ATTR_TYPE_IPV6PREFIX:\n\t\t\t\tptr[0] = 0;\n\t\t\t\tptr[1] = attr->val.ipv6prefix.len;\n\t\t\t\tmemcpy(ptr + 2, &attr->val.ipv6prefix.prefix, sizeof(attr->val.ipv6prefix.prefix));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tlog_emerg(\"radius:packet:BUG: unknown attribute type\\n\");\n\t\t\t\tabort();\n\t\t}\n\t\tptr += attr->len;\n\t}\n\n\t//print_buf(pack->buf, pack->len);\n\treturn 0;\n}\n\nint rad_packet_recv(int fd, struct rad_packet_t **p, struct sockaddr_in *addr)\n{\n\tstruct rad_packet_t *pack;\n\tstruct rad_attr_t *attr;\n\tstruct rad_dict_attr_t *da;\n\tstruct rad_dict_vendor_t *vendor;\n\tuint8_t *ptr;\n\tint n, id, len, vendor_id;\n\tsocklen_t addr_len = sizeof(*addr);\n\n\t*p = NULL;\n\n\tpack = rad_packet_alloc(0);\n\tif (!pack)\n\t\treturn 0;\n\n\t//ptr = mmap(NULL, REQ_LENGTH_MAX, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0);\n\tptr = mempool_alloc(buf_pool);\n\tif (ptr == MAP_FAILED) {\n\t\tlog_emerg(\"radius:packet: out of memory\\n\");\n\t\tgoto out_err;\n\t}\n\n\tpack->buf = ptr;\n\tclock_gettime(CLOCK_MONOTONIC, &pack->tv);\n\n\twhile (1) {\n\t\tif (addr)\n\t\t\tn = recvfrom(fd, pack->buf, REQ_LENGTH_MAX, 0, addr, &addr_len);\n\t\telse\n\t\t\tn = read(fd, pack->buf, REQ_LENGTH_MAX);\n\t\tif (n < 0) {\n\t\t\trad_packet_free(pack);\n\t\t\tif (errno == EAGAIN)\n\t\t\t\treturn 1;\n\n\t\t\tif (errno != ECONNREFUSED)\n\t\t\t\tlog_ppp_error(\"radius:packet:read: %s\\n\", strerror(errno));\n\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (n < 20) {\n\t\tlog_ppp_warn(\"radius:packet: short packed received (%i)\\n\", n);\n\t\tgoto out_err;\n\t}\n\n\tpack->code = *ptr; ptr++;\n\tpack->id = *ptr; ptr++;\n\tpack->len = ntohs(*(uint16_t*)ptr); ptr += 2;\n\n\tif (pack->len > n) {\n\t\tlog_ppp_warn(\"radius:packet: short packet received %i, expected %i\\n\", pack->len, n);\n\t\tgoto out_err;\n\t}\n\n\tptr += 16;\n\tn -= 20;\n\n\twhile (n>0) {\n\t\tid = *ptr; ptr++;\n\t\tlen = *ptr - 2; ptr++;\n\t\tif (len < 0) {\n\t\t\tlog_ppp_warn(\"radius:packet short attribute len received\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t\tif (2 + len > n) {\n\t\t\tlog_ppp_warn(\"radius:packet: too long attribute received (%i, %i)\\n\", id, len);\n\t\t\tgoto out_err;\n\t\t}\n\t\tif (id == 26) {\n\t\t\tvendor_id = ntohl(*(uint32_t *)ptr);\n\t\t\tvendor = rad_dict_find_vendor_id(vendor_id);\n\t\t\tif (vendor) {\n\t\t\t\tptr += 4;\n\n\t\t\t\tif (vendor->tag == 2)\n\t\t\t\t\tid = (uint16_t)ntohs(*(uint16_t *)ptr);\n\t\t\t\telse\n\t\t\t\t\tid = *ptr;\n\n\t\t\t\tptr += vendor->tag;\n\n\t\t\t\tif (vendor->len == 2)\n\t\t\t\t\tlen = (uint16_t)ntohs(*(uint16_t *)ptr);\n\t\t\t\telse\n\t\t\t\t\tlen = *ptr;\n\n\t\t\t\tptr += vendor->len;\n\n\t\t\t\tlen -= vendor->tag + vendor->len;\n\n\t\t\t\tn -= 4 + vendor->tag + vendor->len;\n\t\t\t} else\n\t\t\t\tlog_ppp_warn(\"radius:packet: vendor %i not found\\n\", id);\n\t\t} else\n\t\t\tvendor = NULL;\n\t\tda = rad_dict_find_attr_id(vendor, id);\n\t\tif (da) {\n\t\t\tattr = mempool_alloc(attr_pool);\n\t\t\tif (!attr) {\n\t\t\t\tlog_emerg(\"radius:packet: out of memory\\n\");\n\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t\tmemset(attr, 0, sizeof(*attr));\n\t\t\tattr->vendor = vendor;\n\t\t\tattr->attr = da;\n\t\t\tattr->len = len;\n\t\t\tattr->raw = ptr;\n\n\t\t\tif (!da->array) {\n\t\t\t\tswitch (da->type) {\n\t\t\t\t\tcase ATTR_TYPE_STRING:\n\t\t\t\t\t\tattr->alloc = 1;\n\t\t\t\t\t\tattr->val.string = _malloc(len + 1);\n\t\t\t\t\t\tmemcpy(attr->val.string, ptr, len);\n\t\t\t\t\t\tattr->val.string[len] = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ATTR_TYPE_OCTETS:\n\t\t\t\t\tcase ATTR_TYPE_ETHER:\n\t\t\t\t\tcase ATTR_TYPE_TLV:\n\t\t\t\t\t\tattr->val.octets = ptr;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ATTR_TYPE_INTEGER:\n\t\t\t\t\t\tif (len != da->size)\n\t\t\t\t\t\t\tlog_ppp_warn(\"radius:packet: attribute %s has invalid length %i (must be %i)\\n\", da->name, len, da->size);\n\t\t\t\t\tcase ATTR_TYPE_DATE:\n\t\t\t\t\t\tif (len == 4)\n\t\t\t\t\t\t\tattr->val.integer = ntohl(*(uint32_t*)ptr);\n\t\t\t\t\t\telse if (len == 2)\n\t\t\t\t\t\t\tattr->val.integer = ntohs(*(uint16_t*)ptr);\n\t\t\t\t\t\telse if (len == 1)\n\t\t\t\t\t\t\tattr->val.integer = *ptr;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ATTR_TYPE_IPADDR:\n\t\t\t\t\tcase ATTR_TYPE_IFID:\n\t\t\t\t\tcase ATTR_TYPE_IPV6ADDR:\n\t\t\t\t\t\tmemcpy(&attr->val.integer, ptr, len);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ATTR_TYPE_IPV6PREFIX:\n\t\t\t\t\t\tattr->val.ipv6prefix.len = ptr[1];\n\t\t\t\t\t\tmemset(&attr->val.ipv6prefix.prefix, 0, sizeof(attr->val.ipv6prefix.prefix));\n\t\t\t\t\t\tmemcpy(&attr->val.ipv6prefix.prefix, ptr + 2, len - 2);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlist_add_tail(&attr->entry, &pack->attrs);\n\t\t} else\n\t\t\tlog_ppp_warn(\"radius:packet: unknown attribute received (%i,%i)\\n\", vendor ? vendor->id : 0, id);\n\t\tptr += len;\n\t\tn -= 2 + len;\n\t}\n\n\t*p = pack;\n\n\treturn 0;\n\nout_err:\n\trad_packet_free(pack);\n\treturn 1;\n}\n\nvoid rad_packet_free(struct rad_packet_t *pack)\n{\n\tstruct rad_attr_t *attr;\n\n\tif (pack->buf)\n\t\tmempool_free(pack->buf);\n\t\t//munmap(pack->buf, REQ_LENGTH_MAX);\n\n\twhile(!list_empty(&pack->attrs)) {\n\t\tattr = list_entry(pack->attrs.next, typeof(*attr), entry);\n\t\tlist_del(&attr->entry);\n\t\tif (attr->alloc)\n\t\t\t_free(attr->val.string);\n\t\tmempool_free(attr);\n\t}\n\n\tmempool_free(pack);\n}\n\nstatic void print_octets(uint8_t *raw, int len, void (*print)(const char *fmt, ...))\n{\n\tprint(\" 0x\");\n\twhile (len--)\n\t\tprint(\"%02x\", *raw++);\n}\n\nvoid rad_packet_print(struct rad_packet_t *pack, struct rad_server_t *s, void (*print)(const char *fmt, ...))\n{\n\tstruct rad_attr_t *attr;\n\tstruct rad_dict_value_t *val;\n\tchar ip_str[50];\n\tunion {\n\t\tuint64_t ifid;\n\t\tuint16_t u16[4];\n\t} ifid_u;\n\tin_addr_t addr;\n\n\tif (s)\n\t\tprint(\"[RADIUS(%i) \", s->id);\n\telse\n\t\tprint(\"[RADIUS \");\n\n\tswitch(pack->code) {\n\t\tcase CODE_ACCESS_REQUEST:\n\t\t\tprint(\"Access-Request\");\n\t\t\tbreak;\n\t\tcase CODE_ACCESS_CHALLENGE:\n\t\t\tprint(\"Access-Challenge\");\n\t\t\tbreak;\n\t\tcase CODE_ACCESS_ACCEPT:\n\t\t\tprint(\"Access-Accept\");\n\t\t\tbreak;\n\t\tcase CODE_ACCESS_REJECT:\n\t\t\tprint(\"Access-Reject\");\n\t\t\tbreak;\n\t\tcase CODE_ACCOUNTING_REQUEST:\n\t\t\tprint(\"Accounting-Request\");\n\t\t\tbreak;\n\t\tcase CODE_ACCOUNTING_RESPONSE:\n\t\t\tprint(\"Accounting-Response\");\n\t\t\tbreak;\n\t\tcase CODE_DISCONNECT_REQUEST:\n\t\t\tprint(\"Disconnect-Request\");\n\t\t\tbreak;\n\t\tcase CODE_DISCONNECT_ACK:\n\t\t\tprint(\"Disconnect-ACK\");\n\t\t\tbreak;\n\t\tcase CODE_DISCONNECT_NAK:\n\t\t\tprint(\"Disconnect-NAK\");\n\t\t\tbreak;\n\t\tcase CODE_COA_REQUEST:\n\t\t\tprint(\"CoA-Request\");\n\t\t\tbreak;\n\t\tcase CODE_COA_ACK:\n\t\t\tprint(\"CoA-ACK\");\n\t\t\tbreak;\n\t\tcase CODE_COA_NAK:\n\t\t\tprint(\"CoA-NAK\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprint(\"Unknown (%i)\", pack->code);\n\t}\n\n\tprint(\" id=%x\", pack->id);\n\n\tlist_for_each_entry(attr, &pack->attrs, entry) {\n\t\tprint(\" <%s\", attr->attr->name);\n\n\t\tif (attr->attr->array)\n\t\t\tprint_octets(attr->raw, attr->len, print);\n\t\telse {\n\t\t\tswitch (attr->attr->type) {\n\t\t\t\tcase ATTR_TYPE_INTEGER:\n\t\t\t\t\tval = rad_dict_find_val(attr->attr, attr->val);\n\t\t\t\t\tif (val)\n\t\t\t\t\t\tprint(\" %s\", val->name);\n\t\t\t\t\telse\n\t\t\t\t\t\tprint(\" %u\", attr->val.integer);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_TYPE_STRING:\n\t\t\t\t\tprint(\" \\\"%s\\\"\", attr->val.string);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_TYPE_IPADDR:\n\t\t\t\t\taddr = ntohl(attr->val.ipaddr);\n\t\t\t\t\tprint(\" %i.%i.%i.%i\", (addr >> 24) & 0xff, (addr >> 16) & 0xff, (addr >> 8) & 0xff, addr & 0xff);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_TYPE_IFID:\n\t\t\t\t\tifid_u.ifid = attr->val.ifid;\n\t\t\t\t\tprint(\" %x:%x:%x:%x\", ntohs(ifid_u.u16[0]), ntohs(ifid_u.u16[1]), ntohs(ifid_u.u16[2]), ntohs(ifid_u.u16[3]));\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_TYPE_IPV6ADDR:\n\t\t\t\t\tinet_ntop(AF_INET6, &attr->val.ipv6addr, ip_str, sizeof(ip_str));\n\t\t\t\t\tprint(\" %s\", ip_str);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_TYPE_IPV6PREFIX:\n\t\t\t\t\tinet_ntop(AF_INET6, &attr->val.ipv6prefix.prefix, ip_str, sizeof(ip_str));\n\t\t\t\t\tprint(\" %s/%i\", ip_str, attr->val.ipv6prefix.len);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tprint_octets(attr->raw, attr->len, print);\n\t\t\t}\n\t\t}\n\n\t\tprint(\">\");\n\t}\n\n\tprint(\"]\\n\");\n}\n\nint __export rad_packet_add_int(struct rad_packet_t *pack, const char *vendor_name, const char *name, int val)\n{\n\tstruct rad_attr_t *ra;\n\tstruct rad_dict_attr_t *attr;\n\tstruct rad_dict_vendor_t *vendor;\n\n\tif (pack->len + (vendor_name ? 8 : 2) + 4 >= REQ_LENGTH_MAX)\n\t\treturn -1;\n\n\tif (vendor_name) {\n\t\tvendor = rad_dict_find_vendor_name(vendor_name);\n\t\tif (!vendor)\n\t\t\treturn -1;\n\t\tattr = rad_dict_find_vendor_attr(vendor, name);\n\t} else {\n\t\tvendor = NULL;\n\t\tattr = rad_dict_find_attr(name);\n\t}\n\n\tif (!attr)\n\t\treturn -1;\n\n\tra = mempool_alloc(attr_pool);\n\tif (!ra)\n\t\treturn -1;\n\n\tmemset(ra, 0, sizeof(*ra));\n\tra->vendor = vendor;\n\tra->attr = attr;\n\tra->len = 4;\n\tra->val.integer = val;\n\tra->raw = &ra->val;\n\tlist_add_tail(&ra->entry, &pack->attrs);\n\tpack->len += (vendor_name ? 8 : 2) + 4;\n\n\treturn 0;\n}\n\nint __export rad_packet_change_int(struct rad_packet_t *pack, const char *vendor_name, const char *name, int val)\n{\n\tstruct rad_attr_t *ra;\n\n\tra = rad_packet_find_attr(pack, vendor_name, name);\n\tif (!ra)\n\t\treturn -1;\n\n\tra->val.integer = val;\n\n\treturn 0;\n}\n\nint __export rad_packet_add_octets(struct rad_packet_t *pack, const char *vendor_name, const char *name, const uint8_t *val, int len)\n{\n\tstruct rad_attr_t *ra;\n\tstruct rad_dict_attr_t *attr;\n\tstruct rad_dict_vendor_t *vendor;\n\n\tif (pack->len + (vendor_name ? 8 : 2) + len >= REQ_LENGTH_MAX)\n\t\treturn -1;\n\n\tif (vendor_name) {\n\t\tvendor = rad_dict_find_vendor_name(vendor_name);\n\t\tif (!vendor)\n\t\t\treturn -1;\n\t\tattr = rad_dict_find_vendor_attr(vendor, name);\n\t} else {\n\t\tvendor = NULL;\n\t\tattr = rad_dict_find_attr(name);\n\t}\n\n\tif (!attr)\n\t\treturn -1;\n\n\tra = mempool_alloc(attr_pool);\n\tif (!ra) {\n\t\tlog_emerg(\"radius: out of memory\\n\");\n\t\treturn -1;\n\t}\n\n\tmemset(ra, 0, sizeof(*ra));\n\tra->vendor = vendor;\n\tra->attr = attr;\n\tra->len = len;\n\n\tif (len) {\n\t\tra->alloc = 1;\n\t\tra->val.octets = _malloc(len);\n\t\tif (!ra->val.octets) {\n\t\t\tlog_emerg(\"radius: out of memory\\n\");\n\t\t\t_free(ra);\n\t\t\treturn -1;\n\t\t}\n\t\tmemcpy(ra->val.octets, val, len);\n\t}\n\n\tra->raw = ra->val.octets;\n\n\tlist_add_tail(&ra->entry, &pack->attrs);\n\tpack->len += (vendor_name ? 8 : 2) + len;\n\n\treturn 0;\n}\n\nint __export rad_packet_change_octets(struct rad_packet_t *pack, const char *vendor_name, const char *name, const uint8_t *val, int len)\n{\n\tstruct rad_attr_t *ra;\n\n\tra = rad_packet_find_attr(pack, vendor_name, name);\n\tif (!ra)\n\t\treturn -1;\n\n\tif (ra->len != len) {\n\t\tif (pack->len - ra->len + len >= REQ_LENGTH_MAX)\n\t\t\treturn -1;\n\n\t\tra->val.octets = _realloc(ra->val.octets, len);\n\t\tif (len && !ra->val.octets) {\n\t\t\tlog_emerg(\"radius: out of memory\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tra->raw = ra->val.octets;\n\n\t\tpack->len += len - ra->len;\n\t\tra->len = len;\n\t}\n\n\tif (len)\n\t\tmemcpy(ra->val.octets, val, len);\n\n\treturn 0;\n}\n\n\nint __export rad_packet_add_str(struct rad_packet_t *pack, const char *vendor_name, const char *name, const char *val)\n{\n\tstruct rad_attr_t *ra;\n\tstruct rad_dict_attr_t *attr;\n\tstruct rad_dict_vendor_t *vendor;\n\tint len = strlen(val);\n\n\tif (pack->len + (vendor_name ? 8 : 2) + len >= REQ_LENGTH_MAX)\n\t\treturn -1;\n\n\tif (vendor_name) {\n\t\tvendor = rad_dict_find_vendor_name(vendor_name);\n\t\tif (!vendor)\n\t\t\treturn -1;\n\t\tattr = rad_dict_find_vendor_attr(vendor, name);\n\t} else {\n\t\tvendor = NULL;\n\t\tattr = rad_dict_find_attr(name);\n\t}\n\n\tif (!attr)\n\t\treturn -1;\n\n\tra = mempool_alloc(attr_pool);\n\tif (!ra) {\n\t\tlog_emerg(\"radius: out of memory\\n\");\n\t\treturn -1;\n\t}\n\n\tmemset(ra, 0, sizeof(*ra));\n\tra->vendor = vendor;\n\tra->attr = attr;\n\tra->len = len;\n\tra->alloc = 1;\n\tra->val.string = _malloc(len + 1);\n\tif (!ra->val.string) {\n\t\tlog_emerg(\"radius: out of memory\\n\");\n\t\t_free(ra);\n\t\treturn -1;\n\t}\n\tmemcpy(ra->val.string, val, len);\n\tra->val.string[len] = 0;\n\tra->raw = ra->val.string;\n\tlist_add_tail(&ra->entry, &pack->attrs);\n\tpack->len += (vendor_name ? 8 : 2) + len;\n\n\treturn 0;\n}\n\nint __export rad_packet_change_str(struct rad_packet_t *pack, const char *vendor_name, const char *name, const char *val, int len)\n{\n\tstruct rad_attr_t *ra;\n\n\tra = rad_packet_find_attr(pack, vendor_name, name);\n\tif (!ra)\n\t\treturn -1;\n\n\tif (ra->len != len) {\n\t\tif (pack->len - ra->len + len >= REQ_LENGTH_MAX)\n\t\t\treturn -1;\n\n\t\tra->val.string = _realloc(ra->val.string, len + 1);\n\t\tif (!ra->val.string) {\n\t\t\tlog_emerg(\"radius: out of memory\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tra->raw = ra->val.string;\n\n\t\tpack->len += len - ra->len;\n\t\tra->len = len;\n\t}\n\n\tmemcpy(ra->val.string, val, len);\n\tra->val.string[len] = 0;\n\n\treturn 0;\n}\n\nint __export rad_packet_add_val(struct rad_packet_t *pack, const char *vendor_name, const char *name, const char *val)\n{\n\tstruct rad_attr_t *ra;\n\tstruct rad_dict_attr_t *attr;\n\tstruct rad_dict_value_t *v;\n\tstruct rad_dict_vendor_t *vendor;\n\n\tif (pack->len + (vendor_name ? 8 : 2) + 4 >= REQ_LENGTH_MAX)\n\t\treturn -1;\n\n\tif (vendor_name) {\n\t\tvendor = rad_dict_find_vendor_name(vendor_name);\n\t\tif (!vendor)\n\t\t\treturn -1;\n\t\tattr = rad_dict_find_vendor_attr(vendor, name);\n\t} else {\n\t\tvendor = NULL;\n\t\tattr = rad_dict_find_attr(name);\n\t}\n\n\tif (!attr)\n\t\treturn -1;\n\n\tv = rad_dict_find_val_name(attr, val);\n\tif (!v)\n\t\treturn -1;\n\n\tra = mempool_alloc(attr_pool);\n\tif (!ra)\n\t\treturn -1;\n\n\tmemset(ra, 0, sizeof(*ra));\n\tra->vendor = vendor;\n\tra->attr = attr;\n\tra->len = 4;\n\tra->val = v->val;\n\tra->raw = &ra->val;\n\tlist_add_tail(&ra->entry, &pack->attrs);\n\tpack->len += (vendor_name ? 8 : 2) + 4;\n\n\treturn 0;\n}\n\nint __export rad_packet_change_val(struct rad_packet_t *pack, const char *vendor_name, const char *name, const char *val)\n{\n\tstruct rad_attr_t *ra;\n\tstruct rad_dict_value_t *v;\n\n\tra = rad_packet_find_attr(pack, vendor_name, name);\n\tif (!ra)\n\t\treturn -1;\n\n\tv = rad_dict_find_val_name(ra->attr, val);\n\tif (!v)\n\t\treturn -1;\n\n\tra->val = v->val;\n\n\treturn 0;\n}\n\nint __export rad_packet_add_ipaddr(struct rad_packet_t *pack, const char *vendor_name, const char *name, in_addr_t ipaddr)\n{\n\treturn rad_packet_add_int(pack, vendor_name, name, ipaddr);\n}\n\nint rad_packet_add_ifid(struct rad_packet_t *pack, const char *vendor_name, const char *name, uint64_t ifid)\n{\n\tstruct rad_attr_t *ra;\n\tstruct rad_dict_attr_t *attr;\n\tstruct rad_dict_vendor_t *vendor;\n\n\tif (pack->len + (vendor_name ? 8 : 2) + 8 >= REQ_LENGTH_MAX)\n\t\treturn -1;\n\n\tif (vendor_name) {\n\t\tvendor = rad_dict_find_vendor_name(vendor_name);\n\t\tif (!vendor)\n\t\t\treturn -1;\n\t\tattr = rad_dict_find_vendor_attr(vendor, name);\n\t} else {\n\t\tvendor = NULL;\n\t\tattr = rad_dict_find_attr(name);\n\t}\n\n\tif (!attr)\n\t\treturn -1;\n\n\tra = mempool_alloc(attr_pool);\n\tif (!ra)\n\t\treturn -1;\n\n\tmemset(ra, 0, sizeof(*ra));\n\tra->vendor = vendor;\n\tra->attr = attr;\n\tra->len = 8;\n\tra->val.ifid = ifid;\n\tra->raw = &ra->val;\n\tlist_add_tail(&ra->entry, &pack->attrs);\n\tpack->len += (vendor_name ? 8 : 2) + 8;\n\n\treturn 0;\n}\n\nint rad_packet_add_ipv6prefix(struct rad_packet_t *pack, const char *vendor_name, const char *name, struct in6_addr *prefix, int len)\n{\n\tstruct rad_attr_t *ra;\n\tstruct rad_dict_attr_t *attr;\n\tstruct rad_dict_vendor_t *vendor;\n\n\tif (pack->len + (vendor_name ? 8 : 2) + 18 >= REQ_LENGTH_MAX)\n\t\treturn -1;\n\n\tif (vendor_name) {\n\t\tvendor = rad_dict_find_vendor_name(vendor_name);\n\t\tif (!vendor)\n\t\t\treturn -1;\n\t\tattr = rad_dict_find_vendor_attr(vendor, name);\n\t} else {\n\t\tvendor = NULL;\n\t\tattr = rad_dict_find_attr(name);\n\t}\n\n\tif (!attr)\n\t\treturn -1;\n\n\tra = mempool_alloc(attr_pool);\n\tif (!ra)\n\t\treturn -1;\n\n\tmemset(ra, 0, sizeof(*ra));\n\tra->vendor = vendor;\n\tra->attr = attr;\n\tra->len = 18;\n\tra->val.ipv6prefix.len = len;\n\tra->val.ipv6prefix.prefix = *prefix;\n\tra->raw = &ra->val;\n\tlist_add_tail(&ra->entry, &pack->attrs);\n\tpack->len += (vendor_name ? 8 : 2) + 18;\n\n\treturn 0;\n}\n\n\nstruct rad_attr_t __export *rad_packet_find_attr(struct rad_packet_t *pack, const char *vendor_name, const char *name)\n{\n\tstruct rad_attr_t *ra;\n\tstruct rad_dict_vendor_t *vendor;\n\n\tif (vendor_name) {\n\t\tvendor = rad_dict_find_vendor_name(vendor_name);\n\t\tif (!vendor)\n\t\t\treturn NULL;\n\t} else\n\t\tvendor = NULL;\n\n\tlist_for_each_entry(ra, &pack->attrs, entry) {\n\t\tif (vendor && vendor != ra->vendor)\n\t\t\tcontinue;\n\n\t\tif (strcmp(ra->attr->name, name))\n\t\t\tcontinue;\n\n\t\treturn ra;\n\t}\n\n\treturn NULL;\n}\n\nint rad_packet_send(struct rad_packet_t *pack, int fd, struct sockaddr_in *addr)\n{\n\tint n;\n\n\tclock_gettime(CLOCK_MONOTONIC, &pack->tv);\n\n\twhile (1) {\n\t\tif (addr)\n\t\t\tn = sendto(fd, pack->buf, pack->len, 0, addr, sizeof(*addr));\n\t\telse\n\t\t\tn = write(fd, pack->buf, pack->len);\n\t\tif (n < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tlog_ppp_error(\"radius:write: %s\\n\", strerror(errno));\n\t\t\treturn -1;\n\t\t} else if (n != pack->len) {\n\t\t\tlog_ppp_error(\"radius:write: short write %i, excpected %i\\n\", n, pack->len);\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void init(void)\n{\n\tattr_pool = mempool_create(sizeof(struct rad_attr_t));\n\tpacket_pool = mempool_create(sizeof(struct rad_packet_t));\n\tbuf_pool = mempool_create(REQ_LENGTH_MAX);\n}\n\nDEFINE_INIT(50, init);\n"], "fixing_code": ["#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/mman.h>\n#include <linux/mman.h>\n#include <arpa/inet.h>\n\n#include \"log.h\"\n#include \"mempool.h\"\n\n#include \"radius_p.h\"\n\n#include \"memdebug.h\"\n\nstatic mempool_t packet_pool;\nstatic mempool_t attr_pool;\nstatic mempool_t buf_pool;\n\nstruct rad_packet_t *rad_packet_alloc(int code)\n{\n\tstruct rad_packet_t *pack;\n\n\tpack = mempool_alloc(packet_pool);\n\tif (!pack) {\n\t\tlog_emerg(\"radius:packet: out of memory\\n\");\n\t\treturn NULL;\n\t}\n\n\tmemset(pack, 0, sizeof(*pack));\n\tpack->code = code;\n\tpack->len = 20;\n\tpack->id = 1;\n\tINIT_LIST_HEAD(&pack->attrs);\n\n\treturn pack;\n}\n\nvoid print_buf(uint8_t *buf,int size)\n{\n\tint i;\n\tfor(i=0;i<size;i++)\n\t\tprintf(\"%x \",buf[i]);\n\tprintf(\"\\n\");\n}\n\nint rad_packet_build(struct rad_packet_t *pack, uint8_t *RA)\n{\n\tstruct rad_attr_t *attr;\n\tuint8_t *ptr;\n\n\tif (!pack->buf) {\n\t\t//ptr = mmap(NULL, REQ_LENGTH_MAX, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0);\n\t\tptr = mempool_alloc(buf_pool);\n\n\t\t//if (ptr == MAP_FAILED) {\n\t\tif (!ptr) {\n\t\t\tlog_emerg(\"radius:packet: out of memory\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tpack->buf = ptr;\n\t} else\n\t\tptr = pack->buf;\n\n\t*ptr = pack->code; ptr++;\n\t*ptr = pack->id; ptr++;\n\t*(uint16_t*)ptr = htons(pack->len); ptr+= 2;\n\tmemcpy(ptr, RA, 16);\tptr+=16;\n\n\tlist_for_each_entry(attr, &pack->attrs, entry) {\n\t\tif (attr->vendor) {\n\t\t\t*ptr = 26; ptr++;\n\t\t\t*ptr = attr->len + 2 + 6; ptr++;\n\t\t\t*(uint32_t *)ptr = htonl(attr->vendor->id); ptr+=4;\n\t\t}\n\t\t*ptr = attr->attr->id; ptr++;\n\t\t*ptr = attr->len + 2; ptr++;\n\t\tswitch(attr->attr->type) {\n\t\t\tcase ATTR_TYPE_INTEGER:\n\t\t\t\t*(uint32_t*)ptr = htonl(attr->val.integer);\n\t\t\t\tbreak;\n\t\t\tcase ATTR_TYPE_OCTETS:\n\t\t\tcase ATTR_TYPE_STRING:\n\t\t\t\tmemcpy(ptr, attr->val.string, attr->len);\n\t\t\t\tbreak;\n\t\t\tcase ATTR_TYPE_IPADDR:\n\t\t\tcase ATTR_TYPE_IFID:\n\t\t\tcase ATTR_TYPE_IPV6ADDR:\n\t\t\t\tmemcpy(ptr, &attr->val, attr->len);\n\t\t\t\tbreak;\n\t\t\tcase ATTR_TYPE_DATE:\n\t\t\t\t*(uint32_t*)ptr = htonl(attr->val.date);\n\t\t\t\tbreak;\n\t\t\tcase ATTR_TYPE_IPV6PREFIX:\n\t\t\t\tptr[0] = 0;\n\t\t\t\tptr[1] = attr->val.ipv6prefix.len;\n\t\t\t\tmemcpy(ptr + 2, &attr->val.ipv6prefix.prefix, sizeof(attr->val.ipv6prefix.prefix));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tlog_emerg(\"radius:packet:BUG: unknown attribute type\\n\");\n\t\t\t\tabort();\n\t\t}\n\t\tptr += attr->len;\n\t}\n\n\t//print_buf(pack->buf, pack->len);\n\treturn 0;\n}\n\nint rad_packet_recv(int fd, struct rad_packet_t **p, struct sockaddr_in *addr)\n{\n\tstruct rad_packet_t *pack;\n\tstruct rad_attr_t *attr;\n\tstruct rad_dict_attr_t *da;\n\tstruct rad_dict_vendor_t *vendor;\n\tuint8_t *ptr;\n\tint n, id, len, vendor_id;\n\tsocklen_t addr_len = sizeof(*addr);\n\n\t*p = NULL;\n\n\tpack = rad_packet_alloc(0);\n\tif (!pack)\n\t\treturn 0;\n\n\t//ptr = mmap(NULL, REQ_LENGTH_MAX, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0);\n\tptr = mempool_alloc(buf_pool);\n\tif (ptr == MAP_FAILED) {\n\t\tlog_emerg(\"radius:packet: out of memory\\n\");\n\t\tgoto out_err;\n\t}\n\n\tpack->buf = ptr;\n\tclock_gettime(CLOCK_MONOTONIC, &pack->tv);\n\n\twhile (1) {\n\t\tif (addr)\n\t\t\tn = recvfrom(fd, pack->buf, REQ_LENGTH_MAX, 0, addr, &addr_len);\n\t\telse\n\t\t\tn = read(fd, pack->buf, REQ_LENGTH_MAX);\n\t\tif (n < 0) {\n\t\t\trad_packet_free(pack);\n\t\t\tif (errno == EAGAIN)\n\t\t\t\treturn 1;\n\n\t\t\tif (errno != ECONNREFUSED)\n\t\t\t\tlog_ppp_error(\"radius:packet:read: %s\\n\", strerror(errno));\n\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (n < 20) {\n\t\tlog_ppp_warn(\"radius:packet: short packed received (%i)\\n\", n);\n\t\tgoto out_err;\n\t}\n\n\tpack->code = *ptr; ptr++;\n\tpack->id = *ptr; ptr++;\n\tpack->len = ntohs(*(uint16_t*)ptr); ptr += 2;\n\n\tif (pack->len > n) {\n\t\tlog_ppp_warn(\"radius:packet: short packet received %i, expected %i\\n\", pack->len, n);\n\t\tgoto out_err;\n\t}\n\n\tptr += 16;\n\tn -= 20;\n\n\twhile (n>0) {\n\t\tid = *ptr; ptr++;\n\t\tlen = *ptr - 2; ptr++;\n\t\tif (len < 0) {\n\t\t\tlog_ppp_warn(\"radius:packet short attribute len received\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t\tif (2 + len > n) {\n\t\t\tlog_ppp_warn(\"radius:packet: too long attribute received (%i, %i)\\n\", id, len);\n\t\t\tgoto out_err;\n\t\t}\n\t\tif (id == 26) {\n\t\t\tvendor_id = ntohl(*(uint32_t *)ptr);\n\t\t\tvendor = rad_dict_find_vendor_id(vendor_id);\n\t\t\tif (vendor) {\n\t\t\t\tptr += 4;\n\n\t\t\t\tif (vendor->tag == 2)\n\t\t\t\t\tid = (uint16_t)ntohs(*(uint16_t *)ptr);\n\t\t\t\telse\n\t\t\t\t\tid = *ptr;\n\n\t\t\t\tptr += vendor->tag;\n\n\t\t\t\tif (vendor->len == 2)\n\t\t\t\t\tlen = (uint16_t)ntohs(*(uint16_t *)ptr);\n\t\t\t\telse\n\t\t\t\t\tlen = *ptr;\n\n\t\t\t\tptr += vendor->len;\n\n\t\t\t\tlen -= vendor->tag + vendor->len;\n\n\t\t\t\tn -= 4 + vendor->tag + vendor->len;\n\t\t\t\tif (len < 0) {\n\t\t\t\t\tlog_ppp_warn(\"radius:packet invalid vendor attribute len received\\n\");\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t\tif (2 + len > n) {\n\t\t\t\t\tlog_ppp_warn(\"radius:packet: too long vendor attribute received (%i, %i)\\n\", id, len);\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tlog_ppp_warn(\"radius:packet: vendor %i not found\\n\", id);\n\t\t} else\n\t\t\tvendor = NULL;\n\t\tda = rad_dict_find_attr_id(vendor, id);\n\t\tif (da) {\n\t\t\tattr = mempool_alloc(attr_pool);\n\t\t\tif (!attr) {\n\t\t\t\tlog_emerg(\"radius:packet: out of memory\\n\");\n\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t\tmemset(attr, 0, sizeof(*attr));\n\t\t\tattr->vendor = vendor;\n\t\t\tattr->attr = da;\n\t\t\tattr->len = len;\n\t\t\tattr->raw = ptr;\n\n\t\t\tif (!da->array) {\n\t\t\t\tswitch (da->type) {\n\t\t\t\t\tcase ATTR_TYPE_STRING:\n\t\t\t\t\t\tattr->alloc = 1;\n\t\t\t\t\t\tattr->val.string = _malloc(len + 1);\n\t\t\t\t\t\tmemcpy(attr->val.string, ptr, len);\n\t\t\t\t\t\tattr->val.string[len] = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ATTR_TYPE_OCTETS:\n\t\t\t\t\tcase ATTR_TYPE_ETHER:\n\t\t\t\t\tcase ATTR_TYPE_TLV:\n\t\t\t\t\t\tattr->val.octets = ptr;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ATTR_TYPE_INTEGER:\n\t\t\t\t\t\tif (len != da->size)\n\t\t\t\t\t\t\tlog_ppp_warn(\"radius:packet: attribute %s has invalid length %i (must be %i)\\n\", da->name, len, da->size);\n\t\t\t\t\tcase ATTR_TYPE_DATE:\n\t\t\t\t\t\tif (len == 4)\n\t\t\t\t\t\t\tattr->val.integer = ntohl(*(uint32_t*)ptr);\n\t\t\t\t\t\telse if (len == 2)\n\t\t\t\t\t\t\tattr->val.integer = ntohs(*(uint16_t*)ptr);\n\t\t\t\t\t\telse if (len == 1)\n\t\t\t\t\t\t\tattr->val.integer = *ptr;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ATTR_TYPE_IPADDR:\n\t\t\t\t\tcase ATTR_TYPE_IFID:\n\t\t\t\t\tcase ATTR_TYPE_IPV6ADDR:\n\t\t\t\t\t\tmemcpy(&attr->val.integer, ptr, len);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ATTR_TYPE_IPV6PREFIX:\n\t\t\t\t\t\tattr->val.ipv6prefix.len = ptr[1];\n\t\t\t\t\t\tmemset(&attr->val.ipv6prefix.prefix, 0, sizeof(attr->val.ipv6prefix.prefix));\n\t\t\t\t\t\tmemcpy(&attr->val.ipv6prefix.prefix, ptr + 2, len - 2);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlist_add_tail(&attr->entry, &pack->attrs);\n\t\t} else\n\t\t\tlog_ppp_warn(\"radius:packet: unknown attribute received (%i,%i)\\n\", vendor ? vendor->id : 0, id);\n\t\tptr += len;\n\t\tn -= 2 + len;\n\t}\n\n\t*p = pack;\n\n\treturn 0;\n\nout_err:\n\trad_packet_free(pack);\n\treturn 1;\n}\n\nvoid rad_packet_free(struct rad_packet_t *pack)\n{\n\tstruct rad_attr_t *attr;\n\n\tif (pack->buf)\n\t\tmempool_free(pack->buf);\n\t\t//munmap(pack->buf, REQ_LENGTH_MAX);\n\n\twhile(!list_empty(&pack->attrs)) {\n\t\tattr = list_entry(pack->attrs.next, typeof(*attr), entry);\n\t\tlist_del(&attr->entry);\n\t\tif (attr->alloc)\n\t\t\t_free(attr->val.string);\n\t\tmempool_free(attr);\n\t}\n\n\tmempool_free(pack);\n}\n\nstatic void print_octets(uint8_t *raw, int len, void (*print)(const char *fmt, ...))\n{\n\tprint(\" 0x\");\n\twhile (len--)\n\t\tprint(\"%02x\", *raw++);\n}\n\nvoid rad_packet_print(struct rad_packet_t *pack, struct rad_server_t *s, void (*print)(const char *fmt, ...))\n{\n\tstruct rad_attr_t *attr;\n\tstruct rad_dict_value_t *val;\n\tchar ip_str[50];\n\tunion {\n\t\tuint64_t ifid;\n\t\tuint16_t u16[4];\n\t} ifid_u;\n\tin_addr_t addr;\n\n\tif (s)\n\t\tprint(\"[RADIUS(%i) \", s->id);\n\telse\n\t\tprint(\"[RADIUS \");\n\n\tswitch(pack->code) {\n\t\tcase CODE_ACCESS_REQUEST:\n\t\t\tprint(\"Access-Request\");\n\t\t\tbreak;\n\t\tcase CODE_ACCESS_CHALLENGE:\n\t\t\tprint(\"Access-Challenge\");\n\t\t\tbreak;\n\t\tcase CODE_ACCESS_ACCEPT:\n\t\t\tprint(\"Access-Accept\");\n\t\t\tbreak;\n\t\tcase CODE_ACCESS_REJECT:\n\t\t\tprint(\"Access-Reject\");\n\t\t\tbreak;\n\t\tcase CODE_ACCOUNTING_REQUEST:\n\t\t\tprint(\"Accounting-Request\");\n\t\t\tbreak;\n\t\tcase CODE_ACCOUNTING_RESPONSE:\n\t\t\tprint(\"Accounting-Response\");\n\t\t\tbreak;\n\t\tcase CODE_DISCONNECT_REQUEST:\n\t\t\tprint(\"Disconnect-Request\");\n\t\t\tbreak;\n\t\tcase CODE_DISCONNECT_ACK:\n\t\t\tprint(\"Disconnect-ACK\");\n\t\t\tbreak;\n\t\tcase CODE_DISCONNECT_NAK:\n\t\t\tprint(\"Disconnect-NAK\");\n\t\t\tbreak;\n\t\tcase CODE_COA_REQUEST:\n\t\t\tprint(\"CoA-Request\");\n\t\t\tbreak;\n\t\tcase CODE_COA_ACK:\n\t\t\tprint(\"CoA-ACK\");\n\t\t\tbreak;\n\t\tcase CODE_COA_NAK:\n\t\t\tprint(\"CoA-NAK\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprint(\"Unknown (%i)\", pack->code);\n\t}\n\n\tprint(\" id=%x\", pack->id);\n\n\tlist_for_each_entry(attr, &pack->attrs, entry) {\n\t\tprint(\" <%s\", attr->attr->name);\n\n\t\tif (attr->attr->array)\n\t\t\tprint_octets(attr->raw, attr->len, print);\n\t\telse {\n\t\t\tswitch (attr->attr->type) {\n\t\t\t\tcase ATTR_TYPE_INTEGER:\n\t\t\t\t\tval = rad_dict_find_val(attr->attr, attr->val);\n\t\t\t\t\tif (val)\n\t\t\t\t\t\tprint(\" %s\", val->name);\n\t\t\t\t\telse\n\t\t\t\t\t\tprint(\" %u\", attr->val.integer);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_TYPE_STRING:\n\t\t\t\t\tprint(\" \\\"%s\\\"\", attr->val.string);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_TYPE_IPADDR:\n\t\t\t\t\taddr = ntohl(attr->val.ipaddr);\n\t\t\t\t\tprint(\" %i.%i.%i.%i\", (addr >> 24) & 0xff, (addr >> 16) & 0xff, (addr >> 8) & 0xff, addr & 0xff);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_TYPE_IFID:\n\t\t\t\t\tifid_u.ifid = attr->val.ifid;\n\t\t\t\t\tprint(\" %x:%x:%x:%x\", ntohs(ifid_u.u16[0]), ntohs(ifid_u.u16[1]), ntohs(ifid_u.u16[2]), ntohs(ifid_u.u16[3]));\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_TYPE_IPV6ADDR:\n\t\t\t\t\tinet_ntop(AF_INET6, &attr->val.ipv6addr, ip_str, sizeof(ip_str));\n\t\t\t\t\tprint(\" %s\", ip_str);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_TYPE_IPV6PREFIX:\n\t\t\t\t\tinet_ntop(AF_INET6, &attr->val.ipv6prefix.prefix, ip_str, sizeof(ip_str));\n\t\t\t\t\tprint(\" %s/%i\", ip_str, attr->val.ipv6prefix.len);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tprint_octets(attr->raw, attr->len, print);\n\t\t\t}\n\t\t}\n\n\t\tprint(\">\");\n\t}\n\n\tprint(\"]\\n\");\n}\n\nint __export rad_packet_add_int(struct rad_packet_t *pack, const char *vendor_name, const char *name, int val)\n{\n\tstruct rad_attr_t *ra;\n\tstruct rad_dict_attr_t *attr;\n\tstruct rad_dict_vendor_t *vendor;\n\n\tif (pack->len + (vendor_name ? 8 : 2) + 4 >= REQ_LENGTH_MAX)\n\t\treturn -1;\n\n\tif (vendor_name) {\n\t\tvendor = rad_dict_find_vendor_name(vendor_name);\n\t\tif (!vendor)\n\t\t\treturn -1;\n\t\tattr = rad_dict_find_vendor_attr(vendor, name);\n\t} else {\n\t\tvendor = NULL;\n\t\tattr = rad_dict_find_attr(name);\n\t}\n\n\tif (!attr)\n\t\treturn -1;\n\n\tra = mempool_alloc(attr_pool);\n\tif (!ra)\n\t\treturn -1;\n\n\tmemset(ra, 0, sizeof(*ra));\n\tra->vendor = vendor;\n\tra->attr = attr;\n\tra->len = 4;\n\tra->val.integer = val;\n\tra->raw = &ra->val;\n\tlist_add_tail(&ra->entry, &pack->attrs);\n\tpack->len += (vendor_name ? 8 : 2) + 4;\n\n\treturn 0;\n}\n\nint __export rad_packet_change_int(struct rad_packet_t *pack, const char *vendor_name, const char *name, int val)\n{\n\tstruct rad_attr_t *ra;\n\n\tra = rad_packet_find_attr(pack, vendor_name, name);\n\tif (!ra)\n\t\treturn -1;\n\n\tra->val.integer = val;\n\n\treturn 0;\n}\n\nint __export rad_packet_add_octets(struct rad_packet_t *pack, const char *vendor_name, const char *name, const uint8_t *val, int len)\n{\n\tstruct rad_attr_t *ra;\n\tstruct rad_dict_attr_t *attr;\n\tstruct rad_dict_vendor_t *vendor;\n\n\tif (pack->len + (vendor_name ? 8 : 2) + len >= REQ_LENGTH_MAX)\n\t\treturn -1;\n\n\tif (vendor_name) {\n\t\tvendor = rad_dict_find_vendor_name(vendor_name);\n\t\tif (!vendor)\n\t\t\treturn -1;\n\t\tattr = rad_dict_find_vendor_attr(vendor, name);\n\t} else {\n\t\tvendor = NULL;\n\t\tattr = rad_dict_find_attr(name);\n\t}\n\n\tif (!attr)\n\t\treturn -1;\n\n\tra = mempool_alloc(attr_pool);\n\tif (!ra) {\n\t\tlog_emerg(\"radius: out of memory\\n\");\n\t\treturn -1;\n\t}\n\n\tmemset(ra, 0, sizeof(*ra));\n\tra->vendor = vendor;\n\tra->attr = attr;\n\tra->len = len;\n\n\tif (len) {\n\t\tra->alloc = 1;\n\t\tra->val.octets = _malloc(len);\n\t\tif (!ra->val.octets) {\n\t\t\tlog_emerg(\"radius: out of memory\\n\");\n\t\t\t_free(ra);\n\t\t\treturn -1;\n\t\t}\n\t\tmemcpy(ra->val.octets, val, len);\n\t}\n\n\tra->raw = ra->val.octets;\n\n\tlist_add_tail(&ra->entry, &pack->attrs);\n\tpack->len += (vendor_name ? 8 : 2) + len;\n\n\treturn 0;\n}\n\nint __export rad_packet_change_octets(struct rad_packet_t *pack, const char *vendor_name, const char *name, const uint8_t *val, int len)\n{\n\tstruct rad_attr_t *ra;\n\n\tra = rad_packet_find_attr(pack, vendor_name, name);\n\tif (!ra)\n\t\treturn -1;\n\n\tif (ra->len != len) {\n\t\tif (pack->len - ra->len + len >= REQ_LENGTH_MAX)\n\t\t\treturn -1;\n\n\t\tra->val.octets = _realloc(ra->val.octets, len);\n\t\tif (len && !ra->val.octets) {\n\t\t\tlog_emerg(\"radius: out of memory\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tra->raw = ra->val.octets;\n\n\t\tpack->len += len - ra->len;\n\t\tra->len = len;\n\t}\n\n\tif (len)\n\t\tmemcpy(ra->val.octets, val, len);\n\n\treturn 0;\n}\n\n\nint __export rad_packet_add_str(struct rad_packet_t *pack, const char *vendor_name, const char *name, const char *val)\n{\n\tstruct rad_attr_t *ra;\n\tstruct rad_dict_attr_t *attr;\n\tstruct rad_dict_vendor_t *vendor;\n\tint len = strlen(val);\n\n\tif (pack->len + (vendor_name ? 8 : 2) + len >= REQ_LENGTH_MAX)\n\t\treturn -1;\n\n\tif (vendor_name) {\n\t\tvendor = rad_dict_find_vendor_name(vendor_name);\n\t\tif (!vendor)\n\t\t\treturn -1;\n\t\tattr = rad_dict_find_vendor_attr(vendor, name);\n\t} else {\n\t\tvendor = NULL;\n\t\tattr = rad_dict_find_attr(name);\n\t}\n\n\tif (!attr)\n\t\treturn -1;\n\n\tra = mempool_alloc(attr_pool);\n\tif (!ra) {\n\t\tlog_emerg(\"radius: out of memory\\n\");\n\t\treturn -1;\n\t}\n\n\tmemset(ra, 0, sizeof(*ra));\n\tra->vendor = vendor;\n\tra->attr = attr;\n\tra->len = len;\n\tra->alloc = 1;\n\tra->val.string = _malloc(len + 1);\n\tif (!ra->val.string) {\n\t\tlog_emerg(\"radius: out of memory\\n\");\n\t\t_free(ra);\n\t\treturn -1;\n\t}\n\tmemcpy(ra->val.string, val, len);\n\tra->val.string[len] = 0;\n\tra->raw = ra->val.string;\n\tlist_add_tail(&ra->entry, &pack->attrs);\n\tpack->len += (vendor_name ? 8 : 2) + len;\n\n\treturn 0;\n}\n\nint __export rad_packet_change_str(struct rad_packet_t *pack, const char *vendor_name, const char *name, const char *val, int len)\n{\n\tstruct rad_attr_t *ra;\n\n\tra = rad_packet_find_attr(pack, vendor_name, name);\n\tif (!ra)\n\t\treturn -1;\n\n\tif (ra->len != len) {\n\t\tif (pack->len - ra->len + len >= REQ_LENGTH_MAX)\n\t\t\treturn -1;\n\n\t\tra->val.string = _realloc(ra->val.string, len + 1);\n\t\tif (!ra->val.string) {\n\t\t\tlog_emerg(\"radius: out of memory\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tra->raw = ra->val.string;\n\n\t\tpack->len += len - ra->len;\n\t\tra->len = len;\n\t}\n\n\tmemcpy(ra->val.string, val, len);\n\tra->val.string[len] = 0;\n\n\treturn 0;\n}\n\nint __export rad_packet_add_val(struct rad_packet_t *pack, const char *vendor_name, const char *name, const char *val)\n{\n\tstruct rad_attr_t *ra;\n\tstruct rad_dict_attr_t *attr;\n\tstruct rad_dict_value_t *v;\n\tstruct rad_dict_vendor_t *vendor;\n\n\tif (pack->len + (vendor_name ? 8 : 2) + 4 >= REQ_LENGTH_MAX)\n\t\treturn -1;\n\n\tif (vendor_name) {\n\t\tvendor = rad_dict_find_vendor_name(vendor_name);\n\t\tif (!vendor)\n\t\t\treturn -1;\n\t\tattr = rad_dict_find_vendor_attr(vendor, name);\n\t} else {\n\t\tvendor = NULL;\n\t\tattr = rad_dict_find_attr(name);\n\t}\n\n\tif (!attr)\n\t\treturn -1;\n\n\tv = rad_dict_find_val_name(attr, val);\n\tif (!v)\n\t\treturn -1;\n\n\tra = mempool_alloc(attr_pool);\n\tif (!ra)\n\t\treturn -1;\n\n\tmemset(ra, 0, sizeof(*ra));\n\tra->vendor = vendor;\n\tra->attr = attr;\n\tra->len = 4;\n\tra->val = v->val;\n\tra->raw = &ra->val;\n\tlist_add_tail(&ra->entry, &pack->attrs);\n\tpack->len += (vendor_name ? 8 : 2) + 4;\n\n\treturn 0;\n}\n\nint __export rad_packet_change_val(struct rad_packet_t *pack, const char *vendor_name, const char *name, const char *val)\n{\n\tstruct rad_attr_t *ra;\n\tstruct rad_dict_value_t *v;\n\n\tra = rad_packet_find_attr(pack, vendor_name, name);\n\tif (!ra)\n\t\treturn -1;\n\n\tv = rad_dict_find_val_name(ra->attr, val);\n\tif (!v)\n\t\treturn -1;\n\n\tra->val = v->val;\n\n\treturn 0;\n}\n\nint __export rad_packet_add_ipaddr(struct rad_packet_t *pack, const char *vendor_name, const char *name, in_addr_t ipaddr)\n{\n\treturn rad_packet_add_int(pack, vendor_name, name, ipaddr);\n}\n\nint rad_packet_add_ifid(struct rad_packet_t *pack, const char *vendor_name, const char *name, uint64_t ifid)\n{\n\tstruct rad_attr_t *ra;\n\tstruct rad_dict_attr_t *attr;\n\tstruct rad_dict_vendor_t *vendor;\n\n\tif (pack->len + (vendor_name ? 8 : 2) + 8 >= REQ_LENGTH_MAX)\n\t\treturn -1;\n\n\tif (vendor_name) {\n\t\tvendor = rad_dict_find_vendor_name(vendor_name);\n\t\tif (!vendor)\n\t\t\treturn -1;\n\t\tattr = rad_dict_find_vendor_attr(vendor, name);\n\t} else {\n\t\tvendor = NULL;\n\t\tattr = rad_dict_find_attr(name);\n\t}\n\n\tif (!attr)\n\t\treturn -1;\n\n\tra = mempool_alloc(attr_pool);\n\tif (!ra)\n\t\treturn -1;\n\n\tmemset(ra, 0, sizeof(*ra));\n\tra->vendor = vendor;\n\tra->attr = attr;\n\tra->len = 8;\n\tra->val.ifid = ifid;\n\tra->raw = &ra->val;\n\tlist_add_tail(&ra->entry, &pack->attrs);\n\tpack->len += (vendor_name ? 8 : 2) + 8;\n\n\treturn 0;\n}\n\nint rad_packet_add_ipv6prefix(struct rad_packet_t *pack, const char *vendor_name, const char *name, struct in6_addr *prefix, int len)\n{\n\tstruct rad_attr_t *ra;\n\tstruct rad_dict_attr_t *attr;\n\tstruct rad_dict_vendor_t *vendor;\n\n\tif (pack->len + (vendor_name ? 8 : 2) + 18 >= REQ_LENGTH_MAX)\n\t\treturn -1;\n\n\tif (vendor_name) {\n\t\tvendor = rad_dict_find_vendor_name(vendor_name);\n\t\tif (!vendor)\n\t\t\treturn -1;\n\t\tattr = rad_dict_find_vendor_attr(vendor, name);\n\t} else {\n\t\tvendor = NULL;\n\t\tattr = rad_dict_find_attr(name);\n\t}\n\n\tif (!attr)\n\t\treturn -1;\n\n\tra = mempool_alloc(attr_pool);\n\tif (!ra)\n\t\treturn -1;\n\n\tmemset(ra, 0, sizeof(*ra));\n\tra->vendor = vendor;\n\tra->attr = attr;\n\tra->len = 18;\n\tra->val.ipv6prefix.len = len;\n\tra->val.ipv6prefix.prefix = *prefix;\n\tra->raw = &ra->val;\n\tlist_add_tail(&ra->entry, &pack->attrs);\n\tpack->len += (vendor_name ? 8 : 2) + 18;\n\n\treturn 0;\n}\n\n\nstruct rad_attr_t __export *rad_packet_find_attr(struct rad_packet_t *pack, const char *vendor_name, const char *name)\n{\n\tstruct rad_attr_t *ra;\n\tstruct rad_dict_vendor_t *vendor;\n\n\tif (vendor_name) {\n\t\tvendor = rad_dict_find_vendor_name(vendor_name);\n\t\tif (!vendor)\n\t\t\treturn NULL;\n\t} else\n\t\tvendor = NULL;\n\n\tlist_for_each_entry(ra, &pack->attrs, entry) {\n\t\tif (vendor && vendor != ra->vendor)\n\t\t\tcontinue;\n\n\t\tif (strcmp(ra->attr->name, name))\n\t\t\tcontinue;\n\n\t\treturn ra;\n\t}\n\n\treturn NULL;\n}\n\nint rad_packet_send(struct rad_packet_t *pack, int fd, struct sockaddr_in *addr)\n{\n\tint n;\n\n\tclock_gettime(CLOCK_MONOTONIC, &pack->tv);\n\n\twhile (1) {\n\t\tif (addr)\n\t\t\tn = sendto(fd, pack->buf, pack->len, 0, addr, sizeof(*addr));\n\t\telse\n\t\t\tn = write(fd, pack->buf, pack->len);\n\t\tif (n < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tlog_ppp_error(\"radius:write: %s\\n\", strerror(errno));\n\t\t\treturn -1;\n\t\t} else if (n != pack->len) {\n\t\t\tlog_ppp_error(\"radius:write: short write %i, excpected %i\\n\", n, pack->len);\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void init(void)\n{\n\tattr_pool = mempool_create(sizeof(struct rad_attr_t));\n\tpacket_pool = mempool_create(sizeof(struct rad_packet_t));\n\tbuf_pool = mempool_create(REQ_LENGTH_MAX);\n}\n\nDEFINE_INIT(50, init);\n"], "filenames": ["accel-pppd/radius/packet.c"], "buggy_code_start_loc": [208], "buggy_code_end_loc": [208], "fixing_code_start_loc": [209], "fixing_code_end_loc": [217], "type": "CWE-191", "message": "Variable underflow exists in accel-ppp radius/packet.c when receiving a RADIUS vendor-specific attribute with length field is less than 2. It has an impact only when the attacker controls the RADIUS server, which can lead to arbitrary code execution.", "other": {"cve": {"id": "CVE-2020-28194", "sourceIdentifier": "cve@mitre.org", "published": "2021-02-01T14:15:12.240", "lastModified": "2021-02-05T20:58:45.087", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Variable underflow exists in accel-ppp radius/packet.c when receiving a RADIUS vendor-specific attribute with length field is less than 2. It has an impact only when the attacker controls the RADIUS server, which can lead to arbitrary code execution."}, {"lang": "es", "value": "Se presenta subdesbordamiento de variable en accel-ppp en el archivo  radius/packet.c cuando se recibe un atributo espec\u00edfico del proveedor RADIUS con un campo de longitud menor que 2. Presenta un impacto solo cuando el atacante controla el servidor RADIUS, lo que puede conllevar a una ejecuci\u00f3n de c\u00f3digo arbitraria"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-191"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:accel-ppp:accel-ppp:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.12.0-e9d369a", "matchCriteriaId": "41B2A897-7CA6-4F53-8993-A0747BC3C1EC"}]}]}], "references": [{"url": "https://github.com/accel-ppp/accel-ppp/commit/e9d369aa0054312b7633e964e9f7eb323f1f3d69", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/accel-ppp/accel-ppp/security/advisories/GHSA-2m44-rh3c-x4gr", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/accel-ppp/accel-ppp/commit/e9d369aa0054312b7633e964e9f7eb323f1f3d69"}}