{"buggy_code": ["/* pb_decode.c -- decode a protobuf using minimal resources\n *\n * 2011 Petteri Aimonen <jpa@kapsi.fi>\n */\n\n/* Use the GCC warn_unused_result attribute to check that all return values\n * are propagated correctly. On other compilers and gcc before 3.4.0 just\n * ignore the annotation.\n */\n#if !defined(__GNUC__) || ( __GNUC__ < 3) || (__GNUC__ == 3 && __GNUC_MINOR__ < 4)\n    #define checkreturn\n#else\n    #define checkreturn __attribute__((warn_unused_result))\n#endif\n\n#include \"pb.h\"\n#include \"pb_decode.h\"\n#include \"pb_common.h\"\n\n/**************************************\n * Declarations internal to this file *\n **************************************/\n\ntypedef bool (*pb_decoder_t)(pb_istream_t *stream, const pb_field_t *field, void *dest) checkreturn;\n\nstatic bool checkreturn buf_read(pb_istream_t *stream, pb_byte_t *buf, size_t count);\nstatic bool checkreturn read_raw_value(pb_istream_t *stream, pb_wire_type_t wire_type, pb_byte_t *buf, size_t *size);\nstatic bool checkreturn decode_static_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter);\nstatic bool checkreturn decode_callback_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter);\nstatic bool checkreturn decode_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter);\nstatic void iter_from_extension(pb_field_iter_t *iter, pb_extension_t *extension);\nstatic bool checkreturn default_extension_decoder(pb_istream_t *stream, pb_extension_t *extension, uint32_t tag, pb_wire_type_t wire_type);\nstatic bool checkreturn decode_extension(pb_istream_t *stream, uint32_t tag, pb_wire_type_t wire_type, pb_field_iter_t *iter);\nstatic bool checkreturn find_extension_field(pb_field_iter_t *iter);\nstatic void pb_field_set_to_default(pb_field_iter_t *iter);\nstatic void pb_message_set_to_defaults(const pb_field_t fields[], void *dest_struct);\nstatic bool checkreturn pb_dec_bool(pb_istream_t *stream, const pb_field_t *field, void *dest);\nstatic bool checkreturn pb_dec_varint(pb_istream_t *stream, const pb_field_t *field, void *dest);\nstatic bool checkreturn pb_decode_varint32_eof(pb_istream_t *stream, uint32_t *dest, bool *eof);\nstatic bool checkreturn pb_dec_uvarint(pb_istream_t *stream, const pb_field_t *field, void *dest);\nstatic bool checkreturn pb_dec_svarint(pb_istream_t *stream, const pb_field_t *field, void *dest);\nstatic bool checkreturn pb_dec_fixed32(pb_istream_t *stream, const pb_field_t *field, void *dest);\nstatic bool checkreturn pb_dec_fixed64(pb_istream_t *stream, const pb_field_t *field, void *dest);\nstatic bool checkreturn pb_dec_bytes(pb_istream_t *stream, const pb_field_t *field, void *dest);\nstatic bool checkreturn pb_dec_string(pb_istream_t *stream, const pb_field_t *field, void *dest);\nstatic bool checkreturn pb_dec_submessage(pb_istream_t *stream, const pb_field_t *field, void *dest);\nstatic bool checkreturn pb_dec_fixed_length_bytes(pb_istream_t *stream, const pb_field_t *field, void *dest);\nstatic bool checkreturn pb_skip_varint(pb_istream_t *stream);\nstatic bool checkreturn pb_skip_string(pb_istream_t *stream);\n\n#ifdef PB_ENABLE_MALLOC\nstatic bool checkreturn allocate_field(pb_istream_t *stream, void *pData, size_t data_size, size_t array_size);\nstatic bool checkreturn pb_release_union_field(pb_istream_t *stream, pb_field_iter_t *iter);\nstatic void pb_release_single_field(const pb_field_iter_t *iter);\n#endif\n\n#ifdef PB_WITHOUT_64BIT\n#define pb_int64_t int32_t\n#define pb_uint64_t uint32_t\n#else\n#define pb_int64_t int64_t\n#define pb_uint64_t uint64_t\n#endif\n\n/* --- Function pointers to field decoders ---\n * Order in the array must match pb_action_t LTYPE numbering.\n */\nstatic const pb_decoder_t PB_DECODERS[PB_LTYPES_COUNT] = {\n    &pb_dec_bool,\n    &pb_dec_varint,\n    &pb_dec_uvarint,\n    &pb_dec_svarint,\n    &pb_dec_fixed32,\n    &pb_dec_fixed64,\n    \n    &pb_dec_bytes,\n    &pb_dec_string,\n    &pb_dec_submessage,\n    NULL, /* extensions */\n    &pb_dec_fixed_length_bytes\n};\n\n/*******************************\n * pb_istream_t implementation *\n *******************************/\n\nstatic bool checkreturn buf_read(pb_istream_t *stream, pb_byte_t *buf, size_t count)\n{\n    size_t i;\n    const pb_byte_t *source = (const pb_byte_t*)stream->state;\n    stream->state = (pb_byte_t*)stream->state + count;\n    \n    if (buf != NULL)\n    {\n        for (i = 0; i < count; i++)\n            buf[i] = source[i];\n    }\n    \n    return true;\n}\n\nbool checkreturn pb_read(pb_istream_t *stream, pb_byte_t *buf, size_t count)\n{\n    if (count == 0)\n        return true;\n\n#ifndef PB_BUFFER_ONLY\n\tif (buf == NULL && stream->callback != buf_read)\n\t{\n\t\t/* Skip input bytes */\n\t\tpb_byte_t tmp[16];\n\t\twhile (count > 16)\n\t\t{\n\t\t\tif (!pb_read(stream, tmp, 16))\n\t\t\t\treturn false;\n\t\t\t\n\t\t\tcount -= 16;\n\t\t}\n\t\t\n\t\treturn pb_read(stream, tmp, count);\n\t}\n#endif\n\n    if (stream->bytes_left < count)\n        PB_RETURN_ERROR(stream, \"end-of-stream\");\n    \n#ifndef PB_BUFFER_ONLY\n    if (!stream->callback(stream, buf, count))\n        PB_RETURN_ERROR(stream, \"io error\");\n#else\n    if (!buf_read(stream, buf, count))\n        return false;\n#endif\n    \n    stream->bytes_left -= count;\n    return true;\n}\n\n/* Read a single byte from input stream. buf may not be NULL.\n * This is an optimization for the varint decoding. */\nstatic bool checkreturn pb_readbyte(pb_istream_t *stream, pb_byte_t *buf)\n{\n    if (stream->bytes_left == 0)\n        PB_RETURN_ERROR(stream, \"end-of-stream\");\n\n#ifndef PB_BUFFER_ONLY\n    if (!stream->callback(stream, buf, 1))\n        PB_RETURN_ERROR(stream, \"io error\");\n#else\n    *buf = *(const pb_byte_t*)stream->state;\n    stream->state = (pb_byte_t*)stream->state + 1;\n#endif\n\n    stream->bytes_left--;\n    \n    return true;    \n}\n\npb_istream_t pb_istream_from_buffer(const pb_byte_t *buf, size_t bufsize)\n{\n    pb_istream_t stream;\n    /* Cast away the const from buf without a compiler error.  We are\n     * careful to use it only in a const manner in the callbacks.\n     */\n    union {\n        void *state;\n        const void *c_state;\n    } state;\n#ifdef PB_BUFFER_ONLY\n    stream.callback = NULL;\n#else\n    stream.callback = &buf_read;\n#endif\n    state.c_state = buf;\n    stream.state = state.state;\n    stream.bytes_left = bufsize;\n#ifndef PB_NO_ERRMSG\n    stream.errmsg = NULL;\n#endif\n    return stream;\n}\n\n/********************\n * Helper functions *\n ********************/\n\nstatic bool checkreturn pb_decode_varint32_eof(pb_istream_t *stream, uint32_t *dest, bool *eof)\n{\n    pb_byte_t byte;\n    uint32_t result;\n    \n    if (!pb_readbyte(stream, &byte))\n    {\n        if (stream->bytes_left == 0)\n        {\n            if (eof)\n            {\n                *eof = true;\n            }\n        }\n\n        return false;\n    }\n    \n    if ((byte & 0x80) == 0)\n    {\n        /* Quick case, 1 byte value */\n        result = byte;\n    }\n    else\n    {\n        /* Multibyte case */\n        uint_fast8_t bitpos = 7;\n        result = byte & 0x7F;\n        \n        do\n        {\n            if (!pb_readbyte(stream, &byte))\n                return false;\n            \n            if (bitpos >= 32)\n            {\n                /* Note: The varint could have trailing 0x80 bytes, or 0xFF for negative. */\n                uint8_t sign_extension = (bitpos < 63) ? 0xFF : 0x01;\n                \n                if ((byte & 0x7F) != 0x00 && ((result >> 31) == 0 || byte != sign_extension))\n                {\n                    PB_RETURN_ERROR(stream, \"varint overflow\");\n                }\n            }\n            else\n            {\n                result |= (uint32_t)(byte & 0x7F) << bitpos;\n            }\n            bitpos = (uint_fast8_t)(bitpos + 7);\n        } while (byte & 0x80);\n        \n        if (bitpos == 35 && (byte & 0x70) != 0)\n        {\n            /* The last byte was at bitpos=28, so only bottom 4 bits fit. */\n            PB_RETURN_ERROR(stream, \"varint overflow\");\n        }\n   }\n   \n   *dest = result;\n   return true;\n}\n\nbool checkreturn pb_decode_varint32(pb_istream_t *stream, uint32_t *dest)\n{\n    return pb_decode_varint32_eof(stream, dest, NULL);\n}\n\n#ifndef PB_WITHOUT_64BIT\nbool checkreturn pb_decode_varint(pb_istream_t *stream, uint64_t *dest)\n{\n    pb_byte_t byte;\n    uint_fast8_t bitpos = 0;\n    uint64_t result = 0;\n    \n    do\n    {\n        if (bitpos >= 64)\n            PB_RETURN_ERROR(stream, \"varint overflow\");\n        \n        if (!pb_readbyte(stream, &byte))\n            return false;\n\n        result |= (uint64_t)(byte & 0x7F) << bitpos;\n        bitpos = (uint_fast8_t)(bitpos + 7);\n    } while (byte & 0x80);\n    \n    *dest = result;\n    return true;\n}\n#endif\n\nbool checkreturn pb_skip_varint(pb_istream_t *stream)\n{\n    pb_byte_t byte;\n    do\n    {\n        if (!pb_read(stream, &byte, 1))\n            return false;\n    } while (byte & 0x80);\n    return true;\n}\n\nbool checkreturn pb_skip_string(pb_istream_t *stream)\n{\n    uint32_t length;\n    if (!pb_decode_varint32(stream, &length))\n        return false;\n    \n    return pb_read(stream, NULL, length);\n}\n\nbool checkreturn pb_decode_tag(pb_istream_t *stream, pb_wire_type_t *wire_type, uint32_t *tag, bool *eof)\n{\n    uint32_t temp;\n    *eof = false;\n    *wire_type = (pb_wire_type_t) 0;\n    *tag = 0;\n    \n    if (!pb_decode_varint32_eof(stream, &temp, eof))\n    {\n        return false;\n    }\n    \n    if (temp == 0)\n    {\n        *eof = true; /* Special feature: allow 0-terminated messages. */\n        return false;\n    }\n    \n    *tag = temp >> 3;\n    *wire_type = (pb_wire_type_t)(temp & 7);\n    return true;\n}\n\nbool checkreturn pb_skip_field(pb_istream_t *stream, pb_wire_type_t wire_type)\n{\n    switch (wire_type)\n    {\n        case PB_WT_VARINT: return pb_skip_varint(stream);\n        case PB_WT_64BIT: return pb_read(stream, NULL, 8);\n        case PB_WT_STRING: return pb_skip_string(stream);\n        case PB_WT_32BIT: return pb_read(stream, NULL, 4);\n        default: PB_RETURN_ERROR(stream, \"invalid wire_type\");\n    }\n}\n\n/* Read a raw value to buffer, for the purpose of passing it to callback as\n * a substream. Size is maximum size on call, and actual size on return.\n */\nstatic bool checkreturn read_raw_value(pb_istream_t *stream, pb_wire_type_t wire_type, pb_byte_t *buf, size_t *size)\n{\n    size_t max_size = *size;\n    switch (wire_type)\n    {\n        case PB_WT_VARINT:\n            *size = 0;\n            do\n            {\n                (*size)++;\n                if (*size > max_size) return false;\n                if (!pb_read(stream, buf, 1)) return false;\n            } while (*buf++ & 0x80);\n            return true;\n            \n        case PB_WT_64BIT:\n            *size = 8;\n            return pb_read(stream, buf, 8);\n        \n        case PB_WT_32BIT:\n            *size = 4;\n            return pb_read(stream, buf, 4);\n        \n        case PB_WT_STRING:\n            /* Calling read_raw_value with a PB_WT_STRING is an error.\n             * Explicitly handle this case and fallthrough to default to avoid\n             * compiler warnings.\n             */\n\n        default: PB_RETURN_ERROR(stream, \"invalid wire_type\");\n    }\n}\n\n/* Decode string length from stream and return a substream with limited length.\n * Remember to close the substream using pb_close_string_substream().\n */\nbool checkreturn pb_make_string_substream(pb_istream_t *stream, pb_istream_t *substream)\n{\n    uint32_t size;\n    if (!pb_decode_varint32(stream, &size))\n        return false;\n    \n    *substream = *stream;\n    if (substream->bytes_left < size)\n        PB_RETURN_ERROR(stream, \"parent stream too short\");\n    \n    substream->bytes_left = size;\n    stream->bytes_left -= size;\n    return true;\n}\n\nbool checkreturn pb_close_string_substream(pb_istream_t *stream, pb_istream_t *substream)\n{\n    if (substream->bytes_left) {\n        if (!pb_read(substream, NULL, substream->bytes_left))\n            return false;\n    }\n\n    stream->state = substream->state;\n\n#ifndef PB_NO_ERRMSG\n    stream->errmsg = substream->errmsg;\n#endif\n    return true;\n}\n\n/*************************\n * Decode a single field *\n *************************/\n\nstatic bool checkreturn decode_static_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter)\n{\n    pb_type_t type;\n    pb_decoder_t func;\n    \n    type = iter->pos->type;\n    func = PB_DECODERS[PB_LTYPE(type)];\n\n    switch (PB_HTYPE(type))\n    {\n        case PB_HTYPE_REQUIRED:\n            return func(stream, iter->pos, iter->pData);\n            \n        case PB_HTYPE_OPTIONAL:\n            if (iter->pSize != iter->pData)\n                *(bool*)iter->pSize = true;\n            return func(stream, iter->pos, iter->pData);\n    \n        case PB_HTYPE_REPEATED:\n            if (wire_type == PB_WT_STRING\n                && PB_LTYPE(type) <= PB_LTYPE_LAST_PACKABLE)\n            {\n                /* Packed array */\n                bool status = true;\n                pb_size_t *size = (pb_size_t*)iter->pSize;\n\n                pb_istream_t substream;\n                if (!pb_make_string_substream(stream, &substream))\n                    return false;\n\n                while (substream.bytes_left > 0 && *size < iter->pos->array_size)\n                {\n                    void *pItem = (char*)iter->pData + iter->pos->data_size * (*size);\n                    if (!func(&substream, iter->pos, pItem))\n                    {\n                        status = false;\n                        break;\n                    }\n                    (*size)++;\n                }\n\n                if (substream.bytes_left != 0)\n                    PB_RETURN_ERROR(stream, \"array overflow\");\n                if (!pb_close_string_substream(stream, &substream))\n                    return false;\n\n                return status;\n            }\n            else\n            {\n                /* Repeated field */\n                pb_size_t *size = (pb_size_t*)iter->pSize;\n                char *pItem = (char*)iter->pData + iter->pos->data_size * (*size);\n\n                if ((*size)++ >= iter->pos->array_size)\n                    PB_RETURN_ERROR(stream, \"array overflow\");\n\n                return func(stream, iter->pos, pItem);\n            }\n\n        case PB_HTYPE_ONEOF:\n            *(pb_size_t*)iter->pSize = iter->pos->tag;\n            if (PB_LTYPE(type) == PB_LTYPE_SUBMESSAGE)\n            {\n                /* We memset to zero so that any callbacks are set to NULL.\n                 * Then set any default values. */\n                memset(iter->pData, 0, iter->pos->data_size);\n                pb_message_set_to_defaults((const pb_field_t*)iter->pos->ptr, iter->pData);\n            }\n            return func(stream, iter->pos, iter->pData);\n\n        default:\n            PB_RETURN_ERROR(stream, \"invalid field type\");\n    }\n}\n\n#ifdef PB_ENABLE_MALLOC\n/* Allocate storage for the field and store the pointer at iter->pData.\n * array_size is the number of entries to reserve in an array.\n * Zero size is not allowed, use pb_free() for releasing.\n */\nstatic bool checkreturn allocate_field(pb_istream_t *stream, void *pData, size_t data_size, size_t array_size)\n{    \n    void *ptr = *(void**)pData;\n    \n    if (data_size == 0 || array_size == 0)\n        PB_RETURN_ERROR(stream, \"invalid size\");\n    \n#ifdef __AVR__\n    /* Workaround for AVR libc bug 53284: http://savannah.nongnu.org/bugs/?53284\n     * Realloc to size of 1 byte can cause corruption of the malloc structures.\n     */\n    if (data_size == 1 && array_size == 1)\n    {\n        data_size = 2;\n    }\n#endif\n\n    /* Check for multiplication overflows.\n     * This code avoids the costly division if the sizes are small enough.\n     * Multiplication is safe as long as only half of bits are set\n     * in either multiplicand.\n     */\n    {\n        const size_t check_limit = (size_t)1 << (sizeof(size_t) * 4);\n        if (data_size >= check_limit || array_size >= check_limit)\n        {\n            const size_t size_max = (size_t)-1;\n            if (size_max / array_size < data_size)\n            {\n                PB_RETURN_ERROR(stream, \"size too large\");\n            }\n        }\n    }\n    \n    /* Allocate new or expand previous allocation */\n    /* Note: on failure the old pointer will remain in the structure,\n     * the message must be freed by caller also on error return. */\n    ptr = pb_realloc(ptr, array_size * data_size);\n    if (ptr == NULL)\n        PB_RETURN_ERROR(stream, \"realloc failed\");\n    \n    *(void**)pData = ptr;\n    return true;\n}\n\n/* Clear a newly allocated item in case it contains a pointer, or is a submessage. */\nstatic void initialize_pointer_field(void *pItem, pb_field_iter_t *iter)\n{\n    if (PB_LTYPE(iter->pos->type) == PB_LTYPE_STRING ||\n        PB_LTYPE(iter->pos->type) == PB_LTYPE_BYTES)\n    {\n        *(void**)pItem = NULL;\n    }\n    else if (PB_LTYPE(iter->pos->type) == PB_LTYPE_SUBMESSAGE)\n    {\n        /* We memset to zero so that any callbacks are set to NULL.\n         * Then set any default values. */\n        memset(pItem, 0, iter->pos->data_size);\n        pb_message_set_to_defaults((const pb_field_t *) iter->pos->ptr, pItem);\n    }\n}\n#endif\n\nstatic bool checkreturn decode_pointer_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter)\n{\n#ifndef PB_ENABLE_MALLOC\n    PB_UNUSED(wire_type);\n    PB_UNUSED(iter);\n    PB_RETURN_ERROR(stream, \"no malloc support\");\n#else\n    pb_type_t type;\n    pb_decoder_t func;\n    \n    type = iter->pos->type;\n    func = PB_DECODERS[PB_LTYPE(type)];\n    \n    switch (PB_HTYPE(type))\n    {\n        case PB_HTYPE_REQUIRED:\n        case PB_HTYPE_OPTIONAL:\n        case PB_HTYPE_ONEOF:\n            if (PB_LTYPE(type) == PB_LTYPE_SUBMESSAGE &&\n                *(void**)iter->pData != NULL)\n            {\n                /* Duplicate field, have to release the old allocation first. */\n                pb_release_single_field(iter);\n            }\n        \n            if (PB_HTYPE(type) == PB_HTYPE_ONEOF)\n            {\n                *(pb_size_t*)iter->pSize = iter->pos->tag;\n            }\n\n            if (PB_LTYPE(type) == PB_LTYPE_STRING ||\n                PB_LTYPE(type) == PB_LTYPE_BYTES)\n            {\n                return func(stream, iter->pos, iter->pData);\n            }\n            else\n            {\n                if (!allocate_field(stream, iter->pData, iter->pos->data_size, 1))\n                    return false;\n                \n                initialize_pointer_field(*(void**)iter->pData, iter);\n                return func(stream, iter->pos, *(void**)iter->pData);\n            }\n    \n        case PB_HTYPE_REPEATED:\n            if (wire_type == PB_WT_STRING\n                && PB_LTYPE(type) <= PB_LTYPE_LAST_PACKABLE)\n            {\n                /* Packed array, multiple items come in at once. */\n                bool status = true;\n                pb_size_t *size = (pb_size_t*)iter->pSize;\n                size_t allocated_size = *size;\n                void *pItem;\n                pb_istream_t substream;\n                \n                if (!pb_make_string_substream(stream, &substream))\n                    return false;\n                \n                while (substream.bytes_left)\n                {\n                    if (*size == PB_SIZE_MAX)\n                    {\n#ifndef PB_NO_ERRMSG\n                        stream->errmsg = \"too many array entries\";\n#endif\n                        status = false;\n                        break;\n                    }\n\n                    if ((size_t)*size + 1 > allocated_size)\n                    {\n                        /* Allocate more storage. This tries to guess the\n                         * number of remaining entries. Round the division\n                         * upwards. */\n                        size_t remain = (substream.bytes_left - 1) / iter->pos->data_size + 1;\n                        if (remain < PB_SIZE_MAX - allocated_size)\n                            allocated_size += remain;\n                        else\n                            allocated_size += 1;\n                        \n                        if (!allocate_field(&substream, iter->pData, iter->pos->data_size, allocated_size))\n                        {\n                            status = false;\n                            break;\n                        }\n                    }\n\n                    /* Decode the array entry */\n                    pItem = *(char**)iter->pData + iter->pos->data_size * (*size);\n                    initialize_pointer_field(pItem, iter);\n                    if (!func(&substream, iter->pos, pItem))\n                    {\n                        status = false;\n                        break;\n                    }\n                    \n                    (*size)++;\n                }\n                if (!pb_close_string_substream(stream, &substream))\n                    return false;\n                \n                return status;\n            }\n            else\n            {\n                /* Normal repeated field, i.e. only one item at a time. */\n                pb_size_t *size = (pb_size_t*)iter->pSize;\n                void *pItem;\n                \n                if (*size == PB_SIZE_MAX)\n                    PB_RETURN_ERROR(stream, \"too many array entries\");\n                \n                if (!allocate_field(stream, iter->pData, iter->pos->data_size, (size_t)(*size + 1)))\n                    return false;\n            \n                pItem = *(char**)iter->pData + iter->pos->data_size * (*size);\n                (*size)++;\n                initialize_pointer_field(pItem, iter);\n                return func(stream, iter->pos, pItem);\n            }\n\n        default:\n            PB_RETURN_ERROR(stream, \"invalid field type\");\n    }\n#endif\n}\n\nstatic bool checkreturn decode_callback_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter)\n{\n    pb_callback_t *pCallback = (pb_callback_t*)iter->pData;\n#ifdef PB_OLD_CALLBACK_STYLE\n    void *arg;\n#else\n    void **arg;\n#endif\n    \n    if (pCallback == NULL || pCallback->funcs.decode == NULL)\n        return pb_skip_field(stream, wire_type);\n\n#ifdef PB_OLD_CALLBACK_STYLE\n    arg = pCallback->arg;\n#else\n    arg = &(pCallback->arg);\n#endif\n    \n    if (wire_type == PB_WT_STRING)\n    {\n        pb_istream_t substream;\n        \n        if (!pb_make_string_substream(stream, &substream))\n            return false;\n        \n        do\n        {\n            if (!pCallback->funcs.decode(&substream, iter->pos, arg))\n                PB_RETURN_ERROR(stream, \"callback failed\");\n        } while (substream.bytes_left);\n        \n        if (!pb_close_string_substream(stream, &substream))\n            return false;\n\n        return true;\n    }\n    else\n    {\n        /* Copy the single scalar value to stack.\n         * This is required so that we can limit the stream length,\n         * which in turn allows to use same callback for packed and\n         * not-packed fields. */\n        pb_istream_t substream;\n        pb_byte_t buffer[10];\n        size_t size = sizeof(buffer);\n        \n        if (!read_raw_value(stream, wire_type, buffer, &size))\n            return false;\n        substream = pb_istream_from_buffer(buffer, size);\n        \n        return pCallback->funcs.decode(&substream, iter->pos, arg);\n    }\n}\n\nstatic bool checkreturn decode_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter)\n{\n#ifdef PB_ENABLE_MALLOC\n    /* When decoding an oneof field, check if there is old data that must be\n     * released first. */\n    if (PB_HTYPE(iter->pos->type) == PB_HTYPE_ONEOF)\n    {\n        if (!pb_release_union_field(stream, iter))\n            return false;\n    }\n#endif\n\n    switch (PB_ATYPE(iter->pos->type))\n    {\n        case PB_ATYPE_STATIC:\n            return decode_static_field(stream, wire_type, iter);\n        \n        case PB_ATYPE_POINTER:\n            return decode_pointer_field(stream, wire_type, iter);\n        \n        case PB_ATYPE_CALLBACK:\n            return decode_callback_field(stream, wire_type, iter);\n        \n        default:\n            PB_RETURN_ERROR(stream, \"invalid field type\");\n    }\n}\n\nstatic void iter_from_extension(pb_field_iter_t *iter, pb_extension_t *extension)\n{\n    /* Fake a field iterator for the extension field.\n     * It is not actually safe to advance this iterator, but decode_field\n     * will not even try to. */\n    const pb_field_t *field = (const pb_field_t*)extension->type->arg;\n    (void)pb_field_iter_begin(iter, field, extension->dest);\n    iter->pData = extension->dest;\n    iter->pSize = &extension->found;\n    \n    if (PB_ATYPE(field->type) == PB_ATYPE_POINTER)\n    {\n        /* For pointer extensions, the pointer is stored directly\n         * in the extension structure. This avoids having an extra\n         * indirection. */\n        iter->pData = &extension->dest;\n    }\n}\n\n/* Default handler for extension fields. Expects a pb_field_t structure\n * in extension->type->arg. */\nstatic bool checkreturn default_extension_decoder(pb_istream_t *stream,\n    pb_extension_t *extension, uint32_t tag, pb_wire_type_t wire_type)\n{\n    const pb_field_t *field = (const pb_field_t*)extension->type->arg;\n    pb_field_iter_t iter;\n    \n    if (field->tag != tag)\n        return true;\n    \n    iter_from_extension(&iter, extension);\n    extension->found = true;\n    return decode_field(stream, wire_type, &iter);\n}\n\n/* Try to decode an unknown field as an extension field. Tries each extension\n * decoder in turn, until one of them handles the field or loop ends. */\nstatic bool checkreturn decode_extension(pb_istream_t *stream,\n    uint32_t tag, pb_wire_type_t wire_type, pb_field_iter_t *iter)\n{\n    pb_extension_t *extension = *(pb_extension_t* const *)iter->pData;\n    size_t pos = stream->bytes_left;\n    \n    while (extension != NULL && pos == stream->bytes_left)\n    {\n        bool status;\n        if (extension->type->decode)\n            status = extension->type->decode(stream, extension, tag, wire_type);\n        else\n            status = default_extension_decoder(stream, extension, tag, wire_type);\n\n        if (!status)\n            return false;\n        \n        extension = extension->next;\n    }\n    \n    return true;\n}\n\n/* Step through the iterator until an extension field is found or until all\n * entries have been checked. There can be only one extension field per\n * message. Returns false if no extension field is found. */\nstatic bool checkreturn find_extension_field(pb_field_iter_t *iter)\n{\n    const pb_field_t *start = iter->pos;\n    \n    do {\n        if (PB_LTYPE(iter->pos->type) == PB_LTYPE_EXTENSION)\n            return true;\n        (void)pb_field_iter_next(iter);\n    } while (iter->pos != start);\n    \n    return false;\n}\n\n/* Initialize message fields to default values, recursively */\nstatic void pb_field_set_to_default(pb_field_iter_t *iter)\n{\n    pb_type_t type;\n    type = iter->pos->type;\n    \n    if (PB_LTYPE(type) == PB_LTYPE_EXTENSION)\n    {\n        pb_extension_t *ext = *(pb_extension_t* const *)iter->pData;\n        while (ext != NULL)\n        {\n            pb_field_iter_t ext_iter;\n            ext->found = false;\n            iter_from_extension(&ext_iter, ext);\n            pb_field_set_to_default(&ext_iter);\n            ext = ext->next;\n        }\n    }\n    else if (PB_ATYPE(type) == PB_ATYPE_STATIC)\n    {\n        bool init_data = true;\n        if (PB_HTYPE(type) == PB_HTYPE_OPTIONAL && iter->pSize != iter->pData)\n        {\n            /* Set has_field to false. Still initialize the optional field\n             * itself also. */\n            *(bool*)iter->pSize = false;\n        }\n        else if (PB_HTYPE(type) == PB_HTYPE_REPEATED ||\n                 PB_HTYPE(type) == PB_HTYPE_ONEOF)\n        {\n            /* REPEATED: Set array count to 0, no need to initialize contents.\n               ONEOF: Set which_field to 0. */\n            *(pb_size_t*)iter->pSize = 0;\n            init_data = false;\n        }\n\n        if (init_data)\n        {\n            if (PB_LTYPE(iter->pos->type) == PB_LTYPE_SUBMESSAGE)\n            {\n                /* Initialize submessage to defaults */\n                pb_message_set_to_defaults((const pb_field_t *) iter->pos->ptr, iter->pData);\n            }\n            else if (iter->pos->ptr != NULL)\n            {\n                /* Initialize to default value */\n                memcpy(iter->pData, iter->pos->ptr, iter->pos->data_size);\n            }\n            else\n            {\n                /* Initialize to zeros */\n                memset(iter->pData, 0, iter->pos->data_size);\n            }\n        }\n    }\n    else if (PB_ATYPE(type) == PB_ATYPE_POINTER)\n    {\n        /* Initialize the pointer to NULL. */\n        *(void**)iter->pData = NULL;\n        \n        /* Initialize array count to 0. */\n        if (PB_HTYPE(type) == PB_HTYPE_REPEATED ||\n            PB_HTYPE(type) == PB_HTYPE_ONEOF)\n        {\n            *(pb_size_t*)iter->pSize = 0;\n        }\n    }\n    else if (PB_ATYPE(type) == PB_ATYPE_CALLBACK)\n    {\n        /* Don't overwrite callback */\n    }\n}\n\nstatic void pb_message_set_to_defaults(const pb_field_t fields[], void *dest_struct)\n{\n    pb_field_iter_t iter;\n\n    if (!pb_field_iter_begin(&iter, fields, dest_struct))\n        return; /* Empty message type */\n    \n    do\n    {\n        pb_field_set_to_default(&iter);\n    } while (pb_field_iter_next(&iter));\n}\n\n/*********************\n * Decode all fields *\n *********************/\n\nbool checkreturn pb_decode_noinit(pb_istream_t *stream, const pb_field_t fields[], void *dest_struct)\n{\n    uint32_t fields_seen[(PB_MAX_REQUIRED_FIELDS + 31) / 32] = {0, 0};\n    const uint32_t allbits = ~(uint32_t)0;\n    uint32_t extension_range_start = 0;\n    pb_field_iter_t iter;\n\n    /* 'fixed_count_field' and 'fixed_count_size' track position of a repeated fixed\n     * count field. This can only handle _one_ repeated fixed count field that\n     * is unpacked and unordered among other (non repeated fixed count) fields.\n     */\n    const pb_field_t *fixed_count_field = NULL;\n    pb_size_t fixed_count_size = 0;\n\n    /* Return value ignored, as empty message types will be correctly handled by\n     * pb_field_iter_find() anyway. */\n    (void)pb_field_iter_begin(&iter, fields, dest_struct);\n\n    while (stream->bytes_left)\n    {\n        uint32_t tag;\n        pb_wire_type_t wire_type;\n        bool eof;\n\n        if (!pb_decode_tag(stream, &wire_type, &tag, &eof))\n        {\n            if (eof)\n                break;\n            else\n                return false;\n        }\n\n        if (!pb_field_iter_find(&iter, tag))\n        {\n            /* No match found, check if it matches an extension. */\n            if (tag >= extension_range_start)\n            {\n                if (!find_extension_field(&iter))\n                    extension_range_start = (uint32_t)-1;\n                else\n                    extension_range_start = iter.pos->tag;\n\n                if (tag >= extension_range_start)\n                {\n                    size_t pos = stream->bytes_left;\n\n                    if (!decode_extension(stream, tag, wire_type, &iter))\n                        return false;\n\n                    if (pos != stream->bytes_left)\n                    {\n                        /* The field was handled */\n                        continue;\n                    }\n                }\n            }\n\n            /* No match found, skip data */\n            if (!pb_skip_field(stream, wire_type))\n                return false;\n            continue;\n        }\n\n        /* If a repeated fixed count field was found, get size from\n         * 'fixed_count_field' as there is no counter contained in the struct.\n         */\n        if (PB_HTYPE(iter.pos->type) == PB_HTYPE_REPEATED\n            && iter.pSize == iter.pData)\n        {\n            if (fixed_count_field != iter.pos) {\n                /* If the new fixed count field does not match the previous one,\n                 * check that the previous one is NULL or that it finished\n                 * receiving all the expected data.\n                 */\n                if (fixed_count_field != NULL &&\n                    fixed_count_size != fixed_count_field->array_size)\n                {\n                    PB_RETURN_ERROR(stream, \"wrong size for fixed count field\");\n                }\n\n                fixed_count_field = iter.pos;\n                fixed_count_size = 0;\n            }\n\n            iter.pSize = &fixed_count_size;\n        }\n\n        if (PB_HTYPE(iter.pos->type) == PB_HTYPE_REQUIRED\n            && iter.required_field_index < PB_MAX_REQUIRED_FIELDS)\n        {\n            uint32_t tmp = ((uint32_t)1 << (iter.required_field_index & 31));\n            fields_seen[iter.required_field_index >> 5] |= tmp;\n        }\n\n        if (!decode_field(stream, wire_type, &iter))\n            return false;\n    }\n\n    /* Check that all elements of the last decoded fixed count field were present. */\n    if (fixed_count_field != NULL &&\n        fixed_count_size != fixed_count_field->array_size)\n    {\n        PB_RETURN_ERROR(stream, \"wrong size for fixed count field\");\n    }\n\n    /* Check that all required fields were present. */\n    {\n        /* First figure out the number of required fields by\n         * seeking to the end of the field array. Usually we\n         * are already close to end after decoding.\n         */\n        unsigned req_field_count;\n        pb_type_t last_type;\n        unsigned i;\n        do {\n            req_field_count = iter.required_field_index;\n            last_type = iter.pos->type;\n        } while (pb_field_iter_next(&iter));\n        \n        /* Fixup if last field was also required. */\n        if (PB_HTYPE(last_type) == PB_HTYPE_REQUIRED && iter.pos->tag != 0)\n            req_field_count++;\n        \n        if (req_field_count > PB_MAX_REQUIRED_FIELDS)\n            req_field_count = PB_MAX_REQUIRED_FIELDS;\n\n        if (req_field_count > 0)\n        {\n            /* Check the whole words */\n            for (i = 0; i < (req_field_count >> 5); i++)\n            {\n                if (fields_seen[i] != allbits)\n                    PB_RETURN_ERROR(stream, \"missing required field\");\n            }\n            \n            /* Check the remaining bits (if any) */\n            if ((req_field_count & 31) != 0)\n            {\n                if (fields_seen[req_field_count >> 5] !=\n                    (allbits >> (32 - (req_field_count & 31))))\n                {\n                    PB_RETURN_ERROR(stream, \"missing required field\");\n                }\n            }\n        }\n    }\n    \n    return true;\n}\n\nbool checkreturn pb_decode(pb_istream_t *stream, const pb_field_t fields[], void *dest_struct)\n{\n    bool status;\n    pb_message_set_to_defaults(fields, dest_struct);\n    status = pb_decode_noinit(stream, fields, dest_struct);\n    \n#ifdef PB_ENABLE_MALLOC\n    if (!status)\n        pb_release(fields, dest_struct);\n#endif\n    \n    return status;\n}\n\nbool pb_decode_delimited_noinit(pb_istream_t *stream, const pb_field_t fields[], void *dest_struct)\n{\n    pb_istream_t substream;\n    bool status;\n\n    if (!pb_make_string_substream(stream, &substream))\n        return false;\n\n    status = pb_decode_noinit(&substream, fields, dest_struct);\n\n    if (!pb_close_string_substream(stream, &substream))\n        return false;\n    return status;\n}\n\nbool pb_decode_delimited(pb_istream_t *stream, const pb_field_t fields[], void *dest_struct)\n{\n    pb_istream_t substream;\n    bool status;\n    \n    if (!pb_make_string_substream(stream, &substream))\n        return false;\n    \n    status = pb_decode(&substream, fields, dest_struct);\n\n    if (!pb_close_string_substream(stream, &substream))\n        return false;\n    return status;\n}\n\nbool pb_decode_nullterminated(pb_istream_t *stream, const pb_field_t fields[], void *dest_struct)\n{\n    /* This behaviour will be separated in nanopb-0.4.0, see issue #278. */\n    return pb_decode(stream, fields, dest_struct);\n}\n\n#ifdef PB_ENABLE_MALLOC\n/* Given an oneof field, if there has already been a field inside this oneof,\n * release it before overwriting with a different one. */\nstatic bool pb_release_union_field(pb_istream_t *stream, pb_field_iter_t *iter)\n{\n    pb_size_t old_tag = *(pb_size_t*)iter->pSize; /* Previous which_ value */\n    pb_size_t new_tag = iter->pos->tag; /* New which_ value */\n\n    if (old_tag == 0)\n        return true; /* Ok, no old data in union */\n\n    if (old_tag == new_tag)\n        return true; /* Ok, old data is of same type => merge */\n\n    /* Release old data. The find can fail if the message struct contains\n     * invalid data. */\n    if (!pb_field_iter_find(iter, old_tag))\n        PB_RETURN_ERROR(stream, \"invalid union tag\");\n\n    pb_release_single_field(iter);\n\n    /* Restore iterator to where it should be.\n     * This shouldn't fail unless the pb_field_t structure is corrupted. */\n    if (!pb_field_iter_find(iter, new_tag))\n        PB_RETURN_ERROR(stream, \"iterator error\");\n    \n    return true;\n}\n\nstatic void pb_release_single_field(const pb_field_iter_t *iter)\n{\n    pb_type_t type;\n    type = iter->pos->type;\n\n    if (PB_HTYPE(type) == PB_HTYPE_ONEOF)\n    {\n        if (*(pb_size_t*)iter->pSize != iter->pos->tag)\n            return; /* This is not the current field in the union */\n    }\n\n    /* Release anything contained inside an extension or submsg.\n     * This has to be done even if the submsg itself is statically\n     * allocated. */\n    if (PB_LTYPE(type) == PB_LTYPE_EXTENSION)\n    {\n        /* Release fields from all extensions in the linked list */\n        pb_extension_t *ext = *(pb_extension_t**)iter->pData;\n        while (ext != NULL)\n        {\n            pb_field_iter_t ext_iter;\n            iter_from_extension(&ext_iter, ext);\n            pb_release_single_field(&ext_iter);\n            ext = ext->next;\n        }\n    }\n    else if (PB_LTYPE(type) == PB_LTYPE_SUBMESSAGE && PB_ATYPE(type) != PB_ATYPE_CALLBACK)\n    {\n        /* Release fields in submessage or submsg array */\n        void *pItem = iter->pData;\n        pb_size_t count = 1;\n        \n        if (PB_ATYPE(type) == PB_ATYPE_POINTER)\n        {\n            pItem = *(void**)iter->pData;\n        }\n        \n        if (PB_HTYPE(type) == PB_HTYPE_REPEATED)\n        {\n            if (PB_ATYPE(type) == PB_ATYPE_STATIC && iter->pSize == iter->pData) {\n                /* No _count field so use size of the array */\n                count = iter->pos->array_size;\n            } else {\n                count = *(pb_size_t*)iter->pSize;\n            }\n\n            if (PB_ATYPE(type) == PB_ATYPE_STATIC && count > iter->pos->array_size)\n            {\n                /* Protect against corrupted _count fields */\n                count = iter->pos->array_size;\n            }\n        }\n        \n        if (pItem)\n        {\n            while (count--)\n            {\n                pb_release((const pb_field_t*)iter->pos->ptr, pItem);\n                pItem = (char*)pItem + iter->pos->data_size;\n            }\n        }\n    }\n    \n    if (PB_ATYPE(type) == PB_ATYPE_POINTER)\n    {\n        if (PB_HTYPE(type) == PB_HTYPE_REPEATED &&\n            (PB_LTYPE(type) == PB_LTYPE_STRING ||\n             PB_LTYPE(type) == PB_LTYPE_BYTES))\n        {\n            /* Release entries in repeated string or bytes array */\n            void **pItem = *(void***)iter->pData;\n            pb_size_t count = *(pb_size_t*)iter->pSize;\n            while (count--)\n            {\n                pb_free(*pItem);\n                *pItem++ = NULL;\n            }\n        }\n        \n        if (PB_HTYPE(type) == PB_HTYPE_REPEATED)\n        {\n            /* We are going to release the array, so set the size to 0 */\n            *(pb_size_t*)iter->pSize = 0;\n        }\n        \n        /* Release main item */\n        pb_free(*(void**)iter->pData);\n        *(void**)iter->pData = NULL;\n    }\n}\n\nvoid pb_release(const pb_field_t fields[], void *dest_struct)\n{\n    pb_field_iter_t iter;\n    \n    if (!dest_struct)\n        return; /* Ignore NULL pointers, similar to free() */\n\n    if (!pb_field_iter_begin(&iter, fields, dest_struct))\n        return; /* Empty message type */\n    \n    do\n    {\n        pb_release_single_field(&iter);\n    } while (pb_field_iter_next(&iter));\n}\n#endif\n\n/* Field decoders */\n\nbool pb_decode_bool(pb_istream_t *stream, bool *dest)\n{\n    return pb_dec_bool(stream, NULL, (void*)dest);\n}\n\nbool pb_decode_svarint(pb_istream_t *stream, pb_int64_t *dest)\n{\n    pb_uint64_t value;\n    if (!pb_decode_varint(stream, &value))\n        return false;\n    \n    if (value & 1)\n        *dest = (pb_int64_t)(~(value >> 1));\n    else\n        *dest = (pb_int64_t)(value >> 1);\n    \n    return true;\n}\n\nbool pb_decode_fixed32(pb_istream_t *stream, void *dest)\n{\n    pb_byte_t bytes[4];\n\n    if (!pb_read(stream, bytes, 4))\n        return false;\n    \n    *(uint32_t*)dest = ((uint32_t)bytes[0] << 0) |\n                       ((uint32_t)bytes[1] << 8) |\n                       ((uint32_t)bytes[2] << 16) |\n                       ((uint32_t)bytes[3] << 24);\n    return true;\n}\n\n#ifndef PB_WITHOUT_64BIT\nbool pb_decode_fixed64(pb_istream_t *stream, void *dest)\n{\n    pb_byte_t bytes[8];\n\n    if (!pb_read(stream, bytes, 8))\n        return false;\n    \n    *(uint64_t*)dest = ((uint64_t)bytes[0] << 0) |\n                       ((uint64_t)bytes[1] << 8) |\n                       ((uint64_t)bytes[2] << 16) |\n                       ((uint64_t)bytes[3] << 24) |\n                       ((uint64_t)bytes[4] << 32) |\n                       ((uint64_t)bytes[5] << 40) |\n                       ((uint64_t)bytes[6] << 48) |\n                       ((uint64_t)bytes[7] << 56);\n    \n    return true;\n}\n#endif\n\nstatic bool checkreturn pb_dec_bool(pb_istream_t *stream, const pb_field_t *field, void *dest)\n{\n    uint32_t value;\n    PB_UNUSED(field);\n    if (!pb_decode_varint32(stream, &value))\n        return false;\n\n    *(bool*)dest = (value != 0);\n    return true;\n}\n\nstatic bool checkreturn pb_dec_varint(pb_istream_t *stream, const pb_field_t *field, void *dest)\n{\n    pb_uint64_t value;\n    pb_int64_t svalue;\n    pb_int64_t clamped;\n    if (!pb_decode_varint(stream, &value))\n        return false;\n    \n    /* See issue 97: Google's C++ protobuf allows negative varint values to\n     * be cast as int32_t, instead of the int64_t that should be used when\n     * encoding. Previous nanopb versions had a bug in encoding. In order to\n     * not break decoding of such messages, we cast <=32 bit fields to\n     * int32_t first to get the sign correct.\n     */\n    if (field->data_size == sizeof(pb_int64_t))\n        svalue = (pb_int64_t)value;\n    else\n        svalue = (int32_t)value;\n\n    /* Cast to the proper field size, while checking for overflows */\n    if (field->data_size == sizeof(pb_int64_t))\n        clamped = *(pb_int64_t*)dest = svalue;\n    else if (field->data_size == sizeof(int32_t))\n        clamped = *(int32_t*)dest = (int32_t)svalue;\n    else if (field->data_size == sizeof(int_least16_t))\n        clamped = *(int_least16_t*)dest = (int_least16_t)svalue;\n    else if (field->data_size == sizeof(int_least8_t))\n        clamped = *(int_least8_t*)dest = (int_least8_t)svalue;\n    else\n        PB_RETURN_ERROR(stream, \"invalid data_size\");\n\n    if (clamped != svalue)\n        PB_RETURN_ERROR(stream, \"integer too large\");\n    \n    return true;\n}\n\nstatic bool checkreturn pb_dec_uvarint(pb_istream_t *stream, const pb_field_t *field, void *dest)\n{\n    pb_uint64_t value, clamped;\n    if (!pb_decode_varint(stream, &value))\n        return false;\n    \n    /* Cast to the proper field size, while checking for overflows */\n    if (field->data_size == sizeof(pb_uint64_t))\n        clamped = *(pb_uint64_t*)dest = value;\n    else if (field->data_size == sizeof(uint32_t))\n        clamped = *(uint32_t*)dest = (uint32_t)value;\n    else if (field->data_size == sizeof(uint_least16_t))\n        clamped = *(uint_least16_t*)dest = (uint_least16_t)value;\n    else if (field->data_size == sizeof(uint_least8_t))\n        clamped = *(uint_least8_t*)dest = (uint_least8_t)value;\n    else\n        PB_RETURN_ERROR(stream, \"invalid data_size\");\n    \n    if (clamped != value)\n        PB_RETURN_ERROR(stream, \"integer too large\");\n\n    return true;\n}\n\nstatic bool checkreturn pb_dec_svarint(pb_istream_t *stream, const pb_field_t *field, void *dest)\n{\n    pb_int64_t value, clamped;\n    if (!pb_decode_svarint(stream, &value))\n        return false;\n    \n    /* Cast to the proper field size, while checking for overflows */\n    if (field->data_size == sizeof(pb_int64_t))\n        clamped = *(pb_int64_t*)dest = value;\n    else if (field->data_size == sizeof(int32_t))\n        clamped = *(int32_t*)dest = (int32_t)value;\n    else if (field->data_size == sizeof(int_least16_t))\n        clamped = *(int_least16_t*)dest = (int_least16_t)value;\n    else if (field->data_size == sizeof(int_least8_t))\n        clamped = *(int_least8_t*)dest = (int_least8_t)value;\n    else\n        PB_RETURN_ERROR(stream, \"invalid data_size\");\n\n    if (clamped != value)\n        PB_RETURN_ERROR(stream, \"integer too large\");\n    \n    return true;\n}\n\nstatic bool checkreturn pb_dec_fixed32(pb_istream_t *stream, const pb_field_t *field, void *dest)\n{\n    PB_UNUSED(field);\n    return pb_decode_fixed32(stream, dest);\n}\n\nstatic bool checkreturn pb_dec_fixed64(pb_istream_t *stream, const pb_field_t *field, void *dest)\n{\n    PB_UNUSED(field);\n#ifndef PB_WITHOUT_64BIT\n    return pb_decode_fixed64(stream, dest);\n#else\n    PB_UNUSED(dest);\n    PB_RETURN_ERROR(stream, \"no 64bit support\");\n#endif\n}\n\nstatic bool checkreturn pb_dec_bytes(pb_istream_t *stream, const pb_field_t *field, void *dest)\n{\n    uint32_t size;\n    size_t alloc_size;\n    pb_bytes_array_t *bdest;\n    \n    if (!pb_decode_varint32(stream, &size))\n        return false;\n    \n    if (size > PB_SIZE_MAX)\n        PB_RETURN_ERROR(stream, \"bytes overflow\");\n    \n    alloc_size = PB_BYTES_ARRAY_T_ALLOCSIZE(size);\n    if (size > alloc_size)\n        PB_RETURN_ERROR(stream, \"size too large\");\n    \n    if (PB_ATYPE(field->type) == PB_ATYPE_POINTER)\n    {\n#ifndef PB_ENABLE_MALLOC\n        PB_RETURN_ERROR(stream, \"no malloc support\");\n#else\n        if (!allocate_field(stream, dest, alloc_size, 1))\n            return false;\n        bdest = *(pb_bytes_array_t**)dest;\n#endif\n    }\n    else\n    {\n        if (alloc_size > field->data_size)\n            PB_RETURN_ERROR(stream, \"bytes overflow\");\n        bdest = (pb_bytes_array_t*)dest;\n    }\n\n    bdest->size = (pb_size_t)size;\n    return pb_read(stream, bdest->bytes, size);\n}\n\nstatic bool checkreturn pb_dec_string(pb_istream_t *stream, const pb_field_t *field, void *dest)\n{\n    uint32_t size;\n    size_t alloc_size;\n    bool status;\n    if (!pb_decode_varint32(stream, &size))\n        return false;\n    \n    /* Space for null terminator */\n    alloc_size = size + 1;\n    \n    if (alloc_size < size)\n        PB_RETURN_ERROR(stream, \"size too large\");\n    \n    if (PB_ATYPE(field->type) == PB_ATYPE_POINTER)\n    {\n#ifndef PB_ENABLE_MALLOC\n        PB_RETURN_ERROR(stream, \"no malloc support\");\n#else\n        if (!allocate_field(stream, dest, alloc_size, 1))\n            return false;\n        dest = *(void**)dest;\n#endif\n    }\n    else\n    {\n        if (alloc_size > field->data_size)\n            PB_RETURN_ERROR(stream, \"string overflow\");\n    }\n    \n    status = pb_read(stream, (pb_byte_t*)dest, size);\n    *((pb_byte_t*)dest + size) = 0;\n    return status;\n}\n\nstatic bool checkreturn pb_dec_submessage(pb_istream_t *stream, const pb_field_t *field, void *dest)\n{\n    bool status;\n    pb_istream_t substream;\n    const pb_field_t* submsg_fields = (const pb_field_t*)field->ptr;\n    \n    if (!pb_make_string_substream(stream, &substream))\n        return false;\n    \n    if (field->ptr == NULL)\n        PB_RETURN_ERROR(stream, \"invalid field descriptor\");\n    \n    /* New array entries need to be initialized, while required and optional\n     * submessages have already been initialized in the top-level pb_decode. */\n    if (PB_HTYPE(field->type) == PB_HTYPE_REPEATED)\n        status = pb_decode(&substream, submsg_fields, dest);\n    else\n        status = pb_decode_noinit(&substream, submsg_fields, dest);\n    \n    if (!pb_close_string_substream(stream, &substream))\n        return false;\n    return status;\n}\n\nstatic bool checkreturn pb_dec_fixed_length_bytes(pb_istream_t *stream, const pb_field_t *field, void *dest)\n{\n    uint32_t size;\n\n    if (!pb_decode_varint32(stream, &size))\n        return false;\n\n    if (size > PB_SIZE_MAX)\n        PB_RETURN_ERROR(stream, \"bytes overflow\");\n\n    if (size == 0)\n    {\n        /* As a special case, treat empty bytes string as all zeros for fixed_length_bytes. */\n        memset(dest, 0, field->data_size);\n        return true;\n    }\n\n    if (size != field->data_size)\n        PB_RETURN_ERROR(stream, \"incorrect fixed length bytes size\");\n\n    return pb_read(stream, (pb_byte_t*)dest, field->data_size);\n}\n"], "fixing_code": ["/* pb_decode.c -- decode a protobuf using minimal resources\n *\n * 2011 Petteri Aimonen <jpa@kapsi.fi>\n */\n\n/* Use the GCC warn_unused_result attribute to check that all return values\n * are propagated correctly. On other compilers and gcc before 3.4.0 just\n * ignore the annotation.\n */\n#if !defined(__GNUC__) || ( __GNUC__ < 3) || (__GNUC__ == 3 && __GNUC_MINOR__ < 4)\n    #define checkreturn\n#else\n    #define checkreturn __attribute__((warn_unused_result))\n#endif\n\n#include \"pb.h\"\n#include \"pb_decode.h\"\n#include \"pb_common.h\"\n\n/**************************************\n * Declarations internal to this file *\n **************************************/\n\ntypedef bool (*pb_decoder_t)(pb_istream_t *stream, const pb_field_t *field, void *dest) checkreturn;\n\nstatic bool checkreturn buf_read(pb_istream_t *stream, pb_byte_t *buf, size_t count);\nstatic bool checkreturn read_raw_value(pb_istream_t *stream, pb_wire_type_t wire_type, pb_byte_t *buf, size_t *size);\nstatic bool checkreturn decode_static_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter);\nstatic bool checkreturn decode_callback_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter);\nstatic bool checkreturn decode_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter);\nstatic void iter_from_extension(pb_field_iter_t *iter, pb_extension_t *extension);\nstatic bool checkreturn default_extension_decoder(pb_istream_t *stream, pb_extension_t *extension, uint32_t tag, pb_wire_type_t wire_type);\nstatic bool checkreturn decode_extension(pb_istream_t *stream, uint32_t tag, pb_wire_type_t wire_type, pb_field_iter_t *iter);\nstatic bool checkreturn find_extension_field(pb_field_iter_t *iter);\nstatic void pb_field_set_to_default(pb_field_iter_t *iter);\nstatic void pb_message_set_to_defaults(const pb_field_t fields[], void *dest_struct);\nstatic bool checkreturn pb_dec_bool(pb_istream_t *stream, const pb_field_t *field, void *dest);\nstatic bool checkreturn pb_dec_varint(pb_istream_t *stream, const pb_field_t *field, void *dest);\nstatic bool checkreturn pb_decode_varint32_eof(pb_istream_t *stream, uint32_t *dest, bool *eof);\nstatic bool checkreturn pb_dec_uvarint(pb_istream_t *stream, const pb_field_t *field, void *dest);\nstatic bool checkreturn pb_dec_svarint(pb_istream_t *stream, const pb_field_t *field, void *dest);\nstatic bool checkreturn pb_dec_fixed32(pb_istream_t *stream, const pb_field_t *field, void *dest);\nstatic bool checkreturn pb_dec_fixed64(pb_istream_t *stream, const pb_field_t *field, void *dest);\nstatic bool checkreturn pb_dec_bytes(pb_istream_t *stream, const pb_field_t *field, void *dest);\nstatic bool checkreturn pb_dec_string(pb_istream_t *stream, const pb_field_t *field, void *dest);\nstatic bool checkreturn pb_dec_submessage(pb_istream_t *stream, const pb_field_t *field, void *dest);\nstatic bool checkreturn pb_dec_fixed_length_bytes(pb_istream_t *stream, const pb_field_t *field, void *dest);\nstatic bool checkreturn pb_skip_varint(pb_istream_t *stream);\nstatic bool checkreturn pb_skip_string(pb_istream_t *stream);\n\n#ifdef PB_ENABLE_MALLOC\nstatic bool checkreturn allocate_field(pb_istream_t *stream, void *pData, size_t data_size, size_t array_size);\nstatic bool checkreturn pb_release_union_field(pb_istream_t *stream, pb_field_iter_t *iter);\nstatic void pb_release_single_field(const pb_field_iter_t *iter);\n#endif\n\n#ifdef PB_WITHOUT_64BIT\n#define pb_int64_t int32_t\n#define pb_uint64_t uint32_t\n#else\n#define pb_int64_t int64_t\n#define pb_uint64_t uint64_t\n#endif\n\n/* --- Function pointers to field decoders ---\n * Order in the array must match pb_action_t LTYPE numbering.\n */\nstatic const pb_decoder_t PB_DECODERS[PB_LTYPES_COUNT] = {\n    &pb_dec_bool,\n    &pb_dec_varint,\n    &pb_dec_uvarint,\n    &pb_dec_svarint,\n    &pb_dec_fixed32,\n    &pb_dec_fixed64,\n    \n    &pb_dec_bytes,\n    &pb_dec_string,\n    &pb_dec_submessage,\n    NULL, /* extensions */\n    &pb_dec_fixed_length_bytes\n};\n\n/*******************************\n * pb_istream_t implementation *\n *******************************/\n\nstatic bool checkreturn buf_read(pb_istream_t *stream, pb_byte_t *buf, size_t count)\n{\n    size_t i;\n    const pb_byte_t *source = (const pb_byte_t*)stream->state;\n    stream->state = (pb_byte_t*)stream->state + count;\n    \n    if (buf != NULL)\n    {\n        for (i = 0; i < count; i++)\n            buf[i] = source[i];\n    }\n    \n    return true;\n}\n\nbool checkreturn pb_read(pb_istream_t *stream, pb_byte_t *buf, size_t count)\n{\n    if (count == 0)\n        return true;\n\n#ifndef PB_BUFFER_ONLY\n\tif (buf == NULL && stream->callback != buf_read)\n\t{\n\t\t/* Skip input bytes */\n\t\tpb_byte_t tmp[16];\n\t\twhile (count > 16)\n\t\t{\n\t\t\tif (!pb_read(stream, tmp, 16))\n\t\t\t\treturn false;\n\t\t\t\n\t\t\tcount -= 16;\n\t\t}\n\t\t\n\t\treturn pb_read(stream, tmp, count);\n\t}\n#endif\n\n    if (stream->bytes_left < count)\n        PB_RETURN_ERROR(stream, \"end-of-stream\");\n    \n#ifndef PB_BUFFER_ONLY\n    if (!stream->callback(stream, buf, count))\n        PB_RETURN_ERROR(stream, \"io error\");\n#else\n    if (!buf_read(stream, buf, count))\n        return false;\n#endif\n    \n    stream->bytes_left -= count;\n    return true;\n}\n\n/* Read a single byte from input stream. buf may not be NULL.\n * This is an optimization for the varint decoding. */\nstatic bool checkreturn pb_readbyte(pb_istream_t *stream, pb_byte_t *buf)\n{\n    if (stream->bytes_left == 0)\n        PB_RETURN_ERROR(stream, \"end-of-stream\");\n\n#ifndef PB_BUFFER_ONLY\n    if (!stream->callback(stream, buf, 1))\n        PB_RETURN_ERROR(stream, \"io error\");\n#else\n    *buf = *(const pb_byte_t*)stream->state;\n    stream->state = (pb_byte_t*)stream->state + 1;\n#endif\n\n    stream->bytes_left--;\n    \n    return true;    \n}\n\npb_istream_t pb_istream_from_buffer(const pb_byte_t *buf, size_t bufsize)\n{\n    pb_istream_t stream;\n    /* Cast away the const from buf without a compiler error.  We are\n     * careful to use it only in a const manner in the callbacks.\n     */\n    union {\n        void *state;\n        const void *c_state;\n    } state;\n#ifdef PB_BUFFER_ONLY\n    stream.callback = NULL;\n#else\n    stream.callback = &buf_read;\n#endif\n    state.c_state = buf;\n    stream.state = state.state;\n    stream.bytes_left = bufsize;\n#ifndef PB_NO_ERRMSG\n    stream.errmsg = NULL;\n#endif\n    return stream;\n}\n\n/********************\n * Helper functions *\n ********************/\n\nstatic bool checkreturn pb_decode_varint32_eof(pb_istream_t *stream, uint32_t *dest, bool *eof)\n{\n    pb_byte_t byte;\n    uint32_t result;\n    \n    if (!pb_readbyte(stream, &byte))\n    {\n        if (stream->bytes_left == 0)\n        {\n            if (eof)\n            {\n                *eof = true;\n            }\n        }\n\n        return false;\n    }\n    \n    if ((byte & 0x80) == 0)\n    {\n        /* Quick case, 1 byte value */\n        result = byte;\n    }\n    else\n    {\n        /* Multibyte case */\n        uint_fast8_t bitpos = 7;\n        result = byte & 0x7F;\n        \n        do\n        {\n            if (!pb_readbyte(stream, &byte))\n                return false;\n            \n            if (bitpos >= 32)\n            {\n                /* Note: The varint could have trailing 0x80 bytes, or 0xFF for negative. */\n                uint8_t sign_extension = (bitpos < 63) ? 0xFF : 0x01;\n                \n                if ((byte & 0x7F) != 0x00 && ((result >> 31) == 0 || byte != sign_extension))\n                {\n                    PB_RETURN_ERROR(stream, \"varint overflow\");\n                }\n            }\n            else\n            {\n                result |= (uint32_t)(byte & 0x7F) << bitpos;\n            }\n            bitpos = (uint_fast8_t)(bitpos + 7);\n        } while (byte & 0x80);\n        \n        if (bitpos == 35 && (byte & 0x70) != 0)\n        {\n            /* The last byte was at bitpos=28, so only bottom 4 bits fit. */\n            PB_RETURN_ERROR(stream, \"varint overflow\");\n        }\n   }\n   \n   *dest = result;\n   return true;\n}\n\nbool checkreturn pb_decode_varint32(pb_istream_t *stream, uint32_t *dest)\n{\n    return pb_decode_varint32_eof(stream, dest, NULL);\n}\n\n#ifndef PB_WITHOUT_64BIT\nbool checkreturn pb_decode_varint(pb_istream_t *stream, uint64_t *dest)\n{\n    pb_byte_t byte;\n    uint_fast8_t bitpos = 0;\n    uint64_t result = 0;\n    \n    do\n    {\n        if (bitpos >= 64)\n            PB_RETURN_ERROR(stream, \"varint overflow\");\n        \n        if (!pb_readbyte(stream, &byte))\n            return false;\n\n        result |= (uint64_t)(byte & 0x7F) << bitpos;\n        bitpos = (uint_fast8_t)(bitpos + 7);\n    } while (byte & 0x80);\n    \n    *dest = result;\n    return true;\n}\n#endif\n\nbool checkreturn pb_skip_varint(pb_istream_t *stream)\n{\n    pb_byte_t byte;\n    do\n    {\n        if (!pb_read(stream, &byte, 1))\n            return false;\n    } while (byte & 0x80);\n    return true;\n}\n\nbool checkreturn pb_skip_string(pb_istream_t *stream)\n{\n    uint32_t length;\n    if (!pb_decode_varint32(stream, &length))\n        return false;\n    \n    return pb_read(stream, NULL, length);\n}\n\nbool checkreturn pb_decode_tag(pb_istream_t *stream, pb_wire_type_t *wire_type, uint32_t *tag, bool *eof)\n{\n    uint32_t temp;\n    *eof = false;\n    *wire_type = (pb_wire_type_t) 0;\n    *tag = 0;\n    \n    if (!pb_decode_varint32_eof(stream, &temp, eof))\n    {\n        return false;\n    }\n    \n    if (temp == 0)\n    {\n        *eof = true; /* Special feature: allow 0-terminated messages. */\n        return false;\n    }\n    \n    *tag = temp >> 3;\n    *wire_type = (pb_wire_type_t)(temp & 7);\n    return true;\n}\n\nbool checkreturn pb_skip_field(pb_istream_t *stream, pb_wire_type_t wire_type)\n{\n    switch (wire_type)\n    {\n        case PB_WT_VARINT: return pb_skip_varint(stream);\n        case PB_WT_64BIT: return pb_read(stream, NULL, 8);\n        case PB_WT_STRING: return pb_skip_string(stream);\n        case PB_WT_32BIT: return pb_read(stream, NULL, 4);\n        default: PB_RETURN_ERROR(stream, \"invalid wire_type\");\n    }\n}\n\n/* Read a raw value to buffer, for the purpose of passing it to callback as\n * a substream. Size is maximum size on call, and actual size on return.\n */\nstatic bool checkreturn read_raw_value(pb_istream_t *stream, pb_wire_type_t wire_type, pb_byte_t *buf, size_t *size)\n{\n    size_t max_size = *size;\n    switch (wire_type)\n    {\n        case PB_WT_VARINT:\n            *size = 0;\n            do\n            {\n                (*size)++;\n                if (*size > max_size) return false;\n                if (!pb_read(stream, buf, 1)) return false;\n            } while (*buf++ & 0x80);\n            return true;\n            \n        case PB_WT_64BIT:\n            *size = 8;\n            return pb_read(stream, buf, 8);\n        \n        case PB_WT_32BIT:\n            *size = 4;\n            return pb_read(stream, buf, 4);\n        \n        case PB_WT_STRING:\n            /* Calling read_raw_value with a PB_WT_STRING is an error.\n             * Explicitly handle this case and fallthrough to default to avoid\n             * compiler warnings.\n             */\n\n        default: PB_RETURN_ERROR(stream, \"invalid wire_type\");\n    }\n}\n\n/* Decode string length from stream and return a substream with limited length.\n * Remember to close the substream using pb_close_string_substream().\n */\nbool checkreturn pb_make_string_substream(pb_istream_t *stream, pb_istream_t *substream)\n{\n    uint32_t size;\n    if (!pb_decode_varint32(stream, &size))\n        return false;\n    \n    *substream = *stream;\n    if (substream->bytes_left < size)\n        PB_RETURN_ERROR(stream, \"parent stream too short\");\n    \n    substream->bytes_left = size;\n    stream->bytes_left -= size;\n    return true;\n}\n\nbool checkreturn pb_close_string_substream(pb_istream_t *stream, pb_istream_t *substream)\n{\n    if (substream->bytes_left) {\n        if (!pb_read(substream, NULL, substream->bytes_left))\n            return false;\n    }\n\n    stream->state = substream->state;\n\n#ifndef PB_NO_ERRMSG\n    stream->errmsg = substream->errmsg;\n#endif\n    return true;\n}\n\n/*************************\n * Decode a single field *\n *************************/\n\nstatic bool checkreturn decode_static_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter)\n{\n    pb_type_t type;\n    pb_decoder_t func;\n    \n    type = iter->pos->type;\n    func = PB_DECODERS[PB_LTYPE(type)];\n\n    switch (PB_HTYPE(type))\n    {\n        case PB_HTYPE_REQUIRED:\n            return func(stream, iter->pos, iter->pData);\n            \n        case PB_HTYPE_OPTIONAL:\n            if (iter->pSize != iter->pData)\n                *(bool*)iter->pSize = true;\n            return func(stream, iter->pos, iter->pData);\n    \n        case PB_HTYPE_REPEATED:\n            if (wire_type == PB_WT_STRING\n                && PB_LTYPE(type) <= PB_LTYPE_LAST_PACKABLE)\n            {\n                /* Packed array */\n                bool status = true;\n                pb_size_t *size = (pb_size_t*)iter->pSize;\n\n                pb_istream_t substream;\n                if (!pb_make_string_substream(stream, &substream))\n                    return false;\n\n                while (substream.bytes_left > 0 && *size < iter->pos->array_size)\n                {\n                    void *pItem = (char*)iter->pData + iter->pos->data_size * (*size);\n                    if (!func(&substream, iter->pos, pItem))\n                    {\n                        status = false;\n                        break;\n                    }\n                    (*size)++;\n                }\n\n                if (substream.bytes_left != 0)\n                    PB_RETURN_ERROR(stream, \"array overflow\");\n                if (!pb_close_string_substream(stream, &substream))\n                    return false;\n\n                return status;\n            }\n            else\n            {\n                /* Repeated field */\n                pb_size_t *size = (pb_size_t*)iter->pSize;\n                char *pItem = (char*)iter->pData + iter->pos->data_size * (*size);\n\n                if ((*size)++ >= iter->pos->array_size)\n                    PB_RETURN_ERROR(stream, \"array overflow\");\n\n                return func(stream, iter->pos, pItem);\n            }\n\n        case PB_HTYPE_ONEOF:\n            if (PB_LTYPE(type) == PB_LTYPE_SUBMESSAGE &&\n                *(pb_size_t*)iter->pSize != iter->pos->tag)\n            {\n                /* We memset to zero so that any callbacks are set to NULL.\n                 * This is because the callbacks might otherwise have values\n                 * from some other union field. */\n                memset(iter->pData, 0, iter->pos->data_size);\n                pb_message_set_to_defaults((const pb_field_t*)iter->pos->ptr, iter->pData);\n            }\n            *(pb_size_t*)iter->pSize = iter->pos->tag;\n\n            return func(stream, iter->pos, iter->pData);\n\n        default:\n            PB_RETURN_ERROR(stream, \"invalid field type\");\n    }\n}\n\n#ifdef PB_ENABLE_MALLOC\n/* Allocate storage for the field and store the pointer at iter->pData.\n * array_size is the number of entries to reserve in an array.\n * Zero size is not allowed, use pb_free() for releasing.\n */\nstatic bool checkreturn allocate_field(pb_istream_t *stream, void *pData, size_t data_size, size_t array_size)\n{    \n    void *ptr = *(void**)pData;\n    \n    if (data_size == 0 || array_size == 0)\n        PB_RETURN_ERROR(stream, \"invalid size\");\n    \n#ifdef __AVR__\n    /* Workaround for AVR libc bug 53284: http://savannah.nongnu.org/bugs/?53284\n     * Realloc to size of 1 byte can cause corruption of the malloc structures.\n     */\n    if (data_size == 1 && array_size == 1)\n    {\n        data_size = 2;\n    }\n#endif\n\n    /* Check for multiplication overflows.\n     * This code avoids the costly division if the sizes are small enough.\n     * Multiplication is safe as long as only half of bits are set\n     * in either multiplicand.\n     */\n    {\n        const size_t check_limit = (size_t)1 << (sizeof(size_t) * 4);\n        if (data_size >= check_limit || array_size >= check_limit)\n        {\n            const size_t size_max = (size_t)-1;\n            if (size_max / array_size < data_size)\n            {\n                PB_RETURN_ERROR(stream, \"size too large\");\n            }\n        }\n    }\n    \n    /* Allocate new or expand previous allocation */\n    /* Note: on failure the old pointer will remain in the structure,\n     * the message must be freed by caller also on error return. */\n    ptr = pb_realloc(ptr, array_size * data_size);\n    if (ptr == NULL)\n        PB_RETURN_ERROR(stream, \"realloc failed\");\n    \n    *(void**)pData = ptr;\n    return true;\n}\n\n/* Clear a newly allocated item in case it contains a pointer, or is a submessage. */\nstatic void initialize_pointer_field(void *pItem, pb_field_iter_t *iter)\n{\n    if (PB_LTYPE(iter->pos->type) == PB_LTYPE_STRING ||\n        PB_LTYPE(iter->pos->type) == PB_LTYPE_BYTES)\n    {\n        *(void**)pItem = NULL;\n    }\n    else if (PB_LTYPE(iter->pos->type) == PB_LTYPE_SUBMESSAGE)\n    {\n        /* We memset to zero so that any callbacks are set to NULL.\n         * Then set any default values. */\n        memset(pItem, 0, iter->pos->data_size);\n        pb_message_set_to_defaults((const pb_field_t *) iter->pos->ptr, pItem);\n    }\n}\n#endif\n\nstatic bool checkreturn decode_pointer_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter)\n{\n#ifndef PB_ENABLE_MALLOC\n    PB_UNUSED(wire_type);\n    PB_UNUSED(iter);\n    PB_RETURN_ERROR(stream, \"no malloc support\");\n#else\n    pb_type_t type;\n    pb_decoder_t func;\n    \n    type = iter->pos->type;\n    func = PB_DECODERS[PB_LTYPE(type)];\n    \n    switch (PB_HTYPE(type))\n    {\n        case PB_HTYPE_REQUIRED:\n        case PB_HTYPE_OPTIONAL:\n        case PB_HTYPE_ONEOF:\n            if (PB_LTYPE(type) == PB_LTYPE_SUBMESSAGE &&\n                *(void**)iter->pData != NULL)\n            {\n                /* Duplicate field, have to release the old allocation first. */\n                pb_release_single_field(iter);\n            }\n        \n            if (PB_HTYPE(type) == PB_HTYPE_ONEOF)\n            {\n                *(pb_size_t*)iter->pSize = iter->pos->tag;\n            }\n\n            if (PB_LTYPE(type) == PB_LTYPE_STRING ||\n                PB_LTYPE(type) == PB_LTYPE_BYTES)\n            {\n                return func(stream, iter->pos, iter->pData);\n            }\n            else\n            {\n                if (!allocate_field(stream, iter->pData, iter->pos->data_size, 1))\n                    return false;\n                \n                initialize_pointer_field(*(void**)iter->pData, iter);\n                return func(stream, iter->pos, *(void**)iter->pData);\n            }\n    \n        case PB_HTYPE_REPEATED:\n            if (wire_type == PB_WT_STRING\n                && PB_LTYPE(type) <= PB_LTYPE_LAST_PACKABLE)\n            {\n                /* Packed array, multiple items come in at once. */\n                bool status = true;\n                pb_size_t *size = (pb_size_t*)iter->pSize;\n                size_t allocated_size = *size;\n                void *pItem;\n                pb_istream_t substream;\n                \n                if (!pb_make_string_substream(stream, &substream))\n                    return false;\n                \n                while (substream.bytes_left)\n                {\n                    if (*size == PB_SIZE_MAX)\n                    {\n#ifndef PB_NO_ERRMSG\n                        stream->errmsg = \"too many array entries\";\n#endif\n                        status = false;\n                        break;\n                    }\n\n                    if ((size_t)*size + 1 > allocated_size)\n                    {\n                        /* Allocate more storage. This tries to guess the\n                         * number of remaining entries. Round the division\n                         * upwards. */\n                        size_t remain = (substream.bytes_left - 1) / iter->pos->data_size + 1;\n                        if (remain < PB_SIZE_MAX - allocated_size)\n                            allocated_size += remain;\n                        else\n                            allocated_size += 1;\n                        \n                        if (!allocate_field(&substream, iter->pData, iter->pos->data_size, allocated_size))\n                        {\n                            status = false;\n                            break;\n                        }\n                    }\n\n                    /* Decode the array entry */\n                    pItem = *(char**)iter->pData + iter->pos->data_size * (*size);\n                    initialize_pointer_field(pItem, iter);\n                    if (!func(&substream, iter->pos, pItem))\n                    {\n                        status = false;\n                        break;\n                    }\n                    \n                    (*size)++;\n                }\n                if (!pb_close_string_substream(stream, &substream))\n                    return false;\n                \n                return status;\n            }\n            else\n            {\n                /* Normal repeated field, i.e. only one item at a time. */\n                pb_size_t *size = (pb_size_t*)iter->pSize;\n                void *pItem;\n                \n                if (*size == PB_SIZE_MAX)\n                    PB_RETURN_ERROR(stream, \"too many array entries\");\n                \n                if (!allocate_field(stream, iter->pData, iter->pos->data_size, (size_t)(*size + 1)))\n                    return false;\n            \n                pItem = *(char**)iter->pData + iter->pos->data_size * (*size);\n                (*size)++;\n                initialize_pointer_field(pItem, iter);\n                return func(stream, iter->pos, pItem);\n            }\n\n        default:\n            PB_RETURN_ERROR(stream, \"invalid field type\");\n    }\n#endif\n}\n\nstatic bool checkreturn decode_callback_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter)\n{\n    pb_callback_t *pCallback = (pb_callback_t*)iter->pData;\n#ifdef PB_OLD_CALLBACK_STYLE\n    void *arg;\n#else\n    void **arg;\n#endif\n    \n    if (pCallback == NULL || pCallback->funcs.decode == NULL)\n        return pb_skip_field(stream, wire_type);\n\n#ifdef PB_OLD_CALLBACK_STYLE\n    arg = pCallback->arg;\n#else\n    arg = &(pCallback->arg);\n#endif\n    \n    if (wire_type == PB_WT_STRING)\n    {\n        pb_istream_t substream;\n        \n        if (!pb_make_string_substream(stream, &substream))\n            return false;\n        \n        do\n        {\n            if (!pCallback->funcs.decode(&substream, iter->pos, arg))\n                PB_RETURN_ERROR(stream, \"callback failed\");\n        } while (substream.bytes_left);\n        \n        if (!pb_close_string_substream(stream, &substream))\n            return false;\n\n        return true;\n    }\n    else\n    {\n        /* Copy the single scalar value to stack.\n         * This is required so that we can limit the stream length,\n         * which in turn allows to use same callback for packed and\n         * not-packed fields. */\n        pb_istream_t substream;\n        pb_byte_t buffer[10];\n        size_t size = sizeof(buffer);\n        \n        if (!read_raw_value(stream, wire_type, buffer, &size))\n            return false;\n        substream = pb_istream_from_buffer(buffer, size);\n        \n        return pCallback->funcs.decode(&substream, iter->pos, arg);\n    }\n}\n\nstatic bool checkreturn decode_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter)\n{\n#ifdef PB_ENABLE_MALLOC\n    /* When decoding an oneof field, check if there is old data that must be\n     * released first. */\n    if (PB_HTYPE(iter->pos->type) == PB_HTYPE_ONEOF)\n    {\n        if (!pb_release_union_field(stream, iter))\n            return false;\n    }\n#endif\n\n    switch (PB_ATYPE(iter->pos->type))\n    {\n        case PB_ATYPE_STATIC:\n            return decode_static_field(stream, wire_type, iter);\n        \n        case PB_ATYPE_POINTER:\n            return decode_pointer_field(stream, wire_type, iter);\n        \n        case PB_ATYPE_CALLBACK:\n            return decode_callback_field(stream, wire_type, iter);\n        \n        default:\n            PB_RETURN_ERROR(stream, \"invalid field type\");\n    }\n}\n\nstatic void iter_from_extension(pb_field_iter_t *iter, pb_extension_t *extension)\n{\n    /* Fake a field iterator for the extension field.\n     * It is not actually safe to advance this iterator, but decode_field\n     * will not even try to. */\n    const pb_field_t *field = (const pb_field_t*)extension->type->arg;\n    (void)pb_field_iter_begin(iter, field, extension->dest);\n    iter->pData = extension->dest;\n    iter->pSize = &extension->found;\n    \n    if (PB_ATYPE(field->type) == PB_ATYPE_POINTER)\n    {\n        /* For pointer extensions, the pointer is stored directly\n         * in the extension structure. This avoids having an extra\n         * indirection. */\n        iter->pData = &extension->dest;\n    }\n}\n\n/* Default handler for extension fields. Expects a pb_field_t structure\n * in extension->type->arg. */\nstatic bool checkreturn default_extension_decoder(pb_istream_t *stream,\n    pb_extension_t *extension, uint32_t tag, pb_wire_type_t wire_type)\n{\n    const pb_field_t *field = (const pb_field_t*)extension->type->arg;\n    pb_field_iter_t iter;\n    \n    if (field->tag != tag)\n        return true;\n    \n    iter_from_extension(&iter, extension);\n    extension->found = true;\n    return decode_field(stream, wire_type, &iter);\n}\n\n/* Try to decode an unknown field as an extension field. Tries each extension\n * decoder in turn, until one of them handles the field or loop ends. */\nstatic bool checkreturn decode_extension(pb_istream_t *stream,\n    uint32_t tag, pb_wire_type_t wire_type, pb_field_iter_t *iter)\n{\n    pb_extension_t *extension = *(pb_extension_t* const *)iter->pData;\n    size_t pos = stream->bytes_left;\n    \n    while (extension != NULL && pos == stream->bytes_left)\n    {\n        bool status;\n        if (extension->type->decode)\n            status = extension->type->decode(stream, extension, tag, wire_type);\n        else\n            status = default_extension_decoder(stream, extension, tag, wire_type);\n\n        if (!status)\n            return false;\n        \n        extension = extension->next;\n    }\n    \n    return true;\n}\n\n/* Step through the iterator until an extension field is found or until all\n * entries have been checked. There can be only one extension field per\n * message. Returns false if no extension field is found. */\nstatic bool checkreturn find_extension_field(pb_field_iter_t *iter)\n{\n    const pb_field_t *start = iter->pos;\n    \n    do {\n        if (PB_LTYPE(iter->pos->type) == PB_LTYPE_EXTENSION)\n            return true;\n        (void)pb_field_iter_next(iter);\n    } while (iter->pos != start);\n    \n    return false;\n}\n\n/* Initialize message fields to default values, recursively */\nstatic void pb_field_set_to_default(pb_field_iter_t *iter)\n{\n    pb_type_t type;\n    type = iter->pos->type;\n    \n    if (PB_LTYPE(type) == PB_LTYPE_EXTENSION)\n    {\n        pb_extension_t *ext = *(pb_extension_t* const *)iter->pData;\n        while (ext != NULL)\n        {\n            pb_field_iter_t ext_iter;\n            ext->found = false;\n            iter_from_extension(&ext_iter, ext);\n            pb_field_set_to_default(&ext_iter);\n            ext = ext->next;\n        }\n    }\n    else if (PB_ATYPE(type) == PB_ATYPE_STATIC)\n    {\n        bool init_data = true;\n        if (PB_HTYPE(type) == PB_HTYPE_OPTIONAL && iter->pSize != iter->pData)\n        {\n            /* Set has_field to false. Still initialize the optional field\n             * itself also. */\n            *(bool*)iter->pSize = false;\n        }\n        else if (PB_HTYPE(type) == PB_HTYPE_REPEATED ||\n                 PB_HTYPE(type) == PB_HTYPE_ONEOF)\n        {\n            /* REPEATED: Set array count to 0, no need to initialize contents.\n               ONEOF: Set which_field to 0. */\n            *(pb_size_t*)iter->pSize = 0;\n            init_data = false;\n        }\n\n        if (init_data)\n        {\n            if (PB_LTYPE(iter->pos->type) == PB_LTYPE_SUBMESSAGE)\n            {\n                /* Initialize submessage to defaults */\n                pb_message_set_to_defaults((const pb_field_t *) iter->pos->ptr, iter->pData);\n            }\n            else if (iter->pos->ptr != NULL)\n            {\n                /* Initialize to default value */\n                memcpy(iter->pData, iter->pos->ptr, iter->pos->data_size);\n            }\n            else\n            {\n                /* Initialize to zeros */\n                memset(iter->pData, 0, iter->pos->data_size);\n            }\n        }\n    }\n    else if (PB_ATYPE(type) == PB_ATYPE_POINTER)\n    {\n        /* Initialize the pointer to NULL. */\n        *(void**)iter->pData = NULL;\n        \n        /* Initialize array count to 0. */\n        if (PB_HTYPE(type) == PB_HTYPE_REPEATED ||\n            PB_HTYPE(type) == PB_HTYPE_ONEOF)\n        {\n            *(pb_size_t*)iter->pSize = 0;\n        }\n    }\n    else if (PB_ATYPE(type) == PB_ATYPE_CALLBACK)\n    {\n        /* Don't overwrite callback */\n    }\n}\n\nstatic void pb_message_set_to_defaults(const pb_field_t fields[], void *dest_struct)\n{\n    pb_field_iter_t iter;\n\n    if (!pb_field_iter_begin(&iter, fields, dest_struct))\n        return; /* Empty message type */\n    \n    do\n    {\n        pb_field_set_to_default(&iter);\n    } while (pb_field_iter_next(&iter));\n}\n\n/*********************\n * Decode all fields *\n *********************/\n\nbool checkreturn pb_decode_noinit(pb_istream_t *stream, const pb_field_t fields[], void *dest_struct)\n{\n    uint32_t fields_seen[(PB_MAX_REQUIRED_FIELDS + 31) / 32] = {0, 0};\n    const uint32_t allbits = ~(uint32_t)0;\n    uint32_t extension_range_start = 0;\n    pb_field_iter_t iter;\n\n    /* 'fixed_count_field' and 'fixed_count_size' track position of a repeated fixed\n     * count field. This can only handle _one_ repeated fixed count field that\n     * is unpacked and unordered among other (non repeated fixed count) fields.\n     */\n    const pb_field_t *fixed_count_field = NULL;\n    pb_size_t fixed_count_size = 0;\n\n    /* Return value ignored, as empty message types will be correctly handled by\n     * pb_field_iter_find() anyway. */\n    (void)pb_field_iter_begin(&iter, fields, dest_struct);\n\n    while (stream->bytes_left)\n    {\n        uint32_t tag;\n        pb_wire_type_t wire_type;\n        bool eof;\n\n        if (!pb_decode_tag(stream, &wire_type, &tag, &eof))\n        {\n            if (eof)\n                break;\n            else\n                return false;\n        }\n\n        if (!pb_field_iter_find(&iter, tag))\n        {\n            /* No match found, check if it matches an extension. */\n            if (tag >= extension_range_start)\n            {\n                if (!find_extension_field(&iter))\n                    extension_range_start = (uint32_t)-1;\n                else\n                    extension_range_start = iter.pos->tag;\n\n                if (tag >= extension_range_start)\n                {\n                    size_t pos = stream->bytes_left;\n\n                    if (!decode_extension(stream, tag, wire_type, &iter))\n                        return false;\n\n                    if (pos != stream->bytes_left)\n                    {\n                        /* The field was handled */\n                        continue;\n                    }\n                }\n            }\n\n            /* No match found, skip data */\n            if (!pb_skip_field(stream, wire_type))\n                return false;\n            continue;\n        }\n\n        /* If a repeated fixed count field was found, get size from\n         * 'fixed_count_field' as there is no counter contained in the struct.\n         */\n        if (PB_HTYPE(iter.pos->type) == PB_HTYPE_REPEATED\n            && iter.pSize == iter.pData)\n        {\n            if (fixed_count_field != iter.pos) {\n                /* If the new fixed count field does not match the previous one,\n                 * check that the previous one is NULL or that it finished\n                 * receiving all the expected data.\n                 */\n                if (fixed_count_field != NULL &&\n                    fixed_count_size != fixed_count_field->array_size)\n                {\n                    PB_RETURN_ERROR(stream, \"wrong size for fixed count field\");\n                }\n\n                fixed_count_field = iter.pos;\n                fixed_count_size = 0;\n            }\n\n            iter.pSize = &fixed_count_size;\n        }\n\n        if (PB_HTYPE(iter.pos->type) == PB_HTYPE_REQUIRED\n            && iter.required_field_index < PB_MAX_REQUIRED_FIELDS)\n        {\n            uint32_t tmp = ((uint32_t)1 << (iter.required_field_index & 31));\n            fields_seen[iter.required_field_index >> 5] |= tmp;\n        }\n\n        if (!decode_field(stream, wire_type, &iter))\n            return false;\n    }\n\n    /* Check that all elements of the last decoded fixed count field were present. */\n    if (fixed_count_field != NULL &&\n        fixed_count_size != fixed_count_field->array_size)\n    {\n        PB_RETURN_ERROR(stream, \"wrong size for fixed count field\");\n    }\n\n    /* Check that all required fields were present. */\n    {\n        /* First figure out the number of required fields by\n         * seeking to the end of the field array. Usually we\n         * are already close to end after decoding.\n         */\n        unsigned req_field_count;\n        pb_type_t last_type;\n        unsigned i;\n        do {\n            req_field_count = iter.required_field_index;\n            last_type = iter.pos->type;\n        } while (pb_field_iter_next(&iter));\n        \n        /* Fixup if last field was also required. */\n        if (PB_HTYPE(last_type) == PB_HTYPE_REQUIRED && iter.pos->tag != 0)\n            req_field_count++;\n        \n        if (req_field_count > PB_MAX_REQUIRED_FIELDS)\n            req_field_count = PB_MAX_REQUIRED_FIELDS;\n\n        if (req_field_count > 0)\n        {\n            /* Check the whole words */\n            for (i = 0; i < (req_field_count >> 5); i++)\n            {\n                if (fields_seen[i] != allbits)\n                    PB_RETURN_ERROR(stream, \"missing required field\");\n            }\n            \n            /* Check the remaining bits (if any) */\n            if ((req_field_count & 31) != 0)\n            {\n                if (fields_seen[req_field_count >> 5] !=\n                    (allbits >> (32 - (req_field_count & 31))))\n                {\n                    PB_RETURN_ERROR(stream, \"missing required field\");\n                }\n            }\n        }\n    }\n    \n    return true;\n}\n\nbool checkreturn pb_decode(pb_istream_t *stream, const pb_field_t fields[], void *dest_struct)\n{\n    bool status;\n    pb_message_set_to_defaults(fields, dest_struct);\n    status = pb_decode_noinit(stream, fields, dest_struct);\n    \n#ifdef PB_ENABLE_MALLOC\n    if (!status)\n        pb_release(fields, dest_struct);\n#endif\n    \n    return status;\n}\n\nbool pb_decode_delimited_noinit(pb_istream_t *stream, const pb_field_t fields[], void *dest_struct)\n{\n    pb_istream_t substream;\n    bool status;\n\n    if (!pb_make_string_substream(stream, &substream))\n        return false;\n\n    status = pb_decode_noinit(&substream, fields, dest_struct);\n\n    if (!pb_close_string_substream(stream, &substream))\n        return false;\n    return status;\n}\n\nbool pb_decode_delimited(pb_istream_t *stream, const pb_field_t fields[], void *dest_struct)\n{\n    pb_istream_t substream;\n    bool status;\n    \n    if (!pb_make_string_substream(stream, &substream))\n        return false;\n    \n    status = pb_decode(&substream, fields, dest_struct);\n\n    if (!pb_close_string_substream(stream, &substream))\n        return false;\n    return status;\n}\n\nbool pb_decode_nullterminated(pb_istream_t *stream, const pb_field_t fields[], void *dest_struct)\n{\n    /* This behaviour will be separated in nanopb-0.4.0, see issue #278. */\n    return pb_decode(stream, fields, dest_struct);\n}\n\n#ifdef PB_ENABLE_MALLOC\n/* Given an oneof field, if there has already been a field inside this oneof,\n * release it before overwriting with a different one. */\nstatic bool pb_release_union_field(pb_istream_t *stream, pb_field_iter_t *iter)\n{\n    pb_size_t old_tag = *(pb_size_t*)iter->pSize; /* Previous which_ value */\n    pb_size_t new_tag = iter->pos->tag; /* New which_ value */\n\n    if (old_tag == 0)\n        return true; /* Ok, no old data in union */\n\n    if (old_tag == new_tag)\n        return true; /* Ok, old data is of same type => merge */\n\n    /* Release old data. The find can fail if the message struct contains\n     * invalid data. */\n    if (!pb_field_iter_find(iter, old_tag))\n        PB_RETURN_ERROR(stream, \"invalid union tag\");\n\n    pb_release_single_field(iter);\n\n    /* Restore iterator to where it should be.\n     * This shouldn't fail unless the pb_field_t structure is corrupted. */\n    if (!pb_field_iter_find(iter, new_tag))\n        PB_RETURN_ERROR(stream, \"iterator error\");\n    \n    return true;\n}\n\nstatic void pb_release_single_field(const pb_field_iter_t *iter)\n{\n    pb_type_t type;\n    type = iter->pos->type;\n\n    if (PB_HTYPE(type) == PB_HTYPE_ONEOF)\n    {\n        if (*(pb_size_t*)iter->pSize != iter->pos->tag)\n            return; /* This is not the current field in the union */\n    }\n\n    /* Release anything contained inside an extension or submsg.\n     * This has to be done even if the submsg itself is statically\n     * allocated. */\n    if (PB_LTYPE(type) == PB_LTYPE_EXTENSION)\n    {\n        /* Release fields from all extensions in the linked list */\n        pb_extension_t *ext = *(pb_extension_t**)iter->pData;\n        while (ext != NULL)\n        {\n            pb_field_iter_t ext_iter;\n            iter_from_extension(&ext_iter, ext);\n            pb_release_single_field(&ext_iter);\n            ext = ext->next;\n        }\n    }\n    else if (PB_LTYPE(type) == PB_LTYPE_SUBMESSAGE && PB_ATYPE(type) != PB_ATYPE_CALLBACK)\n    {\n        /* Release fields in submessage or submsg array */\n        void *pItem = iter->pData;\n        pb_size_t count = 1;\n        \n        if (PB_ATYPE(type) == PB_ATYPE_POINTER)\n        {\n            pItem = *(void**)iter->pData;\n        }\n        \n        if (PB_HTYPE(type) == PB_HTYPE_REPEATED)\n        {\n            if (PB_ATYPE(type) == PB_ATYPE_STATIC && iter->pSize == iter->pData) {\n                /* No _count field so use size of the array */\n                count = iter->pos->array_size;\n            } else {\n                count = *(pb_size_t*)iter->pSize;\n            }\n\n            if (PB_ATYPE(type) == PB_ATYPE_STATIC && count > iter->pos->array_size)\n            {\n                /* Protect against corrupted _count fields */\n                count = iter->pos->array_size;\n            }\n        }\n        \n        if (pItem)\n        {\n            while (count--)\n            {\n                pb_release((const pb_field_t*)iter->pos->ptr, pItem);\n                pItem = (char*)pItem + iter->pos->data_size;\n            }\n        }\n    }\n    \n    if (PB_ATYPE(type) == PB_ATYPE_POINTER)\n    {\n        if (PB_HTYPE(type) == PB_HTYPE_REPEATED &&\n            (PB_LTYPE(type) == PB_LTYPE_STRING ||\n             PB_LTYPE(type) == PB_LTYPE_BYTES))\n        {\n            /* Release entries in repeated string or bytes array */\n            void **pItem = *(void***)iter->pData;\n            pb_size_t count = *(pb_size_t*)iter->pSize;\n            while (count--)\n            {\n                pb_free(*pItem);\n                *pItem++ = NULL;\n            }\n        }\n        \n        if (PB_HTYPE(type) == PB_HTYPE_REPEATED)\n        {\n            /* We are going to release the array, so set the size to 0 */\n            *(pb_size_t*)iter->pSize = 0;\n        }\n        \n        /* Release main item */\n        pb_free(*(void**)iter->pData);\n        *(void**)iter->pData = NULL;\n    }\n}\n\nvoid pb_release(const pb_field_t fields[], void *dest_struct)\n{\n    pb_field_iter_t iter;\n    \n    if (!dest_struct)\n        return; /* Ignore NULL pointers, similar to free() */\n\n    if (!pb_field_iter_begin(&iter, fields, dest_struct))\n        return; /* Empty message type */\n    \n    do\n    {\n        pb_release_single_field(&iter);\n    } while (pb_field_iter_next(&iter));\n}\n#endif\n\n/* Field decoders */\n\nbool pb_decode_bool(pb_istream_t *stream, bool *dest)\n{\n    return pb_dec_bool(stream, NULL, (void*)dest);\n}\n\nbool pb_decode_svarint(pb_istream_t *stream, pb_int64_t *dest)\n{\n    pb_uint64_t value;\n    if (!pb_decode_varint(stream, &value))\n        return false;\n    \n    if (value & 1)\n        *dest = (pb_int64_t)(~(value >> 1));\n    else\n        *dest = (pb_int64_t)(value >> 1);\n    \n    return true;\n}\n\nbool pb_decode_fixed32(pb_istream_t *stream, void *dest)\n{\n    pb_byte_t bytes[4];\n\n    if (!pb_read(stream, bytes, 4))\n        return false;\n    \n    *(uint32_t*)dest = ((uint32_t)bytes[0] << 0) |\n                       ((uint32_t)bytes[1] << 8) |\n                       ((uint32_t)bytes[2] << 16) |\n                       ((uint32_t)bytes[3] << 24);\n    return true;\n}\n\n#ifndef PB_WITHOUT_64BIT\nbool pb_decode_fixed64(pb_istream_t *stream, void *dest)\n{\n    pb_byte_t bytes[8];\n\n    if (!pb_read(stream, bytes, 8))\n        return false;\n    \n    *(uint64_t*)dest = ((uint64_t)bytes[0] << 0) |\n                       ((uint64_t)bytes[1] << 8) |\n                       ((uint64_t)bytes[2] << 16) |\n                       ((uint64_t)bytes[3] << 24) |\n                       ((uint64_t)bytes[4] << 32) |\n                       ((uint64_t)bytes[5] << 40) |\n                       ((uint64_t)bytes[6] << 48) |\n                       ((uint64_t)bytes[7] << 56);\n    \n    return true;\n}\n#endif\n\nstatic bool checkreturn pb_dec_bool(pb_istream_t *stream, const pb_field_t *field, void *dest)\n{\n    uint32_t value;\n    PB_UNUSED(field);\n    if (!pb_decode_varint32(stream, &value))\n        return false;\n\n    *(bool*)dest = (value != 0);\n    return true;\n}\n\nstatic bool checkreturn pb_dec_varint(pb_istream_t *stream, const pb_field_t *field, void *dest)\n{\n    pb_uint64_t value;\n    pb_int64_t svalue;\n    pb_int64_t clamped;\n    if (!pb_decode_varint(stream, &value))\n        return false;\n    \n    /* See issue 97: Google's C++ protobuf allows negative varint values to\n     * be cast as int32_t, instead of the int64_t that should be used when\n     * encoding. Previous nanopb versions had a bug in encoding. In order to\n     * not break decoding of such messages, we cast <=32 bit fields to\n     * int32_t first to get the sign correct.\n     */\n    if (field->data_size == sizeof(pb_int64_t))\n        svalue = (pb_int64_t)value;\n    else\n        svalue = (int32_t)value;\n\n    /* Cast to the proper field size, while checking for overflows */\n    if (field->data_size == sizeof(pb_int64_t))\n        clamped = *(pb_int64_t*)dest = svalue;\n    else if (field->data_size == sizeof(int32_t))\n        clamped = *(int32_t*)dest = (int32_t)svalue;\n    else if (field->data_size == sizeof(int_least16_t))\n        clamped = *(int_least16_t*)dest = (int_least16_t)svalue;\n    else if (field->data_size == sizeof(int_least8_t))\n        clamped = *(int_least8_t*)dest = (int_least8_t)svalue;\n    else\n        PB_RETURN_ERROR(stream, \"invalid data_size\");\n\n    if (clamped != svalue)\n        PB_RETURN_ERROR(stream, \"integer too large\");\n    \n    return true;\n}\n\nstatic bool checkreturn pb_dec_uvarint(pb_istream_t *stream, const pb_field_t *field, void *dest)\n{\n    pb_uint64_t value, clamped;\n    if (!pb_decode_varint(stream, &value))\n        return false;\n    \n    /* Cast to the proper field size, while checking for overflows */\n    if (field->data_size == sizeof(pb_uint64_t))\n        clamped = *(pb_uint64_t*)dest = value;\n    else if (field->data_size == sizeof(uint32_t))\n        clamped = *(uint32_t*)dest = (uint32_t)value;\n    else if (field->data_size == sizeof(uint_least16_t))\n        clamped = *(uint_least16_t*)dest = (uint_least16_t)value;\n    else if (field->data_size == sizeof(uint_least8_t))\n        clamped = *(uint_least8_t*)dest = (uint_least8_t)value;\n    else\n        PB_RETURN_ERROR(stream, \"invalid data_size\");\n    \n    if (clamped != value)\n        PB_RETURN_ERROR(stream, \"integer too large\");\n\n    return true;\n}\n\nstatic bool checkreturn pb_dec_svarint(pb_istream_t *stream, const pb_field_t *field, void *dest)\n{\n    pb_int64_t value, clamped;\n    if (!pb_decode_svarint(stream, &value))\n        return false;\n    \n    /* Cast to the proper field size, while checking for overflows */\n    if (field->data_size == sizeof(pb_int64_t))\n        clamped = *(pb_int64_t*)dest = value;\n    else if (field->data_size == sizeof(int32_t))\n        clamped = *(int32_t*)dest = (int32_t)value;\n    else if (field->data_size == sizeof(int_least16_t))\n        clamped = *(int_least16_t*)dest = (int_least16_t)value;\n    else if (field->data_size == sizeof(int_least8_t))\n        clamped = *(int_least8_t*)dest = (int_least8_t)value;\n    else\n        PB_RETURN_ERROR(stream, \"invalid data_size\");\n\n    if (clamped != value)\n        PB_RETURN_ERROR(stream, \"integer too large\");\n    \n    return true;\n}\n\nstatic bool checkreturn pb_dec_fixed32(pb_istream_t *stream, const pb_field_t *field, void *dest)\n{\n    PB_UNUSED(field);\n    return pb_decode_fixed32(stream, dest);\n}\n\nstatic bool checkreturn pb_dec_fixed64(pb_istream_t *stream, const pb_field_t *field, void *dest)\n{\n    PB_UNUSED(field);\n#ifndef PB_WITHOUT_64BIT\n    return pb_decode_fixed64(stream, dest);\n#else\n    PB_UNUSED(dest);\n    PB_RETURN_ERROR(stream, \"no 64bit support\");\n#endif\n}\n\nstatic bool checkreturn pb_dec_bytes(pb_istream_t *stream, const pb_field_t *field, void *dest)\n{\n    uint32_t size;\n    size_t alloc_size;\n    pb_bytes_array_t *bdest;\n    \n    if (!pb_decode_varint32(stream, &size))\n        return false;\n    \n    if (size > PB_SIZE_MAX)\n        PB_RETURN_ERROR(stream, \"bytes overflow\");\n    \n    alloc_size = PB_BYTES_ARRAY_T_ALLOCSIZE(size);\n    if (size > alloc_size)\n        PB_RETURN_ERROR(stream, \"size too large\");\n    \n    if (PB_ATYPE(field->type) == PB_ATYPE_POINTER)\n    {\n#ifndef PB_ENABLE_MALLOC\n        PB_RETURN_ERROR(stream, \"no malloc support\");\n#else\n        if (!allocate_field(stream, dest, alloc_size, 1))\n            return false;\n        bdest = *(pb_bytes_array_t**)dest;\n#endif\n    }\n    else\n    {\n        if (alloc_size > field->data_size)\n            PB_RETURN_ERROR(stream, \"bytes overflow\");\n        bdest = (pb_bytes_array_t*)dest;\n    }\n\n    bdest->size = (pb_size_t)size;\n    return pb_read(stream, bdest->bytes, size);\n}\n\nstatic bool checkreturn pb_dec_string(pb_istream_t *stream, const pb_field_t *field, void *dest)\n{\n    uint32_t size;\n    size_t alloc_size;\n    bool status;\n    if (!pb_decode_varint32(stream, &size))\n        return false;\n    \n    /* Space for null terminator */\n    alloc_size = size + 1;\n    \n    if (alloc_size < size)\n        PB_RETURN_ERROR(stream, \"size too large\");\n    \n    if (PB_ATYPE(field->type) == PB_ATYPE_POINTER)\n    {\n#ifndef PB_ENABLE_MALLOC\n        PB_RETURN_ERROR(stream, \"no malloc support\");\n#else\n        if (!allocate_field(stream, dest, alloc_size, 1))\n            return false;\n        dest = *(void**)dest;\n#endif\n    }\n    else\n    {\n        if (alloc_size > field->data_size)\n            PB_RETURN_ERROR(stream, \"string overflow\");\n    }\n    \n    status = pb_read(stream, (pb_byte_t*)dest, size);\n    *((pb_byte_t*)dest + size) = 0;\n    return status;\n}\n\nstatic bool checkreturn pb_dec_submessage(pb_istream_t *stream, const pb_field_t *field, void *dest)\n{\n    bool status;\n    pb_istream_t substream;\n    const pb_field_t* submsg_fields = (const pb_field_t*)field->ptr;\n    \n    if (!pb_make_string_substream(stream, &substream))\n        return false;\n    \n    if (field->ptr == NULL)\n        PB_RETURN_ERROR(stream, \"invalid field descriptor\");\n    \n    /* New array entries need to be initialized, while required and optional\n     * submessages have already been initialized in the top-level pb_decode. */\n    if (PB_HTYPE(field->type) == PB_HTYPE_REPEATED)\n        status = pb_decode(&substream, submsg_fields, dest);\n    else\n        status = pb_decode_noinit(&substream, submsg_fields, dest);\n    \n    if (!pb_close_string_substream(stream, &substream))\n        return false;\n    return status;\n}\n\nstatic bool checkreturn pb_dec_fixed_length_bytes(pb_istream_t *stream, const pb_field_t *field, void *dest)\n{\n    uint32_t size;\n\n    if (!pb_decode_varint32(stream, &size))\n        return false;\n\n    if (size > PB_SIZE_MAX)\n        PB_RETURN_ERROR(stream, \"bytes overflow\");\n\n    if (size == 0)\n    {\n        /* As a special case, treat empty bytes string as all zeros for fixed_length_bytes. */\n        memset(dest, 0, field->data_size);\n        return true;\n    }\n\n    if (size != field->data_size)\n        PB_RETURN_ERROR(stream, \"incorrect fixed length bytes size\");\n\n    return pb_read(stream, (pb_byte_t*)dest, field->data_size);\n}\n"], "filenames": ["pb_decode.c"], "buggy_code_start_loc": [467], "buggy_code_end_loc": [474], "fixing_code_start_loc": [467], "fixing_code_end_loc": [478], "type": "CWE-119", "message": "Nanopb is a small code-size Protocol Buffers implementation. In Nanopb before versions 0.4.4 and 0.3.9.7, decoding specifically formed message can leak memory if dynamic allocation is enabled and an oneof field contains a static submessage that contains a dynamic field, and the message being decoded contains the submessage multiple times. This is rare in normal messages, but it is a concern when untrusted data is parsed. This is fixed in versions 0.3.9.7 and 0.4.4. The following workarounds are available: 1) Set the option `no_unions` for the oneof field. This will generate fields as separate instead of C union, and avoids triggering the problematic code. 2) Set the type of the submessage field inside oneof to `FT_POINTER`. This way the whole submessage will be dynamically allocated and the problematic code is not executed. 3) Use an arena allocator for nanopb, to make sure all memory can be released afterwards.", "other": {"cve": {"id": "CVE-2020-26243", "sourceIdentifier": "security-advisories@github.com", "published": "2020-11-25T17:15:12.200", "lastModified": "2020-12-07T20:49:47.917", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Nanopb is a small code-size Protocol Buffers implementation. In Nanopb before versions 0.4.4 and 0.3.9.7, decoding specifically formed message can leak memory if dynamic allocation is enabled and an oneof field contains a static submessage that contains a dynamic field, and the message being decoded contains the submessage multiple times. This is rare in normal messages, but it is a concern when untrusted data is parsed. This is fixed in versions 0.3.9.7 and 0.4.4. The following workarounds are available: 1) Set the option `no_unions` for the oneof field. This will generate fields as separate instead of C union, and avoids triggering the problematic code. 2) Set the type of the submessage field inside oneof to `FT_POINTER`. This way the whole submessage will be dynamically allocated and the problematic code is not executed. 3) Use an arena allocator for nanopb, to make sure all memory can be released afterwards."}, {"lang": "es", "value": "Nanopb es una implementaci\u00f3n de B\u00faferes de Protocolo de c\u00f3digo de tama\u00f1o peque\u00f1o. En Nanopb versiones anteriores a 0.4.4 y 0.3.9.7, la decodificaci\u00f3n de un mensaje formado espec\u00edficamente puede filtrar la memoria si es habilitada la asignaci\u00f3n din\u00e1mica y un campo contiene un submensaje est\u00e1tico que contiene un campo din\u00e1mico, y el mensaje que est\u00e1 siendo decodificado contiene el submensaje varias veces. Esto es raro en los mensajes normales, pero es preocupante cuando son analizados datos no fiables. Esto est\u00e1 corregido en las versiones 0.3.9.7 y 0.4.4. Est\u00e1n disponibles las siguientes soluciones provisionales: 1) Poner la opci\u00f3n \"no_unions\" para el campo uno. Esto generar\u00e1 campos como separados en lugar de la uni\u00f3n C, y evita desencadenar el c\u00f3digo problem\u00e1tico. 2) Ajustar el tipo de campo de submensaje dentro de uno de ellos a \"TP_POINTER\". De esta manera todo el submensaje ser\u00e1 asignado din\u00e1micamente y el c\u00f3digo problem\u00e1tico no ser\u00e1 ejecutado. 3) Usar un asignador de campos para el nanopb, para asegurarse de que toda la memoria pueda ser liberada despu\u00e9s"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}, {"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nanopb_project:nanopb:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.3.9.7", "matchCriteriaId": "E2479C6C-033B-4F28-895E-9ACDEB6956F2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nanopb_project:nanopb:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.4.0", "versionEndExcluding": "0.4.4", "matchCriteriaId": "42DF75C8-803B-4F1A-AF78-929126981CBB"}]}]}], "references": [{"url": "https://github.com/nanopb/nanopb/blob/2b48a361786dfb1f63d229840217a93aae064667/CHANGELOG.txt", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/nanopb/nanopb/commit/4fe23595732b6f1254cfc11a9b8d6da900b55b0c", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/nanopb/nanopb/issues/615", "source": "security-advisories@github.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/nanopb/nanopb/security/advisories/GHSA-85rr-4rh9-hhwh", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/nanopb/nanopb/commit/4fe23595732b6f1254cfc11a9b8d6da900b55b0c"}}