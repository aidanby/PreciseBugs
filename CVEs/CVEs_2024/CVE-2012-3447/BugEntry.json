{"buggy_code": ["# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2011 Isaku Yamahata\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\nimport os\n\nfrom nova import exception\nfrom nova import flags\nfrom nova import test\nfrom nova import utils\nfrom nova.virt.disk import api as disk_api\nfrom nova.virt import driver\n\nFLAGS = flags.FLAGS\n\n\nclass TestVirtDriver(test.TestCase):\n    def test_block_device(self):\n        swap = {'device_name': '/dev/sdb',\n                'swap_size': 1}\n        ephemerals = [{'num': 0,\n                       'virtual_name': 'ephemeral0',\n                       'device_name': '/dev/sdc1',\n                       'size': 1}]\n        block_device_mapping = [{'mount_device': '/dev/sde',\n                                 'device_path': 'fake_device'}]\n        block_device_info = {\n                'root_device_name': '/dev/sda',\n                'swap': swap,\n                'ephemerals': ephemerals,\n                'block_device_mapping': block_device_mapping}\n\n        empty_block_device_info = {}\n\n        self.assertEqual(\n            driver.block_device_info_get_root(block_device_info), '/dev/sda')\n        self.assertEqual(\n            driver.block_device_info_get_root(empty_block_device_info), None)\n        self.assertEqual(\n            driver.block_device_info_get_root(None), None)\n\n        self.assertEqual(\n            driver.block_device_info_get_swap(block_device_info), swap)\n        self.assertEqual(driver.block_device_info_get_swap(\n            empty_block_device_info)['device_name'], None)\n        self.assertEqual(driver.block_device_info_get_swap(\n            empty_block_device_info)['swap_size'], 0)\n        self.assertEqual(\n            driver.block_device_info_get_swap({'swap': None})['device_name'],\n            None)\n        self.assertEqual(\n            driver.block_device_info_get_swap({'swap': None})['swap_size'],\n            0)\n        self.assertEqual(\n            driver.block_device_info_get_swap(None)['device_name'], None)\n        self.assertEqual(\n            driver.block_device_info_get_swap(None)['swap_size'], 0)\n\n        self.assertEqual(\n            driver.block_device_info_get_ephemerals(block_device_info),\n            ephemerals)\n        self.assertEqual(\n            driver.block_device_info_get_ephemerals(empty_block_device_info),\n            [])\n        self.assertEqual(\n            driver.block_device_info_get_ephemerals(None),\n            [])\n\n    def test_swap_is_usable(self):\n        self.assertFalse(driver.swap_is_usable(None))\n        self.assertFalse(driver.swap_is_usable({'device_name': None}))\n        self.assertFalse(driver.swap_is_usable({'device_name': '/dev/sdb',\n                                                'swap_size': 0}))\n        self.assertTrue(driver.swap_is_usable({'device_name': '/dev/sdb',\n                                                'swap_size': 1}))\n\n\nclass TestVirtDisk(test.TestCase):\n    def setUp(self):\n        super(TestVirtDisk, self).setUp()\n        self.executes = []\n\n        def fake_execute(*cmd, **kwargs):\n            self.executes.append(cmd)\n            return None, None\n\n        self.stubs.Set(utils, 'execute', fake_execute)\n\n    def test_check_safe_path(self):\n        ret = disk_api._join_and_check_path_within_fs('/foo', 'etc',\n                                                      'something.conf')\n        self.assertEquals(ret, '/foo/etc/something.conf')\n\n    def test_check_unsafe_path(self):\n        self.assertRaises(exception.Invalid,\n                          disk_api._join_and_check_path_within_fs,\n                          '/foo', 'etc/../../../something.conf')\n\n    def test_inject_files_with_bad_path(self):\n        self.assertRaises(exception.Invalid,\n                          disk_api._inject_file_into_fs,\n                          '/tmp', '/etc/../../../../etc/passwd',\n                          'hax')\n\n    def test_lxc_destroy_container(self):\n\n        def proc_mounts(self, mount_point):\n            mount_points = {\n                '/mnt/loop/nopart': '/dev/loop0',\n                '/mnt/loop/part': '/dev/mapper/loop0p1',\n                '/mnt/nbd/nopart': '/dev/nbd15',\n                '/mnt/nbd/part': '/dev/mapper/nbd15p1',\n                '/mnt/guestfs': 'guestmount',\n            }\n            return mount_points[mount_point]\n\n        self.stubs.Set(os.path, 'exists', lambda _: True)\n        self.stubs.Set(disk_api._DiskImage, '_device_for_path', proc_mounts)\n        expected_commands = []\n\n        disk_api.destroy_container('/mnt/loop/nopart')\n        expected_commands += [\n                              ('umount', '/dev/loop0'),\n                              ('losetup', '--detach', '/dev/loop0'),\n                             ]\n\n        disk_api.destroy_container('/mnt/loop/part')\n        expected_commands += [\n                              ('umount', '/dev/mapper/loop0p1'),\n                              ('kpartx', '-d', '/dev/loop0'),\n                              ('losetup', '--detach', '/dev/loop0'),\n                             ]\n\n        disk_api.destroy_container('/mnt/nbd/nopart')\n        expected_commands += [\n                              ('umount', '/dev/nbd15'),\n                              ('qemu-nbd', '-d', '/dev/nbd15'),\n                             ]\n\n        disk_api.destroy_container('/mnt/nbd/part')\n        expected_commands += [\n                              ('umount', '/dev/mapper/nbd15p1'),\n                              ('kpartx', '-d', '/dev/nbd15'),\n                              ('qemu-nbd', '-d', '/dev/nbd15'),\n                             ]\n\n        disk_api.destroy_container('/mnt/guestfs')\n        expected_commands += [\n                              ('fusermount', '-u', '/mnt/guestfs'),\n                             ]\n        # It's not worth trying to match the last timeout command\n        self.executes.pop()\n\n        self.assertEqual(self.executes, expected_commands)\n", "# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n#    Copyright (c) 2010 Citrix Systems, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\n\"\"\"Test suite for XenAPI.\"\"\"\n\nimport ast\nimport contextlib\nimport cPickle as pickle\nimport functools\nimport os\nimport re\n\nfrom nova.compute import api as compute_api\nfrom nova.compute import instance_types\nfrom nova.compute import power_state\nfrom nova import context\nfrom nova import db\nfrom nova import exception\nfrom nova import flags\nfrom nova.openstack.common import importutils\nfrom nova.openstack.common import jsonutils\nfrom nova.openstack.common import log as logging\nfrom nova.openstack.common import timeutils\nfrom nova import test\nfrom nova.tests.db import fakes as db_fakes\nfrom nova.tests import fake_network\nfrom nova.tests import fake_utils\nimport nova.tests.image.fake as fake_image\nfrom nova.tests.xenapi import stubs\nfrom nova.virt.xenapi import agent\nfrom nova.virt.xenapi import driver as xenapi_conn\nfrom nova.virt.xenapi import fake as xenapi_fake\nfrom nova.virt.xenapi import pool_states\nfrom nova.virt.xenapi import vm_utils\nfrom nova.virt.xenapi import vmops\nfrom nova.virt.xenapi import volume_utils\n\n\nLOG = logging.getLogger(__name__)\n\nFLAGS = flags.FLAGS\n\nIMAGE_MACHINE = '1'\nIMAGE_KERNEL = '2'\nIMAGE_RAMDISK = '3'\nIMAGE_RAW = '4'\nIMAGE_VHD = '5'\nIMAGE_ISO = '6'\n\nIMAGE_FIXTURES = {\n    IMAGE_MACHINE: {\n        'image_meta': {'name': 'fakemachine', 'size': 0,\n                       'disk_format': 'ami',\n                       'container_format': 'ami'},\n    },\n    IMAGE_KERNEL: {\n        'image_meta': {'name': 'fakekernel', 'size': 0,\n                       'disk_format': 'aki',\n                       'container_format': 'aki'},\n    },\n    IMAGE_RAMDISK: {\n        'image_meta': {'name': 'fakeramdisk', 'size': 0,\n                       'disk_format': 'ari',\n                       'container_format': 'ari'},\n    },\n    IMAGE_RAW: {\n        'image_meta': {'name': 'fakeraw', 'size': 0,\n                       'disk_format': 'raw',\n                       'container_format': 'bare'},\n    },\n    IMAGE_VHD: {\n        'image_meta': {'name': 'fakevhd', 'size': 0,\n                       'disk_format': 'vhd',\n                       'container_format': 'ovf'},\n    },\n    IMAGE_ISO: {\n        'image_meta': {'name': 'fakeiso', 'size': 0,\n                       'disk_format': 'iso',\n                       'container_format': 'bare'},\n    },\n}\n\n\ndef set_image_fixtures():\n    image_service = fake_image.FakeImageService()\n    image_service.images.clear()\n    for image_id, image_meta in IMAGE_FIXTURES.items():\n        image_meta = image_meta['image_meta']\n        image_meta['id'] = image_id\n        image_service.create(None, image_meta)\n\n\ndef stub_vm_utils_with_vdi_attached_here(function, should_return=True):\n    \"\"\"\n    vm_utils.with_vdi_attached_here needs to be stubbed out because it\n    calls down to the filesystem to attach a vdi. This provides a\n    decorator to handle that.\n    \"\"\"\n    @functools.wraps(function)\n    def decorated_function(self, *args, **kwargs):\n        @contextlib.contextmanager\n        def fake_vdi_attached_here(*args, **kwargs):\n            fake_dev = 'fakedev'\n            yield fake_dev\n\n        def fake_image_download(*args, **kwargs):\n            pass\n\n        def fake_is_vdi_pv(*args, **kwargs):\n            return should_return\n\n        orig_vdi_attached_here = vm_utils.vdi_attached_here\n        orig_image_download = fake_image._FakeImageService.download\n        orig_is_vdi_pv = vm_utils._is_vdi_pv\n        try:\n            vm_utils.vdi_attached_here = fake_vdi_attached_here\n            fake_image._FakeImageService.download = fake_image_download\n            vm_utils._is_vdi_pv = fake_is_vdi_pv\n            return function(self, *args, **kwargs)\n        finally:\n            vm_utils._is_vdi_pv = orig_is_vdi_pv\n            fake_image._FakeImageService.download = orig_image_download\n            vm_utils.vdi_attached_here = orig_vdi_attached_here\n\n    return decorated_function\n\n\nclass XenAPIVolumeTestCase(stubs.XenAPITestBase):\n    \"\"\"Unit tests for Volume operations.\"\"\"\n    def setUp(self):\n        super(XenAPIVolumeTestCase, self).setUp()\n        self.user_id = 'fake'\n        self.project_id = 'fake'\n        self.context = context.RequestContext(self.user_id, self.project_id)\n        self.flags(xenapi_connection_url='test_url',\n                   xenapi_connection_password='test_pass',\n                   firewall_driver='nova.virt.xenapi.firewall.'\n                                   'Dom0IptablesFirewallDriver')\n        db_fakes.stub_out_db_instance_api(self.stubs)\n        self.instance_values = {'id': 1,\n                  'project_id': self.user_id,\n                  'user_id': 'fake',\n                  'image_ref': 1,\n                  'kernel_id': 2,\n                  'ramdisk_id': 3,\n                  'root_gb': 20,\n                  'instance_type_id': '3',  # m1.large\n                  'os_type': 'linux',\n                  'architecture': 'x86-64'}\n\n    def _create_volume(self, size=0):\n        \"\"\"Create a volume object.\"\"\"\n        vol = {}\n        vol['size'] = size\n        vol['user_id'] = 'fake'\n        vol['project_id'] = 'fake'\n        vol['host'] = 'localhost'\n        vol['availability_zone'] = FLAGS.storage_availability_zone\n        vol['status'] = \"creating\"\n        vol['attach_status'] = \"detached\"\n        return db.volume_create(self.context, vol)\n\n    @staticmethod\n    def _make_info():\n        return {\n            'driver_volume_type': 'iscsi',\n            'data': {\n                'volume_id': 1,\n                'target_iqn': 'iqn.2010-10.org.openstack:volume-00000001',\n                'target_portal': '127.0.0.1:3260,fake',\n                'target_lun': None,\n                'auth_method': 'CHAP',\n                'auth_method': 'fake',\n                'auth_method': 'fake',\n            }\n        }\n\n    def test_mountpoint_to_number(self):\n        cases = {\n            'sda': 0,\n            'sdp': 15,\n            'hda': 0,\n            'hdp': 15,\n            'vda': 0,\n            'xvda': 0,\n            '0': 0,\n            '10': 10,\n            'vdq': -1,\n            'sdq': -1,\n            'hdq': -1,\n            'xvdq': -1,\n        }\n\n        for (input, expected) in cases.iteritems():\n            actual = volume_utils.mountpoint_to_number(input)\n            self.assertEqual(actual, expected,\n                    '%s yielded %s, not %s' % (input, actual, expected))\n\n    def test_parse_volume_info_raise_exception(self):\n        \"\"\"This shows how to test helper classes' methods.\"\"\"\n        stubs.stubout_session(self.stubs, stubs.FakeSessionForVolumeTests)\n        session = xenapi_conn.XenAPISession('test_url', 'root', 'test_pass')\n        vol = self._create_volume()\n        # oops, wrong mount point!\n        self.assertRaises(volume_utils.StorageError,\n                          volume_utils.parse_volume_info,\n                          self._make_info(),\n                          'dev/sd'\n                          )\n        db.volume_destroy(context.get_admin_context(), vol['id'])\n\n    def test_attach_volume(self):\n        \"\"\"This shows how to test Ops classes' methods.\"\"\"\n        stubs.stubout_session(self.stubs, stubs.FakeSessionForVolumeTests)\n        conn = xenapi_conn.XenAPIDriver(False)\n        volume = self._create_volume()\n        instance = db.instance_create(self.context, self.instance_values)\n        vm = xenapi_fake.create_vm(instance.name, 'Running')\n        result = conn.attach_volume(self._make_info(),\n                                    instance.name, '/dev/sdc')\n\n        # check that the VM has a VBD attached to it\n        # Get XenAPI record for VBD\n        vbds = xenapi_fake.get_all('VBD')\n        vbd = xenapi_fake.get_record('VBD', vbds[0])\n        vm_ref = vbd['VM']\n        self.assertEqual(vm_ref, vm)\n\n    def test_attach_volume_raise_exception(self):\n        \"\"\"This shows how to test when exceptions are raised.\"\"\"\n        stubs.stubout_session(self.stubs,\n                              stubs.FakeSessionForVolumeFailedTests)\n        conn = xenapi_conn.XenAPIDriver(False)\n        volume = self._create_volume()\n        instance = db.instance_create(self.context, self.instance_values)\n        xenapi_fake.create_vm(instance.name, 'Running')\n        self.assertRaises(exception.VolumeDriverNotFound,\n                          conn.attach_volume,\n                          {'driver_volume_type': 'nonexist'},\n                          instance.name,\n                          '/dev/sdc')\n\n\nclass XenAPIVMTestCase(stubs.XenAPITestBase):\n    \"\"\"Unit tests for VM operations.\"\"\"\n    def setUp(self):\n        super(XenAPIVMTestCase, self).setUp()\n        self.network = importutils.import_object(FLAGS.network_manager)\n        self.flags(xenapi_connection_url='test_url',\n                   xenapi_connection_password='test_pass',\n                   instance_name_template='%d',\n                   firewall_driver='nova.virt.xenapi.firewall.'\n                                   'Dom0IptablesFirewallDriver')\n        xenapi_fake.create_local_srs()\n        xenapi_fake.create_local_pifs()\n        db_fakes.stub_out_db_instance_api(self.stubs)\n        xenapi_fake.create_network('fake', FLAGS.flat_network_bridge)\n        stubs.stubout_session(self.stubs, stubs.FakeSessionForVMTests)\n        stubs.stubout_get_this_vm_uuid(self.stubs)\n        stubs.stubout_is_vdi_pv(self.stubs)\n        stubs.stub_out_vm_methods(self.stubs)\n        fake_utils.stub_out_utils_execute(self.stubs)\n        self.user_id = 'fake'\n        self.project_id = 'fake'\n        self.context = context.RequestContext(self.user_id, self.project_id)\n        self.conn = xenapi_conn.XenAPIDriver(False)\n\n        fake_image.stub_out_image_service(self.stubs)\n        set_image_fixtures()\n        stubs.stubout_image_service_download(self.stubs)\n        stubs.stubout_stream_disk(self.stubs)\n\n        def fake_inject_instance_metadata(self, instance, vm):\n            pass\n        self.stubs.Set(vmops.VMOps, 'inject_instance_metadata',\n                       fake_inject_instance_metadata)\n\n        def fake_safe_copy_vdi(session, sr_ref, instance, vdi_to_copy_ref):\n            name_label = \"fakenamelabel\"\n            disk_type = \"fakedisktype\"\n            virtual_size = 777\n            return vm_utils.create_vdi(\n                    session, sr_ref, instance, name_label, disk_type,\n                    virtual_size)\n        self.stubs.Set(vm_utils, '_safe_copy_vdi', fake_safe_copy_vdi)\n\n    def tearDown(self):\n        super(XenAPIVMTestCase, self).tearDown()\n        fake_image.FakeImageService_reset()\n\n    def test_init_host(self):\n        session = xenapi_conn.XenAPISession('test_url', 'root', 'test_pass')\n        vm = vm_utils._get_this_vm_ref(session)\n        # Local root disk\n        vdi0 = xenapi_fake.create_vdi('compute', None)\n        vbd0 = xenapi_fake.create_vbd(vm, vdi0)\n        # Instance VDI\n        vdi1 = xenapi_fake.create_vdi('instance-aaaa', None,\n                other_config={'nova_instance_uuid': 'aaaa'})\n        vbd1 = xenapi_fake.create_vbd(vm, vdi1)\n        # Only looks like instance VDI\n        vdi2 = xenapi_fake.create_vdi('instance-bbbb', None)\n        vbd2 = xenapi_fake.create_vbd(vm, vdi2)\n\n        self.conn.init_host(None)\n        self.assertEquals(set(xenapi_fake.get_all('VBD')), set([vbd0, vbd2]))\n\n    def test_list_instances_0(self):\n        instances = self.conn.list_instances()\n        self.assertEquals(instances, [])\n\n    def test_get_rrd_server(self):\n        self.flags(xenapi_connection_url='myscheme://myaddress/')\n        server_info = vm_utils._get_rrd_server()\n        self.assertEqual(server_info[0], 'myscheme')\n        self.assertEqual(server_info[1], 'myaddress')\n\n    def test_get_diagnostics(self):\n        def fake_get_rrd(host, vm_uuid):\n            with open('xenapi/vm_rrd.xml') as f:\n                return re.sub(r'\\s', '', f.read())\n        self.stubs.Set(vm_utils, '_get_rrd', fake_get_rrd)\n\n        fake_diagnostics = {\n            'vbd_xvdb_write': '0.0',\n            'memory_target': '4294967296.0000',\n            'memory_internal_free': '1415564.0000',\n            'memory': '4294967296.0000',\n            'vbd_xvda_write': '0.0',\n            'cpu0': '0.0042',\n            'vif_0_tx': '287.4134',\n            'vbd_xvda_read': '0.0',\n            'vif_0_rx': '1816.0144',\n            'vif_2_rx': '0.0',\n            'vif_2_tx': '0.0',\n            'vbd_xvdb_read': '0.0',\n            'last_update': '1328795567',\n        }\n        instance = self._create_instance()\n        expected = self.conn.get_diagnostics(instance)\n        self.assertDictMatch(fake_diagnostics, expected)\n\n    def test_instance_snapshot_fails_with_no_primary_vdi(self):\n        def create_bad_vbd(vm_ref, vdi_ref):\n            vbd_rec = {'VM': vm_ref,\n               'VDI': vdi_ref,\n               'userdevice': 'fake',\n               'currently_attached': False}\n            vbd_ref = xenapi_fake._create_object('VBD', vbd_rec)\n            xenapi_fake.after_VBD_create(vbd_ref, vbd_rec)\n            return vbd_ref\n\n        self.stubs.Set(xenapi_fake, 'create_vbd', create_bad_vbd)\n        stubs.stubout_instance_snapshot(self.stubs)\n        # Stubbing out firewall driver as previous stub sets alters\n        # xml rpc result parsing\n        stubs.stubout_firewall_driver(self.stubs, self.conn)\n        instance = self._create_instance()\n\n        image_id = \"my_snapshot_id\"\n        self.assertRaises(exception.NovaException, self.conn.snapshot,\n                          self.context, instance, image_id)\n\n    def test_instance_snapshot(self):\n        stubs.stubout_instance_snapshot(self.stubs)\n        stubs.stubout_is_snapshot(self.stubs)\n        # Stubbing out firewall driver as previous stub sets alters\n        # xml rpc result parsing\n        stubs.stubout_firewall_driver(self.stubs, self.conn)\n        instance = self._create_instance()\n\n        image_id = \"my_snapshot_id\"\n        self.conn.snapshot(self.context, instance, image_id)\n\n        # Ensure VM was torn down\n        vm_labels = []\n        for vm_ref in xenapi_fake.get_all('VM'):\n            vm_rec = xenapi_fake.get_record('VM', vm_ref)\n            if not vm_rec[\"is_control_domain\"]:\n                vm_labels.append(vm_rec[\"name_label\"])\n\n        self.assertEquals(vm_labels, [instance.name])\n\n        # Ensure VBDs were torn down\n        vbd_labels = []\n        for vbd_ref in xenapi_fake.get_all('VBD'):\n            vbd_rec = xenapi_fake.get_record('VBD', vbd_ref)\n            vbd_labels.append(vbd_rec[\"vm_name_label\"])\n\n        self.assertEquals(vbd_labels, [instance.name])\n\n        # Ensure VDIs were torn down\n        for vdi_ref in xenapi_fake.get_all('VDI'):\n            vdi_rec = xenapi_fake.get_record('VDI', vdi_ref)\n            name_label = vdi_rec[\"name_label\"]\n            self.assert_(not name_label.endswith('snapshot'))\n\n    def create_vm_record(self, conn, os_type, name):\n        instances = conn.list_instances()\n        self.assertEquals(instances, [name])\n\n        # Get Nova record for VM\n        vm_info = conn.get_info({'name': name})\n        # Get XenAPI record for VM\n        vms = [rec for ref, rec\n               in xenapi_fake.get_all_records('VM').iteritems()\n               if not rec['is_control_domain']]\n        vm = vms[0]\n        self.vm_info = vm_info\n        self.vm = vm\n\n    def check_vm_record(self, conn, check_injection=False):\n        # Check that m1.large above turned into the right thing.\n        instance_type = db.instance_type_get_by_name(conn, 'm1.large')\n        mem_kib = long(instance_type['memory_mb']) << 10\n        mem_bytes = str(mem_kib << 10)\n        vcpus = instance_type['vcpus']\n        self.assertEquals(self.vm_info['max_mem'], mem_kib)\n        self.assertEquals(self.vm_info['mem'], mem_kib)\n        self.assertEquals(self.vm['memory_static_max'], mem_bytes)\n        self.assertEquals(self.vm['memory_dynamic_max'], mem_bytes)\n        self.assertEquals(self.vm['memory_dynamic_min'], mem_bytes)\n        self.assertEquals(self.vm['VCPUs_max'], str(vcpus))\n        self.assertEquals(self.vm['VCPUs_at_startup'], str(vcpus))\n\n        # Check that the VM is running according to Nova\n        self.assertEquals(self.vm_info['state'], power_state.RUNNING)\n\n        # Check that the VM is running according to XenAPI.\n        self.assertEquals(self.vm['power_state'], 'Running')\n\n        if check_injection:\n            xenstore_data = self.vm['xenstore_data']\n            self.assertEquals(xenstore_data['vm-data/hostname'], 'test')\n            key = 'vm-data/networking/DEADBEEF0001'\n            xenstore_value = xenstore_data[key]\n            tcpip_data = ast.literal_eval(xenstore_value)\n            self.assertEquals(tcpip_data,\n                              {'broadcast': '192.168.1.255',\n                               'dns': ['192.168.1.4', '192.168.1.3'],\n                               'gateway': '192.168.1.1',\n                               'gateway_v6': 'fe80::def',\n                               'ip6s': [{'enabled': '1',\n                                         'ip': '2001:db8:0:1::1',\n                                         'netmask': 64,\n                                         'gateway': 'fe80::def'}],\n                               'ips': [{'enabled': '1',\n                                        'ip': '192.168.1.100',\n                                        'netmask': '255.255.255.0',\n                                        'gateway': '192.168.1.1'},\n                                       {'enabled': '1',\n                                        'ip': '192.168.1.101',\n                                        'netmask': '255.255.255.0',\n                                        'gateway': '192.168.1.1'}],\n                               'label': 'test1',\n                               'mac': 'DE:AD:BE:EF:00:01'})\n\n    def check_vm_params_for_windows(self):\n        self.assertEquals(self.vm['platform']['nx'], 'true')\n        self.assertEquals(self.vm['HVM_boot_params'], {'order': 'dc'})\n        self.assertEquals(self.vm['HVM_boot_policy'], 'BIOS order')\n\n        # check that these are not set\n        self.assertEquals(self.vm['PV_args'], '')\n        self.assertEquals(self.vm['PV_bootloader'], '')\n        self.assertEquals(self.vm['PV_kernel'], '')\n        self.assertEquals(self.vm['PV_ramdisk'], '')\n\n    def check_vm_params_for_linux(self):\n        self.assertEquals(self.vm['platform']['nx'], 'false')\n        self.assertEquals(self.vm['PV_args'], '')\n        self.assertEquals(self.vm['PV_bootloader'], 'pygrub')\n\n        # check that these are not set\n        self.assertEquals(self.vm['PV_kernel'], '')\n        self.assertEquals(self.vm['PV_ramdisk'], '')\n        self.assertEquals(self.vm['HVM_boot_params'], {})\n        self.assertEquals(self.vm['HVM_boot_policy'], '')\n\n    def check_vm_params_for_linux_with_external_kernel(self):\n        self.assertEquals(self.vm['platform']['nx'], 'false')\n        self.assertEquals(self.vm['PV_args'], 'root=/dev/xvda1')\n        self.assertNotEquals(self.vm['PV_kernel'], '')\n        self.assertNotEquals(self.vm['PV_ramdisk'], '')\n\n        # check that these are not set\n        self.assertEquals(self.vm['HVM_boot_params'], {})\n        self.assertEquals(self.vm['HVM_boot_policy'], '')\n\n    def _list_vdis(self):\n        url = FLAGS.xenapi_connection_url\n        username = FLAGS.xenapi_connection_username\n        password = FLAGS.xenapi_connection_password\n        session = xenapi_conn.XenAPISession(url, username, password)\n        return session.call_xenapi('VDI.get_all')\n\n    def _check_vdis(self, start_list, end_list):\n        for vdi_ref in end_list:\n            if not vdi_ref in start_list:\n                vdi_rec = xenapi_fake.get_record('VDI', vdi_ref)\n                # If the cache is turned on then the base disk will be\n                # there even after the cleanup\n                if 'other_config' in vdi_rec:\n                    if 'image-id' not in vdi_rec['other_config']:\n                        self.fail('Found unexpected VDI:%s' % vdi_ref)\n                else:\n                    self.fail('Found unexpected VDI:%s' % vdi_ref)\n\n    def _test_spawn(self, image_ref, kernel_id, ramdisk_id,\n                    instance_type_id=\"3\", os_type=\"linux\",\n                    hostname=\"test\", architecture=\"x86-64\", instance_id=1,\n                    check_injection=False,\n                    create_record=True, empty_dns=False):\n        # Fake out inject_instance_metadata\n        def fake_inject_instance_metadata(self, instance, vm):\n            pass\n        self.stubs.Set(vmops.VMOps, 'inject_instance_metadata',\n                       fake_inject_instance_metadata)\n\n        if create_record:\n            instance_values = {'id': instance_id,\n                      'project_id': self.project_id,\n                      'user_id': self.user_id,\n                      'image_ref': image_ref,\n                      'kernel_id': kernel_id,\n                      'ramdisk_id': ramdisk_id,\n                      'root_gb': 20,\n                      'instance_type_id': instance_type_id,\n                      'os_type': os_type,\n                      'hostname': hostname,\n                      'architecture': architecture}\n            instance = db.instance_create(self.context, instance_values)\n        else:\n            instance = db.instance_get(self.context, instance_id)\n\n        network_info = fake_network.fake_get_instance_nw_info(self.stubs,\n                                                              spectacular=True)\n        if empty_dns:\n            # NOTE(tr3buchet): this is a terrible way to do this...\n            network_info[0]['network']['subnets'][0]['dns'] = []\n\n        # admin_pass isn't part of the DB model, but it does get set as\n        # an attribute for spawn to use\n        instance.admin_pass = 'herp'\n        image_meta = {'id': IMAGE_VHD,\n                      'disk_format': 'vhd'}\n        self.conn.spawn(self.context, instance, image_meta, network_info)\n        self.create_vm_record(self.conn, os_type, instance['name'])\n        self.check_vm_record(self.conn, check_injection)\n        self.assertTrue(instance.os_type)\n        self.assertTrue(instance.architecture)\n\n    def test_spawn_empty_dns(self):\n        \"\"\"Test spawning with an empty dns list\"\"\"\n        self._test_spawn(IMAGE_VHD, None, None,\n                         os_type=\"linux\", architecture=\"x86-64\",\n                         empty_dns=True)\n        self.check_vm_params_for_linux()\n\n    def test_spawn_not_enough_memory(self):\n        self.assertRaises(exception.InsufficientFreeMemory,\n                          self._test_spawn,\n                          1, 2, 3, \"4\")  # m1.xlarge\n\n    def test_spawn_fail_cleanup_1(self):\n        \"\"\"Simulates an error while downloading an image.\n\n        Verifies that VDIs created are properly cleaned up.\n\n        \"\"\"\n        vdi_recs_start = self._list_vdis()\n        stubs.stubout_fetch_disk_image(self.stubs, raise_failure=True)\n        self.assertRaises(xenapi_fake.Failure,\n                          self._test_spawn, 1, 2, 3)\n        # No additional VDI should be found.\n        vdi_recs_end = self._list_vdis()\n        self._check_vdis(vdi_recs_start, vdi_recs_end)\n\n    def test_spawn_fail_cleanup_2(self):\n        \"\"\"Simulates an error while creating VM record.\n\n        It verifies that VDIs created are properly cleaned up.\n\n        \"\"\"\n        vdi_recs_start = self._list_vdis()\n        stubs.stubout_create_vm(self.stubs)\n        self.assertRaises(xenapi_fake.Failure,\n                          self._test_spawn, 1, 2, 3)\n        # No additional VDI should be found.\n        vdi_recs_end = self._list_vdis()\n        self._check_vdis(vdi_recs_start, vdi_recs_end)\n\n    @stub_vm_utils_with_vdi_attached_here\n    def test_spawn_raw_glance(self):\n        self._test_spawn(IMAGE_RAW, None, None)\n        self.check_vm_params_for_linux()\n\n    def test_spawn_vhd_glance_linux(self):\n        self._test_spawn(IMAGE_VHD, None, None,\n                         os_type=\"linux\", architecture=\"x86-64\")\n        self.check_vm_params_for_linux()\n\n    def test_spawn_vhd_glance_swapdisk(self):\n        # Change the default host_call_plugin to one that'll return\n        # a swap disk\n        orig_func = stubs.FakeSessionForVMTests.host_call_plugin\n        _host_call_plugin = stubs.FakeSessionForVMTests.host_call_plugin_swap\n        stubs.FakeSessionForVMTests.host_call_plugin = _host_call_plugin\n        # Stubbing out firewall driver as previous stub sets a particular\n        # stub for async plugin calls\n        stubs.stubout_firewall_driver(self.stubs, self.conn)\n        try:\n            # We'll steal the above glance linux test\n            self.test_spawn_vhd_glance_linux()\n        finally:\n            # Make sure to put this back\n            stubs.FakeSessionForVMTests.host_call_plugin = orig_func\n\n        # We should have 2 VBDs.\n        self.assertEqual(len(self.vm['VBDs']), 2)\n        # Now test that we have 1.\n        self.tearDown()\n        self.setUp()\n        self.test_spawn_vhd_glance_linux()\n        self.assertEqual(len(self.vm['VBDs']), 1)\n\n    def test_spawn_vhd_glance_windows(self):\n        self._test_spawn(IMAGE_VHD, None, None,\n                         os_type=\"windows\", architecture=\"i386\")\n        self.check_vm_params_for_windows()\n\n    def test_spawn_iso_glance(self):\n        self._test_spawn(IMAGE_ISO, None, None,\n                         os_type=\"windows\", architecture=\"i386\")\n        self.check_vm_params_for_windows()\n\n    def test_spawn_glance(self):\n        stubs.stubout_fetch_disk_image(self.stubs)\n        self._test_spawn(IMAGE_MACHINE,\n                         IMAGE_KERNEL,\n                         IMAGE_RAMDISK)\n        self.check_vm_params_for_linux_with_external_kernel()\n\n    def test_spawn_netinject_file(self):\n        self.flags(flat_injected=True)\n        db_fakes.stub_out_db_instance_api(self.stubs, injected=True)\n\n        self._tee_executed = False\n\n        def _tee_handler(cmd, **kwargs):\n            input = kwargs.get('process_input', None)\n            self.assertNotEqual(input, None)\n            config = [line.strip() for line in input.split(\"\\n\")]\n            # Find the start of eth0 configuration and check it\n            index = config.index('auto eth0')\n            self.assertEquals(config[index + 1:index + 8], [\n                'iface eth0 inet static',\n                'address 192.168.1.100',\n                'netmask 255.255.255.0',\n                'broadcast 192.168.1.255',\n                'gateway 192.168.1.1',\n                'dns-nameservers 192.168.1.3 192.168.1.4',\n                ''])\n            self._tee_executed = True\n            return '', ''\n\n        fake_utils.fake_execute_set_repliers([\n            # Capture the tee .../etc/network/interfaces command\n            (r'tee.*interfaces', _tee_handler),\n        ])\n        self._test_spawn(IMAGE_MACHINE,\n                         IMAGE_KERNEL,\n                         IMAGE_RAMDISK,\n                         check_injection=True)\n        self.assertTrue(self._tee_executed)\n\n    def test_spawn_netinject_xenstore(self):\n        db_fakes.stub_out_db_instance_api(self.stubs, injected=True)\n\n        self._tee_executed = False\n\n        def _mount_handler(cmd, *ignore_args, **ignore_kwargs):\n            # When mounting, create real files under the mountpoint to simulate\n            # files in the mounted filesystem\n\n            # mount point will be the last item of the command list\n            self._tmpdir = cmd[len(cmd) - 1]\n            LOG.debug(_('Creating files in %s to simulate guest agent'),\n                      self._tmpdir)\n            os.makedirs(os.path.join(self._tmpdir, 'usr', 'sbin'))\n            # Touch the file using open\n            open(os.path.join(self._tmpdir, 'usr', 'sbin',\n                'xe-update-networking'), 'w').close()\n            return '', ''\n\n        def _umount_handler(cmd, *ignore_args, **ignore_kwargs):\n            # Umount would normall make files in the m,ounted filesystem\n            # disappear, so do that here\n            LOG.debug(_('Removing simulated guest agent files in %s'),\n                      self._tmpdir)\n            os.remove(os.path.join(self._tmpdir, 'usr', 'sbin',\n                'xe-update-networking'))\n            os.rmdir(os.path.join(self._tmpdir, 'usr', 'sbin'))\n            os.rmdir(os.path.join(self._tmpdir, 'usr'))\n            return '', ''\n\n        def _tee_handler(cmd, *ignore_args, **ignore_kwargs):\n            self._tee_executed = True\n            return '', ''\n\n        fake_utils.fake_execute_set_repliers([\n            (r'mount', _mount_handler),\n            (r'umount', _umount_handler),\n            (r'tee.*interfaces', _tee_handler)])\n        self._test_spawn(1, 2, 3, check_injection=True)\n\n        # tee must not run in this case, where an injection-capable\n        # guest agent is detected\n        self.assertFalse(self._tee_executed)\n\n    def test_spawn_vlanmanager(self):\n        self.flags(network_manager='nova.network.manager.VlanManager',\n                   vlan_interface='fake0')\n\n        def dummy(*args, **kwargs):\n            pass\n\n        self.stubs.Set(vmops.VMOps, '_create_vifs', dummy)\n        # Reset network table\n        xenapi_fake.reset_table('network')\n        # Instance id = 2 will use vlan network (see db/fakes.py)\n        ctxt = self.context.elevated()\n        instance = self._create_instance(2, False)\n        networks = self.network.db.network_get_all(ctxt)\n        for network in networks:\n            self.network.set_network_host(ctxt, network)\n\n        self.network.allocate_for_instance(ctxt,\n                          instance_id=2,\n                          instance_uuid='00000000-0000-0000-0000-000000000002',\n                          host=FLAGS.host,\n                          vpn=None,\n                          rxtx_factor=3,\n                          project_id=self.project_id)\n        self._test_spawn(IMAGE_MACHINE,\n                         IMAGE_KERNEL,\n                         IMAGE_RAMDISK,\n                         instance_id=2,\n                         create_record=False)\n        # TODO(salvatore-orlando): a complete test here would require\n        # a check for making sure the bridge for the VM's VIF is\n        # consistent with bridge specified in nova db\n\n    def test_spawn_with_network_qos(self):\n        self._create_instance()\n        for vif_ref in xenapi_fake.get_all('VIF'):\n            vif_rec = xenapi_fake.get_record('VIF', vif_ref)\n            self.assertEquals(vif_rec['qos_algorithm_type'], 'ratelimit')\n            self.assertEquals(vif_rec['qos_algorithm_params']['kbps'],\n                              str(3 * 10 * 1024))\n\n    def test_rescue(self):\n        instance = self._create_instance()\n        session = xenapi_conn.XenAPISession('test_url', 'root', 'test_pass')\n        vm_ref = vm_utils.lookup(session, instance.name)\n\n        swap_vdi_ref = xenapi_fake.create_vdi('swap', None)\n        root_vdi_ref = xenapi_fake.create_vdi('root', None)\n\n        xenapi_fake.create_vbd(vm_ref, swap_vdi_ref, userdevice=1)\n        xenapi_fake.create_vbd(vm_ref, root_vdi_ref, userdevice=0)\n\n        conn = xenapi_conn.XenAPIDriver(False)\n        image_meta = {'id': IMAGE_VHD,\n                      'disk_format': 'vhd'}\n        conn.rescue(self.context, instance, [], image_meta)\n\n        vm = xenapi_fake.get_record('VM', vm_ref)\n        rescue_name = \"%s-rescue\" % vm[\"name_label\"]\n        rescue_ref = vm_utils.lookup(session, rescue_name)\n        rescue_vm = xenapi_fake.get_record('VM', rescue_ref)\n\n        vdi_uuids = []\n        for vbd_uuid in rescue_vm[\"VBDs\"]:\n            vdi_uuids.append(xenapi_fake.get_record('VBD', vbd_uuid)[\"VDI\"])\n        self.assertTrue(\"swap\" not in vdi_uuids)\n\n    def test_unrescue(self):\n        instance = self._create_instance()\n        conn = xenapi_conn.XenAPIDriver(False)\n        # Unrescue expects the original instance to be powered off\n        conn.power_off(instance)\n        rescue_vm = xenapi_fake.create_vm(instance.name + '-rescue', 'Running')\n        conn.unrescue(instance, None)\n\n    def test_unrescue_not_in_rescue(self):\n        instance = self._create_instance()\n        conn = xenapi_conn.XenAPIDriver(False)\n        # Ensure that it will not unrescue a non-rescued instance.\n        self.assertRaises(exception.InstanceNotInRescueMode, conn.unrescue,\n                          instance, None)\n\n    def test_finish_revert_migration(self):\n        instance = self._create_instance()\n\n        class VMOpsMock():\n\n            def __init__(self):\n                self.finish_revert_migration_called = False\n\n            def finish_revert_migration(self, instance):\n                self.finish_revert_migration_called = True\n\n        conn = xenapi_conn.XenAPIDriver(False)\n        conn._vmops = VMOpsMock()\n        conn.finish_revert_migration(instance, None)\n        self.assertTrue(conn._vmops.finish_revert_migration_called)\n\n    def test_reboot_hard(self):\n        instance = self._create_instance()\n        conn = xenapi_conn.XenAPIDriver(False)\n        conn.reboot(instance, None, \"HARD\")\n\n    def test_reboot_soft(self):\n        instance = self._create_instance()\n        conn = xenapi_conn.XenAPIDriver(False)\n        conn.reboot(instance, None, \"SOFT\")\n\n    def test_reboot_halted(self):\n        session = xenapi_conn.XenAPISession('test_url', 'root', 'test_pass')\n        instance = self._create_instance(spawn=False)\n        conn = xenapi_conn.XenAPIDriver(False)\n        xenapi_fake.create_vm(instance.name, 'Halted')\n        conn.reboot(instance, None, \"SOFT\")\n        vm_ref = vm_utils.lookup(session, instance.name)\n        vm = xenapi_fake.get_record('VM', vm_ref)\n        self.assertEquals(vm['power_state'], 'Running')\n\n    def test_reboot_unknown_state(self):\n        instance = self._create_instance(spawn=False)\n        conn = xenapi_conn.XenAPIDriver(False)\n        xenapi_fake.create_vm(instance.name, 'Unknown')\n        self.assertRaises(xenapi_fake.Failure, conn.reboot, instance,\n                None, \"SOFT\")\n\n    def _create_instance(self, instance_id=1, spawn=True):\n        \"\"\"Creates and spawns a test instance.\"\"\"\n        instance_values = {\n            'id': instance_id,\n            'uuid': '00000000-0000-0000-0000-00000000000%d' % instance_id,\n            'project_id': self.project_id,\n            'user_id': self.user_id,\n            'image_ref': 1,\n            'kernel_id': 2,\n            'ramdisk_id': 3,\n            'root_gb': 20,\n            'instance_type_id': '3',  # m1.large\n            'os_type': 'linux',\n            'vm_mode': 'hvm',\n            'architecture': 'x86-64'}\n        instance = db.instance_create(self.context, instance_values)\n        network_info = fake_network.fake_get_instance_nw_info(self.stubs,\n                                                              spectacular=True)\n        image_meta = {'id': IMAGE_VHD,\n                      'disk_format': 'vhd'}\n        if spawn:\n            instance.admin_pass = 'herp'\n            self.conn.spawn(self.context, instance, image_meta, network_info)\n        return instance\n\n\nclass XenAPIDiffieHellmanTestCase(test.TestCase):\n    \"\"\"Unit tests for Diffie-Hellman code.\"\"\"\n    def setUp(self):\n        super(XenAPIDiffieHellmanTestCase, self).setUp()\n        self.alice = agent.SimpleDH()\n        self.bob = agent.SimpleDH()\n\n    def test_shared(self):\n        alice_pub = self.alice.get_public()\n        bob_pub = self.bob.get_public()\n        alice_shared = self.alice.compute_shared(bob_pub)\n        bob_shared = self.bob.compute_shared(alice_pub)\n        self.assertEquals(alice_shared, bob_shared)\n\n    def _test_encryption(self, message):\n        enc = self.alice.encrypt(message)\n        self.assertFalse(enc.endswith('\\n'))\n        dec = self.bob.decrypt(enc)\n        self.assertEquals(dec, message)\n\n    def test_encrypt_simple_message(self):\n        self._test_encryption('This is a simple message.')\n\n    def test_encrypt_message_with_newlines_at_end(self):\n        self._test_encryption('This message has a newline at the end.\\n')\n\n    def test_encrypt_many_newlines_at_end(self):\n        self._test_encryption('Message with lotsa newlines.\\n\\n\\n')\n\n    def test_encrypt_newlines_inside_message(self):\n        self._test_encryption('Message\\nwith\\ninterior\\nnewlines.')\n\n    def test_encrypt_with_leading_newlines(self):\n        self._test_encryption('\\n\\nMessage with leading newlines.')\n\n    def test_encrypt_really_long_message(self):\n        self._test_encryption(''.join(['abcd' for i in xrange(1024)]))\n\n\nclass XenAPIMigrateInstance(stubs.XenAPITestBase):\n    \"\"\"Unit test for verifying migration-related actions.\"\"\"\n\n    def setUp(self):\n        super(XenAPIMigrateInstance, self).setUp()\n        self.flags(xenapi_connection_url='test_url',\n                   xenapi_connection_password='test_pass',\n                   firewall_driver='nova.virt.xenapi.firewall.'\n                                   'Dom0IptablesFirewallDriver')\n        stubs.stubout_session(self.stubs, stubs.FakeSessionForVMTests)\n        db_fakes.stub_out_db_instance_api(self.stubs)\n        xenapi_fake.create_network('fake', FLAGS.flat_network_bridge)\n        self.user_id = 'fake'\n        self.project_id = 'fake'\n        self.context = context.RequestContext(self.user_id, self.project_id)\n        self.instance_values = {'id': 1,\n                  'project_id': self.project_id,\n                  'user_id': self.user_id,\n                  'image_ref': 1,\n                  'kernel_id': None,\n                  'ramdisk_id': None,\n                  'root_gb': 5,\n                  'instance_type_id': '3',  # m1.large\n                  'os_type': 'linux',\n                  'architecture': 'x86-64'}\n\n        migration_values = {\n            'source_compute': 'nova-compute',\n            'dest_compute': 'nova-compute',\n            'dest_host': '10.127.5.114',\n            'status': 'post-migrating',\n            'instance_uuid': '15f23e6a-cc6e-4d22-b651-d9bdaac316f7',\n            'old_instance_type_id': 5,\n            'new_instance_type_id': 1\n        }\n        self.migration = db.migration_create(\n            context.get_admin_context(), migration_values)\n\n        fake_utils.stub_out_utils_execute(self.stubs)\n        stubs.stub_out_migration_methods(self.stubs)\n        stubs.stubout_get_this_vm_uuid(self.stubs)\n\n        def fake_inject_instance_metadata(self, instance, vm):\n            pass\n        self.stubs.Set(vmops.VMOps, 'inject_instance_metadata',\n                       fake_inject_instance_metadata)\n\n    def test_resize_xenserver_6(self):\n        instance = db.instance_create(self.context, self.instance_values)\n        called = {'resize': False}\n\n        def fake_vdi_resize(*args, **kwargs):\n            called['resize'] = True\n\n        self.stubs.Set(stubs.FakeSessionForVMTests,\n                       \"VDI_resize\", fake_vdi_resize)\n        stubs.stubout_session(self.stubs, stubs.FakeSessionForVMTests,\n                              product_version=(6, 0, 0),\n                              product_brand='XenServer')\n        conn = xenapi_conn.XenAPIDriver(False)\n        vdi_ref = xenapi_fake.create_vdi('hurr', 'fake')\n        vdi_uuid = xenapi_fake.get_record('VDI', vdi_ref)['uuid']\n        conn._vmops._resize_instance(instance,\n                                     {'uuid': vdi_uuid, 'ref': vdi_ref})\n        self.assertEqual(called['resize'], True)\n\n    def test_resize_xcp(self):\n        instance = db.instance_create(self.context, self.instance_values)\n        called = {'resize': False}\n\n        def fake_vdi_resize(*args, **kwargs):\n            called['resize'] = True\n\n        self.stubs.Set(stubs.FakeSessionForVMTests,\n                       \"VDI_resize\", fake_vdi_resize)\n        stubs.stubout_session(self.stubs, stubs.FakeSessionForVMTests,\n                              product_version=(1, 4, 99),\n                              product_brand='XCP')\n        conn = xenapi_conn.XenAPIDriver(False)\n        vdi_ref = xenapi_fake.create_vdi('hurr', 'fake')\n        vdi_uuid = xenapi_fake.get_record('VDI', vdi_ref)['uuid']\n        conn._vmops._resize_instance(instance,\n                                     {'uuid': vdi_uuid, 'ref': vdi_ref})\n        self.assertEqual(called['resize'], True)\n\n    def test_migrate_disk_and_power_off(self):\n        instance = db.instance_create(self.context, self.instance_values)\n        xenapi_fake.create_vm(instance.name, 'Running')\n        instance_type = db.instance_type_get_by_name(self.context, 'm1.large')\n        conn = xenapi_conn.XenAPIDriver(False)\n        conn.migrate_disk_and_power_off(self.context, instance,\n                                        '127.0.0.1', instance_type, None)\n\n    def test_migrate_disk_and_power_off(self):\n        instance = db.instance_create(self.context, self.instance_values)\n        xenapi_fake.create_vm(instance.name, 'Running')\n        instance_type = db.instance_type_get_by_name(self.context, 'm1.large')\n        conn = xenapi_conn.XenAPIDriver(False)\n        conn.migrate_disk_and_power_off(self.context, instance,\n                                        '127.0.0.1', instance_type, None)\n\n    def test_migrate_disk_and_power_off_passes_exceptions(self):\n        instance = db.instance_create(self.context, self.instance_values)\n        xenapi_fake.create_vm(instance.name, 'Running')\n        instance_type = db.instance_type_get_by_name(self.context, 'm1.large')\n\n        def fake_raise(*args, **kwargs):\n            raise exception.MigrationError(reason='test failure')\n        self.stubs.Set(vmops.VMOps, \"_migrate_vhd\", fake_raise)\n\n        conn = xenapi_conn.XenAPIDriver(False)\n        self.assertRaises(exception.MigrationError,\n                          conn.migrate_disk_and_power_off,\n                          self.context, instance,\n                          '127.0.0.1', instance_type, None)\n\n    def test_revert_migrate(self):\n        instance = db.instance_create(self.context, self.instance_values)\n        self.called = False\n        self.fake_vm_start_called = False\n        self.fake_finish_revert_migration_called = False\n\n        def fake_vm_start(*args, **kwargs):\n            self.fake_vm_start_called = True\n\n        def fake_vdi_resize(*args, **kwargs):\n            self.called = True\n\n        def fake_finish_revert_migration(*args, **kwargs):\n            self.fake_finish_revert_migration_called = True\n\n        self.stubs.Set(stubs.FakeSessionForVMTests,\n                       \"VDI_resize_online\", fake_vdi_resize)\n        self.stubs.Set(vmops.VMOps, '_start', fake_vm_start)\n        self.stubs.Set(vmops.VMOps, 'finish_revert_migration',\n                       fake_finish_revert_migration)\n        stubs.stubout_session(self.stubs, stubs.FakeSessionForVMTests,\n                              product_version=(4, 0, 0),\n                              product_brand='XenServer')\n\n        conn = xenapi_conn.XenAPIDriver(False)\n        network_info = fake_network.fake_get_instance_nw_info(self.stubs,\n                                                              spectacular=True)\n        image_meta = {'id': instance.image_ref, 'disk_format': 'vhd'}\n        base = xenapi_fake.create_vdi('hurr', 'fake')\n        base_uuid = xenapi_fake.get_record('VDI', base)['uuid']\n        cow = xenapi_fake.create_vdi('durr', 'fake')\n        cow_uuid = xenapi_fake.get_record('VDI', cow)['uuid']\n        conn.finish_migration(self.context, self.migration, instance,\n                              dict(base_copy=base_uuid, cow=cow_uuid),\n                              network_info, image_meta, resize_instance=True)\n        self.assertEqual(self.called, True)\n        self.assertEqual(self.fake_vm_start_called, True)\n\n        conn.finish_revert_migration(instance, network_info)\n        self.assertEqual(self.fake_finish_revert_migration_called, True)\n\n    def test_finish_migrate(self):\n        instance = db.instance_create(self.context, self.instance_values)\n        self.called = False\n        self.fake_vm_start_called = False\n\n        def fake_vm_start(*args, **kwargs):\n            self.fake_vm_start_called = True\n\n        def fake_vdi_resize(*args, **kwargs):\n            self.called = True\n\n        self.stubs.Set(vmops.VMOps, '_start', fake_vm_start)\n        self.stubs.Set(stubs.FakeSessionForVMTests,\n                       \"VDI_resize_online\", fake_vdi_resize)\n        stubs.stubout_session(self.stubs, stubs.FakeSessionForVMTests,\n                              product_version=(4, 0, 0),\n                              product_brand='XenServer')\n\n        conn = xenapi_conn.XenAPIDriver(False)\n        network_info = fake_network.fake_get_instance_nw_info(self.stubs,\n                                                              spectacular=True)\n        image_meta = {'id': instance.image_ref, 'disk_format': 'vhd'}\n        conn.finish_migration(self.context, self.migration, instance,\n                              dict(base_copy='hurr', cow='durr'),\n                              network_info, image_meta, resize_instance=True)\n        self.assertEqual(self.called, True)\n        self.assertEqual(self.fake_vm_start_called, True)\n\n    def test_finish_migrate_no_local_storage(self):\n        tiny_type = instance_types.get_instance_type_by_name('m1.tiny')\n        tiny_type_id = tiny_type['id']\n        self.instance_values.update({'instance_type_id': tiny_type_id,\n                                     'root_gb': 0})\n        instance = db.instance_create(self.context, self.instance_values)\n\n        def fake_vdi_resize(*args, **kwargs):\n            raise Exception(\"This shouldn't be called\")\n\n        self.stubs.Set(stubs.FakeSessionForVMTests,\n                       \"VDI_resize_online\", fake_vdi_resize)\n        conn = xenapi_conn.XenAPIDriver(False)\n        network_info = fake_network.fake_get_instance_nw_info(self.stubs,\n                                                              spectacular=True)\n        image_meta = {'id': instance.image_ref, 'disk_format': 'vhd'}\n        conn.finish_migration(self.context, self.migration, instance,\n                              dict(base_copy='hurr', cow='durr'),\n                              network_info, image_meta, resize_instance=True)\n\n    def test_finish_migrate_no_resize_vdi(self):\n        instance = db.instance_create(self.context, self.instance_values)\n\n        def fake_vdi_resize(*args, **kwargs):\n            raise Exception(\"This shouldn't be called\")\n\n        self.stubs.Set(stubs.FakeSessionForVMTests,\n                       \"VDI_resize_online\", fake_vdi_resize)\n        conn = xenapi_conn.XenAPIDriver(False)\n        network_info = fake_network.fake_get_instance_nw_info(self.stubs,\n                                                              spectacular=True)\n        # Resize instance would be determined by the compute call\n        image_meta = {'id': instance.image_ref, 'disk_format': 'vhd'}\n        conn.finish_migration(self.context, self.migration, instance,\n                              dict(base_copy='hurr', cow='durr'),\n                              network_info, image_meta, resize_instance=False)\n\n\nclass XenAPIImageTypeTestCase(test.TestCase):\n    \"\"\"Test ImageType class.\"\"\"\n\n    def test_to_string(self):\n        \"\"\"Can convert from type id to type string.\"\"\"\n        self.assertEquals(\n            vm_utils.ImageType.to_string(vm_utils.ImageType.KERNEL),\n            vm_utils.ImageType.KERNEL_STR)\n\n    def test_from_string(self):\n        \"\"\"Can convert from string to type id.\"\"\"\n        self.assertEquals(\n            vm_utils.ImageType.from_string(vm_utils.ImageType.KERNEL_STR),\n            vm_utils.ImageType.KERNEL)\n\n\nclass XenAPIDetermineDiskImageTestCase(test.TestCase):\n    \"\"\"Unit tests for code that detects the ImageType.\"\"\"\n    def assert_disk_type(self, image_meta, expected_disk_type):\n        actual = vm_utils.determine_disk_image_type(image_meta)\n        self.assertEqual(expected_disk_type, actual)\n\n    def test_machine(self):\n        image_meta = {'id': 'a', 'disk_format': 'ami'}\n        self.assert_disk_type(image_meta, vm_utils.ImageType.DISK)\n\n    def test_raw(self):\n        image_meta = {'id': 'a', 'disk_format': 'raw'}\n        self.assert_disk_type(image_meta, vm_utils.ImageType.DISK_RAW)\n\n    def test_vhd(self):\n        image_meta = {'id': 'a', 'disk_format': 'vhd'}\n        self.assert_disk_type(image_meta, vm_utils.ImageType.DISK_VHD)\n\n\nclass CompareVersionTestCase(test.TestCase):\n    def test_less_than(self):\n        \"\"\"Test that cmp_version compares a as less than b\"\"\"\n        self.assertTrue(vmops.cmp_version('1.2.3.4', '1.2.3.5') < 0)\n\n    def test_greater_than(self):\n        \"\"\"Test that cmp_version compares a as greater than b\"\"\"\n        self.assertTrue(vmops.cmp_version('1.2.3.5', '1.2.3.4') > 0)\n\n    def test_equal(self):\n        \"\"\"Test that cmp_version compares a as equal to b\"\"\"\n        self.assertTrue(vmops.cmp_version('1.2.3.4', '1.2.3.4') == 0)\n\n    def test_non_lexical(self):\n        \"\"\"Test that cmp_version compares non-lexically\"\"\"\n        self.assertTrue(vmops.cmp_version('1.2.3.10', '1.2.3.4') > 0)\n\n    def test_length(self):\n        \"\"\"Test that cmp_version compares by length as last resort\"\"\"\n        self.assertTrue(vmops.cmp_version('1.2.3', '1.2.3.4') < 0)\n\n\nclass XenAPIHostTestCase(stubs.XenAPITestBase):\n    \"\"\"Tests HostState, which holds metrics from XenServer that get\n    reported back to the Schedulers.\"\"\"\n\n    def setUp(self):\n        super(XenAPIHostTestCase, self).setUp()\n        self.flags(xenapi_connection_url='test_url',\n                   xenapi_connection_password='test_pass')\n        stubs.stubout_session(self.stubs, stubs.FakeSessionForVMTests)\n        xenapi_fake.create_local_srs()\n        self.conn = xenapi_conn.XenAPIDriver(False)\n\n    def test_host_state(self):\n        stats = self.conn.get_host_stats()\n        self.assertEquals(stats['disk_total'], 10000)\n        self.assertEquals(stats['disk_used'], 20000)\n        self.assertEquals(stats['host_memory_total'], 10)\n        self.assertEquals(stats['host_memory_overhead'], 20)\n        self.assertEquals(stats['host_memory_free'], 30)\n        self.assertEquals(stats['host_memory_free_computed'], 40)\n\n    def _test_host_action(self, method, action, expected=None):\n        result = method('host', action)\n        if not expected:\n            expected = action\n        self.assertEqual(result, expected)\n\n    def test_host_reboot(self):\n        self._test_host_action(self.conn.host_power_action, 'reboot')\n\n    def test_host_shutdown(self):\n        self._test_host_action(self.conn.host_power_action, 'shutdown')\n\n    def test_host_startup(self):\n        self.assertRaises(NotImplementedError,\n                          self.conn.host_power_action, 'host', 'startup')\n\n    def test_host_maintenance_on(self):\n        self._test_host_action(self.conn.host_maintenance_mode,\n                               True, 'on_maintenance')\n\n    def test_host_maintenance_off(self):\n        self._test_host_action(self.conn.host_maintenance_mode,\n                               False, 'off_maintenance')\n\n    def test_set_enable_host_enable(self):\n        self._test_host_action(self.conn.set_host_enabled, True, 'enabled')\n\n    def test_set_enable_host_disable(self):\n        self._test_host_action(self.conn.set_host_enabled, False, 'disabled')\n\n    def test_get_host_uptime(self):\n        result = self.conn.get_host_uptime('host')\n        self.assertEqual(result, 'fake uptime')\n\n\nclass XenAPIAutoDiskConfigTestCase(stubs.XenAPITestBase):\n    def setUp(self):\n        super(XenAPIAutoDiskConfigTestCase, self).setUp()\n        self.flags(xenapi_connection_url='test_url',\n                   xenapi_connection_password='test_pass',\n                   firewall_driver='nova.virt.xenapi.firewall.'\n                                   'Dom0IptablesFirewallDriver')\n        stubs.stubout_session(self.stubs, stubs.FakeSessionForVMTests)\n        self.conn = xenapi_conn.XenAPIDriver(False)\n\n        self.user_id = 'fake'\n        self.project_id = 'fake'\n\n        self.instance_values = {'id': 1,\n                  'project_id': self.project_id,\n                  'user_id': self.user_id,\n                  'image_ref': 1,\n                  'kernel_id': 2,\n                  'ramdisk_id': 3,\n                  'root_gb': 20,\n                  'instance_type_id': '3',  # m1.large\n                  'os_type': 'linux',\n                  'architecture': 'x86-64'}\n\n        self.context = context.RequestContext(self.user_id, self.project_id)\n\n        def fake_create_vbd(session, vm_ref, vdi_ref, userdevice,\n                            vbd_type='disk', read_only=False, bootable=True):\n            pass\n\n        self.stubs.Set(vm_utils, 'create_vbd', fake_create_vbd)\n\n    def assertIsPartitionCalled(self, called):\n        marker = {\"partition_called\": False}\n\n        def fake_resize_part_and_fs(dev, start, old, new):\n            marker[\"partition_called\"] = True\n        self.stubs.Set(vm_utils, \"_resize_part_and_fs\",\n                       fake_resize_part_and_fs)\n\n        ctx = context.RequestContext(self.user_id, self.project_id)\n        session = xenapi_conn.XenAPISession('test_url', 'root', 'test_pass')\n\n        disk_image_type = vm_utils.ImageType.DISK_VHD\n        instance = db.instance_create(self.context, self.instance_values)\n        vm_ref = xenapi_fake.create_vm(instance['name'], 'Halted')\n        vdi_ref = xenapi_fake.create_vdi(instance['name'], 'fake')\n\n        vdi_uuid = session.call_xenapi('VDI.get_record', vdi_ref)['uuid']\n        vdis = {'root': {'uuid': vdi_uuid, 'ref': vdi_ref}}\n\n        self.conn._vmops._attach_disks(instance, vm_ref, instance['name'],\n                                       disk_image_type, vdis)\n\n        self.assertEqual(marker[\"partition_called\"], called)\n\n    def test_instance_not_auto_disk_config(self):\n        \"\"\"Should not partition unless instance is marked as\n        auto_disk_config.\n        \"\"\"\n        self.instance_values['auto_disk_config'] = False\n        self.assertIsPartitionCalled(False)\n\n    @stub_vm_utils_with_vdi_attached_here\n    def test_instance_auto_disk_config_doesnt_pass_fail_safes(self):\n        \"\"\"Should not partition unless fail safes pass\"\"\"\n        self.instance_values['auto_disk_config'] = True\n\n        def fake_get_partitions(dev):\n            return [(1, 0, 100, 'ext4'), (2, 100, 200, 'ext4')]\n        self.stubs.Set(vm_utils, \"_get_partitions\",\n                       fake_get_partitions)\n\n        self.assertIsPartitionCalled(False)\n\n    @stub_vm_utils_with_vdi_attached_here\n    def test_instance_auto_disk_config_passes_fail_safes(self):\n        \"\"\"Should partition if instance is marked as auto_disk_config=True and\n        virt-layer specific fail-safe checks pass.\n        \"\"\"\n        self.instance_values['auto_disk_config'] = True\n\n        def fake_get_partitions(dev):\n            return [(1, 0, 100, 'ext4')]\n        self.stubs.Set(vm_utils, \"_get_partitions\",\n                       fake_get_partitions)\n\n        self.assertIsPartitionCalled(True)\n\n\nclass XenAPIGenerateLocal(stubs.XenAPITestBase):\n    \"\"\"Test generating of local disks, like swap and ephemeral\"\"\"\n    def setUp(self):\n        super(XenAPIGenerateLocal, self).setUp()\n        self.flags(xenapi_connection_url='test_url',\n                   xenapi_connection_password='test_pass',\n                   xenapi_generate_swap=True,\n                   firewall_driver='nova.virt.xenapi.firewall.'\n                                   'Dom0IptablesFirewallDriver')\n        stubs.stubout_session(self.stubs, stubs.FakeSessionForVMTests)\n        db_fakes.stub_out_db_instance_api(self.stubs)\n        self.conn = xenapi_conn.XenAPIDriver(False)\n\n        self.user_id = 'fake'\n        self.project_id = 'fake'\n\n        self.instance_values = {'id': 1,\n                  'project_id': self.project_id,\n                  'user_id': self.user_id,\n                  'image_ref': 1,\n                  'kernel_id': 2,\n                  'ramdisk_id': 3,\n                  'root_gb': 20,\n                  'instance_type_id': '3',  # m1.large\n                  'os_type': 'linux',\n                  'architecture': 'x86-64'}\n\n        self.context = context.RequestContext(self.user_id, self.project_id)\n\n        def fake_create_vbd(session, vm_ref, vdi_ref, userdevice,\n                            vbd_type='disk', read_only=False, bootable=True):\n            pass\n\n        self.stubs.Set(vm_utils, 'create_vbd', fake_create_vbd)\n\n    def assertCalled(self, instance):\n        ctx = context.RequestContext(self.user_id, self.project_id)\n        session = xenapi_conn.XenAPISession('test_url', 'root', 'test_pass')\n\n        disk_image_type = vm_utils.ImageType.DISK_VHD\n        vm_ref = xenapi_fake.create_vm(instance['name'], 'Halted')\n        vdi_ref = xenapi_fake.create_vdi(instance['name'], 'fake')\n\n        vdi_uuid = session.call_xenapi('VDI.get_record', vdi_ref)['uuid']\n        vdis = {'root': {'uuid': vdi_uuid, 'ref': vdi_ref}}\n\n        self.called = False\n        self.conn._vmops._attach_disks(instance, vm_ref, instance['name'],\n                                       disk_image_type, vdis)\n        self.assertTrue(self.called)\n\n    def test_generate_swap(self):\n        \"\"\"Test swap disk generation.\"\"\"\n        instance = db.instance_create(self.context, self.instance_values)\n        instance = db.instance_update(self.context, instance['uuid'],\n                                      {'instance_type_id': 5})\n\n        def fake_generate_swap(*args, **kwargs):\n            self.called = True\n        self.stubs.Set(vm_utils, 'generate_swap', fake_generate_swap)\n\n        self.assertCalled(instance)\n\n    def test_generate_ephemeral(self):\n        \"\"\"Test ephemeral disk generation.\"\"\"\n        instance = db.instance_create(self.context, self.instance_values)\n        instance = db.instance_update(self.context, instance['uuid'],\n                                      {'instance_type_id': 4})\n\n        def fake_generate_ephemeral(*args):\n            self.called = True\n        self.stubs.Set(vm_utils, 'generate_ephemeral', fake_generate_ephemeral)\n\n        self.assertCalled(instance)\n\n\nclass XenAPIBWUsageTestCase(stubs.XenAPITestBase):\n    def setUp(self):\n        super(XenAPIBWUsageTestCase, self).setUp()\n        self.stubs.Set(vm_utils, 'compile_metrics',\n                       XenAPIBWUsageTestCase._fake_compile_metrics)\n        self.flags(xenapi_connection_url='test_url',\n                   xenapi_connection_password='test_pass',\n                   firewall_driver='nova.virt.xenapi.firewall.'\n                                   'Dom0IptablesFirewallDriver')\n        stubs.stubout_session(self.stubs, stubs.FakeSessionForVMTests)\n        self.conn = xenapi_conn.XenAPIDriver(False)\n\n    @classmethod\n    def _fake_compile_metrics(cls, start_time, stop_time=None):\n        raise exception.CouldNotFetchMetrics()\n\n    def test_get_all_bw_usage_in_failure_case(self):\n        \"\"\"Test that get_all_bw_usage returns an empty list when metrics\n        compilation failed.  c.f. bug #910045.\n        \"\"\"\n        class testinstance(object):\n            def __init__(self):\n                self.name = \"instance-0001\"\n                self.uuid = \"1-2-3-4-5\"\n\n        result = self.conn.get_all_bw_usage([testinstance()],\n                                            timeutils.utcnow())\n        self.assertEqual(result, [])\n\n\n# TODO(salvatore-orlando): this class and\n# nova.tests.test_libvirt.IPTablesFirewallDriverTestCase share a lot of code.\n# Consider abstracting common code in a base class for firewall driver testing.\nclass XenAPIDom0IptablesFirewallTestCase(stubs.XenAPITestBase):\n\n    _in_nat_rules = [\n      '# Generated by iptables-save v1.4.10 on Sat Feb 19 00:03:19 2011',\n      '*nat',\n      ':PREROUTING ACCEPT [1170:189210]',\n      ':INPUT ACCEPT [844:71028]',\n      ':OUTPUT ACCEPT [5149:405186]',\n      ':POSTROUTING ACCEPT [5063:386098]',\n    ]\n\n    _in_filter_rules = [\n      '# Generated by iptables-save v1.4.4 on Mon Dec  6 11:54:13 2010',\n      '*filter',\n      ':INPUT ACCEPT [969615:281627771]',\n      ':FORWARD ACCEPT [0:0]',\n      ':OUTPUT ACCEPT [915599:63811649]',\n      ':nova-block-ipv4 - [0:0]',\n      '-A INPUT -i virbr0 -p tcp -m tcp --dport 67 -j ACCEPT ',\n      '-A FORWARD -d 192.168.122.0/24 -o virbr0 -m state --state RELATED'\n      ',ESTABLISHED -j ACCEPT ',\n      '-A FORWARD -s 192.168.122.0/24 -i virbr0 -j ACCEPT ',\n      '-A FORWARD -i virbr0 -o virbr0 -j ACCEPT ',\n      '-A FORWARD -o virbr0 -j REJECT --reject-with icmp-port-unreachable ',\n      '-A FORWARD -i virbr0 -j REJECT --reject-with icmp-port-unreachable ',\n      'COMMIT',\n      '# Completed on Mon Dec  6 11:54:13 2010',\n    ]\n\n    _in6_filter_rules = [\n      '# Generated by ip6tables-save v1.4.4 on Tue Jan 18 23:47:56 2011',\n      '*filter',\n      ':INPUT ACCEPT [349155:75810423]',\n      ':FORWARD ACCEPT [0:0]',\n      ':OUTPUT ACCEPT [349256:75777230]',\n      'COMMIT',\n      '# Completed on Tue Jan 18 23:47:56 2011',\n    ]\n\n    def setUp(self):\n        super(XenAPIDom0IptablesFirewallTestCase, self).setUp()\n        self.flags(xenapi_connection_url='test_url',\n                   xenapi_connection_password='test_pass',\n                   instance_name_template='%d',\n                   firewall_driver='nova.virt.xenapi.firewall.'\n                                   'Dom0IptablesFirewallDriver')\n        xenapi_fake.create_local_srs()\n        xenapi_fake.create_local_pifs()\n        self.user_id = 'mappin'\n        self.project_id = 'fake'\n        stubs.stubout_session(self.stubs, stubs.FakeSessionForFirewallTests,\n                              test_case=self)\n        self.context = context.RequestContext(self.user_id, self.project_id)\n        self.network = importutils.import_object(FLAGS.network_manager)\n        self.conn = xenapi_conn.XenAPIDriver(False)\n        self.fw = self.conn._vmops.firewall_driver\n\n    def _create_instance_ref(self):\n        return db.instance_create(self.context,\n                                  {'user_id': self.user_id,\n                                   'project_id': self.project_id,\n                                   'instance_type_id': 1})\n\n    def _create_test_security_group(self):\n        admin_ctxt = context.get_admin_context()\n        secgroup = db.security_group_create(admin_ctxt,\n                                {'user_id': self.user_id,\n                                 'project_id': self.project_id,\n                                 'name': 'testgroup',\n                                 'description': 'test group'})\n        db.security_group_rule_create(admin_ctxt,\n                                      {'parent_group_id': secgroup['id'],\n                                       'protocol': 'icmp',\n                                       'from_port': -1,\n                                       'to_port': -1,\n                                       'cidr': '192.168.11.0/24'})\n\n        db.security_group_rule_create(admin_ctxt,\n                                      {'parent_group_id': secgroup['id'],\n                                       'protocol': 'icmp',\n                                       'from_port': 8,\n                                       'to_port': -1,\n                                       'cidr': '192.168.11.0/24'})\n\n        db.security_group_rule_create(admin_ctxt,\n                                      {'parent_group_id': secgroup['id'],\n                                       'protocol': 'tcp',\n                                       'from_port': 80,\n                                       'to_port': 81,\n                                       'cidr': '192.168.10.0/24'})\n        return secgroup\n\n    def _validate_security_group(self):\n        in_rules = filter(lambda l: not l.startswith('#'),\n                          self._in_filter_rules)\n        for rule in in_rules:\n            if not 'nova' in rule:\n                self.assertTrue(rule in self._out_rules,\n                                'Rule went missing: %s' % rule)\n\n        instance_chain = None\n        for rule in self._out_rules:\n            # This is pretty crude, but it'll do for now\n            # last two octets change\n            if re.search('-d 192.168.[0-9]{1,3}.[0-9]{1,3} -j', rule):\n                instance_chain = rule.split(' ')[-1]\n                break\n        self.assertTrue(instance_chain, \"The instance chain wasn't added\")\n        security_group_chain = None\n        for rule in self._out_rules:\n            # This is pretty crude, but it'll do for now\n            if '-A %s -j' % instance_chain in rule:\n                security_group_chain = rule.split(' ')[-1]\n                break\n        self.assertTrue(security_group_chain,\n                        \"The security group chain wasn't added\")\n\n        regex = re.compile('-A .* -j ACCEPT -p icmp -s 192.168.11.0/24')\n        self.assertTrue(len(filter(regex.match, self._out_rules)) > 0,\n                        \"ICMP acceptance rule wasn't added\")\n\n        regex = re.compile('-A .* -j ACCEPT -p icmp -m icmp --icmp-type 8'\n                           ' -s 192.168.11.0/24')\n        self.assertTrue(len(filter(regex.match, self._out_rules)) > 0,\n                        \"ICMP Echo Request acceptance rule wasn't added\")\n\n        regex = re.compile('-A .* -j ACCEPT -p tcp --dport 80:81'\n                           ' -s 192.168.10.0/24')\n        self.assertTrue(len(filter(regex.match, self._out_rules)) > 0,\n                        \"TCP port 80/81 acceptance rule wasn't added\")\n\n    def test_static_filters(self):\n        instance_ref = self._create_instance_ref()\n        src_instance_ref = self._create_instance_ref()\n        admin_ctxt = context.get_admin_context()\n        secgroup = self._create_test_security_group()\n\n        src_secgroup = db.security_group_create(admin_ctxt,\n                                                {'user_id': self.user_id,\n                                                 'project_id': self.project_id,\n                                                 'name': 'testsourcegroup',\n                                                 'description': 'src group'})\n        db.security_group_rule_create(admin_ctxt,\n                                      {'parent_group_id': secgroup['id'],\n                                       'protocol': 'tcp',\n                                       'from_port': 80,\n                                       'to_port': 81,\n                                       'group_id': src_secgroup['id']})\n\n        db.instance_add_security_group(admin_ctxt, instance_ref['uuid'],\n                                       secgroup['id'])\n        db.instance_add_security_group(admin_ctxt, src_instance_ref['uuid'],\n                                       src_secgroup['id'])\n        instance_ref = db.instance_get(admin_ctxt, instance_ref['id'])\n        src_instance_ref = db.instance_get(admin_ctxt, src_instance_ref['id'])\n\n        network_model = fake_network.fake_get_instance_nw_info(self.stubs,\n                                                      1, spectacular=True)\n\n        fake_network.stub_out_nw_api_get_instance_nw_info(self.stubs,\n                                      lambda *a, **kw: network_model)\n\n        network_info = network_model.legacy()\n        self.fw.prepare_instance_filter(instance_ref, network_info)\n        self.fw.apply_instance_filter(instance_ref, network_info)\n\n        self._validate_security_group()\n        # Extra test for TCP acceptance rules\n        for ip in network_model.fixed_ips():\n            if ip['version'] != 4:\n                continue\n            regex = re.compile('-A .* -j ACCEPT -p tcp'\n                               ' --dport 80:81 -s %s' % ip['address'])\n            self.assertTrue(len(filter(regex.match, self._out_rules)) > 0,\n                            \"TCP port 80/81 acceptance rule wasn't added\")\n\n        db.instance_destroy(admin_ctxt, instance_ref['uuid'])\n\n    def test_filters_for_instance_with_ip_v6(self):\n        self.flags(use_ipv6=True)\n        network_info = fake_network.fake_get_instance_nw_info(self.stubs, 1)\n        rulesv4, rulesv6 = self.fw._filters_for_instance(\"fake\", network_info)\n        self.assertEquals(len(rulesv4), 2)\n        self.assertEquals(len(rulesv6), 1)\n\n    def test_filters_for_instance_without_ip_v6(self):\n        self.flags(use_ipv6=False)\n        network_info = fake_network.fake_get_instance_nw_info(self.stubs, 1)\n        rulesv4, rulesv6 = self.fw._filters_for_instance(\"fake\", network_info)\n        self.assertEquals(len(rulesv4), 2)\n        self.assertEquals(len(rulesv6), 0)\n\n    def test_multinic_iptables(self):\n        ipv4_rules_per_addr = 1\n        ipv4_addr_per_network = 2\n        ipv6_rules_per_addr = 1\n        ipv6_addr_per_network = 1\n        networks_count = 5\n        instance_ref = self._create_instance_ref()\n        _get_instance_nw_info = fake_network.fake_get_instance_nw_info\n        network_info = _get_instance_nw_info(self.stubs,\n                                             networks_count,\n                                             ipv4_addr_per_network)\n        ipv4_len = len(self.fw.iptables.ipv4['filter'].rules)\n        ipv6_len = len(self.fw.iptables.ipv6['filter'].rules)\n        inst_ipv4, inst_ipv6 = self.fw.instance_rules(instance_ref,\n                                                      network_info)\n        self.fw.prepare_instance_filter(instance_ref, network_info)\n        ipv4 = self.fw.iptables.ipv4['filter'].rules\n        ipv6 = self.fw.iptables.ipv6['filter'].rules\n        ipv4_network_rules = len(ipv4) - len(inst_ipv4) - ipv4_len\n        ipv6_network_rules = len(ipv6) - len(inst_ipv6) - ipv6_len\n        self.assertEquals(ipv4_network_rules,\n                  ipv4_rules_per_addr * ipv4_addr_per_network * networks_count)\n        self.assertEquals(ipv6_network_rules,\n                  ipv6_rules_per_addr * ipv6_addr_per_network * networks_count)\n\n    def test_do_refresh_security_group_rules(self):\n        admin_ctxt = context.get_admin_context()\n        instance_ref = self._create_instance_ref()\n        network_info = fake_network.fake_get_instance_nw_info(self.stubs, 1, 1)\n        secgroup = self._create_test_security_group()\n        db.instance_add_security_group(admin_ctxt, instance_ref['uuid'],\n                                       secgroup['id'])\n        self.fw.prepare_instance_filter(instance_ref, network_info)\n        self.fw.instances[instance_ref['id']] = instance_ref\n        self._validate_security_group()\n        # add a rule to the security group\n        db.security_group_rule_create(admin_ctxt,\n                                      {'parent_group_id': secgroup['id'],\n                                       'protocol': 'udp',\n                                       'from_port': 200,\n                                       'to_port': 299,\n                                       'cidr': '192.168.99.0/24'})\n        #validate the extra rule\n        self.fw.refresh_security_group_rules(secgroup)\n        regex = re.compile('-A .* -j ACCEPT -p udp --dport 200:299'\n                           ' -s 192.168.99.0/24')\n        self.assertTrue(len(filter(regex.match, self._out_rules)) > 0,\n                        \"Rules were not updated properly.\"\n                        \"The rule for UDP acceptance is missing\")\n\n    def test_provider_firewall_rules(self):\n        # setup basic instance data\n        instance_ref = self._create_instance_ref()\n        # FRAGILE: as in libvirt tests\n        # peeks at how the firewall names chains\n        chain_name = 'inst-%s' % instance_ref['id']\n\n        network_info = fake_network.fake_get_instance_nw_info(self.stubs, 1, 1)\n        self.fw.prepare_instance_filter(instance_ref, network_info)\n        self.assertTrue('provider' in self.fw.iptables.ipv4['filter'].chains)\n        rules = [rule for rule in self.fw.iptables.ipv4['filter'].rules\n                      if rule.chain == 'provider']\n        self.assertEqual(0, len(rules))\n\n        admin_ctxt = context.get_admin_context()\n        # add a rule and send the update message, check for 1 rule\n        provider_fw0 = db.provider_fw_rule_create(admin_ctxt,\n                                                  {'protocol': 'tcp',\n                                                   'cidr': '10.99.99.99/32',\n                                                   'from_port': 1,\n                                                   'to_port': 65535})\n        self.fw.refresh_provider_fw_rules()\n        rules = [rule for rule in self.fw.iptables.ipv4['filter'].rules\n                      if rule.chain == 'provider']\n        self.assertEqual(1, len(rules))\n\n        # Add another, refresh, and make sure number of rules goes to two\n        provider_fw1 = db.provider_fw_rule_create(admin_ctxt,\n                                                  {'protocol': 'udp',\n                                                   'cidr': '10.99.99.99/32',\n                                                   'from_port': 1,\n                                                   'to_port': 65535})\n        self.fw.refresh_provider_fw_rules()\n        rules = [rule for rule in self.fw.iptables.ipv4['filter'].rules\n                      if rule.chain == 'provider']\n        self.assertEqual(2, len(rules))\n\n        # create the instance filter and make sure it has a jump rule\n        self.fw.prepare_instance_filter(instance_ref, network_info)\n        self.fw.apply_instance_filter(instance_ref, network_info)\n        inst_rules = [rule for rule in self.fw.iptables.ipv4['filter'].rules\n                           if rule.chain == chain_name]\n        jump_rules = [rule for rule in inst_rules if '-j' in rule.rule]\n        provjump_rules = []\n        # IptablesTable doesn't make rules unique internally\n        for rule in jump_rules:\n            if 'provider' in rule.rule and rule not in provjump_rules:\n                provjump_rules.append(rule)\n        self.assertEqual(1, len(provjump_rules))\n\n        # remove a rule from the db, cast to compute to refresh rule\n        db.provider_fw_rule_destroy(admin_ctxt, provider_fw1['id'])\n        self.fw.refresh_provider_fw_rules()\n        rules = [rule for rule in self.fw.iptables.ipv4['filter'].rules\n                      if rule.chain == 'provider']\n        self.assertEqual(1, len(rules))\n\n\nclass XenAPISRSelectionTestCase(stubs.XenAPITestBase):\n    \"\"\"Unit tests for testing we find the right SR.\"\"\"\n    def test_safe_find_sr_raise_exception(self):\n        \"\"\"Ensure StorageRepositoryNotFound is raise when wrong filter.\"\"\"\n        self.flags(sr_matching_filter='yadayadayada')\n        stubs.stubout_session(self.stubs, stubs.FakeSessionForVMTests)\n        session = xenapi_conn.XenAPISession('test_url', 'root', 'test_pass')\n        self.assertRaises(exception.StorageRepositoryNotFound,\n                          vm_utils.safe_find_sr, session)\n\n    def test_safe_find_sr_local_storage(self):\n        \"\"\"Ensure the default local-storage is found.\"\"\"\n        self.flags(sr_matching_filter='other-config:i18n-key=local-storage')\n        stubs.stubout_session(self.stubs, stubs.FakeSessionForVMTests)\n        session = xenapi_conn.XenAPISession('test_url', 'root', 'test_pass')\n        host_ref = xenapi_fake.get_all('host')[0]\n        local_sr = xenapi_fake.create_sr(\n                              name_label='Fake Storage',\n                              type='lvm',\n                              other_config={'i18n-original-value-name_label':\n                                            'Local storage',\n                                            'i18n-key': 'local-storage'},\n                              host_ref=host_ref)\n        expected = vm_utils.safe_find_sr(session)\n        self.assertEqual(local_sr, expected)\n\n    def test_safe_find_sr_by_other_criteria(self):\n        \"\"\"Ensure the SR is found when using a different filter.\"\"\"\n        self.flags(sr_matching_filter='other-config:my_fake_sr=true')\n        stubs.stubout_session(self.stubs, stubs.FakeSessionForVMTests)\n        session = xenapi_conn.XenAPISession('test_url', 'root', 'test_pass')\n        host_ref = xenapi_fake.get_all('host')[0]\n        local_sr = xenapi_fake.create_sr(name_label='Fake Storage',\n                                         type='lvm',\n                                         other_config={'my_fake_sr': 'true'},\n                                         host_ref=host_ref)\n        expected = vm_utils.safe_find_sr(session)\n        self.assertEqual(local_sr, expected)\n\n    def test_safe_find_sr_default(self):\n        \"\"\"Ensure the default SR is found regardless of other-config.\"\"\"\n        self.flags(sr_matching_filter='default-sr:true')\n        stubs.stubout_session(self.stubs, stubs.FakeSessionForVMTests)\n        session = xenapi_conn.XenAPISession('test_url', 'root', 'test_pass')\n        pool_ref = xenapi_fake.create_pool('')\n        expected = vm_utils.safe_find_sr(session)\n        self.assertEqual(session.call_xenapi('pool.get_default_SR', pool_ref),\n                         expected)\n\n\ndef _create_service_entries(context, values={'avail_zone1': ['fake_host1',\n                                                         'fake_host2'],\n                                         'avail_zone2': ['fake_host3'], }):\n    for avail_zone, hosts in values.iteritems():\n        for host in hosts:\n            db.service_create(context,\n                              {'host': host,\n                               'binary': 'nova-compute',\n                               'topic': 'compute',\n                               'report_count': 0,\n                               'availability_zone': avail_zone})\n    return values\n\n\nclass XenAPIAggregateTestCase(stubs.XenAPITestBase):\n    \"\"\"Unit tests for aggregate operations.\"\"\"\n    def setUp(self):\n        super(XenAPIAggregateTestCase, self).setUp()\n        self.flags(xenapi_connection_url='http://test_url',\n                   xenapi_connection_username='test_user',\n                   xenapi_connection_password='test_pass',\n                   instance_name_template='%d',\n                   firewall_driver='nova.virt.xenapi.firewall.'\n                                   'Dom0IptablesFirewallDriver',\n                   host='host',\n                   connection_type='xenapi',\n                   compute_driver='nova.virt.xenapi.driver.XenAPIDriver')\n        host_ref = xenapi_fake.get_all('host')[0]\n        stubs.stubout_session(self.stubs, stubs.FakeSessionForVMTests)\n        self.context = context.get_admin_context()\n        self.conn = xenapi_conn.XenAPIDriver(False)\n        self.compute = importutils.import_object(FLAGS.compute_manager)\n        self.api = compute_api.AggregateAPI()\n        values = {'name': 'test_aggr',\n                  'availability_zone': 'test_zone',\n                  'metadata': {pool_states.POOL_FLAG: 'XenAPI'}}\n        self.aggr = db.aggregate_create(self.context, values)\n        self.fake_metadata = {pool_states.POOL_FLAG: 'XenAPI',\n                              'master_compute': 'host',\n                              pool_states.KEY: pool_states.ACTIVE,\n                              'host': xenapi_fake.get_record('host',\n                                                             host_ref)['uuid']}\n\n    def test_add_to_aggregate_called(self):\n        def fake_add_to_aggregate(context, aggregate, host):\n            fake_add_to_aggregate.called = True\n        self.stubs.Set(self.conn._pool,\n                       \"add_to_aggregate\",\n                       fake_add_to_aggregate)\n\n        self.conn.add_to_aggregate(None, None, None)\n        self.assertTrue(fake_add_to_aggregate.called)\n\n    def test_add_to_aggregate_for_first_host_sets_metadata(self):\n        def fake_init_pool(id, name):\n            fake_init_pool.called = True\n        self.stubs.Set(self.conn._pool, \"_init_pool\", fake_init_pool)\n\n        aggregate = self._aggregate_setup()\n        self.conn._pool.add_to_aggregate(self.context, aggregate, \"host\")\n        result = db.aggregate_get(self.context, aggregate.id)\n        self.assertTrue(fake_init_pool.called)\n        self.assertDictMatch(self.fake_metadata, result.metadetails)\n\n    def test_join_slave(self):\n        \"\"\"Ensure join_slave gets called when the request gets to master.\"\"\"\n        def fake_join_slave(id, compute_uuid, host, url, user, password):\n            fake_join_slave.called = True\n        self.stubs.Set(self.conn._pool, \"_join_slave\", fake_join_slave)\n\n        aggregate = self._aggregate_setup(hosts=['host', 'host2'],\n                                          metadata=self.fake_metadata)\n        self.conn._pool.add_to_aggregate(self.context, aggregate, \"host2\",\n                                         compute_uuid='fake_uuid',\n                                         url='fake_url',\n                                         user='fake_user',\n                                         passwd='fake_pass',\n                                         xenhost_uuid='fake_uuid')\n        self.assertTrue(fake_join_slave.called)\n\n    def test_add_to_aggregate_first_host(self):\n        def fake_pool_set_name_label(self, session, pool_ref, name):\n            fake_pool_set_name_label.called = True\n        self.stubs.Set(xenapi_fake.SessionBase, \"pool_set_name_label\",\n                       fake_pool_set_name_label)\n        self.conn._session.call_xenapi(\"pool.create\", {\"name\": \"asdf\"})\n\n        values = {\"name\": 'fake_aggregate',\n                  \"availability_zone\": 'fake_zone'}\n        result = db.aggregate_create(self.context, values)\n        metadata = {pool_states.POOL_FLAG: \"XenAPI\",\n                    pool_states.KEY: pool_states.CREATED}\n        db.aggregate_metadata_add(self.context, result.id, metadata)\n\n        db.aggregate_host_add(self.context, result.id, \"host\")\n        aggregate = db.aggregate_get(self.context, result.id)\n        self.assertEqual([\"host\"], aggregate.hosts)\n        self.assertEqual(metadata, aggregate.metadetails)\n\n        self.conn._pool.add_to_aggregate(self.context, aggregate, \"host\")\n        self.assertTrue(fake_pool_set_name_label.called)\n\n    def test_remove_from_aggregate_called(self):\n        def fake_remove_from_aggregate(context, aggregate, host):\n            fake_remove_from_aggregate.called = True\n        self.stubs.Set(self.conn._pool,\n                       \"remove_from_aggregate\",\n                       fake_remove_from_aggregate)\n\n        self.conn.remove_from_aggregate(None, None, None)\n        self.assertTrue(fake_remove_from_aggregate.called)\n\n    def test_remove_from_empty_aggregate(self):\n        result = self._aggregate_setup()\n        self.assertRaises(exception.InvalidAggregateAction,\n                          self.conn._pool.remove_from_aggregate,\n                          self.context, result, \"test_host\")\n\n    def test_remove_slave(self):\n        \"\"\"Ensure eject slave gets called.\"\"\"\n        def fake_eject_slave(id, compute_uuid, host_uuid):\n            fake_eject_slave.called = True\n        self.stubs.Set(self.conn._pool, \"_eject_slave\", fake_eject_slave)\n\n        self.fake_metadata['host2'] = 'fake_host2_uuid'\n        aggregate = self._aggregate_setup(hosts=['host', 'host2'],\n                metadata=self.fake_metadata, aggr_state=pool_states.ACTIVE)\n        self.conn._pool.remove_from_aggregate(self.context, aggregate, \"host2\")\n        self.assertTrue(fake_eject_slave.called)\n\n    def test_remove_master_solo(self):\n        \"\"\"Ensure metadata are cleared after removal.\"\"\"\n        def fake_clear_pool(id):\n            fake_clear_pool.called = True\n        self.stubs.Set(self.conn._pool, \"_clear_pool\", fake_clear_pool)\n\n        aggregate = self._aggregate_setup(metadata=self.fake_metadata)\n        self.conn._pool.remove_from_aggregate(self.context, aggregate, \"host\")\n        result = db.aggregate_get(self.context, aggregate.id)\n        self.assertTrue(fake_clear_pool.called)\n        self.assertDictMatch({pool_states.POOL_FLAG: 'XenAPI',\n                pool_states.KEY: pool_states.ACTIVE}, result.metadetails)\n\n    def test_remote_master_non_empty_pool(self):\n        \"\"\"Ensure AggregateError is raised if removing the master.\"\"\"\n        aggregate = self._aggregate_setup(hosts=['host', 'host2'],\n                                          metadata=self.fake_metadata)\n\n        self.assertRaises(exception.InvalidAggregateAction,\n                          self.conn._pool.remove_from_aggregate,\n                          self.context, aggregate, \"host\")\n\n    def _aggregate_setup(self, aggr_name='fake_aggregate',\n                         aggr_zone='fake_zone',\n                         aggr_state=pool_states.CREATED,\n                         hosts=['host'], metadata=None):\n        values = {\"name\": aggr_name,\n                  \"availability_zone\": aggr_zone}\n        result = db.aggregate_create(self.context, values)\n        pool_flag = {pool_states.POOL_FLAG: \"XenAPI\",\n                    pool_states.KEY: aggr_state}\n        db.aggregate_metadata_add(self.context, result.id, pool_flag)\n\n        for host in hosts:\n            db.aggregate_host_add(self.context, result.id, host)\n        if metadata:\n            db.aggregate_metadata_add(self.context, result.id, metadata)\n        return db.aggregate_get(self.context, result.id)\n\n    def test_add_host_to_aggregate_invalid_changing_status(self):\n        \"\"\"Ensure InvalidAggregateAction is raised when adding host while\n        aggregate is not ready.\"\"\"\n        aggregate = self._aggregate_setup(aggr_state=pool_states.CHANGING)\n        self.assertRaises(exception.InvalidAggregateAction,\n                          self.conn.add_to_aggregate, self.context,\n                          aggregate, 'host')\n\n    def test_add_host_to_aggregate_invalid_dismissed_status(self):\n        \"\"\"Ensure InvalidAggregateAction is raised when aggregate is\n        deleted.\"\"\"\n        aggregate = self._aggregate_setup(aggr_state=pool_states.DISMISSED)\n        self.assertRaises(exception.InvalidAggregateAction,\n                          self.conn.add_to_aggregate, self.context,\n                          aggregate, 'fake_host')\n\n    def test_add_host_to_aggregate_invalid_error_status(self):\n        \"\"\"Ensure InvalidAggregateAction is raised when aggregate is\n        in error.\"\"\"\n        aggregate = self._aggregate_setup(aggr_state=pool_states.ERROR)\n        self.assertRaises(exception.InvalidAggregateAction,\n                          self.conn.add_to_aggregate, self.context,\n                          aggregate, 'fake_host')\n\n    def test_remove_host_from_aggregate_error(self):\n        \"\"\"Ensure we can remove a host from an aggregate even if in error.\"\"\"\n        values = _create_service_entries(self.context)\n        fake_zone = values.keys()[0]\n        aggr = self.api.create_aggregate(self.context,\n                                         'fake_aggregate', fake_zone)\n        # let's mock the fact that the aggregate is ready!\n        metadata = {pool_states.POOL_FLAG: \"XenAPI\",\n                    pool_states.KEY: pool_states.ACTIVE}\n        db.aggregate_metadata_add(self.context, aggr['id'], metadata)\n        for host in values[fake_zone]:\n            aggr = self.api.add_host_to_aggregate(self.context,\n                                                  aggr['id'], host)\n        # let's mock the fact that the aggregate is in error!\n        status = {'operational_state': pool_states.ERROR}\n        expected = self.api.remove_host_from_aggregate(self.context,\n                                                       aggr['id'],\n                                                       values[fake_zone][0])\n        self.assertEqual(len(aggr['hosts']) - 1, len(expected['hosts']))\n        self.assertEqual(expected['metadata'][pool_states.KEY],\n                         pool_states.ACTIVE)\n\n    def test_remove_host_from_aggregate_invalid_dismissed_status(self):\n        \"\"\"Ensure InvalidAggregateAction is raised when aggregate is\n        deleted.\"\"\"\n        aggregate = self._aggregate_setup(aggr_state=pool_states.DISMISSED)\n        self.assertRaises(exception.InvalidAggregateAction,\n                          self.conn.remove_from_aggregate, self.context,\n                          aggregate, 'fake_host')\n\n    def test_remove_host_from_aggregate_invalid_changing_status(self):\n        \"\"\"Ensure InvalidAggregateAction is raised when aggregate is\n        changing.\"\"\"\n        aggregate = self._aggregate_setup(aggr_state=pool_states.CHANGING)\n        self.assertRaises(exception.InvalidAggregateAction,\n                          self.conn.remove_from_aggregate, self.context,\n                          aggregate, 'fake_host')\n\n    def test_add_aggregate_host_raise_err(self):\n        \"\"\"Ensure the undo operation works correctly on add.\"\"\"\n        def fake_driver_add_to_aggregate(context, aggregate, host):\n            raise exception.AggregateError\n        self.stubs.Set(self.compute.driver, \"add_to_aggregate\",\n                       fake_driver_add_to_aggregate)\n        metadata = {pool_states.POOL_FLAG: \"XenAPI\",\n                    pool_states.KEY: pool_states.ACTIVE}\n        db.aggregate_metadata_add(self.context, self.aggr.id, metadata)\n        db.aggregate_host_add(self.context, self.aggr.id, 'fake_host')\n\n        self.assertRaises(exception.AggregateError,\n                          self.compute.add_aggregate_host,\n                          self.context, self.aggr.id, \"fake_host\")\n        excepted = db.aggregate_get(self.context, self.aggr.id)\n        self.assertEqual(excepted.metadetails[pool_states.KEY],\n                pool_states.ERROR)\n        self.assertEqual(excepted.hosts, [])\n\n\nclass VmUtilsTestCase(test.TestCase):\n    \"\"\"Unit tests for xenapi utils.\"\"\"\n\n    def test_upload_image(self):\n        \"\"\"Ensure image properties include instance system metadata\n           as well as few local settings.\"\"\"\n\n        def fake_instance_system_metadata_get(context, uuid):\n            return dict(image_a=1, image_b=2, image_c='c', d='d')\n\n        def fake_get_sr_path(session):\n            return \"foo\"\n\n        class FakeInstance(dict):\n            def __init__(self):\n                super(FakeInstance, self).__init__({\n                        'auto_disk_config': 'auto disk config',\n                        'os_type': 'os type'})\n\n            def __missing__(self, item):\n                return \"whatever\"\n\n        class FakeSession(object):\n            def call_plugin(session_self, service, command, kwargs):\n                self.kwargs = kwargs\n\n        def fake_dumps(thing):\n            return thing\n\n        self.stubs.Set(db, \"instance_system_metadata_get\",\n                                             fake_instance_system_metadata_get)\n        self.stubs.Set(vm_utils, \"get_sr_path\", fake_get_sr_path)\n        self.stubs.Set(pickle, \"dumps\", fake_dumps)\n\n        ctx = context.get_admin_context()\n\n        instance = FakeInstance()\n        session = FakeSession()\n        vm_utils.upload_image(ctx, session, instance, \"vmi uuids\", \"image id\")\n\n        actual = self.kwargs['params']['properties']\n        expected = dict(a=1, b=2, c='c', d='d',\n                        auto_disk_config='auto disk config',\n                        os_type='os type')\n        self.assertEquals(expected, actual)\n\n\nclass XenAPILiveMigrateTestCase(stubs.XenAPITestBase):\n    \"\"\"Unit tests for live_migration.\"\"\"\n    def setUp(self):\n        super(XenAPILiveMigrateTestCase, self).setUp()\n        self.flags(xenapi_connection_url='test_url',\n                   xenapi_connection_password='test_pass',\n                   firewall_driver='nova.virt.xenapi.firewall.'\n                                   'Dom0IptablesFirewallDriver',\n                   host='host')\n        db_fakes.stub_out_db_instance_api(self.stubs)\n        stubs.stubout_session(self.stubs, stubs.FakeSessionForVMTests)\n        self.context = context.get_admin_context()\n        self.conn = xenapi_conn.XenAPIDriver(False)\n\n    def test_live_migration_calls_vmops(self):\n        def fake_live_migrate(context, instance_ref, dest, post_method,\n                              recover_method, block_migration):\n            fake_live_migrate.called = True\n        self.stubs.Set(self.conn._vmops, \"live_migrate\", fake_live_migrate)\n\n        self.conn.live_migration(None, None, None, None, None)\n        self.assertTrue(fake_live_migrate.called)\n\n    def test_pre_live_migration(self):\n        # ensure method is present\n        self.conn.pre_live_migration(None, None, None, None)\n\n    def test_post_live_migration_at_destination(self):\n        # ensure method is present\n        self.conn.post_live_migration_at_destination(None, None, None, None)\n\n    def test_check_can_live_migrate_raises_on_block_migrate(self):\n        self.assertRaises(NotImplementedError,\n                          self.conn.check_can_live_migrate_destination,\n                          None, None, True, None)\n\n    def test_check_can_live_migrate_works(self):\n        class fake_aggregate:\n            def __init__(self):\n                self.metadetails = {\"host\": \"test_host_uuid\"}\n\n        def fake_aggregate_get_by_host(context, host):\n            self.assertEqual(FLAGS.host, host)\n            return fake_aggregate()\n\n        self.stubs.Set(db, \"aggregate_get_by_host\",\n                fake_aggregate_get_by_host)\n        self.conn.check_can_live_migrate_destination(self.context,\n                {'host': 'host'}, False, False)\n\n    def test_check_can_live_migrate_fails(self):\n        class fake_aggregate:\n            def __init__(self):\n                self.metadetails = {\"dest_other\": \"test_host_uuid\"}\n\n        def fake_aggregate_get_by_host(context, host):\n            self.assertEqual(FLAGS.host, host)\n            return fake_aggregate()\n\n        self.stubs.Set(db, \"aggregate_get_by_host\",\n                      fake_aggregate_get_by_host)\n        self.assertRaises(exception.MigrationError,\n                          self.conn.check_can_live_migrate_destination,\n                          self.context, {'host': 'host'}, None, None)\n\n    def test_live_migration(self):\n        def fake_get_vm_opaque_ref(instance):\n            return \"fake_vm\"\n        self.stubs.Set(self.conn._vmops, \"_get_vm_opaque_ref\",\n                       fake_get_vm_opaque_ref)\n\n        def fake_get_host_opaque_ref(context, destination_hostname):\n            return \"fake_host\"\n        self.stubs.Set(self.conn._vmops, \"_get_host_opaque_ref\",\n                       fake_get_host_opaque_ref)\n\n        def post_method(context, instance, destination_hostname,\n                        block_migration):\n            post_method.called = True\n\n        self.conn.live_migration(self.conn, None, None, post_method, None)\n\n        self.assertTrue(post_method.called, \"post_method.called\")\n\n    def test_live_migration_on_failure(self):\n        def fake_get_vm_opaque_ref(instance):\n            return \"fake_vm\"\n        self.stubs.Set(self.conn._vmops, \"_get_vm_opaque_ref\",\n                       fake_get_vm_opaque_ref)\n\n        def fake_get_host_opaque_ref(context, destination_hostname):\n            return \"fake_host\"\n        self.stubs.Set(self.conn._vmops, \"_get_host_opaque_ref\",\n                       fake_get_host_opaque_ref)\n\n        def fake_call_xenapi(*args):\n            raise NotImplementedError()\n        self.stubs.Set(self.conn._vmops._session, \"call_xenapi\",\n                       fake_call_xenapi)\n\n        def recover_method(context, instance, destination_hostname,\n                        block_migration):\n            recover_method.called = True\n\n        self.assertRaises(NotImplementedError, self.conn.live_migration,\n                          self.conn, None, None, None, recover_method)\n        self.assertTrue(recover_method.called, \"recover_method.called\")\n\n\nclass XenAPIInjectMetadataTestCase(stubs.XenAPITestBase):\n    def setUp(self):\n        super(XenAPIInjectMetadataTestCase, self).setUp()\n        self.flags(xenapi_connection_url='test_url',\n                   xenapi_connection_password='test_pass',\n                   firewall_driver='nova.virt.xenapi.firewall.'\n                                   'Dom0IptablesFirewallDriver')\n        stubs.stubout_session(self.stubs, stubs.FakeSessionForVMTests)\n        self.conn = xenapi_conn.XenAPIDriver(False)\n\n        self.xenstore = dict(persist={}, ephem={})\n\n        def fake_get_vm_opaque_ref(inst, instance):\n            self.assertEqual(instance, 'instance')\n            return 'vm_ref'\n\n        def fake_add_to_param_xenstore(inst, vm_ref, key, val):\n            self.assertEqual(vm_ref, 'vm_ref')\n            self.xenstore['persist'][key] = val\n\n        def fake_remove_from_param_xenstore(inst, vm_ref, key):\n            self.assertEqual(vm_ref, 'vm_ref')\n            if key in self.xenstore['persist']:\n                del self.xenstore['persist'][key]\n\n        def fake_write_to_xenstore(inst, instance, path, value, vm_ref=None):\n            self.assertEqual(instance, 'instance')\n            self.assertEqual(vm_ref, 'vm_ref')\n            self.xenstore['ephem'][path] = jsonutils.dumps(value)\n\n        def fake_delete_from_xenstore(inst, instance, path, vm_ref=None):\n            self.assertEqual(instance, 'instance')\n            self.assertEqual(vm_ref, 'vm_ref')\n            if path in self.xenstore['ephem']:\n                del self.xenstore['ephem'][path]\n\n        self.stubs.Set(vmops.VMOps, '_get_vm_opaque_ref',\n                       fake_get_vm_opaque_ref)\n        self.stubs.Set(vmops.VMOps, '_add_to_param_xenstore',\n                       fake_add_to_param_xenstore)\n        self.stubs.Set(vmops.VMOps, '_remove_from_param_xenstore',\n                       fake_remove_from_param_xenstore)\n        self.stubs.Set(vmops.VMOps, '_write_to_xenstore',\n                       fake_write_to_xenstore)\n        self.stubs.Set(vmops.VMOps, '_delete_from_xenstore',\n                       fake_delete_from_xenstore)\n\n    def test_inject_instance_metadata(self):\n\n        # Add some system_metadata to ensure it doesn't get added\n        # to xenstore\n        instance = dict(metadata=[{'key': 'a', 'value': 1},\n                                  {'key': 'b', 'value': 2},\n                                  {'key': 'c', 'value': 3},\n                                  # Check xenstore key sanitizing\n                                  {'key': 'hi.there', 'value': 4},\n                                  {'key': 'hi!t.e/e', 'value': 5}],\n                                  # Check xenstore key sanitizing\n                        system_metadata=[{'key': 'sys_a', 'value': 1},\n                                         {'key': 'sys_b', 'value': 2},\n                                         {'key': 'sys_c', 'value': 3}])\n        self.conn._vmops.inject_instance_metadata(instance, 'vm_ref')\n\n        self.assertEqual(self.xenstore, {\n                'persist': {\n                    'vm-data/user-metadata/a': '1',\n                    'vm-data/user-metadata/b': '2',\n                    'vm-data/user-metadata/c': '3',\n                    'vm-data/user-metadata/hi_there': '4',\n                    'vm-data/user-metadata/hi_t_e_e': '5',\n                    },\n                'ephem': {},\n                })\n\n    def test_change_instance_metadata_add(self):\n        # Test XenStore key sanitizing here, too.\n        diff = {'test.key': ['+', 4]}\n        self.xenstore = {\n            'persist': {\n                'vm-data/user-metadata/a': '1',\n                'vm-data/user-metadata/b': '2',\n                'vm-data/user-metadata/c': '3',\n                },\n            'ephem': {\n                'vm-data/user-metadata/a': '1',\n                'vm-data/user-metadata/b': '2',\n                'vm-data/user-metadata/c': '3',\n                },\n            }\n\n        self.conn._vmops.change_instance_metadata('instance', diff)\n\n        self.assertEqual(self.xenstore, {\n                'persist': {\n                    'vm-data/user-metadata/a': '1',\n                    'vm-data/user-metadata/b': '2',\n                    'vm-data/user-metadata/c': '3',\n                    'vm-data/user-metadata/test_key': '4',\n                    },\n                'ephem': {\n                    'vm-data/user-metadata/a': '1',\n                    'vm-data/user-metadata/b': '2',\n                    'vm-data/user-metadata/c': '3',\n                    'vm-data/user-metadata/test_key': '4',\n                    },\n                })\n\n    def test_change_instance_metadata_update(self):\n        diff = dict(b=['+', 4])\n        self.xenstore = {\n            'persist': {\n                'vm-data/user-metadata/a': '1',\n                'vm-data/user-metadata/b': '2',\n                'vm-data/user-metadata/c': '3',\n                },\n            'ephem': {\n                'vm-data/user-metadata/a': '1',\n                'vm-data/user-metadata/b': '2',\n                'vm-data/user-metadata/c': '3',\n                },\n            }\n\n        self.conn._vmops.change_instance_metadata('instance', diff)\n\n        self.assertEqual(self.xenstore, {\n                'persist': {\n                    'vm-data/user-metadata/a': '1',\n                    'vm-data/user-metadata/b': '4',\n                    'vm-data/user-metadata/c': '3',\n                    },\n                'ephem': {\n                    'vm-data/user-metadata/a': '1',\n                    'vm-data/user-metadata/b': '4',\n                    'vm-data/user-metadata/c': '3',\n                    },\n                })\n\n    def test_change_instance_metadata_delete(self):\n        diff = dict(b=['-'])\n        self.xenstore = {\n            'persist': {\n                'vm-data/user-metadata/a': '1',\n                'vm-data/user-metadata/b': '2',\n                'vm-data/user-metadata/c': '3',\n                },\n            'ephem': {\n                'vm-data/user-metadata/a': '1',\n                'vm-data/user-metadata/b': '2',\n                'vm-data/user-metadata/c': '3',\n                },\n            }\n\n        self.conn._vmops.change_instance_metadata('instance', diff)\n\n        self.assertEqual(self.xenstore, {\n                'persist': {\n                    'vm-data/user-metadata/a': '1',\n                    'vm-data/user-metadata/c': '3',\n                    },\n                'ephem': {\n                    'vm-data/user-metadata/a': '1',\n                    'vm-data/user-metadata/c': '3',\n                    },\n                })\n", "# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2010 United States Government as represented by the\n# Administrator of the National Aeronautics and Space Administration.\n#\n# Copyright 2011, Piston Cloud Computing, Inc.\n#\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\"\"\"\nUtility methods to resize, repartition, and modify disk images.\n\nIncludes injection of SSH PGP keys into authorized_keys file.\n\n\"\"\"\n\nimport crypt\nimport os\nimport random\nimport tempfile\n\nfrom nova import exception\nfrom nova import flags\nfrom nova.openstack.common import cfg\nfrom nova.openstack.common import jsonutils\nfrom nova.openstack.common import log as logging\nfrom nova import utils\nfrom nova.virt.disk import guestfs\nfrom nova.virt.disk import loop\nfrom nova.virt.disk import nbd\nfrom nova.virt import images\n\n\nLOG = logging.getLogger(__name__)\n\ndisk_opts = [\n    cfg.StrOpt('injected_network_template',\n               default='$pybasedir/nova/virt/interfaces.template',\n               help='Template file for injected network'),\n    cfg.ListOpt('img_handlers',\n                default=['loop', 'nbd', 'guestfs'],\n                help='Order of methods used to mount disk images'),\n\n    # NOTE(yamahata): ListOpt won't work because the command may include a\n    #                 comma. For example:\n    #\n    #                 mkfs.ext3 -O dir_index,extent -E stride=8,stripe-width=16\n    #                           --label %(fs_label)s %(target)s\n    #\n    #                 list arguments are comma separated and there is no way to\n    #                 escape such commas.\n    #\n    cfg.MultiStrOpt('virt_mkfs',\n                    default=[\n                      'default=mkfs.ext3 -L %(fs_label)s -F %(target)s',\n                      'linux=mkfs.ext3 -L %(fs_label)s -F %(target)s',\n                      'windows=mkfs.ntfs'\n                      ' --force --fast --label %(fs_label)s %(target)s',\n                      # NOTE(yamahata): vfat case\n                      #'windows=mkfs.vfat -n %(fs_label)s %(target)s',\n                      ],\n                    help='mkfs commands for ephemeral device. '\n                         'The format is <os_type>=<mkfs command>'),\n    ]\n\nFLAGS = flags.FLAGS\nFLAGS.register_opts(disk_opts)\n\n_MKFS_COMMAND = {}\n_DEFAULT_MKFS_COMMAND = None\n\n\nfor s in FLAGS.virt_mkfs:\n    # NOTE(yamahata): mkfs command may includes '=' for its options.\n    #                 So item.partition('=') doesn't work here\n    os_type, mkfs_command = s.split('=', 1)\n    if os_type:\n        _MKFS_COMMAND[os_type] = mkfs_command\n    if os_type == 'default':\n        _DEFAULT_MKFS_COMMAND = mkfs_command\n\n\ndef mkfs(os_type, fs_label, target):\n    mkfs_command = (_MKFS_COMMAND.get(os_type, _DEFAULT_MKFS_COMMAND) or\n                    '') % locals()\n    if mkfs_command:\n        utils.execute(*mkfs_command.split())\n\n\ndef resize2fs(image, check_exit_code=False):\n    utils.execute('e2fsck', '-fp', image, check_exit_code=check_exit_code)\n    utils.execute('resize2fs', image, check_exit_code=check_exit_code)\n\n\ndef get_disk_size(path):\n    \"\"\"Get the (virtual) size of a disk image\n\n    :param path: Path to the disk image\n    :returns: Size (in bytes) of the given disk image as it would be seen\n              by a virtual machine.\n    \"\"\"\n    size = images.qemu_img_info(path)['virtual size']\n    size = size.split('(')[1].split()[0]\n    return int(size)\n\n\ndef extend(image, size):\n    \"\"\"Increase image to size\"\"\"\n    virt_size = get_disk_size(image)\n    if virt_size >= size:\n        return\n    utils.execute('qemu-img', 'resize', image, size)\n    # NOTE(vish): attempts to resize filesystem\n    resize2fs(image)\n\n\ndef can_resize_fs(image, size, use_cow=False):\n    \"\"\"Check whether we can resize contained file system.\"\"\"\n\n    # Check that we're increasing the size\n    virt_size = get_disk_size(image)\n    if virt_size >= size:\n        return False\n\n    # Check the image is unpartitioned\n    if use_cow:\n        # Try to mount an unpartitioned qcow2 image\n        try:\n            inject_data(image, use_cow=True)\n        except exception.NovaException:\n            return False\n    else:\n        # For raw, we can directly inspect the file system\n        try:\n            utils.execute('e2label', image)\n        except exception.ProcessExecutionError:\n            return False\n\n    return True\n\n\ndef bind(src, target, instance_name):\n    \"\"\"Bind device to a filesytem\"\"\"\n    if src:\n        utils.execute('touch', target, run_as_root=True)\n        utils.execute('mount', '-o', 'bind', src, target,\n                run_as_root=True)\n        s = os.stat(src)\n        cgroup_info = \"b %s:%s rwm\\n\" % (os.major(s.st_rdev),\n                                         os.minor(s.st_rdev))\n        cgroups_path = (\"/sys/fs/cgroup/devices/libvirt/lxc/\"\n                        \"%s/devices.allow\" % instance_name)\n        utils.execute('tee', cgroups_path,\n                      process_input=cgroup_info, run_as_root=True)\n\n\ndef unbind(target):\n    if target:\n        utils.execute('umount', target, run_as_root=True)\n\n\nclass _DiskImage(object):\n    \"\"\"Provide operations on a disk image file.\"\"\"\n\n    tmp_prefix = 'openstack-disk-mount-tmp'\n\n    def __init__(self, image, partition=None, use_cow=False, mount_dir=None):\n        # These passed to each mounter\n        self.image = image\n        self.partition = partition\n        self.mount_dir = mount_dir\n\n        # Internal\n        self._mkdir = False\n        self._mounter = None\n        self._errors = []\n\n        # As a performance tweak, don't bother trying to\n        # directly loopback mount a cow image.\n        self.handlers = FLAGS.img_handlers[:]\n        if use_cow and 'loop' in self.handlers:\n            self.handlers.remove('loop')\n\n        if not self.handlers:\n            msg = _('no capable image handler configured')\n            raise exception.NovaException(msg)\n\n        if mount_dir:\n            # Note the os.path.ismount() shortcut doesn't\n            # work with libguestfs due to permissions issues.\n            device = self._device_for_path(mount_dir)\n            if device:\n                self._reset(device)\n\n    @staticmethod\n    def _device_for_path(path):\n        device = None\n        with open(\"/proc/mounts\", 'r') as ifp:\n            for line in ifp:\n                fields = line.split()\n                if fields[1] == path:\n                    device = fields[0]\n                    break\n        return device\n\n    def _reset(self, device):\n        \"\"\"Reset internal state for a previously mounted directory.\"\"\"\n        mounter_cls = self._handler_class(device=device)\n        mounter = mounter_cls(image=self.image,\n                              partition=self.partition,\n                              mount_dir=self.mount_dir,\n                              device=device)\n        self._mounter = mounter\n\n        mount_name = os.path.basename(self.mount_dir or '')\n        self._mkdir = mount_name.startswith(self.tmp_prefix)\n\n    @property\n    def errors(self):\n        \"\"\"Return the collated errors from all operations.\"\"\"\n        return '\\n--\\n'.join([''] + self._errors)\n\n    @staticmethod\n    def _handler_class(mode=None, device=None):\n        \"\"\"Look up the appropriate class to use based on MODE or DEVICE.\"\"\"\n        for cls in (loop.Mount, nbd.Mount, guestfs.Mount):\n            if mode and cls.mode == mode:\n                return cls\n            elif device and cls.device_id_string in device:\n                return cls\n        msg = _(\"no disk image handler for: %s\") % mode or device\n        raise exception.NovaException(msg)\n\n    def mount(self):\n        \"\"\"Mount a disk image, using the object attributes.\n\n        The first supported means provided by the mount classes is used.\n\n        True, or False is returned and the 'errors' attribute\n        contains any diagnostics.\n        \"\"\"\n        if self._mounter:\n            raise exception.NovaException(_('image already mounted'))\n\n        if not self.mount_dir:\n            self.mount_dir = tempfile.mkdtemp(prefix=self.tmp_prefix)\n            self._mkdir = True\n\n        try:\n            for h in self.handlers:\n                mounter_cls = self._handler_class(h)\n                mounter = mounter_cls(image=self.image,\n                                      partition=self.partition,\n                                      mount_dir=self.mount_dir)\n                if mounter.do_mount():\n                    self._mounter = mounter\n                    break\n                else:\n                    LOG.debug(mounter.error)\n                    self._errors.append(mounter.error)\n        finally:\n            if not self._mounter:\n                self.umount()  # rmdir\n\n        return bool(self._mounter)\n\n    def umount(self):\n        \"\"\"Unmount a disk image from the file system.\"\"\"\n        try:\n            if self._mounter:\n                self._mounter.do_umount()\n        finally:\n            if self._mkdir:\n                os.rmdir(self.mount_dir)\n\n\n# Public module functions\n\ndef inject_data(image,\n                key=None, net=None, metadata=None, admin_password=None,\n                files=None, partition=None, use_cow=False):\n    \"\"\"Injects a ssh key and optionally net data into a disk image.\n\n    it will mount the image as a fully partitioned disk and attempt to inject\n    into the specified partition number.\n\n    If partition is not specified it mounts the image as a single partition.\n\n    \"\"\"\n    img = _DiskImage(image=image, partition=partition, use_cow=use_cow)\n    if img.mount():\n        try:\n            inject_data_into_fs(img.mount_dir,\n                                key, net, metadata, admin_password, files)\n        finally:\n            img.umount()\n    else:\n        raise exception.NovaException(img.errors)\n\n\ndef setup_container(image, container_dir, use_cow=False):\n    \"\"\"Setup the LXC container.\n\n    It will mount the loopback image to the container directory in order\n    to create the root filesystem for the container.\n    \"\"\"\n    img = _DiskImage(image=image, use_cow=use_cow, mount_dir=container_dir)\n    if not img.mount():\n        LOG.error(_(\"Failed to mount container filesystem '%(image)s' \"\n                    \"on '%(target)s': %(errors)s\") %\n                  {\"image\": img, \"target\": container_dir,\n                   \"errors\": img.errors})\n        raise exception.NovaException(img.errors)\n\n\ndef destroy_container(container_dir):\n    \"\"\"Destroy the container once it terminates.\n\n    It will umount the container that is mounted,\n    and delete any  linked devices.\n    \"\"\"\n    try:\n        img = _DiskImage(image=None, mount_dir=container_dir)\n        img.umount()\n    except Exception, exn:\n        LOG.exception(_('Failed to unmount container filesystem: %s'), exn)\n\n\ndef inject_data_into_fs(fs, key, net, metadata, admin_password, files):\n    \"\"\"Injects data into a filesystem already mounted by the caller.\n    Virt connections can call this directly if they mount their fs\n    in a different way to inject_data\n    \"\"\"\n    if key:\n        _inject_key_into_fs(key, fs)\n    if net:\n        _inject_net_into_fs(net, fs)\n    if metadata:\n        _inject_metadata_into_fs(metadata, fs)\n    if admin_password:\n        _inject_admin_password_into_fs(admin_password, fs)\n    if files:\n        for (path, contents) in files:\n            _inject_file_into_fs(fs, path, contents)\n\n\ndef _join_and_check_path_within_fs(fs, *args):\n    '''os.path.join() with safety check for injected file paths.\n\n    Join the supplied path components and make sure that the\n    resulting path we are injecting into is within the\n    mounted guest fs.  Trying to be clever and specifying a\n    path with '..' in it will hit this safeguard.\n    '''\n    absolute_path = os.path.realpath(os.path.join(fs, *args))\n    if not absolute_path.startswith(os.path.realpath(fs) + '/'):\n        raise exception.Invalid(_('injected file path not valid'))\n    return absolute_path\n\n\ndef _inject_file_into_fs(fs, path, contents, append=False):\n    absolute_path = _join_and_check_path_within_fs(fs, path.lstrip('/'))\n\n    parent_dir = os.path.dirname(absolute_path)\n    utils.execute('mkdir', '-p', parent_dir, run_as_root=True)\n\n    args = []\n    if append:\n        args.append('-a')\n    args.append(absolute_path)\n\n    kwargs = dict(process_input=contents, run_as_root=True)\n\n    utils.execute('tee', *args, **kwargs)\n\n\ndef _inject_metadata_into_fs(metadata, fs):\n    metadata = dict([(m.key, m.value) for m in metadata])\n    _inject_file_into_fs(fs, 'meta.js', jsonutils.dumps(metadata))\n\n\ndef _setup_selinux_for_keys(fs):\n    \"\"\"Get selinux guests to ensure correct context on injected keys.\"\"\"\n\n    se_cfg = _join_and_check_path_within_fs(fs, 'etc', 'selinux')\n    se_cfg, _err = utils.trycmd('readlink', '-e', se_cfg, run_as_root=True)\n    if not se_cfg:\n        return\n\n    rclocal = _join_and_check_path_within_fs(fs, 'etc', 'rc.local')\n\n    # Support systemd based systems\n    rc_d = _join_and_check_path_within_fs(fs, 'etc', 'rc.d')\n    rclocal_e, _err = utils.trycmd('readlink', '-e', rclocal, run_as_root=True)\n    rc_d_e, _err = utils.trycmd('readlink', '-e', rc_d, run_as_root=True)\n    if not rclocal_e and rc_d_e:\n        rclocal = os.path.join(rc_d, 'rc.local')\n\n    # Note some systems end rc.local with \"exit 0\"\n    # and so to append there you'd need something like:\n    #  utils.execute('sed', '-i', '${/^exit 0$/d}' rclocal, run_as_root=True)\n    restorecon = [\n        '#!/bin/sh\\n',\n        '# Added by Nova to ensure injected ssh keys have the right context\\n',\n        'restorecon -RF /root/.ssh/ 2>/dev/null || :\\n',\n    ]\n\n    rclocal_rel = os.path.relpath(rclocal, fs)\n    _inject_file_into_fs(fs, rclocal_rel, ''.join(restorecon), append=True)\n    utils.execute('chmod', 'a+x', rclocal, run_as_root=True)\n\n\ndef _inject_key_into_fs(key, fs):\n    \"\"\"Add the given public ssh key to root's authorized_keys.\n\n    key is an ssh key string.\n    fs is the path to the base of the filesystem into which to inject the key.\n    \"\"\"\n    sshdir = _join_and_check_path_within_fs(fs, 'root', '.ssh')\n    utils.execute('mkdir', '-p', sshdir, run_as_root=True)\n    utils.execute('chown', 'root', sshdir, run_as_root=True)\n    utils.execute('chmod', '700', sshdir, run_as_root=True)\n\n    keyfile = os.path.join('root', '.ssh', 'authorized_keys')\n\n    key_data = ''.join([\n        '\\n',\n        '# The following ssh key was injected by Nova',\n        '\\n',\n        key.strip(),\n        '\\n',\n    ])\n\n    _inject_file_into_fs(fs, keyfile, key_data, append=True)\n\n    _setup_selinux_for_keys(fs)\n\n\ndef _inject_net_into_fs(net, fs):\n    \"\"\"Inject /etc/network/interfaces into the filesystem rooted at fs.\n\n    net is the contents of /etc/network/interfaces.\n    \"\"\"\n    netdir = _join_and_check_path_within_fs(fs, 'etc', 'network')\n    utils.execute('mkdir', '-p', netdir, run_as_root=True)\n    utils.execute('chown', 'root:root', netdir, run_as_root=True)\n    utils.execute('chmod', 755, netdir, run_as_root=True)\n\n    netfile = os.path.join('etc', 'network', 'interfaces')\n    _inject_file_into_fs(fs, netfile, net)\n\n\ndef _inject_admin_password_into_fs(admin_passwd, fs):\n    \"\"\"Set the root password to admin_passwd\n\n    admin_password is a root password\n    fs is the path to the base of the filesystem into which to inject\n    the key.\n\n    This method modifies the instance filesystem directly,\n    and does not require a guest agent running in the instance.\n\n    \"\"\"\n    # The approach used here is to copy the password and shadow\n    # files from the instance filesystem to local files, make any\n    # necessary changes, and then copy them back.\n\n    admin_user = 'root'\n\n    fd, tmp_passwd = tempfile.mkstemp()\n    os.close(fd)\n    fd, tmp_shadow = tempfile.mkstemp()\n    os.close(fd)\n\n    passwd_path = _join_and_check_path_within_fs(fs, 'etc', 'passwd')\n    shadow_path = _join_and_check_path_within_fs(fs, 'etc', 'shadow')\n\n    utils.execute('cp', passwd_path, tmp_passwd, run_as_root=True)\n    utils.execute('cp', shadow_path, tmp_shadow, run_as_root=True)\n    _set_passwd(admin_user, admin_passwd, tmp_passwd, tmp_shadow)\n    utils.execute('cp', tmp_passwd, passwd_path, run_as_root=True)\n    os.unlink(tmp_passwd)\n    utils.execute('cp', tmp_shadow, shadow_path, run_as_root=True)\n    os.unlink(tmp_shadow)\n\n\ndef _set_passwd(username, admin_passwd, passwd_file, shadow_file):\n    \"\"\"set the password for username to admin_passwd\n\n    The passwd_file is not modified.  The shadow_file is updated.\n    if the username is not found in both files, an exception is raised.\n\n    :param username: the username\n    :param encrypted_passwd: the  encrypted password\n    :param passwd_file: path to the passwd file\n    :param shadow_file: path to the shadow password file\n    :returns: nothing\n    :raises: exception.NovaException(), IOError()\n\n    \"\"\"\n    salt_set = ('abcdefghijklmnopqrstuvwxyz'\n                'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n                '0123456789./')\n    # encryption algo - id pairs for crypt()\n    algos = {'SHA-512': '$6$', 'SHA-256': '$5$', 'MD5': '$1$', 'DES': ''}\n\n    salt = 16 * ' '\n    salt = ''.join([random.choice(salt_set) for c in salt])\n\n    # crypt() depends on the underlying libc, and may not support all\n    # forms of hash. We try md5 first. If we get only 13 characters back,\n    # then the underlying crypt() didn't understand the '$n$salt' magic,\n    # so we fall back to DES.\n    # md5 is the default because it's widely supported. Although the\n    # local crypt() might support stronger SHA, the target instance\n    # might not.\n    encrypted_passwd = crypt.crypt(admin_passwd, algos['MD5'] + salt)\n    if len(encrypted_passwd) == 13:\n        encrypted_passwd = crypt.crypt(admin_passwd, algos['DES'] + salt)\n\n    try:\n        p_file = open(passwd_file, 'rb')\n        s_file = open(shadow_file, 'rb')\n\n        # username MUST exist in passwd file or it's an error\n        found = False\n        for entry in p_file:\n            split_entry = entry.split(':')\n            if split_entry[0] == username:\n                found = True\n                break\n        if not found:\n            msg = _('User %(username)s not found in password file.')\n            raise exception.NovaException(msg % username)\n\n        # update password in the shadow file.It's an error if the\n        # the user doesn't exist.\n        new_shadow = list()\n        found = False\n        for entry in s_file:\n            split_entry = entry.split(':')\n            if split_entry[0] == username:\n                split_entry[1] = encrypted_passwd\n                found = True\n            new_entry = ':'.join(split_entry)\n            new_shadow.append(new_entry)\n        s_file.close()\n        if not found:\n            msg = _('User %(username)s not found in shadow file.')\n            raise exception.NovaException(msg % username)\n        s_file = open(shadow_file, 'wb')\n        for entry in new_shadow:\n            s_file.write(entry)\n    finally:\n        p_file.close()\n        s_file.close()\n"], "fixing_code": ["# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2011 Isaku Yamahata\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\nimport os\n\nfrom nova import exception\nfrom nova import flags\nfrom nova import test\nfrom nova import utils\nfrom nova.virt.disk import api as disk_api\nfrom nova.virt import driver\n\nFLAGS = flags.FLAGS\n\n\nclass TestVirtDriver(test.TestCase):\n    def test_block_device(self):\n        swap = {'device_name': '/dev/sdb',\n                'swap_size': 1}\n        ephemerals = [{'num': 0,\n                       'virtual_name': 'ephemeral0',\n                       'device_name': '/dev/sdc1',\n                       'size': 1}]\n        block_device_mapping = [{'mount_device': '/dev/sde',\n                                 'device_path': 'fake_device'}]\n        block_device_info = {\n                'root_device_name': '/dev/sda',\n                'swap': swap,\n                'ephemerals': ephemerals,\n                'block_device_mapping': block_device_mapping}\n\n        empty_block_device_info = {}\n\n        self.assertEqual(\n            driver.block_device_info_get_root(block_device_info), '/dev/sda')\n        self.assertEqual(\n            driver.block_device_info_get_root(empty_block_device_info), None)\n        self.assertEqual(\n            driver.block_device_info_get_root(None), None)\n\n        self.assertEqual(\n            driver.block_device_info_get_swap(block_device_info), swap)\n        self.assertEqual(driver.block_device_info_get_swap(\n            empty_block_device_info)['device_name'], None)\n        self.assertEqual(driver.block_device_info_get_swap(\n            empty_block_device_info)['swap_size'], 0)\n        self.assertEqual(\n            driver.block_device_info_get_swap({'swap': None})['device_name'],\n            None)\n        self.assertEqual(\n            driver.block_device_info_get_swap({'swap': None})['swap_size'],\n            0)\n        self.assertEqual(\n            driver.block_device_info_get_swap(None)['device_name'], None)\n        self.assertEqual(\n            driver.block_device_info_get_swap(None)['swap_size'], 0)\n\n        self.assertEqual(\n            driver.block_device_info_get_ephemerals(block_device_info),\n            ephemerals)\n        self.assertEqual(\n            driver.block_device_info_get_ephemerals(empty_block_device_info),\n            [])\n        self.assertEqual(\n            driver.block_device_info_get_ephemerals(None),\n            [])\n\n    def test_swap_is_usable(self):\n        self.assertFalse(driver.swap_is_usable(None))\n        self.assertFalse(driver.swap_is_usable({'device_name': None}))\n        self.assertFalse(driver.swap_is_usable({'device_name': '/dev/sdb',\n                                                'swap_size': 0}))\n        self.assertTrue(driver.swap_is_usable({'device_name': '/dev/sdb',\n                                                'swap_size': 1}))\n\n\nclass TestVirtDisk(test.TestCase):\n    def setUp(self):\n        super(TestVirtDisk, self).setUp()\n        self.executes = []\n\n        def fake_execute(*cmd, **kwargs):\n            self.executes.append(cmd)\n            return None, None\n\n        self.stubs.Set(utils, 'execute', fake_execute)\n\n    def test_lxc_destroy_container(self):\n\n        def proc_mounts(self, mount_point):\n            mount_points = {\n                '/mnt/loop/nopart': '/dev/loop0',\n                '/mnt/loop/part': '/dev/mapper/loop0p1',\n                '/mnt/nbd/nopart': '/dev/nbd15',\n                '/mnt/nbd/part': '/dev/mapper/nbd15p1',\n                '/mnt/guestfs': 'guestmount',\n            }\n            return mount_points[mount_point]\n\n        self.stubs.Set(os.path, 'exists', lambda _: True)\n        self.stubs.Set(disk_api._DiskImage, '_device_for_path', proc_mounts)\n        expected_commands = []\n\n        disk_api.destroy_container('/mnt/loop/nopart')\n        expected_commands += [\n                              ('umount', '/dev/loop0'),\n                              ('losetup', '--detach', '/dev/loop0'),\n                             ]\n\n        disk_api.destroy_container('/mnt/loop/part')\n        expected_commands += [\n                              ('umount', '/dev/mapper/loop0p1'),\n                              ('kpartx', '-d', '/dev/loop0'),\n                              ('losetup', '--detach', '/dev/loop0'),\n                             ]\n\n        disk_api.destroy_container('/mnt/nbd/nopart')\n        expected_commands += [\n                              ('umount', '/dev/nbd15'),\n                              ('qemu-nbd', '-d', '/dev/nbd15'),\n                             ]\n\n        disk_api.destroy_container('/mnt/nbd/part')\n        expected_commands += [\n                              ('umount', '/dev/mapper/nbd15p1'),\n                              ('kpartx', '-d', '/dev/nbd15'),\n                              ('qemu-nbd', '-d', '/dev/nbd15'),\n                             ]\n\n        disk_api.destroy_container('/mnt/guestfs')\n        expected_commands += [\n                              ('fusermount', '-u', '/mnt/guestfs'),\n                             ]\n        # It's not worth trying to match the last timeout command\n        self.executes.pop()\n\n        self.assertEqual(self.executes, expected_commands)\n\n\nclass TestVirtDiskPaths(test.TestCase):\n    def setUp(self):\n        super(TestVirtDiskPaths, self).setUp()\n\n        real_execute = utils.execute\n\n        def nonroot_execute(*cmd_parts, **kwargs):\n            kwargs.pop('run_as_root', None)\n            return real_execute(*cmd_parts, **kwargs)\n\n        self.stubs.Set(utils, 'execute', nonroot_execute)\n\n    def test_check_safe_path(self):\n        ret = disk_api._join_and_check_path_within_fs('/foo', 'etc',\n                                                      'something.conf')\n        self.assertEquals(ret, '/foo/etc/something.conf')\n\n    def test_check_unsafe_path(self):\n        self.assertRaises(exception.Invalid,\n                          disk_api._join_and_check_path_within_fs,\n                          '/foo', 'etc/../../../something.conf')\n\n    def test_inject_files_with_bad_path(self):\n        self.assertRaises(exception.Invalid,\n                          disk_api._inject_file_into_fs,\n                          '/tmp', '/etc/../../../../etc/passwd',\n                          'hax')\n", "# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n#    Copyright (c) 2010 Citrix Systems, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\n\"\"\"Test suite for XenAPI.\"\"\"\n\nimport ast\nimport contextlib\nimport cPickle as pickle\nimport functools\nimport os\nimport re\n\nfrom nova.compute import api as compute_api\nfrom nova.compute import instance_types\nfrom nova.compute import power_state\nfrom nova import context\nfrom nova import db\nfrom nova import exception\nfrom nova import flags\nfrom nova.openstack.common import importutils\nfrom nova.openstack.common import jsonutils\nfrom nova.openstack.common import log as logging\nfrom nova.openstack.common import timeutils\nfrom nova import test\nfrom nova.tests.db import fakes as db_fakes\nfrom nova.tests import fake_network\nfrom nova.tests import fake_utils\nimport nova.tests.image.fake as fake_image\nfrom nova.tests.xenapi import stubs\nfrom nova.virt.xenapi import agent\nfrom nova.virt.xenapi import driver as xenapi_conn\nfrom nova.virt.xenapi import fake as xenapi_fake\nfrom nova.virt.xenapi import pool_states\nfrom nova.virt.xenapi import vm_utils\nfrom nova.virt.xenapi import vmops\nfrom nova.virt.xenapi import volume_utils\n\n\nLOG = logging.getLogger(__name__)\n\nFLAGS = flags.FLAGS\n\nIMAGE_MACHINE = '1'\nIMAGE_KERNEL = '2'\nIMAGE_RAMDISK = '3'\nIMAGE_RAW = '4'\nIMAGE_VHD = '5'\nIMAGE_ISO = '6'\n\nIMAGE_FIXTURES = {\n    IMAGE_MACHINE: {\n        'image_meta': {'name': 'fakemachine', 'size': 0,\n                       'disk_format': 'ami',\n                       'container_format': 'ami'},\n    },\n    IMAGE_KERNEL: {\n        'image_meta': {'name': 'fakekernel', 'size': 0,\n                       'disk_format': 'aki',\n                       'container_format': 'aki'},\n    },\n    IMAGE_RAMDISK: {\n        'image_meta': {'name': 'fakeramdisk', 'size': 0,\n                       'disk_format': 'ari',\n                       'container_format': 'ari'},\n    },\n    IMAGE_RAW: {\n        'image_meta': {'name': 'fakeraw', 'size': 0,\n                       'disk_format': 'raw',\n                       'container_format': 'bare'},\n    },\n    IMAGE_VHD: {\n        'image_meta': {'name': 'fakevhd', 'size': 0,\n                       'disk_format': 'vhd',\n                       'container_format': 'ovf'},\n    },\n    IMAGE_ISO: {\n        'image_meta': {'name': 'fakeiso', 'size': 0,\n                       'disk_format': 'iso',\n                       'container_format': 'bare'},\n    },\n}\n\n\ndef set_image_fixtures():\n    image_service = fake_image.FakeImageService()\n    image_service.images.clear()\n    for image_id, image_meta in IMAGE_FIXTURES.items():\n        image_meta = image_meta['image_meta']\n        image_meta['id'] = image_id\n        image_service.create(None, image_meta)\n\n\ndef stub_vm_utils_with_vdi_attached_here(function, should_return=True):\n    \"\"\"\n    vm_utils.with_vdi_attached_here needs to be stubbed out because it\n    calls down to the filesystem to attach a vdi. This provides a\n    decorator to handle that.\n    \"\"\"\n    @functools.wraps(function)\n    def decorated_function(self, *args, **kwargs):\n        @contextlib.contextmanager\n        def fake_vdi_attached_here(*args, **kwargs):\n            fake_dev = 'fakedev'\n            yield fake_dev\n\n        def fake_image_download(*args, **kwargs):\n            pass\n\n        def fake_is_vdi_pv(*args, **kwargs):\n            return should_return\n\n        orig_vdi_attached_here = vm_utils.vdi_attached_here\n        orig_image_download = fake_image._FakeImageService.download\n        orig_is_vdi_pv = vm_utils._is_vdi_pv\n        try:\n            vm_utils.vdi_attached_here = fake_vdi_attached_here\n            fake_image._FakeImageService.download = fake_image_download\n            vm_utils._is_vdi_pv = fake_is_vdi_pv\n            return function(self, *args, **kwargs)\n        finally:\n            vm_utils._is_vdi_pv = orig_is_vdi_pv\n            fake_image._FakeImageService.download = orig_image_download\n            vm_utils.vdi_attached_here = orig_vdi_attached_here\n\n    return decorated_function\n\n\nclass XenAPIVolumeTestCase(stubs.XenAPITestBase):\n    \"\"\"Unit tests for Volume operations.\"\"\"\n    def setUp(self):\n        super(XenAPIVolumeTestCase, self).setUp()\n        self.user_id = 'fake'\n        self.project_id = 'fake'\n        self.context = context.RequestContext(self.user_id, self.project_id)\n        self.flags(xenapi_connection_url='test_url',\n                   xenapi_connection_password='test_pass',\n                   firewall_driver='nova.virt.xenapi.firewall.'\n                                   'Dom0IptablesFirewallDriver')\n        db_fakes.stub_out_db_instance_api(self.stubs)\n        self.instance_values = {'id': 1,\n                  'project_id': self.user_id,\n                  'user_id': 'fake',\n                  'image_ref': 1,\n                  'kernel_id': 2,\n                  'ramdisk_id': 3,\n                  'root_gb': 20,\n                  'instance_type_id': '3',  # m1.large\n                  'os_type': 'linux',\n                  'architecture': 'x86-64'}\n\n    def _create_volume(self, size=0):\n        \"\"\"Create a volume object.\"\"\"\n        vol = {}\n        vol['size'] = size\n        vol['user_id'] = 'fake'\n        vol['project_id'] = 'fake'\n        vol['host'] = 'localhost'\n        vol['availability_zone'] = FLAGS.storage_availability_zone\n        vol['status'] = \"creating\"\n        vol['attach_status'] = \"detached\"\n        return db.volume_create(self.context, vol)\n\n    @staticmethod\n    def _make_info():\n        return {\n            'driver_volume_type': 'iscsi',\n            'data': {\n                'volume_id': 1,\n                'target_iqn': 'iqn.2010-10.org.openstack:volume-00000001',\n                'target_portal': '127.0.0.1:3260,fake',\n                'target_lun': None,\n                'auth_method': 'CHAP',\n                'auth_method': 'fake',\n                'auth_method': 'fake',\n            }\n        }\n\n    def test_mountpoint_to_number(self):\n        cases = {\n            'sda': 0,\n            'sdp': 15,\n            'hda': 0,\n            'hdp': 15,\n            'vda': 0,\n            'xvda': 0,\n            '0': 0,\n            '10': 10,\n            'vdq': -1,\n            'sdq': -1,\n            'hdq': -1,\n            'xvdq': -1,\n        }\n\n        for (input, expected) in cases.iteritems():\n            actual = volume_utils.mountpoint_to_number(input)\n            self.assertEqual(actual, expected,\n                    '%s yielded %s, not %s' % (input, actual, expected))\n\n    def test_parse_volume_info_raise_exception(self):\n        \"\"\"This shows how to test helper classes' methods.\"\"\"\n        stubs.stubout_session(self.stubs, stubs.FakeSessionForVolumeTests)\n        session = xenapi_conn.XenAPISession('test_url', 'root', 'test_pass')\n        vol = self._create_volume()\n        # oops, wrong mount point!\n        self.assertRaises(volume_utils.StorageError,\n                          volume_utils.parse_volume_info,\n                          self._make_info(),\n                          'dev/sd'\n                          )\n        db.volume_destroy(context.get_admin_context(), vol['id'])\n\n    def test_attach_volume(self):\n        \"\"\"This shows how to test Ops classes' methods.\"\"\"\n        stubs.stubout_session(self.stubs, stubs.FakeSessionForVolumeTests)\n        conn = xenapi_conn.XenAPIDriver(False)\n        volume = self._create_volume()\n        instance = db.instance_create(self.context, self.instance_values)\n        vm = xenapi_fake.create_vm(instance.name, 'Running')\n        result = conn.attach_volume(self._make_info(),\n                                    instance.name, '/dev/sdc')\n\n        # check that the VM has a VBD attached to it\n        # Get XenAPI record for VBD\n        vbds = xenapi_fake.get_all('VBD')\n        vbd = xenapi_fake.get_record('VBD', vbds[0])\n        vm_ref = vbd['VM']\n        self.assertEqual(vm_ref, vm)\n\n    def test_attach_volume_raise_exception(self):\n        \"\"\"This shows how to test when exceptions are raised.\"\"\"\n        stubs.stubout_session(self.stubs,\n                              stubs.FakeSessionForVolumeFailedTests)\n        conn = xenapi_conn.XenAPIDriver(False)\n        volume = self._create_volume()\n        instance = db.instance_create(self.context, self.instance_values)\n        xenapi_fake.create_vm(instance.name, 'Running')\n        self.assertRaises(exception.VolumeDriverNotFound,\n                          conn.attach_volume,\n                          {'driver_volume_type': 'nonexist'},\n                          instance.name,\n                          '/dev/sdc')\n\n\nclass XenAPIVMTestCase(stubs.XenAPITestBase):\n    \"\"\"Unit tests for VM operations.\"\"\"\n    def setUp(self):\n        super(XenAPIVMTestCase, self).setUp()\n        self.network = importutils.import_object(FLAGS.network_manager)\n        self.flags(xenapi_connection_url='test_url',\n                   xenapi_connection_password='test_pass',\n                   instance_name_template='%d',\n                   firewall_driver='nova.virt.xenapi.firewall.'\n                                   'Dom0IptablesFirewallDriver')\n        xenapi_fake.create_local_srs()\n        xenapi_fake.create_local_pifs()\n        db_fakes.stub_out_db_instance_api(self.stubs)\n        xenapi_fake.create_network('fake', FLAGS.flat_network_bridge)\n        stubs.stubout_session(self.stubs, stubs.FakeSessionForVMTests)\n        stubs.stubout_get_this_vm_uuid(self.stubs)\n        stubs.stubout_is_vdi_pv(self.stubs)\n        stubs.stub_out_vm_methods(self.stubs)\n        fake_utils.stub_out_utils_execute(self.stubs)\n        self.user_id = 'fake'\n        self.project_id = 'fake'\n        self.context = context.RequestContext(self.user_id, self.project_id)\n        self.conn = xenapi_conn.XenAPIDriver(False)\n\n        fake_image.stub_out_image_service(self.stubs)\n        set_image_fixtures()\n        stubs.stubout_image_service_download(self.stubs)\n        stubs.stubout_stream_disk(self.stubs)\n\n        def fake_inject_instance_metadata(self, instance, vm):\n            pass\n        self.stubs.Set(vmops.VMOps, 'inject_instance_metadata',\n                       fake_inject_instance_metadata)\n\n        def fake_safe_copy_vdi(session, sr_ref, instance, vdi_to_copy_ref):\n            name_label = \"fakenamelabel\"\n            disk_type = \"fakedisktype\"\n            virtual_size = 777\n            return vm_utils.create_vdi(\n                    session, sr_ref, instance, name_label, disk_type,\n                    virtual_size)\n        self.stubs.Set(vm_utils, '_safe_copy_vdi', fake_safe_copy_vdi)\n\n    def tearDown(self):\n        super(XenAPIVMTestCase, self).tearDown()\n        fake_image.FakeImageService_reset()\n\n    def test_init_host(self):\n        session = xenapi_conn.XenAPISession('test_url', 'root', 'test_pass')\n        vm = vm_utils._get_this_vm_ref(session)\n        # Local root disk\n        vdi0 = xenapi_fake.create_vdi('compute', None)\n        vbd0 = xenapi_fake.create_vbd(vm, vdi0)\n        # Instance VDI\n        vdi1 = xenapi_fake.create_vdi('instance-aaaa', None,\n                other_config={'nova_instance_uuid': 'aaaa'})\n        vbd1 = xenapi_fake.create_vbd(vm, vdi1)\n        # Only looks like instance VDI\n        vdi2 = xenapi_fake.create_vdi('instance-bbbb', None)\n        vbd2 = xenapi_fake.create_vbd(vm, vdi2)\n\n        self.conn.init_host(None)\n        self.assertEquals(set(xenapi_fake.get_all('VBD')), set([vbd0, vbd2]))\n\n    def test_list_instances_0(self):\n        instances = self.conn.list_instances()\n        self.assertEquals(instances, [])\n\n    def test_get_rrd_server(self):\n        self.flags(xenapi_connection_url='myscheme://myaddress/')\n        server_info = vm_utils._get_rrd_server()\n        self.assertEqual(server_info[0], 'myscheme')\n        self.assertEqual(server_info[1], 'myaddress')\n\n    def test_get_diagnostics(self):\n        def fake_get_rrd(host, vm_uuid):\n            with open('xenapi/vm_rrd.xml') as f:\n                return re.sub(r'\\s', '', f.read())\n        self.stubs.Set(vm_utils, '_get_rrd', fake_get_rrd)\n\n        fake_diagnostics = {\n            'vbd_xvdb_write': '0.0',\n            'memory_target': '4294967296.0000',\n            'memory_internal_free': '1415564.0000',\n            'memory': '4294967296.0000',\n            'vbd_xvda_write': '0.0',\n            'cpu0': '0.0042',\n            'vif_0_tx': '287.4134',\n            'vbd_xvda_read': '0.0',\n            'vif_0_rx': '1816.0144',\n            'vif_2_rx': '0.0',\n            'vif_2_tx': '0.0',\n            'vbd_xvdb_read': '0.0',\n            'last_update': '1328795567',\n        }\n        instance = self._create_instance()\n        expected = self.conn.get_diagnostics(instance)\n        self.assertDictMatch(fake_diagnostics, expected)\n\n    def test_instance_snapshot_fails_with_no_primary_vdi(self):\n        def create_bad_vbd(vm_ref, vdi_ref):\n            vbd_rec = {'VM': vm_ref,\n               'VDI': vdi_ref,\n               'userdevice': 'fake',\n               'currently_attached': False}\n            vbd_ref = xenapi_fake._create_object('VBD', vbd_rec)\n            xenapi_fake.after_VBD_create(vbd_ref, vbd_rec)\n            return vbd_ref\n\n        self.stubs.Set(xenapi_fake, 'create_vbd', create_bad_vbd)\n        stubs.stubout_instance_snapshot(self.stubs)\n        # Stubbing out firewall driver as previous stub sets alters\n        # xml rpc result parsing\n        stubs.stubout_firewall_driver(self.stubs, self.conn)\n        instance = self._create_instance()\n\n        image_id = \"my_snapshot_id\"\n        self.assertRaises(exception.NovaException, self.conn.snapshot,\n                          self.context, instance, image_id)\n\n    def test_instance_snapshot(self):\n        stubs.stubout_instance_snapshot(self.stubs)\n        stubs.stubout_is_snapshot(self.stubs)\n        # Stubbing out firewall driver as previous stub sets alters\n        # xml rpc result parsing\n        stubs.stubout_firewall_driver(self.stubs, self.conn)\n        instance = self._create_instance()\n\n        image_id = \"my_snapshot_id\"\n        self.conn.snapshot(self.context, instance, image_id)\n\n        # Ensure VM was torn down\n        vm_labels = []\n        for vm_ref in xenapi_fake.get_all('VM'):\n            vm_rec = xenapi_fake.get_record('VM', vm_ref)\n            if not vm_rec[\"is_control_domain\"]:\n                vm_labels.append(vm_rec[\"name_label\"])\n\n        self.assertEquals(vm_labels, [instance.name])\n\n        # Ensure VBDs were torn down\n        vbd_labels = []\n        for vbd_ref in xenapi_fake.get_all('VBD'):\n            vbd_rec = xenapi_fake.get_record('VBD', vbd_ref)\n            vbd_labels.append(vbd_rec[\"vm_name_label\"])\n\n        self.assertEquals(vbd_labels, [instance.name])\n\n        # Ensure VDIs were torn down\n        for vdi_ref in xenapi_fake.get_all('VDI'):\n            vdi_rec = xenapi_fake.get_record('VDI', vdi_ref)\n            name_label = vdi_rec[\"name_label\"]\n            self.assert_(not name_label.endswith('snapshot'))\n\n    def create_vm_record(self, conn, os_type, name):\n        instances = conn.list_instances()\n        self.assertEquals(instances, [name])\n\n        # Get Nova record for VM\n        vm_info = conn.get_info({'name': name})\n        # Get XenAPI record for VM\n        vms = [rec for ref, rec\n               in xenapi_fake.get_all_records('VM').iteritems()\n               if not rec['is_control_domain']]\n        vm = vms[0]\n        self.vm_info = vm_info\n        self.vm = vm\n\n    def check_vm_record(self, conn, check_injection=False):\n        # Check that m1.large above turned into the right thing.\n        instance_type = db.instance_type_get_by_name(conn, 'm1.large')\n        mem_kib = long(instance_type['memory_mb']) << 10\n        mem_bytes = str(mem_kib << 10)\n        vcpus = instance_type['vcpus']\n        self.assertEquals(self.vm_info['max_mem'], mem_kib)\n        self.assertEquals(self.vm_info['mem'], mem_kib)\n        self.assertEquals(self.vm['memory_static_max'], mem_bytes)\n        self.assertEquals(self.vm['memory_dynamic_max'], mem_bytes)\n        self.assertEquals(self.vm['memory_dynamic_min'], mem_bytes)\n        self.assertEquals(self.vm['VCPUs_max'], str(vcpus))\n        self.assertEquals(self.vm['VCPUs_at_startup'], str(vcpus))\n\n        # Check that the VM is running according to Nova\n        self.assertEquals(self.vm_info['state'], power_state.RUNNING)\n\n        # Check that the VM is running according to XenAPI.\n        self.assertEquals(self.vm['power_state'], 'Running')\n\n        if check_injection:\n            xenstore_data = self.vm['xenstore_data']\n            self.assertEquals(xenstore_data['vm-data/hostname'], 'test')\n            key = 'vm-data/networking/DEADBEEF0001'\n            xenstore_value = xenstore_data[key]\n            tcpip_data = ast.literal_eval(xenstore_value)\n            self.assertEquals(tcpip_data,\n                              {'broadcast': '192.168.1.255',\n                               'dns': ['192.168.1.4', '192.168.1.3'],\n                               'gateway': '192.168.1.1',\n                               'gateway_v6': 'fe80::def',\n                               'ip6s': [{'enabled': '1',\n                                         'ip': '2001:db8:0:1::1',\n                                         'netmask': 64,\n                                         'gateway': 'fe80::def'}],\n                               'ips': [{'enabled': '1',\n                                        'ip': '192.168.1.100',\n                                        'netmask': '255.255.255.0',\n                                        'gateway': '192.168.1.1'},\n                                       {'enabled': '1',\n                                        'ip': '192.168.1.101',\n                                        'netmask': '255.255.255.0',\n                                        'gateway': '192.168.1.1'}],\n                               'label': 'test1',\n                               'mac': 'DE:AD:BE:EF:00:01'})\n\n    def check_vm_params_for_windows(self):\n        self.assertEquals(self.vm['platform']['nx'], 'true')\n        self.assertEquals(self.vm['HVM_boot_params'], {'order': 'dc'})\n        self.assertEquals(self.vm['HVM_boot_policy'], 'BIOS order')\n\n        # check that these are not set\n        self.assertEquals(self.vm['PV_args'], '')\n        self.assertEquals(self.vm['PV_bootloader'], '')\n        self.assertEquals(self.vm['PV_kernel'], '')\n        self.assertEquals(self.vm['PV_ramdisk'], '')\n\n    def check_vm_params_for_linux(self):\n        self.assertEquals(self.vm['platform']['nx'], 'false')\n        self.assertEquals(self.vm['PV_args'], '')\n        self.assertEquals(self.vm['PV_bootloader'], 'pygrub')\n\n        # check that these are not set\n        self.assertEquals(self.vm['PV_kernel'], '')\n        self.assertEquals(self.vm['PV_ramdisk'], '')\n        self.assertEquals(self.vm['HVM_boot_params'], {})\n        self.assertEquals(self.vm['HVM_boot_policy'], '')\n\n    def check_vm_params_for_linux_with_external_kernel(self):\n        self.assertEquals(self.vm['platform']['nx'], 'false')\n        self.assertEquals(self.vm['PV_args'], 'root=/dev/xvda1')\n        self.assertNotEquals(self.vm['PV_kernel'], '')\n        self.assertNotEquals(self.vm['PV_ramdisk'], '')\n\n        # check that these are not set\n        self.assertEquals(self.vm['HVM_boot_params'], {})\n        self.assertEquals(self.vm['HVM_boot_policy'], '')\n\n    def _list_vdis(self):\n        url = FLAGS.xenapi_connection_url\n        username = FLAGS.xenapi_connection_username\n        password = FLAGS.xenapi_connection_password\n        session = xenapi_conn.XenAPISession(url, username, password)\n        return session.call_xenapi('VDI.get_all')\n\n    def _check_vdis(self, start_list, end_list):\n        for vdi_ref in end_list:\n            if not vdi_ref in start_list:\n                vdi_rec = xenapi_fake.get_record('VDI', vdi_ref)\n                # If the cache is turned on then the base disk will be\n                # there even after the cleanup\n                if 'other_config' in vdi_rec:\n                    if 'image-id' not in vdi_rec['other_config']:\n                        self.fail('Found unexpected VDI:%s' % vdi_ref)\n                else:\n                    self.fail('Found unexpected VDI:%s' % vdi_ref)\n\n    def _test_spawn(self, image_ref, kernel_id, ramdisk_id,\n                    instance_type_id=\"3\", os_type=\"linux\",\n                    hostname=\"test\", architecture=\"x86-64\", instance_id=1,\n                    check_injection=False,\n                    create_record=True, empty_dns=False):\n        # Fake out inject_instance_metadata\n        def fake_inject_instance_metadata(self, instance, vm):\n            pass\n        self.stubs.Set(vmops.VMOps, 'inject_instance_metadata',\n                       fake_inject_instance_metadata)\n\n        if create_record:\n            instance_values = {'id': instance_id,\n                      'project_id': self.project_id,\n                      'user_id': self.user_id,\n                      'image_ref': image_ref,\n                      'kernel_id': kernel_id,\n                      'ramdisk_id': ramdisk_id,\n                      'root_gb': 20,\n                      'instance_type_id': instance_type_id,\n                      'os_type': os_type,\n                      'hostname': hostname,\n                      'architecture': architecture}\n            instance = db.instance_create(self.context, instance_values)\n        else:\n            instance = db.instance_get(self.context, instance_id)\n\n        network_info = fake_network.fake_get_instance_nw_info(self.stubs,\n                                                              spectacular=True)\n        if empty_dns:\n            # NOTE(tr3buchet): this is a terrible way to do this...\n            network_info[0]['network']['subnets'][0]['dns'] = []\n\n        # admin_pass isn't part of the DB model, but it does get set as\n        # an attribute for spawn to use\n        instance.admin_pass = 'herp'\n        image_meta = {'id': IMAGE_VHD,\n                      'disk_format': 'vhd'}\n        self.conn.spawn(self.context, instance, image_meta, network_info)\n        self.create_vm_record(self.conn, os_type, instance['name'])\n        self.check_vm_record(self.conn, check_injection)\n        self.assertTrue(instance.os_type)\n        self.assertTrue(instance.architecture)\n\n    def test_spawn_empty_dns(self):\n        \"\"\"Test spawning with an empty dns list\"\"\"\n        self._test_spawn(IMAGE_VHD, None, None,\n                         os_type=\"linux\", architecture=\"x86-64\",\n                         empty_dns=True)\n        self.check_vm_params_for_linux()\n\n    def test_spawn_not_enough_memory(self):\n        self.assertRaises(exception.InsufficientFreeMemory,\n                          self._test_spawn,\n                          1, 2, 3, \"4\")  # m1.xlarge\n\n    def test_spawn_fail_cleanup_1(self):\n        \"\"\"Simulates an error while downloading an image.\n\n        Verifies that VDIs created are properly cleaned up.\n\n        \"\"\"\n        vdi_recs_start = self._list_vdis()\n        stubs.stubout_fetch_disk_image(self.stubs, raise_failure=True)\n        self.assertRaises(xenapi_fake.Failure,\n                          self._test_spawn, 1, 2, 3)\n        # No additional VDI should be found.\n        vdi_recs_end = self._list_vdis()\n        self._check_vdis(vdi_recs_start, vdi_recs_end)\n\n    def test_spawn_fail_cleanup_2(self):\n        \"\"\"Simulates an error while creating VM record.\n\n        It verifies that VDIs created are properly cleaned up.\n\n        \"\"\"\n        vdi_recs_start = self._list_vdis()\n        stubs.stubout_create_vm(self.stubs)\n        self.assertRaises(xenapi_fake.Failure,\n                          self._test_spawn, 1, 2, 3)\n        # No additional VDI should be found.\n        vdi_recs_end = self._list_vdis()\n        self._check_vdis(vdi_recs_start, vdi_recs_end)\n\n    @stub_vm_utils_with_vdi_attached_here\n    def test_spawn_raw_glance(self):\n        self._test_spawn(IMAGE_RAW, None, None)\n        self.check_vm_params_for_linux()\n\n    def test_spawn_vhd_glance_linux(self):\n        self._test_spawn(IMAGE_VHD, None, None,\n                         os_type=\"linux\", architecture=\"x86-64\")\n        self.check_vm_params_for_linux()\n\n    def test_spawn_vhd_glance_swapdisk(self):\n        # Change the default host_call_plugin to one that'll return\n        # a swap disk\n        orig_func = stubs.FakeSessionForVMTests.host_call_plugin\n        _host_call_plugin = stubs.FakeSessionForVMTests.host_call_plugin_swap\n        stubs.FakeSessionForVMTests.host_call_plugin = _host_call_plugin\n        # Stubbing out firewall driver as previous stub sets a particular\n        # stub for async plugin calls\n        stubs.stubout_firewall_driver(self.stubs, self.conn)\n        try:\n            # We'll steal the above glance linux test\n            self.test_spawn_vhd_glance_linux()\n        finally:\n            # Make sure to put this back\n            stubs.FakeSessionForVMTests.host_call_plugin = orig_func\n\n        # We should have 2 VBDs.\n        self.assertEqual(len(self.vm['VBDs']), 2)\n        # Now test that we have 1.\n        self.tearDown()\n        self.setUp()\n        self.test_spawn_vhd_glance_linux()\n        self.assertEqual(len(self.vm['VBDs']), 1)\n\n    def test_spawn_vhd_glance_windows(self):\n        self._test_spawn(IMAGE_VHD, None, None,\n                         os_type=\"windows\", architecture=\"i386\")\n        self.check_vm_params_for_windows()\n\n    def test_spawn_iso_glance(self):\n        self._test_spawn(IMAGE_ISO, None, None,\n                         os_type=\"windows\", architecture=\"i386\")\n        self.check_vm_params_for_windows()\n\n    def test_spawn_glance(self):\n        stubs.stubout_fetch_disk_image(self.stubs)\n        self._test_spawn(IMAGE_MACHINE,\n                         IMAGE_KERNEL,\n                         IMAGE_RAMDISK)\n        self.check_vm_params_for_linux_with_external_kernel()\n\n    def test_spawn_netinject_file(self):\n        self.flags(flat_injected=True)\n        db_fakes.stub_out_db_instance_api(self.stubs, injected=True)\n\n        self._tee_executed = False\n\n        def _tee_handler(cmd, **kwargs):\n            input = kwargs.get('process_input', None)\n            self.assertNotEqual(input, None)\n            config = [line.strip() for line in input.split(\"\\n\")]\n            # Find the start of eth0 configuration and check it\n            index = config.index('auto eth0')\n            self.assertEquals(config[index + 1:index + 8], [\n                'iface eth0 inet static',\n                'address 192.168.1.100',\n                'netmask 255.255.255.0',\n                'broadcast 192.168.1.255',\n                'gateway 192.168.1.1',\n                'dns-nameservers 192.168.1.3 192.168.1.4',\n                ''])\n            self._tee_executed = True\n            return '', ''\n\n        def _readlink_handler(cmd_parts, **kwargs):\n            return os.path.realpath(cmd_parts[2]), ''\n\n        fake_utils.fake_execute_set_repliers([\n            # Capture the tee .../etc/network/interfaces command\n            (r'tee.*interfaces', _tee_handler),\n            (r'readlink -nm.*', _readlink_handler),\n        ])\n        self._test_spawn(IMAGE_MACHINE,\n                         IMAGE_KERNEL,\n                         IMAGE_RAMDISK,\n                         check_injection=True)\n        self.assertTrue(self._tee_executed)\n\n    def test_spawn_netinject_xenstore(self):\n        db_fakes.stub_out_db_instance_api(self.stubs, injected=True)\n\n        self._tee_executed = False\n\n        def _mount_handler(cmd, *ignore_args, **ignore_kwargs):\n            # When mounting, create real files under the mountpoint to simulate\n            # files in the mounted filesystem\n\n            # mount point will be the last item of the command list\n            self._tmpdir = cmd[len(cmd) - 1]\n            LOG.debug(_('Creating files in %s to simulate guest agent'),\n                      self._tmpdir)\n            os.makedirs(os.path.join(self._tmpdir, 'usr', 'sbin'))\n            # Touch the file using open\n            open(os.path.join(self._tmpdir, 'usr', 'sbin',\n                'xe-update-networking'), 'w').close()\n            return '', ''\n\n        def _umount_handler(cmd, *ignore_args, **ignore_kwargs):\n            # Umount would normall make files in the m,ounted filesystem\n            # disappear, so do that here\n            LOG.debug(_('Removing simulated guest agent files in %s'),\n                      self._tmpdir)\n            os.remove(os.path.join(self._tmpdir, 'usr', 'sbin',\n                'xe-update-networking'))\n            os.rmdir(os.path.join(self._tmpdir, 'usr', 'sbin'))\n            os.rmdir(os.path.join(self._tmpdir, 'usr'))\n            return '', ''\n\n        def _tee_handler(cmd, *ignore_args, **ignore_kwargs):\n            self._tee_executed = True\n            return '', ''\n\n        fake_utils.fake_execute_set_repliers([\n            (r'mount', _mount_handler),\n            (r'umount', _umount_handler),\n            (r'tee.*interfaces', _tee_handler)])\n        self._test_spawn(1, 2, 3, check_injection=True)\n\n        # tee must not run in this case, where an injection-capable\n        # guest agent is detected\n        self.assertFalse(self._tee_executed)\n\n    def test_spawn_vlanmanager(self):\n        self.flags(network_manager='nova.network.manager.VlanManager',\n                   vlan_interface='fake0')\n\n        def dummy(*args, **kwargs):\n            pass\n\n        self.stubs.Set(vmops.VMOps, '_create_vifs', dummy)\n        # Reset network table\n        xenapi_fake.reset_table('network')\n        # Instance id = 2 will use vlan network (see db/fakes.py)\n        ctxt = self.context.elevated()\n        instance = self._create_instance(2, False)\n        networks = self.network.db.network_get_all(ctxt)\n        for network in networks:\n            self.network.set_network_host(ctxt, network)\n\n        self.network.allocate_for_instance(ctxt,\n                          instance_id=2,\n                          instance_uuid='00000000-0000-0000-0000-000000000002',\n                          host=FLAGS.host,\n                          vpn=None,\n                          rxtx_factor=3,\n                          project_id=self.project_id)\n        self._test_spawn(IMAGE_MACHINE,\n                         IMAGE_KERNEL,\n                         IMAGE_RAMDISK,\n                         instance_id=2,\n                         create_record=False)\n        # TODO(salvatore-orlando): a complete test here would require\n        # a check for making sure the bridge for the VM's VIF is\n        # consistent with bridge specified in nova db\n\n    def test_spawn_with_network_qos(self):\n        self._create_instance()\n        for vif_ref in xenapi_fake.get_all('VIF'):\n            vif_rec = xenapi_fake.get_record('VIF', vif_ref)\n            self.assertEquals(vif_rec['qos_algorithm_type'], 'ratelimit')\n            self.assertEquals(vif_rec['qos_algorithm_params']['kbps'],\n                              str(3 * 10 * 1024))\n\n    def test_rescue(self):\n        instance = self._create_instance()\n        session = xenapi_conn.XenAPISession('test_url', 'root', 'test_pass')\n        vm_ref = vm_utils.lookup(session, instance.name)\n\n        swap_vdi_ref = xenapi_fake.create_vdi('swap', None)\n        root_vdi_ref = xenapi_fake.create_vdi('root', None)\n\n        xenapi_fake.create_vbd(vm_ref, swap_vdi_ref, userdevice=1)\n        xenapi_fake.create_vbd(vm_ref, root_vdi_ref, userdevice=0)\n\n        conn = xenapi_conn.XenAPIDriver(False)\n        image_meta = {'id': IMAGE_VHD,\n                      'disk_format': 'vhd'}\n        conn.rescue(self.context, instance, [], image_meta)\n\n        vm = xenapi_fake.get_record('VM', vm_ref)\n        rescue_name = \"%s-rescue\" % vm[\"name_label\"]\n        rescue_ref = vm_utils.lookup(session, rescue_name)\n        rescue_vm = xenapi_fake.get_record('VM', rescue_ref)\n\n        vdi_uuids = []\n        for vbd_uuid in rescue_vm[\"VBDs\"]:\n            vdi_uuids.append(xenapi_fake.get_record('VBD', vbd_uuid)[\"VDI\"])\n        self.assertTrue(\"swap\" not in vdi_uuids)\n\n    def test_unrescue(self):\n        instance = self._create_instance()\n        conn = xenapi_conn.XenAPIDriver(False)\n        # Unrescue expects the original instance to be powered off\n        conn.power_off(instance)\n        rescue_vm = xenapi_fake.create_vm(instance.name + '-rescue', 'Running')\n        conn.unrescue(instance, None)\n\n    def test_unrescue_not_in_rescue(self):\n        instance = self._create_instance()\n        conn = xenapi_conn.XenAPIDriver(False)\n        # Ensure that it will not unrescue a non-rescued instance.\n        self.assertRaises(exception.InstanceNotInRescueMode, conn.unrescue,\n                          instance, None)\n\n    def test_finish_revert_migration(self):\n        instance = self._create_instance()\n\n        class VMOpsMock():\n\n            def __init__(self):\n                self.finish_revert_migration_called = False\n\n            def finish_revert_migration(self, instance):\n                self.finish_revert_migration_called = True\n\n        conn = xenapi_conn.XenAPIDriver(False)\n        conn._vmops = VMOpsMock()\n        conn.finish_revert_migration(instance, None)\n        self.assertTrue(conn._vmops.finish_revert_migration_called)\n\n    def test_reboot_hard(self):\n        instance = self._create_instance()\n        conn = xenapi_conn.XenAPIDriver(False)\n        conn.reboot(instance, None, \"HARD\")\n\n    def test_reboot_soft(self):\n        instance = self._create_instance()\n        conn = xenapi_conn.XenAPIDriver(False)\n        conn.reboot(instance, None, \"SOFT\")\n\n    def test_reboot_halted(self):\n        session = xenapi_conn.XenAPISession('test_url', 'root', 'test_pass')\n        instance = self._create_instance(spawn=False)\n        conn = xenapi_conn.XenAPIDriver(False)\n        xenapi_fake.create_vm(instance.name, 'Halted')\n        conn.reboot(instance, None, \"SOFT\")\n        vm_ref = vm_utils.lookup(session, instance.name)\n        vm = xenapi_fake.get_record('VM', vm_ref)\n        self.assertEquals(vm['power_state'], 'Running')\n\n    def test_reboot_unknown_state(self):\n        instance = self._create_instance(spawn=False)\n        conn = xenapi_conn.XenAPIDriver(False)\n        xenapi_fake.create_vm(instance.name, 'Unknown')\n        self.assertRaises(xenapi_fake.Failure, conn.reboot, instance,\n                None, \"SOFT\")\n\n    def _create_instance(self, instance_id=1, spawn=True):\n        \"\"\"Creates and spawns a test instance.\"\"\"\n        instance_values = {\n            'id': instance_id,\n            'uuid': '00000000-0000-0000-0000-00000000000%d' % instance_id,\n            'project_id': self.project_id,\n            'user_id': self.user_id,\n            'image_ref': 1,\n            'kernel_id': 2,\n            'ramdisk_id': 3,\n            'root_gb': 20,\n            'instance_type_id': '3',  # m1.large\n            'os_type': 'linux',\n            'vm_mode': 'hvm',\n            'architecture': 'x86-64'}\n        instance = db.instance_create(self.context, instance_values)\n        network_info = fake_network.fake_get_instance_nw_info(self.stubs,\n                                                              spectacular=True)\n        image_meta = {'id': IMAGE_VHD,\n                      'disk_format': 'vhd'}\n        if spawn:\n            instance.admin_pass = 'herp'\n            self.conn.spawn(self.context, instance, image_meta, network_info)\n        return instance\n\n\nclass XenAPIDiffieHellmanTestCase(test.TestCase):\n    \"\"\"Unit tests for Diffie-Hellman code.\"\"\"\n    def setUp(self):\n        super(XenAPIDiffieHellmanTestCase, self).setUp()\n        self.alice = agent.SimpleDH()\n        self.bob = agent.SimpleDH()\n\n    def test_shared(self):\n        alice_pub = self.alice.get_public()\n        bob_pub = self.bob.get_public()\n        alice_shared = self.alice.compute_shared(bob_pub)\n        bob_shared = self.bob.compute_shared(alice_pub)\n        self.assertEquals(alice_shared, bob_shared)\n\n    def _test_encryption(self, message):\n        enc = self.alice.encrypt(message)\n        self.assertFalse(enc.endswith('\\n'))\n        dec = self.bob.decrypt(enc)\n        self.assertEquals(dec, message)\n\n    def test_encrypt_simple_message(self):\n        self._test_encryption('This is a simple message.')\n\n    def test_encrypt_message_with_newlines_at_end(self):\n        self._test_encryption('This message has a newline at the end.\\n')\n\n    def test_encrypt_many_newlines_at_end(self):\n        self._test_encryption('Message with lotsa newlines.\\n\\n\\n')\n\n    def test_encrypt_newlines_inside_message(self):\n        self._test_encryption('Message\\nwith\\ninterior\\nnewlines.')\n\n    def test_encrypt_with_leading_newlines(self):\n        self._test_encryption('\\n\\nMessage with leading newlines.')\n\n    def test_encrypt_really_long_message(self):\n        self._test_encryption(''.join(['abcd' for i in xrange(1024)]))\n\n\nclass XenAPIMigrateInstance(stubs.XenAPITestBase):\n    \"\"\"Unit test for verifying migration-related actions.\"\"\"\n\n    def setUp(self):\n        super(XenAPIMigrateInstance, self).setUp()\n        self.flags(xenapi_connection_url='test_url',\n                   xenapi_connection_password='test_pass',\n                   firewall_driver='nova.virt.xenapi.firewall.'\n                                   'Dom0IptablesFirewallDriver')\n        stubs.stubout_session(self.stubs, stubs.FakeSessionForVMTests)\n        db_fakes.stub_out_db_instance_api(self.stubs)\n        xenapi_fake.create_network('fake', FLAGS.flat_network_bridge)\n        self.user_id = 'fake'\n        self.project_id = 'fake'\n        self.context = context.RequestContext(self.user_id, self.project_id)\n        self.instance_values = {'id': 1,\n                  'project_id': self.project_id,\n                  'user_id': self.user_id,\n                  'image_ref': 1,\n                  'kernel_id': None,\n                  'ramdisk_id': None,\n                  'root_gb': 5,\n                  'instance_type_id': '3',  # m1.large\n                  'os_type': 'linux',\n                  'architecture': 'x86-64'}\n\n        migration_values = {\n            'source_compute': 'nova-compute',\n            'dest_compute': 'nova-compute',\n            'dest_host': '10.127.5.114',\n            'status': 'post-migrating',\n            'instance_uuid': '15f23e6a-cc6e-4d22-b651-d9bdaac316f7',\n            'old_instance_type_id': 5,\n            'new_instance_type_id': 1\n        }\n        self.migration = db.migration_create(\n            context.get_admin_context(), migration_values)\n\n        fake_utils.stub_out_utils_execute(self.stubs)\n        stubs.stub_out_migration_methods(self.stubs)\n        stubs.stubout_get_this_vm_uuid(self.stubs)\n\n        def fake_inject_instance_metadata(self, instance, vm):\n            pass\n        self.stubs.Set(vmops.VMOps, 'inject_instance_metadata',\n                       fake_inject_instance_metadata)\n\n    def test_resize_xenserver_6(self):\n        instance = db.instance_create(self.context, self.instance_values)\n        called = {'resize': False}\n\n        def fake_vdi_resize(*args, **kwargs):\n            called['resize'] = True\n\n        self.stubs.Set(stubs.FakeSessionForVMTests,\n                       \"VDI_resize\", fake_vdi_resize)\n        stubs.stubout_session(self.stubs, stubs.FakeSessionForVMTests,\n                              product_version=(6, 0, 0),\n                              product_brand='XenServer')\n        conn = xenapi_conn.XenAPIDriver(False)\n        vdi_ref = xenapi_fake.create_vdi('hurr', 'fake')\n        vdi_uuid = xenapi_fake.get_record('VDI', vdi_ref)['uuid']\n        conn._vmops._resize_instance(instance,\n                                     {'uuid': vdi_uuid, 'ref': vdi_ref})\n        self.assertEqual(called['resize'], True)\n\n    def test_resize_xcp(self):\n        instance = db.instance_create(self.context, self.instance_values)\n        called = {'resize': False}\n\n        def fake_vdi_resize(*args, **kwargs):\n            called['resize'] = True\n\n        self.stubs.Set(stubs.FakeSessionForVMTests,\n                       \"VDI_resize\", fake_vdi_resize)\n        stubs.stubout_session(self.stubs, stubs.FakeSessionForVMTests,\n                              product_version=(1, 4, 99),\n                              product_brand='XCP')\n        conn = xenapi_conn.XenAPIDriver(False)\n        vdi_ref = xenapi_fake.create_vdi('hurr', 'fake')\n        vdi_uuid = xenapi_fake.get_record('VDI', vdi_ref)['uuid']\n        conn._vmops._resize_instance(instance,\n                                     {'uuid': vdi_uuid, 'ref': vdi_ref})\n        self.assertEqual(called['resize'], True)\n\n    def test_migrate_disk_and_power_off(self):\n        instance = db.instance_create(self.context, self.instance_values)\n        xenapi_fake.create_vm(instance.name, 'Running')\n        instance_type = db.instance_type_get_by_name(self.context, 'm1.large')\n        conn = xenapi_conn.XenAPIDriver(False)\n        conn.migrate_disk_and_power_off(self.context, instance,\n                                        '127.0.0.1', instance_type, None)\n\n    def test_migrate_disk_and_power_off(self):\n        instance = db.instance_create(self.context, self.instance_values)\n        xenapi_fake.create_vm(instance.name, 'Running')\n        instance_type = db.instance_type_get_by_name(self.context, 'm1.large')\n        conn = xenapi_conn.XenAPIDriver(False)\n        conn.migrate_disk_and_power_off(self.context, instance,\n                                        '127.0.0.1', instance_type, None)\n\n    def test_migrate_disk_and_power_off_passes_exceptions(self):\n        instance = db.instance_create(self.context, self.instance_values)\n        xenapi_fake.create_vm(instance.name, 'Running')\n        instance_type = db.instance_type_get_by_name(self.context, 'm1.large')\n\n        def fake_raise(*args, **kwargs):\n            raise exception.MigrationError(reason='test failure')\n        self.stubs.Set(vmops.VMOps, \"_migrate_vhd\", fake_raise)\n\n        conn = xenapi_conn.XenAPIDriver(False)\n        self.assertRaises(exception.MigrationError,\n                          conn.migrate_disk_and_power_off,\n                          self.context, instance,\n                          '127.0.0.1', instance_type, None)\n\n    def test_revert_migrate(self):\n        instance = db.instance_create(self.context, self.instance_values)\n        self.called = False\n        self.fake_vm_start_called = False\n        self.fake_finish_revert_migration_called = False\n\n        def fake_vm_start(*args, **kwargs):\n            self.fake_vm_start_called = True\n\n        def fake_vdi_resize(*args, **kwargs):\n            self.called = True\n\n        def fake_finish_revert_migration(*args, **kwargs):\n            self.fake_finish_revert_migration_called = True\n\n        self.stubs.Set(stubs.FakeSessionForVMTests,\n                       \"VDI_resize_online\", fake_vdi_resize)\n        self.stubs.Set(vmops.VMOps, '_start', fake_vm_start)\n        self.stubs.Set(vmops.VMOps, 'finish_revert_migration',\n                       fake_finish_revert_migration)\n        stubs.stubout_session(self.stubs, stubs.FakeSessionForVMTests,\n                              product_version=(4, 0, 0),\n                              product_brand='XenServer')\n\n        conn = xenapi_conn.XenAPIDriver(False)\n        network_info = fake_network.fake_get_instance_nw_info(self.stubs,\n                                                              spectacular=True)\n        image_meta = {'id': instance.image_ref, 'disk_format': 'vhd'}\n        base = xenapi_fake.create_vdi('hurr', 'fake')\n        base_uuid = xenapi_fake.get_record('VDI', base)['uuid']\n        cow = xenapi_fake.create_vdi('durr', 'fake')\n        cow_uuid = xenapi_fake.get_record('VDI', cow)['uuid']\n        conn.finish_migration(self.context, self.migration, instance,\n                              dict(base_copy=base_uuid, cow=cow_uuid),\n                              network_info, image_meta, resize_instance=True)\n        self.assertEqual(self.called, True)\n        self.assertEqual(self.fake_vm_start_called, True)\n\n        conn.finish_revert_migration(instance, network_info)\n        self.assertEqual(self.fake_finish_revert_migration_called, True)\n\n    def test_finish_migrate(self):\n        instance = db.instance_create(self.context, self.instance_values)\n        self.called = False\n        self.fake_vm_start_called = False\n\n        def fake_vm_start(*args, **kwargs):\n            self.fake_vm_start_called = True\n\n        def fake_vdi_resize(*args, **kwargs):\n            self.called = True\n\n        self.stubs.Set(vmops.VMOps, '_start', fake_vm_start)\n        self.stubs.Set(stubs.FakeSessionForVMTests,\n                       \"VDI_resize_online\", fake_vdi_resize)\n        stubs.stubout_session(self.stubs, stubs.FakeSessionForVMTests,\n                              product_version=(4, 0, 0),\n                              product_brand='XenServer')\n\n        conn = xenapi_conn.XenAPIDriver(False)\n        network_info = fake_network.fake_get_instance_nw_info(self.stubs,\n                                                              spectacular=True)\n        image_meta = {'id': instance.image_ref, 'disk_format': 'vhd'}\n        conn.finish_migration(self.context, self.migration, instance,\n                              dict(base_copy='hurr', cow='durr'),\n                              network_info, image_meta, resize_instance=True)\n        self.assertEqual(self.called, True)\n        self.assertEqual(self.fake_vm_start_called, True)\n\n    def test_finish_migrate_no_local_storage(self):\n        tiny_type = instance_types.get_instance_type_by_name('m1.tiny')\n        tiny_type_id = tiny_type['id']\n        self.instance_values.update({'instance_type_id': tiny_type_id,\n                                     'root_gb': 0})\n        instance = db.instance_create(self.context, self.instance_values)\n\n        def fake_vdi_resize(*args, **kwargs):\n            raise Exception(\"This shouldn't be called\")\n\n        self.stubs.Set(stubs.FakeSessionForVMTests,\n                       \"VDI_resize_online\", fake_vdi_resize)\n        conn = xenapi_conn.XenAPIDriver(False)\n        network_info = fake_network.fake_get_instance_nw_info(self.stubs,\n                                                              spectacular=True)\n        image_meta = {'id': instance.image_ref, 'disk_format': 'vhd'}\n        conn.finish_migration(self.context, self.migration, instance,\n                              dict(base_copy='hurr', cow='durr'),\n                              network_info, image_meta, resize_instance=True)\n\n    def test_finish_migrate_no_resize_vdi(self):\n        instance = db.instance_create(self.context, self.instance_values)\n\n        def fake_vdi_resize(*args, **kwargs):\n            raise Exception(\"This shouldn't be called\")\n\n        self.stubs.Set(stubs.FakeSessionForVMTests,\n                       \"VDI_resize_online\", fake_vdi_resize)\n        conn = xenapi_conn.XenAPIDriver(False)\n        network_info = fake_network.fake_get_instance_nw_info(self.stubs,\n                                                              spectacular=True)\n        # Resize instance would be determined by the compute call\n        image_meta = {'id': instance.image_ref, 'disk_format': 'vhd'}\n        conn.finish_migration(self.context, self.migration, instance,\n                              dict(base_copy='hurr', cow='durr'),\n                              network_info, image_meta, resize_instance=False)\n\n\nclass XenAPIImageTypeTestCase(test.TestCase):\n    \"\"\"Test ImageType class.\"\"\"\n\n    def test_to_string(self):\n        \"\"\"Can convert from type id to type string.\"\"\"\n        self.assertEquals(\n            vm_utils.ImageType.to_string(vm_utils.ImageType.KERNEL),\n            vm_utils.ImageType.KERNEL_STR)\n\n    def test_from_string(self):\n        \"\"\"Can convert from string to type id.\"\"\"\n        self.assertEquals(\n            vm_utils.ImageType.from_string(vm_utils.ImageType.KERNEL_STR),\n            vm_utils.ImageType.KERNEL)\n\n\nclass XenAPIDetermineDiskImageTestCase(test.TestCase):\n    \"\"\"Unit tests for code that detects the ImageType.\"\"\"\n    def assert_disk_type(self, image_meta, expected_disk_type):\n        actual = vm_utils.determine_disk_image_type(image_meta)\n        self.assertEqual(expected_disk_type, actual)\n\n    def test_machine(self):\n        image_meta = {'id': 'a', 'disk_format': 'ami'}\n        self.assert_disk_type(image_meta, vm_utils.ImageType.DISK)\n\n    def test_raw(self):\n        image_meta = {'id': 'a', 'disk_format': 'raw'}\n        self.assert_disk_type(image_meta, vm_utils.ImageType.DISK_RAW)\n\n    def test_vhd(self):\n        image_meta = {'id': 'a', 'disk_format': 'vhd'}\n        self.assert_disk_type(image_meta, vm_utils.ImageType.DISK_VHD)\n\n\nclass CompareVersionTestCase(test.TestCase):\n    def test_less_than(self):\n        \"\"\"Test that cmp_version compares a as less than b\"\"\"\n        self.assertTrue(vmops.cmp_version('1.2.3.4', '1.2.3.5') < 0)\n\n    def test_greater_than(self):\n        \"\"\"Test that cmp_version compares a as greater than b\"\"\"\n        self.assertTrue(vmops.cmp_version('1.2.3.5', '1.2.3.4') > 0)\n\n    def test_equal(self):\n        \"\"\"Test that cmp_version compares a as equal to b\"\"\"\n        self.assertTrue(vmops.cmp_version('1.2.3.4', '1.2.3.4') == 0)\n\n    def test_non_lexical(self):\n        \"\"\"Test that cmp_version compares non-lexically\"\"\"\n        self.assertTrue(vmops.cmp_version('1.2.3.10', '1.2.3.4') > 0)\n\n    def test_length(self):\n        \"\"\"Test that cmp_version compares by length as last resort\"\"\"\n        self.assertTrue(vmops.cmp_version('1.2.3', '1.2.3.4') < 0)\n\n\nclass XenAPIHostTestCase(stubs.XenAPITestBase):\n    \"\"\"Tests HostState, which holds metrics from XenServer that get\n    reported back to the Schedulers.\"\"\"\n\n    def setUp(self):\n        super(XenAPIHostTestCase, self).setUp()\n        self.flags(xenapi_connection_url='test_url',\n                   xenapi_connection_password='test_pass')\n        stubs.stubout_session(self.stubs, stubs.FakeSessionForVMTests)\n        xenapi_fake.create_local_srs()\n        self.conn = xenapi_conn.XenAPIDriver(False)\n\n    def test_host_state(self):\n        stats = self.conn.get_host_stats()\n        self.assertEquals(stats['disk_total'], 10000)\n        self.assertEquals(stats['disk_used'], 20000)\n        self.assertEquals(stats['host_memory_total'], 10)\n        self.assertEquals(stats['host_memory_overhead'], 20)\n        self.assertEquals(stats['host_memory_free'], 30)\n        self.assertEquals(stats['host_memory_free_computed'], 40)\n\n    def _test_host_action(self, method, action, expected=None):\n        result = method('host', action)\n        if not expected:\n            expected = action\n        self.assertEqual(result, expected)\n\n    def test_host_reboot(self):\n        self._test_host_action(self.conn.host_power_action, 'reboot')\n\n    def test_host_shutdown(self):\n        self._test_host_action(self.conn.host_power_action, 'shutdown')\n\n    def test_host_startup(self):\n        self.assertRaises(NotImplementedError,\n                          self.conn.host_power_action, 'host', 'startup')\n\n    def test_host_maintenance_on(self):\n        self._test_host_action(self.conn.host_maintenance_mode,\n                               True, 'on_maintenance')\n\n    def test_host_maintenance_off(self):\n        self._test_host_action(self.conn.host_maintenance_mode,\n                               False, 'off_maintenance')\n\n    def test_set_enable_host_enable(self):\n        self._test_host_action(self.conn.set_host_enabled, True, 'enabled')\n\n    def test_set_enable_host_disable(self):\n        self._test_host_action(self.conn.set_host_enabled, False, 'disabled')\n\n    def test_get_host_uptime(self):\n        result = self.conn.get_host_uptime('host')\n        self.assertEqual(result, 'fake uptime')\n\n\nclass XenAPIAutoDiskConfigTestCase(stubs.XenAPITestBase):\n    def setUp(self):\n        super(XenAPIAutoDiskConfigTestCase, self).setUp()\n        self.flags(xenapi_connection_url='test_url',\n                   xenapi_connection_password='test_pass',\n                   firewall_driver='nova.virt.xenapi.firewall.'\n                                   'Dom0IptablesFirewallDriver')\n        stubs.stubout_session(self.stubs, stubs.FakeSessionForVMTests)\n        self.conn = xenapi_conn.XenAPIDriver(False)\n\n        self.user_id = 'fake'\n        self.project_id = 'fake'\n\n        self.instance_values = {'id': 1,\n                  'project_id': self.project_id,\n                  'user_id': self.user_id,\n                  'image_ref': 1,\n                  'kernel_id': 2,\n                  'ramdisk_id': 3,\n                  'root_gb': 20,\n                  'instance_type_id': '3',  # m1.large\n                  'os_type': 'linux',\n                  'architecture': 'x86-64'}\n\n        self.context = context.RequestContext(self.user_id, self.project_id)\n\n        def fake_create_vbd(session, vm_ref, vdi_ref, userdevice,\n                            vbd_type='disk', read_only=False, bootable=True):\n            pass\n\n        self.stubs.Set(vm_utils, 'create_vbd', fake_create_vbd)\n\n    def assertIsPartitionCalled(self, called):\n        marker = {\"partition_called\": False}\n\n        def fake_resize_part_and_fs(dev, start, old, new):\n            marker[\"partition_called\"] = True\n        self.stubs.Set(vm_utils, \"_resize_part_and_fs\",\n                       fake_resize_part_and_fs)\n\n        ctx = context.RequestContext(self.user_id, self.project_id)\n        session = xenapi_conn.XenAPISession('test_url', 'root', 'test_pass')\n\n        disk_image_type = vm_utils.ImageType.DISK_VHD\n        instance = db.instance_create(self.context, self.instance_values)\n        vm_ref = xenapi_fake.create_vm(instance['name'], 'Halted')\n        vdi_ref = xenapi_fake.create_vdi(instance['name'], 'fake')\n\n        vdi_uuid = session.call_xenapi('VDI.get_record', vdi_ref)['uuid']\n        vdis = {'root': {'uuid': vdi_uuid, 'ref': vdi_ref}}\n\n        self.conn._vmops._attach_disks(instance, vm_ref, instance['name'],\n                                       disk_image_type, vdis)\n\n        self.assertEqual(marker[\"partition_called\"], called)\n\n    def test_instance_not_auto_disk_config(self):\n        \"\"\"Should not partition unless instance is marked as\n        auto_disk_config.\n        \"\"\"\n        self.instance_values['auto_disk_config'] = False\n        self.assertIsPartitionCalled(False)\n\n    @stub_vm_utils_with_vdi_attached_here\n    def test_instance_auto_disk_config_doesnt_pass_fail_safes(self):\n        \"\"\"Should not partition unless fail safes pass\"\"\"\n        self.instance_values['auto_disk_config'] = True\n\n        def fake_get_partitions(dev):\n            return [(1, 0, 100, 'ext4'), (2, 100, 200, 'ext4')]\n        self.stubs.Set(vm_utils, \"_get_partitions\",\n                       fake_get_partitions)\n\n        self.assertIsPartitionCalled(False)\n\n    @stub_vm_utils_with_vdi_attached_here\n    def test_instance_auto_disk_config_passes_fail_safes(self):\n        \"\"\"Should partition if instance is marked as auto_disk_config=True and\n        virt-layer specific fail-safe checks pass.\n        \"\"\"\n        self.instance_values['auto_disk_config'] = True\n\n        def fake_get_partitions(dev):\n            return [(1, 0, 100, 'ext4')]\n        self.stubs.Set(vm_utils, \"_get_partitions\",\n                       fake_get_partitions)\n\n        self.assertIsPartitionCalled(True)\n\n\nclass XenAPIGenerateLocal(stubs.XenAPITestBase):\n    \"\"\"Test generating of local disks, like swap and ephemeral\"\"\"\n    def setUp(self):\n        super(XenAPIGenerateLocal, self).setUp()\n        self.flags(xenapi_connection_url='test_url',\n                   xenapi_connection_password='test_pass',\n                   xenapi_generate_swap=True,\n                   firewall_driver='nova.virt.xenapi.firewall.'\n                                   'Dom0IptablesFirewallDriver')\n        stubs.stubout_session(self.stubs, stubs.FakeSessionForVMTests)\n        db_fakes.stub_out_db_instance_api(self.stubs)\n        self.conn = xenapi_conn.XenAPIDriver(False)\n\n        self.user_id = 'fake'\n        self.project_id = 'fake'\n\n        self.instance_values = {'id': 1,\n                  'project_id': self.project_id,\n                  'user_id': self.user_id,\n                  'image_ref': 1,\n                  'kernel_id': 2,\n                  'ramdisk_id': 3,\n                  'root_gb': 20,\n                  'instance_type_id': '3',  # m1.large\n                  'os_type': 'linux',\n                  'architecture': 'x86-64'}\n\n        self.context = context.RequestContext(self.user_id, self.project_id)\n\n        def fake_create_vbd(session, vm_ref, vdi_ref, userdevice,\n                            vbd_type='disk', read_only=False, bootable=True):\n            pass\n\n        self.stubs.Set(vm_utils, 'create_vbd', fake_create_vbd)\n\n    def assertCalled(self, instance):\n        ctx = context.RequestContext(self.user_id, self.project_id)\n        session = xenapi_conn.XenAPISession('test_url', 'root', 'test_pass')\n\n        disk_image_type = vm_utils.ImageType.DISK_VHD\n        vm_ref = xenapi_fake.create_vm(instance['name'], 'Halted')\n        vdi_ref = xenapi_fake.create_vdi(instance['name'], 'fake')\n\n        vdi_uuid = session.call_xenapi('VDI.get_record', vdi_ref)['uuid']\n        vdis = {'root': {'uuid': vdi_uuid, 'ref': vdi_ref}}\n\n        self.called = False\n        self.conn._vmops._attach_disks(instance, vm_ref, instance['name'],\n                                       disk_image_type, vdis)\n        self.assertTrue(self.called)\n\n    def test_generate_swap(self):\n        \"\"\"Test swap disk generation.\"\"\"\n        instance = db.instance_create(self.context, self.instance_values)\n        instance = db.instance_update(self.context, instance['uuid'],\n                                      {'instance_type_id': 5})\n\n        def fake_generate_swap(*args, **kwargs):\n            self.called = True\n        self.stubs.Set(vm_utils, 'generate_swap', fake_generate_swap)\n\n        self.assertCalled(instance)\n\n    def test_generate_ephemeral(self):\n        \"\"\"Test ephemeral disk generation.\"\"\"\n        instance = db.instance_create(self.context, self.instance_values)\n        instance = db.instance_update(self.context, instance['uuid'],\n                                      {'instance_type_id': 4})\n\n        def fake_generate_ephemeral(*args):\n            self.called = True\n        self.stubs.Set(vm_utils, 'generate_ephemeral', fake_generate_ephemeral)\n\n        self.assertCalled(instance)\n\n\nclass XenAPIBWUsageTestCase(stubs.XenAPITestBase):\n    def setUp(self):\n        super(XenAPIBWUsageTestCase, self).setUp()\n        self.stubs.Set(vm_utils, 'compile_metrics',\n                       XenAPIBWUsageTestCase._fake_compile_metrics)\n        self.flags(xenapi_connection_url='test_url',\n                   xenapi_connection_password='test_pass',\n                   firewall_driver='nova.virt.xenapi.firewall.'\n                                   'Dom0IptablesFirewallDriver')\n        stubs.stubout_session(self.stubs, stubs.FakeSessionForVMTests)\n        self.conn = xenapi_conn.XenAPIDriver(False)\n\n    @classmethod\n    def _fake_compile_metrics(cls, start_time, stop_time=None):\n        raise exception.CouldNotFetchMetrics()\n\n    def test_get_all_bw_usage_in_failure_case(self):\n        \"\"\"Test that get_all_bw_usage returns an empty list when metrics\n        compilation failed.  c.f. bug #910045.\n        \"\"\"\n        class testinstance(object):\n            def __init__(self):\n                self.name = \"instance-0001\"\n                self.uuid = \"1-2-3-4-5\"\n\n        result = self.conn.get_all_bw_usage([testinstance()],\n                                            timeutils.utcnow())\n        self.assertEqual(result, [])\n\n\n# TODO(salvatore-orlando): this class and\n# nova.tests.test_libvirt.IPTablesFirewallDriverTestCase share a lot of code.\n# Consider abstracting common code in a base class for firewall driver testing.\nclass XenAPIDom0IptablesFirewallTestCase(stubs.XenAPITestBase):\n\n    _in_nat_rules = [\n      '# Generated by iptables-save v1.4.10 on Sat Feb 19 00:03:19 2011',\n      '*nat',\n      ':PREROUTING ACCEPT [1170:189210]',\n      ':INPUT ACCEPT [844:71028]',\n      ':OUTPUT ACCEPT [5149:405186]',\n      ':POSTROUTING ACCEPT [5063:386098]',\n    ]\n\n    _in_filter_rules = [\n      '# Generated by iptables-save v1.4.4 on Mon Dec  6 11:54:13 2010',\n      '*filter',\n      ':INPUT ACCEPT [969615:281627771]',\n      ':FORWARD ACCEPT [0:0]',\n      ':OUTPUT ACCEPT [915599:63811649]',\n      ':nova-block-ipv4 - [0:0]',\n      '-A INPUT -i virbr0 -p tcp -m tcp --dport 67 -j ACCEPT ',\n      '-A FORWARD -d 192.168.122.0/24 -o virbr0 -m state --state RELATED'\n      ',ESTABLISHED -j ACCEPT ',\n      '-A FORWARD -s 192.168.122.0/24 -i virbr0 -j ACCEPT ',\n      '-A FORWARD -i virbr0 -o virbr0 -j ACCEPT ',\n      '-A FORWARD -o virbr0 -j REJECT --reject-with icmp-port-unreachable ',\n      '-A FORWARD -i virbr0 -j REJECT --reject-with icmp-port-unreachable ',\n      'COMMIT',\n      '# Completed on Mon Dec  6 11:54:13 2010',\n    ]\n\n    _in6_filter_rules = [\n      '# Generated by ip6tables-save v1.4.4 on Tue Jan 18 23:47:56 2011',\n      '*filter',\n      ':INPUT ACCEPT [349155:75810423]',\n      ':FORWARD ACCEPT [0:0]',\n      ':OUTPUT ACCEPT [349256:75777230]',\n      'COMMIT',\n      '# Completed on Tue Jan 18 23:47:56 2011',\n    ]\n\n    def setUp(self):\n        super(XenAPIDom0IptablesFirewallTestCase, self).setUp()\n        self.flags(xenapi_connection_url='test_url',\n                   xenapi_connection_password='test_pass',\n                   instance_name_template='%d',\n                   firewall_driver='nova.virt.xenapi.firewall.'\n                                   'Dom0IptablesFirewallDriver')\n        xenapi_fake.create_local_srs()\n        xenapi_fake.create_local_pifs()\n        self.user_id = 'mappin'\n        self.project_id = 'fake'\n        stubs.stubout_session(self.stubs, stubs.FakeSessionForFirewallTests,\n                              test_case=self)\n        self.context = context.RequestContext(self.user_id, self.project_id)\n        self.network = importutils.import_object(FLAGS.network_manager)\n        self.conn = xenapi_conn.XenAPIDriver(False)\n        self.fw = self.conn._vmops.firewall_driver\n\n    def _create_instance_ref(self):\n        return db.instance_create(self.context,\n                                  {'user_id': self.user_id,\n                                   'project_id': self.project_id,\n                                   'instance_type_id': 1})\n\n    def _create_test_security_group(self):\n        admin_ctxt = context.get_admin_context()\n        secgroup = db.security_group_create(admin_ctxt,\n                                {'user_id': self.user_id,\n                                 'project_id': self.project_id,\n                                 'name': 'testgroup',\n                                 'description': 'test group'})\n        db.security_group_rule_create(admin_ctxt,\n                                      {'parent_group_id': secgroup['id'],\n                                       'protocol': 'icmp',\n                                       'from_port': -1,\n                                       'to_port': -1,\n                                       'cidr': '192.168.11.0/24'})\n\n        db.security_group_rule_create(admin_ctxt,\n                                      {'parent_group_id': secgroup['id'],\n                                       'protocol': 'icmp',\n                                       'from_port': 8,\n                                       'to_port': -1,\n                                       'cidr': '192.168.11.0/24'})\n\n        db.security_group_rule_create(admin_ctxt,\n                                      {'parent_group_id': secgroup['id'],\n                                       'protocol': 'tcp',\n                                       'from_port': 80,\n                                       'to_port': 81,\n                                       'cidr': '192.168.10.0/24'})\n        return secgroup\n\n    def _validate_security_group(self):\n        in_rules = filter(lambda l: not l.startswith('#'),\n                          self._in_filter_rules)\n        for rule in in_rules:\n            if not 'nova' in rule:\n                self.assertTrue(rule in self._out_rules,\n                                'Rule went missing: %s' % rule)\n\n        instance_chain = None\n        for rule in self._out_rules:\n            # This is pretty crude, but it'll do for now\n            # last two octets change\n            if re.search('-d 192.168.[0-9]{1,3}.[0-9]{1,3} -j', rule):\n                instance_chain = rule.split(' ')[-1]\n                break\n        self.assertTrue(instance_chain, \"The instance chain wasn't added\")\n        security_group_chain = None\n        for rule in self._out_rules:\n            # This is pretty crude, but it'll do for now\n            if '-A %s -j' % instance_chain in rule:\n                security_group_chain = rule.split(' ')[-1]\n                break\n        self.assertTrue(security_group_chain,\n                        \"The security group chain wasn't added\")\n\n        regex = re.compile('-A .* -j ACCEPT -p icmp -s 192.168.11.0/24')\n        self.assertTrue(len(filter(regex.match, self._out_rules)) > 0,\n                        \"ICMP acceptance rule wasn't added\")\n\n        regex = re.compile('-A .* -j ACCEPT -p icmp -m icmp --icmp-type 8'\n                           ' -s 192.168.11.0/24')\n        self.assertTrue(len(filter(regex.match, self._out_rules)) > 0,\n                        \"ICMP Echo Request acceptance rule wasn't added\")\n\n        regex = re.compile('-A .* -j ACCEPT -p tcp --dport 80:81'\n                           ' -s 192.168.10.0/24')\n        self.assertTrue(len(filter(regex.match, self._out_rules)) > 0,\n                        \"TCP port 80/81 acceptance rule wasn't added\")\n\n    def test_static_filters(self):\n        instance_ref = self._create_instance_ref()\n        src_instance_ref = self._create_instance_ref()\n        admin_ctxt = context.get_admin_context()\n        secgroup = self._create_test_security_group()\n\n        src_secgroup = db.security_group_create(admin_ctxt,\n                                                {'user_id': self.user_id,\n                                                 'project_id': self.project_id,\n                                                 'name': 'testsourcegroup',\n                                                 'description': 'src group'})\n        db.security_group_rule_create(admin_ctxt,\n                                      {'parent_group_id': secgroup['id'],\n                                       'protocol': 'tcp',\n                                       'from_port': 80,\n                                       'to_port': 81,\n                                       'group_id': src_secgroup['id']})\n\n        db.instance_add_security_group(admin_ctxt, instance_ref['uuid'],\n                                       secgroup['id'])\n        db.instance_add_security_group(admin_ctxt, src_instance_ref['uuid'],\n                                       src_secgroup['id'])\n        instance_ref = db.instance_get(admin_ctxt, instance_ref['id'])\n        src_instance_ref = db.instance_get(admin_ctxt, src_instance_ref['id'])\n\n        network_model = fake_network.fake_get_instance_nw_info(self.stubs,\n                                                      1, spectacular=True)\n\n        fake_network.stub_out_nw_api_get_instance_nw_info(self.stubs,\n                                      lambda *a, **kw: network_model)\n\n        network_info = network_model.legacy()\n        self.fw.prepare_instance_filter(instance_ref, network_info)\n        self.fw.apply_instance_filter(instance_ref, network_info)\n\n        self._validate_security_group()\n        # Extra test for TCP acceptance rules\n        for ip in network_model.fixed_ips():\n            if ip['version'] != 4:\n                continue\n            regex = re.compile('-A .* -j ACCEPT -p tcp'\n                               ' --dport 80:81 -s %s' % ip['address'])\n            self.assertTrue(len(filter(regex.match, self._out_rules)) > 0,\n                            \"TCP port 80/81 acceptance rule wasn't added\")\n\n        db.instance_destroy(admin_ctxt, instance_ref['uuid'])\n\n    def test_filters_for_instance_with_ip_v6(self):\n        self.flags(use_ipv6=True)\n        network_info = fake_network.fake_get_instance_nw_info(self.stubs, 1)\n        rulesv4, rulesv6 = self.fw._filters_for_instance(\"fake\", network_info)\n        self.assertEquals(len(rulesv4), 2)\n        self.assertEquals(len(rulesv6), 1)\n\n    def test_filters_for_instance_without_ip_v6(self):\n        self.flags(use_ipv6=False)\n        network_info = fake_network.fake_get_instance_nw_info(self.stubs, 1)\n        rulesv4, rulesv6 = self.fw._filters_for_instance(\"fake\", network_info)\n        self.assertEquals(len(rulesv4), 2)\n        self.assertEquals(len(rulesv6), 0)\n\n    def test_multinic_iptables(self):\n        ipv4_rules_per_addr = 1\n        ipv4_addr_per_network = 2\n        ipv6_rules_per_addr = 1\n        ipv6_addr_per_network = 1\n        networks_count = 5\n        instance_ref = self._create_instance_ref()\n        _get_instance_nw_info = fake_network.fake_get_instance_nw_info\n        network_info = _get_instance_nw_info(self.stubs,\n                                             networks_count,\n                                             ipv4_addr_per_network)\n        ipv4_len = len(self.fw.iptables.ipv4['filter'].rules)\n        ipv6_len = len(self.fw.iptables.ipv6['filter'].rules)\n        inst_ipv4, inst_ipv6 = self.fw.instance_rules(instance_ref,\n                                                      network_info)\n        self.fw.prepare_instance_filter(instance_ref, network_info)\n        ipv4 = self.fw.iptables.ipv4['filter'].rules\n        ipv6 = self.fw.iptables.ipv6['filter'].rules\n        ipv4_network_rules = len(ipv4) - len(inst_ipv4) - ipv4_len\n        ipv6_network_rules = len(ipv6) - len(inst_ipv6) - ipv6_len\n        self.assertEquals(ipv4_network_rules,\n                  ipv4_rules_per_addr * ipv4_addr_per_network * networks_count)\n        self.assertEquals(ipv6_network_rules,\n                  ipv6_rules_per_addr * ipv6_addr_per_network * networks_count)\n\n    def test_do_refresh_security_group_rules(self):\n        admin_ctxt = context.get_admin_context()\n        instance_ref = self._create_instance_ref()\n        network_info = fake_network.fake_get_instance_nw_info(self.stubs, 1, 1)\n        secgroup = self._create_test_security_group()\n        db.instance_add_security_group(admin_ctxt, instance_ref['uuid'],\n                                       secgroup['id'])\n        self.fw.prepare_instance_filter(instance_ref, network_info)\n        self.fw.instances[instance_ref['id']] = instance_ref\n        self._validate_security_group()\n        # add a rule to the security group\n        db.security_group_rule_create(admin_ctxt,\n                                      {'parent_group_id': secgroup['id'],\n                                       'protocol': 'udp',\n                                       'from_port': 200,\n                                       'to_port': 299,\n                                       'cidr': '192.168.99.0/24'})\n        #validate the extra rule\n        self.fw.refresh_security_group_rules(secgroup)\n        regex = re.compile('-A .* -j ACCEPT -p udp --dport 200:299'\n                           ' -s 192.168.99.0/24')\n        self.assertTrue(len(filter(regex.match, self._out_rules)) > 0,\n                        \"Rules were not updated properly.\"\n                        \"The rule for UDP acceptance is missing\")\n\n    def test_provider_firewall_rules(self):\n        # setup basic instance data\n        instance_ref = self._create_instance_ref()\n        # FRAGILE: as in libvirt tests\n        # peeks at how the firewall names chains\n        chain_name = 'inst-%s' % instance_ref['id']\n\n        network_info = fake_network.fake_get_instance_nw_info(self.stubs, 1, 1)\n        self.fw.prepare_instance_filter(instance_ref, network_info)\n        self.assertTrue('provider' in self.fw.iptables.ipv4['filter'].chains)\n        rules = [rule for rule in self.fw.iptables.ipv4['filter'].rules\n                      if rule.chain == 'provider']\n        self.assertEqual(0, len(rules))\n\n        admin_ctxt = context.get_admin_context()\n        # add a rule and send the update message, check for 1 rule\n        provider_fw0 = db.provider_fw_rule_create(admin_ctxt,\n                                                  {'protocol': 'tcp',\n                                                   'cidr': '10.99.99.99/32',\n                                                   'from_port': 1,\n                                                   'to_port': 65535})\n        self.fw.refresh_provider_fw_rules()\n        rules = [rule for rule in self.fw.iptables.ipv4['filter'].rules\n                      if rule.chain == 'provider']\n        self.assertEqual(1, len(rules))\n\n        # Add another, refresh, and make sure number of rules goes to two\n        provider_fw1 = db.provider_fw_rule_create(admin_ctxt,\n                                                  {'protocol': 'udp',\n                                                   'cidr': '10.99.99.99/32',\n                                                   'from_port': 1,\n                                                   'to_port': 65535})\n        self.fw.refresh_provider_fw_rules()\n        rules = [rule for rule in self.fw.iptables.ipv4['filter'].rules\n                      if rule.chain == 'provider']\n        self.assertEqual(2, len(rules))\n\n        # create the instance filter and make sure it has a jump rule\n        self.fw.prepare_instance_filter(instance_ref, network_info)\n        self.fw.apply_instance_filter(instance_ref, network_info)\n        inst_rules = [rule for rule in self.fw.iptables.ipv4['filter'].rules\n                           if rule.chain == chain_name]\n        jump_rules = [rule for rule in inst_rules if '-j' in rule.rule]\n        provjump_rules = []\n        # IptablesTable doesn't make rules unique internally\n        for rule in jump_rules:\n            if 'provider' in rule.rule and rule not in provjump_rules:\n                provjump_rules.append(rule)\n        self.assertEqual(1, len(provjump_rules))\n\n        # remove a rule from the db, cast to compute to refresh rule\n        db.provider_fw_rule_destroy(admin_ctxt, provider_fw1['id'])\n        self.fw.refresh_provider_fw_rules()\n        rules = [rule for rule in self.fw.iptables.ipv4['filter'].rules\n                      if rule.chain == 'provider']\n        self.assertEqual(1, len(rules))\n\n\nclass XenAPISRSelectionTestCase(stubs.XenAPITestBase):\n    \"\"\"Unit tests for testing we find the right SR.\"\"\"\n    def test_safe_find_sr_raise_exception(self):\n        \"\"\"Ensure StorageRepositoryNotFound is raise when wrong filter.\"\"\"\n        self.flags(sr_matching_filter='yadayadayada')\n        stubs.stubout_session(self.stubs, stubs.FakeSessionForVMTests)\n        session = xenapi_conn.XenAPISession('test_url', 'root', 'test_pass')\n        self.assertRaises(exception.StorageRepositoryNotFound,\n                          vm_utils.safe_find_sr, session)\n\n    def test_safe_find_sr_local_storage(self):\n        \"\"\"Ensure the default local-storage is found.\"\"\"\n        self.flags(sr_matching_filter='other-config:i18n-key=local-storage')\n        stubs.stubout_session(self.stubs, stubs.FakeSessionForVMTests)\n        session = xenapi_conn.XenAPISession('test_url', 'root', 'test_pass')\n        host_ref = xenapi_fake.get_all('host')[0]\n        local_sr = xenapi_fake.create_sr(\n                              name_label='Fake Storage',\n                              type='lvm',\n                              other_config={'i18n-original-value-name_label':\n                                            'Local storage',\n                                            'i18n-key': 'local-storage'},\n                              host_ref=host_ref)\n        expected = vm_utils.safe_find_sr(session)\n        self.assertEqual(local_sr, expected)\n\n    def test_safe_find_sr_by_other_criteria(self):\n        \"\"\"Ensure the SR is found when using a different filter.\"\"\"\n        self.flags(sr_matching_filter='other-config:my_fake_sr=true')\n        stubs.stubout_session(self.stubs, stubs.FakeSessionForVMTests)\n        session = xenapi_conn.XenAPISession('test_url', 'root', 'test_pass')\n        host_ref = xenapi_fake.get_all('host')[0]\n        local_sr = xenapi_fake.create_sr(name_label='Fake Storage',\n                                         type='lvm',\n                                         other_config={'my_fake_sr': 'true'},\n                                         host_ref=host_ref)\n        expected = vm_utils.safe_find_sr(session)\n        self.assertEqual(local_sr, expected)\n\n    def test_safe_find_sr_default(self):\n        \"\"\"Ensure the default SR is found regardless of other-config.\"\"\"\n        self.flags(sr_matching_filter='default-sr:true')\n        stubs.stubout_session(self.stubs, stubs.FakeSessionForVMTests)\n        session = xenapi_conn.XenAPISession('test_url', 'root', 'test_pass')\n        pool_ref = xenapi_fake.create_pool('')\n        expected = vm_utils.safe_find_sr(session)\n        self.assertEqual(session.call_xenapi('pool.get_default_SR', pool_ref),\n                         expected)\n\n\ndef _create_service_entries(context, values={'avail_zone1': ['fake_host1',\n                                                         'fake_host2'],\n                                         'avail_zone2': ['fake_host3'], }):\n    for avail_zone, hosts in values.iteritems():\n        for host in hosts:\n            db.service_create(context,\n                              {'host': host,\n                               'binary': 'nova-compute',\n                               'topic': 'compute',\n                               'report_count': 0,\n                               'availability_zone': avail_zone})\n    return values\n\n\nclass XenAPIAggregateTestCase(stubs.XenAPITestBase):\n    \"\"\"Unit tests for aggregate operations.\"\"\"\n    def setUp(self):\n        super(XenAPIAggregateTestCase, self).setUp()\n        self.flags(xenapi_connection_url='http://test_url',\n                   xenapi_connection_username='test_user',\n                   xenapi_connection_password='test_pass',\n                   instance_name_template='%d',\n                   firewall_driver='nova.virt.xenapi.firewall.'\n                                   'Dom0IptablesFirewallDriver',\n                   host='host',\n                   connection_type='xenapi',\n                   compute_driver='nova.virt.xenapi.driver.XenAPIDriver')\n        host_ref = xenapi_fake.get_all('host')[0]\n        stubs.stubout_session(self.stubs, stubs.FakeSessionForVMTests)\n        self.context = context.get_admin_context()\n        self.conn = xenapi_conn.XenAPIDriver(False)\n        self.compute = importutils.import_object(FLAGS.compute_manager)\n        self.api = compute_api.AggregateAPI()\n        values = {'name': 'test_aggr',\n                  'availability_zone': 'test_zone',\n                  'metadata': {pool_states.POOL_FLAG: 'XenAPI'}}\n        self.aggr = db.aggregate_create(self.context, values)\n        self.fake_metadata = {pool_states.POOL_FLAG: 'XenAPI',\n                              'master_compute': 'host',\n                              pool_states.KEY: pool_states.ACTIVE,\n                              'host': xenapi_fake.get_record('host',\n                                                             host_ref)['uuid']}\n\n    def test_add_to_aggregate_called(self):\n        def fake_add_to_aggregate(context, aggregate, host):\n            fake_add_to_aggregate.called = True\n        self.stubs.Set(self.conn._pool,\n                       \"add_to_aggregate\",\n                       fake_add_to_aggregate)\n\n        self.conn.add_to_aggregate(None, None, None)\n        self.assertTrue(fake_add_to_aggregate.called)\n\n    def test_add_to_aggregate_for_first_host_sets_metadata(self):\n        def fake_init_pool(id, name):\n            fake_init_pool.called = True\n        self.stubs.Set(self.conn._pool, \"_init_pool\", fake_init_pool)\n\n        aggregate = self._aggregate_setup()\n        self.conn._pool.add_to_aggregate(self.context, aggregate, \"host\")\n        result = db.aggregate_get(self.context, aggregate.id)\n        self.assertTrue(fake_init_pool.called)\n        self.assertDictMatch(self.fake_metadata, result.metadetails)\n\n    def test_join_slave(self):\n        \"\"\"Ensure join_slave gets called when the request gets to master.\"\"\"\n        def fake_join_slave(id, compute_uuid, host, url, user, password):\n            fake_join_slave.called = True\n        self.stubs.Set(self.conn._pool, \"_join_slave\", fake_join_slave)\n\n        aggregate = self._aggregate_setup(hosts=['host', 'host2'],\n                                          metadata=self.fake_metadata)\n        self.conn._pool.add_to_aggregate(self.context, aggregate, \"host2\",\n                                         compute_uuid='fake_uuid',\n                                         url='fake_url',\n                                         user='fake_user',\n                                         passwd='fake_pass',\n                                         xenhost_uuid='fake_uuid')\n        self.assertTrue(fake_join_slave.called)\n\n    def test_add_to_aggregate_first_host(self):\n        def fake_pool_set_name_label(self, session, pool_ref, name):\n            fake_pool_set_name_label.called = True\n        self.stubs.Set(xenapi_fake.SessionBase, \"pool_set_name_label\",\n                       fake_pool_set_name_label)\n        self.conn._session.call_xenapi(\"pool.create\", {\"name\": \"asdf\"})\n\n        values = {\"name\": 'fake_aggregate',\n                  \"availability_zone\": 'fake_zone'}\n        result = db.aggregate_create(self.context, values)\n        metadata = {pool_states.POOL_FLAG: \"XenAPI\",\n                    pool_states.KEY: pool_states.CREATED}\n        db.aggregate_metadata_add(self.context, result.id, metadata)\n\n        db.aggregate_host_add(self.context, result.id, \"host\")\n        aggregate = db.aggregate_get(self.context, result.id)\n        self.assertEqual([\"host\"], aggregate.hosts)\n        self.assertEqual(metadata, aggregate.metadetails)\n\n        self.conn._pool.add_to_aggregate(self.context, aggregate, \"host\")\n        self.assertTrue(fake_pool_set_name_label.called)\n\n    def test_remove_from_aggregate_called(self):\n        def fake_remove_from_aggregate(context, aggregate, host):\n            fake_remove_from_aggregate.called = True\n        self.stubs.Set(self.conn._pool,\n                       \"remove_from_aggregate\",\n                       fake_remove_from_aggregate)\n\n        self.conn.remove_from_aggregate(None, None, None)\n        self.assertTrue(fake_remove_from_aggregate.called)\n\n    def test_remove_from_empty_aggregate(self):\n        result = self._aggregate_setup()\n        self.assertRaises(exception.InvalidAggregateAction,\n                          self.conn._pool.remove_from_aggregate,\n                          self.context, result, \"test_host\")\n\n    def test_remove_slave(self):\n        \"\"\"Ensure eject slave gets called.\"\"\"\n        def fake_eject_slave(id, compute_uuid, host_uuid):\n            fake_eject_slave.called = True\n        self.stubs.Set(self.conn._pool, \"_eject_slave\", fake_eject_slave)\n\n        self.fake_metadata['host2'] = 'fake_host2_uuid'\n        aggregate = self._aggregate_setup(hosts=['host', 'host2'],\n                metadata=self.fake_metadata, aggr_state=pool_states.ACTIVE)\n        self.conn._pool.remove_from_aggregate(self.context, aggregate, \"host2\")\n        self.assertTrue(fake_eject_slave.called)\n\n    def test_remove_master_solo(self):\n        \"\"\"Ensure metadata are cleared after removal.\"\"\"\n        def fake_clear_pool(id):\n            fake_clear_pool.called = True\n        self.stubs.Set(self.conn._pool, \"_clear_pool\", fake_clear_pool)\n\n        aggregate = self._aggregate_setup(metadata=self.fake_metadata)\n        self.conn._pool.remove_from_aggregate(self.context, aggregate, \"host\")\n        result = db.aggregate_get(self.context, aggregate.id)\n        self.assertTrue(fake_clear_pool.called)\n        self.assertDictMatch({pool_states.POOL_FLAG: 'XenAPI',\n                pool_states.KEY: pool_states.ACTIVE}, result.metadetails)\n\n    def test_remote_master_non_empty_pool(self):\n        \"\"\"Ensure AggregateError is raised if removing the master.\"\"\"\n        aggregate = self._aggregate_setup(hosts=['host', 'host2'],\n                                          metadata=self.fake_metadata)\n\n        self.assertRaises(exception.InvalidAggregateAction,\n                          self.conn._pool.remove_from_aggregate,\n                          self.context, aggregate, \"host\")\n\n    def _aggregate_setup(self, aggr_name='fake_aggregate',\n                         aggr_zone='fake_zone',\n                         aggr_state=pool_states.CREATED,\n                         hosts=['host'], metadata=None):\n        values = {\"name\": aggr_name,\n                  \"availability_zone\": aggr_zone}\n        result = db.aggregate_create(self.context, values)\n        pool_flag = {pool_states.POOL_FLAG: \"XenAPI\",\n                    pool_states.KEY: aggr_state}\n        db.aggregate_metadata_add(self.context, result.id, pool_flag)\n\n        for host in hosts:\n            db.aggregate_host_add(self.context, result.id, host)\n        if metadata:\n            db.aggregate_metadata_add(self.context, result.id, metadata)\n        return db.aggregate_get(self.context, result.id)\n\n    def test_add_host_to_aggregate_invalid_changing_status(self):\n        \"\"\"Ensure InvalidAggregateAction is raised when adding host while\n        aggregate is not ready.\"\"\"\n        aggregate = self._aggregate_setup(aggr_state=pool_states.CHANGING)\n        self.assertRaises(exception.InvalidAggregateAction,\n                          self.conn.add_to_aggregate, self.context,\n                          aggregate, 'host')\n\n    def test_add_host_to_aggregate_invalid_dismissed_status(self):\n        \"\"\"Ensure InvalidAggregateAction is raised when aggregate is\n        deleted.\"\"\"\n        aggregate = self._aggregate_setup(aggr_state=pool_states.DISMISSED)\n        self.assertRaises(exception.InvalidAggregateAction,\n                          self.conn.add_to_aggregate, self.context,\n                          aggregate, 'fake_host')\n\n    def test_add_host_to_aggregate_invalid_error_status(self):\n        \"\"\"Ensure InvalidAggregateAction is raised when aggregate is\n        in error.\"\"\"\n        aggregate = self._aggregate_setup(aggr_state=pool_states.ERROR)\n        self.assertRaises(exception.InvalidAggregateAction,\n                          self.conn.add_to_aggregate, self.context,\n                          aggregate, 'fake_host')\n\n    def test_remove_host_from_aggregate_error(self):\n        \"\"\"Ensure we can remove a host from an aggregate even if in error.\"\"\"\n        values = _create_service_entries(self.context)\n        fake_zone = values.keys()[0]\n        aggr = self.api.create_aggregate(self.context,\n                                         'fake_aggregate', fake_zone)\n        # let's mock the fact that the aggregate is ready!\n        metadata = {pool_states.POOL_FLAG: \"XenAPI\",\n                    pool_states.KEY: pool_states.ACTIVE}\n        db.aggregate_metadata_add(self.context, aggr['id'], metadata)\n        for host in values[fake_zone]:\n            aggr = self.api.add_host_to_aggregate(self.context,\n                                                  aggr['id'], host)\n        # let's mock the fact that the aggregate is in error!\n        status = {'operational_state': pool_states.ERROR}\n        expected = self.api.remove_host_from_aggregate(self.context,\n                                                       aggr['id'],\n                                                       values[fake_zone][0])\n        self.assertEqual(len(aggr['hosts']) - 1, len(expected['hosts']))\n        self.assertEqual(expected['metadata'][pool_states.KEY],\n                         pool_states.ACTIVE)\n\n    def test_remove_host_from_aggregate_invalid_dismissed_status(self):\n        \"\"\"Ensure InvalidAggregateAction is raised when aggregate is\n        deleted.\"\"\"\n        aggregate = self._aggregate_setup(aggr_state=pool_states.DISMISSED)\n        self.assertRaises(exception.InvalidAggregateAction,\n                          self.conn.remove_from_aggregate, self.context,\n                          aggregate, 'fake_host')\n\n    def test_remove_host_from_aggregate_invalid_changing_status(self):\n        \"\"\"Ensure InvalidAggregateAction is raised when aggregate is\n        changing.\"\"\"\n        aggregate = self._aggregate_setup(aggr_state=pool_states.CHANGING)\n        self.assertRaises(exception.InvalidAggregateAction,\n                          self.conn.remove_from_aggregate, self.context,\n                          aggregate, 'fake_host')\n\n    def test_add_aggregate_host_raise_err(self):\n        \"\"\"Ensure the undo operation works correctly on add.\"\"\"\n        def fake_driver_add_to_aggregate(context, aggregate, host):\n            raise exception.AggregateError\n        self.stubs.Set(self.compute.driver, \"add_to_aggregate\",\n                       fake_driver_add_to_aggregate)\n        metadata = {pool_states.POOL_FLAG: \"XenAPI\",\n                    pool_states.KEY: pool_states.ACTIVE}\n        db.aggregate_metadata_add(self.context, self.aggr.id, metadata)\n        db.aggregate_host_add(self.context, self.aggr.id, 'fake_host')\n\n        self.assertRaises(exception.AggregateError,\n                          self.compute.add_aggregate_host,\n                          self.context, self.aggr.id, \"fake_host\")\n        excepted = db.aggregate_get(self.context, self.aggr.id)\n        self.assertEqual(excepted.metadetails[pool_states.KEY],\n                pool_states.ERROR)\n        self.assertEqual(excepted.hosts, [])\n\n\nclass VmUtilsTestCase(test.TestCase):\n    \"\"\"Unit tests for xenapi utils.\"\"\"\n\n    def test_upload_image(self):\n        \"\"\"Ensure image properties include instance system metadata\n           as well as few local settings.\"\"\"\n\n        def fake_instance_system_metadata_get(context, uuid):\n            return dict(image_a=1, image_b=2, image_c='c', d='d')\n\n        def fake_get_sr_path(session):\n            return \"foo\"\n\n        class FakeInstance(dict):\n            def __init__(self):\n                super(FakeInstance, self).__init__({\n                        'auto_disk_config': 'auto disk config',\n                        'os_type': 'os type'})\n\n            def __missing__(self, item):\n                return \"whatever\"\n\n        class FakeSession(object):\n            def call_plugin(session_self, service, command, kwargs):\n                self.kwargs = kwargs\n\n        def fake_dumps(thing):\n            return thing\n\n        self.stubs.Set(db, \"instance_system_metadata_get\",\n                                             fake_instance_system_metadata_get)\n        self.stubs.Set(vm_utils, \"get_sr_path\", fake_get_sr_path)\n        self.stubs.Set(pickle, \"dumps\", fake_dumps)\n\n        ctx = context.get_admin_context()\n\n        instance = FakeInstance()\n        session = FakeSession()\n        vm_utils.upload_image(ctx, session, instance, \"vmi uuids\", \"image id\")\n\n        actual = self.kwargs['params']['properties']\n        expected = dict(a=1, b=2, c='c', d='d',\n                        auto_disk_config='auto disk config',\n                        os_type='os type')\n        self.assertEquals(expected, actual)\n\n\nclass XenAPILiveMigrateTestCase(stubs.XenAPITestBase):\n    \"\"\"Unit tests for live_migration.\"\"\"\n    def setUp(self):\n        super(XenAPILiveMigrateTestCase, self).setUp()\n        self.flags(xenapi_connection_url='test_url',\n                   xenapi_connection_password='test_pass',\n                   firewall_driver='nova.virt.xenapi.firewall.'\n                                   'Dom0IptablesFirewallDriver',\n                   host='host')\n        db_fakes.stub_out_db_instance_api(self.stubs)\n        stubs.stubout_session(self.stubs, stubs.FakeSessionForVMTests)\n        self.context = context.get_admin_context()\n        self.conn = xenapi_conn.XenAPIDriver(False)\n\n    def test_live_migration_calls_vmops(self):\n        def fake_live_migrate(context, instance_ref, dest, post_method,\n                              recover_method, block_migration):\n            fake_live_migrate.called = True\n        self.stubs.Set(self.conn._vmops, \"live_migrate\", fake_live_migrate)\n\n        self.conn.live_migration(None, None, None, None, None)\n        self.assertTrue(fake_live_migrate.called)\n\n    def test_pre_live_migration(self):\n        # ensure method is present\n        self.conn.pre_live_migration(None, None, None, None)\n\n    def test_post_live_migration_at_destination(self):\n        # ensure method is present\n        self.conn.post_live_migration_at_destination(None, None, None, None)\n\n    def test_check_can_live_migrate_raises_on_block_migrate(self):\n        self.assertRaises(NotImplementedError,\n                          self.conn.check_can_live_migrate_destination,\n                          None, None, True, None)\n\n    def test_check_can_live_migrate_works(self):\n        class fake_aggregate:\n            def __init__(self):\n                self.metadetails = {\"host\": \"test_host_uuid\"}\n\n        def fake_aggregate_get_by_host(context, host):\n            self.assertEqual(FLAGS.host, host)\n            return fake_aggregate()\n\n        self.stubs.Set(db, \"aggregate_get_by_host\",\n                fake_aggregate_get_by_host)\n        self.conn.check_can_live_migrate_destination(self.context,\n                {'host': 'host'}, False, False)\n\n    def test_check_can_live_migrate_fails(self):\n        class fake_aggregate:\n            def __init__(self):\n                self.metadetails = {\"dest_other\": \"test_host_uuid\"}\n\n        def fake_aggregate_get_by_host(context, host):\n            self.assertEqual(FLAGS.host, host)\n            return fake_aggregate()\n\n        self.stubs.Set(db, \"aggregate_get_by_host\",\n                      fake_aggregate_get_by_host)\n        self.assertRaises(exception.MigrationError,\n                          self.conn.check_can_live_migrate_destination,\n                          self.context, {'host': 'host'}, None, None)\n\n    def test_live_migration(self):\n        def fake_get_vm_opaque_ref(instance):\n            return \"fake_vm\"\n        self.stubs.Set(self.conn._vmops, \"_get_vm_opaque_ref\",\n                       fake_get_vm_opaque_ref)\n\n        def fake_get_host_opaque_ref(context, destination_hostname):\n            return \"fake_host\"\n        self.stubs.Set(self.conn._vmops, \"_get_host_opaque_ref\",\n                       fake_get_host_opaque_ref)\n\n        def post_method(context, instance, destination_hostname,\n                        block_migration):\n            post_method.called = True\n\n        self.conn.live_migration(self.conn, None, None, post_method, None)\n\n        self.assertTrue(post_method.called, \"post_method.called\")\n\n    def test_live_migration_on_failure(self):\n        def fake_get_vm_opaque_ref(instance):\n            return \"fake_vm\"\n        self.stubs.Set(self.conn._vmops, \"_get_vm_opaque_ref\",\n                       fake_get_vm_opaque_ref)\n\n        def fake_get_host_opaque_ref(context, destination_hostname):\n            return \"fake_host\"\n        self.stubs.Set(self.conn._vmops, \"_get_host_opaque_ref\",\n                       fake_get_host_opaque_ref)\n\n        def fake_call_xenapi(*args):\n            raise NotImplementedError()\n        self.stubs.Set(self.conn._vmops._session, \"call_xenapi\",\n                       fake_call_xenapi)\n\n        def recover_method(context, instance, destination_hostname,\n                        block_migration):\n            recover_method.called = True\n\n        self.assertRaises(NotImplementedError, self.conn.live_migration,\n                          self.conn, None, None, None, recover_method)\n        self.assertTrue(recover_method.called, \"recover_method.called\")\n\n\nclass XenAPIInjectMetadataTestCase(stubs.XenAPITestBase):\n    def setUp(self):\n        super(XenAPIInjectMetadataTestCase, self).setUp()\n        self.flags(xenapi_connection_url='test_url',\n                   xenapi_connection_password='test_pass',\n                   firewall_driver='nova.virt.xenapi.firewall.'\n                                   'Dom0IptablesFirewallDriver')\n        stubs.stubout_session(self.stubs, stubs.FakeSessionForVMTests)\n        self.conn = xenapi_conn.XenAPIDriver(False)\n\n        self.xenstore = dict(persist={}, ephem={})\n\n        def fake_get_vm_opaque_ref(inst, instance):\n            self.assertEqual(instance, 'instance')\n            return 'vm_ref'\n\n        def fake_add_to_param_xenstore(inst, vm_ref, key, val):\n            self.assertEqual(vm_ref, 'vm_ref')\n            self.xenstore['persist'][key] = val\n\n        def fake_remove_from_param_xenstore(inst, vm_ref, key):\n            self.assertEqual(vm_ref, 'vm_ref')\n            if key in self.xenstore['persist']:\n                del self.xenstore['persist'][key]\n\n        def fake_write_to_xenstore(inst, instance, path, value, vm_ref=None):\n            self.assertEqual(instance, 'instance')\n            self.assertEqual(vm_ref, 'vm_ref')\n            self.xenstore['ephem'][path] = jsonutils.dumps(value)\n\n        def fake_delete_from_xenstore(inst, instance, path, vm_ref=None):\n            self.assertEqual(instance, 'instance')\n            self.assertEqual(vm_ref, 'vm_ref')\n            if path in self.xenstore['ephem']:\n                del self.xenstore['ephem'][path]\n\n        self.stubs.Set(vmops.VMOps, '_get_vm_opaque_ref',\n                       fake_get_vm_opaque_ref)\n        self.stubs.Set(vmops.VMOps, '_add_to_param_xenstore',\n                       fake_add_to_param_xenstore)\n        self.stubs.Set(vmops.VMOps, '_remove_from_param_xenstore',\n                       fake_remove_from_param_xenstore)\n        self.stubs.Set(vmops.VMOps, '_write_to_xenstore',\n                       fake_write_to_xenstore)\n        self.stubs.Set(vmops.VMOps, '_delete_from_xenstore',\n                       fake_delete_from_xenstore)\n\n    def test_inject_instance_metadata(self):\n\n        # Add some system_metadata to ensure it doesn't get added\n        # to xenstore\n        instance = dict(metadata=[{'key': 'a', 'value': 1},\n                                  {'key': 'b', 'value': 2},\n                                  {'key': 'c', 'value': 3},\n                                  # Check xenstore key sanitizing\n                                  {'key': 'hi.there', 'value': 4},\n                                  {'key': 'hi!t.e/e', 'value': 5}],\n                                  # Check xenstore key sanitizing\n                        system_metadata=[{'key': 'sys_a', 'value': 1},\n                                         {'key': 'sys_b', 'value': 2},\n                                         {'key': 'sys_c', 'value': 3}])\n        self.conn._vmops.inject_instance_metadata(instance, 'vm_ref')\n\n        self.assertEqual(self.xenstore, {\n                'persist': {\n                    'vm-data/user-metadata/a': '1',\n                    'vm-data/user-metadata/b': '2',\n                    'vm-data/user-metadata/c': '3',\n                    'vm-data/user-metadata/hi_there': '4',\n                    'vm-data/user-metadata/hi_t_e_e': '5',\n                    },\n                'ephem': {},\n                })\n\n    def test_change_instance_metadata_add(self):\n        # Test XenStore key sanitizing here, too.\n        diff = {'test.key': ['+', 4]}\n        self.xenstore = {\n            'persist': {\n                'vm-data/user-metadata/a': '1',\n                'vm-data/user-metadata/b': '2',\n                'vm-data/user-metadata/c': '3',\n                },\n            'ephem': {\n                'vm-data/user-metadata/a': '1',\n                'vm-data/user-metadata/b': '2',\n                'vm-data/user-metadata/c': '3',\n                },\n            }\n\n        self.conn._vmops.change_instance_metadata('instance', diff)\n\n        self.assertEqual(self.xenstore, {\n                'persist': {\n                    'vm-data/user-metadata/a': '1',\n                    'vm-data/user-metadata/b': '2',\n                    'vm-data/user-metadata/c': '3',\n                    'vm-data/user-metadata/test_key': '4',\n                    },\n                'ephem': {\n                    'vm-data/user-metadata/a': '1',\n                    'vm-data/user-metadata/b': '2',\n                    'vm-data/user-metadata/c': '3',\n                    'vm-data/user-metadata/test_key': '4',\n                    },\n                })\n\n    def test_change_instance_metadata_update(self):\n        diff = dict(b=['+', 4])\n        self.xenstore = {\n            'persist': {\n                'vm-data/user-metadata/a': '1',\n                'vm-data/user-metadata/b': '2',\n                'vm-data/user-metadata/c': '3',\n                },\n            'ephem': {\n                'vm-data/user-metadata/a': '1',\n                'vm-data/user-metadata/b': '2',\n                'vm-data/user-metadata/c': '3',\n                },\n            }\n\n        self.conn._vmops.change_instance_metadata('instance', diff)\n\n        self.assertEqual(self.xenstore, {\n                'persist': {\n                    'vm-data/user-metadata/a': '1',\n                    'vm-data/user-metadata/b': '4',\n                    'vm-data/user-metadata/c': '3',\n                    },\n                'ephem': {\n                    'vm-data/user-metadata/a': '1',\n                    'vm-data/user-metadata/b': '4',\n                    'vm-data/user-metadata/c': '3',\n                    },\n                })\n\n    def test_change_instance_metadata_delete(self):\n        diff = dict(b=['-'])\n        self.xenstore = {\n            'persist': {\n                'vm-data/user-metadata/a': '1',\n                'vm-data/user-metadata/b': '2',\n                'vm-data/user-metadata/c': '3',\n                },\n            'ephem': {\n                'vm-data/user-metadata/a': '1',\n                'vm-data/user-metadata/b': '2',\n                'vm-data/user-metadata/c': '3',\n                },\n            }\n\n        self.conn._vmops.change_instance_metadata('instance', diff)\n\n        self.assertEqual(self.xenstore, {\n                'persist': {\n                    'vm-data/user-metadata/a': '1',\n                    'vm-data/user-metadata/c': '3',\n                    },\n                'ephem': {\n                    'vm-data/user-metadata/a': '1',\n                    'vm-data/user-metadata/c': '3',\n                    },\n                })\n", "# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2010 United States Government as represented by the\n# Administrator of the National Aeronautics and Space Administration.\n#\n# Copyright 2011, Piston Cloud Computing, Inc.\n#\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\"\"\"\nUtility methods to resize, repartition, and modify disk images.\n\nIncludes injection of SSH PGP keys into authorized_keys file.\n\n\"\"\"\n\nimport crypt\nimport os\nimport random\nimport tempfile\n\nfrom nova import exception\nfrom nova import flags\nfrom nova.openstack.common import cfg\nfrom nova.openstack.common import jsonutils\nfrom nova.openstack.common import log as logging\nfrom nova import utils\nfrom nova.virt.disk import guestfs\nfrom nova.virt.disk import loop\nfrom nova.virt.disk import nbd\nfrom nova.virt import images\n\n\nLOG = logging.getLogger(__name__)\n\ndisk_opts = [\n    cfg.StrOpt('injected_network_template',\n               default='$pybasedir/nova/virt/interfaces.template',\n               help='Template file for injected network'),\n    cfg.ListOpt('img_handlers',\n                default=['loop', 'nbd', 'guestfs'],\n                help='Order of methods used to mount disk images'),\n\n    # NOTE(yamahata): ListOpt won't work because the command may include a\n    #                 comma. For example:\n    #\n    #                 mkfs.ext3 -O dir_index,extent -E stride=8,stripe-width=16\n    #                           --label %(fs_label)s %(target)s\n    #\n    #                 list arguments are comma separated and there is no way to\n    #                 escape such commas.\n    #\n    cfg.MultiStrOpt('virt_mkfs',\n                    default=[\n                      'default=mkfs.ext3 -L %(fs_label)s -F %(target)s',\n                      'linux=mkfs.ext3 -L %(fs_label)s -F %(target)s',\n                      'windows=mkfs.ntfs'\n                      ' --force --fast --label %(fs_label)s %(target)s',\n                      # NOTE(yamahata): vfat case\n                      #'windows=mkfs.vfat -n %(fs_label)s %(target)s',\n                      ],\n                    help='mkfs commands for ephemeral device. '\n                         'The format is <os_type>=<mkfs command>'),\n    ]\n\nFLAGS = flags.FLAGS\nFLAGS.register_opts(disk_opts)\n\n_MKFS_COMMAND = {}\n_DEFAULT_MKFS_COMMAND = None\n\n\nfor s in FLAGS.virt_mkfs:\n    # NOTE(yamahata): mkfs command may includes '=' for its options.\n    #                 So item.partition('=') doesn't work here\n    os_type, mkfs_command = s.split('=', 1)\n    if os_type:\n        _MKFS_COMMAND[os_type] = mkfs_command\n    if os_type == 'default':\n        _DEFAULT_MKFS_COMMAND = mkfs_command\n\n\ndef mkfs(os_type, fs_label, target):\n    mkfs_command = (_MKFS_COMMAND.get(os_type, _DEFAULT_MKFS_COMMAND) or\n                    '') % locals()\n    if mkfs_command:\n        utils.execute(*mkfs_command.split())\n\n\ndef resize2fs(image, check_exit_code=False):\n    utils.execute('e2fsck', '-fp', image, check_exit_code=check_exit_code)\n    utils.execute('resize2fs', image, check_exit_code=check_exit_code)\n\n\ndef get_disk_size(path):\n    \"\"\"Get the (virtual) size of a disk image\n\n    :param path: Path to the disk image\n    :returns: Size (in bytes) of the given disk image as it would be seen\n              by a virtual machine.\n    \"\"\"\n    size = images.qemu_img_info(path)['virtual size']\n    size = size.split('(')[1].split()[0]\n    return int(size)\n\n\ndef extend(image, size):\n    \"\"\"Increase image to size\"\"\"\n    virt_size = get_disk_size(image)\n    if virt_size >= size:\n        return\n    utils.execute('qemu-img', 'resize', image, size)\n    # NOTE(vish): attempts to resize filesystem\n    resize2fs(image)\n\n\ndef can_resize_fs(image, size, use_cow=False):\n    \"\"\"Check whether we can resize contained file system.\"\"\"\n\n    # Check that we're increasing the size\n    virt_size = get_disk_size(image)\n    if virt_size >= size:\n        return False\n\n    # Check the image is unpartitioned\n    if use_cow:\n        # Try to mount an unpartitioned qcow2 image\n        try:\n            inject_data(image, use_cow=True)\n        except exception.NovaException:\n            return False\n    else:\n        # For raw, we can directly inspect the file system\n        try:\n            utils.execute('e2label', image)\n        except exception.ProcessExecutionError:\n            return False\n\n    return True\n\n\ndef bind(src, target, instance_name):\n    \"\"\"Bind device to a filesytem\"\"\"\n    if src:\n        utils.execute('touch', target, run_as_root=True)\n        utils.execute('mount', '-o', 'bind', src, target,\n                run_as_root=True)\n        s = os.stat(src)\n        cgroup_info = \"b %s:%s rwm\\n\" % (os.major(s.st_rdev),\n                                         os.minor(s.st_rdev))\n        cgroups_path = (\"/sys/fs/cgroup/devices/libvirt/lxc/\"\n                        \"%s/devices.allow\" % instance_name)\n        utils.execute('tee', cgroups_path,\n                      process_input=cgroup_info, run_as_root=True)\n\n\ndef unbind(target):\n    if target:\n        utils.execute('umount', target, run_as_root=True)\n\n\nclass _DiskImage(object):\n    \"\"\"Provide operations on a disk image file.\"\"\"\n\n    tmp_prefix = 'openstack-disk-mount-tmp'\n\n    def __init__(self, image, partition=None, use_cow=False, mount_dir=None):\n        # These passed to each mounter\n        self.image = image\n        self.partition = partition\n        self.mount_dir = mount_dir\n\n        # Internal\n        self._mkdir = False\n        self._mounter = None\n        self._errors = []\n\n        # As a performance tweak, don't bother trying to\n        # directly loopback mount a cow image.\n        self.handlers = FLAGS.img_handlers[:]\n        if use_cow and 'loop' in self.handlers:\n            self.handlers.remove('loop')\n\n        if not self.handlers:\n            msg = _('no capable image handler configured')\n            raise exception.NovaException(msg)\n\n        if mount_dir:\n            # Note the os.path.ismount() shortcut doesn't\n            # work with libguestfs due to permissions issues.\n            device = self._device_for_path(mount_dir)\n            if device:\n                self._reset(device)\n\n    @staticmethod\n    def _device_for_path(path):\n        device = None\n        with open(\"/proc/mounts\", 'r') as ifp:\n            for line in ifp:\n                fields = line.split()\n                if fields[1] == path:\n                    device = fields[0]\n                    break\n        return device\n\n    def _reset(self, device):\n        \"\"\"Reset internal state for a previously mounted directory.\"\"\"\n        mounter_cls = self._handler_class(device=device)\n        mounter = mounter_cls(image=self.image,\n                              partition=self.partition,\n                              mount_dir=self.mount_dir,\n                              device=device)\n        self._mounter = mounter\n\n        mount_name = os.path.basename(self.mount_dir or '')\n        self._mkdir = mount_name.startswith(self.tmp_prefix)\n\n    @property\n    def errors(self):\n        \"\"\"Return the collated errors from all operations.\"\"\"\n        return '\\n--\\n'.join([''] + self._errors)\n\n    @staticmethod\n    def _handler_class(mode=None, device=None):\n        \"\"\"Look up the appropriate class to use based on MODE or DEVICE.\"\"\"\n        for cls in (loop.Mount, nbd.Mount, guestfs.Mount):\n            if mode and cls.mode == mode:\n                return cls\n            elif device and cls.device_id_string in device:\n                return cls\n        msg = _(\"no disk image handler for: %s\") % mode or device\n        raise exception.NovaException(msg)\n\n    def mount(self):\n        \"\"\"Mount a disk image, using the object attributes.\n\n        The first supported means provided by the mount classes is used.\n\n        True, or False is returned and the 'errors' attribute\n        contains any diagnostics.\n        \"\"\"\n        if self._mounter:\n            raise exception.NovaException(_('image already mounted'))\n\n        if not self.mount_dir:\n            self.mount_dir = tempfile.mkdtemp(prefix=self.tmp_prefix)\n            self._mkdir = True\n\n        try:\n            for h in self.handlers:\n                mounter_cls = self._handler_class(h)\n                mounter = mounter_cls(image=self.image,\n                                      partition=self.partition,\n                                      mount_dir=self.mount_dir)\n                if mounter.do_mount():\n                    self._mounter = mounter\n                    break\n                else:\n                    LOG.debug(mounter.error)\n                    self._errors.append(mounter.error)\n        finally:\n            if not self._mounter:\n                self.umount()  # rmdir\n\n        return bool(self._mounter)\n\n    def umount(self):\n        \"\"\"Unmount a disk image from the file system.\"\"\"\n        try:\n            if self._mounter:\n                self._mounter.do_umount()\n        finally:\n            if self._mkdir:\n                os.rmdir(self.mount_dir)\n\n\n# Public module functions\n\ndef inject_data(image,\n                key=None, net=None, metadata=None, admin_password=None,\n                files=None, partition=None, use_cow=False):\n    \"\"\"Injects a ssh key and optionally net data into a disk image.\n\n    it will mount the image as a fully partitioned disk and attempt to inject\n    into the specified partition number.\n\n    If partition is not specified it mounts the image as a single partition.\n\n    \"\"\"\n    img = _DiskImage(image=image, partition=partition, use_cow=use_cow)\n    if img.mount():\n        try:\n            inject_data_into_fs(img.mount_dir,\n                                key, net, metadata, admin_password, files)\n        finally:\n            img.umount()\n    else:\n        raise exception.NovaException(img.errors)\n\n\ndef setup_container(image, container_dir, use_cow=False):\n    \"\"\"Setup the LXC container.\n\n    It will mount the loopback image to the container directory in order\n    to create the root filesystem for the container.\n    \"\"\"\n    img = _DiskImage(image=image, use_cow=use_cow, mount_dir=container_dir)\n    if not img.mount():\n        LOG.error(_(\"Failed to mount container filesystem '%(image)s' \"\n                    \"on '%(target)s': %(errors)s\") %\n                  {\"image\": img, \"target\": container_dir,\n                   \"errors\": img.errors})\n        raise exception.NovaException(img.errors)\n\n\ndef destroy_container(container_dir):\n    \"\"\"Destroy the container once it terminates.\n\n    It will umount the container that is mounted,\n    and delete any  linked devices.\n    \"\"\"\n    try:\n        img = _DiskImage(image=None, mount_dir=container_dir)\n        img.umount()\n    except Exception, exn:\n        LOG.exception(_('Failed to unmount container filesystem: %s'), exn)\n\n\ndef inject_data_into_fs(fs, key, net, metadata, admin_password, files):\n    \"\"\"Injects data into a filesystem already mounted by the caller.\n    Virt connections can call this directly if they mount their fs\n    in a different way to inject_data\n    \"\"\"\n    if key:\n        _inject_key_into_fs(key, fs)\n    if net:\n        _inject_net_into_fs(net, fs)\n    if metadata:\n        _inject_metadata_into_fs(metadata, fs)\n    if admin_password:\n        _inject_admin_password_into_fs(admin_password, fs)\n    if files:\n        for (path, contents) in files:\n            _inject_file_into_fs(fs, path, contents)\n\n\ndef _join_and_check_path_within_fs(fs, *args):\n    '''os.path.join() with safety check for injected file paths.\n\n    Join the supplied path components and make sure that the\n    resulting path we are injecting into is within the\n    mounted guest fs.  Trying to be clever and specifying a\n    path with '..' in it will hit this safeguard.\n    '''\n    absolute_path, _err = utils.execute('readlink', '-nm',\n                                        os.path.join(fs, *args),\n                                        run_as_root=True)\n    if not absolute_path.startswith(os.path.realpath(fs) + '/'):\n        raise exception.Invalid(_('injected file path not valid'))\n    return absolute_path\n\n\ndef _inject_file_into_fs(fs, path, contents, append=False):\n    absolute_path = _join_and_check_path_within_fs(fs, path.lstrip('/'))\n\n    parent_dir = os.path.dirname(absolute_path)\n    utils.execute('mkdir', '-p', parent_dir, run_as_root=True)\n\n    args = []\n    if append:\n        args.append('-a')\n    args.append(absolute_path)\n\n    kwargs = dict(process_input=contents, run_as_root=True)\n\n    utils.execute('tee', *args, **kwargs)\n\n\ndef _inject_metadata_into_fs(metadata, fs):\n    metadata = dict([(m.key, m.value) for m in metadata])\n    _inject_file_into_fs(fs, 'meta.js', jsonutils.dumps(metadata))\n\n\ndef _setup_selinux_for_keys(fs):\n    \"\"\"Get selinux guests to ensure correct context on injected keys.\"\"\"\n\n    se_cfg = _join_and_check_path_within_fs(fs, 'etc', 'selinux')\n    se_cfg, _err = utils.trycmd('readlink', '-e', se_cfg, run_as_root=True)\n    if not se_cfg:\n        return\n\n    rclocal = _join_and_check_path_within_fs(fs, 'etc', 'rc.local')\n\n    # Support systemd based systems\n    rc_d = _join_and_check_path_within_fs(fs, 'etc', 'rc.d')\n    rclocal_e, _err = utils.trycmd('readlink', '-e', rclocal, run_as_root=True)\n    rc_d_e, _err = utils.trycmd('readlink', '-e', rc_d, run_as_root=True)\n    if not rclocal_e and rc_d_e:\n        rclocal = os.path.join(rc_d, 'rc.local')\n\n    # Note some systems end rc.local with \"exit 0\"\n    # and so to append there you'd need something like:\n    #  utils.execute('sed', '-i', '${/^exit 0$/d}' rclocal, run_as_root=True)\n    restorecon = [\n        '#!/bin/sh\\n',\n        '# Added by Nova to ensure injected ssh keys have the right context\\n',\n        'restorecon -RF /root/.ssh/ 2>/dev/null || :\\n',\n    ]\n\n    rclocal_rel = os.path.relpath(rclocal, fs)\n    _inject_file_into_fs(fs, rclocal_rel, ''.join(restorecon), append=True)\n    utils.execute('chmod', 'a+x', rclocal, run_as_root=True)\n\n\ndef _inject_key_into_fs(key, fs):\n    \"\"\"Add the given public ssh key to root's authorized_keys.\n\n    key is an ssh key string.\n    fs is the path to the base of the filesystem into which to inject the key.\n    \"\"\"\n    sshdir = _join_and_check_path_within_fs(fs, 'root', '.ssh')\n    utils.execute('mkdir', '-p', sshdir, run_as_root=True)\n    utils.execute('chown', 'root', sshdir, run_as_root=True)\n    utils.execute('chmod', '700', sshdir, run_as_root=True)\n\n    keyfile = os.path.join('root', '.ssh', 'authorized_keys')\n\n    key_data = ''.join([\n        '\\n',\n        '# The following ssh key was injected by Nova',\n        '\\n',\n        key.strip(),\n        '\\n',\n    ])\n\n    _inject_file_into_fs(fs, keyfile, key_data, append=True)\n\n    _setup_selinux_for_keys(fs)\n\n\ndef _inject_net_into_fs(net, fs):\n    \"\"\"Inject /etc/network/interfaces into the filesystem rooted at fs.\n\n    net is the contents of /etc/network/interfaces.\n    \"\"\"\n    netdir = _join_and_check_path_within_fs(fs, 'etc', 'network')\n    utils.execute('mkdir', '-p', netdir, run_as_root=True)\n    utils.execute('chown', 'root:root', netdir, run_as_root=True)\n    utils.execute('chmod', 755, netdir, run_as_root=True)\n\n    netfile = os.path.join('etc', 'network', 'interfaces')\n    _inject_file_into_fs(fs, netfile, net)\n\n\ndef _inject_admin_password_into_fs(admin_passwd, fs):\n    \"\"\"Set the root password to admin_passwd\n\n    admin_password is a root password\n    fs is the path to the base of the filesystem into which to inject\n    the key.\n\n    This method modifies the instance filesystem directly,\n    and does not require a guest agent running in the instance.\n\n    \"\"\"\n    # The approach used here is to copy the password and shadow\n    # files from the instance filesystem to local files, make any\n    # necessary changes, and then copy them back.\n\n    admin_user = 'root'\n\n    fd, tmp_passwd = tempfile.mkstemp()\n    os.close(fd)\n    fd, tmp_shadow = tempfile.mkstemp()\n    os.close(fd)\n\n    passwd_path = _join_and_check_path_within_fs(fs, 'etc', 'passwd')\n    shadow_path = _join_and_check_path_within_fs(fs, 'etc', 'shadow')\n\n    utils.execute('cp', passwd_path, tmp_passwd, run_as_root=True)\n    utils.execute('cp', shadow_path, tmp_shadow, run_as_root=True)\n    _set_passwd(admin_user, admin_passwd, tmp_passwd, tmp_shadow)\n    utils.execute('cp', tmp_passwd, passwd_path, run_as_root=True)\n    os.unlink(tmp_passwd)\n    utils.execute('cp', tmp_shadow, shadow_path, run_as_root=True)\n    os.unlink(tmp_shadow)\n\n\ndef _set_passwd(username, admin_passwd, passwd_file, shadow_file):\n    \"\"\"set the password for username to admin_passwd\n\n    The passwd_file is not modified.  The shadow_file is updated.\n    if the username is not found in both files, an exception is raised.\n\n    :param username: the username\n    :param encrypted_passwd: the  encrypted password\n    :param passwd_file: path to the passwd file\n    :param shadow_file: path to the shadow password file\n    :returns: nothing\n    :raises: exception.NovaException(), IOError()\n\n    \"\"\"\n    salt_set = ('abcdefghijklmnopqrstuvwxyz'\n                'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n                '0123456789./')\n    # encryption algo - id pairs for crypt()\n    algos = {'SHA-512': '$6$', 'SHA-256': '$5$', 'MD5': '$1$', 'DES': ''}\n\n    salt = 16 * ' '\n    salt = ''.join([random.choice(salt_set) for c in salt])\n\n    # crypt() depends on the underlying libc, and may not support all\n    # forms of hash. We try md5 first. If we get only 13 characters back,\n    # then the underlying crypt() didn't understand the '$n$salt' magic,\n    # so we fall back to DES.\n    # md5 is the default because it's widely supported. Although the\n    # local crypt() might support stronger SHA, the target instance\n    # might not.\n    encrypted_passwd = crypt.crypt(admin_passwd, algos['MD5'] + salt)\n    if len(encrypted_passwd) == 13:\n        encrypted_passwd = crypt.crypt(admin_passwd, algos['DES'] + salt)\n\n    try:\n        p_file = open(passwd_file, 'rb')\n        s_file = open(shadow_file, 'rb')\n\n        # username MUST exist in passwd file or it's an error\n        found = False\n        for entry in p_file:\n            split_entry = entry.split(':')\n            if split_entry[0] == username:\n                found = True\n                break\n        if not found:\n            msg = _('User %(username)s not found in password file.')\n            raise exception.NovaException(msg % username)\n\n        # update password in the shadow file.It's an error if the\n        # the user doesn't exist.\n        new_shadow = list()\n        found = False\n        for entry in s_file:\n            split_entry = entry.split(':')\n            if split_entry[0] == username:\n                split_entry[1] = encrypted_passwd\n                found = True\n            new_entry = ':'.join(split_entry)\n            new_shadow.append(new_entry)\n        s_file.close()\n        if not found:\n            msg = _('User %(username)s not found in shadow file.')\n            raise exception.NovaException(msg % username)\n        s_file = open(shadow_file, 'wb')\n        for entry in new_shadow:\n            s_file.write(entry)\n    finally:\n        p_file.close()\n        s_file.close()\n"], "filenames": ["nova/tests/test_virt.py", "nova/tests/test_xenapi.py", "nova/virt/disk/api.py"], "buggy_code_start_loc": [102, 679, 366], "buggy_code_end_loc": [167, 682, 367], "fixing_code_start_loc": [101, 680, 366], "fixing_code_end_loc": [181, 687, 369], "type": "CWE-264", "message": "virt/disk/api.py in OpenStack Compute (Nova) 2012.1.x before 2012.1.2 and Folsom before Folsom-3 allows remote authenticated users to overwrite arbitrary files via a symlink attack on a file in an image that uses a symlink that is only readable by root. NOTE: this vulnerability exists because of an incomplete fix for CVE-2012-3361.", "other": {"cve": {"id": "CVE-2012-3447", "sourceIdentifier": "secalert@redhat.com", "published": "2012-08-20T18:55:03.293", "lastModified": "2023-02-13T03:28:08.590", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "virt/disk/api.py in OpenStack Compute (Nova) 2012.1.x before 2012.1.2 and Folsom before Folsom-3 allows remote authenticated users to overwrite arbitrary files via a symlink attack on a file in an image that uses a symlink that is only readable by root. NOTE: this vulnerability exists because of an incomplete fix for CVE-2012-3361."}, {"lang": "es", "value": "virt/disk/api.py en OpenStack Compute (Nova) v2012.1.x antes de v2012.1.2 y Folsom antes de Folsom-3 permite a usuarios remotos autenticados sobreescribir archivos de su elecci\u00f3n mediante un ataque de enlaces simb\u00f3licos en una imagen que utiliza un enlace simb\u00f3lico que es s\u00f3lo legible por el usuario root. NOTA: esta vulnerabilidad se debe a un arreglo incompleto para CVE-2012-3361.\r\n"}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 6.8, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-264"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openstack:folsom:*:*:*:*:*:*:*:*", "matchCriteriaId": "64EBA4DA-1439-4DCF-812E-C1F932032CD6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:openstack:nova:2012.1:*:*:*:*:*:*:*", "matchCriteriaId": "3340EB75-EC5E-431E-87F8-06F967961375"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2012/08/07/1", "source": "secalert@redhat.com"}, {"url": "http://www.securityfocus.com/bid/54869", "source": "secalert@redhat.com"}, {"url": "https://bugs.launchpad.net/nova/+bug/1031311", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=845106", "source": "secalert@redhat.com"}, {"url": "https://exchange.xforce.ibmcloud.com/vulnerabilities/77539", "source": "secalert@redhat.com"}, {"url": "https://github.com/openstack/nova/commit/ce4b2e27be45a85b310237615c47eb53f37bb5f3", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}, {"url": "https://github.com/openstack/nova/commit/d9577ce9f266166a297488445b5b0c93c1ddb368", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}, {"url": "https://review.openstack.org/#/c/10953/", "source": "secalert@redhat.com"}]}, "github_commit_url": "https://github.com/openstack/nova/commit/ce4b2e27be45a85b310237615c47eb53f37bb5f3"}}