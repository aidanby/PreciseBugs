{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            M   M  PPPP    CCCC                              %\n%                            MM MM  P   P  C                                  %\n%                            M M M  PPPP   C                                  %\n%                            M   M  P      C                                  %\n%                            M   M  P       CCCC                              %\n%                                                                             %\n%                                                                             %\n%              Read/Write Magick Persistant Cache Image Format                %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 March 2000                                  %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2017 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://www.imagemagick.org/script/license.php                           %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"magick/studio.h\"\n#include \"magick/artifact.h\"\n#include \"magick/attribute.h\"\n#include \"magick/blob.h\"\n#include \"magick/blob-private.h\"\n#include \"magick/cache.h\"\n#include \"magick/color.h\"\n#include \"magick/color-private.h\"\n#include \"magick/colormap.h\"\n#include \"magick/constitute.h\"\n#include \"magick/exception.h\"\n#include \"magick/exception-private.h\"\n#include \"magick/geometry.h\"\n#include \"magick/hashmap.h\"\n#include \"magick/image.h\"\n#include \"magick/image-private.h\"\n#include \"magick/list.h\"\n#include \"magick/magick.h\"\n#include \"magick/memory_.h\"\n#include \"magick/module.h\"\n#include \"magick/monitor.h\"\n#include \"magick/monitor-private.h\"\n#include \"magick/option.h\"\n#include \"magick/pixel-accessor.h\"\n#include \"magick/profile.h\"\n#include \"magick/property.h\"\n#include \"magick/quantum-private.h\"\n#include \"magick/resource_.h\"\n#include \"magick/static.h\"\n#include \"magick/statistic.h\"\n#include \"magick/string_.h\"\n#include \"magick/string-private.h\"\n#include \"magick/utility.h\"\n#include \"magick/version-private.h\"\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WriteMPCImage(const ImageInfo *,Image *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s M P C                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsMPC() returns MagickTrue if the image format type, identified by the\n%  magick string, is an Magick Persistent Cache image.\n%\n%  The format of the IsMPC method is:\n%\n%      MagickBooleanType IsMPC(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsMPC(const unsigned char *magick,const size_t length)\n{\n  if (length < 14)\n    return(MagickFalse);\n  if (LocaleNCompare((const char *) magick,\"id=MagickCache\",14) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d C A C H E I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadMPCImage() reads an Magick Persistent Cache image file and returns\n%  it.  It allocates the memory necessary for the new Image structure and\n%  returns a pointer to the new image.\n%\n%  The format of the ReadMPCImage method is:\n%\n%      Image *ReadMPCImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  Decompression code contributed by Kyle Shorter.\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadMPCImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    cache_filename[MaxTextExtent],\n    id[MaxTextExtent],\n    keyword[MaxTextExtent],\n    *options;\n\n  const unsigned char\n    *p;\n\n  GeometryInfo\n    geometry_info;\n\n  Image\n    *image;\n\n  int\n    c;\n\n  LinkedListInfo\n    *profiles;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  MagickStatusType\n    flags;\n\n  register ssize_t\n    i;\n\n  size_t\n    depth,\n    length;\n\n  ssize_t\n    count;\n\n  StringInfo\n    *profile;\n\n  unsigned int\n    signature;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) CopyMagickString(cache_filename,image->filename,MaxTextExtent);\n  AppendImageFormat(\"cache\",cache_filename);\n  c=ReadBlobByte(image);\n  if (c == EOF)\n    {\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  *id='\\0';\n  (void) ResetMagickMemory(keyword,0,sizeof(keyword));\n  offset=0;\n  do\n  {\n    /*\n      Decode image header;  header terminates one character beyond a ':'.\n    */\n    profiles=(LinkedListInfo *) NULL;\n    length=MaxTextExtent;\n    options=AcquireString((char *) NULL);\n    signature=GetMagickSignature((const StringInfo *) NULL);\n    image->depth=8;\n    image->compression=NoCompression;\n    while ((isgraph(c) != MagickFalse) && (c != (int) ':'))\n    {\n      register char\n        *p;\n\n      if (c == (int) '{')\n        {\n          char\n            *comment;\n\n          /*\n            Read comment-- any text between { }.\n          */\n          length=MaxTextExtent;\n          comment=AcquireString((char *) NULL);\n          for (p=comment; comment != (char *) NULL; p++)\n          {\n            c=ReadBlobByte(image);\n            if (c == (int) '\\\\')\n              c=ReadBlobByte(image);\n            else\n              if ((c == EOF) || (c == (int) '}'))\n                break;\n            if ((size_t) (p-comment+1) >= length)\n              {\n                *p='\\0';\n                length<<=1;\n                comment=(char *) ResizeQuantumMemory(comment,length+\n                  MaxTextExtent,sizeof(*comment));\n                if (comment == (char *) NULL)\n                  break;\n                p=comment+strlen(comment);\n              }\n            *p=(char) c;\n          }\n          if (comment == (char *) NULL)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          *p='\\0';\n          (void) SetImageProperty(image,\"comment\",comment);\n          comment=DestroyString(comment);\n          c=ReadBlobByte(image);\n        }\n      else\n        if (isalnum(c) != MagickFalse)\n          {\n            /*\n              Get the keyword.\n            */\n            length=MaxTextExtent;\n            p=keyword;\n            do\n            {\n              if (c == (int) '=')\n                break;\n              if ((size_t) (p-keyword) < (MaxTextExtent-1))\n                *p++=(char) c;\n              c=ReadBlobByte(image);\n            } while (c != EOF);\n            *p='\\0';\n            p=options;\n            while (isspace((int) ((unsigned char) c)) != 0)\n              c=ReadBlobByte(image);\n            if (c == (int) '=')\n              {\n                /*\n                  Get the keyword value.\n                */\n                c=ReadBlobByte(image);\n                while ((c != (int) '}') && (c != EOF))\n                {\n                  if ((size_t) (p-options+1) >= length)\n                    {\n                      *p='\\0';\n                      length<<=1;\n                      options=(char *) ResizeQuantumMemory(options,length+\n                        MaxTextExtent,sizeof(*options));\n                      if (options == (char *) NULL)\n                        break;\n                      p=options+strlen(options);\n                    }\n                  *p++=(char) c;\n                  c=ReadBlobByte(image);\n                  if (c == '\\\\')\n                    {\n                      c=ReadBlobByte(image);\n                      if (c == (int) '}')\n                        {\n                          *p++=(char) c;\n                          c=ReadBlobByte(image);\n                        }\n                    }\n                  if (*options != '{')\n                    if (isspace((int) ((unsigned char) c)) != 0)\n                      break;\n                }\n                if (options == (char *) NULL)\n                  ThrowReaderException(ResourceLimitError,\n                    \"MemoryAllocationFailed\");\n              }\n            *p='\\0';\n            if (*options == '{')\n              (void) CopyMagickString(options,options+1,strlen(options));\n            /*\n              Assign a value to the specified keyword.\n            */\n            switch (*keyword)\n            {\n              case 'b':\n              case 'B':\n              {\n                if (LocaleCompare(keyword,\"background-color\") == 0)\n                  {\n                    (void) QueryColorDatabase(options,&image->background_color,\n                      exception);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"blue-primary\") == 0)\n                  {\n                    flags=ParseGeometry(options,&geometry_info);\n                    image->chromaticity.blue_primary.x=geometry_info.rho;\n                    image->chromaticity.blue_primary.y=geometry_info.sigma;\n                    if ((flags & SigmaValue) == 0)\n                      image->chromaticity.blue_primary.y=\n                        image->chromaticity.blue_primary.x;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"border-color\") == 0)\n                  {\n                    (void) QueryColorDatabase(options,&image->border_color,\n                      exception);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options);\n                break;\n              }\n              case 'c':\n              case 'C':\n              {\n                if (LocaleCompare(keyword,\"class\") == 0)\n                  {\n                    ssize_t\n                      storage_class;\n\n                    storage_class=ParseCommandOption(MagickClassOptions,\n                      MagickFalse,options);\n                    if (storage_class < 0)\n                      break;\n                    image->storage_class=(ClassType) storage_class;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"colors\") == 0)\n                  {\n                    image->colors=StringToUnsignedLong(options);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"colorspace\") == 0)\n                  {\n                    ssize_t\n                      colorspace;\n\n                    colorspace=ParseCommandOption(MagickColorspaceOptions,\n                      MagickFalse,options);\n                    if (colorspace < 0)\n                      break;\n                    image->colorspace=(ColorspaceType) colorspace;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"compression\") == 0)\n                  {\n                    ssize_t\n                      compression;\n\n                    compression=ParseCommandOption(MagickCompressOptions,\n                      MagickFalse,options);\n                    if (compression < 0)\n                      break;\n                    image->compression=(CompressionType) compression;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"columns\") == 0)\n                  {\n                    image->columns=StringToUnsignedLong(options);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options);\n                break;\n              }\n              case 'd':\n              case 'D':\n              {\n                if (LocaleCompare(keyword,\"delay\") == 0)\n                  {\n                    image->delay=StringToUnsignedLong(options);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"depth\") == 0)\n                  {\n                    image->depth=StringToUnsignedLong(options);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"dispose\") == 0)\n                  {\n                    ssize_t\n                      dispose;\n\n                    dispose=ParseCommandOption(MagickDisposeOptions,MagickFalse,\n                      options);\n                    if (dispose < 0)\n                      break;\n                    image->dispose=(DisposeType) dispose;\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options);\n                break;\n              }\n              case 'e':\n              case 'E':\n              {\n                if (LocaleCompare(keyword,\"endian\") == 0)\n                  {\n                    ssize_t\n                      endian;\n\n                    endian=ParseCommandOption(MagickEndianOptions,MagickFalse,\n                      options);\n                    if (endian < 0)\n                      break;\n                    image->endian=(EndianType) endian;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"error\") == 0)\n                  {\n                    image->error.mean_error_per_pixel=StringToDouble(options,\n                      (char **) NULL);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options);\n                break;\n              }\n              case 'g':\n              case 'G':\n              {\n                if (LocaleCompare(keyword,\"gamma\") == 0)\n                  {\n                    image->gamma=StringToDouble(options,(char **) NULL);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"green-primary\") == 0)\n                  {\n                    flags=ParseGeometry(options,&geometry_info);\n                    image->chromaticity.green_primary.x=geometry_info.rho;\n                    image->chromaticity.green_primary.y=geometry_info.sigma;\n                    if ((flags & SigmaValue) == 0)\n                      image->chromaticity.green_primary.y=\n                        image->chromaticity.green_primary.x;\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options);\n                break;\n              }\n              case 'i':\n              case 'I':\n              {\n                if (LocaleCompare(keyword,\"id\") == 0)\n                  {\n                    (void) CopyMagickString(id,options,MaxTextExtent);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"iterations\") == 0)\n                  {\n                    image->iterations=StringToUnsignedLong(options);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options);\n                break;\n              }\n              case 'm':\n              case 'M':\n              {\n                if (LocaleCompare(keyword,\"magick-signature\") == 0)\n                  {\n                    signature=(unsigned int) StringToUnsignedLong(options);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"matte\") == 0)\n                  {\n                    ssize_t\n                      matte;\n\n                    matte=ParseCommandOption(MagickBooleanOptions,MagickFalse,\n                      options);\n                    if (matte < 0)\n                      break;\n                    image->matte=(MagickBooleanType) matte;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"matte-color\") == 0)\n                  {\n                    (void) QueryColorDatabase(options,&image->matte_color,\n                      exception);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"maximum-error\") == 0)\n                  {\n                    image->error.normalized_maximum_error=StringToDouble(\n                      options,(char **) NULL);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"mean-error\") == 0)\n                  {\n                    image->error.normalized_mean_error=StringToDouble(options,\n                      (char **) NULL);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"montage\") == 0)\n                  {\n                    (void) CloneString(&image->montage,options);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options);\n                break;\n              }\n              case 'o':\n              case 'O':\n              {\n                if (LocaleCompare(keyword,\"opaque\") == 0)\n                  {\n                    ssize_t\n                      matte;\n\n                    matte=ParseCommandOption(MagickBooleanOptions,MagickFalse,\n                      options);\n                    if (matte < 0)\n                      break;\n                    image->matte=(MagickBooleanType) matte;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"orientation\") == 0)\n                  {\n                    ssize_t\n                      orientation;\n\n                    orientation=ParseCommandOption(MagickOrientationOptions,\n                      MagickFalse,options);\n                    if (orientation < 0)\n                      break;\n                    image->orientation=(OrientationType) orientation;\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options);\n                break;\n              }\n              case 'p':\n              case 'P':\n              {\n                if (LocaleCompare(keyword,\"page\") == 0)\n                  {\n                    char\n                      *geometry;\n\n                    geometry=GetPageGeometry(options);\n                    (void) ParseAbsoluteGeometry(geometry,&image->page);\n                    geometry=DestroyString(geometry);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"pixel-intensity\") == 0)\n                  {\n                    ssize_t\n                      intensity;\n\n                    intensity=ParseCommandOption(MagickPixelIntensityOptions,\n                      MagickFalse,options);\n                    if (intensity < 0)\n                      break;\n                    image->intensity=(PixelIntensityMethod) intensity;\n                    break;\n                  }\n                if ((LocaleNCompare(keyword,\"profile:\",8) == 0) ||\n                    (LocaleNCompare(keyword,\"profile-\",8) == 0))\n                  {\n                    if (profiles == (LinkedListInfo *) NULL)\n                      profiles=NewLinkedList(0);\n                    (void) AppendValueToLinkedList(profiles,\n                      AcquireString(keyword+8));\n                    profile=BlobToStringInfo((const void *) NULL,(size_t)\n                      StringToLong(options));\n                    if (profile == (StringInfo *) NULL)\n                      ThrowReaderException(ResourceLimitError,\n                        \"MemoryAllocationFailed\");\n                    (void) SetImageProfile(image,keyword+8,profile);\n                    profile=DestroyStringInfo(profile);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options);\n                break;\n              }\n              case 'q':\n              case 'Q':\n              {\n                if (LocaleCompare(keyword,\"quality\") == 0)\n                  {\n                    image->quality=StringToUnsignedLong(options);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options);\n                break;\n              }\n              case 'r':\n              case 'R':\n              {\n                if (LocaleCompare(keyword,\"red-primary\") == 0)\n                  {\n                    flags=ParseGeometry(options,&geometry_info);\n                    image->chromaticity.red_primary.x=geometry_info.rho;\n                    if ((flags & SigmaValue) != 0)\n                      image->chromaticity.red_primary.y=geometry_info.sigma;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"rendering-intent\") == 0)\n                  {\n                    ssize_t\n                      rendering_intent;\n\n                    rendering_intent=ParseCommandOption(MagickIntentOptions,\n                      MagickFalse,options);\n                    if (rendering_intent < 0)\n                      break;\n                    image->rendering_intent=(RenderingIntent) rendering_intent;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"resolution\") == 0)\n                  {\n                    flags=ParseGeometry(options,&geometry_info);\n                    image->x_resolution=geometry_info.rho;\n                    image->y_resolution=geometry_info.sigma;\n                    if ((flags & SigmaValue) == 0)\n                      image->y_resolution=image->x_resolution;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"rows\") == 0)\n                  {\n                    image->rows=StringToUnsignedLong(options);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options);\n                break;\n              }\n              case 's':\n              case 'S':\n              {\n                if (LocaleCompare(keyword,\"scene\") == 0)\n                  {\n                    image->scene=StringToUnsignedLong(options);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options);\n                break;\n              }\n              case 't':\n              case 'T':\n              {\n                if (LocaleCompare(keyword,\"ticks-per-second\") == 0)\n                  {\n                    image->ticks_per_second=(ssize_t) StringToLong(options);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"tile-offset\") == 0)\n                  {\n                    char\n                      *geometry;\n\n                    geometry=GetPageGeometry(options);\n                    (void) ParseAbsoluteGeometry(geometry,&image->tile_offset);\n                    geometry=DestroyString(geometry);\n                  }\n                if (LocaleCompare(keyword,\"type\") == 0)\n                  {\n                    ssize_t\n                      type;\n\n                    type=ParseCommandOption(MagickTypeOptions,MagickFalse,\n                      options);\n                    if (type < 0)\n                      break;\n                    image->type=(ImageType) type;\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options);\n                break;\n              }\n              case 'u':\n              case 'U':\n              {\n                if (LocaleCompare(keyword,\"units\") == 0)\n                  {\n                    ssize_t\n                      units;\n\n                    units=ParseCommandOption(MagickResolutionOptions,MagickFalse,\n                      options);\n                    if (units < 0)\n                      break;\n                    image->units=(ResolutionType) units;\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options);\n                break;\n              }\n              case 'w':\n              case 'W':\n              {\n                if (LocaleCompare(keyword,\"white-point\") == 0)\n                  {\n                    flags=ParseGeometry(options,&geometry_info);\n                    image->chromaticity.white_point.x=geometry_info.rho;\n                    image->chromaticity.white_point.y=geometry_info.sigma;\n                    if ((flags & SigmaValue) == 0)\n                      image->chromaticity.white_point.y=\n                        image->chromaticity.white_point.x;\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options);\n                break;\n              }\n              default:\n              {\n                (void) SetImageProperty(image,keyword,options);\n                break;\n              }\n            }\n          }\n        else\n          c=ReadBlobByte(image);\n      while (isspace((int) ((unsigned char) c)) != 0)\n        c=ReadBlobByte(image);\n    }\n    options=DestroyString(options);\n    (void) ReadBlobByte(image);\n    /*\n      Verify that required image information is defined.\n    */\n    if ((LocaleCompare(id,\"MagickCache\") != 0) ||\n        (image->storage_class == UndefinedClass) ||\n        (image->compression == UndefinedCompression) || (image->columns == 0) ||\n        (image->rows == 0))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if (signature != GetMagickSignature((const StringInfo *) NULL))\n      ThrowReaderException(CacheError,\"IncompatibleAPI\");\n    if (image->montage != (char *) NULL)\n      {\n        register char\n          *p;\n\n        /*\n          Image directory.\n        */\n        length=MaxTextExtent;\n        image->directory=AcquireString((char *) NULL);\n        p=image->directory;\n        do\n        {\n          *p='\\0';\n          if ((strlen(image->directory)+MaxTextExtent) >= length)\n            {\n              /*\n                Allocate more memory for the image directory.\n              */\n              length<<=1;\n              image->directory=(char *) ResizeQuantumMemory(image->directory,\n                length+MaxTextExtent,sizeof(*image->directory));\n              if (image->directory == (char *) NULL)\n                ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n              p=image->directory+strlen(image->directory);\n            }\n          c=ReadBlobByte(image);\n          *p++=(char) c;\n        } while (c != (int) '\\0');\n      }\n    if (profiles != (LinkedListInfo *) NULL)\n      {\n        const char\n          *name;\n\n        const StringInfo\n          *profile;\n\n        register unsigned char\n          *p;\n\n        /*\n          Read image profiles.\n        */\n        ResetLinkedListIterator(profiles);\n        name=(const char *) GetNextValueInLinkedList(profiles);\n        while (name != (const char *) NULL)\n        {\n          profile=GetImageProfile(image,name);\n          if (profile != (StringInfo *) NULL)\n            {\n              p=GetStringInfoDatum(profile);\n              (void) ReadBlob(image,GetStringInfoLength(profile),p);\n            }\n          name=(const char *) GetNextValueInLinkedList(profiles);\n        }\n        profiles=DestroyLinkedList(profiles,RelinquishMagickMemory);\n      }\n    depth=GetImageQuantumDepth(image,MagickFalse);\n    if (image->storage_class == PseudoClass)\n      {\n        size_t\n          packet_size;\n\n        unsigned char\n          *colormap;\n\n        /*\n          Create image colormap.\n        */\n        packet_size=(size_t) (3UL*depth/8UL);\n        if ((packet_size*image->colors) > GetBlobSize(image))\n          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n        image->colormap=(PixelPacket *) AcquireQuantumMemory(image->colors+1,\n          sizeof(*image->colormap));\n        if (image->colormap == (PixelPacket *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        if (image->colors != 0)\n          {\n            /*\n              Read image colormap from file.\n            */\n            colormap=(unsigned char *) AcquireQuantumMemory(image->colors,\n              packet_size*sizeof(*colormap));\n            if (colormap == (unsigned char *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n            count=ReadBlob(image,packet_size*image->colors,colormap);\n            if (count != (ssize_t) (packet_size*image->colors))\n              {\n                colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n                ThrowReaderException(CorruptImageError,\n                  \"InsufficientImageDataInFile\");\n              }\n            p=colormap;\n            switch (depth)\n            {\n              default:\n                colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n                ThrowReaderException(CorruptImageError,\n                  \"ImageDepthNotSupported\");\n              case 8:\n              {\n                unsigned char\n                  pixel;\n\n                for (i=0; i < (ssize_t) image->colors; i++)\n                {\n                  p=PushCharPixel(p,&pixel);\n                  image->colormap[i].red=ScaleCharToQuantum(pixel);\n                  p=PushCharPixel(p,&pixel);\n                  image->colormap[i].green=ScaleCharToQuantum(pixel);\n                  p=PushCharPixel(p,&pixel);\n                  image->colormap[i].blue=ScaleCharToQuantum(pixel);\n                }\n                break;\n              }\n              case 16:\n              {\n                unsigned short\n                  pixel;\n\n                for (i=0; i < (ssize_t) image->colors; i++)\n                {\n                  p=PushShortPixel(MSBEndian,p,&pixel);\n                  image->colormap[i].red=ScaleShortToQuantum(pixel);\n                  p=PushShortPixel(MSBEndian,p,&pixel);\n                  image->colormap[i].green=ScaleShortToQuantum(pixel);\n                  p=PushShortPixel(MSBEndian,p,&pixel);\n                  image->colormap[i].blue=ScaleShortToQuantum(pixel);\n                }\n                break;\n              }\n              case 32:\n              {\n                unsigned int\n                  pixel;\n\n                for (i=0; i < (ssize_t) image->colors; i++)\n                {\n                  p=PushLongPixel(MSBEndian,p,&pixel);\n                  image->colormap[i].red=ScaleLongToQuantum(pixel);\n                  p=PushLongPixel(MSBEndian,p,&pixel);\n                  image->colormap[i].green=ScaleLongToQuantum(pixel);\n                  p=PushLongPixel(MSBEndian,p,&pixel);\n                  image->colormap[i].blue=ScaleLongToQuantum(pixel);\n                }\n                break;\n              }\n            }\n            colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n          }\n      }\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if ((AcquireMagickResource(WidthResource,image->columns) == MagickFalse) ||\n        (AcquireMagickResource(HeightResource,image->rows) == MagickFalse))\n      ThrowReaderException(ImageError,\"WidthOrHeightExceedsLimit\");\n    /*\n      Attach persistent pixel cache.\n    */\n    status=PersistPixelCache(image,cache_filename,MagickTrue,&offset,exception);\n    if (status == MagickFalse)\n      ThrowReaderException(CacheError,\"UnableToPersistPixelCache\");\n    /*\n      Proceed to next image.\n    */\n    do\n    {\n      c=ReadBlobByte(image);\n    } while ((isgraph(c) == MagickFalse) && (c != EOF));\n    if (c != EOF)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (c != EOF);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r M P C I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterMPCImage() adds properties for the Cache image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterMPCImage method is:\n%\n%      size_t RegisterMPCImage(void)\n%\n*/\nModuleExport size_t RegisterMPCImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=SetMagickInfo(\"CACHE\");\n  entry->description=ConstantString(\"Magick Persistent Cache image format\");\n  entry->module=ConstantString(\"MPC\");\n  entry->seekable_stream=MagickTrue;\n  entry->stealth=MagickTrue;\n  (void) RegisterMagickInfo(entry);\n  entry=SetMagickInfo(\"MPC\");\n  entry->decoder=(DecodeImageHandler *) ReadMPCImage;\n  entry->encoder=(EncodeImageHandler *) WriteMPCImage;\n  entry->magick=(IsImageFormatHandler *) IsMPC;\n  entry->description=ConstantString(\"Magick Persistent Cache image format\");\n  entry->seekable_stream=MagickTrue;\n  entry->module=ConstantString(\"MPC\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r M P C I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterMPCImage() removes format registrations made by the\n%  MPC module from the list of supported formats.\n%\n%  The format of the UnregisterMPCImage method is:\n%\n%      UnregisterMPCImage(void)\n%\n*/\nModuleExport void UnregisterMPCImage(void)\n{\n  (void) UnregisterMagickInfo(\"CACHE\");\n  (void) UnregisterMagickInfo(\"MPC\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e M P C I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteMPCImage() writes an Magick Persistent Cache image to a file.\n%\n%  The format of the WriteMPCImage method is:\n%\n%      MagickBooleanType WriteMPCImage(const ImageInfo *image_info,Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image: the image.\n%\n*/\nstatic MagickBooleanType WriteMPCImage(const ImageInfo *image_info,Image *image)\n{\n  char\n    buffer[MaxTextExtent],\n    cache_filename[MaxTextExtent];\n\n  const char\n    *property,\n    *value;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset,\n    scene;\n\n  register ssize_t\n    i;\n\n  size_t\n    depth,\n    one;\n\n  /*\n    Open persistent cache.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) CopyMagickString(cache_filename,image->filename,MaxTextExtent);\n  AppendImageFormat(\"cache\",cache_filename);\n  scene=0;\n  offset=0;\n  one=1;\n  do\n  {\n    /*\n      Write persistent cache meta-information.\n    */\n    depth=GetImageQuantumDepth(image,MagickTrue);\n    if ((image->storage_class == PseudoClass) &&\n        (image->colors > (one << depth)))\n      image->storage_class=DirectClass;\n    (void) WriteBlobString(image,\"id=MagickCache\\n\");\n    (void) FormatLocaleString(buffer,MaxTextExtent,\"magick-signature=%u\\n\",\n      GetMagickSignature((const StringInfo *) NULL));\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MaxTextExtent,\n      \"class=%s  colors=%.20g  matte=%s\\n\",CommandOptionToMnemonic(\n      MagickClassOptions,image->storage_class),(double) image->colors,\n      CommandOptionToMnemonic(MagickBooleanOptions,(ssize_t) image->matte));\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MaxTextExtent,\n      \"columns=%.20g  rows=%.20g depth=%.20g\\n\",(double) image->columns,\n      (double) image->rows,(double) image->depth);\n    (void) WriteBlobString(image,buffer);\n    if (image->type != UndefinedType)\n      {\n        (void) FormatLocaleString(buffer,MaxTextExtent,\"type=%s\\n\",\n          CommandOptionToMnemonic(MagickTypeOptions,image->type));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->colorspace != UndefinedColorspace)\n      {\n        (void) FormatLocaleString(buffer,MaxTextExtent,\"colorspace=%s\\n\",\n          CommandOptionToMnemonic(MagickColorspaceOptions,image->colorspace));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->intensity != UndefinedPixelIntensityMethod)\n      {\n        (void) FormatLocaleString(buffer,MaxTextExtent,\"pixel-intensity=%s\\n\",\n          CommandOptionToMnemonic(MagickPixelIntensityOptions,\n          image->intensity));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->endian != UndefinedEndian)\n      {\n        (void) FormatLocaleString(buffer,MaxTextExtent,\"endian=%s\\n\",\n          CommandOptionToMnemonic(MagickEndianOptions,image->endian));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->compression != UndefinedCompression)\n      {\n        (void) FormatLocaleString(buffer,MaxTextExtent,\n          \"compression=%s  quality=%.20g\\n\",CommandOptionToMnemonic(\n          MagickCompressOptions,image->compression),(double) image->quality);\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->units != UndefinedResolution)\n      {\n        (void) FormatLocaleString(buffer,MaxTextExtent,\"units=%s\\n\",\n          CommandOptionToMnemonic(MagickResolutionOptions,image->units));\n        (void) WriteBlobString(image,buffer);\n      }\n    if ((image->x_resolution != 0) || (image->y_resolution != 0))\n      {\n        (void) FormatLocaleString(buffer,MaxTextExtent,\n          \"resolution=%gx%g\\n\",image->x_resolution,image->y_resolution);\n        (void) WriteBlobString(image,buffer);\n      }\n    if ((image->page.width != 0) || (image->page.height != 0))\n      {\n        (void) FormatLocaleString(buffer,MaxTextExtent,\n          \"page=%.20gx%.20g%+.20g%+.20g\\n\",(double) image->page.width,(double)\n          image->page.height,(double) image->page.x,(double) image->page.y);\n        (void) WriteBlobString(image,buffer);\n      }\n    else\n      if ((image->page.x != 0) || (image->page.y != 0))\n        {\n          (void) FormatLocaleString(buffer,MaxTextExtent,\"page=%+ld%+ld\\n\",\n            (long) image->page.x,(long) image->page.y);\n          (void) WriteBlobString(image,buffer);\n        }\n    if ((image->tile_offset.x != 0) || (image->tile_offset.y != 0))\n      {\n        (void) FormatLocaleString(buffer,MaxTextExtent,\"tile-offset=%+ld%+ld\\n\",\n          (long) image->tile_offset.x,(long) image->tile_offset.y);\n        (void) WriteBlobString(image,buffer);\n      }\n    if ((GetNextImageInList(image) != (Image *) NULL) ||\n        (GetPreviousImageInList(image) != (Image *) NULL))\n      {\n        if (image->scene == 0)\n          (void) FormatLocaleString(buffer,MaxTextExtent,\n            \"iterations=%.20g  delay=%.20g  ticks-per-second=%.20g\\n\",(double)\n            image->iterations,(double) image->delay,(double)\n            image->ticks_per_second);\n        else\n          (void) FormatLocaleString(buffer,MaxTextExtent,\"scene=%.20g  \"\n            \"iterations=%.20g  delay=%.20g  ticks-per-second=%.20g\\n\",\n            (double) image->scene,(double) image->iterations,(double)\n            image->delay,(double) image->ticks_per_second);\n        (void) WriteBlobString(image,buffer);\n      }\n    else\n      {\n        if (image->scene != 0)\n          {\n            (void) FormatLocaleString(buffer,MaxTextExtent,\"scene=%.20g\\n\",\n              (double) image->scene);\n            (void) WriteBlobString(image,buffer);\n          }\n        if (image->iterations != 0)\n          {\n            (void) FormatLocaleString(buffer,MaxTextExtent,\"iterations=%.20g\\n\",\n              (double) image->iterations);\n            (void) WriteBlobString(image,buffer);\n          }\n        if (image->delay != 0)\n          {\n            (void) FormatLocaleString(buffer,MaxTextExtent,\"delay=%.20g\\n\",\n              (double) image->delay);\n            (void) WriteBlobString(image,buffer);\n          }\n        if (image->ticks_per_second != UndefinedTicksPerSecond)\n          {\n            (void) FormatLocaleString(buffer,MaxTextExtent,\n              \"ticks-per-second=%.20g\\n\",(double) image->ticks_per_second);\n            (void) WriteBlobString(image,buffer);\n          }\n      }\n    if (image->gravity != UndefinedGravity)\n      {\n        (void) FormatLocaleString(buffer,MaxTextExtent,\"gravity=%s\\n\",\n          CommandOptionToMnemonic(MagickGravityOptions,image->gravity));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->dispose != UndefinedDispose)\n      {\n        (void) FormatLocaleString(buffer,MaxTextExtent,\"dispose=%s\\n\",\n          CommandOptionToMnemonic(MagickDisposeOptions,image->dispose));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->rendering_intent != UndefinedIntent)\n      {\n        (void) FormatLocaleString(buffer,MaxTextExtent,\n          \"rendering-intent=%s\\n\",CommandOptionToMnemonic(MagickIntentOptions,\n          image->rendering_intent));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->gamma != 0.0)\n      {\n        (void) FormatLocaleString(buffer,MaxTextExtent,\"gamma=%g\\n\",\n          image->gamma);\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->chromaticity.white_point.x != 0.0)\n      {\n        /*\n          Note chomaticity points.\n        */\n        (void) FormatLocaleString(buffer,MaxTextExtent,\"red-primary=\"\n          \"%g,%g  green-primary=%g,%g  blue-primary=%g,%g\\n\",\n          image->chromaticity.red_primary.x,image->chromaticity.red_primary.y,\n          image->chromaticity.green_primary.x,\n          image->chromaticity.green_primary.y,\n          image->chromaticity.blue_primary.x,\n          image->chromaticity.blue_primary.y);\n        (void) WriteBlobString(image,buffer);\n        (void) FormatLocaleString(buffer,MaxTextExtent,\n          \"white-point=%g,%g\\n\",image->chromaticity.white_point.x,\n          image->chromaticity.white_point.y);\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->orientation != UndefinedOrientation)\n      {\n        (void) FormatLocaleString(buffer,MaxTextExtent,\n          \"orientation=%s\\n\",CommandOptionToMnemonic(MagickOrientationOptions,\n          image->orientation));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->profiles != (void *) NULL)\n      {\n        const char\n          *name;\n\n        const StringInfo\n          *profile;\n\n        /*\n          Generic profile.\n        */\n        ResetImageProfileIterator(image);\n        for (name=GetNextImageProfile(image); name != (const char *) NULL; )\n        {\n          profile=GetImageProfile(image,name);\n          if (profile != (StringInfo *) NULL)\n            {\n              (void) FormatLocaleString(buffer,MaxTextExtent,\n                \"profile:%s=%.20g\\n\",name,(double)\n                GetStringInfoLength(profile));\n              (void) WriteBlobString(image,buffer);\n            }\n          name=GetNextImageProfile(image);\n        }\n      }\n    if (image->montage != (char *) NULL)\n      {\n        (void) FormatLocaleString(buffer,MaxTextExtent,\"montage=%s\\n\",\n          image->montage);\n        (void) WriteBlobString(image,buffer);\n      }\n    ResetImagePropertyIterator(image);\n    property=GetNextImageProperty(image);\n    while (property != (const char *) NULL)\n    {\n      (void) FormatLocaleString(buffer,MaxTextExtent,\"%s=\",property);\n      (void) WriteBlobString(image,buffer);\n      value=GetImageProperty(image,property);\n      if (value != (const char *) NULL)\n        {\n          size_t\n            length;\n\n          length=strlen(value);\n          for (i=0; i < (ssize_t) length; i++)\n            if (isspace((int) ((unsigned char) value[i])) != 0)\n              break;\n          if ((i == (ssize_t) length) && (i != 0))\n            (void) WriteBlob(image,length,(const unsigned char *) value);\n          else\n            {\n              (void) WriteBlobByte(image,'{');\n              if (strchr(value,'}') == (char *) NULL)\n                (void) WriteBlob(image,length,(const unsigned char *) value);\n              else\n                for (i=0; i < (ssize_t) length; i++)\n                {\n                  if (value[i] == (int) '}')\n                    (void) WriteBlobByte(image,'\\\\');\n                  (void) WriteBlobByte(image,value[i]);\n                }\n              (void) WriteBlobByte(image,'}');\n            }\n        }\n      (void) WriteBlobByte(image,'\\n');\n      property=GetNextImageProperty(image);\n    }\n    (void) WriteBlobString(image,\"\\f\\n:\\032\");\n    if (image->montage != (char *) NULL)\n      {\n        /*\n          Write montage tile directory.\n        */\n        if (image->directory != (char *) NULL)\n          (void) WriteBlobString(image,image->directory);\n        (void) WriteBlobByte(image,'\\0');\n      }\n    if (image->profiles != 0)\n      {\n        const char\n          *name;\n\n        const StringInfo\n          *profile;\n\n        /*\n          Write image profiles.\n        */\n        ResetImageProfileIterator(image);\n        name=GetNextImageProfile(image);\n        while (name != (const char *) NULL)\n        {\n          profile=GetImageProfile(image,name);\n          (void) WriteBlob(image,GetStringInfoLength(profile),\n            GetStringInfoDatum(profile));\n          name=GetNextImageProfile(image);\n        }\n      }\n    if (image->storage_class == PseudoClass)\n      {\n        size_t\n          packet_size;\n\n        unsigned char\n          *colormap,\n          *q;\n\n        /*\n          Allocate colormap.\n        */\n        packet_size=(size_t) (3UL*depth/8UL);\n        colormap=(unsigned char *) AcquireQuantumMemory(image->colors,\n          packet_size*sizeof(*colormap));\n        if (colormap == (unsigned char *) NULL)\n          return(MagickFalse);\n        /*\n          Write colormap to file.\n        */\n        q=colormap;\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          switch (depth)\n          {\n            default:\n              ThrowWriterException(CorruptImageError,\"ImageDepthNotSupported\");\n            case 32:\n            {\n              unsigned int\n                pixel;\n\n              pixel=ScaleQuantumToLong(image->colormap[i].red);\n              q=PopLongPixel(MSBEndian,pixel,q);\n              pixel=ScaleQuantumToLong(image->colormap[i].green);\n              q=PopLongPixel(MSBEndian,pixel,q);\n              pixel=ScaleQuantumToLong(image->colormap[i].blue);\n              q=PopLongPixel(MSBEndian,pixel,q);\n              break;\n            }\n            case 16:\n            {\n              unsigned short\n                pixel;\n\n              pixel=ScaleQuantumToShort(image->colormap[i].red);\n              q=PopShortPixel(MSBEndian,pixel,q);\n              pixel=ScaleQuantumToShort(image->colormap[i].green);\n              q=PopShortPixel(MSBEndian,pixel,q);\n              pixel=ScaleQuantumToShort(image->colormap[i].blue);\n              q=PopShortPixel(MSBEndian,pixel,q);\n              break;\n            }\n            case 8:\n            {\n              unsigned char\n                pixel;\n\n              pixel=(unsigned char) ScaleQuantumToChar(image->colormap[i].red);\n              q=PopCharPixel(pixel,q);\n              pixel=(unsigned char) ScaleQuantumToChar(\n                image->colormap[i].green);\n              q=PopCharPixel(pixel,q);\n              pixel=(unsigned char) ScaleQuantumToChar(image->colormap[i].blue);\n              q=PopCharPixel(pixel,q);\n              break;\n            }\n          }\n        }\n        (void) WriteBlob(image,packet_size*image->colors,colormap);\n        colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n      }\n    /*\n      Initialize persistent pixel cache.\n    */\n    status=PersistPixelCache(image,cache_filename,MagickFalse,&offset,\n      &image->exception);\n    if (status == MagickFalse)\n      ThrowWriterException(CacheError,\"UnableToPersistPixelCache\");\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        status=image->progress_monitor(SaveImagesTag,scene,\n          GetImageListLength(image),image->client_data);\n        if (status == MagickFalse)\n          break;\n      }\n    scene++;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(status);\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            M   M  PPPP    CCCC                              %\n%                            MM MM  P   P  C                                  %\n%                            M M M  PPPP   C                                  %\n%                            M   M  P      C                                  %\n%                            M   M  P       CCCC                              %\n%                                                                             %\n%                                                                             %\n%              Read/Write Magick Persistant Cache Image Format                %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 March 2000                                  %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2017 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://www.imagemagick.org/script/license.php                           %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"magick/studio.h\"\n#include \"magick/artifact.h\"\n#include \"magick/attribute.h\"\n#include \"magick/blob.h\"\n#include \"magick/blob-private.h\"\n#include \"magick/cache.h\"\n#include \"magick/color.h\"\n#include \"magick/color-private.h\"\n#include \"magick/colormap.h\"\n#include \"magick/constitute.h\"\n#include \"magick/exception.h\"\n#include \"magick/exception-private.h\"\n#include \"magick/geometry.h\"\n#include \"magick/hashmap.h\"\n#include \"magick/image.h\"\n#include \"magick/image-private.h\"\n#include \"magick/list.h\"\n#include \"magick/magick.h\"\n#include \"magick/memory_.h\"\n#include \"magick/module.h\"\n#include \"magick/monitor.h\"\n#include \"magick/monitor-private.h\"\n#include \"magick/option.h\"\n#include \"magick/pixel-accessor.h\"\n#include \"magick/profile.h\"\n#include \"magick/property.h\"\n#include \"magick/quantum-private.h\"\n#include \"magick/resource_.h\"\n#include \"magick/static.h\"\n#include \"magick/statistic.h\"\n#include \"magick/string_.h\"\n#include \"magick/string-private.h\"\n#include \"magick/utility.h\"\n#include \"magick/version-private.h\"\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WriteMPCImage(const ImageInfo *,Image *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s M P C                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsMPC() returns MagickTrue if the image format type, identified by the\n%  magick string, is an Magick Persistent Cache image.\n%\n%  The format of the IsMPC method is:\n%\n%      MagickBooleanType IsMPC(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsMPC(const unsigned char *magick,const size_t length)\n{\n  if (length < 14)\n    return(MagickFalse);\n  if (LocaleNCompare((const char *) magick,\"id=MagickCache\",14) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d C A C H E I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadMPCImage() reads an Magick Persistent Cache image file and returns\n%  it.  It allocates the memory necessary for the new Image structure and\n%  returns a pointer to the new image.\n%\n%  The format of the ReadMPCImage method is:\n%\n%      Image *ReadMPCImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  Decompression code contributed by Kyle Shorter.\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadMPCImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    cache_filename[MaxTextExtent],\n    id[MaxTextExtent],\n    keyword[MaxTextExtent],\n    *options;\n\n  const unsigned char\n    *p;\n\n  GeometryInfo\n    geometry_info;\n\n  Image\n    *image;\n\n  int\n    c;\n\n  LinkedListInfo\n    *profiles;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  MagickStatusType\n    flags;\n\n  register ssize_t\n    i;\n\n  size_t\n    depth,\n    length;\n\n  ssize_t\n    count;\n\n  StringInfo\n    *profile;\n\n  unsigned int\n    signature;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) CopyMagickString(cache_filename,image->filename,MaxTextExtent);\n  AppendImageFormat(\"cache\",cache_filename);\n  c=ReadBlobByte(image);\n  if (c == EOF)\n    {\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  *id='\\0';\n  (void) ResetMagickMemory(keyword,0,sizeof(keyword));\n  offset=0;\n  do\n  {\n    /*\n      Decode image header;  header terminates one character beyond a ':'.\n    */\n    profiles=(LinkedListInfo *) NULL;\n    length=MaxTextExtent;\n    options=AcquireString((char *) NULL);\n    signature=GetMagickSignature((const StringInfo *) NULL);\n    image->depth=8;\n    image->compression=NoCompression;\n    while ((isgraph(c) != MagickFalse) && (c != (int) ':'))\n    {\n      register char\n        *p;\n\n      if (c == (int) '{')\n        {\n          char\n            *comment;\n\n          /*\n            Read comment-- any text between { }.\n          */\n          length=MaxTextExtent;\n          comment=AcquireString((char *) NULL);\n          for (p=comment; comment != (char *) NULL; p++)\n          {\n            c=ReadBlobByte(image);\n            if (c == (int) '\\\\')\n              c=ReadBlobByte(image);\n            else\n              if ((c == EOF) || (c == (int) '}'))\n                break;\n            if ((size_t) (p-comment+1) >= length)\n              {\n                *p='\\0';\n                length<<=1;\n                comment=(char *) ResizeQuantumMemory(comment,length+\n                  MaxTextExtent,sizeof(*comment));\n                if (comment == (char *) NULL)\n                  break;\n                p=comment+strlen(comment);\n              }\n            *p=(char) c;\n          }\n          if (comment == (char *) NULL)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          *p='\\0';\n          (void) SetImageProperty(image,\"comment\",comment);\n          comment=DestroyString(comment);\n          c=ReadBlobByte(image);\n        }\n      else\n        if (isalnum(c) != MagickFalse)\n          {\n            /*\n              Get the keyword.\n            */\n            length=MaxTextExtent;\n            p=keyword;\n            do\n            {\n              if (c == (int) '=')\n                break;\n              if ((size_t) (p-keyword) < (MaxTextExtent-1))\n                *p++=(char) c;\n              c=ReadBlobByte(image);\n            } while (c != EOF);\n            *p='\\0';\n            p=options;\n            while (isspace((int) ((unsigned char) c)) != 0)\n              c=ReadBlobByte(image);\n            if (c == (int) '=')\n              {\n                /*\n                  Get the keyword value.\n                */\n                c=ReadBlobByte(image);\n                while ((c != (int) '}') && (c != EOF))\n                {\n                  if ((size_t) (p-options+1) >= length)\n                    {\n                      *p='\\0';\n                      length<<=1;\n                      options=(char *) ResizeQuantumMemory(options,length+\n                        MaxTextExtent,sizeof(*options));\n                      if (options == (char *) NULL)\n                        break;\n                      p=options+strlen(options);\n                    }\n                  *p++=(char) c;\n                  c=ReadBlobByte(image);\n                  if (c == '\\\\')\n                    {\n                      c=ReadBlobByte(image);\n                      if (c == (int) '}')\n                        {\n                          *p++=(char) c;\n                          c=ReadBlobByte(image);\n                        }\n                    }\n                  if (*options != '{')\n                    if (isspace((int) ((unsigned char) c)) != 0)\n                      break;\n                }\n                if (options == (char *) NULL)\n                  ThrowReaderException(ResourceLimitError,\n                    \"MemoryAllocationFailed\");\n              }\n            *p='\\0';\n            if (*options == '{')\n              (void) CopyMagickString(options,options+1,strlen(options));\n            /*\n              Assign a value to the specified keyword.\n            */\n            switch (*keyword)\n            {\n              case 'b':\n              case 'B':\n              {\n                if (LocaleCompare(keyword,\"background-color\") == 0)\n                  {\n                    (void) QueryColorDatabase(options,&image->background_color,\n                      exception);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"blue-primary\") == 0)\n                  {\n                    flags=ParseGeometry(options,&geometry_info);\n                    image->chromaticity.blue_primary.x=geometry_info.rho;\n                    image->chromaticity.blue_primary.y=geometry_info.sigma;\n                    if ((flags & SigmaValue) == 0)\n                      image->chromaticity.blue_primary.y=\n                        image->chromaticity.blue_primary.x;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"border-color\") == 0)\n                  {\n                    (void) QueryColorDatabase(options,&image->border_color,\n                      exception);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options);\n                break;\n              }\n              case 'c':\n              case 'C':\n              {\n                if (LocaleCompare(keyword,\"class\") == 0)\n                  {\n                    ssize_t\n                      storage_class;\n\n                    storage_class=ParseCommandOption(MagickClassOptions,\n                      MagickFalse,options);\n                    if (storage_class < 0)\n                      break;\n                    image->storage_class=(ClassType) storage_class;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"colors\") == 0)\n                  {\n                    image->colors=StringToUnsignedLong(options);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"colorspace\") == 0)\n                  {\n                    ssize_t\n                      colorspace;\n\n                    colorspace=ParseCommandOption(MagickColorspaceOptions,\n                      MagickFalse,options);\n                    if (colorspace < 0)\n                      break;\n                    image->colorspace=(ColorspaceType) colorspace;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"compression\") == 0)\n                  {\n                    ssize_t\n                      compression;\n\n                    compression=ParseCommandOption(MagickCompressOptions,\n                      MagickFalse,options);\n                    if (compression < 0)\n                      break;\n                    image->compression=(CompressionType) compression;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"columns\") == 0)\n                  {\n                    image->columns=StringToUnsignedLong(options);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options);\n                break;\n              }\n              case 'd':\n              case 'D':\n              {\n                if (LocaleCompare(keyword,\"delay\") == 0)\n                  {\n                    image->delay=StringToUnsignedLong(options);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"depth\") == 0)\n                  {\n                    image->depth=StringToUnsignedLong(options);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"dispose\") == 0)\n                  {\n                    ssize_t\n                      dispose;\n\n                    dispose=ParseCommandOption(MagickDisposeOptions,MagickFalse,\n                      options);\n                    if (dispose < 0)\n                      break;\n                    image->dispose=(DisposeType) dispose;\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options);\n                break;\n              }\n              case 'e':\n              case 'E':\n              {\n                if (LocaleCompare(keyword,\"endian\") == 0)\n                  {\n                    ssize_t\n                      endian;\n\n                    endian=ParseCommandOption(MagickEndianOptions,MagickFalse,\n                      options);\n                    if (endian < 0)\n                      break;\n                    image->endian=(EndianType) endian;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"error\") == 0)\n                  {\n                    image->error.mean_error_per_pixel=StringToDouble(options,\n                      (char **) NULL);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options);\n                break;\n              }\n              case 'g':\n              case 'G':\n              {\n                if (LocaleCompare(keyword,\"gamma\") == 0)\n                  {\n                    image->gamma=StringToDouble(options,(char **) NULL);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"green-primary\") == 0)\n                  {\n                    flags=ParseGeometry(options,&geometry_info);\n                    image->chromaticity.green_primary.x=geometry_info.rho;\n                    image->chromaticity.green_primary.y=geometry_info.sigma;\n                    if ((flags & SigmaValue) == 0)\n                      image->chromaticity.green_primary.y=\n                        image->chromaticity.green_primary.x;\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options);\n                break;\n              }\n              case 'i':\n              case 'I':\n              {\n                if (LocaleCompare(keyword,\"id\") == 0)\n                  {\n                    (void) CopyMagickString(id,options,MaxTextExtent);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"iterations\") == 0)\n                  {\n                    image->iterations=StringToUnsignedLong(options);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options);\n                break;\n              }\n              case 'm':\n              case 'M':\n              {\n                if (LocaleCompare(keyword,\"magick-signature\") == 0)\n                  {\n                    signature=(unsigned int) StringToUnsignedLong(options);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"matte\") == 0)\n                  {\n                    ssize_t\n                      matte;\n\n                    matte=ParseCommandOption(MagickBooleanOptions,MagickFalse,\n                      options);\n                    if (matte < 0)\n                      break;\n                    image->matte=(MagickBooleanType) matte;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"matte-color\") == 0)\n                  {\n                    (void) QueryColorDatabase(options,&image->matte_color,\n                      exception);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"maximum-error\") == 0)\n                  {\n                    image->error.normalized_maximum_error=StringToDouble(\n                      options,(char **) NULL);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"mean-error\") == 0)\n                  {\n                    image->error.normalized_mean_error=StringToDouble(options,\n                      (char **) NULL);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"montage\") == 0)\n                  {\n                    (void) CloneString(&image->montage,options);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options);\n                break;\n              }\n              case 'o':\n              case 'O':\n              {\n                if (LocaleCompare(keyword,\"opaque\") == 0)\n                  {\n                    ssize_t\n                      matte;\n\n                    matte=ParseCommandOption(MagickBooleanOptions,MagickFalse,\n                      options);\n                    if (matte < 0)\n                      break;\n                    image->matte=(MagickBooleanType) matte;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"orientation\") == 0)\n                  {\n                    ssize_t\n                      orientation;\n\n                    orientation=ParseCommandOption(MagickOrientationOptions,\n                      MagickFalse,options);\n                    if (orientation < 0)\n                      break;\n                    image->orientation=(OrientationType) orientation;\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options);\n                break;\n              }\n              case 'p':\n              case 'P':\n              {\n                if (LocaleCompare(keyword,\"page\") == 0)\n                  {\n                    char\n                      *geometry;\n\n                    geometry=GetPageGeometry(options);\n                    (void) ParseAbsoluteGeometry(geometry,&image->page);\n                    geometry=DestroyString(geometry);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"pixel-intensity\") == 0)\n                  {\n                    ssize_t\n                      intensity;\n\n                    intensity=ParseCommandOption(MagickPixelIntensityOptions,\n                      MagickFalse,options);\n                    if (intensity < 0)\n                      break;\n                    image->intensity=(PixelIntensityMethod) intensity;\n                    break;\n                  }\n                if ((LocaleNCompare(keyword,\"profile:\",8) == 0) ||\n                    (LocaleNCompare(keyword,\"profile-\",8) == 0))\n                  {\n                    if (profiles == (LinkedListInfo *) NULL)\n                      profiles=NewLinkedList(0);\n                    (void) AppendValueToLinkedList(profiles,\n                      AcquireString(keyword+8));\n                    profile=BlobToStringInfo((const void *) NULL,(size_t)\n                      StringToLong(options));\n                    if (profile == (StringInfo *) NULL)\n                      ThrowReaderException(ResourceLimitError,\n                        \"MemoryAllocationFailed\");\n                    (void) SetImageProfile(image,keyword+8,profile);\n                    profile=DestroyStringInfo(profile);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options);\n                break;\n              }\n              case 'q':\n              case 'Q':\n              {\n                if (LocaleCompare(keyword,\"quality\") == 0)\n                  {\n                    image->quality=StringToUnsignedLong(options);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options);\n                break;\n              }\n              case 'r':\n              case 'R':\n              {\n                if (LocaleCompare(keyword,\"red-primary\") == 0)\n                  {\n                    flags=ParseGeometry(options,&geometry_info);\n                    image->chromaticity.red_primary.x=geometry_info.rho;\n                    if ((flags & SigmaValue) != 0)\n                      image->chromaticity.red_primary.y=geometry_info.sigma;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"rendering-intent\") == 0)\n                  {\n                    ssize_t\n                      rendering_intent;\n\n                    rendering_intent=ParseCommandOption(MagickIntentOptions,\n                      MagickFalse,options);\n                    if (rendering_intent < 0)\n                      break;\n                    image->rendering_intent=(RenderingIntent) rendering_intent;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"resolution\") == 0)\n                  {\n                    flags=ParseGeometry(options,&geometry_info);\n                    image->x_resolution=geometry_info.rho;\n                    image->y_resolution=geometry_info.sigma;\n                    if ((flags & SigmaValue) == 0)\n                      image->y_resolution=image->x_resolution;\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"rows\") == 0)\n                  {\n                    image->rows=StringToUnsignedLong(options);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options);\n                break;\n              }\n              case 's':\n              case 'S':\n              {\n                if (LocaleCompare(keyword,\"scene\") == 0)\n                  {\n                    image->scene=StringToUnsignedLong(options);\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options);\n                break;\n              }\n              case 't':\n              case 'T':\n              {\n                if (LocaleCompare(keyword,\"ticks-per-second\") == 0)\n                  {\n                    image->ticks_per_second=(ssize_t) StringToLong(options);\n                    break;\n                  }\n                if (LocaleCompare(keyword,\"tile-offset\") == 0)\n                  {\n                    char\n                      *geometry;\n\n                    geometry=GetPageGeometry(options);\n                    (void) ParseAbsoluteGeometry(geometry,&image->tile_offset);\n                    geometry=DestroyString(geometry);\n                  }\n                if (LocaleCompare(keyword,\"type\") == 0)\n                  {\n                    ssize_t\n                      type;\n\n                    type=ParseCommandOption(MagickTypeOptions,MagickFalse,\n                      options);\n                    if (type < 0)\n                      break;\n                    image->type=(ImageType) type;\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options);\n                break;\n              }\n              case 'u':\n              case 'U':\n              {\n                if (LocaleCompare(keyword,\"units\") == 0)\n                  {\n                    ssize_t\n                      units;\n\n                    units=ParseCommandOption(MagickResolutionOptions,MagickFalse,\n                      options);\n                    if (units < 0)\n                      break;\n                    image->units=(ResolutionType) units;\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options);\n                break;\n              }\n              case 'w':\n              case 'W':\n              {\n                if (LocaleCompare(keyword,\"white-point\") == 0)\n                  {\n                    flags=ParseGeometry(options,&geometry_info);\n                    image->chromaticity.white_point.x=geometry_info.rho;\n                    image->chromaticity.white_point.y=geometry_info.sigma;\n                    if ((flags & SigmaValue) == 0)\n                      image->chromaticity.white_point.y=\n                        image->chromaticity.white_point.x;\n                    break;\n                  }\n                (void) SetImageProperty(image,keyword,options);\n                break;\n              }\n              default:\n              {\n                (void) SetImageProperty(image,keyword,options);\n                break;\n              }\n            }\n          }\n        else\n          c=ReadBlobByte(image);\n      while (isspace((int) ((unsigned char) c)) != 0)\n        c=ReadBlobByte(image);\n    }\n    options=DestroyString(options);\n    (void) ReadBlobByte(image);\n    /*\n      Verify that required image information is defined.\n    */\n    if ((LocaleCompare(id,\"MagickCache\") != 0) ||\n        (image->storage_class == UndefinedClass) ||\n        (image->compression == UndefinedCompression) || (image->columns == 0) ||\n        (image->rows == 0))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if (signature != GetMagickSignature((const StringInfo *) NULL))\n      ThrowReaderException(CacheError,\"IncompatibleAPI\");\n    if (image->montage != (char *) NULL)\n      {\n        register char\n          *p;\n\n        /*\n          Image directory.\n        */\n        length=MaxTextExtent;\n        image->directory=AcquireString((char *) NULL);\n        p=image->directory;\n        do\n        {\n          *p='\\0';\n          if ((strlen(image->directory)+MaxTextExtent) >= length)\n            {\n              /*\n                Allocate more memory for the image directory.\n              */\n              length<<=1;\n              image->directory=(char *) ResizeQuantumMemory(image->directory,\n                length+MaxTextExtent,sizeof(*image->directory));\n              if (image->directory == (char *) NULL)\n                ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n              p=image->directory+strlen(image->directory);\n            }\n          c=ReadBlobByte(image);\n          *p++=(char) c;\n        } while (c != (int) '\\0');\n      }\n    if (profiles != (LinkedListInfo *) NULL)\n      {\n        const char\n          *name;\n\n        const StringInfo\n          *profile;\n\n        register unsigned char\n          *p;\n\n        /*\n          Read image profiles.\n        */\n        ResetLinkedListIterator(profiles);\n        name=(const char *) GetNextValueInLinkedList(profiles);\n        while (name != (const char *) NULL)\n        {\n          profile=GetImageProfile(image,name);\n          if (profile != (StringInfo *) NULL)\n            {\n              p=GetStringInfoDatum(profile);\n              (void) ReadBlob(image,GetStringInfoLength(profile),p);\n            }\n          name=(const char *) GetNextValueInLinkedList(profiles);\n        }\n        profiles=DestroyLinkedList(profiles,RelinquishMagickMemory);\n      }\n    depth=GetImageQuantumDepth(image,MagickFalse);\n    if (image->storage_class == PseudoClass)\n      {\n        size_t\n          packet_size;\n\n        unsigned char\n          *colormap;\n\n        /*\n          Create image colormap.\n        */\n        packet_size=(size_t) (3UL*depth/8UL);\n        if ((packet_size*image->colors) > GetBlobSize(image))\n          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n        image->colormap=(PixelPacket *) AcquireQuantumMemory(image->colors+1,\n          sizeof(*image->colormap));\n        if (image->colormap == (PixelPacket *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        if (image->colors != 0)\n          {\n            /*\n              Read image colormap from file.\n            */\n            colormap=(unsigned char *) AcquireQuantumMemory(image->colors,\n              packet_size*sizeof(*colormap));\n            if (colormap == (unsigned char *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n            count=ReadBlob(image,packet_size*image->colors,colormap);\n            if (count != (ssize_t) (packet_size*image->colors))\n              {\n                colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n                ThrowReaderException(CorruptImageError,\n                  \"InsufficientImageDataInFile\");\n              }\n            p=colormap;\n            switch (depth)\n            {\n              default:\n                colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n                ThrowReaderException(CorruptImageError,\n                  \"ImageDepthNotSupported\");\n              case 8:\n              {\n                unsigned char\n                  pixel;\n\n                for (i=0; i < (ssize_t) image->colors; i++)\n                {\n                  p=PushCharPixel(p,&pixel);\n                  image->colormap[i].red=ScaleCharToQuantum(pixel);\n                  p=PushCharPixel(p,&pixel);\n                  image->colormap[i].green=ScaleCharToQuantum(pixel);\n                  p=PushCharPixel(p,&pixel);\n                  image->colormap[i].blue=ScaleCharToQuantum(pixel);\n                }\n                break;\n              }\n              case 16:\n              {\n                unsigned short\n                  pixel;\n\n                for (i=0; i < (ssize_t) image->colors; i++)\n                {\n                  p=PushShortPixel(MSBEndian,p,&pixel);\n                  image->colormap[i].red=ScaleShortToQuantum(pixel);\n                  p=PushShortPixel(MSBEndian,p,&pixel);\n                  image->colormap[i].green=ScaleShortToQuantum(pixel);\n                  p=PushShortPixel(MSBEndian,p,&pixel);\n                  image->colormap[i].blue=ScaleShortToQuantum(pixel);\n                }\n                break;\n              }\n              case 32:\n              {\n                unsigned int\n                  pixel;\n\n                for (i=0; i < (ssize_t) image->colors; i++)\n                {\n                  p=PushLongPixel(MSBEndian,p,&pixel);\n                  image->colormap[i].red=ScaleLongToQuantum(pixel);\n                  p=PushLongPixel(MSBEndian,p,&pixel);\n                  image->colormap[i].green=ScaleLongToQuantum(pixel);\n                  p=PushLongPixel(MSBEndian,p,&pixel);\n                  image->colormap[i].blue=ScaleLongToQuantum(pixel);\n                }\n                break;\n              }\n            }\n            colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n          }\n      }\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if ((AcquireMagickResource(WidthResource,image->columns) == MagickFalse) ||\n        (AcquireMagickResource(HeightResource,image->rows) == MagickFalse))\n      ThrowReaderException(ImageError,\"WidthOrHeightExceedsLimit\");\n    /*\n      Attach persistent pixel cache.\n    */\n    status=PersistPixelCache(image,cache_filename,MagickTrue,&offset,exception);\n    if (status == MagickFalse)\n      ThrowReaderException(CacheError,\"UnableToPersistPixelCache\");\n    /*\n      Proceed to next image.\n    */\n    do\n    {\n      c=ReadBlobByte(image);\n    } while ((isgraph(c) == MagickFalse) && (c != EOF));\n    if (c != EOF)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (c != EOF);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r M P C I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterMPCImage() adds properties for the Cache image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterMPCImage method is:\n%\n%      size_t RegisterMPCImage(void)\n%\n*/\nModuleExport size_t RegisterMPCImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=SetMagickInfo(\"CACHE\");\n  entry->description=ConstantString(\"Magick Persistent Cache image format\");\n  entry->module=ConstantString(\"MPC\");\n  entry->stealth=MagickTrue;\n  (void) RegisterMagickInfo(entry);\n  entry=SetMagickInfo(\"MPC\");\n  entry->decoder=(DecodeImageHandler *) ReadMPCImage;\n  entry->encoder=(EncodeImageHandler *) WriteMPCImage;\n  entry->magick=(IsImageFormatHandler *) IsMPC;\n  entry->description=ConstantString(\"Magick Persistent Cache image format\");\n  entry->seekable_stream=MagickTrue;\n  entry->module=ConstantString(\"MPC\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r M P C I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterMPCImage() removes format registrations made by the\n%  MPC module from the list of supported formats.\n%\n%  The format of the UnregisterMPCImage method is:\n%\n%      UnregisterMPCImage(void)\n%\n*/\nModuleExport void UnregisterMPCImage(void)\n{\n  (void) UnregisterMagickInfo(\"CACHE\");\n  (void) UnregisterMagickInfo(\"MPC\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e M P C I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteMPCImage() writes an Magick Persistent Cache image to a file.\n%\n%  The format of the WriteMPCImage method is:\n%\n%      MagickBooleanType WriteMPCImage(const ImageInfo *image_info,Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image: the image.\n%\n*/\nstatic MagickBooleanType WriteMPCImage(const ImageInfo *image_info,Image *image)\n{\n  char\n    buffer[MaxTextExtent],\n    cache_filename[MaxTextExtent];\n\n  const char\n    *property,\n    *value;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset,\n    scene;\n\n  register ssize_t\n    i;\n\n  size_t\n    depth,\n    one;\n\n  /*\n    Open persistent cache.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) CopyMagickString(cache_filename,image->filename,MaxTextExtent);\n  AppendImageFormat(\"cache\",cache_filename);\n  scene=0;\n  offset=0;\n  one=1;\n  do\n  {\n    /*\n      Write persistent cache meta-information.\n    */\n    depth=GetImageQuantumDepth(image,MagickTrue);\n    if ((image->storage_class == PseudoClass) &&\n        (image->colors > (one << depth)))\n      image->storage_class=DirectClass;\n    (void) WriteBlobString(image,\"id=MagickCache\\n\");\n    (void) FormatLocaleString(buffer,MaxTextExtent,\"magick-signature=%u\\n\",\n      GetMagickSignature((const StringInfo *) NULL));\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MaxTextExtent,\n      \"class=%s  colors=%.20g  matte=%s\\n\",CommandOptionToMnemonic(\n      MagickClassOptions,image->storage_class),(double) image->colors,\n      CommandOptionToMnemonic(MagickBooleanOptions,(ssize_t) image->matte));\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MaxTextExtent,\n      \"columns=%.20g  rows=%.20g depth=%.20g\\n\",(double) image->columns,\n      (double) image->rows,(double) image->depth);\n    (void) WriteBlobString(image,buffer);\n    if (image->type != UndefinedType)\n      {\n        (void) FormatLocaleString(buffer,MaxTextExtent,\"type=%s\\n\",\n          CommandOptionToMnemonic(MagickTypeOptions,image->type));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->colorspace != UndefinedColorspace)\n      {\n        (void) FormatLocaleString(buffer,MaxTextExtent,\"colorspace=%s\\n\",\n          CommandOptionToMnemonic(MagickColorspaceOptions,image->colorspace));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->intensity != UndefinedPixelIntensityMethod)\n      {\n        (void) FormatLocaleString(buffer,MaxTextExtent,\"pixel-intensity=%s\\n\",\n          CommandOptionToMnemonic(MagickPixelIntensityOptions,\n          image->intensity));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->endian != UndefinedEndian)\n      {\n        (void) FormatLocaleString(buffer,MaxTextExtent,\"endian=%s\\n\",\n          CommandOptionToMnemonic(MagickEndianOptions,image->endian));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->compression != UndefinedCompression)\n      {\n        (void) FormatLocaleString(buffer,MaxTextExtent,\n          \"compression=%s  quality=%.20g\\n\",CommandOptionToMnemonic(\n          MagickCompressOptions,image->compression),(double) image->quality);\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->units != UndefinedResolution)\n      {\n        (void) FormatLocaleString(buffer,MaxTextExtent,\"units=%s\\n\",\n          CommandOptionToMnemonic(MagickResolutionOptions,image->units));\n        (void) WriteBlobString(image,buffer);\n      }\n    if ((image->x_resolution != 0) || (image->y_resolution != 0))\n      {\n        (void) FormatLocaleString(buffer,MaxTextExtent,\n          \"resolution=%gx%g\\n\",image->x_resolution,image->y_resolution);\n        (void) WriteBlobString(image,buffer);\n      }\n    if ((image->page.width != 0) || (image->page.height != 0))\n      {\n        (void) FormatLocaleString(buffer,MaxTextExtent,\n          \"page=%.20gx%.20g%+.20g%+.20g\\n\",(double) image->page.width,(double)\n          image->page.height,(double) image->page.x,(double) image->page.y);\n        (void) WriteBlobString(image,buffer);\n      }\n    else\n      if ((image->page.x != 0) || (image->page.y != 0))\n        {\n          (void) FormatLocaleString(buffer,MaxTextExtent,\"page=%+ld%+ld\\n\",\n            (long) image->page.x,(long) image->page.y);\n          (void) WriteBlobString(image,buffer);\n        }\n    if ((image->tile_offset.x != 0) || (image->tile_offset.y != 0))\n      {\n        (void) FormatLocaleString(buffer,MaxTextExtent,\"tile-offset=%+ld%+ld\\n\",\n          (long) image->tile_offset.x,(long) image->tile_offset.y);\n        (void) WriteBlobString(image,buffer);\n      }\n    if ((GetNextImageInList(image) != (Image *) NULL) ||\n        (GetPreviousImageInList(image) != (Image *) NULL))\n      {\n        if (image->scene == 0)\n          (void) FormatLocaleString(buffer,MaxTextExtent,\n            \"iterations=%.20g  delay=%.20g  ticks-per-second=%.20g\\n\",(double)\n            image->iterations,(double) image->delay,(double)\n            image->ticks_per_second);\n        else\n          (void) FormatLocaleString(buffer,MaxTextExtent,\"scene=%.20g  \"\n            \"iterations=%.20g  delay=%.20g  ticks-per-second=%.20g\\n\",\n            (double) image->scene,(double) image->iterations,(double)\n            image->delay,(double) image->ticks_per_second);\n        (void) WriteBlobString(image,buffer);\n      }\n    else\n      {\n        if (image->scene != 0)\n          {\n            (void) FormatLocaleString(buffer,MaxTextExtent,\"scene=%.20g\\n\",\n              (double) image->scene);\n            (void) WriteBlobString(image,buffer);\n          }\n        if (image->iterations != 0)\n          {\n            (void) FormatLocaleString(buffer,MaxTextExtent,\"iterations=%.20g\\n\",\n              (double) image->iterations);\n            (void) WriteBlobString(image,buffer);\n          }\n        if (image->delay != 0)\n          {\n            (void) FormatLocaleString(buffer,MaxTextExtent,\"delay=%.20g\\n\",\n              (double) image->delay);\n            (void) WriteBlobString(image,buffer);\n          }\n        if (image->ticks_per_second != UndefinedTicksPerSecond)\n          {\n            (void) FormatLocaleString(buffer,MaxTextExtent,\n              \"ticks-per-second=%.20g\\n\",(double) image->ticks_per_second);\n            (void) WriteBlobString(image,buffer);\n          }\n      }\n    if (image->gravity != UndefinedGravity)\n      {\n        (void) FormatLocaleString(buffer,MaxTextExtent,\"gravity=%s\\n\",\n          CommandOptionToMnemonic(MagickGravityOptions,image->gravity));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->dispose != UndefinedDispose)\n      {\n        (void) FormatLocaleString(buffer,MaxTextExtent,\"dispose=%s\\n\",\n          CommandOptionToMnemonic(MagickDisposeOptions,image->dispose));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->rendering_intent != UndefinedIntent)\n      {\n        (void) FormatLocaleString(buffer,MaxTextExtent,\n          \"rendering-intent=%s\\n\",CommandOptionToMnemonic(MagickIntentOptions,\n          image->rendering_intent));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->gamma != 0.0)\n      {\n        (void) FormatLocaleString(buffer,MaxTextExtent,\"gamma=%g\\n\",\n          image->gamma);\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->chromaticity.white_point.x != 0.0)\n      {\n        /*\n          Note chomaticity points.\n        */\n        (void) FormatLocaleString(buffer,MaxTextExtent,\"red-primary=\"\n          \"%g,%g  green-primary=%g,%g  blue-primary=%g,%g\\n\",\n          image->chromaticity.red_primary.x,image->chromaticity.red_primary.y,\n          image->chromaticity.green_primary.x,\n          image->chromaticity.green_primary.y,\n          image->chromaticity.blue_primary.x,\n          image->chromaticity.blue_primary.y);\n        (void) WriteBlobString(image,buffer);\n        (void) FormatLocaleString(buffer,MaxTextExtent,\n          \"white-point=%g,%g\\n\",image->chromaticity.white_point.x,\n          image->chromaticity.white_point.y);\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->orientation != UndefinedOrientation)\n      {\n        (void) FormatLocaleString(buffer,MaxTextExtent,\n          \"orientation=%s\\n\",CommandOptionToMnemonic(MagickOrientationOptions,\n          image->orientation));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->profiles != (void *) NULL)\n      {\n        const char\n          *name;\n\n        const StringInfo\n          *profile;\n\n        /*\n          Generic profile.\n        */\n        ResetImageProfileIterator(image);\n        for (name=GetNextImageProfile(image); name != (const char *) NULL; )\n        {\n          profile=GetImageProfile(image,name);\n          if (profile != (StringInfo *) NULL)\n            {\n              (void) FormatLocaleString(buffer,MaxTextExtent,\n                \"profile:%s=%.20g\\n\",name,(double)\n                GetStringInfoLength(profile));\n              (void) WriteBlobString(image,buffer);\n            }\n          name=GetNextImageProfile(image);\n        }\n      }\n    if (image->montage != (char *) NULL)\n      {\n        (void) FormatLocaleString(buffer,MaxTextExtent,\"montage=%s\\n\",\n          image->montage);\n        (void) WriteBlobString(image,buffer);\n      }\n    ResetImagePropertyIterator(image);\n    property=GetNextImageProperty(image);\n    while (property != (const char *) NULL)\n    {\n      (void) FormatLocaleString(buffer,MaxTextExtent,\"%s=\",property);\n      (void) WriteBlobString(image,buffer);\n      value=GetImageProperty(image,property);\n      if (value != (const char *) NULL)\n        {\n          size_t\n            length;\n\n          length=strlen(value);\n          for (i=0; i < (ssize_t) length; i++)\n            if (isspace((int) ((unsigned char) value[i])) != 0)\n              break;\n          if ((i == (ssize_t) length) && (i != 0))\n            (void) WriteBlob(image,length,(const unsigned char *) value);\n          else\n            {\n              (void) WriteBlobByte(image,'{');\n              if (strchr(value,'}') == (char *) NULL)\n                (void) WriteBlob(image,length,(const unsigned char *) value);\n              else\n                for (i=0; i < (ssize_t) length; i++)\n                {\n                  if (value[i] == (int) '}')\n                    (void) WriteBlobByte(image,'\\\\');\n                  (void) WriteBlobByte(image,value[i]);\n                }\n              (void) WriteBlobByte(image,'}');\n            }\n        }\n      (void) WriteBlobByte(image,'\\n');\n      property=GetNextImageProperty(image);\n    }\n    (void) WriteBlobString(image,\"\\f\\n:\\032\");\n    if (image->montage != (char *) NULL)\n      {\n        /*\n          Write montage tile directory.\n        */\n        if (image->directory != (char *) NULL)\n          (void) WriteBlobString(image,image->directory);\n        (void) WriteBlobByte(image,'\\0');\n      }\n    if (image->profiles != 0)\n      {\n        const char\n          *name;\n\n        const StringInfo\n          *profile;\n\n        /*\n          Write image profiles.\n        */\n        ResetImageProfileIterator(image);\n        name=GetNextImageProfile(image);\n        while (name != (const char *) NULL)\n        {\n          profile=GetImageProfile(image,name);\n          (void) WriteBlob(image,GetStringInfoLength(profile),\n            GetStringInfoDatum(profile));\n          name=GetNextImageProfile(image);\n        }\n      }\n    if (image->storage_class == PseudoClass)\n      {\n        size_t\n          packet_size;\n\n        unsigned char\n          *colormap,\n          *q;\n\n        /*\n          Allocate colormap.\n        */\n        packet_size=(size_t) (3UL*depth/8UL);\n        colormap=(unsigned char *) AcquireQuantumMemory(image->colors,\n          packet_size*sizeof(*colormap));\n        if (colormap == (unsigned char *) NULL)\n          return(MagickFalse);\n        /*\n          Write colormap to file.\n        */\n        q=colormap;\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          switch (depth)\n          {\n            default:\n              ThrowWriterException(CorruptImageError,\"ImageDepthNotSupported\");\n            case 32:\n            {\n              unsigned int\n                pixel;\n\n              pixel=ScaleQuantumToLong(image->colormap[i].red);\n              q=PopLongPixel(MSBEndian,pixel,q);\n              pixel=ScaleQuantumToLong(image->colormap[i].green);\n              q=PopLongPixel(MSBEndian,pixel,q);\n              pixel=ScaleQuantumToLong(image->colormap[i].blue);\n              q=PopLongPixel(MSBEndian,pixel,q);\n              break;\n            }\n            case 16:\n            {\n              unsigned short\n                pixel;\n\n              pixel=ScaleQuantumToShort(image->colormap[i].red);\n              q=PopShortPixel(MSBEndian,pixel,q);\n              pixel=ScaleQuantumToShort(image->colormap[i].green);\n              q=PopShortPixel(MSBEndian,pixel,q);\n              pixel=ScaleQuantumToShort(image->colormap[i].blue);\n              q=PopShortPixel(MSBEndian,pixel,q);\n              break;\n            }\n            case 8:\n            {\n              unsigned char\n                pixel;\n\n              pixel=(unsigned char) ScaleQuantumToChar(image->colormap[i].red);\n              q=PopCharPixel(pixel,q);\n              pixel=(unsigned char) ScaleQuantumToChar(\n                image->colormap[i].green);\n              q=PopCharPixel(pixel,q);\n              pixel=(unsigned char) ScaleQuantumToChar(image->colormap[i].blue);\n              q=PopCharPixel(pixel,q);\n              break;\n            }\n          }\n        }\n        (void) WriteBlob(image,packet_size*image->colors,colormap);\n        colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n      }\n    /*\n      Initialize persistent pixel cache.\n    */\n    status=PersistPixelCache(image,cache_filename,MagickFalse,&offset,\n      &image->exception);\n    if (status == MagickFalse)\n      ThrowWriterException(CacheError,\"UnableToPersistPixelCache\");\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        status=image->progress_monitor(SaveImagesTag,scene,\n          GetImageListLength(image),image->client_data);\n        if (status == MagickFalse)\n          break;\n      }\n    scene++;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(status);\n}\n"], "filenames": ["coders/mpc.c"], "buggy_code_start_loc": [1016], "buggy_code_end_loc": [1017], "fixing_code_start_loc": [1015], "fixing_code_end_loc": [1015], "type": "NVD-CWE-noinfo", "message": "coders/mpc.c in ImageMagick before 7.0.6-1 does not enable seekable streams and thus cannot validate blob sizes, which allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via an image received from stdin.", "other": {"cve": {"id": "CVE-2017-11449", "sourceIdentifier": "cve@mitre.org", "published": "2017-07-19T07:29:00.550", "lastModified": "2021-04-20T15:37:22.547", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "coders/mpc.c in ImageMagick before 7.0.6-1 does not enable seekable streams and thus cannot validate blob sizes, which allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via an image received from stdin."}, {"lang": "es", "value": "El archivo coders/mpc.c en ImageMagick anterior a versi\u00f3n 7.0.6-1, no habilita transmisiones visibles y, por lo tanto, no puede comprobar los tama\u00f1os de blob, lo que permite a los atacantes remotos causar una denegaci\u00f3n de servicio (bloqueo de aplicaci\u00f3n) o posiblemente tener otro impacto no especificado por medio de una imagen recibida de stdin."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.9.9-0", "matchCriteriaId": "4418E9AC-8B0E-4C0C-9B70-21FF197441FD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.0.0-0", "versionEndExcluding": "7.0.6-1", "matchCriteriaId": "FB5FB6BA-15D2-4169-BF8D-6102E106080B"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/99958", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=867896", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/529ff26b68febb2ac03062c58452ea0b4c6edbc1", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/b007dd3a048097d8f58949297f5b434612e1e1a3", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/issues/556", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/529ff26b68febb2ac03062c58452ea0b4c6edbc1"}}