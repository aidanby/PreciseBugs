{"buggy_code": ["/*\n *  Copyright (c) 2015-present, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\n#include \"StructuredHeadersUtilities.h\"\n#include <boost/archive/iterators/binary_from_base64.hpp>\n#include <boost/archive/iterators/base64_from_binary.hpp>\n#include <boost/archive/iterators/transform_width.hpp>\n#include \"StructuredHeadersConstants.h\"\n\nnamespace proxygen {\nnamespace StructuredHeaders {\n\nbool isLcAlpha(char c) {\n  return c >= 0x61 && c <= 0x7A;\n}\n\nbool isValidIdentifierChar(char c) {\n  return isLcAlpha(c) || std::isdigit(c) || c == '_' || c == '-' || c == '*' ||\n    c == '/';\n}\n\nbool isValidEncodedBinaryContentChar(\n   char c) {\n  return std::isalpha(c) || std::isdigit(c) || c == '+' || c == '/' || c == '=';\n}\n\nbool isValidStringChar(char c) {\n  /*\n  * The difference between the character restriction here and that mentioned\n  * in section 3.7 of version 6 of the Structured Headers draft is that this\n  * function accepts \\ and DQUOTE characters. These characters are allowed\n  * as long as they are present as a part of an escape sequence, which is\n  * checked for in the parseString() function in the StructuredHeadersBuffer.\n  */\n  return c >= 0x20 && c <= 0x7E;\n}\n\nbool isValidIdentifier(const std::string& s) {\n  if (s.size() == 0 || !isLcAlpha(s[0])) {\n    return false;\n  }\n\n  for (char c : s) {\n    if (!isValidIdentifierChar(c)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nbool isValidString(const std::string& s) {\n  for (char c : s) {\n    if (!isValidStringChar(c)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nbool isValidEncodedBinaryContent(\n  const std::string& s) {\n\n  if (s.size() % 4 != 0) {\n    return false;\n  }\n\n  bool equalSeen = false;\n  for (auto it = s.begin(); it != s.end(); it++) {\n    if (*it == '=') {\n      equalSeen = true;\n    } else if (equalSeen || !isValidEncodedBinaryContentChar(*it)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nbool itemTypeMatchesContent(\n   const StructuredHeaderItem& input) {\n  switch (input.tag) {\n    case StructuredHeaderItem::Type::BINARYCONTENT:\n    case StructuredHeaderItem::Type::IDENTIFIER:\n    case StructuredHeaderItem::Type::STRING:\n      return input.value.type() == typeid(std::string);\n    case StructuredHeaderItem::Type::INT64:\n      return input.value.type() == typeid(int64_t);\n    case StructuredHeaderItem::Type::DOUBLE:\n      return input.value.type() == typeid(double);\n    case StructuredHeaderItem::Type::NONE:\n      return true;\n  }\n\n  return false;\n}\n\nstd::string decodeBase64(\n    const std::string& encoded) {\n\n  if (encoded.size() == 0) {\n    // special case, to prevent an integer overflow down below.\n    return \"\";\n  }\n\n  using namespace boost::archive::iterators;\n  using b64it =\n    transform_width<binary_from_base64<std::string::const_iterator>, 8, 6>;\n\n  std::string decoded = std::string(b64it(std::begin(encoded)),\n                                    b64it(std::end(encoded)));\n\n  uint32_t numPadding = std::count(encoded.begin(), encoded.end(), '=');\n  decoded.erase(decoded.end() - numPadding, decoded.end());\n\n  return decoded;\n}\n\nstd::string encodeBase64(const std::string& input) {\n  using namespace boost::archive::iterators;\n  using b64it = base64_from_binary<transform_width<const char*, 6, 8>>;\n\n  auto data = input.data();\n  std::string encoded(b64it(data), b64it(data + (input.length())));\n  encoded.append((3 - (input.length() % 3)) % 3, '=');\n\n  return encoded;\n}\n\n}\n}\n"], "fixing_code": ["/*\n *  Copyright (c) 2015-present, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\n#include \"StructuredHeadersUtilities.h\"\n#include \"StructuredHeadersConstants.h\"\n\n#include \"proxygen/lib/utils/Base64.h\"\n\nnamespace proxygen {\nnamespace StructuredHeaders {\n\nbool isLcAlpha(char c) {\n  return c >= 0x61 && c <= 0x7A;\n}\n\nbool isValidIdentifierChar(char c) {\n  return isLcAlpha(c) || std::isdigit(c) || c == '_' || c == '-' || c == '*' ||\n    c == '/';\n}\n\nbool isValidEncodedBinaryContentChar(\n   char c) {\n  return std::isalpha(c) || std::isdigit(c) || c == '+' || c == '/' || c == '=';\n}\n\nbool isValidStringChar(char c) {\n  /*\n  * The difference between the character restriction here and that mentioned\n  * in section 3.7 of version 6 of the Structured Headers draft is that this\n  * function accepts \\ and DQUOTE characters. These characters are allowed\n  * as long as they are present as a part of an escape sequence, which is\n  * checked for in the parseString() function in the StructuredHeadersBuffer.\n  */\n  return c >= 0x20 && c <= 0x7E;\n}\n\nbool isValidIdentifier(const std::string& s) {\n  if (s.size() == 0 || !isLcAlpha(s[0])) {\n    return false;\n  }\n\n  for (char c : s) {\n    if (!isValidIdentifierChar(c)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nbool isValidString(const std::string& s) {\n  for (char c : s) {\n    if (!isValidStringChar(c)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nbool isValidEncodedBinaryContent(\n  const std::string& s) {\n\n  if (s.size() % 4 != 0) {\n    return false;\n  }\n\n  bool equalSeen = false;\n  for (auto it = s.begin(); it != s.end(); it++) {\n    if (*it == '=') {\n      equalSeen = true;\n    } else if (equalSeen || !isValidEncodedBinaryContentChar(*it)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nbool itemTypeMatchesContent(\n   const StructuredHeaderItem& input) {\n  switch (input.tag) {\n    case StructuredHeaderItem::Type::BINARYCONTENT:\n    case StructuredHeaderItem::Type::IDENTIFIER:\n    case StructuredHeaderItem::Type::STRING:\n      return input.value.type() == typeid(std::string);\n    case StructuredHeaderItem::Type::INT64:\n      return input.value.type() == typeid(int64_t);\n    case StructuredHeaderItem::Type::DOUBLE:\n      return input.value.type() == typeid(double);\n    case StructuredHeaderItem::Type::NONE:\n      return true;\n  }\n\n  return false;\n}\n\nstd::string decodeBase64(\n    const std::string& encoded) {\n\n  if (encoded.size() == 0) {\n    // special case, to prevent an integer overflow down below.\n    return std::string();\n  }\n\n  int padding = 0;\n  for (auto it = encoded.rbegin();\n       padding < 2 && it != encoded.rend() && *it == '=';\n       ++it) {\n    ++padding;\n  }\n\n  return Base64::decode(encoded, padding);\n}\n\nstd::string encodeBase64(const std::string& input) {\n  return Base64::encode(folly::ByteRange(\n                            reinterpret_cast<const uint8_t*>(input.c_str()),\n                            input.length()));\n}\n\n}\n}\n"], "filenames": ["proxygen/lib/http/structuredheaders/StructuredHeadersUtilities.cpp"], "buggy_code_start_loc": [12], "buggy_code_end_loc": [135], "fixing_code_start_loc": [11], "fixing_code_end_loc": [126], "type": "CWE-787", "message": "An out of bounds write is possible via a specially crafted packet in certain configurations of Proxygen due to improper handling of Base64 when parsing malformed binary content in Structured HTTP Headers. This issue affects versions of proxygen prior to v2019.07.22.00.", "other": {"cve": {"id": "CVE-2019-11921", "sourceIdentifier": "cve-assign@fb.com", "published": "2019-07-25T21:15:11.537", "lastModified": "2019-08-02T20:43:25.177", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An out of bounds write is possible via a specially crafted packet in certain configurations of Proxygen due to improper handling of Base64 when parsing malformed binary content in Structured HTTP Headers. This issue affects versions of proxygen prior to v2019.07.22.00."}, {"lang": "es", "value": "Una escritura fuera de l\u00edmites es posible a trav\u00e9s de un paquete especialmente dise\u00f1ado en ciertas configuraciones de Proxygen debido al manejo inadecuado de Base64 cuando se analiza contenido binario mal formado en Structured HTTP Headers. Este problema afecta a las versiones de proxygen anteriores a v2019.07.22.00."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:facebook:proxygen:*:*:*:*:*:*:*:*", "versionEndExcluding": "2019.07.22.00", "matchCriteriaId": "A96606CA-C503-4426-87A8-92320F4619E1"}]}]}], "references": [{"url": "https://github.com/facebook/proxygen/commit/2f07985bef9fbae124cc63e5c0272e32da4fdaec", "source": "cve-assign@fb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.facebook.com/security/advisories/cve-2019-11921", "source": "cve-assign@fb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/facebook/proxygen/commit/2f07985bef9fbae124cc63e5c0272e32da4fdaec"}}