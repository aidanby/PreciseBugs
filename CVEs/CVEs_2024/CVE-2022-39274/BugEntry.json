{"buggy_code": ["/*!\r\n * \\file      LoRaMac.c\r\n *\r\n * \\brief     LoRa MAC layer implementation\r\n *\r\n * \\copyright Revised BSD License, see section \\ref LICENSE.\r\n *\r\n * \\code\r\n *                ______                              _\r\n *               / _____)             _              | |\r\n *              ( (____  _____ ____ _| |_ _____  ____| |__\r\n *               \\____ \\| ___ |    (_   _) ___ |/ ___)  _ \\\r\n *               _____) ) ____| | | || |_| ____( (___| | | |\r\n *              (______/|_____)_|_|_| \\__)_____)\\____)_| |_|\r\n *              (C)2013-2017 Semtech\r\n *\r\n *               ___ _____ _   ___ _  _____ ___  ___  ___ ___\r\n *              / __|_   _/_\\ / __| |/ / __/ _ \\| _ \\/ __| __|\r\n *              \\__ \\ | |/ _ \\ (__| ' <| _| (_) |   / (__| _|\r\n *              |___/ |_/_/ \\_\\___|_|\\_\\_| \\___/|_|_\\\\___|___|\r\n *              embedded.connectivity.solutions===============\r\n *\r\n * \\endcode\r\n *\r\n * \\author    Miguel Luis ( Semtech )\r\n *\r\n * \\author    Gregory Cristian ( Semtech )\r\n *\r\n * \\author    Daniel Jaeckle ( STACKFORCE )\r\n *\r\n * \\author    Johannes Bruder ( STACKFORCE )\r\n */\r\n#include \"utilities.h\"\r\n#include \"region/Region.h\"\r\n#include \"LoRaMacClassB.h\"\r\n#include \"LoRaMacCrypto.h\"\r\n#include \"secure-element.h\"\r\n#include \"LoRaMacTest.h\"\r\n#include \"LoRaMacTypes.h\"\r\n#include \"LoRaMacConfirmQueue.h\"\r\n#include \"LoRaMacHeaderTypes.h\"\r\n#include \"LoRaMacMessageTypes.h\"\r\n#include \"LoRaMacParser.h\"\r\n#include \"LoRaMacCommands.h\"\r\n#include \"LoRaMacAdr.h\"\r\n#include \"LoRaMacSerializer.h\"\r\n#include \"radio.h\"\r\n\r\n#include \"LoRaMac.h\"\r\n\r\n/*!\r\n * Maximum PHY layer payload size\r\n */\r\n#define LORAMAC_PHY_MAXPAYLOAD                      255\r\n\r\n/*!\r\n * Maximum length of the fOpts field\r\n */\r\n#define LORA_MAC_COMMAND_MAX_FOPTS_LENGTH           15\r\n\r\n/*!\r\n * LoRaMac duty cycle for the back-off procedure during the first hour.\r\n */\r\n#define BACKOFF_DC_1_HOUR                           100\r\n\r\n/*!\r\n * LoRaMac duty cycle for the back-off procedure during the next 10 hours.\r\n */\r\n#define BACKOFF_DC_10_HOURS                         1000\r\n\r\n/*!\r\n * LoRaMac duty cycle for the back-off procedure during the next 24 hours.\r\n */\r\n#define BACKOFF_DC_24_HOURS                         10000\r\n\r\n/*!\r\n * Maximum value for the ADR ack counter\r\n */\r\n#define ADR_ACK_COUNTER_MAX                         0xFFFFFFFF\r\n\r\n/*!\r\n * LoRaMac internal states\r\n */\r\nenum eLoRaMacState\r\n{\r\n    LORAMAC_IDLE          = 0x00000000,\r\n    LORAMAC_STOPPED       = 0x00000001,\r\n    LORAMAC_TX_RUNNING    = 0x00000002,\r\n    LORAMAC_RX            = 0x00000004,\r\n    LORAMAC_ACK_RETRY     = 0x00000010,\r\n    LORAMAC_TX_DELAYED    = 0x00000020,\r\n    LORAMAC_TX_CONFIG     = 0x00000040,\r\n    LORAMAC_RX_ABORT      = 0x00000080,\r\n};\r\n\r\n/*\r\n * Request permission state\r\n */\r\ntypedef enum eLoRaMacRequestHandling\r\n{\r\n    LORAMAC_REQUEST_HANDLING_OFF = 0,\r\n    LORAMAC_REQUEST_HANDLING_ON = !LORAMAC_REQUEST_HANDLING_OFF\r\n}LoRaMacRequestHandling_t;\r\n\r\ntypedef struct sLoRaMacCtx\r\n{\r\n    /*\r\n    * Length of packet in PktBuffer\r\n    */\r\n    uint16_t PktBufferLen;\r\n    /*\r\n    * Buffer containing the data to be sent or received.\r\n    */\r\n    uint8_t PktBuffer[LORAMAC_PHY_MAXPAYLOAD];\r\n    /*!\r\n    * Current processed transmit message\r\n    */\r\n    LoRaMacMessage_t TxMsg;\r\n    /*!\r\n    * Buffer containing the data received by the application.\r\n    */\r\n    uint8_t AppData[LORAMAC_PHY_MAXPAYLOAD];\r\n    /*\r\n    * Size of buffer containing the application data.\r\n    */\r\n    uint8_t AppDataSize;\r\n    /*\r\n    * Buffer containing the upper layer data.\r\n    */\r\n    uint8_t RxPayload[LORAMAC_PHY_MAXPAYLOAD];\r\n    SysTime_t LastTxSysTime;\r\n    /*\r\n    * LoRaMac internal state\r\n    */\r\n    uint32_t MacState;\r\n    /*\r\n    * LoRaMac upper layer event functions\r\n    */\r\n    LoRaMacPrimitives_t* MacPrimitives;\r\n    /*\r\n    * LoRaMac upper layer callback functions\r\n    */\r\n    LoRaMacCallback_t* MacCallbacks;\r\n    /*\r\n    * Radio events function pointer\r\n    */\r\n    RadioEvents_t RadioEvents;\r\n    /*\r\n    * LoRaMac duty cycle delayed Tx timer\r\n    */\r\n    TimerEvent_t TxDelayedTimer;\r\n    /*\r\n    * LoRaMac reception windows timers\r\n    */\r\n    TimerEvent_t RxWindowTimer1;\r\n    TimerEvent_t RxWindowTimer2;\r\n    /*\r\n    * LoRaMac reception windows delay\r\n    * \\remark normal frame: RxWindowXDelay = ReceiveDelayX - RADIO_WAKEUP_TIME\r\n    *         join frame  : RxWindowXDelay = JoinAcceptDelayX - RADIO_WAKEUP_TIME\r\n    */\r\n    uint32_t RxWindow1Delay;\r\n    uint32_t RxWindow2Delay;\r\n    /*\r\n    * LoRaMac Rx windows configuration\r\n    */\r\n    RxConfigParams_t RxWindow1Config;\r\n    RxConfigParams_t RxWindow2Config;\r\n    RxConfigParams_t RxWindowCConfig;\r\n    /*\r\n    * Acknowledge timeout timer. Used for packet retransmissions.\r\n    */\r\n    TimerEvent_t RetransmitTimeoutTimer;\r\n    /*\r\n     * Uplink messages repetitions counter\r\n     */\r\n    uint8_t ChannelsNbTransCounter;\r\n    /*\r\n     * Indicates if the AckTimeout timer has expired or not\r\n     */\r\n    bool RetransmitTimeoutRetry;\r\n    /*\r\n     * If the node has sent a FRAME_TYPE_DATA_CONFIRMED_UP this variable indicates\r\n     * if the nodes needs to manage the server acknowledgement.\r\n     */\r\n    bool NodeAckRequested;\r\n    /*\r\n     * Current channel index\r\n     */\r\n    uint8_t Channel;\r\n    /*\r\n    * Last transmission time on air\r\n    */\r\n    TimerTime_t TxTimeOnAir;\r\n    /*\r\n    * Structure to hold an MCPS indication data.\r\n    */\r\n    McpsIndication_t McpsIndication;\r\n    /*\r\n    * Structure to hold MCPS confirm data.\r\n    */\r\n    McpsConfirm_t McpsConfirm;\r\n    /*\r\n    * Structure to hold MLME confirm data.\r\n    */\r\n    MlmeConfirm_t MlmeConfirm;\r\n    /*\r\n    * Structure to hold MLME indication data.\r\n    */\r\n    MlmeIndication_t MlmeIndication;\r\n    /*\r\n    * Holds the current rx window slot\r\n    */\r\n    LoRaMacRxSlot_t RxSlot;\r\n    /*\r\n    * LoRaMac tx/rx operation state\r\n    */\r\n    LoRaMacFlags_t MacFlags;\r\n    /*\r\n    * Data structure indicating if a request is allowed or not.\r\n    */\r\n    LoRaMacRequestHandling_t AllowRequests;\r\n    /*\r\n    * Cycle timer for Type 0 Rejoin requests\r\n    */\r\n    TimerEvent_t Rejoin0CycleTimer;\r\n    /*\r\n    * Cycle timer for Type 1 Rejoin requests\r\n    */\r\n    TimerEvent_t Rejoin1CycleTimer;\r\n    /*\r\n    * Cycle timer for Rejoin requests trigged by ForceRejoinReq MAC command\r\n    */\r\n    TimerEvent_t ForceRejoinReqCycleTimer;\r\n    /*\r\n    * Time of Type 0 Rejoin requests cycles\r\n    */\r\n    TimerTime_t Rejoin0CycleTime;\r\n    /*\r\n    * Time of Type 1 Rejoin requests cycles\r\n    */\r\n    TimerTime_t Rejoin1CycleTime;\r\n    /*\r\n    * Time of Force Rejoin requests cycles\r\n    */\r\n    TimerTime_t ForceRejonCycleTime;\r\n    /*\r\n    * Duty cycle wait time\r\n    */\r\n    TimerTime_t DutyCycleWaitTime;\r\n    /*\r\n     * Start time of the response timeout\r\n     */\r\n    TimerTime_t ResponseTimeoutStartTime;\r\n    /*\r\n     * Buffer containing the MAC layer commands\r\n     */\r\n    uint8_t MacCommandsBuffer[LORA_MAC_COMMAND_MAX_LENGTH];\r\n}LoRaMacCtx_t;\r\n\r\n/*\r\n * Module context.\r\n */\r\nstatic LoRaMacCtx_t MacCtx;\r\n\r\nstatic LoRaMacNvmData_t Nvm;\r\n\r\nstatic Band_t RegionBands[REGION_NVM_MAX_NB_BANDS];\r\n\r\n/*!\r\n * Defines the LoRaMac radio events status\r\n */\r\ntypedef union uLoRaMacRadioEvents\r\n{\r\n    uint32_t Value;\r\n    struct sEvents\r\n    {\r\n        uint32_t RxProcessPending : 1;\r\n        uint32_t RxTimeout        : 1;\r\n        uint32_t RxError          : 1;\r\n        uint32_t TxTimeout        : 1;\r\n        uint32_t RxDone           : 1;\r\n        uint32_t TxDone           : 1;\r\n    }Events;\r\n}LoRaMacRadioEvents_t;\r\n\r\n/*!\r\n * LoRaMac radio events status\r\n */\r\nLoRaMacRadioEvents_t LoRaMacRadioEvents = { .Value = 0 };\r\n\r\n/*!\r\n * \\brief Function to be executed on Radio Tx Done event\r\n */\r\nstatic void OnRadioTxDone( void );\r\n\r\n/*!\r\n * \\brief This function prepares the MAC to abort the execution of function\r\n *        OnRadioRxDone in case of a reception error.\r\n */\r\nstatic void PrepareRxDoneAbort( void );\r\n\r\n/*!\r\n * \\brief Function to be executed on Radio Rx Done event\r\n */\r\nstatic void OnRadioRxDone( uint8_t* payload, uint16_t size, int16_t rssi, int8_t snr );\r\n\r\n/*!\r\n * \\brief Function executed on Radio Tx Timeout event\r\n */\r\nstatic void OnRadioTxTimeout( void );\r\n\r\n/*!\r\n * \\brief Function executed on Radio Rx error event\r\n */\r\nstatic void OnRadioRxError( void );\r\n\r\n/*!\r\n * \\brief Function executed on Radio Rx Timeout event\r\n */\r\nstatic void OnRadioRxTimeout( void );\r\n\r\n/*!\r\n * \\brief Function executed on duty cycle delayed Tx  timer event\r\n */\r\nstatic void OnTxDelayedTimerEvent( void* context );\r\n\r\n/*!\r\n * \\brief Function executed on first Rx window timer event\r\n */\r\nstatic void OnRxWindow1TimerEvent( void* context );\r\n\r\n/*!\r\n * \\brief Function executed on second Rx window timer event\r\n */\r\nstatic void OnRxWindow2TimerEvent( void* context );\r\n\r\n/*!\r\n * \\brief Function executed on Rejoin Type 0 cycle timer event\r\n */\r\nstatic void OnRejoin0CycleTimerEvent( void* context );\r\n\r\n/*!\r\n * \\brief Function executed on Rejoin Type 0 cycle timer event\r\n */\r\nstatic void OnRejoin1CycleTimerEvent( void* context );\r\n\r\n/*!\r\n * \\brief Function executed on Rejoin Type 0 or 2 cycle timer event\r\n *        which was requested by a ForceRejoinReq MAC command.\r\n */\r\nstatic void OnForceRejoinReqCycleTimerEvent( void* context );\r\n\r\n/*!\r\n * \\brief Function executed on AckTimeout timer event\r\n */\r\nstatic void OnRetransmitTimeoutTimerEvent( void* context );\r\n\r\n/*!\r\n * Computes next 32 bit downlink counter value and determines the frame counter ID.\r\n *\r\n * \\param[IN]     addrID                - Address identifier\r\n * \\param[IN]     fType                 - Frame type\r\n * \\param[IN]     macMsg                - Data message object, holding the current 16 bit transmitted frame counter\r\n * \\param[IN]     lrWanVersion          - LoRaWAN version\r\n * \\param[OUT]    fCntID                - Frame counter identifier\r\n * \\param[OUT]    currentDown           - Current downlink counter value\r\n *\r\n * \\retval                              - Status of the operation\r\n */\r\nstatic LoRaMacCryptoStatus_t GetFCntDown( AddressIdentifier_t addrID, FType_t fType, LoRaMacMessageData_t* macMsg, Version_t lrWanVersion,\r\n                                          FCntIdentifier_t* fCntID, uint32_t* currentDown );\r\n\r\n/*!\r\n * \\brief Switches the device class\r\n *\r\n * \\param [IN] deviceClass Device class to switch to\r\n */\r\nstatic LoRaMacStatus_t SwitchClass( DeviceClass_t deviceClass );\r\n\r\n/*!\r\n * \\brief Gets the maximum application payload length in the absence of the optional FOpt field.\r\n *\r\n * \\param [IN] datarate        Current datarate\r\n *\r\n * \\retval                    Max length\r\n */\r\nstatic uint8_t GetMaxAppPayloadWithoutFOptsLength( int8_t datarate );\r\n\r\n/*!\r\n * \\brief Validates if the payload fits into the frame, taking the datarate\r\n *        into account.\r\n *\r\n * \\details Refer to chapter 4.3.2 of the LoRaWAN specification, v1.0\r\n *\r\n * \\param lenN Length of the application payload. The length depends on the\r\n *             datarate and is region specific\r\n *\r\n * \\param datarate Current datarate\r\n *\r\n * \\param fOptsLen Length of the fOpts field\r\n *\r\n * \\retval [false: payload does not fit into the frame, true: payload fits into\r\n *          the frame]\r\n */\r\nstatic bool ValidatePayloadLength( uint8_t lenN, int8_t datarate, uint8_t fOptsLen );\r\n\r\n/*!\r\n * \\brief Decodes MAC commands in the fOpts field and in the payload\r\n *\r\n * \\param [IN] payload      A pointer to the payload\r\n * \\param [IN] macIndex     The index of the payload where the MAC commands start\r\n * \\param [IN] commandsSize The size of the MAC commands\r\n * \\param [IN] snr          The SNR value  of the frame\r\n * \\param [IN] rxSlot       The RX slot where the frame was received\r\n */\r\nstatic void ProcessMacCommands( uint8_t* payload, uint8_t macIndex, uint8_t commandsSize, int8_t snr, LoRaMacRxSlot_t rxSlot );\r\n\r\n/*!\r\n * \\brief LoRaMAC layer generic send frame\r\n *\r\n * \\param [IN] macHdr      MAC header field\r\n * \\param [IN] fPort       MAC payload port\r\n * \\param [IN] fBuffer     MAC data buffer to be sent\r\n * \\param [IN] fBufferSize MAC data buffer size\r\n * \\retval status          Status of the operation.\r\n */\r\nLoRaMacStatus_t Send( LoRaMacHeader_t* macHdr, uint8_t fPort, void* fBuffer, uint16_t fBufferSize );\r\n\r\n/*!\r\n * \\brief LoRaMAC layer send join/rejoin request\r\n *\r\n * \\param [IN] joinReqType Type of join-request or rejoin\r\n *\r\n * \\retval status          Status of the operation.\r\n */\r\nLoRaMacStatus_t SendReJoinReq( JoinReqIdentifier_t joinReqType );\r\n\r\n/*!\r\n * \\brief LoRaMAC layer frame buffer initialization\r\n *\r\n * \\param [IN] macHdr      MAC header field\r\n * \\param [IN] fCtrl       MAC frame control field\r\n * \\param [IN] fOpts       MAC commands buffer\r\n * \\param [IN] fPort       MAC payload port\r\n * \\param [IN] fBuffer     MAC data buffer to be sent\r\n * \\param [IN] fBufferSize MAC data buffer size\r\n * \\retval status          Status of the operation.\r\n */\r\nLoRaMacStatus_t PrepareFrame( LoRaMacHeader_t* macHdr, LoRaMacFrameCtrl_t* fCtrl, uint8_t fPort, void* fBuffer, uint16_t fBufferSize );\r\n\r\n/*\r\n * \\brief Schedules the frame according to the duty cycle\r\n *\r\n * \\param [IN] allowDelayedTx When set to true, the a frame will be delayed,\r\n *                            the duty cycle restriction is active\r\n * \\retval Status of the operation\r\n */\r\nstatic LoRaMacStatus_t ScheduleTx( bool allowDelayedTx );\r\n\r\n/*\r\n * \\brief Secures the current processed frame ( TxMsg )\r\n * \\param[IN]     txDr      Data rate used for the transmission\r\n * \\param[IN]     txCh      Index of the channel used for the transmission\r\n * \\retval status           Status of the operation\r\n */\r\nstatic LoRaMacStatus_t SecureFrame( uint8_t txDr, uint8_t txCh );\r\n\r\n/*\r\n * \\brief Calculates the aggregated back off time.\r\n */\r\nstatic void CalculateBackOff( void );\r\n\r\n/*\r\n * \\brief Function to remove pending MAC commands\r\n *\r\n * \\param [IN] rxSlot     The RX slot on which the frame was received\r\n * \\param [IN] fCtrl      The frame control field of the received frame\r\n * \\param [IN] request    The request type\r\n */\r\nstatic void RemoveMacCommands( LoRaMacRxSlot_t rxSlot, LoRaMacFrameCtrl_t fCtrl, Mcps_t request );\r\n\r\n/*!\r\n * \\brief LoRaMAC layer prepared frame buffer transmission with channel specification\r\n *\r\n * \\remark PrepareFrame must be called at least once before calling this\r\n *         function.\r\n *\r\n * \\param [IN] channel     Channel to transmit on\r\n * \\retval status          Status of the operation.\r\n */\r\nLoRaMacStatus_t SendFrameOnChannel( uint8_t channel );\r\n\r\n/*!\r\n * \\brief Sets the radio in continuous transmission mode\r\n *\r\n * \\remark Uses the radio parameters set on the previous transmission.\r\n *\r\n * \\param [IN] timeout     Time in seconds while the radio is kept in continuous wave mode\r\n * \\param [IN] frequency   RF frequency to be set.\r\n * \\param [IN] power       RF output power to be set.\r\n * \\retval status          Status of the operation.\r\n */\r\nLoRaMacStatus_t SetTxContinuousWave( uint16_t timeout, uint32_t frequency, uint8_t power );\r\n\r\n/*!\r\n * \\brief Converts a second based Rejoin Cycle base in the from timer module required format.\r\n *\r\n * \\param [IN]  rejoinCycleTime     The time in second\r\n * \\param [out] timeInMiliSec       The time in second\r\n * \\retval status          Status of the operation.\r\n */\r\nstatic bool ConvertRejoinCycleTime( uint32_t rejoinCycleTime, uint32_t* timeInMiliSec );\r\n\r\n/*!\r\n * \\brief Resets MAC specific parameters to default\r\n *\r\n * \\param [in] isRejoin             Reset activation or not.\r\n */\r\nstatic void ResetMacParameters( bool isRejoin );\r\n\r\n/*!\r\n * \\brief Checks if it's required to send a Rejoin (Type 0) request.\r\n *\r\n * \\retval [false: Rejoin not required, true: Rejoin required]\r\n */\r\nstatic bool IsReJoin0Required( void );\r\n\r\n/*!\r\n * \\brief Initializes and opens the reception window\r\n *\r\n * \\param [IN] rxTimer  Window timer to be topped.\r\n * \\param [IN] rxConfig Window parameters to be setup\r\n */\r\nstatic void RxWindowSetup( TimerEvent_t* rxTimer, RxConfigParams_t* rxConfig );\r\n\r\n/*!\r\n * \\brief Opens up a continuous RX C window. This is used for\r\n *        class c devices.\r\n */\r\nstatic void OpenContinuousRxCWindow( void );\r\n\r\n/*!\r\n * \\brief   Returns a pointer to the internal contexts structure.\r\n *\r\n * \\retval  void Points to a structure containing all contexts\r\n */\r\nstatic LoRaMacNvmData_t* GetNvmData( void );\r\n\r\n/*!\r\n * \\brief   Restoring of internal module contexts\r\n *\r\n * \\details This function allows to restore module contexts by a given pointer.\r\n *\r\n *\r\n * \\retval  LoRaMacStatus_t Status of the operation. Possible returns are:\r\n *          returns are:\r\n *          \\ref LORAMAC_STATUS_OK,\r\n *          \\ref LORAMAC_STATUS_PARAMETER_INVALID,\r\n */\r\nstatic LoRaMacStatus_t RestoreNvmData( LoRaMacNvmData_t* contexts );\r\n\r\n/*!\r\n * \\brief   Determines the frame type\r\n *\r\n * \\param [IN] macMsg Data message object\r\n *\r\n * \\param [OUT] fType Frame type\r\n *\r\n * \\retval  LoRaMacStatus_t Status of the operation. Possible returns are:\r\n *          returns are:\r\n *          \\ref LORAMAC_STATUS_OK,\r\n *          \\ref LORAMAC_STATUS_PARAMETER_INVALID,\r\n */\r\nLoRaMacStatus_t DetermineFrameType( LoRaMacMessageData_t* macMsg, FType_t* fType );\r\n\r\n/*!\r\n * \\brief Verifies, if the retransmission counter has reached the limit\r\n *\r\n * \\param [IN] counter Current retransmission counter\r\n * \\param [IN] limit Retransmission counter limit\r\n *\r\n * \\retval Returns true if the number of retransmissions have reached the limit.\r\n */\r\nstatic bool CheckRetrans( uint8_t counter, uint8_t limit );\r\n\r\n/*!\r\n * \\brief Checks if the retransmission should be stopped in case of a unconfirmed uplink\r\n *\r\n * \\retval Returns true if it should be stopped.\r\n */\r\nstatic bool CheckRetransUnconfirmedUplink( void );\r\n\r\n/*!\r\n * \\brief Checks if the retransmission should be stopped in case of a confirmed uplink\r\n *\r\n * \\retval Returns true it should be stopped.\r\n */\r\nstatic bool CheckRetransConfirmedUplink( void );\r\n\r\n/*!\r\n * \\brief Increases the ADR ack counter. Takes the maximum\r\n *        value into account.\r\n *\r\n * \\param [IN] counter Current counter value.\r\n *\r\n * \\retval Returns the next counter value.\r\n */\r\nstatic uint32_t IncreaseAdrAckCounter( uint32_t counter );\r\n\r\n/*!\r\n * \\brief Stops the uplink retransmission\r\n *\r\n * \\retval Returns true if successful.\r\n */\r\nstatic bool StopRetransmission( void );\r\n\r\n/*!\r\n * \\brief Calls the callback to indicate that a context changed\r\n */\r\nstatic void CallNvmDataChangeCallback( uint16_t notifyFlags );\r\n\r\n/*!\r\n * \\brief Verifies if a request is pending currently\r\n *\r\n * \\retval 1: Request pending, 0: request not pending\r\n */\r\nstatic uint8_t IsRequestPending( void );\r\n\r\n/*!\r\n * \\brief Enabled the possibility to perform requests\r\n *\r\n * \\param [IN] requestState Request permission state\r\n */\r\nstatic void LoRaMacEnableRequests( LoRaMacRequestHandling_t requestState );\r\n\r\n/*!\r\n * \\brief This function verifies if a RX abort occurred\r\n */\r\nstatic void LoRaMacCheckForRxAbort( void );\r\n\r\n/*!\r\n * \\brief This function verifies if a beacon acquisition MLME\r\n *        request was pending\r\n *\r\n * \\retval 1: Request pending, 0: no request pending\r\n */\r\nstatic uint8_t LoRaMacCheckForBeaconAcquisition( void );\r\n\r\n/*!\r\n * \\brief Returns true, if the device must apply the minium datarate\r\n *\r\n * \\param [IN] adr ADR status bit\r\n *\r\n * \\param [IN] activation Activation type of the device\r\n *\r\n * \\param [IN] datarateChanged Set to true, if the datarate was changed\r\n *                             with the LinkAdrReq.\r\n */\r\nstatic bool CheckForMinimumAbpDatarate( bool adr, ActivationType_t activation, bool datarateChanged );\r\n\r\n/*!\r\n * \\brief This function handles join request\r\n */\r\nstatic void LoRaMacHandleMlmeRequest( void );\r\n\r\n/*!\r\n * \\brief This function handles mcps request\r\n */\r\nstatic void LoRaMacHandleMcpsRequest( void );\r\n\r\n/*!\r\n * \\brief This function handles callback events for requests\r\n */\r\nstatic void LoRaMacHandleRequestEvents( void );\r\n\r\n/*!\r\n * \\brief This function handles callback events for indications\r\n */\r\nstatic void LoRaMacHandleIndicationEvents( void );\r\n\r\n/*!\r\n * \\brief This function handles events for re-join procedure\r\n */\r\nstatic void LoRaMacHandleRejoinEvents( void );\r\n\r\n/*!\r\n * \\brief This function handles callback events for NVM updates\r\n *\r\n * \\param [IN] nvmData Data structure containing NVM data.\r\n */\r\nstatic void LoRaMacHandleNvm( LoRaMacNvmData_t* nvmData );\r\n\r\n/*!\r\n * \\brief This function verifies if the response timeout has been elapsed. If\r\n *        this is the case, the status of Nvm.MacGroup1.SrvAckRequested will be\r\n *        reset.\r\n *\r\n * \\param [IN] timeoutInMs Timeout [ms] to be compared.\r\n *\r\n * \\param [IN] startTimeInMs Start time [ms] used as a base. If set to 0,\r\n *                           no comparison will be done.\r\n *\r\n * \\retval true: Response timeout has been elapsed, false: Response timeout\r\n *         has not been elapsed or startTimeInMs is 0.\r\n */\r\nstatic bool LoRaMacHandleResponseTimeout( TimerTime_t timeoutInMs, TimerTime_t startTimeInMs );\r\n\r\n/*!\r\n * Structure used to store the radio Tx event data\r\n */\r\nstruct\r\n{\r\n    TimerTime_t CurTime;\r\n}TxDoneParams;\r\n\r\n/*!\r\n * Structure used to store the radio Rx event data\r\n */\r\nstruct\r\n{\r\n    TimerTime_t LastRxDone;\r\n    uint8_t *Payload;\r\n    uint16_t Size;\r\n    int16_t Rssi;\r\n    int8_t Snr;\r\n}RxDoneParams;\r\n\r\nstatic void OnRadioTxDone( void )\r\n{\r\n    TxDoneParams.CurTime = TimerGetCurrentTime( );\r\n    MacCtx.LastTxSysTime = SysTimeGet( );\r\n\r\n    LoRaMacRadioEvents.Events.TxDone = 1;\r\n\r\n    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )\r\n    {\r\n        MacCtx.MacCallbacks->MacProcessNotify( );\r\n    }\r\n}\r\n\r\nstatic void OnRadioRxDone( uint8_t *payload, uint16_t size, int16_t rssi, int8_t snr )\r\n{\r\n    RxDoneParams.LastRxDone = TimerGetCurrentTime( );\r\n    RxDoneParams.Payload = payload;\r\n    RxDoneParams.Size = size;\r\n    RxDoneParams.Rssi = rssi;\r\n    RxDoneParams.Snr = snr;\r\n\r\n    LoRaMacRadioEvents.Events.RxDone = 1;\r\n    LoRaMacRadioEvents.Events.RxProcessPending = 1;\r\n\r\n    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )\r\n    {\r\n        MacCtx.MacCallbacks->MacProcessNotify( );\r\n    }\r\n}\r\n\r\nstatic void OnRadioTxTimeout( void )\r\n{\r\n    LoRaMacRadioEvents.Events.TxTimeout = 1;\r\n\r\n    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )\r\n    {\r\n        MacCtx.MacCallbacks->MacProcessNotify( );\r\n    }\r\n}\r\n\r\nstatic void OnRadioRxError( void )\r\n{\r\n    LoRaMacRadioEvents.Events.RxError = 1;\r\n\r\n    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )\r\n    {\r\n        MacCtx.MacCallbacks->MacProcessNotify( );\r\n    }\r\n}\r\n\r\nstatic void OnRadioRxTimeout( void )\r\n{\r\n    LoRaMacRadioEvents.Events.RxTimeout = 1;\r\n\r\n    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )\r\n    {\r\n        MacCtx.MacCallbacks->MacProcessNotify( );\r\n    }\r\n}\r\n\r\nstatic void UpdateRxSlotIdleState( void )\r\n{\r\n    if( Nvm.MacGroup2.DeviceClass != CLASS_C )\r\n    {\r\n        MacCtx.RxSlot = RX_SLOT_NONE;\r\n    }\r\n    else\r\n    {\r\n        MacCtx.RxSlot = RX_SLOT_WIN_CLASS_C;\r\n    }\r\n}\r\n\r\nstatic void ProcessRadioTxDone( void )\r\n{\r\n    GetPhyParams_t getPhy;\r\n    PhyParam_t phyParam;\r\n    SetBandTxDoneParams_t txDone;\r\n\r\n    if( Nvm.MacGroup2.DeviceClass != CLASS_C )\r\n    {\r\n        Radio.Sleep( );\r\n    }\r\n\r\n    // Setup timers\r\n    CRITICAL_SECTION_BEGIN( );\r\n    uint32_t offset = TimerGetCurrentTime( ) - TxDoneParams.CurTime;\r\n    TimerSetValue( &MacCtx.RxWindowTimer1, MacCtx.RxWindow1Delay - offset );\r\n    TimerStart( &MacCtx.RxWindowTimer1 );\r\n    TimerSetValue( &MacCtx.RxWindowTimer2, MacCtx.RxWindow2Delay - offset );\r\n    TimerStart( &MacCtx.RxWindowTimer2 );\r\n    CRITICAL_SECTION_END( );\r\n\r\n    if( MacCtx.NodeAckRequested == true )\r\n    {\r\n        getPhy.Attribute = PHY_RETRANSMIT_TIMEOUT;\r\n        phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );\r\n        TimerSetValue( &MacCtx.RetransmitTimeoutTimer, MacCtx.RxWindow2Delay + phyParam.Value );\r\n        TimerStart( &MacCtx.RetransmitTimeoutTimer );\r\n    }\r\n    else\r\n    {\r\n        // Transmission successful, setup status directly\r\n        MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_OK;\r\n    }\r\n\r\n    // Update Aggregated last tx done time\r\n    Nvm.MacGroup1.LastTxDoneTime = TxDoneParams.CurTime;\r\n\r\n    // Update last tx done time for the current channel\r\n    txDone.Channel = MacCtx.Channel;\r\n    txDone.LastTxDoneTime = TxDoneParams.CurTime;\r\n    txDone.ElapsedTimeSinceStartUp = SysTimeSub( SysTimeGetMcuTime( ), Nvm.MacGroup2.InitializationTime );\r\n    txDone.LastTxAirTime = MacCtx.TxTimeOnAir;\r\n    txDone.Joined  = true;\r\n    if( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_NONE )\r\n    {\r\n        txDone.Joined  = false;\r\n    }\r\n\r\n    RegionSetBandTxDone( Nvm.MacGroup2.Region, &txDone );\r\n}\r\n\r\nstatic void PrepareRxDoneAbort( void )\r\n{\r\n    MacCtx.MacState |= LORAMAC_RX_ABORT;\r\n\r\n    if( MacCtx.NodeAckRequested == true )\r\n    {\r\n        OnRetransmitTimeoutTimerEvent( NULL );\r\n    }\r\n\r\n    MacCtx.MacFlags.Bits.McpsInd = 1;\r\n    MacCtx.MacFlags.Bits.MacDone = 1;\r\n\r\n    UpdateRxSlotIdleState( );\r\n}\r\n\r\nstatic void ProcessRadioRxDone( void )\r\n{\r\n    LoRaMacHeader_t macHdr;\r\n    ApplyCFListParams_t applyCFList;\r\n    GetPhyParams_t getPhy;\r\n    PhyParam_t phyParam;\r\n    LoRaMacCryptoStatus_t macCryptoStatus = LORAMAC_CRYPTO_ERROR;\r\n\r\n    LoRaMacMessageData_t macMsgData;\r\n    LoRaMacMessageJoinAccept_t macMsgJoinAccept;\r\n    uint8_t *payload = RxDoneParams.Payload;\r\n    uint16_t size = RxDoneParams.Size;\r\n    int16_t rssi = RxDoneParams.Rssi;\r\n    int8_t snr = RxDoneParams.Snr;\r\n\r\n    uint8_t pktHeaderLen = 0;\r\n\r\n    uint32_t downLinkCounter = 0;\r\n    uint32_t address = Nvm.MacGroup2.DevAddr;\r\n    uint8_t multicast = 0;\r\n    AddressIdentifier_t addrID = UNICAST_DEV_ADDR;\r\n    FCntIdentifier_t fCntID;\r\n    uint8_t macCmdPayload[2] = { 0 };\r\n    Mlme_t joinType = MLME_JOIN;\r\n\r\n    LoRaMacRadioEvents.Events.RxProcessPending = 0;\r\n\r\n    MacCtx.McpsConfirm.AckReceived = false;\r\n    MacCtx.McpsIndication.Rssi = rssi;\r\n    MacCtx.McpsIndication.Snr = snr;\r\n    MacCtx.McpsIndication.RxSlot = MacCtx.RxSlot;\r\n    MacCtx.McpsIndication.Port = 0;\r\n    MacCtx.McpsIndication.Multicast = 0;\r\n    MacCtx.McpsIndication.IsUplinkTxPending = 0;\r\n    MacCtx.McpsIndication.Buffer = NULL;\r\n    MacCtx.McpsIndication.BufferSize = 0;\r\n    MacCtx.McpsIndication.RxData = false;\r\n    MacCtx.McpsIndication.AckReceived = false;\r\n    MacCtx.McpsIndication.DownLinkCounter = 0;\r\n    MacCtx.McpsIndication.McpsIndication = MCPS_UNCONFIRMED;\r\n    MacCtx.McpsIndication.DevAddress = 0;\r\n    MacCtx.McpsIndication.DeviceTimeAnsReceived = false;\r\n    MacCtx.McpsIndication.ResponseTimeout = 0;\r\n\r\n    Radio.Sleep( );\r\n\r\n    if( MacCtx.McpsIndication.RxSlot == RX_SLOT_WIN_1 )\r\n    {\r\n        TimerStop( &MacCtx.RxWindowTimer2 );\r\n    }\r\n\r\n    // This function must be called even if we are not in class b mode yet.\r\n    if( LoRaMacClassBRxBeacon( payload, size ) == true )\r\n    {\r\n        MacCtx.MlmeIndication.BeaconInfo.Rssi = rssi;\r\n        MacCtx.MlmeIndication.BeaconInfo.Snr = snr;\r\n        return;\r\n    }\r\n    // Check if we expect a ping or a multicast slot.\r\n    if( Nvm.MacGroup2.DeviceClass == CLASS_B )\r\n    {\r\n        if( LoRaMacClassBIsPingExpected( ) == true )\r\n        {\r\n            LoRaMacClassBSetPingSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );\r\n            LoRaMacClassBPingSlotTimerEvent( NULL );\r\n            MacCtx.McpsIndication.RxSlot = RX_SLOT_WIN_CLASS_B_PING_SLOT;\r\n        }\r\n        else if( LoRaMacClassBIsMulticastExpected( ) == true )\r\n        {\r\n            LoRaMacClassBSetMulticastSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );\r\n            LoRaMacClassBMulticastSlotTimerEvent( NULL );\r\n            MacCtx.McpsIndication.RxSlot = RX_SLOT_WIN_CLASS_B_MULTICAST_SLOT;\r\n        }\r\n    }\r\n\r\n    macHdr.Value = payload[pktHeaderLen++];\r\n\r\n    // Accept frames of LoRaWAN Major Version 1 only\r\n    if( macHdr.Bits.Major != 0 )\r\n    {\r\n        MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\r\n        PrepareRxDoneAbort( );\r\n        return;\r\n    }\r\n\r\n    switch( macHdr.Bits.MType )\r\n    {\r\n        case FRAME_TYPE_JOIN_ACCEPT:\r\n        {\r\n            // Check if the received frame size is valid\r\n            if( size < LORAMAC_JOIN_ACCEPT_FRAME_MIN_SIZE )\r\n            {\r\n                MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\r\n                PrepareRxDoneAbort( );\r\n                return;\r\n            }\r\n            macMsgJoinAccept.Buffer = payload;\r\n            macMsgJoinAccept.BufSize = size;\r\n\r\n            // Abort in case if the device is already joined and no rejoin request is ongoing.\r\n            if( ( Nvm.MacGroup2.NetworkActivation != ACTIVATION_TYPE_NONE ) && ( Nvm.MacGroup2.IsRejoinAcceptPending == false ) )\r\n            {\r\n                MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\r\n                PrepareRxDoneAbort( );\r\n                return;\r\n            }\r\n            macCryptoStatus = LoRaMacCryptoHandleJoinAccept( JOIN_REQ, SecureElementGetJoinEui( ), &macMsgJoinAccept );\r\n\r\n            if( LORAMAC_CRYPTO_SUCCESS != macCryptoStatus )\r\n            {\r\n                macCryptoStatus = LoRaMacCryptoHandleJoinAccept( REJOIN_REQ_0, SecureElementGetJoinEui( ), &macMsgJoinAccept );\r\n                joinType = MLME_REJOIN_0;\r\n            }\r\n\r\n            if( LORAMAC_CRYPTO_SUCCESS != macCryptoStatus )\r\n            {\r\n                macCryptoStatus = LoRaMacCryptoHandleJoinAccept( REJOIN_REQ_1, SecureElementGetJoinEui( ), &macMsgJoinAccept );\r\n                joinType = MLME_REJOIN_1;\r\n            }\r\n\r\n            if( LORAMAC_CRYPTO_SUCCESS != macCryptoStatus )\r\n            {\r\n                macCryptoStatus = LoRaMacCryptoHandleJoinAccept( REJOIN_REQ_2, SecureElementGetJoinEui( ), &macMsgJoinAccept );\r\n                joinType = MLME_REJOIN_2;\r\n            }\r\n\r\n            VerifyParams_t verifyRxDr;\r\n            bool rxDrValid = false;\r\n            verifyRxDr.DatarateParams.Datarate = macMsgJoinAccept.DLSettings.Bits.RX2DataRate;\r\n            verifyRxDr.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;\r\n            rxDrValid = RegionVerify( Nvm.MacGroup2.Region, &verifyRxDr, PHY_RX_DR );\r\n\r\n            if( ( LORAMAC_CRYPTO_SUCCESS == macCryptoStatus ) && ( rxDrValid == true ) )\r\n            {\r\n                // Network ID\r\n                Nvm.MacGroup2.NetID = ( uint32_t ) macMsgJoinAccept.NetID[0];\r\n                Nvm.MacGroup2.NetID |= ( ( uint32_t ) macMsgJoinAccept.NetID[1] << 8 );\r\n                Nvm.MacGroup2.NetID |= ( ( uint32_t ) macMsgJoinAccept.NetID[2] << 16 );\r\n\r\n                // Device Address\r\n                Nvm.MacGroup2.DevAddr = macMsgJoinAccept.DevAddr;\r\n\r\n                // DLSettings\r\n                Nvm.MacGroup2.MacParams.Rx1DrOffset = macMsgJoinAccept.DLSettings.Bits.RX1DRoffset;\r\n                Nvm.MacGroup2.MacParams.Rx2Channel.Datarate = macMsgJoinAccept.DLSettings.Bits.RX2DataRate;\r\n                Nvm.MacGroup2.MacParams.RxCChannel.Datarate = macMsgJoinAccept.DLSettings.Bits.RX2DataRate;\r\n\r\n                // RxDelay\r\n                Nvm.MacGroup2.MacParams.ReceiveDelay1 = macMsgJoinAccept.RxDelay;\r\n                if( Nvm.MacGroup2.MacParams.ReceiveDelay1 == 0 )\r\n                {\r\n                    Nvm.MacGroup2.MacParams.ReceiveDelay1 = 1;\r\n                }\r\n                Nvm.MacGroup2.MacParams.ReceiveDelay1 *= 1000;\r\n                Nvm.MacGroup2.MacParams.ReceiveDelay2 = Nvm.MacGroup2.MacParams.ReceiveDelay1 + 1000;\r\n\r\n                // Reset NbTrans to default value\r\n                Nvm.MacGroup2.MacParams.ChannelsNbTrans = 1;\r\n\r\n                // Is Networkserver's LoRaWAN Version before 1.1.0 ?\r\n                if( macMsgJoinAccept.DLSettings.Bits.OptNeg == 0 )\r\n                {\r\n                    Nvm.MacGroup2.Version.Value = LORAMAC_FALLBACK_VERSION;\r\n                }\r\n                else\r\n                {\r\n                    Nvm.MacGroup2.Version.Value = LORAMAC_VERSION;\r\n                }\r\n\r\n                // Apply CF list\r\n                applyCFList.Payload = macMsgJoinAccept.CFList;\r\n                // Size of the regular payload is 12. Plus 1 byte MHDR and 4 bytes MIC\r\n                applyCFList.Size = size - 17;\r\n                // Apply the last tx channel\r\n                applyCFList.JoinChannel = MacCtx.Channel;\r\n\r\n                RegionApplyCFList( Nvm.MacGroup2.Region, &applyCFList );\r\n\r\n                Nvm.MacGroup2.NetworkActivation = ACTIVATION_TYPE_OTAA;\r\n\r\n                // Add a RekeyInd MAC command to confirm the security key update.\r\n                if( Nvm.MacGroup2.Version.Fields.Minor >= 1 )\r\n                {\r\n                    Nvm.MacGroup1.RekeyIndUplinksCounter = 0;\r\n                    macCmdPayload[0] = Nvm.MacGroup2.Version.Fields.Minor;\r\n                    LoRaMacCommandsAddCmd( MOTE_MAC_REKEY_IND, macCmdPayload, 1 );\r\n                }\r\n\r\n                // MLME handling\r\n                if( LoRaMacConfirmQueueIsCmdActive( joinType ) == true )\r\n                {\r\n                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, joinType );\r\n                }\r\n\r\n                // Rejoin handling\r\n                if( Nvm.MacGroup2.IsRejoinAcceptPending == true )\r\n                {\r\n                    Nvm.MacGroup2.IsRejoinAcceptPending = false;\r\n\r\n                    // Stop in any case the ForceRejoinReqCycleTimer\r\n                    TimerStop( &MacCtx.ForceRejoinReqCycleTimer );\r\n                }\r\n\r\n                // Reset MAC parameters for specific re-join types\r\n                if( ( joinType == MLME_REJOIN_0 ) || ( joinType == MLME_REJOIN_1 ) )\r\n                {\r\n                    ResetMacParameters( true );\r\n                }\r\n            }\r\n            else\r\n            {\r\n                // MLME handling\r\n                if( LoRaMacConfirmQueueIsCmdActive( MLME_JOIN ) == true )\r\n                {\r\n                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_JOIN_FAIL, MLME_JOIN );\r\n                }\r\n            }\r\n            break;\r\n        }\r\n        case FRAME_TYPE_DATA_CONFIRMED_DOWN:\r\n            MacCtx.McpsIndication.McpsIndication = MCPS_CONFIRMED;\r\n            // Intentional fall through\r\n        case FRAME_TYPE_DATA_UNCONFIRMED_DOWN:\r\n            // Check if the received payload size is valid\r\n            getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;\r\n            getPhy.Datarate = MacCtx.McpsIndication.RxDatarate;\r\n            getPhy.Attribute = PHY_MAX_PAYLOAD;\r\n            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );\r\n            if( ( MAX( 0, ( int16_t )( ( int16_t ) size - ( int16_t ) LORAMAC_FRAME_PAYLOAD_OVERHEAD_SIZE ) ) > ( int16_t )phyParam.Value ) ||\r\n                ( size < LORAMAC_FRAME_PAYLOAD_MIN_SIZE ) )\r\n            {\r\n                MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\r\n                PrepareRxDoneAbort( );\r\n                return;\r\n            }\r\n            macMsgData.Buffer = payload;\r\n            macMsgData.BufSize = size;\r\n            macMsgData.FRMPayload = MacCtx.RxPayload;\r\n            macMsgData.FRMPayloadSize = LORAMAC_PHY_MAXPAYLOAD;\r\n\r\n            if( LORAMAC_PARSER_SUCCESS != LoRaMacParserData( &macMsgData ) )\r\n            {\r\n                MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\r\n                PrepareRxDoneAbort( );\r\n                return;\r\n            }\r\n\r\n            // Handle Class B\r\n            // Check if we expect a ping or a multicast slot.\r\n            if( Nvm.MacGroup2.DeviceClass == CLASS_B )\r\n            {\r\n                if( LoRaMacClassBIsPingExpected( ) == true )\r\n                {\r\n                    LoRaMacClassBSetPingSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );\r\n                    LoRaMacClassBPingSlotTimerEvent( NULL );\r\n                    MacCtx.McpsIndication.RxSlot = RX_SLOT_WIN_CLASS_B_PING_SLOT;\r\n                    LoRaMacClassBSetFPendingBit( macMsgData.FHDR.DevAddr, ( uint8_t ) macMsgData.FHDR.FCtrl.Bits.FPending );\r\n                }\r\n                else if( LoRaMacClassBIsMulticastExpected( ) == true )\r\n                {\r\n                    LoRaMacClassBSetMulticastSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );\r\n                    LoRaMacClassBMulticastSlotTimerEvent( NULL );\r\n                    MacCtx.McpsIndication.RxSlot = RX_SLOT_WIN_CLASS_B_MULTICAST_SLOT;\r\n                    LoRaMacClassBSetFPendingBit( macMsgData.FHDR.DevAddr, ( uint8_t ) macMsgData.FHDR.FCtrl.Bits.FPending );\r\n                }\r\n            }\r\n\r\n            // Store device address\r\n            MacCtx.McpsIndication.DevAddress = macMsgData.FHDR.DevAddr;\r\n\r\n            FType_t fType;\r\n            if( LORAMAC_STATUS_OK != DetermineFrameType( &macMsgData, &fType ) )\r\n            {\r\n                MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\r\n                PrepareRxDoneAbort( );\r\n                return;\r\n            }\r\n\r\n            //Check if it is a multicast message\r\n            multicast = 0;\r\n            downLinkCounter = 0;\r\n            for( uint8_t i = 0; i < LORAMAC_MAX_MC_CTX; i++ )\r\n            {\r\n                if( ( Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.Address == macMsgData.FHDR.DevAddr ) &&\r\n                    ( Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.IsEnabled == true ) )\r\n                {\r\n                    multicast = 1;\r\n                    addrID = Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.GroupID;\r\n                    downLinkCounter = *( Nvm.MacGroup2.MulticastChannelList[i].DownLinkCounter );\r\n                    address = Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.Address;\r\n                    if( Nvm.MacGroup2.DeviceClass == CLASS_C )\r\n                    {\r\n                        MacCtx.McpsIndication.RxSlot = RX_SLOT_WIN_CLASS_C_MULTICAST;\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n\r\n            // Filter messages according to multicast downlink exceptions\r\n            if( ( multicast == 1 ) && ( ( fType != FRAME_TYPE_D ) ||\r\n                                        ( macMsgData.FHDR.FCtrl.Bits.Ack != 0 ) ||\r\n                                        ( macMsgData.FHDR.FCtrl.Bits.AdrAckReq != 0 ) ) )\r\n            {\r\n                MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\r\n                PrepareRxDoneAbort( );\r\n                return;\r\n            }\r\n\r\n            // Get downlink frame counter value\r\n            macCryptoStatus = GetFCntDown( addrID, fType, &macMsgData, Nvm.MacGroup2.Version, &fCntID, &downLinkCounter );\r\n            if( macCryptoStatus != LORAMAC_CRYPTO_SUCCESS )\r\n            {\r\n                if( macCryptoStatus == LORAMAC_CRYPTO_FAIL_FCNT_DUPLICATED )\r\n                {\r\n                    // Catch the case of repeated downlink frame counter\r\n                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_DOWNLINK_REPEATED;\r\n                }\r\n                else\r\n                {\r\n                    // Other errors\r\n                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\r\n                }\r\n                MacCtx.McpsIndication.DownLinkCounter = downLinkCounter;\r\n                PrepareRxDoneAbort( );\r\n                return;\r\n            }\r\n\r\n            macCryptoStatus = LoRaMacCryptoUnsecureMessage( addrID, address, fCntID, downLinkCounter, &macMsgData );\r\n            if( macCryptoStatus != LORAMAC_CRYPTO_SUCCESS )\r\n            {\r\n                if( macCryptoStatus == LORAMAC_CRYPTO_FAIL_ADDRESS )\r\n                {\r\n                    // We are not the destination of this frame.\r\n                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ADDRESS_FAIL;\r\n                }\r\n                else\r\n                {\r\n                    // MIC calculation fail\r\n                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_MIC_FAIL;\r\n                }\r\n                PrepareRxDoneAbort( );\r\n                return;\r\n            }\r\n\r\n            MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_OK;\r\n            MacCtx.McpsIndication.Multicast = multicast;\r\n            MacCtx.McpsIndication.Buffer = NULL;\r\n            MacCtx.McpsIndication.BufferSize = 0;\r\n            MacCtx.McpsIndication.DownLinkCounter = downLinkCounter;\r\n            MacCtx.McpsIndication.AckReceived = macMsgData.FHDR.FCtrl.Bits.Ack;\r\n\r\n            MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_OK;\r\n            MacCtx.McpsConfirm.AckReceived = macMsgData.FHDR.FCtrl.Bits.Ack;\r\n\r\n            // Reset ADR ACK Counter only, when RX1 or RX2 slot\r\n            if( ( MacCtx.McpsIndication.RxSlot == RX_SLOT_WIN_1 ) ||\r\n                ( MacCtx.McpsIndication.RxSlot == RX_SLOT_WIN_2 ) )\r\n            {\r\n                Nvm.MacGroup1.AdrAckCounter = 0;\r\n                Nvm.MacGroup2.DownlinkReceived = true;\r\n            }\r\n\r\n            // MCPS Indication and ack requested handling\r\n            if( multicast == 1 )\r\n            {\r\n                MacCtx.McpsIndication.McpsIndication = MCPS_MULTICAST;\r\n            }\r\n            else\r\n            {\r\n                if( macHdr.Bits.MType == FRAME_TYPE_DATA_CONFIRMED_DOWN )\r\n                {\r\n                    Nvm.MacGroup1.SrvAckRequested = true;\r\n                    if( Nvm.MacGroup2.Version.Fields.Minor == 0 )\r\n                    {\r\n                        Nvm.MacGroup1.LastRxMic = macMsgData.MIC;\r\n                    }\r\n                    MacCtx.McpsIndication.McpsIndication = MCPS_CONFIRMED;\r\n\r\n                    // Handle response timeout for class c and class b downlinks\r\n                    if( ( MacCtx.McpsIndication.RxSlot != RX_SLOT_WIN_1 ) &&\r\n                        ( MacCtx.McpsIndication.RxSlot != RX_SLOT_WIN_2 ) )\r\n                    {\r\n                        // Calculate timeout\r\n                        MacCtx.McpsIndication.ResponseTimeout = REGION_COMMON_CLASS_B_C_RESP_TIMEOUT;\r\n                        MacCtx.ResponseTimeoutStartTime = RxDoneParams.LastRxDone;\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    Nvm.MacGroup1.SrvAckRequested = false;\r\n                    MacCtx.McpsIndication.McpsIndication = MCPS_UNCONFIRMED;\r\n                }\r\n            }\r\n\r\n            // Set the pending status\r\n            if( ( ( ( Nvm.MacGroup1.SrvAckRequested == true ) || ( macMsgData.FHDR.FCtrl.Bits.FPending > 0 ) ) && ( Nvm.MacGroup2.DeviceClass == CLASS_A ) ) ||\r\n                ( MacCtx.McpsIndication.ResponseTimeout > 0 ) )\r\n            {\r\n                MacCtx.McpsIndication.IsUplinkTxPending = 1;\r\n            }\r\n\r\n            RemoveMacCommands( MacCtx.McpsIndication.RxSlot, macMsgData.FHDR.FCtrl, MacCtx.McpsConfirm.McpsRequest );\r\n\r\n            switch( fType )\r\n            {\r\n                case FRAME_TYPE_A:\r\n                {  /* +----------+------+-------+--------------+\r\n                    * | FOptsLen | Fopt | FPort |  FRMPayload  |\r\n                    * +----------+------+-------+--------------+\r\n                    * |    > 0   |   X  |  > 0  |       X      |\r\n                    * +----------+------+-------+--------------+\r\n                    */\r\n\r\n                    // Decode MAC commands in FOpts field\r\n                    ProcessMacCommands( macMsgData.FHDR.FOpts, 0, macMsgData.FHDR.FCtrl.Bits.FOptsLen, snr, MacCtx.McpsIndication.RxSlot );\r\n                    MacCtx.McpsIndication.Port = macMsgData.FPort;\r\n                    MacCtx.McpsIndication.Buffer = macMsgData.FRMPayload;\r\n                    MacCtx.McpsIndication.BufferSize = macMsgData.FRMPayloadSize;\r\n                    MacCtx.McpsIndication.RxData = true;\r\n                    break;\r\n                }\r\n                case FRAME_TYPE_B:\r\n                {  /* +----------+------+-------+--------------+\r\n                    * | FOptsLen | Fopt | FPort |  FRMPayload  |\r\n                    * +----------+------+-------+--------------+\r\n                    * |    > 0   |   X  |   -   |       -      |\r\n                    * +----------+------+-------+--------------+\r\n                    */\r\n\r\n                    // Decode MAC commands in FOpts field\r\n                    ProcessMacCommands( macMsgData.FHDR.FOpts, 0, macMsgData.FHDR.FCtrl.Bits.FOptsLen, snr, MacCtx.McpsIndication.RxSlot );\r\n                    MacCtx.McpsIndication.Port = macMsgData.FPort;\r\n                    break;\r\n                }\r\n                case FRAME_TYPE_C:\r\n                {  /* +----------+------+-------+--------------+\r\n                    * | FOptsLen | Fopt | FPort |  FRMPayload  |\r\n                    * +----------+------+-------+--------------+\r\n                    * |    = 0   |   -  |  = 0  | MAC commands |\r\n                    * +----------+------+-------+--------------+\r\n                    */\r\n\r\n                    // Decode MAC commands in FRMPayload\r\n                    ProcessMacCommands( macMsgData.FRMPayload, 0, macMsgData.FRMPayloadSize, snr, MacCtx.McpsIndication.RxSlot );\r\n                    MacCtx.McpsIndication.Port = macMsgData.FPort;\r\n                    break;\r\n                }\r\n                case FRAME_TYPE_D:\r\n                {  /* +----------+------+-------+--------------+\r\n                    * | FOptsLen | Fopt | FPort |  FRMPayload  |\r\n                    * +----------+------+-------+--------------+\r\n                    * |    = 0   |   -  |  > 0  |       X      |\r\n                    * +----------+------+-------+--------------+\r\n                    */\r\n\r\n                    // No MAC commands just application payload\r\n                    MacCtx.McpsIndication.Port = macMsgData.FPort;\r\n                    MacCtx.McpsIndication.Buffer = macMsgData.FRMPayload;\r\n                    MacCtx.McpsIndication.BufferSize = macMsgData.FRMPayloadSize;\r\n                    MacCtx.McpsIndication.RxData = true;\r\n                    break;\r\n                }\r\n                default:\r\n                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\r\n                    PrepareRxDoneAbort( );\r\n                    break;\r\n            }\r\n\r\n            // Rejoin handling\r\n            if( Nvm.MacGroup2.IsRejoinAcceptPending == true )\r\n            {\r\n                Nvm.MacGroup2.IsRejoinAcceptPending = false;\r\n\r\n                // Stop in any case the ForceRejoinReqCycleTimer\r\n                TimerStop( &MacCtx.ForceRejoinReqCycleTimer );\r\n\r\n                // If the rejoin was trigged by MLME, set confirmation status\r\n                if( MacCtx.MacFlags.Bits.MlmeReq == 1 )\r\n                {\r\n                    MacCtx.MlmeConfirm.Status = LORAMAC_EVENT_INFO_STATUS_OK;\r\n                }\r\n            }\r\n\r\n            if( ( macMsgData.FPort == LORAMAC_CERT_FPORT ) && (Nvm.MacGroup2.IsCertPortOn == false ) )\r\n            { // Do not notify the upper layer of data reception on FPort LORAMAC_CERT_FPORT if the port\r\n              // handling is disabled.\r\n                MacCtx.McpsIndication.Port = macMsgData.FPort;\r\n                MacCtx.McpsIndication.Buffer = NULL;\r\n                MacCtx.McpsIndication.BufferSize = 0;\r\n                MacCtx.McpsIndication.RxData = false;\r\n            }\r\n\r\n            // Provide always an indication, skip the callback to the user application,\r\n            // in case of a confirmed downlink retransmission.\r\n            MacCtx.MacFlags.Bits.McpsInd = 1;\r\n\r\n            break;\r\n        case FRAME_TYPE_PROPRIETARY:\r\n            memcpy1( MacCtx.RxPayload, &payload[pktHeaderLen], size - pktHeaderLen );\r\n\r\n            MacCtx.McpsIndication.McpsIndication = MCPS_PROPRIETARY;\r\n            MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_OK;\r\n            MacCtx.McpsIndication.Buffer = MacCtx.RxPayload;\r\n            MacCtx.McpsIndication.BufferSize = size - pktHeaderLen;\r\n\r\n            MacCtx.MacFlags.Bits.McpsInd = 1;\r\n            break;\r\n        default:\r\n            MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\r\n            PrepareRxDoneAbort( );\r\n            break;\r\n    }\r\n\r\n    // Verify if we need to disable the RetransmitTimeoutTimer\r\n    // Only aplies if downlink is received on Rx1 or Rx2 windows.\r\n    if( ( MacCtx.McpsIndication.RxSlot == RX_SLOT_WIN_1 ) ||\r\n        ( MacCtx.McpsIndication.RxSlot == RX_SLOT_WIN_2 ) )\r\n    {\r\n        if( MacCtx.NodeAckRequested == true )\r\n        {\r\n            if( MacCtx.McpsConfirm.AckReceived == true )\r\n            {\r\n                OnRetransmitTimeoutTimerEvent( NULL );\r\n            }\r\n        }\r\n    }\r\n\r\n    if( MacCtx.McpsIndication.RxSlot != RX_SLOT_WIN_CLASS_C )\r\n    {\r\n        MacCtx.MacFlags.Bits.MacDone = 1;\r\n    }\r\n\r\n    UpdateRxSlotIdleState( );\r\n}\r\n\r\nstatic void ProcessRadioTxTimeout( void )\r\n{\r\n    if( Nvm.MacGroup2.DeviceClass != CLASS_C )\r\n    {\r\n        Radio.Sleep( );\r\n    }\r\n    UpdateRxSlotIdleState( );\r\n\r\n    MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_TX_TIMEOUT;\r\n    LoRaMacConfirmQueueSetStatusCmn( LORAMAC_EVENT_INFO_STATUS_TX_TIMEOUT );\r\n    if( MacCtx.NodeAckRequested == true )\r\n    {\r\n        MacCtx.RetransmitTimeoutRetry = true;\r\n    }\r\n    MacCtx.MacFlags.Bits.MacDone = 1;\r\n}\r\n\r\nstatic void HandleRadioRxErrorTimeout( LoRaMacEventInfoStatus_t rx1EventInfoStatus, LoRaMacEventInfoStatus_t rx2EventInfoStatus )\r\n{\r\n    bool classBRx = false;\r\n\r\n    if( Nvm.MacGroup2.DeviceClass != CLASS_C )\r\n    {\r\n        Radio.Sleep( );\r\n    }\r\n\r\n    if( LoRaMacClassBIsBeaconExpected( ) == true )\r\n    {\r\n        LoRaMacClassBSetBeaconState( BEACON_STATE_TIMEOUT );\r\n        LoRaMacClassBBeaconTimerEvent( NULL );\r\n        classBRx = true;\r\n    }\r\n    if( Nvm.MacGroup2.DeviceClass == CLASS_B )\r\n    {\r\n        if( LoRaMacClassBIsPingExpected( ) == true )\r\n        {\r\n            LoRaMacClassBSetPingSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );\r\n            LoRaMacClassBPingSlotTimerEvent( NULL );\r\n            classBRx = true;\r\n        }\r\n        if( LoRaMacClassBIsMulticastExpected( ) == true )\r\n        {\r\n            LoRaMacClassBSetMulticastSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );\r\n            LoRaMacClassBMulticastSlotTimerEvent( NULL );\r\n            classBRx = true;\r\n        }\r\n    }\r\n\r\n    if( classBRx == false )\r\n    {\r\n        if( MacCtx.RxSlot == RX_SLOT_WIN_1 )\r\n        {\r\n            if( MacCtx.NodeAckRequested == true )\r\n            {\r\n                MacCtx.McpsConfirm.Status = rx1EventInfoStatus;\r\n            }\r\n            LoRaMacConfirmQueueSetStatusCmn( rx1EventInfoStatus );\r\n\r\n            if( TimerGetElapsedTime( Nvm.MacGroup1.LastTxDoneTime ) >= MacCtx.RxWindow2Delay )\r\n            {\r\n                TimerStop( &MacCtx.RxWindowTimer2 );\r\n                MacCtx.MacFlags.Bits.MacDone = 1;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            if( MacCtx.NodeAckRequested == true )\r\n            {\r\n                MacCtx.McpsConfirm.Status = rx2EventInfoStatus;\r\n            }\r\n            LoRaMacConfirmQueueSetStatusCmn( rx2EventInfoStatus );\r\n            MacCtx.MacFlags.Bits.MacDone = 1;\r\n        }\r\n    }\r\n\r\n    UpdateRxSlotIdleState( );\r\n}\r\n\r\nstatic void ProcessRadioRxError( void )\r\n{\r\n    HandleRadioRxErrorTimeout( LORAMAC_EVENT_INFO_STATUS_RX1_ERROR, LORAMAC_EVENT_INFO_STATUS_RX2_ERROR );\r\n}\r\n\r\nstatic void ProcessRadioRxTimeout( void )\r\n{\r\n    HandleRadioRxErrorTimeout( LORAMAC_EVENT_INFO_STATUS_RX1_TIMEOUT, LORAMAC_EVENT_INFO_STATUS_RX2_TIMEOUT );\r\n}\r\n\r\nstatic void LoRaMacHandleIrqEvents( void )\r\n{\r\n    LoRaMacRadioEvents_t events;\r\n\r\n    CRITICAL_SECTION_BEGIN( );\r\n    events = LoRaMacRadioEvents;\r\n    LoRaMacRadioEvents.Value = 0;\r\n    CRITICAL_SECTION_END( );\r\n\r\n    if( events.Value != 0 )\r\n    {\r\n        if( events.Events.TxDone == 1 )\r\n        {\r\n            ProcessRadioTxDone( );\r\n        }\r\n        if( events.Events.RxDone == 1 )\r\n        {\r\n            ProcessRadioRxDone( );\r\n        }\r\n        if( events.Events.TxTimeout == 1 )\r\n        {\r\n            ProcessRadioTxTimeout( );\r\n        }\r\n        if( events.Events.RxError == 1 )\r\n        {\r\n            ProcessRadioRxError( );\r\n        }\r\n        if( events.Events.RxTimeout == 1 )\r\n        {\r\n            ProcessRadioRxTimeout( );\r\n        }\r\n    }\r\n}\r\n\r\nbool LoRaMacIsBusy( void )\r\n{\r\n    if( MacCtx.MacState == LORAMAC_STOPPED )\r\n    {\r\n        return false;\r\n    }\r\n\r\n    if( LoRaMacRadioEvents.Events.RxProcessPending == 1 )\r\n    {\r\n        return true;\r\n    }\r\n\r\n    if( ( MacCtx.MacState == LORAMAC_IDLE ) &&\r\n        ( MacCtx.AllowRequests == LORAMAC_REQUEST_HANDLING_ON ) )\r\n    {\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n\r\n\r\nstatic void LoRaMacEnableRequests( LoRaMacRequestHandling_t requestState )\r\n{\r\n    MacCtx.AllowRequests = requestState;\r\n}\r\n\r\nstatic void LoRaMacHandleRequestEvents( void )\r\n{\r\n    // Handle events\r\n    LoRaMacFlags_t reqEvents = MacCtx.MacFlags;\r\n\r\n    if( MacCtx.MacState == LORAMAC_IDLE )\r\n    {\r\n        // Update event bits\r\n        if( MacCtx.MacFlags.Bits.McpsReq == 1 )\r\n        {\r\n            MacCtx.MacFlags.Bits.McpsReq = 0;\r\n        }\r\n\r\n        if( MacCtx.MacFlags.Bits.MlmeReq == 1 )\r\n        {\r\n            MacCtx.MacFlags.Bits.MlmeReq = 0;\r\n        }\r\n\r\n        // Allow requests again\r\n        LoRaMacEnableRequests( LORAMAC_REQUEST_HANDLING_ON );\r\n\r\n        // Handle callbacks\r\n        if( reqEvents.Bits.McpsReq == 1 )\r\n        {\r\n            MacCtx.MacPrimitives->MacMcpsConfirm( &MacCtx.McpsConfirm );\r\n        }\r\n\r\n        if( reqEvents.Bits.MlmeReq == 1 )\r\n        {\r\n            LoRaMacConfirmQueueHandleCb( &MacCtx.MlmeConfirm );\r\n            if( LoRaMacConfirmQueueGetCnt( ) > 0 )\r\n            {\r\n                MacCtx.MacFlags.Bits.MlmeReq = 1;\r\n            }\r\n        }\r\n\r\n        // Start beaconing again\r\n        LoRaMacClassBResumeBeaconing( );\r\n\r\n        // Procedure done. Reset variables.\r\n        MacCtx.MacFlags.Bits.MacDone = 0;\r\n    }\r\n}\r\n\r\nstatic void LoRaMacHandleIndicationEvents( void )\r\n{\r\n    // Handle MLME indication\r\n    if( MacCtx.MacFlags.Bits.MlmeInd == 1 )\r\n    {\r\n        MacCtx.MacFlags.Bits.MlmeInd = 0;\r\n        MacCtx.MacPrimitives->MacMlmeIndication( &MacCtx.MlmeIndication );\r\n    }\r\n\r\n    // Handle MCPS indication\r\n    if( MacCtx.MacFlags.Bits.McpsInd == 1 )\r\n    {\r\n        MacCtx.MacFlags.Bits.McpsInd = 0;\r\n        MacCtx.MacPrimitives->MacMcpsIndication( &MacCtx.McpsIndication );\r\n    }\r\n}\r\n\r\nstatic void LoRaMacHandleRejoinEvents( void )\r\n{\r\n    if( MacCtx.MacState == LORAMAC_IDLE )\r\n    {\r\n        MlmeReq_t mlmeReq;\r\n        if( IsReJoin0Required( ) == true )\r\n        {\r\n            mlmeReq.Type = MLME_REJOIN_0;\r\n            LoRaMacMlmeRequest( &mlmeReq );\r\n        }\r\n        else if( Nvm.MacGroup2.IsRejoin0RequestQueued == true )\r\n        {\r\n            mlmeReq.Type = MLME_REJOIN_0;\r\n            if( LoRaMacMlmeRequest( &mlmeReq ) == LORAMAC_STATUS_OK )\r\n            {\r\n                Nvm.MacGroup2.IsRejoin0RequestQueued = false;\r\n            }\r\n        }\r\n        else if( Nvm.MacGroup2.IsRejoin1RequestQueued == true )\r\n        {\r\n            mlmeReq.Type = MLME_REJOIN_1;\r\n            if( LoRaMacMlmeRequest( &mlmeReq ) == LORAMAC_STATUS_OK )\r\n            {\r\n                Nvm.MacGroup2.IsRejoin1RequestQueued = false;\r\n            }\r\n        }\r\n        else if( Nvm.MacGroup2.IsRejoin2RequestQueued == true )\r\n        {\r\n            mlmeReq.Type = MLME_REJOIN_2;\r\n            if( LoRaMacMlmeRequest( &mlmeReq ) == LORAMAC_STATUS_OK )\r\n            {\r\n                Nvm.MacGroup2.IsRejoin2RequestQueued = false;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nstatic void LoRaMacHandleMcpsRequest( void )\r\n{\r\n    // Handle MCPS uplinks\r\n    if( MacCtx.MacFlags.Bits.McpsReq == 1 )\r\n    {\r\n        bool stopRetransmission = false;\r\n        bool waitForRetransmission = false;\r\n\r\n        if( ( MacCtx.McpsConfirm.McpsRequest == MCPS_UNCONFIRMED ) ||\r\n            ( MacCtx.McpsConfirm.McpsRequest == MCPS_PROPRIETARY ) )\r\n        {\r\n            stopRetransmission = CheckRetransUnconfirmedUplink( );\r\n        }\r\n        else if( MacCtx.McpsConfirm.McpsRequest == MCPS_CONFIRMED )\r\n        {\r\n            if( MacCtx.RetransmitTimeoutRetry == true )\r\n            {\r\n                stopRetransmission = CheckRetransConfirmedUplink( );\r\n            }\r\n            else\r\n            {\r\n                waitForRetransmission = true;\r\n            }\r\n        }\r\n\r\n        if( stopRetransmission == true )\r\n        {// Stop retransmission\r\n            TimerStop( &MacCtx.TxDelayedTimer );\r\n            MacCtx.MacState &= ~LORAMAC_TX_DELAYED;\r\n            StopRetransmission( );\r\n        }\r\n        else if( waitForRetransmission == false )\r\n        {// Arrange further retransmission\r\n            MacCtx.MacFlags.Bits.MacDone = 0;\r\n            // Reset the state of the AckTimeout\r\n            MacCtx.RetransmitTimeoutRetry = false;\r\n            // Sends the same frame again\r\n            OnTxDelayedTimerEvent( NULL );\r\n        }\r\n    }\r\n}\r\n\r\nstatic void LoRaMacHandleMlmeRequest( void )\r\n{\r\n    // Handle join request\r\n    if( MacCtx.MacFlags.Bits.MlmeReq == 1 )\r\n    {\r\n        if( ( LoRaMacConfirmQueueIsCmdActive( MLME_JOIN ) == true ) ||\r\n            ( LoRaMacConfirmQueueIsCmdActive( MLME_REJOIN_0 ) == true ) ||\r\n            ( LoRaMacConfirmQueueIsCmdActive( MLME_REJOIN_1 ) == true ) ||\r\n            ( LoRaMacConfirmQueueIsCmdActive( MLME_REJOIN_2 ) == true ) )\r\n        {\r\n            MacCtx.ChannelsNbTransCounter = 0;\r\n            MacCtx.MacState &= ~LORAMAC_TX_RUNNING;\r\n        }\r\n        else if( LoRaMacConfirmQueueIsCmdActive( MLME_TXCW ) == true )\r\n        {\r\n            MacCtx.MacState &= ~LORAMAC_TX_RUNNING;\r\n        }\r\n    }\r\n}\r\n\r\nstatic uint8_t LoRaMacCheckForBeaconAcquisition( void )\r\n{\r\n    if( ( LoRaMacConfirmQueueIsCmdActive( MLME_BEACON_ACQUISITION ) == true ) &&\r\n        ( MacCtx.MacFlags.Bits.McpsReq == 0 ) )\r\n    {\r\n        if( MacCtx.MacFlags.Bits.MlmeReq == 1 )\r\n        {\r\n            MacCtx.MacState &= ~LORAMAC_TX_RUNNING;\r\n            return 0x01;\r\n        }\r\n    }\r\n    return 0x00;\r\n}\r\n\r\nstatic bool CheckForMinimumAbpDatarate( bool adr, ActivationType_t activation, bool datarateChanged )\r\n{\r\n    if( ( adr == true ) &&\r\n        ( activation == ACTIVATION_TYPE_ABP ) &&\r\n        ( datarateChanged == false ) )\r\n    {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\nstatic void LoRaMacCheckForRxAbort( void )\r\n{\r\n    // A error occurs during receiving\r\n    if( ( MacCtx.MacState & LORAMAC_RX_ABORT ) == LORAMAC_RX_ABORT )\r\n    {\r\n        MacCtx.MacState &= ~LORAMAC_RX_ABORT;\r\n        MacCtx.MacState &= ~LORAMAC_TX_RUNNING;\r\n    }\r\n}\r\n\r\nstatic void LoRaMacHandleNvm( LoRaMacNvmData_t* nvmData )\r\n{\r\n    uint32_t crc = 0;\r\n    uint16_t notifyFlags = LORAMAC_NVM_NOTIFY_FLAG_NONE;\r\n\r\n    if( MacCtx.MacState != LORAMAC_IDLE )\r\n    {\r\n        return;\r\n    }\r\n\r\n    // Crypto\r\n    crc = Crc32( ( uint8_t* ) &nvmData->Crypto, sizeof( nvmData->Crypto ) -\r\n                                                sizeof( nvmData->Crypto.Crc32 ) );\r\n    if( crc != nvmData->Crypto.Crc32 )\r\n    {\r\n        nvmData->Crypto.Crc32 = crc;\r\n        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_CRYPTO;\r\n    }\r\n\r\n    // MacGroup1\r\n    crc = Crc32( ( uint8_t* ) &nvmData->MacGroup1, sizeof( nvmData->MacGroup1 ) -\r\n                                                   sizeof( nvmData->MacGroup1.Crc32 ) );\r\n    if( crc != nvmData->MacGroup1.Crc32 )\r\n    {\r\n        nvmData->MacGroup1.Crc32 = crc;\r\n        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_MAC_GROUP1;\r\n    }\r\n\r\n    // MacGroup2\r\n    crc = Crc32( ( uint8_t* ) &nvmData->MacGroup2, sizeof( nvmData->MacGroup2 ) -\r\n                                                   sizeof( nvmData->MacGroup2.Crc32 ) );\r\n    if( crc != nvmData->MacGroup2.Crc32 )\r\n    {\r\n        nvmData->MacGroup2.Crc32 = crc;\r\n        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_MAC_GROUP2;\r\n    }\r\n\r\n    // Secure Element\r\n    crc = Crc32( ( uint8_t* ) &nvmData->SecureElement, sizeof( nvmData->SecureElement ) -\r\n                                                       sizeof( nvmData->SecureElement.Crc32 ) );\r\n    if( crc != nvmData->SecureElement.Crc32 )\r\n    {\r\n        nvmData->SecureElement.Crc32 = crc;\r\n        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_SECURE_ELEMENT;\r\n    }\r\n\r\n    // Region\r\n    crc = Crc32( ( uint8_t* ) &nvmData->RegionGroup1, sizeof( nvmData->RegionGroup1 ) -\r\n                                                sizeof( nvmData->RegionGroup1.Crc32 ) );\r\n    if( crc != nvmData->RegionGroup1.Crc32 )\r\n    {\r\n        nvmData->RegionGroup1.Crc32 = crc;\r\n        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_REGION_GROUP1;\r\n    }\r\n\r\n    crc = Crc32( ( uint8_t* ) &nvmData->RegionGroup2, sizeof( nvmData->RegionGroup2 ) -\r\n                                                sizeof( nvmData->RegionGroup2.Crc32 ) );\r\n    if( crc != nvmData->RegionGroup2.Crc32 )\r\n    {\r\n        nvmData->RegionGroup2.Crc32 = crc;\r\n        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_REGION_GROUP2;\r\n    }\r\n\r\n    // ClassB\r\n    crc = Crc32( ( uint8_t* ) &nvmData->ClassB, sizeof( nvmData->ClassB ) -\r\n                                                sizeof( nvmData->ClassB.Crc32 ) );\r\n    if( crc != nvmData->ClassB.Crc32 )\r\n    {\r\n        nvmData->ClassB.Crc32 = crc;\r\n        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_CLASS_B;\r\n    }\r\n\r\n    CallNvmDataChangeCallback( notifyFlags );\r\n}\r\n\r\nstatic bool LoRaMacHandleResponseTimeout( TimerTime_t timeoutInMs, TimerTime_t startTimeInMs )\r\n{\r\n    if( startTimeInMs != 0 )\r\n    {\r\n        TimerTime_t elapsedTime = TimerGetElapsedTime( startTimeInMs );\r\n        if( elapsedTime > timeoutInMs )\r\n        {\r\n            Nvm.MacGroup1.SrvAckRequested = false;\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nvoid LoRaMacProcess( void )\r\n{\r\n    uint8_t noTx = false;\r\n\r\n    LoRaMacHandleIrqEvents( );\r\n    LoRaMacClassBProcess( );\r\n\r\n    // MAC proceeded a state and is ready to check\r\n    if( MacCtx.MacFlags.Bits.MacDone == 1 )\r\n    {\r\n        LoRaMacEnableRequests( LORAMAC_REQUEST_HANDLING_OFF );\r\n        LoRaMacCheckForRxAbort( );\r\n\r\n        // An error occurs during transmitting\r\n        if( IsRequestPending( ) > 0 )\r\n        {\r\n            noTx |= LoRaMacCheckForBeaconAcquisition( );\r\n        }\r\n\r\n        if( noTx == 0x00 )\r\n        {\r\n            LoRaMacHandleMlmeRequest( );\r\n            LoRaMacHandleMcpsRequest( );\r\n        }\r\n        LoRaMacHandleRequestEvents( );\r\n        LoRaMacEnableRequests( LORAMAC_REQUEST_HANDLING_ON );\r\n        MacCtx.MacFlags.Bits.NvmHandle = 1;\r\n    }\r\n    LoRaMacHandleIndicationEvents( );\r\n    LoRaMacHandleRejoinEvents( );\r\n\r\n    if( MacCtx.RxSlot == RX_SLOT_WIN_CLASS_C )\r\n    {\r\n        OpenContinuousRxCWindow( );\r\n    }\r\n    if( MacCtx.MacFlags.Bits.NvmHandle == 1 )\r\n    {\r\n        MacCtx.MacFlags.Bits.NvmHandle = 0;\r\n        LoRaMacHandleNvm( &Nvm );\r\n    }\r\n}\r\n\r\nstatic void OnTxDelayedTimerEvent( void* context )\r\n{\r\n    TimerStop( &MacCtx.TxDelayedTimer );\r\n    MacCtx.MacState &= ~LORAMAC_TX_DELAYED;\r\n\r\n    if( LoRaMacHandleResponseTimeout( REGION_COMMON_CLASS_B_C_RESP_TIMEOUT,\r\n                                      MacCtx.ResponseTimeoutStartTime ) == true )\r\n    {\r\n        // Skip retransmission\r\n        return;\r\n    }\r\n\r\n    // Schedule frame, allow delayed frame transmissions\r\n    switch( ScheduleTx( true ) )\r\n    {\r\n        case LORAMAC_STATUS_OK:\r\n        case LORAMAC_STATUS_DUTYCYCLE_RESTRICTED:\r\n        {\r\n            break;\r\n        }\r\n        default:\r\n        {\r\n            // Stop retransmission attempt\r\n            MacCtx.McpsConfirm.Datarate = Nvm.MacGroup1.ChannelsDatarate;\r\n            MacCtx.McpsConfirm.NbTrans = MacCtx.ChannelsNbTransCounter;\r\n            MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_TX_DR_PAYLOAD_SIZE_ERROR;\r\n            LoRaMacConfirmQueueSetStatusCmn( LORAMAC_EVENT_INFO_STATUS_TX_DR_PAYLOAD_SIZE_ERROR );\r\n            StopRetransmission( );\r\n            break;\r\n        }\r\n    }\r\n}\r\n\r\nstatic void OnRxWindow1TimerEvent( void* context )\r\n{\r\n    MacCtx.RxWindow1Config.Channel = MacCtx.Channel;\r\n    MacCtx.RxWindow1Config.DrOffset = Nvm.MacGroup2.MacParams.Rx1DrOffset;\r\n    MacCtx.RxWindow1Config.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;\r\n    MacCtx.RxWindow1Config.RxContinuous = false;\r\n    MacCtx.RxWindow1Config.RxSlot = RX_SLOT_WIN_1;\r\n    MacCtx.RxWindow1Config.NetworkActivation = Nvm.MacGroup2.NetworkActivation;\r\n\r\n    RxWindowSetup( &MacCtx.RxWindowTimer1, &MacCtx.RxWindow1Config );\r\n}\r\n\r\nstatic void OnRxWindow2TimerEvent( void* context )\r\n{\r\n    // Check if we are processing Rx1 window.\r\n    // If yes, we don't setup the Rx2 window.\r\n    if( MacCtx.RxSlot == RX_SLOT_WIN_1 )\r\n    {\r\n        return;\r\n    }\r\n    MacCtx.RxWindow2Config.Channel = MacCtx.Channel;\r\n    MacCtx.RxWindow2Config.Frequency = Nvm.MacGroup2.MacParams.Rx2Channel.Frequency;\r\n    MacCtx.RxWindow2Config.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;\r\n    MacCtx.RxWindow2Config.RxContinuous = false;\r\n    MacCtx.RxWindow2Config.RxSlot = RX_SLOT_WIN_2;\r\n    MacCtx.RxWindow2Config.NetworkActivation = Nvm.MacGroup2.NetworkActivation;\r\n\r\n    RxWindowSetup( &MacCtx.RxWindowTimer2, &MacCtx.RxWindow2Config );\r\n}\r\n\r\nstatic void OnRetransmitTimeoutTimerEvent( void* context )\r\n{\r\n    TimerStop( &MacCtx.RetransmitTimeoutTimer );\r\n\r\n    if( MacCtx.NodeAckRequested == true )\r\n    {\r\n        MacCtx.RetransmitTimeoutRetry = true;\r\n    }\r\n    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )\r\n    {\r\n        MacCtx.MacCallbacks->MacProcessNotify( );\r\n    }\r\n}\r\n\r\nstatic LoRaMacCryptoStatus_t GetFCntDown( AddressIdentifier_t addrID, FType_t fType, LoRaMacMessageData_t* macMsg, Version_t lrWanVersion,\r\n                                          FCntIdentifier_t* fCntID, uint32_t* currentDown )\r\n{\r\n    if( ( macMsg == NULL ) || ( fCntID == NULL ) ||\r\n        ( currentDown == NULL ) )\r\n    {\r\n        return LORAMAC_CRYPTO_ERROR_NPE;\r\n    }\r\n\r\n    // Determine the frame counter identifier and choose counter from FCntList\r\n    switch( addrID )\r\n    {\r\n        case UNICAST_DEV_ADDR:\r\n            if( lrWanVersion.Fields.Minor == 1 )\r\n            {\r\n                if( ( fType == FRAME_TYPE_A ) || ( fType == FRAME_TYPE_D ) )\r\n                {\r\n                    *fCntID = A_FCNT_DOWN;\r\n                }\r\n                else\r\n                {\r\n                    *fCntID = N_FCNT_DOWN;\r\n                }\r\n            }\r\n            else\r\n            { // For LoRaWAN 1.0.X\r\n                *fCntID = FCNT_DOWN;\r\n            }\r\n            break;\r\n        case MULTICAST_0_ADDR:\r\n            *fCntID = MC_FCNT_DOWN_0;\r\n            break;\r\n        case MULTICAST_1_ADDR:\r\n            *fCntID = MC_FCNT_DOWN_1;\r\n            break;\r\n        case MULTICAST_2_ADDR:\r\n            *fCntID = MC_FCNT_DOWN_2;\r\n            break;\r\n        case MULTICAST_3_ADDR:\r\n            *fCntID = MC_FCNT_DOWN_3;\r\n            break;\r\n        default:\r\n            return LORAMAC_CRYPTO_FAIL_FCNT_ID;\r\n    }\r\n\r\n    return LoRaMacCryptoGetFCntDown( *fCntID, macMsg->FHDR.FCnt, currentDown );\r\n}\r\n\r\nstatic LoRaMacStatus_t SwitchClass( DeviceClass_t deviceClass )\r\n{\r\n    LoRaMacStatus_t status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n\r\n    switch( Nvm.MacGroup2.DeviceClass )\r\n    {\r\n        case CLASS_A:\r\n        {\r\n            if( deviceClass == CLASS_A )\r\n            {\r\n                // Revert back RxC parameters\r\n                Nvm.MacGroup2.MacParams.RxCChannel = Nvm.MacGroup2.MacParams.Rx2Channel;\r\n\r\n                status = LORAMAC_STATUS_OK;\r\n            }\r\n            if( deviceClass == CLASS_B )\r\n            {\r\n                status = LoRaMacClassBSwitchClass( deviceClass );\r\n                if( status == LORAMAC_STATUS_OK )\r\n                {\r\n                    Nvm.MacGroup2.DeviceClass = deviceClass;\r\n                }\r\n            }\r\n\r\n            if( deviceClass == CLASS_C )\r\n            {\r\n                Nvm.MacGroup2.DeviceClass = deviceClass;\r\n\r\n                MacCtx.RxWindowCConfig = MacCtx.RxWindow2Config;\r\n                MacCtx.RxWindowCConfig.RxSlot = RX_SLOT_WIN_CLASS_C;\r\n\r\n                for( int8_t i = 0; i < LORAMAC_MAX_MC_CTX; i++ )\r\n                {\r\n                    if( ( Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.IsEnabled == true ) &&\r\n                        ( Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.RxParams.Class == CLASS_C ) )\r\n                    {\r\n                        Nvm.MacGroup2.MacParams.RxCChannel.Frequency = Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.RxParams.Params.ClassC.Frequency;\r\n                        Nvm.MacGroup2.MacParams.RxCChannel.Datarate = Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.RxParams.Params.ClassC.Datarate;\r\n\r\n                        MacCtx.RxWindowCConfig.Channel = MacCtx.Channel;\r\n                        MacCtx.RxWindowCConfig.Frequency = Nvm.MacGroup2.MacParams.RxCChannel.Frequency;\r\n                        MacCtx.RxWindowCConfig.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;\r\n                        MacCtx.RxWindowCConfig.RxSlot = RX_SLOT_WIN_CLASS_C_MULTICAST;\r\n                        MacCtx.RxWindowCConfig.RxContinuous = true;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                // Set the NodeAckRequested indicator to default\r\n                MacCtx.NodeAckRequested = false;\r\n                // Set the radio into sleep mode in case we are still in RX mode\r\n                Radio.Sleep( );\r\n\r\n                OpenContinuousRxCWindow( );\r\n\r\n                // Add a DeviceModeInd MAC Command to indicate the network a device mode change.\r\n                if( Nvm.MacGroup2.Version.Fields.Minor >= 1 )\r\n                {\r\n                    LoRaMacCommandsAddCmd( MOTE_MAC_DEVICE_MODE_IND, ( uint8_t* )&Nvm.MacGroup2.DeviceClass, 1 );\r\n                }\r\n\r\n                status = LORAMAC_STATUS_OK;\r\n            }\r\n            break;\r\n        }\r\n        case CLASS_B:\r\n        {\r\n            status = LoRaMacClassBSwitchClass( deviceClass );\r\n            if( status == LORAMAC_STATUS_OK )\r\n            {\r\n                Nvm.MacGroup2.DeviceClass = deviceClass;\r\n            }\r\n            break;\r\n        }\r\n        case CLASS_C:\r\n        {\r\n            if( deviceClass == CLASS_A )\r\n            {\r\n                // Reset RxSlot to NONE\r\n                MacCtx.RxSlot = RX_SLOT_NONE;\r\n\r\n                Nvm.MacGroup2.DeviceClass = deviceClass;\r\n\r\n                // Set the radio into sleep to setup a defined state\r\n                Radio.Sleep( );\r\n\r\n                status = LORAMAC_STATUS_OK;\r\n\r\n                // Add a DeviceModeInd MAC Command to indicate the network a device mode change.\r\n                if( Nvm.MacGroup2.Version.Fields.Minor >= 1 )\r\n                {\r\n                    LoRaMacCommandsAddCmd( MOTE_MAC_DEVICE_MODE_IND, ( uint8_t* )&Nvm.MacGroup2.DeviceClass, 1 );\r\n                }\r\n            }\r\n            break;\r\n        }\r\n    }\r\n\r\n    return status;\r\n}\r\n\r\nstatic uint8_t GetMaxAppPayloadWithoutFOptsLength( int8_t datarate )\r\n{\r\n    GetPhyParams_t getPhy;\r\n    PhyParam_t phyParam;\r\n\r\n    // Setup PHY request\r\n    getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;\r\n    getPhy.Datarate = datarate;\r\n    getPhy.Attribute = PHY_MAX_PAYLOAD;\r\n    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );\r\n\r\n    return phyParam.Value;\r\n}\r\n\r\nstatic bool ValidatePayloadLength( uint8_t lenN, int8_t datarate, uint8_t fOptsLen )\r\n{\r\n    uint16_t maxN = 0;\r\n    uint16_t payloadSize = 0;\r\n\r\n    maxN = GetMaxAppPayloadWithoutFOptsLength( datarate );\r\n\r\n    // Calculate the resulting payload size\r\n    payloadSize = ( lenN + fOptsLen );\r\n\r\n    // Validation of the application payload size\r\n    if( ( payloadSize <= maxN ) && ( payloadSize <= LORAMAC_PHY_MAXPAYLOAD ) )\r\n    {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\nstatic void ProcessMacCommands( uint8_t *payload, uint8_t macIndex, uint8_t commandsSize, int8_t snr, LoRaMacRxSlot_t rxSlot )\r\n{\r\n    uint8_t status = 0;\r\n    bool adrBlockFound = false;\r\n    uint8_t macCmdPayload[2] = { 0x00, 0x00 };\r\n    MacCommand_t* macCmd;\r\n\r\n    if( ( rxSlot != RX_SLOT_WIN_1 ) && ( rxSlot != RX_SLOT_WIN_2 ) )\r\n    {\r\n        // Do only parse MAC commands for Class A RX windows\r\n        return;\r\n    }\r\n\r\n    while( macIndex < commandsSize )\r\n    {\r\n        // Make sure to parse only complete MAC commands\r\n        if( ( LoRaMacCommandsGetCmdSize( payload[macIndex] ) + macIndex ) > commandsSize )\r\n        {\r\n            return;\r\n        }\r\n\r\n        // Decode Frame MAC commands\r\n        switch( payload[macIndex++] )\r\n        {\r\n            case SRV_MAC_RESET_CONF:\r\n            {\r\n                uint8_t serverMinorVersion = payload[macIndex++];\r\n\r\n                // Compare own LoRaWAN Version with server's\r\n                if( Nvm.MacGroup2.Version.Fields.Minor >= serverMinorVersion )\r\n                {\r\n                    // If they equal remove the sticky ResetInd MAC-Command.\r\n                    if( LoRaMacCommandsGetCmd( MOTE_MAC_RESET_IND, &macCmd) == LORAMAC_COMMANDS_SUCCESS )\r\n                    {\r\n                        LoRaMacCommandsRemoveCmd( macCmd );\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n            case SRV_MAC_LINK_CHECK_ANS:\r\n            {\r\n                if( LoRaMacConfirmQueueIsCmdActive( MLME_LINK_CHECK ) == true )\r\n                {\r\n                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_LINK_CHECK );\r\n                    MacCtx.MlmeConfirm.DemodMargin = payload[macIndex++];\r\n                    MacCtx.MlmeConfirm.NbGateways = payload[macIndex++];\r\n                }\r\n                break;\r\n            }\r\n            case SRV_MAC_LINK_ADR_REQ:\r\n            {\r\n                LinkAdrReqParams_t linkAdrReq;\r\n                int8_t linkAdrDatarate = DR_0;\r\n                int8_t linkAdrTxPower = TX_POWER_0;\r\n                uint8_t linkAdrNbRep = 0;\r\n                uint8_t linkAdrNbBytesParsed = 0;\r\n\r\n                // The end node is allowed to process one block of LinkAdrRequests.\r\n                // It must ignore subsequent blocks\r\n                if( adrBlockFound == false )\r\n                {\r\n                    adrBlockFound = true;\r\n\r\n                    do\r\n                    {\r\n                        // Fill parameter structure\r\n                        linkAdrReq.Payload = &payload[macIndex - 1];\r\n                        linkAdrReq.AdrEnabled = Nvm.MacGroup2.AdrCtrlOn;\r\n                        linkAdrReq.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;\r\n                        linkAdrReq.CurrentDatarate = Nvm.MacGroup1.ChannelsDatarate;\r\n                        linkAdrReq.CurrentTxPower = Nvm.MacGroup1.ChannelsTxPower;\r\n                        linkAdrReq.CurrentNbRep = Nvm.MacGroup2.MacParams.ChannelsNbTrans;\r\n                        linkAdrReq.Version = Nvm.MacGroup2.Version;\r\n\r\n                        // There is a fundamental difference in reporting the status\r\n                        // of the LinkAdrRequests when ADR is on or off. When ADR is on, every\r\n                        // LinkAdrAns contains the same value. This does not hold when ADR is off,\r\n                        // where every LinkAdrAns requires an individual status.\r\n                        if( Nvm.MacGroup2.AdrCtrlOn == true )\r\n                        {\r\n                            // When ADR is on, the function RegionLinkAdrReq will take care\r\n                            // about the parsing and interpretation of the LinkAdrRequest block and\r\n                            // it provides one status which shall be applied to every LinkAdrAns\r\n                            linkAdrReq.PayloadSize = commandsSize - ( macIndex - 1 );\r\n                        }\r\n                        else\r\n                        {\r\n                            // When ADR is off, this function will loop over the individual LinkAdrRequests\r\n                            // and will call RegionLinkAdrReq for each individually, as every request\r\n                            // requires an individual answer.\r\n                            // When ADR is off, the function RegionLinkAdrReq ignores the new values for\r\n                            // ChannelsDatarate, ChannelsTxPower and ChannelsNbTrans.\r\n                            linkAdrReq.PayloadSize = 5;\r\n                        }\r\n\r\n                        // Process the ADR requests\r\n                        status = RegionLinkAdrReq( Nvm.MacGroup2.Region, &linkAdrReq, &linkAdrDatarate,\r\n                                                &linkAdrTxPower, &linkAdrNbRep, &linkAdrNbBytesParsed );\r\n\r\n                        if( ( status & 0x07 ) == 0x07 )\r\n                        {\r\n                            // Set the status that the datarate has been increased\r\n                            if( linkAdrDatarate > Nvm.MacGroup1.ChannelsDatarate )\r\n                            {\r\n                                Nvm.MacGroup2.ChannelsDatarateChangedLinkAdrReq = true;\r\n                            }\r\n                            Nvm.MacGroup1.ChannelsDatarate = linkAdrDatarate;\r\n                            Nvm.MacGroup1.ChannelsTxPower = linkAdrTxPower;\r\n                            Nvm.MacGroup2.MacParams.ChannelsNbTrans = linkAdrNbRep;\r\n                        }\r\n\r\n                        // Add the answers to the buffer\r\n                        for( uint8_t i = 0; i < ( linkAdrNbBytesParsed / 5 ); i++ )\r\n                        {\r\n                            LoRaMacCommandsAddCmd( MOTE_MAC_LINK_ADR_ANS, &status, 1 );\r\n                        }\r\n                        // Update MAC index\r\n                        macIndex += linkAdrNbBytesParsed - 1;\r\n\r\n                        // Check to prevent invalid access\r\n                        if( macIndex >= commandsSize )\r\n                            break;\r\n\r\n                    } while( payload[macIndex++] == SRV_MAC_LINK_ADR_REQ );\r\n\r\n                    if( macIndex < commandsSize )\r\n                    {\r\n                        // Decrease the index such that it points to the next MAC command\r\n                        macIndex--;\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    // Increase the index by the MAC command size (without command)\r\n                    macIndex += 4;\r\n                }\r\n                break;\r\n            }\r\n            case SRV_MAC_DUTY_CYCLE_REQ:\r\n            {\r\n                Nvm.MacGroup2.MaxDCycle = payload[macIndex++] & 0x0F;\r\n                Nvm.MacGroup2.AggregatedDCycle = 1 << Nvm.MacGroup2.MaxDCycle;\r\n                LoRaMacCommandsAddCmd( MOTE_MAC_DUTY_CYCLE_ANS, macCmdPayload, 0 );\r\n                break;\r\n            }\r\n            case SRV_MAC_RX_PARAM_SETUP_REQ:\r\n            {\r\n                RxParamSetupReqParams_t rxParamSetupReq;\r\n                status = 0x07;\r\n\r\n                rxParamSetupReq.DrOffset = ( payload[macIndex] >> 4 ) & 0x07;\r\n                rxParamSetupReq.Datarate = payload[macIndex] & 0x0F;\r\n                macIndex++;\r\n\r\n                rxParamSetupReq.Frequency = ( uint32_t ) payload[macIndex++];\r\n                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 8;\r\n                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 16;\r\n                rxParamSetupReq.Frequency *= 100;\r\n\r\n                // Perform request on region\r\n                status = RegionRxParamSetupReq( Nvm.MacGroup2.Region, &rxParamSetupReq );\r\n\r\n                if( ( status & 0x07 ) == 0x07 )\r\n                {\r\n                    Nvm.MacGroup2.MacParams.Rx2Channel.Datarate = rxParamSetupReq.Datarate;\r\n                    Nvm.MacGroup2.MacParams.RxCChannel.Datarate = rxParamSetupReq.Datarate;\r\n                    Nvm.MacGroup2.MacParams.Rx2Channel.Frequency = rxParamSetupReq.Frequency;\r\n                    Nvm.MacGroup2.MacParams.RxCChannel.Frequency = rxParamSetupReq.Frequency;\r\n                    Nvm.MacGroup2.MacParams.Rx1DrOffset = rxParamSetupReq.DrOffset;\r\n                }\r\n                macCmdPayload[0] = status;\r\n                LoRaMacCommandsAddCmd( MOTE_MAC_RX_PARAM_SETUP_ANS, macCmdPayload, 1 );\r\n                break;\r\n            }\r\n            case SRV_MAC_DEV_STATUS_REQ:\r\n            {\r\n                uint8_t batteryLevel = BAT_LEVEL_NO_MEASURE;\r\n                if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->GetBatteryLevel != NULL ) )\r\n                {\r\n                    batteryLevel = MacCtx.MacCallbacks->GetBatteryLevel( );\r\n                }\r\n                macCmdPayload[0] = batteryLevel;\r\n                macCmdPayload[1] = ( uint8_t )( snr & 0x3F );\r\n                LoRaMacCommandsAddCmd( MOTE_MAC_DEV_STATUS_ANS, macCmdPayload, 2 );\r\n                break;\r\n            }\r\n            case SRV_MAC_NEW_CHANNEL_REQ:\r\n            {\r\n                NewChannelReqParams_t newChannelReq;\r\n                ChannelParams_t chParam;\r\n                status = 0x03;\r\n\r\n                newChannelReq.ChannelId = payload[macIndex++];\r\n                newChannelReq.NewChannel = &chParam;\r\n\r\n                chParam.Frequency = ( uint32_t ) payload[macIndex++];\r\n                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 8;\r\n                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 16;\r\n                chParam.Frequency *= 100;\r\n                chParam.Rx1Frequency = 0;\r\n                chParam.DrRange.Value = payload[macIndex++];\r\n\r\n                status = ( uint8_t )RegionNewChannelReq( Nvm.MacGroup2.Region, &newChannelReq );\r\n\r\n                if( ( int8_t )status >= 0 )\r\n                {\r\n                    macCmdPayload[0] = status;\r\n                    LoRaMacCommandsAddCmd( MOTE_MAC_NEW_CHANNEL_ANS, macCmdPayload, 1 );\r\n                }\r\n                break;\r\n            }\r\n            case SRV_MAC_RX_TIMING_SETUP_REQ:\r\n            {\r\n                uint8_t delay = payload[macIndex++] & 0x0F;\r\n\r\n                if( delay == 0 )\r\n                {\r\n                    delay++;\r\n                }\r\n                Nvm.MacGroup2.MacParams.ReceiveDelay1 = delay * 1000;\r\n                Nvm.MacGroup2.MacParams.ReceiveDelay2 = Nvm.MacGroup2.MacParams.ReceiveDelay1 + 1000;\r\n                LoRaMacCommandsAddCmd( MOTE_MAC_RX_TIMING_SETUP_ANS, macCmdPayload, 0 );\r\n                break;\r\n            }\r\n            case SRV_MAC_TX_PARAM_SETUP_REQ:\r\n            {\r\n                TxParamSetupReqParams_t txParamSetupReq;\r\n                GetPhyParams_t getPhy;\r\n                PhyParam_t phyParam;\r\n                uint8_t eirpDwellTime = payload[macIndex++];\r\n\r\n                txParamSetupReq.UplinkDwellTime = 0;\r\n                txParamSetupReq.DownlinkDwellTime = 0;\r\n\r\n                if( ( eirpDwellTime & 0x20 ) == 0x20 )\r\n                {\r\n                    txParamSetupReq.DownlinkDwellTime = 1;\r\n                }\r\n                if( ( eirpDwellTime & 0x10 ) == 0x10 )\r\n                {\r\n                    txParamSetupReq.UplinkDwellTime = 1;\r\n                }\r\n                txParamSetupReq.MaxEirp = eirpDwellTime & 0x0F;\r\n\r\n                // Check the status for correctness\r\n                if( RegionTxParamSetupReq( Nvm.MacGroup2.Region, &txParamSetupReq ) != -1 )\r\n                {\r\n                    // Accept command\r\n                    Nvm.MacGroup2.MacParams.UplinkDwellTime = txParamSetupReq.UplinkDwellTime;\r\n                    Nvm.MacGroup2.MacParams.DownlinkDwellTime = txParamSetupReq.DownlinkDwellTime;\r\n                    Nvm.MacGroup2.MacParams.MaxEirp = LoRaMacMaxEirpTable[txParamSetupReq.MaxEirp];\r\n                    // Update the datarate in case of the new configuration limits it\r\n                    getPhy.Attribute = PHY_MIN_TX_DR;\r\n                    getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;\r\n                    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );\r\n                    Nvm.MacGroup1.ChannelsDatarate = MAX( Nvm.MacGroup1.ChannelsDatarate, ( int8_t )phyParam.Value );\r\n\r\n                    // Add command response\r\n                    LoRaMacCommandsAddCmd( MOTE_MAC_TX_PARAM_SETUP_ANS, macCmdPayload, 0 );\r\n                }\r\n                break;\r\n            }\r\n            case SRV_MAC_REKEY_CONF:\r\n            {\r\n                uint8_t serverMinorVersion = payload[macIndex++];\r\n\r\n                // Compare own LoRaWAN Version with server's\r\n                if( Nvm.MacGroup2.Version.Fields.Minor >= serverMinorVersion )\r\n                {\r\n                    // If they equal remove the sticky RekeyInd MAC-Command.\r\n                    if( LoRaMacCommandsGetCmd( MOTE_MAC_REKEY_IND, &macCmd) == LORAMAC_COMMANDS_SUCCESS )\r\n                    {\r\n                        LoRaMacCommandsRemoveCmd( macCmd );\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n            case SRV_MAC_DL_CHANNEL_REQ:\r\n            {\r\n                DlChannelReqParams_t dlChannelReq;\r\n                status = 0x03;\r\n\r\n                dlChannelReq.ChannelId = payload[macIndex++];\r\n                dlChannelReq.Rx1Frequency = ( uint32_t ) payload[macIndex++];\r\n                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 8;\r\n                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 16;\r\n                dlChannelReq.Rx1Frequency *= 100;\r\n\r\n                status = ( uint8_t )RegionDlChannelReq( Nvm.MacGroup2.Region, &dlChannelReq );\r\n\r\n                if( ( int8_t )status >= 0 )\r\n                {\r\n                    macCmdPayload[0] = status;\r\n                    LoRaMacCommandsAddCmd( MOTE_MAC_DL_CHANNEL_ANS, macCmdPayload, 1 );\r\n                }\r\n                break;\r\n            }\r\n            case SRV_MAC_ADR_PARAM_SETUP_REQ:\r\n            {\r\n                /* ADRParamSetupReq Payload:  ADRparam\r\n                 * +----------------+---------------+\r\n                 * | 7:4 Limit_exp  | 3:0 Delay_exp |\r\n                 * +----------------+---------------+\r\n                 */\r\n\r\n                uint8_t delayExp = 0x0F & payload[macIndex];\r\n                uint8_t limitExp = 0x0F & ( payload[macIndex] >> 4 );\r\n                macIndex++;\r\n\r\n                // ADR_ACK_ DELAY = 2^Delay_exp\r\n                Nvm.MacGroup2.MacParams.AdrAckDelay = 0x01 << delayExp;\r\n\r\n                // ADR_ACK_LIMIT = 2^Limit_exp\r\n                Nvm.MacGroup2.MacParams.AdrAckLimit = 0x01 << limitExp;\r\n\r\n                LoRaMacCommandsAddCmd( MOTE_MAC_ADR_PARAM_SETUP_ANS, macCmdPayload, 0 );\r\n                break;\r\n            }\r\n            case SRV_MAC_FORCE_REJOIN_REQ:\r\n            {\r\n                /* ForceRejoinReq Payload:\r\n                 * +--------------+------------------+-------+----------------+--------+\r\n                 * | 13:11 Period | 10:8 Max_Retries | 7 RFU | 6:4 RejoinType | 3:0 DR |\r\n                 * +--------------+------------------+-------+----------------+--------+\r\n                 */\r\n\r\n                // Parse payload\r\n                uint8_t period = ( 0x38 & payload[macIndex] ) >> 3;\r\n                Nvm.MacGroup2.ForceRejoinMaxRetries = 0x07 & payload[macIndex];\r\n                macIndex++;\r\n                Nvm.MacGroup2.ForceRejoinType = ( 0x70 & payload[macIndex] ) >> 4;\r\n                Nvm.MacGroup1.ChannelsDatarate = 0x0F & payload[macIndex];\r\n                macIndex ++;\r\n\r\n                // Calc delay between retransmissions: 32 seconds x 2^Period + Rand32\r\n                uint32_t rejoinCycleInSec = 32 * ( 0x01 << period ) + randr( 0, 32 );\r\n\r\n                MacCtx.ForceRejonCycleTime = 0;\r\n                Nvm.MacGroup1.ForceRejoinRetriesCounter = 0;\r\n                ConvertRejoinCycleTime( rejoinCycleInSec, &MacCtx.ForceRejonCycleTime );\r\n                OnForceRejoinReqCycleTimerEvent( NULL );\r\n                break;\r\n            }\r\n            case SRV_MAC_REJOIN_PARAM_REQ:\r\n            {\r\n                /* RejoinParamSetupReq Payload:\r\n                 * +----------------+---------------+\r\n                 * | 7:4 MaxTimeN   | 3:0 MaxCountN |\r\n                 * +----------------+---------------+\r\n                 */\r\n                uint8_t maxCountN = 0x0F & payload[macIndex];\r\n                uint8_t maxTimeN = 0x0F & ( payload[macIndex] >> 4 );\r\n                uint32_t cycleInSec = 0x01 << ( maxTimeN + 10 );\r\n                uint32_t timeInMs = 0;\r\n                uint16_t uplinkLimit = 0x01 << ( maxCountN + 4 );\r\n                macIndex++;\r\n                macCmdPayload[0] = 0;\r\n\r\n                if( ConvertRejoinCycleTime( cycleInSec, &timeInMs ) == true )\r\n                {\r\n                    // Calc delay between retransmissions: 2^(maxTimeN+10)\r\n                    Nvm.MacGroup2.Rejoin0CycleInSec = cycleInSec;\r\n                    // Calc number if uplinks without rejoin request: 2^(maxCountN+4)\r\n                    Nvm.MacGroup2.Rejoin0UplinksLimit = uplinkLimit;\r\n                    MacCtx.Rejoin0CycleTime = timeInMs;\r\n\r\n                    macCmdPayload[0] = 0x01;\r\n                    TimerStop( &MacCtx.Rejoin0CycleTimer );\r\n                    TimerSetValue( &MacCtx.Rejoin0CycleTimer, MacCtx.Rejoin0CycleTime );\r\n                    TimerStart( &MacCtx.Rejoin0CycleTimer );\r\n                }\r\n                LoRaMacCommandsAddCmd( MOTE_MAC_REJOIN_PARAM_ANS, macCmdPayload, 1 );\r\n                break;\r\n             }\r\n            case SRV_MAC_DEVICE_MODE_CONF:\r\n            {\r\n                // 1 byte payload which we do not handle.\r\n                macIndex++;\r\n                if( LoRaMacCommandsGetCmd( MOTE_MAC_DEVICE_MODE_IND, &macCmd) == LORAMAC_COMMANDS_SUCCESS )\r\n                {\r\n                    LoRaMacCommandsRemoveCmd( macCmd );\r\n                }\r\n                break;\r\n            }\r\n            case SRV_MAC_DEVICE_TIME_ANS:\r\n            {\r\n                // The mote time can be updated only when the time is received in classA\r\n                // receive windows only.\r\n                if( LoRaMacConfirmQueueIsCmdActive( MLME_DEVICE_TIME ) == true )\r\n                {\r\n                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_DEVICE_TIME );\r\n\r\n                    SysTime_t gpsEpochTime = { 0 };\r\n                    SysTime_t sysTime = { 0 };\r\n                    SysTime_t sysTimeCurrent = { 0 };\r\n\r\n                    gpsEpochTime.Seconds = ( uint32_t )payload[macIndex++];\r\n                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 8;\r\n                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 16;\r\n                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 24;\r\n                    gpsEpochTime.SubSeconds = payload[macIndex++];\r\n\r\n                    // Convert the fractional second received in ms\r\n                    // round( pow( 0.5, 8.0 ) * 1000 ) = 3.90625\r\n                    gpsEpochTime.SubSeconds = ( int16_t )( ( ( int32_t )gpsEpochTime.SubSeconds * 1000 ) >> 8 );\r\n\r\n                    // Copy received GPS Epoch time into system time\r\n                    sysTime = gpsEpochTime;\r\n                    // Add Unix to Gps epoch offset. The system time is based on Unix time.\r\n                    sysTime.Seconds += UNIX_GPS_EPOCH_OFFSET;\r\n\r\n                    // Compensate time difference between Tx Done time and now\r\n                    sysTimeCurrent = SysTimeGet( );\r\n                    sysTime = SysTimeAdd( sysTimeCurrent, SysTimeSub( sysTime, MacCtx.LastTxSysTime ) );\r\n\r\n                    // Apply the new system time.\r\n                    SysTimeSet( sysTime );\r\n                    LoRaMacClassBDeviceTimeAns( );\r\n                    MacCtx.McpsIndication.DeviceTimeAnsReceived = true;\r\n                }\r\n                else\r\n                {\r\n                    // Incase of other receive windows the Device Time Answer is not received.\r\n                    MacCtx.McpsIndication.DeviceTimeAnsReceived = false;\r\n                }\r\n                break;\r\n            }\r\n            case SRV_MAC_PING_SLOT_INFO_ANS:\r\n            {\r\n                if( LoRaMacConfirmQueueIsCmdActive( MLME_PING_SLOT_INFO ) == true )\r\n                {\r\n                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_PING_SLOT_INFO );\r\n                    // According to the specification, it is not allowed to process this answer in\r\n                    // a ping or multicast slot\r\n                    if( ( MacCtx.RxSlot != RX_SLOT_WIN_CLASS_B_PING_SLOT ) && ( MacCtx.RxSlot != RX_SLOT_WIN_CLASS_B_MULTICAST_SLOT ) )\r\n                    {\r\n                        LoRaMacClassBPingSlotInfoAns( );\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n            case SRV_MAC_PING_SLOT_CHANNEL_REQ:\r\n            {\r\n                uint8_t status = 0x03;\r\n                uint32_t frequency = 0;\r\n                uint8_t datarate;\r\n\r\n                frequency = ( uint32_t )payload[macIndex++];\r\n                frequency |= ( uint32_t )payload[macIndex++] << 8;\r\n                frequency |= ( uint32_t )payload[macIndex++] << 16;\r\n                frequency *= 100;\r\n                datarate = payload[macIndex++] & 0x0F;\r\n\r\n                status = LoRaMacClassBPingSlotChannelReq( datarate, frequency );\r\n                macCmdPayload[0] = status;\r\n                LoRaMacCommandsAddCmd( MOTE_MAC_PING_SLOT_CHANNEL_ANS, macCmdPayload, 1 );\r\n                break;\r\n            }\r\n            case SRV_MAC_BEACON_TIMING_ANS:\r\n            {\r\n                if( LoRaMacConfirmQueueIsCmdActive( MLME_BEACON_TIMING ) == true )\r\n                {\r\n                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_BEACON_TIMING );\r\n                    uint16_t beaconTimingDelay = 0;\r\n                    uint8_t beaconTimingChannel = 0;\r\n\r\n                    beaconTimingDelay = ( uint16_t )payload[macIndex++];\r\n                    beaconTimingDelay |= ( uint16_t )payload[macIndex++] << 8;\r\n                    beaconTimingChannel = payload[macIndex++];\r\n\r\n                    LoRaMacClassBBeaconTimingAns( beaconTimingDelay, beaconTimingChannel, RxDoneParams.LastRxDone );\r\n                }\r\n                break;\r\n            }\r\n            case SRV_MAC_BEACON_FREQ_REQ:\r\n                {\r\n                    uint32_t frequency = 0;\r\n\r\n                    frequency = ( uint32_t )payload[macIndex++];\r\n                    frequency |= ( uint32_t )payload[macIndex++] << 8;\r\n                    frequency |= ( uint32_t )payload[macIndex++] << 16;\r\n                    frequency *= 100;\r\n\r\n                    if( LoRaMacClassBBeaconFreqReq( frequency ) == true )\r\n                    {\r\n                        macCmdPayload[0] = 1;\r\n                    }\r\n                    else\r\n                    {\r\n                        macCmdPayload[0] = 0;\r\n                    }\r\n                    LoRaMacCommandsAddCmd( MOTE_MAC_BEACON_FREQ_ANS, macCmdPayload, 1 );\r\n                }\r\n                break;\r\n            default:\r\n                // Unknown command. ABORT MAC commands processing\r\n                return;\r\n        }\r\n    }\r\n}\r\n\r\nLoRaMacStatus_t Send( LoRaMacHeader_t* macHdr, uint8_t fPort, void* fBuffer, uint16_t fBufferSize )\r\n{\r\n    LoRaMacFrameCtrl_t fCtrl;\r\n    LoRaMacStatus_t status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n    int8_t datarate = Nvm.MacGroup1.ChannelsDatarate;\r\n    int8_t txPower = Nvm.MacGroup1.ChannelsTxPower;\r\n    uint32_t adrAckCounter = Nvm.MacGroup1.AdrAckCounter;\r\n    CalcNextAdrParams_t adrNext;\r\n\r\n    // Check if we are joined\r\n    if( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_NONE )\r\n    {\r\n        return LORAMAC_STATUS_NO_NETWORK_JOINED;\r\n    }\r\n    if( Nvm.MacGroup2.MaxDCycle == 0 )\r\n    {\r\n        Nvm.MacGroup1.AggregatedTimeOff = 0;\r\n    }\r\n\r\n    fCtrl.Value = 0;\r\n    fCtrl.Bits.FOptsLen      = 0;\r\n    fCtrl.Bits.Adr           = Nvm.MacGroup2.AdrCtrlOn;\r\n\r\n    // Check class b\r\n    if( Nvm.MacGroup2.DeviceClass == CLASS_B )\r\n    {\r\n        fCtrl.Bits.FPending      = 1;\r\n    }\r\n    else\r\n    {\r\n        fCtrl.Bits.FPending      = 0;\r\n    }\r\n\r\n    // Check server ack\r\n    if( Nvm.MacGroup1.SrvAckRequested == true )\r\n    {\r\n        fCtrl.Bits.Ack = 1;\r\n    }\r\n\r\n    // ADR next request\r\n    adrNext.UpdateChanMask = true;\r\n    adrNext.AdrEnabled = fCtrl.Bits.Adr;\r\n    adrNext.AdrAckCounter = Nvm.MacGroup1.AdrAckCounter;\r\n    adrNext.AdrAckLimit = Nvm.MacGroup2.MacParams.AdrAckLimit;\r\n    adrNext.AdrAckDelay = Nvm.MacGroup2.MacParams.AdrAckDelay;\r\n    adrNext.Datarate = Nvm.MacGroup1.ChannelsDatarate;\r\n    adrNext.TxPower = Nvm.MacGroup1.ChannelsTxPower;\r\n    adrNext.NbTrans = Nvm.MacGroup2.MacParams.ChannelsNbTrans;\r\n    adrNext.UplinkDwellTime =  Nvm.MacGroup2.MacParams.UplinkDwellTime;\r\n    adrNext.Region = Nvm.MacGroup2.Region;\r\n\r\n    fCtrl.Bits.AdrAckReq = LoRaMacAdrCalcNext( &adrNext, &Nvm.MacGroup1.ChannelsDatarate,\r\n                                               &Nvm.MacGroup1.ChannelsTxPower,\r\n                                               &Nvm.MacGroup2.MacParams.ChannelsNbTrans, &adrAckCounter );\r\n\r\n    // Prepare the frame\r\n    status = PrepareFrame( macHdr, &fCtrl, fPort, fBuffer, fBufferSize );\r\n\r\n    // Validate status\r\n    if( ( status == LORAMAC_STATUS_OK ) || ( status == LORAMAC_STATUS_SKIPPED_APP_DATA ) )\r\n    {\r\n        // Schedule frame, do not allow delayed transmissions\r\n        status = ScheduleTx( false );\r\n    }\r\n\r\n    // Post processing\r\n    if( status != LORAMAC_STATUS_OK )\r\n    {\r\n        // Bad case - restore\r\n        // Store local variables\r\n        Nvm.MacGroup1.ChannelsDatarate = datarate;\r\n        Nvm.MacGroup1.ChannelsTxPower = txPower;\r\n    }\r\n    else\r\n    {\r\n        // Good case\r\n        Nvm.MacGroup1.SrvAckRequested = false;\r\n        Nvm.MacGroup1.AdrAckCounter = adrAckCounter;\r\n        // Remove all none sticky MAC commands\r\n        if( LoRaMacCommandsRemoveNoneStickyCmds( ) != LORAMAC_COMMANDS_SUCCESS )\r\n        {\r\n            return LORAMAC_STATUS_MAC_COMMAD_ERROR;\r\n        }\r\n    }\r\n    return status;\r\n}\r\n\r\nLoRaMacStatus_t SendReJoinReq( JoinReqIdentifier_t joinReqType )\r\n{\r\n    LoRaMacStatus_t status = LORAMAC_STATUS_OK;\r\n    LoRaMacHeader_t macHdr;\r\n    macHdr.Value = 0;\r\n    bool allowDelayedTx = true;\r\n\r\n    // Setup join/rejoin message\r\n    switch( joinReqType )\r\n    {\r\n        case REJOIN_REQ_1:\r\n        {\r\n            Nvm.MacGroup2.IsRejoinAcceptPending = true;\r\n\r\n            MacCtx.TxMsg.Type = LORAMAC_MSG_TYPE_RE_JOIN_1;\r\n            MacCtx.TxMsg.Message.ReJoin1.Buffer = MacCtx.PktBuffer;\r\n            MacCtx.TxMsg.Message.ReJoin1.BufSize = LORAMAC_PHY_MAXPAYLOAD;\r\n\r\n            macHdr.Bits.MType = FRAME_TYPE_REJOIN;\r\n            MacCtx.TxMsg.Message.ReJoin1.MHDR.Value = macHdr.Value;\r\n\r\n            MacCtx.TxMsg.Message.ReJoin1.ReJoinType = 1;\r\n\r\n            memcpy1( MacCtx.TxMsg.Message.ReJoin1.JoinEUI, SecureElementGetJoinEui( ), LORAMAC_JOIN_EUI_FIELD_SIZE );\r\n            memcpy1( MacCtx.TxMsg.Message.ReJoin1.DevEUI, SecureElementGetDevEui( ), LORAMAC_DEV_EUI_FIELD_SIZE );\r\n\r\n            if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoGetRJcount( RJ_COUNT_1, &MacCtx.TxMsg.Message.ReJoin1.RJcount1 ) )\r\n            {\r\n                return LORAMAC_STATUS_CRYPTO_ERROR;\r\n            }\r\n\r\n            break;\r\n        }\r\n        case REJOIN_REQ_0:\r\n        case REJOIN_REQ_2:\r\n        {\r\n            if( joinReqType == REJOIN_REQ_0 )\r\n            {\r\n                MacCtx.TxMsg.Message.ReJoin0or2.ReJoinType = 0;\r\n            }\r\n            else\r\n            {\r\n                MacCtx.TxMsg.Message.ReJoin0or2.ReJoinType = 2;\r\n            }\r\n\r\n            Nvm.MacGroup2.IsRejoinAcceptPending = true;\r\n\r\n            MacCtx.TxMsg.Type = LORAMAC_MSG_TYPE_RE_JOIN_0_2;\r\n            MacCtx.TxMsg.Message.ReJoin0or2.Buffer = MacCtx.PktBuffer;\r\n            MacCtx.TxMsg.Message.ReJoin0or2.BufSize = LORAMAC_PHY_MAXPAYLOAD;\r\n\r\n            macHdr.Bits.MType = FRAME_TYPE_REJOIN;\r\n            MacCtx.TxMsg.Message.ReJoin0or2.MHDR.Value = macHdr.Value;\r\n\r\n            MacCtx.TxMsg.Message.ReJoin0or2.NetID[0] = Nvm.MacGroup2.NetID & 0xFF;\r\n            MacCtx.TxMsg.Message.ReJoin0or2.NetID[1] = ( Nvm.MacGroup2.NetID >> 8 ) & 0xFF;\r\n            MacCtx.TxMsg.Message.ReJoin0or2.NetID[2] = ( Nvm.MacGroup2.NetID >> 16 ) & 0xFF;\r\n\r\n            memcpy1( MacCtx.TxMsg.Message.ReJoin0or2.DevEUI, SecureElementGetDevEui( ), LORAMAC_DEV_EUI_FIELD_SIZE );\r\n\r\n            if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoGetRJcount( RJ_COUNT_0, &MacCtx.TxMsg.Message.ReJoin0or2.RJcount0 ) )\r\n            {\r\n                return LORAMAC_STATUS_CRYPTO_ERROR;\r\n            }\r\n\r\n            break;\r\n        }\r\n        case JOIN_REQ:\r\n        {\r\n            SwitchClass( CLASS_A );\r\n\r\n            MacCtx.TxMsg.Type = LORAMAC_MSG_TYPE_JOIN_REQUEST;\r\n            MacCtx.TxMsg.Message.JoinReq.Buffer = MacCtx.PktBuffer;\r\n            MacCtx.TxMsg.Message.JoinReq.BufSize = LORAMAC_PHY_MAXPAYLOAD;\r\n\r\n            macHdr.Bits.MType = FRAME_TYPE_JOIN_REQ;\r\n            MacCtx.TxMsg.Message.JoinReq.MHDR.Value = macHdr.Value;\r\n\r\n            memcpy1( MacCtx.TxMsg.Message.JoinReq.JoinEUI, SecureElementGetJoinEui( ), LORAMAC_JOIN_EUI_FIELD_SIZE );\r\n            memcpy1( MacCtx.TxMsg.Message.JoinReq.DevEUI, SecureElementGetDevEui( ), LORAMAC_DEV_EUI_FIELD_SIZE );\r\n\r\n            allowDelayedTx = false;\r\n\r\n            break;\r\n        }\r\n        default:\r\n            status = LORAMAC_STATUS_SERVICE_UNKNOWN;\r\n            break;\r\n    }\r\n\r\n    // Schedule frame\r\n    status = ScheduleTx( allowDelayedTx );\r\n    return status;\r\n}\r\n\r\nstatic LoRaMacStatus_t CheckForClassBCollision( void )\r\n{\r\n    if( LoRaMacClassBIsBeaconExpected( ) == true )\r\n    {\r\n        return LORAMAC_STATUS_BUSY_BEACON_RESERVED_TIME;\r\n    }\r\n\r\n    if( Nvm.MacGroup2.DeviceClass == CLASS_B )\r\n    {\r\n        if( LoRaMacClassBIsPingExpected( ) == true )\r\n        {\r\n            return LORAMAC_STATUS_BUSY_PING_SLOT_WINDOW_TIME;\r\n        }\r\n        else if( LoRaMacClassBIsMulticastExpected( ) == true )\r\n        {\r\n            return LORAMAC_STATUS_BUSY_PING_SLOT_WINDOW_TIME;\r\n        }\r\n    }\r\n    return LORAMAC_STATUS_OK;\r\n}\r\n\r\nstatic void ComputeRxWindowParameters( void )\r\n{\r\n    // Compute Rx1 windows parameters\r\n    RegionComputeRxWindowParameters( Nvm.MacGroup2.Region,\r\n                                     RegionApplyDrOffset( Nvm.MacGroup2.Region,\r\n                                                          Nvm.MacGroup2.MacParams.DownlinkDwellTime,\r\n                                                          Nvm.MacGroup1.ChannelsDatarate,\r\n                                                          Nvm.MacGroup2.MacParams.Rx1DrOffset ),\r\n                                     Nvm.MacGroup2.MacParams.MinRxSymbols,\r\n                                     Nvm.MacGroup2.MacParams.SystemMaxRxError,\r\n                                     &MacCtx.RxWindow1Config );\r\n    // Compute Rx2 windows parameters\r\n    RegionComputeRxWindowParameters( Nvm.MacGroup2.Region,\r\n                                     Nvm.MacGroup2.MacParams.Rx2Channel.Datarate,\r\n                                     Nvm.MacGroup2.MacParams.MinRxSymbols,\r\n                                     Nvm.MacGroup2.MacParams.SystemMaxRxError,\r\n                                     &MacCtx.RxWindow2Config );\r\n\r\n    // Default setup, in case the device joined\r\n    MacCtx.RxWindow1Delay = Nvm.MacGroup2.MacParams.ReceiveDelay1 + MacCtx.RxWindow1Config.WindowOffset;\r\n    MacCtx.RxWindow2Delay = Nvm.MacGroup2.MacParams.ReceiveDelay2 + MacCtx.RxWindow2Config.WindowOffset;\r\n\r\n    if( MacCtx.TxMsg.Type != LORAMAC_MSG_TYPE_DATA )\r\n    {\r\n        MacCtx.RxWindow1Delay = Nvm.MacGroup2.MacParams.JoinAcceptDelay1 + MacCtx.RxWindow1Config.WindowOffset;\r\n        MacCtx.RxWindow2Delay = Nvm.MacGroup2.MacParams.JoinAcceptDelay2 + MacCtx.RxWindow2Config.WindowOffset;\r\n    }\r\n}\r\n\r\nstatic LoRaMacStatus_t VerifyTxFrame( void )\r\n{\r\n    size_t macCmdsSize = 0;\r\n\r\n    if( Nvm.MacGroup2.NetworkActivation != ACTIVATION_TYPE_NONE )\r\n    {\r\n        if( LoRaMacCommandsGetSizeSerializedCmds( &macCmdsSize ) != LORAMAC_COMMANDS_SUCCESS )\r\n        {\r\n            return LORAMAC_STATUS_MAC_COMMAD_ERROR;\r\n        }\r\n\r\n        if( ValidatePayloadLength( MacCtx.AppDataSize, Nvm.MacGroup1.ChannelsDatarate, macCmdsSize ) == false )\r\n        {\r\n            return LORAMAC_STATUS_LENGTH_ERROR;\r\n        }\r\n    }\r\n    return LORAMAC_STATUS_OK;\r\n}\r\n\r\nstatic LoRaMacStatus_t SerializeTxFrame( void )\r\n{\r\n    LoRaMacSerializerStatus_t serializeStatus;\r\n\r\n    switch( MacCtx.TxMsg.Type )\r\n    {\r\n        case LORAMAC_MSG_TYPE_JOIN_REQUEST:\r\n            serializeStatus = LoRaMacSerializerJoinRequest( &MacCtx.TxMsg.Message.JoinReq );\r\n            if( LORAMAC_SERIALIZER_SUCCESS != serializeStatus )\r\n            {\r\n                return LORAMAC_STATUS_CRYPTO_ERROR;\r\n            }\r\n            MacCtx.PktBufferLen = MacCtx.TxMsg.Message.JoinReq.BufSize;\r\n            break;\r\n        case LORAMAC_MSG_TYPE_RE_JOIN_1:\r\n            serializeStatus = LoRaMacSerializerReJoinType1( &MacCtx.TxMsg.Message.ReJoin1 );\r\n            if( LORAMAC_SERIALIZER_SUCCESS != serializeStatus )\r\n            {\r\n                return LORAMAC_STATUS_CRYPTO_ERROR;\r\n            }\r\n            MacCtx.PktBufferLen = MacCtx.TxMsg.Message.ReJoin1.BufSize;\r\n            break;\r\n        case LORAMAC_MSG_TYPE_RE_JOIN_0_2:\r\n            serializeStatus = LoRaMacSerializerReJoinType0or2( &MacCtx.TxMsg.Message.ReJoin0or2 );\r\n            if( LORAMAC_SERIALIZER_SUCCESS != serializeStatus )\r\n            {\r\n                return LORAMAC_STATUS_CRYPTO_ERROR;\r\n            }\r\n            MacCtx.PktBufferLen = MacCtx.TxMsg.Message.ReJoin0or2.BufSize;\r\n            break;\r\n        case LORAMAC_MSG_TYPE_DATA:\r\n            serializeStatus = LoRaMacSerializerData( &MacCtx.TxMsg.Message.Data );\r\n            if( LORAMAC_SERIALIZER_SUCCESS != serializeStatus )\r\n            {\r\n                return LORAMAC_STATUS_CRYPTO_ERROR;\r\n            }\r\n            MacCtx.PktBufferLen = MacCtx.TxMsg.Message.Data.BufSize;\r\n            break;\r\n        case LORAMAC_MSG_TYPE_JOIN_ACCEPT:\r\n        case LORAMAC_MSG_TYPE_UNDEF:\r\n        default:\r\n            return LORAMAC_STATUS_PARAMETER_INVALID;\r\n    }\r\n    return LORAMAC_STATUS_OK;\r\n}\r\n\r\nstatic LoRaMacStatus_t ScheduleTx( bool allowDelayedTx )\r\n{\r\n    LoRaMacStatus_t status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n    NextChanParams_t nextChan;\r\n\r\n    // Check class b collisions\r\n    status = CheckForClassBCollision( );\r\n    if( status != LORAMAC_STATUS_OK )\r\n    {\r\n        return status;\r\n    }\r\n\r\n    // Update back-off\r\n    CalculateBackOff( );\r\n\r\n    // Serialize frame\r\n    status = SerializeTxFrame( );\r\n    if( status != LORAMAC_STATUS_OK )\r\n    {\r\n        return status;\r\n    }\r\n\r\n    nextChan.AggrTimeOff = Nvm.MacGroup1.AggregatedTimeOff;\r\n    nextChan.Datarate = Nvm.MacGroup1.ChannelsDatarate;\r\n    nextChan.DutyCycleEnabled = Nvm.MacGroup2.DutyCycleOn;\r\n    nextChan.ElapsedTimeSinceStartUp = SysTimeSub( SysTimeGetMcuTime( ), Nvm.MacGroup2.InitializationTime );\r\n    nextChan.LastAggrTx = Nvm.MacGroup1.LastTxDoneTime;\r\n    nextChan.LastTxIsJoinRequest = false;\r\n    nextChan.Joined = true;\r\n    nextChan.PktLen = MacCtx.PktBufferLen;\r\n\r\n    // Setup the parameters based on the join status\r\n    if( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_NONE )\r\n    {\r\n        nextChan.LastTxIsJoinRequest = true;\r\n        nextChan.Joined = false;\r\n    }\r\n\r\n    // Select channel\r\n    status = RegionNextChannel( Nvm.MacGroup2.Region, &nextChan, &MacCtx.Channel, &MacCtx.DutyCycleWaitTime, &Nvm.MacGroup1.AggregatedTimeOff );\r\n\r\n    if( status != LORAMAC_STATUS_OK )\r\n    {\r\n        if( status == LORAMAC_STATUS_DUTYCYCLE_RESTRICTED )\r\n        {\r\n            if( MacCtx.DutyCycleWaitTime != 0 )\r\n            {\r\n                if( allowDelayedTx == true )\r\n                {\r\n                    // Allow delayed transmissions. We have to allow it in case\r\n                    // the MAC must retransmit a frame with the frame repetitions\r\n                    MacCtx.MacState |= LORAMAC_TX_DELAYED;\r\n                    TimerSetValue( &MacCtx.TxDelayedTimer, MacCtx.DutyCycleWaitTime );\r\n                    TimerStart( &MacCtx.TxDelayedTimer );\r\n                    return LORAMAC_STATUS_OK;\r\n                }\r\n                // Need to delay, but allowDelayedTx does not allow it\r\n                return status;\r\n            }\r\n        }\r\n        else\r\n        {// State where the MAC cannot send a frame\r\n            return status;\r\n        }\r\n    }\r\n\r\n    // Compute window parameters, offsets, rx symbols, system errors etc.\r\n    ComputeRxWindowParameters( );\r\n\r\n    // Verify TX frame\r\n    status = VerifyTxFrame( );\r\n    if( status != LORAMAC_STATUS_OK )\r\n    {\r\n        return status;\r\n    }\r\n\r\n    // Try to send now\r\n    return SendFrameOnChannel( MacCtx.Channel );\r\n}\r\n\r\nstatic LoRaMacStatus_t SecureFrame( uint8_t txDr, uint8_t txCh )\r\n{\r\n    LoRaMacCryptoStatus_t macCryptoStatus = LORAMAC_CRYPTO_ERROR;\r\n    uint32_t fCntUp = 0;\r\n\r\n    switch( MacCtx.TxMsg.Type )\r\n    {\r\n        case LORAMAC_MSG_TYPE_JOIN_REQUEST:\r\n            macCryptoStatus = LoRaMacCryptoPrepareJoinRequest( &MacCtx.TxMsg.Message.JoinReq );\r\n            if( LORAMAC_CRYPTO_SUCCESS != macCryptoStatus )\r\n            {\r\n                return LORAMAC_STATUS_CRYPTO_ERROR;\r\n            }\r\n            MacCtx.PktBufferLen = MacCtx.TxMsg.Message.JoinReq.BufSize;\r\n            break;\r\n        case LORAMAC_MSG_TYPE_RE_JOIN_1:\r\n            macCryptoStatus = LoRaMacCryptoPrepareReJoinType1( &MacCtx.TxMsg.Message.ReJoin1 );\r\n            if( LORAMAC_CRYPTO_SUCCESS != macCryptoStatus )\r\n            {\r\n                return LORAMAC_STATUS_CRYPTO_ERROR;\r\n            }\r\n            MacCtx.PktBufferLen = MacCtx.TxMsg.Message.ReJoin1.BufSize;\r\n            break;\r\n        case LORAMAC_MSG_TYPE_RE_JOIN_0_2:\r\n            macCryptoStatus = LoRaMacCryptoPrepareReJoinType0or2( &MacCtx.TxMsg.Message.ReJoin0or2 );\r\n            if( LORAMAC_CRYPTO_SUCCESS != macCryptoStatus )\r\n            {\r\n                return LORAMAC_STATUS_CRYPTO_ERROR;\r\n            }\r\n            MacCtx.PktBufferLen = MacCtx.TxMsg.Message.ReJoin0or2.BufSize;\r\n            break;\r\n        case LORAMAC_MSG_TYPE_DATA:\r\n\r\n            if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoGetFCntUp( &fCntUp ) )\r\n            {\r\n                return LORAMAC_STATUS_FCNT_HANDLER_ERROR;\r\n            }\r\n\r\n            if( MacCtx.ChannelsNbTransCounter >= 1 )\r\n            {\r\n                fCntUp -= 1;\r\n            }\r\n\r\n            macCryptoStatus = LoRaMacCryptoSecureMessage( fCntUp, txDr, txCh, &MacCtx.TxMsg.Message.Data );\r\n            if( LORAMAC_CRYPTO_SUCCESS != macCryptoStatus )\r\n            {\r\n                return LORAMAC_STATUS_CRYPTO_ERROR;\r\n            }\r\n            MacCtx.PktBufferLen = MacCtx.TxMsg.Message.Data.BufSize;\r\n            break;\r\n        case LORAMAC_MSG_TYPE_JOIN_ACCEPT:\r\n        case LORAMAC_MSG_TYPE_UNDEF:\r\n        default:\r\n            return LORAMAC_STATUS_PARAMETER_INVALID;\r\n    }\r\n    return LORAMAC_STATUS_OK;\r\n}\r\n\r\nstatic void CalculateBackOff( void )\r\n{\r\n    // Make sure that the calculation of the backoff time for the aggregated time off will only be done in\r\n    // case the value is zero. It will be set to zero in the function RegionNextChannel.\r\n    if( Nvm.MacGroup1.AggregatedTimeOff == 0 )\r\n    {\r\n        // Update aggregated time-off. This must be an assignment and no incremental\r\n        // update as we do only calculate the time-off based on the last transmission\r\n        Nvm.MacGroup1.AggregatedTimeOff = ( MacCtx.TxTimeOnAir * Nvm.MacGroup2.AggregatedDCycle - MacCtx.TxTimeOnAir );\r\n    }\r\n}\r\n\r\nstatic void RemoveMacCommands( LoRaMacRxSlot_t rxSlot, LoRaMacFrameCtrl_t fCtrl, Mcps_t request )\r\n{\r\n    if( rxSlot == RX_SLOT_WIN_1 || rxSlot == RX_SLOT_WIN_2  )\r\n    {\r\n        // Remove all sticky MAC commands answers since we can assume\r\n        // that they have been received by the server.\r\n        if( request == MCPS_CONFIRMED )\r\n        {\r\n            if( fCtrl.Bits.Ack == 1 )\r\n            {  // For confirmed uplinks only if we have received an ACK.\r\n                LoRaMacCommandsRemoveStickyAnsCmds( );\r\n            }\r\n        }\r\n        else\r\n        {\r\n            LoRaMacCommandsRemoveStickyAnsCmds( );\r\n        }\r\n    }\r\n}\r\n\r\n\r\nstatic void ResetMacParameters( bool isRejoin )\r\n{\r\n    LoRaMacClassBCallback_t classBCallbacks;\r\n    LoRaMacClassBParams_t classBParams;\r\n\r\n    if( isRejoin == false )\r\n    {\r\n        Nvm.MacGroup2.NetworkActivation = ACTIVATION_TYPE_NONE;\r\n    }\r\n\r\n    // ADR counter\r\n    Nvm.MacGroup1.AdrAckCounter = 0;\r\n\r\n    MacCtx.ChannelsNbTransCounter = 0;\r\n    MacCtx.RetransmitTimeoutRetry = false;\r\n    MacCtx.ResponseTimeoutStartTime = 0;\r\n\r\n    Nvm.MacGroup2.MaxDCycle = 0;\r\n    Nvm.MacGroup2.AggregatedDCycle = 1;\r\n\r\n    Nvm.MacGroup1.ChannelsTxPower = Nvm.MacGroup2.ChannelsTxPowerDefault;\r\n    Nvm.MacGroup1.ChannelsDatarate = Nvm.MacGroup2.ChannelsDatarateDefault;\r\n    Nvm.MacGroup2.MacParams.Rx1DrOffset = Nvm.MacGroup2.MacParamsDefaults.Rx1DrOffset;\r\n    Nvm.MacGroup2.MacParams.Rx2Channel = Nvm.MacGroup2.MacParamsDefaults.Rx2Channel;\r\n    Nvm.MacGroup2.MacParams.RxCChannel = Nvm.MacGroup2.MacParamsDefaults.RxCChannel;\r\n    Nvm.MacGroup2.MacParams.UplinkDwellTime = Nvm.MacGroup2.MacParamsDefaults.UplinkDwellTime;\r\n    Nvm.MacGroup2.MacParams.DownlinkDwellTime = Nvm.MacGroup2.MacParamsDefaults.DownlinkDwellTime;\r\n    Nvm.MacGroup2.MacParams.MaxEirp = Nvm.MacGroup2.MacParamsDefaults.MaxEirp;\r\n    Nvm.MacGroup2.MacParams.AntennaGain = Nvm.MacGroup2.MacParamsDefaults.AntennaGain;\r\n    Nvm.MacGroup2.MacParams.AdrAckLimit = Nvm.MacGroup2.MacParamsDefaults.AdrAckLimit;\r\n    Nvm.MacGroup2.MacParams.AdrAckDelay = Nvm.MacGroup2.MacParamsDefaults.AdrAckDelay;\r\n\r\n    MacCtx.NodeAckRequested = false;\r\n    Nvm.MacGroup1.SrvAckRequested = false;\r\n    Nvm.MacGroup2.ChannelsDatarateChangedLinkAdrReq = false;\r\n    Nvm.MacGroup2.DownlinkReceived = false;\r\n\r\n    Nvm.MacGroup2.Rejoin0UplinksLimit = 0;\r\n    Nvm.MacGroup2.ForceRejoinMaxRetries = 0;\r\n    Nvm.MacGroup2.ForceRejoinType = 0;\r\n    Nvm.MacGroup2.Rejoin0CycleInSec = 0;\r\n    Nvm.MacGroup2.Rejoin1CycleInSec = 0;\r\n    Nvm.MacGroup2.IsRejoin0RequestQueued = 0;\r\n    Nvm.MacGroup2.IsRejoin1RequestQueued = 0;\r\n    Nvm.MacGroup2.IsRejoin2RequestQueued = 0;\r\n\r\n    // Reset to application defaults\r\n    InitDefaultsParams_t params;\r\n    params.Type = INIT_TYPE_RESET_TO_DEFAULT_CHANNELS;\r\n    params.NvmGroup1 = &Nvm.RegionGroup1;\r\n    params.NvmGroup2 = &Nvm.RegionGroup2;\r\n    params.Bands = &RegionBands;\r\n    RegionInitDefaults( Nvm.MacGroup2.Region, &params );\r\n\r\n    // Initialize channel index.\r\n    MacCtx.Channel = 0;\r\n\r\n    // Initialize Rx2 config parameters.\r\n    MacCtx.RxWindow2Config.Channel = MacCtx.Channel;\r\n    MacCtx.RxWindow2Config.Frequency = Nvm.MacGroup2.MacParams.Rx2Channel.Frequency;\r\n    MacCtx.RxWindow2Config.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;\r\n    MacCtx.RxWindow2Config.RxContinuous = false;\r\n    MacCtx.RxWindow2Config.RxSlot = RX_SLOT_WIN_2;\r\n    MacCtx.RxWindow2Config.NetworkActivation = Nvm.MacGroup2.NetworkActivation;\r\n\r\n    // Initialize RxC config parameters.\r\n    MacCtx.RxWindowCConfig = MacCtx.RxWindow2Config;\r\n    MacCtx.RxWindowCConfig.RxContinuous = true;\r\n    MacCtx.RxWindowCConfig.RxSlot = RX_SLOT_WIN_CLASS_C;\r\n\r\n    // Initialize class b\r\n    // Apply callback\r\n    classBCallbacks.GetTemperatureLevel = NULL;\r\n    classBCallbacks.MacProcessNotify = NULL;\r\n\r\n    if( MacCtx.MacCallbacks != NULL )\r\n    {\r\n        classBCallbacks.GetTemperatureLevel = MacCtx.MacCallbacks->GetTemperatureLevel;\r\n        classBCallbacks.MacProcessNotify = MacCtx.MacCallbacks->MacProcessNotify;\r\n    }\r\n\r\n    // Must all be static. Don't use local references.\r\n    classBParams.MlmeIndication = &MacCtx.MlmeIndication;\r\n    classBParams.McpsIndication = &MacCtx.McpsIndication;\r\n    classBParams.MlmeConfirm = &MacCtx.MlmeConfirm;\r\n    classBParams.LoRaMacFlags = &MacCtx.MacFlags;\r\n    classBParams.LoRaMacDevAddr = &Nvm.MacGroup2.DevAddr;\r\n    classBParams.LoRaMacRegion = &Nvm.MacGroup2.Region;\r\n    classBParams.LoRaMacParams = &Nvm.MacGroup2.MacParams;\r\n    classBParams.MulticastChannels = &Nvm.MacGroup2.MulticastChannelList[0];\r\n    classBParams.NetworkActivation = &Nvm.MacGroup2.NetworkActivation;\r\n\r\n    LoRaMacClassBInit( &classBParams, &classBCallbacks, &Nvm.ClassB );\r\n}\r\n\r\nstatic bool IsReJoin0Required( )\r\n{\r\n\r\n    if( ( Nvm.MacGroup2.Rejoin0UplinksLimit == Nvm.MacGroup1.Rejoin0UplinksCounter ) &&\r\n        ( Nvm.MacGroup2.Version.Fields.Minor >= 1 ) &&\r\n        ( Nvm.MacGroup2.Rejoin0UplinksLimit != 0 ) )\r\n    {\r\n        Nvm.MacGroup1.Rejoin0UplinksCounter = 0;\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\n/*!\r\n * \\brief Initializes and opens the reception window\r\n *\r\n * \\param [IN] rxTimer  Window timer to be topped.\r\n * \\param [IN] rxConfig Window parameters to be setup\r\n */\r\nstatic void RxWindowSetup( TimerEvent_t* rxTimer, RxConfigParams_t* rxConfig )\r\n{\r\n    TimerStop( rxTimer );\r\n\r\n    // Ensure the radio is Idle\r\n    Radio.Standby( );\r\n\r\n    if( RegionRxConfig( Nvm.MacGroup2.Region, rxConfig, ( int8_t* )&MacCtx.McpsIndication.RxDatarate ) == true )\r\n    {\r\n        Radio.Rx( Nvm.MacGroup2.MacParams.MaxRxWindow );\r\n        MacCtx.RxSlot = rxConfig->RxSlot;\r\n    }\r\n}\r\n\r\nstatic void OpenContinuousRxCWindow( void )\r\n{\r\n    // Compute RxC windows parameters\r\n    RegionComputeRxWindowParameters( Nvm.MacGroup2.Region,\r\n                                     Nvm.MacGroup2.MacParams.RxCChannel.Datarate,\r\n                                     Nvm.MacGroup2.MacParams.MinRxSymbols,\r\n                                     Nvm.MacGroup2.MacParams.SystemMaxRxError,\r\n                                     &MacCtx.RxWindowCConfig );\r\n\r\n    MacCtx.RxWindowCConfig.RxSlot = RX_SLOT_WIN_CLASS_C;\r\n    MacCtx.RxWindowCConfig.NetworkActivation = Nvm.MacGroup2.NetworkActivation;\r\n    // Setup continuous listening\r\n    MacCtx.RxWindowCConfig.RxContinuous = true;\r\n\r\n    // At this point the Radio should be idle.\r\n    // Thus, there is no need to set the radio in standby mode.\r\n    if( RegionRxConfig( Nvm.MacGroup2.Region, &MacCtx.RxWindowCConfig, ( int8_t* )&MacCtx.McpsIndication.RxDatarate ) == true )\r\n    {\r\n        Radio.Rx( 0 ); // Continuous mode\r\n        MacCtx.RxSlot = MacCtx.RxWindowCConfig.RxSlot;\r\n    }\r\n}\r\n\r\nLoRaMacStatus_t PrepareFrame( LoRaMacHeader_t* macHdr, LoRaMacFrameCtrl_t* fCtrl, uint8_t fPort, void* fBuffer, uint16_t fBufferSize )\r\n{\r\n    MacCtx.PktBufferLen = 0;\r\n    MacCtx.NodeAckRequested = false;\r\n    uint32_t fCntUp = 0;\r\n    size_t macCmdsSize = 0;\r\n    uint8_t availableSize = 0;\r\n\r\n    if( fBuffer == NULL )\r\n    {\r\n        fBufferSize = 0;\r\n    }\r\n\r\n    memcpy1( MacCtx.AppData, ( uint8_t* ) fBuffer, fBufferSize );\r\n    MacCtx.AppDataSize = fBufferSize;\r\n    MacCtx.PktBuffer[0] = macHdr->Value;\r\n\r\n    switch( macHdr->Bits.MType )\r\n    {\r\n        case FRAME_TYPE_DATA_CONFIRMED_UP:\r\n            MacCtx.NodeAckRequested = true;\r\n            // Intentional fall through\r\n        case FRAME_TYPE_DATA_UNCONFIRMED_UP:\r\n            MacCtx.TxMsg.Type = LORAMAC_MSG_TYPE_DATA;\r\n            MacCtx.TxMsg.Message.Data.Buffer = MacCtx.PktBuffer;\r\n            MacCtx.TxMsg.Message.Data.BufSize = LORAMAC_PHY_MAXPAYLOAD;\r\n            MacCtx.TxMsg.Message.Data.MHDR.Value = macHdr->Value;\r\n            MacCtx.TxMsg.Message.Data.FPort = fPort;\r\n            MacCtx.TxMsg.Message.Data.FHDR.DevAddr = Nvm.MacGroup2.DevAddr;\r\n            MacCtx.TxMsg.Message.Data.FHDR.FCtrl.Value = fCtrl->Value;\r\n            MacCtx.TxMsg.Message.Data.FRMPayloadSize = MacCtx.AppDataSize;\r\n            MacCtx.TxMsg.Message.Data.FRMPayload = MacCtx.AppData;\r\n\r\n            if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoGetFCntUp( &fCntUp ) )\r\n            {\r\n                return LORAMAC_STATUS_FCNT_HANDLER_ERROR;\r\n            }\r\n            MacCtx.TxMsg.Message.Data.FHDR.FCnt = ( uint16_t )fCntUp;\r\n\r\n            // Reset confirm parameters\r\n            MacCtx.McpsConfirm.NbTrans = 0;\r\n            MacCtx.McpsConfirm.AckReceived = false;\r\n            MacCtx.McpsConfirm.UpLinkCounter = fCntUp;\r\n\r\n            // Handle the MAC commands if there are any available\r\n            if( LoRaMacCommandsGetSizeSerializedCmds( &macCmdsSize ) != LORAMAC_COMMANDS_SUCCESS )\r\n            {\r\n                return LORAMAC_STATUS_MAC_COMMAD_ERROR;\r\n            }\r\n\r\n            if( macCmdsSize > 0 )\r\n            {\r\n                availableSize = GetMaxAppPayloadWithoutFOptsLength( Nvm.MacGroup1.ChannelsDatarate );\r\n\r\n                // There is application payload available and the MAC commands fit into FOpts field.\r\n                if( ( MacCtx.AppDataSize > 0 ) && ( macCmdsSize <= LORA_MAC_COMMAND_MAX_FOPTS_LENGTH ) )\r\n                {\r\n                    if( LoRaMacCommandsSerializeCmds( LORA_MAC_COMMAND_MAX_FOPTS_LENGTH, &macCmdsSize, MacCtx.TxMsg.Message.Data.FHDR.FOpts ) != LORAMAC_COMMANDS_SUCCESS )\r\n                    {\r\n                        return LORAMAC_STATUS_MAC_COMMAD_ERROR;\r\n                    }\r\n                    fCtrl->Bits.FOptsLen = macCmdsSize;\r\n                    // Update FCtrl field with new value of FOptionsLength\r\n                    MacCtx.TxMsg.Message.Data.FHDR.FCtrl.Value = fCtrl->Value;\r\n                }\r\n                // There is application payload available but the MAC commands does NOT fit into FOpts field.\r\n                else if( ( MacCtx.AppDataSize > 0 ) && ( macCmdsSize > LORA_MAC_COMMAND_MAX_FOPTS_LENGTH ) )\r\n                {\r\n\r\n                    if( LoRaMacCommandsSerializeCmds( availableSize, &macCmdsSize, MacCtx.MacCommandsBuffer ) != LORAMAC_COMMANDS_SUCCESS )\r\n                    {\r\n                        return LORAMAC_STATUS_MAC_COMMAD_ERROR;\r\n                    }\r\n                    return LORAMAC_STATUS_SKIPPED_APP_DATA;\r\n                }\r\n                // No application payload available therefore add all mac commands to the FRMPayload.\r\n                else\r\n                {\r\n                    if( LoRaMacCommandsSerializeCmds( availableSize, &macCmdsSize, MacCtx.MacCommandsBuffer ) != LORAMAC_COMMANDS_SUCCESS )\r\n                    {\r\n                        return LORAMAC_STATUS_MAC_COMMAD_ERROR;\r\n                    }\r\n                    // Force FPort to be zero\r\n                    MacCtx.TxMsg.Message.Data.FPort = 0;\r\n\r\n                    MacCtx.TxMsg.Message.Data.FRMPayload = MacCtx.MacCommandsBuffer;\r\n                    MacCtx.TxMsg.Message.Data.FRMPayloadSize = macCmdsSize;\r\n                }\r\n            }\r\n\r\n            break;\r\n        case FRAME_TYPE_PROPRIETARY:\r\n            if( ( fBuffer != NULL ) && ( MacCtx.AppDataSize > 0 ) )\r\n            {\r\n                memcpy1( MacCtx.PktBuffer + LORAMAC_MHDR_FIELD_SIZE, ( uint8_t* ) fBuffer, MacCtx.AppDataSize );\r\n                MacCtx.PktBufferLen = LORAMAC_MHDR_FIELD_SIZE + MacCtx.AppDataSize;\r\n            }\r\n            break;\r\n        default:\r\n            return LORAMAC_STATUS_SERVICE_UNKNOWN;\r\n    }\r\n\r\n    return LORAMAC_STATUS_OK;\r\n}\r\n\r\nLoRaMacStatus_t SendFrameOnChannel( uint8_t channel )\r\n{\r\n    LoRaMacStatus_t status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n    TxConfigParams_t txConfig;\r\n    int8_t txPower = 0;\r\n\r\n    txConfig.Channel = channel;\r\n    txConfig.Datarate = Nvm.MacGroup1.ChannelsDatarate;\r\n    txConfig.TxPower = Nvm.MacGroup1.ChannelsTxPower;\r\n    txConfig.MaxEirp = Nvm.MacGroup2.MacParams.MaxEirp;\r\n    txConfig.AntennaGain = Nvm.MacGroup2.MacParams.AntennaGain;\r\n    txConfig.PktLen = MacCtx.PktBufferLen;\r\n\r\n    RegionTxConfig( Nvm.MacGroup2.Region, &txConfig, &txPower, &MacCtx.TxTimeOnAir );\r\n\r\n    MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\r\n    MacCtx.McpsConfirm.Datarate = Nvm.MacGroup1.ChannelsDatarate;\r\n    MacCtx.McpsConfirm.TxPower = txPower;\r\n    MacCtx.McpsConfirm.Channel = channel;\r\n\r\n    // Store the time on air\r\n    MacCtx.McpsConfirm.TxTimeOnAir = MacCtx.TxTimeOnAir;\r\n    MacCtx.MlmeConfirm.TxTimeOnAir = MacCtx.TxTimeOnAir;\r\n\r\n    if( LoRaMacClassBIsBeaconModeActive( ) == true )\r\n    {\r\n        // Currently, the Time-On-Air can only be computed when the radio is configured with\r\n        // the TX configuration\r\n        TimerTime_t collisionTime = LoRaMacClassBIsUplinkCollision( MacCtx.TxTimeOnAir );\r\n\r\n        if( collisionTime > 0 )\r\n        {\r\n            return LORAMAC_STATUS_BUSY_UPLINK_COLLISION;\r\n        }\r\n    }\r\n\r\n    if( Nvm.MacGroup2.DeviceClass == CLASS_B )\r\n    {\r\n        // Stop slots for class b\r\n        LoRaMacClassBStopRxSlots( );\r\n    }\r\n\r\n    LoRaMacClassBHaltBeaconing( );\r\n\r\n    // Secure frame\r\n    status = SecureFrame( Nvm.MacGroup1.ChannelsDatarate, MacCtx.Channel );\r\n    if( status != LORAMAC_STATUS_OK )\r\n    {\r\n        return status;\r\n    }\r\n\r\n    MacCtx.MacState |= LORAMAC_TX_RUNNING;\r\n\r\n    MacCtx.ChannelsNbTransCounter++;\r\n    MacCtx.McpsConfirm.NbTrans = MacCtx.ChannelsNbTransCounter;\r\n    MacCtx.ResponseTimeoutStartTime = 0;\r\n\r\n    // Send now\r\n    Radio.Send( MacCtx.PktBuffer, MacCtx.PktBufferLen );\r\n\r\n    return LORAMAC_STATUS_OK;\r\n}\r\n\r\nLoRaMacStatus_t SetTxContinuousWave( uint16_t timeout, uint32_t frequency, uint8_t power )\r\n{\r\n    Radio.SetTxContinuousWave( frequency, power, timeout );\r\n\r\n    MacCtx.MacState |= LORAMAC_TX_RUNNING;\r\n\r\n    return LORAMAC_STATUS_OK;\r\n}\r\n\r\nLoRaMacNvmData_t* GetNvmData( void )\r\n{\r\n    return &Nvm;\r\n}\r\n\r\nLoRaMacStatus_t RestoreNvmData( LoRaMacNvmData_t* nvm )\r\n{\r\n    uint32_t crc = 0;\r\n\r\n    // Status and parameter validation\r\n    if( nvm == NULL )\r\n    {\r\n        return LORAMAC_STATUS_PARAMETER_INVALID;\r\n    }\r\n    if( MacCtx.MacState != LORAMAC_STOPPED )\r\n    {\r\n        return LORAMAC_STATUS_BUSY;\r\n    }\r\n\r\n    // Crypto\r\n    crc = Crc32( ( uint8_t* ) &nvm->Crypto, sizeof( nvm->Crypto ) -\r\n                                            sizeof( nvm->Crypto.Crc32 ) );\r\n    if( crc == nvm->Crypto.Crc32 )\r\n    {\r\n        memcpy1( ( uint8_t* ) &Nvm.Crypto, ( uint8_t* ) &nvm->Crypto,\r\n                 sizeof( Nvm.Crypto ) );\r\n    }\r\n\r\n    // MacGroup1\r\n    crc = Crc32( ( uint8_t* ) &nvm->MacGroup1, sizeof( nvm->MacGroup1 ) -\r\n                                               sizeof( nvm->MacGroup1.Crc32 ) );\r\n    if( crc == nvm->MacGroup1.Crc32 )\r\n    {\r\n        memcpy1( ( uint8_t* ) &Nvm.MacGroup1, ( uint8_t* ) &nvm->MacGroup1,\r\n                 sizeof( Nvm.MacGroup1 ) );\r\n    }\r\n\r\n    // MacGroup2\r\n    crc = Crc32( ( uint8_t* ) &nvm->MacGroup2, sizeof( nvm->MacGroup2 ) -\r\n                                               sizeof( nvm->MacGroup2.Crc32 ) );\r\n    if( crc == nvm->MacGroup2.Crc32 )\r\n    {\r\n        memcpy1( ( uint8_t* ) &Nvm.MacGroup2, ( uint8_t* ) &nvm->MacGroup2,\r\n                 sizeof( Nvm.MacGroup2 ) );\r\n\r\n        // Initialize RxC config parameters.\r\n        MacCtx.RxWindowCConfig.Channel = MacCtx.Channel;\r\n        MacCtx.RxWindowCConfig.Frequency = Nvm.MacGroup2.MacParams.RxCChannel.Frequency;\r\n        MacCtx.RxWindowCConfig.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;\r\n        MacCtx.RxWindowCConfig.RxContinuous = true;\r\n        MacCtx.RxWindowCConfig.RxSlot = RX_SLOT_WIN_CLASS_C;\r\n\r\n        // The public/private network flag may change upon reloading MacGroup2\r\n        // from NVM and we thus need to synchronize the radio. The same function\r\n        // is invoked in LoRaMacInitialization.\r\n        Radio.SetPublicNetwork( Nvm.MacGroup2.PublicNetwork );\r\n    }\r\n\r\n    // Secure Element\r\n    crc = Crc32( ( uint8_t* ) &nvm->SecureElement, sizeof( nvm->SecureElement ) -\r\n                                                   sizeof( nvm->SecureElement.Crc32 ) );\r\n    if( crc == nvm->SecureElement.Crc32 )\r\n    {\r\n        memcpy1( ( uint8_t* ) &Nvm.SecureElement,( uint8_t* ) &nvm->SecureElement,\r\n                 sizeof( Nvm.SecureElement ) );\r\n    }\r\n\r\n    // RegionGroup1\r\n    crc = Crc32( ( uint8_t* ) &nvm->RegionGroup1, sizeof( nvm->RegionGroup1 ) -\r\n                                            sizeof( nvm->RegionGroup1.Crc32 ) );\r\n    if( crc == nvm->RegionGroup1.Crc32 )\r\n    {\r\n        memcpy1( ( uint8_t* ) &Nvm.RegionGroup1,( uint8_t* ) &nvm->RegionGroup1,\r\n                 sizeof( Nvm.RegionGroup1 ) );\r\n    }\r\n\r\n    // RegionGroup2\r\n    crc = Crc32( ( uint8_t* ) &nvm->RegionGroup2, sizeof( nvm->RegionGroup2 ) -\r\n                                            sizeof( nvm->RegionGroup2.Crc32 ) );\r\n    if( crc == nvm->RegionGroup2.Crc32 )\r\n    {\r\n        memcpy1( ( uint8_t* ) &Nvm.RegionGroup2,( uint8_t* ) &nvm->RegionGroup2,\r\n                 sizeof( Nvm.RegionGroup2 ) );\r\n    }\r\n\r\n    crc = Crc32( ( uint8_t* ) &nvm->ClassB, sizeof( nvm->ClassB ) -\r\n                                            sizeof( nvm->ClassB.Crc32 ) );\r\n    if( crc == nvm->ClassB.Crc32 )\r\n    {\r\n        memcpy1( ( uint8_t* ) &Nvm.ClassB,( uint8_t* ) &nvm->ClassB,\r\n                 sizeof( Nvm.ClassB ) );\r\n    }\r\n\r\n    return LORAMAC_STATUS_OK;\r\n}\r\n\r\nLoRaMacStatus_t DetermineFrameType( LoRaMacMessageData_t* macMsg, FType_t* fType )\r\n{\r\n    if( ( macMsg == NULL ) || ( fType == NULL ) )\r\n    {\r\n        return LORAMAC_STATUS_PARAMETER_INVALID;\r\n    }\r\n\r\n    /* The LoRaWAN specification allows several possible configurations how data up/down frames are built up.\r\n     * In sake of clearness the following naming is applied. Please keep in mind that this is\r\n     * implementation specific since there is no definition in the LoRaWAN specification included.\r\n     *\r\n     * X -> Field is available\r\n     * - -> Field is not available\r\n     *\r\n     * +-------+  +----------+------+-------+--------------+\r\n     * | FType |  | FOptsLen | Fopt | FPort |  FRMPayload  |\r\n     * +-------+  +----------+------+-------+--------------+\r\n     * |   A   |  |    > 0   |   X  |  > 0  |       X      |\r\n     * +-------+  +----------+------+-------+--------------+\r\n     * |   B   |  |   >= 0   |  X/- |   -   |       -      |\r\n     * +-------+  +----------+------+-------+--------------+\r\n     * |   C   |  |    = 0   |   -  |  = 0  | MAC commands |\r\n     * +-------+  +----------+------+-------+--------------+\r\n     * |   D   |  |    = 0   |   -  |  > 0  |       X      |\r\n     * +-------+  +----------+------+-------+--------------+\r\n     */\r\n\r\n    if( ( macMsg->FHDR.FCtrl.Bits.FOptsLen > 0 ) && ( macMsg->FPort > 0 ) )\r\n    {\r\n        *fType = FRAME_TYPE_A;\r\n    }\r\n    else if( macMsg->FRMPayloadSize == 0 )\r\n    {\r\n        *fType = FRAME_TYPE_B;\r\n    }\r\n    else if( ( macMsg->FHDR.FCtrl.Bits.FOptsLen == 0 ) && ( macMsg->FPort == 0 ) )\r\n    {\r\n        *fType = FRAME_TYPE_C;\r\n    }\r\n    else if( ( macMsg->FHDR.FCtrl.Bits.FOptsLen == 0 ) && ( macMsg->FPort > 0 ) )\r\n    {\r\n        *fType = FRAME_TYPE_D;\r\n    }\r\n    else\r\n    {\r\n        // Should never happen.\r\n        return LORAMAC_STATUS_ERROR;\r\n    }\r\n\r\n    return LORAMAC_STATUS_OK;\r\n}\r\n\r\nstatic bool CheckRetrans( uint8_t counter, uint8_t limit )\r\n{\r\n    if( counter >= limit )\r\n    {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\nstatic bool CheckRetransUnconfirmedUplink( void )\r\n{\r\n    // Verify, if the max number of retransmissions have been reached\r\n    if( CheckRetrans( MacCtx.ChannelsNbTransCounter,\r\n                      Nvm.MacGroup2.MacParams.ChannelsNbTrans ) == true )\r\n    {\r\n        return true;\r\n    }\r\n\r\n    if( MacCtx.MacFlags.Bits.McpsInd == 1 )\r\n    {\r\n        // Stop the retransmissions, if a valid downlink is received\r\n        // a class A RX window. This holds also for class B and C.\r\n        if( ( MacCtx.McpsIndication.RxSlot == RX_SLOT_WIN_1 ) ||\r\n            ( MacCtx.McpsIndication.RxSlot == RX_SLOT_WIN_2 ) )\r\n        {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nstatic bool CheckRetransConfirmedUplink( void )\r\n{\r\n    // Verify, if the max number of retransmissions have been reached\r\n    if( CheckRetrans( MacCtx.ChannelsNbTransCounter,\r\n                      Nvm.MacGroup2.MacParams.ChannelsNbTrans ) == true )\r\n    {\r\n        return true;\r\n    }\r\n\r\n    if( MacCtx.MacFlags.Bits.McpsInd == 1 )\r\n    {\r\n        if( MacCtx.McpsConfirm.AckReceived == true )\r\n        {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nstatic uint32_t IncreaseAdrAckCounter( uint32_t counter )\r\n{\r\n    if( counter < ADR_ACK_COUNTER_MAX )\r\n    {\r\n        counter++;\r\n    }\r\n    return counter;\r\n}\r\n\r\nstatic bool StopRetransmission( void )\r\n{\r\n    // Increase Rejoin Uplinks counter\r\n    if( Nvm.MacGroup2.Rejoin0UplinksLimit != 0 )\r\n    {\r\n        Nvm.MacGroup1.Rejoin0UplinksCounter++;\r\n    }\r\n\r\n    if( Nvm.MacGroup2.Version.Fields.Minor >= 1 )\r\n    {\r\n        MacCommand_t* macCmd;\r\n        if( LoRaMacCommandsGetCmd( MOTE_MAC_REKEY_IND, &macCmd ) == LORAMAC_COMMANDS_SUCCESS )\r\n        {\r\n            // Increase the Rekey Uplinks counter\r\n            Nvm.MacGroup1.RekeyIndUplinksCounter++;\r\n\r\n            /*\r\n             * If the device has not received a RekeyConf within\r\n             * the first ADR_ACK_LIMIT uplinks it SHALL revert to the Join state.\r\n             */\r\n            if( Nvm.MacGroup1.RekeyIndUplinksCounter == Nvm.MacGroup2.MacParams.AdrAckLimit )\r\n            {\r\n                Nvm.MacGroup2.NetworkActivation = ACTIVATION_TYPE_NONE;\r\n                MacCtx.MacFlags.Bits.MlmeInd = 1;\r\n                MacCtx.MlmeIndication.MlmeIndication = MLME_REVERT_JOIN;\r\n            }\r\n        }\r\n    }\r\n\r\n    if( ( MacCtx.MacFlags.Bits.McpsInd == 0 ) ||\r\n        ( ( MacCtx.McpsIndication.RxSlot != RX_SLOT_WIN_1 ) &&\r\n          ( MacCtx.McpsIndication.RxSlot != RX_SLOT_WIN_2 ) ) )\r\n    {   // Maximum repetitions without downlink. Increase ADR Ack counter.\r\n        // Only process the case when the MAC did not receive a downlink.\r\n        if( Nvm.MacGroup2.AdrCtrlOn == true )\r\n        {\r\n            Nvm.MacGroup1.AdrAckCounter = IncreaseAdrAckCounter( Nvm.MacGroup1.AdrAckCounter );\r\n        }\r\n    }\r\n\r\n    MacCtx.ChannelsNbTransCounter = 0;\r\n    MacCtx.NodeAckRequested = false;\r\n    MacCtx.RetransmitTimeoutRetry = false;\r\n    MacCtx.MacState &= ~LORAMAC_TX_RUNNING;\r\n\r\n    return true;\r\n}\r\n\r\nstatic void CallNvmDataChangeCallback( uint16_t notifyFlags )\r\n{\r\n    if( ( MacCtx.MacCallbacks != NULL ) &&\r\n        ( MacCtx.MacCallbacks->NvmDataChange  != NULL ) )\r\n    {\r\n        MacCtx.MacCallbacks->NvmDataChange ( notifyFlags );\r\n    }\r\n}\r\nstatic uint8_t IsRequestPending( void )\r\n{\r\n    if( ( MacCtx.MacFlags.Bits.MlmeReq == 1 ) ||\r\n        ( MacCtx.MacFlags.Bits.McpsReq == 1 ) )\r\n    {\r\n        return 1;\r\n    }\r\n    return 0;\r\n}\r\n\r\n\r\nLoRaMacStatus_t LoRaMacInitialization( LoRaMacPrimitives_t* primitives, LoRaMacCallback_t* callbacks, LoRaMacRegion_t region )\r\n{\r\n    GetPhyParams_t getPhy;\r\n    PhyParam_t phyParam;\r\n\r\n    if( ( primitives == NULL ) ||\r\n        ( callbacks == NULL ) )\r\n    {\r\n        return LORAMAC_STATUS_PARAMETER_INVALID;\r\n    }\r\n\r\n    if( ( primitives->MacMcpsConfirm == NULL ) ||\r\n        ( primitives->MacMcpsIndication == NULL ) ||\r\n        ( primitives->MacMlmeConfirm == NULL ) ||\r\n        ( primitives->MacMlmeIndication == NULL ) )\r\n    {\r\n        return LORAMAC_STATUS_PARAMETER_INVALID;\r\n    }\r\n    // Verify if the region is supported\r\n    if( RegionIsActive( region ) == false )\r\n    {\r\n        return LORAMAC_STATUS_REGION_NOT_SUPPORTED;\r\n    }\r\n\r\n    // Confirm queue reset\r\n    LoRaMacConfirmQueueInit( primitives );\r\n\r\n    // Initialize the module context with zeros\r\n    memset1( ( uint8_t* ) &Nvm, 0x00, sizeof( LoRaMacNvmData_t ) );\r\n    memset1( ( uint8_t* ) &MacCtx, 0x00, sizeof( LoRaMacCtx_t ) );\r\n\r\n    // Set non zero variables to its default value\r\n    Nvm.MacGroup2.Region = region;\r\n    Nvm.MacGroup2.DeviceClass = CLASS_A;\r\n\r\n    // Setup version\r\n    Nvm.MacGroup2.Version.Value = LORAMAC_VERSION;\r\n\r\n    InitDefaultsParams_t params;\r\n    params.Type = INIT_TYPE_DEFAULTS;\r\n    params.NvmGroup1 = &Nvm.RegionGroup1;\r\n    params.NvmGroup2 = &Nvm.RegionGroup2;\r\n    params.Bands = &RegionBands;\r\n    RegionInitDefaults( Nvm.MacGroup2.Region, &params );\r\n\r\n    // Reset to defaults\r\n    getPhy.Attribute = PHY_DUTY_CYCLE;\r\n    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );\r\n    Nvm.MacGroup2.DutyCycleOn = ( bool ) phyParam.Value;\r\n\r\n    getPhy.Attribute = PHY_DEF_TX_POWER;\r\n    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );\r\n    Nvm.MacGroup2.ChannelsTxPowerDefault = phyParam.Value;\r\n\r\n    getPhy.Attribute = PHY_DEF_TX_DR;\r\n    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );\r\n    Nvm.MacGroup2.ChannelsDatarateDefault = phyParam.Value;\r\n\r\n    getPhy.Attribute = PHY_MAX_RX_WINDOW;\r\n    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );\r\n    Nvm.MacGroup2.MacParamsDefaults.MaxRxWindow = phyParam.Value;\r\n\r\n    getPhy.Attribute = PHY_RECEIVE_DELAY1;\r\n    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );\r\n    Nvm.MacGroup2.MacParamsDefaults.ReceiveDelay1 = phyParam.Value;\r\n\r\n    getPhy.Attribute = PHY_RECEIVE_DELAY2;\r\n    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );\r\n    Nvm.MacGroup2.MacParamsDefaults.ReceiveDelay2 = phyParam.Value;\r\n\r\n    getPhy.Attribute = PHY_JOIN_ACCEPT_DELAY1;\r\n    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );\r\n    Nvm.MacGroup2.MacParamsDefaults.JoinAcceptDelay1 = phyParam.Value;\r\n\r\n    getPhy.Attribute = PHY_JOIN_ACCEPT_DELAY2;\r\n    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );\r\n    Nvm.MacGroup2.MacParamsDefaults.JoinAcceptDelay2 = phyParam.Value;\r\n\r\n    getPhy.Attribute = PHY_DEF_DR1_OFFSET;\r\n    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );\r\n    Nvm.MacGroup2.MacParamsDefaults.Rx1DrOffset = phyParam.Value;\r\n\r\n    getPhy.Attribute = PHY_DEF_RX2_FREQUENCY;\r\n    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );\r\n    Nvm.MacGroup2.MacParamsDefaults.Rx2Channel.Frequency = phyParam.Value;\r\n    Nvm.MacGroup2.MacParamsDefaults.RxCChannel.Frequency = phyParam.Value;\r\n\r\n    getPhy.Attribute = PHY_DEF_RX2_DR;\r\n    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );\r\n    Nvm.MacGroup2.MacParamsDefaults.Rx2Channel.Datarate = phyParam.Value;\r\n    Nvm.MacGroup2.MacParamsDefaults.RxCChannel.Datarate = phyParam.Value;\r\n\r\n    getPhy.Attribute = PHY_DEF_UPLINK_DWELL_TIME;\r\n    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );\r\n    Nvm.MacGroup2.MacParamsDefaults.UplinkDwellTime = phyParam.Value;\r\n\r\n    getPhy.Attribute = PHY_DEF_DOWNLINK_DWELL_TIME;\r\n    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );\r\n    Nvm.MacGroup2.MacParamsDefaults.DownlinkDwellTime = phyParam.Value;\r\n\r\n    getPhy.Attribute = PHY_DEF_MAX_EIRP;\r\n    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );\r\n    Nvm.MacGroup2.MacParamsDefaults.MaxEirp = phyParam.fValue;\r\n\r\n    getPhy.Attribute = PHY_DEF_ANTENNA_GAIN;\r\n    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );\r\n    Nvm.MacGroup2.MacParamsDefaults.AntennaGain = phyParam.fValue;\r\n\r\n    getPhy.Attribute = PHY_DEF_ADR_ACK_LIMIT;\r\n    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );\r\n    Nvm.MacGroup2.MacParamsDefaults.AdrAckLimit = phyParam.Value;\r\n\r\n    getPhy.Attribute = PHY_DEF_ADR_ACK_DELAY;\r\n    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );\r\n    Nvm.MacGroup2.MacParamsDefaults.AdrAckDelay = phyParam.Value;\r\n\r\n    // Init parameters which are not set in function ResetMacParameters\r\n    Nvm.MacGroup2.MacParamsDefaults.ChannelsNbTrans = 1;\r\n    Nvm.MacGroup2.MacParamsDefaults.SystemMaxRxError = 10;\r\n    Nvm.MacGroup2.MacParamsDefaults.MinRxSymbols = 6;\r\n\r\n    Nvm.MacGroup2.MacParams.SystemMaxRxError = Nvm.MacGroup2.MacParamsDefaults.SystemMaxRxError;\r\n    Nvm.MacGroup2.MacParams.MinRxSymbols = Nvm.MacGroup2.MacParamsDefaults.MinRxSymbols;\r\n    Nvm.MacGroup2.MacParams.MaxRxWindow = Nvm.MacGroup2.MacParamsDefaults.MaxRxWindow;\r\n    Nvm.MacGroup2.MacParams.ReceiveDelay1 = Nvm.MacGroup2.MacParamsDefaults.ReceiveDelay1;\r\n    Nvm.MacGroup2.MacParams.ReceiveDelay2 = Nvm.MacGroup2.MacParamsDefaults.ReceiveDelay2;\r\n    Nvm.MacGroup2.MacParams.JoinAcceptDelay1 = Nvm.MacGroup2.MacParamsDefaults.JoinAcceptDelay1;\r\n    Nvm.MacGroup2.MacParams.JoinAcceptDelay2 = Nvm.MacGroup2.MacParamsDefaults.JoinAcceptDelay2;\r\n    Nvm.MacGroup2.MacParams.ChannelsNbTrans = Nvm.MacGroup2.MacParamsDefaults.ChannelsNbTrans;\r\n\r\n    // FPort 224 is enabled by default.\r\n    Nvm.MacGroup2.IsCertPortOn = true;\r\n\r\n    ResetMacParameters( false );\r\n\r\n    Nvm.MacGroup2.PublicNetwork = true;\r\n\r\n    MacCtx.MacPrimitives = primitives;\r\n    MacCtx.MacCallbacks = callbacks;\r\n    MacCtx.MacFlags.Value = 0;\r\n    MacCtx.MacState = LORAMAC_STOPPED;\r\n\r\n    // Reset duty cycle times\r\n    Nvm.MacGroup1.LastTxDoneTime = 0;\r\n    Nvm.MacGroup1.AggregatedTimeOff = 0;\r\n\r\n    // Initialize timers\r\n    TimerInit( &MacCtx.TxDelayedTimer, OnTxDelayedTimerEvent );\r\n    TimerInit( &MacCtx.RxWindowTimer1, OnRxWindow1TimerEvent );\r\n    TimerInit( &MacCtx.RxWindowTimer2, OnRxWindow2TimerEvent );\r\n    TimerInit( &MacCtx.RetransmitTimeoutTimer, OnRetransmitTimeoutTimerEvent );\r\n    TimerInit( &MacCtx.Rejoin0CycleTimer, OnRejoin0CycleTimerEvent );\r\n    TimerInit( &MacCtx.Rejoin1CycleTimer, OnRejoin1CycleTimerEvent );\r\n    TimerInit( &MacCtx.ForceRejoinReqCycleTimer, OnForceRejoinReqCycleTimerEvent );\r\n\r\n    // Store the current initialization time\r\n    Nvm.MacGroup2.InitializationTime = SysTimeGetMcuTime( );\r\n\r\n    // Initialize MAC radio events\r\n    LoRaMacRadioEvents.Value = 0;\r\n\r\n    // Initialize Radio driver\r\n    MacCtx.RadioEvents.TxDone = OnRadioTxDone;\r\n    MacCtx.RadioEvents.RxDone = OnRadioRxDone;\r\n    MacCtx.RadioEvents.RxError = OnRadioRxError;\r\n    MacCtx.RadioEvents.TxTimeout = OnRadioTxTimeout;\r\n    MacCtx.RadioEvents.RxTimeout = OnRadioRxTimeout;\r\n    Radio.Init( &MacCtx.RadioEvents );\r\n\r\n    // Initialize the Secure Element driver\r\n    if( SecureElementInit( &Nvm.SecureElement ) != SECURE_ELEMENT_SUCCESS )\r\n    {\r\n        return LORAMAC_STATUS_CRYPTO_ERROR;\r\n    }\r\n\r\n    // Initialize Crypto module\r\n    if( LoRaMacCryptoInit( &Nvm.Crypto ) != LORAMAC_CRYPTO_SUCCESS )\r\n    {\r\n        return LORAMAC_STATUS_CRYPTO_ERROR;\r\n    }\r\n\r\n    // Initialize MAC commands module\r\n    if( LoRaMacCommandsInit( ) != LORAMAC_COMMANDS_SUCCESS )\r\n    {\r\n        return LORAMAC_STATUS_MAC_COMMAD_ERROR;\r\n    }\r\n\r\n    // Set multicast downlink counter reference\r\n    if( LoRaMacCryptoSetMulticastReference( Nvm.MacGroup2.MulticastChannelList ) != LORAMAC_CRYPTO_SUCCESS )\r\n    {\r\n        return LORAMAC_STATUS_CRYPTO_ERROR;\r\n    }\r\n\r\n    // Random seed initialization\r\n    srand1( Radio.Random( ) );\r\n\r\n    Radio.SetPublicNetwork( Nvm.MacGroup2.PublicNetwork );\r\n    Radio.Sleep( );\r\n\r\n    LoRaMacEnableRequests( LORAMAC_REQUEST_HANDLING_ON );\r\n\r\n    return LORAMAC_STATUS_OK;\r\n}\r\n\r\nLoRaMacStatus_t LoRaMacStart( void )\r\n{\r\n    MacCtx.MacState = LORAMAC_IDLE;\r\n    UpdateRxSlotIdleState();\r\n    return LORAMAC_STATUS_OK;\r\n}\r\n\r\nLoRaMacStatus_t LoRaMacStop( void )\r\n{\r\n    if( LoRaMacIsBusy( ) == false )\r\n    {\r\n        if( Nvm.MacGroup2.DeviceClass == CLASS_C )\r\n        {\r\n            Radio.Sleep( );\r\n        }\r\n        MacCtx.MacState = LORAMAC_STOPPED;\r\n        return LORAMAC_STATUS_OK;\r\n    }\r\n    else if(  MacCtx.MacState == LORAMAC_STOPPED )\r\n    {\r\n        return LORAMAC_STATUS_OK;\r\n    }\r\n    return LORAMAC_STATUS_BUSY;\r\n}\r\n\r\nLoRaMacStatus_t LoRaMacQueryTxPossible( uint8_t size, LoRaMacTxInfo_t* txInfo )\r\n{\r\n    CalcNextAdrParams_t adrNext;\r\n    uint32_t adrAckCounter = Nvm.MacGroup1.AdrAckCounter;\r\n    int8_t datarate = Nvm.MacGroup2.ChannelsDatarateDefault;\r\n    int8_t txPower = Nvm.MacGroup2.ChannelsTxPowerDefault;\r\n    uint8_t nbTrans = MacCtx.ChannelsNbTransCounter;\r\n    size_t macCmdsSize = 0;\r\n\r\n    if( txInfo == NULL )\r\n    {\r\n        return LORAMAC_STATUS_PARAMETER_INVALID;\r\n    }\r\n\r\n    // Setup ADR request\r\n    adrNext.UpdateChanMask = false;\r\n    adrNext.AdrEnabled = Nvm.MacGroup2.AdrCtrlOn;\r\n    adrNext.AdrAckCounter = Nvm.MacGroup1.AdrAckCounter;\r\n    adrNext.AdrAckLimit = Nvm.MacGroup2.MacParams.AdrAckLimit;\r\n    adrNext.AdrAckDelay = Nvm.MacGroup2.MacParams.AdrAckDelay;\r\n    adrNext.Datarate = Nvm.MacGroup1.ChannelsDatarate;\r\n    adrNext.TxPower = Nvm.MacGroup1.ChannelsTxPower;\r\n    adrNext.NbTrans = MacCtx.ChannelsNbTransCounter;\r\n    adrNext.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;\r\n    adrNext.Region = Nvm.MacGroup2.Region;\r\n\r\n    // We call the function for information purposes only. We don't want to\r\n    // apply the datarate, the tx power and the ADR ack counter.\r\n    LoRaMacAdrCalcNext( &adrNext, &datarate, &txPower, &nbTrans, &adrAckCounter );\r\n\r\n    txInfo->CurrentPossiblePayloadSize = GetMaxAppPayloadWithoutFOptsLength( datarate );\r\n\r\n    if( LoRaMacCommandsGetSizeSerializedCmds( &macCmdsSize ) != LORAMAC_COMMANDS_SUCCESS )\r\n    {\r\n        return LORAMAC_STATUS_MAC_COMMAD_ERROR;\r\n    }\r\n\r\n    // Verify if the MAC commands fit into the FOpts and into the maximum payload.\r\n    if( ( LORA_MAC_COMMAND_MAX_FOPTS_LENGTH >= macCmdsSize ) && ( txInfo->CurrentPossiblePayloadSize >= macCmdsSize ) )\r\n    {\r\n        txInfo->MaxPossibleApplicationDataSize = txInfo->CurrentPossiblePayloadSize - macCmdsSize;\r\n\r\n        // Verify if the application data together with MAC command fit into the maximum payload.\r\n        if( txInfo->CurrentPossiblePayloadSize >= ( macCmdsSize + size ) )\r\n        {\r\n            return LORAMAC_STATUS_OK;\r\n        }\r\n        else\r\n        {\r\n           return LORAMAC_STATUS_LENGTH_ERROR;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        txInfo->MaxPossibleApplicationDataSize = 0;\r\n        return LORAMAC_STATUS_LENGTH_ERROR;\r\n    }\r\n}\r\n\r\nLoRaMacStatus_t LoRaMacMibGetRequestConfirm( MibRequestConfirm_t* mibGet )\r\n{\r\n    LoRaMacStatus_t status = LORAMAC_STATUS_OK;\r\n    GetPhyParams_t getPhy;\r\n    PhyParam_t phyParam;\r\n\r\n    if( mibGet == NULL )\r\n    {\r\n        return LORAMAC_STATUS_PARAMETER_INVALID;\r\n    }\r\n\r\n    switch( mibGet->Type )\r\n    {\r\n        case MIB_DEVICE_CLASS:\r\n        {\r\n            mibGet->Param.Class = Nvm.MacGroup2.DeviceClass;\r\n            break;\r\n        }\r\n        case MIB_NETWORK_ACTIVATION:\r\n        {\r\n            mibGet->Param.NetworkActivation = Nvm.MacGroup2.NetworkActivation;\r\n            break;\r\n        }\r\n        case MIB_DEV_EUI:\r\n        {\r\n            mibGet->Param.DevEui = SecureElementGetDevEui( );\r\n            break;\r\n        }\r\n        case MIB_JOIN_EUI:\r\n        {\r\n            mibGet->Param.JoinEui = SecureElementGetJoinEui( );\r\n            break;\r\n        }\r\n        case MIB_SE_PIN:\r\n        {\r\n            mibGet->Param.SePin = SecureElementGetPin( );\r\n            break;\r\n        }\r\n        case MIB_ADR:\r\n        {\r\n            mibGet->Param.AdrEnable = Nvm.MacGroup2.AdrCtrlOn;\r\n            break;\r\n        }\r\n        case MIB_NET_ID:\r\n        {\r\n            mibGet->Param.NetID = Nvm.MacGroup2.NetID;\r\n            break;\r\n        }\r\n        case MIB_DEV_ADDR:\r\n        {\r\n            mibGet->Param.DevAddr = Nvm.MacGroup2.DevAddr;\r\n            break;\r\n        }\r\n        case MIB_PUBLIC_NETWORK:\r\n        {\r\n            mibGet->Param.EnablePublicNetwork = Nvm.MacGroup2.PublicNetwork;\r\n            break;\r\n        }\r\n        case MIB_CHANNELS:\r\n        {\r\n            getPhy.Attribute = PHY_CHANNELS;\r\n            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );\r\n\r\n            mibGet->Param.ChannelList = phyParam.Channels;\r\n            break;\r\n        }\r\n        case MIB_RX2_CHANNEL:\r\n        {\r\n            mibGet->Param.Rx2Channel = Nvm.MacGroup2.MacParams.Rx2Channel;\r\n            break;\r\n        }\r\n        case MIB_RX2_DEFAULT_CHANNEL:\r\n        {\r\n            mibGet->Param.Rx2Channel = Nvm.MacGroup2.MacParamsDefaults.Rx2Channel;\r\n            break;\r\n        }\r\n        case MIB_RXC_CHANNEL:\r\n        {\r\n            mibGet->Param.RxCChannel = Nvm.MacGroup2.MacParams.RxCChannel;\r\n            break;\r\n        }\r\n        case MIB_RXC_DEFAULT_CHANNEL:\r\n        {\r\n            mibGet->Param.RxCChannel = Nvm.MacGroup2.MacParamsDefaults.RxCChannel;\r\n            break;\r\n        }\r\n        case MIB_CHANNELS_DEFAULT_MASK:\r\n        {\r\n            getPhy.Attribute = PHY_CHANNELS_DEFAULT_MASK;\r\n            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );\r\n\r\n            mibGet->Param.ChannelsDefaultMask = phyParam.ChannelsMask;\r\n            break;\r\n        }\r\n        case MIB_CHANNELS_MASK:\r\n        {\r\n            getPhy.Attribute = PHY_CHANNELS_MASK;\r\n            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );\r\n\r\n            mibGet->Param.ChannelsMask = phyParam.ChannelsMask;\r\n            break;\r\n        }\r\n        case MIB_CHANNELS_NB_TRANS:\r\n        {\r\n            mibGet->Param.ChannelsNbTrans = Nvm.MacGroup2.MacParams.ChannelsNbTrans;\r\n            break;\r\n        }\r\n        case MIB_MAX_RX_WINDOW_DURATION:\r\n        {\r\n            mibGet->Param.MaxRxWindow = Nvm.MacGroup2.MacParams.MaxRxWindow;\r\n            break;\r\n        }\r\n        case MIB_RECEIVE_DELAY_1:\r\n        {\r\n            mibGet->Param.ReceiveDelay1 = Nvm.MacGroup2.MacParams.ReceiveDelay1;\r\n            break;\r\n        }\r\n        case MIB_RECEIVE_DELAY_2:\r\n        {\r\n            mibGet->Param.ReceiveDelay2 = Nvm.MacGroup2.MacParams.ReceiveDelay2;\r\n            break;\r\n        }\r\n        case MIB_JOIN_ACCEPT_DELAY_1:\r\n        {\r\n            mibGet->Param.JoinAcceptDelay1 = Nvm.MacGroup2.MacParams.JoinAcceptDelay1;\r\n            break;\r\n        }\r\n        case MIB_JOIN_ACCEPT_DELAY_2:\r\n        {\r\n            mibGet->Param.JoinAcceptDelay2 = Nvm.MacGroup2.MacParams.JoinAcceptDelay2;\r\n            break;\r\n        }\r\n        case MIB_CHANNELS_MIN_TX_DATARATE:\r\n        {\r\n            getPhy.Attribute = PHY_MIN_TX_DR;\r\n            getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;\r\n            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );\r\n\r\n            mibGet->Param.ChannelsMinTxDatarate = phyParam.Value;\r\n            break;\r\n        }\r\n        case MIB_CHANNELS_DEFAULT_DATARATE:\r\n        {\r\n            mibGet->Param.ChannelsDefaultDatarate = Nvm.MacGroup2.ChannelsDatarateDefault;\r\n            break;\r\n        }\r\n        case MIB_CHANNELS_DATARATE:\r\n        {\r\n            mibGet->Param.ChannelsDatarate = Nvm.MacGroup1.ChannelsDatarate;\r\n            break;\r\n        }\r\n        case MIB_CHANNELS_DEFAULT_TX_POWER:\r\n        {\r\n            mibGet->Param.ChannelsDefaultTxPower = Nvm.MacGroup2.ChannelsTxPowerDefault;\r\n            break;\r\n        }\r\n        case MIB_CHANNELS_TX_POWER:\r\n        {\r\n            mibGet->Param.ChannelsTxPower = Nvm.MacGroup1.ChannelsTxPower;\r\n            break;\r\n        }\r\n        case MIB_SYSTEM_MAX_RX_ERROR:\r\n        {\r\n            mibGet->Param.SystemMaxRxError = Nvm.MacGroup2.MacParams.SystemMaxRxError;\r\n            break;\r\n        }\r\n        case MIB_MIN_RX_SYMBOLS:\r\n        {\r\n            mibGet->Param.MinRxSymbols = Nvm.MacGroup2.MacParams.MinRxSymbols;\r\n            break;\r\n        }\r\n        case MIB_ANTENNA_GAIN:\r\n        {\r\n            mibGet->Param.AntennaGain = Nvm.MacGroup2.MacParams.AntennaGain;\r\n            break;\r\n        }\r\n        case MIB_NVM_CTXS:\r\n        {\r\n            mibGet->Param.Contexts = GetNvmData( );\r\n            break;\r\n        }\r\n        case MIB_DEFAULT_ANTENNA_GAIN:\r\n        {\r\n            mibGet->Param.DefaultAntennaGain = Nvm.MacGroup2.MacParamsDefaults.AntennaGain;\r\n            break;\r\n        }\r\n        case MIB_LORAWAN_VERSION:\r\n        {\r\n            mibGet->Param.LrWanVersion.LoRaWan = Nvm.MacGroup2.Version;\r\n            mibGet->Param.LrWanVersion.LoRaWanRegion = RegionGetVersion( );\r\n            break;\r\n        }\r\n        case MIB_IS_CERT_FPORT_ON:\r\n        {\r\n            mibGet->Param.IsCertPortOn = Nvm.MacGroup2.IsCertPortOn;\r\n            break;\r\n        }\r\n        case MIB_REJOIN_0_CYCLE:\r\n        {\r\n            mibGet->Param.Rejoin0CycleInSec = Nvm.MacGroup2.Rejoin0CycleInSec;\r\n            break;\r\n        }\r\n        case MIB_REJOIN_1_CYCLE:\r\n        {\r\n            mibGet->Param.Rejoin1CycleInSec = Nvm.MacGroup2.Rejoin1CycleInSec;\r\n            break;\r\n        }\r\n        case MIB_ADR_ACK_LIMIT:\r\n        {\r\n            mibGet->Param.AdrAckLimit = Nvm.MacGroup2.MacParams.AdrAckLimit;\r\n            break;\r\n        }\r\n        case MIB_ADR_ACK_DELAY:\r\n        {\r\n            mibGet->Param.AdrAckDelay = Nvm.MacGroup2.MacParams.AdrAckDelay;\r\n            break;\r\n        }\r\n        case MIB_ADR_ACK_DEFAULT_LIMIT:\r\n        {\r\n            mibGet->Param.AdrAckLimit = Nvm.MacGroup2.MacParamsDefaults.AdrAckLimit;\r\n            break;\r\n        }\r\n        case MIB_ADR_ACK_DEFAULT_DELAY:\r\n        {\r\n            mibGet->Param.AdrAckDelay = Nvm.MacGroup2.MacParamsDefaults.AdrAckDelay;\r\n            break;\r\n        }\r\n        case MIB_RSSI_FREE_THRESHOLD:\r\n        {\r\n#if defined(REGION_KR920) || defined(REGION_AS923)\r\n            if( Nvm.MacGroup2.Region != LORAMAC_REGION_AS923 && Nvm.MacGroup2.Region != LORAMAC_REGION_KR920 )\r\n            {\r\n                status = LORAMAC_STATUS_ERROR;\r\n            }\r\n            else\r\n            {\r\n                mibGet->Param.RssiFreeThreshold = Nvm.RegionGroup2.RssiFreeThreshold;\r\n            }\r\n#else\r\n            status = LORAMAC_STATUS_ERROR;\r\n#endif\r\n            break;\r\n        }\r\n        case MIB_CARRIER_SENSE_TIME:\r\n        {\r\n#if defined(REGION_KR920) || defined(REGION_AS923)\r\n            if( Nvm.MacGroup2.Region != LORAMAC_REGION_AS923 && Nvm.MacGroup2.Region != LORAMAC_REGION_KR920 )\r\n            {\r\n                status = LORAMAC_STATUS_ERROR;\r\n            }\r\n            else\r\n            {\r\n                mibGet->Param.CarrierSenseTime = Nvm.RegionGroup2.CarrierSenseTime;\r\n            }\r\n#else\r\n            status = LORAMAC_STATUS_ERROR;\r\n#endif\r\n            break;\r\n        }\r\n        default:\r\n        {\r\n            status = LoRaMacClassBMibGetRequestConfirm( mibGet );\r\n            break;\r\n        }\r\n    }\r\n    return status;\r\n}\r\n\r\nLoRaMacStatus_t LoRaMacMibSetRequestConfirm( MibRequestConfirm_t* mibSet )\r\n{\r\n    LoRaMacStatus_t status = LORAMAC_STATUS_OK;\r\n    ChanMaskSetParams_t chanMaskSet;\r\n    VerifyParams_t verify;\r\n\r\n    if( mibSet == NULL )\r\n    {\r\n        return LORAMAC_STATUS_PARAMETER_INVALID;\r\n    }\r\n    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )\r\n    {\r\n        return LORAMAC_STATUS_BUSY;\r\n    }\r\n\r\n    switch( mibSet->Type )\r\n    {\r\n        case MIB_DEVICE_CLASS:\r\n        {\r\n            status = SwitchClass( mibSet->Param.Class );\r\n            break;\r\n        }\r\n        case MIB_NETWORK_ACTIVATION:\r\n        {\r\n            if( mibSet->Param.NetworkActivation != ACTIVATION_TYPE_OTAA  )\r\n            {\r\n                Nvm.MacGroup2.NetworkActivation = mibSet->Param.NetworkActivation;\r\n            }\r\n            else\r\n            {   // Do not allow to set ACTIVATION_TYPE_OTAA since the MAC will set it automatically after a successful join process.\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_DEV_EUI:\r\n        {\r\n            if( SecureElementSetDevEui( mibSet->Param.DevEui ) != SECURE_ELEMENT_SUCCESS )\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_JOIN_EUI:\r\n        {\r\n            if( SecureElementSetJoinEui( mibSet->Param.JoinEui ) != SECURE_ELEMENT_SUCCESS )\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_SE_PIN:\r\n        {\r\n            if( SecureElementSetPin( mibSet->Param.SePin ) != SECURE_ELEMENT_SUCCESS )\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_ADR:\r\n        {\r\n            Nvm.MacGroup2.AdrCtrlOn = mibSet->Param.AdrEnable;\r\n            break;\r\n        }\r\n        case MIB_NET_ID:\r\n        {\r\n            Nvm.MacGroup2.NetID = mibSet->Param.NetID;\r\n            break;\r\n        }\r\n        case MIB_DEV_ADDR:\r\n        {\r\n            Nvm.MacGroup2.DevAddr = mibSet->Param.DevAddr;\r\n            break;\r\n        }\r\n        case MIB_APP_KEY:\r\n        {\r\n            if( mibSet->Param.AppKey != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( APP_KEY, mibSet->Param.AppKey ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_NWK_KEY:\r\n        {\r\n            if( mibSet->Param.NwkKey != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( NWK_KEY, mibSet->Param.NwkKey ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_J_S_INT_KEY:\r\n        {\r\n            if( mibSet->Param.JSIntKey != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( J_S_INT_KEY, mibSet->Param.JSIntKey ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_J_S_ENC_KEY:\r\n        {\r\n            if( mibSet->Param.JSEncKey != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( J_S_ENC_KEY, mibSet->Param.JSEncKey ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_F_NWK_S_INT_KEY:\r\n        {\r\n            if( mibSet->Param.FNwkSIntKey != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( F_NWK_S_INT_KEY, mibSet->Param.FNwkSIntKey ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_S_NWK_S_INT_KEY:\r\n        {\r\n            if( mibSet->Param.SNwkSIntKey != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( S_NWK_S_INT_KEY, mibSet->Param.SNwkSIntKey ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_NWK_S_ENC_KEY:\r\n        {\r\n            if( mibSet->Param.NwkSEncKey != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( NWK_S_ENC_KEY, mibSet->Param.NwkSEncKey ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_APP_S_KEY:\r\n        {\r\n            if( mibSet->Param.AppSKey != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( APP_S_KEY, mibSet->Param.AppSKey ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_MC_KE_KEY:\r\n        {\r\n            if( mibSet->Param.McKEKey != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_KE_KEY, mibSet->Param.McKEKey ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_MC_KEY_0:\r\n        {\r\n            if( mibSet->Param.McKey0 != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_KEY_0, mibSet->Param.McKey0 ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_MC_APP_S_KEY_0:\r\n        {\r\n            if( mibSet->Param.McAppSKey0 != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_APP_S_KEY_0, mibSet->Param.McAppSKey0 ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_MC_NWK_S_KEY_0:\r\n        {\r\n            if( mibSet->Param.McNwkSKey0 != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_NWK_S_KEY_0, mibSet->Param.McNwkSKey0 ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_MC_KEY_1:\r\n        {\r\n            if( mibSet->Param.McKey1 != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_KEY_1, mibSet->Param.McKey1 ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_MC_APP_S_KEY_1:\r\n        {\r\n            if( mibSet->Param.McAppSKey1 != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_APP_S_KEY_1, mibSet->Param.McAppSKey1 ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_MC_NWK_S_KEY_1:\r\n        {\r\n            if( mibSet->Param.McNwkSKey1 != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_NWK_S_KEY_1, mibSet->Param.McNwkSKey1 ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_MC_KEY_2:\r\n        {\r\n            if( mibSet->Param.McKey2 != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_KEY_2, mibSet->Param.McKey2 ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_MC_APP_S_KEY_2:\r\n        {\r\n            if( mibSet->Param.McAppSKey2 != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_APP_S_KEY_2, mibSet->Param.McAppSKey2 ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_MC_NWK_S_KEY_2:\r\n        {\r\n            if( mibSet->Param.McNwkSKey2 != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_NWK_S_KEY_2, mibSet->Param.McNwkSKey2 ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_MC_KEY_3:\r\n        {\r\n            if( mibSet->Param.McKey3 != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_KEY_3, mibSet->Param.McKey3 ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_MC_APP_S_KEY_3:\r\n        {\r\n            if( mibSet->Param.McAppSKey3 != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_APP_S_KEY_3, mibSet->Param.McAppSKey3 ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_MC_NWK_S_KEY_3:\r\n        {\r\n            if( mibSet->Param.McNwkSKey3 != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_NWK_S_KEY_3, mibSet->Param.McNwkSKey3 ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_PUBLIC_NETWORK:\r\n        {\r\n            Nvm.MacGroup2.PublicNetwork = mibSet->Param.EnablePublicNetwork;\r\n            Radio.SetPublicNetwork( Nvm.MacGroup2.PublicNetwork );\r\n            break;\r\n        }\r\n        case MIB_RX2_CHANNEL:\r\n        {\r\n            verify.DatarateParams.Datarate = mibSet->Param.Rx2Channel.Datarate;\r\n            verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;\r\n\r\n            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )\r\n            {\r\n                Nvm.MacGroup2.MacParams.Rx2Channel = mibSet->Param.Rx2Channel;\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_RX2_DEFAULT_CHANNEL:\r\n        {\r\n            verify.DatarateParams.Datarate = mibSet->Param.Rx2Channel.Datarate;\r\n            verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;\r\n\r\n            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )\r\n            {\r\n                Nvm.MacGroup2.MacParamsDefaults.Rx2Channel = mibSet->Param.Rx2DefaultChannel;\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_RXC_CHANNEL:\r\n        {\r\n            verify.DatarateParams.Datarate = mibSet->Param.RxCChannel.Datarate;\r\n            verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;\r\n\r\n            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )\r\n            {\r\n                Nvm.MacGroup2.MacParams.RxCChannel = mibSet->Param.RxCChannel;\r\n\r\n                if( ( Nvm.MacGroup2.DeviceClass == CLASS_C ) && ( Nvm.MacGroup2.NetworkActivation != ACTIVATION_TYPE_NONE ) )\r\n                {\r\n                    // We can only compute the RX window parameters directly, if we are already\r\n                    // in class c mode and joined. We cannot setup an RX window in case of any other\r\n                    // class type.\r\n                    // Set the radio into sleep mode in case we are still in RX mode\r\n                    Radio.Sleep( );\r\n\r\n                    OpenContinuousRxCWindow( );\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_RXC_DEFAULT_CHANNEL:\r\n        {\r\n            verify.DatarateParams.Datarate = mibSet->Param.RxCChannel.Datarate;\r\n            verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;\r\n\r\n            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )\r\n            {\r\n                Nvm.MacGroup2.MacParamsDefaults.RxCChannel = mibSet->Param.RxCDefaultChannel;\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_CHANNELS_DEFAULT_MASK:\r\n        {\r\n            chanMaskSet.ChannelsMaskIn = mibSet->Param.ChannelsDefaultMask;\r\n            chanMaskSet.ChannelsMaskType = CHANNELS_DEFAULT_MASK;\r\n\r\n            if( RegionChanMaskSet( Nvm.MacGroup2.Region, &chanMaskSet ) == false )\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_CHANNELS_MASK:\r\n        {\r\n            chanMaskSet.ChannelsMaskIn = mibSet->Param.ChannelsMask;\r\n            chanMaskSet.ChannelsMaskType = CHANNELS_MASK;\r\n\r\n            if( RegionChanMaskSet( Nvm.MacGroup2.Region, &chanMaskSet ) == false )\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_CHANNELS_NB_TRANS:\r\n        {\r\n            if( ( mibSet->Param.ChannelsNbTrans >= 1 ) &&\r\n                ( mibSet->Param.ChannelsNbTrans <= 15 ) )\r\n            {\r\n                Nvm.MacGroup2.MacParams.ChannelsNbTrans = mibSet->Param.ChannelsNbTrans;\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_MAX_RX_WINDOW_DURATION:\r\n        {\r\n            Nvm.MacGroup2.MacParams.MaxRxWindow = mibSet->Param.MaxRxWindow;\r\n            break;\r\n        }\r\n        case MIB_RECEIVE_DELAY_1:\r\n        {\r\n            Nvm.MacGroup2.MacParams.ReceiveDelay1 = mibSet->Param.ReceiveDelay1;\r\n            break;\r\n        }\r\n        case MIB_RECEIVE_DELAY_2:\r\n        {\r\n            Nvm.MacGroup2.MacParams.ReceiveDelay2 = mibSet->Param.ReceiveDelay2;\r\n            break;\r\n        }\r\n        case MIB_JOIN_ACCEPT_DELAY_1:\r\n        {\r\n            Nvm.MacGroup2.MacParams.JoinAcceptDelay1 = mibSet->Param.JoinAcceptDelay1;\r\n            break;\r\n        }\r\n        case MIB_JOIN_ACCEPT_DELAY_2:\r\n        {\r\n            Nvm.MacGroup2.MacParams.JoinAcceptDelay2 = mibSet->Param.JoinAcceptDelay2;\r\n            break;\r\n        }\r\n        case MIB_CHANNELS_DEFAULT_DATARATE:\r\n        {\r\n            verify.DatarateParams.Datarate = mibSet->Param.ChannelsDefaultDatarate;\r\n\r\n            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_DEF_TX_DR ) == true )\r\n            {\r\n                Nvm.MacGroup2.ChannelsDatarateDefault = verify.DatarateParams.Datarate;\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_CHANNELS_DATARATE:\r\n        {\r\n            verify.DatarateParams.Datarate = mibSet->Param.ChannelsDatarate;\r\n            verify.DatarateParams.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;\r\n\r\n            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_TX_DR ) == true )\r\n            {\r\n                Nvm.MacGroup1.ChannelsDatarate = verify.DatarateParams.Datarate;\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_CHANNELS_DEFAULT_TX_POWER:\r\n        {\r\n            verify.TxPower = mibSet->Param.ChannelsDefaultTxPower;\r\n\r\n            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_DEF_TX_POWER ) == true )\r\n            {\r\n                Nvm.MacGroup2.ChannelsTxPowerDefault = verify.TxPower;\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_CHANNELS_TX_POWER:\r\n        {\r\n            verify.TxPower = mibSet->Param.ChannelsTxPower;\r\n\r\n            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_TX_POWER ) == true )\r\n            {\r\n                Nvm.MacGroup1.ChannelsTxPower = verify.TxPower;\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_SYSTEM_MAX_RX_ERROR:\r\n        {\r\n            Nvm.MacGroup2.MacParams.SystemMaxRxError = Nvm.MacGroup2.MacParamsDefaults.SystemMaxRxError = mibSet->Param.SystemMaxRxError;\r\n            break;\r\n        }\r\n        case MIB_MIN_RX_SYMBOLS:\r\n        {\r\n            Nvm.MacGroup2.MacParams.MinRxSymbols = Nvm.MacGroup2.MacParamsDefaults.MinRxSymbols = mibSet->Param.MinRxSymbols;\r\n            break;\r\n        }\r\n        case MIB_ANTENNA_GAIN:\r\n        {\r\n            Nvm.MacGroup2.MacParams.AntennaGain = mibSet->Param.AntennaGain;\r\n            break;\r\n        }\r\n        case MIB_DEFAULT_ANTENNA_GAIN:\r\n        {\r\n            Nvm.MacGroup2.MacParamsDefaults.AntennaGain = mibSet->Param.DefaultAntennaGain;\r\n            break;\r\n        }\r\n        case MIB_NVM_CTXS:\r\n        {\r\n            if( mibSet->Param.Contexts != 0 )\r\n            {\r\n                status = RestoreNvmData( mibSet->Param.Contexts );\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_ABP_LORAWAN_VERSION:\r\n        {\r\n            if( mibSet->Param.AbpLrWanVersion.Fields.Minor <= 1 )\r\n            {\r\n                Nvm.MacGroup2.Version = mibSet->Param.AbpLrWanVersion;\r\n\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetLrWanVersion( mibSet->Param.AbpLrWanVersion ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_IS_CERT_FPORT_ON:\r\n        {\r\n            Nvm.MacGroup2.IsCertPortOn = mibSet->Param.IsCertPortOn;\r\n            break;\r\n        }\r\n        case MIB_REJOIN_0_CYCLE:\r\n        {\r\n            uint32_t cycleTime = 0;\r\n            if( ( ConvertRejoinCycleTime( mibSet->Param.Rejoin0CycleInSec, &cycleTime ) == true ) &&\r\n                ( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_OTAA ) )\r\n            {\r\n                Nvm.MacGroup2.Rejoin0CycleInSec = mibSet->Param.Rejoin0CycleInSec;\r\n                MacCtx.Rejoin0CycleTime = cycleTime;\r\n                TimerStop( &MacCtx.Rejoin0CycleTimer );\r\n                TimerSetValue( &MacCtx.Rejoin0CycleTimer, MacCtx.Rejoin0CycleTime );\r\n                TimerStart( &MacCtx.Rejoin0CycleTimer );\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_REJOIN_1_CYCLE:\r\n        {\r\n            uint32_t cycleTime = 0;\r\n            if( ( ConvertRejoinCycleTime( mibSet->Param.Rejoin1CycleInSec, &cycleTime ) == true ) &&\r\n                ( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_OTAA ) )\r\n            {\r\n                Nvm.MacGroup2.Rejoin1CycleInSec = mibSet->Param.Rejoin1CycleInSec;\r\n                MacCtx.Rejoin0CycleTime = cycleTime;\r\n                TimerStop( &MacCtx.Rejoin1CycleTimer );\r\n                TimerSetValue( &MacCtx.Rejoin1CycleTimer, MacCtx.Rejoin1CycleTime );\r\n                TimerStart( &MacCtx.Rejoin1CycleTimer );\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_ADR_ACK_LIMIT:\r\n        {\r\n            Nvm.MacGroup2.MacParams.AdrAckLimit = mibSet->Param.AdrAckLimit;\r\n            break;\r\n        }\r\n        case MIB_ADR_ACK_DELAY:\r\n        {\r\n            Nvm.MacGroup2.MacParams.AdrAckDelay = mibSet->Param.AdrAckDelay;\r\n            break;\r\n        }\r\n        case MIB_ADR_ACK_DEFAULT_LIMIT:\r\n        {\r\n            Nvm.MacGroup2.MacParamsDefaults.AdrAckLimit = mibSet->Param.AdrAckLimit;\r\n            break;\r\n        }\r\n        case MIB_ADR_ACK_DEFAULT_DELAY:\r\n        {\r\n            Nvm.MacGroup2.MacParamsDefaults.AdrAckDelay = mibSet->Param.AdrAckDelay;\r\n            break;\r\n        }\r\n        case MIB_RSSI_FREE_THRESHOLD:\r\n        {\r\n#if defined(REGION_KR920) || defined(REGION_AS923)\r\n            if( Nvm.MacGroup2.Region != LORAMAC_REGION_AS923 && Nvm.MacGroup2.Region != LORAMAC_REGION_KR920 )\r\n            {\r\n                status = LORAMAC_STATUS_ERROR;\r\n            }\r\n            else\r\n            {\r\n                Nvm.RegionGroup2.RssiFreeThreshold = mibSet->Param.RssiFreeThreshold;\r\n            }\r\n#else\r\n            status = LORAMAC_STATUS_ERROR;\r\n#endif\r\n            break;\r\n        }\r\n        case MIB_CARRIER_SENSE_TIME:\r\n        {\r\n#if defined(REGION_KR920) || defined(REGION_AS923)\r\n            if( Nvm.MacGroup2.Region != LORAMAC_REGION_AS923 && Nvm.MacGroup2.Region != LORAMAC_REGION_KR920 )\r\n            {\r\n                status = LORAMAC_STATUS_ERROR;\r\n            }\r\n            else\r\n            {\r\n                Nvm.RegionGroup2.CarrierSenseTime = mibSet->Param.CarrierSenseTime;\r\n            }\r\n#else\r\n            status = LORAMAC_STATUS_ERROR;\r\n#endif\r\n            break;\r\n        }\r\n        default:\r\n        {\r\n            status = LoRaMacMibClassBSetRequestConfirm( mibSet );\r\n            break;\r\n        }\r\n    }\r\n\r\n    if( status == LORAMAC_STATUS_OK )\r\n    {\r\n        // Handle NVM potential changes\r\n        MacCtx.MacFlags.Bits.NvmHandle = 1;\r\n    }\r\n    return status;\r\n}\r\n\r\nLoRaMacStatus_t LoRaMacChannelAdd( uint8_t id, ChannelParams_t params )\r\n{\r\n    ChannelAddParams_t channelAdd;\r\n\r\n    // Validate if the MAC is in a correct state\r\n    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )\r\n    {\r\n        if( ( MacCtx.MacState & LORAMAC_TX_CONFIG ) != LORAMAC_TX_CONFIG )\r\n        {\r\n            return LORAMAC_STATUS_BUSY;\r\n        }\r\n    }\r\n\r\n    channelAdd.NewChannel = &params;\r\n    channelAdd.ChannelId = id;\r\n    return RegionChannelAdd( Nvm.MacGroup2.Region, &channelAdd );\r\n}\r\n\r\nLoRaMacStatus_t LoRaMacChannelRemove( uint8_t id )\r\n{\r\n    ChannelRemoveParams_t channelRemove;\r\n\r\n    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )\r\n    {\r\n        if( ( MacCtx.MacState & LORAMAC_TX_CONFIG ) != LORAMAC_TX_CONFIG )\r\n        {\r\n            return LORAMAC_STATUS_BUSY;\r\n        }\r\n    }\r\n\r\n    channelRemove.ChannelId = id;\r\n\r\n    if( RegionChannelsRemove( Nvm.MacGroup2.Region, &channelRemove ) == false )\r\n    {\r\n        return LORAMAC_STATUS_PARAMETER_INVALID;\r\n    }\r\n    return LORAMAC_STATUS_OK;\r\n}\r\n\r\nLoRaMacStatus_t LoRaMacMcChannelSetup( McChannelParams_t *channel )\r\n{\r\n    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )\r\n    {\r\n        return LORAMAC_STATUS_BUSY;\r\n    }\r\n\r\n    if( channel->GroupID >= LORAMAC_MAX_MC_CTX )\r\n    {\r\n        return LORAMAC_STATUS_MC_GROUP_UNDEFINED;\r\n    }\r\n\r\n    Nvm.MacGroup2.MulticastChannelList[channel->GroupID].ChannelParams = *channel;\r\n    MacCtx.MacFlags.Bits.NvmHandle = 1;\r\n\r\n    if( channel->IsRemotelySetup == true )\r\n    {\r\n        const KeyIdentifier_t mcKeys[LORAMAC_MAX_MC_CTX] = { MC_KEY_0, MC_KEY_1, MC_KEY_2, MC_KEY_3 };\r\n        if( LoRaMacCryptoSetKey( mcKeys[channel->GroupID], channel->McKeys.McKeyE ) != LORAMAC_CRYPTO_SUCCESS )\r\n        {\r\n            return LORAMAC_STATUS_CRYPTO_ERROR;\r\n        }\r\n\r\n        if( LoRaMacCryptoDeriveMcSessionKeyPair( channel->GroupID, channel->Address ) != LORAMAC_CRYPTO_SUCCESS )\r\n        {\r\n            return LORAMAC_STATUS_CRYPTO_ERROR;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        const KeyIdentifier_t mcAppSKeys[LORAMAC_MAX_MC_CTX] = { MC_APP_S_KEY_0, MC_APP_S_KEY_1, MC_APP_S_KEY_2, MC_APP_S_KEY_3 };\r\n        const KeyIdentifier_t mcNwkSKeys[LORAMAC_MAX_MC_CTX] = { MC_NWK_S_KEY_0, MC_NWK_S_KEY_1, MC_NWK_S_KEY_2, MC_NWK_S_KEY_3 };\r\n        if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( mcAppSKeys[channel->GroupID], channel->McKeys.Session.McAppSKey ) )\r\n        {\r\n            return LORAMAC_STATUS_CRYPTO_ERROR;\r\n        }\r\n        if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( mcNwkSKeys[channel->GroupID], channel->McKeys.Session.McNwkSKey ) )\r\n        {\r\n            return LORAMAC_STATUS_CRYPTO_ERROR;\r\n        }\r\n    }\r\n\r\n    // Reset multicast channel downlink counter to initial value.\r\n    *Nvm.MacGroup2.MulticastChannelList[channel->GroupID].DownLinkCounter = FCNT_DOWN_INITIAL_VALUE;\r\n    return LORAMAC_STATUS_OK;\r\n}\r\n\r\nLoRaMacStatus_t LoRaMacMcChannelDelete( AddressIdentifier_t groupID )\r\n{\r\n    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )\r\n    {\r\n        return LORAMAC_STATUS_BUSY;\r\n    }\r\n\r\n    if( ( groupID >= LORAMAC_MAX_MC_CTX ) ||\r\n        ( Nvm.MacGroup2.MulticastChannelList[groupID].ChannelParams.IsEnabled == false ) )\r\n    {\r\n        return LORAMAC_STATUS_MC_GROUP_UNDEFINED;\r\n    }\r\n\r\n    McChannelParams_t channel;\r\n\r\n    // Set all channel fields with 0\r\n    memset1( ( uint8_t* )&channel, 0, sizeof( McChannelParams_t ) );\r\n\r\n    Nvm.MacGroup2.MulticastChannelList[groupID].ChannelParams = channel;\r\n    MacCtx.MacFlags.Bits.NvmHandle = 1;\r\n    return LORAMAC_STATUS_OK;\r\n}\r\n\r\nuint8_t LoRaMacMcChannelGetGroupId( uint32_t mcAddress )\r\n{\r\n    for( uint8_t i = 0; i < LORAMAC_MAX_MC_CTX; i++ )\r\n    {\r\n        if( mcAddress == Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.Address )\r\n        {\r\n            return i;\r\n        }\r\n    }\r\n    return 0xFF;\r\n}\r\n\r\nLoRaMacStatus_t LoRaMacMcChannelSetupRxParams( AddressIdentifier_t groupID, McRxParams_t *rxParams, uint8_t *status )\r\n{\r\n   *status = 0x1C + ( groupID & 0x03 );\r\n\r\n    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )\r\n    {\r\n        return LORAMAC_STATUS_BUSY;\r\n    }\r\n\r\n    if( ( rxParams->Class == CLASS_A ) || ( rxParams->Class > CLASS_C ) )\r\n    {\r\n        return LORAMAC_STATUS_PARAMETER_INVALID;\r\n    }\r\n\r\n    if( ( groupID >= LORAMAC_MAX_MC_CTX ) ||\r\n        ( Nvm.MacGroup2.MulticastChannelList[groupID].ChannelParams.IsEnabled == false ) )\r\n    {\r\n        return LORAMAC_STATUS_MC_GROUP_UNDEFINED;\r\n    }\r\n    *status &= 0x0F; // groupID OK\r\n\r\n    VerifyParams_t verify;\r\n    // Check datarate\r\n    if( rxParams->Class == CLASS_B )\r\n    {\r\n        verify.DatarateParams.Datarate = rxParams->Params.ClassB.Datarate;\r\n    }\r\n    else\r\n    {\r\n        verify.DatarateParams.Datarate = rxParams->Params.ClassC.Datarate;\r\n    }\r\n    verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;\r\n\r\n    if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )\r\n    {\r\n        *status &= 0xFB; // datarate OK\r\n    }\r\n\r\n    // Check frequency\r\n    if( rxParams->Class == CLASS_B )\r\n    {\r\n        verify.Frequency = rxParams->Params.ClassB.Frequency;\r\n    }\r\n    else\r\n    {\r\n        verify.Frequency = rxParams->Params.ClassC.Frequency;\r\n    }\r\n    if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_FREQUENCY ) == true )\r\n    {\r\n        *status &= 0xF7; // frequency OK\r\n    }\r\n\r\n    if( *status == ( groupID & 0x03 ) )\r\n    {\r\n        // Apply parameters\r\n        Nvm.MacGroup2.MulticastChannelList[groupID].ChannelParams.RxParams = *rxParams;\r\n        MacCtx.MacFlags.Bits.NvmHandle = 1;\r\n    }\r\n    else\r\n    {\r\n        return LORAMAC_STATUS_PARAMETER_INVALID;\r\n    }\r\n\r\n    if( rxParams->Class == CLASS_B )\r\n    {\r\n        // Calculate class b parameters\r\n        LoRaMacClassBSetMulticastPeriodicity( &Nvm.MacGroup2.MulticastChannelList[groupID] );\r\n    }\r\n    return LORAMAC_STATUS_OK;\r\n}\r\n\r\nLoRaMacStatus_t LoRaMacMlmeRequest( MlmeReq_t* mlmeRequest )\r\n{\r\n    LoRaMacStatus_t status = LORAMAC_STATUS_SERVICE_UNKNOWN;\r\n    MlmeConfirmQueue_t queueElement;\r\n    uint8_t macCmdPayload[2] = { 0x00, 0x00 };\r\n\r\n    if( mlmeRequest == NULL )\r\n    {\r\n        return LORAMAC_STATUS_PARAMETER_INVALID;\r\n    }\r\n    // Initialize mlmeRequest->ReqReturn.DutyCycleWaitTime to 0 in order to\r\n    // return a valid value in case the MAC is busy.\r\n    mlmeRequest->ReqReturn.DutyCycleWaitTime = 0;\r\n\r\n    if( LoRaMacIsBusy( ) == true )\r\n    {\r\n        return LORAMAC_STATUS_BUSY;\r\n    }\r\n    if( LoRaMacConfirmQueueIsFull( ) == true )\r\n    {\r\n        return LORAMAC_STATUS_BUSY;\r\n    }\r\n\r\n    if( LoRaMacConfirmQueueGetCnt( ) == 0 )\r\n    {\r\n        memset1( ( uint8_t* ) &MacCtx.MlmeConfirm, 0, sizeof( MacCtx.MlmeConfirm ) );\r\n    }\r\n    MacCtx.MlmeConfirm.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\r\n\r\n    MacCtx.MacFlags.Bits.MlmeReq = 1;\r\n    queueElement.Request = mlmeRequest->Type;\r\n    queueElement.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\r\n    queueElement.RestrictCommonReadyToHandle = false;\r\n    queueElement.ReadyToHandle = false;\r\n\r\n    switch( mlmeRequest->Type )\r\n    {\r\n        case MLME_JOIN:\r\n        {\r\n            if( ( MacCtx.MacState & LORAMAC_TX_DELAYED ) == LORAMAC_TX_DELAYED )\r\n            {\r\n                return LORAMAC_STATUS_BUSY;\r\n            }\r\n\r\n            if( mlmeRequest->Req.Join.NetworkActivation == ACTIVATION_TYPE_OTAA )\r\n            {\r\n                ResetMacParameters( false );\r\n\r\n            Nvm.MacGroup1.ChannelsDatarate = RegionAlternateDr( Nvm.MacGroup2.Region, mlmeRequest->Req.Join.Datarate, ALTERNATE_DR );\r\n\r\n                queueElement.Status = LORAMAC_EVENT_INFO_STATUS_JOIN_FAIL;\r\n\r\n                status = SendReJoinReq( JOIN_REQ );\r\n\r\n                if( status != LORAMAC_STATUS_OK )\r\n                {\r\n                    // Revert back the previous datarate ( mainly used for US915 like regions )\r\n                    Nvm.MacGroup1.ChannelsDatarate = RegionAlternateDr( Nvm.MacGroup2.Region, mlmeRequest->Req.Join.Datarate, ALTERNATE_DR_RESTORE );\r\n                }\r\n            }\r\n            else if( mlmeRequest->Req.Join.NetworkActivation == ACTIVATION_TYPE_ABP )\r\n            {\r\n                // Restore default value for ChannelsDatarateChangedLinkAdrReq\r\n                Nvm.MacGroup2.ChannelsDatarateChangedLinkAdrReq = false;\r\n\r\n                // Activate the default channels\r\n                InitDefaultsParams_t params;\r\n                params.Type = INIT_TYPE_ACTIVATE_DEFAULT_CHANNELS;\r\n                RegionInitDefaults( Nvm.MacGroup2.Region, &params );\r\n\r\n                Nvm.MacGroup2.NetworkActivation = mlmeRequest->Req.Join.NetworkActivation;\r\n                queueElement.Status = LORAMAC_EVENT_INFO_STATUS_OK;\r\n                queueElement.ReadyToHandle = true;\r\n                MacCtx.MacCallbacks->MacProcessNotify( );\r\n                MacCtx.MacFlags.Bits.MacDone = 1;\r\n                status = LORAMAC_STATUS_OK;\r\n            }\r\n            break;\r\n        }\r\n        case MLME_REJOIN_0:\r\n        {\r\n            MacCtx.MacFlags.Bits.MlmeReq = 1;\r\n            MacCtx.MlmeConfirm.MlmeRequest = mlmeRequest->Type;\r\n\r\n            status = SendReJoinReq( REJOIN_REQ_0 );\r\n\r\n            break;\r\n        }\r\n        case MLME_REJOIN_1:\r\n        {\r\n            MacCtx.MacFlags.Bits.MlmeReq = 1;\r\n            MacCtx.MlmeConfirm.MlmeRequest = mlmeRequest->Type;\r\n\r\n            status = SendReJoinReq( REJOIN_REQ_1 );\r\n\r\n            break;\r\n        }\r\n        case MLME_REJOIN_2:\r\n        {\r\n            MacCtx.MacFlags.Bits.MlmeReq = 1;\r\n            MacCtx.MlmeConfirm.MlmeRequest = mlmeRequest->Type;\r\n\r\n            status = SendReJoinReq( REJOIN_REQ_2 );\r\n\r\n            break;\r\n        }\r\n        case MLME_LINK_CHECK:\r\n        {\r\n            // LoRaMac will send this command piggy-pack\r\n            status = LORAMAC_STATUS_OK;\r\n            if( LoRaMacCommandsAddCmd( MOTE_MAC_LINK_CHECK_REQ, macCmdPayload, 0 ) != LORAMAC_COMMANDS_SUCCESS )\r\n            {\r\n                status = LORAMAC_STATUS_MAC_COMMAD_ERROR;\r\n            }\r\n            break;\r\n        }\r\n        case MLME_TXCW:\r\n        {\r\n            status = SetTxContinuousWave( mlmeRequest->Req.TxCw.Timeout, mlmeRequest->Req.TxCw.Frequency, mlmeRequest->Req.TxCw.Power );\r\n            break;\r\n        }\r\n        case MLME_DEVICE_TIME:\r\n        {\r\n            // LoRaMac will send this command piggy-pack\r\n            status = LORAMAC_STATUS_OK;\r\n            if( LoRaMacCommandsAddCmd( MOTE_MAC_DEVICE_TIME_REQ, macCmdPayload, 0 ) != LORAMAC_COMMANDS_SUCCESS )\r\n            {\r\n                status = LORAMAC_STATUS_MAC_COMMAD_ERROR;\r\n            }\r\n            break;\r\n        }\r\n        case MLME_PING_SLOT_INFO:\r\n        {\r\n            if( Nvm.MacGroup2.DeviceClass == CLASS_A )\r\n            {\r\n                uint8_t value = mlmeRequest->Req.PingSlotInfo.PingSlot.Value;\r\n\r\n                // LoRaMac will send this command piggy-pack\r\n                LoRaMacClassBSetPingSlotInfo( mlmeRequest->Req.PingSlotInfo.PingSlot.Fields.Periodicity );\r\n                macCmdPayload[0] = value;\r\n                status = LORAMAC_STATUS_OK;\r\n                if( LoRaMacCommandsAddCmd( MOTE_MAC_PING_SLOT_INFO_REQ, macCmdPayload, 1 ) != LORAMAC_COMMANDS_SUCCESS )\r\n                {\r\n                    status = LORAMAC_STATUS_MAC_COMMAD_ERROR;\r\n                }\r\n            }\r\n            break;\r\n        }\r\n        case MLME_BEACON_TIMING:\r\n        {\r\n            // LoRaMac will send this command piggy-pack\r\n            status = LORAMAC_STATUS_OK;\r\n            if( LoRaMacCommandsAddCmd( MOTE_MAC_BEACON_TIMING_REQ, macCmdPayload, 0 ) != LORAMAC_COMMANDS_SUCCESS )\r\n            {\r\n                status = LORAMAC_STATUS_MAC_COMMAD_ERROR;\r\n            }\r\n            break;\r\n        }\r\n        case MLME_BEACON_ACQUISITION:\r\n        {\r\n            // Apply the request\r\n            queueElement.RestrictCommonReadyToHandle = true;\r\n\r\n            if( LoRaMacClassBIsAcquisitionInProgress( ) == false )\r\n            {\r\n                // Start class B algorithm\r\n                LoRaMacClassBSetBeaconState( BEACON_STATE_ACQUISITION );\r\n                LoRaMacClassBBeaconTimerEvent( NULL );\r\n\r\n                status = LORAMAC_STATUS_OK;\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_BUSY;\r\n            }\r\n            break;\r\n        }\r\n        default:\r\n            break;\r\n    }\r\n\r\n    // Fill return structure\r\n    mlmeRequest->ReqReturn.DutyCycleWaitTime = MacCtx.DutyCycleWaitTime;\r\n\r\n    if( status != LORAMAC_STATUS_OK )\r\n    {\r\n        if( LoRaMacConfirmQueueGetCnt( ) == 0 )\r\n        {\r\n            MacCtx.NodeAckRequested = false;\r\n            MacCtx.MacFlags.Bits.MlmeReq = 0;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        LoRaMacConfirmQueueAdd( &queueElement );\r\n    }\r\n    return status;\r\n}\r\n\r\nLoRaMacStatus_t LoRaMacMcpsRequest( McpsReq_t* mcpsRequest )\r\n{\r\n    GetPhyParams_t getPhy;\r\n    PhyParam_t phyParam;\r\n    LoRaMacStatus_t status = LORAMAC_STATUS_SERVICE_UNKNOWN;\r\n    LoRaMacHeader_t macHdr;\r\n    VerifyParams_t verify;\r\n    uint8_t fPort = 0;\r\n    void* fBuffer;\r\n    uint16_t fBufferSize;\r\n    int8_t datarate = DR_0;\r\n    bool readyToSend = false;\r\n\r\n    if( mcpsRequest == NULL )\r\n    {\r\n        return LORAMAC_STATUS_PARAMETER_INVALID;\r\n    }\r\n    // Initialize mcpsRequest->ReqReturn.DutyCycleWaitTime to 0 in order to\r\n    // return a valid value in case the MAC is busy.\r\n    mcpsRequest->ReqReturn.DutyCycleWaitTime = 0;\r\n\r\n    if( LoRaMacIsBusy( ) == true )\r\n    {\r\n        return LORAMAC_STATUS_BUSY;\r\n    }\r\n\r\n    McpsReq_t request = *mcpsRequest;\r\n\r\n    macHdr.Value = 0;\r\n    memset1( ( uint8_t* ) &MacCtx.McpsConfirm, 0, sizeof( MacCtx.McpsConfirm ) );\r\n    MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\r\n\r\n    // Apply confirmed downlinks, if the device has not received a valid\r\n    // downlink after a join accept.\r\n    if( ( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_OTAA ) &&\r\n        ( Nvm.MacGroup2.DeviceClass == CLASS_C ) &&\r\n        ( Nvm.MacGroup2.DownlinkReceived == false ) &&\r\n        ( request.Type == MCPS_UNCONFIRMED ) )\r\n    {\r\n        request.Type = MCPS_CONFIRMED;\r\n    }\r\n\r\n    switch( request.Type )\r\n    {\r\n        case MCPS_UNCONFIRMED:\r\n        {\r\n            readyToSend = true;\r\n\r\n            macHdr.Bits.MType = FRAME_TYPE_DATA_UNCONFIRMED_UP;\r\n            fPort = request.Req.Unconfirmed.fPort;\r\n            fBuffer = request.Req.Unconfirmed.fBuffer;\r\n            fBufferSize = request.Req.Unconfirmed.fBufferSize;\r\n            datarate = request.Req.Unconfirmed.Datarate;\r\n            break;\r\n        }\r\n        case MCPS_CONFIRMED:\r\n        {\r\n            readyToSend = true;\r\n\r\n            macHdr.Bits.MType = FRAME_TYPE_DATA_CONFIRMED_UP;\r\n            fPort = request.Req.Confirmed.fPort;\r\n            fBuffer = request.Req.Confirmed.fBuffer;\r\n            fBufferSize = request.Req.Confirmed.fBufferSize;\r\n            datarate = request.Req.Confirmed.Datarate;\r\n            break;\r\n        }\r\n        case MCPS_PROPRIETARY:\r\n        {\r\n            readyToSend = true;\r\n\r\n            macHdr.Bits.MType = FRAME_TYPE_PROPRIETARY;\r\n            fBuffer = request.Req.Proprietary.fBuffer;\r\n            fBufferSize = request.Req.Proprietary.fBufferSize;\r\n            datarate = request.Req.Proprietary.Datarate;\r\n            break;\r\n        }\r\n        default:\r\n            break;\r\n    }\r\n\r\n    // Make sure that the input datarate is compliant\r\n    // to the regional specification.\r\n    getPhy.Attribute = PHY_MIN_TX_DR;\r\n    getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;\r\n    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );\r\n    // Apply the minimum possible datarate.\r\n    // Some regions have limitations for the minimum datarate.\r\n    datarate = MAX( datarate, ( int8_t )phyParam.Value );\r\n\r\n    // Apply minimum datarate in this special case.\r\n    if( CheckForMinimumAbpDatarate( Nvm.MacGroup2.AdrCtrlOn, Nvm.MacGroup2.NetworkActivation,\r\n                                    Nvm.MacGroup2.ChannelsDatarateChangedLinkAdrReq ) == true )\r\n    {\r\n        datarate = ( int8_t )phyParam.Value;\r\n    }\r\n\r\n    if( readyToSend == true )\r\n    {\r\n        if( ( Nvm.MacGroup2.AdrCtrlOn == false ) ||\r\n            ( CheckForMinimumAbpDatarate( Nvm.MacGroup2.AdrCtrlOn, Nvm.MacGroup2.NetworkActivation,\r\n                                          Nvm.MacGroup2.ChannelsDatarateChangedLinkAdrReq ) == true ) )\r\n        {\r\n            verify.DatarateParams.Datarate = datarate;\r\n            verify.DatarateParams.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;\r\n\r\n            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_TX_DR ) == true )\r\n            {\r\n                Nvm.MacGroup1.ChannelsDatarate = verify.DatarateParams.Datarate;\r\n            }\r\n            else\r\n            {\r\n                return LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n        }\r\n\r\n        // Verification of response timeout for class b and class c\r\n        LoRaMacHandleResponseTimeout( REGION_COMMON_CLASS_B_C_RESP_TIMEOUT,\r\n                                      MacCtx.ResponseTimeoutStartTime );\r\n\r\n        status = Send( &macHdr, fPort, fBuffer, fBufferSize );\r\n        if( status == LORAMAC_STATUS_OK )\r\n        {\r\n            MacCtx.McpsConfirm.McpsRequest = request.Type;\r\n            MacCtx.MacFlags.Bits.McpsReq = 1;\r\n        }\r\n        else\r\n        {\r\n            MacCtx.NodeAckRequested = false;\r\n        }\r\n    }\r\n\r\n    // Fill return structure\r\n    mcpsRequest->ReqReturn.DutyCycleWaitTime = MacCtx.DutyCycleWaitTime;\r\n\r\n    return status;\r\n}\r\n\r\nstatic bool ConvertRejoinCycleTime( uint32_t rejoinCycleTime, uint32_t* timeInMiliSec )\r\n{\r\n    // Our timer implementation do not allow longer times than 4294967295 ms\r\n    if( rejoinCycleTime <= 4294967 )\r\n    {\r\n        *timeInMiliSec = rejoinCycleTime * 1000;\r\n        return true;\r\n    }\r\n    else\r\n    {\r\n        return false;\r\n    }\r\n}\r\n\r\nstatic void OnRejoin0CycleTimerEvent( void* context )\r\n{\r\n    TimerStop( &MacCtx.Rejoin0CycleTimer );\r\n    ConvertRejoinCycleTime( Nvm.MacGroup2.Rejoin0CycleInSec, &MacCtx.Rejoin0CycleTime );\r\n\r\n    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )\r\n    {\r\n        MacCtx.MacCallbacks->MacProcessNotify( );\r\n    }\r\n\r\n    Nvm.MacGroup2.IsRejoin0RequestQueued = true;\r\n\r\n    TimerSetValue( &MacCtx.Rejoin0CycleTimer, MacCtx.Rejoin0CycleTime );\r\n    TimerStart( &MacCtx.Rejoin0CycleTimer );\r\n}\r\n\r\nstatic void OnRejoin1CycleTimerEvent( void* context )\r\n{\r\n    TimerStop( &MacCtx.Rejoin1CycleTimer );\r\n    ConvertRejoinCycleTime( Nvm.MacGroup2.Rejoin1CycleInSec, &MacCtx.Rejoin1CycleTime );\r\n\r\n    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )\r\n    {\r\n        MacCtx.MacCallbacks->MacProcessNotify( );\r\n    }\r\n\r\n    Nvm.MacGroup2.IsRejoin1RequestQueued = true;\r\n\r\n    TimerSetValue( &MacCtx.Rejoin1CycleTimer, MacCtx.Rejoin1CycleTime );\r\n    TimerStart( &MacCtx.Rejoin1CycleTimer );\r\n}\r\n\r\nstatic void OnForceRejoinReqCycleTimerEvent( void* context )\r\n{\r\n    Nvm.MacGroup1.ForceRejoinRetriesCounter++;\r\n    if( ( Nvm.MacGroup2.ForceRejoinType == 0 ) || ( Nvm.MacGroup2.ForceRejoinType == 1 ) )\r\n    {\r\n        Nvm.MacGroup2.IsRejoin0RequestQueued = true;\r\n    }\r\n    else\r\n    {\r\n        Nvm.MacGroup2.IsRejoin2RequestQueued = true;\r\n    }\r\n\r\n    if( Nvm.MacGroup1.ForceRejoinRetriesCounter >= Nvm.MacGroup2.ForceRejoinMaxRetries )\r\n    {\r\n        TimerStop( &MacCtx.ForceRejoinReqCycleTimer );\r\n        Nvm.MacGroup1.ForceRejoinRetriesCounter = 0;\r\n    }\r\n    else\r\n    {\r\n        TimerSetValue( &MacCtx.ForceRejoinReqCycleTimer, MacCtx.ForceRejonCycleTime );\r\n        TimerStart( &MacCtx.ForceRejoinReqCycleTimer );\r\n    }\r\n\r\n    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )\r\n    {\r\n        MacCtx.MacCallbacks->MacProcessNotify( );\r\n    }\r\n}\r\n\r\nvoid LoRaMacTestSetDutyCycleOn( bool enable )\r\n{\r\n    VerifyParams_t verify;\r\n\r\n    verify.DutyCycle = enable;\r\n\r\n    if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_DUTY_CYCLE ) == true )\r\n    {\r\n        Nvm.MacGroup2.DutyCycleOn = enable;\r\n        // Handle NVM potential changes\r\n        MacCtx.MacFlags.Bits.NvmHandle = 1;\r\n    }\r\n}\r\n\r\nLoRaMacStatus_t LoRaMacDeInitialization( void )\r\n{\r\n    // Check the current state of the LoRaMac\r\n    if ( LoRaMacStop( ) == LORAMAC_STATUS_OK )\r\n    {\r\n        // Stop Timers\r\n        TimerStop( &MacCtx.TxDelayedTimer );\r\n        TimerStop( &MacCtx.RxWindowTimer1 );\r\n        TimerStop( &MacCtx.RxWindowTimer2 );\r\n\r\n        // Take care about class B\r\n        LoRaMacClassBHaltBeaconing( );\r\n\r\n        // Reset Mac parameters\r\n        ResetMacParameters( false );\r\n\r\n        // Switch off Radio\r\n        Radio.Sleep( );\r\n\r\n        // Return success\r\n        return LORAMAC_STATUS_OK;\r\n    }\r\n    else\r\n    {\r\n        return LORAMAC_STATUS_BUSY;\r\n    }\r\n}\r\n"], "fixing_code": ["/*!\r\n * \\file      LoRaMac.c\r\n *\r\n * \\brief     LoRa MAC layer implementation\r\n *\r\n * \\copyright Revised BSD License, see section \\ref LICENSE.\r\n *\r\n * \\code\r\n *                ______                              _\r\n *               / _____)             _              | |\r\n *              ( (____  _____ ____ _| |_ _____  ____| |__\r\n *               \\____ \\| ___ |    (_   _) ___ |/ ___)  _ \\\r\n *               _____) ) ____| | | || |_| ____( (___| | | |\r\n *              (______/|_____)_|_|_| \\__)_____)\\____)_| |_|\r\n *              (C)2013-2017 Semtech\r\n *\r\n *               ___ _____ _   ___ _  _____ ___  ___  ___ ___\r\n *              / __|_   _/_\\ / __| |/ / __/ _ \\| _ \\/ __| __|\r\n *              \\__ \\ | |/ _ \\ (__| ' <| _| (_) |   / (__| _|\r\n *              |___/ |_/_/ \\_\\___|_|\\_\\_| \\___/|_|_\\\\___|___|\r\n *              embedded.connectivity.solutions===============\r\n *\r\n * \\endcode\r\n *\r\n * \\author    Miguel Luis ( Semtech )\r\n *\r\n * \\author    Gregory Cristian ( Semtech )\r\n *\r\n * \\author    Daniel Jaeckle ( STACKFORCE )\r\n *\r\n * \\author    Johannes Bruder ( STACKFORCE )\r\n */\r\n#include \"utilities.h\"\r\n#include \"region/Region.h\"\r\n#include \"LoRaMacClassB.h\"\r\n#include \"LoRaMacCrypto.h\"\r\n#include \"secure-element.h\"\r\n#include \"LoRaMacTest.h\"\r\n#include \"LoRaMacTypes.h\"\r\n#include \"LoRaMacConfirmQueue.h\"\r\n#include \"LoRaMacHeaderTypes.h\"\r\n#include \"LoRaMacMessageTypes.h\"\r\n#include \"LoRaMacParser.h\"\r\n#include \"LoRaMacCommands.h\"\r\n#include \"LoRaMacAdr.h\"\r\n#include \"LoRaMacSerializer.h\"\r\n#include \"radio.h\"\r\n\r\n#include \"LoRaMac.h\"\r\n\r\n/*!\r\n * Maximum PHY layer payload size\r\n */\r\n#define LORAMAC_PHY_MAXPAYLOAD                      255\r\n\r\n/*!\r\n * Maximum length of the fOpts field\r\n */\r\n#define LORA_MAC_COMMAND_MAX_FOPTS_LENGTH           15\r\n\r\n/*!\r\n * LoRaMac duty cycle for the back-off procedure during the first hour.\r\n */\r\n#define BACKOFF_DC_1_HOUR                           100\r\n\r\n/*!\r\n * LoRaMac duty cycle for the back-off procedure during the next 10 hours.\r\n */\r\n#define BACKOFF_DC_10_HOURS                         1000\r\n\r\n/*!\r\n * LoRaMac duty cycle for the back-off procedure during the next 24 hours.\r\n */\r\n#define BACKOFF_DC_24_HOURS                         10000\r\n\r\n/*!\r\n * Maximum value for the ADR ack counter\r\n */\r\n#define ADR_ACK_COUNTER_MAX                         0xFFFFFFFF\r\n\r\n/*!\r\n * LoRaMac internal states\r\n */\r\nenum eLoRaMacState\r\n{\r\n    LORAMAC_IDLE          = 0x00000000,\r\n    LORAMAC_STOPPED       = 0x00000001,\r\n    LORAMAC_TX_RUNNING    = 0x00000002,\r\n    LORAMAC_RX            = 0x00000004,\r\n    LORAMAC_ACK_RETRY     = 0x00000010,\r\n    LORAMAC_TX_DELAYED    = 0x00000020,\r\n    LORAMAC_TX_CONFIG     = 0x00000040,\r\n    LORAMAC_RX_ABORT      = 0x00000080,\r\n};\r\n\r\n/*\r\n * Request permission state\r\n */\r\ntypedef enum eLoRaMacRequestHandling\r\n{\r\n    LORAMAC_REQUEST_HANDLING_OFF = 0,\r\n    LORAMAC_REQUEST_HANDLING_ON = !LORAMAC_REQUEST_HANDLING_OFF\r\n}LoRaMacRequestHandling_t;\r\n\r\ntypedef struct sLoRaMacCtx\r\n{\r\n    /*\r\n    * Length of packet in PktBuffer\r\n    */\r\n    uint16_t PktBufferLen;\r\n    /*\r\n    * Buffer containing the data to be sent or received.\r\n    */\r\n    uint8_t PktBuffer[LORAMAC_PHY_MAXPAYLOAD];\r\n    /*!\r\n    * Current processed transmit message\r\n    */\r\n    LoRaMacMessage_t TxMsg;\r\n    /*!\r\n    * Buffer containing the data received by the application.\r\n    */\r\n    uint8_t AppData[LORAMAC_PHY_MAXPAYLOAD];\r\n    /*\r\n    * Size of buffer containing the application data.\r\n    */\r\n    uint8_t AppDataSize;\r\n    /*\r\n    * Buffer containing the upper layer data.\r\n    */\r\n    uint8_t RxPayload[LORAMAC_PHY_MAXPAYLOAD];\r\n    SysTime_t LastTxSysTime;\r\n    /*\r\n    * LoRaMac internal state\r\n    */\r\n    uint32_t MacState;\r\n    /*\r\n    * LoRaMac upper layer event functions\r\n    */\r\n    LoRaMacPrimitives_t* MacPrimitives;\r\n    /*\r\n    * LoRaMac upper layer callback functions\r\n    */\r\n    LoRaMacCallback_t* MacCallbacks;\r\n    /*\r\n    * Radio events function pointer\r\n    */\r\n    RadioEvents_t RadioEvents;\r\n    /*\r\n    * LoRaMac duty cycle delayed Tx timer\r\n    */\r\n    TimerEvent_t TxDelayedTimer;\r\n    /*\r\n    * LoRaMac reception windows timers\r\n    */\r\n    TimerEvent_t RxWindowTimer1;\r\n    TimerEvent_t RxWindowTimer2;\r\n    /*\r\n    * LoRaMac reception windows delay\r\n    * \\remark normal frame: RxWindowXDelay = ReceiveDelayX - RADIO_WAKEUP_TIME\r\n    *         join frame  : RxWindowXDelay = JoinAcceptDelayX - RADIO_WAKEUP_TIME\r\n    */\r\n    uint32_t RxWindow1Delay;\r\n    uint32_t RxWindow2Delay;\r\n    /*\r\n    * LoRaMac Rx windows configuration\r\n    */\r\n    RxConfigParams_t RxWindow1Config;\r\n    RxConfigParams_t RxWindow2Config;\r\n    RxConfigParams_t RxWindowCConfig;\r\n    /*\r\n    * Acknowledge timeout timer. Used for packet retransmissions.\r\n    */\r\n    TimerEvent_t RetransmitTimeoutTimer;\r\n    /*\r\n     * Uplink messages repetitions counter\r\n     */\r\n    uint8_t ChannelsNbTransCounter;\r\n    /*\r\n     * Indicates if the AckTimeout timer has expired or not\r\n     */\r\n    bool RetransmitTimeoutRetry;\r\n    /*\r\n     * If the node has sent a FRAME_TYPE_DATA_CONFIRMED_UP this variable indicates\r\n     * if the nodes needs to manage the server acknowledgement.\r\n     */\r\n    bool NodeAckRequested;\r\n    /*\r\n     * Current channel index\r\n     */\r\n    uint8_t Channel;\r\n    /*\r\n    * Last transmission time on air\r\n    */\r\n    TimerTime_t TxTimeOnAir;\r\n    /*\r\n    * Structure to hold an MCPS indication data.\r\n    */\r\n    McpsIndication_t McpsIndication;\r\n    /*\r\n    * Structure to hold MCPS confirm data.\r\n    */\r\n    McpsConfirm_t McpsConfirm;\r\n    /*\r\n    * Structure to hold MLME confirm data.\r\n    */\r\n    MlmeConfirm_t MlmeConfirm;\r\n    /*\r\n    * Structure to hold MLME indication data.\r\n    */\r\n    MlmeIndication_t MlmeIndication;\r\n    /*\r\n    * Holds the current rx window slot\r\n    */\r\n    LoRaMacRxSlot_t RxSlot;\r\n    /*\r\n    * LoRaMac tx/rx operation state\r\n    */\r\n    LoRaMacFlags_t MacFlags;\r\n    /*\r\n    * Data structure indicating if a request is allowed or not.\r\n    */\r\n    LoRaMacRequestHandling_t AllowRequests;\r\n    /*\r\n    * Cycle timer for Type 0 Rejoin requests\r\n    */\r\n    TimerEvent_t Rejoin0CycleTimer;\r\n    /*\r\n    * Cycle timer for Type 1 Rejoin requests\r\n    */\r\n    TimerEvent_t Rejoin1CycleTimer;\r\n    /*\r\n    * Cycle timer for Rejoin requests trigged by ForceRejoinReq MAC command\r\n    */\r\n    TimerEvent_t ForceRejoinReqCycleTimer;\r\n    /*\r\n    * Time of Type 0 Rejoin requests cycles\r\n    */\r\n    TimerTime_t Rejoin0CycleTime;\r\n    /*\r\n    * Time of Type 1 Rejoin requests cycles\r\n    */\r\n    TimerTime_t Rejoin1CycleTime;\r\n    /*\r\n    * Time of Force Rejoin requests cycles\r\n    */\r\n    TimerTime_t ForceRejonCycleTime;\r\n    /*\r\n    * Duty cycle wait time\r\n    */\r\n    TimerTime_t DutyCycleWaitTime;\r\n    /*\r\n     * Start time of the response timeout\r\n     */\r\n    TimerTime_t ResponseTimeoutStartTime;\r\n    /*\r\n     * Buffer containing the MAC layer commands\r\n     */\r\n    uint8_t MacCommandsBuffer[LORA_MAC_COMMAND_MAX_LENGTH];\r\n}LoRaMacCtx_t;\r\n\r\n/*\r\n * Module context.\r\n */\r\nstatic LoRaMacCtx_t MacCtx;\r\n\r\nstatic LoRaMacNvmData_t Nvm;\r\n\r\nstatic Band_t RegionBands[REGION_NVM_MAX_NB_BANDS];\r\n\r\n/*!\r\n * Defines the LoRaMac radio events status\r\n */\r\ntypedef union uLoRaMacRadioEvents\r\n{\r\n    uint32_t Value;\r\n    struct sEvents\r\n    {\r\n        uint32_t RxProcessPending : 1;\r\n        uint32_t RxTimeout        : 1;\r\n        uint32_t RxError          : 1;\r\n        uint32_t TxTimeout        : 1;\r\n        uint32_t RxDone           : 1;\r\n        uint32_t TxDone           : 1;\r\n    }Events;\r\n}LoRaMacRadioEvents_t;\r\n\r\n/*!\r\n * LoRaMac radio events status\r\n */\r\nLoRaMacRadioEvents_t LoRaMacRadioEvents = { .Value = 0 };\r\n\r\n/*!\r\n * \\brief Function to be executed on Radio Tx Done event\r\n */\r\nstatic void OnRadioTxDone( void );\r\n\r\n/*!\r\n * \\brief This function prepares the MAC to abort the execution of function\r\n *        OnRadioRxDone in case of a reception error.\r\n */\r\nstatic void PrepareRxDoneAbort( void );\r\n\r\n/*!\r\n * \\brief Function to be executed on Radio Rx Done event\r\n */\r\nstatic void OnRadioRxDone( uint8_t* payload, uint16_t size, int16_t rssi, int8_t snr );\r\n\r\n/*!\r\n * \\brief Function executed on Radio Tx Timeout event\r\n */\r\nstatic void OnRadioTxTimeout( void );\r\n\r\n/*!\r\n * \\brief Function executed on Radio Rx error event\r\n */\r\nstatic void OnRadioRxError( void );\r\n\r\n/*!\r\n * \\brief Function executed on Radio Rx Timeout event\r\n */\r\nstatic void OnRadioRxTimeout( void );\r\n\r\n/*!\r\n * \\brief Function executed on duty cycle delayed Tx  timer event\r\n */\r\nstatic void OnTxDelayedTimerEvent( void* context );\r\n\r\n/*!\r\n * \\brief Function executed on first Rx window timer event\r\n */\r\nstatic void OnRxWindow1TimerEvent( void* context );\r\n\r\n/*!\r\n * \\brief Function executed on second Rx window timer event\r\n */\r\nstatic void OnRxWindow2TimerEvent( void* context );\r\n\r\n/*!\r\n * \\brief Function executed on Rejoin Type 0 cycle timer event\r\n */\r\nstatic void OnRejoin0CycleTimerEvent( void* context );\r\n\r\n/*!\r\n * \\brief Function executed on Rejoin Type 0 cycle timer event\r\n */\r\nstatic void OnRejoin1CycleTimerEvent( void* context );\r\n\r\n/*!\r\n * \\brief Function executed on Rejoin Type 0 or 2 cycle timer event\r\n *        which was requested by a ForceRejoinReq MAC command.\r\n */\r\nstatic void OnForceRejoinReqCycleTimerEvent( void* context );\r\n\r\n/*!\r\n * \\brief Function executed on AckTimeout timer event\r\n */\r\nstatic void OnRetransmitTimeoutTimerEvent( void* context );\r\n\r\n/*!\r\n * Computes next 32 bit downlink counter value and determines the frame counter ID.\r\n *\r\n * \\param[IN]     addrID                - Address identifier\r\n * \\param[IN]     fType                 - Frame type\r\n * \\param[IN]     macMsg                - Data message object, holding the current 16 bit transmitted frame counter\r\n * \\param[IN]     lrWanVersion          - LoRaWAN version\r\n * \\param[OUT]    fCntID                - Frame counter identifier\r\n * \\param[OUT]    currentDown           - Current downlink counter value\r\n *\r\n * \\retval                              - Status of the operation\r\n */\r\nstatic LoRaMacCryptoStatus_t GetFCntDown( AddressIdentifier_t addrID, FType_t fType, LoRaMacMessageData_t* macMsg, Version_t lrWanVersion,\r\n                                          FCntIdentifier_t* fCntID, uint32_t* currentDown );\r\n\r\n/*!\r\n * \\brief Switches the device class\r\n *\r\n * \\param [IN] deviceClass Device class to switch to\r\n */\r\nstatic LoRaMacStatus_t SwitchClass( DeviceClass_t deviceClass );\r\n\r\n/*!\r\n * \\brief Gets the maximum application payload length in the absence of the optional FOpt field.\r\n *\r\n * \\param [IN] datarate        Current datarate\r\n *\r\n * \\retval                    Max length\r\n */\r\nstatic uint8_t GetMaxAppPayloadWithoutFOptsLength( int8_t datarate );\r\n\r\n/*!\r\n * \\brief Validates if the payload fits into the frame, taking the datarate\r\n *        into account.\r\n *\r\n * \\details Refer to chapter 4.3.2 of the LoRaWAN specification, v1.0\r\n *\r\n * \\param lenN Length of the application payload. The length depends on the\r\n *             datarate and is region specific\r\n *\r\n * \\param datarate Current datarate\r\n *\r\n * \\param fOptsLen Length of the fOpts field\r\n *\r\n * \\retval [false: payload does not fit into the frame, true: payload fits into\r\n *          the frame]\r\n */\r\nstatic bool ValidatePayloadLength( uint8_t lenN, int8_t datarate, uint8_t fOptsLen );\r\n\r\n/*!\r\n * \\brief Decodes MAC commands in the fOpts field and in the payload\r\n *\r\n * \\param [IN] payload      A pointer to the payload\r\n * \\param [IN] macIndex     The index of the payload where the MAC commands start\r\n * \\param [IN] commandsSize The size of the MAC commands\r\n * \\param [IN] snr          The SNR value  of the frame\r\n * \\param [IN] rxSlot       The RX slot where the frame was received\r\n */\r\nstatic void ProcessMacCommands( uint8_t* payload, uint8_t macIndex, uint8_t commandsSize, int8_t snr, LoRaMacRxSlot_t rxSlot );\r\n\r\n/*!\r\n * \\brief LoRaMAC layer generic send frame\r\n *\r\n * \\param [IN] macHdr      MAC header field\r\n * \\param [IN] fPort       MAC payload port\r\n * \\param [IN] fBuffer     MAC data buffer to be sent\r\n * \\param [IN] fBufferSize MAC data buffer size\r\n * \\retval status          Status of the operation.\r\n */\r\nLoRaMacStatus_t Send( LoRaMacHeader_t* macHdr, uint8_t fPort, void* fBuffer, uint16_t fBufferSize );\r\n\r\n/*!\r\n * \\brief LoRaMAC layer send join/rejoin request\r\n *\r\n * \\param [IN] joinReqType Type of join-request or rejoin\r\n *\r\n * \\retval status          Status of the operation.\r\n */\r\nLoRaMacStatus_t SendReJoinReq( JoinReqIdentifier_t joinReqType );\r\n\r\n/*!\r\n * \\brief LoRaMAC layer frame buffer initialization\r\n *\r\n * \\param [IN] macHdr      MAC header field\r\n * \\param [IN] fCtrl       MAC frame control field\r\n * \\param [IN] fOpts       MAC commands buffer\r\n * \\param [IN] fPort       MAC payload port\r\n * \\param [IN] fBuffer     MAC data buffer to be sent\r\n * \\param [IN] fBufferSize MAC data buffer size\r\n * \\retval status          Status of the operation.\r\n */\r\nLoRaMacStatus_t PrepareFrame( LoRaMacHeader_t* macHdr, LoRaMacFrameCtrl_t* fCtrl, uint8_t fPort, void* fBuffer, uint16_t fBufferSize );\r\n\r\n/*\r\n * \\brief Schedules the frame according to the duty cycle\r\n *\r\n * \\param [IN] allowDelayedTx When set to true, the a frame will be delayed,\r\n *                            the duty cycle restriction is active\r\n * \\retval Status of the operation\r\n */\r\nstatic LoRaMacStatus_t ScheduleTx( bool allowDelayedTx );\r\n\r\n/*\r\n * \\brief Secures the current processed frame ( TxMsg )\r\n * \\param[IN]     txDr      Data rate used for the transmission\r\n * \\param[IN]     txCh      Index of the channel used for the transmission\r\n * \\retval status           Status of the operation\r\n */\r\nstatic LoRaMacStatus_t SecureFrame( uint8_t txDr, uint8_t txCh );\r\n\r\n/*\r\n * \\brief Calculates the aggregated back off time.\r\n */\r\nstatic void CalculateBackOff( void );\r\n\r\n/*\r\n * \\brief Function to remove pending MAC commands\r\n *\r\n * \\param [IN] rxSlot     The RX slot on which the frame was received\r\n * \\param [IN] fCtrl      The frame control field of the received frame\r\n * \\param [IN] request    The request type\r\n */\r\nstatic void RemoveMacCommands( LoRaMacRxSlot_t rxSlot, LoRaMacFrameCtrl_t fCtrl, Mcps_t request );\r\n\r\n/*!\r\n * \\brief LoRaMAC layer prepared frame buffer transmission with channel specification\r\n *\r\n * \\remark PrepareFrame must be called at least once before calling this\r\n *         function.\r\n *\r\n * \\param [IN] channel     Channel to transmit on\r\n * \\retval status          Status of the operation.\r\n */\r\nLoRaMacStatus_t SendFrameOnChannel( uint8_t channel );\r\n\r\n/*!\r\n * \\brief Sets the radio in continuous transmission mode\r\n *\r\n * \\remark Uses the radio parameters set on the previous transmission.\r\n *\r\n * \\param [IN] timeout     Time in seconds while the radio is kept in continuous wave mode\r\n * \\param [IN] frequency   RF frequency to be set.\r\n * \\param [IN] power       RF output power to be set.\r\n * \\retval status          Status of the operation.\r\n */\r\nLoRaMacStatus_t SetTxContinuousWave( uint16_t timeout, uint32_t frequency, uint8_t power );\r\n\r\n/*!\r\n * \\brief Converts a second based Rejoin Cycle base in the from timer module required format.\r\n *\r\n * \\param [IN]  rejoinCycleTime     The time in second\r\n * \\param [out] timeInMiliSec       The time in second\r\n * \\retval status          Status of the operation.\r\n */\r\nstatic bool ConvertRejoinCycleTime( uint32_t rejoinCycleTime, uint32_t* timeInMiliSec );\r\n\r\n/*!\r\n * \\brief Resets MAC specific parameters to default\r\n *\r\n * \\param [in] isRejoin             Reset activation or not.\r\n */\r\nstatic void ResetMacParameters( bool isRejoin );\r\n\r\n/*!\r\n * \\brief Checks if it's required to send a Rejoin (Type 0) request.\r\n *\r\n * \\retval [false: Rejoin not required, true: Rejoin required]\r\n */\r\nstatic bool IsReJoin0Required( void );\r\n\r\n/*!\r\n * \\brief Initializes and opens the reception window\r\n *\r\n * \\param [IN] rxTimer  Window timer to be topped.\r\n * \\param [IN] rxConfig Window parameters to be setup\r\n */\r\nstatic void RxWindowSetup( TimerEvent_t* rxTimer, RxConfigParams_t* rxConfig );\r\n\r\n/*!\r\n * \\brief Opens up a continuous RX C window. This is used for\r\n *        class c devices.\r\n */\r\nstatic void OpenContinuousRxCWindow( void );\r\n\r\n/*!\r\n * \\brief   Returns a pointer to the internal contexts structure.\r\n *\r\n * \\retval  void Points to a structure containing all contexts\r\n */\r\nstatic LoRaMacNvmData_t* GetNvmData( void );\r\n\r\n/*!\r\n * \\brief   Restoring of internal module contexts\r\n *\r\n * \\details This function allows to restore module contexts by a given pointer.\r\n *\r\n *\r\n * \\retval  LoRaMacStatus_t Status of the operation. Possible returns are:\r\n *          returns are:\r\n *          \\ref LORAMAC_STATUS_OK,\r\n *          \\ref LORAMAC_STATUS_PARAMETER_INVALID,\r\n */\r\nstatic LoRaMacStatus_t RestoreNvmData( LoRaMacNvmData_t* contexts );\r\n\r\n/*!\r\n * \\brief   Determines the frame type\r\n *\r\n * \\param [IN] macMsg Data message object\r\n *\r\n * \\param [OUT] fType Frame type\r\n *\r\n * \\retval  LoRaMacStatus_t Status of the operation. Possible returns are:\r\n *          returns are:\r\n *          \\ref LORAMAC_STATUS_OK,\r\n *          \\ref LORAMAC_STATUS_PARAMETER_INVALID,\r\n */\r\nLoRaMacStatus_t DetermineFrameType( LoRaMacMessageData_t* macMsg, FType_t* fType );\r\n\r\n/*!\r\n * \\brief Verifies, if the retransmission counter has reached the limit\r\n *\r\n * \\param [IN] counter Current retransmission counter\r\n * \\param [IN] limit Retransmission counter limit\r\n *\r\n * \\retval Returns true if the number of retransmissions have reached the limit.\r\n */\r\nstatic bool CheckRetrans( uint8_t counter, uint8_t limit );\r\n\r\n/*!\r\n * \\brief Checks if the retransmission should be stopped in case of a unconfirmed uplink\r\n *\r\n * \\retval Returns true if it should be stopped.\r\n */\r\nstatic bool CheckRetransUnconfirmedUplink( void );\r\n\r\n/*!\r\n * \\brief Checks if the retransmission should be stopped in case of a confirmed uplink\r\n *\r\n * \\retval Returns true it should be stopped.\r\n */\r\nstatic bool CheckRetransConfirmedUplink( void );\r\n\r\n/*!\r\n * \\brief Increases the ADR ack counter. Takes the maximum\r\n *        value into account.\r\n *\r\n * \\param [IN] counter Current counter value.\r\n *\r\n * \\retval Returns the next counter value.\r\n */\r\nstatic uint32_t IncreaseAdrAckCounter( uint32_t counter );\r\n\r\n/*!\r\n * \\brief Stops the uplink retransmission\r\n *\r\n * \\retval Returns true if successful.\r\n */\r\nstatic bool StopRetransmission( void );\r\n\r\n/*!\r\n * \\brief Calls the callback to indicate that a context changed\r\n */\r\nstatic void CallNvmDataChangeCallback( uint16_t notifyFlags );\r\n\r\n/*!\r\n * \\brief Verifies if a request is pending currently\r\n *\r\n * \\retval 1: Request pending, 0: request not pending\r\n */\r\nstatic uint8_t IsRequestPending( void );\r\n\r\n/*!\r\n * \\brief Enabled the possibility to perform requests\r\n *\r\n * \\param [IN] requestState Request permission state\r\n */\r\nstatic void LoRaMacEnableRequests( LoRaMacRequestHandling_t requestState );\r\n\r\n/*!\r\n * \\brief This function verifies if a RX abort occurred\r\n */\r\nstatic void LoRaMacCheckForRxAbort( void );\r\n\r\n/*!\r\n * \\brief This function verifies if a beacon acquisition MLME\r\n *        request was pending\r\n *\r\n * \\retval 1: Request pending, 0: no request pending\r\n */\r\nstatic uint8_t LoRaMacCheckForBeaconAcquisition( void );\r\n\r\n/*!\r\n * \\brief Returns true, if the device must apply the minium datarate\r\n *\r\n * \\param [IN] adr ADR status bit\r\n *\r\n * \\param [IN] activation Activation type of the device\r\n *\r\n * \\param [IN] datarateChanged Set to true, if the datarate was changed\r\n *                             with the LinkAdrReq.\r\n */\r\nstatic bool CheckForMinimumAbpDatarate( bool adr, ActivationType_t activation, bool datarateChanged );\r\n\r\n/*!\r\n * \\brief This function handles join request\r\n */\r\nstatic void LoRaMacHandleMlmeRequest( void );\r\n\r\n/*!\r\n * \\brief This function handles mcps request\r\n */\r\nstatic void LoRaMacHandleMcpsRequest( void );\r\n\r\n/*!\r\n * \\brief This function handles callback events for requests\r\n */\r\nstatic void LoRaMacHandleRequestEvents( void );\r\n\r\n/*!\r\n * \\brief This function handles callback events for indications\r\n */\r\nstatic void LoRaMacHandleIndicationEvents( void );\r\n\r\n/*!\r\n * \\brief This function handles events for re-join procedure\r\n */\r\nstatic void LoRaMacHandleRejoinEvents( void );\r\n\r\n/*!\r\n * \\brief This function handles callback events for NVM updates\r\n *\r\n * \\param [IN] nvmData Data structure containing NVM data.\r\n */\r\nstatic void LoRaMacHandleNvm( LoRaMacNvmData_t* nvmData );\r\n\r\n/*!\r\n * \\brief This function verifies if the response timeout has been elapsed. If\r\n *        this is the case, the status of Nvm.MacGroup1.SrvAckRequested will be\r\n *        reset.\r\n *\r\n * \\param [IN] timeoutInMs Timeout [ms] to be compared.\r\n *\r\n * \\param [IN] startTimeInMs Start time [ms] used as a base. If set to 0,\r\n *                           no comparison will be done.\r\n *\r\n * \\retval true: Response timeout has been elapsed, false: Response timeout\r\n *         has not been elapsed or startTimeInMs is 0.\r\n */\r\nstatic bool LoRaMacHandleResponseTimeout( TimerTime_t timeoutInMs, TimerTime_t startTimeInMs );\r\n\r\n/*!\r\n * Structure used to store the radio Tx event data\r\n */\r\nstruct\r\n{\r\n    TimerTime_t CurTime;\r\n}TxDoneParams;\r\n\r\n/*!\r\n * Structure used to store the radio Rx event data\r\n */\r\nstruct\r\n{\r\n    TimerTime_t LastRxDone;\r\n    uint8_t *Payload;\r\n    uint16_t Size;\r\n    int16_t Rssi;\r\n    int8_t Snr;\r\n}RxDoneParams;\r\n\r\nstatic void OnRadioTxDone( void )\r\n{\r\n    TxDoneParams.CurTime = TimerGetCurrentTime( );\r\n    MacCtx.LastTxSysTime = SysTimeGet( );\r\n\r\n    LoRaMacRadioEvents.Events.TxDone = 1;\r\n\r\n    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )\r\n    {\r\n        MacCtx.MacCallbacks->MacProcessNotify( );\r\n    }\r\n}\r\n\r\nstatic void OnRadioRxDone( uint8_t *payload, uint16_t size, int16_t rssi, int8_t snr )\r\n{\r\n    RxDoneParams.LastRxDone = TimerGetCurrentTime( );\r\n    RxDoneParams.Payload = payload;\r\n    RxDoneParams.Size = size;\r\n    RxDoneParams.Rssi = rssi;\r\n    RxDoneParams.Snr = snr;\r\n\r\n    LoRaMacRadioEvents.Events.RxDone = 1;\r\n    LoRaMacRadioEvents.Events.RxProcessPending = 1;\r\n\r\n    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )\r\n    {\r\n        MacCtx.MacCallbacks->MacProcessNotify( );\r\n    }\r\n}\r\n\r\nstatic void OnRadioTxTimeout( void )\r\n{\r\n    LoRaMacRadioEvents.Events.TxTimeout = 1;\r\n\r\n    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )\r\n    {\r\n        MacCtx.MacCallbacks->MacProcessNotify( );\r\n    }\r\n}\r\n\r\nstatic void OnRadioRxError( void )\r\n{\r\n    LoRaMacRadioEvents.Events.RxError = 1;\r\n\r\n    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )\r\n    {\r\n        MacCtx.MacCallbacks->MacProcessNotify( );\r\n    }\r\n}\r\n\r\nstatic void OnRadioRxTimeout( void )\r\n{\r\n    LoRaMacRadioEvents.Events.RxTimeout = 1;\r\n\r\n    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )\r\n    {\r\n        MacCtx.MacCallbacks->MacProcessNotify( );\r\n    }\r\n}\r\n\r\nstatic void UpdateRxSlotIdleState( void )\r\n{\r\n    if( Nvm.MacGroup2.DeviceClass != CLASS_C )\r\n    {\r\n        MacCtx.RxSlot = RX_SLOT_NONE;\r\n    }\r\n    else\r\n    {\r\n        MacCtx.RxSlot = RX_SLOT_WIN_CLASS_C;\r\n    }\r\n}\r\n\r\nstatic void ProcessRadioTxDone( void )\r\n{\r\n    GetPhyParams_t getPhy;\r\n    PhyParam_t phyParam;\r\n    SetBandTxDoneParams_t txDone;\r\n\r\n    if( Nvm.MacGroup2.DeviceClass != CLASS_C )\r\n    {\r\n        Radio.Sleep( );\r\n    }\r\n\r\n    // Setup timers\r\n    CRITICAL_SECTION_BEGIN( );\r\n    uint32_t offset = TimerGetCurrentTime( ) - TxDoneParams.CurTime;\r\n    TimerSetValue( &MacCtx.RxWindowTimer1, MacCtx.RxWindow1Delay - offset );\r\n    TimerStart( &MacCtx.RxWindowTimer1 );\r\n    TimerSetValue( &MacCtx.RxWindowTimer2, MacCtx.RxWindow2Delay - offset );\r\n    TimerStart( &MacCtx.RxWindowTimer2 );\r\n    CRITICAL_SECTION_END( );\r\n\r\n    if( MacCtx.NodeAckRequested == true )\r\n    {\r\n        getPhy.Attribute = PHY_RETRANSMIT_TIMEOUT;\r\n        phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );\r\n        TimerSetValue( &MacCtx.RetransmitTimeoutTimer, MacCtx.RxWindow2Delay + phyParam.Value );\r\n        TimerStart( &MacCtx.RetransmitTimeoutTimer );\r\n    }\r\n    else\r\n    {\r\n        // Transmission successful, setup status directly\r\n        MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_OK;\r\n    }\r\n\r\n    // Update Aggregated last tx done time\r\n    Nvm.MacGroup1.LastTxDoneTime = TxDoneParams.CurTime;\r\n\r\n    // Update last tx done time for the current channel\r\n    txDone.Channel = MacCtx.Channel;\r\n    txDone.LastTxDoneTime = TxDoneParams.CurTime;\r\n    txDone.ElapsedTimeSinceStartUp = SysTimeSub( SysTimeGetMcuTime( ), Nvm.MacGroup2.InitializationTime );\r\n    txDone.LastTxAirTime = MacCtx.TxTimeOnAir;\r\n    txDone.Joined  = true;\r\n    if( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_NONE )\r\n    {\r\n        txDone.Joined  = false;\r\n    }\r\n\r\n    RegionSetBandTxDone( Nvm.MacGroup2.Region, &txDone );\r\n}\r\n\r\nstatic void PrepareRxDoneAbort( void )\r\n{\r\n    MacCtx.MacState |= LORAMAC_RX_ABORT;\r\n\r\n    if( MacCtx.NodeAckRequested == true )\r\n    {\r\n        OnRetransmitTimeoutTimerEvent( NULL );\r\n    }\r\n\r\n    MacCtx.MacFlags.Bits.McpsInd = 1;\r\n    MacCtx.MacFlags.Bits.MacDone = 1;\r\n\r\n    UpdateRxSlotIdleState( );\r\n}\r\n\r\nstatic void ProcessRadioRxDone( void )\r\n{\r\n    LoRaMacHeader_t macHdr;\r\n    ApplyCFListParams_t applyCFList;\r\n    GetPhyParams_t getPhy;\r\n    PhyParam_t phyParam;\r\n    LoRaMacCryptoStatus_t macCryptoStatus = LORAMAC_CRYPTO_ERROR;\r\n\r\n    LoRaMacMessageData_t macMsgData;\r\n    LoRaMacMessageJoinAccept_t macMsgJoinAccept;\r\n    uint8_t *payload = RxDoneParams.Payload;\r\n    uint16_t size = RxDoneParams.Size;\r\n    int16_t rssi = RxDoneParams.Rssi;\r\n    int8_t snr = RxDoneParams.Snr;\r\n\r\n    uint8_t pktHeaderLen = 0;\r\n\r\n    uint32_t downLinkCounter = 0;\r\n    uint32_t address = Nvm.MacGroup2.DevAddr;\r\n    uint8_t multicast = 0;\r\n    AddressIdentifier_t addrID = UNICAST_DEV_ADDR;\r\n    FCntIdentifier_t fCntID;\r\n    uint8_t macCmdPayload[2] = { 0 };\r\n    Mlme_t joinType = MLME_JOIN;\r\n\r\n    LoRaMacRadioEvents.Events.RxProcessPending = 0;\r\n\r\n    MacCtx.McpsConfirm.AckReceived = false;\r\n    MacCtx.McpsIndication.Rssi = rssi;\r\n    MacCtx.McpsIndication.Snr = snr;\r\n    MacCtx.McpsIndication.RxSlot = MacCtx.RxSlot;\r\n    MacCtx.McpsIndication.Port = 0;\r\n    MacCtx.McpsIndication.Multicast = 0;\r\n    MacCtx.McpsIndication.IsUplinkTxPending = 0;\r\n    MacCtx.McpsIndication.Buffer = NULL;\r\n    MacCtx.McpsIndication.BufferSize = 0;\r\n    MacCtx.McpsIndication.RxData = false;\r\n    MacCtx.McpsIndication.AckReceived = false;\r\n    MacCtx.McpsIndication.DownLinkCounter = 0;\r\n    MacCtx.McpsIndication.McpsIndication = MCPS_UNCONFIRMED;\r\n    MacCtx.McpsIndication.DevAddress = 0;\r\n    MacCtx.McpsIndication.DeviceTimeAnsReceived = false;\r\n    MacCtx.McpsIndication.ResponseTimeout = 0;\r\n\r\n    Radio.Sleep( );\r\n\r\n    if( MacCtx.McpsIndication.RxSlot == RX_SLOT_WIN_1 )\r\n    {\r\n        TimerStop( &MacCtx.RxWindowTimer2 );\r\n    }\r\n\r\n    // This function must be called even if we are not in class b mode yet.\r\n    if( LoRaMacClassBRxBeacon( payload, size ) == true )\r\n    {\r\n        MacCtx.MlmeIndication.BeaconInfo.Rssi = rssi;\r\n        MacCtx.MlmeIndication.BeaconInfo.Snr = snr;\r\n        return;\r\n    }\r\n    // Check if we expect a ping or a multicast slot.\r\n    if( Nvm.MacGroup2.DeviceClass == CLASS_B )\r\n    {\r\n        if( LoRaMacClassBIsPingExpected( ) == true )\r\n        {\r\n            LoRaMacClassBSetPingSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );\r\n            LoRaMacClassBPingSlotTimerEvent( NULL );\r\n            MacCtx.McpsIndication.RxSlot = RX_SLOT_WIN_CLASS_B_PING_SLOT;\r\n        }\r\n        else if( LoRaMacClassBIsMulticastExpected( ) == true )\r\n        {\r\n            LoRaMacClassBSetMulticastSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );\r\n            LoRaMacClassBMulticastSlotTimerEvent( NULL );\r\n            MacCtx.McpsIndication.RxSlot = RX_SLOT_WIN_CLASS_B_MULTICAST_SLOT;\r\n        }\r\n    }\r\n\r\n    // Abort on empty radio frames\r\n    if( size == 0 )\r\n    {\r\n        MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\r\n        PrepareRxDoneAbort( );\r\n        return;\r\n    }\r\n\r\n    macHdr.Value = payload[pktHeaderLen++];\r\n\r\n    // Accept frames of LoRaWAN Major Version 1 only\r\n    if( macHdr.Bits.Major != 0 )\r\n    {\r\n        MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\r\n        PrepareRxDoneAbort( );\r\n        return;\r\n    }\r\n\r\n    switch( macHdr.Bits.MType )\r\n    {\r\n        case FRAME_TYPE_JOIN_ACCEPT:\r\n        {\r\n            // Check if the received frame size is valid\r\n            if( size < LORAMAC_JOIN_ACCEPT_FRAME_MIN_SIZE )\r\n            {\r\n                MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\r\n                PrepareRxDoneAbort( );\r\n                return;\r\n            }\r\n            macMsgJoinAccept.Buffer = payload;\r\n            macMsgJoinAccept.BufSize = size;\r\n\r\n            // Abort in case if the device is already joined and no rejoin request is ongoing.\r\n            if( ( Nvm.MacGroup2.NetworkActivation != ACTIVATION_TYPE_NONE ) && ( Nvm.MacGroup2.IsRejoinAcceptPending == false ) )\r\n            {\r\n                MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\r\n                PrepareRxDoneAbort( );\r\n                return;\r\n            }\r\n            macCryptoStatus = LoRaMacCryptoHandleJoinAccept( JOIN_REQ, SecureElementGetJoinEui( ), &macMsgJoinAccept );\r\n\r\n            if( LORAMAC_CRYPTO_SUCCESS != macCryptoStatus )\r\n            {\r\n                macCryptoStatus = LoRaMacCryptoHandleJoinAccept( REJOIN_REQ_0, SecureElementGetJoinEui( ), &macMsgJoinAccept );\r\n                joinType = MLME_REJOIN_0;\r\n            }\r\n\r\n            if( LORAMAC_CRYPTO_SUCCESS != macCryptoStatus )\r\n            {\r\n                macCryptoStatus = LoRaMacCryptoHandleJoinAccept( REJOIN_REQ_1, SecureElementGetJoinEui( ), &macMsgJoinAccept );\r\n                joinType = MLME_REJOIN_1;\r\n            }\r\n\r\n            if( LORAMAC_CRYPTO_SUCCESS != macCryptoStatus )\r\n            {\r\n                macCryptoStatus = LoRaMacCryptoHandleJoinAccept( REJOIN_REQ_2, SecureElementGetJoinEui( ), &macMsgJoinAccept );\r\n                joinType = MLME_REJOIN_2;\r\n            }\r\n\r\n            VerifyParams_t verifyRxDr;\r\n            bool rxDrValid = false;\r\n            verifyRxDr.DatarateParams.Datarate = macMsgJoinAccept.DLSettings.Bits.RX2DataRate;\r\n            verifyRxDr.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;\r\n            rxDrValid = RegionVerify( Nvm.MacGroup2.Region, &verifyRxDr, PHY_RX_DR );\r\n\r\n            if( ( LORAMAC_CRYPTO_SUCCESS == macCryptoStatus ) && ( rxDrValid == true ) )\r\n            {\r\n                // Network ID\r\n                Nvm.MacGroup2.NetID = ( uint32_t ) macMsgJoinAccept.NetID[0];\r\n                Nvm.MacGroup2.NetID |= ( ( uint32_t ) macMsgJoinAccept.NetID[1] << 8 );\r\n                Nvm.MacGroup2.NetID |= ( ( uint32_t ) macMsgJoinAccept.NetID[2] << 16 );\r\n\r\n                // Device Address\r\n                Nvm.MacGroup2.DevAddr = macMsgJoinAccept.DevAddr;\r\n\r\n                // DLSettings\r\n                Nvm.MacGroup2.MacParams.Rx1DrOffset = macMsgJoinAccept.DLSettings.Bits.RX1DRoffset;\r\n                Nvm.MacGroup2.MacParams.Rx2Channel.Datarate = macMsgJoinAccept.DLSettings.Bits.RX2DataRate;\r\n                Nvm.MacGroup2.MacParams.RxCChannel.Datarate = macMsgJoinAccept.DLSettings.Bits.RX2DataRate;\r\n\r\n                // RxDelay\r\n                Nvm.MacGroup2.MacParams.ReceiveDelay1 = macMsgJoinAccept.RxDelay;\r\n                if( Nvm.MacGroup2.MacParams.ReceiveDelay1 == 0 )\r\n                {\r\n                    Nvm.MacGroup2.MacParams.ReceiveDelay1 = 1;\r\n                }\r\n                Nvm.MacGroup2.MacParams.ReceiveDelay1 *= 1000;\r\n                Nvm.MacGroup2.MacParams.ReceiveDelay2 = Nvm.MacGroup2.MacParams.ReceiveDelay1 + 1000;\r\n\r\n                // Reset NbTrans to default value\r\n                Nvm.MacGroup2.MacParams.ChannelsNbTrans = 1;\r\n\r\n                // Is Networkserver's LoRaWAN Version before 1.1.0 ?\r\n                if( macMsgJoinAccept.DLSettings.Bits.OptNeg == 0 )\r\n                {\r\n                    Nvm.MacGroup2.Version.Value = LORAMAC_FALLBACK_VERSION;\r\n                }\r\n                else\r\n                {\r\n                    Nvm.MacGroup2.Version.Value = LORAMAC_VERSION;\r\n                }\r\n\r\n                // Apply CF list\r\n                applyCFList.Payload = macMsgJoinAccept.CFList;\r\n                // Size of the regular payload is 12. Plus 1 byte MHDR and 4 bytes MIC\r\n                applyCFList.Size = size - 17;\r\n                // Apply the last tx channel\r\n                applyCFList.JoinChannel = MacCtx.Channel;\r\n\r\n                RegionApplyCFList( Nvm.MacGroup2.Region, &applyCFList );\r\n\r\n                Nvm.MacGroup2.NetworkActivation = ACTIVATION_TYPE_OTAA;\r\n\r\n                // Add a RekeyInd MAC command to confirm the security key update.\r\n                if( Nvm.MacGroup2.Version.Fields.Minor >= 1 )\r\n                {\r\n                    Nvm.MacGroup1.RekeyIndUplinksCounter = 0;\r\n                    macCmdPayload[0] = Nvm.MacGroup2.Version.Fields.Minor;\r\n                    LoRaMacCommandsAddCmd( MOTE_MAC_REKEY_IND, macCmdPayload, 1 );\r\n                }\r\n\r\n                // MLME handling\r\n                if( LoRaMacConfirmQueueIsCmdActive( joinType ) == true )\r\n                {\r\n                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, joinType );\r\n                }\r\n\r\n                // Rejoin handling\r\n                if( Nvm.MacGroup2.IsRejoinAcceptPending == true )\r\n                {\r\n                    Nvm.MacGroup2.IsRejoinAcceptPending = false;\r\n\r\n                    // Stop in any case the ForceRejoinReqCycleTimer\r\n                    TimerStop( &MacCtx.ForceRejoinReqCycleTimer );\r\n                }\r\n\r\n                // Reset MAC parameters for specific re-join types\r\n                if( ( joinType == MLME_REJOIN_0 ) || ( joinType == MLME_REJOIN_1 ) )\r\n                {\r\n                    ResetMacParameters( true );\r\n                }\r\n            }\r\n            else\r\n            {\r\n                // MLME handling\r\n                if( LoRaMacConfirmQueueIsCmdActive( MLME_JOIN ) == true )\r\n                {\r\n                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_JOIN_FAIL, MLME_JOIN );\r\n                }\r\n            }\r\n            break;\r\n        }\r\n        case FRAME_TYPE_DATA_CONFIRMED_DOWN:\r\n            MacCtx.McpsIndication.McpsIndication = MCPS_CONFIRMED;\r\n            // Intentional fall through\r\n        case FRAME_TYPE_DATA_UNCONFIRMED_DOWN:\r\n            // Check if the received payload size is valid\r\n            getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;\r\n            getPhy.Datarate = MacCtx.McpsIndication.RxDatarate;\r\n            getPhy.Attribute = PHY_MAX_PAYLOAD;\r\n            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );\r\n            if( ( MAX( 0, ( int16_t )( ( int16_t ) size - ( int16_t ) LORAMAC_FRAME_PAYLOAD_OVERHEAD_SIZE ) ) > ( int16_t )phyParam.Value ) ||\r\n                ( size < LORAMAC_FRAME_PAYLOAD_MIN_SIZE ) )\r\n            {\r\n                MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\r\n                PrepareRxDoneAbort( );\r\n                return;\r\n            }\r\n            macMsgData.Buffer = payload;\r\n            macMsgData.BufSize = size;\r\n            macMsgData.FRMPayload = MacCtx.RxPayload;\r\n            macMsgData.FRMPayloadSize = LORAMAC_PHY_MAXPAYLOAD;\r\n\r\n            if( LORAMAC_PARSER_SUCCESS != LoRaMacParserData( &macMsgData ) )\r\n            {\r\n                MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\r\n                PrepareRxDoneAbort( );\r\n                return;\r\n            }\r\n\r\n            // Handle Class B\r\n            // Check if we expect a ping or a multicast slot.\r\n            if( Nvm.MacGroup2.DeviceClass == CLASS_B )\r\n            {\r\n                if( LoRaMacClassBIsPingExpected( ) == true )\r\n                {\r\n                    LoRaMacClassBSetPingSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );\r\n                    LoRaMacClassBPingSlotTimerEvent( NULL );\r\n                    MacCtx.McpsIndication.RxSlot = RX_SLOT_WIN_CLASS_B_PING_SLOT;\r\n                    LoRaMacClassBSetFPendingBit( macMsgData.FHDR.DevAddr, ( uint8_t ) macMsgData.FHDR.FCtrl.Bits.FPending );\r\n                }\r\n                else if( LoRaMacClassBIsMulticastExpected( ) == true )\r\n                {\r\n                    LoRaMacClassBSetMulticastSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );\r\n                    LoRaMacClassBMulticastSlotTimerEvent( NULL );\r\n                    MacCtx.McpsIndication.RxSlot = RX_SLOT_WIN_CLASS_B_MULTICAST_SLOT;\r\n                    LoRaMacClassBSetFPendingBit( macMsgData.FHDR.DevAddr, ( uint8_t ) macMsgData.FHDR.FCtrl.Bits.FPending );\r\n                }\r\n            }\r\n\r\n            // Store device address\r\n            MacCtx.McpsIndication.DevAddress = macMsgData.FHDR.DevAddr;\r\n\r\n            FType_t fType;\r\n            if( LORAMAC_STATUS_OK != DetermineFrameType( &macMsgData, &fType ) )\r\n            {\r\n                MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\r\n                PrepareRxDoneAbort( );\r\n                return;\r\n            }\r\n\r\n            //Check if it is a multicast message\r\n            multicast = 0;\r\n            downLinkCounter = 0;\r\n            for( uint8_t i = 0; i < LORAMAC_MAX_MC_CTX; i++ )\r\n            {\r\n                if( ( Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.Address == macMsgData.FHDR.DevAddr ) &&\r\n                    ( Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.IsEnabled == true ) )\r\n                {\r\n                    multicast = 1;\r\n                    addrID = Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.GroupID;\r\n                    downLinkCounter = *( Nvm.MacGroup2.MulticastChannelList[i].DownLinkCounter );\r\n                    address = Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.Address;\r\n                    if( Nvm.MacGroup2.DeviceClass == CLASS_C )\r\n                    {\r\n                        MacCtx.McpsIndication.RxSlot = RX_SLOT_WIN_CLASS_C_MULTICAST;\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n\r\n            // Filter messages according to multicast downlink exceptions\r\n            if( ( multicast == 1 ) && ( ( fType != FRAME_TYPE_D ) ||\r\n                                        ( macMsgData.FHDR.FCtrl.Bits.Ack != 0 ) ||\r\n                                        ( macMsgData.FHDR.FCtrl.Bits.AdrAckReq != 0 ) ) )\r\n            {\r\n                MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\r\n                PrepareRxDoneAbort( );\r\n                return;\r\n            }\r\n\r\n            // Get downlink frame counter value\r\n            macCryptoStatus = GetFCntDown( addrID, fType, &macMsgData, Nvm.MacGroup2.Version, &fCntID, &downLinkCounter );\r\n            if( macCryptoStatus != LORAMAC_CRYPTO_SUCCESS )\r\n            {\r\n                if( macCryptoStatus == LORAMAC_CRYPTO_FAIL_FCNT_DUPLICATED )\r\n                {\r\n                    // Catch the case of repeated downlink frame counter\r\n                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_DOWNLINK_REPEATED;\r\n                }\r\n                else\r\n                {\r\n                    // Other errors\r\n                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\r\n                }\r\n                MacCtx.McpsIndication.DownLinkCounter = downLinkCounter;\r\n                PrepareRxDoneAbort( );\r\n                return;\r\n            }\r\n\r\n            macCryptoStatus = LoRaMacCryptoUnsecureMessage( addrID, address, fCntID, downLinkCounter, &macMsgData );\r\n            if( macCryptoStatus != LORAMAC_CRYPTO_SUCCESS )\r\n            {\r\n                if( macCryptoStatus == LORAMAC_CRYPTO_FAIL_ADDRESS )\r\n                {\r\n                    // We are not the destination of this frame.\r\n                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ADDRESS_FAIL;\r\n                }\r\n                else\r\n                {\r\n                    // MIC calculation fail\r\n                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_MIC_FAIL;\r\n                }\r\n                PrepareRxDoneAbort( );\r\n                return;\r\n            }\r\n\r\n            MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_OK;\r\n            MacCtx.McpsIndication.Multicast = multicast;\r\n            MacCtx.McpsIndication.Buffer = NULL;\r\n            MacCtx.McpsIndication.BufferSize = 0;\r\n            MacCtx.McpsIndication.DownLinkCounter = downLinkCounter;\r\n            MacCtx.McpsIndication.AckReceived = macMsgData.FHDR.FCtrl.Bits.Ack;\r\n\r\n            MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_OK;\r\n            MacCtx.McpsConfirm.AckReceived = macMsgData.FHDR.FCtrl.Bits.Ack;\r\n\r\n            // Reset ADR ACK Counter only, when RX1 or RX2 slot\r\n            if( ( MacCtx.McpsIndication.RxSlot == RX_SLOT_WIN_1 ) ||\r\n                ( MacCtx.McpsIndication.RxSlot == RX_SLOT_WIN_2 ) )\r\n            {\r\n                Nvm.MacGroup1.AdrAckCounter = 0;\r\n                Nvm.MacGroup2.DownlinkReceived = true;\r\n            }\r\n\r\n            // MCPS Indication and ack requested handling\r\n            if( multicast == 1 )\r\n            {\r\n                MacCtx.McpsIndication.McpsIndication = MCPS_MULTICAST;\r\n            }\r\n            else\r\n            {\r\n                if( macHdr.Bits.MType == FRAME_TYPE_DATA_CONFIRMED_DOWN )\r\n                {\r\n                    Nvm.MacGroup1.SrvAckRequested = true;\r\n                    if( Nvm.MacGroup2.Version.Fields.Minor == 0 )\r\n                    {\r\n                        Nvm.MacGroup1.LastRxMic = macMsgData.MIC;\r\n                    }\r\n                    MacCtx.McpsIndication.McpsIndication = MCPS_CONFIRMED;\r\n\r\n                    // Handle response timeout for class c and class b downlinks\r\n                    if( ( MacCtx.McpsIndication.RxSlot != RX_SLOT_WIN_1 ) &&\r\n                        ( MacCtx.McpsIndication.RxSlot != RX_SLOT_WIN_2 ) )\r\n                    {\r\n                        // Calculate timeout\r\n                        MacCtx.McpsIndication.ResponseTimeout = REGION_COMMON_CLASS_B_C_RESP_TIMEOUT;\r\n                        MacCtx.ResponseTimeoutStartTime = RxDoneParams.LastRxDone;\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    Nvm.MacGroup1.SrvAckRequested = false;\r\n                    MacCtx.McpsIndication.McpsIndication = MCPS_UNCONFIRMED;\r\n                }\r\n            }\r\n\r\n            // Set the pending status\r\n            if( ( ( ( Nvm.MacGroup1.SrvAckRequested == true ) || ( macMsgData.FHDR.FCtrl.Bits.FPending > 0 ) ) && ( Nvm.MacGroup2.DeviceClass == CLASS_A ) ) ||\r\n                ( MacCtx.McpsIndication.ResponseTimeout > 0 ) )\r\n            {\r\n                MacCtx.McpsIndication.IsUplinkTxPending = 1;\r\n            }\r\n\r\n            RemoveMacCommands( MacCtx.McpsIndication.RxSlot, macMsgData.FHDR.FCtrl, MacCtx.McpsConfirm.McpsRequest );\r\n\r\n            switch( fType )\r\n            {\r\n                case FRAME_TYPE_A:\r\n                {  /* +----------+------+-------+--------------+\r\n                    * | FOptsLen | Fopt | FPort |  FRMPayload  |\r\n                    * +----------+------+-------+--------------+\r\n                    * |    > 0   |   X  |  > 0  |       X      |\r\n                    * +----------+------+-------+--------------+\r\n                    */\r\n\r\n                    // Decode MAC commands in FOpts field\r\n                    ProcessMacCommands( macMsgData.FHDR.FOpts, 0, macMsgData.FHDR.FCtrl.Bits.FOptsLen, snr, MacCtx.McpsIndication.RxSlot );\r\n                    MacCtx.McpsIndication.Port = macMsgData.FPort;\r\n                    MacCtx.McpsIndication.Buffer = macMsgData.FRMPayload;\r\n                    MacCtx.McpsIndication.BufferSize = macMsgData.FRMPayloadSize;\r\n                    MacCtx.McpsIndication.RxData = true;\r\n                    break;\r\n                }\r\n                case FRAME_TYPE_B:\r\n                {  /* +----------+------+-------+--------------+\r\n                    * | FOptsLen | Fopt | FPort |  FRMPayload  |\r\n                    * +----------+------+-------+--------------+\r\n                    * |    > 0   |   X  |   -   |       -      |\r\n                    * +----------+------+-------+--------------+\r\n                    */\r\n\r\n                    // Decode MAC commands in FOpts field\r\n                    ProcessMacCommands( macMsgData.FHDR.FOpts, 0, macMsgData.FHDR.FCtrl.Bits.FOptsLen, snr, MacCtx.McpsIndication.RxSlot );\r\n                    MacCtx.McpsIndication.Port = macMsgData.FPort;\r\n                    break;\r\n                }\r\n                case FRAME_TYPE_C:\r\n                {  /* +----------+------+-------+--------------+\r\n                    * | FOptsLen | Fopt | FPort |  FRMPayload  |\r\n                    * +----------+------+-------+--------------+\r\n                    * |    = 0   |   -  |  = 0  | MAC commands |\r\n                    * +----------+------+-------+--------------+\r\n                    */\r\n\r\n                    // Decode MAC commands in FRMPayload\r\n                    ProcessMacCommands( macMsgData.FRMPayload, 0, macMsgData.FRMPayloadSize, snr, MacCtx.McpsIndication.RxSlot );\r\n                    MacCtx.McpsIndication.Port = macMsgData.FPort;\r\n                    break;\r\n                }\r\n                case FRAME_TYPE_D:\r\n                {  /* +----------+------+-------+--------------+\r\n                    * | FOptsLen | Fopt | FPort |  FRMPayload  |\r\n                    * +----------+------+-------+--------------+\r\n                    * |    = 0   |   -  |  > 0  |       X      |\r\n                    * +----------+------+-------+--------------+\r\n                    */\r\n\r\n                    // No MAC commands just application payload\r\n                    MacCtx.McpsIndication.Port = macMsgData.FPort;\r\n                    MacCtx.McpsIndication.Buffer = macMsgData.FRMPayload;\r\n                    MacCtx.McpsIndication.BufferSize = macMsgData.FRMPayloadSize;\r\n                    MacCtx.McpsIndication.RxData = true;\r\n                    break;\r\n                }\r\n                default:\r\n                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\r\n                    PrepareRxDoneAbort( );\r\n                    break;\r\n            }\r\n\r\n            // Rejoin handling\r\n            if( Nvm.MacGroup2.IsRejoinAcceptPending == true )\r\n            {\r\n                Nvm.MacGroup2.IsRejoinAcceptPending = false;\r\n\r\n                // Stop in any case the ForceRejoinReqCycleTimer\r\n                TimerStop( &MacCtx.ForceRejoinReqCycleTimer );\r\n\r\n                // If the rejoin was trigged by MLME, set confirmation status\r\n                if( MacCtx.MacFlags.Bits.MlmeReq == 1 )\r\n                {\r\n                    MacCtx.MlmeConfirm.Status = LORAMAC_EVENT_INFO_STATUS_OK;\r\n                }\r\n            }\r\n\r\n            if( ( macMsgData.FPort == LORAMAC_CERT_FPORT ) && (Nvm.MacGroup2.IsCertPortOn == false ) )\r\n            { // Do not notify the upper layer of data reception on FPort LORAMAC_CERT_FPORT if the port\r\n              // handling is disabled.\r\n                MacCtx.McpsIndication.Port = macMsgData.FPort;\r\n                MacCtx.McpsIndication.Buffer = NULL;\r\n                MacCtx.McpsIndication.BufferSize = 0;\r\n                MacCtx.McpsIndication.RxData = false;\r\n            }\r\n\r\n            // Provide always an indication, skip the callback to the user application,\r\n            // in case of a confirmed downlink retransmission.\r\n            MacCtx.MacFlags.Bits.McpsInd = 1;\r\n\r\n            break;\r\n        case FRAME_TYPE_PROPRIETARY:\r\n            memcpy1( MacCtx.RxPayload, &payload[pktHeaderLen], size - pktHeaderLen );\r\n\r\n            MacCtx.McpsIndication.McpsIndication = MCPS_PROPRIETARY;\r\n            MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_OK;\r\n            MacCtx.McpsIndication.Buffer = MacCtx.RxPayload;\r\n            MacCtx.McpsIndication.BufferSize = size - pktHeaderLen;\r\n\r\n            MacCtx.MacFlags.Bits.McpsInd = 1;\r\n            break;\r\n        default:\r\n            MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\r\n            PrepareRxDoneAbort( );\r\n            break;\r\n    }\r\n\r\n    // Verify if we need to disable the RetransmitTimeoutTimer\r\n    // Only aplies if downlink is received on Rx1 or Rx2 windows.\r\n    if( ( MacCtx.McpsIndication.RxSlot == RX_SLOT_WIN_1 ) ||\r\n        ( MacCtx.McpsIndication.RxSlot == RX_SLOT_WIN_2 ) )\r\n    {\r\n        if( MacCtx.NodeAckRequested == true )\r\n        {\r\n            if( MacCtx.McpsConfirm.AckReceived == true )\r\n            {\r\n                OnRetransmitTimeoutTimerEvent( NULL );\r\n            }\r\n        }\r\n    }\r\n\r\n    if( MacCtx.McpsIndication.RxSlot != RX_SLOT_WIN_CLASS_C )\r\n    {\r\n        MacCtx.MacFlags.Bits.MacDone = 1;\r\n    }\r\n\r\n    UpdateRxSlotIdleState( );\r\n}\r\n\r\nstatic void ProcessRadioTxTimeout( void )\r\n{\r\n    if( Nvm.MacGroup2.DeviceClass != CLASS_C )\r\n    {\r\n        Radio.Sleep( );\r\n    }\r\n    UpdateRxSlotIdleState( );\r\n\r\n    MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_TX_TIMEOUT;\r\n    LoRaMacConfirmQueueSetStatusCmn( LORAMAC_EVENT_INFO_STATUS_TX_TIMEOUT );\r\n    if( MacCtx.NodeAckRequested == true )\r\n    {\r\n        MacCtx.RetransmitTimeoutRetry = true;\r\n    }\r\n    MacCtx.MacFlags.Bits.MacDone = 1;\r\n}\r\n\r\nstatic void HandleRadioRxErrorTimeout( LoRaMacEventInfoStatus_t rx1EventInfoStatus, LoRaMacEventInfoStatus_t rx2EventInfoStatus )\r\n{\r\n    bool classBRx = false;\r\n\r\n    if( Nvm.MacGroup2.DeviceClass != CLASS_C )\r\n    {\r\n        Radio.Sleep( );\r\n    }\r\n\r\n    if( LoRaMacClassBIsBeaconExpected( ) == true )\r\n    {\r\n        LoRaMacClassBSetBeaconState( BEACON_STATE_TIMEOUT );\r\n        LoRaMacClassBBeaconTimerEvent( NULL );\r\n        classBRx = true;\r\n    }\r\n    if( Nvm.MacGroup2.DeviceClass == CLASS_B )\r\n    {\r\n        if( LoRaMacClassBIsPingExpected( ) == true )\r\n        {\r\n            LoRaMacClassBSetPingSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );\r\n            LoRaMacClassBPingSlotTimerEvent( NULL );\r\n            classBRx = true;\r\n        }\r\n        if( LoRaMacClassBIsMulticastExpected( ) == true )\r\n        {\r\n            LoRaMacClassBSetMulticastSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );\r\n            LoRaMacClassBMulticastSlotTimerEvent( NULL );\r\n            classBRx = true;\r\n        }\r\n    }\r\n\r\n    if( classBRx == false )\r\n    {\r\n        if( MacCtx.RxSlot == RX_SLOT_WIN_1 )\r\n        {\r\n            if( MacCtx.NodeAckRequested == true )\r\n            {\r\n                MacCtx.McpsConfirm.Status = rx1EventInfoStatus;\r\n            }\r\n            LoRaMacConfirmQueueSetStatusCmn( rx1EventInfoStatus );\r\n\r\n            if( TimerGetElapsedTime( Nvm.MacGroup1.LastTxDoneTime ) >= MacCtx.RxWindow2Delay )\r\n            {\r\n                TimerStop( &MacCtx.RxWindowTimer2 );\r\n                MacCtx.MacFlags.Bits.MacDone = 1;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            if( MacCtx.NodeAckRequested == true )\r\n            {\r\n                MacCtx.McpsConfirm.Status = rx2EventInfoStatus;\r\n            }\r\n            LoRaMacConfirmQueueSetStatusCmn( rx2EventInfoStatus );\r\n            MacCtx.MacFlags.Bits.MacDone = 1;\r\n        }\r\n    }\r\n\r\n    UpdateRxSlotIdleState( );\r\n}\r\n\r\nstatic void ProcessRadioRxError( void )\r\n{\r\n    HandleRadioRxErrorTimeout( LORAMAC_EVENT_INFO_STATUS_RX1_ERROR, LORAMAC_EVENT_INFO_STATUS_RX2_ERROR );\r\n}\r\n\r\nstatic void ProcessRadioRxTimeout( void )\r\n{\r\n    HandleRadioRxErrorTimeout( LORAMAC_EVENT_INFO_STATUS_RX1_TIMEOUT, LORAMAC_EVENT_INFO_STATUS_RX2_TIMEOUT );\r\n}\r\n\r\nstatic void LoRaMacHandleIrqEvents( void )\r\n{\r\n    LoRaMacRadioEvents_t events;\r\n\r\n    CRITICAL_SECTION_BEGIN( );\r\n    events = LoRaMacRadioEvents;\r\n    LoRaMacRadioEvents.Value = 0;\r\n    CRITICAL_SECTION_END( );\r\n\r\n    if( events.Value != 0 )\r\n    {\r\n        if( events.Events.TxDone == 1 )\r\n        {\r\n            ProcessRadioTxDone( );\r\n        }\r\n        if( events.Events.RxDone == 1 )\r\n        {\r\n            ProcessRadioRxDone( );\r\n        }\r\n        if( events.Events.TxTimeout == 1 )\r\n        {\r\n            ProcessRadioTxTimeout( );\r\n        }\r\n        if( events.Events.RxError == 1 )\r\n        {\r\n            ProcessRadioRxError( );\r\n        }\r\n        if( events.Events.RxTimeout == 1 )\r\n        {\r\n            ProcessRadioRxTimeout( );\r\n        }\r\n    }\r\n}\r\n\r\nbool LoRaMacIsBusy( void )\r\n{\r\n    if( MacCtx.MacState == LORAMAC_STOPPED )\r\n    {\r\n        return false;\r\n    }\r\n\r\n    if( LoRaMacRadioEvents.Events.RxProcessPending == 1 )\r\n    {\r\n        return true;\r\n    }\r\n\r\n    if( ( MacCtx.MacState == LORAMAC_IDLE ) &&\r\n        ( MacCtx.AllowRequests == LORAMAC_REQUEST_HANDLING_ON ) )\r\n    {\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n\r\n\r\nstatic void LoRaMacEnableRequests( LoRaMacRequestHandling_t requestState )\r\n{\r\n    MacCtx.AllowRequests = requestState;\r\n}\r\n\r\nstatic void LoRaMacHandleRequestEvents( void )\r\n{\r\n    // Handle events\r\n    LoRaMacFlags_t reqEvents = MacCtx.MacFlags;\r\n\r\n    if( MacCtx.MacState == LORAMAC_IDLE )\r\n    {\r\n        // Update event bits\r\n        if( MacCtx.MacFlags.Bits.McpsReq == 1 )\r\n        {\r\n            MacCtx.MacFlags.Bits.McpsReq = 0;\r\n        }\r\n\r\n        if( MacCtx.MacFlags.Bits.MlmeReq == 1 )\r\n        {\r\n            MacCtx.MacFlags.Bits.MlmeReq = 0;\r\n        }\r\n\r\n        // Allow requests again\r\n        LoRaMacEnableRequests( LORAMAC_REQUEST_HANDLING_ON );\r\n\r\n        // Handle callbacks\r\n        if( reqEvents.Bits.McpsReq == 1 )\r\n        {\r\n            MacCtx.MacPrimitives->MacMcpsConfirm( &MacCtx.McpsConfirm );\r\n        }\r\n\r\n        if( reqEvents.Bits.MlmeReq == 1 )\r\n        {\r\n            LoRaMacConfirmQueueHandleCb( &MacCtx.MlmeConfirm );\r\n            if( LoRaMacConfirmQueueGetCnt( ) > 0 )\r\n            {\r\n                MacCtx.MacFlags.Bits.MlmeReq = 1;\r\n            }\r\n        }\r\n\r\n        // Start beaconing again\r\n        LoRaMacClassBResumeBeaconing( );\r\n\r\n        // Procedure done. Reset variables.\r\n        MacCtx.MacFlags.Bits.MacDone = 0;\r\n    }\r\n}\r\n\r\nstatic void LoRaMacHandleIndicationEvents( void )\r\n{\r\n    // Handle MLME indication\r\n    if( MacCtx.MacFlags.Bits.MlmeInd == 1 )\r\n    {\r\n        MacCtx.MacFlags.Bits.MlmeInd = 0;\r\n        MacCtx.MacPrimitives->MacMlmeIndication( &MacCtx.MlmeIndication );\r\n    }\r\n\r\n    // Handle MCPS indication\r\n    if( MacCtx.MacFlags.Bits.McpsInd == 1 )\r\n    {\r\n        MacCtx.MacFlags.Bits.McpsInd = 0;\r\n        MacCtx.MacPrimitives->MacMcpsIndication( &MacCtx.McpsIndication );\r\n    }\r\n}\r\n\r\nstatic void LoRaMacHandleRejoinEvents( void )\r\n{\r\n    if( MacCtx.MacState == LORAMAC_IDLE )\r\n    {\r\n        MlmeReq_t mlmeReq;\r\n        if( IsReJoin0Required( ) == true )\r\n        {\r\n            mlmeReq.Type = MLME_REJOIN_0;\r\n            LoRaMacMlmeRequest( &mlmeReq );\r\n        }\r\n        else if( Nvm.MacGroup2.IsRejoin0RequestQueued == true )\r\n        {\r\n            mlmeReq.Type = MLME_REJOIN_0;\r\n            if( LoRaMacMlmeRequest( &mlmeReq ) == LORAMAC_STATUS_OK )\r\n            {\r\n                Nvm.MacGroup2.IsRejoin0RequestQueued = false;\r\n            }\r\n        }\r\n        else if( Nvm.MacGroup2.IsRejoin1RequestQueued == true )\r\n        {\r\n            mlmeReq.Type = MLME_REJOIN_1;\r\n            if( LoRaMacMlmeRequest( &mlmeReq ) == LORAMAC_STATUS_OK )\r\n            {\r\n                Nvm.MacGroup2.IsRejoin1RequestQueued = false;\r\n            }\r\n        }\r\n        else if( Nvm.MacGroup2.IsRejoin2RequestQueued == true )\r\n        {\r\n            mlmeReq.Type = MLME_REJOIN_2;\r\n            if( LoRaMacMlmeRequest( &mlmeReq ) == LORAMAC_STATUS_OK )\r\n            {\r\n                Nvm.MacGroup2.IsRejoin2RequestQueued = false;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nstatic void LoRaMacHandleMcpsRequest( void )\r\n{\r\n    // Handle MCPS uplinks\r\n    if( MacCtx.MacFlags.Bits.McpsReq == 1 )\r\n    {\r\n        bool stopRetransmission = false;\r\n        bool waitForRetransmission = false;\r\n\r\n        if( ( MacCtx.McpsConfirm.McpsRequest == MCPS_UNCONFIRMED ) ||\r\n            ( MacCtx.McpsConfirm.McpsRequest == MCPS_PROPRIETARY ) )\r\n        {\r\n            stopRetransmission = CheckRetransUnconfirmedUplink( );\r\n        }\r\n        else if( MacCtx.McpsConfirm.McpsRequest == MCPS_CONFIRMED )\r\n        {\r\n            if( MacCtx.RetransmitTimeoutRetry == true )\r\n            {\r\n                stopRetransmission = CheckRetransConfirmedUplink( );\r\n            }\r\n            else\r\n            {\r\n                waitForRetransmission = true;\r\n            }\r\n        }\r\n\r\n        if( stopRetransmission == true )\r\n        {// Stop retransmission\r\n            TimerStop( &MacCtx.TxDelayedTimer );\r\n            MacCtx.MacState &= ~LORAMAC_TX_DELAYED;\r\n            StopRetransmission( );\r\n        }\r\n        else if( waitForRetransmission == false )\r\n        {// Arrange further retransmission\r\n            MacCtx.MacFlags.Bits.MacDone = 0;\r\n            // Reset the state of the AckTimeout\r\n            MacCtx.RetransmitTimeoutRetry = false;\r\n            // Sends the same frame again\r\n            OnTxDelayedTimerEvent( NULL );\r\n        }\r\n    }\r\n}\r\n\r\nstatic void LoRaMacHandleMlmeRequest( void )\r\n{\r\n    // Handle join request\r\n    if( MacCtx.MacFlags.Bits.MlmeReq == 1 )\r\n    {\r\n        if( ( LoRaMacConfirmQueueIsCmdActive( MLME_JOIN ) == true ) ||\r\n            ( LoRaMacConfirmQueueIsCmdActive( MLME_REJOIN_0 ) == true ) ||\r\n            ( LoRaMacConfirmQueueIsCmdActive( MLME_REJOIN_1 ) == true ) ||\r\n            ( LoRaMacConfirmQueueIsCmdActive( MLME_REJOIN_2 ) == true ) )\r\n        {\r\n            MacCtx.ChannelsNbTransCounter = 0;\r\n            MacCtx.MacState &= ~LORAMAC_TX_RUNNING;\r\n        }\r\n        else if( LoRaMacConfirmQueueIsCmdActive( MLME_TXCW ) == true )\r\n        {\r\n            MacCtx.MacState &= ~LORAMAC_TX_RUNNING;\r\n        }\r\n    }\r\n}\r\n\r\nstatic uint8_t LoRaMacCheckForBeaconAcquisition( void )\r\n{\r\n    if( ( LoRaMacConfirmQueueIsCmdActive( MLME_BEACON_ACQUISITION ) == true ) &&\r\n        ( MacCtx.MacFlags.Bits.McpsReq == 0 ) )\r\n    {\r\n        if( MacCtx.MacFlags.Bits.MlmeReq == 1 )\r\n        {\r\n            MacCtx.MacState &= ~LORAMAC_TX_RUNNING;\r\n            return 0x01;\r\n        }\r\n    }\r\n    return 0x00;\r\n}\r\n\r\nstatic bool CheckForMinimumAbpDatarate( bool adr, ActivationType_t activation, bool datarateChanged )\r\n{\r\n    if( ( adr == true ) &&\r\n        ( activation == ACTIVATION_TYPE_ABP ) &&\r\n        ( datarateChanged == false ) )\r\n    {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\nstatic void LoRaMacCheckForRxAbort( void )\r\n{\r\n    // A error occurs during receiving\r\n    if( ( MacCtx.MacState & LORAMAC_RX_ABORT ) == LORAMAC_RX_ABORT )\r\n    {\r\n        MacCtx.MacState &= ~LORAMAC_RX_ABORT;\r\n        MacCtx.MacState &= ~LORAMAC_TX_RUNNING;\r\n    }\r\n}\r\n\r\nstatic void LoRaMacHandleNvm( LoRaMacNvmData_t* nvmData )\r\n{\r\n    uint32_t crc = 0;\r\n    uint16_t notifyFlags = LORAMAC_NVM_NOTIFY_FLAG_NONE;\r\n\r\n    if( MacCtx.MacState != LORAMAC_IDLE )\r\n    {\r\n        return;\r\n    }\r\n\r\n    // Crypto\r\n    crc = Crc32( ( uint8_t* ) &nvmData->Crypto, sizeof( nvmData->Crypto ) -\r\n                                                sizeof( nvmData->Crypto.Crc32 ) );\r\n    if( crc != nvmData->Crypto.Crc32 )\r\n    {\r\n        nvmData->Crypto.Crc32 = crc;\r\n        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_CRYPTO;\r\n    }\r\n\r\n    // MacGroup1\r\n    crc = Crc32( ( uint8_t* ) &nvmData->MacGroup1, sizeof( nvmData->MacGroup1 ) -\r\n                                                   sizeof( nvmData->MacGroup1.Crc32 ) );\r\n    if( crc != nvmData->MacGroup1.Crc32 )\r\n    {\r\n        nvmData->MacGroup1.Crc32 = crc;\r\n        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_MAC_GROUP1;\r\n    }\r\n\r\n    // MacGroup2\r\n    crc = Crc32( ( uint8_t* ) &nvmData->MacGroup2, sizeof( nvmData->MacGroup2 ) -\r\n                                                   sizeof( nvmData->MacGroup2.Crc32 ) );\r\n    if( crc != nvmData->MacGroup2.Crc32 )\r\n    {\r\n        nvmData->MacGroup2.Crc32 = crc;\r\n        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_MAC_GROUP2;\r\n    }\r\n\r\n    // Secure Element\r\n    crc = Crc32( ( uint8_t* ) &nvmData->SecureElement, sizeof( nvmData->SecureElement ) -\r\n                                                       sizeof( nvmData->SecureElement.Crc32 ) );\r\n    if( crc != nvmData->SecureElement.Crc32 )\r\n    {\r\n        nvmData->SecureElement.Crc32 = crc;\r\n        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_SECURE_ELEMENT;\r\n    }\r\n\r\n    // Region\r\n    crc = Crc32( ( uint8_t* ) &nvmData->RegionGroup1, sizeof( nvmData->RegionGroup1 ) -\r\n                                                sizeof( nvmData->RegionGroup1.Crc32 ) );\r\n    if( crc != nvmData->RegionGroup1.Crc32 )\r\n    {\r\n        nvmData->RegionGroup1.Crc32 = crc;\r\n        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_REGION_GROUP1;\r\n    }\r\n\r\n    crc = Crc32( ( uint8_t* ) &nvmData->RegionGroup2, sizeof( nvmData->RegionGroup2 ) -\r\n                                                sizeof( nvmData->RegionGroup2.Crc32 ) );\r\n    if( crc != nvmData->RegionGroup2.Crc32 )\r\n    {\r\n        nvmData->RegionGroup2.Crc32 = crc;\r\n        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_REGION_GROUP2;\r\n    }\r\n\r\n    // ClassB\r\n    crc = Crc32( ( uint8_t* ) &nvmData->ClassB, sizeof( nvmData->ClassB ) -\r\n                                                sizeof( nvmData->ClassB.Crc32 ) );\r\n    if( crc != nvmData->ClassB.Crc32 )\r\n    {\r\n        nvmData->ClassB.Crc32 = crc;\r\n        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_CLASS_B;\r\n    }\r\n\r\n    CallNvmDataChangeCallback( notifyFlags );\r\n}\r\n\r\nstatic bool LoRaMacHandleResponseTimeout( TimerTime_t timeoutInMs, TimerTime_t startTimeInMs )\r\n{\r\n    if( startTimeInMs != 0 )\r\n    {\r\n        TimerTime_t elapsedTime = TimerGetElapsedTime( startTimeInMs );\r\n        if( elapsedTime > timeoutInMs )\r\n        {\r\n            Nvm.MacGroup1.SrvAckRequested = false;\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nvoid LoRaMacProcess( void )\r\n{\r\n    uint8_t noTx = false;\r\n\r\n    LoRaMacHandleIrqEvents( );\r\n    LoRaMacClassBProcess( );\r\n\r\n    // MAC proceeded a state and is ready to check\r\n    if( MacCtx.MacFlags.Bits.MacDone == 1 )\r\n    {\r\n        LoRaMacEnableRequests( LORAMAC_REQUEST_HANDLING_OFF );\r\n        LoRaMacCheckForRxAbort( );\r\n\r\n        // An error occurs during transmitting\r\n        if( IsRequestPending( ) > 0 )\r\n        {\r\n            noTx |= LoRaMacCheckForBeaconAcquisition( );\r\n        }\r\n\r\n        if( noTx == 0x00 )\r\n        {\r\n            LoRaMacHandleMlmeRequest( );\r\n            LoRaMacHandleMcpsRequest( );\r\n        }\r\n        LoRaMacHandleRequestEvents( );\r\n        LoRaMacEnableRequests( LORAMAC_REQUEST_HANDLING_ON );\r\n        MacCtx.MacFlags.Bits.NvmHandle = 1;\r\n    }\r\n    LoRaMacHandleIndicationEvents( );\r\n    LoRaMacHandleRejoinEvents( );\r\n\r\n    if( MacCtx.RxSlot == RX_SLOT_WIN_CLASS_C )\r\n    {\r\n        OpenContinuousRxCWindow( );\r\n    }\r\n    if( MacCtx.MacFlags.Bits.NvmHandle == 1 )\r\n    {\r\n        MacCtx.MacFlags.Bits.NvmHandle = 0;\r\n        LoRaMacHandleNvm( &Nvm );\r\n    }\r\n}\r\n\r\nstatic void OnTxDelayedTimerEvent( void* context )\r\n{\r\n    TimerStop( &MacCtx.TxDelayedTimer );\r\n    MacCtx.MacState &= ~LORAMAC_TX_DELAYED;\r\n\r\n    if( LoRaMacHandleResponseTimeout( REGION_COMMON_CLASS_B_C_RESP_TIMEOUT,\r\n                                      MacCtx.ResponseTimeoutStartTime ) == true )\r\n    {\r\n        // Skip retransmission\r\n        return;\r\n    }\r\n\r\n    // Schedule frame, allow delayed frame transmissions\r\n    switch( ScheduleTx( true ) )\r\n    {\r\n        case LORAMAC_STATUS_OK:\r\n        case LORAMAC_STATUS_DUTYCYCLE_RESTRICTED:\r\n        {\r\n            break;\r\n        }\r\n        default:\r\n        {\r\n            // Stop retransmission attempt\r\n            MacCtx.McpsConfirm.Datarate = Nvm.MacGroup1.ChannelsDatarate;\r\n            MacCtx.McpsConfirm.NbTrans = MacCtx.ChannelsNbTransCounter;\r\n            MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_TX_DR_PAYLOAD_SIZE_ERROR;\r\n            LoRaMacConfirmQueueSetStatusCmn( LORAMAC_EVENT_INFO_STATUS_TX_DR_PAYLOAD_SIZE_ERROR );\r\n            StopRetransmission( );\r\n            break;\r\n        }\r\n    }\r\n}\r\n\r\nstatic void OnRxWindow1TimerEvent( void* context )\r\n{\r\n    MacCtx.RxWindow1Config.Channel = MacCtx.Channel;\r\n    MacCtx.RxWindow1Config.DrOffset = Nvm.MacGroup2.MacParams.Rx1DrOffset;\r\n    MacCtx.RxWindow1Config.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;\r\n    MacCtx.RxWindow1Config.RxContinuous = false;\r\n    MacCtx.RxWindow1Config.RxSlot = RX_SLOT_WIN_1;\r\n    MacCtx.RxWindow1Config.NetworkActivation = Nvm.MacGroup2.NetworkActivation;\r\n\r\n    RxWindowSetup( &MacCtx.RxWindowTimer1, &MacCtx.RxWindow1Config );\r\n}\r\n\r\nstatic void OnRxWindow2TimerEvent( void* context )\r\n{\r\n    // Check if we are processing Rx1 window.\r\n    // If yes, we don't setup the Rx2 window.\r\n    if( MacCtx.RxSlot == RX_SLOT_WIN_1 )\r\n    {\r\n        return;\r\n    }\r\n    MacCtx.RxWindow2Config.Channel = MacCtx.Channel;\r\n    MacCtx.RxWindow2Config.Frequency = Nvm.MacGroup2.MacParams.Rx2Channel.Frequency;\r\n    MacCtx.RxWindow2Config.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;\r\n    MacCtx.RxWindow2Config.RxContinuous = false;\r\n    MacCtx.RxWindow2Config.RxSlot = RX_SLOT_WIN_2;\r\n    MacCtx.RxWindow2Config.NetworkActivation = Nvm.MacGroup2.NetworkActivation;\r\n\r\n    RxWindowSetup( &MacCtx.RxWindowTimer2, &MacCtx.RxWindow2Config );\r\n}\r\n\r\nstatic void OnRetransmitTimeoutTimerEvent( void* context )\r\n{\r\n    TimerStop( &MacCtx.RetransmitTimeoutTimer );\r\n\r\n    if( MacCtx.NodeAckRequested == true )\r\n    {\r\n        MacCtx.RetransmitTimeoutRetry = true;\r\n    }\r\n    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )\r\n    {\r\n        MacCtx.MacCallbacks->MacProcessNotify( );\r\n    }\r\n}\r\n\r\nstatic LoRaMacCryptoStatus_t GetFCntDown( AddressIdentifier_t addrID, FType_t fType, LoRaMacMessageData_t* macMsg, Version_t lrWanVersion,\r\n                                          FCntIdentifier_t* fCntID, uint32_t* currentDown )\r\n{\r\n    if( ( macMsg == NULL ) || ( fCntID == NULL ) ||\r\n        ( currentDown == NULL ) )\r\n    {\r\n        return LORAMAC_CRYPTO_ERROR_NPE;\r\n    }\r\n\r\n    // Determine the frame counter identifier and choose counter from FCntList\r\n    switch( addrID )\r\n    {\r\n        case UNICAST_DEV_ADDR:\r\n            if( lrWanVersion.Fields.Minor == 1 )\r\n            {\r\n                if( ( fType == FRAME_TYPE_A ) || ( fType == FRAME_TYPE_D ) )\r\n                {\r\n                    *fCntID = A_FCNT_DOWN;\r\n                }\r\n                else\r\n                {\r\n                    *fCntID = N_FCNT_DOWN;\r\n                }\r\n            }\r\n            else\r\n            { // For LoRaWAN 1.0.X\r\n                *fCntID = FCNT_DOWN;\r\n            }\r\n            break;\r\n        case MULTICAST_0_ADDR:\r\n            *fCntID = MC_FCNT_DOWN_0;\r\n            break;\r\n        case MULTICAST_1_ADDR:\r\n            *fCntID = MC_FCNT_DOWN_1;\r\n            break;\r\n        case MULTICAST_2_ADDR:\r\n            *fCntID = MC_FCNT_DOWN_2;\r\n            break;\r\n        case MULTICAST_3_ADDR:\r\n            *fCntID = MC_FCNT_DOWN_3;\r\n            break;\r\n        default:\r\n            return LORAMAC_CRYPTO_FAIL_FCNT_ID;\r\n    }\r\n\r\n    return LoRaMacCryptoGetFCntDown( *fCntID, macMsg->FHDR.FCnt, currentDown );\r\n}\r\n\r\nstatic LoRaMacStatus_t SwitchClass( DeviceClass_t deviceClass )\r\n{\r\n    LoRaMacStatus_t status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n\r\n    switch( Nvm.MacGroup2.DeviceClass )\r\n    {\r\n        case CLASS_A:\r\n        {\r\n            if( deviceClass == CLASS_A )\r\n            {\r\n                // Revert back RxC parameters\r\n                Nvm.MacGroup2.MacParams.RxCChannel = Nvm.MacGroup2.MacParams.Rx2Channel;\r\n\r\n                status = LORAMAC_STATUS_OK;\r\n            }\r\n            if( deviceClass == CLASS_B )\r\n            {\r\n                status = LoRaMacClassBSwitchClass( deviceClass );\r\n                if( status == LORAMAC_STATUS_OK )\r\n                {\r\n                    Nvm.MacGroup2.DeviceClass = deviceClass;\r\n                }\r\n            }\r\n\r\n            if( deviceClass == CLASS_C )\r\n            {\r\n                Nvm.MacGroup2.DeviceClass = deviceClass;\r\n\r\n                MacCtx.RxWindowCConfig = MacCtx.RxWindow2Config;\r\n                MacCtx.RxWindowCConfig.RxSlot = RX_SLOT_WIN_CLASS_C;\r\n\r\n                for( int8_t i = 0; i < LORAMAC_MAX_MC_CTX; i++ )\r\n                {\r\n                    if( ( Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.IsEnabled == true ) &&\r\n                        ( Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.RxParams.Class == CLASS_C ) )\r\n                    {\r\n                        Nvm.MacGroup2.MacParams.RxCChannel.Frequency = Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.RxParams.Params.ClassC.Frequency;\r\n                        Nvm.MacGroup2.MacParams.RxCChannel.Datarate = Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.RxParams.Params.ClassC.Datarate;\r\n\r\n                        MacCtx.RxWindowCConfig.Channel = MacCtx.Channel;\r\n                        MacCtx.RxWindowCConfig.Frequency = Nvm.MacGroup2.MacParams.RxCChannel.Frequency;\r\n                        MacCtx.RxWindowCConfig.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;\r\n                        MacCtx.RxWindowCConfig.RxSlot = RX_SLOT_WIN_CLASS_C_MULTICAST;\r\n                        MacCtx.RxWindowCConfig.RxContinuous = true;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                // Set the NodeAckRequested indicator to default\r\n                MacCtx.NodeAckRequested = false;\r\n                // Set the radio into sleep mode in case we are still in RX mode\r\n                Radio.Sleep( );\r\n\r\n                OpenContinuousRxCWindow( );\r\n\r\n                // Add a DeviceModeInd MAC Command to indicate the network a device mode change.\r\n                if( Nvm.MacGroup2.Version.Fields.Minor >= 1 )\r\n                {\r\n                    LoRaMacCommandsAddCmd( MOTE_MAC_DEVICE_MODE_IND, ( uint8_t* )&Nvm.MacGroup2.DeviceClass, 1 );\r\n                }\r\n\r\n                status = LORAMAC_STATUS_OK;\r\n            }\r\n            break;\r\n        }\r\n        case CLASS_B:\r\n        {\r\n            status = LoRaMacClassBSwitchClass( deviceClass );\r\n            if( status == LORAMAC_STATUS_OK )\r\n            {\r\n                Nvm.MacGroup2.DeviceClass = deviceClass;\r\n            }\r\n            break;\r\n        }\r\n        case CLASS_C:\r\n        {\r\n            if( deviceClass == CLASS_A )\r\n            {\r\n                // Reset RxSlot to NONE\r\n                MacCtx.RxSlot = RX_SLOT_NONE;\r\n\r\n                Nvm.MacGroup2.DeviceClass = deviceClass;\r\n\r\n                // Set the radio into sleep to setup a defined state\r\n                Radio.Sleep( );\r\n\r\n                status = LORAMAC_STATUS_OK;\r\n\r\n                // Add a DeviceModeInd MAC Command to indicate the network a device mode change.\r\n                if( Nvm.MacGroup2.Version.Fields.Minor >= 1 )\r\n                {\r\n                    LoRaMacCommandsAddCmd( MOTE_MAC_DEVICE_MODE_IND, ( uint8_t* )&Nvm.MacGroup2.DeviceClass, 1 );\r\n                }\r\n            }\r\n            break;\r\n        }\r\n    }\r\n\r\n    return status;\r\n}\r\n\r\nstatic uint8_t GetMaxAppPayloadWithoutFOptsLength( int8_t datarate )\r\n{\r\n    GetPhyParams_t getPhy;\r\n    PhyParam_t phyParam;\r\n\r\n    // Setup PHY request\r\n    getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;\r\n    getPhy.Datarate = datarate;\r\n    getPhy.Attribute = PHY_MAX_PAYLOAD;\r\n    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );\r\n\r\n    return phyParam.Value;\r\n}\r\n\r\nstatic bool ValidatePayloadLength( uint8_t lenN, int8_t datarate, uint8_t fOptsLen )\r\n{\r\n    uint16_t maxN = 0;\r\n    uint16_t payloadSize = 0;\r\n\r\n    maxN = GetMaxAppPayloadWithoutFOptsLength( datarate );\r\n\r\n    // Calculate the resulting payload size\r\n    payloadSize = ( lenN + fOptsLen );\r\n\r\n    // Validation of the application payload size\r\n    if( ( payloadSize <= maxN ) && ( payloadSize <= LORAMAC_PHY_MAXPAYLOAD ) )\r\n    {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\nstatic void ProcessMacCommands( uint8_t *payload, uint8_t macIndex, uint8_t commandsSize, int8_t snr, LoRaMacRxSlot_t rxSlot )\r\n{\r\n    uint8_t status = 0;\r\n    bool adrBlockFound = false;\r\n    uint8_t macCmdPayload[2] = { 0x00, 0x00 };\r\n    MacCommand_t* macCmd;\r\n\r\n    if( ( rxSlot != RX_SLOT_WIN_1 ) && ( rxSlot != RX_SLOT_WIN_2 ) )\r\n    {\r\n        // Do only parse MAC commands for Class A RX windows\r\n        return;\r\n    }\r\n\r\n    while( macIndex < commandsSize )\r\n    {\r\n        // Make sure to parse only complete MAC commands\r\n        if( ( LoRaMacCommandsGetCmdSize( payload[macIndex] ) + macIndex ) > commandsSize )\r\n        {\r\n            return;\r\n        }\r\n\r\n        // Decode Frame MAC commands\r\n        switch( payload[macIndex++] )\r\n        {\r\n            case SRV_MAC_RESET_CONF:\r\n            {\r\n                uint8_t serverMinorVersion = payload[macIndex++];\r\n\r\n                // Compare own LoRaWAN Version with server's\r\n                if( Nvm.MacGroup2.Version.Fields.Minor >= serverMinorVersion )\r\n                {\r\n                    // If they equal remove the sticky ResetInd MAC-Command.\r\n                    if( LoRaMacCommandsGetCmd( MOTE_MAC_RESET_IND, &macCmd) == LORAMAC_COMMANDS_SUCCESS )\r\n                    {\r\n                        LoRaMacCommandsRemoveCmd( macCmd );\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n            case SRV_MAC_LINK_CHECK_ANS:\r\n            {\r\n                if( LoRaMacConfirmQueueIsCmdActive( MLME_LINK_CHECK ) == true )\r\n                {\r\n                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_LINK_CHECK );\r\n                    MacCtx.MlmeConfirm.DemodMargin = payload[macIndex++];\r\n                    MacCtx.MlmeConfirm.NbGateways = payload[macIndex++];\r\n                }\r\n                break;\r\n            }\r\n            case SRV_MAC_LINK_ADR_REQ:\r\n            {\r\n                LinkAdrReqParams_t linkAdrReq;\r\n                int8_t linkAdrDatarate = DR_0;\r\n                int8_t linkAdrTxPower = TX_POWER_0;\r\n                uint8_t linkAdrNbRep = 0;\r\n                uint8_t linkAdrNbBytesParsed = 0;\r\n\r\n                // The end node is allowed to process one block of LinkAdrRequests.\r\n                // It must ignore subsequent blocks\r\n                if( adrBlockFound == false )\r\n                {\r\n                    adrBlockFound = true;\r\n\r\n                    do\r\n                    {\r\n                        // Fill parameter structure\r\n                        linkAdrReq.Payload = &payload[macIndex - 1];\r\n                        linkAdrReq.AdrEnabled = Nvm.MacGroup2.AdrCtrlOn;\r\n                        linkAdrReq.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;\r\n                        linkAdrReq.CurrentDatarate = Nvm.MacGroup1.ChannelsDatarate;\r\n                        linkAdrReq.CurrentTxPower = Nvm.MacGroup1.ChannelsTxPower;\r\n                        linkAdrReq.CurrentNbRep = Nvm.MacGroup2.MacParams.ChannelsNbTrans;\r\n                        linkAdrReq.Version = Nvm.MacGroup2.Version;\r\n\r\n                        // There is a fundamental difference in reporting the status\r\n                        // of the LinkAdrRequests when ADR is on or off. When ADR is on, every\r\n                        // LinkAdrAns contains the same value. This does not hold when ADR is off,\r\n                        // where every LinkAdrAns requires an individual status.\r\n                        if( Nvm.MacGroup2.AdrCtrlOn == true )\r\n                        {\r\n                            // When ADR is on, the function RegionLinkAdrReq will take care\r\n                            // about the parsing and interpretation of the LinkAdrRequest block and\r\n                            // it provides one status which shall be applied to every LinkAdrAns\r\n                            linkAdrReq.PayloadSize = commandsSize - ( macIndex - 1 );\r\n                        }\r\n                        else\r\n                        {\r\n                            // When ADR is off, this function will loop over the individual LinkAdrRequests\r\n                            // and will call RegionLinkAdrReq for each individually, as every request\r\n                            // requires an individual answer.\r\n                            // When ADR is off, the function RegionLinkAdrReq ignores the new values for\r\n                            // ChannelsDatarate, ChannelsTxPower and ChannelsNbTrans.\r\n                            linkAdrReq.PayloadSize = 5;\r\n                        }\r\n\r\n                        // Process the ADR requests\r\n                        status = RegionLinkAdrReq( Nvm.MacGroup2.Region, &linkAdrReq, &linkAdrDatarate,\r\n                                                &linkAdrTxPower, &linkAdrNbRep, &linkAdrNbBytesParsed );\r\n\r\n                        if( ( status & 0x07 ) == 0x07 )\r\n                        {\r\n                            // Set the status that the datarate has been increased\r\n                            if( linkAdrDatarate > Nvm.MacGroup1.ChannelsDatarate )\r\n                            {\r\n                                Nvm.MacGroup2.ChannelsDatarateChangedLinkAdrReq = true;\r\n                            }\r\n                            Nvm.MacGroup1.ChannelsDatarate = linkAdrDatarate;\r\n                            Nvm.MacGroup1.ChannelsTxPower = linkAdrTxPower;\r\n                            Nvm.MacGroup2.MacParams.ChannelsNbTrans = linkAdrNbRep;\r\n                        }\r\n\r\n                        // Add the answers to the buffer\r\n                        for( uint8_t i = 0; i < ( linkAdrNbBytesParsed / 5 ); i++ )\r\n                        {\r\n                            LoRaMacCommandsAddCmd( MOTE_MAC_LINK_ADR_ANS, &status, 1 );\r\n                        }\r\n                        // Update MAC index\r\n                        macIndex += linkAdrNbBytesParsed - 1;\r\n\r\n                        // Check to prevent invalid access\r\n                        if( macIndex >= commandsSize )\r\n                            break;\r\n\r\n                    } while( payload[macIndex++] == SRV_MAC_LINK_ADR_REQ );\r\n\r\n                    if( macIndex < commandsSize )\r\n                    {\r\n                        // Decrease the index such that it points to the next MAC command\r\n                        macIndex--;\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    // Increase the index by the MAC command size (without command)\r\n                    macIndex += 4;\r\n                }\r\n                break;\r\n            }\r\n            case SRV_MAC_DUTY_CYCLE_REQ:\r\n            {\r\n                Nvm.MacGroup2.MaxDCycle = payload[macIndex++] & 0x0F;\r\n                Nvm.MacGroup2.AggregatedDCycle = 1 << Nvm.MacGroup2.MaxDCycle;\r\n                LoRaMacCommandsAddCmd( MOTE_MAC_DUTY_CYCLE_ANS, macCmdPayload, 0 );\r\n                break;\r\n            }\r\n            case SRV_MAC_RX_PARAM_SETUP_REQ:\r\n            {\r\n                RxParamSetupReqParams_t rxParamSetupReq;\r\n                status = 0x07;\r\n\r\n                rxParamSetupReq.DrOffset = ( payload[macIndex] >> 4 ) & 0x07;\r\n                rxParamSetupReq.Datarate = payload[macIndex] & 0x0F;\r\n                macIndex++;\r\n\r\n                rxParamSetupReq.Frequency = ( uint32_t ) payload[macIndex++];\r\n                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 8;\r\n                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 16;\r\n                rxParamSetupReq.Frequency *= 100;\r\n\r\n                // Perform request on region\r\n                status = RegionRxParamSetupReq( Nvm.MacGroup2.Region, &rxParamSetupReq );\r\n\r\n                if( ( status & 0x07 ) == 0x07 )\r\n                {\r\n                    Nvm.MacGroup2.MacParams.Rx2Channel.Datarate = rxParamSetupReq.Datarate;\r\n                    Nvm.MacGroup2.MacParams.RxCChannel.Datarate = rxParamSetupReq.Datarate;\r\n                    Nvm.MacGroup2.MacParams.Rx2Channel.Frequency = rxParamSetupReq.Frequency;\r\n                    Nvm.MacGroup2.MacParams.RxCChannel.Frequency = rxParamSetupReq.Frequency;\r\n                    Nvm.MacGroup2.MacParams.Rx1DrOffset = rxParamSetupReq.DrOffset;\r\n                }\r\n                macCmdPayload[0] = status;\r\n                LoRaMacCommandsAddCmd( MOTE_MAC_RX_PARAM_SETUP_ANS, macCmdPayload, 1 );\r\n                break;\r\n            }\r\n            case SRV_MAC_DEV_STATUS_REQ:\r\n            {\r\n                uint8_t batteryLevel = BAT_LEVEL_NO_MEASURE;\r\n                if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->GetBatteryLevel != NULL ) )\r\n                {\r\n                    batteryLevel = MacCtx.MacCallbacks->GetBatteryLevel( );\r\n                }\r\n                macCmdPayload[0] = batteryLevel;\r\n                macCmdPayload[1] = ( uint8_t )( snr & 0x3F );\r\n                LoRaMacCommandsAddCmd( MOTE_MAC_DEV_STATUS_ANS, macCmdPayload, 2 );\r\n                break;\r\n            }\r\n            case SRV_MAC_NEW_CHANNEL_REQ:\r\n            {\r\n                NewChannelReqParams_t newChannelReq;\r\n                ChannelParams_t chParam;\r\n                status = 0x03;\r\n\r\n                newChannelReq.ChannelId = payload[macIndex++];\r\n                newChannelReq.NewChannel = &chParam;\r\n\r\n                chParam.Frequency = ( uint32_t ) payload[macIndex++];\r\n                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 8;\r\n                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 16;\r\n                chParam.Frequency *= 100;\r\n                chParam.Rx1Frequency = 0;\r\n                chParam.DrRange.Value = payload[macIndex++];\r\n\r\n                status = ( uint8_t )RegionNewChannelReq( Nvm.MacGroup2.Region, &newChannelReq );\r\n\r\n                if( ( int8_t )status >= 0 )\r\n                {\r\n                    macCmdPayload[0] = status;\r\n                    LoRaMacCommandsAddCmd( MOTE_MAC_NEW_CHANNEL_ANS, macCmdPayload, 1 );\r\n                }\r\n                break;\r\n            }\r\n            case SRV_MAC_RX_TIMING_SETUP_REQ:\r\n            {\r\n                uint8_t delay = payload[macIndex++] & 0x0F;\r\n\r\n                if( delay == 0 )\r\n                {\r\n                    delay++;\r\n                }\r\n                Nvm.MacGroup2.MacParams.ReceiveDelay1 = delay * 1000;\r\n                Nvm.MacGroup2.MacParams.ReceiveDelay2 = Nvm.MacGroup2.MacParams.ReceiveDelay1 + 1000;\r\n                LoRaMacCommandsAddCmd( MOTE_MAC_RX_TIMING_SETUP_ANS, macCmdPayload, 0 );\r\n                break;\r\n            }\r\n            case SRV_MAC_TX_PARAM_SETUP_REQ:\r\n            {\r\n                TxParamSetupReqParams_t txParamSetupReq;\r\n                GetPhyParams_t getPhy;\r\n                PhyParam_t phyParam;\r\n                uint8_t eirpDwellTime = payload[macIndex++];\r\n\r\n                txParamSetupReq.UplinkDwellTime = 0;\r\n                txParamSetupReq.DownlinkDwellTime = 0;\r\n\r\n                if( ( eirpDwellTime & 0x20 ) == 0x20 )\r\n                {\r\n                    txParamSetupReq.DownlinkDwellTime = 1;\r\n                }\r\n                if( ( eirpDwellTime & 0x10 ) == 0x10 )\r\n                {\r\n                    txParamSetupReq.UplinkDwellTime = 1;\r\n                }\r\n                txParamSetupReq.MaxEirp = eirpDwellTime & 0x0F;\r\n\r\n                // Check the status for correctness\r\n                if( RegionTxParamSetupReq( Nvm.MacGroup2.Region, &txParamSetupReq ) != -1 )\r\n                {\r\n                    // Accept command\r\n                    Nvm.MacGroup2.MacParams.UplinkDwellTime = txParamSetupReq.UplinkDwellTime;\r\n                    Nvm.MacGroup2.MacParams.DownlinkDwellTime = txParamSetupReq.DownlinkDwellTime;\r\n                    Nvm.MacGroup2.MacParams.MaxEirp = LoRaMacMaxEirpTable[txParamSetupReq.MaxEirp];\r\n                    // Update the datarate in case of the new configuration limits it\r\n                    getPhy.Attribute = PHY_MIN_TX_DR;\r\n                    getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;\r\n                    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );\r\n                    Nvm.MacGroup1.ChannelsDatarate = MAX( Nvm.MacGroup1.ChannelsDatarate, ( int8_t )phyParam.Value );\r\n\r\n                    // Add command response\r\n                    LoRaMacCommandsAddCmd( MOTE_MAC_TX_PARAM_SETUP_ANS, macCmdPayload, 0 );\r\n                }\r\n                break;\r\n            }\r\n            case SRV_MAC_REKEY_CONF:\r\n            {\r\n                uint8_t serverMinorVersion = payload[macIndex++];\r\n\r\n                // Compare own LoRaWAN Version with server's\r\n                if( Nvm.MacGroup2.Version.Fields.Minor >= serverMinorVersion )\r\n                {\r\n                    // If they equal remove the sticky RekeyInd MAC-Command.\r\n                    if( LoRaMacCommandsGetCmd( MOTE_MAC_REKEY_IND, &macCmd) == LORAMAC_COMMANDS_SUCCESS )\r\n                    {\r\n                        LoRaMacCommandsRemoveCmd( macCmd );\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n            case SRV_MAC_DL_CHANNEL_REQ:\r\n            {\r\n                DlChannelReqParams_t dlChannelReq;\r\n                status = 0x03;\r\n\r\n                dlChannelReq.ChannelId = payload[macIndex++];\r\n                dlChannelReq.Rx1Frequency = ( uint32_t ) payload[macIndex++];\r\n                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 8;\r\n                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 16;\r\n                dlChannelReq.Rx1Frequency *= 100;\r\n\r\n                status = ( uint8_t )RegionDlChannelReq( Nvm.MacGroup2.Region, &dlChannelReq );\r\n\r\n                if( ( int8_t )status >= 0 )\r\n                {\r\n                    macCmdPayload[0] = status;\r\n                    LoRaMacCommandsAddCmd( MOTE_MAC_DL_CHANNEL_ANS, macCmdPayload, 1 );\r\n                }\r\n                break;\r\n            }\r\n            case SRV_MAC_ADR_PARAM_SETUP_REQ:\r\n            {\r\n                /* ADRParamSetupReq Payload:  ADRparam\r\n                 * +----------------+---------------+\r\n                 * | 7:4 Limit_exp  | 3:0 Delay_exp |\r\n                 * +----------------+---------------+\r\n                 */\r\n\r\n                uint8_t delayExp = 0x0F & payload[macIndex];\r\n                uint8_t limitExp = 0x0F & ( payload[macIndex] >> 4 );\r\n                macIndex++;\r\n\r\n                // ADR_ACK_ DELAY = 2^Delay_exp\r\n                Nvm.MacGroup2.MacParams.AdrAckDelay = 0x01 << delayExp;\r\n\r\n                // ADR_ACK_LIMIT = 2^Limit_exp\r\n                Nvm.MacGroup2.MacParams.AdrAckLimit = 0x01 << limitExp;\r\n\r\n                LoRaMacCommandsAddCmd( MOTE_MAC_ADR_PARAM_SETUP_ANS, macCmdPayload, 0 );\r\n                break;\r\n            }\r\n            case SRV_MAC_FORCE_REJOIN_REQ:\r\n            {\r\n                /* ForceRejoinReq Payload:\r\n                 * +--------------+------------------+-------+----------------+--------+\r\n                 * | 13:11 Period | 10:8 Max_Retries | 7 RFU | 6:4 RejoinType | 3:0 DR |\r\n                 * +--------------+------------------+-------+----------------+--------+\r\n                 */\r\n\r\n                // Parse payload\r\n                uint8_t period = ( 0x38 & payload[macIndex] ) >> 3;\r\n                Nvm.MacGroup2.ForceRejoinMaxRetries = 0x07 & payload[macIndex];\r\n                macIndex++;\r\n                Nvm.MacGroup2.ForceRejoinType = ( 0x70 & payload[macIndex] ) >> 4;\r\n                Nvm.MacGroup1.ChannelsDatarate = 0x0F & payload[macIndex];\r\n                macIndex ++;\r\n\r\n                // Calc delay between retransmissions: 32 seconds x 2^Period + Rand32\r\n                uint32_t rejoinCycleInSec = 32 * ( 0x01 << period ) + randr( 0, 32 );\r\n\r\n                MacCtx.ForceRejonCycleTime = 0;\r\n                Nvm.MacGroup1.ForceRejoinRetriesCounter = 0;\r\n                ConvertRejoinCycleTime( rejoinCycleInSec, &MacCtx.ForceRejonCycleTime );\r\n                OnForceRejoinReqCycleTimerEvent( NULL );\r\n                break;\r\n            }\r\n            case SRV_MAC_REJOIN_PARAM_REQ:\r\n            {\r\n                /* RejoinParamSetupReq Payload:\r\n                 * +----------------+---------------+\r\n                 * | 7:4 MaxTimeN   | 3:0 MaxCountN |\r\n                 * +----------------+---------------+\r\n                 */\r\n                uint8_t maxCountN = 0x0F & payload[macIndex];\r\n                uint8_t maxTimeN = 0x0F & ( payload[macIndex] >> 4 );\r\n                uint32_t cycleInSec = 0x01 << ( maxTimeN + 10 );\r\n                uint32_t timeInMs = 0;\r\n                uint16_t uplinkLimit = 0x01 << ( maxCountN + 4 );\r\n                macIndex++;\r\n                macCmdPayload[0] = 0;\r\n\r\n                if( ConvertRejoinCycleTime( cycleInSec, &timeInMs ) == true )\r\n                {\r\n                    // Calc delay between retransmissions: 2^(maxTimeN+10)\r\n                    Nvm.MacGroup2.Rejoin0CycleInSec = cycleInSec;\r\n                    // Calc number if uplinks without rejoin request: 2^(maxCountN+4)\r\n                    Nvm.MacGroup2.Rejoin0UplinksLimit = uplinkLimit;\r\n                    MacCtx.Rejoin0CycleTime = timeInMs;\r\n\r\n                    macCmdPayload[0] = 0x01;\r\n                    TimerStop( &MacCtx.Rejoin0CycleTimer );\r\n                    TimerSetValue( &MacCtx.Rejoin0CycleTimer, MacCtx.Rejoin0CycleTime );\r\n                    TimerStart( &MacCtx.Rejoin0CycleTimer );\r\n                }\r\n                LoRaMacCommandsAddCmd( MOTE_MAC_REJOIN_PARAM_ANS, macCmdPayload, 1 );\r\n                break;\r\n             }\r\n            case SRV_MAC_DEVICE_MODE_CONF:\r\n            {\r\n                // 1 byte payload which we do not handle.\r\n                macIndex++;\r\n                if( LoRaMacCommandsGetCmd( MOTE_MAC_DEVICE_MODE_IND, &macCmd) == LORAMAC_COMMANDS_SUCCESS )\r\n                {\r\n                    LoRaMacCommandsRemoveCmd( macCmd );\r\n                }\r\n                break;\r\n            }\r\n            case SRV_MAC_DEVICE_TIME_ANS:\r\n            {\r\n                // The mote time can be updated only when the time is received in classA\r\n                // receive windows only.\r\n                if( LoRaMacConfirmQueueIsCmdActive( MLME_DEVICE_TIME ) == true )\r\n                {\r\n                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_DEVICE_TIME );\r\n\r\n                    SysTime_t gpsEpochTime = { 0 };\r\n                    SysTime_t sysTime = { 0 };\r\n                    SysTime_t sysTimeCurrent = { 0 };\r\n\r\n                    gpsEpochTime.Seconds = ( uint32_t )payload[macIndex++];\r\n                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 8;\r\n                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 16;\r\n                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 24;\r\n                    gpsEpochTime.SubSeconds = payload[macIndex++];\r\n\r\n                    // Convert the fractional second received in ms\r\n                    // round( pow( 0.5, 8.0 ) * 1000 ) = 3.90625\r\n                    gpsEpochTime.SubSeconds = ( int16_t )( ( ( int32_t )gpsEpochTime.SubSeconds * 1000 ) >> 8 );\r\n\r\n                    // Copy received GPS Epoch time into system time\r\n                    sysTime = gpsEpochTime;\r\n                    // Add Unix to Gps epoch offset. The system time is based on Unix time.\r\n                    sysTime.Seconds += UNIX_GPS_EPOCH_OFFSET;\r\n\r\n                    // Compensate time difference between Tx Done time and now\r\n                    sysTimeCurrent = SysTimeGet( );\r\n                    sysTime = SysTimeAdd( sysTimeCurrent, SysTimeSub( sysTime, MacCtx.LastTxSysTime ) );\r\n\r\n                    // Apply the new system time.\r\n                    SysTimeSet( sysTime );\r\n                    LoRaMacClassBDeviceTimeAns( );\r\n                    MacCtx.McpsIndication.DeviceTimeAnsReceived = true;\r\n                }\r\n                else\r\n                {\r\n                    // Incase of other receive windows the Device Time Answer is not received.\r\n                    MacCtx.McpsIndication.DeviceTimeAnsReceived = false;\r\n                }\r\n                break;\r\n            }\r\n            case SRV_MAC_PING_SLOT_INFO_ANS:\r\n            {\r\n                if( LoRaMacConfirmQueueIsCmdActive( MLME_PING_SLOT_INFO ) == true )\r\n                {\r\n                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_PING_SLOT_INFO );\r\n                    // According to the specification, it is not allowed to process this answer in\r\n                    // a ping or multicast slot\r\n                    if( ( MacCtx.RxSlot != RX_SLOT_WIN_CLASS_B_PING_SLOT ) && ( MacCtx.RxSlot != RX_SLOT_WIN_CLASS_B_MULTICAST_SLOT ) )\r\n                    {\r\n                        LoRaMacClassBPingSlotInfoAns( );\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n            case SRV_MAC_PING_SLOT_CHANNEL_REQ:\r\n            {\r\n                uint8_t status = 0x03;\r\n                uint32_t frequency = 0;\r\n                uint8_t datarate;\r\n\r\n                frequency = ( uint32_t )payload[macIndex++];\r\n                frequency |= ( uint32_t )payload[macIndex++] << 8;\r\n                frequency |= ( uint32_t )payload[macIndex++] << 16;\r\n                frequency *= 100;\r\n                datarate = payload[macIndex++] & 0x0F;\r\n\r\n                status = LoRaMacClassBPingSlotChannelReq( datarate, frequency );\r\n                macCmdPayload[0] = status;\r\n                LoRaMacCommandsAddCmd( MOTE_MAC_PING_SLOT_CHANNEL_ANS, macCmdPayload, 1 );\r\n                break;\r\n            }\r\n            case SRV_MAC_BEACON_TIMING_ANS:\r\n            {\r\n                if( LoRaMacConfirmQueueIsCmdActive( MLME_BEACON_TIMING ) == true )\r\n                {\r\n                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_BEACON_TIMING );\r\n                    uint16_t beaconTimingDelay = 0;\r\n                    uint8_t beaconTimingChannel = 0;\r\n\r\n                    beaconTimingDelay = ( uint16_t )payload[macIndex++];\r\n                    beaconTimingDelay |= ( uint16_t )payload[macIndex++] << 8;\r\n                    beaconTimingChannel = payload[macIndex++];\r\n\r\n                    LoRaMacClassBBeaconTimingAns( beaconTimingDelay, beaconTimingChannel, RxDoneParams.LastRxDone );\r\n                }\r\n                break;\r\n            }\r\n            case SRV_MAC_BEACON_FREQ_REQ:\r\n                {\r\n                    uint32_t frequency = 0;\r\n\r\n                    frequency = ( uint32_t )payload[macIndex++];\r\n                    frequency |= ( uint32_t )payload[macIndex++] << 8;\r\n                    frequency |= ( uint32_t )payload[macIndex++] << 16;\r\n                    frequency *= 100;\r\n\r\n                    if( LoRaMacClassBBeaconFreqReq( frequency ) == true )\r\n                    {\r\n                        macCmdPayload[0] = 1;\r\n                    }\r\n                    else\r\n                    {\r\n                        macCmdPayload[0] = 0;\r\n                    }\r\n                    LoRaMacCommandsAddCmd( MOTE_MAC_BEACON_FREQ_ANS, macCmdPayload, 1 );\r\n                }\r\n                break;\r\n            default:\r\n                // Unknown command. ABORT MAC commands processing\r\n                return;\r\n        }\r\n    }\r\n}\r\n\r\nLoRaMacStatus_t Send( LoRaMacHeader_t* macHdr, uint8_t fPort, void* fBuffer, uint16_t fBufferSize )\r\n{\r\n    LoRaMacFrameCtrl_t fCtrl;\r\n    LoRaMacStatus_t status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n    int8_t datarate = Nvm.MacGroup1.ChannelsDatarate;\r\n    int8_t txPower = Nvm.MacGroup1.ChannelsTxPower;\r\n    uint32_t adrAckCounter = Nvm.MacGroup1.AdrAckCounter;\r\n    CalcNextAdrParams_t adrNext;\r\n\r\n    // Check if we are joined\r\n    if( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_NONE )\r\n    {\r\n        return LORAMAC_STATUS_NO_NETWORK_JOINED;\r\n    }\r\n    if( Nvm.MacGroup2.MaxDCycle == 0 )\r\n    {\r\n        Nvm.MacGroup1.AggregatedTimeOff = 0;\r\n    }\r\n\r\n    fCtrl.Value = 0;\r\n    fCtrl.Bits.FOptsLen      = 0;\r\n    fCtrl.Bits.Adr           = Nvm.MacGroup2.AdrCtrlOn;\r\n\r\n    // Check class b\r\n    if( Nvm.MacGroup2.DeviceClass == CLASS_B )\r\n    {\r\n        fCtrl.Bits.FPending      = 1;\r\n    }\r\n    else\r\n    {\r\n        fCtrl.Bits.FPending      = 0;\r\n    }\r\n\r\n    // Check server ack\r\n    if( Nvm.MacGroup1.SrvAckRequested == true )\r\n    {\r\n        fCtrl.Bits.Ack = 1;\r\n    }\r\n\r\n    // ADR next request\r\n    adrNext.UpdateChanMask = true;\r\n    adrNext.AdrEnabled = fCtrl.Bits.Adr;\r\n    adrNext.AdrAckCounter = Nvm.MacGroup1.AdrAckCounter;\r\n    adrNext.AdrAckLimit = Nvm.MacGroup2.MacParams.AdrAckLimit;\r\n    adrNext.AdrAckDelay = Nvm.MacGroup2.MacParams.AdrAckDelay;\r\n    adrNext.Datarate = Nvm.MacGroup1.ChannelsDatarate;\r\n    adrNext.TxPower = Nvm.MacGroup1.ChannelsTxPower;\r\n    adrNext.NbTrans = Nvm.MacGroup2.MacParams.ChannelsNbTrans;\r\n    adrNext.UplinkDwellTime =  Nvm.MacGroup2.MacParams.UplinkDwellTime;\r\n    adrNext.Region = Nvm.MacGroup2.Region;\r\n\r\n    fCtrl.Bits.AdrAckReq = LoRaMacAdrCalcNext( &adrNext, &Nvm.MacGroup1.ChannelsDatarate,\r\n                                               &Nvm.MacGroup1.ChannelsTxPower,\r\n                                               &Nvm.MacGroup2.MacParams.ChannelsNbTrans, &adrAckCounter );\r\n\r\n    // Prepare the frame\r\n    status = PrepareFrame( macHdr, &fCtrl, fPort, fBuffer, fBufferSize );\r\n\r\n    // Validate status\r\n    if( ( status == LORAMAC_STATUS_OK ) || ( status == LORAMAC_STATUS_SKIPPED_APP_DATA ) )\r\n    {\r\n        // Schedule frame, do not allow delayed transmissions\r\n        status = ScheduleTx( false );\r\n    }\r\n\r\n    // Post processing\r\n    if( status != LORAMAC_STATUS_OK )\r\n    {\r\n        // Bad case - restore\r\n        // Store local variables\r\n        Nvm.MacGroup1.ChannelsDatarate = datarate;\r\n        Nvm.MacGroup1.ChannelsTxPower = txPower;\r\n    }\r\n    else\r\n    {\r\n        // Good case\r\n        Nvm.MacGroup1.SrvAckRequested = false;\r\n        Nvm.MacGroup1.AdrAckCounter = adrAckCounter;\r\n        // Remove all none sticky MAC commands\r\n        if( LoRaMacCommandsRemoveNoneStickyCmds( ) != LORAMAC_COMMANDS_SUCCESS )\r\n        {\r\n            return LORAMAC_STATUS_MAC_COMMAD_ERROR;\r\n        }\r\n    }\r\n    return status;\r\n}\r\n\r\nLoRaMacStatus_t SendReJoinReq( JoinReqIdentifier_t joinReqType )\r\n{\r\n    LoRaMacStatus_t status = LORAMAC_STATUS_OK;\r\n    LoRaMacHeader_t macHdr;\r\n    macHdr.Value = 0;\r\n    bool allowDelayedTx = true;\r\n\r\n    // Setup join/rejoin message\r\n    switch( joinReqType )\r\n    {\r\n        case REJOIN_REQ_1:\r\n        {\r\n            Nvm.MacGroup2.IsRejoinAcceptPending = true;\r\n\r\n            MacCtx.TxMsg.Type = LORAMAC_MSG_TYPE_RE_JOIN_1;\r\n            MacCtx.TxMsg.Message.ReJoin1.Buffer = MacCtx.PktBuffer;\r\n            MacCtx.TxMsg.Message.ReJoin1.BufSize = LORAMAC_PHY_MAXPAYLOAD;\r\n\r\n            macHdr.Bits.MType = FRAME_TYPE_REJOIN;\r\n            MacCtx.TxMsg.Message.ReJoin1.MHDR.Value = macHdr.Value;\r\n\r\n            MacCtx.TxMsg.Message.ReJoin1.ReJoinType = 1;\r\n\r\n            memcpy1( MacCtx.TxMsg.Message.ReJoin1.JoinEUI, SecureElementGetJoinEui( ), LORAMAC_JOIN_EUI_FIELD_SIZE );\r\n            memcpy1( MacCtx.TxMsg.Message.ReJoin1.DevEUI, SecureElementGetDevEui( ), LORAMAC_DEV_EUI_FIELD_SIZE );\r\n\r\n            if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoGetRJcount( RJ_COUNT_1, &MacCtx.TxMsg.Message.ReJoin1.RJcount1 ) )\r\n            {\r\n                return LORAMAC_STATUS_CRYPTO_ERROR;\r\n            }\r\n\r\n            break;\r\n        }\r\n        case REJOIN_REQ_0:\r\n        case REJOIN_REQ_2:\r\n        {\r\n            if( joinReqType == REJOIN_REQ_0 )\r\n            {\r\n                MacCtx.TxMsg.Message.ReJoin0or2.ReJoinType = 0;\r\n            }\r\n            else\r\n            {\r\n                MacCtx.TxMsg.Message.ReJoin0or2.ReJoinType = 2;\r\n            }\r\n\r\n            Nvm.MacGroup2.IsRejoinAcceptPending = true;\r\n\r\n            MacCtx.TxMsg.Type = LORAMAC_MSG_TYPE_RE_JOIN_0_2;\r\n            MacCtx.TxMsg.Message.ReJoin0or2.Buffer = MacCtx.PktBuffer;\r\n            MacCtx.TxMsg.Message.ReJoin0or2.BufSize = LORAMAC_PHY_MAXPAYLOAD;\r\n\r\n            macHdr.Bits.MType = FRAME_TYPE_REJOIN;\r\n            MacCtx.TxMsg.Message.ReJoin0or2.MHDR.Value = macHdr.Value;\r\n\r\n            MacCtx.TxMsg.Message.ReJoin0or2.NetID[0] = Nvm.MacGroup2.NetID & 0xFF;\r\n            MacCtx.TxMsg.Message.ReJoin0or2.NetID[1] = ( Nvm.MacGroup2.NetID >> 8 ) & 0xFF;\r\n            MacCtx.TxMsg.Message.ReJoin0or2.NetID[2] = ( Nvm.MacGroup2.NetID >> 16 ) & 0xFF;\r\n\r\n            memcpy1( MacCtx.TxMsg.Message.ReJoin0or2.DevEUI, SecureElementGetDevEui( ), LORAMAC_DEV_EUI_FIELD_SIZE );\r\n\r\n            if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoGetRJcount( RJ_COUNT_0, &MacCtx.TxMsg.Message.ReJoin0or2.RJcount0 ) )\r\n            {\r\n                return LORAMAC_STATUS_CRYPTO_ERROR;\r\n            }\r\n\r\n            break;\r\n        }\r\n        case JOIN_REQ:\r\n        {\r\n            SwitchClass( CLASS_A );\r\n\r\n            MacCtx.TxMsg.Type = LORAMAC_MSG_TYPE_JOIN_REQUEST;\r\n            MacCtx.TxMsg.Message.JoinReq.Buffer = MacCtx.PktBuffer;\r\n            MacCtx.TxMsg.Message.JoinReq.BufSize = LORAMAC_PHY_MAXPAYLOAD;\r\n\r\n            macHdr.Bits.MType = FRAME_TYPE_JOIN_REQ;\r\n            MacCtx.TxMsg.Message.JoinReq.MHDR.Value = macHdr.Value;\r\n\r\n            memcpy1( MacCtx.TxMsg.Message.JoinReq.JoinEUI, SecureElementGetJoinEui( ), LORAMAC_JOIN_EUI_FIELD_SIZE );\r\n            memcpy1( MacCtx.TxMsg.Message.JoinReq.DevEUI, SecureElementGetDevEui( ), LORAMAC_DEV_EUI_FIELD_SIZE );\r\n\r\n            allowDelayedTx = false;\r\n\r\n            break;\r\n        }\r\n        default:\r\n            status = LORAMAC_STATUS_SERVICE_UNKNOWN;\r\n            break;\r\n    }\r\n\r\n    // Schedule frame\r\n    status = ScheduleTx( allowDelayedTx );\r\n    return status;\r\n}\r\n\r\nstatic LoRaMacStatus_t CheckForClassBCollision( void )\r\n{\r\n    if( LoRaMacClassBIsBeaconExpected( ) == true )\r\n    {\r\n        return LORAMAC_STATUS_BUSY_BEACON_RESERVED_TIME;\r\n    }\r\n\r\n    if( Nvm.MacGroup2.DeviceClass == CLASS_B )\r\n    {\r\n        if( LoRaMacClassBIsPingExpected( ) == true )\r\n        {\r\n            return LORAMAC_STATUS_BUSY_PING_SLOT_WINDOW_TIME;\r\n        }\r\n        else if( LoRaMacClassBIsMulticastExpected( ) == true )\r\n        {\r\n            return LORAMAC_STATUS_BUSY_PING_SLOT_WINDOW_TIME;\r\n        }\r\n    }\r\n    return LORAMAC_STATUS_OK;\r\n}\r\n\r\nstatic void ComputeRxWindowParameters( void )\r\n{\r\n    // Compute Rx1 windows parameters\r\n    RegionComputeRxWindowParameters( Nvm.MacGroup2.Region,\r\n                                     RegionApplyDrOffset( Nvm.MacGroup2.Region,\r\n                                                          Nvm.MacGroup2.MacParams.DownlinkDwellTime,\r\n                                                          Nvm.MacGroup1.ChannelsDatarate,\r\n                                                          Nvm.MacGroup2.MacParams.Rx1DrOffset ),\r\n                                     Nvm.MacGroup2.MacParams.MinRxSymbols,\r\n                                     Nvm.MacGroup2.MacParams.SystemMaxRxError,\r\n                                     &MacCtx.RxWindow1Config );\r\n    // Compute Rx2 windows parameters\r\n    RegionComputeRxWindowParameters( Nvm.MacGroup2.Region,\r\n                                     Nvm.MacGroup2.MacParams.Rx2Channel.Datarate,\r\n                                     Nvm.MacGroup2.MacParams.MinRxSymbols,\r\n                                     Nvm.MacGroup2.MacParams.SystemMaxRxError,\r\n                                     &MacCtx.RxWindow2Config );\r\n\r\n    // Default setup, in case the device joined\r\n    MacCtx.RxWindow1Delay = Nvm.MacGroup2.MacParams.ReceiveDelay1 + MacCtx.RxWindow1Config.WindowOffset;\r\n    MacCtx.RxWindow2Delay = Nvm.MacGroup2.MacParams.ReceiveDelay2 + MacCtx.RxWindow2Config.WindowOffset;\r\n\r\n    if( MacCtx.TxMsg.Type != LORAMAC_MSG_TYPE_DATA )\r\n    {\r\n        MacCtx.RxWindow1Delay = Nvm.MacGroup2.MacParams.JoinAcceptDelay1 + MacCtx.RxWindow1Config.WindowOffset;\r\n        MacCtx.RxWindow2Delay = Nvm.MacGroup2.MacParams.JoinAcceptDelay2 + MacCtx.RxWindow2Config.WindowOffset;\r\n    }\r\n}\r\n\r\nstatic LoRaMacStatus_t VerifyTxFrame( void )\r\n{\r\n    size_t macCmdsSize = 0;\r\n\r\n    if( Nvm.MacGroup2.NetworkActivation != ACTIVATION_TYPE_NONE )\r\n    {\r\n        if( LoRaMacCommandsGetSizeSerializedCmds( &macCmdsSize ) != LORAMAC_COMMANDS_SUCCESS )\r\n        {\r\n            return LORAMAC_STATUS_MAC_COMMAD_ERROR;\r\n        }\r\n\r\n        if( ValidatePayloadLength( MacCtx.AppDataSize, Nvm.MacGroup1.ChannelsDatarate, macCmdsSize ) == false )\r\n        {\r\n            return LORAMAC_STATUS_LENGTH_ERROR;\r\n        }\r\n    }\r\n    return LORAMAC_STATUS_OK;\r\n}\r\n\r\nstatic LoRaMacStatus_t SerializeTxFrame( void )\r\n{\r\n    LoRaMacSerializerStatus_t serializeStatus;\r\n\r\n    switch( MacCtx.TxMsg.Type )\r\n    {\r\n        case LORAMAC_MSG_TYPE_JOIN_REQUEST:\r\n            serializeStatus = LoRaMacSerializerJoinRequest( &MacCtx.TxMsg.Message.JoinReq );\r\n            if( LORAMAC_SERIALIZER_SUCCESS != serializeStatus )\r\n            {\r\n                return LORAMAC_STATUS_CRYPTO_ERROR;\r\n            }\r\n            MacCtx.PktBufferLen = MacCtx.TxMsg.Message.JoinReq.BufSize;\r\n            break;\r\n        case LORAMAC_MSG_TYPE_RE_JOIN_1:\r\n            serializeStatus = LoRaMacSerializerReJoinType1( &MacCtx.TxMsg.Message.ReJoin1 );\r\n            if( LORAMAC_SERIALIZER_SUCCESS != serializeStatus )\r\n            {\r\n                return LORAMAC_STATUS_CRYPTO_ERROR;\r\n            }\r\n            MacCtx.PktBufferLen = MacCtx.TxMsg.Message.ReJoin1.BufSize;\r\n            break;\r\n        case LORAMAC_MSG_TYPE_RE_JOIN_0_2:\r\n            serializeStatus = LoRaMacSerializerReJoinType0or2( &MacCtx.TxMsg.Message.ReJoin0or2 );\r\n            if( LORAMAC_SERIALIZER_SUCCESS != serializeStatus )\r\n            {\r\n                return LORAMAC_STATUS_CRYPTO_ERROR;\r\n            }\r\n            MacCtx.PktBufferLen = MacCtx.TxMsg.Message.ReJoin0or2.BufSize;\r\n            break;\r\n        case LORAMAC_MSG_TYPE_DATA:\r\n            serializeStatus = LoRaMacSerializerData( &MacCtx.TxMsg.Message.Data );\r\n            if( LORAMAC_SERIALIZER_SUCCESS != serializeStatus )\r\n            {\r\n                return LORAMAC_STATUS_CRYPTO_ERROR;\r\n            }\r\n            MacCtx.PktBufferLen = MacCtx.TxMsg.Message.Data.BufSize;\r\n            break;\r\n        case LORAMAC_MSG_TYPE_JOIN_ACCEPT:\r\n        case LORAMAC_MSG_TYPE_UNDEF:\r\n        default:\r\n            return LORAMAC_STATUS_PARAMETER_INVALID;\r\n    }\r\n    return LORAMAC_STATUS_OK;\r\n}\r\n\r\nstatic LoRaMacStatus_t ScheduleTx( bool allowDelayedTx )\r\n{\r\n    LoRaMacStatus_t status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n    NextChanParams_t nextChan;\r\n\r\n    // Check class b collisions\r\n    status = CheckForClassBCollision( );\r\n    if( status != LORAMAC_STATUS_OK )\r\n    {\r\n        return status;\r\n    }\r\n\r\n    // Update back-off\r\n    CalculateBackOff( );\r\n\r\n    // Serialize frame\r\n    status = SerializeTxFrame( );\r\n    if( status != LORAMAC_STATUS_OK )\r\n    {\r\n        return status;\r\n    }\r\n\r\n    nextChan.AggrTimeOff = Nvm.MacGroup1.AggregatedTimeOff;\r\n    nextChan.Datarate = Nvm.MacGroup1.ChannelsDatarate;\r\n    nextChan.DutyCycleEnabled = Nvm.MacGroup2.DutyCycleOn;\r\n    nextChan.ElapsedTimeSinceStartUp = SysTimeSub( SysTimeGetMcuTime( ), Nvm.MacGroup2.InitializationTime );\r\n    nextChan.LastAggrTx = Nvm.MacGroup1.LastTxDoneTime;\r\n    nextChan.LastTxIsJoinRequest = false;\r\n    nextChan.Joined = true;\r\n    nextChan.PktLen = MacCtx.PktBufferLen;\r\n\r\n    // Setup the parameters based on the join status\r\n    if( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_NONE )\r\n    {\r\n        nextChan.LastTxIsJoinRequest = true;\r\n        nextChan.Joined = false;\r\n    }\r\n\r\n    // Select channel\r\n    status = RegionNextChannel( Nvm.MacGroup2.Region, &nextChan, &MacCtx.Channel, &MacCtx.DutyCycleWaitTime, &Nvm.MacGroup1.AggregatedTimeOff );\r\n\r\n    if( status != LORAMAC_STATUS_OK )\r\n    {\r\n        if( status == LORAMAC_STATUS_DUTYCYCLE_RESTRICTED )\r\n        {\r\n            if( MacCtx.DutyCycleWaitTime != 0 )\r\n            {\r\n                if( allowDelayedTx == true )\r\n                {\r\n                    // Allow delayed transmissions. We have to allow it in case\r\n                    // the MAC must retransmit a frame with the frame repetitions\r\n                    MacCtx.MacState |= LORAMAC_TX_DELAYED;\r\n                    TimerSetValue( &MacCtx.TxDelayedTimer, MacCtx.DutyCycleWaitTime );\r\n                    TimerStart( &MacCtx.TxDelayedTimer );\r\n                    return LORAMAC_STATUS_OK;\r\n                }\r\n                // Need to delay, but allowDelayedTx does not allow it\r\n                return status;\r\n            }\r\n        }\r\n        else\r\n        {// State where the MAC cannot send a frame\r\n            return status;\r\n        }\r\n    }\r\n\r\n    // Compute window parameters, offsets, rx symbols, system errors etc.\r\n    ComputeRxWindowParameters( );\r\n\r\n    // Verify TX frame\r\n    status = VerifyTxFrame( );\r\n    if( status != LORAMAC_STATUS_OK )\r\n    {\r\n        return status;\r\n    }\r\n\r\n    // Try to send now\r\n    return SendFrameOnChannel( MacCtx.Channel );\r\n}\r\n\r\nstatic LoRaMacStatus_t SecureFrame( uint8_t txDr, uint8_t txCh )\r\n{\r\n    LoRaMacCryptoStatus_t macCryptoStatus = LORAMAC_CRYPTO_ERROR;\r\n    uint32_t fCntUp = 0;\r\n\r\n    switch( MacCtx.TxMsg.Type )\r\n    {\r\n        case LORAMAC_MSG_TYPE_JOIN_REQUEST:\r\n            macCryptoStatus = LoRaMacCryptoPrepareJoinRequest( &MacCtx.TxMsg.Message.JoinReq );\r\n            if( LORAMAC_CRYPTO_SUCCESS != macCryptoStatus )\r\n            {\r\n                return LORAMAC_STATUS_CRYPTO_ERROR;\r\n            }\r\n            MacCtx.PktBufferLen = MacCtx.TxMsg.Message.JoinReq.BufSize;\r\n            break;\r\n        case LORAMAC_MSG_TYPE_RE_JOIN_1:\r\n            macCryptoStatus = LoRaMacCryptoPrepareReJoinType1( &MacCtx.TxMsg.Message.ReJoin1 );\r\n            if( LORAMAC_CRYPTO_SUCCESS != macCryptoStatus )\r\n            {\r\n                return LORAMAC_STATUS_CRYPTO_ERROR;\r\n            }\r\n            MacCtx.PktBufferLen = MacCtx.TxMsg.Message.ReJoin1.BufSize;\r\n            break;\r\n        case LORAMAC_MSG_TYPE_RE_JOIN_0_2:\r\n            macCryptoStatus = LoRaMacCryptoPrepareReJoinType0or2( &MacCtx.TxMsg.Message.ReJoin0or2 );\r\n            if( LORAMAC_CRYPTO_SUCCESS != macCryptoStatus )\r\n            {\r\n                return LORAMAC_STATUS_CRYPTO_ERROR;\r\n            }\r\n            MacCtx.PktBufferLen = MacCtx.TxMsg.Message.ReJoin0or2.BufSize;\r\n            break;\r\n        case LORAMAC_MSG_TYPE_DATA:\r\n\r\n            if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoGetFCntUp( &fCntUp ) )\r\n            {\r\n                return LORAMAC_STATUS_FCNT_HANDLER_ERROR;\r\n            }\r\n\r\n            if( MacCtx.ChannelsNbTransCounter >= 1 )\r\n            {\r\n                fCntUp -= 1;\r\n            }\r\n\r\n            macCryptoStatus = LoRaMacCryptoSecureMessage( fCntUp, txDr, txCh, &MacCtx.TxMsg.Message.Data );\r\n            if( LORAMAC_CRYPTO_SUCCESS != macCryptoStatus )\r\n            {\r\n                return LORAMAC_STATUS_CRYPTO_ERROR;\r\n            }\r\n            MacCtx.PktBufferLen = MacCtx.TxMsg.Message.Data.BufSize;\r\n            break;\r\n        case LORAMAC_MSG_TYPE_JOIN_ACCEPT:\r\n        case LORAMAC_MSG_TYPE_UNDEF:\r\n        default:\r\n            return LORAMAC_STATUS_PARAMETER_INVALID;\r\n    }\r\n    return LORAMAC_STATUS_OK;\r\n}\r\n\r\nstatic void CalculateBackOff( void )\r\n{\r\n    // Make sure that the calculation of the backoff time for the aggregated time off will only be done in\r\n    // case the value is zero. It will be set to zero in the function RegionNextChannel.\r\n    if( Nvm.MacGroup1.AggregatedTimeOff == 0 )\r\n    {\r\n        // Update aggregated time-off. This must be an assignment and no incremental\r\n        // update as we do only calculate the time-off based on the last transmission\r\n        Nvm.MacGroup1.AggregatedTimeOff = ( MacCtx.TxTimeOnAir * Nvm.MacGroup2.AggregatedDCycle - MacCtx.TxTimeOnAir );\r\n    }\r\n}\r\n\r\nstatic void RemoveMacCommands( LoRaMacRxSlot_t rxSlot, LoRaMacFrameCtrl_t fCtrl, Mcps_t request )\r\n{\r\n    if( rxSlot == RX_SLOT_WIN_1 || rxSlot == RX_SLOT_WIN_2  )\r\n    {\r\n        // Remove all sticky MAC commands answers since we can assume\r\n        // that they have been received by the server.\r\n        if( request == MCPS_CONFIRMED )\r\n        {\r\n            if( fCtrl.Bits.Ack == 1 )\r\n            {  // For confirmed uplinks only if we have received an ACK.\r\n                LoRaMacCommandsRemoveStickyAnsCmds( );\r\n            }\r\n        }\r\n        else\r\n        {\r\n            LoRaMacCommandsRemoveStickyAnsCmds( );\r\n        }\r\n    }\r\n}\r\n\r\n\r\nstatic void ResetMacParameters( bool isRejoin )\r\n{\r\n    LoRaMacClassBCallback_t classBCallbacks;\r\n    LoRaMacClassBParams_t classBParams;\r\n\r\n    if( isRejoin == false )\r\n    {\r\n        Nvm.MacGroup2.NetworkActivation = ACTIVATION_TYPE_NONE;\r\n    }\r\n\r\n    // ADR counter\r\n    Nvm.MacGroup1.AdrAckCounter = 0;\r\n\r\n    MacCtx.ChannelsNbTransCounter = 0;\r\n    MacCtx.RetransmitTimeoutRetry = false;\r\n    MacCtx.ResponseTimeoutStartTime = 0;\r\n\r\n    Nvm.MacGroup2.MaxDCycle = 0;\r\n    Nvm.MacGroup2.AggregatedDCycle = 1;\r\n\r\n    Nvm.MacGroup1.ChannelsTxPower = Nvm.MacGroup2.ChannelsTxPowerDefault;\r\n    Nvm.MacGroup1.ChannelsDatarate = Nvm.MacGroup2.ChannelsDatarateDefault;\r\n    Nvm.MacGroup2.MacParams.Rx1DrOffset = Nvm.MacGroup2.MacParamsDefaults.Rx1DrOffset;\r\n    Nvm.MacGroup2.MacParams.Rx2Channel = Nvm.MacGroup2.MacParamsDefaults.Rx2Channel;\r\n    Nvm.MacGroup2.MacParams.RxCChannel = Nvm.MacGroup2.MacParamsDefaults.RxCChannel;\r\n    Nvm.MacGroup2.MacParams.UplinkDwellTime = Nvm.MacGroup2.MacParamsDefaults.UplinkDwellTime;\r\n    Nvm.MacGroup2.MacParams.DownlinkDwellTime = Nvm.MacGroup2.MacParamsDefaults.DownlinkDwellTime;\r\n    Nvm.MacGroup2.MacParams.MaxEirp = Nvm.MacGroup2.MacParamsDefaults.MaxEirp;\r\n    Nvm.MacGroup2.MacParams.AntennaGain = Nvm.MacGroup2.MacParamsDefaults.AntennaGain;\r\n    Nvm.MacGroup2.MacParams.AdrAckLimit = Nvm.MacGroup2.MacParamsDefaults.AdrAckLimit;\r\n    Nvm.MacGroup2.MacParams.AdrAckDelay = Nvm.MacGroup2.MacParamsDefaults.AdrAckDelay;\r\n\r\n    MacCtx.NodeAckRequested = false;\r\n    Nvm.MacGroup1.SrvAckRequested = false;\r\n    Nvm.MacGroup2.ChannelsDatarateChangedLinkAdrReq = false;\r\n    Nvm.MacGroup2.DownlinkReceived = false;\r\n\r\n    Nvm.MacGroup2.Rejoin0UplinksLimit = 0;\r\n    Nvm.MacGroup2.ForceRejoinMaxRetries = 0;\r\n    Nvm.MacGroup2.ForceRejoinType = 0;\r\n    Nvm.MacGroup2.Rejoin0CycleInSec = 0;\r\n    Nvm.MacGroup2.Rejoin1CycleInSec = 0;\r\n    Nvm.MacGroup2.IsRejoin0RequestQueued = 0;\r\n    Nvm.MacGroup2.IsRejoin1RequestQueued = 0;\r\n    Nvm.MacGroup2.IsRejoin2RequestQueued = 0;\r\n\r\n    // Reset to application defaults\r\n    InitDefaultsParams_t params;\r\n    params.Type = INIT_TYPE_RESET_TO_DEFAULT_CHANNELS;\r\n    params.NvmGroup1 = &Nvm.RegionGroup1;\r\n    params.NvmGroup2 = &Nvm.RegionGroup2;\r\n    params.Bands = &RegionBands;\r\n    RegionInitDefaults( Nvm.MacGroup2.Region, &params );\r\n\r\n    // Initialize channel index.\r\n    MacCtx.Channel = 0;\r\n\r\n    // Initialize Rx2 config parameters.\r\n    MacCtx.RxWindow2Config.Channel = MacCtx.Channel;\r\n    MacCtx.RxWindow2Config.Frequency = Nvm.MacGroup2.MacParams.Rx2Channel.Frequency;\r\n    MacCtx.RxWindow2Config.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;\r\n    MacCtx.RxWindow2Config.RxContinuous = false;\r\n    MacCtx.RxWindow2Config.RxSlot = RX_SLOT_WIN_2;\r\n    MacCtx.RxWindow2Config.NetworkActivation = Nvm.MacGroup2.NetworkActivation;\r\n\r\n    // Initialize RxC config parameters.\r\n    MacCtx.RxWindowCConfig = MacCtx.RxWindow2Config;\r\n    MacCtx.RxWindowCConfig.RxContinuous = true;\r\n    MacCtx.RxWindowCConfig.RxSlot = RX_SLOT_WIN_CLASS_C;\r\n\r\n    // Initialize class b\r\n    // Apply callback\r\n    classBCallbacks.GetTemperatureLevel = NULL;\r\n    classBCallbacks.MacProcessNotify = NULL;\r\n\r\n    if( MacCtx.MacCallbacks != NULL )\r\n    {\r\n        classBCallbacks.GetTemperatureLevel = MacCtx.MacCallbacks->GetTemperatureLevel;\r\n        classBCallbacks.MacProcessNotify = MacCtx.MacCallbacks->MacProcessNotify;\r\n    }\r\n\r\n    // Must all be static. Don't use local references.\r\n    classBParams.MlmeIndication = &MacCtx.MlmeIndication;\r\n    classBParams.McpsIndication = &MacCtx.McpsIndication;\r\n    classBParams.MlmeConfirm = &MacCtx.MlmeConfirm;\r\n    classBParams.LoRaMacFlags = &MacCtx.MacFlags;\r\n    classBParams.LoRaMacDevAddr = &Nvm.MacGroup2.DevAddr;\r\n    classBParams.LoRaMacRegion = &Nvm.MacGroup2.Region;\r\n    classBParams.LoRaMacParams = &Nvm.MacGroup2.MacParams;\r\n    classBParams.MulticastChannels = &Nvm.MacGroup2.MulticastChannelList[0];\r\n    classBParams.NetworkActivation = &Nvm.MacGroup2.NetworkActivation;\r\n\r\n    LoRaMacClassBInit( &classBParams, &classBCallbacks, &Nvm.ClassB );\r\n}\r\n\r\nstatic bool IsReJoin0Required( )\r\n{\r\n\r\n    if( ( Nvm.MacGroup2.Rejoin0UplinksLimit == Nvm.MacGroup1.Rejoin0UplinksCounter ) &&\r\n        ( Nvm.MacGroup2.Version.Fields.Minor >= 1 ) &&\r\n        ( Nvm.MacGroup2.Rejoin0UplinksLimit != 0 ) )\r\n    {\r\n        Nvm.MacGroup1.Rejoin0UplinksCounter = 0;\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\n/*!\r\n * \\brief Initializes and opens the reception window\r\n *\r\n * \\param [IN] rxTimer  Window timer to be topped.\r\n * \\param [IN] rxConfig Window parameters to be setup\r\n */\r\nstatic void RxWindowSetup( TimerEvent_t* rxTimer, RxConfigParams_t* rxConfig )\r\n{\r\n    TimerStop( rxTimer );\r\n\r\n    // Ensure the radio is Idle\r\n    Radio.Standby( );\r\n\r\n    if( RegionRxConfig( Nvm.MacGroup2.Region, rxConfig, ( int8_t* )&MacCtx.McpsIndication.RxDatarate ) == true )\r\n    {\r\n        Radio.Rx( Nvm.MacGroup2.MacParams.MaxRxWindow );\r\n        MacCtx.RxSlot = rxConfig->RxSlot;\r\n    }\r\n}\r\n\r\nstatic void OpenContinuousRxCWindow( void )\r\n{\r\n    // Compute RxC windows parameters\r\n    RegionComputeRxWindowParameters( Nvm.MacGroup2.Region,\r\n                                     Nvm.MacGroup2.MacParams.RxCChannel.Datarate,\r\n                                     Nvm.MacGroup2.MacParams.MinRxSymbols,\r\n                                     Nvm.MacGroup2.MacParams.SystemMaxRxError,\r\n                                     &MacCtx.RxWindowCConfig );\r\n\r\n    MacCtx.RxWindowCConfig.RxSlot = RX_SLOT_WIN_CLASS_C;\r\n    MacCtx.RxWindowCConfig.NetworkActivation = Nvm.MacGroup2.NetworkActivation;\r\n    // Setup continuous listening\r\n    MacCtx.RxWindowCConfig.RxContinuous = true;\r\n\r\n    // At this point the Radio should be idle.\r\n    // Thus, there is no need to set the radio in standby mode.\r\n    if( RegionRxConfig( Nvm.MacGroup2.Region, &MacCtx.RxWindowCConfig, ( int8_t* )&MacCtx.McpsIndication.RxDatarate ) == true )\r\n    {\r\n        Radio.Rx( 0 ); // Continuous mode\r\n        MacCtx.RxSlot = MacCtx.RxWindowCConfig.RxSlot;\r\n    }\r\n}\r\n\r\nLoRaMacStatus_t PrepareFrame( LoRaMacHeader_t* macHdr, LoRaMacFrameCtrl_t* fCtrl, uint8_t fPort, void* fBuffer, uint16_t fBufferSize )\r\n{\r\n    MacCtx.PktBufferLen = 0;\r\n    MacCtx.NodeAckRequested = false;\r\n    uint32_t fCntUp = 0;\r\n    size_t macCmdsSize = 0;\r\n    uint8_t availableSize = 0;\r\n\r\n    if( fBuffer == NULL )\r\n    {\r\n        fBufferSize = 0;\r\n    }\r\n\r\n    memcpy1( MacCtx.AppData, ( uint8_t* ) fBuffer, fBufferSize );\r\n    MacCtx.AppDataSize = fBufferSize;\r\n    MacCtx.PktBuffer[0] = macHdr->Value;\r\n\r\n    switch( macHdr->Bits.MType )\r\n    {\r\n        case FRAME_TYPE_DATA_CONFIRMED_UP:\r\n            MacCtx.NodeAckRequested = true;\r\n            // Intentional fall through\r\n        case FRAME_TYPE_DATA_UNCONFIRMED_UP:\r\n            MacCtx.TxMsg.Type = LORAMAC_MSG_TYPE_DATA;\r\n            MacCtx.TxMsg.Message.Data.Buffer = MacCtx.PktBuffer;\r\n            MacCtx.TxMsg.Message.Data.BufSize = LORAMAC_PHY_MAXPAYLOAD;\r\n            MacCtx.TxMsg.Message.Data.MHDR.Value = macHdr->Value;\r\n            MacCtx.TxMsg.Message.Data.FPort = fPort;\r\n            MacCtx.TxMsg.Message.Data.FHDR.DevAddr = Nvm.MacGroup2.DevAddr;\r\n            MacCtx.TxMsg.Message.Data.FHDR.FCtrl.Value = fCtrl->Value;\r\n            MacCtx.TxMsg.Message.Data.FRMPayloadSize = MacCtx.AppDataSize;\r\n            MacCtx.TxMsg.Message.Data.FRMPayload = MacCtx.AppData;\r\n\r\n            if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoGetFCntUp( &fCntUp ) )\r\n            {\r\n                return LORAMAC_STATUS_FCNT_HANDLER_ERROR;\r\n            }\r\n            MacCtx.TxMsg.Message.Data.FHDR.FCnt = ( uint16_t )fCntUp;\r\n\r\n            // Reset confirm parameters\r\n            MacCtx.McpsConfirm.NbTrans = 0;\r\n            MacCtx.McpsConfirm.AckReceived = false;\r\n            MacCtx.McpsConfirm.UpLinkCounter = fCntUp;\r\n\r\n            // Handle the MAC commands if there are any available\r\n            if( LoRaMacCommandsGetSizeSerializedCmds( &macCmdsSize ) != LORAMAC_COMMANDS_SUCCESS )\r\n            {\r\n                return LORAMAC_STATUS_MAC_COMMAD_ERROR;\r\n            }\r\n\r\n            if( macCmdsSize > 0 )\r\n            {\r\n                availableSize = GetMaxAppPayloadWithoutFOptsLength( Nvm.MacGroup1.ChannelsDatarate );\r\n\r\n                // There is application payload available and the MAC commands fit into FOpts field.\r\n                if( ( MacCtx.AppDataSize > 0 ) && ( macCmdsSize <= LORA_MAC_COMMAND_MAX_FOPTS_LENGTH ) )\r\n                {\r\n                    if( LoRaMacCommandsSerializeCmds( LORA_MAC_COMMAND_MAX_FOPTS_LENGTH, &macCmdsSize, MacCtx.TxMsg.Message.Data.FHDR.FOpts ) != LORAMAC_COMMANDS_SUCCESS )\r\n                    {\r\n                        return LORAMAC_STATUS_MAC_COMMAD_ERROR;\r\n                    }\r\n                    fCtrl->Bits.FOptsLen = macCmdsSize;\r\n                    // Update FCtrl field with new value of FOptionsLength\r\n                    MacCtx.TxMsg.Message.Data.FHDR.FCtrl.Value = fCtrl->Value;\r\n                }\r\n                // There is application payload available but the MAC commands does NOT fit into FOpts field.\r\n                else if( ( MacCtx.AppDataSize > 0 ) && ( macCmdsSize > LORA_MAC_COMMAND_MAX_FOPTS_LENGTH ) )\r\n                {\r\n\r\n                    if( LoRaMacCommandsSerializeCmds( availableSize, &macCmdsSize, MacCtx.MacCommandsBuffer ) != LORAMAC_COMMANDS_SUCCESS )\r\n                    {\r\n                        return LORAMAC_STATUS_MAC_COMMAD_ERROR;\r\n                    }\r\n                    return LORAMAC_STATUS_SKIPPED_APP_DATA;\r\n                }\r\n                // No application payload available therefore add all mac commands to the FRMPayload.\r\n                else\r\n                {\r\n                    if( LoRaMacCommandsSerializeCmds( availableSize, &macCmdsSize, MacCtx.MacCommandsBuffer ) != LORAMAC_COMMANDS_SUCCESS )\r\n                    {\r\n                        return LORAMAC_STATUS_MAC_COMMAD_ERROR;\r\n                    }\r\n                    // Force FPort to be zero\r\n                    MacCtx.TxMsg.Message.Data.FPort = 0;\r\n\r\n                    MacCtx.TxMsg.Message.Data.FRMPayload = MacCtx.MacCommandsBuffer;\r\n                    MacCtx.TxMsg.Message.Data.FRMPayloadSize = macCmdsSize;\r\n                }\r\n            }\r\n\r\n            break;\r\n        case FRAME_TYPE_PROPRIETARY:\r\n            if( ( fBuffer != NULL ) && ( MacCtx.AppDataSize > 0 ) )\r\n            {\r\n                memcpy1( MacCtx.PktBuffer + LORAMAC_MHDR_FIELD_SIZE, ( uint8_t* ) fBuffer, MacCtx.AppDataSize );\r\n                MacCtx.PktBufferLen = LORAMAC_MHDR_FIELD_SIZE + MacCtx.AppDataSize;\r\n            }\r\n            break;\r\n        default:\r\n            return LORAMAC_STATUS_SERVICE_UNKNOWN;\r\n    }\r\n\r\n    return LORAMAC_STATUS_OK;\r\n}\r\n\r\nLoRaMacStatus_t SendFrameOnChannel( uint8_t channel )\r\n{\r\n    LoRaMacStatus_t status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n    TxConfigParams_t txConfig;\r\n    int8_t txPower = 0;\r\n\r\n    txConfig.Channel = channel;\r\n    txConfig.Datarate = Nvm.MacGroup1.ChannelsDatarate;\r\n    txConfig.TxPower = Nvm.MacGroup1.ChannelsTxPower;\r\n    txConfig.MaxEirp = Nvm.MacGroup2.MacParams.MaxEirp;\r\n    txConfig.AntennaGain = Nvm.MacGroup2.MacParams.AntennaGain;\r\n    txConfig.PktLen = MacCtx.PktBufferLen;\r\n\r\n    RegionTxConfig( Nvm.MacGroup2.Region, &txConfig, &txPower, &MacCtx.TxTimeOnAir );\r\n\r\n    MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\r\n    MacCtx.McpsConfirm.Datarate = Nvm.MacGroup1.ChannelsDatarate;\r\n    MacCtx.McpsConfirm.TxPower = txPower;\r\n    MacCtx.McpsConfirm.Channel = channel;\r\n\r\n    // Store the time on air\r\n    MacCtx.McpsConfirm.TxTimeOnAir = MacCtx.TxTimeOnAir;\r\n    MacCtx.MlmeConfirm.TxTimeOnAir = MacCtx.TxTimeOnAir;\r\n\r\n    if( LoRaMacClassBIsBeaconModeActive( ) == true )\r\n    {\r\n        // Currently, the Time-On-Air can only be computed when the radio is configured with\r\n        // the TX configuration\r\n        TimerTime_t collisionTime = LoRaMacClassBIsUplinkCollision( MacCtx.TxTimeOnAir );\r\n\r\n        if( collisionTime > 0 )\r\n        {\r\n            return LORAMAC_STATUS_BUSY_UPLINK_COLLISION;\r\n        }\r\n    }\r\n\r\n    if( Nvm.MacGroup2.DeviceClass == CLASS_B )\r\n    {\r\n        // Stop slots for class b\r\n        LoRaMacClassBStopRxSlots( );\r\n    }\r\n\r\n    LoRaMacClassBHaltBeaconing( );\r\n\r\n    // Secure frame\r\n    status = SecureFrame( Nvm.MacGroup1.ChannelsDatarate, MacCtx.Channel );\r\n    if( status != LORAMAC_STATUS_OK )\r\n    {\r\n        return status;\r\n    }\r\n\r\n    MacCtx.MacState |= LORAMAC_TX_RUNNING;\r\n\r\n    MacCtx.ChannelsNbTransCounter++;\r\n    MacCtx.McpsConfirm.NbTrans = MacCtx.ChannelsNbTransCounter;\r\n    MacCtx.ResponseTimeoutStartTime = 0;\r\n\r\n    // Send now\r\n    Radio.Send( MacCtx.PktBuffer, MacCtx.PktBufferLen );\r\n\r\n    return LORAMAC_STATUS_OK;\r\n}\r\n\r\nLoRaMacStatus_t SetTxContinuousWave( uint16_t timeout, uint32_t frequency, uint8_t power )\r\n{\r\n    Radio.SetTxContinuousWave( frequency, power, timeout );\r\n\r\n    MacCtx.MacState |= LORAMAC_TX_RUNNING;\r\n\r\n    return LORAMAC_STATUS_OK;\r\n}\r\n\r\nLoRaMacNvmData_t* GetNvmData( void )\r\n{\r\n    return &Nvm;\r\n}\r\n\r\nLoRaMacStatus_t RestoreNvmData( LoRaMacNvmData_t* nvm )\r\n{\r\n    uint32_t crc = 0;\r\n\r\n    // Status and parameter validation\r\n    if( nvm == NULL )\r\n    {\r\n        return LORAMAC_STATUS_PARAMETER_INVALID;\r\n    }\r\n    if( MacCtx.MacState != LORAMAC_STOPPED )\r\n    {\r\n        return LORAMAC_STATUS_BUSY;\r\n    }\r\n\r\n    // Crypto\r\n    crc = Crc32( ( uint8_t* ) &nvm->Crypto, sizeof( nvm->Crypto ) -\r\n                                            sizeof( nvm->Crypto.Crc32 ) );\r\n    if( crc == nvm->Crypto.Crc32 )\r\n    {\r\n        memcpy1( ( uint8_t* ) &Nvm.Crypto, ( uint8_t* ) &nvm->Crypto,\r\n                 sizeof( Nvm.Crypto ) );\r\n    }\r\n\r\n    // MacGroup1\r\n    crc = Crc32( ( uint8_t* ) &nvm->MacGroup1, sizeof( nvm->MacGroup1 ) -\r\n                                               sizeof( nvm->MacGroup1.Crc32 ) );\r\n    if( crc == nvm->MacGroup1.Crc32 )\r\n    {\r\n        memcpy1( ( uint8_t* ) &Nvm.MacGroup1, ( uint8_t* ) &nvm->MacGroup1,\r\n                 sizeof( Nvm.MacGroup1 ) );\r\n    }\r\n\r\n    // MacGroup2\r\n    crc = Crc32( ( uint8_t* ) &nvm->MacGroup2, sizeof( nvm->MacGroup2 ) -\r\n                                               sizeof( nvm->MacGroup2.Crc32 ) );\r\n    if( crc == nvm->MacGroup2.Crc32 )\r\n    {\r\n        memcpy1( ( uint8_t* ) &Nvm.MacGroup2, ( uint8_t* ) &nvm->MacGroup2,\r\n                 sizeof( Nvm.MacGroup2 ) );\r\n\r\n        // Initialize RxC config parameters.\r\n        MacCtx.RxWindowCConfig.Channel = MacCtx.Channel;\r\n        MacCtx.RxWindowCConfig.Frequency = Nvm.MacGroup2.MacParams.RxCChannel.Frequency;\r\n        MacCtx.RxWindowCConfig.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;\r\n        MacCtx.RxWindowCConfig.RxContinuous = true;\r\n        MacCtx.RxWindowCConfig.RxSlot = RX_SLOT_WIN_CLASS_C;\r\n\r\n        // The public/private network flag may change upon reloading MacGroup2\r\n        // from NVM and we thus need to synchronize the radio. The same function\r\n        // is invoked in LoRaMacInitialization.\r\n        Radio.SetPublicNetwork( Nvm.MacGroup2.PublicNetwork );\r\n    }\r\n\r\n    // Secure Element\r\n    crc = Crc32( ( uint8_t* ) &nvm->SecureElement, sizeof( nvm->SecureElement ) -\r\n                                                   sizeof( nvm->SecureElement.Crc32 ) );\r\n    if( crc == nvm->SecureElement.Crc32 )\r\n    {\r\n        memcpy1( ( uint8_t* ) &Nvm.SecureElement,( uint8_t* ) &nvm->SecureElement,\r\n                 sizeof( Nvm.SecureElement ) );\r\n    }\r\n\r\n    // RegionGroup1\r\n    crc = Crc32( ( uint8_t* ) &nvm->RegionGroup1, sizeof( nvm->RegionGroup1 ) -\r\n                                            sizeof( nvm->RegionGroup1.Crc32 ) );\r\n    if( crc == nvm->RegionGroup1.Crc32 )\r\n    {\r\n        memcpy1( ( uint8_t* ) &Nvm.RegionGroup1,( uint8_t* ) &nvm->RegionGroup1,\r\n                 sizeof( Nvm.RegionGroup1 ) );\r\n    }\r\n\r\n    // RegionGroup2\r\n    crc = Crc32( ( uint8_t* ) &nvm->RegionGroup2, sizeof( nvm->RegionGroup2 ) -\r\n                                            sizeof( nvm->RegionGroup2.Crc32 ) );\r\n    if( crc == nvm->RegionGroup2.Crc32 )\r\n    {\r\n        memcpy1( ( uint8_t* ) &Nvm.RegionGroup2,( uint8_t* ) &nvm->RegionGroup2,\r\n                 sizeof( Nvm.RegionGroup2 ) );\r\n    }\r\n\r\n    crc = Crc32( ( uint8_t* ) &nvm->ClassB, sizeof( nvm->ClassB ) -\r\n                                            sizeof( nvm->ClassB.Crc32 ) );\r\n    if( crc == nvm->ClassB.Crc32 )\r\n    {\r\n        memcpy1( ( uint8_t* ) &Nvm.ClassB,( uint8_t* ) &nvm->ClassB,\r\n                 sizeof( Nvm.ClassB ) );\r\n    }\r\n\r\n    return LORAMAC_STATUS_OK;\r\n}\r\n\r\nLoRaMacStatus_t DetermineFrameType( LoRaMacMessageData_t* macMsg, FType_t* fType )\r\n{\r\n    if( ( macMsg == NULL ) || ( fType == NULL ) )\r\n    {\r\n        return LORAMAC_STATUS_PARAMETER_INVALID;\r\n    }\r\n\r\n    /* The LoRaWAN specification allows several possible configurations how data up/down frames are built up.\r\n     * In sake of clearness the following naming is applied. Please keep in mind that this is\r\n     * implementation specific since there is no definition in the LoRaWAN specification included.\r\n     *\r\n     * X -> Field is available\r\n     * - -> Field is not available\r\n     *\r\n     * +-------+  +----------+------+-------+--------------+\r\n     * | FType |  | FOptsLen | Fopt | FPort |  FRMPayload  |\r\n     * +-------+  +----------+------+-------+--------------+\r\n     * |   A   |  |    > 0   |   X  |  > 0  |       X      |\r\n     * +-------+  +----------+------+-------+--------------+\r\n     * |   B   |  |   >= 0   |  X/- |   -   |       -      |\r\n     * +-------+  +----------+------+-------+--------------+\r\n     * |   C   |  |    = 0   |   -  |  = 0  | MAC commands |\r\n     * +-------+  +----------+------+-------+--------------+\r\n     * |   D   |  |    = 0   |   -  |  > 0  |       X      |\r\n     * +-------+  +----------+------+-------+--------------+\r\n     */\r\n\r\n    if( ( macMsg->FHDR.FCtrl.Bits.FOptsLen > 0 ) && ( macMsg->FPort > 0 ) )\r\n    {\r\n        *fType = FRAME_TYPE_A;\r\n    }\r\n    else if( macMsg->FRMPayloadSize == 0 )\r\n    {\r\n        *fType = FRAME_TYPE_B;\r\n    }\r\n    else if( ( macMsg->FHDR.FCtrl.Bits.FOptsLen == 0 ) && ( macMsg->FPort == 0 ) )\r\n    {\r\n        *fType = FRAME_TYPE_C;\r\n    }\r\n    else if( ( macMsg->FHDR.FCtrl.Bits.FOptsLen == 0 ) && ( macMsg->FPort > 0 ) )\r\n    {\r\n        *fType = FRAME_TYPE_D;\r\n    }\r\n    else\r\n    {\r\n        // Should never happen.\r\n        return LORAMAC_STATUS_ERROR;\r\n    }\r\n\r\n    return LORAMAC_STATUS_OK;\r\n}\r\n\r\nstatic bool CheckRetrans( uint8_t counter, uint8_t limit )\r\n{\r\n    if( counter >= limit )\r\n    {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\nstatic bool CheckRetransUnconfirmedUplink( void )\r\n{\r\n    // Verify, if the max number of retransmissions have been reached\r\n    if( CheckRetrans( MacCtx.ChannelsNbTransCounter,\r\n                      Nvm.MacGroup2.MacParams.ChannelsNbTrans ) == true )\r\n    {\r\n        return true;\r\n    }\r\n\r\n    if( MacCtx.MacFlags.Bits.McpsInd == 1 )\r\n    {\r\n        // Stop the retransmissions, if a valid downlink is received\r\n        // a class A RX window. This holds also for class B and C.\r\n        if( ( MacCtx.McpsIndication.RxSlot == RX_SLOT_WIN_1 ) ||\r\n            ( MacCtx.McpsIndication.RxSlot == RX_SLOT_WIN_2 ) )\r\n        {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nstatic bool CheckRetransConfirmedUplink( void )\r\n{\r\n    // Verify, if the max number of retransmissions have been reached\r\n    if( CheckRetrans( MacCtx.ChannelsNbTransCounter,\r\n                      Nvm.MacGroup2.MacParams.ChannelsNbTrans ) == true )\r\n    {\r\n        return true;\r\n    }\r\n\r\n    if( MacCtx.MacFlags.Bits.McpsInd == 1 )\r\n    {\r\n        if( MacCtx.McpsConfirm.AckReceived == true )\r\n        {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nstatic uint32_t IncreaseAdrAckCounter( uint32_t counter )\r\n{\r\n    if( counter < ADR_ACK_COUNTER_MAX )\r\n    {\r\n        counter++;\r\n    }\r\n    return counter;\r\n}\r\n\r\nstatic bool StopRetransmission( void )\r\n{\r\n    // Increase Rejoin Uplinks counter\r\n    if( Nvm.MacGroup2.Rejoin0UplinksLimit != 0 )\r\n    {\r\n        Nvm.MacGroup1.Rejoin0UplinksCounter++;\r\n    }\r\n\r\n    if( Nvm.MacGroup2.Version.Fields.Minor >= 1 )\r\n    {\r\n        MacCommand_t* macCmd;\r\n        if( LoRaMacCommandsGetCmd( MOTE_MAC_REKEY_IND, &macCmd ) == LORAMAC_COMMANDS_SUCCESS )\r\n        {\r\n            // Increase the Rekey Uplinks counter\r\n            Nvm.MacGroup1.RekeyIndUplinksCounter++;\r\n\r\n            /*\r\n             * If the device has not received a RekeyConf within\r\n             * the first ADR_ACK_LIMIT uplinks it SHALL revert to the Join state.\r\n             */\r\n            if( Nvm.MacGroup1.RekeyIndUplinksCounter == Nvm.MacGroup2.MacParams.AdrAckLimit )\r\n            {\r\n                Nvm.MacGroup2.NetworkActivation = ACTIVATION_TYPE_NONE;\r\n                MacCtx.MacFlags.Bits.MlmeInd = 1;\r\n                MacCtx.MlmeIndication.MlmeIndication = MLME_REVERT_JOIN;\r\n            }\r\n        }\r\n    }\r\n\r\n    if( ( MacCtx.MacFlags.Bits.McpsInd == 0 ) ||\r\n        ( ( MacCtx.McpsIndication.RxSlot != RX_SLOT_WIN_1 ) &&\r\n          ( MacCtx.McpsIndication.RxSlot != RX_SLOT_WIN_2 ) ) )\r\n    {   // Maximum repetitions without downlink. Increase ADR Ack counter.\r\n        // Only process the case when the MAC did not receive a downlink.\r\n        if( Nvm.MacGroup2.AdrCtrlOn == true )\r\n        {\r\n            Nvm.MacGroup1.AdrAckCounter = IncreaseAdrAckCounter( Nvm.MacGroup1.AdrAckCounter );\r\n        }\r\n    }\r\n\r\n    MacCtx.ChannelsNbTransCounter = 0;\r\n    MacCtx.NodeAckRequested = false;\r\n    MacCtx.RetransmitTimeoutRetry = false;\r\n    MacCtx.MacState &= ~LORAMAC_TX_RUNNING;\r\n\r\n    return true;\r\n}\r\n\r\nstatic void CallNvmDataChangeCallback( uint16_t notifyFlags )\r\n{\r\n    if( ( MacCtx.MacCallbacks != NULL ) &&\r\n        ( MacCtx.MacCallbacks->NvmDataChange  != NULL ) )\r\n    {\r\n        MacCtx.MacCallbacks->NvmDataChange ( notifyFlags );\r\n    }\r\n}\r\nstatic uint8_t IsRequestPending( void )\r\n{\r\n    if( ( MacCtx.MacFlags.Bits.MlmeReq == 1 ) ||\r\n        ( MacCtx.MacFlags.Bits.McpsReq == 1 ) )\r\n    {\r\n        return 1;\r\n    }\r\n    return 0;\r\n}\r\n\r\n\r\nLoRaMacStatus_t LoRaMacInitialization( LoRaMacPrimitives_t* primitives, LoRaMacCallback_t* callbacks, LoRaMacRegion_t region )\r\n{\r\n    GetPhyParams_t getPhy;\r\n    PhyParam_t phyParam;\r\n\r\n    if( ( primitives == NULL ) ||\r\n        ( callbacks == NULL ) )\r\n    {\r\n        return LORAMAC_STATUS_PARAMETER_INVALID;\r\n    }\r\n\r\n    if( ( primitives->MacMcpsConfirm == NULL ) ||\r\n        ( primitives->MacMcpsIndication == NULL ) ||\r\n        ( primitives->MacMlmeConfirm == NULL ) ||\r\n        ( primitives->MacMlmeIndication == NULL ) )\r\n    {\r\n        return LORAMAC_STATUS_PARAMETER_INVALID;\r\n    }\r\n    // Verify if the region is supported\r\n    if( RegionIsActive( region ) == false )\r\n    {\r\n        return LORAMAC_STATUS_REGION_NOT_SUPPORTED;\r\n    }\r\n\r\n    // Confirm queue reset\r\n    LoRaMacConfirmQueueInit( primitives );\r\n\r\n    // Initialize the module context with zeros\r\n    memset1( ( uint8_t* ) &Nvm, 0x00, sizeof( LoRaMacNvmData_t ) );\r\n    memset1( ( uint8_t* ) &MacCtx, 0x00, sizeof( LoRaMacCtx_t ) );\r\n\r\n    // Set non zero variables to its default value\r\n    Nvm.MacGroup2.Region = region;\r\n    Nvm.MacGroup2.DeviceClass = CLASS_A;\r\n\r\n    // Setup version\r\n    Nvm.MacGroup2.Version.Value = LORAMAC_VERSION;\r\n\r\n    InitDefaultsParams_t params;\r\n    params.Type = INIT_TYPE_DEFAULTS;\r\n    params.NvmGroup1 = &Nvm.RegionGroup1;\r\n    params.NvmGroup2 = &Nvm.RegionGroup2;\r\n    params.Bands = &RegionBands;\r\n    RegionInitDefaults( Nvm.MacGroup2.Region, &params );\r\n\r\n    // Reset to defaults\r\n    getPhy.Attribute = PHY_DUTY_CYCLE;\r\n    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );\r\n    Nvm.MacGroup2.DutyCycleOn = ( bool ) phyParam.Value;\r\n\r\n    getPhy.Attribute = PHY_DEF_TX_POWER;\r\n    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );\r\n    Nvm.MacGroup2.ChannelsTxPowerDefault = phyParam.Value;\r\n\r\n    getPhy.Attribute = PHY_DEF_TX_DR;\r\n    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );\r\n    Nvm.MacGroup2.ChannelsDatarateDefault = phyParam.Value;\r\n\r\n    getPhy.Attribute = PHY_MAX_RX_WINDOW;\r\n    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );\r\n    Nvm.MacGroup2.MacParamsDefaults.MaxRxWindow = phyParam.Value;\r\n\r\n    getPhy.Attribute = PHY_RECEIVE_DELAY1;\r\n    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );\r\n    Nvm.MacGroup2.MacParamsDefaults.ReceiveDelay1 = phyParam.Value;\r\n\r\n    getPhy.Attribute = PHY_RECEIVE_DELAY2;\r\n    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );\r\n    Nvm.MacGroup2.MacParamsDefaults.ReceiveDelay2 = phyParam.Value;\r\n\r\n    getPhy.Attribute = PHY_JOIN_ACCEPT_DELAY1;\r\n    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );\r\n    Nvm.MacGroup2.MacParamsDefaults.JoinAcceptDelay1 = phyParam.Value;\r\n\r\n    getPhy.Attribute = PHY_JOIN_ACCEPT_DELAY2;\r\n    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );\r\n    Nvm.MacGroup2.MacParamsDefaults.JoinAcceptDelay2 = phyParam.Value;\r\n\r\n    getPhy.Attribute = PHY_DEF_DR1_OFFSET;\r\n    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );\r\n    Nvm.MacGroup2.MacParamsDefaults.Rx1DrOffset = phyParam.Value;\r\n\r\n    getPhy.Attribute = PHY_DEF_RX2_FREQUENCY;\r\n    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );\r\n    Nvm.MacGroup2.MacParamsDefaults.Rx2Channel.Frequency = phyParam.Value;\r\n    Nvm.MacGroup2.MacParamsDefaults.RxCChannel.Frequency = phyParam.Value;\r\n\r\n    getPhy.Attribute = PHY_DEF_RX2_DR;\r\n    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );\r\n    Nvm.MacGroup2.MacParamsDefaults.Rx2Channel.Datarate = phyParam.Value;\r\n    Nvm.MacGroup2.MacParamsDefaults.RxCChannel.Datarate = phyParam.Value;\r\n\r\n    getPhy.Attribute = PHY_DEF_UPLINK_DWELL_TIME;\r\n    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );\r\n    Nvm.MacGroup2.MacParamsDefaults.UplinkDwellTime = phyParam.Value;\r\n\r\n    getPhy.Attribute = PHY_DEF_DOWNLINK_DWELL_TIME;\r\n    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );\r\n    Nvm.MacGroup2.MacParamsDefaults.DownlinkDwellTime = phyParam.Value;\r\n\r\n    getPhy.Attribute = PHY_DEF_MAX_EIRP;\r\n    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );\r\n    Nvm.MacGroup2.MacParamsDefaults.MaxEirp = phyParam.fValue;\r\n\r\n    getPhy.Attribute = PHY_DEF_ANTENNA_GAIN;\r\n    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );\r\n    Nvm.MacGroup2.MacParamsDefaults.AntennaGain = phyParam.fValue;\r\n\r\n    getPhy.Attribute = PHY_DEF_ADR_ACK_LIMIT;\r\n    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );\r\n    Nvm.MacGroup2.MacParamsDefaults.AdrAckLimit = phyParam.Value;\r\n\r\n    getPhy.Attribute = PHY_DEF_ADR_ACK_DELAY;\r\n    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );\r\n    Nvm.MacGroup2.MacParamsDefaults.AdrAckDelay = phyParam.Value;\r\n\r\n    // Init parameters which are not set in function ResetMacParameters\r\n    Nvm.MacGroup2.MacParamsDefaults.ChannelsNbTrans = 1;\r\n    Nvm.MacGroup2.MacParamsDefaults.SystemMaxRxError = 10;\r\n    Nvm.MacGroup2.MacParamsDefaults.MinRxSymbols = 6;\r\n\r\n    Nvm.MacGroup2.MacParams.SystemMaxRxError = Nvm.MacGroup2.MacParamsDefaults.SystemMaxRxError;\r\n    Nvm.MacGroup2.MacParams.MinRxSymbols = Nvm.MacGroup2.MacParamsDefaults.MinRxSymbols;\r\n    Nvm.MacGroup2.MacParams.MaxRxWindow = Nvm.MacGroup2.MacParamsDefaults.MaxRxWindow;\r\n    Nvm.MacGroup2.MacParams.ReceiveDelay1 = Nvm.MacGroup2.MacParamsDefaults.ReceiveDelay1;\r\n    Nvm.MacGroup2.MacParams.ReceiveDelay2 = Nvm.MacGroup2.MacParamsDefaults.ReceiveDelay2;\r\n    Nvm.MacGroup2.MacParams.JoinAcceptDelay1 = Nvm.MacGroup2.MacParamsDefaults.JoinAcceptDelay1;\r\n    Nvm.MacGroup2.MacParams.JoinAcceptDelay2 = Nvm.MacGroup2.MacParamsDefaults.JoinAcceptDelay2;\r\n    Nvm.MacGroup2.MacParams.ChannelsNbTrans = Nvm.MacGroup2.MacParamsDefaults.ChannelsNbTrans;\r\n\r\n    // FPort 224 is enabled by default.\r\n    Nvm.MacGroup2.IsCertPortOn = true;\r\n\r\n    ResetMacParameters( false );\r\n\r\n    Nvm.MacGroup2.PublicNetwork = true;\r\n\r\n    MacCtx.MacPrimitives = primitives;\r\n    MacCtx.MacCallbacks = callbacks;\r\n    MacCtx.MacFlags.Value = 0;\r\n    MacCtx.MacState = LORAMAC_STOPPED;\r\n\r\n    // Reset duty cycle times\r\n    Nvm.MacGroup1.LastTxDoneTime = 0;\r\n    Nvm.MacGroup1.AggregatedTimeOff = 0;\r\n\r\n    // Initialize timers\r\n    TimerInit( &MacCtx.TxDelayedTimer, OnTxDelayedTimerEvent );\r\n    TimerInit( &MacCtx.RxWindowTimer1, OnRxWindow1TimerEvent );\r\n    TimerInit( &MacCtx.RxWindowTimer2, OnRxWindow2TimerEvent );\r\n    TimerInit( &MacCtx.RetransmitTimeoutTimer, OnRetransmitTimeoutTimerEvent );\r\n    TimerInit( &MacCtx.Rejoin0CycleTimer, OnRejoin0CycleTimerEvent );\r\n    TimerInit( &MacCtx.Rejoin1CycleTimer, OnRejoin1CycleTimerEvent );\r\n    TimerInit( &MacCtx.ForceRejoinReqCycleTimer, OnForceRejoinReqCycleTimerEvent );\r\n\r\n    // Store the current initialization time\r\n    Nvm.MacGroup2.InitializationTime = SysTimeGetMcuTime( );\r\n\r\n    // Initialize MAC radio events\r\n    LoRaMacRadioEvents.Value = 0;\r\n\r\n    // Initialize Radio driver\r\n    MacCtx.RadioEvents.TxDone = OnRadioTxDone;\r\n    MacCtx.RadioEvents.RxDone = OnRadioRxDone;\r\n    MacCtx.RadioEvents.RxError = OnRadioRxError;\r\n    MacCtx.RadioEvents.TxTimeout = OnRadioTxTimeout;\r\n    MacCtx.RadioEvents.RxTimeout = OnRadioRxTimeout;\r\n    Radio.Init( &MacCtx.RadioEvents );\r\n\r\n    // Initialize the Secure Element driver\r\n    if( SecureElementInit( &Nvm.SecureElement ) != SECURE_ELEMENT_SUCCESS )\r\n    {\r\n        return LORAMAC_STATUS_CRYPTO_ERROR;\r\n    }\r\n\r\n    // Initialize Crypto module\r\n    if( LoRaMacCryptoInit( &Nvm.Crypto ) != LORAMAC_CRYPTO_SUCCESS )\r\n    {\r\n        return LORAMAC_STATUS_CRYPTO_ERROR;\r\n    }\r\n\r\n    // Initialize MAC commands module\r\n    if( LoRaMacCommandsInit( ) != LORAMAC_COMMANDS_SUCCESS )\r\n    {\r\n        return LORAMAC_STATUS_MAC_COMMAD_ERROR;\r\n    }\r\n\r\n    // Set multicast downlink counter reference\r\n    if( LoRaMacCryptoSetMulticastReference( Nvm.MacGroup2.MulticastChannelList ) != LORAMAC_CRYPTO_SUCCESS )\r\n    {\r\n        return LORAMAC_STATUS_CRYPTO_ERROR;\r\n    }\r\n\r\n    // Random seed initialization\r\n    srand1( Radio.Random( ) );\r\n\r\n    Radio.SetPublicNetwork( Nvm.MacGroup2.PublicNetwork );\r\n    Radio.Sleep( );\r\n\r\n    LoRaMacEnableRequests( LORAMAC_REQUEST_HANDLING_ON );\r\n\r\n    return LORAMAC_STATUS_OK;\r\n}\r\n\r\nLoRaMacStatus_t LoRaMacStart( void )\r\n{\r\n    MacCtx.MacState = LORAMAC_IDLE;\r\n    UpdateRxSlotIdleState();\r\n    return LORAMAC_STATUS_OK;\r\n}\r\n\r\nLoRaMacStatus_t LoRaMacStop( void )\r\n{\r\n    if( LoRaMacIsBusy( ) == false )\r\n    {\r\n        if( Nvm.MacGroup2.DeviceClass == CLASS_C )\r\n        {\r\n            Radio.Sleep( );\r\n        }\r\n        MacCtx.MacState = LORAMAC_STOPPED;\r\n        return LORAMAC_STATUS_OK;\r\n    }\r\n    else if(  MacCtx.MacState == LORAMAC_STOPPED )\r\n    {\r\n        return LORAMAC_STATUS_OK;\r\n    }\r\n    return LORAMAC_STATUS_BUSY;\r\n}\r\n\r\nLoRaMacStatus_t LoRaMacQueryTxPossible( uint8_t size, LoRaMacTxInfo_t* txInfo )\r\n{\r\n    CalcNextAdrParams_t adrNext;\r\n    uint32_t adrAckCounter = Nvm.MacGroup1.AdrAckCounter;\r\n    int8_t datarate = Nvm.MacGroup2.ChannelsDatarateDefault;\r\n    int8_t txPower = Nvm.MacGroup2.ChannelsTxPowerDefault;\r\n    uint8_t nbTrans = MacCtx.ChannelsNbTransCounter;\r\n    size_t macCmdsSize = 0;\r\n\r\n    if( txInfo == NULL )\r\n    {\r\n        return LORAMAC_STATUS_PARAMETER_INVALID;\r\n    }\r\n\r\n    // Setup ADR request\r\n    adrNext.UpdateChanMask = false;\r\n    adrNext.AdrEnabled = Nvm.MacGroup2.AdrCtrlOn;\r\n    adrNext.AdrAckCounter = Nvm.MacGroup1.AdrAckCounter;\r\n    adrNext.AdrAckLimit = Nvm.MacGroup2.MacParams.AdrAckLimit;\r\n    adrNext.AdrAckDelay = Nvm.MacGroup2.MacParams.AdrAckDelay;\r\n    adrNext.Datarate = Nvm.MacGroup1.ChannelsDatarate;\r\n    adrNext.TxPower = Nvm.MacGroup1.ChannelsTxPower;\r\n    adrNext.NbTrans = MacCtx.ChannelsNbTransCounter;\r\n    adrNext.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;\r\n    adrNext.Region = Nvm.MacGroup2.Region;\r\n\r\n    // We call the function for information purposes only. We don't want to\r\n    // apply the datarate, the tx power and the ADR ack counter.\r\n    LoRaMacAdrCalcNext( &adrNext, &datarate, &txPower, &nbTrans, &adrAckCounter );\r\n\r\n    txInfo->CurrentPossiblePayloadSize = GetMaxAppPayloadWithoutFOptsLength( datarate );\r\n\r\n    if( LoRaMacCommandsGetSizeSerializedCmds( &macCmdsSize ) != LORAMAC_COMMANDS_SUCCESS )\r\n    {\r\n        return LORAMAC_STATUS_MAC_COMMAD_ERROR;\r\n    }\r\n\r\n    // Verify if the MAC commands fit into the FOpts and into the maximum payload.\r\n    if( ( LORA_MAC_COMMAND_MAX_FOPTS_LENGTH >= macCmdsSize ) && ( txInfo->CurrentPossiblePayloadSize >= macCmdsSize ) )\r\n    {\r\n        txInfo->MaxPossibleApplicationDataSize = txInfo->CurrentPossiblePayloadSize - macCmdsSize;\r\n\r\n        // Verify if the application data together with MAC command fit into the maximum payload.\r\n        if( txInfo->CurrentPossiblePayloadSize >= ( macCmdsSize + size ) )\r\n        {\r\n            return LORAMAC_STATUS_OK;\r\n        }\r\n        else\r\n        {\r\n           return LORAMAC_STATUS_LENGTH_ERROR;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        txInfo->MaxPossibleApplicationDataSize = 0;\r\n        return LORAMAC_STATUS_LENGTH_ERROR;\r\n    }\r\n}\r\n\r\nLoRaMacStatus_t LoRaMacMibGetRequestConfirm( MibRequestConfirm_t* mibGet )\r\n{\r\n    LoRaMacStatus_t status = LORAMAC_STATUS_OK;\r\n    GetPhyParams_t getPhy;\r\n    PhyParam_t phyParam;\r\n\r\n    if( mibGet == NULL )\r\n    {\r\n        return LORAMAC_STATUS_PARAMETER_INVALID;\r\n    }\r\n\r\n    switch( mibGet->Type )\r\n    {\r\n        case MIB_DEVICE_CLASS:\r\n        {\r\n            mibGet->Param.Class = Nvm.MacGroup2.DeviceClass;\r\n            break;\r\n        }\r\n        case MIB_NETWORK_ACTIVATION:\r\n        {\r\n            mibGet->Param.NetworkActivation = Nvm.MacGroup2.NetworkActivation;\r\n            break;\r\n        }\r\n        case MIB_DEV_EUI:\r\n        {\r\n            mibGet->Param.DevEui = SecureElementGetDevEui( );\r\n            break;\r\n        }\r\n        case MIB_JOIN_EUI:\r\n        {\r\n            mibGet->Param.JoinEui = SecureElementGetJoinEui( );\r\n            break;\r\n        }\r\n        case MIB_SE_PIN:\r\n        {\r\n            mibGet->Param.SePin = SecureElementGetPin( );\r\n            break;\r\n        }\r\n        case MIB_ADR:\r\n        {\r\n            mibGet->Param.AdrEnable = Nvm.MacGroup2.AdrCtrlOn;\r\n            break;\r\n        }\r\n        case MIB_NET_ID:\r\n        {\r\n            mibGet->Param.NetID = Nvm.MacGroup2.NetID;\r\n            break;\r\n        }\r\n        case MIB_DEV_ADDR:\r\n        {\r\n            mibGet->Param.DevAddr = Nvm.MacGroup2.DevAddr;\r\n            break;\r\n        }\r\n        case MIB_PUBLIC_NETWORK:\r\n        {\r\n            mibGet->Param.EnablePublicNetwork = Nvm.MacGroup2.PublicNetwork;\r\n            break;\r\n        }\r\n        case MIB_CHANNELS:\r\n        {\r\n            getPhy.Attribute = PHY_CHANNELS;\r\n            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );\r\n\r\n            mibGet->Param.ChannelList = phyParam.Channels;\r\n            break;\r\n        }\r\n        case MIB_RX2_CHANNEL:\r\n        {\r\n            mibGet->Param.Rx2Channel = Nvm.MacGroup2.MacParams.Rx2Channel;\r\n            break;\r\n        }\r\n        case MIB_RX2_DEFAULT_CHANNEL:\r\n        {\r\n            mibGet->Param.Rx2Channel = Nvm.MacGroup2.MacParamsDefaults.Rx2Channel;\r\n            break;\r\n        }\r\n        case MIB_RXC_CHANNEL:\r\n        {\r\n            mibGet->Param.RxCChannel = Nvm.MacGroup2.MacParams.RxCChannel;\r\n            break;\r\n        }\r\n        case MIB_RXC_DEFAULT_CHANNEL:\r\n        {\r\n            mibGet->Param.RxCChannel = Nvm.MacGroup2.MacParamsDefaults.RxCChannel;\r\n            break;\r\n        }\r\n        case MIB_CHANNELS_DEFAULT_MASK:\r\n        {\r\n            getPhy.Attribute = PHY_CHANNELS_DEFAULT_MASK;\r\n            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );\r\n\r\n            mibGet->Param.ChannelsDefaultMask = phyParam.ChannelsMask;\r\n            break;\r\n        }\r\n        case MIB_CHANNELS_MASK:\r\n        {\r\n            getPhy.Attribute = PHY_CHANNELS_MASK;\r\n            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );\r\n\r\n            mibGet->Param.ChannelsMask = phyParam.ChannelsMask;\r\n            break;\r\n        }\r\n        case MIB_CHANNELS_NB_TRANS:\r\n        {\r\n            mibGet->Param.ChannelsNbTrans = Nvm.MacGroup2.MacParams.ChannelsNbTrans;\r\n            break;\r\n        }\r\n        case MIB_MAX_RX_WINDOW_DURATION:\r\n        {\r\n            mibGet->Param.MaxRxWindow = Nvm.MacGroup2.MacParams.MaxRxWindow;\r\n            break;\r\n        }\r\n        case MIB_RECEIVE_DELAY_1:\r\n        {\r\n            mibGet->Param.ReceiveDelay1 = Nvm.MacGroup2.MacParams.ReceiveDelay1;\r\n            break;\r\n        }\r\n        case MIB_RECEIVE_DELAY_2:\r\n        {\r\n            mibGet->Param.ReceiveDelay2 = Nvm.MacGroup2.MacParams.ReceiveDelay2;\r\n            break;\r\n        }\r\n        case MIB_JOIN_ACCEPT_DELAY_1:\r\n        {\r\n            mibGet->Param.JoinAcceptDelay1 = Nvm.MacGroup2.MacParams.JoinAcceptDelay1;\r\n            break;\r\n        }\r\n        case MIB_JOIN_ACCEPT_DELAY_2:\r\n        {\r\n            mibGet->Param.JoinAcceptDelay2 = Nvm.MacGroup2.MacParams.JoinAcceptDelay2;\r\n            break;\r\n        }\r\n        case MIB_CHANNELS_MIN_TX_DATARATE:\r\n        {\r\n            getPhy.Attribute = PHY_MIN_TX_DR;\r\n            getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;\r\n            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );\r\n\r\n            mibGet->Param.ChannelsMinTxDatarate = phyParam.Value;\r\n            break;\r\n        }\r\n        case MIB_CHANNELS_DEFAULT_DATARATE:\r\n        {\r\n            mibGet->Param.ChannelsDefaultDatarate = Nvm.MacGroup2.ChannelsDatarateDefault;\r\n            break;\r\n        }\r\n        case MIB_CHANNELS_DATARATE:\r\n        {\r\n            mibGet->Param.ChannelsDatarate = Nvm.MacGroup1.ChannelsDatarate;\r\n            break;\r\n        }\r\n        case MIB_CHANNELS_DEFAULT_TX_POWER:\r\n        {\r\n            mibGet->Param.ChannelsDefaultTxPower = Nvm.MacGroup2.ChannelsTxPowerDefault;\r\n            break;\r\n        }\r\n        case MIB_CHANNELS_TX_POWER:\r\n        {\r\n            mibGet->Param.ChannelsTxPower = Nvm.MacGroup1.ChannelsTxPower;\r\n            break;\r\n        }\r\n        case MIB_SYSTEM_MAX_RX_ERROR:\r\n        {\r\n            mibGet->Param.SystemMaxRxError = Nvm.MacGroup2.MacParams.SystemMaxRxError;\r\n            break;\r\n        }\r\n        case MIB_MIN_RX_SYMBOLS:\r\n        {\r\n            mibGet->Param.MinRxSymbols = Nvm.MacGroup2.MacParams.MinRxSymbols;\r\n            break;\r\n        }\r\n        case MIB_ANTENNA_GAIN:\r\n        {\r\n            mibGet->Param.AntennaGain = Nvm.MacGroup2.MacParams.AntennaGain;\r\n            break;\r\n        }\r\n        case MIB_NVM_CTXS:\r\n        {\r\n            mibGet->Param.Contexts = GetNvmData( );\r\n            break;\r\n        }\r\n        case MIB_DEFAULT_ANTENNA_GAIN:\r\n        {\r\n            mibGet->Param.DefaultAntennaGain = Nvm.MacGroup2.MacParamsDefaults.AntennaGain;\r\n            break;\r\n        }\r\n        case MIB_LORAWAN_VERSION:\r\n        {\r\n            mibGet->Param.LrWanVersion.LoRaWan = Nvm.MacGroup2.Version;\r\n            mibGet->Param.LrWanVersion.LoRaWanRegion = RegionGetVersion( );\r\n            break;\r\n        }\r\n        case MIB_IS_CERT_FPORT_ON:\r\n        {\r\n            mibGet->Param.IsCertPortOn = Nvm.MacGroup2.IsCertPortOn;\r\n            break;\r\n        }\r\n        case MIB_REJOIN_0_CYCLE:\r\n        {\r\n            mibGet->Param.Rejoin0CycleInSec = Nvm.MacGroup2.Rejoin0CycleInSec;\r\n            break;\r\n        }\r\n        case MIB_REJOIN_1_CYCLE:\r\n        {\r\n            mibGet->Param.Rejoin1CycleInSec = Nvm.MacGroup2.Rejoin1CycleInSec;\r\n            break;\r\n        }\r\n        case MIB_ADR_ACK_LIMIT:\r\n        {\r\n            mibGet->Param.AdrAckLimit = Nvm.MacGroup2.MacParams.AdrAckLimit;\r\n            break;\r\n        }\r\n        case MIB_ADR_ACK_DELAY:\r\n        {\r\n            mibGet->Param.AdrAckDelay = Nvm.MacGroup2.MacParams.AdrAckDelay;\r\n            break;\r\n        }\r\n        case MIB_ADR_ACK_DEFAULT_LIMIT:\r\n        {\r\n            mibGet->Param.AdrAckLimit = Nvm.MacGroup2.MacParamsDefaults.AdrAckLimit;\r\n            break;\r\n        }\r\n        case MIB_ADR_ACK_DEFAULT_DELAY:\r\n        {\r\n            mibGet->Param.AdrAckDelay = Nvm.MacGroup2.MacParamsDefaults.AdrAckDelay;\r\n            break;\r\n        }\r\n        case MIB_RSSI_FREE_THRESHOLD:\r\n        {\r\n#if defined(REGION_KR920) || defined(REGION_AS923)\r\n            if( Nvm.MacGroup2.Region != LORAMAC_REGION_AS923 && Nvm.MacGroup2.Region != LORAMAC_REGION_KR920 )\r\n            {\r\n                status = LORAMAC_STATUS_ERROR;\r\n            }\r\n            else\r\n            {\r\n                mibGet->Param.RssiFreeThreshold = Nvm.RegionGroup2.RssiFreeThreshold;\r\n            }\r\n#else\r\n            status = LORAMAC_STATUS_ERROR;\r\n#endif\r\n            break;\r\n        }\r\n        case MIB_CARRIER_SENSE_TIME:\r\n        {\r\n#if defined(REGION_KR920) || defined(REGION_AS923)\r\n            if( Nvm.MacGroup2.Region != LORAMAC_REGION_AS923 && Nvm.MacGroup2.Region != LORAMAC_REGION_KR920 )\r\n            {\r\n                status = LORAMAC_STATUS_ERROR;\r\n            }\r\n            else\r\n            {\r\n                mibGet->Param.CarrierSenseTime = Nvm.RegionGroup2.CarrierSenseTime;\r\n            }\r\n#else\r\n            status = LORAMAC_STATUS_ERROR;\r\n#endif\r\n            break;\r\n        }\r\n        default:\r\n        {\r\n            status = LoRaMacClassBMibGetRequestConfirm( mibGet );\r\n            break;\r\n        }\r\n    }\r\n    return status;\r\n}\r\n\r\nLoRaMacStatus_t LoRaMacMibSetRequestConfirm( MibRequestConfirm_t* mibSet )\r\n{\r\n    LoRaMacStatus_t status = LORAMAC_STATUS_OK;\r\n    ChanMaskSetParams_t chanMaskSet;\r\n    VerifyParams_t verify;\r\n\r\n    if( mibSet == NULL )\r\n    {\r\n        return LORAMAC_STATUS_PARAMETER_INVALID;\r\n    }\r\n    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )\r\n    {\r\n        return LORAMAC_STATUS_BUSY;\r\n    }\r\n\r\n    switch( mibSet->Type )\r\n    {\r\n        case MIB_DEVICE_CLASS:\r\n        {\r\n            status = SwitchClass( mibSet->Param.Class );\r\n            break;\r\n        }\r\n        case MIB_NETWORK_ACTIVATION:\r\n        {\r\n            if( mibSet->Param.NetworkActivation != ACTIVATION_TYPE_OTAA  )\r\n            {\r\n                Nvm.MacGroup2.NetworkActivation = mibSet->Param.NetworkActivation;\r\n            }\r\n            else\r\n            {   // Do not allow to set ACTIVATION_TYPE_OTAA since the MAC will set it automatically after a successful join process.\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_DEV_EUI:\r\n        {\r\n            if( SecureElementSetDevEui( mibSet->Param.DevEui ) != SECURE_ELEMENT_SUCCESS )\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_JOIN_EUI:\r\n        {\r\n            if( SecureElementSetJoinEui( mibSet->Param.JoinEui ) != SECURE_ELEMENT_SUCCESS )\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_SE_PIN:\r\n        {\r\n            if( SecureElementSetPin( mibSet->Param.SePin ) != SECURE_ELEMENT_SUCCESS )\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_ADR:\r\n        {\r\n            Nvm.MacGroup2.AdrCtrlOn = mibSet->Param.AdrEnable;\r\n            break;\r\n        }\r\n        case MIB_NET_ID:\r\n        {\r\n            Nvm.MacGroup2.NetID = mibSet->Param.NetID;\r\n            break;\r\n        }\r\n        case MIB_DEV_ADDR:\r\n        {\r\n            Nvm.MacGroup2.DevAddr = mibSet->Param.DevAddr;\r\n            break;\r\n        }\r\n        case MIB_APP_KEY:\r\n        {\r\n            if( mibSet->Param.AppKey != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( APP_KEY, mibSet->Param.AppKey ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_NWK_KEY:\r\n        {\r\n            if( mibSet->Param.NwkKey != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( NWK_KEY, mibSet->Param.NwkKey ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_J_S_INT_KEY:\r\n        {\r\n            if( mibSet->Param.JSIntKey != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( J_S_INT_KEY, mibSet->Param.JSIntKey ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_J_S_ENC_KEY:\r\n        {\r\n            if( mibSet->Param.JSEncKey != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( J_S_ENC_KEY, mibSet->Param.JSEncKey ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_F_NWK_S_INT_KEY:\r\n        {\r\n            if( mibSet->Param.FNwkSIntKey != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( F_NWK_S_INT_KEY, mibSet->Param.FNwkSIntKey ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_S_NWK_S_INT_KEY:\r\n        {\r\n            if( mibSet->Param.SNwkSIntKey != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( S_NWK_S_INT_KEY, mibSet->Param.SNwkSIntKey ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_NWK_S_ENC_KEY:\r\n        {\r\n            if( mibSet->Param.NwkSEncKey != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( NWK_S_ENC_KEY, mibSet->Param.NwkSEncKey ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_APP_S_KEY:\r\n        {\r\n            if( mibSet->Param.AppSKey != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( APP_S_KEY, mibSet->Param.AppSKey ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_MC_KE_KEY:\r\n        {\r\n            if( mibSet->Param.McKEKey != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_KE_KEY, mibSet->Param.McKEKey ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_MC_KEY_0:\r\n        {\r\n            if( mibSet->Param.McKey0 != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_KEY_0, mibSet->Param.McKey0 ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_MC_APP_S_KEY_0:\r\n        {\r\n            if( mibSet->Param.McAppSKey0 != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_APP_S_KEY_0, mibSet->Param.McAppSKey0 ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_MC_NWK_S_KEY_0:\r\n        {\r\n            if( mibSet->Param.McNwkSKey0 != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_NWK_S_KEY_0, mibSet->Param.McNwkSKey0 ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_MC_KEY_1:\r\n        {\r\n            if( mibSet->Param.McKey1 != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_KEY_1, mibSet->Param.McKey1 ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_MC_APP_S_KEY_1:\r\n        {\r\n            if( mibSet->Param.McAppSKey1 != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_APP_S_KEY_1, mibSet->Param.McAppSKey1 ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_MC_NWK_S_KEY_1:\r\n        {\r\n            if( mibSet->Param.McNwkSKey1 != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_NWK_S_KEY_1, mibSet->Param.McNwkSKey1 ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_MC_KEY_2:\r\n        {\r\n            if( mibSet->Param.McKey2 != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_KEY_2, mibSet->Param.McKey2 ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_MC_APP_S_KEY_2:\r\n        {\r\n            if( mibSet->Param.McAppSKey2 != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_APP_S_KEY_2, mibSet->Param.McAppSKey2 ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_MC_NWK_S_KEY_2:\r\n        {\r\n            if( mibSet->Param.McNwkSKey2 != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_NWK_S_KEY_2, mibSet->Param.McNwkSKey2 ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_MC_KEY_3:\r\n        {\r\n            if( mibSet->Param.McKey3 != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_KEY_3, mibSet->Param.McKey3 ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_MC_APP_S_KEY_3:\r\n        {\r\n            if( mibSet->Param.McAppSKey3 != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_APP_S_KEY_3, mibSet->Param.McAppSKey3 ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_MC_NWK_S_KEY_3:\r\n        {\r\n            if( mibSet->Param.McNwkSKey3 != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_NWK_S_KEY_3, mibSet->Param.McNwkSKey3 ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_PUBLIC_NETWORK:\r\n        {\r\n            Nvm.MacGroup2.PublicNetwork = mibSet->Param.EnablePublicNetwork;\r\n            Radio.SetPublicNetwork( Nvm.MacGroup2.PublicNetwork );\r\n            break;\r\n        }\r\n        case MIB_RX2_CHANNEL:\r\n        {\r\n            verify.DatarateParams.Datarate = mibSet->Param.Rx2Channel.Datarate;\r\n            verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;\r\n\r\n            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )\r\n            {\r\n                Nvm.MacGroup2.MacParams.Rx2Channel = mibSet->Param.Rx2Channel;\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_RX2_DEFAULT_CHANNEL:\r\n        {\r\n            verify.DatarateParams.Datarate = mibSet->Param.Rx2Channel.Datarate;\r\n            verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;\r\n\r\n            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )\r\n            {\r\n                Nvm.MacGroup2.MacParamsDefaults.Rx2Channel = mibSet->Param.Rx2DefaultChannel;\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_RXC_CHANNEL:\r\n        {\r\n            verify.DatarateParams.Datarate = mibSet->Param.RxCChannel.Datarate;\r\n            verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;\r\n\r\n            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )\r\n            {\r\n                Nvm.MacGroup2.MacParams.RxCChannel = mibSet->Param.RxCChannel;\r\n\r\n                if( ( Nvm.MacGroup2.DeviceClass == CLASS_C ) && ( Nvm.MacGroup2.NetworkActivation != ACTIVATION_TYPE_NONE ) )\r\n                {\r\n                    // We can only compute the RX window parameters directly, if we are already\r\n                    // in class c mode and joined. We cannot setup an RX window in case of any other\r\n                    // class type.\r\n                    // Set the radio into sleep mode in case we are still in RX mode\r\n                    Radio.Sleep( );\r\n\r\n                    OpenContinuousRxCWindow( );\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_RXC_DEFAULT_CHANNEL:\r\n        {\r\n            verify.DatarateParams.Datarate = mibSet->Param.RxCChannel.Datarate;\r\n            verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;\r\n\r\n            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )\r\n            {\r\n                Nvm.MacGroup2.MacParamsDefaults.RxCChannel = mibSet->Param.RxCDefaultChannel;\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_CHANNELS_DEFAULT_MASK:\r\n        {\r\n            chanMaskSet.ChannelsMaskIn = mibSet->Param.ChannelsDefaultMask;\r\n            chanMaskSet.ChannelsMaskType = CHANNELS_DEFAULT_MASK;\r\n\r\n            if( RegionChanMaskSet( Nvm.MacGroup2.Region, &chanMaskSet ) == false )\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_CHANNELS_MASK:\r\n        {\r\n            chanMaskSet.ChannelsMaskIn = mibSet->Param.ChannelsMask;\r\n            chanMaskSet.ChannelsMaskType = CHANNELS_MASK;\r\n\r\n            if( RegionChanMaskSet( Nvm.MacGroup2.Region, &chanMaskSet ) == false )\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_CHANNELS_NB_TRANS:\r\n        {\r\n            if( ( mibSet->Param.ChannelsNbTrans >= 1 ) &&\r\n                ( mibSet->Param.ChannelsNbTrans <= 15 ) )\r\n            {\r\n                Nvm.MacGroup2.MacParams.ChannelsNbTrans = mibSet->Param.ChannelsNbTrans;\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_MAX_RX_WINDOW_DURATION:\r\n        {\r\n            Nvm.MacGroup2.MacParams.MaxRxWindow = mibSet->Param.MaxRxWindow;\r\n            break;\r\n        }\r\n        case MIB_RECEIVE_DELAY_1:\r\n        {\r\n            Nvm.MacGroup2.MacParams.ReceiveDelay1 = mibSet->Param.ReceiveDelay1;\r\n            break;\r\n        }\r\n        case MIB_RECEIVE_DELAY_2:\r\n        {\r\n            Nvm.MacGroup2.MacParams.ReceiveDelay2 = mibSet->Param.ReceiveDelay2;\r\n            break;\r\n        }\r\n        case MIB_JOIN_ACCEPT_DELAY_1:\r\n        {\r\n            Nvm.MacGroup2.MacParams.JoinAcceptDelay1 = mibSet->Param.JoinAcceptDelay1;\r\n            break;\r\n        }\r\n        case MIB_JOIN_ACCEPT_DELAY_2:\r\n        {\r\n            Nvm.MacGroup2.MacParams.JoinAcceptDelay2 = mibSet->Param.JoinAcceptDelay2;\r\n            break;\r\n        }\r\n        case MIB_CHANNELS_DEFAULT_DATARATE:\r\n        {\r\n            verify.DatarateParams.Datarate = mibSet->Param.ChannelsDefaultDatarate;\r\n\r\n            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_DEF_TX_DR ) == true )\r\n            {\r\n                Nvm.MacGroup2.ChannelsDatarateDefault = verify.DatarateParams.Datarate;\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_CHANNELS_DATARATE:\r\n        {\r\n            verify.DatarateParams.Datarate = mibSet->Param.ChannelsDatarate;\r\n            verify.DatarateParams.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;\r\n\r\n            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_TX_DR ) == true )\r\n            {\r\n                Nvm.MacGroup1.ChannelsDatarate = verify.DatarateParams.Datarate;\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_CHANNELS_DEFAULT_TX_POWER:\r\n        {\r\n            verify.TxPower = mibSet->Param.ChannelsDefaultTxPower;\r\n\r\n            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_DEF_TX_POWER ) == true )\r\n            {\r\n                Nvm.MacGroup2.ChannelsTxPowerDefault = verify.TxPower;\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_CHANNELS_TX_POWER:\r\n        {\r\n            verify.TxPower = mibSet->Param.ChannelsTxPower;\r\n\r\n            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_TX_POWER ) == true )\r\n            {\r\n                Nvm.MacGroup1.ChannelsTxPower = verify.TxPower;\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_SYSTEM_MAX_RX_ERROR:\r\n        {\r\n            Nvm.MacGroup2.MacParams.SystemMaxRxError = Nvm.MacGroup2.MacParamsDefaults.SystemMaxRxError = mibSet->Param.SystemMaxRxError;\r\n            break;\r\n        }\r\n        case MIB_MIN_RX_SYMBOLS:\r\n        {\r\n            Nvm.MacGroup2.MacParams.MinRxSymbols = Nvm.MacGroup2.MacParamsDefaults.MinRxSymbols = mibSet->Param.MinRxSymbols;\r\n            break;\r\n        }\r\n        case MIB_ANTENNA_GAIN:\r\n        {\r\n            Nvm.MacGroup2.MacParams.AntennaGain = mibSet->Param.AntennaGain;\r\n            break;\r\n        }\r\n        case MIB_DEFAULT_ANTENNA_GAIN:\r\n        {\r\n            Nvm.MacGroup2.MacParamsDefaults.AntennaGain = mibSet->Param.DefaultAntennaGain;\r\n            break;\r\n        }\r\n        case MIB_NVM_CTXS:\r\n        {\r\n            if( mibSet->Param.Contexts != 0 )\r\n            {\r\n                status = RestoreNvmData( mibSet->Param.Contexts );\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_ABP_LORAWAN_VERSION:\r\n        {\r\n            if( mibSet->Param.AbpLrWanVersion.Fields.Minor <= 1 )\r\n            {\r\n                Nvm.MacGroup2.Version = mibSet->Param.AbpLrWanVersion;\r\n\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetLrWanVersion( mibSet->Param.AbpLrWanVersion ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_IS_CERT_FPORT_ON:\r\n        {\r\n            Nvm.MacGroup2.IsCertPortOn = mibSet->Param.IsCertPortOn;\r\n            break;\r\n        }\r\n        case MIB_REJOIN_0_CYCLE:\r\n        {\r\n            uint32_t cycleTime = 0;\r\n            if( ( ConvertRejoinCycleTime( mibSet->Param.Rejoin0CycleInSec, &cycleTime ) == true ) &&\r\n                ( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_OTAA ) )\r\n            {\r\n                Nvm.MacGroup2.Rejoin0CycleInSec = mibSet->Param.Rejoin0CycleInSec;\r\n                MacCtx.Rejoin0CycleTime = cycleTime;\r\n                TimerStop( &MacCtx.Rejoin0CycleTimer );\r\n                TimerSetValue( &MacCtx.Rejoin0CycleTimer, MacCtx.Rejoin0CycleTime );\r\n                TimerStart( &MacCtx.Rejoin0CycleTimer );\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_REJOIN_1_CYCLE:\r\n        {\r\n            uint32_t cycleTime = 0;\r\n            if( ( ConvertRejoinCycleTime( mibSet->Param.Rejoin1CycleInSec, &cycleTime ) == true ) &&\r\n                ( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_OTAA ) )\r\n            {\r\n                Nvm.MacGroup2.Rejoin1CycleInSec = mibSet->Param.Rejoin1CycleInSec;\r\n                MacCtx.Rejoin0CycleTime = cycleTime;\r\n                TimerStop( &MacCtx.Rejoin1CycleTimer );\r\n                TimerSetValue( &MacCtx.Rejoin1CycleTimer, MacCtx.Rejoin1CycleTime );\r\n                TimerStart( &MacCtx.Rejoin1CycleTimer );\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_ADR_ACK_LIMIT:\r\n        {\r\n            Nvm.MacGroup2.MacParams.AdrAckLimit = mibSet->Param.AdrAckLimit;\r\n            break;\r\n        }\r\n        case MIB_ADR_ACK_DELAY:\r\n        {\r\n            Nvm.MacGroup2.MacParams.AdrAckDelay = mibSet->Param.AdrAckDelay;\r\n            break;\r\n        }\r\n        case MIB_ADR_ACK_DEFAULT_LIMIT:\r\n        {\r\n            Nvm.MacGroup2.MacParamsDefaults.AdrAckLimit = mibSet->Param.AdrAckLimit;\r\n            break;\r\n        }\r\n        case MIB_ADR_ACK_DEFAULT_DELAY:\r\n        {\r\n            Nvm.MacGroup2.MacParamsDefaults.AdrAckDelay = mibSet->Param.AdrAckDelay;\r\n            break;\r\n        }\r\n        case MIB_RSSI_FREE_THRESHOLD:\r\n        {\r\n#if defined(REGION_KR920) || defined(REGION_AS923)\r\n            if( Nvm.MacGroup2.Region != LORAMAC_REGION_AS923 && Nvm.MacGroup2.Region != LORAMAC_REGION_KR920 )\r\n            {\r\n                status = LORAMAC_STATUS_ERROR;\r\n            }\r\n            else\r\n            {\r\n                Nvm.RegionGroup2.RssiFreeThreshold = mibSet->Param.RssiFreeThreshold;\r\n            }\r\n#else\r\n            status = LORAMAC_STATUS_ERROR;\r\n#endif\r\n            break;\r\n        }\r\n        case MIB_CARRIER_SENSE_TIME:\r\n        {\r\n#if defined(REGION_KR920) || defined(REGION_AS923)\r\n            if( Nvm.MacGroup2.Region != LORAMAC_REGION_AS923 && Nvm.MacGroup2.Region != LORAMAC_REGION_KR920 )\r\n            {\r\n                status = LORAMAC_STATUS_ERROR;\r\n            }\r\n            else\r\n            {\r\n                Nvm.RegionGroup2.CarrierSenseTime = mibSet->Param.CarrierSenseTime;\r\n            }\r\n#else\r\n            status = LORAMAC_STATUS_ERROR;\r\n#endif\r\n            break;\r\n        }\r\n        default:\r\n        {\r\n            status = LoRaMacMibClassBSetRequestConfirm( mibSet );\r\n            break;\r\n        }\r\n    }\r\n\r\n    if( status == LORAMAC_STATUS_OK )\r\n    {\r\n        // Handle NVM potential changes\r\n        MacCtx.MacFlags.Bits.NvmHandle = 1;\r\n    }\r\n    return status;\r\n}\r\n\r\nLoRaMacStatus_t LoRaMacChannelAdd( uint8_t id, ChannelParams_t params )\r\n{\r\n    ChannelAddParams_t channelAdd;\r\n\r\n    // Validate if the MAC is in a correct state\r\n    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )\r\n    {\r\n        if( ( MacCtx.MacState & LORAMAC_TX_CONFIG ) != LORAMAC_TX_CONFIG )\r\n        {\r\n            return LORAMAC_STATUS_BUSY;\r\n        }\r\n    }\r\n\r\n    channelAdd.NewChannel = &params;\r\n    channelAdd.ChannelId = id;\r\n    return RegionChannelAdd( Nvm.MacGroup2.Region, &channelAdd );\r\n}\r\n\r\nLoRaMacStatus_t LoRaMacChannelRemove( uint8_t id )\r\n{\r\n    ChannelRemoveParams_t channelRemove;\r\n\r\n    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )\r\n    {\r\n        if( ( MacCtx.MacState & LORAMAC_TX_CONFIG ) != LORAMAC_TX_CONFIG )\r\n        {\r\n            return LORAMAC_STATUS_BUSY;\r\n        }\r\n    }\r\n\r\n    channelRemove.ChannelId = id;\r\n\r\n    if( RegionChannelsRemove( Nvm.MacGroup2.Region, &channelRemove ) == false )\r\n    {\r\n        return LORAMAC_STATUS_PARAMETER_INVALID;\r\n    }\r\n    return LORAMAC_STATUS_OK;\r\n}\r\n\r\nLoRaMacStatus_t LoRaMacMcChannelSetup( McChannelParams_t *channel )\r\n{\r\n    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )\r\n    {\r\n        return LORAMAC_STATUS_BUSY;\r\n    }\r\n\r\n    if( channel->GroupID >= LORAMAC_MAX_MC_CTX )\r\n    {\r\n        return LORAMAC_STATUS_MC_GROUP_UNDEFINED;\r\n    }\r\n\r\n    Nvm.MacGroup2.MulticastChannelList[channel->GroupID].ChannelParams = *channel;\r\n    MacCtx.MacFlags.Bits.NvmHandle = 1;\r\n\r\n    if( channel->IsRemotelySetup == true )\r\n    {\r\n        const KeyIdentifier_t mcKeys[LORAMAC_MAX_MC_CTX] = { MC_KEY_0, MC_KEY_1, MC_KEY_2, MC_KEY_3 };\r\n        if( LoRaMacCryptoSetKey( mcKeys[channel->GroupID], channel->McKeys.McKeyE ) != LORAMAC_CRYPTO_SUCCESS )\r\n        {\r\n            return LORAMAC_STATUS_CRYPTO_ERROR;\r\n        }\r\n\r\n        if( LoRaMacCryptoDeriveMcSessionKeyPair( channel->GroupID, channel->Address ) != LORAMAC_CRYPTO_SUCCESS )\r\n        {\r\n            return LORAMAC_STATUS_CRYPTO_ERROR;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        const KeyIdentifier_t mcAppSKeys[LORAMAC_MAX_MC_CTX] = { MC_APP_S_KEY_0, MC_APP_S_KEY_1, MC_APP_S_KEY_2, MC_APP_S_KEY_3 };\r\n        const KeyIdentifier_t mcNwkSKeys[LORAMAC_MAX_MC_CTX] = { MC_NWK_S_KEY_0, MC_NWK_S_KEY_1, MC_NWK_S_KEY_2, MC_NWK_S_KEY_3 };\r\n        if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( mcAppSKeys[channel->GroupID], channel->McKeys.Session.McAppSKey ) )\r\n        {\r\n            return LORAMAC_STATUS_CRYPTO_ERROR;\r\n        }\r\n        if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( mcNwkSKeys[channel->GroupID], channel->McKeys.Session.McNwkSKey ) )\r\n        {\r\n            return LORAMAC_STATUS_CRYPTO_ERROR;\r\n        }\r\n    }\r\n\r\n    // Reset multicast channel downlink counter to initial value.\r\n    *Nvm.MacGroup2.MulticastChannelList[channel->GroupID].DownLinkCounter = FCNT_DOWN_INITIAL_VALUE;\r\n    return LORAMAC_STATUS_OK;\r\n}\r\n\r\nLoRaMacStatus_t LoRaMacMcChannelDelete( AddressIdentifier_t groupID )\r\n{\r\n    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )\r\n    {\r\n        return LORAMAC_STATUS_BUSY;\r\n    }\r\n\r\n    if( ( groupID >= LORAMAC_MAX_MC_CTX ) ||\r\n        ( Nvm.MacGroup2.MulticastChannelList[groupID].ChannelParams.IsEnabled == false ) )\r\n    {\r\n        return LORAMAC_STATUS_MC_GROUP_UNDEFINED;\r\n    }\r\n\r\n    McChannelParams_t channel;\r\n\r\n    // Set all channel fields with 0\r\n    memset1( ( uint8_t* )&channel, 0, sizeof( McChannelParams_t ) );\r\n\r\n    Nvm.MacGroup2.MulticastChannelList[groupID].ChannelParams = channel;\r\n    MacCtx.MacFlags.Bits.NvmHandle = 1;\r\n    return LORAMAC_STATUS_OK;\r\n}\r\n\r\nuint8_t LoRaMacMcChannelGetGroupId( uint32_t mcAddress )\r\n{\r\n    for( uint8_t i = 0; i < LORAMAC_MAX_MC_CTX; i++ )\r\n    {\r\n        if( mcAddress == Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.Address )\r\n        {\r\n            return i;\r\n        }\r\n    }\r\n    return 0xFF;\r\n}\r\n\r\nLoRaMacStatus_t LoRaMacMcChannelSetupRxParams( AddressIdentifier_t groupID, McRxParams_t *rxParams, uint8_t *status )\r\n{\r\n   *status = 0x1C + ( groupID & 0x03 );\r\n\r\n    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )\r\n    {\r\n        return LORAMAC_STATUS_BUSY;\r\n    }\r\n\r\n    if( ( rxParams->Class == CLASS_A ) || ( rxParams->Class > CLASS_C ) )\r\n    {\r\n        return LORAMAC_STATUS_PARAMETER_INVALID;\r\n    }\r\n\r\n    if( ( groupID >= LORAMAC_MAX_MC_CTX ) ||\r\n        ( Nvm.MacGroup2.MulticastChannelList[groupID].ChannelParams.IsEnabled == false ) )\r\n    {\r\n        return LORAMAC_STATUS_MC_GROUP_UNDEFINED;\r\n    }\r\n    *status &= 0x0F; // groupID OK\r\n\r\n    VerifyParams_t verify;\r\n    // Check datarate\r\n    if( rxParams->Class == CLASS_B )\r\n    {\r\n        verify.DatarateParams.Datarate = rxParams->Params.ClassB.Datarate;\r\n    }\r\n    else\r\n    {\r\n        verify.DatarateParams.Datarate = rxParams->Params.ClassC.Datarate;\r\n    }\r\n    verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;\r\n\r\n    if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )\r\n    {\r\n        *status &= 0xFB; // datarate OK\r\n    }\r\n\r\n    // Check frequency\r\n    if( rxParams->Class == CLASS_B )\r\n    {\r\n        verify.Frequency = rxParams->Params.ClassB.Frequency;\r\n    }\r\n    else\r\n    {\r\n        verify.Frequency = rxParams->Params.ClassC.Frequency;\r\n    }\r\n    if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_FREQUENCY ) == true )\r\n    {\r\n        *status &= 0xF7; // frequency OK\r\n    }\r\n\r\n    if( *status == ( groupID & 0x03 ) )\r\n    {\r\n        // Apply parameters\r\n        Nvm.MacGroup2.MulticastChannelList[groupID].ChannelParams.RxParams = *rxParams;\r\n        MacCtx.MacFlags.Bits.NvmHandle = 1;\r\n    }\r\n    else\r\n    {\r\n        return LORAMAC_STATUS_PARAMETER_INVALID;\r\n    }\r\n\r\n    if( rxParams->Class == CLASS_B )\r\n    {\r\n        // Calculate class b parameters\r\n        LoRaMacClassBSetMulticastPeriodicity( &Nvm.MacGroup2.MulticastChannelList[groupID] );\r\n    }\r\n    return LORAMAC_STATUS_OK;\r\n}\r\n\r\nLoRaMacStatus_t LoRaMacMlmeRequest( MlmeReq_t* mlmeRequest )\r\n{\r\n    LoRaMacStatus_t status = LORAMAC_STATUS_SERVICE_UNKNOWN;\r\n    MlmeConfirmQueue_t queueElement;\r\n    uint8_t macCmdPayload[2] = { 0x00, 0x00 };\r\n\r\n    if( mlmeRequest == NULL )\r\n    {\r\n        return LORAMAC_STATUS_PARAMETER_INVALID;\r\n    }\r\n    // Initialize mlmeRequest->ReqReturn.DutyCycleWaitTime to 0 in order to\r\n    // return a valid value in case the MAC is busy.\r\n    mlmeRequest->ReqReturn.DutyCycleWaitTime = 0;\r\n\r\n    if( LoRaMacIsBusy( ) == true )\r\n    {\r\n        return LORAMAC_STATUS_BUSY;\r\n    }\r\n    if( LoRaMacConfirmQueueIsFull( ) == true )\r\n    {\r\n        return LORAMAC_STATUS_BUSY;\r\n    }\r\n\r\n    if( LoRaMacConfirmQueueGetCnt( ) == 0 )\r\n    {\r\n        memset1( ( uint8_t* ) &MacCtx.MlmeConfirm, 0, sizeof( MacCtx.MlmeConfirm ) );\r\n    }\r\n    MacCtx.MlmeConfirm.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\r\n\r\n    MacCtx.MacFlags.Bits.MlmeReq = 1;\r\n    queueElement.Request = mlmeRequest->Type;\r\n    queueElement.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\r\n    queueElement.RestrictCommonReadyToHandle = false;\r\n    queueElement.ReadyToHandle = false;\r\n\r\n    switch( mlmeRequest->Type )\r\n    {\r\n        case MLME_JOIN:\r\n        {\r\n            if( ( MacCtx.MacState & LORAMAC_TX_DELAYED ) == LORAMAC_TX_DELAYED )\r\n            {\r\n                return LORAMAC_STATUS_BUSY;\r\n            }\r\n\r\n            if( mlmeRequest->Req.Join.NetworkActivation == ACTIVATION_TYPE_OTAA )\r\n            {\r\n                ResetMacParameters( false );\r\n\r\n            Nvm.MacGroup1.ChannelsDatarate = RegionAlternateDr( Nvm.MacGroup2.Region, mlmeRequest->Req.Join.Datarate, ALTERNATE_DR );\r\n\r\n                queueElement.Status = LORAMAC_EVENT_INFO_STATUS_JOIN_FAIL;\r\n\r\n                status = SendReJoinReq( JOIN_REQ );\r\n\r\n                if( status != LORAMAC_STATUS_OK )\r\n                {\r\n                    // Revert back the previous datarate ( mainly used for US915 like regions )\r\n                    Nvm.MacGroup1.ChannelsDatarate = RegionAlternateDr( Nvm.MacGroup2.Region, mlmeRequest->Req.Join.Datarate, ALTERNATE_DR_RESTORE );\r\n                }\r\n            }\r\n            else if( mlmeRequest->Req.Join.NetworkActivation == ACTIVATION_TYPE_ABP )\r\n            {\r\n                // Restore default value for ChannelsDatarateChangedLinkAdrReq\r\n                Nvm.MacGroup2.ChannelsDatarateChangedLinkAdrReq = false;\r\n\r\n                // Activate the default channels\r\n                InitDefaultsParams_t params;\r\n                params.Type = INIT_TYPE_ACTIVATE_DEFAULT_CHANNELS;\r\n                RegionInitDefaults( Nvm.MacGroup2.Region, &params );\r\n\r\n                Nvm.MacGroup2.NetworkActivation = mlmeRequest->Req.Join.NetworkActivation;\r\n                queueElement.Status = LORAMAC_EVENT_INFO_STATUS_OK;\r\n                queueElement.ReadyToHandle = true;\r\n                MacCtx.MacCallbacks->MacProcessNotify( );\r\n                MacCtx.MacFlags.Bits.MacDone = 1;\r\n                status = LORAMAC_STATUS_OK;\r\n            }\r\n            break;\r\n        }\r\n        case MLME_REJOIN_0:\r\n        {\r\n            MacCtx.MacFlags.Bits.MlmeReq = 1;\r\n            MacCtx.MlmeConfirm.MlmeRequest = mlmeRequest->Type;\r\n\r\n            status = SendReJoinReq( REJOIN_REQ_0 );\r\n\r\n            break;\r\n        }\r\n        case MLME_REJOIN_1:\r\n        {\r\n            MacCtx.MacFlags.Bits.MlmeReq = 1;\r\n            MacCtx.MlmeConfirm.MlmeRequest = mlmeRequest->Type;\r\n\r\n            status = SendReJoinReq( REJOIN_REQ_1 );\r\n\r\n            break;\r\n        }\r\n        case MLME_REJOIN_2:\r\n        {\r\n            MacCtx.MacFlags.Bits.MlmeReq = 1;\r\n            MacCtx.MlmeConfirm.MlmeRequest = mlmeRequest->Type;\r\n\r\n            status = SendReJoinReq( REJOIN_REQ_2 );\r\n\r\n            break;\r\n        }\r\n        case MLME_LINK_CHECK:\r\n        {\r\n            // LoRaMac will send this command piggy-pack\r\n            status = LORAMAC_STATUS_OK;\r\n            if( LoRaMacCommandsAddCmd( MOTE_MAC_LINK_CHECK_REQ, macCmdPayload, 0 ) != LORAMAC_COMMANDS_SUCCESS )\r\n            {\r\n                status = LORAMAC_STATUS_MAC_COMMAD_ERROR;\r\n            }\r\n            break;\r\n        }\r\n        case MLME_TXCW:\r\n        {\r\n            status = SetTxContinuousWave( mlmeRequest->Req.TxCw.Timeout, mlmeRequest->Req.TxCw.Frequency, mlmeRequest->Req.TxCw.Power );\r\n            break;\r\n        }\r\n        case MLME_DEVICE_TIME:\r\n        {\r\n            // LoRaMac will send this command piggy-pack\r\n            status = LORAMAC_STATUS_OK;\r\n            if( LoRaMacCommandsAddCmd( MOTE_MAC_DEVICE_TIME_REQ, macCmdPayload, 0 ) != LORAMAC_COMMANDS_SUCCESS )\r\n            {\r\n                status = LORAMAC_STATUS_MAC_COMMAD_ERROR;\r\n            }\r\n            break;\r\n        }\r\n        case MLME_PING_SLOT_INFO:\r\n        {\r\n            if( Nvm.MacGroup2.DeviceClass == CLASS_A )\r\n            {\r\n                uint8_t value = mlmeRequest->Req.PingSlotInfo.PingSlot.Value;\r\n\r\n                // LoRaMac will send this command piggy-pack\r\n                LoRaMacClassBSetPingSlotInfo( mlmeRequest->Req.PingSlotInfo.PingSlot.Fields.Periodicity );\r\n                macCmdPayload[0] = value;\r\n                status = LORAMAC_STATUS_OK;\r\n                if( LoRaMacCommandsAddCmd( MOTE_MAC_PING_SLOT_INFO_REQ, macCmdPayload, 1 ) != LORAMAC_COMMANDS_SUCCESS )\r\n                {\r\n                    status = LORAMAC_STATUS_MAC_COMMAD_ERROR;\r\n                }\r\n            }\r\n            break;\r\n        }\r\n        case MLME_BEACON_TIMING:\r\n        {\r\n            // LoRaMac will send this command piggy-pack\r\n            status = LORAMAC_STATUS_OK;\r\n            if( LoRaMacCommandsAddCmd( MOTE_MAC_BEACON_TIMING_REQ, macCmdPayload, 0 ) != LORAMAC_COMMANDS_SUCCESS )\r\n            {\r\n                status = LORAMAC_STATUS_MAC_COMMAD_ERROR;\r\n            }\r\n            break;\r\n        }\r\n        case MLME_BEACON_ACQUISITION:\r\n        {\r\n            // Apply the request\r\n            queueElement.RestrictCommonReadyToHandle = true;\r\n\r\n            if( LoRaMacClassBIsAcquisitionInProgress( ) == false )\r\n            {\r\n                // Start class B algorithm\r\n                LoRaMacClassBSetBeaconState( BEACON_STATE_ACQUISITION );\r\n                LoRaMacClassBBeaconTimerEvent( NULL );\r\n\r\n                status = LORAMAC_STATUS_OK;\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_BUSY;\r\n            }\r\n            break;\r\n        }\r\n        default:\r\n            break;\r\n    }\r\n\r\n    // Fill return structure\r\n    mlmeRequest->ReqReturn.DutyCycleWaitTime = MacCtx.DutyCycleWaitTime;\r\n\r\n    if( status != LORAMAC_STATUS_OK )\r\n    {\r\n        if( LoRaMacConfirmQueueGetCnt( ) == 0 )\r\n        {\r\n            MacCtx.NodeAckRequested = false;\r\n            MacCtx.MacFlags.Bits.MlmeReq = 0;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        LoRaMacConfirmQueueAdd( &queueElement );\r\n    }\r\n    return status;\r\n}\r\n\r\nLoRaMacStatus_t LoRaMacMcpsRequest( McpsReq_t* mcpsRequest )\r\n{\r\n    GetPhyParams_t getPhy;\r\n    PhyParam_t phyParam;\r\n    LoRaMacStatus_t status = LORAMAC_STATUS_SERVICE_UNKNOWN;\r\n    LoRaMacHeader_t macHdr;\r\n    VerifyParams_t verify;\r\n    uint8_t fPort = 0;\r\n    void* fBuffer;\r\n    uint16_t fBufferSize;\r\n    int8_t datarate = DR_0;\r\n    bool readyToSend = false;\r\n\r\n    if( mcpsRequest == NULL )\r\n    {\r\n        return LORAMAC_STATUS_PARAMETER_INVALID;\r\n    }\r\n    // Initialize mcpsRequest->ReqReturn.DutyCycleWaitTime to 0 in order to\r\n    // return a valid value in case the MAC is busy.\r\n    mcpsRequest->ReqReturn.DutyCycleWaitTime = 0;\r\n\r\n    if( LoRaMacIsBusy( ) == true )\r\n    {\r\n        return LORAMAC_STATUS_BUSY;\r\n    }\r\n\r\n    McpsReq_t request = *mcpsRequest;\r\n\r\n    macHdr.Value = 0;\r\n    memset1( ( uint8_t* ) &MacCtx.McpsConfirm, 0, sizeof( MacCtx.McpsConfirm ) );\r\n    MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\r\n\r\n    // Apply confirmed downlinks, if the device has not received a valid\r\n    // downlink after a join accept.\r\n    if( ( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_OTAA ) &&\r\n        ( Nvm.MacGroup2.DeviceClass == CLASS_C ) &&\r\n        ( Nvm.MacGroup2.DownlinkReceived == false ) &&\r\n        ( request.Type == MCPS_UNCONFIRMED ) )\r\n    {\r\n        request.Type = MCPS_CONFIRMED;\r\n    }\r\n\r\n    switch( request.Type )\r\n    {\r\n        case MCPS_UNCONFIRMED:\r\n        {\r\n            readyToSend = true;\r\n\r\n            macHdr.Bits.MType = FRAME_TYPE_DATA_UNCONFIRMED_UP;\r\n            fPort = request.Req.Unconfirmed.fPort;\r\n            fBuffer = request.Req.Unconfirmed.fBuffer;\r\n            fBufferSize = request.Req.Unconfirmed.fBufferSize;\r\n            datarate = request.Req.Unconfirmed.Datarate;\r\n            break;\r\n        }\r\n        case MCPS_CONFIRMED:\r\n        {\r\n            readyToSend = true;\r\n\r\n            macHdr.Bits.MType = FRAME_TYPE_DATA_CONFIRMED_UP;\r\n            fPort = request.Req.Confirmed.fPort;\r\n            fBuffer = request.Req.Confirmed.fBuffer;\r\n            fBufferSize = request.Req.Confirmed.fBufferSize;\r\n            datarate = request.Req.Confirmed.Datarate;\r\n            break;\r\n        }\r\n        case MCPS_PROPRIETARY:\r\n        {\r\n            readyToSend = true;\r\n\r\n            macHdr.Bits.MType = FRAME_TYPE_PROPRIETARY;\r\n            fBuffer = request.Req.Proprietary.fBuffer;\r\n            fBufferSize = request.Req.Proprietary.fBufferSize;\r\n            datarate = request.Req.Proprietary.Datarate;\r\n            break;\r\n        }\r\n        default:\r\n            break;\r\n    }\r\n\r\n    // Make sure that the input datarate is compliant\r\n    // to the regional specification.\r\n    getPhy.Attribute = PHY_MIN_TX_DR;\r\n    getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;\r\n    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );\r\n    // Apply the minimum possible datarate.\r\n    // Some regions have limitations for the minimum datarate.\r\n    datarate = MAX( datarate, ( int8_t )phyParam.Value );\r\n\r\n    // Apply minimum datarate in this special case.\r\n    if( CheckForMinimumAbpDatarate( Nvm.MacGroup2.AdrCtrlOn, Nvm.MacGroup2.NetworkActivation,\r\n                                    Nvm.MacGroup2.ChannelsDatarateChangedLinkAdrReq ) == true )\r\n    {\r\n        datarate = ( int8_t )phyParam.Value;\r\n    }\r\n\r\n    if( readyToSend == true )\r\n    {\r\n        if( ( Nvm.MacGroup2.AdrCtrlOn == false ) ||\r\n            ( CheckForMinimumAbpDatarate( Nvm.MacGroup2.AdrCtrlOn, Nvm.MacGroup2.NetworkActivation,\r\n                                          Nvm.MacGroup2.ChannelsDatarateChangedLinkAdrReq ) == true ) )\r\n        {\r\n            verify.DatarateParams.Datarate = datarate;\r\n            verify.DatarateParams.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;\r\n\r\n            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_TX_DR ) == true )\r\n            {\r\n                Nvm.MacGroup1.ChannelsDatarate = verify.DatarateParams.Datarate;\r\n            }\r\n            else\r\n            {\r\n                return LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n        }\r\n\r\n        // Verification of response timeout for class b and class c\r\n        LoRaMacHandleResponseTimeout( REGION_COMMON_CLASS_B_C_RESP_TIMEOUT,\r\n                                      MacCtx.ResponseTimeoutStartTime );\r\n\r\n        status = Send( &macHdr, fPort, fBuffer, fBufferSize );\r\n        if( status == LORAMAC_STATUS_OK )\r\n        {\r\n            MacCtx.McpsConfirm.McpsRequest = request.Type;\r\n            MacCtx.MacFlags.Bits.McpsReq = 1;\r\n        }\r\n        else\r\n        {\r\n            MacCtx.NodeAckRequested = false;\r\n        }\r\n    }\r\n\r\n    // Fill return structure\r\n    mcpsRequest->ReqReturn.DutyCycleWaitTime = MacCtx.DutyCycleWaitTime;\r\n\r\n    return status;\r\n}\r\n\r\nstatic bool ConvertRejoinCycleTime( uint32_t rejoinCycleTime, uint32_t* timeInMiliSec )\r\n{\r\n    // Our timer implementation do not allow longer times than 4294967295 ms\r\n    if( rejoinCycleTime <= 4294967 )\r\n    {\r\n        *timeInMiliSec = rejoinCycleTime * 1000;\r\n        return true;\r\n    }\r\n    else\r\n    {\r\n        return false;\r\n    }\r\n}\r\n\r\nstatic void OnRejoin0CycleTimerEvent( void* context )\r\n{\r\n    TimerStop( &MacCtx.Rejoin0CycleTimer );\r\n    ConvertRejoinCycleTime( Nvm.MacGroup2.Rejoin0CycleInSec, &MacCtx.Rejoin0CycleTime );\r\n\r\n    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )\r\n    {\r\n        MacCtx.MacCallbacks->MacProcessNotify( );\r\n    }\r\n\r\n    Nvm.MacGroup2.IsRejoin0RequestQueued = true;\r\n\r\n    TimerSetValue( &MacCtx.Rejoin0CycleTimer, MacCtx.Rejoin0CycleTime );\r\n    TimerStart( &MacCtx.Rejoin0CycleTimer );\r\n}\r\n\r\nstatic void OnRejoin1CycleTimerEvent( void* context )\r\n{\r\n    TimerStop( &MacCtx.Rejoin1CycleTimer );\r\n    ConvertRejoinCycleTime( Nvm.MacGroup2.Rejoin1CycleInSec, &MacCtx.Rejoin1CycleTime );\r\n\r\n    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )\r\n    {\r\n        MacCtx.MacCallbacks->MacProcessNotify( );\r\n    }\r\n\r\n    Nvm.MacGroup2.IsRejoin1RequestQueued = true;\r\n\r\n    TimerSetValue( &MacCtx.Rejoin1CycleTimer, MacCtx.Rejoin1CycleTime );\r\n    TimerStart( &MacCtx.Rejoin1CycleTimer );\r\n}\r\n\r\nstatic void OnForceRejoinReqCycleTimerEvent( void* context )\r\n{\r\n    Nvm.MacGroup1.ForceRejoinRetriesCounter++;\r\n    if( ( Nvm.MacGroup2.ForceRejoinType == 0 ) || ( Nvm.MacGroup2.ForceRejoinType == 1 ) )\r\n    {\r\n        Nvm.MacGroup2.IsRejoin0RequestQueued = true;\r\n    }\r\n    else\r\n    {\r\n        Nvm.MacGroup2.IsRejoin2RequestQueued = true;\r\n    }\r\n\r\n    if( Nvm.MacGroup1.ForceRejoinRetriesCounter >= Nvm.MacGroup2.ForceRejoinMaxRetries )\r\n    {\r\n        TimerStop( &MacCtx.ForceRejoinReqCycleTimer );\r\n        Nvm.MacGroup1.ForceRejoinRetriesCounter = 0;\r\n    }\r\n    else\r\n    {\r\n        TimerSetValue( &MacCtx.ForceRejoinReqCycleTimer, MacCtx.ForceRejonCycleTime );\r\n        TimerStart( &MacCtx.ForceRejoinReqCycleTimer );\r\n    }\r\n\r\n    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )\r\n    {\r\n        MacCtx.MacCallbacks->MacProcessNotify( );\r\n    }\r\n}\r\n\r\nvoid LoRaMacTestSetDutyCycleOn( bool enable )\r\n{\r\n    VerifyParams_t verify;\r\n\r\n    verify.DutyCycle = enable;\r\n\r\n    if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_DUTY_CYCLE ) == true )\r\n    {\r\n        Nvm.MacGroup2.DutyCycleOn = enable;\r\n        // Handle NVM potential changes\r\n        MacCtx.MacFlags.Bits.NvmHandle = 1;\r\n    }\r\n}\r\n\r\nLoRaMacStatus_t LoRaMacDeInitialization( void )\r\n{\r\n    // Check the current state of the LoRaMac\r\n    if ( LoRaMacStop( ) == LORAMAC_STATUS_OK )\r\n    {\r\n        // Stop Timers\r\n        TimerStop( &MacCtx.TxDelayedTimer );\r\n        TimerStop( &MacCtx.RxWindowTimer1 );\r\n        TimerStop( &MacCtx.RxWindowTimer2 );\r\n\r\n        // Take care about class B\r\n        LoRaMacClassBHaltBeaconing( );\r\n\r\n        // Reset Mac parameters\r\n        ResetMacParameters( false );\r\n\r\n        // Switch off Radio\r\n        Radio.Sleep( );\r\n\r\n        // Return success\r\n        return LORAMAC_STATUS_OK;\r\n    }\r\n    else\r\n    {\r\n        return LORAMAC_STATUS_BUSY;\r\n    }\r\n}\r\n"], "filenames": ["src/mac/LoRaMac.c"], "buggy_code_start_loc": [940], "buggy_code_end_loc": [940], "fixing_code_start_loc": [941], "fixing_code_end_loc": [949], "type": "CWE-120", "message": "LoRaMac-node is a reference implementation and documentation of a LoRa network node. Versions of LoRaMac-node prior to 4.7.0 are vulnerable to a buffer overflow. Improper size validation of the incoming radio frames can lead to an 65280-byte out-of-bounds write. The function `ProcessRadioRxDone` implicitly expects incoming radio frames to have at least a payload of one byte or more. An empty payload leads to a 1-byte out-of-bounds read of user controlled content when the payload buffer is reused. This allows an attacker to craft a FRAME_TYPE_PROPRIETARY frame with size -1 which results in an 65280-byte out-of-bounds memcopy likely with partially controlled attacker data. Corrupting a large part if the data section is likely to cause a DoS. If the large out-of-bounds write does not immediately crash the attacker may gain control over the execution due to now controlling large parts of the data section. Users are advised to upgrade either by updating their package or by manually applying the patch commit `e851b079`.", "other": {"cve": {"id": "CVE-2022-39274", "sourceIdentifier": "security-advisories@github.com", "published": "2022-10-06T18:16:16.103", "lastModified": "2022-12-08T03:11:02.383", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "LoRaMac-node is a reference implementation and documentation of a LoRa network node. Versions of LoRaMac-node prior to 4.7.0 are vulnerable to a buffer overflow. Improper size validation of the incoming radio frames can lead to an 65280-byte out-of-bounds write. The function `ProcessRadioRxDone` implicitly expects incoming radio frames to have at least a payload of one byte or more. An empty payload leads to a 1-byte out-of-bounds read of user controlled content when the payload buffer is reused. This allows an attacker to craft a FRAME_TYPE_PROPRIETARY frame with size -1 which results in an 65280-byte out-of-bounds memcopy likely with partially controlled attacker data. Corrupting a large part if the data section is likely to cause a DoS. If the large out-of-bounds write does not immediately crash the attacker may gain control over the execution due to now controlling large parts of the data section. Users are advised to upgrade either by updating their package or by manually applying the patch commit `e851b079`."}, {"lang": "es", "value": "LoRaMac-node es una implementaci\u00f3n de referencia y documentaci\u00f3n de un nodo de red LoRa. Las versiones de LoRaMac-node anteriores a 4.7.0 son vulnerables a un desbordamiento del b\u00fafer. Una comprobaci\u00f3n inapropiada del tama\u00f1o de las tramas de radio entrantes puede conllevar a una escritura de 65280 bytes fuera de l\u00edmites. La funci\u00f3n \"ProcessRadioRxDone\" espera impl\u00edcitamente que las tramas de radio entrantes tengan al menos una carga \u00fatil de un byte o m\u00e1s. Una carga \u00fatil vac\u00eda conlleva una lectura de 1 byte fuera de l\u00edmites del contenido controlado por el usuario cuando es reusado el b\u00fafer de carga \u00fatil. Esto permite a un atacante dise\u00f1ar una trama FRAME_TYPE_PROPRIETARY de tama\u00f1o -1, lo que resulta en una copia de memoria de 65280 bytes fuera de l\u00edmites, probablemente con datos parcialmente controlados por el atacante. Corromper una gran parte de la secci\u00f3n de datos puede causar un DoS. Si la gran escritura fuera de l\u00edmites no es bloqueada inmediatamente, el atacante puede conseguir el control de la ejecuci\u00f3n debido a que ahora controla grandes partes de la secci\u00f3n de datos. Es recomendado a usuarios actualizar su paquete o que apliquen manualmente el parche commit \"e851b079\""}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.6, "impactScore": 5.9}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:semtech:loramac-node:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.7.0", "matchCriteriaId": "56397603-5EB1-4482-8FE6-2C606C7D2026"}]}]}], "references": [{"url": "https://github.com/Lora-net/LoRaMac-node/commit/e851b079c82ba1bcf3f4d291ab69a571b0bf458a", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Lora-net/LoRaMac-node/releases/tag/v4.7.0", "source": "security-advisories@github.com", "tags": ["Broken Link", "Third Party Advisory"]}, {"url": "https://github.com/Lora-net/LoRaMac-node/security/advisories/GHSA-7vv8-73pc-63c2", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Lora-net/LoRaMac-node/commit/e851b079c82ba1bcf3f4d291ab69a571b0bf458a"}}