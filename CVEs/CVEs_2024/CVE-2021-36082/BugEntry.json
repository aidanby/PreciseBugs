{"buggy_code": ["/*\n * netbios.c\n *\n * Copyright (C) 2011-21 - ntop.org\n * Copyright (C) 2009-11 - ipoque GmbH\n *\n * This file is part of nDPI, an open source deep packet inspection\n * library based on the OpenDPI and PACE technology by ipoque GmbH\n *\n * nDPI is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * nDPI is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with nDPI.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n\n#include \"ndpi_protocol_ids.h\"\n\n#define NDPI_CURRENT_PROTO NDPI_PROTOCOL_NETBIOS\n\n#include \"ndpi_api.h\"\n\n/* ****************************************************************** */\n\nstruct netbios_header {\n  u_int16_t transaction_id, flags, questions, answer_rrs, authority_rrs, additional_rrs;\n};\n\n/* ****************************************************************** */\n\n/* The function below has been inherited by tcpdump */\nint ndpi_netbios_name_interpret(char *in, size_t in_len, char *out, u_int out_len) {\n  u_int ret = 0, len, idx = in_len, out_idx = 0;\n\n  len = (*in++)/2;\n  out_len--;\n  out[out_idx] = 0;\n\n  if((len > out_len) || (len < 1) || ((2*len) > in_len))\n    return(-1);\n\n  while((len--) && (out_idx < out_len)) {\n    if((idx < 2) || (in[0] < 'A') || (in[0] > 'P') || (in[1] < 'A') || (in[1] > 'P')) {\n      out[out_idx] = 0;\n      break;\n    }\n\n    out[out_idx] = ((in[0] - 'A') << 4) + (in[1] - 'A');\n    in += 2, idx -= 2;\n\n    if(isprint(out[out_idx]))\n      out_idx++, ret++;\n  }\n\n  /* Trim trailing whitespace from the returned string */\n  if(out_idx > 0) {\n    out[out_idx] = 0;\n    out_idx--;\n\n    while((out_idx > 0) && (out[out_idx] == ' ')) {\n      out[out_idx] = 0;\n      out_idx--;\n    }\n\n  }\n\n  return(ret);\n}\n\n/* ****************************************************************** */\n\nstatic void ndpi_int_netbios_add_connection(struct ndpi_detection_module_struct *ndpi_struct,\n\t\t\t\t\t    struct ndpi_flow_struct *flow,\n\t\t\t\t\t    u_int16_t sub_protocol) {\n  char name[64];\n  u_int off = flow->packet.payload[12] == 0x20 ? 12 : 14;\n\n  if((off < flow->packet.payload_packet_len)\n     && ndpi_netbios_name_interpret((char*)&flow->packet.payload[off],\n\t\t\t\t flow->packet.payload_packet_len - off, name, sizeof(name)) > 0) {\n      snprintf((char*)flow->host_server_name, sizeof(flow->host_server_name)-1, \"%s\", name);\n\n      ndpi_check_dga_name(ndpi_struct, flow, (char*)flow->host_server_name, 1);\n  }\n\n  if(sub_protocol == NDPI_PROTOCOL_UNKNOWN)\n    ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_NETBIOS, NDPI_PROTOCOL_UNKNOWN);\n  else\n    ndpi_set_detected_protocol(ndpi_struct, flow, sub_protocol, NDPI_PROTOCOL_NETBIOS);\n}\n\n/* ****************************************************************** */\n\nvoid ndpi_search_netbios(struct ndpi_detection_module_struct *ndpi_struct,\n\t\t\t struct ndpi_flow_struct *flow) {\n  struct ndpi_packet_struct *packet = &flow->packet;\n  u_int16_t dport;\n\n  NDPI_LOG_DBG(ndpi_struct, \"search netbios\\n\");\n\n  if(packet->udp != NULL) {\n    dport = ntohs(packet->udp->dest);\n\n    /*check standard NETBIOS over udp to port 137  */\n    if((dport == 137 || 0) && packet->payload_packet_len >= 50) {\n      struct netbios_header h;\n\n      memcpy(&h, packet->payload, sizeof(struct netbios_header));\n      h.transaction_id = ntohs(h.transaction_id), h.flags = ntohs(h.flags),\n\th.questions = ntohs(h.questions), h.answer_rrs = ntohs(h.answer_rrs),\n\th.authority_rrs = ntohs(h.authority_rrs), h.additional_rrs = ntohs(h.additional_rrs);\n\n      NDPI_LOG_DBG(ndpi_struct, \"found netbios port 137 and payload_packet_len 50\\n\");\n\n      if(h.flags == 0 &&\n\t h.questions == 1 &&\n\t h.answer_rrs == 0 &&\n\t h.authority_rrs == 0 && h.additional_rrs == 0) {\n\n\tNDPI_LOG_INFO(ndpi_struct, \"found netbios with questions = 1 and answers = 0, authority = 0  \\n\");\n\n\tndpi_int_netbios_add_connection(ndpi_struct, flow, NDPI_PROTOCOL_UNKNOWN);\n\treturn;\n      }\n\n      if(((h.flags & 0x8710) == 0x10) &&\n\t h.questions == 1 &&\n\t h.answer_rrs == 0 &&\n\t h.authority_rrs == 0) {\n\n\tNDPI_LOG_INFO(ndpi_struct, \"found netbios with questions = 1 and answers = 0, authority = 0 and broadcast \\n\");\n\n\tndpi_int_netbios_add_connection(ndpi_struct, flow, NDPI_PROTOCOL_UNKNOWN);\n\treturn;\n      }\n\n      if(packet->payload[2] == 0x80 &&\n\t h.questions == 1 &&\n\t h.answer_rrs == 0 &&\n\t h.authority_rrs == 0 && h.additional_rrs == 1) {\n\n\tNDPI_LOG_INFO(ndpi_struct, \"found netbios with questions = 1 and answers, authority, additional = 0  \\n\");\n\n\tndpi_int_netbios_add_connection(ndpi_struct, flow, NDPI_PROTOCOL_UNKNOWN);\n\treturn;\n      }\n\n      if(h.flags == 0x4000 &&\n\t h.questions == 1 &&\n\t h.answer_rrs == 0 &&\n\t h.authority_rrs == 0 && h.additional_rrs == 1) {\n\n\tNDPI_LOG_INFO(ndpi_struct, \"found netbios with questions = 1 and answers = 0, authority = 0  \\n\");\n\n\tndpi_int_netbios_add_connection(ndpi_struct, flow, NDPI_PROTOCOL_UNKNOWN);\n\treturn;\n      }\n\n      if(h.flags == 0x8400 &&\n\t h.questions == 0 &&\n\t h.answer_rrs == 1 &&\n\t h.authority_rrs == 0 && h.additional_rrs == 0) {\n\n\tNDPI_LOG_INFO(ndpi_struct,\n\t\t      \"found netbios with flag 8400 questions = 0 and answers = 1, authority, additional = 0  \\n\");\n\n\tndpi_int_netbios_add_connection(ndpi_struct, flow, NDPI_PROTOCOL_UNKNOWN);\n\treturn;\n      }\n\n      if(h.flags == 0x8500 &&\n\t h.questions == 0 &&\n\t h.answer_rrs == 1 &&\n\t h.authority_rrs == 0 && h.additional_rrs == 0) {\n\n\tNDPI_LOG_INFO(ndpi_struct,\n\t\t      \"found netbios with flag 8500 questions = 0 and answers = 1, authority, additional = 0  \\n\");\n\n\tndpi_int_netbios_add_connection(ndpi_struct, flow, NDPI_PROTOCOL_UNKNOWN);\n\treturn;\n      }\n\n      if(((h.flags == 0x2900) || (h.flags == 0x2910)) &&\n\t h.questions == 1 &&\n\t h.answer_rrs == 0 &&\n\t h.authority_rrs == 0 && h.additional_rrs == 1) {\n\n\tNDPI_LOG_INFO(ndpi_struct,\n\t\t      \"found netbios with flag 2910, questions = 1 and answers, authority=0, additional = 1  \\n\");\n\n\tndpi_int_netbios_add_connection(ndpi_struct, flow, NDPI_PROTOCOL_UNKNOWN);\n\treturn;\n      }\n\n      if(h.flags == 0xAD86 &&\n\t h.questions == 0 &&\n\t h.answer_rrs == 1 &&\n\t h.authority_rrs == 0 && h.additional_rrs == 0) {\n\n\tNDPI_LOG_INFO(ndpi_struct,\n\t\t      \"found netbios with flag ad86 questions = 0 and answers = 1, authority, additional = 0  \\n\");\n\n\tndpi_int_netbios_add_connection(ndpi_struct, flow, NDPI_PROTOCOL_UNKNOWN);\n\treturn;\n      }\n\n      if(h.flags == 0x0110 &&\n\t h.questions == 1 &&\n\t h.answer_rrs == 0 &&\n\t h.authority_rrs == 0 && h.additional_rrs == 0) {\n\n\tNDPI_LOG_INFO(ndpi_struct,\n\t\t      \"found netbios with flag 0110 questions = 1 and answers = 0, authority, additional = 0  \\n\");\n\n\tndpi_int_netbios_add_connection(ndpi_struct, flow, NDPI_PROTOCOL_UNKNOWN);\n\treturn;\n      }\n\n      if((h.flags & 0xf800) == 0) {\n\tNDPI_LOG_DBG2(ndpi_struct, \"possible netbios name query request\\n\");\n\n\tif(get_u_int16_t(packet->payload, 4) == htons(1) &&\n\t   get_u_int16_t(packet->payload, 6) == 0 &&\n\t   get_u_int16_t(packet->payload, 8) == 0 && get_u_int16_t(packet->payload, 10) == 0) {\n\n\t  /* name is encoded as described in rfc883 */\n\t  u_int8_t name_length = packet->payload[12];\n\n\t  NDPI_LOG_DBG2(ndpi_struct,\n\t\t\t\"possible netbios name query request, one question\\n\");\n\n\t  if(packet->payload_packet_len == 12 + 1 + name_length + 1 + 2 + 2) {\n\n\t    NDPI_LOG_DBG2(ndpi_struct,\n\t\t\t  \"possible netbios name query request, length matches\\n\");\n\n\t    /* null terminated? */\n\t    if(packet->payload[12 + name_length + 1] == 0 &&\n\t       get_u_int16_t(packet->payload, 12 + name_length + 2) == htons(0x0020) &&\n\t       get_u_int16_t(packet->payload, 12 + name_length + 4) == htons(0x0001)) {\n\n\t      NDPI_LOG_INFO(ndpi_struct,\n\t\t\t    \"found netbios name query request\\n\");\n\t      ndpi_int_netbios_add_connection(ndpi_struct, flow, NDPI_PROTOCOL_UNKNOWN);\n\t      return;\n\t    }\n\t  }\n\t}\n      } else if((h.flags & 0xf800) == 0x8000) {\n\tNDPI_LOG_DBG2(ndpi_struct,\n\t\t      \"possible netbios name query response\\n\");\n\n\tif(get_u_int16_t(packet->payload, 4) == 0 &&\n\t   get_u_int16_t(packet->payload, 6) == htons(1) &&\n\t   get_u_int16_t(packet->payload, 8) == 0 && get_u_int16_t(packet->payload, 10) == 0) {\n\n\t  /* name is encoded as described in rfc883 */\n\t  u_int8_t name_length = packet->payload[12];\n\n\t  NDPI_LOG_DBG2(ndpi_struct,\n\t\t\t\"possible netbios positive name query response, one answer\\n\");\n\n\t  if(packet->payload_packet_len >= 12 + 1 + name_length + 1 + 2 + 2) {\n\n\t    NDPI_LOG_DBG2(ndpi_struct,\n\t\t\t  \"possible netbios name query response, length matches\\n\");\n\n\t    /* null terminated? */\n\t    if(packet->payload[12 + name_length + 1] == 0 &&\n\t       get_u_int16_t(packet->payload, 12 + name_length + 2) == htons(0x0020) &&\n\t       get_u_int16_t(packet->payload, 12 + name_length + 4) == htons(0x0001)) {\n\n\t      NDPI_LOG_INFO(ndpi_struct,\n\t\t\t    \"found netbios name query response\\n\");\n\t      ndpi_int_netbios_add_connection(ndpi_struct, flow, NDPI_PROTOCOL_UNKNOWN);\n\t      return;\n\t    }\n\t  }\n\t} else if(get_u_int16_t(packet->payload, 4) == 0 &&\n\t\t  get_u_int16_t(packet->payload, 6) == 0 &&\n\t\t  get_u_int16_t(packet->payload, 8) == 0 && get_u_int16_t(packet->payload, 10) == 0) {\n\n\t  /* name is encoded as described in rfc883 */\n\t  u_int8_t name_length = packet->payload[12];\n\n\t  NDPI_LOG_DBG2(ndpi_struct,\n\t\t\t\"possible netbios negative name query response, one answer\\n\");\n\n\t  if(packet->payload_packet_len >= 12 + 1 + name_length + 1 + 2 + 2) {\n\n\t    NDPI_LOG_DBG2(ndpi_struct,\n\t\t\t  \"possible netbios name query response, length matches\\n\");\n\n\t    /* null terminated? */\n\t    if(packet->payload[12 + name_length + 1] == 0 &&\n\t       get_u_int16_t(packet->payload, 12 + name_length + 2) == htons(0x000A) &&\n\t       get_u_int16_t(packet->payload, 12 + name_length + 4) == htons(0x0001)) {\n\n\t      NDPI_LOG_INFO(ndpi_struct,\n\t\t\t    \"found netbios name query response\\n\");\n\t      ndpi_int_netbios_add_connection(ndpi_struct, flow, NDPI_PROTOCOL_UNKNOWN);\n\t      return;\n\t    }\n\t  }\n\t} else if(get_u_int16_t(packet->payload, 4) == 0 &&\n\t\t  get_u_int16_t(packet->payload, 6) == 0 &&\n\t\t  get_u_int16_t(packet->payload, 8) == htons(1) && get_u_int16_t(packet->payload, 10) == htons(1)) {\n\n\t  /* name is encoded as described in rfc883 */\n\t  u_int8_t name_length = packet->payload[12];\n\n\t  NDPI_LOG_DBG2(ndpi_struct,\n\t\t\t\"possible netbios redirect name query response, one answer\\n\");\n\n\t  if(packet->payload_packet_len >= 12 + 1 + name_length + 1 + 2 + 2) {\n\n\t    NDPI_LOG_DBG2(ndpi_struct,\n\t\t\t  \"possible netbios name query response, length matches\\n\");\n\n\t    /* null terminated? */\n\t    if(packet->payload[12 + name_length + 1] == 0 &&\n\t       get_u_int16_t(packet->payload, 12 + name_length + 2) == htons(0x0002) &&\n\t       get_u_int16_t(packet->payload, 12 + name_length + 4) == htons(0x0001)) {\n\n\t      NDPI_LOG_INFO(ndpi_struct,\n\t\t\t    \"found netbios name query response\\n\");\n\t      ndpi_int_netbios_add_connection(ndpi_struct, flow, NDPI_PROTOCOL_UNKNOWN);\n\t      return;\n\t    }\n\t  }\n\t}\n      }\n      /* TODO: extend according to rfc1002 */\n    }\n\n    /* check standard NETBIOS over udp to port 138 */\n\n    /* netbios header token from http://www.protocolbase.net/protocols/protocol_NBDGM.php */\n\n    if((dport == 138) && (packet->payload_packet_len >= 14)) {\n      u_int16_t netbios_len = ntohs(get_u_int16_t(packet->payload, 10));\n\n      if(netbios_len == packet->payload_packet_len - 14) {\n\tNDPI_LOG_DBG2(ndpi_struct, \"found netbios port 138 and payload length >= 112 \\n\");\n\n\tif(packet->payload[0] >= 0x10 && packet->payload[0] <= 0x16) {\n\t  u_int32_t source_ip = ntohl(get_u_int32_t(packet->payload, 4));\n\n\t  NDPI_LOG_DBG2(ndpi_struct, \"found netbios with MSG-type 0x10,0x11,0x12,0x13,0x14,0x15 or 0x16\\n\");\n\n\t  if(source_ip == ntohl(packet->iph->saddr)) {\n\t    int16_t leftover = netbios_len - 82; /* NetBIOS len */\n\n\t    NDPI_LOG_INFO(ndpi_struct, \"found netbios with checked ip-address\\n\");\n\n\t    ndpi_int_netbios_add_connection(ndpi_struct, flow, (leftover > 0) ? NDPI_PROTOCOL_SMBV1 : NDPI_PROTOCOL_UNKNOWN);\n\t    return;\n\t  }\n\t}\n      }\n    }\n  }\n\n  if(packet->tcp != NULL) {\n    dport = ntohs(packet->tcp->dest);\n\n    /* destination port must be 139 */\n    if(dport == 139) {\n      NDPI_LOG_DBG2(ndpi_struct, \"found netbios with destination port 139\\n\");\n\n      /* payload_packet_len must be 72 */\n      if(packet->payload_packet_len == 72) {\n\tNDPI_LOG_DBG2(ndpi_struct, \"found netbios with payload_packen_len = 72. \\n\");\n\n\tif(packet->payload[0] == 0x81 && packet->payload[1] == 0 && ntohs(get_u_int16_t(packet->payload, 2)) == 68) {\n\t  NDPI_LOG_INFO(ndpi_struct,\n\t\t\t\"found netbios with session request = 81, flags=0 and length od following bytes = 68. \\n\");\n\n\t  ndpi_int_netbios_add_connection(ndpi_struct, flow, NDPI_PROTOCOL_UNKNOWN);\n\t  return;\n\t}\n      }\n    }\n\n  }\n\n  NDPI_EXCLUDE_PROTO(ndpi_struct, flow);\n}\n\n/* ****************************************************************** */\n\nvoid init_netbios_dissector(struct ndpi_detection_module_struct *ndpi_struct, u_int32_t *id, NDPI_PROTOCOL_BITMASK *detection_bitmask)\n{\n  ndpi_set_bitmask_protocol_detection(\"NETBIOS\", ndpi_struct, detection_bitmask, *id,\n\t\t\t\t      NDPI_PROTOCOL_NETBIOS,\n\t\t\t\t      ndpi_search_netbios,\n\t\t\t\t      NDPI_SELECTION_BITMASK_PROTOCOL_TCP_OR_UDP_WITH_PAYLOAD_WITHOUT_RETRANSMISSION,\n\t\t\t\t      SAVE_DETECTION_BITMASK_AS_UNKNOWN,\n\t\t\t\t      ADD_TO_DETECTION_BITMASK);\n\n  *id += 1;\n}\n", "/*\n * tls.c - TLS/TLS/DTLS dissector\n *\n * Copyright (C) 2016-21 - ntop.org\n *\n * nDPI is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * nDPI is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with nDPI.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n#include \"ndpi_protocol_ids.h\"\n\n#define NDPI_CURRENT_PROTO NDPI_PROTOCOL_TLS\n\n#include \"ndpi_api.h\"\n#include \"ndpi_md5.h\"\n#include \"ndpi_sha1.h\"\n#include \"ndpi_encryption.h\"\n\nextern char *strptime(const char *s, const char *format, struct tm *tm);\nextern int processClientServerHello(struct ndpi_detection_module_struct *ndpi_struct,\n\t\t\t\t    struct ndpi_flow_struct *flow, uint32_t quic_version);\nextern int http_process_user_agent(struct ndpi_detection_module_struct *ndpi_struct,\n                                   struct ndpi_flow_struct *flow,\n                                   const u_int8_t *ua_ptr, u_int16_t ua_ptr_len);\n/* QUIC/GQUIC stuff */\nextern int quic_len(const uint8_t *buf, uint64_t *value);\nextern int quic_len_buffer_still_required(uint8_t value);\nextern int is_version_with_var_int_transport_params(uint32_t version);\n\n// #define DEBUG_TLS_MEMORY       1\n// #define DEBUG_TLS              1\n// #define DEBUG_TLS_BLOCKS       1\n// #define DEBUG_CERTIFICATE_HASH\n\n// #define DEBUG_JA3C 1\n\n/* #define DEBUG_FINGERPRINT      1 */\n/* #define DEBUG_ENCRYPTED_SNI    1 */\n\n/* **************************************** */\n\n/* https://engineering.salesforce.com/tls-fingerprinting-with-ja3-and-ja3s-247362855967 */\n\n#define JA3_STR_LEN        1024\n#define MAX_NUM_JA3         512\n#define MAX_JA3_STRLEN      256\n\nunion ja3_info {\n  struct {\n    u_int16_t tls_handshake_version;\n    u_int16_t num_cipher, cipher[MAX_NUM_JA3];\n    u_int16_t num_tls_extension, tls_extension[MAX_NUM_JA3];\n    u_int16_t num_elliptic_curve, elliptic_curve[MAX_NUM_JA3];\n    u_int16_t num_elliptic_curve_point_format, elliptic_curve_point_format[MAX_NUM_JA3];\n    char signature_algorithms[MAX_JA3_STRLEN], supported_versions[MAX_JA3_STRLEN], alpn[MAX_JA3_STRLEN];\n  } client;\n\n  struct {\n    u_int16_t tls_handshake_version;\n    u_int16_t num_cipher, cipher[MAX_NUM_JA3];\n    u_int16_t num_tls_extension, tls_extension[MAX_NUM_JA3];\n    u_int16_t tls_supported_version;\n    u_int16_t num_elliptic_curve_point_format, elliptic_curve_point_format[MAX_NUM_JA3];\n    char alpn[MAX_JA3_STRLEN];\n  } server; /* Used for JA3+ */\n};\n\n/*\n  NOTE\n\n  How to view the certificate fingerprint\n  1. Using wireshark save the certificate on certificate.bin file as explained\n     in https://security.stackexchange.com/questions/123851/how-can-i-extract-the-certificate-from-this-pcap-file\n\n  2. openssl x509 -inform der -in certificate.bin -text > certificate.der\n  3. openssl x509 -noout -fingerprint -sha1 -inform pem -in certificate.der\n     SHA1 Fingerprint=15:9A:76....\n\n  $ shasum -a 1 www.grc.com.bin\n    159a76.....\n */\n\n#define NDPI_MAX_TLS_REQUEST_SIZE 10000\n\n/* skype.c */\nextern u_int8_t is_skype_flow(struct ndpi_detection_module_struct *ndpi_struct,\n\t\t\t      struct ndpi_flow_struct *flow);\n\n/* stun.c */\nextern u_int32_t get_stun_lru_key(struct ndpi_flow_struct *flow, u_int8_t rev);\n\nstatic void ndpi_int_tls_add_connection(struct ndpi_detection_module_struct *ndpi_struct,\n\t\t\t\t\tstruct ndpi_flow_struct *flow, u_int32_t protocol);\n\n/* **************************************** */\n\nstatic u_int32_t ndpi_tls_refine_master_protocol(struct ndpi_detection_module_struct *ndpi_struct,\n\t\t\t\t\t\t struct ndpi_flow_struct *flow, u_int32_t protocol) {\n  struct ndpi_packet_struct *packet = &flow->packet;\n\n  // protocol = NDPI_PROTOCOL_TLS;\n\n  if(packet->tcp != NULL) {\n    switch(protocol) {\n    case NDPI_PROTOCOL_TLS:\n      {\n\t/*\n\t  In case of TLS there are probably sub-protocols\n\t  such as IMAPS that can be otherwise detected\n\t*/\n\tu_int16_t sport = ntohs(packet->tcp->source);\n\tu_int16_t dport = ntohs(packet->tcp->dest);\n\n\tif((sport == 465) || (dport == 465) || (sport == 587) || (dport == 587))\n\t  protocol = NDPI_PROTOCOL_MAIL_SMTPS;\n\telse if((sport == 993) || (dport == 993)\n\t\t|| (flow->l4.tcp.mail_imap_starttls)\n\t\t) protocol = NDPI_PROTOCOL_MAIL_IMAPS;\n\telse if((sport == 995) || (dport == 995)) protocol = NDPI_PROTOCOL_MAIL_POPS;\n      }\n      break;\n    }\n  }\n\n  return(protocol);\n}\n\n/* **************************************** */\n\nvoid ndpi_search_tls_tcp_memory(struct ndpi_detection_module_struct *ndpi_struct,\n\t\t\t\tstruct ndpi_flow_struct *flow) {\n  struct ndpi_packet_struct *packet = &flow->packet;\n  u_int avail_bytes;\n\n  /* TCP */\n#ifdef DEBUG_TLS_MEMORY\n  printf(\"[TLS Mem] Handling TCP/TLS flow [payload_len: %u][buffer_len: %u][direction: %u]\\n\",\n\t packet->payload_packet_len,\n\t flow->l4.tcp.tls.message.buffer_len,\n\t packet->packet_direction);\n#endif\n\n  if(flow->l4.tcp.tls.message.buffer == NULL) {\n    /* Allocate buffer */\n    flow->l4.tcp.tls.message.buffer_len = 2048, flow->l4.tcp.tls.message.buffer_used = 0;\n    flow->l4.tcp.tls.message.buffer = (u_int8_t*)ndpi_malloc(flow->l4.tcp.tls.message.buffer_len);\n\n    if(flow->l4.tcp.tls.message.buffer == NULL)\n      return;\n\n#ifdef DEBUG_TLS_MEMORY\n    printf(\"[TLS Mem] Allocating %u buffer\\n\", flow->l4.tcp.tls.message.buffer_len);\n#endif\n  }\n\n  avail_bytes = flow->l4.tcp.tls.message.buffer_len - flow->l4.tcp.tls.message.buffer_used;\n\n  if(avail_bytes < packet->payload_packet_len) {\n    u_int new_len = flow->l4.tcp.tls.message.buffer_len + packet->payload_packet_len - avail_bytes + 1;\n    void *newbuf  = ndpi_realloc(flow->l4.tcp.tls.message.buffer,\n\t\t\t\t flow->l4.tcp.tls.message.buffer_len, new_len);\n    if(!newbuf) return;\n\n#ifdef DEBUG_TLS_MEMORY\n    printf(\"[TLS Mem] Enlarging %u -> %u buffer\\n\", flow->l4.tcp.tls.message.buffer_len, new_len);\n#endif\n\n    flow->l4.tcp.tls.message.buffer = (u_int8_t*)newbuf;\n    flow->l4.tcp.tls.message.buffer_len = new_len;\n    avail_bytes = flow->l4.tcp.tls.message.buffer_len - flow->l4.tcp.tls.message.buffer_used;\n  }\n\n  if(packet->payload_packet_len > 0 && avail_bytes >= packet->payload_packet_len) {\n    u_int8_t ok = 0;\n\n    if(flow->l4.tcp.tls.message.next_seq[packet->packet_direction] != 0) {\n      if(ntohl(packet->tcp->seq) == flow->l4.tcp.tls.message.next_seq[packet->packet_direction])\n\tok = 1;\n    } else\n      ok = 1;\n\n    if(ok) {\n      memcpy(&flow->l4.tcp.tls.message.buffer[flow->l4.tcp.tls.message.buffer_used],\n\t     packet->payload, packet->payload_packet_len);\n\n      flow->l4.tcp.tls.message.buffer_used += packet->payload_packet_len;\n#ifdef DEBUG_TLS_MEMORY\n      printf(\"[TLS Mem] Copied data to buffer [%u/%u bytes][direction: %u][tcp_seq: %u][next: %u]\\n\",\n\t     flow->l4.tcp.tls.message.buffer_used, flow->l4.tcp.tls.message.buffer_len,\n\t     packet->packet_direction,\n\t     ntohl(packet->tcp->seq),\n\t     ntohl(packet->tcp->seq)+packet->payload_packet_len);\n#endif\n\n      flow->l4.tcp.tls.message.next_seq[packet->packet_direction] = ntohl(packet->tcp->seq)+packet->payload_packet_len;\n    } else {\n#ifdef DEBUG_TLS_MEMORY\n      printf(\"[TLS Mem] Skipping packet [%u bytes][direction: %u][tcp_seq: %u][expected next: %u]\\n\",\n\t     flow->l4.tcp.tls.message.buffer_len,\n\t     packet->packet_direction,\n\t     ntohl(packet->tcp->seq),\n\t     ntohl(packet->tcp->seq)+packet->payload_packet_len);\n#endif\n    }\n  }\n}\n\n/* **************************************** */\n\n/* Can't call libc functions from kernel space, define some stub instead */\n\n#define ndpi_isalpha(ch) (((ch) >= 'a' && (ch) <= 'z') || ((ch) >= 'A' && (ch) <= 'Z'))\n#define ndpi_isdigit(ch) ((ch) >= '0' && (ch) <= '9')\n#define ndpi_isspace(ch) (((ch) >= '\\t' && (ch) <= '\\r') || ((ch) == ' '))\n#define ndpi_isprint(ch) ((ch) >= 0x20 && (ch) <= 0x7e)\n#define ndpi_ispunct(ch) (((ch) >= '!' && (ch) <= '/') ||\t\\\n\t\t\t  ((ch) >= ':' && (ch) <= '@') ||\t\\\n\t\t\t  ((ch) >= '[' && (ch) <= '`') ||\t\\\n\t\t\t  ((ch) >= '{' && (ch) <= '~'))\n\n/* **************************************** */\n\nstatic void cleanupServerName(char *buffer, int buffer_len) {\n  u_int i;\n\n  /* Now all lowecase */\n  for(i=0; i<buffer_len; i++)\n    buffer[i] = tolower(buffer[i]);\n}\n\n/* **************************************** */\n\n/*\n  Return code\n  -1: error (buffer too short)\n   0: OK but buffer is not human readeable (so something went wrong)\n   1: OK\n */\nstatic int extractRDNSequence(struct ndpi_packet_struct *packet,\n\t\t\t      u_int offset, char *buffer, u_int buffer_len,\n\t\t\t      char *rdnSeqBuf, u_int *rdnSeqBuf_offset,\n\t\t\t      u_int rdnSeqBuf_len,\n\t\t\t      const char *label) {\n  u_int8_t str_len = packet->payload[offset+4], is_printable = 1;\n  char *str;\n  u_int len, j;\n\n  if (*rdnSeqBuf_offset >= rdnSeqBuf_len) {\n#ifdef DEBUG_TLS\n    printf(\"[TLS] %s() [buffer capacity reached][%u]\\n\",\n           __FUNCTION__, rdnSeqBuf_len);\n#endif\n    return -1;\n  }\n\n  // packet is truncated... further inspection is not needed\n  if((offset+4+str_len) >= packet->payload_packet_len)\n    return(-1);\n\n  str = (char*)&packet->payload[offset+5];\n\n  len = (u_int)ndpi_min(str_len, buffer_len-1);\n  strncpy(buffer, str, len);\n  buffer[len] = '\\0';\n\n  // check string is printable\n  for(j = 0; j < len; j++) {\n    if(!ndpi_isprint(buffer[j])) {\n      is_printable = 0;\n      break;\n    }\n  }\n\n  if(is_printable) {\n    int rc = snprintf(&rdnSeqBuf[*rdnSeqBuf_offset],\n\t\t      rdnSeqBuf_len-(*rdnSeqBuf_offset),\n\t\t      \"%s%s=%s\", (*rdnSeqBuf_offset > 0) ? \", \" : \"\",\n\t\t      label, buffer);\n\n    if(rc > 0)\n      (*rdnSeqBuf_offset) += rc;\n  }\n\n  return(is_printable);\n}\n\n/* **************************************** */\n\nstatic void checkTLSSubprotocol(struct ndpi_detection_module_struct *ndpi_struct,\n\t\t\t\tstruct ndpi_flow_struct *flow) {\n  if(flow->detected_protocol_stack[1] == NDPI_PROTOCOL_UNKNOWN) {\n    /* Subprotocol not yet set */\n\n    if(ndpi_struct->tls_cert_cache && flow->packet.iph) {\n      u_int32_t key = flow->packet.iph->daddr + flow->packet.tcp->dest;\n      u_int16_t cached_proto;\n\n      if(ndpi_lru_find_cache(ndpi_struct->tls_cert_cache, key,\n\t\t\t     &cached_proto, 0 /* Don't remove it as it can be used for other connections */)) {\n\tndpi_protocol ret = { NDPI_PROTOCOL_TLS, cached_proto, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED };\n\n\tflow->detected_protocol_stack[0] = cached_proto,\n\tflow->detected_protocol_stack[1] = NDPI_PROTOCOL_TLS;\n\n\tflow->category = ndpi_get_proto_category(ndpi_struct, ret);\n\tndpi_check_subprotocol_risk(flow, cached_proto);\n      }\n    }\n  }\n}\n\n/* **************************************** */\n\n/* See https://blog.catchpoint.com/2017/05/12/dissecting-tls-using-wireshark/ */\nstatic void processCertificateElements(struct ndpi_detection_module_struct *ndpi_struct,\n\t\t\t\t       struct ndpi_flow_struct *flow,\n\t\t\t\t       u_int16_t p_offset, u_int16_t certificate_len) {\n  struct ndpi_packet_struct *packet = &flow->packet;\n  u_int num_found = 0, i;\n  char buffer[64] = { '\\0' }, rdnSeqBuf[2048] = { '\\0' };\n  u_int rdn_len = 0;\n\n#ifdef DEBUG_TLS\n  printf(\"[TLS] %s() [offset: %u][certificate_len: %u]\\n\", __FUNCTION__, p_offset, certificate_len);\n#endif\n\n  /* Check after handshake protocol header (5 bytes) and message header (4 bytes) */\n  for(i = p_offset; i < certificate_len; i++) {\n    /*\n       See https://www.ibm.com/support/knowledgecenter/SSFKSJ_7.5.0/com.ibm.mq.sec.doc/q009860_.htm\n       for X.509 certificate labels\n    */\n    if((packet->payload[i] == 0x55) && (packet->payload[i+1] == 0x04) && (packet->payload[i+2] == 0x03)) {\n      /* Common Name */\n      int rc = extractRDNSequence(packet, i, buffer, sizeof(buffer), rdnSeqBuf, &rdn_len, sizeof(rdnSeqBuf), \"CN\");\n      if(rc == -1) break;\n\n#ifdef DEBUG_TLS\n      printf(\"[TLS] %s() [%s][%s: %s]\\n\", __FUNCTION__, (num_found == 0) ? \"Subject\" : \"Issuer\", \"Common Name\", buffer);\n#endif\n    } else if((packet->payload[i] == 0x55) && (packet->payload[i+1] == 0x04) && (packet->payload[i+2] == 0x06)) {\n      /* Country */\n      int rc = extractRDNSequence(packet, i, buffer, sizeof(buffer), rdnSeqBuf, &rdn_len, sizeof(rdnSeqBuf), \"C\");\n      if(rc == -1) break;\n\n#ifdef DEBUG_TLS\n      printf(\"[TLS] %s() [%s][%s: %s]\\n\", __FUNCTION__, (num_found == 0) ? \"Subject\" : \"Issuer\", \"Country\", buffer);\n#endif\n    } else if((packet->payload[i] == 0x55) && (packet->payload[i+1] == 0x04) && (packet->payload[i+2] == 0x07)) {\n      /* Locality */\n      int rc = extractRDNSequence(packet, i, buffer, sizeof(buffer), rdnSeqBuf, &rdn_len, sizeof(rdnSeqBuf), \"L\");\n      if(rc == -1) break;\n\n#ifdef DEBUG_TLS\n      printf(\"[TLS] %s() [%s][%s: %s]\\n\", __FUNCTION__, (num_found == 0) ? \"Subject\" : \"Issuer\", \"Locality\", buffer);\n#endif\n    } else if((packet->payload[i] == 0x55) && (packet->payload[i+1] == 0x04) && (packet->payload[i+2] == 0x08)) {\n      /* State or Province */\n      int rc = extractRDNSequence(packet, i, buffer, sizeof(buffer), rdnSeqBuf, &rdn_len, sizeof(rdnSeqBuf), \"ST\");\n      if(rc == -1) break;\n\n#ifdef DEBUG_TLS\n      printf(\"[TLS] %s() [%s][%s: %s]\\n\", __FUNCTION__, (num_found == 0) ? \"Subject\" : \"Issuer\", \"State or Province\", buffer);\n#endif\n    } else if((packet->payload[i] == 0x55) && (packet->payload[i+1] == 0x04) && (packet->payload[i+2] == 0x0a)) {\n      /* Organization Name */\n      int rc = extractRDNSequence(packet, i, buffer, sizeof(buffer), rdnSeqBuf, &rdn_len, sizeof(rdnSeqBuf), \"O\");\n      if(rc == -1) break;\n\n#ifdef DEBUG_TLS\n      printf(\"[TLS] %s() [%s][%s: %s]\\n\", __FUNCTION__, (num_found == 0) ? \"Subject\" : \"Issuer\", \"Organization Name\", buffer);\n#endif\n\n    } else if((packet->payload[i] == 0x55) && (packet->payload[i+1] == 0x04) && (packet->payload[i+2] == 0x0b)) {\n      /* Organization Unit */\n      int rc = extractRDNSequence(packet, i, buffer, sizeof(buffer), rdnSeqBuf, &rdn_len, sizeof(rdnSeqBuf), \"OU\");\n      if(rc == -1) break;\n\n#ifdef DEBUG_TLS\n      printf(\"[TLS] %s() [%s][%s: %s]\\n\", __FUNCTION__, (num_found == 0) ? \"Subject\" : \"Issuer\", \"Organization Unit\", buffer);\n#endif\n    } else if((packet->payload[i] == 0x30) && (packet->payload[i+1] == 0x1e) && (packet->payload[i+2] == 0x17)) {\n      /* Certificate Validity */\n      u_int8_t len = packet->payload[i+3];\n      u_int offset = i+4;\n\n      if(num_found == 0) {\n\tnum_found++;\n\n#ifdef DEBUG_TLS\n\tprintf(\"[TLS] %s() IssuerDN [%s]\\n\", __FUNCTION__, rdnSeqBuf);\n#endif\n\n\tif(rdn_len && (flow->protos.tls_quic_stun.tls_quic.issuerDN == NULL))\n\t  flow->protos.tls_quic_stun.tls_quic.issuerDN = ndpi_strdup(rdnSeqBuf);\n\n\trdn_len = 0; /* Reset buffer */\n      }\n\n      if((offset+len) < packet->payload_packet_len) {\n\tchar utcDate[32];\n\n#ifdef DEBUG_TLS\n\tu_int j;\n\n\tprintf(\"[CERTIFICATE] notBefore [len: %u][\", len);\n\tfor(j=0; j<len; j++) printf(\"%c\", packet->payload[i+4+j]);\n\tprintf(\"]\\n\");\n#endif\n\n\tif(len < (sizeof(utcDate)-1)) {\n\t  struct tm utc;\n\t  utc.tm_isdst = -1; /* Not set by strptime */\n\n\t  strncpy(utcDate, (const char*)&packet->payload[i+4], len);\n\t  utcDate[len] = '\\0';\n\n\t  /* 141021000000Z */\n\t  if(strptime(utcDate, \"%y%m%d%H%M%SZ\", &utc) != NULL) {\n\t    flow->protos.tls_quic_stun.tls_quic.notBefore = timegm(&utc);\n#ifdef DEBUG_TLS\n\t    printf(\"[CERTIFICATE] notBefore %u [%s]\\n\",\n\t\t   flow->protos.tls_quic_stun.tls_quic.notBefore, utcDate);\n#endif\n\t  }\n\t}\n\n\toffset += len;\n\n\tif((offset+1) < packet->payload_packet_len) {\n\t  len = packet->payload[offset+1];\n\n\t  offset += 2;\n\n\t  if((offset+len) < packet->payload_packet_len) {\n\t    u_int32_t time_sec = flow->packet.current_time_ms / 1000;\n#ifdef DEBUG_TLS\n\t    u_int j;\n\n\t    printf(\"[CERTIFICATE] notAfter [len: %u][\", len);\n\t    for(j=0; j<len; j++) printf(\"%c\", packet->payload[offset+j]);\n\t    printf(\"]\\n\");\n#endif\n\n\t    if(len < (sizeof(utcDate)-1)) {\n\t      struct tm utc;\n\t      utc.tm_isdst = -1; /* Not set by strptime */\n\n\t      strncpy(utcDate, (const char*)&packet->payload[offset], len);\n\t      utcDate[len] = '\\0';\n\n\t      /* 141021000000Z */\n\t      if(strptime(utcDate, \"%y%m%d%H%M%SZ\", &utc) != NULL) {\n\t\tflow->protos.tls_quic_stun.tls_quic.notAfter = timegm(&utc);\n#ifdef DEBUG_TLS\n\t\tprintf(\"[CERTIFICATE] notAfter %u [%s]\\n\",\n\t\t       flow->protos.tls_quic_stun.tls_quic.notAfter, utcDate);\n#endif\n\t      }\n\t    }\n\n\n\t    if((time_sec < flow->protos.tls_quic_stun.tls_quic.notBefore)\n\t       || (time_sec > flow->protos.tls_quic_stun.tls_quic.notAfter))\n\t    ndpi_set_risk(flow, NDPI_TLS_CERTIFICATE_EXPIRED); /* Certificate expired */\n\t  }\n\t}\n      }\n    } else if((packet->payload[i] == 0x55) && (packet->payload[i+1] == 0x1d) && (packet->payload[i+2] == 0x11)) {\n      /* Organization OID: 2.5.29.17 (subjectAltName) */\n      u_int8_t matched_name = 0;\n\n#ifdef DEBUG_TLS\n      printf(\"******* [TLS] Found subjectAltName\\n\");\n#endif\n\n      i += 3 /* skip the initial patten 55 1D 11 */;\n      i++; /* skip the first type, 0x04 == BIT STRING, and jump to it's length */\n      if(i < packet->payload_packet_len) {\n\ti += (packet->payload[i] & 0x80) ? (packet->payload[i] & 0x7F) : 0; /* skip BIT STRING length */\n\tif(i < packet->payload_packet_len) {\n\t  i += 2; /* skip the second type, 0x30 == SEQUENCE, and jump to it's length */\n\t  if(i < packet->payload_packet_len) {\n\t    i += (packet->payload[i] & 0x80) ? (packet->payload[i] & 0x7F) : 0; /* skip SEQUENCE length */\n\t    i++;\n\n\t    while(i < packet->payload_packet_len) {\n\t      if(packet->payload[i] == 0x82) {\n\t\tif((i < (packet->payload_packet_len - 1))\n\t\t   && ((i + packet->payload[i + 1] + 2) < packet->payload_packet_len)) {\n\t\t  u_int8_t len = packet->payload[i + 1];\n\t\t  char dNSName[256];\n\n\t\t  i += 2;\n\n\t\t  /* The check \"len > sizeof(dNSName) - 1\" will be always false. If we add it,\n\t\t     the compiler is smart enough to detect it and throws a warning */\n\t\t  if((len == 0 /* Looks something went wrong */)\n\t\t     || ((i+len) >  packet->payload_packet_len))\n\t\t    break;\n\n\t\t  strncpy(dNSName, (const char*)&packet->payload[i], len);\n\t\t  dNSName[len] = '\\0';\n\n\t\t  cleanupServerName(dNSName, len);\n\n#if DEBUG_TLS\n\t\t  printf(\"[TLS] dNSName %s [%s][len: %u][leftover: %d]\\n\", dNSName,\n\t\t\t flow->protos.tls_quic_stun.tls_quic.client_requested_server_name, len,\n\t\t\t packet->payload_packet_len-i-len);\n#endif\n\t\t  if(matched_name == 0) {\n\t\t    if(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name[0] == '\\0')\n\t\t      matched_name = 1;\t/* No SNI */\n\t\t    else if (dNSName[0] == '*')\n\t\t    {\n\t\t      char * label = strstr(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name, &dNSName[1]);\n\n\t\t      if (label != NULL)\n\t\t      {\n\t\t        char * first_dot = strchr(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name, '.');\n\n\t\t        if (first_dot == NULL || first_dot >= label)\n\t\t        {\n\t\t          matched_name = 1;\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t    else if(strcmp(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name, dNSName) == 0)\n\t\t      matched_name = 1;\n\t\t  }\n\n\t\t  if(flow->protos.tls_quic_stun.tls_quic.server_names == NULL)\n\t\t    flow->protos.tls_quic_stun.tls_quic.server_names = ndpi_strdup(dNSName),\n\t\t      flow->protos.tls_quic_stun.tls_quic.server_names_len = strlen(dNSName);\n\t\t  else {\n\t\t    u_int16_t dNSName_len = strlen(dNSName);\n\t\t    u_int16_t newstr_len = flow->protos.tls_quic_stun.tls_quic.server_names_len + dNSName_len + 1;\n\t\t    char *newstr = (char*)ndpi_realloc(flow->protos.tls_quic_stun.tls_quic.server_names,\n\t\t\t\t\t\t       flow->protos.tls_quic_stun.tls_quic.server_names_len+1, newstr_len+1);\n\n\t\t    if(newstr) {\n\t\t      flow->protos.tls_quic_stun.tls_quic.server_names = newstr;\n\t\t      flow->protos.tls_quic_stun.tls_quic.server_names[flow->protos.tls_quic_stun.tls_quic.server_names_len] = ',';\n\t\t      strncpy(&flow->protos.tls_quic_stun.tls_quic.server_names[flow->protos.tls_quic_stun.tls_quic.server_names_len+1],\n\t\t\t      dNSName, dNSName_len+1);\n\t\t      flow->protos.tls_quic_stun.tls_quic.server_names[newstr_len] = '\\0';\n\t\t      flow->protos.tls_quic_stun.tls_quic.server_names_len = newstr_len;\n\t\t    }\n\t\t  }\n\n\t\t  if(!flow->l4.tcp.tls.subprotocol_detected)\n\t\t    if(ndpi_match_hostname_protocol(ndpi_struct, flow, NDPI_PROTOCOL_TLS, dNSName, len))\n\t\t      flow->l4.tcp.tls.subprotocol_detected = 1;\n\n\t\t  i += len;\n\t\t} else {\n#if DEBUG_TLS\n\t\t  printf(\"[TLS] Leftover %u bytes\", packet->payload_packet_len - i);\n#endif\n\t\t  break;\n\t\t}\n\t      } else {\n\t\tbreak;\n\t      }\n\t    } /* while */\n\n\t    if(!matched_name)\n\t      ndpi_set_risk(flow, NDPI_TLS_CERTIFICATE_MISMATCH); /* Certificate mismatch */\n\t  }\n\t}\n      }\n    }\n  }\n\n  if(rdn_len && (flow->protos.tls_quic_stun.tls_quic.subjectDN == NULL)) {\n    flow->protos.tls_quic_stun.tls_quic.subjectDN = ndpi_strdup(rdnSeqBuf);\n\n    if(flow->detected_protocol_stack[1] == NDPI_PROTOCOL_UNKNOWN) {\n      /* No idea what is happening behind the scenes: let's check the certificate */\n      u_int32_t proto_id;\n      int rc = ndpi_match_string_value(ndpi_struct->tls_cert_subject_automa.ac_automa,\n\t\t\t\t       rdnSeqBuf, strlen(rdnSeqBuf),&proto_id);\n\n      if(rc == 0) {\n\t/* Match found */\n\tndpi_protocol ret = { NDPI_PROTOCOL_TLS, proto_id, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED};\n\n\tflow->detected_protocol_stack[0] = proto_id,\n\t  flow->detected_protocol_stack[1] = NDPI_PROTOCOL_TLS;\n\n\tflow->category = ndpi_get_proto_category(ndpi_struct, ret);\n\tndpi_check_subprotocol_risk(flow, proto_id);\n\n\tif(ndpi_struct->tls_cert_cache == NULL)\n\t  ndpi_struct->tls_cert_cache = ndpi_lru_cache_init(1024);\n\n\tif(ndpi_struct->tls_cert_cache && flow->packet.iph) {\n\t  u_int32_t key = flow->packet.iph->daddr + flow->packet.tcp->dest;\n\n\t  ndpi_lru_add_to_cache(ndpi_struct->tls_cert_cache, key, proto_id);\n\t}\n      }\n    }\n  }\n\n  if(flow->protos.tls_quic_stun.tls_quic.subjectDN && flow->protos.tls_quic_stun.tls_quic.issuerDN\n     && (!strcmp(flow->protos.tls_quic_stun.tls_quic.subjectDN, flow->protos.tls_quic_stun.tls_quic.issuerDN)))\n    ndpi_set_risk(flow, NDPI_TLS_SELFSIGNED_CERTIFICATE);\n\n#if DEBUG_TLS\n  printf(\"[TLS] %s() SubjectDN [%s]\\n\", __FUNCTION__, rdnSeqBuf);\n#endif\n}\n\n/* **************************************** */\n\n/* See https://blog.catchpoint.com/2017/05/12/dissecting-tls-using-wireshark/ */\nint processCertificate(struct ndpi_detection_module_struct *ndpi_struct,\n\t\t       struct ndpi_flow_struct *flow) {\n  struct ndpi_packet_struct *packet = &flow->packet;\n  int is_dtls = packet->udp ? 1 : 0;\n  u_int32_t certificates_length, length = (packet->payload[1] << 16) + (packet->payload[2] << 8) + packet->payload[3];\n  u_int32_t certificates_offset = 7 + (is_dtls ? 8 : 0);\n  u_int8_t num_certificates_found = 0;\n  SHA1_CTX srv_cert_fingerprint_ctx ;\n\n#ifdef DEBUG_TLS\n  printf(\"[TLS] %s() [payload_packet_len=%u][direction: %u][%02X %02X %02X %02X %02X %02X...]\\n\",\n\t __FUNCTION__, packet->payload_packet_len,\n\t packet->packet_direction,\n\t packet->payload[0], packet->payload[1], packet->payload[2],\n\t packet->payload[3], packet->payload[4], packet->payload[5]);\n#endif\n\n  if((packet->payload_packet_len != (length + 4 + (is_dtls ? 8 : 0))) || (packet->payload[1] != 0x0)) {\n    ndpi_set_risk(flow, NDPI_MALFORMED_PACKET);\n    return(-1); /* Invalid length */\n  }\n\n  certificates_length = (packet->payload[certificates_offset - 3] << 16) +\n                        (packet->payload[certificates_offset - 2] << 8) +\n                        packet->payload[certificates_offset - 1];\n\n  if((packet->payload[certificates_offset - 3] != 0x0) || ((certificates_length+3) != length)) {\n    ndpi_set_risk(flow, NDPI_MALFORMED_PACKET);\n    return(-2); /* Invalid length */\n  }\n\n  /* Now let's process each individual certificates */\n  while(certificates_offset < certificates_length) {\n    u_int32_t certificate_len = (packet->payload[certificates_offset] << 16) + (packet->payload[certificates_offset+1] << 8) + packet->payload[certificates_offset+2];\n\n    /* Invalid lenght */\n    if((certificate_len == 0)\n       || (packet->payload[certificates_offset] != 0x0)\n       || ((certificates_offset+certificate_len) > (4+certificates_length+(is_dtls ? 8 : 0)))) {\n#ifdef DEBUG_TLS\n      printf(\"[TLS] Invalid length [certificate_len: %u][certificates_offset: %u][%u vs %u]\\n\",\n\t     certificate_len, certificates_offset,\n\t     (certificates_offset+certificate_len),\n\t     certificates_length);\n#endif\n      break;\n    }\n\n    certificates_offset += 3;\n#ifdef DEBUG_TLS\n    printf(\"[TLS] Processing %u bytes certificate [%02X %02X %02X]\\n\",\n\t   certificate_len,\n\t   packet->payload[certificates_offset],\n\t   packet->payload[certificates_offset+1],\n\t   packet->payload[certificates_offset+2]);\n#endif\n\n    if(num_certificates_found++ == 0) /* Dissect only the first certificate that is the one we care */ {\n      /* For SHA-1 we take into account only the first certificate and not all of them */\n\n      SHA1Init(&srv_cert_fingerprint_ctx);\n\n#ifdef DEBUG_CERTIFICATE_HASH\n      {\n\tint i;\n\n\tfor(i=0;i<certificate_len;i++)\n\t  printf(\"%02X \", packet->payload[certificates_offset+i]);\n\n\tprintf(\"\\n\");\n      }\n#endif\n\n      SHA1Update(&srv_cert_fingerprint_ctx,\n\t\t &packet->payload[certificates_offset],\n\t\t certificate_len);\n\n      SHA1Final(flow->protos.tls_quic_stun.tls_quic.sha1_certificate_fingerprint, &srv_cert_fingerprint_ctx);\n\n      flow->l4.tcp.tls.fingerprint_set = 1;\n\n      uint8_t * sha1 = flow->protos.tls_quic_stun.tls_quic.sha1_certificate_fingerprint;\n      const size_t sha1_siz = sizeof(flow->protos.tls_quic_stun.tls_quic.sha1_certificate_fingerprint);\n      char sha1_str[20 /* sha1_siz */ * 2 + 1];\n      static const char hexalnum[] = \"0123456789ABCDEF\";\n      for (size_t i = 0; i < sha1_siz; ++i) {\n        u_int8_t lower = (sha1[i] & 0x0F);\n        u_int8_t upper = (sha1[i] & 0xF0) >> 4;\n        sha1_str[i*2] = hexalnum[upper];\n        sha1_str[i*2 + 1] = hexalnum[lower];\n      }\n      sha1_str[sha1_siz * 2] = '\\0';\n\n#ifdef DEBUG_TLS\n      printf(\"[TLS] SHA-1: %s\\n\", sha1_str);\n#endif\n\n      if (ndpi_struct->malicious_sha1_automa.ac_automa != NULL) {\n        u_int16_t rc1 = ndpi_match_string(ndpi_struct->malicious_sha1_automa.ac_automa, sha1_str);\n\n        if(rc1 > 0)\n          ndpi_set_risk(flow, NDPI_MALICIOUS_SHA1_CERTIFICATE);\n      }\n\n      processCertificateElements(ndpi_struct, flow, certificates_offset, certificate_len);\n    }\n\n    certificates_offset += certificate_len;\n  }\n\n  if((ndpi_struct->num_tls_blocks_to_follow != 0)\n     && (flow->l4.tcp.tls.num_tls_blocks >= ndpi_struct->num_tls_blocks_to_follow)) {\n#ifdef DEBUG_TLS_BLOCKS\n    printf(\"*** [TLS Block] Enough blocks dissected\\n\");\n#endif\n\n    flow->extra_packets_func = NULL; /* We're good now */\n  }\n\n  return(1);\n}\n\n/* **************************************** */\n\nstatic int processTLSBlock(struct ndpi_detection_module_struct *ndpi_struct,\n\t\t\t   struct ndpi_flow_struct *flow) {\n  struct ndpi_packet_struct *packet = &flow->packet;\n  int ret;\n\n  switch(packet->payload[0] /* block type */) {\n  case 0x01: /* Client Hello */\n  case 0x02: /* Server Hello */\n    processClientServerHello(ndpi_struct, flow, 0);\n    flow->l4.tcp.tls.hello_processed = 1;\n    ndpi_int_tls_add_connection(ndpi_struct, flow, NDPI_PROTOCOL_TLS);\n\n#ifdef DEBUG_TLS\n    printf(\"*** TLS [version: %02X][%s Hello]\\n\",\n\t   flow->protos.tls_quic_stun.tls_quic.ssl_version,\n\t   (packet->payload[0] == 0x01) ? \"Client\" : \"Server\");\n#endif\n\n    if((flow->protos.tls_quic_stun.tls_quic.ssl_version >= 0x0304 /* TLS 1.3 */)\n       && (packet->payload[0] == 0x02 /* Server Hello */)) {\n      flow->l4.tcp.tls.certificate_processed = 1; /* No Certificate with TLS 1.3+ */\n    }\n\n    checkTLSSubprotocol(ndpi_struct, flow);\n    break;\n\n  case 0x0b: /* Certificate */\n    /* Important: populate the tls union fields only after\n     * ndpi_int_tls_add_connection has been called */\n    if(flow->l4.tcp.tls.hello_processed) {\n      ret = processCertificate(ndpi_struct, flow);\n      if (ret != 1) {\n#ifdef DEBUG_TLS\n        printf(\"[TLS] Error processing certificate: %d\\n\", ret);\n#endif\n      }\n      flow->l4.tcp.tls.certificate_processed = 1;\n    }\n    break;\n\n  default:\n    return(-1);\n  }\n\n  return(0);\n}\n\n/* **************************************** */\n\nstatic void ndpi_looks_like_tls(struct ndpi_detection_module_struct *ndpi_struct,\n\t\t\t\tstruct ndpi_flow_struct *flow) {\n  // ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_TLS, NDPI_PROTOCOL_UNKNOWN);\n\n  if(flow->guessed_protocol_id == NDPI_PROTOCOL_UNKNOWN)\n    flow->guessed_protocol_id = NDPI_PROTOCOL_TLS;\n}\n\n/* **************************************** */\n\nstatic int ndpi_search_tls_tcp(struct ndpi_detection_module_struct *ndpi_struct,\n\t\t\t       struct ndpi_flow_struct *flow) {\n  struct ndpi_packet_struct *packet = &flow->packet;\n  u_int8_t something_went_wrong = 0;\n\n#ifdef DEBUG_TLS_MEMORY\n  printf(\"[TLS Mem] ndpi_search_tls_tcp() Processing new packet [payload_packet_len: %u]\\n\",\n\t packet->payload_packet_len);\n#endif\n\n  if(packet->payload_packet_len == 0)\n    return(1); /* Keep working */\n\n  ndpi_search_tls_tcp_memory(ndpi_struct, flow);\n\n  while(!something_went_wrong) {\n    u_int16_t len, p_len;\n    const u_int8_t *p;\n    u_int8_t content_type;\n\n    if(flow->l4.tcp.tls.message.buffer_used < 5)\n      return(1); /* Keep working */\n\n    len = (flow->l4.tcp.tls.message.buffer[3] << 8) + flow->l4.tcp.tls.message.buffer[4] + 5;\n\n    if(len > flow->l4.tcp.tls.message.buffer_used) {\n#ifdef DEBUG_TLS_MEMORY\n      printf(\"[TLS Mem] Not enough TLS data [%u < %u][%02X %02X %02X %02X %02X]\\n\",\n\t     len, flow->l4.tcp.tls.message.buffer_used,\n\t     flow->l4.tcp.tls.message.buffer[0],\n\t     flow->l4.tcp.tls.message.buffer[1],\n\t     flow->l4.tcp.tls.message.buffer[2],\n\t     flow->l4.tcp.tls.message.buffer[3],\n\t     flow->l4.tcp.tls.message.buffer[4]);\n#endif\n      break;\n    }\n\n    if(len == 0) {\n      something_went_wrong = 1;\n      break;\n    }\n\n#ifdef DEBUG_TLS_MEMORY\n    printf(\"[TLS Mem] Processing %u bytes message\\n\", len);\n#endif\n\n    content_type = flow->l4.tcp.tls.message.buffer[0];\n\n    /* Overwriting packet payload */\n    p = packet->payload;\n    p_len = packet->payload_packet_len; /* Backup */\n\n    if(content_type == 0x14 /* Change Cipher Spec */) {\n      if(ndpi_struct->skip_tls_blocks_until_change_cipher) {\n\t/*\n\t  Ignore Application Data up until change cipher\n\t  so in this case we reset the number of observed\n\t  TLS blocks\n\t*/\n\tflow->l4.tcp.tls.num_tls_blocks = 0;\n      }\n    }\n\n    if((len > 9)\n       && (content_type != 0x17 /* Application Data */)\n       && (!flow->l4.tcp.tls.certificate_processed)) {\n      /* Split the element in blocks */\n      u_int16_t processed = 5;\n\n      while((processed+4) <= len) {\n\tconst u_int8_t *block = (const u_int8_t *)&flow->l4.tcp.tls.message.buffer[processed];\n\tu_int32_t block_len   = (block[1] << 16) + (block[2] << 8) + block[3];\n\n\tif(/* (block_len == 0) || */ /* Note blocks can have zero lenght */\n\t   (block_len > len) || ((block[1] != 0x0))) {\n\t  something_went_wrong = 1;\n\t  break;\n\t}\n\n\tpacket->payload = block;\n\tpacket->payload_packet_len = ndpi_min(block_len+4, flow->l4.tcp.tls.message.buffer_used);\n\n\tif((processed+packet->payload_packet_len) > len) {\n\t  something_went_wrong = 1;\n\t  break;\n\t}\n\n\tprocessTLSBlock(ndpi_struct, flow);\n\tndpi_looks_like_tls(ndpi_struct, flow);\n\n\tprocessed += packet->payload_packet_len;\n      }\n    } else {\n      /* Process element as a whole */\n      if(content_type == 0x17 /* Application Data */) {\n\tndpi_looks_like_tls(ndpi_struct, flow);\n\n\tif(flow->l4.tcp.tls.certificate_processed) {\n\t  if(flow->l4.tcp.tls.num_tls_blocks < ndpi_struct->num_tls_blocks_to_follow)\n\t    flow->l4.tcp.tls.tls_application_blocks_len[flow->l4.tcp.tls.num_tls_blocks++] =\n\t      (packet->packet_direction == 0) ? (len-5) : -(len-5);\n\n#ifdef DEBUG_TLS_BLOCKS\n\t  printf(\"*** [TLS Block] [len: %u][num_tls_blocks: %u/%u]\\n\",\n\t\t len-5, flow->l4.tcp.tls.num_tls_blocks, ndpi_struct->num_tls_blocks_to_follow);\n#endif\n\t}\n      }\n    }\n\n    packet->payload = p;\n    packet->payload_packet_len = p_len; /* Restore */\n    flow->l4.tcp.tls.message.buffer_used -= len;\n\n    if(flow->l4.tcp.tls.message.buffer_used > 0)\n      memmove(flow->l4.tcp.tls.message.buffer,\n\t      &flow->l4.tcp.tls.message.buffer[len],\n\t      flow->l4.tcp.tls.message.buffer_used);\n    else\n      break;\n\n#ifdef DEBUG_TLS_MEMORY\n    printf(\"[TLS Mem] Left memory buffer %u bytes\\n\", flow->l4.tcp.tls.message.buffer_used);\n#endif\n  }\n\n  if(something_went_wrong\n     || ((ndpi_struct->num_tls_blocks_to_follow > 0)\n\t && (flow->l4.tcp.tls.num_tls_blocks == ndpi_struct->num_tls_blocks_to_follow))\n     ) {\n#ifdef DEBUG_TLS_BLOCKS\n    printf(\"*** [TLS Block] No more blocks\\n\");\n#endif\n    flow->check_extra_packets = 0;\n    flow->extra_packets_func = NULL;\n    return(0); /* That's all */\n  } else\n    return(1);\n}\n\n/* **************************************** */\n\nstatic int ndpi_search_tls_udp(struct ndpi_detection_module_struct *ndpi_struct,\n\t\t\t       struct ndpi_flow_struct *flow) {\n  struct ndpi_packet_struct *packet = &flow->packet;\n  u_int32_t handshake_len;\n  u_int16_t p_len, processed;\n  const u_int8_t *p;\n  u_int8_t no_dtls = 0, change_cipher_found = 0;\n\n#ifdef DEBUG_TLS\n  printf(\"[TLS] %s()\\n\", __FUNCTION__);\n#endif\n\n  /* Overwriting packet payload */\n  p = packet->payload, p_len = packet->payload_packet_len; /* Backup */\n\n  /* Split the element in blocks */\n  processed = 0;\n  while(processed + 13 < p_len) {\n    u_int32_t block_len;\n    const u_int8_t *block = (const u_int8_t *)&p[processed];\n\n    if((block[0] != 0x16 && block[0] != 0x14) || /* Handshake, change-cipher-spec */\n       (block[1] != 0xfe) || /* We ignore old DTLS versions */\n       ((block[2] != 0xff) && (block[2] != 0xfd))) {\n#ifdef DEBUG_TLS\n      printf(\"[TLS] DTLS invalid block 0x%x or old version 0x%x-0x%x-0x%x\\n\",\n             block[0], block[1], block[2], block[3]);\n#endif\n      no_dtls = 1;\n      break;\n    }\n    block_len = ntohs(*((u_int16_t*)&block[11]));\n#ifdef DEBUG_TLS\n    printf(\"[TLS] DTLS block len: %d\\n\", block_len);\n#endif\n    if (block_len == 0 || (processed + block_len + 12 >= p_len)) {\n#ifdef DEBUG_TLS\n      printf(\"[TLS] DTLS invalid block len %d (processed %d, p_len %d)\\n\",\n             block_len, processed, p_len);\n#endif\n      no_dtls = 1;\n      break;\n    }\n    /* We process only handshake msgs */\n    if(block[0] == 0x16) {\n      if (processed + block_len + 13 > p_len) {\n#ifdef DEBUG_TLS\n        printf(\"[TLS] DTLS invalid len %d %d %d\\n\", processed, block_len, p_len);\n#endif\n        no_dtls = 1;\n        break;\n     }\n      /* TODO: handle (certificate) fragments */\n      handshake_len = (block[14] << 16) + (block[15] << 8) + block[16];\n      if((handshake_len + 12) != block_len) {\n#ifdef DEBUG_TLS\n        printf(\"[TLS] DTLS invalid handshake_len %d, %d)\\n\",\n               handshake_len, block_len);\n#endif\n        no_dtls = 1;\n        break;\n      }\n      packet->payload = &block[13];\n      packet->payload_packet_len = block_len;\n      processTLSBlock(ndpi_struct, flow);\n    } else {\n      /* Change-cipher-spec: any subsequent block might be encrypted */\n#ifdef DEBUG_TLS\n      printf(\"[TLS] Change-cipher-spec\\n\");\n#endif\n      change_cipher_found = 1;\n      processed += block_len + 13;\n      break;\n    }\n\n    processed += block_len + 13;\n  }\n  if(processed != p_len) {\n#ifdef DEBUG_TLS\n    printf(\"[TLS] DTLS invalid processed len %d/%d (%d)\\n\", processed, p_len, change_cipher_found);\n#endif\n    if(!change_cipher_found)\n      no_dtls = 1;\n  }\n\n  packet->payload = p;\n  packet->payload_packet_len = p_len; /* Restore */\n\n  if(no_dtls || change_cipher_found) {\n    NDPI_EXCLUDE_PROTO(ndpi_struct, flow);\n    return(0); /* That's all */\n  } else {\n    return(1); /* Keep working */\n  }\n}\n\n/* **************************************** */\n\nstatic void tlsInitExtraPacketProcessing(struct ndpi_detection_module_struct *ndpi_struct,\n\t\t\t\t\t struct ndpi_flow_struct *flow) {\n  flow->check_extra_packets = 1;\n\n  /* At most 12 packets should almost always be enough to find the server certificate if it's there */\n  flow->max_extra_packets_to_check = 12 + (ndpi_struct->num_tls_blocks_to_follow*4);\n  flow->extra_packets_func = (flow->packet.udp != NULL) ? ndpi_search_tls_udp : ndpi_search_tls_tcp;\n}\n\n/* **************************************** */\n\nstatic void tlsCheckUncommonALPN(struct ndpi_flow_struct *flow)\n{\n  /* see: https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml */\n  static char const * const common_alpns[] = {\n    \"http/0.9\", \"http/1.0\", \"http/1.1\",\n    \"spdy/1\", \"spdy/2\", \"spdy/3\", \"spdy/3.1\",\n    \"stun.turn\", \"stun.nat-discovery\",\n    \"h2\", \"h2c\", \"h2-16\", \"h2-15\", \"h2-14\",\n    \"webrtc\", \"c-webrtc\",\n    \"ftp\", \"imap\", \"pop3\", \"managesieve\", \"coap\",\n    \"xmpp-client\", \"xmpp-server\",\n    \"acme-tls/1\",\n    \"mqtt\", \"dot\", \"ntske/1\", \"sunrpc\",\n    \"h3\",\n    \"smb\",\n    \"irc\",\n\n    /* QUIC ALPNs */\n    \"h3-T051\", \"h3-T050\",\n    \"h3-32\", \"h3-30\", \"h3-29\", \"h3-28\", \"h3-27\", \"h3-24\", \"h3-22\",\n    \"hq-30\", \"hq-29\", \"hq-28\", \"hq-27\",\n    \"h3-fb-05\", \"h1q-fb\",\n    \"doq-i00\"\n  };\n\n  /*\n   * If the ALPN list increases in size, iterating over all items for every incoming ALPN may\n   * have a performance impact. A hash map could solve this issue.\n   */\n\n  char * alpn_start = flow->protos.tls_quic_stun.tls_quic.alpn;\n  char * comma_or_nul = alpn_start;\n  do {\n    comma_or_nul = strchr(comma_or_nul, ',');\n    if (comma_or_nul == NULL)\n    {\n      comma_or_nul = alpn_start + strlen(alpn_start);\n    }\n\n    int alpn_found = 0;\n    int alpn_len = comma_or_nul - alpn_start;\n    char const * const alpn = alpn_start;\n    for (size_t i = 0; i < sizeof(common_alpns)/sizeof(common_alpns[0]); ++i)\n    {\n      if (strlen(common_alpns[i]) == alpn_len &&\n          strncmp(alpn, common_alpns[i], alpn_len) == 0)\n      {\n        alpn_found = 1;\n        break;\n      }\n    }\n\n    if (alpn_found == 0)\n    {\n#ifdef DEBUG_TLS\n      printf(\"TLS uncommon ALPN found: %.*s\\n\", alpn_len, alpn);\n#endif\n      ndpi_set_risk(flow, NDPI_TLS_UNCOMMON_ALPN);\n      break;\n    }\n\n    alpn_start = comma_or_nul + 1;\n  } while (*(comma_or_nul++) != '\\0');\n}\n\n/* **************************************** */\n\nstatic void ndpi_int_tls_add_connection(struct ndpi_detection_module_struct *ndpi_struct,\n\t\t\t\t\tstruct ndpi_flow_struct *flow, u_int32_t protocol) {\n#if DEBUG_TLS\n  printf(\"[TLS] %s()\\n\", __FUNCTION__);\n#endif\n\n  if((flow->packet.udp != NULL) && (protocol == NDPI_PROTOCOL_TLS))\n    protocol = NDPI_PROTOCOL_DTLS;\n\n  if((flow->detected_protocol_stack[0] == protocol)\n     || (flow->detected_protocol_stack[1] == protocol)) {\n    if(!flow->check_extra_packets)\n      tlsInitExtraPacketProcessing(ndpi_struct, flow);\n    return;\n  }\n\n  if(protocol != NDPI_PROTOCOL_TLS)\n    ;\n  else\n    protocol = ndpi_tls_refine_master_protocol(ndpi_struct, flow, protocol);\n\n  ndpi_set_detected_protocol(ndpi_struct, flow, protocol, protocol);\n\n  tlsInitExtraPacketProcessing(ndpi_struct, flow);\n}\n\n/* **************************************** */\n\nint processClientServerHello(struct ndpi_detection_module_struct *ndpi_struct,\n\t\t\t     struct ndpi_flow_struct *flow, uint32_t quic_version) {\n  struct ndpi_packet_struct *packet = &flow->packet;\n  union ja3_info ja3;\n  u_int8_t invalid_ja3 = 0;\n  u_int16_t tls_version, ja3_str_len;\n  char ja3_str[JA3_STR_LEN];\n  ndpi_MD5_CTX ctx;\n  u_char md5_hash[16];\n  int i;\n  u_int16_t total_len;\n  u_int8_t handshake_type;\n  char buffer[64] = { '\\0' };\n  int is_quic = (quic_version != 0);\n  int is_dtls = packet->udp && (!is_quic);\n\n#ifdef DEBUG_TLS\n  printf(\"TLS %s() called\\n\", __FUNCTION__);\n#endif\n\n  memset(&ja3, 0, sizeof(ja3));\n\n  handshake_type = packet->payload[0];\n  total_len = (packet->payload[1] << 16) +  (packet->payload[2] << 8) + packet->payload[3];\n\n  if((total_len > packet->payload_packet_len) || (packet->payload[1] != 0x0))\n    return(0); /* Not found */\n\n  total_len = packet->payload_packet_len;\n\n  /* At least \"magic\" 3 bytes, null for string end, otherwise no need to waste cpu cycles */\n  if(total_len > 4) {\n    u_int16_t base_offset    = (!is_dtls) ? 38 : 46;\n    u_int16_t version_offset = (!is_dtls) ? 4 : 12;\n    u_int16_t offset = (!is_dtls) ? 38 : 46, extension_len, j;\n    u_int8_t  session_id_len =  0;\n\n    if((base_offset >= total_len) ||\n       (version_offset + 1) >= total_len)\n      return 0; /* Not found */\n\n    session_id_len = packet->payload[base_offset];\n\n#ifdef DEBUG_TLS\n    printf(\"TLS [len: %u][handshake_type: %02X]\\n\", packet->payload_packet_len, handshake_type);\n#endif\n\n    tls_version = ntohs(*((u_int16_t*)&packet->payload[version_offset]));\n\n    if(handshake_type == 0x02 /* Server Hello */) {\n      int i, rc;\n\n      ja3.server.tls_handshake_version = tls_version;\n\n#ifdef DEBUG_TLS\n      printf(\"TLS Server Hello [version: 0x%04X]\\n\", tls_version);\n#endif\n\n      /*\n\tThe server hello decides about the TLS version of this flow\n\thttps://networkengineering.stackexchange.com/questions/55752/why-does-wireshark-show-version-tls-1-2-here-instead-of-tls-1-3\n      */\n      if(packet->udp)\n\toffset += session_id_len + 1;\n      else {\n\tif(tls_version < 0x7F15 /* TLS 1.3 lacks of session id */)\n\t  offset += session_id_len+1;\n      }\n\n      if((offset+3) > packet->payload_packet_len)\n\treturn(0); /* Not found */\n\n      ja3.server.num_cipher = 1, ja3.server.cipher[0] = ntohs(*((u_int16_t*)&packet->payload[offset]));\n      if((flow->protos.tls_quic_stun.tls_quic.server_unsafe_cipher = ndpi_is_safe_ssl_cipher(ja3.server.cipher[0])) == 1)\n\tndpi_set_risk(flow, NDPI_TLS_WEAK_CIPHER);\n\n      flow->protos.tls_quic_stun.tls_quic.server_cipher = ja3.server.cipher[0];\n\n#ifdef DEBUG_TLS\n      printf(\"TLS [server][session_id_len: %u][cipher: %04X]\\n\", session_id_len, ja3.server.cipher[0]);\n#endif\n\n      offset += 2 + 1;\n\n      if((offset + 1) < packet->payload_packet_len) /* +1 because we are goint to read 2 bytes */\n\textension_len = ntohs(*((u_int16_t*)&packet->payload[offset]));\n      else\n\textension_len = 0;\n\n#ifdef DEBUG_TLS\n      printf(\"TLS [server][extension_len: %u]\\n\", extension_len);\n#endif\n      offset += 2;\n\n      for(i=0; i<extension_len; ) {\n\tu_int16_t extension_id, extension_len;\n\n\tif((offset+4) > packet->payload_packet_len) break;\n\n\textension_id  = ntohs(*((u_int16_t*)&packet->payload[offset]));\n\textension_len = ntohs(*((u_int16_t*)&packet->payload[offset+2]));\n\n\tif(ja3.server.num_tls_extension < MAX_NUM_JA3)\n\t  ja3.server.tls_extension[ja3.server.num_tls_extension++] = extension_id;\n\n#ifdef DEBUG_TLS\n\tprintf(\"TLS [server][extension_id: %u/0x%04X][len: %u]\\n\",\n\t       extension_id, extension_id, extension_len);\n#endif\n\n\tif(extension_id == 43 /* supported versions */) {\n\t  if(extension_len >= 2) {\n\t    u_int16_t tls_version = ntohs(*((u_int16_t*)&packet->payload[offset+4]));\n\n#ifdef DEBUG_TLS\n\t    printf(\"TLS [server] [TLS version: 0x%04X]\\n\", tls_version);\n#endif\n\n\t    flow->protos.tls_quic_stun.tls_quic.ssl_version = ja3.server.tls_supported_version = tls_version;\n\t  }\n\t} else if(extension_id == 16 /* application_layer_protocol_negotiation (ALPN) */) {\n\t  u_int16_t s_offset = offset+4;\n\t  u_int16_t tot_alpn_len = ntohs(*((u_int16_t*)&packet->payload[s_offset]));\n\t  char alpn_str[256];\n\t  u_int8_t alpn_str_len = 0, i;\n\n#ifdef DEBUG_TLS\n\t  printf(\"Server TLS [ALPN: block_len=%u/len=%u]\\n\", extension_len, tot_alpn_len);\n#endif\n\t  s_offset += 2;\n\t  tot_alpn_len += s_offset;\n\n\t  while(s_offset < tot_alpn_len && s_offset < total_len) {\n\t    u_int8_t alpn_i, alpn_len = packet->payload[s_offset++];\n\n\t    if((s_offset + alpn_len) <= tot_alpn_len) {\n#ifdef DEBUG_TLS\n\t      printf(\"Server TLS [ALPN: %u]\\n\", alpn_len);\n#endif\n\n\t      if((alpn_str_len+alpn_len+1) < (sizeof(alpn_str)-1)) {\n\t        if(alpn_str_len > 0) {\n\t          alpn_str[alpn_str_len] = ',';\n\t          alpn_str_len++;\n\t        }\n\n\t        for(alpn_i=0; alpn_i<alpn_len; alpn_i++)\n\t        {\n\t          alpn_str[alpn_str_len+alpn_i] = packet->payload[s_offset+alpn_i];\n\t        }\n\n\t        s_offset += alpn_len, alpn_str_len += alpn_len;;\n\t      } else {\n\t        ndpi_set_risk(flow, NDPI_TLS_UNCOMMON_ALPN);\n\t        break;\n\t      }\n\t    } else {\n\t      ndpi_set_risk(flow, NDPI_TLS_UNCOMMON_ALPN);\n\t      break;\n\t    }\n\t  } /* while */\n\n\t  alpn_str[alpn_str_len] = '\\0';\n\n#ifdef DEBUG_TLS\n\t  printf(\"Server TLS [ALPN: %s][len: %u]\\n\", alpn_str, alpn_str_len);\n#endif\n\t  if(flow->protos.tls_quic_stun.tls_quic.alpn == NULL)\n\t    flow->protos.tls_quic_stun.tls_quic.alpn = ndpi_strdup(alpn_str);\n\n\t  if(flow->protos.tls_quic_stun.tls_quic.alpn != NULL)\n\t    tlsCheckUncommonALPN(flow);\n\n\t  snprintf(ja3.server.alpn, sizeof(ja3.server.alpn), \"%s\", alpn_str);\n\n\t  /* Replace , with - as in JA3 */\n\t  for(i=0; ja3.server.alpn[i] != '\\0'; i++)\n\t    if(ja3.server.alpn[i] == ',') ja3.server.alpn[i] = '-';\n\t} else if(extension_id == 11 /* ec_point_formats groups */) {\n\t  u_int16_t s_offset = offset+4 + 1;\n\n#ifdef DEBUG_TLS\n\t  printf(\"Server TLS [EllipticCurveFormat: len=%u]\\n\", extension_len);\n#endif\n\t  if((s_offset+extension_len-1) <= total_len) {\n\t    for(i=0; i<extension_len-1; i++) {\n\t      u_int8_t s_group = packet->payload[s_offset+i];\n\n#ifdef DEBUG_TLS\n\t      printf(\"Server TLS [EllipticCurveFormat: %u]\\n\", s_group);\n#endif\n\n\t      if(ja3.server.num_elliptic_curve_point_format < MAX_NUM_JA3)\n\t\tja3.server.elliptic_curve_point_format[ja3.server.num_elliptic_curve_point_format++] = s_group;\n\t      else {\n\t\tinvalid_ja3 = 1;\n#ifdef DEBUG_TLS\n\t\tprintf(\"Server TLS Invalid num elliptic %u\\n\", ja3.server.num_elliptic_curve_point_format);\n#endif\n\t      }\n\t    }\n\t  } else {\n\t    invalid_ja3 = 1;\n#ifdef DEBUG_TLS\n\t    printf(\"Server TLS Invalid len %u vs %u\\n\", s_offset+extension_len, total_len);\n#endif\n\t  }\n\t}\n\n\ti += 4 + extension_len, offset += 4 + extension_len;\n      } /* for */\n\n      ja3_str_len = snprintf(ja3_str, sizeof(ja3_str), \"%u,\", ja3.server.tls_handshake_version);\n\n      for(i=0; i<ja3.server.num_cipher; i++) {\n\trc = snprintf(&ja3_str[ja3_str_len], sizeof(ja3_str)-ja3_str_len, \"%s%u\", (i > 0) ? \"-\" : \"\", ja3.server.cipher[i]);\n\n\tif(rc <= 0) break; else ja3_str_len += rc;\n      }\n\n      rc = snprintf(&ja3_str[ja3_str_len], sizeof(ja3_str)-ja3_str_len, \",\");\n      if(rc > 0 && ja3_str_len + rc < JA3_STR_LEN) ja3_str_len += rc;\n\n      /* ********** */\n\n      for(i=0; i<ja3.server.num_tls_extension; i++) {\n\tint rc = snprintf(&ja3_str[ja3_str_len], sizeof(ja3_str)-ja3_str_len, \"%s%u\", (i > 0) ? \"-\" : \"\", ja3.server.tls_extension[i]);\n\n\tif(rc <= 0) break; else ja3_str_len += rc;\n      }\n\n      if(ndpi_struct->enable_ja3_plus) {\n\tfor(i=0; i<ja3.server.num_elliptic_curve_point_format; i++) {\n\t  rc = snprintf(&ja3_str[ja3_str_len], sizeof(ja3_str)-ja3_str_len, \"%s%u\",\n\t\t\t(i > 0) ? \"-\" : \"\", ja3.server.elliptic_curve_point_format[i]);\n\t  if((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc; else break;\n\t}\n\n\tif(ja3.server.alpn[0] != '\\0') {\n\t  rc = snprintf(&ja3_str[ja3_str_len], sizeof(ja3_str)-ja3_str_len, \",%s\", ja3.server.alpn);\n\t  if((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc;\n\t}\n\n#ifdef DEBUG_TLS\n\tprintf(\"[JA3+] Server: %s \\n\", ja3_str);\n#endif\n      } else {\n#ifdef DEBUG_TLS\n\tprintf(\"[JA3] Server: %s \\n\", ja3_str);\n#endif\n      }\n\n      ndpi_MD5Init(&ctx);\n      ndpi_MD5Update(&ctx, (const unsigned char *)ja3_str, strlen(ja3_str));\n      ndpi_MD5Final(md5_hash, &ctx);\n\n      for(i=0, j=0; i<16; i++) {\n\tint rc = snprintf(&flow->protos.tls_quic_stun.tls_quic.ja3_server[j],\n\t\t\t  sizeof(flow->protos.tls_quic_stun.tls_quic.ja3_server)-j, \"%02x\", md5_hash[i]);\n\tif(rc <= 0) break; else j += rc;\n      }\n\n#ifdef DEBUG_TLS\n      printf(\"[JA3] Server: %s \\n\", flow->protos.tls_quic_stun.tls_quic.ja3_server);\n#endif\n    } else if(handshake_type == 0x01 /* Client Hello */) {\n      u_int16_t cipher_len, cipher_offset;\n      u_int8_t cookie_len = 0;\n\n      flow->protos.tls_quic_stun.tls_quic.ssl_version = ja3.client.tls_handshake_version = tls_version;\n      if(flow->protos.tls_quic_stun.tls_quic.ssl_version < 0x0302) /* TLSv1.1 */\n\tndpi_set_risk(flow, NDPI_TLS_OBSOLETE_VERSION);\n\n      if((session_id_len+base_offset+3) > packet->payload_packet_len)\n\treturn(0); /* Not found */\n\n      if(!is_dtls) {\n\tcipher_len = packet->payload[session_id_len+base_offset+2] + (packet->payload[session_id_len+base_offset+1] << 8);\n\tcipher_offset = base_offset + session_id_len + 3;\n      } else {\n\tcookie_len = packet->payload[base_offset+session_id_len+1];\n#ifdef DEBUG_TLS\n\tprintf(\"[JA3] Client: DTLS cookie len %d\\n\", cookie_len);\n#endif\n\tif((session_id_len+base_offset+cookie_len+4) > packet->payload_packet_len)\n\t  return(0); /* Not found */\n\tcipher_len = ntohs(*((u_int16_t*)&packet->payload[base_offset+session_id_len+cookie_len+2]));\n\tcipher_offset = base_offset + session_id_len + cookie_len + 4;\n      }\n\n#ifdef DEBUG_TLS\n      printf(\"Client TLS [client cipher_len: %u][tls_version: 0x%04X]\\n\", cipher_len, tls_version);\n#endif\n\n      if((cipher_offset+cipher_len) <= total_len) {\n\tu_int8_t safari_ciphers = 0, chrome_ciphers = 0;\n\n\tfor(i=0; i<cipher_len;) {\n\t  u_int16_t *id = (u_int16_t*)&packet->payload[cipher_offset+i];\n\n#ifdef DEBUG_TLS\n\t  printf(\"Client TLS [cipher suite: %u/0x%04X] [%d/%u]\\n\", ntohs(*id), ntohs(*id), i, cipher_len);\n#endif\n\t  if((*id == 0) || (packet->payload[cipher_offset+i] != packet->payload[cipher_offset+i+1])) {\n\t    u_int16_t cipher_id = ntohs(*id);\n\t    /*\n\t      Skip GREASE [https://tools.ietf.org/id/draft-ietf-tls-grease-01.html]\n\t      https://engineering.salesforce.com/tls-fingerprinting-with-ja3-and-ja3s-247362855967\n\t    */\n\n\t    if(ja3.client.num_cipher < MAX_NUM_JA3)\n\t      ja3.client.cipher[ja3.client.num_cipher++] = cipher_id;\n\t    else {\n\t      invalid_ja3 = 1;\n#ifdef DEBUG_TLS\n\t      printf(\"Client TLS Invalid cipher %u\\n\", ja3.client.num_cipher);\n#endif\n\t    }\n\n\t    switch(cipher_id) {\n\t    case TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:\n\t    case TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384:\n\t      safari_ciphers++;\n\t      break;\n\n\t    case TLS_CIPHER_GREASE_RESERVED_0:\n\t    case TLS_AES_128_GCM_SHA256:\n\t    case TLS_AES_256_GCM_SHA384:\n\t    case TLS_CHACHA20_POLY1305_SHA256:\n\t      chrome_ciphers++;\n\t      break;\n\n\t    case TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256:\n\t    case TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:\n\t    case TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:\n\t    case TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:\n\t    case TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:\n\t    case TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:\n\t    case TLS_RSA_WITH_AES_128_CBC_SHA:\n\t    case TLS_RSA_WITH_AES_256_CBC_SHA:\n\t    case TLS_RSA_WITH_AES_128_GCM_SHA256:\n\t    case TLS_RSA_WITH_AES_256_GCM_SHA384:\n\t      safari_ciphers++, chrome_ciphers++;\n\t      break;\n\t    }\n\t  }\n\n\t  i += 2;\n\t} /* for */\n\n\tif(chrome_ciphers == 13)\n\t  flow->protos.tls_quic_stun.tls_quic.browser_euristics.is_chrome_tls = 1;\n\telse if(safari_ciphers == 12)\n\t  flow->protos.tls_quic_stun.tls_quic.browser_euristics.is_safari_tls = 1;\n      } else {\n\tinvalid_ja3 = 1;\n#ifdef DEBUG_TLS\n\tprintf(\"Client TLS Invalid len %u vs %u\\n\", (cipher_offset+cipher_len), total_len);\n#endif\n      }\n\n      offset = base_offset + session_id_len + cookie_len + cipher_len + 2;\n      offset += (!is_dtls) ? 1 : 2;\n\n      if(offset < total_len) {\n\tu_int16_t compression_len;\n\tu_int16_t extensions_len;\n\n\tcompression_len = packet->payload[offset];\n\toffset++;\n\n#ifdef DEBUG_TLS\n\tprintf(\"Client TLS [compression_len: %u]\\n\", compression_len);\n#endif\n\n\t// offset += compression_len + 3;\n\toffset += compression_len;\n\n\tif(offset+1 < total_len) {\n\t  extensions_len = ntohs(*((u_int16_t*)&packet->payload[offset]));\n\t  offset += 2;\n\n#ifdef DEBUG_TLS\n\t  printf(\"Client TLS [extensions_len: %u]\\n\", extensions_len);\n#endif\n\n\t  if((extensions_len+offset) <= total_len) {\n\t    /* Move to the first extension\n\t       Type is u_int to avoid possible overflow on extension_len addition */\n\t    u_int extension_offset = 0;\n\t    u_int32_t j;\n\n\t    while(extension_offset < extensions_len &&\n\t\t  offset+extension_offset+4 <= total_len) {\n\t      u_int16_t extension_id, extension_len, extn_off = offset+extension_offset;\n\n\n\t      extension_id = ntohs(*((u_int16_t*)&packet->payload[offset+extension_offset]));\n\t      extension_offset += 2;\n\n\t      extension_len = ntohs(*((u_int16_t*)&packet->payload[offset+extension_offset]));\n\t      extension_offset += 2;\n\n#ifdef DEBUG_TLS\n\t      printf(\"Client TLS [extension_id: %u][extension_len: %u]\\n\", extension_id, extension_len);\n#endif\n\n\t      if((extension_id == 0) || (packet->payload[extn_off] != packet->payload[extn_off+1])) {\n\t\t/* Skip GREASE */\n\n\t\tif(ja3.client.num_tls_extension < MAX_NUM_JA3)\n\t\t  ja3.client.tls_extension[ja3.client.num_tls_extension++] = extension_id;\n\t\telse {\n\t\t  invalid_ja3 = 1;\n#ifdef DEBUG_TLS\n\t\t  printf(\"Client TLS Invalid extensions %u\\n\", ja3.client.num_tls_extension);\n#endif\n\t\t}\n\t      }\n\n\t      if(extension_id == 0 /* server name */) {\n\t\tu_int16_t len;\n\n#ifdef DEBUG_TLS\n\t\tprintf(\"[TLS] Extensions: found server name\\n\");\n#endif\n\t\tif((offset+extension_offset+4) < packet->payload_packet_len) {\n\n\t\t  len = (packet->payload[offset+extension_offset+3] << 8) + packet->payload[offset+extension_offset+4];\n\t\t  len = (u_int)ndpi_min(len, sizeof(buffer)-1);\n\n\t\t  if((offset+extension_offset+5+len) <= packet->payload_packet_len) {\n\t\t    strncpy(buffer, (char*)&packet->payload[offset+extension_offset+5], len);\n\t\t    buffer[len] = '\\0';\n\n\t\t    cleanupServerName(buffer, sizeof(buffer));\n\n\t\t    snprintf(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name,\n\t\t\t     sizeof(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name),\n\t\t\t     \"%s\", buffer);\n#ifdef DEBUG_TLS\n\t\t    printf(\"[TLS] SNI: [%s]\\n\", buffer);\n#endif\n\t\t    if(!is_quic) {\n\t\t      if(ndpi_match_hostname_protocol(ndpi_struct, flow, NDPI_PROTOCOL_TLS, buffer, strlen(buffer)))\n\t\t        flow->l4.tcp.tls.subprotocol_detected = 1;\n\t\t    } else {\n\t\t      if(ndpi_match_hostname_protocol(ndpi_struct, flow, NDPI_PROTOCOL_QUIC, buffer, strlen(buffer)))\n\t\t        flow->l4.tcp.tls.subprotocol_detected = 1;\n\t\t    }\n\n\t\t    if(ndpi_check_dga_name(ndpi_struct, flow,\n\t\t\t\t\t   flow->protos.tls_quic_stun.tls_quic.client_requested_server_name, 1)) {\n\t\t      char *sni = flow->protos.tls_quic_stun.tls_quic.client_requested_server_name;\n\t\t      int len = strlen(sni);\n\n#ifdef DEBUG_TLS\n\t\t      printf(\"[TLS] SNI: (DGA) [%s]\\n\", flow->protos.tls_quic_stun.tls_quic.client_requested_server_name);\n#endif\n\n\t\t      if((len >= 4)\n\t\t         /* Check if it ends in .com or .net */\n\t\t         && ((strcmp(&sni[len-4], \".com\") == 0) || (strcmp(&sni[len-4], \".net\") == 0))\n\t\t         && (strncmp(sni, \"www.\", 4) == 0)) /* Not starting with www.... */\n\t\t        ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_TOR, NDPI_PROTOCOL_TLS);\n\t\t    } else {\n#ifdef DEBUG_TLS\n\t\t      printf(\"[TLS] SNI: (NO DGA) [%s]\\n\", flow->protos.tls_quic_stun.tls_quic.client_requested_server_name);\n#endif\n\t\t    }\n\t\t  } else {\n#ifdef DEBUG_TLS\n\t\t    printf(\"[TLS] Extensions server len too short: %u vs %u\\n\",\n\t\t\t   offset+extension_offset+5+len,\n\t\t\t   packet->payload_packet_len);\n#endif\n\t\t  }\n\t\t}\n\t      } else if(extension_id == 10 /* supported groups */) {\n\t\tu_int16_t s_offset = offset+extension_offset + 2;\n\n#ifdef DEBUG_TLS\n\t\tprintf(\"Client TLS [EllipticCurveGroups: len=%u]\\n\", extension_len);\n#endif\n\n\t\tif((s_offset+extension_len-2) <= total_len) {\n\t\t  for(i=0; i<extension_len-2;) {\n\t\t    u_int16_t s_group = ntohs(*((u_int16_t*)&packet->payload[s_offset+i]));\n\n#ifdef DEBUG_TLS\n\t\t    printf(\"Client TLS [EllipticCurve: %u/0x%04X]\\n\", s_group, s_group);\n#endif\n\t\t    if((s_group == 0) || (packet->payload[s_offset+i] != packet->payload[s_offset+i+1])) {\n\t\t      /* Skip GREASE */\n\t\t      if(ja3.client.num_elliptic_curve < MAX_NUM_JA3)\n\t\t\tja3.client.elliptic_curve[ja3.client.num_elliptic_curve++] = s_group;\n\t\t      else {\n\t\t\tinvalid_ja3 = 1;\n#ifdef DEBUG_TLS\n\t\t\tprintf(\"Client TLS Invalid num elliptic %u\\n\", ja3.client.num_elliptic_curve);\n#endif\n\t\t      }\n\t\t    }\n\n\t\t    i += 2;\n\t\t  }\n\t\t} else {\n\t\t  invalid_ja3 = 1;\n#ifdef DEBUG_TLS\n\t\t  printf(\"Client TLS Invalid len %u vs %u\\n\", (s_offset+extension_len-1), total_len);\n#endif\n\t\t}\n\t      } else if(extension_id == 11 /* ec_point_formats groups */) {\n\t\tu_int16_t s_offset = offset+extension_offset + 1;\n\n#ifdef DEBUG_TLS\n\t\tprintf(\"Client TLS [EllipticCurveFormat: len=%u]\\n\", extension_len);\n#endif\n\t\tif((s_offset+extension_len-1) <= total_len) {\n\t\t  for(i=0; i<extension_len-1; i++) {\n\t\t    u_int8_t s_group = packet->payload[s_offset+i];\n\n#ifdef DEBUG_TLS\n\t\t    printf(\"Client TLS [EllipticCurveFormat: %u]\\n\", s_group);\n#endif\n\n\t\t    if(ja3.client.num_elliptic_curve_point_format < MAX_NUM_JA3)\n\t\t      ja3.client.elliptic_curve_point_format[ja3.client.num_elliptic_curve_point_format++] = s_group;\n\t\t    else {\n\t\t      invalid_ja3 = 1;\n#ifdef DEBUG_TLS\n\t\t      printf(\"Client TLS Invalid num elliptic %u\\n\", ja3.client.num_elliptic_curve_point_format);\n#endif\n\t\t    }\n\t\t  }\n\t\t} else {\n\t\t  invalid_ja3 = 1;\n#ifdef DEBUG_TLS\n\t\t  printf(\"Client TLS Invalid len %u vs %u\\n\", s_offset+extension_len, total_len);\n#endif\n\t\t}\n\t      } else if(extension_id == 13 /* signature algorithms */) {\n\t\tu_int16_t s_offset = offset+extension_offset, safari_signature_algorithms = 0, chrome_signature_algorithms = 0;\n\t\tu_int16_t tot_signature_algorithms_len = ntohs(*((u_int16_t*)&packet->payload[s_offset]));\n\n#ifdef DEBUG_TLS\n\t\tprintf(\"Client TLS [SIGNATURE_ALGORITHMS: block_len=%u/len=%u]\\n\", extension_len, tot_signature_algorithms_len);\n#endif\n\n\t\ts_offset += 2;\n\t\ttot_signature_algorithms_len = ndpi_min((sizeof(ja3.client.signature_algorithms) / 2) - 1, tot_signature_algorithms_len);\n\n#ifdef TLS_HANDLE_SIGNATURE_ALGORITMS\n\t\tflow->protos.tls_quic_stun.tls_quic.num_tls_signature_algorithms = ndpi_min(tot_signature_algorithms_len / 2, MAX_NUM_TLS_SIGNATURE_ALGORITHMS);\n\n\t\tmemcpy(flow->protos.tls_quic_stun.tls_quic.client_signature_algorithms,\n\t\t       &packet->payload[s_offset], 2 /* 16 bit */*flow->protos.tls_quic_stun.tls_quic.num_tls_signature_algorithms);\n#endif\n\n\t\tfor(i=0; i<tot_signature_algorithms_len; i++) {\n\t\t  int rc = snprintf(&ja3.client.signature_algorithms[i*2], sizeof(ja3.client.signature_algorithms)-i*2, \"%02X\", packet->payload[s_offset+i]);\n\n\t\t  if(rc < 0) break;\n\t\t}\n\n\t\tfor(i=0; i<tot_signature_algorithms_len; i+=2) {\n\t\t  u_int16_t cipher_id = (u_int16_t)ntohs(*((u_int16_t*)&packet->payload[s_offset+i]));\n\n\t\t  // printf(\"=>> %04X\\n\", cipher_id);\n\n\t\t  switch(cipher_id) {\n\t\t  case ECDSA_SECP521R1_SHA512:\n\t\t    flow->protos.tls_quic_stun.tls_quic.browser_euristics.is_firefox_tls = 1;\n\t\t    break;\n\n\t\t  case ECDSA_SECP256R1_SHA256:\n\t\t  case ECDSA_SECP384R1_SHA384:\n\t\t  case RSA_PKCS1_SHA256:\n\t\t  case RSA_PKCS1_SHA384:\n\t\t  case RSA_PKCS1_SHA512:\n\t\t  case RSA_PSS_RSAE_SHA256:\n\t\t  case RSA_PSS_RSAE_SHA384:\n\t\t  case RSA_PSS_RSAE_SHA512:\n\t\t    chrome_signature_algorithms++, safari_signature_algorithms++;\n\t\t    break;\n\t\t  }\n\t\t}\n\n\t\tif(flow->protos.tls_quic_stun.tls_quic.browser_euristics.is_firefox_tls)\n\t\t  flow->protos.tls_quic_stun.tls_quic.browser_euristics.is_safari_tls = 0,\n\t\t    flow->protos.tls_quic_stun.tls_quic.browser_euristics.is_chrome_tls = 0;\n\n\t\tif(safari_signature_algorithms != 8)\n\t\t   flow->protos.tls_quic_stun.tls_quic.browser_euristics.is_safari_tls = 0;\n\n\t\tif(chrome_signature_algorithms != 8)\n\t\t   flow->protos.tls_quic_stun.tls_quic.browser_euristics.is_chrome_tls = 0;\n\n\t\tja3.client.signature_algorithms[i*2] = '\\0';\n\n#ifdef DEBUG_TLS\n\t\tprintf(\"Client TLS [SIGNATURE_ALGORITHMS: %s]\\n\", ja3.client.signature_algorithms);\n#endif\n\t      } else if(extension_id == 16 /* application_layer_protocol_negotiation */) {\n\t\tu_int16_t s_offset = offset+extension_offset;\n\t\tu_int16_t tot_alpn_len = ntohs(*((u_int16_t*)&packet->payload[s_offset]));\n\t\tchar alpn_str[256];\n\t\tu_int8_t alpn_str_len = 0, i;\n\n#ifdef DEBUG_TLS\n\t\tprintf(\"Client TLS [ALPN: block_len=%u/len=%u]\\n\", extension_len, tot_alpn_len);\n#endif\n\t\ts_offset += 2;\n\t\ttot_alpn_len += s_offset;\n\n\t\twhile(s_offset < tot_alpn_len && s_offset < total_len) {\n\t\t  u_int8_t alpn_i, alpn_len = packet->payload[s_offset++];\n\n\t\t  if((s_offset + alpn_len) <= tot_alpn_len &&\n\t\t     (s_offset + alpn_len) <= total_len) {\n#ifdef DEBUG_TLS\n\t\t    printf(\"Client TLS [ALPN: %u]\\n\", alpn_len);\n#endif\n\n\t\t    if((alpn_str_len+alpn_len+1) < (sizeof(alpn_str)-1)) {\n\t\t      if(alpn_str_len > 0) {\n\t\t\talpn_str[alpn_str_len] = ',';\n\t\t\talpn_str_len++;\n\t\t      }\n\n\t\t      for(alpn_i=0; alpn_i<alpn_len; alpn_i++)\n\t\t\talpn_str[alpn_str_len+alpn_i] = packet->payload[s_offset+alpn_i];\n\n\t\t      s_offset += alpn_len, alpn_str_len += alpn_len;;\n\t\t    } else\n\t\t      break;\n\t\t  } else\n\t\t    break;\n\t\t} /* while */\n\n\t\talpn_str[alpn_str_len] = '\\0';\n\n#ifdef DEBUG_TLS\n\t\tprintf(\"Client TLS [ALPN: %s][len: %u]\\n\", alpn_str, alpn_str_len);\n#endif\n\t\tif(flow->protos.tls_quic_stun.tls_quic.alpn == NULL)\n\t\t  flow->protos.tls_quic_stun.tls_quic.alpn = ndpi_strdup(alpn_str);\n\n\t\tsnprintf(ja3.client.alpn, sizeof(ja3.client.alpn), \"%s\", alpn_str);\n\n\t\t/* Replace , with - as in JA3 */\n\t\tfor(i=0; ja3.client.alpn[i] != '\\0'; i++)\n\t\t  if(ja3.client.alpn[i] == ',') ja3.client.alpn[i] = '-';\n\n\t      } else if(extension_id == 43 /* supported versions */) {\n\t\tu_int16_t s_offset = offset+extension_offset;\n\t\tu_int8_t version_len = packet->payload[s_offset];\n\t\tchar version_str[256];\n\t\tu_int8_t version_str_len = 0;\n\t\tversion_str[0] = 0;\n#ifdef DEBUG_TLS\n\t\tprintf(\"Client TLS [TLS version len: %u]\\n\", version_len);\n#endif\n\n\t\tif(version_len == (extension_len-1)) {\n\t\t  u_int8_t j;\n\t\t  u_int16_t supported_versions_offset = 0;\n\n\t\t  s_offset++;\n\n\t\t  // careful not to overflow and loop forever with u_int8_t\n\t\t  for(j=0; j+1<version_len; j += 2) {\n\t\t    u_int16_t tls_version = ntohs(*((u_int16_t*)&packet->payload[s_offset+j]));\n\t\t    u_int8_t unknown_tls_version;\n\n#ifdef DEBUG_TLS\n\t\t    printf(\"Client TLS [TLS version: %s/0x%04X]\\n\",\n\t\t\t   ndpi_ssl_version2str(flow, tls_version, &unknown_tls_version), tls_version);\n#endif\n\n\t\t    if((version_str_len+8) < sizeof(version_str)) {\n\t\t      int rc = snprintf(&version_str[version_str_len],\n\t\t\t\t\tsizeof(version_str) - version_str_len, \"%s%s\",\n\t\t\t\t\t(version_str_len > 0) ? \",\" : \"\",\n\t\t\t\t\tndpi_ssl_version2str(flow, tls_version, &unknown_tls_version));\n\t\t      if(rc <= 0)\n\t\t\tbreak;\n\t\t      else\n\t\t\tversion_str_len += rc;\n\n\t\t      rc = snprintf(&ja3.client.supported_versions[supported_versions_offset],\n\t\t\t\t    sizeof(ja3.client.supported_versions)-supported_versions_offset,\n\t\t\t\t    \"%s%04X\", (j > 0) ? \"-\" : \"\", tls_version);\n\n\t\t      if(rc > 0)\n\t\t\tsupported_versions_offset += rc;\n\t\t    }\n\t\t  }\n\n#ifdef DEBUG_TLS\n\t\t  printf(\"Client TLS [SUPPORTED_VERSIONS: %s]\\n\", ja3.client.supported_versions);\n#endif\n\n\t\t  if(flow->protos.tls_quic_stun.tls_quic.tls_supported_versions == NULL)\n\t\t    flow->protos.tls_quic_stun.tls_quic.tls_supported_versions = ndpi_strdup(version_str);\n\t\t}\n\t      } else if(extension_id == 65486 /* encrypted server name */) {\n\t\t/*\n\t\t   - https://tools.ietf.org/html/draft-ietf-tls-esni-06\n\t\t   - https://blog.cloudflare.com/encrypted-sni/\n\t\t*/\n\t\tu_int16_t e_offset = offset+extension_offset;\n\t\tu_int16_t initial_offset = e_offset;\n\t\tu_int16_t e_sni_len, cipher_suite = ntohs(*((u_int16_t*)&packet->payload[e_offset]));\n\n\t\tflow->protos.tls_quic_stun.tls_quic.encrypted_sni.cipher_suite = cipher_suite;\n\n\t\te_offset += 2; /* Cipher suite len */\n\n\t\t/* Key Share Entry */\n\t\te_offset += 2; /* Group */\n\t\te_offset +=  ntohs(*((u_int16_t*)&packet->payload[e_offset])) + 2; /* Lenght */\n\n\t\tif((e_offset+4) < packet->payload_packet_len) {\n\t\t  /* Record Digest */\n\t\t  e_offset +=  ntohs(*((u_int16_t*)&packet->payload[e_offset])) + 2; /* Lenght */\n\n\t\t  if((e_offset+4) < packet->payload_packet_len) {\n\t\t    e_sni_len = ntohs(*((u_int16_t*)&packet->payload[e_offset]));\n\t\t    e_offset += 2;\n\n\t\t    if((e_offset+e_sni_len-extension_len-initial_offset) >= 0 &&\n\t\t        e_offset+e_sni_len < packet->payload_packet_len) {\n#ifdef DEBUG_ENCRYPTED_SNI\n\t\t      printf(\"Client TLS [Encrypted Server Name len: %u]\\n\", e_sni_len);\n#endif\n\n\t\t      if(flow->protos.tls_quic_stun.tls_quic.encrypted_sni.esni == NULL) {\n\t\t\tflow->protos.tls_quic_stun.tls_quic.encrypted_sni.esni = (char*)ndpi_malloc(e_sni_len*2+1);\n\n\t\t\tif(flow->protos.tls_quic_stun.tls_quic.encrypted_sni.esni) {\n\t\t\t  u_int16_t i, off;\n\n\t\t\t  for(i=e_offset, off=0; i<(e_offset+e_sni_len); i++) {\n\t\t\t    int rc = sprintf(&flow->protos.tls_quic_stun.tls_quic.encrypted_sni.esni[off], \"%02X\", packet->payload[i] & 0XFF);\n\n\t\t\t    if(rc <= 0) {\n\t\t\t      flow->protos.tls_quic_stun.tls_quic.encrypted_sni.esni[off] = '\\0';\n\t\t\t      break;\n\t\t\t    } else\n\t\t\t      off += rc;\n\t\t\t  }\n\t\t\t}\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t}\n\t      } else if(extension_id == 65445 || /* QUIC transport parameters (drafts version) */\n\t\t        extension_id == 57) { /* QUIC transport parameters (final version) */\n\t\tu_int16_t s_offset = offset+extension_offset;\n\t\tuint16_t final_offset;\n\t\tint using_var_int = is_version_with_var_int_transport_params(quic_version);\n\n\t\tif(!using_var_int) {\n\t\t  if(s_offset+1 >= total_len) {\n\t\t    final_offset = 0; /* Force skipping extension */\n\t\t  } else {\n\t\t    u_int16_t seq_len = ntohs(*((u_int16_t*)&packet->payload[s_offset]));\n\t\t    s_offset += 2;\n\t            final_offset = MIN(total_len, s_offset + seq_len);\n\t\t  }\n\t\t} else {\n\t          final_offset = MIN(total_len, s_offset + extension_len);\n\t\t}\n\n\t\twhile(s_offset < final_offset) {\n\t\t  u_int64_t param_type, param_len;\n\n                  if(!using_var_int) {\n\t\t    if(s_offset+3 >= final_offset)\n\t\t      break;\n\t\t    param_type = ntohs(*((u_int16_t*)&packet->payload[s_offset]));\n\t\t    param_len = ntohs(*((u_int16_t*)&packet->payload[s_offset + 2]));\n\t\t    s_offset += 4;\n\t\t  } else {\n\t\t    if(s_offset >= final_offset ||\n\t\t       (s_offset + quic_len_buffer_still_required(packet->payload[s_offset])) >= final_offset)\n\t\t      break;\n\t\t    s_offset += quic_len(&packet->payload[s_offset], &param_type);\n\n\t\t    if(s_offset >= final_offset ||\n\t\t       (s_offset + quic_len_buffer_still_required(packet->payload[s_offset])) >= final_offset)\n\t\t      break;\n\t\t    s_offset += quic_len(&packet->payload[s_offset], &param_len);\n\t\t  }\n\n#ifdef DEBUG_TLS\n\t\t  printf(\"Client TLS [QUIC TP: Param 0x%x Len %d]\\n\", (int)param_type, (int)param_len);\n#endif\n\t\t  if(s_offset+param_len > final_offset)\n\t\t    break;\n\n\t\t  if(param_type==0x3129) {\n#ifdef DEBUG_TLS\n\t\t      printf(\"UA [%.*s]\\n\", (int)param_len, &packet->payload[s_offset]);\n#endif\n\t\t      http_process_user_agent(ndpi_struct, flow,\n\t\t\t\t\t      &packet->payload[s_offset], param_len);\n\t\t      break;\n\t\t  }\n\t\t  s_offset += param_len;\n\t\t}\n\t      }\n\n\t      extension_offset += extension_len; /* Move to the next extension */\n\n#ifdef DEBUG_TLS\n\t      printf(\"Client TLS [extension_offset/len: %u/%u]\\n\", extension_offset, extension_len);\n#endif\n\t    } /* while */\n\n\t    if(!invalid_ja3) {\n\t      int rc;\n\n\t    compute_ja3c:\n\t      ja3_str_len = snprintf(ja3_str, sizeof(ja3_str), \"%u,\", ja3.client.tls_handshake_version);\n\n\t      for(i=0; i<ja3.client.num_cipher; i++) {\n\t\trc = snprintf(&ja3_str[ja3_str_len], sizeof(ja3_str)-ja3_str_len, \"%s%u\",\n\t\t\t      (i > 0) ? \"-\" : \"\", ja3.client.cipher[i]);\n\t\tif((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc; else break;\n\t      }\n\n\t      rc = snprintf(&ja3_str[ja3_str_len], sizeof(ja3_str)-ja3_str_len, \",\");\n\t      if((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc;\n\n\t      /* ********** */\n\n\t      for(i=0; i<ja3.client.num_tls_extension; i++) {\n\t\trc = snprintf(&ja3_str[ja3_str_len], sizeof(ja3_str)-ja3_str_len, \"%s%u\",\n\t\t\t      (i > 0) ? \"-\" : \"\", ja3.client.tls_extension[i]);\n\t\tif((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc; else break;\n\t      }\n\n\t      rc = snprintf(&ja3_str[ja3_str_len], sizeof(ja3_str)-ja3_str_len, \",\");\n\t      if((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc;\n\n\t      /* ********** */\n\n\t      for(i=0; i<ja3.client.num_elliptic_curve; i++) {\n\t\trc = snprintf(&ja3_str[ja3_str_len], sizeof(ja3_str)-ja3_str_len, \"%s%u\",\n\t\t\t      (i > 0) ? \"-\" : \"\", ja3.client.elliptic_curve[i]);\n\t\tif((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc; else break;\n\t      }\n\n\t      rc = snprintf(&ja3_str[ja3_str_len], sizeof(ja3_str)-ja3_str_len, \",\");\n\t      if((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc;\n\n\t      for(i=0; i<ja3.client.num_elliptic_curve_point_format; i++) {\n\t\trc = snprintf(&ja3_str[ja3_str_len], sizeof(ja3_str)-ja3_str_len, \"%s%u\",\n\t\t\t      (i > 0) ? \"-\" : \"\", ja3.client.elliptic_curve_point_format[i]);\n\t\tif((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc; else break;\n\t      }\n\n\t      if(ndpi_struct->enable_ja3_plus) {\n\t\trc = snprintf(&ja3_str[ja3_str_len], sizeof(ja3_str)-ja3_str_len,\n\t\t\t      \",%s,%s,%s\", ja3.client.signature_algorithms, ja3.client.supported_versions, ja3.client.alpn);\n\t\tif((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc;\n\t      }\n\n#ifdef DEBUG_JA3C\n\t      printf(\"[JA3+] Client: %s \\n\", ja3_str);\n#endif\n\n\t      ndpi_MD5Init(&ctx);\n\t      ndpi_MD5Update(&ctx, (const unsigned char *)ja3_str, strlen(ja3_str));\n\t      ndpi_MD5Final(md5_hash, &ctx);\n\n\t      for(i=0, j=0; i<16; i++) {\n\t\trc = snprintf(&flow->protos.tls_quic_stun.tls_quic.ja3_client[j],\n\t\t\t      sizeof(flow->protos.tls_quic_stun.tls_quic.ja3_client)-j, \"%02x\",\n\t\t\t      md5_hash[i]);\n\t\tif(rc > 0) j += rc; else break;\n\t      }\n\n#ifdef DEBUG_JA3C\n\t      printf(\"[JA3] Client: %s \\n\", flow->protos.tls_quic_stun.tls_quic.ja3_client);\n#endif\n\n\t      if(ndpi_struct->malicious_ja3_automa.ac_automa != NULL) {\n\t\tu_int16_t rc1 = ndpi_match_string(ndpi_struct->malicious_ja3_automa.ac_automa,\n\t\t\t\t\t\t  flow->protos.tls_quic_stun.tls_quic.ja3_client);\n\n\t\tif(rc1 > 0)\n\t\t  ndpi_set_risk(flow, NDPI_MALICIOUS_JA3);\n\t      }\n\t    }\n\n\t    /* Before returning to the caller we need to make a final check */\n\t    if((flow->protos.tls_quic_stun.tls_quic.ssl_version >= 0x0303) /* >= TLSv1.2 */\n\t       && (flow->protos.tls_quic_stun.tls_quic.alpn == NULL) /* No ALPN */) {\n\t      ndpi_set_risk(flow, NDPI_TLS_NOT_CARRYING_HTTPS);\n\t    }\n\n\t    /* Suspicious Domain Fronting:\n\t       https://github.com/SixGenInc/Noctilucent/blob/master/docs/ */\n\t    if(flow->protos.tls_quic_stun.tls_quic.encrypted_sni.esni &&\n\t       flow->protos.tls_quic_stun.tls_quic.client_requested_server_name[0] != '\\0') {\n\t      ndpi_set_risk(flow, NDPI_TLS_SUSPICIOUS_ESNI_USAGE);\n\t    }\n\n\t    /* Add check for missing SNI */\n\t    if((flow->protos.tls_quic_stun.tls_quic.client_requested_server_name[0] == 0)\n\t       && (flow->protos.tls_quic_stun.tls_quic.ssl_version >= 0x0302) /* TLSv1.1 */\n\t       && (flow->protos.tls_quic_stun.tls_quic.encrypted_sni.esni == NULL) /* No ESNI */\n\t       ) {\n\t      /* This is a bit suspicious */\n\t      ndpi_set_risk(flow, NDPI_TLS_MISSING_SNI);\n\t    }\n\n\t    return(2 /* Client Certificate */);\n\t  } else {\n#ifdef DEBUG_TLS\n\t    printf(\"[TLS] Client: too short [%u vs %u]\\n\",\n\t\t   (extensions_len+offset), total_len);\n#endif\n\t  }\n\t} else if(offset == total_len) {\n\t  /* TLS does not have extensions etc */\n\t  goto compute_ja3c;\n\t}\n      } else {\n#ifdef DEBUG_TLS\n\tprintf(\"[JA3] Client: invalid length detected\\n\");\n#endif\n      }\n    }\n  }\n\n  return(0); /* Not found */\n}\n\n/* **************************************** */\n\nstatic void ndpi_search_tls_wrapper(struct ndpi_detection_module_struct *ndpi_struct,\n\t\t\t\t    struct ndpi_flow_struct *flow) {\n  struct ndpi_packet_struct *packet = &flow->packet;\n\n#ifdef DEBUG_TLS\n  printf(\"==>> %s() %u [len: %u][version: %u]\\n\",\n\t __FUNCTION__,\n\t flow->guessed_host_protocol_id,\n\t packet->payload_packet_len,\n\t flow->protos.tls_quic_stun.tls_quic.ssl_version);\n#endif\n\n  if(packet->udp != NULL)\n    ndpi_search_tls_udp(ndpi_struct, flow);\n  else\n    ndpi_search_tls_tcp(ndpi_struct, flow);\n}\n\n/* **************************************** */\n\nvoid init_tls_dissector(struct ndpi_detection_module_struct *ndpi_struct,\n\t\t\tu_int32_t *id, NDPI_PROTOCOL_BITMASK *detection_bitmask) {\n  ndpi_set_bitmask_protocol_detection(\"TLS\", ndpi_struct, detection_bitmask, *id,\n\t\t\t\t      NDPI_PROTOCOL_TLS,\n\t\t\t\t      ndpi_search_tls_wrapper,\n\t\t\t\t      NDPI_SELECTION_BITMASK_PROTOCOL_V4_V6_TCP_WITH_PAYLOAD_WITHOUT_RETRANSMISSION,\n\t\t\t\t      SAVE_DETECTION_BITMASK_AS_UNKNOWN,\n\t\t\t\t      ADD_TO_DETECTION_BITMASK);\n\n  *id += 1;\n\n  /* *************************************************** */\n\n  ndpi_set_bitmask_protocol_detection(\"DTLS\", ndpi_struct, detection_bitmask, *id,\n\t\t\t\t      NDPI_PROTOCOL_DTLS,\n\t\t\t\t      ndpi_search_tls_wrapper,\n\t\t\t\t      NDPI_SELECTION_BITMASK_PROTOCOL_V4_V6_UDP_WITH_PAYLOAD,\n\t\t\t\t      SAVE_DETECTION_BITMASK_AS_UNKNOWN,\n\t\t\t\t      ADD_TO_DETECTION_BITMASK);\n\n  *id += 1;\n}\n"], "fixing_code": ["/*\n * netbios.c\n *\n * Copyright (C) 2011-21 - ntop.org\n * Copyright (C) 2009-11 - ipoque GmbH\n *\n * This file is part of nDPI, an open source deep packet inspection\n * library based on the OpenDPI and PACE technology by ipoque GmbH\n *\n * nDPI is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * nDPI is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with nDPI.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n\n#include \"ndpi_protocol_ids.h\"\n\n#define NDPI_CURRENT_PROTO NDPI_PROTOCOL_NETBIOS\n\n#include \"ndpi_api.h\"\n\n/* ****************************************************************** */\n\nstruct netbios_header {\n  u_int16_t transaction_id, flags, questions, answer_rrs, authority_rrs, additional_rrs;\n};\n\n/* ****************************************************************** */\n\n/* The function below has been inherited by tcpdump */\nint ndpi_netbios_name_interpret(char *in, size_t in_len, char *out, u_int out_len) {\n  u_int ret = 0, len, idx = in_len, out_idx = 0;\n\n  len = (*in++)/2, in_len--;\n  out_len--;\n  out[out_idx] = 0;\n\n  if((len > out_len) || (len < 1) || ((2*len) > in_len))\n    return(-1);\n\n  while((len--) && (out_idx < out_len)) {\n    if((idx < 2) || (in[0] < 'A') || (in[0] > 'P') || (in[1] < 'A') || (in[1] > 'P')) {\n      out[out_idx] = 0;\n      break;\n    }\n\n    out[out_idx] = ((in[0] - 'A') << 4) + (in[1] - 'A');\n    in += 2, idx -= 2;\n\n    if(isprint(out[out_idx]))\n      out_idx++, ret++;\n  }\n\n  /* Trim trailing whitespace from the returned string */\n  if(out_idx > 0) {\n    out[out_idx] = 0;\n    out_idx--;\n\n    while((out_idx > 0) && (out[out_idx] == ' ')) {\n      out[out_idx] = 0;\n      out_idx--;\n    }\n\n  }\n\n  return(ret);\n}\n\n/* ****************************************************************** */\n\nstatic void ndpi_int_netbios_add_connection(struct ndpi_detection_module_struct *ndpi_struct,\n\t\t\t\t\t    struct ndpi_flow_struct *flow,\n\t\t\t\t\t    u_int16_t sub_protocol) {\n  char name[64];\n  u_int off = flow->packet.payload[12] == 0x20 ? 12 : 14;\n\n  if((off < flow->packet.payload_packet_len)\n     && ndpi_netbios_name_interpret((char*)&flow->packet.payload[off],\n\t\t\t\t flow->packet.payload_packet_len - off, name, sizeof(name)) > 0) {\n      snprintf((char*)flow->host_server_name, sizeof(flow->host_server_name)-1, \"%s\", name);\n\n      ndpi_check_dga_name(ndpi_struct, flow, (char*)flow->host_server_name, 1);\n  }\n\n  if(sub_protocol == NDPI_PROTOCOL_UNKNOWN)\n    ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_NETBIOS, NDPI_PROTOCOL_UNKNOWN);\n  else\n    ndpi_set_detected_protocol(ndpi_struct, flow, sub_protocol, NDPI_PROTOCOL_NETBIOS);\n}\n\n/* ****************************************************************** */\n\nvoid ndpi_search_netbios(struct ndpi_detection_module_struct *ndpi_struct,\n\t\t\t struct ndpi_flow_struct *flow) {\n  struct ndpi_packet_struct *packet = &flow->packet;\n  u_int16_t dport;\n\n  NDPI_LOG_DBG(ndpi_struct, \"search netbios\\n\");\n\n  if(packet->udp != NULL) {\n    dport = ntohs(packet->udp->dest);\n\n    /*check standard NETBIOS over udp to port 137  */\n    if((dport == 137 || 0) && packet->payload_packet_len >= 50) {\n      struct netbios_header h;\n\n      memcpy(&h, packet->payload, sizeof(struct netbios_header));\n      h.transaction_id = ntohs(h.transaction_id), h.flags = ntohs(h.flags),\n\th.questions = ntohs(h.questions), h.answer_rrs = ntohs(h.answer_rrs),\n\th.authority_rrs = ntohs(h.authority_rrs), h.additional_rrs = ntohs(h.additional_rrs);\n\n      NDPI_LOG_DBG(ndpi_struct, \"found netbios port 137 and payload_packet_len 50\\n\");\n\n      if(h.flags == 0 &&\n\t h.questions == 1 &&\n\t h.answer_rrs == 0 &&\n\t h.authority_rrs == 0 && h.additional_rrs == 0) {\n\n\tNDPI_LOG_INFO(ndpi_struct, \"found netbios with questions = 1 and answers = 0, authority = 0  \\n\");\n\n\tndpi_int_netbios_add_connection(ndpi_struct, flow, NDPI_PROTOCOL_UNKNOWN);\n\treturn;\n      }\n\n      if(((h.flags & 0x8710) == 0x10) &&\n\t h.questions == 1 &&\n\t h.answer_rrs == 0 &&\n\t h.authority_rrs == 0) {\n\n\tNDPI_LOG_INFO(ndpi_struct, \"found netbios with questions = 1 and answers = 0, authority = 0 and broadcast \\n\");\n\n\tndpi_int_netbios_add_connection(ndpi_struct, flow, NDPI_PROTOCOL_UNKNOWN);\n\treturn;\n      }\n\n      if(packet->payload[2] == 0x80 &&\n\t h.questions == 1 &&\n\t h.answer_rrs == 0 &&\n\t h.authority_rrs == 0 && h.additional_rrs == 1) {\n\n\tNDPI_LOG_INFO(ndpi_struct, \"found netbios with questions = 1 and answers, authority, additional = 0  \\n\");\n\n\tndpi_int_netbios_add_connection(ndpi_struct, flow, NDPI_PROTOCOL_UNKNOWN);\n\treturn;\n      }\n\n      if(h.flags == 0x4000 &&\n\t h.questions == 1 &&\n\t h.answer_rrs == 0 &&\n\t h.authority_rrs == 0 && h.additional_rrs == 1) {\n\n\tNDPI_LOG_INFO(ndpi_struct, \"found netbios with questions = 1 and answers = 0, authority = 0  \\n\");\n\n\tndpi_int_netbios_add_connection(ndpi_struct, flow, NDPI_PROTOCOL_UNKNOWN);\n\treturn;\n      }\n\n      if(h.flags == 0x8400 &&\n\t h.questions == 0 &&\n\t h.answer_rrs == 1 &&\n\t h.authority_rrs == 0 && h.additional_rrs == 0) {\n\n\tNDPI_LOG_INFO(ndpi_struct,\n\t\t      \"found netbios with flag 8400 questions = 0 and answers = 1, authority, additional = 0  \\n\");\n\n\tndpi_int_netbios_add_connection(ndpi_struct, flow, NDPI_PROTOCOL_UNKNOWN);\n\treturn;\n      }\n\n      if(h.flags == 0x8500 &&\n\t h.questions == 0 &&\n\t h.answer_rrs == 1 &&\n\t h.authority_rrs == 0 && h.additional_rrs == 0) {\n\n\tNDPI_LOG_INFO(ndpi_struct,\n\t\t      \"found netbios with flag 8500 questions = 0 and answers = 1, authority, additional = 0  \\n\");\n\n\tndpi_int_netbios_add_connection(ndpi_struct, flow, NDPI_PROTOCOL_UNKNOWN);\n\treturn;\n      }\n\n      if(((h.flags == 0x2900) || (h.flags == 0x2910)) &&\n\t h.questions == 1 &&\n\t h.answer_rrs == 0 &&\n\t h.authority_rrs == 0 && h.additional_rrs == 1) {\n\n\tNDPI_LOG_INFO(ndpi_struct,\n\t\t      \"found netbios with flag 2910, questions = 1 and answers, authority=0, additional = 1  \\n\");\n\n\tndpi_int_netbios_add_connection(ndpi_struct, flow, NDPI_PROTOCOL_UNKNOWN);\n\treturn;\n      }\n\n      if(h.flags == 0xAD86 &&\n\t h.questions == 0 &&\n\t h.answer_rrs == 1 &&\n\t h.authority_rrs == 0 && h.additional_rrs == 0) {\n\n\tNDPI_LOG_INFO(ndpi_struct,\n\t\t      \"found netbios with flag ad86 questions = 0 and answers = 1, authority, additional = 0  \\n\");\n\n\tndpi_int_netbios_add_connection(ndpi_struct, flow, NDPI_PROTOCOL_UNKNOWN);\n\treturn;\n      }\n\n      if(h.flags == 0x0110 &&\n\t h.questions == 1 &&\n\t h.answer_rrs == 0 &&\n\t h.authority_rrs == 0 && h.additional_rrs == 0) {\n\n\tNDPI_LOG_INFO(ndpi_struct,\n\t\t      \"found netbios with flag 0110 questions = 1 and answers = 0, authority, additional = 0  \\n\");\n\n\tndpi_int_netbios_add_connection(ndpi_struct, flow, NDPI_PROTOCOL_UNKNOWN);\n\treturn;\n      }\n\n      if((h.flags & 0xf800) == 0) {\n\tNDPI_LOG_DBG2(ndpi_struct, \"possible netbios name query request\\n\");\n\n\tif(get_u_int16_t(packet->payload, 4) == htons(1) &&\n\t   get_u_int16_t(packet->payload, 6) == 0 &&\n\t   get_u_int16_t(packet->payload, 8) == 0 && get_u_int16_t(packet->payload, 10) == 0) {\n\n\t  /* name is encoded as described in rfc883 */\n\t  u_int8_t name_length = packet->payload[12];\n\n\t  NDPI_LOG_DBG2(ndpi_struct,\n\t\t\t\"possible netbios name query request, one question\\n\");\n\n\t  if(packet->payload_packet_len == 12 + 1 + name_length + 1 + 2 + 2) {\n\n\t    NDPI_LOG_DBG2(ndpi_struct,\n\t\t\t  \"possible netbios name query request, length matches\\n\");\n\n\t    /* null terminated? */\n\t    if(packet->payload[12 + name_length + 1] == 0 &&\n\t       get_u_int16_t(packet->payload, 12 + name_length + 2) == htons(0x0020) &&\n\t       get_u_int16_t(packet->payload, 12 + name_length + 4) == htons(0x0001)) {\n\n\t      NDPI_LOG_INFO(ndpi_struct,\n\t\t\t    \"found netbios name query request\\n\");\n\t      ndpi_int_netbios_add_connection(ndpi_struct, flow, NDPI_PROTOCOL_UNKNOWN);\n\t      return;\n\t    }\n\t  }\n\t}\n      } else if((h.flags & 0xf800) == 0x8000) {\n\tNDPI_LOG_DBG2(ndpi_struct,\n\t\t      \"possible netbios name query response\\n\");\n\n\tif(get_u_int16_t(packet->payload, 4) == 0 &&\n\t   get_u_int16_t(packet->payload, 6) == htons(1) &&\n\t   get_u_int16_t(packet->payload, 8) == 0 && get_u_int16_t(packet->payload, 10) == 0) {\n\n\t  /* name is encoded as described in rfc883 */\n\t  u_int8_t name_length = packet->payload[12];\n\n\t  NDPI_LOG_DBG2(ndpi_struct,\n\t\t\t\"possible netbios positive name query response, one answer\\n\");\n\n\t  if(packet->payload_packet_len >= 12 + 1 + name_length + 1 + 2 + 2) {\n\n\t    NDPI_LOG_DBG2(ndpi_struct,\n\t\t\t  \"possible netbios name query response, length matches\\n\");\n\n\t    /* null terminated? */\n\t    if(packet->payload[12 + name_length + 1] == 0 &&\n\t       get_u_int16_t(packet->payload, 12 + name_length + 2) == htons(0x0020) &&\n\t       get_u_int16_t(packet->payload, 12 + name_length + 4) == htons(0x0001)) {\n\n\t      NDPI_LOG_INFO(ndpi_struct,\n\t\t\t    \"found netbios name query response\\n\");\n\t      ndpi_int_netbios_add_connection(ndpi_struct, flow, NDPI_PROTOCOL_UNKNOWN);\n\t      return;\n\t    }\n\t  }\n\t} else if(get_u_int16_t(packet->payload, 4) == 0 &&\n\t\t  get_u_int16_t(packet->payload, 6) == 0 &&\n\t\t  get_u_int16_t(packet->payload, 8) == 0 && get_u_int16_t(packet->payload, 10) == 0) {\n\n\t  /* name is encoded as described in rfc883 */\n\t  u_int8_t name_length = packet->payload[12];\n\n\t  NDPI_LOG_DBG2(ndpi_struct,\n\t\t\t\"possible netbios negative name query response, one answer\\n\");\n\n\t  if(packet->payload_packet_len >= 12 + 1 + name_length + 1 + 2 + 2) {\n\n\t    NDPI_LOG_DBG2(ndpi_struct,\n\t\t\t  \"possible netbios name query response, length matches\\n\");\n\n\t    /* null terminated? */\n\t    if(packet->payload[12 + name_length + 1] == 0 &&\n\t       get_u_int16_t(packet->payload, 12 + name_length + 2) == htons(0x000A) &&\n\t       get_u_int16_t(packet->payload, 12 + name_length + 4) == htons(0x0001)) {\n\n\t      NDPI_LOG_INFO(ndpi_struct,\n\t\t\t    \"found netbios name query response\\n\");\n\t      ndpi_int_netbios_add_connection(ndpi_struct, flow, NDPI_PROTOCOL_UNKNOWN);\n\t      return;\n\t    }\n\t  }\n\t} else if(get_u_int16_t(packet->payload, 4) == 0 &&\n\t\t  get_u_int16_t(packet->payload, 6) == 0 &&\n\t\t  get_u_int16_t(packet->payload, 8) == htons(1) && get_u_int16_t(packet->payload, 10) == htons(1)) {\n\n\t  /* name is encoded as described in rfc883 */\n\t  u_int8_t name_length = packet->payload[12];\n\n\t  NDPI_LOG_DBG2(ndpi_struct,\n\t\t\t\"possible netbios redirect name query response, one answer\\n\");\n\n\t  if(packet->payload_packet_len >= 12 + 1 + name_length + 1 + 2 + 2) {\n\n\t    NDPI_LOG_DBG2(ndpi_struct,\n\t\t\t  \"possible netbios name query response, length matches\\n\");\n\n\t    /* null terminated? */\n\t    if(packet->payload[12 + name_length + 1] == 0 &&\n\t       get_u_int16_t(packet->payload, 12 + name_length + 2) == htons(0x0002) &&\n\t       get_u_int16_t(packet->payload, 12 + name_length + 4) == htons(0x0001)) {\n\n\t      NDPI_LOG_INFO(ndpi_struct,\n\t\t\t    \"found netbios name query response\\n\");\n\t      ndpi_int_netbios_add_connection(ndpi_struct, flow, NDPI_PROTOCOL_UNKNOWN);\n\t      return;\n\t    }\n\t  }\n\t}\n      }\n      /* TODO: extend according to rfc1002 */\n    }\n\n    /* check standard NETBIOS over udp to port 138 */\n\n    /* netbios header token from http://www.protocolbase.net/protocols/protocol_NBDGM.php */\n\n    if((dport == 138) && (packet->payload_packet_len >= 14)) {\n      u_int16_t netbios_len = ntohs(get_u_int16_t(packet->payload, 10));\n\n      if(netbios_len == packet->payload_packet_len - 14) {\n\tNDPI_LOG_DBG2(ndpi_struct, \"found netbios port 138 and payload length >= 112 \\n\");\n\n\tif(packet->payload[0] >= 0x10 && packet->payload[0] <= 0x16) {\n\t  u_int32_t source_ip = ntohl(get_u_int32_t(packet->payload, 4));\n\n\t  NDPI_LOG_DBG2(ndpi_struct, \"found netbios with MSG-type 0x10,0x11,0x12,0x13,0x14,0x15 or 0x16\\n\");\n\n\t  if(source_ip == ntohl(packet->iph->saddr)) {\n\t    int16_t leftover = netbios_len - 82; /* NetBIOS len */\n\n\t    NDPI_LOG_INFO(ndpi_struct, \"found netbios with checked ip-address\\n\");\n\n\t    ndpi_int_netbios_add_connection(ndpi_struct, flow, (leftover > 0) ? NDPI_PROTOCOL_SMBV1 : NDPI_PROTOCOL_UNKNOWN);\n\t    return;\n\t  }\n\t}\n      }\n    }\n  }\n\n  if(packet->tcp != NULL) {\n    dport = ntohs(packet->tcp->dest);\n\n    /* destination port must be 139 */\n    if(dport == 139) {\n      NDPI_LOG_DBG2(ndpi_struct, \"found netbios with destination port 139\\n\");\n\n      /* payload_packet_len must be 72 */\n      if(packet->payload_packet_len == 72) {\n\tNDPI_LOG_DBG2(ndpi_struct, \"found netbios with payload_packen_len = 72. \\n\");\n\n\tif(packet->payload[0] == 0x81 && packet->payload[1] == 0 && ntohs(get_u_int16_t(packet->payload, 2)) == 68) {\n\t  NDPI_LOG_INFO(ndpi_struct,\n\t\t\t\"found netbios with session request = 81, flags=0 and length od following bytes = 68. \\n\");\n\n\t  ndpi_int_netbios_add_connection(ndpi_struct, flow, NDPI_PROTOCOL_UNKNOWN);\n\t  return;\n\t}\n      }\n    }\n\n  }\n\n  NDPI_EXCLUDE_PROTO(ndpi_struct, flow);\n}\n\n/* ****************************************************************** */\n\nvoid init_netbios_dissector(struct ndpi_detection_module_struct *ndpi_struct, u_int32_t *id, NDPI_PROTOCOL_BITMASK *detection_bitmask)\n{\n  ndpi_set_bitmask_protocol_detection(\"NETBIOS\", ndpi_struct, detection_bitmask, *id,\n\t\t\t\t      NDPI_PROTOCOL_NETBIOS,\n\t\t\t\t      ndpi_search_netbios,\n\t\t\t\t      NDPI_SELECTION_BITMASK_PROTOCOL_TCP_OR_UDP_WITH_PAYLOAD_WITHOUT_RETRANSMISSION,\n\t\t\t\t      SAVE_DETECTION_BITMASK_AS_UNKNOWN,\n\t\t\t\t      ADD_TO_DETECTION_BITMASK);\n\n  *id += 1;\n}\n", "/*\n * tls.c - TLS/TLS/DTLS dissector\n *\n * Copyright (C) 2016-21 - ntop.org\n *\n * nDPI is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * nDPI is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with nDPI.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n#include \"ndpi_protocol_ids.h\"\n\n#define NDPI_CURRENT_PROTO NDPI_PROTOCOL_TLS\n\n#include \"ndpi_api.h\"\n#include \"ndpi_md5.h\"\n#include \"ndpi_sha1.h\"\n#include \"ndpi_encryption.h\"\n\nextern char *strptime(const char *s, const char *format, struct tm *tm);\nextern int processClientServerHello(struct ndpi_detection_module_struct *ndpi_struct,\n\t\t\t\t    struct ndpi_flow_struct *flow, uint32_t quic_version);\nextern int http_process_user_agent(struct ndpi_detection_module_struct *ndpi_struct,\n                                   struct ndpi_flow_struct *flow,\n                                   const u_int8_t *ua_ptr, u_int16_t ua_ptr_len);\n/* QUIC/GQUIC stuff */\nextern int quic_len(const uint8_t *buf, uint64_t *value);\nextern int quic_len_buffer_still_required(uint8_t value);\nextern int is_version_with_var_int_transport_params(uint32_t version);\n\n// #define DEBUG_TLS_MEMORY       1\n// #define DEBUG_TLS              1\n// #define DEBUG_TLS_BLOCKS       1\n// #define DEBUG_CERTIFICATE_HASH\n\n// #define DEBUG_JA3C 1\n\n/* #define DEBUG_FINGERPRINT      1 */\n/* #define DEBUG_ENCRYPTED_SNI    1 */\n\n/* **************************************** */\n\n/* https://engineering.salesforce.com/tls-fingerprinting-with-ja3-and-ja3s-247362855967 */\n\n#define JA3_STR_LEN        1024\n#define MAX_NUM_JA3         512\n#define MAX_JA3_STRLEN      256\n\nunion ja3_info {\n  struct {\n    u_int16_t tls_handshake_version;\n    u_int16_t num_cipher, cipher[MAX_NUM_JA3];\n    u_int16_t num_tls_extension, tls_extension[MAX_NUM_JA3];\n    u_int16_t num_elliptic_curve, elliptic_curve[MAX_NUM_JA3];\n    u_int16_t num_elliptic_curve_point_format, elliptic_curve_point_format[MAX_NUM_JA3];\n    char signature_algorithms[MAX_JA3_STRLEN], supported_versions[MAX_JA3_STRLEN], alpn[MAX_JA3_STRLEN];\n  } client;\n\n  struct {\n    u_int16_t tls_handshake_version;\n    u_int16_t num_cipher, cipher[MAX_NUM_JA3];\n    u_int16_t num_tls_extension, tls_extension[MAX_NUM_JA3];\n    u_int16_t tls_supported_version;\n    u_int16_t num_elliptic_curve_point_format, elliptic_curve_point_format[MAX_NUM_JA3];\n    char alpn[MAX_JA3_STRLEN];\n  } server; /* Used for JA3+ */\n};\n\n/*\n  NOTE\n\n  How to view the certificate fingerprint\n  1. Using wireshark save the certificate on certificate.bin file as explained\n     in https://security.stackexchange.com/questions/123851/how-can-i-extract-the-certificate-from-this-pcap-file\n\n  2. openssl x509 -inform der -in certificate.bin -text > certificate.der\n  3. openssl x509 -noout -fingerprint -sha1 -inform pem -in certificate.der\n     SHA1 Fingerprint=15:9A:76....\n\n  $ shasum -a 1 www.grc.com.bin\n    159a76.....\n */\n\n#define NDPI_MAX_TLS_REQUEST_SIZE 10000\n\n/* skype.c */\nextern u_int8_t is_skype_flow(struct ndpi_detection_module_struct *ndpi_struct,\n\t\t\t      struct ndpi_flow_struct *flow);\n\n/* stun.c */\nextern u_int32_t get_stun_lru_key(struct ndpi_flow_struct *flow, u_int8_t rev);\n\nstatic void ndpi_int_tls_add_connection(struct ndpi_detection_module_struct *ndpi_struct,\n\t\t\t\t\tstruct ndpi_flow_struct *flow, u_int32_t protocol);\n\n/* **************************************** */\n\nstatic u_int32_t ndpi_tls_refine_master_protocol(struct ndpi_detection_module_struct *ndpi_struct,\n\t\t\t\t\t\t struct ndpi_flow_struct *flow, u_int32_t protocol) {\n  struct ndpi_packet_struct *packet = &flow->packet;\n\n  // protocol = NDPI_PROTOCOL_TLS;\n\n  if(packet->tcp != NULL) {\n    switch(protocol) {\n    case NDPI_PROTOCOL_TLS:\n      {\n\t/*\n\t  In case of TLS there are probably sub-protocols\n\t  such as IMAPS that can be otherwise detected\n\t*/\n\tu_int16_t sport = ntohs(packet->tcp->source);\n\tu_int16_t dport = ntohs(packet->tcp->dest);\n\n\tif((sport == 465) || (dport == 465) || (sport == 587) || (dport == 587))\n\t  protocol = NDPI_PROTOCOL_MAIL_SMTPS;\n\telse if((sport == 993) || (dport == 993)\n\t\t|| (flow->l4.tcp.mail_imap_starttls)\n\t\t) protocol = NDPI_PROTOCOL_MAIL_IMAPS;\n\telse if((sport == 995) || (dport == 995)) protocol = NDPI_PROTOCOL_MAIL_POPS;\n      }\n      break;\n    }\n  }\n\n  return(protocol);\n}\n\n/* **************************************** */\n\nvoid ndpi_search_tls_tcp_memory(struct ndpi_detection_module_struct *ndpi_struct,\n\t\t\t\tstruct ndpi_flow_struct *flow) {\n  struct ndpi_packet_struct *packet = &flow->packet;\n  u_int avail_bytes;\n\n  /* TCP */\n#ifdef DEBUG_TLS_MEMORY\n  printf(\"[TLS Mem] Handling TCP/TLS flow [payload_len: %u][buffer_len: %u][direction: %u]\\n\",\n\t packet->payload_packet_len,\n\t flow->l4.tcp.tls.message.buffer_len,\n\t packet->packet_direction);\n#endif\n\n  if(flow->l4.tcp.tls.message.buffer == NULL) {\n    /* Allocate buffer */\n    flow->l4.tcp.tls.message.buffer_len = 2048, flow->l4.tcp.tls.message.buffer_used = 0;\n    flow->l4.tcp.tls.message.buffer = (u_int8_t*)ndpi_malloc(flow->l4.tcp.tls.message.buffer_len);\n\n    if(flow->l4.tcp.tls.message.buffer == NULL)\n      return;\n\n#ifdef DEBUG_TLS_MEMORY\n    printf(\"[TLS Mem] Allocating %u buffer\\n\", flow->l4.tcp.tls.message.buffer_len);\n#endif\n  }\n\n  avail_bytes = flow->l4.tcp.tls.message.buffer_len - flow->l4.tcp.tls.message.buffer_used;\n\n  if(avail_bytes < packet->payload_packet_len) {\n    u_int new_len = flow->l4.tcp.tls.message.buffer_len + packet->payload_packet_len - avail_bytes + 1;\n    void *newbuf  = ndpi_realloc(flow->l4.tcp.tls.message.buffer,\n\t\t\t\t flow->l4.tcp.tls.message.buffer_len, new_len);\n    if(!newbuf) return;\n\n#ifdef DEBUG_TLS_MEMORY\n    printf(\"[TLS Mem] Enlarging %u -> %u buffer\\n\", flow->l4.tcp.tls.message.buffer_len, new_len);\n#endif\n\n    flow->l4.tcp.tls.message.buffer = (u_int8_t*)newbuf;\n    flow->l4.tcp.tls.message.buffer_len = new_len;\n    avail_bytes = flow->l4.tcp.tls.message.buffer_len - flow->l4.tcp.tls.message.buffer_used;\n  }\n\n  if(packet->payload_packet_len > 0 && avail_bytes >= packet->payload_packet_len) {\n    u_int8_t ok = 0;\n\n    if(flow->l4.tcp.tls.message.next_seq[packet->packet_direction] != 0) {\n      if(ntohl(packet->tcp->seq) == flow->l4.tcp.tls.message.next_seq[packet->packet_direction])\n\tok = 1;\n    } else\n      ok = 1;\n\n    if(ok) {\n      memcpy(&flow->l4.tcp.tls.message.buffer[flow->l4.tcp.tls.message.buffer_used],\n\t     packet->payload, packet->payload_packet_len);\n\n      flow->l4.tcp.tls.message.buffer_used += packet->payload_packet_len;\n#ifdef DEBUG_TLS_MEMORY\n      printf(\"[TLS Mem] Copied data to buffer [%u/%u bytes][direction: %u][tcp_seq: %u][next: %u]\\n\",\n\t     flow->l4.tcp.tls.message.buffer_used, flow->l4.tcp.tls.message.buffer_len,\n\t     packet->packet_direction,\n\t     ntohl(packet->tcp->seq),\n\t     ntohl(packet->tcp->seq)+packet->payload_packet_len);\n#endif\n\n      flow->l4.tcp.tls.message.next_seq[packet->packet_direction] = ntohl(packet->tcp->seq)+packet->payload_packet_len;\n    } else {\n#ifdef DEBUG_TLS_MEMORY\n      printf(\"[TLS Mem] Skipping packet [%u bytes][direction: %u][tcp_seq: %u][expected next: %u]\\n\",\n\t     flow->l4.tcp.tls.message.buffer_len,\n\t     packet->packet_direction,\n\t     ntohl(packet->tcp->seq),\n\t     ntohl(packet->tcp->seq)+packet->payload_packet_len);\n#endif\n    }\n  }\n}\n\n/* **************************************** */\n\n/* Can't call libc functions from kernel space, define some stub instead */\n\n#define ndpi_isalpha(ch) (((ch) >= 'a' && (ch) <= 'z') || ((ch) >= 'A' && (ch) <= 'Z'))\n#define ndpi_isdigit(ch) ((ch) >= '0' && (ch) <= '9')\n#define ndpi_isspace(ch) (((ch) >= '\\t' && (ch) <= '\\r') || ((ch) == ' '))\n#define ndpi_isprint(ch) ((ch) >= 0x20 && (ch) <= 0x7e)\n#define ndpi_ispunct(ch) (((ch) >= '!' && (ch) <= '/') ||\t\\\n\t\t\t  ((ch) >= ':' && (ch) <= '@') ||\t\\\n\t\t\t  ((ch) >= '[' && (ch) <= '`') ||\t\\\n\t\t\t  ((ch) >= '{' && (ch) <= '~'))\n\n/* **************************************** */\n\nstatic void cleanupServerName(char *buffer, int buffer_len) {\n  u_int i;\n\n  /* Now all lowecase */\n  for(i=0; i<buffer_len; i++)\n    buffer[i] = tolower(buffer[i]);\n}\n\n/* **************************************** */\n\n/*\n  Return code\n  -1: error (buffer too short)\n   0: OK but buffer is not human readeable (so something went wrong)\n   1: OK\n */\nstatic int extractRDNSequence(struct ndpi_packet_struct *packet,\n\t\t\t      u_int offset, char *buffer, u_int buffer_len,\n\t\t\t      char *rdnSeqBuf, u_int *rdnSeqBuf_offset,\n\t\t\t      u_int rdnSeqBuf_len,\n\t\t\t      const char *label) {\n  u_int8_t str_len = packet->payload[offset+4], is_printable = 1;\n  char *str;\n  u_int len, j;\n\n  if (*rdnSeqBuf_offset >= rdnSeqBuf_len) {\n#ifdef DEBUG_TLS\n    printf(\"[TLS] %s() [buffer capacity reached][%u]\\n\",\n           __FUNCTION__, rdnSeqBuf_len);\n#endif\n    return -1;\n  }\n\n  // packet is truncated... further inspection is not needed\n  if((offset+4+str_len) >= packet->payload_packet_len)\n    return(-1);\n\n  str = (char*)&packet->payload[offset+5];\n\n  len = (u_int)ndpi_min(str_len, buffer_len-1);\n  strncpy(buffer, str, len);\n  buffer[len] = '\\0';\n\n  // check string is printable\n  for(j = 0; j < len; j++) {\n    if(!ndpi_isprint(buffer[j])) {\n      is_printable = 0;\n      break;\n    }\n  }\n\n  if(is_printable) {\n    int rc = snprintf(&rdnSeqBuf[*rdnSeqBuf_offset],\n\t\t      rdnSeqBuf_len-(*rdnSeqBuf_offset),\n\t\t      \"%s%s=%s\", (*rdnSeqBuf_offset > 0) ? \", \" : \"\",\n\t\t      label, buffer);\n\n    if(rc > 0)\n      (*rdnSeqBuf_offset) += rc;\n  }\n\n  return(is_printable);\n}\n\n/* **************************************** */\n\nstatic void checkTLSSubprotocol(struct ndpi_detection_module_struct *ndpi_struct,\n\t\t\t\tstruct ndpi_flow_struct *flow) {\n  if(flow->detected_protocol_stack[1] == NDPI_PROTOCOL_UNKNOWN) {\n    /* Subprotocol not yet set */\n\n    if(ndpi_struct->tls_cert_cache && flow->packet.iph) {\n      u_int32_t key = flow->packet.iph->daddr + flow->packet.tcp->dest;\n      u_int16_t cached_proto;\n\n      if(ndpi_lru_find_cache(ndpi_struct->tls_cert_cache, key,\n\t\t\t     &cached_proto, 0 /* Don't remove it as it can be used for other connections */)) {\n\tndpi_protocol ret = { NDPI_PROTOCOL_TLS, cached_proto, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED };\n\n\tflow->detected_protocol_stack[0] = cached_proto,\n\tflow->detected_protocol_stack[1] = NDPI_PROTOCOL_TLS;\n\n\tflow->category = ndpi_get_proto_category(ndpi_struct, ret);\n\tndpi_check_subprotocol_risk(flow, cached_proto);\n      }\n    }\n  }\n}\n\n/* **************************************** */\n\n/* See https://blog.catchpoint.com/2017/05/12/dissecting-tls-using-wireshark/ */\nstatic void processCertificateElements(struct ndpi_detection_module_struct *ndpi_struct,\n\t\t\t\t       struct ndpi_flow_struct *flow,\n\t\t\t\t       u_int16_t p_offset, u_int16_t certificate_len) {\n  struct ndpi_packet_struct *packet = &flow->packet;\n  u_int num_found = 0, i;\n  char buffer[64] = { '\\0' }, rdnSeqBuf[2048] = { '\\0' };\n  u_int rdn_len = 0;\n\n#ifdef DEBUG_TLS\n  printf(\"[TLS] %s() [offset: %u][certificate_len: %u]\\n\", __FUNCTION__, p_offset, certificate_len);\n#endif\n\n  /* Check after handshake protocol header (5 bytes) and message header (4 bytes) */\n  for(i = p_offset; i < certificate_len; i++) {\n    /*\n       See https://www.ibm.com/support/knowledgecenter/SSFKSJ_7.5.0/com.ibm.mq.sec.doc/q009860_.htm\n       for X.509 certificate labels\n    */\n    if((packet->payload[i] == 0x55) && (packet->payload[i+1] == 0x04) && (packet->payload[i+2] == 0x03)) {\n      /* Common Name */\n      int rc = extractRDNSequence(packet, i, buffer, sizeof(buffer), rdnSeqBuf, &rdn_len, sizeof(rdnSeqBuf), \"CN\");\n      if(rc == -1) break;\n\n#ifdef DEBUG_TLS\n      printf(\"[TLS] %s() [%s][%s: %s]\\n\", __FUNCTION__, (num_found == 0) ? \"Subject\" : \"Issuer\", \"Common Name\", buffer);\n#endif\n    } else if((packet->payload[i] == 0x55) && (packet->payload[i+1] == 0x04) && (packet->payload[i+2] == 0x06)) {\n      /* Country */\n      int rc = extractRDNSequence(packet, i, buffer, sizeof(buffer), rdnSeqBuf, &rdn_len, sizeof(rdnSeqBuf), \"C\");\n      if(rc == -1) break;\n\n#ifdef DEBUG_TLS\n      printf(\"[TLS] %s() [%s][%s: %s]\\n\", __FUNCTION__, (num_found == 0) ? \"Subject\" : \"Issuer\", \"Country\", buffer);\n#endif\n    } else if((packet->payload[i] == 0x55) && (packet->payload[i+1] == 0x04) && (packet->payload[i+2] == 0x07)) {\n      /* Locality */\n      int rc = extractRDNSequence(packet, i, buffer, sizeof(buffer), rdnSeqBuf, &rdn_len, sizeof(rdnSeqBuf), \"L\");\n      if(rc == -1) break;\n\n#ifdef DEBUG_TLS\n      printf(\"[TLS] %s() [%s][%s: %s]\\n\", __FUNCTION__, (num_found == 0) ? \"Subject\" : \"Issuer\", \"Locality\", buffer);\n#endif\n    } else if((packet->payload[i] == 0x55) && (packet->payload[i+1] == 0x04) && (packet->payload[i+2] == 0x08)) {\n      /* State or Province */\n      int rc = extractRDNSequence(packet, i, buffer, sizeof(buffer), rdnSeqBuf, &rdn_len, sizeof(rdnSeqBuf), \"ST\");\n      if(rc == -1) break;\n\n#ifdef DEBUG_TLS\n      printf(\"[TLS] %s() [%s][%s: %s]\\n\", __FUNCTION__, (num_found == 0) ? \"Subject\" : \"Issuer\", \"State or Province\", buffer);\n#endif\n    } else if((packet->payload[i] == 0x55) && (packet->payload[i+1] == 0x04) && (packet->payload[i+2] == 0x0a)) {\n      /* Organization Name */\n      int rc = extractRDNSequence(packet, i, buffer, sizeof(buffer), rdnSeqBuf, &rdn_len, sizeof(rdnSeqBuf), \"O\");\n      if(rc == -1) break;\n\n#ifdef DEBUG_TLS\n      printf(\"[TLS] %s() [%s][%s: %s]\\n\", __FUNCTION__, (num_found == 0) ? \"Subject\" : \"Issuer\", \"Organization Name\", buffer);\n#endif\n\n    } else if((packet->payload[i] == 0x55) && (packet->payload[i+1] == 0x04) && (packet->payload[i+2] == 0x0b)) {\n      /* Organization Unit */\n      int rc = extractRDNSequence(packet, i, buffer, sizeof(buffer), rdnSeqBuf, &rdn_len, sizeof(rdnSeqBuf), \"OU\");\n      if(rc == -1) break;\n\n#ifdef DEBUG_TLS\n      printf(\"[TLS] %s() [%s][%s: %s]\\n\", __FUNCTION__, (num_found == 0) ? \"Subject\" : \"Issuer\", \"Organization Unit\", buffer);\n#endif\n    } else if((packet->payload[i] == 0x30) && (packet->payload[i+1] == 0x1e) && (packet->payload[i+2] == 0x17)) {\n      /* Certificate Validity */\n      u_int8_t len = packet->payload[i+3];\n      u_int offset = i+4;\n\n      if(num_found == 0) {\n\tnum_found++;\n\n#ifdef DEBUG_TLS\n\tprintf(\"[TLS] %s() IssuerDN [%s]\\n\", __FUNCTION__, rdnSeqBuf);\n#endif\n\n\tif(rdn_len && (flow->protos.tls_quic_stun.tls_quic.issuerDN == NULL))\n\t  flow->protos.tls_quic_stun.tls_quic.issuerDN = ndpi_strdup(rdnSeqBuf);\n\n\trdn_len = 0; /* Reset buffer */\n      }\n\n      if((offset+len) < packet->payload_packet_len) {\n\tchar utcDate[32];\n\n#ifdef DEBUG_TLS\n\tu_int j;\n\n\tprintf(\"[CERTIFICATE] notBefore [len: %u][\", len);\n\tfor(j=0; j<len; j++) printf(\"%c\", packet->payload[i+4+j]);\n\tprintf(\"]\\n\");\n#endif\n\n\tif(len < (sizeof(utcDate)-1)) {\n\t  struct tm utc;\n\t  utc.tm_isdst = -1; /* Not set by strptime */\n\n\t  strncpy(utcDate, (const char*)&packet->payload[i+4], len);\n\t  utcDate[len] = '\\0';\n\n\t  /* 141021000000Z */\n\t  if(strptime(utcDate, \"%y%m%d%H%M%SZ\", &utc) != NULL) {\n\t    flow->protos.tls_quic_stun.tls_quic.notBefore = timegm(&utc);\n#ifdef DEBUG_TLS\n\t    printf(\"[CERTIFICATE] notBefore %u [%s]\\n\",\n\t\t   flow->protos.tls_quic_stun.tls_quic.notBefore, utcDate);\n#endif\n\t  }\n\t}\n\n\toffset += len;\n\n\tif((offset+1) < packet->payload_packet_len) {\n\t  len = packet->payload[offset+1];\n\n\t  offset += 2;\n\n\t  if((offset+len) < packet->payload_packet_len) {\n\t    u_int32_t time_sec = flow->packet.current_time_ms / 1000;\n#ifdef DEBUG_TLS\n\t    u_int j;\n\n\t    printf(\"[CERTIFICATE] notAfter [len: %u][\", len);\n\t    for(j=0; j<len; j++) printf(\"%c\", packet->payload[offset+j]);\n\t    printf(\"]\\n\");\n#endif\n\n\t    if(len < (sizeof(utcDate)-1)) {\n\t      struct tm utc;\n\t      utc.tm_isdst = -1; /* Not set by strptime */\n\n\t      strncpy(utcDate, (const char*)&packet->payload[offset], len);\n\t      utcDate[len] = '\\0';\n\n\t      /* 141021000000Z */\n\t      if(strptime(utcDate, \"%y%m%d%H%M%SZ\", &utc) != NULL) {\n\t\tflow->protos.tls_quic_stun.tls_quic.notAfter = timegm(&utc);\n#ifdef DEBUG_TLS\n\t\tprintf(\"[CERTIFICATE] notAfter %u [%s]\\n\",\n\t\t       flow->protos.tls_quic_stun.tls_quic.notAfter, utcDate);\n#endif\n\t      }\n\t    }\n\n\n\t    if((time_sec < flow->protos.tls_quic_stun.tls_quic.notBefore)\n\t       || (time_sec > flow->protos.tls_quic_stun.tls_quic.notAfter))\n\t    ndpi_set_risk(flow, NDPI_TLS_CERTIFICATE_EXPIRED); /* Certificate expired */\n\t  }\n\t}\n      }\n    } else if((packet->payload[i] == 0x55) && (packet->payload[i+1] == 0x1d) && (packet->payload[i+2] == 0x11)) {\n      /* Organization OID: 2.5.29.17 (subjectAltName) */\n      u_int8_t matched_name = 0;\n\n#ifdef DEBUG_TLS\n      printf(\"******* [TLS] Found subjectAltName\\n\");\n#endif\n\n      i += 3 /* skip the initial patten 55 1D 11 */;\n      i++; /* skip the first type, 0x04 == BIT STRING, and jump to it's length */\n      if(i < packet->payload_packet_len) {\n\ti += (packet->payload[i] & 0x80) ? (packet->payload[i] & 0x7F) : 0; /* skip BIT STRING length */\n\tif(i < packet->payload_packet_len) {\n\t  i += 2; /* skip the second type, 0x30 == SEQUENCE, and jump to it's length */\n\t  if(i < packet->payload_packet_len) {\n\t    i += (packet->payload[i] & 0x80) ? (packet->payload[i] & 0x7F) : 0; /* skip SEQUENCE length */\n\t    i++;\n\n\t    while(i < packet->payload_packet_len) {\n\t      if(packet->payload[i] == 0x82) {\n\t\tif((i < (packet->payload_packet_len - 1))\n\t\t   && ((i + packet->payload[i + 1] + 2) < packet->payload_packet_len)) {\n\t\t  u_int8_t len = packet->payload[i + 1];\n\t\t  char dNSName[256];\n\n\t\t  i += 2;\n\n\t\t  /* The check \"len > sizeof(dNSName) - 1\" will be always false. If we add it,\n\t\t     the compiler is smart enough to detect it and throws a warning */\n\t\t  if((len == 0 /* Looks something went wrong */)\n\t\t     || ((i+len) >  packet->payload_packet_len))\n\t\t    break;\n\n\t\t  strncpy(dNSName, (const char*)&packet->payload[i], len);\n\t\t  dNSName[len] = '\\0';\n\n\t\t  cleanupServerName(dNSName, len);\n\n#if DEBUG_TLS\n\t\t  printf(\"[TLS] dNSName %s [%s][len: %u][leftover: %d]\\n\", dNSName,\n\t\t\t flow->protos.tls_quic_stun.tls_quic.client_requested_server_name, len,\n\t\t\t packet->payload_packet_len-i-len);\n#endif\n\t\t  if(matched_name == 0) {\n\t\t    if(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name[0] == '\\0')\n\t\t      matched_name = 1;\t/* No SNI */\n\t\t    else if (dNSName[0] == '*')\n\t\t    {\n\t\t      char * label = strstr(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name, &dNSName[1]);\n\n\t\t      if (label != NULL)\n\t\t      {\n\t\t        char * first_dot = strchr(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name, '.');\n\n\t\t        if (first_dot == NULL || first_dot >= label)\n\t\t        {\n\t\t          matched_name = 1;\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t    else if(strcmp(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name, dNSName) == 0)\n\t\t      matched_name = 1;\n\t\t  }\n\n\t\t  if(flow->protos.tls_quic_stun.tls_quic.server_names == NULL)\n\t\t    flow->protos.tls_quic_stun.tls_quic.server_names = ndpi_strdup(dNSName),\n\t\t      flow->protos.tls_quic_stun.tls_quic.server_names_len = strlen(dNSName);\n\t\t  else {\n\t\t    u_int16_t dNSName_len = strlen(dNSName);\n\t\t    u_int16_t newstr_len = flow->protos.tls_quic_stun.tls_quic.server_names_len + dNSName_len + 1;\n\t\t    char *newstr = (char*)ndpi_realloc(flow->protos.tls_quic_stun.tls_quic.server_names,\n\t\t\t\t\t\t       flow->protos.tls_quic_stun.tls_quic.server_names_len+1, newstr_len+1);\n\n\t\t    if(newstr) {\n\t\t      flow->protos.tls_quic_stun.tls_quic.server_names = newstr;\n\t\t      flow->protos.tls_quic_stun.tls_quic.server_names[flow->protos.tls_quic_stun.tls_quic.server_names_len] = ',';\n\t\t      strncpy(&flow->protos.tls_quic_stun.tls_quic.server_names[flow->protos.tls_quic_stun.tls_quic.server_names_len+1],\n\t\t\t      dNSName, dNSName_len+1);\n\t\t      flow->protos.tls_quic_stun.tls_quic.server_names[newstr_len] = '\\0';\n\t\t      flow->protos.tls_quic_stun.tls_quic.server_names_len = newstr_len;\n\t\t    }\n\t\t  }\n\n\t\t  if(!flow->l4.tcp.tls.subprotocol_detected)\n\t\t    if(ndpi_match_hostname_protocol(ndpi_struct, flow, NDPI_PROTOCOL_TLS, dNSName, len))\n\t\t      flow->l4.tcp.tls.subprotocol_detected = 1;\n\n\t\t  i += len;\n\t\t} else {\n#if DEBUG_TLS\n\t\t  printf(\"[TLS] Leftover %u bytes\", packet->payload_packet_len - i);\n#endif\n\t\t  break;\n\t\t}\n\t      } else {\n\t\tbreak;\n\t      }\n\t    } /* while */\n\n\t    if(!matched_name)\n\t      ndpi_set_risk(flow, NDPI_TLS_CERTIFICATE_MISMATCH); /* Certificate mismatch */\n\t  }\n\t}\n      }\n    }\n  }\n\n  if(rdn_len && (flow->protos.tls_quic_stun.tls_quic.subjectDN == NULL)) {\n    flow->protos.tls_quic_stun.tls_quic.subjectDN = ndpi_strdup(rdnSeqBuf);\n\n    if(flow->detected_protocol_stack[1] == NDPI_PROTOCOL_UNKNOWN) {\n      /* No idea what is happening behind the scenes: let's check the certificate */\n      u_int32_t proto_id;\n      int rc = ndpi_match_string_value(ndpi_struct->tls_cert_subject_automa.ac_automa,\n\t\t\t\t       rdnSeqBuf, strlen(rdnSeqBuf),&proto_id);\n\n      if(rc == 0) {\n\t/* Match found */\n\tndpi_protocol ret = { NDPI_PROTOCOL_TLS, proto_id, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED};\n\n\tflow->detected_protocol_stack[0] = proto_id,\n\t  flow->detected_protocol_stack[1] = NDPI_PROTOCOL_TLS;\n\n\tflow->category = ndpi_get_proto_category(ndpi_struct, ret);\n\tndpi_check_subprotocol_risk(flow, proto_id);\n\n\tif(ndpi_struct->tls_cert_cache == NULL)\n\t  ndpi_struct->tls_cert_cache = ndpi_lru_cache_init(1024);\n\n\tif(ndpi_struct->tls_cert_cache && flow->packet.iph) {\n\t  u_int32_t key = flow->packet.iph->daddr + flow->packet.tcp->dest;\n\n\t  ndpi_lru_add_to_cache(ndpi_struct->tls_cert_cache, key, proto_id);\n\t}\n      }\n    }\n  }\n\n  if(flow->protos.tls_quic_stun.tls_quic.subjectDN && flow->protos.tls_quic_stun.tls_quic.issuerDN\n     && (!strcmp(flow->protos.tls_quic_stun.tls_quic.subjectDN, flow->protos.tls_quic_stun.tls_quic.issuerDN)))\n    ndpi_set_risk(flow, NDPI_TLS_SELFSIGNED_CERTIFICATE);\n\n#if DEBUG_TLS\n  printf(\"[TLS] %s() SubjectDN [%s]\\n\", __FUNCTION__, rdnSeqBuf);\n#endif\n}\n\n/* **************************************** */\n\n/* See https://blog.catchpoint.com/2017/05/12/dissecting-tls-using-wireshark/ */\nint processCertificate(struct ndpi_detection_module_struct *ndpi_struct,\n\t\t       struct ndpi_flow_struct *flow) {\n  struct ndpi_packet_struct *packet = &flow->packet;\n  int is_dtls = packet->udp ? 1 : 0;\n  u_int32_t certificates_length, length = (packet->payload[1] << 16) + (packet->payload[2] << 8) + packet->payload[3];\n  u_int32_t certificates_offset = 7 + (is_dtls ? 8 : 0);\n  u_int8_t num_certificates_found = 0;\n  SHA1_CTX srv_cert_fingerprint_ctx ;\n\n#ifdef DEBUG_TLS\n  printf(\"[TLS] %s() [payload_packet_len=%u][direction: %u][%02X %02X %02X %02X %02X %02X...]\\n\",\n\t __FUNCTION__, packet->payload_packet_len,\n\t packet->packet_direction,\n\t packet->payload[0], packet->payload[1], packet->payload[2],\n\t packet->payload[3], packet->payload[4], packet->payload[5]);\n#endif\n\n  if((packet->payload_packet_len != (length + 4 + (is_dtls ? 8 : 0))) || (packet->payload[1] != 0x0)) {\n    ndpi_set_risk(flow, NDPI_MALFORMED_PACKET);\n    return(-1); /* Invalid length */\n  }\n\n  certificates_length = (packet->payload[certificates_offset - 3] << 16) +\n                        (packet->payload[certificates_offset - 2] << 8) +\n                        packet->payload[certificates_offset - 1];\n\n  if((packet->payload[certificates_offset - 3] != 0x0) || ((certificates_length+3) != length)) {\n    ndpi_set_risk(flow, NDPI_MALFORMED_PACKET);\n    return(-2); /* Invalid length */\n  }\n\n  /* Now let's process each individual certificates */\n  while(certificates_offset < certificates_length) {\n    u_int32_t certificate_len = (packet->payload[certificates_offset] << 16) + (packet->payload[certificates_offset+1] << 8) + packet->payload[certificates_offset+2];\n\n    /* Invalid lenght */\n    if((certificate_len == 0)\n       || (packet->payload[certificates_offset] != 0x0)\n       || ((certificates_offset+certificate_len) > (4+certificates_length+(is_dtls ? 8 : 0)))) {\n#ifdef DEBUG_TLS\n      printf(\"[TLS] Invalid length [certificate_len: %u][certificates_offset: %u][%u vs %u]\\n\",\n\t     certificate_len, certificates_offset,\n\t     (certificates_offset+certificate_len),\n\t     certificates_length);\n#endif\n      break;\n    }\n\n    certificates_offset += 3;\n#ifdef DEBUG_TLS\n    printf(\"[TLS] Processing %u bytes certificate [%02X %02X %02X]\\n\",\n\t   certificate_len,\n\t   packet->payload[certificates_offset],\n\t   packet->payload[certificates_offset+1],\n\t   packet->payload[certificates_offset+2]);\n#endif\n\n    if(num_certificates_found++ == 0) /* Dissect only the first certificate that is the one we care */ {\n      /* For SHA-1 we take into account only the first certificate and not all of them */\n\n      SHA1Init(&srv_cert_fingerprint_ctx);\n\n#ifdef DEBUG_CERTIFICATE_HASH\n      {\n\tint i;\n\n\tfor(i=0;i<certificate_len;i++)\n\t  printf(\"%02X \", packet->payload[certificates_offset+i]);\n\n\tprintf(\"\\n\");\n      }\n#endif\n\n      SHA1Update(&srv_cert_fingerprint_ctx,\n\t\t &packet->payload[certificates_offset],\n\t\t certificate_len);\n\n      SHA1Final(flow->protos.tls_quic_stun.tls_quic.sha1_certificate_fingerprint, &srv_cert_fingerprint_ctx);\n\n      flow->l4.tcp.tls.fingerprint_set = 1;\n\n      uint8_t * sha1 = flow->protos.tls_quic_stun.tls_quic.sha1_certificate_fingerprint;\n      const size_t sha1_siz = sizeof(flow->protos.tls_quic_stun.tls_quic.sha1_certificate_fingerprint);\n      char sha1_str[20 /* sha1_siz */ * 2 + 1];\n      static const char hexalnum[] = \"0123456789ABCDEF\";\n      for (size_t i = 0; i < sha1_siz; ++i) {\n        u_int8_t lower = (sha1[i] & 0x0F);\n        u_int8_t upper = (sha1[i] & 0xF0) >> 4;\n        sha1_str[i*2] = hexalnum[upper];\n        sha1_str[i*2 + 1] = hexalnum[lower];\n      }\n      sha1_str[sha1_siz * 2] = '\\0';\n\n#ifdef DEBUG_TLS\n      printf(\"[TLS] SHA-1: %s\\n\", sha1_str);\n#endif\n\n      if (ndpi_struct->malicious_sha1_automa.ac_automa != NULL) {\n        u_int16_t rc1 = ndpi_match_string(ndpi_struct->malicious_sha1_automa.ac_automa, sha1_str);\n\n        if(rc1 > 0)\n          ndpi_set_risk(flow, NDPI_MALICIOUS_SHA1_CERTIFICATE);\n      }\n\n      processCertificateElements(ndpi_struct, flow, certificates_offset, certificate_len);\n    }\n\n    certificates_offset += certificate_len;\n  }\n\n  if((ndpi_struct->num_tls_blocks_to_follow != 0)\n     && (flow->l4.tcp.tls.num_tls_blocks >= ndpi_struct->num_tls_blocks_to_follow)) {\n#ifdef DEBUG_TLS_BLOCKS\n    printf(\"*** [TLS Block] Enough blocks dissected\\n\");\n#endif\n\n    flow->extra_packets_func = NULL; /* We're good now */\n  }\n\n  return(1);\n}\n\n/* **************************************** */\n\nstatic int processTLSBlock(struct ndpi_detection_module_struct *ndpi_struct,\n\t\t\t   struct ndpi_flow_struct *flow) {\n  struct ndpi_packet_struct *packet = &flow->packet;\n  int ret;\n\n  switch(packet->payload[0] /* block type */) {\n  case 0x01: /* Client Hello */\n  case 0x02: /* Server Hello */\n    processClientServerHello(ndpi_struct, flow, 0);\n    flow->l4.tcp.tls.hello_processed = 1;\n    ndpi_int_tls_add_connection(ndpi_struct, flow, NDPI_PROTOCOL_TLS);\n\n#ifdef DEBUG_TLS\n    printf(\"*** TLS [version: %02X][%s Hello]\\n\",\n\t   flow->protos.tls_quic_stun.tls_quic.ssl_version,\n\t   (packet->payload[0] == 0x01) ? \"Client\" : \"Server\");\n#endif\n\n    if((flow->protos.tls_quic_stun.tls_quic.ssl_version >= 0x0304 /* TLS 1.3 */)\n       && (packet->payload[0] == 0x02 /* Server Hello */)) {\n      flow->l4.tcp.tls.certificate_processed = 1; /* No Certificate with TLS 1.3+ */\n    }\n\n    checkTLSSubprotocol(ndpi_struct, flow);\n    break;\n\n  case 0x0b: /* Certificate */\n    /* Important: populate the tls union fields only after\n     * ndpi_int_tls_add_connection has been called */\n    if(flow->l4.tcp.tls.hello_processed) {\n      ret = processCertificate(ndpi_struct, flow);\n      if (ret != 1) {\n#ifdef DEBUG_TLS\n        printf(\"[TLS] Error processing certificate: %d\\n\", ret);\n#endif\n      }\n      flow->l4.tcp.tls.certificate_processed = 1;\n    }\n    break;\n\n  default:\n    return(-1);\n  }\n\n  return(0);\n}\n\n/* **************************************** */\n\nstatic void ndpi_looks_like_tls(struct ndpi_detection_module_struct *ndpi_struct,\n\t\t\t\tstruct ndpi_flow_struct *flow) {\n  // ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_TLS, NDPI_PROTOCOL_UNKNOWN);\n\n  if(flow->guessed_protocol_id == NDPI_PROTOCOL_UNKNOWN)\n    flow->guessed_protocol_id = NDPI_PROTOCOL_TLS;\n}\n\n/* **************************************** */\n\nstatic int ndpi_search_tls_tcp(struct ndpi_detection_module_struct *ndpi_struct,\n\t\t\t       struct ndpi_flow_struct *flow) {\n  struct ndpi_packet_struct *packet = &flow->packet;\n  u_int8_t something_went_wrong = 0;\n\n#ifdef DEBUG_TLS_MEMORY\n  printf(\"[TLS Mem] ndpi_search_tls_tcp() Processing new packet [payload_packet_len: %u]\\n\",\n\t packet->payload_packet_len);\n#endif\n\n  if(packet->payload_packet_len == 0)\n    return(1); /* Keep working */\n\n  ndpi_search_tls_tcp_memory(ndpi_struct, flow);\n\n  while(!something_went_wrong) {\n    u_int16_t len, p_len;\n    const u_int8_t *p;\n    u_int8_t content_type;\n\n    if(flow->l4.tcp.tls.message.buffer_used < 5)\n      return(1); /* Keep working */\n\n    len = (flow->l4.tcp.tls.message.buffer[3] << 8) + flow->l4.tcp.tls.message.buffer[4] + 5;\n\n    if(len > flow->l4.tcp.tls.message.buffer_used) {\n#ifdef DEBUG_TLS_MEMORY\n      printf(\"[TLS Mem] Not enough TLS data [%u < %u][%02X %02X %02X %02X %02X]\\n\",\n\t     len, flow->l4.tcp.tls.message.buffer_used,\n\t     flow->l4.tcp.tls.message.buffer[0],\n\t     flow->l4.tcp.tls.message.buffer[1],\n\t     flow->l4.tcp.tls.message.buffer[2],\n\t     flow->l4.tcp.tls.message.buffer[3],\n\t     flow->l4.tcp.tls.message.buffer[4]);\n#endif\n      break;\n    }\n\n    if(len == 0) {\n      something_went_wrong = 1;\n      break;\n    }\n\n#ifdef DEBUG_TLS_MEMORY\n    printf(\"[TLS Mem] Processing %u bytes message\\n\", len);\n#endif\n\n    content_type = flow->l4.tcp.tls.message.buffer[0];\n\n    /* Overwriting packet payload */\n    p = packet->payload;\n    p_len = packet->payload_packet_len; /* Backup */\n\n    if(content_type == 0x14 /* Change Cipher Spec */) {\n      if(ndpi_struct->skip_tls_blocks_until_change_cipher) {\n\t/*\n\t  Ignore Application Data up until change cipher\n\t  so in this case we reset the number of observed\n\t  TLS blocks\n\t*/\n\tflow->l4.tcp.tls.num_tls_blocks = 0;\n      }\n    }\n\n    if((len > 9)\n       && (content_type != 0x17 /* Application Data */)\n       && (!flow->l4.tcp.tls.certificate_processed)) {\n      /* Split the element in blocks */\n      u_int16_t processed = 5;\n\n      while((processed+4) <= len) {\n\tconst u_int8_t *block = (const u_int8_t *)&flow->l4.tcp.tls.message.buffer[processed];\n\tu_int32_t block_len   = (block[1] << 16) + (block[2] << 8) + block[3];\n\n\tif(/* (block_len == 0) || */ /* Note blocks can have zero lenght */\n\t   (block_len > len) || ((block[1] != 0x0))) {\n\t  something_went_wrong = 1;\n\t  break;\n\t}\n\n\tpacket->payload = block;\n\tpacket->payload_packet_len = ndpi_min(block_len+4, flow->l4.tcp.tls.message.buffer_used);\n\n\tif((processed+packet->payload_packet_len) > len) {\n\t  something_went_wrong = 1;\n\t  break;\n\t}\n\n\tprocessTLSBlock(ndpi_struct, flow);\n\tndpi_looks_like_tls(ndpi_struct, flow);\n\n\tprocessed += packet->payload_packet_len;\n      }\n    } else {\n      /* Process element as a whole */\n      if(content_type == 0x17 /* Application Data */) {\n\tndpi_looks_like_tls(ndpi_struct, flow);\n\n\tif(flow->l4.tcp.tls.certificate_processed) {\n\t  if(flow->l4.tcp.tls.num_tls_blocks < ndpi_struct->num_tls_blocks_to_follow)\n\t    flow->l4.tcp.tls.tls_application_blocks_len[flow->l4.tcp.tls.num_tls_blocks++] =\n\t      (packet->packet_direction == 0) ? (len-5) : -(len-5);\n\n#ifdef DEBUG_TLS_BLOCKS\n\t  printf(\"*** [TLS Block] [len: %u][num_tls_blocks: %u/%u]\\n\",\n\t\t len-5, flow->l4.tcp.tls.num_tls_blocks, ndpi_struct->num_tls_blocks_to_follow);\n#endif\n\t}\n      }\n    }\n\n    packet->payload = p;\n    packet->payload_packet_len = p_len; /* Restore */\n    flow->l4.tcp.tls.message.buffer_used -= len;\n\n    if(flow->l4.tcp.tls.message.buffer_used > 0)\n      memmove(flow->l4.tcp.tls.message.buffer,\n\t      &flow->l4.tcp.tls.message.buffer[len],\n\t      flow->l4.tcp.tls.message.buffer_used);\n    else\n      break;\n\n#ifdef DEBUG_TLS_MEMORY\n    printf(\"[TLS Mem] Left memory buffer %u bytes\\n\", flow->l4.tcp.tls.message.buffer_used);\n#endif\n  }\n\n  if(something_went_wrong\n     || ((ndpi_struct->num_tls_blocks_to_follow > 0)\n\t && (flow->l4.tcp.tls.num_tls_blocks == ndpi_struct->num_tls_blocks_to_follow))\n     ) {\n#ifdef DEBUG_TLS_BLOCKS\n    printf(\"*** [TLS Block] No more blocks\\n\");\n#endif\n    flow->check_extra_packets = 0;\n    flow->extra_packets_func = NULL;\n    return(0); /* That's all */\n  } else\n    return(1);\n}\n\n/* **************************************** */\n\nstatic int ndpi_search_tls_udp(struct ndpi_detection_module_struct *ndpi_struct,\n\t\t\t       struct ndpi_flow_struct *flow) {\n  struct ndpi_packet_struct *packet = &flow->packet;\n  u_int32_t handshake_len;\n  u_int16_t p_len, processed;\n  const u_int8_t *p;\n  u_int8_t no_dtls = 0, change_cipher_found = 0;\n\n#ifdef DEBUG_TLS\n  printf(\"[TLS] %s()\\n\", __FUNCTION__);\n#endif\n\n  /* Overwriting packet payload */\n  p = packet->payload, p_len = packet->payload_packet_len; /* Backup */\n\n  /* Split the element in blocks */\n  processed = 0;\n  while(processed + 13 < p_len) {\n    u_int32_t block_len;\n    const u_int8_t *block = (const u_int8_t *)&p[processed];\n\n    if((block[0] != 0x16 && block[0] != 0x14) || /* Handshake, change-cipher-spec */\n       (block[1] != 0xfe) || /* We ignore old DTLS versions */\n       ((block[2] != 0xff) && (block[2] != 0xfd))) {\n#ifdef DEBUG_TLS\n      printf(\"[TLS] DTLS invalid block 0x%x or old version 0x%x-0x%x-0x%x\\n\",\n             block[0], block[1], block[2], block[3]);\n#endif\n      no_dtls = 1;\n      break;\n    }\n    block_len = ntohs(*((u_int16_t*)&block[11]));\n#ifdef DEBUG_TLS\n    printf(\"[TLS] DTLS block len: %d\\n\", block_len);\n#endif\n    if (block_len == 0 || (processed + block_len + 12 >= p_len)) {\n#ifdef DEBUG_TLS\n      printf(\"[TLS] DTLS invalid block len %d (processed %d, p_len %d)\\n\",\n             block_len, processed, p_len);\n#endif\n      no_dtls = 1;\n      break;\n    }\n    /* We process only handshake msgs */\n    if(block[0] == 0x16) {\n      if (processed + block_len + 13 > p_len) {\n#ifdef DEBUG_TLS\n        printf(\"[TLS] DTLS invalid len %d %d %d\\n\", processed, block_len, p_len);\n#endif\n        no_dtls = 1;\n        break;\n     }\n      /* TODO: handle (certificate) fragments */\n      handshake_len = (block[14] << 16) + (block[15] << 8) + block[16];\n      if((handshake_len + 12) != block_len) {\n#ifdef DEBUG_TLS\n        printf(\"[TLS] DTLS invalid handshake_len %d, %d)\\n\",\n               handshake_len, block_len);\n#endif\n        no_dtls = 1;\n        break;\n      }\n      packet->payload = &block[13];\n      packet->payload_packet_len = block_len;\n      processTLSBlock(ndpi_struct, flow);\n    } else {\n      /* Change-cipher-spec: any subsequent block might be encrypted */\n#ifdef DEBUG_TLS\n      printf(\"[TLS] Change-cipher-spec\\n\");\n#endif\n      change_cipher_found = 1;\n      processed += block_len + 13;\n      break;\n    }\n\n    processed += block_len + 13;\n  }\n  if(processed != p_len) {\n#ifdef DEBUG_TLS\n    printf(\"[TLS] DTLS invalid processed len %d/%d (%d)\\n\", processed, p_len, change_cipher_found);\n#endif\n    if(!change_cipher_found)\n      no_dtls = 1;\n  }\n\n  packet->payload = p;\n  packet->payload_packet_len = p_len; /* Restore */\n\n  if(no_dtls || change_cipher_found) {\n    NDPI_EXCLUDE_PROTO(ndpi_struct, flow);\n    return(0); /* That's all */\n  } else {\n    return(1); /* Keep working */\n  }\n}\n\n/* **************************************** */\n\nstatic void tlsInitExtraPacketProcessing(struct ndpi_detection_module_struct *ndpi_struct,\n\t\t\t\t\t struct ndpi_flow_struct *flow) {\n  flow->check_extra_packets = 1;\n\n  /* At most 12 packets should almost always be enough to find the server certificate if it's there */\n  flow->max_extra_packets_to_check = 12 + (ndpi_struct->num_tls_blocks_to_follow*4);\n  flow->extra_packets_func = (flow->packet.udp != NULL) ? ndpi_search_tls_udp : ndpi_search_tls_tcp;\n}\n\n/* **************************************** */\n\nstatic void tlsCheckUncommonALPN(struct ndpi_flow_struct *flow)\n{\n  /* see: https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml */\n  static char const * const common_alpns[] = {\n    \"http/0.9\", \"http/1.0\", \"http/1.1\",\n    \"spdy/1\", \"spdy/2\", \"spdy/3\", \"spdy/3.1\",\n    \"stun.turn\", \"stun.nat-discovery\",\n    \"h2\", \"h2c\", \"h2-16\", \"h2-15\", \"h2-14\",\n    \"webrtc\", \"c-webrtc\",\n    \"ftp\", \"imap\", \"pop3\", \"managesieve\", \"coap\",\n    \"xmpp-client\", \"xmpp-server\",\n    \"acme-tls/1\",\n    \"mqtt\", \"dot\", \"ntske/1\", \"sunrpc\",\n    \"h3\",\n    \"smb\",\n    \"irc\",\n\n    /* QUIC ALPNs */\n    \"h3-T051\", \"h3-T050\",\n    \"h3-32\", \"h3-30\", \"h3-29\", \"h3-28\", \"h3-27\", \"h3-24\", \"h3-22\",\n    \"hq-30\", \"hq-29\", \"hq-28\", \"hq-27\",\n    \"h3-fb-05\", \"h1q-fb\",\n    \"doq-i00\"\n  };\n\n  /*\n   * If the ALPN list increases in size, iterating over all items for every incoming ALPN may\n   * have a performance impact. A hash map could solve this issue.\n   */\n\n  char * alpn_start = flow->protos.tls_quic_stun.tls_quic.alpn;\n  char * comma_or_nul = alpn_start;\n  do {\n    comma_or_nul = strchr(comma_or_nul, ',');\n    if (comma_or_nul == NULL)\n    {\n      comma_or_nul = alpn_start + strlen(alpn_start);\n    }\n\n    int alpn_found = 0;\n    int alpn_len = comma_or_nul - alpn_start;\n    char const * const alpn = alpn_start;\n    for (size_t i = 0; i < sizeof(common_alpns)/sizeof(common_alpns[0]); ++i)\n    {\n      if (strlen(common_alpns[i]) == alpn_len &&\n          strncmp(alpn, common_alpns[i], alpn_len) == 0)\n      {\n        alpn_found = 1;\n        break;\n      }\n    }\n\n    if (alpn_found == 0)\n    {\n#ifdef DEBUG_TLS\n      printf(\"TLS uncommon ALPN found: %.*s\\n\", alpn_len, alpn);\n#endif\n      ndpi_set_risk(flow, NDPI_TLS_UNCOMMON_ALPN);\n      break;\n    }\n\n    alpn_start = comma_or_nul + 1;\n  } while (*(comma_or_nul++) != '\\0');\n}\n\n/* **************************************** */\n\nstatic void ndpi_int_tls_add_connection(struct ndpi_detection_module_struct *ndpi_struct,\n\t\t\t\t\tstruct ndpi_flow_struct *flow, u_int32_t protocol) {\n#if DEBUG_TLS\n  printf(\"[TLS] %s()\\n\", __FUNCTION__);\n#endif\n\n  if((flow->packet.udp != NULL) && (protocol == NDPI_PROTOCOL_TLS))\n    protocol = NDPI_PROTOCOL_DTLS;\n\n  if((flow->detected_protocol_stack[0] == protocol)\n     || (flow->detected_protocol_stack[1] == protocol)) {\n    if(!flow->check_extra_packets)\n      tlsInitExtraPacketProcessing(ndpi_struct, flow);\n    return;\n  }\n\n  if(protocol != NDPI_PROTOCOL_TLS)\n    ;\n  else\n    protocol = ndpi_tls_refine_master_protocol(ndpi_struct, flow, protocol);\n\n  ndpi_set_detected_protocol(ndpi_struct, flow, protocol, protocol);\n\n  tlsInitExtraPacketProcessing(ndpi_struct, flow);\n}\n\n/* **************************************** */\n\nint processClientServerHello(struct ndpi_detection_module_struct *ndpi_struct,\n\t\t\t     struct ndpi_flow_struct *flow, uint32_t quic_version) {\n  struct ndpi_packet_struct *packet = &flow->packet;\n  union ja3_info ja3;\n  u_int8_t invalid_ja3 = 0;\n  u_int16_t tls_version, ja3_str_len;\n  char ja3_str[JA3_STR_LEN];\n  ndpi_MD5_CTX ctx;\n  u_char md5_hash[16];\n  int i;\n  u_int16_t total_len;\n  u_int8_t handshake_type;\n  char buffer[64] = { '\\0' };\n  int is_quic = (quic_version != 0);\n  int is_dtls = packet->udp && (!is_quic);\n\n#ifdef DEBUG_TLS\n  printf(\"TLS %s() called\\n\", __FUNCTION__);\n#endif\n\n  memset(&ja3, 0, sizeof(ja3));\n\n  handshake_type = packet->payload[0];\n  total_len = (packet->payload[1] << 16) +  (packet->payload[2] << 8) + packet->payload[3];\n\n  if((total_len > packet->payload_packet_len) || (packet->payload[1] != 0x0))\n    return(0); /* Not found */\n\n  total_len = packet->payload_packet_len;\n\n  /* At least \"magic\" 3 bytes, null for string end, otherwise no need to waste cpu cycles */\n  if(total_len > 4) {\n    u_int16_t base_offset    = (!is_dtls) ? 38 : 46;\n    u_int16_t version_offset = (!is_dtls) ? 4 : 12;\n    u_int16_t offset = (!is_dtls) ? 38 : 46, extension_len, j;\n    u_int8_t  session_id_len =  0;\n\n    if((base_offset >= total_len) ||\n       (version_offset + 1) >= total_len)\n      return 0; /* Not found */\n\n    session_id_len = packet->payload[base_offset];\n\n#ifdef DEBUG_TLS\n    printf(\"TLS [len: %u][handshake_type: %02X]\\n\", packet->payload_packet_len, handshake_type);\n#endif\n\n    tls_version = ntohs(*((u_int16_t*)&packet->payload[version_offset]));\n\n    if(handshake_type == 0x02 /* Server Hello */) {\n      int i, rc;\n\n      ja3.server.tls_handshake_version = tls_version;\n\n#ifdef DEBUG_TLS\n      printf(\"TLS Server Hello [version: 0x%04X]\\n\", tls_version);\n#endif\n\n      /*\n\tThe server hello decides about the TLS version of this flow\n\thttps://networkengineering.stackexchange.com/questions/55752/why-does-wireshark-show-version-tls-1-2-here-instead-of-tls-1-3\n      */\n      if(packet->udp)\n\toffset += session_id_len + 1;\n      else {\n\tif(tls_version < 0x7F15 /* TLS 1.3 lacks of session id */)\n\t  offset += session_id_len+1;\n      }\n\n      if((offset+3) > packet->payload_packet_len)\n\treturn(0); /* Not found */\n\n      ja3.server.num_cipher = 1, ja3.server.cipher[0] = ntohs(*((u_int16_t*)&packet->payload[offset]));\n      if((flow->protos.tls_quic_stun.tls_quic.server_unsafe_cipher = ndpi_is_safe_ssl_cipher(ja3.server.cipher[0])) == 1)\n\tndpi_set_risk(flow, NDPI_TLS_WEAK_CIPHER);\n\n      flow->protos.tls_quic_stun.tls_quic.server_cipher = ja3.server.cipher[0];\n\n#ifdef DEBUG_TLS\n      printf(\"TLS [server][session_id_len: %u][cipher: %04X]\\n\", session_id_len, ja3.server.cipher[0]);\n#endif\n\n      offset += 2 + 1;\n\n      if((offset + 1) < packet->payload_packet_len) /* +1 because we are goint to read 2 bytes */\n\textension_len = ntohs(*((u_int16_t*)&packet->payload[offset]));\n      else\n\textension_len = 0;\n\n#ifdef DEBUG_TLS\n      printf(\"TLS [server][extension_len: %u]\\n\", extension_len);\n#endif\n      offset += 2;\n\n      for(i=0; i<extension_len; ) {\n\tu_int16_t extension_id, extension_len;\n\n\tif((offset+4) > packet->payload_packet_len) break;\n\n\textension_id  = ntohs(*((u_int16_t*)&packet->payload[offset]));\n\textension_len = ntohs(*((u_int16_t*)&packet->payload[offset+2]));\n\n\tif(ja3.server.num_tls_extension < MAX_NUM_JA3)\n\t  ja3.server.tls_extension[ja3.server.num_tls_extension++] = extension_id;\n\n#ifdef DEBUG_TLS\n\tprintf(\"TLS [server][extension_id: %u/0x%04X][len: %u]\\n\",\n\t       extension_id, extension_id, extension_len);\n#endif\n\n\tif(extension_id == 43 /* supported versions */) {\n\t  if(extension_len >= 2) {\n\t    u_int16_t tls_version = ntohs(*((u_int16_t*)&packet->payload[offset+4]));\n\n#ifdef DEBUG_TLS\n\t    printf(\"TLS [server] [TLS version: 0x%04X]\\n\", tls_version);\n#endif\n\n\t    flow->protos.tls_quic_stun.tls_quic.ssl_version = ja3.server.tls_supported_version = tls_version;\n\t  }\n\t} else if(extension_id == 16 /* application_layer_protocol_negotiation (ALPN) */) {\n\t  u_int16_t s_offset = offset+4;\n\t  u_int16_t tot_alpn_len = ntohs(*((u_int16_t*)&packet->payload[s_offset]));\n\t  char alpn_str[256];\n\t  u_int8_t alpn_str_len = 0, i;\n\n#ifdef DEBUG_TLS\n\t  printf(\"Server TLS [ALPN: block_len=%u/len=%u]\\n\", extension_len, tot_alpn_len);\n#endif\n\t  s_offset += 2;\n\t  tot_alpn_len += s_offset;\n\n\t  while(s_offset < tot_alpn_len && s_offset < total_len) {\n\t    u_int8_t alpn_i, alpn_len = packet->payload[s_offset++];\n\n\t    if((s_offset + alpn_len) <= tot_alpn_len) {\n#ifdef DEBUG_TLS\n\t      printf(\"Server TLS [ALPN: %u]\\n\", alpn_len);\n#endif\n\n\t      if((alpn_str_len+alpn_len+1) < (sizeof(alpn_str)-1)) {\n\t        if(alpn_str_len > 0) {\n\t          alpn_str[alpn_str_len] = ',';\n\t          alpn_str_len++;\n\t        }\n\n\t        for(alpn_i=0; alpn_i<alpn_len; alpn_i++)\n\t        {\n\t          alpn_str[alpn_str_len+alpn_i] = packet->payload[s_offset+alpn_i];\n\t        }\n\n\t        s_offset += alpn_len, alpn_str_len += alpn_len;;\n\t      } else {\n\t        ndpi_set_risk(flow, NDPI_TLS_UNCOMMON_ALPN);\n\t        break;\n\t      }\n\t    } else {\n\t      ndpi_set_risk(flow, NDPI_TLS_UNCOMMON_ALPN);\n\t      break;\n\t    }\n\t  } /* while */\n\n\t  alpn_str[alpn_str_len] = '\\0';\n\n#ifdef DEBUG_TLS\n\t  printf(\"Server TLS [ALPN: %s][len: %u]\\n\", alpn_str, alpn_str_len);\n#endif\n\t  if(flow->protos.tls_quic_stun.tls_quic.alpn == NULL)\n\t    flow->protos.tls_quic_stun.tls_quic.alpn = ndpi_strdup(alpn_str);\n\n\t  if(flow->protos.tls_quic_stun.tls_quic.alpn != NULL)\n\t    tlsCheckUncommonALPN(flow);\n\n\t  snprintf(ja3.server.alpn, sizeof(ja3.server.alpn), \"%s\", alpn_str);\n\n\t  /* Replace , with - as in JA3 */\n\t  for(i=0; ja3.server.alpn[i] != '\\0'; i++)\n\t    if(ja3.server.alpn[i] == ',') ja3.server.alpn[i] = '-';\n\t} else if(extension_id == 11 /* ec_point_formats groups */) {\n\t  u_int16_t s_offset = offset+4 + 1;\n\n#ifdef DEBUG_TLS\n\t  printf(\"Server TLS [EllipticCurveFormat: len=%u]\\n\", extension_len);\n#endif\n\t  if((s_offset+extension_len-1) <= total_len) {\n\t    for(i=0; i<extension_len-1; i++) {\n\t      u_int8_t s_group = packet->payload[s_offset+i];\n\n#ifdef DEBUG_TLS\n\t      printf(\"Server TLS [EllipticCurveFormat: %u]\\n\", s_group);\n#endif\n\n\t      if(ja3.server.num_elliptic_curve_point_format < MAX_NUM_JA3)\n\t\tja3.server.elliptic_curve_point_format[ja3.server.num_elliptic_curve_point_format++] = s_group;\n\t      else {\n\t\tinvalid_ja3 = 1;\n#ifdef DEBUG_TLS\n\t\tprintf(\"Server TLS Invalid num elliptic %u\\n\", ja3.server.num_elliptic_curve_point_format);\n#endif\n\t      }\n\t    }\n\t  } else {\n\t    invalid_ja3 = 1;\n#ifdef DEBUG_TLS\n\t    printf(\"Server TLS Invalid len %u vs %u\\n\", s_offset+extension_len, total_len);\n#endif\n\t  }\n\t}\n\n\ti += 4 + extension_len, offset += 4 + extension_len;\n      } /* for */\n\n      ja3_str_len = snprintf(ja3_str, JA3_STR_LEN, \"%u,\", ja3.server.tls_handshake_version);\n\n      for(i=0; (i<ja3.server.num_cipher) && (JA3_STR_LEN > ja3_str_len); i++) {\n\trc = snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN-ja3_str_len, \"%s%u\", (i > 0) ? \"-\" : \"\", ja3.server.cipher[i]);\n\n\tif(rc <= 0) break; else ja3_str_len += rc;\n      }\n\n      if(JA3_STR_LEN > ja3_str_len) {\n\trc = snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN-ja3_str_len, \",\");\n\tif(rc > 0 && ja3_str_len + rc < JA3_STR_LEN) ja3_str_len += rc;\n      }\n      \n      /* ********** */\n\n      for(i=0; (i<ja3.server.num_tls_extension) && (JA3_STR_LEN > ja3_str_len); i++) {\n\tint rc = snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN-ja3_str_len, \"%s%u\", (i > 0) ? \"-\" : \"\", ja3.server.tls_extension[i]);\n\n\tif(rc <= 0) break; else ja3_str_len += rc;\n      }\n\n      if(ndpi_struct->enable_ja3_plus) {\n\tfor(i=0; (i<ja3.server.num_elliptic_curve_point_format) && (JA3_STR_LEN > ja3_str_len); i++) {\n\t  rc = snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN-ja3_str_len, \"%s%u\",\n\t\t\t(i > 0) ? \"-\" : \"\", ja3.server.elliptic_curve_point_format[i]);\n\t  if((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc; else break;\n\t}\n\n\tif((ja3.server.alpn[0] != '\\0') && (JA3_STR_LEN > ja3_str_len)) {\n\t  rc = snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN-ja3_str_len, \",%s\", ja3.server.alpn);\n\t  if((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc;\n\t}\n\n#ifdef DEBUG_TLS\n\tprintf(\"[JA3+] Server: %s \\n\", ja3_str);\n#endif\n      } else {\n#ifdef DEBUG_TLS\n\tprintf(\"[JA3] Server: %s \\n\", ja3_str);\n#endif\n      }\n\n      ndpi_MD5Init(&ctx);\n      ndpi_MD5Update(&ctx, (const unsigned char *)ja3_str, strlen(ja3_str));\n      ndpi_MD5Final(md5_hash, &ctx);\n\n      for(i=0, j=0; i<16; i++) {\n\tint rc = snprintf(&flow->protos.tls_quic_stun.tls_quic.ja3_server[j],\n\t\t\t  sizeof(flow->protos.tls_quic_stun.tls_quic.ja3_server)-j, \"%02x\", md5_hash[i]);\n\tif(rc <= 0) break; else j += rc;\n      }\n\n#ifdef DEBUG_TLS\n      printf(\"[JA3] Server: %s \\n\", flow->protos.tls_quic_stun.tls_quic.ja3_server);\n#endif\n    } else if(handshake_type == 0x01 /* Client Hello */) {\n      u_int16_t cipher_len, cipher_offset;\n      u_int8_t cookie_len = 0;\n\n      flow->protos.tls_quic_stun.tls_quic.ssl_version = ja3.client.tls_handshake_version = tls_version;\n      if(flow->protos.tls_quic_stun.tls_quic.ssl_version < 0x0302) /* TLSv1.1 */\n\tndpi_set_risk(flow, NDPI_TLS_OBSOLETE_VERSION);\n\n      if((session_id_len+base_offset+3) > packet->payload_packet_len)\n\treturn(0); /* Not found */\n\n      if(!is_dtls) {\n\tcipher_len = packet->payload[session_id_len+base_offset+2] + (packet->payload[session_id_len+base_offset+1] << 8);\n\tcipher_offset = base_offset + session_id_len + 3;\n      } else {\n\tcookie_len = packet->payload[base_offset+session_id_len+1];\n#ifdef DEBUG_TLS\n\tprintf(\"[JA3] Client: DTLS cookie len %d\\n\", cookie_len);\n#endif\n\tif((session_id_len+base_offset+cookie_len+4) > packet->payload_packet_len)\n\t  return(0); /* Not found */\n\tcipher_len = ntohs(*((u_int16_t*)&packet->payload[base_offset+session_id_len+cookie_len+2]));\n\tcipher_offset = base_offset + session_id_len + cookie_len + 4;\n      }\n\n#ifdef DEBUG_TLS\n      printf(\"Client TLS [client cipher_len: %u][tls_version: 0x%04X]\\n\", cipher_len, tls_version);\n#endif\n\n      if((cipher_offset+cipher_len) <= total_len) {\n\tu_int8_t safari_ciphers = 0, chrome_ciphers = 0;\n\n\tfor(i=0; i<cipher_len;) {\n\t  u_int16_t *id = (u_int16_t*)&packet->payload[cipher_offset+i];\n\n#ifdef DEBUG_TLS\n\t  printf(\"Client TLS [cipher suite: %u/0x%04X] [%d/%u]\\n\", ntohs(*id), ntohs(*id), i, cipher_len);\n#endif\n\t  if((*id == 0) || (packet->payload[cipher_offset+i] != packet->payload[cipher_offset+i+1])) {\n\t    u_int16_t cipher_id = ntohs(*id);\n\t    /*\n\t      Skip GREASE [https://tools.ietf.org/id/draft-ietf-tls-grease-01.html]\n\t      https://engineering.salesforce.com/tls-fingerprinting-with-ja3-and-ja3s-247362855967\n\t    */\n\n\t    if(ja3.client.num_cipher < MAX_NUM_JA3)\n\t      ja3.client.cipher[ja3.client.num_cipher++] = cipher_id;\n\t    else {\n\t      invalid_ja3 = 1;\n#ifdef DEBUG_TLS\n\t      printf(\"Client TLS Invalid cipher %u\\n\", ja3.client.num_cipher);\n#endif\n\t    }\n\n\t    switch(cipher_id) {\n\t    case TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:\n\t    case TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384:\n\t      safari_ciphers++;\n\t      break;\n\n\t    case TLS_CIPHER_GREASE_RESERVED_0:\n\t    case TLS_AES_128_GCM_SHA256:\n\t    case TLS_AES_256_GCM_SHA384:\n\t    case TLS_CHACHA20_POLY1305_SHA256:\n\t      chrome_ciphers++;\n\t      break;\n\n\t    case TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256:\n\t    case TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:\n\t    case TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:\n\t    case TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:\n\t    case TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:\n\t    case TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:\n\t    case TLS_RSA_WITH_AES_128_CBC_SHA:\n\t    case TLS_RSA_WITH_AES_256_CBC_SHA:\n\t    case TLS_RSA_WITH_AES_128_GCM_SHA256:\n\t    case TLS_RSA_WITH_AES_256_GCM_SHA384:\n\t      safari_ciphers++, chrome_ciphers++;\n\t      break;\n\t    }\n\t  }\n\n\t  i += 2;\n\t} /* for */\n\n\tif(chrome_ciphers == 13)\n\t  flow->protos.tls_quic_stun.tls_quic.browser_euristics.is_chrome_tls = 1;\n\telse if(safari_ciphers == 12)\n\t  flow->protos.tls_quic_stun.tls_quic.browser_euristics.is_safari_tls = 1;\n      } else {\n\tinvalid_ja3 = 1;\n#ifdef DEBUG_TLS\n\tprintf(\"Client TLS Invalid len %u vs %u\\n\", (cipher_offset+cipher_len), total_len);\n#endif\n      }\n\n      offset = base_offset + session_id_len + cookie_len + cipher_len + 2;\n      offset += (!is_dtls) ? 1 : 2;\n\n      if(offset < total_len) {\n\tu_int16_t compression_len;\n\tu_int16_t extensions_len;\n\n\tcompression_len = packet->payload[offset];\n\toffset++;\n\n#ifdef DEBUG_TLS\n\tprintf(\"Client TLS [compression_len: %u]\\n\", compression_len);\n#endif\n\n\t// offset += compression_len + 3;\n\toffset += compression_len;\n\n\tif(offset+1 < total_len) {\n\t  extensions_len = ntohs(*((u_int16_t*)&packet->payload[offset]));\n\t  offset += 2;\n\n#ifdef DEBUG_TLS\n\t  printf(\"Client TLS [extensions_len: %u]\\n\", extensions_len);\n#endif\n\n\t  if((extensions_len+offset) <= total_len) {\n\t    /* Move to the first extension\n\t       Type is u_int to avoid possible overflow on extension_len addition */\n\t    u_int extension_offset = 0;\n\t    u_int32_t j;\n\n\t    while(extension_offset < extensions_len &&\n\t\t  offset+extension_offset+4 <= total_len) {\n\t      u_int16_t extension_id, extension_len, extn_off = offset+extension_offset;\n\n\n\t      extension_id = ntohs(*((u_int16_t*)&packet->payload[offset+extension_offset]));\n\t      extension_offset += 2;\n\n\t      extension_len = ntohs(*((u_int16_t*)&packet->payload[offset+extension_offset]));\n\t      extension_offset += 2;\n\n#ifdef DEBUG_TLS\n\t      printf(\"Client TLS [extension_id: %u][extension_len: %u]\\n\", extension_id, extension_len);\n#endif\n\n\t      if((extension_id == 0) || (packet->payload[extn_off] != packet->payload[extn_off+1])) {\n\t\t/* Skip GREASE */\n\n\t\tif(ja3.client.num_tls_extension < MAX_NUM_JA3)\n\t\t  ja3.client.tls_extension[ja3.client.num_tls_extension++] = extension_id;\n\t\telse {\n\t\t  invalid_ja3 = 1;\n#ifdef DEBUG_TLS\n\t\t  printf(\"Client TLS Invalid extensions %u\\n\", ja3.client.num_tls_extension);\n#endif\n\t\t}\n\t      }\n\n\t      if(extension_id == 0 /* server name */) {\n\t\tu_int16_t len;\n\n#ifdef DEBUG_TLS\n\t\tprintf(\"[TLS] Extensions: found server name\\n\");\n#endif\n\t\tif((offset+extension_offset+4) < packet->payload_packet_len) {\n\n\t\t  len = (packet->payload[offset+extension_offset+3] << 8) + packet->payload[offset+extension_offset+4];\n\t\t  len = (u_int)ndpi_min(len, sizeof(buffer)-1);\n\n\t\t  if((offset+extension_offset+5+len) <= packet->payload_packet_len) {\n\t\t    strncpy(buffer, (char*)&packet->payload[offset+extension_offset+5], len);\n\t\t    buffer[len] = '\\0';\n\n\t\t    cleanupServerName(buffer, sizeof(buffer));\n\n\t\t    snprintf(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name,\n\t\t\t     sizeof(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name),\n\t\t\t     \"%s\", buffer);\n#ifdef DEBUG_TLS\n\t\t    printf(\"[TLS] SNI: [%s]\\n\", buffer);\n#endif\n\t\t    if(!is_quic) {\n\t\t      if(ndpi_match_hostname_protocol(ndpi_struct, flow, NDPI_PROTOCOL_TLS, buffer, strlen(buffer)))\n\t\t        flow->l4.tcp.tls.subprotocol_detected = 1;\n\t\t    } else {\n\t\t      if(ndpi_match_hostname_protocol(ndpi_struct, flow, NDPI_PROTOCOL_QUIC, buffer, strlen(buffer)))\n\t\t        flow->l4.tcp.tls.subprotocol_detected = 1;\n\t\t    }\n\n\t\t    if(ndpi_check_dga_name(ndpi_struct, flow,\n\t\t\t\t\t   flow->protos.tls_quic_stun.tls_quic.client_requested_server_name, 1)) {\n\t\t      char *sni = flow->protos.tls_quic_stun.tls_quic.client_requested_server_name;\n\t\t      int len = strlen(sni);\n\n#ifdef DEBUG_TLS\n\t\t      printf(\"[TLS] SNI: (DGA) [%s]\\n\", flow->protos.tls_quic_stun.tls_quic.client_requested_server_name);\n#endif\n\n\t\t      if((len >= 4)\n\t\t         /* Check if it ends in .com or .net */\n\t\t         && ((strcmp(&sni[len-4], \".com\") == 0) || (strcmp(&sni[len-4], \".net\") == 0))\n\t\t         && (strncmp(sni, \"www.\", 4) == 0)) /* Not starting with www.... */\n\t\t        ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_TOR, NDPI_PROTOCOL_TLS);\n\t\t    } else {\n#ifdef DEBUG_TLS\n\t\t      printf(\"[TLS] SNI: (NO DGA) [%s]\\n\", flow->protos.tls_quic_stun.tls_quic.client_requested_server_name);\n#endif\n\t\t    }\n\t\t  } else {\n#ifdef DEBUG_TLS\n\t\t    printf(\"[TLS] Extensions server len too short: %u vs %u\\n\",\n\t\t\t   offset+extension_offset+5+len,\n\t\t\t   packet->payload_packet_len);\n#endif\n\t\t  }\n\t\t}\n\t      } else if(extension_id == 10 /* supported groups */) {\n\t\tu_int16_t s_offset = offset+extension_offset + 2;\n\n#ifdef DEBUG_TLS\n\t\tprintf(\"Client TLS [EllipticCurveGroups: len=%u]\\n\", extension_len);\n#endif\n\n\t\tif((s_offset+extension_len-2) <= total_len) {\n\t\t  for(i=0; i<extension_len-2;) {\n\t\t    u_int16_t s_group = ntohs(*((u_int16_t*)&packet->payload[s_offset+i]));\n\n#ifdef DEBUG_TLS\n\t\t    printf(\"Client TLS [EllipticCurve: %u/0x%04X]\\n\", s_group, s_group);\n#endif\n\t\t    if((s_group == 0) || (packet->payload[s_offset+i] != packet->payload[s_offset+i+1])) {\n\t\t      /* Skip GREASE */\n\t\t      if(ja3.client.num_elliptic_curve < MAX_NUM_JA3)\n\t\t\tja3.client.elliptic_curve[ja3.client.num_elliptic_curve++] = s_group;\n\t\t      else {\n\t\t\tinvalid_ja3 = 1;\n#ifdef DEBUG_TLS\n\t\t\tprintf(\"Client TLS Invalid num elliptic %u\\n\", ja3.client.num_elliptic_curve);\n#endif\n\t\t      }\n\t\t    }\n\n\t\t    i += 2;\n\t\t  }\n\t\t} else {\n\t\t  invalid_ja3 = 1;\n#ifdef DEBUG_TLS\n\t\t  printf(\"Client TLS Invalid len %u vs %u\\n\", (s_offset+extension_len-1), total_len);\n#endif\n\t\t}\n\t      } else if(extension_id == 11 /* ec_point_formats groups */) {\n\t\tu_int16_t s_offset = offset+extension_offset + 1;\n\n#ifdef DEBUG_TLS\n\t\tprintf(\"Client TLS [EllipticCurveFormat: len=%u]\\n\", extension_len);\n#endif\n\t\tif((s_offset+extension_len-1) <= total_len) {\n\t\t  for(i=0; i<extension_len-1; i++) {\n\t\t    u_int8_t s_group = packet->payload[s_offset+i];\n\n#ifdef DEBUG_TLS\n\t\t    printf(\"Client TLS [EllipticCurveFormat: %u]\\n\", s_group);\n#endif\n\n\t\t    if(ja3.client.num_elliptic_curve_point_format < MAX_NUM_JA3)\n\t\t      ja3.client.elliptic_curve_point_format[ja3.client.num_elliptic_curve_point_format++] = s_group;\n\t\t    else {\n\t\t      invalid_ja3 = 1;\n#ifdef DEBUG_TLS\n\t\t      printf(\"Client TLS Invalid num elliptic %u\\n\", ja3.client.num_elliptic_curve_point_format);\n#endif\n\t\t    }\n\t\t  }\n\t\t} else {\n\t\t  invalid_ja3 = 1;\n#ifdef DEBUG_TLS\n\t\t  printf(\"Client TLS Invalid len %u vs %u\\n\", s_offset+extension_len, total_len);\n#endif\n\t\t}\n\t      } else if(extension_id == 13 /* signature algorithms */) {\n\t\tu_int16_t s_offset = offset+extension_offset, safari_signature_algorithms = 0, chrome_signature_algorithms = 0;\n\t\tu_int16_t tot_signature_algorithms_len = ntohs(*((u_int16_t*)&packet->payload[s_offset]));\n\n#ifdef DEBUG_TLS\n\t\tprintf(\"Client TLS [SIGNATURE_ALGORITHMS: block_len=%u/len=%u]\\n\", extension_len, tot_signature_algorithms_len);\n#endif\n\n\t\ts_offset += 2;\n\t\ttot_signature_algorithms_len = ndpi_min((sizeof(ja3.client.signature_algorithms) / 2) - 1, tot_signature_algorithms_len);\n\n#ifdef TLS_HANDLE_SIGNATURE_ALGORITMS\n\t\tflow->protos.tls_quic_stun.tls_quic.num_tls_signature_algorithms = ndpi_min(tot_signature_algorithms_len / 2, MAX_NUM_TLS_SIGNATURE_ALGORITHMS);\n\n\t\tmemcpy(flow->protos.tls_quic_stun.tls_quic.client_signature_algorithms,\n\t\t       &packet->payload[s_offset], 2 /* 16 bit */*flow->protos.tls_quic_stun.tls_quic.num_tls_signature_algorithms);\n#endif\n\n\t\tfor(i=0; i<tot_signature_algorithms_len; i++) {\n\t\t  int rc = snprintf(&ja3.client.signature_algorithms[i*2], sizeof(ja3.client.signature_algorithms)-i*2, \"%02X\", packet->payload[s_offset+i]);\n\n\t\t  if(rc < 0) break;\n\t\t}\n\n\t\tfor(i=0; i<tot_signature_algorithms_len; i+=2) {\n\t\t  u_int16_t cipher_id = (u_int16_t)ntohs(*((u_int16_t*)&packet->payload[s_offset+i]));\n\n\t\t  // printf(\"=>> %04X\\n\", cipher_id);\n\n\t\t  switch(cipher_id) {\n\t\t  case ECDSA_SECP521R1_SHA512:\n\t\t    flow->protos.tls_quic_stun.tls_quic.browser_euristics.is_firefox_tls = 1;\n\t\t    break;\n\n\t\t  case ECDSA_SECP256R1_SHA256:\n\t\t  case ECDSA_SECP384R1_SHA384:\n\t\t  case RSA_PKCS1_SHA256:\n\t\t  case RSA_PKCS1_SHA384:\n\t\t  case RSA_PKCS1_SHA512:\n\t\t  case RSA_PSS_RSAE_SHA256:\n\t\t  case RSA_PSS_RSAE_SHA384:\n\t\t  case RSA_PSS_RSAE_SHA512:\n\t\t    chrome_signature_algorithms++, safari_signature_algorithms++;\n\t\t    break;\n\t\t  }\n\t\t}\n\n\t\tif(flow->protos.tls_quic_stun.tls_quic.browser_euristics.is_firefox_tls)\n\t\t  flow->protos.tls_quic_stun.tls_quic.browser_euristics.is_safari_tls = 0,\n\t\t    flow->protos.tls_quic_stun.tls_quic.browser_euristics.is_chrome_tls = 0;\n\n\t\tif(safari_signature_algorithms != 8)\n\t\t   flow->protos.tls_quic_stun.tls_quic.browser_euristics.is_safari_tls = 0;\n\n\t\tif(chrome_signature_algorithms != 8)\n\t\t   flow->protos.tls_quic_stun.tls_quic.browser_euristics.is_chrome_tls = 0;\n\n\t\tja3.client.signature_algorithms[i*2] = '\\0';\n\n#ifdef DEBUG_TLS\n\t\tprintf(\"Client TLS [SIGNATURE_ALGORITHMS: %s]\\n\", ja3.client.signature_algorithms);\n#endif\n\t      } else if(extension_id == 16 /* application_layer_protocol_negotiation */) {\n\t\tu_int16_t s_offset = offset+extension_offset;\n\t\tu_int16_t tot_alpn_len = ntohs(*((u_int16_t*)&packet->payload[s_offset]));\n\t\tchar alpn_str[256];\n\t\tu_int8_t alpn_str_len = 0, i;\n\n#ifdef DEBUG_TLS\n\t\tprintf(\"Client TLS [ALPN: block_len=%u/len=%u]\\n\", extension_len, tot_alpn_len);\n#endif\n\t\ts_offset += 2;\n\t\ttot_alpn_len += s_offset;\n\n\t\twhile(s_offset < tot_alpn_len && s_offset < total_len) {\n\t\t  u_int8_t alpn_i, alpn_len = packet->payload[s_offset++];\n\n\t\t  if((s_offset + alpn_len) <= tot_alpn_len &&\n\t\t     (s_offset + alpn_len) <= total_len) {\n#ifdef DEBUG_TLS\n\t\t    printf(\"Client TLS [ALPN: %u]\\n\", alpn_len);\n#endif\n\n\t\t    if((alpn_str_len+alpn_len+1) < (sizeof(alpn_str)-1)) {\n\t\t      if(alpn_str_len > 0) {\n\t\t\talpn_str[alpn_str_len] = ',';\n\t\t\talpn_str_len++;\n\t\t      }\n\n\t\t      for(alpn_i=0; alpn_i<alpn_len; alpn_i++)\n\t\t\talpn_str[alpn_str_len+alpn_i] = packet->payload[s_offset+alpn_i];\n\n\t\t      s_offset += alpn_len, alpn_str_len += alpn_len;;\n\t\t    } else\n\t\t      break;\n\t\t  } else\n\t\t    break;\n\t\t} /* while */\n\n\t\talpn_str[alpn_str_len] = '\\0';\n\n#ifdef DEBUG_TLS\n\t\tprintf(\"Client TLS [ALPN: %s][len: %u]\\n\", alpn_str, alpn_str_len);\n#endif\n\t\tif(flow->protos.tls_quic_stun.tls_quic.alpn == NULL)\n\t\t  flow->protos.tls_quic_stun.tls_quic.alpn = ndpi_strdup(alpn_str);\n\n\t\tsnprintf(ja3.client.alpn, sizeof(ja3.client.alpn), \"%s\", alpn_str);\n\n\t\t/* Replace , with - as in JA3 */\n\t\tfor(i=0; ja3.client.alpn[i] != '\\0'; i++)\n\t\t  if(ja3.client.alpn[i] == ',') ja3.client.alpn[i] = '-';\n\n\t      } else if(extension_id == 43 /* supported versions */) {\n\t\tu_int16_t s_offset = offset+extension_offset;\n\t\tu_int8_t version_len = packet->payload[s_offset];\n\t\tchar version_str[256];\n\t\tu_int8_t version_str_len = 0;\n\t\tversion_str[0] = 0;\n#ifdef DEBUG_TLS\n\t\tprintf(\"Client TLS [TLS version len: %u]\\n\", version_len);\n#endif\n\n\t\tif(version_len == (extension_len-1)) {\n\t\t  u_int8_t j;\n\t\t  u_int16_t supported_versions_offset = 0;\n\n\t\t  s_offset++;\n\n\t\t  // careful not to overflow and loop forever with u_int8_t\n\t\t  for(j=0; j+1<version_len; j += 2) {\n\t\t    u_int16_t tls_version = ntohs(*((u_int16_t*)&packet->payload[s_offset+j]));\n\t\t    u_int8_t unknown_tls_version;\n\n#ifdef DEBUG_TLS\n\t\t    printf(\"Client TLS [TLS version: %s/0x%04X]\\n\",\n\t\t\t   ndpi_ssl_version2str(flow, tls_version, &unknown_tls_version), tls_version);\n#endif\n\n\t\t    if((version_str_len+8) < sizeof(version_str)) {\n\t\t      int rc = snprintf(&version_str[version_str_len],\n\t\t\t\t\tsizeof(version_str) - version_str_len, \"%s%s\",\n\t\t\t\t\t(version_str_len > 0) ? \",\" : \"\",\n\t\t\t\t\tndpi_ssl_version2str(flow, tls_version, &unknown_tls_version));\n\t\t      if(rc <= 0)\n\t\t\tbreak;\n\t\t      else\n\t\t\tversion_str_len += rc;\n\n\t\t      rc = snprintf(&ja3.client.supported_versions[supported_versions_offset],\n\t\t\t\t    sizeof(ja3.client.supported_versions)-supported_versions_offset,\n\t\t\t\t    \"%s%04X\", (j > 0) ? \"-\" : \"\", tls_version);\n\n\t\t      if(rc > 0)\n\t\t\tsupported_versions_offset += rc;\n\t\t    }\n\t\t  }\n\n#ifdef DEBUG_TLS\n\t\t  printf(\"Client TLS [SUPPORTED_VERSIONS: %s]\\n\", ja3.client.supported_versions);\n#endif\n\n\t\t  if(flow->protos.tls_quic_stun.tls_quic.tls_supported_versions == NULL)\n\t\t    flow->protos.tls_quic_stun.tls_quic.tls_supported_versions = ndpi_strdup(version_str);\n\t\t}\n\t      } else if(extension_id == 65486 /* encrypted server name */) {\n\t\t/*\n\t\t   - https://tools.ietf.org/html/draft-ietf-tls-esni-06\n\t\t   - https://blog.cloudflare.com/encrypted-sni/\n\t\t*/\n\t\tu_int16_t e_offset = offset+extension_offset;\n\t\tu_int16_t initial_offset = e_offset;\n\t\tu_int16_t e_sni_len, cipher_suite = ntohs(*((u_int16_t*)&packet->payload[e_offset]));\n\n\t\tflow->protos.tls_quic_stun.tls_quic.encrypted_sni.cipher_suite = cipher_suite;\n\n\t\te_offset += 2; /* Cipher suite len */\n\n\t\t/* Key Share Entry */\n\t\te_offset += 2; /* Group */\n\t\te_offset +=  ntohs(*((u_int16_t*)&packet->payload[e_offset])) + 2; /* Lenght */\n\n\t\tif((e_offset+4) < packet->payload_packet_len) {\n\t\t  /* Record Digest */\n\t\t  e_offset +=  ntohs(*((u_int16_t*)&packet->payload[e_offset])) + 2; /* Lenght */\n\n\t\t  if((e_offset+4) < packet->payload_packet_len) {\n\t\t    e_sni_len = ntohs(*((u_int16_t*)&packet->payload[e_offset]));\n\t\t    e_offset += 2;\n\n\t\t    if((e_offset+e_sni_len-extension_len-initial_offset) >= 0 &&\n\t\t        e_offset+e_sni_len < packet->payload_packet_len) {\n#ifdef DEBUG_ENCRYPTED_SNI\n\t\t      printf(\"Client TLS [Encrypted Server Name len: %u]\\n\", e_sni_len);\n#endif\n\n\t\t      if(flow->protos.tls_quic_stun.tls_quic.encrypted_sni.esni == NULL) {\n\t\t\tflow->protos.tls_quic_stun.tls_quic.encrypted_sni.esni = (char*)ndpi_malloc(e_sni_len*2+1);\n\n\t\t\tif(flow->protos.tls_quic_stun.tls_quic.encrypted_sni.esni) {\n\t\t\t  u_int16_t i, off;\n\n\t\t\t  for(i=e_offset, off=0; i<(e_offset+e_sni_len); i++) {\n\t\t\t    int rc = sprintf(&flow->protos.tls_quic_stun.tls_quic.encrypted_sni.esni[off], \"%02X\", packet->payload[i] & 0XFF);\n\n\t\t\t    if(rc <= 0) {\n\t\t\t      flow->protos.tls_quic_stun.tls_quic.encrypted_sni.esni[off] = '\\0';\n\t\t\t      break;\n\t\t\t    } else\n\t\t\t      off += rc;\n\t\t\t  }\n\t\t\t}\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t}\n\t      } else if(extension_id == 65445 || /* QUIC transport parameters (drafts version) */\n\t\t        extension_id == 57) { /* QUIC transport parameters (final version) */\n\t\tu_int16_t s_offset = offset+extension_offset;\n\t\tuint16_t final_offset;\n\t\tint using_var_int = is_version_with_var_int_transport_params(quic_version);\n\n\t\tif(!using_var_int) {\n\t\t  if(s_offset+1 >= total_len) {\n\t\t    final_offset = 0; /* Force skipping extension */\n\t\t  } else {\n\t\t    u_int16_t seq_len = ntohs(*((u_int16_t*)&packet->payload[s_offset]));\n\t\t    s_offset += 2;\n\t            final_offset = MIN(total_len, s_offset + seq_len);\n\t\t  }\n\t\t} else {\n\t          final_offset = MIN(total_len, s_offset + extension_len);\n\t\t}\n\n\t\twhile(s_offset < final_offset) {\n\t\t  u_int64_t param_type, param_len;\n\n                  if(!using_var_int) {\n\t\t    if(s_offset+3 >= final_offset)\n\t\t      break;\n\t\t    param_type = ntohs(*((u_int16_t*)&packet->payload[s_offset]));\n\t\t    param_len = ntohs(*((u_int16_t*)&packet->payload[s_offset + 2]));\n\t\t    s_offset += 4;\n\t\t  } else {\n\t\t    if(s_offset >= final_offset ||\n\t\t       (s_offset + quic_len_buffer_still_required(packet->payload[s_offset])) >= final_offset)\n\t\t      break;\n\t\t    s_offset += quic_len(&packet->payload[s_offset], &param_type);\n\n\t\t    if(s_offset >= final_offset ||\n\t\t       (s_offset + quic_len_buffer_still_required(packet->payload[s_offset])) >= final_offset)\n\t\t      break;\n\t\t    s_offset += quic_len(&packet->payload[s_offset], &param_len);\n\t\t  }\n\n#ifdef DEBUG_TLS\n\t\t  printf(\"Client TLS [QUIC TP: Param 0x%x Len %d]\\n\", (int)param_type, (int)param_len);\n#endif\n\t\t  if(s_offset+param_len > final_offset)\n\t\t    break;\n\n\t\t  if(param_type==0x3129) {\n#ifdef DEBUG_TLS\n\t\t      printf(\"UA [%.*s]\\n\", (int)param_len, &packet->payload[s_offset]);\n#endif\n\t\t      http_process_user_agent(ndpi_struct, flow,\n\t\t\t\t\t      &packet->payload[s_offset], param_len);\n\t\t      break;\n\t\t  }\n\t\t  s_offset += param_len;\n\t\t}\n\t      }\n\n\t      extension_offset += extension_len; /* Move to the next extension */\n\n#ifdef DEBUG_TLS\n\t      printf(\"Client TLS [extension_offset/len: %u/%u]\\n\", extension_offset, extension_len);\n#endif\n\t    } /* while */\n\n\t    if(!invalid_ja3) {\n\t      int rc;\n\n\t    compute_ja3c:\n\t      ja3_str_len = snprintf(ja3_str, JA3_STR_LEN, \"%u,\", ja3.client.tls_handshake_version);\n\n\t      for(i=0; i<ja3.client.num_cipher; i++) {\n\t\trc = snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN-ja3_str_len, \"%s%u\",\n\t\t\t      (i > 0) ? \"-\" : \"\", ja3.client.cipher[i]);\n\t\tif((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc; else break;\n\t      }\n\n\t      rc = snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN-ja3_str_len, \",\");\n\t      if((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc;\n\n\t      /* ********** */\n\n\t      for(i=0; i<ja3.client.num_tls_extension; i++) {\n\t\trc = snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN-ja3_str_len, \"%s%u\",\n\t\t\t      (i > 0) ? \"-\" : \"\", ja3.client.tls_extension[i]);\n\t\tif((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc; else break;\n\t      }\n\n\t      rc = snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN-ja3_str_len, \",\");\n\t      if((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc;\n\n\t      /* ********** */\n\n\t      for(i=0; i<ja3.client.num_elliptic_curve; i++) {\n\t\trc = snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN-ja3_str_len, \"%s%u\",\n\t\t\t      (i > 0) ? \"-\" : \"\", ja3.client.elliptic_curve[i]);\n\t\tif((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc; else break;\n\t      }\n\n\t      rc = snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN-ja3_str_len, \",\");\n\t      if((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc;\n\n\t      for(i=0; i<ja3.client.num_elliptic_curve_point_format; i++) {\n\t\trc = snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN-ja3_str_len, \"%s%u\",\n\t\t\t      (i > 0) ? \"-\" : \"\", ja3.client.elliptic_curve_point_format[i]);\n\t\tif((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc; else break;\n\t      }\n\n\t      if(ndpi_struct->enable_ja3_plus) {\n\t\trc = snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN-ja3_str_len,\n\t\t\t      \",%s,%s,%s\", ja3.client.signature_algorithms, ja3.client.supported_versions, ja3.client.alpn);\n\t\tif((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc;\n\t      }\n\n#ifdef DEBUG_JA3C\n\t      printf(\"[JA3+] Client: %s \\n\", ja3_str);\n#endif\n\n\t      ndpi_MD5Init(&ctx);\n\t      ndpi_MD5Update(&ctx, (const unsigned char *)ja3_str, strlen(ja3_str));\n\t      ndpi_MD5Final(md5_hash, &ctx);\n\n\t      for(i=0, j=0; i<16; i++) {\n\t\trc = snprintf(&flow->protos.tls_quic_stun.tls_quic.ja3_client[j],\n\t\t\t      sizeof(flow->protos.tls_quic_stun.tls_quic.ja3_client)-j, \"%02x\",\n\t\t\t      md5_hash[i]);\n\t\tif(rc > 0) j += rc; else break;\n\t      }\n\n#ifdef DEBUG_JA3C\n\t      printf(\"[JA3] Client: %s \\n\", flow->protos.tls_quic_stun.tls_quic.ja3_client);\n#endif\n\n\t      if(ndpi_struct->malicious_ja3_automa.ac_automa != NULL) {\n\t\tu_int16_t rc1 = ndpi_match_string(ndpi_struct->malicious_ja3_automa.ac_automa,\n\t\t\t\t\t\t  flow->protos.tls_quic_stun.tls_quic.ja3_client);\n\n\t\tif(rc1 > 0)\n\t\t  ndpi_set_risk(flow, NDPI_MALICIOUS_JA3);\n\t      }\n\t    }\n\n\t    /* Before returning to the caller we need to make a final check */\n\t    if((flow->protos.tls_quic_stun.tls_quic.ssl_version >= 0x0303) /* >= TLSv1.2 */\n\t       && (flow->protos.tls_quic_stun.tls_quic.alpn == NULL) /* No ALPN */) {\n\t      ndpi_set_risk(flow, NDPI_TLS_NOT_CARRYING_HTTPS);\n\t    }\n\n\t    /* Suspicious Domain Fronting:\n\t       https://github.com/SixGenInc/Noctilucent/blob/master/docs/ */\n\t    if(flow->protos.tls_quic_stun.tls_quic.encrypted_sni.esni &&\n\t       flow->protos.tls_quic_stun.tls_quic.client_requested_server_name[0] != '\\0') {\n\t      ndpi_set_risk(flow, NDPI_TLS_SUSPICIOUS_ESNI_USAGE);\n\t    }\n\n\t    /* Add check for missing SNI */\n\t    if((flow->protos.tls_quic_stun.tls_quic.client_requested_server_name[0] == 0)\n\t       && (flow->protos.tls_quic_stun.tls_quic.ssl_version >= 0x0302) /* TLSv1.1 */\n\t       && (flow->protos.tls_quic_stun.tls_quic.encrypted_sni.esni == NULL) /* No ESNI */\n\t       ) {\n\t      /* This is a bit suspicious */\n\t      ndpi_set_risk(flow, NDPI_TLS_MISSING_SNI);\n\t    }\n\n\t    return(2 /* Client Certificate */);\n\t  } else {\n#ifdef DEBUG_TLS\n\t    printf(\"[TLS] Client: too short [%u vs %u]\\n\",\n\t\t   (extensions_len+offset), total_len);\n#endif\n\t  }\n\t} else if(offset == total_len) {\n\t  /* TLS does not have extensions etc */\n\t  goto compute_ja3c;\n\t}\n      } else {\n#ifdef DEBUG_TLS\n\tprintf(\"[JA3] Client: invalid length detected\\n\");\n#endif\n      }\n    }\n  }\n\n  return(0); /* Not found */\n}\n\n/* **************************************** */\n\nstatic void ndpi_search_tls_wrapper(struct ndpi_detection_module_struct *ndpi_struct,\n\t\t\t\t    struct ndpi_flow_struct *flow) {\n  struct ndpi_packet_struct *packet = &flow->packet;\n\n#ifdef DEBUG_TLS\n  printf(\"==>> %s() %u [len: %u][version: %u]\\n\",\n\t __FUNCTION__,\n\t flow->guessed_host_protocol_id,\n\t packet->payload_packet_len,\n\t flow->protos.tls_quic_stun.tls_quic.ssl_version);\n#endif\n\n  if(packet->udp != NULL)\n    ndpi_search_tls_udp(ndpi_struct, flow);\n  else\n    ndpi_search_tls_tcp(ndpi_struct, flow);\n}\n\n/* **************************************** */\n\nvoid init_tls_dissector(struct ndpi_detection_module_struct *ndpi_struct,\n\t\t\tu_int32_t *id, NDPI_PROTOCOL_BITMASK *detection_bitmask) {\n  ndpi_set_bitmask_protocol_detection(\"TLS\", ndpi_struct, detection_bitmask, *id,\n\t\t\t\t      NDPI_PROTOCOL_TLS,\n\t\t\t\t      ndpi_search_tls_wrapper,\n\t\t\t\t      NDPI_SELECTION_BITMASK_PROTOCOL_V4_V6_TCP_WITH_PAYLOAD_WITHOUT_RETRANSMISSION,\n\t\t\t\t      SAVE_DETECTION_BITMASK_AS_UNKNOWN,\n\t\t\t\t      ADD_TO_DETECTION_BITMASK);\n\n  *id += 1;\n\n  /* *************************************************** */\n\n  ndpi_set_bitmask_protocol_detection(\"DTLS\", ndpi_struct, detection_bitmask, *id,\n\t\t\t\t      NDPI_PROTOCOL_DTLS,\n\t\t\t\t      ndpi_search_tls_wrapper,\n\t\t\t\t      NDPI_SELECTION_BITMASK_PROTOCOL_V4_V6_UDP_WITH_PAYLOAD,\n\t\t\t\t      SAVE_DETECTION_BITMASK_AS_UNKNOWN,\n\t\t\t\t      ADD_TO_DETECTION_BITMASK);\n\n  *id += 1;\n}\n"], "filenames": ["src/lib/protocols/netbios.c", "src/lib/protocols/tls.c"], "buggy_code_start_loc": [44, 1372], "buggy_code_end_loc": [45, 2026], "fixing_code_start_loc": [44, 1372], "fixing_code_end_loc": [45, 2028], "type": "CWE-787", "message": "ntop nDPI 3.4 has a stack-based buffer overflow in processClientServerHello.", "other": {"cve": {"id": "CVE-2021-36082", "sourceIdentifier": "cve@mitre.org", "published": "2021-07-01T03:15:08.653", "lastModified": "2021-07-08T17:28:44.590", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "ntop nDPI 3.4 has a stack-based buffer overflow in processClientServerHello."}, {"lang": "es", "value": "ntop nDPI versi\u00f3n 3.4, presenta un desbordamiento de b\u00fafer en la regi\u00f3n stack de la memoria en la funci\u00f3n processClientServerHello"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ntop:ndpi:3.4:*:*:*:*:*:*:*", "matchCriteriaId": "2AC70C5C-563D-4745-A3C7-FF98B6F61ADB"}]}]}], "references": [{"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=30393", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/google/oss-fuzz-vulns/blob/main/vulns/ndpi/OSV-2021-304.yaml", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/ntop/nDPI/commit/1ec621c85b9411cc611652fd57a892cfef478af3", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ntop/nDPI/commit/1ec621c85b9411cc611652fd57a892cfef478af3"}}