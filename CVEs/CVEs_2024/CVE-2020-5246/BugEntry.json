{"buggy_code": ["/*\n * Copyright 2017 Anton Tananaev (anton@traccar.org)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.traccar.database;\n\nimport javax.naming.Context;\nimport javax.naming.NamingEnumeration;\nimport javax.naming.NamingException;\nimport javax.naming.directory.Attribute;\nimport javax.naming.directory.InitialDirContext;\nimport javax.naming.directory.SearchControls;\nimport javax.naming.directory.SearchResult;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.traccar.config.Config;\nimport org.traccar.model.User;\n\nimport java.util.Hashtable;\n\npublic class LdapProvider {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(LdapProvider.class);\n\n    private String url;\n    private String searchBase;\n    private String idAttribute;\n    private String nameAttribute;\n    private String mailAttribute;\n    private String searchFilter;\n    private String adminFilter;\n    private String serviceUser;\n    private String servicePassword;\n\n    public LdapProvider(Config config) {\n        String url = config.getString(\"ldap.url\");\n        if (url != null) {\n            this.url = url;\n        } else {\n            this.url = \"ldap://\" + config.getString(\"ldap.server\") + \":\" + config.getInteger(\"ldap.port\", 389);\n        }\n        this.searchBase = config.getString(\"ldap.base\");\n        this.idAttribute = config.getString(\"ldap.idAttribute\", \"uid\");\n        this.nameAttribute = config.getString(\"ldap.nameAttribute\", \"cn\");\n        this.mailAttribute = config.getString(\"ldap.mailAttribute\", \"mail\");\n        this.searchFilter = config.getString(\"ldap.searchFilter\", \"(\" + idAttribute + \"=:login)\");\n        String adminGroup = config.getString(\"ldap.adminGroup\");\n        this.adminFilter = config.getString(\"ldap.adminFilter\");\n        if (this.adminFilter == null && adminGroup != null) {\n            this.adminFilter = \"(&(\" + idAttribute + \"=:login)(memberOf=\" + adminGroup + \"))\";\n        }\n        this.serviceUser = config.getString(\"ldap.user\");\n        this.servicePassword = config.getString(\"ldap.password\");\n    }\n\n    private InitialDirContext auth(String accountName, String password) throws NamingException {\n        Hashtable<String, String> env = new Hashtable<>();\n        env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n        env.put(Context.PROVIDER_URL, url);\n\n        env.put(Context.SECURITY_AUTHENTICATION, \"simple\");\n        env.put(Context.SECURITY_PRINCIPAL, accountName);\n        env.put(Context.SECURITY_CREDENTIALS, password);\n\n        return new InitialDirContext(env);\n    }\n\n    private boolean isAdmin(String accountName) {\n        if (this.adminFilter != null) {\n            try {\n                InitialDirContext context = initContext();\n                String searchString = adminFilter.replace(\":login\", accountName);\n                SearchControls searchControls = new SearchControls();\n                searchControls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n                NamingEnumeration<SearchResult> results = context.search(searchBase, searchString, searchControls);\n                if (results.hasMoreElements()) {\n                    results.nextElement();\n                    if (results.hasMoreElements()) {\n                        LOGGER.warn(\"Matched multiple users for the accountName: \" + accountName);\n                        return false;\n                    }\n                    return true;\n                }\n            } catch (NamingException e) {\n                return false;\n            }\n        }\n        return false;\n    }\n\n    public InitialDirContext initContext() throws NamingException {\n        return auth(serviceUser, servicePassword);\n    }\n\n    private SearchResult lookupUser(String accountName) throws NamingException {\n        InitialDirContext context = initContext();\n\n        String searchString = searchFilter.replace(\":login\", accountName);\n\n        SearchControls searchControls = new SearchControls();\n        String[] attributeFilter = {idAttribute, nameAttribute, mailAttribute};\n        searchControls.setReturningAttributes(attributeFilter);\n        searchControls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n\n        NamingEnumeration<SearchResult> results = context.search(searchBase, searchString, searchControls);\n\n        SearchResult searchResult = null;\n        if (results.hasMoreElements()) {\n            searchResult = results.nextElement();\n            if (results.hasMoreElements()) {\n                LOGGER.warn(\"Matched multiple users for the accountName: \" + accountName);\n                return null;\n            }\n        }\n\n        return searchResult;\n    }\n\n    public User getUser(String accountName) {\n        SearchResult ldapUser;\n        User user = new User();\n        try {\n            ldapUser = lookupUser(accountName);\n            if (ldapUser != null) {\n                Attribute attribute = ldapUser.getAttributes().get(idAttribute);\n                if (attribute != null) {\n                    user.setLogin((String) attribute.get());\n                } else {\n                    user.setLogin(accountName);\n                }\n                attribute = ldapUser.getAttributes().get(nameAttribute);\n                if (attribute != null) {\n                    user.setName((String) attribute.get());\n                } else {\n                    user.setName(accountName);\n                }\n                attribute = ldapUser.getAttributes().get(mailAttribute);\n                if (attribute != null) {\n                    user.setEmail((String) attribute.get());\n                } else {\n                    user.setEmail(accountName);\n                }\n            }\n            user.setAdministrator(isAdmin(accountName));\n        } catch (NamingException e) {\n            user.setLogin(accountName);\n            user.setName(accountName);\n            user.setEmail(accountName);\n            LOGGER.warn(\"User lookup error\", e);\n        }\n        return user;\n    }\n\n    public boolean login(String username, String password) {\n        try {\n            SearchResult ldapUser = lookupUser(username);\n            if (ldapUser != null) {\n                auth(ldapUser.getNameInNamespace(), password).close();\n                return true;\n            }\n        } catch (NamingException e) {\n            return false;\n        }\n        return false;\n    }\n\n}\n"], "fixing_code": ["/*\n * Copyright 2017 - 2020 Anton Tananaev (anton@traccar.org)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.traccar.database;\n\nimport javax.naming.Context;\nimport javax.naming.NamingEnumeration;\nimport javax.naming.NamingException;\nimport javax.naming.directory.Attribute;\nimport javax.naming.directory.InitialDirContext;\nimport javax.naming.directory.SearchControls;\nimport javax.naming.directory.SearchResult;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.traccar.config.Config;\nimport org.traccar.model.User;\n\nimport java.util.Hashtable;\n\npublic class LdapProvider {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(LdapProvider.class);\n\n    private String url;\n    private String searchBase;\n    private String idAttribute;\n    private String nameAttribute;\n    private String mailAttribute;\n    private String searchFilter;\n    private String adminFilter;\n    private String serviceUser;\n    private String servicePassword;\n\n    public LdapProvider(Config config) {\n        String url = config.getString(\"ldap.url\");\n        if (url != null) {\n            this.url = url;\n        } else {\n            this.url = \"ldap://\" + config.getString(\"ldap.server\") + \":\" + config.getInteger(\"ldap.port\", 389);\n        }\n        this.searchBase = config.getString(\"ldap.base\");\n        this.idAttribute = config.getString(\"ldap.idAttribute\", \"uid\");\n        this.nameAttribute = config.getString(\"ldap.nameAttribute\", \"cn\");\n        this.mailAttribute = config.getString(\"ldap.mailAttribute\", \"mail\");\n        this.searchFilter = config.getString(\"ldap.searchFilter\", \"(\" + idAttribute + \"=:login)\");\n        String adminGroup = config.getString(\"ldap.adminGroup\");\n        this.adminFilter = config.getString(\"ldap.adminFilter\");\n        if (this.adminFilter == null && adminGroup != null) {\n            this.adminFilter = \"(&(\" + idAttribute + \"=:login)(memberOf=\" + adminGroup + \"))\";\n        }\n        this.serviceUser = config.getString(\"ldap.user\");\n        this.servicePassword = config.getString(\"ldap.password\");\n    }\n\n    private InitialDirContext auth(String accountName, String password) throws NamingException {\n        Hashtable<String, String> env = new Hashtable<>();\n        env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n        env.put(Context.PROVIDER_URL, url);\n\n        env.put(Context.SECURITY_AUTHENTICATION, \"simple\");\n        env.put(Context.SECURITY_PRINCIPAL, accountName);\n        env.put(Context.SECURITY_CREDENTIALS, password);\n\n        return new InitialDirContext(env);\n    }\n\n    private boolean isAdmin(String accountName) {\n        if (this.adminFilter != null) {\n            try {\n                InitialDirContext context = initContext();\n                String searchString = adminFilter.replace(\":login\", encodeForLdap(accountName));\n                SearchControls searchControls = new SearchControls();\n                searchControls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n                NamingEnumeration<SearchResult> results = context.search(searchBase, searchString, searchControls);\n                if (results.hasMoreElements()) {\n                    results.nextElement();\n                    if (results.hasMoreElements()) {\n                        LOGGER.warn(\"Matched multiple users for the accountName: \" + accountName);\n                        return false;\n                    }\n                    return true;\n                }\n            } catch (NamingException e) {\n                return false;\n            }\n        }\n        return false;\n    }\n\n    public InitialDirContext initContext() throws NamingException {\n        return auth(serviceUser, servicePassword);\n    }\n\n    private SearchResult lookupUser(String accountName) throws NamingException {\n        InitialDirContext context = initContext();\n\n        String searchString = searchFilter.replace(\":login\", encodeForLdap(accountName));\n\n        SearchControls searchControls = new SearchControls();\n        String[] attributeFilter = {idAttribute, nameAttribute, mailAttribute};\n        searchControls.setReturningAttributes(attributeFilter);\n        searchControls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n\n        NamingEnumeration<SearchResult> results = context.search(searchBase, searchString, searchControls);\n\n        SearchResult searchResult = null;\n        if (results.hasMoreElements()) {\n            searchResult = results.nextElement();\n            if (results.hasMoreElements()) {\n                LOGGER.warn(\"Matched multiple users for the accountName: \" + accountName);\n                return null;\n            }\n        }\n\n        return searchResult;\n    }\n\n    public User getUser(String accountName) {\n        SearchResult ldapUser;\n        User user = new User();\n        try {\n            ldapUser = lookupUser(accountName);\n            if (ldapUser != null) {\n                Attribute attribute = ldapUser.getAttributes().get(idAttribute);\n                if (attribute != null) {\n                    user.setLogin((String) attribute.get());\n                } else {\n                    user.setLogin(accountName);\n                }\n                attribute = ldapUser.getAttributes().get(nameAttribute);\n                if (attribute != null) {\n                    user.setName((String) attribute.get());\n                } else {\n                    user.setName(accountName);\n                }\n                attribute = ldapUser.getAttributes().get(mailAttribute);\n                if (attribute != null) {\n                    user.setEmail((String) attribute.get());\n                } else {\n                    user.setEmail(accountName);\n                }\n            }\n            user.setAdministrator(isAdmin(accountName));\n        } catch (NamingException e) {\n            user.setLogin(accountName);\n            user.setName(accountName);\n            user.setEmail(accountName);\n            LOGGER.warn(\"User lookup error\", e);\n        }\n        return user;\n    }\n\n    public boolean login(String username, String password) {\n        try {\n            SearchResult ldapUser = lookupUser(username);\n            if (ldapUser != null) {\n                auth(ldapUser.getNameInNamespace(), password).close();\n                return true;\n            }\n        } catch (NamingException e) {\n            return false;\n        }\n        return false;\n    }\n\n    public String encodeForLdap(String input) {\n        if( input == null ) {\n            return null;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < input.length(); i++) {\n            char c = input.charAt(i);\n            switch (c) {\n                case '\\\\':\n                    sb.append(\"\\\\5c\");\n                    break;\n                case '*':\n                    sb.append(\"\\\\2a\");\n                    break;\n                case '(':\n                    sb.append(\"\\\\28\");\n                    break;\n                case ')':\n                    sb.append(\"\\\\29\");\n                    break;\n                case '\\0':\n                    sb.append(\"\\\\00\");\n                    break;\n                default:\n                    sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n\n}\n"], "filenames": ["src/main/java/org/traccar/database/LdapProvider.java"], "buggy_code_start_loc": [2], "buggy_code_end_loc": [178], "fixing_code_start_loc": [2], "fixing_code_end_loc": [209], "type": "CWE-74", "message": "Traccar GPS Tracking System before version 4.9 has a LDAP injection vulnerability. It occurs when user input is being used in LDAP search filter. By providing specially crafted input, an attacker can modify the logic of the LDAP query and get admin privileges. The issue only impacts instances with LDAP configuration and where users can craft their own names. This has been patched in version 4.9.", "other": {"cve": {"id": "CVE-2020-5246", "sourceIdentifier": "security-advisories@github.com", "published": "2020-07-14T21:15:10.827", "lastModified": "2020-07-16T19:27:47.627", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Traccar GPS Tracking System before version 4.9 has a LDAP injection vulnerability. It occurs when user input is being used in LDAP search filter. By providing specially crafted input, an attacker can modify the logic of the LDAP query and get admin privileges. The issue only impacts instances with LDAP configuration and where users can craft their own names. This has been patched in version 4.9."}, {"lang": "es", "value": "Traccar GPS Tracking System versiones anteriores a 4.9, presenta una vulnerabilidad de inyecci\u00f3n LDAP. Se produce cuando la entrada del usuario est\u00e1 siendo usada en el filtro de b\u00fasqueda LDAP. Al proporcionar una entrada especialmente dise\u00f1ada, un atacante puede modificar la l\u00f3gica de la consulta LDAP y obtener privilegios de administrador. El problema solo afecta a las instancias con la configuraci\u00f3n LDAP y donde los usuarios pueden crear sus propios nombres. Esto ha sido parcheado en la versi\u00f3n 4.9"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.7, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.1, "impactScore": 4.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-74"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-90"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:traccar:traccar:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.9", "matchCriteriaId": "9045AFF9-6C68-4957-87D0-B85892D37131"}]}]}], "references": [{"url": "https://github.com/traccar/traccar/commit/e4f6e74e57ab743b65d49ae00f6624a20ca0291e", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/traccar/traccar/security/advisories/GHSA-v955-7g22-2p49", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/traccar/traccar/commit/e4f6e74e57ab743b65d49ae00f6624a20ca0291e"}}