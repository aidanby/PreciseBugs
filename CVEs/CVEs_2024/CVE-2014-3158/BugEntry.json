{"buggy_code": ["/*\n * options.c - handles option processing for PPP.\n *\n * Copyright (c) 1984-2000 Carnegie Mellon University. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * 3. The name \"Carnegie Mellon University\" must not be used to\n *    endorse or promote products derived from this software without\n *    prior written permission. For permission or any legal\n *    details, please contact\n *      Office of Technology Transfer\n *      Carnegie Mellon University\n *      5000 Forbes Avenue\n *      Pittsburgh, PA  15213-3890\n *      (412) 268-4387, fax: (412) 268-7395\n *      tech-transfer@andrew.cmu.edu\n *\n * 4. Redistributions of any form whatsoever must retain the following\n *    acknowledgment:\n *    \"This product includes software developed by Computing Services\n *     at Carnegie Mellon University (http://www.cmu.edu/computing/).\"\n *\n * CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO\n * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE\n * FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN\n * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#define RCSID\t\"$Id: options.c,v 1.102 2008/06/15 06:53:06 paulus Exp $\"\n\n#include <ctype.h>\n#include <stdio.h>\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <syslog.h>\n#include <string.h>\n#include <pwd.h>\n#ifdef PLUGIN\n#include <dlfcn.h>\n#endif\n\n#ifdef PPP_FILTER\n#include <pcap.h>\n/*\n * There have been 3 or 4 different names for this in libpcap CVS, but\n * this seems to be what they have settled on...\n * For older versions of libpcap, use DLT_PPP - but that means\n * we lose the inbound and outbound qualifiers.\n */\n#ifndef DLT_PPP_PPPD\n#ifdef DLT_PPP_WITHDIRECTION\n#define DLT_PPP_PPPD\tDLT_PPP_WITHDIRECTION\n#else\n#define DLT_PPP_PPPD\tDLT_PPP\n#endif\n#endif\n#endif /* PPP_FILTER */\n\n#include \"pppd.h\"\n#include \"pathnames.h\"\n\n#if defined(ultrix) || defined(NeXT)\nchar *strdup __P((char *));\n#endif\n\nstatic const char rcsid[] = RCSID;\n\nstruct option_value {\n    struct option_value *next;\n    const char *source;\n    char value[1];\n};\n\n/*\n * Option variables and default values.\n */\nint\tdebug = 0;\t\t/* Debug flag */\nint\tkdebugflag = 0;\t\t/* Tell kernel to print debug messages */\nint\tdefault_device = 1;\t/* Using /dev/tty or equivalent */\nchar\tdevnam[MAXPATHLEN];\t/* Device name */\nbool\tnodetach = 0;\t\t/* Don't detach from controlling tty */\nbool\tupdetach = 0;\t\t/* Detach once link is up */\nbool\tmaster_detach;\t\t/* Detach when we're (only) multilink master */\nint\tmaxconnect = 0;\t\t/* Maximum connect time */\nchar\tuser[MAXNAMELEN];\t/* Username for PAP */\nchar\tpasswd[MAXSECRETLEN];\t/* Password for PAP */\nbool\tpersist = 0;\t\t/* Reopen link after it goes down */\nchar\tour_name[MAXNAMELEN];\t/* Our name for authentication purposes */\nbool\tdemand = 0;\t\t/* do dial-on-demand */\nchar\t*ipparam = NULL;\t/* Extra parameter for ip up/down scripts */\nint\tidle_time_limit = 0;\t/* Disconnect if idle for this many seconds */\nint\tholdoff = 30;\t\t/* # seconds to pause before reconnecting */\nbool\tholdoff_specified;\t/* true if a holdoff value has been given */\nint\tlog_to_fd = 1;\t\t/* send log messages to this fd too */\nbool\tlog_default = 1;\t/* log_to_fd is default (stdout) */\nint\tmaxfail = 10;\t\t/* max # of unsuccessful connection attempts */\nchar\tlinkname[MAXPATHLEN];\t/* logical name for link */\nbool\ttune_kernel;\t\t/* may alter kernel settings */\nint\tconnect_delay = 1000;\t/* wait this many ms after connect script */\nint\treq_unit = -1;\t\t/* requested interface unit */\nbool\tmultilink = 0;\t\t/* Enable multilink operation */\nchar\t*bundle_name = NULL;\t/* bundle name for multilink */\nbool\tdump_options;\t\t/* print out option values */\nbool\tdryrun;\t\t\t/* print out option values and exit */\nchar\t*domain;\t\t/* domain name set by domain option */\nint\tchild_wait = 5;\t\t/* # seconds to wait for children at exit */\nstruct userenv *userenv_list;\t/* user environment variables */\n\n#ifdef MAXOCTETS\nunsigned int  maxoctets = 0;    /* default - no limit */\nint maxoctets_dir = 0;       /* default - sum of traffic */\nint maxoctets_timeout = 1;   /* default 1 second */ \n#endif\n\n\nextern option_t auth_options[];\nextern struct stat devstat;\n\n#ifdef PPP_FILTER\nstruct\tbpf_program pass_filter;/* Filter program for packets to pass */\nstruct\tbpf_program active_filter; /* Filter program for link-active pkts */\n#endif\n\nstatic option_t *curopt;\t/* pointer to option being processed */\nchar *current_option;\t\t/* the name of the option being parsed */\nint  privileged_option;\t\t/* set iff the current option came from root */\nchar *option_source;\t\t/* string saying where the option came from */\nint  option_priority = OPRIO_CFGFILE; /* priority of the current options */\nbool devnam_fixed;\t\t/* can no longer change device name */\n\nstatic int logfile_fd = -1;\t/* fd opened for log file */\nstatic char logfile_name[MAXPATHLEN];\t/* name of log file */\n\n/*\n * Prototypes\n */\nstatic int setdomain __P((char **));\nstatic int readfile __P((char **));\nstatic int callfile __P((char **));\nstatic int showversion __P((char **));\nstatic int showhelp __P((char **));\nstatic void usage __P((void));\nstatic int setlogfile __P((char **));\n#ifdef PLUGIN\nstatic int loadplugin __P((char **));\n#endif\n\n#ifdef PPP_FILTER\nstatic int setpassfilter __P((char **));\nstatic int setactivefilter __P((char **));\n#endif\n\n#ifdef MAXOCTETS\nstatic int setmodir __P((char **));\n#endif\n\nstatic int user_setenv __P((char **));\nstatic void user_setprint __P((option_t *, printer_func, void *));\nstatic int user_unsetenv __P((char **));\nstatic void user_unsetprint __P((option_t *, printer_func, void *));\n\nstatic option_t *find_option __P((const char *name));\nstatic int process_option __P((option_t *, char *, char **));\nstatic int n_arguments __P((option_t *));\nstatic int number_option __P((char *, u_int32_t *, int));\n\n/*\n * Structure to store extra lists of options.\n */\nstruct option_list {\n    option_t *options;\n    struct option_list *next;\n};\n\nstatic struct option_list *extra_options = NULL;\n\n/*\n * Valid arguments.\n */\noption_t general_options[] = {\n    { \"debug\", o_int, &debug,\n      \"Increase debugging level\", OPT_INC | OPT_NOARG | 1 },\n    { \"-d\", o_int, &debug,\n      \"Increase debugging level\",\n      OPT_ALIAS | OPT_INC | OPT_NOARG | 1 },\n\n    { \"kdebug\", o_int, &kdebugflag,\n      \"Set kernel driver debug level\", OPT_PRIO },\n\n    { \"nodetach\", o_bool, &nodetach,\n      \"Don't detach from controlling tty\", OPT_PRIO | 1 },\n    { \"-detach\", o_bool, &nodetach,\n      \"Don't detach from controlling tty\", OPT_ALIAS | OPT_PRIOSUB | 1 },\n    { \"updetach\", o_bool, &updetach,\n      \"Detach from controlling tty once link is up\",\n      OPT_PRIOSUB | OPT_A2CLR | 1, &nodetach },\n\n    { \"master_detach\", o_bool, &master_detach,\n      \"Detach when we're multilink master but have no link\", 1 },\n\n    { \"holdoff\", o_int, &holdoff,\n      \"Set time in seconds before retrying connection\",\n      OPT_PRIO, &holdoff_specified },\n\n    { \"idle\", o_int, &idle_time_limit,\n      \"Set time in seconds before disconnecting idle link\", OPT_PRIO },\n\n    { \"maxconnect\", o_int, &maxconnect,\n      \"Set connection time limit\",\n      OPT_PRIO | OPT_LLIMIT | OPT_NOINCR | OPT_ZEROINF },\n\n    { \"domain\", o_special, (void *)setdomain,\n      \"Add given domain name to hostname\",\n      OPT_PRIO | OPT_PRIV | OPT_A2STRVAL, &domain },\n\n    { \"file\", o_special, (void *)readfile,\n      \"Take options from a file\", OPT_NOPRINT },\n    { \"call\", o_special, (void *)callfile,\n      \"Take options from a privileged file\", OPT_NOPRINT },\n\n    { \"persist\", o_bool, &persist,\n      \"Keep on reopening connection after close\", OPT_PRIO | 1 },\n    { \"nopersist\", o_bool, &persist,\n      \"Turn off persist option\", OPT_PRIOSUB },\n\n    { \"demand\", o_bool, &demand,\n      \"Dial on demand\", OPT_INITONLY | 1, &persist },\n\n    { \"--version\", o_special_noarg, (void *)showversion,\n      \"Show version number\" },\n    { \"--help\", o_special_noarg, (void *)showhelp,\n      \"Show brief listing of options\" },\n    { \"-h\", o_special_noarg, (void *)showhelp,\n      \"Show brief listing of options\", OPT_ALIAS },\n\n    { \"logfile\", o_special, (void *)setlogfile,\n      \"Append log messages to this file\",\n      OPT_PRIO | OPT_A2STRVAL | OPT_STATIC, &logfile_name },\n    { \"logfd\", o_int, &log_to_fd,\n      \"Send log messages to this file descriptor\",\n      OPT_PRIOSUB | OPT_A2CLR, &log_default },\n    { \"nolog\", o_int, &log_to_fd,\n      \"Don't send log messages to any file\",\n      OPT_PRIOSUB | OPT_NOARG | OPT_VAL(-1) },\n    { \"nologfd\", o_int, &log_to_fd,\n      \"Don't send log messages to any file descriptor\",\n      OPT_PRIOSUB | OPT_ALIAS | OPT_NOARG | OPT_VAL(-1) },\n\n    { \"linkname\", o_string, linkname,\n      \"Set logical name for link\",\n      OPT_PRIO | OPT_PRIV | OPT_STATIC, NULL, MAXPATHLEN },\n\n    { \"maxfail\", o_int, &maxfail,\n      \"Maximum number of unsuccessful connection attempts to allow\",\n      OPT_PRIO },\n\n    { \"ktune\", o_bool, &tune_kernel,\n      \"Alter kernel settings as necessary\", OPT_PRIO | 1 },\n    { \"noktune\", o_bool, &tune_kernel,\n      \"Don't alter kernel settings\", OPT_PRIOSUB },\n\n    { \"connect-delay\", o_int, &connect_delay,\n      \"Maximum time (in ms) to wait after connect script finishes\",\n      OPT_PRIO },\n\n    { \"unit\", o_int, &req_unit,\n      \"PPP interface unit number to use if possible\",\n      OPT_PRIO | OPT_LLIMIT, 0, 0 },\n\n    { \"dump\", o_bool, &dump_options,\n      \"Print out option values after parsing all options\", 1 },\n    { \"dryrun\", o_bool, &dryrun,\n      \"Stop after parsing, printing, and checking options\", 1 },\n\n    { \"child-timeout\", o_int, &child_wait,\n      \"Number of seconds to wait for child processes at exit\",\n      OPT_PRIO },\n\n    { \"set\", o_special, (void *)user_setenv,\n      \"Set user environment variable\",\n      OPT_A2PRINTER | OPT_NOPRINT, (void *)user_setprint },\n    { \"unset\", o_special, (void *)user_unsetenv,\n      \"Unset user environment variable\",\n      OPT_A2PRINTER | OPT_NOPRINT, (void *)user_unsetprint },\n\n#ifdef HAVE_MULTILINK\n    { \"multilink\", o_bool, &multilink,\n      \"Enable multilink operation\", OPT_PRIO | 1 },\n    { \"mp\", o_bool, &multilink,\n      \"Enable multilink operation\", OPT_PRIOSUB | OPT_ALIAS | 1 },\n    { \"nomultilink\", o_bool, &multilink,\n      \"Disable multilink operation\", OPT_PRIOSUB | 0 },\n    { \"nomp\", o_bool, &multilink,\n      \"Disable multilink operation\", OPT_PRIOSUB | OPT_ALIAS | 0 },\n\n    { \"bundle\", o_string, &bundle_name,\n      \"Bundle name for multilink\", OPT_PRIO },\n#endif /* HAVE_MULTILINK */\n\n#ifdef PLUGIN\n    { \"plugin\", o_special, (void *)loadplugin,\n      \"Load a plug-in module into pppd\", OPT_PRIV | OPT_A2LIST },\n#endif\n\n#ifdef PPP_FILTER\n    { \"pass-filter\", o_special, setpassfilter,\n      \"set filter for packets to pass\", OPT_PRIO },\n\n    { \"active-filter\", o_special, setactivefilter,\n      \"set filter for active pkts\", OPT_PRIO },\n#endif\n\n#ifdef MAXOCTETS\n    { \"maxoctets\", o_int, &maxoctets,\n      \"Set connection traffic limit\",\n      OPT_PRIO | OPT_LLIMIT | OPT_NOINCR | OPT_ZEROINF },\n    { \"mo\", o_int, &maxoctets,\n      \"Set connection traffic limit\",\n      OPT_ALIAS | OPT_PRIO | OPT_LLIMIT | OPT_NOINCR | OPT_ZEROINF },\n    { \"mo-direction\", o_special, setmodir,\n      \"Set direction for limit traffic (sum,in,out,max)\" },\n    { \"mo-timeout\", o_int, &maxoctets_timeout,\n      \"Check for traffic limit every N seconds\", OPT_PRIO | OPT_LLIMIT | 1 },\n#endif\n\n    { NULL }\n};\n\n#ifndef IMPLEMENTATION\n#define IMPLEMENTATION \"\"\n#endif\n\nstatic char *usage_string = \"\\\npppd version %s\\n\\\nUsage: %s [ options ], where options are:\\n\\\n\t<device>\tCommunicate over the named device\\n\\\n\t<speed>\t\tSet the baud rate to <speed>\\n\\\n\t<loc>:<rem>\tSet the local and/or remote interface IP\\n\\\n\t\t\taddresses.  Either one may be omitted.\\n\\\n\tasyncmap <n>\tSet the desired async map to hex <n>\\n\\\n\tauth\t\tRequire authentication from peer\\n\\\n        connect <p>     Invoke shell command <p> to set up the serial line\\n\\\n\tcrtscts\t\tUse hardware RTS/CTS flow control\\n\\\n\tdefaultroute\tAdd default route through interface\\n\\\n\tfile <f>\tTake options from file <f>\\n\\\n\tmodem\t\tUse modem control lines\\n\\\n\tmru <n>\t\tSet MRU value to <n> for negotiation\\n\\\nSee pppd(8) for more options.\\n\\\n\";\n\n/*\n * parse_args - parse a string of arguments from the command line.\n */\nint\nparse_args(argc, argv)\n    int argc;\n    char **argv;\n{\n    char *arg;\n    option_t *opt;\n    int n;\n\n    privileged_option = privileged;\n    option_source = \"command line\";\n    option_priority = OPRIO_CMDLINE;\n    while (argc > 0) {\n\targ = *argv++;\n\t--argc;\n\topt = find_option(arg);\n\tif (opt == NULL) {\n\t    option_error(\"unrecognized option '%s'\", arg);\n\t    usage();\n\t    return 0;\n\t}\n\tn = n_arguments(opt);\n\tif (argc < n) {\n\t    option_error(\"too few parameters for option %s\", arg);\n\t    return 0;\n\t}\n\tif (!process_option(opt, arg, argv))\n\t    return 0;\n\targc -= n;\n\targv += n;\n    }\n    return 1;\n}\n\n/*\n * options_from_file - Read a string of options from a file,\n * and interpret them.\n */\nint\noptions_from_file(filename, must_exist, check_prot, priv)\n    char *filename;\n    int must_exist;\n    int check_prot;\n    int priv;\n{\n    FILE *f;\n    int i, newline, ret, err;\n    option_t *opt;\n    int oldpriv, n;\n    char *oldsource;\n    uid_t euid;\n    char *argv[MAXARGS];\n    char args[MAXARGS][MAXWORDLEN];\n    char cmd[MAXWORDLEN];\n\n    euid = geteuid();\n    if (check_prot && seteuid(getuid()) == -1) {\n\toption_error(\"unable to drop privileges to open %s: %m\", filename);\n\treturn 0;\n    }\n    f = fopen(filename, \"r\");\n    err = errno;\n    if (check_prot && seteuid(euid) == -1)\n\tfatal(\"unable to regain privileges\");\n    if (f == NULL) {\n\terrno = err;\n\tif (!must_exist) {\n\t    if (err != ENOENT && err != ENOTDIR)\n\t\twarn(\"Warning: can't open options file %s: %m\", filename);\n\t    return 1;\n\t}\n\toption_error(\"Can't open options file %s: %m\", filename);\n\treturn 0;\n    }\n\n    oldpriv = privileged_option;\n    privileged_option = priv;\n    oldsource = option_source;\n    option_source = strdup(filename);\n    if (option_source == NULL)\n\toption_source = \"file\";\n    ret = 0;\n    while (getword(f, cmd, &newline, filename)) {\n\topt = find_option(cmd);\n\tif (opt == NULL) {\n\t    option_error(\"In file %s: unrecognized option '%s'\",\n\t\t\t filename, cmd);\n\t    goto err;\n\t}\n\tn = n_arguments(opt);\n\tfor (i = 0; i < n; ++i) {\n\t    if (!getword(f, args[i], &newline, filename)) {\n\t\toption_error(\n\t\t\t\"In file %s: too few parameters for option '%s'\",\n\t\t\tfilename, cmd);\n\t\tgoto err;\n\t    }\n\t    argv[i] = args[i];\n\t}\n\tif (!process_option(opt, cmd, argv))\n\t    goto err;\n    }\n    ret = 1;\n\nerr:\n    fclose(f);\n    privileged_option = oldpriv;\n    option_source = oldsource;\n    return ret;\n}\n\n/*\n * options_from_user - See if the use has a ~/.ppprc file,\n * and if so, interpret options from it.\n */\nint\noptions_from_user()\n{\n    char *user, *path, *file;\n    int ret;\n    struct passwd *pw;\n    size_t pl;\n\n    pw = getpwuid(getuid());\n    if (pw == NULL || (user = pw->pw_dir) == NULL || user[0] == 0)\n\treturn 1;\n    file = _PATH_USEROPT;\n    pl = strlen(user) + strlen(file) + 2;\n    path = malloc(pl);\n    if (path == NULL)\n\tnovm(\"init file name\");\n    slprintf(path, pl, \"%s/%s\", user, file);\n    option_priority = OPRIO_CFGFILE;\n    ret = options_from_file(path, 0, 1, privileged);\n    free(path);\n    return ret;\n}\n\n/*\n * options_for_tty - See if an options file exists for the serial\n * device, and if so, interpret options from it.\n * We only allow the per-tty options file to override anything from\n * the command line if it is something that the user can't override\n * once it has been set by root; this is done by giving configuration\n * files a lower priority than the command line.\n */\nint\noptions_for_tty()\n{\n    char *dev, *path, *p;\n    int ret;\n    size_t pl;\n\n    dev = devnam;\n    if ((p = strstr(dev, \"/dev/\")) != NULL)\n\tdev = p + 5;\n    if (dev[0] == 0 || strcmp(dev, \"tty\") == 0)\n\treturn 1;\t\t/* don't look for /etc/ppp/options.tty */\n    pl = strlen(_PATH_TTYOPT) + strlen(dev) + 1;\n    path = malloc(pl);\n    if (path == NULL)\n\tnovm(\"tty init file name\");\n    slprintf(path, pl, \"%s%s\", _PATH_TTYOPT, dev);\n    /* Turn slashes into dots, for Solaris case (e.g. /dev/term/a) */\n    for (p = path + strlen(_PATH_TTYOPT); *p != 0; ++p)\n\tif (*p == '/')\n\t    *p = '.';\n    option_priority = OPRIO_CFGFILE;\n    ret = options_from_file(path, 0, 0, 1);\n    free(path);\n    return ret;\n}\n\n/*\n * options_from_list - process a string of options in a wordlist.\n */\nint\noptions_from_list(w, priv)\n    struct wordlist *w;\n    int priv;\n{\n    char *argv[MAXARGS];\n    option_t *opt;\n    int i, n, ret = 0;\n    struct wordlist *w0;\n\n    privileged_option = priv;\n    option_source = \"secrets file\";\n    option_priority = OPRIO_SECFILE;\n\n    while (w != NULL) {\n\topt = find_option(w->word);\n\tif (opt == NULL) {\n\t    option_error(\"In secrets file: unrecognized option '%s'\",\n\t\t\t w->word);\n\t    goto err;\n\t}\n\tn = n_arguments(opt);\n\tw0 = w;\n\tfor (i = 0; i < n; ++i) {\n\t    w = w->next;\n\t    if (w == NULL) {\n\t\toption_error(\n\t\t\t\"In secrets file: too few parameters for option '%s'\",\n\t\t\tw0->word);\n\t\tgoto err;\n\t    }\n\t    argv[i] = w->word;\n\t}\n\tif (!process_option(opt, w0->word, argv))\n\t    goto err;\n\tw = w->next;\n    }\n    ret = 1;\n\nerr:\n    return ret;\n}\n\n/*\n * match_option - see if this option matches an option_t structure.\n */\nstatic int\nmatch_option(name, opt, dowild)\n    char *name;\n    option_t *opt;\n    int dowild;\n{\n\tint (*match) __P((char *, char **, int));\n\n\tif (dowild != (opt->type == o_wild))\n\t\treturn 0;\n\tif (!dowild)\n\t\treturn strcmp(name, opt->name) == 0;\n\tmatch = (int (*) __P((char *, char **, int))) opt->addr;\n\treturn (*match)(name, NULL, 0);\n}\n\n/*\n * find_option - scan the option lists for the various protocols\n * looking for an entry with the given name.\n * This could be optimized by using a hash table.\n */\nstatic option_t *\nfind_option(name)\n    const char *name;\n{\n\toption_t *opt;\n\tstruct option_list *list;\n\tint i, dowild;\n\n\tfor (dowild = 0; dowild <= 1; ++dowild) {\n\t\tfor (opt = general_options; opt->name != NULL; ++opt)\n\t\t\tif (match_option(name, opt, dowild))\n\t\t\t\treturn opt;\n\t\tfor (opt = auth_options; opt->name != NULL; ++opt)\n\t\t\tif (match_option(name, opt, dowild))\n\t\t\t\treturn opt;\n\t\tfor (list = extra_options; list != NULL; list = list->next)\n\t\t\tfor (opt = list->options; opt->name != NULL; ++opt)\n\t\t\t\tif (match_option(name, opt, dowild))\n\t\t\t\t\treturn opt;\n\t\tfor (opt = the_channel->options; opt->name != NULL; ++opt)\n\t\t\tif (match_option(name, opt, dowild))\n\t\t\t\treturn opt;\n\t\tfor (i = 0; protocols[i] != NULL; ++i)\n\t\t\tif ((opt = protocols[i]->options) != NULL)\n\t\t\t\tfor (; opt->name != NULL; ++opt)\n\t\t\t\t\tif (match_option(name, opt, dowild))\n\t\t\t\t\t\treturn opt;\n\t}\n\treturn NULL;\n}\n\n/*\n * process_option - process one new-style option.\n */\nstatic int\nprocess_option(opt, cmd, argv)\n    option_t *opt;\n    char *cmd;\n    char **argv;\n{\n    u_int32_t v;\n    int iv, a;\n    char *sv;\n    int (*parser) __P((char **));\n    int (*wildp) __P((char *, char **, int));\n    char *optopt = (opt->type == o_wild)? \"\": \" option\";\n    int prio = option_priority;\n    option_t *mainopt = opt;\n\n    current_option = opt->name;\n    if ((opt->flags & OPT_PRIVFIX) && privileged_option)\n\tprio += OPRIO_ROOT;\n    while (mainopt->flags & OPT_PRIOSUB)\n\t--mainopt;\n    if (mainopt->flags & OPT_PRIO) {\n\tif (prio < mainopt->priority) {\n\t    /* new value doesn't override old */\n\t    if (prio == OPRIO_CMDLINE && mainopt->priority > OPRIO_ROOT) {\n\t\toption_error(\"%s%s set in %s cannot be overridden\\n\",\n\t\t\t     opt->name, optopt, mainopt->source);\n\t\treturn 0;\n\t    }\n\t    return 1;\n\t}\n\tif (prio > OPRIO_ROOT && mainopt->priority == OPRIO_CMDLINE)\n\t    warn(\"%s%s from %s overrides command line\",\n\t\t opt->name, optopt, option_source);\n    }\n\n    if ((opt->flags & OPT_INITONLY) && phase != PHASE_INITIALIZE) {\n\toption_error(\"%s%s cannot be changed after initialization\",\n\t\t     opt->name, optopt);\n\treturn 0;\n    }\n    if ((opt->flags & OPT_PRIV) && !privileged_option) {\n\toption_error(\"using the %s%s requires root privilege\",\n\t\t     opt->name, optopt);\n\treturn 0;\n    }\n    if ((opt->flags & OPT_ENABLE) && *(bool *)(opt->addr2) == 0) {\n\toption_error(\"%s%s is disabled\", opt->name, optopt);\n\treturn 0;\n    }\n    if ((opt->flags & OPT_DEVEQUIV) && devnam_fixed) {\n\toption_error(\"the %s%s may not be changed in %s\",\n\t\t     opt->name, optopt, option_source);\n\treturn 0;\n    }\n\n    switch (opt->type) {\n    case o_bool:\n\tv = opt->flags & OPT_VALUE;\n\t*(bool *)(opt->addr) = v;\n\tif (opt->addr2 && (opt->flags & OPT_A2COPY))\n\t    *(bool *)(opt->addr2) = v;\n\telse if (opt->addr2 && (opt->flags & OPT_A2CLR))\n\t    *(bool *)(opt->addr2) = 0;\n\telse if (opt->addr2 && (opt->flags & OPT_A2CLRB))\n\t    *(u_char *)(opt->addr2) &= ~v;\n\telse if (opt->addr2 && (opt->flags & OPT_A2OR))\n\t    *(u_char *)(opt->addr2) |= v;\n\tbreak;\n\n    case o_int:\n\tiv = 0;\n\tif ((opt->flags & OPT_NOARG) == 0) {\n\t    if (!int_option(*argv, &iv))\n\t\treturn 0;\n\t    if ((((opt->flags & OPT_LLIMIT) && iv < opt->lower_limit)\n\t\t || ((opt->flags & OPT_ULIMIT) && iv > opt->upper_limit))\n\t\t&& !((opt->flags & OPT_ZEROOK && iv == 0))) {\n\t\tchar *zok = (opt->flags & OPT_ZEROOK)? \" zero or\": \"\";\n\t\tswitch (opt->flags & OPT_LIMITS) {\n\t\tcase OPT_LLIMIT:\n\t\t    option_error(\"%s value must be%s >= %d\",\n\t\t\t\t opt->name, zok, opt->lower_limit);\n\t\t    break;\n\t\tcase OPT_ULIMIT:\n\t\t    option_error(\"%s value must be%s <= %d\",\n\t\t\t\t opt->name, zok, opt->upper_limit);\n\t\t    break;\n\t\tcase OPT_LIMITS:\n\t\t    option_error(\"%s value must be%s between %d and %d\",\n\t\t\t\topt->name, zok, opt->lower_limit, opt->upper_limit);\n\t\t    break;\n\t\t}\n\t\treturn 0;\n\t    }\n\t}\n\ta = opt->flags & OPT_VALUE;\n\tif (a >= 128)\n\t    a -= 256;\t\t/* sign extend */\n\tiv += a;\n\tif (opt->flags & OPT_INC)\n\t    iv += *(int *)(opt->addr);\n\tif ((opt->flags & OPT_NOINCR) && !privileged_option) {\n\t    int oldv = *(int *)(opt->addr);\n\t    if ((opt->flags & OPT_ZEROINF) ?\n\t\t(oldv != 0 && (iv == 0 || iv > oldv)) : (iv > oldv)) {\n\t\toption_error(\"%s value cannot be increased\", opt->name);\n\t\treturn 0;\n\t    }\n\t}\n\t*(int *)(opt->addr) = iv;\n\tif (opt->addr2 && (opt->flags & OPT_A2COPY))\n\t    *(int *)(opt->addr2) = iv;\n\tbreak;\n\n    case o_uint32:\n\tif (opt->flags & OPT_NOARG) {\n\t    v = opt->flags & OPT_VALUE;\n\t    if (v & 0x80)\n\t\t    v |= 0xffffff00U;\n\t} else if (!number_option(*argv, &v, 16))\n\t    return 0;\n\tif (opt->flags & OPT_OR)\n\t    v |= *(u_int32_t *)(opt->addr);\n\t*(u_int32_t *)(opt->addr) = v;\n\tif (opt->addr2 && (opt->flags & OPT_A2COPY))\n\t    *(u_int32_t *)(opt->addr2) = v;\n\tbreak;\n\n    case o_string:\n\tif (opt->flags & OPT_STATIC) {\n\t    strlcpy((char *)(opt->addr), *argv, opt->upper_limit);\n\t} else {\n\t    sv = strdup(*argv);\n\t    if (sv == NULL)\n\t\tnovm(\"option argument\");\n\t    *(char **)(opt->addr) = sv;\n\t}\n\tbreak;\n\n    case o_special_noarg:\n    case o_special:\n\tparser = (int (*) __P((char **))) opt->addr;\n\tcuropt = opt;\n\tif (!(*parser)(argv))\n\t    return 0;\n\tif (opt->flags & OPT_A2LIST) {\n\t    struct option_value *ovp, *pp;\n\n\t    ovp = malloc(sizeof(*ovp) + strlen(*argv));\n\t    if (ovp != 0) {\n\t\tstrcpy(ovp->value, *argv);\n\t\tovp->source = option_source;\n\t\tovp->next = NULL;\n\t\tif (opt->addr2 == NULL) {\n\t\t    opt->addr2 = ovp;\n\t\t} else {\n\t\t    for (pp = opt->addr2; pp->next != NULL; pp = pp->next)\n\t\t\t;\n\t\t    pp->next = ovp;\n\t\t}\n\t    }\n\t}\n\tbreak;\n\n    case o_wild:\n\twildp = (int (*) __P((char *, char **, int))) opt->addr;\n\tif (!(*wildp)(cmd, argv, 1))\n\t    return 0;\n\tbreak;\n    }\n\n    /*\n     * If addr2 wasn't used by any flag (OPT_A2COPY, etc.) but is set,\n     * treat it as a bool and set/clear it based on the OPT_A2CLR bit.\n     */\n    if (opt->addr2 && (opt->flags & (OPT_A2COPY|OPT_ENABLE\n\t\t|OPT_A2PRINTER|OPT_A2STRVAL|OPT_A2LIST|OPT_A2OR)) == 0)\n\t*(bool *)(opt->addr2) = !(opt->flags & OPT_A2CLR);\n\n    mainopt->source = option_source;\n    mainopt->priority = prio;\n    mainopt->winner = opt - mainopt;\n\n    return 1;\n}\n\n/*\n * override_value - if the option priorities would permit us to\n * override the value of option, return 1 and update the priority\n * and source of the option value.  Otherwise returns 0.\n */\nint\noverride_value(option, priority, source)\n    const char *option;\n    int priority;\n    const char *source;\n{\n\toption_t *opt;\n\n\topt = find_option(option);\n\tif (opt == NULL)\n\t\treturn 0;\n\twhile (opt->flags & OPT_PRIOSUB)\n\t\t--opt;\n\tif ((opt->flags & OPT_PRIO) && priority < opt->priority)\n\t\treturn 0;\n\topt->priority = priority;\n\topt->source = source;\n\topt->winner = -1;\n\treturn 1;\n}\n\n/*\n * n_arguments - tell how many arguments an option takes\n */\nstatic int\nn_arguments(opt)\n    option_t *opt;\n{\n\treturn (opt->type == o_bool || opt->type == o_special_noarg\n\t\t|| (opt->flags & OPT_NOARG))? 0: 1;\n}\n\n/*\n * add_options - add a list of options to the set we grok.\n */\nvoid\nadd_options(opt)\n    option_t *opt;\n{\n    struct option_list *list;\n\n    list = malloc(sizeof(*list));\n    if (list == 0)\n\tnovm(\"option list entry\");\n    list->options = opt;\n    list->next = extra_options;\n    extra_options = list;\n}\n\n/*\n * check_options - check that options are valid and consistent.\n */\nvoid\ncheck_options()\n{\n\tif (logfile_fd >= 0 && logfile_fd != log_to_fd)\n\t\tclose(logfile_fd);\n}\n\n/*\n * print_option - print out an option and its value\n */\nstatic void\nprint_option(opt, mainopt, printer, arg)\n    option_t *opt, *mainopt;\n    printer_func printer;\n    void *arg;\n{\n\tint i, v;\n\tchar *p;\n\n\tif (opt->flags & OPT_NOPRINT)\n\t\treturn;\n\tswitch (opt->type) {\n\tcase o_bool:\n\t\tv = opt->flags & OPT_VALUE;\n\t\tif (*(bool *)opt->addr != v)\n\t\t\t/* this can happen legitimately, e.g. lock\n\t\t\t   option turned off for default device */\n\t\t\tbreak;\n\t\tprinter(arg, \"%s\", opt->name);\n\t\tbreak;\n\tcase o_int:\n\t\tv = opt->flags & OPT_VALUE;\n\t\tif (v >= 128)\n\t\t\tv -= 256;\n\t\ti = *(int *)opt->addr;\n\t\tif (opt->flags & OPT_NOARG) {\n\t\t\tprinter(arg, \"%s\", opt->name);\n\t\t\tif (i != v) {\n\t\t\t\tif (opt->flags & OPT_INC) {\n\t\t\t\t\tfor (; i > v; i -= v)\n\t\t\t\t\t\tprinter(arg, \" %s\", opt->name);\n\t\t\t\t} else\n\t\t\t\t\tprinter(arg, \" # oops: %d not %d\\n\",\n\t\t\t\t\t\ti, v);\n\t\t\t}\n\t\t} else {\n\t\t\tprinter(arg, \"%s %d\", opt->name, i);\n\t\t}\n\t\tbreak;\n\tcase o_uint32:\n\t\tprinter(arg, \"%s\", opt->name);\n\t\tif ((opt->flags & OPT_NOARG) == 0)\n\t\t\tprinter(arg, \" %x\", *(u_int32_t *)opt->addr);\n\t\tbreak;\n\n\tcase o_string:\n\t\tif (opt->flags & OPT_HIDE) {\n\t\t\tp = \"??????\";\n\t\t} else {\n\t\t\tp = (char *) opt->addr;\n\t\t\tif ((opt->flags & OPT_STATIC) == 0)\n\t\t\t\tp = *(char **)p;\n\t\t}\n\t\tprinter(arg, \"%s %q\", opt->name, p);\n\t\tbreak;\n\n\tcase o_special:\n\tcase o_special_noarg:\n\tcase o_wild:\n\t\tif (opt->type != o_wild) {\n\t\t\tprinter(arg, \"%s\", opt->name);\n\t\t\tif (n_arguments(opt) == 0)\n\t\t\t\tbreak;\n\t\t\tprinter(arg, \" \");\n\t\t}\n\t\tif (opt->flags & OPT_A2PRINTER) {\n\t\t\tvoid (*oprt) __P((option_t *, printer_func, void *));\n\t\t\toprt = (void (*) __P((option_t *, printer_func,\n\t\t\t\t\t void *)))opt->addr2;\n\t\t\t(*oprt)(opt, printer, arg);\n\t\t} else if (opt->flags & OPT_A2STRVAL) {\n\t\t\tp = (char *) opt->addr2;\n\t\t\tif ((opt->flags & OPT_STATIC) == 0)\n\t\t\t\tp = *(char **)p;\n\t\t\tprinter(\"%q\", p);\n\t\t} else if (opt->flags & OPT_A2LIST) {\n\t\t\tstruct option_value *ovp;\n\n\t\t\tovp = (struct option_value *) opt->addr2;\n\t\t\tfor (;;) {\n\t\t\t\tprinter(arg, \"%q\", ovp->value);\n\t\t\t\tif ((ovp = ovp->next) == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tprinter(arg, \"\\t\\t# (from %s)\\n%s \",\n\t\t\t\t\tovp->source, opt->name);\n\t\t\t}\n\t\t} else {\n\t\t\tprinter(arg, \"xxx # [don't know how to print value]\");\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tprinter(arg, \"# %s value (type %d\\?\\?)\", opt->name, opt->type);\n\t\tbreak;\n\t}\n\tprinter(arg, \"\\t\\t# (from %s)\\n\", mainopt->source);\n}\n\n/*\n * print_option_list - print out options in effect from an\n * array of options.\n */\nstatic void\nprint_option_list(opt, printer, arg)\n    option_t *opt;\n    printer_func printer;\n    void *arg;\n{\n\twhile (opt->name != NULL) {\n\t\tif (opt->priority != OPRIO_DEFAULT\n\t\t    && opt->winner != (short int) -1)\n\t\t\tprint_option(opt + opt->winner, opt, printer, arg);\n\t\tdo {\n\t\t\t++opt;\n\t\t} while (opt->flags & OPT_PRIOSUB);\n\t}\n}\n\n/*\n * print_options - print out what options are in effect.\n */\nvoid\nprint_options(printer, arg)\n    printer_func printer;\n    void *arg;\n{\n\tstruct option_list *list;\n\tint i;\n\n\tprinter(arg, \"pppd options in effect:\\n\");\n\tprint_option_list(general_options, printer, arg);\n\tprint_option_list(auth_options, printer, arg);\n\tfor (list = extra_options; list != NULL; list = list->next)\n\t\tprint_option_list(list->options, printer, arg);\n\tprint_option_list(the_channel->options, printer, arg);\n\tfor (i = 0; protocols[i] != NULL; ++i)\n\t\tprint_option_list(protocols[i]->options, printer, arg);\n}\n\n/*\n * usage - print out a message telling how to use the program.\n */\nstatic void\nusage()\n{\n    if (phase == PHASE_INITIALIZE)\n\tfprintf(stderr, usage_string, VERSION, progname);\n}\n\n/*\n * showhelp - print out usage message and exit.\n */\nstatic int\nshowhelp(argv)\n    char **argv;\n{\n    if (phase == PHASE_INITIALIZE) {\n\tusage();\n\texit(0);\n    }\n    return 0;\n}\n\n/*\n * showversion - print out the version number and exit.\n */\nstatic int\nshowversion(argv)\n    char **argv;\n{\n    if (phase == PHASE_INITIALIZE) {\n\tfprintf(stderr, \"pppd version %s\\n\", VERSION);\n\texit(0);\n    }\n    return 0;\n}\n\n/*\n * option_error - print a message about an error in an option.\n * The message is logged, and also sent to\n * stderr if phase == PHASE_INITIALIZE.\n */\nvoid\noption_error __V((char *fmt, ...))\n{\n    va_list args;\n    char buf[1024];\n\n#if defined(__STDC__)\n    va_start(args, fmt);\n#else\n    char *fmt;\n    va_start(args);\n    fmt = va_arg(args, char *);\n#endif\n    vslprintf(buf, sizeof(buf), fmt, args);\n    va_end(args);\n    if (phase == PHASE_INITIALIZE)\n\tfprintf(stderr, \"%s: %s\\n\", progname, buf);\n    syslog(LOG_ERR, \"%s\", buf);\n}\n\n#if 0\n/*\n * readable - check if a file is readable by the real user.\n */\nint\nreadable(fd)\n    int fd;\n{\n    uid_t uid;\n    int i;\n    struct stat sbuf;\n\n    uid = getuid();\n    if (uid == 0)\n\treturn 1;\n    if (fstat(fd, &sbuf) != 0)\n\treturn 0;\n    if (sbuf.st_uid == uid)\n\treturn sbuf.st_mode & S_IRUSR;\n    if (sbuf.st_gid == getgid())\n\treturn sbuf.st_mode & S_IRGRP;\n    for (i = 0; i < ngroups; ++i)\n\tif (sbuf.st_gid == groups[i])\n\t    return sbuf.st_mode & S_IRGRP;\n    return sbuf.st_mode & S_IROTH;\n}\n#endif\n\n/*\n * Read a word from a file.\n * Words are delimited by white-space or by quotes (\" or ').\n * Quotes, white-space and \\ may be escaped with \\.\n * \\<newline> is ignored.\n */\nint\ngetword(f, word, newlinep, filename)\n    FILE *f;\n    char *word;\n    int *newlinep;\n    char *filename;\n{\n    int c, len, escape;\n    int quoted, comment;\n    int value, digit, got, n;\n\n#define isoctal(c) ((c) >= '0' && (c) < '8')\n\n    *newlinep = 0;\n    len = 0;\n    escape = 0;\n    comment = 0;\n    quoted = 0;\n\n    /*\n     * First skip white-space and comments.\n     */\n    for (;;) {\n\tc = getc(f);\n\tif (c == EOF)\n\t    break;\n\n\t/*\n\t * A newline means the end of a comment; backslash-newline\n\t * is ignored.  Note that we cannot have escape && comment.\n\t */\n\tif (c == '\\n') {\n\t    if (!escape) {\n\t\t*newlinep = 1;\n\t\tcomment = 0;\n\t    } else\n\t\tescape = 0;\n\t    continue;\n\t}\n\n\t/*\n\t * Ignore characters other than newline in a comment.\n\t */\n\tif (comment)\n\t    continue;\n\n\t/*\n\t * If this character is escaped, we have a word start.\n\t */\n\tif (escape)\n\t    break;\n\n\t/*\n\t * If this is the escape character, look at the next character.\n\t */\n\tif (c == '\\\\') {\n\t    escape = 1;\n\t    continue;\n\t}\n\n\t/*\n\t * If this is the start of a comment, ignore the rest of the line.\n\t */\n\tif (c == '#') {\n\t    comment = 1;\n\t    continue;\n\t}\n\n\t/*\n\t * A non-whitespace character is the start of a word.\n\t */\n\tif (!isspace(c))\n\t    break;\n    }\n\n    /*\n     * Process characters until the end of the word.\n     */\n    while (c != EOF) {\n\tif (escape) {\n\t    /*\n\t     * This character is escaped: backslash-newline is ignored,\n\t     * various other characters indicate particular values\n\t     * as for C backslash-escapes.\n\t     */\n\t    escape = 0;\n\t    if (c == '\\n') {\n\t        c = getc(f);\n\t\tcontinue;\n\t    }\n\n\t    got = 0;\n\t    switch (c) {\n\t    case 'a':\n\t\tvalue = '\\a';\n\t\tbreak;\n\t    case 'b':\n\t\tvalue = '\\b';\n\t\tbreak;\n\t    case 'f':\n\t\tvalue = '\\f';\n\t\tbreak;\n\t    case 'n':\n\t\tvalue = '\\n';\n\t\tbreak;\n\t    case 'r':\n\t\tvalue = '\\r';\n\t\tbreak;\n\t    case 's':\n\t\tvalue = ' ';\n\t\tbreak;\n\t    case 't':\n\t\tvalue = '\\t';\n\t\tbreak;\n\n\t    default:\n\t\tif (isoctal(c)) {\n\t\t    /*\n\t\t     * \\ddd octal sequence\n\t\t     */\n\t\t    value = 0;\n\t\t    for (n = 0; n < 3 && isoctal(c); ++n) {\n\t\t\tvalue = (value << 3) + (c & 07);\n\t\t\tc = getc(f);\n\t\t    }\n\t\t    got = 1;\n\t\t    break;\n\t\t}\n\n\t\tif (c == 'x') {\n\t\t    /*\n\t\t     * \\x<hex_string> sequence\n\t\t     */\n\t\t    value = 0;\n\t\t    c = getc(f);\n\t\t    for (n = 0; n < 2 && isxdigit(c); ++n) {\n\t\t\tdigit = toupper(c) - '0';\n\t\t\tif (digit > 10)\n\t\t\t    digit += '0' + 10 - 'A';\n\t\t\tvalue = (value << 4) + digit;\n\t\t\tc = getc (f);\n\t\t    }\n\t\t    got = 1;\n\t\t    break;\n\t\t}\n\n\t\t/*\n\t\t * Otherwise the character stands for itself.\n\t\t */\n\t\tvalue = c;\n\t\tbreak;\n\t    }\n\n\t    /*\n\t     * Store the resulting character for the escape sequence.\n\t     */\n\t    if (len < MAXWORDLEN-1)\n\t\tword[len] = value;\n\t    ++len;\n\n\t    if (!got)\n\t\tc = getc(f);\n\t    continue;\n\t}\n\n\t/*\n\t * Backslash starts a new escape sequence.\n\t */\n\tif (c == '\\\\') {\n\t    escape = 1;\n\t    c = getc(f);\n\t    continue;\n\t}\n\n\t/*\n\t * Not escaped: check for the start or end of a quoted\n\t * section and see if we've reached the end of the word.\n\t */\n\tif (quoted) {\n\t    if (c == quoted) {\n\t\tquoted = 0;\n\t\tc = getc(f);\n\t\tcontinue;\n\t    }\n\t} else if (c == '\"' || c == '\\'') {\n\t    quoted = c;\n\t    c = getc(f);\n\t    continue;\n\t} else if (isspace(c) || c == '#') {\n\t    ungetc (c, f);\n\t    break;\n\t}\n\n\t/*\n\t * An ordinary character: store it in the word and get another.\n\t */\n\tif (len < MAXWORDLEN-1)\n\t    word[len] = c;\n\t++len;\n\n\tc = getc(f);\n    }\n\n    /*\n     * End of the word: check for errors.\n     */\n    if (c == EOF) {\n\tif (ferror(f)) {\n\t    if (errno == 0)\n\t\terrno = EIO;\n\t    option_error(\"Error reading %s: %m\", filename);\n\t    die(1);\n\t}\n\t/*\n\t * If len is zero, then we didn't find a word before the\n\t * end of the file.\n\t */\n\tif (len == 0)\n\t    return 0;\n\tif (quoted)\n\t    option_error(\"warning: quoted word runs to end of file (%.20s...)\",\n\t\t\t filename, word);\n    }\n\n    /*\n     * Warn if the word was too long, and append a terminating null.\n     */\n    if (len >= MAXWORDLEN) {\n\toption_error(\"warning: word in file %s too long (%.20s...)\",\n\t\t     filename, word);\n\tlen = MAXWORDLEN - 1;\n    }\n    word[len] = 0;\n\n    return 1;\n\n#undef isoctal\n\n}\n\n/*\n * number_option - parse an unsigned numeric parameter for an option.\n */\nstatic int\nnumber_option(str, valp, base)\n    char *str;\n    u_int32_t *valp;\n    int base;\n{\n    char *ptr;\n\n    *valp = strtoul(str, &ptr, base);\n    if (ptr == str) {\n\toption_error(\"invalid numeric parameter '%s' for %s option\",\n\t\t     str, current_option);\n\treturn 0;\n    }\n    return 1;\n}\n\n\n/*\n * int_option - like number_option, but valp is int *,\n * the base is assumed to be 0, and *valp is not changed\n * if there is an error.\n */\nint\nint_option(str, valp)\n    char *str;\n    int *valp;\n{\n    u_int32_t v;\n\n    if (!number_option(str, &v, 0))\n\treturn 0;\n    *valp = (int) v;\n    return 1;\n}\n\n\n/*\n * The following procedures parse options.\n */\n\n/*\n * readfile - take commands from a file.\n */\nstatic int\nreadfile(argv)\n    char **argv;\n{\n    return options_from_file(*argv, 1, 1, privileged_option);\n}\n\n/*\n * callfile - take commands from /etc/ppp/peers/<name>.\n * Name may not contain /../, start with / or ../, or end in /..\n */\nstatic int\ncallfile(argv)\n    char **argv;\n{\n    char *fname, *arg, *p;\n    int l, ok;\n\n    arg = *argv;\n    ok = 1;\n    if (arg[0] == '/' || arg[0] == 0)\n\tok = 0;\n    else {\n\tfor (p = arg; *p != 0; ) {\n\t    if (p[0] == '.' && p[1] == '.' && (p[2] == '/' || p[2] == 0)) {\n\t\tok = 0;\n\t\tbreak;\n\t    }\n\t    while (*p != '/' && *p != 0)\n\t\t++p;\n\t    if (*p == '/')\n\t\t++p;\n\t}\n    }\n    if (!ok) {\n\toption_error(\"call option value may not contain .. or start with /\");\n\treturn 0;\n    }\n\n    l = strlen(arg) + strlen(_PATH_PEERFILES) + 1;\n    if ((fname = (char *) malloc(l)) == NULL)\n\tnovm(\"call file name\");\n    slprintf(fname, l, \"%s%s\", _PATH_PEERFILES, arg);\n\n    ok = options_from_file(fname, 1, 1, 1);\n\n    free(fname);\n    return ok;\n}\n\n#ifdef PPP_FILTER\n/*\n * setpassfilter - Set the pass filter for packets\n */\nstatic int\nsetpassfilter(argv)\n    char **argv;\n{\n    pcap_t *pc;\n    int ret = 1;\n\n    pc = pcap_open_dead(DLT_PPP_PPPD, 65535);\n    if (pcap_compile(pc, &pass_filter, *argv, 1, netmask) == -1) {\n\toption_error(\"error in pass-filter expression: %s\\n\",\n\t\t     pcap_geterr(pc));\n\tret = 0;\n    }\n    pcap_close(pc);\n\n    return ret;\n}\n\n/*\n * setactivefilter - Set the active filter for packets\n */\nstatic int\nsetactivefilter(argv)\n    char **argv;\n{\n    pcap_t *pc;\n    int ret = 1;\n\n    pc = pcap_open_dead(DLT_PPP_PPPD, 65535);\n    if (pcap_compile(pc, &active_filter, *argv, 1, netmask) == -1) {\n\toption_error(\"error in active-filter expression: %s\\n\",\n\t\t     pcap_geterr(pc));\n\tret = 0;\n    }\n    pcap_close(pc);\n\n    return ret;\n}\n#endif\n\n/*\n * setdomain - Set domain name to append to hostname \n */\nstatic int\nsetdomain(argv)\n    char **argv;\n{\n    gethostname(hostname, MAXNAMELEN);\n    if (**argv != 0) {\n\tif (**argv != '.')\n\t    strncat(hostname, \".\", MAXNAMELEN - strlen(hostname));\n\tdomain = hostname + strlen(hostname);\n\tstrncat(hostname, *argv, MAXNAMELEN - strlen(hostname));\n    }\n    hostname[MAXNAMELEN-1] = 0;\n    return (1);\n}\n\nstatic int\nsetlogfile(argv)\n    char **argv;\n{\n    int fd, err;\n    uid_t euid;\n\n    euid = geteuid();\n    if (!privileged_option && seteuid(getuid()) == -1) {\n\toption_error(\"unable to drop permissions to open %s: %m\", *argv);\n\treturn 0;\n    }\n    fd = open(*argv, O_WRONLY | O_APPEND | O_CREAT | O_EXCL, 0644);\n    if (fd < 0 && errno == EEXIST)\n\tfd = open(*argv, O_WRONLY | O_APPEND);\n    err = errno;\n    if (!privileged_option && seteuid(euid) == -1)\n\tfatal(\"unable to regain privileges: %m\");\n    if (fd < 0) {\n\terrno = err;\n\toption_error(\"Can't open log file %s: %m\", *argv);\n\treturn 0;\n    }\n    strlcpy(logfile_name, *argv, sizeof(logfile_name));\n    if (logfile_fd >= 0)\n\tclose(logfile_fd);\n    logfile_fd = fd;\n    log_to_fd = fd;\n    log_default = 0;\n    return 1;\n}\n\n#ifdef MAXOCTETS\nstatic int\nsetmodir(argv)\n    char **argv;\n{\n    if(*argv == NULL)\n\treturn 0;\n    if(!strcmp(*argv,\"in\")) {\n        maxoctets_dir = PPP_OCTETS_DIRECTION_IN;\n    } else if (!strcmp(*argv,\"out\")) {\n        maxoctets_dir = PPP_OCTETS_DIRECTION_OUT;\n    } else if (!strcmp(*argv,\"max\")) {\n        maxoctets_dir = PPP_OCTETS_DIRECTION_MAXOVERAL;\n    } else {\n        maxoctets_dir = PPP_OCTETS_DIRECTION_SUM;\n    }\n    return 1;\n}\n#endif\n\n#ifdef PLUGIN\nstatic int\nloadplugin(argv)\n    char **argv;\n{\n    char *arg = *argv;\n    void *handle;\n    const char *err;\n    void (*init) __P((void));\n    char *path = arg;\n    const char *vers;\n\n    if (strchr(arg, '/') == 0) {\n\tconst char *base = _PATH_PLUGIN;\n\tint l = strlen(base) + strlen(arg) + 2;\n\tpath = malloc(l);\n\tif (path == 0)\n\t    novm(\"plugin file path\");\n\tstrlcpy(path, base, l);\n\tstrlcat(path, \"/\", l);\n\tstrlcat(path, arg, l);\n    }\n    handle = dlopen(path, RTLD_GLOBAL | RTLD_NOW);\n    if (handle == 0) {\n\terr = dlerror();\n\tif (err != 0)\n\t    option_error(\"%s\", err);\n\toption_error(\"Couldn't load plugin %s\", arg);\n\tgoto err;\n    }\n    init = (void (*)(void))dlsym(handle, \"plugin_init\");\n    if (init == 0) {\n\toption_error(\"%s has no initialization entry point\", arg);\n\tgoto errclose;\n    }\n    vers = (const char *) dlsym(handle, \"pppd_version\");\n    if (vers == 0) {\n\twarn(\"Warning: plugin %s has no version information\", arg);\n    } else if (strcmp(vers, VERSION) != 0) {\n\toption_error(\"Plugin %s is for pppd version %s, this is %s\",\n\t\t     arg, vers, VERSION);\n\tgoto errclose;\n    }\n    info(\"Plugin %s loaded.\", arg);\n    (*init)();\n    return 1;\n\n errclose:\n    dlclose(handle);\n err:\n    if (path != arg)\n\tfree(path);\n    return 0;\n}\n#endif /* PLUGIN */\n\n/*\n * Set an environment variable specified by the user.\n */\nstatic int\nuser_setenv(argv)\n    char **argv;\n{\n    char *arg = argv[0];\n    char *eqp;\n    struct userenv *uep, **insp;\n\n    if ((eqp = strchr(arg, '=')) == NULL) {\n\toption_error(\"missing = in name=value: %s\", arg);\n\treturn 0;\n    }\n    if (eqp == arg) {\n\toption_error(\"missing variable name: %s\", arg);\n\treturn 0;\n    }\n    for (uep = userenv_list; uep != NULL; uep = uep->ue_next) {\n\tint nlen = strlen(uep->ue_name);\n\tif (nlen == (eqp - arg) &&\n\t    strncmp(arg, uep->ue_name, nlen) == 0)\n\t    break;\n    }\n    /* Ignore attempts by unprivileged users to override privileged sources */\n    if (uep != NULL && !privileged_option && uep->ue_priv)\n\treturn 1;\n    /* The name never changes, so allocate it with the structure */\n    if (uep == NULL) {\n\tuep = malloc(sizeof (*uep) + (eqp-arg));\n\tstrncpy(uep->ue_name, arg, eqp-arg);\n\tuep->ue_name[eqp-arg] = '\\0';\n\tuep->ue_next = NULL;\n\tinsp = &userenv_list;\n\twhile (*insp != NULL)\n\t    insp = &(*insp)->ue_next;\n\t*insp = uep;\n    } else {\n\tstruct userenv *uep2;\n\tfor (uep2 = userenv_list; uep2 != NULL; uep2 = uep2->ue_next) {\n\t    if (uep2 != uep && !uep2->ue_isset)\n\t\tbreak;\n\t}\n\tif (uep2 == NULL && !uep->ue_isset)\n\t    find_option(\"unset\")->flags |= OPT_NOPRINT;\n\tfree(uep->ue_value);\n    }\n    uep->ue_isset = 1;\n    uep->ue_priv = privileged_option;\n    uep->ue_source = option_source;\n    uep->ue_value = strdup(eqp + 1);\n    curopt->flags &= ~OPT_NOPRINT;\n    return 1;\n}\n\nstatic void\nuser_setprint(opt, printer, arg)\n    option_t *opt;\n    printer_func printer;\n    void *arg;\n{\n    struct userenv *uep, *uepnext;\n\n    uepnext = userenv_list;\n    while (uepnext != NULL && !uepnext->ue_isset)\n\tuepnext = uepnext->ue_next;\n    while ((uep = uepnext) != NULL) {\n\tuepnext = uep->ue_next;\n\twhile (uepnext != NULL && !uepnext->ue_isset)\n\t    uepnext = uepnext->ue_next;\n\t(*printer)(arg, \"%s=%s\", uep->ue_name, uep->ue_value);\n\tif (uepnext != NULL)\n\t    (*printer)(arg, \"\\t\\t# (from %s)\\n%s \", uep->ue_source, opt->name);\n\telse\n\t    opt->source = uep->ue_source;\n    }\n}\n\nstatic int\nuser_unsetenv(argv)\n    char **argv;\n{\n    struct userenv *uep, **insp;\n    char *arg = argv[0];\n\n    if (strchr(arg, '=') != NULL) {\n\toption_error(\"unexpected = in name: %s\", arg);\n\treturn 0;\n    }\n    if (arg == '\\0') {\n\toption_error(\"missing variable name for unset\");\n\treturn 0;\n    }\n    for (uep = userenv_list; uep != NULL; uep = uep->ue_next) {\n\tif (strcmp(arg, uep->ue_name) == 0)\n\t    break;\n    }\n    /* Ignore attempts by unprivileged users to override privileged sources */\n    if (uep != NULL && !privileged_option && uep->ue_priv)\n\treturn 1;\n    /* The name never changes, so allocate it with the structure */\n    if (uep == NULL) {\n\tuep = malloc(sizeof (*uep) + strlen(arg));\n\tstrcpy(uep->ue_name, arg);\n\tuep->ue_next = NULL;\n\tinsp = &userenv_list;\n\twhile (*insp != NULL)\n\t    insp = &(*insp)->ue_next;\n\t*insp = uep;\n    } else {\n\tstruct userenv *uep2;\n\tfor (uep2 = userenv_list; uep2 != NULL; uep2 = uep2->ue_next) {\n\t    if (uep2 != uep && uep2->ue_isset)\n\t\tbreak;\n\t}\n\tif (uep2 == NULL && uep->ue_isset)\n\t    find_option(\"set\")->flags |= OPT_NOPRINT;\n\tfree(uep->ue_value);\n    }\n    uep->ue_isset = 0;\n    uep->ue_priv = privileged_option;\n    uep->ue_source = option_source;\n    uep->ue_value = NULL;\n    curopt->flags &= ~OPT_NOPRINT;\n    return 1;\n}\n\nstatic void\nuser_unsetprint(opt, printer, arg)\n    option_t *opt;\n    printer_func printer;\n    void *arg;\n{\n    struct userenv *uep, *uepnext;\n\n    uepnext = userenv_list;\n    while (uepnext != NULL && uepnext->ue_isset)\n\tuepnext = uepnext->ue_next;\n    while ((uep = uepnext) != NULL) {\n\tuepnext = uep->ue_next;\n\twhile (uepnext != NULL && uepnext->ue_isset)\n\t    uepnext = uepnext->ue_next;\n\t(*printer)(arg, \"%s\", uep->ue_name);\n\tif (uepnext != NULL)\n\t    (*printer)(arg, \"\\t\\t# (from %s)\\n%s \", uep->ue_source, opt->name);\n\telse\n\t    opt->source = uep->ue_source;\n    }\n}\n"], "fixing_code": ["/*\n * options.c - handles option processing for PPP.\n *\n * Copyright (c) 1984-2000 Carnegie Mellon University. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * 3. The name \"Carnegie Mellon University\" must not be used to\n *    endorse or promote products derived from this software without\n *    prior written permission. For permission or any legal\n *    details, please contact\n *      Office of Technology Transfer\n *      Carnegie Mellon University\n *      5000 Forbes Avenue\n *      Pittsburgh, PA  15213-3890\n *      (412) 268-4387, fax: (412) 268-7395\n *      tech-transfer@andrew.cmu.edu\n *\n * 4. Redistributions of any form whatsoever must retain the following\n *    acknowledgment:\n *    \"This product includes software developed by Computing Services\n *     at Carnegie Mellon University (http://www.cmu.edu/computing/).\"\n *\n * CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO\n * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE\n * FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN\n * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#define RCSID\t\"$Id: options.c,v 1.102 2008/06/15 06:53:06 paulus Exp $\"\n\n#include <ctype.h>\n#include <stdio.h>\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <syslog.h>\n#include <string.h>\n#include <pwd.h>\n#ifdef PLUGIN\n#include <dlfcn.h>\n#endif\n\n#ifdef PPP_FILTER\n#include <pcap.h>\n/*\n * There have been 3 or 4 different names for this in libpcap CVS, but\n * this seems to be what they have settled on...\n * For older versions of libpcap, use DLT_PPP - but that means\n * we lose the inbound and outbound qualifiers.\n */\n#ifndef DLT_PPP_PPPD\n#ifdef DLT_PPP_WITHDIRECTION\n#define DLT_PPP_PPPD\tDLT_PPP_WITHDIRECTION\n#else\n#define DLT_PPP_PPPD\tDLT_PPP\n#endif\n#endif\n#endif /* PPP_FILTER */\n\n#include \"pppd.h\"\n#include \"pathnames.h\"\n\n#if defined(ultrix) || defined(NeXT)\nchar *strdup __P((char *));\n#endif\n\nstatic const char rcsid[] = RCSID;\n\nstruct option_value {\n    struct option_value *next;\n    const char *source;\n    char value[1];\n};\n\n/*\n * Option variables and default values.\n */\nint\tdebug = 0;\t\t/* Debug flag */\nint\tkdebugflag = 0;\t\t/* Tell kernel to print debug messages */\nint\tdefault_device = 1;\t/* Using /dev/tty or equivalent */\nchar\tdevnam[MAXPATHLEN];\t/* Device name */\nbool\tnodetach = 0;\t\t/* Don't detach from controlling tty */\nbool\tupdetach = 0;\t\t/* Detach once link is up */\nbool\tmaster_detach;\t\t/* Detach when we're (only) multilink master */\nint\tmaxconnect = 0;\t\t/* Maximum connect time */\nchar\tuser[MAXNAMELEN];\t/* Username for PAP */\nchar\tpasswd[MAXSECRETLEN];\t/* Password for PAP */\nbool\tpersist = 0;\t\t/* Reopen link after it goes down */\nchar\tour_name[MAXNAMELEN];\t/* Our name for authentication purposes */\nbool\tdemand = 0;\t\t/* do dial-on-demand */\nchar\t*ipparam = NULL;\t/* Extra parameter for ip up/down scripts */\nint\tidle_time_limit = 0;\t/* Disconnect if idle for this many seconds */\nint\tholdoff = 30;\t\t/* # seconds to pause before reconnecting */\nbool\tholdoff_specified;\t/* true if a holdoff value has been given */\nint\tlog_to_fd = 1;\t\t/* send log messages to this fd too */\nbool\tlog_default = 1;\t/* log_to_fd is default (stdout) */\nint\tmaxfail = 10;\t\t/* max # of unsuccessful connection attempts */\nchar\tlinkname[MAXPATHLEN];\t/* logical name for link */\nbool\ttune_kernel;\t\t/* may alter kernel settings */\nint\tconnect_delay = 1000;\t/* wait this many ms after connect script */\nint\treq_unit = -1;\t\t/* requested interface unit */\nbool\tmultilink = 0;\t\t/* Enable multilink operation */\nchar\t*bundle_name = NULL;\t/* bundle name for multilink */\nbool\tdump_options;\t\t/* print out option values */\nbool\tdryrun;\t\t\t/* print out option values and exit */\nchar\t*domain;\t\t/* domain name set by domain option */\nint\tchild_wait = 5;\t\t/* # seconds to wait for children at exit */\nstruct userenv *userenv_list;\t/* user environment variables */\n\n#ifdef MAXOCTETS\nunsigned int  maxoctets = 0;    /* default - no limit */\nint maxoctets_dir = 0;       /* default - sum of traffic */\nint maxoctets_timeout = 1;   /* default 1 second */ \n#endif\n\n\nextern option_t auth_options[];\nextern struct stat devstat;\n\n#ifdef PPP_FILTER\nstruct\tbpf_program pass_filter;/* Filter program for packets to pass */\nstruct\tbpf_program active_filter; /* Filter program for link-active pkts */\n#endif\n\nstatic option_t *curopt;\t/* pointer to option being processed */\nchar *current_option;\t\t/* the name of the option being parsed */\nint  privileged_option;\t\t/* set iff the current option came from root */\nchar *option_source;\t\t/* string saying where the option came from */\nint  option_priority = OPRIO_CFGFILE; /* priority of the current options */\nbool devnam_fixed;\t\t/* can no longer change device name */\n\nstatic int logfile_fd = -1;\t/* fd opened for log file */\nstatic char logfile_name[MAXPATHLEN];\t/* name of log file */\n\n/*\n * Prototypes\n */\nstatic int setdomain __P((char **));\nstatic int readfile __P((char **));\nstatic int callfile __P((char **));\nstatic int showversion __P((char **));\nstatic int showhelp __P((char **));\nstatic void usage __P((void));\nstatic int setlogfile __P((char **));\n#ifdef PLUGIN\nstatic int loadplugin __P((char **));\n#endif\n\n#ifdef PPP_FILTER\nstatic int setpassfilter __P((char **));\nstatic int setactivefilter __P((char **));\n#endif\n\n#ifdef MAXOCTETS\nstatic int setmodir __P((char **));\n#endif\n\nstatic int user_setenv __P((char **));\nstatic void user_setprint __P((option_t *, printer_func, void *));\nstatic int user_unsetenv __P((char **));\nstatic void user_unsetprint __P((option_t *, printer_func, void *));\n\nstatic option_t *find_option __P((const char *name));\nstatic int process_option __P((option_t *, char *, char **));\nstatic int n_arguments __P((option_t *));\nstatic int number_option __P((char *, u_int32_t *, int));\n\n/*\n * Structure to store extra lists of options.\n */\nstruct option_list {\n    option_t *options;\n    struct option_list *next;\n};\n\nstatic struct option_list *extra_options = NULL;\n\n/*\n * Valid arguments.\n */\noption_t general_options[] = {\n    { \"debug\", o_int, &debug,\n      \"Increase debugging level\", OPT_INC | OPT_NOARG | 1 },\n    { \"-d\", o_int, &debug,\n      \"Increase debugging level\",\n      OPT_ALIAS | OPT_INC | OPT_NOARG | 1 },\n\n    { \"kdebug\", o_int, &kdebugflag,\n      \"Set kernel driver debug level\", OPT_PRIO },\n\n    { \"nodetach\", o_bool, &nodetach,\n      \"Don't detach from controlling tty\", OPT_PRIO | 1 },\n    { \"-detach\", o_bool, &nodetach,\n      \"Don't detach from controlling tty\", OPT_ALIAS | OPT_PRIOSUB | 1 },\n    { \"updetach\", o_bool, &updetach,\n      \"Detach from controlling tty once link is up\",\n      OPT_PRIOSUB | OPT_A2CLR | 1, &nodetach },\n\n    { \"master_detach\", o_bool, &master_detach,\n      \"Detach when we're multilink master but have no link\", 1 },\n\n    { \"holdoff\", o_int, &holdoff,\n      \"Set time in seconds before retrying connection\",\n      OPT_PRIO, &holdoff_specified },\n\n    { \"idle\", o_int, &idle_time_limit,\n      \"Set time in seconds before disconnecting idle link\", OPT_PRIO },\n\n    { \"maxconnect\", o_int, &maxconnect,\n      \"Set connection time limit\",\n      OPT_PRIO | OPT_LLIMIT | OPT_NOINCR | OPT_ZEROINF },\n\n    { \"domain\", o_special, (void *)setdomain,\n      \"Add given domain name to hostname\",\n      OPT_PRIO | OPT_PRIV | OPT_A2STRVAL, &domain },\n\n    { \"file\", o_special, (void *)readfile,\n      \"Take options from a file\", OPT_NOPRINT },\n    { \"call\", o_special, (void *)callfile,\n      \"Take options from a privileged file\", OPT_NOPRINT },\n\n    { \"persist\", o_bool, &persist,\n      \"Keep on reopening connection after close\", OPT_PRIO | 1 },\n    { \"nopersist\", o_bool, &persist,\n      \"Turn off persist option\", OPT_PRIOSUB },\n\n    { \"demand\", o_bool, &demand,\n      \"Dial on demand\", OPT_INITONLY | 1, &persist },\n\n    { \"--version\", o_special_noarg, (void *)showversion,\n      \"Show version number\" },\n    { \"--help\", o_special_noarg, (void *)showhelp,\n      \"Show brief listing of options\" },\n    { \"-h\", o_special_noarg, (void *)showhelp,\n      \"Show brief listing of options\", OPT_ALIAS },\n\n    { \"logfile\", o_special, (void *)setlogfile,\n      \"Append log messages to this file\",\n      OPT_PRIO | OPT_A2STRVAL | OPT_STATIC, &logfile_name },\n    { \"logfd\", o_int, &log_to_fd,\n      \"Send log messages to this file descriptor\",\n      OPT_PRIOSUB | OPT_A2CLR, &log_default },\n    { \"nolog\", o_int, &log_to_fd,\n      \"Don't send log messages to any file\",\n      OPT_PRIOSUB | OPT_NOARG | OPT_VAL(-1) },\n    { \"nologfd\", o_int, &log_to_fd,\n      \"Don't send log messages to any file descriptor\",\n      OPT_PRIOSUB | OPT_ALIAS | OPT_NOARG | OPT_VAL(-1) },\n\n    { \"linkname\", o_string, linkname,\n      \"Set logical name for link\",\n      OPT_PRIO | OPT_PRIV | OPT_STATIC, NULL, MAXPATHLEN },\n\n    { \"maxfail\", o_int, &maxfail,\n      \"Maximum number of unsuccessful connection attempts to allow\",\n      OPT_PRIO },\n\n    { \"ktune\", o_bool, &tune_kernel,\n      \"Alter kernel settings as necessary\", OPT_PRIO | 1 },\n    { \"noktune\", o_bool, &tune_kernel,\n      \"Don't alter kernel settings\", OPT_PRIOSUB },\n\n    { \"connect-delay\", o_int, &connect_delay,\n      \"Maximum time (in ms) to wait after connect script finishes\",\n      OPT_PRIO },\n\n    { \"unit\", o_int, &req_unit,\n      \"PPP interface unit number to use if possible\",\n      OPT_PRIO | OPT_LLIMIT, 0, 0 },\n\n    { \"dump\", o_bool, &dump_options,\n      \"Print out option values after parsing all options\", 1 },\n    { \"dryrun\", o_bool, &dryrun,\n      \"Stop after parsing, printing, and checking options\", 1 },\n\n    { \"child-timeout\", o_int, &child_wait,\n      \"Number of seconds to wait for child processes at exit\",\n      OPT_PRIO },\n\n    { \"set\", o_special, (void *)user_setenv,\n      \"Set user environment variable\",\n      OPT_A2PRINTER | OPT_NOPRINT, (void *)user_setprint },\n    { \"unset\", o_special, (void *)user_unsetenv,\n      \"Unset user environment variable\",\n      OPT_A2PRINTER | OPT_NOPRINT, (void *)user_unsetprint },\n\n#ifdef HAVE_MULTILINK\n    { \"multilink\", o_bool, &multilink,\n      \"Enable multilink operation\", OPT_PRIO | 1 },\n    { \"mp\", o_bool, &multilink,\n      \"Enable multilink operation\", OPT_PRIOSUB | OPT_ALIAS | 1 },\n    { \"nomultilink\", o_bool, &multilink,\n      \"Disable multilink operation\", OPT_PRIOSUB | 0 },\n    { \"nomp\", o_bool, &multilink,\n      \"Disable multilink operation\", OPT_PRIOSUB | OPT_ALIAS | 0 },\n\n    { \"bundle\", o_string, &bundle_name,\n      \"Bundle name for multilink\", OPT_PRIO },\n#endif /* HAVE_MULTILINK */\n\n#ifdef PLUGIN\n    { \"plugin\", o_special, (void *)loadplugin,\n      \"Load a plug-in module into pppd\", OPT_PRIV | OPT_A2LIST },\n#endif\n\n#ifdef PPP_FILTER\n    { \"pass-filter\", o_special, setpassfilter,\n      \"set filter for packets to pass\", OPT_PRIO },\n\n    { \"active-filter\", o_special, setactivefilter,\n      \"set filter for active pkts\", OPT_PRIO },\n#endif\n\n#ifdef MAXOCTETS\n    { \"maxoctets\", o_int, &maxoctets,\n      \"Set connection traffic limit\",\n      OPT_PRIO | OPT_LLIMIT | OPT_NOINCR | OPT_ZEROINF },\n    { \"mo\", o_int, &maxoctets,\n      \"Set connection traffic limit\",\n      OPT_ALIAS | OPT_PRIO | OPT_LLIMIT | OPT_NOINCR | OPT_ZEROINF },\n    { \"mo-direction\", o_special, setmodir,\n      \"Set direction for limit traffic (sum,in,out,max)\" },\n    { \"mo-timeout\", o_int, &maxoctets_timeout,\n      \"Check for traffic limit every N seconds\", OPT_PRIO | OPT_LLIMIT | 1 },\n#endif\n\n    { NULL }\n};\n\n#ifndef IMPLEMENTATION\n#define IMPLEMENTATION \"\"\n#endif\n\nstatic char *usage_string = \"\\\npppd version %s\\n\\\nUsage: %s [ options ], where options are:\\n\\\n\t<device>\tCommunicate over the named device\\n\\\n\t<speed>\t\tSet the baud rate to <speed>\\n\\\n\t<loc>:<rem>\tSet the local and/or remote interface IP\\n\\\n\t\t\taddresses.  Either one may be omitted.\\n\\\n\tasyncmap <n>\tSet the desired async map to hex <n>\\n\\\n\tauth\t\tRequire authentication from peer\\n\\\n        connect <p>     Invoke shell command <p> to set up the serial line\\n\\\n\tcrtscts\t\tUse hardware RTS/CTS flow control\\n\\\n\tdefaultroute\tAdd default route through interface\\n\\\n\tfile <f>\tTake options from file <f>\\n\\\n\tmodem\t\tUse modem control lines\\n\\\n\tmru <n>\t\tSet MRU value to <n> for negotiation\\n\\\nSee pppd(8) for more options.\\n\\\n\";\n\n/*\n * parse_args - parse a string of arguments from the command line.\n */\nint\nparse_args(argc, argv)\n    int argc;\n    char **argv;\n{\n    char *arg;\n    option_t *opt;\n    int n;\n\n    privileged_option = privileged;\n    option_source = \"command line\";\n    option_priority = OPRIO_CMDLINE;\n    while (argc > 0) {\n\targ = *argv++;\n\t--argc;\n\topt = find_option(arg);\n\tif (opt == NULL) {\n\t    option_error(\"unrecognized option '%s'\", arg);\n\t    usage();\n\t    return 0;\n\t}\n\tn = n_arguments(opt);\n\tif (argc < n) {\n\t    option_error(\"too few parameters for option %s\", arg);\n\t    return 0;\n\t}\n\tif (!process_option(opt, arg, argv))\n\t    return 0;\n\targc -= n;\n\targv += n;\n    }\n    return 1;\n}\n\n/*\n * options_from_file - Read a string of options from a file,\n * and interpret them.\n */\nint\noptions_from_file(filename, must_exist, check_prot, priv)\n    char *filename;\n    int must_exist;\n    int check_prot;\n    int priv;\n{\n    FILE *f;\n    int i, newline, ret, err;\n    option_t *opt;\n    int oldpriv, n;\n    char *oldsource;\n    uid_t euid;\n    char *argv[MAXARGS];\n    char args[MAXARGS][MAXWORDLEN];\n    char cmd[MAXWORDLEN];\n\n    euid = geteuid();\n    if (check_prot && seteuid(getuid()) == -1) {\n\toption_error(\"unable to drop privileges to open %s: %m\", filename);\n\treturn 0;\n    }\n    f = fopen(filename, \"r\");\n    err = errno;\n    if (check_prot && seteuid(euid) == -1)\n\tfatal(\"unable to regain privileges\");\n    if (f == NULL) {\n\terrno = err;\n\tif (!must_exist) {\n\t    if (err != ENOENT && err != ENOTDIR)\n\t\twarn(\"Warning: can't open options file %s: %m\", filename);\n\t    return 1;\n\t}\n\toption_error(\"Can't open options file %s: %m\", filename);\n\treturn 0;\n    }\n\n    oldpriv = privileged_option;\n    privileged_option = priv;\n    oldsource = option_source;\n    option_source = strdup(filename);\n    if (option_source == NULL)\n\toption_source = \"file\";\n    ret = 0;\n    while (getword(f, cmd, &newline, filename)) {\n\topt = find_option(cmd);\n\tif (opt == NULL) {\n\t    option_error(\"In file %s: unrecognized option '%s'\",\n\t\t\t filename, cmd);\n\t    goto err;\n\t}\n\tn = n_arguments(opt);\n\tfor (i = 0; i < n; ++i) {\n\t    if (!getword(f, args[i], &newline, filename)) {\n\t\toption_error(\n\t\t\t\"In file %s: too few parameters for option '%s'\",\n\t\t\tfilename, cmd);\n\t\tgoto err;\n\t    }\n\t    argv[i] = args[i];\n\t}\n\tif (!process_option(opt, cmd, argv))\n\t    goto err;\n    }\n    ret = 1;\n\nerr:\n    fclose(f);\n    privileged_option = oldpriv;\n    option_source = oldsource;\n    return ret;\n}\n\n/*\n * options_from_user - See if the use has a ~/.ppprc file,\n * and if so, interpret options from it.\n */\nint\noptions_from_user()\n{\n    char *user, *path, *file;\n    int ret;\n    struct passwd *pw;\n    size_t pl;\n\n    pw = getpwuid(getuid());\n    if (pw == NULL || (user = pw->pw_dir) == NULL || user[0] == 0)\n\treturn 1;\n    file = _PATH_USEROPT;\n    pl = strlen(user) + strlen(file) + 2;\n    path = malloc(pl);\n    if (path == NULL)\n\tnovm(\"init file name\");\n    slprintf(path, pl, \"%s/%s\", user, file);\n    option_priority = OPRIO_CFGFILE;\n    ret = options_from_file(path, 0, 1, privileged);\n    free(path);\n    return ret;\n}\n\n/*\n * options_for_tty - See if an options file exists for the serial\n * device, and if so, interpret options from it.\n * We only allow the per-tty options file to override anything from\n * the command line if it is something that the user can't override\n * once it has been set by root; this is done by giving configuration\n * files a lower priority than the command line.\n */\nint\noptions_for_tty()\n{\n    char *dev, *path, *p;\n    int ret;\n    size_t pl;\n\n    dev = devnam;\n    if ((p = strstr(dev, \"/dev/\")) != NULL)\n\tdev = p + 5;\n    if (dev[0] == 0 || strcmp(dev, \"tty\") == 0)\n\treturn 1;\t\t/* don't look for /etc/ppp/options.tty */\n    pl = strlen(_PATH_TTYOPT) + strlen(dev) + 1;\n    path = malloc(pl);\n    if (path == NULL)\n\tnovm(\"tty init file name\");\n    slprintf(path, pl, \"%s%s\", _PATH_TTYOPT, dev);\n    /* Turn slashes into dots, for Solaris case (e.g. /dev/term/a) */\n    for (p = path + strlen(_PATH_TTYOPT); *p != 0; ++p)\n\tif (*p == '/')\n\t    *p = '.';\n    option_priority = OPRIO_CFGFILE;\n    ret = options_from_file(path, 0, 0, 1);\n    free(path);\n    return ret;\n}\n\n/*\n * options_from_list - process a string of options in a wordlist.\n */\nint\noptions_from_list(w, priv)\n    struct wordlist *w;\n    int priv;\n{\n    char *argv[MAXARGS];\n    option_t *opt;\n    int i, n, ret = 0;\n    struct wordlist *w0;\n\n    privileged_option = priv;\n    option_source = \"secrets file\";\n    option_priority = OPRIO_SECFILE;\n\n    while (w != NULL) {\n\topt = find_option(w->word);\n\tif (opt == NULL) {\n\t    option_error(\"In secrets file: unrecognized option '%s'\",\n\t\t\t w->word);\n\t    goto err;\n\t}\n\tn = n_arguments(opt);\n\tw0 = w;\n\tfor (i = 0; i < n; ++i) {\n\t    w = w->next;\n\t    if (w == NULL) {\n\t\toption_error(\n\t\t\t\"In secrets file: too few parameters for option '%s'\",\n\t\t\tw0->word);\n\t\tgoto err;\n\t    }\n\t    argv[i] = w->word;\n\t}\n\tif (!process_option(opt, w0->word, argv))\n\t    goto err;\n\tw = w->next;\n    }\n    ret = 1;\n\nerr:\n    return ret;\n}\n\n/*\n * match_option - see if this option matches an option_t structure.\n */\nstatic int\nmatch_option(name, opt, dowild)\n    char *name;\n    option_t *opt;\n    int dowild;\n{\n\tint (*match) __P((char *, char **, int));\n\n\tif (dowild != (opt->type == o_wild))\n\t\treturn 0;\n\tif (!dowild)\n\t\treturn strcmp(name, opt->name) == 0;\n\tmatch = (int (*) __P((char *, char **, int))) opt->addr;\n\treturn (*match)(name, NULL, 0);\n}\n\n/*\n * find_option - scan the option lists for the various protocols\n * looking for an entry with the given name.\n * This could be optimized by using a hash table.\n */\nstatic option_t *\nfind_option(name)\n    const char *name;\n{\n\toption_t *opt;\n\tstruct option_list *list;\n\tint i, dowild;\n\n\tfor (dowild = 0; dowild <= 1; ++dowild) {\n\t\tfor (opt = general_options; opt->name != NULL; ++opt)\n\t\t\tif (match_option(name, opt, dowild))\n\t\t\t\treturn opt;\n\t\tfor (opt = auth_options; opt->name != NULL; ++opt)\n\t\t\tif (match_option(name, opt, dowild))\n\t\t\t\treturn opt;\n\t\tfor (list = extra_options; list != NULL; list = list->next)\n\t\t\tfor (opt = list->options; opt->name != NULL; ++opt)\n\t\t\t\tif (match_option(name, opt, dowild))\n\t\t\t\t\treturn opt;\n\t\tfor (opt = the_channel->options; opt->name != NULL; ++opt)\n\t\t\tif (match_option(name, opt, dowild))\n\t\t\t\treturn opt;\n\t\tfor (i = 0; protocols[i] != NULL; ++i)\n\t\t\tif ((opt = protocols[i]->options) != NULL)\n\t\t\t\tfor (; opt->name != NULL; ++opt)\n\t\t\t\t\tif (match_option(name, opt, dowild))\n\t\t\t\t\t\treturn opt;\n\t}\n\treturn NULL;\n}\n\n/*\n * process_option - process one new-style option.\n */\nstatic int\nprocess_option(opt, cmd, argv)\n    option_t *opt;\n    char *cmd;\n    char **argv;\n{\n    u_int32_t v;\n    int iv, a;\n    char *sv;\n    int (*parser) __P((char **));\n    int (*wildp) __P((char *, char **, int));\n    char *optopt = (opt->type == o_wild)? \"\": \" option\";\n    int prio = option_priority;\n    option_t *mainopt = opt;\n\n    current_option = opt->name;\n    if ((opt->flags & OPT_PRIVFIX) && privileged_option)\n\tprio += OPRIO_ROOT;\n    while (mainopt->flags & OPT_PRIOSUB)\n\t--mainopt;\n    if (mainopt->flags & OPT_PRIO) {\n\tif (prio < mainopt->priority) {\n\t    /* new value doesn't override old */\n\t    if (prio == OPRIO_CMDLINE && mainopt->priority > OPRIO_ROOT) {\n\t\toption_error(\"%s%s set in %s cannot be overridden\\n\",\n\t\t\t     opt->name, optopt, mainopt->source);\n\t\treturn 0;\n\t    }\n\t    return 1;\n\t}\n\tif (prio > OPRIO_ROOT && mainopt->priority == OPRIO_CMDLINE)\n\t    warn(\"%s%s from %s overrides command line\",\n\t\t opt->name, optopt, option_source);\n    }\n\n    if ((opt->flags & OPT_INITONLY) && phase != PHASE_INITIALIZE) {\n\toption_error(\"%s%s cannot be changed after initialization\",\n\t\t     opt->name, optopt);\n\treturn 0;\n    }\n    if ((opt->flags & OPT_PRIV) && !privileged_option) {\n\toption_error(\"using the %s%s requires root privilege\",\n\t\t     opt->name, optopt);\n\treturn 0;\n    }\n    if ((opt->flags & OPT_ENABLE) && *(bool *)(opt->addr2) == 0) {\n\toption_error(\"%s%s is disabled\", opt->name, optopt);\n\treturn 0;\n    }\n    if ((opt->flags & OPT_DEVEQUIV) && devnam_fixed) {\n\toption_error(\"the %s%s may not be changed in %s\",\n\t\t     opt->name, optopt, option_source);\n\treturn 0;\n    }\n\n    switch (opt->type) {\n    case o_bool:\n\tv = opt->flags & OPT_VALUE;\n\t*(bool *)(opt->addr) = v;\n\tif (opt->addr2 && (opt->flags & OPT_A2COPY))\n\t    *(bool *)(opt->addr2) = v;\n\telse if (opt->addr2 && (opt->flags & OPT_A2CLR))\n\t    *(bool *)(opt->addr2) = 0;\n\telse if (opt->addr2 && (opt->flags & OPT_A2CLRB))\n\t    *(u_char *)(opt->addr2) &= ~v;\n\telse if (opt->addr2 && (opt->flags & OPT_A2OR))\n\t    *(u_char *)(opt->addr2) |= v;\n\tbreak;\n\n    case o_int:\n\tiv = 0;\n\tif ((opt->flags & OPT_NOARG) == 0) {\n\t    if (!int_option(*argv, &iv))\n\t\treturn 0;\n\t    if ((((opt->flags & OPT_LLIMIT) && iv < opt->lower_limit)\n\t\t || ((opt->flags & OPT_ULIMIT) && iv > opt->upper_limit))\n\t\t&& !((opt->flags & OPT_ZEROOK && iv == 0))) {\n\t\tchar *zok = (opt->flags & OPT_ZEROOK)? \" zero or\": \"\";\n\t\tswitch (opt->flags & OPT_LIMITS) {\n\t\tcase OPT_LLIMIT:\n\t\t    option_error(\"%s value must be%s >= %d\",\n\t\t\t\t opt->name, zok, opt->lower_limit);\n\t\t    break;\n\t\tcase OPT_ULIMIT:\n\t\t    option_error(\"%s value must be%s <= %d\",\n\t\t\t\t opt->name, zok, opt->upper_limit);\n\t\t    break;\n\t\tcase OPT_LIMITS:\n\t\t    option_error(\"%s value must be%s between %d and %d\",\n\t\t\t\topt->name, zok, opt->lower_limit, opt->upper_limit);\n\t\t    break;\n\t\t}\n\t\treturn 0;\n\t    }\n\t}\n\ta = opt->flags & OPT_VALUE;\n\tif (a >= 128)\n\t    a -= 256;\t\t/* sign extend */\n\tiv += a;\n\tif (opt->flags & OPT_INC)\n\t    iv += *(int *)(opt->addr);\n\tif ((opt->flags & OPT_NOINCR) && !privileged_option) {\n\t    int oldv = *(int *)(opt->addr);\n\t    if ((opt->flags & OPT_ZEROINF) ?\n\t\t(oldv != 0 && (iv == 0 || iv > oldv)) : (iv > oldv)) {\n\t\toption_error(\"%s value cannot be increased\", opt->name);\n\t\treturn 0;\n\t    }\n\t}\n\t*(int *)(opt->addr) = iv;\n\tif (opt->addr2 && (opt->flags & OPT_A2COPY))\n\t    *(int *)(opt->addr2) = iv;\n\tbreak;\n\n    case o_uint32:\n\tif (opt->flags & OPT_NOARG) {\n\t    v = opt->flags & OPT_VALUE;\n\t    if (v & 0x80)\n\t\t    v |= 0xffffff00U;\n\t} else if (!number_option(*argv, &v, 16))\n\t    return 0;\n\tif (opt->flags & OPT_OR)\n\t    v |= *(u_int32_t *)(opt->addr);\n\t*(u_int32_t *)(opt->addr) = v;\n\tif (opt->addr2 && (opt->flags & OPT_A2COPY))\n\t    *(u_int32_t *)(opt->addr2) = v;\n\tbreak;\n\n    case o_string:\n\tif (opt->flags & OPT_STATIC) {\n\t    strlcpy((char *)(opt->addr), *argv, opt->upper_limit);\n\t} else {\n\t    sv = strdup(*argv);\n\t    if (sv == NULL)\n\t\tnovm(\"option argument\");\n\t    *(char **)(opt->addr) = sv;\n\t}\n\tbreak;\n\n    case o_special_noarg:\n    case o_special:\n\tparser = (int (*) __P((char **))) opt->addr;\n\tcuropt = opt;\n\tif (!(*parser)(argv))\n\t    return 0;\n\tif (opt->flags & OPT_A2LIST) {\n\t    struct option_value *ovp, *pp;\n\n\t    ovp = malloc(sizeof(*ovp) + strlen(*argv));\n\t    if (ovp != 0) {\n\t\tstrcpy(ovp->value, *argv);\n\t\tovp->source = option_source;\n\t\tovp->next = NULL;\n\t\tif (opt->addr2 == NULL) {\n\t\t    opt->addr2 = ovp;\n\t\t} else {\n\t\t    for (pp = opt->addr2; pp->next != NULL; pp = pp->next)\n\t\t\t;\n\t\t    pp->next = ovp;\n\t\t}\n\t    }\n\t}\n\tbreak;\n\n    case o_wild:\n\twildp = (int (*) __P((char *, char **, int))) opt->addr;\n\tif (!(*wildp)(cmd, argv, 1))\n\t    return 0;\n\tbreak;\n    }\n\n    /*\n     * If addr2 wasn't used by any flag (OPT_A2COPY, etc.) but is set,\n     * treat it as a bool and set/clear it based on the OPT_A2CLR bit.\n     */\n    if (opt->addr2 && (opt->flags & (OPT_A2COPY|OPT_ENABLE\n\t\t|OPT_A2PRINTER|OPT_A2STRVAL|OPT_A2LIST|OPT_A2OR)) == 0)\n\t*(bool *)(opt->addr2) = !(opt->flags & OPT_A2CLR);\n\n    mainopt->source = option_source;\n    mainopt->priority = prio;\n    mainopt->winner = opt - mainopt;\n\n    return 1;\n}\n\n/*\n * override_value - if the option priorities would permit us to\n * override the value of option, return 1 and update the priority\n * and source of the option value.  Otherwise returns 0.\n */\nint\noverride_value(option, priority, source)\n    const char *option;\n    int priority;\n    const char *source;\n{\n\toption_t *opt;\n\n\topt = find_option(option);\n\tif (opt == NULL)\n\t\treturn 0;\n\twhile (opt->flags & OPT_PRIOSUB)\n\t\t--opt;\n\tif ((opt->flags & OPT_PRIO) && priority < opt->priority)\n\t\treturn 0;\n\topt->priority = priority;\n\topt->source = source;\n\topt->winner = -1;\n\treturn 1;\n}\n\n/*\n * n_arguments - tell how many arguments an option takes\n */\nstatic int\nn_arguments(opt)\n    option_t *opt;\n{\n\treturn (opt->type == o_bool || opt->type == o_special_noarg\n\t\t|| (opt->flags & OPT_NOARG))? 0: 1;\n}\n\n/*\n * add_options - add a list of options to the set we grok.\n */\nvoid\nadd_options(opt)\n    option_t *opt;\n{\n    struct option_list *list;\n\n    list = malloc(sizeof(*list));\n    if (list == 0)\n\tnovm(\"option list entry\");\n    list->options = opt;\n    list->next = extra_options;\n    extra_options = list;\n}\n\n/*\n * check_options - check that options are valid and consistent.\n */\nvoid\ncheck_options()\n{\n\tif (logfile_fd >= 0 && logfile_fd != log_to_fd)\n\t\tclose(logfile_fd);\n}\n\n/*\n * print_option - print out an option and its value\n */\nstatic void\nprint_option(opt, mainopt, printer, arg)\n    option_t *opt, *mainopt;\n    printer_func printer;\n    void *arg;\n{\n\tint i, v;\n\tchar *p;\n\n\tif (opt->flags & OPT_NOPRINT)\n\t\treturn;\n\tswitch (opt->type) {\n\tcase o_bool:\n\t\tv = opt->flags & OPT_VALUE;\n\t\tif (*(bool *)opt->addr != v)\n\t\t\t/* this can happen legitimately, e.g. lock\n\t\t\t   option turned off for default device */\n\t\t\tbreak;\n\t\tprinter(arg, \"%s\", opt->name);\n\t\tbreak;\n\tcase o_int:\n\t\tv = opt->flags & OPT_VALUE;\n\t\tif (v >= 128)\n\t\t\tv -= 256;\n\t\ti = *(int *)opt->addr;\n\t\tif (opt->flags & OPT_NOARG) {\n\t\t\tprinter(arg, \"%s\", opt->name);\n\t\t\tif (i != v) {\n\t\t\t\tif (opt->flags & OPT_INC) {\n\t\t\t\t\tfor (; i > v; i -= v)\n\t\t\t\t\t\tprinter(arg, \" %s\", opt->name);\n\t\t\t\t} else\n\t\t\t\t\tprinter(arg, \" # oops: %d not %d\\n\",\n\t\t\t\t\t\ti, v);\n\t\t\t}\n\t\t} else {\n\t\t\tprinter(arg, \"%s %d\", opt->name, i);\n\t\t}\n\t\tbreak;\n\tcase o_uint32:\n\t\tprinter(arg, \"%s\", opt->name);\n\t\tif ((opt->flags & OPT_NOARG) == 0)\n\t\t\tprinter(arg, \" %x\", *(u_int32_t *)opt->addr);\n\t\tbreak;\n\n\tcase o_string:\n\t\tif (opt->flags & OPT_HIDE) {\n\t\t\tp = \"??????\";\n\t\t} else {\n\t\t\tp = (char *) opt->addr;\n\t\t\tif ((opt->flags & OPT_STATIC) == 0)\n\t\t\t\tp = *(char **)p;\n\t\t}\n\t\tprinter(arg, \"%s %q\", opt->name, p);\n\t\tbreak;\n\n\tcase o_special:\n\tcase o_special_noarg:\n\tcase o_wild:\n\t\tif (opt->type != o_wild) {\n\t\t\tprinter(arg, \"%s\", opt->name);\n\t\t\tif (n_arguments(opt) == 0)\n\t\t\t\tbreak;\n\t\t\tprinter(arg, \" \");\n\t\t}\n\t\tif (opt->flags & OPT_A2PRINTER) {\n\t\t\tvoid (*oprt) __P((option_t *, printer_func, void *));\n\t\t\toprt = (void (*) __P((option_t *, printer_func,\n\t\t\t\t\t void *)))opt->addr2;\n\t\t\t(*oprt)(opt, printer, arg);\n\t\t} else if (opt->flags & OPT_A2STRVAL) {\n\t\t\tp = (char *) opt->addr2;\n\t\t\tif ((opt->flags & OPT_STATIC) == 0)\n\t\t\t\tp = *(char **)p;\n\t\t\tprinter(\"%q\", p);\n\t\t} else if (opt->flags & OPT_A2LIST) {\n\t\t\tstruct option_value *ovp;\n\n\t\t\tovp = (struct option_value *) opt->addr2;\n\t\t\tfor (;;) {\n\t\t\t\tprinter(arg, \"%q\", ovp->value);\n\t\t\t\tif ((ovp = ovp->next) == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tprinter(arg, \"\\t\\t# (from %s)\\n%s \",\n\t\t\t\t\tovp->source, opt->name);\n\t\t\t}\n\t\t} else {\n\t\t\tprinter(arg, \"xxx # [don't know how to print value]\");\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tprinter(arg, \"# %s value (type %d\\?\\?)\", opt->name, opt->type);\n\t\tbreak;\n\t}\n\tprinter(arg, \"\\t\\t# (from %s)\\n\", mainopt->source);\n}\n\n/*\n * print_option_list - print out options in effect from an\n * array of options.\n */\nstatic void\nprint_option_list(opt, printer, arg)\n    option_t *opt;\n    printer_func printer;\n    void *arg;\n{\n\twhile (opt->name != NULL) {\n\t\tif (opt->priority != OPRIO_DEFAULT\n\t\t    && opt->winner != (short int) -1)\n\t\t\tprint_option(opt + opt->winner, opt, printer, arg);\n\t\tdo {\n\t\t\t++opt;\n\t\t} while (opt->flags & OPT_PRIOSUB);\n\t}\n}\n\n/*\n * print_options - print out what options are in effect.\n */\nvoid\nprint_options(printer, arg)\n    printer_func printer;\n    void *arg;\n{\n\tstruct option_list *list;\n\tint i;\n\n\tprinter(arg, \"pppd options in effect:\\n\");\n\tprint_option_list(general_options, printer, arg);\n\tprint_option_list(auth_options, printer, arg);\n\tfor (list = extra_options; list != NULL; list = list->next)\n\t\tprint_option_list(list->options, printer, arg);\n\tprint_option_list(the_channel->options, printer, arg);\n\tfor (i = 0; protocols[i] != NULL; ++i)\n\t\tprint_option_list(protocols[i]->options, printer, arg);\n}\n\n/*\n * usage - print out a message telling how to use the program.\n */\nstatic void\nusage()\n{\n    if (phase == PHASE_INITIALIZE)\n\tfprintf(stderr, usage_string, VERSION, progname);\n}\n\n/*\n * showhelp - print out usage message and exit.\n */\nstatic int\nshowhelp(argv)\n    char **argv;\n{\n    if (phase == PHASE_INITIALIZE) {\n\tusage();\n\texit(0);\n    }\n    return 0;\n}\n\n/*\n * showversion - print out the version number and exit.\n */\nstatic int\nshowversion(argv)\n    char **argv;\n{\n    if (phase == PHASE_INITIALIZE) {\n\tfprintf(stderr, \"pppd version %s\\n\", VERSION);\n\texit(0);\n    }\n    return 0;\n}\n\n/*\n * option_error - print a message about an error in an option.\n * The message is logged, and also sent to\n * stderr if phase == PHASE_INITIALIZE.\n */\nvoid\noption_error __V((char *fmt, ...))\n{\n    va_list args;\n    char buf[1024];\n\n#if defined(__STDC__)\n    va_start(args, fmt);\n#else\n    char *fmt;\n    va_start(args);\n    fmt = va_arg(args, char *);\n#endif\n    vslprintf(buf, sizeof(buf), fmt, args);\n    va_end(args);\n    if (phase == PHASE_INITIALIZE)\n\tfprintf(stderr, \"%s: %s\\n\", progname, buf);\n    syslog(LOG_ERR, \"%s\", buf);\n}\n\n#if 0\n/*\n * readable - check if a file is readable by the real user.\n */\nint\nreadable(fd)\n    int fd;\n{\n    uid_t uid;\n    int i;\n    struct stat sbuf;\n\n    uid = getuid();\n    if (uid == 0)\n\treturn 1;\n    if (fstat(fd, &sbuf) != 0)\n\treturn 0;\n    if (sbuf.st_uid == uid)\n\treturn sbuf.st_mode & S_IRUSR;\n    if (sbuf.st_gid == getgid())\n\treturn sbuf.st_mode & S_IRGRP;\n    for (i = 0; i < ngroups; ++i)\n\tif (sbuf.st_gid == groups[i])\n\t    return sbuf.st_mode & S_IRGRP;\n    return sbuf.st_mode & S_IROTH;\n}\n#endif\n\n/*\n * Read a word from a file.\n * Words are delimited by white-space or by quotes (\" or ').\n * Quotes, white-space and \\ may be escaped with \\.\n * \\<newline> is ignored.\n */\nint\ngetword(f, word, newlinep, filename)\n    FILE *f;\n    char *word;\n    int *newlinep;\n    char *filename;\n{\n    int c, len, escape;\n    int quoted, comment;\n    int value, digit, got, n;\n\n#define isoctal(c) ((c) >= '0' && (c) < '8')\n\n    *newlinep = 0;\n    len = 0;\n    escape = 0;\n    comment = 0;\n    quoted = 0;\n\n    /*\n     * First skip white-space and comments.\n     */\n    for (;;) {\n\tc = getc(f);\n\tif (c == EOF)\n\t    break;\n\n\t/*\n\t * A newline means the end of a comment; backslash-newline\n\t * is ignored.  Note that we cannot have escape && comment.\n\t */\n\tif (c == '\\n') {\n\t    if (!escape) {\n\t\t*newlinep = 1;\n\t\tcomment = 0;\n\t    } else\n\t\tescape = 0;\n\t    continue;\n\t}\n\n\t/*\n\t * Ignore characters other than newline in a comment.\n\t */\n\tif (comment)\n\t    continue;\n\n\t/*\n\t * If this character is escaped, we have a word start.\n\t */\n\tif (escape)\n\t    break;\n\n\t/*\n\t * If this is the escape character, look at the next character.\n\t */\n\tif (c == '\\\\') {\n\t    escape = 1;\n\t    continue;\n\t}\n\n\t/*\n\t * If this is the start of a comment, ignore the rest of the line.\n\t */\n\tif (c == '#') {\n\t    comment = 1;\n\t    continue;\n\t}\n\n\t/*\n\t * A non-whitespace character is the start of a word.\n\t */\n\tif (!isspace(c))\n\t    break;\n    }\n\n    /*\n     * Process characters until the end of the word.\n     */\n    while (c != EOF) {\n\tif (escape) {\n\t    /*\n\t     * This character is escaped: backslash-newline is ignored,\n\t     * various other characters indicate particular values\n\t     * as for C backslash-escapes.\n\t     */\n\t    escape = 0;\n\t    if (c == '\\n') {\n\t        c = getc(f);\n\t\tcontinue;\n\t    }\n\n\t    got = 0;\n\t    switch (c) {\n\t    case 'a':\n\t\tvalue = '\\a';\n\t\tbreak;\n\t    case 'b':\n\t\tvalue = '\\b';\n\t\tbreak;\n\t    case 'f':\n\t\tvalue = '\\f';\n\t\tbreak;\n\t    case 'n':\n\t\tvalue = '\\n';\n\t\tbreak;\n\t    case 'r':\n\t\tvalue = '\\r';\n\t\tbreak;\n\t    case 's':\n\t\tvalue = ' ';\n\t\tbreak;\n\t    case 't':\n\t\tvalue = '\\t';\n\t\tbreak;\n\n\t    default:\n\t\tif (isoctal(c)) {\n\t\t    /*\n\t\t     * \\ddd octal sequence\n\t\t     */\n\t\t    value = 0;\n\t\t    for (n = 0; n < 3 && isoctal(c); ++n) {\n\t\t\tvalue = (value << 3) + (c & 07);\n\t\t\tc = getc(f);\n\t\t    }\n\t\t    got = 1;\n\t\t    break;\n\t\t}\n\n\t\tif (c == 'x') {\n\t\t    /*\n\t\t     * \\x<hex_string> sequence\n\t\t     */\n\t\t    value = 0;\n\t\t    c = getc(f);\n\t\t    for (n = 0; n < 2 && isxdigit(c); ++n) {\n\t\t\tdigit = toupper(c) - '0';\n\t\t\tif (digit > 10)\n\t\t\t    digit += '0' + 10 - 'A';\n\t\t\tvalue = (value << 4) + digit;\n\t\t\tc = getc (f);\n\t\t    }\n\t\t    got = 1;\n\t\t    break;\n\t\t}\n\n\t\t/*\n\t\t * Otherwise the character stands for itself.\n\t\t */\n\t\tvalue = c;\n\t\tbreak;\n\t    }\n\n\t    /*\n\t     * Store the resulting character for the escape sequence.\n\t     */\n\t    if (len < MAXWORDLEN) {\n\t\tword[len] = value;\n\t\t++len;\n\t    }\n\n\t    if (!got)\n\t\tc = getc(f);\n\t    continue;\n\t}\n\n\t/*\n\t * Backslash starts a new escape sequence.\n\t */\n\tif (c == '\\\\') {\n\t    escape = 1;\n\t    c = getc(f);\n\t    continue;\n\t}\n\n\t/*\n\t * Not escaped: check for the start or end of a quoted\n\t * section and see if we've reached the end of the word.\n\t */\n\tif (quoted) {\n\t    if (c == quoted) {\n\t\tquoted = 0;\n\t\tc = getc(f);\n\t\tcontinue;\n\t    }\n\t} else if (c == '\"' || c == '\\'') {\n\t    quoted = c;\n\t    c = getc(f);\n\t    continue;\n\t} else if (isspace(c) || c == '#') {\n\t    ungetc (c, f);\n\t    break;\n\t}\n\n\t/*\n\t * An ordinary character: store it in the word and get another.\n\t */\n\tif (len < MAXWORDLEN) {\n\t    word[len] = c;\n\t    ++len;\n\t}\n\n\tc = getc(f);\n    }\n\n    /*\n     * End of the word: check for errors.\n     */\n    if (c == EOF) {\n\tif (ferror(f)) {\n\t    if (errno == 0)\n\t\terrno = EIO;\n\t    option_error(\"Error reading %s: %m\", filename);\n\t    die(1);\n\t}\n\t/*\n\t * If len is zero, then we didn't find a word before the\n\t * end of the file.\n\t */\n\tif (len == 0)\n\t    return 0;\n\tif (quoted)\n\t    option_error(\"warning: quoted word runs to end of file (%.20s...)\",\n\t\t\t filename, word);\n    }\n\n    /*\n     * Warn if the word was too long, and append a terminating null.\n     */\n    if (len >= MAXWORDLEN) {\n\toption_error(\"warning: word in file %s too long (%.20s...)\",\n\t\t     filename, word);\n\tlen = MAXWORDLEN - 1;\n    }\n    word[len] = 0;\n\n    return 1;\n\n#undef isoctal\n\n}\n\n/*\n * number_option - parse an unsigned numeric parameter for an option.\n */\nstatic int\nnumber_option(str, valp, base)\n    char *str;\n    u_int32_t *valp;\n    int base;\n{\n    char *ptr;\n\n    *valp = strtoul(str, &ptr, base);\n    if (ptr == str) {\n\toption_error(\"invalid numeric parameter '%s' for %s option\",\n\t\t     str, current_option);\n\treturn 0;\n    }\n    return 1;\n}\n\n\n/*\n * int_option - like number_option, but valp is int *,\n * the base is assumed to be 0, and *valp is not changed\n * if there is an error.\n */\nint\nint_option(str, valp)\n    char *str;\n    int *valp;\n{\n    u_int32_t v;\n\n    if (!number_option(str, &v, 0))\n\treturn 0;\n    *valp = (int) v;\n    return 1;\n}\n\n\n/*\n * The following procedures parse options.\n */\n\n/*\n * readfile - take commands from a file.\n */\nstatic int\nreadfile(argv)\n    char **argv;\n{\n    return options_from_file(*argv, 1, 1, privileged_option);\n}\n\n/*\n * callfile - take commands from /etc/ppp/peers/<name>.\n * Name may not contain /../, start with / or ../, or end in /..\n */\nstatic int\ncallfile(argv)\n    char **argv;\n{\n    char *fname, *arg, *p;\n    int l, ok;\n\n    arg = *argv;\n    ok = 1;\n    if (arg[0] == '/' || arg[0] == 0)\n\tok = 0;\n    else {\n\tfor (p = arg; *p != 0; ) {\n\t    if (p[0] == '.' && p[1] == '.' && (p[2] == '/' || p[2] == 0)) {\n\t\tok = 0;\n\t\tbreak;\n\t    }\n\t    while (*p != '/' && *p != 0)\n\t\t++p;\n\t    if (*p == '/')\n\t\t++p;\n\t}\n    }\n    if (!ok) {\n\toption_error(\"call option value may not contain .. or start with /\");\n\treturn 0;\n    }\n\n    l = strlen(arg) + strlen(_PATH_PEERFILES) + 1;\n    if ((fname = (char *) malloc(l)) == NULL)\n\tnovm(\"call file name\");\n    slprintf(fname, l, \"%s%s\", _PATH_PEERFILES, arg);\n\n    ok = options_from_file(fname, 1, 1, 1);\n\n    free(fname);\n    return ok;\n}\n\n#ifdef PPP_FILTER\n/*\n * setpassfilter - Set the pass filter for packets\n */\nstatic int\nsetpassfilter(argv)\n    char **argv;\n{\n    pcap_t *pc;\n    int ret = 1;\n\n    pc = pcap_open_dead(DLT_PPP_PPPD, 65535);\n    if (pcap_compile(pc, &pass_filter, *argv, 1, netmask) == -1) {\n\toption_error(\"error in pass-filter expression: %s\\n\",\n\t\t     pcap_geterr(pc));\n\tret = 0;\n    }\n    pcap_close(pc);\n\n    return ret;\n}\n\n/*\n * setactivefilter - Set the active filter for packets\n */\nstatic int\nsetactivefilter(argv)\n    char **argv;\n{\n    pcap_t *pc;\n    int ret = 1;\n\n    pc = pcap_open_dead(DLT_PPP_PPPD, 65535);\n    if (pcap_compile(pc, &active_filter, *argv, 1, netmask) == -1) {\n\toption_error(\"error in active-filter expression: %s\\n\",\n\t\t     pcap_geterr(pc));\n\tret = 0;\n    }\n    pcap_close(pc);\n\n    return ret;\n}\n#endif\n\n/*\n * setdomain - Set domain name to append to hostname \n */\nstatic int\nsetdomain(argv)\n    char **argv;\n{\n    gethostname(hostname, MAXNAMELEN);\n    if (**argv != 0) {\n\tif (**argv != '.')\n\t    strncat(hostname, \".\", MAXNAMELEN - strlen(hostname));\n\tdomain = hostname + strlen(hostname);\n\tstrncat(hostname, *argv, MAXNAMELEN - strlen(hostname));\n    }\n    hostname[MAXNAMELEN-1] = 0;\n    return (1);\n}\n\nstatic int\nsetlogfile(argv)\n    char **argv;\n{\n    int fd, err;\n    uid_t euid;\n\n    euid = geteuid();\n    if (!privileged_option && seteuid(getuid()) == -1) {\n\toption_error(\"unable to drop permissions to open %s: %m\", *argv);\n\treturn 0;\n    }\n    fd = open(*argv, O_WRONLY | O_APPEND | O_CREAT | O_EXCL, 0644);\n    if (fd < 0 && errno == EEXIST)\n\tfd = open(*argv, O_WRONLY | O_APPEND);\n    err = errno;\n    if (!privileged_option && seteuid(euid) == -1)\n\tfatal(\"unable to regain privileges: %m\");\n    if (fd < 0) {\n\terrno = err;\n\toption_error(\"Can't open log file %s: %m\", *argv);\n\treturn 0;\n    }\n    strlcpy(logfile_name, *argv, sizeof(logfile_name));\n    if (logfile_fd >= 0)\n\tclose(logfile_fd);\n    logfile_fd = fd;\n    log_to_fd = fd;\n    log_default = 0;\n    return 1;\n}\n\n#ifdef MAXOCTETS\nstatic int\nsetmodir(argv)\n    char **argv;\n{\n    if(*argv == NULL)\n\treturn 0;\n    if(!strcmp(*argv,\"in\")) {\n        maxoctets_dir = PPP_OCTETS_DIRECTION_IN;\n    } else if (!strcmp(*argv,\"out\")) {\n        maxoctets_dir = PPP_OCTETS_DIRECTION_OUT;\n    } else if (!strcmp(*argv,\"max\")) {\n        maxoctets_dir = PPP_OCTETS_DIRECTION_MAXOVERAL;\n    } else {\n        maxoctets_dir = PPP_OCTETS_DIRECTION_SUM;\n    }\n    return 1;\n}\n#endif\n\n#ifdef PLUGIN\nstatic int\nloadplugin(argv)\n    char **argv;\n{\n    char *arg = *argv;\n    void *handle;\n    const char *err;\n    void (*init) __P((void));\n    char *path = arg;\n    const char *vers;\n\n    if (strchr(arg, '/') == 0) {\n\tconst char *base = _PATH_PLUGIN;\n\tint l = strlen(base) + strlen(arg) + 2;\n\tpath = malloc(l);\n\tif (path == 0)\n\t    novm(\"plugin file path\");\n\tstrlcpy(path, base, l);\n\tstrlcat(path, \"/\", l);\n\tstrlcat(path, arg, l);\n    }\n    handle = dlopen(path, RTLD_GLOBAL | RTLD_NOW);\n    if (handle == 0) {\n\terr = dlerror();\n\tif (err != 0)\n\t    option_error(\"%s\", err);\n\toption_error(\"Couldn't load plugin %s\", arg);\n\tgoto err;\n    }\n    init = (void (*)(void))dlsym(handle, \"plugin_init\");\n    if (init == 0) {\n\toption_error(\"%s has no initialization entry point\", arg);\n\tgoto errclose;\n    }\n    vers = (const char *) dlsym(handle, \"pppd_version\");\n    if (vers == 0) {\n\twarn(\"Warning: plugin %s has no version information\", arg);\n    } else if (strcmp(vers, VERSION) != 0) {\n\toption_error(\"Plugin %s is for pppd version %s, this is %s\",\n\t\t     arg, vers, VERSION);\n\tgoto errclose;\n    }\n    info(\"Plugin %s loaded.\", arg);\n    (*init)();\n    return 1;\n\n errclose:\n    dlclose(handle);\n err:\n    if (path != arg)\n\tfree(path);\n    return 0;\n}\n#endif /* PLUGIN */\n\n/*\n * Set an environment variable specified by the user.\n */\nstatic int\nuser_setenv(argv)\n    char **argv;\n{\n    char *arg = argv[0];\n    char *eqp;\n    struct userenv *uep, **insp;\n\n    if ((eqp = strchr(arg, '=')) == NULL) {\n\toption_error(\"missing = in name=value: %s\", arg);\n\treturn 0;\n    }\n    if (eqp == arg) {\n\toption_error(\"missing variable name: %s\", arg);\n\treturn 0;\n    }\n    for (uep = userenv_list; uep != NULL; uep = uep->ue_next) {\n\tint nlen = strlen(uep->ue_name);\n\tif (nlen == (eqp - arg) &&\n\t    strncmp(arg, uep->ue_name, nlen) == 0)\n\t    break;\n    }\n    /* Ignore attempts by unprivileged users to override privileged sources */\n    if (uep != NULL && !privileged_option && uep->ue_priv)\n\treturn 1;\n    /* The name never changes, so allocate it with the structure */\n    if (uep == NULL) {\n\tuep = malloc(sizeof (*uep) + (eqp-arg));\n\tstrncpy(uep->ue_name, arg, eqp-arg);\n\tuep->ue_name[eqp-arg] = '\\0';\n\tuep->ue_next = NULL;\n\tinsp = &userenv_list;\n\twhile (*insp != NULL)\n\t    insp = &(*insp)->ue_next;\n\t*insp = uep;\n    } else {\n\tstruct userenv *uep2;\n\tfor (uep2 = userenv_list; uep2 != NULL; uep2 = uep2->ue_next) {\n\t    if (uep2 != uep && !uep2->ue_isset)\n\t\tbreak;\n\t}\n\tif (uep2 == NULL && !uep->ue_isset)\n\t    find_option(\"unset\")->flags |= OPT_NOPRINT;\n\tfree(uep->ue_value);\n    }\n    uep->ue_isset = 1;\n    uep->ue_priv = privileged_option;\n    uep->ue_source = option_source;\n    uep->ue_value = strdup(eqp + 1);\n    curopt->flags &= ~OPT_NOPRINT;\n    return 1;\n}\n\nstatic void\nuser_setprint(opt, printer, arg)\n    option_t *opt;\n    printer_func printer;\n    void *arg;\n{\n    struct userenv *uep, *uepnext;\n\n    uepnext = userenv_list;\n    while (uepnext != NULL && !uepnext->ue_isset)\n\tuepnext = uepnext->ue_next;\n    while ((uep = uepnext) != NULL) {\n\tuepnext = uep->ue_next;\n\twhile (uepnext != NULL && !uepnext->ue_isset)\n\t    uepnext = uepnext->ue_next;\n\t(*printer)(arg, \"%s=%s\", uep->ue_name, uep->ue_value);\n\tif (uepnext != NULL)\n\t    (*printer)(arg, \"\\t\\t# (from %s)\\n%s \", uep->ue_source, opt->name);\n\telse\n\t    opt->source = uep->ue_source;\n    }\n}\n\nstatic int\nuser_unsetenv(argv)\n    char **argv;\n{\n    struct userenv *uep, **insp;\n    char *arg = argv[0];\n\n    if (strchr(arg, '=') != NULL) {\n\toption_error(\"unexpected = in name: %s\", arg);\n\treturn 0;\n    }\n    if (arg == '\\0') {\n\toption_error(\"missing variable name for unset\");\n\treturn 0;\n    }\n    for (uep = userenv_list; uep != NULL; uep = uep->ue_next) {\n\tif (strcmp(arg, uep->ue_name) == 0)\n\t    break;\n    }\n    /* Ignore attempts by unprivileged users to override privileged sources */\n    if (uep != NULL && !privileged_option && uep->ue_priv)\n\treturn 1;\n    /* The name never changes, so allocate it with the structure */\n    if (uep == NULL) {\n\tuep = malloc(sizeof (*uep) + strlen(arg));\n\tstrcpy(uep->ue_name, arg);\n\tuep->ue_next = NULL;\n\tinsp = &userenv_list;\n\twhile (*insp != NULL)\n\t    insp = &(*insp)->ue_next;\n\t*insp = uep;\n    } else {\n\tstruct userenv *uep2;\n\tfor (uep2 = userenv_list; uep2 != NULL; uep2 = uep2->ue_next) {\n\t    if (uep2 != uep && uep2->ue_isset)\n\t\tbreak;\n\t}\n\tif (uep2 == NULL && uep->ue_isset)\n\t    find_option(\"set\")->flags |= OPT_NOPRINT;\n\tfree(uep->ue_value);\n    }\n    uep->ue_isset = 0;\n    uep->ue_priv = privileged_option;\n    uep->ue_source = option_source;\n    uep->ue_value = NULL;\n    curopt->flags &= ~OPT_NOPRINT;\n    return 1;\n}\n\nstatic void\nuser_unsetprint(opt, printer, arg)\n    option_t *opt;\n    printer_func printer;\n    void *arg;\n{\n    struct userenv *uep, *uepnext;\n\n    uepnext = userenv_list;\n    while (uepnext != NULL && uepnext->ue_isset)\n\tuepnext = uepnext->ue_next;\n    while ((uep = uepnext) != NULL) {\n\tuepnext = uep->ue_next;\n\twhile (uepnext != NULL && uepnext->ue_isset)\n\t    uepnext = uepnext->ue_next;\n\t(*printer)(arg, \"%s\", uep->ue_name);\n\tif (uepnext != NULL)\n\t    (*printer)(arg, \"\\t\\t# (from %s)\\n%s \", uep->ue_source, opt->name);\n\telse\n\t    opt->source = uep->ue_source;\n    }\n}\n"], "filenames": ["pppd/options.c"], "buggy_code_start_loc": [1292], "buggy_code_end_loc": [1335], "fixing_code_start_loc": [1292], "fixing_code_end_loc": [1337], "type": "CWE-119", "message": "Integer overflow in the getword function in options.c in pppd in Paul's PPP Package (ppp) before 2.4.7 allows attackers to \"access privileged options\" via a long word in an options file, which triggers a heap-based buffer overflow that \"[corrupts] security-relevant variables.\"", "other": {"cve": {"id": "CVE-2014-3158", "sourceIdentifier": "cve-coordination@google.com", "published": "2014-11-15T21:59:00.117", "lastModified": "2020-02-24T15:55:38.160", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Integer overflow in the getword function in options.c in pppd in Paul's PPP Package (ppp) before 2.4.7 allows attackers to \"access privileged options\" via a long word in an options file, which triggers a heap-based buffer overflow that \"[corrupts] security-relevant variables.\""}, {"lang": "es", "value": "Desbordamiento de enteros en la funci\u00f3n en options.c en pppd en Paul's PPP Package (ppp) anterior a 2.4.7 permite a atacantes el 'Acceso a opciones privilegiadas' a trav\u00e9s de una palabra larga en el archivo de opciones, que provoca un desbordamiento de buffer basado en memoria din\u00e1mica que '(corrompe) las variables relevantes para la seguridad'."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:point-to-point_protocol_project:point-to-point_protocol:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.4.6", "matchCriteriaId": "B82DE957-F0F3-4989-82DC-85712A8D8E44"}]}]}], "references": [{"url": "http://advisories.mageia.org/MGASA-2014-0368.html", "source": "cve-coordination@google.com"}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2014-August/136932.html", "source": "cve-coordination@google.com"}, {"url": "http://marc.info/?l=linux-ppp&m=140764978420764", "source": "cve-coordination@google.com"}, {"url": "http://www.debian.org/security/2014/dsa-3079", "source": "cve-coordination@google.com"}, {"url": "http://www.mandriva.com/security/advisories?name=MDVSA-2015:135", "source": "cve-coordination@google.com"}, {"url": "http://www.oracle.com/technetwork/topics/security/bulletinapr2015-2511959.html", "source": "cve-coordination@google.com"}, {"url": "http://www.ubuntu.com/usn/USN-2429-1", "source": "cve-coordination@google.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1128748", "source": "cve-coordination@google.com"}, {"url": "https://github.com/paulusmack/ppp/commit/7658e8257183f062dc01f87969c140707c7e52cb", "source": "cve-coordination@google.com", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/paulusmack/ppp/commit/7658e8257183f062dc01f87969c140707c7e52cb"}}