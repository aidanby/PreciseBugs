{"buggy_code": ["var parse = require('url').parse\nvar events = require('events')\nvar https = require('https')\nvar http = require('http')\nvar util = require('util')\n\nvar httpsOptions = [\n  'pfx', 'key', 'passphrase', 'cert', 'ca', 'ciphers',\n  'rejectUnauthorized', 'secureProtocol', 'servername', 'checkServerIdentity'\n]\n\nvar bom = [239, 187, 191]\nvar colon = 58\nvar space = 32\nvar lineFeed = 10\nvar carriageReturn = 13\n// Beyond 256KB we could not observe any gain in performance\nvar maxBufferAheadAllocation = 1024 * 256\n\nfunction hasBom (buf) {\n  return bom.every(function (charCode, index) {\n    return buf[index] === charCode\n  })\n}\n\n/**\n * Creates a new EventSource object\n *\n * @param {String} url the URL to which to connect\n * @param {Object} [eventSourceInitDict] extra init params. See README for details.\n * @api public\n **/\nfunction EventSource (url, eventSourceInitDict) {\n  var readyState = EventSource.CONNECTING\n  Object.defineProperty(this, 'readyState', {\n    get: function () {\n      return readyState\n    }\n  })\n\n  Object.defineProperty(this, 'url', {\n    get: function () {\n      return url\n    }\n  })\n\n  var self = this\n  self.reconnectInterval = 1000\n  self.connectionInProgress = false\n\n  function onConnectionClosed (message) {\n    if (readyState === EventSource.CLOSED) return\n    readyState = EventSource.CONNECTING\n    _emit('error', new Event('error', {message: message}))\n\n    // The url may have been changed by a temporary\n    // redirect. If that's the case, revert it now.\n    if (reconnectUrl) {\n      url = reconnectUrl\n      reconnectUrl = null\n    }\n    setTimeout(function () {\n      if (readyState !== EventSource.CONNECTING || self.connectionInProgress) {\n        return\n      }\n      self.connectionInProgress = true\n      connect()\n    }, self.reconnectInterval)\n  }\n\n  var req\n  var lastEventId = ''\n  if (eventSourceInitDict && eventSourceInitDict.headers && eventSourceInitDict.headers['Last-Event-ID']) {\n    lastEventId = eventSourceInitDict.headers['Last-Event-ID']\n    delete eventSourceInitDict.headers['Last-Event-ID']\n  }\n\n  var discardTrailingNewline = false\n  var data = ''\n  var eventName = ''\n\n  var reconnectUrl = null\n\n  function connect () {\n    var options = parse(url)\n    var isSecure = options.protocol === 'https:'\n    options.headers = { 'Cache-Control': 'no-cache', 'Accept': 'text/event-stream' }\n    if (lastEventId) options.headers['Last-Event-ID'] = lastEventId\n    if (eventSourceInitDict && eventSourceInitDict.headers) {\n      for (var i in eventSourceInitDict.headers) {\n        var header = eventSourceInitDict.headers[i]\n        if (header) {\n          options.headers[i] = header\n        }\n      }\n    }\n\n    // Legacy: this should be specified as `eventSourceInitDict.https.rejectUnauthorized`,\n    // but for now exists as a backwards-compatibility layer\n    options.rejectUnauthorized = !(eventSourceInitDict && !eventSourceInitDict.rejectUnauthorized)\n\n    if (eventSourceInitDict && eventSourceInitDict.createConnection !== undefined) {\n      options.createConnection = eventSourceInitDict.createConnection\n    }\n\n    // If specify http proxy, make the request to sent to the proxy server,\n    // and include the original url in path and Host headers\n    var useProxy = eventSourceInitDict && eventSourceInitDict.proxy\n    if (useProxy) {\n      var proxy = parse(eventSourceInitDict.proxy)\n      isSecure = proxy.protocol === 'https:'\n\n      options.protocol = isSecure ? 'https:' : 'http:'\n      options.path = url\n      options.headers.Host = options.host\n      options.hostname = proxy.hostname\n      options.host = proxy.host\n      options.port = proxy.port\n    }\n\n    // If https options are specified, merge them into the request options\n    if (eventSourceInitDict && eventSourceInitDict.https) {\n      for (var optName in eventSourceInitDict.https) {\n        if (httpsOptions.indexOf(optName) === -1) {\n          continue\n        }\n\n        var option = eventSourceInitDict.https[optName]\n        if (option !== undefined) {\n          options[optName] = option\n        }\n      }\n    }\n\n    // Pass this on to the XHR\n    if (eventSourceInitDict && eventSourceInitDict.withCredentials !== undefined) {\n      options.withCredentials = eventSourceInitDict.withCredentials\n    }\n\n    req = (isSecure ? https : http).request(options, function (res) {\n      self.connectionInProgress = false\n      // Handle HTTP errors\n      if (res.statusCode === 500 || res.statusCode === 502 || res.statusCode === 503 || res.statusCode === 504) {\n        _emit('error', new Event('error', {status: res.statusCode, message: res.statusMessage}))\n        onConnectionClosed()\n        return\n      }\n\n      // Handle HTTP redirects\n      if (res.statusCode === 301 || res.statusCode === 302 || res.statusCode === 307) {\n        if (!res.headers.location) {\n          // Server sent redirect response without Location header.\n          _emit('error', new Event('error', {status: res.statusCode, message: res.statusMessage}))\n          return\n        }\n        if (res.statusCode === 307) reconnectUrl = url\n        url = res.headers.location\n        process.nextTick(connect)\n        return\n      }\n\n      if (res.statusCode !== 200) {\n        _emit('error', new Event('error', {status: res.statusCode, message: res.statusMessage}))\n        return self.close()\n      }\n\n      readyState = EventSource.OPEN\n      res.on('close', function () {\n        res.removeAllListeners('close')\n        res.removeAllListeners('end')\n        onConnectionClosed()\n      })\n\n      res.on('end', function () {\n        res.removeAllListeners('close')\n        res.removeAllListeners('end')\n        onConnectionClosed()\n      })\n      _emit('open', new Event('open'))\n\n      // text/event-stream parser adapted from webkit's\n      // Source/WebCore/page/EventSource.cpp\n      var buf\n      var newBuffer\n      var startingPos = 0\n      var startingFieldLength = -1\n      var newBufferSize = 0\n      var bytesUsed = 0\n\n      res.on('data', function (chunk) {\n        if (!buf) {\n          buf = chunk\n          if (hasBom(buf)) {\n            buf = buf.slice(bom.length)\n          }\n          bytesUsed = buf.length\n        } else {\n          if (chunk.length > buf.length - bytesUsed) {\n            newBufferSize = (buf.length * 2) + chunk.length\n            if (newBufferSize > maxBufferAheadAllocation) {\n              newBufferSize = buf.length + chunk.length + maxBufferAheadAllocation\n            }\n            newBuffer = Buffer.alloc(newBufferSize)\n            buf.copy(newBuffer, 0, 0, bytesUsed)\n            buf = newBuffer\n          }\n          chunk.copy(buf, bytesUsed)\n          bytesUsed += chunk.length\n        }\n\n        var pos = 0\n        var length = bytesUsed\n\n        while (pos < length) {\n          if (discardTrailingNewline) {\n            if (buf[pos] === lineFeed) {\n              ++pos\n            }\n            discardTrailingNewline = false\n          }\n\n          var lineLength = -1\n          var fieldLength = startingFieldLength\n          var c\n\n          for (var i = startingPos; lineLength < 0 && i < length; ++i) {\n            c = buf[i]\n            if (c === colon) {\n              if (fieldLength < 0) {\n                fieldLength = i - pos\n              }\n            } else if (c === carriageReturn) {\n              discardTrailingNewline = true\n              lineLength = i - pos\n            } else if (c === lineFeed) {\n              lineLength = i - pos\n            }\n          }\n\n          if (lineLength < 0) {\n            startingPos = length - pos\n            startingFieldLength = fieldLength\n            break\n          } else {\n            startingPos = 0\n            startingFieldLength = -1\n          }\n\n          parseEventStreamLine(buf, pos, fieldLength, lineLength)\n\n          pos += lineLength + 1\n        }\n\n        if (pos === length) {\n          buf = void 0\n          bytesUsed = 0\n        } else if (pos > 0) {\n          buf = buf.slice(pos, bytesUsed)\n          bytesUsed = buf.length\n        }\n      })\n    })\n\n    req.on('error', function (err) {\n      self.connectionInProgress = false\n      onConnectionClosed(err.message)\n    })\n\n    if (req.setNoDelay) req.setNoDelay(true)\n    req.end()\n  }\n\n  connect()\n\n  function _emit () {\n    if (self.listeners(arguments[0]).length > 0) {\n      self.emit.apply(self, arguments)\n    }\n  }\n\n  this._close = function () {\n    if (readyState === EventSource.CLOSED) return\n    readyState = EventSource.CLOSED\n    if (req.abort) req.abort()\n    if (req.xhr && req.xhr.abort) req.xhr.abort()\n  }\n\n  function parseEventStreamLine (buf, pos, fieldLength, lineLength) {\n    if (lineLength === 0) {\n      if (data.length > 0) {\n        var type = eventName || 'message'\n        _emit(type, new MessageEvent(type, {\n          data: data.slice(0, -1), // remove trailing newline\n          lastEventId: lastEventId,\n          origin: new URL(url).origin\n        }))\n        data = ''\n      }\n      eventName = void 0\n    } else if (fieldLength > 0) {\n      var noValue = fieldLength < 0\n      var step = 0\n      var field = buf.slice(pos, pos + (noValue ? lineLength : fieldLength)).toString()\n\n      if (noValue) {\n        step = lineLength\n      } else if (buf[pos + fieldLength + 1] !== space) {\n        step = fieldLength + 1\n      } else {\n        step = fieldLength + 2\n      }\n      pos += step\n\n      var valueLength = lineLength - step\n      var value = buf.slice(pos, pos + valueLength).toString()\n\n      if (field === 'data') {\n        data += value + '\\n'\n      } else if (field === 'event') {\n        eventName = value\n      } else if (field === 'id') {\n        lastEventId = value\n      } else if (field === 'retry') {\n        var retry = parseInt(value, 10)\n        if (!Number.isNaN(retry)) {\n          self.reconnectInterval = retry\n        }\n      }\n    }\n  }\n}\n\nmodule.exports = EventSource\n\nutil.inherits(EventSource, events.EventEmitter)\nEventSource.prototype.constructor = EventSource; // make stacktraces readable\n\n['open', 'error', 'message'].forEach(function (method) {\n  Object.defineProperty(EventSource.prototype, 'on' + method, {\n    /**\n     * Returns the current listener\n     *\n     * @return {Mixed} the set function or undefined\n     * @api private\n     */\n    get: function get () {\n      var listener = this.listeners(method)[0]\n      return listener ? (listener._listener ? listener._listener : listener) : undefined\n    },\n\n    /**\n     * Start listening for events\n     *\n     * @param {Function} listener the listener\n     * @return {Mixed} the set function or undefined\n     * @api private\n     */\n    set: function set (listener) {\n      this.removeAllListeners(method)\n      this.addEventListener(method, listener)\n    }\n  })\n})\n\n/**\n * Ready states\n */\nObject.defineProperty(EventSource, 'CONNECTING', {enumerable: true, value: 0})\nObject.defineProperty(EventSource, 'OPEN', {enumerable: true, value: 1})\nObject.defineProperty(EventSource, 'CLOSED', {enumerable: true, value: 2})\n\nEventSource.prototype.CONNECTING = 0\nEventSource.prototype.OPEN = 1\nEventSource.prototype.CLOSED = 2\n\n/**\n * Closes the connection, if one is made, and sets the readyState attribute to 2 (closed)\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/EventSource/close\n * @api public\n */\nEventSource.prototype.close = function () {\n  this._close()\n}\n\n/**\n * Emulates the W3C Browser based WebSocket interface using addEventListener.\n *\n * @param {String} type A string representing the event type to listen out for\n * @param {Function} listener callback\n * @see https://developer.mozilla.org/en/DOM/element.addEventListener\n * @see http://dev.w3.org/html5/websockets/#the-websocket-interface\n * @api public\n */\nEventSource.prototype.addEventListener = function addEventListener (type, listener) {\n  if (typeof listener === 'function') {\n    // store a reference so we can return the original function again\n    listener._listener = listener\n    this.on(type, listener)\n  }\n}\n\n/**\n * Emulates the W3C Browser based WebSocket interface using dispatchEvent.\n *\n * @param {Event} event An event to be dispatched\n * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/dispatchEvent\n * @api public\n */\nEventSource.prototype.dispatchEvent = function dispatchEvent (event) {\n  if (!event.type) {\n    throw new Error('UNSPECIFIED_EVENT_TYPE_ERR')\n  }\n  // if event is instance of an CustomEvent (or has 'details' property),\n  // send the detail object as the payload for the event\n  this.emit(event.type, event.detail)\n}\n\n/**\n * Emulates the W3C Browser based WebSocket interface using removeEventListener.\n *\n * @param {String} type A string representing the event type to remove\n * @param {Function} listener callback\n * @see https://developer.mozilla.org/en/DOM/element.removeEventListener\n * @see http://dev.w3.org/html5/websockets/#the-websocket-interface\n * @api public\n */\nEventSource.prototype.removeEventListener = function removeEventListener (type, listener) {\n  if (typeof listener === 'function') {\n    listener._listener = undefined\n    this.removeListener(type, listener)\n  }\n}\n\n/**\n * W3C Event\n *\n * @see http://www.w3.org/TR/DOM-Level-3-Events/#interface-Event\n * @api private\n */\nfunction Event (type, optionalProperties) {\n  Object.defineProperty(this, 'type', { writable: false, value: type, enumerable: true })\n  if (optionalProperties) {\n    for (var f in optionalProperties) {\n      if (optionalProperties.hasOwnProperty(f)) {\n        Object.defineProperty(this, f, { writable: false, value: optionalProperties[f], enumerable: true })\n      }\n    }\n  }\n}\n\n/**\n * W3C MessageEvent\n *\n * @see http://www.w3.org/TR/webmessaging/#event-definitions\n * @api private\n */\nfunction MessageEvent (type, eventInitDict) {\n  Object.defineProperty(this, 'type', { writable: false, value: type, enumerable: true })\n  for (var f in eventInitDict) {\n    if (eventInitDict.hasOwnProperty(f)) {\n      Object.defineProperty(this, f, { writable: false, value: eventInitDict[f], enumerable: true })\n    }\n  }\n}\n", "/* eslint-disable no-new */\nvar EventSource = require('../lib/eventsource')\nvar bufferFrom = require('buffer-from')\nvar path = require('path')\nvar http = require('http')\nvar https = require('https')\nvar fs = require('fs')\nvar mocha = require('mocha')\nvar assert = require('assert')\nvar u = require('url')\nvar net = require('net')\n\nvar it = mocha.it\nvar describe = mocha.describe\n\nvar httpsServerOptions = {\n  key: fs.readFileSync(path.join(__dirname, 'server_certs', 'key.pem')),\n  cert: fs.readFileSync(path.join(__dirname, 'server_certs', 'certificate.pem'))\n}\n\nvar _port = 20000\nvar servers = []\nprocess.on('exit', function () {\n  if (servers.length > 0) {\n    console.error(\"************ Didn't kill all servers - there is still %d running.\", servers.length)\n  }\n})\n\nfunction createServer (callback) {\n  var server = http.createServer()\n  configureServer(server, 'http', _port++, callback)\n}\n\nfunction createHttpsServer (callback) {\n  var server = https.createServer(httpsServerOptions)\n  configureServer(server, 'https', _port++, callback)\n}\n\nfunction createHttpsServerWithClientAuth (callback) {\n  var options = {\n    key: fs.readFileSync(path.join(__dirname, 'client_certs', 'server_key.pem')),\n    cert: fs.readFileSync(path.join(__dirname, 'client_certs', 'server_cert.crt')),\n    ca: fs.readFileSync(path.join(__dirname, 'client_certs', 'cacert.crt')),\n    passphrase: 'test1234$',\n    requestCert: true,\n    rejectAuthorized: true\n  }\n  var server = https.createServer(options)\n  configureServer(server, 'https', _port++, callback)\n}\n\nfunction configureServer (server, protocol, port, callback) {\n  var responses = []\n\n  var oldClose = server.close\n  server.close = function (closeCb) {\n    responses.forEach(function (res) {\n      res.end()\n    })\n    oldClose.call(this, function () {\n      servers.splice(servers.indexOf(server), 1)\n      closeCb()\n    })\n  }\n\n  server.on('request', function (req, res) {\n    responses.push(res)\n  })\n\n  server.url = protocol + '://localhost:' + port\n\n  server.listen(port, function onOpen (err) {\n    servers.push(server)\n    callback(err, server)\n  })\n}\n\nfunction createProxy (target, protocol, callback) {\n  var proxyPort = _port++\n  var targetProtocol = target.indexOf('https') === 0 ? 'https' : 'http'\n  var requester = targetProtocol === 'https' ? https : http\n  var serve = protocol === 'https' ? https : http\n\n  var proxied = []\n  var server = serve.createServer(serve === https ? httpsServerOptions : undefined)\n\n  server.on('request', function (req, res) {\n    var options = u.parse(target)\n    options.headers = req.headers\n    options.rejectUnauthorized = false\n\n    var upstreamReq = requester.request(options, function (upstreamRes) {\n      upstreamRes.pipe(res)\n    })\n\n    proxied.push({req: upstreamReq, res: res})\n    upstreamReq.end()\n  })\n\n  servers.push(server)\n\n  var oldClose = server.close\n  server.close = function (closeCb) {\n    proxied.forEach(function (pair) {\n      pair.req.abort()\n      pair.res.destroy()\n    })\n\n    oldClose.call(server, function () {\n      servers.splice(servers.indexOf(server), 1)\n      closeCb()\n    })\n  }\n\n  server.listen(proxyPort, function onOpen (err) {\n    server.url = protocol + '://localhost:' + proxyPort\n    callback(err, server)\n  })\n}\n\nfunction writeEvents (chunks) {\n  return function (req, res) {\n    res.writeHead(200, {'Content-Type': 'text/event-stream'})\n    chunks.forEach(function (chunk) {\n      res.write(chunk)\n    })\n    res.write(':') // send a dummy comment to ensure that the head is flushed\n  }\n}\n\ndescribe('Parser', function () {\n  it('parses multibyte characters', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents(['id: 1\\ndata: \u20ac\u8c46\u8150\\n\\n']))\n      var es = new EventSource(server.url)\n\n      es.onmessage = function (m) {\n        assert.equal('\u20ac\u8c46\u8150', m.data)\n        server.close(done)\n      }\n    })\n  })\n\n  it('parses empty lines with multibyte characters', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents(['\\n\\n\\n\\nid: 1\\ndata: \u6211\u73fe\u5728\u90fd\u770b\u5be6\u6cc1\u4e0d\u73a9\u904a\u6232\\n\\n']))\n      var es = new EventSource(server.url)\n\n      es.onmessage = function (m) {\n        assert.equal('\u6211\u73fe\u5728\u90fd\u770b\u5be6\u6cc1\u4e0d\u73a9\u904a\u6232', m.data)\n        server.close(done)\n      }\n    })\n  })\n\n  it('parses one one-line message in one chunk', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents(['data: Hello\\n\\n']))\n      var es = new EventSource(server.url)\n      es.onmessage = function (m) {\n        assert.equal('Hello', m.data)\n        server.close(done)\n      }\n    })\n  })\n\n  it('ignores byte-order mark', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', function (req, res) {\n        res.writeHead(200, {'Content-Type': 'text/event-stream'})\n        res.write('\\uFEFF')\n        res.write('data: foo\\n\\n')\n        res.end()\n      })\n      var es = new EventSource(server.url)\n      es.onmessage = function (m) {\n        assert.equal('foo', m.data)\n        server.close(done)\n      }\n    })\n  })\n\n  it('parses one one-line message in two chunks', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents(['data: Hel', 'lo\\n\\n']))\n      var es = new EventSource(server.url)\n      es.onmessage = function (m) {\n        assert.equal('Hello', m.data)\n        server.close(done)\n      }\n    })\n  })\n\n  it('parses two one-line messages in one chunk', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents(['data: Hello\\n\\n', 'data: World\\n\\n']))\n      var es = new EventSource(server.url)\n\n      es.onmessage = first\n\n      function first (m) {\n        assert.equal('Hello', m.data)\n        es.onmessage = second\n      }\n\n      function second (m) {\n        assert.equal('World', m.data)\n        server.close(done)\n      }\n    })\n  })\n\n  it('parses one two-line message in one chunk', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents(['data: Hello\\ndata:World\\n\\n']))\n      var es = new EventSource(server.url)\n\n      es.onmessage = function (m) {\n        assert.equal('Hello\\nWorld', m.data)\n        server.close(done)\n      }\n    })\n  })\n\n  it('parses chopped up unicode data', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      var chopped = 'data: Aslak\\n\\ndata: Helles\u00f8y\\n\\n'.split('')\n      server.on('request', writeEvents(chopped))\n      var es = new EventSource(server.url)\n\n      es.onmessage = first\n\n      function first (m) {\n        assert.equal('Aslak', m.data)\n        es.onmessage = second\n      }\n\n      function second (m) {\n        assert.equal('Helles\u00f8y', m.data)\n        server.close(done)\n      }\n    })\n  })\n\n  it('parses really chopped up unicode data', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', function (req, res) {\n        const msg = bufferFrom('data: Aslak Helles\u00f8y is the original author\\n\\n')\n        res.writeHead(200, {'Content-Type': 'text/event-stream'})\n\n        // Slice in the middle of a unicode sequence (\u00f8), making sure that one data\n        // chunk will contain the first byte and the second chunk will get the other\n        res.write(msg.slice(0, 19), 'binary', function () {\n          res.write(msg.slice(19))\n        })\n      })\n\n      var es = new EventSource(server.url)\n\n      es.onmessage = function (m) {\n        assert.equal('Aslak Helles\u00f8y is the original author', m.data)\n        server.close(done)\n      }\n    })\n  })\n\n  it('accepts CRLF as separator', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      var chopped = 'data: Aslak\\r\\n\\r\\ndata: Helles\u00f8y\\r\\n\\r\\n'.split('')\n      server.on('request', writeEvents(chopped))\n      var es = new EventSource(server.url)\n\n      es.onmessage = first\n\n      function first (m) {\n        assert.equal('Aslak', m.data)\n        es.onmessage = second\n      }\n\n      function second (m) {\n        assert.equal('Helles\u00f8y', m.data)\n        server.close(done)\n      }\n    })\n  })\n\n  it('accepts CR as separator', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      var chopped = 'data: Aslak\\r\\rdata: Helles\u00f8y\\r\\r'.split('')\n      server.on('request', writeEvents(chopped))\n      var es = new EventSource(server.url)\n\n      es.onmessage = first\n\n      function first (m) {\n        assert.equal('Aslak', m.data)\n        es.onmessage = second\n      }\n\n      function second (m) {\n        assert.equal('Helles\u00f8y', m.data)\n        server.close(done)\n      }\n    })\n  })\n\n  it('delivers message with explicit event', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents(['event: greeting\\ndata: Hello\\n\\n']))\n      var es = new EventSource(server.url)\n\n      es.addEventListener('greeting', function (m) {\n        assert.equal('Hello', m.data)\n        server.close(done)\n      })\n    })\n  })\n\n  it('allows removal of event listeners', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents(['event: greeting\\ndata: Hello\\n\\n', 'event: greeting\\ndata: World\\n\\n']))\n      var es = new EventSource(server.url)\n      var numCalled = 0\n\n      function onGreeting (m) {\n        numCalled++\n        assert.equal('Hello', m.data)\n        es.removeEventListener('greeting', onGreeting, false)\n        process.nextTick(scheduleDisconnect)\n      }\n\n      function scheduleDisconnect () {\n        assert.equal(1, numCalled)\n        server.close(done)\n      }\n\n      es.addEventListener('greeting', onGreeting, false)\n    })\n  })\n\n  it('ignores comments', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents(['data: Hello\\n\\n:nothing to see here\\n\\ndata: World\\n\\n']))\n      var es = new EventSource(server.url)\n\n      es.onmessage = first\n\n      function first (m) {\n        assert.equal('Hello', m.data)\n        es.onmessage = second\n      }\n\n      function second (m) {\n        assert.equal('World', m.data)\n        server.close(done)\n      }\n    })\n  })\n\n  it('ignores empty comments', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents(['data: Hello\\n\\n:\\n\\ndata: World\\n\\n']))\n      var es = new EventSource(server.url)\n\n      es.onmessage = first\n\n      function first (m) {\n        assert.equal('Hello', m.data)\n        es.onmessage = second\n      }\n\n      function second (m) {\n        assert.equal('World', m.data)\n        server.close(done)\n      }\n    })\n  })\n\n  it('does not ignore multilines strings', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents(['data: line one\\ndata:\\ndata: line two\\n\\n']))\n      var es = new EventSource(server.url)\n\n      es.onmessage = function (m) {\n        assert.equal('line one\\n\\nline two', m.data)\n        server.close(done)\n      }\n    })\n  })\n\n  it('does not ignore multilines strings even in data beginning', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents(['data:\\ndata:line one\\ndata: line two\\n\\n']))\n      var es = new EventSource(server.url)\n\n      es.onmessage = function (m) {\n        assert.equal('\\nline one\\nline two', m.data)\n        server.close(done)\n      }\n    })\n  })\n\n  it('causes entire event to be ignored for empty event field', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents(['event:\\n\\ndata: Hello\\n\\n']))\n      var es = new EventSource(server.url)\n\n      var originalEmit = es.emit\n      es.emit = function (event) {\n        assert.ok(event === 'message' || event === 'newListener')\n        return originalEmit.apply(this, arguments)\n      }\n      es.onmessage = function (m) {\n        assert.equal('Hello', m.data)\n        server.close(done)\n      }\n    })\n  })\n\n  it('parses relatively huge messages efficiently', function (done) {\n    this.timeout(200)\n\n    createServer(function (err, server) {\n      if (err) return done(err)\n      var longMessage = 'data: ' + new Array(100000).join('a') + '\\n\\n'\n      server.on('request', writeEvents([longMessage]))\n\n      var es = new EventSource(server.url)\n\n      es.onmessage = function () {\n        server.close(done)\n      }\n    })\n  })\n\n  it('parses a relatively huge message across many chunks efficiently', function (done) {\n    this.timeout(1000)\n\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      var longMessageContent = new Array(100000).join('a')\n      var longMessage = 'data: ' + longMessageContent + '\\n\\n'\n      var longMessageChunks = longMessage.match(/[\\s\\S]{1,10}/g) // Split the message into chunks of 10 characters\n      server.on('request', writeEvents(longMessageChunks))\n\n      var es = new EventSource(server.url)\n\n      es.onmessage = function (m) {\n        assert.equal(longMessageContent, m.data)\n        server.close(done)\n      }\n    })\n  })\n})\n\ndescribe('HTTP Request', function () {\n  it('passes cache-control: no-cache to server', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', function (req) {\n        assert.equal('no-cache', req.headers['cache-control'])\n        server.close(done)\n      })\n\n      new EventSource(server.url)\n    })\n  })\n\n  it('sets request headers', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', function (req) {\n        assert.equal(req.headers['user-agent'], 'test')\n        assert.equal(req.headers['cookie'], 'test=test')\n        assert.equal(req.headers['last-event-id'], '99')\n        server.close(done)\n      })\n\n      var headers = {\n        'User-Agent': 'test',\n        'Cookie': 'test=test',\n        'Last-Event-ID': '99'\n      }\n      new EventSource(server.url, {headers: headers})\n    })\n  })\n\n  it(\"does not set request headers that don't have a value\", function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', function (req) {\n        assert.equal(req.headers['user-agent'], 'test')\n        assert.equal(req.headers['cookie'], 'test=test')\n        assert.equal(req.headers['last-event-id'], '99')\n        assert.equal(req.headers['X-Something'], undefined)\n        server.close(done)\n      })\n\n      var headers = {\n        'User-Agent': 'test',\n        'Cookie': 'test=test',\n        'Last-Event-ID': '99',\n        'X-Something': null\n      }\n\n      assert.doesNotThrow(\n        function () {\n          new EventSource(server.url, {headers: headers})\n        }\n      )\n    })\n  });\n\n  [301, 302, 307].forEach(function (status) {\n    it('follows http ' + status + ' redirect', function (done) {\n      var redirectSuffix = '/foobar'\n      var clientRequestedRedirectUrl = false\n      createServer(function (err, server) {\n        if (err) return done(err)\n\n        server.on('request', function (req, res) {\n          if (req.url === '/') {\n            res.writeHead(status, {\n              'Connection': 'Close',\n              'Location': server.url + redirectSuffix\n            })\n            res.end()\n          } else if (req.url === redirectSuffix) {\n            clientRequestedRedirectUrl = true\n            res.writeHead(200, {'Content-Type': 'text/event-stream'})\n            res.end()\n          }\n        })\n\n        var es = new EventSource(server.url)\n        es.onopen = function () {\n          assert.ok(clientRequestedRedirectUrl)\n          assert.equal(server.url + redirectSuffix, es.url)\n          server.close(done)\n        }\n      })\n    })\n\n    it('causes error event when response is ' + status + ' with missing location', function (done) {\n      createServer(function (err, server) {\n        if (err) return done(err)\n\n        server.on('request', function (req, res) {\n          res.writeHead(status, 'status message', {\n            'Connection': 'Close'\n          })\n          res.end()\n        })\n\n        var es = new EventSource(server.url)\n        es.onerror = function (err) {\n          assert.equal(err.status, status)\n          assert.equal(err.message, 'status message')\n          server.close(done)\n        }\n      })\n    })\n  });\n\n  [401, 403].forEach(function (status) {\n    it('causes error event when response status is ' + status, function (done) {\n      createServer(function (err, server) {\n        if (err) return done(err)\n\n        server.on('request', function (req, res) {\n          res.writeHead(status, 'status message', {'Content-Type': 'text/html'})\n          res.end()\n        })\n\n        var es = new EventSource(server.url)\n        es.onerror = function (err) {\n          assert.equal(err.status, status)\n          assert.equal(err.message, 'status message')\n          server.close(done)\n        }\n      })\n    })\n  })\n\n  it('checks createConnection option', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      var testResult = false\n\n      server.on('request', function () {\n        assert.ok(testResult)\n        server.close(done)\n      })\n\n      var urlObj = u.parse(server.url)\n\n      new EventSource(server.url, {\n        createConnection: function () {\n          var connection = net.createConnection({ port: urlObj.port, host: urlObj.hostname })\n          connection.on('connect', function () {\n            testResult = true\n          })\n          return connection\n        }\n      })\n    })\n  })\n})\n\ndescribe('HTTPS Support', function () {\n  it('uses https for https urls', function (done) {\n    createHttpsServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents(['data: hello\\n\\n']))\n      var es = new EventSource(server.url, {rejectUnauthorized: false})\n\n      es.onmessage = function (m) {\n        assert.equal('hello', m.data)\n        server.close(done)\n      }\n    })\n  })\n})\n\ndescribe('HTTPS Client Certificate Support', function () {\n  it('uses client certificate for https urls', function (done) {\n    this.timeout(1500000)\n    createHttpsServerWithClientAuth(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents(['data: hello\\n\\n']))\n      var es = new EventSource(server.url,\n        {\n          https: {\n            key: fs.readFileSync(path.join(__dirname, 'client_certs', 'client_key.pem')),\n            cert: fs.readFileSync(path.join(__dirname, 'client_certs', 'client_cert.crt')),\n            ca: fs.readFileSync(path.join(__dirname, 'client_certs', 'cacert.crt')),\n            passphrase: 'test1234$',\n            rejectUnauthorized: true\n          }\n        }\n      )\n      es.onmessage = function (m) {\n        assert.equal('hello', m.data)\n        server.close(done)\n      }\n    })\n  })\n})\n\ndescribe('Reconnection', function () {\n  it('is attempted when server is down', function (done) {\n    var es = new EventSource('http://localhost:' + _port)\n    es.reconnectInterval = 0\n\n    es.onerror = function () {\n      es.onerror = null\n      createServer(function (err, server) {\n        if (err) return done(err)\n\n        server.on('request', writeEvents(['data: hello\\n\\n']))\n\n        es.onmessage = function (m) {\n          assert.equal('hello', m.data)\n          server.close(done)\n        }\n      })\n    }\n  })\n\n  it('continuing attempts when server is down', function (done) {\n    // Seems set reconnectInterval=0 not work here, this makes total time spent for current case more than 3S\n    this.timeout(4000)\n\n    var es = new EventSource('http://localhost:' + _port++)\n    es.reconnectInterval = 0\n    var reconnectCount = 0\n\n    es.onerror = function () {\n      reconnectCount++\n      // make sure client is keeping reconnecting\n      if (reconnectCount > 2) {\n        es.onerror = null\n        var port = u.parse(es.url).port\n        configureServer(http.createServer(), 'http', port, function (err, server) {\n          if (err) return done(err)\n\n          server.on('request', writeEvents(['data: hello\\n\\n']))\n\n          es.onmessage = function (m) {\n            assert.equal('hello', m.data)\n            server.close(done)\n          }\n        })\n      }\n    }\n  })\n\n  it('is attempted when server goes down after connection', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents(['data: hello\\n\\n']))\n      var es = new EventSource(server.url)\n      es.reconnectInterval = 0\n\n      es.onmessage = function (m) {\n        assert.equal('hello', m.data)\n        server.close(function (err) {\n          if (err) return done(err)\n\n          var port = u.parse(es.url).port\n          configureServer(http.createServer(), 'http', port, function (err, server2) {\n            if (err) return done(err)\n\n            server2.on('request', writeEvents(['data: world\\n\\n']))\n            es.onmessage = function (m) {\n              assert.equal('world', m.data)\n              server2.close(done)\n            }\n          })\n        })\n      }\n    })\n  })\n\n  it('is attempted when the server responds with a 500', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', function (req, res) {\n        res.writeHead(500)\n        res.end()\n      })\n\n      var es = new EventSource(server.url)\n      es.reconnectInterval = 0\n\n      var errored = false\n\n      es.onerror = function () {\n        if (errored) return\n        errored = true\n        server.close(function (err) {\n          if (err) return done(err)\n\n          var port = u.parse(es.url).port\n          configureServer(http.createServer(), 'http', port, function (err, server2) {\n            if (err) return done(err)\n\n            server2.on('request', writeEvents(['data: hello\\n\\n']))\n            es.onmessage = function (m) {\n              assert.equal('hello', m.data)\n              server2.close(done)\n            }\n          })\n        })\n      }\n    })\n  })\n\n  it('is stopped when server goes down and eventsource is being closed', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents(['data: hello\\n\\n']))\n      var es = new EventSource(server.url)\n      es.reconnectInterval = 0\n\n      es.onmessage = function (m) {\n        assert.equal('hello', m.data)\n        server.close(function (err) {\n          if (err) return done(err)\n          // The server has closed down. es.onerror should now get called,\n          // because es's remote connection was dropped.\n        })\n      }\n\n      es.onerror = function () {\n        // We received an error because the remote connection was closed.\n        // We close es, so we do not want es to reconnect.\n        es.close()\n\n        var port = u.parse(es.url).port\n        configureServer(http.createServer(), 'http', port, function (err, server2) {\n          if (err) return done(err)\n          server2.on('request', writeEvents(['data: world\\n\\n']))\n\n          es.onmessage = function (m) {\n            return done(new Error('Unexpected message: ' + m.data))\n          }\n\n          setTimeout(function () {\n            // We have not received any message within 100ms, we can\n            // presume this works correctly.\n            server2.close(done)\n          }, 100)\n        })\n      }\n    })\n  })\n\n  it('is not attempted when server responds with non-200 and non-500', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', function (req, res) {\n        res.writeHead(204, 'status message')\n        res.end()\n      })\n\n      var es = new EventSource(server.url)\n      es.reconnectInterval = 0\n\n      es.onerror = function (e) {\n        assert.equal(e.status, 204)\n        assert.equal(e.message, 'status message')\n        server.close(function (err) {\n          if (err) return done(err)\n\n          var port = u.parse(es.url).port\n          configureServer(http.createServer(), 'http', port, function (err, server2) {\n            if (err) return done(err)\n\n            // this will be verified by the readyState\n            // going from CONNECTING to CLOSED,\n            // along with the tests verifying that the\n            // state is CONNECTING when a server closes.\n            // it's next to impossible to write a fail-safe\n            // test for this, though.\n            var ival = setInterval(function () {\n              if (es.readyState === EventSource.CLOSED) {\n                clearInterval(ival)\n                server2.close(done)\n              }\n            }, 5)\n          })\n        })\n      }\n    })\n  })\n\n  it('sends Last-Event-ID http header when it has previously been passed in an event from the server', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents(['id: 10\\ndata: Hello\\n\\n']))\n\n      var es = new EventSource(server.url)\n      es.reconnectInterval = 0\n\n      es.onmessage = function () {\n        server.close(function (err) {\n          if (err) return done(err)\n\n          var port = u.parse(es.url).port\n          configureServer(http.createServer(), 'http', port, function (err, server2) {\n            if (err) return done(err)\n\n            server2.on('request', function (req, res) {\n              assert.equal('10', req.headers['last-event-id'])\n              server2.close(done)\n            })\n          })\n        })\n      }\n    })\n  })\n\n  it('sends correct Last-Event-ID http header when an initial Last-Event-ID header was specified in the constructor', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', function (req, res) {\n        assert.equal('9', req.headers['last-event-id'])\n        server.close(done)\n      })\n\n      new EventSource(server.url, {headers: {'Last-Event-ID': '9'}})\n    })\n  })\n\n  it('does not send Last-Event-ID http header when it has not been previously sent by the server', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents(['data: Hello\\n\\n']))\n\n      var es = new EventSource(server.url)\n      es.reconnectInterval = 0\n\n      es.onmessage = function () {\n        server.close(function (err) {\n          if (err) return done(err)\n\n          var port = u.parse(es.url).port\n          configureServer(http.createServer(), 'http', port, function (err, server2) {\n            if (err) return done(err)\n\n            server2.on('request', function (req, res) {\n              assert.equal(undefined, req.headers['last-event-id'])\n              server2.close(done)\n            })\n          })\n        })\n      }\n    })\n  })\n\n  it('attempts to reconnect are deduplicated on sequential erorrs', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n      var events = ['data: Hello']\n      var eventsSent = 0\n      var errorOccurred = false\n      server.on('request', function (req, res) {\n        if (eventsSent === 0) {\n          var fn = writeEvents(events)\n          fn(req, res)\n          eventsSent++\n          // now cause a few errors\n          fn(req, res)\n          eventsSent++\n        } else {\n          assert.equal(EventSource.CONNECTING, es.readyState)\n          assert.ok(errorOccurred)\n          server.close(done)\n        }\n      })\n\n      var es = new EventSource(server.url)\n      assert.equal(EventSource.CONNECTING, es.readyState)\n      es.reconnectInterval = 0\n      es.onerror = function (err) {\n        errorOccurred = !!(errorOccurred || err)\n      }\n    })\n  })\n})\n\ndescribe('readyState', function () {\n  it('has CONNECTING constant', function () {\n    assert.equal(0, EventSource.CONNECTING)\n  })\n\n  it('has OPEN constant', function () {\n    assert.equal(1, EventSource.OPEN)\n  })\n\n  it('has CLOSED constant', function () {\n    assert.equal(2, EventSource.CLOSED)\n  })\n\n  it('has readystate constants on instances', function (done) {\n    var es = new EventSource('http://localhost:' + _port)\n    assert.equal(EventSource.CONNECTING, es.CONNECTING, 'constant CONNECTING missing/invalid')\n    assert.equal(EventSource.OPEN, es.OPEN, 'constant OPEN missing/invalid')\n    assert.equal(EventSource.CLOSED, es.CLOSED, 'constant CLOSED missing/invalid')\n\n    es.onerror = function () {\n      es.close()\n      done()\n    }\n  })\n\n  it('is CONNECTING before connection has been established', function (done) {\n    var es = new EventSource('http://localhost:' + _port)\n    assert.equal(EventSource.CONNECTING, es.readyState)\n    es.onerror = function () {\n      es.close()\n      done()\n    }\n  })\n\n  it('is CONNECTING when server has closed the connection', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents([]))\n      var es = new EventSource(server.url)\n      es.reconnectInterval = 0\n\n      es.onopen = function (m) {\n        server.close(function (err) {\n          if (err) return done(err)\n\n          es.onerror = function () {\n            es.onerror = null\n            assert.equal(EventSource.CONNECTING, es.readyState)\n            done()\n          }\n        })\n      }\n    })\n  })\n\n  it('is OPEN when connection has been established', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents([]))\n      var es = new EventSource(server.url)\n\n      es.onopen = function () {\n        assert.equal(EventSource.OPEN, es.readyState)\n        server.close(done)\n      }\n    })\n  })\n\n  it('is CLOSED after connection has been closed', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents([]))\n      var es = new EventSource(server.url)\n\n      es.onopen = function () {\n        es.close()\n        assert.equal(EventSource.CLOSED, es.readyState)\n        server.close(done)\n      }\n    })\n  })\n})\n\ndescribe('Methods', function () {\n  it('close method exists and can be called to close an eventsource', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n      var es = new EventSource(server.url)\n      server.on('request', writeEvents([]))\n      es.onopen = function () {\n        assert.equal(es.close(), undefined)\n        server.close(done)\n      }\n    })\n  })\n\n  it('close method is a prototype method', function () {\n    assert.equal(typeof EventSource.prototype.close, 'function')\n  })\n})\n\ndescribe('Properties', function () {\n  it('url exposes original request url', function () {\n    var url = 'http://localhost:' + _port\n    var es = new EventSource(url)\n    assert.equal(url, es.url)\n  })\n})\n\ndescribe('Events', function () {\n  it('calls onopen when connection is established', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents([]))\n      var es = new EventSource(server.url)\n\n      es.onopen = function (event) {\n        assert.equal(event.type, 'open')\n        server.close(done)\n      }\n    })\n  })\n\n  it('supplies the correct origin', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents(['data: hello\\n\\n']))\n      var es = new EventSource(server.url)\n\n      es.onmessage = function (event) {\n        assert.equal(event.origin, server.url)\n        server.close(done)\n      }\n    })\n  })\n\n  it('emits open event when connection is established', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents([]))\n      var es = new EventSource(server.url)\n\n      es.addEventListener('open', function (event) {\n        assert.equal(event.type, 'open')\n        server.close(done)\n      })\n    })\n  })\n\n  it('does not double reconnect when connection is closed by server', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      var numConnections = 0\n      server.on('request', function (req, res) {\n        numConnections++\n        writeEvents([])(req, res)\n\n        if (numConnections > 2) done(new Error('reopening too many connections'))\n        // destroy only the first connection - expected only 1 other reconnect\n        if (numConnections === 1) {\n          process.nextTick(function () {\n            req.destroy()\n          })\n        }\n      })\n      const es = new EventSource(server.url)\n      es.reconnectInterval = 50\n\n      setTimeout(function () {\n        server.close(done)\n      }, 350)\n    })\n  })\n\n  it('does not emit error when connection is closed by client', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents([]))\n      var es = new EventSource(server.url)\n\n      es.addEventListener('open', function () {\n        es.close()\n        process.nextTick(function () {\n          server.close(done)\n        })\n      })\n      es.addEventListener('error', function () {\n        done(new Error('error should not be emitted'))\n      })\n    })\n  })\n\n  it('populates message\\'s lastEventId correctly when the last event has an associated id', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents(['id: 123\\ndata: hello\\n\\n']))\n      var es = new EventSource(server.url)\n\n      es.onmessage = function (m) {\n        assert.equal(m.lastEventId, '123')\n        server.close(done)\n      }\n    })\n  })\n\n  it('populates message\\'s lastEventId correctly when the last event doesn\\'t have an associated id', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents(['id: 123\\ndata: Hello\\n\\n', 'data: World\\n\\n']))\n      var es = new EventSource(server.url)\n\n      es.onmessage = first\n\n      function first () {\n        es.onmessage = second\n      }\n\n      function second (m) {\n        assert.equal(m.data, 'World')\n        assert.equal(m.lastEventId, '123')  // expect to get back the previous event id\n        server.close(done)\n      }\n    })\n  })\n\n  it('populates messages with enumerable properties so they can be inspected via console.log().', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents(['data: World\\n\\n']))\n      var es = new EventSource(server.url)\n\n      es.onmessage = function (m) {\n        var enumerableAttributes = Object.keys(m)\n        assert.notEqual(enumerableAttributes.indexOf('data'), -1)\n        assert.notEqual(enumerableAttributes.indexOf('type'), -1)\n        server.close(done)\n      }\n    })\n  })\n\n  it('throws error if the message type is unspecified, \\'\\' or null', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      var es = new EventSource(server.url)\n\n      assert.throws(function () { es.dispatchEvent({}) })\n      assert.throws(function () { es.dispatchEvent({type: undefined}) })\n      assert.throws(function () { es.dispatchEvent({type: ''}) })\n      assert.throws(function () { es.dispatchEvent({type: null}) })\n\n      server.close(done)\n    })\n  })\n\n  it('delivers the dispatched event without payload', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      var es = new EventSource(server.url)\n\n      es.addEventListener('greeting', function (m) {\n        server.close(done)\n      })\n\n      es.dispatchEvent({type: 'greeting'})\n    })\n  })\n\n  it('delivers the dispatched event with payload', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      var es = new EventSource(server.url)\n\n      es.addEventListener('greeting', function (m) {\n        assert.equal('Hello', m.data)\n        server.close(done)\n      })\n\n      es.dispatchEvent({type: 'greeting', detail: {data: 'Hello'}})\n    })\n  })\n})\n\ndescribe('Proxying', function () {\n  it('proxies http->http requests', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents(['data: World\\n\\n']))\n\n      createProxy(server.url, 'http', function (err, proxy) {\n        if (err) return done(err)\n\n        var es = new EventSource(server.url, {proxy: proxy.url})\n        es.onmessage = function (m) {\n          assert.equal(m.data, 'World')\n          proxy.close(function () {\n            server.close(done)\n          })\n        }\n      })\n    })\n  })\n\n  it('proxies http->https requests', function (done) {\n    createHttpsServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents(['data: World\\n\\n']))\n\n      createProxy(server.url, 'http', function (err, proxy) {\n        if (err) return done(err)\n\n        var es = new EventSource(server.url, {proxy: proxy.url})\n        es.onmessage = function (m) {\n          assert.equal(m.data, 'World')\n          proxy.close(function () {\n            server.close(done)\n          })\n        }\n      })\n    })\n  })\n\n  it('proxies https->http requests', function (done) {\n    createHttpsServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents(['data: World\\n\\n']))\n\n      createProxy(server.url, 'https', function (err, proxy) {\n        if (err) return done(err)\n\n        var es = new EventSource(server.url, {proxy: proxy.url, rejectUnauthorized: false})\n        es.onmessage = function (m) {\n          assert.equal(m.data, 'World')\n          proxy.close(function () {\n            server.close(done)\n          })\n        }\n      })\n    })\n  })\n})\n"], "fixing_code": ["var parse = require('url').parse\nvar events = require('events')\nvar https = require('https')\nvar http = require('http')\nvar util = require('util')\n\nvar httpsOptions = [\n  'pfx', 'key', 'passphrase', 'cert', 'ca', 'ciphers',\n  'rejectUnauthorized', 'secureProtocol', 'servername', 'checkServerIdentity'\n]\n\nvar bom = [239, 187, 191]\nvar colon = 58\nvar space = 32\nvar lineFeed = 10\nvar carriageReturn = 13\n// Beyond 256KB we could not observe any gain in performance\nvar maxBufferAheadAllocation = 1024 * 256\n\nfunction hasBom (buf) {\n  return bom.every(function (charCode, index) {\n    return buf[index] === charCode\n  })\n}\n\n/**\n * Creates a new EventSource object\n *\n * @param {String} url the URL to which to connect\n * @param {Object} [eventSourceInitDict] extra init params. See README for details.\n * @api public\n **/\nfunction EventSource (url, eventSourceInitDict) {\n  var readyState = EventSource.CONNECTING\n  var headers = eventSourceInitDict && eventSourceInitDict.headers\n  var hasNewOrigin = false\n  Object.defineProperty(this, 'readyState', {\n    get: function () {\n      return readyState\n    }\n  })\n\n  Object.defineProperty(this, 'url', {\n    get: function () {\n      return url\n    }\n  })\n\n  var self = this\n  self.reconnectInterval = 1000\n  self.connectionInProgress = false\n\n  function onConnectionClosed (message) {\n    if (readyState === EventSource.CLOSED) return\n    readyState = EventSource.CONNECTING\n    _emit('error', new Event('error', {message: message}))\n\n    // The url may have been changed by a temporary redirect. If that's the case,\n    // revert it now, and flag that we are no longer pointing to a new origin\n    if (reconnectUrl) {\n      url = reconnectUrl\n      reconnectUrl = null\n      hasNewOrigin = false\n    }\n    setTimeout(function () {\n      if (readyState !== EventSource.CONNECTING || self.connectionInProgress) {\n        return\n      }\n      self.connectionInProgress = true\n      connect()\n    }, self.reconnectInterval)\n  }\n\n  var req\n  var lastEventId = ''\n  if (headers && headers['Last-Event-ID']) {\n    lastEventId = headers['Last-Event-ID']\n    delete headers['Last-Event-ID']\n  }\n\n  var discardTrailingNewline = false\n  var data = ''\n  var eventName = ''\n\n  var reconnectUrl = null\n\n  function connect () {\n    var options = parse(url)\n    var isSecure = options.protocol === 'https:'\n    options.headers = { 'Cache-Control': 'no-cache', 'Accept': 'text/event-stream' }\n    if (lastEventId) options.headers['Last-Event-ID'] = lastEventId\n    if (headers) {\n      var reqHeaders = hasNewOrigin ? removeUnsafeHeaders(headers) : headers\n      for (var i in reqHeaders) {\n        var header = reqHeaders[i]\n        if (header) {\n          options.headers[i] = header\n        }\n      }\n    }\n\n    // Legacy: this should be specified as `eventSourceInitDict.https.rejectUnauthorized`,\n    // but for now exists as a backwards-compatibility layer\n    options.rejectUnauthorized = !(eventSourceInitDict && !eventSourceInitDict.rejectUnauthorized)\n\n    if (eventSourceInitDict && eventSourceInitDict.createConnection !== undefined) {\n      options.createConnection = eventSourceInitDict.createConnection\n    }\n\n    // If specify http proxy, make the request to sent to the proxy server,\n    // and include the original url in path and Host headers\n    var useProxy = eventSourceInitDict && eventSourceInitDict.proxy\n    if (useProxy) {\n      var proxy = parse(eventSourceInitDict.proxy)\n      isSecure = proxy.protocol === 'https:'\n\n      options.protocol = isSecure ? 'https:' : 'http:'\n      options.path = url\n      options.headers.Host = options.host\n      options.hostname = proxy.hostname\n      options.host = proxy.host\n      options.port = proxy.port\n    }\n\n    // If https options are specified, merge them into the request options\n    if (eventSourceInitDict && eventSourceInitDict.https) {\n      for (var optName in eventSourceInitDict.https) {\n        if (httpsOptions.indexOf(optName) === -1) {\n          continue\n        }\n\n        var option = eventSourceInitDict.https[optName]\n        if (option !== undefined) {\n          options[optName] = option\n        }\n      }\n    }\n\n    // Pass this on to the XHR\n    if (eventSourceInitDict && eventSourceInitDict.withCredentials !== undefined) {\n      options.withCredentials = eventSourceInitDict.withCredentials\n    }\n\n    req = (isSecure ? https : http).request(options, function (res) {\n      self.connectionInProgress = false\n      // Handle HTTP errors\n      if (res.statusCode === 500 || res.statusCode === 502 || res.statusCode === 503 || res.statusCode === 504) {\n        _emit('error', new Event('error', {status: res.statusCode, message: res.statusMessage}))\n        onConnectionClosed()\n        return\n      }\n\n      // Handle HTTP redirects\n      if (res.statusCode === 301 || res.statusCode === 302 || res.statusCode === 307) {\n        var location = res.headers.location\n        if (!location) {\n          // Server sent redirect response without Location header.\n          _emit('error', new Event('error', {status: res.statusCode, message: res.statusMessage}))\n          return\n        }\n        var prevOrigin = new URL(url).origin\n        var nextOrigin = new URL(location).origin\n        hasNewOrigin = prevOrigin !== nextOrigin\n        if (res.statusCode === 307) reconnectUrl = url\n        url = location\n        process.nextTick(connect)\n        return\n      }\n\n      if (res.statusCode !== 200) {\n        _emit('error', new Event('error', {status: res.statusCode, message: res.statusMessage}))\n        return self.close()\n      }\n\n      readyState = EventSource.OPEN\n      res.on('close', function () {\n        res.removeAllListeners('close')\n        res.removeAllListeners('end')\n        onConnectionClosed()\n      })\n\n      res.on('end', function () {\n        res.removeAllListeners('close')\n        res.removeAllListeners('end')\n        onConnectionClosed()\n      })\n      _emit('open', new Event('open'))\n\n      // text/event-stream parser adapted from webkit's\n      // Source/WebCore/page/EventSource.cpp\n      var buf\n      var newBuffer\n      var startingPos = 0\n      var startingFieldLength = -1\n      var newBufferSize = 0\n      var bytesUsed = 0\n\n      res.on('data', function (chunk) {\n        if (!buf) {\n          buf = chunk\n          if (hasBom(buf)) {\n            buf = buf.slice(bom.length)\n          }\n          bytesUsed = buf.length\n        } else {\n          if (chunk.length > buf.length - bytesUsed) {\n            newBufferSize = (buf.length * 2) + chunk.length\n            if (newBufferSize > maxBufferAheadAllocation) {\n              newBufferSize = buf.length + chunk.length + maxBufferAheadAllocation\n            }\n            newBuffer = Buffer.alloc(newBufferSize)\n            buf.copy(newBuffer, 0, 0, bytesUsed)\n            buf = newBuffer\n          }\n          chunk.copy(buf, bytesUsed)\n          bytesUsed += chunk.length\n        }\n\n        var pos = 0\n        var length = bytesUsed\n\n        while (pos < length) {\n          if (discardTrailingNewline) {\n            if (buf[pos] === lineFeed) {\n              ++pos\n            }\n            discardTrailingNewline = false\n          }\n\n          var lineLength = -1\n          var fieldLength = startingFieldLength\n          var c\n\n          for (var i = startingPos; lineLength < 0 && i < length; ++i) {\n            c = buf[i]\n            if (c === colon) {\n              if (fieldLength < 0) {\n                fieldLength = i - pos\n              }\n            } else if (c === carriageReturn) {\n              discardTrailingNewline = true\n              lineLength = i - pos\n            } else if (c === lineFeed) {\n              lineLength = i - pos\n            }\n          }\n\n          if (lineLength < 0) {\n            startingPos = length - pos\n            startingFieldLength = fieldLength\n            break\n          } else {\n            startingPos = 0\n            startingFieldLength = -1\n          }\n\n          parseEventStreamLine(buf, pos, fieldLength, lineLength)\n\n          pos += lineLength + 1\n        }\n\n        if (pos === length) {\n          buf = void 0\n          bytesUsed = 0\n        } else if (pos > 0) {\n          buf = buf.slice(pos, bytesUsed)\n          bytesUsed = buf.length\n        }\n      })\n    })\n\n    req.on('error', function (err) {\n      self.connectionInProgress = false\n      onConnectionClosed(err.message)\n    })\n\n    if (req.setNoDelay) req.setNoDelay(true)\n    req.end()\n  }\n\n  connect()\n\n  function _emit () {\n    if (self.listeners(arguments[0]).length > 0) {\n      self.emit.apply(self, arguments)\n    }\n  }\n\n  this._close = function () {\n    if (readyState === EventSource.CLOSED) return\n    readyState = EventSource.CLOSED\n    if (req.abort) req.abort()\n    if (req.xhr && req.xhr.abort) req.xhr.abort()\n  }\n\n  function parseEventStreamLine (buf, pos, fieldLength, lineLength) {\n    if (lineLength === 0) {\n      if (data.length > 0) {\n        var type = eventName || 'message'\n        _emit(type, new MessageEvent(type, {\n          data: data.slice(0, -1), // remove trailing newline\n          lastEventId: lastEventId,\n          origin: new URL(url).origin\n        }))\n        data = ''\n      }\n      eventName = void 0\n    } else if (fieldLength > 0) {\n      var noValue = fieldLength < 0\n      var step = 0\n      var field = buf.slice(pos, pos + (noValue ? lineLength : fieldLength)).toString()\n\n      if (noValue) {\n        step = lineLength\n      } else if (buf[pos + fieldLength + 1] !== space) {\n        step = fieldLength + 1\n      } else {\n        step = fieldLength + 2\n      }\n      pos += step\n\n      var valueLength = lineLength - step\n      var value = buf.slice(pos, pos + valueLength).toString()\n\n      if (field === 'data') {\n        data += value + '\\n'\n      } else if (field === 'event') {\n        eventName = value\n      } else if (field === 'id') {\n        lastEventId = value\n      } else if (field === 'retry') {\n        var retry = parseInt(value, 10)\n        if (!Number.isNaN(retry)) {\n          self.reconnectInterval = retry\n        }\n      }\n    }\n  }\n}\n\nmodule.exports = EventSource\n\nutil.inherits(EventSource, events.EventEmitter)\nEventSource.prototype.constructor = EventSource; // make stacktraces readable\n\n['open', 'error', 'message'].forEach(function (method) {\n  Object.defineProperty(EventSource.prototype, 'on' + method, {\n    /**\n     * Returns the current listener\n     *\n     * @return {Mixed} the set function or undefined\n     * @api private\n     */\n    get: function get () {\n      var listener = this.listeners(method)[0]\n      return listener ? (listener._listener ? listener._listener : listener) : undefined\n    },\n\n    /**\n     * Start listening for events\n     *\n     * @param {Function} listener the listener\n     * @return {Mixed} the set function or undefined\n     * @api private\n     */\n    set: function set (listener) {\n      this.removeAllListeners(method)\n      this.addEventListener(method, listener)\n    }\n  })\n})\n\n/**\n * Ready states\n */\nObject.defineProperty(EventSource, 'CONNECTING', {enumerable: true, value: 0})\nObject.defineProperty(EventSource, 'OPEN', {enumerable: true, value: 1})\nObject.defineProperty(EventSource, 'CLOSED', {enumerable: true, value: 2})\n\nEventSource.prototype.CONNECTING = 0\nEventSource.prototype.OPEN = 1\nEventSource.prototype.CLOSED = 2\n\n/**\n * Closes the connection, if one is made, and sets the readyState attribute to 2 (closed)\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/EventSource/close\n * @api public\n */\nEventSource.prototype.close = function () {\n  this._close()\n}\n\n/**\n * Emulates the W3C Browser based WebSocket interface using addEventListener.\n *\n * @param {String} type A string representing the event type to listen out for\n * @param {Function} listener callback\n * @see https://developer.mozilla.org/en/DOM/element.addEventListener\n * @see http://dev.w3.org/html5/websockets/#the-websocket-interface\n * @api public\n */\nEventSource.prototype.addEventListener = function addEventListener (type, listener) {\n  if (typeof listener === 'function') {\n    // store a reference so we can return the original function again\n    listener._listener = listener\n    this.on(type, listener)\n  }\n}\n\n/**\n * Emulates the W3C Browser based WebSocket interface using dispatchEvent.\n *\n * @param {Event} event An event to be dispatched\n * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/dispatchEvent\n * @api public\n */\nEventSource.prototype.dispatchEvent = function dispatchEvent (event) {\n  if (!event.type) {\n    throw new Error('UNSPECIFIED_EVENT_TYPE_ERR')\n  }\n  // if event is instance of an CustomEvent (or has 'details' property),\n  // send the detail object as the payload for the event\n  this.emit(event.type, event.detail)\n}\n\n/**\n * Emulates the W3C Browser based WebSocket interface using removeEventListener.\n *\n * @param {String} type A string representing the event type to remove\n * @param {Function} listener callback\n * @see https://developer.mozilla.org/en/DOM/element.removeEventListener\n * @see http://dev.w3.org/html5/websockets/#the-websocket-interface\n * @api public\n */\nEventSource.prototype.removeEventListener = function removeEventListener (type, listener) {\n  if (typeof listener === 'function') {\n    listener._listener = undefined\n    this.removeListener(type, listener)\n  }\n}\n\n/**\n * W3C Event\n *\n * @see http://www.w3.org/TR/DOM-Level-3-Events/#interface-Event\n * @api private\n */\nfunction Event (type, optionalProperties) {\n  Object.defineProperty(this, 'type', { writable: false, value: type, enumerable: true })\n  if (optionalProperties) {\n    for (var f in optionalProperties) {\n      if (optionalProperties.hasOwnProperty(f)) {\n        Object.defineProperty(this, f, { writable: false, value: optionalProperties[f], enumerable: true })\n      }\n    }\n  }\n}\n\n/**\n * W3C MessageEvent\n *\n * @see http://www.w3.org/TR/webmessaging/#event-definitions\n * @api private\n */\nfunction MessageEvent (type, eventInitDict) {\n  Object.defineProperty(this, 'type', { writable: false, value: type, enumerable: true })\n  for (var f in eventInitDict) {\n    if (eventInitDict.hasOwnProperty(f)) {\n      Object.defineProperty(this, f, { writable: false, value: eventInitDict[f], enumerable: true })\n    }\n  }\n}\n\n/**\n * Returns a new object of headers that does not include any authorization and cookie headers\n *\n * @param {Object} headers An object of headers ({[headerName]: headerValue})\n * @return {Object} a new object of headers\n * @api private\n */\nfunction removeUnsafeHeaders (headers) {\n  var safe = {}\n  for (var key in headers) {\n    if (/^(cookie|authorization)$/i.test(key)) {\n      continue\n    }\n\n    safe[key] = headers[key]\n  }\n\n  return safe\n}\n", "/* eslint-disable no-new */\nvar EventSource = require('../lib/eventsource')\nvar bufferFrom = require('buffer-from')\nvar path = require('path')\nvar http = require('http')\nvar https = require('https')\nvar fs = require('fs')\nvar mocha = require('mocha')\nvar assert = require('assert')\nvar u = require('url')\nvar net = require('net')\n\nvar it = mocha.it\nvar describe = mocha.describe\n\nvar httpsServerOptions = {\n  key: fs.readFileSync(path.join(__dirname, 'server_certs', 'key.pem')),\n  cert: fs.readFileSync(path.join(__dirname, 'server_certs', 'certificate.pem'))\n}\n\nvar _port = 20000\nvar servers = []\nprocess.on('exit', function () {\n  if (servers.length > 0) {\n    console.error(\"************ Didn't kill all servers - there is still %d running.\", servers.length)\n  }\n})\n\nfunction createServer (callback) {\n  var server = http.createServer()\n  configureServer(server, 'http', _port++, callback)\n}\n\nfunction createHttpsServer (callback) {\n  var server = https.createServer(httpsServerOptions)\n  configureServer(server, 'https', _port++, callback)\n}\n\nfunction createHttpsServerWithClientAuth (callback) {\n  var options = {\n    key: fs.readFileSync(path.join(__dirname, 'client_certs', 'server_key.pem')),\n    cert: fs.readFileSync(path.join(__dirname, 'client_certs', 'server_cert.crt')),\n    ca: fs.readFileSync(path.join(__dirname, 'client_certs', 'cacert.crt')),\n    passphrase: 'test1234$',\n    requestCert: true,\n    rejectAuthorized: true\n  }\n  var server = https.createServer(options)\n  configureServer(server, 'https', _port++, callback)\n}\n\nfunction configureServer (server, protocol, port, callback) {\n  var responses = []\n\n  var oldClose = server.close\n  server.close = function (closeCb) {\n    responses.forEach(function (res) {\n      res.end()\n    })\n    oldClose.call(this, function () {\n      servers.splice(servers.indexOf(server), 1)\n      closeCb()\n    })\n  }\n\n  server.on('request', function (req, res) {\n    responses.push(res)\n  })\n\n  server.url = protocol + '://localhost:' + port\n\n  server.listen(port, function onOpen (err) {\n    servers.push(server)\n    callback(err, server)\n  })\n}\n\nfunction createProxy (target, protocol, callback) {\n  var proxyPort = _port++\n  var targetProtocol = target.indexOf('https') === 0 ? 'https' : 'http'\n  var requester = targetProtocol === 'https' ? https : http\n  var serve = protocol === 'https' ? https : http\n\n  var proxied = []\n  var server = serve.createServer(serve === https ? httpsServerOptions : undefined)\n\n  server.on('request', function (req, res) {\n    var options = u.parse(target)\n    options.headers = req.headers\n    options.rejectUnauthorized = false\n\n    var upstreamReq = requester.request(options, function (upstreamRes) {\n      upstreamRes.pipe(res)\n    })\n\n    proxied.push({req: upstreamReq, res: res})\n    upstreamReq.end()\n  })\n\n  servers.push(server)\n\n  var oldClose = server.close\n  server.close = function (closeCb) {\n    proxied.forEach(function (pair) {\n      pair.req.abort()\n      pair.res.destroy()\n    })\n\n    oldClose.call(server, function () {\n      servers.splice(servers.indexOf(server), 1)\n      closeCb()\n    })\n  }\n\n  server.listen(proxyPort, function onOpen (err) {\n    server.url = protocol + '://localhost:' + proxyPort\n    callback(err, server)\n  })\n}\n\nfunction writeEvents (chunks) {\n  return function (req, res) {\n    res.writeHead(200, {'Content-Type': 'text/event-stream'})\n    chunks.forEach(function (chunk) {\n      res.write(chunk)\n    })\n    res.write(':') // send a dummy comment to ensure that the head is flushed\n  }\n}\n\ndescribe('Parser', function () {\n  it('parses multibyte characters', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents(['id: 1\\ndata: \u20ac\u8c46\u8150\\n\\n']))\n      var es = new EventSource(server.url)\n\n      es.onmessage = function (m) {\n        assert.equal('\u20ac\u8c46\u8150', m.data)\n        server.close(done)\n      }\n    })\n  })\n\n  it('parses empty lines with multibyte characters', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents(['\\n\\n\\n\\nid: 1\\ndata: \u6211\u73fe\u5728\u90fd\u770b\u5be6\u6cc1\u4e0d\u73a9\u904a\u6232\\n\\n']))\n      var es = new EventSource(server.url)\n\n      es.onmessage = function (m) {\n        assert.equal('\u6211\u73fe\u5728\u90fd\u770b\u5be6\u6cc1\u4e0d\u73a9\u904a\u6232', m.data)\n        server.close(done)\n      }\n    })\n  })\n\n  it('parses one one-line message in one chunk', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents(['data: Hello\\n\\n']))\n      var es = new EventSource(server.url)\n      es.onmessage = function (m) {\n        assert.equal('Hello', m.data)\n        server.close(done)\n      }\n    })\n  })\n\n  it('ignores byte-order mark', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', function (req, res) {\n        res.writeHead(200, {'Content-Type': 'text/event-stream'})\n        res.write('\\uFEFF')\n        res.write('data: foo\\n\\n')\n        res.end()\n      })\n      var es = new EventSource(server.url)\n      es.onmessage = function (m) {\n        assert.equal('foo', m.data)\n        server.close(done)\n      }\n    })\n  })\n\n  it('parses one one-line message in two chunks', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents(['data: Hel', 'lo\\n\\n']))\n      var es = new EventSource(server.url)\n      es.onmessage = function (m) {\n        assert.equal('Hello', m.data)\n        server.close(done)\n      }\n    })\n  })\n\n  it('parses two one-line messages in one chunk', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents(['data: Hello\\n\\n', 'data: World\\n\\n']))\n      var es = new EventSource(server.url)\n\n      es.onmessage = first\n\n      function first (m) {\n        assert.equal('Hello', m.data)\n        es.onmessage = second\n      }\n\n      function second (m) {\n        assert.equal('World', m.data)\n        server.close(done)\n      }\n    })\n  })\n\n  it('parses one two-line message in one chunk', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents(['data: Hello\\ndata:World\\n\\n']))\n      var es = new EventSource(server.url)\n\n      es.onmessage = function (m) {\n        assert.equal('Hello\\nWorld', m.data)\n        server.close(done)\n      }\n    })\n  })\n\n  it('parses chopped up unicode data', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      var chopped = 'data: Aslak\\n\\ndata: Helles\u00f8y\\n\\n'.split('')\n      server.on('request', writeEvents(chopped))\n      var es = new EventSource(server.url)\n\n      es.onmessage = first\n\n      function first (m) {\n        assert.equal('Aslak', m.data)\n        es.onmessage = second\n      }\n\n      function second (m) {\n        assert.equal('Helles\u00f8y', m.data)\n        server.close(done)\n      }\n    })\n  })\n\n  it('parses really chopped up unicode data', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', function (req, res) {\n        const msg = bufferFrom('data: Aslak Helles\u00f8y is the original author\\n\\n')\n        res.writeHead(200, {'Content-Type': 'text/event-stream'})\n\n        // Slice in the middle of a unicode sequence (\u00f8), making sure that one data\n        // chunk will contain the first byte and the second chunk will get the other\n        res.write(msg.slice(0, 19), 'binary', function () {\n          res.write(msg.slice(19))\n        })\n      })\n\n      var es = new EventSource(server.url)\n\n      es.onmessage = function (m) {\n        assert.equal('Aslak Helles\u00f8y is the original author', m.data)\n        server.close(done)\n      }\n    })\n  })\n\n  it('accepts CRLF as separator', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      var chopped = 'data: Aslak\\r\\n\\r\\ndata: Helles\u00f8y\\r\\n\\r\\n'.split('')\n      server.on('request', writeEvents(chopped))\n      var es = new EventSource(server.url)\n\n      es.onmessage = first\n\n      function first (m) {\n        assert.equal('Aslak', m.data)\n        es.onmessage = second\n      }\n\n      function second (m) {\n        assert.equal('Helles\u00f8y', m.data)\n        server.close(done)\n      }\n    })\n  })\n\n  it('accepts CR as separator', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      var chopped = 'data: Aslak\\r\\rdata: Helles\u00f8y\\r\\r'.split('')\n      server.on('request', writeEvents(chopped))\n      var es = new EventSource(server.url)\n\n      es.onmessage = first\n\n      function first (m) {\n        assert.equal('Aslak', m.data)\n        es.onmessage = second\n      }\n\n      function second (m) {\n        assert.equal('Helles\u00f8y', m.data)\n        server.close(done)\n      }\n    })\n  })\n\n  it('delivers message with explicit event', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents(['event: greeting\\ndata: Hello\\n\\n']))\n      var es = new EventSource(server.url)\n\n      es.addEventListener('greeting', function (m) {\n        assert.equal('Hello', m.data)\n        server.close(done)\n      })\n    })\n  })\n\n  it('allows removal of event listeners', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents(['event: greeting\\ndata: Hello\\n\\n', 'event: greeting\\ndata: World\\n\\n']))\n      var es = new EventSource(server.url)\n      var numCalled = 0\n\n      function onGreeting (m) {\n        numCalled++\n        assert.equal('Hello', m.data)\n        es.removeEventListener('greeting', onGreeting, false)\n        process.nextTick(scheduleDisconnect)\n      }\n\n      function scheduleDisconnect () {\n        assert.equal(1, numCalled)\n        server.close(done)\n      }\n\n      es.addEventListener('greeting', onGreeting, false)\n    })\n  })\n\n  it('ignores comments', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents(['data: Hello\\n\\n:nothing to see here\\n\\ndata: World\\n\\n']))\n      var es = new EventSource(server.url)\n\n      es.onmessage = first\n\n      function first (m) {\n        assert.equal('Hello', m.data)\n        es.onmessage = second\n      }\n\n      function second (m) {\n        assert.equal('World', m.data)\n        server.close(done)\n      }\n    })\n  })\n\n  it('ignores empty comments', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents(['data: Hello\\n\\n:\\n\\ndata: World\\n\\n']))\n      var es = new EventSource(server.url)\n\n      es.onmessage = first\n\n      function first (m) {\n        assert.equal('Hello', m.data)\n        es.onmessage = second\n      }\n\n      function second (m) {\n        assert.equal('World', m.data)\n        server.close(done)\n      }\n    })\n  })\n\n  it('does not ignore multilines strings', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents(['data: line one\\ndata:\\ndata: line two\\n\\n']))\n      var es = new EventSource(server.url)\n\n      es.onmessage = function (m) {\n        assert.equal('line one\\n\\nline two', m.data)\n        server.close(done)\n      }\n    })\n  })\n\n  it('does not ignore multilines strings even in data beginning', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents(['data:\\ndata:line one\\ndata: line two\\n\\n']))\n      var es = new EventSource(server.url)\n\n      es.onmessage = function (m) {\n        assert.equal('\\nline one\\nline two', m.data)\n        server.close(done)\n      }\n    })\n  })\n\n  it('causes entire event to be ignored for empty event field', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents(['event:\\n\\ndata: Hello\\n\\n']))\n      var es = new EventSource(server.url)\n\n      var originalEmit = es.emit\n      es.emit = function (event) {\n        assert.ok(event === 'message' || event === 'newListener')\n        return originalEmit.apply(this, arguments)\n      }\n      es.onmessage = function (m) {\n        assert.equal('Hello', m.data)\n        server.close(done)\n      }\n    })\n  })\n\n  it('parses relatively huge messages efficiently', function (done) {\n    this.timeout(200)\n\n    createServer(function (err, server) {\n      if (err) return done(err)\n      var longMessage = 'data: ' + new Array(100000).join('a') + '\\n\\n'\n      server.on('request', writeEvents([longMessage]))\n\n      var es = new EventSource(server.url)\n\n      es.onmessage = function () {\n        server.close(done)\n      }\n    })\n  })\n\n  it('parses a relatively huge message across many chunks efficiently', function (done) {\n    this.timeout(1000)\n\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      var longMessageContent = new Array(100000).join('a')\n      var longMessage = 'data: ' + longMessageContent + '\\n\\n'\n      var longMessageChunks = longMessage.match(/[\\s\\S]{1,10}/g) // Split the message into chunks of 10 characters\n      server.on('request', writeEvents(longMessageChunks))\n\n      var es = new EventSource(server.url)\n\n      es.onmessage = function (m) {\n        assert.equal(longMessageContent, m.data)\n        server.close(done)\n      }\n    })\n  })\n})\n\ndescribe('HTTP Request', function () {\n  it('passes cache-control: no-cache to server', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', function (req) {\n        assert.equal('no-cache', req.headers['cache-control'])\n        server.close(done)\n      })\n\n      new EventSource(server.url)\n    })\n  })\n\n  it('sets request headers', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', function (req) {\n        assert.equal(req.headers['user-agent'], 'test')\n        assert.equal(req.headers['cookie'], 'test=test')\n        assert.equal(req.headers['last-event-id'], '99')\n        server.close(done)\n      })\n\n      var headers = {\n        'User-Agent': 'test',\n        'Cookie': 'test=test',\n        'Last-Event-ID': '99'\n      }\n      new EventSource(server.url, {headers: headers})\n    })\n  })\n\n  it(\"does not set request headers that don't have a value\", function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', function (req) {\n        assert.equal(req.headers['user-agent'], 'test')\n        assert.equal(req.headers['cookie'], 'test=test')\n        assert.equal(req.headers['last-event-id'], '99')\n        assert.equal(req.headers['X-Something'], undefined)\n        server.close(done)\n      })\n\n      var headers = {\n        'User-Agent': 'test',\n        'Cookie': 'test=test',\n        'Last-Event-ID': '99',\n        'X-Something': null\n      }\n\n      assert.doesNotThrow(\n        function () {\n          new EventSource(server.url, {headers: headers})\n        }\n      )\n    })\n  });\n\n  [301, 302, 307].forEach(function (status) {\n    it('follows http ' + status + ' redirect', function (done) {\n      var redirectSuffix = '/foobar'\n      var clientRequestedRedirectUrl = false\n      createServer(function (err, server) {\n        if (err) return done(err)\n\n        server.on('request', function (req, res) {\n          if (req.url === '/') {\n            res.writeHead(status, {\n              'Connection': 'Close',\n              'Location': server.url + redirectSuffix\n            })\n            res.end()\n          } else if (req.url === redirectSuffix) {\n            clientRequestedRedirectUrl = true\n            res.writeHead(200, {'Content-Type': 'text/event-stream'})\n            res.end()\n          }\n        })\n\n        var es = new EventSource(server.url)\n        es.onopen = function () {\n          assert.ok(clientRequestedRedirectUrl)\n          assert.equal(server.url + redirectSuffix, es.url)\n          server.close(done)\n        }\n      })\n    })\n\n    it('follows http ' + status + ' redirects, drops sensitive headers on origin change', function (done) {\n      var redirectSuffix = '/foobar'\n      var clientRequestedRedirectUrl = false\n      var receivedHeaders = {}\n      createServer(function (err, server) {\n        if (err) return done(err)\n\n        var newServerUrl = server.url.replace('http://localhost', 'http://127.0.0.1')\n\n        server.on('request', function (req, res) {\n          if (req.url === '/') {\n            res.writeHead(status, {\n              'Connection': 'Close',\n              'Location': newServerUrl + redirectSuffix\n            })\n            res.end()\n          } else if (req.url === redirectSuffix) {\n            clientRequestedRedirectUrl = true\n            receivedHeaders = req.headers\n            res.writeHead(200, {'Content-Type': 'text/event-stream'})\n            res.end()\n          }\n        })\n\n        var es = new EventSource(server.url, {\n          headers: {\n            keep: 'me',\n            authorization: 'Bearer someToken',\n            cookie: 'some-cookie=yep'\n          }\n        })\n\n        es.onopen = function () {\n          assert.ok(clientRequestedRedirectUrl)\n          assert.equal(newServerUrl + redirectSuffix, es.url)\n          assert.equal(receivedHeaders.keep, 'me', 'safe header no longer present')\n          assert.equal(typeof receivedHeaders.authorization, 'undefined', 'authorization header still present')\n          assert.equal(typeof receivedHeaders.cookie, 'undefined', 'cookie header still present')\n          server.close(done)\n        }\n      })\n    })\n\n    it('causes error event when response is ' + status + ' with missing location', function (done) {\n      createServer(function (err, server) {\n        if (err) return done(err)\n\n        server.on('request', function (req, res) {\n          res.writeHead(status, 'status message', {\n            'Connection': 'Close'\n          })\n          res.end()\n        })\n\n        var es = new EventSource(server.url)\n        es.onerror = function (err) {\n          assert.equal(err.status, status)\n          assert.equal(err.message, 'status message')\n          server.close(done)\n        }\n      })\n    })\n  });\n\n  [401, 403].forEach(function (status) {\n    it('causes error event when response status is ' + status, function (done) {\n      createServer(function (err, server) {\n        if (err) return done(err)\n\n        server.on('request', function (req, res) {\n          res.writeHead(status, 'status message', {'Content-Type': 'text/html'})\n          res.end()\n        })\n\n        var es = new EventSource(server.url)\n        es.onerror = function (err) {\n          assert.equal(err.status, status)\n          assert.equal(err.message, 'status message')\n          server.close(done)\n        }\n      })\n    })\n  })\n\n  it('checks createConnection option', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      var testResult = false\n\n      server.on('request', function () {\n        assert.ok(testResult)\n        server.close(done)\n      })\n\n      var urlObj = u.parse(server.url)\n\n      new EventSource(server.url, {\n        createConnection: function () {\n          var connection = net.createConnection({ port: urlObj.port, host: urlObj.hostname })\n          connection.on('connect', function () {\n            testResult = true\n          })\n          return connection\n        }\n      })\n    })\n  })\n})\n\ndescribe('HTTPS Support', function () {\n  it('uses https for https urls', function (done) {\n    createHttpsServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents(['data: hello\\n\\n']))\n      var es = new EventSource(server.url, {rejectUnauthorized: false})\n\n      es.onmessage = function (m) {\n        assert.equal('hello', m.data)\n        server.close(done)\n      }\n    })\n  })\n})\n\ndescribe('HTTPS Client Certificate Support', function () {\n  it('uses client certificate for https urls', function (done) {\n    this.timeout(1500000)\n    createHttpsServerWithClientAuth(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents(['data: hello\\n\\n']))\n      var es = new EventSource(server.url,\n        {\n          https: {\n            key: fs.readFileSync(path.join(__dirname, 'client_certs', 'client_key.pem')),\n            cert: fs.readFileSync(path.join(__dirname, 'client_certs', 'client_cert.crt')),\n            ca: fs.readFileSync(path.join(__dirname, 'client_certs', 'cacert.crt')),\n            passphrase: 'test1234$',\n            rejectUnauthorized: true\n          }\n        }\n      )\n      es.onmessage = function (m) {\n        assert.equal('hello', m.data)\n        server.close(done)\n      }\n    })\n  })\n})\n\ndescribe('Reconnection', function () {\n  it('is attempted when server is down', function (done) {\n    var es = new EventSource('http://localhost:' + _port)\n    es.reconnectInterval = 0\n\n    es.onerror = function () {\n      es.onerror = null\n      createServer(function (err, server) {\n        if (err) return done(err)\n\n        server.on('request', writeEvents(['data: hello\\n\\n']))\n\n        es.onmessage = function (m) {\n          assert.equal('hello', m.data)\n          server.close(done)\n        }\n      })\n    }\n  })\n\n  it('continuing attempts when server is down', function (done) {\n    // Seems set reconnectInterval=0 not work here, this makes total time spent for current case more than 3S\n    this.timeout(4000)\n\n    var es = new EventSource('http://localhost:' + _port++)\n    es.reconnectInterval = 0\n    var reconnectCount = 0\n\n    es.onerror = function () {\n      reconnectCount++\n      // make sure client is keeping reconnecting\n      if (reconnectCount > 2) {\n        es.onerror = null\n        var port = u.parse(es.url).port\n        configureServer(http.createServer(), 'http', port, function (err, server) {\n          if (err) return done(err)\n\n          server.on('request', writeEvents(['data: hello\\n\\n']))\n\n          es.onmessage = function (m) {\n            assert.equal('hello', m.data)\n            server.close(done)\n          }\n        })\n      }\n    }\n  })\n\n  it('is attempted when server goes down after connection', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents(['data: hello\\n\\n']))\n      var es = new EventSource(server.url)\n      es.reconnectInterval = 0\n\n      es.onmessage = function (m) {\n        assert.equal('hello', m.data)\n        server.close(function (err) {\n          if (err) return done(err)\n\n          var port = u.parse(es.url).port\n          configureServer(http.createServer(), 'http', port, function (err, server2) {\n            if (err) return done(err)\n\n            server2.on('request', writeEvents(['data: world\\n\\n']))\n            es.onmessage = function (m) {\n              assert.equal('world', m.data)\n              server2.close(done)\n            }\n          })\n        })\n      }\n    })\n  })\n\n  it('is attempted when the server responds with a 500', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', function (req, res) {\n        res.writeHead(500)\n        res.end()\n      })\n\n      var es = new EventSource(server.url)\n      es.reconnectInterval = 0\n\n      var errored = false\n\n      es.onerror = function () {\n        if (errored) return\n        errored = true\n        server.close(function (err) {\n          if (err) return done(err)\n\n          var port = u.parse(es.url).port\n          configureServer(http.createServer(), 'http', port, function (err, server2) {\n            if (err) return done(err)\n\n            server2.on('request', writeEvents(['data: hello\\n\\n']))\n            es.onmessage = function (m) {\n              assert.equal('hello', m.data)\n              server2.close(done)\n            }\n          })\n        })\n      }\n    })\n  })\n\n  it('is stopped when server goes down and eventsource is being closed', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents(['data: hello\\n\\n']))\n      var es = new EventSource(server.url)\n      es.reconnectInterval = 0\n\n      es.onmessage = function (m) {\n        assert.equal('hello', m.data)\n        server.close(function (err) {\n          if (err) return done(err)\n          // The server has closed down. es.onerror should now get called,\n          // because es's remote connection was dropped.\n        })\n      }\n\n      es.onerror = function () {\n        // We received an error because the remote connection was closed.\n        // We close es, so we do not want es to reconnect.\n        es.close()\n\n        var port = u.parse(es.url).port\n        configureServer(http.createServer(), 'http', port, function (err, server2) {\n          if (err) return done(err)\n          server2.on('request', writeEvents(['data: world\\n\\n']))\n\n          es.onmessage = function (m) {\n            return done(new Error('Unexpected message: ' + m.data))\n          }\n\n          setTimeout(function () {\n            // We have not received any message within 100ms, we can\n            // presume this works correctly.\n            server2.close(done)\n          }, 100)\n        })\n      }\n    })\n  })\n\n  it('is not attempted when server responds with non-200 and non-500', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', function (req, res) {\n        res.writeHead(204, 'status message')\n        res.end()\n      })\n\n      var es = new EventSource(server.url)\n      es.reconnectInterval = 0\n\n      es.onerror = function (e) {\n        assert.equal(e.status, 204)\n        assert.equal(e.message, 'status message')\n        server.close(function (err) {\n          if (err) return done(err)\n\n          var port = u.parse(es.url).port\n          configureServer(http.createServer(), 'http', port, function (err, server2) {\n            if (err) return done(err)\n\n            // this will be verified by the readyState\n            // going from CONNECTING to CLOSED,\n            // along with the tests verifying that the\n            // state is CONNECTING when a server closes.\n            // it's next to impossible to write a fail-safe\n            // test for this, though.\n            var ival = setInterval(function () {\n              if (es.readyState === EventSource.CLOSED) {\n                clearInterval(ival)\n                server2.close(done)\n              }\n            }, 5)\n          })\n        })\n      }\n    })\n  })\n\n  it('sends Last-Event-ID http header when it has previously been passed in an event from the server', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents(['id: 10\\ndata: Hello\\n\\n']))\n\n      var es = new EventSource(server.url)\n      es.reconnectInterval = 0\n\n      es.onmessage = function () {\n        server.close(function (err) {\n          if (err) return done(err)\n\n          var port = u.parse(es.url).port\n          configureServer(http.createServer(), 'http', port, function (err, server2) {\n            if (err) return done(err)\n\n            server2.on('request', function (req, res) {\n              assert.equal('10', req.headers['last-event-id'])\n              server2.close(done)\n            })\n          })\n        })\n      }\n    })\n  })\n\n  it('sends correct Last-Event-ID http header when an initial Last-Event-ID header was specified in the constructor', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', function (req, res) {\n        assert.equal('9', req.headers['last-event-id'])\n        server.close(done)\n      })\n\n      new EventSource(server.url, {headers: {'Last-Event-ID': '9'}})\n    })\n  })\n\n  it('does not send Last-Event-ID http header when it has not been previously sent by the server', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents(['data: Hello\\n\\n']))\n\n      var es = new EventSource(server.url)\n      es.reconnectInterval = 0\n\n      es.onmessage = function () {\n        server.close(function (err) {\n          if (err) return done(err)\n\n          var port = u.parse(es.url).port\n          configureServer(http.createServer(), 'http', port, function (err, server2) {\n            if (err) return done(err)\n\n            server2.on('request', function (req, res) {\n              assert.equal(undefined, req.headers['last-event-id'])\n              server2.close(done)\n            })\n          })\n        })\n      }\n    })\n  })\n\n  it('attempts to reconnect are deduplicated on sequential erorrs', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n      var events = ['data: Hello']\n      var eventsSent = 0\n      var errorOccurred = false\n      server.on('request', function (req, res) {\n        if (eventsSent === 0) {\n          var fn = writeEvents(events)\n          fn(req, res)\n          eventsSent++\n          // now cause a few errors\n          fn(req, res)\n          eventsSent++\n        } else {\n          assert.equal(EventSource.CONNECTING, es.readyState)\n          assert.ok(errorOccurred)\n          server.close(done)\n        }\n      })\n\n      var es = new EventSource(server.url)\n      assert.equal(EventSource.CONNECTING, es.readyState)\n      es.reconnectInterval = 0\n      es.onerror = function (err) {\n        errorOccurred = !!(errorOccurred || err)\n      }\n    })\n  })\n})\n\ndescribe('readyState', function () {\n  it('has CONNECTING constant', function () {\n    assert.equal(0, EventSource.CONNECTING)\n  })\n\n  it('has OPEN constant', function () {\n    assert.equal(1, EventSource.OPEN)\n  })\n\n  it('has CLOSED constant', function () {\n    assert.equal(2, EventSource.CLOSED)\n  })\n\n  it('has readystate constants on instances', function (done) {\n    var es = new EventSource('http://localhost:' + _port)\n    assert.equal(EventSource.CONNECTING, es.CONNECTING, 'constant CONNECTING missing/invalid')\n    assert.equal(EventSource.OPEN, es.OPEN, 'constant OPEN missing/invalid')\n    assert.equal(EventSource.CLOSED, es.CLOSED, 'constant CLOSED missing/invalid')\n\n    es.onerror = function () {\n      es.close()\n      done()\n    }\n  })\n\n  it('is CONNECTING before connection has been established', function (done) {\n    var es = new EventSource('http://localhost:' + _port)\n    assert.equal(EventSource.CONNECTING, es.readyState)\n    es.onerror = function () {\n      es.close()\n      done()\n    }\n  })\n\n  it('is CONNECTING when server has closed the connection', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents([]))\n      var es = new EventSource(server.url)\n      es.reconnectInterval = 0\n\n      es.onopen = function (m) {\n        server.close(function (err) {\n          if (err) return done(err)\n\n          es.onerror = function () {\n            es.onerror = null\n            assert.equal(EventSource.CONNECTING, es.readyState)\n            done()\n          }\n        })\n      }\n    })\n  })\n\n  it('is OPEN when connection has been established', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents([]))\n      var es = new EventSource(server.url)\n\n      es.onopen = function () {\n        assert.equal(EventSource.OPEN, es.readyState)\n        server.close(done)\n      }\n    })\n  })\n\n  it('is CLOSED after connection has been closed', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents([]))\n      var es = new EventSource(server.url)\n\n      es.onopen = function () {\n        es.close()\n        assert.equal(EventSource.CLOSED, es.readyState)\n        server.close(done)\n      }\n    })\n  })\n})\n\ndescribe('Methods', function () {\n  it('close method exists and can be called to close an eventsource', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n      var es = new EventSource(server.url)\n      server.on('request', writeEvents([]))\n      es.onopen = function () {\n        assert.equal(es.close(), undefined)\n        server.close(done)\n      }\n    })\n  })\n\n  it('close method is a prototype method', function () {\n    assert.equal(typeof EventSource.prototype.close, 'function')\n  })\n})\n\ndescribe('Properties', function () {\n  it('url exposes original request url', function () {\n    var url = 'http://localhost:' + _port\n    var es = new EventSource(url)\n    assert.equal(url, es.url)\n  })\n})\n\ndescribe('Events', function () {\n  it('calls onopen when connection is established', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents([]))\n      var es = new EventSource(server.url)\n\n      es.onopen = function (event) {\n        assert.equal(event.type, 'open')\n        server.close(done)\n      }\n    })\n  })\n\n  it('supplies the correct origin', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents(['data: hello\\n\\n']))\n      var es = new EventSource(server.url)\n\n      es.onmessage = function (event) {\n        assert.equal(event.origin, server.url)\n        server.close(done)\n      }\n    })\n  })\n\n  it('emits open event when connection is established', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents([]))\n      var es = new EventSource(server.url)\n\n      es.addEventListener('open', function (event) {\n        assert.equal(event.type, 'open')\n        server.close(done)\n      })\n    })\n  })\n\n  it('does not double reconnect when connection is closed by server', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      var numConnections = 0\n      server.on('request', function (req, res) {\n        numConnections++\n        writeEvents([])(req, res)\n\n        if (numConnections > 2) done(new Error('reopening too many connections'))\n        // destroy only the first connection - expected only 1 other reconnect\n        if (numConnections === 1) {\n          process.nextTick(function () {\n            req.destroy()\n          })\n        }\n      })\n      const es = new EventSource(server.url)\n      es.reconnectInterval = 50\n\n      setTimeout(function () {\n        server.close(done)\n      }, 350)\n    })\n  })\n\n  it('does not emit error when connection is closed by client', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents([]))\n      var es = new EventSource(server.url)\n\n      es.addEventListener('open', function () {\n        es.close()\n        process.nextTick(function () {\n          server.close(done)\n        })\n      })\n      es.addEventListener('error', function () {\n        done(new Error('error should not be emitted'))\n      })\n    })\n  })\n\n  it('populates message\\'s lastEventId correctly when the last event has an associated id', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents(['id: 123\\ndata: hello\\n\\n']))\n      var es = new EventSource(server.url)\n\n      es.onmessage = function (m) {\n        assert.equal(m.lastEventId, '123')\n        server.close(done)\n      }\n    })\n  })\n\n  it('populates message\\'s lastEventId correctly when the last event doesn\\'t have an associated id', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents(['id: 123\\ndata: Hello\\n\\n', 'data: World\\n\\n']))\n      var es = new EventSource(server.url)\n\n      es.onmessage = first\n\n      function first () {\n        es.onmessage = second\n      }\n\n      function second (m) {\n        assert.equal(m.data, 'World')\n        assert.equal(m.lastEventId, '123')  // expect to get back the previous event id\n        server.close(done)\n      }\n    })\n  })\n\n  it('populates messages with enumerable properties so they can be inspected via console.log().', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents(['data: World\\n\\n']))\n      var es = new EventSource(server.url)\n\n      es.onmessage = function (m) {\n        var enumerableAttributes = Object.keys(m)\n        assert.notEqual(enumerableAttributes.indexOf('data'), -1)\n        assert.notEqual(enumerableAttributes.indexOf('type'), -1)\n        server.close(done)\n      }\n    })\n  })\n\n  it('throws error if the message type is unspecified, \\'\\' or null', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      var es = new EventSource(server.url)\n\n      assert.throws(function () { es.dispatchEvent({}) })\n      assert.throws(function () { es.dispatchEvent({type: undefined}) })\n      assert.throws(function () { es.dispatchEvent({type: ''}) })\n      assert.throws(function () { es.dispatchEvent({type: null}) })\n\n      server.close(done)\n    })\n  })\n\n  it('delivers the dispatched event without payload', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      var es = new EventSource(server.url)\n\n      es.addEventListener('greeting', function (m) {\n        server.close(done)\n      })\n\n      es.dispatchEvent({type: 'greeting'})\n    })\n  })\n\n  it('delivers the dispatched event with payload', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      var es = new EventSource(server.url)\n\n      es.addEventListener('greeting', function (m) {\n        assert.equal('Hello', m.data)\n        server.close(done)\n      })\n\n      es.dispatchEvent({type: 'greeting', detail: {data: 'Hello'}})\n    })\n  })\n})\n\ndescribe('Proxying', function () {\n  it('proxies http->http requests', function (done) {\n    createServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents(['data: World\\n\\n']))\n\n      createProxy(server.url, 'http', function (err, proxy) {\n        if (err) return done(err)\n\n        var es = new EventSource(server.url, {proxy: proxy.url})\n        es.onmessage = function (m) {\n          assert.equal(m.data, 'World')\n          proxy.close(function () {\n            server.close(done)\n          })\n        }\n      })\n    })\n  })\n\n  it('proxies http->https requests', function (done) {\n    createHttpsServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents(['data: World\\n\\n']))\n\n      createProxy(server.url, 'http', function (err, proxy) {\n        if (err) return done(err)\n\n        var es = new EventSource(server.url, {proxy: proxy.url})\n        es.onmessage = function (m) {\n          assert.equal(m.data, 'World')\n          proxy.close(function () {\n            server.close(done)\n          })\n        }\n      })\n    })\n  })\n\n  it('proxies https->http requests', function (done) {\n    createHttpsServer(function (err, server) {\n      if (err) return done(err)\n\n      server.on('request', writeEvents(['data: World\\n\\n']))\n\n      createProxy(server.url, 'https', function (err, proxy) {\n        if (err) return done(err)\n\n        var es = new EventSource(server.url, {proxy: proxy.url, rejectUnauthorized: false})\n        es.onmessage = function (m) {\n          assert.equal(m.data, 'World')\n          proxy.close(function () {\n            server.close(done)\n          })\n        }\n      })\n    })\n  })\n})\n"], "filenames": ["lib/eventsource.js", "test/eventsource_test.js"], "buggy_code_start_loc": [34, 578], "buggy_code_end_loc": [465, 578], "fixing_code_start_loc": [35, 579], "fixing_code_end_loc": [494, 622], "type": "CWE-200", "message": "Exposure of Sensitive Information to an Unauthorized Actor in GitHub repository eventsource/eventsource prior to v2.0.2.", "other": {"cve": {"id": "CVE-2022-1650", "sourceIdentifier": "security@huntr.dev", "published": "2022-05-12T11:15:07.290", "lastModified": "2022-12-13T01:59:30.683", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Exposure of Sensitive Information to an Unauthorized Actor in GitHub repository eventsource/eventsource prior to v2.0.2."}, {"lang": "es", "value": "Una Exposici\u00f3n de Informaci\u00f3n Confidencial a un Actor no Autorizado en el repositorio GitHub eventsource/eventsource versiones anteriores a v2.0.2"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 9.3, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 2.8, "impactScore": 5.8}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:eventsource:eventsource:*:*:*:*:node.js:*:*:*", "versionEndExcluding": "1.1.1", "matchCriteriaId": "7AC35E5D-57F8-4BF5-A812-C02E420D30C0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:eventsource:eventsource:*:*:*:*:node.js:*:*:*", "versionStartIncluding": "2.0.0", "versionEndExcluding": "2.0.2", "matchCriteriaId": "AF673C3C-2DB2-4915-8520-09E33629D98E"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "https://github.com/eventsource/eventsource/commit/10ee0c4881a6ba2fe65ec18ed195ac35889583c4", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/dc9e467f-be5d-4945-867d-1044d27e9b8e", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/12/msg00021.html", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/eventsource/eventsource/commit/10ee0c4881a6ba2fe65ec18ed195ac35889583c4"}}