{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                      CCCC   AAA    CCCC  H   H  EEEEE                       %\n%                     C      A   A  C      H   H  E                           %\n%                     C      AAAAA  C      HHHHH  EEE                         %\n%                     C      A   A  C      H   H  E                           %\n%                      CCCC  A   A   CCCC  H   H  EEEEE                       %\n%                                                                             %\n%                                                                             %\n%                       MagickCore Pixel Cache Methods                        %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1999                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/cache-private.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/composite-private.h\"\n#include \"MagickCore/distribute-cache-private.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/memory-private.h\"\n#include \"MagickCore/nt-base-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/policy.h\"\n#include \"MagickCore/quantum.h\"\n#include \"MagickCore/random_.h\"\n#include \"MagickCore/registry.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/semaphore.h\"\n#include \"MagickCore/splay-tree.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/thread-private.h\"\n#include \"MagickCore/utility.h\"\n#include \"MagickCore/utility-private.h\"\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n#include \"zlib.h\"\n#endif\n\f\n/*\n  Define declarations.\n*/\n#define CacheTick(offset,extent)  QuantumTick((MagickOffsetType) offset,extent)\n#define IsFileDescriptorLimitExceeded() (GetMagickResource(FileResource) > \\\n  GetMagickResourceLimit(FileResource) ? MagickTrue : MagickFalse)\n\f\n/*\n  Typedef declarations.\n*/\ntypedef struct _MagickModulo\n{\n  ssize_t\n    quotient,\n    remainder;\n} MagickModulo;\n\f\n/*\n  Forward declarations.\n*/\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\nstatic Cache\n  GetImagePixelCache(Image *,const MagickBooleanType,ExceptionInfo *)\n    magick_hot_spot;\n\nstatic const Quantum\n  *GetVirtualPixelCache(const Image *,const VirtualPixelMethod,const ssize_t,\n    const ssize_t,const size_t,const size_t,ExceptionInfo *),\n  *GetVirtualPixelsCache(const Image *);\n\nstatic const void\n  *GetVirtualMetacontentFromCache(const Image *);\n\nstatic MagickBooleanType\n  GetOneAuthenticPixelFromCache(Image *,const ssize_t,const ssize_t,Quantum *,\n    ExceptionInfo *),\n  GetOneVirtualPixelFromCache(const Image *,const VirtualPixelMethod,\n    const ssize_t,const ssize_t,Quantum *,ExceptionInfo *),\n  OpenPixelCache(Image *,const MapMode,ExceptionInfo *),\n  OpenPixelCacheOnDisk(CacheInfo *,const MapMode),\n  ReadPixelCachePixels(CacheInfo *magick_restrict,NexusInfo *magick_restrict,\n    ExceptionInfo *),\n  ReadPixelCacheMetacontent(CacheInfo *magick_restrict,\n    NexusInfo *magick_restrict,ExceptionInfo *),\n  SyncAuthenticPixelsCache(Image *,ExceptionInfo *),\n  WritePixelCachePixels(CacheInfo *magick_restrict,NexusInfo *magick_restrict,\n    ExceptionInfo *),\n  WritePixelCacheMetacontent(CacheInfo *,NexusInfo *magick_restrict,\n    ExceptionInfo *);\n\nstatic Quantum\n  *GetAuthenticPixelsCache(Image *,const ssize_t,const ssize_t,const size_t,\n    const size_t,ExceptionInfo *),\n  *QueueAuthenticPixelsCache(Image *,const ssize_t,const ssize_t,const size_t,\n    const size_t,ExceptionInfo *),\n  *SetPixelCacheNexusPixels(const CacheInfo *,const MapMode,\n    const RectangleInfo *,NexusInfo *,ExceptionInfo *) magick_hot_spot;\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\f\n/*\n  Global declarations.\n*/\nstatic volatile MagickBooleanType\n  instantiate_cache = MagickFalse;\n\nstatic SemaphoreInfo\n  *cache_semaphore = (SemaphoreInfo *) NULL;\n\nstatic time_t\n  cache_epoch = 0;\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   A c q u i r e P i x e l C a c h e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquirePixelCache() acquires a pixel cache.\n%\n%  The format of the AcquirePixelCache() method is:\n%\n%      Cache AcquirePixelCache(const size_t number_threads)\n%\n%  A description of each parameter follows:\n%\n%    o number_threads: the number of nexus threads.\n%\n*/\nMagickPrivate Cache AcquirePixelCache(const size_t number_threads)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  char\n    *synchronize;\n\n  cache_info=(CacheInfo *) AcquireQuantumMemory(1,sizeof(*cache_info));\n  if (cache_info == (CacheInfo *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(cache_info,0,sizeof(*cache_info));\n  cache_info->type=UndefinedCache;\n  cache_info->mode=IOMode;\n  cache_info->colorspace=sRGBColorspace;\n  cache_info->file=(-1);\n  cache_info->id=GetMagickThreadId();\n  cache_info->number_threads=number_threads;\n  if (GetOpenMPMaximumThreads() > cache_info->number_threads)\n    cache_info->number_threads=GetOpenMPMaximumThreads();\n  if (GetMagickResourceLimit(ThreadResource) > cache_info->number_threads)\n    cache_info->number_threads=(size_t) GetMagickResourceLimit(ThreadResource);\n  if (cache_info->number_threads == 0)\n    cache_info->number_threads=1;\n  cache_info->nexus_info=AcquirePixelCacheNexus(cache_info->number_threads);\n  if (cache_info->nexus_info == (NexusInfo **) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  synchronize=GetEnvironmentValue(\"MAGICK_SYNCHRONIZE\");\n  if (synchronize != (const char *) NULL)\n    {\n      cache_info->synchronize=IsStringTrue(synchronize);\n      synchronize=DestroyString(synchronize);\n    }\n  cache_info->semaphore=AcquireSemaphoreInfo();\n  cache_info->reference_count=1;\n  cache_info->file_semaphore=AcquireSemaphoreInfo();\n  cache_info->debug=IsEventLogging();\n  cache_info->signature=MagickCoreSignature;\n  return((Cache ) cache_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   A c q u i r e P i x e l C a c h e N e x u s                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquirePixelCacheNexus() allocates the NexusInfo structure.\n%\n%  The format of the AcquirePixelCacheNexus method is:\n%\n%      NexusInfo **AcquirePixelCacheNexus(const size_t number_threads)\n%\n%  A description of each parameter follows:\n%\n%    o number_threads: the number of nexus threads.\n%\n*/\nMagickPrivate NexusInfo **AcquirePixelCacheNexus(const size_t number_threads)\n{\n  NexusInfo\n    **magick_restrict nexus_info;\n\n  register ssize_t\n    i;\n\n  nexus_info=(NexusInfo **) MagickAssumeAligned(AcquireAlignedMemory(\n    number_threads,sizeof(*nexus_info)));\n  if (nexus_info == (NexusInfo **) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  nexus_info[0]=(NexusInfo *) AcquireQuantumMemory(number_threads,\n    sizeof(**nexus_info));\n  if (nexus_info[0] == (NexusInfo *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(nexus_info[0],0,number_threads*sizeof(**nexus_info));\n  for (i=0; i < (ssize_t) number_threads; i++)\n  {\n    nexus_info[i]=(&nexus_info[0][i]);\n    nexus_info[i]->signature=MagickCoreSignature;\n  }\n  return(nexus_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   A c q u i r e P i x e l C a c h e P i x e l s                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquirePixelCachePixels() returns the pixels associated with the specified\n%  image.\n%\n%  The format of the AcquirePixelCachePixels() method is:\n%\n%      const void *AcquirePixelCachePixels(const Image *image,\n%        MagickSizeType *length,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o length: the pixel cache length.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickPrivate const void *AcquirePixelCachePixels(const Image *image,\n  MagickSizeType *length,ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  *length=0;\n  if ((cache_info->type != MemoryCache) && (cache_info->type != MapCache))\n    return((const void *) NULL);\n  *length=cache_info->length;\n  return((const void *) cache_info->pixels);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   C a c h e C o m p o n e n t G e n e s i s                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CacheComponentGenesis() instantiates the cache component.\n%\n%  The format of the CacheComponentGenesis method is:\n%\n%      MagickBooleanType CacheComponentGenesis(void)\n%\n*/\nMagickPrivate MagickBooleanType CacheComponentGenesis(void)\n{\n  if (cache_semaphore == (SemaphoreInfo *) NULL)\n    cache_semaphore=AcquireSemaphoreInfo();\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   C a c h e C o m p o n e n t T e r m i n u s                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CacheComponentTerminus() destroys the cache component.\n%\n%  The format of the CacheComponentTerminus() method is:\n%\n%      CacheComponentTerminus(void)\n%\n*/\nMagickPrivate void CacheComponentTerminus(void)\n{\n  if (cache_semaphore == (SemaphoreInfo *) NULL)\n    ActivateSemaphoreInfo(&cache_semaphore);\n  LockSemaphoreInfo(cache_semaphore);\n  instantiate_cache=MagickFalse;\n  UnlockSemaphoreInfo(cache_semaphore);\n  RelinquishSemaphoreInfo(&cache_semaphore);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   C l o n e P i x e l C a c h e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ClonePixelCache() clones a pixel cache.\n%\n%  The format of the ClonePixelCache() method is:\n%\n%      Cache ClonePixelCache(const Cache cache)\n%\n%  A description of each parameter follows:\n%\n%    o cache: the pixel cache.\n%\n*/\nMagickPrivate Cache ClonePixelCache(const Cache cache)\n{\n  CacheInfo\n    *magick_restrict clone_info;\n\n  const CacheInfo\n    *magick_restrict cache_info;\n\n  assert(cache != NULL);\n  cache_info=(const CacheInfo *) cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  if (cache_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      cache_info->filename);\n  clone_info=(CacheInfo *) AcquirePixelCache(cache_info->number_threads);\n  if (clone_info == (Cache) NULL)\n    return((Cache) NULL);\n  clone_info->virtual_pixel_method=cache_info->virtual_pixel_method;\n  return((Cache ) clone_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   C l o n e P i x e l C a c h e M e t h o d s                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ClonePixelCacheMethods() clones the pixel cache methods from one cache to\n%  another.\n%\n%  The format of the ClonePixelCacheMethods() method is:\n%\n%      void ClonePixelCacheMethods(Cache clone,const Cache cache)\n%\n%  A description of each parameter follows:\n%\n%    o clone: Specifies a pointer to a Cache structure.\n%\n%    o cache: the pixel cache.\n%\n*/\nMagickPrivate void ClonePixelCacheMethods(Cache clone,const Cache cache)\n{\n  CacheInfo\n    *magick_restrict cache_info,\n    *magick_restrict source_info;\n\n  assert(clone != (Cache) NULL);\n  source_info=(CacheInfo *) clone;\n  assert(source_info->signature == MagickCoreSignature);\n  if (source_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      source_info->filename);\n  assert(cache != (Cache) NULL);\n  cache_info=(CacheInfo *) cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  source_info->methods=cache_info->methods;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   C l o n e P i x e l C a c h e R e p o s i t o r y                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%  ClonePixelCacheRepository() clones the source pixel cache to the destination\n%  cache.\n%\n%  The format of the ClonePixelCacheRepository() method is:\n%\n%      MagickBooleanType ClonePixelCacheRepository(CacheInfo *cache_info,\n%        CacheInfo *source_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o cache_info: the pixel cache.\n%\n%    o source_info: the source pixel cache.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic MagickBooleanType ClonePixelCacheOnDisk(\n  CacheInfo *magick_restrict cache_info,CacheInfo *magick_restrict clone_info)\n{\n  MagickSizeType\n    extent;\n\n  size_t\n    quantum;\n\n  ssize_t\n    count;\n\n  struct stat\n    file_stats;\n\n  unsigned char\n    *buffer;\n\n  /*\n    Clone pixel cache on disk with identifcal morphology.\n  */\n  if ((OpenPixelCacheOnDisk(cache_info,ReadMode) == MagickFalse) ||\n      (OpenPixelCacheOnDisk(clone_info,IOMode) == MagickFalse))\n    return(MagickFalse);\n  quantum=(size_t) MagickMaxBufferExtent;\n  if ((fstat(cache_info->file,&file_stats) == 0) && (file_stats.st_size > 0))\n    quantum=(size_t) MagickMin(file_stats.st_size,MagickMaxBufferExtent);\n  buffer=(unsigned char *) AcquireQuantumMemory(quantum,sizeof(*buffer));\n  if (buffer == (unsigned char *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  extent=0;\n  while ((count=read(cache_info->file,buffer,quantum)) > 0)\n  {\n    ssize_t\n      number_bytes;\n\n    number_bytes=write(clone_info->file,buffer,(size_t) count);\n    if (number_bytes != count)\n      break;\n    extent+=number_bytes;\n  }\n  buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n  if (extent != cache_info->length)\n    return(MagickFalse);\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType ClonePixelCacheRepository(\n  CacheInfo *magick_restrict clone_info,CacheInfo *magick_restrict cache_info,\n  ExceptionInfo *exception)\n{\n#define MaxCacheThreads  2\n#define cache_threads(source,destination) \\\n  num_threads(((source)->type == DiskCache) || \\\n    ((destination)->type == DiskCache) || (((source)->rows) < \\\n    (16*GetMagickResourceLimit(ThreadResource))) ? 1 : \\\n    GetMagickResourceLimit(ThreadResource) < MaxCacheThreads ? \\\n    GetMagickResourceLimit(ThreadResource) : MaxCacheThreads)\n\n  MagickBooleanType\n    optimize,\n    status;\n\n  NexusInfo\n    **magick_restrict cache_nexus,\n    **magick_restrict clone_nexus;\n\n  size_t\n    length;\n\n  ssize_t\n    y;\n\n  assert(cache_info != (CacheInfo *) NULL);\n  assert(clone_info != (CacheInfo *) NULL);\n  assert(exception != (ExceptionInfo *) NULL);\n  if (cache_info->type == PingCache)\n    return(MagickTrue);\n  length=cache_info->number_channels*sizeof(*cache_info->channel_map);\n  if ((cache_info->columns == clone_info->columns) &&\n      (cache_info->rows == clone_info->rows) &&\n      (cache_info->number_channels == clone_info->number_channels) &&\n      (memcmp(cache_info->channel_map,clone_info->channel_map,length) == 0) &&\n      (cache_info->metacontent_extent == clone_info->metacontent_extent))\n    {\n      /*\n        Identical pixel cache morphology.\n      */\n      if (((cache_info->type == MemoryCache) ||\n           (cache_info->type == MapCache)) &&\n          ((clone_info->type == MemoryCache) ||\n           (clone_info->type == MapCache)))\n        {\n          (void) memcpy(clone_info->pixels,cache_info->pixels,\n            cache_info->columns*cache_info->number_channels*cache_info->rows*\n            sizeof(*cache_info->pixels));\n          if ((cache_info->metacontent_extent != 0) &&\n              (clone_info->metacontent_extent != 0))\n            (void) memcpy(clone_info->metacontent,cache_info->metacontent,\n              cache_info->columns*cache_info->rows*\n              clone_info->metacontent_extent*sizeof(unsigned char));\n          return(MagickTrue);\n        }\n      if ((cache_info->type == DiskCache) && (clone_info->type == DiskCache))\n        return(ClonePixelCacheOnDisk(cache_info,clone_info));\n    }\n  /*\n    Mismatched pixel cache morphology.\n  */\n  cache_nexus=AcquirePixelCacheNexus(MaxCacheThreads);\n  clone_nexus=AcquirePixelCacheNexus(MaxCacheThreads);\n  if ((cache_nexus == (NexusInfo **) NULL) ||\n      (clone_nexus == (NexusInfo **) NULL))\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  length=cache_info->number_channels*sizeof(*cache_info->channel_map);\n  optimize=(cache_info->number_channels == clone_info->number_channels) &&\n    (memcmp(cache_info->channel_map,clone_info->channel_map,length) == 0) ?\n    MagickTrue : MagickFalse;\n  length=(size_t) MagickMin(cache_info->columns*cache_info->number_channels,\n    clone_info->columns*clone_info->number_channels);\n  status=MagickTrue;\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(status) \\\n    cache_threads(cache_info,clone_info)\n#endif\n  for (y=0; y < (ssize_t) cache_info->rows; y++)\n  {\n    const int\n      id = GetOpenMPThreadId();\n\n    Quantum\n      *pixels;\n\n    RectangleInfo\n      region;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    if (y >= (ssize_t) clone_info->rows)\n      continue;\n    region.width=cache_info->columns;\n    region.height=1;\n    region.x=0;\n    region.y=y;\n    pixels=SetPixelCacheNexusPixels(cache_info,ReadMode,&region,\n      cache_nexus[id],exception);\n    if (pixels == (Quantum *) NULL)\n      continue;\n    status=ReadPixelCachePixels(cache_info,cache_nexus[id],exception);\n    if (status == MagickFalse)\n      continue;\n    region.width=clone_info->columns;\n    pixels=SetPixelCacheNexusPixels(clone_info,WriteMode,&region,\n      clone_nexus[id],exception);\n    if (pixels == (Quantum *) NULL)\n      continue;\n    (void) ResetMagickMemory(clone_nexus[id]->pixels,0,(size_t)\n      clone_nexus[id]->length);\n    if (optimize != MagickFalse)\n      (void) memcpy(clone_nexus[id]->pixels,cache_nexus[id]->pixels,length*\n        sizeof(Quantum));\n    else\n      {\n        register const Quantum\n          *magick_restrict p;\n\n        register Quantum\n          *magick_restrict q;\n\n        /*\n          Mismatched pixel channel map.\n        */\n        p=cache_nexus[id]->pixels;\n        q=clone_nexus[id]->pixels;\n        for (x=0; x < (ssize_t) cache_info->columns; x++)\n        {\n          register ssize_t\n            i;\n\n          if (x == (ssize_t) clone_info->columns)\n            break;\n          for (i=0; i < (ssize_t) clone_info->number_channels; i++)\n          {\n            PixelChannel\n              channel;\n\n            PixelTrait\n              traits;\n\n            channel=clone_info->channel_map[i].channel;\n            traits=cache_info->channel_map[channel].traits;\n            if (traits != UndefinedPixelTrait)\n              *q=*(p+cache_info->channel_map[channel].offset);\n            q++;\n          }\n          p+=cache_info->number_channels;\n        }\n      }\n    status=WritePixelCachePixels(clone_info,clone_nexus[id],exception);\n  }\n  if ((cache_info->metacontent_extent != 0) &&\n      (clone_info->metacontent_extent != 0))\n    {\n      /*\n        Clone metacontent.\n      */\n      length=(size_t) MagickMin(cache_info->metacontent_extent,\n        clone_info->metacontent_extent);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      #pragma omp parallel for schedule(static,4) shared(status) \\\n        cache_threads(cache_info,clone_info)\n#endif\n      for (y=0; y < (ssize_t) cache_info->rows; y++)\n      {\n        const int\n          id = GetOpenMPThreadId();\n\n        Quantum\n          *pixels;\n\n        RectangleInfo\n          region;\n\n        if (status == MagickFalse)\n          continue;\n        if (y >= (ssize_t) clone_info->rows)\n          continue;\n        region.width=cache_info->columns;\n        region.height=1;\n        region.x=0;\n        region.y=y;\n        pixels=SetPixelCacheNexusPixels(cache_info,ReadMode,&region,\n          cache_nexus[id],exception);\n        if (pixels == (Quantum *) NULL)\n          continue;\n        status=ReadPixelCacheMetacontent(cache_info,cache_nexus[id],exception);\n        if (status == MagickFalse)\n          continue;\n        region.width=clone_info->columns;\n        pixels=SetPixelCacheNexusPixels(clone_info,WriteMode,&region,\n          clone_nexus[id],exception);\n        if (pixels == (Quantum *) NULL)\n          continue;\n        if ((clone_nexus[id]->metacontent != (void *) NULL) &&\n            (cache_nexus[id]->metacontent != (void *) NULL))\n          (void) memcpy(clone_nexus[id]->metacontent,\n            cache_nexus[id]->metacontent,length*sizeof(unsigned char));\n        status=WritePixelCacheMetacontent(clone_info,clone_nexus[id],exception);\n      }\n    }\n  cache_nexus=DestroyPixelCacheNexus(cache_nexus,MaxCacheThreads);\n  clone_nexus=DestroyPixelCacheNexus(clone_nexus,MaxCacheThreads);\n  if (cache_info->debug != MagickFalse)\n    {\n      char\n        message[MagickPathExtent];\n\n      (void) FormatLocaleString(message,MagickPathExtent,\"%s => %s\",\n        CommandOptionToMnemonic(MagickCacheOptions,(ssize_t) cache_info->type),\n        CommandOptionToMnemonic(MagickCacheOptions,(ssize_t) clone_info->type));\n      (void) LogMagickEvent(CacheEvent,GetMagickModule(),\"%s\",message);\n    }\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D e s t r o y I m a g e P i x e l C a c h e                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyImagePixelCache() deallocates memory associated with the pixel cache.\n%\n%  The format of the DestroyImagePixelCache() method is:\n%\n%      void DestroyImagePixelCache(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nstatic void DestroyImagePixelCache(Image *image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->cache == (void *) NULL)\n    return;\n  image->cache=DestroyPixelCache(image->cache);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D e s t r o y I m a g e P i x e l s                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyImagePixels() deallocates memory associated with the pixel cache.\n%\n%  The format of the DestroyImagePixels() method is:\n%\n%      void DestroyImagePixels(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport void DestroyImagePixels(Image *image)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  if (cache_info->methods.destroy_pixel_handler != (DestroyPixelHandler) NULL)\n    {\n      cache_info->methods.destroy_pixel_handler(image);\n      return;\n    }\n  image->cache=DestroyPixelCache(image->cache);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D e s t r o y P i x e l C a c h e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyPixelCache() deallocates memory associated with the pixel cache.\n%\n%  The format of the DestroyPixelCache() method is:\n%\n%      Cache DestroyPixelCache(Cache cache)\n%\n%  A description of each parameter follows:\n%\n%    o cache: the pixel cache.\n%\n*/\n\nstatic MagickBooleanType ClosePixelCacheOnDisk(CacheInfo *cache_info)\n{\n  int\n    status;\n\n  status=(-1);\n  if (cache_info->file != -1)\n    {\n      status=close(cache_info->file);\n      cache_info->file=(-1);\n      RelinquishMagickResource(FileResource,1);\n    }\n  return(status == -1 ? MagickFalse : MagickTrue);\n}\n\nstatic inline void RelinquishPixelCachePixels(CacheInfo *cache_info)\n{\n  switch (cache_info->type)\n  {\n    case MemoryCache:\n    {\n      if (cache_info->mapped == MagickFalse)\n        cache_info->pixels=(Quantum *) RelinquishAlignedMemory(\n          cache_info->pixels);\n      else\n        {\n          (void) UnmapBlob(cache_info->pixels,(size_t) cache_info->length);\n          cache_info->pixels=(Quantum *) NULL;\n        }\n      RelinquishMagickResource(MemoryResource,cache_info->length);\n      break;\n    }\n    case MapCache:\n    {\n      (void) UnmapBlob(cache_info->pixels,(size_t) cache_info->length);\n      cache_info->pixels=(Quantum *) NULL;\n      if (cache_info->mode != ReadMode)\n        (void) RelinquishUniqueFileResource(cache_info->cache_filename);\n      *cache_info->cache_filename='\\0';\n      RelinquishMagickResource(MapResource,cache_info->length);\n    }\n    case DiskCache:\n    {\n      if (cache_info->file != -1)\n        (void) ClosePixelCacheOnDisk(cache_info);\n      if (cache_info->mode != ReadMode)\n        (void) RelinquishUniqueFileResource(cache_info->cache_filename);\n      *cache_info->cache_filename='\\0';\n      RelinquishMagickResource(DiskResource,cache_info->length);\n      break;\n    }\n    case DistributedCache:\n    {\n      *cache_info->cache_filename='\\0';\n      (void) RelinquishDistributePixelCache((DistributeCacheInfo *)\n        cache_info->server_info);\n      break;\n    }\n    default:\n      break;\n  }\n  cache_info->type=UndefinedCache;\n  cache_info->mapped=MagickFalse;\n  cache_info->metacontent=(void *) NULL;\n}\n\nMagickPrivate Cache DestroyPixelCache(Cache cache)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  assert(cache != (Cache) NULL);\n  cache_info=(CacheInfo *) cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  if (cache_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      cache_info->filename);\n  LockSemaphoreInfo(cache_info->semaphore);\n  cache_info->reference_count--;\n  if (cache_info->reference_count != 0)\n    {\n      UnlockSemaphoreInfo(cache_info->semaphore);\n      return((Cache) NULL);\n    }\n  UnlockSemaphoreInfo(cache_info->semaphore);\n  if (cache_info->debug != MagickFalse)\n    {\n      char\n        message[MagickPathExtent];\n\n      (void) FormatLocaleString(message,MagickPathExtent,\"destroy %s\",\n        cache_info->filename);\n      (void) LogMagickEvent(CacheEvent,GetMagickModule(),\"%s\",message);\n    }\n  RelinquishPixelCachePixels(cache_info);\n  if (cache_info->server_info != (DistributeCacheInfo *) NULL)\n    cache_info->server_info=DestroyDistributeCacheInfo((DistributeCacheInfo *)\n      cache_info->server_info);\n  if (cache_info->nexus_info != (NexusInfo **) NULL)\n    cache_info->nexus_info=DestroyPixelCacheNexus(cache_info->nexus_info,\n      cache_info->number_threads);\n  if (cache_info->random_info != (RandomInfo *) NULL)\n    cache_info->random_info=DestroyRandomInfo(cache_info->random_info);\n  if (cache_info->file_semaphore != (SemaphoreInfo *) NULL)\n    RelinquishSemaphoreInfo(&cache_info->file_semaphore);\n  if (cache_info->semaphore != (SemaphoreInfo *) NULL)\n    RelinquishSemaphoreInfo(&cache_info->semaphore);\n  cache_info->signature=(~MagickCoreSignature);\n  cache_info=(CacheInfo *) RelinquishMagickMemory(cache_info);\n  cache=(Cache) NULL;\n  return(cache);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D e s t r o y P i x e l C a c h e N e x u s                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyPixelCacheNexus() destroys a pixel cache nexus.\n%\n%  The format of the DestroyPixelCacheNexus() method is:\n%\n%      NexusInfo **DestroyPixelCacheNexus(NexusInfo *nexus_info,\n%        const size_t number_threads)\n%\n%  A description of each parameter follows:\n%\n%    o nexus_info: the nexus to destroy.\n%\n%    o number_threads: the number of nexus threads.\n%\n*/\n\nstatic inline void RelinquishCacheNexusPixels(NexusInfo *nexus_info)\n{\n  if (nexus_info->mapped == MagickFalse)\n    (void) RelinquishAlignedMemory(nexus_info->cache);\n  else\n    (void) UnmapBlob(nexus_info->cache,(size_t) nexus_info->length);\n  nexus_info->cache=(Quantum *) NULL;\n  nexus_info->pixels=(Quantum *) NULL;\n  nexus_info->metacontent=(void *) NULL;\n  nexus_info->length=0;\n  nexus_info->mapped=MagickFalse;\n}\n\nMagickPrivate NexusInfo **DestroyPixelCacheNexus(NexusInfo **nexus_info,\n  const size_t number_threads)\n{\n  register ssize_t\n    i;\n\n  assert(nexus_info != (NexusInfo **) NULL);\n  for (i=0; i < (ssize_t) number_threads; i++)\n  {\n    if (nexus_info[i]->cache != (Quantum *) NULL)\n      RelinquishCacheNexusPixels(nexus_info[i]);\n    nexus_info[i]->signature=(~MagickCoreSignature);\n  }\n  nexus_info[0]=(NexusInfo *) RelinquishMagickMemory(nexus_info[0]);\n  nexus_info=(NexusInfo **) RelinquishAlignedMemory(nexus_info);\n  return(nexus_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t A u t h e n t i c M e t a c o n t e n t                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetAuthenticMetacontent() returns the authentic metacontent corresponding\n%  with the last call to QueueAuthenticPixels() or GetVirtualPixels().  NULL is\n%  returned if the associated pixels are not available.\n%\n%  The format of the GetAuthenticMetacontent() method is:\n%\n%      void *GetAuthenticMetacontent(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport void *GetAuthenticMetacontent(const Image *image)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  if (cache_info->methods.get_authentic_metacontent_from_handler !=\n      (GetAuthenticMetacontentFromHandler) NULL)\n    {\n      void\n        *metacontent;\n\n      metacontent=cache_info->methods.\n        get_authentic_metacontent_from_handler(image);\n      return(metacontent);\n    }\n  assert(id < (int) cache_info->number_threads);\n  return(cache_info->nexus_info[id]->metacontent);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t A u t h e n t i c M e t a c o n t e n t F r o m C a c h e           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetAuthenticMetacontentFromCache() returns the meta-content corresponding\n%  with the last call to QueueAuthenticPixelsCache() or\n%  GetAuthenticPixelsCache().\n%\n%  The format of the GetAuthenticMetacontentFromCache() method is:\n%\n%      void *GetAuthenticMetacontentFromCache(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nstatic void *GetAuthenticMetacontentFromCache(const Image *image)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  assert(id < (int) cache_info->number_threads);\n  return(cache_info->nexus_info[id]->metacontent);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t A u t h e n t i c P i x e l C a c h e N e x u s                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetAuthenticPixelCacheNexus() gets authentic pixels from the in-memory or\n%  disk pixel cache as defined by the geometry parameters.   A pointer to the\n%  pixels is returned if the pixels are transferred, otherwise a NULL is\n%  returned.\n%\n%  The format of the GetAuthenticPixelCacheNexus() method is:\n%\n%      Quantum *GetAuthenticPixelCacheNexus(Image *image,const ssize_t x,\n%        const ssize_t y,const size_t columns,const size_t rows,\n%        NexusInfo *nexus_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o x,y,columns,rows:  These values define the perimeter of a region of\n%      pixels.\n%\n%    o nexus_info: the cache nexus to return.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nMagickPrivate Quantum *GetAuthenticPixelCacheNexus(Image *image,const ssize_t x,\n  const ssize_t y,const size_t columns,const size_t rows,NexusInfo *nexus_info,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  Quantum\n    *magick_restrict pixels;\n\n  /*\n    Transfer pixels from the cache.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  pixels=QueueAuthenticPixelCacheNexus(image,x,y,columns,rows,MagickTrue,\n    nexus_info,exception);\n  if (pixels == (Quantum *) NULL)\n    return((Quantum *) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  if (nexus_info->authentic_pixel_cache != MagickFalse)\n    return(pixels);\n  if (ReadPixelCachePixels(cache_info,nexus_info,exception) == MagickFalse)\n    return((Quantum *) NULL);\n  if (cache_info->metacontent_extent != 0)\n    if (ReadPixelCacheMetacontent(cache_info,nexus_info,exception) == MagickFalse)\n      return((Quantum *) NULL);\n  return(pixels);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t A u t h e n t i c P i x e l s F r o m C a c h e                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetAuthenticPixelsFromCache() returns the pixels associated with the last\n%  call to the QueueAuthenticPixelsCache() or GetAuthenticPixelsCache() methods.\n%\n%  The format of the GetAuthenticPixelsFromCache() method is:\n%\n%      Quantum *GetAuthenticPixelsFromCache(const Image image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nstatic Quantum *GetAuthenticPixelsFromCache(const Image *image)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  assert(id < (int) cache_info->number_threads);\n  return(cache_info->nexus_info[id]->pixels);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t A u t h e n t i c P i x e l Q u e u e                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetAuthenticPixelQueue() returns the authentic pixels associated\n%  corresponding with the last call to QueueAuthenticPixels() or\n%  GetAuthenticPixels().\n%\n%  The format of the GetAuthenticPixelQueue() method is:\n%\n%      Quantum *GetAuthenticPixelQueue(const Image image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport Quantum *GetAuthenticPixelQueue(const Image *image)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  if (cache_info->methods.get_authentic_pixels_from_handler !=\n       (GetAuthenticPixelsFromHandler) NULL)\n    return(cache_info->methods.get_authentic_pixels_from_handler(image));\n  assert(id < (int) cache_info->number_threads);\n  return(cache_info->nexus_info[id]->pixels);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t A u t h e n t i c P i x e l s                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetAuthenticPixels() obtains a pixel region for read/write access. If the\n%  region is successfully accessed, a pointer to a Quantum array\n%  representing the region is returned, otherwise NULL is returned.\n%\n%  The returned pointer may point to a temporary working copy of the pixels\n%  or it may point to the original pixels in memory. Performance is maximized\n%  if the selected region is part of one row, or one or more full rows, since\n%  then there is opportunity to access the pixels in-place (without a copy)\n%  if the image is in memory, or in a memory-mapped file. The returned pointer\n%  must *never* be deallocated by the user.\n%\n%  Pixels accessed via the returned pointer represent a simple array of type\n%  Quantum.  If the image has corresponding metacontent,call\n%  GetAuthenticMetacontent() after invoking GetAuthenticPixels() to obtain the\n%  meta-content corresponding to the region.  Once the Quantum array has\n%  been updated, the changes must be saved back to the underlying image using\n%  SyncAuthenticPixels() or they may be lost.\n%\n%  The format of the GetAuthenticPixels() method is:\n%\n%      Quantum *GetAuthenticPixels(Image *image,const ssize_t x,\n%        const ssize_t y,const size_t columns,const size_t rows,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o x,y,columns,rows:  These values define the perimeter of a region of\n%      pixels.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Quantum *GetAuthenticPixels(Image *image,const ssize_t x,\n  const ssize_t y,const size_t columns,const size_t rows,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  Quantum\n    *pixels;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  if (cache_info->methods.get_authentic_pixels_handler !=\n      (GetAuthenticPixelsHandler) NULL)\n    {\n      pixels=cache_info->methods.get_authentic_pixels_handler(image,x,y,columns,\n        rows,exception);\n      return(pixels);\n    }\n  assert(id < (int) cache_info->number_threads);\n  pixels=GetAuthenticPixelCacheNexus(image,x,y,columns,rows,\n    cache_info->nexus_info[id],exception);\n  return(pixels);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t A u t h e n t i c P i x e l s C a c h e                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetAuthenticPixelsCache() gets pixels from the in-memory or disk pixel cache\n%  as defined by the geometry parameters.   A pointer to the pixels is returned\n%  if the pixels are transferred, otherwise a NULL is returned.\n%\n%  The format of the GetAuthenticPixelsCache() method is:\n%\n%      Quantum *GetAuthenticPixelsCache(Image *image,const ssize_t x,\n%        const ssize_t y,const size_t columns,const size_t rows,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o x,y,columns,rows:  These values define the perimeter of a region of\n%      pixels.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Quantum *GetAuthenticPixelsCache(Image *image,const ssize_t x,\n  const ssize_t y,const size_t columns,const size_t rows,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  Quantum\n    *magick_restrict pixels;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  if (cache_info == (Cache) NULL)\n    return((Quantum *) NULL);\n  assert(cache_info->signature == MagickCoreSignature);\n  assert(id < (int) cache_info->number_threads);\n  pixels=GetAuthenticPixelCacheNexus(image,x,y,columns,rows,\n    cache_info->nexus_info[id],exception);\n  return(pixels);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t I m a g e E x t e n t                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageExtent() returns the extent of the pixels associated corresponding\n%  with the last call to QueueAuthenticPixels() or GetAuthenticPixels().\n%\n%  The format of the GetImageExtent() method is:\n%\n%      MagickSizeType GetImageExtent(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport MagickSizeType GetImageExtent(const Image *image)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  assert(id < (int) cache_info->number_threads);\n  return(GetPixelCacheNexusExtent(cache_info,cache_info->nexus_info[id]));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t I m a g e P i x e l C a c h e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImagePixelCache() ensures that there is only a single reference to the\n%  pixel cache to be modified, updating the provided cache pointer to point to\n%  a clone of the original pixel cache if necessary.\n%\n%  The format of the GetImagePixelCache method is:\n%\n%      Cache GetImagePixelCache(Image *image,const MagickBooleanType clone,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o clone: any value other than MagickFalse clones the cache pixels.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline MagickBooleanType ValidatePixelCacheMorphology(\n  const Image *magick_restrict image)\n{\n  const CacheInfo\n    *magick_restrict cache_info;\n\n  const PixelChannelMap\n    *magick_restrict p,\n    *magick_restrict q;\n\n  /*\n    Does the image match the pixel cache morphology?\n  */\n  cache_info=(CacheInfo *) image->cache;\n  p=image->channel_map;\n  q=cache_info->channel_map;\n  if ((image->storage_class != cache_info->storage_class) ||\n      (image->colorspace != cache_info->colorspace) ||\n      (image->alpha_trait != cache_info->alpha_trait) ||\n      (image->read_mask != cache_info->read_mask) ||\n      (image->write_mask != cache_info->write_mask) ||\n      (image->columns != cache_info->columns) ||\n      (image->rows != cache_info->rows) ||\n      (image->number_channels != cache_info->number_channels) ||\n      (memcmp(p,q,image->number_channels*sizeof(*p)) != 0) ||\n      (image->metacontent_extent != cache_info->metacontent_extent) ||\n      (cache_info->nexus_info == (NexusInfo **) NULL))\n    return(MagickFalse);\n  return(MagickTrue);\n}\n\nstatic Cache GetImagePixelCache(Image *image,const MagickBooleanType clone,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  MagickBooleanType\n    destroy,\n    status;\n\n  static MagickSizeType\n    cache_timelimit = 0,\n    cpu_throttle = MagickResourceInfinity,\n    cycles = 0;\n\n  status=MagickTrue;\n  if (cpu_throttle == MagickResourceInfinity)\n    cpu_throttle=GetMagickResourceLimit(ThrottleResource);\n  if ((cpu_throttle != 0) && ((cycles++ % 32) == 0))\n    MagickDelay(cpu_throttle);\n  if (cache_epoch == 0)\n    {\n      /*\n        Set the expire time in seconds.\n      */\n      cache_timelimit=GetMagickResourceLimit(TimeResource);\n      cache_epoch=time((time_t *) NULL);\n    }\n  if ((cache_timelimit != MagickResourceInfinity) &&\n      ((MagickSizeType) (time((time_t *) NULL)-cache_epoch) >= cache_timelimit))\n     {\n#if defined(ECANCELED)\n       errno=ECANCELED;\n#endif\n       ThrowFatalException(ResourceLimitFatalError,\"TimeLimitExceeded\");\n     }\n  LockSemaphoreInfo(image->semaphore);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  destroy=MagickFalse;\n  if ((cache_info->reference_count > 1) || (cache_info->mode == ReadMode))\n    {\n      LockSemaphoreInfo(cache_info->semaphore);\n      if ((cache_info->reference_count > 1) || (cache_info->mode == ReadMode))\n        {\n          CacheInfo\n            *clone_info;\n\n          Image\n            clone_image;\n\n          /*\n            Clone pixel cache.\n          */\n          clone_image=(*image);\n          clone_image.semaphore=AcquireSemaphoreInfo();\n          clone_image.reference_count=1;\n          clone_image.cache=ClonePixelCache(cache_info);\n          clone_info=(CacheInfo *) clone_image.cache;\n          status=OpenPixelCache(&clone_image,IOMode,exception);\n          if (status != MagickFalse)\n            {\n              if (clone != MagickFalse)\n                status=ClonePixelCacheRepository(clone_info,cache_info,\n                  exception);\n              if (status != MagickFalse)\n                {\n                  if (cache_info->reference_count == 1)\n                    cache_info->nexus_info=(NexusInfo **) NULL;\n                  destroy=MagickTrue;\n                  image->cache=clone_image.cache;\n                }\n            }\n          RelinquishSemaphoreInfo(&clone_image.semaphore);\n        }\n      UnlockSemaphoreInfo(cache_info->semaphore);\n    }\n  if (destroy != MagickFalse)\n    cache_info=(CacheInfo *) DestroyPixelCache(cache_info);\n  if (status != MagickFalse)\n    {\n      /*\n        Ensure the image matches the pixel cache morphology.\n      */\n      image->type=UndefinedType;\n      if (ValidatePixelCacheMorphology(image) == MagickFalse)\n        {\n          status=OpenPixelCache(image,IOMode,exception);\n          cache_info=(CacheInfo *) image->cache;\n          if (cache_info->type == DiskCache)\n            (void) ClosePixelCacheOnDisk(cache_info);\n        }\n    }\n  UnlockSemaphoreInfo(image->semaphore);\n  if (status == MagickFalse)\n    return((Cache) NULL);\n  return(image->cache);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t I m a g e P i x e l C a c h e T y p e                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImagePixelCacheType() returns the pixel cache type: UndefinedCache,\n%  DiskCache, MemoryCache, MapCache, or PingCache.\n%\n%  The format of the GetImagePixelCacheType() method is:\n%\n%      CacheType GetImagePixelCacheType(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport CacheType GetImagePixelCacheType(const Image *image)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  return(cache_info->type);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t O n e A u t h e n t i c P i x e l                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetOneAuthenticPixel() returns a single pixel at the specified (x,y)\n%  location.  The image background color is returned if an error occurs.\n%\n%  The format of the GetOneAuthenticPixel() method is:\n%\n%      MagickBooleanType GetOneAuthenticPixel(const Image image,const ssize_t x,\n%        const ssize_t y,Quantum *pixel,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o x,y:  These values define the location of the pixel to return.\n%\n%    o pixel: return a pixel at the specified (x,y) location.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline MagickBooleanType CopyPixel(const Image *image,const Quantum *source,\n  Quantum *destination)\n{\n  register ssize_t\n    i;\n\n  if (source == (const Quantum *) NULL)\n    {\n      destination[RedPixelChannel]=ClampToQuantum(image->background_color.red);\n      destination[GreenPixelChannel]=ClampToQuantum(image->background_color.green);\n      destination[BluePixelChannel]=ClampToQuantum(image->background_color.blue);\n      destination[BlackPixelChannel]=ClampToQuantum(image->background_color.black);\n      destination[AlphaPixelChannel]=ClampToQuantum(image->background_color.alpha);\n      return(MagickFalse);\n    }\n  for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n  {\n    PixelChannel channel=GetPixelChannelChannel(image,i);\n    destination[channel]=source[i];\n  }\n  return(MagickTrue);\n}\n\nMagickExport MagickBooleanType GetOneAuthenticPixel(Image *image,\n  const ssize_t x,const ssize_t y,Quantum *pixel,ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  register Quantum\n    *magick_restrict q;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  (void) memset(pixel,0,MaxPixelChannels*sizeof(*pixel));\n  if (cache_info->methods.get_one_authentic_pixel_from_handler !=\n       (GetOneAuthenticPixelFromHandler) NULL)\n    return(cache_info->methods.get_one_authentic_pixel_from_handler(image,x,y,\n      pixel,exception));\n  q=GetAuthenticPixelsCache(image,x,y,1UL,1UL,exception);\n  return(CopyPixel(image,q,pixel));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t O n e A u t h e n t i c P i x e l F r o m C a c h e                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetOneAuthenticPixelFromCache() returns a single pixel at the specified (x,y)\n%  location.  The image background color is returned if an error occurs.\n%\n%  The format of the GetOneAuthenticPixelFromCache() method is:\n%\n%      MagickBooleanType GetOneAuthenticPixelFromCache(const Image image,\n%        const ssize_t x,const ssize_t y,Quantum *pixel,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o x,y:  These values define the location of the pixel to return.\n%\n%    o pixel: return a pixel at the specified (x,y) location.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType GetOneAuthenticPixelFromCache(Image *image,\n  const ssize_t x,const ssize_t y,Quantum *pixel,ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  register Quantum\n    *magick_restrict q;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  assert(id < (int) cache_info->number_threads);\n  (void) memset(pixel,0,MaxPixelChannels*sizeof(*pixel));\n  q=GetAuthenticPixelCacheNexus(image,x,y,1UL,1UL,cache_info->nexus_info[id],\n    exception);\n  return(CopyPixel(image,q,pixel));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t O n e V i r t u a l P i x e l                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetOneVirtualPixel() returns a single virtual pixel at the specified\n%  (x,y) location.  The image background color is returned if an error occurs.\n%  If you plan to modify the pixel, use GetOneAuthenticPixel() instead.\n%\n%  The format of the GetOneVirtualPixel() method is:\n%\n%      MagickBooleanType GetOneVirtualPixel(const Image image,const ssize_t x,\n%        const ssize_t y,Quantum *pixel,ExceptionInfo exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o x,y:  These values define the location of the pixel to return.\n%\n%    o pixel: return a pixel at the specified (x,y) location.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType GetOneVirtualPixel(const Image *image,\n  const ssize_t x,const ssize_t y,Quantum *pixel,ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  const Quantum\n    *p;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  (void) memset(pixel,0,MaxPixelChannels*sizeof(*pixel));\n  if (cache_info->methods.get_one_virtual_pixel_from_handler !=\n       (GetOneVirtualPixelFromHandler) NULL)\n    return(cache_info->methods.get_one_virtual_pixel_from_handler(image,\n      GetPixelCacheVirtualMethod(image),x,y,pixel,exception));\n  assert(id < (int) cache_info->number_threads);\n  p=GetVirtualPixelsFromNexus(image,GetPixelCacheVirtualMethod(image),x,y,\n    1UL,1UL,cache_info->nexus_info[id],exception);\n  return(CopyPixel(image,p,pixel));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t O n e V i r t u a l P i x e l F r o m C a c h e                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetOneVirtualPixelFromCache() returns a single virtual pixel at the\n%  specified (x,y) location.  The image background color is returned if an\n%  error occurs.\n%\n%  The format of the GetOneVirtualPixelFromCache() method is:\n%\n%      MagickBooleanType GetOneVirtualPixelFromCache(const Image image,\n%        const VirtualPixelMethod method,const ssize_t x,const ssize_t y,\n%        Quantum *pixel,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o virtual_pixel_method: the virtual pixel method.\n%\n%    o x,y:  These values define the location of the pixel to return.\n%\n%    o pixel: return a pixel at the specified (x,y) location.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType GetOneVirtualPixelFromCache(const Image *image,\n  const VirtualPixelMethod virtual_pixel_method,const ssize_t x,const ssize_t y,\n  Quantum *pixel,ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  const Quantum\n    *p;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  assert(id < (int) cache_info->number_threads);\n  (void) memset(pixel,0,MaxPixelChannels*sizeof(*pixel));\n  p=GetVirtualPixelsFromNexus(image,virtual_pixel_method,x,y,1UL,1UL,\n    cache_info->nexus_info[id],exception);\n  return(CopyPixel(image,p,pixel));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t O n e V i r t u a l P i x e l I n f o                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetOneVirtualPixelInfo() returns a single pixel at the specified (x,y)\n%  location.  The image background color is returned if an error occurs.  If\n%  you plan to modify the pixel, use GetOneAuthenticPixel() instead.\n%\n%  The format of the GetOneVirtualPixelInfo() method is:\n%\n%      MagickBooleanType GetOneVirtualPixelInfo(const Image image,\n%        const VirtualPixelMethod virtual_pixel_method,const ssize_t x,\n%        const ssize_t y,PixelInfo *pixel,ExceptionInfo exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o virtual_pixel_method: the virtual pixel method.\n%\n%    o x,y:  these values define the location of the pixel to return.\n%\n%    o pixel: return a pixel at the specified (x,y) location.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType GetOneVirtualPixelInfo(const Image *image,\n  const VirtualPixelMethod virtual_pixel_method,const ssize_t x,const ssize_t y,\n  PixelInfo *pixel,ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  register const Quantum\n    *magick_restrict p;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  assert(id < (int) cache_info->number_threads);\n  GetPixelInfo(image,pixel);\n  p=GetVirtualPixelsFromNexus(image,virtual_pixel_method,x,y,1UL,1UL,\n    cache_info->nexus_info[id],exception);\n  if (p == (const Quantum *) NULL)\n    return(MagickFalse);\n  GetPixelInfoPixel(image,p,pixel);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t P i x e l C a c h e C o l o r s p a c e                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetPixelCacheColorspace() returns the class type of the pixel cache.\n%\n%  The format of the GetPixelCacheColorspace() method is:\n%\n%      Colorspace GetPixelCacheColorspace(Cache cache)\n%\n%  A description of each parameter follows:\n%\n%    o cache: the pixel cache.\n%\n*/\nMagickPrivate ColorspaceType GetPixelCacheColorspace(const Cache cache)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  assert(cache != (Cache) NULL);\n  cache_info=(CacheInfo *) cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  if (cache_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      cache_info->filename);\n  return(cache_info->colorspace);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t P i x e l C a c h e M e t h o d s                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetPixelCacheMethods() initializes the CacheMethods structure.\n%\n%  The format of the GetPixelCacheMethods() method is:\n%\n%      void GetPixelCacheMethods(CacheMethods *cache_methods)\n%\n%  A description of each parameter follows:\n%\n%    o cache_methods: Specifies a pointer to a CacheMethods structure.\n%\n*/\nMagickPrivate void GetPixelCacheMethods(CacheMethods *cache_methods)\n{\n  assert(cache_methods != (CacheMethods *) NULL);\n  (void) ResetMagickMemory(cache_methods,0,sizeof(*cache_methods));\n  cache_methods->get_virtual_pixel_handler=GetVirtualPixelCache;\n  cache_methods->get_virtual_pixels_handler=GetVirtualPixelsCache;\n  cache_methods->get_virtual_metacontent_from_handler=\n    GetVirtualMetacontentFromCache;\n  cache_methods->get_one_virtual_pixel_from_handler=GetOneVirtualPixelFromCache;\n  cache_methods->get_authentic_pixels_handler=GetAuthenticPixelsCache;\n  cache_methods->get_authentic_metacontent_from_handler=\n    GetAuthenticMetacontentFromCache;\n  cache_methods->get_authentic_pixels_from_handler=GetAuthenticPixelsFromCache;\n  cache_methods->get_one_authentic_pixel_from_handler=\n    GetOneAuthenticPixelFromCache;\n  cache_methods->queue_authentic_pixels_handler=QueueAuthenticPixelsCache;\n  cache_methods->sync_authentic_pixels_handler=SyncAuthenticPixelsCache;\n  cache_methods->destroy_pixel_handler=DestroyImagePixelCache;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t P i x e l C a c h e N e x u s E x t e n t                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetPixelCacheNexusExtent() returns the extent of the pixels associated\n%  corresponding with the last call to SetPixelCacheNexusPixels() or\n%  GetPixelCacheNexusPixels().\n%\n%  The format of the GetPixelCacheNexusExtent() method is:\n%\n%      MagickSizeType GetPixelCacheNexusExtent(const Cache cache,\n%        NexusInfo *nexus_info)\n%\n%  A description of each parameter follows:\n%\n%    o nexus_info: the nexus info.\n%\n*/\nMagickPrivate MagickSizeType GetPixelCacheNexusExtent(const Cache cache,\n  NexusInfo *magick_restrict nexus_info)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  MagickSizeType\n    extent;\n\n  assert(cache != NULL);\n  cache_info=(CacheInfo *) cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  extent=(MagickSizeType) nexus_info->region.width*nexus_info->region.height;\n  if (extent == 0)\n    return((MagickSizeType) cache_info->columns*cache_info->rows);\n  return(extent);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t P i x e l C a c h e P i x e l s                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetPixelCachePixels() returns the pixels associated with the specified image.\n%\n%  The format of the GetPixelCachePixels() method is:\n%\n%      void *GetPixelCachePixels(Image *image,MagickSizeType *length,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o length: the pixel cache length.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickPrivate void *GetPixelCachePixels(Image *image,MagickSizeType *length,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  assert(length != (MagickSizeType *) NULL);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  *length=0;\n  if ((cache_info->type != MemoryCache) && (cache_info->type != MapCache))\n    return((void *) NULL);\n  *length=cache_info->length;\n  return((void *) cache_info->pixels);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t P i x e l C a c h e S t o r a g e C l a s s                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetPixelCacheStorageClass() returns the class type of the pixel cache.\n%\n%  The format of the GetPixelCacheStorageClass() method is:\n%\n%      ClassType GetPixelCacheStorageClass(Cache cache)\n%\n%  A description of each parameter follows:\n%\n%    o type: GetPixelCacheStorageClass returns DirectClass or PseudoClass.\n%\n%    o cache: the pixel cache.\n%\n*/\nMagickPrivate ClassType GetPixelCacheStorageClass(const Cache cache)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  assert(cache != (Cache) NULL);\n  cache_info=(CacheInfo *) cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  if (cache_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      cache_info->filename);\n  return(cache_info->storage_class);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t P i x e l C a c h e T i l e S i z e                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetPixelCacheTileSize() returns the pixel cache tile size.\n%\n%  The format of the GetPixelCacheTileSize() method is:\n%\n%      void GetPixelCacheTileSize(const Image *image,size_t *width,\n%        size_t *height)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o width: the optimize cache tile width in pixels.\n%\n%    o height: the optimize cache tile height in pixels.\n%\n*/\nMagickPrivate void GetPixelCacheTileSize(const Image *image,size_t *width,\n  size_t *height)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  *width=2048UL/(cache_info->number_channels*sizeof(Quantum));\n  if (GetImagePixelCacheType(image) == DiskCache)\n    *width=8192UL/(cache_info->number_channels*sizeof(Quantum));\n  *height=(*width);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t P i x e l C a c h e V i r t u a l M e t h o d                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetPixelCacheVirtualMethod() gets the \"virtual pixels\" method for the\n%  pixel cache.  A virtual pixel is any pixel access that is outside the\n%  boundaries of the image cache.\n%\n%  The format of the GetPixelCacheVirtualMethod() method is:\n%\n%      VirtualPixelMethod GetPixelCacheVirtualMethod(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickPrivate VirtualPixelMethod GetPixelCacheVirtualMethod(const Image *image)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  return(cache_info->virtual_pixel_method);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t V i r t u a l M e t a c o n t e n t F r o m C a c h e               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetVirtualMetacontentFromCache() returns the meta-content corresponding with\n%  the last call to QueueAuthenticPixelsCache() or GetVirtualPixelCache().\n%\n%  The format of the GetVirtualMetacontentFromCache() method is:\n%\n%      void *GetVirtualMetacontentFromCache(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nstatic const void *GetVirtualMetacontentFromCache(const Image *image)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  const void\n    *magick_restrict metacontent;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  assert(id < (int) cache_info->number_threads);\n  metacontent=GetVirtualMetacontentFromNexus(cache_info,\n    cache_info->nexus_info[id]);\n  return(metacontent);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t V i r t u a l M e t a c o n t e n t F r o m N e x u s               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetVirtualMetacontentFromNexus() returns the meta-content for the specified\n%  cache nexus.\n%\n%  The format of the GetVirtualMetacontentFromNexus() method is:\n%\n%      const void *GetVirtualMetacontentFromNexus(const Cache cache,\n%        NexusInfo *nexus_info)\n%\n%  A description of each parameter follows:\n%\n%    o cache: the pixel cache.\n%\n%    o nexus_info: the cache nexus to return the meta-content.\n%\n*/\nMagickPrivate const void *GetVirtualMetacontentFromNexus(const Cache cache,\n  NexusInfo *magick_restrict nexus_info)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  assert(cache != (Cache) NULL);\n  cache_info=(CacheInfo *) cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  if (cache_info->storage_class == UndefinedClass)\n    return((void *) NULL);\n  return(nexus_info->metacontent);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t V i r t u a l M e t a c o n t e n t                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetVirtualMetacontent() returns the virtual metacontent corresponding with\n%  the last call to QueueAuthenticPixels() or GetVirtualPixels().  NULL is\n%  returned if the meta-content are not available.\n%\n%  The format of the GetVirtualMetacontent() method is:\n%\n%      const void *GetVirtualMetacontent(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport const void *GetVirtualMetacontent(const Image *image)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  const void\n    *magick_restrict metacontent;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  metacontent=cache_info->methods.get_virtual_metacontent_from_handler(image);\n  if (metacontent != (void *) NULL)\n    return(metacontent);\n  assert(id < (int) cache_info->number_threads);\n  metacontent=GetVirtualMetacontentFromNexus(cache_info,\n    cache_info->nexus_info[id]);\n  return(metacontent);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t V i r t u a l P i x e l s F r o m N e x u s                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetVirtualPixelsFromNexus() gets virtual pixels from the in-memory or disk\n%  pixel cache as defined by the geometry parameters.   A pointer to the pixels\n%  is returned if the pixels are transferred, otherwise a NULL is returned.\n%\n%  The format of the GetVirtualPixelsFromNexus() method is:\n%\n%      Quantum *GetVirtualPixelsFromNexus(const Image *image,\n%        const VirtualPixelMethod method,const ssize_t x,const ssize_t y,\n%        const size_t columns,const size_t rows,NexusInfo *nexus_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o virtual_pixel_method: the virtual pixel method.\n%\n%    o x,y,columns,rows:  These values define the perimeter of a region of\n%      pixels.\n%\n%    o nexus_info: the cache nexus to acquire.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic ssize_t\n  DitherMatrix[64] =\n  {\n     0,  48,  12,  60,   3,  51,  15,  63,\n    32,  16,  44,  28,  35,  19,  47,  31,\n     8,  56,   4,  52,  11,  59,   7,  55,\n    40,  24,  36,  20,  43,  27,  39,  23,\n     2,  50,  14,  62,   1,  49,  13,  61,\n    34,  18,  46,  30,  33,  17,  45,  29,\n    10,  58,   6,  54,   9,  57,   5,  53,\n    42,  26,  38,  22,  41,  25,  37,  21\n  };\n\nstatic inline ssize_t DitherX(const ssize_t x,const size_t columns)\n{\n  ssize_t\n    index;\n\n  index=x+DitherMatrix[x & 0x07]-32L;\n  if (index < 0L)\n    return(0L);\n  if (index >= (ssize_t) columns)\n    return((ssize_t) columns-1L);\n  return(index);\n}\n\nstatic inline ssize_t DitherY(const ssize_t y,const size_t rows)\n{\n  ssize_t\n    index;\n\n  index=y+DitherMatrix[y & 0x07]-32L;\n  if (index < 0L)\n    return(0L);\n  if (index >= (ssize_t) rows)\n    return((ssize_t) rows-1L);\n  return(index);\n}\n\nstatic inline ssize_t EdgeX(const ssize_t x,const size_t columns)\n{\n  if (x < 0L)\n    return(0L);\n  if (x >= (ssize_t) columns)\n    return((ssize_t) (columns-1));\n  return(x);\n}\n\nstatic inline ssize_t EdgeY(const ssize_t y,const size_t rows)\n{\n  if (y < 0L)\n    return(0L);\n  if (y >= (ssize_t) rows)\n    return((ssize_t) (rows-1));\n  return(y);\n}\n\nstatic inline ssize_t RandomX(RandomInfo *random_info,const size_t columns)\n{\n  return((ssize_t) (columns*GetPseudoRandomValue(random_info)));\n}\n\nstatic inline ssize_t RandomY(RandomInfo *random_info,const size_t rows)\n{\n  return((ssize_t) (rows*GetPseudoRandomValue(random_info)));\n}\n\nstatic inline MagickModulo VirtualPixelModulo(const ssize_t offset,\n  const size_t extent)\n{\n  MagickModulo\n    modulo;\n\n  /*\n    Compute the remainder of dividing offset by extent.  It returns not only\n    the quotient (tile the offset falls in) but also the positive remainer\n    within that tile such that 0 <= remainder < extent.  This method is\n    essentially a ldiv() using a floored modulo division rather than the\n    normal default truncated modulo division.\n  */\n  modulo.quotient=offset/(ssize_t) extent;\n  if (offset < 0L)\n    modulo.quotient--;\n  modulo.remainder=offset-modulo.quotient*(ssize_t) extent;\n  return(modulo);\n}\n\nMagickPrivate const Quantum *GetVirtualPixelsFromNexus(const Image *image,\n  const VirtualPixelMethod virtual_pixel_method,const ssize_t x,const ssize_t y,\n  const size_t columns,const size_t rows,NexusInfo *nexus_info,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  MagickOffsetType\n    offset;\n\n  MagickSizeType\n    length,\n    number_pixels;\n\n  NexusInfo\n    **magick_restrict virtual_nexus;\n\n  Quantum\n    *magick_restrict pixels,\n    virtual_pixel[MaxPixelChannels];\n\n  RectangleInfo\n    region;\n\n  register const Quantum\n    *magick_restrict p;\n\n  register const void\n    *magick_restrict r;\n\n  register Quantum\n    *magick_restrict q;\n\n  register ssize_t\n    i,\n    u;\n\n  register unsigned char\n    *magick_restrict s;\n\n  ssize_t\n    v;\n\n  void\n    *magick_restrict virtual_metacontent;\n\n  /*\n    Acquire pixels.\n  */\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  if (cache_info->type == UndefinedCache)\n    return((const Quantum *) NULL);\n  region.x=x;\n  region.y=y;\n  region.width=columns;\n  region.height=rows;\n  pixels=SetPixelCacheNexusPixels(cache_info,ReadMode,&region,nexus_info,\n    exception);\n  if (pixels == (Quantum *) NULL)\n    return((const Quantum *) NULL);\n  q=pixels;\n  offset=(MagickOffsetType) nexus_info->region.y*cache_info->columns+\n    nexus_info->region.x;\n  length=(MagickSizeType) (nexus_info->region.height-1L)*cache_info->columns+\n    nexus_info->region.width-1L;\n  number_pixels=(MagickSizeType) cache_info->columns*cache_info->rows;\n  if ((offset >= 0) && (((MagickSizeType) offset+length) < number_pixels))\n    if ((x >= 0) && ((ssize_t) (x+columns) <= (ssize_t) cache_info->columns) &&\n        (y >= 0) && ((ssize_t) (y+rows) <= (ssize_t) cache_info->rows))\n      {\n        MagickBooleanType\n          status;\n\n        /*\n          Pixel request is inside cache extents.\n        */\n        if (nexus_info->authentic_pixel_cache != MagickFalse)\n          return(q);\n        status=ReadPixelCachePixels(cache_info,nexus_info,exception);\n        if (status == MagickFalse)\n          return((const Quantum *) NULL);\n        if (cache_info->metacontent_extent != 0)\n          {\n            status=ReadPixelCacheMetacontent(cache_info,nexus_info,exception);\n            if (status == MagickFalse)\n              return((const Quantum *) NULL);\n          }\n        return(q);\n      }\n  /*\n    Pixel request is outside cache extents.\n  */\n  s=(unsigned char *) nexus_info->metacontent;\n  virtual_nexus=AcquirePixelCacheNexus(1);\n  if (virtual_nexus == (NexusInfo **) NULL)\n    {\n      if (virtual_nexus != (NexusInfo **) NULL)\n        virtual_nexus=DestroyPixelCacheNexus(virtual_nexus,1);\n      (void) ThrowMagickException(exception,GetMagickModule(),CacheError,\n        \"UnableToGetCacheNexus\",\"`%s'\",image->filename);\n      return((const Quantum *) NULL);\n    }\n  (void) ResetMagickMemory(virtual_pixel,0,cache_info->number_channels*\n    sizeof(*virtual_pixel));\n  virtual_metacontent=(void *) NULL;\n  switch (virtual_pixel_method)\n  {\n    case BackgroundVirtualPixelMethod:\n    case BlackVirtualPixelMethod:\n    case GrayVirtualPixelMethod:\n    case TransparentVirtualPixelMethod:\n    case MaskVirtualPixelMethod:\n    case WhiteVirtualPixelMethod:\n    case EdgeVirtualPixelMethod:\n    case CheckerTileVirtualPixelMethod:\n    case HorizontalTileVirtualPixelMethod:\n    case VerticalTileVirtualPixelMethod:\n    {\n      if (cache_info->metacontent_extent != 0)\n        {\n          /*\n            Acquire a metacontent buffer.\n          */\n          virtual_metacontent=(void *) AcquireQuantumMemory(1,\n            cache_info->metacontent_extent);\n          if (virtual_metacontent == (void *) NULL)\n            {\n              virtual_nexus=DestroyPixelCacheNexus(virtual_nexus,1);\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CacheError,\"UnableToGetCacheNexus\",\"`%s'\",image->filename);\n              return((const Quantum *) NULL);\n            }\n          (void) ResetMagickMemory(virtual_metacontent,0,\n            cache_info->metacontent_extent);\n        }\n      switch (virtual_pixel_method)\n      {\n        case BlackVirtualPixelMethod:\n        {\n          for (i=0; i < (ssize_t) cache_info->number_channels; i++)\n            SetPixelChannel(image,(PixelChannel) i,0,virtual_pixel);\n          SetPixelAlpha(image,OpaqueAlpha,virtual_pixel);\n          break;\n        }\n        case GrayVirtualPixelMethod:\n        {\n          for (i=0; i < (ssize_t) cache_info->number_channels; i++)\n            SetPixelChannel(image,(PixelChannel) i,QuantumRange/2,\n              virtual_pixel);\n          SetPixelAlpha(image,OpaqueAlpha,virtual_pixel);\n          break;\n        }\n        case TransparentVirtualPixelMethod:\n        {\n          for (i=0; i < (ssize_t) cache_info->number_channels; i++)\n            SetPixelChannel(image,(PixelChannel) i,0,virtual_pixel);\n          SetPixelAlpha(image,TransparentAlpha,virtual_pixel);\n          break;\n        }\n        case MaskVirtualPixelMethod:\n        case WhiteVirtualPixelMethod:\n        {\n          for (i=0; i < (ssize_t) cache_info->number_channels; i++)\n            SetPixelChannel(image,(PixelChannel) i,QuantumRange,virtual_pixel);\n          SetPixelAlpha(image,OpaqueAlpha,virtual_pixel);\n          break;\n        }\n        default:\n        {\n          SetPixelRed(image,ClampToQuantum(image->background_color.red),\n            virtual_pixel);\n          SetPixelGreen(image,ClampToQuantum(image->background_color.green),\n            virtual_pixel);\n          SetPixelBlue(image,ClampToQuantum(image->background_color.blue),\n            virtual_pixel);\n          SetPixelBlack(image,ClampToQuantum(image->background_color.black),\n            virtual_pixel);\n          SetPixelAlpha(image,ClampToQuantum(image->background_color.alpha),\n            virtual_pixel);\n          break;\n        }\n      }\n      break;\n    }\n    default:\n      break;\n  }\n  for (v=0; v < (ssize_t) rows; v++)\n  {\n    ssize_t\n      y_offset;\n\n    y_offset=y+v;\n    if ((virtual_pixel_method == EdgeVirtualPixelMethod) ||\n        (virtual_pixel_method == UndefinedVirtualPixelMethod))\n      y_offset=EdgeY(y_offset,cache_info->rows);\n    for (u=0; u < (ssize_t) columns; u+=length)\n    {\n      ssize_t\n        x_offset;\n\n      x_offset=x+u;\n      length=(MagickSizeType) MagickMin(cache_info->columns-x_offset,columns-u);\n      if (((x_offset < 0) || (x_offset >= (ssize_t) cache_info->columns)) ||\n          ((y_offset < 0) || (y_offset >= (ssize_t) cache_info->rows)) ||\n          (length == 0))\n        {\n          MagickModulo\n            x_modulo,\n            y_modulo;\n\n          /*\n            Transfer a single pixel.\n          */\n          length=(MagickSizeType) 1;\n          switch (virtual_pixel_method)\n          {\n            case EdgeVirtualPixelMethod:\n            default:\n            {\n              p=GetVirtualPixelsFromNexus(image,virtual_pixel_method,\n                EdgeX(x_offset,cache_info->columns),\n                EdgeY(y_offset,cache_info->rows),1UL,1UL,*virtual_nexus,\n                exception);\n              r=GetVirtualMetacontentFromNexus(cache_info,*virtual_nexus);\n              break;\n            }\n            case RandomVirtualPixelMethod:\n            {\n              if (cache_info->random_info == (RandomInfo *) NULL)\n                cache_info->random_info=AcquireRandomInfo();\n              p=GetVirtualPixelsFromNexus(image,virtual_pixel_method,\n                RandomX(cache_info->random_info,cache_info->columns),\n                RandomY(cache_info->random_info,cache_info->rows),1UL,1UL,\n                *virtual_nexus,exception);\n              r=GetVirtualMetacontentFromNexus(cache_info,*virtual_nexus);\n              break;\n            }\n            case DitherVirtualPixelMethod:\n            {\n              p=GetVirtualPixelsFromNexus(image,virtual_pixel_method,\n                DitherX(x_offset,cache_info->columns),\n                DitherY(y_offset,cache_info->rows),1UL,1UL,*virtual_nexus,\n                exception);\n              r=GetVirtualMetacontentFromNexus(cache_info,*virtual_nexus);\n              break;\n            }\n            case TileVirtualPixelMethod:\n            {\n              x_modulo=VirtualPixelModulo(x_offset,cache_info->columns);\n              y_modulo=VirtualPixelModulo(y_offset,cache_info->rows);\n              p=GetVirtualPixelsFromNexus(image,virtual_pixel_method,\n                x_modulo.remainder,y_modulo.remainder,1UL,1UL,*virtual_nexus,\n                exception);\n              r=GetVirtualMetacontentFromNexus(cache_info,*virtual_nexus);\n              break;\n            }\n            case MirrorVirtualPixelMethod:\n            {\n              x_modulo=VirtualPixelModulo(x_offset,cache_info->columns);\n              if ((x_modulo.quotient & 0x01) == 1L)\n                x_modulo.remainder=(ssize_t) cache_info->columns-\n                  x_modulo.remainder-1L;\n              y_modulo=VirtualPixelModulo(y_offset,cache_info->rows);\n              if ((y_modulo.quotient & 0x01) == 1L)\n                y_modulo.remainder=(ssize_t) cache_info->rows-\n                  y_modulo.remainder-1L;\n              p=GetVirtualPixelsFromNexus(image,virtual_pixel_method,\n                x_modulo.remainder,y_modulo.remainder,1UL,1UL,*virtual_nexus,\n                exception);\n              r=GetVirtualMetacontentFromNexus(cache_info,*virtual_nexus);\n              break;\n            }\n            case HorizontalTileEdgeVirtualPixelMethod:\n            {\n              x_modulo=VirtualPixelModulo(x_offset,cache_info->columns);\n              p=GetVirtualPixelsFromNexus(image,virtual_pixel_method,\n                x_modulo.remainder,EdgeY(y_offset,cache_info->rows),1UL,1UL,\n                *virtual_nexus,exception);\n              r=GetVirtualMetacontentFromNexus(cache_info,*virtual_nexus);\n              break;\n            }\n            case VerticalTileEdgeVirtualPixelMethod:\n            {\n              y_modulo=VirtualPixelModulo(y_offset,cache_info->rows);\n              p=GetVirtualPixelsFromNexus(image,virtual_pixel_method,\n                EdgeX(x_offset,cache_info->columns),y_modulo.remainder,1UL,1UL,\n                *virtual_nexus,exception);\n              r=GetVirtualMetacontentFromNexus(cache_info,*virtual_nexus);\n              break;\n            }\n            case BackgroundVirtualPixelMethod:\n            case BlackVirtualPixelMethod:\n            case GrayVirtualPixelMethod:\n            case TransparentVirtualPixelMethod:\n            case MaskVirtualPixelMethod:\n            case WhiteVirtualPixelMethod:\n            {\n              p=virtual_pixel;\n              r=virtual_metacontent;\n              break;\n            }\n            case CheckerTileVirtualPixelMethod:\n            {\n              x_modulo=VirtualPixelModulo(x_offset,cache_info->columns);\n              y_modulo=VirtualPixelModulo(y_offset,cache_info->rows);\n              if (((x_modulo.quotient ^ y_modulo.quotient) & 0x01) != 0L)\n                {\n                  p=virtual_pixel;\n                  r=virtual_metacontent;\n                  break;\n                }\n              p=GetVirtualPixelsFromNexus(image,virtual_pixel_method,\n                x_modulo.remainder,y_modulo.remainder,1UL,1UL,*virtual_nexus,\n                exception);\n              r=GetVirtualMetacontentFromNexus(cache_info,*virtual_nexus);\n              break;\n            }\n            case HorizontalTileVirtualPixelMethod:\n            {\n              if ((y_offset < 0) || (y_offset >= (ssize_t) cache_info->rows))\n                {\n                  p=virtual_pixel;\n                  r=virtual_metacontent;\n                  break;\n                }\n              x_modulo=VirtualPixelModulo(x_offset,cache_info->columns);\n              y_modulo=VirtualPixelModulo(y_offset,cache_info->rows);\n              p=GetVirtualPixelsFromNexus(image,virtual_pixel_method,\n                x_modulo.remainder,y_modulo.remainder,1UL,1UL,*virtual_nexus,\n                exception);\n              r=GetVirtualMetacontentFromNexus(cache_info,*virtual_nexus);\n              break;\n            }\n            case VerticalTileVirtualPixelMethod:\n            {\n              if ((x_offset < 0) || (x_offset >= (ssize_t) cache_info->columns))\n                {\n                  p=virtual_pixel;\n                  r=virtual_metacontent;\n                  break;\n                }\n              x_modulo=VirtualPixelModulo(x_offset,cache_info->columns);\n              y_modulo=VirtualPixelModulo(y_offset,cache_info->rows);\n              p=GetVirtualPixelsFromNexus(image,virtual_pixel_method,\n                x_modulo.remainder,y_modulo.remainder,1UL,1UL,*virtual_nexus,\n                exception);\n              r=GetVirtualMetacontentFromNexus(cache_info,*virtual_nexus);\n              break;\n            }\n          }\n          if (p == (const Quantum *) NULL)\n            break;\n          (void) memcpy(q,p,(size_t) length*cache_info->number_channels*\n            sizeof(*p));\n          q+=cache_info->number_channels;\n          if ((s != (void *) NULL) && (r != (const void *) NULL))\n            {\n              (void) memcpy(s,r,(size_t) cache_info->metacontent_extent);\n              s+=cache_info->metacontent_extent;\n            }\n          continue;\n        }\n      /*\n        Transfer a run of pixels.\n      */\n      p=GetVirtualPixelsFromNexus(image,virtual_pixel_method,x_offset,y_offset,\n        (size_t) length,1UL,*virtual_nexus,exception);\n      if (p == (const Quantum *) NULL)\n        break;\n      r=GetVirtualMetacontentFromNexus(cache_info,*virtual_nexus);\n      (void) memcpy(q,p,(size_t) length*cache_info->number_channels*sizeof(*p));\n      q+=length*cache_info->number_channels;\n      if ((r != (void *) NULL) && (s != (const void *) NULL))\n        {\n          (void) memcpy(s,r,(size_t) length);\n          s+=length*cache_info->metacontent_extent;\n        }\n    }\n    if (u < (ssize_t) columns)\n      break;\n  }\n  /*\n    Free resources.\n  */\n  if (virtual_metacontent != (void *) NULL)\n    virtual_metacontent=(void *) RelinquishMagickMemory(virtual_metacontent);\n  virtual_nexus=DestroyPixelCacheNexus(virtual_nexus,1);\n  if (v < (ssize_t) rows)\n    return((const Quantum *) NULL);\n  return(pixels);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t V i r t u a l P i x e l C a c h e                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetVirtualPixelCache() get virtual pixels from the in-memory or disk pixel\n%  cache as defined by the geometry parameters.   A pointer to the pixels\n%  is returned if the pixels are transferred, otherwise a NULL is returned.\n%\n%  The format of the GetVirtualPixelCache() method is:\n%\n%      const Quantum *GetVirtualPixelCache(const Image *image,\n%        const VirtualPixelMethod virtual_pixel_method,const ssize_t x,\n%        const ssize_t y,const size_t columns,const size_t rows,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o virtual_pixel_method: the virtual pixel method.\n%\n%    o x,y,columns,rows:  These values define the perimeter of a region of\n%      pixels.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic const Quantum *GetVirtualPixelCache(const Image *image,\n  const VirtualPixelMethod virtual_pixel_method,const ssize_t x,const ssize_t y,\n  const size_t columns,const size_t rows,ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  const Quantum\n    *magick_restrict p;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  assert(id < (int) cache_info->number_threads);\n  p=GetVirtualPixelsFromNexus(image,virtual_pixel_method,x,y,columns,rows,\n    cache_info->nexus_info[id],exception);\n  return(p);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t V i r t u a l P i x e l Q u e u e                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetVirtualPixelQueue() returns the virtual pixels associated corresponding\n%  with the last call to QueueAuthenticPixels() or GetVirtualPixels().\n%\n%  The format of the GetVirtualPixelQueue() method is:\n%\n%      const Quantum *GetVirtualPixelQueue(const Image image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport const Quantum *GetVirtualPixelQueue(const Image *image)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  if (cache_info->methods.get_virtual_pixels_handler !=\n       (GetVirtualPixelsHandler) NULL)\n    return(cache_info->methods.get_virtual_pixels_handler(image));\n  assert(id < (int) cache_info->number_threads);\n  return(GetVirtualPixelsNexus(cache_info,cache_info->nexus_info[id]));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t V i r t u a l P i x e l s                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetVirtualPixels() returns an immutable pixel region. If the\n%  region is successfully accessed, a pointer to it is returned, otherwise\n%  NULL is returned.  The returned pointer may point to a temporary working\n%  copy of the pixels or it may point to the original pixels in memory.\n%  Performance is maximized if the selected region is part of one row, or one\n%  or more full rows, since there is opportunity to access the pixels in-place\n%  (without a copy) if the image is in memory, or in a memory-mapped file.  The\n%  returned pointer must *never* be deallocated by the user.\n%\n%  Pixels accessed via the returned pointer represent a simple array of type\n%  Quantum.  If the image type is CMYK or the storage class is PseudoClass,\n%  call GetAuthenticMetacontent() after invoking GetAuthenticPixels() to\n%  access the meta-content (of type void) corresponding to the the\n%  region.\n%\n%  If you plan to modify the pixels, use GetAuthenticPixels() instead.\n%\n%  Note, the GetVirtualPixels() and GetAuthenticPixels() methods are not thread-\n%  safe.  In a threaded environment, use GetCacheViewVirtualPixels() or\n%  GetCacheViewAuthenticPixels() instead.\n%\n%  The format of the GetVirtualPixels() method is:\n%\n%      const Quantum *GetVirtualPixels(const Image *image,const ssize_t x,\n%        const ssize_t y,const size_t columns,const size_t rows,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o x,y,columns,rows:  These values define the perimeter of a region of\n%      pixels.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport const Quantum *GetVirtualPixels(const Image *image,\n  const ssize_t x,const ssize_t y,const size_t columns,const size_t rows,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  const Quantum\n    *magick_restrict p;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  if (cache_info->methods.get_virtual_pixel_handler !=\n       (GetVirtualPixelHandler) NULL)\n    return(cache_info->methods.get_virtual_pixel_handler(image,\n      GetPixelCacheVirtualMethod(image),x,y,columns,rows,exception));\n  assert(id < (int) cache_info->number_threads);\n  p=GetVirtualPixelsFromNexus(image,GetPixelCacheVirtualMethod(image),x,y,\n    columns,rows,cache_info->nexus_info[id],exception);\n  return(p);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t V i r t u a l P i x e l s F r o m C a c h e                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetVirtualPixelsCache() returns the pixels associated corresponding with the\n%  last call to QueueAuthenticPixelsCache() or GetVirtualPixelCache().\n%\n%  The format of the GetVirtualPixelsCache() method is:\n%\n%      Quantum *GetVirtualPixelsCache(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nstatic const Quantum *GetVirtualPixelsCache(const Image *image)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  assert(id < (int) cache_info->number_threads);\n  return(GetVirtualPixelsNexus(image->cache,cache_info->nexus_info[id]));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t V i r t u a l P i x e l s N e x u s                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetVirtualPixelsNexus() returns the pixels associated with the specified\n%  cache nexus.\n%\n%  The format of the GetVirtualPixelsNexus() method is:\n%\n%      const Quantum *GetVirtualPixelsNexus(const Cache cache,\n%        NexusInfo *nexus_info)\n%\n%  A description of each parameter follows:\n%\n%    o cache: the pixel cache.\n%\n%    o nexus_info: the cache nexus to return the colormap pixels.\n%\n*/\nMagickPrivate const Quantum *GetVirtualPixelsNexus(const Cache cache,\n  NexusInfo *magick_restrict nexus_info)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  assert(cache != (Cache) NULL);\n  cache_info=(CacheInfo *) cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  if (cache_info->storage_class == UndefinedClass)\n    return((Quantum *) NULL);\n  return((const Quantum *) nexus_info->pixels);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   O p e n P i x e l C a c h e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  OpenPixelCache() allocates the pixel cache.  This includes defining the cache\n%  dimensions, allocating space for the image pixels and optionally the\n%  metacontent, and memory mapping the cache if it is disk based.  The cache\n%  nexus array is initialized as well.\n%\n%  The format of the OpenPixelCache() method is:\n%\n%      MagickBooleanType OpenPixelCache(Image *image,const MapMode mode,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o mode: ReadMode, WriteMode, or IOMode.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\n#if defined(SIGBUS)\nstatic void CacheSignalHandler(int status)\n{\n  ThrowFatalException(CacheFatalError,\"UnableToExtendPixelCache\");\n}\n#endif\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\nstatic MagickBooleanType OpenPixelCacheOnDisk(CacheInfo *cache_info,\n  const MapMode mode)\n{\n  int\n    file;\n\n  /*\n    Open pixel cache on disk.\n  */\n  if ((cache_info->file != -1) && (cache_info->mode == mode))\n    return(MagickTrue);  /* cache already open and in the proper mode */\n  if (*cache_info->cache_filename == '\\0')\n    file=AcquireUniqueFileResource(cache_info->cache_filename);\n  else\n    switch (mode)\n    {\n      case ReadMode:\n      {\n        file=open_utf8(cache_info->cache_filename,O_RDONLY | O_BINARY,0);\n        break;\n      }\n      case WriteMode:\n      {\n        file=open_utf8(cache_info->cache_filename,O_WRONLY | O_CREAT |\n          O_BINARY | O_EXCL,S_MODE);\n        if (file == -1)\n          file=open_utf8(cache_info->cache_filename,O_WRONLY | O_BINARY,S_MODE);\n        break;\n      }\n      case IOMode:\n      default:\n      {\n        file=open_utf8(cache_info->cache_filename,O_RDWR | O_CREAT | O_BINARY |\n          O_EXCL,S_MODE);\n        if (file == -1)\n          file=open_utf8(cache_info->cache_filename,O_RDWR | O_BINARY,S_MODE);\n        break;\n      }\n    }\n  if (file == -1)\n    return(MagickFalse);\n  (void) AcquireMagickResource(FileResource,1);\n  if (cache_info->file != -1)\n    (void) ClosePixelCacheOnDisk(cache_info);\n  cache_info->file=file;\n  cache_info->mode=mode;\n  return(MagickTrue);\n}\n\nstatic inline MagickOffsetType WritePixelCacheRegion(\n  const CacheInfo *magick_restrict cache_info,const MagickOffsetType offset,\n  const MagickSizeType length,const unsigned char *magick_restrict buffer)\n{\n  register MagickOffsetType\n    i;\n\n  ssize_t\n    count;\n\n#if !defined(MAGICKCORE_HAVE_PWRITE)\n  if (lseek(cache_info->file,offset,SEEK_SET) < 0)\n    return((MagickOffsetType) -1);\n#endif\n  count=0;\n  for (i=0; i < (MagickOffsetType) length; i+=count)\n  {\n#if !defined(MAGICKCORE_HAVE_PWRITE)\n    count=write(cache_info->file,buffer+i,(size_t) MagickMin(length-i,(size_t)\n      SSIZE_MAX));\n#else\n    count=pwrite(cache_info->file,buffer+i,(size_t) MagickMin(length-i,(size_t)\n      SSIZE_MAX),(off_t) (offset+i));\n#endif\n    if (count <= 0)\n      {\n        count=0;\n        if (errno != EINTR)\n          break;\n      }\n  }\n  return(i);\n}\n\nstatic MagickBooleanType SetPixelCacheExtent(Image *image,MagickSizeType length)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  MagickOffsetType\n    count,\n    extent,\n    offset;\n\n  cache_info=(CacheInfo *) image->cache;\n  if (image->debug != MagickFalse)\n    {\n      char\n        format[MagickPathExtent],\n        message[MagickPathExtent];\n\n      (void) FormatMagickSize(length,MagickFalse,\"B\",MagickPathExtent,format);\n      (void) FormatLocaleString(message,MagickPathExtent,\n        \"extend %s (%s[%d], disk, %s)\",cache_info->filename,\n        cache_info->cache_filename,cache_info->file,format);\n      (void) LogMagickEvent(CacheEvent,GetMagickModule(),\"%s\",message);\n    }\n  if (length != (MagickSizeType) ((MagickOffsetType) length))\n    return(MagickFalse);\n  offset=(MagickOffsetType) lseek(cache_info->file,0,SEEK_END);\n  if (offset < 0)\n    return(MagickFalse);\n  if ((MagickSizeType) offset >= length)\n    count=(MagickOffsetType) 1;\n  else\n    {\n      extent=(MagickOffsetType) length-1;\n      count=WritePixelCacheRegion(cache_info,extent,1,(const unsigned char *)\n        \"\");\n#if defined(MAGICKCORE_HAVE_POSIX_FALLOCATE)\n      if (cache_info->synchronize != MagickFalse)\n        (void) posix_fallocate(cache_info->file,offset+1,extent-offset);\n#endif\n#if defined(SIGBUS)\n      (void) signal(SIGBUS,CacheSignalHandler);\n#endif\n    }\n  offset=(MagickOffsetType) lseek(cache_info->file,0,SEEK_SET);\n  if (offset < 0)\n    return(MagickFalse);\n  return(count != (MagickOffsetType) 1 ? MagickFalse : MagickTrue);\n}\n\nstatic MagickBooleanType OpenPixelCache(Image *image,const MapMode mode,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info,\n    source_info;\n\n  char\n    format[MagickPathExtent],\n    message[MagickPathExtent];\n\n  const char\n    *type;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    length,\n    number_pixels;\n\n  size_t\n    columns,\n    packet_size;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if ((image->columns == 0) || (image->rows == 0))\n    ThrowBinaryException(CacheError,\"NoPixelsDefinedInCache\",image->filename);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  if ((AcquireMagickResource(WidthResource,image->columns) == MagickFalse) ||\n      (AcquireMagickResource(HeightResource,image->rows) == MagickFalse))\n    ThrowBinaryException(ImageError,\"WidthOrHeightExceedsLimit\",\n      image->filename);\n  source_info=(*cache_info);\n  source_info.file=(-1);\n  (void) FormatLocaleString(cache_info->filename,MagickPathExtent,\"%s[%.20g]\",\n    image->filename,(double) GetImageIndexInList(image));\n  cache_info->storage_class=image->storage_class;\n  cache_info->colorspace=image->colorspace;\n  cache_info->alpha_trait=image->alpha_trait;\n  cache_info->read_mask=image->read_mask;\n  cache_info->write_mask=image->write_mask;\n  cache_info->rows=image->rows;\n  cache_info->columns=image->columns;\n  InitializePixelChannelMap(image);\n  cache_info->number_channels=GetPixelChannels(image);\n  (void) memcpy(cache_info->channel_map,image->channel_map,MaxPixelChannels*\n    sizeof(*image->channel_map));\n  cache_info->metacontent_extent=image->metacontent_extent;\n  cache_info->mode=mode;\n  number_pixels=(MagickSizeType) cache_info->columns*cache_info->rows;\n  packet_size=cache_info->number_channels*sizeof(Quantum);\n  if (image->metacontent_extent != 0)\n    packet_size+=cache_info->metacontent_extent;\n  length=number_pixels*packet_size;\n  columns=(size_t) (length/cache_info->rows/packet_size);\n  if ((cache_info->columns != columns) || ((ssize_t) cache_info->columns < 0) ||\n      ((ssize_t) cache_info->rows < 0))\n    ThrowBinaryException(ResourceLimitError,\"PixelCacheAllocationFailed\",\n      image->filename);\n  cache_info->length=length;\n  if (image->ping != MagickFalse)\n    {\n      cache_info->storage_class=image->storage_class;\n      cache_info->colorspace=image->colorspace;\n      cache_info->type=PingCache;\n      return(MagickTrue);\n    }\n  status=AcquireMagickResource(AreaResource,cache_info->length);\n  length=number_pixels*(cache_info->number_channels*sizeof(Quantum)+\n    cache_info->metacontent_extent);\n  if ((status != MagickFalse) && (length == (MagickSizeType) ((size_t) length)))\n    {\n      status=AcquireMagickResource(MemoryResource,cache_info->length);\n      if (((cache_info->type == UndefinedCache) && (status != MagickFalse)) ||\n          (cache_info->type == MemoryCache))\n        {\n          cache_info->mapped=MagickFalse;\n          cache_info->pixels=(Quantum *) MagickAssumeAligned(\n            AcquireAlignedMemory(1,(size_t) cache_info->length));\n          if (cache_info->pixels == (Quantum *) NULL)\n            cache_info->pixels=source_info.pixels;\n          else\n            {\n              /*\n                Create memory pixel cache.\n              */\n              status=MagickTrue;\n              cache_info->type=MemoryCache;\n              cache_info->metacontent=(void *) NULL;\n              if (cache_info->metacontent_extent != 0)\n                cache_info->metacontent=(void *) (cache_info->pixels+\n                  number_pixels*cache_info->number_channels);\n              if ((source_info.storage_class != UndefinedClass) &&\n                  (mode != ReadMode))\n                {\n                  status=ClonePixelCacheRepository(cache_info,&source_info,\n                    exception);\n                  RelinquishPixelCachePixels(&source_info);\n                }\n              if (image->debug != MagickFalse)\n                {\n                  (void) FormatMagickSize(cache_info->length,MagickTrue,\"B\",\n                    MagickPathExtent,format);\n                  type=CommandOptionToMnemonic(MagickCacheOptions,(ssize_t)\n                    cache_info->type);\n                  (void) FormatLocaleString(message,MagickPathExtent,\n                    \"open %s (%s %s, %.20gx%.20gx%.20g %s)\",\n                    cache_info->filename,cache_info->mapped != MagickFalse ?\n                    \"Anonymous\" : \"Heap\",type,(double) cache_info->columns,\n                    (double) cache_info->rows,(double)\n                    cache_info->number_channels,format);\n                  (void) LogMagickEvent(CacheEvent,GetMagickModule(),\"%s\",\n                    message);\n                }\n              return(status);\n            }\n        }\n      RelinquishMagickResource(MemoryResource,cache_info->length);\n    }\n  /*\n    Create pixel cache on disk.\n  */\n  status=AcquireMagickResource(DiskResource,cache_info->length);\n  if ((status == MagickFalse) || (cache_info->type == DistributedCache))\n    {\n      DistributeCacheInfo\n        *server_info;\n\n      if (cache_info->type == DistributedCache)\n        RelinquishMagickResource(DiskResource,cache_info->length);\n      server_info=AcquireDistributeCacheInfo(exception);\n      if (server_info != (DistributeCacheInfo *) NULL)\n        {\n          status=OpenDistributePixelCache(server_info,image);\n          if (status == MagickFalse)\n            {\n              ThrowFileException(exception,CacheError,\"UnableToOpenPixelCache\",\n                GetDistributeCacheHostname(server_info));\n              server_info=DestroyDistributeCacheInfo(server_info);\n            }\n          else\n            {\n              /*\n                Create a distributed pixel cache.\n              */\n              cache_info->type=DistributedCache;\n              cache_info->server_info=server_info;\n              (void) FormatLocaleString(cache_info->cache_filename,\n                MagickPathExtent,\"%s:%d\",GetDistributeCacheHostname(\n                (DistributeCacheInfo *) cache_info->server_info),\n                GetDistributeCachePort((DistributeCacheInfo *)\n                cache_info->server_info));\n              if ((source_info.storage_class != UndefinedClass) &&\n                  (mode != ReadMode))\n                {\n                  status=ClonePixelCacheRepository(cache_info,&source_info,\n                    exception);\n                  RelinquishPixelCachePixels(&source_info);\n                }\n              if (image->debug != MagickFalse)\n                {\n                  (void) FormatMagickSize(cache_info->length,MagickFalse,\"B\",\n                    MagickPathExtent,format);\n                  type=CommandOptionToMnemonic(MagickCacheOptions,(ssize_t)\n                    cache_info->type);\n                  (void) FormatLocaleString(message,MagickPathExtent,\n                    \"open %s (%s[%d], %s, %.20gx%.20gx%.20g %s)\",\n                    cache_info->filename,cache_info->cache_filename,\n                    GetDistributeCacheFile((DistributeCacheInfo *)\n                    cache_info->server_info),type,(double) cache_info->columns,\n                    (double) cache_info->rows,(double)\n                    cache_info->number_channels,format);\n                  (void) LogMagickEvent(CacheEvent,GetMagickModule(),\"%s\",\n                    message);\n                }\n              return(MagickTrue);\n            }\n        }\n      RelinquishMagickResource(DiskResource,cache_info->length);\n      (void) ThrowMagickException(exception,GetMagickModule(),CacheError,\n        \"CacheResourcesExhausted\",\"`%s'\",image->filename);\n      return(MagickFalse);\n    }\n  if ((source_info.storage_class != UndefinedClass) && (mode != ReadMode))\n    {\n      (void) ClosePixelCacheOnDisk(cache_info);\n      *cache_info->cache_filename='\\0';\n    }\n  if (OpenPixelCacheOnDisk(cache_info,mode) == MagickFalse)\n    {\n      RelinquishMagickResource(DiskResource,cache_info->length);\n      ThrowFileException(exception,CacheError,\"UnableToOpenPixelCache\",\n        image->filename);\n      return(MagickFalse);\n    }\n  status=SetPixelCacheExtent(image,(MagickSizeType) cache_info->offset+\n    cache_info->length);\n  if (status == MagickFalse)\n    {\n      ThrowFileException(exception,CacheError,\"UnableToExtendCache\",\n        image->filename);\n      return(MagickFalse);\n    }\n  length=number_pixels*(cache_info->number_channels*sizeof(Quantum)+\n    cache_info->metacontent_extent);\n  if (length != (MagickSizeType) ((size_t) length))\n    cache_info->type=DiskCache;\n  else\n    {\n      status=AcquireMagickResource(MapResource,cache_info->length);\n      if ((status == MagickFalse) && (cache_info->type != MapCache) &&\n          (cache_info->type != MemoryCache))\n        cache_info->type=DiskCache;\n      else\n        {\n          cache_info->pixels=(Quantum *) MapBlob(cache_info->file,mode,\n            cache_info->offset,(size_t) cache_info->length);\n          if (cache_info->pixels == (Quantum *) NULL)\n            {\n              cache_info->type=DiskCache;\n              cache_info->pixels=source_info.pixels;\n            }\n          else\n            {\n              /*\n                Create file-backed memory-mapped pixel cache.\n              */\n              status=MagickTrue;\n              (void) ClosePixelCacheOnDisk(cache_info);\n              cache_info->type=MapCache;\n              cache_info->mapped=MagickTrue;\n              cache_info->metacontent=(void *) NULL;\n              if (cache_info->metacontent_extent != 0)\n                cache_info->metacontent=(void *) (cache_info->pixels+\n                  number_pixels*cache_info->number_channels);\n              if ((source_info.storage_class != UndefinedClass) &&\n                  (mode != ReadMode))\n                {\n                  status=ClonePixelCacheRepository(cache_info,&source_info,\n                    exception);\n                  RelinquishPixelCachePixels(&source_info);\n                }\n              if (image->debug != MagickFalse)\n                {\n                  (void) FormatMagickSize(cache_info->length,MagickTrue,\"B\",\n                    MagickPathExtent,format);\n                  type=CommandOptionToMnemonic(MagickCacheOptions,(ssize_t)\n                    cache_info->type);\n                  (void) FormatLocaleString(message,MagickPathExtent,\n                    \"open %s (%s[%d], %s, %.20gx%.20gx%.20g %s)\",\n                    cache_info->filename,cache_info->cache_filename,\n                    cache_info->file,type,(double) cache_info->columns,(double)\n                    cache_info->rows,(double) cache_info->number_channels,\n                    format);\n                  (void) LogMagickEvent(CacheEvent,GetMagickModule(),\"%s\",\n                    message);\n                }\n              return(status);\n            }\n        }\n      RelinquishMagickResource(MapResource,cache_info->length);\n    }\n  status=MagickTrue;\n  if ((source_info.storage_class != UndefinedClass) && (mode != ReadMode))\n    {\n      status=ClonePixelCacheRepository(cache_info,&source_info,exception);\n      RelinquishPixelCachePixels(&source_info);\n    }\n  if (image->debug != MagickFalse)\n    {\n      (void) FormatMagickSize(cache_info->length,MagickFalse,\"B\",\n        MagickPathExtent,format);\n      type=CommandOptionToMnemonic(MagickCacheOptions,(ssize_t)\n        cache_info->type);\n      (void) FormatLocaleString(message,MagickPathExtent,\n        \"open %s (%s[%d], %s, %.20gx%.20gx%.20g %s)\",cache_info->filename,\n        cache_info->cache_filename,cache_info->file,type,(double)\n        cache_info->columns,(double) cache_info->rows,(double)\n        cache_info->number_channels,format);\n      (void) LogMagickEvent(CacheEvent,GetMagickModule(),\"%s\",message);\n    }\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   P e r s i s t P i x e l C a c h e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  PersistPixelCache() attaches to or initializes a persistent pixel cache.  A\n%  persistent pixel cache is one that resides on disk and is not destroyed\n%  when the program exits.\n%\n%  The format of the PersistPixelCache() method is:\n%\n%      MagickBooleanType PersistPixelCache(Image *image,const char *filename,\n%        const MagickBooleanType attach,MagickOffsetType *offset,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o filename: the persistent pixel cache filename.\n%\n%    o attach: A value other than zero initializes the persistent pixel cache.\n%\n%    o initialize: A value other than zero initializes the persistent pixel\n%      cache.\n%\n%    o offset: the offset in the persistent cache to store pixels.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType PersistPixelCache(Image *image,\n  const char *filename,const MagickBooleanType attach,MagickOffsetType *offset,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info,\n    *magick_restrict clone_info;\n\n  Image\n    clone_image;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    page_size;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(image->cache != (void *) NULL);\n  assert(filename != (const char *) NULL);\n  assert(offset != (MagickOffsetType *) NULL);\n  page_size=GetMagickPageSize();\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  if (attach != MagickFalse)\n    {\n      /*\n        Attach existing persistent pixel cache.\n      */\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CacheEvent,GetMagickModule(),\n          \"attach persistent cache\");\n      (void) CopyMagickString(cache_info->cache_filename,filename,\n        MagickPathExtent);\n      cache_info->type=DiskCache;\n      cache_info->offset=(*offset);\n      if (OpenPixelCache(image,ReadMode,exception) == MagickFalse)\n        return(MagickFalse);\n      *offset+=cache_info->length+page_size-(cache_info->length % page_size);\n      return(MagickTrue);\n    }\n  if ((cache_info->mode != ReadMode) &&\n      ((cache_info->type == DiskCache) || (cache_info->type == MapCache)) &&\n      (cache_info->reference_count == 1))\n    {\n      LockSemaphoreInfo(cache_info->semaphore);\n      if ((cache_info->mode != ReadMode) &&\n          ((cache_info->type == DiskCache) || (cache_info->type == MapCache)) &&\n          (cache_info->reference_count == 1))\n        {\n          /*\n            Usurp existing persistent pixel cache.\n          */\n          if (rename_utf8(cache_info->cache_filename, filename) == 0)\n            {\n              (void) CopyMagickString(cache_info->cache_filename,filename,\n                MagickPathExtent);\n              *offset+=cache_info->length+page_size-(cache_info->length %\n                page_size);\n              UnlockSemaphoreInfo(cache_info->semaphore);\n              cache_info=(CacheInfo *) ReferencePixelCache(cache_info);\n              if (image->debug != MagickFalse)\n                (void) LogMagickEvent(CacheEvent,GetMagickModule(),\n                  \"Usurp resident persistent cache\");\n              return(MagickTrue);\n            }\n        }\n      UnlockSemaphoreInfo(cache_info->semaphore);\n    }\n  /*\n    Clone persistent pixel cache.\n  */\n  clone_image=(*image);\n  clone_info=(CacheInfo *) clone_image.cache;\n  image->cache=ClonePixelCache(cache_info);\n  cache_info=(CacheInfo *) ReferencePixelCache(image->cache);\n  (void) CopyMagickString(cache_info->cache_filename,filename,MagickPathExtent);\n  cache_info->type=DiskCache;\n  cache_info->offset=(*offset);\n  cache_info=(CacheInfo *) image->cache;\n  status=OpenPixelCache(image,IOMode,exception);\n  if (status != MagickFalse)\n    status=ClonePixelCacheRepository(cache_info,clone_info,exception);\n  *offset+=cache_info->length+page_size-(cache_info->length % page_size);\n  clone_info=(CacheInfo *) DestroyPixelCache(clone_info);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   Q u e u e A u t h e n t i c P i x e l C a c h e N e x u s                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  QueueAuthenticPixelCacheNexus() allocates an region to store image pixels as\n%  defined by the region rectangle and returns a pointer to the region.  This\n%  region is subsequently transferred from the pixel cache with\n%  SyncAuthenticPixelsCache().  A pointer to the pixels is returned if the\n%  pixels are transferred, otherwise a NULL is returned.\n%\n%  The format of the QueueAuthenticPixelCacheNexus() method is:\n%\n%      Quantum *QueueAuthenticPixelCacheNexus(Image *image,const ssize_t x,\n%        const ssize_t y,const size_t columns,const size_t rows,\n%        const MagickBooleanType clone,NexusInfo *nexus_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o x,y,columns,rows:  These values define the perimeter of a region of\n%      pixels.\n%\n%    o nexus_info: the cache nexus to set.\n%\n%    o clone: clone the pixel cache.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickPrivate Quantum *QueueAuthenticPixelCacheNexus(Image *image,\n  const ssize_t x,const ssize_t y,const size_t columns,const size_t rows,\n  const MagickBooleanType clone,NexusInfo *nexus_info,ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  MagickOffsetType\n    offset;\n\n  MagickSizeType\n    number_pixels;\n\n  Quantum\n    *magick_restrict pixels;\n\n  RectangleInfo\n    region;\n\n  /*\n    Validate pixel cache geometry.\n  */\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) GetImagePixelCache(image,clone,exception);\n  if (cache_info == (Cache) NULL)\n    return((Quantum *) NULL);\n  assert(cache_info->signature == MagickCoreSignature);\n  if ((cache_info->columns == 0) || (cache_info->rows == 0) || (x < 0) ||\n      (y < 0) || (x >= (ssize_t) cache_info->columns) ||\n      (y >= (ssize_t) cache_info->rows))\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),CacheError,\n        \"PixelsAreNotAuthentic\",\"`%s'\",image->filename);\n      return((Quantum *) NULL);\n    }\n  offset=(MagickOffsetType) y*cache_info->columns+x;\n  if (offset < 0)\n    return((Quantum *) NULL);\n  number_pixels=(MagickSizeType) cache_info->columns*cache_info->rows;\n  offset+=(MagickOffsetType) (rows-1)*cache_info->columns+columns-1;\n  if ((MagickSizeType) offset >= number_pixels)\n    return((Quantum *) NULL);\n  /*\n    Return pixel cache.\n  */\n  region.x=x;\n  region.y=y;\n  region.width=columns;\n  region.height=rows;\n  pixels=SetPixelCacheNexusPixels(cache_info,WriteMode,&region,nexus_info,\n    exception);\n  return(pixels);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   Q u e u e A u t h e n t i c P i x e l s C a c h e                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  QueueAuthenticPixelsCache() allocates an region to store image pixels as\n%  defined by the region rectangle and returns a pointer to the region.  This\n%  region is subsequently transferred from the pixel cache with\n%  SyncAuthenticPixelsCache().  A pointer to the pixels is returned if the\n%  pixels are transferred, otherwise a NULL is returned.\n%\n%  The format of the QueueAuthenticPixelsCache() method is:\n%\n%      Quantum *QueueAuthenticPixelsCache(Image *image,const ssize_t x,\n%        const ssize_t y,const size_t columns,const size_t rows,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o x,y,columns,rows:  These values define the perimeter of a region of\n%      pixels.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Quantum *QueueAuthenticPixelsCache(Image *image,const ssize_t x,\n  const ssize_t y,const size_t columns,const size_t rows,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  Quantum\n    *magick_restrict pixels;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  assert(id < (int) cache_info->number_threads);\n  pixels=QueueAuthenticPixelCacheNexus(image,x,y,columns,rows,MagickFalse,\n    cache_info->nexus_info[id],exception);\n  return(pixels);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   Q u e u e A u t h e n t i c P i x e l s                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  QueueAuthenticPixels() queues a mutable pixel region.  If the region is\n%  successfully initialized a pointer to a Quantum array representing the\n%  region is returned, otherwise NULL is returned.  The returned pointer may\n%  point to a temporary working buffer for the pixels or it may point to the\n%  final location of the pixels in memory.\n%\n%  Write-only access means that any existing pixel values corresponding to\n%  the region are ignored.  This is useful if the initial image is being\n%  created from scratch, or if the existing pixel values are to be\n%  completely replaced without need to refer to their pre-existing values.\n%  The application is free to read and write the pixel buffer returned by\n%  QueueAuthenticPixels() any way it pleases. QueueAuthenticPixels() does not\n%  initialize the pixel array values. Initializing pixel array values is the\n%  application's responsibility.\n%\n%  Performance is maximized if the selected region is part of one row, or\n%  one or more full rows, since then there is opportunity to access the\n%  pixels in-place (without a copy) if the image is in memory, or in a\n%  memory-mapped file. The returned pointer must *never* be deallocated\n%  by the user.\n%\n%  Pixels accessed via the returned pointer represent a simple array of type\n%  Quantum. If the image type is CMYK or the storage class is PseudoClass,\n%  call GetAuthenticMetacontent() after invoking GetAuthenticPixels() to\n%  obtain the meta-content (of type void) corresponding to the region.\n%  Once the Quantum (and/or Quantum) array has been updated, the\n%  changes must be saved back to the underlying image using\n%  SyncAuthenticPixels() or they may be lost.\n%\n%  The format of the QueueAuthenticPixels() method is:\n%\n%      Quantum *QueueAuthenticPixels(Image *image,const ssize_t x,\n%        const ssize_t y,const size_t columns,const size_t rows,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o x,y,columns,rows:  These values define the perimeter of a region of\n%      pixels.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Quantum *QueueAuthenticPixels(Image *image,const ssize_t x,\n  const ssize_t y,const size_t columns,const size_t rows,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  Quantum\n    *magick_restrict pixels;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  if (cache_info->methods.queue_authentic_pixels_handler !=\n      (QueueAuthenticPixelsHandler) NULL)\n    {\n      pixels=cache_info->methods.queue_authentic_pixels_handler(image,x,y,\n        columns,rows,exception);\n      return(pixels);\n    }\n  assert(id < (int) cache_info->number_threads);\n  pixels=QueueAuthenticPixelCacheNexus(image,x,y,columns,rows,MagickFalse,\n    cache_info->nexus_info[id],exception);\n  return(pixels);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   R e a d P i x e l C a c h e M e t a c o n t e n t                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadPixelCacheMetacontent() reads metacontent from the specified region of\n%  the pixel cache.\n%\n%  The format of the ReadPixelCacheMetacontent() method is:\n%\n%      MagickBooleanType ReadPixelCacheMetacontent(CacheInfo *cache_info,\n%        NexusInfo *nexus_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o cache_info: the pixel cache.\n%\n%    o nexus_info: the cache nexus to read the metacontent.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline MagickOffsetType ReadPixelCacheRegion(\n  const CacheInfo *magick_restrict cache_info,const MagickOffsetType offset,\n  const MagickSizeType length,unsigned char *magick_restrict buffer)\n{\n  register MagickOffsetType\n    i;\n\n  ssize_t\n    count;\n\n#if !defined(MAGICKCORE_HAVE_PREAD)\n  if (lseek(cache_info->file,offset,SEEK_SET) < 0)\n    return((MagickOffsetType) -1);\n#endif\n  count=0;\n  for (i=0; i < (MagickOffsetType) length; i+=count)\n  {\n#if !defined(MAGICKCORE_HAVE_PREAD)\n    count=read(cache_info->file,buffer+i,(size_t) MagickMin(length-i,(size_t)\n      SSIZE_MAX));\n#else\n    count=pread(cache_info->file,buffer+i,(size_t) MagickMin(length-i,(size_t)\n      SSIZE_MAX),(off_t) (offset+i));\n#endif\n    if (count <= 0)\n      {\n        count=0;\n        if (errno != EINTR)\n          break;\n      }\n  }\n  return(i);\n}\n\nstatic MagickBooleanType ReadPixelCacheMetacontent(\n  CacheInfo *magick_restrict cache_info,NexusInfo *magick_restrict nexus_info,\n  ExceptionInfo *exception)\n{\n  MagickOffsetType\n    count,\n    offset;\n\n  MagickSizeType\n    extent,\n    length;\n\n  register ssize_t\n    y;\n\n  register unsigned char\n    *magick_restrict q;\n\n  size_t\n    rows;\n\n  if (cache_info->metacontent_extent == 0)\n    return(MagickFalse);\n  if (nexus_info->authentic_pixel_cache != MagickFalse)\n    return(MagickTrue);\n  offset=(MagickOffsetType) nexus_info->region.y*cache_info->columns+\n    nexus_info->region.x;\n  length=(MagickSizeType) nexus_info->region.width*\n    cache_info->metacontent_extent;\n  extent=length*nexus_info->region.height;\n  rows=nexus_info->region.height;\n  y=0;\n  q=(unsigned char *) nexus_info->metacontent;\n  switch (cache_info->type)\n  {\n    case MemoryCache:\n    case MapCache:\n    {\n      register unsigned char\n        *magick_restrict p;\n\n      /*\n        Read meta-content from memory.\n      */\n      if ((cache_info->columns == nexus_info->region.width) &&\n          (extent == (MagickSizeType) ((size_t) extent)))\n        {\n          length=extent;\n          rows=1UL;\n        }\n      p=(unsigned char *) cache_info->metacontent+offset*\n        cache_info->metacontent_extent;\n      for (y=0; y < (ssize_t) rows; y++)\n      {\n        (void) memcpy(q,p,(size_t) length);\n        p+=cache_info->metacontent_extent*cache_info->columns;\n        q+=cache_info->metacontent_extent*nexus_info->region.width;\n      }\n      break;\n    }\n    case DiskCache:\n    {\n      /*\n        Read meta content from disk.\n      */\n      LockSemaphoreInfo(cache_info->file_semaphore);\n      if (OpenPixelCacheOnDisk(cache_info,IOMode) == MagickFalse)\n        {\n          ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",\n            cache_info->cache_filename);\n          UnlockSemaphoreInfo(cache_info->file_semaphore);\n          return(MagickFalse);\n        }\n      if ((cache_info->columns == nexus_info->region.width) &&\n          (extent <= MagickMaxBufferExtent))\n        {\n          length=extent;\n          rows=1UL;\n        }\n      extent=(MagickSizeType) cache_info->columns*cache_info->rows;\n      for (y=0; y < (ssize_t) rows; y++)\n      {\n        count=ReadPixelCacheRegion(cache_info,cache_info->offset+extent*\n          cache_info->number_channels*sizeof(Quantum)+offset*\n          cache_info->metacontent_extent,length,(unsigned char *) q);\n        if (count != (MagickOffsetType) length)\n          break;\n        offset+=cache_info->columns;\n        q+=cache_info->metacontent_extent*nexus_info->region.width;\n      }\n      if (IsFileDescriptorLimitExceeded() != MagickFalse)\n        (void) ClosePixelCacheOnDisk(cache_info);\n      UnlockSemaphoreInfo(cache_info->file_semaphore);\n      break;\n    }\n    case DistributedCache:\n    {\n      RectangleInfo\n        region;\n\n      /*\n        Read metacontent from distributed cache.\n      */\n      LockSemaphoreInfo(cache_info->file_semaphore);\n      region=nexus_info->region;\n      if ((cache_info->columns != nexus_info->region.width) ||\n          (extent > MagickMaxBufferExtent))\n        region.height=1UL;\n      else\n        {\n          length=extent;\n          rows=1UL;\n        }\n      for (y=0; y < (ssize_t) rows; y++)\n      {\n        count=ReadDistributePixelCacheMetacontent((DistributeCacheInfo *)\n          cache_info->server_info,&region,length,(unsigned char *) q);\n        if (count != (MagickOffsetType) length)\n          break;\n        q+=cache_info->metacontent_extent*nexus_info->region.width;\n        region.y++;\n      }\n      UnlockSemaphoreInfo(cache_info->file_semaphore);\n      break;\n    }\n    default:\n      break;\n  }\n  if (y < (ssize_t) rows)\n    {\n      ThrowFileException(exception,CacheError,\"UnableToReadPixelCache\",\n        cache_info->cache_filename);\n      return(MagickFalse);\n    }\n  if ((cache_info->debug != MagickFalse) &&\n      (CacheTick(nexus_info->region.y,cache_info->rows) != MagickFalse))\n    (void) LogMagickEvent(CacheEvent,GetMagickModule(),\n      \"%s[%.20gx%.20g%+.20g%+.20g]\",cache_info->filename,(double)\n      nexus_info->region.width,(double) nexus_info->region.height,(double)\n      nexus_info->region.x,(double) nexus_info->region.y);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   R e a d P i x e l C a c h e P i x e l s                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadPixelCachePixels() reads pixels from the specified region of the pixel\n%  cache.\n%\n%  The format of the ReadPixelCachePixels() method is:\n%\n%      MagickBooleanType ReadPixelCachePixels(CacheInfo *cache_info,\n%        NexusInfo *nexus_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o cache_info: the pixel cache.\n%\n%    o nexus_info: the cache nexus to read the pixels.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType ReadPixelCachePixels(\n  CacheInfo *magick_restrict cache_info,NexusInfo *magick_restrict nexus_info,\n  ExceptionInfo *exception)\n{\n  MagickOffsetType\n    count,\n    offset;\n\n  MagickSizeType\n    extent,\n    length;\n\n  register Quantum\n    *magick_restrict q;\n\n  register ssize_t\n    y;\n\n  size_t\n    number_channels,\n    rows;\n\n  if (nexus_info->authentic_pixel_cache != MagickFalse)\n    return(MagickTrue);\n  offset=(MagickOffsetType) nexus_info->region.y*cache_info->columns;\n  if ((ssize_t) (offset/cache_info->columns) != nexus_info->region.y)\n    return(MagickFalse);\n  offset+=nexus_info->region.x;\n  number_channels=cache_info->number_channels;\n  length=(MagickSizeType) number_channels*nexus_info->region.width*\n    sizeof(Quantum);\n  if ((length/number_channels/sizeof(Quantum)) != nexus_info->region.width)\n    return(MagickFalse);\n  rows=nexus_info->region.height;\n  extent=length*rows;\n  if ((extent == 0) || ((extent/length) != rows))\n    return(MagickFalse);\n  y=0;\n  q=nexus_info->pixels;\n  switch (cache_info->type)\n  {\n    case MemoryCache:\n    case MapCache:\n    {\n      register Quantum\n        *magick_restrict p;\n\n      /*\n        Read pixels from memory.\n      */\n      if ((cache_info->columns == nexus_info->region.width) &&\n          (extent == (MagickSizeType) ((size_t) extent)))\n        {\n          length=extent;\n          rows=1UL;\n        }\n      p=cache_info->pixels+offset*cache_info->number_channels;\n      for (y=0; y < (ssize_t) rows; y++)\n      {\n        (void) memcpy(q,p,(size_t) length);\n        p+=cache_info->number_channels*cache_info->columns;\n        q+=cache_info->number_channels*nexus_info->region.width;\n      }\n      break;\n    }\n    case DiskCache:\n    {\n      /*\n        Read pixels from disk.\n      */\n      LockSemaphoreInfo(cache_info->file_semaphore);\n      if (OpenPixelCacheOnDisk(cache_info,IOMode) == MagickFalse)\n        {\n          ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",\n            cache_info->cache_filename);\n          UnlockSemaphoreInfo(cache_info->file_semaphore);\n          return(MagickFalse);\n        }\n      if ((cache_info->columns == nexus_info->region.width) &&\n          (extent <= MagickMaxBufferExtent))\n        {\n          length=extent;\n          rows=1UL;\n        }\n      for (y=0; y < (ssize_t) rows; y++)\n      {\n        count=ReadPixelCacheRegion(cache_info,cache_info->offset+offset*\n          cache_info->number_channels*sizeof(*q),length,(unsigned char *) q);\n        if (count != (MagickOffsetType) length)\n          break;\n        offset+=cache_info->columns;\n        q+=cache_info->number_channels*nexus_info->region.width;\n      }\n      if (IsFileDescriptorLimitExceeded() != MagickFalse)\n        (void) ClosePixelCacheOnDisk(cache_info);\n      UnlockSemaphoreInfo(cache_info->file_semaphore);\n      break;\n    }\n    case DistributedCache:\n    {\n      RectangleInfo\n        region;\n\n      /*\n        Read pixels from distributed cache.\n      */\n      LockSemaphoreInfo(cache_info->file_semaphore);\n      region=nexus_info->region;\n      if ((cache_info->columns != nexus_info->region.width) ||\n          (extent > MagickMaxBufferExtent))\n        region.height=1UL;\n      else\n        {\n          length=extent;\n          rows=1UL;\n        }\n      for (y=0; y < (ssize_t) rows; y++)\n      {\n        count=ReadDistributePixelCachePixels((DistributeCacheInfo *)\n          cache_info->server_info,&region,length,(unsigned char *) q);\n        if (count != (MagickOffsetType) length)\n          break;\n        q+=cache_info->number_channels*nexus_info->region.width;\n        region.y++;\n      }\n      UnlockSemaphoreInfo(cache_info->file_semaphore);\n      break;\n    }\n    default:\n      break;\n  }\n  if (y < (ssize_t) rows)\n    {\n      ThrowFileException(exception,CacheError,\"UnableToReadPixelCache\",\n        cache_info->cache_filename);\n      return(MagickFalse);\n    }\n  if ((cache_info->debug != MagickFalse) &&\n      (CacheTick(nexus_info->region.y,cache_info->rows) != MagickFalse))\n    (void) LogMagickEvent(CacheEvent,GetMagickModule(),\n      \"%s[%.20gx%.20g%+.20g%+.20g]\",cache_info->filename,(double)\n      nexus_info->region.width,(double) nexus_info->region.height,(double)\n      nexus_info->region.x,(double) nexus_info->region.y);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   R e f e r e n c e P i x e l C a c h e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReferencePixelCache() increments the reference count associated with the\n%  pixel cache returning a pointer to the cache.\n%\n%  The format of the ReferencePixelCache method is:\n%\n%      Cache ReferencePixelCache(Cache cache_info)\n%\n%  A description of each parameter follows:\n%\n%    o cache_info: the pixel cache.\n%\n*/\nMagickPrivate Cache ReferencePixelCache(Cache cache)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  assert(cache != (Cache *) NULL);\n  cache_info=(CacheInfo *) cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  LockSemaphoreInfo(cache_info->semaphore);\n  cache_info->reference_count++;\n  UnlockSemaphoreInfo(cache_info->semaphore);\n  return(cache_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   R e s e t P i x e l C a c h e E p o c h e                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ResetPixelCacheEpoch() resets the pixel cache epoch.\n%\n%  The format of the ResetPixelCacheEpoch method is:\n%\n%      void ResetPixelCacheEpoch(void)\n%\n*/\nMagickPrivate void ResetPixelCacheEpoch(void)\n{\n  cache_epoch=0;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   S e t P i x e l C a c h e M e t h o d s                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetPixelCacheMethods() sets the image pixel methods to the specified ones.\n%\n%  The format of the SetPixelCacheMethods() method is:\n%\n%      SetPixelCacheMethods(Cache *,CacheMethods *cache_methods)\n%\n%  A description of each parameter follows:\n%\n%    o cache: the pixel cache.\n%\n%    o cache_methods: Specifies a pointer to a CacheMethods structure.\n%\n*/\nMagickPrivate void SetPixelCacheMethods(Cache cache,CacheMethods *cache_methods)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  GetOneAuthenticPixelFromHandler\n    get_one_authentic_pixel_from_handler;\n\n  GetOneVirtualPixelFromHandler\n    get_one_virtual_pixel_from_handler;\n\n  /*\n    Set cache pixel methods.\n  */\n  assert(cache != (Cache) NULL);\n  assert(cache_methods != (CacheMethods *) NULL);\n  cache_info=(CacheInfo *) cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  if (cache_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      cache_info->filename);\n  if (cache_methods->get_virtual_pixel_handler != (GetVirtualPixelHandler) NULL)\n    cache_info->methods.get_virtual_pixel_handler=\n      cache_methods->get_virtual_pixel_handler;\n  if (cache_methods->destroy_pixel_handler != (DestroyPixelHandler) NULL)\n    cache_info->methods.destroy_pixel_handler=\n      cache_methods->destroy_pixel_handler;\n  if (cache_methods->get_virtual_metacontent_from_handler !=\n      (GetVirtualMetacontentFromHandler) NULL)\n    cache_info->methods.get_virtual_metacontent_from_handler=\n      cache_methods->get_virtual_metacontent_from_handler;\n  if (cache_methods->get_authentic_pixels_handler !=\n      (GetAuthenticPixelsHandler) NULL)\n    cache_info->methods.get_authentic_pixels_handler=\n      cache_methods->get_authentic_pixels_handler;\n  if (cache_methods->queue_authentic_pixels_handler !=\n      (QueueAuthenticPixelsHandler) NULL)\n    cache_info->methods.queue_authentic_pixels_handler=\n      cache_methods->queue_authentic_pixels_handler;\n  if (cache_methods->sync_authentic_pixels_handler !=\n      (SyncAuthenticPixelsHandler) NULL)\n    cache_info->methods.sync_authentic_pixels_handler=\n      cache_methods->sync_authentic_pixels_handler;\n  if (cache_methods->get_authentic_pixels_from_handler !=\n      (GetAuthenticPixelsFromHandler) NULL)\n    cache_info->methods.get_authentic_pixels_from_handler=\n      cache_methods->get_authentic_pixels_from_handler;\n  if (cache_methods->get_authentic_metacontent_from_handler !=\n      (GetAuthenticMetacontentFromHandler) NULL)\n    cache_info->methods.get_authentic_metacontent_from_handler=\n      cache_methods->get_authentic_metacontent_from_handler;\n  get_one_virtual_pixel_from_handler=\n    cache_info->methods.get_one_virtual_pixel_from_handler;\n  if (get_one_virtual_pixel_from_handler !=\n      (GetOneVirtualPixelFromHandler) NULL)\n    cache_info->methods.get_one_virtual_pixel_from_handler=\n      cache_methods->get_one_virtual_pixel_from_handler;\n  get_one_authentic_pixel_from_handler=\n    cache_methods->get_one_authentic_pixel_from_handler;\n  if (get_one_authentic_pixel_from_handler !=\n      (GetOneAuthenticPixelFromHandler) NULL)\n    cache_info->methods.get_one_authentic_pixel_from_handler=\n      cache_methods->get_one_authentic_pixel_from_handler;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   S e t P i x e l C a c h e N e x u s P i x e l s                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetPixelCacheNexusPixels() defines the region of the cache for the\n%  specified cache nexus.\n%\n%  The format of the SetPixelCacheNexusPixels() method is:\n%\n%      Quantum SetPixelCacheNexusPixels(const CacheInfo *cache_info,\n%        const MapMode mode,const RectangleInfo *region,NexusInfo *nexus_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o cache_info: the pixel cache.\n%\n%    o mode: ReadMode, WriteMode, or IOMode.\n%\n%    o region: A pointer to the RectangleInfo structure that defines the\n%      region of this particular cache nexus.\n%\n%    o nexus_info: the cache nexus to set.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline MagickBooleanType AcquireCacheNexusPixels(\n  const CacheInfo *magick_restrict cache_info,NexusInfo *nexus_info,\n  ExceptionInfo *exception)\n{\n  if (nexus_info->length != (MagickSizeType) ((size_t) nexus_info->length))\n    return(MagickFalse);\n  nexus_info->mapped=MagickFalse;\n  nexus_info->cache=(Quantum *) MagickAssumeAligned(AcquireAlignedMemory(1,\n    (size_t) nexus_info->length));\n  if (nexus_info->cache == (Quantum *) NULL)\n    {\n      nexus_info->mapped=MagickTrue;\n      nexus_info->cache=(Quantum *) MapBlob(-1,IOMode,0,(size_t)\n        nexus_info->length);\n    }\n  if (nexus_info->cache == (Quantum *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\n        cache_info->filename);\n      return(MagickFalse);\n    }\n  return(MagickTrue);\n}\n\nstatic inline MagickBooleanType IsPixelCacheAuthentic(\n  const CacheInfo *magick_restrict cache_info,\n  const NexusInfo *magick_restrict nexus_info)\n{\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  /*\n    Does nexus pixels point directly to in-core cache pixels or is it buffered?\n  */\n  if (cache_info->type == PingCache)\n    return(MagickTrue);\n  offset=(MagickOffsetType) nexus_info->region.y*cache_info->columns+\n    nexus_info->region.x;\n  status=nexus_info->pixels == (cache_info->pixels+offset*\n    cache_info->number_channels) ? MagickTrue : MagickFalse;\n  return(status);\n}\n\nstatic inline void PrefetchPixelCacheNexusPixels(const NexusInfo *nexus_info,\n  const MapMode mode)\n{\n  if (mode == ReadMode)\n    {\n      MagickCachePrefetch((unsigned char *) nexus_info->pixels,0,1);\n      return;\n    }\n  MagickCachePrefetch((unsigned char *) nexus_info->pixels,1,1);\n}\n\nstatic Quantum *SetPixelCacheNexusPixels(const CacheInfo *cache_info,\n  const MapMode mode,const RectangleInfo *region,NexusInfo *nexus_info,\n  ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    length,\n    number_pixels;\n\n  assert(cache_info != (const CacheInfo *) NULL);\n  assert(cache_info->signature == MagickCoreSignature);\n  if (cache_info->type == UndefinedCache)\n    return((Quantum *) NULL);\n  nexus_info->region=(*region);\n  if ((cache_info->type == MemoryCache) || (cache_info->type == MapCache))\n    {\n      ssize_t\n        x,\n        y;\n\n      x=nexus_info->region.x+(ssize_t) nexus_info->region.width-1;\n      y=nexus_info->region.y+(ssize_t) nexus_info->region.height-1;\n      if (((nexus_info->region.x >= 0) && (x < (ssize_t) cache_info->columns) &&\n           (nexus_info->region.y >= 0) && (y < (ssize_t) cache_info->rows)) &&\n          ((nexus_info->region.height == 1UL) || ((nexus_info->region.x == 0) &&\n           ((nexus_info->region.width == cache_info->columns) ||\n            ((nexus_info->region.width % cache_info->columns) == 0)))))\n        {\n          MagickOffsetType\n            offset;\n\n          /*\n            Pixels are accessed directly from memory.\n          */\n          offset=(MagickOffsetType) nexus_info->region.y*cache_info->columns+\n            nexus_info->region.x;\n          nexus_info->pixels=cache_info->pixels+cache_info->number_channels*\n            offset;\n          nexus_info->metacontent=(void *) NULL;\n          if (cache_info->metacontent_extent != 0)\n            nexus_info->metacontent=(unsigned char *) cache_info->metacontent+\n              offset*cache_info->metacontent_extent;\n          PrefetchPixelCacheNexusPixels(nexus_info,mode);\n          nexus_info->authentic_pixel_cache=IsPixelCacheAuthentic(cache_info,\n            nexus_info);\n          return(nexus_info->pixels);\n        }\n    }\n  /*\n    Pixels are stored in a staging region until they are synced to the cache.\n  */\n  number_pixels=(MagickSizeType) nexus_info->region.width*\n    nexus_info->region.height;\n  length=number_pixels*cache_info->number_channels*sizeof(Quantum);\n  if (cache_info->metacontent_extent != 0)\n    length+=number_pixels*cache_info->metacontent_extent;\n  if (nexus_info->cache == (Quantum *) NULL)\n    {\n      nexus_info->length=length;\n      status=AcquireCacheNexusPixels(cache_info,nexus_info,exception);\n      if (status == MagickFalse)\n        {\n          nexus_info->length=0;\n          return((Quantum *) NULL);\n        }\n    }\n  else\n    if (nexus_info->length < length)\n      {\n        RelinquishCacheNexusPixels(nexus_info);\n        nexus_info->length=length;\n        status=AcquireCacheNexusPixels(cache_info,nexus_info,exception);\n        if (status == MagickFalse)\n          {\n            nexus_info->length=0;\n            return((Quantum *) NULL);\n          }\n      }\n  nexus_info->pixels=nexus_info->cache;\n  nexus_info->metacontent=(void *) NULL;\n  if (cache_info->metacontent_extent != 0)\n    nexus_info->metacontent=(void *) (nexus_info->pixels+number_pixels*\n      cache_info->number_channels);\n  PrefetchPixelCacheNexusPixels(nexus_info,mode);\n  nexus_info->authentic_pixel_cache=IsPixelCacheAuthentic(cache_info,\n    nexus_info);\n  return(nexus_info->pixels);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t P i x e l C a c h e V i r t u a l M e t h o d                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetPixelCacheVirtualMethod() sets the \"virtual pixels\" method for the\n%  pixel cache and returns the previous setting.  A virtual pixel is any pixel\n%  access that is outside the boundaries of the image cache.\n%\n%  The format of the SetPixelCacheVirtualMethod() method is:\n%\n%      VirtualPixelMethod SetPixelCacheVirtualMethod(Image *image,\n%        const VirtualPixelMethod virtual_pixel_method,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o virtual_pixel_method: choose the type of virtual pixel.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic MagickBooleanType SetCacheAlphaChannel(Image *image,const Quantum alpha,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  CacheView\n    *magick_restrict image_view;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  image->alpha_trait=BlendPixelTrait;\n  status=MagickTrue;\n  image_view=AcquireVirtualCacheView(image,exception);  /* must be virtual */\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(status) \\\n    magick_threads(image,image,1,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      SetPixelAlpha(image,alpha,q);\n      q+=GetPixelChannels(image);\n    }\n    status=SyncCacheViewAuthenticPixels(image_view,exception);\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\nMagickPrivate VirtualPixelMethod SetPixelCacheVirtualMethod(Image *image,\n  const VirtualPixelMethod virtual_pixel_method,ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  VirtualPixelMethod\n    method;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  method=cache_info->virtual_pixel_method;\n  cache_info->virtual_pixel_method=virtual_pixel_method;\n  if ((image->columns != 0) && (image->rows != 0))\n    switch (virtual_pixel_method)\n    {\n      case BackgroundVirtualPixelMethod:\n      {\n        if ((image->background_color.alpha_trait != UndefinedPixelTrait) &&\n            (image->alpha_trait == UndefinedPixelTrait))\n          (void) SetCacheAlphaChannel(image,OpaqueAlpha,exception);\n        if ((IsPixelInfoGray(&image->background_color) == MagickFalse) &&\n            (IsGrayColorspace(image->colorspace) != MagickFalse))\n          (void) SetImageColorspace(image,sRGBColorspace,exception);\n        break;\n      }\n      case TransparentVirtualPixelMethod:\n      {\n        if (image->alpha_trait == UndefinedPixelTrait)\n          (void) SetCacheAlphaChannel(image,OpaqueAlpha,exception);\n        break;\n      }\n      default:\n        break;\n    }\n  return(method);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   S y n c A u t h e n t i c P i x e l C a c h e N e x u s                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SyncAuthenticPixelCacheNexus() saves the authentic image pixels to the\n%  in-memory or disk cache.  The method returns MagickTrue if the pixel region\n%  is synced, otherwise MagickFalse.\n%\n%  The format of the SyncAuthenticPixelCacheNexus() method is:\n%\n%      MagickBooleanType SyncAuthenticPixelCacheNexus(Image *image,\n%        NexusInfo *nexus_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o nexus_info: the cache nexus to sync.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickPrivate MagickBooleanType SyncAuthenticPixelCacheNexus(Image *image,\n  NexusInfo *magick_restrict nexus_info,ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  MagickBooleanType\n    status;\n\n  /*\n    Transfer pixels to the cache.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->cache == (Cache) NULL)\n    ThrowBinaryException(CacheError,\"PixelCacheIsNotOpen\",image->filename);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  if (cache_info->type == UndefinedCache)\n    return(MagickFalse);\n  if (nexus_info->authentic_pixel_cache != MagickFalse)\n    {\n      image->taint=MagickTrue;\n      return(MagickTrue);\n    }\n  assert(cache_info->signature == MagickCoreSignature);\n  status=WritePixelCachePixels(cache_info,nexus_info,exception);\n  if ((cache_info->metacontent_extent != 0) &&\n      (WritePixelCacheMetacontent(cache_info,nexus_info,exception) == MagickFalse))\n    return(MagickFalse);\n  if (status != MagickFalse)\n    image->taint=MagickTrue;\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   S y n c A u t h e n t i c P i x e l C a c h e                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SyncAuthenticPixelsCache() saves the authentic image pixels to the in-memory\n%  or disk cache.  The method returns MagickTrue if the pixel region is synced,\n%  otherwise MagickFalse.\n%\n%  The format of the SyncAuthenticPixelsCache() method is:\n%\n%      MagickBooleanType SyncAuthenticPixelsCache(Image *image,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType SyncAuthenticPixelsCache(Image *image,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  MagickBooleanType\n    status;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  assert(id < (int) cache_info->number_threads);\n  status=SyncAuthenticPixelCacheNexus(image,cache_info->nexus_info[id],\n    exception);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S y n c A u t h e n t i c P i x e l s                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SyncAuthenticPixels() saves the image pixels to the in-memory or disk cache.\n%  The method returns MagickTrue if the pixel region is flushed, otherwise\n%  MagickFalse.\n%\n%  The format of the SyncAuthenticPixels() method is:\n%\n%      MagickBooleanType SyncAuthenticPixels(Image *image,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType SyncAuthenticPixels(Image *image,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  MagickBooleanType\n    status;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  if (cache_info->methods.sync_authentic_pixels_handler !=\n       (SyncAuthenticPixelsHandler) NULL)\n    {\n      status=cache_info->methods.sync_authentic_pixels_handler(image,\n        exception);\n      return(status);\n    }\n  assert(id < (int) cache_info->number_threads);\n  status=SyncAuthenticPixelCacheNexus(image,cache_info->nexus_info[id],\n    exception);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   S y n c I m a g e P i x e l C a c h e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SyncImagePixelCache() saves the image pixels to the in-memory or disk cache.\n%  The method returns MagickTrue if the pixel region is flushed, otherwise\n%  MagickFalse.\n%\n%  The format of the SyncImagePixelCache() method is:\n%\n%      MagickBooleanType SyncImagePixelCache(Image *image,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickPrivate MagickBooleanType SyncImagePixelCache(Image *image,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  assert(image != (Image *) NULL);\n  assert(exception != (ExceptionInfo *) NULL);\n  cache_info=(CacheInfo *) GetImagePixelCache(image,MagickTrue,exception);\n  return(cache_info == (CacheInfo *) NULL ? MagickFalse : MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   W r i t e P i x e l C a c h e M e t a c o n t e n t                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WritePixelCacheMetacontent() writes the meta-content to the specified region\n%  of the pixel cache.\n%\n%  The format of the WritePixelCacheMetacontent() method is:\n%\n%      MagickBooleanType WritePixelCacheMetacontent(CacheInfo *cache_info,\n%        NexusInfo *nexus_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o cache_info: the pixel cache.\n%\n%    o nexus_info: the cache nexus to write the meta-content.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WritePixelCacheMetacontent(CacheInfo *cache_info,\n  NexusInfo *magick_restrict nexus_info,ExceptionInfo *exception)\n{\n  MagickOffsetType\n    count,\n    offset;\n\n  MagickSizeType\n    extent,\n    length;\n\n  register const unsigned char\n    *magick_restrict p;\n\n  register ssize_t\n    y;\n\n  size_t\n    rows;\n\n  if (cache_info->metacontent_extent == 0)\n    return(MagickFalse);\n  if (nexus_info->authentic_pixel_cache != MagickFalse)\n    return(MagickTrue);\n  offset=(MagickOffsetType) nexus_info->region.y*cache_info->columns+\n    nexus_info->region.x;\n  length=(MagickSizeType) nexus_info->region.width*\n    cache_info->metacontent_extent;\n  extent=(MagickSizeType) length*nexus_info->region.height;\n  rows=nexus_info->region.height;\n  y=0;\n  p=(unsigned char *) nexus_info->metacontent;\n  switch (cache_info->type)\n  {\n    case MemoryCache:\n    case MapCache:\n    {\n      register unsigned char\n        *magick_restrict q;\n\n      /*\n        Write associated pixels to memory.\n      */\n      if ((cache_info->columns == nexus_info->region.width) &&\n          (extent == (MagickSizeType) ((size_t) extent)))\n        {\n          length=extent;\n          rows=1UL;\n        }\n      q=(unsigned char *) cache_info->metacontent+offset*\n        cache_info->metacontent_extent;\n      for (y=0; y < (ssize_t) rows; y++)\n      {\n        (void) memcpy(q,p,(size_t) length);\n        p+=nexus_info->region.width*cache_info->metacontent_extent;\n        q+=cache_info->columns*cache_info->metacontent_extent;\n      }\n      break;\n    }\n    case DiskCache:\n    {\n      /*\n        Write associated pixels to disk.\n      */\n      LockSemaphoreInfo(cache_info->file_semaphore);\n      if (OpenPixelCacheOnDisk(cache_info,IOMode) == MagickFalse)\n        {\n          ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",\n            cache_info->cache_filename);\n          UnlockSemaphoreInfo(cache_info->file_semaphore);\n          return(MagickFalse);\n        }\n      if ((cache_info->columns == nexus_info->region.width) &&\n          (extent <= MagickMaxBufferExtent))\n        {\n          length=extent;\n          rows=1UL;\n        }\n      extent=(MagickSizeType) cache_info->columns*cache_info->rows;\n      for (y=0; y < (ssize_t) rows; y++)\n      {\n        count=WritePixelCacheRegion(cache_info,cache_info->offset+extent*\n          cache_info->number_channels*sizeof(Quantum)+offset*\n          cache_info->metacontent_extent,length,(const unsigned char *) p);\n        if (count != (MagickOffsetType) length)\n          break;\n        p+=cache_info->metacontent_extent*nexus_info->region.width;\n        offset+=cache_info->columns;\n      }\n      if (IsFileDescriptorLimitExceeded() != MagickFalse)\n        (void) ClosePixelCacheOnDisk(cache_info);\n      UnlockSemaphoreInfo(cache_info->file_semaphore);\n      break;\n    }\n    case DistributedCache:\n    {\n      RectangleInfo\n        region;\n\n      /*\n        Write metacontent to distributed cache.\n      */\n      LockSemaphoreInfo(cache_info->file_semaphore);\n      region=nexus_info->region;\n      if ((cache_info->columns != nexus_info->region.width) ||\n          (extent > MagickMaxBufferExtent))\n        region.height=1UL;\n      else\n        {\n          length=extent;\n          rows=1UL;\n        }\n      for (y=0; y < (ssize_t) rows; y++)\n      {\n        count=WriteDistributePixelCacheMetacontent((DistributeCacheInfo *)\n          cache_info->server_info,&region,length,(const unsigned char *) p);\n        if (count != (MagickOffsetType) length)\n          break;\n        p+=cache_info->metacontent_extent*nexus_info->region.width;\n        region.y++;\n      }\n      UnlockSemaphoreInfo(cache_info->file_semaphore);\n      break;\n    }\n    default:\n      break;\n  }\n  if (y < (ssize_t) rows)\n    {\n      ThrowFileException(exception,CacheError,\"UnableToWritePixelCache\",\n        cache_info->cache_filename);\n      return(MagickFalse);\n    }\n  if ((cache_info->debug != MagickFalse) &&\n      (CacheTick(nexus_info->region.y,cache_info->rows) != MagickFalse))\n    (void) LogMagickEvent(CacheEvent,GetMagickModule(),\n      \"%s[%.20gx%.20g%+.20g%+.20g]\",cache_info->filename,(double)\n      nexus_info->region.width,(double) nexus_info->region.height,(double)\n      nexus_info->region.x,(double) nexus_info->region.y);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   W r i t e C a c h e P i x e l s                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WritePixelCachePixels() writes image pixels to the specified region of the\n%  pixel cache.\n%\n%  The format of the WritePixelCachePixels() method is:\n%\n%      MagickBooleanType WritePixelCachePixels(CacheInfo *cache_info,\n%        NexusInfo *nexus_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o cache_info: the pixel cache.\n%\n%    o nexus_info: the cache nexus to write the pixels.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WritePixelCachePixels(\n  CacheInfo *magick_restrict cache_info,NexusInfo *magick_restrict nexus_info,\n  ExceptionInfo *exception)\n{\n  MagickOffsetType\n    count,\n    offset;\n\n  MagickSizeType\n    extent,\n    length;\n\n  register const Quantum\n    *magick_restrict p;\n\n  register ssize_t\n    y;\n\n  size_t\n    rows;\n\n  if (nexus_info->authentic_pixel_cache != MagickFalse)\n    return(MagickTrue);\n  offset=(MagickOffsetType) nexus_info->region.y*cache_info->columns+\n    nexus_info->region.x;\n  length=(MagickSizeType) cache_info->number_channels*nexus_info->region.width*\n    sizeof(Quantum);\n  extent=length*nexus_info->region.height;\n  rows=nexus_info->region.height;\n  y=0;\n  p=nexus_info->pixels;\n  switch (cache_info->type)\n  {\n    case MemoryCache:\n    case MapCache:\n    {\n      register Quantum\n        *magick_restrict q;\n\n      /*\n        Write pixels to memory.\n      */\n      if ((cache_info->columns == nexus_info->region.width) &&\n          (extent == (MagickSizeType) ((size_t) extent)))\n        {\n          length=extent;\n          rows=1UL;\n        }\n      q=cache_info->pixels+offset*cache_info->number_channels;\n      for (y=0; y < (ssize_t) rows; y++)\n      {\n        (void) memcpy(q,p,(size_t) length);\n        p+=cache_info->number_channels*nexus_info->region.width;\n        q+=cache_info->columns*cache_info->number_channels;\n      }\n      break;\n    }\n    case DiskCache:\n    {\n      /*\n        Write pixels to disk.\n      */\n      LockSemaphoreInfo(cache_info->file_semaphore);\n      if (OpenPixelCacheOnDisk(cache_info,IOMode) == MagickFalse)\n        {\n          ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",\n            cache_info->cache_filename);\n          UnlockSemaphoreInfo(cache_info->file_semaphore);\n          return(MagickFalse);\n        }\n      if ((cache_info->columns == nexus_info->region.width) &&\n          (extent <= MagickMaxBufferExtent))\n        {\n          length=extent;\n          rows=1UL;\n        }\n      for (y=0; y < (ssize_t) rows; y++)\n      {\n        count=WritePixelCacheRegion(cache_info,cache_info->offset+offset*\n          cache_info->number_channels*sizeof(*p),length,(const unsigned char *)\n          p);\n        if (count != (MagickOffsetType) length)\n          break;\n        p+=cache_info->number_channels*nexus_info->region.width;\n        offset+=cache_info->columns;\n      }\n      if (IsFileDescriptorLimitExceeded() != MagickFalse)\n        (void) ClosePixelCacheOnDisk(cache_info);\n      UnlockSemaphoreInfo(cache_info->file_semaphore);\n      break;\n    }\n    case DistributedCache:\n    {\n      RectangleInfo\n        region;\n\n      /*\n        Write pixels to distributed cache.\n      */\n      LockSemaphoreInfo(cache_info->file_semaphore);\n      region=nexus_info->region;\n      if ((cache_info->columns != nexus_info->region.width) ||\n          (extent > MagickMaxBufferExtent))\n        region.height=1UL;\n      else\n        {\n          length=extent;\n          rows=1UL;\n        }\n      for (y=0; y < (ssize_t) rows; y++)\n      {\n        count=WriteDistributePixelCachePixels((DistributeCacheInfo *)\n          cache_info->server_info,&region,length,(const unsigned char *) p);\n        if (count != (MagickOffsetType) length)\n          break;\n        p+=cache_info->number_channels*nexus_info->region.width;\n        region.y++;\n      }\n      UnlockSemaphoreInfo(cache_info->file_semaphore);\n      break;\n    }\n    default:\n      break;\n  }\n  if (y < (ssize_t) rows)\n    {\n      ThrowFileException(exception,CacheError,\"UnableToWritePixelCache\",\n        cache_info->cache_filename);\n      return(MagickFalse);\n    }\n  if ((cache_info->debug != MagickFalse) &&\n      (CacheTick(nexus_info->region.y,cache_info->rows) != MagickFalse))\n    (void) LogMagickEvent(CacheEvent,GetMagickModule(),\n      \"%s[%.20gx%.20g%+.20g%+.20g]\",cache_info->filename,(double)\n      nexus_info->region.width,(double) nexus_info->region.height,(double)\n      nexus_info->region.x,(double) nexus_info->region.y);\n  return(MagickTrue);\n}\n", "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                     IIIII  M   M   AAA    GGGG  EEEEE                       %\n%                       I    MM MM  A   A  G      E                           %\n%                       I    M M M  AAAAA  G  GG  EEE                         %\n%                       I    M   M  A   A  G   G  E                           %\n%                     IIIII  M   M  A   A   GGGG  EEEEE                       %\n%                                                                             %\n%                                                                             %\n%                           MagickCore Image Methods                          %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/animate.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/cache-private.h\"\n#include \"MagickCore/cache-view.h\"\n#include \"MagickCore/client.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/composite.h\"\n#include \"MagickCore/composite-private.h\"\n#include \"MagickCore/compress.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/display.h\"\n#include \"MagickCore/draw.h\"\n#include \"MagickCore/enhance.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/gem.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/histogram.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magic.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/magick-private.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/paint.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantize.h\"\n#include \"MagickCore/random_.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/segment.h\"\n#include \"MagickCore/semaphore.h\"\n#include \"MagickCore/signature-private.h\"\n#include \"MagickCore/statistic.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/thread-private.h\"\n#include \"MagickCore/threshold.h\"\n#include \"MagickCore/timer.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/utility.h\"\n#include \"MagickCore/utility-private.h\"\n#include \"MagickCore/version.h\"\n#include \"MagickCore/xwindow-private.h\"\n\f\n/*\n  Constant declaration.\n*/\nconst char\n  AlphaColor[] = \"#bdbdbd\",  /* gray */\n  BackgroundColor[] = \"#ffffff\",  /* white */\n  BorderColor[] = \"#dfdfdf\",  /* gray */\n  DefaultTileFrame[] = \"15x15+3+3\",\n  DefaultTileGeometry[] = \"120x120+4+3>\",\n  DefaultTileLabel[] = \"%f\\n%G\\n%b\",\n  ForegroundColor[] = \"#000\",  /* black */\n  LoadImageTag[] = \"Load/Image\",\n  LoadImagesTag[] = \"Load/Images\",\n  PSDensityGeometry[] = \"72.0x72.0\",\n  PSPageGeometry[] = \"612x792\",\n  SaveImageTag[] = \"Save/Image\",\n  SaveImagesTag[] = \"Save/Images\",\n  TransparentColor[] = \"#00000000\";  /* transparent black */\n\nconst double\n  DefaultResolution = 72.0;\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   A c q u i r e I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquireImage() returns a pointer to an image structure initialized to\n%  default values.\n%\n%  The format of the AcquireImage method is:\n%\n%      Image *AcquireImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: Many of the image default values are set from this\n%      structure.  For example, filename, compression, depth, background color,\n%      and others.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *AcquireImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  const char\n    *option;\n\n  Image\n    *image;\n\n  MagickStatusType\n    flags;\n\n  /*\n    Allocate image structure.\n  */\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  image=(Image *) AcquireMagickMemory(sizeof(*image));\n  if (image == (Image *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(image,0,sizeof(*image));\n  /*\n    Initialize Image structure.\n  */\n  (void) CopyMagickString(image->magick,\"MIFF\",MagickPathExtent);\n  image->storage_class=DirectClass;\n  image->depth=MAGICKCORE_QUANTUM_DEPTH;\n  image->colorspace=sRGBColorspace;\n  image->rendering_intent=PerceptualIntent;\n  image->gamma=1.000f/2.200f;\n  image->chromaticity.red_primary.x=0.6400f;\n  image->chromaticity.red_primary.y=0.3300f;\n  image->chromaticity.red_primary.z=0.0300f;\n  image->chromaticity.green_primary.x=0.3000f;\n  image->chromaticity.green_primary.y=0.6000f;\n  image->chromaticity.green_primary.z=0.1000f;\n  image->chromaticity.blue_primary.x=0.1500f;\n  image->chromaticity.blue_primary.y=0.0600f;\n  image->chromaticity.blue_primary.z=0.7900f;\n  image->chromaticity.white_point.x=0.3127f;\n  image->chromaticity.white_point.y=0.3290f;\n  image->chromaticity.white_point.z=0.3583f;\n  image->interlace=NoInterlace;\n  image->ticks_per_second=UndefinedTicksPerSecond;\n  image->compose=OverCompositeOp;\n  (void) QueryColorCompliance(AlphaColor,AllCompliance,&image->alpha_color,\n    exception);\n  (void) QueryColorCompliance(BackgroundColor,AllCompliance,\n    &image->background_color,exception);\n  (void) QueryColorCompliance(BorderColor,AllCompliance,&image->border_color,\n    exception);\n  (void) QueryColorCompliance(TransparentColor,AllCompliance,\n    &image->transparent_color,exception);\n  GetTimerInfo(&image->timer);\n  image->cache=AcquirePixelCache(0);\n  image->channel_mask=DefaultChannels;\n  image->channel_map=AcquirePixelChannelMap();\n  image->blob=CloneBlobInfo((BlobInfo *) NULL);\n  image->timestamp=time((time_t *) NULL);\n  image->debug=IsEventLogging();\n  image->reference_count=1;\n  image->semaphore=AcquireSemaphoreInfo();\n  image->signature=MagickCoreSignature;\n  if (image_info == (ImageInfo *) NULL)\n    return(image);\n  /*\n    Transfer image info.\n  */\n  SetBlobExempt(image,image_info->file != (FILE *) NULL ? MagickTrue :\n    MagickFalse);\n  (void) CopyMagickString(image->filename,image_info->filename,\n    MagickPathExtent);\n  (void) CopyMagickString(image->magick_filename,image_info->filename,\n    MagickPathExtent);\n  (void) CopyMagickString(image->magick,image_info->magick,MagickPathExtent);\n  if (image_info->size != (char *) NULL)\n    {\n      (void) ParseAbsoluteGeometry(image_info->size,&image->extract_info);\n      image->columns=image->extract_info.width;\n      image->rows=image->extract_info.height;\n      image->offset=image->extract_info.x;\n      image->extract_info.x=0;\n      image->extract_info.y=0;\n    }\n  if (image_info->extract != (char *) NULL)\n    {\n      RectangleInfo\n        geometry;\n\n      flags=ParseAbsoluteGeometry(image_info->extract,&geometry);\n      if (((flags & XValue) != 0) || ((flags & YValue) != 0))\n        {\n          image->extract_info=geometry;\n          Swap(image->columns,image->extract_info.width);\n          Swap(image->rows,image->extract_info.height);\n        }\n    }\n  image->compression=image_info->compression;\n  image->quality=image_info->quality;\n  image->endian=image_info->endian;\n  image->interlace=image_info->interlace;\n  image->units=image_info->units;\n  if (image_info->density != (char *) NULL)\n    {\n      GeometryInfo\n        geometry_info;\n\n      flags=ParseGeometry(image_info->density,&geometry_info);\n      image->resolution.x=geometry_info.rho;\n      image->resolution.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->resolution.y=image->resolution.x;\n    }\n  if (image_info->page != (char *) NULL)\n    {\n      char\n        *geometry;\n\n      image->page=image->extract_info;\n      geometry=GetPageGeometry(image_info->page);\n      (void) ParseAbsoluteGeometry(geometry,&image->page);\n      geometry=DestroyString(geometry);\n    }\n  if (image_info->depth != 0)\n    image->depth=image_info->depth;\n  image->dither=image_info->dither;\n  image->alpha_color=image_info->alpha_color;\n  image->background_color=image_info->background_color;\n  image->border_color=image_info->border_color;\n  image->transparent_color=image_info->transparent_color;\n  image->ping=image_info->ping;\n  image->progress_monitor=image_info->progress_monitor;\n  image->client_data=image_info->client_data;\n  if (image_info->cache != (void *) NULL)\n    ClonePixelCacheMethods(image->cache,image_info->cache);\n  /*\n    Set all global options that map to per-image settings.\n  */\n  (void) SyncImageSettings(image_info,image,exception);\n  /*\n    Global options that are only set for new images.\n  */\n  option=GetImageOption(image_info,\"delay\");\n  if (option != (const char *) NULL)\n    {\n      GeometryInfo\n        geometry_info;\n\n      flags=ParseGeometry(option,&geometry_info);\n      if ((flags & GreaterValue) != 0)\n        {\n          if (image->delay > (size_t) floor(geometry_info.rho+0.5))\n            image->delay=(size_t) floor(geometry_info.rho+0.5);\n        }\n      else\n        if ((flags & LessValue) != 0)\n          {\n            if (image->delay < (size_t) floor(geometry_info.rho+0.5))\n              image->ticks_per_second=(ssize_t) floor(geometry_info.sigma+0.5);\n          }\n        else\n          image->delay=(size_t) floor(geometry_info.rho+0.5);\n      if ((flags & SigmaValue) != 0)\n        image->ticks_per_second=(ssize_t) floor(geometry_info.sigma+0.5);\n    }\n  option=GetImageOption(image_info,\"dispose\");\n  if (option != (const char *) NULL)\n    image->dispose=(DisposeType) ParseCommandOption(MagickDisposeOptions,\n      MagickFalse,option);\n  return(image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   A c q u i r e I m a g e I n f o                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquireImageInfo() allocates the ImageInfo structure.\n%\n%  The format of the AcquireImageInfo method is:\n%\n%      ImageInfo *AcquireImageInfo(void)\n%\n*/\nMagickExport ImageInfo *AcquireImageInfo(void)\n{\n  ImageInfo\n    *image_info;\n\n  image_info=(ImageInfo *) AcquireMagickMemory(sizeof(*image_info));\n  if (image_info == (ImageInfo *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  GetImageInfo(image_info);\n  return(image_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   A c q u i r e N e x t I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquireNextImage() initializes the next image in a sequence to\n%  default values.  The next member of image points to the newly allocated\n%  image.  If there is a memory shortage, next is assigned NULL.\n%\n%  The format of the AcquireNextImage method is:\n%\n%      void AcquireNextImage(const ImageInfo *image_info,Image *image,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: Many of the image default values are set from this\n%      structure.  For example, filename, compression, depth, background color,\n%      and others.\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport void AcquireNextImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  /*\n    Allocate image structure.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  image->next=AcquireImage(image_info,exception);\n  if (GetNextImageInList(image) == (Image *) NULL)\n    return;\n  (void) CopyMagickString(GetNextImageInList(image)->filename,image->filename,\n    MagickPathExtent);\n  if (image_info != (ImageInfo *) NULL)\n    (void) CopyMagickString(GetNextImageInList(image)->filename,\n      image_info->filename,MagickPathExtent);\n  DestroyBlob(GetNextImageInList(image));\n  image->next->blob=ReferenceBlob(image->blob);\n  image->next->endian=image->endian;\n  image->next->scene=image->scene+1;\n  image->next->previous=image;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     A p p e n d I m a g e s                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AppendImages() takes all images from the current image pointer to the end\n%  of the image list and appends them to each other top-to-bottom if the\n%  stack parameter is true, otherwise left-to-right.\n%\n%  The current gravity setting effects how the image is justified in the\n%  final image.\n%\n%  The format of the AppendImages method is:\n%\n%      Image *AppendImages(const Image *images,const MagickBooleanType stack,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o images: the image sequence.\n%\n%    o stack: A value other than 0 stacks the images top-to-bottom.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *AppendImages(const Image *images,\n  const MagickBooleanType stack,ExceptionInfo *exception)\n{\n#define AppendImageTag  \"Append/Image\"\n\n  CacheView\n    *append_view;\n\n  Image\n    *append_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    n;\n\n  PixelTrait\n    alpha_trait;\n\n  RectangleInfo\n    geometry;\n\n  register const Image\n    *next;\n\n  size_t\n    depth,\n    height,\n    number_images,\n    width;\n\n  ssize_t\n    x_offset,\n    y,\n    y_offset;\n\n  /*\n    Compute maximum area of appended area.\n  */\n  assert(images != (Image *) NULL);\n  assert(images->signature == MagickCoreSignature);\n  if (images->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",images->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  alpha_trait=images->alpha_trait;\n  number_images=1;\n  width=images->columns;\n  height=images->rows;\n  depth=images->depth;\n  next=GetNextImageInList(images);\n  for ( ; next != (Image *) NULL; next=GetNextImageInList(next))\n  {\n    if (next->depth > depth)\n      depth=next->depth;\n    if (next->alpha_trait != UndefinedPixelTrait)\n      alpha_trait=BlendPixelTrait;\n    number_images++;\n    if (stack != MagickFalse)\n      {\n        if (next->columns > width)\n          width=next->columns;\n        height+=next->rows;\n        continue;\n      }\n    width+=next->columns;\n    if (next->rows > height)\n      height=next->rows;\n  }\n  /*\n    Append images.\n  */\n  append_image=CloneImage(images,width,height,MagickTrue,exception);\n  if (append_image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(append_image,DirectClass,exception) == MagickFalse)\n    {\n      append_image=DestroyImage(append_image);\n      return((Image *) NULL);\n    }\n  append_image->depth=depth;\n  append_image->alpha_trait=alpha_trait;\n  (void) SetImageBackgroundColor(append_image,exception);\n  status=MagickTrue;\n  x_offset=0;\n  y_offset=0;\n  next=images;\n  append_view=AcquireAuthenticCacheView(append_image,exception);\n  for (n=0; n < (MagickOffsetType) number_images; n++)\n  {\n    CacheView\n      *image_view;\n\n    MagickBooleanType\n      proceed;\n\n    SetGeometry(append_image,&geometry);\n    GravityAdjustGeometry(next->columns,next->rows,next->gravity,&geometry);\n    if (stack != MagickFalse)\n      x_offset-=geometry.x;\n    else\n      y_offset-=geometry.y;\n    image_view=AcquireVirtualCacheView(next,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n    #pragma omp parallel for schedule(static,4) shared(status) \\\n      magick_threads(next,next,next->rows,1)\n#endif\n    for (y=0; y < (ssize_t) next->rows; y++)\n    {\n      MagickBooleanType\n        sync;\n\n      PixelInfo\n        pixel;\n\n      register const Quantum\n        *magick_restrict p;\n\n      register Quantum\n        *magick_restrict q;\n\n      register ssize_t\n        x;\n\n      if (status == MagickFalse)\n        continue;\n      p=GetCacheViewVirtualPixels(image_view,0,y,next->columns,1,exception);\n      q=QueueCacheViewAuthenticPixels(append_view,x_offset,y+y_offset,\n        next->columns,1,exception);\n      if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n        {\n          status=MagickFalse;\n          continue;\n        }\n      GetPixelInfo(next,&pixel);\n      for (x=0; x < (ssize_t) next->columns; x++)\n      {\n        if (GetPixelReadMask(next,p) == 0)\n          {\n            SetPixelBackgoundColor(append_image,q);\n            p+=GetPixelChannels(next);\n            q+=GetPixelChannels(append_image);\n            continue;\n          }\n        GetPixelInfoPixel(next,p,&pixel);\n        SetPixelViaPixelInfo(append_image,&pixel,q);\n        p+=GetPixelChannels(next);\n        q+=GetPixelChannels(append_image);\n      }\n      sync=SyncCacheViewAuthenticPixels(append_view,exception);\n      if (sync == MagickFalse)\n        status=MagickFalse;\n    }\n    image_view=DestroyCacheView(image_view);\n    if (stack == MagickFalse)\n      {\n        x_offset+=(ssize_t) next->columns;\n        y_offset=0;\n      }\n    else\n      {\n        x_offset=0;\n        y_offset+=(ssize_t) next->rows;\n      }\n    proceed=SetImageProgress(append_image,AppendImageTag,n,number_images);\n    if (proceed == MagickFalse)\n      break;\n    next=GetNextImageInList(next);\n  }\n  append_view=DestroyCacheView(append_view);\n  if (status == MagickFalse)\n    append_image=DestroyImage(append_image);\n  return(append_image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C a t c h I m a g e E x c e p t i o n                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CatchImageException() returns if no exceptions are found in the image\n%  sequence, otherwise it determines the most severe exception and reports\n%  it as a warning or error depending on the severity.\n%\n%  The format of the CatchImageException method is:\n%\n%      ExceptionType CatchImageException(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: An image sequence.\n%\n*/\nMagickExport ExceptionType CatchImageException(Image *image)\n{\n  ExceptionInfo\n    *exception;\n\n  ExceptionType\n    severity;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  exception=AcquireExceptionInfo();\n  CatchException(exception);\n  severity=exception->severity;\n  exception=DestroyExceptionInfo(exception);\n  return(severity);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C l i p I m a g e P a t h                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ClipImagePath() sets the image clip mask based any clipping path information\n%  if it exists.\n%\n%  The format of the ClipImagePath method is:\n%\n%      MagickBooleanType ClipImagePath(Image *image,const char *pathname,\n%        const MagickBooleanType inside,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o pathname: name of clipping path resource. If name is preceded by #, use\n%      clipping path numbered by name.\n%\n%    o inside: if non-zero, later operations take effect inside clipping path.\n%      Otherwise later operations take effect outside clipping path.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nMagickExport MagickBooleanType ClipImage(Image *image,ExceptionInfo *exception)\n{\n  return(ClipImagePath(image,\"#1\",MagickTrue,exception));\n}\n\nMagickExport MagickBooleanType ClipImagePath(Image *image,const char *pathname,\n  const MagickBooleanType inside,ExceptionInfo *exception)\n{\n#define ClipImagePathTag  \"ClipPath/Image\"\n\n  char\n    *property;\n\n  const char\n    *value;\n\n  Image\n    *clip_mask;\n\n  ImageInfo\n    *image_info;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(pathname != NULL);\n  property=AcquireString(pathname);\n  (void) FormatLocaleString(property,MagickPathExtent,\"8BIM:1999,2998:%s\",\n    pathname);\n  value=GetImageProperty(image,property,exception);\n  property=DestroyString(property);\n  if (value == (const char *) NULL)\n    {\n      ThrowFileException(exception,OptionError,\"NoClipPathDefined\",\n        image->filename);\n      return(MagickFalse);\n    }\n  image_info=AcquireImageInfo();\n  (void) CopyMagickString(image_info->filename,image->filename,\n     MagickPathExtent);\n  (void) ConcatenateMagickString(image_info->filename,pathname,\n    MagickPathExtent);\n  clip_mask=BlobToImage(image_info,value,strlen(value),exception);\n  image_info=DestroyImageInfo(image_info);\n  if (clip_mask == (Image *) NULL)\n    return(MagickFalse);\n  if (clip_mask->storage_class == PseudoClass)\n    {\n      (void) SyncImage(clip_mask,exception);\n      if (SetImageStorageClass(clip_mask,DirectClass,exception) == MagickFalse)\n        return(MagickFalse);\n    }\n  if (inside == MagickFalse)\n    (void) NegateImage(clip_mask,MagickFalse,exception);\n  (void) FormatLocaleString(clip_mask->magick_filename,MagickPathExtent,\n    \"8BIM:1999,2998:%s\\nPS\",pathname);\n  (void) SetImageMask(image,ReadPixelMask,clip_mask,exception);\n  clip_mask=DestroyImage(clip_mask);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C l o n e I m a g e                                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CloneImage() copies an image and returns the copy as a new image object.\n%\n%  If the specified columns and rows is 0, an exact copy of the image is\n%  returned, otherwise the pixel data is undefined and must be initialized\n%  with the QueueAuthenticPixels() and SyncAuthenticPixels() methods.  On\n%  failure, a NULL image is returned and exception describes the reason for the\n%  failure.\n%\n%  The format of the CloneImage method is:\n%\n%      Image *CloneImage(const Image *image,const size_t columns,\n%        const size_t rows,const MagickBooleanType orphan,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o columns: the number of columns in the cloned image.\n%\n%    o rows: the number of rows in the cloned image.\n%\n%    o detach:  With a value other than 0, the cloned image is detached from\n%      its parent I/O stream.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *CloneImage(const Image *image,const size_t columns,\n  const size_t rows,const MagickBooleanType detach,ExceptionInfo *exception)\n{\n  Image\n    *clone_image;\n\n  double\n    scale;\n\n  size_t\n    length;\n\n  /*\n    Clone the image.\n  */\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if ((image->columns == 0) || (image->rows == 0))\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,\n        \"NegativeOrZeroImageSize\",\"`%s'\",image->filename);\n      return((Image *) NULL);\n    }\n  clone_image=(Image *) AcquireMagickMemory(sizeof(*clone_image));\n  if (clone_image == (Image *) NULL)\n    ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(clone_image,0,sizeof(*clone_image));\n  clone_image->signature=MagickCoreSignature;\n  clone_image->storage_class=image->storage_class;\n  clone_image->number_channels=image->number_channels;\n  clone_image->number_meta_channels=image->number_meta_channels;\n  clone_image->metacontent_extent=image->metacontent_extent;\n  clone_image->colorspace=image->colorspace;\n  clone_image->read_mask=image->read_mask;\n  clone_image->write_mask=image->write_mask;\n  clone_image->alpha_trait=image->alpha_trait;\n  clone_image->columns=image->columns;\n  clone_image->rows=image->rows;\n  clone_image->dither=image->dither;\n  if (image->colormap != (PixelInfo *) NULL)\n    {\n      /*\n        Allocate and copy the image colormap.\n      */\n      clone_image->colors=image->colors;\n      length=(size_t) image->colors;\n      clone_image->colormap=(PixelInfo *) AcquireQuantumMemory(length,\n        sizeof(*clone_image->colormap));\n      if (clone_image->colormap == (PixelInfo *) NULL)\n        ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\");\n      (void) CopyMagickMemory(clone_image->colormap,image->colormap,length*\n        sizeof(*clone_image->colormap));\n    }\n  clone_image->image_info=CloneImageInfo(image->image_info);\n  (void) CloneImageProfiles(clone_image,image);\n  (void) CloneImageProperties(clone_image,image);\n  (void) CloneImageArtifacts(clone_image,image);\n  GetTimerInfo(&clone_image->timer);\n  if (image->ascii85 != (void *) NULL)\n    Ascii85Initialize(clone_image);\n  clone_image->magick_columns=image->magick_columns;\n  clone_image->magick_rows=image->magick_rows;\n  clone_image->type=image->type;\n  clone_image->channel_mask=image->channel_mask;\n  clone_image->channel_map=ClonePixelChannelMap(image->channel_map);\n  (void) CopyMagickString(clone_image->magick_filename,image->magick_filename,\n    MagickPathExtent);\n  (void) CopyMagickString(clone_image->magick,image->magick,MagickPathExtent);\n  (void) CopyMagickString(clone_image->filename,image->filename,\n    MagickPathExtent);\n  clone_image->progress_monitor=image->progress_monitor;\n  clone_image->client_data=image->client_data;\n  clone_image->reference_count=1;\n  clone_image->next=image->next;\n  clone_image->previous=image->previous;\n  clone_image->list=NewImageList();\n  if (detach == MagickFalse)\n    clone_image->blob=ReferenceBlob(image->blob);\n  else\n    {\n      clone_image->next=NewImageList();\n      clone_image->previous=NewImageList();\n      clone_image->blob=CloneBlobInfo((BlobInfo *) NULL);\n    }\n  clone_image->ping=image->ping;\n  clone_image->debug=IsEventLogging();\n  clone_image->semaphore=AcquireSemaphoreInfo();\n  if ((columns == 0) || (rows == 0))\n    {\n      if (image->montage != (char *) NULL)\n        (void) CloneString(&clone_image->montage,image->montage);\n      if (image->directory != (char *) NULL)\n        (void) CloneString(&clone_image->directory,image->directory);\n      clone_image->cache=ReferencePixelCache(image->cache);\n      return(clone_image);\n    }\n  scale=1.0;\n  if (image->columns != 0)\n    scale=(double) columns/(double) image->columns;\n  clone_image->page.width=(size_t) floor(scale*image->page.width+0.5);\n  clone_image->page.x=(ssize_t) ceil(scale*image->page.x-0.5);\n  clone_image->tile_offset.x=(ssize_t) ceil(scale*image->tile_offset.x-0.5);\n  scale=1.0;\n  if (image->rows != 0)\n    scale=(double) rows/(double) image->rows;\n  clone_image->page.height=(size_t) floor(scale*image->page.height+0.5);\n  clone_image->page.y=(ssize_t) ceil(scale*image->page.y-0.5);\n  clone_image->tile_offset.y=(ssize_t) ceil(scale*image->tile_offset.y-0.5);\n  clone_image->columns=columns;\n  clone_image->rows=rows;\n  clone_image->cache=ClonePixelCache(image->cache);\n  return(clone_image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C l o n e I m a g e I n f o                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CloneImageInfo() makes a copy of the given image info structure.  If\n%  NULL is specified, a new image info structure is created initialized to\n%  default values.\n%\n%  The format of the CloneImageInfo method is:\n%\n%      ImageInfo *CloneImageInfo(const ImageInfo *image_info)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n*/\nMagickExport ImageInfo *CloneImageInfo(const ImageInfo *image_info)\n{\n  ImageInfo\n    *clone_info;\n\n  clone_info=AcquireImageInfo();\n  if (image_info == (ImageInfo *) NULL)\n    return(clone_info);\n  clone_info->compression=image_info->compression;\n  clone_info->temporary=image_info->temporary;\n  clone_info->adjoin=image_info->adjoin;\n  clone_info->antialias=image_info->antialias;\n  clone_info->scene=image_info->scene;\n  clone_info->number_scenes=image_info->number_scenes;\n  clone_info->depth=image_info->depth;\n  (void) CloneString(&clone_info->size,image_info->size);\n  (void) CloneString(&clone_info->extract,image_info->extract);\n  (void) CloneString(&clone_info->scenes,image_info->scenes);\n  (void) CloneString(&clone_info->page,image_info->page);\n  clone_info->interlace=image_info->interlace;\n  clone_info->endian=image_info->endian;\n  clone_info->units=image_info->units;\n  clone_info->quality=image_info->quality;\n  (void) CloneString(&clone_info->sampling_factor,image_info->sampling_factor);\n  (void) CloneString(&clone_info->server_name,image_info->server_name);\n  (void) CloneString(&clone_info->font,image_info->font);\n  (void) CloneString(&clone_info->texture,image_info->texture);\n  (void) CloneString(&clone_info->density,image_info->density);\n  clone_info->pointsize=image_info->pointsize;\n  clone_info->fuzz=image_info->fuzz;\n  clone_info->alpha_color=image_info->alpha_color;\n  clone_info->background_color=image_info->background_color;\n  clone_info->border_color=image_info->border_color;\n  clone_info->transparent_color=image_info->transparent_color;\n  clone_info->dither=image_info->dither;\n  clone_info->monochrome=image_info->monochrome;\n  clone_info->colorspace=image_info->colorspace;\n  clone_info->type=image_info->type;\n  clone_info->orientation=image_info->orientation;\n  clone_info->ping=image_info->ping;\n  clone_info->verbose=image_info->verbose;\n  clone_info->progress_monitor=image_info->progress_monitor;\n  clone_info->client_data=image_info->client_data;\n  clone_info->cache=image_info->cache;\n  if (image_info->cache != (void *) NULL)\n    clone_info->cache=ReferencePixelCache(image_info->cache);\n  if (image_info->profile != (void *) NULL)\n    clone_info->profile=(void *) CloneStringInfo((StringInfo *)\n      image_info->profile);\n  SetImageInfoFile(clone_info,image_info->file);\n  SetImageInfoBlob(clone_info,image_info->blob,image_info->length);\n  clone_info->stream=image_info->stream;\n  (void) CopyMagickString(clone_info->magick,image_info->magick,\n    MagickPathExtent);\n  (void) CopyMagickString(clone_info->unique,image_info->unique,\n    MagickPathExtent);\n  (void) CopyMagickString(clone_info->filename,image_info->filename,\n    MagickPathExtent);\n  clone_info->channel=image_info->channel;\n  (void) CloneImageOptions(clone_info,image_info);\n  clone_info->debug=IsEventLogging();\n  clone_info->signature=image_info->signature;\n  return(clone_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C o p y I m a g e P i x e l s                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CopyImagePixels() copies pixels from the source image as defined by the\n%  geometry the destination image at the specified offset.\n%\n%  The format of the CopyImagePixels method is:\n%\n%      MagickBooleanType CopyImagePixels(Image *image,const Image *source_image,\n%        const RectangleInfo *geometry,const OffsetInfo *offset,\n%        ExceptionInfo *exception);\n%\n%  A description of each parameter follows:\n%\n%    o image: the destination image.\n%\n%    o source_image: the source image.\n%\n%    o geometry: define the dimensions of the source pixel rectangle.\n%\n%    o offset: define the offset in the destination image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType CopyImagePixels(Image *image,\n  const Image *source_image,const RectangleInfo *geometry,\n  const OffsetInfo *offset,ExceptionInfo *exception)\n{\n#define CopyImageTag  \"Copy/Image\"\n\n  CacheView\n    *image_view,\n    *source_view;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(source_image != (Image *) NULL);\n  assert(geometry != (RectangleInfo *) NULL);\n  assert(offset != (OffsetInfo *) NULL);\n  if ((offset->x < 0) || (offset->y < 0) ||\n      ((ssize_t) (offset->x+geometry->width) > (ssize_t) image->columns) ||\n      ((ssize_t) (offset->y+geometry->height) > (ssize_t) image->rows))\n    ThrowBinaryException(OptionError,\"GeometryDoesNotContainImage\",\n      image->filename);\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    return(MagickFalse);\n  /*\n    Copy image pixels.\n  */\n  status=MagickTrue;\n  progress=0;\n  source_view=AcquireVirtualCacheView(source_image,exception);\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(image,source_image,geometry->height,1)\n#endif\n  for (y=0; y < (ssize_t) geometry->height; y++)\n  {\n    MagickBooleanType\n      sync;\n\n    register const Quantum\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    register Quantum\n      *magick_restrict q;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(source_view,geometry->x,y+geometry->y,\n      geometry->width,1,exception);\n    q=QueueCacheViewAuthenticPixels(image_view,offset->x,y+offset->y,\n      geometry->width,1,exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) geometry->width; x++)\n    {\n      register ssize_t\n        i;\n\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      { \n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        PixelTrait source_traits=GetPixelChannelTraits(source_image,channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (source_traits == UndefinedPixelTrait))\n          continue;\n        SetPixelChannel(image,channel,p[i],q);\n      }\n      p+=GetPixelChannels(source_image);\n      q+=GetPixelChannels(image);\n    }\n    sync=SyncCacheViewAuthenticPixels(image_view,exception);\n    if (sync == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_CopyImage)\n#endif\n        proceed=SetImageProgress(image,CopyImageTag,progress++,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  source_view=DestroyCacheView(source_view);\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e s t r o y I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyImage() dereferences an image, deallocating memory associated with\n%  the image if the reference count becomes zero.\n%\n%  The format of the DestroyImage method is:\n%\n%      Image *DestroyImage(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport Image *DestroyImage(Image *image)\n{\n  MagickBooleanType\n    destroy;\n\n  /*\n    Dereference image.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  destroy=MagickFalse;\n  LockSemaphoreInfo(image->semaphore);\n  image->reference_count--;\n  if (image->reference_count == 0)\n    destroy=MagickTrue;\n  UnlockSemaphoreInfo(image->semaphore);\n  if (destroy == MagickFalse)\n    return((Image *) NULL);\n  /*\n    Destroy image.\n  */\n  DestroyImagePixels(image);\n  image->channel_map=DestroyPixelChannelMap(image->channel_map);\n  if (image->montage != (char *) NULL)\n    image->montage=DestroyString(image->montage);\n  if (image->directory != (char *) NULL)\n    image->directory=DestroyString(image->directory);\n  if (image->colormap != (PixelInfo *) NULL)\n    image->colormap=(PixelInfo *) RelinquishMagickMemory(image->colormap);\n  if (image->geometry != (char *) NULL)\n    image->geometry=DestroyString(image->geometry);\n  DestroyImageProfiles(image);\n  DestroyImageProperties(image);\n  DestroyImageArtifacts(image);\n  if (image->ascii85 != (Ascii85Info *) NULL)\n    image->ascii85=(Ascii85Info *) RelinquishMagickMemory(image->ascii85);\n  if (image->image_info != (ImageInfo *) NULL)\n    image->image_info=DestroyImageInfo(image->image_info);\n  DestroyBlob(image);\n  if (image->semaphore != (SemaphoreInfo *) NULL)\n    RelinquishSemaphoreInfo(&image->semaphore);\n  image->signature=(~MagickCoreSignature);\n  image=(Image *) RelinquishMagickMemory(image);\n  return(image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e s t r o y I m a g e I n f o                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyImageInfo() deallocates memory associated with an ImageInfo\n%  structure.\n%\n%  The format of the DestroyImageInfo method is:\n%\n%      ImageInfo *DestroyImageInfo(ImageInfo *image_info)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n*/\nMagickExport ImageInfo *DestroyImageInfo(ImageInfo *image_info)\n{\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  if (image_info->size != (char *) NULL)\n    image_info->size=DestroyString(image_info->size);\n  if (image_info->extract != (char *) NULL)\n    image_info->extract=DestroyString(image_info->extract);\n  if (image_info->scenes != (char *) NULL)\n    image_info->scenes=DestroyString(image_info->scenes);\n  if (image_info->page != (char *) NULL)\n    image_info->page=DestroyString(image_info->page);\n  if (image_info->sampling_factor != (char *) NULL)\n    image_info->sampling_factor=DestroyString(\n      image_info->sampling_factor);\n  if (image_info->server_name != (char *) NULL)\n    image_info->server_name=DestroyString(\n      image_info->server_name);\n  if (image_info->font != (char *) NULL)\n    image_info->font=DestroyString(image_info->font);\n  if (image_info->texture != (char *) NULL)\n    image_info->texture=DestroyString(image_info->texture);\n  if (image_info->density != (char *) NULL)\n    image_info->density=DestroyString(image_info->density);\n  if (image_info->cache != (void *) NULL)\n    image_info->cache=DestroyPixelCache(image_info->cache);\n  if (image_info->profile != (StringInfo *) NULL)\n    image_info->profile=(void *) DestroyStringInfo((StringInfo *)\n      image_info->profile);\n  DestroyImageOptions(image_info);\n  image_info->signature=(~MagickCoreSignature);\n  image_info=(ImageInfo *) RelinquishMagickMemory(image_info);\n  return(image_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D i s a s s o c i a t e I m a g e S t r e a m                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DisassociateImageStream() disassociates the image stream.  It checks if the\n%  blob of the specified image is referenced by other images. If the reference\n%  count is higher then 1 a new blob is assigned to the specified image.\n%\n%  The format of the DisassociateImageStream method is:\n%\n%      void DisassociateImageStream(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport void DisassociateImageStream(Image *image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  DisassociateBlob(image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e I n f o                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageInfo() initializes image_info to default values.\n%\n%  The format of the GetImageInfo method is:\n%\n%      void GetImageInfo(ImageInfo *image_info)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n*/\nMagickExport void GetImageInfo(ImageInfo *image_info)\n{\n  char\n    *synchronize;\n\n  ExceptionInfo\n    *exception;\n\n  /*\n    File and image dimension members.\n  */\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image_info != (ImageInfo *) NULL);\n  (void) ResetMagickMemory(image_info,0,sizeof(*image_info));\n  image_info->adjoin=MagickTrue;\n  image_info->interlace=NoInterlace;\n  image_info->channel=DefaultChannels;\n  image_info->quality=UndefinedCompressionQuality;\n  image_info->antialias=MagickTrue;\n  image_info->dither=MagickTrue;\n  synchronize=GetEnvironmentValue(\"MAGICK_SYNCHRONIZE\");\n  if (synchronize != (const char *) NULL)\n    {\n      image_info->synchronize=IsStringTrue(synchronize);\n      synchronize=DestroyString(synchronize);\n    }\n  exception=AcquireExceptionInfo();\n  (void) QueryColorCompliance(AlphaColor,AllCompliance,&image_info->alpha_color,\n    exception);\n  (void) QueryColorCompliance(BackgroundColor,AllCompliance,\n    &image_info->background_color,exception);\n  (void) QueryColorCompliance(BorderColor,AllCompliance,\n    &image_info->border_color,exception);\n  (void) QueryColorCompliance(TransparentColor,AllCompliance,\n    &image_info->transparent_color,exception);\n  exception=DestroyExceptionInfo(exception);\n  image_info->debug=IsEventLogging();\n  image_info->signature=MagickCoreSignature;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e I n f o F i l e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageInfoFile() returns the image info file member.\n%\n%  The format of the GetImageInfoFile method is:\n%\n%      FILE *GetImageInfoFile(const ImageInfo *image_info)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n*/\nMagickExport FILE *GetImageInfoFile(const ImageInfo *image_info)\n{\n  return(image_info->file);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e M a s k                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageMask() returns the mask associated with the image.\n%\n%  The format of the GetImageMask method is:\n%\n%      Image *GetImageMask(const Image *image,const PixelMask type,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o type: the mask type, ReadPixelMask or WritePixelMask.\n%\n*/\nMagickExport Image *GetImageMask(const Image *image,const PixelMask type,\n  ExceptionInfo *exception)\n{\n  CacheView\n    *mask_view,\n    *image_view;\n\n  Image\n    *mask_image;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  /*\n    Get image mask.\n  */\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickCoreSignature);\n  mask_image=CloneImage(image,image->columns,image->rows,MagickTrue,exception);\n  if (mask_image == (Image *) NULL)\n    return((Image *) NULL);\n  status=MagickTrue;\n  mask_image->alpha_trait=UndefinedPixelTrait;\n  (void) SetImageColorspace(mask_image,GRAYColorspace,exception);\n  mask_image->read_mask=MagickFalse;\n  image_view=AcquireVirtualCacheView(image,exception);\n  mask_view=AcquireAuthenticCacheView(mask_image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const Quantum\n      *magick_restrict p;\n\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    q=GetCacheViewAuthenticPixels(mask_view,0,y,mask_image->columns,1,\n      exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      switch (type)\n      {\n        case WritePixelMask:\n        {\n          SetPixelGray(mask_image,GetPixelWriteMask(image,p),q);\n          break;\n        }\n        default:\n        {\n          SetPixelGray(mask_image,GetPixelReadMask(image,p),q);\n          break;\n        }\n      }\n      p+=GetPixelChannels(image);\n      q+=GetPixelChannels(mask_image);\n    }\n    if (SyncCacheViewAuthenticPixels(mask_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  mask_view=DestroyCacheView(mask_view);\n  image_view=DestroyCacheView(image_view);\n  if (status == MagickFalse)\n    mask_image=DestroyImage(mask_image);\n  return(mask_image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t I m a g e R e f e r e n c e C o u n t                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageReferenceCount() returns the image reference count.\n%\n%  The format of the GetReferenceCount method is:\n%\n%      ssize_t GetImageReferenceCount(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport ssize_t GetImageReferenceCount(Image *image)\n{\n  ssize_t\n    reference_count;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  LockSemaphoreInfo(image->semaphore);\n  reference_count=image->reference_count;\n  UnlockSemaphoreInfo(image->semaphore);\n  return(reference_count);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e V i r t u a l P i x e l M e t h o d                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageVirtualPixelMethod() gets the \"virtual pixels\" method for the\n%  image.  A virtual pixel is any pixel access that is outside the boundaries\n%  of the image cache.\n%\n%  The format of the GetImageVirtualPixelMethod() method is:\n%\n%      VirtualPixelMethod GetImageVirtualPixelMethod(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport VirtualPixelMethod GetImageVirtualPixelMethod(const Image *image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  return(GetPixelCacheVirtualMethod(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%  I n t e r p r e t I m a g e F i l e n a m e                                %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  InterpretImageFilename() interprets embedded characters in an image filename.\n%  The filename length is returned.\n%\n%  The format of the InterpretImageFilename method is:\n%\n%      size_t InterpretImageFilename(const ImageInfo *image_info,Image *image,\n%        const char *format,int value,char *filename,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info..\n%\n%    o image: the image.\n%\n%    o format:  A filename describing the format to use to write the numeric\n%      argument. Only the first numeric format identifier is replaced.\n%\n%    o value:  Numeric value to substitute into format filename.\n%\n%    o filename:  return the formatted filename in this character buffer.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport size_t InterpretImageFilename(const ImageInfo *image_info,\n  Image *image,const char *format,int value,char *filename,\n  ExceptionInfo *exception)\n{\n  char\n    *q;\n\n  int\n    c;\n\n  MagickBooleanType\n    canonical;\n\n  register const char\n    *p;\n\n  size_t\n    length;\n\n  canonical=MagickFalse;\n  length=0;\n  (void) CopyMagickString(filename,format,MagickPathExtent);\n  for (p=strchr(format,'%'); p != (char *) NULL; p=strchr(p+1,'%'))\n  {\n    q=(char *) p+1;\n    if (*q == '%')\n      {\n        p=q+1;\n        continue;\n      }\n    if (*q == '0')\n      {\n        ssize_t\n          foo;\n\n        foo=(ssize_t) strtol(q,&q,10);\n        (void) foo;\n      }\n    switch (*q)\n    {\n      case 'd':\n      case 'o':\n      case 'x':\n      {\n        q++;\n        c=(*q);\n        *q='\\0';\n        (void) FormatLocaleString(filename+(p-format),(size_t)\n          (MagickPathExtent-(p-format)),p,value);\n        *q=c;\n        (void) ConcatenateMagickString(filename,q,MagickPathExtent);\n        canonical=MagickTrue;\n        if (*(q-1) != '%')\n          break;\n        p++;\n        break;\n      }\n      case '[':\n      {\n        char\n          pattern[MagickPathExtent];\n\n        const char\n          *option;\n\n        register char\n          *r;\n\n        register ssize_t\n          i;\n\n        ssize_t\n          depth;\n\n        /*\n          Image option.\n        */\n        /* FUTURE: Compare update with code from InterpretImageProperties()\n           Note that a 'filename:' property should not need depth recursion.\n        */\n        if (strchr(p,']') == (char *) NULL)\n          break;\n        depth=1;\n        r=q+1;\n        for (i=0; (i < (MagickPathExtent-1L)) && (*r != '\\0'); i++)\n        {\n          if (*r == '[')\n            depth++;\n          if (*r == ']')\n            depth--;\n          if (depth <= 0)\n            break;\n          pattern[i]=(*r++);\n        }\n        pattern[i]='\\0';\n        if (LocaleNCompare(pattern,\"filename:\",9) != 0)\n          break;\n        option=(const char *) NULL;\n        if (image != (Image *) NULL)\n          option=GetImageProperty(image,pattern,exception);\n        if ((option == (const char *) NULL) && (image != (Image *) NULL))\n          option=GetImageArtifact(image,pattern);\n        if ((option == (const char *) NULL) &&\n            (image_info != (ImageInfo *) NULL))\n          option=GetImageOption(image_info,pattern);\n        if (option == (const char *) NULL)\n          break;\n        q--;\n        c=(*q);\n        *q='\\0';\n        (void) CopyMagickString(filename+(p-format-length),option,(size_t)\n          (MagickPathExtent-(p-format-length)));\n        length+=strlen(pattern)-1;\n        *q=c;\n        (void) ConcatenateMagickString(filename,r+1,MagickPathExtent);\n        canonical=MagickTrue;\n        if (*(q-1) != '%')\n          break;\n        p++;\n        break;\n      }\n      default:\n        break;\n    }\n  }\n  for (q=filename; *q != '\\0'; q++)\n    if ((*q == '%') && (*(q+1) == '%'))\n      {\n        (void) CopyMagickString(q,q+1,(size_t) (MagickPathExtent-(q-filename)));\n        canonical=MagickTrue;\n      }\n  if (canonical == MagickFalse)\n    (void) CopyMagickString(filename,format,MagickPathExtent);\n  return(strlen(filename));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s H i g h D y n a m i c R a n g e I m a g e                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsHighDynamicRangeImage() returns MagickTrue if any pixel component is\n%  non-integer or exceeds the bounds of the quantum depth (e.g. for Q16\n%  0..65535.\n%\n%  The format of the IsHighDynamicRangeImage method is:\n%\n%      MagickBooleanType IsHighDynamicRangeImage(const Image *image,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType IsHighDynamicRangeImage(const Image *image,\n  ExceptionInfo *exception)\n{\n#if !defined(MAGICKCORE_HDRI_SUPPORT)\n  (void) image;\n  (void) exception;\n  return(MagickFalse);\n#else\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=MagickTrue;\n  image_view=AcquireVirtualCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(status) \\\n    magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const Quantum\n      *p;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      if (GetPixelReadMask(image,p) == 0)\n        {\n          p+=GetPixelChannels(image);\n          continue;\n        }\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        double\n          pixel;\n\n        PixelTrait\n          traits;\n\n        traits=GetPixelChannelTraits(image,(PixelChannel) i);\n        if (traits == UndefinedPixelTrait)\n          continue;\n        pixel=(double) p[i];\n        if ((pixel < 0.0) || (pixel > QuantumRange) ||\n            (pixel != (double) ((QuantumAny) pixel)))\n          break;\n      }\n      p+=GetPixelChannels(image);\n      if (i < (ssize_t) GetPixelChannels(image))\n        status=MagickFalse;\n    }\n    if (x < (ssize_t) image->columns)\n      status=MagickFalse;\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status != MagickFalse ? MagickFalse : MagickTrue);\n#endif\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     I s I m a g e O b j e c t                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsImageObject() returns MagickTrue if the image sequence contains a valid\n%  set of image objects.\n%\n%  The format of the IsImageObject method is:\n%\n%      MagickBooleanType IsImageObject(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport MagickBooleanType IsImageObject(const Image *image)\n{\n  register const Image\n    *p;\n\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  for (p=image; p != (Image *) NULL; p=GetNextImageInList(p))\n    if (p->signature != MagickCoreSignature)\n      return(MagickFalse);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     I s T a i n t I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsTaintImage() returns MagickTrue any pixel in the image has been altered\n%  since it was first constituted.\n%\n%  The format of the IsTaintImage method is:\n%\n%      MagickBooleanType IsTaintImage(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport MagickBooleanType IsTaintImage(const Image *image)\n{\n  char\n    magick[MagickPathExtent],\n    filename[MagickPathExtent];\n\n  register const Image\n    *p;\n\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickCoreSignature);\n  (void) CopyMagickString(magick,image->magick,MagickPathExtent);\n  (void) CopyMagickString(filename,image->filename,MagickPathExtent);\n  for (p=image; p != (Image *) NULL; p=GetNextImageInList(p))\n  {\n    if (p->taint != MagickFalse)\n      return(MagickTrue);\n    if (LocaleCompare(p->magick,magick) != 0)\n      return(MagickTrue);\n    if (LocaleCompare(p->filename,filename) != 0)\n      return(MagickTrue);\n  }\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   M o d i f y I m a g e                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ModifyImage() ensures that there is only a single reference to the image\n%  to be modified, updating the provided image pointer to point to a clone of\n%  the original image if necessary.\n%\n%  The format of the ModifyImage method is:\n%\n%      MagickBooleanType ModifyImage(Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType ModifyImage(Image **image,\n  ExceptionInfo *exception)\n{\n  Image\n    *clone_image;\n\n  assert(image != (Image **) NULL);\n  assert(*image != (Image *) NULL);\n  assert((*image)->signature == MagickCoreSignature);\n  if ((*image)->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",(*image)->filename);\n  if (GetImageReferenceCount(*image) <= 1)\n    return(MagickTrue);\n  clone_image=CloneImage(*image,0,0,MagickTrue,exception);\n  LockSemaphoreInfo((*image)->semaphore);\n  (*image)->reference_count--;\n  UnlockSemaphoreInfo((*image)->semaphore);\n  *image=clone_image;\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   N e w M a g i c k I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  NewMagickImage() creates a blank image canvas of the specified size and\n%  background color.\n%\n%  The format of the NewMagickImage method is:\n%\n%      Image *NewMagickImage(const ImageInfo *image_info,const size_t width,\n%        const size_t height,const PixelInfo *background,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o width: the image width.\n%\n%    o height: the image height.\n%\n%    o background: the image color.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *NewMagickImage(const ImageInfo *image_info,\n  const size_t width,const size_t height,const PixelInfo *background,\n  ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  assert(image_info != (const ImageInfo *) NULL);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image_info->signature == MagickCoreSignature);\n  assert(background != (const PixelInfo *) NULL);\n  image=AcquireImage(image_info,exception);\n  image->columns=width;\n  image->rows=height;\n  image->colorspace=background->colorspace;\n  image->alpha_trait=background->alpha_trait;\n  image->fuzz=background->fuzz;\n  image->depth=background->depth;\n  status=MagickTrue;\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(status) \\\n    magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=QueueCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      SetPixelViaPixelInfo(image,background,q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  image_view=DestroyCacheView(image_view);\n  if (status == MagickFalse)\n    image=DestroyImage(image);\n  return(image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e f e r e n c e I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReferenceImage() increments the reference count associated with an image\n%  returning a pointer to the image.\n%\n%  The format of the ReferenceImage method is:\n%\n%      Image *ReferenceImage(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport Image *ReferenceImage(Image *image)\n{\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickCoreSignature);\n  LockSemaphoreInfo(image->semaphore);\n  image->reference_count++;\n  UnlockSemaphoreInfo(image->semaphore);\n  return(image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e s e t I m a g e P a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ResetImagePage() resets the image page canvas and position.\n%\n%  The format of the ResetImagePage method is:\n%\n%      MagickBooleanType ResetImagePage(Image *image,const char *page)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o page: the relative page specification.\n%\n*/\nMagickExport MagickBooleanType ResetImagePage(Image *image,const char *page)\n{\n  MagickStatusType\n    flags;\n\n  RectangleInfo\n    geometry;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  flags=ParseAbsoluteGeometry(page,&geometry);\n  if ((flags & WidthValue) != 0)\n    {\n      if ((flags & HeightValue) == 0)\n        geometry.height=geometry.width;\n      image->page.width=geometry.width;\n      image->page.height=geometry.height;\n    }\n  if ((flags & AspectValue) != 0)\n    {\n      if ((flags & XValue) != 0)\n        image->page.x+=geometry.x;\n      if ((flags & YValue) != 0)\n        image->page.y+=geometry.y;\n    }\n  else\n    {\n      if ((flags & XValue) != 0)\n        {\n          image->page.x=geometry.x;\n          if ((image->page.width == 0) && (geometry.x > 0))\n            image->page.width=image->columns+geometry.x;\n        }\n      if ((flags & YValue) != 0)\n        {\n          image->page.y=geometry.y;\n          if ((image->page.height == 0) && (geometry.y > 0))\n            image->page.height=image->rows+geometry.y;\n        }\n    }\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t I m a g e B a c k g r o u n d C o l o r                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageBackgroundColor() initializes the image pixels to the image\n%  background color.  The background color is defined by the background_color\n%  member of the image structure.\n%\n%  The format of the SetImage method is:\n%\n%      MagickBooleanType SetImageBackgroundColor(Image *image,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType SetImageBackgroundColor(Image *image,\n  ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  PixelInfo\n    background;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickCoreSignature);\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    return(MagickFalse);\n  ConformPixelInfo(image,&image->background_color,&background,exception);\n  /*\n    Set image background color.\n  */\n  status=MagickTrue;\n  image_view=AcquireAuthenticCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=QueueCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      SetPixelViaPixelInfo(image,&background,q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t I m a g e C h a n n e l M a s k                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageChannelMask() sets the image channel mask from the specified channel\n%  mask.\n%\n%  The format of the SetImageChannelMask method is:\n%\n%      ChannelType SetImageChannelMask(Image *image,\n%        const ChannelType channel_mask)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o channel_mask: the channel mask.\n%\n*/\nMagickExport ChannelType SetImageChannelMask(Image *image,\n  const ChannelType channel_mask)\n{\n  return(SetPixelChannelMask(image,channel_mask));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t I m a g e C o l o r                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageColor() set the entire image canvas to the specified color.\n%\n%  The format of the SetImageColor method is:\n%\n%      MagickBooleanType SetImageColor(Image *image,const PixelInfo *color,\n%        ExeptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o background: the image color.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType SetImageColor(Image *image,\n  const PixelInfo *color,ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickCoreSignature);\n  assert(color != (const PixelInfo *) NULL);\n  image->colorspace=color->colorspace;\n  image->alpha_trait=color->alpha_trait;\n  image->fuzz=color->fuzz;\n  image->depth=color->depth;\n  status=MagickTrue;\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(status) \\\n    magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=QueueCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      SetPixelViaPixelInfo(image,color,q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t I m a g e S t o r a g e C l a s s                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageStorageClass() sets the image class: DirectClass for true color\n%  images or PseudoClass for colormapped images.\n%\n%  The format of the SetImageStorageClass method is:\n%\n%      MagickBooleanType SetImageStorageClass(Image *image,\n%        const ClassType storage_class,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o storage_class:  The image class.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType SetImageStorageClass(Image *image,\n  const ClassType storage_class,ExceptionInfo *exception)\n{\n  image->storage_class=storage_class;\n  return(SyncImagePixelCache(image,exception));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t I m a g e E x t e n t                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageExtent() sets the image size (i.e. columns & rows).\n%\n%  The format of the SetImageExtent method is:\n%\n%      MagickBooleanType SetImageExtent(Image *image,const size_t columns,\n%        const size_t rows,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o columns:  The image width in pixels.\n%\n%    o rows:  The image height in pixels.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType SetImageExtent(Image *image,const size_t columns,\n  const size_t rows,ExceptionInfo *exception)\n{\n  if ((columns == 0) || (rows == 0))\n    return(MagickFalse);\n  image->columns=columns;\n  image->rows=rows;\n  if (image->depth > (8*sizeof(MagickSizeType)))\n    ThrowBinaryException(ImageError,\"ImageDepthNotSupported\",image->filename);\n  return(SyncImagePixelCache(image,exception));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   S e t I m a g e I n f o                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageInfo() initializes the 'magick' field of the ImageInfo structure.\n%  It is set to a type of image format based on the prefix or suffix of the\n%  filename.  For example, 'ps:image' returns PS indicating a Postscript image.\n%  JPEG is returned for this filename: 'image.jpg'.  The filename prefix has\n%  precendence over the suffix.  Use an optional index enclosed in brackets\n%  after a file name to specify a desired scene of a multi-resolution image\n%  format like Photo CD (e.g. img0001.pcd[4]).  A True (non-zero) return value\n%  indicates success.\n%\n%  The format of the SetImageInfo method is:\n%\n%      MagickBooleanType SetImageInfo(ImageInfo *image_info,\n%        const unsigned int frames,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o frames: the number of images you intend to write.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType SetImageInfo(ImageInfo *image_info,\n  const unsigned int frames,ExceptionInfo *exception)\n{\n  char\n    component[MagickPathExtent],\n    magic[MagickPathExtent],\n    *q;\n\n  const MagicInfo\n    *magic_info;\n\n  const MagickInfo\n    *magick_info;\n\n  ExceptionInfo\n    *sans_exception;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  register const char\n    *p;\n\n  ssize_t\n    count;\n\n  /*\n    Look for 'image.format' in filename.\n  */\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  *component='\\0';\n  GetPathComponent(image_info->filename,SubimagePath,component);\n  if (*component != '\\0')\n    {\n      /*\n        Look for scene specification (e.g. img0001.pcd[4]).\n      */\n      if (IsSceneGeometry(component,MagickFalse) == MagickFalse)\n        {\n          if (IsGeometry(component) != MagickFalse)\n            (void) CloneString(&image_info->extract,component);\n        }\n      else\n        {\n          size_t\n            first,\n            last;\n\n          (void) CloneString(&image_info->scenes,component);\n          image_info->scene=StringToUnsignedLong(image_info->scenes);\n          image_info->number_scenes=image_info->scene;\n          p=image_info->scenes;\n          for (q=(char *) image_info->scenes; *q != '\\0'; p++)\n          {\n            while ((isspace((int) ((unsigned char) *p)) != 0) || (*p == ','))\n              p++;\n            first=(size_t) strtol(p,&q,10);\n            last=first;\n            while (isspace((int) ((unsigned char) *q)) != 0)\n              q++;\n            if (*q == '-')\n              last=(size_t) strtol(q+1,&q,10);\n            if (first > last)\n              Swap(first,last);\n            if (first < image_info->scene)\n              image_info->scene=first;\n            if (last > image_info->number_scenes)\n              image_info->number_scenes=last;\n            p=q;\n          }\n          image_info->number_scenes-=image_info->scene-1;\n        }\n    }\n  *component='\\0';\n  if (*image_info->magick == '\\0')\n    GetPathComponent(image_info->filename,ExtensionPath,component);\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n  if (*component != '\\0')\n    if ((LocaleCompare(component,\"gz\") == 0) ||\n        (LocaleCompare(component,\"Z\") == 0) ||\n        (LocaleCompare(component,\"svgz\") == 0) ||\n        (LocaleCompare(component,\"wmz\") == 0))\n      {\n        char\n          path[MagickPathExtent];\n\n        (void) CopyMagickString(path,image_info->filename,MagickPathExtent);\n        path[strlen(path)-strlen(component)-1]='\\0';\n        GetPathComponent(path,ExtensionPath,component);\n      }\n#endif\n#if defined(MAGICKCORE_BZLIB_DELEGATE)\n  if (*component != '\\0')\n    if (LocaleCompare(component,\"bz2\") == 0)\n      {\n        char\n          path[MagickPathExtent];\n\n        (void) CopyMagickString(path,image_info->filename,MagickPathExtent);\n        path[strlen(path)-strlen(component)-1]='\\0';\n        GetPathComponent(path,ExtensionPath,component);\n      }\n#endif\n  image_info->affirm=MagickFalse;\n  sans_exception=AcquireExceptionInfo();\n  if (*component != '\\0')\n    {\n      MagickFormatType\n        format_type;\n\n      register ssize_t\n        i;\n\n      static const char\n        *format_type_formats[] =\n        {\n          \"AUTOTRACE\",\n          \"BROWSE\",\n          \"DCRAW\",\n          \"EDIT\",\n          \"LAUNCH\",\n          \"MPEG:DECODE\",\n          \"MPEG:ENCODE\",\n          \"PRINT\",\n          \"PS:ALPHA\",\n          \"PS:CMYK\",\n          \"PS:COLOR\",\n          \"PS:GRAY\",\n          \"PS:MONO\",\n          \"SCAN\",\n          \"SHOW\",\n          \"WIN\",\n          (char *) NULL\n        };\n\n      /*\n        User specified image format.\n      */\n      (void) CopyMagickString(magic,component,MagickPathExtent);\n      LocaleUpper(magic);\n      /*\n        Look for explicit image formats.\n      */\n      format_type=UndefinedFormatType;\n      magick_info=GetMagickInfo(magic,sans_exception);\n      if ((magick_info != (const MagickInfo *) NULL) &&\n          (magick_info->format_type != UndefinedFormatType))\n        format_type=magick_info->format_type;\n      i=0;\n      while ((format_type == UndefinedFormatType) &&\n             (format_type_formats[i] != (char *) NULL))\n      {\n        if ((*magic == *format_type_formats[i]) &&\n            (LocaleCompare(magic,format_type_formats[i]) == 0))\n          format_type=ExplicitFormatType;\n        i++;\n      }\n      if (format_type == UndefinedFormatType)\n        (void) CopyMagickString(image_info->magick,magic,MagickPathExtent);\n      else\n        if (format_type == ExplicitFormatType)\n          {\n            image_info->affirm=MagickTrue;\n            (void) CopyMagickString(image_info->magick,magic,MagickPathExtent);\n          }\n      if (LocaleCompare(magic,\"RGB\") == 0)\n        image_info->affirm=MagickFalse;  /* maybe SGI disguised as RGB */\n    }\n  /*\n    Look for explicit 'format:image' in filename.\n  */\n  *magic='\\0';\n  GetPathComponent(image_info->filename,MagickPath,magic);\n  if (*magic == '\\0')\n    (void) CopyMagickString(magic,image_info->magick,MagickPathExtent);\n  else\n    {\n      /*\n        User specified image format.\n      */\n      LocaleUpper(magic);\n      if (IsMagickConflict(magic) == MagickFalse)\n        {\n          (void) CopyMagickString(image_info->magick,magic,MagickPathExtent);\n          image_info->affirm=MagickTrue;\n        }\n    }\n  magick_info=GetMagickInfo(magic,sans_exception);\n  sans_exception=DestroyExceptionInfo(sans_exception);\n  if ((magick_info == (const MagickInfo *) NULL) ||\n      (GetMagickEndianSupport(magick_info) == MagickFalse))\n    image_info->endian=UndefinedEndian;\n  GetPathComponent(image_info->filename,CanonicalPath,component);\n  (void) CopyMagickString(image_info->filename,component,MagickPathExtent);\n  if ((image_info->adjoin != MagickFalse) && (frames > 1))\n    {\n      /*\n        Test for multiple image support (e.g. image%02d.png).\n      */\n      (void) InterpretImageFilename(image_info,(Image *) NULL,\n        image_info->filename,(int) image_info->scene,component,exception);\n      if ((LocaleCompare(component,image_info->filename) != 0) &&\n          (strchr(component,'%') == (char *) NULL))\n        image_info->adjoin=MagickFalse;\n    }\n  if ((image_info->adjoin != MagickFalse) && (frames > 0))\n    {\n      /*\n        Some image formats do not support multiple frames per file.\n      */\n      magick_info=GetMagickInfo(magic,exception);\n      if (magick_info != (const MagickInfo *) NULL)\n        if (GetMagickAdjoin(magick_info) == MagickFalse)\n          image_info->adjoin=MagickFalse;\n    }\n  if (image_info->affirm != MagickFalse)\n    return(MagickTrue);\n  if (frames == 0)\n    {\n      unsigned char\n        *magick;\n\n      size_t\n        magick_size;\n\n      /*\n        Determine the image format from the first few bytes of the file.\n      */\n      magick_size=GetMagicPatternExtent(exception);\n      if (magick_size == 0)\n        return(MagickFalse);\n      image=AcquireImage(image_info,exception);\n      (void) CopyMagickString(image->filename,image_info->filename,\n        MagickPathExtent);\n      status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n      if (status == MagickFalse)\n        {\n          image=DestroyImage(image);\n          return(MagickFalse);\n        }\n      if ((IsBlobSeekable(image) == MagickFalse) ||\n          (IsBlobExempt(image) != MagickFalse))\n        {\n          /*\n            Copy standard input or pipe to temporary file.\n          */\n          *component='\\0';\n          status=ImageToFile(image,component,exception);\n          (void) CloseBlob(image);\n          if (status == MagickFalse)\n            {\n              image=DestroyImage(image);\n              return(MagickFalse);\n            }\n          SetImageInfoFile(image_info,(FILE *) NULL);\n          (void) CopyMagickString(image->filename,component,MagickPathExtent);\n          status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n          if (status == MagickFalse)\n            {\n              image=DestroyImage(image);\n              return(MagickFalse);\n            }\n          (void) CopyMagickString(image_info->filename,component,\n            MagickPathExtent);\n          image_info->temporary=MagickTrue;\n        }\n      magick=(unsigned char *) AcquireMagickMemory(magick_size);\n      if (magick == (unsigned char *) NULL)\n        {\n          (void) CloseBlob(image);\n          image=DestroyImage(image);\n          return(MagickFalse);\n        }\n      (void) ResetMagickMemory(magick,0,magick_size);\n      count=ReadBlob(image,magick_size,magick);\n      (void) SeekBlob(image,-((MagickOffsetType) count),SEEK_CUR);\n      (void) CloseBlob(image);\n      image=DestroyImage(image);\n      /*\n        Check magic.xml configuration file.\n      */\n      sans_exception=AcquireExceptionInfo();\n      magic_info=GetMagicInfo(magick,(size_t) count,sans_exception);\n      magick=(unsigned char *) RelinquishMagickMemory(magick);\n      if ((magic_info != (const MagicInfo *) NULL) &&\n          (GetMagicName(magic_info) != (char *) NULL))\n        {\n          /*\n            Try to use magick_info that was determined earlier by the extension\n          */\n          if ((magick_info != (const MagickInfo *) NULL) &&\n              (GetMagickUseExtension(magick_info) != MagickFalse) &&\n              (LocaleCompare(magick_info->module,GetMagicName(\n                magic_info)) == 0))\n            (void) CopyMagickString(image_info->magick,magick_info->name,\n              MagickPathExtent);\n          else\n            {\n              (void) CopyMagickString(image_info->magick,GetMagicName(\n                magic_info),MagickPathExtent);\n              magick_info=GetMagickInfo(image_info->magick,sans_exception);\n            }\n          if ((magick_info == (const MagickInfo *) NULL) ||\n              (GetMagickEndianSupport(magick_info) == MagickFalse))\n            image_info->endian=UndefinedEndian;\n          sans_exception=DestroyExceptionInfo(sans_exception);\n          return(MagickTrue);\n        }\n      magick_info=GetMagickInfo(image_info->magick,sans_exception);\n      if ((magick_info == (const MagickInfo *) NULL) ||\n          (GetMagickEndianSupport(magick_info) == MagickFalse))\n        image_info->endian=UndefinedEndian;\n      sans_exception=DestroyExceptionInfo(sans_exception);\n    }\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t I m a g e I n f o B l o b                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageInfoBlob() sets the image info blob member.\n%\n%  The format of the SetImageInfoBlob method is:\n%\n%      void SetImageInfoBlob(ImageInfo *image_info,const void *blob,\n%        const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o blob: the blob.\n%\n%    o length: the blob length.\n%\n*/\nMagickExport void SetImageInfoBlob(ImageInfo *image_info,const void *blob,\n  const size_t length)\n{\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  image_info->blob=(void *) blob;\n  image_info->length=length;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t I m a g e I n f o F i l e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageInfoFile() sets the image info file member.\n%\n%  The format of the SetImageInfoFile method is:\n%\n%      void SetImageInfoFile(ImageInfo *image_info,FILE *file)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o file: the file.\n%\n*/\nMagickExport void SetImageInfoFile(ImageInfo *image_info,FILE *file)\n{\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  image_info->file=file;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t I m a g e M a s k                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageMask() associates a mask with the image.  The mask must be the same\n%  dimensions as the image.\n%\n%  The format of the SetImageMask method is:\n%\n%      MagickBooleanType SetImageMask(Image *image,const PixelMask type,\n%        const Image *mask,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o type: the mask type, ReadPixelMask or WritePixelMask.\n%\n%    o mask: the image mask.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType SetImageMask(Image *image,const PixelMask type,\n  const Image *mask,ExceptionInfo *exception)\n{\n  CacheView\n    *mask_view,\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  /*\n    Set image mask.\n  */\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickCoreSignature);\n  if (mask == (const Image *) NULL)\n    {\n      switch (type)\n      {\n        case WritePixelMask: image->write_mask=MagickFalse; break;\n        default: image->read_mask=MagickFalse; break;\n      }\n      return(SyncImagePixelCache(image,exception));\n    }\n  switch (type)\n  {\n    case WritePixelMask: image->write_mask=MagickTrue; break;\n    default: image->read_mask=MagickTrue; break;\n  }\n  if (SyncImagePixelCache(image,exception) == MagickFalse)\n    return(MagickFalse);\n  status=MagickTrue;\n  mask_view=AcquireVirtualCacheView(mask,exception);\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(status) \\\n    magick_threads(mask,image,1,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const Quantum\n      *magick_restrict p;\n\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(mask_view,0,y,mask->columns,1,exception);\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      MagickRealType\n        intensity;\n\n      intensity=GetPixelIntensity(mask,p);\n      switch (type)\n      {\n        case WritePixelMask:\n        {\n          SetPixelWriteMask(image,ClampToQuantum(QuantumRange-intensity),q);\n          break;\n        }\n        default:\n        {\n          SetPixelReadMask(image,ClampToQuantum(QuantumRange-intensity),q);\n          break;\n        }\n      }\n      p+=GetPixelChannels(mask);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  mask_view=DestroyCacheView(mask_view);\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     S e t I m a g e A l p h a                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageAlpha() sets the alpha levels of the image.\n%\n%  The format of the SetImageAlpha method is:\n%\n%      MagickBooleanType SetImageAlpha(Image *image,const Quantum alpha,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o Alpha: the level of transparency: 0 is fully opaque and QuantumRange is\n%      fully transparent.\n%\n*/\nMagickExport MagickBooleanType SetImageAlpha(Image *image,const Quantum alpha,\n  ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickCoreSignature);\n  image->alpha_trait=BlendPixelTrait;\n  status=MagickTrue;\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(status) \\\n    magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if (GetPixelReadMask(image,q) != 0)\n        SetPixelAlpha(image,alpha,q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t I m a g e V i r t u a l P i x e l M e t h o d                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageVirtualPixelMethod() sets the \"virtual pixels\" method for the\n%  image and returns the previous setting.  A virtual pixel is any pixel access\n%  that is outside the boundaries of the image cache.\n%\n%  The format of the SetImageVirtualPixelMethod() method is:\n%\n%      VirtualPixelMethod SetImageVirtualPixelMethod(Image *image,\n%        const VirtualPixelMethod virtual_pixel_method,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o virtual_pixel_method: choose the type of virtual pixel.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport VirtualPixelMethod SetImageVirtualPixelMethod(Image *image,\n  const VirtualPixelMethod virtual_pixel_method,ExceptionInfo *exception)\n{\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  return(SetPixelCacheVirtualMethod(image,virtual_pixel_method,exception));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     S m u s h I m a g e s                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SmushImages() takes all images from the current image pointer to the end\n%  of the image list and smushes them to each other top-to-bottom if the\n%  stack parameter is true, otherwise left-to-right.\n%\n%  The current gravity setting now effects how the image is justified in the\n%  final image.\n%\n%  The format of the SmushImages method is:\n%\n%      Image *SmushImages(const Image *images,const MagickBooleanType stack,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o images: the image sequence.\n%\n%    o stack: A value other than 0 stacks the images top-to-bottom.\n%\n%    o offset: minimum distance in pixels between images.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic ssize_t SmushXGap(const Image *smush_image,const Image *images,\n  const ssize_t offset,ExceptionInfo *exception)\n{\n  CacheView\n    *left_view,\n    *right_view;\n\n  const Image\n    *left_image,\n    *right_image;\n\n  RectangleInfo\n    left_geometry,\n    right_geometry;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    y;\n\n  size_t\n    gap;\n\n  ssize_t\n    x;\n\n  if (images->previous == (Image *) NULL)\n    return(0);\n  right_image=images;\n  SetGeometry(smush_image,&right_geometry);\n  GravityAdjustGeometry(right_image->columns,right_image->rows,\n    right_image->gravity,&right_geometry);\n  left_image=images->previous;\n  SetGeometry(smush_image,&left_geometry);\n  GravityAdjustGeometry(left_image->columns,left_image->rows,\n    left_image->gravity,&left_geometry);\n  gap=right_image->columns;\n  left_view=AcquireVirtualCacheView(left_image,exception);\n  right_view=AcquireVirtualCacheView(right_image,exception);\n  for (y=0; y < (ssize_t) smush_image->rows; y++)\n  {\n    for (x=(ssize_t) left_image->columns-1; x > 0; x--)\n    {\n      p=GetCacheViewVirtualPixels(left_view,x,left_geometry.y+y,1,1,exception);\n      if ((p == (const Quantum *) NULL) ||\n          (GetPixelAlpha(left_image,p) != TransparentAlpha) ||\n          ((left_image->columns-x-1) >= gap))\n        break;\n    }\n    i=(ssize_t) left_image->columns-x-1;\n    for (x=0; x < (ssize_t) right_image->columns; x++)\n    {\n      p=GetCacheViewVirtualPixels(right_view,x,right_geometry.y+y,1,1,\n        exception);\n      if ((p == (const Quantum *) NULL) ||\n          (GetPixelAlpha(right_image,p) != TransparentAlpha) ||\n          ((x+i) >= (ssize_t) gap))\n        break;\n    }\n    if ((x+i) < (ssize_t) gap)\n      gap=(size_t) (x+i);\n  }\n  right_view=DestroyCacheView(right_view);\n  left_view=DestroyCacheView(left_view);\n  if (y < (ssize_t) smush_image->rows)\n    return(offset);\n  return((ssize_t) gap-offset);\n}\n\nstatic ssize_t SmushYGap(const Image *smush_image,const Image *images,\n  const ssize_t offset,ExceptionInfo *exception)\n{\n  CacheView\n    *bottom_view,\n    *top_view;\n\n  const Image\n    *bottom_image,\n    *top_image;\n\n  RectangleInfo\n    bottom_geometry,\n    top_geometry;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  size_t\n    gap;\n\n  ssize_t\n    y;\n\n  if (images->previous == (Image *) NULL)\n    return(0);\n  bottom_image=images;\n  SetGeometry(smush_image,&bottom_geometry);\n  GravityAdjustGeometry(bottom_image->columns,bottom_image->rows,\n    bottom_image->gravity,&bottom_geometry);\n  top_image=images->previous;\n  SetGeometry(smush_image,&top_geometry);\n  GravityAdjustGeometry(top_image->columns,top_image->rows,top_image->gravity,\n    &top_geometry);\n  gap=bottom_image->rows;\n  top_view=AcquireVirtualCacheView(top_image,exception);\n  bottom_view=AcquireVirtualCacheView(bottom_image,exception);\n  for (x=0; x < (ssize_t) smush_image->columns; x++)\n  {\n    for (y=(ssize_t) top_image->rows-1; y > 0; y--)\n    {\n      p=GetCacheViewVirtualPixels(top_view,top_geometry.x+x,y,1,1,exception);\n      if ((p == (const Quantum *) NULL) ||\n          (GetPixelAlpha(top_image,p) != TransparentAlpha) ||\n          ((top_image->rows-y-1) >= gap))\n        break;\n    }\n    i=(ssize_t) top_image->rows-y-1;\n    for (y=0; y < (ssize_t) bottom_image->rows; y++)\n    {\n      p=GetCacheViewVirtualPixels(bottom_view,bottom_geometry.x+x,y,1,1,\n        exception);\n      if ((p == (const Quantum *) NULL) ||\n          (GetPixelAlpha(bottom_image,p) != TransparentAlpha) ||\n          ((y+i) >= (ssize_t) gap))\n        break;\n    }\n    if ((y+i) < (ssize_t) gap)\n      gap=(size_t) (y+i);\n  }\n  bottom_view=DestroyCacheView(bottom_view);\n  top_view=DestroyCacheView(top_view);\n  if (x < (ssize_t) smush_image->columns)\n    return(offset);\n  return((ssize_t) gap-offset);\n}\n\nMagickExport Image *SmushImages(const Image *images,\n  const MagickBooleanType stack,const ssize_t offset,ExceptionInfo *exception)\n{\n#define SmushImageTag  \"Smush/Image\"\n\n  const Image\n    *image;\n\n  Image\n    *smush_image;\n\n  MagickBooleanType\n    proceed,\n    status;\n\n  MagickOffsetType\n    n;\n\n  PixelTrait\n    alpha_trait;\n\n  RectangleInfo\n    geometry;\n\n  register const Image\n    *next;\n\n  size_t\n    height,\n    number_images,\n    width;\n\n  ssize_t\n    x_offset,\n    y_offset;\n\n  /*\n    Compute maximum area of smushed area.\n  */\n  assert(images != (Image *) NULL);\n  assert(images->signature == MagickCoreSignature);\n  if (images->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",images->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=images;\n  alpha_trait=image->alpha_trait;\n  number_images=1;\n  width=image->columns;\n  height=image->rows;\n  next=GetNextImageInList(image);\n  for ( ; next != (Image *) NULL; next=GetNextImageInList(next))\n  {\n    if (next->alpha_trait != UndefinedPixelTrait)\n      alpha_trait=BlendPixelTrait;\n    number_images++;\n    if (stack != MagickFalse)\n      {\n        if (next->columns > width)\n          width=next->columns;\n        height+=next->rows;\n        if (next->previous != (Image *) NULL)\n          height+=offset;\n        continue;\n      }\n    width+=next->columns;\n    if (next->previous != (Image *) NULL)\n      width+=offset;\n    if (next->rows > height)\n      height=next->rows;\n  }\n  /*\n    Smush images.\n  */\n  smush_image=CloneImage(image,width,height,MagickTrue,exception);\n  if (smush_image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(smush_image,DirectClass,exception) == MagickFalse)\n    {\n      smush_image=DestroyImage(smush_image);\n      return((Image *) NULL);\n    }\n  smush_image->alpha_trait=alpha_trait;\n  (void) SetImageBackgroundColor(smush_image,exception);\n  status=MagickTrue;\n  x_offset=0;\n  y_offset=0;\n  for (n=0; n < (MagickOffsetType) number_images; n++)\n  {\n    SetGeometry(smush_image,&geometry);\n    GravityAdjustGeometry(image->columns,image->rows,image->gravity,&geometry);\n    if (stack != MagickFalse)\n      {\n        x_offset-=geometry.x;\n        y_offset-=SmushYGap(smush_image,image,offset,exception);\n      }\n    else\n      {\n        x_offset-=SmushXGap(smush_image,image,offset,exception);\n        y_offset-=geometry.y;\n      }\n    status=CompositeImage(smush_image,image,OverCompositeOp,MagickTrue,x_offset,\n      y_offset,exception);\n    proceed=SetImageProgress(image,SmushImageTag,n,number_images);\n    if (proceed == MagickFalse)\n      break;\n    if (stack == MagickFalse)\n      {\n        x_offset+=(ssize_t) image->columns;\n        y_offset=0;\n      }\n    else\n      {\n        x_offset=0;\n        y_offset+=(ssize_t) image->rows;\n      }\n    image=GetNextImageInList(image);\n  }\n  if (stack == MagickFalse)\n    smush_image->columns=(size_t) x_offset;\n  else\n    smush_image->rows=(size_t) y_offset;\n  if (status == MagickFalse)\n    smush_image=DestroyImage(smush_image);\n  return(smush_image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S t r i p I m a g e                                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  StripImage() strips an image of all profiles and comments.\n%\n%  The format of the StripImage method is:\n%\n%      MagickBooleanType StripImage(Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType StripImage(Image *image,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  (void) exception;\n  DestroyImageProfiles(image);\n  (void) DeleteImageProperty(image,\"comment\");\n  (void) DeleteImageProperty(image,\"date:create\");\n  (void) DeleteImageProperty(image,\"date:modify\");\n  status=SetImageArtifact(image,\"png:exclude-chunk\",\n    \"bKGD,cHRM,EXIF,gAMA,iCCP,iTXt,sRGB,tEXt,zCCP,zTXt,date\");\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   S y n c I m a g e                                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SyncImage() initializes the red, green, and blue intensities of each pixel\n%  as defined by the colormap index.\n%\n%  The format of the SyncImage method is:\n%\n%      MagickBooleanType SyncImage(Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline Quantum PushColormapIndex(Image *image,const Quantum index,\n  MagickBooleanType *range_exception)\n{\n  if ((size_t) index < image->colors)\n    return(index);\n  *range_exception=MagickTrue;\n  return((Quantum) 0);\n}\n\nMagickExport MagickBooleanType SyncImage(Image *image,ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    range_exception,\n    status,\n    taint;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickCoreSignature);\n  if (image->storage_class == DirectClass)\n    return(MagickFalse);\n  range_exception=MagickFalse;\n  status=MagickTrue;\n  taint=image->taint;\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(range_exception,status) \\\n    magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    Quantum\n      index;\n\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      index=PushColormapIndex(image,GetPixelIndex(image,q),&range_exception);\n      SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  image_view=DestroyCacheView(image_view);\n  image->taint=taint;\n  if ((image->ping == MagickFalse) && (range_exception != MagickFalse))\n    (void) ThrowMagickException(exception,GetMagickModule(),\n      CorruptImageWarning,\"InvalidColormapIndex\",\"`%s'\",image->filename);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S y n c I m a g e S e t t i n g s                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SyncImageSettings() syncs any image_info global options into per-image\n%  attributes.\n%\n%  Note: in IMv6 free form 'options' were always mapped into 'artifacts', so\n%  that operations and coders can find such settings.  In IMv7 if a desired\n%  per-image artifact is not set, then it will directly look for a global\n%  option as a fallback, as such this copy is no longer needed, only the\n%  link set up.\n%\n%  The format of the SyncImageSettings method is:\n%\n%      MagickBooleanType SyncImageSettings(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%      MagickBooleanType SyncImagesSettings(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nMagickExport MagickBooleanType SyncImagesSettings(ImageInfo *image_info,\n  Image *images,ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(images != (Image *) NULL);\n  assert(images->signature == MagickCoreSignature);\n  if (images->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",images->filename);\n  image=images;\n  for ( ; image != (Image *) NULL; image=GetNextImageInList(image))\n    (void) SyncImageSettings(image_info,image,exception);\n  (void) DeleteImageOption(image_info,\"page\");\n  return(MagickTrue);\n}\n\nMagickExport MagickBooleanType SyncImageSettings(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  const char\n    *option;\n\n  GeometryInfo\n    geometry_info;\n\n  MagickStatusType\n    flags;\n\n  ResolutionType\n    units;\n\n  /*\n    Sync image options.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  option=GetImageOption(image_info,\"alpha-color\");\n  if (option != (const char *) NULL)\n    (void) QueryColorCompliance(option,AllCompliance,&image->alpha_color,\n      exception);\n  option=GetImageOption(image_info,\"background\");\n  if (option != (const char *) NULL)\n    (void) QueryColorCompliance(option,AllCompliance,&image->background_color,\n      exception);\n  option=GetImageOption(image_info,\"black-point-compensation\");\n  if (option != (const char *) NULL)\n    image->black_point_compensation=(MagickBooleanType) ParseCommandOption(\n      MagickBooleanOptions,MagickFalse,option);\n  option=GetImageOption(image_info,\"blue-primary\");\n  if (option != (const char *) NULL)\n    {\n      flags=ParseGeometry(option,&geometry_info);\n      image->chromaticity.blue_primary.x=geometry_info.rho;\n      image->chromaticity.blue_primary.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->chromaticity.blue_primary.y=image->chromaticity.blue_primary.x;\n    }\n  option=GetImageOption(image_info,\"bordercolor\");\n  if (option != (const char *) NULL)\n    (void) QueryColorCompliance(option,AllCompliance,&image->border_color,\n      exception);\n  /* FUTURE: do not sync compose to per-image compose setting here */\n  option=GetImageOption(image_info,\"compose\");\n  if (option != (const char *) NULL)\n    image->compose=(CompositeOperator) ParseCommandOption(MagickComposeOptions,\n      MagickFalse,option);\n  /* -- */\n  option=GetImageOption(image_info,\"compress\");\n  if (option != (const char *) NULL)\n    image->compression=(CompressionType) ParseCommandOption(\n      MagickCompressOptions,MagickFalse,option);\n  option=GetImageOption(image_info,\"debug\");\n  if (option != (const char *) NULL)\n    image->debug=(MagickBooleanType) ParseCommandOption(MagickBooleanOptions,\n      MagickFalse,option);\n  option=GetImageOption(image_info,\"density\");\n  if (option != (const char *) NULL)\n    {\n      GeometryInfo\n        geometry_info;\n\n      flags=ParseGeometry(option,&geometry_info);\n      image->resolution.x=geometry_info.rho;\n      image->resolution.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->resolution.y=image->resolution.x;\n    }\n  option=GetImageOption(image_info,\"depth\");\n  if (option != (const char *) NULL)\n    image->depth=StringToUnsignedLong(option);\n  option=GetImageOption(image_info,\"endian\");\n  if (option != (const char *) NULL)\n    image->endian=(EndianType) ParseCommandOption(MagickEndianOptions,\n      MagickFalse,option);\n  option=GetImageOption(image_info,\"filter\");\n  if (option != (const char *) NULL)\n    image->filter=(FilterType) ParseCommandOption(MagickFilterOptions,\n      MagickFalse,option);\n  option=GetImageOption(image_info,\"fuzz\");\n  if (option != (const char *) NULL)\n    image->fuzz=StringToDoubleInterval(option,(double) QuantumRange+1.0);\n  option=GetImageOption(image_info,\"gravity\");\n  if (option != (const char *) NULL)\n    image->gravity=(GravityType) ParseCommandOption(MagickGravityOptions,\n      MagickFalse,option);\n  option=GetImageOption(image_info,\"green-primary\");\n  if (option != (const char *) NULL)\n    {\n      flags=ParseGeometry(option,&geometry_info);\n      image->chromaticity.green_primary.x=geometry_info.rho;\n      image->chromaticity.green_primary.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->chromaticity.green_primary.y=image->chromaticity.green_primary.x;\n    }\n  option=GetImageOption(image_info,\"intent\");\n  if (option != (const char *) NULL)\n    image->rendering_intent=(RenderingIntent) ParseCommandOption(\n      MagickIntentOptions,MagickFalse,option);\n  option=GetImageOption(image_info,\"intensity\");\n  if (option != (const char *) NULL)\n    image->intensity=(PixelIntensityMethod) ParseCommandOption(\n      MagickPixelIntensityOptions,MagickFalse,option);\n  option=GetImageOption(image_info,\"interlace\");\n  if (option != (const char *) NULL)\n    image->interlace=(InterlaceType) ParseCommandOption(MagickInterlaceOptions,\n      MagickFalse,option);\n  option=GetImageOption(image_info,\"interpolate\");\n  if (option != (const char *) NULL)\n    image->interpolate=(PixelInterpolateMethod) ParseCommandOption(\n      MagickInterpolateOptions,MagickFalse,option);\n  option=GetImageOption(image_info,\"loop\");\n  if (option != (const char *) NULL)\n    image->iterations=StringToUnsignedLong(option);\n  option=GetImageOption(image_info,\"orient\");\n  if (option != (const char *) NULL)\n    image->orientation=(OrientationType) ParseCommandOption(\n      MagickOrientationOptions,MagickFalse,option);\n  option=GetImageOption(image_info,\"page\");\n  if (option != (const char *) NULL)\n    {\n      char\n        *geometry;\n\n      geometry=GetPageGeometry(option);\n      flags=ParseAbsoluteGeometry(geometry,&image->page);\n      geometry=DestroyString(geometry);\n    }\n  option=GetImageOption(image_info,\"quality\");\n  if (option != (const char *) NULL)\n    image->quality=StringToUnsignedLong(option);\n  option=GetImageOption(image_info,\"red-primary\");\n  if (option != (const char *) NULL)\n    {\n      flags=ParseGeometry(option,&geometry_info);\n      image->chromaticity.red_primary.x=geometry_info.rho;\n      image->chromaticity.red_primary.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->chromaticity.red_primary.y=image->chromaticity.red_primary.x;\n    }\n  if (image_info->quality != UndefinedCompressionQuality)\n    image->quality=image_info->quality;\n  option=GetImageOption(image_info,\"scene\");\n  if (option != (const char *) NULL)\n    image->scene=StringToUnsignedLong(option);\n  option=GetImageOption(image_info,\"taint\");\n  if (option != (const char *) NULL)\n    image->taint=(MagickBooleanType) ParseCommandOption(MagickBooleanOptions,\n      MagickFalse,option);\n  option=GetImageOption(image_info,\"tile-offset\");\n  if (option != (const char *) NULL)\n    {\n      char\n        *geometry;\n\n      geometry=GetPageGeometry(option);\n      flags=ParseAbsoluteGeometry(geometry,&image->tile_offset);\n      geometry=DestroyString(geometry);\n    }\n  option=GetImageOption(image_info,\"transparent-color\");\n  if (option != (const char *) NULL)\n    (void) QueryColorCompliance(option,AllCompliance,&image->transparent_color,\n      exception);\n  option=GetImageOption(image_info,\"type\");\n  if (option != (const char *) NULL)\n    image->type=(ImageType) ParseCommandOption(MagickTypeOptions,MagickFalse,\n      option);\n  option=GetImageOption(image_info,\"units\");\n  units=image_info->units;\n  if (option != (const char *) NULL)\n    units=(ResolutionType) ParseCommandOption(MagickResolutionOptions,\n      MagickFalse,option);\n  if (units != UndefinedResolution)\n    {\n      if (image->units != units)\n        switch (image->units)\n        {\n          case PixelsPerInchResolution:\n          {\n            if (units == PixelsPerCentimeterResolution)\n              {\n                image->resolution.x/=2.54;\n                image->resolution.y/=2.54;\n              }\n            break;\n          }\n          case PixelsPerCentimeterResolution:\n          {\n            if (units == PixelsPerInchResolution)\n              {\n                image->resolution.x=(double) ((size_t) (100.0*2.54*\n                  image->resolution.x+0.5))/100.0;\n                image->resolution.y=(double) ((size_t) (100.0*2.54*\n                  image->resolution.y+0.5))/100.0;\n              }\n            break;\n          }\n          default:\n            break;\n        }\n      image->units=units;\n    }\n  option=GetImageOption(image_info,\"virtual-pixel\");\n  if (option != (const char *) NULL)\n    (void) SetImageVirtualPixelMethod(image,(VirtualPixelMethod)\n      ParseCommandOption(MagickVirtualPixelOptions,MagickFalse,option),\n      exception);\n  option=GetImageOption(image_info,\"white-point\");\n  if (option != (const char *) NULL)\n    {\n      flags=ParseGeometry(option,&geometry_info);\n      image->chromaticity.white_point.x=geometry_info.rho;\n      image->chromaticity.white_point.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->chromaticity.white_point.y=image->chromaticity.white_point.x;\n    }\n  /*\n    Pointer to allow the lookup of pre-image artifact will fallback to a global\n    option setting/define.  This saves a lot of duplication of global options\n    into per-image artifacts, while ensuring only specifically set per-image\n    artifacts are preserved when parenthesis ends.\n  */\n  if (image->image_info != (ImageInfo *) NULL)\n    image->image_info=DestroyImageInfo(image->image_info);\n  image->image_info=CloneImageInfo(image_info);\n  return(MagickTrue);\n}\n", "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                            W   W  PPPP    GGGG                              %\n%                            W   W  P   P  G                                  %\n%                            W W W  PPPP   G GGG                              %\n%                            WW WW  P      G   G                              %\n%                            W   W  P       GGG                               %\n%                                                                             %\n%                                                                             %\n%                       Read WordPerfect Image Format                         %\n%                                                                             %\n%                              Software Design                                %\n%                              Jaroslav Fojtik                                %\n%                                 June 2000                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colormap-private.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/distort.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magic.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/transform.h\"\n#include \"MagickCore/utility.h\"\n#include \"MagickCore/utility-private.h\"\n\f\ntypedef struct\n   {\n   unsigned char Red;\n   unsigned char Blue;\n   unsigned char Green;\n   } RGB_Record;\n\n/* Default palette for WPG level 1 */\nstatic const RGB_Record WPG1_Palette[256]={\n{  0,  0,  0},    {  0,  0,168},\n{  0,168,  0},    {  0,168,168},\n{168,  0,  0},    {168,  0,168},\n{168, 84,  0},    {168,168,168},\n{ 84, 84, 84},    { 84, 84,252},\n{ 84,252, 84},    { 84,252,252},\n{252, 84, 84},    {252, 84,252},\n{252,252, 84},    {252,252,252},  /*16*/\n{  0,  0,  0},    { 20, 20, 20},\n{ 32, 32, 32},    { 44, 44, 44},\n{ 56, 56, 56},    { 68, 68, 68},\n{ 80, 80, 80},    { 96, 96, 96},\n{112,112,112},    {128,128,128},\n{144,144,144},    {160,160,160},\n{180,180,180},    {200,200,200},\n{224,224,224},    {252,252,252},  /*32*/\n{  0,  0,252},    { 64,  0,252},\n{124,  0,252},    {188,  0,252},\n{252,  0,252},    {252,  0,188},\n{252,  0,124},    {252,  0, 64},\n{252,  0,  0},    {252, 64,  0},\n{252,124,  0},    {252,188,  0},\n{252,252,  0},    {188,252,  0},\n{124,252,  0},    { 64,252,  0},  /*48*/\n{  0,252,  0},    {  0,252, 64},\n{  0,252,124},    {  0,252,188},\n{  0,252,252},    {  0,188,252},\n{  0,124,252},    {  0, 64,252},\n{124,124,252},    {156,124,252},\n{188,124,252},    {220,124,252},\n{252,124,252},    {252,124,220},\n{252,124,188},    {252,124,156},  /*64*/\n{252,124,124},    {252,156,124},\n{252,188,124},    {252,220,124},\n{252,252,124},    {220,252,124},\n{188,252,124},    {156,252,124},\n{124,252,124},    {124,252,156},\n{124,252,188},    {124,252,220},\n{124,252,252},    {124,220,252},\n{124,188,252},    {124,156,252},  /*80*/\n{180,180,252},    {196,180,252},\n{216,180,252},    {232,180,252},\n{252,180,252},    {252,180,232},\n{252,180,216},    {252,180,196},\n{252,180,180},    {252,196,180},\n{252,216,180},    {252,232,180},\n{252,252,180},    {232,252,180},\n{216,252,180},    {196,252,180},  /*96*/\n{180,220,180},    {180,252,196},\n{180,252,216},    {180,252,232},\n{180,252,252},    {180,232,252},\n{180,216,252},    {180,196,252},\n{0,0,112},    {28,0,112},\n{56,0,112},    {84,0,112},\n{112,0,112},    {112,0,84},\n{112,0,56},    {112,0,28},  /*112*/\n{112,0,0},    {112,28,0},\n{112,56,0},    {112,84,0},\n{112,112,0},    {84,112,0},\n{56,112,0},    {28,112,0},\n{0,112,0},    {0,112,28},\n{0,112,56},    {0,112,84},\n{0,112,112},    {0,84,112},\n{0,56,112},    {0,28,112},   /*128*/\n{56,56,112},    {68,56,112},\n{84,56,112},    {96,56,112},\n{112,56,112},    {112,56,96},\n{112,56,84},    {112,56,68},\n{112,56,56},    {112,68,56},\n{112,84,56},    {112,96,56},\n{112,112,56},    {96,112,56},\n{84,112,56},    {68,112,56},  /*144*/\n{56,112,56},    {56,112,69},\n{56,112,84},    {56,112,96},\n{56,112,112},    {56,96,112},\n{56,84,112},    {56,68,112},\n{80,80,112},    {88,80,112},\n{96,80,112},    {104,80,112},\n{112,80,112},    {112,80,104},\n{112,80,96},    {112,80,88},  /*160*/\n{112,80,80},    {112,88,80},\n{112,96,80},    {112,104,80},\n{112,112,80},    {104,112,80},\n{96,112,80},    {88,112,80},\n{80,112,80},    {80,112,88},\n{80,112,96},    {80,112,104},\n{80,112,112},    {80,114,112},\n{80,96,112},    {80,88,112},  /*176*/\n{0,0,64},    {16,0,64},\n{32,0,64},    {48,0,64},\n{64,0,64},    {64,0,48},\n{64,0,32},    {64,0,16},\n{64,0,0},    {64,16,0},\n{64,32,0},    {64,48,0},\n{64,64,0},    {48,64,0},\n{32,64,0},    {16,64,0},  /*192*/\n{0,64,0},    {0,64,16},\n{0,64,32},    {0,64,48},\n{0,64,64},    {0,48,64},\n{0,32,64},    {0,16,64},\n{32,32,64},    {40,32,64},\n{48,32,64},    {56,32,64},\n{64,32,64},    {64,32,56},\n{64,32,48},    {64,32,40},  /*208*/\n{64,32,32},    {64,40,32},\n{64,48,32},    {64,56,32},\n{64,64,32},    {56,64,32},\n{48,64,32},    {40,64,32},\n{32,64,32},    {32,64,40},\n{32,64,48},    {32,64,56},\n{32,64,64},    {32,56,64},\n{32,48,64},    {32,40,64},  /*224*/\n{44,44,64},    {48,44,64},\n{52,44,64},    {60,44,64},\n{64,44,64},    {64,44,60},\n{64,44,52},    {64,44,48},\n{64,44,44},    {64,48,44},\n{64,52,44},    {64,60,44},\n{64,64,44},    {60,64,44},\n{52,64,44},    {48,64,44},  /*240*/\n{44,64,44},    {44,64,48},\n{44,64,52},    {44,64,60},\n{44,64,64},    {44,60,64},\n{44,55,64},    {44,48,64},\n{0,0,0},    {0,0,0},\n{0,0,0},    {0,0,0},\n{0,0,0},    {0,0,0},\n{0,0,0},    {0,0,0}    /*256*/\n};\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s W P G                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsWPG() returns True if the image format type, identified by the magick\n%  string, is WPG.\n%\n%  The format of the IsWPG method is:\n%\n%      unsigned int IsWPG(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o status:  Method IsWPG returns True if the image format type is WPG.\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic unsigned int IsWPG(const unsigned char *magick,const size_t length)\n{\n  if (length < 4)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\377WPC\",4) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n\nstatic void Rd_WP_DWORD(Image *image,size_t *d)\n{\n  unsigned char\n    b;\n\n  b=ReadBlobByte(image);\n  *d=b;\n  if (b < 0xFFU)\n    return;\n  b=ReadBlobByte(image);\n  *d=(size_t) b;\n  b=ReadBlobByte(image);\n  *d+=(size_t) b*256l;\n  if (*d < 0x8000)\n    return;\n  *d=(*d & 0x7FFF) << 16;\n  b=ReadBlobByte(image);\n  *d+=(size_t) b;\n  b=ReadBlobByte(image);\n  *d+=(size_t) b*256l;\n  return;\n}\n\nstatic void InsertRow(Image *image,unsigned char *p,ssize_t y,int bpp,\n  ExceptionInfo *exception)\n{\n  int\n    bit;\n\n  Quantum\n    index;\n\n  register Quantum\n    *q;\n\n  ssize_t\n    x;\n\n  switch (bpp)\n    {\n    case 1:  /* Convert bitmap scanline. */\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n        {\n          for (bit=0; bit < 8; bit++)\n          {\n            index=((*p) & (0x80 >> bit) ? 0x01 : 0x00);\n            SetPixelIndex(image,index,q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            q+=GetPixelChannels(image);\n          }\n          p++;\n        }\n        if ((image->columns % 8) != 0)\n          {\n            for (bit=0; bit < (ssize_t) (image->columns % 8); bit++)\n            {\n              index=((*p) & (0x80 >> bit) ? 0x01 : 0x00);\n              SetPixelIndex(image,index,q);\n              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n              q+=GetPixelChannels(image);\n            }\n            p++;\n          }\n        if (!SyncAuthenticPixels(image,exception))\n          break;\n        break;\n      }\n    case 2:  /* Convert PseudoColor scanline. */\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < ((ssize_t) image->columns-3); x+=4)\n        {\n            index=ConstrainColormapIndex(image,(*p >> 6) & 0x3,exception);\n            SetPixelIndex(image,index,q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            q+=GetPixelChannels(image);\n            index=ConstrainColormapIndex(image,(*p >> 4) & 0x3,exception);\n            SetPixelIndex(image,index,q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            q+=GetPixelChannels(image);\n            index=ConstrainColormapIndex(image,(*p >> 2) & 0x3,exception);\n            SetPixelIndex(image,index,q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            q+=GetPixelChannels(image);\n            index=ConstrainColormapIndex(image,(*p) & 0x3,exception);\n            SetPixelIndex(image,index,q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            q+=GetPixelChannels(image);\n            p++;\n        }\n       if ((image->columns % 4) != 0)\n          {\n            index=ConstrainColormapIndex(image,(*p >> 6) & 0x3,exception);\n            SetPixelIndex(image,index,q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            q+=GetPixelChannels(image);\n            if ((image->columns % 4) > 1)\n              {\n                index=ConstrainColormapIndex(image,(*p >> 4) & 0x3,exception);\n                SetPixelIndex(image,index,q);\n                SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n                q+=GetPixelChannels(image);\n                if ((image->columns % 4) > 2)\n                  {\n                    index=ConstrainColormapIndex(image,(*p >> 2) & 0x3,\n                      exception);\n                    SetPixelIndex(image,index,q);\n                    SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n                    q+=GetPixelChannels(image);\n                  }\n              }\n            p++;\n          }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        break;\n      }\n \n    case 4:  /* Convert PseudoColor scanline. */\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < ((ssize_t) image->columns-1); x+=2)\n          { \n            index=ConstrainColormapIndex(image,(*p >> 4) & 0x0f,exception);\n            SetPixelIndex(image,index,q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            q+=GetPixelChannels(image);\n            index=ConstrainColormapIndex(image,(*p) & 0x0f,exception);\n            SetPixelIndex(image,index,q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            p++;\n            q+=GetPixelChannels(image);\n          }\n        if ((image->columns % 2) != 0)\n          {\n            index=ConstrainColormapIndex(image,(*p >> 4) & 0x0f,exception);\n            SetPixelIndex(image,index,q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            p++;\n            q+=GetPixelChannels(image);\n          }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        break;\n      }\n    case 8: /* Convert PseudoColor scanline. */\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL) break;\n\n        for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            index=ConstrainColormapIndex(image,*p,exception);\n            SetPixelIndex(image,index,q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            p++;\n            q+=GetPixelChannels(image);\n          }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n      }\n      break;\n     \n    case 24:     /*  Convert DirectColor scanline.  */\n      q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n      if (q == (Quantum *) NULL)\n        break;\n      for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n          SetPixelGreen(image,ScaleCharToQuantum(*p++),q);\n          SetPixelBlue(image,ScaleCharToQuantum(*p++),q);\n          q+=GetPixelChannels(image);\n        }\n      if (!SyncAuthenticPixels(image,exception))\n        break;\n      break;\n    }\n}\n\n\n/* Helper for WPG1 raster reader. */\n#define InsertByte(b) \\\n{ \\\n  BImgBuff[x]=b; \\\n  x++; \\\n  if((ssize_t) x>=ldblk) \\\n  { \\\n    InsertRow(image,BImgBuff,(ssize_t) y,bpp,exception); \\\n    x=0; \\\n    y++; \\\n    } \\\n}\n/* WPG1 raster reader. */\nstatic int UnpackWPGRaster(Image *image,int bpp,ExceptionInfo *exception)\n{\n  int\n    x,\n    y,\n    i;\n\n  unsigned char\n    bbuf,\n    *BImgBuff,\n    RunCount;\n\n  ssize_t\n    ldblk;\n\n  x=0;\n  y=0;\n\n  ldblk=(ssize_t) ((bpp*image->columns+7)/8);\n  BImgBuff=(unsigned char *) AcquireQuantumMemory((size_t) ldblk,\n    8*sizeof(*BImgBuff));\n  if(BImgBuff==NULL) return(-2);\n\n  while(y<(ssize_t) image->rows)\n    {\n      int\n        c;\n\n      c=ReadBlobByte(image);\n      if (c == EOF)\n        break;\n      bbuf=(unsigned char) c;\n      RunCount=bbuf & 0x7F;\n      if(bbuf & 0x80)\n        {\n          if(RunCount)  /* repeat next byte runcount * */\n            {\n              bbuf=ReadBlobByte(image);\n              for(i=0;i<(int) RunCount;i++) InsertByte(bbuf);\n            }\n          else {  /* read next byte as RunCount; repeat 0xFF runcount* */\n            c=ReadBlobByte(image);\n            if (c < 0)\n              break;\n            RunCount=(unsigned char) c;\n            for(i=0;i<(int) RunCount;i++) InsertByte(0xFF);\n          }\n        }\n      else {\n        if(RunCount)   /* next runcount byte are readed directly */\n          {\n            for(i=0;i < (int) RunCount;i++)\n              {\n                bbuf=ReadBlobByte(image);\n                InsertByte(bbuf);\n              }\n          }\n        else {  /* repeat previous line runcount* */\n          c=ReadBlobByte(image);\n          if (c < 0)\n            break;\n          RunCount=(unsigned char) c;\n          if(x) {    /* attempt to duplicate row from x position: */\n            /* I do not know what to do here */\n            BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);\n            return(-3);\n          }\n          for(i=0;i < (int) RunCount;i++)\n            {\n              x=0;\n              y++;    /* Here I need to duplicate previous row RUNCOUNT* */\n              if(y<2) continue;\n              if(y>(ssize_t) image->rows)\n                {\n                  BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);\n                  return(-4);\n                }\n              InsertRow(image,BImgBuff,y-1,bpp,exception);\n            }\n        }\n      }\n      if (EOFBlob(image) != MagickFalse)\n        break;\n    }\n  BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);\n  return(y <(ssize_t) image->rows ? -5 : 0);\n}\n\n\n/* Helper for WPG2 reader. */\n#define InsertByte6(b) \\\n{ \\\nDisableMSCWarning(4310) \\\n  if(XorMe)\\\n    BImgBuff[x] = (unsigned char)~b;\\\n  else\\\n    BImgBuff[x] = b;\\\nRestoreMSCWarning \\\n  x++; \\\n  if((ssize_t) x >= ldblk) \\\n  { \\\n    InsertRow(image,BImgBuff,(ssize_t) y,bpp,exception); \\\n    x=0; \\\n    y++; \\\n   } \\\n}\n/* WPG2 raster reader. */\nstatic int UnpackWPG2Raster(Image *image,int bpp,ExceptionInfo *exception)\n{\n  int\n    RunCount,\n    XorMe = 0;\n\n  size_t\n    x,\n    y;\n\n  ssize_t\n    i,\n    ldblk;\n\n  unsigned int\n    SampleSize=1;\n\n  unsigned char\n    bbuf,\n    *BImgBuff,\n    SampleBuffer[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };\n\n  x=0;\n  y=0;\n  ldblk=(ssize_t) ((bpp*image->columns+7)/8);\n  BImgBuff=(unsigned char *) AcquireQuantumMemory((size_t) ldblk,\n    sizeof(*BImgBuff));\n  if(BImgBuff==NULL)\n    return(-2);\n\n  while( y< image->rows)\n    {\n      bbuf=ReadBlobByte(image);\n\n      switch(bbuf)\n        {\n        case 0x7D:\n          SampleSize=ReadBlobByte(image);  /* DSZ */\n          if(SampleSize>8)\n            return(-2);\n          if(SampleSize<1)\n            return(-2);\n          break;\n        case 0x7E:\n          (void) FormatLocaleFile(stderr,\n            \"\\nUnsupported WPG token XOR, please report!\");\n          XorMe=!XorMe;\n          break;\n        case 0x7F:\n          RunCount=ReadBlobByte(image);   /* BLK */\n          if (RunCount < 0)\n            break;\n          for(i=0; i < SampleSize*(RunCount+1); i++)\n            {\n              InsertByte6(0);\n            }\n          break;\n        case 0xFD:\n          RunCount=ReadBlobByte(image);   /* EXT */\n          if (RunCount < 0)\n            break;\n          for(i=0; i<= RunCount;i++)\n            for(bbuf=0; bbuf < SampleSize; bbuf++)\n              InsertByte6(SampleBuffer[bbuf]);          \n          break;\n        case 0xFE:\n          RunCount=ReadBlobByte(image);  /* RST */\n          if (RunCount < 0)\n            break;\n          if(x!=0)\n            {\n              (void) FormatLocaleFile(stderr,\n                \"\\nUnsupported WPG2 unaligned token RST x=%.20g, please report!\\n\"\n                ,(double) x);\n              return(-3);\n            }\n          {\n            /* duplicate the previous row RunCount x */\n            for(i=0;i<=RunCount;i++)\n              {      \n                InsertRow(image,BImgBuff,(ssize_t) (image->rows >= y ? y : image->rows-1),\n                          bpp,exception);\n                y++;\n              }    \n          }\n          break;\n        case 0xFF:\n          RunCount=ReadBlobByte(image);   /* WHT */\n          if (RunCount < 0)\n            break;\n          for(i=0; i < SampleSize*(RunCount+1); i++)\n            {\n              InsertByte6(0xFF);\n            }\n          break;\n        default:\n          RunCount=bbuf & 0x7F;\n\n          if(bbuf & 0x80)     /* REP */\n            {  \n              for(i=0; i < SampleSize; i++)\n                SampleBuffer[i]=ReadBlobByte(image);\n              for(i=0;i<=RunCount;i++)\n                for(bbuf=0;bbuf<SampleSize;bbuf++)\n                  InsertByte6(SampleBuffer[bbuf]);\n            }\n          else {      /* NRP */\n            for(i=0; i< SampleSize*(RunCount+1);i++)\n              {\n                bbuf=ReadBlobByte(image);\n                InsertByte6(bbuf);\n              }\n          }\n        }\n      if (EOFBlob(image) != MagickFalse)\n        break;\n    }\n  BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);\n  return(0);\n}\n\n\ntypedef float tCTM[3][3];\n\nstatic unsigned LoadWPG2Flags(Image *image,char Precision,float *Angle,tCTM *CTM)\n{\nconst unsigned char TPR=1,TRN=2,SKW=4,SCL=8,ROT=0x10,OID=0x20,LCK=0x80;\nssize_t x;\nunsigned DenX;\nunsigned Flags;\n\n (void) memset(*CTM,0,sizeof(*CTM));     /*CTM.erase();CTM.resize(3,3);*/\n (*CTM)[0][0]=1;\n (*CTM)[1][1]=1;\n (*CTM)[2][2]=1;\n\n Flags=ReadBlobLSBShort(image);\n if(Flags & LCK) (void) ReadBlobLSBLong(image);  /*Edit lock*/\n if(Flags & OID)\n  {\n  if(Precision==0)\n    {(void) ReadBlobLSBShort(image);}  /*ObjectID*/\n  else\n    {(void) ReadBlobLSBLong(image);}  /*ObjectID (Double precision)*/\n  }\n if(Flags & ROT)\n  {\n  x=ReadBlobLSBLong(image);  /*Rot Angle*/\n  if(Angle) *Angle=x/65536.0;\n  }\n if(Flags & (ROT|SCL))\n  {\n  x=ReadBlobLSBLong(image);  /*Sx*cos()*/\n  (*CTM)[0][0] = (float)x/0x10000;\n  x=ReadBlobLSBLong(image);  /*Sy*cos()*/\n  (*CTM)[1][1] = (float)x/0x10000;\n  }\n if(Flags & (ROT|SKW))\n  {\n  x=ReadBlobLSBLong(image);       /*Kx*sin()*/\n  (*CTM)[1][0] = (float)x/0x10000;\n  x=ReadBlobLSBLong(image);       /*Ky*sin()*/\n  (*CTM)[0][1] = (float)x/0x10000;\n  }\n if(Flags & TRN)\n  {\n  x=ReadBlobLSBLong(image); DenX=ReadBlobLSBShort(image);  /*Tx*/\n        if(x>=0) (*CTM)[0][2] = (float)x+(float)DenX/0x10000;\n            else (*CTM)[0][2] = (float)x-(float)DenX/0x10000;\n  x=ReadBlobLSBLong(image); DenX=ReadBlobLSBShort(image);  /*Ty*/\n  (*CTM)[1][2]=(float)x + ((x>=0)?1:-1)*(float)DenX/0x10000;\n        if(x>=0) (*CTM)[1][2] = (float)x+(float)DenX/0x10000;\n            else (*CTM)[1][2] = (float)x-(float)DenX/0x10000;\n  }\n if(Flags & TPR)\n  {\n  x=ReadBlobLSBShort(image); DenX=ReadBlobLSBShort(image);  /*Px*/\n  (*CTM)[2][0] = x + (float)DenX/0x10000;;\n  x=ReadBlobLSBShort(image);  DenX=ReadBlobLSBShort(image); /*Py*/\n  (*CTM)[2][1] = x + (float)DenX/0x10000;\n  }\n return(Flags);\n}\n\n\nstatic Image *ExtractPostscript(Image *image,const ImageInfo *image_info,\n  MagickOffsetType PS_Offset,ssize_t PS_Size,ExceptionInfo *exception)\n{\n  char\n    postscript_file[MagickPathExtent];\n\n  const MagicInfo\n    *magic_info;    \n\n  FILE\n    *ps_file;\n\n  ImageInfo\n    *clone_info;\n    \n  Image\n    *image2;\n    \n  unsigned char\n    magick[2*MagickPathExtent];    \n    \n\n  if ((clone_info=CloneImageInfo(image_info)) == NULL)\n    return(image);\n  clone_info->blob=(void *) NULL;\n  clone_info->length=0;\n\n  /* Obtain temporary file */\n  (void) AcquireUniqueFilename(postscript_file);\n  ps_file=fopen_utf8(postscript_file,\"wb\");\n  if (ps_file == (FILE *) NULL)\n    goto FINISH;\n\n  /* Copy postscript to temporary file */\n  (void) SeekBlob(image,PS_Offset,SEEK_SET);\n  (void) ReadBlob(image, 2*MagickPathExtent, magick);\n  \n  (void) SeekBlob(image,PS_Offset,SEEK_SET);\n  while(PS_Size-- > 0)\n    {\n      (void) fputc(ReadBlobByte(image),ps_file);\n    }\n  (void) fclose(ps_file);\n  \n    /* Detect file format - Check magic.mgk configuration file. */\n  magic_info=GetMagicInfo(magick,2*MagickPathExtent,exception);\n  if(magic_info == (const MagicInfo *) NULL) goto FINISH_UNL;\n  /*     printf(\"Detected:%s  \\n\",magic_info->name); */\n  if(exception->severity != UndefinedException) goto FINISH_UNL;     \n  if(magic_info->name == (char *) NULL) goto FINISH_UNL;\n    \n  (void) strncpy(clone_info->magick,magic_info->name,MagickPathExtent);\n  \n    /* Read nested image */\n  /*FormatString(clone_info->filename,\"%s:%s\",magic_info->name,postscript_file);*/\n  FormatLocaleString(clone_info->filename,MagickPathExtent,\"%s\",postscript_file);\n  image2=ReadImage(clone_info,exception);\n\n  if (!image2)\n    goto FINISH_UNL;\n\n  /*\n    Replace current image with new image while copying base image\n    attributes.\n  */\n  (void) CopyMagickMemory(image2->filename,image->filename,MagickPathExtent);\n  (void) CopyMagickMemory(image2->magick_filename,image->magick_filename,MagickPathExtent);\n  (void) CopyMagickMemory(image2->magick,image->magick,MagickPathExtent);\n  image2->depth=image->depth;\n  DestroyBlob(image2);\n  image2->blob=ReferenceBlob(image->blob);\n\n  if ((image->rows == 0) || (image->columns == 0))\n    DeleteImageFromList(&image);\n\n  AppendImageToList(&image,image2);\n\n FINISH_UNL:    \n  (void) RelinquishUniqueFileResource(postscript_file);\n FINISH:\n  DestroyImageInfo(clone_info);\n  return(image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d W P G I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  Method ReadWPGImage reads an WPG X image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadWPGImage method is:\n%\n%    Image *ReadWPGImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image:  Method ReadWPGImage returns a pointer to the image after\n%      reading. A null image is returned if there is a memory shortage or if\n%      the image cannot be read.\n%\n%    o image_info: Specifies a pointer to a ImageInfo structure.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadWPGImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  typedef struct\n  {\n    size_t FileId;\n    MagickOffsetType DataOffset;\n    unsigned int ProductType;\n    unsigned int FileType;\n    unsigned char MajorVersion;\n    unsigned char MinorVersion;\n    unsigned int EncryptKey;\n    unsigned int Reserved;\n  } WPGHeader;\n\n  typedef struct\n  {\n    unsigned char RecType;\n    size_t RecordLength;\n  } WPGRecord;\n\n  typedef struct\n  {\n    unsigned char Class;\n    unsigned char RecType;\n    size_t Extension;\n    size_t RecordLength;\n  } WPG2Record;\n\n  typedef struct\n  {\n    unsigned  HorizontalUnits;\n    unsigned  VerticalUnits;\n    unsigned char PosSizePrecision;\n  } WPG2Start;\n\n  typedef struct\n  {\n    unsigned int Width;\n    unsigned int Height;\n    unsigned int Depth;\n    unsigned int HorzRes;\n    unsigned int VertRes;\n  } WPGBitmapType1;\n\n  typedef struct\n  {\n    unsigned int Width;\n    unsigned int Height;\n    unsigned char Depth;\n    unsigned char Compression;\n  } WPG2BitmapType1;\n\n  typedef struct\n  {\n    unsigned int RotAngle;\n    unsigned int LowLeftX;\n    unsigned int LowLeftY;\n    unsigned int UpRightX;\n    unsigned int UpRightY;\n    unsigned int Width;\n    unsigned int Height;\n    unsigned int Depth;\n    unsigned int HorzRes;\n    unsigned int VertRes;\n  } WPGBitmapType2;\n\n  typedef struct\n  {\n    unsigned int StartIndex;\n    unsigned int NumOfEntries;\n  } WPGColorMapRec;\n\n  /*\n  typedef struct {\n    size_t PS_unknown1;\n    unsigned int PS_unknown2;\n    unsigned int PS_unknown3;\n  } WPGPSl1Record;  \n  */\n\n  Image\n    *image;\n\n  unsigned int\n    status;\n\n  WPGHeader\n    Header;\n\n  WPGRecord\n    Rec;\n\n  WPG2Record\n    Rec2;\n\n  WPG2Start StartWPG;\n\n  WPGBitmapType1\n    BitmapHeader1;\n\n  WPG2BitmapType1\n    Bitmap2Header1;\n\n  WPGBitmapType2\n    BitmapHeader2;\n\n  WPGColorMapRec\n    WPG_Palette;\n\n  int\n    i,\n    bpp,\n    WPG2Flags;\n\n  ssize_t\n    ldblk;\n\n  size_t\n    one;\n\n  unsigned char\n    *BImgBuff;\n\n  tCTM CTM;         /*current transform matrix*/\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  one=1;\n  image=AcquireImage(image_info,exception);\n  image->depth=8;\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read WPG image.\n  */\n  Header.FileId=ReadBlobLSBLong(image);\n  Header.DataOffset=(MagickOffsetType) ReadBlobLSBLong(image);\n  Header.ProductType=ReadBlobLSBShort(image);\n  Header.FileType=ReadBlobLSBShort(image);\n  Header.MajorVersion=ReadBlobByte(image);\n  Header.MinorVersion=ReadBlobByte(image);\n  Header.EncryptKey=ReadBlobLSBShort(image);\n  Header.Reserved=ReadBlobLSBShort(image);\n\n  if (Header.FileId!=0x435057FF || (Header.ProductType>>8)!=0x16)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (Header.EncryptKey!=0)\n    ThrowReaderException(CoderError,\"EncryptedWPGImageFileNotSupported\");\n\n  image->columns = 1;\n  image->rows = 1;\n  image->colors = 0;\n  bpp=0;\n  BitmapHeader2.RotAngle=0;\n\n  switch(Header.FileType)\n    {\n    case 1:     /* WPG level 1 */\n      while(!EOFBlob(image)) /* object parser loop */\n        {\n          (void) SeekBlob(image,Header.DataOffset,SEEK_SET);\n          if(EOFBlob(image))\n            break;\n\n          Rec.RecType=(i=ReadBlobByte(image));\n          if(i==EOF)\n            break;\n          Rd_WP_DWORD(image,&Rec.RecordLength);\n          if(EOFBlob(image))\n            break;\n\n          Header.DataOffset=TellBlob(image)+Rec.RecordLength;\n\n          switch(Rec.RecType)\n            {\n            case 0x0B: /* bitmap type 1 */\n              BitmapHeader1.Width=ReadBlobLSBShort(image);\n              BitmapHeader1.Height=ReadBlobLSBShort(image);\n              if ((BitmapHeader1.Width == 0) || (BitmapHeader1.Height == 0))\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              BitmapHeader1.Depth=ReadBlobLSBShort(image);\n              BitmapHeader1.HorzRes=ReadBlobLSBShort(image);\n              BitmapHeader1.VertRes=ReadBlobLSBShort(image);\n\n              if(BitmapHeader1.HorzRes && BitmapHeader1.VertRes)\n                {\n                  image->units=PixelsPerCentimeterResolution;\n                  image->resolution.x=BitmapHeader1.HorzRes/470.0;\n                  image->resolution.y=BitmapHeader1.VertRes/470.0;\n                }\n              image->columns=BitmapHeader1.Width;\n              image->rows=BitmapHeader1.Height;\n              bpp=BitmapHeader1.Depth;\n\n              goto UnpackRaster;\n\n            case 0x0E:  /*Color palette */\n              WPG_Palette.StartIndex=ReadBlobLSBShort(image);\n              WPG_Palette.NumOfEntries=ReadBlobLSBShort(image);\n\n              image->colors=WPG_Palette.NumOfEntries;\n              if (!AcquireImageColormap(image,image->colors,exception))\n                goto NoMemory;\n              for (i=WPG_Palette.StartIndex;\n                   i < (int)WPG_Palette.NumOfEntries; i++)\n                {\n                  image->colormap[i].red=ScaleCharToQuantum((unsigned char)\n                    ReadBlobByte(image));\n                  image->colormap[i].green=ScaleCharToQuantum((unsigned char)\n                    ReadBlobByte(image));\n                  image->colormap[i].blue=ScaleCharToQuantum((unsigned char)\n                    ReadBlobByte(image));\n                }\n              break;\n     \n            case 0x11:  /* Start PS l1 */\n              if(Rec.RecordLength > 8)\n                image=ExtractPostscript(image,image_info,\n                  TellBlob(image)+8,   /* skip PS header in the wpg */\n                  (ssize_t) Rec.RecordLength-8,exception);\n              break;     \n\n            case 0x14:  /* bitmap type 2 */\n              BitmapHeader2.RotAngle=ReadBlobLSBShort(image);\n              BitmapHeader2.LowLeftX=ReadBlobLSBShort(image);\n              BitmapHeader2.LowLeftY=ReadBlobLSBShort(image);\n              BitmapHeader2.UpRightX=ReadBlobLSBShort(image);\n              BitmapHeader2.UpRightY=ReadBlobLSBShort(image);\n              BitmapHeader2.Width=ReadBlobLSBShort(image);\n              BitmapHeader2.Height=ReadBlobLSBShort(image);\n              if ((BitmapHeader2.Width == 0) || (BitmapHeader2.Height == 0))\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              BitmapHeader2.Depth=ReadBlobLSBShort(image);\n              BitmapHeader2.HorzRes=ReadBlobLSBShort(image);\n              BitmapHeader2.VertRes=ReadBlobLSBShort(image);\n\n              image->units=PixelsPerCentimeterResolution;\n              image->page.width=(unsigned int)\n                ((BitmapHeader2.LowLeftX-BitmapHeader2.UpRightX)/470.0);\n              image->page.height=(unsigned int)\n                ((BitmapHeader2.LowLeftX-BitmapHeader2.UpRightY)/470.0);\n              image->page.x=(int) (BitmapHeader2.LowLeftX/470.0);\n              image->page.y=(int) (BitmapHeader2.LowLeftX/470.0);\n              if(BitmapHeader2.HorzRes && BitmapHeader2.VertRes)\n                {\n                  image->resolution.x=BitmapHeader2.HorzRes/470.0;\n                  image->resolution.y=BitmapHeader2.VertRes/470.0;\n                }\n              image->columns=BitmapHeader2.Width;\n              image->rows=BitmapHeader2.Height;\n              bpp=BitmapHeader2.Depth;\n\n            UnpackRaster:      \n              status=SetImageExtent(image,image->columns,image->rows,exception);\n              if (status == MagickFalse)\n                break;\n              if ((image->colors == 0) && (bpp != 24))\n                {\n                  image->colors=one << bpp;\n                  if (!AcquireImageColormap(image,image->colors,exception))\n                    {\n                    NoMemory:\n                      ThrowReaderException(ResourceLimitError,\n                        \"MemoryAllocationFailed\");\n                    }\n                  /* printf(\"Load default colormap \\n\"); */\n                  for (i=0; (i < (int) image->colors) && (i < 256); i++)\n                    {               \n                      image->colormap[i].red=ScaleCharToQuantum(WPG1_Palette[i].Red);\n                      image->colormap[i].green=ScaleCharToQuantum(WPG1_Palette[i].Green);\n                      image->colormap[i].blue=ScaleCharToQuantum(WPG1_Palette[i].Blue);\n                    }\n                }\n              else\n                {\n                  if (bpp < 24)\n                    if ( (image->colors < (one << bpp)) && (bpp != 24) )\n                      image->colormap=(PixelInfo *) ResizeQuantumMemory(\n                        image->colormap,(size_t) (one << bpp),\n                        sizeof(*image->colormap));\n                }\n          \n              if (bpp == 1)\n                {\n                  if(image->colormap[0].red==0 &&\n                     image->colormap[0].green==0 &&\n                     image->colormap[0].blue==0 &&\n                     image->colormap[1].red==0 &&\n                     image->colormap[1].green==0 &&\n                     image->colormap[1].blue==0)\n                    {  /* fix crippled monochrome palette */\n                      image->colormap[1].red =\n                        image->colormap[1].green =\n                        image->colormap[1].blue = QuantumRange;\n                    }\n                }      \n\n              if(UnpackWPGRaster(image,bpp,exception) < 0)\n                /* The raster cannot be unpacked */\n                {\n                DecompressionFailed:\n                  ThrowReaderException(CoderError,\"UnableToDecompressImage\");\n                    }\n\n              if(Rec.RecType==0x14 && BitmapHeader2.RotAngle!=0 && !image_info->ping)\n                {  \n                  /* flop command */\n                  if(BitmapHeader2.RotAngle & 0x8000)\n                    {\n                      Image\n                        *flop_image;\n\n                      flop_image = FlopImage(image, exception);\n                      if (flop_image != (Image *) NULL) {\n                        DuplicateBlob(flop_image,image);\n                        (void) RemoveLastImageFromList(&image);\n                        AppendImageToList(&image,flop_image);\n                      }\n                    }\n                  /* flip command */\n                  if(BitmapHeader2.RotAngle & 0x2000)\n                    {\n                      Image\n                        *flip_image;\n\n                      flip_image = FlipImage(image, exception);\n                      if (flip_image != (Image *) NULL) {\n                        DuplicateBlob(flip_image,image);\n                        (void) RemoveLastImageFromList(&image);\n                        AppendImageToList(&image,flip_image);\n                      }\n                    }\n                  /* rotate command */\n                  if(BitmapHeader2.RotAngle & 0x0FFF)\n                    {\n                      Image\n                        *rotate_image;\n\n                      rotate_image=RotateImage(image,(BitmapHeader2.RotAngle &\n                        0x0FFF), exception);\n                      if (rotate_image != (Image *) NULL) {\n                        DuplicateBlob(rotate_image,image);\n                        (void) RemoveLastImageFromList(&image);\n                        AppendImageToList(&image,rotate_image);\n                      }\n                    }\n                }\n\n              /* Allocate next image structure. */\n              AcquireNextImage(image_info,image,exception);\n              image->depth=8;\n              if (image->next == (Image *) NULL)\n                goto Finish;\n              image=SyncNextImageInList(image);\n              image->columns=image->rows=1;\n              image->colors=0;\n              break;\n\n            case 0x1B:  /* Postscript l2 */\n              if(Rec.RecordLength>0x3C)\n                image=ExtractPostscript(image,image_info,\n                  TellBlob(image)+0x3C,   /* skip PS l2 header in the wpg */\n                  (ssize_t) Rec.RecordLength-0x3C,exception);\n              break;\n            }\n        }\n      break;\n\n    case 2:  /* WPG level 2 */\n      (void) memset(CTM,0,sizeof(CTM));\n      StartWPG.PosSizePrecision = 0;\n      while(!EOFBlob(image)) /* object parser loop */\n        {\n          (void) SeekBlob(image,Header.DataOffset,SEEK_SET);\n          if(EOFBlob(image))\n            break;\n\n          Rec2.Class=(i=ReadBlobByte(image));\n          if(i==EOF)\n            break;\n          Rec2.RecType=(i=ReadBlobByte(image));\n          if(i==EOF)\n            break;\n          Rd_WP_DWORD(image,&Rec2.Extension);\n          Rd_WP_DWORD(image,&Rec2.RecordLength);\n          if(EOFBlob(image))\n            break;\n\n          Header.DataOffset=TellBlob(image)+Rec2.RecordLength;\n\n          switch(Rec2.RecType)\n            {\n      case 1:\n              StartWPG.HorizontalUnits=ReadBlobLSBShort(image);\n              StartWPG.VerticalUnits=ReadBlobLSBShort(image);\n              StartWPG.PosSizePrecision=ReadBlobByte(image);\n              break;\n            case 0x0C:    /* Color palette */\n              WPG_Palette.StartIndex=ReadBlobLSBShort(image);\n              WPG_Palette.NumOfEntries=ReadBlobLSBShort(image);\n\n              image->colors=WPG_Palette.NumOfEntries;\n              if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              for (i=WPG_Palette.StartIndex;\n                   i < (int)WPG_Palette.NumOfEntries; i++)\n                {\n                  image->colormap[i].red=ScaleCharToQuantum((char)\n                    ReadBlobByte(image));\n                  image->colormap[i].green=ScaleCharToQuantum((char)\n                    ReadBlobByte(image));\n                  image->colormap[i].blue=ScaleCharToQuantum((char)\n                    ReadBlobByte(image));\n                  (void) ReadBlobByte(image);   /*Opacity??*/\n                }\n              break;\n            case 0x0E:\n              Bitmap2Header1.Width=ReadBlobLSBShort(image);\n              Bitmap2Header1.Height=ReadBlobLSBShort(image);\n              if ((Bitmap2Header1.Width == 0) || (Bitmap2Header1.Height == 0))\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              Bitmap2Header1.Depth=ReadBlobByte(image);\n              Bitmap2Header1.Compression=ReadBlobByte(image);\n\n              if(Bitmap2Header1.Compression > 1)\n                continue; /*Unknown compression method */\n              switch(Bitmap2Header1.Depth)\n                {\n                case 1:\n                  bpp=1;\n                  break;\n                case 2:\n                  bpp=2;\n                  break;\n                case 3:\n                  bpp=4;\n                  break;\n                case 4:\n                  bpp=8;\n                  break;\n                case 8:\n                  bpp=24;\n                  break;\n                default:\n                  continue;  /*Ignore raster with unknown depth*/\n                }\n              image->columns=Bitmap2Header1.Width;\n              image->rows=Bitmap2Header1.Height;\n              status=SetImageExtent(image,image->columns,image->rows,exception);\n              if (status == MagickFalse)\n                break;\n\n              if ((image->colors == 0) && (bpp != 24))\n                {\n                  size_t\n                    one;\n\n                  one=1;\n                  image->colors=one << bpp;\n                  if (!AcquireImageColormap(image,image->colors,exception))\n                    goto NoMemory;\n                }\n              else\n                {\n                  if(bpp < 24)\n                    if( image->colors<(one << bpp) && bpp!=24 )\n                      image->colormap=(PixelInfo *) ResizeQuantumMemory(\n                       image->colormap,(size_t) (one << bpp),\n                       sizeof(*image->colormap));\n                }\n\n\n              switch(Bitmap2Header1.Compression)\n                {\n                case 0:    /*Uncompressed raster*/\n                  {\n                    ldblk=(ssize_t) ((bpp*image->columns+7)/8);\n                    BImgBuff=(unsigned char *) AcquireQuantumMemory((size_t)\n                      ldblk+1,sizeof(*BImgBuff));\n                    if (BImgBuff == (unsigned char *) NULL)\n                      goto NoMemory;\n\n                    for(i=0; i< (ssize_t) image->rows; i++)\n                      {\n                        (void) ReadBlob(image,ldblk,BImgBuff);\n                        InsertRow(image,BImgBuff,i,bpp,exception);\n                      }\n\n                    if(BImgBuff)\n                      BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);\n                    break;\n                  }\n                case 1:    /*RLE for WPG2 */\n                  {\n                    if( UnpackWPG2Raster(image,bpp,exception) < 0)\n                      goto DecompressionFailed;\n                    break;\n                  }   \n                }\n\n              if(CTM[0][0]<0 && !image_info->ping)\n                {    /*?? RotAngle=360-RotAngle;*/\n                  Image\n                    *flop_image;\n\n                  flop_image = FlopImage(image, exception);\n                  if (flop_image != (Image *) NULL) {\n                    DuplicateBlob(flop_image,image);\n                    (void) RemoveLastImageFromList(&image);\n                    AppendImageToList(&image,flop_image);\n                  }\n                  /* Try to change CTM according to Flip - I am not sure, must be checked.\n                     Tx(0,0)=-1;      Tx(1,0)=0;   Tx(2,0)=0;\n                     Tx(0,1)= 0;      Tx(1,1)=1;   Tx(2,1)=0;\n                     Tx(0,2)=(WPG._2Rect.X_ur+WPG._2Rect.X_ll);\n                     Tx(1,2)=0;   Tx(2,2)=1; */\n                }\n              if(CTM[1][1]<0 && !image_info->ping)\n                {    /*?? RotAngle=360-RotAngle;*/\n                  Image\n                    *flip_image;\n\n                   flip_image = FlipImage(image, exception);\n                   if (flip_image != (Image *) NULL) {\n                     DuplicateBlob(flip_image,image);\n                     (void) RemoveLastImageFromList(&image);\n                     AppendImageToList(&image,flip_image);\n                    }\n                  /* Try to change CTM according to Flip - I am not sure, must be checked.\n                     float_matrix Tx(3,3);\n                     Tx(0,0)= 1;   Tx(1,0)= 0;   Tx(2,0)=0;\n                     Tx(0,1)= 0;   Tx(1,1)=-1;   Tx(2,1)=0;\n                     Tx(0,2)= 0;   Tx(1,2)=(WPG._2Rect.Y_ur+WPG._2Rect.Y_ll);\n                     Tx(2,2)=1; */\n              }\n\n\n              /* Allocate next image structure. */\n              AcquireNextImage(image_info,image,exception);\n              image->depth=8;\n              if (image->next == (Image *) NULL)\n                goto Finish;\n              image=SyncNextImageInList(image);\n              image->columns=image->rows=1;\n              image->colors=0;\n              break;\n\n            case 0x12:  /* Postscript WPG2*/\n        i=ReadBlobLSBShort(image);\n              if(Rec2.RecordLength > (unsigned int) i)\n                image=ExtractPostscript(image,image_info,\n                  TellBlob(image)+i,    /*skip PS header in the wpg2*/\n                  (ssize_t) (Rec2.RecordLength-i-2),exception);\n              break;\n\n      case 0x1B:          /*bitmap rectangle*/\n              WPG2Flags = LoadWPG2Flags(image,StartWPG.PosSizePrecision,NULL,&CTM);\n              (void) WPG2Flags;\n              break;\n            }\n        }\n\n      break;\n\n    default:\n      {\n         ThrowReaderException(CoderError,\"DataEncodingSchemeIsNotSupported\");\n      }\n   }\n\n Finish:\n  (void) CloseBlob(image);\n\n  {\n    Image\n      *p;\n\n    ssize_t\n      scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n    /*\n      Fix scene numbers.\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=(size_t) scene++;\n  }\n  if (image == (Image *) NULL)\n    ThrowReaderException(CorruptImageError,\n      \"ImageFileDoesNotContainAnyImageData\");\n  return(image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r W P G I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  Method RegisterWPGImage adds attributes for the WPG image format to\n%  the list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterWPGImage method is:\n%\n%      size_t RegisterWPGImage(void)\n%\n*/\nModuleExport size_t RegisterWPGImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"WPG\",\"WPG\",\"Word Perfect Graphics\");\n  entry->decoder=(DecodeImageHandler *) ReadWPGImage;\n  entry->magick=(IsImageFormatHandler *) IsWPG;\n  entry->flags|=CoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r W P G I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  Method UnregisterWPGImage removes format registrations made by the\n%  WPG module from the list of supported formats.\n%\n%  The format of the UnregisterWPGImage method is:\n%\n%      UnregisterWPGImage(void)\n%\n*/\nModuleExport void UnregisterWPGImage(void)\n{\n  (void) UnregisterMagickInfo(\"WPG\");\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                      CCCC   AAA    CCCC  H   H  EEEEE                       %\n%                     C      A   A  C      H   H  E                           %\n%                     C      AAAAA  C      HHHHH  EEE                         %\n%                     C      A   A  C      H   H  E                           %\n%                      CCCC  A   A   CCCC  H   H  EEEEE                       %\n%                                                                             %\n%                                                                             %\n%                       MagickCore Pixel Cache Methods                        %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1999                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/cache-private.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/composite-private.h\"\n#include \"MagickCore/distribute-cache-private.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/memory-private.h\"\n#include \"MagickCore/nt-base-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/policy.h\"\n#include \"MagickCore/quantum.h\"\n#include \"MagickCore/random_.h\"\n#include \"MagickCore/registry.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/semaphore.h\"\n#include \"MagickCore/splay-tree.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/thread-private.h\"\n#include \"MagickCore/utility.h\"\n#include \"MagickCore/utility-private.h\"\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n#include \"zlib.h\"\n#endif\n\f\n/*\n  Define declarations.\n*/\n#define CacheTick(offset,extent)  QuantumTick((MagickOffsetType) offset,extent)\n#define IsFileDescriptorLimitExceeded() (GetMagickResource(FileResource) > \\\n  GetMagickResourceLimit(FileResource) ? MagickTrue : MagickFalse)\n\f\n/*\n  Typedef declarations.\n*/\ntypedef struct _MagickModulo\n{\n  ssize_t\n    quotient,\n    remainder;\n} MagickModulo;\n\f\n/*\n  Forward declarations.\n*/\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\nstatic Cache\n  GetImagePixelCache(Image *,const MagickBooleanType,ExceptionInfo *)\n    magick_hot_spot;\n\nstatic const Quantum\n  *GetVirtualPixelCache(const Image *,const VirtualPixelMethod,const ssize_t,\n    const ssize_t,const size_t,const size_t,ExceptionInfo *),\n  *GetVirtualPixelsCache(const Image *);\n\nstatic const void\n  *GetVirtualMetacontentFromCache(const Image *);\n\nstatic MagickBooleanType\n  GetOneAuthenticPixelFromCache(Image *,const ssize_t,const ssize_t,Quantum *,\n    ExceptionInfo *),\n  GetOneVirtualPixelFromCache(const Image *,const VirtualPixelMethod,\n    const ssize_t,const ssize_t,Quantum *,ExceptionInfo *),\n  OpenPixelCache(Image *,const MapMode,ExceptionInfo *),\n  OpenPixelCacheOnDisk(CacheInfo *,const MapMode),\n  ReadPixelCachePixels(CacheInfo *magick_restrict,NexusInfo *magick_restrict,\n    ExceptionInfo *),\n  ReadPixelCacheMetacontent(CacheInfo *magick_restrict,\n    NexusInfo *magick_restrict,ExceptionInfo *),\n  SyncAuthenticPixelsCache(Image *,ExceptionInfo *),\n  WritePixelCachePixels(CacheInfo *magick_restrict,NexusInfo *magick_restrict,\n    ExceptionInfo *),\n  WritePixelCacheMetacontent(CacheInfo *,NexusInfo *magick_restrict,\n    ExceptionInfo *);\n\nstatic Quantum\n  *GetAuthenticPixelsCache(Image *,const ssize_t,const ssize_t,const size_t,\n    const size_t,ExceptionInfo *),\n  *QueueAuthenticPixelsCache(Image *,const ssize_t,const ssize_t,const size_t,\n    const size_t,ExceptionInfo *),\n  *SetPixelCacheNexusPixels(const CacheInfo *,const MapMode,\n    const RectangleInfo *,NexusInfo *,ExceptionInfo *) magick_hot_spot;\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\f\n/*\n  Global declarations.\n*/\nstatic volatile MagickBooleanType\n  instantiate_cache = MagickFalse;\n\nstatic SemaphoreInfo\n  *cache_semaphore = (SemaphoreInfo *) NULL;\n\nstatic time_t\n  cache_epoch = 0;\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   A c q u i r e P i x e l C a c h e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquirePixelCache() acquires a pixel cache.\n%\n%  The format of the AcquirePixelCache() method is:\n%\n%      Cache AcquirePixelCache(const size_t number_threads)\n%\n%  A description of each parameter follows:\n%\n%    o number_threads: the number of nexus threads.\n%\n*/\nMagickPrivate Cache AcquirePixelCache(const size_t number_threads)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  char\n    *synchronize;\n\n  cache_info=(CacheInfo *) AcquireQuantumMemory(1,sizeof(*cache_info));\n  if (cache_info == (CacheInfo *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(cache_info,0,sizeof(*cache_info));\n  cache_info->type=UndefinedCache;\n  cache_info->mode=IOMode;\n  cache_info->colorspace=sRGBColorspace;\n  cache_info->file=(-1);\n  cache_info->id=GetMagickThreadId();\n  cache_info->number_threads=number_threads;\n  if (GetOpenMPMaximumThreads() > cache_info->number_threads)\n    cache_info->number_threads=GetOpenMPMaximumThreads();\n  if (GetMagickResourceLimit(ThreadResource) > cache_info->number_threads)\n    cache_info->number_threads=(size_t) GetMagickResourceLimit(ThreadResource);\n  if (cache_info->number_threads == 0)\n    cache_info->number_threads=1;\n  cache_info->nexus_info=AcquirePixelCacheNexus(cache_info->number_threads);\n  if (cache_info->nexus_info == (NexusInfo **) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  synchronize=GetEnvironmentValue(\"MAGICK_SYNCHRONIZE\");\n  if (synchronize != (const char *) NULL)\n    {\n      cache_info->synchronize=IsStringTrue(synchronize);\n      synchronize=DestroyString(synchronize);\n    }\n  cache_info->semaphore=AcquireSemaphoreInfo();\n  cache_info->reference_count=1;\n  cache_info->file_semaphore=AcquireSemaphoreInfo();\n  cache_info->debug=IsEventLogging();\n  cache_info->signature=MagickCoreSignature;\n  return((Cache ) cache_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   A c q u i r e P i x e l C a c h e N e x u s                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquirePixelCacheNexus() allocates the NexusInfo structure.\n%\n%  The format of the AcquirePixelCacheNexus method is:\n%\n%      NexusInfo **AcquirePixelCacheNexus(const size_t number_threads)\n%\n%  A description of each parameter follows:\n%\n%    o number_threads: the number of nexus threads.\n%\n*/\nMagickPrivate NexusInfo **AcquirePixelCacheNexus(const size_t number_threads)\n{\n  NexusInfo\n    **magick_restrict nexus_info;\n\n  register ssize_t\n    i;\n\n  nexus_info=(NexusInfo **) MagickAssumeAligned(AcquireAlignedMemory(\n    number_threads,sizeof(*nexus_info)));\n  if (nexus_info == (NexusInfo **) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  nexus_info[0]=(NexusInfo *) AcquireQuantumMemory(number_threads,\n    sizeof(**nexus_info));\n  if (nexus_info[0] == (NexusInfo *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(nexus_info[0],0,number_threads*sizeof(**nexus_info));\n  for (i=0; i < (ssize_t) number_threads; i++)\n  {\n    nexus_info[i]=(&nexus_info[0][i]);\n    nexus_info[i]->signature=MagickCoreSignature;\n  }\n  return(nexus_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   A c q u i r e P i x e l C a c h e P i x e l s                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquirePixelCachePixels() returns the pixels associated with the specified\n%  image.\n%\n%  The format of the AcquirePixelCachePixels() method is:\n%\n%      const void *AcquirePixelCachePixels(const Image *image,\n%        MagickSizeType *length,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o length: the pixel cache length.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickPrivate const void *AcquirePixelCachePixels(const Image *image,\n  MagickSizeType *length,ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  *length=0;\n  if ((cache_info->type != MemoryCache) && (cache_info->type != MapCache))\n    return((const void *) NULL);\n  *length=cache_info->length;\n  return((const void *) cache_info->pixels);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   C a c h e C o m p o n e n t G e n e s i s                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CacheComponentGenesis() instantiates the cache component.\n%\n%  The format of the CacheComponentGenesis method is:\n%\n%      MagickBooleanType CacheComponentGenesis(void)\n%\n*/\nMagickPrivate MagickBooleanType CacheComponentGenesis(void)\n{\n  if (cache_semaphore == (SemaphoreInfo *) NULL)\n    cache_semaphore=AcquireSemaphoreInfo();\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   C a c h e C o m p o n e n t T e r m i n u s                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CacheComponentTerminus() destroys the cache component.\n%\n%  The format of the CacheComponentTerminus() method is:\n%\n%      CacheComponentTerminus(void)\n%\n*/\nMagickPrivate void CacheComponentTerminus(void)\n{\n  if (cache_semaphore == (SemaphoreInfo *) NULL)\n    ActivateSemaphoreInfo(&cache_semaphore);\n  LockSemaphoreInfo(cache_semaphore);\n  instantiate_cache=MagickFalse;\n  UnlockSemaphoreInfo(cache_semaphore);\n  RelinquishSemaphoreInfo(&cache_semaphore);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   C l o n e P i x e l C a c h e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ClonePixelCache() clones a pixel cache.\n%\n%  The format of the ClonePixelCache() method is:\n%\n%      Cache ClonePixelCache(const Cache cache)\n%\n%  A description of each parameter follows:\n%\n%    o cache: the pixel cache.\n%\n*/\nMagickPrivate Cache ClonePixelCache(const Cache cache)\n{\n  CacheInfo\n    *magick_restrict clone_info;\n\n  const CacheInfo\n    *magick_restrict cache_info;\n\n  assert(cache != NULL);\n  cache_info=(const CacheInfo *) cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  if (cache_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      cache_info->filename);\n  clone_info=(CacheInfo *) AcquirePixelCache(cache_info->number_threads);\n  if (clone_info == (Cache) NULL)\n    return((Cache) NULL);\n  clone_info->virtual_pixel_method=cache_info->virtual_pixel_method;\n  return((Cache ) clone_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   C l o n e P i x e l C a c h e M e t h o d s                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ClonePixelCacheMethods() clones the pixel cache methods from one cache to\n%  another.\n%\n%  The format of the ClonePixelCacheMethods() method is:\n%\n%      void ClonePixelCacheMethods(Cache clone,const Cache cache)\n%\n%  A description of each parameter follows:\n%\n%    o clone: Specifies a pointer to a Cache structure.\n%\n%    o cache: the pixel cache.\n%\n*/\nMagickPrivate void ClonePixelCacheMethods(Cache clone,const Cache cache)\n{\n  CacheInfo\n    *magick_restrict cache_info,\n    *magick_restrict source_info;\n\n  assert(clone != (Cache) NULL);\n  source_info=(CacheInfo *) clone;\n  assert(source_info->signature == MagickCoreSignature);\n  if (source_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      source_info->filename);\n  assert(cache != (Cache) NULL);\n  cache_info=(CacheInfo *) cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  source_info->methods=cache_info->methods;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   C l o n e P i x e l C a c h e R e p o s i t o r y                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%  ClonePixelCacheRepository() clones the source pixel cache to the destination\n%  cache.\n%\n%  The format of the ClonePixelCacheRepository() method is:\n%\n%      MagickBooleanType ClonePixelCacheRepository(CacheInfo *cache_info,\n%        CacheInfo *source_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o cache_info: the pixel cache.\n%\n%    o source_info: the source pixel cache.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic MagickBooleanType ClonePixelCacheOnDisk(\n  CacheInfo *magick_restrict cache_info,CacheInfo *magick_restrict clone_info)\n{\n  MagickSizeType\n    extent;\n\n  size_t\n    quantum;\n\n  ssize_t\n    count;\n\n  struct stat\n    file_stats;\n\n  unsigned char\n    *buffer;\n\n  /*\n    Clone pixel cache on disk with identifcal morphology.\n  */\n  if ((OpenPixelCacheOnDisk(cache_info,ReadMode) == MagickFalse) ||\n      (OpenPixelCacheOnDisk(clone_info,IOMode) == MagickFalse))\n    return(MagickFalse);\n  quantum=(size_t) MagickMaxBufferExtent;\n  if ((fstat(cache_info->file,&file_stats) == 0) && (file_stats.st_size > 0))\n    quantum=(size_t) MagickMin(file_stats.st_size,MagickMaxBufferExtent);\n  buffer=(unsigned char *) AcquireQuantumMemory(quantum,sizeof(*buffer));\n  if (buffer == (unsigned char *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  extent=0;\n  while ((count=read(cache_info->file,buffer,quantum)) > 0)\n  {\n    ssize_t\n      number_bytes;\n\n    number_bytes=write(clone_info->file,buffer,(size_t) count);\n    if (number_bytes != count)\n      break;\n    extent+=number_bytes;\n  }\n  buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n  if (extent != cache_info->length)\n    return(MagickFalse);\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType ClonePixelCacheRepository(\n  CacheInfo *magick_restrict clone_info,CacheInfo *magick_restrict cache_info,\n  ExceptionInfo *exception)\n{\n#define MaxCacheThreads  2\n#define cache_threads(source,destination) \\\n  num_threads(((source)->type == DiskCache) || \\\n    ((destination)->type == DiskCache) || (((source)->rows) < \\\n    (16*GetMagickResourceLimit(ThreadResource))) ? 1 : \\\n    GetMagickResourceLimit(ThreadResource) < MaxCacheThreads ? \\\n    GetMagickResourceLimit(ThreadResource) : MaxCacheThreads)\n\n  MagickBooleanType\n    optimize,\n    status;\n\n  NexusInfo\n    **magick_restrict cache_nexus,\n    **magick_restrict clone_nexus;\n\n  size_t\n    length;\n\n  ssize_t\n    y;\n\n  assert(cache_info != (CacheInfo *) NULL);\n  assert(clone_info != (CacheInfo *) NULL);\n  assert(exception != (ExceptionInfo *) NULL);\n  if (cache_info->type == PingCache)\n    return(MagickTrue);\n  length=cache_info->number_channels*sizeof(*cache_info->channel_map);\n  if ((cache_info->columns == clone_info->columns) &&\n      (cache_info->rows == clone_info->rows) &&\n      (cache_info->number_channels == clone_info->number_channels) &&\n      (memcmp(cache_info->channel_map,clone_info->channel_map,length) == 0) &&\n      (cache_info->metacontent_extent == clone_info->metacontent_extent))\n    {\n      /*\n        Identical pixel cache morphology.\n      */\n      if (((cache_info->type == MemoryCache) ||\n           (cache_info->type == MapCache)) &&\n          ((clone_info->type == MemoryCache) ||\n           (clone_info->type == MapCache)))\n        {\n          (void) memcpy(clone_info->pixels,cache_info->pixels,\n            cache_info->columns*cache_info->number_channels*cache_info->rows*\n            sizeof(*cache_info->pixels));\n          if ((cache_info->metacontent_extent != 0) &&\n              (clone_info->metacontent_extent != 0))\n            (void) memcpy(clone_info->metacontent,cache_info->metacontent,\n              cache_info->columns*cache_info->rows*\n              clone_info->metacontent_extent*sizeof(unsigned char));\n          return(MagickTrue);\n        }\n      if ((cache_info->type == DiskCache) && (clone_info->type == DiskCache))\n        return(ClonePixelCacheOnDisk(cache_info,clone_info));\n    }\n  /*\n    Mismatched pixel cache morphology.\n  */\n  cache_nexus=AcquirePixelCacheNexus(MaxCacheThreads);\n  clone_nexus=AcquirePixelCacheNexus(MaxCacheThreads);\n  if ((cache_nexus == (NexusInfo **) NULL) ||\n      (clone_nexus == (NexusInfo **) NULL))\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  length=cache_info->number_channels*sizeof(*cache_info->channel_map);\n  optimize=(cache_info->number_channels == clone_info->number_channels) &&\n    (memcmp(cache_info->channel_map,clone_info->channel_map,length) == 0) ?\n    MagickTrue : MagickFalse;\n  length=(size_t) MagickMin(cache_info->columns*cache_info->number_channels,\n    clone_info->columns*clone_info->number_channels);\n  status=MagickTrue;\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(status) \\\n    cache_threads(cache_info,clone_info)\n#endif\n  for (y=0; y < (ssize_t) cache_info->rows; y++)\n  {\n    const int\n      id = GetOpenMPThreadId();\n\n    Quantum\n      *pixels;\n\n    RectangleInfo\n      region;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    if (y >= (ssize_t) clone_info->rows)\n      continue;\n    region.width=cache_info->columns;\n    region.height=1;\n    region.x=0;\n    region.y=y;\n    pixels=SetPixelCacheNexusPixels(cache_info,ReadMode,&region,\n      cache_nexus[id],exception);\n    if (pixels == (Quantum *) NULL)\n      continue;\n    status=ReadPixelCachePixels(cache_info,cache_nexus[id],exception);\n    if (status == MagickFalse)\n      continue;\n    region.width=clone_info->columns;\n    pixels=SetPixelCacheNexusPixels(clone_info,WriteMode,&region,\n      clone_nexus[id],exception);\n    if (pixels == (Quantum *) NULL)\n      continue;\n    (void) ResetMagickMemory(clone_nexus[id]->pixels,0,(size_t)\n      clone_nexus[id]->length);\n    if (optimize != MagickFalse)\n      (void) memcpy(clone_nexus[id]->pixels,cache_nexus[id]->pixels,length*\n        sizeof(Quantum));\n    else\n      {\n        register const Quantum\n          *magick_restrict p;\n\n        register Quantum\n          *magick_restrict q;\n\n        /*\n          Mismatched pixel channel map.\n        */\n        p=cache_nexus[id]->pixels;\n        q=clone_nexus[id]->pixels;\n        for (x=0; x < (ssize_t) cache_info->columns; x++)\n        {\n          register ssize_t\n            i;\n\n          if (x == (ssize_t) clone_info->columns)\n            break;\n          for (i=0; i < (ssize_t) clone_info->number_channels; i++)\n          {\n            PixelChannel\n              channel;\n\n            PixelTrait\n              traits;\n\n            channel=clone_info->channel_map[i].channel;\n            traits=cache_info->channel_map[channel].traits;\n            if (traits != UndefinedPixelTrait)\n              *q=*(p+cache_info->channel_map[channel].offset);\n            q++;\n          }\n          p+=cache_info->number_channels;\n        }\n      }\n    status=WritePixelCachePixels(clone_info,clone_nexus[id],exception);\n  }\n  if ((cache_info->metacontent_extent != 0) &&\n      (clone_info->metacontent_extent != 0))\n    {\n      /*\n        Clone metacontent.\n      */\n      length=(size_t) MagickMin(cache_info->metacontent_extent,\n        clone_info->metacontent_extent);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      #pragma omp parallel for schedule(static,4) shared(status) \\\n        cache_threads(cache_info,clone_info)\n#endif\n      for (y=0; y < (ssize_t) cache_info->rows; y++)\n      {\n        const int\n          id = GetOpenMPThreadId();\n\n        Quantum\n          *pixels;\n\n        RectangleInfo\n          region;\n\n        if (status == MagickFalse)\n          continue;\n        if (y >= (ssize_t) clone_info->rows)\n          continue;\n        region.width=cache_info->columns;\n        region.height=1;\n        region.x=0;\n        region.y=y;\n        pixels=SetPixelCacheNexusPixels(cache_info,ReadMode,&region,\n          cache_nexus[id],exception);\n        if (pixels == (Quantum *) NULL)\n          continue;\n        status=ReadPixelCacheMetacontent(cache_info,cache_nexus[id],exception);\n        if (status == MagickFalse)\n          continue;\n        region.width=clone_info->columns;\n        pixels=SetPixelCacheNexusPixels(clone_info,WriteMode,&region,\n          clone_nexus[id],exception);\n        if (pixels == (Quantum *) NULL)\n          continue;\n        if ((clone_nexus[id]->metacontent != (void *) NULL) &&\n            (cache_nexus[id]->metacontent != (void *) NULL))\n          (void) memcpy(clone_nexus[id]->metacontent,\n            cache_nexus[id]->metacontent,length*sizeof(unsigned char));\n        status=WritePixelCacheMetacontent(clone_info,clone_nexus[id],exception);\n      }\n    }\n  cache_nexus=DestroyPixelCacheNexus(cache_nexus,MaxCacheThreads);\n  clone_nexus=DestroyPixelCacheNexus(clone_nexus,MaxCacheThreads);\n  if (cache_info->debug != MagickFalse)\n    {\n      char\n        message[MagickPathExtent];\n\n      (void) FormatLocaleString(message,MagickPathExtent,\"%s => %s\",\n        CommandOptionToMnemonic(MagickCacheOptions,(ssize_t) cache_info->type),\n        CommandOptionToMnemonic(MagickCacheOptions,(ssize_t) clone_info->type));\n      (void) LogMagickEvent(CacheEvent,GetMagickModule(),\"%s\",message);\n    }\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D e s t r o y I m a g e P i x e l C a c h e                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyImagePixelCache() deallocates memory associated with the pixel cache.\n%\n%  The format of the DestroyImagePixelCache() method is:\n%\n%      void DestroyImagePixelCache(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nstatic void DestroyImagePixelCache(Image *image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->cache == (void *) NULL)\n    return;\n  image->cache=DestroyPixelCache(image->cache);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D e s t r o y I m a g e P i x e l s                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyImagePixels() deallocates memory associated with the pixel cache.\n%\n%  The format of the DestroyImagePixels() method is:\n%\n%      void DestroyImagePixels(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport void DestroyImagePixels(Image *image)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  if (cache_info->methods.destroy_pixel_handler != (DestroyPixelHandler) NULL)\n    {\n      cache_info->methods.destroy_pixel_handler(image);\n      return;\n    }\n  image->cache=DestroyPixelCache(image->cache);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D e s t r o y P i x e l C a c h e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyPixelCache() deallocates memory associated with the pixel cache.\n%\n%  The format of the DestroyPixelCache() method is:\n%\n%      Cache DestroyPixelCache(Cache cache)\n%\n%  A description of each parameter follows:\n%\n%    o cache: the pixel cache.\n%\n*/\n\nstatic MagickBooleanType ClosePixelCacheOnDisk(CacheInfo *cache_info)\n{\n  int\n    status;\n\n  status=(-1);\n  if (cache_info->file != -1)\n    {\n      status=close(cache_info->file);\n      cache_info->file=(-1);\n      RelinquishMagickResource(FileResource,1);\n    }\n  return(status == -1 ? MagickFalse : MagickTrue);\n}\n\nstatic inline void RelinquishPixelCachePixels(CacheInfo *cache_info)\n{\n  switch (cache_info->type)\n  {\n    case MemoryCache:\n    {\n      if (cache_info->mapped == MagickFalse)\n        cache_info->pixels=(Quantum *) RelinquishAlignedMemory(\n          cache_info->pixels);\n      else\n        {\n          (void) UnmapBlob(cache_info->pixels,(size_t) cache_info->length);\n          cache_info->pixels=(Quantum *) NULL;\n        }\n      RelinquishMagickResource(MemoryResource,cache_info->length);\n      break;\n    }\n    case MapCache:\n    {\n      (void) UnmapBlob(cache_info->pixels,(size_t) cache_info->length);\n      cache_info->pixels=(Quantum *) NULL;\n      if (cache_info->mode != ReadMode)\n        (void) RelinquishUniqueFileResource(cache_info->cache_filename);\n      *cache_info->cache_filename='\\0';\n      RelinquishMagickResource(MapResource,cache_info->length);\n    }\n    case DiskCache:\n    {\n      if (cache_info->file != -1)\n        (void) ClosePixelCacheOnDisk(cache_info);\n      if (cache_info->mode != ReadMode)\n        (void) RelinquishUniqueFileResource(cache_info->cache_filename);\n      *cache_info->cache_filename='\\0';\n      RelinquishMagickResource(DiskResource,cache_info->length);\n      break;\n    }\n    case DistributedCache:\n    {\n      *cache_info->cache_filename='\\0';\n      (void) RelinquishDistributePixelCache((DistributeCacheInfo *)\n        cache_info->server_info);\n      break;\n    }\n    default:\n      break;\n  }\n  cache_info->type=UndefinedCache;\n  cache_info->mapped=MagickFalse;\n  cache_info->metacontent=(void *) NULL;\n}\n\nMagickPrivate Cache DestroyPixelCache(Cache cache)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  assert(cache != (Cache) NULL);\n  cache_info=(CacheInfo *) cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  if (cache_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      cache_info->filename);\n  LockSemaphoreInfo(cache_info->semaphore);\n  cache_info->reference_count--;\n  if (cache_info->reference_count != 0)\n    {\n      UnlockSemaphoreInfo(cache_info->semaphore);\n      return((Cache) NULL);\n    }\n  UnlockSemaphoreInfo(cache_info->semaphore);\n  if (cache_info->debug != MagickFalse)\n    {\n      char\n        message[MagickPathExtent];\n\n      (void) FormatLocaleString(message,MagickPathExtent,\"destroy %s\",\n        cache_info->filename);\n      (void) LogMagickEvent(CacheEvent,GetMagickModule(),\"%s\",message);\n    }\n  RelinquishPixelCachePixels(cache_info);\n  if (cache_info->server_info != (DistributeCacheInfo *) NULL)\n    cache_info->server_info=DestroyDistributeCacheInfo((DistributeCacheInfo *)\n      cache_info->server_info);\n  if (cache_info->nexus_info != (NexusInfo **) NULL)\n    cache_info->nexus_info=DestroyPixelCacheNexus(cache_info->nexus_info,\n      cache_info->number_threads);\n  if (cache_info->random_info != (RandomInfo *) NULL)\n    cache_info->random_info=DestroyRandomInfo(cache_info->random_info);\n  if (cache_info->file_semaphore != (SemaphoreInfo *) NULL)\n    RelinquishSemaphoreInfo(&cache_info->file_semaphore);\n  if (cache_info->semaphore != (SemaphoreInfo *) NULL)\n    RelinquishSemaphoreInfo(&cache_info->semaphore);\n  cache_info->signature=(~MagickCoreSignature);\n  cache_info=(CacheInfo *) RelinquishMagickMemory(cache_info);\n  cache=(Cache) NULL;\n  return(cache);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D e s t r o y P i x e l C a c h e N e x u s                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyPixelCacheNexus() destroys a pixel cache nexus.\n%\n%  The format of the DestroyPixelCacheNexus() method is:\n%\n%      NexusInfo **DestroyPixelCacheNexus(NexusInfo *nexus_info,\n%        const size_t number_threads)\n%\n%  A description of each parameter follows:\n%\n%    o nexus_info: the nexus to destroy.\n%\n%    o number_threads: the number of nexus threads.\n%\n*/\n\nstatic inline void RelinquishCacheNexusPixels(NexusInfo *nexus_info)\n{\n  if (nexus_info->mapped == MagickFalse)\n    (void) RelinquishAlignedMemory(nexus_info->cache);\n  else\n    (void) UnmapBlob(nexus_info->cache,(size_t) nexus_info->length);\n  nexus_info->cache=(Quantum *) NULL;\n  nexus_info->pixels=(Quantum *) NULL;\n  nexus_info->metacontent=(void *) NULL;\n  nexus_info->length=0;\n  nexus_info->mapped=MagickFalse;\n}\n\nMagickPrivate NexusInfo **DestroyPixelCacheNexus(NexusInfo **nexus_info,\n  const size_t number_threads)\n{\n  register ssize_t\n    i;\n\n  assert(nexus_info != (NexusInfo **) NULL);\n  for (i=0; i < (ssize_t) number_threads; i++)\n  {\n    if (nexus_info[i]->cache != (Quantum *) NULL)\n      RelinquishCacheNexusPixels(nexus_info[i]);\n    nexus_info[i]->signature=(~MagickCoreSignature);\n  }\n  nexus_info[0]=(NexusInfo *) RelinquishMagickMemory(nexus_info[0]);\n  nexus_info=(NexusInfo **) RelinquishAlignedMemory(nexus_info);\n  return(nexus_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t A u t h e n t i c M e t a c o n t e n t                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetAuthenticMetacontent() returns the authentic metacontent corresponding\n%  with the last call to QueueAuthenticPixels() or GetVirtualPixels().  NULL is\n%  returned if the associated pixels are not available.\n%\n%  The format of the GetAuthenticMetacontent() method is:\n%\n%      void *GetAuthenticMetacontent(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport void *GetAuthenticMetacontent(const Image *image)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  if (cache_info->methods.get_authentic_metacontent_from_handler !=\n      (GetAuthenticMetacontentFromHandler) NULL)\n    {\n      void\n        *metacontent;\n\n      metacontent=cache_info->methods.\n        get_authentic_metacontent_from_handler(image);\n      return(metacontent);\n    }\n  assert(id < (int) cache_info->number_threads);\n  return(cache_info->nexus_info[id]->metacontent);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t A u t h e n t i c M e t a c o n t e n t F r o m C a c h e           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetAuthenticMetacontentFromCache() returns the meta-content corresponding\n%  with the last call to QueueAuthenticPixelsCache() or\n%  GetAuthenticPixelsCache().\n%\n%  The format of the GetAuthenticMetacontentFromCache() method is:\n%\n%      void *GetAuthenticMetacontentFromCache(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nstatic void *GetAuthenticMetacontentFromCache(const Image *image)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  assert(id < (int) cache_info->number_threads);\n  return(cache_info->nexus_info[id]->metacontent);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t A u t h e n t i c P i x e l C a c h e N e x u s                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetAuthenticPixelCacheNexus() gets authentic pixels from the in-memory or\n%  disk pixel cache as defined by the geometry parameters.   A pointer to the\n%  pixels is returned if the pixels are transferred, otherwise a NULL is\n%  returned.\n%\n%  The format of the GetAuthenticPixelCacheNexus() method is:\n%\n%      Quantum *GetAuthenticPixelCacheNexus(Image *image,const ssize_t x,\n%        const ssize_t y,const size_t columns,const size_t rows,\n%        NexusInfo *nexus_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o x,y,columns,rows:  These values define the perimeter of a region of\n%      pixels.\n%\n%    o nexus_info: the cache nexus to return.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nMagickPrivate Quantum *GetAuthenticPixelCacheNexus(Image *image,const ssize_t x,\n  const ssize_t y,const size_t columns,const size_t rows,NexusInfo *nexus_info,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  Quantum\n    *magick_restrict pixels;\n\n  /*\n    Transfer pixels from the cache.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  pixels=QueueAuthenticPixelCacheNexus(image,x,y,columns,rows,MagickTrue,\n    nexus_info,exception);\n  if (pixels == (Quantum *) NULL)\n    return((Quantum *) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  if (nexus_info->authentic_pixel_cache != MagickFalse)\n    return(pixels);\n  if (ReadPixelCachePixels(cache_info,nexus_info,exception) == MagickFalse)\n    return((Quantum *) NULL);\n  if (cache_info->metacontent_extent != 0)\n    if (ReadPixelCacheMetacontent(cache_info,nexus_info,exception) == MagickFalse)\n      return((Quantum *) NULL);\n  return(pixels);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t A u t h e n t i c P i x e l s F r o m C a c h e                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetAuthenticPixelsFromCache() returns the pixels associated with the last\n%  call to the QueueAuthenticPixelsCache() or GetAuthenticPixelsCache() methods.\n%\n%  The format of the GetAuthenticPixelsFromCache() method is:\n%\n%      Quantum *GetAuthenticPixelsFromCache(const Image image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nstatic Quantum *GetAuthenticPixelsFromCache(const Image *image)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  assert(id < (int) cache_info->number_threads);\n  return(cache_info->nexus_info[id]->pixels);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t A u t h e n t i c P i x e l Q u e u e                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetAuthenticPixelQueue() returns the authentic pixels associated\n%  corresponding with the last call to QueueAuthenticPixels() or\n%  GetAuthenticPixels().\n%\n%  The format of the GetAuthenticPixelQueue() method is:\n%\n%      Quantum *GetAuthenticPixelQueue(const Image image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport Quantum *GetAuthenticPixelQueue(const Image *image)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  if (cache_info->methods.get_authentic_pixels_from_handler !=\n       (GetAuthenticPixelsFromHandler) NULL)\n    return(cache_info->methods.get_authentic_pixels_from_handler(image));\n  assert(id < (int) cache_info->number_threads);\n  return(cache_info->nexus_info[id]->pixels);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t A u t h e n t i c P i x e l s                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetAuthenticPixels() obtains a pixel region for read/write access. If the\n%  region is successfully accessed, a pointer to a Quantum array\n%  representing the region is returned, otherwise NULL is returned.\n%\n%  The returned pointer may point to a temporary working copy of the pixels\n%  or it may point to the original pixels in memory. Performance is maximized\n%  if the selected region is part of one row, or one or more full rows, since\n%  then there is opportunity to access the pixels in-place (without a copy)\n%  if the image is in memory, or in a memory-mapped file. The returned pointer\n%  must *never* be deallocated by the user.\n%\n%  Pixels accessed via the returned pointer represent a simple array of type\n%  Quantum.  If the image has corresponding metacontent,call\n%  GetAuthenticMetacontent() after invoking GetAuthenticPixels() to obtain the\n%  meta-content corresponding to the region.  Once the Quantum array has\n%  been updated, the changes must be saved back to the underlying image using\n%  SyncAuthenticPixels() or they may be lost.\n%\n%  The format of the GetAuthenticPixels() method is:\n%\n%      Quantum *GetAuthenticPixels(Image *image,const ssize_t x,\n%        const ssize_t y,const size_t columns,const size_t rows,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o x,y,columns,rows:  These values define the perimeter of a region of\n%      pixels.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Quantum *GetAuthenticPixels(Image *image,const ssize_t x,\n  const ssize_t y,const size_t columns,const size_t rows,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  Quantum\n    *pixels;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  if (cache_info->methods.get_authentic_pixels_handler !=\n      (GetAuthenticPixelsHandler) NULL)\n    {\n      pixels=cache_info->methods.get_authentic_pixels_handler(image,x,y,columns,\n        rows,exception);\n      return(pixels);\n    }\n  assert(id < (int) cache_info->number_threads);\n  pixels=GetAuthenticPixelCacheNexus(image,x,y,columns,rows,\n    cache_info->nexus_info[id],exception);\n  return(pixels);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t A u t h e n t i c P i x e l s C a c h e                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetAuthenticPixelsCache() gets pixels from the in-memory or disk pixel cache\n%  as defined by the geometry parameters.   A pointer to the pixels is returned\n%  if the pixels are transferred, otherwise a NULL is returned.\n%\n%  The format of the GetAuthenticPixelsCache() method is:\n%\n%      Quantum *GetAuthenticPixelsCache(Image *image,const ssize_t x,\n%        const ssize_t y,const size_t columns,const size_t rows,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o x,y,columns,rows:  These values define the perimeter of a region of\n%      pixels.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Quantum *GetAuthenticPixelsCache(Image *image,const ssize_t x,\n  const ssize_t y,const size_t columns,const size_t rows,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  Quantum\n    *magick_restrict pixels;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  if (cache_info == (Cache) NULL)\n    return((Quantum *) NULL);\n  assert(cache_info->signature == MagickCoreSignature);\n  assert(id < (int) cache_info->number_threads);\n  pixels=GetAuthenticPixelCacheNexus(image,x,y,columns,rows,\n    cache_info->nexus_info[id],exception);\n  return(pixels);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t I m a g e E x t e n t                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageExtent() returns the extent of the pixels associated corresponding\n%  with the last call to QueueAuthenticPixels() or GetAuthenticPixels().\n%\n%  The format of the GetImageExtent() method is:\n%\n%      MagickSizeType GetImageExtent(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport MagickSizeType GetImageExtent(const Image *image)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  assert(id < (int) cache_info->number_threads);\n  return(GetPixelCacheNexusExtent(cache_info,cache_info->nexus_info[id]));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t I m a g e P i x e l C a c h e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImagePixelCache() ensures that there is only a single reference to the\n%  pixel cache to be modified, updating the provided cache pointer to point to\n%  a clone of the original pixel cache if necessary.\n%\n%  The format of the GetImagePixelCache method is:\n%\n%      Cache GetImagePixelCache(Image *image,const MagickBooleanType clone,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o clone: any value other than MagickFalse clones the cache pixels.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline MagickBooleanType ValidatePixelCacheMorphology(\n  const Image *magick_restrict image)\n{\n  const CacheInfo\n    *magick_restrict cache_info;\n\n  const PixelChannelMap\n    *magick_restrict p,\n    *magick_restrict q;\n\n  /*\n    Does the image match the pixel cache morphology?\n  */\n  cache_info=(CacheInfo *) image->cache;\n  p=image->channel_map;\n  q=cache_info->channel_map;\n  if ((image->storage_class != cache_info->storage_class) ||\n      (image->colorspace != cache_info->colorspace) ||\n      (image->alpha_trait != cache_info->alpha_trait) ||\n      (image->read_mask != cache_info->read_mask) ||\n      (image->write_mask != cache_info->write_mask) ||\n      (image->columns != cache_info->columns) ||\n      (image->rows != cache_info->rows) ||\n      (image->number_channels != cache_info->number_channels) ||\n      (memcmp(p,q,image->number_channels*sizeof(*p)) != 0) ||\n      (image->metacontent_extent != cache_info->metacontent_extent) ||\n      (cache_info->nexus_info == (NexusInfo **) NULL))\n    return(MagickFalse);\n  return(MagickTrue);\n}\n\nstatic Cache GetImagePixelCache(Image *image,const MagickBooleanType clone,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  MagickBooleanType\n    destroy,\n    status;\n\n  static MagickSizeType\n    cache_timelimit = 0,\n    cpu_throttle = MagickResourceInfinity,\n    cycles = 0;\n\n  status=MagickTrue;\n  if (cpu_throttle == MagickResourceInfinity)\n    cpu_throttle=GetMagickResourceLimit(ThrottleResource);\n  if ((cpu_throttle != 0) && ((cycles++ % 32) == 0))\n    MagickDelay(cpu_throttle);\n  if (cache_epoch == 0)\n    {\n      /*\n        Set the expire time in seconds.\n      */\n      cache_timelimit=GetMagickResourceLimit(TimeResource);\n      cache_epoch=time((time_t *) NULL);\n    }\n  if ((cache_timelimit != MagickResourceInfinity) &&\n      ((MagickSizeType) (time((time_t *) NULL)-cache_epoch) >= cache_timelimit))\n     {\n#if defined(ECANCELED)\n       errno=ECANCELED;\n#endif\n       ThrowFatalException(ResourceLimitFatalError,\"TimeLimitExceeded\");\n     }\n  LockSemaphoreInfo(image->semaphore);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  destroy=MagickFalse;\n  if ((cache_info->reference_count > 1) || (cache_info->mode == ReadMode))\n    {\n      LockSemaphoreInfo(cache_info->semaphore);\n      if ((cache_info->reference_count > 1) || (cache_info->mode == ReadMode))\n        {\n          CacheInfo\n            *clone_info;\n\n          Image\n            clone_image;\n\n          /*\n            Clone pixel cache.\n          */\n          clone_image=(*image);\n          clone_image.semaphore=AcquireSemaphoreInfo();\n          clone_image.reference_count=1;\n          clone_image.cache=ClonePixelCache(cache_info);\n          clone_info=(CacheInfo *) clone_image.cache;\n          status=OpenPixelCache(&clone_image,IOMode,exception);\n          if (status != MagickFalse)\n            {\n              if (clone != MagickFalse)\n                status=ClonePixelCacheRepository(clone_info,cache_info,\n                  exception);\n              if (status != MagickFalse)\n                {\n                  if (cache_info->reference_count == 1)\n                    cache_info->nexus_info=(NexusInfo **) NULL;\n                  destroy=MagickTrue;\n                  image->cache=clone_image.cache;\n                }\n            }\n          RelinquishSemaphoreInfo(&clone_image.semaphore);\n        }\n      UnlockSemaphoreInfo(cache_info->semaphore);\n    }\n  if (destroy != MagickFalse)\n    cache_info=(CacheInfo *) DestroyPixelCache(cache_info);\n  if (status != MagickFalse)\n    {\n      /*\n        Ensure the image matches the pixel cache morphology.\n      */\n      image->type=UndefinedType;\n      if (ValidatePixelCacheMorphology(image) == MagickFalse)\n        {\n          status=OpenPixelCache(image,IOMode,exception);\n          cache_info=(CacheInfo *) image->cache;\n          if (cache_info->type == DiskCache)\n            (void) ClosePixelCacheOnDisk(cache_info);\n        }\n    }\n  UnlockSemaphoreInfo(image->semaphore);\n  if (status == MagickFalse)\n    return((Cache) NULL);\n  return(image->cache);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t I m a g e P i x e l C a c h e T y p e                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImagePixelCacheType() returns the pixel cache type: UndefinedCache,\n%  DiskCache, MemoryCache, MapCache, or PingCache.\n%\n%  The format of the GetImagePixelCacheType() method is:\n%\n%      CacheType GetImagePixelCacheType(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport CacheType GetImagePixelCacheType(const Image *image)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  return(cache_info->type);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t O n e A u t h e n t i c P i x e l                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetOneAuthenticPixel() returns a single pixel at the specified (x,y)\n%  location.  The image background color is returned if an error occurs.\n%\n%  The format of the GetOneAuthenticPixel() method is:\n%\n%      MagickBooleanType GetOneAuthenticPixel(const Image image,const ssize_t x,\n%        const ssize_t y,Quantum *pixel,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o x,y:  These values define the location of the pixel to return.\n%\n%    o pixel: return a pixel at the specified (x,y) location.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline MagickBooleanType CopyPixel(const Image *image,const Quantum *source,\n  Quantum *destination)\n{\n  register ssize_t\n    i;\n\n  if (source == (const Quantum *) NULL)\n    {\n      destination[RedPixelChannel]=ClampToQuantum(image->background_color.red);\n      destination[GreenPixelChannel]=ClampToQuantum(image->background_color.green);\n      destination[BluePixelChannel]=ClampToQuantum(image->background_color.blue);\n      destination[BlackPixelChannel]=ClampToQuantum(image->background_color.black);\n      destination[AlphaPixelChannel]=ClampToQuantum(image->background_color.alpha);\n      return(MagickFalse);\n    }\n  for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n  {\n    PixelChannel channel=GetPixelChannelChannel(image,i);\n    destination[channel]=source[i];\n  }\n  return(MagickTrue);\n}\n\nMagickExport MagickBooleanType GetOneAuthenticPixel(Image *image,\n  const ssize_t x,const ssize_t y,Quantum *pixel,ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  register Quantum\n    *magick_restrict q;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  (void) memset(pixel,0,MaxPixelChannels*sizeof(*pixel));\n  if (cache_info->methods.get_one_authentic_pixel_from_handler !=\n       (GetOneAuthenticPixelFromHandler) NULL)\n    return(cache_info->methods.get_one_authentic_pixel_from_handler(image,x,y,\n      pixel,exception));\n  q=GetAuthenticPixelsCache(image,x,y,1UL,1UL,exception);\n  return(CopyPixel(image,q,pixel));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t O n e A u t h e n t i c P i x e l F r o m C a c h e                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetOneAuthenticPixelFromCache() returns a single pixel at the specified (x,y)\n%  location.  The image background color is returned if an error occurs.\n%\n%  The format of the GetOneAuthenticPixelFromCache() method is:\n%\n%      MagickBooleanType GetOneAuthenticPixelFromCache(const Image image,\n%        const ssize_t x,const ssize_t y,Quantum *pixel,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o x,y:  These values define the location of the pixel to return.\n%\n%    o pixel: return a pixel at the specified (x,y) location.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType GetOneAuthenticPixelFromCache(Image *image,\n  const ssize_t x,const ssize_t y,Quantum *pixel,ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  register Quantum\n    *magick_restrict q;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  assert(id < (int) cache_info->number_threads);\n  (void) memset(pixel,0,MaxPixelChannels*sizeof(*pixel));\n  q=GetAuthenticPixelCacheNexus(image,x,y,1UL,1UL,cache_info->nexus_info[id],\n    exception);\n  return(CopyPixel(image,q,pixel));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t O n e V i r t u a l P i x e l                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetOneVirtualPixel() returns a single virtual pixel at the specified\n%  (x,y) location.  The image background color is returned if an error occurs.\n%  If you plan to modify the pixel, use GetOneAuthenticPixel() instead.\n%\n%  The format of the GetOneVirtualPixel() method is:\n%\n%      MagickBooleanType GetOneVirtualPixel(const Image image,const ssize_t x,\n%        const ssize_t y,Quantum *pixel,ExceptionInfo exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o x,y:  These values define the location of the pixel to return.\n%\n%    o pixel: return a pixel at the specified (x,y) location.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType GetOneVirtualPixel(const Image *image,\n  const ssize_t x,const ssize_t y,Quantum *pixel,ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  const Quantum\n    *p;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  (void) memset(pixel,0,MaxPixelChannels*sizeof(*pixel));\n  if (cache_info->methods.get_one_virtual_pixel_from_handler !=\n       (GetOneVirtualPixelFromHandler) NULL)\n    return(cache_info->methods.get_one_virtual_pixel_from_handler(image,\n      GetPixelCacheVirtualMethod(image),x,y,pixel,exception));\n  assert(id < (int) cache_info->number_threads);\n  p=GetVirtualPixelsFromNexus(image,GetPixelCacheVirtualMethod(image),x,y,\n    1UL,1UL,cache_info->nexus_info[id],exception);\n  return(CopyPixel(image,p,pixel));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t O n e V i r t u a l P i x e l F r o m C a c h e                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetOneVirtualPixelFromCache() returns a single virtual pixel at the\n%  specified (x,y) location.  The image background color is returned if an\n%  error occurs.\n%\n%  The format of the GetOneVirtualPixelFromCache() method is:\n%\n%      MagickBooleanType GetOneVirtualPixelFromCache(const Image image,\n%        const VirtualPixelMethod method,const ssize_t x,const ssize_t y,\n%        Quantum *pixel,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o virtual_pixel_method: the virtual pixel method.\n%\n%    o x,y:  These values define the location of the pixel to return.\n%\n%    o pixel: return a pixel at the specified (x,y) location.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType GetOneVirtualPixelFromCache(const Image *image,\n  const VirtualPixelMethod virtual_pixel_method,const ssize_t x,const ssize_t y,\n  Quantum *pixel,ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  const Quantum\n    *p;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  assert(id < (int) cache_info->number_threads);\n  (void) memset(pixel,0,MaxPixelChannels*sizeof(*pixel));\n  p=GetVirtualPixelsFromNexus(image,virtual_pixel_method,x,y,1UL,1UL,\n    cache_info->nexus_info[id],exception);\n  return(CopyPixel(image,p,pixel));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t O n e V i r t u a l P i x e l I n f o                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetOneVirtualPixelInfo() returns a single pixel at the specified (x,y)\n%  location.  The image background color is returned if an error occurs.  If\n%  you plan to modify the pixel, use GetOneAuthenticPixel() instead.\n%\n%  The format of the GetOneVirtualPixelInfo() method is:\n%\n%      MagickBooleanType GetOneVirtualPixelInfo(const Image image,\n%        const VirtualPixelMethod virtual_pixel_method,const ssize_t x,\n%        const ssize_t y,PixelInfo *pixel,ExceptionInfo exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o virtual_pixel_method: the virtual pixel method.\n%\n%    o x,y:  these values define the location of the pixel to return.\n%\n%    o pixel: return a pixel at the specified (x,y) location.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType GetOneVirtualPixelInfo(const Image *image,\n  const VirtualPixelMethod virtual_pixel_method,const ssize_t x,const ssize_t y,\n  PixelInfo *pixel,ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  register const Quantum\n    *magick_restrict p;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  assert(id < (int) cache_info->number_threads);\n  GetPixelInfo(image,pixel);\n  p=GetVirtualPixelsFromNexus(image,virtual_pixel_method,x,y,1UL,1UL,\n    cache_info->nexus_info[id],exception);\n  if (p == (const Quantum *) NULL)\n    return(MagickFalse);\n  GetPixelInfoPixel(image,p,pixel);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t P i x e l C a c h e C o l o r s p a c e                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetPixelCacheColorspace() returns the class type of the pixel cache.\n%\n%  The format of the GetPixelCacheColorspace() method is:\n%\n%      Colorspace GetPixelCacheColorspace(Cache cache)\n%\n%  A description of each parameter follows:\n%\n%    o cache: the pixel cache.\n%\n*/\nMagickPrivate ColorspaceType GetPixelCacheColorspace(const Cache cache)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  assert(cache != (Cache) NULL);\n  cache_info=(CacheInfo *) cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  if (cache_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      cache_info->filename);\n  return(cache_info->colorspace);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t P i x e l C a c h e M e t h o d s                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetPixelCacheMethods() initializes the CacheMethods structure.\n%\n%  The format of the GetPixelCacheMethods() method is:\n%\n%      void GetPixelCacheMethods(CacheMethods *cache_methods)\n%\n%  A description of each parameter follows:\n%\n%    o cache_methods: Specifies a pointer to a CacheMethods structure.\n%\n*/\nMagickPrivate void GetPixelCacheMethods(CacheMethods *cache_methods)\n{\n  assert(cache_methods != (CacheMethods *) NULL);\n  (void) ResetMagickMemory(cache_methods,0,sizeof(*cache_methods));\n  cache_methods->get_virtual_pixel_handler=GetVirtualPixelCache;\n  cache_methods->get_virtual_pixels_handler=GetVirtualPixelsCache;\n  cache_methods->get_virtual_metacontent_from_handler=\n    GetVirtualMetacontentFromCache;\n  cache_methods->get_one_virtual_pixel_from_handler=GetOneVirtualPixelFromCache;\n  cache_methods->get_authentic_pixels_handler=GetAuthenticPixelsCache;\n  cache_methods->get_authentic_metacontent_from_handler=\n    GetAuthenticMetacontentFromCache;\n  cache_methods->get_authentic_pixels_from_handler=GetAuthenticPixelsFromCache;\n  cache_methods->get_one_authentic_pixel_from_handler=\n    GetOneAuthenticPixelFromCache;\n  cache_methods->queue_authentic_pixels_handler=QueueAuthenticPixelsCache;\n  cache_methods->sync_authentic_pixels_handler=SyncAuthenticPixelsCache;\n  cache_methods->destroy_pixel_handler=DestroyImagePixelCache;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t P i x e l C a c h e N e x u s E x t e n t                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetPixelCacheNexusExtent() returns the extent of the pixels associated\n%  corresponding with the last call to SetPixelCacheNexusPixels() or\n%  GetPixelCacheNexusPixels().\n%\n%  The format of the GetPixelCacheNexusExtent() method is:\n%\n%      MagickSizeType GetPixelCacheNexusExtent(const Cache cache,\n%        NexusInfo *nexus_info)\n%\n%  A description of each parameter follows:\n%\n%    o nexus_info: the nexus info.\n%\n*/\nMagickPrivate MagickSizeType GetPixelCacheNexusExtent(const Cache cache,\n  NexusInfo *magick_restrict nexus_info)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  MagickSizeType\n    extent;\n\n  assert(cache != NULL);\n  cache_info=(CacheInfo *) cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  extent=(MagickSizeType) nexus_info->region.width*nexus_info->region.height;\n  if (extent == 0)\n    return((MagickSizeType) cache_info->columns*cache_info->rows);\n  return(extent);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t P i x e l C a c h e P i x e l s                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetPixelCachePixels() returns the pixels associated with the specified image.\n%\n%  The format of the GetPixelCachePixels() method is:\n%\n%      void *GetPixelCachePixels(Image *image,MagickSizeType *length,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o length: the pixel cache length.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickPrivate void *GetPixelCachePixels(Image *image,MagickSizeType *length,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  assert(length != (MagickSizeType *) NULL);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  *length=0;\n  if ((cache_info->type != MemoryCache) && (cache_info->type != MapCache))\n    return((void *) NULL);\n  *length=cache_info->length;\n  return((void *) cache_info->pixels);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t P i x e l C a c h e S t o r a g e C l a s s                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetPixelCacheStorageClass() returns the class type of the pixel cache.\n%\n%  The format of the GetPixelCacheStorageClass() method is:\n%\n%      ClassType GetPixelCacheStorageClass(Cache cache)\n%\n%  A description of each parameter follows:\n%\n%    o type: GetPixelCacheStorageClass returns DirectClass or PseudoClass.\n%\n%    o cache: the pixel cache.\n%\n*/\nMagickPrivate ClassType GetPixelCacheStorageClass(const Cache cache)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  assert(cache != (Cache) NULL);\n  cache_info=(CacheInfo *) cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  if (cache_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      cache_info->filename);\n  return(cache_info->storage_class);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t P i x e l C a c h e T i l e S i z e                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetPixelCacheTileSize() returns the pixel cache tile size.\n%\n%  The format of the GetPixelCacheTileSize() method is:\n%\n%      void GetPixelCacheTileSize(const Image *image,size_t *width,\n%        size_t *height)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o width: the optimize cache tile width in pixels.\n%\n%    o height: the optimize cache tile height in pixels.\n%\n*/\nMagickPrivate void GetPixelCacheTileSize(const Image *image,size_t *width,\n  size_t *height)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  *width=2048UL/(cache_info->number_channels*sizeof(Quantum));\n  if (GetImagePixelCacheType(image) == DiskCache)\n    *width=8192UL/(cache_info->number_channels*sizeof(Quantum));\n  *height=(*width);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t P i x e l C a c h e V i r t u a l M e t h o d                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetPixelCacheVirtualMethod() gets the \"virtual pixels\" method for the\n%  pixel cache.  A virtual pixel is any pixel access that is outside the\n%  boundaries of the image cache.\n%\n%  The format of the GetPixelCacheVirtualMethod() method is:\n%\n%      VirtualPixelMethod GetPixelCacheVirtualMethod(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickPrivate VirtualPixelMethod GetPixelCacheVirtualMethod(const Image *image)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  return(cache_info->virtual_pixel_method);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t V i r t u a l M e t a c o n t e n t F r o m C a c h e               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetVirtualMetacontentFromCache() returns the meta-content corresponding with\n%  the last call to QueueAuthenticPixelsCache() or GetVirtualPixelCache().\n%\n%  The format of the GetVirtualMetacontentFromCache() method is:\n%\n%      void *GetVirtualMetacontentFromCache(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nstatic const void *GetVirtualMetacontentFromCache(const Image *image)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  const void\n    *magick_restrict metacontent;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  assert(id < (int) cache_info->number_threads);\n  metacontent=GetVirtualMetacontentFromNexus(cache_info,\n    cache_info->nexus_info[id]);\n  return(metacontent);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t V i r t u a l M e t a c o n t e n t F r o m N e x u s               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetVirtualMetacontentFromNexus() returns the meta-content for the specified\n%  cache nexus.\n%\n%  The format of the GetVirtualMetacontentFromNexus() method is:\n%\n%      const void *GetVirtualMetacontentFromNexus(const Cache cache,\n%        NexusInfo *nexus_info)\n%\n%  A description of each parameter follows:\n%\n%    o cache: the pixel cache.\n%\n%    o nexus_info: the cache nexus to return the meta-content.\n%\n*/\nMagickPrivate const void *GetVirtualMetacontentFromNexus(const Cache cache,\n  NexusInfo *magick_restrict nexus_info)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  assert(cache != (Cache) NULL);\n  cache_info=(CacheInfo *) cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  if (cache_info->storage_class == UndefinedClass)\n    return((void *) NULL);\n  return(nexus_info->metacontent);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t V i r t u a l M e t a c o n t e n t                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetVirtualMetacontent() returns the virtual metacontent corresponding with\n%  the last call to QueueAuthenticPixels() or GetVirtualPixels().  NULL is\n%  returned if the meta-content are not available.\n%\n%  The format of the GetVirtualMetacontent() method is:\n%\n%      const void *GetVirtualMetacontent(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport const void *GetVirtualMetacontent(const Image *image)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  const void\n    *magick_restrict metacontent;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  metacontent=cache_info->methods.get_virtual_metacontent_from_handler(image);\n  if (metacontent != (void *) NULL)\n    return(metacontent);\n  assert(id < (int) cache_info->number_threads);\n  metacontent=GetVirtualMetacontentFromNexus(cache_info,\n    cache_info->nexus_info[id]);\n  return(metacontent);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t V i r t u a l P i x e l s F r o m N e x u s                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetVirtualPixelsFromNexus() gets virtual pixels from the in-memory or disk\n%  pixel cache as defined by the geometry parameters.   A pointer to the pixels\n%  is returned if the pixels are transferred, otherwise a NULL is returned.\n%\n%  The format of the GetVirtualPixelsFromNexus() method is:\n%\n%      Quantum *GetVirtualPixelsFromNexus(const Image *image,\n%        const VirtualPixelMethod method,const ssize_t x,const ssize_t y,\n%        const size_t columns,const size_t rows,NexusInfo *nexus_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o virtual_pixel_method: the virtual pixel method.\n%\n%    o x,y,columns,rows:  These values define the perimeter of a region of\n%      pixels.\n%\n%    o nexus_info: the cache nexus to acquire.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic ssize_t\n  DitherMatrix[64] =\n  {\n     0,  48,  12,  60,   3,  51,  15,  63,\n    32,  16,  44,  28,  35,  19,  47,  31,\n     8,  56,   4,  52,  11,  59,   7,  55,\n    40,  24,  36,  20,  43,  27,  39,  23,\n     2,  50,  14,  62,   1,  49,  13,  61,\n    34,  18,  46,  30,  33,  17,  45,  29,\n    10,  58,   6,  54,   9,  57,   5,  53,\n    42,  26,  38,  22,  41,  25,  37,  21\n  };\n\nstatic inline ssize_t DitherX(const ssize_t x,const size_t columns)\n{\n  ssize_t\n    index;\n\n  index=x+DitherMatrix[x & 0x07]-32L;\n  if (index < 0L)\n    return(0L);\n  if (index >= (ssize_t) columns)\n    return((ssize_t) columns-1L);\n  return(index);\n}\n\nstatic inline ssize_t DitherY(const ssize_t y,const size_t rows)\n{\n  ssize_t\n    index;\n\n  index=y+DitherMatrix[y & 0x07]-32L;\n  if (index < 0L)\n    return(0L);\n  if (index >= (ssize_t) rows)\n    return((ssize_t) rows-1L);\n  return(index);\n}\n\nstatic inline ssize_t EdgeX(const ssize_t x,const size_t columns)\n{\n  if (x < 0L)\n    return(0L);\n  if (x >= (ssize_t) columns)\n    return((ssize_t) (columns-1));\n  return(x);\n}\n\nstatic inline ssize_t EdgeY(const ssize_t y,const size_t rows)\n{\n  if (y < 0L)\n    return(0L);\n  if (y >= (ssize_t) rows)\n    return((ssize_t) (rows-1));\n  return(y);\n}\n\nstatic inline ssize_t RandomX(RandomInfo *random_info,const size_t columns)\n{\n  return((ssize_t) (columns*GetPseudoRandomValue(random_info)));\n}\n\nstatic inline ssize_t RandomY(RandomInfo *random_info,const size_t rows)\n{\n  return((ssize_t) (rows*GetPseudoRandomValue(random_info)));\n}\n\nstatic inline MagickModulo VirtualPixelModulo(const ssize_t offset,\n  const size_t extent)\n{\n  MagickModulo\n    modulo;\n\n  /*\n    Compute the remainder of dividing offset by extent.  It returns not only\n    the quotient (tile the offset falls in) but also the positive remainer\n    within that tile such that 0 <= remainder < extent.  This method is\n    essentially a ldiv() using a floored modulo division rather than the\n    normal default truncated modulo division.\n  */\n  modulo.quotient=offset/(ssize_t) extent;\n  if (offset < 0L)\n    modulo.quotient--;\n  modulo.remainder=offset-modulo.quotient*(ssize_t) extent;\n  return(modulo);\n}\n\nMagickPrivate const Quantum *GetVirtualPixelsFromNexus(const Image *image,\n  const VirtualPixelMethod virtual_pixel_method,const ssize_t x,const ssize_t y,\n  const size_t columns,const size_t rows,NexusInfo *nexus_info,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  MagickOffsetType\n    offset;\n\n  MagickSizeType\n    length,\n    number_pixels;\n\n  NexusInfo\n    **magick_restrict virtual_nexus;\n\n  Quantum\n    *magick_restrict pixels,\n    virtual_pixel[MaxPixelChannels];\n\n  RectangleInfo\n    region;\n\n  register const Quantum\n    *magick_restrict p;\n\n  register const void\n    *magick_restrict r;\n\n  register Quantum\n    *magick_restrict q;\n\n  register ssize_t\n    i,\n    u;\n\n  register unsigned char\n    *magick_restrict s;\n\n  ssize_t\n    v;\n\n  void\n    *magick_restrict virtual_metacontent;\n\n  /*\n    Acquire pixels.\n  */\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  if (cache_info->type == UndefinedCache)\n    return((const Quantum *) NULL);\n  region.x=x;\n  region.y=y;\n  region.width=columns;\n  region.height=rows;\n  pixels=SetPixelCacheNexusPixels(cache_info,ReadMode,&region,nexus_info,\n    exception);\n  if (pixels == (Quantum *) NULL)\n    return((const Quantum *) NULL);\n  q=pixels;\n  offset=(MagickOffsetType) nexus_info->region.y*cache_info->columns+\n    nexus_info->region.x;\n  length=(MagickSizeType) (nexus_info->region.height-1L)*cache_info->columns+\n    nexus_info->region.width-1L;\n  number_pixels=(MagickSizeType) cache_info->columns*cache_info->rows;\n  if ((offset >= 0) && (((MagickSizeType) offset+length) < number_pixels))\n    if ((x >= 0) && ((ssize_t) (x+columns) <= (ssize_t) cache_info->columns) &&\n        (y >= 0) && ((ssize_t) (y+rows) <= (ssize_t) cache_info->rows))\n      {\n        MagickBooleanType\n          status;\n\n        /*\n          Pixel request is inside cache extents.\n        */\n        if (nexus_info->authentic_pixel_cache != MagickFalse)\n          return(q);\n        status=ReadPixelCachePixels(cache_info,nexus_info,exception);\n        if (status == MagickFalse)\n          return((const Quantum *) NULL);\n        if (cache_info->metacontent_extent != 0)\n          {\n            status=ReadPixelCacheMetacontent(cache_info,nexus_info,exception);\n            if (status == MagickFalse)\n              return((const Quantum *) NULL);\n          }\n        return(q);\n      }\n  /*\n    Pixel request is outside cache extents.\n  */\n  s=(unsigned char *) nexus_info->metacontent;\n  virtual_nexus=AcquirePixelCacheNexus(1);\n  if (virtual_nexus == (NexusInfo **) NULL)\n    {\n      if (virtual_nexus != (NexusInfo **) NULL)\n        virtual_nexus=DestroyPixelCacheNexus(virtual_nexus,1);\n      (void) ThrowMagickException(exception,GetMagickModule(),CacheError,\n        \"UnableToGetCacheNexus\",\"`%s'\",image->filename);\n      return((const Quantum *) NULL);\n    }\n  (void) ResetMagickMemory(virtual_pixel,0,cache_info->number_channels*\n    sizeof(*virtual_pixel));\n  virtual_metacontent=(void *) NULL;\n  switch (virtual_pixel_method)\n  {\n    case BackgroundVirtualPixelMethod:\n    case BlackVirtualPixelMethod:\n    case GrayVirtualPixelMethod:\n    case TransparentVirtualPixelMethod:\n    case MaskVirtualPixelMethod:\n    case WhiteVirtualPixelMethod:\n    case EdgeVirtualPixelMethod:\n    case CheckerTileVirtualPixelMethod:\n    case HorizontalTileVirtualPixelMethod:\n    case VerticalTileVirtualPixelMethod:\n    {\n      if (cache_info->metacontent_extent != 0)\n        {\n          /*\n            Acquire a metacontent buffer.\n          */\n          virtual_metacontent=(void *) AcquireQuantumMemory(1,\n            cache_info->metacontent_extent);\n          if (virtual_metacontent == (void *) NULL)\n            {\n              virtual_nexus=DestroyPixelCacheNexus(virtual_nexus,1);\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CacheError,\"UnableToGetCacheNexus\",\"`%s'\",image->filename);\n              return((const Quantum *) NULL);\n            }\n          (void) ResetMagickMemory(virtual_metacontent,0,\n            cache_info->metacontent_extent);\n        }\n      switch (virtual_pixel_method)\n      {\n        case BlackVirtualPixelMethod:\n        {\n          for (i=0; i < (ssize_t) cache_info->number_channels; i++)\n            SetPixelChannel(image,(PixelChannel) i,0,virtual_pixel);\n          SetPixelAlpha(image,OpaqueAlpha,virtual_pixel);\n          break;\n        }\n        case GrayVirtualPixelMethod:\n        {\n          for (i=0; i < (ssize_t) cache_info->number_channels; i++)\n            SetPixelChannel(image,(PixelChannel) i,QuantumRange/2,\n              virtual_pixel);\n          SetPixelAlpha(image,OpaqueAlpha,virtual_pixel);\n          break;\n        }\n        case TransparentVirtualPixelMethod:\n        {\n          for (i=0; i < (ssize_t) cache_info->number_channels; i++)\n            SetPixelChannel(image,(PixelChannel) i,0,virtual_pixel);\n          SetPixelAlpha(image,TransparentAlpha,virtual_pixel);\n          break;\n        }\n        case MaskVirtualPixelMethod:\n        case WhiteVirtualPixelMethod:\n        {\n          for (i=0; i < (ssize_t) cache_info->number_channels; i++)\n            SetPixelChannel(image,(PixelChannel) i,QuantumRange,virtual_pixel);\n          SetPixelAlpha(image,OpaqueAlpha,virtual_pixel);\n          break;\n        }\n        default:\n        {\n          SetPixelRed(image,ClampToQuantum(image->background_color.red),\n            virtual_pixel);\n          SetPixelGreen(image,ClampToQuantum(image->background_color.green),\n            virtual_pixel);\n          SetPixelBlue(image,ClampToQuantum(image->background_color.blue),\n            virtual_pixel);\n          SetPixelBlack(image,ClampToQuantum(image->background_color.black),\n            virtual_pixel);\n          SetPixelAlpha(image,ClampToQuantum(image->background_color.alpha),\n            virtual_pixel);\n          break;\n        }\n      }\n      break;\n    }\n    default:\n      break;\n  }\n  for (v=0; v < (ssize_t) rows; v++)\n  {\n    ssize_t\n      y_offset;\n\n    y_offset=y+v;\n    if ((virtual_pixel_method == EdgeVirtualPixelMethod) ||\n        (virtual_pixel_method == UndefinedVirtualPixelMethod))\n      y_offset=EdgeY(y_offset,cache_info->rows);\n    for (u=0; u < (ssize_t) columns; u+=length)\n    {\n      ssize_t\n        x_offset;\n\n      x_offset=x+u;\n      length=(MagickSizeType) MagickMin(cache_info->columns-x_offset,columns-u);\n      if (((x_offset < 0) || (x_offset >= (ssize_t) cache_info->columns)) ||\n          ((y_offset < 0) || (y_offset >= (ssize_t) cache_info->rows)) ||\n          (length == 0))\n        {\n          MagickModulo\n            x_modulo,\n            y_modulo;\n\n          /*\n            Transfer a single pixel.\n          */\n          length=(MagickSizeType) 1;\n          switch (virtual_pixel_method)\n          {\n            case EdgeVirtualPixelMethod:\n            default:\n            {\n              p=GetVirtualPixelsFromNexus(image,virtual_pixel_method,\n                EdgeX(x_offset,cache_info->columns),\n                EdgeY(y_offset,cache_info->rows),1UL,1UL,*virtual_nexus,\n                exception);\n              r=GetVirtualMetacontentFromNexus(cache_info,*virtual_nexus);\n              break;\n            }\n            case RandomVirtualPixelMethod:\n            {\n              if (cache_info->random_info == (RandomInfo *) NULL)\n                cache_info->random_info=AcquireRandomInfo();\n              p=GetVirtualPixelsFromNexus(image,virtual_pixel_method,\n                RandomX(cache_info->random_info,cache_info->columns),\n                RandomY(cache_info->random_info,cache_info->rows),1UL,1UL,\n                *virtual_nexus,exception);\n              r=GetVirtualMetacontentFromNexus(cache_info,*virtual_nexus);\n              break;\n            }\n            case DitherVirtualPixelMethod:\n            {\n              p=GetVirtualPixelsFromNexus(image,virtual_pixel_method,\n                DitherX(x_offset,cache_info->columns),\n                DitherY(y_offset,cache_info->rows),1UL,1UL,*virtual_nexus,\n                exception);\n              r=GetVirtualMetacontentFromNexus(cache_info,*virtual_nexus);\n              break;\n            }\n            case TileVirtualPixelMethod:\n            {\n              x_modulo=VirtualPixelModulo(x_offset,cache_info->columns);\n              y_modulo=VirtualPixelModulo(y_offset,cache_info->rows);\n              p=GetVirtualPixelsFromNexus(image,virtual_pixel_method,\n                x_modulo.remainder,y_modulo.remainder,1UL,1UL,*virtual_nexus,\n                exception);\n              r=GetVirtualMetacontentFromNexus(cache_info,*virtual_nexus);\n              break;\n            }\n            case MirrorVirtualPixelMethod:\n            {\n              x_modulo=VirtualPixelModulo(x_offset,cache_info->columns);\n              if ((x_modulo.quotient & 0x01) == 1L)\n                x_modulo.remainder=(ssize_t) cache_info->columns-\n                  x_modulo.remainder-1L;\n              y_modulo=VirtualPixelModulo(y_offset,cache_info->rows);\n              if ((y_modulo.quotient & 0x01) == 1L)\n                y_modulo.remainder=(ssize_t) cache_info->rows-\n                  y_modulo.remainder-1L;\n              p=GetVirtualPixelsFromNexus(image,virtual_pixel_method,\n                x_modulo.remainder,y_modulo.remainder,1UL,1UL,*virtual_nexus,\n                exception);\n              r=GetVirtualMetacontentFromNexus(cache_info,*virtual_nexus);\n              break;\n            }\n            case HorizontalTileEdgeVirtualPixelMethod:\n            {\n              x_modulo=VirtualPixelModulo(x_offset,cache_info->columns);\n              p=GetVirtualPixelsFromNexus(image,virtual_pixel_method,\n                x_modulo.remainder,EdgeY(y_offset,cache_info->rows),1UL,1UL,\n                *virtual_nexus,exception);\n              r=GetVirtualMetacontentFromNexus(cache_info,*virtual_nexus);\n              break;\n            }\n            case VerticalTileEdgeVirtualPixelMethod:\n            {\n              y_modulo=VirtualPixelModulo(y_offset,cache_info->rows);\n              p=GetVirtualPixelsFromNexus(image,virtual_pixel_method,\n                EdgeX(x_offset,cache_info->columns),y_modulo.remainder,1UL,1UL,\n                *virtual_nexus,exception);\n              r=GetVirtualMetacontentFromNexus(cache_info,*virtual_nexus);\n              break;\n            }\n            case BackgroundVirtualPixelMethod:\n            case BlackVirtualPixelMethod:\n            case GrayVirtualPixelMethod:\n            case TransparentVirtualPixelMethod:\n            case MaskVirtualPixelMethod:\n            case WhiteVirtualPixelMethod:\n            {\n              p=virtual_pixel;\n              r=virtual_metacontent;\n              break;\n            }\n            case CheckerTileVirtualPixelMethod:\n            {\n              x_modulo=VirtualPixelModulo(x_offset,cache_info->columns);\n              y_modulo=VirtualPixelModulo(y_offset,cache_info->rows);\n              if (((x_modulo.quotient ^ y_modulo.quotient) & 0x01) != 0L)\n                {\n                  p=virtual_pixel;\n                  r=virtual_metacontent;\n                  break;\n                }\n              p=GetVirtualPixelsFromNexus(image,virtual_pixel_method,\n                x_modulo.remainder,y_modulo.remainder,1UL,1UL,*virtual_nexus,\n                exception);\n              r=GetVirtualMetacontentFromNexus(cache_info,*virtual_nexus);\n              break;\n            }\n            case HorizontalTileVirtualPixelMethod:\n            {\n              if ((y_offset < 0) || (y_offset >= (ssize_t) cache_info->rows))\n                {\n                  p=virtual_pixel;\n                  r=virtual_metacontent;\n                  break;\n                }\n              x_modulo=VirtualPixelModulo(x_offset,cache_info->columns);\n              y_modulo=VirtualPixelModulo(y_offset,cache_info->rows);\n              p=GetVirtualPixelsFromNexus(image,virtual_pixel_method,\n                x_modulo.remainder,y_modulo.remainder,1UL,1UL,*virtual_nexus,\n                exception);\n              r=GetVirtualMetacontentFromNexus(cache_info,*virtual_nexus);\n              break;\n            }\n            case VerticalTileVirtualPixelMethod:\n            {\n              if ((x_offset < 0) || (x_offset >= (ssize_t) cache_info->columns))\n                {\n                  p=virtual_pixel;\n                  r=virtual_metacontent;\n                  break;\n                }\n              x_modulo=VirtualPixelModulo(x_offset,cache_info->columns);\n              y_modulo=VirtualPixelModulo(y_offset,cache_info->rows);\n              p=GetVirtualPixelsFromNexus(image,virtual_pixel_method,\n                x_modulo.remainder,y_modulo.remainder,1UL,1UL,*virtual_nexus,\n                exception);\n              r=GetVirtualMetacontentFromNexus(cache_info,*virtual_nexus);\n              break;\n            }\n          }\n          if (p == (const Quantum *) NULL)\n            break;\n          (void) memcpy(q,p,(size_t) length*cache_info->number_channels*\n            sizeof(*p));\n          q+=cache_info->number_channels;\n          if ((s != (void *) NULL) && (r != (const void *) NULL))\n            {\n              (void) memcpy(s,r,(size_t) cache_info->metacontent_extent);\n              s+=cache_info->metacontent_extent;\n            }\n          continue;\n        }\n      /*\n        Transfer a run of pixels.\n      */\n      p=GetVirtualPixelsFromNexus(image,virtual_pixel_method,x_offset,y_offset,\n        (size_t) length,1UL,*virtual_nexus,exception);\n      if (p == (const Quantum *) NULL)\n        break;\n      r=GetVirtualMetacontentFromNexus(cache_info,*virtual_nexus);\n      (void) memcpy(q,p,(size_t) length*cache_info->number_channels*sizeof(*p));\n      q+=length*cache_info->number_channels;\n      if ((r != (void *) NULL) && (s != (const void *) NULL))\n        {\n          (void) memcpy(s,r,(size_t) length);\n          s+=length*cache_info->metacontent_extent;\n        }\n    }\n    if (u < (ssize_t) columns)\n      break;\n  }\n  /*\n    Free resources.\n  */\n  if (virtual_metacontent != (void *) NULL)\n    virtual_metacontent=(void *) RelinquishMagickMemory(virtual_metacontent);\n  virtual_nexus=DestroyPixelCacheNexus(virtual_nexus,1);\n  if (v < (ssize_t) rows)\n    return((const Quantum *) NULL);\n  return(pixels);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t V i r t u a l P i x e l C a c h e                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetVirtualPixelCache() get virtual pixels from the in-memory or disk pixel\n%  cache as defined by the geometry parameters.   A pointer to the pixels\n%  is returned if the pixels are transferred, otherwise a NULL is returned.\n%\n%  The format of the GetVirtualPixelCache() method is:\n%\n%      const Quantum *GetVirtualPixelCache(const Image *image,\n%        const VirtualPixelMethod virtual_pixel_method,const ssize_t x,\n%        const ssize_t y,const size_t columns,const size_t rows,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o virtual_pixel_method: the virtual pixel method.\n%\n%    o x,y,columns,rows:  These values define the perimeter of a region of\n%      pixels.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic const Quantum *GetVirtualPixelCache(const Image *image,\n  const VirtualPixelMethod virtual_pixel_method,const ssize_t x,const ssize_t y,\n  const size_t columns,const size_t rows,ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  const Quantum\n    *magick_restrict p;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  assert(id < (int) cache_info->number_threads);\n  p=GetVirtualPixelsFromNexus(image,virtual_pixel_method,x,y,columns,rows,\n    cache_info->nexus_info[id],exception);\n  return(p);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t V i r t u a l P i x e l Q u e u e                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetVirtualPixelQueue() returns the virtual pixels associated corresponding\n%  with the last call to QueueAuthenticPixels() or GetVirtualPixels().\n%\n%  The format of the GetVirtualPixelQueue() method is:\n%\n%      const Quantum *GetVirtualPixelQueue(const Image image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport const Quantum *GetVirtualPixelQueue(const Image *image)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  if (cache_info->methods.get_virtual_pixels_handler !=\n       (GetVirtualPixelsHandler) NULL)\n    return(cache_info->methods.get_virtual_pixels_handler(image));\n  assert(id < (int) cache_info->number_threads);\n  return(GetVirtualPixelsNexus(cache_info,cache_info->nexus_info[id]));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t V i r t u a l P i x e l s                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetVirtualPixels() returns an immutable pixel region. If the\n%  region is successfully accessed, a pointer to it is returned, otherwise\n%  NULL is returned.  The returned pointer may point to a temporary working\n%  copy of the pixels or it may point to the original pixels in memory.\n%  Performance is maximized if the selected region is part of one row, or one\n%  or more full rows, since there is opportunity to access the pixels in-place\n%  (without a copy) if the image is in memory, or in a memory-mapped file.  The\n%  returned pointer must *never* be deallocated by the user.\n%\n%  Pixels accessed via the returned pointer represent a simple array of type\n%  Quantum.  If the image type is CMYK or the storage class is PseudoClass,\n%  call GetAuthenticMetacontent() after invoking GetAuthenticPixels() to\n%  access the meta-content (of type void) corresponding to the the\n%  region.\n%\n%  If you plan to modify the pixels, use GetAuthenticPixels() instead.\n%\n%  Note, the GetVirtualPixels() and GetAuthenticPixels() methods are not thread-\n%  safe.  In a threaded environment, use GetCacheViewVirtualPixels() or\n%  GetCacheViewAuthenticPixels() instead.\n%\n%  The format of the GetVirtualPixels() method is:\n%\n%      const Quantum *GetVirtualPixels(const Image *image,const ssize_t x,\n%        const ssize_t y,const size_t columns,const size_t rows,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o x,y,columns,rows:  These values define the perimeter of a region of\n%      pixels.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport const Quantum *GetVirtualPixels(const Image *image,\n  const ssize_t x,const ssize_t y,const size_t columns,const size_t rows,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  const Quantum\n    *magick_restrict p;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  if (cache_info->methods.get_virtual_pixel_handler !=\n       (GetVirtualPixelHandler) NULL)\n    return(cache_info->methods.get_virtual_pixel_handler(image,\n      GetPixelCacheVirtualMethod(image),x,y,columns,rows,exception));\n  assert(id < (int) cache_info->number_threads);\n  p=GetVirtualPixelsFromNexus(image,GetPixelCacheVirtualMethod(image),x,y,\n    columns,rows,cache_info->nexus_info[id],exception);\n  return(p);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t V i r t u a l P i x e l s F r o m C a c h e                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetVirtualPixelsCache() returns the pixels associated corresponding with the\n%  last call to QueueAuthenticPixelsCache() or GetVirtualPixelCache().\n%\n%  The format of the GetVirtualPixelsCache() method is:\n%\n%      Quantum *GetVirtualPixelsCache(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nstatic const Quantum *GetVirtualPixelsCache(const Image *image)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  assert(id < (int) cache_info->number_threads);\n  return(GetVirtualPixelsNexus(image->cache,cache_info->nexus_info[id]));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t V i r t u a l P i x e l s N e x u s                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetVirtualPixelsNexus() returns the pixels associated with the specified\n%  cache nexus.\n%\n%  The format of the GetVirtualPixelsNexus() method is:\n%\n%      const Quantum *GetVirtualPixelsNexus(const Cache cache,\n%        NexusInfo *nexus_info)\n%\n%  A description of each parameter follows:\n%\n%    o cache: the pixel cache.\n%\n%    o nexus_info: the cache nexus to return the colormap pixels.\n%\n*/\nMagickPrivate const Quantum *GetVirtualPixelsNexus(const Cache cache,\n  NexusInfo *magick_restrict nexus_info)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  assert(cache != (Cache) NULL);\n  cache_info=(CacheInfo *) cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  if (cache_info->storage_class == UndefinedClass)\n    return((Quantum *) NULL);\n  return((const Quantum *) nexus_info->pixels);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   O p e n P i x e l C a c h e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  OpenPixelCache() allocates the pixel cache.  This includes defining the cache\n%  dimensions, allocating space for the image pixels and optionally the\n%  metacontent, and memory mapping the cache if it is disk based.  The cache\n%  nexus array is initialized as well.\n%\n%  The format of the OpenPixelCache() method is:\n%\n%      MagickBooleanType OpenPixelCache(Image *image,const MapMode mode,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o mode: ReadMode, WriteMode, or IOMode.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\n#if defined(SIGBUS)\nstatic void CacheSignalHandler(int status)\n{\n  ThrowFatalException(CacheFatalError,\"UnableToExtendPixelCache\");\n}\n#endif\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\nstatic MagickBooleanType OpenPixelCacheOnDisk(CacheInfo *cache_info,\n  const MapMode mode)\n{\n  int\n    file;\n\n  /*\n    Open pixel cache on disk.\n  */\n  if ((cache_info->file != -1) && (cache_info->mode == mode))\n    return(MagickTrue);  /* cache already open and in the proper mode */\n  if (*cache_info->cache_filename == '\\0')\n    file=AcquireUniqueFileResource(cache_info->cache_filename);\n  else\n    switch (mode)\n    {\n      case ReadMode:\n      {\n        file=open_utf8(cache_info->cache_filename,O_RDONLY | O_BINARY,0);\n        break;\n      }\n      case WriteMode:\n      {\n        file=open_utf8(cache_info->cache_filename,O_WRONLY | O_CREAT |\n          O_BINARY | O_EXCL,S_MODE);\n        if (file == -1)\n          file=open_utf8(cache_info->cache_filename,O_WRONLY | O_BINARY,S_MODE);\n        break;\n      }\n      case IOMode:\n      default:\n      {\n        file=open_utf8(cache_info->cache_filename,O_RDWR | O_CREAT | O_BINARY |\n          O_EXCL,S_MODE);\n        if (file == -1)\n          file=open_utf8(cache_info->cache_filename,O_RDWR | O_BINARY,S_MODE);\n        break;\n      }\n    }\n  if (file == -1)\n    return(MagickFalse);\n  (void) AcquireMagickResource(FileResource,1);\n  if (cache_info->file != -1)\n    (void) ClosePixelCacheOnDisk(cache_info);\n  cache_info->file=file;\n  cache_info->mode=mode;\n  return(MagickTrue);\n}\n\nstatic inline MagickOffsetType WritePixelCacheRegion(\n  const CacheInfo *magick_restrict cache_info,const MagickOffsetType offset,\n  const MagickSizeType length,const unsigned char *magick_restrict buffer)\n{\n  register MagickOffsetType\n    i;\n\n  ssize_t\n    count;\n\n#if !defined(MAGICKCORE_HAVE_PWRITE)\n  if (lseek(cache_info->file,offset,SEEK_SET) < 0)\n    return((MagickOffsetType) -1);\n#endif\n  count=0;\n  for (i=0; i < (MagickOffsetType) length; i+=count)\n  {\n#if !defined(MAGICKCORE_HAVE_PWRITE)\n    count=write(cache_info->file,buffer+i,(size_t) MagickMin(length-i,(size_t)\n      SSIZE_MAX));\n#else\n    count=pwrite(cache_info->file,buffer+i,(size_t) MagickMin(length-i,(size_t)\n      SSIZE_MAX),(off_t) (offset+i));\n#endif\n    if (count <= 0)\n      {\n        count=0;\n        if (errno != EINTR)\n          break;\n      }\n  }\n  return(i);\n}\n\nstatic MagickBooleanType SetPixelCacheExtent(Image *image,MagickSizeType length)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  MagickOffsetType\n    count,\n    extent,\n    offset;\n\n  cache_info=(CacheInfo *) image->cache;\n  if (image->debug != MagickFalse)\n    {\n      char\n        format[MagickPathExtent],\n        message[MagickPathExtent];\n\n      (void) FormatMagickSize(length,MagickFalse,\"B\",MagickPathExtent,format);\n      (void) FormatLocaleString(message,MagickPathExtent,\n        \"extend %s (%s[%d], disk, %s)\",cache_info->filename,\n        cache_info->cache_filename,cache_info->file,format);\n      (void) LogMagickEvent(CacheEvent,GetMagickModule(),\"%s\",message);\n    }\n  if (length != (MagickSizeType) ((MagickOffsetType) length))\n    return(MagickFalse);\n  offset=(MagickOffsetType) lseek(cache_info->file,0,SEEK_END);\n  if (offset < 0)\n    return(MagickFalse);\n  if ((MagickSizeType) offset >= length)\n    count=(MagickOffsetType) 1;\n  else\n    {\n      extent=(MagickOffsetType) length-1;\n      count=WritePixelCacheRegion(cache_info,extent,1,(const unsigned char *)\n        \"\");\n#if defined(MAGICKCORE_HAVE_POSIX_FALLOCATE)\n      if (cache_info->synchronize != MagickFalse)\n        (void) posix_fallocate(cache_info->file,offset+1,extent-offset);\n#endif\n#if defined(SIGBUS)\n      (void) signal(SIGBUS,CacheSignalHandler);\n#endif\n    }\n  offset=(MagickOffsetType) lseek(cache_info->file,0,SEEK_SET);\n  if (offset < 0)\n    return(MagickFalse);\n  return(count != (MagickOffsetType) 1 ? MagickFalse : MagickTrue);\n}\n\nstatic MagickBooleanType OpenPixelCache(Image *image,const MapMode mode,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info,\n    source_info;\n\n  char\n    format[MagickPathExtent],\n    message[MagickPathExtent];\n\n  const char\n    *type;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    length,\n    number_pixels;\n\n  size_t\n    columns,\n    packet_size;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if ((image->columns == 0) || (image->rows == 0))\n    ThrowBinaryException(CacheError,\"NoPixelsDefinedInCache\",image->filename);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  if ((AcquireMagickResource(WidthResource,image->columns) == MagickFalse) ||\n      (AcquireMagickResource(HeightResource,image->rows) == MagickFalse))\n    ThrowBinaryException(ImageError,\"WidthOrHeightExceedsLimit\",\n      image->filename);\n  source_info=(*cache_info);\n  source_info.file=(-1);\n  (void) FormatLocaleString(cache_info->filename,MagickPathExtent,\"%s[%.20g]\",\n    image->filename,(double) GetImageIndexInList(image));\n  cache_info->storage_class=image->storage_class;\n  cache_info->colorspace=image->colorspace;\n  cache_info->alpha_trait=image->alpha_trait;\n  cache_info->read_mask=image->read_mask;\n  cache_info->write_mask=image->write_mask;\n  cache_info->rows=image->rows;\n  cache_info->columns=image->columns;\n  InitializePixelChannelMap(image);\n  cache_info->number_channels=GetPixelChannels(image);\n  (void) memcpy(cache_info->channel_map,image->channel_map,MaxPixelChannels*\n    sizeof(*image->channel_map));\n  cache_info->metacontent_extent=image->metacontent_extent;\n  cache_info->mode=mode;\n  number_pixels=(MagickSizeType) cache_info->columns*cache_info->rows;\n  packet_size=cache_info->number_channels*sizeof(Quantum);\n  if (image->metacontent_extent != 0)\n    packet_size+=cache_info->metacontent_extent;\n  length=number_pixels*packet_size;\n  columns=(size_t) (length/cache_info->rows/packet_size);\n  if ((cache_info->columns != columns) || ((ssize_t) cache_info->columns < 0) ||\n      ((ssize_t) cache_info->rows < 0))\n    ThrowBinaryException(ResourceLimitError,\"PixelCacheAllocationFailed\",\n      image->filename);\n  cache_info->length=length;\n  if (image->ping != MagickFalse)\n    {\n      cache_info->storage_class=image->storage_class;\n      cache_info->colorspace=image->colorspace;\n      cache_info->type=PingCache;\n      return(MagickTrue);\n    }\n  status=AcquireMagickResource(AreaResource,cache_info->length);\n  length=number_pixels*(cache_info->number_channels*sizeof(Quantum)+\n    cache_info->metacontent_extent);\n  if ((status != MagickFalse) && (length == (MagickSizeType) ((size_t) length)))\n    {\n      status=AcquireMagickResource(MemoryResource,cache_info->length);\n      if (((cache_info->type == UndefinedCache) && (status != MagickFalse)) ||\n          (cache_info->type == MemoryCache))\n        {\n          cache_info->mapped=MagickFalse;\n          cache_info->pixels=(Quantum *) MagickAssumeAligned(\n            AcquireAlignedMemory(1,(size_t) cache_info->length));\n          if (cache_info->pixels == (Quantum *) NULL)\n            cache_info->pixels=source_info.pixels;\n          else\n            {\n              /*\n                Create memory pixel cache.\n              */\n              status=MagickTrue;\n              cache_info->type=MemoryCache;\n              cache_info->metacontent=(void *) NULL;\n              if (cache_info->metacontent_extent != 0)\n                cache_info->metacontent=(void *) (cache_info->pixels+\n                  number_pixels*cache_info->number_channels);\n              if ((source_info.storage_class != UndefinedClass) &&\n                  (mode != ReadMode))\n                {\n                  status=ClonePixelCacheRepository(cache_info,&source_info,\n                    exception);\n                  RelinquishPixelCachePixels(&source_info);\n                }\n              if (image->debug != MagickFalse)\n                {\n                  (void) FormatMagickSize(cache_info->length,MagickTrue,\"B\",\n                    MagickPathExtent,format);\n                  type=CommandOptionToMnemonic(MagickCacheOptions,(ssize_t)\n                    cache_info->type);\n                  (void) FormatLocaleString(message,MagickPathExtent,\n                    \"open %s (%s %s, %.20gx%.20gx%.20g %s)\",\n                    cache_info->filename,cache_info->mapped != MagickFalse ?\n                    \"Anonymous\" : \"Heap\",type,(double) cache_info->columns,\n                    (double) cache_info->rows,(double)\n                    cache_info->number_channels,format);\n                  (void) LogMagickEvent(CacheEvent,GetMagickModule(),\"%s\",\n                    message);\n                }\n              return(status);\n            }\n        }\n      RelinquishMagickResource(MemoryResource,cache_info->length);\n    }\n  /*\n    Create pixel cache on disk.\n  */\n  status=AcquireMagickResource(DiskResource,cache_info->length);\n  if ((status == MagickFalse) || (cache_info->type == DistributedCache))\n    {\n      DistributeCacheInfo\n        *server_info;\n\n      if (cache_info->type == DistributedCache)\n        RelinquishMagickResource(DiskResource,cache_info->length);\n      server_info=AcquireDistributeCacheInfo(exception);\n      if (server_info != (DistributeCacheInfo *) NULL)\n        {\n          status=OpenDistributePixelCache(server_info,image);\n          if (status == MagickFalse)\n            {\n              ThrowFileException(exception,CacheError,\"UnableToOpenPixelCache\",\n                GetDistributeCacheHostname(server_info));\n              server_info=DestroyDistributeCacheInfo(server_info);\n            }\n          else\n            {\n              /*\n                Create a distributed pixel cache.\n              */\n              cache_info->type=DistributedCache;\n              cache_info->server_info=server_info;\n              (void) FormatLocaleString(cache_info->cache_filename,\n                MagickPathExtent,\"%s:%d\",GetDistributeCacheHostname(\n                (DistributeCacheInfo *) cache_info->server_info),\n                GetDistributeCachePort((DistributeCacheInfo *)\n                cache_info->server_info));\n              if ((source_info.storage_class != UndefinedClass) &&\n                  (mode != ReadMode))\n                {\n                  status=ClonePixelCacheRepository(cache_info,&source_info,\n                    exception);\n                  RelinquishPixelCachePixels(&source_info);\n                }\n              if (image->debug != MagickFalse)\n                {\n                  (void) FormatMagickSize(cache_info->length,MagickFalse,\"B\",\n                    MagickPathExtent,format);\n                  type=CommandOptionToMnemonic(MagickCacheOptions,(ssize_t)\n                    cache_info->type);\n                  (void) FormatLocaleString(message,MagickPathExtent,\n                    \"open %s (%s[%d], %s, %.20gx%.20gx%.20g %s)\",\n                    cache_info->filename,cache_info->cache_filename,\n                    GetDistributeCacheFile((DistributeCacheInfo *)\n                    cache_info->server_info),type,(double) cache_info->columns,\n                    (double) cache_info->rows,(double)\n                    cache_info->number_channels,format);\n                  (void) LogMagickEvent(CacheEvent,GetMagickModule(),\"%s\",\n                    message);\n                }\n              return(MagickTrue);\n            }\n        }\n      RelinquishMagickResource(DiskResource,cache_info->length);\n      cache_info->type=UndefinedCache;\n      (void) ThrowMagickException(exception,GetMagickModule(),CacheError,\n        \"CacheResourcesExhausted\",\"`%s'\",image->filename);\n      return(MagickFalse);\n    }\n  if ((source_info.storage_class != UndefinedClass) && (mode != ReadMode))\n    {\n      (void) ClosePixelCacheOnDisk(cache_info);\n      *cache_info->cache_filename='\\0';\n    }\n  if (OpenPixelCacheOnDisk(cache_info,mode) == MagickFalse)\n    {\n      RelinquishMagickResource(DiskResource,cache_info->length);\n      cache_info->type=UndefinedCache;\n      ThrowFileException(exception,CacheError,\"UnableToOpenPixelCache\",\n        image->filename);\n      return(MagickFalse);\n    }\n  status=SetPixelCacheExtent(image,(MagickSizeType) cache_info->offset+\n    cache_info->length);\n  if (status == MagickFalse)\n    {\n      cache_info->type=UndefinedCache;\n      ThrowFileException(exception,CacheError,\"UnableToExtendCache\",\n        image->filename);\n      return(MagickFalse);\n    }\n  length=number_pixels*(cache_info->number_channels*sizeof(Quantum)+\n    cache_info->metacontent_extent);\n  if (length != (MagickSizeType) ((size_t) length))\n    cache_info->type=DiskCache;\n  else\n    {\n      status=AcquireMagickResource(MapResource,cache_info->length);\n      if ((status == MagickFalse) && (cache_info->type != MapCache) &&\n          (cache_info->type != MemoryCache))\n        cache_info->type=DiskCache;\n      else\n        {\n          cache_info->pixels=(Quantum *) MapBlob(cache_info->file,mode,\n            cache_info->offset,(size_t) cache_info->length);\n          if (cache_info->pixels == (Quantum *) NULL)\n            {\n              cache_info->type=DiskCache;\n              cache_info->pixels=source_info.pixels;\n            }\n          else\n            {\n              /*\n                Create file-backed memory-mapped pixel cache.\n              */\n              status=MagickTrue;\n              (void) ClosePixelCacheOnDisk(cache_info);\n              cache_info->type=MapCache;\n              cache_info->mapped=MagickTrue;\n              cache_info->metacontent=(void *) NULL;\n              if (cache_info->metacontent_extent != 0)\n                cache_info->metacontent=(void *) (cache_info->pixels+\n                  number_pixels*cache_info->number_channels);\n              if ((source_info.storage_class != UndefinedClass) &&\n                  (mode != ReadMode))\n                {\n                  status=ClonePixelCacheRepository(cache_info,&source_info,\n                    exception);\n                  RelinquishPixelCachePixels(&source_info);\n                }\n              if (image->debug != MagickFalse)\n                {\n                  (void) FormatMagickSize(cache_info->length,MagickTrue,\"B\",\n                    MagickPathExtent,format);\n                  type=CommandOptionToMnemonic(MagickCacheOptions,(ssize_t)\n                    cache_info->type);\n                  (void) FormatLocaleString(message,MagickPathExtent,\n                    \"open %s (%s[%d], %s, %.20gx%.20gx%.20g %s)\",\n                    cache_info->filename,cache_info->cache_filename,\n                    cache_info->file,type,(double) cache_info->columns,(double)\n                    cache_info->rows,(double) cache_info->number_channels,\n                    format);\n                  (void) LogMagickEvent(CacheEvent,GetMagickModule(),\"%s\",\n                    message);\n                }\n              if (status == MagickFalse)\n                cache_info->type=UndefinedCache;\n              return(status);\n            }\n        }\n      RelinquishMagickResource(MapResource,cache_info->length);\n    }\n  status=MagickTrue;\n  if ((source_info.storage_class != UndefinedClass) && (mode != ReadMode))\n    {\n      status=ClonePixelCacheRepository(cache_info,&source_info,exception);\n      RelinquishPixelCachePixels(&source_info);\n    }\n  if (image->debug != MagickFalse)\n    {\n      (void) FormatMagickSize(cache_info->length,MagickFalse,\"B\",\n        MagickPathExtent,format);\n      type=CommandOptionToMnemonic(MagickCacheOptions,(ssize_t)\n        cache_info->type);\n      (void) FormatLocaleString(message,MagickPathExtent,\n        \"open %s (%s[%d], %s, %.20gx%.20gx%.20g %s)\",cache_info->filename,\n        cache_info->cache_filename,cache_info->file,type,(double)\n        cache_info->columns,(double) cache_info->rows,(double)\n        cache_info->number_channels,format);\n      (void) LogMagickEvent(CacheEvent,GetMagickModule(),\"%s\",message);\n    }\n  if (status == MagickFalse)\n    cache_info->type=UndefinedCache;\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   P e r s i s t P i x e l C a c h e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  PersistPixelCache() attaches to or initializes a persistent pixel cache.  A\n%  persistent pixel cache is one that resides on disk and is not destroyed\n%  when the program exits.\n%\n%  The format of the PersistPixelCache() method is:\n%\n%      MagickBooleanType PersistPixelCache(Image *image,const char *filename,\n%        const MagickBooleanType attach,MagickOffsetType *offset,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o filename: the persistent pixel cache filename.\n%\n%    o attach: A value other than zero initializes the persistent pixel cache.\n%\n%    o initialize: A value other than zero initializes the persistent pixel\n%      cache.\n%\n%    o offset: the offset in the persistent cache to store pixels.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType PersistPixelCache(Image *image,\n  const char *filename,const MagickBooleanType attach,MagickOffsetType *offset,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info,\n    *magick_restrict clone_info;\n\n  Image\n    clone_image;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    page_size;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(image->cache != (void *) NULL);\n  assert(filename != (const char *) NULL);\n  assert(offset != (MagickOffsetType *) NULL);\n  page_size=GetMagickPageSize();\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  if (attach != MagickFalse)\n    {\n      /*\n        Attach existing persistent pixel cache.\n      */\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CacheEvent,GetMagickModule(),\n          \"attach persistent cache\");\n      (void) CopyMagickString(cache_info->cache_filename,filename,\n        MagickPathExtent);\n      cache_info->type=DiskCache;\n      cache_info->offset=(*offset);\n      if (OpenPixelCache(image,ReadMode,exception) == MagickFalse)\n        return(MagickFalse);\n      *offset+=cache_info->length+page_size-(cache_info->length % page_size);\n      return(MagickTrue);\n    }\n  if ((cache_info->mode != ReadMode) &&\n      ((cache_info->type == DiskCache) || (cache_info->type == MapCache)) &&\n      (cache_info->reference_count == 1))\n    {\n      LockSemaphoreInfo(cache_info->semaphore);\n      if ((cache_info->mode != ReadMode) &&\n          ((cache_info->type == DiskCache) || (cache_info->type == MapCache)) &&\n          (cache_info->reference_count == 1))\n        {\n          /*\n            Usurp existing persistent pixel cache.\n          */\n          if (rename_utf8(cache_info->cache_filename, filename) == 0)\n            {\n              (void) CopyMagickString(cache_info->cache_filename,filename,\n                MagickPathExtent);\n              *offset+=cache_info->length+page_size-(cache_info->length %\n                page_size);\n              UnlockSemaphoreInfo(cache_info->semaphore);\n              cache_info=(CacheInfo *) ReferencePixelCache(cache_info);\n              if (image->debug != MagickFalse)\n                (void) LogMagickEvent(CacheEvent,GetMagickModule(),\n                  \"Usurp resident persistent cache\");\n              return(MagickTrue);\n            }\n        }\n      UnlockSemaphoreInfo(cache_info->semaphore);\n    }\n  /*\n    Clone persistent pixel cache.\n  */\n  clone_image=(*image);\n  clone_info=(CacheInfo *) clone_image.cache;\n  image->cache=ClonePixelCache(cache_info);\n  cache_info=(CacheInfo *) ReferencePixelCache(image->cache);\n  (void) CopyMagickString(cache_info->cache_filename,filename,MagickPathExtent);\n  cache_info->type=DiskCache;\n  cache_info->offset=(*offset);\n  cache_info=(CacheInfo *) image->cache;\n  status=OpenPixelCache(image,IOMode,exception);\n  if (status != MagickFalse)\n    status=ClonePixelCacheRepository(cache_info,clone_info,exception);\n  *offset+=cache_info->length+page_size-(cache_info->length % page_size);\n  clone_info=(CacheInfo *) DestroyPixelCache(clone_info);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   Q u e u e A u t h e n t i c P i x e l C a c h e N e x u s                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  QueueAuthenticPixelCacheNexus() allocates an region to store image pixels as\n%  defined by the region rectangle and returns a pointer to the region.  This\n%  region is subsequently transferred from the pixel cache with\n%  SyncAuthenticPixelsCache().  A pointer to the pixels is returned if the\n%  pixels are transferred, otherwise a NULL is returned.\n%\n%  The format of the QueueAuthenticPixelCacheNexus() method is:\n%\n%      Quantum *QueueAuthenticPixelCacheNexus(Image *image,const ssize_t x,\n%        const ssize_t y,const size_t columns,const size_t rows,\n%        const MagickBooleanType clone,NexusInfo *nexus_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o x,y,columns,rows:  These values define the perimeter of a region of\n%      pixels.\n%\n%    o nexus_info: the cache nexus to set.\n%\n%    o clone: clone the pixel cache.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickPrivate Quantum *QueueAuthenticPixelCacheNexus(Image *image,\n  const ssize_t x,const ssize_t y,const size_t columns,const size_t rows,\n  const MagickBooleanType clone,NexusInfo *nexus_info,ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  MagickOffsetType\n    offset;\n\n  MagickSizeType\n    number_pixels;\n\n  Quantum\n    *magick_restrict pixels;\n\n  RectangleInfo\n    region;\n\n  /*\n    Validate pixel cache geometry.\n  */\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) GetImagePixelCache(image,clone,exception);\n  if (cache_info == (Cache) NULL)\n    return((Quantum *) NULL);\n  assert(cache_info->signature == MagickCoreSignature);\n  if ((cache_info->columns == 0) || (cache_info->rows == 0) || (x < 0) ||\n      (y < 0) || (x >= (ssize_t) cache_info->columns) ||\n      (y >= (ssize_t) cache_info->rows))\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),CacheError,\n        \"PixelsAreNotAuthentic\",\"`%s'\",image->filename);\n      return((Quantum *) NULL);\n    }\n  offset=(MagickOffsetType) y*cache_info->columns+x;\n  if (offset < 0)\n    return((Quantum *) NULL);\n  number_pixels=(MagickSizeType) cache_info->columns*cache_info->rows;\n  offset+=(MagickOffsetType) (rows-1)*cache_info->columns+columns-1;\n  if ((MagickSizeType) offset >= number_pixels)\n    return((Quantum *) NULL);\n  /*\n    Return pixel cache.\n  */\n  region.x=x;\n  region.y=y;\n  region.width=columns;\n  region.height=rows;\n  pixels=SetPixelCacheNexusPixels(cache_info,WriteMode,&region,nexus_info,\n    exception);\n  return(pixels);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   Q u e u e A u t h e n t i c P i x e l s C a c h e                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  QueueAuthenticPixelsCache() allocates an region to store image pixels as\n%  defined by the region rectangle and returns a pointer to the region.  This\n%  region is subsequently transferred from the pixel cache with\n%  SyncAuthenticPixelsCache().  A pointer to the pixels is returned if the\n%  pixels are transferred, otherwise a NULL is returned.\n%\n%  The format of the QueueAuthenticPixelsCache() method is:\n%\n%      Quantum *QueueAuthenticPixelsCache(Image *image,const ssize_t x,\n%        const ssize_t y,const size_t columns,const size_t rows,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o x,y,columns,rows:  These values define the perimeter of a region of\n%      pixels.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Quantum *QueueAuthenticPixelsCache(Image *image,const ssize_t x,\n  const ssize_t y,const size_t columns,const size_t rows,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  Quantum\n    *magick_restrict pixels;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  assert(id < (int) cache_info->number_threads);\n  pixels=QueueAuthenticPixelCacheNexus(image,x,y,columns,rows,MagickFalse,\n    cache_info->nexus_info[id],exception);\n  return(pixels);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   Q u e u e A u t h e n t i c P i x e l s                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  QueueAuthenticPixels() queues a mutable pixel region.  If the region is\n%  successfully initialized a pointer to a Quantum array representing the\n%  region is returned, otherwise NULL is returned.  The returned pointer may\n%  point to a temporary working buffer for the pixels or it may point to the\n%  final location of the pixels in memory.\n%\n%  Write-only access means that any existing pixel values corresponding to\n%  the region are ignored.  This is useful if the initial image is being\n%  created from scratch, or if the existing pixel values are to be\n%  completely replaced without need to refer to their pre-existing values.\n%  The application is free to read and write the pixel buffer returned by\n%  QueueAuthenticPixels() any way it pleases. QueueAuthenticPixels() does not\n%  initialize the pixel array values. Initializing pixel array values is the\n%  application's responsibility.\n%\n%  Performance is maximized if the selected region is part of one row, or\n%  one or more full rows, since then there is opportunity to access the\n%  pixels in-place (without a copy) if the image is in memory, or in a\n%  memory-mapped file. The returned pointer must *never* be deallocated\n%  by the user.\n%\n%  Pixels accessed via the returned pointer represent a simple array of type\n%  Quantum. If the image type is CMYK or the storage class is PseudoClass,\n%  call GetAuthenticMetacontent() after invoking GetAuthenticPixels() to\n%  obtain the meta-content (of type void) corresponding to the region.\n%  Once the Quantum (and/or Quantum) array has been updated, the\n%  changes must be saved back to the underlying image using\n%  SyncAuthenticPixels() or they may be lost.\n%\n%  The format of the QueueAuthenticPixels() method is:\n%\n%      Quantum *QueueAuthenticPixels(Image *image,const ssize_t x,\n%        const ssize_t y,const size_t columns,const size_t rows,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o x,y,columns,rows:  These values define the perimeter of a region of\n%      pixels.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Quantum *QueueAuthenticPixels(Image *image,const ssize_t x,\n  const ssize_t y,const size_t columns,const size_t rows,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  Quantum\n    *magick_restrict pixels;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  if (cache_info->methods.queue_authentic_pixels_handler !=\n      (QueueAuthenticPixelsHandler) NULL)\n    {\n      pixels=cache_info->methods.queue_authentic_pixels_handler(image,x,y,\n        columns,rows,exception);\n      return(pixels);\n    }\n  assert(id < (int) cache_info->number_threads);\n  pixels=QueueAuthenticPixelCacheNexus(image,x,y,columns,rows,MagickFalse,\n    cache_info->nexus_info[id],exception);\n  return(pixels);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   R e a d P i x e l C a c h e M e t a c o n t e n t                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadPixelCacheMetacontent() reads metacontent from the specified region of\n%  the pixel cache.\n%\n%  The format of the ReadPixelCacheMetacontent() method is:\n%\n%      MagickBooleanType ReadPixelCacheMetacontent(CacheInfo *cache_info,\n%        NexusInfo *nexus_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o cache_info: the pixel cache.\n%\n%    o nexus_info: the cache nexus to read the metacontent.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline MagickOffsetType ReadPixelCacheRegion(\n  const CacheInfo *magick_restrict cache_info,const MagickOffsetType offset,\n  const MagickSizeType length,unsigned char *magick_restrict buffer)\n{\n  register MagickOffsetType\n    i;\n\n  ssize_t\n    count;\n\n#if !defined(MAGICKCORE_HAVE_PREAD)\n  if (lseek(cache_info->file,offset,SEEK_SET) < 0)\n    return((MagickOffsetType) -1);\n#endif\n  count=0;\n  for (i=0; i < (MagickOffsetType) length; i+=count)\n  {\n#if !defined(MAGICKCORE_HAVE_PREAD)\n    count=read(cache_info->file,buffer+i,(size_t) MagickMin(length-i,(size_t)\n      SSIZE_MAX));\n#else\n    count=pread(cache_info->file,buffer+i,(size_t) MagickMin(length-i,(size_t)\n      SSIZE_MAX),(off_t) (offset+i));\n#endif\n    if (count <= 0)\n      {\n        count=0;\n        if (errno != EINTR)\n          break;\n      }\n  }\n  return(i);\n}\n\nstatic MagickBooleanType ReadPixelCacheMetacontent(\n  CacheInfo *magick_restrict cache_info,NexusInfo *magick_restrict nexus_info,\n  ExceptionInfo *exception)\n{\n  MagickOffsetType\n    count,\n    offset;\n\n  MagickSizeType\n    extent,\n    length;\n\n  register ssize_t\n    y;\n\n  register unsigned char\n    *magick_restrict q;\n\n  size_t\n    rows;\n\n  if (cache_info->metacontent_extent == 0)\n    return(MagickFalse);\n  if (nexus_info->authentic_pixel_cache != MagickFalse)\n    return(MagickTrue);\n  offset=(MagickOffsetType) nexus_info->region.y*cache_info->columns+\n    nexus_info->region.x;\n  length=(MagickSizeType) nexus_info->region.width*\n    cache_info->metacontent_extent;\n  extent=length*nexus_info->region.height;\n  rows=nexus_info->region.height;\n  y=0;\n  q=(unsigned char *) nexus_info->metacontent;\n  switch (cache_info->type)\n  {\n    case MemoryCache:\n    case MapCache:\n    {\n      register unsigned char\n        *magick_restrict p;\n\n      /*\n        Read meta-content from memory.\n      */\n      if ((cache_info->columns == nexus_info->region.width) &&\n          (extent == (MagickSizeType) ((size_t) extent)))\n        {\n          length=extent;\n          rows=1UL;\n        }\n      p=(unsigned char *) cache_info->metacontent+offset*\n        cache_info->metacontent_extent;\n      for (y=0; y < (ssize_t) rows; y++)\n      {\n        (void) memcpy(q,p,(size_t) length);\n        p+=cache_info->metacontent_extent*cache_info->columns;\n        q+=cache_info->metacontent_extent*nexus_info->region.width;\n      }\n      break;\n    }\n    case DiskCache:\n    {\n      /*\n        Read meta content from disk.\n      */\n      LockSemaphoreInfo(cache_info->file_semaphore);\n      if (OpenPixelCacheOnDisk(cache_info,IOMode) == MagickFalse)\n        {\n          ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",\n            cache_info->cache_filename);\n          UnlockSemaphoreInfo(cache_info->file_semaphore);\n          return(MagickFalse);\n        }\n      if ((cache_info->columns == nexus_info->region.width) &&\n          (extent <= MagickMaxBufferExtent))\n        {\n          length=extent;\n          rows=1UL;\n        }\n      extent=(MagickSizeType) cache_info->columns*cache_info->rows;\n      for (y=0; y < (ssize_t) rows; y++)\n      {\n        count=ReadPixelCacheRegion(cache_info,cache_info->offset+extent*\n          cache_info->number_channels*sizeof(Quantum)+offset*\n          cache_info->metacontent_extent,length,(unsigned char *) q);\n        if (count != (MagickOffsetType) length)\n          break;\n        offset+=cache_info->columns;\n        q+=cache_info->metacontent_extent*nexus_info->region.width;\n      }\n      if (IsFileDescriptorLimitExceeded() != MagickFalse)\n        (void) ClosePixelCacheOnDisk(cache_info);\n      UnlockSemaphoreInfo(cache_info->file_semaphore);\n      break;\n    }\n    case DistributedCache:\n    {\n      RectangleInfo\n        region;\n\n      /*\n        Read metacontent from distributed cache.\n      */\n      LockSemaphoreInfo(cache_info->file_semaphore);\n      region=nexus_info->region;\n      if ((cache_info->columns != nexus_info->region.width) ||\n          (extent > MagickMaxBufferExtent))\n        region.height=1UL;\n      else\n        {\n          length=extent;\n          rows=1UL;\n        }\n      for (y=0; y < (ssize_t) rows; y++)\n      {\n        count=ReadDistributePixelCacheMetacontent((DistributeCacheInfo *)\n          cache_info->server_info,&region,length,(unsigned char *) q);\n        if (count != (MagickOffsetType) length)\n          break;\n        q+=cache_info->metacontent_extent*nexus_info->region.width;\n        region.y++;\n      }\n      UnlockSemaphoreInfo(cache_info->file_semaphore);\n      break;\n    }\n    default:\n      break;\n  }\n  if (y < (ssize_t) rows)\n    {\n      ThrowFileException(exception,CacheError,\"UnableToReadPixelCache\",\n        cache_info->cache_filename);\n      return(MagickFalse);\n    }\n  if ((cache_info->debug != MagickFalse) &&\n      (CacheTick(nexus_info->region.y,cache_info->rows) != MagickFalse))\n    (void) LogMagickEvent(CacheEvent,GetMagickModule(),\n      \"%s[%.20gx%.20g%+.20g%+.20g]\",cache_info->filename,(double)\n      nexus_info->region.width,(double) nexus_info->region.height,(double)\n      nexus_info->region.x,(double) nexus_info->region.y);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   R e a d P i x e l C a c h e P i x e l s                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadPixelCachePixels() reads pixels from the specified region of the pixel\n%  cache.\n%\n%  The format of the ReadPixelCachePixels() method is:\n%\n%      MagickBooleanType ReadPixelCachePixels(CacheInfo *cache_info,\n%        NexusInfo *nexus_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o cache_info: the pixel cache.\n%\n%    o nexus_info: the cache nexus to read the pixels.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType ReadPixelCachePixels(\n  CacheInfo *magick_restrict cache_info,NexusInfo *magick_restrict nexus_info,\n  ExceptionInfo *exception)\n{\n  MagickOffsetType\n    count,\n    offset;\n\n  MagickSizeType\n    extent,\n    length;\n\n  register Quantum\n    *magick_restrict q;\n\n  register ssize_t\n    y;\n\n  size_t\n    number_channels,\n    rows;\n\n  if (nexus_info->authentic_pixel_cache != MagickFalse)\n    return(MagickTrue);\n  offset=(MagickOffsetType) nexus_info->region.y*cache_info->columns;\n  if ((ssize_t) (offset/cache_info->columns) != nexus_info->region.y)\n    return(MagickFalse);\n  offset+=nexus_info->region.x;\n  number_channels=cache_info->number_channels;\n  length=(MagickSizeType) number_channels*nexus_info->region.width*\n    sizeof(Quantum);\n  if ((length/number_channels/sizeof(Quantum)) != nexus_info->region.width)\n    return(MagickFalse);\n  rows=nexus_info->region.height;\n  extent=length*rows;\n  if ((extent == 0) || ((extent/length) != rows))\n    return(MagickFalse);\n  y=0;\n  q=nexus_info->pixels;\n  switch (cache_info->type)\n  {\n    case MemoryCache:\n    case MapCache:\n    {\n      register Quantum\n        *magick_restrict p;\n\n      /*\n        Read pixels from memory.\n      */\n      if ((cache_info->columns == nexus_info->region.width) &&\n          (extent == (MagickSizeType) ((size_t) extent)))\n        {\n          length=extent;\n          rows=1UL;\n        }\n      p=cache_info->pixels+offset*cache_info->number_channels;\n      for (y=0; y < (ssize_t) rows; y++)\n      {\n        (void) memcpy(q,p,(size_t) length);\n        p+=cache_info->number_channels*cache_info->columns;\n        q+=cache_info->number_channels*nexus_info->region.width;\n      }\n      break;\n    }\n    case DiskCache:\n    {\n      /*\n        Read pixels from disk.\n      */\n      LockSemaphoreInfo(cache_info->file_semaphore);\n      if (OpenPixelCacheOnDisk(cache_info,IOMode) == MagickFalse)\n        {\n          ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",\n            cache_info->cache_filename);\n          UnlockSemaphoreInfo(cache_info->file_semaphore);\n          return(MagickFalse);\n        }\n      if ((cache_info->columns == nexus_info->region.width) &&\n          (extent <= MagickMaxBufferExtent))\n        {\n          length=extent;\n          rows=1UL;\n        }\n      for (y=0; y < (ssize_t) rows; y++)\n      {\n        count=ReadPixelCacheRegion(cache_info,cache_info->offset+offset*\n          cache_info->number_channels*sizeof(*q),length,(unsigned char *) q);\n        if (count != (MagickOffsetType) length)\n          break;\n        offset+=cache_info->columns;\n        q+=cache_info->number_channels*nexus_info->region.width;\n      }\n      if (IsFileDescriptorLimitExceeded() != MagickFalse)\n        (void) ClosePixelCacheOnDisk(cache_info);\n      UnlockSemaphoreInfo(cache_info->file_semaphore);\n      break;\n    }\n    case DistributedCache:\n    {\n      RectangleInfo\n        region;\n\n      /*\n        Read pixels from distributed cache.\n      */\n      LockSemaphoreInfo(cache_info->file_semaphore);\n      region=nexus_info->region;\n      if ((cache_info->columns != nexus_info->region.width) ||\n          (extent > MagickMaxBufferExtent))\n        region.height=1UL;\n      else\n        {\n          length=extent;\n          rows=1UL;\n        }\n      for (y=0; y < (ssize_t) rows; y++)\n      {\n        count=ReadDistributePixelCachePixels((DistributeCacheInfo *)\n          cache_info->server_info,&region,length,(unsigned char *) q);\n        if (count != (MagickOffsetType) length)\n          break;\n        q+=cache_info->number_channels*nexus_info->region.width;\n        region.y++;\n      }\n      UnlockSemaphoreInfo(cache_info->file_semaphore);\n      break;\n    }\n    default:\n      break;\n  }\n  if (y < (ssize_t) rows)\n    {\n      ThrowFileException(exception,CacheError,\"UnableToReadPixelCache\",\n        cache_info->cache_filename);\n      return(MagickFalse);\n    }\n  if ((cache_info->debug != MagickFalse) &&\n      (CacheTick(nexus_info->region.y,cache_info->rows) != MagickFalse))\n    (void) LogMagickEvent(CacheEvent,GetMagickModule(),\n      \"%s[%.20gx%.20g%+.20g%+.20g]\",cache_info->filename,(double)\n      nexus_info->region.width,(double) nexus_info->region.height,(double)\n      nexus_info->region.x,(double) nexus_info->region.y);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   R e f e r e n c e P i x e l C a c h e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReferencePixelCache() increments the reference count associated with the\n%  pixel cache returning a pointer to the cache.\n%\n%  The format of the ReferencePixelCache method is:\n%\n%      Cache ReferencePixelCache(Cache cache_info)\n%\n%  A description of each parameter follows:\n%\n%    o cache_info: the pixel cache.\n%\n*/\nMagickPrivate Cache ReferencePixelCache(Cache cache)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  assert(cache != (Cache *) NULL);\n  cache_info=(CacheInfo *) cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  LockSemaphoreInfo(cache_info->semaphore);\n  cache_info->reference_count++;\n  UnlockSemaphoreInfo(cache_info->semaphore);\n  return(cache_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   R e s e t P i x e l C a c h e E p o c h e                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ResetPixelCacheEpoch() resets the pixel cache epoch.\n%\n%  The format of the ResetPixelCacheEpoch method is:\n%\n%      void ResetPixelCacheEpoch(void)\n%\n*/\nMagickPrivate void ResetPixelCacheEpoch(void)\n{\n  cache_epoch=0;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   S e t P i x e l C a c h e M e t h o d s                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetPixelCacheMethods() sets the image pixel methods to the specified ones.\n%\n%  The format of the SetPixelCacheMethods() method is:\n%\n%      SetPixelCacheMethods(Cache *,CacheMethods *cache_methods)\n%\n%  A description of each parameter follows:\n%\n%    o cache: the pixel cache.\n%\n%    o cache_methods: Specifies a pointer to a CacheMethods structure.\n%\n*/\nMagickPrivate void SetPixelCacheMethods(Cache cache,CacheMethods *cache_methods)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  GetOneAuthenticPixelFromHandler\n    get_one_authentic_pixel_from_handler;\n\n  GetOneVirtualPixelFromHandler\n    get_one_virtual_pixel_from_handler;\n\n  /*\n    Set cache pixel methods.\n  */\n  assert(cache != (Cache) NULL);\n  assert(cache_methods != (CacheMethods *) NULL);\n  cache_info=(CacheInfo *) cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  if (cache_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      cache_info->filename);\n  if (cache_methods->get_virtual_pixel_handler != (GetVirtualPixelHandler) NULL)\n    cache_info->methods.get_virtual_pixel_handler=\n      cache_methods->get_virtual_pixel_handler;\n  if (cache_methods->destroy_pixel_handler != (DestroyPixelHandler) NULL)\n    cache_info->methods.destroy_pixel_handler=\n      cache_methods->destroy_pixel_handler;\n  if (cache_methods->get_virtual_metacontent_from_handler !=\n      (GetVirtualMetacontentFromHandler) NULL)\n    cache_info->methods.get_virtual_metacontent_from_handler=\n      cache_methods->get_virtual_metacontent_from_handler;\n  if (cache_methods->get_authentic_pixels_handler !=\n      (GetAuthenticPixelsHandler) NULL)\n    cache_info->methods.get_authentic_pixels_handler=\n      cache_methods->get_authentic_pixels_handler;\n  if (cache_methods->queue_authentic_pixels_handler !=\n      (QueueAuthenticPixelsHandler) NULL)\n    cache_info->methods.queue_authentic_pixels_handler=\n      cache_methods->queue_authentic_pixels_handler;\n  if (cache_methods->sync_authentic_pixels_handler !=\n      (SyncAuthenticPixelsHandler) NULL)\n    cache_info->methods.sync_authentic_pixels_handler=\n      cache_methods->sync_authentic_pixels_handler;\n  if (cache_methods->get_authentic_pixels_from_handler !=\n      (GetAuthenticPixelsFromHandler) NULL)\n    cache_info->methods.get_authentic_pixels_from_handler=\n      cache_methods->get_authentic_pixels_from_handler;\n  if (cache_methods->get_authentic_metacontent_from_handler !=\n      (GetAuthenticMetacontentFromHandler) NULL)\n    cache_info->methods.get_authentic_metacontent_from_handler=\n      cache_methods->get_authentic_metacontent_from_handler;\n  get_one_virtual_pixel_from_handler=\n    cache_info->methods.get_one_virtual_pixel_from_handler;\n  if (get_one_virtual_pixel_from_handler !=\n      (GetOneVirtualPixelFromHandler) NULL)\n    cache_info->methods.get_one_virtual_pixel_from_handler=\n      cache_methods->get_one_virtual_pixel_from_handler;\n  get_one_authentic_pixel_from_handler=\n    cache_methods->get_one_authentic_pixel_from_handler;\n  if (get_one_authentic_pixel_from_handler !=\n      (GetOneAuthenticPixelFromHandler) NULL)\n    cache_info->methods.get_one_authentic_pixel_from_handler=\n      cache_methods->get_one_authentic_pixel_from_handler;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   S e t P i x e l C a c h e N e x u s P i x e l s                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetPixelCacheNexusPixels() defines the region of the cache for the\n%  specified cache nexus.\n%\n%  The format of the SetPixelCacheNexusPixels() method is:\n%\n%      Quantum SetPixelCacheNexusPixels(const CacheInfo *cache_info,\n%        const MapMode mode,const RectangleInfo *region,NexusInfo *nexus_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o cache_info: the pixel cache.\n%\n%    o mode: ReadMode, WriteMode, or IOMode.\n%\n%    o region: A pointer to the RectangleInfo structure that defines the\n%      region of this particular cache nexus.\n%\n%    o nexus_info: the cache nexus to set.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline MagickBooleanType AcquireCacheNexusPixels(\n  const CacheInfo *magick_restrict cache_info,NexusInfo *nexus_info,\n  ExceptionInfo *exception)\n{\n  if (nexus_info->length != (MagickSizeType) ((size_t) nexus_info->length))\n    return(MagickFalse);\n  nexus_info->mapped=MagickFalse;\n  nexus_info->cache=(Quantum *) MagickAssumeAligned(AcquireAlignedMemory(1,\n    (size_t) nexus_info->length));\n  if (nexus_info->cache == (Quantum *) NULL)\n    {\n      nexus_info->mapped=MagickTrue;\n      nexus_info->cache=(Quantum *) MapBlob(-1,IOMode,0,(size_t)\n        nexus_info->length);\n    }\n  if (nexus_info->cache == (Quantum *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\n        cache_info->filename);\n      return(MagickFalse);\n    }\n  return(MagickTrue);\n}\n\nstatic inline MagickBooleanType IsPixelCacheAuthentic(\n  const CacheInfo *magick_restrict cache_info,\n  const NexusInfo *magick_restrict nexus_info)\n{\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  /*\n    Does nexus pixels point directly to in-core cache pixels or is it buffered?\n  */\n  if (cache_info->type == PingCache)\n    return(MagickTrue);\n  offset=(MagickOffsetType) nexus_info->region.y*cache_info->columns+\n    nexus_info->region.x;\n  status=nexus_info->pixels == (cache_info->pixels+offset*\n    cache_info->number_channels) ? MagickTrue : MagickFalse;\n  return(status);\n}\n\nstatic inline void PrefetchPixelCacheNexusPixels(const NexusInfo *nexus_info,\n  const MapMode mode)\n{\n  if (mode == ReadMode)\n    {\n      MagickCachePrefetch((unsigned char *) nexus_info->pixels,0,1);\n      return;\n    }\n  MagickCachePrefetch((unsigned char *) nexus_info->pixels,1,1);\n}\n\nstatic Quantum *SetPixelCacheNexusPixels(const CacheInfo *cache_info,\n  const MapMode mode,const RectangleInfo *region,NexusInfo *nexus_info,\n  ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    length,\n    number_pixels;\n\n  assert(cache_info != (const CacheInfo *) NULL);\n  assert(cache_info->signature == MagickCoreSignature);\n  if (cache_info->type == UndefinedCache)\n    return((Quantum *) NULL);\n  nexus_info->region=(*region);\n  if ((cache_info->type == MemoryCache) || (cache_info->type == MapCache))\n    {\n      ssize_t\n        x,\n        y;\n\n      x=nexus_info->region.x+(ssize_t) nexus_info->region.width-1;\n      y=nexus_info->region.y+(ssize_t) nexus_info->region.height-1;\n      if (((nexus_info->region.x >= 0) && (x < (ssize_t) cache_info->columns) &&\n           (nexus_info->region.y >= 0) && (y < (ssize_t) cache_info->rows)) &&\n          ((nexus_info->region.height == 1UL) || ((nexus_info->region.x == 0) &&\n           ((nexus_info->region.width == cache_info->columns) ||\n            ((nexus_info->region.width % cache_info->columns) == 0)))))\n        {\n          MagickOffsetType\n            offset;\n\n          /*\n            Pixels are accessed directly from memory.\n          */\n          offset=(MagickOffsetType) nexus_info->region.y*cache_info->columns+\n            nexus_info->region.x;\n          nexus_info->pixels=cache_info->pixels+cache_info->number_channels*\n            offset;\n          nexus_info->metacontent=(void *) NULL;\n          if (cache_info->metacontent_extent != 0)\n            nexus_info->metacontent=(unsigned char *) cache_info->metacontent+\n              offset*cache_info->metacontent_extent;\n          PrefetchPixelCacheNexusPixels(nexus_info,mode);\n          nexus_info->authentic_pixel_cache=IsPixelCacheAuthentic(cache_info,\n            nexus_info);\n          return(nexus_info->pixels);\n        }\n    }\n  /*\n    Pixels are stored in a staging region until they are synced to the cache.\n  */\n  number_pixels=(MagickSizeType) nexus_info->region.width*\n    nexus_info->region.height;\n  length=number_pixels*cache_info->number_channels*sizeof(Quantum);\n  if (cache_info->metacontent_extent != 0)\n    length+=number_pixels*cache_info->metacontent_extent;\n  if (nexus_info->cache == (Quantum *) NULL)\n    {\n      nexus_info->length=length;\n      status=AcquireCacheNexusPixels(cache_info,nexus_info,exception);\n      if (status == MagickFalse)\n        {\n          nexus_info->length=0;\n          return((Quantum *) NULL);\n        }\n    }\n  else\n    if (nexus_info->length < length)\n      {\n        RelinquishCacheNexusPixels(nexus_info);\n        nexus_info->length=length;\n        status=AcquireCacheNexusPixels(cache_info,nexus_info,exception);\n        if (status == MagickFalse)\n          {\n            nexus_info->length=0;\n            return((Quantum *) NULL);\n          }\n      }\n  nexus_info->pixels=nexus_info->cache;\n  nexus_info->metacontent=(void *) NULL;\n  if (cache_info->metacontent_extent != 0)\n    nexus_info->metacontent=(void *) (nexus_info->pixels+number_pixels*\n      cache_info->number_channels);\n  PrefetchPixelCacheNexusPixels(nexus_info,mode);\n  nexus_info->authentic_pixel_cache=IsPixelCacheAuthentic(cache_info,\n    nexus_info);\n  return(nexus_info->pixels);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t P i x e l C a c h e V i r t u a l M e t h o d                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetPixelCacheVirtualMethod() sets the \"virtual pixels\" method for the\n%  pixel cache and returns the previous setting.  A virtual pixel is any pixel\n%  access that is outside the boundaries of the image cache.\n%\n%  The format of the SetPixelCacheVirtualMethod() method is:\n%\n%      VirtualPixelMethod SetPixelCacheVirtualMethod(Image *image,\n%        const VirtualPixelMethod virtual_pixel_method,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o virtual_pixel_method: choose the type of virtual pixel.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic MagickBooleanType SetCacheAlphaChannel(Image *image,const Quantum alpha,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  CacheView\n    *magick_restrict image_view;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  image->alpha_trait=BlendPixelTrait;\n  status=MagickTrue;\n  image_view=AcquireVirtualCacheView(image,exception);  /* must be virtual */\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(status) \\\n    magick_threads(image,image,1,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      SetPixelAlpha(image,alpha,q);\n      q+=GetPixelChannels(image);\n    }\n    status=SyncCacheViewAuthenticPixels(image_view,exception);\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\nMagickPrivate VirtualPixelMethod SetPixelCacheVirtualMethod(Image *image,\n  const VirtualPixelMethod virtual_pixel_method,ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  VirtualPixelMethod\n    method;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  method=cache_info->virtual_pixel_method;\n  cache_info->virtual_pixel_method=virtual_pixel_method;\n  if ((image->columns != 0) && (image->rows != 0))\n    switch (virtual_pixel_method)\n    {\n      case BackgroundVirtualPixelMethod:\n      {\n        if ((image->background_color.alpha_trait != UndefinedPixelTrait) &&\n            (image->alpha_trait == UndefinedPixelTrait))\n          (void) SetCacheAlphaChannel(image,OpaqueAlpha,exception);\n        if ((IsPixelInfoGray(&image->background_color) == MagickFalse) &&\n            (IsGrayColorspace(image->colorspace) != MagickFalse))\n          (void) SetImageColorspace(image,sRGBColorspace,exception);\n        break;\n      }\n      case TransparentVirtualPixelMethod:\n      {\n        if (image->alpha_trait == UndefinedPixelTrait)\n          (void) SetCacheAlphaChannel(image,OpaqueAlpha,exception);\n        break;\n      }\n      default:\n        break;\n    }\n  return(method);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   S y n c A u t h e n t i c P i x e l C a c h e N e x u s                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SyncAuthenticPixelCacheNexus() saves the authentic image pixels to the\n%  in-memory or disk cache.  The method returns MagickTrue if the pixel region\n%  is synced, otherwise MagickFalse.\n%\n%  The format of the SyncAuthenticPixelCacheNexus() method is:\n%\n%      MagickBooleanType SyncAuthenticPixelCacheNexus(Image *image,\n%        NexusInfo *nexus_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o nexus_info: the cache nexus to sync.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickPrivate MagickBooleanType SyncAuthenticPixelCacheNexus(Image *image,\n  NexusInfo *magick_restrict nexus_info,ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  MagickBooleanType\n    status;\n\n  /*\n    Transfer pixels to the cache.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->cache == (Cache) NULL)\n    ThrowBinaryException(CacheError,\"PixelCacheIsNotOpen\",image->filename);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  if (cache_info->type == UndefinedCache)\n    return(MagickFalse);\n  if (nexus_info->authentic_pixel_cache != MagickFalse)\n    {\n      image->taint=MagickTrue;\n      return(MagickTrue);\n    }\n  assert(cache_info->signature == MagickCoreSignature);\n  status=WritePixelCachePixels(cache_info,nexus_info,exception);\n  if ((cache_info->metacontent_extent != 0) &&\n      (WritePixelCacheMetacontent(cache_info,nexus_info,exception) == MagickFalse))\n    return(MagickFalse);\n  if (status != MagickFalse)\n    image->taint=MagickTrue;\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   S y n c A u t h e n t i c P i x e l C a c h e                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SyncAuthenticPixelsCache() saves the authentic image pixels to the in-memory\n%  or disk cache.  The method returns MagickTrue if the pixel region is synced,\n%  otherwise MagickFalse.\n%\n%  The format of the SyncAuthenticPixelsCache() method is:\n%\n%      MagickBooleanType SyncAuthenticPixelsCache(Image *image,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType SyncAuthenticPixelsCache(Image *image,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  MagickBooleanType\n    status;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  assert(id < (int) cache_info->number_threads);\n  status=SyncAuthenticPixelCacheNexus(image,cache_info->nexus_info[id],\n    exception);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S y n c A u t h e n t i c P i x e l s                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SyncAuthenticPixels() saves the image pixels to the in-memory or disk cache.\n%  The method returns MagickTrue if the pixel region is flushed, otherwise\n%  MagickFalse.\n%\n%  The format of the SyncAuthenticPixels() method is:\n%\n%      MagickBooleanType SyncAuthenticPixels(Image *image,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType SyncAuthenticPixels(Image *image,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  MagickBooleanType\n    status;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  if (cache_info->methods.sync_authentic_pixels_handler !=\n       (SyncAuthenticPixelsHandler) NULL)\n    {\n      status=cache_info->methods.sync_authentic_pixels_handler(image,\n        exception);\n      return(status);\n    }\n  assert(id < (int) cache_info->number_threads);\n  status=SyncAuthenticPixelCacheNexus(image,cache_info->nexus_info[id],\n    exception);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   S y n c I m a g e P i x e l C a c h e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SyncImagePixelCache() saves the image pixels to the in-memory or disk cache.\n%  The method returns MagickTrue if the pixel region is flushed, otherwise\n%  MagickFalse.\n%\n%  The format of the SyncImagePixelCache() method is:\n%\n%      MagickBooleanType SyncImagePixelCache(Image *image,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickPrivate MagickBooleanType SyncImagePixelCache(Image *image,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  assert(image != (Image *) NULL);\n  assert(exception != (ExceptionInfo *) NULL);\n  cache_info=(CacheInfo *) GetImagePixelCache(image,MagickTrue,exception);\n  return(cache_info == (CacheInfo *) NULL ? MagickFalse : MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   W r i t e P i x e l C a c h e M e t a c o n t e n t                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WritePixelCacheMetacontent() writes the meta-content to the specified region\n%  of the pixel cache.\n%\n%  The format of the WritePixelCacheMetacontent() method is:\n%\n%      MagickBooleanType WritePixelCacheMetacontent(CacheInfo *cache_info,\n%        NexusInfo *nexus_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o cache_info: the pixel cache.\n%\n%    o nexus_info: the cache nexus to write the meta-content.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WritePixelCacheMetacontent(CacheInfo *cache_info,\n  NexusInfo *magick_restrict nexus_info,ExceptionInfo *exception)\n{\n  MagickOffsetType\n    count,\n    offset;\n\n  MagickSizeType\n    extent,\n    length;\n\n  register const unsigned char\n    *magick_restrict p;\n\n  register ssize_t\n    y;\n\n  size_t\n    rows;\n\n  if (cache_info->metacontent_extent == 0)\n    return(MagickFalse);\n  if (nexus_info->authentic_pixel_cache != MagickFalse)\n    return(MagickTrue);\n  offset=(MagickOffsetType) nexus_info->region.y*cache_info->columns+\n    nexus_info->region.x;\n  length=(MagickSizeType) nexus_info->region.width*\n    cache_info->metacontent_extent;\n  extent=(MagickSizeType) length*nexus_info->region.height;\n  rows=nexus_info->region.height;\n  y=0;\n  p=(unsigned char *) nexus_info->metacontent;\n  switch (cache_info->type)\n  {\n    case MemoryCache:\n    case MapCache:\n    {\n      register unsigned char\n        *magick_restrict q;\n\n      /*\n        Write associated pixels to memory.\n      */\n      if ((cache_info->columns == nexus_info->region.width) &&\n          (extent == (MagickSizeType) ((size_t) extent)))\n        {\n          length=extent;\n          rows=1UL;\n        }\n      q=(unsigned char *) cache_info->metacontent+offset*\n        cache_info->metacontent_extent;\n      for (y=0; y < (ssize_t) rows; y++)\n      {\n        (void) memcpy(q,p,(size_t) length);\n        p+=nexus_info->region.width*cache_info->metacontent_extent;\n        q+=cache_info->columns*cache_info->metacontent_extent;\n      }\n      break;\n    }\n    case DiskCache:\n    {\n      /*\n        Write associated pixels to disk.\n      */\n      LockSemaphoreInfo(cache_info->file_semaphore);\n      if (OpenPixelCacheOnDisk(cache_info,IOMode) == MagickFalse)\n        {\n          ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",\n            cache_info->cache_filename);\n          UnlockSemaphoreInfo(cache_info->file_semaphore);\n          return(MagickFalse);\n        }\n      if ((cache_info->columns == nexus_info->region.width) &&\n          (extent <= MagickMaxBufferExtent))\n        {\n          length=extent;\n          rows=1UL;\n        }\n      extent=(MagickSizeType) cache_info->columns*cache_info->rows;\n      for (y=0; y < (ssize_t) rows; y++)\n      {\n        count=WritePixelCacheRegion(cache_info,cache_info->offset+extent*\n          cache_info->number_channels*sizeof(Quantum)+offset*\n          cache_info->metacontent_extent,length,(const unsigned char *) p);\n        if (count != (MagickOffsetType) length)\n          break;\n        p+=cache_info->metacontent_extent*nexus_info->region.width;\n        offset+=cache_info->columns;\n      }\n      if (IsFileDescriptorLimitExceeded() != MagickFalse)\n        (void) ClosePixelCacheOnDisk(cache_info);\n      UnlockSemaphoreInfo(cache_info->file_semaphore);\n      break;\n    }\n    case DistributedCache:\n    {\n      RectangleInfo\n        region;\n\n      /*\n        Write metacontent to distributed cache.\n      */\n      LockSemaphoreInfo(cache_info->file_semaphore);\n      region=nexus_info->region;\n      if ((cache_info->columns != nexus_info->region.width) ||\n          (extent > MagickMaxBufferExtent))\n        region.height=1UL;\n      else\n        {\n          length=extent;\n          rows=1UL;\n        }\n      for (y=0; y < (ssize_t) rows; y++)\n      {\n        count=WriteDistributePixelCacheMetacontent((DistributeCacheInfo *)\n          cache_info->server_info,&region,length,(const unsigned char *) p);\n        if (count != (MagickOffsetType) length)\n          break;\n        p+=cache_info->metacontent_extent*nexus_info->region.width;\n        region.y++;\n      }\n      UnlockSemaphoreInfo(cache_info->file_semaphore);\n      break;\n    }\n    default:\n      break;\n  }\n  if (y < (ssize_t) rows)\n    {\n      ThrowFileException(exception,CacheError,\"UnableToWritePixelCache\",\n        cache_info->cache_filename);\n      return(MagickFalse);\n    }\n  if ((cache_info->debug != MagickFalse) &&\n      (CacheTick(nexus_info->region.y,cache_info->rows) != MagickFalse))\n    (void) LogMagickEvent(CacheEvent,GetMagickModule(),\n      \"%s[%.20gx%.20g%+.20g%+.20g]\",cache_info->filename,(double)\n      nexus_info->region.width,(double) nexus_info->region.height,(double)\n      nexus_info->region.x,(double) nexus_info->region.y);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   W r i t e C a c h e P i x e l s                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WritePixelCachePixels() writes image pixels to the specified region of the\n%  pixel cache.\n%\n%  The format of the WritePixelCachePixels() method is:\n%\n%      MagickBooleanType WritePixelCachePixels(CacheInfo *cache_info,\n%        NexusInfo *nexus_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o cache_info: the pixel cache.\n%\n%    o nexus_info: the cache nexus to write the pixels.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WritePixelCachePixels(\n  CacheInfo *magick_restrict cache_info,NexusInfo *magick_restrict nexus_info,\n  ExceptionInfo *exception)\n{\n  MagickOffsetType\n    count,\n    offset;\n\n  MagickSizeType\n    extent,\n    length;\n\n  register const Quantum\n    *magick_restrict p;\n\n  register ssize_t\n    y;\n\n  size_t\n    rows;\n\n  if (nexus_info->authentic_pixel_cache != MagickFalse)\n    return(MagickTrue);\n  offset=(MagickOffsetType) nexus_info->region.y*cache_info->columns+\n    nexus_info->region.x;\n  length=(MagickSizeType) cache_info->number_channels*nexus_info->region.width*\n    sizeof(Quantum);\n  extent=length*nexus_info->region.height;\n  rows=nexus_info->region.height;\n  y=0;\n  p=nexus_info->pixels;\n  switch (cache_info->type)\n  {\n    case MemoryCache:\n    case MapCache:\n    {\n      register Quantum\n        *magick_restrict q;\n\n      /*\n        Write pixels to memory.\n      */\n      if ((cache_info->columns == nexus_info->region.width) &&\n          (extent == (MagickSizeType) ((size_t) extent)))\n        {\n          length=extent;\n          rows=1UL;\n        }\n      q=cache_info->pixels+offset*cache_info->number_channels;\n      for (y=0; y < (ssize_t) rows; y++)\n      {\n        (void) memcpy(q,p,(size_t) length);\n        p+=cache_info->number_channels*nexus_info->region.width;\n        q+=cache_info->columns*cache_info->number_channels;\n      }\n      break;\n    }\n    case DiskCache:\n    {\n      /*\n        Write pixels to disk.\n      */\n      LockSemaphoreInfo(cache_info->file_semaphore);\n      if (OpenPixelCacheOnDisk(cache_info,IOMode) == MagickFalse)\n        {\n          ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",\n            cache_info->cache_filename);\n          UnlockSemaphoreInfo(cache_info->file_semaphore);\n          return(MagickFalse);\n        }\n      if ((cache_info->columns == nexus_info->region.width) &&\n          (extent <= MagickMaxBufferExtent))\n        {\n          length=extent;\n          rows=1UL;\n        }\n      for (y=0; y < (ssize_t) rows; y++)\n      {\n        count=WritePixelCacheRegion(cache_info,cache_info->offset+offset*\n          cache_info->number_channels*sizeof(*p),length,(const unsigned char *)\n          p);\n        if (count != (MagickOffsetType) length)\n          break;\n        p+=cache_info->number_channels*nexus_info->region.width;\n        offset+=cache_info->columns;\n      }\n      if (IsFileDescriptorLimitExceeded() != MagickFalse)\n        (void) ClosePixelCacheOnDisk(cache_info);\n      UnlockSemaphoreInfo(cache_info->file_semaphore);\n      break;\n    }\n    case DistributedCache:\n    {\n      RectangleInfo\n        region;\n\n      /*\n        Write pixels to distributed cache.\n      */\n      LockSemaphoreInfo(cache_info->file_semaphore);\n      region=nexus_info->region;\n      if ((cache_info->columns != nexus_info->region.width) ||\n          (extent > MagickMaxBufferExtent))\n        region.height=1UL;\n      else\n        {\n          length=extent;\n          rows=1UL;\n        }\n      for (y=0; y < (ssize_t) rows; y++)\n      {\n        count=WriteDistributePixelCachePixels((DistributeCacheInfo *)\n          cache_info->server_info,&region,length,(const unsigned char *) p);\n        if (count != (MagickOffsetType) length)\n          break;\n        p+=cache_info->number_channels*nexus_info->region.width;\n        region.y++;\n      }\n      UnlockSemaphoreInfo(cache_info->file_semaphore);\n      break;\n    }\n    default:\n      break;\n  }\n  if (y < (ssize_t) rows)\n    {\n      ThrowFileException(exception,CacheError,\"UnableToWritePixelCache\",\n        cache_info->cache_filename);\n      return(MagickFalse);\n    }\n  if ((cache_info->debug != MagickFalse) &&\n      (CacheTick(nexus_info->region.y,cache_info->rows) != MagickFalse))\n    (void) LogMagickEvent(CacheEvent,GetMagickModule(),\n      \"%s[%.20gx%.20g%+.20g%+.20g]\",cache_info->filename,(double)\n      nexus_info->region.width,(double) nexus_info->region.height,(double)\n      nexus_info->region.x,(double) nexus_info->region.y);\n  return(MagickTrue);\n}\n", "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                     IIIII  M   M   AAA    GGGG  EEEEE                       %\n%                       I    MM MM  A   A  G      E                           %\n%                       I    M M M  AAAAA  G  GG  EEE                         %\n%                       I    M   M  A   A  G   G  E                           %\n%                     IIIII  M   M  A   A   GGGG  EEEEE                       %\n%                                                                             %\n%                                                                             %\n%                           MagickCore Image Methods                          %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/animate.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/cache-private.h\"\n#include \"MagickCore/cache-view.h\"\n#include \"MagickCore/client.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/composite.h\"\n#include \"MagickCore/composite-private.h\"\n#include \"MagickCore/compress.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/display.h\"\n#include \"MagickCore/draw.h\"\n#include \"MagickCore/enhance.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/gem.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/histogram.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magic.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/magick-private.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/paint.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantize.h\"\n#include \"MagickCore/random_.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/segment.h\"\n#include \"MagickCore/semaphore.h\"\n#include \"MagickCore/signature-private.h\"\n#include \"MagickCore/statistic.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/thread-private.h\"\n#include \"MagickCore/threshold.h\"\n#include \"MagickCore/timer.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/utility.h\"\n#include \"MagickCore/utility-private.h\"\n#include \"MagickCore/version.h\"\n#include \"MagickCore/xwindow-private.h\"\n\f\n/*\n  Constant declaration.\n*/\nconst char\n  AlphaColor[] = \"#bdbdbd\",  /* gray */\n  BackgroundColor[] = \"#ffffff\",  /* white */\n  BorderColor[] = \"#dfdfdf\",  /* gray */\n  DefaultTileFrame[] = \"15x15+3+3\",\n  DefaultTileGeometry[] = \"120x120+4+3>\",\n  DefaultTileLabel[] = \"%f\\n%G\\n%b\",\n  ForegroundColor[] = \"#000\",  /* black */\n  LoadImageTag[] = \"Load/Image\",\n  LoadImagesTag[] = \"Load/Images\",\n  PSDensityGeometry[] = \"72.0x72.0\",\n  PSPageGeometry[] = \"612x792\",\n  SaveImageTag[] = \"Save/Image\",\n  SaveImagesTag[] = \"Save/Images\",\n  TransparentColor[] = \"#00000000\";  /* transparent black */\n\nconst double\n  DefaultResolution = 72.0;\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   A c q u i r e I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquireImage() returns a pointer to an image structure initialized to\n%  default values.\n%\n%  The format of the AcquireImage method is:\n%\n%      Image *AcquireImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: Many of the image default values are set from this\n%      structure.  For example, filename, compression, depth, background color,\n%      and others.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *AcquireImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  const char\n    *option;\n\n  Image\n    *image;\n\n  MagickStatusType\n    flags;\n\n  /*\n    Allocate image structure.\n  */\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  image=(Image *) AcquireMagickMemory(sizeof(*image));\n  if (image == (Image *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(image,0,sizeof(*image));\n  /*\n    Initialize Image structure.\n  */\n  (void) CopyMagickString(image->magick,\"MIFF\",MagickPathExtent);\n  image->storage_class=DirectClass;\n  image->depth=MAGICKCORE_QUANTUM_DEPTH;\n  image->colorspace=sRGBColorspace;\n  image->rendering_intent=PerceptualIntent;\n  image->gamma=1.000f/2.200f;\n  image->chromaticity.red_primary.x=0.6400f;\n  image->chromaticity.red_primary.y=0.3300f;\n  image->chromaticity.red_primary.z=0.0300f;\n  image->chromaticity.green_primary.x=0.3000f;\n  image->chromaticity.green_primary.y=0.6000f;\n  image->chromaticity.green_primary.z=0.1000f;\n  image->chromaticity.blue_primary.x=0.1500f;\n  image->chromaticity.blue_primary.y=0.0600f;\n  image->chromaticity.blue_primary.z=0.7900f;\n  image->chromaticity.white_point.x=0.3127f;\n  image->chromaticity.white_point.y=0.3290f;\n  image->chromaticity.white_point.z=0.3583f;\n  image->interlace=NoInterlace;\n  image->ticks_per_second=UndefinedTicksPerSecond;\n  image->compose=OverCompositeOp;\n  (void) QueryColorCompliance(AlphaColor,AllCompliance,&image->alpha_color,\n    exception);\n  (void) QueryColorCompliance(BackgroundColor,AllCompliance,\n    &image->background_color,exception);\n  (void) QueryColorCompliance(BorderColor,AllCompliance,&image->border_color,\n    exception);\n  (void) QueryColorCompliance(TransparentColor,AllCompliance,\n    &image->transparent_color,exception);\n  GetTimerInfo(&image->timer);\n  image->cache=AcquirePixelCache(0);\n  image->channel_mask=DefaultChannels;\n  image->channel_map=AcquirePixelChannelMap();\n  image->blob=CloneBlobInfo((BlobInfo *) NULL);\n  image->timestamp=time((time_t *) NULL);\n  image->debug=IsEventLogging();\n  image->reference_count=1;\n  image->semaphore=AcquireSemaphoreInfo();\n  image->signature=MagickCoreSignature;\n  if (image_info == (ImageInfo *) NULL)\n    return(image);\n  /*\n    Transfer image info.\n  */\n  SetBlobExempt(image,image_info->file != (FILE *) NULL ? MagickTrue :\n    MagickFalse);\n  (void) CopyMagickString(image->filename,image_info->filename,\n    MagickPathExtent);\n  (void) CopyMagickString(image->magick_filename,image_info->filename,\n    MagickPathExtent);\n  (void) CopyMagickString(image->magick,image_info->magick,MagickPathExtent);\n  if (image_info->size != (char *) NULL)\n    {\n      (void) ParseAbsoluteGeometry(image_info->size,&image->extract_info);\n      image->columns=image->extract_info.width;\n      image->rows=image->extract_info.height;\n      image->offset=image->extract_info.x;\n      image->extract_info.x=0;\n      image->extract_info.y=0;\n    }\n  if (image_info->extract != (char *) NULL)\n    {\n      RectangleInfo\n        geometry;\n\n      flags=ParseAbsoluteGeometry(image_info->extract,&geometry);\n      if (((flags & XValue) != 0) || ((flags & YValue) != 0))\n        {\n          image->extract_info=geometry;\n          Swap(image->columns,image->extract_info.width);\n          Swap(image->rows,image->extract_info.height);\n        }\n    }\n  image->compression=image_info->compression;\n  image->quality=image_info->quality;\n  image->endian=image_info->endian;\n  image->interlace=image_info->interlace;\n  image->units=image_info->units;\n  if (image_info->density != (char *) NULL)\n    {\n      GeometryInfo\n        geometry_info;\n\n      flags=ParseGeometry(image_info->density,&geometry_info);\n      image->resolution.x=geometry_info.rho;\n      image->resolution.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->resolution.y=image->resolution.x;\n    }\n  if (image_info->page != (char *) NULL)\n    {\n      char\n        *geometry;\n\n      image->page=image->extract_info;\n      geometry=GetPageGeometry(image_info->page);\n      (void) ParseAbsoluteGeometry(geometry,&image->page);\n      geometry=DestroyString(geometry);\n    }\n  if (image_info->depth != 0)\n    image->depth=image_info->depth;\n  image->dither=image_info->dither;\n  image->alpha_color=image_info->alpha_color;\n  image->background_color=image_info->background_color;\n  image->border_color=image_info->border_color;\n  image->transparent_color=image_info->transparent_color;\n  image->ping=image_info->ping;\n  image->progress_monitor=image_info->progress_monitor;\n  image->client_data=image_info->client_data;\n  if (image_info->cache != (void *) NULL)\n    ClonePixelCacheMethods(image->cache,image_info->cache);\n  /*\n    Set all global options that map to per-image settings.\n  */\n  (void) SyncImageSettings(image_info,image,exception);\n  /*\n    Global options that are only set for new images.\n  */\n  option=GetImageOption(image_info,\"delay\");\n  if (option != (const char *) NULL)\n    {\n      GeometryInfo\n        geometry_info;\n\n      flags=ParseGeometry(option,&geometry_info);\n      if ((flags & GreaterValue) != 0)\n        {\n          if (image->delay > (size_t) floor(geometry_info.rho+0.5))\n            image->delay=(size_t) floor(geometry_info.rho+0.5);\n        }\n      else\n        if ((flags & LessValue) != 0)\n          {\n            if (image->delay < (size_t) floor(geometry_info.rho+0.5))\n              image->ticks_per_second=(ssize_t) floor(geometry_info.sigma+0.5);\n          }\n        else\n          image->delay=(size_t) floor(geometry_info.rho+0.5);\n      if ((flags & SigmaValue) != 0)\n        image->ticks_per_second=(ssize_t) floor(geometry_info.sigma+0.5);\n    }\n  option=GetImageOption(image_info,\"dispose\");\n  if (option != (const char *) NULL)\n    image->dispose=(DisposeType) ParseCommandOption(MagickDisposeOptions,\n      MagickFalse,option);\n  return(image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   A c q u i r e I m a g e I n f o                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquireImageInfo() allocates the ImageInfo structure.\n%\n%  The format of the AcquireImageInfo method is:\n%\n%      ImageInfo *AcquireImageInfo(void)\n%\n*/\nMagickExport ImageInfo *AcquireImageInfo(void)\n{\n  ImageInfo\n    *image_info;\n\n  image_info=(ImageInfo *) AcquireMagickMemory(sizeof(*image_info));\n  if (image_info == (ImageInfo *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  GetImageInfo(image_info);\n  return(image_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   A c q u i r e N e x t I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquireNextImage() initializes the next image in a sequence to\n%  default values.  The next member of image points to the newly allocated\n%  image.  If there is a memory shortage, next is assigned NULL.\n%\n%  The format of the AcquireNextImage method is:\n%\n%      void AcquireNextImage(const ImageInfo *image_info,Image *image,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: Many of the image default values are set from this\n%      structure.  For example, filename, compression, depth, background color,\n%      and others.\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport void AcquireNextImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  /*\n    Allocate image structure.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  image->next=AcquireImage(image_info,exception);\n  if (GetNextImageInList(image) == (Image *) NULL)\n    return;\n  (void) CopyMagickString(GetNextImageInList(image)->filename,image->filename,\n    MagickPathExtent);\n  if (image_info != (ImageInfo *) NULL)\n    (void) CopyMagickString(GetNextImageInList(image)->filename,\n      image_info->filename,MagickPathExtent);\n  DestroyBlob(GetNextImageInList(image));\n  image->next->blob=ReferenceBlob(image->blob);\n  image->next->endian=image->endian;\n  image->next->scene=image->scene+1;\n  image->next->previous=image;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     A p p e n d I m a g e s                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AppendImages() takes all images from the current image pointer to the end\n%  of the image list and appends them to each other top-to-bottom if the\n%  stack parameter is true, otherwise left-to-right.\n%\n%  The current gravity setting effects how the image is justified in the\n%  final image.\n%\n%  The format of the AppendImages method is:\n%\n%      Image *AppendImages(const Image *images,const MagickBooleanType stack,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o images: the image sequence.\n%\n%    o stack: A value other than 0 stacks the images top-to-bottom.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *AppendImages(const Image *images,\n  const MagickBooleanType stack,ExceptionInfo *exception)\n{\n#define AppendImageTag  \"Append/Image\"\n\n  CacheView\n    *append_view;\n\n  Image\n    *append_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    n;\n\n  PixelTrait\n    alpha_trait;\n\n  RectangleInfo\n    geometry;\n\n  register const Image\n    *next;\n\n  size_t\n    depth,\n    height,\n    number_images,\n    width;\n\n  ssize_t\n    x_offset,\n    y,\n    y_offset;\n\n  /*\n    Compute maximum area of appended area.\n  */\n  assert(images != (Image *) NULL);\n  assert(images->signature == MagickCoreSignature);\n  if (images->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",images->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  alpha_trait=images->alpha_trait;\n  number_images=1;\n  width=images->columns;\n  height=images->rows;\n  depth=images->depth;\n  next=GetNextImageInList(images);\n  for ( ; next != (Image *) NULL; next=GetNextImageInList(next))\n  {\n    if (next->depth > depth)\n      depth=next->depth;\n    if (next->alpha_trait != UndefinedPixelTrait)\n      alpha_trait=BlendPixelTrait;\n    number_images++;\n    if (stack != MagickFalse)\n      {\n        if (next->columns > width)\n          width=next->columns;\n        height+=next->rows;\n        continue;\n      }\n    width+=next->columns;\n    if (next->rows > height)\n      height=next->rows;\n  }\n  /*\n    Append images.\n  */\n  append_image=CloneImage(images,width,height,MagickTrue,exception);\n  if (append_image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(append_image,DirectClass,exception) == MagickFalse)\n    {\n      append_image=DestroyImage(append_image);\n      return((Image *) NULL);\n    }\n  append_image->depth=depth;\n  append_image->alpha_trait=alpha_trait;\n  (void) SetImageBackgroundColor(append_image,exception);\n  status=MagickTrue;\n  x_offset=0;\n  y_offset=0;\n  next=images;\n  append_view=AcquireAuthenticCacheView(append_image,exception);\n  for (n=0; n < (MagickOffsetType) number_images; n++)\n  {\n    CacheView\n      *image_view;\n\n    MagickBooleanType\n      proceed;\n\n    SetGeometry(append_image,&geometry);\n    GravityAdjustGeometry(next->columns,next->rows,next->gravity,&geometry);\n    if (stack != MagickFalse)\n      x_offset-=geometry.x;\n    else\n      y_offset-=geometry.y;\n    image_view=AcquireVirtualCacheView(next,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n    #pragma omp parallel for schedule(static,4) shared(status) \\\n      magick_threads(next,next,next->rows,1)\n#endif\n    for (y=0; y < (ssize_t) next->rows; y++)\n    {\n      MagickBooleanType\n        sync;\n\n      PixelInfo\n        pixel;\n\n      register const Quantum\n        *magick_restrict p;\n\n      register Quantum\n        *magick_restrict q;\n\n      register ssize_t\n        x;\n\n      if (status == MagickFalse)\n        continue;\n      p=GetCacheViewVirtualPixels(image_view,0,y,next->columns,1,exception);\n      q=QueueCacheViewAuthenticPixels(append_view,x_offset,y+y_offset,\n        next->columns,1,exception);\n      if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n        {\n          status=MagickFalse;\n          continue;\n        }\n      GetPixelInfo(next,&pixel);\n      for (x=0; x < (ssize_t) next->columns; x++)\n      {\n        if (GetPixelReadMask(next,p) == 0)\n          {\n            SetPixelBackgoundColor(append_image,q);\n            p+=GetPixelChannels(next);\n            q+=GetPixelChannels(append_image);\n            continue;\n          }\n        GetPixelInfoPixel(next,p,&pixel);\n        SetPixelViaPixelInfo(append_image,&pixel,q);\n        p+=GetPixelChannels(next);\n        q+=GetPixelChannels(append_image);\n      }\n      sync=SyncCacheViewAuthenticPixels(append_view,exception);\n      if (sync == MagickFalse)\n        status=MagickFalse;\n    }\n    image_view=DestroyCacheView(image_view);\n    if (stack == MagickFalse)\n      {\n        x_offset+=(ssize_t) next->columns;\n        y_offset=0;\n      }\n    else\n      {\n        x_offset=0;\n        y_offset+=(ssize_t) next->rows;\n      }\n    proceed=SetImageProgress(append_image,AppendImageTag,n,number_images);\n    if (proceed == MagickFalse)\n      break;\n    next=GetNextImageInList(next);\n  }\n  append_view=DestroyCacheView(append_view);\n  if (status == MagickFalse)\n    append_image=DestroyImage(append_image);\n  return(append_image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C a t c h I m a g e E x c e p t i o n                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CatchImageException() returns if no exceptions are found in the image\n%  sequence, otherwise it determines the most severe exception and reports\n%  it as a warning or error depending on the severity.\n%\n%  The format of the CatchImageException method is:\n%\n%      ExceptionType CatchImageException(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: An image sequence.\n%\n*/\nMagickExport ExceptionType CatchImageException(Image *image)\n{\n  ExceptionInfo\n    *exception;\n\n  ExceptionType\n    severity;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  exception=AcquireExceptionInfo();\n  CatchException(exception);\n  severity=exception->severity;\n  exception=DestroyExceptionInfo(exception);\n  return(severity);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C l i p I m a g e P a t h                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ClipImagePath() sets the image clip mask based any clipping path information\n%  if it exists.\n%\n%  The format of the ClipImagePath method is:\n%\n%      MagickBooleanType ClipImagePath(Image *image,const char *pathname,\n%        const MagickBooleanType inside,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o pathname: name of clipping path resource. If name is preceded by #, use\n%      clipping path numbered by name.\n%\n%    o inside: if non-zero, later operations take effect inside clipping path.\n%      Otherwise later operations take effect outside clipping path.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nMagickExport MagickBooleanType ClipImage(Image *image,ExceptionInfo *exception)\n{\n  return(ClipImagePath(image,\"#1\",MagickTrue,exception));\n}\n\nMagickExport MagickBooleanType ClipImagePath(Image *image,const char *pathname,\n  const MagickBooleanType inside,ExceptionInfo *exception)\n{\n#define ClipImagePathTag  \"ClipPath/Image\"\n\n  char\n    *property;\n\n  const char\n    *value;\n\n  Image\n    *clip_mask;\n\n  ImageInfo\n    *image_info;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(pathname != NULL);\n  property=AcquireString(pathname);\n  (void) FormatLocaleString(property,MagickPathExtent,\"8BIM:1999,2998:%s\",\n    pathname);\n  value=GetImageProperty(image,property,exception);\n  property=DestroyString(property);\n  if (value == (const char *) NULL)\n    {\n      ThrowFileException(exception,OptionError,\"NoClipPathDefined\",\n        image->filename);\n      return(MagickFalse);\n    }\n  image_info=AcquireImageInfo();\n  (void) CopyMagickString(image_info->filename,image->filename,\n     MagickPathExtent);\n  (void) ConcatenateMagickString(image_info->filename,pathname,\n    MagickPathExtent);\n  clip_mask=BlobToImage(image_info,value,strlen(value),exception);\n  image_info=DestroyImageInfo(image_info);\n  if (clip_mask == (Image *) NULL)\n    return(MagickFalse);\n  if (clip_mask->storage_class == PseudoClass)\n    {\n      (void) SyncImage(clip_mask,exception);\n      if (SetImageStorageClass(clip_mask,DirectClass,exception) == MagickFalse)\n        return(MagickFalse);\n    }\n  if (inside == MagickFalse)\n    (void) NegateImage(clip_mask,MagickFalse,exception);\n  (void) FormatLocaleString(clip_mask->magick_filename,MagickPathExtent,\n    \"8BIM:1999,2998:%s\\nPS\",pathname);\n  (void) SetImageMask(image,ReadPixelMask,clip_mask,exception);\n  clip_mask=DestroyImage(clip_mask);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C l o n e I m a g e                                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CloneImage() copies an image and returns the copy as a new image object.\n%\n%  If the specified columns and rows is 0, an exact copy of the image is\n%  returned, otherwise the pixel data is undefined and must be initialized\n%  with the QueueAuthenticPixels() and SyncAuthenticPixels() methods.  On\n%  failure, a NULL image is returned and exception describes the reason for the\n%  failure.\n%\n%  The format of the CloneImage method is:\n%\n%      Image *CloneImage(const Image *image,const size_t columns,\n%        const size_t rows,const MagickBooleanType orphan,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o columns: the number of columns in the cloned image.\n%\n%    o rows: the number of rows in the cloned image.\n%\n%    o detach:  With a value other than 0, the cloned image is detached from\n%      its parent I/O stream.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *CloneImage(const Image *image,const size_t columns,\n  const size_t rows,const MagickBooleanType detach,ExceptionInfo *exception)\n{\n  Image\n    *clone_image;\n\n  double\n    scale;\n\n  size_t\n    length;\n\n  /*\n    Clone the image.\n  */\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if ((image->columns == 0) || (image->rows == 0))\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,\n        \"NegativeOrZeroImageSize\",\"`%s'\",image->filename);\n      return((Image *) NULL);\n    }\n  clone_image=(Image *) AcquireMagickMemory(sizeof(*clone_image));\n  if (clone_image == (Image *) NULL)\n    ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(clone_image,0,sizeof(*clone_image));\n  clone_image->signature=MagickCoreSignature;\n  clone_image->storage_class=image->storage_class;\n  clone_image->number_channels=image->number_channels;\n  clone_image->number_meta_channels=image->number_meta_channels;\n  clone_image->metacontent_extent=image->metacontent_extent;\n  clone_image->colorspace=image->colorspace;\n  clone_image->read_mask=image->read_mask;\n  clone_image->write_mask=image->write_mask;\n  clone_image->alpha_trait=image->alpha_trait;\n  clone_image->columns=image->columns;\n  clone_image->rows=image->rows;\n  clone_image->dither=image->dither;\n  if (image->colormap != (PixelInfo *) NULL)\n    {\n      /*\n        Allocate and copy the image colormap.\n      */\n      clone_image->colors=image->colors;\n      length=(size_t) image->colors;\n      clone_image->colormap=(PixelInfo *) AcquireQuantumMemory(length,\n        sizeof(*clone_image->colormap));\n      if (clone_image->colormap == (PixelInfo *) NULL)\n        {\n          clone_image=DestroyImage(clone_image);\n          ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n      (void) CopyMagickMemory(clone_image->colormap,image->colormap,length*\n        sizeof(*clone_image->colormap));\n    }\n  clone_image->image_info=CloneImageInfo(image->image_info);\n  (void) CloneImageProfiles(clone_image,image);\n  (void) CloneImageProperties(clone_image,image);\n  (void) CloneImageArtifacts(clone_image,image);\n  GetTimerInfo(&clone_image->timer);\n  if (image->ascii85 != (void *) NULL)\n    Ascii85Initialize(clone_image);\n  clone_image->magick_columns=image->magick_columns;\n  clone_image->magick_rows=image->magick_rows;\n  clone_image->type=image->type;\n  clone_image->channel_mask=image->channel_mask;\n  clone_image->channel_map=ClonePixelChannelMap(image->channel_map);\n  (void) CopyMagickString(clone_image->magick_filename,image->magick_filename,\n    MagickPathExtent);\n  (void) CopyMagickString(clone_image->magick,image->magick,MagickPathExtent);\n  (void) CopyMagickString(clone_image->filename,image->filename,\n    MagickPathExtent);\n  clone_image->progress_monitor=image->progress_monitor;\n  clone_image->client_data=image->client_data;\n  clone_image->reference_count=1;\n  clone_image->next=image->next;\n  clone_image->previous=image->previous;\n  clone_image->list=NewImageList();\n  if (detach == MagickFalse)\n    clone_image->blob=ReferenceBlob(image->blob);\n  else\n    {\n      clone_image->next=NewImageList();\n      clone_image->previous=NewImageList();\n      clone_image->blob=CloneBlobInfo((BlobInfo *) NULL);\n    }\n  clone_image->ping=image->ping;\n  clone_image->debug=IsEventLogging();\n  clone_image->semaphore=AcquireSemaphoreInfo();\n  if ((columns == 0) || (rows == 0))\n    {\n      if (image->montage != (char *) NULL)\n        (void) CloneString(&clone_image->montage,image->montage);\n      if (image->directory != (char *) NULL)\n        (void) CloneString(&clone_image->directory,image->directory);\n      clone_image->cache=ReferencePixelCache(image->cache);\n      return(clone_image);\n    }\n  scale=1.0;\n  if (image->columns != 0)\n    scale=(double) columns/(double) image->columns;\n  clone_image->page.width=(size_t) floor(scale*image->page.width+0.5);\n  clone_image->page.x=(ssize_t) ceil(scale*image->page.x-0.5);\n  clone_image->tile_offset.x=(ssize_t) ceil(scale*image->tile_offset.x-0.5);\n  scale=1.0;\n  if (image->rows != 0)\n    scale=(double) rows/(double) image->rows;\n  clone_image->page.height=(size_t) floor(scale*image->page.height+0.5);\n  clone_image->page.y=(ssize_t) ceil(scale*image->page.y-0.5);\n  clone_image->tile_offset.y=(ssize_t) ceil(scale*image->tile_offset.y-0.5);\n  clone_image->columns=columns;\n  clone_image->rows=rows;\n  clone_image->cache=ClonePixelCache(image->cache);\n  return(clone_image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C l o n e I m a g e I n f o                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CloneImageInfo() makes a copy of the given image info structure.  If\n%  NULL is specified, a new image info structure is created initialized to\n%  default values.\n%\n%  The format of the CloneImageInfo method is:\n%\n%      ImageInfo *CloneImageInfo(const ImageInfo *image_info)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n*/\nMagickExport ImageInfo *CloneImageInfo(const ImageInfo *image_info)\n{\n  ImageInfo\n    *clone_info;\n\n  clone_info=AcquireImageInfo();\n  if (image_info == (ImageInfo *) NULL)\n    return(clone_info);\n  clone_info->compression=image_info->compression;\n  clone_info->temporary=image_info->temporary;\n  clone_info->adjoin=image_info->adjoin;\n  clone_info->antialias=image_info->antialias;\n  clone_info->scene=image_info->scene;\n  clone_info->number_scenes=image_info->number_scenes;\n  clone_info->depth=image_info->depth;\n  (void) CloneString(&clone_info->size,image_info->size);\n  (void) CloneString(&clone_info->extract,image_info->extract);\n  (void) CloneString(&clone_info->scenes,image_info->scenes);\n  (void) CloneString(&clone_info->page,image_info->page);\n  clone_info->interlace=image_info->interlace;\n  clone_info->endian=image_info->endian;\n  clone_info->units=image_info->units;\n  clone_info->quality=image_info->quality;\n  (void) CloneString(&clone_info->sampling_factor,image_info->sampling_factor);\n  (void) CloneString(&clone_info->server_name,image_info->server_name);\n  (void) CloneString(&clone_info->font,image_info->font);\n  (void) CloneString(&clone_info->texture,image_info->texture);\n  (void) CloneString(&clone_info->density,image_info->density);\n  clone_info->pointsize=image_info->pointsize;\n  clone_info->fuzz=image_info->fuzz;\n  clone_info->alpha_color=image_info->alpha_color;\n  clone_info->background_color=image_info->background_color;\n  clone_info->border_color=image_info->border_color;\n  clone_info->transparent_color=image_info->transparent_color;\n  clone_info->dither=image_info->dither;\n  clone_info->monochrome=image_info->monochrome;\n  clone_info->colorspace=image_info->colorspace;\n  clone_info->type=image_info->type;\n  clone_info->orientation=image_info->orientation;\n  clone_info->ping=image_info->ping;\n  clone_info->verbose=image_info->verbose;\n  clone_info->progress_monitor=image_info->progress_monitor;\n  clone_info->client_data=image_info->client_data;\n  clone_info->cache=image_info->cache;\n  if (image_info->cache != (void *) NULL)\n    clone_info->cache=ReferencePixelCache(image_info->cache);\n  if (image_info->profile != (void *) NULL)\n    clone_info->profile=(void *) CloneStringInfo((StringInfo *)\n      image_info->profile);\n  SetImageInfoFile(clone_info,image_info->file);\n  SetImageInfoBlob(clone_info,image_info->blob,image_info->length);\n  clone_info->stream=image_info->stream;\n  (void) CopyMagickString(clone_info->magick,image_info->magick,\n    MagickPathExtent);\n  (void) CopyMagickString(clone_info->unique,image_info->unique,\n    MagickPathExtent);\n  (void) CopyMagickString(clone_info->filename,image_info->filename,\n    MagickPathExtent);\n  clone_info->channel=image_info->channel;\n  (void) CloneImageOptions(clone_info,image_info);\n  clone_info->debug=IsEventLogging();\n  clone_info->signature=image_info->signature;\n  return(clone_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C o p y I m a g e P i x e l s                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CopyImagePixels() copies pixels from the source image as defined by the\n%  geometry the destination image at the specified offset.\n%\n%  The format of the CopyImagePixels method is:\n%\n%      MagickBooleanType CopyImagePixels(Image *image,const Image *source_image,\n%        const RectangleInfo *geometry,const OffsetInfo *offset,\n%        ExceptionInfo *exception);\n%\n%  A description of each parameter follows:\n%\n%    o image: the destination image.\n%\n%    o source_image: the source image.\n%\n%    o geometry: define the dimensions of the source pixel rectangle.\n%\n%    o offset: define the offset in the destination image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType CopyImagePixels(Image *image,\n  const Image *source_image,const RectangleInfo *geometry,\n  const OffsetInfo *offset,ExceptionInfo *exception)\n{\n#define CopyImageTag  \"Copy/Image\"\n\n  CacheView\n    *image_view,\n    *source_view;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(source_image != (Image *) NULL);\n  assert(geometry != (RectangleInfo *) NULL);\n  assert(offset != (OffsetInfo *) NULL);\n  if ((offset->x < 0) || (offset->y < 0) ||\n      ((ssize_t) (offset->x+geometry->width) > (ssize_t) image->columns) ||\n      ((ssize_t) (offset->y+geometry->height) > (ssize_t) image->rows))\n    ThrowBinaryException(OptionError,\"GeometryDoesNotContainImage\",\n      image->filename);\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    return(MagickFalse);\n  /*\n    Copy image pixels.\n  */\n  status=MagickTrue;\n  progress=0;\n  source_view=AcquireVirtualCacheView(source_image,exception);\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(image,source_image,geometry->height,1)\n#endif\n  for (y=0; y < (ssize_t) geometry->height; y++)\n  {\n    MagickBooleanType\n      sync;\n\n    register const Quantum\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    register Quantum\n      *magick_restrict q;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(source_view,geometry->x,y+geometry->y,\n      geometry->width,1,exception);\n    q=QueueCacheViewAuthenticPixels(image_view,offset->x,y+offset->y,\n      geometry->width,1,exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) geometry->width; x++)\n    {\n      register ssize_t\n        i;\n\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      { \n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        PixelTrait source_traits=GetPixelChannelTraits(source_image,channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (source_traits == UndefinedPixelTrait))\n          continue;\n        SetPixelChannel(image,channel,p[i],q);\n      }\n      p+=GetPixelChannels(source_image);\n      q+=GetPixelChannels(image);\n    }\n    sync=SyncCacheViewAuthenticPixels(image_view,exception);\n    if (sync == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_CopyImage)\n#endif\n        proceed=SetImageProgress(image,CopyImageTag,progress++,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  source_view=DestroyCacheView(source_view);\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e s t r o y I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyImage() dereferences an image, deallocating memory associated with\n%  the image if the reference count becomes zero.\n%\n%  The format of the DestroyImage method is:\n%\n%      Image *DestroyImage(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport Image *DestroyImage(Image *image)\n{\n  MagickBooleanType\n    destroy;\n\n  /*\n    Dereference image.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  destroy=MagickFalse;\n  LockSemaphoreInfo(image->semaphore);\n  image->reference_count--;\n  if (image->reference_count == 0)\n    destroy=MagickTrue;\n  UnlockSemaphoreInfo(image->semaphore);\n  if (destroy == MagickFalse)\n    return((Image *) NULL);\n  /*\n    Destroy image.\n  */\n  DestroyImagePixels(image);\n  image->channel_map=DestroyPixelChannelMap(image->channel_map);\n  if (image->montage != (char *) NULL)\n    image->montage=DestroyString(image->montage);\n  if (image->directory != (char *) NULL)\n    image->directory=DestroyString(image->directory);\n  if (image->colormap != (PixelInfo *) NULL)\n    image->colormap=(PixelInfo *) RelinquishMagickMemory(image->colormap);\n  if (image->geometry != (char *) NULL)\n    image->geometry=DestroyString(image->geometry);\n  DestroyImageProfiles(image);\n  DestroyImageProperties(image);\n  DestroyImageArtifacts(image);\n  if (image->ascii85 != (Ascii85Info *) NULL)\n    image->ascii85=(Ascii85Info *) RelinquishMagickMemory(image->ascii85);\n  if (image->image_info != (ImageInfo *) NULL)\n    image->image_info=DestroyImageInfo(image->image_info);\n  DestroyBlob(image);\n  if (image->semaphore != (SemaphoreInfo *) NULL)\n    RelinquishSemaphoreInfo(&image->semaphore);\n  image->signature=(~MagickCoreSignature);\n  image=(Image *) RelinquishMagickMemory(image);\n  return(image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e s t r o y I m a g e I n f o                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyImageInfo() deallocates memory associated with an ImageInfo\n%  structure.\n%\n%  The format of the DestroyImageInfo method is:\n%\n%      ImageInfo *DestroyImageInfo(ImageInfo *image_info)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n*/\nMagickExport ImageInfo *DestroyImageInfo(ImageInfo *image_info)\n{\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  if (image_info->size != (char *) NULL)\n    image_info->size=DestroyString(image_info->size);\n  if (image_info->extract != (char *) NULL)\n    image_info->extract=DestroyString(image_info->extract);\n  if (image_info->scenes != (char *) NULL)\n    image_info->scenes=DestroyString(image_info->scenes);\n  if (image_info->page != (char *) NULL)\n    image_info->page=DestroyString(image_info->page);\n  if (image_info->sampling_factor != (char *) NULL)\n    image_info->sampling_factor=DestroyString(\n      image_info->sampling_factor);\n  if (image_info->server_name != (char *) NULL)\n    image_info->server_name=DestroyString(\n      image_info->server_name);\n  if (image_info->font != (char *) NULL)\n    image_info->font=DestroyString(image_info->font);\n  if (image_info->texture != (char *) NULL)\n    image_info->texture=DestroyString(image_info->texture);\n  if (image_info->density != (char *) NULL)\n    image_info->density=DestroyString(image_info->density);\n  if (image_info->cache != (void *) NULL)\n    image_info->cache=DestroyPixelCache(image_info->cache);\n  if (image_info->profile != (StringInfo *) NULL)\n    image_info->profile=(void *) DestroyStringInfo((StringInfo *)\n      image_info->profile);\n  DestroyImageOptions(image_info);\n  image_info->signature=(~MagickCoreSignature);\n  image_info=(ImageInfo *) RelinquishMagickMemory(image_info);\n  return(image_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D i s a s s o c i a t e I m a g e S t r e a m                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DisassociateImageStream() disassociates the image stream.  It checks if the\n%  blob of the specified image is referenced by other images. If the reference\n%  count is higher then 1 a new blob is assigned to the specified image.\n%\n%  The format of the DisassociateImageStream method is:\n%\n%      void DisassociateImageStream(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport void DisassociateImageStream(Image *image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  DisassociateBlob(image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e I n f o                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageInfo() initializes image_info to default values.\n%\n%  The format of the GetImageInfo method is:\n%\n%      void GetImageInfo(ImageInfo *image_info)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n*/\nMagickExport void GetImageInfo(ImageInfo *image_info)\n{\n  char\n    *synchronize;\n\n  ExceptionInfo\n    *exception;\n\n  /*\n    File and image dimension members.\n  */\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image_info != (ImageInfo *) NULL);\n  (void) ResetMagickMemory(image_info,0,sizeof(*image_info));\n  image_info->adjoin=MagickTrue;\n  image_info->interlace=NoInterlace;\n  image_info->channel=DefaultChannels;\n  image_info->quality=UndefinedCompressionQuality;\n  image_info->antialias=MagickTrue;\n  image_info->dither=MagickTrue;\n  synchronize=GetEnvironmentValue(\"MAGICK_SYNCHRONIZE\");\n  if (synchronize != (const char *) NULL)\n    {\n      image_info->synchronize=IsStringTrue(synchronize);\n      synchronize=DestroyString(synchronize);\n    }\n  exception=AcquireExceptionInfo();\n  (void) QueryColorCompliance(AlphaColor,AllCompliance,&image_info->alpha_color,\n    exception);\n  (void) QueryColorCompliance(BackgroundColor,AllCompliance,\n    &image_info->background_color,exception);\n  (void) QueryColorCompliance(BorderColor,AllCompliance,\n    &image_info->border_color,exception);\n  (void) QueryColorCompliance(TransparentColor,AllCompliance,\n    &image_info->transparent_color,exception);\n  exception=DestroyExceptionInfo(exception);\n  image_info->debug=IsEventLogging();\n  image_info->signature=MagickCoreSignature;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e I n f o F i l e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageInfoFile() returns the image info file member.\n%\n%  The format of the GetImageInfoFile method is:\n%\n%      FILE *GetImageInfoFile(const ImageInfo *image_info)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n*/\nMagickExport FILE *GetImageInfoFile(const ImageInfo *image_info)\n{\n  return(image_info->file);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e M a s k                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageMask() returns the mask associated with the image.\n%\n%  The format of the GetImageMask method is:\n%\n%      Image *GetImageMask(const Image *image,const PixelMask type,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o type: the mask type, ReadPixelMask or WritePixelMask.\n%\n*/\nMagickExport Image *GetImageMask(const Image *image,const PixelMask type,\n  ExceptionInfo *exception)\n{\n  CacheView\n    *mask_view,\n    *image_view;\n\n  Image\n    *mask_image;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  /*\n    Get image mask.\n  */\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickCoreSignature);\n  mask_image=CloneImage(image,image->columns,image->rows,MagickTrue,exception);\n  if (mask_image == (Image *) NULL)\n    return((Image *) NULL);\n  status=MagickTrue;\n  mask_image->alpha_trait=UndefinedPixelTrait;\n  (void) SetImageColorspace(mask_image,GRAYColorspace,exception);\n  mask_image->read_mask=MagickFalse;\n  image_view=AcquireVirtualCacheView(image,exception);\n  mask_view=AcquireAuthenticCacheView(mask_image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const Quantum\n      *magick_restrict p;\n\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    q=GetCacheViewAuthenticPixels(mask_view,0,y,mask_image->columns,1,\n      exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      switch (type)\n      {\n        case WritePixelMask:\n        {\n          SetPixelGray(mask_image,GetPixelWriteMask(image,p),q);\n          break;\n        }\n        default:\n        {\n          SetPixelGray(mask_image,GetPixelReadMask(image,p),q);\n          break;\n        }\n      }\n      p+=GetPixelChannels(image);\n      q+=GetPixelChannels(mask_image);\n    }\n    if (SyncCacheViewAuthenticPixels(mask_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  mask_view=DestroyCacheView(mask_view);\n  image_view=DestroyCacheView(image_view);\n  if (status == MagickFalse)\n    mask_image=DestroyImage(mask_image);\n  return(mask_image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t I m a g e R e f e r e n c e C o u n t                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageReferenceCount() returns the image reference count.\n%\n%  The format of the GetReferenceCount method is:\n%\n%      ssize_t GetImageReferenceCount(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport ssize_t GetImageReferenceCount(Image *image)\n{\n  ssize_t\n    reference_count;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  LockSemaphoreInfo(image->semaphore);\n  reference_count=image->reference_count;\n  UnlockSemaphoreInfo(image->semaphore);\n  return(reference_count);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e V i r t u a l P i x e l M e t h o d                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageVirtualPixelMethod() gets the \"virtual pixels\" method for the\n%  image.  A virtual pixel is any pixel access that is outside the boundaries\n%  of the image cache.\n%\n%  The format of the GetImageVirtualPixelMethod() method is:\n%\n%      VirtualPixelMethod GetImageVirtualPixelMethod(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport VirtualPixelMethod GetImageVirtualPixelMethod(const Image *image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  return(GetPixelCacheVirtualMethod(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%  I n t e r p r e t I m a g e F i l e n a m e                                %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  InterpretImageFilename() interprets embedded characters in an image filename.\n%  The filename length is returned.\n%\n%  The format of the InterpretImageFilename method is:\n%\n%      size_t InterpretImageFilename(const ImageInfo *image_info,Image *image,\n%        const char *format,int value,char *filename,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info..\n%\n%    o image: the image.\n%\n%    o format:  A filename describing the format to use to write the numeric\n%      argument. Only the first numeric format identifier is replaced.\n%\n%    o value:  Numeric value to substitute into format filename.\n%\n%    o filename:  return the formatted filename in this character buffer.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport size_t InterpretImageFilename(const ImageInfo *image_info,\n  Image *image,const char *format,int value,char *filename,\n  ExceptionInfo *exception)\n{\n  char\n    *q;\n\n  int\n    c;\n\n  MagickBooleanType\n    canonical;\n\n  register const char\n    *p;\n\n  size_t\n    length;\n\n  canonical=MagickFalse;\n  length=0;\n  (void) CopyMagickString(filename,format,MagickPathExtent);\n  for (p=strchr(format,'%'); p != (char *) NULL; p=strchr(p+1,'%'))\n  {\n    q=(char *) p+1;\n    if (*q == '%')\n      {\n        p=q+1;\n        continue;\n      }\n    if (*q == '0')\n      {\n        ssize_t\n          foo;\n\n        foo=(ssize_t) strtol(q,&q,10);\n        (void) foo;\n      }\n    switch (*q)\n    {\n      case 'd':\n      case 'o':\n      case 'x':\n      {\n        q++;\n        c=(*q);\n        *q='\\0';\n        (void) FormatLocaleString(filename+(p-format),(size_t)\n          (MagickPathExtent-(p-format)),p,value);\n        *q=c;\n        (void) ConcatenateMagickString(filename,q,MagickPathExtent);\n        canonical=MagickTrue;\n        if (*(q-1) != '%')\n          break;\n        p++;\n        break;\n      }\n      case '[':\n      {\n        char\n          pattern[MagickPathExtent];\n\n        const char\n          *option;\n\n        register char\n          *r;\n\n        register ssize_t\n          i;\n\n        ssize_t\n          depth;\n\n        /*\n          Image option.\n        */\n        /* FUTURE: Compare update with code from InterpretImageProperties()\n           Note that a 'filename:' property should not need depth recursion.\n        */\n        if (strchr(p,']') == (char *) NULL)\n          break;\n        depth=1;\n        r=q+1;\n        for (i=0; (i < (MagickPathExtent-1L)) && (*r != '\\0'); i++)\n        {\n          if (*r == '[')\n            depth++;\n          if (*r == ']')\n            depth--;\n          if (depth <= 0)\n            break;\n          pattern[i]=(*r++);\n        }\n        pattern[i]='\\0';\n        if (LocaleNCompare(pattern,\"filename:\",9) != 0)\n          break;\n        option=(const char *) NULL;\n        if (image != (Image *) NULL)\n          option=GetImageProperty(image,pattern,exception);\n        if ((option == (const char *) NULL) && (image != (Image *) NULL))\n          option=GetImageArtifact(image,pattern);\n        if ((option == (const char *) NULL) &&\n            (image_info != (ImageInfo *) NULL))\n          option=GetImageOption(image_info,pattern);\n        if (option == (const char *) NULL)\n          break;\n        q--;\n        c=(*q);\n        *q='\\0';\n        (void) CopyMagickString(filename+(p-format-length),option,(size_t)\n          (MagickPathExtent-(p-format-length)));\n        length+=strlen(pattern)-1;\n        *q=c;\n        (void) ConcatenateMagickString(filename,r+1,MagickPathExtent);\n        canonical=MagickTrue;\n        if (*(q-1) != '%')\n          break;\n        p++;\n        break;\n      }\n      default:\n        break;\n    }\n  }\n  for (q=filename; *q != '\\0'; q++)\n    if ((*q == '%') && (*(q+1) == '%'))\n      {\n        (void) CopyMagickString(q,q+1,(size_t) (MagickPathExtent-(q-filename)));\n        canonical=MagickTrue;\n      }\n  if (canonical == MagickFalse)\n    (void) CopyMagickString(filename,format,MagickPathExtent);\n  return(strlen(filename));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s H i g h D y n a m i c R a n g e I m a g e                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsHighDynamicRangeImage() returns MagickTrue if any pixel component is\n%  non-integer or exceeds the bounds of the quantum depth (e.g. for Q16\n%  0..65535.\n%\n%  The format of the IsHighDynamicRangeImage method is:\n%\n%      MagickBooleanType IsHighDynamicRangeImage(const Image *image,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType IsHighDynamicRangeImage(const Image *image,\n  ExceptionInfo *exception)\n{\n#if !defined(MAGICKCORE_HDRI_SUPPORT)\n  (void) image;\n  (void) exception;\n  return(MagickFalse);\n#else\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=MagickTrue;\n  image_view=AcquireVirtualCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(status) \\\n    magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const Quantum\n      *p;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      if (GetPixelReadMask(image,p) == 0)\n        {\n          p+=GetPixelChannels(image);\n          continue;\n        }\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        double\n          pixel;\n\n        PixelTrait\n          traits;\n\n        traits=GetPixelChannelTraits(image,(PixelChannel) i);\n        if (traits == UndefinedPixelTrait)\n          continue;\n        pixel=(double) p[i];\n        if ((pixel < 0.0) || (pixel > QuantumRange) ||\n            (pixel != (double) ((QuantumAny) pixel)))\n          break;\n      }\n      p+=GetPixelChannels(image);\n      if (i < (ssize_t) GetPixelChannels(image))\n        status=MagickFalse;\n    }\n    if (x < (ssize_t) image->columns)\n      status=MagickFalse;\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status != MagickFalse ? MagickFalse : MagickTrue);\n#endif\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     I s I m a g e O b j e c t                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsImageObject() returns MagickTrue if the image sequence contains a valid\n%  set of image objects.\n%\n%  The format of the IsImageObject method is:\n%\n%      MagickBooleanType IsImageObject(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport MagickBooleanType IsImageObject(const Image *image)\n{\n  register const Image\n    *p;\n\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  for (p=image; p != (Image *) NULL; p=GetNextImageInList(p))\n    if (p->signature != MagickCoreSignature)\n      return(MagickFalse);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     I s T a i n t I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsTaintImage() returns MagickTrue any pixel in the image has been altered\n%  since it was first constituted.\n%\n%  The format of the IsTaintImage method is:\n%\n%      MagickBooleanType IsTaintImage(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport MagickBooleanType IsTaintImage(const Image *image)\n{\n  char\n    magick[MagickPathExtent],\n    filename[MagickPathExtent];\n\n  register const Image\n    *p;\n\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickCoreSignature);\n  (void) CopyMagickString(magick,image->magick,MagickPathExtent);\n  (void) CopyMagickString(filename,image->filename,MagickPathExtent);\n  for (p=image; p != (Image *) NULL; p=GetNextImageInList(p))\n  {\n    if (p->taint != MagickFalse)\n      return(MagickTrue);\n    if (LocaleCompare(p->magick,magick) != 0)\n      return(MagickTrue);\n    if (LocaleCompare(p->filename,filename) != 0)\n      return(MagickTrue);\n  }\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   M o d i f y I m a g e                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ModifyImage() ensures that there is only a single reference to the image\n%  to be modified, updating the provided image pointer to point to a clone of\n%  the original image if necessary.\n%\n%  The format of the ModifyImage method is:\n%\n%      MagickBooleanType ModifyImage(Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType ModifyImage(Image **image,\n  ExceptionInfo *exception)\n{\n  Image\n    *clone_image;\n\n  assert(image != (Image **) NULL);\n  assert(*image != (Image *) NULL);\n  assert((*image)->signature == MagickCoreSignature);\n  if ((*image)->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",(*image)->filename);\n  if (GetImageReferenceCount(*image) <= 1)\n    return(MagickTrue);\n  clone_image=CloneImage(*image,0,0,MagickTrue,exception);\n  LockSemaphoreInfo((*image)->semaphore);\n  (*image)->reference_count--;\n  UnlockSemaphoreInfo((*image)->semaphore);\n  *image=clone_image;\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   N e w M a g i c k I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  NewMagickImage() creates a blank image canvas of the specified size and\n%  background color.\n%\n%  The format of the NewMagickImage method is:\n%\n%      Image *NewMagickImage(const ImageInfo *image_info,const size_t width,\n%        const size_t height,const PixelInfo *background,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o width: the image width.\n%\n%    o height: the image height.\n%\n%    o background: the image color.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *NewMagickImage(const ImageInfo *image_info,\n  const size_t width,const size_t height,const PixelInfo *background,\n  ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  assert(image_info != (const ImageInfo *) NULL);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image_info->signature == MagickCoreSignature);\n  assert(background != (const PixelInfo *) NULL);\n  image=AcquireImage(image_info,exception);\n  image->columns=width;\n  image->rows=height;\n  image->colorspace=background->colorspace;\n  image->alpha_trait=background->alpha_trait;\n  image->fuzz=background->fuzz;\n  image->depth=background->depth;\n  status=MagickTrue;\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(status) \\\n    magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=QueueCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      SetPixelViaPixelInfo(image,background,q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  image_view=DestroyCacheView(image_view);\n  if (status == MagickFalse)\n    image=DestroyImage(image);\n  return(image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e f e r e n c e I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReferenceImage() increments the reference count associated with an image\n%  returning a pointer to the image.\n%\n%  The format of the ReferenceImage method is:\n%\n%      Image *ReferenceImage(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport Image *ReferenceImage(Image *image)\n{\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickCoreSignature);\n  LockSemaphoreInfo(image->semaphore);\n  image->reference_count++;\n  UnlockSemaphoreInfo(image->semaphore);\n  return(image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e s e t I m a g e P a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ResetImagePage() resets the image page canvas and position.\n%\n%  The format of the ResetImagePage method is:\n%\n%      MagickBooleanType ResetImagePage(Image *image,const char *page)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o page: the relative page specification.\n%\n*/\nMagickExport MagickBooleanType ResetImagePage(Image *image,const char *page)\n{\n  MagickStatusType\n    flags;\n\n  RectangleInfo\n    geometry;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  flags=ParseAbsoluteGeometry(page,&geometry);\n  if ((flags & WidthValue) != 0)\n    {\n      if ((flags & HeightValue) == 0)\n        geometry.height=geometry.width;\n      image->page.width=geometry.width;\n      image->page.height=geometry.height;\n    }\n  if ((flags & AspectValue) != 0)\n    {\n      if ((flags & XValue) != 0)\n        image->page.x+=geometry.x;\n      if ((flags & YValue) != 0)\n        image->page.y+=geometry.y;\n    }\n  else\n    {\n      if ((flags & XValue) != 0)\n        {\n          image->page.x=geometry.x;\n          if ((image->page.width == 0) && (geometry.x > 0))\n            image->page.width=image->columns+geometry.x;\n        }\n      if ((flags & YValue) != 0)\n        {\n          image->page.y=geometry.y;\n          if ((image->page.height == 0) && (geometry.y > 0))\n            image->page.height=image->rows+geometry.y;\n        }\n    }\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t I m a g e B a c k g r o u n d C o l o r                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageBackgroundColor() initializes the image pixels to the image\n%  background color.  The background color is defined by the background_color\n%  member of the image structure.\n%\n%  The format of the SetImage method is:\n%\n%      MagickBooleanType SetImageBackgroundColor(Image *image,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType SetImageBackgroundColor(Image *image,\n  ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  PixelInfo\n    background;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickCoreSignature);\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    return(MagickFalse);\n  ConformPixelInfo(image,&image->background_color,&background,exception);\n  /*\n    Set image background color.\n  */\n  status=MagickTrue;\n  image_view=AcquireAuthenticCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=QueueCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      SetPixelViaPixelInfo(image,&background,q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t I m a g e C h a n n e l M a s k                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageChannelMask() sets the image channel mask from the specified channel\n%  mask.\n%\n%  The format of the SetImageChannelMask method is:\n%\n%      ChannelType SetImageChannelMask(Image *image,\n%        const ChannelType channel_mask)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o channel_mask: the channel mask.\n%\n*/\nMagickExport ChannelType SetImageChannelMask(Image *image,\n  const ChannelType channel_mask)\n{\n  return(SetPixelChannelMask(image,channel_mask));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t I m a g e C o l o r                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageColor() set the entire image canvas to the specified color.\n%\n%  The format of the SetImageColor method is:\n%\n%      MagickBooleanType SetImageColor(Image *image,const PixelInfo *color,\n%        ExeptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o background: the image color.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType SetImageColor(Image *image,\n  const PixelInfo *color,ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickCoreSignature);\n  assert(color != (const PixelInfo *) NULL);\n  image->colorspace=color->colorspace;\n  image->alpha_trait=color->alpha_trait;\n  image->fuzz=color->fuzz;\n  image->depth=color->depth;\n  status=MagickTrue;\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(status) \\\n    magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=QueueCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      SetPixelViaPixelInfo(image,color,q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t I m a g e S t o r a g e C l a s s                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageStorageClass() sets the image class: DirectClass for true color\n%  images or PseudoClass for colormapped images.\n%\n%  The format of the SetImageStorageClass method is:\n%\n%      MagickBooleanType SetImageStorageClass(Image *image,\n%        const ClassType storage_class,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o storage_class:  The image class.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType SetImageStorageClass(Image *image,\n  const ClassType storage_class,ExceptionInfo *exception)\n{\n  image->storage_class=storage_class;\n  return(SyncImagePixelCache(image,exception));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t I m a g e E x t e n t                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageExtent() sets the image size (i.e. columns & rows).\n%\n%  The format of the SetImageExtent method is:\n%\n%      MagickBooleanType SetImageExtent(Image *image,const size_t columns,\n%        const size_t rows,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o columns:  The image width in pixels.\n%\n%    o rows:  The image height in pixels.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType SetImageExtent(Image *image,const size_t columns,\n  const size_t rows,ExceptionInfo *exception)\n{\n  if ((columns == 0) || (rows == 0))\n    return(MagickFalse);\n  image->columns=columns;\n  image->rows=rows;\n  if (image->depth > (8*sizeof(MagickSizeType)))\n    ThrowBinaryException(ImageError,\"ImageDepthNotSupported\",image->filename);\n  return(SyncImagePixelCache(image,exception));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   S e t I m a g e I n f o                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageInfo() initializes the 'magick' field of the ImageInfo structure.\n%  It is set to a type of image format based on the prefix or suffix of the\n%  filename.  For example, 'ps:image' returns PS indicating a Postscript image.\n%  JPEG is returned for this filename: 'image.jpg'.  The filename prefix has\n%  precendence over the suffix.  Use an optional index enclosed in brackets\n%  after a file name to specify a desired scene of a multi-resolution image\n%  format like Photo CD (e.g. img0001.pcd[4]).  A True (non-zero) return value\n%  indicates success.\n%\n%  The format of the SetImageInfo method is:\n%\n%      MagickBooleanType SetImageInfo(ImageInfo *image_info,\n%        const unsigned int frames,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o frames: the number of images you intend to write.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType SetImageInfo(ImageInfo *image_info,\n  const unsigned int frames,ExceptionInfo *exception)\n{\n  char\n    component[MagickPathExtent],\n    magic[MagickPathExtent],\n    *q;\n\n  const MagicInfo\n    *magic_info;\n\n  const MagickInfo\n    *magick_info;\n\n  ExceptionInfo\n    *sans_exception;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  register const char\n    *p;\n\n  ssize_t\n    count;\n\n  /*\n    Look for 'image.format' in filename.\n  */\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  *component='\\0';\n  GetPathComponent(image_info->filename,SubimagePath,component);\n  if (*component != '\\0')\n    {\n      /*\n        Look for scene specification (e.g. img0001.pcd[4]).\n      */\n      if (IsSceneGeometry(component,MagickFalse) == MagickFalse)\n        {\n          if (IsGeometry(component) != MagickFalse)\n            (void) CloneString(&image_info->extract,component);\n        }\n      else\n        {\n          size_t\n            first,\n            last;\n\n          (void) CloneString(&image_info->scenes,component);\n          image_info->scene=StringToUnsignedLong(image_info->scenes);\n          image_info->number_scenes=image_info->scene;\n          p=image_info->scenes;\n          for (q=(char *) image_info->scenes; *q != '\\0'; p++)\n          {\n            while ((isspace((int) ((unsigned char) *p)) != 0) || (*p == ','))\n              p++;\n            first=(size_t) strtol(p,&q,10);\n            last=first;\n            while (isspace((int) ((unsigned char) *q)) != 0)\n              q++;\n            if (*q == '-')\n              last=(size_t) strtol(q+1,&q,10);\n            if (first > last)\n              Swap(first,last);\n            if (first < image_info->scene)\n              image_info->scene=first;\n            if (last > image_info->number_scenes)\n              image_info->number_scenes=last;\n            p=q;\n          }\n          image_info->number_scenes-=image_info->scene-1;\n        }\n    }\n  *component='\\0';\n  if (*image_info->magick == '\\0')\n    GetPathComponent(image_info->filename,ExtensionPath,component);\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n  if (*component != '\\0')\n    if ((LocaleCompare(component,\"gz\") == 0) ||\n        (LocaleCompare(component,\"Z\") == 0) ||\n        (LocaleCompare(component,\"svgz\") == 0) ||\n        (LocaleCompare(component,\"wmz\") == 0))\n      {\n        char\n          path[MagickPathExtent];\n\n        (void) CopyMagickString(path,image_info->filename,MagickPathExtent);\n        path[strlen(path)-strlen(component)-1]='\\0';\n        GetPathComponent(path,ExtensionPath,component);\n      }\n#endif\n#if defined(MAGICKCORE_BZLIB_DELEGATE)\n  if (*component != '\\0')\n    if (LocaleCompare(component,\"bz2\") == 0)\n      {\n        char\n          path[MagickPathExtent];\n\n        (void) CopyMagickString(path,image_info->filename,MagickPathExtent);\n        path[strlen(path)-strlen(component)-1]='\\0';\n        GetPathComponent(path,ExtensionPath,component);\n      }\n#endif\n  image_info->affirm=MagickFalse;\n  sans_exception=AcquireExceptionInfo();\n  if (*component != '\\0')\n    {\n      MagickFormatType\n        format_type;\n\n      register ssize_t\n        i;\n\n      static const char\n        *format_type_formats[] =\n        {\n          \"AUTOTRACE\",\n          \"BROWSE\",\n          \"DCRAW\",\n          \"EDIT\",\n          \"LAUNCH\",\n          \"MPEG:DECODE\",\n          \"MPEG:ENCODE\",\n          \"PRINT\",\n          \"PS:ALPHA\",\n          \"PS:CMYK\",\n          \"PS:COLOR\",\n          \"PS:GRAY\",\n          \"PS:MONO\",\n          \"SCAN\",\n          \"SHOW\",\n          \"WIN\",\n          (char *) NULL\n        };\n\n      /*\n        User specified image format.\n      */\n      (void) CopyMagickString(magic,component,MagickPathExtent);\n      LocaleUpper(magic);\n      /*\n        Look for explicit image formats.\n      */\n      format_type=UndefinedFormatType;\n      magick_info=GetMagickInfo(magic,sans_exception);\n      if ((magick_info != (const MagickInfo *) NULL) &&\n          (magick_info->format_type != UndefinedFormatType))\n        format_type=magick_info->format_type;\n      i=0;\n      while ((format_type == UndefinedFormatType) &&\n             (format_type_formats[i] != (char *) NULL))\n      {\n        if ((*magic == *format_type_formats[i]) &&\n            (LocaleCompare(magic,format_type_formats[i]) == 0))\n          format_type=ExplicitFormatType;\n        i++;\n      }\n      if (format_type == UndefinedFormatType)\n        (void) CopyMagickString(image_info->magick,magic,MagickPathExtent);\n      else\n        if (format_type == ExplicitFormatType)\n          {\n            image_info->affirm=MagickTrue;\n            (void) CopyMagickString(image_info->magick,magic,MagickPathExtent);\n          }\n      if (LocaleCompare(magic,\"RGB\") == 0)\n        image_info->affirm=MagickFalse;  /* maybe SGI disguised as RGB */\n    }\n  /*\n    Look for explicit 'format:image' in filename.\n  */\n  *magic='\\0';\n  GetPathComponent(image_info->filename,MagickPath,magic);\n  if (*magic == '\\0')\n    (void) CopyMagickString(magic,image_info->magick,MagickPathExtent);\n  else\n    {\n      /*\n        User specified image format.\n      */\n      LocaleUpper(magic);\n      if (IsMagickConflict(magic) == MagickFalse)\n        {\n          (void) CopyMagickString(image_info->magick,magic,MagickPathExtent);\n          image_info->affirm=MagickTrue;\n        }\n    }\n  magick_info=GetMagickInfo(magic,sans_exception);\n  sans_exception=DestroyExceptionInfo(sans_exception);\n  if ((magick_info == (const MagickInfo *) NULL) ||\n      (GetMagickEndianSupport(magick_info) == MagickFalse))\n    image_info->endian=UndefinedEndian;\n  GetPathComponent(image_info->filename,CanonicalPath,component);\n  (void) CopyMagickString(image_info->filename,component,MagickPathExtent);\n  if ((image_info->adjoin != MagickFalse) && (frames > 1))\n    {\n      /*\n        Test for multiple image support (e.g. image%02d.png).\n      */\n      (void) InterpretImageFilename(image_info,(Image *) NULL,\n        image_info->filename,(int) image_info->scene,component,exception);\n      if ((LocaleCompare(component,image_info->filename) != 0) &&\n          (strchr(component,'%') == (char *) NULL))\n        image_info->adjoin=MagickFalse;\n    }\n  if ((image_info->adjoin != MagickFalse) && (frames > 0))\n    {\n      /*\n        Some image formats do not support multiple frames per file.\n      */\n      magick_info=GetMagickInfo(magic,exception);\n      if (magick_info != (const MagickInfo *) NULL)\n        if (GetMagickAdjoin(magick_info) == MagickFalse)\n          image_info->adjoin=MagickFalse;\n    }\n  if (image_info->affirm != MagickFalse)\n    return(MagickTrue);\n  if (frames == 0)\n    {\n      unsigned char\n        *magick;\n\n      size_t\n        magick_size;\n\n      /*\n        Determine the image format from the first few bytes of the file.\n      */\n      magick_size=GetMagicPatternExtent(exception);\n      if (magick_size == 0)\n        return(MagickFalse);\n      image=AcquireImage(image_info,exception);\n      (void) CopyMagickString(image->filename,image_info->filename,\n        MagickPathExtent);\n      status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n      if (status == MagickFalse)\n        {\n          image=DestroyImage(image);\n          return(MagickFalse);\n        }\n      if ((IsBlobSeekable(image) == MagickFalse) ||\n          (IsBlobExempt(image) != MagickFalse))\n        {\n          /*\n            Copy standard input or pipe to temporary file.\n          */\n          *component='\\0';\n          status=ImageToFile(image,component,exception);\n          (void) CloseBlob(image);\n          if (status == MagickFalse)\n            {\n              image=DestroyImage(image);\n              return(MagickFalse);\n            }\n          SetImageInfoFile(image_info,(FILE *) NULL);\n          (void) CopyMagickString(image->filename,component,MagickPathExtent);\n          status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n          if (status == MagickFalse)\n            {\n              image=DestroyImage(image);\n              return(MagickFalse);\n            }\n          (void) CopyMagickString(image_info->filename,component,\n            MagickPathExtent);\n          image_info->temporary=MagickTrue;\n        }\n      magick=(unsigned char *) AcquireMagickMemory(magick_size);\n      if (magick == (unsigned char *) NULL)\n        {\n          (void) CloseBlob(image);\n          image=DestroyImage(image);\n          return(MagickFalse);\n        }\n      (void) ResetMagickMemory(magick,0,magick_size);\n      count=ReadBlob(image,magick_size,magick);\n      (void) SeekBlob(image,-((MagickOffsetType) count),SEEK_CUR);\n      (void) CloseBlob(image);\n      image=DestroyImage(image);\n      /*\n        Check magic.xml configuration file.\n      */\n      sans_exception=AcquireExceptionInfo();\n      magic_info=GetMagicInfo(magick,(size_t) count,sans_exception);\n      magick=(unsigned char *) RelinquishMagickMemory(magick);\n      if ((magic_info != (const MagicInfo *) NULL) &&\n          (GetMagicName(magic_info) != (char *) NULL))\n        {\n          /*\n            Try to use magick_info that was determined earlier by the extension\n          */\n          if ((magick_info != (const MagickInfo *) NULL) &&\n              (GetMagickUseExtension(magick_info) != MagickFalse) &&\n              (LocaleCompare(magick_info->module,GetMagicName(\n                magic_info)) == 0))\n            (void) CopyMagickString(image_info->magick,magick_info->name,\n              MagickPathExtent);\n          else\n            {\n              (void) CopyMagickString(image_info->magick,GetMagicName(\n                magic_info),MagickPathExtent);\n              magick_info=GetMagickInfo(image_info->magick,sans_exception);\n            }\n          if ((magick_info == (const MagickInfo *) NULL) ||\n              (GetMagickEndianSupport(magick_info) == MagickFalse))\n            image_info->endian=UndefinedEndian;\n          sans_exception=DestroyExceptionInfo(sans_exception);\n          return(MagickTrue);\n        }\n      magick_info=GetMagickInfo(image_info->magick,sans_exception);\n      if ((magick_info == (const MagickInfo *) NULL) ||\n          (GetMagickEndianSupport(magick_info) == MagickFalse))\n        image_info->endian=UndefinedEndian;\n      sans_exception=DestroyExceptionInfo(sans_exception);\n    }\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t I m a g e I n f o B l o b                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageInfoBlob() sets the image info blob member.\n%\n%  The format of the SetImageInfoBlob method is:\n%\n%      void SetImageInfoBlob(ImageInfo *image_info,const void *blob,\n%        const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o blob: the blob.\n%\n%    o length: the blob length.\n%\n*/\nMagickExport void SetImageInfoBlob(ImageInfo *image_info,const void *blob,\n  const size_t length)\n{\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  image_info->blob=(void *) blob;\n  image_info->length=length;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t I m a g e I n f o F i l e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageInfoFile() sets the image info file member.\n%\n%  The format of the SetImageInfoFile method is:\n%\n%      void SetImageInfoFile(ImageInfo *image_info,FILE *file)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o file: the file.\n%\n*/\nMagickExport void SetImageInfoFile(ImageInfo *image_info,FILE *file)\n{\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  image_info->file=file;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t I m a g e M a s k                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageMask() associates a mask with the image.  The mask must be the same\n%  dimensions as the image.\n%\n%  The format of the SetImageMask method is:\n%\n%      MagickBooleanType SetImageMask(Image *image,const PixelMask type,\n%        const Image *mask,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o type: the mask type, ReadPixelMask or WritePixelMask.\n%\n%    o mask: the image mask.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType SetImageMask(Image *image,const PixelMask type,\n  const Image *mask,ExceptionInfo *exception)\n{\n  CacheView\n    *mask_view,\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  /*\n    Set image mask.\n  */\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickCoreSignature);\n  if (mask == (const Image *) NULL)\n    {\n      switch (type)\n      {\n        case WritePixelMask: image->write_mask=MagickFalse; break;\n        default: image->read_mask=MagickFalse; break;\n      }\n      return(SyncImagePixelCache(image,exception));\n    }\n  switch (type)\n  {\n    case WritePixelMask: image->write_mask=MagickTrue; break;\n    default: image->read_mask=MagickTrue; break;\n  }\n  if (SyncImagePixelCache(image,exception) == MagickFalse)\n    return(MagickFalse);\n  status=MagickTrue;\n  mask_view=AcquireVirtualCacheView(mask,exception);\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(status) \\\n    magick_threads(mask,image,1,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const Quantum\n      *magick_restrict p;\n\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(mask_view,0,y,mask->columns,1,exception);\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      MagickRealType\n        intensity;\n\n      intensity=GetPixelIntensity(mask,p);\n      switch (type)\n      {\n        case WritePixelMask:\n        {\n          SetPixelWriteMask(image,ClampToQuantum(QuantumRange-intensity),q);\n          break;\n        }\n        default:\n        {\n          SetPixelReadMask(image,ClampToQuantum(QuantumRange-intensity),q);\n          break;\n        }\n      }\n      p+=GetPixelChannels(mask);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  mask_view=DestroyCacheView(mask_view);\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     S e t I m a g e A l p h a                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageAlpha() sets the alpha levels of the image.\n%\n%  The format of the SetImageAlpha method is:\n%\n%      MagickBooleanType SetImageAlpha(Image *image,const Quantum alpha,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o Alpha: the level of transparency: 0 is fully opaque and QuantumRange is\n%      fully transparent.\n%\n*/\nMagickExport MagickBooleanType SetImageAlpha(Image *image,const Quantum alpha,\n  ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickCoreSignature);\n  image->alpha_trait=BlendPixelTrait;\n  status=MagickTrue;\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(status) \\\n    magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if (GetPixelReadMask(image,q) != 0)\n        SetPixelAlpha(image,alpha,q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t I m a g e V i r t u a l P i x e l M e t h o d                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageVirtualPixelMethod() sets the \"virtual pixels\" method for the\n%  image and returns the previous setting.  A virtual pixel is any pixel access\n%  that is outside the boundaries of the image cache.\n%\n%  The format of the SetImageVirtualPixelMethod() method is:\n%\n%      VirtualPixelMethod SetImageVirtualPixelMethod(Image *image,\n%        const VirtualPixelMethod virtual_pixel_method,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o virtual_pixel_method: choose the type of virtual pixel.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport VirtualPixelMethod SetImageVirtualPixelMethod(Image *image,\n  const VirtualPixelMethod virtual_pixel_method,ExceptionInfo *exception)\n{\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  return(SetPixelCacheVirtualMethod(image,virtual_pixel_method,exception));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     S m u s h I m a g e s                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SmushImages() takes all images from the current image pointer to the end\n%  of the image list and smushes them to each other top-to-bottom if the\n%  stack parameter is true, otherwise left-to-right.\n%\n%  The current gravity setting now effects how the image is justified in the\n%  final image.\n%\n%  The format of the SmushImages method is:\n%\n%      Image *SmushImages(const Image *images,const MagickBooleanType stack,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o images: the image sequence.\n%\n%    o stack: A value other than 0 stacks the images top-to-bottom.\n%\n%    o offset: minimum distance in pixels between images.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic ssize_t SmushXGap(const Image *smush_image,const Image *images,\n  const ssize_t offset,ExceptionInfo *exception)\n{\n  CacheView\n    *left_view,\n    *right_view;\n\n  const Image\n    *left_image,\n    *right_image;\n\n  RectangleInfo\n    left_geometry,\n    right_geometry;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    y;\n\n  size_t\n    gap;\n\n  ssize_t\n    x;\n\n  if (images->previous == (Image *) NULL)\n    return(0);\n  right_image=images;\n  SetGeometry(smush_image,&right_geometry);\n  GravityAdjustGeometry(right_image->columns,right_image->rows,\n    right_image->gravity,&right_geometry);\n  left_image=images->previous;\n  SetGeometry(smush_image,&left_geometry);\n  GravityAdjustGeometry(left_image->columns,left_image->rows,\n    left_image->gravity,&left_geometry);\n  gap=right_image->columns;\n  left_view=AcquireVirtualCacheView(left_image,exception);\n  right_view=AcquireVirtualCacheView(right_image,exception);\n  for (y=0; y < (ssize_t) smush_image->rows; y++)\n  {\n    for (x=(ssize_t) left_image->columns-1; x > 0; x--)\n    {\n      p=GetCacheViewVirtualPixels(left_view,x,left_geometry.y+y,1,1,exception);\n      if ((p == (const Quantum *) NULL) ||\n          (GetPixelAlpha(left_image,p) != TransparentAlpha) ||\n          ((left_image->columns-x-1) >= gap))\n        break;\n    }\n    i=(ssize_t) left_image->columns-x-1;\n    for (x=0; x < (ssize_t) right_image->columns; x++)\n    {\n      p=GetCacheViewVirtualPixels(right_view,x,right_geometry.y+y,1,1,\n        exception);\n      if ((p == (const Quantum *) NULL) ||\n          (GetPixelAlpha(right_image,p) != TransparentAlpha) ||\n          ((x+i) >= (ssize_t) gap))\n        break;\n    }\n    if ((x+i) < (ssize_t) gap)\n      gap=(size_t) (x+i);\n  }\n  right_view=DestroyCacheView(right_view);\n  left_view=DestroyCacheView(left_view);\n  if (y < (ssize_t) smush_image->rows)\n    return(offset);\n  return((ssize_t) gap-offset);\n}\n\nstatic ssize_t SmushYGap(const Image *smush_image,const Image *images,\n  const ssize_t offset,ExceptionInfo *exception)\n{\n  CacheView\n    *bottom_view,\n    *top_view;\n\n  const Image\n    *bottom_image,\n    *top_image;\n\n  RectangleInfo\n    bottom_geometry,\n    top_geometry;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  size_t\n    gap;\n\n  ssize_t\n    y;\n\n  if (images->previous == (Image *) NULL)\n    return(0);\n  bottom_image=images;\n  SetGeometry(smush_image,&bottom_geometry);\n  GravityAdjustGeometry(bottom_image->columns,bottom_image->rows,\n    bottom_image->gravity,&bottom_geometry);\n  top_image=images->previous;\n  SetGeometry(smush_image,&top_geometry);\n  GravityAdjustGeometry(top_image->columns,top_image->rows,top_image->gravity,\n    &top_geometry);\n  gap=bottom_image->rows;\n  top_view=AcquireVirtualCacheView(top_image,exception);\n  bottom_view=AcquireVirtualCacheView(bottom_image,exception);\n  for (x=0; x < (ssize_t) smush_image->columns; x++)\n  {\n    for (y=(ssize_t) top_image->rows-1; y > 0; y--)\n    {\n      p=GetCacheViewVirtualPixels(top_view,top_geometry.x+x,y,1,1,exception);\n      if ((p == (const Quantum *) NULL) ||\n          (GetPixelAlpha(top_image,p) != TransparentAlpha) ||\n          ((top_image->rows-y-1) >= gap))\n        break;\n    }\n    i=(ssize_t) top_image->rows-y-1;\n    for (y=0; y < (ssize_t) bottom_image->rows; y++)\n    {\n      p=GetCacheViewVirtualPixels(bottom_view,bottom_geometry.x+x,y,1,1,\n        exception);\n      if ((p == (const Quantum *) NULL) ||\n          (GetPixelAlpha(bottom_image,p) != TransparentAlpha) ||\n          ((y+i) >= (ssize_t) gap))\n        break;\n    }\n    if ((y+i) < (ssize_t) gap)\n      gap=(size_t) (y+i);\n  }\n  bottom_view=DestroyCacheView(bottom_view);\n  top_view=DestroyCacheView(top_view);\n  if (x < (ssize_t) smush_image->columns)\n    return(offset);\n  return((ssize_t) gap-offset);\n}\n\nMagickExport Image *SmushImages(const Image *images,\n  const MagickBooleanType stack,const ssize_t offset,ExceptionInfo *exception)\n{\n#define SmushImageTag  \"Smush/Image\"\n\n  const Image\n    *image;\n\n  Image\n    *smush_image;\n\n  MagickBooleanType\n    proceed,\n    status;\n\n  MagickOffsetType\n    n;\n\n  PixelTrait\n    alpha_trait;\n\n  RectangleInfo\n    geometry;\n\n  register const Image\n    *next;\n\n  size_t\n    height,\n    number_images,\n    width;\n\n  ssize_t\n    x_offset,\n    y_offset;\n\n  /*\n    Compute maximum area of smushed area.\n  */\n  assert(images != (Image *) NULL);\n  assert(images->signature == MagickCoreSignature);\n  if (images->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",images->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=images;\n  alpha_trait=image->alpha_trait;\n  number_images=1;\n  width=image->columns;\n  height=image->rows;\n  next=GetNextImageInList(image);\n  for ( ; next != (Image *) NULL; next=GetNextImageInList(next))\n  {\n    if (next->alpha_trait != UndefinedPixelTrait)\n      alpha_trait=BlendPixelTrait;\n    number_images++;\n    if (stack != MagickFalse)\n      {\n        if (next->columns > width)\n          width=next->columns;\n        height+=next->rows;\n        if (next->previous != (Image *) NULL)\n          height+=offset;\n        continue;\n      }\n    width+=next->columns;\n    if (next->previous != (Image *) NULL)\n      width+=offset;\n    if (next->rows > height)\n      height=next->rows;\n  }\n  /*\n    Smush images.\n  */\n  smush_image=CloneImage(image,width,height,MagickTrue,exception);\n  if (smush_image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(smush_image,DirectClass,exception) == MagickFalse)\n    {\n      smush_image=DestroyImage(smush_image);\n      return((Image *) NULL);\n    }\n  smush_image->alpha_trait=alpha_trait;\n  (void) SetImageBackgroundColor(smush_image,exception);\n  status=MagickTrue;\n  x_offset=0;\n  y_offset=0;\n  for (n=0; n < (MagickOffsetType) number_images; n++)\n  {\n    SetGeometry(smush_image,&geometry);\n    GravityAdjustGeometry(image->columns,image->rows,image->gravity,&geometry);\n    if (stack != MagickFalse)\n      {\n        x_offset-=geometry.x;\n        y_offset-=SmushYGap(smush_image,image,offset,exception);\n      }\n    else\n      {\n        x_offset-=SmushXGap(smush_image,image,offset,exception);\n        y_offset-=geometry.y;\n      }\n    status=CompositeImage(smush_image,image,OverCompositeOp,MagickTrue,x_offset,\n      y_offset,exception);\n    proceed=SetImageProgress(image,SmushImageTag,n,number_images);\n    if (proceed == MagickFalse)\n      break;\n    if (stack == MagickFalse)\n      {\n        x_offset+=(ssize_t) image->columns;\n        y_offset=0;\n      }\n    else\n      {\n        x_offset=0;\n        y_offset+=(ssize_t) image->rows;\n      }\n    image=GetNextImageInList(image);\n  }\n  if (stack == MagickFalse)\n    smush_image->columns=(size_t) x_offset;\n  else\n    smush_image->rows=(size_t) y_offset;\n  if (status == MagickFalse)\n    smush_image=DestroyImage(smush_image);\n  return(smush_image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S t r i p I m a g e                                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  StripImage() strips an image of all profiles and comments.\n%\n%  The format of the StripImage method is:\n%\n%      MagickBooleanType StripImage(Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType StripImage(Image *image,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  (void) exception;\n  DestroyImageProfiles(image);\n  (void) DeleteImageProperty(image,\"comment\");\n  (void) DeleteImageProperty(image,\"date:create\");\n  (void) DeleteImageProperty(image,\"date:modify\");\n  status=SetImageArtifact(image,\"png:exclude-chunk\",\n    \"bKGD,cHRM,EXIF,gAMA,iCCP,iTXt,sRGB,tEXt,zCCP,zTXt,date\");\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   S y n c I m a g e                                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SyncImage() initializes the red, green, and blue intensities of each pixel\n%  as defined by the colormap index.\n%\n%  The format of the SyncImage method is:\n%\n%      MagickBooleanType SyncImage(Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline Quantum PushColormapIndex(Image *image,const Quantum index,\n  MagickBooleanType *range_exception)\n{\n  if ((size_t) index < image->colors)\n    return(index);\n  *range_exception=MagickTrue;\n  return((Quantum) 0);\n}\n\nMagickExport MagickBooleanType SyncImage(Image *image,ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    range_exception,\n    status,\n    taint;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickCoreSignature);\n  if (image->storage_class == DirectClass)\n    return(MagickFalse);\n  range_exception=MagickFalse;\n  status=MagickTrue;\n  taint=image->taint;\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(range_exception,status) \\\n    magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    Quantum\n      index;\n\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      index=PushColormapIndex(image,GetPixelIndex(image,q),&range_exception);\n      SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  image_view=DestroyCacheView(image_view);\n  image->taint=taint;\n  if ((image->ping == MagickFalse) && (range_exception != MagickFalse))\n    (void) ThrowMagickException(exception,GetMagickModule(),\n      CorruptImageWarning,\"InvalidColormapIndex\",\"`%s'\",image->filename);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S y n c I m a g e S e t t i n g s                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SyncImageSettings() syncs any image_info global options into per-image\n%  attributes.\n%\n%  Note: in IMv6 free form 'options' were always mapped into 'artifacts', so\n%  that operations and coders can find such settings.  In IMv7 if a desired\n%  per-image artifact is not set, then it will directly look for a global\n%  option as a fallback, as such this copy is no longer needed, only the\n%  link set up.\n%\n%  The format of the SyncImageSettings method is:\n%\n%      MagickBooleanType SyncImageSettings(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%      MagickBooleanType SyncImagesSettings(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nMagickExport MagickBooleanType SyncImagesSettings(ImageInfo *image_info,\n  Image *images,ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(images != (Image *) NULL);\n  assert(images->signature == MagickCoreSignature);\n  if (images->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",images->filename);\n  image=images;\n  for ( ; image != (Image *) NULL; image=GetNextImageInList(image))\n    (void) SyncImageSettings(image_info,image,exception);\n  (void) DeleteImageOption(image_info,\"page\");\n  return(MagickTrue);\n}\n\nMagickExport MagickBooleanType SyncImageSettings(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  const char\n    *option;\n\n  GeometryInfo\n    geometry_info;\n\n  MagickStatusType\n    flags;\n\n  ResolutionType\n    units;\n\n  /*\n    Sync image options.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  option=GetImageOption(image_info,\"alpha-color\");\n  if (option != (const char *) NULL)\n    (void) QueryColorCompliance(option,AllCompliance,&image->alpha_color,\n      exception);\n  option=GetImageOption(image_info,\"background\");\n  if (option != (const char *) NULL)\n    (void) QueryColorCompliance(option,AllCompliance,&image->background_color,\n      exception);\n  option=GetImageOption(image_info,\"black-point-compensation\");\n  if (option != (const char *) NULL)\n    image->black_point_compensation=(MagickBooleanType) ParseCommandOption(\n      MagickBooleanOptions,MagickFalse,option);\n  option=GetImageOption(image_info,\"blue-primary\");\n  if (option != (const char *) NULL)\n    {\n      flags=ParseGeometry(option,&geometry_info);\n      image->chromaticity.blue_primary.x=geometry_info.rho;\n      image->chromaticity.blue_primary.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->chromaticity.blue_primary.y=image->chromaticity.blue_primary.x;\n    }\n  option=GetImageOption(image_info,\"bordercolor\");\n  if (option != (const char *) NULL)\n    (void) QueryColorCompliance(option,AllCompliance,&image->border_color,\n      exception);\n  /* FUTURE: do not sync compose to per-image compose setting here */\n  option=GetImageOption(image_info,\"compose\");\n  if (option != (const char *) NULL)\n    image->compose=(CompositeOperator) ParseCommandOption(MagickComposeOptions,\n      MagickFalse,option);\n  /* -- */\n  option=GetImageOption(image_info,\"compress\");\n  if (option != (const char *) NULL)\n    image->compression=(CompressionType) ParseCommandOption(\n      MagickCompressOptions,MagickFalse,option);\n  option=GetImageOption(image_info,\"debug\");\n  if (option != (const char *) NULL)\n    image->debug=(MagickBooleanType) ParseCommandOption(MagickBooleanOptions,\n      MagickFalse,option);\n  option=GetImageOption(image_info,\"density\");\n  if (option != (const char *) NULL)\n    {\n      GeometryInfo\n        geometry_info;\n\n      flags=ParseGeometry(option,&geometry_info);\n      image->resolution.x=geometry_info.rho;\n      image->resolution.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->resolution.y=image->resolution.x;\n    }\n  option=GetImageOption(image_info,\"depth\");\n  if (option != (const char *) NULL)\n    image->depth=StringToUnsignedLong(option);\n  option=GetImageOption(image_info,\"endian\");\n  if (option != (const char *) NULL)\n    image->endian=(EndianType) ParseCommandOption(MagickEndianOptions,\n      MagickFalse,option);\n  option=GetImageOption(image_info,\"filter\");\n  if (option != (const char *) NULL)\n    image->filter=(FilterType) ParseCommandOption(MagickFilterOptions,\n      MagickFalse,option);\n  option=GetImageOption(image_info,\"fuzz\");\n  if (option != (const char *) NULL)\n    image->fuzz=StringToDoubleInterval(option,(double) QuantumRange+1.0);\n  option=GetImageOption(image_info,\"gravity\");\n  if (option != (const char *) NULL)\n    image->gravity=(GravityType) ParseCommandOption(MagickGravityOptions,\n      MagickFalse,option);\n  option=GetImageOption(image_info,\"green-primary\");\n  if (option != (const char *) NULL)\n    {\n      flags=ParseGeometry(option,&geometry_info);\n      image->chromaticity.green_primary.x=geometry_info.rho;\n      image->chromaticity.green_primary.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->chromaticity.green_primary.y=image->chromaticity.green_primary.x;\n    }\n  option=GetImageOption(image_info,\"intent\");\n  if (option != (const char *) NULL)\n    image->rendering_intent=(RenderingIntent) ParseCommandOption(\n      MagickIntentOptions,MagickFalse,option);\n  option=GetImageOption(image_info,\"intensity\");\n  if (option != (const char *) NULL)\n    image->intensity=(PixelIntensityMethod) ParseCommandOption(\n      MagickPixelIntensityOptions,MagickFalse,option);\n  option=GetImageOption(image_info,\"interlace\");\n  if (option != (const char *) NULL)\n    image->interlace=(InterlaceType) ParseCommandOption(MagickInterlaceOptions,\n      MagickFalse,option);\n  option=GetImageOption(image_info,\"interpolate\");\n  if (option != (const char *) NULL)\n    image->interpolate=(PixelInterpolateMethod) ParseCommandOption(\n      MagickInterpolateOptions,MagickFalse,option);\n  option=GetImageOption(image_info,\"loop\");\n  if (option != (const char *) NULL)\n    image->iterations=StringToUnsignedLong(option);\n  option=GetImageOption(image_info,\"orient\");\n  if (option != (const char *) NULL)\n    image->orientation=(OrientationType) ParseCommandOption(\n      MagickOrientationOptions,MagickFalse,option);\n  option=GetImageOption(image_info,\"page\");\n  if (option != (const char *) NULL)\n    {\n      char\n        *geometry;\n\n      geometry=GetPageGeometry(option);\n      flags=ParseAbsoluteGeometry(geometry,&image->page);\n      geometry=DestroyString(geometry);\n    }\n  option=GetImageOption(image_info,\"quality\");\n  if (option != (const char *) NULL)\n    image->quality=StringToUnsignedLong(option);\n  option=GetImageOption(image_info,\"red-primary\");\n  if (option != (const char *) NULL)\n    {\n      flags=ParseGeometry(option,&geometry_info);\n      image->chromaticity.red_primary.x=geometry_info.rho;\n      image->chromaticity.red_primary.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->chromaticity.red_primary.y=image->chromaticity.red_primary.x;\n    }\n  if (image_info->quality != UndefinedCompressionQuality)\n    image->quality=image_info->quality;\n  option=GetImageOption(image_info,\"scene\");\n  if (option != (const char *) NULL)\n    image->scene=StringToUnsignedLong(option);\n  option=GetImageOption(image_info,\"taint\");\n  if (option != (const char *) NULL)\n    image->taint=(MagickBooleanType) ParseCommandOption(MagickBooleanOptions,\n      MagickFalse,option);\n  option=GetImageOption(image_info,\"tile-offset\");\n  if (option != (const char *) NULL)\n    {\n      char\n        *geometry;\n\n      geometry=GetPageGeometry(option);\n      flags=ParseAbsoluteGeometry(geometry,&image->tile_offset);\n      geometry=DestroyString(geometry);\n    }\n  option=GetImageOption(image_info,\"transparent-color\");\n  if (option != (const char *) NULL)\n    (void) QueryColorCompliance(option,AllCompliance,&image->transparent_color,\n      exception);\n  option=GetImageOption(image_info,\"type\");\n  if (option != (const char *) NULL)\n    image->type=(ImageType) ParseCommandOption(MagickTypeOptions,MagickFalse,\n      option);\n  option=GetImageOption(image_info,\"units\");\n  units=image_info->units;\n  if (option != (const char *) NULL)\n    units=(ResolutionType) ParseCommandOption(MagickResolutionOptions,\n      MagickFalse,option);\n  if (units != UndefinedResolution)\n    {\n      if (image->units != units)\n        switch (image->units)\n        {\n          case PixelsPerInchResolution:\n          {\n            if (units == PixelsPerCentimeterResolution)\n              {\n                image->resolution.x/=2.54;\n                image->resolution.y/=2.54;\n              }\n            break;\n          }\n          case PixelsPerCentimeterResolution:\n          {\n            if (units == PixelsPerInchResolution)\n              {\n                image->resolution.x=(double) ((size_t) (100.0*2.54*\n                  image->resolution.x+0.5))/100.0;\n                image->resolution.y=(double) ((size_t) (100.0*2.54*\n                  image->resolution.y+0.5))/100.0;\n              }\n            break;\n          }\n          default:\n            break;\n        }\n      image->units=units;\n    }\n  option=GetImageOption(image_info,\"virtual-pixel\");\n  if (option != (const char *) NULL)\n    (void) SetImageVirtualPixelMethod(image,(VirtualPixelMethod)\n      ParseCommandOption(MagickVirtualPixelOptions,MagickFalse,option),\n      exception);\n  option=GetImageOption(image_info,\"white-point\");\n  if (option != (const char *) NULL)\n    {\n      flags=ParseGeometry(option,&geometry_info);\n      image->chromaticity.white_point.x=geometry_info.rho;\n      image->chromaticity.white_point.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->chromaticity.white_point.y=image->chromaticity.white_point.x;\n    }\n  /*\n    Pointer to allow the lookup of pre-image artifact will fallback to a global\n    option setting/define.  This saves a lot of duplication of global options\n    into per-image artifacts, while ensuring only specifically set per-image\n    artifacts are preserved when parenthesis ends.\n  */\n  if (image->image_info != (ImageInfo *) NULL)\n    image->image_info=DestroyImageInfo(image->image_info);\n  image->image_info=CloneImageInfo(image_info);\n  return(MagickTrue);\n}\n", "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                            W   W  PPPP    GGGG                              %\n%                            W   W  P   P  G                                  %\n%                            W W W  PPPP   G GGG                              %\n%                            WW WW  P      G   G                              %\n%                            W   W  P       GGG                               %\n%                                                                             %\n%                                                                             %\n%                       Read WordPerfect Image Format                         %\n%                                                                             %\n%                              Software Design                                %\n%                              Jaroslav Fojtik                                %\n%                                 June 2000                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colormap-private.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/distort.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magic.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/transform.h\"\n#include \"MagickCore/utility.h\"\n#include \"MagickCore/utility-private.h\"\n\f\ntypedef struct\n   {\n   unsigned char Red;\n   unsigned char Blue;\n   unsigned char Green;\n   } RGB_Record;\n\n/* Default palette for WPG level 1 */\nstatic const RGB_Record WPG1_Palette[256]={\n{  0,  0,  0},    {  0,  0,168},\n{  0,168,  0},    {  0,168,168},\n{168,  0,  0},    {168,  0,168},\n{168, 84,  0},    {168,168,168},\n{ 84, 84, 84},    { 84, 84,252},\n{ 84,252, 84},    { 84,252,252},\n{252, 84, 84},    {252, 84,252},\n{252,252, 84},    {252,252,252},  /*16*/\n{  0,  0,  0},    { 20, 20, 20},\n{ 32, 32, 32},    { 44, 44, 44},\n{ 56, 56, 56},    { 68, 68, 68},\n{ 80, 80, 80},    { 96, 96, 96},\n{112,112,112},    {128,128,128},\n{144,144,144},    {160,160,160},\n{180,180,180},    {200,200,200},\n{224,224,224},    {252,252,252},  /*32*/\n{  0,  0,252},    { 64,  0,252},\n{124,  0,252},    {188,  0,252},\n{252,  0,252},    {252,  0,188},\n{252,  0,124},    {252,  0, 64},\n{252,  0,  0},    {252, 64,  0},\n{252,124,  0},    {252,188,  0},\n{252,252,  0},    {188,252,  0},\n{124,252,  0},    { 64,252,  0},  /*48*/\n{  0,252,  0},    {  0,252, 64},\n{  0,252,124},    {  0,252,188},\n{  0,252,252},    {  0,188,252},\n{  0,124,252},    {  0, 64,252},\n{124,124,252},    {156,124,252},\n{188,124,252},    {220,124,252},\n{252,124,252},    {252,124,220},\n{252,124,188},    {252,124,156},  /*64*/\n{252,124,124},    {252,156,124},\n{252,188,124},    {252,220,124},\n{252,252,124},    {220,252,124},\n{188,252,124},    {156,252,124},\n{124,252,124},    {124,252,156},\n{124,252,188},    {124,252,220},\n{124,252,252},    {124,220,252},\n{124,188,252},    {124,156,252},  /*80*/\n{180,180,252},    {196,180,252},\n{216,180,252},    {232,180,252},\n{252,180,252},    {252,180,232},\n{252,180,216},    {252,180,196},\n{252,180,180},    {252,196,180},\n{252,216,180},    {252,232,180},\n{252,252,180},    {232,252,180},\n{216,252,180},    {196,252,180},  /*96*/\n{180,220,180},    {180,252,196},\n{180,252,216},    {180,252,232},\n{180,252,252},    {180,232,252},\n{180,216,252},    {180,196,252},\n{0,0,112},    {28,0,112},\n{56,0,112},    {84,0,112},\n{112,0,112},    {112,0,84},\n{112,0,56},    {112,0,28},  /*112*/\n{112,0,0},    {112,28,0},\n{112,56,0},    {112,84,0},\n{112,112,0},    {84,112,0},\n{56,112,0},    {28,112,0},\n{0,112,0},    {0,112,28},\n{0,112,56},    {0,112,84},\n{0,112,112},    {0,84,112},\n{0,56,112},    {0,28,112},   /*128*/\n{56,56,112},    {68,56,112},\n{84,56,112},    {96,56,112},\n{112,56,112},    {112,56,96},\n{112,56,84},    {112,56,68},\n{112,56,56},    {112,68,56},\n{112,84,56},    {112,96,56},\n{112,112,56},    {96,112,56},\n{84,112,56},    {68,112,56},  /*144*/\n{56,112,56},    {56,112,69},\n{56,112,84},    {56,112,96},\n{56,112,112},    {56,96,112},\n{56,84,112},    {56,68,112},\n{80,80,112},    {88,80,112},\n{96,80,112},    {104,80,112},\n{112,80,112},    {112,80,104},\n{112,80,96},    {112,80,88},  /*160*/\n{112,80,80},    {112,88,80},\n{112,96,80},    {112,104,80},\n{112,112,80},    {104,112,80},\n{96,112,80},    {88,112,80},\n{80,112,80},    {80,112,88},\n{80,112,96},    {80,112,104},\n{80,112,112},    {80,114,112},\n{80,96,112},    {80,88,112},  /*176*/\n{0,0,64},    {16,0,64},\n{32,0,64},    {48,0,64},\n{64,0,64},    {64,0,48},\n{64,0,32},    {64,0,16},\n{64,0,0},    {64,16,0},\n{64,32,0},    {64,48,0},\n{64,64,0},    {48,64,0},\n{32,64,0},    {16,64,0},  /*192*/\n{0,64,0},    {0,64,16},\n{0,64,32},    {0,64,48},\n{0,64,64},    {0,48,64},\n{0,32,64},    {0,16,64},\n{32,32,64},    {40,32,64},\n{48,32,64},    {56,32,64},\n{64,32,64},    {64,32,56},\n{64,32,48},    {64,32,40},  /*208*/\n{64,32,32},    {64,40,32},\n{64,48,32},    {64,56,32},\n{64,64,32},    {56,64,32},\n{48,64,32},    {40,64,32},\n{32,64,32},    {32,64,40},\n{32,64,48},    {32,64,56},\n{32,64,64},    {32,56,64},\n{32,48,64},    {32,40,64},  /*224*/\n{44,44,64},    {48,44,64},\n{52,44,64},    {60,44,64},\n{64,44,64},    {64,44,60},\n{64,44,52},    {64,44,48},\n{64,44,44},    {64,48,44},\n{64,52,44},    {64,60,44},\n{64,64,44},    {60,64,44},\n{52,64,44},    {48,64,44},  /*240*/\n{44,64,44},    {44,64,48},\n{44,64,52},    {44,64,60},\n{44,64,64},    {44,60,64},\n{44,55,64},    {44,48,64},\n{0,0,0},    {0,0,0},\n{0,0,0},    {0,0,0},\n{0,0,0},    {0,0,0},\n{0,0,0},    {0,0,0}    /*256*/\n};\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s W P G                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsWPG() returns True if the image format type, identified by the magick\n%  string, is WPG.\n%\n%  The format of the IsWPG method is:\n%\n%      unsigned int IsWPG(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o status:  Method IsWPG returns True if the image format type is WPG.\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic unsigned int IsWPG(const unsigned char *magick,const size_t length)\n{\n  if (length < 4)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\377WPC\",4) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n\nstatic void Rd_WP_DWORD(Image *image,size_t *d)\n{\n  unsigned char\n    b;\n\n  b=ReadBlobByte(image);\n  *d=b;\n  if (b < 0xFFU)\n    return;\n  b=ReadBlobByte(image);\n  *d=(size_t) b;\n  b=ReadBlobByte(image);\n  *d+=(size_t) b*256l;\n  if (*d < 0x8000)\n    return;\n  *d=(*d & 0x7FFF) << 16;\n  b=ReadBlobByte(image);\n  *d+=(size_t) b;\n  b=ReadBlobByte(image);\n  *d+=(size_t) b*256l;\n  return;\n}\n\nstatic void InsertRow(Image *image,unsigned char *p,ssize_t y,int bpp,\n  ExceptionInfo *exception)\n{\n  int\n    bit;\n\n  Quantum\n    index;\n\n  register Quantum\n    *q;\n\n  ssize_t\n    x;\n\n  switch (bpp)\n    {\n    case 1:  /* Convert bitmap scanline. */\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n        {\n          for (bit=0; bit < 8; bit++)\n          {\n            index=((*p) & (0x80 >> bit) ? 0x01 : 0x00);\n            SetPixelIndex(image,index,q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            q+=GetPixelChannels(image);\n          }\n          p++;\n        }\n        if ((image->columns % 8) != 0)\n          {\n            for (bit=0; bit < (ssize_t) (image->columns % 8); bit++)\n            {\n              index=((*p) & (0x80 >> bit) ? 0x01 : 0x00);\n              SetPixelIndex(image,index,q);\n              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n              q+=GetPixelChannels(image);\n            }\n            p++;\n          }\n        if (!SyncAuthenticPixels(image,exception))\n          break;\n        break;\n      }\n    case 2:  /* Convert PseudoColor scanline. */\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < ((ssize_t) image->columns-3); x+=4)\n        {\n            index=ConstrainColormapIndex(image,(*p >> 6) & 0x3,exception);\n            SetPixelIndex(image,index,q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            q+=GetPixelChannels(image);\n            index=ConstrainColormapIndex(image,(*p >> 4) & 0x3,exception);\n            SetPixelIndex(image,index,q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            q+=GetPixelChannels(image);\n            index=ConstrainColormapIndex(image,(*p >> 2) & 0x3,exception);\n            SetPixelIndex(image,index,q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            q+=GetPixelChannels(image);\n            index=ConstrainColormapIndex(image,(*p) & 0x3,exception);\n            SetPixelIndex(image,index,q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            q+=GetPixelChannels(image);\n            p++;\n        }\n       if ((image->columns % 4) != 0)\n          {\n            index=ConstrainColormapIndex(image,(*p >> 6) & 0x3,exception);\n            SetPixelIndex(image,index,q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            q+=GetPixelChannels(image);\n            if ((image->columns % 4) > 1)\n              {\n                index=ConstrainColormapIndex(image,(*p >> 4) & 0x3,exception);\n                SetPixelIndex(image,index,q);\n                SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n                q+=GetPixelChannels(image);\n                if ((image->columns % 4) > 2)\n                  {\n                    index=ConstrainColormapIndex(image,(*p >> 2) & 0x3,\n                      exception);\n                    SetPixelIndex(image,index,q);\n                    SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n                    q+=GetPixelChannels(image);\n                  }\n              }\n            p++;\n          }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        break;\n      }\n \n    case 4:  /* Convert PseudoColor scanline. */\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < ((ssize_t) image->columns-1); x+=2)\n          { \n            index=ConstrainColormapIndex(image,(*p >> 4) & 0x0f,exception);\n            SetPixelIndex(image,index,q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            q+=GetPixelChannels(image);\n            index=ConstrainColormapIndex(image,(*p) & 0x0f,exception);\n            SetPixelIndex(image,index,q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            p++;\n            q+=GetPixelChannels(image);\n          }\n        if ((image->columns % 2) != 0)\n          {\n            index=ConstrainColormapIndex(image,(*p >> 4) & 0x0f,exception);\n            SetPixelIndex(image,index,q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            p++;\n            q+=GetPixelChannels(image);\n          }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        break;\n      }\n    case 8: /* Convert PseudoColor scanline. */\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL) break;\n\n        for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            index=ConstrainColormapIndex(image,*p,exception);\n            SetPixelIndex(image,index,q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            p++;\n            q+=GetPixelChannels(image);\n          }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n      }\n      break;\n     \n    case 24:     /*  Convert DirectColor scanline.  */\n      q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n      if (q == (Quantum *) NULL)\n        break;\n      for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n          SetPixelGreen(image,ScaleCharToQuantum(*p++),q);\n          SetPixelBlue(image,ScaleCharToQuantum(*p++),q);\n          q+=GetPixelChannels(image);\n        }\n      if (!SyncAuthenticPixels(image,exception))\n        break;\n      break;\n    }\n}\n\n\n/* Helper for WPG1 raster reader. */\n#define InsertByte(b) \\\n{ \\\n  BImgBuff[x]=b; \\\n  x++; \\\n  if((ssize_t) x>=ldblk) \\\n  { \\\n    InsertRow(image,BImgBuff,(ssize_t) y,bpp,exception); \\\n    x=0; \\\n    y++; \\\n    } \\\n}\n/* WPG1 raster reader. */\nstatic int UnpackWPGRaster(Image *image,int bpp,ExceptionInfo *exception)\n{\n  int\n    x,\n    y,\n    i;\n\n  unsigned char\n    bbuf,\n    *BImgBuff,\n    RunCount;\n\n  ssize_t\n    ldblk;\n\n  x=0;\n  y=0;\n\n  ldblk=(ssize_t) ((bpp*image->columns+7)/8);\n  BImgBuff=(unsigned char *) AcquireQuantumMemory((size_t) ldblk,\n    8*sizeof(*BImgBuff));\n  if(BImgBuff==NULL) return(-2);\n\n  while(y<(ssize_t) image->rows)\n    {\n      int\n        c;\n\n      c=ReadBlobByte(image);\n      if (c == EOF)\n        break;\n      bbuf=(unsigned char) c;\n      RunCount=bbuf & 0x7F;\n      if(bbuf & 0x80)\n        {\n          if(RunCount)  /* repeat next byte runcount * */\n            {\n              bbuf=ReadBlobByte(image);\n              for(i=0;i<(int) RunCount;i++) InsertByte(bbuf);\n            }\n          else {  /* read next byte as RunCount; repeat 0xFF runcount* */\n            c=ReadBlobByte(image);\n            if (c < 0)\n              break;\n            RunCount=(unsigned char) c;\n            for(i=0;i<(int) RunCount;i++) InsertByte(0xFF);\n          }\n        }\n      else {\n        if(RunCount)   /* next runcount byte are readed directly */\n          {\n            for(i=0;i < (int) RunCount;i++)\n              {\n                bbuf=ReadBlobByte(image);\n                InsertByte(bbuf);\n              }\n          }\n        else {  /* repeat previous line runcount* */\n          c=ReadBlobByte(image);\n          if (c < 0)\n            break;\n          RunCount=(unsigned char) c;\n          if(x) {    /* attempt to duplicate row from x position: */\n            /* I do not know what to do here */\n            BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);\n            return(-3);\n          }\n          for(i=0;i < (int) RunCount;i++)\n            {\n              x=0;\n              y++;    /* Here I need to duplicate previous row RUNCOUNT* */\n              if(y<2) continue;\n              if(y>(ssize_t) image->rows)\n                {\n                  BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);\n                  return(-4);\n                }\n              InsertRow(image,BImgBuff,y-1,bpp,exception);\n            }\n        }\n      }\n      if (EOFBlob(image) != MagickFalse)\n        break;\n    }\n  BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);\n  return(y <(ssize_t) image->rows ? -5 : 0);\n}\n\n\n/* Helper for WPG2 reader. */\n#define InsertByte6(b) \\\n{ \\\nDisableMSCWarning(4310) \\\n  if(XorMe)\\\n    BImgBuff[x] = (unsigned char)~b;\\\n  else\\\n    BImgBuff[x] = b;\\\nRestoreMSCWarning \\\n  x++; \\\n  if((ssize_t) x >= ldblk) \\\n  { \\\n    InsertRow(image,BImgBuff,(ssize_t) y,bpp,exception); \\\n    x=0; \\\n    y++; \\\n   } \\\n}\n/* WPG2 raster reader. */\nstatic int UnpackWPG2Raster(Image *image,int bpp,ExceptionInfo *exception)\n{\n  int\n    RunCount,\n    XorMe = 0;\n\n  size_t\n    x,\n    y;\n\n  ssize_t\n    i,\n    ldblk;\n\n  unsigned int\n    SampleSize=1;\n\n  unsigned char\n    bbuf,\n    *BImgBuff,\n    SampleBuffer[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };\n\n  x=0;\n  y=0;\n  ldblk=(ssize_t) ((bpp*image->columns+7)/8);\n  BImgBuff=(unsigned char *) AcquireQuantumMemory((size_t) ldblk,\n    sizeof(*BImgBuff));\n  if(BImgBuff==NULL)\n    return(-2);\n\n  while( y< image->rows)\n    {\n      bbuf=ReadBlobByte(image);\n\n      switch(bbuf)\n        {\n        case 0x7D:\n          SampleSize=ReadBlobByte(image);  /* DSZ */\n          if(SampleSize>8)\n            return(-2);\n          if(SampleSize<1)\n            return(-2);\n          break;\n        case 0x7E:\n          (void) FormatLocaleFile(stderr,\n            \"\\nUnsupported WPG token XOR, please report!\");\n          XorMe=!XorMe;\n          break;\n        case 0x7F:\n          RunCount=ReadBlobByte(image);   /* BLK */\n          if (RunCount < 0)\n            break;\n          for(i=0; i < SampleSize*(RunCount+1); i++)\n            {\n              InsertByte6(0);\n            }\n          break;\n        case 0xFD:\n          RunCount=ReadBlobByte(image);   /* EXT */\n          if (RunCount < 0)\n            break;\n          for(i=0; i<= RunCount;i++)\n            for(bbuf=0; bbuf < SampleSize; bbuf++)\n              InsertByte6(SampleBuffer[bbuf]);          \n          break;\n        case 0xFE:\n          RunCount=ReadBlobByte(image);  /* RST */\n          if (RunCount < 0)\n            break;\n          if(x!=0)\n            {\n              (void) FormatLocaleFile(stderr,\n                \"\\nUnsupported WPG2 unaligned token RST x=%.20g, please report!\\n\"\n                ,(double) x);\n              return(-3);\n            }\n          {\n            /* duplicate the previous row RunCount x */\n            for(i=0;i<=RunCount;i++)\n              {      \n                InsertRow(image,BImgBuff,(ssize_t) (image->rows >= y ? y : image->rows-1),\n                          bpp,exception);\n                y++;\n              }    \n          }\n          break;\n        case 0xFF:\n          RunCount=ReadBlobByte(image);   /* WHT */\n          if (RunCount < 0)\n            break;\n          for(i=0; i < SampleSize*(RunCount+1); i++)\n            {\n              InsertByte6(0xFF);\n            }\n          break;\n        default:\n          RunCount=bbuf & 0x7F;\n\n          if(bbuf & 0x80)     /* REP */\n            {  \n              for(i=0; i < SampleSize; i++)\n                SampleBuffer[i]=ReadBlobByte(image);\n              for(i=0;i<=RunCount;i++)\n                for(bbuf=0;bbuf<SampleSize;bbuf++)\n                  InsertByte6(SampleBuffer[bbuf]);\n            }\n          else {      /* NRP */\n            for(i=0; i< SampleSize*(RunCount+1);i++)\n              {\n                bbuf=ReadBlobByte(image);\n                InsertByte6(bbuf);\n              }\n          }\n        }\n      if (EOFBlob(image) != MagickFalse)\n        break;\n    }\n  BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);\n  return(0);\n}\n\n\ntypedef float tCTM[3][3];\n\nstatic unsigned LoadWPG2Flags(Image *image,char Precision,float *Angle,tCTM *CTM)\n{\nconst unsigned char TPR=1,TRN=2,SKW=4,SCL=8,ROT=0x10,OID=0x20,LCK=0x80;\nssize_t x;\nunsigned DenX;\nunsigned Flags;\n\n (void) memset(*CTM,0,sizeof(*CTM));     /*CTM.erase();CTM.resize(3,3);*/\n (*CTM)[0][0]=1;\n (*CTM)[1][1]=1;\n (*CTM)[2][2]=1;\n\n Flags=ReadBlobLSBShort(image);\n if(Flags & LCK) (void) ReadBlobLSBLong(image);  /*Edit lock*/\n if(Flags & OID)\n  {\n  if(Precision==0)\n    {(void) ReadBlobLSBShort(image);}  /*ObjectID*/\n  else\n    {(void) ReadBlobLSBLong(image);}  /*ObjectID (Double precision)*/\n  }\n if(Flags & ROT)\n  {\n  x=ReadBlobLSBLong(image);  /*Rot Angle*/\n  if(Angle) *Angle=x/65536.0;\n  }\n if(Flags & (ROT|SCL))\n  {\n  x=ReadBlobLSBLong(image);  /*Sx*cos()*/\n  (*CTM)[0][0] = (float)x/0x10000;\n  x=ReadBlobLSBLong(image);  /*Sy*cos()*/\n  (*CTM)[1][1] = (float)x/0x10000;\n  }\n if(Flags & (ROT|SKW))\n  {\n  x=ReadBlobLSBLong(image);       /*Kx*sin()*/\n  (*CTM)[1][0] = (float)x/0x10000;\n  x=ReadBlobLSBLong(image);       /*Ky*sin()*/\n  (*CTM)[0][1] = (float)x/0x10000;\n  }\n if(Flags & TRN)\n  {\n  x=ReadBlobLSBLong(image); DenX=ReadBlobLSBShort(image);  /*Tx*/\n        if(x>=0) (*CTM)[0][2] = (float)x+(float)DenX/0x10000;\n            else (*CTM)[0][2] = (float)x-(float)DenX/0x10000;\n  x=ReadBlobLSBLong(image); DenX=ReadBlobLSBShort(image);  /*Ty*/\n  (*CTM)[1][2]=(float)x + ((x>=0)?1:-1)*(float)DenX/0x10000;\n        if(x>=0) (*CTM)[1][2] = (float)x+(float)DenX/0x10000;\n            else (*CTM)[1][2] = (float)x-(float)DenX/0x10000;\n  }\n if(Flags & TPR)\n  {\n  x=ReadBlobLSBShort(image); DenX=ReadBlobLSBShort(image);  /*Px*/\n  (*CTM)[2][0] = x + (float)DenX/0x10000;;\n  x=ReadBlobLSBShort(image);  DenX=ReadBlobLSBShort(image); /*Py*/\n  (*CTM)[2][1] = x + (float)DenX/0x10000;\n  }\n return(Flags);\n}\n\n\nstatic Image *ExtractPostscript(Image *image,const ImageInfo *image_info,\n  MagickOffsetType PS_Offset,ssize_t PS_Size,ExceptionInfo *exception)\n{\n  char\n    postscript_file[MagickPathExtent];\n\n  const MagicInfo\n    *magic_info;    \n\n  FILE\n    *ps_file;\n\n  ImageInfo\n    *clone_info;\n    \n  Image\n    *image2;\n    \n  unsigned char\n    magick[2*MagickPathExtent];    \n    \n\n  if ((clone_info=CloneImageInfo(image_info)) == NULL)\n    return(image);\n  clone_info->blob=(void *) NULL;\n  clone_info->length=0;\n\n  /* Obtain temporary file */\n  (void) AcquireUniqueFilename(postscript_file);\n  ps_file=fopen_utf8(postscript_file,\"wb\");\n  if (ps_file == (FILE *) NULL)\n    goto FINISH;\n\n  /* Copy postscript to temporary file */\n  (void) SeekBlob(image,PS_Offset,SEEK_SET);\n  (void) ReadBlob(image, 2*MagickPathExtent, magick);\n  \n  (void) SeekBlob(image,PS_Offset,SEEK_SET);\n  while(PS_Size-- > 0)\n    {\n      (void) fputc(ReadBlobByte(image),ps_file);\n    }\n  (void) fclose(ps_file);\n  \n    /* Detect file format - Check magic.mgk configuration file. */\n  magic_info=GetMagicInfo(magick,2*MagickPathExtent,exception);\n  if(magic_info == (const MagicInfo *) NULL) goto FINISH_UNL;\n  /*     printf(\"Detected:%s  \\n\",magic_info->name); */\n  if(exception->severity != UndefinedException) goto FINISH_UNL;     \n  if(magic_info->name == (char *) NULL) goto FINISH_UNL;\n    \n  (void) strncpy(clone_info->magick,magic_info->name,MagickPathExtent);\n  \n    /* Read nested image */\n  /*FormatString(clone_info->filename,\"%s:%s\",magic_info->name,postscript_file);*/\n  FormatLocaleString(clone_info->filename,MagickPathExtent,\"%s\",postscript_file);\n  image2=ReadImage(clone_info,exception);\n\n  if (!image2)\n    goto FINISH_UNL;\n\n  /*\n    Replace current image with new image while copying base image\n    attributes.\n  */\n  (void) CopyMagickMemory(image2->filename,image->filename,MagickPathExtent);\n  (void) CopyMagickMemory(image2->magick_filename,image->magick_filename,MagickPathExtent);\n  (void) CopyMagickMemory(image2->magick,image->magick,MagickPathExtent);\n  image2->depth=image->depth;\n  DestroyBlob(image2);\n  image2->blob=ReferenceBlob(image->blob);\n\n  if ((image->rows == 0) || (image->columns == 0))\n    DeleteImageFromList(&image);\n\n  AppendImageToList(&image,image2);\n\n FINISH_UNL:    \n  (void) RelinquishUniqueFileResource(postscript_file);\n FINISH:\n  DestroyImageInfo(clone_info);\n  return(image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d W P G I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  Method ReadWPGImage reads an WPG X image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadWPGImage method is:\n%\n%    Image *ReadWPGImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image:  Method ReadWPGImage returns a pointer to the image after\n%      reading. A null image is returned if there is a memory shortage or if\n%      the image cannot be read.\n%\n%    o image_info: Specifies a pointer to a ImageInfo structure.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadWPGImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  typedef struct\n  {\n    size_t FileId;\n    MagickOffsetType DataOffset;\n    unsigned int ProductType;\n    unsigned int FileType;\n    unsigned char MajorVersion;\n    unsigned char MinorVersion;\n    unsigned int EncryptKey;\n    unsigned int Reserved;\n  } WPGHeader;\n\n  typedef struct\n  {\n    unsigned char RecType;\n    size_t RecordLength;\n  } WPGRecord;\n\n  typedef struct\n  {\n    unsigned char Class;\n    unsigned char RecType;\n    size_t Extension;\n    size_t RecordLength;\n  } WPG2Record;\n\n  typedef struct\n  {\n    unsigned  HorizontalUnits;\n    unsigned  VerticalUnits;\n    unsigned char PosSizePrecision;\n  } WPG2Start;\n\n  typedef struct\n  {\n    unsigned int Width;\n    unsigned int Height;\n    unsigned int Depth;\n    unsigned int HorzRes;\n    unsigned int VertRes;\n  } WPGBitmapType1;\n\n  typedef struct\n  {\n    unsigned int Width;\n    unsigned int Height;\n    unsigned char Depth;\n    unsigned char Compression;\n  } WPG2BitmapType1;\n\n  typedef struct\n  {\n    unsigned int RotAngle;\n    unsigned int LowLeftX;\n    unsigned int LowLeftY;\n    unsigned int UpRightX;\n    unsigned int UpRightY;\n    unsigned int Width;\n    unsigned int Height;\n    unsigned int Depth;\n    unsigned int HorzRes;\n    unsigned int VertRes;\n  } WPGBitmapType2;\n\n  typedef struct\n  {\n    unsigned int StartIndex;\n    unsigned int NumOfEntries;\n  } WPGColorMapRec;\n\n  /*\n  typedef struct {\n    size_t PS_unknown1;\n    unsigned int PS_unknown2;\n    unsigned int PS_unknown3;\n  } WPGPSl1Record;  \n  */\n\n  Image\n    *image;\n\n  unsigned int\n    status;\n\n  WPGHeader\n    Header;\n\n  WPGRecord\n    Rec;\n\n  WPG2Record\n    Rec2;\n\n  WPG2Start StartWPG;\n\n  WPGBitmapType1\n    BitmapHeader1;\n\n  WPG2BitmapType1\n    Bitmap2Header1;\n\n  WPGBitmapType2\n    BitmapHeader2;\n\n  WPGColorMapRec\n    WPG_Palette;\n\n  int\n    i,\n    bpp,\n    WPG2Flags;\n\n  ssize_t\n    ldblk;\n\n  size_t\n    one;\n\n  unsigned char\n    *BImgBuff;\n\n  tCTM CTM;         /*current transform matrix*/\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  one=1;\n  image=AcquireImage(image_info,exception);\n  image->depth=8;\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read WPG image.\n  */\n  Header.FileId=ReadBlobLSBLong(image);\n  Header.DataOffset=(MagickOffsetType) ReadBlobLSBLong(image);\n  Header.ProductType=ReadBlobLSBShort(image);\n  Header.FileType=ReadBlobLSBShort(image);\n  Header.MajorVersion=ReadBlobByte(image);\n  Header.MinorVersion=ReadBlobByte(image);\n  Header.EncryptKey=ReadBlobLSBShort(image);\n  Header.Reserved=ReadBlobLSBShort(image);\n\n  if (Header.FileId!=0x435057FF || (Header.ProductType>>8)!=0x16)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (Header.EncryptKey!=0)\n    ThrowReaderException(CoderError,\"EncryptedWPGImageFileNotSupported\");\n\n  image->columns = 1;\n  image->rows = 1;\n  image->colors = 0;\n  bpp=0;\n  BitmapHeader2.RotAngle=0;\n\n  switch(Header.FileType)\n    {\n    case 1:     /* WPG level 1 */\n      while(!EOFBlob(image)) /* object parser loop */\n        {\n          (void) SeekBlob(image,Header.DataOffset,SEEK_SET);\n          if(EOFBlob(image))\n            break;\n\n          Rec.RecType=(i=ReadBlobByte(image));\n          if(i==EOF)\n            break;\n          Rd_WP_DWORD(image,&Rec.RecordLength);\n          if(EOFBlob(image))\n            break;\n\n          Header.DataOffset=TellBlob(image)+Rec.RecordLength;\n\n          switch(Rec.RecType)\n            {\n            case 0x0B: /* bitmap type 1 */\n              BitmapHeader1.Width=ReadBlobLSBShort(image);\n              BitmapHeader1.Height=ReadBlobLSBShort(image);\n              if ((BitmapHeader1.Width == 0) || (BitmapHeader1.Height == 0))\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              BitmapHeader1.Depth=ReadBlobLSBShort(image);\n              BitmapHeader1.HorzRes=ReadBlobLSBShort(image);\n              BitmapHeader1.VertRes=ReadBlobLSBShort(image);\n\n              if(BitmapHeader1.HorzRes && BitmapHeader1.VertRes)\n                {\n                  image->units=PixelsPerCentimeterResolution;\n                  image->resolution.x=BitmapHeader1.HorzRes/470.0;\n                  image->resolution.y=BitmapHeader1.VertRes/470.0;\n                }\n              image->columns=BitmapHeader1.Width;\n              image->rows=BitmapHeader1.Height;\n              bpp=BitmapHeader1.Depth;\n\n              goto UnpackRaster;\n\n            case 0x0E:  /*Color palette */\n              WPG_Palette.StartIndex=ReadBlobLSBShort(image);\n              WPG_Palette.NumOfEntries=ReadBlobLSBShort(image);\n\n              image->colors=WPG_Palette.NumOfEntries;\n              if (!AcquireImageColormap(image,image->colors,exception))\n                goto NoMemory;\n              for (i=WPG_Palette.StartIndex;\n                   i < (int)WPG_Palette.NumOfEntries; i++)\n                {\n                  image->colormap[i].red=ScaleCharToQuantum((unsigned char)\n                    ReadBlobByte(image));\n                  image->colormap[i].green=ScaleCharToQuantum((unsigned char)\n                    ReadBlobByte(image));\n                  image->colormap[i].blue=ScaleCharToQuantum((unsigned char)\n                    ReadBlobByte(image));\n                }\n              break;\n     \n            case 0x11:  /* Start PS l1 */\n              if(Rec.RecordLength > 8)\n                image=ExtractPostscript(image,image_info,\n                  TellBlob(image)+8,   /* skip PS header in the wpg */\n                  (ssize_t) Rec.RecordLength-8,exception);\n              break;     \n\n            case 0x14:  /* bitmap type 2 */\n              BitmapHeader2.RotAngle=ReadBlobLSBShort(image);\n              BitmapHeader2.LowLeftX=ReadBlobLSBShort(image);\n              BitmapHeader2.LowLeftY=ReadBlobLSBShort(image);\n              BitmapHeader2.UpRightX=ReadBlobLSBShort(image);\n              BitmapHeader2.UpRightY=ReadBlobLSBShort(image);\n              BitmapHeader2.Width=ReadBlobLSBShort(image);\n              BitmapHeader2.Height=ReadBlobLSBShort(image);\n              if ((BitmapHeader2.Width == 0) || (BitmapHeader2.Height == 0))\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              BitmapHeader2.Depth=ReadBlobLSBShort(image);\n              BitmapHeader2.HorzRes=ReadBlobLSBShort(image);\n              BitmapHeader2.VertRes=ReadBlobLSBShort(image);\n\n              image->units=PixelsPerCentimeterResolution;\n              image->page.width=(unsigned int)\n                ((BitmapHeader2.LowLeftX-BitmapHeader2.UpRightX)/470.0);\n              image->page.height=(unsigned int)\n                ((BitmapHeader2.LowLeftX-BitmapHeader2.UpRightY)/470.0);\n              image->page.x=(int) (BitmapHeader2.LowLeftX/470.0);\n              image->page.y=(int) (BitmapHeader2.LowLeftX/470.0);\n              if(BitmapHeader2.HorzRes && BitmapHeader2.VertRes)\n                {\n                  image->resolution.x=BitmapHeader2.HorzRes/470.0;\n                  image->resolution.y=BitmapHeader2.VertRes/470.0;\n                }\n              image->columns=BitmapHeader2.Width;\n              image->rows=BitmapHeader2.Height;\n              bpp=BitmapHeader2.Depth;\n\n            UnpackRaster:      \n              status=SetImageExtent(image,image->columns,image->rows,exception);\n              if (status == MagickFalse)\n                break;\n              if ((image->colors == 0) && (bpp != 24))\n                {\n                  image->colors=one << bpp;\n                  if (!AcquireImageColormap(image,image->colors,exception))\n                    {\n                    NoMemory:\n                      ThrowReaderException(ResourceLimitError,\n                        \"MemoryAllocationFailed\");\n                    }\n                  /* printf(\"Load default colormap \\n\"); */\n                  for (i=0; (i < (int) image->colors) && (i < 256); i++)\n                    {               \n                      image->colormap[i].red=ScaleCharToQuantum(WPG1_Palette[i].Red);\n                      image->colormap[i].green=ScaleCharToQuantum(WPG1_Palette[i].Green);\n                      image->colormap[i].blue=ScaleCharToQuantum(WPG1_Palette[i].Blue);\n                    }\n                }\n              else\n                {\n                  if (bpp < 24)\n                    if ( (image->colors < (one << bpp)) && (bpp != 24) )\n                      image->colormap=(PixelInfo *) ResizeQuantumMemory(\n                        image->colormap,(size_t) (one << bpp),\n                        sizeof(*image->colormap));\n                }\n          \n              if (bpp == 1)\n                {\n                  if(image->colormap[0].red==0 &&\n                     image->colormap[0].green==0 &&\n                     image->colormap[0].blue==0 &&\n                     image->colormap[1].red==0 &&\n                     image->colormap[1].green==0 &&\n                     image->colormap[1].blue==0)\n                    {  /* fix crippled monochrome palette */\n                      image->colormap[1].red =\n                        image->colormap[1].green =\n                        image->colormap[1].blue = QuantumRange;\n                    }\n                }      \n\n              if(UnpackWPGRaster(image,bpp,exception) < 0)\n                /* The raster cannot be unpacked */\n                {\n                DecompressionFailed:\n                  ThrowReaderException(CoderError,\"UnableToDecompressImage\");\n                    }\n\n              if(Rec.RecType==0x14 && BitmapHeader2.RotAngle!=0 && !image_info->ping)\n                {  \n                  /* flop command */\n                  if(BitmapHeader2.RotAngle & 0x8000)\n                    {\n                      Image\n                        *flop_image;\n\n                      flop_image = FlopImage(image, exception);\n                      if (flop_image != (Image *) NULL) {\n                        DuplicateBlob(flop_image,image);\n                        (void) RemoveLastImageFromList(&image);\n                        AppendImageToList(&image,flop_image);\n                      }\n                    }\n                  /* flip command */\n                  if(BitmapHeader2.RotAngle & 0x2000)\n                    {\n                      Image\n                        *flip_image;\n\n                      flip_image = FlipImage(image, exception);\n                      if (flip_image != (Image *) NULL) {\n                        DuplicateBlob(flip_image,image);\n                        (void) RemoveLastImageFromList(&image);\n                        AppendImageToList(&image,flip_image);\n                      }\n                    }\n                  /* rotate command */\n                  if(BitmapHeader2.RotAngle & 0x0FFF)\n                    {\n                      Image\n                        *rotate_image;\n\n                      rotate_image=RotateImage(image,(BitmapHeader2.RotAngle &\n                        0x0FFF), exception);\n                      if (rotate_image != (Image *) NULL) {\n                        DuplicateBlob(rotate_image,image);\n                        (void) RemoveLastImageFromList(&image);\n                        AppendImageToList(&image,rotate_image);\n                      }\n                    }\n                }\n\n              /* Allocate next image structure. */\n              AcquireNextImage(image_info,image,exception);\n              image->depth=8;\n              if (image->next == (Image *) NULL)\n                goto Finish;\n              image=SyncNextImageInList(image);\n              image->columns=image->rows=1;\n              image->colors=0;\n              break;\n\n            case 0x1B:  /* Postscript l2 */\n              if(Rec.RecordLength>0x3C)\n                image=ExtractPostscript(image,image_info,\n                  TellBlob(image)+0x3C,   /* skip PS l2 header in the wpg */\n                  (ssize_t) Rec.RecordLength-0x3C,exception);\n              break;\n            }\n        }\n      break;\n\n    case 2:  /* WPG level 2 */\n      (void) memset(CTM,0,sizeof(CTM));\n      StartWPG.PosSizePrecision = 0;\n      while(!EOFBlob(image)) /* object parser loop */\n        {\n          (void) SeekBlob(image,Header.DataOffset,SEEK_SET);\n          if(EOFBlob(image))\n            break;\n\n          Rec2.Class=(i=ReadBlobByte(image));\n          if(i==EOF)\n            break;\n          Rec2.RecType=(i=ReadBlobByte(image));\n          if(i==EOF)\n            break;\n          Rd_WP_DWORD(image,&Rec2.Extension);\n          Rd_WP_DWORD(image,&Rec2.RecordLength);\n          if(EOFBlob(image))\n            break;\n\n          Header.DataOffset=TellBlob(image)+Rec2.RecordLength;\n\n          switch(Rec2.RecType)\n            {\n      case 1:\n              StartWPG.HorizontalUnits=ReadBlobLSBShort(image);\n              StartWPG.VerticalUnits=ReadBlobLSBShort(image);\n              StartWPG.PosSizePrecision=ReadBlobByte(image);\n              break;\n            case 0x0C:    /* Color palette */\n              WPG_Palette.StartIndex=ReadBlobLSBShort(image);\n              WPG_Palette.NumOfEntries=ReadBlobLSBShort(image);\n\n              image->colors=WPG_Palette.NumOfEntries;\n              if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              for (i=WPG_Palette.StartIndex;\n                   i < (int)WPG_Palette.NumOfEntries; i++)\n                {\n                  image->colormap[i].red=ScaleCharToQuantum((char)\n                    ReadBlobByte(image));\n                  image->colormap[i].green=ScaleCharToQuantum((char)\n                    ReadBlobByte(image));\n                  image->colormap[i].blue=ScaleCharToQuantum((char)\n                    ReadBlobByte(image));\n                  (void) ReadBlobByte(image);   /*Opacity??*/\n                }\n              break;\n            case 0x0E:\n              Bitmap2Header1.Width=ReadBlobLSBShort(image);\n              Bitmap2Header1.Height=ReadBlobLSBShort(image);\n              if ((Bitmap2Header1.Width == 0) || (Bitmap2Header1.Height == 0))\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              Bitmap2Header1.Depth=ReadBlobByte(image);\n              Bitmap2Header1.Compression=ReadBlobByte(image);\n\n              if(Bitmap2Header1.Compression > 1)\n                continue; /*Unknown compression method */\n              switch(Bitmap2Header1.Depth)\n                {\n                case 1:\n                  bpp=1;\n                  break;\n                case 2:\n                  bpp=2;\n                  break;\n                case 3:\n                  bpp=4;\n                  break;\n                case 4:\n                  bpp=8;\n                  break;\n                case 8:\n                  bpp=24;\n                  break;\n                default:\n                  continue;  /*Ignore raster with unknown depth*/\n                }\n              image->columns=Bitmap2Header1.Width;\n              image->rows=Bitmap2Header1.Height;\n              status=SetImageExtent(image,image->columns,image->rows,exception);\n              if (status == MagickFalse)\n                break;\n              if ((image->colors == 0) && (bpp != 24))\n                {\n                  size_t\n                    one;\n\n                  one=1;\n                  image->colors=one << bpp;\n                  if (!AcquireImageColormap(image,image->colors,exception))\n                    goto NoMemory;\n                }\n              else\n                {\n                  if(bpp < 24)\n                    if( image->colors<(one << bpp) && bpp!=24 )\n                      image->colormap=(PixelInfo *) ResizeQuantumMemory(\n                       image->colormap,(size_t) (one << bpp),\n                       sizeof(*image->colormap));\n                }\n\n\n              switch(Bitmap2Header1.Compression)\n                {\n                case 0:    /*Uncompressed raster*/\n                  {\n                    ldblk=(ssize_t) ((bpp*image->columns+7)/8);\n                    BImgBuff=(unsigned char *) AcquireQuantumMemory((size_t)\n                      ldblk+1,sizeof(*BImgBuff));\n                    if (BImgBuff == (unsigned char *) NULL)\n                      goto NoMemory;\n\n                    for(i=0; i< (ssize_t) image->rows; i++)\n                      {\n                        (void) ReadBlob(image,ldblk,BImgBuff);\n                        InsertRow(image,BImgBuff,i,bpp,exception);\n                      }\n\n                    if(BImgBuff)\n                      BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);\n                    break;\n                  }\n                case 1:    /*RLE for WPG2 */\n                  {\n                    if( UnpackWPG2Raster(image,bpp,exception) < 0)\n                      goto DecompressionFailed;\n                    break;\n                  }   \n                }\n\n              if(CTM[0][0]<0 && !image_info->ping)\n                {    /*?? RotAngle=360-RotAngle;*/\n                  Image\n                    *flop_image;\n\n                  flop_image = FlopImage(image, exception);\n                  if (flop_image != (Image *) NULL) {\n                    DuplicateBlob(flop_image,image);\n                    (void) RemoveLastImageFromList(&image);\n                    AppendImageToList(&image,flop_image);\n                  }\n                  /* Try to change CTM according to Flip - I am not sure, must be checked.\n                     Tx(0,0)=-1;      Tx(1,0)=0;   Tx(2,0)=0;\n                     Tx(0,1)= 0;      Tx(1,1)=1;   Tx(2,1)=0;\n                     Tx(0,2)=(WPG._2Rect.X_ur+WPG._2Rect.X_ll);\n                     Tx(1,2)=0;   Tx(2,2)=1; */\n                }\n              if(CTM[1][1]<0 && !image_info->ping)\n                {    /*?? RotAngle=360-RotAngle;*/\n                  Image\n                    *flip_image;\n\n                   flip_image = FlipImage(image, exception);\n                   if (flip_image != (Image *) NULL) {\n                     DuplicateBlob(flip_image,image);\n                     (void) RemoveLastImageFromList(&image);\n                     AppendImageToList(&image,flip_image);\n                    }\n                  /* Try to change CTM according to Flip - I am not sure, must be checked.\n                     float_matrix Tx(3,3);\n                     Tx(0,0)= 1;   Tx(1,0)= 0;   Tx(2,0)=0;\n                     Tx(0,1)= 0;   Tx(1,1)=-1;   Tx(2,1)=0;\n                     Tx(0,2)= 0;   Tx(1,2)=(WPG._2Rect.Y_ur+WPG._2Rect.Y_ll);\n                     Tx(2,2)=1; */\n              }\n\n\n              /* Allocate next image structure. */\n              AcquireNextImage(image_info,image,exception);\n              image->depth=8;\n              if (image->next == (Image *) NULL)\n                goto Finish;\n              image=SyncNextImageInList(image);\n              image->columns=image->rows=1;\n              image->colors=0;\n              break;\n\n            case 0x12:  /* Postscript WPG2*/\n        i=ReadBlobLSBShort(image);\n              if(Rec2.RecordLength > (unsigned int) i)\n                image=ExtractPostscript(image,image_info,\n                  TellBlob(image)+i,    /*skip PS header in the wpg2*/\n                  (ssize_t) (Rec2.RecordLength-i-2),exception);\n              break;\n\n      case 0x1B:          /*bitmap rectangle*/\n              WPG2Flags = LoadWPG2Flags(image,StartWPG.PosSizePrecision,NULL,&CTM);\n              (void) WPG2Flags;\n              break;\n            }\n        }\n\n      break;\n\n    default:\n      {\n         ThrowReaderException(CoderError,\"DataEncodingSchemeIsNotSupported\");\n      }\n   }\n\n Finish:\n  (void) CloseBlob(image);\n\n  {\n    Image\n      *p;\n\n    ssize_t\n      scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n    /*\n      Fix scene numbers.\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=(size_t) scene++;\n  }\n  if (image == (Image *) NULL)\n    ThrowReaderException(CorruptImageError,\n      \"ImageFileDoesNotContainAnyImageData\");\n  return(image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r W P G I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  Method RegisterWPGImage adds attributes for the WPG image format to\n%  the list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterWPGImage method is:\n%\n%      size_t RegisterWPGImage(void)\n%\n*/\nModuleExport size_t RegisterWPGImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"WPG\",\"WPG\",\"Word Perfect Graphics\");\n  entry->decoder=(DecodeImageHandler *) ReadWPGImage;\n  entry->magick=(IsImageFormatHandler *) IsWPG;\n  entry->flags|=CoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r W P G I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  Method UnregisterWPGImage removes format registrations made by the\n%  WPG module from the list of supported formats.\n%\n%  The format of the UnregisterWPGImage method is:\n%\n%      UnregisterWPGImage(void)\n%\n*/\nModuleExport void UnregisterWPGImage(void)\n{\n  (void) UnregisterMagickInfo(\"WPG\");\n}\n"], "filenames": ["MagickCore/cache.c", "MagickCore/image.c", "coders/wpg.c"], "buggy_code_start_loc": [3555, 855, 1319], "buggy_code_end_loc": [3657, 856, 1320], "fixing_code_start_loc": [3556, 855, 1318], "fixing_code_end_loc": [3665, 859, 1318], "type": "CWE-119", "message": "The WPG parser in ImageMagick before 6.9.4-4 and 7.x before 7.0.1-5, when a memory limit is set, allows remote attackers to have unspecified impact via vectors related to the SetImageExtent return-value check, which trigger (1) a heap-based buffer overflow in the SetPixelIndex function or an invalid write operation in the (2) ScaleCharToQuantum or (3) SetPixelIndex functions.", "other": {"cve": {"id": "CVE-2016-5688", "sourceIdentifier": "cve@mitre.org", "published": "2016-12-13T15:59:01.217", "lastModified": "2016-12-16T16:38:02.250", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The WPG parser in ImageMagick before 6.9.4-4 and 7.x before 7.0.1-5, when a memory limit is set, allows remote attackers to have unspecified impact via vectors related to the SetImageExtent return-value check, which trigger (1) a heap-based buffer overflow in the SetPixelIndex function or an invalid write operation in the (2) ScaleCharToQuantum or (3) SetPixelIndex functions."}, {"lang": "es", "value": "El analizador WPG en ImageMagick en versiones anteriores a 6.9.4-4 y 7.x en versiones anteriores a 7.0.1-5, cuando se establece un l\u00edmite de memoria, permite a atacantes remotos tener un impacto no especificado a trav\u00e9s de vectores relacionados con la comprobaci\u00f3n del valor de retorno SetImageExtent, lo que desencadena (1) un desbordamiento de b\u00fafer basado en memoria din\u00e1mica en la funci\u00f3n SetPixelIndex o una operaci\u00f3n de escritura no v\u00e1lida en las funciones (2) ScaleCharToQuantum o (3) SetPixelIndex."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:oracle:solaris:11.3:*:*:*:*:*:*:*", "matchCriteriaId": "79A602C5-61FE-47BA-9786-F045B6C6DBA8"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionEndIncluding": "6.9.4-3", "matchCriteriaId": "F6DB4059-C842-4A82-8B13-195082EB457E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-0:*:*:*:*:*:*:*", "matchCriteriaId": "693C9F8F-A8C1-4D06-8F31-E085E16E701C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-1:*:*:*:*:*:*:*", "matchCriteriaId": "6D3D3DFC-8459-41BA-BF3E-AE84E48FCEE7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-2:*:*:*:*:*:*:*", "matchCriteriaId": "A3E12EB4-B8F6-43A3-847D-DBC96AE10905"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-3:*:*:*:*:*:*:*", "matchCriteriaId": "30539421-5872-4C2E-94AE-8A2B05C952C0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-4:*:*:*:*:*:*:*", "matchCriteriaId": "1A5B7537-8563-409D-82DE-EB07107D3C04"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2016/06/14/5", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/06/17/3", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.oracle.com/technetwork/topics/security/bulletinjul2016-3090568.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/91283", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://blog.fuzzing-project.org/46-Various-invalid-memory-reads-in-ImageMagick-WPG,-DDS,-DCM.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/aecd0ada163a4d6c769cec178955d5f3e9316f2f", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/fc43974d34318c834fbf78570ca1a3764ed8c7d7", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commits/6.9.4-4", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commits/7.0.1-5", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/aecd0ada163a4d6c769cec178955d5f3e9316f2f"}}