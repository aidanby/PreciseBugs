{"buggy_code": ["package install\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"github.com/cnlh/nps/lib/common\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nfunc InstallNps() {\n\tpath := common.GetInstallPath()\n\tif common.FileExists(path) {\n\t\tlog.Fatalf(\"the path %s has exist, does not support install\", path)\n\t}\n\tMkidrDirAll(path, \"conf\", \"web/static\", \"web/views\")\n\t//\u590d\u5236\u6587\u4ef6\u5230\u5bf9\u5e94\u76ee\u5f55\n\tif err := CopyDir(filepath.Join(common.GetAppPath(), \"web\", \"views\"), filepath.Join(path, \"web\", \"views\")); err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\tif err := CopyDir(filepath.Join(common.GetAppPath(), \"web\", \"static\"), filepath.Join(path, \"web\", \"static\")); err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\tif err := CopyDir(filepath.Join(common.GetAppPath(), \"conf\"), filepath.Join(path, \"conf\")); err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\n\tif !common.IsWindows() {\n\t\tif _, err := copyFile(filepath.Join(common.GetAppPath(), \"nps\"), \"/usr/bin/nps\"); err != nil {\n\t\t\tif _, err := copyFile(filepath.Join(common.GetAppPath(), \"nps\"), \"/usr/local/bin/nps\"); err != nil {\n\t\t\t\tlog.Fatalln(err)\n\t\t\t} else {\n\t\t\t\tos.Chmod(\"/usr/local/bin/nps\", 0777)\n\t\t\t\tlog.Println(\"Executable files have been copied to\", \"/usr/local/bin/nps\")\n\t\t\t}\n\t\t} else {\n\t\t\tos.Chmod(\"/usr/bin/nps\", 0777)\n\t\t\tlog.Println(\"Executable files have been copied to\", \"/usr/bin/nps\")\n\t\t}\n\n\t}\n\tlog.Println(\"install ok!\")\n\tlog.Println(\"Static files and configuration files in the current directory will be useless\")\n\tlog.Println(\"The new configuration file is located in\", path, \"you can edit them\")\n\tif !common.IsWindows() {\n\t\tlog.Println(\"You can start with nps test|start|stop|restart|status anywhere\")\n\t} else {\n\t\tlog.Println(\"You can copy executable files to any directory and start working with nps.exe test|start|stop|restart|status\")\n\t}\n}\nfunc MkidrDirAll(path string, v ...string) {\n\tfor _, item := range v {\n\t\tif err := os.MkdirAll(filepath.Join(path, item), 0755); err != nil {\n\t\t\tlog.Fatalf(\"Failed to create directory %s error:%s\", path, err.Error())\n\t\t}\n\t}\n}\n\nfunc CopyDir(srcPath string, destPath string) error {\n\t//\u68c0\u6d4b\u76ee\u5f55\u6b63\u786e\u6027\n\tif srcInfo, err := os.Stat(srcPath); err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t} else {\n\t\tif !srcInfo.IsDir() {\n\t\t\te := errors.New(\"SrcPath is not the right directory!\")\n\t\t\treturn e\n\t\t}\n\t}\n\tif destInfo, err := os.Stat(destPath); err != nil {\n\t\treturn err\n\t} else {\n\t\tif !destInfo.IsDir() {\n\t\t\te := errors.New(\"DestInfo is not the right directory!\")\n\t\t\treturn e\n\t\t}\n\t}\n\terr := filepath.Walk(srcPath, func(path string, f os.FileInfo, err error) error {\n\t\tif f == nil {\n\t\t\treturn err\n\t\t}\n\t\tif !f.IsDir() {\n\t\t\tdestNewPath := strings.Replace(path, srcPath, destPath, -1)\n\t\t\tlog.Println(\"copy file ::\" + path + \" to \" + destNewPath)\n\t\t\tcopyFile(path, destNewPath)\n\t\t}\n\t\treturn nil\n\t})\n\treturn err\n}\n\n//\u751f\u6210\u76ee\u5f55\u5e76\u62f7\u8d1d\u6587\u4ef6\nfunc copyFile(src, dest string) (w int64, err error) {\n\tsrcFile, err := os.Open(src)\n\tif err != nil {\n\t\treturn\n\t}\n\tdefer srcFile.Close()\n\t//\u5206\u5272path\u76ee\u5f55\n\tdestSplitPathDirs := strings.Split(dest, string(filepath.Separator))\n\n\t//\u68c0\u6d4b\u65f6\u5019\u5b58\u5728\u76ee\u5f55\n\tdestSplitPath := \"\"\n\tfor index, dir := range destSplitPathDirs {\n\t\tif index < len(destSplitPathDirs)-1 {\n\t\t\tdestSplitPath = destSplitPath + dir + string(filepath.Separator)\n\t\t\tb, _ := pathExists(destSplitPath)\n\t\t\tif b == false {\n\t\t\t\tlog.Println(\"mkdir:\" + destSplitPath)\n\t\t\t\t//\u521b\u5efa\u76ee\u5f55\n\t\t\t\terr := os.Mkdir(destSplitPath, os.ModePerm)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Fatalln(err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdstFile, err := os.Create(dest)\n\tif err != nil {\n\t\treturn\n\t}\n\tdefer dstFile.Close()\n\n\treturn io.Copy(dstFile, srcFile)\n}\n\n//\u68c0\u6d4b\u6587\u4ef6\u5939\u8def\u5f84\u65f6\u5019\u5b58\u5728\nfunc pathExists(path string) (bool, error) {\n\t_, err := os.Stat(path)\n\tif err == nil {\n\t\treturn true, nil\n\t}\n\tif os.IsNotExist(err) {\n\t\treturn false, nil\n\t}\n\treturn false, err\n}\n"], "fixing_code": ["package install\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"github.com/cnlh/nps/lib/common\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nfunc InstallNps() {\n\tpath := common.GetInstallPath()\n\tif common.FileExists(path) {\n\t\tlog.Fatalf(\"the path %s has exist, does not support install\", path)\n\t}\n\tMkidrDirAll(path, \"conf\", \"web/static\", \"web/views\")\n\t//\u590d\u5236\u6587\u4ef6\u5230\u5bf9\u5e94\u76ee\u5f55\n\tif err := CopyDir(filepath.Join(common.GetAppPath(), \"web\", \"views\"), filepath.Join(path, \"web\", \"views\")); err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\tif err := CopyDir(filepath.Join(common.GetAppPath(), \"web\", \"static\"), filepath.Join(path, \"web\", \"static\")); err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\tif err := CopyDir(filepath.Join(common.GetAppPath(), \"conf\"), filepath.Join(path, \"conf\")); err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\n\tif !common.IsWindows() {\n\t\tif _, err := copyFile(filepath.Join(common.GetAppPath(), \"nps\"), \"/usr/bin/nps\"); err != nil {\n\t\t\tif _, err := copyFile(filepath.Join(common.GetAppPath(), \"nps\"), \"/usr/local/bin/nps\"); err != nil {\n\t\t\t\tlog.Fatalln(err)\n\t\t\t} else {\n\t\t\t\tos.Chmod(\"/usr/local/bin/nps\", 0755)\n\t\t\t\tlog.Println(\"Executable files have been copied to\", \"/usr/local/bin/nps\")\n\t\t\t}\n\t\t} else {\n\t\t\tos.Chmod(\"/usr/bin/nps\", 0755)\n\t\t\tlog.Println(\"Executable files have been copied to\", \"/usr/bin/nps\")\n\t\t}\n\n\t}\n\tlog.Println(\"install ok!\")\n\tlog.Println(\"Static files and configuration files in the current directory will be useless\")\n\tlog.Println(\"The new configuration file is located in\", path, \"you can edit them\")\n\tif !common.IsWindows() {\n\t\tlog.Println(\"You can start with nps test|start|stop|restart|status anywhere\")\n\t} else {\n\t\tlog.Println(\"You can copy executable files to any directory and start working with nps.exe test|start|stop|restart|status\")\n\t}\n}\nfunc MkidrDirAll(path string, v ...string) {\n\tfor _, item := range v {\n\t\tif err := os.MkdirAll(filepath.Join(path, item), 0755); err != nil {\n\t\t\tlog.Fatalf(\"Failed to create directory %s error:%s\", path, err.Error())\n\t\t}\n\t}\n}\n\nfunc CopyDir(srcPath string, destPath string) error {\n\t//\u68c0\u6d4b\u76ee\u5f55\u6b63\u786e\u6027\n\tif srcInfo, err := os.Stat(srcPath); err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t} else {\n\t\tif !srcInfo.IsDir() {\n\t\t\te := errors.New(\"SrcPath is not the right directory!\")\n\t\t\treturn e\n\t\t}\n\t}\n\tif destInfo, err := os.Stat(destPath); err != nil {\n\t\treturn err\n\t} else {\n\t\tif !destInfo.IsDir() {\n\t\t\te := errors.New(\"DestInfo is not the right directory!\")\n\t\t\treturn e\n\t\t}\n\t}\n\terr := filepath.Walk(srcPath, func(path string, f os.FileInfo, err error) error {\n\t\tif f == nil {\n\t\t\treturn err\n\t\t}\n\t\tif !f.IsDir() {\n\t\t\tdestNewPath := strings.Replace(path, srcPath, destPath, -1)\n\t\t\tlog.Println(\"copy file ::\" + path + \" to \" + destNewPath)\n\t\t\tcopyFile(path, destNewPath)\n\t\t}\n\t\treturn nil\n\t})\n\treturn err\n}\n\n//\u751f\u6210\u76ee\u5f55\u5e76\u62f7\u8d1d\u6587\u4ef6\nfunc copyFile(src, dest string) (w int64, err error) {\n\tsrcFile, err := os.Open(src)\n\tif err != nil {\n\t\treturn\n\t}\n\tdefer srcFile.Close()\n\t//\u5206\u5272path\u76ee\u5f55\n\tdestSplitPathDirs := strings.Split(dest, string(filepath.Separator))\n\n\t//\u68c0\u6d4b\u65f6\u5019\u5b58\u5728\u76ee\u5f55\n\tdestSplitPath := \"\"\n\tfor index, dir := range destSplitPathDirs {\n\t\tif index < len(destSplitPathDirs)-1 {\n\t\t\tdestSplitPath = destSplitPath + dir + string(filepath.Separator)\n\t\t\tb, _ := pathExists(destSplitPath)\n\t\t\tif b == false {\n\t\t\t\tlog.Println(\"mkdir:\" + destSplitPath)\n\t\t\t\t//\u521b\u5efa\u76ee\u5f55\n\t\t\t\terr := os.Mkdir(destSplitPath, os.ModePerm)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Fatalln(err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdstFile, err := os.Create(dest)\n\tif err != nil {\n\t\treturn\n\t}\n\tdefer dstFile.Close()\n\n\treturn io.Copy(dstFile, srcFile)\n}\n\n//\u68c0\u6d4b\u6587\u4ef6\u5939\u8def\u5f84\u65f6\u5019\u5b58\u5728\nfunc pathExists(path string) (bool, error) {\n\t_, err := os.Stat(path)\n\tif err == nil {\n\t\treturn true, nil\n\t}\n\tif os.IsNotExist(err) {\n\t\treturn false, nil\n\t}\n\treturn false, err\n}\n"], "filenames": ["lib/install/install.go"], "buggy_code_start_loc": [36], "buggy_code_end_loc": [41], "fixing_code_start_loc": [36], "fixing_code_end_loc": [41], "type": "CWE-732", "message": "lib/install/install.go in cnlh nps through 0.23.2 uses 0777 permissions for /usr/local/bin/nps and/or /usr/bin/nps, leading to a file overwrite by a local user.", "other": {"cve": {"id": "CVE-2019-15119", "sourceIdentifier": "cve@mitre.org", "published": "2019-08-16T15:15:11.950", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "lib/install/install.go in cnlh nps through 0.23.2 uses 0777 permissions for /usr/local/bin/nps and/or /usr/bin/nps, leading to a file overwrite by a local user."}, {"lang": "es", "value": "La biblioteca lib/install/install.go en cnlh nps versiones hasta 0.23.2 utiliza los permisos 0777 para /usr/local/bin/nps y/o /usr/bin/nps, conllevando a la sobreescritura de un archivo por parte de un usuario local."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:H/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-732"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nps_project:nps:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.23.2", "matchCriteriaId": "D3BC0BFD-CAE4-43CF-8930-6974E168502D"}]}]}], "references": [{"url": "https://github.com/cnlh/nps/commit/7178b3380720e910d283036a8d39879a94105515", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/cnlh/nps/issues/176", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/cnlh/nps/commit/7178b3380720e910d283036a8d39879a94105515"}}